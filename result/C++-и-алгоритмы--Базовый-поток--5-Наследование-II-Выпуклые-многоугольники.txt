Сегодня продолжаем говорить про наследование. Давайте вспомним, на чем мы остановились в прошлый раз.
В прошлый раз мы говорили про то, что ссылки указателей на базовый класс на самом деле могут
ссылаться и на объекты производного класса. У меня есть некоторый класс A, есть класс B,
который публично унаследован от A. Это означает, что внешний код имеет право знать о том,
что B каким-то образом связан с A, точнее унаследован от A. Поэтому где-то во внешнем коде,
неважно, в мейне или в какой-то другой функции я могу сделать следующую вещь. Я могу создать
объект типа B и создать ссылку на A, но при этом сделать так, чтобы она указывала на объект B.
Вот тут вот создаю объект B, создаю Bptr, который на самом деле является указателем на A, но при этом
он хранит в себе адрес объекта B. Мы говорили про то, что если у меня и в классе A, и в классе B
есть одна и та же функция F, давайте говорить о том, что они имеют одинаковую сигнатуру, то если я
через этот указатель буду вызывать функцию F, то у меня будет вызываться метод, который расположен в
классе A. Почему? Потому что статический тип объекта Bptr, точнее указатель Bptr, это указатель на A.
Соответственно, компилятор видит, что это указатель на A, поэтому он предполагает, что
наверное надо вызывать именно метод F. Но при этом, наверное, хотелось бы немного другого поведения,
хотелось бы примерно следующего. Мы бы хотели понимать, что если у нас есть какой-то указатель,
и этот указатель может указывать как на объект базового класса, так и на объект производного
класса, то мы хотим, чтобы по этому указателю выбиралась именно та функция, точнее выбор
функции осуществлялась именно на основании того, какой на самом деле объект там лежит,
а не на основании типа самого указателя. Понятна проблема? Хотелось бы, наверное,
достичь какого-то такого поведения. И это можно сделать с помощью механизма виртуальных функций,
ну или виртуальных методов. Как это работает? Давайте я просто возьму и в базовом классе перед
именем метода напишу ключевое слово virtual. Что это означает? Что означает ключевое слово
virtual? Ключевое слово virtual означает, что выбор класса, из которого нужно вызвать этот метод,
он должен осуществляться непосредственно на основании типа, который лежит под указателем или
ссылкой, но не на основании статического типа указателей или ссылки. Что у меня тут происходит?
У меня тут есть в классе A виртуальная функция f, которая выводит на экран, что вызвана функция f
из класса A. А в структуре B я пишу точно такую же функцию, но она при этом выводит на экран,
что вызвана функция из B. При этом, да, тут надо подчеркнуть, что если в классе A функцию f объявил
виртуальный, то и во всех наследниках эта же функция будет виртуальной, то есть не обязательно
везде писать ключевое слово virtual. То есть как только функция стала виртуальной, дальше во всех
наследниках эта функция автоматически будет виртуальной. И теперь смотрите, что происходит. Я
создаю объект типа B, снова создаю указатель, который имеет тип A со звездой, но при этом он
указывает на объект типа B. И дальше я через этот указатель вызываю f. И вот в этот момент происходит
магия. В этот момент у меня вызывается функция f, которая находится не в классе A, а которая находится
в классе B. Почему? Потому что ключевое слово virtual как раз таки об этом говорит, что выбор функции
должен осуществляться непосредственно на основании вот того объекта, который там лежит, а не на
основании того, какой указатель, короче, а не на основании типа указателя. Понятно? Вот. Соответственно,
в этом назначение виртуальных функций. Виртуальные функции позволяют через указатели или ссылки,
то есть тут важный момент, именно через указатели и ссылки позволяет вам вызывать именно ту версию
функции, которая расположена непосредственно в самом объекте, который там лежит, а не на основании
типа указателей или ссылки. Вот. Соответственно, этот механизм еще называется механизм позднего
связывания. Ну, почему позднего связывания? Ну, вот дело в том, что до этого у нас все вызовы функций,
давайте сюда вернемся. Вот здесь выбор функции, то есть непосредственно вот какая функция будет
вызвана, это решение принималось на этапе компиляции. Вот это называется раннее связывание. То есть
раннее связывание говорит о том, что выбор. Вот именно выбор функции, которая будет вызвана,
осуществляется на этапе компиляции. То есть вот на этапе компиляции, здесь будет, ну в
код Assembler будет подставлен именно вызов функции f, которая находится в a. Здесь же, когда мы используем
виртуальные функции, используется механизм позднего связывания. Механизм позднего связывания
работает не во время компиляции, а непосредственно во время исполнения программы. То есть позднее
Говорить нам о том, что выбор
непосредственной функции, которая будет вызвана
будет осуществляться во время
работы программ,
а не во время компиляции.
Кто-нибудь может привести пример из первого
семестра, когда у нас осуществлялось
такое позднее связывание,
а не раннее связывание?
У вас на самом деле был
такой пример?
Приведите пример,
когда у вас функция вызывается,
точнее выбор функции,
которая будет вызвана происходит не на этапе компиляции,
а во время исполнения программы.
Но это указатель на функцию на самом деле.
Представьте себе, что
у вас есть
какая-то функция f,
есть какая-то функция g,
и есть функция
call,
которая принимает указатель на функцию
и внутри осуществляет вызов
этой самой функции.
Теперь я могу
в эту функцию передавать
либо f,
либо g.
Понятное дело, я могу это делать
непосредственно
вот так, например,
sin
x,
и там, например,
if x
равно-равно нулю,
я делаю call
f else
call g.
То есть здесь выбор функции,
которая будет вызвана, происходит не на этапе компиляции,
а на этапе выполнения программы.
Именно на этапе выполнения программы, вот здесь вместо ptr
будет подставлена конкретная функция,
а потом она будет вызвана.
То есть понятное дело, что на этапе компиляции
у компиляторов в принципе нет никакой возможности понять,
какую функцию здесь нужно вызывать.
Потому что указатель происходит
во время выполнения программы,
а не во время компиляции.
Пример понятен?
Да, ну и собственно
про механизм позднего связывания поговорили,
давайте вот тут
еще пример разберем, значит смотрите, что тут происходит.
Вот здесь есть ф, есть класс a, есть виртуальный метод f
и есть обычный метод g.
Есть структура b, в которой объявлены
точно такие же методы f и g, но при этом
мы помним, что f по-прежнему виртуальная,
потому что виртуальность она наследуется.
И теперь здесь, когда я вызываю функцию g,
у меня вот сюда
именно код,
тот код, который приводит
к вызову функции g, он подставляется непосредственно
во время компиляции.
А вот здесь выбор функции f конкретный,
то есть либо из a, либо из b,
то есть сходит во время исполнения программы,
но не во время компиляции, окей?
Ну и соответственно,
вот такой вопрос, как я сказал,
во второй строке решение откладывается,
то есть компилятор здесь на самом деле не подставляет
никакого кода, точнее он там пишет особый код,
но при этом конкретную функцию туда
не подставляет, а откладывает
это все на момент
рантайма, на момент выполнения
программы. Это вот вопрос, а в чем проблема?
Почему нельзя просто так взять и, скажем, сюда
подставить вызов функции,
которая находится в b?
Кажется, компилятор вполне себе может проанализировать ваш код,
понять, что
указатель на a на самом деле
ссылается на объект b, и поэтому здесь нужно
вызвать g, который находится в b.
В чем проблема? Зачем это нужно откладывать?
Зачем нужно позднее связывание? Почему нельзя обойтись
только ранним связыванием?
В чем проблема определения
функции f на этапе
компиляции? Почему здесь нельзя просто так взять
и сразу подставить b.2.f?
Почему компилятор
так не может сделать?
Сложно.
Смотрите, ответ такой.
Дело в том, что в данном случае компилятор
конечно может это сделать, и
вполне вероятно он так и сделает. Здесь,
если с достаточно
уровнем
оптимизации вы запускаете компиляцию,
возможно он это как-то соптимизирует и здесь
сразу поставит вызов функции b.
Но в общем случае он этого сделать не может.
И вот почему. Дело в том, что у вас
фактически
объект, на который будет указывать a,
может зависеть от каких-то
параметров, которые будут
известны только на этапе выполнения программы.
Я уже приводил этот пример
с указателем на функцию.
Смотрите, у меня есть x.
Я x вожу с клавиатуры.
Понятное дело, что компиляторы пока не научились
делать действия пользователей. То есть компилятор не может предсказать,
а что же будет на самом деле введено.
Понятно? То есть я могу ввести 1,
2, 3, могу ввести 0 или вообще
что угодно. И здесь в зависимости
от того, ввел я 0 или нет, у меня
указатель ptr указывает либо на объект
типа b, new b, либо на объект
типа a, new a.
Ну и понятное дело, что вот в данный момент,
что когда компилятор читает ваш код, ему в принципе
не понятно, а какую функцию f нужно вызвать.
Которая находится в b или которая в a.
Понятно?
На этапе компиляции это сделать просто нельзя.
Это не всегда возможно.
вот пример, когда этого сделать тупо нельзя.
Вот для этого существует механизм позднего связ Goo.
Решение о том, какая функция
будет вызвана, откладывается до момента
исполнения программы.
Вот. Ну и как здесь написано
позднее связ10 действительно оно
более затратно, чем раннее связ00.
У вас возникает вопрос. Ну хорошо, а зачем
тогда все сделать на этапе компиляции,
тогда давайте все делать на этапе executed
программы, во время исполнения программы
для каждой функции определять, какая должна быть вызвана.
Естественно, это более дорого. Понятно почему.
Потому что на этапе компиляции компилятор сразу может поставить, что
а вот тут находится такая-то функция, поэтому при вызове этой функции
указатель инструкции нужно передвинуть туда.
А если у вас есть позднее связание, то есть если у вас решение о том,
какая функция будет вызвана, откладывается до момента исполнения программы,
то естественно компилятору нужно сделать несколько дополнительных действий.
В частности, понять, какой объект там на самом деле лежит,
какую функцию нужно выбрать и только потом ее вызвать.
То есть позднее связание обязательно влечет за собой некоторые дополнительные действия.
Окей?
Поэтому, в общем, с одной стороны мы получаем гибкость,
то есть мы можем использовать указатели на базовый класс и при этом,
в зависимости на какой объект мы на самом деле указываем,
будет вызываться тот или иной метод, но с другой стороны мы получаем
некоторую просадку в производительности, потому что вызывать такие функции более дорого.
Понятно?
Хорошо, ну и давайте попробуем как-то, не знаю, порешаем задачи на эту тему.
Вот есть класс A, в нем есть виртуальный метод F и не виртуальный метод G.
Дальше есть класс B, который публично унаследован от A,
в нем есть точно такой же метод F, и в свою очередь B объявляет метод G виртуальным.
Ну и есть структура C, которая наследуется от B и определяет функцию F,
и определяет функцию G, но при этом, заметьте, что тип другой.
То есть во всех функциях есть метод F, который возвращает void,
во всех функциях есть метод G, но при этом в классе A он возвращает void,
а в классе C он возвращает char.
Ну и более того, виртуальный метод G объявляется только в классе B.
Давайте посмотрим на центральную колонку и попробуем определить, где метод вызывается.
При условии, что я объект типа A создаю с помощью объекта типа B,
объект B создаю с помощью объекта типа C, ну и объект C создаю с помощью объекта типа C.
Ну давайте, наверное, с C начнем, это самое простое, да, вот последние две строки.
Что там вызывается?
Ну, естественно, C, да, везде.
Ну, тут нет никаких вариантов, потому что, ну как бы, C проинтересована объектом типа C,
тут вообще никаких вопросов быть не может.
Хорошо, давайте тогда, ну давайте тогда начнем, давайте сверху пойдем.
Вот я вызываю A.F, какая функция вызывается?
Так, кто считает, что в B?
А кто считает, что A?
Да, действительно, A.
Может, кто-то сможет объяснить, почему A, а не B?
Так, смотрите, F виртуальная, и A создан с помощью объекта типа B,
но при этом вызывается A, то есть это, кажется, противоречит тому, что мы обсуждали до этого, или нет?
Ну кто объяснит?
Ну, вот смотрите, я утверждаю, что есть противоречи... что?
Ну, не совсем.
То есть конструктор, ну, точнее так, конструктор от B, конечно, вызвался,
но при этом произошло нечто другое. Что еще произошло?
Срезка, да. Все помните, что такое срезка?
Вот, значит, этот пример показывает, ну, то есть этот пример демонстрирует то,
что, на самом деле, важно отличать срезку и работу с указателями и ссылками.
Значит, еще раз, срезка создает непосредственно тот объект, который вы попросили,
то есть срезка создает вам объект типа A.
То есть A, а маленькая, это переменная, которая ссылается на объект типа A.
Да, то есть, ну, действительно, там в правой части произошло создание объекта типа B,
но потом он просто взял и урезался до объекта типа A.
Поэтому тут, на самом деле, виртуализация, естественно, не работает, почему?
Потому что, ну, компилятор видит, что A это объект типа A,
и у объекта типа A можно вызывать только методы класса A,
поэтому тут вызывается af.
Ну, и в центральных двух строках?
Ну, абсолютно точно так же.
Bf и Bf, ой, и Bg.
Почему? Потому что тип, тип переменной B, это B.
То есть сама B является объектом типа B.
У объекта типа B ничего нельзя вызвать другого, кроме как, вот, собственно, методы класса B.
А вот теперь давайте перейдем на правую, в правую колонку,
ну, и пойдем по порядку.
Вот у меня есть указатель, указатель на A,
но он при этом указывает на объект типа B.
Какие функции будут вызваны f и g?
Которые находятся в A, в B или в C?
Так, здесь вызовется вот так. Согласны?
А здесь a, g, так? Или нет?
Ну, а теперь давайте перейдем на правую колонку.
Вот здесь у меня есть указатель на A,
но он при этом указывает на объект типа B.
Какие функции будут вызваны f и g?
Говорю, давайте по порядку.
Почему в первой строке вызовется функция, которая находится в B?
Да, ну, во-первых, потому что f виртуальная,
то есть по порядку, что мы делаем?
Мы понимаем, что тип APB это указатель на A,
поэтому мы идем сюда и смотрим на функцию f.
И вот в этот момент мы понимаем, что функция f виртуальная.
А раз функция f виртуальная, то что это означает?
Это означает, что нам не достаточно знать о том,
какой указатель на самом деле был.
Нам важно знать, на какой объект мы указываем. Согласны?
А объект, на который мы указываем, это объект типа B.
Поэтому вызван на самом деле фактически будет вот этот метод,
который находится в B.
Окей.
Так, ну а во второй строке почему будет вызван метод g,
который находится в A?
Потому что g в A не виртуальный.
Да, потому что метод g не виртуальный.
Все, то есть тут то же самое.
Мы видим, что APB это указатель на A,
мы идем сюда, видим, что это метод g,
и он не виртуальный,
поэтому просто-напросто берем и его вызываем.
То есть тут нет позднего связывания.
Так, идем дальше.
C.
Так, в первой строке какой метод будет вызван?
Который в B или в C или в A?
В A.
Так, говорят в C.
Ну хорошо. А во второй строке?
В A.
Окей, ну давайте теперь поговорим.
Почему в первой строке вызывается метод, который находится в C?
Да, потому что f виртуальный метод.
Еще раз, что мы делаем?
Еще раз, как действует компилятор?
Компилятор просто смотрит на тип APC.
Тип APC это указатель на A,
поэтому мы идем сюда.
То есть компилятор в этот момент понимает,
что метод f виртуальный,
поэтому нужно посмотреть на то, какой на самом деле тип там лежит.
Там на самом деле лежит тип C.
Потому что мы создали его с помощью конструкции new C.
Ну а так как на самом деле
мы указываем на объекте C,
поэтому нужно вызывать метод f.
А во второй строке почему вызывается g?
Во второй строке почему вызывается g из A,
а не из B или не из C?
Потому что g не виртуальная.
Да, потому что g не виртуальная.
Но снова мы идем в класс A и видим, что g не виртуальная,
поэтому вообще нет никаких вариантов.
То есть вызываем только эту g.
Ну и последние две строки.
Какие тут методы?
Так, есть вариант из B в C.
Еще какие варианты есть?
С, С.
Есть еще варианты?
Кто за первый вариант?
Один.
Кто за второй вариант?
Побольше.
Кто за третий вариант?
Тоже один.
Ну да, на самом деле
будет вызван...
Хотя нет, стоп.
Нет, все правильно.
Здесь вызвана вторая строка.
То есть будет C, F
и C, G.
Сейчас, стоп.
Нет, нет, тут неправда.
Сейчас поговорим.
Давайте по порядку.
В первой строке
почему вызывается C, думаю, понятно.
Мы идем в B,
то есть B по C на самом деле указывает на A, B,
мы идем сюда, видим функцию F,
но она на самом деле виртуальная.
Почему?
Потому что мы сказали, что виртуальность на самом деле наследуется.
То есть если в базовом классе
эта функция объявлена виртуальной,
то и всюду далее она будет виртуальной.
То есть как бы вот тут не явно все равно стоит слово virtual.
Она виртуальная, поэтому на самом деле смотрим на то,
на какой объект мы указываем.
На самом деле мы указываем на объект типа C,
поэтому вызывается метод F, который находится в C.
А вот теперь смотрим сюда.
Здесь все интереснее.
Здесь все интереснее. Почему?
Потому что действительно мы смотрим на функцию G
и G виртуальная.
Но какая функция G виртуальная?
Которая возвращает void.
То есть виртуальная именно функция,
которая ничего не принимает и возвращает void.
Функция, которая возвращает char
и ничего не принимает,
к этой void не имеет никакого отношения.
Это функция, которая имеет абсолютно другой тип.
Поэтому она не виртуальная.
Поэтому здесь на самом деле будет вызвана функция из B.
Кто понимает?
В смысле, давайте алгоритм еще раз.
Нет, вот функция char
в данном контексте,
в данном случае ее нельзя вызвать.
Потому что это функция, которая находится в C.
И она никак не связана.
Что находится в B?
В B у вас находится функция, которая возвращает void.
Есть функция C,
которая возвращает char G.
С помощью указателя на B
можно вызвать только функции,
которые объявлены в классе B.
Char G объявлено в классе C.
Вот про эту функцию класс B в принципе ничего не знает.
Поэтому она не может быть вызвана никак.
Грубо говоря, вот эти функции имеют разные типы.
Одна возвращает void,
другая char.
Они имеют разные типы.
Поэтому виртуальность на них не распространяется.
Виртуальность распространяется только на ту функцию,
которая дословно совпадает
с тем типом, который был объявлен виртуальным.
Теперь был вопрос, как компилятор понимает,
что на самом деле...
Как компилятор это все понимает?
Давайте еще раз с алгоритмом.
Алгоритм такой.
Компилятор смотрит на тип указателя.
Тип указателя какой? Указатель на B.
Поэтому мы должны пойти вот сюда.
Смотрим сюда.
Эта функция какая? Виртуальная.
Виртуальная функция void G.
Мы принимаем решение о том,
какая функция будет вызвана,
а не того, на какой объект мы указываем.
А указываем мы на объект типа C.
Мы идем в C и смотрим,
есть ли там функция void G.
Такой функции там нет.
Точнее, она есть, но она унаследована
от B.
Мы ее никак не переопределяли в классе C.
Поэтому мы вызываем именно ту функцию,
которую она унаследовала.
Есть вопросы?
Вот.
Здесь вызывается функция
именно того типа, который указан
непосредственно в классе B.
А в классе B функция G имеет
тип void и пустые круглые скобки.
Поэтому никакая другая функция
с другой сигнатурой вызвана быть не может.
Ответы вроде все совпало.
Хорошо.
Значит,
еще немного про виртуальность.
Виртуальность работает
и внутри методов класса.
Что это означает? Это означает, что
если у вас есть какой-то виртуальный метод,
и вы этот виртуальный метод вызываете
внутри другого метода,
то все вот эти приколы
с поздним связанием
будут также работать.
В частности, если у меня есть
указатель на A,
при этом я проницилизировал указатель на A
и указателем на B.
Если я вызову printName,
несмотря на то, что printName
не является виртуальным,
то есть тут никаких проблем нет.
Тут вызывается именно A
2.2.printName.
То есть тут происходит какое связывание?
Раннее связывание.
PrintName не виртуальное. Но при этом
printName сама внутри себя
вызывает виртуальную функцию.
И вот здесь уже происходит позднее связывание.
Понятно?
То есть вот здесь внутри этой функции комплинатор
подставляет код, который непосредственно
не вызывает name, а делает какие-то приколы
так, чтобы был вызван именно
тот метод, на который указывает
указатель.
Но именно указатель this.
Тут на самом деле name
разворачивается this,
стрелочка name.
А указатель this на самом деле указывает
на объект типа B.
Понятно почему.
Поэтому тут работает виртуальный метод.
Пример понятен?
В общем, мораль такая, что
виртуальные функции работают не только во внешнем коде,
но и внутри ваших классов тоже
можно вызывать виртуальные методы,
и они работают, в общем,
как и заявлялось.
Единственное исключение,
виртуальные методы не работают в конструкторах
и деструкторах. Вот если вы в конструкторе
или деструкторе позовете виртуальный метод,
то виртуальность будет игнорироваться.
Из того, что я знаю, это единственное исключение,
когда виртуальные методы не работают.
Это конструкторы и деструкторы.
Есть гипотезы,
почему не работают?
Из-за чего?
Ну да, смотрите,
да, действительно,
почему в конструкторе нельзя вызывать
виртуальные методы.
Смотрите, вот представьте,
что у меня есть конструктор B,
что делает конструктор B?
Конструктор B сначала
вызывает конструктор A. Согласны?
Ну, помним, да? Хорошо.
А внутри конструктора A
вызывается виртуальный метод F.
Если я внутри конструктора A
вызываю виртуальный метод F,
который будет вызван. Который из a или который из b?
Ну, по идее.
По идее, если он виртуальный, то, наверное, должен быть вызван метод,
который находится в b.
А что может делать такого запрещенного,
в данном контексте,
метод f, который определен в b?
Ну, не совсем.
Он может использовать ту часть,
которая еще не проницилизирована.
Понятно проблема?
Давайте еще раз повторю.
Вот смотрите, у меня есть конструктор b.
Я его вызываю.
Причем, что происходит в конструкторе b,
это вызов конструктора a.
Изначально я создаю вот такую вот коробку,
которая относится к a.
Вот эта вот закрашенная часть, она еще не создана.
Она еще даже не проницилизирована.
Окей?
И теперь смотрите, если я вдруг
в конструкторе a вызываю виртуальный метод,
то этот виртуальный метод чисто теоретически может
полезть туда, куда ему еще не следует.
Понятно?
То есть он может полезть в ту часть, которая еще не создана.
И это большая беда.
Понятно?
То же самое с деструктором.
Что происходит в деструкторе b?
Что сначала уничтожается?
Сначала в деструкторе уничтожается все то,
что относится к объекту b.
Согласны?
Вот.
Ну и теперь смотрите, у меня все вот тут уничтожилось,
и я захожу в деструктор a.
И в деструкторе a снова вызываю виртуальный метод f.
Ну и та же самая проблема.
Теперь вот этот вот виртуальный метод f
может захотеть полезть
в уже удаленную часть.
То есть та часть, которая уже в принципе
компилятором была, ну не компилятором,
а вот исполнителем была помечена как уже удаленная.
Снова беда.
Поэтому в конструкторах и деструкторах
виртуальность просто-напросто не работает.
То есть не то, что это будет undefined behavior,
нет, просто вот не работает.
То есть будут вызваны именно те методы,
которые, точнее, вот тут будет вызвана
обязательно метод a, и тут обязательно метод a,
тут обязательно метод b,
и обязательно метод b.
Все.
Окей?
Все понятно здесь?
Идем дальше.
Ну, про виртуальность более-менее мы
поговорили.
Теперь, в общем, немного теории, вот как это все называется.
Вот то, про что мы сейчас говорим,
про механизмы позднего связывания,
и тому подобное, называется динамическим
полиморфизмом.
Еще раз, у нас есть основные столпы,
на которых держится объектно-ориентированное программирование,
это абстракция, инкапсуляция, наследование
и полиморфизм.
Полиморфизм бывает разный.
Давайте еще раз вспомним, что такое полиморфизм.
Полиморфизм — это свойство системы, которая позволяет
использовать несколько реализаций
в рамках одного интерфейса.
И до этого мы, на самом деле, говорили про полиморфизм
как про вещь, которая позволяет нам
выбрать нужную функцию в зависимости того,
например, шаблоны.
То есть мы можем одну и ту же функцию F использовать для нескольких типов.
Или перегрузка — то же самое.
То есть мы можем использовать одну и ту же операцию,
но при этом для разных типов и даже своих собственных.
И это всё является примерно статического полиморфизма.
Почему статического?
Статический полиморфизм означает,
что мы реализацию выбираем на этапе компиляции.
То есть понятно дело,
что шаблоны,
выбор перегрузки, перегрузка операции,
всё работает на этапе компиляции.
выбирает, какую версию той или иной функции нужно выбрать. Понятно? Динамический полиморфизм,
вроде как тоже, осуществляет, реализует вот этот механизм полиморфизма, то есть в зависимости
того, на какой объект мы указываем, выбирает вся или иная функция. Но при этом это все происходит
не на этапе компиляции, как мы обсудили до этого, а во время исполнения программы. Программа
выполняется, в процессе своей работы она исполняется, и в какой-то момент она может вызвать
функцию f из a или может вызвать функцию f из b, в зависимости того, какое условие ей пришло. И это все
происходит во время исполнения, а не во время компиляции. Вот. Да, ну и, собственно, основной
механизм реализации динамического полиморфизма — это виртуальные функции. Ну, есть еще второй,
есть еще один механизм реализации динамического полиморфизма. Кто вспомнит? Обсуждали. Ну,
указатель на функцию. Если вы используете указатель на функцию, то это тоже как бы динамический
полиморфизм, потому что вы можете использовать либо ту, либо иную функцию в зависимости
каких-то условий. Да, и, собственно, наследование с применением виртуальных функций называют
полиморфным. Вот если у вас в наследовании присутствуют виртуальные функции, то такое
наследование называется полиморфным, не виртуальным. Значит, в C++ существует понятие
виртуального наследования, и это вот не про это. Виртуальное наследование — это совсем про
другое, я не знаю, успеем мы в этом году про это поговорить или нет, но в общем, виртуальное
наследование — это вот не про это, здесь полиморфное наследование. Окей? Ну, потому
что полиморфное наследование позволяет реализовать динамический полиморфизм. Окей?
Ну и собственно… Для чего нам это все нужно? Мы вроде как обсудили, что, наверное, иногда это
это бывает полезно. Ну и на самом деле динамический полиморпизм используется довольно часто во многих паттернах.
Очень часто бывает полезно. Давайте такой игрушечный пример.
Я утверждаю, что с помощью динамического полиморпизма мне сейчас удастся
создать массив из объектов разных типов. Как я это сделаю?
Давайте я заведу класс «Животное». Допустим я хочу в одном массиве хранить всех животных.
Кошек, собак и тому подобное. Понятно дело, что тип кошки, тип собаки отличаются.
Но при этом мне бы хотелось их всех хранить в одном массиве.
Как бы в классическом C++, то есть до сегодняшней лекции мы этого делать не могли.
А сейчас я утверждаю, что сможем. Смотрите, что мы делаем.
Мы заводим класс «Животное» и заводим в нем виртуальный метод, который могут выполнять все животные.
Например, подать голос. Заводим, соответственно, кошку и в ней переопределяем этот метод voice.
Заводим собаку, она лает. Заводим лису, она тоже что-то делает.
Соответственно, у нас есть такая иерархия. Есть животное.
И все животные в нашей программе, они все унаследованы от этого базового класса.
Ну и теперь смотрите, что я делаю. Если я хочу создать массив всех животных,
я просто-напросто беру и создаю массив указателей на животных.
Ну и далее я могу делать следующую вещь. То есть я могу заполнить этот массив.
Например, for int i равно 0 и меньше 10 i, плюс-плюс i.
Ну и в зависимости от каких-то условий сделать animal с i равно new cat,
либо new, в зависимости от какого-то условия, new fox или new dog.
То есть я, например, могу с клавиатуры вводить имя животного,
и в зависимости от того, какое имя я ввел, мне добавляется в этот массив либо кошка,
либо собака, либо кто-то еще.
Понятное дело, что на этапе компиляции, то есть компилятор, в принципе,
не зная заранее, какие животные у вас будут храниться в массиве, в каком порядке и так далее.
Все это происходит непосредственно во время исполнения программы.
И дальше вы делаете следующую вещь. Вы просто для каждого животного вызываете метод voice.
То есть вы можете, например, вашему зоопару сказать, ну там, все подать голос.
И сразу раз на экране будут появляться именно те звуки, которые вы задали в методе voice
для каждого из отдельных типов. Понятно?
То есть мы единым образом работаем с объектами разных типов,
и при этом их все храним в одном массиве. Круто?
Ну и на самом деле, если говорить так, в общем, чем вообще хорош C++,
почему вообще мы изучаем C++, во многих университетах C++ изучается как базовый язык.
Да потому что вот эта реализация, динамический полиморфизм,
он лежит в основе очень многих языков программирования.
Например, вы знаете язык Python.
Например, в Python в массивах можно хранить объекты разных типов.
За счет чего это достигается?
Ну как раз таки за счет этого.
Например, в одной из самых популярных реализаций Пайтона, CITON,
который реализован на C, на C++, там как раз используется динамический полиморфизм.
То есть предполагается, что все объекты в Python унаследованы от одного класса object, условно.
То есть в Python есть общий базовый класс object, от которого унаследованы вообще все типы.
И вот на самом деле, когда вы создаете массив объектов, у вас в этом массиве как раз-таки хранятся указатели нам вот эти объекты типа object.
И за счет этого получается достичь того, что у вас в одном массиве могут храниться элементы абсолютно разных типов.
И вот именно в основе всего этого лежит вот этот механизм.
Ну, соответственно, в C++ тоже можно реализовать что-то подобное.
То есть можно писать вообще свою стандартную библиотеку,
создать базовый класс object, от которого унаследованы вообще все типы.
То есть создать класс int, класс float и так далее, унаследовать их всех от object,
и тогда можно будет хранить объекты разных типов в одном массиве.
Ну и вопрос, а почему так не делают? Почему не сделать так?
Что? Да, непроизводительно. То есть как мы сказали, механизм позднего связывания работает долго.
Потому что на этапе компиляции мы можем что-то саптимизировать, мы можем подставить конкретные вызовы, мы можем что-то заинлайнить и так далее.
Когда мы используем механизм позднего связывания, мы такой возможности просто-напросто теряемся.
Потому что мы выбираем функцию непосредственно на этапе исполнения.
То есть это какой-то дополнительный код, какие-то дополнительные затраты на выборы функции.
Ну а во-вторых, это дополнительные затраты на вызов функции и так далее.
Еще один важный момент, который касается виртуальных методов, ну и в принципе полимортного наследования, это виртуальный деструктор.
Деструкторы тоже можно делать виртуальными. То есть может возникать вопрос, а для чего?
На самом деле виртуальный деструктор это чуть ли не самое важное, а вот про что мы сегодня будем говорить.
Проблема следующая. Вот представьте себе такую вещь. Вот у меня есть класс stack.
И я создал класс stackMax, то есть класс stack с поддержкой максимума.
И я его унаследовал от класса stack. Ну понятно, то есть публичная наследование говорит о том, что stackMax является stack.
Ну и понятное дело, что их реализации похожи, поэтому я как бы, например, чтобы избежать дублирование кода делаю вот такую вещь.
Разумно? Окей. Ну и теперь представьте себе, что я делаю следующую вещь.
Я создаю указатель на stack, но при этом ему присваиваю объект типа stackMax.
Ну я могу так сделать? Могу.
Окей. Ну и теперь, так как я создавал объект с помощью new, я должен его очистить с помощью delete.
И вот тут я вызываю delete. В чем беда? В чем проблема?
Ага, да. Действительно. Что делает delete? Кто помнит? В первую очередь.
Да, delete в первую очередь вызывает деструктор. А какой деструктор будет вызывать тут delete?
Да, тут будет вызвать деструктор stack. А почему? Неужели компилятор такой тупой и будет вызывать именно вот этот деструктор?
Ну да, правда. Компилятор тупой. Почему? Потому что компилятор на самом деле просто-напросто берет и смотрит, а какой указатель мы удаляем?
А удаляем мы указатель на stack. Вот. Stack со звездой.
Но так как мы удаляем указатель на stack, то и значит, что нужно вызвать деструктор stack.
Ну и все. У нас есть часть, которая относится к stack, и есть часть, которая относится к max.
Вот. Вот эта часть будет удалена, а вот тут, если даже были какие-то выделения памяти и тому подобное, то ничего с убеждением не будет.
Беда? Беда.
Вот. Да. Ну и, собственно, здесь все расписано. Да, действительно, что тип stackptr это stack-указатель, delete вызывает деструктор stack, а не stackmax.
Поэтому stackmax будет уничтожен неправильно. Ну, то есть, просто на обстановке findBehaviour.
Ну, а на практике это утечка памяти.
Как решается эта проблема? Решается проблема очень просто. Нужно объявить... То есть, если вы предполагаете...
Давайте я сразу скажу, что не надо там заводить панику и вообще все деструкторы делать виртуальными, нет.
Если вы предполагаете, что ваш класс может являться базовым классом для каких-то других классов, то в этом классе нужно делать деструктор виртуальным.
Чем помогает виртуальный деструктор? Ну, собственно, ровно тем же, чем помогает виртуальность для остальных методов.
Значит, если вы объявили деструктор виртуальным, то выбор конкретного деструктора будет осуществляться непосредственно на этапе исполнения программы, а не на этапе компиляции.
То есть, что здесь происходит? Теперь. Тип stack-ptr – это stack-указатель.
Поэтому я иду в класс stack и смотрю, какой там деструктор. И вижу, что там деструктор виртуальный.
Но раз деструктор виртуальный, то это значит, что мне нужно посмотреть повнимательнее.
То есть, уже не на этапе компиляции, а на этапе исполнения программы.
То есть, нужно посмотреть, какой на самом деле объект лежит под этим указателем.
А под этим указателем лежит указатель на stack-max, поэтому тут на самом деле будет вызван деструктор stack-max.
И все благодаря виртуальному деструктуру в базовом классе.
Ну вот, пока осознайте это, и после перерывов продолжим.
Так, продолжим. В общем, как я сказал, если у вас предполагается
использование вашего класса как некоторого полиморфного наследника,
то есть, если в вашем классе есть какие-то виртуальные методы,
то необходимо также позаботиться о том, что у вас и деструктор тоже был виртуальный.
То есть, для полиморфных классов необходимо писать виртуальный деструктор.
Это просто, в общем, жизненно необходимо.
Ну и теперь поговорим про некоторые ключевые слова, которые помогут упростить написание полиморфных классов.
Ну и в принципе, уберегут от большого количества проблем.
Это слова overwrite и final.
Да, естественно, если вы что-то наследуете, то эти же самые функции тоже виртуальные.
Если у вас в базовом классе виртуальная, то эта виртуальность сохраняется для всех остальных классов.
Поговорим про слова overwrite и final.
Проблема следующая. Мы, на самом деле, с ней уже столкнулись, когда обсуждали один из примеров.
Помните, когда у нас была функция g, которая void, или функция g, которая char.
Там действительно было легко запутаться в том, какая функция является виртуальной,
какая не является виртуальной.
Так вот, чтобы этого не было, есть специальные слова.
Давайте подробнее про проблему.
Мы помним, что виртуальность работает только для функции определенного типа.
Если я сказал, что функция void fint, она виртуальная,
то это означает, что функция void flong в производном классе виртуальной уже не будет.
Виртуальность строго сохраняет тип.
То же самое касается константности. Константность это тоже часть типа функции.
Поэтому если у вас в базовом классе функция g является константной,
а в производном классе g она не является константной,
то вот эта функция, она с этой никак не связана.
Сюда виртуальность не распространяется.
И это является, естественно, источником большого количества ошибок.
Чтобы переопределить виртуальную функцию, вам нужно в точности дословно знать
интерфейс или тип функций, которые есть в базовом классе.
Понятно?
Но при этом понятное дело, что забыть написать конст очень просто.
Ну и, соответственно, здесь показана эта проблема, что, действительно,
если у меня есть указатель на a, который на самом деле указывает на объекте по b,
и я вызываю здесь f от нуля, то, казалось бы, я тут предполагаю,
что у меня будет вызвана функция f, которая находится в b,
потому что f — это виртуальная функция.
Но при этом нет, будет вызвана функция f, которая находится в a. Почему?
Еще раз, потому что эта функция никак не связана с функцией f от int.
f от int и f от long — это абсолютно разные функции.
То же самое касается функции g.
В базовом классе у меня функция g объявлена как константная,
в производном классе эта функция g не константная.
Поэтому здесь будет вызвана именно функция g, которая находится в a,
а не которая в b. Понятно?
И вот чтобы избежать таких проблем, то есть с точки зрения компилятора,
естественно, это не ошибка.
То есть, возможно, вы предполагали, что вот эти вот функции f и g,
они переопределяют в виртуальные функции, которые находятся выше.
Но при этом это не так.
Но и компилятор, естественно, ругаться не будет и выдавать предупреждения не будет,
потому что это вполне символично.
Он просто создал новые функции, которые никак не связаны с теми.
Все нормально.
Но вот если вы хотите, чтобы компилятор действительно проследил,
что вы сделали все правильно,
это не ключевое слово, это зарезервированный идентификатор.
То есть есть специальное слово — overwrite,
которое будет следить за тем, чтобы вы сделали все так, как хотели.
Вы просто после функции, которую вы предполагаете, что она виртуальная,
если у вас есть виртуальная функция,
и вы хотите ее в наследники переопределить,
вы должны написать слово overwrite.
Точнее, не должны, если вы не напишете, ошибки не будет.
Но при этом overwrite убережет вас от возможных проблем,
которые мы обсуждали ранее.
То есть если вы пишете overwrite,
но при этом ваша функция никак не связана с какой-нибудь виртуальной функцией
выше по иерархии наследования,
то у вас возникнет ошибка в компиляции.
Но в частности здесь вам скажут, что вот эта вот функция,
она помещена как overwrite, но она на самом деле ничего не overrides.
То же самое с функцией g.
То есть функцию g вы пометили как overwrite, но она ничего не overrides.
Потому что она никак не связана с той виртуальной функцией,
которая находится в базовом классе.
Понятно? Да.
А функция, когда у вас такое несоответствие,
проходит на этапе компиляции это делать или после?
Нет, это естественно...
На этапе компиляции, да, уже разбирается с тем,
откинуть функцию дальше или сразу...
Нет, тут все можно сделать на этапе компиляции.
То есть компилятор же видит, что тут есть функция flong.
И вы пометили ее как overwrite.
Если без overwrite, то будет как и здесь.
Проблем никаких не будет.
Ошибки компиляции не будет.
Просто будут вызываться функции f и g, которые находятся в a.
Потому что в b вы ничего не приопределили.
То есть точке зрения компилятора вы ничего не приопределили.
Long и int это разные типы.
g с констом и g без конста это разные типы тоже.
Естественно, проверка overwrite, то есть overwrite это или не overwrite,
это на этапе компиляции происходит.
Что делает компилятор?
Он видит, что есть функция flong.
И вы утверждаете, что она переопределяет функцию,
которая находится в базовом классе.
Но при этом он смотрит в базовый класс и видит, что такой функции там нет.
Ну и все, ошибка компиляции.
Такой виртуальной функции там нет.
Ну то есть условно, если у вас тут была функция h...
void h.
И тут бы вы написали тоже void h,
и при этом написали overwrite,
то тоже была бы ошибка компиляции. Почему?
Потому что функция h не виртуальная.
То есть overwrite работает только для виртуальных функций.
Соответственно, как мы сказали,
переопределять виртуальные функции можно только дословно.
То есть типы функций могут совпадать.
Это не совсем правда. Точнее, это правда с точностью
до кавариантных возвращаемых типов.
Что такое кавариантные возвращаемые типы?
Кавариантные возвращаемые типы это типы, которые связаны
между собой и иерархией наследования.
То есть условно, если у вас виртуальная функция f,
virtual,
скажем, указатель на a,
а функция f, которая находится в наследнике,
возвращает указатель на b, и при этом a является
базовым классом для b, то все OK.
То есть несмотря на то, что a указатель и b указатель
это разные типы, все равно они являются совместимыми
между собой, поэтому все OK.
Понятно?
Только с указателями и ссылками.
У нас не нравится только указатель или ссылки
на типы, которые связаны между собой и иерархией наследования.
Для чего это может быть нужно?
Это часто применяется для всевозможных паттернов
проектирования или в частности для так называемых
виртуальных конструкторов копирования.
Например, есть метод clone, который просто клонирует
текущий объект, возвращая указатель на него.
У вас есть класс a, и у вас есть метод clone, который возвращает
объект типа a, но при этом копию на объект типа a.
И вы переопределяете этот метод
в наследники в классе b, и при этом
в классе наследники он возвращает указатель на b.
И при этом clone, который находится в базовом классе,
и clone, который находится в наследнике, они между собой связаны,
и по-прежнему они могут override друг другу.
Они по-прежнему являются виртуальными, и они связаны друг с другом.
Вот ровно потому, что тип a со звездой
и тип b со звездой являются квариантными типами.
Да, да, да.
В смысле, вы имеете в виду, если вот так и ставить?
Сейчас, указатель a, так.
Так.
Ну, вот так.
Нет, смотрите, опять же,
короче, срезки тут, естественно, не происходит.
То есть вы работаете тупо с указателями.
То есть даже если вы сделали так,
в данном контексте у вас, в данном случае,
у вас будет вызван clone, который расположен в b,
то есть вот здесь.
То есть будет вызван clone, который расположен в b,
то есть вот здесь.
То есть будет вызван clone,
возвращает вам указатель на объект типа b.
Если вы его сохраните в указатель на a,
то так можно делать.
Мы, собственно, всю лекцию этому посвятили.
Но при этом, естественно, весь b,
потому что вы создаете весь b.
То есть указатели ссылки
никакой срезки не делают никогда.
Указатели ссылки ссылаются именно
на тот объект, который у вас есть.
Ну, есть еще одно специальное слово, final,
которое говорит следующее.
Final говорит о том, что эту функцию больше
переопределять нельзя.
То есть вот эта функция, которая оплена здесь,
больше изменению не подлежит в наследниках.
Ну вот как это работает?
Вот у вас есть виртуальная функция f,
вы ее переопределяете в структуре b,
и при этом говорите, что она final.
Наследники b не имеют права эту функцию как-то переопределять.
Но это может быть нужно, например, если вы в классе
переопределили какое-то ее поведение,
и дальше не хотите, чтобы оно как-то менялось.
То есть у вас нет логики класса b.
И теперь, если вы в структуре c,
которая наследована от b, попытаетесь эту функцию заоверайдить,
точнее попытаетесь ее переопределить,
то есть создать другую функцию, то есть начинать создать функцию,
которая тоже является void, которая ничего не принимает,
имеет имя f, то у вас ничего не получится, будет ошибка компиляции.
Почему? То же самое.
Override вообще ни на что не влияет.
Грубо говоря, предохраняет вас от ошибок.
Неважно, писали вы override или нет, у вас все равно происходит переопределение.
Override, грубо говоря, с точки зрения...
Override не привносит никакой код.
То есть, грубо говоря, компиляторы его игнорируют в той степени,
что он лишь выдает вам предупреждение, если у вас что-то идет не так.
В остальном override ни на что не влияет.
По код-стайлу, да.
Точнее так. Если вы переопределяете виртуальную функцию,
то нужно писать override.
Если вы не делаете этого, то не нужно.
Компилятору, на самом деле, от этого не жарко,
но это просто вас спасает от ошибок.
И, соответственно, будет ошибка, что
виртуальная функция CF переопределяет финальную функцию,
которая вот здесь была объявлена как финальная.
То есть final запрещает
дальнейшее переопределение этой функции в наследниках.
RETUR華 я Quinn.
Да. Ну, соответственно, правило
понятное дело, что финальный можно пометить только виртуальную функцию.
То есть нельзя просто так взять и сказать,
что какой-то метод финальный.
Финальный может быть только виртуальная функция
потому что переопределяются к виртуальной функции.
А невертуальные функции, што с ними происходит?
Если вы все-таки хотите написать функцию, которую вообще никак нельзя не переопределить, не заместить в наследниках,
то можно ее создать виртуальной и сразу сделать ее финальной.
Тогда в наследниках в принципе нельзя будет создать функцию voidf.
Потому что, во-первых, так как это функция виртуальная, то компилятор будет считать, что любая функция voidf — это переопределение.
Ну а так как вы написали final, то переопределения запрещены.
Да, соответственно, это имеет смысл, если хочешь запретить наследникам определять функции с тем же именем и типом.
Ну и еще одно место, где может использоваться final. Final может использоваться на уровне с классом, точнее с объявлением класса.
Тут все просто. Это слово просто говорит о том, что от этого класса нельзя наследоваться.
Если вы хотите, чтобы от вашего класса нельзя было наследоваться, то вы помечаете его final.
Для чего это может быть нужно? Например, у вас есть класс, в котором есть виртуальные функции, которые вы унаследовали от кого-то,
но при этом виртуального деструктора в этом классе у вас не предполагается.
Не потому что вы не хотите, чтобы от вашего класса в принципе кто-то наследовался и так далее.
Тогда просто пишите final и тогда вы защищаете себя от ошибок.
Если вы случайно от этого класса унаследуетесь, то будет ошибка компиляции.
Понятно?
Еще один пункт. Поговорим про чисто виртуальные функции и абстрактные классы.
Вот такой.
Почти жизни, например.
Допустим, вы пишете какой-то свой messenger на языке C++.
Ну и понятное дело, чтобы как-то описать логику вашей программы и так далее,
вы вводите туда новые классы, новые сущности, описываете вашу программу в вас messenger с точки зрения каких-то других абстракций.
Но с частности, вам нужен, например, класс сообщения.
Если вы хотите послать какое-то сообщение, то для этого нужен класс.
Но при этом вы понимаете, что типа в сообщении у вас может быть несколько.
И при этом каждое сообщение ведет себя как-то иначе.
Есть текстовые сообщения, есть сообщения в виде картинки, есть сообщения в виде видео и так далее.
Типов сообщений может быть очень много.
И при этом, наверное, хотелось бы иметь возможность для каждого конкретного пользователя хранить массив тех сообщений, которые у него есть.
Как добиться того, чтобы можно было в одном массиве хранить сообщения разных типов?
Ну, естественно, с помощью динамического полиморфизма.
То, про что мы говорили.
Поэтому что мы делаем?
Мы заводим базовый класс сообщения и говорим в нем следующее.
У него есть метод send, который просто берет и отправляет сообщение в нужный чат.
Чат мы принимаем по указателю.
Мы принимаем указатель на чат и в этот чат отправляем это сообщение.
Ну ладно, в общем, нам не важно, как работает логика.
И плюс мы предполагаем, что у каждого сообщения есть метод display,
который просто, например, на устройстве отображает это самое сообщение.
Понятное дело, что текстовые сообщения, сообщения видео, сообщения картинка, они отображаются по-разному.
Ну, естественно.
Текст это просто текст, а картинку нужно как-то декодировать.
Поэтому мы предполагаем, что метод display должен быть переопределен в классах наследников.
Ну то есть в классе текстовые сообщения метод display выглядит одним образом,
в классе сообщения sticker отображение выглядит другим способом и так далее.
И каждый класс по-своему переопределяет этот метод display.
Логика понятна?
Вот.
В общем, вот такая иерархия.
Все, логично, окей.
Ну и теперь давайте попробуем ответить на некоторые вопросы и посвятить некоторые проблемы.
Ну вот смотрите, у меня есть базовый класс message.
Есть, соответственно, текстовые сообщения, есть там изображения, есть там stickers, ну и так далее.
Вопрос.
Имеет ли в моей программе вообще смысл создавать объекты типа message?
message msg
Ну, наверное, нет.
Что означает абстрактное сообщение?
Ну, непонятно, да?
В общем, что такое сообщение?
Сообщение может быть либо текстовое, либо видео, либо изображение и так далее.
Просто сообщение какое-то абстрактное, не имеет смысла.
То же самое как сказать, я купил мебель.
На ней можно сидеть, за ней можно писать и так далее.
Но ничего не понятно, да?
То есть можно купить конкретный объект.
Второй вопрос.
А что должен делать метод display в message?
Ну, смотрите, так как я написал класс message, в нем есть метод display.
И, естественно, мне нужно его как-то реализовать.
То есть я не могу оставлять методы без реализации.
То есть я не могу просто написать функцию, я не могу просто объедить функцию и ее никак не определить.
Что должен делать метод display в message?
Ну, вообще непонятно.
Ну, снова, как отобразить абстрактное сообщение?
Вообще ничего непонятно.
Третий вопрос.
Как заставить наследников реализовывать display?
Ну, хорошо, допустим, я придумал какой-то логичный способ
делать отображение произвольного сообщения.
Но при этом понятное дело, что у меня есть другие типы сообщений,
в которых мне просто необходимо реализовать свой метод display.
Точнее, свою реализацию display.
И при этом мне нужно заставить их реализовать это все по-своему.
Ну, понятно почему, да?
То есть я, например, могу реализовать класс
sticker message,
и при этом забыть реализовать вот этот метод.
Ну, просто могу про него забыть.
Ну, при этом, если я про него забуду, то ничего страшного.
У меня просто будет использоваться метод из базового класса.
Ну, а это, естественно, баг.
То есть мне, наверное, хотелось бы еще
про метод display сказать, что этот метод обязательно для реализации.
То есть вы все должны по-своему обязательно его как-то реализовать.
То есть использовать базовую реализацию нельзя.
Вот.
Вот такие три проблемы.
И все они решаются с помощью
так называемых чисто виртуальных функций
или чисто виртуальных методов.
Значит, что такое чисто виртуальная функция
или чисто виртуальный метод?
Это метод, который помечается, в общем,
в конце конструкции равно ноль.
То есть, по-моему, да, мы обсуждали,
там равно default, равно delete,
и вот сейчас есть конструкция равно ноль.
Вот если вы методу говорите,
что он равен нулю, то это значит, что вы определяете
чисто виртуальный метод.
Чисто виртуальный метод это метод,
который может не иметь реализации.
То есть если вы хотите сказать, что у этого метода
может не быть реализации, то вы делаете
равно нулю.
Вот.
Что это влечет за собой?
Да, ну, собственно, как я сказал,
что чисто виртуальные функции
можно оставлять без реализации, то есть нет никакой ошибки.
То есть если вы
если вы оставили какой-то метод без реализации,
то естественно это ошибка,
ну ошибка линковки.
То есть компилятор ожидал, что у вас есть функция,
у нее есть реализация, а вы ее не написали,
в общем в этом случае это ошибка.
В случае чисто виртуальных функций такой ошибки не
возникает. То есть компилятор понимает,
что вот вы нарочно оставили всё без реализации.
Единственное исключение — это
чисто виртуальные деструкторы.
Вот чисто виртуальные деструкторы,
во-первых, их делать не стоит, а во-вторых,
у любого деструктора обязательно должна быть реализация.
Деструктор всегда вызывается так или иначе.
Второй момент. Чисто виртуальные функции могут быть реализованы только вне класса.
То есть нельзя написать виртуал void f равно 0 и дальше написать реализацию.
Вот так делать нельзя. То есть после равно 0 можно написать только точку запятой.
Если вы хотите этот метод реализовать, то это нужно сделать обязательно вне класса.
Просто такое правило.
Сейчас будет про это.
Я сказал, что чисто виртуальные методы позволяют вам не писать реализацию для конкретного метода.
Это может показаться странным.
Неужели это нужно только для того, чтобы не писать реализацию?
Нет. Это еще позволяет создавать так называемые абстрактные классы.
Абстрактный класс — это класс у которого есть хотя бы один чисто виртуальный метод.
Если в вашем классе есть хотя бы один чисто виртуальный метод, этот класс называется абстрактным.
Почему этот класс называется абстрактным?
А потому что объекты таких типов создавать нельзя.
Понятное дело, что если у вас есть абстрактный класс, то это означает, что в нем есть
чисто виртуальные методы, то есть меты, у которых нет реализации. Если у вас есть методы, у pipeline нет реализации,
то это значит, что вызывать эти методы, естественно, нельзя.
Ну и объекты таких типов тоже создавать нельзя. Логика такая. Короче, абстрактный класс
одним чисто виртуальным методом, и главное их
свойство состоит в том, что объекты таких
классов создавать нельзя. То есть нельзя
создать iMessage, iMessage MSG. Вот тут будет
ошибка компиляции. Ну да, вот здесь это показано.
Но при этом, при этом можно создавать
указатели на такие, на такие типы и
ссылки на такие типы, окей? То есть абстрактные
классы могут быть использованы только
для того, чтобы создавать на них указатели
или создавать на них ссылки. Все, сами объекты
создавать нельзя. То есть в некотором
смысле, вот про это по-моему было
где-то написано, в общем, в некотором
смысле абстрактные классы представляют
из себя интерфейсы. Ну грубо говоря, что
такое интерфейс? Вот по код-стайлу мы в
начале абстрактных классов пишем всегда
заглавную букву i. Это по код-стайлу. Ну от
слова интерфейс. Чтобы не путать абстрактные
классы и не абстрактные классы. В общем,
интерфейс это следующее. То есть вы
внутри этого класса можете написать, какие
методы там есть у метода, какие методы есть у
класса message. То есть, точнее, что можно делать
сообщением. Например, сообщением можно делать
send, сообщением можно делать display. Ну и
допустим, display я сделал равно нулю. И он
виртуальный, естественно. Что это
означает? Это означает, что у любого
объекта, который я унаследую, который я
унаследую от message, у меня обязательно в
нем должны появиться методы send и метод
display. Да? И, соответственно, я через
вот эти вот ptr могу вызывать методы
display. Могу через этот ptr вызывать метод
send. Ну и так далее. Что? Ну потому что, наверное,
вы хотите, чтобы ваше сообщение можно было
как-то отправлять. То есть вы внутри
абстрактного класса пишете все действия,
которые можно совершать над
объектами, которые объединены, грубо говоря,
понятием сообщения. Любое сообщение
можно отправить, любое сообщение можно
показать на экране, любое сообщение, не знаю,
можно удалить. Ну и теперь вы можете
создавать указатель или ссылки на
сообщение и присваивать им конкретные
типы сообщения. Там текстовая, картинка,
стикер и так далее. И со всеми этими
сообщения теперь можно делать display, send
и тому подобное. Почему? Потому что эти
методы объявлены в абстрактном базовом
классе iMessage.
Да, ну то есть...
Нет, абстрактный класс это класс хотя бы
одним чисто виртуальным методом. А в абстрактном
классе может быть, например, один чисто
виртуальный метод, а все остальные методы
могут быть невиртуальными. Это нормально.
Ну давайте конкретный пример.
Почему, например, send может быть
невиртуальным, а display виртуальным?
Ну потому что send, допустим, логика
программы устроена так, что отправка
сообщения это просто, например, запись,
запись в логе, что вот там Вася отправил
сообщение Петь и все. То есть, естественно,
как бы нет смысла этот send
переопределять там для текста отдельно,
для стикера и так далее. То есть, сообщение
это просто одна строка там в логе и все.
А вот display уже работает по-разному, то есть
для текста, для картинки, для видео
display работает по-разному. И поэтому я
объявляю его чисто виртуальным.
Почему объявляю виртуальным? Для того,
чтобы наследники могли его
переопределить. А чисто виртуальным?
Ну потому что я хочу сделать абстрактный
класс, объект, которого нельзя создать и
плюс я не знаю, как мне написать
реализацию для display в общем случае.
Что? Затемнение можно, да, написать реализацию.
Хороший вопрос. Например, за этим.
Void. Давайте так напишем. Для чего
писать реализацию чисто виртуальным
методом? Ну, например, вот зачем.
Display. Вот я пишу здесь реализацию.
Ну и, допустим, представь себе, что у вас
есть какие-то общие действия, которые
необходимо сделать. Ну, например,
опять же, не залогировать, а ну.
Ну какие есть общие действия?
Отобразить, может, дату и время отправки.
OK? Например, display.date.time.
Все. Вот любое сообщение должно там
отобразить дату и время. То есть здесь
вы пишете некоторую общую логику. И
теперь в наследниках, вот. Ну и, например,
в наследнике, в текст message вы пишете
метод display и теперь вы можете написать так.
Вы можете сказать, что сначала мы делаем
общие действия, например, iMessage,
двоеточие, двоеточие, display. Ну, display.
А дальше пишете специфичные действия.
Вот. То есть сначала вы вызываете метод из
базового класса, а потом уже делаете те
действия, которые вам нужны. Вот, например, вот так.
Понятно?
Хорошо. Да, значит, абстрактный класс,
нельзя создавать объект абстрактного
класса, но при этом можно создавать ссылки
указателя на абстрактный класс. Вот.
Значит, еще одно свойство абстрактных
классов. Если вдруг наследник решит
подерзить и не будет переопределять
чисто виртуальный метод, то, в общем, в
наказание он сам автоматически становится
абстрактным. Ну, то есть, если у меня есть
iMessage и stickerMessage, который решил
не переопределять метод display, то с
этого момента stickerMessage тоже считается
абстрактным. То есть объекты такого типа
создавать нельзя, окей?
То есть наследуется как виртуальность, так и
чистая виртуальность, вот так.
Чтобы перестать быть чисто виртуально,
точнее чтобы перестать быть абстрактным,
нужно взять и переопределить
соответствующий чисто виртуальный метод.
И вот, собственно, в этом и заключается
решение проблемы с тем, чтобы заставить
обьекты производных классов
переопределять методы. Потому что, если
объекты производных классов это не
сделают, то они сами становятся абстрактными.
А им это нафиг надо, им это не надо. Понятно? Такие дела.
Да, вызов чисто виртуальных методов в конструкторах или деструкторах приводит к undefinedBehaviour,
но это к вопросу о том, что в конструкторах и деструкторах в принципе не стоит вызывать виртуальные методы,
а чисто виртуальные методы тем более. Это undefinedBehaviour.
Ну и про то, что мы говорили, абстрактные классы используются для определения интерфейсов,
для создания семейства классов с одинаковыми свойствами методами.
Но это, кажется, обсудили.
То есть, если вам нужно общий интерфейс вынести в какой-то отдельный класс,
то вы создаете абстрактный класс. И дальше все наследники обязаны будут это все реализовать.
Есть вопросы?
Хорошо.
Ну и сколько у нас? 10 минут осталось, отлично.
В общем, есть вопросы по лекции про наследование?
Про виртуальные методы, про...
Ну и теперь давайте 10 минут посетим тому, чтобы понять,
а как вообще работает механизм позднего связывания?
На этапе компиляции все понятно.
Компилятор просто подставляет нужные ассемблерные инструкции,
вызовы отдельно под инструкции и так далее, и все нормально.
А вот как работает механизм позднего связывания?
То есть как вообще, во время исполнения, понять, какую функцию нужно вызывать?
Вот это интересный вопрос.
Значит, работает это так.
Смотрите, как только... Представьте, что у вас есть класс.
Давайте структуру напишу, чтобы паблик не писать.
И у вас есть в нем виртуальная функция A.
Значит, как только у вас в классе появилась виртуальная функция,
для этого класса создается так называемая таблица виртуальных функций.
Таблица виртуальных функций.
Ну, что это такое?
Она, понятное дело, может быть устроена по-разному в зависимости от реализации,
но в общем случае там можно считать так.
Значит, таблица виртуальных функций это просто тип функции...
Это тип функции, который отображается в некоторый адрес вашей программе.
Где эта функция на самом деле расположена?
Ну, давайте я тут вместо адреса буду писать просто полное имя функции.
там a...f.
То есть для каждой виртуальной функции заводится некоторая запись в таблице виртуальных функций для класса A.
И давайте тут заведу еще виртуальную функцию g, для примера.
Виртуал int g.
Ну и здесь будет тогда int g.
И указатель будет вести, собственно, вот на начало инструкции для A.
Теперь я завожу структуру B.
Ну и давайте что я сделаю?
Я возьму и переопределю виртуальную функцию f.
А, да, спасибо.
B унаследуем от A.
Что происходит?
В B тоже есть виртуальные функции.
Так как B унаследуется от A, а в A есть виртуальные функции, то B уже не отвертится.
В B в любом случае есть виртуальные функции.
Поэтому для B тоже заводится таблица виртуальных функций.
В этой таблице тоже есть две записи.
Давайте еще одну функцию добавим.
Пусть будет три записи.
Virtual void h.
В таблице виртуальных функций для B есть три записи.
Какие?
Понятное дело, что это функция f.
Потому что раз это функция виртуальная в A, то эта функция виртуальная и в B.
Куда указывает указатель в этой таблице?
На B.
Почему?
Потому что B реализует функцию f по-своему.
И указатель, который находится здесь...
Указатель это некоторое 32-битное или 64-битное число.
Здесь пишу так.
Это просто указатель, который указывает вот сюда.
И этот указатель указывает вот сюда.
Какие есть еще методы?
Есть метод g.
Так как это тоже виртуальный метод, он унаследован от A.
Согласны?
Куда указывает указатель в этой таблице?
На A.
Потому что B не переопределяет функцию g.
То есть альтернативной реализации для g нет.
То есть единственная реализация, которая есть для g, это A.
Поэтому этот указатель указывает на A.
Хорошо?
Ну и также B заводит свою функцию h.
H будет h,
которая ведет, естественно, в B.
Вот.
Ну и так далее. Понятно, да?
То есть если вы там что-то наследуете от C,
то есть заводите класс C, который наследован от B,
заводите класс D, который наследован от A,
то для каждого такого класса
у вас заводится своя таблица виртуальных функций.
Все понятно.
Теперь.
Что происходит далее?
Значит, допустим,
мы пишем вот так.
Х равно nuB.
Дальше делаем ptr,
стрелочка на vtf.
Как компилятор понимает...
Тут есть главный вопрос,
вообще говоря.
Как компилятор понимает,
на какой тип указывает ptr?
Вообще говоря, это не тривиальная задача.
Потому что напомню, что здесь может стоять
что-то наподобие такого.
Х равно равно 0.
Х равно nuB,
иначе nuA.
То есть вообще говоря, компилятор
на этапе компиляции, он не понимает,
какой там на самом деле объект лежит.
Поэтому ему нужно как-то понять,
что там за объект.
Вот как компилятор понимает,
на какой объект на самом деле указывает ptr?
Вопрос такой,
но на понимание.
Точнее, я предлагаю вам решение,
а вы его покритикуйте.
Я говорю следующую вещь.
Если указатель ptr указывает
на объект типа B,
то это означает следующее.
Это означает, что у меня сначала лежит
объект типа A, а потом какая-то часть,
которая относится к B.
В памяти так устроено.
И компилятор просто проверяет,
вот эти биты относятся к A,
а вот эти биты относятся к B.
И если это действительно так,
то у меня объект типа B.
Если это не так, то объект типа A.
В чем проблема?
Что?
Ну нет, такого быть не может.
Если я вызываю метод f,
то это значит, что у меня
конструкторы все сработали.
Ну да, смотрите,
что происходит в памяти?
Что такое память, как она устроена?
Что в ней хранится?
Да, ну,
ну, нолики единички.
Единственное, что хранится в памяти,
это нолики единички.
Как по ноликам единичкам здесь
понять, точнее, вот тут, например,
есть какое-то polyintx.
Polyintx кодируется тоже каким-то
ноликами единичками.
Как чисто по ноликам единичкам
компилятору понять,
что там лежит
объект типа B, а не просто
какой-то рандомный мусор?
Ну согласитесь, что если у вас есть
объект типа A,
а правее него ничего нет,
то есть тут лежит какой-то мусор.
Но согласитесь, что этот мусор,
он может быть так устроен, что он очень сильно похож
на объект типа B.
Ну и проблема.
Поэтому такой план проваливается
естественным образом.
То есть даже если бы тут хранилась какая-то информация,
вот представьте себе, что компилятор
бы здесь хранил какую-то информацию о том,
что начинается B.
Не знаю, в каком-то виде он бы
закодировал.
Но тогда бы это тоже не работало, почему?
Потому что если на самом деле у вас тут лежал объект типа A,
то за объектом типа A у вас бы лежал какой-то мусор.
А вот эти самые мусорные биты,
они могли бы выстроиться в такую цепочку,
которая бы давала вам B.
Что?
Ну это маловероятно, но такое возможно.
Чтобы уменьшить вероятность,
нужно было все больше и больше бибитов откусывать.
В общем, беда.
В общем, так делать нельзя.
А как делается?
Делается за счет некоторого понижения
производительности.
Делается так.
Вот если вы посмотрите на
сайзов полиморфных классов,
то есть у классов, которые есть виртуальные функции,
то увидите, что у всех размер
как минимум больше на 8 байт.
То есть скажем, если у вас
в структуре A хранится
поле типа long,
ну или long-long давайте,
int64t,
то вообще говоря,
окажется, что размер типа A
должен занимать 8 байт.
Вот если вы посмотрите на его реальные сайзов,
то увидите 16 байт.
Почему? Куда уходит еще дополнительные 8 байт?
А уходят они на так называемый указатель
на таблицу виртуальных функций.
Указатель
на таблицу
виртуальных функций.
Ну или WPTR.
Что это такое?
Значит смотрите, у каждого класса
полиморфного
есть своя таблица виртуальных функций.
Мы про это говорили.
Теперь.
Вот есть объект типа A.
Значит на самом деле в памяти
все устроено так. Если у вас класс A
содержит виртуальные методы,
ну или у него есть таблица виртуальных функций,
то это означает, что
все поля
объекта A хранятся здесь.
А перед объектом типа A 8 байт
отводится на так называемый указатель
на таблицу виртуальных функций.
И этот указатель как раз таки указывает на нужную таблицу.
Понятно?
То есть как это работает? Снова.
Я завожу указатель на A.
PTR. И делаю
указатель B.
Что у меня происходит в памяти?
В памяти создается объект типа B.
То есть это часть, которая относится к A,
это часть, которая относится только к B.
И при этом в начале дописывается
специальный 8 байт,
в котором хранится указатель
на таблицу виртуальных функций для B.
И этот указатель указывает вот сюда.
Понятно?
Тип указатель на таблицу виртуальных функций.
Зависит от реализации.
Можно.
Короче, вот то, что я рассказываю,
давайте так, вот то, что я рассказываю,
этого в стандарте не описано.
То есть как бы стандарт
просто пишет, что вот нужно
поддержать возможность динамического полимархизма.
Вот то, что я сейчас рассказываю,
это то, как реализовано
в подавляющем большинстве компиляторов.
И скорее всего у вас.
То есть этот указатель вы можете достать
и посмотреть его.
Но вообще это не гарантируется.
Но скорее всего именно так это и происходит.
И теперь,
смотрите, что происходит,
когда я вызываю PTR стрелочка F.
Что на самом деле происходит?
А на самом деле происходит следующая вещь.
Компилятор смотрит вот сюда.
Во-первых, компилятор понимает,
что A это полиморфный тип.
То есть у него есть виртуальные методы.
Что это означает?
Это означает, что первые 8 بайт
это указатель на таблицу виртуальных функций.
Так, это указатель на таблицу виртуальных функций.
Он просто берет
и идет по этому указателю.
Приходят вот сюда.
Всё, по этому указателю
он приходит в таблицу виртуальных функций.
А уже в таблице виртуальных функций
компилятор ищет нужную ему функцию f
и вот здесь обращается
по нужному адресу к нужной ему функции.
И именно в этом заключается долгое время работы. Почему?
Потому что ему нужно сначала разоминать этот указатель,
пойти в таблицу, разоминать вот этот указатель,
пойти в нужную функцию и только потом начинать ее выполнять.
Понятно, как это устроено?
Еще раз, для каждого класса, в котором есть виртуальный метод,
заводится таблица виртуальных функций.
Когда вы создаете объект такого класса,
у вас размер каждого объекта увеличивается на 8 байт.
Эти 8 байт нужны для того, чтобы хранить указатель на эту самую таблицу.
И теперь компилятор, когда вы будете использовать такой синтаксис,
с помощью ссылки или указателя,
компилятор будет в первую очередь смотреть на этот указатель,
и вот по этому указателю компилятор уже может понять,
какой тип, тип A, тип B или C.
Все, дальше он проходит по этому указателю в нужную таблицу
и за эту таблицу вытаскивает нужную функцию.
Вот так это работает.
Ну все, в общем, с полиморфным наследом закончили.
Виртуальные функции позволяют использовать полиморфное наследование.
Необходимо помнить о необходимости использования виртуального деструктора,
если у вас есть виртуальные методы.
Нужно использовать override, если вы хотите переопределить виртуальные методы.
Ну и есть чисто виртуальные функции, которые делают классы абстрактными.
Основные тезисы лекции.
Сегодня продолжим геометрию и поговорим продробно про выпуклые многоугольники.
Нам будет достаточно определения выпуклого многоугольника,
как многоугольника такого, что при продолжении произвольной стороны
у вас все точки находятся по одну сторону от прямой.
Это одно из определений выпуклости многоугольника.
Ну и, естественно, первый вопрос, который тут может возникнуть,
это, собственно, следующий.
Ну, естественно, мы многоугольник, давайте про это скажем еще раз,
что многоугольник будем представлять в виде упорядоченного набора вершин,
то есть в виде упорядоченного по часовой стрелке или против часовой стрелки,
в общем-то говоря, неважно.
Потому что они как-то упорядочены в некотором массиве вершин.
И, соответственно, первый вопрос, который можно поставить,
это, смотрите, вам дан многоугольник.
То есть многоугольник вам дан в виде некоторого массива вершин.
Собственно, можно поставить вопрос, а является ли этот многоугольник выпуклым или нет?
Что вам подсунули? Выпуклую штуку или нет?
То есть тест на выпуклость.
Что мы можем сделать?
Ну, смотрите. Самый простой алгоритм, который, в принципе, может придумать,
это действует чисто по определению.
Давайте возьмем просто каждую сторону, и для каждой стороны просмотрим все точки и определим,
находятся ли они по одному сторону от прямой или нет.
Наивный алгоритм, кажется, понятен.
Просто-напросто по определению все проверим.
За сколько этот алгоритм работает?
За квадрат, да.
Наивный алгоритм работает за большое от n квадрат.
Ну понятно, нам нужно перебрать каждую сторону,
и для каждой стороны мы проходимся по всем вершинам.
Соответственно, n квадрат.
Давайте попробуем как-то этот алгоритм улучшить.
Улучшать и предлагаю его следующим образом.
Я предлагаю проверять не все вершины, а только одну.
Ну, смотрите, вот я взял какую-то сторону.
Вот эту.
И давайте я просто-напросто проверю угол, который составляет,
ну, вектор, который проходит от вершины, ну давайте, в общем случае,
ПК, ПК плюс один, и ПК плюс один, ПК плюс два.
Вот давайте я проверю угол между двумя последовательными векторами сторон.
Я утверждаю следующую вещь.
Что если у меня, ну, то есть если я прохожусь по всем сторонам,
то есть сначала такой, такой, такой, такой,
что если приобходит нам по часовой стрелке или про часовой стрелке,
то у меня все углы будут либо положительные, либо отрицательные.
Вот если знаки всех углов совпадают,
то в этом случае у меня многоугольник выпуклый.
Вот, значит, предложение такое.
Последовательно
рассмотрим пары ПК, ПК плюс один, и ПК плюс один, ПК плюс два,
ну, пара и вектор, давайте, вектор.
И знаки углов между ними.
И критерий такой, значит, если знаки все больше либо равны нуля,
ну, или меньше либо равны нуля,
то выпуклый.
Иначе нет.
Ну, давайте вспомним, ну, что тут можно вспомнить.
Знаки углов между ними.
Каким образом мы считаем знаки углов между векторами?
Через синус, а если?
Через векторное произведение, да, отлично.
То есть нам тут достаточно, на самом деле, посчитать просто векторное произведение
ПК, ПК плюс один, и ПК плюс один, ПК плюс два.
Вот, читаем векторное произведение, следим за знаками.
Если в какой-нибудь момент встретились два разных знака,
то есть все время было плюс-плюс-плюс, в какой-то момент появился минус,
то останавливаем работу.
И наоборот, если все время было минус-минус-минус,
в какой-то момент встретились плюс, то тоже завершаем работу.
Ну, пока алгоритм понятен, да?
За сколько он работает?
За линию.
За линию.
Мы просто проходимся по всем парам,
ну не по всем, а просто по последним парам.
Сначала вот эту пару, потом вот эту пару, потом вот эту пару и так далее.
Ну, всего последних пар, естественно, у от n.
Короче, их не больше n.
Поэтому алгоритм работает у от n.
Ну и теперь главный вопрос, а почему на самом деле это так?
Почему это работает?
Ну, смотрите.
Доказательство корректности.
Давайте попробуем доказать по индукции.
Ну, начнем с n равного 3.
То есть многоугольники начинаются с n равного 3.
Ну, здесь все понятно.
Любой треугольник выпуклый.
Согласны, да?
Ну, здесь...
Любой треугольник выпуклый, ну и плюс для любого треугольника вот это свойство тоже выполняется.
Поэтому все нормально.
Теперь.
Пусть верно для любого n меньше, чем...
Любого n-штрих меньше, чем n.
Вот.
Рассмотрим n-угольник.
n-угольник, у которого...
Ну, вот эта штука выполнена.
Вот.
Окей?
Ну, вот взяли произвольный многоугольник и сказали, что, ну вот, допустим,
все время каждый угол выполняется на один и тот же поворот.
Давайте покажем, что такой многоугольник будет являться действительно выпуклым.
Ну, что мы сделаем?
Давайте возьмем произвольную точку k.
Возьмем...
Произвольную точку pk.
И удалим ее.
Из n-угольника.
Ну, то есть у меня был какой-то многоугольник.
Вот.
Эта точка pk.
Вот, я от нее избавился временно.
Все время на ее удаляю.
Вот, что я получил?
Я получил на самом деле...
Я утверждаю, что я получил n-1-угольник.
N-1-угольник.
С выполненным звездочкой.
То есть звездочка для такого n-1-угольника, говоришь, не выполняется.
Вопрос, почему?
На самом деле это не очевидно.
То есть если для какого многоугольника это выполняется,
то почему это будет продолжать выполняться для такого многоугольника?
Ну, пояснение такое.
Вот.
Значит, это k-1.
pk.
Тут еще.
k-2.
k-1.
И вот на самом деле хочется понять...
Вот эту точку я удалил.
И хочется понять, действительно ли угол.
Давайте я буду предполагать, что у меня все время происходит...
Точнее, поворот происходит в положительном направлении.
Давайте я буду предлагать, что у меня все время происходит в положительном направлении.
Давайте я докажу, что для pk-1 и pk-1 поворот относительно такой прямой
тоже происходит в положительном направлении.
Допустим, это не так.
Как это может получиться?
Как могло получиться так, что у меня вот этот поворот
Пк плюс один осуществляется в наоборот отрицательном направлении.
Это значит, что у меня картинка выглядит на самом деле не так,
а каким-то таким образом.
Тут Пк, и вот тут где-то Пк плюс один.
Справедливо?
А что это в свою очередь означает?
Да.
В свою очередь означает, что тогда у меня от этой прямой
есть две точки, которые находятся по ее разные стороны.
Для некоторой тройки здесь не выполняется условие звездочка.
Поэтому такого быть не может.
Окей.
Все.
Тогда тут получили Пк минус один и Пк плюс один.
Ну и на самом деле утверждаю, что мы все доказали.
Действительно, рассмотрим вот такой n минус один угольник.
Для него выполняется звездочка.
Также по предположению индукции для него выполняется условие...
Ну, короче, для него все выполняется.
Вот для такого n минус один угольника у меня выполняется звездочка,
а соответственно он является выпуклым.
Согласны?
Ну и давайте рассмотрим здесь все поподробнее.
Теперь как мне доказать, что вот если у меня есть выпуклый многоугольник,
как мне доказать, что если я добавлю вот такую точку Пк,
как мне показать, что у меня действительно многоугольник будет по-прежнему выпуклый?
Ну, на самом деле достаточно просто.
Достаточно просто понять следующую вещь.
Смотрите, что мне известно про расположение точки Пк?
Точка Пк точно находится по левую сторону от вот такого вектора.
То есть точка Пх находится здесь.
Аналогично мне известно, что точка Пк находится по левую сторону от вот такого отрезка.
Ну, по звездочке.
Соответственно Пк находится где-то вот в этой области.
Плюс, мне что еще дополнительно известно, может ли точка Пк находиться где-то здесь?
Нет, не может. Почему? Потому что у меня повороты везде одинакового знака.
Если у меня точка Пк была где-то здесь, то поворот здесь бы осуществлялся в отрицательном направлении.
Что противоречит звездочке?
Соответственно ничего не остается, кроме как Пк быть здесь.
Ну, а мы знаем, что любая точка, которая находится здесь, создает мне выпуклый многоугольник.
Ну, это понятно.
То есть все, мы показали, что без точки Пк у меня многоугольник выпуклый,
а с точкой Пк... ну, а точка Пк мне ничего не портит.
Точка Пк тоже делает выпуклый многоугольник.
Ну, вот, собственно, и все.
Понятно?
Вот такая история.
Окей, мы научились проверять многоугольник на выпуклость.
Теперь давайте перейдем...
Ну, даже не перейдем, давайте вернемся к прошлой лекции.
Мы закончим на прошлой лекции, и на чем?
Помните, что мы обсуждали в последний раз?
Да, принадлежит ли точка внутренности многоугольника или нет?
Вот я утверждаю, что если у меня многоугольник выпуклый...
Да, и какой алгоритм у нас был за какое время?
Или мы не обсудили, за сколько он работает?
Ну, хорошо, если не обсудили, за сколько работал наш алгоритм,
который мы обсудили в прошлый раз.
Ну, интуитивно.
Ну, за линию, да, давайте я напомню, что мы делали.
Мы брали точку и просто проводили либо горизонтальную,
либо под каким-то углом, ну, в общем, проводили какую-то прямую.
Ну, в зависимости от метода, который вам больше понравился.
В общем, так или иначе мы проводим какую-то прямую,
и даже считаем количество пересечений.
Да?
А как мы считаем количество пересечений?
Ну, мы просто проходим все последовательно
по каждому отрезку многоугольника
и смотрим, пересекается он случом или нет.
Проверка, пересекается ли отрезок случом или нет,
мы умеем выполнять за единицу.
Соответственно, общая работа, линия.
То есть за линию мы умеем проверять,
находится ли точка внутри многоугольника или нет.
Вот.
Так вот, я утверждаю, что если у меня многоугольник выпуклый,
то мы можем проверять,
а вот я утверждаю, что если у меня многоугольник выпуклый,
то эту задачу можно решить гораздо быстрее.
Второй пункт.
Принадлежность точки
внутренности выпуклого многоугольника.
Как мы это будем делать?
Ну, смотрите, допустим, неизвестно,
что многоугольник выпуклый.
Мне известно, что многоугольник выпуклый.
Давайте возьму произвольную сторону,
ну, даже вектор, наверное, с стороны p0 и p1.
И задам вам следующий вопрос.
Что можно сказать про вектора p0, p1, p0, p2, p0, p3 и так далее?
p0, pn-1.
Ну, вот про эти вектора.
p0, p1, p0, p2, p0, p3, p0, p4, p0, p5.
Вот, случай выпуклого многоугольника.
Ну, понятно, что мы будем делать.
Ну, понятно, они не пересекаются.
Что еще? Ну, самое главное.
Да, что? Еще раз.
Ну, в одну сторону.
Вот именно в таком порядке,
если их перечисляют, то что происходит?
Заметьте, что они идут по возрастанию угла.
По возрастанию угла относительно p0, p1.
То есть тут угол p0, p1 вставляет 0,
ну, самим собой.
Дальше угол p больше, больше, больше и так далее.
То есть здесь все идет по возрастанию.
Ахи, вы знаете алгоритмы,
которые работают быстрее,
если у вас что-то есть по возрастанию?
Бинпоиск. Отлично.
Отлично.
Ну, давайте, у меня есть какая-то точка
штрих.
Я хочу проверить, лежит ли она внутри
многоугольника или нет.
Ну, давайте придумаем какой-то алгоритм.
Что мы будем делать?
Видимо, каким-то бинпоиском
найдем положение
по 0, по штрих.
Ну, посмотрите, бинпоиск
мне находит какой-то вектор.
То есть либо вот этот вектор, либо вот этот вектор.
Ну, есть ли разница,
какой вектор искать?
Ну, давайте какую-нибудь умную фразу скажем.
Ну, смотрите, бинпоиск
притягивается,
ну, смотрите, бинпоиск
предполагает, что бинпоиск
как бы предполагает
ответ на вопрос, есть ли такой вектор
или нет.
Ну, естественно, скорее всего, вот именно такого вектора
у вас среди этого набора нет.
Поэтому бинпоиск будет вращать всегда false.
А что нам на самом деле нужно?
Нам нужен не бинпоиск, а какой-то алгоритм,
который на нем основан.
Во, супер, upper bound или lower bound?
Давайте найдем lower bound, например.
Все помните такое lower bound?
Первый шаг.
Так, плохо видно, да?
Lower bound.
Ну, давайте сам полигон,
вот это вот все я буду обозначать как
побольшое.
А точку, которую хочу найти,
а вектор, которую хочу найти, по ноль, по штрих.
То есть я хочу найти
в многоугольнике P
lower bound
для вектора
ноль по штрих.
Ну, что такое lower bound?
Это первый
элемент.
Такой что? Какой?
Больше либо равен, да.
Первый элемент, который больше либо равен.
В данном случае
какой вектор у меня является lower bound?
Ну, по ноль по 4, да.
Все, то есть я нашел
вектор, который по углу,
точнее, первый вектор по величине.
Наименьший по величине
вектор, который больше либо равен,
чем нужный мне вектор.
Понятно?
И что я дальше делаю?
Ну, понятное дело, что если я знаю
такой вектор, то я знаю и
следующую по величине,
то есть вот такой вектор.
То есть, грубо говоря, что?
Ну, почти.
То есть я знаю,
что у меня вот этот вектор, он зажат
между вот таким вектором
и вот таким вектором.
И что мне осталось проверить?
Вот эта точка находится
между вот таким лучом
и между вот таким лучом.
И что мне на самом деле остается проверить?
Да, мне нужно на самом деле проверить,
по какую сторону эта точка расположена
относительно вот этого отрезка.
Ну, или в общем случае нужно просто проверить,
принадлежит ли эта точка вот этому треугольнику.
Ну, понятное дело, что это все делается
за вот единицами. Не важно, каким алгоритм
вы используетесь.
Да?
Lower bound.
Давайте, продолжаем писать.
Находим
p0, pk
и p0,
pk
плюс один,
между которыми
зажат
зажат
вектор p0, p'.
Классно?
Ну, вот этот первый шаг
он выполняется как раз таки за от логарифма.
Потому что это по сути бинпоиск.
Точнее алгоритм, который основан
на бинпоиске, да?
Log n.
Ну, все.
Ну и второй,
последний пункт,
этот алгоритм второй.
Проверяем
p'
принадлежит,
ну, давайте
треугольнику
p0, pk,
pk плюс один,
да, у меня?
pk, да.
pk плюс один.
Вот, ну, можно так.
По какую сторону
от pk
pk плюс один
располагается p'.
Все.
Вопросы?
Все понятно?
Смотрите, тогда у меня такой вопрос.
Смотрите, ну, вроде как,
я обещал,
что
мы вообще никак не будем привлекать там всякую,
там всякие приближенные
вычисления, вычисления углов и так далее,
а вот
смотрите, когда я сравниваю угол,
смотрите, когда я делаю бинпоиск,
мне же на самом деле нужно сравнивать углы.
Согласны?
То есть как устроен бинпоиск? Я просто сравню, грубо говоря,
вот эта штука больше, чем этот вектор или нет,
но я сравниваю их по углу.
Не возникает ли это противоречием? То есть мне же нужно сравнить углы,
а как мне сравнить углы,
не вычисляя их?
Косинус не совсем.
Косинус тут не поможет.
Да, опять же, синус.
Ну, точнее, величина знака, да,
смотрите еще раз.
Вот, есть два произвольных вектора.
Вектор A,
вектор B.
Ну, вот горизонтальный вектор,
а вектор B,
и вот горизонтальная ось, допустим.
И мне нужно понять, вот угол A,
который составляется вот этой осью
он Больше, чем вектор,
Больше, чем угол, который составляет B с этой осью или нет?
Как мне это понять?
Давайте так,
B меньше, чем A, ну давайте угол,
который составляет B меньше, чем угол, который составляет A,
тогда и только тогда?
Когда поворот от Б к A совершается
в положительном направлении,
Согласны?
То есть тогда и только тогда, когда...
Давайте поменяем местами, чтобы...
Давайте вот так.
Ну, более привычно.
А меньше b, тогда и только тогда, когда векторное произведение a и b больше нуля.
Согласны?
Всё.
Чтобы сравнить углы, которые составляют векторы, мне достаточно просто сравнить векторные произведения.
Поэтому тут по-прежнему, мне не нужно привлекать какие-то аркосинусы, арксинусы, аркангенцы.
Я собираюсь по-прежнему вот в парадигме векторных и скалярных произведений.
Всё.
Замечательно.
Всё, могу стирать.
Ну и еще одна тема, которую стоит обсудить в цикле разговоров про геометрию, это выпухлые оболочки.
Значит, выпухлые оболочки или по-английски convex hull.
Значит, выпухлые оболочки множество точек, множество точек s, называется минимальная по включению,
минимальная по включению выпухлое множество, содержащее s.
Ну то есть у меня есть какое-то множество точек.
И я строю такое выпухлое множество. Что такое выпухлое множество?
Выпухлое множество, давайте вот, математическое определение, оно на самом деле не понадобится.
В общем, выпухлое множество это то множество, которое вместе с любой парой точек содержит все промежуточные точки.
То есть если вам известно, что есть точка A и есть точка B, и они оба принадлежат выпухлое множество,
это означает, что все точки между ними тоже лежат в этом выпухлое множестве.
Ну то есть грубо говоря, вот такая фигура, она не является выпухлой. Почему?
Потому что вот есть пара точек, и вот эти точки посередине ему не принадлежат.
Но при этом круг является выпухлым множеством.
Какую бы пару точек они взяли, у вас промежуточные точки тоже лежат в этом множестве.
Грубо говоря, я хочу построить такую оболочку всех моих точек,
которая была бы выпухлой, минимальной, и которая бы естественно все точки содержала.
То есть грубо говоря, это такое некоторое минимальное описание моего множества точек.
Ну естественно, для произвольного множества точек, не знаю, для бесконечного множества точек,
выпухлая оболочка может быть, ну вообще говоря, довольно произвольной фигурой.
Например, если я возьму счетное множество точек, которые расположены по окружности,
то выпухлой оболочкой такого множества точек будет окружность.
Дело немного обстоит по-другому, если я использую конечное множество точек.
Можете ли вы предположить, что будет являться выпухлой оболочкой конечного набора точек?
Допустим, я беру вообще произвольные точки, но при этом их конечное число.
7. Что будет являться выпухлой оболочкой?
Ну в данном случае там шестиугольник, ну а в общем случае?
Просто какой-то многоугольник, да.
Ну это доказательство мы опустим, но если неформально, то понятное дело,
что если мы следуем определению изматона выпуклости,
то мы просто-напросто проводим всевозможные отрезки.
Ну и по определению выпуклости у меня все отрезки должны быть внутри моего выпухлого множества.
Поэтому, естественно, минимальная фигура, которая содержит все вот эти вот точки,
все вот эти отрезки, это будет, грубо говоря, вот эта вот самая внешняя граница.
Внешняя граница этой фигуры.
Поэтому давайте отдельно пропишем, что выпухлая оболочка конечного множества точек является
выпухлый многоугольник,
вершина которого, давайте, конечного множества S,
вершина которого принадлежит S.
Вот, то есть что мне нужно сделать, в чем стоит задача?
Ну сейчас у нас.
Нам будет дано какой-то произвольный набор точек конечный,
и нам нужно из этого конечного набора точек выделить такие точки,
которые будут являться вершинами нашего выпухлого многоугольника.
Ну короче говоря, нам дан произвольный набор множества точек,
и нам нужно из него вытащить такой многоугольник, который бы являлся их выпухлой оболочкой.
Вот такая вот цель на оставшуюся часть лекции.
Ну и давайте начнем, наверное, с алгоритма Джарвиса.
Забыл.
Так, алгоритм Джарвиса.
Ну еще иногда его называют алгоритм упаковки подарка.
И вот почему.
Давайте рассмотрим произвольное множество точек.
Ну и давайте с такой чисто житейской точки зрения подумаем,
как бы нам построить для такого множества точек выпухлую оболочку.
Ну давайте возьмем какую-нибудь точку, которая гарантирована,
которая точно войдет в нашу выпухлую оболочку.
Это какая точка?
Ну либо самая левая, либо самая верхняя, самая правая, самая нижняя, не важно.
Давайте возьмем самую нижнюю точку.
Понятное дело, что самая нижняя точка обязательно должна быть выпухлой оболочки.
Ну и дальше я сделаю следующую вещь.
Давайте я возьму бесконечную такую ленту,
и буду этой лентой оборачивать мои точки, как будто заворачиваю подарок.
Ну либо можно сказать, что тут прибиты какие-то гвоздики в стене.
Я взял веревку и начал потихоньку оборачивать все вот эти вот гвоздики.
Я беру и поворачиваю в положительном направлении, то есть против чего стрелки, вот этот самый луч.
Что я в итоге получу?
В какой момент у меня луч упрется во что-то?
Ну вот в этот момент.
Что это за момент такой? Что это за точка?
С математической точки зрения.
Да, с минимальным углом относительно горизонтали.
Я беру вершину с минимальным углом.
Ну и собственно давайте я возьму эту точку в мое выпуклое множество.
При этом заметьте, что по построению у меня все окей.
То есть я на самом деле утверждаю, тут корректность мы не будем строго доказывать, но вообще по построению тут все окей.
Почему? Потому что если я взял вот такой луч, то у меня гарантированно правее него ничего нет.
Все остальные точки остались только левее.
Поэтому выпуклость у меня сохраняется.
То же самое здесь.
То же самое здесь.
Ну теперь я беру вот эту точку и относительно этой точки начинаю продолжать заворачивать, в общем, заворачивать упаковку.
Что у меня произойдет дальше?
Ну дальше я встречу вот эту точку с наименьшим углом относительно вот этой прямой.
Точнее вот этой луча, согласны?
Ну и так далее.
Встретил вот эту точку, дальше продолжаю заворачивать упаковку.
и в какой-то момент встречу точку с наименьшим углом относительно вот этой прямой.
И так далее. Продолжаю заворачивать, встречаю вот эту точку.
Продолжаю заворачивать эту точку, ну и в какой-то момент приду в изначально.
Это идея алгоритма. То есть, естественно, это не алгоритм, да?
Это идея. Так, давайте перейдем к формальному описанию того, что мы на самом деле сделали.
И за сколько это все работает?
Первым шагом мы выбираем...
Как я обозначил?
Мы выбираем по штрих.
С наименьшей координатой y.
Ну опять же, почему это так? Потому что точка с наименьшей координатой y,
с наименьшей координатой x, неважно, в любом случае эта точка войдет в выпуклую оболочку.
Потому что мы не имеем права ее не взять. Иначе она ничем не будет захвачена.
Короче, если таких точек несколько, то, давайте так, если таких несколько,
например, они расположены одной прямой, таких несколько, то среди них
с наименьшей координатой x.
В общем, если таких точек несколько, если все расположенные на минимальном y,
на одной прямой, то убираем точку с наименьшей координатой x.
То есть самую левую, самую левую нижнюю точку.
Дальше. Второй пункт делаем следующим образом.
Пи, выбираем так, что
пи-2, пи-1 угол, пи-1пи, является
минимальным среди всех, среди всех п, принадлежащих многоугольнику.
Ну, короче говоря, вот у вас есть, да, кстати, надо видимо отдельно сказать,
что есть точка п0, мы ее выбрали как минимальную.
Дальше мы выбираем точку п1, как минимальную,
ну, которая составляет минимальный угол с горизонталью.
Давайте это отдельно там пропишем.
Какой-нибудь пункт, один штрих, п1, образует минимальный угол с горизонталью.
Вот. То есть теперь, когда у меня есть две точки,
я выбираю следующую точку п2 так, чтобы вот этот вот угол
между вот этим вектором, то есть, который образован двумя последними точками,
и вот этот вектор, чтобы он был минимальным.
То есть, ну, понятное дело, что у меня есть много кандидатов, да,
но среди них я выбираю такой, который образует минимальный угол.
Да. Может так получиться, что таких несколько.
Ну, то есть, вот представьте, что тут тоже есть несколько точек,
которые расположены на одной прямой.
Тогда какую точку мне среди них нужно выбрать?
Самую дальнюю?
Самую дальнюю, да.
Ну, снова. Если таких несколько, то самая дальняя.
Вот. Ну и повторяем. Повторяем пункт два.
До каких пор? Ну, пока не вернемся в изначальную точку.
Пока Pi не равно по ноль. Ну или, что у меня тут, по штриху было, да?
По ноль тогда обозначу.
Окей? Что?
А вот не совсем. Ну, в худшем случае, действительно, он работает за n квадрат.
Ну, давайте, действительно, давайте обсудим, за сколько он работает.
Ну, давайте по порядку, значит, по каждому пункту.
Ну вот, пункты один и один штрих суммарно работают за сколько?
Ну, не более, чем за линию, согласны?
Ну, нужно просто пройтись по всем точкам и найти там минимальную по y,
ну, и потом еще дополнительно пройтись по всем точкам и найти точку с минимальным углом относительно горизонтали.
То есть тут как бы линия, два прохода всего, да?
Окей. Теперь суммарно сколько работает пункты два и три?
Ну, давайте так. Сколько всего итераций пункта два мне потребуется?
Да, сколько точек выпулой оболочки?
Всего итераций h. h это количество точек выпулой оболочки.
Ну, то есть, ну, в данном случае сколько всего точек?
Раз, два, три, четыре, пять, шесть. Ну, то есть примерно шесть итераций.
Так, и на каждой итерации я трачу сколько времени?
Сколько мне нужно времени, чтобы среди всех точек найти точку, которая образует минимальный угол?
Ну, n, да. То есть я просто беру и за линейное время нахожу минимально от n.
Ну, то есть суммарная сложность, о большое, от n, h.
Можно вопрос?
Да.
А если мы, допустим, можем вот сейчас вот точек по эти находимся,
нам уже не надо пойти и по ноль проверять.
Не можно ли нам перейти и по ноль проверять?
Можно. Ну, как бы, в этом случае у вас будет оценка n-h.
Н-h на h. Ну, не сильно, вы ничего не выиграете от этого.
Ну, действительно, можно те точки, которые уже добавили в облочку, их можно не рассматривать.
Но это не сильно повлияет.
И здесь сразу мы видим следующую вещь, что у вас как бы время работы зависит от ответа.
Ну, это на самом деле не очень хорошо, потому что вообще говорят,
вот в этом случае
такие алгоритмы не считаются полиномиальными.
Потому что, как бы, пол escaped stopped from a display algorithm.
Но, nachusson-semit contractor околонал это было все Venezuela,
В этом случае, ваше алгоритм работает за n квадрат.
Ну, какой это случай?
Ну, вот если у вас внезапно все точки выстроились по окружности, например.
В этом случае у вас все точки войдут в вашу выпуклую оболочку.
Понятно эта оценка, откуда берется?
Чем она хороша, чем она плоха?
В общем, алгоритм Джарвиса работает нормально, если вы действительно заранее знаете,
допустим, из свойств ваших точек, из свойств вашей задачи.
Если вы точно знаете, что у вас количество точек выпуклой оболочки будет немного.
Например, вы знаете, что у вас точки в основном сконцентрированы в центре,
а снаружи очень мало точек.
В этом случае нормально.
Но в худшем случае у вас алгоритм по-прежнему будет работать за n квадрат,
что не очень приятно.
Так, будем писать псевдокод или на слово поверим?
Все, отлично, супер. Мы на одной волне, замечательно.
Давайте тогда попробуем придумать что-то более...
В общем, алгоритм Джарвиса на самом деле очень прост.
То есть он тут всего три пункта, и в целом все нормально.
Да, давайте еще такой вопрос на понимание.
Все ли понимают, что здесь снова не нужно никаких углов вычислять?
Ну, снова минимальный угол можно посчитать просто с помощью векторного произведения.
То есть мы берем два вектора и сравним их между собой.
Как их сравнить между собой?
Просто взять их векторное произведение.
Чем больше векторное произведение, тем дальше вот этот вот отрезок находится,
точнее так, неправильно сказал, по величине угла,
по знаку угла между этими векторами.
Если угол положительный, то значит этот вектор находится дальше.
Вот этот вектор находится дальше.
Если угол отрицательный, то значит этот вектор находится ближе.
Ну, придется...
Что сказать быстрее всего?
То есть если вы видите, что у вас векторное произведение 0,
то вы просто на самом деле смотрите на модуль координат вот этих вот штук.
То есть у вас сравнение происходит следующим образом.
Если векторное произведение меньше 0, то то,
если векторное произведение больше 0, то то,
если векторное произведение равно 0, то сравниваем еще и длины.
Простой алгоритм Джарвиса, который в худшем случае работает за н квадрат,
в лучшем случае, если повезет, работает за линию.
Окей.
Но хотелось бы чего-то более хорошего.
И вот, прежде чем перейдем к следующему алгоритму,
наверное стоит сделать замечание и рассказать следующую вещь.
Вообще говоря, в общем случае, быстрее, чем занять log n,
у вас построить выпуклую оболочку вряд ли получится.
И вот последующая причина. Давайте замечание просто.
Давайте так. Нижняя оценка
на скорость
построения выпуклой оболочки.
Вот утверждается, что быстрее, чем за
n log n вряд ли получится.
Ну, что значит в общем случае, сейчас расскажу.
У вас был в первом семе, то есть вы обсуждали нижнюю оценку на скорости сортировки?
Да или нет?
Все знают, что быстрее, чем за n log n сортировать в принципе в общем случае нельзя.
Все, отлично.
И с этим на самом деле это очень сильно связано.
Смотрите почему.
В общем, я утверждаю, что если вдруг мне получится построить выпуклую оболочку
быстрее, чем за n log n, то это значит, что я смогу сортировать быстрее, чем за n log n.
И вот такой причине.
Вот, представьте себе, что у меня есть точки
x0, x1, x2, ну и так далее, x1-1.
Ну, не точки, а точнее массив значений.
Окей?
Теперь, что я сделаю?
Давайте я из этих чисел, не важно, что это,
ну, допустим числа, я сделаю следующую штуку.
Я построю точку из точки с вот такими координатами.
То есть точки с абсциссой x и и ординатой x и в квадрате.
Окей?
Ну, как будут выглядеть эти точки на плоскости?
Вот таким образом.
Ну, вот тут где-то у меня точки.
И я ставлю им соответственно, ну и тут где-то ноль.
И вот у меня точки.
Вот, вот, тут, пусть тут.
Согласны?
Ну, то есть они все лежат на параболе.
Что произойдет, если я построю выпуклой оболочку этих точек?
Ну, понятное дело, что они все, что все эти точки
войдут в выпуклую оболочку. Согласны?
То есть я не могу, то есть выпуклая оболочка будет
состоять из всех этих точек.
То есть я построю многоугольник на этом наборе точек.
А мы знаем, что многоугольник у него все вершины упорядочены.
Да, ну, то есть сначала тут одна точка, потом следующая, следующая, следующая и так далее.
То есть, по сути, если я умею, если я умею
строить выпуклую оболочку быстрее, чем за n лог n,
то по сути это означает, что я эти точки,
x1, ну, xi, xj и так далее,
получается, что все эти точки я тоже отсортировал в порядке возрастания.
Ну, а это противоречие. Ну, нельзя сортировать быстрее, чем за n лог n.
В общем случае.
Ну, точнее, сортировка, которая основана только на сравнениях.
Поэтому в этой модели вычислений, основанной только на сравнениях,
быстрее, чем за n лог n, построить выпуклую оболочку тоже нельзя.
Окей?
Вот.
Вот.
Ну, точнее, если у меня алгоритмы по строению выпуклых оболочек
вообще не предполагают никакой структуры в данных,
то есть не предполагают, что у меня все точки там целы,
не предполагают, что у меня там точки имеют какое-то определенное распределение,
то вообще говоря быстрее, чем за n лог n, не получится.
На самом деле, есть по строению выпуклых оболочек,
которые работают быстрее, за линейное время и так далее,
отчислил. Их мы затроить не будем. Давайте рассмотрим некоторый общий алгоритм,
который достигает вот этой самой нижней границы. Вот этот алгоритм называется алгоритмом Грехома.
Работает он следующим образом. У меня есть какой-то конечный набор точек,
и я делаю следующую вещь. Как и в предыдущем алгоритме, я убираю точку с наименьшей
y-координатой. Эта точка гарантированно у меня будет входить в мою выпуклую оболочку.
А дальше я сделаю следующую интересную вещь. Я возьму и отсортирую все точки остальные по
величине угла относительно горизонтального луча, проведенного из вот этой точки панели.
Ну, то есть, сначала вот такая, так, так, так, так, ну и так далее. То есть 1, 2, 3, 4, 5, 6.
То есть первый шаг. Первый шаг, ну, выбираю по ноль как аргмин по y, среди всех точек p.
Дальше второй. Я сортирую по полярному углу относительно точки p0.
И теперь у меня есть набор тех же самых точек, но теперь он сортирован вот по этому
самому полярному углу. Окей? Окей, что я делаю дальше? А делаю я следующую вещь. Пусть c stack
хранящей текущие точки в выпуклой оболочке. То есть я сведу c, некоторый stack, который будет
хранить все точки, уже построенные в выпуклой оболочке. Окей? Ну, изначально, понятно дело,
что c у меня состоит из точек p0 и p1. Ну, почему p0? Понятно, мы ее выбрали изначально. Почему p1?
Потому что она обладает наименьшим полярным углом относительно горизонтали. Естественно,
эту точку тоже надо взять. Ну, как в алгоритме Джарвиса. То есть первые две точки, как взять,
я понимаю. А дальше происходят странные вещи. Дальше происходит следующая вещь.
На очередном шаге рассмотрим точку pi.
И попытаемся ее добавить. Я рассматриваю точку 2. Вот такую выпуклую оболочку я уже построил,
и теперь пытаюсь добавить точку 2. Ну, в каком случае мне ее добавить выгодно? В каком случае
я могу ее добавить? Ну, если она не портит мне выпуклость моего многоугольника, согласны? Ну,
в данном случае она пока ничего не портит. То есть у меня тут по критерию выпуклости все нормально.
То есть я заворачиваю в положительном направлении. Рассматриваю точку pi и... Что, почему? Нет, пока
вы смотрите точки 0, 1 и 2, с ними все нормально. То есть я их рассматриваю по порядку. То есть сначала
буду рассматривать точку 2, потом 3, потом 4, потом 5 и так далее. Вот пока я рассмотрел только точки 0,
1 и 2. Остальные меня пока не интересуют. Здесь все нормально. То есть если она ничего не портит,
то есть если у меня тут происходит поворот в положительном направлении, то все отлично. А что,
если у меня происходит такая картина? Хорошо, точку 2 я добавил. На следующем шаге я пытаюсь
добавить точку 3. То есть я очень хочу ее добавить. Ну, почему мне ее нужно добавить на этом шаге?
Потому что вот эта точка, она гарантирована пока вот этим множеством не покрывается. Потому что
она имеет наибольший полярный угол, наибольший среди всех этих первых четырех точек. Поэтому
ее я на данном шаге обязан взять. Но при этом я вижу, что у меня портится выпуклость. Кто виноват в этой
не выпуклости? Да, точка 2. И вот на этот случай есть специальный рецепт. Значит рассматриваю точку
и если вектора i-2, i-1, i, i-1. Так, тут плохо i-2 и i-1. Давайте к. Давайте вообще с.
Ск. Ск. Ск-1. Ну, c это точки из стека, окей? Ну вот у меня есть стек и в нем хранятся точки
p0, p1 и так далее, pk. Ну просто какие-то точки, которые уже составляют мою выпуклооболочку. Хотел c, написал p.
Вот, то есть я рассматриваю предыдущую точку и точку перед предыдущей. То есть я рассматриваю
последние два элемента стека. Вот. Если угол между этими векторами, то есть если вот эти вектора
образуют отрицательный поворот, то удаляю точку ck. Вот, это ровно то, что мы обсудили. Вот, смотрите,
у меня была изначально точка p0 и p1. Все, я их добавил в мой стек. Они составляют выпуклооболочку.
Ну, пока. Дальше рассматриваю точку 2. С точки 2 все хорошо. Она образует положительный поворот,
поэтому все окей. Дальше рассматриваю точку 3 и вижу, что тут уже образуется неположительный поворот.
То есть нарушается выпуклость. Значит, мне вот эту точку нужно удалить. Я ее удаляю и продолжаю дальше.
Сейчас, подождите. На очередном шаге рассматриваю точку pi и если образует отрицательный поворот,
то удаляю ck. Ну и, собственно, и так до тех пор. Пока. Ну, давайте вот это условие звездочку
обозначим. В общем, пока вот это верно, пока у меня образуется отрицательный поворот,
я в последовательность удаляю точку из стека. Окей? И только в самом конце добавляю точку pi.
Ну, давайте на таком примере, ну или давайте отдельно что-ли мы нарисуем, какой-нибудь пример.
Все видно хорошо. Ну, давайте как-то так. В общем, это первая точка, это вторая, третья,
четвертая, пятая, шестая, седьмая и восьмая. Значит, будем рисовать стек, что в нем сейчас
находится, и идти по порядку. То есть, изначально у меня, в моей выпуклой оболочке находятся точки
p0 и p1. Дальше я пытаюсь добавить точку p2. С точкой p2 у меня все хорошо, согласны? Все выпукло.
Стек добавляется с точкой p2. Дальше добавляю точку p3. А вот с p3 уже нехорошо. Вот тут появился другой
поворот отрицательный. Поэтому я удаляю точку p2 из стека и проверяю, действительно у меня точки,
угол между p0 и p1, и p1 и p3 образуют положительный поворот. Но тут, кажется, все нормально. Все нормально,
добавляю точку p3. Идем дальше. p4 могу добавить? Все нормально, поворот хороший. p5 могу добавить?
Поворот хороший. p6 могу добавить? Давайте более явно. Тоже все нормально. То есть, я спокойно
добавляю p4, p5 и p6. Добавляю p7. Беда. Все, тут все портится. То есть, вот этот вот угол портит
мне всю малину. Поэтому я удаляю точку p6 и рассматриваю вот такой угол. Снова все плохо, да? То есть,
снова тут угол отрицательный. Поэтому p5 я тоже удаляю. Я рассматриваю точку p4. Давайте снова
очевидно нарисуем, чтобы... вот так. Снова угол не совсем хороший, а точнее отрицательный. Поэтому
и p4 я тоже удаляю из рассмотрения. Все, остается точка p3. И с точкой p3 у меня все нормально. Согласны?
Все. Значит, цикл у меня там закончился, я добавляю точку p7. Дальше добавляю точку p8.
С p8 все нормально. Добавляю точку p0. Все нормально. 7, p8. Ну, p0 я не добавляю, просто я замечаю,
что я вернулся в ту же точку, откуда я начал. Все, и в итоге я понял, что у меня выбукла
блок стоит из точек p0, p1, p3, p7, p8. Вот они. В порядке перечисления. Окей? Вот такой алгоритм.
Пятый пункт. Повторяем пока... что повторяем? Повторяем 4. Повторяем четвертый пункт,
пока pi не равно 0. То есть, как только я вернулся в исходную точку, я завершаю работу. Точнее не так,
это неправильно. Повторяем до тех пор, пока не закончатся точки. Я же точки в порядке
взрастания перечисляю. То есть, как только у меня точки закончились, это значит,
что я все закончил. Не надо ничего проверять. Ну вот как-то так. Вопросы по алгоритму есть?
Что непонятно? Какой шаг? Давайте еще раз повторюсь. Первые два пункта очень простые.
Сначала выбираем минимальную точку p0. Дальше относительно этой точки горизонтали сортируем все
точки по полярному углу. Снова сам угол вычислять не нужно. То есть, все можно сделать с помощью
обычного векторного произведения. То есть, величину углов можно сравнить на основании
вот векторного произведения двух векторов. Зачем? Еще раз, векторное произведение у нас,
его проект снова из-за этого, это просто axby минус aybx. Нас же интересует только знак. Нас
интересует синус угла между ними. То есть, между ними положительный угол и отрицательный угол.
Все. Тут ни деления, ничего не нужно делать. То есть, единственное, что нам нужно знать...
Так вот, смотрите. Что вас интересует? Вас интересует угол b с горизонталью. Условно,
с горизонталью составляет больше угол или меньше угол? Вот если у вас угол, то есть,
если у вас от a до b, от a до b угол положительный, то значит b находится дальше. Если отрицательный,
то ближе. Вот и все. Ничего вопроса? Симптотика, супер. Давайте перейдем к симптотике. Тут все
просто. Ну, не все просто, ладно. Почти. Первый пункт, за сколько выполняется? Ну, за линию.
Ну, минимум найти за линию. Сортировка. Вот n, сортировка n log n. Вот. И это, собственно, самый долгий
шаг. Второй шаг, он самый долгий. Дальше все нормально. Там c stack. Тут вообще единица. То есть,
просто создаем stack и добавляем изначально две точки. Ну, самое сложное, наверное, здесь. В чем
могут быть сложности вот в этих двух пунктах? Ну, смотрите, что у меня происходит. С одной стороны,
я рассматриваю каждую точку только один раз, казалось бы. То есть, каждую точку я рассматриваю
только один раз, поэтому o от n. Согласны? Но при этом получается так, что я постепенно из моего
множества c какие-то точки удаляю. То есть, я некоторые точки рассматриваю по несколько раз.
Это правда. То есть, смотрите, что у меня происходит. То есть, я точку 4 рассматривал,
когда добавлял ее, и плюс точку 4 рассматривал, когда вот эти вот точки удалялись. Согласны? Да,
и на этом, на самом деле, все. То есть, может показаться, что каждую точку я могу рассмотреть
очень большое количество раз. На самом деле, нет. Каждую точку я могу рассмотреть только два раза.
Первый раз, когда я ее добавлял в стэк. Давайте это отдельно пропишем. Каждая точка
один раз добавляется в стэк и не более одного раза удаляется из него.
То есть, я на каждой точке совершаю, грубо говоря, не более двух действий. Ну,
понятное дело, что там есть еще какие-то действия, которые связаны с тем, что я вычисляю углы и так
далее. Но так или иначе, каждое мое действие приводит к тому, что я какую-то точку добавляю,
а какую-то точку удаляю. Согласны? Ну, все. Сколько всего добавлений точек?
Сколько всего раз я добавляю точки в стэк? Не более чем n. А сколько всего раз я удаляю
точки из стэка? Всего удалений. Не более чем n+. То есть, я не могу из стэка удалить больше точек,
чем я в него добавлял. Окей, давайте напишем равно n. Согласен. Да, каждую точку в любом случае
окажется хотя бы один раз в стэке. Да, согласен. Но самое главное, что всего удалений у меня будет
не больше, чем n+. Соответственно, не больше, чем n раз. Понятно? То есть, суммарная сложность
пунктов 4 и 5 от n. Ну или, можно иначе сказать, амортизированная сложность пункта A4 не
происходит от единицы. Согласны? Ну помнишь, что такое амортизированная сложность? То есть,
если я возьму суммарную сложность, то я просуммирую. То есть, понятно дело, что в каждый определенный
момент у меня сложность пункта A4 может быть большой. Вот как наберется вот этими точками? То есть,
я не могу сказать, что у меня в каждый момент пункт 4 выполняется за константное время. То есть,
теоретически он может выполняться и бесконечно, ну не бесконечно, а очень большое количество времени.
Ну например, вот если я так вот по спирали, ну не совсем так, но вот как-то вот так сделаю кучу
точек и вот тут отдельную точку. Понятно дело, что когда я буду рассматривать эту точку, мне придется
вот тут поудалять очень много всего. Но при этом суммарно, суммарно, гарантированно я не произведу
более чем 2n действий. Все. То есть, что у меня получается? O от n, O от n log n, тут O от единицы и
суммарно они более чем 2n, ну то есть O от n. Но естественно, вот эта штука самая долгая. Все,
поэтому алгоритм суммарно работает за n log n и это в принципе теоретически возможно минимум,
то есть на, ну в модели, когда мы можем использовать только арифметические действия, ну и всякие
сравнения. Да, да. Вот. Ну видимо, видимо еще один алгоритм не успеем рассказать, ну в общем-то
этого достаточно. Этого в задании будут только эти два алгоритма. Соответственно у вас есть
алгоритм Джарвиса, который работает за n h и у вас есть алгоритм Грехема, который работает за n
log n. Но опять же, нельзя сказать, что там, скажем Грехем строго лучше, чем Джарвис и Джарвис строго
лучше, чем Грехем. Да, потому что, ну в зависимости от соотношений между h и log n, у вас могут
получаться те или иные, в общем, те или иные артефакты, так скажем. Вот. Все зависит от
установки сдачи, там, насколько вы понимаете, там, насколько много точек у вас, может быть,
выпуклые оболочки или насколько, насколько мало. Ну, сегодня, видимо, все. Спасибо.
