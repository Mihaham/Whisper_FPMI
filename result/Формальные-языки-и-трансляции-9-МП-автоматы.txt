Всем доброго дня. Мы с вами сдали колокию. Подавляющее большинство из нас сдало колокию. Немного.
Вот. И сегодня мы с вами продолжаем наш курс. И так внезапно сложилось, что после колокию мы
начинаем сразу проходить новую тему. Вот. Эта тема автоматы с магазинной памятью. Они же
сокращаются как МП-автоматы. Сегодняшняя наша цель будет состоять в том, чтобы рассмотреть эту
конструкцию и понять, чему они эквалентны. Как вы думаете, чему они эквалентны? КС-громатикам, да.
Значит, а давайте вспомним, что вообще было до колоквиума. Да, алгоритмы Мерли. Собственно,
мы говорили очень сильно про КС-громатики, поговорили про алгоритмы распознавания КС-громатик.
Мы разобрали с вами два алгоритма. Кока, Янгер и Косами. И алгоритм Мерли. Вот. И сегодня, значит,
наша цель разобрать, существует ли какой-то аналог подобный автоматам. На самом деле такой аналог
существует. И это МП-автоматы. Если мы будем говорить неформально, давайте я сначала веду
неформальное определение, то что такое МП-автомат? Это автомат, у которого есть стэк в ходе исполнения.
Наша цель будет очистить стэк и принять какое-то слово. А теперь давайте чуть более формально
определим. Значит, сегодняшнее определение, с которым мы будем работать. МП-автомат.
Значит, это следующая конструкция. Это шестерка. У нас все больше элементов
в кортеже появляется. Уже практически столько же, сколько в машине тюринга. Да вроде столько же.
Так, значит... А, я забыл. Гамма. Вот. Шесть элементов. Ку, сигма, гамма, дельта, ку, ноль, эф.
Значит, давайте определим. Первое. Это множество состояний. Напомню, что все множества конечные.
Нет, не будет. У нас бесконечные языки. Значит, сигма-алфавит. И у нас появляется дополнительный
алфавит. Это гамма. Стэковый алфавит. Все эти множества конечные. Вот. Если мы говорим про формальное
определение, то сигма и гамма не пересекаются. Будьте здоровы. А дельта, смотрите, это будет
под множество ку на сигма со звездой на гамма со звездой, декартового перемножив на ку на гамма со звездой.
То есть, смотрите, мы каким-то образом с вами будем оперировать со стэковым алфавитом на входе,
да, и на выходе тоже каким-то образом будем оперировать с тэковым алфавитом. Так, ку-ноль
это стартовое состояние, f под множество ку это завершающее состояние. Вот такое определение. Напомню, все
множества являются конечными. А, да. Декартового произведения, конечно же. Да, который заменяет
оператор декартового произведения. Вот. В автомате появился стэк. Это, да, важно зафиксировать. И давайте
поймем, как рисуется в этом переходе автомати. Значит, изначально по факту будем считать, что стэк
пустой. Ну, потому что нечего делать. А дальше мы делаем следующее. Смотрите, важно понять абстракцию.
Если у нас есть переход из q1 в альфа в какой-то q2b, смотрите внимательно, это означает, что вот у
нас есть по ходу как исполнение какой-то стэк. И здесь написан строка альфа. Что мы имеем право
сделать? Мы имеем право пройти по этому переходу только в том случае, если на вершине стэка написано
альфа. Мы снимаем плату за то, что мы проходим по этому переходу и кладем все строки, строку бета
на стэк. Значит, во-первых, смотрите, при этом здесь у нас последовательность терминалов и не
терминалов. То есть, если у нас альфа равняется абс, то мы считаем, что сначала мы со стэка снимаем
c, потом b, потом a. Ой, извините, оговорочка по фрейду. Просто вот гамма это стэковая альфа,
элементы стэкового альфа это они будут каким-то смыслом напоминать не терминалы. Да. То есть,
несмотря на то, что мы пишем строку альфа равно абс, мы снимать будем их всегда в обратном порядке.
Ну, это просто чтобы нотация строковая была понятна.
Вершина, да.
Да, мы можем снимать последовательность символа со стэка.
Нет, как раз если у нас есть переход из q1 в w по abc, то это значит, что мы берем по факту
стэк как нашу строку и снимаем с нее суффикс.
Да, да, да. Ну, а по факту будет происходить следующее. Мы будем снимать c, потом b, потом a.
Да, да, да. Что бы по факту произошло. Снимаем со стэка a, кладем на стэк бета.
Вот. Это вот такой абстрактный смысл. Важно заканчивать будем с пустым стэком.
Да, этого можно не требовать. И это, на самом деле, одно из упражнений, которое можно доказать.
Опять же флэшбеки к последней задаче с колоквиума тут возникают.
Ну, типа что можно не требовать очистки стэка в определении mp автомата.
Вот. Но мы пока это не будем рассматривать.
Итак.
Не, не, не. Ну, похожая задача. По духу я имеется.
Вот смотрите, примером p автомата. Как они рисуются?
Значит, мы говорим следующее, что вот это вот все в терминах автомата будет перерисовываться таким образом.
Что из q1 q2 мы берем, считываем слово w на входе, со стэка снимаем альфа, на стэк кладем бета.
Это такое обозначение у нас будет.
Вот. Смотрите. Вот такой вот замечательный mp автомат.
Какой у него стэк алфавит, как вы думаете?
А большое, либо любое над множество а большого.
Вот. При этом в этом автомате распознаются слова baa и abba.
Давайте поймем, как распознается слово baa.
Да, смотрите. Мы идем по b.
У нас на стэке появляется две буквы a.
И потом мы снимаем по каждой букве a со стэка.
Получаем baa. Стэк пустой, пришли в завершающее состояние.
Ой, извините. abba.
Abba.
A. Перешли сюда.
Да, смотрите. Мы из q0 переходим в q1.
У нас здесь уже стэк пустой.
То есть ab, пустой стэк.
Дальше мы идем вниз по b, кладем букву a.
Потом мы снова снимаем.
Это примеры слов.
Зачем нам нужны примеры слов?
Для того, чтобы определить отношение воводимости.
Да, пом... А?
Ну да.
Собственно, знакомимся еще с одним термином, который нам сегодня понадобится.
Это определение конфигурации.
Это тройка.
q, u, gamma.
Где у нас q принадлежит q.
q принадлежит сигма со звездой.
Gamma принадлежит gamma со звездой.
И дальше определение 3.
Самое важное.
У нас у нас у нас у нас у нас у нас у нас у нас у нас у нас у нас у нас.
Дальше определение 3.
Самое важное.
Которое у нас есть.
Нам нужно определить наш любимый штопор.
Так, давайте поможем мне.
Ну, наименьшее рефлексивное-транзитивное отношение.
Не-не.
Рефлексивность означает следующее.
Что q, u, gamma всегда выводят вот эта рефлексивность.
Просто мы обычно будем писать, что это будет происходить за ноль шагов.
Ну, как обычно.
Мы это делали.
Да, да, да.
Ну, мы так же для автоматов определяли все.
Да.
Да, именно так.
Да.
Да.
Да.
Да.
Да.
Да.
Да.
А?
Не у, а гамма.
Это греческая буква.
Видимо, просто гамма.
Да, это символ гамма.
Так, давайте попробуем написать это все дело.
Имея вот этот смысл.
Значит, допустим, у нас есть переход q1.
Дубль в альфа.
А эти скобки буду рисовать.
Давайте подумаем, что мы можем сделать с вами.
Мы можем сказать с вами, что, пожалуйста, для любого слова...
Так.
Для любого слова u...
А, да, кстати, это неформальный смысл.
Сейчас давайте я его расскажу.
То есть идея следующая.
Идея следующая.
Что вот у нас есть такой переход.
Давайте вот так напишем.
Чтобы совпадание с презентацией было.
Для любого слова v и сигма со звездой.
И для любой буквы, которая называется это,
выполнено следующее.
Что из q1...
Так, смотрите.
q2...
это a.
Можно вывести q2...
v...
это b.
То есть конфигурация, на самом деле, что такое?
Это у нас то, что остается прочитать с входа.
То, что у нас на входе.
Это состояние стека.
Соответственно, что у нас происходит?
Для любого перехода.
Получается, мы считываем букву u со стека.
Просто из входа считываем букву u.
Снимаем со стека альфу.
Кладем на стек бету.
Логичное определение?
В смысле?
2.
У альфы в q2 бета.
Да.
Но вообще переход у нас из q1.
Из q1 в q2.
Просто это дополнительная опция.
Да.
Просто мы говорим, что при переходе с q1 в q2,
мы считаем с входа u,
снимаем со стека альфы,
кладем на стек бета.
То есть u, u, альфа и бета вы можете писать как угодно.
Главное, что переход из нового состояния в другое происходит.
Так, ну хорошо.
Давайте опять же,
если это определение понятно,
пройдемся вот по вот этой штуке.
А, еще одна вещь.
Нам нужно определить принадлежное слово языку.
Мы говорим, что язык, задаваемый mp-автоматом,
это множество всех слов.
Такое, что из q0
на входе,
прочитав слово epsilon,
мы на выходе получаем
q epsilon,
для некоторого q из f.
То есть мы можем пройти
от стартовой вершины до завершающей,
прочитав все слово целиком,
и на стеке у нас останется пустота.
Понятен ли этот слайд?
Нет, это конфигурация.
То есть вот это у нас остодоин наш.
Когда мы прочитаем слово,
у нас длина остодоина уменьшается.
Неформально в конфигурации?
Нет.
А что это значит?
Неформально в конфигурации
это помежуточное население
по чтению слова.
Да.
Стояние всей системы.
Мы тут по обратным ребрам идем.
Не-не-не, мы идем по прямым ребрам.
Мы просто говорим,
что не то, что мы накапливаем слово,
а мы его считываем.
То есть у нас считывается какой-то префикс,
и мы его обрубаем.
Наша цель дойти до того момента,
когда мы прочитали все слово.
То есть что нам осталось прочитать пустое слово.
Можно сказать, что мы в процессе чтения
после каждого шага
фотографируем все состояние системы,
потом штопором
соединяем D2,
если после первого
через какой-то шагов
возникает второе,
именно так.
Гениально.
Все-таки сегодня 31 октября,
поэтому можно.
Так, давайте пример.
Еще один раз, посмотрим,
как это формально выводится.
Вот как
выводит слово A, B, AA.
То есть у нас, короче, разница в том,
что в автоматах мы накапливали слово?
Да, в автоматах то же самое было.
Да.
А в автоматах мы слово накапливали?
Это если
давать ваше определение,
которое давали мы,
наоборот снимали его.
Да.
Да, какая разница глобально
накапливать или снимать?
Никак.
Ну, да.
Просто оказывается.
Вот, смотрите, выводим мы слово A, B, AA.
Состоит в том,
что мы берем, значит, снимаем
A со стека, переходим,
точнее, делаем переход
из Q0 в Q1 по A,
двигаемся сюда,
на стек кладем A.
Вот оно наше состояние, мы находимся в Q1,
нам осталось прочитать слово B, A
и буквы A на стеке.
Потом можно сделать следующее,
можно перейти в состояние Q2,
сняв букву A,
точнее,
еще один раз положив букву A
на стек, и дальше
два раза букву A снять со стека.
Получаем, что слово A, B, AA лежит
в языке, сдаваемом нашему АП-автомату.
Так, с этим определением OK?
Вот это пример
выводимости.
Хорошо, давайте доказывать
первое упрощение,
но вот есть
такой пример языка,
на семинаре вы рассмотрите, почему он является
АП-автоматом,
почему он задается АП-автоматом.
На самом деле, здесь такая же самая идея,
как у КС грамматик, только хитрее.
Вы можете...
Правда, если КС свободная,
то КС свободная,
то КС свободная.
Ну вот, да,
КС свободная.
Это мы не просто две грошей дыма.
Даже в одну?
А, да.
Вы не поверите, что количество N вы можете
кодировать длиной стека?
Это очевидно, да,
даже в одну.
Смотрите, вы можете сказать, что N
это длина стека.
Да.
И вы по факту...
Да, здесь можно две вершины.
Нет, в одну вершину?
А, ну можно, да.
Ну, то есть, смотрите,
по факту
мы можем сказать, что количество букв A
на стеке, это количество N.
А, да.
Это вариант другой будет.
Это будет PSP, кажется,
если его брать.
Если соединить это все в одну вершину,
это будет PSP.
Правильной скобочной последовательности.
Нет.
Да.
Да, а вот чтобы получить количество
букв A равняется количеству букв B,
тут нужно эмулировать вот такую вещь.
У вас есть по факту стек,
это что? Это ось неотрицательных
целых чисел.
Чтобы проэмулировать ось отрицательных
чисел, вам нужно еще одну букву
завести.
И вы говорите, что если у нас
N букв на стеке, то баланс плюс N,
а если N букв B на стеке, то
баланс минус N.
Вот, и дальше строится...
Ну да.
Ну можно и зачеряться вплоть до того,
что если количество будет условно
четное, то это положительное
или нечетное... Ну можно, можно.
Зачем упарываться?
В общем, тут
четыре перехода будут.
Я думаю, что это детали на семинарах
вы посмотрите.
Давайте доказывать
что-нибудь более конструктивное.
И первый факт,
который мы с вами будем доказывать,
он на самом деле очень простой.
Утверждение один.
Для любого mp-автомата
можно сказать, что для любого
q1
u
α
q2β
можно получить
следующее свойство.
Что длина u сверху
ограничена единичкой.
И смотрите, сумма длин альфа плюс бета
ограничена единицей.
Давайте подумаем,
как это можно сделать.
Да.
Могу написать вот так.
Какой есть идея доказательства?
Да.
Пихнем еще вершинок.
Давайте картинку нарисую.
Все очень просто.
Предполагаю, что у нас есть такой переход.
Сделаем так.
Обратите внимание, что
буквы аиты
переворачиваются.
Это про то, что я говорил.
Что в составе снимается верхняя вершина.
Еще раз.
У нас есть...
А?
Ага.
У нас был такой переход.
Мы из него делаем...
Там, где пропущено,
мы говорим, что просто
ε.
Буква алфавита.
Это стековые эти элементы.
А.
Да, кладем.
Да, да, да.
Все.
Есть такое...
Есть такие штуки. Пистолет называются.
Там, по факту, магазин
это кабура.
Да, конечно.
Магазин.
Вот это вот...
То, что вставляется в любое оружие,
это стек.
То есть там
пули вытаскиваются
в определенном порядке.
А?
Ну, да.
Так, контент 18+.
Это...
А?
Не забудьте
плашку поставить, пожалуйста.
А?
Ну, да.
Ладно.
Да.
Так, ладно. Шутки шутками.
Понятно доказательство, да, этого факта?
Так.
Усиление.
Да?
Нет-нет-нет.
Говорю, в остальных местах ε и ε возникают.
Так, следующее утверждение.
Я его сокращу так.
Вот так я его сокращу.
Если расшифровывать,
говорится, что существует mp-автомат
вот с такими требованиями
для любого mp-автомата.
Да, смотрите, там было не больше, чем один
в сумме, а здесь ровно один.
У не более одного остается.
Да.
Есть мысли, как доказать?
Во.
Давайте рассмотрим вот такой переход.
Да.
Да.
Цель такая, чтобы на каждом переходе
мы с вами либо снимали букву, либо клали букву на стэк.
Зачем эта стандартизация нужна?
Эта нужна для того, чтобы мы с вами
корректно доказали,
что для любого mp-автомата
существует кс язык.
Что для любого mp-автомата
можно построить любую кс-громатику.
Так, понятно.
Да, и мы не знаем,
как это сделать.
Так.
Да, и мы сейчас это прям начнем доказывать.
И более того, мы с вами заложим основу
одного из алгоримфных парсинга,
который является эффективным.
Этим доказательством.
Так.
Где?
B, M.
Нет.
А, да.
Да, это конъюнкция.
Да, это конъюнкция.
Вообще имеет, кажется.
Да.
Да.
Так.
Значит, смотрите, за оставшееся время
мы попробуем с вами доказать
следующее утверждение,
что кс-громатика и mp-автомата
эквалентны между собой.
Да.
Ну, сюрприз, сюрприз.
Собственно, цель
кс-громатики
и мп-автомата
эквалентны между собой.
Собственно, цель
давайте сформулирую это утверждение,
которое будет называться
mp-теоремой.
На любом
кс-громатике
G существует
mp-автомат.
m
l от m.
Это первый факт, который мы сегодня
с вами будем доказывать.
Идея,
смотрите, какая интересная.
Представим себе,
что у нас есть с вами
как раз громатика какая-нибудь.
Ну,
давайте мы сейчас
PSP рассмотрим
и рассмотрим утверждение
утверждения вида
ABB.
Напоминаю, что у нас
PSP задается вот такой
громатикой.
И давайте я еще
дополнительно закину
правила из h'
PSP.
Мы с вами говорили, что так можно делать.
Теперь смотрите,
как идет разбор слова.
А давайте мы сделаем следующую вещь.
Давайте построим
наш вывод.
Для этого напишем наше слово
и начнем его разбирать.
Давайте мы
с вами сейчас
будем на стеке
установить правила,
которые мы сейчас
по факту,
так сказать, крону нашего дерева
вывода на текущий момент.
Крону дерева.
Можно.
Просто здесь это еще будет иметь некоторый
терапевтический смысл.
Нет.
Смотрите,
суть будет в следующем,
что мы будем строить дерево снизу вверх.
Это называются восходящие парсеры.
Суть в чем?
Давайте я буду писать слово здесь.
Эпсилон.
Из него будет выводиться правило s.
На стеке будет появляться s.
Дальше, когда мы считаем слово,
у нас ABB.
Я напишу специально
большие пропуски, чтобы было видно,
что происходит.
Когда у нас встречается буква,
мы ее кладем на стек.
Дальше у нас встречается правило
Эпсилон. Мы наверх кладем s.
То есть нам нужно
сделать какой-то вывод.
Дальше, смотрите,
кладем на стек A
s, Эпсилон.
Я буду строить выводы.
А дальше, смотрите,
кладем на стек B
и чудеса.
Смотрите, что у нас находится на стеке.
У нас на стеке
с вами находится
SASB.
А что такое SASB?
S.
Это правая часть правила.
Поэтому мы разрешим с вами выполнять следующее свойство.
Что если у нас
на стеке находится правая часть правила,
то мы ее можем заменить на левую часть правила.
И в итоге
теперь у нас на стеке будет храниться SAS.
Дальше кладем
букву B
на стек
и
соединяем это все еще
в один символ.
S. Дальше на стеке
у нас остается только S.
И мы сейчас можем сказать, что у нас
и слово разобрано целиком.
Это хороший вопрос.
Вот это как раз сейчас
самая главная загадка дыры, так сказать.
И по факту мы несколько лекций
потратим на то, чтобы эту загадку дыры разгадать.
Сейчас, а S?
Это если у вас есть переход?
Да.
А в смысле? Ну да. Смотрите.
То есть мы можем пустое слово
по факту свернуть по правилу
S в эпсилон.
То есть нам здесь позволяет
в любой момент времени на стеке положить S.
Да. Чего?
В бане мы можем между
любым звенобудством вставить S в эпсилон.
Но это нам разрешает.
То есть мы из эпсилона как бы можем подняться вверх по S.
Возможно.
Да, да, да, конечно.
Смотрите, операция...
Давайте я немножко скажу более детально,
что операция, когда мы кладем
букву на стек,
называется shift.
А когда мы сворачиваемся
по правилу,
называется reduce.
Не, не, не. Вот видите, у нас было
следующее, что у нас был символ
афавита A, мы его положили на стек.
Просто читаем букву.
Да, да, да.
Не, не, мы последний. Мы как бы слово читаем
слева направо.
Да.
То есть мы можем либо свернуть правую часть
правила, которые у нас есть на стеке,
либо мы можем с вами прочитать
букву и положить эту букву на стек.
Reduce. Мы с вами
сворачиваемся по правилу S в эпсилон.
То есть когда у нас
правая часть правила заменяется
на левую часть правила, это...
Да, по другому правилу.
Вот эти правила
тоже могут быть для однозначности?
Конечно же, конечно, конечно же.
Тут столько неоднозначности.
То есть это тоже проблема?
Да, да, да.
Утверждение, утверждение
для неоднозначной грамматики это будет
это будет плохо.
Вот.
Нет, там даже полиномы не
получаются.
Так.
Так.
Давайте теперь формально нарисуем автомат.
Да, будет.
Надеюсь успеем.
Так, смотрите.
Теперь как выглядит этот автомат.
Собственно, если у нас с вами есть
правило
буква
то есть если мы
берем букву, то мы ее можем положить на стэк.
А если у нас
есть правило
то мы можем со стэка снять правую часть
правила и положить левую.
И последнее, это нам нужно
снять стартовый символ.
Да.
Гениальный автомат.
Да, да, да, да.
Да, да, да.
Да.
То есть идея такая, что правую часть правила
заменяем на левую, при этом ничего не считаем
со входа. Левая часть правила
ничего не считаем со входа.
Либо мы идем следующим образом, что
читаем букву со входа, снимаем епсилон
кладем ту же самую букву на стэк.
Вопрос, где здесь подвох?
Нет, почему не забыли?
Оно здесь.
Мы просто, смотрите, мы что делаем.
Если подставить s в епсилон,
то альфа это епсилон, кладем s.
То есть мы в любой момент просто на стэк s можем
положить.
Так.
А ну давайте пролистаем
к определению.
Да, как
на стэк сложить символ алфавита?
Да,
он говорит, что множество стэков
алфавита, множество символов
алфавита не пересекаются.
Да, отклонируем символ
алфавита такие же,
как в стэковом алфавите.
То есть делаем отдельную копию символов.
Ну, нет.
Типа, смотрите,
когда вы кладете образ
наговоря, смотрите,
здесь мы говорим а штрих везде.
То есть везде над символом будем добавлять
штрихи.
Да, да, да, да, да.
Да, да, да.
А штрих, б штрих, ну и так далее.
Что?
Это сделано
чисто для того, чтобы это все было
максимально похоже на кс-грамматике,
что мы вводим новый алфавит и он никаким образом
не пересекается вот с текущим.
Для амп-автоматов нет
критической разницы, для кс-грамматик
понятно, что это разница очень большая.
Да?
Нет, смотрите,
это если вы пытаетесь раскрыть
правила грамматики, а здесь идет в обратном
смысле, что мы дерево вывода собираем
снизу вверх.
То есть еще раз, смотрите, суть в чем,
когда мы собрали правую часть правила,
мы снимаем ее со стека
и кладем на стек левую часть правила.
Да.
Мы хотим в итоге прочитать
слово и получить с.
Но зато приводит нас к алгоритму
к определенному.
Раскрывать, да?
Есть такое, можете в качестве упражнения
попытаться сделать то же самое,
раскрыв левую часть правила
на правую. Так тоже можно.
Да, ну не, ну а здесь просто
это такая затравка перед будущими алгоритмами,
которые мы будем рассматривать.
Мы будем модернизировать...
Да, на самом деле мы будем с вами модернизировать
алгоритм, который будет потом за линию работать
для длины слова.
Вот, при помощи вот этой штуки.
Так, давайте докажем все-таки его.
Да, для некоторых грамматик мы за линию
для длины слова научимся разбирать
для некоторых грамматик.
Ну, для большого числа.
Да?
Нет, нет, нет, нет. Конкретно, что
мы снимаем правую часть, кладем в левую часть правила.
Вот картинка.
Снизу вверх, по выводу идем.
Что считываем со...
Нет, смотрите,
первое, это что мы снимаем со входа,
второе, это что мы снимаем со стека,
третье, что кладем на стек.
Нормально стало?
Это два действия.
Первое действие, это перенос,
то есть мы берем и переносим букву
на стек, считывая ее.
А второе свертка, мы берем правую часть правила
и сворачиваем ее в левую часть правила.
Вот, и при помощи такой штуки
за экспоненты вы сможете разобрать
принадлежные слова грамматики.
Да.
Теперь надо доказать, что этот автомат работает.
Да.
Да.
А если мы из mp-автомата научим строить
кс-грамматику, то из кс-грамматики мы потом сможем...
Да.
Да.
Итак,
давайте, вот они правила, формально
выписаны, и давайте
нам нужно доказывать следующее.
Первое, что из
a вводится слово w,
тогда и только тогда,
когда
мы можем вывести
ну, то есть, по факту, вот эту часть
перегнать вот сюда.
И второй факт следующий,
что для буквы это тоже самое
выполнено.
Ну,
ну, второй факт кажется очевидным.
Ну, из букв вывелось слово.
Это значит, что буква равняется этому слову.
Да, это
кажется сверхочевидный факт,
поскольку у нас есть
такой переход.
Давайте сотру все-таки букв, чтобы...
Где? Вот тут?
А, в грамматике.
Потому что мы хотим вращаться
именно в этом состоянии.
То есть, мы хотим вращаться
в этом состоянии и в какой-то момент
получить s.
Вот, утверждение, которое мы будем
доказывать, что это можно делать вот таким
образом.
Так.
Что, начнем доказывать этот факт?
Ну, тут две индукции.
Давайте сделаем так.
Хотим обе индукции или
интересную индукцию?
Интересную. Значит, интересная индукция
будет справа налево.
Индукция слева направо, индукция
по длине вывода.
База есть, переход проверяется.
Нет.
Хорошо.
Если останется время, проведем этот индукционный
переход. На самом деле,
здесь просто берется
последний переход, и он раскрывается.
В Slow Mo это
таким вот образом делается.
То есть, просто аккуратненько выводится.
Так, теперь в обратную сторону.
Значит, индукция по длине вывода
в mp-автомате.
Количество шагов,
в котором из вот
этой конфигурации мы можем получить
вот такую конфигурацию.
У нас, напоминая, что выводимость
это наименьшее рефлексивное, транзитивное
состояние. Оно порождается
переходами в нашем автомате.
Поэтому количество шагов,
за которых достигается
из одного конфигурации к другому,
можно вычислить, построив
транзитивное замыкание
над этими всеми состояниями.
База.
База очень простая.
Мы можем с вами
q0 w epsilon
за ноль шагов
вывести q0
epsilon alpha.
Что из выводимости в автомате
будет следовать выводимость грамматики?
Давайте тут посмотрим внимательно
на эти два варианта.
Здесь есть два возможных кейса.
Даже за один шаг.
Но если за ноль шагов смотреть,
то кажется...
Да, это неинтересно.
Да, все-таки мы хотим, чтобы
у нас в левой части правила
стояло хоть что-то, поэтому
напишу неинтересно.
Так, давайте за один шаг посмотрим,
что у нас происходит.
Итак,
за один шаг
за один шаг
здесь есть варианты.
Собственно, как этот один шаг был
достигнут?
Вариант один.
У нас с вами
было следующее, что
из A epsilon
из этого будет следовать, что
A
равняется альфа
и вводит наше слово W,
которое равняется A.
То есть мы сделали переход по правилу shift.
Второй вариант
это переход по правилу reduce.
Успользуемся вот этим правилом.
Значит, тогда
у нас получается, что
W это epsilon
и здесь у нас epsilon,
правая часть правила.
И мы получаем с вами
некоторое q0
epsilon A.
Но из этого следует,
что у нас есть правило A
epsilon.
Да,
да,
мы пришли по букве,
да, то есть мы сняли букву,
положили букву, поэтому из этой буквы
эта буква же и выводится.
А второй переход говорит, что
на самом деле у нас существует правило A
epsilon
в нашей грамматике.
Где? Здесь?
А потому что у нас один шаг есть,
только получить не терминал сейчас.
То есть да, да,
то есть
да, мы просто не успеваем, потому что у нас
просто один шаг.
Вот, ну и из этого следует, что
да,
вот epsilon, который в нашем случае
получается равным пустым словам.
Базы доказали.
Переход.
А вот переход это
самая интересная вещь, которая есть здесь.
Давайте попробуем проверить
интуицию и скажите, пожалуйста,
какой шаг нам
нужно будет с вами сейчас проверить.
Первый или последний?
Пока я стираю из доски и ищу
тряпку.
Хочется последний.
Смотрите.
Давайте посмотрим, каким образом
был получен вот этот шаг.
Ну, мы можем с вами сказать,
что этот шаг был получен вот таким вот образом.
У нас здесь на входе
было epsilon,
а здесь была последовательность символов
α1, αn.
Вот.
Вопрос.
Пока я там готовлю
себе другую доску, скажите,
пожалуйста,
что дальше делать?
Есть ли у вас какие-то мысли
по этому поводу?
Тут важно
ваше внимание,
что у вас есть
какие-то мысли по этому поводу.
Если у вас есть
какие-то мысли по этому поводу,
тут важно
задетектировать один момент,
который нам будет сильно помогать.
Давайте возьмем
первый момент,
когда появился символ
α1.
У нас символы с вами появляются
на стеке.
Значит, в какой-то момент
на стеке появился α1.
И больше там ничего не было.
Не-не-не. Именно в первый раз,
когда он совсем появился.
Смотрите, согласен.
Первый момент,
в котором дальше после этого
α1 не происходило
изменений.
Да.
Именно так.
То есть,
α1 появился на стеке
и зафиксировался
до того момента,
пока мы не сделали переход
по вот этому правилу.
Тогда смотрите,
первое появление,
берем его,
и дальше делаем следующее.
А давайте посмотрим,
что ему предшествовало.
Логично?
То есть, здесь у нас получилось так,
что Q0, ε, α1
у нас появилось на стеке.
Здесь мы говорим следующее.
За один шаг
у нас с вами
на самом деле здесь уже было
какое-то слово W1.
Которое потом трансформировалось
во все остальные правила.
Вот. И за один раз
давайте посмотрим на вот этот момент.
Хорошо.
Давайте уточнение сделаю
некоторое.
Смотрите,
тогда мы можем сказать,
что
Q0,
ε,
мы можем сказать,
что у нас появляется
вот такой вывод.
Я подчеркну, что здесь вот вывод,
именно стрелочка α1,
и тут был какой-то еще другой вывод до этого.
Теперь смотрите,
пользуемся тем,
что из эстадеина
у нас ничего не считывается.
То есть, на эстадеин мы больше ничего
положить не можем.
Ну, в плане, то что
если отсюда какая-то буква пропала
из этой конфигурации, больше мы ее не вернем.
А я имею в виду в то,
что вот это вот правило можно оставить.
Смотрите, я хочу сказать,
что мы можем с вами представить следующие
вот это слово следующим образом.
Что
вот это вот все
равняется некоторому
u1 на v1.
И из этого хочется сделать вывод,
что из q0
значит
u1
ε мы можем с вами
вывести q0
εα1.
Вот что
я имею в виду.
То есть, существует
наше разложение
вот таким вот образом.
Но тогда смотрите, что у нас получается.
Из этого делается вывод,
что из α1 выводится у1.
Вот это предположение нубца, которое мы с вами искали.
Дальше мы делаем следующее.
Повторяем аналогичные действия
для α2,
α3,
α
сколько там у нас было?
n
Получаем,
αит выводится уит,
и тогда
из а у нас за один шаг
αн
ун
а это как раз наш
слово w будет.
Так, я надеюсь, что я не слишком руками
помахал тут.
То есть, главная идея
фиксируем в первый момент, когда у нас появится
символ на стеке.
И дальше
из того, что у нас конфигурация
строится по транзитивному замыканию,
мы можем с вами взять
и убрать произвольный префикс из длины слова.
Который есть и там, и там.
Так, давайте вопросы.
А у нас и так, да.
Если последний переход shift,
это вот совсем база индукции,
которую мы проверили вот здесь.
Так, теперь давайте доведем
доказательства.
Смотрите, w принадлежит языку
задаваемой грамматики g.
Тогда и только тогда, когда из s выводится w.
Логично?
Теперь.
Это означает, что это эквалюта тому, что
из q0 w епсилон
выводит q0
епсилон s.
Вот как раз по факту, которую мы с вами доказали.
А теперь за один шаг
мы можем снять этот s
и получить
что
mp автомат.
Все, они факт доказали.
Ладно, это была простая часть доказательства.
Да.
В обратную сторону.
Так.
Идея понятна?
Хорошо.
Теперь давайте мы
сделаем следующую вещь.
Докажем
факт в обратную сторону.
Мы не доказали, как
pmp автомат устроит ks грамматику.
Мы доказали, что
любое ковыдное ковыдное ковыдное автоматом
будет...
Да.
Смотрите, мы доказали, что
по любой ковыдской грамматике у нас
можно построить mp автомат.
Да.
А теперь надо в обратную
сторону это все доказать.
Нет.
Не очевидно.
Это, кстати, основная идея, которую, возможно,
вам на семинарах уже рассказывали.
Вот.
Но я подчекну ее еще раз.
Идея. Смотрите.
Давайте возьмем как раз автомат,
у которого мы можем либо снимать
букву со стека обязательно,
либо класть букву на стек.
То есть рассмотрим mp автомат
где перехода
имеет следующий вид.
Сейчас будет взрыв башки.
Так. Давайте рассмотрим
момент,
в котором у нас появляется
взрыв башки.
В котором у нас появляется
буква на стеке. То есть у нас с вами есть
путь от стартовой вершины до завершающей,
в котором у нас
распознается некоторое слово w.
И при этом у нас есть
и появление буквы a на
стеке и в какой-то
момент эта буква a на стеке должна была
сняться.
То есть давайте рассмотрим
произвольный путь и стартовые
вершины в завершающей вершину.
Давайте рассмотрим, как
себя будет ввести стек в себя.
Значит, смотрите, если у нас
в какой-то момент добавился символ на
стек,
это значит, что в какой-то момент этот символ
со стека
снимется.
Да. И давайте
как раз построим эту картиночку
более детально.
Тарам.
Возможно, что на семинарах уже кто-то видел
такую картинку.
Рисовали картинку такую?
Это когда...
Да, да, да.
Это ровно та же самая картинка,
только мы ее построим в зависимости
длины стека от
времени переходов.
Смотрите, предположим, что у нас
в какой-то момент появилась буква А на стеке.
Дальше у нас
в какой-то момент буква А со стека была
снята.
Дальше смотрите, в какой-то момент
у нас здесь стек
не менялся. Ну, суммарно
стек не поменялся.
Согласны?
И давайте посмотрим
последний момент вот здесь, когда у нас
стек не менялся.
Это значит, что у нас был какой-то переход,
который снял еще одну букву со стека.
А теперь давайте затрекаем эти
состояния. Идея найти
пары состояний таким образом,
чтобы они... Переход
от этого состояния другого
не менялся стек.
Обозначим эту вершинку
куитом.
Это куэстый, это
кутетый, это куэртый,
а это кужитая.
Нет, не потеряли.
Сейчас я буду рисовать эту картинку,
потому что она мне понадобится.
Куит...
Вы не против, если я 1, q2, q3, q4, q5 обозначу?
Так, хорошо.
Так.
И давайте мы с вами сейчас сделаем
следующий... Построим следующую
кэс грамматику.
Множество
терминалов это будет декартовое
произведение состояния в нашем МП
автомате.
А алфавит будет
такой же.
Правило сейчас определим, а
стартовая вершина, это у нас будет
q0, qf.
Стартовая вершина и
пара стартового состояния и
завершающего состояния. Здесь нужно сказать,
что в МП автомате можно гарантировать следующее,
что в нем будет ровно одно завершающее состояние.
Идея ровно такая же.
Сводим все в сток.
Теперь перехода.
Не сломайтесь, пожалуйста.
Это просто баг.
Так.
Итак, значит, смотрите.
Давайте предположим, что
мы сюда положили слово u.
Итак, смотрите, переходы
какие будут.
Ох, блин.
Мы говорим следующее.
Что q1, q5
будет выводить
u
q2, q3
v
q4, q5
Мы добавляем такой правил грамматики.
Да, пара декартового
произведения состояния в
МП автомате.
Да, это те символы,
которые считались, когда мы
положили символ a на стэк.
А это те символы, которые считались,
когда мы эту a с стэка сняли.
Взрыв башки, да?
Нет, для всех.
То есть мы просто перебираем
все пятерки состояний.
Да, для всех пятерок состояний,
у которых возникает
следующее, что у нас есть
правило вида q1
u epsilon
a
и правило
вводим вот такое правило.
Это в.
Ну, давайте поменяем символ.
Вот, добавим все такие правила.
И дополнительные правила
у нас есть.
И еще к ним добавим правила.
И добавим все возможные правила
такого, что из любой пары
одинаковых символов мы можем породить пустое слово.
Мощно, да?
Так.
Что?
Где, где, где, что?
Овальчики?
А вот овальчики мы здесь пропустим.
Вот они, овальчики.
То есть это пара состояний,
которая будет говорить, что из нее будет
проводиться произвольное слово.
Да, просто стэк меняться не будет.
Вы готовы дальше?
А, да, я еще
забыл, что
А, ну да,
то есть смотрите, мы можем сказать, что либо
старт у нас вот такой, и тогда
у нас требуется одно завершающее состояние.
Либо мы из старта делаем
переходы в пару.
Да, если у нас одно завершающее,
то можно оставить вот так, как у нас
на доске.
Да.
То есть еще раз, либо мы делаем одно завершающее,
либо мы
говорим следующее, что
давайте из стартового проведем
переходы во все пары.
Стартовое завершающее.
Давайте так оставим.
Подчеркну.
Теперь главное, лемма.
Которая на самом деле нам
поможет очень сильно.
Лемма.
Вы даже ее сможете сформулировать самостоятельно.
Не-не-не, не настолько.
Смотрите.
Тогда это только так, да?
Да.
Ну да.
Это нормально.
Да, у нас в картинке это не учитывается
в правилах грамматики.
Ну да.
Это не нам да.
У нас, смотрите, просто если
это завершающее состояние, то это просто
ку-ноль-ку-эв сразу.
Ну и все, у нас получается ку-ноль-ку-эв
вот это вот байдо.
Ну то есть нам не нужно будет
минус-б делать. То есть минус-б
это просто мы фиксируем последний момент, когда
уровень стека является точно таким же.
Здесь это чисто визуально для картинки
показано, что дальше у нас
уровень стека меняется.
Ну и с ку-ноль-ку-эв мы смотрим первый символ,
в котором мы будем
делать подъем по А,
дальше смотрим последний момент, в котором
мы снимаем эту буква, и дальше просто ползем
до конца.
Да?
Все, смотрите, вот это лемма,
которую мы будем с вами доказывать.
Собственно, опять же,
слева на право тут индукционный переход.
А?
Ну давайте быстро докажем это.
База.
База.
За один шаг выводит слово
W. Какое слово W тогда?
Ура, получили!
Переход.
На, на, на.
На, на, на.
На, на, на.
На, на.
На, на, на.
На, на, на.
А как мы с правил грамматики можем вывести еще что-то?
Переход.
Ну, собственно, последний переход, который у нас
произошел, это вот по такому правилу.
У, Т, З, В.
Ну, тогда смотрите, как у нас строится цепочка вывода.
Из Q1 у Т, З, В мы кладем, с вами у нас было вот такое правило.
В Q2 у Т, З, В на стэк кладется буква А.
По предположению индукции у нас стэк не меняется.
Из Q2 в Q3.
Тогда мы говорим, что из Q3 у нас остается А.
Дальше за один шаг, который у нас является правилом, вот таким вот, мы снимаем букву А со стэка.
И еще за один шаг.
Ой, наоборот, букву А со стэка сняли, получили эпсилон.
И из Q4 к Q5 у нас стэк не меняется.
Q5, эпсилон, эпсилон.
Это переход в одну сторону.
Переход в другую сторону.
Честные и внимательные слушатели могут сказать, что это может не доказывать.
Почему?
Вы смотрите, предположим, что у нас Q1 в эпсилон выводит Q2 эпсилон на эпсилон.
Опять же, индукция по длине правил вывода.
База.
За ноль шагов мы выводим пару Q2 эпсилон на эпсилон.
Ну а тогда смотрите, что мы выводим из пары Q1-Q2.
Мы выводим слово эпсилон, равное нашему слову W.
Вот это правило грамматики.
Переход.
Тут я замолчал.
Какой переход?
Это переход.
Картинка. Еще раз поясняем картинку.
Смотрите, у нас с вами из Q1 W эпсилон идет переход в состояние Q2 эпсилон-эпсилон.
Поскольку у нас все переходы имеют вид, когда мы кладем букву со стека или снимаем букву со стека, то какой первый переход у нас будет с вами здесь?
Тогда у нас, смотрите, Q1 W эпсилон, это будет за один шаг мы перейдем в какое-то состояние Q3, в котором наше слово будет уже разбито каким-то образом другим.
W3, назовем эту всю штуку, а здесь будет символ A.
Логично?
Дальше за какое-то количество шагов мы перейдем с вами в состояние Q4, в котором уже будет слово W4, и эта буква до сих пор будет висеть.
То есть это последний момент, когда мы увидели букву A на стеке.
Потом мы за один переход снимаем эту букву A со стека.
И потом за какое-то еще количество переходов мы получаем Q2 эпсилон-эпсилон.
Ну смотрите, да, из Q3 по Q4 мы переходим по предположению, из Q5 в Q2 мы переходим по предположению.
Единственное, тут надо сказать следующее, что W тогда это будет у нас с вами некоторое U3 W3.
Значит, это будет U3 U4 W4, это будет U3 U4 U5 W5.
По предположению индукции у нас с вами получается, что из W3 W4, Q3 Q4 у нас выводит слово U4,
и из Q5 в Q2 мы выводим слово W5.
Стек не меняется.
А теперь смотрите, какое у нас правило грамматика-то есть.
Мы кладем букву A на стек, мы можем с вами за один шаг перейти.
Смотрите, кладем U3, поскольку букву A на стек кладем.
Дальше мы переходим в переход Q3 Q4.
Дальше мы снимаем то, что мы сняли со стека букву, мы делаем переход по U5,
и делаем переход Q5 Q2.
Это переобозначение терминов, которые здесь.
То есть у нас появляется такое правило, потому что мы строили грамматику таким образом.
Теперь смотрите, отсюда мы выводим U4, а отсюда мы выводим W5.
Сошлось.
И осталось последнее.
Если мы говорим с вами,
В пролежит языку, задаваемым грамматикой, тогда и только тогда,
когда есть пара Q0 QF, мы выводим слово W.
А это эквалент тому, что из Q0 W епсилон мы выводим QF епсилон епсилон.
А это эквалент тому, что слово принадлежит нашему МП-автомату.
То есть две важных идеи, которые у нас сегодня произошло.
Первое, что можно сделать? Если мы положили какую-то букву на стэк,
то можно посмотреть первый момент, когда мы ее убрали.
Раз.
А вторых, что если у нас какой-то не терминал появился в правилах,
если какой-то символ появился на терминале, мы выводим Q0 QQ
он появился на стеке. Давайте посмотрим первый момент, когда он появился на стеке.
Это две основных идеи, при помощи которых доказываются эти факты.
То есть я не прошу формально запоминать доказательства, а запомнить вот эти два факта.
Это две идеи, которые были важны здесь.
Так, давайте вопроса. Это на самом деле то, что я планировал как раз сегодня рассказать.
Тут есть более формальное доказательство.
Это то же самое. А я уже ее скинул вчера вечером. Мы тоже.
В каком моменте мы закончим доказательство?
А, вот той? Вот.
Да, именно так.
Это я невнимательно подчеркнул. То есть вот эта лемма, которую мы с вами доказали.
Что из кодинку 2 вводится в W тогда и только тогда, когда это работает.
Здесь мы закончили доказательство этой леммы.
И дальше здесь мы уже доказали теорему в одну строчку.
Так, а теперь фишка состоит в следующем.
Тут есть примеры. И тут видите, какой страшный МП-автомат выходит.
Вот, смотрите, мы сегодня показали, что МП-автоматы и КС-громатики являются эквалютными конструкциями.
Более того, следствие которое мы выяснили, что любого МП-автомата можно построить МП-автомат с двумя состояниями.
Вот, и самое важное еще, что можно сказать, что мы с вами построили алгоритм перенос свертка.
С которым мы с вами еще будем разбираться, когда мы будем рассматривать LR-парсер.
Давайте анонс на следующую серию.
Следующая серия будет следующая. Мы с вами построим еще одну нормальную форму для грамматик.
Вот, и некоторые отсылки были с ней.
Дальше мы разберем задачу еще одну из колоквиума, благодаря этому.
Вот, докажем, что КС-пересечь с регулярным языком, это КС-язык.
Но сделаем это достаточно элегантно.
Вот, и построим МП-автомат, в котором не будет эпсилум переходов.
Нет, там будет чисто однобуквенные по букве, пока мы этого не гарантировали.
Пока у нас все переходы не более чем однобуквенные.
Все, спасибо, вопросы? Слушаю.
