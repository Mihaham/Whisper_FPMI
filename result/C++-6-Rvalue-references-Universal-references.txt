Значит, я быстренько напомню, что мы делали. Я определял, что такое lvalue и rvalue формально.
Значит, что такое lvalue и что такое rvalue? Значит, имя переменной это lvalue, литерал это rvalue.
Дальше там бинарные всякие операторы. Плюс, минус, умножить и так далее. Это lvalue.
Тьфу, наоборот. Бинарные плюс равно, минус равно, умножить равно и так далее. Это lvalue.
А плюс, минус, умножить, разделить и так далее. Это rvalue. Дальше унарная звездочка и возможно
что-то еще. Это lvalue, амперсант, тильда и прочее. Это rvalue. Потом у нас был префиксный
инкремент. Это lvalue, постфиксный инкремент. Это rvalue. Дальше, кажется, я говорил про тернарный
оператор. Ну, я не буду уж дальше все это делать. Тернарный оператор там когда-то lvalue,
когда-то rvalue. И последний пункт, точнее последние два пункта, самое для нас важное. Это вызов функции,
если возвращаемое значение, значит, с возвращаемым значением t амперсант,
а здесь вызов функции, у которого возвращаемое значение t или t двойной амперсант, где t не
при тип. Бессылочный. То есть, если мы возвращаем тип с одним амперсантом, то результат вызов этой
функции lvalue. Если возвращаем с двумя, то rvalue или без амперсантов. И cast expression с возвращаемым
типом t амперсант. То же самое. Это lvalue, в то время как cast expression к t или t двойному амперсанту,
это rvalue. И вот тут начинает проявляться понимание того, что такое t с двойным амперсантом.
То есть, по сути, t с двойным амперсантом это такая ссылка, которая в общем-то как обычная ссылка,
но если ее вернуть из функции или из cast expression, то это будет считаться rvalue, а не lvalue.
Вот в чем, по сути, смысл. Пока это, конечно, еще все не отвечает на очень многие вопросы,
но что-то начинает проясняться. Если вспомнить реализацию sdmove, которую мы писали в прошлый раз,
то там мы вспоминаем, что было написано static cast к... что-то там с двумя амперсантами,
это как раз получается rvalue. И возвращаемый тип с двумя амперсантами, это получается rvalue.
Поэтому, когда мы вызываем sdmove, мы всегда получаем rvalue. То есть, результат вызывая sdmove
это rvalue, при этом вот это тот самый объект, от которого был sdmove. То есть, по сути,
sdmove это rvalue... это можно было бы сказать... можно было бы назвать rvalue cast. sdmove
это просто cast rvalue. Был какой-то объект. Давайте трактовать его как rvalue теперь. Вот и все.
Ну, есть еще несколько пунктов, которые я не перечислил. Давайте, наверное, сейчас я открою,
поскольку у меня теперь есть интернет и импровизированный проектор досках. Я могу открыть
страницу с формальным описанием всего этого. Сейчас на нее посмотрим. То есть, я таблицу нарисовал
для такого основного перечтения. Вот, давайте посмотрим на то, что такое lvalue формально. Ну вот,
еще я не упомянул результат вызова оператора точки. Если a само было lvalue, то a. что-то это
тоже lvalue. Если мы к полю обращаемся, и стрелочка то же самое, и точка со звездочкой, и стрелочка со
звездочкой. Вот если у меня a это lvalue, то результат такого это тоже будет lvalue. Вот, но тут по некоторым
техническим причинам довольно, значит, ну есть некоторый странный пункт. Например, стринг
литерала это lvalue считается. Не любой литерал считается lvalue, а rvalue, а стринг литерал считается
lvalue. Но это такие технические тонкости, где-то костыли про которые я не хочу говорить. Вот, ну и
есть понятие rvalue, которое определяет себе два понятия на самом деле. prvalue и xvalue. Вот, и тут
перечислено, что это такое. Я сейчас не хочу говорить даже о том, что такое xvalue, чем он
отличается от prvalue. Давайте просто пока сойдемся на том, что это все называется rvalue, и для понимания
муксимантики на самом деле этого будет достаточно. А про то, что такое xvalue мы тоже поговорим, конечно,
но через, ну чуть попозже, когда поем основное. Ну вот, ну а теперь самое время поговорить о том,
что такое все-таки вот эти rvalue ссылки. Ну то есть, вот это вот было формальное
определение lvalue, rvalue. А теперь давайте поговорим о том, что такое rvalue references. Ну я назову
следующий пункт. Собственно, это будет параграф 10.6, кажется. Значит, rvalue references. Так, что у меня
какие-то вещественные числа получились вместо обычного r. rvalue references и их свойства.
Теперь, когда я определил все это, можно объяснить, что такое rvalue ссылка на самом деле. Ну, во-первых,
это ссылка. То есть, все свойства, присущие ссылкам, что касается того, что она неотвечима от объекта,
вот это вот все, что присваивание ей, это присваивание объекту, это все остается вверх. То есть,
это ссылка. Главная разница в том, что, во-первых, инициализировать эту ссылку можно лишь через rvalue,
а второе, это что возвращая эту ссылку из функции вы получаете rvalue. Сейчас поясню. Вот, допустим,
у меня есть какой-то... Наверное, тут я лучше код открою. У меня есть какой-то, ну скажем,
int обычный. Вот давайте на примере кода посмотрим, как работают rvalue ссылки. Вот есть у меня int.
Я могу сказать int&r равно x, и это обычная ссылка. Могу сказать const int&r равно x или r, без разницы.
Это будет константная ссылка. Вот такие ссылки отныне мы будем называть lvalue ссылками. Ну,
просто ссылки, они же lvalue ссылки. Что такое rvalue ссылка? rvalue ссылка int двойной амперсант rr может
быть инициализирована только посредством rvalue. То есть, если я напишу и вот так,
это будет CE. Давайте я продемонстрирую. Вот, cannot bind rvalue regions of type lvalue of type int.
Заметьте, lvalue of type int. lvalue это не часть type int, а выражение lvalue. Хорошо. Я напоминаю,
что lvalue ссылки нельзя инициализировать посредством rvalue, а rvalue ссылки наоборот.
Дальше. Могу ли я... ну, окей, хорошо. Ну, тогда, наверное, я могу написать вот так. Вот так я бы не
мог написать, как вы, я надеюсь, помните. А вот так могу. Потому что справа lvalue. В этом идее
lvalue ссылки. Инициализируется она с помощью lvalue тока. А что надо сделать, если я хочу сделать
lvalue ссылку на x? lvalue cast. Правильно, нужно сделать sdmove. Чтобы инициализировать lvalue ссылку
существующим объектам, нужно, чтобы выражение справа стало lvalue. Но lvalue to lvalue cast,
он так не явно не происходит, его явно надо делать. Вот. То есть, с помощью функции sdmove,
я явно говорю, в этом есть некоторая аналогия между константами и неконстантами. Грубо говоря,
lvalue это такая штука, которая, ну, lvalue это такая штука, которая, скажем так, не все позволяет над
собой делать. Ну, условно. Какая-то аналогия прослеживается. В чем смысл move? Это значит,
мы сейчас отдадим этот объект куда-то, чтобы его испортить. Ну, грубо говоря, да. И если мы
хотим lvalue ссылку у него создать, обычно это означает, что мы собираемся сейчас его как-то
дальше пропихнуть, чтобы из него забрали содержимое. Но вот просто lvalue ссылку
пронициализировать объектами так нельзя. Нужно явно написать, что я cast делаю к lvalue.
Вопрос на понимание. Вот я сейчас напишу им двойной имперсант, не знаю, rr, равно rr.
Вроде да. Нет, потому что rr это же lvalue. Отлично. Правильно. Значит, господин Садович, молодец.
Вот господин Евтеев сделал ошибку, которую я предрекал в прошлый раз. Я говорил вам,
что вы еще ошибетесь. Нельзя, конечно. Так нельзя, потому что справа lvalue. Понятно?
Значит, не важно какой тип, важно какой вид value. Когда вы имеете дело с rvalue ссылкой, то,
что у нее тип rvalue ссылка, не означает, что объект теперь под ней. Вообще объект не бывает rvalue
или lvalue, но имя переменной всегда lvalue. Всегда, когда вы функцию передали, значит, что-то по rvalue
ссылке, там оно уже снова lvalue стало. Если вы хотите его дальше move-нуть, то надо опять явно
написать move. Это будет опять rvalue cast. Давайте с конс теперь разберемся. Как это все работает
вместе с const? Ну, независимо. const – это вещь, которая продолжает работать, как и раньше,
независимо от всего того, что я сказал. Артагональные вещи. Ну, то есть, по-прежнему
можно навешивать const на это все. Но это довольно бессмысленно. Я не знаю практически полезных
примеров, где нужно было бы использовать const rvalue ссылку. Но скорее это такие уроцы,
искусственно созданные типы, но довольно бесполезные. const lvalue ссылка отличается
от обычной lvalue ссылки тем, что ее можно инициализировать через rvalue. Я тут пишу 5,
что является rvalue, но мог бы написать и вот так, например. То есть, константная ссылка, а в отличие
от обычной ссылки, мы это обсуждали в первом семестве, обладает тем свойством, что ее можно
инициализировать посредством rvalue. Не посредством константы, а посредством rvalue, вот что важно. То
есть, литерала или, например, результат sdmove. А вот эту вот нельзя посредством lvalue, как я уже
говорил. Что такое const rvalue ссылка? Ну, все точно так же, как если бы мы const висели на обычную
ссылку. В одну сторону можно, в обратную нельзя. Ну, то есть, я могу сделать sdmove от rr и
проинициализировать таким образом const rvalue ссылку. Если потом у меня опять будет rvalue ссылка,
rr равно sdmove от crr, то так уже нельзя, потому что с видом value на этот раз все хорошо,
но константность нарушена. Значит, binding, reference of type, bla-bla-bla, discards, qualifiers,
знакомые слова вам уже, я думаю. Вот. Ну, зато вот так можно. Константность не нарушена.
Итак, в чем поняли? Мы поняли, что у нас теперь есть такой особенный вид ссылок, который
обладает всеми теми же свойствами, что и обычными ссылки, но есть два важных ключевых отличия. Вот
самая главная суть. Их инициализировать можно только посредством rvalue, а еще возвращение их из
функций это rvalue, а не lvalue. Это приводит нас к тому, что мы теперь способны делать перегрузку по
виду value. Вдумайтесь, вот эти правила, вот в точности они позволяют нам делать перегрузку по виду
value. То есть иногда мы можем, если мы ничего явно не будем писать, все будет работать как раньше,
никакого move, никаких rvalue ссылок, но если мы, в обратную сторону, как бы неявные касты работают,
то есть я могу конст, инт, амперсант проинициализировать результатом move. Это
будет работать как и раньше. Если у меня нету версии для двойного амперсанда, то каст в сторону
конст, инт, амперсанда не явно сделается, а двойного амперсанда конст, инт, амперсанду сделается,
а в обратную сторону не сделается без явного каста. Но не просто он не сделается, а еще и вид
value должен совпасть. То есть чтобы мне попасть в версию, которая принимает инт двойного амперсанда,
но не инт двойного амперсанда, а т двойного амперсанда, произвольный т, мне мало чтобы
передаваемый аргумент был с типом двойного амперсанда, мне надо чтобы еще вид value был у него
правильнее. Ну поэтому у меня и работает перегрузка. Вот если у меня есть вектор,
а давайте-ка я наверное вот здесь вот снова открою вектор. Вот у нас был вектор, в очередной
раз я открываю вектор, и тут есть pushback. Вот теперь я могу, значит, этот pushback скопировать,
и это в pushback будет отличаться от того pushback'а, по сути, только вот этим. Ну я, конечно,
нехорошо сделал кипя пасту, но сейчас простительно. Теперь у меня есть два pushback'а, в частности,
вектор. Один принимает т двойного амперсанда, другой примет код с т амперсанда. И если я в pushback
передаю rvalue, то вот это становится предпочтительной вещью. Если же я в pushback передаю lvalue,
в частности, пусть даже я передаю туда rvalue ссылку, но передаю ее какими-то переменной. Вот эта
версия отпадает, потому что она, ну потому что не подходит эта версия. Нельзя принцелизировать это
посредством того, что я дал. Значит, выбирается эта версия. Если же у меня не было бы вот этой
версии вообще, то в любом случае выбиралась бы эта версия по-прежнему, потому что в эту сторону
каст нормально работает. Ну вот сейчас, по сути, я, можно сказать, озвучил всю часть про move.
Это еще не все. Сейчас у нас еще остались не закрытые некоторые гестальты. Но про то,
как работает move, про то, как работает выбор вот этих вот версий, и что такое rvalue ссылка,
вот сейчас должно стать понятно. Ну, если забыть про то, что у нас там в move была принималась
т двойная персанда, мы не понимали, что это означает в том контексте. Забудьте про ту
проблему, и просто как будто вы о ней не слышали. И вот тогда все должно быть понятно. Вот есть ли
вопросы про эту часть. Когда, за счет чего мы теперь решили проблемы с разными версиями pushback,
как работает move. Они точно появятся, когда мы начнем мапу писать, но пока все вроде кажется,
что все понятно. Окей, хорошо. Еще раз, вкратце, главные мифы. Разоблачение мифов. Главное,
что нужно помнить. Во-первых, std move сама по себе как функция ничего не делает с объектом. Она
вообще не генерирует процессорных инструкций. Это просто каст для компилятора, говорящий о том,
какую версию перегрузки выбрать надо. Если вы просто вызовете std move от чего-то,
точка запятой, и ничему не присвоите результат, ничего с объектом не произойдет. Это вообще
проигнорируется. Второй миф. rvalue и lvalue это свойство выражений, а не объектов. Не имеет
смысла спросить данный объект rvalue или lvalue. Имеет смысл спросить синтоксические данные выражения.
И выбор происходит между этими версиями именно по виду value, в первую очередь.
Ну и третье, в частности, rvalue ссылка, это не такая ссылка, что вот она rvalue является. Это такая
ссылка, что инициализировать ее можно посредством только rvalue. И возвращая ее из функции вы получаете
rvalue выражение. Вот в чем суть rvalue ссылки, а не в том, что она якобы сама rvalue. Вообще
нет смысла спрашивать, она является чем. Это свойство выражения еще, повторяю, а не объектов.
У нас осталась еще одна проблема. А, прежде чем говорить про еще одну проблему, я вот что скажу.
Вот сейчас... Илья, можно вопрос? Да, конечно. Ты сказал, что если вернуть rvalue ссылку из
функции, то получится rvalue. Да. Это потому что то, что получится при возвращении с функции, зависит
не от типа выражения, а уже от типа данных, которые мы возвращаем. Нет, если... Сейчас, вот это вот...
Вот тут вот я перечислял, что является rvalue. И тут написано, что если выражение представляет
себя функциональный вызов, в котором возвращаемый тип что-то с двойным имперсантом, то такой
функциональный вызов это rvalue выражение. Это место, где что-то зависит от типа, с которым мы работаем. Да, это
правда. Это правда. Ну, не совсем корректно говорить, что это чисто синтоксическое свойство, но это в
большей степени синтоксическое свойство. То есть компилятор смотрит в определение функции и решает
в зависимости от возвращаемого типа, что это будет зависеть от этого. Окей. Ну да, это правда. Это вот то
самое место, где оно зависит от типа. Так вот, сейчас я хочу еще поговорить про ссылочные
квалификаторы. Вектор я закрою. Открою снова вот это. Вот смотрите, у меня есть какой-нибудь класс...
Ой, какой void. Ну, многие из вас уже знают про это. Ну, давайте теперь мы аккуратненько уже с новыми
знаниями проговорим. Значит, мы научились сейчас, по сути, делать выбор версии функций по виду
value принимаемого значения. Ну, по аналогии с тем, как у нас бывали раньше конст-квалификаторы,
можно было бы захотеть сделать и ссылочные квалификаторы. Что такое конст-квалификаторы?
Вот у меня есть void f, не знаю, которая выводит 1, а есть void f const, которая выводит 2. И что это такое?
Это перегрузка по константности самого того объекта, которого мы вызываем. Это ни у кого вопросов
уже не должно вызывать. Но я могу организовать перегрузку, начиная с плюс плюс одиннадцать,
и по виду value моего объекта. Не по виду value принимаемого объекта, как я научился это делать,
а по виду value самого того объекта, от которого я вызываюсь. Ну, как бы, подкол засчитан, но понятно,
что я имел в виду, имел в виду, что вот если я пишу что-то типа x, вот что-то, точка f,
вот в зависимости от вида value того, что тут, я хочу, чтобы вызывалась либо одна f, либо другая.
Ну, вид value не самого объекта, а как бы того, той ипостасии, в которую он перед нами предстал,
когда мы вызывали f. Вот он может быть, он мог быть подан нам как lvalue в некотором выражении,
ну, как rvalue. Вот в зависимости от этого разные версии f вызвать можно. Например,
давайте я заведу такую my struct s и напишу s.f. Вот так я хочу, чтобы вызвался один. А если бы я
написал, скажем, plus у меня нет, я мог написать std move от s.f, должно вывестись 2. Ну, или если бы
я просто написал my struct .f, тоже должно вывестись 2. Потому что вот это rvalue. Это подпадает под
пункт вызов функции возвращаемый тип, который без ссылок. Ну, это вызов конструктора, как бы.
То есть вызов user defined метода, у которого возвращаемый тип, это t без всяких ссылок.
Значит, это rvalue. Так, вопрос в чате. Правда ли, что если какая-то моя функция будет типа t,
то никогда не станет хуже, если я вместо этого напишу return std move от result? Неправда. Иногда
станет хуже и про это мы скоро поговорим. А именно станет хуже в случае, когда там была rvo. Про
это мы поговорим. Мы успеем сегодня поговорить про это. Stay tuned, мы дойдем до этого. Так вот,
как это делается, ну вы наверно уже знаете, многие из вас, делается это так. Я могу написать
ссылочный квалификатор там на том же месте, где обычно я ставлю конструктор. Вот. Вот такой
квалификатор означает, что эта функция пригодна только для lvalue левого аргумента. То есть до
точки lvalue должно стоять. А это значит только для lvalue левого аргумента. Если нет вообще ссылочного
квалификатора, это значит функция пригодна для чего угодно. Скомпилируем. Ну вот получилось,
как я говорил, 1, 2, 2. Вот. Если бы у меня была вот такая функция и такая функция, то это было бы ce,
кажется. Сейчас проверим. Да. То есть я либо определяю одну для обоих видов value, либо я
определяю только одну для какого-то вида value, а для второго тогда он будет запрещено. Либо я
определяю две для раз. Ну вот, короче, делать такую перегрузку нельзя. Но можно сделать перегрузку вот
такую. Зачем это может быть надо? Ну, например, у вас объект хранит себе какой-то большой блок
данных. И вы собираетесь написать функцию, которая этот блок данных вам возвращает. Вот представившим
функцию возвращает там, не знаю, ну, str, скажем. А в полях тут есть собственно str. Вот. Тогда
здесь я мог бы, скажем, сказать return str, а тут я мог бы сказать return std move от str. Самое главное,
я вам формально все это рассказываю, но мы совсем забыли об идее, зачем move надо. Move надо,
когда мы собираемся. Ну, вот это то, что обычно говорят. Все лекции по move семантике обычно
начинаются со слов. Иногда мы хотим сказать, как бы что объект скоро будет уничтожен, нам больше не
нужен. Вот это скоро будет уничтожено, нам больше не нужно. Мне очень не нравится, потому что непонятно
совершенно формально, что это значит. Но надо понимать это как просто мотивацию к всему тому,
что я здесь рассказал. Когда мы используем std move? Когда мы понимаем, что этот объект больше,
содержимый этого объекта больше не нужен. Он скоро уничтожится все равно или будет замещен чем-то
другим. Поэтому если мы имеем дело с объектом, с rvalue, как бы ссылкой на объект, как сказать,
вот я говорю с rvalue объектом, чтобы упростить слова с синтаксическим выражением, которое
представляет нам объект этот как rvalue. Вот rvalue объект это сокращение, чтобы не говорить вот этого.
Вот если мы имеем дело вот с таким, то мы можем отдать просто string через move. Во второй реализации
не стинговый написан должен быть. Нет. Зачем? Вот сейчас идея в том, что давайте я скажу,
что у меня поле публичное, я вот так вот сделаю. Вот смотрите, вот я утверждаю, что сейчас вот в
этой ситуации я получу строку копированием той строки из полей, а в этой ситуации я получу строку
губанием. То есть вот здесь вот никакой лишней копии не случится. И еще в структуре s больше будет
строки, верно? Да, и после этой строки кода в структуре s будет пустая строка лежать.
Так, вот посмотрите на эту строчку и поймите, почему в этой строке кода не произойдет ни
одного копирования. Это не совсем очевидно. Ну тут понятно, тут произойдет копирование.
А тут почему не произойдет ни одного копирования? Понимаете?
Значит, вот здесь я попадаю в эту версию из-за того, что у меня std move перегрузка
выбирает вот эту версию. Я говорю return std move от str. Вот это std string инициализируется выражением
std move от str, а значит называется move constructor, а не copy constructor. Значит, вот это str становится
пустой и все содержимое string переходит, это str переходит в эту string. А потом вот это string
инициализируется результатом вызова вот этого. То есть мы вызываем конструктор просто от rvalue?
Но это тоже rvalue. Поэтому тоже move constructor будет выбран, если вообще будет. Ну тут на
самом деле копия лежим произойдет, но я пока еще не рассказывал, что это такое. Ну даже вот на
уровне наших текущих знаний понятно, что не будет ни одного копирования. Потому что вот здесь
будет выбран move constructor, потому что от stmove мы конструируемся, вот здесь вот когда написано str2
равно что-то, будет выбран move constructor, потому что с правой rvalue написано. И move constructor по
правилу он предпочтительнее будет выбран. То есть в худшем случае, если даже компилятор ничего не
сооптимизирует, здесь просто будет два move, но ни одного копирования. Почему нет? А почему нет?
Почему что? Почему ничто? Типа почему бы так не написать? Или что? Значит, ну я объяснил, почему
вот здесь вот возвращаем значение str2 это ок, копирования не будет. Я так полагаю вопрос,
почему бы не написать вот так, чем будет хуже? На самом деле будет хуже. А именно как раз, ну давайте
я этот вопрос положу в стэк, и вот мы короче, в очередь вот так, мы на него ответим, когда чуть
попозже. Но если так написать, то не будет оптимизации, потому что при такой записи компилятор вообще не
будет вызывать, произведет copy elision так называемый, второго конструктора вообще не будет вызвано. А вот
при таком компилятор менее вероятно сооптимизирует, и ему придется второй раз move constructor вызывать.
А, минуточку. Сейчас, я неправильно сказал. Виноват, тут все еще хуже. Давайте вот подумаем,
действительно, что будет, если вот так написать?
У нас же как бы просто ссылка возвращается. У нас ссылка на объект, который только что уничтожен?
Ну он не уничтожен, но вот тут мы получили R-value ссылку на str, тут мы получили R-value ссылку на вот тот
самый str. То есть, короче говоря, F дает нам R-value ссылку на вот тот самый str. И мы получили str2 как str. Нет, ну кажется,
что нормально. Кажется, что будет работать, да. Ну кажется, будет работать, да. Ну то есть, UB вроде не
будет. А это правда, это правильное замечание. Вот если бы, вот это правильное замечание. Вот поэтому
и безопаснее писать str без амперсантов. Вот если бы мы не поле возвращали, а создавали бы какую-то строку str,
местный str, который какой-то результатом обработки того str является, и его бы возвращали, то вот тогда это
было бы проблемой. Ну то есть, вот я, допустим, написал std string new str равно std move от str, а потом еще написал
вот так. Вот тогда это было бы UB, потому что, понятно почему, потому что это была бы сбитая ссылка. А при такой
реализации не было бы. Ну то есть, я неправильно сказал вам, что там будет один лишний конструктор,
забудьте. Но кажется, что без амперсантов писать просто безопаснее. Значит, вопрос. Если бы s был
const, мой страх, мы бы получили ce или дополнительное копирование? Давайте и на этот вопрос ответим. Так,
я верну, как было, значит, я верну без амперсантов. Так, хорошо. Если бы s был const,
мой страх, если бы s был const, мой страх, то я думаю, что дополнительное копирование, ну,
по тому же самому принципу, по которому и... Сейчас, нет, так не могу сходу ответить. Ну,
давайте подумаем. std move дает нам rvalue. То есть, у нас есть, по сути, const, мой страх, двойной амперсант.
И нужно либо выбрать версию, которая просто мой страх, двойной амперсант,
либо версию, которая одинарный амперсант. Нет, это будет ce. Это должен быть ce,
давайте проверим. Так, я не сохранил, кажется. Да, это ce. Смотрите, почему ce, потому что эту
версию, ну, у нас теперь this имеет тип const, мой страх, двойной амперсант. Эту версию мы не можем
выбрать, потому что const нарушается, а эту версию мы не можем выбрать, потому что rvalue нарушается.
А если бы у нас не было первого... Почему? Потому что нельзя перегружать так, чтобы у одной не было,
было ноль ссылок у второй две ссылки. Ну, так бы можно было выбрать первую. Ах, нет, нельзя.
Нет, так бы можно было выбрать первую, но перегружать так нельзя. Нет, вот этот одиночный амперсант
за что только lvalue сюда можно отдавать. Вот эта фраза Discalce Qualifiers, она теперь применима не
только к константности, а еще и к амперсантности, так скажем. Вот, тут константность нарушается,
а тут игнорируется квалификатор вот этот вот. Давайте пойдем дальше, потому что еще, на самом деле,
достаточно много надо обсудить. Следующий пункт будет называться Проблема Perfect Formatting.
Мы обсудили move и более-менее поняли, как работают рвелые ссылки. У нас осталась важная проблема.
Следующая. Смотрите. Представьте, что у меня есть. Ну, давайте начнем вот с чего. Давайте даже
не отсюда начнем, а опять вернемся в вектор. Вот в векторе такой метод есть emplaceback. Следующий
пункт будет называться, это пункт 10.7, он будет называться Perfect Forwarding Problem.
В векторе есть такой метод emplaceback. Что делает emplaceback? Он принимает аргументы конструктора t
и избегает создания промежуточного t. Ну, например, если у меня есть, ну я не знаю, вот представьте,
что у меня вектор векторов. Сейчас как бы мне это организовать. Давайте я применю. Вот представьте,
что у меня есть вектор векторов. std vector от std vector v, ну там от int. И я хочу вектор векторов
положить вектор, скажем, из 10 int. Я могу написать v.emplaceback 10. Что это будет означать? Понимаете,
это я, значит, говорю, положи в вектор такой объект, который бы получился, если ты вызвал
конструктор внутреннего типа с параметром 10. То есть после этого в моем векторе будет лежать
один вектор с десятью нулями. Эта функция, она тоже, начиная с c++11 появилась, и появилась она для того,
чтобы избегать создания промежуточного объекта, когда вы что-то в вектор кладёте. Ну не только в
вектор, в любой контейнер. Она точно так же есть. В map можно написать map.emplace вместо insert.
Значит, понятна разница? Вместо того, чтобы передавать объект типа t, я передаю параметры
конструктора для объекта типа t. Я могу написать так v.emplaceback 10.1. Это будет означать, что у меня
будет вектор, в нем первый вектор то 10 нулей, а второй вектор то 10 единиц. Вот эти параметры,
они передаются в тот самый конструктор. Ну да. Вот. Значит, понятно разница между pushback и
emplaceback. Вот. Ну и с помощью emplaceback можно было бы на самом деле избегать копирований как
раз в той ситуации, с которой мы начинали. Вот. Когда я говорил там, что значит. Ну вот. Вот если бы я так
написал и сделал pushback вместо emplaceback, то было бы лишнее копирования. Ну, в старом смысле лишний
вызов конструктора t. Потому что pushback принимает t, ему нужно было бы сконструировать t вот от этого,
а потом другое t от того t, который он сконструировал. Emplaceback позволяет избежать этой проблемы путем того,
что в самом placeback вы принимаете лишь параметры конструктора для t, но не t готовы еще. И t
конструируется один раз, а не два раза. Вот. Но возникает новая проблема. А проблема вот как.
Вот я перейду сейчас сюда и задам вам вопрос. А как реализовать emplaceback? Emplaceback. Что должно
быть типами принимаемых параметров? Какой-нибудь арк с двойным персантом. Вот. Я не могу написать так деле.
Потому что. А вдруг они не константные там? Ну, точнее нет. Не в этом дело. Не потому, что вдруг они не
константные там. Вдруг не передали rvalue? То есть я мог бы так написать. Я мог бы так написать. И я мог бы на самом деле
вот здесь сказать, бла-бла-бла-бла-бла, new arccz t от arcs. Многоточие. И pushback на самом деле просто выражается
через emplaceback в одну строчку. Это просто emplaceback от value. А это emplaceback это stmove от value.
Но вот здесь, если я так напишу, у меня будет опять проблема с лишними копированиями. Откуда берется
проблема с лишними копированиями? Потому что я все аргументы принял в константной ссылке. А вдруг они были rvalue?
Некоторые из них, по крайней мере. То есть смотрите, у меня есть параметры, которые могут быть как lvalue,
так и rvalue. И я хочу обработать их правильно в любом случае. В случае pushback у меня просто есть
перегрузка. В одном случае я точно сдал объект как lvalue, и я его не буду мувать. В другом случае я не
имею права мувать просто. Это не было бы CE, но не имею права. А здесь у меня много аргументов,
и часть из них может быть lvalue, а часть rvalue. Я не могу написать просто перегрузку для const.arq с
ampersand, а потом перегрузку для args с двойным ampersand в старом смысле. Потому что аргументов
много. Если я напишу вот так, это будет неэффективно, потому что я все их скопирую. Но все мувнуть я тоже
не могу. Что же делать? То есть если я вот так напишу и напишу здесь the move от args, то это вообще
очень плохо, потому что я тем самым мувнул все аргументы, в том числе те, которые возможно мувнуть
было нельзя. Что же делать? Это как раз называется проблема perfect forwarding, проблема идеальной
передачи. Когда у меня есть много аргументов, да и даже не обязательно много аргументов, пусть даже это
один аргумент, но он может быть как rvalue, так и lvalue. И мне надо передать его дальше в следующую
функцию с сохранением вида value, с которой мне его дали изначально. Почему const.arq повлечет лишнее
копирования? Потому что я вызываю конструктор T от параметров, каждый из которых const что-то там
амперсант. А если бы у меня эти параметры были переданы мне как rvalue, то я мог бы вызвать move
конструктор T. Ну банальный пример, если я сделал in place back от string, от другого вектора, я его здесь
принял как const вектор амперсант и передал конструктор того нового вектора от const вектор
амперсант и вызвал конструктор копирования, а мне его дали изначально через move. Я move его должен был,
а не должен, а не стал. Я мог бы move, а не стал. Это лишнее копирования аргументов. Так, понятно ли
проблема? Кто-нибудь скажите. Да, понятно. Верно, что к каст двойного амперсанта,
если бы мы сняли in place back от args двойного амперсанта и дайща, то все бы спокойно попадало туда.
Да, но из того, что я сказал до этого, это еще не следует. Это следующее, что я как раз
собираюсь сказать. Так, окей, если никто больше ничего не говорит и не спрашивает,
то я считаю, что проблема понятна. Сейчас я буду объяснить, как решать проблему.
Что я должен принять в первую очередь? Вот мне надо, чтобы я мог принимать как R-value,
так и L-value. Если я буду принимать con start с амперсант, то все, я уже ничего с
этим не сделаю. Лишние копирования потом будут. А если я буду принимать вот так,
то я как будто бы принимаю R-value ссылку и получается, что я могу как будто только R-value принимать.
В общем, нет и ввели костыль. Сейчас будет очень странный костыль, который прям в
стандарте зафиксирован, но не я это придумал. Возможно, если бы я это придумывал, скорее всего
мы бы не придумали ничего лучше. В общем, комитет не придумал ничего лучше, как вести следующий
ужасный костыль. Если у вас ARX это шаблонный аргумент функции, то ARX с двойным амперсантом
имеет не тот же смысл, как если бы он не был шаблонным аргументом.
Когда ARX любой шаблонный или когда он именно несколько содержит в себе?
Когда он любой шаблонный аргумент. Вот если у меня ARX, который принимает им двойной амперсант X,
то сюда можно передавать только R-value. Но если у меня функция с шаблонным параметром T,
которая принимает вот такую вещь, то сюда можно передавать как L-value, так и R-value.
Это костыль. Что будет? А что именно будет, вот раз можно принимать, что это значит?
Пока я не сказал, что будет, сейчас вот такое правило. Если у вас это является шаблонным
аргументом функции, то такую ссылку можно интеллизировать как посредством R-value,
так и посредством R-value. Такие ссылки называются универсальные ссылки. По-русски они называются
универсальные ссылки или еще они называются forwarding references. Надо понимать, что это не официальный
термин стандарта. Это просто такой синтоксический, ну такой костыль. Но на жаргоне, можно так сказать,
между собой это называется forwarding reference, универсальная ссылка. Вот это конкретно ссылка.
Она не R-value ссылка, потому что ее не только посредством R-value можно интеллизировать,
она просто с шаблонным параметром T. Вот из-за того, что тут шаблонный параметр T, ее можно
интеллизировать как R-value, так и R-value, поэтому она универсальна. Вот эта вот ссылка.
Теперь рецепт, как решить проблему. Я принимаю ARC с двойной амперсант. Это универсальная ссылка,
и по вот этому костыльному правилу сюда можно передать как R-value, так и R-value. И вот здесь мне
нужно что-то написать. Просто ARC передать я не могу, потому что это будет L-value, значит опять скопируется.
SDMove от ARC передать я не могу, потому что я move-ну что-то лишнее. Это будет даже хуже,
чем если бы я скопировал. Это я нарушу, я испорчу пользовательские объекты. Мне
нужна другая специальная волшебная функция для такой ситуации, которая называется SDForward.
Она вызывается шаблонным параметром T. Возможно, тут немножко усложняет дело наличие этого
переменного количества аргументов. То есть я говорю бла-бла-бла, ну я что-то делаю в этой функции,
а потом вызываю другую функцию, скажем, h от stdforward от t от x. Вот этот вот stdforward это такая
волшебная функция, которая следующим хитрым образом работает. Она возвращает R-value,
если изначально тот x я принял как R-value, и возвращает L-value в противном случае.
Вот эта конструкция приводит к тому, что для тех и только тех ARCs, которые были даны мне как L-value,
результат вызова SDForward даст L-value. Ну L-value ссылку, а поэтому L-value. А для тех ARCs,
которые были изначально даны мне как R-value, результат вызова SDForward даст мне R-value ссылку,
то есть R-value. И поэтому в конструктор T я отдам те и только те аргументы по R-value ссылки,
которые мне изначально пришли в эту функцию как R-value. И на самом деле вот этот pushback я тоже
могу выразить через emplaceback. И я могу сказать, вот здесь вот просто я делаю emplaceback stdmove от
value. В этом случае emplaceback скопирует, а в этом случае emplaceback movenet, потому что SDForward умеет
вот здесь как раз можно. Ну вот я избавился от copypasta заодно и разобрал emplaceback,
еще так реализован emplaceback, но тут правда конечно Allocator, ну вы все понимаете.
Вот теперь вам должно быть понятно, почему мы в Move принимали T2 и November Sound.
Я напомню, как выглядит реализация stdmove.
Как выглядит реализация stdmove? Мы принимали туда вот такой тип.
Возвращали мы вот такой странный тип, а принимали мы T2&. Теперь вы понимаете,
почему T2&&? Потому что в Move мы должны уметь принимать как R-value, так и L-value. И вот по
этому костыльному правилу, которое введено специально, чтобы такую ситуацию победить,
T, поскольку шаблонный параметр нашей функции, он является и любой вид value подойдет сюда.
А еще теперь вы должны понять следующее, что вот например, давайте посмотрим сюда.
Так, опять потерял.
Ладно, давайте зайдем в вектор.
Ну вот если мы посмотрим на Allocator.
Господи, где Allocator стандартный?
И посмотрим на функцию Construct в Allocator, то здесь, как вы видите, написано тоже
ARC с двойным амперсаном. Я все это время опускал эту деталь и писал код Stark с амперсантом.
Ну вот этот вот Placement new, который я вызываю с std forward, он на самом деле в Allocator спрятан.
То есть на самом деле я же вызываю не Placement new явно из вектора, я вызываю Allocator trades
Construct опять-таки от std forward от ARCs. И в Allocator уже вызывается Placement new и опять написано
std forward там. То есть вот здесь вот должно быть написано new от вот этого вот std forward.
Ровно по этой причине. Потому что Construct должен мовнуть те и только те
аргументы, которые были приняты как R-value.
Так, теперь вам должно быть понятно
почему вот эти двойные... что такое универсальная ссылка? Как и когда использовать std forward?
И почему в Allocator и в emplaceback именно такие ссылки и std forward написаны?
И следующая вещь, которую надо понять, а как это работает? Опять мы поняли,
мы закрыли Gestalt про то, почему было t2n% в муве, поняли что emplaceback,
поняли почему двойные ссылки в Construct и поняли как пользоваться std forward,
в каких ситуациях. Но мы теперь не понимаем, и это последнее что нам осталось понять,
а как это работает? Вот когда мы это поймем, мы, можно сказать, до конца поймем,
ну почти до конца поймем мув-семантику и останемся только про RVO и copy&paste поговорить.
Плохо слышно очень, я не понимаю. Ты спросил про шаблонный аргумент что-то,
только с шаблонным аргументом работает универсальная ссылка?
Нет, я вообще нет. Повторить, что мы, по твоему, еще не знаем, что мы еще не придумали.
А, мы не понимаем, да, как это работает, как std forward работает, как это цель достигается. Мы
все поняли, кроме того, как вот эта часть работает. Как часть с t2n% работает мы уже
понимаем, как часть с std forward работает. Вот, окей. А, ну еще мы не понимаем, что такое
xvalue. Ну, в общем, еще пару вещей потом останется. Окей, мы поняли проблему,
поняли решение, теперь как это работает. Значит, параграф 10.8 будет называться std forward
implementation и, значит, свойства универсальных ссылок. Ну, я не буду писать это, давайте назовем
просто std forward implementation. Прежде чем написать реализацию std forward, нам надо понять вообще,
а как работает вот этот вот костыль с двойным персандом в параметрах. Вопрос, который у меня
возникает следующий, ну и у вас он, наверное, должен возникать. А какой тип имеет выражение,
вот здесь вот, x, когда мы его сюда передали. То есть, вот я сюда передал x по универсальной
ссылке. Какой вот здесь вот будет тип x? Вот тип этого выражения, какой? Не with value,
with value это lvalue, понятно. А тип какой? То есть, сколько реально персандов будет у x? x это будет
lvalue. Это должно работать как-то так, чтобы когда мы передали lvalue, x оказался с двумя
персандами тут. А когда мы передали lvalue, надо, чтобы какой-то магией x оказался одним
персандом. Тогда std forward бы по этому принципу сумел различать, когда сделать move, когда не
сделать move. Вот здесь вот std forward, он понимает в итоге вернуть rvalue или lvalue, как раз в
зависимости от того, а сколько амперсандов было у x, который в него пришел. И нужно как-то так
правило ввести приемы по универсальным ссылкам, чтобы когда мы передали lvalue, x получил в итоге
1 амперсант. А когда мы передали rvalue, x получил бы в итоге 2 амперсанта. Можно вопрос? Да. Мы как-то,
кажется, обсуждали, что если у нас t, ну если у нас был тип, у которого был 1 амперсант,
если на него сверху навесим еще 2 амперсанта, то получится 1 амперсант все равно. Да. А нет такого,
что тогда, когда мы, как раз универсальный ссылка, у нас по сути получаются разные t. То есть,
если x, ну если мы вызвали lvalue, у нас t было бы тип с 1 амперсантом, а если rvalue, то без амперсантов,
по сути. Гениально. Все так. Именно так это и работает. Давайте задумываемся о том, а что вообще такое
t здесь? Когда мы вызываем какую-то шаблонную функцию с параметром t, во что превращается t? Вот в
нормальной ситуации, если я вызываю какую-то функцию с шаблонным параметром t, ну без пока, вот пока мы
не знаем ничего о двойных амперсантах. Вот, допустим, я вызову эту функцию от x, int x равно 1, f от x.
Чему становится равен t? t становится равен int. И амперсант навешивается поверх t. Правильно так работает
шаблонный вывод, вывод шаблонного параметра. t, он без амперсанта, оказывается. Другой вопрос,
если я напишу int % r равно x, чему будет равно t? Вот смотрите, вот давайте такой эксперимент
проведем. Вот если я сейчас вызову f от r, чему будет равно t? Ну давайте я просто проверю,
вот я же могу написать std isSame v t, запятая int % Да, понятно, что я сделал. Давайте вектор,
наверное, я закрою, мне это уже сейчас не пригодится. Так, я оставлю вот это. Вот смотрите,
я взял x, взял lvalue ссылку на x и вызвался от нее. И спрашиваю t, чему равно? Это равно int %?
Вообще t это lvalue reference, я могу спросить t это isLvalueReference.
Что? Не понял, а где вывод? А, потому что я забыл type traits подключить, сейчас подключу.
Type traits. Да что такое это? А, потому что c++17 не поставил. Ноль. t это не int % t это int.
Вот смотрите, когда я передаю, когда я вызываю f от ссылки от int % type r это int % в шаблонном
выводе t всроснуться int, а не int % И int значит сверху. То есть вот в этой функции t означает int,
а не int %. То же самое, если бы здесь было const t % Ой, если я напису const t %
t это было бы просто int, а const и int % повесились бы сверху на него.
Но все меняется, когда здесь два анперсанда. И это как раз особенное правило для универсальных
ссылок. И это тот самый костыль, благодаря которому работает sdfoward. Если я здесь вызываю,
если я принимаю здесь t с двумя анперсантами, то есть если это универсальная ссылка, то внезапно
оказывается, что t это ни с того ни с сего int % Смотрите еще раз, следите за руками. Сейчас
может у кого-то крышу снести. Что я сделал? Я принял в f t двойной анперсант, где t шаблон
f. Это универсальная ссылка. И я спросил, правда ли, что t равно, давайте, наверное, вот так вот
сделаю. Вот я просто вот скажу, чему равно t? Это int, int с двумя анперсантами или int с одним
анперсантами. И сейчас я внезапно обнаруживаю, что t это int с одним анперсантами.
Ну нет, это даже выглядит визуально логично, как бы там два анперсанда мы передали с одним
анперсанда, в одне один остался и все такое. Хорошо, что если я от x вызовусь, а не от r?
Чему теперь будет равно t? Только не говорите, что int. Там всегда будет один анперсант, если мы
вызвали с этого value. Правильно. И более анперсантов иначе. Да, все так. Значит, это правило работает
независимо от типа того, от чего я вызвался, а в зависимости от вида value от того, от чего я вызвался.
Правило вот этот костыль звучит следующим образом. Если функция приводит вниверсальную ссылку,
то шаблонный вывод t работает не так, как обычно, а вот как. Если в вызове f в данной
ситуации было lvalue выражение, то на t навешится анперсант лишний. А иначе ничего не навешивается.
Поэтому если я вызовусь от x, то у меня все равно будет t равно int анперсант, несмотря на то,
что x без анперсантов был вообще. А вот если я вызовусь от rvalue, ну, например, от одного,
то t будет без анперсантов. Это будет просто int. И если я вызовусь от std move от x, теперь я вызываюсь
от int с двумя анперсантами. Тип выражения std move от x это int 2 анперсанта. Но важен не
тип, а вид value. Вид value это rvalue. А раз rvalue, то никаких анперсантов t не получает. Сейчас опять
будет просто int. Вот такая вот странная шаблонная магия. А поэтому можно уже понять, как forward
работает, исходя из этого правила. Как работает forward? В forward мы не случайно перейдем вот
этот шаблонный параметр t. Он важен. Без него forward не скомпилируется. Нужно явно указать t.
И вот этот t как раз и позволяет forward понять. Мы сейчас от lvalue или от rvalue. Потому что когда
мы от rvalue были, вот это t будет без анперсантов. А когда от lvalue, оно будет с один анперсантом.
Поэтому давайте просто сейчас напишу реализацию forward. template type name t. А давайте подумаем.
Значит forward. А это просто forward. Такой слабенький forward. Это какой-то слабенький forward. В смысле слабенький
forward можно вызывать от пакета самого. Нет, минуточку. forward вызывается от одного аргумента,
а не от пакета. Многоточие оно ставится вот здесь, а не тут. Я рассказывал, что многоточие означает
повторить все это через запятую. То выражение, после которого оно стоит. Поэтому на самом деле это
выглядит как stforward от первого, а это stforward от второго, stforward от третьего. Все это через запятую.
Для каждого из них по отдельности называется stforward. И они либо превращаются в rvalue ссылкой,
либо в lvalue ссылкой, смотря какое t. Ну давайте подумаем. Какой должен быть возвращаемый тип,
какой принимаемый тип. Не подглядывайте себе. Переференс. Давайте. Какой? Принимаемый,
универсальная ссылка, понятное дело. Универсальная ссылка, говорите вы. Ну, допустим. А возвращаемый?
Тоже универсальная ссылка? Нет, вы достойно. Даже хуже. А, стоп, можно удалить все ссылки,
еще что-то навесить. Возвращаемым типом должен быть либо, значит, либо... Ремофф референс с 2 амперсантом,
либо ремофф референс с 1 амперсантом. Что-то такое. Нам нужно как-то перегрузку сделать,
в зависимости от t. Нам, видимо, нужно template type name t и template type name t амперсант. Это как
такого штука, чтобы различать t у нас. Проблема вот в чем. Если вы будете принимать forward t с
2 амперсантом, то опять будет правило с универсальными ссылками работать, и на это t навесится
дополнительный амперсант. Вот вы же здесь от LVL вызываетесь, не так ли? И независимо от того,
что там было до этого, вы здесь получите x с 1 амперсантом, и t будет с 1 амперсантом,
если вы так напишете. Само t будет всегда с 1 амперсантом, если вы такое примете,
по правилам универсальных ссылок. Поэтому нельзя forward принимать t с 2 амперсантом,
это неправильно. Вы ничего не различите таким способом, потому что t всегда с 1 амперсантом будет
в обоих случаях. Принимать надо t с 1 амперсантом. А если мы const передали или что-то такое? Нет,
const сохраняется, с const ничего не будет. На самом деле, я немножечко обманул не совсем t с 1
амперсантом, но так тоже будет работать. Это будет почти правильнее forward. Сейчас обсудим,
почему не совсем еще правильнее. Значит, t с 1 амперсантом я принимаю forward, а вот возвращаю
t с 2 амперсантом. И по сути я говорю return static cast к t с 2 амперсантом от x.
Смотрите, что происходит. Если я вызывался вот здесь от lvalue, то есть вот этот вот,
давайте я как-нибудь по-другому назову, вот я не знаю, давайте я назову это, может быть,
t, нет, это будет y. Смотрите, если я вызывался от lvalue, то есть я получил x как lvalue, t здесь
будет с одиночным амперсантом, типом x будет int амперсант, и t здесь будет int амперсант.
Я приду сюда, t будет уже, т будет, поскольку я явно указал шаблонный аргумент, по-прежнему int
амперсант, я же явно указал шаблонный аргумент, t будет int амперсант, int амперсант, еще раз
амперсант, ну это все еще один амперсант, ссылка на ссылку, это по-прежнему обычная ссылка.
И здесь произойдет так называемый референс коллапсинг. Что такое референс коллапсинг?
Когда у меня есть int амперсант, и на него намешиваются еще два амперсанда, то считается,
что это один амперсант. Вот это вот превратится для компиляторов int амперсант, а поверх него
еще два амперсанда, но один амперсант побеждает, потому что если вы, ну как, у вас была lvalue
lvalue и rvalue, логично, что нужно сохранить lvalue, ну как, вы типа были, у вас была обычная ссылка,
но вы на нее навесили двойную ссылку, но это все еще должно остаться обычной ссылкой, это еще нельзя
муготь как бы. Это называется референс коллапсинг. Давай я это запишу, референс коллапсинг rules.
Значит, один амперсант плюс один амперсант, это один амперсант. Один амперсант плюс два амперсанда,
это один амперсант. Два амперсанда плюс один амперсант, это один амперсант,
и два амперсанда, на которые навешены два амперсанты, получается два амперсанда.
Вот здесь вот сработает правило, что один амперсант, и 2 амперсанты – это один амперсант,
амперсант. И вернется int одиночный амперсант, то есть l-value. Если же я принял x как r-value,
t будет без амперсантов, здесь x имеет тип int двойной амперсант. Но это не важно,
какой тип здесь имеет x, потому что проинциализирую я его все равно вот так,
ну это будет здесь y будет все равно иметь тип int амперсант, потому что x это l-value,
t будет без амперсантов, y будет иметь тип int амперсант, но статик k будет к двойному амперсанту,
потому что t без амперсантов. И это будет аналог MOV по сути. Вот так работает forward.
Кто понял? Отлично, теперь бы это еще все выучить. Тут я сказал, что немножечко вас обманул,
обманул я вас вот в чем. Тут на самом деле не t, а std remove reference t под t и 1 амперсант
поверх этого уже. У этого есть два объяснения. Первое объяснение такое, почему так лучше,
а не так как было написано раньше. Потому что это вынуждает вас явно писать шарлонный
аргумент при вызове forward. Если бы forward был реализован так, как до этого мы написали,
то можно было бы вызывать forward без шарлонного аргумента, и он бы вызывался, это бы не было в CE.
И при этом бы это неправильно работало. Потому что он бы не пробрасывал этот амперсант,
когда надо. Потому что мы же по одиночной ссылке принимаем, на t амперсант не навешивается. Вы бы,
забыв написать шарлонный аргумент явно, не получили бы CE, а получили бы не forward,
а просто копирование. Ой, не копирование, а move они бы получили всегда. Forward бы работал
как move, если бы вы забыли написать шарлонный аргумент. Вот при таком параметре компилятор
не может сам вывести шарлонный аргумент, поэтому вам его приходится явно писать.
А есть и вторая причина, есть еще вторая перегрузка у форварда на самом деле, вот такая.
Есть и вот такая перегрузка у форварда. Мы не рассмотрели случай, когда forward приходит rvalue.
Заметьте, что оба случая, которые мы рассмотрели, это было, когда мы forward перейдем lvalue. А бывает,
что мы forward rvalue передаем? Такое вообще, это вообще осмысленно, но потому что в прошлой нашей
реализации forward вообще не умел принимать rvalue. А осмысленно ли вообще хоть когда-то forward
передавать rvalue? Если мы вызвали forward от rvalue, какое-то ситуация, было бы CE.
А осмысленно ли forward передавать rvalue? Когда это может быть осмысленно?
Когда? Понятно или непонятно, когда? Непонятно. Непонятно, когда.
Если мы знаем rvalue, можно MOOC вызвать. Да, но мы можем не знать rvalue или это. Это может быть вот в какой ситуации.
Допустим, мы вызываем forward не от просто x, а еще от какой-то другой функции, которая от x.
И эта функция тоже может в свою очередь как lvalue, так и rvalue вернуть в зависимости от чего-нибудь там.
Ну, например, это та самая функция, вот та, которая была, забери str, либо копию вернет, либо там,
ну, что? Да, ну, наша f, вот которая там, которая ссылочным квалификатором, либо ссылку вернет, либо копию, либо rvalue копию.
Вот, и тогда forward иногда может получиться, что мы от rvalue пытаемся вызвать. В такой ситуации мы в старой реализации бы не смогли просто,
а теперь это не будет CE, просто мы попадем вот сюда. Ну, и все правильно сработает. Тут у меня произойдет, значит, что у меня произойдет?
Ну, все нормально будет, так rvalue останется. То есть на самом деле вот так вот реализован forward, у него две версии. Вот с таким параметром и с таким параметром.
