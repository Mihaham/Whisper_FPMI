У нас тема сегодня шестнадцатая и последняя, видимо, это Compiled-time-вычисление.
Ну, сегодня будет не совсем еще крышесносное Compiled-time-вычисление, а завтра напоследок я думаю,
что мы устроим какой-нибудь развал кабины, и будут очень веселые Compiled-time-вычисления,
и последнюю задачу я публикую на них. Но пока начнем с кастовом, наверное,
начнем с того, о чем все и так знают. Это Compile-time-вычисление.
Его базовое использование. Ну, слово constexpr появилось C++11, как и большинство из того,
чем мы занимаемся последние полгода. Что оно означает? Оно означает, что данная функция,
а может быть? Оно применимо к функциям и к переменным. Давай сначала поймем,
что такое constexpr функция. Ну, вот я напишу constexpr int, ну, не знаю, что-нибудь.
Sqr от int x возвращает x умножить на x. Вот. Ну, как вы, наверное, знаете, вообще говоря,
я не могу, например, создать какой-нибудь массив из int-ов размера Sqr от 5. Ну, вот. Если бы
здесь не было этого слова, до того, как мы начали это обсуждать, вот так я написать не могу,
не потому что я не заинфулил ray, сейчас я его заинфулю, а потому что... ой-ой-ой-ой. Блин,
я не в той папке находился. Ну ладно, чёрт, сейчас переду. Ну вот. Сейчас не будет ошибка
компиляции, потому что нельзя... ну, в параметре шаблона нельзя передавать вызовы функций. Это вы,
наверное, и так знаете. Вот. На ней мере должны знать. Ну, все здесь прислушивающие будут знать.
Вот. Что вам приходилось делать? Вам приходилось делать какие-то шаблонные мета-учисления, там,
рекурсию на шаблонах и так далее, чтобы уходит в статик const-value равное чему-то, и вот тогда его
можно. Ну, просто существует такое понятие константа времени компиляции. То есть константы бывают
обычные, бывают константы времени компиляции. Вот когда я задаю числовые шаблонные параметры,
мне нужна константа времени компиляции, а не просто константа. То есть то, что вычислено
на этой компиляции должно быть. Компилятор по умолчанию вызову функций в комплинации не делает.
Поэтому так вот и компилируется. Так вот constexpr это слово, которое предписывают компилятору,
если от него требуется вычислить эту функцию на этой компиляции. То есть можно эту функцию в compile
time вызывать. Вот сейчас поскомпилируется. Вот так стало можно начинать C++11. Вот. Я хочу, значит,
обратить внимание на следующий факт. Даже если бы я здесь написал const int. Ну, кстати,
может быть, так бы и сработало, там const int m равно десяти, и я бы сказал int, и вот здесь n.
Я, кстати, не уверен, сработали это и будет или нет. Нет, работает все-таки. Но я хочу сказать,
что вот этот const int n, это хоть и константа, но она не обязана быть константой время компиляции.
Ну вот, например, я мог бы поступить к каким-нибудь следующим образом. Я бы сказал int x,
ввел бы x с клавиатуры, а потом сказал const int n равно x умножить на x. И давай-ка я заведу массив
размера n. Конечно же, это будет CE уже сейчас, очевидно, потому что хоть это и конст, это не
compile time константа. Вот это пример иллюстривающей разницы между просто константами и константами
времени компиляции. Быть константой времени компиляции — это более строгое условие,
чем просто быть константой. Вот сейчас это очевидно не скомпилируется. Вот. Вот это вот называется
constant expression. n is not usable in a constant expression. Constant expression означает, что вот выражение,
которое в момент компиляции должно быть. Я могу слово constexpr использовать и для переменных тоже.
То есть я могу некоторую переменную объявить constexpr. Ну, например, могу вот про это переменную
писать constexpr. Что это будет означать? Ну, это опять означать будет ошибку компиляции, только на этот
раз уже в этой строке, где constexpr написано. constexpr переменная — это значит такая переменная,
которая должна быть, значение которой должно быть вычислено в момент компиляции. То есть она
должна в компиляторе, в момент компиляции должно быть вычислено значение и пронициализировано
это переменная. Вычисление того, чем она пронициализирована, не должно быть отложено на
runtime. Вот constexpr int — это более сильное условие, чем constint. constint означает, что просто константа,
но не обязательно то, чем она инциализируется в compile-time вычисляется, а constexpr int означает,
что это мало того, что константа, так еще и константа в момент компиляции уже должно быть,
в момент которой известно. Вот часто будет СЕ, потому что хуночная х, очевидно, нельзя использовать
для инциализации constexpr переменной. Да просто х нельзя использовать для инциализации constexpr
переменной. Вот. Но я могу, например, так написать. sqr от пяти. Вот так я могу написать. А если бы
здесь я убрал constexpr, то опять бы не смог, потому что, ну, соответственно, вот справа должно быть
что-то compile-time-вычислимое. Вот. Ну, все понятно, короче. Вроде как. Да? Вот. Ну, вот мы раньше писали
с вами static const, там all-value где-то. Теперь можно писать static constexpr. All-value — это даже будет
более диаматично, что ли. Ну хорошо, возникает вопрос. О чем можно вообще в constexpr функциях
использовать? Да, первое замечание, которое хочу сделать про constexpr функцию. Вот, допустим,
я сказал с dossеин х, потом, наверное, я все-таки ввел х, и вывел stdcout sqr от х. Вот здесь будет какая-нибудь ошибка.
Функция constexpr. Все нормально или нет? Да. Значит, правильно, все хорошо, никакой ошибки нет.
constexpr функция не означает, что она обязана быть вычислена в момент компиляции. А для этого есть
другое слово — const.all, но про него мы попозже поговорим. Вот constexpr функция — это функция, которая,
будучи вызвана их constant expression, компилятор должен попытаться вычислить compile-time. Но и это не
значит, что ее нельзя вызывать в обычных контекстах. То есть в обычных runtime контекстах ее тоже можно
вызывать. А если constexpr функция вызывает какую-то, которая не constexpr, то это ce? Это ce в момент,
когда до этого вызова дело дойдет. Сейчас мы эти все примеры разберем.
Да. Но давайте что-нибудь более сложное в constexpr функции напишем. Ну давайте,
например, это будет у нас какая-нибудь функция constexpr. Не знаю, что. Что-нибудь сделать там.
Что у нас бывает? Не знаю, вот. Esprime от n. Вот я сейчас проверю число на простоту. Только
вернуть нужно. Bool. Вот. Давайте короче напишем проверку простого числа. Ну там, что мы сделаем там,
скажем Bool. Вот первый вопрос. Вообще, могу ли я циклы использовать в constexpr функции? Вообще,
что я могу использовать в constexpr функции? Могу ли я написать проверку числа на простоту с помощью
constexpr функции вот стандартным образом? Ну то есть, я напишу там int d равно 0 d умножить на d меньше
или равно n плюс плюс d. Только не от уля, наверное, а от 2. Да, и если n делится на d, то return false.
Если n равно 1, return false, а тут return true. Так, я не наложал проверку числа на простоту. Надеюсь,
что нет. Такой позор будет. Ну будем считать, что я не наложал, ладно. Нормально все. Сейчас,
ну от двух перебираем делители. Ну да, нормально. Ровно нормально. Вот, это вообще скомпилируется
сейчас. Могу ли я такую функцию constexpr сделать? Почему нет? Ну я тут for использую, например. У нас
векторит все функции constexpr. Ну это вы просто уже много видели, да. Ну, до c++14 не мог. Вот это все разрешено только c++14.
Ну, в общем.
Значит, только начиная c++14 в constexpr функциях можно стало использовать control statement. В c++11 изначально
constexpr функции были вообще супер ограничены по возможностям. В них можно было использовать лишь
один return. Да, ну вот вопрос. Можно ли из constexpr функции вызвать не constexpr функцию? А давайте мы
так и сделаем. Вот смотрите, как удачно. Я тут как раз возведение в квадрат нужно. Вот я сейчас вот
это здесь и заиспользую. Вот. Ну и давайте я попробую. Ну, во-первых, просто попробую
это скомпилировать. А, нет. Я неправильно сказал. ce будет сразу же. Просто сразу же в момент
компиляции будет ce. Я не вызывал эту функцию даже. Вот. Если я из constexpr функции пытаюсь вызвать не
constexpr, то это ce. Потому что все, что я в constexpr функции делаю, должно само быть constexpr.
Вот. Ну, соответственно, sqr должен быть constexpr, тогда все заработает.
Окей. Что еще можно делать в constexpr функциях? Ну,
давайте вспомним, что мы еще умеем делать. Можно ли это делать в constexpr функциях?
Ну, не знаю. Ну, например, могу ли я в constexpr функциях объявить какой-нибудь указатель или ссылку
на что-нибудь? Могу ли я, скажем, взять там авто p равно адрес n? Не знаю, зачем это надо,
но вот зачем хотелось. Могу. Даже c14, кажется, это должен быть. Вот. Возникает, конечно, вопрос,
что же это такое за адрес? Ну вот, компилятор как-то, значит, а, мы ее не вызвали. Может быть,
если я вызову, все испортится. Ну, давайте bool is 32767 prime равно is prime от 32767. А! Это
должен быть constexpr bool. Нет, все работает. Ну, то есть, компилятор как-то вот в compile
time эмулирует самые настоящие выполнения. Можно заводить указатели, ссылки, массивы. Могу ли я
вот массив завести? Не знаю, вот, что я хотел написать теперь? Я не буду его писать, не знаю. Вот int a100. Нет, int a10.
И вот что-нибудь. A5 равно 3. Так получится у меня. An initialized variable. Мне нужно
инициализировать массивы. Ну, давайте инициализируем. Вот, давайте теперь. Все, массивы тоже
надо в клацеркульте заводить. Отлично. Что еще вы помните? Что еще бывает в программах c++?
C out. Ну, c out, очевидно, нельзя. Потому что, трудно сказать, почему на самом деле. Ну, это что-то странное
в этом видео. Ну, это что бы означало, что он в compile time должен подцепиться к потоку вывода и
начать писать прям в... В месяц сушку компиляции. Да-да, параллельно с сушкой компиляции. Ну,
давайте попробуем. Нет, не могу. Я, честно говоря, даже не пробовал, но нет. Ну, просто оператор
влево-влево у Basic Stream, не constexpr, вот и все. А жаль. Я просто сейчас вам расскажу, что еще
constexpr стал недавно. Ну, я так понимаю, что new, да? Не только. Это еще не худшее. Не худшее? Да. Ну,
окей. Значит, до c++14 constexpr мог содержать только один return и обходить астернарген подкатитил.
Начиная с c++14, стало можно использовать и for, ну, любые constful statements и try-patch,
чтобы нельзя было. Try-patch нельзя, switch, while, понятно, массивы можно заводить, можно переменные
объявлять локальные, можно, значит, другие функции вызывать. Ну, короче, фактически все,
что хотите, указатели, ссылки, там, рекурсия. Единственное, чтобы все функции были constexpr. Вот,
объекты нельзя создавать, конструкторы вызывать нельзя. Вот, но с другой стороны, смотрите,
вот если я, допустим, такое сделаю. Давайте я верну это назад, а то у меня странно уже какая-то
чушь написана. Вот вопрос. Вот, допустим, у меня есть какая-то структура и в ней есть поля. Да,
вот я сказал, объекты нельзя создавать. Ну, не совсем правда. Вот такие объекты можно, в принципе,
создавать в constexpr функциях. Это я все говорю про старые версии плюсов. Дальше с каждой версией
возможности того, что можно делать в constexpr функциях, расширяется неукладно. Вот могу ли я создать
такое? Ну, казалось бы, да. Почему нет-то? Pereturn s.y. Ну, то есть что, я просто вызываю конструктор
по умолчанию, да, и два поля инициализируются по умолчанию. Вот я сейчас, кстати, не уверен,
с какими флагами меня это скомпилируется. Ну, давайте, ну, давайте C++17 скомпилировать. Ну,
да, скомпилировал с C++17, ну, видимо, и с C++14 тоже скомпилировал. Да, то есть просто создать
объект, у которого нет нетривиального конструктора по умолчанию, я могу он стать функцией. Хорошо,
что если у меня был бы конструктор? Вот что теперь? Вот теперь это не скомпилируется,
скорее всего. Почему? Потому что уже конструктор пользователь, user defined, а он в constexpr не
помещен, конструктор это же тоже функция. Вот, поэтому если я хочу такое создавать,
то мне нужен constexpr конструктор. Вот теперь скомпилируется. Ну, то есть constexpr конструктор
просто, вот сейчас для нас constexpr конструктор это просто способ как функцию сказать, что его
можно вызывать в compile time. В частности, создавать объект такого типа в constexpr
функции. А вот, хорошо. Как насчет, ну, понятно дальше, что я могу, в принципе, все, вот пока
мы не говорим про выделение динамической памяти, понятно, что перегрузка операторов я тоже
могу в constexpr. Ну, то есть, если не обращаюсь к каким-то системным ресурсам, то кажется,
что я могу сейчас с таким же успехом определить constexpr операторы для этого класса. Вот, могу
наследование сделать, то есть я могу сейчас структуру S наследовать от другой, и тот конструктор
будет constexpr, и этот конструктор будет constexpr. Ну, то есть, казалось бы, ничего такого. Что еще
можно в constexpr функции? Вот, можно ли с исключениями работать в constexpr функции? Вот, можно ли в
constexpr функции в compile time бросить исключения? В 20 можно стало. Значит, правило было следующее,
вот dot C++, ну, давайте я вот так скажу, тест от X, давай я скажу, если X равно 0,
то throw, что-нибудь там, 1. Смотрите, как интересно. Вот, давайте я скажу constexpr int,
не знаю, C равно тест от 1. Вот, я зашел в эту функцию, проверил, если X равен 0,
то я должен бросить исключения, ну, а так, если нет, то я просто возвращаю тройку. Я вызываю
все-таки единицу. Смотрите, как интересно, все работает. То есть, вот эта константа будет,
ну, static assert, сейчас я напишу, что C равно 3. Static assert, напоминаю для тех, кто не знает,
это compile time проверка, что условия верны, если оно не верно, то ошибка компиляции. Вот,
поскольку у меня C это constexpr, вот для constexpr переменных я могу static assert проверять,
что они правны чему-то. Вот как раз тот факт, что переменная constexpr дает мне возможность
условия на нее проверять static assert. Все скомпилировалось. Ну, то есть, если бы я написал здесь C
равно 5, то была бы ошибка компиляции, что C равно 3 и не 5 на самом деле. Static assert failed. Так вот,
а что если бы я вызвался от нуля? Там написано if X равен 0, throw 1. Догадаетесь. Say yeah, потому что
брошено исключение в compile time. Ну, то есть, если мы в процессе compile time вычислений видим слово
throw, само по себе слово throw в концепциях функций не запрещено, но если мы на него
натыкаемся в реальности, то say yeah. Вот такое правило. Но это начиная с C++17. До C++17
вообще throw, по-моему, нельзя было в концепциях функций писать, давайте проверим. Да, вот смотрите,
в C++14 у меня expression throw expression из ноты концепция. То есть, до C++17 вообще throw в концепциях
функций было запрещено. Начиная с C++17. У меня работает. Можно. 14+. Да? Интересно. Может,
другая версия комплята. У меня и кланк, и JCC работают. Ну, фиг знает. 11 может начало разрешать.
Нет, не разрешает. Ну, в общем, не знаю. Но кажется, что, насколько я помню, так было. Вот.
C++17, соответственно, если мы натыкаемся на throw, то say yeah, а иначе все нормально. Просто...
Подождите, я неправильно сказал. Это у меня ошибка не из-за того, что я throw в принципе написал,
ошибка из-за того, что я от нуля вызвался. Может быть, действительно, C++14 тоже можно было throw писать.
Ну, не так важно, в какой... Ну да, видимо, это правда. Видимо, 14 тоже можно было. Ну, тогда не буду говорить,
что... Так, но... Ну, это не так важно, в какой версии что стало можно. Вот. А я сейчас говорю уже про то,
что можно теперь, начиная с C++20. Начиная с C++20, можно try catch писать в концепциях функций. Вот раньше
нельзя было. Вот. Я в C++17 еще не мог в концепциях написать try. Ну вот, давайте я так сделаю.
Очень странная функция. Смотрите, я, если х равен нулю, то кину 1 и верну, ну, в итоге верну 5.
А иначе верну 3. Вот я вызываюсь от единицы. Что сейчас будет?
Если я вызываюсь от единицы, то он компилирует прямо с warning, что C++20 нужно. Ну вот, C++17
он все равно скомпилировал, но с warning. Ну вот, C++20 он скомпилировал.
Вот. И статик осер, что C равно 3. Если от нуля, то...
Я разочаровываю.
Фроу сделал, но все равно не смог.
Эх, жаль. А я думал, он уже умеет. Ну ладно.
Try.cache писать научились, а фроу не научились делать.
Ну, если бы мы... Вот. В первом случае мы отработали.
Когда эти полуравия на единицы, мы попали в этот притерон. А так мы попали в этот притерон.
Так, давайте посмотрим на формальный список того, что умеет делать constexpr.
Вот здесь перечислено много интересного. Мы сейчас еще не все из этого разобрали.
Ну вот, возвращаемый тип должен быть ветеральным. Каждый из этих параметров должен быть ветеральным.
Конструктор и деструктор классно не должны иметь виртуальных наследований, так запрещено.
Существует... В общем, ладно, я не буду это читать. Нельзя, чтобы это был function.try.blog.c++20.
Ну, вот что нельзя в constexpr функциях до 723.
Нельзя go to, нельзя метки, соответственно.
Нельзя try.blog, нельзя assembler-ную вставку.
И нельзя объявление переменной, у которой не производится инициализация.
Это до c++20, было с c++20, стало можно.
Нельзя определять переменную нелитерального типа, нельзя объявлять переменную статического или thread storage duration.
Странно, что throw до сих пор нельзя, если можно при этом...
Ам...
Зачем нам go to?
Да, even though try.blogs and inline.assembly are allowed in constexpr functions, throw in exceptions or execute in assembly is still disallowed in a constexpr expression. Понятно.
Что такое literal type?
Я не помню.
Какой пример не literal type?
Ну, вектор.
Он не literal, у него же все constexpr.
Ам...
Нет, я неправильно сказал.
В общем, определение literal type подогнано под то, чтобы в constexpr функциях можно было создавать все то, что мы хотим.
Он должен обладать всеми следующими свойствами.
Имеет тривиальный деструктор до c++20, начиная с c++20, просто constexpr-деструктор.
И это, в общем, все, что мы хотим.
И это, в общем, все, что мы хотим.
И это, в общем, все, что мы хотим.
Деструктор до c++20, начиная с c++20, просто constexpr-деструктор.
И это один из эгрегатных типов, хотя бы с одним constexpr-конструктором.
И либо это замыкание.
Замыкание, то есть лямут.
Короче, очень много чего literal type-ами уже является.
Еще и unions-ы могут быть literal type-ами.
для юнионов
хотя бы один нестатический член должен быть не волатайл витерал-тайп
а для неюнионов все члены должны быть такими, и все базовые классы должны быть такими
короче, это очень слабое условие, что витерал-тайп
да, все-таки throw нельзя в констанциях функций делать, и вот здесь заметка, что
try можно писать, но throw делать нельзя, почему?
ну а когда тогда может try в констанциях функций быть полезным?
ну например, если эта функция, она вызывается как в run-time, так и в compile-time
в compile-time он просто try увидит, ну и пройдет спокойно, но если у нас ровно ткнется, будет ce, а в run-time он уже нормально
но исключение кидать в compile-time он все-таки не умеет
вот
давайте поговорим про constexpr-dynamic-memory-location
и про это я даже отдельные пункты веду
пункт 16.2 будет называться constexpr-new-delete
ну и
ну ладно, пройдите пока
ну constexpr-vector, vector-end-string
начиная с c++20
а
оператор new стала можно использовать в compile-time
зачем это может быть нужно?
и как это работает?
второй вопрос более интересен
на самом деле второй вопрос не супер интересен, потому что
это забота компилятора, как обычно
но компилятор уже полностью умеет
ну, он уже полностью потерян в compile-time, в лизы compile-time-вечтений
ну, по сути, весь c++ вогнали почти туда
теперь еще new там есть, delete
ну как? компилятор просто
пока компилирует, делает вызов new, ну что?
он запрашивает в операционке, кидает в память
ну, пока компилирует, в чем проблема?
ну, constexpr-new есть одно приятное очень свойство
которое отличает его от
не знаю, constexpr-array-sum
давайте
там, не знаю
constexpr-in-array-sum
а
ну, давайте я скажу, что
принимаю n
будет очень глупая функция, которая
заводит массив
заполняет его n числами
и возвращает сумму, не знаю
в общем
ну, давайте я скажу, что у меня будет
int звездочка p равно
int звездочка a равно
new
int n
ну, дальше я скажу
for там, int i равно 0
i меньше n, плюс плюс i
a it равно
i
ну, и дальше что-нибудь сделаю там, не знаю
for
ну, понятно, что я могу, конечно
сделать n умножить с 1 пополам
и вернуть сумму, но я вот
просто для демонстрации
возможностей сделаю глупый алгоритм под счет
суммы первых n чисел, вот я
скажу, что сумма у меня равна 0
а теперь я вот это скопирую
и скажу, что теперь
сумма плюс равно
a it
очень глупый алгоритм
и возвращаю сумму
ну, глупый не глупый
а можно, в принципе, и
что-то более интеллектуальное сделать
ну, допустим, у меня действительно был бы какой-то
вектор чисел
и
он бы где-то вот был записан
в каких-нибудь статических константах
ну, у меня был бы какой-нибудь реально массив статический большой
и мне нужно было в CompileTimer
посчитать на нем
какие-нибудь
вещи, ну, или, например, я хочу
в CompileTimer сделать 6-й ротосфер
вот, вот
CompileTimer 6-й ротосфер
я хочу там, в CompileTimer
построить там таблицу
там, среди первых
миллионов чисел
какой простой, какой нет
пожалуйста, я это спокойно делаю в CompileTimer
причем
это n, я его могу варьировать
и оно просто будет параметром
функции
я просто в CompileTimer
построю таблицу эту, среди што
ротосфер, и
она будет, как статический констант
массив, уже в бинарник записана
когда программа
запустится
вот, ну, вот сейчас
я попробую это вызвать
constexpr int
sum равно
array sum
от 10
допустим
и так
я здесь тест от 0
это не будет смогу вызываться
ну, давайте скажу, что
статик ассерт
что сумма у меня
45, наверное, должна быть
там, когда ввести число
сейчас будет CE
посмотрите на эту прекрасную
ошибку компиляции
на первую
я сделал new, а delete не сделал
в CompileTimer
компилятору не понравилось
когда я в CompileTimer использую
оператор new, компилятор
вынужден сам следить
за тем
освободил ли я все, что выделал
или нет
добро пожаловать в горку
добро пожаловать автоматически
можно сказать
нельзя сказать
сборкой мусора
если бы я не освободил
то компилятор
утечку памяти допустил в CompileTimer
так же он не может допустить
поэтому компилятор
если я что-то в new выделяю
в CompileTimer
дополнительно сам
он на самом деле запрашивает больше
он в CompileTimer поддерживает специальные
структуры, которые ему нужны
сколько я выделил, столько и освободил
это же еще веселее
допустим я скажу
delete
a plus 1
или go
я вот так скажу
delete a просто
даже это ведь плохо
я же должен был сказать delete
а
non-radiallocational object
allocated with react allocation
компилятор
честно следит
что-то, над чем мы столько
страдали, что мы должны были
в run-time с руками
отслеживать через санитайзер, компилятор
все теперь в CPU 20 умеет в CompileTimer
проверять
в частности, например
вы можете использовать это для того, чтобы проверить
вот у вас там, ну вы не из основного потока
даже если вы были из основного потока
даже если вы не из основного потока
вот пишите вы стринг
хотите проверить
не забыли все ли вы корректно
освобождаете
ну просто констанцев понавешали везде
соответственно
и статик осертов вместо обычных осертов
ну тогда компилятор просидит
что вы все освободили, что выделили
и корректно причем освободили
вот
но
ладно, я вам сейчас еще одну
очень забавную фишку покажу связанную
с этой
давайте я попрошу компилятор
посчитать мне сумму
времени от
не от 10
а вот знаете
сколько
да от миллиарда
я не буду уже статик
осерт говорить
чему равна сумма, я не хочу
я просто скажу, что она больше, чем 2 миллиарда
ну что сейчас будет?
ну сейчас
это будет очень долго компилироваться конечно
но может быть я
от миллиона все таки попрошу, а не от миллиарда
мне хватит
чтобы продемонстрировать нужный эффект
что сейчас будет, отгадайте
будет ЦЕ
и отгадайте почему
потому что переполнение
ИНТА
у меня loop iteration count exceeds limit of
262 тысячи
что?
это конечно
constexpr loop limit
ага
ну давайте увеличим
не проблема
я не знал, что они такого параметра
удивительно
сколько мне надо
2 миллиарда
ну давайте 10 миллион
вот он считает
вычисления в compile time
не очень быстрые
ну все
ЦЕ
overflowing constant expression
причем он очень много раз
эту ошибку выдал, видимо
он не остановил
вычисления, когда ее обнаружил в первый раз
и продолжил
а в конце он еще написал, что
evolution operation count exceeds limit of
3352432
так стоп, я же 10 миллионов поставил
лимит
а это лимит на цикл, а тут есть еще
лимит на операции
и его нужно, минус f constexpr obs limit
в общем, у него много лимитов
ну это предохранитель
ну это уже понятно, ни в каком стандарте не описано
а это просто у самого компилятора
предохранитель
constexpr obs limit
это понятно в самом компиляторе
что надо предохранить, чтобы вы случайно
в compile time не зависли
понятнее, чем это надо
но можно и его увеличить
ну то есть, смотрите, constexpr позволяет вам
вылавливать УБ
compile time
то, что раньше было УБ, теперь ЦЕ
то, что раньше было РЕ, теперь ЦЕ
давайте я все-таки вектор заведу
стд-вектор
только это будет В
ну, а тысячи буду вызываться
чтобы не сильно вручать
вот
значит
вот
я
этот вектор завел
я его посчитал
ну, сейчас просто проверим, что работает
то там, вроде, символисты жаловались
что не компилируются
ага
я просто не заинтуидаю
значит, начиная с имперсус-20
конструкторы вектора
стали constexpr
все
ну, возможно, кроме вектора
почему? потому что теперь Нью
можно в compile time делать, соответственно
вы можете в compile time теперь заводить векторы
сроки тоже
я, кстати, напомню, что
в стринг, в строке
там есть еще один дополнительный прикол
там же есть
SOO
small object optimization
или SSO
там union
у которого
члены переставлять приходится
иногда
ну, то есть, у вас с юнионом же
следующая проблема
ну, когда вы выбрали какой-то член в юнио
она потом в runtime подменили тип лежащего в юнио
на что-то другое
вот
и это все тоже в compile time теперь можно делать
это раньше было нельзя до какой-то версии
но я не помню до какой
ну вот, начиная с какой-то можно
то есть, сейчас, мне кажется
ой, материалная статья
у меня была
статья, в которой перечислялась эта
ну, ладно
вот
ну, в общем, строки и векторы
я теперь могу делать в compile time
х
не могу
очень слышно
может быть
g++ не справляется
да, вот семейристы еще тоже жалуются, что
вектор в compile time не изменится
аа
справишься или нет?
нет, все равно не получается
это очень странно, наверное
у меня просто старая версия
давайте
давайте-ка я попробую
давайте-ка я попробую
это все
я попробую
интересно выделяется
ладно, сейчас godbolt
должен работать
давайте
я не помню как
вот
заходить
поэтому придется
пишет, ошибка, что
у среди векторов нет constexpr деструктора
сейчас
где constexpr
был файл
давайте
вот эту функцию мы
скопируем
да, просто все скопируем
и
gcc 12
все еще не справляется
а силенка 12
силенка 14
да, силенка 14
все
нет, все равно не может
а не может, вероятно, потому что
очень странно
а
остается
17, давайте попробуем 20
все равно не может
я что-то не понимаю в этой жизни
прошел стринг, посмотри
вы видите constexpr
а так
да
что?
да
да
да, очень странно
непонятно
ну
значит
я был неправ
и почему-то они еще не поддерживают
объявление векторов
в компонент тайне
хотя мне казалось, что я
прям точно
видел такое
возможно, это было планируемое
возможно, мне
побережилось
а возможно, это был какой-то код
который потенциально должен скорость
работать, потому что не работает
да
ну ладно
ну значит
почему-то вектор пока нельзя
объявлять в компоненте функции
написано, что
должно быть
с 12
работать
что именно?
вектор constexpr
ну возможно
можно написать constexpr
вектор вот так
наверное
вот что имеется в виду
что можно constexpr
вектор завести вот таким образом
вот так можно
в
в
ничего
тоже нельзя, по той же причине
ну это уж вообще странно
довольно бессмысленно
очень странно
очень странно
ну уж строки-то уж точно
должно быть можно
я же прям видел, что люди так делают
ладно
я вас обманул, значит нельзя
но я не знаю почему
я был уверен, что можно
это было странно
не знаю почему
ладно, разберусь
давайте дальше пойдем
ну короче constexpr new
и delete в любом случае можно
по крайней мере это значит
что вы можете
свой вектор написать
который уже будет compile-time поддерживать
вы можете
наверное объявить виртуальный
constexpr
деструктор у вектора
и тогда он будет
работать
то есть если вот мы посмотрим на вектор
и на его методы
то наверное мы увидим, что деструктор
в нем не constexpr
не деструктор в нем constexpr
тогда это вообще
очень странно
может быть компиляторы просто не поддерживают
еще до сих пор, потому что su20 должно быть можно
ну написано
там же есть статья
написано, что должно
поддерживать su12
ну вот
почему-то не поддерживают
то ли я какую-то мелочь забыл
то ли
компиляторы
еще не умеют до конца
возможно в библиотеке
еще constexpr
писали в деструктор вектора
то есть начиная с su20 и деструктор
а следователь на тип становится литеральным
согласно тому определению, которое вы читали
казалось бы он должен создаваться в компрелтайне в мете
в общем
я даже если не поддерживаюсь сейчас
я все равно верю в то, что это очень скоро начнет поддерживаться
следующая вещь, о которой хочу поговорить
это самая crazy
возможно вещь, которую я
слышал про
c++
ну нет, самая crazy
будет завтра
это наверное
ну это самая смешная вещь
которую я за последний год
слышал про c++
связанная с c++20
что у нас еще есть
в языке важного
из того, что мы изучали
ну у нас понятно, из класса
конструктор, киргруз и операторов наследования
у нас была такая замечательная тема
полиморфизм
и виртуальные функции
а не поддержать ли нам в компрелтайне
виртуальные функции
подумал комитет
а давайте
решили они и поддержали
начиная с c++20
можно виртуальные функции делать констэксп
таким образом
можно делать в компрелтайне динамик диспетч
вот давайте это посмотрим
давайте я попробую
завести класс base и класс derived
давайте это будет пункт 16.3
констэкспорт
виртуал
функционс
динамик каст
начиная с c++20
вот я завожу структуру base
да
это смешно
и тут у меня будет
виртуал
void f
ну не знаю
return x
констэкспорт
base
base
вот
ну и завожу структуру derived
которая наследуется от base
у нее тоже констэкспорт конструктор
напишу на всякий случай чтобы там
ни по сомнению не было
alright
и
верну игрок на этот раз
ну и давайте
констэкспорт
int test
virtual
вот
нет чего
ну что
как там
мы любим base
звездочка p
b равно new
derived
int
ans равно pb
стрелочка f
delete base
delete pb
обязательно а то у нас будут проблемы
из-за неосвобождения памяти
return ans
нам похоже нужно виртуальный структур добавить
или не то что важно
ну давайте
добавим
не знаю влияет ли это на что-то
а
мне нужно написать констэкспорт base
потому что сейчас у меня не виртуальный структур
кстати не знаю может быть
давайте сначала без него попробую
потому что я не уверен что написал виртуальный структур
base возможно все сломается
а
void function f
should not return a value
ну действительно
and
void int
ой
да я еще что-то написал
давайте посмотрим
что теперь
ну опять та же проблема с вектором
но в остальном-то нет проблемы
ну как видите компилятор не жалуется
то есть единственное что ему не нравится
это вектор
ну
вернем как было
блин
вот точка v равна
ее int под n
а тут delete
конкретность
конточки b
так
ну тут кстати
assertion failed
но в целом
давайте проверим
констэкспорт int
мы не написали нашу функцию
констэкспорт f
да и тем не менее почему-то он скопилировался
мы вызвали тест
нет
констэкспорт int
мы его удираем
потому что только мы ее мы вызовем
что забавно
констэкспорт
int res
равно
тест
virtual
и
статик assert
что res
равен
нелю
давайте здесь будет 2
2
2
проверим
вот
non-constext function cannot be used in constant expression
ну давайте исправим
давайте пометим
констэкспорт
так
мне кажется констэкспор надо писать перед
virtual хотя я не уверен
вроде не важно
удираем
я бейс пометил
а теперь еще удираем пометим
забавно то что бейс можно в данном случае не помечать
потому что мы ее не вызовем в итоге
это сработает
дальше
это теперь ошибка компиляции
тоже
классно
ну давайте сделаем виртуальный деструктор
ну давайте я сделаю
просто виртуальный деструктор
и тогда я наверное получу по башке за то что он
не констэкспорт
с g c 11 не ругается
на это
non-literal type-destruction
не констэкспорт
non-literal type derived
cannot be used in constant expression
он ругался когда не было вообще деструктора
because
ну короче деструктор я тоже должен делать
констэкспорт понятна уже причина
констэкспорт virtual
тоже мне нравится это сочетание слов
деструктор base
вот
его еще надо определить
чего
что
вот это должно запуститься с кангом теперь
какая-то магия
g plus-plus не ругается когда вообще нету деструктора
виртуального ему пофиг
он ругается
но вы наверное
понимаете что как и с концептами
это все вещи очень
еще сырые
как видите компиляторы очень расходятся
во мнениях что должно компилироваться
а что нет
вот я уверен
что и в том и другом компиляторе еще есть
достаточно багов
то есть мы сейчас наблюдаем
не то что должно быть по стандарту
а то что компиляторы
научились поддерживать к данному моменту
c++ 20 пока
еще без багов
поддержать не удалось
но тем не менее
мы хоть от
какого-то компилятора добились
поддержки виртуальных
значит функций
вот ну и
кстати
вопрос еще такой могут ли
констэкспорт
вот если я вот эту функцию
действительно не сделал бы констэкспорт
то
сработало бы это
это бы все равно сработало
под g++
а
это
не работает по той же причине что и раньше
но не
из-за того что я написал
смотрите у меня виртуальная функция f
а override ее констэкспорт
функция то есть
исходная функция была не констэкспорт
а эта функция была констэкспорт
функция
которая override
та которую она override
не констэкспорт и это ничему не мешает
просто в компайл тайме
если дойдет дело до вызова f
и он поймет что нужно выбирать эту f
то будет ce потому что мы вызвали
не констэкспорт версию
а если мы попадем
в нужную версию
если динамический полиморфизм
в компайл тайме поймет что
мы попали в констэкспорт версию
то она вызовется успешно
ну соответственно можно делать
динамик каст в компайл тайме
теперь
констэкспорт функция
ну
ну я наверное не буду
демонстрировать ну в общем
можно вот
вот можно почитать статью тут у меня есть
я тут заготовил несколько
ну вот есть статья
про то как
а
значит что
решили в c4s20
добавить и
здесь есть
даже некоторые практически
пример я его даже
скопипастил
я даже открыл blackbolt
вот здесь есть
очень классный
практически полезный пример
использования констэкспор
версию функций
а именно задача парсинга
выражений
вот в такой форме
значит мы берем констэкспорт
выражение
строку
и статик ассерт
что ее значение это выражение
вот такое
а внутри тут парсер
но парсер он устроен
он использует виртуальные функции в своей реализации
то есть что у нас есть
ну мы типа разбиваем выражение
на ноды
да у нас есть нода
просто int у нас есть
нода сложения
у нас есть нода умножения
и мы значит
вызываем эволуэйт
от ноды
ну в случае умножения
у нас получается что мы оцениваем левое
значение левого и значение правого
и перемножаем в случае сложения
делаем вот так
в случае просто числа
просто возвращаем это число
ну и дальше нам нужно просто научиться
делать парс
мы распарсили либо
число либо терм
либо выражение
выражение
эээ
ну и вот
в итоге это все компилируется
и работает
по константной ссылке
агументы принимаются
по константной
час червь
по
по ссылке на константные указатели
мы принимаем здесь агументы
не такой код станд
но вот
здесь правда
гцц
гцц 12
не справляется
только силенк справляется
ну видимо поддержка
virtual constexr функции
в гцц еще плохо сделано
то есть это есть в
ну вот силенк 13
компилирует спокойно
и вся программа состоит просто
из ничего
программы пустой по сути
но все сделано в compile timing
вот все скомпилировалось
гцц не умеет почему-то ничего
то есть это есть в стандарте
да да да
allowing virtual function
holds in constant expressions
пропузал который собственно
был в стандарт добавлен
окей давайте
расскажу быстренько еще про пару
вещей связанных с compile timing
функциями
и видимо на сегодня мы закончим
ну а завтра я расскажу уж совсем дичь
вот
обязательно приходите
еще пара
вещей
связанных с концепцией
функциями
это
ну во первых
есть такая замечательная функция
из constant evaluator
она позволяет вам проверить
вы сейчас в compile timing находитесь или нет
ну например
вот вы пишете какую-то функцию
возведение в степень
вы хотите по-разному действовать
в зависимости от того
вы сейчас в compile timing вычисляетесь
просто не все вещи могут быть в compile timing
например сделаны
например в runtime вы можете вызвать
какую-то более
умную функцию
которая там делает что-то что в compile timing запрещено
не знаю
или вы можете
в runtime
просто
если вы понимаете что у вас слишком
долгие вычисления вы можете там
на runtime отложить сказать что
если меня вызвали от большого
числа, а я в compile timing
то я не хочу вычислять
это скажу ошибку
а в runtime я вычислюсь
если так получилось
вы проверяете из constant evaluator
эта функция реализована компилятором
на C++ ей не напишешь конечно
это внутренняя функция
раньше она была компилятором
то есть нужно было подчеркнуть
что-то там
в C++ 20 я добавил стандарт
то есть вы можете использовать разные алгоритмы
в зависимости от того
по разному действовать изнутри функции
понимая вы сейчас вызвались из compile timing
или не из compile timing
кстати
обратите внимание
типичная
ошибка
которая бывает при использовании этой функции
это написать if const export
у нас же есть if const export
который проверяет в compile timing
верно или нет
но дело в том
что как раз когда вы хотите if
из const evaluator
вы не должны писать const export
после if
потому что это автоматически сделает условие true
потому что если вы написали их const export
то то что под if в скобочках
оно автоматически const evaluator
и вы получите true
поэтому если вы хотите проверять
const evaluator
вот так написать не надо
и эта функция
в C++ 23
будет устаревшей
скорее всего
потому что ее заменят
другим
другой конструкцией
и в const evaluator
что
ну
точнее нет
if const evaluator будет не устаревшей
потому что она просто будет реализована
через if const evaluator
но вместо if const evaluator можно будет писать if const evaluator
в C++ 23
if const evaluator
уже не нужен круглых скобочек
просто фигурная скобочка
это вот укивалент на проверке того
if compile timing сейчас или нет
const evaluator это новое ключевое слово
вот
ок
ну и
последнее
видимо, что я на сегодня расскажу
но под это я
таки заведу отдельный пункт
это вот как раз
слова const evaluator
const init
давайте я скажу
так
const initialization
const evaluator
const init
а
что
такое
const initialization
ну вот тут я наверное опять обращусь
к статье, но он другой
вот к этой
мы с вами кажется
мы когда-нибудь говорили до сих пор про то
как вообще
инициализируются переменные
в какой момент и кем
но вот
когда у вас есть статические переменные
или когда у вас есть константы
есть
два варианта
они могут быть инициализированы в compile time или run time
то есть константы вот бывают
в compile time вычислимые и те которые уже
после запуска программы вычисляются их значения
вот
соответственно
если у вас
какая-то переменная
объявлена
ну скажем
да даже если она объявлена
const export
сейчас
если она объявлена const export
то наверное это все-таки означает что она должна быть
вычислено
ва
в compile time
если у вас какая-то переменная объявлена
как const
ну вот это тот пример который я говорил в самом начале
то это еще не гарантирует вам
что ее значение будет вычислено
и она будет проинциализирована в compile time
const export вам как раз это гарантирует
вот
но
вы иногда могли бы хотеть
например
чтобы у вас
переменная была гарантирована
вычислено в compile time
но не была константой
вот для такого есть
слово const finite
сейчас
ну то есть вот что мне надо
вот у меня есть compile time
у меня есть переменная
которую я хочу сделать константой
но при этом не гарантирую что значение этой константы
будет положено в бинарник
до запуска программы
тогда я просто пишу const int
если я говорю const export int
я тем самым себя гарантирую что вот эта штука
будет вычислена в compile time и уже
на момент запуска будет известно значение этой штуки
но она при этом будет константой
а что если я хочу сделать
не константу
не константную переменную
но тем не менее гарантировать
что значение будет вычислено
в compile time
ну тогда у меня есть ключевое слово const int
оно появилось
тоже c++20
const int int c
равно
тест от одного
вот сейчас будет
ce скорее всего, потому что
статика cert
уже не работает, потому что это
не compile time константа
я лишь гарантировал что
она инициализируется в compile time
но
менять ее
после этого я могу
вот
соответственно
если бы у меня была какая-нибудь константа
времени конверяции
типа
не примитивного
а какого-нибудь классового
то это бы означало, что чтобы ее
инициализировать в compile time
мне нужно чтобы у него был const export конструктор
и вот эта причина, по которой конструкторы
всех классов стали const export
довольно давно
ну там, если отбросить вот эти истории
с выделением динамической памяти
конструкторы
некоторых классов, которые казалось бы
никакой динамической памяти не выделяют
стали const export
еще до того, как разрешили
много чего делать const export
просто потому что вы иногда бы хотели, чтобы у вас
константы времени
конпиляции можно было создавать вот таких
типов, чтобы они были инициализированы
уже в compile time, статическая инициализация
что бы происходило
ну а вот это вот с const init
примерно
то есть вот это например не сработает
потому что вот это
не const export функция
ну
динамическая инициализация
и
order fiasco это
это уже
другая история
я про это не буду говорить
вот, а
последнее слово, про которое я хотел сказать
это const eval
но я про него уже очень скользь упомянул
там особо говорить нечего
просто скажу, что const eval
то
это
способ гарантировать
что функция обязательно в compile time вычисляется
вот у нас
снова const export
а
как я уже неоднократно
повторял, оно означает, что
функция может быть вызвана в compile time
но это не мешает ее и в run time тоже вызвать
вот если вы хотите, чтобы функцию только в compile time
можно было вызывать, то слово const eval
то есть const eval функция
вам выдаст ошибку в компиляции, если
вы попробуете из run time ее вызвать
а что значит из run time?
ну не в compile time
не в compile time контексте
то есть вот если
вы вызываете в контексте, который const eval
то нормально
а мучать const export int
обязательно равно быть в этой функции?
конечно, потому что именно const export int
что-то
как раз и обязывает, что там compile time
вычисляется
когда ты идентифицируешь const export переменную
это как раз случай, когда
то, что справа
должно быть в compile time вычислено
и ты в compile time контексте находишься из const eval
вот там const export
функция будет
const eval функция подойдет
ну можно
открыть, значит
подемонстрировать
const eval
const eval specify
и это все появилось
тоже начиная с secret 20
