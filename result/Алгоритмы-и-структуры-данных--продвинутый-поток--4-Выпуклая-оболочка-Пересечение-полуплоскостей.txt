Ну, попробуем рассмотреть еще одну такую достаточно известную задачу, как поиск выпуклой оболочек.
Так, ну и сразу начинается вопрос. Что такое выпуклый оболочек?
Ну да, вот давайте смотреть. Допустим, у нас есть какое-то абсолютно случайное подмножиство точек на плоскость.
Ну в принципе, определение, которое мы сейчас скажем, он может работать и в пространстве, и в гиперпространстве.
Ну а теперь вытекает вопрос. Что такое выпуклая оболочка?
То есть выпуклая оболочка со множества а или, как мы ее будем называть, конв, от а.
Конв, соответственно, от слова конвекс. Соответственно, выпуклый.
Это... так, что это такое?
Ну, например, пересечение всех выпуклых фигур, содержащих все эти точки.
На самом деле, да. Ну и в общем-то, да. На самом деле, тут обычно есть два определения.
Одно, такое смысловое, то есть минимальное по включению,
минимальное по включению, выпуклое, да, важно, выпуклое множество а штрих,
такое, что а является под множеством а штрих.
Вот. Минимальное по включению. Вот по смыслу, вот.
Но на уровне определения, конечно, вызывает сомнительность.
Потому что что вообще означает это сочетание минимальное по включению?
Что нет никакого под множество строго собственного, которое тоже содержит...
Ну, например, так, да, что нельзя взять его выпуклое под множество, которое тоже содержит а.
Но возникает естественный вопрос.
Почему такое существует?
Ну, во-первых, почему такое существует, а во-вторых, почему такое единственное?
Вот. Ну, на самом деле ответ-то это дает эквивалентное определение.
То есть выпуклая оболочка, в общем, короче, не буду переписывать.
Ну, короче, конват а это пересечение множеств а штрих,
где по всем а таким, что а содержит а штрих и а штрих содержится в квадрат,
и, соответственно, а штрих выпукла.
Вот.
Ну, действительно, почему это оказалось бы одно и то же?
Ну, по весьма естественным причинам.
Ну, начнем с того, что пересечение любого множества, любого количества,
неважно, счетного, несчастного, континуального, там, что-то и там еще, оно заведомо выпукло.
Почему?
Ну, просто потому что мы помним, да, какое у нас определение выпуклости.
Для любых двух точек отрезок может быть не algorithms, да?
Да.
Совершенно верно, фигура выпукла, есть для любых двух точек фигуры отрезок следующих, тоже целиком в этой фигуре ложится.
Ну, заметим, что если какие-то две точки лежат в пересечении выпуклых ножств,
то есть, значит, эти две точки лежат в каждом из этих ножев,
значит, в каждом из этих ножев лежит целиком отрезок,
значит, и в пересечении их этот отрезок целиком лежит ура.
Следовательно, это нож то выпукла.
выпукла, но и очевидно, что а в нем тоже нет, вот. Но соответственно, почему оно
минимальное по включению? Ну, просто потому что, если было какое-то меньшее, то тогда
у нас противоречие с тем, что это пересечение всех выпукло. Вот, поэтому это
получается, то есть, поэтому такое определение, собственно, да, эквивалентно
этому заодно дает ответ, действительно, на вопрос, почему тут это существует
Ну, там, в другую сторону было бы доказательство на тему того, что как бы вот это
вот пересечение, оно советово в любом выпукло множестве лежит, да. Вот, но действительно,
заметьте, да, такое определение дает на возможность определять все, что угодно,
определять выпукло оболочку для чего угодно, вот. Ну и по идее, но заменим, что форма
выпукло оболочки может быть какой угодно, на самом деле. Ну, то есть, зависит от того,
что подходит, потому что, например, ну, допустим, если у нас там какая-нибудь вот такая,
вот типа кардиоиды, например, такой, да, то что такое выпукло оболочка этой фигуры? Ну,
по кроме того, что внутренностью, естественно, берем. Что это такое?
Там нужно касательно привести ее на все, что между ними содержится. Ну, вот, типа того, да, да, да, да.
Да, то есть, вот как-то вот так. То есть, как-то вот так. Ну, действительно, там можно,
действительно, для многоугольника что-нибудь поговорить, то есть, у многоугольника тоже
может быть там какая-нибудь выпукло оболочка, но здесь все достаточно просто. Ну, у нас,
в общем-то, будет такой достаточно простой случай. Ну, вот, мы будем пытаться искать выпуклую оболочку
конечного множества точек. Поддано нам n точек на плоскости, нам очень хочется найти выпукло оболочку.
Формально говоря, мы пока даже не понимаем, а что это вообще такое? Ну, вот. Ну, как бы, да,
напоминаю, мы тут мыслим немножко формально. Я думаю, что, конечно, вы, наверное, в своей жизни хотя бы
раз в жизни искали выпукло оболочку или нет? Так, ладно, кто хотя бы раз в жизни искал выпукло оболочку?
Ага, отлично. Ну, вот. Ну, тогда да. Значит, теперь осталось только подвести под это
какие-то менее интуитивную базу. Ну, вот такую, более формально доказательную. И так, потому что
вообще выпуклая оболочка, согласно вот такому определению, может быть, что там? Круг какой-нибудь,
элипс. Что там еще? Какие еще выпуклые может что бывает? Полуплоскость. Да, плоскость, кстати,
тоже выпуклая множество. Или там угол какой-нибудь, ну и там в общем. Чего? Я бы сказал, что она, конечно,
не по площади, например, по минимальным вот, минимальным включениям. Да, да, вы читеры, да. Ну,
и она же такая смешная существует, потому что она единая. А мы с читерами. Мы ввели второе
определение и увидели, что она рекламина. Да, так что это? Так что ты, это там, это называется,
лучше вылезай, а то, знаешь, мы тут, мы тут можем по-другому мыслить немножко. Ой, а то, да,
и падает. Ой, давайте я десять минут отдохну, все равно понятно, что вы будете говорить, а потом
выяснится, что я делаю. Вот, ну ладно. Значит, что у нас тогда дальше? Ну, кстати, на тему прямой.
Прямая, не прямая, но есть такая подлянка, что выпуклой оболочкой и множеством точек вполне
может быть отрезок. Ну, если их совершенно случайно, все точки лежат на одной какой-то
прямой, то, соответственно, выпуклая оболочка, очевидно, является отрезок. Да, такой случай
чисто теоретически есть, и об этом надо помнить. Если все точки лежат на одной точке, то это одна точка.
Ну, скажем так, это вырежненный случай вот этого вырежненного случая. Вот так. Да,
такое тоже, ну такое, да, это ваше, такое тоже бывает. Не, ну мы, конечно, считаем это просто ты,
что у нас все точки по парам различны, но да, но помните, да, то есть, конвекс, выпуклая оболочка,
множество из одной точки равно, ну, конечно, просто эта точка. Точнее, множество из этой
точки. Да. Ну, помните, у вас там логика какая-нибудь была, там вот это, что множество из одной точки,
одна точка, это разные вещи, типа, да, вот это вот. А теперь давайте думать, чем же может быть выпуклая
оболочка, если точки на одной прямой не лежат. Ну, вот давайте, вот давайте все,
давайте зачистим, и давайте будем делать пим-пим-пим. Так, для этого нам нужен,
возьмем красивые марки. Вот, м точек. Вот. Так. Ну, давайте думать, вот, соответственно,
смотрите. Давайте все-таки, вот так вот сделаем. Ну, давайте думать, где у нас может быть граница
этой выпуклой оболочки. Ну, давайте попробуем найти самую нижнюю точку, и проведем через нее
ризонтальную прямую. Начнем с того, что вся эта выпуклая оболочка заведомо лежит в верхней
полуплоскости относительно этой прямой. Ну, просто потому что это выпуклая оболочка содержащая все
точки. Ну, а заметим, что вот эта точка, ну, в этой выпуклой оболочке лежать обязана, правда? Да,
кстати, сразу оговоримся, может так случиться, что точек на этой прямой окажется несколько. Мы
будем рассматривать самую левую, самую левую. Вот. Тогда что получается? Значит, мы видим,
что эта точка точно выпуклая оболочка, а еще это самая левая, а еще самая правая. Тут тоже будет
на выпуклой, если что, тоже на выпуклой оболочке, и более того, этот отрезок целиком в этой выпуклой
оболочке заведомо лежит. Вот. Значит, очень интересно. Мы уже такую часть выпуклой оболочки нашли.
А теперь будем думать вот о чем. Смотрите. Рассмотрим теперь вот из этой правой точки вот
такой красивый лучик. Значит, смотрите, тут какая тут штука. Видим, что относительно
этой полуплоскости все точки лежат в этой полуплоскости. А теперь давайте вот эту
полуплоскость границу поворачивать вокруг этой точки. Вот, поим, по чуть-чуть, по чуть-чуть,
по чуть-чуть поворачиваем. По чуть-чуть, по чуть-чуть, по чуть-чуть, по чуть-чуть. Видим, пока чуть-чуть
поворачиваем, мы видим, что в этих полуплоскостях, получаемых, выпуклая оболочка тоже лежит,
правда? То есть, в принципе, отсюда следует, что она будет лежать и в пересечении полуплоскостей,
можно сказать, что просто вот в этом угле лежать, правда? Значит, лежать, лежать, лежать, лежать. И
наконец закончится тем, что в какой-то момент лучше все-таки наткнется на какую-то правую точку.
Вот как интересно получается. Так, наткнулись, но теперь мы тогда видим следующее, что то, что у нас
тут получается, это на самом деле, это, как видим, граница выпуклой оболочки. Ну, в том плане,
что эти точки лежат в выпуклой оболочке, но в ее окрестности здесь точки, не лежащие в
выпуклой оболочке. Ну, потому что вот все точки не с той стороны относительно прямой,
они уже заведомо вне выпуклой оболочки. Ну, это уже выяснилось, правда? То есть, получается,
это вот такая вот граница интересная получается. Что происходит дальше? Ну, теперь давайте вращать
эту плоскость, то есть эту прямую, относительно уже вот этой вершины. И будет тоже получаться,
некоторое время, значит, просто мы крутим-крутим-крутим, и в какой-то момент
натыкаемся вот на эту. Так мы нашли вот, то есть еще то, то есть мы вот продлеваем вот таким
образом границу. И, смотрите, ведь мы же так можем повторять эту операцию, правда? То есть,
мы вот так повторяем операцию, повторяем. То есть, в каждый момент времени относительно точки
находим самую правую. И получаем вот такой вот выпуклый многоугольник. Почему он выпуклый? Ну,
потому что у нас что-то повороты все в одну сторону. Да, в какой-то момент возникнет ощущение,
а почему мы, собственно, зациклимся обязательно? Ну, просто потому что, когда прямая у нас
повернется на 360 градусов, у нас она будет, значит, у нас будет какая-то горизонтальная прямая,
которая проходит через какую-то точку, и при этом все точки находятся выше. А у нас одна такая точка,
по камере прямая точка. Вот. То есть, вот получается такая красота. Причем, что интересно оказывается,
что, смотрите, то есть, получился выпуклый многоугольник. То есть, он целиком выпуклый, его
граница выпуклая, оболочка лежит. Так, вследствие, все, что внутри, тоже лежит внутри. А вот то, что вовне,
оно как-то не лежит. Ну, просто вот за... Ну, вот. Потому что, по сути, получалось следующее,
что через каждую прямую... через каждую сторону можно прям провести, действительно, прямую такую,
что, действительно, все не с той стороны заведомо оболочек. Ну, вывод очень простой. То,
что у нас получилось, это, действительно, выпуклая оболочка. И, таким образом, то есть,
фактически, уже, то есть, получилось... можно параллелить прям мистическую теорему. Теорема
Выпуклая оболочка множества n точек, это либо точка, либо отрезок, либо выпуклый ногоугольник с вершинами в этих точках.
Вообще пустое множество.
А, ну да, выпуклая оболочка пустое множество это пустое множество, но мы как-то обычно n раз на нулю не распадкаем в таких задачах.
Ну бывает либо точка, то есть она сама, либо отрезок с концами в каких-то этих точках.
Но более того, что для нас тут приятно, как для программистов, так это то, что в принципе, вообще-то говоря, мы с вами придумали просто конструктивный алгоритм, как эту выпуклую оболочку искать.
Единственное только, конечно, оговорка, что вот так вот вращать, что, конечно, мы не можем сказать компьютеру, там вращайте касательно.
Вот вращайте барабан, мы сказать можем, вот там генератор случайных чисел запустил, а там вращайте прямую, мы сказать не можем.
Но что мы можем сказать? Можем мы ему сказать следующее, что в каждый момент времени мы говорим, мы пришли вот в какую-то точку.
Мы знаем, что если вот из этой точки смотреть в предыдущую, то все находится правее, и более того, строго за нами ничего нет.
То есть это означает, что в принципе все вот эти вот точки оставшиеся мы можем между собой сравнивать по принципу кто левее, кто правее, с помощью просто векторного произведения.
И все, что нам остается, это сказать, ну, то есть найти самую правую, и мы ее можем прям честно найти.
Прям честно в тупую перебрав, ну и конечно же с оговоркой, что если таких будет несколько, то вторым сравнением в компараторе будет кто дальше.
Да, кстати, совет на тему константы, когда измеряете кто дальше, вам не обязательно вычислять расстояние.
Ну, расстояние не надо вычислять, потому что лишней раскорей извлекать будете, и не надо делать квадрат расстояния, потому что это лишнее умножение.
На самом деле вам прекрасно хватит Манхэттенского расстояния, ну вот этого.
Ну, знаете, вот это вот, Манхэттенское расстояние, допустим, п1, п2, оно пусть будет равно, допустим, модуль х1-х2 плюс модуль игрок 1-игрок 2, вот здесь вам этого просто вот так вот хватит.
Главное, что не чайте модуль сами только по одной координации.
Да, да, да.
Да, да, да, помните, если вы возьмете расстояние только по иксу, то вы нагнетесь на какой-нибудь вертикальный рипвал.
Это зачем?
Нет, смотрите, когда вы пишете компаратор, вы сравниваете две точки, кто правее, да, что вы делаете, вы делаете векторное произведение.
И вот выясняется, что совпало.
Кого вы выбираете?
Надо выбрать того, кто дальше.
Ну вот оказывается, что можно оптимизировать константу и сказать, что дальше тот, кто дальше по Манхэттенскому расстоянию.
То есть, это вас просто...
То есть, помните, что нельзя писать только по иксу или только по игроку, а вот по обоим вполне пожалуйста.
Ну и модули, конечно, не забывайте.
А то тоже подляночки будут, как вы понимаете.
Вот.
Вот такая вот красота у нас получается.
Красивая.
Вот.
Такая вот красота.
Это...
Ну, соответственно, это называется метод заворачивания подарка.
Это называется алгоритм Джадвиса.
И его асимптотика О от...
Ну, здесь вот надо уточнить.
То есть, лучше вот максимально точно сказать, что ее асимптотика этого алгоритма О от NH.
Где H это реальный размер выпуклой оболочки.
Да, здесь важно сделать эту уголоку, потому что, ну...
То есть, понятно, что в худшем случае, конечно, это квадрат, если все точки лежат на выпуклой оболочке.
Ну вот, но если окажется, что там выпуклая оболочка стоит из 10 точек, то, в принципе, этот алгоритм вам за 10-е эти точки найдет.
То есть, он очень удобен.
То есть, удобен в том плане, что мелкую выпуклую оболочку он найдет быстро.
Ну вот, не мелкую, не быстро.
Но чем он еще приятен?
Он на самом деле приятен тем, что, по большому счету, он на самом деле фактически лишь иллюстрация,
может быть, более общей концепции, как можно искать выпуклую оболочку ограниченного множества любого.
Вот смотрите, давайте рассмотрим какой-нибудь более сложный пример.
Вот рассмотрим более сложный пример.
Вот, допустим, я хочу найти выпуклую оболочку N кругов.
И чтоб совсем было весело, круги разного радиуса.
Потому что, знаете, я встречал две задачи, на самом деле.
Задача, когда радиус одинаковый и задача, когда радиус разный.
Сложность принципиальная.
Да, то есть, код принципиально разный.
Кажется, на отборе волкоша был.
Ну, и там тоже.
Ну, это очень старые боя, на самом деле.
Я, по-моему, такую задачу, вообще, я варенье на старклюськах когда-то решал.
Да, N тысячи, естественно.
А, ладно.
Там 50.
А, ну, пожалуйста.
Ну да-да-да, классическая подлянка.
50 равно 20, пусть они там напишут в переборе.
Да-да-да.
Ну вот, так, ну давайте я вот еще.
Нарисую какую-нибудь.
Так, смотри.
Вот еще.
Итак, как решать, как искать такую выпуклую оболочку?
Ну, на самом деле, идея, в общем-то, та же.
То есть, по большому счету.
Давайте начнем с того, что нарисуем.
Ну, фактически, чем мы занимаемся?
Нарисуем касательные, по сути.
То есть, по сути, как устроена выпуклая оболочка?
То есть, мы говорим так.
Мы проводим все, там, 2P касательных.
Ну, в смысле, понятно, в вещественном смысле все.
От 0 до 2P, да?
И вот, то есть, находим эти касательные, да?
То есть, находим эти касательные.
На каждой касательной, фактически, находится какая-то вот такая.
Там находится хотя бы одна точка или несколько точек.
И мы там, отрезок, который покрывает все эти точки,
собственно, добавляем выпуклую оболочку, и так получается граница.
Ровное это мы проделаем здесь, смотрите.
То есть, ну, прижимаем касательную.
Вот, в данном случае, она прижалась к одной точке, да?
Теперь, давайте ее вращать.
То есть, теперь заметимся, когда мы ее вращаем,
конечно, точка касания.
То есть, некоторое время мы касаемся той же окружности,
но сама точка, конечно, сдвигается.
Так, аккуратненько, да?
До какого момента она сдвигается?
Ну, сдвигается она, конечно же, до того момента,
пока эта касательная не наткнется еще на одну окружность.
Смотрите, вот такая.
И тут, бах-бах, наткнулись.
Ну, тут мы, естественно, вынуждены заключить,
что весь этот отрезок тоже граница выпуклой оболочки.
Видите, да?
Теперь.
То есть, ну, теперь у нас да.
То есть, опорная окружность так сказать, вот эта.
Теперь, когда мы начинаем вращать,
мы тут начинаем рисовать какие-то касательные вот эти вот.
Вот, да?
И видим, что точечка у нас движется, движется, движется, движется.
Ну, до, видимо, вот этой касательной.
То есть, как найти эту точку?
То есть, да, очень просто.
То есть, ну как бы в чем задача?
Надо найти, действительно, самую правую касательную.
То есть, для каждой окружности надо найти ее там эти оба,
правые, общие касательные, с другими
и выбрите из них самую правую. Понимаете, да? Вот. Ну и так и получается, видите?
То есть абсолютно тот же самый метод. Обратите на это внимание. Вот так вот получается.
Потом вот идем вот как-то вот так, вот там. И так далее, и так далее. Вот.
То есть видим, да? То есть мы в кладболочке здесь, конечно, тоже немногоугольник.
Это такой криволинейный многоугольник, где стороны бывают как отрезками, так и дугами.
Вот. Да, бывает.
Чего?
Гладенький.
Ну, как гладенький?
Ну не совсем гладенький, знаете, тут с дифференцией.
Да, ну хотя нет, да, с первой производной тут адекватно.
Вторую не гарантирую, но вот туда.
Ну это уже, да, ой.
Ой, гладкие.
Ну вот. Ну вот как-то так это выглядит.
То есть в принципе вот уже так можно идти. В принципе это, на самом деле, с точки зрения глобальной математики, это общий такой пример.
То есть вы просто вращаете касательную, да, то есть вращаете касательную, и для каждого угла находите, собственно, точку или вот там, отрезок касания.
И, собственно, набор этих точек и отрезков, то есть объединения, и будет вам давать, по сути, границу в кладболочке.
Ну, опять же, это, конечно, работает, если множество ограничено, понимаете.
А эта задача решается на счастье в этом?
Мне неизвестно.
Вполне вероятно.
Но есть, конечно, оговорка, что если радиусы равны, то она быстрее решается.
Да, там неожиданно смешно. Это смешное решение.
Действительно получается.
Но это уже другая письма.
Ну и тем более, что нам понадобится немножко другой алгоритм для этого.
Но, по крайней мере, вот такой метод пользуется.
Потому что, как минимум, полезно помнить, что, на самом деле, вот выпукла оболочка, действительно, рождается вот из таких вот касательных.
Ну, собственно говоря, с вращением касательных, в общем-то, мы еще с вами обязательно столкнемся, может быть, даже сегодня.
Вот.
Ну вот, полезно помнить, что джарвис, конечно, то есть, иногда работает.
То есть, теоретически это все работает, может работать и для каких-нибудь эллипсов там, или там, ну и вообще, для чему угодно, чему вы можете проводить касательные.
Вот.
А если вернуться теперь к N точкам, то, действительно, высягает такой интересный вопрос.
А можно ли решать задачу быстрее, чем за квадрат?
Можно.
Ну вот, оказывается, можно.
Потому что, можно на это все глянуть с немножко другой колокольни.
Итак.
Значит, Джилл был у нас алгоритм за N.
Ну ладно, колокольни тут бывают, кстати, самые разные.
Вот.
И получается примерно следующее.
Смотрите.
Значит, смотрите.
То есть, тут мы говорим следующее.
У Жени были у нас N точки.
И вот была у нас опять самая нижняя.
И среди всех нижних там самая левая.
Вот.
И тут мы говорим, ладно, что-то многовато нарисовал, но ладно.
Так.
Теперь мы говорим следующее.
Заметим, то есть теперь вот немножко по-другому.
Заметим, что если я приведу теперь какой-нибудь лучший в самую правую и в самую левую точку относительно этой точки, да?
Вот так вот, да?
То есть, если я приведу теперь какой-нибудь лучший в самую правую и в самую левую точку относительно этой точки, да?
Вот так вот, да?
То я замечу, что внутри этого угла теперь лежит все.
То есть, все точки лежат в каком-то угле менее 180 градусов.
Это означает, что с точки зрения этого угла точки можно реально сравнивать по принципу кто левее, кто правее.
Правда?
Да, мы раньше уже этим пользовались.
То есть, если это тем, чтобы найти самую правую, то теперь мы пойдем дальше и скажем, а давайте-ка мы эти точки отсортируем.
Ну так, чтобы они шли справа налево.
В науке их называется отсортируем по полярному углу.
Да, но это страшное заклинание.
Я не знаю, я помню, когда я первый раз его слышал, как я потом понял, оно меня просто выбивало в осадок.
То есть вроде понятно о чем, но не особо.
Суть в том, что давайте их упорядочим по принципу, чтобы они шли справа налево с точки зрения этой точки.
То есть сначала идет эта точка, потом вот эта, потом вот эта, потом вот эта, потом вот эта, потом вот эта, потом вот эта, потом вот эта и так далее.
Ну в принципе понятно, да?
Просто зачем мы это делаем?
Делаем это вот зачем.
Вот зачем. Мы понимаем, что конечно не все эти точки будут в выпуклой оболочке, но те, кто будут, они в общем-то ровно в этом порядке справа налево относительно этой точки идти заведомо будут.
И поэтому возникает действительно следующая идея.
А давайте теперь пытаться добавлять точки по одной и строить текущую выпуклую оболочку.
Ну то есть некоторое время многоугольник будет честно выпуклый, тут в общем-то ничего интересного не будет.
То есть пока мы идем справа налево, действительно, пока у нас тут все загибы идут строго влево, все в порядке, потому что финально этот загиб всегда будет влево.
Ну потому что легко заметить, что если относительно точки мы шли вправо, то тут два варианта.
Если мы возьмем точку, которая находится левее, то соответственно и тут загиб относительно этой прямой сюда будет тоже левее.
Видим, да?
Но в какой-то момент впервые может возникнуть такая ситуация, допустим, вот допустим тут она возникла, давай точку уберем, что поворот пошел вправо.
Ну в принципе что означает, что у нас получается следующее, у нас была какая-то выпуклая такая штука, мы попытались добавить одну точку.
Но заметим тогда следующее, что если загиб произошел вправо, это означает, что, ну учитывая, что все точки идут в таком порядке, это означает только одно, что эта точка на самом деле внутри вот этого треугольника лежит.
И поэтому идея оказывается простая, давайте просто эту точечку из многоугольника ударим, а эту давай.
Ну вот, ну и здесь нам повезло, видим, что теперь у нас многоугольник получился вот такой красивый, то есть теперь тут вот этот поворот все еще остался влево, так что все в порядке.
Но конечно, так может, ну вот, может не фортануть, вот например, вот сейчас мы видим, например поворот направо, это значит эту точку выкидываем, но видим что у нас теперь вот этот поворот стал направо, что это значит, это значит, что мы эту точку тоже выкидываем, теперьgehen поворот налево,
то есть точек может выкинуться несколько, но заметим, что, когда мы выкидываем точку, мы расписываемся, что она лежит строго внутри треугольника из трех других точек.
Ну или где-то там вот на каких-то отрезках еще может быть, если не подлежат нам.
Что это значит?
Отлично не выкладывается.
Да, то есть на хранице выкладывающей она не лежит.
Ну или вершина выкладывающей она не является, значит ты ее может действительно выкинуть, ничего не поможешь.
Вот.
Соответственно.
И более того, на самом деле у нас получается каждый момент времени вот такой многоугольник,
внутри которого все точки, пока я имею в виду этого момента, все равно лежат.
Вот.
Но в каком-то этом мы вот добиваемся того, что он будет.
То есть получается, что действительно в каждый момент времени, когда мы заканчиваем это выкидывание точек,
мы убеждаемся, что мы нашли выпуклую оболочку, по крайней мере, вот досюда точно.
Ну и все, что нам остается, это просто проделать это до конца.
То есть по сути мы замечаем, что вот этот многоугольник, он, что точечки тут лежат просто,
что эти точки практически образуют стек.
Вот очень удобно это так воспринимать.
Единственная проблема, что в этом стеке надо смотреть не на последние элементы, а на два последних элемента.
Но это уже есть, но это уже достаточно просто.
Вот.
Но сам по себе стек говорит о том, что сама по себе, то есть после сортировки сама по себе эта процедура работает за линейное время.
Неплохо так, правда?
Просто за линейное время.
То есть получается формально, это алгоритм.
Да, алгоритм называется алгоритм Грехема.
И он работает за О от N log N.
Но по факту надо помнить, что N log N здесь чисто из-за того, что вам нужно сортировать точки.
Если вы умеете сортировать точки по полярному углу быстрее, чем за N log N, то и выпуклую оболочку вы найдете быстрее.
Вот.
Ну правда, в этом смысле задача тут в некотором смысле эквивалентная.
Потому что если вы умеете искать выпуклую оболочку за N log N, то скорее всего вы сортировать быстрее, чем за N log N умеете.
Ну вот, ну как минимум, потому что вообще задача сортировки сводится к поиску выпуклой оболочки.
Ну вот как просто вот ситуация.
Вам нужно сортировать числа, допустим, x1, x2 и так далее, xn.
Как их сортировать? Да очень просто.
Рассмотрим точки x1 с x1 в квадрате.
Там вот x2, x2 в квадрате, да.
И так далее.
Ну то есть с точки зрения графика просто посадим вот на такую все параболу.
То есть они все будут лежать на выпуклой оболочке, да.
Единственное только вопрос в каком порядке.
Но если вы выпуклую оболочку умеете искать быстрее, чем за N log N, то вот вам и сортировка.
Так что вот такая красота.
Так что да, то есть на самом деле задача может быть примерно одинаковой по сложности.
Вот, но правда да.
Но когда вы сортируете числа, ведь известно же, что целые числа, укладывающиеся в битву в машинное слово,
как известно, наука умеет сортировать за N log log N.
Да, мы не проходили этот алгоритм почему-то, да.
И слава богу, наверное.
Ну в 2015 году вот такой алгоритм вышел.
N log log N.
Да, как и странно, всем точка длины машинного слова не зависит.
N log log N это же дерево НДБОС.
Ну и оно тоже.
Не-не-не, стоп.
Дерево НДБОС это не N log log N.
Это дерево НДБОС.
Там N log машинного слова.
Увы.
А там был именно N log log N.
Ну естественно тоже предположение, что там условно это N умещается в машинное слово, естественно.
Правда, как и там все, что вы сортируете.
То есть не все так просто.
Но вот, тем не менее.
Ну да, еще тот самый, красивый, N log log N.
Ну да.
Но в принципе, на самом деле, тут еще конечно проблема, что надо сортировать как-то по полярному углу.
Но если хочется как бы свести задачу более простой сортировки.
Вот видите, мне вот когда-то ВЛПШ-АКОНОВИЧУССО, мне вот сильно помогло.
Потому что я не очень понимал, что такое сортировка.
Поэтому мне была понятна следующая модификация этого алгоритма.
Называется алгоритм Грэхэма Эндрю.
Эндрю это фамилия.
Это фамилия.
Это фамилия.
Это фамилия.
Это фамилия.
Это фамилия.
Это фамилия.
Это фамилия.
Это фамилия.
Это фамилия.
Это фамилия.
Это фамилия.
А не то, что вы подумали.
Так что я думаю, что это Андрей Сергеевич при чем.
Вот.
Ну и лопатин тоже на всякий случай.
Так.
Так.
Ну вот.
Идея на этот раз такая.
Так смотрите, что такое группа лополочек.
Так, вот у нее есть самая левая точка.
Ну или там отрезок.
И самая правая точка.
И выпуклая оболочка делится на две части.
Именно части.
Нижнюю часть и верхнюю часть.
Да, я иногда буду, наверное, оговариваться и говорить, что это половина.
Но можно упасть и считать, что это реально половина.
Потому что тут точек может быть сильно меньше, чем тут.
Равно как и наоборот.
Вот.
И теперь идея.
Как найти нижнюю часть выпуклой оболочки.
Выпуклой оболочки.
Как это сделать?
Точно так же.
Так же да не так же.
Сортируем по Иксу.
Да, мы тупо сортируем точки по Иксу.
Да, еще по Иксу это легко.
Потому что если точки до миллиарда, вы их можете сортировать за Н плюс корень из миллиарда.
Ну под счетом.
Двух уровней вот, да?
Все не делали так?
Мы это все делали, но кажется ни разу не писали.
Ну да.
Скорее всего обычно это и не нужно, да.
Слушай, что там, кто-то вам, вряд ли кто-то будет упихивать вас в таксовом решении, да.
Что на самом деле, да, все правильно просто выпуклой оболочку ищите за Н.
Потому что вот эта сортировка якобы работает быстрее, чем за Н влоге.
Вся эта философский вопрос.
Ну ладно.
Нет, хотя, кстати, интересно попробовать.
Может объектор задачи хоть будет действительно помогать.
Ну мало ли там, какие-нибудь.
Найдутся какие-нибудь там любители.
Напишем кому-нибудь задачу.
А потом потребуем того, чтобы ее уминали обеими ногами.
Вот.
Ну и другое.
Ладно.
Допустим, отсектировали по Иксу как-нибудь.
И тогда оказывается, что для поиска нижней выплодолосика работает буквально тот же механизм.
Просто за счет того, что вы знаете, что эти точки будут идти по любому слева направо и не как окромя.
Правда?
То есть прям так и делаем.
Ну добавляем.
Там вот так вот там что-то убираем.
Тут убираем.
Там тут убираем.
Это вот берем и тут просто вот это начинаем там уничтожать.
Нет, это мы не уничтожаем.
Это живет.
Так ладно, что-то я пропустил, но суть, я думаю, понятна.
То есть вот оказывается такое.
Если вам не нравится сортировать по полярному углу, просто сортируйте по Иксу и будет радость.
Тем более, что этот метод позволяет вам найти, то есть некоторые задачи вам нужны не вся выплодолочка, а только ее нижняя часть.
Вот.
То есть получается вот такой метод Грэфово-Эндрю, который позволяет вам сортировать не по полярному углу, а по Иксу.
Преимущество, ну смотрите, с одной стороны, преимущество в том, что когда вы будете сортировать за НЛОГН, то окажется, что в компараторе у вас не будет всяких умножений типа векторного произведения.
А будет сравнение только по Иксу.
То есть это правда может, это правда скомпенсируется тем, что вам придется прибираться по вершинам, потом за ОАТН два раза.
Для низа и для верха.
Ну вот, мне сейчас констант. То есть понятно, что, конечно, от этой копипасты легко избавиться, повернувши картинку на 180 градусов, конечно, да.
Ну вот, но это уже другое.
Вот. Но, с точки зрения константа, конечно, все равно важно, то есть получается там где-то там на куче умножений оптимизировалась та часть, которая работала за НЛОГН.
Да, чуть дольше теперь работает то, что за ОАТН, но по константе это все равно должно работать лучше.
Ну, пока имеется таких соображений, ну в реальности, конечно, там может зависеть.
Хотя делаем, казалось бы, хотя, ну вот, делаем, казалось бы, буквально то же самое.
Вот. Так что, да, есть вот, конечно, такой алгоритм.
То, что вот очень приятно.
Здесь, конечно, ну, нельзя, конечно, забыть о том, что есть еще.
Есть, конечно, еще такой алгоритм, который основан на подходе разделяй и властвуй.
Который вам предельно честно скажет.
Который вам предельно честно скажет.
Значит, смотрите, работаем по методу разделяй и властвуй.
А именно. То есть вот у нас есть, допустим, N точка.
Как найти выпуклую оболочку?
Значит, просто разделим эти точки на два множества.
Я нарисую так, хотя на самом деле произвольным образом разделим.
И говорим. Отлично. Давайте найдем выпуклую оболочку вот этого множества.
И найдем выпуклую оболочку вот этого множества.
И теперь нужно отсекасаться от ногоугольника, по сути.
Ну, с одной стороны, да, но с другой стороны, нас сейчас за линию строим.
То есть выплыву оболочку по-любому, за млогом строим.
И принципиально быстрее у нас получиться не должно.
Обратите внимание, да? Вот.
Поэтому теперь нам нужно, теперь у нас фактически задача такая.
Данные два выпуклых ногоугольника.
В принципе, кстати, может и пересекаются, мы не знаем.
Вот давайте я тут даже что-нибудь пересекающееся нарисую.
Вот.
И теперь у нас задачка.
Каким-то мистическим образом это пересечь.
То есть не пересечь, а наоборот.
Объединить, то есть взять выпуклую оболочку, объединить этих двух ногоугольников.
А может лучше мы будем так зелить, чтобы они не перескались?
Кажется, это может сильно усложнять задачу.
Что ж там?
Может лучше мы будем зелить точку так, чтобы они точно не перескались?
Ну, в принципе можно, да.
Один раз просто все время фиксуй, потом всегда будем.
Да, но на самом деле тот метод, который я сейчас хочу предложить, он на самом деле более-менее попарападуем.
Потому что этот метод будет основан просто на том же заворачивании подарка, который был у нас.
А, или да.
Проведем.
Ну, то есть по сути мы будем вращать касательные к ногоугольникам.
Параллельно вращать и в каждый момент времени выбирать ту, которая правее.
Вот.
То есть смотрите, то есть как-то будет примерно работать.
Работа будет примерно так.
Проведем. Ну, во-первых, начнем с того, что проведем самую нижнюю касательную.
Вот она, да.
То есть вот эта коризонтальная, которая вверх.
И выберем какая из этих точек там ниже всех.
Но в любом случае, смотрите, то есть в ответ мы добавляем, конечно, вот эту точку, да.
Но у нас есть как бы два указателя.
То есть у нас есть два указателя, которые говорят, где у нас сейчас касательная опирается для одного ногоугольника и для другого.
Вот, понимаете, да?
Теперь, значит, теперь у нас есть два указателя.
Теперь, господа, значит, вращаем барабан.
Ну, с точки зрения компьютера мы просто выясняем, на какой угол нужно повернуть, чтобы действительно опорная точка у хотя бы одного из ногоугольников поменялась.
Как это сделать?
Ну, в данном случае очень просто.
Вот у нас есть следующее ребро одного, следующее второго.
Просто по векторовому произведению понимаем, что следующее будет вот это.
Отлично.
Тогда получается, что опора у нас теперь переходит с этой точки на эту.
Но теперь возникает вопрос.
А где у нас выпуклая оболочка находится?
Ну, тут мы в данном случае замечаем, что эта точка левее этого ребра по-любому находится.
Поэтому эту точку мы добавлять в выпуклую оболочку не стремимся.
Вот.
Вот.
То есть пока у нас эта точка...
Ну, точнее так.
Вот эта точка даже так.
Она левее вот этой точки с точки зрения вот этой касательной.
Понимаете, да?
Ну, в данном случае касательной.
То есть она левее вот этого ребра.
Итак, вращаем дальше.
Ну, вращаем дальше.
Ну вот.
Что у нас тут будет следующее?
То есть мы заметим, что когда мы тут вращаем касательную, то мы вращаем касательный ток многоугольника.
Поэтому когда мы вращаем, нам плевать, что касательная налетела на эту точку.
Вращаем, вращаем.
И наконец выясняем, что у нас это получается, что сейчас мы сравниваем эти две касательные.
И тут мы выясняем что обратно тут вот этот указатель сдвигается.
И выясняется что вторая точка левее.
вторая точка левее. Получается у нас тут точка касания поменялась, ну вот эти точки у нас находятся на нужной нам границе.
Поэтому мы получаем, что вот это ребро оказывается на вытклу оболочки у нас целиком лежит. Вот такая вот красота получается.
Так, нет, пока тут ничего не происходит. Теперь дальше, ну вращаем дальше. Теперь переходит вот этот вот, то есть вот эта вот штука происходит, но она все еще оказывается действительно левее этой точки, поэтому эта точка у нас пока в вытклу оболочку не попадает.
Понимаете, да? Вот. Что у нас теперь? Дальше у нас передвигаемся сюда, понимаем, что эта точка попадает на вытклу оболочку, потому что она вот правее этой, поэтому мы ее тут добавляем.
Теперь, вот теперь происходит интересное. Вот, потому что мы теперь тут поворачиваем, поворачиваем. Ну, значит так. Ну вот. Ну, значит и так у нас происходит сейчас, смотрите.
Сначала мы поворачиваем, то есть поворачиваем, значит соответственно, да, вот этой касательной. И пока видим, что ничего не происходит. Пока, видите? Пока ничего не происходит, потому что эта точка все еще правее, все в порядке.
Вот. Но как бы в следующий раз, ну в следующий раз мы тут будем поворачивать, и дойдет ситуация вот до примерно вот этой ситуации. Вот.
И мы обнаружим, что в случае вот этой касательной, то есть уже вот эта точка становится правее.
Поэтому мы теперь вынуждены сказать, что это точка следующей, и вот ровно тут мы тут неожиданно начинаем поворачивать, но при этом два указателя у нас все еще вот на эти точки, ну вот, точнее смотрим, ну, то есть этот указатель сдвинулся, этот указатель остался вот так вот.
Но вытклая оболочка теперь находится на этой точке. Вот. Ну, собственно и так далее. Вот. Поехали в принципе.
Как мы сейчас поначалу будем вести между двумя разными, ну точками разного уголика?
Нет, а нам даже по барабану. Мы просто обнаружили, что, ну, то есть мы просто в какой, то есть на самом деле так, мы даже нам по барабану, собственно, точка откуда взялась отсюда, там, из одного уголика или из другого, нам самое главное следующее, что в каждый опорный момент, да, когда меняется указатель, мы смотрим, какая из этих точек правее.
Иногда она совпадает с предыдущей, тогда еще делать не надо. А иногда она не совпадает. И тогда, значит, надо новую точку, вытклую оболочку добавить.
Причем вот в этих случаях оказывалось, что эта точка находится в одном и том же многоугольнике. Здесь оказалось шум разных.
Вот. Но дело на самом деле даже не в этом. Ну, в принципе, там вообще могут быть случаи, когда некоторые вершины этих многоугольников вообще совпадают иногда.
Но это не суть. Вот. То есть вот такие вот повороты у нас происходят, и в итоге, собственно, мы там, да, объединяем. То есть вот таким вот образом тоже можно это теоретически объединять.
Это, конечно, не самый с точки зрения практики веселый способ, но, тем не менее, метод разделяет властвовое имя лицо.
Можно еще раз подсказать, в каком порядке мы делаем что-то?
Чего? В каком порядке поворачиваем?
Ну, идея очень проста. То есть, еще раз. Ну, то есть, глобально мы занимаемся тем, что, начиная с вот этого направления, мы поворачиваем касательные на угол 2p.
И в каждый момент времени смотрим, на какие точки в одном и другом многоугольнике эти касательные опираются.
Мы их одновременно поворачиваем.
Да. Мы поворачиваем одновременно и крутим с одной и той же скоростью.
И каждую точку, то есть, если какая-то лицшина в какой-то момент оказалась лежать на правой касательности, значит, она должна быть добавлена в выпускную оболочку.
Вот тут такая идея.
Вот. Ну, собственно, вот в чем дело.
Вот. То есть, можно, ну, там, можно так объединять или тут действительно какие-то там касательные искать.
Но, конечно, даже вот в этом случае имеет смысл действительно это общую касательную искать робота таким образом.
Ну, можно, конечно, мечтать о том, что если вы это не за O от N делаете, за O от логарифма, то у вас все получится.
Но тогда для этого вам придется каким-то образом это еще поясу сортировать, как по-любому, я благодарен.
Но, тем не менее, есть такой алгоритм, то есть, по крайней мере, на основе методы разделяя и властвуя.
Это называется, ну, вот, ну, это алгоритм Киркпатрика называется.
Вот.
Тут, тут, тут, тот самый.
Ну, не то чтобы я бы проверял, но есть подозрение, что вряд ли там по Киркпатрика.
Хотя мало ли там.
Как это? Не было у нас два Киркпатрика.
У него были интересы такие, смешанные, и геометрия, и всякие романы.
Ну, а, как видите, геометрия и сортировка, в общем-то, не то чтобы не связаны.
Там хорошие шоу на эту тему есть.
Вот.
Ну, а что еще есть?
Ну, на самом деле, почему я упоминаю еще этот алгоритм?
То есть, я не знаю, честно, доживем ли до него или нет.
Но, на самом деле, есть алгоритм, который ищет выпукло оболочку в 3D.
Там классическая заворачивание-подарка будет за квадрат работать тоже.
Вот.
Но, можно за M-O-G, но все подобные методы типа сортировки по естественным причинам вылетают.
Но зато разделяя властву и эти два многокрайки как-то красивым образом пленочкой обернуть там можно.
Ну, честно скажу, достаточно убойно понять, действительно, что там происходит, но алгоритм есть.
Там теоретически есть даже статья, в которой там дан код, который, между прочим, очень минималистично выглядит, на самом деле.
Вот.
Но это еще даже не все, что мы хотим тут, значит, поискать поисков.
Значит, вы тут.
То есть, 2D.
Потому что, как бы, пока, у нас есть два способа.
То есть, мы ищем выпукло оболочку либо за M-O-G или M-O-G.
Либо за M-H.
Вот.
на NH Jarvis, вот, ну как бы, то есть получается пока как-будто на уровне, там, мы заранее,
вот, вот, хочется выбирать лучший из них, как можно выбирать лучший из них?
Можно начать делать Jarvis, или ты будешь логерить по шагу, или...
Да, то есть когда, да, да, помним, да, что, на самом деле проблема заключается, конечно,
у нас, да, в том, что мы заранее не знаем размер глубокой оболочки, но можно сказать,
что давайте запустим Jarvis, а если за алгоритмом интеракции не получилось,
ну, значит, тогда плюем на все и ищем. Да, получится алгоритм, действительно,
за n лог, это за минимум из аша и лога. Но, оказывается, это можно еще попытаться
мажорировать. Потому что, да, сейчас мы попробуем неожиданность 4, и, значит,
и у нас сейчас будет еще один алгоритм. Вот, это будет алгоритм чена,
и он сейчас будет искать рубку оболочку за o от n лог аш. Ну, как видите, он, конечно,
если аш порядка n, он, конечно, особо не поможет, но если аш там меньше,
то, глядишь, он все-таки найдет еще быстрее. Значит, как же он будет работать?
Работать он будет неожиданно простым образом. Значит, смотрите, давайте мы с вами
предположим, значит, предположим, что мы знаем заранее аш. Вот, предположим,
что мы знаем, что у нас выпукла оболочка имеет размер аш. Вот, с небес по факсу
нам прислали. Тогда как мы будем это работать? Значит, работать будем в следующем
образом. Значит, вот у нас есть эти точки. Разобьем эти точки на грубки абсолютно
случайным образом, никаких сортировок, по аш. Вот, по аш, по аш, по аш. Ну, конечно,
если мы рандомно будем разбивать, то вполне вероятно, что выпуклая оболочка этих
точек будут пересекаться. Вот тут будет аш, и тут чуть-чуть аш. Что мы теперь сделаем?
А давайте найдем выпуклую оболочку в каждом из этих точек. Прямо чем-нибудь вон те.
Вот эти выпуклые оболочки могут пересекаться. Вполне. Вполне могут пересекаться, тут все
возможно. Вот, собственно, пересечение. Да, вот. Вот так, вот так. Вот. Всем заметим,
за сколько мы это сделали? Как бы у нас было n поделить на аш частей, каждую мы обработали
за аш лог аш. То есть получилось n лог аш, это нас устраивает. Что мы теперь будем делать?
А теперь давайте попробуем объединить. А теперь давайте попробуем найти выпуклую
оболочку этих n поделить на аш выпуклой с многоугольных. Как вы уже догадываетесь,
это делается абсолютно идентично тому, что мы сейчас сделали с двумя многоугольниками.
Понимаете, да? А мы сразу начинаем, или мы разавим для группы, или мы так же?
Чего-чего? Не, никаких рекурсий. Не, никаких рекурсий. Именно в честную за аш лог аш.
Нет, в смысле, как мы будем их объединять? Сразу все, или мы их разавим для группы?
А, сразу все. Да, сразу все, это важно. Да, просто дело в том, что... Да, кажется, что это
очень долго, но дело в том, что, смотрите, каждую следующую точку мы ищем за n поделить на аш,
правда? Ну, то есть у нас получается метод n поделить на аш. Чего аш лог аш?
Что? Нет, ну, я ее не ищу. Я вращаю эту касательную, поэтому у меня получается метод
n поделить на аш указателей. На чем? На чем бы то сразу? Пожалуйста, то же самое.
Ищем нижнюю касательную каждому логу угольнику. Каждому логу угольнику за аш мы ее найдем.
Вот она, да? Там находим, понятно, самую правую точку относить на эту, вот она.
Теперь начинаем вращать. Теперь думаем, куда, как сдвинется указатель теперь, да?
Ну, отлично. Так, находим все вот эти направления, находим из этих направлений самая правая.
Там какой, какой из них там будет самая правая? Из направлений самая правая.
Ну да, да. Вот это направление, вот это направление, вот это, вот это. В данном случае вот это.
И сдвигаем. Теперь, то есть, опорные точки, теперь вот это, это, это, это и теперь вот это.
Из этих точек самая правая, ну с точки зрения нашего направления вот этого вот это оказывается,
поэтому мы ее тоже вот в кладовочку добавляем. Что будет теперь?
Какой указатель мы сдвинем дальше?
Сим, а что если у нас была точка в каком-то исследовании многоугольников?
Вот, вот, вот, а если я тебя проявлю, на следующем шаге мы такой случай сейчас рассмотрим.
Потому что обратили, нет, в смысле вниз.
Смотрите, теперь, нет, эти точки, ну эта точка, точка лежала в кладовике, ой, что-то я это проигнорировал, но ладно.
А, ну в общем по барабану, давайте. У нас вот тоже указатель был.
Итак, теперь думаем.
Теперь, какое следующее направление?
Теперь у нас самая правая.
Так, если я проявлю, то по-моему вот это получается, да?
Ну потому что вот это, вот это, вот это, вот это и вот это. Это самая правая.
Отлично. То есть теперь у нас касательная текущая, теперь...
Теперь у нас текущая касательная, она теперь вот это, но заметим, что,
Но какая из этих точек, вот, опорных точек, теперь самая правая относительная этой касательной?
Вот эта. Поэтому еще нового мы не добавляем.
Да, то есть видите, касательная тут, видите, чуть-чуть повернулась, да, то есть, ну, вот такая.
Ну вот, ну и так далее.
То есть каждую следующую мы, получается, находим за n поделить на h.
Открывайте меня.
Это нормально, что так?
Мы не нашли ни одной новой точки.
Мы сделали n на h операции.
Угу. Ай-я-я.
Как говорится, как плохо-то, да?
Ну я просто сейчас нашел другую версию.
Так, какую?
Которая звучит так.
Из данной точки найдем касательные, как все, по всем негугольникам.
Каждому за логаж, сегодня наш негугольник.
Выделим самую выгодную касательную.
Нет, еще нот. Не, плевать, плевать, плевать.
Работать будет, честно-честно.
Это просто, когда мы перешага наменяли два негугольника,
этот метод был бы такой, честно-честно, был бы лучше,
потому что, ну, мы все вам не позволили пройтись во всем дыше.
Там каждый раз, если касательная была противная,
всем было бы n лог квадрат, вроде бы.
Вот, а здесь нужно либо по-лужему выбирать
следующее минимум за быстро.
То есть, скинуть все университеты,
и что-то в ней искать с изменением.
Теперь просто в сет даже хватит, не знаю.
Мне кажется, сет будет плохо.
Нет, ну, в сет непонятно, потому что, как бы,
в какой-то момент они в сете должны меняться местами.
Ну, конечно, да.
Да, ну, действительно, да.
То есть, в идеале хотелось сказать,
что мы тут действительно за аж шагов найдем.
Но тут, да, проблема в том, что да, за...
Нет, хотя...
Да, к сожалению, суммарное число шагов,
это у нас, к сожалению, все равно там от,
и каждый шаг мы делаем и поделить на аж.
Да.
А ты хочешь сказать следующее, если я позаблю вас?
Да.
На всем, кроме этого, мы будем,
чтобы мы и так знали, что это происходит.
Ну да, так.
Аж?
Лога сна.
Лога сна.
Лога сна.
Лога сна.
Нет, хотя, смотри, нет, на самом деле,
нет, на самом деле, то есть, этим методом
тоже на самом деле можно,
потому что можно применить еще такое заворачивание подарка.
Раз уж мы знаем вот эту точку, да,
раз уж мы ее случайно знаем,
так давайте попробуем,
попробуем провести правую,
ну, попробуем провести из этой точки
правую касательную ко всем ногам.
Но, как ее провести?
А очень просто.
То есть, проводить ее надо по принципу,
что мы говорим, так, то есть,
у каждой точки есть указатель,
и мы его будем двигать вправо до тех пор,
пока это не окажется точкой правого касания.
То есть, вот такая вот.
То есть, такое вот получится.
То есть, вращаем, и получается,
не общую касательную, да,
а вращаем мы, на самом деле, вот,
получается такой угол просмотра, что ли.
То есть, такой точкой вот.
То есть, указатель указывает, где у нас тут точка правого касания,
и тогда этот метод позволяет,
что суммарно эти указатели все равно
двигаются за ОАТ, правда?
Потому что указатели двигаются
только вперед.
Но при этом, на каждом шаге,
мы действительно находим
следующую точку.
И тогда получается, что за сколько
это работает. То есть, получается,
мы делаем аж шагов, потому что мы знаем,
что будет клуб оболочка размера аж.
Каждую мы действительно, буквально, находим
за N поделить на аж, и там еще где-то
отдельно плюс суммарно N.
То есть, получается,
новую часть мы делаем
за, соответственно, ОАТ.
Ну и все.
То есть, вот такой алгоритм, получается,
находит выпуклую оболочку
за N лог аж, если вам
заранее дано аж.
Так, понятна идея?
Это понятно.
Последнюю часть.
Не совсем понятно, почему у нас такая
симпатика вышла.
Ну, потому что, что мы делаем
при каждой точке? Мы ищем правду
касательную путем двигания
указателя.
Причем все устроено так, что указатели
фактически, когда мы тут все вот это
повернем, указатели просто
подвигаются, собственно, по моему угольнику
один раз. Поэтому суммарные
двигания указателей будут работать
за ОАТ суммарами.
А теперь мы говорим, но, как бы,
после того, как мы их сдвинули, мы за N поделить
на аж находим следующую точку.
Как честным перебором.
Вот.
Но сколько раз мы это будем делать?
Мы это будем делать аж раз, потому что размеры
по оболочке аж. Поэтому, получается,
вот такая симпатика.
Каждый раз касательно выпускаем из самой правой
точки.
Из текущей точки.
Ну да, то есть, по сути, мы движемся
виртуально по этой выпуклой оболочке
будущей, да?
И в каждый момент времени вот для точки
поддерживания, практически, то есть, да,
немножко другой такой риск. То есть, не сканлайн
вот этих вот, не вращение касательных
таких, а, скажем,
движение точки по выпуклой оболочке
и вращение вот этого вот
касательного угла. Вот так, на самом деле, получается.
Из этой точки во все
угольники, да? Да. То есть, у нас
получается, да. То есть, тоже N поделить
на аж указателей и N поделить на аж
вращающихся вот этих углов обзора
на угольник.
Если так можно выразиться.
Вот.
А стоит только решить маленькую
техническую вещь.
А если нам аж заранее не сказали?
Давайте угадаем.
Но выяснять, что
этого алгоритма есть маленькая приятная вещь.
Вот.
На самом деле, мы за N лог аж
можем либо найти выпуклую
оболочку, либо сказать, что размер
этой выпуклой оболочки больше, чем аж.
Правда? Да. Потому что мы можем сказать, что
если через аж вот этого заворачивать,
то первую фазу мы по-любому за N лог аж
делаем, да?
Ну вот. А вторую мы делаем
за N плюс N поделить
на аж и умножить на итерацию. То есть, если через
аж итерацию мы там, или даже
два аж итерации мы поняли, что
что-то не замыкается,
то есть, мы как бы что-то в первую точку не пришли,
что делать?
Тогда мы говорим, что
все это больше, чем аж.
И тогда идея
возникает следующая.
Так давайте будем потихоньку
это аж увеличивать.
Причем весьма хитерским способом.
Значит, будет, мы давайте попытаемся
решить эту, будем запускать этот
критик. Для аж
равно
сматычка.
Как говорится, два
два в степени два
два в степени два в квадрате
два в степени два в кубе
да, не то, что вы подумали
два в степени два в четвертой
два в степени два в пятой
и так далее. Да, тут будет
два в первой, два в нулевой, вот так.
Сначала была какая-то ссылочка
да, казалось, что это 2 в степени
не два в степени, да, но не, не, не, не, не, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет
суммарная n на, ну логарифм два в степени, два в степени шота это два в степени шота, правда, поэтому n в степени там два в степени ноль плюс два в степени один плюс два в степени два плюс и так далее плюс два в степени k вот, но это фактически o от n на два в степени k, но это соответственно получается o от n лов h получен, вот собственно и все
то есть получается мы просто, то есть мы будем попробовать мелкое h, потом чуть больше, потом еще больше и так далее, только как бы h увеличиваем не в два раза, а получается в квадрат раз, ну то есть это делается с целью того, что как бы каждый шаг мы делаем за n лог h и наша цель просто на каждом шаге увеличивать этот логарифм в два раза, но при этом заметим, что в худшем случае то, что мы
делаем за n лог h не обязан быть два в степени два в степени k, то есть в худшем случае h может оказаться где-то чуть-чуть больше, чем корень из этого два в степени два в степени k, который мы наткнемся, но с точки зрения логарифма это все равно константа, вот, то есть как видим вот такая вот действительно красота у нас получилась
есть ли какие-то вопросы по такому логарифму?
что будет у тебя написать, насколько это реально будет работать?
ну быстро, ну честный ответ не знаю, не пробовал
Андрей с кем-то еще
ну я так скажу
ну по-разному, скорее всего значительного прироста по сравнению с Грэхом и Андреем вряд ли даст, особенно в случае, когда выпукла оболочка очень большая
а если она относительно мелкая, ну может и за n h
ну то есть понимаете, очень сложно сделать так, чтобы логарифм h был значительно меньше, во-первых, логарифма n значительно меньше
и при этом еще и значительно меньше
значительно меньше, чем h
ну да, не, ну как сказать там
если h равно 20, например, то логарифм h вроде чебили
логарифма константа больше, чем h
логарифма константа больше, чем h
да, но тут константа, ну как сказать
ну как сказать там, когда h равно 2 в степени 2 в степени 0, наверное там константа не очень
ну в принципе, да, как считаю, что легче уже написать это джаггеса за 20 h и не париться уже
да, поэтому вот такого
но тем не менее вот логарифм есть
а?
да-да, мы предположим, что h
ну заметим, что если мы сказали, что h такое, оно оказалось меньше, мы не пострадаем
просто чуть раньше 20
поэтому запускаем, предположим, что h равен там 2 в степени 2 в степени 0, то есть 2
ну предположим такое
запустили, и за n h поняли, что ой, оказывается, что там выпукла оболочка явно больше, чем 2
окей, все, убиваем все
значит, зачищаем
ладно, давайте предположим, что 2 не больше, чем 4
что это не больше, чем 4
так, запустили, поняли, что нет, что-то больше, чем 4
ну окей, все, заново делаем
теперь 16
потом там 256
потом 65536
потом там, сколько там, 4 миллиарда дальше константа, не помню, ну и так далее
ну вот, и так далее
ну кстати, не так страшно
в реальных олипиадах ограничениях получается, что в общем-то
в общем-то, за 5 итераций вы в общем-то все сделаете
обратите внимание
а, ну да, кстати, по факту
по факту, не особо
ну да, то есть там
то есть по факту, единственный случай, когда
это вам может реально помочь
прям вот реально помочь
это, ну вот, то есть
это возможно, но это возможно, когда у вас выпукла оболочка не превосходит 256
ну вот, так видите, тут какие числа получается
4, сколько там, 2
4, 16, 256
так что вот может быть вот конкретно
если выпукла оболочка между 16 и 256
то может быть
этот алгоритм как-то поможет
сомнительно, согласен
так что тут, да, то есть практически
алгоритм такой не работает
так что вот, да, то есть
практически алгоритм такой не работает
да, то есть практически алгоритм такой
не очень, но теоретически такой алгоритм действует
так
f, отдельная песня, конечно,
да, f, мечта была бы сказать, что он
конечно синтетически оптимальный
но, конечно, чтобы такого сказать
пока я с Лютой не могу
или может быть, может быть, ну, потому что
стандартное соображение, из которых могли бы это сказать
мы можем сказать, что там, допустим, что
у нас эта выпукла оболочка сводится
допустим, сортировка сводится к выпуклу оболочке, да?
ну вот, то есть понятно, что
если выпукла оболочка размерен, то понятно
что будет там быстрее не получится
потому что сортировка сводится
кто такой вообще оптимальный
с алгоритмом?
ну, то же самое, как помните у нас задача
была?
алгоритм одного параметра?
не, а в домашнем задании была задача
ой, где бы сортировали?
не, помните там, да, сортировать
элементы, но как бы нам еще известно
что они, каждый находится от своего
правильного места на расстоянии более чем k
и там, там, собственно, тоже можно
то есть синтетическая оптимальность
можно было доказать, что есть алгоритм там
за n log k, но при этом можно сказать, что
никакой алгоритм не может работать
быстрее, в худшем случае, быстрее, чем за n log k
да
да, то есть формально, конечно, возникает
ощущение, что может быть две
таких, две таких оценки
на самом деле, оптимальны
там, типа, одна n log k, другая k
log k
но это странно, конечно
вот тут бы тоже была такая мечта
но с другой стороны, пока
это только говорит о том, что
позируется на том, что, допустим, мы знаем
что у нас размер группы оболочки h
тогда возникает вопрос
у вас количество различных ответов вообще есть?
нет, если c, нам еще порядок ваш
нет, ну, в смысле
сколько вариантов ответов в сортировке?
потому что на первом месте может оказаться
каждый из этих элементов n штук, потом на
вместе кто-то из составов с n-1 и так далее
да, здесь то же самое
здесь получается, да, вариантов ответа n
на n-1, на
n-2, на и так далее
на n-h-1
вот, но это там приблизительно
в райе, конечно, но
m в степени h
ну, зависит от того, какая
h на ctn, какая функция там
что? ну, зависит от того, насколько
h на ctn, если a
если h на ctn, то да
если h это какая-то функция
ну, формально, нет, давайте так
правильно сказать так, что это n форториал
поделить там, n-h форториал, да
это у нас, помнится,
это у нас почему-то там укрывали, да
давайте бы затворим
а что такое?
а, сегодня мучили этим
как удачно-то
так, что там n-h
ну и вот
и пригодилось, собственно
n-h в степени
n-h, ну вот
там что-нибудь получится
ну да
ну, что-нибудь получится
вроде на лекции вообще, ну и, по крайней мере
годичной давности
первой, вот как раз доказывали, что
это n в степени h при h
у
умалывает корень из n
а при h умалывает
n в степени 3, там чуть-чуть другая формула
ну да
да, возможно
но не стоит, ну хорошо, ладно
если h относительно там меньше корня
то допустим, это все равно там примерно
n в степени h, но правда сильно нам
это не помогает, потому что
как бы мы говорим, что количество сравнений
каких-то, которые нам придется сделать, оно я бы там
менее чем логарифом
этой штуки, но логарифом этой штуки
к сожалению, h лог n
а не то, что нам хотелось бы
да, ну не знаю
можно конечно
да, можно конечно попытаться
придумать алгоритм, который работает за
максимум из
n и h лог n
нас меньше, чем он
не может вообще работать с алгоритмом
ну почему, если h очень маленькая
ну почему бы не
нам все точки нужны
если h очень большой, то h лог n
будет лучше, чем n
ну смотрите, если h равно n,
то быстрее чем за m лог n не получится
есть такое подозрение
по крайней мере на уровне сравнений
за счет чего-нибудь еще
но кажется, что
идеальный алгоритм тогда
при таком h лог n, он должен работать за n
но честно скажу, я не знаю
если он, то есть лучше известный мне
вот n лог h
может там есть
какие-то
возможно другие методы диаметрии
которые там позволят что-нибудь оказывать
но вот это уже
другая ситуация
так, ладно
есть тут еще какие-то вопросы
что там у нас дальше
ладно
ну конечно
хотя на самом деле да
если мы говорим о каких-то выпуклостях
ой, так
то о чем бы нам тут конечно поговорить
глаза разбегаются
квадро дерево
о нет
нет, я бы про выпуклость говорил
квадро я не обещаю
но без квадро дерево мы не обойдемся
ну там
ну там долго
есть эта, есть там вращающая
ой, ну хотя тут все взаимосвязано
ладно
вот
ладно
раз уж мы до сюда дошли
то конечно
в черт тогда не поговорить о пересечении
по плоскостей
о, это просто классика
диаметрии, из цикла идеи на все понятно
но там почему-то никуда никогда не берется это писать
хотя казалось
почему
вот сел и написал
там сел и за часик написал
вот
ну в общем нам пора
смотрите
вот, ну вот предположим
у нас оказалась задача теперь
надо не для точку выпуклоболочку
найти, а надо
пересечь полуплоскость
ну сразу давайте договоримся
как задается полуплоскость
прямой
направлении
или векторам
ну можно
задавайте
ее направленной прямой
считая что
выпуклоболочка
полуплоскость
это то что слева от нее
как задается направление
направление можно сказать, если прямое сдается двумя точками
то как бы вот пусть у нас есть направляющие объекты, понятно, да, можно так или действительно окажется,
что если у вас есть ax плюс b и x плюс c равно нулю прямая, то можно задать полуплоскость по
принципу x плюс b и x плюс c больше либо равно нуля, ну по сути это будет эквивалент на тому,
что вот вы просто смотрите, что у вас есть нормаль ab, собственно куда она смотрит,
туда и полуплоскость, то есть на множестве на минус будет смотреть другую скорую, да,
ну по-разному можно, но я предпочитаю с двумя точками, конечно, я вообще не особо люблю
это уравнение, хоть оно, конечно, и красивое завязано, итак теперь вот наша задача пересечь,
вот дало n полуплоскостей, мы хотим пересечь, сразу возникает вопрос, вот теперь давайте попробуем
чем может являться пересечение полуплоскостей, ну какие случаи могут быть, заметим, что любой выпуклый
многоугольник, по идее, это не что иное, как пересечение вот такого рода полуплоскостей,
ну сейчас давайте в порядке поступления, на уровне идеи, конечно, вот действительно логично,
бывает в принципе вот такое, что-то такое, это можно сказать бесконечный многоугольник, то есть вот
такая вот какая-нибудь вот такая красота, пора было, это бесконечное количество полуплоскостей,
надо, а у нас конечное, можно приблизить, ну можно приблизить, но n там совсем большой, ну пустая,
но что конечно, надо упомянуть, пересечение полуплоскостей, ну да, пересечение пустого
полуплоскостей получается f квадрат, потому что любая точка лежит в каждой из этих нуля полуплоскостей,
нет, надо мыслить позитивно, каждая точка лежит в каждой из этих нуля полуплоскостей,
вот, поэтому пересечение f квадрата получается, но это логичнее, знаете, потому что должно быть
так, чтобы чем больше было с добавлением новой полуплоскости, множество должно уменьшаться,
поэтому как бы с добавлением первой полуплоскости, как бы оно не должно увеличиваться с пустого множества на целую полуплоскость,
кстати, полуплоскость, да, нет, ну полуплоскость или угол там еще, но это да, допустим, можно считать,
что это там частые случаи вот этого, да, но есть подле, да, но есть самый подлый случай, да, самый подлый случай,
это, конечно, когда все полуплоскости параллели, у вас получается вот такое пересечение.
Вот, красота.
Ну есть что выразить на эту точку там.
Ну да, не считаю выгляждаемых, но это просто самый неприятный, чем он самый неприятный,
он неприятен тем, что у него хранится радость такая несвязная.
Неплохо тогда.
Ну да, потому что заметим, что, конечно, все многоугольники могут, конечно, это все может вырождаться,
поэтому пересечением полуплоскости может быть прямая, может быть прямая, может быть лучик, может быть истинный,
да, отрезок обязательно, ну да, если тут просто что-то порезали.
Ну хипсизола, конечно, точка.
Ну там какая-нибудь вот такое безобразие произошло, например.
Вот, красота.
Благо удачи.
Почему же здесь кто-то не пишет?
Вот. Не знаю, боятся все как-то.
Не, ну тут, конечно, всегда все боятся писать геометрию,
потому что геометрия, она сама по себе, это значит, что заложите на задачу лишние полчаса.
Ну вот, потому что, ну что делать?
Хотя, я помню, хотя кто-то из тренеров еще в школе нас учил,
что если вы просто не боитесь геометрии, умеете ее адекват подписать,
то как бы у вас преимущество перед конкурентами, собственно, на одну задачу.
Потому что в контесте, скорее всего, одна задача на геометрию добудется,
поэтому как бы все не испугаются писать, а вы ее напишете.
Вот. Ну да, в школах Олимпиадов что-то геометрию редко дают.
Ну, в общем, ладно.
Тут иногда, конечно, бывает проблема, что авторы задачи тоже не очень любят геометрию,
потому что это же надо авторские решения писать, самим не замкнуться, тесты адекватные подсунуть.
Ну, тут, конечно, от людей зависит, потому что там придут люди, которые...
А, ну или так.
Не, ну знаете, как-то, понимаете...
Не, ну тут по-разному. Не, ну не совсем.
Понимаете, тут по-разному. Что значит «поможешь», понимаете?
Можно, конечно, давать задачи по плюсу, что это задача людям понравится,
а это задача людям не понравится. Ну, это такое.
Ну, как по мне, с точки зрения соревнования,
как вы делаете на экспортивном компоненте, знаете, там
вам нравятся задачи, не нравятся задачи,
это всё-таки вопрос должен быть второй.
То есть максимум для чего это может быть,
это что вы понимаете, что у вас в команде вот это...
Вот такие задачи мне нравятся больше.
Ну, пока не в том плане, что я их умею решать лучше, писать лучше.
То есть вы тогда в команде это понимаете,
Almost lettering is the sports wording writing that is written and
You will write such and such tasks and you will have your desk.
Если не нравится, это из цикла, потому что на контесте задачи будут объединены для всех.
Если вы придете в полуфинал или финал, вам дадут такую задачу, ну извините.
Если вы не решаете эту задачу, не любите такие задачи, вас обгонят те, кто любит.
Такие задачи, все.
Так что, знаете, любишь, не любишь, это звучит как, знаете, как бы это сказать,
я называю это в футболе, очень люблю бить вот так вот по мячу и не очень люблю давать пас.
То есть как оно такое, ну вот.
То есть тогда либо вас там будут ставить в команде только в такие места и будут давать так,
что вы можете только делать вот так, либо вообще играть не будете.
У вас все равно играет человек, который вот так умеет делать и вот так в случае чего.
А если он умеет делать одновременно замахиваться и только в последнюю секунду,
когда это показывает, что он реально делает, то, собственно, это вообще будет шедевр.
Ну, собственно, вы в этом месте отправляете в запас и начинаете там петь эти вот, собственно,
там добрые песенки эти все.
Вот. Так. Почему я это вспомнил, неважно.
Так.
Вот. Значит, итак.
Значит, как же мы будем искать пересечения полуплоскостей?
Ну, значит, на самом деле есть такой лайцак, который на самом деле позволяет там все вот эти,
вот эти, там вот эти случаи более-менее применить.
Метод называется метод bounding box.
А именно. Ну, смотрите.
Что можно сказать про границу?
Ну, про границу явно можно сказать то, что вот эти точки, которые вот эти всякие вершины и так далее, да?
То есть подозрение, что эти точки имеют какое-то отношение к пересечениям прямых,
которые являются границами полуплоскостей. Правда?
Имеет смысл.
Что?
Имеет смысл.
Вот.
И тогда идея такая еще трое. Глобально тематически где бы такая?
Вот у нас допустим есть какие-то полуплоскости.
Вот.
Но будем говорить, а давайте-ка мы с вами будем рассматривать не все.
Так вот. Ну, давайте прямые. Ну вот.
То есть не всю плоскость будем рассматривать.
Так вот.
Ладно, вот так вот.
Да, что-то давай.
Давайте вот так вот.
Ой, да.
Вот.
А будем рассматривать некую такую некий вот такой большой прямой увольник,
который заведомо содержит все точки пересечения.
Вот.
Вот такая вот у нас есть.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот такая вот у нас будет красота.
А можно нарянуться чуть-чуть?
Да, ярче.
Ну, давай.
Ну, давайте попробуем.
Но у нас не получится.
Так.
Ужас.
Да, да, да.
Только наши маркеры вытирают другое.
Хочешь быть ярче другого маркера, затынь его.
Да, логично.
Так.
Ну ладно, вот это чуть получше.
О.
О.
Блин.
Так хорошо начиналось.
Ну да.
Мне долго мучился тут маркер.
Да.
Ну, давайте вот так.
Так вот, идея такая.
Давайте искать не полное пересечение полуплоскостей,
а пересечение полуплоскостей и вот этого прямого увольника.
Нам это удобно.
Потому что, в принципе, фактически, что такое прямоугольник?
Это еще четыре вот такие полуплоскости.
Это в принципе нас приводит к тому,
что теперь пересечение полуплоскостей точно ограничено.
Вот, понимаете, да?
Но на самом деле теперь достаточно легко будет оценить
реальное пересечение полуплоскостей, оно ограничено или нет.
То есть будет очень просто.
Если оно было ограничено,
то оно кажется просто многоугольником
или там какой-то вон той радостью,
которая и так лежит строго внутри этого прямоугольника
и ничего не меняется.
Ну, потому что мы знаем, что если это что-то ограниченное,
типа вот там многоугольника или там отрезка с точкой,
то это будет какой-то выпуклый многоугольник,
составленный из некоторых точек пересечения некоторых прямых.
Правда?
А все пересечения прямых, напоминаю, у нас уже где-то внутри находятся.
Вот, но если же оказалось это не так, то есть пересечение вот такое,
то тогда у нас с баундинг боксом будут примерно вот такие отношения.
И тогда окажется, что если вы заметите,
что какая-то часть пересечения полуплоскостей
у вас оказывается грамиться баундинг бокса,
значит в этом месте пересечение полуплоскостей выходит на бесконечность.
Вот такая вот примерно идея.
Сейчас можно по вопросу?
А как нам выбрать достаточно...
Ну, например, прикинуть, что там пересечения...
Вот нам заданы какие-то точки, ну, например, они целые, да?
Допустим, все точки целые и не происходит 10-9,
как-то часто на игре не бывает, да?
Тогда где могут лежать пересечения?
Вот, ну пересечения, как вы помните, примерно,
у нас в этих точках есть пересечения,
вот, ну пересечения, как вы помните, примерно,
у нас вычисляются по формуле...
По какой-то вот примерно формуле в духе...
Давайте попробуем.
P1 плюс P2 минус P1
на какое-то векторное произведение,
поделить какое-то векторное произведение.
Там, по-моему, что-то типа P2 минус P1,
там P4 минус P3, если не ошибаюсь,
там P3 минус P1, там P4 минус P3,
или вот что-то в этом роде,
может, там наоборот, я не помню,
сейчас не буду переводить формулу.
Вот, у нас на первом занятии была, вот хорошо.
Вот.
Ну и теперь давайте прикидывать.
Ну вот, что это в худшем случае вообще может быть?
Это мы сейчас хотим оценить на сколько большой прямой уровень?
Да.
Очень-очень.
В худшем случае, не дай мне девичкой вверху.
Ну, в худшем случае, смотрите, да.
Ну, то есть, на самом деле, если измерять длины,
допустим, длины или там что-то по х,
то, ну, видим, что тут, конечно,
P2 минус P1, P2 минус P1,
тут как-то пошлеп-шлепается, да?
То есть, есть так под длином.
Ну вот. И тут нот.
И нот, и тут, соответственно, что нот.
Сейчас, ну мы, то, что знаменатели,
можно оценить только...
Ну, смотрите.
Ну, давайте так.
Ну, давайте так.
Что-то все-таки нот.
Ну, давайте так.
Там в знаменателе находится что-то длина на длина на синус, да?
Но, в принципе, сократить вот это на это, в принципе, можно просто.
Вот.
И, то есть, получится тут, там, P4 минус P3 на синус.
Он тоже сократится.
Ну, если мы...
Ну, да. Ну, тут, впрочем, да, тут, может быть, да.
Ну, по-хорошему, да, ладно.
Самое надежное, знать, что это как минимум 1,
что это там, как минимум 1 уж точно,
это, скорее всего, это может быть квадрат,
то есть, здесь 9 в квадрате, тут квадрат.
Поэтому можно оценивать как куб.
То есть, в принципе, можно сразу сказать, что там, да.
То есть, сделаем bounding box на 1027
и точно не паримся.
Правда, мне почему-то их...
Правда, да, мне...
Да, мне почему-то, почему-то,
у меня интуитивно всегда ощущение, что квадрат,
что-то я должен охватать.
Да.
А почему?
Это точно формула твоя?
Да.
Нет?
Ну, плюс-минус там, пример.
Она примерно такая.
Она примерно.
Да, может быть, там было P1-P3, но...
Ну, только там с минусом.
Ну, да, может быть.
Ну, так все просто хорошо.
Ну да.
Ну, как бы порядок все равно передается правильно.
У нас не все как раз сокращается, что это.
Не, ну где-то сокращается, да.
Ну вот что?
Ну, давайте так, вот по x смотреть, что у нас получится.
Ну, там вот давайте по x получится что-то типа x1,
плюс x2-x1 и да множить на вот это вот, да.
Вот это вот какое-то безобразие, да.
Получается x3-x1 на там значит y4-y3, соответственно, минус.
Соответственно, что там?
y3-y1 на сколько там x4-x3?
Так, и все это поделить на то же самое,
ну вот x2-x1 на y4-y3, минус y2-y1, x4-x3.
Вот, так.
Ну вот, и тут и получается, что как бы этот x, вот как минимум здесь,
он что-то вот примерно сокращается.
Вот.
А здесь как бы да, а вот здесь может оказаться подряд,
что это число мелкое, x2-x1 какое-то большое.
Хотя, ну вот вопрос.
Хотя, на другой стороны, если это число мелкое, то как бы и это мелкое.
Поэтому странно, конечно.
Так что да, ну тут вот действительно возникает вопрос, да,
как там эти расстояния изменяются.
Ну и что?
Ладно.
Ну да, тем не менее почему-то все равно,
все равно вот я не понимаю, почему у меня интуитивное ощущение,
что если точка 29, то уж как-нибудь в 10-18 пересечение уложится.
Хотя, на самом деле, может быть, это и не правда.
Ладно, не важно.
Вот.
Да.
Ну вот, но, по крайней мере, тем не менее, действительно метод у нас есть.
Вот.
Ну и теперь возникает еще один вопрос.
Как он нам помогает искать пересечение полуплоскостей?
Как он помогает?
Вот.
Ну, по крайней мере, в том плане, что он помогает нам говорить,
что мы по крайней мере ищем выпуклый многоугольник
или какую-то его выверженную реинформацию.
Понимаете, да?
Вот.
Как же мы ее ищем?
Не влезет.
Чего?
Не влезет.
Не влезет?
Да.
Да, почему?
В самом низу доступного репиона сделаем отрезок,
ну не в прямую, который идет вправо на 10, 9, вверх на 1.
А в самом верху прямую, которая идет вправо на 10, 9, плюс 1
и вверх на 1.
Репискуется где-то на 10, 27.
Так, сейчас.
Сейчас.
Подожди.
То же самое только еще.
Или нет.
Или они сблизятся на 1, на 10, 5.
Я сказал.
Ну, то-то и правда.
Нет.
Они сблизятся на 1, на 10, 9, плюс 1 и 1, вверх.
Ага.
Там, да, за 10, 9 они сблизятся на 1, на 10, 9.
Да, что такое?
То есть они...
Без 10, 9 они сблизятся на 1, на 10, 9.
Ну, окей.
То есть куп, то есть куп отсюда точно, типа.
Ну, я бы не придумал, если нет.
Нет, куп мы оценили.
Нет.
Нет, ну купы, вот куп отсюда чинит.
Да, все.
Да, все.
Ладно, окей, куп.
Да.
Понятно.
Но подлянка бывает.
Окей.
Подлянка бывает кусачья.
Да.
Вот.
Ну, а тем не менее.
Значит, как же можно искать крещение полуплоскостей?
По крайней мере, хотя бы мысля вот таким образом.
Вот.
Ну, можно его искать примерно там следующим образом.
Ну, здесь разные способы есть, потому что это тоже тот пример,
когда вы на самом деле можете смотреть на ограничение
и в зависимости от этого писать более или менее там
какой-то сложный алкоголь.
Например.
Вот предположим, что выяснилось, что у вас n не превосходит,
ну, я не знаю, двести.
Тогда на самом деле пересечение полуплоскостей
можно найти неожиданно тупым образом.
Говорим так.
А давайте k найдем.
Хорошо.
Мы ищем какой-то многоугольник на каких-то точках,
которые являются пересечениями каких-то пар прямых
и лежат во всех полуплоскостях.
Правильно?
Так, давайте часто за квадрат найдем все пересечения, все в прямых.
И для каждой из этих точек, прямо часто за o от n,
проверим, лежит ли она в пересечении полуплоскостей.
Как честно проверить, лежит ли точка в пересечении полуплоскостей?
Правильно.
Тупо перебрать все полуплоскости и тупо проверить,
лежит ли эта точка в полуплоскости, дай или нет.
Вот угол.
И тогда у вас получается, за n в кубе
у вас появится некий набор точек,
которые в пересечении полуплоскостей лежат.
Ну, видимо, все вершины этого пересечения.
Все, что вам остается, это там отсортировать,
найти их выбклу оболочку или что-то то же самое,
просто их отсортировать там по полярному углу как-то,
и в этом порядке и вывести.
Все, больше вам ничего не надо.
Мы рассмотрим вариант, если это отряд будет?
Да.
Ну, мы как бы пока предполагаем,
что ответ конечный вот с учетом этого Bounding Boss.
Вот.
То есть, в принципе, вот такой метод есть.
Что можно сделать еще?
Вот если, например, выясняется, что n не превосходит,
я не знаю, три тысячи,
три тысячи,
то оказывается,
оказывается,
можно
делать такой, как это у нас,
как это называется,
да, можно забабахать инкриментивный метод,
или как это называется.
Ну, короче, метод, когда мы будем
добавлять полуплоскости по одной
и поддерживать текущее пересечение реально.
Итеративно.
Ну, может, может и итеративно.
Да, но вот, не знаю.
Как мы это будем делать?
Да очень просто.
Ну, потому что в каждый момент времени у нас пересечение полуплоскостей
в какой-то многоугольник.
Вот он.
Ну, изначально просто Bounding Box,
а потом будем докидывать еще по одной прямой.
Ну и теперь ограничение позволяет нам
говорить, что так, если нам пришла
новая прямая, вот в каком-то направлении,
то мы можем прям за линию
найти пересечение соответствующей
полуплоскости этой многоугольника.
Как это сделать?
Ну, один из тупых способов такой.
Давайте, вот там, допустим, нам повезло,
они так пересеклись.
Давайте для каждой вершины поймем,
лежит ли эта вершина в полуплоскости,
да или нет.
Если у какого-то ребра выяснилось,
что одна точка лежит, а другая нет,
то мы сейчас находим точку пересечения
этого ребра с прямой и тоже добавляем
ее в ответ, ладно, как и вот эти точки.
То есть, по сути, там идея будет заключаться
в том, что вы будете идти
по многоугольнику и говорить, что
если вершина с плюсиком, то вы ее добавляете,
а если при проходе по ребру состояние
изменилось, то вы находите точку пересечения
и тоже добавляете ее в ответ.
Вот. Если состояние прячется,
если все плюсики, то окей,
если там все минусики, то, соответственно,
вы найдете точку пересечения.
Вот.
Можно, в принципе, вот так делать.
В принципе, вот пересечение за М квадрат тоже
может вам помочь.
Вопрос, как здесь найти первоначальный ВВ?
Так он изначально вам да.
То есть, это пересечение, а, изначальный
bounding box.
А, хорошо.
Да, мы стартуем с bounding box.
Да, нам очень удобно.
Вот.
И, наконец,
когда выясняется, что у вас
два на десять пять.
Все дело.
Ну, тут, на самом деле, можно мыслить
двумя способами.
Да. На самом деле,
заметим, что можно,
можно, в принципе, вот это вот
попытаться реально упихать
за алгоритм.
Таким образом.
В сете, хранить него угольник,
искать пересечения.
Ну, начнется с того, так, ну, во-первых, у нас начнется такая задача,
похожая на которую мы уже решали.
Задача. Дан выплыл на угольник,
дано направление. Найдите, пожалуйста,
найдите, пожалуйста, касательную
параллельную этому направлению.
Ну, можно легко
вот, я утверждаю, что, в принципе,
ну, за логонот.
Ну, за алгоритм мы это найдем.
Есть у нас
плотница обращения к вершине
угольника. Да.
Ну, если у нас вот
эти вершины заданы прям вот в массиве,
то за алгоритм найдем.
Ну, во-первых,
можно предположить еще, что, допустим,
мы самую низкую точку случайно знаем.
Ну, тогда это просто будет очень удобно.
Тогда мы можем, там, скажем,
сначала бинпоиском найти
вот эту самую верхнюю точку, да?
Понятно каким образом, да?
Потому что есть точки возрастающие, есть точки
убывающие, есть параллельная заставка.
А потом, после этого, там,
между этой точкой этой бинпоиском
ищем, там, как бы, то есть, где подходит
этот касательный лед, если не подходит,
то, как бы, потому что поздно или потому что рано.
Ну, например, вот для этой точки
вот так касательно откровенно поздно. Почему?
Потому что предыдущее ребро,
входящее в нее, оно
как бы, оно, как бы, полергута влево
относительно этого направления, видите?
Ну, вот. Или если
слишком оно бывает, иногда слишком рано.
Потому что, наоборот, следующее
ребро, на самом деле, правее нашего.
А вот есть погранзастава, вот это какая-нибудь точка,
вот она. Когда тут все в порядке?
И следующее ребро левее, и предыдущее
ребро правее.
То есть, как бы, как бы, сначала
идут ребра, которые правее нашего направления,
потом левее. Поэтому бинпоиском
ищем погранзастав.
Ну, а это, если нам вот эта
самая низкая точка нашлась?
А что делать, если этой
самой низкой точки нет?
А зачем нам не нужна была самая низкая точка?
Ну, чтобы вот, ну, во-первых,
чтобы найти самую верхнюю и чтобы потом вот
между этой и этой точкой реально тут были полетели бабахи.
Ну, нам бы нужна была
эта нижность. Нам
просто нужна была любая точка, и ее предсуположно.
Ну, вот. Ну, в принципе,
ну, в принципе, да.
А по большому счету, да, даже если этого не было,
на самом деле мы могли бы спрашивать, давайте скажем что
это там, какая-нибудь, если у нас первая
попавшаяся точка, то давайте скажем что у нас есть
первая попавшаяся направление. Вот оно.
И тогда замечем, что мы тем же бинпоиском
можем найти точку
противоположную по направлению,
то есть противоположной по направлению касательной,
что же бинпоиском, да.
А потом в
нужнойlexe, либо здесь, либо здесь
найти там бинпоиском
Собственно, там точку, в которую можно привезти вот это.
Да, то есть явно, видите, это можно сделать, не самым приятным образом.
Если это, можно действительно это сделать, если у вас точки находятся в многоугольнике.
Если у вас точки лежат в массиве.
Мы нашли касательно.
Да, нашли. Ну, да, мы нашли касательно.
Зачем мы это сделали? А вот зачем.
Потому что вот мы нашли одну касатель, и нашли, кстати, заодно вторую, противоположную.
Ну, за логарифом сделали, да?
А теперь просто идея такая, что теперь за логарифом вы теперь можете найти, где эта реальная прямая горизополутоскость пересекает наш многоугольник.
Ну, собственно, тут бенпоисковый, тут бенпоисковый.
Ну, или выяснить, что если эта прямая тут справа от этой, значит вообще ничего не меняется.
А если она слева аж до этой, значит вообще пересечение стало пустым.
Ну, это мне отдельная, конечно, песня с разбором выраженных отрезков всяких.
Вот.
Но, правда, есть маленькая проблема. Хорошо.
Точки пересечения, хорошо, мы научились искать точки пересечения, точки пересечения прямой и записанного в массиве многоугольника, да?
Теперь залат логарифмы из массива удалим половину.
Да, теперь задача. Изобрести массив, в который можно обращаться залат единицы к точкам, и при этом залат логарифма, ну, или хотя бы учетного, удалять лишние точки.
А нам не нужно залат единицы к точкам обращаться?
Ну, да.
Да, в принципе, да, конечно, мы глобально можем с этим сталкивались, но теперь смотрите внимательно.
Потому что давайте сделаем так. Давайте эти точки заодно игром охранить дикартовым деревьем.
А, ой, дикартовый деревьем, ладно, в овелике.
Вот.
Нет, ну чтоб заодно еще можно сплеить, но овелик, у него железобетонный логарифм, он там все хорошо.
И сплитить его можно, мержить можно, вот так.
Так вот. Итак, овелик.
Тогда заметим следующее, что в овелике мы просто к катому, во-первых, мы можем к катому элементу обратиться за логарифм, да, для любого к.
И тогда получается, что в принципе за лог квадрат мы в принципе нужные точки можем найти.
Ну можно так как минимум изомыслить, правда?
Ну вот. И потом, собственно, лишние точки можно прям за логарифм и убрать.
Хотя можно не заморачиваться, если, может, каждую точку, которую вы удаляете, она никогда не добавится, поэтому суммарные удаления будут на логе, так что это по муравану.
Вот. То есть получается, что теперь добавление можно делать за лог квадрат.
Но, конечно, фишка в том, как было замечено, что на самом деле этот бинпоиск можно написать, если его правильно написать.
То бинпоиск он делается за логарифм.
Так, как за лог квадрат, понятно?
А теперь смотрите, как делать за логарифм.
Сейчас еще раз, за лог квадрат, это вот то, что со савелькой...
Да, то есть говорим, давайте эти вершины хранить не в массиве, а в овелике.
Тогда все домножается на логарифм, поскольку доступ к точке номер к у вас становится логарифмический.
А это нам нужно для того, чтобы...
Чтобы потом адекватно удалять эти точки.
Да, их нужно удалять, и еще вот эти новые вставить.
Вот.
Так вот.
Как же теперь этот лог квадрат превратить в логарифм?
Ну, вспомнить, что овель это вообще дерево поиска.
То есть у нас все поиски базировались на том, что у нас там относительно какого-то компаратора сначала точки или ребра плохие, а потом хорошие, правда?
И надо найти первую точку, которая там хорошая, да?
Вообще, раньше плохие, да?
Но как это делать?
Ну, на самом деле, если у вас уже есть дерево высоты от логарифма, а овель дерево, ура, это правда,
то тогда мы просто говорим, так, если у нас точки лежат вовл...
То есть мы делаем так, забабахиваем овель дерево, да, но нам придется, правда, для каждой точки проверить, там, поддерживать указатель на следующую и предыдущую еще, правда.
Но это уже мелочи.
Реализационные такие.
И говорим, так, отлично, вот жила была точка, корень.
Так, она хорошая или плохая?
Допустим, хорошая.
Так, тогда первая хорошая точка, либо она, либо она не хорошая.
Допустим, хорошая.
Так, тогда первая хорошая точка, либо она, либо что-то, что находится в левом поддереве, правда?
Отправляемся в левое поддерево, говорим, так, вот эта точка, хорошая или плохая?
Плохая.
Так, значит, видимо первая хорошая точка, либо эта, либо то, что у нее в правом поддереве, правда?
Ну и так далее.
Тут тоже плохо, тут наоборот хорошо, и тогда ближайший ответ получается этот, и так далее.
В двоичном дереве поиска бинпоиск делается спуском по дереву, потому что двоичное дерево поиска это набор всех возможных траекторий реального бинпоиска.
Не совсем, но тем не менее. Он позволит вам это прекрасно за логарифом делать.
Бинпоиск с деревом поиска прекрасно совмещается.
Все это вы будете делать за высоту дерева.
Вот, собственно, и все.
Как минимум, в идее.
Да, осталось только потом сесть и это написать.
Потому что на этот раз вам придется писать свое овое дерево. В смысле, декортеатрику.
Не сильно легче будет.
Вам придется для каждой точки хранить, кто следующий, кто предыдущий.
Удалять там как-то, понимать, как точку удалить.
В общем, мерзость будет, но, по крайней мере, чисто теоретически вы за логарифом это делать умеете.
Но, на самом деле, слава богу, есть другой алгоритм.
Не интерационный.
Ну, то есть, полезно иметь в виду, что в принципе интерационный алгоритм есть.
И он иногда таки помогает.
Вот.
Нет, в принципе...
Ну да, там, конечно, по-разному можно делать, но сейчас поговорим.
Потому что мне сейчас в голове опять начинает крутиться какое-то дерево отрезков вот этих вот безобразий.
Нет, кстати...
А, ну как?
Нет, нет.
Ну хотя...
Да, нет, не надо.
Вот, значит, смотрите, альтернативная версия алгоритма.
Ну вот, по крайней мере, моя версия такая.
То есть, на самом деле, честно скажу, есть там разные какие-то версии.
Ну вот, по крайней мере, я расскажу версию, которая может быть не самая приятная по написанию, но зато же незабетонная.
Вот.
А базируется она вот на чем.
Она базируется на том, что полуплоскости, по идее, можно разбить на две части.
Те, которые смотрят вверх, и те, которые смотрят вниз, правда?
Ну, есть еще, правда, вот, то есть, есть вот такие какие-то, да, которые смотрят там куда-то вверх.
А есть всякие вот эти вот, которые смотрят вниз.
Вот.
Так, вот они выглядят, вот такая вот смотрит.
Да, вот обратите внимание, вот такое будет смотреть вниз тоже, видите.
Вот.
А влево-право все берет?
Ну, почему? Нет, в смысле влево-право.
Вот это, это смотрит вверх.
Нет, нет, нет.
Ааа.
А с программой заставы можно подключить так.
Давайте, если такие есть, включим их в bounding box.
Ну, у нас изначально же был bounding box, помните, из четырех вот полуплоскостей, да, вот.
Одна из них вот теперь смотрела вниз, да.
В смысле влево-право.
Но если у нас еще есть, смотрящие туда же полуплоски, давайте bounding box ограничим до них.
Вот, удобно, правда?
Ну, если у нас там экран схлопнулся, ну, значит, нам повезло.
Ну, или не повезло, как нам повезло.
Да.
Вот.
А теперь у нас получается остальные полуплоскости теперь разбились на две части.
Которые смотрят вверх, которые смотрят вниз.
Так вот, у меня идея такая.
Давайте найдем пересечение полуплоскостей этих, найдем пересечение полуплоскостей этих, а потом с конлайном их объединим.
Выглядит это будет примерно так.
Вот давайте представим, что у нас все полуплоскости смотрят только вверх и никуда, кроме.
Тогда оказывается, что у нас, в принципе, есть фактически метод Грехома.
Который сейчас прекрасно сработает и здесь.
Как он сработает?
Очень просто.
Давайте вот, жили были у нас вот эти вот там всякие безобразия, да?
Вот это вот все, да?
Так вот, отсортируем их по полярному углу.
Ну, в смысле, по углу направления, прям по векторным произведениям.
Вот так, да?
Ну, заметим, что такое полуплоскость и смотрящий вектор?
Это означает, что направляющий вектор смотрит вправо.
То есть, ну, вправо в смысле, что и х у конца строго больше, чем и х у начала.
Звучит, конечно, так, как-то.
Да, мальчик, который не знает сторон смет, а каждый был, смотрит, а птицы улетают направо.
Ну, да.
Ну, да, только еще таким детским голоском это надо подавать еще таким.
Да, мальчик, который не знает сторон смет, а каждый был, смотрит, а птицы улетают направо.
Ну, вот как-то так.
Ладно.
Так.
Так вот, ладно.
Значит, тогда идея такая.
Так, если выход сортировали, то давайте теперь по очереди их добавлять.
Ну, и сначала у нас будет вот такое пересечение.
Да, ну, если там понятно сначала, если идет там прям пластер из таких вот идущих подряд стрел, то, понятно, мы их быстро разбираем, оставляем только последнюю.
Итак.
Берем следующую.
Ну, понятно, что две какие-нибудь будет вот как-то так.
Ну, а начиная с этого момента уже происходит более-менее общий случай.
В чем он заключается?
Заключается он в следующее.
Вот.
То есть, он заключается в том, что у вас есть уже вот какой-то такой вот набор.
И есть полуплоскость, которая заведомо смотрит вот как-то левее, чем вот это направление.
Да?
Тогда идея такая.
Вот допустим, оно, то есть оно, что приятно, оно вот эту ломаную, оно эту ломаную заведомо пересечет.
Вот, кстати, почему приятно пересекать полуплоскость, которая смотрит в строгомверх?
Потому что вы знаете, что пересечение всегда будет.
И оно будет устроено более-менее одинаковым образом.
Вы понимаете, да?
А это с чем-то похожим на конверсал-трик?
Это оно и есть.
Нет, не совсем.
Это похоже на алгоритм Крехова.
Я бы сказал так.
А конверсал-трик, это как бы...
А нет, конверсал-трик и вообще подлянка.
Потому что, как показала практика, под конверсал-триком в голове могут возникать две принципиально разные картинки вообще.
Потому что в одной надо реально там возникают какие-то прямые, которые надо пересекать.
А в другой возникают точки, у которых надо искать мобку оболочку.
Не, прямые, прямые.
Ну, оригинальный конверсал-трик, вот оно.
Для каждого Иксана типы...
Я не знаю, что такое оригинальный конверсал-трик.
Вот для меня в оригинале конверсал-трик, где возникают точки, надо мобку оболочку искать.
Один, наверное.
Вот.
Вот для меня вот так.
Потому что...
Потому что, что такое родная?
Если родная это то, что вы первый раз услышали, что некоторые обозвалы конверсал-трик, то вот я сказал, что это было для меня.
Возможно.
Ну, на самом деле ладно.
Возможно даже сегодня.
Сегодня мы успеем.
Интересно.
Может уже Иксан действительно перелез.
Так зачем перелез?
Хорошо, пошел.
Послушай, как в прошлый раз.
Ну ладно, сейчас посмотрим.
В прошлый раз перелез был.
Не, по-моему в прошлый раз перелеза не было.
В прошлый раз мы тупо напитаться раньше закончили.
Нет, он был уже поздравленный.
А, в итоге был?
Ну ладно.
Ну сейчас посмотрим.
Ну ладно, это давайте добьем?
В любом случае, конверсал-трик мы, естественно, будем обсуждать.
Во всех его интерпретациях.
В обеих.
Так что не волнуйтесь.
Да.
Как говорится, из одной, из другой.
Там с этим вот деревом лечао, естественно.
Так что не волнуйтесь, это все будет.
Так ладно.
Значит, ну чем по камере приятно, так это тем, что пересечение всегда есть.
И более того, значит, теперь когда добавляется новая прямая,
теперь вот очень хочется найти, где она произошла.
Потому что видим, что если мы движемся по этой границе,
то некоторое время мы движемся и все это лежит в пересечении.
А потом оп, мы тыкаемся на эту прямую.
И все, что будет дальше, это вот отрызок этой прямой.
Представляете, получается, в алгоритм Грехома в том плане,
что мы просто вот все точки, вот эти пересечения, которые лежат,
не лежат в этой плоскости, мы просто из стека выкидываем.
Вместо этого добавляем вот эту точку пересечения.
То есть получается, по сути, он просто простой аналог Грехома.
Даже не Грехома, а скорее Эндрю.
Такой получается. Вот такая красота.
Вот.
Итак, теперь мы смогли сделать это здесь.
Ну и действительно, можно даже, кстати, для красоты еще вот эти,
начать вот с вертикальных, вот этих двух вертикальных,
чтобы совсем красиво было, да?
Но теперь смотрите, что у вас получилось.
Нашли это пересечение и, повернув картинку на 180 градусов,
нашли еще вон то пересечение.
Вот так вот.
То есть фактически у вас есть, так сказать, чашка и крышка.
Вот. Да. Или так. Крышка и кружка.
Главное, глазные не перепутаны.
Вообще да. Да, капелька, это совершенно верно.
Нет, я так понимаю.
То есть не помню, что отослаться,
но как бы в каких-то отдельных областях науки
это прям вот очень активная технология использована.
В лотехе.
В лотехе, правда, пересечение объединений использованы.
Но КПКП это точно.
А, но там было, конечно, там что-то, да.
Ой. Ну, в общем, ладно, да.
Ладно, чувак, который там про чашки и крышки рассказывал,
помню, что вы его точно не знаете.
Вот.
Так вот.
Ну, теперь идея такая.
То есть на самом деле теперь задача.
Вот давайте сейчас для простоты скажем,
что у вас нет вот этих ограничивающих,
вы там идёте вот от плюс бесконечности.
Вот у вас такая выпуклая штука.
И вот такая.
Некоторое время вы идёте-идёте,
и у вас оказывается, что чашка выше кружки.
То есть пока никаких пересечений нет.
Вот прям идёте.
Прям честно двумя указателями,
прям по вершинкам идёте, да.
Но потом в какой-то момент неожиданно,
бабах, и обнаруживается, что
в какой-то момент, неожиданно,
кружка оказалась ниже.
То есть крышка оказалась ниже кружки.
Выше кружки.
Но тогда у вас есть эту точку пересечений,
понимаете, что начиная с этого момента,
у вас пересечение реально пошло.
Видите, да?
Оно идёт, идёт, идёт.
И в какой-то момент опять поменялось.
Ну, значит, в этом месте оно закончилось.
То есть вот, собственно, вот эти части.
Ну, конечно же, да.
Если вы стартовали не с минус бесконечности,
а с этой прямой,
то, может быть, у вас всё сразу стартовало
уже с пересечения.
Но суть от этого не меняется.
То есть вот таким вот надёжным образом,
хоть и не самым приятным с точки зрения ходинга,
можно найти пересечение кладов с костей.
Про пересечение у них крышки и кружки у вас ещё раз?
Ну, ещё раз, просто,
ну, практически идёте таким вот сконлайном.
Да, вот, вот.
Фактически два указателя таких, да?
И в каждый момент думаете, так,
кого двигать?
Ну, в каждом момент времени двигаете вы,
естественно, того, тот указатель, который раньше.
И, вот.
Пока, ну, как бы, этот отрезок,
эта точка выше, ну, как вы проверяете выше,
потому что вы тут, так бы, эту проекцию,
то есть по этому иксу вот на этот отрезок проверяете
и, собственно, смотрите выше и ниже.
Ну, можете так проверять,
можете просто проверить, что вот у вас отрезок
и вот у вас есть точка по иксу между ними.
Можно просто вот на уровне векторного произведения
проверить, она там выше или ниже.
Вот.
Ну, а можно прям в явном виде вычислить
как координату, это уже деталь.
Вот.
Ну, вот.
Ну, соответственно, двигаем, двигаем.
И вот, наконец, в какой-то момент обнаружилось,
что вот пока у вас это выше,
но когда мы перейдём, сдвинем вот этот указатель дальше,
окажется, что это будет уже выше.
Тогда, получается, что эти отрезки откровенно пересекаются,
вы находите эту точку пересечения
и говорите, что эта точка у нас
оказывается в пересечении,
то есть в этом пересечении КПК полежит.
Ну да, и дальше точно.
Ну, начиная с этого момента,
тут интересно, начиная с этого момента,
каждую вершину, каждую вершину,
сверху и снизу вы в ответ добавляете.
Правда, у вас тут как бы два вектора,
то есть как бы то, что сверху и то, что снизу.
Вот.
Ну там, да, то есть надо быть аккуратнее,
потому что надо внимательно смотреть,
что будет, если у вас там КПК пересекаются
вот каким-нибудь вот таким вот мерзким образом.
Да, такое тоже бывает.
Или вообще там по одной точке касания произошло,
всякая мерзость случается, но вот тем не менее.
Но обычно это решается по принципу,
давайте в конце пробежимся и удалим там
какие-нибудь одинаковые идущие подряд точки, скажем.
Так что ну вот, ну или там точки,
лежащие на одной прямой какие-нибудь еще, вот это все.
Да, так что получается вот еще один вот такой алгоритм,
который успешно работает за НЛОГЭ.
По камере железобетонно-надежным.
Так что вот так можно найти, если у вас задача
есть найти именно пересечение полуплоскостей.
Ладно, значит смотрите, ну тогда,
если уже говорим тоже об этом,
то, соответственно, говорим о выпущении,
то нельзя не сказать, конечно,
представьте, пару слов о таком красивом методе
решения задач, как торгонарный поиск.
Да, это важно.
Ну, потому что для чего вообще нужен торгонарный поиск?
Ну, чаще всего нужен для следующего.
Вот предположим, что нам дана мистическая функция,
которая сначала строго убывает до какого-то момента,
вот нам известно откуда-то,
а потом строго возрастает.
Такая функция называется унимодали.
Да, я тут специально вот такой.
Функция называется унимодали.
И вот у нас задача,
то есть дана такая функция,
мы для каждого х за 1 можем вычислить f от x,
но где минимум мы не знаем.
Но возникает естественный вопрос,
как же этот минимум найти?
Ну, допустим, где-то вот на отрезке, допустим, от l до r.
Вот так.
l, 2, r.
У нас она как бы непрерывная,
или мы в соточках смотрим?
Не очень понятно.
И так, и так, не принципиально.
Самое главное, что она сначала убывает,
потом возрастает непрерывно,
как вы сейчас видите, вообще ни при чем.
Более того, на самом деле,
здесь минимум может быть не один,
а целый отрезок минимума.
Да, но здесь никаких разных плотов быть не может,
сейчас вы увидите почему.
Ну, по крайней мере, с точки зрения того метода.
Значит, в чем заключается метод?
Как искать минимум?
А очень просто.
Значит, смотрите, давайте поделим наш вот этот отрезок
на три части.
Ну, например, разные части.
Эта точка будет 2l плюс r на 3,
эта будет l плюс 2r на 3.
Вот.
Честно вычислим значение в этой точке.
То есть, допустим, более правое,
потому что справа оказалось больше.
Тогда я утверждаю, что минимум
заведомо не находится
вот в этой вот правой третьей.
Почему?
Ну, потому что, по сути, наш алгоритм говорит следующее.
Не может быть такой точки,
у которой и слева есть что-то меньше меня
и справа есть то, что меньше меня.
То есть, смотрите, определение нашей функции
это притallogично.
То есть, либо слева от меня все точки больше
либо справа от меня все точки меньше меня.
Раз не верно, что все слева точки больше меня,
значит справа борьше, значит вытягивает.
То есть, получается, если справа оказалось значение больше,
значит мы тут все вытягиваем.
если бы нам повезло они оказались равны, ну в принципе можно выкидывать и то и то с точки зрения нашего определения
ну и таким образом теперь повторяем операцию, то есть теперь у нас отрезок вот такой, то есть отрезок теперь уменьшился в полтора раза получается
что теперь можно сделать? можно теперь сделать что, и теперь делим этот отрезок тоже на три части
теперь уже вот там как-то вот так и допустим вот так и выкидываем вот эту часть, потому что вот эта оказалась больше чем вот эта
ну и так далее, ну делаем так, ну тут два варианта, если мы делаем тернарный поиск на массиве точек, то тогда ищем там до тех пор пока длина этого отрезка
не окажется меньше четырех, ну вот, ну а там когда отрезок длины четыре вы уже минимум находите прям перебора
ну вот если функция непрерывная, то ну как всегда, чаще всего это говорят, просто делаем 200 итераций
ну такой стандарт, 200 итераций и говорю, что минимум где-то тут вот остался маленький отрезок, где там берем середину и не паримся
вот, то есть вот так вот может работать тернарный поиск, есть у нас функция вот такая немодальная
вот, ну пишется он достаточно просто, вот, но самое интересное конечно возникает конечно даже не в самом поиске, а в том когда его можно применить
вот, ну чаще всего оно конечно применяется, чаще всего тернарный поиск применяется в поиске минимума на выпуклых функций
ну давайте поймем, вот что такое выпуклая функция
какая функция у нас выпукла вниз
производная вторая
нет, это на дифференции
но вообще что, ну ее на аутографик выпукла
на самом деле, да, лишь она по идее, да, то есть действительно, то есть функция f допустим на a вв, так и напишем, выпукла вверх, выпукла вниз, потому что ее на аутографик
если, вот это мы на уровне определения напишем, если ее на аут график, что такое на аут график функции
ну то есть это множество точек x и y таких, что значит x лежит на a вв, и соответственно y больше либо равно f от x
если ее на аут график, выпукл
да, если бы f была два раза дифференцируемой, то вы могли бы там утверждать, что функция выпукла вниз тогда и только тогда, когда у нее там вторая производная больше либо равна нуля
но на самом деле функцию можно выпукла вниз, даже если она и не дифференцируема, то всякое бывает
ну по крайней мере два раза, в конце-таки то бывает, что вот вопрос о пересечении полуплоскостей, вот такая не такая функция, правильно?
она даже один раз не всегда дифференцируема
вот, так вот, можно заметить, но на самом деле можно заметить, что выпуклая вниз функция на отрезке, допустим, ab, вполне себе является унимодальна
соответственно, понятно почему?
ну ладно, договорка, не совсем, бывает еще выпуклые функции вот такого вида, тупо убывающие или тупо возрастающие?
это не подходит в ходу унимодальности?
ну вот как это воспринимать?
потому что мы сказали, что у нас должна быть функция, которая сначала убывает, строго убывает, потом строго возрастает
ну ладно, если мы это примем, как крайний случай, унимодальной функцией, то соответственно
так, ну теперь правда, вот возникает вопрос
действительно, да, правда
а как бы доказать?
желательно, что без производства функция дифференцируемая обязана быть не
ну не очень сложно, берем минимум
так
ну начнем с того, существует ли он?
ну
если функция непрерывная
функция не обязательно непрерывная?
если функция непрерывная на отрезке АВ, то соответственно, да, давайте простой случай рассмотрим
если функция непрерывная
чаще всего так и бывает
да, рассмотрим
если функция непрерывна
то да, у нас есть минимум
да, мы знаем, что минимум есть и он достижен
и теперь давайте посмотрим
может верно ли, что скажем до этого момента функция строго убывает?
функция строго убывает. Ну положим красивая, пусть там есть такие две точки, что... Ну да, тогда заметим действительно, что если у нас вот есть минимум, есть вот
какая-то такая точка, и тут такая точка, то заметим, что вот этот отрезок просто пересекает как бы вот эту
ликтикальную прямую ниже этой точки, то есть получается не весь этот отрезок лежит в нотографике.
Понимаете, да? Понимаете, да. Это было бы, как говорится, непринотно, это было бы противоречие.
Поэтому получается двух точек, слева двух точек таких, что правая выше левой, у нас быть заведомо не
может. Ну и справа аналогично. Так, ну и в принципе это верно просто, если у нас есть достижимый минимум,
если у нас есть достижимый минимум, то да, действительно, тогда какие-то функции откровенно
и не модально. Что делать, если у нас... Ну да, ну кстати, да, если функция монотонная, ну то есть и так,
если у нас минимум достигается на краю, то тоже заведомо функция монотонна, да. Но возникает вопрос,
хорошо, а если этот минимум не достигается? Ну, можно... Ну, малый, чисто театрический минимум на отрезке АВ
может не достигаться. Или просто... Ну, хорошо, тогда есть последовательность точек, что их значения стремятся к
минимуму. Можно видеть в поселке... Так что у нас должна быть у кого-то точка, то есть функция в одной точке должна быть
неопределена. Почему? Нет, ну, потому что у нас это же... Нет, мы сказали уже, мы отказались даже от требований непрерывности.
Так что может быть вот такая точка, вот такая функция куда-нибудь стремящаяся, и тут в конце один
точка. Ну, да. Да. Что-то это как бы противоречие. Вот надо подумать где. Пока вот Антон начинал логичное
расположение. Что есть? Отрезок. Что? У нас есть отрезок. Да. И у нас есть там... Ух! Какая моя кула не сказать.
Ух, ё-моё. И если бы ещё функция была ограничена, то всё вообще было бы очевидно. Так, ну хорошо, да-да-да.
Доказать, что она ограничена. Потому что её можно ограничить в некотором смысле прямой. Возьмём функцию,
возьмём значение в коем-нибудь точке. Возьмём. Нарисуем прямую между началом и этой точкой. Так, хорошо, давай читать.
Функция на отрезке, да. Возьмём... Так, точку в начале и точку в эту, да? Да, точку в самой левой границе и точку ещё в
где-нибудь. Взяли. Я утверждаю, что справа от точки, которую мы взяли, функция ограничена этой демонтой.
Ну, снизу ограничена этой демонтой. Понятно, почему. Потому что если тут нашлась точка ниже, то тогда вот тут фейл.
Так. Давай теперь через эту точку возьмём точку справа. Возьмём точку справа ещё. А, ну да, понятно.
Заметим, да, что точка ограничена, функция ограничена снизу, поэтому да. Ну, это мы ограничили снизу, да? Да.
Да, теперь сам мы доказали, что функция ограничена снизу. Ну, сверху она ограничена быть... Не обязана, да?
Нет, хотя нет, ну, на отрезке скорее обязана. О, Господи, на отрезке. Да. Ну, а мы жестко пользуемся тем, что это отрезок.
Да. Вот. Ну, на самом деле... Хотя нет, на самом деле не очень жестко. Если бы это был интервал... На самом деле давайте так.
Если бы это был интервал, то мы бы взяли просто три точки, вот такие, от балды, и сказали бы, что всё с этими прямыми ограничено, всё в порядке, да.
Ну, на интервале тогда функция может быть вообще вот такой парамок и вот такой. Или там, может это вообще там танкинс какой-нибудь. А, знаете, это хип-синонная модуль танкинса.
Модуль танкинса вот так вот выглядит. Вот. Ну, хорошо. Так, ну и что, хорошо. Функция ограничена снизу, да. И чего?
Ну, рассмотрим просто на точку, которая значение которой стремится к инчиму. Там можно выбрать очень подходящую спутни следовательность.
Так. Ну, да. Если функция на отрезке ограничена снизу, то она... Нет, так не прерывная. Да? Да. Ну, вот. Ну, да. Так. Что такое выпуклая, прерывистая функция?
А какая разница? Ну, не знаю. Звучит как-то, что на чём они существуют. Ну, мы пытаемся это доказать, вроде бы. Да. В чём проблема-то?
В том, что возьмём точку разрыва. Бывает любого рода? Господи. Ну, да. Ну, не бывает любого рода. Ну, ладно. Бывает.
Можно ещё раз доказать, что функция ограничена снизу?
Знаете, доказательство такое. Рассмотрим три любые точки. Да, и с разными иксами. Да, с разными иксами, конечно. Ну, мы как бы рассматриваем функции на графике.
Это вот функция на графике как-то вот. И вот как-то так. Тогда утверждение следующее. Вне вот этого отрезка... Вне вот этого отрезка я утверждаю, что...
Точнее, сначала тихо он утверждает, след за ним, и я, что все точки вне этого отрезка заведомо лежат выше этой прямой. Почему? Ну, просто потому, что если он нашла где-нибудь ниже, то тогда график откровенно не выпукал, потому что вот эта точка разрыва снижает.
Вот. Ну, с другой стороны, вне вот этого отрезка функция тоже должна быть выше этой прямой. Почему? Потому что по той же причине. А если это не минивум, а минивум не минивум?
Так, пока был вопрос, почему функция ограничена снизу. На графике чем ограничена функция такой? Ну, она ограничена снизу вот этой прямой, снизу вот этой прямой.
Ну, давай на ходевал, в смысле... Залила ограниченность? Нет, она... Вот такой вот сложной фигней. Так, ну хорошо, она ограничена снизу вот этим вот. Ага. Так, значит, на этой прямой она ограничена вот этим вот.
Нет, вообще так, вне она ограничена вот этой прямой, вот этой прямой и вот этим вот интервалчиком. Но, как бы, ну скажем так, эта функция, конечно, разрывная, но ограничена снизу откровенно.
Стоя средняя. Нет, в смысле... Нет, в смысле она... Нет, ну еще раз. Утверждение. Вот... Так, давайте заново. Вот здесь две... Начнем с простого. Есть две точки на графике, да? Да.
Значит, я утверждаю следующее, что наша функция... Вот в этой полосе эта функция ограничена снизу вот этой вот прямой. Почему? Потому что предположим, что в этой полосе нашлась какая-нибудь точка ниже этой прямой.
Давайте не доказывать ограниченности. Давайте не доказывать ограниченности. Ну, на всякий случай. Ну, сейчас покажу. Ну, соединили. Обнаружили, что тогда, смотрите, эта точка из-за графика, эта точка из-за графика, значит, вот эта точка из-за графика.
Да. Просто притворечит. И еще она ограничена... В этой полосе она ограничена снизу вот этим, а в этой полосе ограничена снизу вот этим. Да, между этими точками может быть, конечно, все что угодно, но понятно.
Но если вы возьмете третью точку какую-нибудь еще, там скажем, вот какую-нибудь вот эту. Ну, я от волды так взял, потому что они могут и монотонно расти, это неважно. То есть я могу сказать, что функция по той же причине ограничена еще чем-то на этом отрезке, чем-то на этом отрезке. Вот. То есть вот таким вот мой додырем функция ограничена снизу.
Соответственно.
Так, у меня, в общем, два комментариев. Первое, неправда, что она не достигается минимум. Какой пример? Пусть она на все отрезки вот прямая, да, и с крайней точки выколоты выше, чем эта прямая.
А, ой, какая красота.
Вот, но не сложно доказать, что это единственная проблема.
Нет, в этом случае минимум как раз достигается.
Нет, она вот-вот так.
Она выпуклая.
О, да.
Вот.
Но, к счастью, это единственный случай. Как еще раз доказать?
Ну вот пусть у нас есть инфима, у нее есть последняя точка, которая к нему стремится.
Так.
Можно выводить под последовательностью, которые, иксы тоже к чему-то сходятся.
Тогда у нас получается такая точка, вот, и значение в ней, что к ней стремятся значения меньше ее.
Так.
Вот.
А если проводить каждый раз прямую, то она будет все более и более вертикальна,
и в итоге, короче, с одной из сторон от этой точки просто все значения должны быть плюс бесконечность.
Что невозможно. Поэтому точка будет крайняя.
Нет, погоди, ну, смотря как они сходятся...
Мы можем оставить только с одной половины.
Нет, может они там как-то сходятся, извиняюсь, так, чтобы касательная все-таки там не обязательно вот так вот прям по наклону прям проблемы.
Нет, там обязательно будут прям по наклону, потому что они сходятся к точке под ней строка.
Ну, вот эти же точки, они также сходятся к ней, но по наклону, то все...
По наклону... Сейчас, можно или нет?
Давай.
В общем...
Так.
Ну, вот у нас есть точка, да, а вот тут как бы есть, условно, ну, точка, которая сходит к чему-то ниже ее.
Тогда если мы будем проводить вот, например, вот такую прямую, да,
мы уже знаем, что вот справа от этой точки все должно быть выше, чем от прямой.
Ну, не меньше, потому что если меньше, то противоречие.
Так.
А если мы можем провести с еще большим наклоном, и с еще большим, и сколько годам большим?
Ну, мы можем считать, что все точки левее ее.
А, типа если тут точка выше.
Вот. Ну, мы можем считать, что все точки только с одной стороны от этой.
Понятно.
Вот. Но остается в случае, когда эта точка крайняя, но тогда мы уже знаем, что здесь она обязательно функцию убывает.
Вот. Ну, и тут, правда, она может быть выкрутой.
Нет.
Ну, а, ну, если они так...
Ну, если они так стремятся, eineстановку, конечно.
Вот. Так, ну да, если они так стремятся короче.
Но это если эта точка выше.
Ну, а если.
Если они вот так стремятся, и эта точка ниже...
Так мы же стремились к инфину, и она не может быть ниже.
А, мы vimos, точно. Мы стремились к инфину.
А если она равна пред towel, то это и есть миззи.
Да.
Если она равна, а если она, если она, а если она выше.
Не с краю, то всё плохо. Если она с краю, то мы уже получили, как функция выглядит.
Так, какой из этого вывод, что у нас функция бывает либо монотонная, кроме одной точки с левой или с правой, либо...
Либо реально убывает и потом возрастает.
Либо, причём, минимум железобетона достигается, что интересно.
Ну, вот кроме такого странного точки.
Нет, это называется, когда у нас полная монотонность, кроме правой точки.
Понятно.
Так, что, понятно, что тут произошло?
Мы сейчас к чему ведём, что-то. Уже нить вообще потерялась.
Так, значит, смотрите. Мы доказали, что, допустим, там функция ограничена, да?
Ну, теперь говорим следующее.
Я этого даже не использовал.
Так, но это даже как... Ну, не совсем. Мы тут всё-таки говорим...
Если не стрелять, то, конечно, то же самое.
Да. Ну, в общем, смотрите. Ситуация такая.
Ну, допустим, если у нас минимум достигся, то мы всё доказали, да?
Да, напоминаем. Мы доказываем, что...
Так, что мы доказываем вообще?
А, мы доказываем унимодальность выпуклой вниз функции.
Вот мы это так...
Вот мы...
Кстати, да.
Так, вот эта функция вообще унимодальна или нет, кстати?
Да.
Смотря какое определение.
Ну, давайте сюда.
Да, если кричать, значит, до какого-то...
Не, ну, да.
Потому что, формально говоря, у нас, да.
Потому что хочется сказать, что функция на отрезке унимодальна,
если между А и В существует такой х, что от А до х она уплывает, а х до Б возрастает.
Да, заметим, что вот в этом конкретном выколотом случае на самом деле этого не происходит.
Уменяем определение.
Ну, сейчас, а если мы мерём, ну, х это правая граница, тогда да?
Ну ладно, на интервале тогда х она убивает, не на отрезке.
Ну, можно и на интервале, да.
Вот. Ну да.
Ну, замечаем, да, что есть вот действительно там погранзаставные случаи.
Но мы доказываем следующее, что, оказывается, либо функция на всём интервале убывает,
то есть либо функция строго там полностью убывает, но там конкретно на краю есть выколотая точка,
либо наоборот ещё может быть вот такое безобразие.
Вот. А во всех утверждается, что во всех иных случаях на самом деле минимум достигается.
Вот, если я правильно понял.
Доказательства.
Действительно.
Раз у нас на отрезке у нас где-то инфимум есть, да, может быть минус бесконечность, может не минус бесконечность, да?
Но заметим, что, то есть это означает, что существует последовательность х,
каких-то рандомных х, которые по значению к этому минимуму стремятся, правда?
Более того, так как эти х ограничены у нас на отрезке, то из них можно выбрать сходящуюся под последовательность.
Ну, помним, да, из ограниченной последовательности можно выбрать сходящуюся хоть куда-нибудь под последовательность.
И вот она куда-то сошлась.
Допустим...
Вот.
Ну, тогда что у нас получилось?
Допустим, что эта и по х сошлась куда-то строго между а и b.
Вот она сходилась, сходилась.
Вот она куда-то сходилась, сходилась, но нам достаточно рассмотреть, только, ну, понятно, что у этой последовательности либо есть,
или есть бесконечное число элементов слева, которое сходится, или бесконечное число элементов справа, которое сходится, правда?
Может и там и там. Но давайте рассмотрим, что, вот пусть слева trays ходится.
Тогда, смотрим...
Значит, куда они сходятся?
Ну, сходится, да, по значению они сходятся, скорее, вот, каким-то таким-то образом.
Ну а теперь предположим, что там это не инфимум, это не минус бесконечности, а какое-то вот это вот значение.
Вот к нему они как-то сходятся, но выяснилось, что в самом этом иксе значение этой функции — это не оно.
Но раз оно не оно, а это инфимум, значит оно больше. То есть реальная икса где-то здесь.
Что мы тогда имеем? Что мы тогда имеем?
Вот тогда имеем следующее. Что заметим? Рассмотрим какую-нибудь из этих точек, которые ниже ее.
Тогда заметим, что мы можем тут привести прямую и сказать, что справа от этого икса все должно быть строго больше.
Все должно быть выше этой прямой, как мы уже выяснили. Выяснили?
Вот. Ну а теперь заметим следующее, что если точка начинает приближаться к вот этой фиксированной точке,
то и вот этот вот угол начинает стремиться просто к пипополаву.
То есть если точка стремится сюда, то и угол стремится к пипополаву.
Ну тогда получается, что для любой вот такой прямой выясняется, что функция должна быть выше.
То есть получается у нас тут мы просто даже значение функции f' поставить не можем, потому что они все должны быть больше, чем что-то там бесконечно большое.
Вот. Но следовательно получается, если минимум ограничен, такого не бывает.
А если минимум, ну правда, если точки там стремятся совсем уж куда-то вот сюда, то легче от этого не стать.
Понимаете, да?
То есть если тут скоро угодно близко здесь и скоро угодно низко тут, то наклон там будет высокий.
То есть следовательно у нас два варианта.
Если у нас есть вот это вот стремление слева к какому-то x, то у вас два варианта получается.
Либо этот, то есть действительно, либо тогда f от x тогда равен действительно этому пределу и минимум достигся.
Либо у нас вот этого ничего справа от x не существует.
То есть единственный случай, когда у нас тогда происходит стремление слева к этому инфинуму,
это когда у нас этот инфинум достигается вот струра в b.
То есть вот получается такая вот последовательность.
Остается только теперь доказать, что в этом случае тогда действительно на всем отрезке от a до b на самом деле функция,
пока и мере на полуинтервале, функция действительно убывает.
Да, осталось только выяснить.
Там есть еще одна небольшая заглотка.
Там может быть минимум на полуинтервале граничит как бы с правым концом, но в самом правом конце выше.
То есть там может быть вот в самом низу нестрогое убывание уже.
В смысле?
Вот так что ли?
Ну вот там может быть равенство.
Ну равенство да, но это равенство еще минимум достигся.
А, да ладно точно.
Ну да, то есть конечно да, может быть действительно такое, но вот если какая-то вопрос может ли это быть так?
Ну если вот такая ситуация, то уже понятно, что...
Нет, ну можно сказать так.
Рассмотрим вот какую-нибудь точку.
Она выше этого инфинума.
Ну больше либо равна этого инфинуму.
Значит рассмотрим у этой точки маленькую-маленькую окрестность, которая заведома ниже этой точки.
И рассмотрим тут какую-нибудь любую точку f от x.
Ну вот, то есть мы здесь найдется то точка, которая лежит здесь.
Тогда проводим через нее прямую и говорим, что все что слева выше этой прямой.
То есть, по крайней мере мы доказали, что для любой точки верно, что все что слева больше ее.
А еще можно сказать, что этот инфимум все-таки не может быть мином бесконечности даже в таком случае.
Этот инфимум не может быть мином бесконечности даже в таком случае.
Ну что, там можно тоже вот сфиксировать эту точку где-то на сильной отрезке.
А, ну да-да-да, устремить и получить.
Ну красота, красота.
А еще нужно прокомментировать, что когда минимум достигается, он может достигаться на точке, на отрезке, либо на полу интервале, который как раз в границе примыкает.
Ну или на интервале, да и вы отличаться.
Ну да, ладно, не будем, наверное, прописывать полностью эту фугу, да, но тем не менее.
Тем не менее, да.
То есть выяснилось, да, оказался бы простой интуитивный факт, если функция выплыва вниз, то наверно, что она обнимотает.
Ну ладно, но правда, да, в подавляющей большинстве случаев функция будет все равно непрерывная, так что.
Господи, вот так хорошо работаются непрерывные функции.
Ну теперь просто, ну теперь просто выясняется, просто да.
А между прочим?
Ну она может быть только в концах не непрерывная вообще, потому что мы уже поняли, что она сначала бывает в том, что застает, если она убывает в каком-то месте с разрывом, то там опять наклон бесконечности.
Ну да, и как правило.
Да.
Ну вот, понимаешь?
Да, действительно.
Да, оказывается выпуклое значит непрерывное, хотя...
На интервале?
Ну хотя бы на интервале точно, да.
Так, ладно, давайте так.
Ладно, нет, это уже можно сформировать как утверждение, как теория, да.
Если F выпукло вниз на, соответственно, A, B, C, D, C, E, C, D, E, A, D, A, D, D, E, A, D, E, A, D, D, E, E, D, E, E, E, A, D, E, E, E, E.
Влез на интервале АВ, то F непрерывно на АВ.
Слушайте, что-то знакомое.
А у вас в курсе мотонализа не было такого утверждения?
Нет.
А сколько предполагалось через вторую проблему?
Нет.
Нет.
Нет.
Нет.
Там как-то стрёмно было.
Там было...
Бескорно.
Бескорно.
Ну окей.
Я ещё не уверен.
Ну ладно.
Не, ну какой-то выпуклый анализ у вас, кстати, должен быть.
Там чуть позже.
Да.
Вообще красивый теперь, конечно.
Да.
Окей.
Значит ладно.
Ну это для нас не особо даже важно.
Теперь давайте смотреть.
Значит, ну как-то и все это применим с задачей.
Ну вот.
Откуда мы можем брать вообще выпуклые функции?
Ну на самом деле, действительно, какие у нас примеры вообще
выпуклых функций?
Какие у нас примеры вообще выпуклых функций есть?
Ну, на первых, f от x равно...
Ну x квадрат.
Такая классическая выпуклая функция, да?
Ещё бывает x.
А ещё бывает такая...
Одна из самых красивых.
LOD x.
Да.
Это для любителей дифференцированных функций.
Или там констант.
Ну констант.
X плюс...
Kx плюс b, конечно, это святое.
Вот.
Что ещё бывает?
Ну глобально бывает x четвёртый.
Или там...
А, ну в общем-то x кубе бывает.
Ну на всяких интервалах, типа там...
От нуля типа до плюс бесконечности, конечно.
Вот.
Ну и так далее.
Ну тогда и синус какой-то можно ещё...
Тоже на маленьком интервале чуть-чуть.
Ага, на каком?
От, в принципе, пополам до нуля.
Да.
Да.
Вот.
Да.
Но неважно.
Ну а самое приятное, по камере если брать уже прям...
Что-то ближе к олимпиадам, то самое приятное на самом деле следующее.
То на самом деле верно...
Верны ещё всякие мистические теоремы о том, что если f от x и g от x выпуклына каких-нибудь там ab или выпуклына там...
Ну я не знаю, давайте ab напишу, хотя может быть и вот это, и вот это, неважно, да?
То...
То оказываются маленькие приятные вещи.
Выпуклы вниз?
Ну мы пока всё вниз.
Да, вниз.
Да-да-да, спасибо за уточнение.
Да.
Ну то есть мы, конечно, имеем в виду, я даже не буду...
Теоретически есть выпуклость вверх и там как бы верно всё то же самое, только в другом сторону.
Так, ну во-первых...
Начнём отрицать, что, во-первых...
f от x плюс g от x выпукла вниз.
Да, то есть, конечно, да, через вторую производную это было бы очевидно, но...
Я, кстати, сейчас прочитал, что любая выпуклая на интервале функция, она дифференцируема кроме счётного числа точек и дважды дифференцируема почти всюду.
Так что...
А почти всюду и кроме коней счётного числа точек, а что такое?
Почти всюду это кроме множества точек меры ноль, оно будет не счётным.
Понятно.
Какая красота!
Господи, выпуклая функция, они хорошие.
Множества точек меры ноль, не счётные.
Кантру?
Кантру.
Так вот, ну ладно, во-первых...
Ну, тем не менее, пока не реван, эта серия может доказываться без всяких этих ваших непрерывностей.
А, нет, или да.
Ну, потому что действительно, если у нас есть, допустим, как видите, два графика, есть один график, и мы говорим, что вот этот отрезок целиком лежит в над-графике функции f.
И возникает ещё какой-нибудь там вот этот вот.
И есть вот над-график функции g, вот так вот.
Да?
То есть, над график g.
Ну, тогда заметим, что если мы сложим вот этот отрезок и от этот отрезок, то получится тоже отрезок.
Вот с примерно вот этой, ну, такой, ну, вот этой, ну, вот этой.
И заметим, что сумма функции f.x будет всегда выше вот этого отрезка.
Так это понятно, что я говорю?
Или нет?
Это страшно.
Это мы когда-то решили другого направления.
Нет.
Нет, почему?
У нас есть определение, есть над-график, над-график, над-график, над-график, над-график, над-график, над-график.
Нет.
Нет, почему?
У нас есть определение, есть над-график.
Да?
Мы сейчас взяли точки на графике.
Да.
А, ну самое главное.
Нет, смотрите.
Мы говорим следующее.
Фактически мы должны доказать следующее.
Ну, что нужно доказать для того, чтобы над-график, соответственно, выпал.
Ну, по сути, я вот как жаль, что надо доказать, что если мы возьмём любые две точки, 2x и соединимых отрезков,
то тогда этот отрезок будет целиком лежать в над-графике.
Правда?
По сути, ровно это мы и доказываем.
Вот.
Да переча.
Как же мы доказываем?
Теперь мы говорим следующее.
Вот есть функция f от x.
Все значения функции f между этими x ниже этого отрезка.
Правда?
Ну ладно, не выше.
А все значения функции g они не выше этого отрезка.
Правда?
Но отсюда будет...
Но когда мы их сложим, окажется, что этот отрезок плюс этот отрезок, да, равно тоже линейной функции, то есть вот такому отрезку.
И окажется, что у суммы все значения между вот этими x они не выше, чем вот этот отрезок.
Теперь мы доказываем.
То есть позируется просто на том, что на этом отрезке функция f мажорируется линейной функцией и функция g мажорируется линейной функцией.
Значит из суммы тоже мажорируются линейные функции, причем проходящие через соответствующие две точки.
Значит получается то, что надо.
То есть этот отрезок функции лежит целиком в над графике.
Все, кайф.
Так что даже если функцию случайно не дифференцируемо дважды в этих точках, то ничего страшного.
Ну что еще для нас приятно?
А еще для нас приятно, что минимум из f и g тоже выпукл вниз.
Мимимум из f и g тоже выпукл вниз.
Может максимум.
А может и максимум.
А вот что они оба?
Смерть тебе пора была вот это?
Ага, ну даже да.
Ой да, подляночка.
Да, как это? Какое красивое, вообще радостное утверждение,
пока просто не проверить, а верно ли оно.
Потому что да, конечно, на самом деле, конечно, нет.
Потому что если функции выглядят вот таким вот образом,
то вот такой вот минимум откровенно не будет.
Максимум.
Да.
А если, ну вот.
Вот если максимум, да.
С максимумом такой тест.
Уже ничего не важно.
С другой стороны, правда, тут уже сразу сомнения.
Может там максимуме тоже можно контракт пример привести?
Почему?
Ну это как?
Хочется сказать, что пересечение двух эффектов умножится.
Да, совершенно верно.
А, ну так и есть.
Потому что над график максимума это пересечение над графиков, собственно, этих двух функций.
Да, помните, объединение выпуклых множеств не обязано быть выпуклым множеством,
потому что, ну потому что вот такой же ремонтчик можно всегда воображать и, собственно, радовать.
Шляпка выпукла, ножка выпукла, шляпка с ножкой, нет.
Все просто.
А вот пересечение выпуклых множеств оно выпукло,
поэтому и максимум здесь выпукл вполне себе вниз.
И это очень удобно.
И в результате, знаете, это позволяет, то есть на самом деле нет,
то есть это позволяет в некоторых задачах действительно просто доказывать,
что да, тернарным поискам искать минимум здесь можно.
Ну вот.
Значит, смотрите.
То есть, например, вот классическая задача, возможно, здесь не сталкивается,
но одна из моих ремней звучит так.
Значит, так она звучит.
Так.
Так, сейчас я тут скажу и...
Значит, звучит она так.
Значит, у нас есть гонка.
Гонка заключается в том, что там по прямой.
Когда вы пришли на гонку, каждый товарищ уже находился в точке x и t
и несся со скоростью v и t.
Вправо.
И вы, ну вы действительно каким-то образом поняли,
или, по крайней мере, поверили, что действительно все это было в прямой.
И вы, ну вы действительно каким-то образом поняли,
что действительно все это было в прямой.
И вы поверили, что все люди на гонке, естественно, бегут всю гонку с одной и той же скоростью.
Конечно.
Ну, в общем, каждый бежит, что есть мочи, конечно.
Что фустанит, ну не...
Так вот, они, короче, бегут.
Да, кто-то бывает там бежит сзади, но догоняет там всякое бывает.
Ну и так вот, не важно.
В общем, бегут, бегут, бегут.
Они бегут не с одной скоростью.
Они бегут не с одной скоростью.
Нет, каждый, скажи так, скорость каждого постоянно.
Вот так.
И мы хотим для какого-то момента времени узнавать, кто самый первый сейчас?
Нет.
Еще круче.
Мы хотим их сфотографировать.
Бегущих.
Вот хотим прям вот взять и сфотографировать, чтобы всех увидеть прям вот всю гонку.
И мы хотим, чтобы расстояние между...
Да, но очень хочется, чтобы они, конечно, попадали в как можно более меньшего размера кадр.
И тут нам становится жутко интересно, да.
В какой момент времени этот кадр будет поменьше?
А, понятно.
Вот.
Вот утверждение.
Значу нужно решать тернарным поиском.
За О от М умножить на логарифом тернарного поиска.
Ну, понятно.
Ну да, два варианта.
Так, все, нам минимум какой-то искать.
Давайте напишем тернарик и не будем париться.
Тернарик всегда работает.
Ну, как бы он всегда работает, когда вы ищете пересечение прямых.
Кстати.
Не, реально, на самом деле, смотрите.
Вот у вас точечка тут бежит по Т, да.
Вот по 1 плюс, там по 2 минус по 1 Т, да.
И заметим, что расстояние до этой прямой сначала уменьшается до нуля, а потом вот растает.
А если у нас выраженная сущность?
Какой?
Ну, типа такая прямая.
С сетки координат.
И что?
А какая разница?
Все равно, видите, расстояние до этой прямой сначала убывает, потом взрастает.
Не знаю.
Все.
Так что давайте просто это подходящее Т найдем тернарным поиском.
Ну, правда, для этого надо уметь искать расстояние от точки до прямой.
Ну, у вас там есть какое-нибудь заявление?
Модуль АХ плюс Б ИГР плюс С поделить на корень за квадрат плюс Б квадрат.
Можете мне делить?
Вон там, в этой статье в интернете, да.
Там можно не делить, потому что, ну, понятно, все одинаковые номеровку будут уметь.
Чего делить?
Ну, можем не делить, а на АХ плюс Б квадрат, потому что для всех точек остается одна тема.
А, да, да, да, да.
Ну да, а потом заметим, что да.
А потом заметим, что если не брать модуль, то функция сначала отрицательная, потом положительная или наоборот.
А потом заметим, что она меняется так красиво, что можно заливать единицы там.
Ну, это да.
Ну, это уже мелочь.
Но при желании не заморять.
Ну, тут понятно, почему.
А здесь действительно, да.
Да, но здесь действительно, ну вот.
Но здесь действительно тоже оказывается тракторный поиск применения.
Почему?
Потому что максимум, буквально, функция плавнее с минимум плаве, а мы из максимума читаем минимум.
Да, потому что вот есть такая функция f at least как максимум х.
Ну, смотрите, что нас интересует?
Нас интересует максимум х и т, т минус минимум х и т, т.
Мы исследуем это как функцию от t.
Ну, а теперь заметим, что, смотрите, х и т от t это линейная функция.
Линейная функция выпукло вниз, правда?
Следовательно, максимум тоже выпукло вниз.
Почему все-таки она называется выпукло вниз?
Откуда это выпукло вниз?
Выпуклась вверху от него.
Ну, потому что выпуклась как-то интуитивно, по-моему, выпуклась все-таки куда-то в сторону вниз, где сидит.
Ну, хорошо.
То есть как бы, ну как-то, я не знаю.
Ну, как сказать, вот допустим, если у меня сейчас вот живот неожиданно расти начнет, да, останется выпуклым, он же будет выпуклым в вашу сторону, да?
Ну вот, так что вот.
Здесь он тоже, если он начнет вот как бы это разрастаться, то, соответственно, это будет вниз, поэтому, видимо, такая логика.
Так, теперь заметим, что минимум.
А, теперь приятный факт.
Мало кто знает, что линейная функция не только выпукла вниз, но и выпукла вверх.
Да, можно доказать, что это единственный случай. Если функция и выпукла вниз, и выпукла вверх, значит, что она линейная.
Ну, это очевидно.
Да, да, совершенно верно.
Вот.
И тут выпукла вверх.
Но, правда, заметим, что минус выпуклая вверх функция и выпуклая вниз функция.
Так что мы тут суммируем две выпуклы вниз функции.
То есть, короче, это выпуклая вниз функция.
Еще и неприютная, кстати.
Так что минимум существует, и его можно искать тогда в этот поиск.
Красота.
Плагу дать.
Так.
Так.
Так что, в принципе, от подобного рода соображения можно доказывать, что в некоторых задачах минимум можно искать тогда в этот поиск.
Так, да, я понимаю, что...
Так.
А, у вас там сейчас пара будет, да?
А или конкретно у вас ни у кого пара нет?
Это не важно.
В смысле, не важно.
Ну, я...
Что?
Что?
Расписание будет.
А, по расписанию будет или нет?
У меня будет расписание.
Нет, я смотрел расписание и подумал, что у кого-то из вас, возможно, все-таки что-то будет.
Было.
Нет, у кого-то что-то было, а у кого-то что-то будет.
То есть, вы делитесь на две части.
В смысле, было так, что у нас что-то будет. Отменили.
Перенесли.
А, отменили?
Ладно.
Нет, просто прийдите, вот просто у этой темы есть, на самом деле, такое красивое окончание.
Вот, поэтому сейчас я не хочется его откладывать через неделю.
Просто, знаете, как...
Просто, как это...
Ну, смотрится это так.
Ну, я тут, конечно, мог бы рассказывать про то, как искать там...
А, ну, естественно, там понятно.
На самом деле, можно искать таким вот образом действительно, допустим, ближе...
Вот, допустим, даны n точек, и надо найти точку с минимальной суммой расстояния до них.
Да, это можно искать как...
Ну, что это?
Ну, это можно искать тернариком, но, на самом деле, не нужно.
Ну, и здесь, на самом деле, просто полезно знать, что, на самом деле, минимум достигается где-то на отрезке между медианами.
Или если количество точек нечетно, то как бы медиально.
Почему?
Ну, просто потому что, если вы рассмотрите, как эта функция суммой расстояния устроена, то...
Там, видите, она будет устроена каким-то вот таким вот красивым образом, где вот...
Каждый раз, когда вы проходите точку, наклон будет увеличиваться на два.
Ну, потому что, как бы, когда вы тут идете, то вы, как бы, ко всем точкам приближаетесь, к шести точкам.
А когда здесь вы к пяти приближаетесь, от одной отдаляетесь, то получается там, типа, минус уже не шесть dx, а тут минус четыре.
Ну, понятно, Вайка, да?
Вот, поэтому там получается, тут можно искать медиану.
Ну, вот, если вы ищите, минимизируете сумму х-х и т.д. в квадрате...
Ну, здесь все еще дубее.
Вы можете, честно, раскрыть это там, собственно, посчитать искребить.
Там, честно, в вершину парабола.
Ну, знаете, графиком этой функции является вот эта парабола, ветра которой направлен вверх, там, в каком классе у нас это было, да?
Вот.
Ну и, в общем, там, опуская все вычисления, окажется, что, в общем, эта вершина окажется в точке, в общем, как это ни странно, в среднем юрпедическом.
Ну, просто так получится.
Вот.
Ну, а что приятно?
Приятно тут заключается в том, что теперь отсюда мы плавно можем перейти в двумирие.
Потому что, как можно себе вообразить, функции бывают выпуклые вниз и функция двух параметров.
Правда?
Ну, там, правда, такие трехмерные графики будут, вот такие красивые с чашечками, да?
Понимаете, да?
Ну, заметим, что если у вас функция действительно выпукла вниз от двух параметров, то заметим, что минимум в них тоже можно искать.
Только уже не одним тернарным поиском, а вложенным тернарным поиском.
Ну, давайте.
Так.
Так, ладно.
Называется надписать вложенный тернарный поиск или понятно, о чем речь?
Давайте все-таки обсудим.
Ну, хорошо.
Давайте, смотрите.
Вот задача.
Вот у нас есть какая-то вот, там, X, Y, и вот какая-то вот такая вот мистическая функция.
А у нас какое расстояние между точками?
Ну, пока мы жили напрямую по барабану.
Мы же сейчас в двухмерное переходим.
А когда мы переходим в двухмерное, а мы сейчас уже даже забыли о расстоянии, мы сейчас просто говорим, что у нас есть выпукла вниз функция.
Да, выпукла вниз с тем же определением, естественно.
Ну вот.
Как искать в ней минимум?
Как искать в ней минимум?
Ну вот, оказывается, интересный факт.
Заметим, что мы можем зафиксировать какой-нибудь игрок, да?
Вот если мы зафиксируем какой-нибудь игрок.
Вот он.
То окажется, что тогда из этого графика выпилится какая-то вот такая параболка, правда?
То есть это будет выпукла от одного параметра функции, и с помощью тернарика вы этот минимум можете даже найти.
Правда?
И тогда получится, что у вас будет получиться такая функция, то есть такая F от G от игры.
Эта функция минимума прификсирована в игре.
Но заметим, что эта функция, ну так как все эти точки лежат на графике, то возникает подозрение, что эта функция...
Тоже выпукла.
Тоже выпукла вниз.
Не очевидно.
Не очевидно?
А смотрите, ну потому что смотрите, вот у вас при одном игреке, вот допустим у вас при одном игреке нашелся минимум, да?
И при другом игреке вот где-то, при другом игреке тоже нашелся минимум, да?
Видите, да?
Там может быть идет пониже.
Тогда смотрите, давайте мысленно вообразим себе эти две плоскости, да, вот параллельные, да?
И вот соединим прямой.
И прямой.
Тогда заметим следующее, что если брать точки X и Y, ну вот, то есть как бы это трехмерный отрезок, да?
Но вот если брать вот ниже, что тут на плоскости происходит, да, вот эти вот, то есть это плоскости X и Y, да?
То тут как бы в проекции получается там пум-пум-пум-пум.
Вот тут точка, и тут пум-пум-пум-пум тоже точка, да?
Но тогда можно заметить, что во всех этих точках X и Y, ну вот, то тогда во всех этих точках X и Y у нас действительно значение, ну по выпуклости не превосходит вот этой вот прямой, правда?
Но тогда получается и минимум при соответствующих игроков тоже не будет превосходить этой прямой, правда?
Ну вот.
Ну собственно, и всё.
А мы
Вот эта вот вектикальная плоскость, а, ну, на плоскость перпендикулярную x в оси x.
Так, сейчас вот эти вот лишние сотру, давайте, да, эта плоскость должна быть слева, конечно.
Да, да, да, да, все-таки. Вот.
Так, смотрите, вот давайте вот такую вот спрецируем, что вот перпендикулярная оси x.
И тогда получится, что функция этих минимумов встроена так.
Для вот этого игрока она равна, то есть для вот этого игрока она равна вот этому.
Допустим, а для этого игрока она равна вот этому, да, вот тут у нас такой отрезок, да.
Ну тогда я утверждаю, что минимум в каком-нибудь игроке между ними, вот в этом вот, да.
Вот, да, тут сложно рисовать правильную картинку.
То есть он тоже будет где-то между вот этими точками.
Ну потому что при таких игроках как минимум одна точка ниже этой прямой да будет.
То есть вот примерно так это можно себе вообразить.
Да, можно попытаться это аккуратно доказать в гибридическом, но увидеть можно это ровно таким образом.
И тогда получается, то есть идея такая, то есть вы ищете тернарным поиском, то есть ищем тернарным поиском,
тернарным поиском, минимум функции g от игр.
Где g от игр равно минимум по x, действительно f от x игр.
Понятно, да?
Получается, вы запускаете тернарик и в тернарном поиске делаете вызовы функции g.
А когда вызываете функцию g, вы внутри вызываете второй тернарик уже по x.
То есть это называется вложенные тернарики.
Вот, то есть получается, что если у вас возникают какие-то тоже функции там,
функции типа там расстояние между точками там, расстояние между точками в квадрате там,
то оказывается как раз тоже выпуклые функции.
Ну легко себе это вообразить, да?
Или там линейная какая-нибудь функция, график которой является плоскостью на этот раз, да?
Это тоже выпуклая функция.
Ну график в 3D, конечно.
Нет, ну вот.
То есть получается вот такая тоже вложенная тернарика вполне возможна.
Вот закончить это хочется вообще, на самом деле, очень красивые задачи с полуфинала 10-го года.
Которая считается как классическая задача на пересечение полуплоскостей.
Вот, так, сейчас.
Так, да, была.
А, ну собственно, задача по большому счёту сводится в следующее.
Сейчас, может надо из полуфинала, ладно, набрал, ну не важно.
Значит, смотрите, дан выпуклый многоугольник.
Я хочу поместить внутрь этого многоугольника какой-нибудь круг.
Внимание, вопрос.
Какого максимального радиуса круг я могу туда поместить?
Это полуфинала?
Ну вот, то ли такое, то ли что-то типа того.
Хотя, может, я...
Чего?
Ну, как бы.
А в 10-м году это была задача с полуфинала.
Ну хотя ладно.
Хотя нет, может...
Хотя нет, может...
Хотя нет, может...
Хотя ладно, нет, это неправда.
Хотя нет, я набрал, там, по-моему, возможно, была задача...
Там другая была задача на пересечение полуплоскостей.
Ну ладно.
А может и...
Я думаю, за N-лог можно.
Да, вопрос, чтобы за N-лог чего?
C.
N-лог квадрат C.
Ну, есть два решения. За N-лог N?
Ну, вообще так, есть решения за N-лог C?
Ну вот.
Ну вот. А есть решения...
Ну ладно.
За N-лог квадрат?
Ну ладно, сейчас дойдем.
Ну, смотрите.
Ну, скажем так, да.
Есть решения за N-лог C.
Ну, действительно, есть решения...
Ну, во-первых, понятно.
То есть, действительно, есть решения просто.
Давайте решим задачу по поискам по ответу, да?
Как мы будем делать эту задачу по поискам по ответу?
Да, очень просто.
Ну, во-первых, давайте поймем.
Как это делается?
Ну очень просто.
Заметим, что эта точка должна находиться с этой стороны,
то есть, где-то должен находиться центр.
Относить над этой прямой,
он должен находиться на расстоянии не менее, чем R.
Вот, давайте проведем эту прямую на расстоянии R.
И говорим, что центр должен лежать на этой полуплоскости.
И еще, вот относить на этой полуплоскости, он должен лежать слева.
Получается N полуплоскости...
Понимаете, да?
То есть, в принципе, классическое решение вот такое.
Стоит сток-сист, пересечение полу-плоскостей.
Получается красивое решение за n лог вашего без поиска.
Но при, может быть, чуть меньших ограничениях есть на самом деле...
Оперечения полу-плоскостей за...
Но в данном случае они не отсортированы, поэтому получается за линию.
Потому что, видите, они по полягому углу уже отсортированы заранее.
Ага.
Классно.
Вот. Так что получается красота.
Вот. Но на самом деле, если вас n лог квадрат С не сильно пугает,
то есть, на самом деле, более красивые решения.
Ну, на мой, по крайней мере, скромные.
Которые вообще никаких пересечений полу-плоскостей от вас не потребуют.
Загоняй точку центра, пожалуйста.
Да, я упреждаю, что эту точку можно затырнарить.
Как затырнарить?
Ну, потому что, давайте думать, вот находится, лежит у нас точка, да?
Как понять, какой максимальный радиус с центром в этой точке можно забавить?
Но, очевидно, надо найти расстояние до этих прямых,
и из этих расстояний взять минимум.
Да, иногда расстояние бывает, там расстояние может упасть в тупой угол,
но это означает, что до соседней ответства расстояние еще меньше.
То есть, фактически, у нас высекает такая функция f от x и как
равно минимум по i равно от 0 до n-1
расстояние от точки x и как,
до, соответственно, прямой, там, a и минус первое, a и t.
Понятно, да?
Ну, теперь, хочется сказать, что, да, хочется сказать, что эта функция,
нам нужно найти максимум, но хочется сказать, что эта функция выпукла вверх.
Да, но высекает проблема.
Для этого, конечно, мы могли бы сказать, для этого хочется сказать, что
расстояние от точки до прямой, это функция выпукла вверх.
И, действительно, но если мы бы образили в себе график функции,
расстояние до прямой,
как он выглядит?
Ну, она выпуклая вниз.
Да, то он вот такая, да, он вот такая жанрочка.
Думаю, он ориентированный, тогда он будет вверх и вниз.
Да, и вот в этом-то идея.
На самом деле, давайте,
то есть, давайте скажем, что это расстояние будет ориентированным.
То есть, давайте скажем, что наугольник у нас идет против часовой стрелки.
Вот он.
Вот.
Давайте скажем, что наугольник идет против часовой стрелки.
И будем говорить, что если точка слева, то расстояние больше нуля,
а если справа, то меньше нуля.
Тогда график будет уже просто честная плоскость,
а плоскость это функция выпукла вверх.
То есть, заметим, нам уже плевать, там не надо проверять,
точка лежит внутри наугольника или вне.
Просто, то есть, просто тогда в случае чего минимум будет отрицательным и ничего страшного.
Вот, собственно, и все.
И тогда получаете, что эту точку теперь без всяких там этих ваших пересечений полуплоскости,
а там ограничений, возможно, на тысячу было,
можно без того, чтобы это искать,
просто двумя вложенными тернаритами.
Можно без трюка с ориентированным состоянием,
можно просто ограничить область, на которой мы будем тернариться.
Ну, чуть неприятнее писать.
Собственно, если за теркер надо идти,
достаточно просто пересечь прямую с прямоугольником
и выбрать снигель к лучкому диапазону.
На этом диапазоне пункты должны быть по понятной причине,
потому что все расстояния с понятием знают.
Ну, как сказать...
Ну да, но правда...
А, ну, можно, но...
Я понимаю, что это не бесполезно,
просто интересно, но это нельзя.
Ну, не знаю, но, по-моему, этот трюк,
по сравнению с тому, что предложено,
сильно упрощенеет.
Так что, на самом деле...
Вот.
Да, ну, просто вот...
Ну, на мой взгляд, действительно красиво.
Эта точка, конечно, не идеальна,
потому что тут лог квадрата, там вот лог.
Получается этого радиуса.
Вот, но тем не менее...
Но тем не менее, вот получается
достаточно хорошо.
Так, ну вот.
Ну, это практически все, на самом деле,
что я хотел сказать про выпуклость, на самом деле.
Ну, то есть у нас, скорее всего, там вращающиеся,
касательные нас еще, конечно, в следующем занятии
обязательно встретимся,
но это будет уже в следующий раз.
Ну, а на сегодня тогда все.
