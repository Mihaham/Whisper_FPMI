И давайте тогда воспомним, собственно, о чём мы вообще
говорим.
А мы не можем так вливать биномиальные кучи?
Биномиальные кучи?
Ну, тефетически мы можем, в чём проблема?
Тогда у нас...
Ну да, всё работает, завод единицы, да, инстакт работает.
Ну, хотя там, ну не совсем так, то есть там есть нужда
по модулю одной мистической операции.
Дело в том, что, смотрите, у вас там жёсткий логарифм
возникает, вот мы ещё не дошли до операции как удаление
минимума.
Тут ещё вот такая проблема есть.
Вот, то есть, и она достаточно нетривиальна, то есть видите,
это настолько нетривиально на самом деле, что, как вы
помните, у нас даже в интерфейсе не прописана операция delete
в принципе, delete просто.
То есть удаляем мы только минимум.
То есть в результате...
Ну вы иди наоборот, преймись.
Неа.
Чего, а в смысла кучи тогда?
Ну вот...
Не, у нас есть find min.
Ну есть find min, есть delete min, не путать.
Нет, есть просто delete.
Не, нету.
Если есть...
Так, значит, если есть, значит, как говорится,
можете побить того, кто вам это сказал.
Да.
Ну вот и безобразие, что мы это дописали.
Значит, всё.
Значит, во избежание, значит, паники.
Сейчас мы просто честно пропишем, какой интерфейс тут есть.
Вот, прям совсем.
То есть я на всякий случай даже себе статью открою,
чтобы тут уже лишний раз не перепутать.
А то, знаете...
Значит, какие у нас есть операции?
Операции есть.
Значит, операции есть.
Create.
Значит, отыть.
Вот, кстати, кто-нибудь знает вообще, что это за буквы вообще?
Уйть.
Чего?
Не, все это вот.
А это...
А это уйть.
А это из красивой возможно?
Не знаю.
Это из зюм.
Ну да.
Скажите, пожалуйста, это всё-таки биномиальная куча.
Мы можем снимать за вот единицы?
Ну...
Получится.
Ну, по модулю правильного делитмина да, получается.
Ну и нет.
Но на самом деле, что?
Давайте вот, кстати...
По модулю правильного делитмина, то есть если умеем снимать, то неправильно изон долеем.
Нет, то есть, ну...
Ну, типа того.
Ну, просто смотрите.
Просто биномиальная куча, помните, когда мы удаляли,
нам приходилось это делать реально за логорифом,
за счёт того, что у удалённого корня оставалось логорифом детей,
с которым мы должны были что-то делать.
То есть сейчас мы будем пытаться,
всё-таки из-под этого корня,
ну, если забирать вперёд,
мыслить по принципу,
так, жила была у меня вершина, так я её удалил,
так, давайте на место её достанем
кого-нибудь там из детей.
Вот.
То есть это будет приводить к тому,
что там, называется,
дети будут как-то схлопываться
и становиться меньше.
И вот только тогда, когда мы обнаружим,
что уже как минимум половина детей убилось,
вот тогда, в этот момент,
начинаем действительно
из этих детей создавать там новую кучу
и куда-то там её добавлять.
Вот.
Это если вот вкратце на уровне идеи,
то есть там поэтому амортизация начнёт работать.
Вот.
Значит, смотрите,
о, кстати, у меня идея.
Так, давайте-ка я сделаю то,
что можно сразу сделать.
Как вы это даете?
Это называется, что только я в статью смотрю?
Давайте-ка в статью будете смотреть,
о боже, кстати.
Нет.
Не, кстати, да.
Вот, кстати, интересно, я даже
никогда не натыкался на описание этой структуры
на отличном английском языке.
Ну ладно, не то чтобы я искал на японском,
конечно, но
так, что это?
Ой, испанский.
Ой.
Ух ты.
Чё придумал?
А, и тут выясняется,
что эта статья у вас уже там в группе
ВКонтакте давно есть.
Чё вы молчите?
Так что да.
Так что, по идее, да.
На всякий случай, да. Можете, да.
Можно следить, чтобы убеждаться, что я тут
не сильно наврал.
В случае чего, как бы это официальный
первоисточник.
Делит.
А, всё-таки есть.
Вот скотина.
Вот скотина.
Ну ладно.
Ну ладно. Нет, хотя, погодите.
Ну ладно.
Не, ну почему не хватает? А, икса не хватает.
Ладно, давайте.
Вспоминаем интерфейс.
Так.
Есть melt.
Есть delete.
Да, причём главное,
по описанию, да, всё нормально.
Просто взять и удалить элемент.
Ну ладно, удалим, что делать.
Ну да, видимо, да, видимо, я туда же
подсматривал, да.
Ну, да, тут всё за 1.
Кроме вот этого.
Это у нас, напоминаю, за log1
делить на епсилон, да.
Эпсилон, напоминаю, это ярко
выбранная константа от 0 до 1 и 2.
Вот.
И, соответственно, да, тут всё
омортиировано.
Но, напоминаем,
кодовый смысл, да.
Помним, да, что куча
конечно, да, она вот
любит искать минимум, но это не точно.
Не точно в каком плане.
Вот в таком вот.
То есть это означает,
что мысленно,
вот у нас есть этот вот элемент,
допустим, x.
Вот.
То есть у каждого элемента x есть,
так сказать, ключик, key.
Это реальное значение.
И есть, напоминаю,
псевдоним.
Мы его будем ck называть.
Вот.
Мы гарантируем,
то есть мы говорим, что
ключик всегда меньше
либо равен этого псевдонима.
И что мы ещё говорим?
И говорим, что куча будет искать
минимум именно по псевдониму,
потому что ей так удобнее.
Вот.
Но при этом она гарантирует,
что не более,
чем
εн элементов
называется верно,
что ключик строго меньше
своего псевдонима.
Вот.
В каждый момент времени
в куче, если было верно,
что в кучу или там
в те кучи, из которых она была смелдена,
собственно, было
суммарно вставлено
не более чем n элементов.
Так.
Это
нет, позиция тут
вообще ни при чём.
То есть позиция у нас возникала,
когда мы пытались доставать эти элементы
в каком-то порядке их,
записывать в какой-то массив.
Сегодня мы об этом
даже вспоминать не будем.
Да, в прошлый раз мы
обсуждали, то есть это всё касается того,
что мы обсуждали, что с этой кучей,
с таким интерфейсом можно вообще делать.
Оказалось, что что-то таки можно.
Вот.
Но сейчас мы говорим, что с точки
само, в само все кученьков порядка нет.
То есть просто она
гарантируется, что она там
присваивает элементом какие-то псевдонимы.
В общем, не более, чем у
ε умножить на n элементов. Эти псевдонимы
соответственно
отличаются от самих элементов.
Ну, как уже было сказано,
на самом деле, да. Что будет, если
ε будет стремиться к нулю?
Ну, достаточно быстро. Если ε станет
1 делить на n, то на самом деле
у нас будет абсолютно корректная куча,
у которой из порченных элементов
будет 0.
Вот.
Ну, вот.
Но может быть и наоборот.
То есть если ε будет равно, скажем, одна вторая,
то это означает, что до половины всех элементов
могут быть
попорчены. Причём половины от тех,
кто был добавлен, а не от половины тех,
кто ещё остался. То есть, как вы помните,
ε равно одна вторая. Если мы добавим
100 элементов, а потом
достанем 70, то в оставшейся куче
все 30 могут быть попорчены.
Это приведёт к тому,
что все эти операции будут
буквально работать за 1.
Если мы даже ещё добавим 20, они всё ещё могут быть
все попорчены, по идее.
Да, да, да.
Да, совершенно верно.
Совершенно верно.
Но, тем не менее,
это каким-то мистическим образом
ещё что-то полезное делает,
что выищет, но это можно обсуждать.
Так, а?
Можно такое, что если у нас, опять же,
ε одна вторая,
у нас куча 100 элементов,
и мы 100 раз достанём минимум.
Он может 99 раз
дать что-то не правильное?
Вполне может.
На самом деле, ε равно одна вторая,
для этого даже не нужно.
Потому что, допустим,
вы добавили, допустим...
Допустим, да, при ε одна сотая
вы добавили 100 элементов.
Тогда, предположим, что этот единственный
испорченный элемент – это единицу,
но испорчился он, скажем, до бесконечности.
Тогда, по факту,
когда вы будете доставать элементы,
они достанутся в порядке 2, 3, 4, 5,
и так далее 100, и в конце один.
Это нормально.
Вот.
Ну вот, да.
Но обратите внимание не то, чтобы плохо
получилось на самом деле.
То есть, как бы, и TeamSort после этого
может залинивать работы.
Но количество правильных ответов у нас убийственное.
Ну, как сказать, да.
Ну...
Как бы, допоминаю, они почти правильные.
Почти.
Это структура данных о том,
что у нас бывает иногда, что у нас устраивают
почти правильные в некотором смысле ответы.
То есть, знаете,
в контроле физики есть принцип неопределённости
физинберга, да.
То есть, там как-то выясняется, что
в пределе там, как бы, чем
там называется там...
Там как-то...
Ну вот, сейчас.
Как там было, что-то действительно
произведение там, что-то...
Какое-то, что... Сейчас.
Сейчас.
Да.
А, тут и оно, что она мне не моя, поэтому не будем
заморачиваться, да.
В общем, лучше гуглоните на эту тему.
Там просто тоже смутно пошло
что-то на эту тему,
на самом деле, тоже.
Что там, что-то тем...
Короче, точных ответов не мешает.
Короче, да, да.
Ну, вообще так, что там, да, что-то точно...
Грубо говоря, там, типа, произведение
точности, координаты
на
точность энергии
что-то нам равно, в принципе,
единичкой условной.
Ну да.
Соответственно, можно либо
точно поделить координату, либо
энергию, но не другую.
Ну да, окей, ну вот.
Ну да, окей, хорошо,
спасибо, спасибо.
Вот, ладно.
Так, так, все, ой, если мы сейчас еще и физику пойдем,
Господи.
Не надо.
Такое хорошее задание, пойти в физику, да, ну да.
Ладно.
Начится, смотрите. Нет, ну как бы,
он хотел на ПМФ, он уже там, все.
Вот.
Впрочем, у вас еще есть шанс.
Так вот,
господа, внимание.
Итак, теперь пришло
время примерно понимать,
как у нас действительно
будет устроена куча.
Итак,
ну, как мы уже с вами начали
говорить, что она будет
состоять
из набора
биномиальных деревьев.
Вот.
Значит, ну, как
будет выглядеть биномиальное дерево?
Вот, давайте попробуем это
изобразить.
Вот. Ну, например, значит,
ну, во-первых, действительно у нас обязательно
будет вершина.
То есть, биномиальное дерево состоит
из вершины. Вот, давайте будем считать ее
ноди.
Вот.
Прям вот капсом тут написано.
О, я даже побольше нарисую.
Что
будет храниться в вершине?
В вершине будет храниться
ну, конечно же, ключик.
Вот он.
Так.
Ну,
ладно, хотелось бы хранить ключик,
но ключик мы хранить не будем.
Псевдоним?
Да. Конечно же, мы будем хранить
псевдоним.
Да, мы будем хранить псевдоним. А, вот у меня
маркер от псевдонима.
Так.
Что нам еще надо?
Ну, неотъемлемой частью каждой вершины
является его величество ранг.
Вот.
И что там у нас еще?
Ага, ну, логично
да. А, ну, конечно же, давайте еще
скажем. Ну, во-первых, это
next child, конечно.
То есть, помните, да? То есть, у нас
помните, да, что как
мы храним несколько детей у вершины? Мы
говорим, что у нас есть несколько экземпляров
одной и той же вершины, правда, с разными
рангами.
Вот. То есть, вот будет
у нас такой next.
Нет, это не next, это child.
Будет у нас ребеночек
и будет у нас next.
Так.
И неожиданно
вот такая еще вещь.
Так.
Так.
Вот такая.
О.
О.
Тут даже два
указателя будут на нее смотреть.
Дело в том, что это лист.
О.
Ну.
Значит,
как я сказал? Дело в том, что...
Да.
А. Ну, давайте, как бы...
Если очень хочется, я могу тут
как бы нарисовать, что это реально
список.
Ну.
На самом деле можно...
Если раз уж мы конец храним, то можно и
односвязно. Это не проблема.
Так вот.
Так вот. Именно
в этом списке
хранятся ключики.
Значит, на самом деле, за счет чего
мы будем экономить? Да?
Почему эти...
На тему псевдонимов. Дело в том, что каждая
вершина будет хранить несколько
на самом деле ключей.
Про каждый из этих ключиков
будет известно,
что ключик меньше
либо равен соответствующего
псевдонима.
Ну, в анализе, когда мы будем
анализировать, мы всегда будем говорить,
что у нас, как бы, если в списке
количество элементов отлично
от одного, то можно лучше
считать, что там все попорчено уже.
Сразу.
Вот.
Ну, а соответственно...
Ну, вот. Ну, на самом деле, да.
Нет, на самом деле так. В основном, конечно,
да. То есть будет...
Чаще всего будет верно, что
если в списке один элемент,
то, значит, скорее всего
и псевдоним равен ему.
Но, правда, на практике это может оказаться
не так.
Ну, потому что... Просто потому, что
думаю, вы уже догадываетесь, да, каким
образом мы будем искать минимум и
удалять его.
То есть мы будем это делать.
Ну, на самом деле мы видим так.
Удалять на самом деле достаточно
просто, кстати. Обратите внимание.
Если вы хотите удалить какой-то конкретный ключик,
вы просто удаляете его из этого списка
и не заморачивайтесь.
А это не важно.
Тут фишка такая.
То есть как будет устроено...
Ну, find-min...
Ну, ладно.
Как будет устроено find-min, тут действительно
не очень понятно. Но там просто...
Если вы пытаетесь обратиться там, найти
минимум или там, скажем, удалить
его...
А, что?
Ранг?
Ранг вершины.
Что это значит?
Ну, вот у бинвельного дерева есть ранг.
И помните, что у нас дерево было устроено
таким образом, что у каждой
вершины есть
ранг, и на нем висит прям корректное
бинвельное дерево такого ранга.
Вот.
Это он и есть.
От чего K?
K1, K2, K3,
вот это.
Ну да, это KG.
Так, про что я перед этим говорил?
А, ну вот.
То есть там фишка будет такая, что если мы
будем там делать, допустим, какой-нибудь
find-min, да,
то есть мы будем пытаться
делать какой-то find-min или delete,
то мы как бы, что мы делаем? Мы смотрим, где там
у какого корня самый минимальный
псевдоним, и
смотрим туда элемент. Если
там пусто,
вот тогда мы начинаем
шевелиться.
Ну вот, потому что пока там не пусто,
шевелиться нечего. Или там пока
мы не пытаемся его удалить.
Что-что?
Ну не в верхнем элементе.
Ведь как бы не все элементы
хранятся в одном дереве.
Потому что это я сказал,
это я напомнил, как устроена вершина.
Давайте вот на всякий случай, да? То есть это вот
бинвельное дерево. То есть помните, то есть бинвельное
дерево, обычно, ну классическое
бинвельное дерево в
экзотической интерпретации нужный сейчас
устроено так.
Вот, ну вот. То есть допустим там
в корне у меня пятерочка. То есть
помните, да, там я вот хочу
нарисовать дерево ранга 4.
Оно будет выглядеть так.
Вот. То есть это все
next, next, next, next, next.
И как бы на самом деле мы говорим о том,
что это все одна и та же вершина.
Ну не, точнее
ну типа, то есть на самом деле
просто у этой вершины четверо детей.
То есть мы
к этому сыну за О отказ.
Ну типа, да, только, ну давайте в терминологии
чизэли она называется next.
Чивай еще раз.
Мы к этому сыну входим за О отказ, чтобы
не рисовать нашу вершину. Да, именно, именно.
Вот.
Ну а соответственно, а есть соответственно
child, и вот тут уже начинается.
Допустим, тут, допустим,
шестерочка.
Да, тут вот надо,
видите, тут надо уже аккуратненько рисовать.
Да.
Вот.
Да,
я, я, я, я, я.
Какие, какие мы непостоянные.
Да, да, да.
Ой.
Не, ну пожалуйста,
можно, ну вот.
Не, ну как сказать,
вы родитель, вы, ладно,
да, мы создали себе братьев, что каждый брат
контролировал наших детей, там наших детей,
что братья контролировали наших детей, да.
Ну, во-первых, мы любим,
мы ставим себе более высокие цели,
чтобы от массивов избавляться,
там типа по интермашин.
А во-вторых, что самое главное, вот именно
такой интерпретацией мы сейчас будем пользоваться.
То есть там фишка такая,
то есть какая бы смысл, то есть структура
устроена так. Жил, был чизэль,
он говорит так, давайте биняльную кучу
сделаем вот так, вот так, вот так и вот так вот.
別. Вот это тоже адекват,
это лагорифум. А теперь давайте минимум
доставать, вот, не как раньше, то есть это
взяли детей, создали из них
новую кучу в мельт�ills и обратно.
А давайте пытаться из них
там выковыривать пока там,
пока количество, пока количество детей
еще, хотя бы половина от того, что было.
Вот сделали. Сделали.
А теперь давайте в одном месте там
выковыривать будем чуть больше.
Ну вот и ой, вот софт хипа получился.
Вот.
Да, ну в общем-то, вот я и рассказал смысл этой структуры, остальные детали додумайте, сами лекции окончено, всем спасибо.
Вот, теоретически можно было сказать, но обедать мы пойдем чуть позже.
Вот, значит, теперь подробнее.
Ну вот, допоминаем, да, что
значит, они же брать, ладно, давайте в скопках напишем, вот так вот, brother.
Вот так, все, это будет типа ипподром, а это типа, если вы любите платформу 47-й километр, ну там можете в скопках писать.
То есть, на казанском направлении никто не живет, да?
Нет, там просто недавно одну станцию переименовали, поэтому там вот так вот это пишут, и там ипподром в скопках платформы 47-й километр.
Ну то есть, додумались, да, что, наверное, если рядом с вашей станцией находится ипподром с почти 100-летней историей, то, наверное,
имеет смысл его упомянуть в названии.
Вот, не важно.
Нет, нет, это отдельная письма, что он со 100-летней историей.
Вот.
Не-не-не-не, это в Раменском все, я говорю, это казанское направление железной дороги.
Вот.
Вот.
Так, ну вот, примерно так это начинает выглядеть, правда, тут еще надо дорисовывать, тут, в общем, но чем помните?
Нет, это пока я нарисовал просто бенмяльное дерево, как оно в нашей интерпретации просто классическое бенмяльное дерево выглядит.
Вот, то есть в идеале, пока из него не начали ничего выковыривать, оно, собственно, тоже так же будет выглядеть примерно.
Вот, но фишка в том, что, да, то есть, конечно, это еще не все,
потому что хорошо, вот так устроены вершины, то есть,
то есть, допоминаю, да, что у каждой вершины будет ранг, причем по рангам, то есть, если ранги рисовать, то ранг тут будет, условно, тут 4-3-2-1-0, то есть, как бы, убрать их в разные ранги.
То есть, смысл в том, чтобы для каждой, чтобы говорить, что, как бы, если у нас обнаружилась вершинка ранга 3, то, как бы, в ее поддереве,
мы проверили, изначально в идеале хранится прям абсолютно корректное бенмяльное дерево размера там ранга 3.
То есть, более того, смотрите, я не, почему я тут рисую еще, это фиолетовым, но здесь, ну ладно, это не совсем так видно, но суть, в общем, еще такая, напоминаю, что вариант такой, что у вершины, если вершина один раз создается с какого-то ранга и ее ранг не поменяется никогда, просто до ее удаления.
То есть, как я сказал, это уже смысл в том, что у меня ранг 5, это означает, что в идеале, то есть, у меня когда-то была деревом ранга 5.
Да, у меня сейчас все, да, у меня сейчас все поудаляли, да, у меня там осталось только там, называется, трое детей, скоро меня вообще распормируют, но когда-то давным-давно я была там большим дворянином, вот, и она будет это помнить, но помнить она будет как раз вот именно с целью того, чтобы контролировать, сколько у меня детей было изначально, типа, и сколько их на самом деле сейчас, это нам пригодится.
Значит, это как встроены бенмяльные деревья.
Да, да, если вы говорили, кстати, да, вот так, так выйдет бенмяльное дерево, но если мы говорим о куче, то это будет выглядеть чуть более экзотическим образом, смотрите, вот смотрите, то есть, вот у нас есть вот этот вот путь, да, ранги действительно такие, но у каждого будет вот этот вот сикей, допустим, 5.
Но у всех их будет единый список, список ключиков, вот этот вот, вот который я красненьким рисую, вот, еще вот так будет.
Вот, вот.
Ну, как бы, да.
Ну, мы сказали следующее, вот я говорю, что у каждой вершины есть список на ключи, которые в ней хранятся, да.
Так вот, во всех этих вот вершинах, вот всех этих, так сказать, братьях, их же next'ах, понятно, что хранятся одни и те же вершины, потому что, как мы помним, что как бы это, мы только чисто для своих технических нужд ее вообще размножили.
Теперь, когда мы в одном изменим, нам придется у всех изменить?
Да нет, а, ну вообще говорят, да, мы должны будем следить, что на всем этом пути все элементы одинаковые, и мы будем это делать, и более того, мы еще будем следить, чтобы тут и ссылки на эти списки были тоже одинаковые, да, нам это будет интересно.
Вот, значит, вот такая вот примерно картинка.
Да, вот обратите внимание, видите, тут элементы, да, могут быть меньше, могут быть равные, порядок абсолютно рандомный.
Если порядок рандомный, можно поугарать, чтобы указатели не ломались в середину?
Ну, если очень хочется развлечься, то пожалуйста.
Ну, а шо?
Не, ну мало ли чего, как бы это, мало ли, может, кто-нибудь помнит эти стародавные времена, там с лототронами, вот этими шариками.
Так вот, значит, смотрите, ну а теперь, значит, как мы уже помним, в бенмяльной куче бенмяльное дерево само по себе самодостаточной кучей не является.
Так, а помимо этого у нас есть красивая обертка.
Так, ладно, каким цветом мы ее будем рисовать?
Ну, давайте синий, нет, синий и фиолетовый так все контрастируют.
Ну ладно, не зеленым, у нас будет ссылка на суффикс Мииму.
Значит, смотрите, сама в себе куча, это вот такой односвязанный список таких структур данных,
которые называются, как они у нас называются, хеды они называются.
Ну, в статье ж хеда они называются, по камере есть там такое слово, да?
Че оно значит?
Ну, давайте прям честно, да, это напоминаю, односвязанный список.
Как устроена сама куча.
Вот, то есть смотрите, чего-чего?
Это все биномиальные деревья.
Да, то есть это все биномиальные деревья, причем, что важно, строго возрастающих рангов, по крайней мере, в корнях.
Вот, так, ну давайте, чтобы я тут никакие поля не забыл.
А, пардон, неправ, неправ, неправ, неправ, в том плане, что список двусвязанный.
Вот там, видите, там прям так и написано next prev.
Так, значит, что там еще написано?
Еще там написано, конечно же, так, ну еще у каждой вершины, конечно же, есть, значит, соответственно, дерево, то есть указатель на корень дерева.
Вот.
Говорю, ну вот.
Вот.
И более того, мистическим образом ранг мы тут в каждой вершине тоже храним.
Видимо, чисто, чтоб удобно было.
Ну, чтоб там лишней бюрократии не заниматься.
Вот, что еще?
Так, что я еще забыл?
Ссылки, а, и самое главное, самое интересное, внимание.
Самое интересное, это что из каждой штуки мы храним не только ссылки на следующего, предыдущего, но и ссылку на минимум.
Минимум на суффиксе, типа, начиная с себя и правее.
Вот как-то так это может выглядеть, это будет вот так и называется, суффикс.
Во.
Чего?
Ну, как минимум этот указатель нужен для того, чтобы там за О от единицы делать файндмин, если вам очень надо.
Вот.
На сеся прям вот очень-очень-очень надо.
Вот.
Но еще он делается для того, чтобы когда вы смерживаете две кучи, если вы сделали это за О от трех, то и как бы минимум потом пересчитывался за О от трех, а не за О от приближимся опять заново по всему, что было.
А, ну вот.
Ну, конечно, да, конкретно эти вещи можно было и без этого делать, но тем не менее.
Значит, вот, кажется, что это как бы какой-то дополнительный, какая-то дополнительная странность, но на самом деле нет.
То есть, на самом деле выясняется, что, можно достаточно быстро выяснить, что на асимптотику она на самом деле значительного влияния оказывать не будет.
Вот.
Значит, почему?
Ну, собственно, да.
Ну, чтобы понять почему, конечно, нам бы неплохо понять каким же образом у нас это все вообще будет устроено.
Ну, давайте смотреть.
Значит, давайте смотреть.
Ну, во-первых, да, как вы уже поняли, да, вы уже догадались, как у нас будет устроен сам дилит, правда?
Ну, то есть, дилит будет устроен.
Если тебе сказали, удали вот этот элемент, ну так пойди и удали его из этого списка буквально.
А есть список?
Чего?
Это нормально.
А каждый элемент в одном списке?
Значит, нет, каждый элемент находится ровно в одном списке, да.
Значит, некоторые, значит, у нас будет так.
Некоторые списки будут пустые.
Но более того, иногда у нас списки будут исчезать, в смысле, смерживаться с соседом.
Вот.
То есть, мы опять будем указать для каждого элемента, типа итератора?
Ну да, конечно.
То есть, итераторы указывают именно сюда.
Да.
Вот.
В чем завете, видите, структура устроена так, что нам, в общем-то, для элемента не важно, не особо важно по элементу говорить, где он.
Обратите внимание.
То есть, он просто удалился из своего списка и до свидания.
Хотя ладно.
Ну хотя ладно, это, да, это, наверное, не совсем так.
Ну вот.
Если список опустел, то мы все-таки продолжаем хранить вершины, да?
Если список опустел, то, ну скажешь так, мы продолжаем хранить, что этот список есть.
Правда, нам приходится хранить, что этот список пустой.
Вот.
Да, по большому счету, конечно, правильнее, видимо, было бы хранить просто такой, где-то тут хранится такой STD-лист и ссылка на него.
А внутри этого STD-листа может быть вот все вот это вот, да.
Экстракт Мин просто удалит первый элемент.
Ну, экстракт Мин, да, он просто полезет в минимум и удалит оттуда элемент.
А если...
А если список будет пустой?
Так в настоящем сейчас разбираться будет не важно.
Ну вот.
Спойлер.
А вот, а тут начнется основная магия.
Ну вот там, понимаете, FindMini тоже надо еще задуматься.
Понимаете, когда мы...
Когда мы, как бы FindMini, он что сделает?
Он пойдет в суффикс Мин, посмотрит в корень.
И смотрит.
Если я обговорю, что там список, что там все минимально, но список пустой, значит будет запускаться черная магия.
То есть, да, у нас будет такая функция черная магия.
А еще суффикс Мин пересчитать потом.
А подтягиваться...
Но это ничего страшного.
На самом деле ничего страшного в этом нет.
Потому что черная магия будет работать как минимум за от количества братьев у корня, я так вам забегать вперед скажу.
Поэтому на самом деле по сравнению с этим суффикс Мин будет работать бесплатно.
Так что это...
Так что не проблема.
Но черная магия будет заниматься тем, что я хочу, чтобы у меня там в детях, соответственно, что-то произошло.
Так что Логен у нас вполне может вылезти, но просто редко.
Видимо такая...
Нет, причем нет.
Логен будет вылезать, но просто...
Сейчас увидите, даже сложно.
Сложно так заранее на уровне спойлера сразу все описать, что тут будет происходить.
Вот.
Поэтому смотрите, работать это будет так.
Ну, во-первых, да.
Смотрите.
Самое главное для нас, давайте просто себе это вообразим.
Что если и так не говорить о грустных вещах типа Delita, то все остальное достаточно просто.
То есть как сделать инсорт нового элемента?
Ну, инсорт нового элемента сделать очень просто.
Мы создаем кучу на один элемент в завод единицы.
И часто ее вмерчиваем.
Правда?
Понимаете, да?
За сколько?
Сумакно за от Логен.
Ну, во-первых, за от Логен, конечно.
Но реально мы вмерчиваем за от столько, сколько надо.
Там же вот был этот факт про минимум.
Да, значит, смотрите.
Давайте его напомним.
Так, ладно, давайте вот так.
Это я нарезал.
Вот давайте, да, давайте вспомним, как мы мержим две кучи.
Да.
Да.
Как мы их мержим?
Мержим так.
То есть у нас есть, допустим, последовательность.
Вот давайте себе представим, что у нас есть какая-нибудь куча экзотическая размера.
Там рангов у нас, какие у нее будут ранги?
Ну, я не знаю, там от балды какой-нибудь там.
0, 3, 4, там, допустим, 7, 8, 9, какой-нибудь 12.
Вот.
Ну и, например, у нее будет, ну вот, и мы хотим ее мержить.
Ну, допустим, я не знаю, с какой-нибудь кучей там.
Ну ладно, давайте я сначала этим буду рисовать.
0, 1, там, допустим, 4, ой, не тем рисую, и допустим, какой-нибудь, ну я не знаю, 7.
Допустим.
Вот.
Ну вот, то есть вот такой вот у нас список есть, да.
То есть, напоминаю, да, у нас есть вот такой, такие два списочка,
и у этих списочков еще и там какие-то суффикс-мины есть, да.
Вот, то есть эти там суффикс-мины куда-то там отправляются,
я даже на этот раз не буду рисовать куда конкретно.
Вот.
И тут, конечно.
Значит как же, что же мы будем делать?
Значит первое, значит мы идем двумя указателями,
и, например, видим, что там 0, вы видим два нолика.
Что это значит?
Ну вот.
Ну начать так вот, пытаемся добавлять их в кучу,
но быстренько выясняем, что они у нас оказываются одинакового ранга,
поэтому мы быстренько превращаем их в единое дерево ранга 1.
Видите, да?
Что будет происходить?
Ну вот, дальше мы видим, что эта единица у нас, оказывается,
две указатели, тут можно объединить вот этой единицей
и получить, на самом деле, двоечку.
Но больше у нас деревьев ранга 2 нету.
Да, медвеномиальных деревьев, если быть точнее.
Чего?
Ну мы, ну был вопрос по логарифу, мы его воспоминаем,
тем более, ну это по-любому воспомнить надо.
Да.
Да, я не утверждаю, да, в прошлый раз мы это обсуждали, да.
Значит, далее, значит, эта двоечка отправляется она уже в кучу.
Далее, теперь мы видим вот эту троечку,
но видим, что ее тоже складывать не с чем,
поэтому, на самом деле, как бы, можно сказать,
что мы ее тоже переносим вот сюда.
Вот, то есть, вот эта вот троечка, соответственно.
Вот, и мы переходим дальше.
Дальше мы видим две четверочки,
их мы объединяем в пятерочку.
Вот.
Вот.
Так.
Так, чего я так много маркеров-то держу?
Вот.
То есть, это мы все делаем, этому мы всему радуемся.
Очень хорошо.
Да, пока вот у нас тут, да, мы тут, это начало списка такое.
Так, пятерочку не с чем складывать,
поэтому пятерочка тут останется.
Вот.
Дальше мы получим семерочку,
и у нас наступит такой вот граничный момент.
Граничный момент будет заключаться в том,
что одна из куч закончилась.
То есть, смотрите, мы сделали,
то есть, фактически, можно сказать,
мы работали вот за, там,
может быть, от, за О от меньшего ранга куч.
Ну, если сказать, что ранг куча — это ранг максимального дерева,
ну, допустим, да,
то как бы мы работаем за О от, получается, минимального ранга.
Хотелось бы это сказать.
Но это не совсем так.
Потому что после этой границы
у нас, на самом деле, тут возникнут еще вот такие моменты.
То есть, нам придется тут объединять,
потом еще вот тут объединять,
а, ну и, слава богу, все.
И, на самом деле, только вот здесь,
на самом деле, нас ждет конец.
Вот.
То есть, это будет девять-десять.
Да, еще двенадцать,
а, на самом деле, может быть, там еще что-то там дальше пойдет.
Да, но здесь, оказывается, достаточно легко,
потому что, значит, мы это прилепляем вот сюда,
и теперь говорим, что вот на этом суффексе
мы уже посчитаны.
Остается только пробежаться по этому списку еще раз,
и, собственно, эти минимумы еще раз насчитать.
Остается только вспомнить,
почему у нас здесь лагеритмат минимум.
Перенасчитать.
Значит, теперь давайте вспоминать,
почему у нас тут действительно что-то такое происходит.
Но идея там была какая-то следующая.
Да, ну, во-первых, да.
Первое, что хотелось обратить внимание,
то пересчет суффикс мина на самом деле на симпточку не влияет.
Ну да.
Он не влияет просто потому,
что мы прибираемся за О от свежесозданных вершин.
А их не более чем столько, сколько мы обошли?
Нет, это другой вопрос.
Это другой вопрос.
То даже проще.
Мы говорим, что если мы создали сколько-то вершин,
то мы уже затратили на это не менее чем омега от их количества времени.
Поэтому мы докажем,
что то время, которое мы на них потратили,
оно там адекватно, то и суффикс мин на самом деле тоже проблем не даст.
Ну, там константу, по сути, увеличим и все.
Вот.
Поэтому, да, суффикс мин, как мы видим, ни на что здесь не влияет.
Вот.
Значит, теперь возникает вопрос,
почему суммарно такие мэлды будут работать за, допустим, О от единицы?
Ну, потому что мэлд можно разделить на две части.
Значит, вот эта вот первая часть до вот этой границы,
она работает за, там,
собственно, за О от минимума.
Ну, допустим, я это назову R1 и R2,
где R у меня это будет максимальный ранг дерева в куче.
Понимаете, да?
Вот.
Но здесь заметим следующее,
что каждой вершине,
ну вот, что каждой вершине, особенно если мы еще не удаляли,
можно сопоставить в соответствии два в степени ранг элементов,
которые в ней находятся, правда?
В будущем мы, кстати, тоже будем так делать,
только мы будем подразумевать, что ранг, соответственно,
у него будет не, что там будет иметься в виду,
не только те элементы, которые в ней есть сейчас,
но и те, которые в ней были когда-то.
То есть у нас всегда будет верно так,
что если у нас создалась вообще вершина ранга 8,
то это означает, что к этой вершине причастны ровно 64 элемента,
то есть, ну, два восьмой, то есть ровно 64 вот эта айтема,
они, то есть, если рассмотреть всех ее потомков,
вот, да, если, там, если рассмотреть всех ее, там, прошлых или,
там, собственно, нынешних или прошлых потомков,
рассмотреть все айтемы, то их будет ровно 64.
Вот, понятно, да?
Ну, вот.
Вот.
И в результате, теперь давайте пока для простоты,
ну, пока предполагаем, что, например, дилита нету,
но тогда получается, если дилита нету,
то там все эти элементы на месте.
То есть, заметим, что тогда вот этот ранг,
это О от логарифма нот,
то есть, этот ранг, он как бы О от логарифма ее реального размера, правда?
Ну, вот.
То есть, получается, это равно О от минимума,
то есть, видите, это как оценка сверху, обратите внимание,
лог СЗ1,
лог СЗ2.
Да, но это, конечно, да.
Короче, писать, что это лог
минимума от СЗ1, СЗ2.
Да.
Ну, потому что да.
То есть, ранг не превосходит логарифма размера.
Максимально,
максимального дерева в куче.
Ну, пока да.
Пока ранг 8,
то есть, вот у этой кучи мы будем считать, что ранг 7,
а у этой кучи ранг, ну, вот какой-то там больше 12.
Сейчас.
Почему у нас
до того момента, как мы доедем до границы,
мы работаем за О от минимума,
ведь в верхнем дереве мы же можем больше пройти за это время.
Да, а я не случайно нарисовал здесь вот эту черту.
Потому что до этой черты
мы работали за вот столько.
Вот.
То, что будет после этой черты, оно работает за
8 точек.
Оно работает за О от количества
вот этих вот объединений.
То есть, на момент, когда мы пересекли черту,
когда указатель сверху пересек.
Ну, нет.
Значит, мы пересекли черту, когда одна из куч закончилась.
Ну, мы же могли пересечь черту
сверху раньше, чем
закончилась нижняя куча.
Для меня черта, это когда закончилась,
когда в одной из куч закончились деревья.
Нет, ну да, у нас могло...
Да, после пересечения черты у нас могло остаться
дерево, которое, там как-то вот
могло остаться какое-то дерево большего ранга,
чем то, что было в одной из куч,
и его там надо еще домерживать в большую.
Вот эту цепочку.
Но теперь, смотрите,
амортизация здесь будет работать так.
Я утверждаю, что если мы работаем с кучами
суммарно на n элементов, то я утверждаю,
что все мэлды в этих кучах будут...
То есть, ну как бы, мы себе можем вообразить,
но я утверждаю, что все эти мержи
суммарно будут работать за линейное время.
Это и будет означать, что каждый мэлд
амортизированно работает за единицу.
Как же мы это будем доказывать?
Ну, начнем со второго.
То есть, если рассматривать в мэлдах то, что происходит
после черты, то вот это вот суммарно
по-любому будет за oatn. Почему?
Да просто потому, что общее количество
объединений, оно будет не более чем n-1.
Ну, у нас, по понятиям,
было у нас n деревьев,
в результате каждое объединение одно-одно
становится меньше, в итоге стало одно.
Ну, в худшем случае одно, а может и больше.
Вот, поэтому получается вот это oatn очевидно.
Или не очевидно?
Суммарно у нас всего было n деревья,
с каждой такой операцией мы одно дерево убиваем.
Одно уменьшаем.
Чезель это предлагает воспринимать объединение,
как у нас было два объекта,
мы из них создали новый объект,
а два старых убили.
Ну, здесь получилось так,
одно новое образовалось, но два старых исчезли.
У нас в процессе всего алгоритмы могло
что-то происходить, потому что у нас
количество деревьев суммарное.
Здравствуйте.
Совершенно верно.
Но сфагулируем так.
Поэтому нам придется делать так.
Пока у нас нет удалений, значит мы проводим анализ,
а потом, когда у нас появятся еще какие-то дополнительные операции,
нам придется посмотреть на это еще раз и посмотреть,
как этот анализ модифицируется.
А вот если у нас в верхнем дереве
первые три дерева были бы
с рамками 0, 1, 2 и 3?
Ну, значит, тогда первая фаза работала бы
за от 3.
Ладно, плюс 1, там на самом деле надо написать, конечно.
Получается, мы тогда пересекли,
мы в верхнем дереве пересекли границу раньше,
чем закончилось с нижним деревом.
Да, правильно.
Если бы складывали 0, 1, 2, 3, 0, 1, 4, 7,
то да, в верхнем дереве граница,
то есть верхний дерево закончился бы раньше,
граница там была бы по троечке, да.
Но оно бы не закончилось,
оно дальше еще продолжалось.
Нет, если там 0, 1, 2, 3, 8, 9, 12,
то, конечно, да, тогда мы работаем,
первая фаза работает за от 8.
А, я понял, все.
Вот, окей.
Что будет, если мы прищем границу и пойдем дальше?
Ну, дальше...
То, что будет дальше,
вот что мы будем делать с этой восьмеркой,
если она 100-1?
Так, тут есть восьмерка, да, объединяем 9,
тут есть 9, так, объединяем 10,
тут есть 10, ой, нет, все, вставили 10, закончили.
Объединили, будет 11.
Итак, пока там дальше все встречается.
За сколько это работает?
За от количества объединений деревьев,
которые нам придется в этом месте выполнить.
То есть мы это еще не посчитали?
Нет, мы посчитали,
мы сказали, что у нас суммарное количество объединений
таких деревьев во всех мержах будет О от Н.
Точнее, Н-1.
Поэтому амортизировано, это работает за О от единицы,
нас это устраивает ура.
В прошлый раз, кстати, мы еще приводили такой образ,
на самом деле, что давайте представим себе,
что на вот такие объединения у нас на каждом хейде
лежит коричневая монетка.
Ну, раз уж мы и вот эти объединения деревьев
обводим коричневым маркером,
значит это будет коричневая монетка.
И тогда, когда вы объединяете два дерева,
вы тратите на это одну из этих монеточек,
а вторую монетку вот как бы переносите вот сюда.
Тогда получается, что созданием,
когда вы создаете новый элемент,
у вас создается автоматически новая монетка,
и получается суммарно вы создаете N-монеток.
Ровно, причем N, обратите внимание.
А соответственно, каждое объединение деревьев
вот это вот имеет учетную стоимость ноль.
Да, это вот важно понимать, полезно понимать,
что у вас есть действие учетной стоимости ноль.
То есть вы их как бы делаете, но они как бы не считаются.
Ну, тогда мы вообще, кажется, могли бы ничего не анализировать
с вот этим логарифмом минимума.
Нет, с логарифмом, но не совсем так.
Мы же всегда когда мертвы.
Нет, это неправда, важный момент.
Дело в том, что неверно,
что количество действий, которые мы делали до границы,
это тета от количества объединений, которые мы делали.
А потому что мы же тут не только объединяем деревья,
но и сформируем из них список.
Да, давайте я вот поясню.
Смотрите, то есть как бы если у нас тут ранги 0, 2, 4, 6,
а тут ранги 1, 3, 5, 7.
Вот.
Вот.
И тогда оказывается, что мы как бы, да, граница тут шестерка,
но соответственно вам придется, ну вот,
и вам тут реально от 6 и плюс 1 реально придется тут ходить,
потому что вам придется помешивать эти списки.
Да, ни одного объединения произвело.
Поэтому вот эту часть, к сожалению,
оценивать объединениями деревьев нельзя.
Поэтому придется тут реально мыслить что-то там про логорифум минимума.
Но при этом оказывается, что вы можете, ну вот,
что по индукции достаточно легко доказать,
что если вы там, допустим, у вас есть изначально n единичек,
а потом вы на каждом шаге берете два числа и их объединяете,
и там прибавляете логорифум минимума,
то итоговая сумма у вас в конце получится от n.
Правильно.
Будем.
Ну вот.
Но если забирать вперед, то работать это будет примерно так.
Ну, во-первых, логорифум...
Ну, во-первых, так.
Смотрите.
Значит, логорифум минимумов,
анализ логорифма минимумов от этого никуда не будет.
Ну, вот.
Вот.
Значит, логорифум минимумов,
анализ логорифма минимумов от этого никуда не денется.
Потому что, ну, по большому счету куча...
Потому что в этом месте, во-первых, мы будем глобально
говорить, что сколько элементов в принципе соответствует этой куче
нынешних или удаленных.
Вот. А во-вторых, почему мы удаляем и следим за половиной детей?
Потому что мы можем сказать, что когда мы удаляем,
у вершины исчезает по каким-то причинам ребенок...
Вот.
А вы уже умерли там, да?
Да, это круто, да.
Задать вопрос и умереть, да, круто.
Вот.
Ну, вот.
Ну, как сказать, знаете, как-то...
Представьте себе ситуацию.
К вам подошел человек, задал вопрос и сразу заснул.
Повышает ли это мотивацию отвечать на вопрос?
Вот.
Но тем не менее, я продолжу ответ.
Значит, смотрите, суть в следующем.
То есть, когда, просто можно сказать, когда вы у вершины
говорите, вот вершина, у меня ранга 8, допустим, да?
И у нее, по крайней мере, изначально 8 детей.
Поэтому мы говорим, так, если у нее по каким-то там,
чуть позже изучим, по каким мистическим причинам
отпилился ребенок, то это отпиливание тоже будет давать монетку.
А может быть даже две.
Ну, вот, может быть, да.
Ну, вот, этими монетками мы будем оплачивать вот этих вот товарищей.
То есть, это тоже будет бесплатно, поэтому, то есть, в симпатике
не участвует, все хорошо.
Ну, потому что, когда мы отпиливаем детей, мы ж по-любому там явно
на это уж Омега от единицы действий потратим, правда?
Да.
Вот. Так что давайте просто в этих Омега действий будем включать,
давайте еще и тут монетки.
То есть, как бы, да, ну, как бы, да, за каждого, да, за каждого
отпиленного ребенка родитель должен получить какую-то компенсацию, да.
Почему родитель может на же ребенок просто, когда, типа,
добавляем новую вершину, добавляем новое дарево в кучу,
всегда кладом на это дарево монетки?
Нет, одно другому не мешает.
Просто дело в том, что мы как бы детей, нет, хуже.
Нет, на самом деле у нас хуже.
Отпиливать детей, нет.
На самом деле это добрая куча.
Мы не будем отпиливать детей.
У нас не будут детей припиливать.
Нет, мы не будем.
Мы будем высасывать из них все соки и дети будут схлопываться.
Вот.
И что, вы пересмотрели Рейки и Морсе?
Да.
Кто?
Нет, я как человек, который вообще, по-моему, там толком никогда их не видел.
Да, да.
Ну, а кто?
Нет, я как человек, который вообще, по-моему, там толком никогда их не видел.
Я просто, это не ко мне.
Но тут вот ситуация так.
Хотя Чизель, может, и пересмотрела, я не знаю.
Хотя, то есть Рик и Морти, когда они вышли вообще?
Нет, в 2000.
Нет?
Ну, скажи так, первые серии были до 2000 или после?
После 2010.
А, ну вот.
Значит, на Чизели они не повлияли.
Да, лямбер.
Так вот.
Ой-ой-ой.
О.
Кошмар какой.
Так, что-то это.
Так.
Да, началось конец октября.
Дети начинают умирать.
Да.
Вы не поверите.
Ну, мы поняли, почему за одни сработает мало.
Угу.
Не, мы первые сейчас.
Нет, мы сейчас это, мы сейчас до конца пытаемся это, ну вот, запилить.
Значит, значит, пришло время, ну ладно, видимо, нам, наверное, пришло время начать понимать.
Ну ладно, как устроен дилит мы поняли.
Значит, как будет теперь сам, то есть, самое не тривиальное это на самом деле будет, как устроен файндмин.
А стоп, мы же не запрофали вот это первая часть, как его смердживание.
Смержу, нет.
Нет, мы не поняли, как устроен дилит, когда у нас.
А с первой, нет, смотрите.
Нет, давайте так.
Нет, ну на самом деле, нет, понимаете, на самом деле сейчас, ну можно, на самом деле понять сейчас это очень сложно, потому что мы не поняли, как это, как там устроено это высасывание соков и отпиливали там и слопывание половины детей.
Да, мы это не можем, нот.
Поэтому, может быть, правильнее, действительно, знаете, делать это все так, но постепенно.
То есть, пока мы так, о, наметками, что там примерно будет и как это.
Так вот, теперь начинается самое интересное.
Так сказать, ядро.
То есть, это ядро оказывается, ну где-то вот, можно сказать, где-то в файндмине.
Вот.
Значит, файндмин, ну вот.
То есть, на самом деле, да, неожиданно, но у нас будет жирный файндмин.
Жирность его будет, ну понятно, что начало, казалось бы, не предвещало что-то нетривиального.
Мы просто берем, берем кучу, берем суффикс мин, смотрим, возвращаем, радуемся.
Но возникает маленькая проблема.
То есть, мы попробуем сделать так.
То есть, мы попробуем сделать так.
Мы скажем так.
А, дорогой корень, расскажи-ка, пожалуйста, а список у тебя там не пустой?
И если этот список не пустой, то, значит, тогда все в порядке, не заморачиваемся.
А вот если он пустой, тогда мы ему говорим, э, у тебя должны быть элементы.
Он говорит, угу, и вот.
И тут начинается самый нод.
И тут, значит, делается следующее.
Он говорит, так, он первое что думает, так, да-да, так, ладно, откуда достать минимум?
Так, откуда ты из детей?
Так, а сколько у меня детей?
И он честно прибирается по списочку, прямо буквально честно прибирается.
И спрашивает, так, сколько у меня детей?
Если совершенно случайно выяснилось, что количество детей меньше, чем мой ранг,
а ранг напоминает о столько, сколько у меня детей в идеале,
или, по крайней мере, когда-то было, пока я тут не начал заниматься, собственно, высасыванием соков,
вот, то я говорю, так, все, мои полномочия на этом все.
Да, из оставшихся детей я создаю отдельную биномиальную кучу и вмелживаю ее обратно.
И запускается рекурсив.
Ну вот, нет, ну там речь идет скорее о вайл труп.
То есть мы говорим так, вайл в суффикс мини ни черта нет.
То есть пока мы идем в суффикс мини, а там, собственно, ничего нет,
мы там начинаем, мы лезем к этому корню и говорим, э, гони.
Значит, он говорит...
Семки есть?
Да.
Детей?
Ну нет, почему есть детей?
Не, ну там по рангам зависит, эти дети могут быть очень высокора.
Но правда мы, да, согласен, что мы это будем делать как бы за от...
То есть граница будет где-то здесь, наверное, а то и левее.
Потому что очевидно, что если у нас, напоминаю, тут все по рангам отсортировано, да?
Поэтому вот эта вот граница с логорифами, как бы, если ее так вообразить,
она будет все равно где-то здесь, когда мы будем в туалете, да.
Если там пустой список, то мы берем всех детей этой вершины?
Нет, нет, нет, нет, нет, только если у корни еще очень мало детей по сравнению с рангам.
Насколько мало? Два раза меньше?
Да.
Ну там если количество детей, которое там есть, оно строго меньше, чем,
оно там строго меньше, чем, соответственно, ранг пополам,
то мы, нот, то мы тогда действительно грустно заявляем, что эта вершина удаляется.
Количество детей, что мы имеем, ранг, мы имеем в виду...
Количество детей, которое когда-то было или все-таки твой ранг, который был изначально в бедвейной куче?
А это одно, а это, нот, ну ранг, который изначально был в бедвейной куче.
То есть детей тогда должно быть типа меньше, чем два в степени ранга минус один?
Нет, зачем два в степени ранга минус один?
Нет, смотри, ладно, для формальности можно считать следующее, что ранг это вот такая мистическая величина.
Вот такая.
То есть, напоминаю, что каждая вершина рождается своим рангом.
Когда у нас вершина рождается? Вершина у нас, напоминаю, новая вершина у нас рождается всего в двух случаях.
Случай номер раз, когда мы вызываем инцер, тогда рождается вершина ранга ноль.
И когда мы решаем объединить два дерева ранга И.
Как мы мержим деревья ранга И?
Мы создаем новую вершину ранга И плюс один и подвешиваем к ней эти два дерева.
Одного объявляем братом, одного объявляем ребенком.
Кого мы называем братом?
Меньшим.
Ну тот, у кого меньше псевдоним, конечно.
Вот.
То есть, можно считать, что ранг это вот это вот.
Все. То есть, напоминаю, у вершины раса навсегда создался ранг и она не меняется.
Вот.
Это количество прямых потом.
Прямых детей, короче.
Ну, тип.
Если у минимальной вершины количество непосредственных детей меньше, чем ранг пополам ее,
Чем мы что-то делаем?
Откуда ранг пополам? Мы все детей не знаем.
Ну потому что количество детей может уменьшаться.
Вопрос такой.
Может у кого где-то мы когда объединяем два дерева мы создаем новую вершину?
Да. Совершенно верно.
Нет, нет, нет.
В данном случае сейчас мы создаем новую вершину и подвешиваем две.
Ну то есть, смысл остается тем же, что мы как бы к одному дереву подвесили другое.
Но просто для того, чтобы к одному дереву подвесить другое, вам как бы количество братьев в этом списке надо увеличить на один.
Если бы мы это реализовывали не на поинтермашине, то мы бы просто подвешивали одну другую вершину.
Ну, на самом деле да.
Ну в бенвельных деревьях было бы так.
Хотя я не знаю.
Ну я не знаю, можно ли это поинтерпретировать софт хип именно так.
Потому что сейчас вот то, что я буду описывать жестко, использует именно эту структуру.
Вот.
То есть у нас количество двизей становится типа меньше.
Не прямых, а просто потомков.
Ага.
Оно становится типа корень нашего количества.
Почему корень?
Ну если рамка пополам делится, это значит что?
Рамка это типа изначально было, например, логарифы количества.
Ну там не совсем.
Там же вопрос, какие дети отпилились?
У вас же есть жирные дети размеры?
Если у вас 8 детей, то есть жирный ребенок на 2 в 7 элементов, а есть ребенок на 2 в 0.
То есть скорее всего выжиматься соки будут у детей 0,1,2,3.
Собственно я думаю, конечно подходит время понимать каким же конкретным образом мы будем выжимать соки.
KFC больше.
Чего KFC?
А если детей еще не так мало, то что мы делаем?
Вот.
Именно к этому мы переходим.
Мы вызываем мистическую операцию выжать соки.
На английском языке это называется SIFT.
Вот.
Да.
А, давай.
Мы доказали то, что у нас, например, работает золото в нижней стороны, амортизировано.
Да.
Нет, мы это скажем так, четко и строго мы доказали только в предположении, что дилитов не было.
А почему это так?
Потому что у нас работает за количество объединений плюс логарифмы.
Он работает так, за количество объединений плюс сумма вот этих вот минимумов логарифмов объединяемых элементов.
Ага, а сумма логарифмов у нас?
А ранг пополам это для любого эпсила?
Да.
Да, пока этот алгоритм не зависел от эпсила.
Он от эпсила начнет зависеть чуть позже.
А здесь, ну здесь просто смотрите, там, то есть на самом деле он сводится к рекурренции из домашнего задания.
Почему?
Потому что рассмотрим финальное объединение кучи на n элементов.
Да?
То в ней было там m элементов и n-m элементов.
Ну вот.
Соответственно.
И там получается, что чтобы суммарное объединение было, значит сколько времени нам надо было чтобы объединить вот эту m элементов?
Сколько времени нужно было чтобы объединить отдельно вот эти n-m и плюс вот этот вот минимум из логарифмов m и n-m?
Вот.
Только скорее у нас одна куча из x элементов, вторая из y элементов.
А итоговая из x плюс y минус d, где d это количество вершин, которые сложились.
Не, погодите, погодите.
Мы говорим про элементы, есть элементы, когда я говорю элементы, я в первую очередь вот эти имею.
Да.
И потом заметим, что мержи, кстати, вот эти вершины никоим образом не удаляют, обратите внимание, они только новые создают.
А.
А если x мин не пустой, то мы берем любой элемент из списка?
Да, но если find min, то мы на этом просто оставим.
Да, то есть берем первый попавшийся элемент и говорим вот.
Мы две удалили и одно новое создали, нет?
Нет, мы взяли две вершины и подвесились к новой свежесозданной.
Вот типа.
Ну как бы нет, то есть сам мерж ни одну вершину не удаляет.
Именно мерж.
Вот.
То есть более того, в нашу интерпретацию он еще и что-то новое добавляет.
Так вот, как будет, чего?
Что делать, если у корня меньше половины детей?
Что делать, если у корня меньше половины детей?
Нет, нет, если выяснилось, что у find min мало того, что пустой список, только еще и меньше половины детей, то делается очень просто.
Мы пробегаемся во всем этим детям, создаем из них новую кучу.
Да, ровно в этот момент, кстати, единственное, только в этот момент вершины реально удаляются.
Ну там прям целый вот этот вот путь next будет удаляться.
А, нет, ладно, чуть позже будет еще один момент, когда дети будут удаляться, конечно.
Вот, значит эта вершина, значит список удаляется.
Из оставшихся деревьев мы формируем вот эту вот корректную кучу за отых количество.
И торжественно ее вмерживаем обратно.
И снова и снова ищем в ней.
Да, потом после этого мы снова пытаемся искать find min, если обнаружилась та же ситуация.
Ну, кстати, при высасывании соков мы тоже будем пытаться делать ровно это.
И это все амортизировано за единицу у нас получается, да?
Не, на это, ну да.
Ну, нет, амортизировано это получится за единицу.
Вроде да, потому что для того, чтобы вот так вот испортить какую-то вершину,
чтобы ее пришлось собирать, типа, за ранг раз, нам надо удалить хотя бы ранг.
Ну да, конкретно, поэтому конкретно это войдет в амортизацию за единицу.
То есть там, да, доказательства по сути дальше будет такое.
То есть нам нужно научиться делать...
Сначала алтеритм все-таки, а потом...
Сейчас, давайте так, надо научиться делать это высасывание соков из детей так,
что оно, там, суммарно работало за получается nunnlog 1 ÷ eppsilon,
ну там, плюс сколько там функций вы вызывали.
Ну, потому что по большому счету, то мы с вами, что доказываем?
Мы по большому счету, доказываем следующее, что есть...
у вас есть куча, в которой суммарно было вставлено n элементов, да?
Ну, сколькото из них удалено, но тем не менее, суммарно вставлено.
То тогда суммарное время работы всех операций равно nnlog 1 ÷ epsilon,
плюс, там, сколько раз вы вызывали, там, все остальные операции.
Ну это я так напомнил, основы амортизационного анализа.
А теперь...
А может нам же надо будет все суффиксмин еще пересчитать,
если не так что-то будет?
Да, но как всегда это же всегда бесплатно делается.
Помните, melt у нас умеет, мы в melde это делаем так,
что как бы суффиксмин получается делать это...
Нет, нам же нужно пересчитать так, чтобы вторая часть
этого проекта не после удаления.
Нет, нет, нет, нет.
Не, первая часть, которую мы удалили.
Да, но смотрите, ну и что?
Вот вы допустим удалили вот это дерево.
Вы взяли и удалили, и что?
Вы его удалили и делаете какой-то merge.
Ну там, во-первых, вы можете считать, что merge вы делаете
за omega от ранга этой вершины где-то.
Ну ладно, хотя ладно, это не совсем правда.
Но неважно, вы можете сказать так.
Вы можете сказать, что...
Давайте так, сольем две кучи, вот то, что тут получится,
и вот это сольем, да?
Ну там результат, там еще помержим вот это,
и только после этого будем пересчитывать суффиксмины.
То есть не надо сначать?
То есть нет необходимости...
То есть как бы вы, конечно, можете...
Нет, теоретически, в принципе, можно, на самом деле,
удалить это дерево и пересчитать тут суффиксмины,
но на самом деле в этом нет необходимости.
То есть нет, в принципе, ну да, на самом деле,
просто нет необходимости и все.
Только в самом конце пересчитываем,
как в meld мы делали.
Ну потому что смотрите, когда вы, как бы, помните,
когда вы делаете meld, вот сливаете вот этих детей,
и допустим, вот это вы сливаете, да?
То есть как бы вам при самом слиянии
этот суффиксмин, в общем-то, не нужен.
Вот.
То есть вы сливаете.
Если у вас в конце окажется дерево-ранга,
вот совпадающего с этим,
то вы тут еще дообъединяете там лишнее, да?
И потом после этого в конце прохаживаетесь
и там перевычисляете суффиксмин.
В конце.
Мы знаем, с какого момента у нас неправильная суффиксмина.
Да.
Поэтому да.
Ну, собственно, в meld мы раньше ровно то же самое делали.
Так вот.
Итак.
Пришло время чуть-чуть повысасывать соки.
Ну, не чуть-чуть.
Ладно, не чуть-чуть.
Это на самом деле основная идея.
Потому что чем отличается soft hip от бенмяльной кучи?
В бенмяльной куче
как бы высасывать соки никто не думал.
То есть там было жестко,
что как бы дерево, оно всегда дерево,
пока оно, то есть как бы,
если мы не хотим, чтобы это было дерево,
то корень удаляется там.
Но дети в данном виде пока остаются.
Вот.
В данном случае да.
То есть здесь мы как бы куча мягкая,
поэтому мы пытаемся смягчить
себе жизнь.
Вот. Так.
Так, где бы нам что порисовать?
Нет, давайте-ка я здесь порисую.
Чего?
Как мы удаляем детей?
Нет, мы их не удаляем.
Они схлопываются.
И вот именно сейчас я перехожу к тому,
чтобы начать описывать, как это происходит.
Вот.
Так.
Смотрите, сейчас все будет.
Сейчас все-все-все-все-все-все
будет.
Да.
Значит, мы
будем, значит, ну,
на уровне идеи это будет происходить
примерно следующим образом.
Итак, представим себе,
что у нас образовалась вершинка.
Какая-нибудь вершина В.
А у нас будет реку, ну вот.
И мы вызвали сифт от В.
Вызвали ее, потому что мы говорим,
что, ой, по-моему, у этой вершины
пустой список, и я очень хочу,
чтобы этот список был не пустым.
Ну, мне, по крайней мере, так хотелось.
Как же мы это будем делать?
Ну, говорить мы
будем следующее.
Ну, во-первых, мы скажем так,
вот, значит, обратите внимание,
мы пришли в какую-то вершину,
да?
Секей, да?
Значит, мы говорим,
ну, тут надо просматривать
случаи.
Значит, думаем.
Хорошо, список есть, думаем.
А в этом дереве еще что-то,
кроме этой вершины, есть?
То есть, случай номер раз.
Если совершенно случайно выяснилось,
что у нее
next нет, child нет,
все плохо,
а, а, а, а.
Изначально мы запускаем сифт
от нашего поры.
Да, мы изначально
в этом месте запускаем сифт
от этой вершины, если в ней достаточно
людей.
Напоминаю, да.
Так вот, значит, пытаемся из кого-то
что-то высасывать.
Если высасывать неоткуда, то есть, в нашем
под дереве, кроме нас, больше никого нет.
Ну, тогда, да,
кстати, помните об этом мистическом инварианте
о том, что child и next
всегда указывают на
вершины одинакового ранга
или одновременно оба никуда не указывают.
Помните, да?
Это важный инвариант, который мы будем поддерживать.
То есть, не может быть так, что там
next ранга 4, а child ранга 3.
Вот.
Что?
У нас же
наш ранг
должен быть
больше, чем ранг сына.
Нет, смотрите, наш ранг
больше, чем ранг сына.
И, конечно, больше, чем ранг next.
А, нет, смотрите, ну, просто
напоминаю, тут еще фишка, что
да, мы, конечно, мы размножили
себя, да, но
при этом там ранги, как бы, у нас
тут убывают.
То есть, вот это нам оказывается удобно.
Вот, ну, сейчас увидите, почему.
Просто, почему нам вообще удобно,
что у нас есть вот брат меньшего ранга и ребенок?
Точнее на работу. Для вас так.
Брат и ребенок, да?
Потому что мы сейчас будем пытаться
делать следующее, что мы, потому что
если в результате мы там повыжимали соки, оказалось,
что брат оказался
больше, чем ребенок,
то мы заметим, что мы
как бы, так, можем быстренько
взглянуться и брата с ребенком местами
поменять. Если сказать,
что теперь ты мой брат, а ты мой ребенок.
Вот. И быстро,
нет, ну, и в себе там
сикей пересчитать и список перед подключиться.
Вот так можно сделать.
Ну, и как-то бывает в генту
линуксе. Более того, и мы будем
это делать.
Вот. Ну, начнем
с простого. Если совершенно
случайно выяснилось, что
детей у меня нет,
и братьев у меня нет, вот такой вот я
последний, последний герой,
то, что мы делаем?
Ну, тут все просто.
Вот. Я объявляю
себя,
все, я объявляю себя плюс бесконечностью
и гордо возвращаю
себя.
А у нас одинаково плюс бесконечность всегда?
Эээ.
Точно.
Но нам не придется потом объявлять себя плюс
бесконечности?
Не,не,не,не. Плюс бесконечность она всегда
плюс бесконечность. То есть, мы не
можем даже хранить там tight Patrol
что все у меня есть этот элемент он в заведомо
больше, чем все, что вы туда добавили.
А если остались только элементы плюс бесконечности,
то и ладно.
Ну,а так мы будем следить. Ну что значит
только элементы плюс бесконечности? У нас
сейчас мы будем следить за тем,
что у нас не может остаться
деревьев. Прям деревьев из
плюс бесконечности более того но то есть мы будем вообще стараться следить что у нас
вообще только у вершин с плюс бесконечным сикеем могут вот могут быть вот эти вот пустые дети то
есть у плюс бесконечности не тривиальных детей быть не может потому что плюс бесконечности значит
что все из меня выжили все я чего не гарантирует ну да но но ничего страшного нет ну просто в
какой-то момент просто будем удалять сейчас мы эту сейчас увидеть что мы ее не можем удалить
потому что смотрите она может быть чьим-то потомочкам да то есть она может быть чим-то next то есть
она скорее всего является на экстрим и чай там сейчас вы увидите почему и у этой вершины тоже
есть чайл а помните у нас был вариант на тему того что как бы у каждой вершины либо есть либо
чайл дн экс указывает на вершины одинакового ранга либо обе оба никуда не указывает то есть не
может быть так что один куда-то указывает другой никуда не указывает поэтому нельзя просто взять и
удалить эту вершину кто плюс бесконечности в не обязательно но ладно мы от нее так вызвались но
просто но на самом деле просто так мы этого делать не будем потому что теперь давайте чтобы было
понятно о чем я говорю давайте я перейду ко второму случаю значит если выяснилось что мы еще
живы и куда-то указываем тогда мы будем делать так тогда первое что мы вызовем это сифт от в next
то есть мы то есть мы внимание попытаемся по выжимать собственно по выжимать какой-то
элемент из next то есть типа то есть ну суть в том что мы будем говорить что как бы мы
пытаемся выживать или выжимать элементы из самых из деревьев с минимальными рангами вот значит
будем говорить во первых shift вот такой значит но там повыжимался повыжимался но вершина сохранилась
то есть мы проследили затем что у нас всегда то есть как бы когда мы вызываем shift от вершины
сама вершины не удалится вот дальше будет написано примерно следующее ну значит важный
эпический swap значит если выяснилось что в чайл да именно после сикей оказалось совершенно
случайно меньше чем сикей у next в next то у нас тогда оказывается что очень удобно сделать значит
в чайлт и в next можно и по swap ну как бы это просто по определению что еще раз у next у них не
только один список но и один ключ у next ну ключ да ну размноженный по копиям но один да да поэтому
да да правильно первое совершенно верно первое что мы должны здесь написать это действительно
в сикей равно то есть скопировать ключ да так я вам даже больше скажу мы даже скопировать не
только это но еще и списочек но не скопировать о смысле указатели ну да нет ну как сказать тут
я пока просто да разъясняю в принципе да как сказать как-то не странно вредный автор почему-то
этого не делал если вы посмотрите спину вот то есть поэтому тут написать что в этом и это и
ровно там в next и и но и тут вот это вот и л тейл тоже нет вот вот так бы на самом деле это выглядело
если бы мы хотели нарисовать просто бинвельную кучу а нет еще и еще на самом деле нам очень значит
теперь мы еще сделаем ну примерно вот что ну да то есть можно здесь действительно создать такую
ну потому что да нас на самом деле тут не совсем сейчас вот может быть но на самом деле можно
сделать так если совершенно случайно оказалось что v сикей равен плюс бесконечности
то тогда мы делаем простую вещь ну короче мы удаляем ребенка удаляем брата
да вы ну да нет ну чего нет выглядит как два убийства но на самом деле как бы они
умерли уже до этого ну по эти там фильм вот полетай на гнездом кукушки да при чем тут
полетай на гнездом кукушки не в том плане там тоже там концовка была такой что как бы главного
героя там как бы в итоге там как бы в итоге убили но есть подозрение что смерть что реально его
смерть не наступила не в этот момент времени но там такой момент вот ну знаете как-то в хороших
фильмах на самом деле знаете спойлер на самом деле это в конце концов знаете вот романа на
коренина наверное не становится менее интересным от того что вы знаете чем вот закончится да
во первых да если мы следим то есть если я после этого пересчета оказался плюс бесконечностью то
детей мы тоже ликвидируем но могло так случиться значит теперь следующий случай следующий
случай говорит нам следующее что если после этого свапа оказалось шумы адекватные
но это лучше чем пытаться сократить себе жизнь правда ну вот но ребенок оказался плюс бесконечным
то возникает интересная идея идея называется в том а давайте убьем в том что а давайте убьем
ребенка но вот это но вот это нет нет смысл смысл будет очень простой мы значит да ребенка мы
убьем и значит смотрите вот смотрите смотрим на этого брата этого брата тоже из два указателя
так вот мы этого брата тоже убьем а два указателя переподвесим да у нас значит далее а вот дальше
если но опять да если если это мы оказались уже аж крутыми да то у нас соответственно вот теперь
говорим дальше там код будет выглядеть примерно так если оказалось что в чайлт сикей так давайте
все-таки тут рыжим начну писать да вот давайте тут сикей бесконечность и тут сикей равно равно
плюс бесконечность нет это все как бы едино нет нет и вы тут вот как заканчивается так так и
но вот если вы не не вот здесь вот так да это ты закончился на вот этом свапе и больше ничего не
происходит вот он все равно пустой список тоже убивается потому что плюс бесконечность мы
гарантируем что плюс бесконечность появляется только если список прям вот ну совсем пустой
ftv
вот смотрите заметьте следующие когда мы вызываемся от вершины мы вызываемся когда
говорим что список у этой вершины пустой но не Motionターм он вызываем севт мы говорим что мы
вызываем севт не просто так а когда уершины v пустой список как бы мы хотим этот список удалить
там попытаться вместо него найти какой-то список из детей ну когда мы смотрите вы рекурсивно
вызывайтесь от вн экст у нее тот же список шоу и в поэтому он тоже пустой вот значит соответственно
сейчас по очереди да так слапнули ну если вы чаялт оказался меньше например сходить в него
ну потому что допустим вн экст стал плюс бесконечностью он оказался слева а вы чаялт мог тоже
ну у него тоже не могло не быть детей при этом нет погодите мы сначала сходили а потом как бы
сказали что если после этого вн экст сказался бесконечностью мы его отправили в чаялт ну да
а вдруг чаялт тоже при будущем мог бы оказаться бесконечностью ну смотря в каком будущем вот не
произошло ли это в настоящем вы проверили уже прямо сейчас как мы это проверили потому что мы
знаем что чаялт сейчас после вот этого слапа вн экст точно меньше чаялта поэтому когда вы
его переперели если после этого плюс бесконечность значит на него плюс бесконечность до свидания а еще
мы следим за тем что если оказалось что тут плюс бесконечность а тут допустим нет то как бы вот
мы вот в этом эфе сейчас вот дописываем его но делаем мы вот буквально вот это вот сейчас нет
но мы же не проверили что у нашего чаялта на самом деле есть какие-то дети а нам пока не важно нам
главное что этот чаялт и как бы чаялт и next они оба существуют как у нас два случая либо они
оба существуют либо оба не существует когда они оба не существует мы вот тут разбирались а когда
они оба существуют вот мы с ними шаманим да вот здесь мы еще дополнительно рассматриваем
в этом случае что делать если после этого выяснилось что чаялты не существует а next
существует так какой еще вопрос был там десятка и правый сим тоже десятка ну это 19 и 19 но вообще да
а это не вариант это асимптутика а что такой вариант 1 пока нигде я вам я вам пока открою
страшную тайну мы пока еще за пределами вот повернутой ночью но экологически чистой
кучи не вылезаем то есть наша цель попробовать сделать так если тут вот плюс бесконечность то я
даже пытаюсь вот этом выпиливать выпиливать я буду примерно следующим образом но на самом
деле это ладно придется мне тут и говорить что дилитов я вызывать не буду но я тут могу
короче написать но давайте пойдем след с завтра мы скажем что там вопрос изборки мусора мы там
как говорится оставим кому-нибудь кто будет реализовывать это на языке где это надо нет
при этом парадоксально то что автор сам реализовывал это на какой-то причем у вас и до олдскульной
версии сей там ну олдскульность там ну можете увидеть почему вот но вот но поэтому там по
хорошему на то ладно там сборка мусора там черт с ней но вот так вот тут можно написать так
в чайлт мы будем называть равно в next child и в next равно в next child
а вы на экстракт да да да да да да да да да да ну и в общем-то все остается эти там две вершинки
как-то удалить туда можно их там эту в тем эту можно сразу удалить эту можно в темпешку зажнать
в общем короче тут была блаблашку какую-то напишите на эту тему и тут пару дилитов вот
вот ну да а и самое главное что знаете что на самом деле список чек вот этот вот да
ну мы еще посвапали мы добились того что здесь элемент меньше либо равно чем вот это
могло быть так что тут плюс без стала плюс бесконечность тут было 19 и мы их посвапали
ну чтобы у next было меньше чем чайлт вот но и на самом деле да правильнее на самом
деле было бы написать что вот эту вот красненькую строчку на самом деле конечно правильнее делать
здесь но копирование списка вот это но это мы заситились только в next мы еще чего мы да то
есть на самом деле смотрите как пока мы реализовываем чисто бинальную кучу сифт у нас будет рекурсивный
вызов только один ув next поэтому обратите внимание что сифт он по-любому пройдет по всем next и
вот упрется в конец поэтому поэтому как бы если вы перед этим сифтом попытались пробежаться по
там по детям убедились что их достаточно много то в общем-то вы симпатически ничего не потеряли от
этого вот но когда вы а вот когда вы вот в этот момент отпиливаете ребенка вот например вот
таким образом вот такие или вот таким да то вы-то можете накидывать монетку да а что нам
ломает но нет ну как бы инварианта это ничего не ломает единственное пока нам это ломает что нам
чтобы нам хотелось проанализировать видимо это нам придется так почему-то никто не выгоняет
нет я не знаю просто да да да да нас уже слушать нет мне даже интересный послушали
нашу тематику так так так она собирается выгонять или не собирается ну хорошо ну ладно
злая нет но пока смотрите первое нет вот смотрите значит ребят первое что хочется сделать на самом
деле так вот на самом деле уже про описал собственно как бы мы хотели вот так вот
реализовывать бинляльную кучу спокойно спокойно вот и хочется доказать что мы тут не просто хорошо
сделали а хочется доказать что как бы о этой куче мы инстинк сделали залаза рифом а все остальное
за единиц чего надо не минимум не минимум нам не на нет что минимум где бинг где да но мы говорим
о файнд миге да теперь надо доказать каким-то образом что файнд мин на самом деле абортизировано
работает завод единиц но там разные проблемы возникают
чего у нас не происходит сейчас корапт ключей чего нет да вот поэтому я и не
корапта пока нет это пока честно бинляльная куча все еще как бы мы вставим тут еще в одном месте
одну магическую строчку и начнется мягкость да не сто лет нет у нас все-таки выгоняют все ура
нас выгоняют давайте знаете что так ну что ладно давайте-ка может быть для может быть
более точного анализа может быть где-то мы с вами давайте попробуем немножко покудить ну вот или не
надо нет но я думаю надо все-таки тут попишем прям на доске но почти описание и то еще как бы
самое как бы где собственно происходит именно же там вот это вот но был но это мы но нет ну
кратко можно обсудить что скажем так если неожиданно но скажи так если вы сделали сифт от этой
вершины то да вот для нее и всех ее предыдущих товарищей конечно вам придется пересчитать
суффиксные мины но заметим что так как тут у нас если у нас мы то сделали за омега от ранка потому
что у нас есть как минимум половина элементов есть значит омега от ранка да а вот тут у нас
элементов слева тоже там от ранга то получается что пересчет суффиксная мина не на никакой
симптутику не повлияет поэтому никаких проблем это не вызывает значит смотрите так вот ровно
вот ровно с этой целью как бы во избежание всех вопросов давайте пытаться подписать значит
смотрите сейчас мы будем пробовать пробовать будем выписать немножко так значит так ну
а первых давайте так во первых давайте начнем так с чего мы начнем но первых давайте начнем так
так у нас есть так давайте думать так стракт ноде давайте капсом будем писать что у нас
стракт ноде вообще есть но давайте так я буду немножко в более таком c++ стиле писать вот
тк с кей но как бы да в статье конечно используется инты но как бы мы будем подчеркивать что на
самом деле конкретный тип кучи тут не принципиально но ладно будем дополнительно предполагать что
тк это такой тип у которого есть значение инфинити вот так для простоты да а вот ранг у нас будет
интом правильно даже было написать ансайн тентом но ладно на этом уже тоже как это вот там уже
заморачиваться не будет так значит что нам еще надо значит но естественно ноде звездочка child и
звездочка next и конечно ладно на этот раз у нас не будет указателей ил и ил тейл а вместо этого
а вместо этого сет сезона
да вот ну давайте воспользуйся да вы возможно еще не знаете но вы стали есть лист да я на нем
да
там помдаш специальная функция на эту тему есть так так вот значит это был ноде так
теперь достаем коричневый маркер и создаем стракт хед
а пардон нет мы же мы же тут это капсом пишем ой и тут капсом пишем ой
хед голова вот ну если вас это ноде и хед не запутает то окей ладно давайте
но я как брал но скажем так тут две цель но во первых как бы для большей унификации
систем как вот написан статье а во вторых там смысл в том что как бы ноде и хед это то что
мы создаем сами а вот все вот эти типы они как бы и сишная стандартная вот ну ладно значит
будем хед значит смотрите значит ладно значит что мы в этом хеде храним но в этом хеде мы
храним соответственно так но во первых это так ладно так вот действительно что мы во первых
но во первых мы храним конечно же ноде звездочка ой слушайте как это дерево назвать root давайте
назовем но можно root 3 там знаете там хит знаете хит там вообще там вообще хит сезона по
мистической причине в самой статье это вообще кьюя называется я не понял почему но видимо
но видимо мысль в том что да это какая-то очередь все-таки с приоритетом это вот так
воспринимается но потому что с помощью севта это действительно так оно и есть где в каком-то
смысле вот где двое точек да да да мы попытаемся значит еще важный момент им
для видимо некоторого удобства мы все-таки себе ранг напишем но то есть он будет чисто
совпадать с рангом рута но это уже другое чтобы не переспрашивать да вот так
это не заработает не не не ну ладно давайте не до мы не до такой степени будем упарываться
так внимание внимание так пишем теперь хед звездочка next и звездочка преф да
можно было наверно тоже тут сказать что это лист но мы так не будем делать почему нет ну нет
все эти вы только по одной причине наверно попытаемся все-таки ручками сделать потому
что у нас есть еще один хед звездочка суффикс мин который вот так ну и теперь вгибание вопрос
что такое куча так ну и пришлось да ладно раз у нас все черное значит как бы сама
себе куча объявляется так черные работают значит ну ладно ладно но по-хорошему надо обернуть
потому что единственное что в этом софте хиппи есть это конечно же указатель на хед не
не получится ну во первых тут одна строчка осталась
да тут надо вообще писать шаблон причем еще и от шаблонный параметр будет дабл
эпсел он еще но давайте ручью называть который мы потом добавим пару строчек и повеселимся
да потому что потому что мы так захотели нет как хед это одно конкретное дерево то
чем вот вот это хед точнее вот оно хранит вот это дерево это другой хед он хранит вот это
дерево и так далее надо для того чтобы но потому что смотрите дело в том что в каждой если вы
в вершине будете суффикс мин хранить это будет неудобно что вершина может быть корневой в
дереве может не корневой поэтому мы как бы отделяем сущность дерева отсущности там список
деревьев вот это на самом деле такой правильный ход на самом деле вот хорошая практика значится
поехали ну давайте самое легкое что тут можно реализовать это конечно функцию крейт ну потому
что надо что что что надо сделать ничего чего но вот но вот ну соответственно да действительно то
есть можем так и то есть что там надо софт ну давайте софт хип крейт ну здесь уже понятно тут
можно просто написать ритором софт хип от от чего от нулпот эра конечно да тут даже не интерес
так что что то есть не говорим что вот тебе там число x сделать так чтобы оно лежало в
это insert ну да ну да ну хорошо но да но давайте хорошо с вами согласен имеет смысл конечно
софт хип давайте так крейт от икса давайте то есть давайте все-таки подсунем туда хуенчик ключик
таки ки так это не таки это почему ну почему я себе но вот это ну смотрите но как бы сама
куча это двусвязанный список деревьев но вот и соответственно рутс это будет просто указатель
на ее вот первый элемент ну указатель на список корней но мы это подчеркиваем что мы как бы их
да ну ну хотите можем феструт назвать пока не поздно пойдет ну либо феструт либо рутс
ну вот значит поехали значит ну во первых нам надо создать новую вершинку так давайте
смотреть что у нас значит но первых дан так нужно создать новую вершинку давайте создать
ее так ну во первых поехали она нам это будет очень удобно потому что insert мы будем сводить
вот этому крейту и мылду двух кучек вот так же такая вот идея вот значит поехали начать
но где да да в идеале конечно неплохо было бы крутить до и итератор конечно возвращать
да а что что это не обязательно а о боже господи да дайте да нет просто я сейчас
судьбе не можно включить режим дедушки который от таких которые как бы вроде вопрос логичный
ты знаешь, что мы такие вопросы там по...
там он говорит, ну с тобой невозможно разговаривать
ты увязаешь вообще в частостях, надо как бы в общем
понимать о чем говорю, а не
по подобным мелочам смотреть, ну вы что
вообще не туда выслите, ну вот
нет, я так делать не буду
но предупреждаю
но как бы да
но в принципе согласен, да, точку запятой не надо
лазить дальше
значит
значит, итак, поехали
где пробелы, где код стайл
так, код стайл
пока там, значит плюс-плюс
и будет
ага, ну декстайл, да тут тогда привиус
давайте писать, тут std
двуточи-двуточи давайте писать, ага
you need namespace std, нормально
а, умные указатели давайте
писать, ага, да, замечательно
не-не, так, все
тихо, так, тишина
а то
а то как бы, понимаете, да
а то мы это еще в следующий раз будем обсуждать
вот
так вот, значит
создаем новую вершину
просто пока, просто ноди
равно нью
ноди
нью ноди от чего, ну я тут чтобы лишние
строчки не тратить, значит поехали
что
кей запятой
для начала ck
давайте так
а, потому что я лишнюю точку
поставил, значит
пока кей, ранг соответственно
ноль
так, ну здесь два нул птр
тут тоже два нул птр
ну вот, и как бы нью
вот так давайте
нью лист от тк
вот здесь, наверное, так напишем
от кея
не факт, что он сработает
не, скорее всего
скажи так, у листа должен быть
такой конструктор
ну не у всех
структур, у которых, казалось бы, должен быть
он реально есть, ну поверим
но знаете, вы все равно, я думаю, будем для простоты опускать
момент, что по-хорошему, да, надо
итератор на этот кей вернуть
и как бы потом по этому элементу еще понимать
где он, а для этого, наверное
придется этот лист реально там
то есть не стояли с кем пользоваться
реально там создавать как-то
очереди, например, нет, хотя там тоже кажется, что
ну понятно
ладно, значит, смотрите
значит, далее еще мы там может быть где-то
от, как говорится
о мусоре, может, не будем задумываться там
вот, ну не важно, значит ноди
создали, теперь создаем
хед, да
создаем, как мы хед создаем
хед
значит, хед
равно new head
вот, ну а в ней
соответственно, к чем мы пишем
ну, соответственно, ее величество
ноди, естественно
ранг нулевой
next и
next и пребы все, соответственно
кто?
ну, птр
ну, птр
ну, птр
ну, птр
и, конечно, его величество
суффикс мин, не-не-не, ну давай
лучше мы в явном виде будем прописывать
тут как раз для, это важно для понимабельности
и ноди
вот
и что-то еще надо
сделать, а что?
не слышал?
ну да
ну, по большому счету, да
return
soft
hip
суффикс мин, это же указатели на хед
не, ну
мы должны
потом на
ой
да, изначально нул птр
да, вы правы, спасибо
значит, пока нул птр
так, тут после этого написать
соответственно
значит, суффикс мин
как раз
ровно
себя любимого
себе, нет
себе любимому
вот
вот
и, вот так вот
я могу вот так вот
вот так вот
вот так, могу
еще вот так вот вот так вот вот так вот вот примерно так мы создали создадим
кучу из одного элемента обратите внимание только в этот момент мы будем
эти листы создавать то есть забираю вперед готовьтесь морально к тому что
цель севта будет мне сделать так чтобы корневой список был не пустым его цель
удалить этот пустой список и переформатировать дерево а что там
где хед суфик а ну хеды присваиваем но как бы если у вас списки одно дерево то
суфикс мин у него указывает на себя так так ну что господа так а теперь давайте
я тут еще чуть-чуть попишу видимо где-то внизу но ладно давайте я вот эту скобочку
сделаю поменьше нет ну да я напишу инсерт конечно вот так но здесь я смотрите как
напишу давайте я у меня будет у меня будет читерство когда я но дайте я буду
предполагать так что когда я вызываю операцию от кучи она удивляется и уничтожается а
вместо него появляется другая куча которую я и верну а будет а будет мне удобно так
не но но скажем так дело в том что смотрите мэл я планирую как бы писать что мне приходит
на вход две кучи и они уничтожаются вместо этого и появляется третья куча которую я и вернул
но я но я могу конечно переприсвоить а ну если ну ладно если так хотите пожалуйста ладно по
барабану действительно так воет воет инсерт инсерт от значит давайте но здесь там но здесь по
барабану в каком порядке так значит давайте софт хип у нас будет с аж и допустим мы еще
хотим передать ты ки что мы делаем но мы говорим с аж равно мэл от аж и соответственно
крейт отки вот
а
но давайте так я давайте так я не гарантирую что мы сейчас напишем прям идеальную версию
ну да вот на этом и может и да на это мы скорее забью так вот значит теперь давайте думать как
же мы будем значит как же мы теперь давайте как же мы напишем мэл значит смотреть
значит смотрите на самом деле смотрите тут как бы вот будет такое так значит
дат на этот раз внимание софт си внимание мэл давай если нам постоянно смотрите ли вы
нет смысле нет есть конец появится новые задачи естественно я вас об этом предупрежу
вот на этот вопрос я пока не умею отвечать так а вот это да вот это так без паники без
так вот мэл внимание внимание внимание все будет спокойно все будет все в порядке будет
да и так мэл значит поехали так сливаем соответственно так ну во первых ну давайте
поехали значит ну во первых нас интересует конечно так ну давайте так нас интересует два
указателя ну давайте вот пусть у нас два указателя на хеда и будут хед звездочка ука один ука от
слова указатель а что такое а господи тогда уж птр давайте пожалуйста
вот вот так вот птр 1 птр 2 вот такие вот указатели да видите да значит еще у нас будет значит еще
для того чтобы аккуратно сливать нам что еще нужно как перенос как там перенос по английски будет
равно 0 птр да нет и хед и хед звездочка но допустим ans равно 0 птр пока
вот
но вот ну и на всякий случай еще напишем хед ans back потому что мы в конце в конец тут будем
значит поехали ans back а это указатель наконец надо было ans tail написать но уж
вот значит поехали
потому что смотри нам просто ну я могу конечно хранить только указатель наконец об том его в
конце превратить в указатель на начало это да ну если если хотите можно так сделать пожалуйста
ну нет можно нет а знаете давайте так сделать да сейчас мы перенос ну когда вы складываете
в столбик да так ладно давайте ans ans back оставим хед звездочка ans back равно ну понятно пока
0 птр далее что мы делаем так нет погодить но сейчас вы увидите значит как теперь слияние
будет выглядеть while соответственно ptr 1 and ptr 2 значит смотрите внимание пока они оба живы
пока они оба живы значит ну во первых давайте так начнем с того что давайте давайте сделаем так
что птр 1 ранг не будет больше чем птр 2 то есть делать это достаточно легко если птр птр 1
рк больше чем птр 2 рк то соответственно свап птр 1 птр 2 вот
а там мы просто рамки заводили а да ну хорошо не пудай пожалуй вы правы да давайте так и
сделаем да да да конечно конечно так ну дальше что мы теперь делаем но один из вариантов говорим так
значит если совершенно случайно оказалось что керри не пустой да то есть если керри
ну нет ну по-любому придется разбор случаев делать что делать но что делать ну во первых
да давай ну мы уже нет смотрите от половины случаев мы то есть отчасти случаев мы избавились мы
точно знаем что птр 1 ранг меньше либо равен понятно но ничего сейчас разберемся не важно
значит далее получается такой значит если перенос есть да но могут быть равенства поэтому вот с
этого и начнем если выяснилось что керри ранг оказался строго меньше допустим чем птр 1
то что мы тогда делаем то соответственно вот сейчас мы напишем значит то мы и сделаем так
значит начиная я напишу так я напишу функцию push back 2 ans там ans ans back и керри
то есть эти вот ans ans back я даже буду посылки передавать чтобы они поменялись ах да
ну хорошо давайте так значит push back от ans и керри что что да
керри равно ну птр да мы можем написать и в керри ранг меньше чем птр 2 ранг и тогда слить керри
птр 1 а потом будет нет смотрите тут так сейчас парадить про нот да нету я скажу так давайте я
еще тут по всякий случай континью напишу да может оно нам не понадобится но как бы как
сигнал того что да в этом месте while продолжается хоть птр 1 и птр 2 не сдвинулись так что делать
если ну очевидно если ранги у них совпали то их придется сливать вот ну давайте так я на всякий
случай я напишу так чтобы не путать обозначение я напишу так значит head ну давайте так head
звездочка tmp равно meld heads значит от керри и птр 1 от этого птр 1 да вот значит и говорим что
если ну теперь ну теперь у нас по большому счету два варианта так ну вот ну во первых птр 1 мы точно
можем двигать теперь да это мы уже точно делаем птр 1 равно птр 1 быть быть next а вот что а вот что
делать с птр 2 но тут два варианта на самом деле то есть опять два случая то есть если оказалось
что то есть два варианта либо у tmp ранг не выше чем птр 2 то есть если оказалось что tmp ить ить ранг
меньше либо равен вот этого ранга 2 да птр 2 быть быть ранг то соответственно все что я в этом
месте предлагаю это на самом деле а давайте то есть для простоты можно этот tmp просто перенести в кэрри и все
значит значит кэрри равно tmp просто вот вот ну давайте я тут ранг напишу
напишу напишу напишу напишу и что теперь что я теперь теперь сделаю но в противном случае
но в противном случае у меня будет очень простая идея но хотя да хотя да по большому счету кэрри
равно tmp произойдет по-любому просто нет просто нет если больше значит этот птр 2 точно теперь
надо занести уже в ответ да поэтому да кэрри можно сказать кэрри равно tmp будет по-любому да
давайте я так но я вот так напишу вы вынесите там копипасту значит соответственно tmp значит push
back to ans back to ans соответственно от птр 2 ну и соответственно да и все на самом деле нет
птр 2 надо еще сдвинуть а push back to ans может их немножко испортить ну просто в идеале
я должен написать просто птр 2 ров до птр 2 next но на самом деле тут тогда возникнет маленький
вопрос как я буду реализовывать push back to ans если я как бы говорю что то что у меня там что у меня
в конце ответа он там то что куда он там указывать вправо нам пока по барабану
а мы можем сделать так чтобы нам push back to ans возвращал она что изначально указывал
там птр и next так пушбек тунн нам ретернет просто что справа оказалось ну так он ну в смысле
указатель на этот текущий птр 2 он и будет возвращать так и будет не в смысле пусть пушбек
тунн нам ретернет именно вот как значение next от птр который мы ему передали ну не знаю а в
кэре тогда какой смысл но я не знаю по моему это звучит как провекти нуждаются лишь шнурки в
повторном связи так и пропишем сразу кэре равно push back to ans и он вернет нам птр и здесь мы
пропишем что дайте слушайте легче честно скажу легче написать так тмп равно птр 2 все вот все
ребят все да правильно абсолютно то есть птр лучше от прайи ну просто нет правильно писать так чтобы
ваш код как бы не зависело того максимально не зависело того как вы эту функцию реализуете так
птр 2 равно не зачем птр 2 чтобы не путаться next то есть теперь как бы это то что мы добавляем
это в тмп и теперь вот push back to ans вот правильнее вот так написать но это мы сохраняем эту но мы
выяснили что это вот птр 2 на самом деле это деревца которые надо уже добавить в ответ
поэтому мы мы его оставляем себе в переменной тмп вот а значит птр 2 соответственно сдвигаем
то что по любому придется двигать да строго после кэре равно тнп точка звездочка тмп равно
птр 2 витя чего вот так ну и здесь соответственно тмп так ну что все вроде случаи реализовали
потому что непонятно когда вы push back и тх не очень по дефолту понятно что что действительно
что как бы делает push back с этой вершины в плане куда указывает next как бы теоретики но вот
то есть по хорошему лучше если уж добавляете в новый список наверно лучше предполагать что это
конец списка и как следствие писать что там был пт и это мы разобрали случай если есть кэрри
но что делать что делать так
ну погодите погодите сейчас ладно самое интересное будет потом но давайте так вот этот
код можно стирать вот я вот вот эти вот заявки я не хочу стирать давайте так так нет но вот не
так как ну институт а инстит можно он такой интеллектуальный так ну ладно я думаю кто хотел
это уже записали да и думаю ничего не тривиального тут нет он такой такой да как говорила не забываемая
да павлик он такой такой так это еще не все теперь мы просто продолжаем иф это еще иф не
закончился напоминаю так давайте так а теперь смотрите да нет иф закончился но мы тут пишем
вот вот здесь теперь будем писать да у нас тут этот л за продолжается вот до какого-то момент
а раз у нас но если у нас кэри нету то ладно давайте в качестве упражнения вам оставим самим
что там будет я думаю вы сами догадываетесь какую приблизить на радость там надо написать вот
самое интересное конечно же будет в другом тогда ваил на этом заканчивается да да
вот так вот сделаем и вот но теперь хорошо мы действительно что-то слили у нас есть амстубэк
да понимаете да значит далее мы делаем ну значит теперь получается что у нас произошло у нас кто-то
из этих указателей теперь указывает на пустоту хотя бы один может и оба правда но чтобы избавиться
от случая мы сделаем просто если не птр-1 то соответственно свап птр-1 и птр-2 можно было
присвоить но если птр-1 то запихнуть его конец потом так же если птр-2 не не не не не надо его
запихивать в конец потому что мы договорились что как бы эта функция может обнулять указатель
дальше поэтому не надо здесь мы будем сейчас более аккуратно делать да else ну и тут я сказал что как
бы там в общем напишите какой-то аналогичный код но там будет два случая если ранги равны то
значит складываем там складываем отправляем в кэри и прибавляем к обоим там если нет то
соответственно просто отправляем птр-1 соответственно в там вансы сдвигаем только
птр-1 все он там нет нет нет нельзя потому что pushback мы не знаем как как реализованы pushback
pushback туанск скорее всего может быть реализована так что мы решили что раз
мы этот хед добавляем в конец нового списка то наверное значит раз он должен быть в конец
то на что не должен быть пустым и мы это чисто переприсвоим где где вот здесь ну в лз что
чего написать где написать сейчас а мы там так сейчас хорошо дальше получится а если кэри то есть
pushback туанск и равно а а слушайте а ну ладно давайте ладно давайте попробуем этот прикольчик
мы даже напишем пожалуй да и зря мы это делаем ну ладно значит говорим так значит вы чего
предлагаете предлагаем кэри равно птр-1 птр-1 равно птр-1 стрелочка next так и утверждается что
независимо не от чего все но то есть это вот л за что утверждается что прям все в обоих случаях
не но давайте разбираться что произойдет если это два варианта ну как бы у нас как бы пока там
пустота давка в переносе если если двух деревьев не одинаковый ранг то есть у птр-1 меньше да то
мы переносим его в кэри и сдвигаем птр-1 тогда на следующей итерации произойдет что кэри выяснится
что он будет заведомо меньше там птр-1 ранг да ну или там кэри останется и там соответственно вот
и тогда он просто будет добавлен в ответ кэри опустеет и в общем-то все сделается честно сейчас
добью но вот если же птр-1 и птр-2 были одинаковые то на следующем шаге реализуется вот этот случай
они там честно смешатся и там и вот и поздвигаются да получается хорошо
ничего страшного нет это нормально что так случится что одна куча закончится а кэри выжил
это нормально да да да нет я не сказал что в этом месте нет боже упаси считать что в этом месте то
есть на на этом вайле мэлты заканчивается боже упаси это не так нам потом еще отловить где что
живое запихнуть это в хвост значит сваты нет но это легко отлавливается и так мы знаем то есть
мы торжественно дошли внимание до того что птр что там либо что либо птр или птр-1 или птр-2
пустой может даже оба кстати если повезет понимаете да но этот случай рассматривается легко давайте
сделаем так что если есть не пустой то он будет птр это мы сделаем вот стандартным приемом
дальше и в птр-1 так теперь внимание ну дальше теперь оказывается что птр что птр-1 может
оказаться не пустым и кэри может оказаться не пустым и более того боже у них ранги могут
совпасть у кэри точно меньше или равен значит смотрите значит да если есть кэри то он заведомо
меньше либо равен птр-1 по рангу это мы точно знаем внимание поэтому пишем так смотрите
значит while значит пишем кэри and and птр-1 and and их ранги совпадают кэри ить-ыть ранг
равен птр-1 ить-ыть ранг так господи зачем я стукаю вот ранг ранг ранг что я делаю дальше
что я делаю дальше не слышу так ну здесь я делаю достаточно элементарную здесь вообще
тривиально смотрите а вы правы да давайте скопируем в тмпшку да как всегда как всегда
да а нет у нас так до хед звездочка дамы пишем коричневым поэтому хед звездочка
тмп равно птр-1 там птр-1 равно птр-1 быть next и что дальше и соответственно кэри
мельт хипс от кэри и соответственно птр-1 да мы видим это все что мы хотим да да
мельт а потому что а мельт хец хец это одна буковка вот такая красота
ночем до сливали что теперь происходит у нас может живой кэри быть может живой быть но дальше
но начнем с простого теперь мы замечаем что если кэри и живой то он заведомо меньше всего что
да да да да молодцы спасибо что еще значит первое что но если кэри жив то он меньше всего того
что есть птр-1 поэтому да поэтому да внимание если кэри то соответственно пушбэк туанс
значит анс бэк и соответственно кэри не не не не нет внимание очень важно пушбэк туанс он
один одну хеду добавляет это вот поэтому там скорее будет поэтому я скажу так правильнее
написать так коннект хедс коннект хедс от анс бэк и соответственно теперь птр-1 то есть
коннект то есть видите чем отличается коннект от вот пушбэк туанс то есть я значит я взял
хед она чисто выдернула из того списка добавил в новый а коннект хедс говорит что как бы вот
у меня есть две вершины я хочу чтобы они соединились и чтобы то что слева и то что
справа сохранилось давайте мы просто кодом напишем хотим анс бэк мэк что равно птр птр
прег равно анс бэк нет ну слушайте на усмотрение давайте тут лучше пока так значит коннект хед
значит соединили и внимание и осталось только одна маленькая зелененькая строчка
а точно одна маленькая ну давайте так но я так скажу ну ладно там ифчик получится мы же хотим
ну во первых может так случиться что но дело в том что нам осталось делать по-хорошему нам
надо все вершины от начала списка до анс бэка включить на в них пересчитать суффикс мин ну
лучше правда в другую сторону но наоборот от анс бэка и влево до конца пересчитать суффикс
вот поэтому я напишу так значит я напишу так если анс бэк оказался пустой если не анс бэк
то все что вам остается это ретурн
да мы что поминает софт хип возвращаем да софт хип от птр 1
ну потому что тогда начало списка в птр 1 в противном случае
ну лучше написать конечно вот так вот давайте я так аккуратненько напишу ретурн вот я тут
употреблю функцию название которое есть в учезеля фикс а то нет там было фикс мин лист нам чего
до суфига суфикс минс и в суфикс минсе значит я передам анс бэк но буду рассчитывать что как
бы он мне вернет указательного начала а он нагрёт указательного начала списка мы хотим этого
а правильно да давайте так чтобы не вся длинную строчку давайте так это звездочка анс равно и
соответственно в конце пишем тоже ретурн сейчас допишу софт хип от анса все на этом заканчивается
да давай потому что в этот список ни одно дерево не добавилось например один из примеров вот
мы же отдельно не рассматривали случаи когда вам подсунули одну из куч изначально пустую где
рассмотрен ну и что и что но нет канак рец рассмотрит как случай когда патер один пустой так
когда анс бэк пустой тогда он просто скажет что у патера 1 значит премо нету и все в порядке
так ладно если это непонятно сейчас я почищаться скажу как этот канат хедж мы реализуем что ж там
не будет не будет смотреть вот давайте сейчас я так раз есть вопросы так что там так все
канак это вообще ничего не вызывает конец это он вообще ничего не возвращает потому что он
даже эти указатели менять не будет значит смотрите значит ну аккуратная реализация вот
этих вот значит и мелких функций будет выглядеть так смотрите void connect heads connect heads вот значит
получать на вход она будет значит два хеда хед звездочка так сказать давайте я так напишу он
у меня тут локально он будет называться left back и right front ну типа у меня есть два как бы у меня
есть как бы указатель наконец одного списка и указатель на начало второго я хочу сконнектить
и я говорю значит если обоих не существует вот я просто буду прям очень скупулезно
рассматривать все случаи если обоих не существует то мы можем из этой функции радостно выброситься
да ну значит поехали да да именно именно а ну здесь а ну здесь вообще смотрите тут
вообще сейчас очень красиво получится если не left back то да right front да уйдь уйдь прем равно
left back потому что я с это не пустая то мы знаем что это нот а зачем тогда и а действительно это
если не рейт фронт как раз нет наоборот даже наоборот если просто если райт фронт есть вово вово
до ночью да вот прям кайф сейчас да если left back есть суща а а это мы зачем писали вообще
сущи мы по моему вот это и можем выкинуть сущь в обществе какая красота-то
ну нет мы вот нет это да best practices да никакого речерта уже нет все вот это все что вы делаете
вот
та перечка ну и теперь в качестве добивочки можем еще push back to us реализовать давайте вот
прям вот в этом же столбике void push back to us нет знаете нет на самом деле вот мне кажется
это хороший стиль кода пишите сначала глобальный код но всякие технические мелочи вы как бы выносите
функции которые обещаете себе реализовать позже но вот нет на самом деле нет это работает это так
это отличная практика но просто у вас потом накапливается сто этих функций и вы хватает за
голову начинает их реализовывать нет прийти до но тут проблема такая в том или ином виде вам
их придется реализовать так или иначе но одно дело когда вы все одновременно в голове держите а
другое дело сказали штат вот у меня будет задача вот решить вот эту техническую задачу вы даже
когда ее создаете вы себе прописываясь я должен создать функцию которая делает вот это и вот это
желательно в этом месте четко присописать себе что она конкретно получает и что конкретно делает
вот потом да у вас получается много функций но каждую из этих функций вы уже когда реализуете
вы вообще не думаете о 99 остальных и это сильно снижает как бы вероятность то есть как бы это
называть вы декомпозируете задачу на вот мелкие подзадач не это уже другое но преш это как бы не
сильно в тиме то есть это на самом деле ухудшает процесс дивара потому что как бы даты там надеюсь
что тебе прям сейчас повезет но как бы дальше чем дальше ты это делаешь тем меньше ты начинаешь
думать как бы я сейчас говорю я сейчас говорю не о том как это там потом оперативно записывать я
говорю о том что как писать сложную задачу так чтобы количество баров минимизировать в принципе
но то есть я часто когда если это так вот аккуратно пишешь и прям в каждом минутке когда пишешь вот
саму эту функцию ты не задумываешься о том как конкретно ты реализуешь вот это это а когда
пишешь эти функции ты не задумываешься о том как ты реализовывал мэд то потом ты скорее
всего вообще удивишься что багов нет оно сразу заработала скорбила ну или почти заработала
просто проблема в том что вы сначала не думаете не думаете а потом у вас он пятый вылезает там
не должно быть но скажем так ну с одной стороны да но так но с другой стороны вы по камере
начинаете с того что как бы код у вас уже работает и чаще всего этот энд пятый потом
в кубе на той же инфраструктуре допилить да в этой функции да мы так уверены да мы так хотим вот
канак так работает почему мы здесь когда мы ее здесь вызываем так и происходит шанс бык указывает
наконец уже набранного списка аптер один на начало того списка к которому мы хотим это
приконнектить вот теперь поехали
да и мы его еще не писали и мы его напишем ну раз уж ладно раз пошла такая пьянка что давайте
уж писать что да не то чтобы я планировал это делать но я думаю как бы как вы знаете
тысяча строк кода вместо тысячи слов о том что там должно быть да вот так хотя бы да так push
back to ans вас издаст так значит push back to ans это что мы делаем значит что мы передаем но да
мы передаем по ссылке внимание анс бек и передаем то что мы хотим добавить хед звездочка хед на
этот раз мы требуем что раз уж хотим добавить то мы никогда пустой не кидаем поэтому тут мы
даже для себе же для безопасности пишем ассерт хед но проверяем что да мы хотим тут у головы
добавить она вот это ай ай ана существует потому что мы как бы указать сами эти указатели не
меняем то есть я как бы взял вот эти две вершины на которые я указываю они есть то это тут ну вот
все они как бы и ну если они есть конечно то я их коннекчу вот теперь push back to ans значит
поехали нет но здесь все просто но здесь давайте я вот подпишу что давайте хед next равно 0 птр чтобы
как бы все было корректно ну что как бы список был корректный последний элемент указывал в
пустоту они куда-то там непонятно куда ну и здесь все просто теперь я пишу коннект хед значит
в ans back и хед ну и конечно в конце все что вам остается это написать ans back равно хед да если
вы напишите ans back равно ans back next это будет ошибкой почему это будет ошибкой потому что
этот указатель может указывать и на ну вот вот да нет видите но не дайте мелкие как бы штучки
они какие-то простые вот значит теперь но и остается конечно реализовать так что нам
осталось реализовать а ну нам у нас да у нас остаются две мистические функции которые отсюда
надо реализовать это fix suffix means и конечно его величество meld hips так да не все тупые в общем
так ну давайте с кого начнем а серд это функция которая проверяет булевые выражения которые
передали если оно тру то оно ничего не делает а если пост она начинает вопить и выбрасываться из
программи с криком terminate ну короче нет это не сроу нет это не сроу exception да но это это но вот
то есть нет это это так знаете себе для дебара то есть если это серд упадет значит программе
пошло что-то не так ну знаете но это не значит что не надо страховаться как бы мы-то себя
знаем как бы это мы можем допустить бар и мы будем это делать что я скорее скорее exit 1 или exit
что-нибудь еще не но не совсем поемте там так а серд то по моему вы уже не перехватите а с
ролика exception можно перехватить exception там вы можете перехватить и там это вот то есть по
хорошему да надо писать с роли там exception там понимать какие exception и происходят там как-то
это прописывать но мы как бы сейчас не будем уж совсем настолько если так заборачиваться надо
было и template и писать там от epsilon автомат тк вот это все согласен вот так теперь
так господа внимание внимание внимание так ну теперь давайте так ну ладно давайте это
чтобы так плавно будет плавно переводить таз к тому как реализуется все остальное вот и
соответственно пока напишем fix suffix means значит поехали так ну давайте так значит давайте так
значит head звездочка fix suffix means suffix means получает она на вход что она получает head
звездочка так сказать back ну да но здесь по-разному давайте уж раз уж мы так написали давайте тут
ассертица на тему того что как бы этот этот элемент действительно существует в том плане что
есть что фиксить ну то есть это не обязательно тут конечно но там просто else если тут можно даже
не ассервить нет по-разному можно но вот метод функция реализуется независимо потому что мы
это сделали того что мы значит fix suffix means в интерфейсе прописали что этот указатель должен
быть не пустым поэтому дальше мы думаем так в интерфейсе прописано что не пустым давайте
это еще и перепроверим но те вещи которые можем очень просто перепроверить вариантный стоит
перепроверять вот значит дальше говорим следующее что еще раз что почему connect heads и pushback
которая вызывает само по себе вызывает коннект нет это другая функция мы еще реализуем да мы
она еще прогремит да ну ладно не прогремит вообще все если не писать ассерты не будут
ну наверное не будут не будут правда возможно правда возможно дебак у вас это будет чуть-чуть
дольше очень сильно возможно так значит смотрите так рябки значит маэл бэк значит что вам надо
вам надо теперь вот в пересчитать суффикс мим для этого вы говорите
значит чтобы пересчитать убака суффикс мим как вы как вы пересчитать
значит пишем таки допустим майки равно чему но так и пишем значит так пишем бэк
быть быть так как мы его там обозвали рут быть быть сики да напоминаю мы живем только по
псевдогимом да погодите теперь смотрим следующий таки next мим следующий причем
еще и минимальный секшер наверное может никто не сказал что справа от нее вообще что-то есть
а если есть мы должны проверить значит да нет тихо тихо значит внимание я поэтому я пишу так
если бэк next конечно если он существует то здесь ой сейчас заклинание будет бэк
быть быть next next быть быть суффикс мим ой слушайте о чем я никто не поправляет
почему а суффикс мим через нижние подчеркивания пишу вообще так а я тут день суффикс мим вообще
так все быстренько никто ничего не заметил но я не занят просто как-то ну не как-то знаете
просто видите везде вот левдбеке так пишу поэтому так так вот но да типа так суффикс мим быть быть
это будет работать за вот единицы ну вот единственную константу так вот двое точие
в красота да если его нет только еще бесконечно и вот теперь пишем значит поехали значит после
этого мы также с напишем значит тут очень важно так значит пишем ну давайте еще один
тагнарный оператор напишем значит бэк быть быть суффикс мим равно значит смотрите тут я
аккуратно если next мим оказался меньше сейчас я объясню почему я именно в таком порядке пишу
то есть если он строг то есть я как бы в next мим его отправляю только если там next мим строго меньше
потому что при равенстве я должен его отправлять майки потому что как мы помним майки может и плюс
бесконечности случайно оказаться ну бывает такое помним как говорится помним да так значит тут
мы пишем двоеточие в этом случае мы пишем вот этот как так вот копипастим вот эту строчку
короче но вот это вот бэк быть быть next быть быть суффикс мим вопрос ну вот а да вопрос согласен
ну правильно но и что сейчас все сейчас увидите я смотрите я для него пересчитываю а вот дальше
я вот так вот мне тут да можно написать while back хотя правильнее написать было while true на
самом деле хотя тут по барабану дальше я напишу если не бэк быть быть если некуда дальше идти
то я просто объявляю что ретурн бэк лз я говорю бэк равно бэк быть быть так красота да вот мне
кажется да это хорошо вот и все так так а значит это while закончился и код закончил вот ура ну как бы знаете
как во всех таких со структура говорят да по константе может работать не очень а в некоторых
случаях для современных в современных данных при современных ограничениях современных
дабл юбитных дабл ю в дабл юбитности это вообще будет работать медленнее чем логен и но нам
плевать нам интересно теоретически да мы статью вы писем код чтобы понимать алгоритм знаете
как это да сдвинули бэк назад но при этом сказали по этим и договорились что фиксу фикс
мимс должен как бы вернуть указатель на реальный начало это списка да вот видите мы же вот мы же
вот это вот вот чтобы вот так красиво написать то есть вот я просто хотел вот это взять чтобы
как бы вот да потому что у нас все время там возникают какие-то сомнения где мы там что где мы
там что написали где мы там что делаем какие-то мелкие детали вот давайте вот я по коду показывать
что мы реально делаем так ну и чтобы покончить по крайней мере с моим дом ну ладно видимо я
сразу скажу дилет чем нам тогда вообще вали бэк ну по факту да а потом еще выбрасывай совершенно
верно можете написать ваил бэк вошли написать ваил тру в данном случае это будет одно и то что так
ну что так ладно что из этого можно стирать давай потому что могло так случиться что мы ванс
ничего не добавили ну во первых это могло случиться если одна из один из этих списков
пустой такое могло случиться вот а во вторых если случилось так что в птр 1 1 1 деревце
которые равно соседу то вы тогда это птр перенесете в перенос вот у нас мы так код написали да
а нет мы и нот да мы его там ладно но там смотрите вот предположим что у вас тут у одного дерева
будет там допустим ранг 5 а у другого будет 5 там 6 7 8 9 да то тогда что произойдет смотрите
давайте по коду смотреть кэри у нас нет да поэтому произойдет следующее значит ну что произойдет
во первых нам это мы это отправим в кэри да то есть это будет кэри темпе значит темпе один
значит у нас будет теперь указывать никуда и на этом вайла закончится и обратите внимание за
этот шаг мы ванс бэк не добавили ничего то есть ацбэк пуст то есть анс пуст то есть такое может
это может быть и более но вот это может быть чем в этой штуке обратить внимание так и произойдет
вот когда 5 6 и 8 он так они помешатся тут будет одно дерево 6 потом одно дерево 7 то есть все
это превратится в единое дерево ранга 9 которая будет хранится в кэри а этот птр 1 он сад там
птр 1 да не тмп там птр 1 он дойдет до сюда я пусть и будет пустота поэтому да птр 1 ну птр 2 уже
давно пустила да передать нет пока мы вот вот до этого и фа ванс бэк никто ничего не положил
ну до вот этого и фа ванс бэк никто ничего не положил что ну после него положился что
ну я сформулирую так значит так смотрите когда мы по камере первый раз пишем сложный код первая
задача написать его так чтобы он работал честно скажу с точки зрения безопасности легче прописать
возможный случай что он с бэк пустой нежели думать о том что этого никогда не будет это раз
ну кстати так вот но такой тоже а кто бы сказал что meld будет вызываться только двух непустых куч
лучше такого зачем лучше как бы вы знаете если пользователь будет выдавать документацию там
на тысячу мелких гадких случаев там что вы должны делать сами то как бы и пользователь наплюет
пользователь вам будет плевать собственно лицо вместо того чтобы использовать вашу структуру
чем этим пользователям будете вы сами самое интересное потому что вам же этот интерфейс потом
использовать то есть представьте вы написали код потом там что-то пошли перекусили бутербродик там
возможно переключились на халявные задачи если в олимпиадную суть брать потом через два часа
к этому коду вернулись и потом вы там начинайте использовать meld потом вспоминаете что ой оказывается
meld работает еще вот в этом предположи то есть нужно чтобы там это было не пустая это была не
пустая так вон тот указатель указывал на число 57 179 или 2007 а фаза луны должна быть там называется
первая четверть с дюймом ну вот а патрик мохолмс должен там набрать четыре тачда у нас за первую
четверть там я не знаю причем да ладно вы мы теперь все это учтете у вас останется значит
три минуты вы по запусте оно не компилиться почему не компилиться потому что вы и но потому что
выяснилось что оказывается вам еще что-то надо учесть там я знаю что майкл джордан там все-таки
не умеет играть в бейсбол там я не знаю и поэтому вон третью строчку тоже надо поменять там на
майкла джера да который потом вспомнил да потому что после контеста вспомнишь он тоже не играет
в бейсбол но это уже другая песня да нет он хотя бы даже не пытался ну вот ну не ну нет
перебора то что они потом выяснилось что конкретно в последней игре действительно количество
очков набранных конзак сити на самом деле перевалила за тип то там собственно за тип байт
нет ну да да задача сколько тач даунов надо набрать что перевалить за тип байт так 256
поделить на ну ладно в идеале 8 так и быть это сколько получается так сейчас 128 64 а ну 32 так
да ну ладно по тач даунов мне в две минуты дам а ну еще там с доплана так так ладно тоже один но вот так
вот лучше писать код так чтобы вам вот не вспоминать это все не держать в голове одновременно если вам
надо это проверять лучше там вот мелких функциях там он собственно и вспоминайте в отдельной мелкой
функции не думая о том как результата будет вспоминать как фамилия мохом вообще пишется
но вот вот а то еще придется вспоминать какой у нее там номер там вообще да ладно так вот
да не говоря уже об этой мелочи да ладно так какой из этих функций можно стирать для того чтобы
я написал мол хедс а мы проверим в него дам а что-то вы писать не не не нет есть кое-что
нет нет нет внимание в мэл хедсе так внимание в мэл вот давайте-ка нет лучше править в мэл хедсе
никаких сфтов нет мэл но так вот тут на самом деле смотрите вот эти вот функции относительно
технической сейчас мы вот хочется написать именно сейчас мэл хедс потому что она чуть больше
начинает нас приводить к сути работы именно с деревьями а мы же по псевдонимам работаем не
только но не только но вообще видите мы вообще тут пока работали вот псевдоним эти видите вот
начали поминать только вот фиксу фикс менее да но нам на этот раз придется вспомнить не только
псевдонимах ну и правильно пересчитывать ранги и что самое главное еще вот этот лист не забыли
поэтому внимание в нем так тихо тихо так ладно что так ну что ладно вот это стирать можем или
нет нет мы ничего не возвращаем а находимся в этом вайле продолжаем то есть мы как бы для
вершины пересчитали есть предыдущие вершины значит продолжаем для нее то есть да я тут мог
написать ретурн там скажем ретурн фиксу фикс минс от бэк прямо вот ну то есть это конечно так
неправильно писать это уже еще там еще елена владимировна свои там собственно книжки детская
книжка писала почему так нельзя делать но не ну не скажите ну во первых нет эти по этой
логике надо почистую выкидывать всю программу общий фистеха потому что мы в общем-то говорим
практически о достаточно старых вещах ну ладно то есть ну это мы сейчас вот старая
вести потому что она в 2000 году еще уже опубликована она писалась она в девяносто восьмом а прикиньте
еще тогда тогда что-то будет смотанализом где вы проходите там программу дай бог чтоб 19 века
но вот чего вы семнадцатого
о хорошая да спасибо что напомнили да не не прямо сейчас конечно ладно те так тишина ладно все
правда раз тут есть вопросы ладно я тут это так года тут будет мало поэтому я попробую мэлт хипс
вот куда-нибудь сюда упихнуть мэлт хэдс внимание смотрите так мэлт хэдс я буду
да сейчас но для этого сейчас будет очень интересно но да да ой ну да а ну ладно мы уже
мы уже забили на этом чистку мусора да так что ладно ладно все временно на всякий случай
напоминаю сюда мы забыли на вы забили на утечку памяти значит говорим теперь так ну скажем так
в контесте не уверена в ревью обязательно воин ну правильно конечно так значит отрите
значит у нас будет вот хэд звездочка мэлт хэдс значит хэд звездочка ашадим я даже покороче
напишу хэд звездочка аш два вот ну вот да ну ладно давайте старые хэды лучше давайте
предполагать что старые хэды мы не удаляем этим вот да там ну да ладно при желании вот тут на
тему там дилитов всяких вот можно вот тут этим заняться ну это я так значит ладно для нас
сейчас самое интересное следующее значит во первых проверим что оба но от оба хэда существуют
энд энд аж два а еще мы проверим что у них одинаковые ранги это важно для нас так кто
там взлыл во с учетом того что если здесь что-то не выполнилось но просто выбрасывается можно было
лучше знаете лучше везде лучше везде перестраховываться даба но если в декабы так
нас убрасли бабы чем если скажем так нам не сложно вставить проверку давайте вставим вот значит
ранг ну раз где у нас и в хэда хранятся помните да так а вот теперь смотри теперь давайте перейдем
к нодам нодея звездочка рут один равно соответственно аж один быть быть как там
это называется рут и это что там да нет это понятно нет просто кто-то прям активно будет
да нет повда нет не знаю как раз на ворот как-то вроде понятно все пошло более-менее по крайней
мере пока так ну это переча так но я хочу значит что я хочу я хочу чтобы у меня аж один был слева
аж 2 был справа то есть он был next понятно да поэтому поэтому естественно кто у меня должен быть
меньше тот кто справа поэтому я пишу значит если совершенно случайно выяснилось что аж 2
и тск строго меньше чем аж 1 и тск то swap я сказал да не просто можно и нужно да согласен да
меня включит меня включит да извините извините значит иф ну да да да рут один мы же за этим его
ввели в общем-то дару два меньше рут один вот то соответственно swap swap от соответственно
рут 2 и рут 1 а вот они а на них а на них там по барабанам вообще о них думать не
будем нет для смотрите сейчас у нас дело вот сейчас я вот картинку давайте я картинку
дорисую дело в том что вот у нас будет как бы смотрите как бы сливает происходит мэр вот
одинакового ранга да я хочу создать новую вершину и сказать что вот это next и вот это child вот что
из этого будет но как мы хотим мы хотим чтобы как бы ключ у этого был равен вот такой же как тут
и чтобы вот тут он был как бы меньше чем тут но да поэтому но вот так поэтому я и пишу что вот
это вот должно быть как бы рут 2 в итоге это рут один я хочу вот так тогда наоборот условия
хорошо хорошо ладно давайте но если вы хотим тут промесь я мог бы тут больше написать на ладно
значит если выяснилось что рут один меньше меньше рут 2 то давайте да да да да вы правы но хотя
да меньше а вы уже да вы уже изучаете шаблоны нет на всякий случай так если вы пишете там
передаете шаблонные компараторы то обычно вы передаете компаратор меньше поэтому позвольте
лучше писать код так чтобы как бы вызывался только оператор меньше вот значит если рут 1
ck самое главное и тут ck то соответственно делаем swap вот но и теперь пишем значит внимание
начну и создаем теперь новую вершину то есть нодея звездочка ну так сказать давайте рут
глобально напишем и пишем что там в тексте теперь от нее будет сикей понятно какой
рут 2 ck так что там дальше да ну да рут 2 ранг плюс один совершенно верно так да нет да
child это у нас рут 1 этот рут 2 и его и хит сезона кис чему кис равен ну кис соответственно равен
очевидно рут 2 быть быть кис вот сейчас красненький возьму так да еще ну и что нам
теперь осталось с этого сделать из этого хед и вернуть его но да а может описать уже теперь
ретурн ю хед от то есть давайте так сейчас я вот так давайте так я вот напишу так пум пум пум
такое продолжение ретурн нею хед и в этом ню хеде я пишу но я пишу естественно рут
так ранг у меня его чего равен но да тут без вариантов рот ралк так но да да нет ну хотя
да по большому счету что мы напишем суфикс мин нам начать так что ну лучше да ну птр но
лучше да давайте ну птр ну птр и давайте себе а а у нас проблемы мы же заранее не
можем так сладко хрен с ним давайте ну давайте вот так напишем вот так да мы знаем мы знаем
точно чтобы пересчитывать поэтому все равно если мы не пересчитаем то независимо от того что мы
здесь напишем у нас будет беда вот ну типа да вот так что вот так как что мы и да мы реализовали
практически все кроме файнд мина ну честно скажу глобальный дилит мы наверное реализовывать не
будем ну да то есть там как-то очень аккуратно для каждого элемента еще уметь понимать в
каком листе он там ну все как-то быстро еще понимать но то считать что он там находить
по каждому элементу реально предыдущего и следующего и как бы реально выпиливать
ну вот и там еще какие-нибудь начала списка то есть в общем ну типа да нет нет нет нет
snm не надо писать потому что 7 точка будет не отлететься да нет ну глобально пишется так у
тебя есть структура лист да если мы не говорим что нам указатель пришел с неба если у нас указателя
нет мы знаем там что-то про просто про этот элемент нет но на самом деле нет правильная
релизанта будет такая вот мы используем стл ну так типа для простоты да если нам требуется
реальный указатель то нам надо нужно так нам нужно сделать сделать там то есть обернуть это положить
кисть в какую-то структуру у которой есть красные указатели уже для себя тоже next и преф и
реализовать свою структуру лист у которой как бы и которая у которой есть по сути этот
элемент дамме то есть типа который символизирует начало и конец так можно ну смотрите как
реализовывать непосредственно delete вот по то есть как реализовывать было бы если бы
хотели чтобы там каждому ключу у нас был доступ ну скажем так мы должны были этим озаботиться в
принципе ровно это и надо но просто единственное только надо чтобы как бы и когда когда вы
удалили элемент список об этом знал например если вы храните лист в виде спи указатель на
первый элемент то есть этот первый элемент возьми удались то как бы тогда начало списка должно
об этом как-то узнать да но для этого ж надо знать что это начальный элемент вообще и но тогда
поэтому я говорю лучше реализовать там структуру листу который есть элемент дамме такой типа
который типа псевдо начала вот но это классическая он же начал он же еще и конец заодно вот и
после этого то но вот и тогда когда вы создаёте ки значит вы реализуете это дамме у этого листа
есть там добавить удалить и у каждого кисток да значит вы там взяли этот элемент и потом
его возвращаете и потом его же удалять а у нас длит дали по указателю на что на элемент списка
ну на итератор да но удалять по идее по итератору который ну да но на вершину в которой находится
этот элемент нет на векшину на вершину 2 связного списка в котором он находится конечно нет
то ты проблема да ну там потому что это поддерживать сложно потому что у нас в
будущем я скажу эти листы будут рандомно смерчивать вот не надо и сыном делать я говорю
что если как бы у вас есть специальная структура то есть ки оберну специальную структуру который
вот красный есть красный на икс и преф он говорит что в моем красном листе в котором я лежу вот
на экст вот этот преф вот этот может может быть они являются дами если я начало или конец
списка если нет то нет но как бы удали ну да но после этого удалять вы теперь делаете
завод единицы и радуетесь да тут не парить вот поэтому там но это можно но мы так не
будем то есть единственное что нам остается реализовать это но там можно дать файнд мины
соответственно длит мин вот так что соответственно так не пришло ли она так сколько времени то
еще у нас но если файнд мин будет возвращать итератор туда но давайте лучше мы будем ладно
лучшим но ладно я так я просто не хочется сейчас тратить время на такую технику как бы просто
пока это не нужно но для этого вот нам придется до файнд мины длит меня обсуждать но для этого
первое что хочется обсудить они пришло ли нам время сделать перерыв но вот мне тоже так кажется
поэтому перерыв
потому что понимаете вы можете вернуть это итератор на этот элемент даже если это не будет меняться
проблема в том что вы по-моему не сможете вы не сможете удалить итератора потому что
потому что по этому итератору можно удалить только то есть там удаление этой методы
поэтому как бы поэтому там вам по итератору придется еще узнать в каком месте он находится а это вы
а
а
а
а
а
а
а
а
а
а
а
ну то есть
conclusion
Один раз в роли я собираю чуть-чуть одеть тебя, Тима, в готовку.
Второй раз.
Вот так я музыки передать.
Получился плеер, аттен, кабинет, кабинет, кабинет.
Перенести ты, Вася, не перенесёшь, даже не надейся.
Шок-картет жопами.
У него стрижка, Пейл.
Давай.
Вот выпишем нашу скетту.
Вот выпишем эту скетту.
Мне кажется, это не очень...
Потому что, в целом, мы и так понимаем, в целом, как работает.
Ну, мне кажется, только.
А потом, типа, ты приходишь домой, ты начинаешь писать вот так.
Ты понимаешь, что есть некоторые моменты, которые тебе не понятны.
Но за счёт этого ты ещё раз всё продумываешь.
И, типа, понимаешь, как она работает.
Это, конечно, сложный предмет.
Вообще, лучше, да?
Ну, в настоящем, там, проблема.
Нет, я понимаю, что так кажется, но тут просто...
Дело в том, что все понимают по-разному.
Вот у меня просто возникает ощущение, что, ну, там...
Допустим, вот, да, возможно, вот конкретно ты действительно там вот действительно всё понимаешь, и всё.
Да.
Достаточно много, что ли.
Но у меня, нет, ну, как...
Слушай, как показывают...
Как показывают практику в отчёты предыдущих поколений?
На самом деле есть просто, так сказать, менее глиборучая склона.
Которая, на самом деле, понимает сильно меньше.
Просто она стесняется.
Особенно, когда прийдёшь в участок, то и включишь, что дальше понятно.
Да.
Вот.
Поэтому, ну, вот.
Ну, и, что более того, он не всегда откидывает, но он, типа, его просто заставит.
Поэтому, собственно, для того, чтобы было понятное оставалось, собственно, я ещё не допущу.
Да.
Потому что, да.
Как бы тоже, тебе очень было соблазнить, вот, вот, не писать, но всё-таки всё отлично.
Спасибо.
Так, всё-таки лучше...
Как бы, лучше будет двигаться помедленнее, но, как бы, не сказать, что будет...
Жизнь будет реальна.
Не все, как бы, в семье разберутся самостоятельно.
Каждый работает в моменты, которые не отличны.
Поэтому лучше, как бы, то есть лучше, как бы, это всё...
Да.
По какой стране, условно, вы держите ход, типа, два раза, да, становится скучно,
мы немножко устраиваемся.
Ну, ничего.
И после этого ещё нужно как бы...
Ну, и чего?
Не пропустить момент, когда начинается.
Ну, есть такой, ну, да.
Я сразу предупрежал, да, что как бы...
Да, может, проявить некую экземплярную парочку, но через несколько минут, да,
супер-масса, супер-рега.
Вот через это по отношению культуру.
Ну, в принципе...
Так что...
Ну, поэтому я говорю, брать лучше...
Лучше, как бы, оказывается.
То есть все эти мелкие...
Все эти мелкие лучше прописать и по три раза.
Да.
Скажите, как бы, тура сегодня.
Значит, брать не надо.
Чего?
Просто в тупую, вот, выдёргивание из этого листа...
Ага.
А дальше у нас веселье возникнет с тем,
как мы будем делать именно файн-мин, видимо.
Или что-нибудь такое.
Или как мы будем делать экстракт-мин.
То есть у нас там будет возникать вопрос,
ладно, давайте забьём на точность и сделаем просто, чтобы...
Но тем, кто...
Ну, не важно.
Но вообще, на тех операциях, что мы написали,
у нас сейчас просто нормальная куча.
Ага.
Чуть-чуть, первая нормальная куча.
Ноля.
И я ж правильно понимаю, что мы вот где-то вот в этом моменте
просто умираем в этом стадии, особенно когда у нас вот такое количество обращения памяти.
Ну, показатель.
И мы в разных ячейках пытаемся это всё разъименовать.
Постоянно не попадаем в кэш.
Ну, типа да.
У нас вот по этой фильтре суммарно констант такой.
Ну, понятно.
Как на 5-й порядковой статистике за линию.
Ну, понятно.
То есть, на самом деле, это же не будет быстрее.
И даже вот сутически быстрее, чем катая порядковая статистика за линию.
Ну, да.
Если мы будем делать вот такое, что предлагала Сепсуала на третьей раунде,
то будет даже нет.
Даже если без рандома писать катую порядковую.
Ну, а кто так называется?
Ну, как бы это просто такое прикольное применение.
Просто, да.
Чтоб типа пошариться, что нам вообще пришло.
Потому что там, в общем-то, не было.
Ну, понятно.
Но просто кажется, что совсем бесполезное расширение проекта структуры.
Ну, с точки зрения теории, оно тем не менее ваше.
Когда-нибудь, когда компьютер стал очень-очень быстрым,
она будет в своем местном смысле.
Когда мы будем 1.15 в секунду обрабатывать,
и такая константа нам уже будет не страшна.
Это же когда-нибудь не будет.
Когда мы будем обрабатывать 1.15 в секунду,
это же когда-нибудь, никогда не наступит.
Скорее, значит, будем развиваться в сторону многопоточности,
и вот такое нам не сильно поможет.
Это как-то более вероятный сценарий.
Особенно с инденцией развития железа там за последние сколько?
За последние 30 лет.
Ну, потому что количество потоков у нас увеличилось раз в 40.
Так, а количество тактов в секунду меньше.
Сейчас интересная теория должна быть.
А как распараллелить известные задачи?
Параллелим ДФС?
О, боже.
Нет, параллелим ДФС, это сомнительно, конечно.
Потому что параллель ДФС,
то есть свойство старого ДФСа вылетит с трубу,
если вы там параллельно в несколько детей поедете.
Вот параллельный ДФС...
А нет, параллельный ДФС тоже опасен.
ДФС параллельный скучный, я такое описал.
Причем что-то на 150 потоков.
Нормально, да.
Там ничего суперинтересовало.
Понятно.
Нет, ну там важно, чтобы ты каждый уровень,
все равно уровень последовательно придется делать.
Ну, там можно и защититься.
Особенно если у нас не самый рандомный граф.
Нет, ну если не самый, то и другая письма.
Для не самых рандомных графов и не самая рандомная теория.
Ну да.
Так что соответствуй.
Мы просто в Улкаша нам что-то сделали,
один день убор этих задач,
но выделили сервер на 128 потоков, по-моему.
Дали задачи на то, чтобы мы просто параллелили код.
Понятно.
И типа вам дается 10 в десятый чисел входных данных.
Трель две секунды.
Ну нормально.
Просто это, чтение входных данных через запрос пункции.
Ну понятно.
Ну понятно конечно.
Ну забавно, забавно.
У нас турнир, там боками ножницы, бумага на...
Ну сколько там сделали?
Ну понятно.
На 2 в 35 человек?
Ну понятно, да, да, да.
Ну это весело.
Так.
Я тоже спал на первой паре.
Ты ничего не пропустил на первой паре.
Вообще ничего не пропустил.
Допустим.
Потому что когда мы вернулись, мы заморозили.
Нет.
Нет ничего, ну у нас просто динамиальная куча,
которая у нас есть.
Все.
В остальном это тупая динамиальная куча,
которая у нас есть.
Да, собственно.
Человек он не занят и примется.
Можешь себе позволить...
Это мерч обычный.
Ну окей, вот такая это динамиальная куча у нас есть.
Ее это не реальная куча у нас есть.
Потому что у нас список в каждом.
Он не начинал...
А, нет, сейчас.
Это не эта динамиальная.
Это не эта куча.
Мы будем спрятать, и мы даже еще не начнём.
Это у меня у нас есть динамиальная куча,
если мы пишем на скиссе.
То есть если у нас...
Вы не беспокойтесь.
Если у нас список деревьев,
тогда у нас все то же самое.
Если бы мы не могли кого-нибудь пригласить и спрятать.
Буквально вчера что делали.
Да.
Я там сидел сначала,
отлавливал латейские парни,
типа, 1,5 часа.
Потом еще рентайм-эрор,
дебазовка,
1,5 часа.
А перед этим учили все генераторы тестов.
Почему там не запасные?
Потому что я уже отлавил две.
Я уже заслал.
Не, я понимаю, что...
Ничего не все.
Ладно.
Это надо знал,
почему вот это идет.
Я думаю, я придумал.
Если хочешь,
я могу тебе снимать реально рабочий фото.
Ну, только с единственным моментом,
что...
Вот это у нас...
Вот это у нас...
Вектор указательной матери.
Ну, то есть пропадают просто вот это вот.
Тебя проект заливали на сайте.
Он дефигируется на сайте.
Заказчику он дадет столько...
Ну, показывает,
сколько исполняемых правил,
как работает и ничего.
Если у тебя заказ...
Доложение.
Тебе удастся.
Такая слегка иммунитета.
Ну, еще я что-то...
У меня сегодня на минуту не выпил меня.
О-о-о!
Ну, в честь доложения.
Вот вы говорили,
что вы про технику ток.
У меня есть одна задача.
Я...
Есть интересная задача.
Я не довел ее до конца.
Какая-нибудь, типа,
табличка до шеи,
на единственную току,
к которой я не подходил.
Дополнительным, что через минуту...
Вот.
А какие у него там условия,
чтобы это можно было сделать?
Уже нормально.
А если у тебя...
Нарисовывается...
Если ее конкретно довезли,
можно там,
в середине цифрам,
добавить табличку.
Прикольно.
Вот, если там есть типа условия,
там что-то...
Ну, вы видели там что-то?
Нет, табличку не видят.
А, ну тогда потому что...
Тогда если поедете,
можно написать мне,
я вам тогда ссылку дам.
Питон Ча...
А...
Пайтон Чортов.
Так...
Из седьмого класса.
Так нет,
в этом не является.
Это просто...
И...
Программация же никакой.
Да.
Не знаю, как это работать.
Еще когда-нибудь,
сниматься,
ну и все, да.
Ты оставили,
как стоил, концепты, раз...
Так нет,
это дело, что в продукте
у тебя человек знания,
то он связан
с этим,
с договором.
Который с участием...
Я это...
Суть о полкусных.
И, притом,
у тебя челек,
понимает,
ну все такие...
Здесь ты, по сути,
даже не представляешь.
А можно представлять?
Какой человек?
Ну...
Типа...
А если жива,
фликовый паспорт?
Легальность жива.
Ну...
И тянут.
А если жива,
асси...
И тянут.
Так.
Так.
Так.
Так.
Так.
Так.
Так.
Так.
Так.
Так.
Так.
Так.
Так.
Так.
Так.
flowerpot.world.
Сним mortarpot.world.
Ой, это, к сожалению, интересно.
Я думаю, запах одной тысячи.
Короче, она работает со спонженными третьей стороной.
Именно с самого филанса.
Сучиться-то отлично.
Загащик сначала отправил деньги.
И деньги приходят не на счет филанса, а на специальный счет самого филанса.
Да, он ему дается эту продукцию.
Да.
А в самом случае еще есть несогласия.
Это все оскорбляется с применением технической поддержки,
потом идти сделать следующий счет.
Который сама контурует.
У тебя должен быть хороший старт на самую филанс.
Да.
Нет, потому что деньги отправляются не в филанс, это понятно.
Потому что, когда работают даже на Aliexpress, те деньги отправляются не...
Я понимаю, да.
Но мне кажется, что здесь примерно то же самое, как и на Aliexpress.
Если чей-то реально нужно вверх сдавать...
Не знаю.
Ну, оказывается, даже деньги продаются.
Там опять же, да.
Убирается отставка.
Ну, за счет там.
Кажется, что на Aliexpress, на Aliexpress, так и на Aliexpress,
и на Aliexpress, и на Aliexpress,
на Aliexpress.
Да.
Потому что там можно быть такой честным для работы.
Да.
Это просто классичная работа.
А вот то, что она обратила в честность одного руком,
это не честно.
Если мне не честно.
Ну...
Ну, вы понимаете?
Честно говоря, это не того, да.
Потому что...
Тут все может быть что-то, а здесь...
Ну, как...
Например...
В случае, если...
Закажешь.
Он может просто сказать, что вы работаете на Aliexpress,
значит, деньги продаются и будут.
А в случае, когда...
Закажете.
А...
Если у нас будет задательная
биномиальная куча, у нас будет
сверхосписывание
с конкурсом основы.
Потому что я уже туда заслал биномиальную кучу.
Может...
Подумаем, может, и будет.
Просто хочется просто CTRL-C, CTRL-V,
потому что я ее уже написал и отладил.
И у нички парить и отладил.
Не, ну, если...
Ну, смотря как пасал, если списываешь твоего же аккаунта...
Ну, нет.
Значит, будет парень-человек,
что как бы он писал мне, посылал мне свой.
Очень не дарит.
Он может как бы заранее запросить,
что как бы...
Нет, там детлайн-контест, я думаю, уже вот прошел.
А, да?
Печально.
Ладно.
По крайней мере, у меня уже есть кондест
рестестирования.
Ладно, господа, я думаю, пора продолжить.
Пора.
Пора, пора, пора, пора.
Пора, брат,
пора. Туда, где
за тучей белеет жара, там пора
вот это, да?
Ну, в общем, короче,
в общем, там была гора,
на ней, в общем, это...
В общем, там летела птица,
и еще одна,
вот, и одна там птица
другой что-то сказала, вот,
и вторая там ей
как-то ответила,
а первая птица, ну,
это, в общем, упала,
и...
Вот.
Там, да.
Возрождитесь.
Можете?
Чего? Давайте.
А, ну, я думаю, надо...
Ну, вот.
Да.
Как это, да.
Так.
Так,
ну, ладно.
В общем, ладно, как устроен
мэлт, вы, короче, поняли?
Думаю, его уж точно
можно ликвидировать.
Вот.
И теперь
переходим к самому интересненькому.
Но, как я уже сказал,
дилит мы реализовывать не будем.
Ну, мы тебе кратенько обрисовали,
как мы конкретно дилит там, конкретно
по итератору можем делать.
Максимум, что мы сможем сделать,
это реализовать дилит-мин.
Ну, кстати, ну, более того,
насколько, может, вы меня, конечно, поправите,
но, по-моему, автор статьи, кстати, тоже
конкретно глобальный дилит
не заморачивался.
Типа, очевидно, что...
Не, ну, там просто слишком.
Ну, сейчас, как вы видите, там просто
слишком просто. Ну, там действительно для нас реально хватит,
что просто хотите выполнить дилит,
удалите элементы списка, и на этом все,
в общем-то.
А!
То есть там, поэтому я вам даже вот
как скажу, да?
Нет.
Не, ну, дилит-мином будет проще,
потому что...
Мы же можем просто файнер-мин реализовать,
а потом... Да.
О, давайте я даже сразу это сделаю, чтобы мы об этом
не думали. Значит, смотрите.
Я так себе это в уголочке
напишу.
Значит...
Давайте void
delete-min.
О, давайте.
De-lit
min.
Так, delete-min
хорошо.
Ну, просто delete-min.
А, ну и софт-хипа, конечно, да?
Софт-хип.
Ну, давайте
по амперсанту
sh сделаем, да?
Ну да.
Ну, фактически, да.
Мы вызываем
файнд-мин, даже наплевать на то,
что он нам что-то возвращает.
Файнд-мин от sh,
все, по барабану даже.
Теперь то, что он вернул, мы просто...
Нет, он ничего
не вернул. Если он нам что-то и вернул,
то копию какого-то элемента, не более
того.
Мы это сделали, чтобы
просеялось. Да нет, мы сделали
так. Дело в том,
что... Значит, что
делает файнд-мин? Файнд-мин
добивается того, что в корневом
списке дерева, указанном на суффикс
мини, реально что-то находится.
Вот он этого добивается.
Поэтому...
То есть, поэтому теперь, чтобы
сделать дилит, мы сделаем
так. То есть, пишем sh
.
Так, что там у нас?
Так, давайте следующий маркер.
Roots там, соответственно.
Какая диета?
sh.
roots.
Так.
Так.
Значит...
Так, ой, так.
Ладно, лучше все маркеры возьму уже, а то...
Да.
Значит, roots.
Значит,
.
суффикс мин.
Но да, ладно, файнд-мин, видимо, будем
считать, что файнд-мин взвоит, если бы
попытались найти минимум в пустой куче.
А он может
после некоторых просеиваний
неожиданно выяснить, что это так.
Но знаете, с рандомными дилитами
вообще может выяснить, что куча там огромное
количество чего хранится, а по факту пустая.
То есть, она так схлопнется, схлопнется, схлопнется
и говорит, ой, а у меня куча пустая. И что делать?
Все, выть.
Значит...
Выть или не выть? Да, суффикс
мин. Так, дальше
после суффикс мина мы отправляемся в рут.
Потом, видимо, в кейс.
Нет. А, да.
Кейс.
Да, кейс.
Пум-пум.
Какой-нибудь экстракт
оттуда, видимо.
О, господи.
Кейс.
Ну или поп-фронт.
Поп.
Но давайте поп-фронт, для прикола.
Только кейс с стрелочкой,
конечно.
Вот такое заклинание
получилось. Да, это не 0. Это
скобочки.
Вот, дилидмин, видите, просто
Красота.
Две строчки кода, наверное.
но это нормально но это вот единица господи
а теперь а теперь начинаем господи что-то все мелоча господи
вот мы говорим о высокой математике а тут вот так и господи
как это то же самое говорит да это называется это называется да называется дам да и тут мы забьем красивый гол через себя в падении
ой ну у меня спина испачкается ну вот ну как-то так это звучит ну честно
ну
а я просто вчера сидел запихивал в пустыне
не надо потому что у всех у всех эта ветка указывает буквально на один и тот же лист буквально
нет она просто указывает на лист видите вот звездочка то есть есть структура данных лист которая хранит себе там
ну ладно в том исполнении который у нас есть этот лист мог с тем же успехом быть конечно и каким-то вектором
а вот теперь начинаем расписывать файндмин и это собственно сейчас будет основное шоу
то есть знаете как-то в одной телепередаче говорят предыдущие испытания лишь сплотили команду теперь ее ждет по-настоящему сложные опасные испытания
вот
да именно сейчас мы там пойдем в комнату со змеями будем пытаться их это сдувать вот это все
через shift
значит
мы наверное хотим ссылку на изаж потому что мы все таки будем менять или а не ладно там же по указанию нормально
значит смотреть
я слепой сегодня
так значится смотреть значит
значит давайте попробуем так
ну на самом деле да можно
ну я не знаю но вот сейчас нет ну нет нет на самом деле посылки надо потому что смотрите в процессе файндмина ссылка на рут сможет поменяться потому что может быть
в самой первой хед может быть будет ликвидирован
да такое может быть
так ну давайте так чтобы не писать огромные вайл трубов
знаете как сделаем
так
ну значит смотрите
ну так
как же мы это сделаем
да лучше лучше конечно написать функцию крейша трэда трэда
да
так
так
да лучше лучше конечно написать функцию крейша трэда трэда
господи какая какая какая как мерзко действительно этот вайл писать
мы уже написали один мерзкий вайл
ну вот нет ну просто по хорошему тут надо написать
почему здесь простой вайл
ну так сказать вайл да но там сейчас огроменный то есть там сейчас по хорошему что мы сейчас должны сделать
попытаться найти вот это выкопать вот этот вот минимум
если он не существует начать
называется как
и начать делать какое-то мерзкое шоу
ну вот ну хотя ладно давайте ладно
а тут придется субмины еще пересчитывать да?
ну да ладно ладно сейчас я понял начнете как мы это будем делать
значит пишем так вайл труп пока
значит вайл труп пишем ну во первых
если выяснилось что допустим куча вообще пусто
ну может быть такое куча вообще пусто да?
то есть пишем
то есть я не знаю но там пока ассерт
что ассерт да sh.roots да
ну потому что если там совсем ничего нет ну значит
запрос становится некорректен
в противном случае
значит находим этот вот суффикс мин
значит поехали как мы это делаем значит пишем ноде звездочка
звездочка
а нет не ноде звездочка не путать
хед звездочка
а
пока решили убрать
нет почему delete mean вот он все
да мы его свели к find mean
то есть напиная find mean будет он в процессе добьется того что вот по этому координате что-то находится
и после этого мы это удаляем
значит пишем что-что за хед
ну хед этот найти очень просто
суффикс мин
тут все просто
понятно да?
значит ну можно сразу написать
что если совершенно случайно
значит
значит смотрите дальше будет работать так
так ладно сделаем так сначала
давайте создадим
значит ноде звездочка допустим этот вот root давайте корень
равен хед умпум тоже root
вот
хед
хед
да совершенно верно если
не
значит если не вот так вот в скобочках root keys
точка empty да совершенно верно
то есть если там в этих ключи существует
хед
да
а как
keys стрелочка
ну стрелочка а ну и ладно хотите безопасность я вот так вот могу написать
после keys стрелочка
а да
с keys указать
да да да да да все вы правы спасибо спасибо
так
ну вот
ну да ну знаете
по запросам телезрителей
телезрителей ух ты
я хотел это классно было если бы было в прямом эфире и там нам еще кто-то писал да
не ну я на карантине в принципе такое ввел да было весело
так
ретурна значит ну понятно пишем комбинацию
root
keys
begin
front
а ну в принципе
а ну в принципе да
а нет нет нет нет нет
а вот тут дальше начинается шоу
смотрите внимательно
потому что дальше мы дальше напоминаю что мы вычисляем а сколько у нас
у этого рута детей
сначала мы вычислим
значит количество детей
так ну ладно так дети
так ну ладно дети у нас фиолетовая будем их считать фиолетовым
не не ну при желании можем но в этом нет необходимости
так
а
потому что функция find min по исходному определению она
возвращает минимум
да ну что мы все плюс плюси мы все мы всех имеем право вызвать функцию даже не
сохранить ее значение
мы это делаем чтобы у нас гарантированно был уже найден
да
да да да
ну да то есть это как бы
нет а то есть куча будет корректная гарантируется только одно что
то есть она просто доделает еще так чтобы добавок к этому
у того кто куда указывать суффикс мин там элементы реально есть
в этом в заражнике
итак поехали ну здесь я Элза даже писать не буду вот просто ИВ закончился и все
ну как бы если он сработал значит мы выбросились
значит работаем что там пусто и мы этот лист хотим сейчас
как-нибудь уничтожить
и
происходит это теперь так
внимание
ну во первых int
children number
равно
нулю
cnt ну такое
значит ну здесь все просто
for
node
звездочка
ну какой-нибудь там
давайте
если уж так хотите равно root
ptr
ptr равно
ptr
next
что мы там делаем тогда
ну естественно все что мы делаем плюс плюс children
number
вот
верно ли мы нашли количество детей
ну нам живые нужны или как
живые
нет да ответ нет неверно на самом деле тут надо с минус один стартовать
но помните там у на этом пути у всех вершин кроме последней кроме последней есть ребенок корректный
значит и мы теперь
говорим
что мы
говорим
да так чисто
для психологической уверенности чтоб все хорошо на самом деле нет необходимости
нет а это важно теперь надо проверить
ради этого мы тут все и пишем то есть если в этом минимуме да есть какие-то ключи
то значит вот минимум мы нашли
и вторые
то есть внутри не фиолетовый стереиджи
который от знака
я не знаю я бы шунарда он может стать там
конечно
но я не знаю все унарных операторов приоритет самый высокий поэтому как бы он может не рута потом скажешь о я от була не умею не
Это...
Ну я не знаю, вообще у нарных операторов приоритет самый высокий, поэтому как бы он может не орут, а потом сказать, что ой, я от була не умею, не?
Не, у стрелочки приоритет примерно как у фортовых скобок.
Ну...
Ладно.
Так, ладно.
Какая разница?
Так, ребят, давайте сейчас это, называйте, не об тех мелочах думать.
Вот.
Потому что, ну потому что, смотрите, когда вы там вот идете по пути, вот знаете, что вы натратились на последнюю вершину, у которой ребенка на самом деле нет.
Поэтому ее считать не надо.
Вот.
Ну если по-другому считать, то у нас просто первая вершина не является своим ребенком.
То есть можно с двух сторон.
Ну вот, ну мы тут вот посчитали детей.
И теперь, соответственно, говорим.
Значит, если совершенно случайно, абсолютно случайно, выяснилось, знаете...
То есть вы, значит, если выяснилось, что это количество детей, давайте все-таки сейчас вот по некоторым причинам я сейчас напишу.
Children number оказался меньше либо равен...
Меньше...
Не, ну без разницы.
Потому что я, дальше все, что я хочу написать, это...
Как бы, root, um-pum, rank, delete на 2, это все, что я хочу написать.
Это то же самое, что 2 умножить на shield number меньше либо равно.
Как мы делаем ptr next, если next, если ptr это нот-звездочка?
И что? А ptr next это что, не указатель, что ли?
У нас, у ноты нет next.
Здрасте.
А у нас же тут ломается.
Кто ломается?
У нас же тут равенство ломается, если мы справа делим.
Ну, в смысле, у нас слева 2, справа 5, мы говорим, что равно.
Да, и это нас устраивает.
Ну, детей меньше либо равно половины.
Ну, 2 это меньше половины.
Ну, 2 меньше половины, 2 с половиной там.
Ой, ой, да, да, да.
Нет, знаете, тут я еще важный случай, почему я хочу именно...
Потому что там, может быть, там, по-моему, у Кизеля, может, и меньше стоит,
но знаете меня просто какой случай смутил?
Смотрите, что делать, если rank вершины равен нулю?
Вот, кстати, задачка.
Что делать, если rank у этого рута равен нулю?
Наверное, от него shift бесполезно вызывать, правда?
То есть, поэтому у вас два варианта.
Мы должны либо, значит, удалить эту вершину к чертям,
а выживших детей объявить отдельной кучей.
Либо, что еще мы можем сделать?
Ну, вот, либо вызывать shift в надежде, что мы еще там что-то выкопаем.
Но shift можно выкапывать только в одном случае,
если там, в этой вершине, еще хоть что-то существует.
Поэтому, если 0 детей, то, значит, мы должны всегда,
собственно, значит, эту штуку аккуратно уничтожать.
Значит, поэтому в этом месте я напишу...
Я тоже вызову сейчас новую функцию.
Значит, я напишу так.
Такая у меня будет...
Ладно, будет у меня такая коричневая функция.
Спокойно.
А можно объяснить, в чем логика этого ИХ, что мы вообще здесь хотим?
Ну, в принципе, мы говорили так, что мы как бы пытаемся до последнего,
до некоторого момента, если в корне еще нет,
пытаемся из детей что-то выжать, чтобы себе перенести.
А вот в этот момент уже не пытаемся?
Да, вот если наступило, если детей стало сильно мало,
то, да, уже не пытаемся.
Сильно мало это корень от того, что должно быть.
Нет, детей, а не потомков.
Скажем так, внук это потомок, но не ребенок.
Я понимаю, я просто пытаюсь понять, а как это...
Нет, корень это неправда, потому что там количество элементов...
Да, там половина, кажется.
Даже не половина, ну, смотри.
Ну, потому что нет, ну, как бы если у тебя была куча размера 8,
ну там 8 детей, да, то как бы если у тебя уничтожатся дети
рангов 0, 1, 2, 3, то их как бы и суммар на этих потомков
будет меньше, чем в одном дереве ранга 4, не говоря уже об остальных.
Да, понятно.
Поэтому...
Это не очень понятно, откуда эта оценка берется, чем это.
А, значит, амортизации мы хотим.
А почему вот эти надо делить на 2?
Сейчас давайте, вот я допишу, вот я допишу и будем разбираться.
Значит, здесь я напишу техническую функцию.
DeleteHead, она у меня будет называться.
Передавать ей тоже, разумеется, по ссылочке буду
этот вот S-ашек.
И что-то еще я буду делать.
Что я еще буду делать?
Чего?
И, ну да, и, конечно же, собственно, хеды буду передавать.
Все, я говорю, что все.
Я хочу уничтожить.
Я бы доставать хорошие наточные топоры
и нежно вешать кучу головы.
Да.
Значит, а в противном случае...
Вот сейчас.
А в противном случае вызывается супер...
А в противном случае будет вызываться шедевр,
который я, пожалуй, тоже буду красным писать.
Чтобы было...
children number было быть строго меньше,
чем rank пополам.
Что-что там?
У нас же children...
children number строго меньше,
чем rank пополам, и...
Сейчас, чего еще раз?
При ограничении строго меньше,
чем rank пополам, а то да,
мы вызываем создание новой кучи.
Да.
Она сейчас тут меньше или равно?
Чего?
А здесь у нас меньше или равно?
Ну, типа того.
Хотя, на самом деле, правильно будет еще
я даже так...
Множить на два там и писать меньше.
Ну да.
Нет, нет, тут меньше...
Нет, почему?
Меньше или равно нас тоже устраивает.
А еще нас устраивает.
Знаете, если еще...
Может быть так, что у вас...
На самом деле, я вот знаете,
пожалуй, правильнее даже чуть по-другому написать.
Вот с этим вот мы вернемся.
На самом деле, как бы, нас что не устраивает?
Нас не устраивает,
когда вообще одна несчастная вершинка осталась
вообще, правда?
Тогда из нее сифт выковыривать бесполезно.
Поэтому мы будем делать так.
В общем, если совершенно
случайно выяснилось,
что, соответственно,
root, даже вот я еще так
напишу, root next,
короче, не root next,
а root next.
Потому что я решил сюда
вставить еще одну строчку.
Я его верну.
Просто я не хочу...
Потому что код не работал, вот почему.
Предположим, что в дереве осталась
вершина ранка 6,
но я не знаю.
Но детей ни ребенка,
ни next у нее нет.
Ну, я не знаю.
И сама она пустая?
И сама она пустая,
как раз она дожила.
А?
А мы next называем...
У нас next используется
в хедди как следующий в списке,
а в ноде он используется как
брат?
Ну, типа да.
Подождите, а разве не поддерживали,
что у нас больше поводить детей еще?
Ну...
Это просто файлы.
Ну, скажем так.
Ну, скажем так.
Почему-то, ну вот...
Ну, скажем так, от того, что мы удалим
на два ребенка больше и повыживаем,
на самом деле криминала не будет.
Хотя...
Да нет, ну хуже точно не будет.
Ну, давайте так.
А потом в анализе поймем, насколько нам это
прям принципиально, чтобы количество детей
было прям большое.
Вот так сделаем.
Ну, там просто теоретически
может быть случай, знаете, когда у вас там
огроменное дерево с огромным количеством
листов и все они пустые.
Ну, так.
Так вот.
Если у рута этого next
нет, то мы, конечно,
вызываем...
Так.
Делит head.
Говорим мы.
А ты Саша и head.
Вот.
Ну, а мы перенот.
Вот.
А, ну хотя...
Что это такое?
А, да, ну ладно.
Давайте я тупанул, хорошо.
Давайте.
Возвращаем.
Если...
Так.
Если child...
Number действительно меньше
либо... Да, пожалуй, не нужно, да.
Согласен.
Ну ладно, лучше, да.
Значит, меньше либо равен чего?
Значит...
Да.
Ранг delete на два.
То мы тоже у него вызываем
delete head, да. Да, согласен, да.
Delete head.
И, соответственно,
пум-пум.
Тогда мы, видимо, должны писать else.
Ну, в смысле else здесь.
А.
Ну, да.
А то мы сейчас это...
Да, да, да, да.
Будем что-то интересное отрезать.
В противном случае, да.
Внимание.
Нет, а вот тут...
Тут надо очень аккуратно.
Чего?
Если не root next
или...
Ну, могли.
Опять переписывать?
Нет, как вы сейчас
могли вообще это не писать.
На самом деле все правильно было.
Давайте перепишем.
Не, не буду я ничего переписывать.
Все.
Так.
Не буду я ничего переписывать.
Это я буду вот так делать, да.
Если бы я вот это...
Вот это.
Взять оранжевый маркер и написать
ваша реклама.
Ага.
Да, да, да, да, да.
Продам гараж.
Так.
Так, тихо, тихо, тихо.
Так, топилича. Теперь самое
интересное. Значит, мы пробуем
вызываем внимание
shift от этого root.
Да, внимание, да, shift.
Когда вы вызываете shift от вершины,
она как бы корень не поменяет.
То есть как вершину.
То есть не может быть так, что в результате
сифта корень прям удалился.
Ну, там swap будет, да.
Угу. Значит, поехали.
Значит, ну, swap и да,
но вершину не поменяет. То есть у нее там могут поменяться
эти вот ребенок с братом,
но как всегда.
Значит, вызываем мистическую
функцию shift.
От рота.
Да.
Может.
Поэтому,
поэтому очень важно в этом месте
написать
его величество
fix suffix min.
Да, вот я чуть справей
напишу fix
suffix
min
соответственно
от хэда.
Ну,
хотя
да, можно здесь
да, знаете, формально
я, конечно, должен написать, конечно,
вот root, но на самом деле я не должен этого делать.
Да, то есть он как
что-то возвращает, я, по идее,
его должен написать в sh.root,
но на самом деле
необходимости в этом нет.
Просто потому, что как бы
сами по себе хэды у нас
не поменяются.
Да, то есть я так.
Да, это можно удалить.
Допустим, мы хотим
взять suffix min
и мы вот смотрим на следующий за нашим
хедом. Да.
И он указывает на какой-нибудь
хед,
в котором вершинка,
самый верхний список, он пустой.
Сейчас
кто куда указывает?
До этого мы
запустились и попали
через
пойти в suffix min мы попали в вершинку,
в которой был пустой список. Отлично.
Вот, отлично.
У нас есть такие условия,
что мы зашли в seed
и потом мы снова запустили
fix suffix min.
Правильно, но fix suffix min
он как бы по
невым сике ориентируется, ведь не случайно
у нас тут wild true написано,
потому что просто в следующей итерации мы
еще раз попробуем пойти
по этому suffix min, а если выяснишь, что там все еще
пустой список, значит
делаем еще раз, и
еще раз, и еще раз.
Мы больше же не запускали
find min.
В смысле?
У нас find min
начинается wild true. Смотри,
вот find min начинается wild true,
видишь, не случайно.
Допустим, мы попали вот,
можете, пожалуйста, рисовать
suffix min, в который мы попали, с пустым списком.
Так.
Так, значит
мы указываем на вот такой
head,
он указывает нам на
вершину,
у нее там вот этот длинный список
next, и они все указывают
на вот это.
Давайте
саптимизируем suffix min.
На пустоту они указывают.
Когда suffix min вызываем, то
сначала мы же смотрим на
следующий head после вот этого,
который вы нарисовали.
Чего? Что такое следующий head?
Нет, он и ровно на этот head и смотрит.
Давайте кое-что...
Сначала пересчитать suffix min, начиная с этого head,
начиная с этого head и влево, да.
Да, мы должны посмотреть еще на...
А справа ничего не поменялось.
Да, ну можете, пожалуйста, рисовать просто.
Ну, давайте.
Вот мы
пришли в head,
и вот этот head указывает...
Вот, нет, самый первый head после
нашего...
Вот этот. Да, вот этот. Он указывает
на какой-нибудь head, в котором тоже пустой список.
И что?
Да, это для нас не проблема.
Почему?
Ну, потому что, смотри, мы сейчас этим
сифтом, например, мы удалим вот этот
список. Нам будет важно, цель сифта
удалить этот список.
И всю вот эту цепочку, соответственно.
Ну, условно, удалить, чтобы списков у нас не было.
И там пересчитать.
После этого может быть пересчитан
suffix min и выяснится,
что он указывает куда-нибудь сюда, и список
тоже пустой. Значит, мы второй раз
проделаем вот эту операцию, удалять будем
уже этот список.
А find min у нас вызывается
из fix suffix min?
Find min...
У нас всё это фиксится только
сифтом и delete head.
А delete head у нас вызывается только
find min.
Если мы снова впадаем в пустой
список, то
мы его не фиксим же
на данном этапе.
Из того, что мы сейчас написали,
у нас вот это не фиксится.
А кто сказал, что одна это
фиксируем? Delete head не обязан
ничего фиксить. Delete head'у сказали
так, возьми вот это дерево,
его не существует. То есть удали
корень там, если у него были дети, сделай из них новую
кучу и вызови melt.
Всё, в общем-то
больше она
ничего не хочет.
Да, либо не обнаружим,
что там всё пусто и до свидания.
Мы же ещё не заказывали
что-нибудь работать, да?
Пока ещё нет.
Мы уже начинали доказывать,
для начала полного
анализа остаётся только реализовать
сифт.
Тут надо бы ещё один фикс
сделать, чтобы
если мы текущий
head не изменили,
то чтобы мы и дальше не шли.
Просто это будет по оптимизации
неплохая.
Ну, нет,
это сделается не фиксу фиксминсов,
вот здесь, тогда это надо делать.
В смысле, нет, мы же вон там идём
байлом, просто справа-налево.
А пока не перестанем менять.
Знаете, что значит
он не изменил?
Если мы не изменили вот в этой вершине,
то мы и во всех, что левее тоже не изменим.
Я не знаю, лично у меня
возникает ощущение
просто небезопасности.
Скажем так,
лучше сначала писать код,
убедиться, что он работает, а потом заниматься оптимизацией,
если очень хочется. Подобного рода
вещей уж точно.
Видите, код и так сложный.
Но как минимум объёмный,
поэтому
сразу
мелочи проверять лучше не надо.
Какой ещё вопрос?
Так вот.
Сколько у нас там времени?
Ой, у нас ещё и время есть.
Ну да.
Да, значит он его удалит.
То есть, как бы суммарное количество
плохих итераций вайлов,
которые вот не вот тут выбросятся,
суммарное количество будет не более чем n.
Потому что у нас вообще
вот эти списки
у нас не более чем н.
Потому что у нас не более
чем н.
То есть, напоминаю, обратите внимание,
у нас было единственное место,
где эти списки создаются.
Это вот в
крейте от
элемента.
Это было единственное место,
где они создавались. И каждая эта итерация
будет их удалять, поэтому всё нормально.
А фишка этой кучи
в том, что она выдает
один из epsilon n минимальных?
Из чего?
Один из epsilon n минимальных.
Ну, а кто сказал, что их там...
Нет.
Так нельзя формулировать.
Кто сказал, что...
Что вообще
делает это кучу?
Так.
Да, давайте вспомним,
что мы вообще делаем, ради чего
это всё вообще.
Ну, кроме того, чтобы написать ещё одну вот такую
бенмельную кучу.
Напоминаю, смысл
следующий. Мы хотим реализовать кучу
псевдо,
которая выполняет вот этот весь интерфейс,
заявленный хоть и учётно,
но асимпточкой.
Но говорит она следующее,
что, так как эта асимпточка может быть
меньше, чем log n и
идеальная,
которая ещё и всегда в правильный минимум
возвращает такое невозможно,
поэтому она говорит следующее,
что каждому элементу
присваивается псевдоним,
который не меньше,
чем наш элемент.
Значит, элементы сравниваются
по псевдонимам, минимум возвращается
тоже по псевдонимам,
и при этом гарантируется, что если
было всего n инсертов
в эту кучу,
в общем, было n листов,
то есть когда-то n инсертов в эту кучу
или её составляющая была,
то мы гарантируем, что не более,
чем у epsilon n элементов
ключ не совпадает
с псевдонимом.
С псевдонимом, да?
Ну, то есть если отостровать элементы
лежащие в куче,
то...
Что значит отсортировать?
Ну, просто взять и представить, что мы
их выпустили в массивы отсортировать.
Ну, допустим, и что?
То если мы просим кучу вернуть
минимальный элемент, то она
вернёт из первых
epsilon n элементов...
Ну, первых epsilon n плюс один.
Первых epsilon n плюс один,
и на это чего инсертов?
Именно. Именно инсертов.
Ну, инсертов,
или если куча создавалась с помощью
meld'ов, то там из всех инсертов
с этими meld'ами.
Ну, короче так, для каждой кучи можно хранить
сколько элементов в них когда-то
было.
То есть там условно, что если
в кучу взял инсерт, количество элементов увеличивается
на один, если куча создаётся
с помощью meld'а, то значит у неё
в ней когда-то было элементов,
равное там, когда-то было
в первый плюс когда-то было во второй.
Вот так.
То есть как бы...
Нет, то не могло быть, а именно было.
То есть как бы в каждой куче есть память
обо всех элементах, которые её когда-то
касались.
Ну да.
То есть условно говоря, это память
не о предках, но как бы...
То есть скажем так, куча
это города, у каждого уважающего города
есть кладбище. Если объединяются
два города, то объединяется и кладбище.
Ну хотя бы на уровне памяти о том, что
там вот, как говорится, здесь
у нас хранятся покои, там
вершины номер там вот этой, вот этой, вот этой.
Ну да.
В список, в который
кейс, мы ещё ничего не добавляли
у него, да?
В смысле не добавляли? Мы...
В каком месте в нём становится больше,
чем один элемент? Вот тот и прикол,
что пока ни в каком. Потому что мы
так и не дошли до самого интересного места,
где это вообще будет происходить.
Значит, поехали.
Так. Ладно, так, ну что,
вот это шоу наконец ликвидируем.
Значит, поехали.
Ща будет
весело, да.
Какой ретюр?
А, окей, ладно,
всё.
Во.
Нет.
Нет.
Ну, может быть.
Значит, смотрите,
что в итоге получится.
Значит, поехали.
Итак, сифт он вообще даже будет
void.
Ну вот.
Нет, а после этого
поняли, что вопросов возникает слишком много,
и ровно поэтому мы стали это писать полностью.
Ну вот, да, у меня даже в перерыве были вопросы,
а если и так, в принципе, всё понятно,
зачем мы это делаем. Ну вот, у меня возникло
ощущение, что в принципе понятно не всё,
поэтому... Поэтому, знаете,
тут как бы максимально убедительно
тогда уже действительно полностью во всех мелочах
так прописать, а потом уже что-то доказывать.
Потому что чем говорить, что ну там подгоним,
тут подкрутим, тут вот это, знаете, это всё
как бы... То есть проблема, особенно
в дизамортизации в том, что каждая подкрутка
дизамортизации тоже, она
может ухудшить асимптотику.
Поэтому как бы мы должны
как бы уметь смотреть на это дело
как-то вот сильно.
В общем. Так вот.
Так, сифт получает на вход.
Sean получает на вход.
Node.
Node.
Звёздочка.
Там допустим root.
И
говорим.
Значит.
Значит. Смотрите.
Подразумевается следующее.
Я даже... Следующая строчка
на самом деле не важна.
Поэтому
на самом деле я сейчас буду
прописывать следующее. То есть
я здесь... Ну здесь я сейчас
что я сделаю. На всякий случай пропишу, что
что я
пропишу.
Что я пропишу-то реально.
А! Я знаю, что
я пропишу.
В общем. Root. Стрелочка.
Вот этот вот лист. Как его зовут?
Как его зовут?
Case.
Case его зовут.
Так вот.
Я пропишу, что он сразу равен 0
ptr.
То есть строчка имеет скорее символическое
значение, но
потому что сифт будет
подозвать, что эта вершина
и все ее братья
должны забыть
об этом листе. Да. Я не буду
заботиться о том, чтобы его удалять.
Там же даже... У нее же не может быть листа вообще.
Чего?
Ну то есть лист пустой, но мы просто его
переводим.
Нет. Тут важно. Смотрите.
Дело в том, что пустой лист и листа не существует.
Это разные вещи.
То есть как бы я буду считать...
То есть с точки зрения сборки мусора
лист перестает существовать,
когда на нее... Когда
исчезает последний указатель, указывающий на него.
Вот.
Но тут я буду мне удобно будет
именно забывать о нем.
Но чуть позже увидите почему.
Значит, внимание.
Внимание.
Значит, что теперь будет делать сифт?
Ну, во-первых,
теперь идея будет...
Значит... Ну, во-первых, значит...
Да, соответственно.
Нулптр так нулптр.
И, значит, первое, что мы пишем, как вы помните,
если выяснилось, что брата
у меня нет...
Да.
У меня сестренки нет.
У меня братишки нет.
Вот.
Допивать не буду, да.
Папе скоро, да.
Папе скоро в восемь...
Вот.
Так.
Значит...
Так.
Значит, теперь я торжественно
объявляю. Пришло время
объявить, что root
ck равно бескречности.
Мы уже это делали.
Чего?
Чего такое?
Ой.
Много придется вырезать просто.
В смысле?
Вы там что, мутюгаетесь
что ли?
Хочу вырезать.
Так.
Так.
Так.
Нет, тут надо не вырезать, а если
я как бы просто чисто пишу код, это проматывать
надо, знаете.
Там, знаете, у творческого тоже есть лекция, на самом деле,
Паша Маврина там... Нет, а нет,
там есть эффекты, что в этом месте
пишется что-то большое, там, какой-нибудь там
веселую балалаечку, там вот это все.
Ну, у нее только на заставке.
А, ну, нет, у Бориса
Трушина, кстати, когда он там начинает писать
такие там большие выкладки, у него там
и что-то проматывается. Ну, можно в балалаечке,
в балалаечке.
В общем, сами подставите, это уже
не важно.
Вот.
Так, ну, с Алтовым можно просто всю лекцию
смотреть.
15 минут уложится.
Ну, не скажите.
Нет, ну, одно другому не мешает.
Нет, если в песнях, которые он сыграл,
есть смысл собственного происходящего,
то почему нет? Ладно.
Так вот, хорошо.
И так, если Нэкс существует, то
что мы делаем?
То мы также запускаем, конечно же,
сифт от него.
Вот.
Нахид запускаем сифт.
Красота, правда?
Так, что надо теперь сделать?
Так, ребенка, конечно, неплохо
было бы с Рутом, неплохо
было бы с Нэксом посвапать, правда?
Но, конечно, не всегда.
Когда мы свапаем, напомните-ка мне?
Да, если Рут
Child
Child, я сказал.
Child, ребенок
оказался строго меньше, чем мы.
Мы?
Что там дальше?
Да.
Так, что там?
Во.
Потому что
там у Нэкс-то, на самом деле,
этот сикей мог принципиально поменяться.
Тем более, что этого сикея, в общем-то, уже не существует.
Мы сейчас Увершину, по сути,
уничтожаем. Ну, не уничтожаем,
а там на ее место что-то достаем.
Вот так.
То, соответственно, делаем свапчик.
Свапчик.
Свапчик.
Значит.
Рут, Child.
Рут.
Пум-пум.
Соответственно,
Next.
Вот.
Начнем с пистики.
Чего?
Значит.
Теперь.
Значит.
То теперь, соответственно,
надо...
Ну, скажем так.
Если мы пока ни с чем больше...
Ну, во-первых, да, надо сикей, конечно, перенести.
То есть, да, обязательно
пишем, что Рут.
Пум-пум. Сикей равно
Рут теперь Next.
Пум-пум. Соответственно.
Чего?
Да, за iPhone давайте я это
поменьше.
Так, это мы сделали.
Да, ну вот.
Ну, лист, конечно, тоже у нас следовали.
Вот.
Да, пока вы еще не знаете,
что такое наследование,
поэтому вас это не путает.
Или уже знаете?
Нет.
Ну, нет.
До ВУЗа это не считается, да.
Так.
Ну, как сказать, да, в нашем предположении
вы пока не знаете, что такое дикартовые деревья.
Да.
Нет, я знаю, что...
По Олимпиадам мы сюда как?
По Олимпиадам, по математике.
Как говорится, и да, выход...
Нет, в предположении мотонаеза
мы не знаем, что такое синус.
По крайней мере, не знали еще недели назад.
Поэтому...
В предположении
мотонаеза мы не знаем, что такое...
Тихо, тихо, тихо.
Да, это шедевр вообще, да.
Так вот.
Вот.
Значит, что мы теперь делаем?
Ну, на самом деле...
А, ну единственное, надо еще...
Ладно.
Надо еще убедиться на тему
плюс бесконечностей.
Ну, во-первых,
то есть, хорошо, листы
лист сохранили.
Как говорится, чтобы он был, да.
Вот.
И дальше по идее,
ну, исключительно по идее, должно
происходить следующее.
Значит, дальше говорим, что...
Ну, во-первых, да, если выяснилось,
что в руте после этого оказалось
ужас плюс бесконечность,
да?
Давайте вот проверим.
Значит, root
up, up,
ck равно
плюс бесконечность
равно, равно
и инфинити.
Так, что мы...
Ну, вот.
Да нет?
Ну, по большому счету,
я говорю, что мы...
Ну, ладно, тут мы...
А, ну мы же уже забили
на чистку памяти, да?
Поэтому давайте для краткости пишем.
root child
равно root next
root child равно
root next
равно 0ptr.
Так.
Вот.
Ну, и все, и теперь можно...
Ну, и можно отсюда выброситься теперь.
Вот.
В противном случае...
Значит, в противном случае...
А, ну ладно, это уже не иначе,
а просто идем дальше.
Значит, ну дальше
теперь надо проверить,
а не надо ли нам выбросить
ребеночка.
Может так оказаться, что...
Ладно.
Да, вот не пришло ли время сказать,
что, дорогой ребеночек,
теперь твои полномочия...
В общем, все.
Да.
Так, значит...
Ну, почему нет?
Ну, ты как бы да.
Как бы это да...
Не, ну есть еще другий раз.
Не, ну есть разные варианты.
А что такое root-стрелка-челка-стрелка-infinity?
А что такое root-стрелка-челка-infinity?
Э, ну child это тоже указатель.
А почему стрелка-инфинити?
Ой.
Как все сложно-то, а?
Формалисты!
Да, реально, не очень понятно.
Ну да, да, да, да.
Ну, правильно, правильно.
В какой-то бесконечности ребенка спрашиваем.
Да.
Да.
Ну, как сказать, я не знаю.
Поэтия, как бы, да.
Не успели спросить съехать.
Да нет, как бы это все понятно.
Да, но знаете. Нет, просто в реальном мире,
особенно в мире Непотемачка, вас реально спросят.
Там...
Это...
Там что-нибудь просто скажут слово Сэмки.
Но, на самом деле, вопрос подозревается.
В вашем правом кармане
есть некоторое количество семочек,
которое вам могло бы быть не жалко?
Ну, это просто Сэмки непонятно.
Чего вы имеете в виду вообще?
Вот.
Так, ладно.
Ладно, сложная ассоциация, окей.
Значит, если это соответственно так,
то что мы делаем? Мы этого ребенка
выпиливаем. Как мы его выпиливаем?
Мы
говорим, что...
Слушай, да, мы тебя начинаем игнорировать.
Вот. Мы
говорим,
что ладно, теперь я буду считать своим ребенком
ребенком моего брата.
А чтобы
это уравновесилось по братам, мы начинаем
игнорировать этого брата.
Не, это еще не Санта-Барбара.
Вот.
Так.
Не, ну вроде все.
Чего?
Так.
У нас
мы реализовали
бинвиальную кучу.
Нет, нет, нет.
Значит, еще раз. Мы
свято верить в то, что
вершину мы однажды создали ранку, он будет
навсегда.
Так, ну, для тех, кого кукнуло, что мы там
делали. Какого мы тебе брода вообще?
Нет, ну, смотрите.
Напоминаю еще раз.
Предположим, что у нас жила была вершина
и выяснилось, что она указывает на плюс
бесконечность.
То есть, типа там, тут уже
пустота, клен, ничего
интересного.
Но выяснилось, что
да, то есть, тут вершина есть плюс бесконечность, а тут
next, который в принципе адекватный.
Тогда
мы хотим этого ребенка удалить.
Мы его удаляем так.
Смотрите, я удаляю вместо этих
двух указателей, я провожу указатели
вот сюда и вот сюда.
Вот.
То есть, получается, ну, вот.
Какую?
Не, не надо.
Потому, что
когда мы возвращали, у нас тут на всем пути
как бы было все адекватно.
Чего?
Нет, тут как раз все адекватненько.
Значит, теперь смотрите.
На самом деле, значит, теперь
так, сколько у нас тут времени-то осталось?
Так. Ой,
может, правда она...
Ну ладно.
Ну, а когда еще детей уничтожать?
Ну, в смысле,
вместо верхних
условий. Вместо двух условий
оставить только нижних.
Нет, смотрите, понимаете,
сейчас.
Ну,
по-по-по-по.
А, ну если держать...
Так, ну ладно, если верить
в вариант, что у инфи, что у инфинити
обязательно два указателя пустые,
то могли, наверное, да.
Ну, работает и пуст.
Ну, как бы, да.
Хорошо. Ладно, значит,
смотрите, у нас осталось не так много времени,
поэтому сделать нам придет следующее.
Значит, во-первых, попытаться убедиться,
что, действительно, итоговая реализация
работает за вот адекватную
симпточку, только тут логен.
Верим, давайте.
Не-не-не, тут
желательно провести нот.
А потом, соответственно, да, потом сказать
действительно, какие мы еще две строчки вставим,
чтобы это было
магией.
И, собственно, тогда, в следующий раз уже тогда
обсуждать, почему там
становится все адекватно.
В чем, как, в смысле, а симпточки, так в смысле
вот этого вот.
На данный момент она работает просто как обычная куча.
Да, как минобиальная куча.
Так еще нет ли не по Констанде.
Чтобы делать экстракт мин, мы сначала должны запустить файнт-мин.
Чего?
Чтобы она действует в операции
и выполняла хотя бы за 2 секунды.
Ну да, вот дилит мин, да.
Дилит мин и экстракт мин, это вот
ровно. Ну, можно
экстракт мин было сказать, это
сделаем файнт-мин, сохраним его, вызовем
дилит мин и возрадуемся.
Да.
Но давайте
смотреть.
Подоцкнуть дилит, который мы написали.
Там мы где-то удалили что-то
из писка какого-то,
из кейсов.
Аппо фронт дата написано.
Так, значит,
внимание,
значит, теперь давайте разбираться.
Почему же
это так классно работает?
Ну, работает это следующее, смотрите.
Так, ну, давайте так.
Так, значит,
ну,
почему же это все у нас работает
на самом деле у от единицы
после инсерта?
Ну, потому что, ну, например,
смотрите, сам по себе
сифт,
я утверждаю, что учетная
стоимость сифта равна у от
единицы.
Каждого конкретного вызова сифта
у от единицы.
Почему?
Ну, потому что
заметим вот что.
Ну, будем считать, что,
ну, для начала давайте скажем, что у от единицы.
Ну, мы тратим время на его вызов.
Значит, почему?
Дело в том, что каждый
сифт он занимается
тем, что удаляет какой-то
список. Согласны?
Поэтому, давайте,
поэтому можно сказать, что он работает даже
не за у от единицы, а действительно
у от нуля следующим образом.
Давайте скажем,
когда мы создаем новый список,
а мы разрешаем себе его
создавать за логн,
мы тратим еще логари,
кладем на этот лист логн
монеток, который мы потом
потратим на удаление его
путем сифта. Почему нам
этого хватит? Потому что реальная
стоимость сифта это логарифм.
Потому что мы по факту все,
что делает сифт, обратите внимание,
он тупо проходит по вот этому списку
некстов и больше ничего не делает.
Нет, потому что у нас каждый
следующий вершина строго
меньше.
То есть все ранги, да,
вот.
Да, ну там
еще какие-то там свапочки делает.
Потому что работает это за логари,
ну не более чем логарифм.
Ну потому что ранги все не происходят
логарифма, например.
Вот, поэтому работает
за логарифм. Но каждый сифт
он как бы занимается тем, что удаляет
вот этот вот никому не нужный пустой список
по факту.
Нет, ветку то
он может и не удаляет, но там какие-то
вершины начинаются какой-то там
идут в плюс бесконечности, чуть позже
реально удаляются. Но самое
главное, что мы этот лист начинаем
игнорировать.
Игнорировать один список.
Че?
Игнорировать один список.
Да, игнорировать один список.
Да, но список
это может быть единица
bone. Но списков нет, списков у нас
всего N, напоминаю.
Где N, это было, у нас сколько было
инсектов, столько и списков буквально.
Ну списков не более
чем. Нет, ровно
инсертов, потому что каждый инсерт создает новый список, и только он, ну ладно, по факту это он делает не инсерт, а крейт от этого, но у нас только инсерт его вызывает.
Вы полностью код написали?
Ну вообще, да. Ладно, кроме дилит хэда, конечно.
А где мы использовали увеличение СиКей, и где мы использовали... как это сказать... где мы использовали увеличение СиКей, и где мы использовали...
Ну пока нигде.
Мы пока написали, где мы использовали Эпсел.
Пока... вот я говорю, пока нигде.
Тут, к сожалению, фишка такая, да, это не тривиальная реализация биномиальной кучи.
Нам нужно убедиться, что она работает за заявленную асимптотику, а потом мы сейчас начнем подкручивать.
А за заявленную асимптотику какую?
В данном случае, что инсерт будет работать за логен, а все остальное за отъединицы.
Да, мы ровно ради этого, мы всем этим и занимаемся.
Это же не совсем биномиальная куча.
Потому что потом...
Почему? Если у нас инсерк, как мы считаем, работает за честный лог, то если мы положим логен монеток на созданный список, то как бы учетная стоимость останется логом.
А потом наша доказательность сломается.
Почему она сломается?
Потому что там 1,9 на Эпсел за миллион.
Ну...
Мы здесь чуть-чуть поменяем.
Если, например, в СиК-тему, может он плать будет по одной единицей.
А там по-другому работать чуть-чуть будет.
Но я вам так скажу.
Дело в том, что там будет...
Нет, ну если вам интересно, то там работать это будет так.
Мы введем константу R, которая равна там 2 плюс 2 логарифма 1 делить на Эпсел, накругленное куда-то там.
Вот.
И у нас там будет просто фишка в том, что если у нас там...
Ну одна из фишек будет, что мы там достаточно быстро будем еще ветвиться.
То есть на самом деле в этом месте будет написано, что если там выполнено какое-то мистическое условие, то мы как бы от этого next вызовем shift еще.
То есть давайте сжимаемся еще.
И то, что мы оттуда выживем, мы присобачим к нам.
Ровно вот в этом месте это будет происходить.
Ну это если вкратце.
Подробнее лучше, да.
Подробнее в следующий раз, видимо, уже будем обсуждать.
А.
Сейчас каждый список состоит ровно из одного элемента.
Каждый список состоит ровно из одного элемента.
Пока, пока, пока, да.
В будущем...
Когда мы создаем элемент, то мы кладем логарифом монеток.
Да, конкретно на этот лист мы кладем логарифом новых монеток.
От логарифа от чего?
Ну, допустим, от N.
Предположим, что мы знаем, что в системе было не более чем N инсертов.
Так, и как нам это потом поможет?
Когда мы будем использовать shift, эти монетки свидятся тем, что...
Но этими монетками мы этот shift оплатим.
Да, но мы...
Так, ну мы уменьшим глубину хотя бы на один.
Как...
Ну, нет, при чем тут глубина?
Мы, Савер, мы уничтожили список.
Да, мы уничтожили список, но мы уничтожили целую кучу вершин.
И что?
А какая разница?
Монетки лежали на списке, а не на вот этой цепочке.
Не путать.
На вот этом...
Мы проходили же в цепочке.
Но уничтожали это список.
Так, но это очень здорово, но мы, в принципе, чтобы уничтожить список, мы проходили по всей цепочке.
Да.
И все смотрели на этот список, но они же...
Но длинное количество вершин-то в этой цепочке не происходит, логариф, Мэн, правда?
Да, но потом эти вершины же будут еще дальше потом использоваться когда-нибудь.
Нет?
Ну, часть, смотри, часть из них будет инфинити и потом ликвидирована.
И это тоже не очень интересно, потому что там...
Ну, скажем там, я не знаю, можно заранее там тоже, когда создаете вершину, положить там, я не знаю, монетку на ее удаление, да, это уже...
Это тоже там стоимость ноль, не интересно.
Но там часть удалится, а часть войдется в цепочке, которая будет указывать на другие листы.
Но новых листов от этого не создастся.
Мы в будущем не будем проходиться под тем же вершинам, которые...
Будем, но удалять будем уже другой лист.
От другого листа, потому что инфинити-инфинити там будет, она будет как заработка.
От одного удаляется сразу в две.
Ну да, но это неважно, потому что стоимость, учетная стоимость удаления, конкретного удаления тоже ноль.
Вот.
Сейчас, когда у нас, может нечего, когда у нас создается лист...
Лист создается в инсерте, а точнее функции create от phi и x.
Но много чего кладем.
Ну, например, кладем одну монетку для meldo вот этих вот.
И отдельно на созданный лист кладем logarithm n-монеток.
На его будущее удаление.
Нет, rank лучше не класть, потому что rank конкретно этого листа может потом повыситься.
А что такое n?
Что?
Что такое n?
Это количество решений?
Ну да.
Хорошо.
Ну вот мы сделали один раз сифт.
И потратили все эти монетки.
Если мы еще раз сифт сделаем...
Так и с других этих вот листов.
Если мы там...
Ну с других листов.
А мы тратим монетки, которые лежат на каком-то листе.
Конечно.
Да.
То есть один конкретный сифт.
Да.
Он...
Один конкретный сифт.
Он прогуливается по цепочке.
Как бы он занимается тем, что как бы удаляет этот опустевший лист.
Хорошо.
А почему на нем будет достаточно количество монет?
Ну потому что сам конкретный сифт работает за от logarithm n.
Потому что тут...
И на нем лежит logarithm n-монеток.
Значит их хватит.
Нет.
На какой-то вот вершине снизу, на ней же не факт, что лежит logarithm n-монеток?
На вершине ничего не лежит вообще.
Монетки лежат на самом листе.
Сейчас.
А.
А.
Лист дерева.
Я путаю лист вот так.
Не путай, да.
Лист дерева.
Нет.
Лист это вот...
Есть лист список.
Есть лист дерева.
Это другой вопрос.
На этом листе ничего не лежит.
Точнее какая-то к списку отношения не имеет.
Хорошо.
Так.
Вот.
То есть самое интересное, то есть хорошо.
То есть как минимум да.
То есть как минимум сифты на самом деле проплатились.
Да.
Учетная стоимость сифта оказалась ноль.
Приплачивали.
Более того, да.
Теперь сколько раз этот while будет вызываться?
А.
Ну хотя нет.
У нас еще есть еще одна маленькая проблема.
Delete head.
Потому что в delete head на самом деле, да, мы его не прописали,
но там...
Но там я дорадуетесь, что мы там напишем.
Я думаю, нет уже смысла писать эту...
То есть как мы из этих деревьев там создадим кучу,
как мы ее вмелживать вот в это вот будем, да.
Я только обращу внимание, что вот в этом месте sh-root
сможет поменяться.
Ну просто то, что мы делаем вмелжение.
Вот.
Да, именно.
Не говоря уже о том, что этот head может быть,
извините, началом списка.
Это тоже такой вопрос.
А?
Мы доказывали, что у нас ранки меньше 3.
Да.
В этом случае.
У нас же типа подвешивается не к вершине,
у которой 2 стихи не имеются.
А у которой типа циаретист когда-то могло быть 2 стихи.
Ну как сказать...
Ну это, да, так есть большое слово сказать,
остается в качестве упражнения.
Ну доказательство будет такое же, что на самом деле
у каждой вершины есть...
У каждой вершины там есть такой список...
Там есть набор множества элементов,
которые к этой вершине имеют отношение.
В том числе и вот...
Ну с теми самыми городами и кладбищами.
И можно будет тогда по индукции доказывать,
что количество этих элементов у каждой вершины ранга k
ровно 2 в степени k.
Причем в каждый момент времени каждый элемент,
живой или мертвый, имеет отношение
только к одному из вот этих вот рутов.
Да, разумеется.
Но если рассматриваешь различные деревья,
то как бы не может быть так,
что одна вершина имеет отношение к двум.
Да.
Вот к одному из этих он имеет отношение, да.
Вот.
Так вот.
Значит, но в delete head теперь...
Вот теперь внимание.
Так, внимание.
Теперь смотрите, почему тут написано
меньше либо равно root rank пополам?
Потому что фишка такая.
То есть...
Ну, потому что, смотрите, помните,
вот отчего у нас раньше работал meld?
Да?
Вот давайте вспомним его анализ.
У нас в meld было две части.
До окончания одной из куч
и после окончания одной из куч.
Помните, да?
Было дело, да?
Заметьте.
Ну вот.
Ну и, соответственно, теперь...
Значит, теперь...
Ну вот.
Ну, собственно, как же они анализировались?
Вот о чем со второй части?
Вторая часть базировалась на том,
что у нас всего не более чем n деревьев.
Поэтому, как бы,
когда мы объединяем два дерева,
то количество деревьев уменьшается на один
и оно никогда не увеличивается.
Поэтому суммарное количество слияния у нас не более чем одно.
Правда?
То есть, n-1.
Да, n-1.
Теперь это перестает работать.
Потому что delete head говорит нам
о нихрена.
Нихрена.
Потому что выясняется,
что количество деревьев может увеличиваться вполне.
Но здесь одна фишка работает так.
Ну, давайте так.
Ну, то есть,
тут делаем как всегда.
То есть,
а именно...
Значит...
Ну, на самом деле,
то есть, идея такая.
Для того, чтобы делать эти мержи,
мы говорили так.
Мы кладем на корень каждого дерева монетку,
которая дает нам право
его мерживать с кем-нибудь.
Правда?
То есть, когда у нас есть два дерева
и у них есть две монетки,
мы тратим ровно одну из них,
а вторую перекладываем на их новый корень.
Помните?
И такую монетку, когда она у нас будет появляться?
Ну, идея теперь такая.
Во-первых, такая монетка появляется,
когда мы создаем вершину в крейт
от ключа.
Такую монетку мы кладем.
А во-вторых, мы будем говорить,
что каждый раз, когда у вершины
удаляется ребенок,
каждый раз, когда у вершины удаляется
ребенок,
значит, мы можем
мы можем, скажем,
мысленно положить на нее
монетку.
Удаляется в севте.
Ну, например, да.
Например, в севте, да.
Да, например, в севте
или там вот, я не знаю, еще где-нибудь.
Вот.
То есть, такие вот монетки.
То есть, может быть, даже
правильнее, на самом деле, для каждой вершины
говорить, что если мы конкретно ее ребенку
удалили, давайте на ней будет лежать
вершина.
И тогда кажется,
что если детей у нас
оказывается меньше, чем ранг пополам,
это означает, что вот на этом пути будет лежать
как минимум ранг пополам уже
меток, которые мы положим
на новые деревья,
чтобы они мерзились.
То есть, таким образом
с Мелдом мы выкрутились.
Ну, просто мы говорим так.
Вот, смотрите, вот в этом месте,
внимание, ровно, ровно,
вот в этом месте, допустим,
когда мы тут у вершины
решили уничтожить ребеночка,
мы вот
на саму эту вершину root,
именно на root, то есть не на корень
глобальный, вот на текущую,
кладем монетку.
То есть, это монетка нового цвета,
которая будет говорить нам о том, что у этой вершины
тут ребенок удалялся.
Почему я это делаю? Дело в том, что
я бы мог выкласть на корень, но дело в том,
что эта вершина в какой-то момент
из корневого вот этого списка братьев корня могла
исчезнуть в силу какого-нибудь свапа.
Вот, поэтому я ее посвапал,
потому что монетка сохранилась.
И поэтому в будущем получается следующее,
что на самом деле, ну, можно убедиться
следующим, что если у вершины ранг, допустим,
8, а у нее next ранг 3,
то это означает, что на этой вершине,
видимо, лежит 5, там сколько, 4 монетки.
Ну, по числу удаленных детей,
правда?
Потому что сначала у нее был ребенок ранга
7, он был удален, да?
А, ну еще там, а, ну еще конечно
фишка, что если вы удаляете там вот этого брата,
то все монетки переходят, соответственно,
в родителя. То есть, типа, я
дорогой брат, я игнорирую тебя
и собираю все твои деньги.
Вот.
Вот. И тогда получается следующее.
Тогда получается такая красота,
что когда оказывается,
что детей осталось меньше
либо равно ранг пополам,
это означает, что количество
на этом пути монеток
уже больше либо равно ранг пополам
по числу исчезнущих детей тех самых.
Уж у каждой вершины указано, сколько там детей
подряд было убито.
Вот. Ну и, собственно, что это означает?
Ну, это означает, что как раз
мы, значит, в этом, эти монетки перекладываем
на новые корни,
в новую кучу, и получается,
что учетная стоимость
этой операции не пострадала.
То есть, таким образом, действительно,
получается, значит,
здесь мы выкрутились.
Но тогда отсюда, кажется, следует,
что мы и в принципе везде выкрутились.
Потому что обратите внимание,
да, но этот deleteMin в принципе понятно,
он работает за findMin плюс 100 единицы,
причем
не меняющих никаких монеток,
а findMin каждая итерация
получается обязательно
чем-то дооплачена.
Ну понятно.
Что?
Ну,
ну,
ну,
ну,
щас.
Ну, не совсем так.
Ну ладно, я скажу,
начну с другого. Вообще исходная
бенмельная куча говорила, что давайте никогда
не делаем Sieve, делаем всегда deleteHead,
но это бы работала delete
за логорифом.
Но если мы, да,
Чисто теоретически мы могли бы делать там, наверное, делать всегда сифт, действительно, почему бы и нет.
Вот.
Ну вот.
Но, но тут фишка, вот тут уже и начинается фишка в том, что если сифт делать не нот, то есть если сифт делать только иногда, то вот в этом месте как раз и начнется как бы, то есть как бы нам, как этот код надо подкрутить, чтобы периодически какие-то элементы уничтожали, и их листы склеивались.
Но при этом надо добиться того, чтобы они с одной стороны делали это не слишком часто, то есть чтобы не слишком много элементов склеилось.
Но с другой стороны мы должны это делать так, чтобы, как бы, а чем точка сифта при этом оставалась хорошей, то есть что-то там условно, там если мы сделали от вот этого R-операции, то там желательно, чтобы это от R-операции было оплачено слиянием двух листов в одно.
Вот.
Нет, тут никто не будет умножать на два.
Нет, из...
Нет.
Изменения...
Нет, на самом деле вот...
Нет, там на самом деле чит предлагается следующий, то есть не совсем такой, но вот...
То есть на самом деле работать будет так вот, сейчас вообще...
Так, давайте вот можем...
Сейчас совсем магия будет.
То есть если выполнено мистическое условие, которое у автора называется Loop Condition...
У нас, кстати, говорят, через час пару минут, друзья, надо...
Да, да, да, я... Поэтому я и говорю, просто вот.
То...
То мы отправляемся вот сюда и делаем все это еще раз.
Эээ...
А почему это что-то...
Что вообще?
Так давайте давайте это будем гонять, чтобы на следующей лекции...
Да, именно, именно.
Что за...
Вот да.
Что за...
Вот да.
А почему это нужно ускорять?
Мы сделали больше.
Прям формулу.
Ну блин, доски мы тоже делаем больше, чем Василия, но минимум раклеска ускоряет.
Но...
