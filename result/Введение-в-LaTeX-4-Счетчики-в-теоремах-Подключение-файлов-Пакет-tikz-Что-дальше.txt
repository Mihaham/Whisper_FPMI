Итак, мы начинаем последнее занятие курса по техо, и за сегодня хочется закрыть все открытые
вопросы, которые возникали на прошлых занятиях. Все дело до обсудить. В моей части программы
на сегодня завершение истории про счетчики и как использовать для нумерации сложных объектов,
например, теориям. Работа с большими проектами в техе, а именно подключение всяких сторонних
файлов, и немножко про графику в виде пакета тикс CD, после которого я передам слово Лешу.
Сначала счетчики. Тут стоит рассказать про две техники, которые упоминались в прошлый раз.
Во-первых, необязательно аргумент некоторого счетчика после команды Ethereum, который,
как уже в прошлый раз говорилось, говорит, что данная теорема ведет нумерацию на один
уровень глубже, чем тот счетчик, который поднадеет аргумент. То есть, если у нас есть первый
уровень глубинный счетчик секций, просто 1.2.3.4, если указываем в качестве аргумента его для этой
теоремы, то теорема будет нумероваться в виде 1.1, 1.2 и так далее, где первое число это номер
текущей секции. Ну и вот есть пример кода. Мы говорим, что теорема нумеруются за пунктом
секции, а следствие нумеруются за теоремами. И вот такой вот код, который приведен ниже,
дает такой результат. Можно снова посмотреть на него.
Можно вопрос? Хотя, я понял, все это пологло с кей.
Ну, на всякий случай, я построчно прибегу в счет, произошло. Вот первые две теоремы,
которые объявлены. Ну, они просто нумеруются как теорема 1.1, теорема 1.2, потому что в часть
первого раздела они идут. Далее идет следствие, которое идет за второй теоремой, и поэтому следует
счетчик от нее и ставит после этого свое число. Ну и да, если бы была еще одна теорема,
потом еще наследствие. Еще наследствие, значит, надо было уже с теоремы 1.3. Вся нумерация
обнулилась. И вторая вещь, которая в прошлый раз не была подробно сказана, но которая тоже
бывает очень полезной, это аргумент, который можно передавать сразу после названия теоремы,
которая на скобках. Это тоже может быть предзвольный счетчик, но эффект будет другим. Это будет означать,
что данная теорема прям использует этот счетчик для своей нумерации, и соответственно,
каждая новая теорема инкриментирует этот счетчик. Например, вот мы создали прям сами счетчик
myCount и сделали две теоремы, вернее, утверждение и лему, два типа теорем, которые на счетчик
опираются. И вот я утверждаю, что они будут вместе, вернее, каждая по очереди счетчик
инкриментировать, если будем их использовать. Пример коры вот такой. Мы используем одно утверждение,
потом одно лему, потом еще одно утверждение. Потом мы сами руками продвигаем счетчик еще на один и
пишем еще одну лему. Получается вот такой результат. Как и ожидалось, эти два типа теорем используют
один и тот же счетчик, поэтому их нумерация не просто согласована, а прям одна и та же нумерация.
И первые три объекта нумируются как раз-два-три, потому что они идут подряд, с счетчиком больше
ничего не происходит. Просто каждая новая появляющаяся теорема инкриментирует. А далее
мы намеренно меняем счетчик еще на плюс один. И поэтому тот объект, который будет стертом,
получает номер пять. Вот. Это бывает полезно, когда действительно в документе много похожих
сущностей, которым уместно иметь одну и ту же нумерацию, как, например, утверждение и лемма,
но возможно кому-то может потребоваться такая фича, что этот счетчик он вообще-то управляемый,
и можно менять его даже между этими утверждениями. Ну и вот раз зашла речь про какие-то сложные файлы,
в которых требуется какие-то сложные вещи с счетчиком производить, стоит наконец поговорить о
том, как организовать большие проекты, а именно как подключать много файлов с кодом в один файл и
компилировать его. Есть этого два инструмента, input и include. Мы говорим про input в первую очередь,
а потом сравним вот с вторым инструментом. Вот. Как делается постановка кода в техе? Пишется
команда input и ее аргумент, название этого файла, код которого хочется подставить прямо в данное
место. На стадии компиляции этот код будет подставлен вместо команды input и будет
компилироваться как единый документ, с которого эта компиляция запустилась. Что примечательно,
ну можно указывать не просто файлы лежащие рядом с текущим файлом в качестве их названий,
а можно искать файлы где-то по файловой иерархии, используя привычные команды там
., ., slash, и при этом область видимости, текущая местная иерархия, в которой мы находимся,
это место, где лежит компилируемый файл. Вот мы ищем из него все остальные файлы. Даже если
те input, которые используются, они какие-то вложенные один в другом, то есть мы подключаем с помощью
input один файл, а внутри него допускаем еще один input, и вот он будет как-то искать файлы. Вот
надо помнить, что все равно область видимости у него будет из корневого файла, который компилируется.
Не относительно. Ну и да, как было сказано, инструментов два, у input есть альтернатива include,
но работа несколько по-разному. Вот я привожу сравнение каких-то главных отличий между ними,
но самое счастное, наверное, в том, что input предполагает, что он будет использоваться для
включения всяких цельных кусков кода, которые хранят себе целые главы, может быть, какого-то
произведения. Поэтому он много производит работы по подчистке страницы, каких-то еще добытных
манипуляций, и начиная текст с новой страницы, с чистого стиля, и это не всегда бывает полезно.
Более того, это лишнюю серия для компилятора, поэтому лично я так никогда не делаю. Мне кажется
более разумным в такой ситуации делать совмещение команд new page, которая просто делает новую
страницу, и команда input, которая была ниже, выше. Ну input просто подставляет текст, больше ничего
не делает. Следующая тонкость, input бывает вложенным, то есть можно подключить один файл в main,
потом от этого файла еще один файл. С include так не сработает, как раз из-за тех манипуляций,
которые он производит. Это тоже некоторая опасность, которая может себе много выстрелить.
Но у него есть такая фича, что если потребуется в целях, скажем, отладки компилировать не все
подключаемые файлы, то в преамбулу можно просто добавить вот такую вот команду include only и все
имена, которые будут компилироваться при подключении. Все остальные будут игнорироваться. Это полезно,
если вам не хочется, скажем, по большому файлу идти и отслеживать, какие мы файлы вообще подключали,
и комментировать отдельно каждую строку. В случае с input-ом tp-фичи нет, но мне кажется,
это не очень большая потеря, потому что файл main, повторюсь, как правило, выглядит очень компактно,
и в нем легко оследить, какие файлы компилируются, какие нет. И если вам это нелегко, то скорее всего
у вас архитектура проекта не очень удобная, и стоит ее поменять в первую очередь, а не переходить
на include. Еще раз напоминание о том, как происходит поиск имен. В этой технологии всегда, даже из
сложенных файлов, весь поиск происходит из искорневого файла. И более того, это касается не
только input-а и include-а, это также касается команды include-graphics, которые уже были,
которые получают изображение, и тех команд, которые будут дальше. Бывает полезно в тех интегрировать
какую-то еще pdf-ку, ставить несколько страниц другого pdf, а потом продолжить свой. Это делается,
в частности, пакетом PDF-pages, наверняка есть альтернатива, но вот есть такой пакет,
который очень простой indexes. В нужном месте нам просто требуется сделать include-pdf и далее указать
какие-то нужные нам аргументы того, как это будет подключаться, например, номера страниц,
которые потребуется подключить. Причем, опять же, вариантов как это указать много. Можно указать
отдельные страницы, можно интервалы. Ну и у этого пакета, как у всех остальных, есть удобная
документация, ее можно посчитать, посмотреть все остальные параметры, вплоть до того, что
пылучки подключаемых страниц можно подключать не в прямом порядке, а в таком, который требуется для
печати буклетов. Ну, то есть, книжечек формата A4, припечатен на всех сторонах файла. Он сам это
посчитает и правильно разместит. Но это все гуглится. А синтезис первоочередный, он вот такой.
И последняя история, которая будет рассказана мной, это про то, как делать техи-графику,
ну и в частности коммутативные диаграммы. Вообще, пакет TIX, он очень большой, мы про него будем
сегодня подробно говорить, но уже не я, а Леш. Но вот есть такая у него особая технология, ну и
вообще их несколько. Есть разные пакеты поменьше, которые решат какие-то конкретные графические задачи.
И вот есть такой пакет TIX-SD, который делает коммутативные диаграммы. Это вещи из алгебры,
с которой вы, наверное, отсталкивались. И, ну, поскольку я часто пишу, что по алгебре, мне он
постоянно пригождается. Но, опять же, из его специфики я приведу только конкретный пример
использования. И на его примере я просто разберу, ну, каков синтез происходящего. TIX-SD позволяет нам
использовать такое имяное окружение TIX-SD, внутри которого будет такой особый синтаксис, который
поддерживается только внутри этого окружения, который будет отрисовываться в диаграмму. Вот,
я предлагаю прям посмотреть на то, что получится в итоге. Вот такая картинка. И постараюсь
анализировать код, смотреть, что он делает. Значит, первоочередно, TIX-SD устроен как некое
многострочное окружение, как таблицы, как элайны. Мы можем указать параметр, скажем, насколько будет
большими отдевители строк или столбцов в качестве аргументов ROGSEP или COLUMNSEP. Это будет влиять на
то, насколько друг от друга далеко стоят ячейки этой диаграммы. Ну, вот теперь с самой ячейки,
что это такое. Как в таблице, у нас есть некоторое количество строк, в каждой из которых одно и то же
фиксированное количество ячейок. Здесь мы не указываем его заранее, но мы выбираем с собой,
чтобы это число было согласованными, чтобы было одинаково на каждый строк. Здесь строк всего две,
поэтому на каждый строк у меня по три ячейки. Причем три ячейки я делаю заполненными текстом,
а три пустыми. Ну, для того, чтобы мне было вообще реально организовать такую диаграмму,
то есть строки будут все по-тиагонали. У меня есть три ячейки сверху, три ячейки снизу.
В каждой ячейке можно написать некий текст, который будет в ней адресован, и эти ячейки
можно соединить между собой стрелочками. Синдоксистибичная стрелочка имеет вот такой вид.
Это arrow и два параметра аргументов. Иногда даже три. Аргумент в скопках квадратных,
это аргумент необязательный, он подключает некий модификатор стилей для стрелочки. Например,
если я пишу здесь dash right arrow, то это будет стрелка, адресованная пунктиром. Если я пишу swap,
это будет стрелка, ну в общем, подпись к ней текстовая будет размещена не в привычном для
нее месте, вот здесь, а в противоположном, вот здесь. Swap просто меняет позицию текста в
зеркальте относительно стрелки. Далее обязательный аргумент, в котором придается направление стрелки.
Причем в виде такого вот сокращения из буквок, где RL это right left, а DU это down up. Это может быть
любого вида комбинации, скажем, три буквы R и четыре буквы U будут означать, что стрелочка
ведет на три ячейки вправо и на четыре ячейки вверх. Но это, конечно, экзотика. В данном случае
хватает вот такого. RL означает, что у нас остается стрелочка, которая ведет на две ячейки вправо,
то есть не на одну и заканчивается здесь, а сразу на две, идет в третью. Две стрелочки тут отрисовываются
как одна влево вниз, одна вправо вверх. Последний аргумент, это собственно текстовая подпись,
которая будет размещена на стрелочке. По умолчанию она будет размещена сверху от нее,
либо в том аналоге верха, который соответствует данному направлению стрелочки. Например,
стрелочка идет вот так, то на нее, вверх, он вообще, говорят, здесь. То есть поворот на
270 градусов относительно текущего положения. И если мы хотим, чтобы текст был на самом деле
на настоящем верху, а не там, который предполагается, мы делаем команду swap,
о которой я уже тоже упомянул. Вот. Базу синтезисов такой. На самом деле,
то минимума хватает для того, чтобы рисовать диаграммы. Но, опять же, есть целая документация,
о которой можно читать, разбираться и смотреть на другие возможности. Вот.
Лично я на этом заканчиваю и хочу передать слово Леше. Надеюсь, ты уже здесь и готов.
Да, я здесь и я готов. Да. Так. В общем, сегодня я расскажу вам про фикс. Ну, Даню уже начал.
В общем, основная идея – это нам нужны рисуночки в техе, и мы хотим рисовать как-то векторами. Ну,
в смысле, не кисточкой, не мышкой водить, а создавать такие рисунки, которые не трудно изменить
и которые, в общем, дают команду. Вот. Ну, в общем, самые простые примеры – это просто линия или там
вот точечка. Вот. Но мы сейчас подробно разберем, что это значит. Просто для демонстрации. В общем,
основная идея, основной блок всех рисунков в тигзе – это путь. И путь состоит из точек и вот,
в общем, двух диафисов, которые соединяют эти точки между собой. И получается вот такой нарисованный
путь. Вот. Вот так он выглядит, если по нему пройтись. Да. Для того, чтобы рисовать в тигзе,
нужно… можно либо использовать окружение – tixpicture, либо использовать команду tix,
дальше какой-нибудь код, и все заканчивается точкой за пятой, или tix и в фигурных скобках.
Набор команд. Вот. Ну, понятное вплощительное, самый способ – это писать окружением. Вот. Но
иногда я буду в экономии писать просто тигз, чтобы не тратить вертикальную высоту слайда.
Чтобы нарисовать ellipse, ну, например, круг, нужно просто нарисовать круг и его радиус.
Чтобы нарисовать ellipse, нужно передать ему его полуосе. Чтобы нарисовать повернутый ellipse,
достаточно просто сказать ему «повернись 30 градусов». Еще иногда бывает полезно рисовать
сетку. Тоже такой просто пример. Чтобы нарисовать ее, мы говорим… ну, вообще для
любого объекта, для круга тоже вначале можно сказать точку, к которой мы рисуем. То есть,
если ничего не указывать, то он будет рисовать… то он как-то сам ее выберет. Вот. Но так можно
явно указать, где рисовать, и это все может быть частью пути. Вот. Для того, чтобы нарисовать
сетку нужно также в параметрах, помните, как бы параметр повернуть, также в параметрах
передать шаг по стороне xtepp или xtt. Вот ну или просто xtans. Давайте proposed все, что ты нарисовал.
Ну все, что ты тут сказал. Нарисуем круглый круг, ecological ellipse, еще один ellipse и сетку такую.
но это все выглядит уже как-то слишком сумбурно и неприятно, поэтому давайте я скажу, что сетка
у нас будет серенькой и тоненькой, серенькой и очень тонкой, ну и в принципе ничего не изменит,
вот теперь это выглядит приятнее, даже можно чем-то красиво назвать, то есть сетка выполняется
скорее такой вспомогательный вид, как просто как фон, в общем эти все линии, их можно считать
вспомогательными и чтобы сделать их вспомогательными, я сказал, что они должны быть серыми и тонкими,
вот, но на самом деле тут не существенно то, что они серые и тонкие, а существенно то, что они
вспомогательными, и чтобы не возникало, ну, чтобы логичнее, куда логичнее, куда правильнее с точки
зрения общественного программирования, будет выделить это как в отдельную функцию что ли, в общем
сделать такой define, в чем сделать свой стиль, сделать свой стиль, например стиль вспомогательной линии,
ну, в синтакте у него вот такой, вот, может показаться немного странный, но в общем какой есть, вот,
ну, это делается с командой TXS, то есть стиль можно применять конкретно к кому-то одному рисунку,
вот, а можно и делать глобальным для всего вашего документа, вот, ну, в общем пример таких,
пример такого использованного вспомогательной линии, очень частый, еще точка, но к ней мы чуть
позже вернемся, в конце, я там большой пример разберу, так, теперь материал чуть с изветочкой,
в общем, во-первых, можно передавать в параметр, то, что, вы смотрите, например, hell appliance,
style, и вот здесь передал параметр, это как в командах, хештег 1, синтаксис,
высказательный знак 50 для цвета означает, что, ну, потом расскажу, что это означает, в общем,
этот синтакс относится именно к цвету, а вот хештег 1 относится к команде, которая придет,
и дальше мы указываем дефолтное значение, ну, в дефолту пускай будет black, вот, а дальше мы можем
сделать, то, что здесь писал hell appliance равно black, это можно было не писать, они бы, по умолчанию,
были равно black, и можно делать второй стиль, вспомогательная сетка, где будем задавать,
то есть как мы вот здесь сделали, мы сделали step и hell appliance, вот, а все это можно объединить
в один аргумент hell grid и указывать после равен, ну, то есть hell grid равно 0,5 сантиметров,
как здесь, то есть hell grid равно 0,5 сантиметров, это будет еще один аргумент, который, в общем,
мы опять уменьшаем сущности, которые будут встречаться в новом рисунке, вот, делаем его более читаемым,
вот, ну, опять-таки, если для самураев можно делать несколько параметров, вот, в общем,
синтаксис можно на эти метры. Я уже говорил пару опций, помните, типа поворот или шаг, вот, но основные,
конечно, это как бы опции пера, опции линий, и основная характеристика толщина, это ultra
vary thin, thin, thin, thick, thick, ultra vary thick, вот, в общем, вот, понятно, такая градация, цвета,
как можно назвать цвета, можно либо название, либо rgb, вот такой синтаксис, то есть можно сказать
не rgb 250, а rgb 10, ну, то есть, вообще говоря, можно вот таким синтаксисом смешивать, в общем, раз в род
цвета, не только rgb, там разные палитры, и не только из 255, это просто категорическое значение, ну, в общем,
можно из другое какое-то значение дать, не знаю, из ста в процентах. Можно смешивать два цвета,
такая запись означает то, что 10% красного и 90% синего, вот, и помните, я говорил о синтаксисе,
в конце это означает прозрачность, то есть, сначала цвет, и в конце,
да, в общем, сначала цвет, и в конце прозрачность, вот, и заполнение линии имеется в виду, в общем,
dash, это пунктирует dot в точках, ну, loose или dense, типа, редко часто, вот, ну, вот, примеры,
такие простенькие уже, уже выглядит приятно, в общем, fill, это для заливки используется, ну,
то есть, можно просто color, это цвет линии, а если fill, это цвет заливки пути, в общем, вот, первый
вариант, вот второй, тут немного надо пояснить, в общем, в пути я использовал cycle, это, значит,
вернуться к первой точке пути, ну, и в общем, зациклить путь, чтобы не копить власти.
В втором треугольнике, что я сделал, ну, вот, это сегмент окружности. Я начал с точки 2.0,
дальше значок плюс означает то, что 10.2, сейчас объясню, что это значит, в общем, значок плюс
означает то, что эта точка отсчитывается от предыдущей точки пути, то есть, не абсолютное значение
координата относительно, да, дальше, 10.2 означает, в общем, эта координата точек в полярных координатах,
то есть, 10 градусов, против числа стрелки, и два, две единицы длины, вот, дальше я сказал в этой
точке разместить дугу, в общем, дугу вот с такими, ну, от нуля до 30 градусов с радиусом 2,
вот, и, в общем, зациклил, вот, да, и залил все это синим, с 10 процентов яркости.
Еще, в общем, еще такое, иногда будет полезно рисовать стрелки, хочется рисовать стрелки,
ну, я не знаю, вектор скорости, например, и, ну, в общем, стандартный вот синтаксис для стрелки,
это вот стрелочка, вот, но она выглядит не очень приятно, это та самая стрелка из тех,
которые ту или не ту, в общем, вот эта обычная стрелка, которая с ним было стрелки, но куда
более приятная стрелочка, это стилс, вот, выглядит, и чтобы все стрелки были такими,
можно тоже в параметрах всей, всего, ну, или в параметрах конкретного, конкретной строчки,
или в параметрах всего окружения, или можно в свой стиль это засунуть,
которых мы обсуждали в стиле, в общем, чтобы все стрелочки были вот такого вида, это стилс,
вот, ну, тут я еще показываю то, что дугу можно делать еще эллипса, то есть, помните,
там, угол-угол-радиус, а тут, как бы, вот такой синтаксис, значит, там, два радиуса,
ну, то есть, малая и большая площадь, ну, дугая эллипса. Стрелочки, может быть, две штуки,
и еще, на самом деле, вот, вместо самой стрелочки можно писать название стрелочки, например, вот,
вот такая стрелочка называется лотьях. То есть, вместо, здесь можно было писать лотьях,
тогда все стрелочки были такими в этом рисунке. В общем, да, вот тут я еще указал такой параметр
scale. Это тоже параметр, который применяется, ну, или к всему рисунку, или там, к конкретному,
к какой-то строчке. Это, в общем, масштабирование, потому что масштабирование влияет только на
координаты, то есть, там, буквы не изменяются, что такое, то есть, масштабируется координат,
но подписи, которые вы будете делать, ну, обычные технические, они останутся таким же. Ну, да,
соответственно, и с документами. И вот здесь еще после, я не написал, в общем, после названия
стрелочки, или даже вот здесь вот, сразу после, можно написать в тоже квадратных скобочках size,
равноту и размер. Если хотите уточнить размер, ну, обычно стандарты подходят. Так, теперь я
немного про точки поговорим. Чтобы задать координату точки, существует синдоксис типа расположить,
дальше вот эти названия точки в круговых скобках, и где расположить. Координат стоит в логичной
синдоксе. И дальше вот, ой, я тут не исправил, короче, тут не прямая, а кружочка. В общем, там
просто draw, a, и дальше вот здесь circle. Ну, там обычная кружочка. А сейчас, в общем, это было
быстрое введение в самую основу тигза, а сейчас будут чуть-таки уже какие-то более содержательные
примеры. Окей, в общем, первое, что зачем нужен тигз, это чтобы бы считать, ну, то есть, чтобы
упрощать немного в числении себя. То есть, мы же там, когда хотим, например, может, мы хотим провести
окружность через точку. То есть, конечно, можно посчитать радиус, но это выглядит кастрюля немного.
Вот, поэтому синтаксис такой. В общем, вот мы располагаем две точки, и дальше, я потом объясню,
что значит node, и дальше мы говорим то, что, в общем, такой синтаксис. Провести окружность через
точку a, все это провести в точке b, вот, и нарисовать. Вот, node это, в общем, такая концепция тоже тигза,
и, в общем, о ней как бы так быстро ничего полезно не сказать. В общем, просто в некоторых случаях я буду
писать node, ну, в общем, таким синтаксисом. В общем, это концепция узлов, и как хорошо про нее рассказать
быстро не получится. Вот, ну, в общем, она, как это можно просто смотреть и пользоваться. Вот, но потом
я чуть побольше про нее расскажу как конец. В общем, глобально это мы просто говорим то, что у нас есть узел,
расположен точке b. Если мы здесь что-то здесь напишем, фигурно в скобках, то это будет нарисовано в
точке b. Ну, то есть, вот, напишем тут букву a, и прямо здесь вот появится буква a.
Прям в той точке, где мы расположили узел. Вот, а теперь начинается, в общем, вся макия его. Ну,
хорошо, в общем, я там, вот, coordinate a и b, в общем, я располагаю точку. Ну, точку a и c расположилась чем
по-обычному. Точку b расположил в полярных координатах, а точку d расположила относительно точки a. Вот.
В общем, пакет tixcalc позволяет проводить вычисления точками, типа, складывать их там, ну, такие
вычисления проводить, но для этого надо как бы оформить такое окружение скобочка долларов,
ну, как формула. Вот, теперь началась магия. Смотрите, вот такой синтаксис обозначает точку,
причем это даже без tixcalc. В общем, такой синтаксис обозначает точку, лежащую на пресечении вертикальной
линии, проходящей через a, и горизонтальной, проходящей через b. Ну, вот, вот эта точка я
вот провел путем. Вот a, это точка b. Вот он нарисовал, и вот он как вертикальная линия через a,
и горизонтальная через b. И вот он нашел пресечение этой линии. Ну, там b.d.c я просто
нарисовал. Вот дотат. Дальше интересное. Вот такой синтаксис. Ладно, начну с a. Вот такой синтаксис.
Он обозначает то, что мы провольем от точки b до точки d отрезок и выбираем что-то на расстоянии 0,5
от длины этого отрезка от b в сторону d. То есть здесь может быть отрицательное число. Например,
минус 1 означает вот эту точку. Ну, то есть, которое отражение b на этом отрезке. То есть,
на таком же расстоянии вот в эту сторону идем. Вот. Если бы я взял 1, это взял бы вот точку d. 0.b.
2 это вот отражение b за d. Вот. А вот такой синтаксис dbc означает проекция b напрямую
соединяющей d.c. То есть, ну, здесь треугольник dbc получился сейчас треугольный, поэтому,
ну, это просто высота. Но если бы, например, точка c была здесь, то оно просто
опускается на линию и не парится. Шампакет тикс евклит позволяет работать с отрезками углами.
И там можно нарисовать бисикрису лбу. Все красиво сделать. Давайте вот в этот рисунок добавим,
отметим угол. Вот здесь можно нарисовать, например, ватикальную палочку. Это будет
означать черточка. Можно нарисовать букву s. Это будет означать вот такое, знаете, когда, в общем,
волнистая отметка. Ну, и там есть какой-то список. Можно загуглить. После арк надо писать количество
букв l. Это вот этот угол. Он никак не помещен. 2 l означает 2 дуги. 1 l, 1 дуга. 3 l, 3 дуги.
Сайз 10 пт. Ну, это так просто по вкусу подбирать, чтобы прилично выглядело. И дальше говорите
какой угол. cdb. Вот cdb. Если вы скажете bdc, он пометит вот этот внешний угол. Так,
tx mark right angle. Это отвечает прямой угол. Вот он отмечен. Это спойлер. Дальше label angle.
Это пометить angle. Ну, вот cdb. cdb помещаем синтаксис альфа. Ну, помещаем вот такой синтаксис,
помещаем его значением альфа. Вот пометили альфа. Дальше tx mark сегмент. Как помещать вертикальную
палочку одной чертой, две вертикальные двумя. Буква s. Это такой волнистая пометка. Это отрезок
eb. Вот отрезок eb и ed. Мы пометили, потому что они равны, потому что, помните,
а вот сюда это была просто середина отрезка bd. Ну, в общем, они равны, мы их ответили. Вот так
вот можно конструировать такие геометрические рисунки. На самом деле очень просто, очень удобно.
Небольшое отступление про лотех. В общем, один из создателей вот этого еще движения придумал
еще циклы. Циклы в чехе. И они не только про, ну, то есть они там подключаются к какой-то библиотекой,
но это тоже легко загуглить, но они идут вместе с тигзом. И, ну, работают не только в тигзе. Вот.
И, например, можно привернуть вот такую вот махинацию. То есть, какой синтаксис?
Forage переменная, дальше диапазон. И тут может быть, аж, он понял, что это значит. Могут быть
большие буквы. Можно один, там, один, и там, один запятая многоточие, один, ну, один запятая многоточие
пять. Это все числа до 9. Можно комбинировать и буквы, и цифры. В общем, такой синтаксис очень,
очень свободный. Надо поэкспериментировать и, в общем, поймете. Ну, или загуглить. Дальше условный
оператор. Ifs and else. В общем, он принимает на первое утверждение, на первое, в общем, первым
аргументом он принимает утверждение. Дальше, что надо делать, когда истинно, когда ложно.
Вот. Ну, в общем, что это делает? Это внутри формулы. Под корнем он передвигает все буквы от
а до ж, и если это буква а, то он ничего не пишет. А если любая другая буква, то он пишет плюс,
а дальше в любом случае пишется буква в квадрате. Потому что вот такая запись, вместо, не очень удобно
руками писать, превращается в более компактно. Ну, здесь, конечно, это может не так быть очевидно,
но когда у вас какие-то очень сложные конструкции, там много, в общем, на самом деле, так это, в общем,
по жизни замечается, когда это может быть полезно. В общем, это может быть удобно, правда. Вот. Дальше,
в общем, все опять увеличение какое-то происходит. Вот здесь такой синтаксис, я объявил переменным.
То есть, объявил то, что примена r равна единице. Вот. И дальше я расположил a вот такой точкой. Ну,
там остальные точки не так важны, чтобы места не занимать. Вот эти точки, вот я их расположил,
и дальше я... Ой, тут съехало. В общем, вот тут в цикле, тут уже существенно, потому что вот
это все, что копируют для каждой точки, не так удобно. Тем более, тут точка в трех местах
встречается. В общем, я написал там... Ну, то есть, что я написал? Для каждой p из вот этих букв он
сразу догадал. Ой, тут должно было быть е. И тут е. Ну, в общем, тут точки a, b, c, d, e. Тут
должно было быть a, t, e. И здесь последняя точка должна быть е. Вот. То есть, он рисует, заполняет
черным кружочек размера 1 point. Вот. То есть, тут подставляется p просто вместо... То есть,
вместо p подставляется буква a. Вот. И вот, а скобочка как эта точка. Помните, как мы уже делали?
Вот. Ну, и дальше... Вот. Еще один пример, когда нужно node. Если хотите что-то подписать как-то по
умному, то нужно написать node. Ну, то есть, нужно сделать узел в этой точке и как-то поменять
это лейблом. Вот. И вот здесь задается положение. То есть, можно above, below, left, right комбинировать
или даже угол написать. То есть, лейбл равно 30 двоеточек. И что вы пишете, это значит будет под
углом 30. Ну, в общем, можно прям точно, точно пересценировать, где его расположить. Как-то так.
Следующая интересная вещь, которая есть, это пути их пресечения. В общем, давайте нарисую путь ab
и обозначу то, что это путь ab. Как не странно. Ну, можно было как-то другом назвать. Дальше,
в точке d я нарисую круг через, ну, точке d. Точнее, не так. Я скажу, что d, узел d. Что такое узел d?
Это... Ну, он располагается в точке a. Он есть окружность, проходящая через b.
С центром точки a. Его надо нарисовать, это окружность. Называть эту окружность, то есть,
то, что нарисовалось, это будет путь, назвать его d. И еще пометить слева d. Сейчас покажу
следующий пример, что получится. То есть, мы задали точки a и b только. Дальше говорим,
надо в точке a провести окружность, проходящую через b. Называть эту окружность d и пометить
слева. Ну, вот он это и сделал. То же самое с точкой e. То есть, мы говорим, то, что надо провести,
надо расположить узел e. Называю это узел e. Первое, что располагаю его в точке b. Это есть окружность,
которую нужно нарисовать, которая проходит через точку a. И подписать его надо справа. Вот так он
подписывает. И дальше, в чем величие, мы называем перещение of, перещение d и e. Называю его c и ch3.
Поскольку перещение d и e 2, ну, то есть, их может быть и больше, может быть и меньше,
вот. То синтактис такой, то, что intersection of, intersection равно тигуру скопочка of каких путей,
точнее, да, тут назвали пути d, назвали пути e. Путей d и e. И как его назвать? И дальше,
поскольку тут много, тоже надо тигуру скопочка все написать. И дальше мы перечисляем все
перещения. Они там, по-моему, отсортированы сначала по x, потом по y, но это так. В общем,
экспериментальным путем выясняется, как что называется. Вот. И помимо того, что мы обозначаем
каждую точку c или ch3, но мы еще и... В общем, он там располагает узлы те самые, и мы подписываем
еще вот, например, подписать сверху, подписать снизу. Вот. Вот он нашел перещение, подписал сверху это,
подписал снизу это. И теперь к ним можно обращаться. Теперь я пройду через эти две точки путь ch3 и
назову его, как ни странно, cc3. И скажу, что он будет красным. И дальше я найду перещение ab и cc3 и
назову его f. Вот. И нашел перещение путей ab и cc3. И назвал его f. Ну и там дальше я уже не стал писать код. Там я эту точку
как-то нарисовал красненьким. Ну в общем, ей можно пользоваться. Вот. В общем, вот величина. И еще
следующий шаг. Смотрите, задача нарисовать на стороне треугольника, например. Ну как это можно
сделать? Ну еще отрезок. Ну что мы с Гееминым помним? Ну то есть мы должны как бы дойти до середины, то есть
ну понятно, что можно провести две окружности такого радиуса. Ну в общем, вот здесь вот у нас
получился на стороне треугольник. И на самом деле помните, я говорил то, что вот здесь говорил draw, да,
нарисовать круг. На самом деле можно было не рисовать его. Тогда бы круг, сами круги не нарисовались. То есть
но перо бы по ним прошло. То есть как бы пути остались, но они не были нарисованы. И точку c мы бы
нашли как прещение этих двух кругов. Надеюсь, понятно мысль. То есть если я уберу вот здесь вот этот
draw, то сами круги перестанут быть нарисованы. Но эти точки все равно я смогу их найти и отметить.
В общем, это один способ нарисовать, например, на стороне треугольника. Но следующий способ, наверное, самый короткий.
В общем, у меня есть отрезок АКБ. Все что делаю. Ну помните, я могу найти середину точки x. Я вот сначала
снизу пройду. Вот по нижнему. То есть я расположил точки A и B. Провел путь A-B. Дальше.
Смотрите, я провожу, я смещаю точку x по середине между A и B. Вот расположил точку x.
В общем, я рисую от A до x. И дальше я вот эту точку. Вот эту точку. Это как раз будет D точка.
Я что делаю? Как казалось бы, тот же самый синтаксис, который я уже говорил, он только какие-то странные 92
В общем, я беру точку x, точнее отрезок xB. Беру вот это расстояние. Можно синус считать, что угодно.
Можно считать. Все формы доступны. В общем, беру синус 60, умножаю его на 2. То есть получаю ровно это расстояние,
только оно идет в сторону точки B. Если бы я убрал 90, то у нас была бы вот эта точка вот здесь.
Но значение 90 значит еще и повернуть на угол. И это как раз то, что нам нужно. То есть мы отверяем такое расстояние в эту сторону и поворачиваем на угол 90.
Но угол может быть не только 90, может быть 45. Какого угода угол может быть. И вообще, вот это все,
то, что я написал, можно сократить в один код. То есть вот такая длинная запись для формулы.
То есть она вычисляется слева направо. То есть мы сначала берем точки A и B, берем их середину, и потом от этой середины до точки B
проводим расстояние, равное по длине. Вот. Восток это раз больше. То есть синус 60 умножить на 2. Это как бы коэффициент,
с которым надо умножить расстояние. И потом еще повернуть на 90 градусов. И по мне все проще.
Говорю то, что надо разместить точки D. Ну то есть, точнее назвать узел D вот этим всем.
Разбужить его вот здесь. Вот узел D. Можно было им сказать координат. И помимо всего, я говорю,
его нарисовать. Ну то есть заполнить красным. Intercept это размер точки. Это размер точки.
Вот она как квадратка такая. В общем, может он так и рисует. Вот. В общем, идея такая.
Например, вот картинка, которую хочу показать, картинка, которую нарисовал. Ну, если интересно,
здесь просто показываю. Ну, это решение одной издачи, там, по сравнению с прознаменением.
В общем, вот какой-то диск, он заходит, в общем, тут вот выходит всякая геометрия касательная.
Содержательный рисунок. А теперь иду к рассказу о том, как я его получил.
В общем, здесь вот, ну, сначала я немного объясню. Еще есть такой класс документов Standalone.
Он позволяет, в общем, только рисовать. Ну, в общем, он такой технический класс. Видите у меня
PDF, он ровно по картиночке. Ну вот, еще с границ 11 метров. В общем, в этом его предназначение.
Тут нажито не по-сильному. В общем, нажито за всю жизнь библиотека TIX,
которую я когда-либо использовал. Все, вот этот, кстати, вот этот калк, который позволяет считать
точки. Intersections, который позволяет, ну, калк, это точка, скобочка, доллар. Intersections,
который позволяет искать перещения. True, это вот это, проести круг через точку.
TIX и CLID, это вот этот пакет. Ну, в общем, все, что получилось. Теперь еще расскажу про сам рисунок.
Вначале я задаю два стиля. Стиль точка, что это означает? Это значит то, что надо рисовать,
заполнить черным. Цвет тоже черный, который надо рисовать. Это должен быть кружочек и
радиус 1. Помните, я не писал тогда кружочек, и если бы я беру вот сюда все кружочки,
то они бы станут кларатиками точкой. Слову кружочек беру. В общем, dot означает вот такой
набор параметров. Help означает то, что все должно быть серым. Дальше. Я ввожу два радиуса,
большой и маленький, и ввожу некий уголочек альфа. То есть, это те основные характеристики,
которые, то есть, я как бы все способы изменить картинку вынес вот в одно место. То есть,
чтобы не вводить каких-то абстрактных чисел, которые сильно меняют картинку потом, а основные
задающие картинку значения, я вот вывел в начало. Чтобы, если я хочу изменить радиус,
я мог вместо сверки напишу восьмерку. Я нажму скопировать. В общем, давайте вместо восьмерки
я сделаю пятерку. И видите, все опять перестрауло, все стало как нужно. Но картинка сильно
изменилась, но опять все точки там, где нужны. То есть, я могу менять только один параметр,
а все остальное будет оставаться. Все причечения будут там, где нужно, и, в общем, это очень
удобно. Дальше, что я делаю? Я пишу координаты, дальше перейду к параметру dot. То есть, надо,
что значит? Ну, значит, перейду к сеть параметру, чтобы нарисовать точку черную. Размещаю точку
о в центре. Размещаю точку t в вот таком месте. Минус альфа r. Ну, альфа – это вот этот уголочек.
Вот этот, видимо. А, минус альфа, да, минус альфа. То есть, вот отсюда, вот сюда он отсчитывается
в 155 градусов. То есть, если я сделаю 130, например, то он станет куда, вот видите, он стал куда меньше.
Корзинка перестала быть такой красивой еще, говоря. Вот, в общем, так не надо делать, наверное.
В общем, могу там 170 показать. Это я вот делаю больше. Видите, опять, все как нужно расположилось,
но не так приятно выглядит, потому что 155 – это подобранное значение. Вот, хорошо. Размещаю t вот
здесь, и t вот здесь. Видите, тут вот все работает легко. То есть, я на расстоянии r plus r. Ну, вот так
пишу. r plus r. Дальше. Называю путь. Называю звезда. В точке o рисую круг радиус mr. Это звезда.
И этот путь называется звезда. И планеты называю этот путь планетой. И рисую его в точке p. И радиус
mr. Вот. Дальше. В общем, дальше я просто рисую линию, соединяющую звезду и планету o и p. Вот. Дальше.
Дальше я прожжу касательную. Называю этот путь касательной. Прожжу ее пунктирной. И вот этот
100pt, 100pt – это я просто задал размер, как бы. То есть, что тут произошло? Я пришел от t к точке p.
Ну, помните, как я говорил, пришел от точки t, ну, к точке x. А от t точки p вернулся на 90 градусов
и прошел расстояние 100pt. То есть, тут я задал конкретное расстояние points. Поэтому это не в
процентах, а какое-то расстояние. Потом, в общем, от этой точки иду к точке t. Иду к точке,
расположенной, ну, тут уже плюс 90. То есть, он отсчитал свои 100pt и вернулся на 90 градусов.
Дальше я называю путь путь, потому что это путь прохождения планеты. Тоже пунктирный. Он
начинается в точке p и заканчивает опять относительно позиционирование и плюс. И я тут
считаю, видите, 2.2 умножить на 0r. Ну, то есть, ой, что-то он скомпилировал как r. В общем,
2.2 умножить на, то есть, на самом деле, 0r это можно было произвинить на 0.r. Вот. Но я тут
хотел почему-то, на какую сторону, в общем, так мне было удобнее. То есть, как бы в ту сторону на r,
на расстоянии 2.2. Ну, 2.2 умножить на r. Дальше я называю intersection of касательный путь
планеты. Вот эта селенькая точка. Называю ее ti. Не помню, почему. Вот. И дальше, видите, note help
at ti. Вот. Help. И она вот становится вот в тот самый стиль help. И она вот становится вот такой
селенькой точкой. Дальше я... Дальше я взмещаю точку и называю ее pr0path. Это, ну,
в общем, так называл. Точки могут называться как угодно. Как угодно длинными. Это все, в общем,
доступно. И вот, располагая ее, вот, как раз, то есть, это вот эта точка. Ну, то есть, это
прегуляр из 0 на путь. Из o на путь. Вот. Это прегуляр из p. То есть, я беру точку планета. Вот эта ti.
И, ну, в общем, я пускаю определенного. Но я уже рассказывал о чём-то синтакте. Я его сам только недавно
узнал. То есть, получается, это же можно было бы сделать и вот. Заодно проверим. Ну да. То есть,
надо вертикальную линию через o. То есть, вертикальная линия... Да, вот. Видите? То есть,
вот точка o, вот точка p. То есть, я говорю, вертикальная линия, проходящая через o,
и горизонтальная линия, проходящая через планету. И вот они здесь пересекаются.
Дальше я рисую от 0 до... от o до этой точки. И тут, в этой точке, в этой точке, точнее вот,
после этого перехода, я располагаю узел и говорю, что находится midway. Что значит? Это значит,
что надо располагать посередине последнего перехода. Вот. Ну и дальше вот, то самое label.
Write b. В общем, так я помещаю вот это пройденное расстояние. То есть, так я помещаю вот этот
отрезок. То есть, я говорю, идти из 0 в эту точку и параллельно на серединке, ну, то есть,
и параллельно, говорю, midway, то есть, посередине пути пометить точка b справа. Вот. Дальше помещаю
прямой угол. Вот этот прямой угол помещаю. Дальше помещаю прямой угол вот этот. Дальше помещаю
просто угол, вот видите. Да, вот надо написать mark, чтобы он пометился. Но он пустой. То есть,
если напишу, например, обещанное s, видите, он такой вот волнистый пометился. В общем,
он такой волнистый пометился. Но тут не нужно было, чтобы он хоть как-то помещался. Вот поэтому
просто искал mark. То есть, чтобы было видно. Все, наверное, если уберу mark, ничего не изменится.
Вот. Дальше я подписываю тугл бета. Дальше я рисую, видите, опять везде help, чтобы такое было
серенькое. И тут начинается. Я рисую от точки t, то есть, здесь я вот так захотел пометить
расстояние. Может быть, можно как-то модернизировать этот способ, но я не придумал. В общем, что тут
делаю? Я от точки t, к точке касания провожу, видите, вверх на расстоянии 6, прямую просто,
и от точки o прохожу вверх на расстоянии 3 прямую. То есть, просто вот как от руки рисую прямую
вверх. И вот от точки p и ti рисую прямую вниз. Дальше... Дальше тут немного сложный кусочек.
Я говорю... Ну, я начинаю путь. Дальше говорю звепременные локально. Это такой синтаксис let p1 и p2,
in. Как помните, был для цикла, но тут вот как бы, в общем, не цикл, а такой синтаксис. Вот. Дальше
я начинаю рисовать. Ну, говорю draw. Помните, лотех? Что вот здесь написано? Лотех. Трелотех.
Вот этот скейл за все. Это просто стрелочки. Это стрелочка лотех. И дальше у него параметр скейл
полтора. То есть, это стрелочка лотех увеличена в полтора. Слева и стрелочка справа. То есть,
вот это чтобы эти были две стрелочки. Дальше прохожу... Дальше вот точки p1. Я это не рассказывал,
знаете, можно... То есть, когда я так называю p1, и тут именно обязательно синтаксис. Если
хотите знать точку, то обязательно говорите именно p. Дальше можно p1, p2. В смысле можно
вместо 1 и 2 в фигурных скобочках написать название. Вот. Дальше его использовать. Но обязательно
в начале синтаксис. Дальше я беру координаты x второй точки, ставлю в координату x точки,
а вторая координата единица. Ну и вот, в общем, вот такой... Ну вот так. То есть,
я беру иксовый координат и прошу прямую. И опять-таки говорю о посередине этого пути,
который только что прошел. Сейчас я немного поясню. Еще раз. Вот эту штуку можно было заменить.
Сейчас. Вот эту всю штуку можно заменить на... Просто вот так вот. И вот видите,
просто стрелочки стали такими. Здесь я ради красоты стрелочек это сделал, в общем,
и побольше, и стилил от тех. Вот. В общем, вот так вот я помещаю этот r-штик. Ну,
аналогично нормально, кажется, их. Наверное, везде, наверное, мне было лучше вынести вот этот
вот весь стиль. Помните, как я... Ну, вот давайте я прямо сейчас это сделаю. То есть, я вот найду
его. А, нет, ну так это просто сделать. А, нет, все придумал. В общем, когда она справа,
я заменю это на правую стрелочку. Когда она слева, я заменю ее на левую стрелочку.
И в самом начале, где-то вот здесь, я скажу то, что... Вот. Вот, все, видите? Короче, я тоже...
Главное, это уметь исправить свои ошибки. То есть, я вместо того, чтобы копить кучу раз,
я в общем так не делал, а теперь сделал. Смотрите, код куда более читаемый. И, ну вот, я тут задал ему,
что все стрелочки должны быть в лотех и размер. А теперь, если я хочу, например, сделать чуть-чуть
поменьше, то я только в одном месте изменяю. Не, все дружно становятся чуть меньше. Видите,
как все замечательно. Вот мы, вот. Вот мы с вами. И выясним все. Вот. Так. В общем, мы
остановились вот здесь. Вот. Так. Теперь стрелочка направо из планеты. Ну, просто тут как-то я хотел
поменить радиус. Да? То есть, вот. Стрелочка направо. По центру подписываю радиус. Это я помещаю
радиус. Ну, вот 160р. В общем, 160 градусов. Вот 160 градусов. Также помещаю большой радиус. Это вот здесь помещаю.
Да. В общем, теперь это вот была вся левая часть рисунка. То есть, вот это все, вся левая часть рисунка.
Теперь вот проправочная часть рисунка. Я даже немного приближу. Что-то происходит. Ну, то есть, тут
вот примерно впечатление, как в истории было. Неважно. Что делаю? Я размещаю точку выхода. Ну,
просто говорю. Альфа минус 180. То есть, это. То есть, помните, там угол альфы вот этот был. В общем,
как раз получается противоположная точка. Альфа минус 180. Ровно эта точка. Ну, и радиусом r
плюс r. Это получается вот эта точка. Вот эта точка. То есть, она противоположна вот этой точке.
По углу. То есть, этот угол. Ну да. Дальше называю этот путь planet out. Серая. Прерывистая. Кружок.
Радиус r. Дальше опять вот. Let p1 pout, p2 p, p3 ti. Ну, в общем, здесь просто вот такая геометрия.
x1 плюс x2 минус x3. Это. Я располагаю вот эту точку. Видимо. А нет, вот эту точку. Видимо. Не знаю.
Какую-то из этих точек я располагаю просто, в общем. Ну, по координатам я располагаю. То есть,
я выражаю через координаты других точек. Да. То есть, мне нужно было, чтобы вот это расстояние r
было равно на одно расстояние r. И ровно этого я здесь и добиваюсь. То есть, что такое r? Это расстояние
между точкой p и ti. Вот. То есть, p ti это 2 и 3. То есть, экзамен с x3. И проявляю точки x1. То есть,
к точке pout. В общем, получаю вот эту точку. А y беру такой же, ну, у них всех был. Вот. И получаю ровно
эту точку. Вот. Дальше p in. Это planet внутри. Это, в общем, я просто вот такой синтез с минус 1. То есть,
я как бы за точку ti2 в другую сторону от pout на расстоянии 1. В общем, такой рисунок. Дальше
называю этот путь планеты внутреннее. В общем, вот такое рисую. Да. То есть, вот эта точка, ой,
эта точка, она как раз не лежит на окружности. У нее смысл было, чтобы ровно r3 было. В общем,
добился вот в этих учтениях. Назвал. Вот я назвал этот кружочек внутри. Это планета внутри.
И дальше что делаю? В общем, я расположил. Ну, я вот эти прямые рисую. То есть, я рисую прямую.
То есть, я из точки вычитаю точку. То есть, я как бы иду вот в эту сторону на 92.3. То есть,
на 90 градусов. Ну, минус. То есть, 90 градусов это вот сюда вот. И 3 это длина. Только минус,
значит это вниз. В общем, так я получаю точку. Вот так вот рисую. Ну, и дальше вот в конце это
я провожу. Сначала помещаю r' и r'. И дальше вот у нижней стрелки. Тут я как бы применяю,
то есть, то же самое x1-x2 и 0. Это какая-то высота. Ну, точнее вот, видите, плюс относительное
положение. То есть, в общем, тут я выбрал какую-то высоту y2-2.6 сантиметров. Просто вот это на глаз
убрал. А тут, чтобы не дублировать это, я пишу относительное положение. Вот. Это, чтобы не
дублировать 2.6 сантиметров, которые выбраны были на глаз. И дальше здесь я два раза подписал. И
сверху у Tao. И снизу просто обычным текстом. Вот. Ну, и на самом деле вот такое. Ну, то есть,
это нужно было для решения знача рисунок. И рисунок вроде сложный. То есть, я не знаю,
где его можно аккуратно нарисовать. Ну, то есть, может есть какие-то. Вот. Но, может тексты выглядят
сложным. Но я так, просто немного принорвишно рисовать. Я минут за 15 или даже меньше рисовал.
Наверное, минут за 10. В общем, на самом деле, синтаксис, если чуть-чуть попрактиковаться,
порисовать, очень воспривыкается, что-то для себя запоминается. И вот это реально на ходу
уберется. То есть, это как свободный поток. То есть, расположить точку здесь, взять пересечение. Вот.
То есть, момент, что я время-тремя лезу в Google за синтаксисом. Но... В общем, время-тремя я ложу
синтаксисом. Но в этом как бы ничего такого нет. Такова жизнь. Вот. И еще я хотел показать,
перед тем, как я совсем закончу. Да. В общем, вот книжка. Это просто прекрасная книжка. И, не знаю,
ее Кристоф Нодону, Кирилю Тенко просто... Ну да, в общем, понятно. Кафедра математического анализа.
В общем, это прекрасная книжка. И тут очень-очень подробно и очень, на самом деле, ну,
в общем, честно расписано. В общем, расписано все. Тут еще с примерами, все с синтаксисом. Все как бы
везде в примерах вы можете найти все основное. И на самом деле очень легко найти именно какие-то
основные вопросы. Но если именно читать весь текст, то внутри очень рассказано очень много полезных
фишечек маленьких. Как там что-то делать. Вот. Ну, я сейчас просто пролистаю просто. Ну, вот то,
что я показывал. И тут разбираться какие-то конкретные примеры. И вот так вот шаг за шагом
все пишется, показывается. Ну, в общем, реально очень, очень просто. Вот. То есть очень, по ней
очень легко ориентироваться. И я ее реально использую как настольную книжку. И, ну, в общем, очень классная
фишка. Я ее в чат скинул, конечно. Вот. И, в общем, тикс позволяет рисовать ну, прям очень какие-то
крутые картинки. И можно в интернете погуглить там типа тикс картинки. Ну, тикс картинки. И там есть
очень много картин, которые, на первый взгляд, кажутся очень сложными. Но, во-первых, код у них там
занимается срочек 100 всего лишь. Вот. И если его почитать, видно, что он совсем простой и синтаксис
даже. Ну, в общем, там просто вот это все комбинирование отцы. Ну, то есть, в общем,
простым гуглингом почти любая картинка рисуется. Ну, в общем, ну, как-то так. Вот. В общем, основной
посыл то, что в нем очень легко считать, делать модифицирующиеся картинки, которые можно
создать параметрами. Вот. И, ну да, вот этот синтаксис, например, который говорил про проектирование.
Вот. Там вот еще такие вот рисунки. Что-то такое интересное. В общем, я думаю, на этом все про тикс,
но еще небольшой комментарий. Есть pgfplots. Это свойство, это, в общем, такая вещь,
чтобы рисовать графики. И про нее, как бы, в двух словах не скажешь. Потому что, ну, то есть,
это потратить было еще минут 20 нашего времени. Но я думаю, в общем, если вам интересно, можете
погуглить pgfplots. Я там ссылочку тоже в чат скину. В общем, она позволит рисовать именно графики.
И, на самом деле, там тоже, в общем, синтаксис там немного заимствованный. Ну, то есть, немного
схожий с тиксом. И графики получаются очень хорошие. Ну, то есть, очень легко их рисовать,
очень подстраивать. Вот, на самом деле. Вот теперь все, и я передаю слово дальше.
Ну, во-первых, стоит отметить, что мы далеко не сел в множестве тех,
кто смогли покрыть четыре занятия. Поскольку некоторые фишки, которые представляют с
некоторыми пакетами, они при всем там, насколько они хороши и удобные, очень узконаправленные,
решают какую-то конкретную задачу. И если у вас задача не возникнет, то вы, скорее всего,
никогда просто не узнаете об этом пакете. Если так, то зачем про него слушать? Вот. Ну, вот стоит
хотя бы несколько из них упомянуть. Есть такая штука multicoll, чтобы описать, ну, знаете, как журналик
ланта, текст несколько столбцов на одной странице. Там вот все управляется. Есть пакет color, чтобы
всякие RGB-шные цвета подключать в документы. Если вам требуется как-то тонко настроить,
какой у вас будет шрифт, то вот вам сюда. Есть пакет talkloft, который здорово настраивает
содержание. Визуализируется то, как отрисовываются всякие символы перед номерацией секций. Вот все
вот это управляется talkloft. Ну, возможно, опять же есть и лернативы, но это очень хороший вариант.
Есть пакет для написания кода или алгоритмов. Ну, в общем, чего-то при информатике. Есть пакет
listings, который именно что визуализирует всякий код, подчеркнул, не комплинирует, а именно
визуализирует его написание. Возможно, это для ключевые слова. Это может быть полезно,
если вы конспектируете какой-то там курс по языку программирования или там пишете что-то
подобное. И есть пакет algorithm2e. Это штука для написания именно алгоритмов, для их описания
информатического, а не кода. Ну, там такой довольно общий псевдокод, который в общем понятие там
можно посчитать, какие в нем есть поддерживаемые ключевые слова, может создавать свои. Тоже вещь
удобная, сам периодически пользуюсь. И пакет rapfig, которым вообще я планирую рассказать когда-нибудь,
но как-то вот в общем дело не дошло, но эта штука для того, чтобы размещать всякие картинки,
таблицы и прочие плавающие объекты, не там где-то отдаленное текст в своем окружении,
типа центр или чего-то еще. А прям посреди текста я задаю конкретные правила обтекания,
слева-справа, на нужном расстоянии, ну, примерно как в Word, но по-человечески,
чтобы ничего не ломалось. Не необходимости не возникало, но вообще говоря, возникнуть можно.
Ну, и еще стоит отметить, что действительно очень много людей пользуются латехом всегда,
если что-то непонятно, и по крайней мере есть понимание, что именно непонятно, и что именно
стоит гуглить, то скорее всего вы это найдете, даже если это будет какой-то форум с индустрией
2008 года, но он точно будет, если это решение, которое нужно вам на один раз, скорее всего оно
сработает. Не всегда стоит прям внимательно вчитываться в каждую строчку кода, которую вы
копируете, если это какая-то конкретная команда, которая нужна для конкретного вопроса, ну,
в образовательных целях, но вот поэтому не стоит бояться, надо много гуглить, если что-то
не получается, скорее всего что-нибудь найдется. Прям больших книг, в которых было бы все на свете,
по тех, у я, ну, как бы не знаю, есть старые мануалы, которых тоже было бы не актуального написано,
и которые тоже неизбежно скатываются в то, что там обозревают возможности, которые очень редко
кому-то потребоваться, поэтому, мне кажется, тех удобнее изучать, когда у тебя возникает вопрос,
и ты ищешь на него ответ. И, думаю, на этом оправданно закончить. Вот, если вопросов ни у кого
не осталось, хотя, наверное, по этой части вопросов быть не должно было, то предлагаю
на этом закончить. Всем спасибо.
