Познакомились с понятием исключений, обработкой исключений
C++, грубо говоря, какой новый способ обработки ошибок
и способ сообщения о них предоставляет C++ по сравнению
с его предшественниками языком C.
Прежде чем двигаться дальше, давайте разберем исторический
анекдот.
Иногда, точнее раньше, я довольно часто у студентов
видел следующий код, соответственно, раз он встречается довольно
часто, то давайте его обсудим на предмет того, почему так
писать не стоит, ну и в чем тут проблема.
Смотрите, что здесь происходит.
Вот, допустим, кто-то написал следующий код, он написал
функцию f, дальше вызывает функцию g, ну и по всей видимости
он считает, что функция g, она какая-то потенциально
опасная.
Ну а раз она потенциально опасная, то соответственно
нужно, и при этом я не хочу, чтобы, и при этом я хочу
эту ошибку как-то, не знаю, обработать, как-то сообщить
о том, что функция g потенциально может брать исключение,
и соответственно, для этого я оборачиваю вызов функции
g в блок try, дальше, ну так как я потенциально не знаю,
что я хочу поймать, точнее, что может выбросить функцию
g, ну и вообще, в принципе, мне не важно, что выбросило
функцию g, мне хочется эту ошибку просто как-то обработать
и дальше выбросить ее дальше.
В целом, этот код плюс-минус бесполезен.
Почему?
Потому что о чем говорит этот код?
Этот код говорит о том, что я не знаю, как находясь
внутри функции f, исправить ошибку, или когда я нахожусь
внутри функции f, и если при этом функции g, что-то пошло
не так, то никаких дополнительных действий, например, по очистке
памяти, по воздействию каких-то ресурсов обратным
перспективным системе, мне делать не нужно.
То есть, в принципе, функция f тут явно сообщает о том,
что в целом исправить ошибку я не могу, и каких-то
дополнительных действий в случае возникновения ошибки
делать мне не нужно.
Но чтобы это сказать, этот код является довольно-таки
избыточным.
Почему?
Потому что если мы просто-напросто опустим все блоки try и catch,
то мы получим ровно тот же самый результат.
То есть, если функция f дойдет до вызова функции g, и при
вызове функции g возникнет исключение, то в случае,
если f это исключение не обрабатывает, то исключение
просто-напросто вылетает из функции f.
То есть, мы получаем ровно тот же самый эффект, что
и на слайде выше.
Понятно?
Поэтому просто ловить исключение для того, чтобы
его поймать, так делать не нужно.
Исключение все-таки нужно ловить только тогда, когда
вы знаете, как исправить ошибку, либо тогда, когда
вам действительно нужно сделать какие-то дополнительные
действия для того, чтобы как-то исключение в дальнейшем
либо обработать, либо сделать так, чтобы избежать утечек
памяти и того подобного.
В экстремальном случае этого кейса я видел вот такой
пример.
Смотрите, функция f бросает исключение, но по какой-то
причине кому-то почему-то очень хочется заключить
этот throw x в блок try, дальше поймать его в киче и бросить
дальше.
Грубо говоря, я сгенерировал исключение, дальше его обработал
и бросил дальше.
Ну, смотрите, если вы хотите выбросить исключение, то
пожалуйста, просто его бросайте.
Не нужно никаким образом дополнительно обрабатывать
функции, которая сама генерировал исключение.
Если функция сама генерировала исключение, значит, что
она сделала всё что могла и исключение теперь
и всё, что остается ей отлететь дальше.
Этот код бесполезен уже полностью.
Почему?
Потому что, по сути, вы бросаете исключение, подбрасываете
его вверх, ловите снова и дальше бросаете уже туда,
куда надо.
Такой код абсолютно точно является не Invest츠нным, would
Если вы хотите бросить исключение, то просто его
бросайте.
Если вы не знаете, как обработать исключение или вам не
нужно делать никаких дополнительных действий по обработке
исключения, который потенциально может выбрать и другая функция, то не пишите
никакого обработчика. То есть пусть исключение летит дальше, пусть его
обрабатывает следующая функция, которая потенциально сможет это сделать.
Окей? Хорошо. Ну давайте тогда перейдем
к продолжению разговора про исключение. И сегодня у нас план примерно следующий.
Ну вот мы в прошлый раз познакомились с таким базовыми основами обработки
исключений, ну вообще работы с исключениями. Вот сегодня давайте поговорим про то,
как исключения взаимодействуют с другими аспектами языка C++, ну в частности там с
конструкторами, деструкторами, со стандартной билетекой. Ну и вообще говоря,
вновь вернемся к вопросу, а вот каким образом нам жить вот в этом мире полным
исключений. То есть как можно ли на что-то полагаться, можно ли полагаться на то,
что что-то ошибок вызывать не будет, можно ли полагаться на то, что если ошибка
вдруг возникла, то можно будет корректно продолжить работу и так далее.
Начнем с исключения в конструкторах и деструкторах. Вот давайте посмотрим на
следующий пример. У меня есть некоторый класс A, у которого есть два поля.
Поле-вектор и поле-обычный указатель, который потенциально может указывать на
динамическую область памяти. Ну и действительно смотрим на конструктор, в
конструкторе у меня создается вектор из 100 элементов и выделяется динамическая
память, которая сохраняется в указатель PTR. Ну и даже по какой-то причине в
конструкторе мне нужно вызвать некоторую функцию, в которой потенциально можно
бросить исключение. Ну не знаю, допустим она там по-своему как-то выделяет память,
или допустим она открывает какое-то соединение по сети, но и соответственно
понятное дело, что это может там закончиться, а потенциально это может
закончиться неуспехом, что в итоге приведет к выбросу исключения. Вот.
Ну деструктор при этом у меня написан корректно, то есть в деструкторе я просто
насущаю ресурс, который выделил в конструкторе. Что тут может пойти не так? Как
вы думаете? Ну да, действительно, смотрите. Действительно, я вызываю
конструктор А. В конструкторе А происходит создание вектора, то есть у меня был
создан вектор из 100 элементов, дальше я выделал память с помощью Нью Инс,
сохранил ее в указатель PTR, дальше вызываю функцию F, и в общем произошло исключение.
И тут возникает вопрос. С одной стороны, с одной стороны у меня есть нормально
написанный деструктор, mars, он приведет, ну еслиager,
в итоге будет, вызвание деструктор, все приведет к тому, что вектор будет
уничтожен, и память будет очищена. Так у меня есть строчка deletePtr.
С другой стороны, как будто бы деструктор у меня не завершил работу корректно.
То есть я попытался вызвать деструктор..ой, конструктор, то есть я
создал, попытался создать объект А, но вот коплавка его произошла некорректно,
Вот если создание объекта А произошло некорректно,
то могу ли я полагаться на то, что для объекта А
будет вызван деструктор, или не могу?
Вот как вы думаете? Представьте себе следующую ситуацию.
Даже абстрагируясь вот этого примера,
я решил создать какой-то объект.
Объект типа А. Но по какой-то причине
при создании объекта А
произошла ошибка.
Как вы думаете, имеет ли право компилятор
вызвать деструктор для этого объекта?
Нет. А почему?
Угу.
Да, смотрите. Если во время создания объекта А
было вызвано исключение,
то понятное дело, что, скорее всего,
объект был создан не полностью.
А если объект был создан не полностью,
то, значит, возможно, у него как-то неправильно
проницелизировано поля.
То есть объект находится, возможно, в несогласованном состоянии.
Но раз объект находится в несогласованном состоянии,
то и деструктор для него вызывать некорректно.
Почему? Потому что
естественно деструктор полагает,
то, что все поля у него созданы корректно,
что вся память выделлена и так далее.
Но если в конструкторе вызванное исключение,
то не все поля могут быть корректным образом проницелизированы.
Поэтому не все поля, а там нужно удалять
ими таким образом, каким прописано в деструкторе.
Согласны?
Что делать?
Решений. Да, соответственно, проблема
что проект glam not move, то объект
считается создан он, а раз объект не считается
создан, то и для него
деструктора вызвана не будет.
Что делать?
Потенциальным решением может стать
использование try-catch блока.
Если я понимаю, что функция f
потенциально может бросить исключение,
я могу просто функцию f заключить в блок try
и дальше написать соответствующий блок catch,
который ловит произвольные исключения.
И в этом блоке catch,
так как я понимаю, что создание a
не может завершиться корректно,
я просто уничтожаю ptr и бросаю исключение дальше.
Обратите внимание, что
для вектора
для вектора мне деструктор вызывать
не обязательно.
Почему?
Потому что если
уже был создан какой-то объект, у которого уже есть
деструктор, то есть, смотрите, в данном контексте
у меня вектор уже создан корректно.
То есть вектор – это уже существующий объект, который есть где-то в памяти.
Поэтому
для него деструктора вызывать явно не нужно,
деструктор для него будет вызван автоматически.
Все поля, которые уже были
созданы, если эти поля являются полями классами,
то для каждого из таких
полей будет вызван корректно деструктор.
В этом заключается еще одно преимущество
использования RAI классов
по сравнению с использованием обычных вторых указателей.
Грубо говоря,
если мы вместо динамического выделения массива
или динамического выделения памяти используем вектор
или используем умные указатели,
unique ptr, char ptr, то
за очищение отвечают именно эти классы,
и нам об этом не нужно думать даже в контексте
исключений.
Соответственно, с вектором все будет нормально, объект вектора
создан корректно, значит, для него корректно
будет вызван деструктор.
Ну и соответственно, пример.
Правильнее всего данный
класс был бы написать вот так,
надо написать вектор, дальше
написать unique ptr, который указывает лишь на единичный
элемент int,
ну и создать вектор из 100 элементов,
создать указатель на
нулевой элемент. Даже если f бросит
исключение, то
корректно вызовется деструктор
для v, корректно вызовется деструктор для ptr,
и кроме того, нам не нужно прописывать
деструкторы, конструкторы, конструкторы
копирования, конструкции перемещения, все будет
создано автоматически.
Вот, кстати, это является прекрасной демонстрацией
правила нуля. То есть мы написали
целиково полностью,
которая зависит от
классов, которые поддерживают идиом ураи,
то есть на основе вектора, на основе unique ptr,
и нам не пришлось писать ни конструкторов,
ни деструкторов. И кроме того, нам
практически не нужно задумывать об исключениях,
почему? Потому что если вдруг исключение возникнет,
то объекты корректно уничтожатся, ну согласно
их вызовам деструкторов. Понятно?
Так.
Давайте посмотрим на другой
пример. Ну хорошо, разобрали исключения
в конструкторах. То есть если резюмировать исключения
в конструкторах, ну если мы пишем,
если мы все реализуем на
самостоятельном выделении ресурсов,
то нам необходимо помнить о проблеме
вызова, точнее о проблеме
возникновения исключения в конструкторах, и нам нужно
в этой ситуации обрабатывать самостоятельно.
Теперь представьте себе, что мы пишем
деструктор.
Как вы думаете, что
произойдет, если
в деструкторе в какой-то момент
произойдет исключение?
Ну вот представьте себе,
что у меня есть тот же самый класс A,
и класс A по какой-то причине
вызывает, ну перед тем как освободить
память, конструктор вызывает
некоторую опасную функцию F.
Ну я думаю, вы понимаете, что если
конструктор завершится некорректно, то, соответственно,
все те операции, которые следуют в конце,
то есть по очистке памяти и так далее, они
выполнены не будут, поэтому возникнет утечка памяти.
Ну соответственно, по этой причине
я вызов функции, помещаю второй catch block,
вызываю delete, пробрасываю исключение дальше.
Ну при этом, как и раньше, если у меня есть
какие-то поля, которые относятся к объектам
классом, то есть если у меня есть
вектор, то для вектора деструктор будет вызван
корректно, будет вызван автоматически, поэтому
с ним ничего делать не нужно.
Вот. Но вот с деструкторами,
в контексте деструкторов,
исключение приводит
к еще одной
не очень приятной и не очень очевидной проблеме.
Давайте о ней поговорим.
Дело в том, ну давайте
посмотрим на пример и попробуем
понять, а что тут вообще происходит. Вот признай
себе, что у меня есть некоторая функция H,
есть
класс A, у которого
потенциально опасный деструктор. Ну представьте
себе, что класс A написан ровно так, как написано
на предыдущем слайде. То есть у него есть деструктор,
который потенциально может бросить исключение.
Вот. Соответственно, я написал
класс A, деструктор может бросить исключение
и дальше, после того, как я создал
A, вызываю функцию
же, которая тоже может бросить исключение.
Можете ли вы предложить сценарий,
при котором
произойдет большая проблема?
Еще раз?
Не поймем, где
ошибка.
Так, окей, да, ну
есть такая проблема. Действительно, если мы
вызываем функцию H, ну представьте себе,
что мы вызываем функцию H,
функцию H помещаем в
try sketchBlock
sketchBlock
Вот.
Потенциально мы не можем понять,
а где возникла проблема.
Есть объект A, есть вызов
функции же, ну и тут
какие-то еще
операторы.
Действительно,
если мы неправильно пишем,
если мы пишем код как-то не так, то
в целом мы не можем понять, где у нас
возникла ошибка. То есть ошибка возникла в классе A,
ошибка возникла в классе G.
В целом, если мы
грамотно проектируем нашу программу,
то мы все-таки для каждой ошибки пишем свой
тип ошибки, свой класс ошибки.
То есть те ошибки, которые
бросает класс A, они относят
к одному типу, те ошибки, которые бросает
G, относятся к другому типу.
В целом, с этой проблемой
мы как-то победить можем.
Надо, например, для каждого из типов ошибки
завести свой собственный класс и, соответственно,
ловить соответствующий класс в блоке catch.
И мы можем проверять, какая последовательность
вызовов привела к данной ошибке.
Проблема есть, но на самом деле
это не самое страшное, что может произойти.
Давайте немного подскажу
и скажу следующее.
Проблема произойдет тогда,
когда исключение будет
бросаться из функции G.
Давайте подумаем, что будет происходить,
если вдруг в какой-то момент
из функции G вылетело исключение.
Да, смотрите, что произойдет.
Из функции G вылетает исключение.
То есть тут генерируется какое-то исключение.
Что происходит, когда
функция генерирует исключение?
Функция совершает работу и
вызываются деструкторы для всех элементов,
которые находятся в этой функции.
Согласны?
То есть создание, точнее,
генерация исключения здесь приводит к тому,
что у меня будет вызван деструктор A.
То есть генерируется исключение из G,
потом
вызывается
деструктор A.
А что произойдет дальше?
Нет, ну а дальше
как устроен деструктор A?
Мы с вами сказали, что деструктор A
потенциально может бросить исключение.
Теперь на третьем шаге
происходит
исключение
в деструкторе A.
То есть теперь у меня двойная проблема.
И G вылетело исключение,
и при вызове деструктора A
тоже вылетело исключение.
То есть что получается?
Получается, что из функции H
вылетело сразу два исключения.
Понятно?
Одно из исключений появилось
изначально, когда я вызывал функцию G,
а второе исключение появилось как
следствие вызова деструктора A.
То есть вот вызвался деструктор A,
допустим в функции F тоже что-то пошло не так,
и соответственно вызвалось исключение.
То есть возникла проблема
двойного исключения,
то есть функция завершилась,
и при этом из этой функции вылетело два исключения.
Значит,
ну вот.
То есть G бросает исключение, начинается раскручивание стека,
вызывается диструктор для A,
и в нем снова бросается исключение.
В итоге из функции H
вылетает сразу два исключения.
По стандарту языка C++
если из функции,
если в функцию покидает сразу несколько исключений,
то это приводит к
то это приводит к неопределенному поведению. Это неопределенное поведение может возникнуть только в том случае, если у вас есть функция,
внутри которой может возникнуть исключение, и при этом эта функция создает объекты, которые потенциально в деструкторе могут бросить исключение.
То есть исключение в деструкторах потенциально приводит к неопределенному поведению в том смысле, что если вдруг деструктор был вызван в результате раскрутки стека,
то в результате совершения какой-то другой ошибки, то к вызывающую функцию покинут сразу несколько исключений.
Поэтому с исключением в деструкторах мы поступаем очень просто. Мы просто-напросто не допускаем исключений в деструкторах.
Основное правило такое. Пишите деструктор так, чтобы из него не вылетало никаких исключений.
Это золотой стандарт программирования на C++.
То есть даже если деструктор потенциально вызывает какие-то опасные функции, то постарайтесь сделать все возможное, чтобы эти исключения никак не покидали сам деструктор.
Либо обработайте исключения, либо напишите сообщение, что деструктор потенциально завершился неуспешно и так далее.
У нас же должно быть только так, чтобы у нас одновременно не могли бросить два исключения, но это не гарантирует, что у нас и там, и там одновременно не брать.
В плане, оно может броситься в А, но если мы так можем построить программу, то если оно бросилось в А, то оно дальше не бросится, и наоборот.
То есть это как-бы излишне интересно.
Я сейчас не совсем понял идею, то есть ваш предложение...
Тут?
Да, окей, я понял, о чем вы говорите, смотрите.
Во-первых, деструктор А и функции G могут бросить разные исключения.
То есть они могут сигнализировать о разных ошибках, ну и естественно хотелось бы, чтобы и первая и вторая ошибка в итоге дошли до конечного пользователя.
Значит, так сделать нельзя просто потому, что C++ не поддерживает несколько летящих исключений из одной функции.
То, про что вы говорите, на самом деле, оно более близко к истине о том, как это может быть устроено в C++.
Давайте чуть подробнее расскажу.
На самом деле, действительно, деструктор может быть более гибкий.
Вот в каком смысле.
В C++ есть специальная функция std.uncode.exceptions.
Эта функция возвращает текущее количество с генерированных исключений.
Грубо говоря, если у вас в данный момент в программе летит сразу три исключения.
Во-первых, непонятно, как вы так написали программу.
В общем, так или иначе.
Допустим, в какой-то момент у вас летит три исключения.
И в деструкторе А вы можете это проверить.
Допустим, вы можете проверить.
Если std.uncode.exceptions больше нуля,
то в этом случае вы говорите, что генерировать исключения нельзя.
Иначе, если никаких исключений в этот момент не сгенерированы, то можно бросить исключения.
В целом, можно написать вот так.
Сразу я говорю, что то, как я написал здесь, опять же, не очень корректно.
То есть, я рекомендую зайти на страницу.
Давайте еще раз напишу.
Обратите внимание на последний символ exception.
Потому что есть функция std.uncode.exceptions, а есть std.uncode.exceptions.
Вот std.uncode.exceptions.
Она сейчас, по-моему, задеприкечена C++, то есть ее использовать нельзя.
Std.uncode.exceptions использовать можно и нужно.
И пример того, как правильно использовать std.uncode.exceptions, там показан.
Там может возникнуть ситуация, при которой вы вызываете функцию.
Дальше в destructor destructor вызывает другую функцию,
которая генерирует исключения. Дальше другая функция тоже генерирует исключения.
В теории может быть такое, что из нескольких разных функций летит исключение.
И поэтому получается, что исключений больше одного.
Поэтому в destructor нужно проверять.
Если destructor был вызван для функции, в которой уже сгенерируется исключение,
то бросать исключения не нужно.
Если destructor вызван в функции, которая на самом деле не сгенерирует исключения,
то исключения бросать нужно.
Как дополнительный материал, можете почитать.
Но в целом рекомендации не бросать исключений вполне на практике достаточно.
Нет. Перегрузки деструкторов в C++ нет. Деструктор всегда только один.
Такого не работает.
Но вы можете понять, происходит ли сейчас раскрутка стека или нет.
Вы можете по этой функции.
Если происходит раскрутка стека, то вы действуете одним способом.
Если не происходит, то действуете другим способом.
В теории вы можете написать clean1 и clean2.
И вызвать ту или иную функцию в зависимости от того, по какому пути вы идете.
Хорошо. В общем, исключение в деструкторах плохо.
А исключение в конструкторах норм.
Но там надо тоже думать о том, как правильно очистить память при необходимости.
Хорошо.
Ну вот, собственно, у меня есть замечание про это,
что на самом деле в C++ можно так делать.
Но об этом можно посчитать дополнительным образом.
Так, есть ли вопросы?
Окей, тогда следующий важный пункт,
про который нужно обязательно поговорить в контексте исключений,
это гарантия безопасности исключений.
Давайте начнем.
Вот, с прошлого раза, как мы стали изучать исключения,
ну, как я уже сказал, мы стали изучать исключения,
полный исключений, полный ошибок и так далее.
И вообще говоря, в этом нестабильном мире хотелось бы хоть на что-то полагаться.
Хотелось бы полагаться хоть на какие-то инварианты,
которые сохраняются даже если код написан,
ну, не то что с ошибками,
даже если в коде возникают какие-то непредвиденные обстоятельства.
И поэтому для того, чтобы формализовать понятие о безопасном коде,
формируем, например, код.
Вот.
И поэтому для того, чтобы формализовать понятие о безопасном коде,
формализовать понятие о том, на что можно полагаться,
на что нельзя полагаться,
есть такие понятия как гарантии безопасности исключений.
Причем, таких гарантий существует три.
И давайте про них, про каждую поговорим отдельно.
Всего гарантии три.
Первая из них это гарантия отсутствия исключений,
в смысле, самая простая с точки зрения понимания,
ну, и самая сложная с точки зрения оформления.
Дальше есть базовая гарантия безопасности,
есть строгая гарантия безопасности.
Давайте про каждую из них отдельно поговорим.
Ну, гарантия отсутствия исключений самая простая,
для понимания опять же, потому что
гарантия отсутствия исключений говорит том,
что вызов данной функции или вызов данной операции
не приводит к генерации исключений.
Окей?
То есть, если вы читаете, ну, в общем, для чего это нужно,
то есть вы, например, читаете документацию по языку C++,
ну, допустим, вот заходите в какую, допустим, на страницу vector,
и смотрите его отдельные операции.
На каждой странице, если вы обратите внимание, есть несколько пунктов.
Первая – это как вызывается функция, вторая – что она возвращает.
Дальше комплексити, то есть какова сложность данной операции.
Плюс дополнительно есть еще такой подраздел как exception safety,
то есть безопасность относительно исключений.
Одна из гарантий безопасности, которую вы можете встретить,
это гарантия отсутствия исключений.
Гарантия отсутствия исключений, еще раз повторю,
это гарантия, что данная операция никогда не приводит к выбросу исключения.
То есть данная операция всегда завершается корректно,
на данную операцию, вы можете полагать, она всегда работает как часы.
Например, операция стека, точнее, операция запроса размеров в стеке,
она всегда завершается корректно. Почему?
Потому что это просто операция доступа к полю.
То есть она просто возвращает значение поля size,
и, естественно, она никогда не приводит к ошибке.
В то же время, операция копирования, то есть в то же время конструктор копирования,
естественно, не может вам дать гарантию отсутствия исключений.
Почему? Потому что копирование стека,
оно обязательно приводит к тому, что вы перевыделяете память для нового стека,
а выделение памяти – это уже как минимум повод задумываться над тем,
что операция потенциально может завершиться неуспешно.
Понятно? Окей.
Дальше. Базовая гарантия безопасности.
Что такое базовая гарантия безопасности?
Функция удовлетворяет базовой гарантии безопасности, если происходит следующее.
То есть вы вызываете операцию, и при этом, если операция представляет вам базовую гарантию безопасности,
она не гарантирует, что данная операция всегда завершится успешно.
Нет, иногда данная операция может завершиться неуспешно, в том смысле, что она может бросить исключение.
Но базовая гарантия безопасности гарантирует следующее,
что если из операции вылетело исключение,
и при этом вы это исключение обработаете,
то вы можете дальше корректно пользоваться программой.
Дальше корректно пользоваться программой означает,
структура данных осталась в корректном состоянии, то есть как бы программа тоже
осталась в корректном состоянии, то есть у вас нет ни утечек памяти, ничего такого,
но при этом в каком состоянии оказалась структура данных, вы сказать не можете.
Ну то есть, например, у вас есть какой-то класс A, и у класса A, точнее у объекта класса A,
вы вызываете метод f. Вот метод f, который потенциально бросает исключение.
Вот функция f обладает базовой гарантией безопасности, если после обработки этого исключения
вы можете дальше корректно пользоваться программой, вы можете дальше корректно пользоваться объектом A,
но при этом в каком состоянии окажется A после вызова функции f, мы сказать достоверно не можем.
Понятно? То есть A находится в каком-то корректном состоянии, но в корректном состоянии
значит, что у него соблюдаются варианты класса. Ну какие варианты класса могут быть?
Например, если мы работаем с вектором, то варианты класса – это size меньше чем capacity,
и при этом capacity содержит как раз количество выделенной памяти, а size содержит количество элементов,
которые реально находятся в векторе. Окей? То есть объект находится в согласовом состоянии,
то есть там все корректно, и может корректно продолжать пользоваться, никаких утечек памяти не произошло,
но в каком состоянии оказался, мы сказать не можем. Ну, например, если бы вектор, представьте,
у меня есть вектор, у него, допустим, изначально размер равен 10, а capacity равен 20.
Вот, я вызвал v.pushback, вот, и если бы pushback обладал только базовые гарантии безопасности,
то мы бы сказали следующее, что я могу дальше продолжить пользоваться вектором,
то есть дальше делать в него pushback, делать size и так далее.
Да, ну представьте, что тут вылетело исключение.
Но при этом сказать, какой у него в данный момент размер, или сказать,
какой у него в данный момент capacity, я не могу. Окей? Нормально?
Вот, это базовая гарантия безопасности. То есть программой можно дальше пользоваться,
программа может дальше работать, но вот перед тем, как дальше работать, нужно проверить,
что же там на самом деле происходит, то есть какой размер вектора, какой там capacity,
какие там элементы векторе сохранили, то есть может какие-то элементы были удалены,
или может какие-то элементы были добавлены все-таки. Окей? Хорошо.
Ну и, наконец, строгая гарантия безопасности говорит про следующее.
Вот если тут, я не мог сказать, то есть я мог сказать лишь то,
что вектор можно корректно пользоваться, то есть никаких техник данных не произошло,
то вот тут, в случае строгой гарантии безопасности, я могу точно сказать,
что если операция завершилась неуспешно, то вектор находится ровно в том же состоянии,
что и до вызова этого метода. То есть тут я могу с точной уверенностью сказать,
что тут size по-прежнему равен 10, capacity по-прежнему равен 20, ну и, точнее так, давайте так скажем,
что вот этот вектор в точности совпадает с вот этим вот вектором. Окей?
То есть строгой гарантией безопасности, это по сути то же самое, что и базовая гарантия безопасности,
то есть программой можно продолжить корректно пользоваться, но при этом дополнительно
строгая гарантия безопасности говорит в том, что система находится ровно в том же состоянии,
что и до вызова проблемного метода или что до вызова проблемной операции, понятно?
То есть ну грубо говоря, строгая гарантия безопасности говорит в том, что грубо говоря,
операция происходит атомарно, то есть она происходит либо полностью, то есть происходит изменение
корректно, либо операция как будто бы не происходила вообще.
Вот.
так ну и давайте я предлагаю посмотреть на примеры и
обсудить какой код является безопасным кой код безопасным не является ну
давайте посмотрим все на примере вектора да давайте предлагаю посмотреть на
примере вектора и обсудить реализацию
операции при свавене. Сразу скажу, что
операция при свавене реализована с некоторыми допущениями, с некоторыми
ошибками, которые нельзя просто взять и перенести в домашнюю, но концепции
связанные с ограничением безопасности мы обсудим. Значит, давайте для начала
посмотрим на гарантию отсутствия исключений.
Допустим, я пишу вектор, у вектора естественно есть указатель на выделенные данные, у
вектора есть размер, то есть количество элементов, которые реально хранится в векторе,
ну и плюс капасти от количества реальных выделенных ячеек памяти
для хранения элементов. Какие операции могут похвастаться строгой гарантией
безопасности? Строгой гарантией, простите, гарантией отсутствия исключений.
Гарантия отсутствия исключений могут похвастаться методы, такие методы, как, например, свап.
Ну, я думаю, вы понимаете, что при вызове метода свап ничего плохого не
происходит. Почему? Потому что свап просто-напросто меняет местами
чиселки сайса capacity и меняет местами указатель на буфер.
Да.
Слаб у нас перелезен на перемещающие присваивания.
Здесь, например, есть сычевый клад, который написан без noexcept, перемещающий присваивания.
Но это саб, получается, теряется в гаранде.
Это да, про noexcept в перемещающих методах мы поговорим.
Вот, смотрите, тут никаких проблем не будет.
Почему? Потому что size – это число, capacity – это число, указатель – это число.
При обмене двух чисел и при обмене двух указателей ничего плохого не происходит.
Поэтому вот этот вот саб абсолютно безопасен с точки зрения исключений.
Согласны?
Окей.
Теперь давайте посмотрим на операцию перемещающего присваивания.
Операция перемещающего присваивания тоже абсолютно безопасна.
По крайней мере, вот эта вот реализация абсолютно безопасна.
По какой причине?
Смотрите.
Ну, понятное дело, тут я проверяю на самом присваивании.
Дальше 22 строчки я вызываю delete-буфер.
Давайте обсудим, может ли delete-буфер привести потенциально к проблемам.
Ну, смотрите, вообще говоря, сама по себе очистка памяти,
то есть вызов, точнее возврат памяти операционной системы, он безопасен.
То есть гарантируется, что там никаких проблем не возникнет.
Но вот что еще на самом деле вызывает delete?
Да, delete вызывает деструкторы.
А как мы с вами говорили, деструкторы, они потенциально тоже могут бросить исключения.
Это совсем плохо.
И, соответственно, первое допущение, которое мы тут делаем,
и вообще допущение, которое делается практически во всех классах стандартной библиотеки,
то, что деструкторы не вызывают исключений, окей?
То есть мы автоматически предполагаем, что деструкторы всегда завершаются корректно.
Поэтому если мы предполагаем, что деструктор завершается корректно.
Кстати, я про это не сказал, ну, кажется, это было на слайдах.
Вот именно по той причине, что вызывать исключения в диструкторах плохо,
Все диструкторы по умолчанию всегда помечены noexcept.
Окей?
То есть даже если вы для диструктора не писали noexcept,
считается, что деструктор помечен noexcept.
Поэтому можем считать, что 22 строчка тоже завершится корректно.
корректно, никаких проблем не будет. Ну а дальше, по сути, я тут использую
операцию Exchange, напомню, как работает Exchange. Exchange берет первый аргумент,
точнее, эта функция берет второй аргумент, записывает первый аргумент, а старое
значение первого аргумента возвращает в качестве результата. То есть, грубо
говоря, давайте еще раз интуитивно напомним, как работает Exchange.
Exchange x и y работает так. r записывается в x, а x записывается в z.
Ну и так как Exchange просто реализован на обменах между,
по крайней мере, данный Exchange реализован чисто на обменах целых чисел и указателей, то
естественно, никаких проблем тут не возникнет. То есть, абсолютно, полностью
корректно и безопасно написанная перемещающая пресваивание.
Давайте посмотрим на более осмысленные примеры и посмотрим на
операцию копирующего пресваивания. Операция копирующего пресваивания
принимает другой вектор, я тут проверяю на смысл пресваивания и дальше
делаю следующее. Ну, казалось бы, с алкогерпинской точки зрения, все написано
корректно. Сначала я копирую размер, потом я в capacity записываю тоже другой
размер. Дальше что я делаю? Дальше я удаляю старые данные, выделяю память для
новых данных и дальше в цикле копирую данные из другого массива в свой
массив. Ну, тут я опускаю момент то, что на самом деле вектор, он использует
не пресваивание, использует размещающий new. В общем, это давайте оставим за скобками.
Давайте посмотрим на то, безопасен ли этот код с хоть какой-то точки зрения.
То есть, обладает ли он гарантией отсутствия исключения, обладает ли он
гарантии базовой гарантии исключения и отсутствия базовой гарантии
безопасности исключения или строк гарантии безопасности. Какие есть предложения?
Давайте вообще в принципе просмотрим этот код полностью и посмотрим на те
моменты, которые потенциально могут бросить исключения. Давайте начнем с первой
строчки. Понятно дело, что тут просто происходит
присваивание целых чисел. При присваивании целых чисел ничего плохого
произойти не может. То есть, это примитивный тип, с примитивным типом ничего плохого не
происходит. Дальше тут вызывается дилит, точнее вызывается очистка памяти, ну и плюс
вызов деструкторов. Как мы с вами обсудили вызов деструкторов, ну мы предполагаем,
что вызов деструкторов ни к чему плохого не приведет. Дальше, вот в 39 строчке.
Действительно, как правильно отметили, в 39 строчке потенциально может возникнуть
проблема bed-lock. То есть, мы тут выделяем память, памяти может не хватить, new может
бросить исключения. Какая еще на самом деле проблема существует в 309 строчке?
Да, смотрите, new помимо того, что выделяет память, еще приводит к тому, что
вызывают конструкторы. То есть, тут вызывается capacity раз конструктор
по умолчанию. Я же не знаю, чем на самом деле является тип T, согласны?
Поэтому тип T, точнее конструктор по умолчанию для T, теоретически может тоже
бросить исключение. Вот, поэтому в 39 строчке исключение может возникнуть по
двум причинам. Первое не хватает памяти, второе исключение возникло в
конструкторе по умолчанию. Согласны? Хорошо. Давайте дальше. Цикл тут понятно, тут
ничего плохого не происходит, а внутри цикла в 41 строчке. Да, тут уже вызывается
операция присваивания для типа T. Опять же, я не знаю, как
устроен тип T, я поэтому не могу гарантировать вам, что для типа T
операция присваивания будет работать безопасно. Поэтому операция
присваивания, чисто в теории, может привести к проблемам, может привести к
ошибкам. Вот, я нашел сразу три места, где потенциально можно бросить
исключение. То есть данная функция не является, не предоставляет гарантию
отсутствия исключений совсем. Ну, может быть, она предоставляет базовую
гарантию безопасности или строгую гарантию безопасности, как вы думаете? То есть, окей, я
понял, что функция потенциально бросает исключение. Вот, ну, если функция бросает
исключение, то еще есть шанс, что она предоставит мне, ну там, не знаю, строгую гарантию
безопасности, да, то что исключение возникнет, но при этом вектор останется в том
же самом состоянии, что и до вызова операции присваивания. Верно это или нет?
Почему?
Во, да, смотрите, эта функция не предоставляет мне строгой гарантии
безопасности. Почему? Потому что я тут в 38-ой строчке очистил массив, то есть
очистил память, которую хранит в себе вектор, а потом в 39-ой строчке у меня
потенциально бросается исключение. Вот, представьте себе, что в 39-ой строчке вылетело
исключение, и что произошло? У меня вектор очистил свою память и при этом
возникло исключение, то есть пользователь после обработки своего исключения в
операции присваивания, он получит вектор, у которого вообще нет памяти, да, понятно?
Поэтому, ну, понятное дело, что вектор с памятью и вектор без памяти, два
абсолютно разных вектора, вот, поэтому строгой гарантии точно нет. А базовая
гарантия есть? А где тут зануление? Так, ничего, есть базовая гарантия или нет?
Почему? Да, смотрите, на самом деле эта реализация не предоставляет даже базовой
гарантии безопасности. Почему? Потому что тут вектор, ну, вот, если в 39-ой
строчке возникло исключение, то вектор просто нагло врет о своем состоянии.
Ну вот, представьте себе, что у меня был вектор, у которого там был какой-то
size и был какой-то capacity. Вот, дальше я сказал, что вектор равен, там, допустим,
вектору из ста элементов. Вот, что произошло? Я выставил size равной сотне,
capacity равной сотне, дальше в 38-ой строчке очистил буфер,
удалил память, а дальше у меня возникло исключение. Ну, допустим, я это исключение
как-то тут обработал, и дальше продолжаю пользоваться вектором. Что произошло?
Вектор говорит, а у меня размер 100 и вместимость 100, а на самом деле ничего нет.
Понятно? Ну, вектор находится не в корректном состоянии, он врет, он говорит, что у меня
capacity 100, а на самом деле у него вообще ничего не выделено, на самом деле вообще нет памяти,
потому что мы для него вызвали delete. Понятно? Да? Ну, смотрите,
буфер равно newT, как работает, сначала вызывается new, потом результат вызван
new, записывается в буфер. Если new вызвал исключение, то присваивание, естественно,
произойдет. То есть в буфере останется старое значение, то есть буфер будет указывать на уже
удаленные данные. Понятно? Давайте попробуем как-то переписать код, так чтобы этот код
удовлетворял хотя бы, ну, смотрите, вообще такой код он не очень хорош, почему? Потому что он
не удовлетворяет ни одной из гарантий безопасности, он вообще не безопасен, то есть как бы и он исключение
допускает, и если исключение произошло, то вообще все, как бы вектором пользоваться нельзя, он вообще
не корректен, ну, вообще непонятно, как что с этим вектором делать. Давайте попробуем реализовать хотя
бы базовую гарантию безопасности. Я утверждаю, что вот этот код обладает базовой гарантией
безопасности. Давайте посмотрим на него и осознаем почему. Давайте прокомментируем,
что тут происходит. В этой версии операции присваивания я сначала удаляю буфер, потом в буфер
записываю nullptr, в size и capacity тоже записываю по нулям, а дальше выделяю память и записываю
в буфер. Смотрите, что тут происходит. Допустим, тут в 58-ой строчке при вызове new, либо по причине
того, что конструктор умолчания бросил исключение, либо по причине того, что new бросил исключение,
ну так или иначе у меня возникло 58-ой строчка исключения. Что в итоге произойдет? В каком состоянии
будет вектор? Да, смотрите, если тут произошла ошибка, то у меня вектор окажется в следующем
состоянии. Size у него будет равен нулю, capacity у него будет равен нулю, а сам указатель буфер
будет указывать на null. То есть у меня вектор окажется в полностью согласованном состоянии.
То есть у него размер равен нулю, вместимость равна нулю, то есть никакая память не выделена,
и память действительно никуда не указывает, то есть она указывает в нулевую позицию. Понятно?
Вот. То есть изначально у меня был какой-то вектор, так как операция прислания завершилась
неуспешно, то вектор оказался в каком-то валидном состоянии, но не в таком как раньше. А это ровно и
есть определение базовой гарантии безопасности. Понятно? То есть вектор оказался в каком-то
хорошем в том смысле, что согласованном состоянии, но при этом не в том же состоянии, что и раньше.
Нормально? Давайте попробуем допилить этот код и сделать из кода, который гарантирует,
который дает базовую гарантию безопасности, код, который дает строгую гарантию безопасности.
Вот он. Я утверждаю, что данный код обладает строгой гарантией безопасности. Снова давайте
дам время посмотреть, обдумать и потом прокомментирую. Да. Я сравниваю не два вектора,
я сравниваю указатели. Сравнение указателей корректно. Именно поэтому проверка на самопредсвоение
реализована так. Потому что сравнение векторов может быть во-первых долгим, а во-вторых опасно
быть на самом деле, вряд ли может, но все равно. Что тут происходит? Давайте разбираться. Смотрите,
первым делом я выделяю память для хранения новых данных, то есть new buffer. Смотрите,
если с этой операции что-то пошло не так, то, ну как бы и ладно, из-за присваивания вылетело
исключение, у меня вектор остался ровно в том же состоянии. Потому что до 72 строчки я вектор
вообще никак не менял. Понятно? Раз я вектор вообще никак не менял, то соответственно и вектор окажется
в том же состоянии, что и до вызова операции присваивания. Дальше. Давайте я пока уберу вот
этот вот try-catch и посмотрим на вот этот вот цикл. Смотрите, если я с этим циклом ничего делать не
буду, то что может произойти? Какая неприятная история? Да, смотрите, тут возможность следующей
неприятности. Понятное дело, что тут используется операция присваивания. Но операция присваивания,
так как я использую операцию присваивания для какого-то типа T, но про этот тип T, естественно,
заранее я ничего не знаю. Поэтому операция присваивания для типа T потенциально может
просить исключение. И вот если тут возникнет исключение, то будет проблема связанная с тем,
что исключение вылетит, но при этом я же уже выделил память для нового буфера. И эта память у меня
утечет. Чтобы избежать вытечки памяти, я добавляю вот этот try-catch блок. И что я говорю? Я говорю,
что я пытаюсь скопировать все данные из other буфер в new буфер, и если в какой-то момент что-то
пошло не так, то есть если при каком-то копировании что-то пошло не так, то я просто-напросто вызываю
catch, то я ловлю произвольное исключение, очищаю память, которую выделал ранее, и бросаю исключение
дальше. Понятно? То есть если в каком-то этапе копирования у меня что-то пошло не так, то я
могу все откатить обратно. В том смысле, что я могу удалить память, которую я уже выделил,
но так как я, смотрите, вот тут нигде вообще не изменял данные исходного вектора, то есть нигде не
изменял исходный буфер, нигде не менял исходный size и capacity, то вектор останется по-прежнему в
корректном состоянии. И только в случае, если и выделение памяти, и копирование произойдет
успешно, только после этого я со спокойной совестью могу изменять данные вектора. То есть я удаляю
буфер, говорю, что буфер теперь это новый буфер, size это новый size и capacity это новый size. Все.
Нормально? То есть я сначала сделал все изменения, а потом с помощью только безопасных операций
применил эти самые изменения. То есть когда я делал изменения в векторе, у меня ничего не
менялось, поэтому ничего и после выброса исключений не изменится. А когда я начал делать безопасные
операции, я тоже спокойно менял состояние вектора, потому что раз это операция безопасная, то и
исключений тут нигде не возникнет. В качестве бонуса могу показать еще одну реализацию
операции присваивания, которые обладают строгой гарантией безопасности и которые используют так
называемый copy and swap and idiom. Идиом и копия и swap и
Добавить строгую гарантию безопасности, а вот так, чтобы исправить дублирование кода, можно воспользоваться следующим трюком.
Тут я проверяю на самоприсваивание.
Надо проверить адрес.
Я проверяю самоприсваивание.
А дальше делаю следующее.
Я предполагаю, что у меня уже реализован конструктор копирования.
Давайте я с помощью копирования создам временный объект из Adr.
То есть я путем копирования создаю временный объект, то есть временную копию Adr.
А дальше к этой временной копии применяю уже реализованный метод swap.
Что происходит?
Вся логика копирования у меня уходит в конструктор копирования.
Вся копирование отходит на конструктор копирования.
Если в этом конструкторе копирования что-то пошло не так, то ничего не произошло потому что у меня исходный объект никак не изменился.
Но если копирование произошло успешно полностью, то я могу взять этот вот временный объект
и забрать все его данные себе, а свои данные дати этому временному объекту.
Что тогда произойдет?
Этот временный объект получит мои данные, их уничтожит...
это временный объект, для него потом вызовется деструктор. Все мои данные, они будут уничтожены.
А те данные, которые скопировал вот этот вот конструктор копирования, я заберу себе,
поэтому получу полноценную копию атер. Таким образом, я убиваю двух зайцев и избавляюсь от дублирования кода,
и получаю строгую гарантию безопасности. Да.
А вот будут ли какие-то идеи и отличия, если мы будем, допустим, наоборот, делать что-то временное объекта,
а потом, где он здесь, стрелочка, свап, вот время. Нет, нет, ну то есть, можно написать вот так,
автокопии равно адр, и дальше просто написать свап, копии. Можно написать вот так, ну,
идей вообще ни в чем отличия не будет, то есть, как бы то же самое. Вот. Просто вот так вот
можно писать в одну строчку. Так. Вопросы есть? Хорошо. Поговорили про гарантию безопасности.
Теперь давайте внезапно вернемся к вопросу, а для чего же на самом деле нужен noexcept?
Ну вот, в прошлый раз я сказал, что noexcept нужен для того, чтобы пометить функции,
которые точно не бросают исключений, вот. Поэтому если функция там точно не бросает исключений,
то, соответственно, я могу на это полагаться, бла-бла-бла. В общем, на самом деле, когда мы вызываем
какие-то функции, вряд ли мы опираемся на вот это вот ключевое слово noexcept. Ну то есть, на самом
деле, мы, конечно, можем заглянуть в документацию, посмотреть на функцию, объявленную функцией noexcept
или нет. Ну, скорее всего, мы либо как-то заранее интуитивно понимаем, может ли функция брать
исключения или нет, ну, либо, скорее всего, просто обсчитаем документацию, документация написана,
бросает ли функции исключения или нет. Так вот, зачем же на самом деле нужно помещать некоторые
функции noexcept и к чему это привозит? Так вот, внезапно, вот, возможно, эта информация кого-то
шокирует, но noexcept нужен больше не для безопасности, а noexcept нужен больше для производительности.
Вот. Давайте я об этом поговорю. Давайте я про это скажу. А, ну да, окей. Давайте я про это скажу.
Смотрите, вот, вот лейтмотивом нашего курса по sup++, ну, вообще, как бы таким краеугольным
камнем sup++ является постоянная борьба между безопасностью кода и его эффективностью, да,
то есть, например, почему sup++ настолько небезопасный, да, что аж там, кому-то ЦРУ, да, там говорят, что все,
не надо использовать sup++, потому что он супер небезопасный, потому что там работа с памятью и так далее.
Вот. Почему sup++ небезопасный? Вот как раз sup++ небезопасный по причине того, что он эффективный,
точнее наоборот, он эффективный, потому что небезопасный. В чем тут связь? Ну, смотрите,
из-за чего возникают вот эти вот самые проблемы с безопасностью? Проблемы с безопасностью возникают
тогда, когда у нас, когда мы educational thinking на таком Idol listeners Yue Sasha California Soto2021 surface.
Я понятиvo неопределенное поведение, вот. З Gladys pumpkin converた, separtoradesame мы выходим за
oso 2025. Исходим за границей массива. Но это неопределенное поведение. Мы, допустим,
Una.יבいや طоб mommyodylu выделилиconduct, но ее не очистили. Это неопределенное поведение,
там мы два раза очporte до одну и ту же память. Это неопределенное поведение. Я и так далее,
В чем причина вот этого неопределенного поведения?
Вот неопределенное поведение — это, по сути, вот такие вот дыры в стандарте C++,
которые C++ на самом деле оставляет осознанно просто-напросто для того,
чтобы разработчики компиляторов могли полагаться на то, что этого никогда не происходит.
А если этого никогда не происходит, то и в принципе проверок на то,
что это потенциально может произойти, делать не нужно.
Ну, пример такой вот жизненный.
Вот вы пишете задачу на контесте, вам в контесте сказано, что вам на вход подают положительные числа.
Сказано, плюс gesagt, что надеALLY у вас есть положительные числа.
Соответственно что вы делаете? Вы просто пишите программу в предположении,
что у вас на вход подают положительные числа.
Вам никак не нужно дополнительно обрабатывать ситуацию,
если вам на giờ подали отрицательные числа.
Ну, потому что если вам было сказано, что на вход подают положительные числа…
А если соответственно подаются отрицательные числа, то вам нужно сделать что-то еще.
В этом случае ваша программа была бы менее эффективной.
Потому что вам бы пришлось рассматривать некоторые дополнительные случаи и вот Halard
и вот эти постоянные проверки на лFA
замедлили вашу программу да, а когда вам в условии
прям четко и ясно сказано, что вам наход connectors
подают столько положительные числа, вы просто
забиваете на другие случаи и пишите вот
в предположении что вам наход Commission под kommen
положительные числа, разработчики компили mostrar
etty ровно так же, statistics плюс
плюс написано, то что并 не написано,
что нужно делать если вдруг
мы вышли за границы массива или что
нужно делать если вдруг мы обращаемся к
не инициализированный переменной,
то разработчик they пока полны волны
поступать так как им удобно, что значит
как им удобно стрpoчки компиляторы
поступают так, как это будет так Nambo
эффективно конкретно в их реализации. Именно поэтому возникает вот такая вот
история, что мы забиваем на безопасность, то есть мы предполагаем, что такого не
происходит, но при этом получаем дополнительную эффективность.
Если же в какой-то момент возникает необходимость в какой-то
безопасности, допустим, вот почему, например, нет неопределенного поведения
какого-нибудь Java и Python, ну потому что на все такие ситуации, выход за
границы массива, обращение к неинициализированной памяти, там вообще, по-моему, нет
неинициализированной памяти, в общем, при обращении к переменам всегда
происходит дополнительная проверка, то есть сама система, сам компилятор или
сам интерпретатор проверяет, а действительно ли эта память доступна,
действительно ли там что-то лежит и так далее. И вот на это уходят дополнительные
ресурсы. И вот возникает вот такая вот проблема. С одной стороны, хочется писать
безопасный код, но безопасный код, как правило, связан с дополнительной
нагрузкой, с дополнительными проверками. С другой стороны, хочется писать
эффективный код, но если мы пишем эффективный код, тогда он придется избавляться от
дополнительных проверок, чтобы код делал ровно то, чего мы хотим. Вот, и вот
таким вот, как назвать, ну таким вот аватаром, который приводит все в
баланс, в C++ является слово noexcept. Вот noexcept говорит следующее, что этот код
не только эффективный, но этот код еще и безопасный, то есть компилятор может
полагаться на то, что при вызове этого метода или при вызове этой операции
ничего плохого не произойдет, поэтому можно выбирать наиболее эффективную
версию. Вот, давайте обсудим. Давайте приведу пример. Как noexcept позволяет
ускорить код, ускорить код программ? Так, пу-пу-пу, в общем, пример, ладно, я хотел показать другой пример, давайте его на
доске обсудим. Смотрите, ключевое место, в котором необходимо писать noexcept
всегда, ладно, давайте на том примере. Место, где стоит всегда писать noexcept,
является перемещающий конструктор или перемещающий присваивание. Вот по
следующей причине. Давайте посмотрим на этот код. Код realoket, который
просто-напросто переведеляет память для вектора, то есть как бы если
меня попросили выделить памяти больше чем ноль, то я выделяю эту память, вот
создаю новый буфер, создаю новый размер и так далее. Вот данный код является
примером кода, который является неэффективным и небезопасным. Вот, почему?
Этот код является неэффективным и небезопасным, потому что, во-первых, тут
потенциально может возникнуть исключение, то есть при копировании данных
возникает исключение, и соответственно, что при этом происходит? Если тут
возникнет исключение, то я потеряю вот эту вот динамически выделенную память и
соответственно у меня произойдет утечка памяти, да, понятно. С другой стороны, эта
реализация не является эффективной, по какой причине? Она не является эффективной,
потому что тут я использую копирование, да, то есть смотрите, у меня есть, у меня есть
старые данные, то есть вот у меня есть старые данные, вот, я хочу перевыделить память,
допустим, перевыделить память большего размера, я хочу перенести старые данные в
новый массив. Вот. А что, если вы в качестве вот этих вот данных, которые мне нужно
перевести в новый массив? Что если этими данными окажутся какие-то длинные строчки,
или какие-то другие длинные вектора? Что при этом произойдет? Ну, при этом будет вот этот
каждый элемент будет копироваться в новый буфер, а копирование будет занимать очень большое время,
согласны? Да? Вот. Поэтому, что на самом деле бы хотелось сделать? Ну, какая есть альтератива
копирования? Да, то есть, если у меня есть какой-то, ну, если у меня был какой-то старый буфер,
мне нужно какие-то данные перенести старого буфера в новый буфер, ну, при перевыделении памяти
вектора, то, естественно, разумным вариантом был бы применить перемещение, ну, то есть каждому
элементу применить функцию sdmove. Ну, давайте разбираться по порядку. Вот. Хорошо. Допустим,
я решил пока забить на эффективность, да, и решил написать вот этот вот, переписать тот же самый
код, но с использованием, ну, скажем так, техник безопасности. На это что я делаю? Я выделяю память,
дальше говорю, что у меня новый размер вектора равен вот такому, вот такой величине, и дальше я
помещаю вот этот вот код, в котором потенциально может что-то пойти не так, я помещаю его в блок
try-catch. То есть, я произвожу копирование элементов, то есть, я копирую элементы из старого буфера в
новый буфер, вот. И в случае, если что-то пошло не так, то я, ну, ловлю это самое произвольное
исключение, которое произошло, удаляю память, которая была выделена, и бросаю исключение дальше.
То есть, в этот момент, то есть, как бы, ну, сказал, ну, окей, жаль, да, то есть, копирование произошло
неуспешно, поэтому оставайся со старым буфером. Нормально? Да? Вот. То есть, данная реализация
является безопасной, но при этом по-прежнему является неэффективной, да, почему? Потому что у меня
тут используется копирование, вот, ну, то есть, а при копировании данных у меня, при копировании
данных у меня, ну, потенциально, копирование данных потенциально занимает большое время, то есть,
если я вдруг работаю там со строками, с факторами и так далее, вот. Давайте посмотрим на следующий
код и зададимся следующим вопросом. Хорошо, вот я понял, что предыдущий код, он безопасный,
ну, он обладает строгой гарантией безопасности, но при этом не является эффективным. Почему? Потому
что вот тут вот в 38 строчке происходит копирование. Давайте я вот согласно вот этому плану перейду
от копирования к перемещению. Вот. То есть, напишу вот такой код. То есть, вместо того, чтобы копировать
элементы, буду их перемещать. То есть, что я буду делать? То есть, вот, пусть у меня есть буфер,
вот есть элемент тут, тут, тут, и что я буду делать? Перемещу первый элемент, перемещу второй элемент,
перемещу третий элемент и четвертый. Перемещение потенциально работает быстрее, чем копирование,
ну, там для строк и векторов это точно верно. Вот. Ну и плюс так, я все поместил в тройкач блок,
кажется, что код абсолютно, точнее, код обладает строгой гарантией безопасности, то есть,
во-первых, он и эффективный, и безопасный. Так это или нет? Ну, смотрите, если, смотрите,
если у меня перемещения нет, то вот этот код будет работать как копирование. Ну, давайте
предположим, что у типа T, да, то есть, у элементов, которые хранит вектор, конструктор перемещает,
точнее, перемещающие присваивания все-таки есть. Ну, там для большинства типа перемещающие
присваивания оно все-таки присутствует. Вот. В чем принципиальная проблема? Почему этот код на самом
деле не является безопасным? Ну, казалось бы, да, он эффективный почему-то, потому что я перемещаю,
ну, разумно. Вот. Но он не является, с другой стороны, он является безопасным, ну, просто потому,
что я поместил весь код вызова присваивания в try-catch. Да, если у меня перемещение произошло
неуспешно, то я просто-напросто удаляю новый буфер и бросаю исключение дальше. Почему этот
код не обладает строгой гарантией безопасности? А в каком случае могут потеряться данные?
Вот. Да, смотрите. Смотрите, в чем потенциальная проблема. Снова. У меня есть буфер, в котором изначально
были данные. Я в тыкле-фор начал их поочередно перемещать. Взял первый элемент, переместил.
Взял второй элемент, переместил. Начал перемещать третий элемент, но тут возникло исключение.
Что произошло? Да, смотрите. У меня в результате перемещения второго элемента возникло исключение.
Я это исключение поймал в кэтчблоке, удалил новый буфер и завершил операцию реаллокации.
Что произошло? У меня буфер изменился, согласны? Раньше в нем были два элемента,
ну первые два элемента в нем были, а теперь первых двух элементов нет. Точнее, они находятся в так
называемом moved from state. Эти элементы были перемещены, значит они хранят, скорее всего,
они хранят какие-то нулевые указатели. Хотя раньше они хранили какие-то реальные объекты. Понятно?
Это момент понятен? То есть раньше, когда я копировал, вот, если я производил копирование,
то все окей. Раз я производил копирование, то эти элементы остались на месте. Я мог спокойно удалить
новый буфер, ну тогда, соответственно, после удаления у меня исходный буфер оставался в
прежнем состоянии. Если же я начинаю перемещать, то я лишаюсь способности к написанию безопасного кода.
Вот, то есть возникла вот эта вот самая вилка, в которой, с одной стороны, я хочу написать
оптимальный код, который бы перемещал элементы, но с другой стороны, я теряю безопасность. Почему?
Потому что если я элементы перемещаю, и в какой-то момент при перемещении возникла ошибка, то у меня
исходный буфер остался в невоидном состоянии. Как победить эту проблему? Давайте я предложу такой
вариант. Вот. Мое предложение такое. Давайте я буду перемещать, то есть вот у меня есть буфер,
есть новый буфер. Давайте я буду перемещать элементы, то есть перемещу вот этот элемент, перемещу вот этот
элемент, перемещу вот этот элемент, а при перемещении вот этого элемента возникла ошибка. Ну смотрите,
что у меня произошло? Так как я эти элементы перемещал, у меня буфер оказался не в том состоянии,
который был раньше. Согласны? Ну давайте я верну его в исходное состояние, сделаю код безопасным.
То есть перемещение не удалось, ну давайте откатим все обратно. Давайте перемещаю обратно, перемещаю
обратно, перемещаю обратно. В чем проблема? Да, перемещаю обратно, и тут новая ошибка. Что делаем дальше?
Ну окей, туда не получилось, давайте обратно перемещать. Вот. И так далее. То есть понимаете,
в чем проблема? Если я начинаю перемещать, то я вообще не могу гарантировать, вообще не могу
дать строгую гарантию безопасности, потому что перемещение, оно всегда оставляет мне какой-то
из векторов, точнее, какой-то из массивов в промежуточном состоянии. И если я пытаюсь из этого
промежуточного состояния вернуться в какое-то исходное состояние, то мне снова придется вызывать
перемещение, ну а перемещение опять же может бросить исключение. Понятно? Да. А кто вам такое сказал?
Давайте я напишу специальный тип. Класс Type. Напишу класс Type. И у класса Type напишу такое перемещающее
присваивание. Вот так. Type, оператор Type, амперсант, амперсант. И напишу тут такой код. Если
ранд, не знаю, процент 0 равно 0, то throw. А иначе не throw. То есть, ты представляешь себе, что операция
перемещения, она зависит от каких-то внешних обстоятельств. То есть, по каким-то причинам,
в некоторых ситуациях она бросает исключение, в других ситуациях не бросает. Например, она зависит
от какого-то рандома. То есть, тут я вообще не могу дать никаких гарантий на то, что перемещение завершится
успешно. Понятно? То есть, перемещение, оно оптимально, то есть, оно эффективно, но, к сожалению,
не дает мне написать безопасный код. Вот, в этом проблема. Так, поэтому, что у нас получается? У нас
получается следующее. Если я хочу написать код, написать код реаллокации, который бы следовал,
который бы удовлетворял строгой гарантии безопасности, то я должен использовать копирующее
присваивание. Этот код безопасный, но не эффективный. Если я хочу получить эффективный код, то я
использую перемещение. Вот оно, перемещение. Но при этом код становится небезопасным. Вот, вот
этот самый баланс. При чем тут noexcept? А noexcept тут при том. Смотрите, помните, я говорил про то,
что когда мы обсуждали симматику перемещения, я говорил про то, что все операции,
копирующие, перемещающие присваивание и все конструкторы перемещения, то есть, все
перемещающие операции должны быть помечены noexcept. Для чего? Смотрите. На самом деле,
на самом деле, стандарты BGC++, помимо функции std move, есть еще функция move if noexcept. И она устроена
очень хитро. std move if noexcept действует следующим образом. Она говорит, она работает как std move
в случае, если перемещение помещено как noexcept, а если перемещение не помещено как noexcept,
она просто-напросто возвращает копию. Понятно? Move if noexcept устроена следующим образом. Она
возвращает исходный объект, если перемещение не помещено как noexcept и работает как
move, если перемещение помещено как noexcept. Вот. Для чего нужно перемещение, на самом деле,
помещать noexcept? Перемещение нужно помещать noexcept, чтобы у вас код был одновременно и безопасным,
и эффективным. Потому что если вы перемещение пометили как noexcept, то тогда компилятор,
но еще и стандартная пилотека, точно уверена, что при перемещении ничего плохого не может
произойти. А раз при перемещении ничего плохого не может произойти, то я могу абсолютно спокойно,
ну допустим при реалокации, вызывать перемещение. То есть тут, тут, тут, тут и так далее. Окей?
Вот. То есть noexcept позволяет общить другому коду о том, что меня вызывать абсолютно безопасно.
Раз меня вызывать абсолютно безопасно, то эту операцию, эту функцию можно вызывать в контексте
максимальной эффективности. Вот пример. Если я буду вызывать перемещение, то это будет
работать небезопасно, но если я гарантирую, что у меня перемещение noexcept, то тогда я говорю,
пожалуйста, делай перемещение, и можешь не думать о проблемах с безопасностью. Окей?
Вот в этом примере. Давайте еще раз. Смотрите, если я просто...
Ну смотрите, если, ну смотрите, в предыдущем примере, если я не был, если я не уверен в том,
что перемещение работает безопасно, тогда проблема в следующем. Вот. Я начинаю перемещать,
перемещать, перемещать, и вдруг, допустим, на последнем элементе перемещение зафейлилось.
Допустим, я ставлю ровно в таком состоянии. Вот. Допустим, перемещение устроено так,
что оно в какой-то случайный момент решает бросить исключение, суету навести. Вот. По какой-то
причине. То есть мы же не знаем, как... Смотрите, у нас же вектор реализован для произвольного типа
T. Я же не знаю, какой там пользователь подаст типа T. Но вдруг он реализует как-то неправильно
операцию перемещения, или просто перемещение устроено так, что, допустим, перемещение выделяет
память у него. Вот. Тогда она может покинуть исключение. Поэтому, в случае, если тут произойдет
что-то не так, то мне либо придется возвращать все обратно, а, как мы поняли, это невозможно. Почему?
Потому что, если я буду начинать возвращать все обратно, то при возврате обратно снова может
произойти вот такая вот ситуация. Вот. Поэтому вернуть все обратно я не могу. Поэтому мне придется
смириться с тем, что вот я останусь, что у меня все останется на полупытии, и строгой гарантии не
будет. Вот. То есть строгую гарантию, то есть одновременно и строгую гарантию безопасности,
и эффективность я могу гарантировать только в том случае, если у меня перемещение не
бросает исключений. И вот для этих ситуаций есть функция moveNoExcept. Еще раз, да, moveNoExcept,
если видит, что перемещение безопасно, оно просто-напросто делает перемещение, и все работает
эффективно. Если moveNoExcept видит, что перемещение безопасно, то он вместо перемещения делает
копирование. Вот. Ну а копирование уже тоже дает строгую гарантию безопасности.
А как, смотрите, а как компилятору понять, безопасно это или нет? Еще раз, компилятор смотрит верно
лишь, что перемещение помещено как NoExcept. Вот как раз такой разговор про что? Когда мы пишем
конструктор перемещения, ну или перемещающий присваивание, мы же пишем его вот так. Адр. И
дальше необходимо писать NoExcept. Вот вы можете самостоятельно провести, ну давайте я семинаристу
попрошу, в общем, можете провести эксперимент. Вы можете реализовать, ну вот взять, да, возьмите,
кстати, проведите такой эксперимент. Вот вы все писали наверняка класс строки свой, да, класс
стринг. Вот возьмите там свой класс строки, и в конструкторе перемещения и в перемещающей
присваивании уберите слово NoExcept. Вот. И попробуйте добавить кучу элементов в std-вектор.
Попробуйте добавить кучу строк, ну кучу не нулевых строк в std-вектор. Вот. NoExcept и без NoExcept.
Вы увидите, что если вы не пишете NoExcept, то у вас вектор работает супер медленно. Если вы
работаете с NoExcept, то вектор будет работать быстро. Почему? Потому что если вы не написали NoExcept,
то вектор переключается в режим копирования. Вот. Если вы пишете NoExcept, то вектор работает в
режиме перемещения. Окей? Нормально? Задайте какие-нибудь вопросы. Так, ну окей. Так,
ну про ирак и исключения, я надеюсь, вы говорили про, вы в общем все это говорили
в семинарах. Ну и в целом тогда у меня про исключение все. Всем спасибо и до встречи на следующей неделе.
