Итак, новая технология поиска поток, вот, вообще новая.
Ну, на самом деле, я говорю именно технология, но это не технология, ну вот.
Ну, потому что, на самом деле, то есть сейчас мы введем в партию все то, что можно назвать словом framework.
Такое модное слово есть.
Вот, там framework, на основе которого, на самом деле, можно придумать многое.
Вот, framework, значит, будет работать так.
Значит, смотрите, у нас, то есть первая аксема такая, что раньше мы искали потоки по принципу, ну там, разными способами, но все они упирались в одно.
Мы каким-то образом нашли путь в остаточной сети и протолкнули по нему поток.
То есть, таким образом, в каждый момент времени, условно говоря, у нас корректный поток, просто он может быть еще не максимальный.
Ну, искали мы потоки.
Да, там этот путь либо в тупую, ну либо там каким-то вот блокирующим поток.
Значит, теперь мы сделаем немножко альтернативы.
Мы себе сейчас разрешаем, значит, мы себе разрешаем, чтобы у нас в вершину втекало больше воды, чем вытекало.
Временно.
Это мы будем называть предпоток.
Вот, значит, смотрите, то есть определение.
То есть, вот давайте скажем f.
Ну, давайте вот в программистских терминах напишем.
E, значит, в соответственно R, ну как вы помните, у нас больше или в равно порядке.
Это предпоток.
Если, ну соответственно.
Ну, во-первых, конечно, для любого ребра верно, что f от e меньше либо равно c от e.
Да, и в данном случае больше либо равно нуля.
Давайте я на всякий случай еще раз напишу, хотя я это уже писал.
И второе, самое главное, где я напишу, что для любой вершины v не являющейся истоком истока.
Значит, я напишу так, e от v.
E от v.
Лучше, конечно, больше либо равно нуля.
Вот.
Где?
Ладно, e это плохо писать, потому что e у нас это ребро.
Поэтому мы напишем excess от v больше либо равно нуля.
Ну, я просто хочу отдельно написать, что такое excess.
То есть excess от v это сумма всех втекающих потоков.
Значит, e.finish равен v.
f от e.
Ну, я сейчас написал просто в программистском виде.
Да.
Если бы я писал это в математическом виде, то да, было бы просто сумма всех f.
Сумма всех f от v, да.
Ну, а на самом деле идеи на одно и то же.
Вот.
То есть видите, то есть отличие на самом деле от потока, только то, что...
То есть на самом деле заметим, что поток это такой предпоток, у которого все excess равны нуля.
То есть как excess, это называется вообще избыток по-русски.
Нормальное такое русское слово.
И будем теперь говорить, что вершина v.
Переполненная.
Переполненная.
Если, соответственно, excess от v больше нуля.
Ну, это я просто такой вот цеплен был.
Такая ничего страшного в этом мире.
Вот.
Но это не вся технология.
Теперь мы, то есть забирать сразу скажем, что поток мы будем теперь искать, что мы будем...
Вот у нас будут в некоторых вершинах избытки, и мы эти избытки будем куда-то проталкивать.
Но тоже мы их будем проталкивать совершенно не от балды.
Значит, дело в том, что помимо этого мы введем функцию h.
Значит, теперь у каждой, значит, этот избыток будет еще и связан как-то с высотой.
То есть мы, то есть высота, это функция, это такая функция.
Значит, функция, соответственно, из тоже v в z больше либо равно нуля.
То есть высота у нас целая не отрицается.
Вот.
И теперь смотрите, какая ситуация.
Значит, высота, ну вот, то есть высота это непросто.
Значит, она иногда меняется, но у нее есть тоже важный аксел.
Значит, во-первых, у истока и истока высоты не меняются никогда.
Высота s равна, соответственно, модулю v.
Ht всегда равна нулю.
Это раз.
И теперь есть два.
А теперь говорим, что для любого, так сказать, вот как бы это написать?
Вот так напишем.
Для любого ребра в, вот в нашей технологии напишем, в остаточной сети.
Причем не просто ребра остаточной сети, да, вот чтобы во избежание кривотолков сразу спрашиваем, у которого c, вот эта остаточная пропускная способность, больше нуля.
То есть для любого ребра в остаточной сети, по которому еще можно что-то пустить, ну потому что у нас в остаточной сети по этой ребре ничего нельзя пустить, но они нас сейчас не интересуют.
В общем, для любого ребра, по которому можно что-то пустить еще, в чем как прямого, так и обратно.
Верно, маленькая приятная вещь.
Значит, высота конца этого ребра, ну вот она как минимум, как минимум, это как минимум высота стартовой вершины.
Это как минимум высота стартовой вершины, минус один.
А это вообще возможно?
А что такое?
Если у нас есть какой-то короткий путь из...
А, в смысле, ладно, мы же еще не говорили о том, на каких шагах.
Вот, значит мы будем поддерживать вот такой вариант.
Вот.
Ну, конечно же, в самом начале, конечно, ну правда, да, то есть действительно выясняет естественный вопрос, что в самом начале это очень странно.
Потому что кажется, что, например, если у нас есть ребра из С в Т, допустим, да, то тогда эти ребра будут изначально просто сразу противоречить вот этой орсеоне.
Но они не будут это делать.
То есть если у нас любой путь из С в Т не проходя через все вершины, нет?
Ну, практически да.
Вот.
Ну, на самом деле, смотрите, ну тут, на самом деле, чем это вообще приятно?
Эта штука на самом деле приятна вот чем.
Что сразу давайте вот тогда, чтобы там раздаваться, смотреть.
Предположим, что у нас нашелся поток, даже не предпоток.
Ну, в общем, пусть у нас будет предпоток, то пусть у нас сейчас будет поток и какой-то набор высот, удовлетворяющий вот этим условиям.
Тогда я утверждаю, что этот поток максимальный.
Загадываетесь почему?
Потому что это условие невозможно удовлетворить, если есть хоть один путь из С в Т.
Ну да, то есть действительно, если в остаточной сети есть путь по ненасыщенным ребрам из С в Т,
то учитывая, что каждый переход по ребру уменьшает высоту не более чем на один,
то получается, что, чтобы дойти до Т, вам нужно сделать хотя бы модуль В шагов.
А вы столько шагов не сделаете, у вас там любой простой путь может быть максимальный.
То есть по сути, вам нужно просто будет найти высоту, высоту между В и ноль,
на которой нет ни одной вершины, а такая по принципу делихали найдется.
И просто заявить, что давайте у нас будет разрез, что доля С все шо выше, доля Т все шо ниже.
Понимаете, да?
То есть поэтому наша цель будет подогнать такой поток, вот такой.
То есть найти какой-нибудь поток и подогнать какие-то высоты.
Вот, ну как же это делать?
Но оказывается, и это мы тоже будем делать не обыкаким образом.
А технология будет заключаться, значит технология теперь заключается в следующем.
Ну то есть там разные варианты, но металгоритм будет такой.
То есть такой, так сказать, мета-алгоритм, так сказать, нашего Эндрю, Вячеслав, Владислав,
соответственно, Голдберг.
Значит, он предлагает следующее.
Значит, первый шаг, в чем первый шаг вполне алгоритмический.
Значит, первый шаг, в чем первый шаг вполне алгоритмический.
Значит, присваиваем все высоты, равно нулю.
Значит, h от s равно 0 в, пардон.
Значит, h от t, ну, h от, все остальные вершины равно нулю.
Где v это вот просто любое, любой неисток.
Это во-первых.
Да, пока это еще все некорректно.
Но все, но корректно сейчас все станет после второго шара.
А второй шаг.
Наполните серебра из s.
Да, я так это назову.
Насытить все ребра из s.
Да.
То есть, это по сути, эти два шага, по сути, инициализация.
То есть, после этого заметим, что у нас в графе имеется предпоток абсолютно корректный.
Видите, да?
То есть, абсолютно корректный предпоток, удовлетворяющий действительно вот этим вот высотам.
Видите, да?
Вот.
Ну, а чтобы довершить его до потока, все.
m это что?
m? Это модуль v.
Нет, m это не модуль v, m просто не существует.
Что это за разорванная m?
Ну, а чтобы превратить этот предпоток в поток.
Ну вот.
Ну вот.
Вот дальше сейчас я напишу некоторое заклинание.
Выполняем, скажу я, в некотором порядке.
В некотором порядке.
В некотором порядке.
Вот это слово некоторые превращает алгоритм в металгоритм, собственно.
Порядки.
Порядки.
Операции.
Уж.
И релейбл.
Ну и в других редакциях лифт.
Мы ее будем называть релейбл.
Пока.
Не останется.
Ни одной.
Ладно, так.
I don't speak Russian.
I don't speak English.
I can't speak German, etc.
Пока.
Ну вот, есть.
Хотя бы.
Одна.
Вершина В не исток.
С.
Excess от В.
Больше 0.
Вот такая мета.
Тихон.
Вот.
Такая вот магия.
Да, мы пока не знаем, что такое push-re-label.
Но замечаем, что если нам удастся выполнить push-re-label
и добиться того, что ни одной вершины success от В больше 0 нет,
то тогда это действительно мы нашли максимальный поток.
Согласны?
Как мы уже только что выяснили.
Но обратите внимание.
То есть пункт 3 на самом деле явно подразумевает,
что сетью вы делаете, ну самой сетью, только push-re-label.
Но мы не знаем, что такое push-re-label.
Сетью вы делаете, ну самой сетью, только push-re-label.
То есть именно, ну вот.
То есть больше, ну то есть все остальное, это вы делаете сетью как-то вот не ясно.
Значит, смотрите.
В общем, сеть в данном случае даже имеет расширенное понятие,
потому что мы к вершинам еще и вцепляем вот Аши.
Значит, теперь пришло время понять,
значит, каким же образом мы модифицируем, проталкиваем потоки и изменяем Аши.
Но на самом деле тут разделение труда еще более простое.
Дело в том, что push на самом деле,
то есть дело в том, что у нас push конкретно будет отвечать за проталкивание воды,
а не label будет отвечать за то, чтобы вершину поднять.
Вот, понятно?
Извините, я вызываю.
Извините, я вызываю.
Да.
Значит, а именно.
Значит, поехали.
Значит, теперь пришло время тогда более точно сказать,
что конкретно такой push.
Значит, смотрите.
Значит, push принимает на вход ребро Z.
Такое, что.
Значит, то есть это, значит, ребро в остаточной сети
и, конечно же, оно ненасыщенное.
F от E вот так скажем.
Ну, точнее так, остаточная вот эта пропускная способность C, F от E,
она строго больше 0.
А также еще один важный момент,
то есть если брать пререквизиты,
то еще требуется, что, значит,
значит, E.start не равно S и T.
Finish, пожалуйста, а вот start, боже упаси.
И еще для нас важно,
чтобы excess от E.start был строго больше 0.
То есть смысл очень простой,
смысл очень простой,
то есть чтобы выполнить push по ребро,
то есть цель push'а протолкнуть воду по ребро.
Но для этого нужно, чтобы, во-первых, ребро было ненасыщенное,
во-вторых, чтобы, так сказать, из стартовой вершины было что пихать.
Но есть еще и третье важное требование.
Важное требование заключается в том,
чтобы на этот раз H от E.finish,
на этот раз был равен H от E.start
минус 1.
То есть вот вспомнили, у нас теперь еще будут высоты.
То есть и мы говорим, что вода у нас пропускается только если ребро смотрит вниз.
Причем рога на 1.
Ну, а нижаная не строй.
Мы говорим, что слишком низко у нас под крутым углом трубы у нас не идут,
но если труба идет вверх, то воду мы по ней не пускаем.
А то нас ждет интеллектуальная душа.
Вот.
Так вот.
Это, соответственно, пререквизиты.
То есть сам по себе push.
Что он делает?
Ну, естественно, он пускает максимально возможное число воды по этому ребру.
То есть, то есть, вот так вот, push.
Так, требование.
Значит, требования такие.
А действие будет, ну, формально его можно писать так.
Delta просто присвоит минимум из того, что есть.
И, соответственно, то, что можем пустить.
C, F от E.
Ну, а, соответственно.
Ну, значит, говорится.
Ну, и говорим, соответственно, вот так скажем.
Пустить.
Delta по ребру E.
Ну, я так сразу напишу.
Понятно там.
По тематической интерпретации.
По тематической интерпретации.
По тематической интерпретации.
Ну, я так сразу напишу.
Понятно там.
По тематической интерпретации.
Подразумевал, что F от U, V плюс равно delta.
F от V у минус равно delta.
И еще эксцессы там пересчитать.
Ну, думаю, все понятно.
Понятно?
Да.
Окей.
То есть, обратите внимание.
То есть, вот такой push.
Только он будет пускать воду.
Только он будет пускать воду.
Он будет пускать воду.
При этом высоты он не меняет от слова никак.
Обратите на это внимание.
Понимаете, да?
У нас E.start на брюкдане равно S и T.
Да.
И push единственная операция с ребрами, которые у нас есть.
Да.
В смысле?
Не, не, я не об этом.
И о том, что у нас вообще будет момент, когда мы куда-нибудь...
Когда мы уменьшаем суммарный поток.
Да, когда мы уменьшаем суммарный поток вообще.
Ответ очень простой.
Start в эгошине не должна быть равна S и T.
Совсем формально математически, кстати, лучше это, наверное, вот так.
А, мы типа можем протолкнуть обратно в S?
Совершенно верно.
И мы будем это делать.
Столько у нас будут вершины выше, чем...
Да.
Да, то есть, помните, вода может деться куда.
Либо в T, либо в S.
Ну, в S вернуться обратно.
Кайф.
Так что вот такая красота.
Но для того, чтобы вершины стали выше S, наверное, высоты должны как-то меняться.
Да, нет.
Потому что, скажем, в самом начале, например, мы ни одного pushа выполнить не можем.
Справиться с этим нам помогают...
Так.
Функция reliable.
Так, смотрите.
Итак, функция reliable от V.
Требования.
Значит, требования пишем.
Во-первых, вершина V – это вершина.
Да, как всегда, не исток и несток.
То есть, исток исток у нас навсегда появится.
Своим, соответственно, местам на стенке.
И что еще?
А, и, конечно, еще важно, чтобы excess от V был больше 0.
Excess?
Да.
Вот.
А.
Нет.
Еще один.
Нельзя выполнить push.
Нигде в графе.
Нет.
Нельзя выполнить push из вершины V.
То есть, по любому ребру из вершины V.
Push от E с E.start равновое.
Ну, то есть, для каждой вершины, если из нее можно куда-то по комнату ребру сделать push, делай push.
А вот когда push нельзя делать, вот тогда возвышайтесь.
Это были требования.
А что делать?
Ну, идея очень проста.
Раз push нельзя сделать, а от избытка надо избавиться, значит, надо просто поднять вершину так, чтобы push выполнить было можно.
Ну, с этим условием, на самом деле, куда ее повышать, в общем-то, все происходит однозначно.
То есть, ну, давайте я вот тут напишу.
Действие.
Вот очень простое.
То есть, h от V просто мы пересчитаем 1 плюс минимум.
Минимум из, значит, соответственно, h от E.finish.
Такое, что E это ребро, торчащее из вершины V.
Ну и, соответственно, EF, конечно.
Не путать, да.
То есть, не в исходной сети, а именно в остаточной.
И, конечно же, значит, по которой можно еще что-то делать.
То есть, когда мы говорим ребра, нас вообще интересуют только ребра, по которым вас что-то пропихнут.
Вот в некоторых терминологиях вообще там считают, что у нас существует только ребра ненасыщенные.
Если они насыщенные, то их типа нет.
Вот.
Ну, то есть, обратите внимание, это все, что мы можем сделать для того, чтобы из этой вершины можно было что-то пропихивать и при этом не нарушить вариант.
Вот.
Так что вот такая ситуация.
Вот.
То есть, ну, по большому счету, то есть, действительно, на самом деле, операция достаточно жесткая.
То есть, заметите, если мы тыкнули в вершину, то из вершины можно, с избытком, можно выполнить только либо push, либо relabel.
Хотя, нет, по-хорошему, на самом деле, еще вопрос.
То есть, как говорится, то есть, на самом деле, теперь вот вопрос о корректности мета-алгоритма.
Вот, предположим, мы делаем, делаем, делаем, делаем вот эти вот, выполняем push и relabel, и потом в какой-то момент выясняется.
Ну, что может выясниться?
Ну, во-первых, да, если выяснилось, что ни одного эксцесса больше нуля нет, значит все, мы поняли, это поток, он максимальный, мы победим.
Ну, теперь у меня есть какая-то вопрос.
А не может ли быть так, что у нас есть вершина, допустим, с эксцессом, для несколько, вот, то есть, есть вершина, но из нее нельзя выполнить ни push, ни relabel?
Нет.
Почему?
Ну, если из нее, ну, давайте сначала, если из нее можно сделать push, то можно сделать push, теперь пусть из нее нельзя сделать push.
Тогда у нее, но при этом у нее эксцесс больше нуля, понятное дело.
Да.
А не если ты, понятное дело.
Да.
А, тогда почему из нее может не быть, может быть невозможно сделать relabel?
Только если поднятие ее высоты, сейчас из нее нет сходящих ребер.
Ну, не нашли все.
Да.
Значит, может ли изменение ее высоты в плюс нарушить вариант на входящих в нее ребер?
Нет, не может.
Нет, на входящих-то не может.
То есть, вот, может быть, действительно, а вдруг этих исходящих из нее ребер нет вообще?
И, на самом деле, вот этот минимум тупо некорректен.
В обстоточной сети всегда есть исходящие ребра.
Э, они насыщенные.
Ну, вот, в обстоточной сети всегда есть ненасыщенные исходящие ребра.
Почему?
Потому что сумма по любой вершине, ну, не совсем ноль сейчас, как это нормально сказать.
Ну, если насыщенное ребро прямое, то ненасыщенное обратное.
Ну, откровенно говоря, да.
То есть, действительно, если, да, то есть, действительно, если у нас у вершины есть избыток, значит, в нее втекает больше, чем вытекает.
Значит, в нее что-то втекает.
О-о-о.
А раз что-то втекает, значит, есть обратное ребро, обратное ненасыщенное ребро, по которому этот поток можно отменить.
Да.
Поэтому, если вершина имеет, соответственно, не нулевой избыток, значит, из нее этот избыток можно куда-то деть.
Ну, в смысле, по камере, существует ребро, по которому теоретически можно было бы деть, если бы это был Сашка.
Да.
Но, значит, действительно, хорошо.
Но, правда, вытекает такой следующий, на самом деле, тоже относительно корректный вопрос.
А почему это не зациклите на бесконечности и у нас не будет двадцать девятой высоты?
Потому что высота не больше, чем 2В.
Наверное. Я очень надеюсь на это.
Почему именно 2В?
Ну, иначе мы до старта не дадим вам ничего такого.
А-а-а, действительно.
Вот, действительно, кажется, что, а вдруг действительно так случится, что эти пушеры, лейбл, у нас будут там действительно выполняться до скончания века и зациклятся.
Вот.
Ну, а, на самом деле, действительно.
Да, очень да.
Но, на самом деле, справиться с этим нам помогает следующий приятный факт.
Значит, такой весьма, может быть, неожиданный, но в нашем случае очень-очень-очень приятный.
Очень приятно.
Значит, мистическое утверждение.
Мистическое утверждение звучит так.
Если, значит, если f, значит, соответственно, предпоток, значит, v, соответственно, неисток и неисток, но вершина при этом, и у нее не нулевой избыток,
то, внимание, в остаточной сети существует путь из v в s по ненасыщенным ребрам.
Ачев.
Что?
Ачев.
Ачев?
Ой-ой.
Ну, и как докажешь?
Ну, она же туда как-то что-то втекает.
И что?
Ну, притекло, откуда есть путь.
И что?
А потом там остальное, а потом те ребра потом притекло, зело и отменилось.
И что?
И почему путь существует?
Что?
Ну, мало ли.
Ладно, хорошо.
Я тоже докажу.
Ну, вот.
Ну, вот.
Ну, да, то есть интуитивно кажется, что действительно достаточно легко, иногда там хочется это просто по индукции доказывать, да?
Ну.
Ну, вот.
Ну, вот.
По пушам или лейблам?
Что после каждого пуша и после каждого лейбла ничего не происходит.
Нет, ну, заметим, что после лейбла, в принципе, ничего не происходит.
Ну, вот.
Ну, да, то есть интуитивно кажется, что действительно достаточно легко, иногда там хочется это просто по индукции доказывать, да?
Ну, вот.
По пушам или лейблам?
Что после каждого пуша и после каждого лейбла ничего не происходит.
Нет, ну, заметим, что после лейбла, в принципе, ничего не происходит.
Ну, вот.
Ну, да, то есть интуитивно кажется, что действительно достаточно легко, иногда там хочется это просто по индукции доказывать, да?
Ну, вот.
По пушам или лейблам?
Ну, да, то есть интуитивно кажется, что действительно достаточно легко, иногда там хочется это просто по индукции доказывать, да?
Ну, вот.
По пушам или лейблам?
Что после каждого пуша и после каждого лейбла ничего не происходит.
Нет, ну, заметим, что после лейбла, в принципе, ничего не происходит.
Ну, да, то есть интуитивно кажется, что действительно достаточно просто по индукции доказывать, да?
Ну, вот.
Ну, да, то есть интуитивно кажется, что действительно достаточно просто по индукции доказывать, да?
Ну, вот.
Ну, да, то есть интуитивно кажется, что действительно достаточно просто по индукции доказывать, да?
Ну, вот.
Ну, да, то есть интуитивно кажется, что действительно достаточно просто по индукции доказывать, да?
Ну, вот.
По пушам или лейблам?
Ну, да, то есть интуитивно кажется, что действительно достаточно просто по индукции доказывать, да?
Ну, вот.
По пушам или лейблам?
Ну, да, то есть интуитивно кажется, что действительно достаточно просто по индукции доказывать, да?
Ну, вот.
По пушам или лейблам?
Ну, да, то есть интуитивно кажется, что действительно достаточно просто по индукции доказывать, да?
Ну, вот.
По пушам или лейблам?
Ну, да, то есть интуитивно кажется, что действительно достаточно просто по индукции доказывать, да?
Ну, вот.
По пушам или лейблам?
Ну, да, то есть интуитивно кажется, что действительно достаточно просто по индукции доказывать,
да?
Ну, вот.
По пушам или лейблам?
Ну, да, то есть интуитивно кажется, что действительно достаточно просто по индукции доказывать,
да?
Ну, вот.
По пушам или лейблам?
Ну, да, то есть интуитивно кажется, что действительно достаточно просто по индукции доказывать,
да?
Ну, вот.
По пушам или лейблам?
Ну, да, то есть интуитивно кажется, что действительно достаточно просто по индукции доказывать,
да?
Ну, вот.
По пушам или лейблам?
Ну, вот.
По пушам или лейблам?
Ну, да, то есть интуитивно кажется, что действительно достаточно просто по индукции доказывать,
да?
Ну, вот.
По пушам или лейблам?
Ну, да, то есть интуитивно кажется, что действительно достаточно просто по индукции доказывать,
да?
Ну, вот.
По пушам или лейблам?
Ну, да, то есть интуитивно кажется, что действительно достаточно просто по индукции доказывать,
да?
Ну, вот.
По пушам или лейблам?
Ну, да, то есть интуитивно кажется, что действительно достаточно просто по индукции доказывать,
да?
Ну, вот.
По пушам или лейблам?
Ну, вот.
По пушам или лейблам?
Ну, да, то есть интуитивно кажется, что действительно достаточно просто по индукции доказывать,
да?
Ну, вот.
По пушам или лейблам?
Ну, да, то есть интуитивно кажется, что действительно достаточно просто по индукции доказывать,
да?
Ну, вот.
По пушам или лейблам?
Ну, да, то есть интуитивно кажется, что действительно достаточно просто по индукции доказывать,
да?
Ну, вот.
По пушам или лейблам?
Ну, да, то есть интуитивно кажется, что действительно достаточно просто по индукции доказывать,
да?
Ну, вот.
По пушам или лейблам?
Ну, вот.
По пушам или лейблам?
Ну, вот.
По пушам или лейблам?
Ну, вот.
По пушам или лейблам?
Ну, вот.
По пушам или лейблам?
Ну, вот.
По пушам или лейблам?
Ну, вот.
По пушам или лейблам?
Ну, вот.
По пушам или лейблам?
Ну, вот.
По пушам или лейблам?
Ну, вот.
По пушам или лейблам?
Ну, вот.
По пушам или лейблам?
Ну, вот.
По пушам или лейблам?
Ну, вот.
По пушам или лейблам?
Ну, вот.
Ну, в чём теперь идея?
Вот.
Ну, идея теперь заключается в следующем.
Казалось бы, что если вы теперь делаете пуш, то тогда, получается, у вас появляется вот это вот обратное ребро.
Нужно посмотреть, что случилось.
Да, какие случились?
Во-первых, мы могли пропушить как раз-таки по этому обратному ребру к С.
Нет, если мы пропушили по этому ребру, к нему есть обратное.
Сейчас.
Ну, вот где пора?
И тогда, действительно, кажется, что вот просто тогда из В в С вот он путь.
Логично, да?
Хотя, да, есть единственное ограничение, что вдруг это ребро лежало вот на этом пути.
Тогда что могло быть?
Тогда единственная проблема, которая может произойти, это...
Ну, тогда вот из В по любому пути есть.
Ну, возникает вопрос.
А может быть, тогда теперь этот путь перестал быть в У?
Вдруг такое?
Вот, действительно.
Ну, во-первых, да.
Ладно, надо еще обговориться, что...
А что на тему других вершин?
Да, но у других вершин, да.
У других вершин был путь.
Был путь, и он остался, потому что мы его не тронули.
Хотя они договорились.
Если только этот путь проходил не через вот эту.
А если он проходил через В, можно сказать, что он доходит до У и идет напрямую к ДС.
Если только это ребро, на этом пути не нужно.
Вот, да. Ребро на пути мы еще не рассмотрели.
Да. То есть, может быть, действительно такое, что этот путь у нас действительно лежит...
То есть, путь, на самом деле, от У до В, он действительно вот такой.
Так, вот внимание и вопрос.
Как говорится, и были там какие-то вершины W, из которых этот путь проходил через вот это ребро?
А потом это ребро бабах отменился.
Да даже у нас сейчас у может перестать быть путь.
Ну да. Ведь может так случиться, что...
Ну, правда, в половине пушей, правда, у перестанет быть избыточной вершиной.
В половине пушей это игрок, я сказал. В смысле, да.
Ну, там, ну, условно, да. Там два случая.
Либо, потому что заметим, что в результате пуши у нас либо стартовая вершина перестанет быть избыточной, либо ребро у нас.
Мы можем усилить утверждение.
А именно?
Что у нас есть поток из У в В, что там, эксцессов?
А вдруг у этой вершины W был поток, и это ребро было важной его составляющей?
Ну, бывает.
Ну, бывает, это проблема.
Да, это проблема.
Собственно, видимо, ровно поэтому тут начинают доказывать принципиально по-другому.
То есть, идея, ну, то есть, на самом деле, достаточно классическая идея.
А именно?
Вот, ну, на самом деле, тоже достаточно стандартная для нас.
Вот, смотрите.
Вот из вершины W по ненасыщенным ребрам дойти до С нельзя.
А теперь идея.
А давайте посмотрим, а докуда можно.
Где-то у нас была уже такая идея, да?
Давайте просмотрим, докуда можно вершины W вообще дойти.
Так вот, так вот, вот так вот, и вот так вот.
Вот.
Вот рассмотрим вот такое множество.
Я его даже назову У-красивое.
Вот, внимание, вопрос.
Что можно сказать про множество У-красивое?
Ну, из него не видят ни одного ребра.
С одной стороны.
Ну, ни одного ненасыщенного.
Но при этом, я вот вычитаю парадоксальную вещь.
В него втекает.
Больше чем вытекает.
Да, больше чем вытекает, совершенно вероятно.
Почему так?
Ну, раз стихососа тут В.
Ну, вот.
У нас в каждую втекает хотя бы столько втекает.
Да.
Одну вершину втекает больше.
Ну, да, просто идея такая.
Давайте просуммируем все эксцессы по этим вершинам.
Вот.
А, ну, правда есть маленькая оговорка.
А вдруг выяснится, что от вершины В можно дойти до Т.
Ну, с другой стороны, в этом ничего страшного нет.
Потому что эксцесс от Т тоже больше либо равен нуля всегда.
То есть, просуммируем все эксцессы.
То есть, как бы, просуммируем.
То есть, перебираем все вершины У-красивом и просуммируем эксцессы.
Это строго больше нуля.
С другой стороны, а что такое эксцесс?
Это сколько...
Ой, слушайте, а правильное ли я вам определение сказал?
Сколько втекает, минус, сколько вытекает.
Я так сказал?
Ага.
А, значит, я не ошибся, да?
Точно, я там минус, прям минус слово писал, да?
Все, хорошо.
Ну, окей.
Значит, я все правильно сказал.
Значит, тогда смотрите.
То есть, что это такое?
Мы должны пробежаться по всем вершинам, просуммировать все, что в них втекает.
А потом пробежаться по всем вершинам и вычесть то, что из них вытекает, правда?
Ну, я могу это все формально порасписывать, но теперь заметим следующее.
Задействованы будут все рёбра, которые как-то связаны с этими вершинами.
Но заметим, что если репро лежит строго внутри множество у, то его вклад взаиму уничтожится, правда?
Потому что он в этой вершине будет со знаком плюс, а в этой со знаком минус.
Понимаете, да?
Или надо просписывать?
Не надо?
Нет?
Вот.
Но тогда остаются только две вершины.
Ну, тогда остаются только рёбра, которые связывают с множеством у изверения.
То есть, тогда останутся только вот рёбра со знаком плюс, которые ведут в множество у, и минус рёбра, по которым вода вытекает.
То есть, никакие?
Нет.
Ну, то есть, вот такие, минус вот такие.
Ну, вот минус таких – 0.
Да.
То есть никакие?
Нет, ну то есть вот такие, минус вот такие.
Ну вот, минус таких ноль.
Да, ну, во-первых, да.
Но теперь, а это, ну вот.
Ну вот, а это же нам уже не важно.
Хорошо.
Почему? Потому что самое главное, что
excess-то больше ноля.
Нет, а это не важно. Кстати, нет, такие не ноль,
потому что сейчас-то мы считали, сколько
воды течет, а не сколько воды можно
протекать.
Ну, мы сейчас что
суммировали? Мы суммировали excess-а.
Excess-а – это не сколько воды
может протечь. Excess – это
сколько воды уже
втекает. То есть,
поэтому могут быть вполне ребра,
по которым вода отсюда вытекает.
Да.
Вот.
Это разная вещь.
Ну а теперь, смотрите. Раз у нас
excess больше нуля, и он равен
сколько воды втекает,
минус сколько воды вытекает, значит
найдется ребро, по которому вода
сюда втекает. Правда?
Ну раз excess больше нуля, да?
Но тогда,
если по этому ребру течет
какой-то не нулевой поток,
значит, существует обратное
ребро, по которому этот поток можно обменить.
Противоречие.
Противоречие с тем, чтобы вот такого
у нас не было.
Вот такая идея.
Лято.
А если бы
S доходило, почему
противоречие бы исчезло?
Потому что у S, да, excess меньше нуля, да.
Именно.
То есть, ну по сути,
то есть, вообразить себе, то есть,
интуитивная идея такая,
что у нас в этом множестве
вершин, да,
то есть, в некоторых вершиков, conex с
Americans, сколько втекает, сколько вытекает, а в некоторых
вода, что там, часть воды застревает.
То есть получается,
что всё это множество, как бы,
засасывает в себя воду.
Но эта вода откуда-то берется?
Берется она только из у我是тока.
Тогда получается, что в это множество
из из толка вода должна как-то попасть.
Ну да. А у нас У это... А, все окей.
Может достижима СВ по остаточному равному?
Не, может что-то мы еще про сумму эти написали. Ну там понятно, что будет что-то больше.
Для В будет что-то больше.
Да.
Ну эта сумма понятна, но с другой стороны мы просто переписываем чему этот excess равен и взауничтожаем его внутри.
Ну вот это была часть рассуждения. Так ладно, давайте формально рассмотрим.
Ну вот просто рисовали, что там можно пройти, потом мы понимаем, что у нас, поскольку сумма excessа больше 0, значит какой-то поток туда входит, значит здесь обратно ребро, значит можно дойти.
Ну там было важно доказать, что существует именно какое-то ребро, в котором вода входит сюда извне.
А нам недостаточно того, что excess больше 0?
У excess.
Ну excess у В больше 0, значит сумма всех excess тоже больше 0.
Правильно.
Это да.
Это что?
Угадит, что что-то входит.
Почему?
Ну мы как бы, по сути это значит сумма всех excess, это excess множество.
Ну это да, но это просто тут как бы надо формально просто говорить.
А, окей, хорошо.
Значит смотрите, давайте попробуем.
Ну формально математически дальше доказательство звучит так.
Что такое вот эта сумма excess?
Это сумма по всем ребрам, значит суммируем по всем e, и соответственно и говорим, что там e.finish лежит в множестве u, значит f от e.
Минус, то же самое, только проста.
Вот.
Ну, пишем, да, ну вот.
Ну теперь заметим следующее.
Мы можем ребра делиться на два типа.
Те, которые целиком лежат, и те, которые целиком не лежат.
Ну давайте я могу даже вот так написать.
Сумма по всем, значит e.start лежит в u, e.finish лежит в u.
Это, значит суммируем f от e.
Плюс сумма по всем e.start не лежит в u, а e.finish лежит.
Это тоже f от e.
Минус.
Теперь раскладываем то же самое.
То есть я просто сумму раскладываю на две суммы.
Больше я ничего не делаю.
То есть тут f от e, и тут f от e.
Значит тут мы пьют, но тут уже на это раз цепляемся, что e.start лежит в u, значит тут e.finish тоже он как бы, он может лежать, а может не лежать.
Так, u и e.finish лежит в u.
Ну если очень внимательно на это посмотреть, то на лицо шлеп-шлеп.
Что остается?
Остается то, что втекает извне, минус то, что вытекает вовне.
Но так как это больше нуля, то тогда получается, что вот это больше нуля, значит найдется ребро, по которому именно извне что-то втекает.
Ну это я в программерской концепции, точнее парадигме.
То есть если писать математически, то это было бы конечно гораздо проще.
То есть как-то короче было бы писать.
Ну во-первых, такую версию вы найдете в кормине, если что.
Вот такую?
Нет, математическую версию.
Ну там было бы то же самое, только эффект был бы в два раза меньше, и тут бы я писал там сумму по всем УВ.
То есть суть идеи на абсолютно та же самая, просто вот здесь она более в нашу любимую программическую.
Так вот.
То есть вот таким вот образом, то есть мы убеждаемся в том, что действительно из вершины В в С путь есть.
Но раз он есть, тогда прямое следствие, что действительно H от любой вершины В не превосходит, ну может даже УЗ, а на самом деле 2В-2.
Потому что Тета на этом пути лежать не будет.
Слишком сильное выживление.
Ага, проверять его мы конечно не будем.
Ну хотя что его проверять на самом деле.
Да, то есть можно совсем прям на 2В-2, то есть ну обычно сейчас доказывают про В-1, на самом деле В-2.
Ну просто потому что рассмотрим путь до С, то есть на самом деле высота вершины В не более чем модуль В плюс количество ревер на этом пути.
А сколько ревер на этом пути?
Ну сколько на этом пути вершин без учета самой вершины, самого истока.
Вершин у нас всего кроме С и Т не более чем В-2, поэтому 2В-2.
Ну с точки зрения асимптотипе конечно вообще не важно, то есть нам уже 2В бы хватило для дальнейших осуждений, но на самом деле 2В-2.
Вот, отсюда конечно вытекает маленький приятный вывод.
Что ну по крайней мере релейблов будет не бесконечное количество.
А на самом деле он даже больше, даже можем уже начать даже оценивать будущую асимптотипу.
Вот скажите мне пожалуйста, за какое время суммарно будут работать все релейблы?
Смотри как мы их реализуем.
Мы будем проходиться по всем ребрам каждый раз?
Да.
Давайте да.
Тогда В квадрат, ВЕ.
Ну на самом деле да, О от В, Е на самом деле.
Да, то есть мы подозреваем что релейбл мы будем реализовывать, то есть каждый релейбл мы будем в честную реализовывать за О от ДЕГАУТ от В.
Ну исходящая степень вершины В.
Ну в остаточной сети естественно имеется в виду.
Может даже аут.
Ну ладно.
Суть в общем понятна, так что получайте суммарно О от В.
Ну кстати должно быть неплохо учитывая что пока мы не умеем искать поток быстрее чем ЗВЕ.
Причем по словам мы я подразумеваю человечество.
Ну просто факт.
Придумайте быстрее, посылайте получайте какую-нибудь премию веселую.
Ну я не знаю дадут ли за это премию не тюрлинга.
Но на сообщество руку вам пожрет конечно.
То есть сообщество порадуется.
Ну вот.
ОТОПЕРИЧА ПУШИ.
Да.
Ну кстати еще важный момент что это суммарное время работы всех.
Вот так я напишу.
Ну вот.
То есть суммарное время работы.
Ага.
Если мы ни один релейбл зря не вызвали.
Ага.
И каждый релейбл еще и увеличил высоту прям реально на 1-2.
А не сразу там?
Нет.
Это оценка сверху.
Только если мы нечаянно не вызываем релейблу.
Который вначале проверяет а можно ли вообще выйти с релейбла.
Ну да.
Ну это не очень.
Ну предположим что мы откуда-то знаем.
То есть я имею в виду что.
Ну так почему это метод релейбл.
Потому что у нас есть как бы мистический черный ящик.
То есть мистический алгоритм.
Который будет тыкать кнопки push релейбл.
Причем он будет гарантировать что.
Когда тычешь релейбл.
Он реально надо делать релейбл.
А когда тычешь push.
Он еще и тыкнет тебе в ребро.
По которому надо делать push.
Да.
Ну еще конечно оговоримся.
Ну вот если мы говорим что о числе релейблов.
Именно сколько раз мы вызываем релейбл.
То там вот во квадрат.
Ну тут конечно есть более сильное утверждение.
То есть если в каждом релейбле.
На сколько он увеличил высоту.
То суммарное увеличение не превосходит во квадрата.
Да.
Ну два во квадрата.
Ну в смысле вот это вот умножить на В.
В смысле на В-2.
И вот.
Короче вот во квадрат.
Но push.
Я пока даже не уверен что они не зацикнутся.
Так.
А вот давайте подумаем.
А как может быть так.
Чтобы push зациклились при конечном числе релейблов.
Никак.
Все доказано.
Никак.
Ну действительно.
Даже push всегда толкает вершину с меньшей высотой.
Да.
То есть между двумя релейблами произойдет конечное число push.
Ну да.
Но это надо все-таки более точно.
Давайте более точно.
Давайте представим себе.
Вот теперь важный момент.
Давайте теперь внимательно представим.
Что происходит между двумя релейблами.
Происходит следующее.
У нас есть вершины расположенные как-то по слоям.
Вот.
И каждый push проталкивает воду.
Собственно строго вниз.
Понимаете да?
Понимаете?
И тогда получается следующее.
Вот я даже сразу на будущее давайте напишу.
Push'а бывают двух типов.
Кстати пересекающие все по характеру.
Я даже вот так напишу.
Насыщающие.
Ну это насыщающие.
Это когда вот этот ребро становится изостаточной сети и исчезает.
И.
Нет вот так напишу.
И не насыщающие.
То есть здесь мы говорим что C, F от E.
Пересекающие, не насыщающие и не насыщающие.
Да, потому что они не насыщающие.
Ну соответственно потому что если ребро не насытилось, значит что произошло?
Значит этот excess от E.start.
Стал нулю.
Значит кончилась вода, которую можно попушить.
Я их не случайно рисую пересекающие, потому что один push может одновременно быть и тем и тем.
Да, и насыщающим и не насыщающим.
Слово не насыщающие, это менее какое-нибудь истощающее, не важно.
Что-нибудь не противоречащее.
Ага, мне кажется что обнуляющие и не насыщающие.
Ну да.
Ну не знаю.
Ну просто нет, обычно говорят не насыщающие и не насыщающие.
О господи.
Ну ладно.
Значит обычно не насыщающие и не насыщающие.
То есть будем считать что насыщающие и не насыщающие это не противоречащие.
Другого слова.
Ну ладно.
Избыто ковнуляющее.
Вот.
Ну а теперь давайте посмотрим.
Вот.
Ну или можно опросить.
Ну то есть я тут мог бы чуть-чуть пересекаться, а можно опросить.
Теперь давайте представим себе вот что.
Сколько насыщающих и не насыщающих?
Ну вот.
Ну вот.
Ну вот.
Ну вот.
Ну вот.
Какие насыщающие проталкивали?
Смотрите, я утверждаю следующее вот между двумя релеблами,
вот предположим вот у вас вот между двумя релеблами
произошло насыщающее проталкивание.
Тогда я утверждаю следующее,
до следующего релебла это ребро, поэтому ребровый пуш никогда не делаете.
И его обратная тоже.
Ну, кстати, да.
Кстати, ровно по этой причине.
Потому что прямо сейчас вы не сможете
по обратному ребру протолкнуть воду,
потому что раз вы сейчас протолкнули, значит
В ниже. Вот, кстати, начинаем
пользоваться высотами.
То есть В ниже.
Пока В станет выше, вы обратно
воду не толкаете, и, как следствие,
это ребро не раздосытится.
То есть получается, между релейблами
каждое насыщающее проталкивание
может быть выполнено не более, чем
один раз.
Ну, всего ребер у нас есть.
Ну, в смысле два есть, но
актуальных всё равно нет, потому что
пара ребер хоть одно, да не актуально.
Поэтому мы получаем, что
насыщающих проталкивание суммарно
не более, чем
ну, там, два вея.
Это прям точная оценка.
За одно
что?
За когда?
Ну, вот,
за всегда.
Ну, потому что мы говорим именно о
насыщающих проталкиваниях.
Как мы уже сказали,
а, ладно, уточняю,
не просто до ближайшего
релейбла, а до ближайшего релейбла
связанного с вершиной В.
Именно с В.
Да, согласен.
Потому что пока вы не повысите вершину В,
она выше его не станет точно.
Может, там, это ребро насытится,
и вы пользуетесь этим возвысить вершину В?
Ну, вот, конечно, но тогда от этого вершины
В всё равно должно стать ещё выше.
Так что именно два вея.
Понимаете, да?
Понимаете?
Вот.
Ну, пока неплохо.
Ну, а теперь начинается самое интересное.
А что с не насыщающими?
Ну, если в хорошем порядке вызывать,
то мало.
Например, сверху вниз
можно вызывать.
Ну, по ситуации.
Вот.
Потому что там тоже может...
Ну, иногда, ну, как сказать,
сверху вниз тут сложно, потому что вы тут
делаете, делаете, делаете, а потом пришлось
релейбла вызывать.
Если внутри одного релейбла делаете их сверху вниз,
то будет от Е тоже.
Ну, как сказать, ну, правда...
Ну, внутри одного релейбла понятное дело.
Да, да, да.
Ну, да.
Ну, порядок, хотя да.
Ну, там, правда, по здоровьем порядок немножко
может меняться.
Ну, понятно, что
между релейблами будет меняться.
От одного между релейбля
до другого.
Нет, понятно, понятно.
Ну, там...
Хорошо, да?
А в общем случае не очень понятно.
Ну, да.
Ну, тут, смотрите, да.
Ну, тогда это, кстати, почему приведет?
Если, да, между релейблами
мы как минимум можем проталкивать
действительно все сверху вниз.
И это получится...
Ну, это какая симпатика получится?
Е на релейбл, то есть в квадрат Е.
Да, в квадрат Е.
Ну, а мы докажем более сильные факты.
Я считаю,
что ненасыщающих проталкиваний
в принципе не будет больше, чем вот в квадрат Е.
Независимо от того,
что конкретно мы пихнули, да.
То есть то, что ты сказал,
это вообще получается просто...
То есть на самом деле еще и будет алгоритм за В квадрат Е.
Кстати, да.
Ну, давайте смотреть,
что получается.
Значит, почему?
Ну, то есть если делать push в рандомном порядке,
то, конечно, будет очень философский вопрос.
Что происходит?
Вот.
Потому что какие-то решины будут
с избыточной, какие-то будут исчезать
из избыточной.
Может быть даже между релейблами может случиться так,
что вершина перестала быть избыточной,
а потом неожиданно
снова стала избыточной,
потому что к ней сверху что-то пишет.
Может быть такое, правда?
Что делать?
Ну, вот. Но тем не менее, значит,
аккуратно рассматривать это можно.
И, собственно,
в этом месте нам приходит
время воспользоваться
такой красивой штукой, как
метод потенциал.
Ну, это не тот метод потенциала, который вот...
А, ну, хотя в общем-то и тот.
То есть мы введем
потенциал. Давайте там
его принято называть.
Потенциал, давайте, phi
от нашей сети
g, g.
Это вот что.
Это мы
просуммируем высоты
у всех избыточных вершин.
Вот такой потенциал.
Ой, надо было его зелененьким
нарисовать.
А вот теперь давайте думать,
как потенциал меняется в процессе?
Изначально он чему равен?
Да.
Чему он еще может быть равен, действительно?
Когда все высоты равны нулю, в принципе.
Ну, не все.
Ну, кроме и стока,
у которого мы избыточный считаем
от слова вообще.
Да, ну, теперь давайте думать,
как изменяет высоты
relabel?
А, увеличивает.
Значит, увеличивает потенциал.
Да, он увеличивает потенциал,
но суммарно он его
увеличивает,
то есть суммарно
плюс
не более, чем
два вайфа.
Мы знаем, что суммарно высот не более, чем два вайфа.
То есть нам нужно только показать,
что каждый пуш, который нас интересует,
увеличивает потенциал,
а каждый, который нас не интересует, не уменьшает его.
Ну, к сожалению,
он уменьшается.
Блин, все, не учу.
Вот тут и проблема, что
вот эта штука, да.
Ну, хотя нет, тут как повезет,
на самом деле.
То есть, на самом деле, да,
то есть, если,
ну,
ну, хотя, да, давайте
внимательно смотреть.
То есть, на самом деле, потенциал может
вполне увеличиваться.
Вот каждая насыщающая,
оно может как уменьшить
потенциал на единичку,
так и уменьшить его на аж, кстати.
Потому что, ну, вот.
Уменьшение потенциала это хорошо.
Ну, это не, ну, смотрите, ладно, давайте, смотрите,
что происходит. Заметим следующее,
что у нас, что мы гарантируем после пуша,
это то, что вот эта высота в потенциал включится,
а вот эта как повезет.
И была ли эта высота включена
перед пушем тоже как повезет, правильно?
Вот.
Ну, давайте смотреть.
Но, заметим следующее.
Если оно насыщающее,
то эта вершина заведомо выключается
из потенциала, правда?
Почему нет?
Потому что она перестает быть насыщенной.
Избыточной, да.
Насыщающее?
Насыщающее насыщает ребро.
Если оно не насыщающее.
А, ну да, да, да. Если оно не насыщающее,
то каждый такой потенциал,
то есть это как минимум,
изменение меньше либо равно,
чем минус 1.
А может и больше.
Может минус а шатку,
если выяснилось, что
эта вершина и так была включена.
То есть и так было испытано.
А что касается насыщающего ребра,
вот давайте я вот себе возьму так.
Вот давайте я возьму
то насыщающее, которое еще и
избыточ не убивает.
Заметим, что оно...
Ну что, может ли оно
увеличить потенциал?
Вполне.
А насколько оно его может увеличить?
На аш-тершины, в которые входят, да?
Ну да. А аш у нас не происходит,
2v.
То есть получается,
ну так и пишем, что
суммарно, то есть оно может
увеличивать на плюс не более,
чем 2v.
Ну минус 2
пишем.
И суммарно
получается
сколько?
4v2e.
Ну то есть у нас есть потенциал,
который растет суммарно
на 4v2e
плюс 2v2.
А вычитается
только вот в таких вот ненасыщенных
ребрах, но каждый раз хотя бы
на один.
Меньше нуля он не становится,
что важно.
Следовательно, он уменьшается
не большее число раз, чем увеличивается.
И отсюда
как раз и следует,
что ненасыщающих
пушень
всего
меньше
либо равно, чем o
от v2e.
То есть это вот больше теперь технический факт.
Как вы не делаете
пушей и релейблы?
Ну конечно вы там можете делать и искать эти пуши и релейблы
за бесконечную секточку, конечно.
Но пушей
всего вы больше, чем v2e
ну от v2e
не сделаете.
Просто и жесткая вот.
А также насыщающих
вы сделаете не более, чем
2e, ну а релейблов
вы сделаете не больше, чем v2e.
То есть вот оказывается,
что технология достаточно
жесткая. Уже на уровне
мета алгоритма, если вы это каким-то образом
проделаете, то пушей и релейблов вы суммарно
сделаете не сильно много.
Ну и в принципе да, как сделать
за v2e?
Ну в принципе да, тут два варианта.
Можно сразу подумать, а можно ли реализовать
технологию, которая вам за 1
будет тыкать носом в каком ребре вы можете сделать
пушь или релейбл?
Ну там это будет какая-нибудь веселая технология
из сыпла. Давайте в каком-нибудь
двусвязанном списке храним все
избыточные вершины,
храним все ребра, по которым там можно
еще что-то делать, ну и там
аккуратненько там в результате
на каждом шаге достаем что-нибудь типа
делаем из списка вершину, избыточную
смотрим, так, есть ли у нее в списке
ребра, о, есть, отлично, значит
давайте делаем пушь,
ну а если нет, давайте делаем релейбл.
Ну теоретически так можно, но утих
оно было проще.
А у тебя был алгоритм, который за
v2e, просто предлагает
следующее, давайте между каждыми
релейблами отсортируем вершины
по высоте, по убыванию, а это
как, кстати, за отвы делается,
обратите внимание подсчетом, да?
Ну не то, чтобы это сильно важно, но
а потом после этого
а потом
после этого делаем, а что
мы после этого делаем?
Да, а после этого мы просто
по сути пробегаемся
после этого мы там
просто сверху вниз, пробегаемся
по всем ребрам, делаем пушь
пока ребра не закончится
ну или соответственно
если избыток не закончился
если избыток не закончился,
то мы в этом месте сразу делаем релейбл
и переходим к следующей фазе
если релейбл
а если избыток
закончился, значит берем следующую вершину
и продолжаем
зацикла не произойдет,
потому что мы
идем сверху вниз, поэтому если у вершины
получился избыток, то до следующего релейбла
избыток не нулевым не станет
так что вот получился еще один
очень простой алгоритм, как можно делать
в квадрате
ну что
если тут еще какие-то вопросы
секунду
идея в том, что мы
от артеровали
все вершины по высоте
пошли сверху вниз
и в каждой вершине делаем пуши
пока можем, когда не можем
делаем релейбл
почему мы не делаем релейбл для каждой вершины?
нет, зачем для каждой?
почему мы за один проход
делаем релейбл не для каждой вершины?
А зачем нам для каждой?
Нет.
Мы как только очередной лекшином сделали релегл, мы все прекращаем эту фазу и делаем все заново.
А почему мы не продолжить?
Потому что будет другая вариация.
Ага.
Нет, если вы еще хотите, пожалуйста, можно и продолжить.
Это корректно.
Ну, в общем-то да.
Это на самом деле метод. Пробежимся по всем лекшинам и пробежимся по всем левым и сделаем все пуши.
А если левушки закончились, часть будет так.
Нет, значит делаем релейну.
Круто.
Моим и собственной релейну.
По-моему, быстро разберем.
Ага.
Да.
Самое смешное, что еще быстрее, чем кажется.
Вот скажите, по-моему, у вас домашних заданий будет это.
Докажите, что если вы перебегаете вершины даже не в порядке высоты, а просто от одного до а.
То это работает на куб.
В куб.
Прям в куб.
Ну, подразумевает, что нет кратных берегов где, конечно.
Понятно.
Вот.
Верю.
Верю.
Вот.
А иначе за VE?
Или что?
Да.
Так.
Сейчас.
А что иначе за VE?
Ну...
Нет, там будет, туда будет V куб плюс VE формально.
Вот так.
Верю.
V куб плюс VE, но если вы сожмете, будет куб и будет кайф.
Вот.
Но если переходить к кубическим алгоритмам, то, как я уже сказал, у нас их в курсе
трое.
Значит, два из них у вас там в теоретическом домашнем задании.
Это ваше задание теоретическое, потому что на практике вы не выздали, что?
Нет, на практике вы сами выберете, какой кубический алгоритм вы захотите написать.
А там есть хотя бы...
Надо узнать домашний, который реально нужно писать, это...
Да.
Ну, реально в каком плане?
У вас уже слишком динец не зайдет.
А, нет, ну это правда.
Ну, потому что очень мало верят, потому что вы динца не запихаете.
Кайф.
Вот.
Сегодня у нас...
Так.
Вот сколько у нас еще?
То есть у нас сегодня еще одно занятие будет.
Да, ну вот.
И соответственно, видимо, на нем мы все-таки будем обсуждать теоремы как заново,
которые покажут, что на самом деле в подавляющем большинстве задач
на самом деле динец, скорее всего, уверенно зайдет.
Интересная теорема.
Ну, вообще, он будет показывать, что на самом деле он будет хорошо заходить.
На самом деле количество задач, когда динец зайдет.
Ну, как сказать, с точки зрения Олимпиад, вообще, динец это там основной алгоритм.
То есть, скорее всего, если нужно писать что-то более не тривиальное,
скорее всего, это там имеет отношение к конкретных задач.
Ну, то есть теоретически, наверное, можно, может быть, придумать задачу,
где там это динец завалится, а именно прифлопуш,
но это какой-то очень, очень внимательный какой-то алгоритм должен быть.
То есть, именно вот, внимательно использовать.
То есть, я, конечно, один раз полноталкивался на задачу,
где нужен именно алгоритм Барувки, например.
А, ой, вы не знаете, сколько алгоритм Барувки?
Это на Рэпе на Миросково?
На Миросково, да.
Было?
Что, уже ничего не помню?
Нет, здесь его не было.
Не было.
Когда мы из каждой компоненты ищем ребро, все ребра добавляем.
Ну, да.
Было же.
Не было.
Не, не.
Нет, был прим, был краска.
То есть, был прим, когда у нас есть одна компонента,
и мы подключаем минимальное ребро.
Не было еще поиски с выдачами кучи?
Нет.
Это не так.
Нет, не так.
Я скажу так.
Был прим, где мы к одной компоненте подключаем одно ребро.
Да.
Был краска, где мы просто сортируем ребра и обведения.
Были там, особенно у прим, огромное количество модификаций.
Да.
Вот.
Да, дело это было, которые там нас в какой-то момент дошли
едва ли не за ОАТВ плюс Е, там, при каких-то условиях.
А тут еще было со сливами кучки.
Да.
Это оно было?
Нет, это другое было.
Нет, это был миностов с ориентированными графами.
Вот.
А.
Да-да-да.
Это когда?
Это два китайца плюс сливаемые кучи равно елоговое.
Да-да-да.
Ой.
Ну а что?
Ну да.
Ну а что такое?
Если есть метод четырех русских, то, наверное, есть алгоритм двух китайцев.
Да.
Ну ничего, ладно.
Когда-нибудь, как говорится, будет алгоритм трех американцев.
Ой.
Так-так.
Значит, что, да, ну вот.
Ну а теперь, значит, возвращаясь к push-re-label, то будет что-нибудь еще.
Ну а то теперь, значит, попробуем, значит, попихать за вакуум.
Ну один из классических алгоритмов, как запихнуть за вакуум.
Ну, конечно, то есть речь будет идти о том, что, конечно же, пуши надо делать как-то более аккуратно.
Ну, то есть более кому-то аккуратно поят.
Вот.
Ну вот, алгоритм, ну, на самом деле, основная его идея зашита уже в название метода.
Название метода relabel to front.
The question is to front of what?
Вот.
Ну, а идея очень проста.
Дело в том, что у нас будет что-то типа очереди.
Значит, будет у нас, смотрите, значит, что-то типа очереди.
Значит, ну метод тоже, действительно, мы будем в некотором смысле проталкивать воду сверху вниз, но не совсем сверху.
Дело в том, что мы будем, оп-оп-оп, значит, оп-оп.
Значит, жила была вода.
Вот она, вот она, вот она, вот она, вот она, вот она.
То есть у нас будет вот такая длинная цепочка вершины.
И гарантируется следующее, что с точки зрения этой цепочки,
все ребра, по которым можно выполнить push,
в чем, когда я говорю на этот раз выполнить push, я говорю буквально, то есть выполнены прям вот все условия.
В том числе на высоты.
Значит, цепочка будет устроена так, что все эти ребра будут смотреть вот так.
Слева направо.
Что это вообще за цепочка?
Вот просто цепочка вершин, из которых мы хотим...
Эти вот синие ребра, это не ребра, это просто...
Да, это просто намек на то, что это односвязный список.
Ну, можно просто посветить.
Вот.
Значит, мы будем идти слева направо.
И делать...
Ну вот.
И делать тотальную зачистку.
То есть мы будем просто перебирать все ребра и смотреть, можно ли сделать push.
Если можно сделать push, делаем.
Если ребра закончились, а 0 xs не наступило,
тогда мы делаем следующее.
Тогда мы берем эту вершину, делаем у нее relabel,
и торжественно отправляем в начало.
Мы идем по вершинам, как-то с куда-то по когда-то.
Нет, просто слева направо, с самого начала и до самого конца.
И в каждой вершине, прям...
Прям, давайте так, пока тупо,
пока прям очень тупо,
делаем, значит,
в каждой вершине, прям,
пока тупо,
пока прям очень тупо,
делаем, значит,
перебираем ребра и пытаемся делать push.
Ну, если она, конечно, xs у нее больше 0.
Если xs у нее равен 0, то ничего не делаем.
Значит, делаем, идем по ребрам,
если делаем push,
и остановится этот процесс либо когда ребра закончится, либо когда избыток станет 0 или 0.
Ну, если избыток стал 0 или 0, значит, мы идем к следующей вершине и продолжаем.
А эту вершину не трогаем?
А эту вершину не трогаем.
Но если у какой-то вершины неожиданно ребра закончились,
а relabel не наступил,
фу, да,
xs нулевым не стал,
значит, мы делаем relabel.
Но когда мы делаем relabel, мы эту вершину торжественно отправляем в начало списка.
Вот такая вот неожиданная идея.
И после этого, кстати, мы теперь
еще раз прибираемся по вершинам, но уже начинает с этой вершины.
То есть дальше, пояс дальше не идет.
Пояс идет сначала.
А, то есть мы не доходим до конца.
Мы каждый раз выкину вершину, опять зеленую начинаем.
Да.
А зеленая стрелочка это просто какое-то ребро или что?
Это, нет, смысл зеленой стрелочки, что мы поддерживаем вариант,
что все ребра, которым можно реально сделать push,
ну, вот со всеми условиями, прямо сейчас прямо взять и сделать push,
то есть все эти ребра смотрят с точки зрения этого списка слева направо.
А изначально у нас какой список?
Ну изначально вершины, просто все вершины расположены в рандомном порядке.
Там нам начать просто потому, что в самом начале вы push не можете сделать в принципе.
Так что вот такая красота.
Правда, остается понять две вещи.
Так, первое самое.
Почему это вообще, ну, во-первых, мы тут заявляли какой-то инвариант,
а почему этот инвариант вообще работает?
Ну, не говоря уже о той мелочи, а почему этот алгоритм вообще работает?
Ну, понять это несложно.
Потому что если мы пользуемся, верим в этот инвариант, что все слева направо,
то тогда это означает следующее, что если тут вот мы прошлись по вершинам и релейблов не было,
то тогда мы гарантируем, что у этих вершин избыток ноль,
и более того, пока мы не выполним релейбл, избытки у этих вершин ни нули, ни выми, ни станут.
Потому что все дальнейшие push, они будут такими же, как и мы,
они будут отправлять воду вот куда-то, туда-туда-туда.
Понимаете, да?
Тогда получается, что этот процесс, если мы поверим в инвариант, конечно,
получается, что каждый проход по списку у нас заканчивается либо релейблом,
либо мы дойдем прямо вот до конца,
и тогда это будет означать, что мы прошлись по всем вершинам
и гарантируем, что теперь у всех этих вершин избыток нулей.
А это, как вы помните, в точности означает, что мы нашли поток и мы победили.
Понятно, да?
Понятно, да.
Так вот.
Да.
Нет, он уже за куб работает, если мы верим в инвариант.
За куб?
Потому что?
Потому что каждая фаза работает.
Ну, если мы верим в инвариант...
А, за В квадрат Е.
Да, пока каждая фаза работает за В Е. Пока.
Вот.
Но давайте пойдем по инварианту сначала, чтобы подумать, как эту В Е допилить до куба.
Просто идея, теперь следующая.
А почему этот инвариант вообще работает?
Давайте посмотрим, значит...
Ну да.
Что происходит при лейбле, что происходит при пуше.
Ну, во-первых, заметим, что если мы вот дошли уже до этой вершины,
то вот этих вот ребер, обратите внимание, которые ведут откуда-то отсюда, куда-то дальше,
их уже нет.
Почему их нет?
Потому что все эти вершины перестали быть избыточными.
А у пуши есть такое маленькое условие, что пушь делается только при избытке.
Понимаете, да?
Да.
Поэтому получается, что самое главное для нас, по сути, нам надо было доказать,
что при вот этом рейлейбле этой вершины в нее не ведет хороших ребер.
Вот мы и показали, что их не видел.
Потому что из этих вершин вообще никаких адекватных ребер не видел.
Ну правда, могли, конечно, появиться после рейлейбла адекватные ребра, ведущие в эти вершины,
но, собственно, ровно с этой целью мы ее в начало и перекинули.
Ну а все остальные, у всех остальных вершин высоты не поменялись,
поэтому, собственно, все избытки не поменялись,
поэтому, собственно, все пушевости все равно остаются слева-направо.
Поэтому получается, что их вариант коррективен.
Вот.
Понятно?
Вот, да, нет, наверное.
Сейчас.
Почему, если мы делаем пуш по рейбру слева-направо, не появится рейбро справа-налево?
А, потому что рейлейбла не произошло, окей.
Нет, вообще непонятно.
Понятно.
Почему у нас не могло нового рейбра?
Да, действительно.
Так, да, действительно, в таком варианте, да,
что если мы просто так говорим, что если-то тогда мы можем сделать пуш,
и тут появится какое-то, ну вот, какое-то адекватное рейбро,
в котором этот пуш это реально можно сделать.
Так.
Так, все сделано.
Хорошо.
Хорошо.
Действительно.
А насколько нам тут прям принципиально, что эти вершины перестали быть избуточены?
Очень.
Прямо очень.
Ну, почему не могу попросить такого, что мы сделаем пуш по рейбру, вершина направо какой-нибудь,
и из нее появится рейбро вообще хоть куда-нибудь.
У нее станет excess 0.
Да, теперь.
Да, но есть одна маленькая проблема.
Что означает, что был адекватный рейбро?
Ну, допустим, вот мы скажем, что рейбро называется хорошим,
то есть там пушером, если в нем выполнены все условия пуш,
кроме, может быть, избыточности вершины.
Ладно.
Кроме, может быть, избыточности вершины.
Тогда смотрите какая ситуация.
Чтобы было, существовало вот такое рейбро УВ,
тогда должно быть выполнено, что h от У равно h от В плюс 1.
Но если бы выполнили рейбл УВ, значит, высота-то строго увеличилась.
Высота-то строго увеличилась.
Ну, это в этом.
Потому что высота-то строго увеличилась,
а значит, это рейбро, даже если оно было хорошим,
ровно в момент релейбла, хорошим быть перестало.
Можно пошагом еще раз, где у нас вообще было доказательство того,
что у нас все рёбра всегда будут вести слева-направо.
Нужно проверить, чтобы все пуши и все релейблы
не создают рёбры, ведущих справа-налево.
Но не всех рёбр.
Нас интересует не все рёбра.
Нас интересует только ненасыщенные рёбра,
то есть ненасыщенные рёбра,
торчащие не из устока,
и у которых разность высот между стартом и финишем равна ровно 1.
Нас интересуют только эти рёбры.
Теперь смотрите.
В результате пуша таких рёбр, конечно же, не появляются.
В результате пуша появляется только обратное рибро с разностью высот минус 1.
А почему у нас может...
Сейчас, есть еще одно условие, что excess больше 0.
А вот это условия у нас больше нет.
Нас интересует рёбра, у которых разность высот 1,
и у которых ненасыщенные рёбры.
Вот это условие нас сейчас не интересует.
Вот.
Теперь смотрите, какая ситуация.
Это было хорошее рибро.
При пуше у нас появляется только обратное рибро с разностью высот минус 1.
И в результате чего получается хорошо.
В результате чего получается, что это рибро имеет разность с высот минус 1,
и как следствие, хорошим пушем он на текущий момент не является.
Теперь осмотрим релейбл.
Вот смотрите, шли мы тут по списку, шли, и появился релейбл.
Теперь давайте думаем.
Значит, что поменялось?
Ну, во-первых, конечно, из этой вершины могли появиться хорошие рёбра, теперь торчащие куда-то сюда.
Но с ними никаких проблем нет, потому что мы как раз эту вершину вначале пихаем.
Всё, что нам надо показать, это то, что у нас теперь нет.
Нет хороших релейблов, которые ведут в вершину V.
Ну, смотрите.
Но смотрите, тут заметим, что в результате релейбла у нас ребра не появляются и не исчезают.
Но заметим вот что, предположим, что было перед релейблом хорошее ребро.
Нет, хотя нет, было.
Хотя нет, не появляются и не исчезают, это неправильная формулировка.
Я имею в виду, что ребра, насыщенность ребра не появляется и не исчезает.
А теперь предположим, что было какое-то ребро.
Было ненасыщенное ребро, ведущее откуда-то слева.
Ну, справа вести не могло, да?
Было вот слева.
Но для того, чтобы оно было пушевым, оно не только должно быть ненасыщенное, а ещё должно быть выполнено, что h2 должно быть равно hv плюс 1.
Это должно быть выполнено после релейбла.
Это должно быть выполнено перед релейблом, потому что это часть инварианта.
Я не понял.
Часть инварианта.
Я не понимаю, что мы докажем.
Что инвариант сохраняется.
При релейбле.
Для этого инвариант – это отсутствие хороших ребер справа налево.
Да.
Вот мы думаем, откуда они могли появиться.
Могли они появиться только из-за того, что у нас есть какое-то хорошее ребро.
Не хорошее, а которое стало хорошим.
Или сейчас что?
Которое может быть стало хорошим.
У нас у v менялся h только что.
Оно могло быть плохим, стать хорошим.
Нет? Я не понимаю.
Окей.
Так.
Так, ну хорошо, ладно.
После того, как вы пишите h от u или h от v, вы понимаете, что h только что поменялось.
Какой именно h вы видите?
Так.
Так.
Так, хорошо.
Значит, у нас неожиданно в результате релейбла появилось ребро.
Из uv, да?
Ага.
В котором выполнено это ребро e.
И мы знаем, что пропускная способность этого e cf от e больше нуля.
А еще мы знаем, что h от u прямо сейчас равно h от v плюс 1.
Это правда.
Да.
Только маленькая проблема.
А теперь что было непосредственно перед релейблом?
А перед релейблом непосредственно h от v был еще меньше.
Да.
То есть у нас было ненасыщенное ребро, у которого разность перепад высот был больше чем 1.
А, ну да.
А это противоречит просто, извините, исходно заданной технологии.
Такого у нас типа не было.
Вот и все.
Вот.
То есть таким образом этот алгоритм работает.
В том плане, что вариант корректен, следует на рано или поздно все релейблы закончатся.
И он там один раз пройдется по всем вершинам, все пропихнет, скажет, что релейблов не было, вода закончилась.
Ура да здрасьте.
Но единственная проблема, что этот алгоритм пока все еще работает за v2e.
Но на самом деле, ну почему за v2e?
А почему за v2e?
Потому что суммарно все наши вот эти вот проходы, каждый проход работает за v2e.
А проходов у нас...
Ага, кстати, v2 проходов и каждый проход работает за v2e.
А, просто за e, за e, да.
E и v2.
Но на самом деле возникает следующая идея.
Сейчас у нас будет, может быть на самом деле, который вырастает просто в надстройку над push.relay.
А идея следующая, смотрите.
Вот жила-была вершина, да?
Жила-была вершина.
Была она избыточной.
И чтобы избавиться от избытка, вы стали перебирать ребра.
Перебирали, сделали push.
Сделали push.
Сделали push и избыток закончился.
А потом в какой-то момент избыток появился.
Теперь возникает вопрос.
Если при этом, тогда возникает вот этот вопрос.
Имеет ли смысл, когда мы сейчас второй будем делать проход, рассматривать вот эти ребра?
Ну, в общем случае, конечно, да.
Ну а теперь маленькое уточнение.
А теперь давайте себе представим, что между этими двумя попытками что-то пропихнуть relabel не вызывался.
То есть, смотрите, если вы делали чё-то, попихали, избыток закончился, а потом вы захотели, появился ещё избыток, но relabel не было.
А, ну, собственно, если появился избыток, то, очевидно, и relabel быть не могло, да?
То я утверждаю, что надо начинать перебирать ровно с того ребра, на котором вы остановились передать.
Потому что с этими вот ребрами они все либо нам не подходят, а если они нам не подходят по высотам, то подойти по высотам всё равно не могут, правда?
Вот.
Ну, либо это были, то есть, если они нам подходят по высотам, то они были насыщены.
Понимаете, да?
То есть, и без там relabel-ов они не разносытятся.
То есть, а если оно было насыщено, а потом разносытилось, значит, эта вершина стала выше, чем V.
И, соответственно, пока мы не сделаем relabel от V, ничего не поменяйте.
Понятно, да?
А пока, вообще, это могло произойти, тогда мы можем между, ну, в принципе, в нашем окреплении, потому что, тогда мы можем к одной вершине два раза пройти между двумя relabel-ами.
Если избытки маленькие, а ребр много.
И что?
То есть, если как бы спрос, меньше предложения.
Ну, смотри.
Вот наш лагеритм. Мы идём, идём, идём, пихаем.
Мы же не могли пихнуть влево.
Влево не могли.
Значит, мы пихаем только вправо.
А что такое влево-вправо?
Вот у нас же есть список.
Нет, слушай, вот от списка сейчас можно абстрагироваться.
Хорошо, ладно.
Я имею в виду именно как relabel самой вершины V, потому что могли быть вызваны, потому что между этим фактом могли быть вызваны relabel от вот этих всех вершин.
А, то есть нам нужно именно relabel у V.
Именно V. Именно V.
Ну, то есть, заметим следующее, что у нас в каждом из ребра есть ребра.
Некоторые из этих ребр, некоторые из этих ребр имеют перепад высот больше одного, но, как следствие, они насыщены.
Некоторые имеют перепад высот ровно один, а некоторые имеют перепад высот какой-то неположительный.
Но заметим, что если какое-то ребро имеет перепад высот неположительный, то пока мы не вызовем relabel от V, он так и V мы останемся, правда?
Поэтому если мы какое-то вот просмотрели ребро, увидели, что у него перепад высот какой-то неположительный, значит мы говорим сразу до свидания.
Понимаете, да?
Понимаете?
Вот.
Значит, да.
Да.
Значит, могло ли быть так, что какое-то ребро...
Но если ребро было насыщенное, то до ближайшего relabel V его тоже бесполезно рассматривать.
Почему?
Да потому что, если это ребро было насыщенным, в том раз насытилось, значит его конец имеет высоту на один больше, чем у вершины V.
Значит, до relabel V мы его все равно не оприходуем.
Остаются только ребра, у которых разность высот ровно один.
Ну что с ними происходит?
Мы либо по ним делаем push, то есть в процессе, может быть, мы его прошли мимо, да?
Но если мы его прошли мимо, то оно, значит, было либо насыщенным, и тогда, смотри, предыдущий пункт.
Вот.
Ну еще периодически бывает, что у ребра разность высот меняется.
То есть прежде, чем мы по нему...
Но, правда, если мы тут прошли мимо него, уже дальше мимо него прошли, то тогда это ребро просто уже было насыщенным, да, с собой не интересует.
То есть все пройденные ребра либо насыщенные, либо не подходят и не подойдут в высоте?
Да, совершенно верно. То есть, если они насыщенные, то они нам уже точно не подойдут до relabel V.
И, соответственно, либо...
А почему-то они могли быть...
А, понятно.
Либо они нас просто не подходят по высотам, и тогда, значит, тем более по высотам они будущим нам тоже не подойдут.
Есть еще один вариант.
Но если бы у нас было ребро в вершину очень маленькой высоты, и у нее потом поднялась высота для подходящей, то, казалось бы, появилось новое ребро, но такого просто не бывает, потому что...
Нет, просто если...
Сейчас.
Если разность высоты у ребра очень большая больше одного, то это значит, что оно тупо насыщенное.
Да.
Иначе противоречие бы было.
Да.
Поэтому, на самом деле, этот случай, можно сказать, уже рассмотрен.
То есть, оно либо насыщенное, либо...
Ну, короче, либо насыщенное, либо...
То есть, либо насыщенное, либо не подходит по высотам, потому что высота этой вершины слишком большая.
То есть, либо мы его насыщали, уже насыщали.
Да.
То есть, получается, что идея как в алгоритме денется теперь.
То есть, на основе этого.
Давайте просто в каждой вершине, в списке смежности храним, когда мы ближайшую серию пушей будем делать.
Вот.
То есть, так не когда, а начиная с кого.
Да, обратите внимание.
То есть, начинать надо строго со того же ребра.
То есть, в том плане, что если вы сделали пуш, по этому ребру остановились, значит, в следующий раз, возможно, вы по этому же ребру еще пуш сделаете.
Ну, могло так случиться, что просто это...
То есть, это, наверное, был не насыщающий пуш.
Ну, там, типа, прописанная способность ребра 10, а избыток был 3.
Тогда вы как бы все, избыток закончился, у вас тут еще 7 осталось.
Тогда, когда в следующий раз избыток у вас тут появится, вы сможете сделать еще.
Понятно?
Да.
Вот.
На основе этого, то есть, на самом деле, это уже превращается в технологию.
То есть, знаете, будет очень здорово, если вы в коде даже отразите это в рамках правильного наследования классов.
Что?
Ну, потому что, смотрите.
Какие классы?
Ну, какие? Ну, классы, все плюс-плюс, и есть классы.
Вот.
Что, не знали?
В смысле, где здесь классы?
Кому наследуют?
Наследуем в алгоритме.
Ну, потому что, смотрите, у вас есть метод-алгоритм.
Класс-алгоритм.
У вас есть метод-алгоритм.
То есть, метод-алгоритм.
В принципе, набор алгоритмов, но все они умеют делать только push, relabel, и в самом начале делают вот это.
Поэтому, крайне естественно, в этом месте реализовать класс,
у который, значит, там, в конструкторе принимает себе на вход сеть, делает вот все вот эти операции,
а дальше, предоставляет вам доступ только push и relabel.
Ну, ладно, может быть, там еще в качестве ридонли предоставляет вам доступ к ребрам и вершинам.
Вот.
И тогда, ну, вот.
Но тогда у этого тут, у него тогда возникает виртуальный метод run,
и все алгоритмы тогда, использующие технологию push, relabel, должны быть его наследоваться.
Тебе это просто кажется хорошей идеей, когда ты это писал?
Ну, собственно, я, ну, даже не я.
Куча ваших предшественников писал, и это было очень красиво.
А почему я делаю?
И кто-то заставлял?
Да.
Блин.
Ну вот.
То есть, более того, там хорошая, на самом деле, длинная цепочка.
Потому что сейчас мы от этой технологии еще технологию последуем.
Технологию, вместо технологии push, relabel, мы делаем технологию discharge.
То есть, мы теперь вместо этого говорим.
То есть, у нас такой металгоритм будет такой.
Мы теперь выполняем не в некотором порядке push, relabel,
а в некотором порядке будем вызывать функцию discharge.
Значит, что делает функция discharge?
Вот ровно то, что мы описали на самом деле.
То есть, мы для каждой вершины храним вот этот вот мистический итератор.
То есть, мы для каждой вершины храним вот этот вот мистический итератор.
Вот, понимаете, да?
То есть, у нас там есть условные массивы.
Current Iterators.
Current Iterators.
Current Iterators.
То есть, он указывает, значит, когда мы в предыдущий раз у нас делали какую-то серию этих push, relabel,
мы говорили, собственно, где у нас мы остановились.
И, соответственно, функция discharge
принимает на вход вершину V,
которая гарантирует, что V, естественно, не исток, и не сток.
И, что она еще делает?
А, ну и, конечно же, еще гарантируется, что она избыточна.
И делает она вот прям буквально в следующем.
Можно прям в ход написать.
Значит, while, говорим мы,
значит, оказалось, что там, условно, excess от V больше нуля.
То есть, пока она избычная.
То есть, send discharge-я ликвидировать избыток вершины V.
Ну, мы сейчас будем пользоваться тем, что мы всегда можем сделать из вершины либо push, либо relabel.
Понимаете, да?
И вот мы это будем делать так.
Значит, мы говорим,
значит, если current iterator,
если текущий вот этот итератор от вершины V
valid,
ну не на end или что?
Ну да. Но помните, мы же описывали, что у нас конкретно тут вот этот итератор, вот у нас две недели назад было вот это описывали,
что у нас этот итератор с методами там valid и next.
То есть, это не совсем то, что мы делали в этом видео.
Раз вы посмотрите, мы так вот делали,
описывали, что у нас это итератор с методами
Valid и Next.
Да, то есть это не совсем классический C++ итератор
прям в классических концепциях, но
мы обсуждали, что такие итераторы тоже есть во всяких этих наших чанах.
У нас после BKL двоеточие, это реально попало на C++?
Ну, все доказания.
Да, но не говоря уже о том, что, дайте, тут понятно, что подразумевается, что вам надо еще
эти XS сохранить, то есть, возможно, там проталкивание потока
в сети вам придется тоже как-то перегрузить.
Ну, в том плане, что у вас там будет свой метод, который говорит,
так, ладно, значит, поток-то тыкни, а XS еще и пересчитай.
Ну, прибавь вычете W, чтобы было удобно.
Ну, тем более, что в Аше еще там где-то будут.
Поэтому понятно, что это все-таки в определенной степени псевдокод.
Значит, если итератор Valid,
вы говорите,
значит, если
мы можем сделать push
по вот этому вот, так сказать, итератору,
точнее, по его звездочке, так сказать,
ну, что тогда? Тогда делаем push.
Короче, не буду.
Ну, а в противном случае,
тогда мы говорим, что это вот безобразие,
значит, currentIterators,
pushConnects.
Ура!
Ура!
Но это все, если
итератор еще на что-то указывает.
В противном же случае
мы говорим,
то есть вот, обратите внимание, очень важно,
будет у вас большой соблазн next делать всегда, даже если push удался,
но, боже, у вас упаси это делать.
Потому что если вы сделали успешный push, может быть, как я уже сказал,
выпустился,
а избыток закончился, а ребра нет.
Поэтому, возможно, в следующий раз надо будет делать push.
В противном случае, значит, если же
ребра все-таки закончились, то вы объявляете
relabel от V,
ну, и, конечно, этот итератор,
theIterators от V
равно,
ну, там, в нашей технологии называлось
network.begin от V.
Все.
То есть вот такая вот технология.
То есть вот просто, то есть, заметим, что
мы можем, в принципе, десчать все, даже не привязываясь
обязательно к relabel по фронту.
То есть, на самом деле, можно просто объявить такой
второй металгоритм.
Такой продвинутый металгоритм.
Такой продвинутый.
Отличие будет только в том, что
вместо push и relabel мы будем вызывать
только десчать.
Ну, и
вот,
и
если даже забыть про алгоритм relabel
to front,
то теперь давайте мы о нем забудем и предположим, что мы
выполняем вот этот продвинутый металгоритм.
Вот как вы думаете, за какую ассинтотику он
работает?
Ну, в предположении, что мы
считаем только то, что делает
десчать.
В смысле? Мы проходим по всем вершинам,
в каком-то порядке.
Нет, имеете в виду, что на каждом шаге на какой-то черный ящик
говорит, сделайте десчать отсюда.
И там десчар сделать возможность?
Вы купили?
Ну, не совсем.
Ну, на самом деле, я бы так сказал. Дело в том, что
десчать делает, ну, кажется, что
каждый десчач суммарно делает от
количества, там,
для каждой вершины он делает
от количества оттачащихся у нее ребер умножить на
количество relabel у этой вершины.
Вот кажется, что суммарно десчать делает именно это.
Но это, к сожалению, обидно, что это только кажется.
Потому что, как я уже сказал,
есть одна маленькая подлянка, что
может быть очень много десчачей
по одному и тому же ребру.
Помните, да?
Ну, слет укажется.
Но на самом деле можно оценивать так.
На самом деле я бы сказал так,
что когда вы проходите мимо ребра,
то есть у вас, смотрите,
десчачи бывают двух типов.
Те, которые вот дальше этого ребра так и не
двинулись, прям сразу сделали push и закончились, да?
И все остальные. Но все остальные действительно
делаются завыде. Ну, в смысле,
для каждой вершины за степень вершины умножить на количество relabel, правда?
Ну, потому что
от каждого ребра перейти к следующему
все равно не более, чем бы раз делаете, правда?
Понимаете, да?
Поэтому на самом деле я могу сказать,
что вся эта технология, в некотором смысле,
будет работать за вот какую симпточку.
За VE плюс количество
десчачей.
Более того, кстати, мы можем даже
ослабить требования и сказать, что черный ящик
иногда делает десчачи и от неизбыточных.
Они будут работать за 1 единица.
Да, но они тоже будут работать за 1 единица,
просто выпросившись в этом мае сразу.
Понятно?
Отлично.
Ну, теперь единственная оговорка,
понятно, что сам алгоритм будет еще работать
за VE плюс количество десчачей, плюс сколько времени
делится, а куда десчач делать вообще.
Но давайте внимательно смотреть, давайте проанализируем
relabel-to-front.
Идея теперь, настоящий relabel-to-front,
прибегается по всем вершинам, и из каждой из них
требует именно десчач.
Но еще если десчач.
Да, ну и соговорка, что если в результате
десчача был выполнен хотя бы один relabel,
а ведь заметим, кстати, что
внутри десчача одна и та же вершина,
может быть, relabel-to-next, раз и даже не два.
Ну, потому что relabel-ли,
пропушились, еще relabel-ы, пропушились, но здесь
большой из бытов был.
Вот.
Значит, gel был десчач.
Вот.
И тогда получается,
но тогда получается, что мы в каждом моменте,
ну вот, то есть мы говорим, что если высота уменьшилась,
то тогда мы эту вершину перетаскиваем в коль.
То есть в общем-то, то есть получается, в общем-то заметим,
эту операцию мы все равно делаем взау от единицы, правда?
То есть по сути мы сейчас все действия,
которые мы делаем, мы по сути вот в количестве десчарджей
они умещаются, ну кроме своих десчарджей.
А теперь внимание вопрос, сколько десчарджей?
Мало.
Ну мало это сколько, давайте так, проходов, вот сколько у нас
проходов вот таких произошло?
Не более в квадраты.
Каждый не более в 10 отживей. Да, не более, да.
То есть действительно так, не более в квадрат, совершенно верно.
Потому что у нас relabel-ов не более, чем в квадрат.
Но внутри каждого прохода не более, чем в десчарджей.
Потому что у нас совершенно не более вв.
Так что получается, что конкретно в данном случае
действительно нам удалось таки достичь кубической силы.
Вот такая вот десчарджистая технология.
Понятно? Да.
Если у нас есть кратные рёбра, верно, что мы всегда их должны сжать?
Да, но с точки зрения потока вообще да.
То есть мы уже говорили, что их можно сжать,
причём даже можно за В квадрат, можете за В плюс Е их на самом деле сжать.
Ну да, но главное потом в конце не забыть вспомнить,
что у вас на самом деле их потом надо сжать обратно.
Да, ну то есть понятно, математически это не интересная задача,
но технически вам придётся это делать.
Но редко, правда, это реально приходится делать.
Но тогда после, ну вот ровно имея в виду это обстоятельство,
обычно считается, что кратных рёбр нет,
и поэтому идеи не превосходят туда квадрата.
И поэтому и пишут, что алгоритм работает за В.
В общем, заметим, что, как вы будете писать в обложке,
что алгоритм пишет очень несложно на самом деле.
Ну, просто чем это приятен?
Алгоритм тем, что, ну как бы технология,
ну то есть вот тут простой код инициализации,
простой код пуша, простой код релебла,
там простой код дисчачи,
а всё остальное это простое использование вот этой инфраструктуры.
То есть подобное ощущение у вас могло быть,
когда вы там писали декартовый деревья, например.
Ну в том плане, что когда вы уже написали сплит и мёртвый декартовый деревья,
то там все остальные действия там будут в основном сводиться к
собственно, аккуратному, правильному вызову сплитов и мёртвей.
Каждую задачу сплит можете свои, к сожалению.
Ну да.
А в данном случае вот, а здесь нет.
А здесь заметим, что пуша и релебл особо не меняются.
То есть вы просто можете их разными алгоритмами по-разному менять.
То есть, в общем-то, из трёх алгоритмов это может быть даже самый сложный.
Из трёх, которые сегодня были?
Нет, из трёх...
А какими два? Это Деница и Эднон?
Нет, остальные... Нет, я имею в виду, что у нас в пульсе есть три алгоритма ЗВКуб на основе технологии.
Один вот мы рассмотрели сейчас, два у вас там как минимум в теоретическом домашнем задании.
То есть вот вам алгоритм, докажите, что он работает в ЗВКубе.
В общем, там первый алгоритм будет...
То есть первый алгоритм там будет что-то в духе...
Что-то в духе... Изначально у вас есть там условно какая-то очередь.
Ну даже не условно, а просто у вас есть очередь.
И в очереди в каждый момент времени находятся избыточные вершины.
И вы говорите, пока очередь не пустая.
Достаете из очереди вершину, делаете из неё тишчач.
Достаете из неё тишчач.
При этом, если в процессе...
То есть если в процессе ещё оказалось, что вы там сделали какую-то...
Там какая-то вершина перестала быть избыточной, стала неожиданно избыточной,
значит пихайте её в очередь дальше.
Вот. Оказывается, уже такой метод работает в ЗВКубе.
Но если не это слишком сложно...
А это сложно, потому что вам придётся вот это...
То есть это картоне пушка, где тишчач ещё допиливает в этом месте, да?
Есть ещё более тупой метод.
Значит говорите, пока есть избыточные вершины,
тупо пробегаемся по всем вершинам и с каждой пытаемся делать тишчач.
Прям тупо фор и от одного до энд, тишчач отбили. Всё.
На каждом шаге...
На самом деле на каждом шаге можете хоть рендом шахл делать.
Главное на каждой фазе пробежать все вершины.
И это тоже оказывается.
Может быть не так тривиально доказать, но написать это прям совсем элементарно.
То есть на самом деле вот такая вот крутая технология,
как из крепичков собрать себе крутой лагерь.
Так, есть тут ещё какие-то вопросы?
Денис за сколько работал?
Денис? Ну пока в Эквадрат Е.
В Эквадрат Е ещё было прикольно.
Ну там были продвинутые, типа там ВЕЛОГВ, а вот эти все, да.
Вот этот Денис с линкатом.
Вот это вот.
Вот, что ещё было? Ну вот.
А, ну потом мы обнаружили, что если графы какие-то целочисленные, особенно единичные,
то Денис начинает работать сильно быстрее.
За ЕКР не из Е.
А ХОПНОТ, а про сочетание ищется вообще за ЕКР не из В.
Ну и с прочими там этими приколами, типа теория выгоняли у КАП.
Кстати, там не работает оценка, что работает за ЕКР не из Э.
ЕВР АККРАТ НЕИЗЕ, что это?
А ЕКР не из Э. Нет, ну можно ЕКР не из Е сказать, а можно сказать, что...
Это в каком случае?
В единичной сети.
Да, Денис единичный сети.
Единственного работы за ЕКР не из Е.
Можно.
Это покрывает обе оценки?
Ну, на самом деле, да.
Но обычно же мы любим писать оценки
всё-таки от V и E,
а не от какого-то там бистического потока.
Пусть конкретно в данном случае.
Ну, в принципе, да, E, K, Ne, F, D.
Хорошие, без более негрых.
Но на самом деле,
сейчас после перерыва мы, видимо, вернёмся
к этому всему и докажем там
ещё более экзотические оценки и подобное.
Пользуясь подобным же методом.
Вот. А это есть, просто,
две теоремы как заново.
Вот. Да, мне тоже не нравится.
Так что, а пока перерыв.
Значит, смотрите, давайте возвращаемся
в сладостычирующий и упалительный мир
концепцией блокирующих поток.
И целочисленных сетей.
Значит, наша цель...
Ну, вот, но мы уже научились говорить,
что в единичных сетях мы уже умеем
доказывать, что количество фаз будет
не более, чем, ну, например,
О от корень из Е,
ну, или, как правило, техно-дрейтал,
О от корень из Ф, на самом деле.
Если внимательно пугаться.
И это ключ.
Потому что всё равно в единичной сети
поток больше, чем О от Е, не будет.
Но!
Но, помимо единичных сетей,
есть просто целочисленные сети.
Можно, конечно, оценить
количество фаз, именно количество фаз,
как О от корень из С,
на Е.
Ну, причины ровно те же.
Вообразим в себе каждое ребро
пропускной способности С, как С-рёбри
пропускной способности А.
Вот.
И доказательство будет, что фаз будет
О от С. То же самое доказательство.
Там каждый динец будет
работать тоже за О от С, Е,
на каждой фазе. Поэтому получится,
что у вас при желании, в общем случае,
алгоритм динца будет работать
вот такой симпатии.
Но, на самом деле, часто количество
фаз можно оценить и сильно лучше.
И предлагается делать это вот.
Мы введём опять потенциал.
И это будет
другой потенциал.
Нет. Мы считаем,
что пропускные способности целочисленные
и все от одного до С.
Впрочем, в первой тери нам это не понадобится.
А понадобится вот что.
Значит, итак, пусть
А определение пишет.
Пусть В это не исток и несток.
Тогда,
значит, смотрите.
Тогда мы объявляем
П, значит, потенциал входящий.
Это просто мы субмируем
сколько в неё
теоретически воды может войти.
Пишем С от Е.
Где Е это ребро?
И где С?
С от Е.
То есть он констант.
Да.
То есть наша цель не в процессе
что-то оценивать.
А вот попробовать посмотреть на Сите,
грубо прикинуть, а сколько там у неё вообще
фаз может быть.
Значит, это П входящие.
И, конечно, есть потенциально П исходящее.
А сколько вообще теоретически может выйти?
Вот.
Но на самом деле нам интересно
даже не столько эти две величины,
а их минимум.
Почему именно минимум?
Да по той причине,
что на самом деле этот минимум
имеет такую интересную функцию,
а сколько воды вообще может
протекать через вершину В в принципе?
Ну как-то логично, да,
что если, например,
в вершину входит 3 лебра,
единичные, а выходит 10,
то наверно всё-таки больше чем 3 единицы воды
наверно вытекать из этой вершины не будет.
Поэтому нас это интересует.
Это будет называться
потенциал вершины.
Ну это можно назвать входящий потенциал и исходящий потенциал,
но мы этим даже пользоваться не будем.
Это будет потенциал вершины.
И теперь ещё одно важное определение,
теперь вводим потенциал сети.
Потенциал сети.
Значит, P,
ну в смысле P от G,
это будет просто тупо
сумма всех потенциалов.
Это определение.
Вот, утверждается,
что этот потенциал
тоже
нам сейчас кое-чем поможет.
Ну, во-первых, начнём вот с чего.
Утверждение.
Ну, я его хратко напишу.
Если я пущу в этой сети G
какой-нибудь поток,
забыли про предпотоки,
предпотоков не существует,
запустили какой-нибудь поток G,
то оказывается, как легко убедиться,
потенциал этого не поменялся
от слова никак.
Ну, причина очень простая,
что если у вас втекла
единица потока в вершину,
то тем самым образовалась
у пропускной способности
на единичку больше
исходящая пропускная способность.
Но если вытекла,
то на единичку больше
стала входящая.
То есть, если и втекло,
и вытекло одновременно,
то ничего не поменялось.
Ну, по сути, да.
У нас здесь Pimp,
а это C,
это пропускная способность какая?
Вообще?
Ну, это я пишу в общей сети,
но как бы в остаточной сети,
но это для любой сети,
но я могу в остаточной сети тоже
ровно по тем же лекалам посчитать потенциал.
Остаточная сеть тоже просто
граф какой-то
с пропускными способностями
встать.
Чего?
Да, но при этом они
еще поувеличивались.
Потому что дело в том, что когда ты пустил поток,
по обратным ребрам увеличилась
пропускная способность,
а по входящим уменьшилась.
Это когда поток входит.
А когда выходил, то исходящая уменьшилась,
и ничего.
Поэтому они друг друга сбалансировали,
то есть если одна единица потока вошла и вышла,
то ничего не поменялось.
То есть, по сути,
потенциал это что такое?
Это какое суммарное
количество воды может
проходить через все вершины?
Ну, такая верхняя оценка.
Может быть, даже грубая.
Потому что понятно, что одна и та же единица воды
скорее всего будет проходить через несколько вершин.
Но мы говорим, что если
в идеале
там каждая единица будет проходить только через одну свою вершину,
то тогда суммарно все равно этой воды будет
не более чем FHG.
Ну, кстати, это тоже оценка
может быть на поток.
Но у нас цель, на самом деле,
мы в поток заранее не знаем,
как бы оценить
по внешнему виду сети.
Так вот.
Теперь возникает...
Теперь самое интересное.
Заметим, что поток не превосходит FHG.
О, да.
Нет, просто из этого следует...
То есть, на самом деле,
тогда... Все понимают,
почему у нас поток не превосходит...
Почему количество фаз
не превосходит...
Именно количество фаз
не превосходит
от размера потока.
Все понятно?
Почему нет?
Опять же...
Да, ведь оно
не ходит на корень из F.
Количество фаз...
Я сейчас не говорю о том,
за сколько времени вы каждую фазу сделаете, да?
Но я утверждаю, что
количество фаз будет не более, чем корень из F.
Почему я это утверждаю?
Ну, доказательство... Схема абсолютно та же.
То есть,
сделаем корень из F
фаз этой блокирующего потока,
и что у вас остается?
Вам остается пустить...
Значит, у вас остается остаточная сеть,
которую нужно пустить не более, чем
F-потока, да?
Но при этом этот поток
может быть максимальной в этой остаточной сети
и декомпозировать на пути.
И каждый пусик будет иметь длину
не более...
не менее, чем корень из F.
Потому что у нас
расстояние 1.2T больше, чем корень из F.
Следовательно, этих единиц потока
у вас осталось не более, чем корень из F,
а вам осталось еще не более, чем корень из F-потока.
Ну, теперь, значит, это было одно утверждение.
Теперь утверждение два.
Да, ну, утверждение два.
То есть,
так сказать, Fmax,
то есть,
максимальный поток вот этой сети G
не превосходит Fg.
Ну, потому что каждому...
каждой единицы потоков декомпозиции
будет соответствовать одна и несколько единиц,
притекающих через декширы.
Ну вот.
Ну и в результате отсюда...
уже так можно доказать
первую...
первая серия Макарзанова.
То есть,
количество фаз...
то есть, количество
фаз
в концепции блокирующего потока...
вот я, заметьте,
не про единицы даже пишу,
а просто про любой
блокирующего потока
не превосходит
от корень
из этого потенциала.
Ну вот.
Но это если вот...
то есть, если поверить, да,
то есть, это на самом деле следствие,
что это же концепция, то есть, это не превосходит
от корня из вот этого вот
F максимального.
Но это уже действительно простой фаз.
Ну вот.
Ну вот.
Ну вот.
Ну вот.
Ну или можно эту теорему там
в каких-нибудь диких аспектах
просто так доказывать напрямую,
просто применять тот же самый шаблончик.
Ну, который говорит там, что
давайте сделаем корень из P
итерацией, после этого мы
там...
как там было?
Сделаем корень из P итерацией,
после этого мы обнаружим, соответственно,
теперь остаточную сеть, у которой
расстояние от S до D.
Ну вот.
Там...
Ну потенциал тот же.
Ну вот, потенциал тот же,
и каждая единица потока выжрет вам
не менее, чем корень из P.
Значит, этих самых единиц тоже не более,
чем корень из P.
Вот. Теперь первое теряем как заново.
То есть, такая вот оценка.
Вот.
Но на самом деле есть и вторая.
То есть, мотивируется она тем, что
как бы для того, чтобы применить эту оценку,
вы уже можете просто не считать поток,
а можете посмотреть на сеть, вычитать потенциал
и сказать, что вот, ну как минимум вот столько будет.
То есть, не более, чем
столько будет.
Кстати, автоматически отсюда уже можно вывести,
что в парасочетании вы ищете за
E корень из V.
Потому что обратите внимание,
на самом деле в парасочетании там потенциал
каждой вершины равен 1.
Это можно было...
Да, мы...
Да, в прошлый раз мы, собственно,
это можно было и и сделали,
но теперь заметим, что мы просто привели те же рассуждения
в обобщенном виде.
То есть, просто более общий факт.
Но теперь возникает следующий факт.
Очень хочется теперь сказать, что вот,
допустим, мы вот не хотим прям бегать и считать
потенциалы,
а очень хочется как-то вот оценить
вообще это все безобразие
через...
Используя там терминологию
V, E, ну или там
я предлагаю, что E это В квадрат,
там только В, и С.
Хочется оценить количество фаз,
только используя В, Е, С, и никаких вот этих потенциалов
не используем.
Как это можно сделать?
А оказывается, здесь
надо сделать это можно следующее.
Стирай
вот это вот все.
Лучше, чем С, Е?
Ну, С, Е это многовато.
Нет, это количество фаз-то, наверное,
в С, Е это многовато.
Нет, это не количество фаз, а потенциал.
Нет, мы сейчас будем вообще не потенциал.
Хорошо.
Есть альтернативная?
Идея следующая.
Мы попытаемся сейчас
просто применить ту же логику,
но
у нас классическая логика.
Террина у нас
количество фаз не превосходит
2k.
Где k какое-то число?
Как мы это доказываем?
Ну, мы это как-то доказываем
в духе, значит, сделаем
k-этерация, потом докажем, что у нас
в пути осталось не более, чем k.
Или, например, можно
еще как-то
терриба
количества фаз не более, чем
k плюс l.
Доказательство. Сделаем k-этерацию,
обнаружим, что после этого потока осталось не более,
чем l.
Вот давайте сейчас мы применим эту же схему.
Вот каким образом.
Итак, говорим.
Значит,
там терриба,
то есть вторая терриба
Корзанова.
Она говорит,
количество итераций
в концепции блокирующего
потока
не превосходит.
Да.
В данной ситуации количество итераций
определенно не превосходит.
Доказательство.
Доказательство будет такое.
Значит, смотрите.
После l-этерации
расстояние от s до t стало
больше, чем l. Правильно?
Вот.
Тогда вот идея такая.
Завтра построим
ту самую слоистую сеть.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Ну, мы помним, да, что тут
ребра бывают вот такие, ребра бывают какие-то там
идущие назад, идущие внутри,
но там перескакивающих ребр нет.
Помните, да?
Помните?
Вот.
Там что-то еще.
И где-то наконец тут t образовался.
Ну, могут тут еще какие-то слои быть,
но нижние слои нас даже не интересуют.
А интересует нас
вот что.
Ну, хотя нет, надо признать киша.
Остальные слои нас могут
интересовать, но с другой стороны, как мы
помним, там остальные, если из вершины
нельзя... Ну, давайте так.
Если из вершины,
то есть мы можем мысленно вытянуть все
вершины, через которые нельзя
дойти из s до t.
Ну, помните, у нас была теорема, что если из вершины нельзя дойти
до t, то она нам не интересна.
Помните, да?
Вот.
И да, вот. А, и более того, если
из s до нее нельзя дойти, то и в будущем
мы ее никогда не дойдем, можно вытянуть.
Так вот. Значит, у нас
вот слои, слои, слои, слои.
Да, ну, тут вот, ладно, давайте вот
нарисуем еще пару слоев для понятности.
Но давайте, смотрите, давайте эти слои
обзовем. V1,
V2, вот множество, это V
большое, да? V4,
V5 и так далее, V
Сколько тут? Больше либо равно l.
Ну, давайте l'
напишем, где l' больше либо равно l.
Видите, да? Я бы даже сказал строго больше l,
если быть точнее.
Ну, вот какая идея возникает.
А давайте
рассмотрим разрез.
Вот такой.
Четыре отряда, да?
Ну, допустим, четыре.
А в общем случае именно с этим.
А, кстати, давайте этот слой еще
обзовем V0.
Вот, допустим,
если вот это вот sT,
вот это будет sIT и TIT,
вот разрез такой sIT TIT.
Тогда заметим, что я могу
оценить величину
этого разреза.
Как я его могу оценить?
Да очень просто.
V4 в игре.
Да.
В смысле нет.
На 1c.
Да, то есть если это вот равно
v и T, вот на c это уже
да.
Это равно,
то есть он меньше
либо равно, чем модуль
v и минус первое умножить
на v и T на внезапно
c.
Почему так? А что за ребра
вообще пересекают этот разрез?
Ну, которые идут слева направо, очевидно
это только ребра из вот этих вот.
Так, ну в этом месте, правда,
конечно, мы сразу вы должны
записать.
Если нет кратных ребят.
Это важно.
Мы сейчас этим воспользуемся, обратите внимание.
У нас есть такое обозначение для разреза, да?
Что? У нас есть такое обозначение для разреза?
Нет, у нас просто есть вот
такой разрез.
Ну а что бы нет?
Вот давайте я скажу, что
доля T и T это
как бы все вершины измножат
v и T, v плюс первое и так далее.
А в доле s, v нулевое, v первое и так далее
то v и минус первое. И равно
1, 2, 3 и так далее.
Понимаете, да?
То есть, ну теперь заметим,
что этот оставшийся максимальный поток
он не
превосходит, то есть так сказать этот вот
f оставшийся
оставшийся
не превосходит c умножить
на минимум.
Из очень такой интересной величины
v0 на v1
v1 v2 v2 v3
и так далее
vl штрих минус 1
vl штрих
1
Ну потому что, помните, максимальный поток
у нас не превосходит
никакого разреза. То есть мы просто
перебрали несколько разрезов и взяли минимум.
А теперь
то есть в принципе
можно заметить, что раз поток не превосходит
то тогда ответ у нас будет
не превосходить l плюс
вот это вот.
В смысле ответ?
Количество итераций?
Количество итераций.
Еще делить на l?
Почему делить на l?
А, да, делить на l.
Да, то есть пока мы тут хотим
нацепить что-то типа l плюс
вот f ост
делить на l, совершенно верно.
Понимаете почему, да?
Даже l штрих я бы сказал.
Но мы будем
оценивать как л.
Ну а теперь давайте думать
вот о чем. А теперь давайте
просто попробуем немножко поиграть в алгебру
и подумать, о чему может быть
равен минимум вот этой
штуки. Учитывая, что
все эти v-шки целые
положительные
и их сумма не превосходит
v.
И их хотя бы l.
Штрих.
Ну, l штрих это l.
Это хотя бы l.
Да.
Ну, если они все равны,
то там v делить на l в квадрате.
Ну да.
А если не равны, то докажем, что
это оптимально.
Ну, можно на самом деле
внимательно подумать, действительно,
почему оптимально, чтобы они были именно все равны,
чтобы это было максимально, чтобы минимум было
можно больше.
Но на самом деле нет необходимости.
Потому что, смотрите,
потому что мы можем поступить так.
Каждая из этих штук
мы оценим как средняя арифметическая.
Вот.
Ну, средняя арифметическая в квадрате, конечно.
Минимум
из такой штуки как
v0 плюс v1
пополам
в квадрате.
Значит,
соответственно,
дальше что у нас тут?
Модуль v1 плюс модуль v2
поделить в квадрате.
В общем, и так далее.
В общем, эти все квадраты. Понятно, да?
В этом минимуме
теперь надо просто
найти минимальную сумму двух соседних.
Понимаете, да?
Но заметим, что если я это все
просуммирую, у меня
вот, не квадраты, конечно, сейчас могу сказать,
что все это вот минимум и все это в квадрате, да?
Если я просуммирую
средние арифметические.
То есть вот эти вот.
То у меня что получится? У меня получится
что-то типа v0 пополам
плюс v1 плюс v2 плюс и так далее.
Ну и в конце там еще v' пополам.
Ну, короче говоря, суммы этих средних
арифметических не превосходят v, правда?
Но если сумма не превосходит,
то есть у нас есть l' слагаемых.
Их сумма не превосходит l.
Значит, наверное, кто-то из них
будет не больше, чем v поделить
на l'. Правда?
Ну, по принципу, делить v, правда?
То есть получается, что это
меньше либо равно, действительно,
чем c на...
Ну, соответственно, если c
и
значит, модуль v делить на l
в квадрате.
То есть тогда вот это вот
получается...
Значит, получается,
что значит этих потоков...
Значит, получается, пишем тут
c на модуль v в квадрате
делить на l в квадрате
и все это поделить
на l. Что-то не то.
Слишком сильно.
Ну, степени не такие должны быть.
Там где-то тройка должна быть у нас в четверке.
Ну, у нас l...
Тут l в квадрате, тут l.
У нас l в четверте равно c в квадрате.
Там, вроде, l купран.
Вот это.
Либо мы доказали новую теорию,
а там более крутую.
Чем было там 40 лет, чем было 50 лет назад.
Ну, видимо, это оставшиеся
в уральной оценке.
Ну, как? Ну, давайте, смотрите.
Здесь мы оценили как произведение.
Умножить на c.
Каждое произведение мы оценили
как среднее рифметическое в квадрате.
То есть, минимум из квадратов
это то же самое, что квадрат из минимума.
Или нет?
Ну, конечно.
Вот.
Минимум, значит,
средних рифметических мы оценили
как c поделить на l.
Вот.
Тогда получается...
Это, значит, получается,
что, действительно,
это мы оценим как c на v в квадрат
поделить на l в квадрат.
Потом мы говорим, что каждый
футч требует
длины хотя бы l.
То есть, если мы оценили
общих реагер,
он же у нас не единичек.
У нас единички гораздо меньше.
Нет, мы вот этот поток...
Почему можно на l поделить?
Потому что каждая единичка потока
покушает хотя бы l единичек.
Да.
Мы, значит, считаем, что
серва единичная и просто каждая
не единичная единичка...
Стоп, стоп, стоп.
Да, мы оцениваем поток.
Фаз будет столько, сколько попоков,
а не сколько потоков делить на l.
Поэтому этот делить на l
мы не предъявим.
Убедитель, да?
Сейчас.
И почему в итоге?
Сейчас. Не убедитель, да?
Мы просто
носили аргументы, да?
Насколько они мощно выглядят.
Нет, то просто... А почему мы делим
на l-то вообще?
Ну, давай так. Как мы оцениваем количество
фаз, в точности сколько осталось потока?
Почему?
Потому что каждая следующая фаза покроет
не менее чем одну единицу потока.
Мы когда делили на l, мы оценивали
суммарно оставшееся количество единиц
потока вот во всех единицах.
А, да.
То есть мы сейчас не пользуемся тем, что
каждая единица потока покрывает каких-то там l ребер.
Мы сейчас этим не пользуемся вообще.
l мы использовали здесь.
Поэтому
получаем, что вот c плюс v квадрат
поделить на l квадрат.
В результате
что получается?
Ну, для того, чтобы это асимпатически было как можно
меньше, надо подогнать l так,
чтобы было, значит,
там где-то l приблизительно
c в v квадрат
поделить на l квадрат.
Ну, подгоняем. l, значит,
должно быть приблизительно
c в v квадрат.
И получается, что a равно
корень кубический
из этого всего.
И когда мы это делаем, получается и h
столько, и вот это тоже самое столько.
То есть получается,
можно сказать, не
превосходит. Пишем теперь
2.
Ну, можно теперь это переписать так.
c в степени 1 треть обычно пишут,
v в степени
2 треть.
Раньше у нас было то, что не превосходит
v, но
в качестве итерации.
Ну, не совсем. Во-первых,
ну, не происходит v,
оно было всегда.
Вот именно, всегда. Да, безусловно.
Вот v. Ну, это как бы если
c не сильно большое, то это лучше.
Если c меньше, чем v.
Ну, бывает такое, да.
Славно.
Ну, да.
Ну, да.
Вот.
Ну, и соответственно,
и что еще?
Ну, там по-разному.
В единичных графах
итерация была не более, чем корень из e.
Вот.
Ну, там тоже так получалось.
Ну, то есть, конечно,
корень из e у нас в худшем случае это v.
Поэтому, кстати, в единичных
это, кстати, теперь даже
лучше.
Если граф не сильно разрешенный, конечно.
Да.
Ну, как бы нет. Тут просто надо,
потому что такая тялема есть.
Да. Может быть,
то есть, ну, вот.
Так что, вот, получилась вот такая тялема,
и просто разными способами можно оценивать
максимальный поток.
Вот.
Так что, вот это называется
две тялемы Красанова.
И у нас осталось 4 минуты.
Так.
Ну, за которые все, что можно,
это разве что прикинуть. А что нам по потокам
вообще осталось?
Минкост.
Так, ну, во-первых, да.
Да, безусловно, да.
Во-первых, остался его величество
Минкост.
Нет. Особенно есть еще раз Лету я, может быть,
что-то забыл, но есть, как минимум, еще два алгоритма,
которые обязательно в этом контексте надо
обсудить.
Ну, во-первых, Ренгеркартич.
Нет. Ну, скажем тогда,
он входит в Минкост.
Вот. И, конечно же, алгоритм
Шторвагнера.
Именно он, да. Точно знаю, который.
Напомните, что это?
Алгоритм Шторвагнера — это поиск
глобального разреза.
Уууу.
В смысле, с его сочетанием, да?
Сочетание.
А это вот... СТ больше нет.
Значит, задача такая. У вас есть
просто СТ нет, есть просто
реалинтированный граф.
У графа есть там...
Значит, есть веса.
Не отрицательные.
И вам очень хочется разбить
вершины на два некуда.
То есть, провести разрез, но не тривиальный.
То есть, чтобы с левой и с правой что-то было.
Но так, чтобы суммарный вес
Ренгеркартич-разрез был все равно как можно меньше.
А, размещались. Все.
Еще есть дерево-гамуреку вообще.
Кайфовая структура.
Ооо.
Шедевр. Это шедевр.
Нет, мы друзья писали.
Какую-то задачу.
Я должен был поток искать
в двумерном дерево-адреску.
Ой, напомни потом эту задачу, что это
шедевр, да? Повеселимся.
Если я его вспомню,
это будет чистое...
Это будет вауда.
