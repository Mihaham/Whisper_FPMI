Начнём мы со страшилки. Буквально за пару часов до семинара
мне так не повезло, что я узнал о одной замечательной фиче, которая поддерживается в языке C++,
которую я не могу с вами не поделиться. Давайте внимательно посмотрим на то, что здесь происходит.
Я объявил смешную структурку vector, в которой есть sizeT plan.
И вот такая странная штука. Это как бы массив неизвестного размера, что это вообще может значить?
Почему это компилируется? Давайте выведем размер sizeT и размер вот этой структурки vector.
И то, и другое 8. То есть вот эта штука никаких данных, структурку не добавила.
Теперь посмотрим на смешную функцию makeVector. Она берет, молочит размер vector plus size
Ну и кастит к вектору. Такой сишный код. А дальше мы берем, делаем makeVector
и в эту дату пишем keg. В конце конечно backslash 0 есть в строковых литералах.
То есть выделили на 4 байтика больше, чем нужно было для вектора. 12 байтиков написали туда keg.
И теперь через дату можем обратно его получить.
Вас это не шокирует? Эта штука позволяет получить доступ к данным, лежащим за концом этой структурки.
Абсолютно легально собрало 3 cdc++20. А под слангом такое есть?
Под слангом должно тоже работать, потому что это часть стандарта c++. Да?
Так, ну что? Компайлинг. Вы только посмотрите, работает.
Я к такому жизни если честно не готов. Какая же это гадость.
Да, после таких вещей обычно глаза хлоркой промывают.
Ну закончим с этим. У нас там подошел дедлайн по первой домашке, поэтому предлагается ее посмотреть.
Ну разобрать так сказать.
Что от вас требовалось? Написать стрейнгу, которую можно в constexpr засовывать.
Ну с этим я думаю все должны были справиться, потому что там никакой идеи нет.
Просто пройти по ссылке и посмотреть, что можно. Можно оказывается массивы.
То есть стдр или сишный массив фиксированной длины.
И так как здесь у вас не требуется произвольного размера, все ограничивается 255.
Ну как бы все нормально. То есть в типе самого стринга зашит размер,
его используется чтобы создать стдр или пару размеров.
Ну даже все равно пару размеров с ист и стдр или сишный массив.
И туда записываете данные этой строки.
А интересных здесь классматы.
Там было очень много различных вариантов решений, и все они какие-то слишком умудренные.
Как по мне самое правильное решение самое простое.
Давайте сначала даже без требований на концепты и констрейнты просто реализуем маппинг.
Как это будет выглядеть?
Вот эту штуку скопируем.
Основной класс я предлагаю сделать просто пустым.
То есть ничего общего в нем не реализовывать, потом мы сюда навесим констрейнты и все.
А дальше все кейсы разбирать специализациями.
Ну первая специализация самая очевидная, это если у нас маппингов нет.
В таком случае у нас выбрато и нет, кроме как вернуть no load.
Ну и конечно же второй кейс это если хоть что-то есть.
А если хоть что-то есть, маппинг sub.
Ну весьма закономерно, что оно опять все рекурсивно будет действовать.
Попробуют с первым маппингом, если получилось окей.
Если нет, то отправляем дальше.
Ну так вот, попробуем с первым маппингом.
Для удобства давайте этого маппинга заведем, как бы их назвать, чтобы не было коллизий.
А почему нельзя сделать в специализации не маппинг, а маппинг и сразу шаблонные параметры?
Да, ты прав. Эти два варианта мне кажется эквивалентны.
Давайте сделаем так.
Тогда нам уже здесь нужно указывать не маппинг, а содержимый его.
И засовывать вот сюда.
Так, так.
Соответственно здесь мы можем сразу попробовать сделать динамик каст.
К рома звездочка объекта.
Кто знает почему я делаю именно вот так, а не вот так?
Я застучил.
В таком случае динамик каст чем отличен всего остального?
Он как бы безопасный. Он умеет понимать, когда каст невозможен.
И в этом случае выдавать ошибку.
В случае указателей ошибкой считается nullptr.
А если мы используем ссылки, то null ссылки не бывает.
Единственное, что нам остается, это кинуть исключения.
Но мы же здесь знаем, что мы хотим делать в случае, если у нас ошибка.
Исключения стоит использовать только, когда непонятно, что делать, если произошла ошибка.
Исключительная ситуация, которую мы в текущем коде не знаем, как обработать.
В этом коде мы знаем, как ошибку обработать, поэтому давайте не использовать исключения.
А также чисто мое импо, что хорошим стилем является не просто их динамик каст, а явно сравнивает с nullptr.
Ну тут по-разному можно писать, конечно.
Так вот, если каст нам удался, то мы просто возвращаем таргет.
Иначе нам нужно пойти рекурсивно.
Для этого мы возьмем classMapper от того же base и таргета, но от макингсов, от которых мы откусили первый кусочек.
И у него запустим рекурсивно.
Собственно все. Вот и все решения задачи.
За исключением маленьких деталей, как обычно с маленькими деталями, тут самое более.
В чем заключаются детали?
Первое, нам нужно законстраинтить более-менее адекватно вот это вот дело, чтобы мы могли выдавать читабельные ошибки.
Пользователю, который случайно в маппинге что-то не то написал.
Ну, что нужно констраинтить?
Во-первых, то, что все классы внутри маппингсов – это маппинги.
То есть инстанциации маппинга. Это первое.
Второе, Chrome должен наследовать base. Публично.
Иначе никакого динамиккаста у нас не выйдет и будет что-то странное.
И последнее предположение, что мы делаем, это то, что вот здесь вот этот таргет, да, у него же тип авто, непонятно какой.
Предположение в том, что вот этот таргет нам удастся скастить к вот этому таргету.
Ну, давайте попробуем это сразу написать.
Первое, что... ну да, concept, value и mapping.
Так его назовем.
И это будет относиться к...
Так, ну также нам здесь придется указать дополнительные параметры для концепта.
Мы должны знать, какой base и какой таргет ажитарный.
Соответственно их и напишем.
Ну и...
Какой у меня сейчас компилятор стоит интересный? Вроде бы GCC.
Тут можно специализировать не эту боупеременную на правильный маппинг, а сюда просто значение этой constexpr боупеременной вставить.
Да, можно так, если у нас нету constexpr лямб.
А если есть constexpr лямб, то мы можем их заобьютить.
Я очень люблю этот трюк, и так как у меня сейчас GCC, я могу его заиспользовать.
Ну ладно, нет, давайте считать, что мы согласны условиям полностью действиям.
Поэтому действительно будем использовать constexpr bool.
Темплей у нас будет точно такой же.
Тут false, а потом специализация false.
Вот тут немножко нетривиально написать специализацию.
Здесь будет у нас какой-то произвольный класс f и какое-то произвольное значение t.
Но какой тип этого значения?
Мы здесь auto t используем, а здесь class f.
Можно не auto t, а isConvertibleToTarget.
Да, можно сразу так, а можно это вот здесь написать.
Да, вот здесь мы сразу можем написать the right from base.
Это будет работать.
А здесь мы действительно тоже можем написать...
Я забыл кое-что.
Здесь мы вновь можем написать...
Хотя это вроде не работает, у меня не работало.
Ну, короче, это не работает, да.
Можешь попробовать написать это и потом auto.
Вот так нельзя, к сожалению, писать в текущем стандарте.
Да, я не то использовал.
У тебя неправильно специализация написана.
Мы специализировали, да.
Это базы и таргеты, а вот эта штука останется...
Да, я не знаю, что...
Какой-то кринч произошел, если честно.
Вот.
Там надо target type, наверное, сделать.
Вот, короче, так хитро у нас не выйдет, нам придется вот так делать.
Это будет...
Нет, это хотели добавить в 20 стандарт.
Ну, давай попробуем.
Возможно, это сработает, но у меня память говорит, что...
О, да, забавно.
Вот тут очень много дискуссий было с тем, для чего можно такой краткий синтаксис использовать.
Там, например, если у вас template-template параметры,
пока что нельзя использовать вот такой краткий синтаксис constraints.
К сожалению.
А вот здесь можно, наверное, потому что и в функциях можно.
Закономер.
Вот, собственно, мы и сделали, и надо только концепт обернуть.
Ну, наверное, можно даже этого и не делать.
Хотя тогда...
Ну, да, лучше сделать все-таки, чтобы мы вот здесь могли...
Не здесь.
Чтобы мы вот здесь могли классно написать.
Valid mapping от base target.
Вот.
Кажется, все.
Конечно, покрыть тестами, насколько корректно работают концепты в случае ошибок,
ну, невозможно, мягко говоря.
Остается только попытаться поломать, поиспользовать на практике
и посмотреть, насколько приемлемо ошибки выдает компилятор,
и со временем понять, что, ну, да, ок, оно удовлетворительно.
Давайте подумаем, не забыли ли мы ничего. Вроде не забыли.
О специализациях.
В специализациях не надо вместо класс mapping сделать там концепт ..mapping.
Он не будет писать, что специализация менее специализирована, чем base.
Да, тут ты прав.
Наверное, стоит. Наверное, стоит это сделать.
Опять же, правила достаточно тонкие, и чем вспоминать их проще.
Попробовать build this? Ну, давай попробуем, кстати.
Надо как-то инстанцировать в этот раз, да.
Например, мы украдем, конечно же, отсюда.
И вне, чтобы не париться.
Вот так вот.
Что?
Ну, видимо, это из авта. Попробуй. Возможно, это из авта.
Он говорит, что предикат из convertible-v невозможно использовать в constexpr-контексте.
Ну, видимо, это из авта.
Мне кажется, что в конвертибл-в можно использовать constexpr-контексте.
Но, видимо, это из авта.
Мне кажется, это дефект гцс.
Попробуй брать after, concept after.
Не, да, если мы берем after, это будет работать не так, как мы ожидаем.
Ноль, переключились на clan.
Let's make project.
Let's make project.
Кажется, он так быстро справился.
Нет.
Вот это да.
А, это дефект либо stdc++, да?
Почему десятая?
Действительно, непонятно, почему десятая.
Хороший вопрос. Кто помнит, как std...
Сейчас.
Как аргументы в CMake?
Compiled option.
CMake 6.x.flux, да?
std lib равно lib c++.
А.
Ага.
Понял, понял.
А, все, я решил, что я буду...
Да.
Все, вернись обратно.
Да.
Просто вот так сделали, все должно заработать.
Clan 12.
Ура.
Вернемся сюда.
Соберем.
Все заработает.
Ну да, короче, это дефект гцц.
Все-таки не зря задание, единственное, использовать кланка.
Да, используйте то, на чем будет работать.
Там Microsoft, Visual Studio, лучше, как понятно, все работает.
Ну вот.
Кажется, у нас действительно все работает.
И даже вот та деталь, про которую упоминалась Николай вроде, да, упоминал,
что вот здесь меньше констрейнтов, чем вот здесь.
Этот даже его не волнует.
Внезапно.
Вот здесь, где мы специализируем, здесь констрейнтов меньше.
Я так понимаю, констрейнты из основного класса автоматом наследуются на специализацию.
Да.
А может это с вариадиками связано?
Да, мне тоже кажется, что это так работает, но я уже успел забыть.
Кажется, на первой лекции я это помнил еще.
Ну давайте проверим просто для веселья.
Например, сюда напишем, что у нас не конвертируется, но точно по-нормальному констэкспрессе.
Что у нас не конвертируется, но точно по-нормальному констэкспрессе.
Стодер рей от inds.
Здесь, например, да.
Чем у нас визуал?
Угу, constraints not satisfied.
Угу, constraints not satisfied.
Valid mapping evaluate to false.
Ну вот тут начинаются маленькие детальки, что у нас просто valid mapping evaluate to false.
А хотелось бы, чтобы нам более конкретно говорили.
Почему?
Потому что нам не подходит target у этого матнида.
Вот, соответственно, этот концепт еще можно докручивать и довинчивать.
Не уверен, какой самый эффективный способ это сделать.
Но кажется, что самое лучшее это будет проверить первое.
М. Какая-то инстанциация маппинга.
Второе. Сделать здесь возможность получить from.
Вот так. Получить target и from.
А дальше проверять просто для этих штук constraints.
Ну, проверку на то, что инстанциация мы уже с вами писали.
А мы даже можем это сейчас подкастрелять.
И отсюда вот это выпилить.
Вот это все выпилить.
И просто сказать, что должен быть маппинга в те.
А здесь мы сделаем compound, который будет requires.
Ну, если более общий писать, то вот так.
Нет, так плохо. Не очень вообще получается.
Потому что вот это вот авто, оно очень конкретно.
Необобщенный код.
Поэтому мы просто сделаем вот так.
Сделаем вот так.
Убираю, что у нас будет m, f, base.
Это base.
И, наконец, convertible to.
А вот тут можно связать вот этот замечательный синтаксист.
m22.t convertible to target.
Да, type name, конечно же, здесь нужно.
Вот, получили немножко альтернативнее.
И теперь нам пишут constraint not satisfied,
because valid mapping evaluated to false,
because convertible to was not satisfied.
Мне кажется, это более хорошее решение.
Нам сразу пишут, где проблема.
В левом аргументе или вправо.
Вот, соответственно, если мы вернем так, чтобы все работало,
и сюда двоечку запихнем, а вот сюда string,
то ошибка будет соответствующей.
Нам скажут, что derived from провалился.
Для чего basic string char
и animal.
Единственная проблема, что вот эту штуку не смогло раскрыть сразу.
Ниже раскрыла, да?
А, вот, animal base of basic string не вернул.
И мне кажется, что это идеальное решение,
за исключением маленького гадского теста,
который требуется, чтобы...
Там требуется, чтобы неявная конвертация не работала для этих таргетов.
Ну, тесты я с прошлого года, разумеется, не трогал,
и в прошлом году предполагалось, что здесь будет sameS.
Мне теперь начало казаться, что лучше convertible to,
но, в общем, решение, которое проходят тесты,
но чуть менее элегантное, как по мне, — это sameS требовать.
Там начинается что-то сложное.
Я же в чатике пытался сказать, как это сделать,
но у меня тогда ничего не получилось.
Там что-то страшное...
Я не разобрался, честно.
Ну, вот если кто-то хочет пересерчить...
Ну, нет, нам наоборот нужно, да?
Нам нужно, чтобы тип T был...
А, нет.
А, да.
Хорошо.
Ну, вот.
Ну, вот.
Ну, вот.
Ну, вот.
Ну, вот.
А, да.
Хорошо.
Да, нам нужно, чтобы target был,
constructable from...
Да, это тогда опять вот такая штука.
Вот.
Вот так что.
В порядке, верно?
Да.
Вот, возможно, это тоже пройдут тесты.
Я этого не гарантирую.
Там может произойти что-то странное.
А, потому что...
Ну, а мы точно...
Оператор...
Оператор кассы.
Да.
Оператор кассы.
Слати, explicit.
Такую вещь.
Считается.
Ну, вот остается только надеяться.
Но.
Все в trucе.
Ну, вот.
Смотри, собственно, что происходит, да?
Да.
Да.
Ошибка, почему?
2, convertible to int.
двойка convertible to int, да, то есть как бы convertible to он охватывает constructible from, если
constructible from верно, если мы вот так напишем, то у нас никогда этот концепт, ну вот проблема
собственно, все запор это, вот поэтому идеальное решение, которое еще и проходят тесты, это мне
кажется вот так, ну невелика жалость, что-что, вот поэтому мне кажется, что convertible to лучше,
это именно на тестах, да, проблема была или, то есть как ты делал и как у тебя ломалась смс,
а вот, да, да, потому что двойка это, стоп, это типа деколтай под нее, но это же левой лифт,
ну да, как бы, нет, вот он, помните, мы когда концепты стандартной библиотеки разбирали, нашли там
common reference width, вот, вот кажется его здесь надо союзить, да, ну вот возможно так, да, то есть
потребует что-то как бы почти одинаковые классы, но common reference width с собой тоже тащит немного
там гадости всякой, да, он там с наследованием умеет работать и вот такие вещи, ну мне кажется не сказать,
какой решение, самое лучшее без какой-то практики и отстреливание колен в продакшене, вот, в общем
у нас с первой задачей на этом все, я думаю, этот код я никуда не выкладываю, я просто стираю, да,
если вы хотите его скопипастить и сдать задачу, то еще не сдал, а вроде уже почти все сдали,
или вообще все, вот, надо смотреть записи, или вы сейчас... переходим к второму заданию, по нему
я тоже хочу немножко комментов кинуть, потому что оказалось, что я немножко недостаточно толстый
я бы намекал на одну классную штуку, давайте вот эти вещи скопируем и попытаемся реализовать drop
вот в его момент катарсис должен происходить, если он не произошел, то что-то не то, так, drop
а, возможно
zip вроде красиво выглядит
ну вот, да, тут есть два пути изображать
короче, в общем, навесили requires, короче, навесили requires, вот, но при этом компилятор такой
короче, это не может спеша вайс, это не может как-то стрелять
ну хотя бы из них, один из них empty это сложно подтвердить, да?
не сложно
да, но компилятора ты это не докажешь
ну там, что один из них empty, оно делается
там один из них empty, оно просто делается, там через трюк, что можно сделать там один тип empty, а потом раскрыть через там or or и 3.
да, но компилятор не смог доказать, что это более специализированная вещь
ну, короче, да, сначала я, короче, сделал просто барзу без констрейнков, и оно заработало, но оно работало не совсем хорошо, короче, пришлось вот type list, заменить на type sequence и еще
а так, короче, я свободно перечитал несколько раз, но я так и не понял, в каком месте это не мог констрейнуть
возможно, это баг компилятора
возможно, но я не представляю, что это мог констрейнуть
ну, да, но
так, мы забыли про стрелку по преследованию
а, ну, кстати, да, но я делал по-другому, я детексил, что хотя бы один из них пустой, да, что все не пустые
ну, вы поэкспериментировали, да, да, и так оно работает отлично, и без костылей, даже не нужно вот этот вот фолды использовать, да
можно прямо там, где кластер иточен, написать этот
но это все ладно, это такие уже
там не проверяется, нет, там же есть проверка, что зип конечного с бесконечным нормально работает
а, зип произвольного количества
но тесты слабые пока
ну, вот, утверждается, что есть очень простое, очень красивое решение зипа, которое с конечными тоже работает
если там теста не хватает, то давайте его добавим, да, потому что
ну ладно, после гедлайма уже добавим
да, так вот, как мы будем делать дроп?
ну, не специализация, а это основная штука
ну, какую специализацию, так, внимание
какую специализацию легко сделать, да?
как обычно, мы такие, ну, если дропнуть нужно ничего, то понятно, что это будет, да
ноль, тель, ура, ура, все круто
и, а что тут пишем?
как это сделать вообще, как мы
вот, и вот это первый классный хак
можно сделать все так
обычно
нет, оно работает всегда
так, давайте сначала для тех, кто потерял ход мысли
обычно мы вот так пишем, да, эти всякие операции над тейп-листами
сюда что-то вписываем, и сюда что-то вписываем
но тут как бы, ну, разве что вот так можно написать, да?
ну, да
но если тейль пустой
ну, еще один костыль придется сделать, да?
нелеганно
можно сделать вот так
и вы автоматом, если у тейля есть head и tail
подтащите их вот в этот скоб, да?
юзинги из родителей перетаскиваются наследником
а если тейль это нил
то он удовлетворяет концепту empty-лист
потому что дирайв с ром
вот здесь нужно было словить катарсис, почему оно вот именно так написано
а не просто мило до пустой список
и там почти в каждой функции можно это свойство наследования красиво заобьюзить
и получить конфетку
давайте допишем
чем мы не разобрали?
ну, общий случай, да?
общий случай мы, наверное, сверху даже
здесь n
это не ноль
что мы будем делать?
да, просто вот так
но нам нужно отпустить от тейль кусочек
а, да, мы не можем этого сделать, тейль может быть пустым
поэтому нам во всяком случае нужно специализироваться, да?
а специализируемся мы с помощью type-sequencer
n-тейль
и это ровный есть, не пустой список, да?
у него гарантированно есть head и tail
и что тогда нужно сделать, да?
делегировать определение, что будет head, а что будет tail
drop с меньшим n
можно от наследоваться от него
да, вот, вы начинаете мысль с правильным стороном
а что?
а что плохого?
да, хочется опять начать эти using head равно ля-ля-ля
нет, вот
после такого мы уже знаем, что мы просто пишем вот так, и оно работает
и, собственно, все остальное в этом задании предполагалось в таком стиле писать
ты уже по-другому написал, да?
можно еще раз, получается, наследование делает за нас всю эту работу с using head, да?
да, да, да
то есть автоматически вот эти вот using head или tail, которые, мы говорим, должны быть внутри списков, подтягиваются из наследников
то есть здесь мы просто говорим
ну вот на это наследование можно смотреть, как на празу мы являемся
список, в котором drop-нули n элементов из непустого списка tail, является списком
где drop-нули n-1 элемент из его хвоста
если же мы дошли до нуля, то это как бы есть сам этот список
да, остался один, конечно же, случай, если
если список пустой, а n еще не кончилось, такое мы тоже хотим поддерживать и не какие-то ошибки выдавать
ну в таком случае мы просто наследуем дел
вот так тут куда-то не решен
могут быть проблемы, как раз саппорядочено они в специализации
но самая неприятная вещь в написании, как раз, это специализация
подобрать специализацию так, чтобы нормально в порядке быть в этот случай
а если у нас ноль и empty, то что должно произойти? Тоже nil, да?
наследник у nil, а это что у наследника?
да
давайте, так сделаем
и все, да? То есть покрыли все кейсы
всего две специализации, по-моему это очень хорошо
если дошли до нуля и что-то еще осталось, то это то, что осталось
если еще не ноль, то тропы m1 идем дальше
в всех иных случаях nil
то есть это буквально объявление функций на функциональном языке
это двуточек, а равность почти работает
да, очень смешно получается, как мне кажется
не знаю, насколько это стоит с продакшн тащить, но потренировать, работать со специализацией на констрейнтами и прочим
надеюсь, полезно
вот, если кто-то еще не брался за второе задание, еще не написал все с этим
то стоит браться, и вот в таком стиле у вас достаточно быстро, мне кажется, пойдет дело
да, там group by это как раз ultimate challenge в этом задании
да, там есть разные обходные хаки, которые я тоже буду принимать, потому что это непростая штука
то есть group by любыми хаками только сделайте
да и в принципе все задание
но все это можно сделать достаточно красиво и лаконично
и было бы здорово, если бы так сделали
давайте возвращаться к нашим парам, к TypeRage'у
больная тема
мы там пытались, что-то получилось, что-то не получилось
надо для начала повторить, да?
CRTP нас не интересует
хотя нет, давайте про CRTP еще одно упоминание
внезапно в C++20
появилось еще одно смешное использование CRTP в Ranges, про которое мы будем говорить потом
но применение тут примерно такое же, как мы смотрели
можно некоторый класс, который называется View, не важно, что это
отнаследовать от вот такого View-интерфейса, используя CRTP
дальше нужно объявить BeginEnd в нашем наследнике
вот этот хитрый интерфейс нам как бы подмешает
внутри этого класса куча смешных дополнительных функций, реализованных через BeginEnd
например, проверку на empty
но тут еще хитрее все, на самом деле
empty он подмешает только если вот этот шаблонный аргумент
и вытворяет вот такому концепту
там оператор bool подмешает, кажется, всегда
ну там тоже скорее всего будет концепт
примерно понятно, как empty реализовать, если у нас есть BeginEnd
это какой-то картаинер
просто проверить, сравить для BeginEnd
оператор bool тоже самое
дата это звездочка Begin по сути
size это End-Begin
ну там похитрее на самом деле
давайте закроем
кому-то кого-то на комиссию отправили
видимо
вот
да, ну у size тоже понятно, как реализовать
End-Begin, но такой size можно реализовать
только если вот результат этих Begin и End можно вычитать
соответственно тут навешаны констрейнты, которые это требуют
ну и front и back для контейнера понятно, как реализовать
если у нас есть BeginEnd на самом деле
с некоторыми оговорками
то есть на самом деле многие контейнеры в OSTD
кажется, что можно было бы с помощью такой штуки очень удобно реализовывать
не выписывая все вот эти вещи руками
ну да, там требуются какие-то сложные штуки, которые мы потом будем
ну сам OSTD Ranges сложный
это нечто
а Unifex будет еще больше нечто
будет одобрее
да, вернемся к нашему барану
TypeRange, все, наконец-то
мы остановились на том, что написали AnyInput
а вообще, что такое было TypeRange?
это такой волшебный способ
забыть о том, какой был тип у какого-то набора значений
с условием, что у них у всех есть некий общий функционал
то есть функционал не забыли, а типы забыли
и вот в Any можно положить вообще что угодно
и мы забудем, что там лежит
единственное, что мы можем сделать, это попутаться, вытащить
получилось окей, не получилась беда
а также есть функцион, который похож на OSTD Function
он забывает все, кроме оператора вызова
для того, что мы туда положим
помните, что у каждой лямбды свой уникальный тип
и лямбду просто так куда-то не сохранить
ее тип нельзя выписать
а вот OSTD Function или наш Function
позволяет забыть тип этой лямбды
и запомнить только то, что ее можно вызвать от MTA
ну и вернуть в плагин
вот, но то, что мы написали, оно было не очень хорошее
давайте фиксить нехорошести
первая нехорошесть – это динамик Cast
мы думали в прошлый раз пять минут, как это убрать, не придумали
но не мудрено
не помню, это не придумать, мне кажется
вспомним, как у нас работал весь этот type ratio
мы хранили UniquePtr
на наследника такого вот интерфейса
ничего не делающего
а наследников генерили через шаблон
и что нам, по сути, нужно сделать
нам нужно спросить вот этого наследника
ну, вот этот nimpl
попросить его выдать нам какой-то идентификатор
какую-нибудь чиселку, которая разная
для всех инстанциаций вот этих вот
по сути
если мы научимся для каждого конкретного импла
вернее, его инстанциации
иметь разную чиселку
в compile-time
то мы, по сути, победили
мы сможем взять, инстанцировать
вот здесь, в гете
конкрет импл от t
и забрать оттуда чиселку
а также попросить чиселку из nimpl
если они совпали, то можем reintegrate-cast
или static-cast
если не совпали – беда
так вот, чиселка
понятное дело, что чтобы
вот отсюда вытаскивать такую чиселку
из импла
нам все-таки понадобится виртуальный метод
а вместо чиселки мы будем использовать void-звездочка
или char-звездочка
void-звездочки нельзя сравнивать
на равенство
ну посмотрим
это то, что не сильно часто приходится делать
так что увидите
где-то id будет
ну и у каждого такого конкретного импла
я хочу
хочу заубирайтесь
но что писать, пока мы сюда не понимаем
как будет 0.2
что-нибудь
все так
так вот
остался последний шаг
как сгенерить уникальную чиселку
для каждой инстанциации конкрет импла
конечно это будет любый хак
без state-sum это против
да
мы сделаем state-void-хак
и сделаем его
в любом случае
в любом случае
в любом случае
в любом случае
в любом случае
в любом случае
хак
и сделаем его
зависимым от t
на всякий случай
потому что если сделать независимым
может взорваться, я не уверен
нот имплементы
мы его имплементируем
все хорошо
а здесь мы вернем
ну
что, не так?
да
ну надо заринтеры вгастить
ну или застаток вгастить
ну понятно
даже я не знаю
std-sist
а, int-ptrt
вот это будет лучше
int-ptrt для тех, кто впервые такую штуку видит
это такой целочисленный тип
размер которого равен размеру указателя
ну то есть
как бы std-sist формально говоря
может быть 32 бита
даже если у нас указатель
это 64 бита
такое даже бывает вроде в реальной жизни
так что int-ptrt
это безопасный способ взять указатель
и использовать как просто чиселку
ну вот мы и победили
а здесь мы сделаем
следующий прикол
if
импл
getId
равно
да, конкрет
импл
getId
а
а
мне что-то не нравится
давайте вот эту штуку вот сюда
да
просто для удобства
и здесь будем сравнивать
этот хак можно даже
приват отправить
нет
мы же не знаем, какой из наследников
импл
лежит вот здесь
мы здесь
используем то, что у нас есть
динамическая диспетчеризация
в зависимости от того, кто лежит
под вот этим указателем на импл
да
мы выберем разный getId
то есть то, что здесь
хранилось, оно вернет тот
id, который был у него
у его тэшки
соответственно
здесь мы берем id тэшки, которые
пытаемся кастить
если они совпали
то мы можем с уверенностью просто
кстати
кастить
конкрет импл
get
звездочки
импл get
и у этой штуки получать
get
иначе
что мы делали иначе
интересный хак, не правда ли?
только там он плохо
работает с констами
например, если мы хотим получить
констант, isn't that
да, про то, что происходит
если у нас здесь консты не консты
это мы еще поговорим
это еще один кусок, который надо
рассказать обязательно
да-да, так и работает
а если мы вот здесь напишем
сразу getFloat
прилетело
РДТИ
да, ну его
не нужен он
да, просто
небольшой набор скромных
хаков и все работает
никакой РДТИ
вот, давайте дальше
думать, почему этот код все еще хрей
почему этот n все еще хрей
но констант
не токое, гораздо более очевидное
вот, мы так не умеем
ну мы хотим просто
взять и скопировать
мы не умеем копировать сейчас эни
да, за счет того, что
зачем?
ну зачем по току можно
ну если там веки разных типов
просто старые веки ничтожат
ничего не надо
ничего не надо, у нас все работает
sharedPTR сделать
этого тоже не надо
у нас
нет, sharedPTR это не то, что мы хотим
если мы используем sharedPTR
то у нас будет здесь
два разных эни ссылаться
на одно и то же значение
а у эни должна быть семантика value
дип копии должен происходить
вот, а насчет деструкторов
с деструктурами здесь уже все нормально
за счет того, что деструктор
в виртуальной мы используем UniquePTR
вот в этом как раз и
пункт технологии через виртуальные вызов
что здесь думать-то особо не надо
в стандартной ООП все спокойно работает
скоро откажемся
все-все в планах
ну как бы
как в ООП решается проблема
дип копии
пишется
nimple UniquePTR
clone
что-что?
DTO
не до конца
не совсем
тут сложно сказать
где патрон прототипа, а где просто дип копии
прототип обычно
подразумевает, что мы
сильно abuse
этот clone для конструирования
каких-то копий
для какого-то такого
полиморфизма конструкторов
а здесь просто как бы
конструктор копирования надо вывезти
да, наверное это из-за того, что внизу
виртуальный или пока такая паника происходит
давайте виртуальный
clone overwrite
что мы здесь будем делать?
ничего сложного
мы вернем U
onCreateImple
от
then
да, скорее всего
нет
давайте
у меня, честно говоря, в последнее время
какие-то проблемы с этим никому
мне кажется, что у меня
всю жизнь работало просто
а потом оно почему-то перестает
и я грущен
а, да
нет
вот
вот
вот
нет
пишем тупо, не пытаясь выпендриваться
современными фишками
concreateImple
вот
то есть мы создали
новый concreteImple
с теми же шаблонными аргументами
запустив
конструктор копирования
от вот этой тешки
и вернули линейку ptr
от этой штуки
ура
теперь мы можем реализовать
конструктор копирования
я не удерживаюсь
и оператор
присваиваем
во-первых
так
в таком кейсе ничего не хотим делать
про копирование
мы инициализируем
ой
мы инициализируем импл
импл чем?
и все
все
здесь
std
exchange
импл
так же сработал
ну как зачем
ладно
сделаем проще
а стоп
мы же копировать хотим инициализировать
да
что-то у меня в голове заклинило
клон мы хотим опекивать
все
то бишь что происходит со старым имплом
он спокойненько удаляется
как удаляется любой полиморфный класс
диструкторы вызываются, все хорошо
а потом мы делаем клон и записываем
о себе
кажется теперь это должно работать
мы взяли а
и давайте попытаемся вывести
ткет
b как
куда оно нам тычит нос
о нет
я пытаюсь быстро подкастрелять это
если не выйдет
а
а
а
а
а
а
а
а
а
а
а
а
а
а
а
а
а
да мы хотим
короче
в чем ошибка
вот этот
синтаксис как мы знаем
вызывает не
оператор присваивания
он вызывает конструктор копирования
окей
но
ну ка проверим
а вот этот сможет
что для этого нужно сделать
проверить requires
для этого нужно проверить
является ли самирегулярным
t а t у нас н
окей
что проверить он самирегулярный
нужно проверить, что он имеет конструктор
копирования
а вот это может он
ну давайте проверим
Нужно аккуратно. Вот этот костыль должен пофиксить. Не пофиксил.
Не то, конечно. Вот так, вот так.
Да, это надо взять в скобочки, потому что парсер больно. Вот, мы прервали бесконечные рекурсии, ну молодцы.
Но, собственно, нам к лангтайде и жалуются, что конструктор, который принимает forwarding-reference, может захайдить это, но и советует эксплиситово пометить.
Я не знаю, хочу ли эксплиситово пометить, потому что мне вот нравится, если честно, писать.
Но перед тем, как Энни войдет в Overload Resolution, в Overload Set, нужно проверить, что Requirements удовлетворены.
То есть, еще до того, как мы построили Set перегрузок, мы ушли в бесконечную рекурсию, пытаясь проверять вот этот общий минимум.
Да, современный C++ такой, непонятно, что происходит. Ура, должно работать. Действительно работает.
Вот мы научились копировать. Ну, move-ать, кажется, здесь учиться не надо. Move-ать, Энни, это понятно, просто move-аем линейка.
Кажется, дефолтный move этот уже вполне работает. Да, дефолтный move-конструктор, дефолтный ратор move.
Что-нибудь, что-нибудь надо.
А мы проверили? Да.
Проверим.
Что? Не сгенерировал. Не сгенерировал, ладно, я не прав.
Провело пти, оно не про это, это правило для программиста, а для компилятора немножко другие правила действуют.
Вот это я тоже постоянно с этим путаюсь, если честно. Проще, конечно, всегда писать все варианты, точно не ошибешься.
Я думаю, оно даже заработает.
Так вот, про констрейли, и платильность, и мувабельность я вообще хотел говорить на функциях.
Сейчас здесь попробуем поговорить.
Что будет, начнем с простого, что будет, если мы сделаем вот так.
Да, в чем проблема?
Мы потребовали регуляр, да, самирегуляр.
Это слишком жирно. Да, уникпадр не является самирегуляр, давайте откроем.
Если бы референс был самирегуляру, копия был и дефолты не шалаизовывали, да, мне кажется, что на ошейне должен как бы и с мувабелонными типами тоже работать.
Поэтому давайте вот это вот условие все-таки отпилим и будем более тонко смотреть.
В чем теперь проблема? В том, что мы и там еще самирегулярно писали.
Вот, теперь в чем проблема? Она не ушла никуда, конечно же.
Какая ошибка, я пытаюсь понять. Вот ошибка, да. Как только мы клон пытаемся вызвать, произойдет фигня.
Что в этом случае вообще делать?
Оказывается, что хорошо бы рандайм ошибку делать.
Давайте посмотрим, что STD делается в таком случае.
А, нет, он вообще так не умеет. Ладно.
Давайте попробуем. Все-таки лучше всего эта штука чувствуется, на примере, с функцией, чем в сцене.
Мне кажется, Энни все-таки лучше оставить стекулярными и следовать примеру STD.
Что еще нужно пофиксить? Консты, да?
И не только на самом деле. Что если мы хотим мувнуть то, что лежит внутри Энни?
У нас есть замечательная операция Get. Она сейчас возвращает 10%. Но это не очень хорошо.
Что будет происходить, если...
Что будет происходить, если...
Вектор ментов, в котором лежит 1, 2, 3. Вот так хорошо.
Энни, Б, мув, А, нет, даже не так. Вектор ментов, Get, вектор ментов.
Что должно происходить в таком случае? Что в нашем случае произойдет?
Да, мы вернем из Get ссылку и скопируем. Это может быть слегка неожиданно, да?
Да, ожидается, что это полезно уметь делать.
Давайте посмотрим, что произойдет так.
Слово класс.
Да, попробуем понять, что лежит теперь.
Да, попробуем понять, что лежит теперь.
Вот так.
И что лежит вектор, попробуем понять.
А, это же у нас просто... Да, все.
3, 3, 3. Да, скопировалось. Давайте попробуем это заменить на STDN.
Ой, а там еще все сложно. Там же не кастом.
Не кастом, да? Да.
То есть это не кастом. Это было свободная функция.
Спасибо, Силан, что сделал. Ровно то, что я хотел.
Вот так вот, да?
Вот. Посмотрим, что здесь произойдет.
Ага, ноль. А у нас было 3, 2, 3. То бишь, когда мы делаем гет из РВ,
то оно как бы его забирает. Это весьма логично. И если задуматься,
то какие-то опертки над чем-то работают точно так же.
Давайте сделаем, чтобы у нас работало точно так же.
Во-первых, вот такая штука у нас будет возвращаться только когда lvalue.
Если кого-нибудь пугает.
После метода можно дописывать различные квалифаеры, которые будут накинуты
на то выражение, у которого мы вызываем этот метод. Если мы написали ampersand,
то gt можно будет вызвать только у lvalue выражения. Если в ampersand,
то у lvalue выражения. Если на весь лек конст, то только у конст выражения.
Вот такие пироги. Соответственно, если у нас просто lvalue и не конст,
то мы делаем lvalue. Если мы делаем вот так, то мы делаем вот так.
Если у нас...
Вот как-то так получается. Смотри, какой паснутый метод, который отличается примерно ничем.
Пойнт только в том, что у них разные вот эти вот квалифаеры.
Соответственно, если теперь мы...
Ой, давайте...
Сейчас я напишу этот заказ быстренько, потому что я задолбался.
Ничего я потерять не должен был.
Всё.
Всё.
Почему?
Хорошо.
Всё, я увидел что-то.
Вот. Что я сейчас сделал? Я написал обёрточку такую же, как просто...
Я написал вот эту обёрточку Anycast, которая просто полностью прогидывает всё к нашему гету,
чтобы мне не приходилось второй раз эти Anycast заменять на нашу гету.
Меняем на нашу гету.
Где ошибка?
Да, тут, к сожалению, не получилось.
Да, всё, всё. Похоже на правую.
Ну вот, если мы теперь запустим, мы, соответственно...
Да, получим такое же поведение, как в STD, и всё хорошо.
Вот, соответственно, всё да не всё.
Возникает некоторое количество вопросов.
А что если в УП не положили конст или ссылку?
Давайте забанить такие случаи.
Вот я предлагаю забанить такие случаи и не страдать.
Хотя...
Я Article 3.
Я предлагаю забанить такие случаи и не страдать, хотя
в таком может быть смысл, да?
Зачем ссылку, если можно указать и помнить?
Да, ссылки бессмысленно, ссылки это вообще дичь,
это мы даже не будем пытаться использовать, даже в стандартной
библиотеке классы типа optional со ссылками сейчас работают
как-то крип.
Вроде даже вообще не понятно, что должно происходить,
вообще не понятно.
Так, соответственно, проверяем, мы забанили то, что там
ссылки могут получиться, да, мы забанили, потому что
мы явно ремонт свой референс, ну и конст, собственно,
забанили.
Но если задуматься, то в принципе конст можно
туда положить.
Только непонятен смысл, потому что конст можно на
самоиндивисит, и за счет вот этих наших хитрых форвардов
будет происходить ровно то, чего мы хотим, чего мне
понравилось.
А получить конст?
Что значит получить конст?
Получить констинт, точнее скостовать констинту.
Но если мы положили инт, то что можно сделать get от
констинта?
Get от констинта, я бы сказал, что просто нужно, не нужно
это поддерживать.
Использователь сам указывает правильную тэшку.
Вот и все.
Мне кажется, это достаточно здраво.
И кажется, на этом вот с такой типа классической
реализации мы закончили.
Про функции.
Функция у нас, на самом деле, наша самая проблема,
была.
Давайте я только как-то попытаюсь вот это все сделать
вот так, сделать вот так, и все это свернуть.
Вот.
Все.
Брали.
И вот это все тоже.
Нафиг.
Вроде как мы все прошли, что у меня нет.
О, и вот это нужно туда же.
Так.
Как слайны к другому консору.
Так.
Так.
В нашей функции у нас такая же проблема.
У нас копирование здесь не происходит.
Ну, понятно, как ее фиксить, это уже давайте не будем
делать.
Но с функциями бывают более хитрые вещи.
Что вообще хранит вот наша вот эта вот функция?
Она хранит некоторый объект, у которого есть оператор
круглой скобки, грубо говоря.
Или у которого можно инвок вызвать.
Что если этот оператор круглой скобки константный?
А что если он не константный?
А что если он только на R-Way не вызывается?
А что если он на EXCEPT?
Да.
Да.
Так.
Да, понятно ли проблема?
Что вот здесь мы как бы call делаем на f, да?
И f у нас value и не константное.
А что если единственный оператор круглой скобки,
который есть вот этого типа f большое, он константный
или там даже только R-Way вызывается?
Вот непонятно.
Давайте лучше пример напишем.
Да, мы эту инфу еще и сохранить не можем.
Нам сейчас нужно будет ее лечить.
Ну, TypeRanger что-то непроста.
Будет оператор круглой скобки, который отвечает на вопрос.
Он будет константный.
А теперь мы такие наш Function берем
и пытаемся в него положить вот этот вот bad.
Положилось.
А, у нас вообще ничего не вышло, да?
Invokeable от ARX.
А, видите, я же не указал.
Да, конечно, оно само не смогло вывести.
In тот ничего.
Вот, пока все здорово.
Точно.
Прикол не сработал.
Прикол должен наоборот работать.
Я вот так хочу.
Да, то есть сама-то функция константная.
Вроде как все ок.
Ну, не можем.
Нет, это тоже фиксится легко.
Это фиксится просто добавлением 200 слов points.
Отсюда констант перейдет?
Да, сейчас все работает.
Вот отсюда конст убираем.
Все тоже работает.
И все тоже работает, да.
Хотя мы просили, чтобы только на конст-объекты позывалось.
Ну, на константный, конечно, ничего не прошли.
Ну, да.
Ну, что?
Ну, да.
В общем, тут начинается некоторая мессия.
Если мы вот так сделаем.
Вот тут все сломается.
Да, конечно.
Потому что мы здесь просто делаем Invoke, а должны бы Invoke от f.
Давайте постепенно это все вылечивать,
потому что мы сейчас, я гарантирую, не напишем идеально.
Ставим Function.
В общем, мы здесь просто делаем Invoke, а должны бы Invoke от f.
Давайте постепенно это все вылечивать,
не напишем идеально. Ставим Function.
Мы просто обозреем некоторые проблемы.
Вот, и теперь, соответственно, начинаются проблемки.
Можем ли мы вообще сделать вот так?
Ну, вот начинаются приколы.
Что нам, по сути, нужно несколько таких функций.
И вот если мы вот так сделаем.
И вот если мы вот так сделаем.
То уже, кажется, все будет работать хорошо у всех кейс.
Ну да, у нас, скорее всего, пока просто call c, call l, call r.
Где вы даете Ref.Qualifier?
Для другого?
Так, и теперь должно следующая штука работать.
Мы должны и вот так, и вот так, и вот так бить наших этих.
И теперь, если мы делаем вот так.
43, да? То есть пришел LV.
Так, конечно же, нужно мурнуть.
42, для какого?
Если добавлю const, то тоже все должно работать.
Вот, и это уже более-менее корректно, как бы, обработка всех кейсов.
Да, вот проблема.
Если нам прислали метод, у которого noexcept поменьше вот здесь,
то очень хотелось бы, чтобы оператор круглые скобки тоже был как бы noexcept,
но я бы не сказал, что проще.
Мы узнаем здесь тип.
Кого?
Ну, кого?
Тип импла. У нас же TypeRager произошел.
Вот, и кажется, это уже то, на что мы не будем пытаться тратить время.
Вместо этого мы откроем такую штуку Function2.
Это замечательная библиотечка, которую вы уже на курсе конкарнси могли видеть.
И среди прочего, оно умеет все эти кейсы обрабатывать.
И они про это пишут.
Я что-то потерял.
Квалифаер.
Да.
Собственно, почти то же самое, что мы и сделали, делают и они.
Если, ну, точнее, они эту информацию все-таки хранят в типе,
нам бы тоже, на самом деле, хотелось в типе хранить, а не динамически.
Вот.
Но с таким дизайном на виртуальных вызовах оно не очень хорошо работает.
Сейчас будет нормальный дизайн, как вы в домашке будете писать, там уже получше.
Да.
Да, соответственно, если тут указано конст, то у него там конст.
Если тут указано болатайл, то у него болатайл.
Ир-вэлью-квалификаторы можно писать, иноэксепты можно писать.
И вообще все здорово.
Да, но только...
Да, вот как тут нуэксепт корректно обрабатывать.
Если мы потребовали нуэксепт среди квалифаеров,
но при этом...
Ну, короче, ладно.
Оно будет проверять статически, когда мы пытаемся запихнуть туда внутрь
лямбда или что-то еще, что там есть нуэксепт.
И если вдруг мы случайно вызвали на пустом функциональном объекте,
то есть когда вот здесь noLptr, грубо говоря,
оператор круглые скобки,
ну вот std function вроде исключение кидает.
Но если мы поместили оператора круглые скобки noexcept, как он кинет исключение?
Поэтому вызывают std abort или std terminate.
Вот, ну в общем, если вы всегда мечтали увидеть идеальную имплементацию std function,
потому что std function вообще ни разу не идеальная на аппаратите,
то вот function2, этот код, я думаю, интересно будет почитать,
а нам надо к более оптимайдженному.
Собственно, виртуальный вызов это, конечно, здорово,
но это вообще не то, что нам хочется, не то, что нам нужно.
Всех, по-моему, все.
Не будет виртуальных вызовов.
Ничего не будет. Никакого праздника.
Начинай с нуля.
Будет следующее.
Ладно, я зря все это стер.
Я думаю, лучше бы оно осталось.
К нему упакуем namespace.
Вот так вот.
А мы теперь будем писать как большие мальчики.
Девочки.
Дея f, это у нас такие будет полноценные функциональные таблиш.
С помощью перегрузки мы вытащим оттуда класс r
и некоторые аргументы.
И хранить мы, соответственно, будем банально...
Такой же синтез?
Нет, никакой.
Не такой.
А, да.
Вот так.
Хранить мы будем буквально этот function pt.
Назовем его call.
Окей, здорово. А где данные?
Если нам прислали лямбду, внутри которой есть какой-то заслаб.
Ну, для этого нам приходится выделить на куче некоторое количество байтиков.
Как бы это лучше сделать?
Да никак это не получится хорошо сделать.
Мы будем это делать вот так.
Нам нужен шаблонный конструктор.
Итак.
Дату мы положим.
F
И на этом устанавливаемся.
Вот такая заготовочка.
Тупая заготовочка, ничего нет.
Просто объект функциональный положили на кучу куда-то дату.
И теперь не знаем, что делать.
Как здесь вызвать диструктор?
Мы же забыли тим.
Ага.
Как здесь вызвать функцию?
Мы же забыли тим.
Внимание от трюков.
Call мы положим в следующую лямбду.
Что не дано?
Так ты же уже все это знаешь.
Ты же точно это видел.
Я уже с ней разбирался.
Причем лямба будет
без захвата.
Иначе как мы положим в этот показатель.
И функцион PTR мы...
Плюс.
А вы не знаете плюс.
Плюс превращает лямбду в указатель на функцию.
Работает только если у лямбы вот здесь в захвате ничего нет.
Мощно, правда?
Внимание от трюков.
Вот этот вот функцион PTR
мы добавим будет звездочку
звездочка помимо args.
И это будет self.
static cast
f
звездочка self
и
и
и
и
и
и
и
и
и
и
и
и
и
и
и
И да, это конечно неправильно.
Вот теперь правильно.
Кажется, это должно работать.
Внимание от трюков.
Вот эта лямба
зависит от вот этого f
при каждом вызове конструктора с разным функтором или лямбда или еще чем-то, вот эта f будет
разная, а значит и лямбда будет разная, в кол будет записаны разные адреса разных функций,
которые уже в свою очередь, каждый из них знает, какая была f, с которой ее сгенерили и туда положили.
И теперь вот здесь мы можем написать просто com data arcs, все.
Ощущайте силу происходящего.
Прошлый раз мы делали TypeRager за счет того, что генерировали наследников интерфейса шаблонами,
которым ко всем можно было через виртуальные функции обращаться одинаковым образом с помощью
на этот раз с помощью шаблонов мы генирием не наследников интерфейса с виртуальным вызовом,
а шаблонные функции или лямбда. Давайте даже чуть по-другому перепишем это. Давайте
заведем функцию. Нет, мы здесь не заведем. Ладно, можем его завести.
Сейчас я просто возьму и вытащу вот эту лямбду в глобальную функцию, чтобы было
чуть понятнее, какого черта происходит. Возможно из-за лямбды все сложнее.
Возможно из-за лямбды все сложнее. Возможно из-за лямбды все сложнее.
Вот так вот. То есть еще раз для каждого такого f мы генерируем свой. Там наверное надо еще
присваивание тоже као с нижней точкой. 200, 60, 60. Наверное паблик сделать все. Вот еще
раз. Для каждого f, который прислали в конструктор, это шаблонный класс, мы генерируем глобальную
функцию као. Что она берет на вход? Некоторые его звездочка, которые кастят к вот этому f,
по которому она сгенерирована, и аргументы, с которыми она вызывает оператор круглой скобки
у вот этого self. Чтобы было чуть более явно, давайте даже вот так напишем стрелка оператор
в глобальной скобке от вот этого вот. Так. Я думаю мы даже это сейчас сможем протестить.
Это получилось. Проверим что за флаг адекватно сработал.
И вызовем f от двух. Да, там типы могли чуть-чуть полететь. Может возвращаемые значения явно
указать. Да, действительно. Лишняя звездочка.
Звездочка, твой звездочка, overloaded.
Короче, у меня ощущение, что беда в том, что вот это деклдайбот авто, это уже какой-то
перебор. Я думаю нам надо по простому сделать просто возвращаемый тип. Вот. Если честно,
я тоже никогда не писал следа function вот этим методом. Я писал немножко другие контейнеры.
Поэтому тут опять может быть мелкие детали, которые лучше всего конечно в библиотеке function2
расписывали. Ну нам главное сейчас понять просто вот этот трюк.
Почему кандидат функции не подошла? Она же подходит. Ну что, надо как-то вот так написать.
Сейчас. Там что-то типа как-то совсем не кастится. Там написано, что function от принимает int,
возвращает int, кастится, принимает твой звездочка int, возвращает int. Здесь у нас
возвращается int, принимается твой звездочка, и еще один int. И здесь у нас.
Возвращается int, принимается int, и будет звездочка есть. Это очень странно. Сейчас там.
Да, и меня это устраивает. А нет, меня это не устраивает.
Здесь обязательно нужно, чтобы без CVREF было, потому что мы указатели просто кастим.
Нет, это не должно быть проблемой. Я сделал инстанциацию функции.
Там какой-то overloaded function type может из-за этого какие-то проблемы.
Очень странно. Давайте попробуем Clang. А это и был Clang. Давайте попробуем v-plus-plus.
Какой он версии? Кажется, это самый свежий. По-моему, еще не выкатил эту историю.
Там же 11.2, самое свежее вроде.
Будем надеяться, что к этой сценам полезнее выдаст сообщение.
Вот это прикол. Как ты создаешь его, вот этот function?
Сейчас, у тебя второй аргумент col это int-wander-sandler.
Второй аргумент col?
Черт, я перевыбедливался. Не нужно ничего forwardить. Нужно просто писать тупой код, пусть копируется, потом все это можно навесить.
Окей, мы справились. Работает ли оно таки? Оно таки работает.
Во-первых, корректно вот этот вот объект захвата лямбда у нас на кучу перенесся с forward, что вообще приятно.
И корректно произошел вызов. Какая-то магия.
Цель TypeRager это забыть тип данных, но запомнить операции, которые можно с ним производить.
Как шаблонами сгенерировать новые операции для каждого типа данных.
Ну, собственно, это и переводит статический полиморфизм динамический.
Раньше у нас было множество разных типов, у каждого из которых свой вызов функции.
А теперь у нас просто множество значений, у которых одинаковый вызов функции, но сама функция runtime значений меняющаяся.
Вот, но мы еще не все объяснили. Вот здесь. Что делать? Да понятно, что делать.
Какая будет звездочка? Вот так, detor.
Конечно, нужно писать не так, а вот так.
Они говорят, что в лесу много скобок. Как это читать?
Против часовой стрелки.
Да, против часовой стрелки поскороли.
Ну, вот нет. Ну, хорошо. Здесь у нас план какой? Запустить detor от data.
Мы закончили.
Мы закончили. А здесь план detor сохранить. Ну, с вашего позволения уже буду объюзить лямбда,
потому что каждый раз выносить вот это вот не хочу.
У нас будет звездочка.
Да, и давайте сохраним
вот этот функциональный тип, потому что мы хотим не воспользоваться, да, все-таки ремонтировать.
Да, плюс просто пишется перед лямбдой и превращает ее в указатель на функцию.
Написать его мы можем только перед лямбдой, где в захвате ничего.
Если в захвате что-то есть, то это более сложная вещь, нежели просто функция.
Таки вот, destructor вызывается.
Наверное, это стоит проверить, как-нибудь хорошо написав тестовый кейс.
А, так у нас еще целых 20 даже.
Напишем tracer.
Думаю, я стану так писать, поэтому все будет в строчку.
Отправочка на будущее.
Все. Все операции, которые только могут производиться с этой штукой, оно трейсит.
Конечно, надо написать.
Все.
Но accept всего лишь значит, делай estate terminate, если вылетело исключение.
Так вот.
А, мне хочется, чтобы оператор углу в скобке был, да.
Что он будет возвращать? Пусть он int возвращает, вперед int.
Да.
Что?
Все нормально.
OK, int положим туда.
Должно 4 вывести, вызывается constructor и destructor.
destructor, move constructor, destructor, destructor.
Ну, в принципе, все правильно, потому что здесь temporary-объект сконструировался.
Этот temporary-объект move-нулся вот здесь.
После этого он удалился.
Я потерял.
После этого temporary уничтожился.
И, наконец, вывели четверку.
И потом вызвался destructor уже все function, который вызвал destructor-tracer.
Все правильно.
Ну, понятное дело, что дальше писать?
Сейчас копии move.
Причем move-ать мы будем из нового звездочка, другой звездочка.
И здесь тоже из нового звездочка, другой звездочка.
Как-то все нормально.
Обычно я хочу на курс.
А что не так?
Как мы будем делать копирование?
Копирование мы будем делать следующим моментом.
Оба статик кастим.
Ну, в принципе, да, в окей статик кастили.
Ну, как бы да, как бы нет, потому что нам мало копий.
Это скорее копий-конструктор.
То есть на самом деле нам нужно уметь в копии-конструкторе.
Ну, давайте здесь напишем.
Так.
О.
Вот так, так сработает.
да, какая общая цель?
цель — вызывать копию констрактора вот этой штуки
и понятное дело, что первым делом мы запустим деструктор нашей даты
а дальше нам как-то нужно получить копию этой даты
да, наверное, мы все-таки будем пользоваться антикипсиктурами
давайте пока просто с копией
просто еще на будущее заметочка, последние 20 минут
наверное, лучше это не досветить
а-а-а
new hook
кстати, cast self
копия, две звездочки, две звездочки
ну и две звездочки
а, это Войдов не исчез, да?
там должен быть звездочка возвращается
вот, и так уже хорошо
теперь мы здесь можем сказать, что дата равно ad-копии
и, соответственно, свой код
ок
давайте попробуем
оператор присваивания
всякие мувы
так, что нам нужно сделать, чтобы...
а, ну, собственно, это я и написал
да
вот
ну, не очень оригинально получилось, да?
ну, на самом деле тут, конечно, куча оговорок
вот тут, ну, ПТР бывает
тут миллион разных оговорочек
что потом вот у этого адера тоже замылить нужно
а, нет, если это копия, то замылять ему ничего не нужно
но при муве таки нужно
вот
в общем, весело
а вот насчет мува, на самом деле, кажется, что даже не нужно вот такой вот метод для мува заводить, да?
мы же просто можем дату мугнуть, все
вот
а теперь начинается гиралаш
это медленно
вот это сейчас, типа, не сильно круче, чем у нас там было с этими виртуальными вызовами
ну ладно, это чуть быстрее
ну да
можно быстрее
большая часть лямб
она что захватывает?
именно так
большая часть лямб, она выглядит как-то вот как у нас здесь было раньше
да, типа, в квадратах это и вот так
то есть мы захватили все подряд по ссылке
ну ссылка это там, типа, сколько?
64 битика, да? 8 байтиков
ну и переменных локальных у нас обычно тоже не очень много
соответственно, суммарно, это вообще копейки
а если компилятор умный, то он еще и как-то хитро вот этот общий захват всего подряд может соптимизироваться
да, что?
он же знает статические офсеты
ну хотя не уверен, что он так делает
в всяком случае, большая часть лямб, с которыми мы работаем, они в захвате хранят очень мало данных
а мы для вот этого маленького кусочка данных, которое меньше 64
или меньше чем 64 байтика может быть
мы ради них делаем тут мю
не камельфо
поэтому давайте ахитрить
давайте если у нас вот тут вот
вернее не так
проще написать, чем говорить
стд variant
и variant у нас будет из-за, грубо говоря, массива байтиков
и его и звездочка
а variant он не делает мю внутри себя?
или он через union?
в этом смысл variant
variant это по сути unit
то бишь он выделяет не на кучу, просто его размер
размер variant равен максимуму из размеров его шаблонных аргументов
и плюс 1 обычно, не факт
там бывает оптимация
может на стейке, а не на кучу?
неправильно говорить, что variant хранится на стейке
мы же хотим на стейке
потому что никто не хочет
нет такого противопоставления, как на стейке или на куче
есть inline, есть на куче
потому что никто не мешает все равно написать variant, который будет выделен на кучу
и получается, что variant на куче хранится?
нет, конечно
речь о том, что variant сам к себе хранит без indirection, без выделений на куче
в своей памяти
не тянет меня язык сказать, что это и называется хранение на стейке
наверное проще говорить, что variant хранится на стейке
следует сторожевая хранительность
следует сторожевая хранительность, да, это модные слова
вот
соответственно
какие костыли предлагаются впилить?
да, вот здесь написать
size of f
size of f
size of f
наверное func, да
все-таки
меньше
давайте заведем
такой вот констант
и предлагается, если размер вот этого объекта, который мы сюда захватываем меньше этой константы
то заталкиваясь все вот в такой вот array чариков
а иначе действовать как раньше и выделять на куче
обратите внимание, что теперь придется добавить немало костылей
потому что во всех и копии
и коле
и деструкторе, и вообще везде
придется делать что-то странное теперь
например, в деструкторе, если вы хранили вот в этой вот онлайновой памяти свой объект
придется теперь не просто там звать delete
а придется звать деструктора
по вот этому вот адресу
и все, и ничего не деликтуется
ну и примерно такие же выкрутасы со всеми остальными вещами
если, например, вы хотите сделать копии
то придется
вместо того, чтобы там просто возвращать new func
придется в...
да, такая сигнатура копии не подойдет, какая подойдет, вы дома подумайте
ну не сложно, да
вам придется в копии передать адрес вот этого буфера
и в нем использовать placement new
ну, placement new для тех, кто впервые слышит
пусть у нас есть какой-то датабуфер на много данных
оказывается, мы можем взять
и прямо внутри этого буфера
инициализировать какой-то тит
я не знаю, например, func
и туда как бы
вот, ну только вместо этого датабуфера
у вас, конечно, должен быть корректно использоваться вот этот
ну и вот, собственно, placement new это
такой вариант оператора new, у которого в скобках потом указывается
указатель, в какой памяти конструировать объект
то есть он не выделяет ничего на куче
это просто запуск конструктора на конкретной памяти
и, соответственно, это может быть копи-конструктор, мув-конструктор, что угодно
вот, соответственно, все кейсы вам придется отработать
да, насчет прикольных методов STD-lib
вот это вот у вас может сломаться
просто если вот так делать, STD-ray чариков или
вообще, конечно, лучше в двадцатых плюсах STD-byte использовать
специальный тип данных для byte'иков
то есть, ну как сказать, просто массив произвольных byte'иков
не понятно каких
но в каких случаях это сломается?
вот бывают такие объекты
которые требуют, чтобы они были выровнены в памяти
кто может придумать пример такого объекта?
не обязательно колобом
потому что
ну какие-то векторных операции там нужно, чтобы...
да, вот оно самое
какие-нибудь интриги, векторные операции, Синды
они требуют выравнивания, соответственно, данные, которые мы храним и перекидываем куда-либо
должны быть выровнены
ну и как бы выразить это, если вы хотите
то есть, если вы хотите выразить это
куда-либо
должны быть выровнены
ну и, конечно, обычные не просто массивы флотов передают
создают специальную структурку
в которую уже хранится там
четыре флота, не знаю
давайте Вех-4 назовём
и где-то здесь пишут
align s
и 4 на...
по-моему, да, 4 на size of float
что не так?
да, я-то не помню, где эти аттребуты написать
о, вот так вот, да
то есть мы теперь потребовали, чтобы на самом деле везде в плюсах
где используется этот тип Вех-4
его адрес был кратен 16
то есть он никогда не может лежать
по адресу там
миллион-миллионов или плохо
ну вы поняли, да?
остаток отделения адреса на 16 всегда был
даже если вы на куче выделяете
оператор в неё это будет уважать вот это вот требование align s
и там всякие выделения на стреке
тоже будут это уважать, если нужно будут
пэдинги и выравнивания делаться
а вот у нас это не уважается
и как-то я использовал библиотеку айген, которая очень сильно
объюзит интринзики вот такие штуки
и если вы нарушите этот контракт с выравниванием
вы получите такую больную ошибку
в которую дважды только можно молитвить
смотришь код, меняешь, что попало
и молишься, что оно исправится
там почему невозможно догадаться
из-за чего оно именно так сломалось
да, в рентайме конечно
то есть в рентайме внезапно получается секвел
там где он физически не мог получиться
в стекстрейсе нет абсолютно ничего
под дебаг режимом запускаешь секвел
в общем грустно
поэтому std-rate и std-bytes мы используем только чтобы
передавать какие-то сырые данные, которые не плюсовые структуры
если вы по сети что-то перекачиваете
подобные вещи, вот это как раз
а когда вы собираетесь в каком-то буфере
хранить структуры плюсов с помощью
оператора new, вы должны использовать
std-alignet storage
std-alignet storage
просто alignet storage
он принимает size
и alignment
который мы конечно же не знаем
у кого?
у кого ты собрался спрашивать align of?
f?
соответственно здесь начинается некоторая беда
поэтому мы будем использовать
стд-alignet storage
стд-alignet storage
начинается некоторая беда
поэтому, ну да
я не помню как он пишется
а там же max-align вроде для
дефолтных типов
в данном не подходит
ну вот тут уже начинаются такие махания руками
что типа, ну вот столько, наверное хватит
давайте столько бахнем и все будет хорошо
можно ассерт добавить
да, мы можем
вообще размер кашлини обычно
точно всем хватит
можно сказать, что если у нас не такой align, то делаем new
small-buffer это на самом деле должен быть размер кашлиний
минус вот эти данные
ну и здесь можем
давайте просто вот так бахнем
собственно когда мы будем инстанцировать конструктор
мы можем сделать статик ассерт
на то, что
ну ладно
а почему new не вызывать в этом случае?
почему не вызывать new обычный, когда мы делаем small-buffer?
нет, когда у нас align неподходящий
можно, можно
это хорошая идея, кстати
ну это очень сложно представить себе тип
который, да, давайте тогда скажем
что размер меньше small-buffer size
и align of
func
что должно произойти?
нет, делимость должна быть
там всегда степень двойки
а align of
гарантирована степень двойки?
там всегда align степень двойки
окей, здорово
вот видите
давайте вот так
а ладно, за то, что мы здесь ничего не написали
давайте напишем
да, нам нужно нашему варианту data
на самом деле я предлагаю
еще один вариант добавить std monostate
который, да, на случай, когда у нас ничего
если он первый
в перечислении вариантов
то по дефолту именно он будет сидеть
нам нужно сказать data
как его привлечь?
наверное просто emplace
я, если честно, не забыл
я вроде сработал
то есть мы сейчас emplace или default на конструируемый
align storage, но он ничего не делает, он пустой
и там ничего не происходит
теперь мы можем делать сюда target по индексу 1
вроде вот так
типа просто вот так
оно вроде должно работать
я надеюсь, по крайней мере
да
теперь мы можем взять этот адрес
и вызвать new туда placement
func от forward
f of f
красота
оно все равно не перестало жаловаться
но вот точные детали
как это подстроить
нет, в стандарте не надо смотреть
потому что там косяки
скорее всего там действительно косяки
с учетом того, сколько косяков STD function просто
я не удивлюсь, если и с этим
проравнивание возможно
стандарт сам почитать, да
а стандартные библиотеки смотреть реализацию не стоит
вот эти детали и размеры предлагаю с function2
просто взять целиком
собственно как-то в целом так
теперь вопрос
ничего ли я вам не забыл рассказать
представьте, что вы это прямо сейчас пишете
какие у вас могут быть вопросы
да, ну и вообще нет
там в задании не требуется callable
мы можем даже прямо сейчас
открыть function2
и посмотреть, например
что смотреть
смотрите, как они делают
разные функции
у них просто один и тот же functionbase, который кастомизирован
с помощью каких-то флажков
дожди, я не увидел
покажи еще раз
в полисе бейс дизайн
про это я тоже хочу рассказать
что мы Александреску догоняли
да, да, да, не подведем мы Александреску
нужна
class function
вот что я забыл
так, смотрите
здесь у нас десяток каких-то разных указателей
неудобно, давайте все это в одну структуру объединим
ну по сути ровно это и будет происходить
структурка
птр
где можно
давайте как у них
in walk table
куда мы перенесем вот этих всех бравых ребят
ну
с colt птр немножко неприятно
давайте пока оставим
но в задании вам хватит просто вот так вот
in walk table
который у нас будет храниться
такие указатели
в общем да, здесь можно добавить указатель
в in walk table
но тогда у нас будет два indirection
ну и вот здесь
мы можем добавить
в таблику
в таблику
в таблику
в таблику
но тогда у нас будет 2 indirection
нам сначала разаменовать вот этот указатель нужно
а потом разаменовать указатель функции
это не очень приятно
можно так, там есть разные хаки
не зря эта библиотека такая сложная
тут много разных хаков, которые нужно все учесть
как-то заюзать и чтоб все было круто
Кажется, они просто к ней наследуются. Можно вот так сделать, но давайте просто вот так сохраним и более того, да не более того, все. Давайте просто вот так на этом это оставим.
По-моему, тут еще есть некоторое количество антимайзов, которые я уже как-то не успеваю забывать. Возможно, я мог меньше деталей и больше впихнуть, но я рекомендую попытаться почитать этот код.
Пусть даже это будет для вас первый опыт чтения сложного шаблонного мета кода, начиная с чего-то надо. Уж очень хороша эта библиотека.
Вот. Ничего бы не забыли ли.
Тут просто еще один хитрый слой indirection использовать. Вот тут некоторые объекты рейжеров, которые как бы в полисе Baste умеют генерить вот эти вот таблички с type rager.
То есть они как бы вот эту табличку разных конструкторов, деструкторов или операторов вызова или еще чего-либо тоже сделали метапрожный шаблонный, чтобы совсем улететь на Луну.
Это, конечно, усложняет все дело.
Класс. Рейжер, вот.
Ну да, они изобрели VTable, потому что если вы задумаетесь глубоко и хорошо, вот эта штука – это VTable.
И чем наше решение отличается вот текущее от решения на виртуальных функциях? Вот эти.
Нет, нет, нет. Мы убрали здесь звездочку.
Ну, то есть что хранится в классе с виртуальными функциями – указатель на виртуальную таблицу.
А вот эту саму таблицу, если мы указателем собираемся ее хранить, можем ее объявить статической вот здесь вот.
Соответственно, для каждого шаблонного аргумента будет своя такая статическая переменная сгенерена, и мы будем прокидывать указатель на нее.
И вот тогда мы полностью переизобрели виртуальные функции.
Если сделать вот так, то мы сделали чуть более оптимизировано, чем виртуальные функции, потому что всего за один indirection проходим, а не за два.
И работает это действительно быстрее. Но памяти ждет больше.
Вот, в общем, давайте на этом закончим.
Вот этот весь месивный код я, конечно, заканчу сейчас, но зачем?
Так, мы здесь, мы здесь.
Вот, может, и все.
Ура, все, у вас должен быть вот этот код.
Он такой сунгуртный, но на правильные идеи по решению ДЗ должен натолкнуть.
А выложу его, надеюсь, сегодня.
Я хотел еще одну дозу впихнуть по дайп-листам.
Помните, я говорил, чтобы посортировать, дай к чиплам, вернее, посортировать их.
Такое несложное, надеюсь, чисто позапонить.
Вот, я все еще планирую его сделать, но, надеюсь, его вывали.
А вот поэтому вот прямо сегодня, видимо, уже и выложу сразу.
Оно уже готово.
Все, если никаких вопросов нет, всем спасибо.
Всем стоп.
