Всем доброго дня, мы уже, я не знаю, раньше у нас лекции начинались в 11.40,
теперь у нас начинаются лекции аж в целых 11.55. Да, собственно у нас есть сейчас внезапно час
пять минут, чтобы начать новую тему, значит тут было голосование, по которому выяснили,
что люди предпочитают новую тему, вот, вместо того, чтобы разбирать линейность для алгоритма.
Нет, в нем будем разбираться на следующих лекциях, вот. Решили сменить немного тему,
чтобы немножко было попроще и контролем было понимание, что происходит. Значит,
наша сегодняшняя тема это, конечно, преобразователи. Значит, смотрите, какая у нас мотивация с вами,
мы умеем с вами уже распознавать какие-то слова, да, а вторых, мы можем ли мы их каким-то образом
трансформировать, то есть чтобы у нас что-то приходило на вход, ну и допустим мы что-то получали
на выход. И для этого давайте сначала вспомним, какая у нас таблица, есть точнее те абстракции,
которые мы с вами уже разбирали, которые именно компьютерная абстракция. Вот давайте начнем с
автомата. Что у нас с вами представляет собой автомат? Что он на вход принимает? На вход он
принимает слово. Есть ли у него какая-то дополнительная структура данных, которые мы пользуемся?
Ничего там нету. Да, ну собственно, автомат сам по себе. Что он на выход дает? Да, бит 0 или единичку.
Какая была абстракция следующей, которую мы с вами разбирали? Не-не, регулярная это эквалент
автомата с точки зрения распознавания. Просто регулярка обычно для нас создана. Да,
mp-автомат. Что он на вход принимает? Ага, есть ли у него какая-то дополнительная структура? Да,
а на выход что он на... Да нет, ну то есть тоже бит. Как вы думаете, вот следующая абстракция,
которую мы с вами будем разбирать, которая является конечным преобразователем, какую структуру будет
иметь? Ну тоже автомат. На вход, как вы думаете, что он будет принимать? Слово. На выходе? На выходе
она будет принимать слово. А как вы думаете, дополнительная структура у нас будет в ней? Нет.
Мы просто пытаемся понять, чего не хватает. То есть смотрите, у нас было на входе слово всегда,
и раньше на выходе мы давали ответ только да или нет. Хочется вместо выхода да или нет давать
на выход слово, то есть преобразовывать наше входное слово. То есть мы по факту, если раньше занимались
просто принадлежностью слова и языка, да это всегда так возникает, то мы можем изучать такой объект
как конечный преобразователь kp-тель. Почему тель? Потому что есть такой объект как конечное
преобразование e. А конечное преобразование мы с вами будем обозначать как kp. Потому что
конечное преобразование каждый раз писать достаточно тяжело. Значит смотрите, вот все вот эти вот разделы,
которые у нас были, вот здесь вот мы с вами по факту определяли, так сказать, как это называется,
лексический анализ проводили. В качестве AP автоматов, это у нас в контексте свободной
грамматики, мы с вами уже определяли синтоксический анализ. А вот конечные преобразователи будут делать
кое-какую другую вещь. Какие разделы русского языка вы знаете? Вообще какие разделы лингвистики вы знаете?
Диалектология близко, кстати. Арфаэпия, ну если вам нужно по слову написать транскрипцию, то да. Это
морфология. Чем занимается морфология? Ну да, мы можем преобразовать части речи из одной
из одного подраздела в другое. Например, склонение и спряжение. Столовая, нет чего столовой. Да,
это существительное. Но суть в том, что мы можем сказать, у нас есть, допустим, морфологический разбор слова
столовая, нет кого столовой. Значит, что у нас произошло при том, что у нас существительное
поменялось на родительный падеж? Да, смотрите, у нас с вами последние две буквы ая заменялись
на последние две буквы ой. И кажется, что такое можно сделать конструкциями, похожими на конечный
автомат. Вот, это вот мельта мотивация, которую мы с вами будем рассматривать. Что бы вы понимали,
где это еще работает, есть такой партия, что в питоне, кстати, частенько используется. Называется
primorthy2. Потому что вторая версия, во-первых. Вы не поверите, при помощи этого как раз пакеты
генерируются условия контрольные? То есть вы пишете, допустим, одно число, дальше вы даете на вход два,
оно по ходу два вы генерирует слово числа, два числа. Да, да, да. Да, эта библиотека написана русскими
лидиямия для морфологических изменений. Такая удобная достаточно вещь, она правда основана
в большей части на словарях и на автоматах, но в целом она помогает вот какие-то простые конструкции
морфологически генерировать. Вот так пишется.
Morphology также пишется, а slowmorph. Конечно, вы не поверите, когда я поступил в УС, он только
как раз только вышел. Это было в тринадцатом году. Да, мы тут как раз коллегами смотрели,
что Python 3.7 уже скоро будет. Да, да, да, можно. Ладно, давайте прийдем все-таки к теме, то есть вот
эта вот мотивация наша цель понимать, что умеет конструкция, связанная с преобразованием автоматов,
вот, который умеет на входе принимать слово, на выходе тоже отдавать какое-то слово. Значит,
смотрите, давайте введем первое определение. Конечный преобразователь, он же у нас будет
называться теперь дальнейшим каптилем. Это объект вида m, q, sigma, gamma, delta, q0, f. Опять же,
подчеркну, что все множества конечные у нас здесь такие, что, значит, q это состояние,
sigma это входной алфавит. Как вы думаете, гамма это что такое? Да, гамма это выходной алфавит.
Как вы думаете, это под множество, какого множества?
Q на sigma со звездой мы переходим, проходим по переходу,
считываем с него какое-то слово, на выход пишем слово. Так, q0 где лежит? Q, да, в стартовом состоянии,
а f это что у нас с вами такое? И получается, как мы будем с вами писать переходы? Переходы
обычно пишутся следующим образом. Как у нас было, у принадлежит sigma со звездой,
ну и принадлежит гамма со звездой. И переходы можно писать двумя способами. Какой вам удобнее,
что-то можете использовать. Первый способ писать переходы, это вот таким образом,
как мы писали переходы по автоматике. Ну иногда, когда хочется прямо показать,
что это конечный преобразователь, иногда пишут следующий. На входе пишется слово u,
на выход пишется слово v. То есть это просто два эквалентных обозначения.
Ну то есть мы записываем тоже по квадрату? Да-да-да. Ну вот регулярно там можно сделать,
ну нет, такое мы не делаем. Да-да-да, то есть надо сначала обычнить приставку,
возможно перейти в какие-то разные состояния, потом перейти в состояние,
в которое мы будем распознавать корень, слово, а потом еще мы будем
определенный набор состояний, которые будут распознавать суффикс. То есть мы читаем подряд.
Без разницы. Мы уже поняли, что на самом деле только в получать какие-то свободные грамматики
важно, чтобы сигма и гамма не пересекались, а здесь уже без разницы. Вот пример конечного
преобразователя. Давайте поймем, какие слова он может распознать. А это что, их очень много здесь?
Пара, вход, выход. Да, смотрите, любые слова, которые заканчиваются на а, и при этом смотрите,
если последняя буква а, то она стирается. То есть это на самом деле, это конечный преобразователь,
как ни странно, берет произвольное слово, и если у него последняя буква а, то он ее стирает.
То есть это по факту у вас удаление окончания а, можно так сказать. Вот, то есть вот такой конечный
преобразователь. Наверное, у вас уже были семинары по конечным преобразователям, были? Нет,
у вас еще не было. Вот поэтому Дмитрий меня спрашивал. То есть у всех по-разному, у кого-то уже начались,
у кого-то уже нет. У кого-то еще нет. Теперь давайте подумаем, как определить конфигурацию конечного
преобразователя. Это пара, ой, тройка, Q, Q, V такие, что Q из Q, Q из сигната Q, V из гамма Q, V из гамма Q, V из гамма Q, V из гамма Q.
Давайте подумаем, что хотелось бы сказать о отношении в выводимости.
Да, это наименьшее рефлексивное и транспортированное отношение.
Такое, смотрите, предположим, что у нас с вами есть переход Q1U переходит Q2V.
Тогда давайте подумаем, что нам нужно сделать, чтобы корректно это все определить.
Наверное, нам нужно для любого X сигма с звездой, для любого Y из гамма с звездой что-то написать.
Что именно?
Давайте абстрактный смысл. Значит Q это то, что мы с вами видим, осталось прочесть.
А здесь вот это то, что у нас есть, это то, что мы уже записали.
Я сейчас это еще раз на флаге покажу.
То есть неформально. Находимся в состоянии Q, осталось прочесть слово U, на выход мы уже написали слово V.
Тогда давайте поймем, как у нас подставляется конкурент.
Да. У X есть слово Y. А здесь что у нас будет тогда? X, Y, V.
То есть мы считываем с вами U, пишем V.
И вот здесь важный тонкий момент. Раньше мы определяли принадлежные слова языка.
Ну это рефлексивность. Транзитивность позволяет нам построить замыкание более чем за один переход.
Теперь вопрос. Как вы думаете, такая конструкция может по одному входу делать несколько выходов?
Конечно, может. Поэтому важно в данном случае сделать одно важное определение.
Это коммерческое преобразование.
Значит, это следующая вещь. Это мы будем обозначать 5.
Это множество пар УВ таких, что существует завершающая Q.
То есть Q0, Qo, мы получаем Qo.
Вопрос на понимание гиперсийной математики, февральчитила, основного станка, бинатарики.
Что это за объект?
Это соответствие.
Не отображение, не функция, а именно соответствие.
То есть у нас для любого входа может не быть выходов, и для нового входа может быть сколько угодно.
И как раз поэтому у нас есть понятие конечного преобразователя, есть понятие конечного преобразования.
Конечное преобразование, мы будем говорить, что это соответственно которого существует конечный преобразователь, задающий эти пары слов.
Хорошо.
Так, значит конечное преобразование состоит из пар УВ, можно построить соответствие из УВ.
Значит, мы понимаем с вами, что если у нас
для любого У мощность в Qoq
мы можем это написать вот так
равной единице, то ψ это отображение.
Кажется, здесь пока что ничего такого нет.
А?
Не, ну функция обычно в число отображает.
Ну да.
Конечное преобразование это соответствие из сигматов с vu в Гам Safety enable,
для которого существует конечное преобразование.
Мы можем, смотрите, задать конечное преобразование для фиксированного конечного преобразователя
или мы можем определить, как некоторые отношения
между некоторой соответствием из сигматов с vu к Гамma С certification,
หน доброго существует конечнее преобразователь,
который его задает.
Вот, и мы будем говорить следующее. Мы будем говорить ватердно.
Во-первых, конечное преобразование для преобразователя.
Но если мы это не упоминаем, это означает, что существует конечное преобразование.
Хорошо. Давайте посмотрим пример вводимости слова.
Собственно, иску 0 мы по a, b, a, e. Куда идем?
В q1, a, b, a, e. Дальше что делаем?
Съедаем a, мы получаем q1, b, a, a.
Потом q1, a, a, b. И дальше что? q2, e, a, b.
То есть у нас получается пара a, b, a, b принадлежит этому конечному преобразованию.
Конечно, вы преобразоваете μ, который сдается к конечному преобразователю.
Хорошо. Сейчас будут некоторые примеры. Они на уровень упражнения тянут.
Ну, таких очевидных фактов, что можно задавать конечным преобразованием.
Что является конечным преобразованием. Давайте как раз разберем все эти примеры.
Первый пример. Identity.
Какая идентификация у нас?
Пепля.
Пепля по всем символам.
Да, пепля по всем символам.
Символы разлога.
Ну да, конечно же.
Вот такая она. То есть для любого x мы по входу x генерируем выход x.
Вот она картинка.
Второй пример.
Это, скажите, такие технологии программирования и всяких технических вещей, что написано в операции?
Вот это вот.
Так?
Ну вот, я слышу правильные слова.
Перенаправление в девну.
Вы можете написать.
Мы кома?
Ага.
В выход ничего не пишется.
Стрелочка это оператор вывода.
Ну да.
В этом деле прав, что нужно добавить апперсан, чтобы stdout и stdir улетало в этот файл.
Это файловый дискрептор, который, ну по факту, файловое устройство, которое позволяет вам спрятать весь вывод.
Знатоки курса PD уже знакомы с этим оператором.
Да.
Ну да, а вот это означает, что типа stdout, stdir в stdout направляет.
Ладно, короче, тут надо какой-нибудь игре по истории сделать, чтобы найти эту команду.
Я образно пишу.
Так, вопрос. Как построить конечную преобразователь для этой штуки?
А?
Не, не, у, вот это регулярный язык, если что.
Ну как бы вход у нас должен приниматься только из слов регулярного языка.
Да, берем автомат.
И на каждом переходе мы пишем вместо слова, на вход слово у, а на выход epsilon пишем.
То есть мы как бы считываем все слова из регулярного языка, а на выходе ничего не оставляем.
А?
В смысле петлю?
А что делать, если у нас язык бесконечный? У нас регулярный язык может быть бесконечным.
Ну, он может состоять из бесконечного количества слов, я про это говорю.
А со звездой допустим?
Вот, аналогично можно построить следующую вещь.
Да, все просто наоборот. Так, третья.
Представьте себе, у нас с вами есть два конечных преобразования, как сконктимировать.
Да.
Ну, конечно.
Тут все свойства автоматов действуют, что существует конечный преобразователь с одним завершающим состоянием.
Всем это понятно?
Что любой конечный преобразователь может создать конечный преобразователь с ровно одним завершающим состоянием.
Да, надо просто втянуть epsilon по входу и по выходу.
Поэтому конструкция у нас вот такая.
Здесь ничего сложного нет.
Так, хорошо.
Ну, картинка знакомая.
Четвертый.
Вещь это приписывание слова произвольного.
Как это сделать?
Да, сконктимировать id со вторым.
На самом деле id сконктимировать вот с таким свойством.
Хорошо.
Так, я проверю, что Zoom работает.
Пятое. Объединение.
Как строить объединение?
Да, да, да.
То есть все вот свойства, которые у нас были для автоматов, они поддерживаются.
Ну, объединение, iteration, concatenation.
То есть здесь все то же самое.
Хорошо, пример шесть.
Гомоморфизма.
Ну, конечно.
От epsilon будет epsilon, да.
Это даже кажется можно вывести.
Ну, да.
Как построить?
Ну, на самом деле нам нужно построить конечный преобразователь для каждой буквы.
Нет, пока что примеры рассматриваем в преобразовании, которые существуют.
То есть вот, допустим, у нас есть отображение из одного языка в другой, да, из одного слова в другой, который является гомоморфитами.
Наша цель представить его в виде конечного преобразования.
Но вы близко идете, правильно сказали.
Наша цель сейчас будет состоять в том, чтобы доказать, что любое конечное преобразование можно представить в виде каких-то простых, обвинения каких-то простых конструкций.
То есть если у нас есть гомоморфизм Си из одного языка в другой, то мы его можем задать.
Так, только здесь важно, что это буква.
Вот так это выглядит. То есть нам достаточно задать...
Да, кстати, примеры.
Ну, чтобы понять, примеры гомоморфизмов.
Значит, это либо каждую букву мы удваиваем с вами, либо кирпичный язык, солнечный язык, я не знаю, было у вас в детстве такое или нет.
Ну, вот и потолок.
Вот это все можно писать некоторым гомоморфизмом.
Вот.
Собственно, задается это достаточно простым образом.
Так, обратный гомоморфизм давайте обсудим.
Тут этого функции нету, но оно должен быть.
Я не понял, что мы задавали.
В плане, у нас есть какое-то соответствие.
Да, которое оказалось, что является гомоморфизмом.
Да, наши цели его задать в конечном сетке.
В конечном сетке существует конечное преобразование.
Да, которое задает этот гомоморфизм.
Мы его задали.
Сделали астропаховый преобразователь с одним состоянием.
Он на фото снимает букву, произвольную букву, и на выход подает ее образ.
Вы говорили, что получается конечное преобразование.
Да.
Ну, потому что чем задается гомоморфизм?
Гомоморфизм обычно в группу создается базовыми элементами, полугруппом.
Как осуществлять обратный гомоморфизм?
То есть наша цель – получать измены впервые.
Но по факту надо поменять то, что здесь было местами.
Единственное, смотрите, здесь тонкий момент есть.
Вот раз скажу, очень важный.
Да, здесь вот так вот.
Здесь однозначности никто не требует.
Хорошо.
Вот здесь есть тонкий момент.
А как это аккуратненько сделать?
На самом деле у нас, думаю, два разных слов.
Да.
Два перехода по одному и того же слово.
Да, но мы детерминированность не требуем.
Мы запрещали, мы написали, что у нас 9 при этом, потому что Q на sigma со звездой.
Поэтому из каждой вершины может сходить не больше одного.
Не, Q на sigma со звездой на Q на sigma со звездой.
То есть по одному состоянию мы можем перейти в другое.
Так, этот пример с вами должны на семинарах будут разобрать, как два числа складывать.
Типа, если у нас числа подаются в бинарной записи, то можно, собственно, использовать состояние автомата как бит переноса.
Нормально.
Там причем они идут по битово.
То есть сначала последние биты X, а потом последние биты Y.
Иначе, кстати, можно доказать, что такое сложение работать не будет.
Да, то есть у нас есть два числа, которые записаны в двоичной записи, причем биты подаются вот в порядке 0, 0, потом 1, 0, 1, 1 и так далее.
То есть вот в таком порядке.
Да, да, да, и бит его начали складывать.
То есть нам главное уметь хранить бит переноса.
Хорошо.
Так, и сейчас мы наконец-ки начинаем доказывать какие-то факты.
То есть мы рассмотрели с вами примеры, все примеры были понятны?
Это вам не лерд оказывать, как говорится.
Все достаточно легко.
Давайте докажем следующий факт.
На самом деле мы его доказывать не будем, как ни странно,
потому что это факт, вы сейчас увидите, что большая часть это просто то, что не будет стояться на следующей вещи.
Значит, утверждается первое, что для любого конечного преобразователя можно сделать следующее.
Можно считать,
что
почему
Ну да, в списку конечных преобразований это совсем сложно.
Почему?
Значит, первое.
Если у нас с вами есть переход,
это мы это все уже увидели.
Это что, он за один?
Нет, с ним пойдет.
Такой конечный преобразователь, кстати, он очень интересный,
потому что оказывается, в каком очень его можно сделать из контекста свободной грамматики, из контекста зависимости.
Ну типа, на вход принять контекст свободного языка, на выход выдать не контекст свободного языка.
Да, да, да. Из нас спит на конечности, мы это будем доказывать.
Ну да, я думаю, что мы это будем доказывать.
А?
Да, да, да. Из нас спит на конечности, мы это будем доказывать.
Так, ну первый шаг.
Это какой?
А второй шаг, смотрите, какой.
Второй шаг у нас будет в следующем.
Убрать epsilon-epsilon перехода.
Я думаю, это доказывать не надо.
Как они убираются еще раз?
Берем epsilon.
Да.
Берем дерево epsilon, берем существенный переход и делаем вымахание.
То есть так же, как удаление epsilon-перехода.
Так, это первый факт, который нам нужно было доказать.
Теперь давайте подумаем еще одну вещь.
Сделаем.
Во.
Значит, следующие факты, которые позволяют посмотреть,
а что же такое конечное преобразование по факту.
Значит, это следующее утверждение.
Оно будет состоять из трех фактов.
И мы будем доказывать, что это конечное преобразование по факту.
Значит, это следующее утверждение.
Оно будет состоять из трех фактов.
Первый факт, область определения конечного преобразования,
это регулярный язык.
Да.
Значит, второе, область значения конечного преобразования,
это тоже регулярный язык.
Тоже вроде логично.
Да, мы просто берем эти, смотрим на выходы, получаем автомат.
И третье, это индуцированное конечное преобразование по регулярному языку.
То есть, это те регулярные, это по факту такое соответствие,
которое принимает только слова из нашего регулярного выражения.
И на выходе выдает то, что должен был выдавать от конечного преобразования.
На этом можно...
Как ни странно, будет пересечение двух конечных преобразователей.
Я не знаю, мы хотим это строго доказывать.
Да, давайте на третью хотя бы отчасти начнем писать формально,
а дальше посмотрим.
Теорема.
Пусть фи это конечное преобразование.
Тогда, первое, область определения фи это регулярный язык.
Образ.
Это тоже регулярный язык.
И третье, это...
Если R регулярен, то тоже конечное преобразование.
Значит, первые три свойства, мы с вами первые два свойства уже говорили.
Это означает, что это конечное преобразование может принимать только слова из родного языка.
Это может принимать отход любой слова из родного языка.
А потом мы взяли регулярку из двух букв A, которые повторены сколько-то раз.
Как у нас это происходит? Мы можем убрать переход по символу A,
потому что тогда он станет пустой.
А если мы его не уберем, то у нас будет заниматься все.
Первое, только входы смотрим.
Второе, только выходы.
А вот третье, это интересный факт.
Значит, смотрите, что такое регулярный язык?
Чем его можно задать?
Еще?
Еще?
Так, нет.
ДК.
Можем задать его ДК.
Тут есть некоторые примеры.
Мы берем наш преобразователь, который задает ПСИ,
и делаем ДКМ.
А дальше, смотрите, что мы делаем.
Построим декартовое произведение.
То есть наша цель сейчас будет пересечь входы регулярного выражения и входы нашего ДК.
Смотрите, я сейчас картинку нарисую.
Вот это, допустим, наш Т, а вот это наш К.
Значит, смотрите, если у нас есть декартовое произведение,
есть переход по букве А из состояния КУ1 КУ2,
а в нашем конечном преобразователе существует переход из П1.
Так, давайте.
КУ это у нас в преобразователе, поэтому автоматизируем П1 П2.
А здесь есть переход из КУ1 КУ2,
который съедает именно эту букву А,
то мы делаем переход в нашем конечном преобразователе по вот таким вещам.
То, что берет на вход по букве А,
то мы делаем переход в нашем конечном преобразователе по вот таким вещам.
То, что берет на вход А и на выход по букве А.
Ну, почти то же самое, да.
А еще смотрите, здесь нужно делать кое-какую аккуратную вещь,
что везде вот в этих конструкциях,
если у нас с вами был переход из F7PB,
то мы делаем вот такие горизонтальные переходы.
На всех состояний.
То есть мы меняем переход, меняем состояние в нашем конечном преобразователе,
но не меняем состояние в нашем автомате.
Нам надо контролировать не только то, что мы считаем со входу,
но и то, что мы пишем на выход.
То есть вот эти состояния мы с вами контролировали пересечением,
а вот эти оставляем как есть.
Угу, понятно, да?
Потому что теперь это формально, если записать,
то это выглядит вот таким образом.
Состоит из, во-первых...
При условии...
Здесь переход в нашем конечном преобразователе
и есть переход в нашем автомате.
Так, объедини...
с...
Q1P...
Получается...
Epsilon в...
Q2B,
если у нас получается следующая вещь,
то из Q1Q2...
Ой, Q1 в Epsilon есть переход...
Q2B.
Ну и здесь надо просто оказать чуть-чуть новую лему...
следующего образца.
Вот такой вот факт нужно уметь доказывать.
Значит, получается, что мы можем прочитать в нашем конечном преобразователе
построенное наше слово тогда и только тогда...
Чуть-чуть...
Где мы?
Чуть-чуть закотим...
выводится...
Epsilon в...
Тогда и только тогда...
Когда мы в каждом из них можем это сделать.
Да, да, да...
Так, с первого хода как-то, что это неважно...
Если бы не стоило тогда добавить переходы не только в петли, а еще в переходы...
Короче, в петли это не снимается?
Да, нет.
Сейчас, вот тут есть один тонкий момент, который мы сейчас будем с вами рассматривать.
Возможно, что в нем понадобится, что это ДК.
Давайте посмотрим.
Смотрите, как вы думаете, в какую сторону сложнее доказывать?
Слева направо или справа налево?
Слева направо?
Да, если подумать...
Ну, это да, если меньше подумать.
А?
Да, слева направо, на самом деле, не сложно.
Это индукция по длине вывода в этой грамматике.
Вот у нас правило есть.
Какой грамматик?
В нашем преобразователе.
Собственно, берем распичку.
То есть у нас там первый переход.
Либо вот такой...
Да, это значит, что у нас есть выводы в основании.
Либо переход такой, тогда мы рассмотрим.
Поэтому интересно рассмотреть переход справа налево.
И давайте поймем, по какому параметру мы будем делать индукцию.
А?
Ну да.
По сумме длины вывода.
Так, это в правую сторону переход.
Тут можно просто прочитать.
Тут есть несколько вариантов.
По сумме длины вывода.
База.
Значит...
У1, у эксион выводит у2, эксион в, в 0 шагов.
Что из этого снижается?
У эксион, и в в равняется эксион.
И в в равняется эксион.
Да, снижается.
Это логично, да?
И второго факта.
0 шагов?
Ну тогда давайте поймем, что такое...
Пара Q1P1?
Эксион, эксион.
Она как раз выводит пару Q2P2, эксион, эксион.
Логично, да?
Так, переход.
Здесь интересный переход.
А, да, кстати.
Ну...
Да, в общем, тут нужно автомация набуковыми переходами.
Ну, пока да, пока автомации набуковыми переходами хватает.
Короче, это можно затереть.
Так, переход. Значит, смотрите.
Давайте рассмотрим последний переход в нашем автоматике.
В нашем конечном преобразователе.
Так, переход.
Здесь более мощная база подойдет.
Смотрите.
Если здесь эксион у пустое слово,
вместо U пустое слово,
то здесь неважно, за какое количество переходов.
Мы просто явно выводим количество переходов полно нулю.
А?
Да, здесь одному самому.
Хорошо, так, давайте...
Мы с вами начнем переход.
Значит, рассмотрим последний переход, который у нас был.
О, что там?
Значит, какие у нас варианты здесь могут быть?
Смотрите.
Первый вариант, что мы вот здесь вот считываем буквом.
Второй вариант, какой здесь может быть?
Да.
Третий вариант, на самом деле, по идее, должен быть.
Ну, давайте рассмотрим первый сначала.
Значит, тогда у нас есть переход следующий.
Q3, A.
Вот Q2.
Тогда давайте выводить, что это означает.
Это означает, что Q3 равняется A,
а в N3 равняется B.
Ой, Q3.
Вот это слово тогда равняется A.
Да?
Хорошо.
Значит, V3 равняется V.
И тогда мы можем сказать, что U
это некоторое U'A.
И смотрите дальше, что мы делаем.
И вот тут тонкий момент, кстати, который говорит следующее.
Значит, у нас с вами из P1 по слову U
считывается P2ε
в нашем автомате с однобуквенными переходами.
Да?
Значит, смотрите, существует перемычка,
что у нас верно вот это соотношение.
Так, по-моему, уже вот трогление будет, поэтому
P1 U'A мы выводим, смотрите, P4A
и за один шаг мы выводим P2ε.
Что?
Сложный.
А?
Сложный.
Сложный факт.
Но здесь, кстати, мы пользуемся, что у нас автоматомодобуквенными переходами.
Да.
Теперь давайте собирать факты.
Собираем наши факты.
Смотрите, что у нас получается.
У нас получается интересная вещь.
Что?
Утверждение.
Мы можем сказать, что тогда,
по предположению индукции, внезапно
у нас пара из пары Q1P1U'ε
будет выводиться пара Q3P4
εv.
Откуда это следует?
Это следует из того, что вот это U'A у нас с вами,
а вот это A,
а вот это V.
То есть как бы получается, что мы с вами,
у нас вот здесь есть переход для
из Q1 в Q3, который съедает U' на выход, пишет V,
а здесь у нас получается переход, который
заменчивает число шагов, из P1 делает P4,
считывая это слово U'.
Ну да, да, да.
Не, мы для любых паровершен это делаем.
Ну а тогда смотрите, здесь уже все достаточно просто.
Мы пишем U'A,
когда мы выводим с вами Q3P4,
A, V,
В,
В,
В,
В,
А, В,
и дальше за один шаг,
поскольку вот у нас есть вот такой образ.
Правильно?
Что, значит, если мы с вами,
у нас с вами есть переход, который считывает букву A,
из Q3 в Q2,
а есть переход, который из P4 съедает букву A,
то мы получаем с вами пару Q2P2, X, Y.
То есть как бы проконтролировали все кроме последней буквы
и сделали переход по последней букве со входа.
Это первый случай.
Второй случай.
У нас с вами пишем букву B на выходе.
Тогда давайте его рассмотрим.
У нас получается,
за один шаг,
получается есть
переход по суну Q3P4.
То есть мы пишем букву B.
Значит, тогда смотрите,
из этого будет следовать,
что U3 это пустое слово,
а V,
так, стоп,
а V это какое-то слово V3B.
То есть потому что мы вот здесь написали букву B в конец.
Меня кто-то еще слушает?
Вот, а тогда смотрите, в чем фишка.
Значит, дальше мы говорим,
смотрите, по предположению индукции,
вот здесь тонкий момент,
заключается в том, что мы можем написать.
Что для пары
Q1,
P1,
Q2,
P1,
Q3,
мы можем вывести пару Q3, P2, E3.
Почему это так?
Собственно, нам нужно считать со входа слово U
и на выход написать слово B3.
В таком случае,
во втором кейсе у нас получается следующее,
что U3 это эпсилон,
поэтому мы со входа считываем U,
а здесь у нас получается со входа эпсилон пишем V3.
Все.
Ну и дополнительно мы с вами понимаем тогда, что здесь,
поскольку у нас с вами уже из U3 нечего считывать,
то мы можем сделать переход за один шаг,
U2,
Q2,
эпсилон, V3B.
Это наш слов Эпс.
Все, доказали.
И как мы правильно подметили, нам не нужен дификат.
Сейчас, погоди, петли.
Петли?
Мы по факту добавили петли поверх состояния нашего автомата.
То есть мы можем мысленно считать,
что у нас вот в этом автомате с одномоквынными переходами
мысленно появляется эпсилон пятер вокруг себя.
Да, я не имею в виду, что если у нас был автомат 1,
а это 2,
у него правило 2,
там был эпсилон V,
у него V2, у него V3,
то в каком мы петли добавили бытового автомата?
В смысле, еще раз?
Если была петля?
Если был переход в первом автомате...
В первом, это V или U3?
Короче, из Q2 в Q3, по U2,
из Q2, Q3,
а, ну да, у нас U3 в Q4,
то мы бытового автомата в Q3 добавили.
Мы сделали парадельный перенос,
из Q3 в Q4 сделали переход,
а вот в этом автомате мы не поменяли свой способ.
А, сейчас, мы добавили...
Чего?
У нас нет обухов, получается?
Чего-чего?
У нас нет обухов в втором автомате.
Ну да,
ну нет, мы не делали, смотрите,
суть в том, что если у нас конечное преобразование
со входа считывается эпсилон,
то в втором автомате мы должны остаться на том же месте.
То есть ничего не делать.
Да.
Ну это именно рептология.
То есть мы во втором автомате добавили эпсилон,
после этого сделали его опять обухов.
Не-не-не, смотрите, вот.
Вот тут написано, как это делается.
То есть мы говорим, что если у нас есть
в нашем автомате старом,
в преобразователе то, что мы считываем
со входа на эпсилон, пишем V на выход.
Да.
Да?
То здесь мы делаем следующее.
Собственно, мы не меняем состояние
в нашем НК,
но меняем состояние в нашем преобразователе.
Вот тогда картинка.
Ну да, по старту ничего не читают.
Сейчас, а можно сказать,
можно сделать так?
Можно для всех?
Нет, нельзя.
Нельзя, наверное.
Ну да.
Я не понимаю, мы просто добавляем
во все вершины абсолютный эпсилон?
Ну да, только во все вершины.
То есть если у нас есть переход
в одной вещи из эпсилона V,
то во все остальные встанут,
мы добавляем такие же.
Так, ну что?
Двигаем дальше.
Ох, тут дальше факты.
Собственно, смотрите, давайте тогда
я сейчас поступлю следующим образом.
Значит, пока что мы вот этот факт
оставим на следующий раз.
Вот, мы к нему поверим.
Значит, это один из самых фундаментальных фактов,
который есть.
То, что конечная преобразовательность
относительно композиции.
То есть если у нас с вами есть два
конечных преобразования, то их композиция
тоже является конечным преобразованием.
Давайте этот факт мы будем доказывать в следующий раз,
потому что здесь очень много
муторных выкладок.
Чтобы вы понимали, как это работает,
знакомый с конструкцией Pipe
перед направлением вывода.
Вот.
Из одного потока в другое.
Вот, попробуйте ее реализовать на автоматах.
То есть вам нужно, грубо говоря,
все, что у вас выходит в стедаут
первого преобразователя,
сразу съедать на входе второго преобразователя.
Вот.
Там опять же будет декартовое произведение преобразователей.
Просто аккуратный разбор трех случаев.
Вот.
Что мы с вами будем делать?
Доказательство ровда похожее на то, что есть.
И давайте мы его просто оставим в следующий раз.
Просто видите, сколько тут перелистываний слайдов.
А вот так строится композиция, допустим.
Двух преобразователей.
Значит, давайте мы сейчас с вами
докажем следующий факт.
Значит, смотрите, есть такое утверждение.
Мы с вами будем использовать такой факт,
как неудлиняющий гомоморфизм.
То есть это гомоморфизм, который не удлиняет длину слова.
Вот.
Значит, вот такой вот интересный факт.
И смотрите.
Собственно, для любого неудлиняющего гомоморфизма
можно сказать, что если у нас есть какая-то буква,
то образ этой буквы не более чем один.
То есть у нас либо образ этой буквы
это другая буква из выходного фавита,
либо образ этой буквы это пустое слово.
И вот теперь еще одна вот такая важная теорема,
которую мы вам доказываем,
доказывать на синем мы сейчас ее быстренько докажем,
называется теорем Нева.
Значит, именно Нева. Почему?
Потому что это французская фамилия.
Вот.
Значит, и она формулирует следующим образом,
что любое конечное преобразование
можно представить в виде композиции трех отдельных вещей.
Значит, первое, это обратный неудлиняющий гомоморфизм.
Второе, это ограничение на регулярный язык.
И третье, это еще один неудлиняющий гомоморфизм.
То есть суть состоит в том,
что вы представляете любое конечное преобразование
в виде трех простых преобразований, композиции.
Каждый из них является само по себе конечным преобразованием.
Если мы верим в теорему,
что конечное преобразование
закрыто относительно композиции,
то получается композиция этих трех преобразований
это конечное преобразование.
давайте напишу таким образом psi можно представить как композиция значит phi в
минус 1 и это это не удлиняющий гаммарфизм
это регулярный язык
вот давайте доказываем эти факты на самом деле доказательства очень красивая
без индукции кстати
нет картинка значит смотрите я не знаю знакомы ли вы с таким понятием как
разложение матрицы собственно это аналог
сингулярного разложения напоминает что такое сингулярRa
разложения эта композиция арт наши то преобразование поворота
жатия или растяжение собственно это ограничение tappedии biliyor другого
приобразование и идиот LISA момент что мы понимаем с вами что PLAYING
Обратное к нему тоже ортогональное.
Но вот здесь приходится усложнять это.
То есть это не удлиняющая обратный гаморфизм.
А идея очень простая.
Давайте рассмотрим конечный преобразователь произвольный.
И мы понимаем с вами,
что у нас существует конечный преобразователь
с однобуквенными переходами.
Логично?
Ну вот тот самый, который мы с вами доказывали.
А теперь давайте мы сделаем следующую вещь.
Мы с вами построим два...
Значит, построим следующую вещь.
Значит...
Смотрите, тут важно.
Видите?
Как вы думаете, здесь опечатка или нет?
Нет, нет.
Что тут дельта написано?
Что промежуточный алфавит это дельта.
Вас ничего не смущает?
Не, однобуквенная это значит сумма переходов один тут.
В этом термине обозначает.
Пока что, пока что да.
А теперь смотрите.
Теперь давайте картинку нарисую.
Значит, смотрите.
Первое.
Пси.
Преобразование Фи.
Оно, значит...
Если у нас с вами есть какой-то переход.
Должны делать следующее.
Оно берет и преобразовывает ее в У.
А это...
Делает В.
А теперь смотрите.
Мы будем строить конечный преобразователь.
У которого алфавит это множество переходов
в нашем исходном конечном преобразователе.
То есть это принадлежит дельта.
И это принадлежит дельта.
Это получается у нас с вами
переход из одной буквы
в не более чем одну букву.
Это взрыв в башке.
Давайте картинку, наверное.
Смотрите.
Пример.
Собственно.
Давайте назначим алфавит ребер,
который у нас имеется.
То есть во всем нашем, конечно,
преобразователь, который у нас имеется,
мы назначим ребра.
Обозначим их вот таким вот образом.
Теперь смотрите, что мы с вами сделаем.
Мы с вами вот это вот регулярное выражение,
которое вот здесь вот есть,
мы скажем, что это множество путей
от нашего стартового состояния
до нашего завершающего состояния.
Мы их можем задать регулярным выражением.
Потому что по факту, что у нас такое,
у нас с вами здесь будет написан
регулярный автомат.
На ребре которого каждого написана
просто буква одного алфавита.
Одна буква этого алфавита дельта.
Да, да, да. Мы это сожмем как регулярное выражение.
Смотрите, у нас здесь что делается.
Мы по факту, вот мы видим с вами
переход.
Значит, какой-нибудь
из эпсилон В.
В нашем, конечно, преобразователе.
Q1, Q2.
Значит, при помощи
неудлиняющего гомоморфизма
обратного
мы это сделаем следующее.
Мы из В
сделаем Q1,
эпсилон В,
Q2.
Перегоним его обратным
гомоморфизму.
Понятно.
То есть,
по факту у нас
фи будет делать вот такую вот.
Фи в минус 1.
А вот этот элемент нашего дельта.
Потом
мы его сократим,
а это
сделает следующее. Она возьмет
вот этот переход, который у нас есть,
и обратно перегонит
выход.
Нам надо вход же перегонять.
То есть у нас вход перегоняется
вот в такую вещь.
Потом при помощи
неудлиняющего гомоморфизма здесь мы перегоняем этот вход.
То есть получается
то, что написано на входе, мы
кодируем ID-шником
нашего перехода.
Потом сокращаем это все
на регулярное выражение, и потом этот ID-шник
обратно переводим
уже в то,
что написано на выходе этого ребра.
Так, давайте вопроса.
Перенумеруем все переходы в нашем автомате.
Говорим, что вот этот переход
это переход номер 5.
Значит, тогда у нас
наш обратный гомоморфизм
будет говорить следующее, что
из эпсилона мы будем
ставить пятерку.
То есть прямой гомоморфизм вот здесь
он будет говорить, вот phi будет писать, что
пятерка
у нас трансформируется в эпсилон.
Пятый переход в нашем автомате.
В нашем конечном преобразователе.
Слова.
Слова. Но смотрите, мы делаем следующее.
Мы говорим, что у нас будет новый язык.
То есть мы переходим.
Нам же здесь не говорят
какие языки.
Ну, типа того.
То есть смотрите,
у нас будет
следующее преобразование. Давайте я напишу
чуть формальнее.
Phi у нас будет
действовать из дельта
в сигма со звездой.
Psi
будет действовать из дельты
в гамма со звездой.
То есть мы
даем этому путь, а он нам дает,
что после этого пути мы
ну да, что
на входе получаем.
Тогда мы берем произвольный вход.
Ну да.
Да, из дельты со звездой.
Правильно.
То есть мы даем ему путь в автомате.
И Phi по пути в автомате выдает
то, что мы прочитали на входе.
А вот это
по входу,
по тому, что мы
какой путь прошли,
мы даем выход.
Да, это есть доказательство.
А смотрите.
Потому что для каждого перехода
мы берем элемент из дельты.
Вот это элемент
из нашего множества
состояний,
то есть длина вот этой штуки
в алфавите
равняется единице?
Да.
То есть длина вот этой штуки
в алфавите
равняется единице?
Одно ребро записано одной буквой, да.
А это уже образ.
Тут либо 0 буква,
либо 1 буква.
То есть получается, да, мы читаем всегда одну букву,
а на выходе всегда пишем либо 0, либо 1 буква.
Вот.
А ограничение на регулярный язык
это как раз множество всех путей
в нашем автомате. Это регулярный автомат.
А по регулярному автомату
мы умеем строить регулярное выражение.
Знаете, как выход
вот за четвертую стенку
в фильмах обычно есть?
Вот оно и произошло.
Так, давайте вопрос.
Да.
Да, да, да.
Допустим,
у нас могло случиться так,
что типа у нас есть слово
а, б,
мы его прочитали
в совходе, получили выход.
И оказывается, что фи в минус 1 от а
это, допустим, вот такой переход.
А фи в минус 1 от б
это другой переход. То есть, грубо говоря,
здесь мы читали слово а,
а здесь мы читали слово б.
Да, и вот эти вот переходы у нас
никаким образом не связаны.
Да, да, да.
Если у нас тут заданное несоответствие,
это отображение.
Ну, да, фи,
гомоморфизм это отображение, если что.
Так.
Да, мы каждый бок смотрим,
какие ребра соответствуют.
Да, путей, да.
А пути мы можем задать регулярным выражением
все.
Каждый путь от стартового выражения,
от стартового станет завершающим, мы можем задать каким-то путем.
Подождите.
Ну, а если у нас есть
текстовый футбол?
Ну, а это звездочка,
это рация к линии в регулярных поражениях.
Мы пишем с вами, смотрите.
Р это регулярный язык
над дельта со звездой.
Над дельтой.
То есть, по Р
нам надо поставить...
Мы строим регулярный автомат.
А если у нас есть регулярный автомат,
то мы можем построить из него
Р регулярного выражения.
Да.
И уже исходя из этого регулярного выражения
мы строим ФИ, да?
А?
Ну да, мы же имеем на входе конкретный автомат.
Вот, допустим.
То есть, по факту,
что делает ФИ?
ФИ минус первое говорит
по входной букве, какие переходы
она могла поратить, а это говорит,
из каких переходов мы можем получить букву В.
Такой коннектор получается.
А ФИ не зависит от вершины?
Нет, не зависит.
От перехода только зависит.
Переход?
Да, переход.
То есть, цель следующая.
Взять, значит, входное слово.
Написать, грубо говоря,
по всем этим буквам,
какие переходы у нас есть.
Потом сказать оба,
какие реально пути подходят.
Это как раз ограничение на наш регулярный автомат
регулярное выражение
из регулярного автомата.
Мы ФИ строили по автомату.
Да, во-первых,
ФИ учитывали ограничение...
Мы построили ФИ,
учитывая уже ограничение нашего автомата.
Да-да-да.
Зачем нам еще раз потом ограничивать?
Нет-нет-нет, чтобы точно все совпало.
А как это может не совпало?
Легко.
Смотрите. Вот даже пример.
Смотрите.
Вот смотрите.
Пример.
Вот это пусть х,
вот это у, вот это z.
Обозначаем.
Что такое фирма МС1?
От АБ.
Сейчас, давай так.
И...
Давайте так.
ФИ от х это...
Это ексимум.
ФИ от х это А, да?
Да, фи от х это А.
ФИ от х это В.
ФИ от z это В.
То есть фиг МС1 от АВ
это утверждение, что это либо
х-секрет, либо х-з.
Но х-з нам не подходят.
Почему? Потому что то регулярное выражение,
которое у нас получится,
это, смотрите, ху
плюс ху-з.
Но можно говорить, чтобы у нас
фи и это у нас давали только
однобухленное? Ну, чтобы не только
однобухленное подавали, чтобы у нас
у вас не кресло было?
Нет. Нет, не можем.
Вот, смотрите, то есть у нас фиг МС1
от АВ это ху и х, да?
Хз нам не подходят.
Потому что регулярное выражение,
которое мы пишем все возможные пути,
это х и х-секрет.
А можете добавить еще Эпсилон А
с первой вершины?
Эпсилона Эпсилона у нас нету.
Тогда у нас фи от А.
Вот это Т будет.
Вот это фи от Т.
Сейчас.
Ну, тогда регулярное выражение у нас
будет Т со звездой.
Вот так вот.
Ну, при этом фи от А,
фи от Т изменяется? Нет, нет, нет.
А фи от Эпсилона тоже?
А? Фи от Т это Эпсилон.
Так, давайте, ладно, напишем
короче, чтобы было понятно.
Фи от Т это Эпсилон.
Значит, смотрите.
Фи от Т это Эпсилон.
Фи от Х это А.
А, вот, все, я понял.
Фи минус 1.
Вот это будет, типа,
Т звездочка А, да?
Ну, да, фи минус 1 от А
это на самом деле даже
больше.
Сейчас, вы просто понимали.
Да.
Да.
Так.
Фи минус 1 от Б.
Нет, это тоже Т звездочка
А.
Почему? У нас нет пути,
который пройдет
по Эпсилону, потом...
Э, нет, смотрите, у нас фи...
Смотрите.
Формально у нас фи
дает, значит, берет на вход
любой переход и строит выход по нему.
Ну, берет переход
и пишет, что на нем на выходе.
Ну, то есть, в нашем случае
фи минус 1 от А это на самом деле
Т вк Т Х.
Т вк Т, да.
Т вк Т.
Да, да, да.
То есть ему, короче,
ему дали просто набор ребер,
Безы, бешенки.
Да.
Да, да, да.
А потом нам нужно как раз применить ограничение
на регулярный язык, на все возможные пути.
Да, это регулярный R.
А потом уже пишем выход.
А?
Да, да.
Да.
Применению этой теории мы хорошие.
Первый факт, который мы с вами думаем,
доказывает, что образ регулярного выражения
при применении конечного преобразования
это регулярный язык.
То есть эта штука позволяет доказывать
замкнутость.
Образ... Смотрите.
То есть если у нас есть
L регулярный,
Пси это конечное преобразование,
то Пси от L тоже будет
регулярным.
Это раз.
Второе.
L КС,
Пси конечное преобразование,
Пси от L тоже будет
КС.
Там еще есть какие-то другие
утверждения, которые чуть более сложные.
Они связаны с тем, как связаны язык
правильно-оскобочных последовательностей
и конечное преобразование.
В этом контексте свободного языка.
В этом контексте свободного языка.
Если грубо говоря,
все то, что
на самом деле мы можем с вами получить
в мире КС языков,
это не что иное, как некоторые вариации
относительно правильно-оскобочных последовательностей.
То есть
ничего более крутого
получить нельзя.
