Здравствуйте! Начинаем. Так, ну что, у нас остается две лекции с учетом этой. Значит, сегодня мы
договорим про потоки. Вот, на оставшейся лекции поговорим что-нибудь про деревья. Вот. Значит,
по всяким зачетам-экзаменам. Так, сейчас я попытаюсь вспомнить. Значит, у того,
что я называю PMI и зачета-экзамен, значит, зачет, как обычно, просто по задачам семестра. Экзамен,
так же, как был в первом семестре. Ну, приходите, пишите теории вопроса и потом задачи на до балла.
Значит, дальше. У PMF, который, видимо, КТФ и PMI, только зачет, и чтобы как-то проконтролировать
теоретический материал, будет контрольная, видимо, на одном из последних семинаров. Там
будет 20 вопросов в стиле, там, сформулируйте теорему Форда Фалкерсона или дайте определение,
что у нас там было, ну, не знаю, клики, например, ну, что-нибудь такое. Определение, формулировки,
и, возможно, самые-самые простые доказательства, где там, ну, они буквально однострочные. Такие
доказательства тоже могут быть. Вот программу я, видимо, сегодня-завтра тоже постараюсь скинуть.
Это будет на, значит, 20 вопросов, на плюс 20 баллов. Вот. И, соответственно, пороговые значения тоже
я, пороговые значения за зачет я тоже на днях выставлю. В табличке будет отдельно по PMI,
отдельно по КТ. Вот. А ФУПУМ, который PM, у нас вроде бы только экзамен, поэтому работа в семестре
будет учитываться на экзамене и плюс на экзамене, ну, в общем, какой-то похожий формат. Там будет
теор-вопрос, но это еще подробнее. Это, в общем, скорее семинарист вам объявит, как это будет. Мы
еще не до конца продумали. Ну, в общем, какой-то такой план. То есть зачет нет, только экзамен,
и там, ну, вот учитывается работа в семестре плюс ответ на экзамен. Вот. Так, есть ли вопросы по
оргинформации какой-нибудь? Ну, а пока там приблизительно, да, стоит. Я говорю, как бы они
пока не окончательные. В том семестре у нас было, ну, то есть там сначала стоит приблизительно,
просто линейная, а потом я немножко ее подфиксирую. Ну, то есть конкретный будет порог на U3,
на U4, на U5 и так далее, на U10. Но они будут не сильно отличаться от того, что сейчас стоит. Ну,
наверное. Ваша цель это не оценку получить, а задачу научиться решать. Поэтому я оставляю
за собой право немножко их фиксировать. Так, еще вопросы? Хорошо. Значит, тогда у нас на сегодня
две задачи. Первая это минимальный глобальный разрез. Ну, разрез мы должны помнить, что такое,
если у нас есть сеть, и сток, и сток, и нам нужно, значит, как-то их разрезать, то есть разбить все
множество на две доли, S большое, T большое. Так что с маленькой в S большом, T маленькая в T
большом. И в объединении эти два множества дают все множество вершин. Значит, это разрез между
двумя вершинами, а глобальный разрез — это когда S маленькая и T маленькая у вас не фиксированы.
Значит, пусть G и C — это сеть, то есть граф с функцией вот этой вот capacity без выделенных и
стока, и стока. Значит, тогда пара S, T называется разрезом, если это два непустых множества,
которые в дизюнктном объединении дают все множество вершин графа. Если S и T не пустые,
при этом их дизюнктное объединение равно множеству вершин всего графа. То есть каждая вершина
отнесена к одной из двух долей. Ну, величина такого разреза — это сумма всех ребер пересекающих
разрез, в смысле сумма capacity всех ребер пересекающих разрез. Ну, давайте это напишем. Это у нас уже
было. C, S, T — это сумма по всем U из S, V из T, C, U, V, где C — вот эта самая функция пропускных способностей.
Вот. Ну, мы в дальнейшем... Давайте я также напишу. То есть это я для разреза определил C. Я могу
определить также C для любых двух множеств. Если A и B произвольные под множество V,
то мы можем точно также определить C от A, B как сумму U из A, V из B, C, U, V. То есть C — это
как бы не только величина разреза, но и для произвольных нож. Там не обязательно все вершины,
не обязательно. Там они оба не пустые. Вот просто любую пару можем такое определить. Ну,
значит, смотрите. Тут возникает две таких задачи естественных. Это поиск минимального глобального
разреза. Ну, вот здесь я написал просто разрез. Можно написать, что глобальный, подчеркнуть,
как бы, что он называется глобальным разрезом. Подчеркнуть, что на него нет условий, что там S в
S большом, а T в T большом. Так вот, значит, появляется задача поиска минимального глобального
разреза и максимального глобального разреза. Вот с первой задачей мы сегодня справимся,
а вторая довольно сложная. Не просто довольно сложная, а НП трудная. То есть, если, например,
стоит задача данный граф, нужно разбить все его множество вершин на две доли так, чтобы суммарно
из первой доли во вторую сумма весов ребер была максимально возможна. Это задача НП трудная. Для
нас, как бы, неважно пока, что это значит. Тут нужно много времени потратить, чтобы определить,
что такое НП трудность. Но для нас это словосочетание значит, что эту задачу мы пока не умеем решать
за поляном. Так же, как у нас было, мы уже несколько раз встречались с этим словом, когда мы искали
максимально независимое множество или там, что мы еще искали, минимальное вершинное покрытие,
не в вдовдольном графе, а в произвольном. Все такие задачи, они НП трудные, и пока никто не умеет
их решать за поляном. Напоминаю, зачем нам это знание. Затем, что если вы вдруг какую-то задачу
свели к поиску, скажем, максимального глобального разреза, то это сведение не очень полезное.
Если у вас был исходной граф на тысячи вершин, и вы свели исходную задачу к поиске максимального
глобального разреза на этой же самой тысячи вершин, ну вот тогда дальше непонятно, что делать,
потому что пока что никто не умеет быстро это решать. То есть, там есть какие-то приближенные алгоритмы,
которые с какой-то точностью дают разрез. То есть, там не хуже, чем в два раза отличается. Ну,
не больше, чем в два раза отличается от максимального, например. Но точное решение пока никто искать не умеет.
Вот. Но давайте я напишу какой-то пул НП трудных задач, которые у нас уже есть, то есть, которые,
как бы, я бы сказал так, как бы на текущем уровне понимания можно даже не пытаться решать. То есть,
на третьем курсе у некоторых из вас будет курс сложности учисления, где вот все вот эти задачи
будут как бы друг к другу там сведены в каком-то смысле, и показано, что все они одинаковой трудности,
и решить одно из них значит решить все вообще. Поэтому они как бы не просто все сложены сами по себе,
но и совокупности тоже. То есть, если вы хотя бы одно решите, то сразу решите все. То есть,
не одинаковой трудности между собой, и решить одну значит решить все. А пока никто не умеет это делать.
Итак, значит, это максимально независимое множество. Ну, в произвольном графе, конечно,
потому что в долудольном мы уже умеем искать. Там кунти, аримакеннига и так далее. Значит,
двойственное к нему это минимальное вершинное покрытие. Тоже похожа характеристика,
это максимальная клика. Напомню, что мы умели искать максимальную клику вот за такое время.
Два всегда не n пополам, но это экспоненты от размеров хода. Вот, а какой-нибудь там полином,
типа n в кубе, пока никто делать не умеет. Дальше, максимальный разрез. Можно же добавить поиск
гаметного цикла. То есть, проверка того, существует он, ну и скажем, если существует, то вывести его.
Давайте я так напишу поиск гаметного цикла. Поиск гаметного цикла или гаметного пути. Это одно
и то же в плане сложности. Они обе NP трудные. Про гаметного цикла мы тоже что-то говорили,
когда про DP начинали говорить. То есть там можно опять-таки за экспоненту решать, типа за два в
степени n умножить на n. Но за какой-то полином пока никто не умеет. Ну и последнее добавлю еще
хроматическое число. Графа. Хроматическое число. Хроматическое число. Это вот у вас есть граф.
Есть какие-то ребра в нем. И вам нужно покрасить все вершины в какие-то цвета, в минимальное число
цветов, так чтобы вершины, соединенные ребрами, были разных цветов. То есть, если вот между двумя
вершинками есть ребро, то цвета, которые на них написаны, различны. С1 не равно С2. И так по всем
ребрам. Соответственно, какое минимальное число цветов вам нужно, чтобы иметь какую-то
корректную раскраску. Это тоже NP трудная задача. Вот такой обзор. Ну, конечно, есть NP трудные
задачи не только на графах. Я, кажется, еще формулировал, когда задача 3 SAT тоже NP трудная.
Значит, мы решали два SAT с помощью ориентированных графов каких-то и поиском компонент сильно
связанности. Но вот если вы разрешите в каждой скобке содержать три литералы, то это уже тоже
станет NP трудная задача. Пока как решать неизвестно. Вот. Ну, еще их много-много других, но вот такие,
которые у нас в курсе, по крайней мере, были рядышком. Так. Ну, значит, давайте отложим этот
максимальный глобальный разрез. Мы его поняли, что искать не умеем и не будем этого делать. Будем
искать минимальный глобальный разрез. Значит, давайте я для удобства буду считать, что наш граф не
ориентированный уже, не ориентированный. Это значит, что если вы какие-то две вершинки,
разнесли в разные доли. Скажем uws, avvt, то обязательно вес этого ребра,
ну, капасти этого ребра обязательно учтется в разрезе. То есть как бы вы эти uw не разносили,
в смысле, если он не в разных долях, то обязательно вес этого ребра учтется в разрезе. Тут нет
если проходит разрез, то оно обязательно учитывается.
Так, ну конечно, у нас есть уже какой-то способ, как можно найти минимальный глобальный разрез.
Вопрос к вам, к помощи какого алгоритма можно найти из уже известных,
можно найти минимальный разрез?
А если это кто?
Ну конечно, да, можно просто перевернуть все пары вершин s маленькая, t маленькая,
найти максимальный поток между s и t и взять минимум по всем возможным таким парам s и t.
Давайте напишем, ans равно бесконечность, цикл s от единицы до n, цикл t от, скажем, s плюс одного до n,
ans равно минимум из ans, plow между s и t.
Ну то есть мы знаем, что в оптимальном разрезе s, t точно есть хотя бы кто-то здесь, хотя бы кто-то здесь.
Давайте какие-нибудь вершины здесь фиксируем, s маленькая, t маленькая.
Тогда, в частности, вес, величина этого разреза будет равна величине потока между s и t.
Потому что мы знаем, что минимальный разрез равен максимальному потоку.
А раз это вообще минимальный разрез во всей сети, то он подавно меньше либо равен, чем вес минимального разреза между s маленькая и t маленькая.
Значит, если мы все такие пары переберем, то у нас точно получится вообще минимально возможный разрез.
Значит, соответственно, здесь время работы будет n квадрат на время работы какого-нибудь алгоритма поиска максимального потока.
Вот, но можно еще немножко это даже оптимизировать.
Можно не делать два вложенных цикла, можно, скажем, зафиксировать s равно единичке и перебирать только t.
Давайте напишем альтернативную версию, тоже работающую.
Значит ans это бесконечность, а s это единица, а дальше цикл только по t.
У двойки до n. И в цикле мы делаем то же самое ans равно минимум из ans low st.
Ну, потому что поскольку граф не ориентированный, мы понимаем, что не умоляя общности, можно считать, что вершина номер один лежит здесь.
Вершина номер один лежит здесь, потому что иначе можно переставить s и t, от этого вес разреза не изменится.
Значит, единичка здесь, ну и тогда надо просто перебирать, кто лежит здесь.
То есть хотя бы одна вершина должна сюда попасть, мы ее перебираем, и тогда величина этого потока равна в точности величине разреза минимального.
Согласны?
Значит, получили, что время работы это n на время работы потока.
Я напишу так time от flow.
Ну, если, например, поток мы ищем алгоритмом диница, который работает за v квадрат e, то это будет, ну я напишу так, v куб e.
Ну, n это v, число вершин.
Поток мы с помощью алгоритма диница находим за v квадрат e.
Вот такая ужасная симптотика поиска минимального глобального разреза.
Так, ну и сейчас мы будем делать другой алгоритм, который позволяет нам сделать то же самое за лучшую симптотику.
Это так называемый алгоритм Штор-Вагнера.
Два автора.
Штор-женщина-вагнер-мужчина.
Поэтому так сперегаются фамилии.
Значит, алгоритм следующий.
два автора тор женщина вагнер мужчина поэтому так сперегаются фамилии значит
алгоритм следующий сейчас будет его описание алгоритм будет рекурсивный и
делает он следующее значит сначала говорит что а 1 это единичка а аито это множество
вершин с а 1 по аито в частности а большое первое это вершина только одна вершина номер один
дальше на и плюс первом шаге мы находим такую вершину то есть у нас есть весь граф у нас
фиксировано там какие-то вершины с первой поитой и на следующем шаге мы находим такую вершину
которая максимально связана вот с этим предыдущим множеством максимально в смысле
цэ в смысле capacity значит формально это арк максимум по всем вершинам вы не лежащим в аито
величина вот такого вот разреза в кавычках между вы и аито то есть есть у вас уже найденное
множество а большое это вы перебираете все остальные вершины которые в нем не лежать вы
складываете сумму весов всех этих ребер и находите такое вы где где здесь достигается максимум
значит ну тогда соответственно а и плюс первая это аито в объединении с это новой вершинкой а и
плюс первой вот так делайте получается n минус один раз находите а второе а третья и так далее
вот в конце у вас есть какой-то порядок вершин так что каждая это как бы наиболее
связанная со всеми остальными так вот тогда алгоритм утверждает следующее давайте утверждение
что ну да минимальный разрез между а n минус 1 и а n то есть рассматриваем две вершины которые
мы на двух последних шагах находим оказывается что минимальный разрез между ними равен
по величине вот этому вот разрезу
смотрите мы в каком-то странном порядке номируем вершины и оказывается что две последние вершины
когда мы их вот занумеровали две последние добавлены в наш массив вершины оказывается что если
мы будем пытаться находить максимальный поток между ними то есть минимальный разрез между
ними да то есть скажем из а n в а n минус 1 будем пускать максимальный поток это то же
самое что искать минимальный разрез и вот оказывается что среди всех таких разрезов которые
разносят а n минус 1 и а n в разные стороны оказывается что минимальным является вот такой то
есть когда у вас просто отдельная а n а все остальные во второй долю
так но если это верно то смотрите получается что за один вот такой прогон мы смогли найти
минимальный разрез между какой-то парой вершин это утверждение мы чуть-чуть позже докажем но
смотрите за один прогон мы смогли найти минкат между кем-то двумя вершинами а дальше замечание
следующее что если это не минкат если это не ответ то значит в минимальном разрезе эти две
вершины не по разные стороны разреза то есть они должны лежать либо оба либо обе в с либо обе в
т потому что не по разное то минимально возможный разрез вот он тут написан значит если это не
ответ то можно считать что в ответе эти две вершины в одной доле их можно склеить
вот ну значит дальше мы их склеиваем и запускаем наш алгоритм рекурсивно уже на
графе зену с одной вершины и так делаем пока в графе не останется одна или две вершины значит
две опции да либо c а n а n минус 1 это глобальный минкат глобальный минимальный разрез либо
в глобально минимальном разрезе глобально минимальном разрезе а n минус 1 и а n лежат в
одном множестве следовательно их можно склеить ну склейка происходит очень просто есть две
вершинки у вас а n минус 1 и а n и есть все ребра которые в них входят но тогда вот считайте что
вот это вот это одна такая толстая вершина а ребра которые в них в них ходили но тоже надо
склеить то есть например вот эти вот два ребра которые из одной тоже вершины исходили нужно
превратить в ребро с весом равным сумме весов вот этих вот двух величин вот это плюс вот это
не знаю напишу здесь там x y а тогда в частности будет вот такое ребро веса x плюс y соответственно
надо будет сложить вот эти вот две величины тоже ну добавить там такое ребро а эти просто
ребра добавить без складывая ну короче в общем ребра из одной вершины которые ввели в а n минус
1 и в а н надо просто склеить и сложить к опассите тех ребер которые там были написаны вот ну а
дальше значит рекурсивный запуск рекурсивный запуск на графе с n минус одной вершины
пока не дойдем до графа с двумя вершинами если в графе две вершины то понятно как выглядит
это просто сумма весов ну как бы просто вес ребра на самом деле между тем двумя вершинами
вот такой алгоритм значит за сколько он работает ну здесь понятно что нужно делать вот этот прогон
n раз да какая-то какая-то какая-то номерации вершин дальше склейка двух последних и опять входим
входим в цикл опять перенумеровываем вершины нужно просто это сколько реализуется вот это
можно сделать за квадрат вот этот прогон можно сделать за н квадрат потому что ну здесь что-то
очень похоже на алгоритм ну допустим prima потому что смотрите вы как бы по очереди так откусывайте
вершинки а дальше для всех остальных которые вы еще не не откусили вы рассматривайте там какую-то
величину берете из них максимально и и перетягивайте в множество а и плюс первая это очень похоже на
алгоритм прима, что у вас есть уже какое-то остовное дерево, дальше всех остальных недобавленных
востов вы выбираете вершину, ну там, какое-то минимальное ребро, и его добавляете востов,
и дальше пересчитываете вот эти вот, вот эти штуки. Ну то же самое надо сделать здесь. Давайте
просто для каждой вершины, не лежащей в аитом, будем поддерживать вот эту вот текущую величину,
суммой весов и ребер между v и всем аитом, находить там максимум, перетаскивать вершину в а и плюс
первая, ну и дальше тогда эта величина просто пересчитывается. Если вы v перенесли в а и плюс
первая, то как меняется вот эта величина для всех остальных вершин? Надо просто пройтись по
ребрам исходящим из v и прибавить сюда вес вот этих вот, ну как бы сюда прибавить вес этого
ребра, сюда вес этого, сюда вес этого. На этом сам мы будем знать вот это значение всех вершин,
максимум находим за линию, просто пройдясь по всем вершинам, ну и потом пересчет делается за
число ребер на самом деле. Тут можно было написать, а ну да, ну да, n квадрат, потому что суммарный
ребер у меня e, не больше чем n квадрат, и мне нужно n раз находить максимум, это еще n квадрат.
Согласны? Вот, ну и итоговая симптотика будет n куб, потому что мы n раз так делаем. Симптотика
вот в кубе. Значит, все, что нам осталось сделать, это доказать вот это утверждение, что при такой
странной нумерации минимальный разрез между двумя последними, это тривиальный разрез, где а n в
отдельной доле лежит. Чтобы доказать утверждение, давайте скажем следующее. Пусть st какой-то разрез,
какой-то разрез. Наша задача показать не совсем какой-то, сейчас одну секунду,
какой-то разрез между а n и а n-1, то есть такой, что а n скажем в s, а n-1 в t. Наш стать показать,
что вес этого разреза не меньше, чем вес вот того разреза, accumufacturing published algorithm,
SHIP, который мы находим в нашем алгоритме. Цель показать, что вес этого разреза больше
либо равен. Вес вот того оптимального разреза, который мы утверждаем, что является
минимальным между ними. Если мы это докажем, получается, что любой разрез больше либо равен
чем вот этот, значит, это минимальный. Итак, вот будем доказывать такое утверждение для произвольного
разреза СТ. Значит, говорим, что вершина АИ является активной, если она и предыдущая,
а и минус первая, лежат в разных долях СТ. Я напишу так, если АИ лежит в С, а АИ минус
первая лежит в Т, или АИТ лежит в Т, а АИ минус первая лежит в С. В общем, активная вершина
это та, которая была добавлена в другую долю по сравнению с предыдущей вершиной.
Вот, и давайте докажем для активных вершин следующее утверждение. Если АИ активная, то
разрез между АИ и АИ минус первая меньше либо равен, чем сужение вот этого разреза на множество
АИТ, то есть С пересечь с АИТ, Т пересечь с АИТ. Давайте докажем такое утверждение для каждой
активной вершины. Доказательства. Индукция по активным вершинам.
По активным вершинам. База, когда у нас появляется первая активная вершина, что такое первая активная
в этом нашем порядке 1 на 2 и так далее? Первая активная, это такая, что все до нее лежали в С
большом, а она первая попала в Т большое. Ну или наоборот, она первая в С, а все остальные в Т
большом. База. Пусть АЖ это первая активная, первая активная, ну тогда картинка какая-то такая,
например. Вот здесь вот лежали все товарищи с первого, позже минус первая, скажем, это было С
пересечь с АЖТ, а АЖТ единственная, которая попала в Т большое. Ну здесь понятно, что там, может быть
здесь наоборот ТС, из-за неориентированности мне неважно, кто из них кто. С и Т можно всегда
свопнуть при необходимости. Вот, ну и тогда понятно, что на самом деле то, что написано вот в
утверждении, это одно и то же просто. Так, АЖТ, АЖ минус первая, в точности равно просто на величине
вот этого разреза. Потому что вот здесь это просто сумма весов вот этих вот ребер. Но это есть величина
разреза просто. База очевидна, база даже, в базе у нас даже просто равенство, а не не равенство.
Даже равенство. База есть. Теперь переход.
Для перехода мы рассматриваем две последовательные активные вершины.
Переход. Пусть АУ и АВ две последовательные активные вершины.
Две последовательные активные вершины. Значит между ними не было активных. Ну тогда картинка какая-то такая.
Вот в какой-то момент АУТ куда-то добавилось. Дальше все последующие до АВТ добавлялись туда же.
Потому что если бы добавились в другое, то это была бы активная вершина. Значит там же, где АУ, лежит АУ плюс один и так далее, АВ минус один.
А вот АВТ уже попадает в противоположную долю. У нас получается вот такое вот разбиение нашего графа.
Если здесь у меня С пересечь с АВ, здесь Т пересечь с АВ, то у меня картинка какая-то такая, что все с УТ по В-1 попали в одну и ту же долю.
Так, ну и тогда давайте писать, что такое величина разреза между АВ и АВ минус один.
Значит это сумма весов.
Ну давайте я напишу так, значит это вот эти вот ребра, да точно. Ну еще соответственно сумма весов всех ребер из АВ вот во все остальные.
То есть я напишу так, это С между АВ и все, что находится вот здесь, это можно написать так. АВ минус один без АУ минус один.
Это получается все вершины, вот эти вот, которые были добавлены между ними, плюс С между АВ и так сейчас, ну да, и АУ минус один.
То есть вот это вот, это вот эти ребра между новодобавленными вершинами, а все остальное, АВ и АУ минус один, это все вот эти вот, все остальные.
Итак, значит теперь мне нужно эти два слога как-то сверху оценить. Значит смотрите, первая идея следующая, вот эта штука не больше, чем САУ АУ минус один по выбору АУ.
Вот это объясняется выбором АУ. Почему? Ну потому что на каждом шаге как мы выбрали АУ? АУ мы выбрали как вершину, не лежащую в АУ минус один, с максимальным значением вот этого разреза.
Максимальное значение было вот это. Но, да, значит АВ я тогда не выбрал и выбрал когда-то позднее. Получается, что АВ оно хуже с точки зрения этой величины, чем АУ.
Потому что АУ максимально. Значит можно написать такое неравенство. Раз мы АВ не выбрали в тот момент, а выбрали АУ, значит есть такое неравенство.
Вот, а эту штуку мы уже умеем оценивать по предположению индукции, что вот эта вот вещь не больше там какой-то там С, по утверждению которой мы доказываем.
Теперь надо разобраться вот с этим. Как это можно оценить?
Ну, смотрите, вес вот этих вот ребер, которые здесь написан, вес этих ребер, это точно нижняя оценка на то, насколько изменился вообще наш разрез по сравнению с состоянием С пересечь с АУ, Т пересечь с АУ.
То есть вот эти вот кружочки, которые я нарисовал, это на самом деле С пересечь с АУ минус один.
Так, Т пересечь с АУ минус один.
Да, ну потому что здесь все номера с У по В, они не лежат в них. То есть смотрите, если я сравню два как бы разреза, если я сравню два разреза, всех напишу.
Вот этот вот, который самый большой, вот эти два множества.
И вот этот, С пересечь с АУ минус один и пересечь с АУ минус один.
Рассмотрю такую разность, то она явно больше равна, чем как раз все вот эти ребра.
То есть больше равна, чем С между АВ и АВ минус один без АУ минус один.
Еще раз, да, что я написал, смотрите.
Первое, вот это вот уменьшаемое, это величина разреза между двумя большими кружочками.
Дальше, вычитаемые, это величина разреза между маленькими кружочками.
Я рассматриваю как отличаются эти два разреза.
То есть какие ребра появляются в разрезе, когда я добавляю вот эти кашины и вот эту.
Ну, понятно, что хотя бы вот эти.
Да и еще какие-то, конечно, появляются, появляются вот эти ребра, вот эти ребра и так далее.
Какие-то, конечно, еще появляются, но как минимум вот эти появляются.
и так далее. Какие-то, конечно, еще появляются, но, как минимум, вот эти появляются.
Значит, эта разность точно больше собрана, чем вот эта. Мы предполагаем, что все
капасти не отрицательны. Ну, значит, вот эту штуку можем оценить через такую разность.
Так, давайте перейдем сюда. Вот, ну все, соответственно, дальше вот это оцениваем
по индукции, там сокращается вот это и вычитаем, и получается то, что нужно.
Значит, так, что мы получили? Мы получили, что вот эта вещь меньше либо равна, чем...
Вот это первое с логами я оцениваю через эту разность.
Второе с логами я оцениваю по вот этому. Просто переписали. Дальше, эта вещь у нас
оценивается по предположению индукции для вершинки ау, поскольку ау предыдущая активная,
для нее верно вот это утверждение, поэтому можем оценить сверху величину этого разреза.
Это не больше, чем с пересечь с аут, ты пересечь с аут. Так, ну и вот,
то есть эти штуки почти одно и то же. Надо сейчас разобраться.
Ну понятно, просто вот эта вещь не отрицательна. Вот эта вот минус вот эта явно не отрицательна,
потому что здесь мы расширили, там с большое, t большое, значит вот эта вот минус вот эта не
отрицательна. Давайте сделаем вставку. Величина такого разреза, очевидно,
больше равна, чем величина такого разреза, когда у меня на одну вершинку меньше.
Понятно, что чем отличается вот этот разрез от вот этого. Я куда-то добавил просто аута маленькая,
одну вершинку добавил и поняли, что величина разреза могла только увеличиться. Значит,
вот эта разность не отрицательна и отсюда мы получаем то, что нужно.
Что это не больше, чем вот это вот первое слагаемое.
Что и требовалось.
Сейчас одну секунду, действительно справедливо. Сейчас я тогда минутку подумаю.
Да, вы право, момент.
Мне хотелось бы вот, чтобы здесь не было вот этого, чтобы здесь было не минус один,
тогда бы все получилось.
Так, sorry.
Смотрите, можно сделать вот так, видимо.
Нет, это бред.
Ладно, sorry. Я не вижу, как это фиксовать. Давайте я на следующий раз это перенесу. Виноват.
Значит, здесь где-то бага. Бага, потому что действительно, да, вот правильно заметили,
что если тут написано что-то не отрицательное, то мы доказали, что наше не больше, чем то,
что надо, плюс что-то, но оно может быть больше, чем это. Да, окей, виноват. В следующий раз давайте
это я пофиксирую. Ну, пока давайте считать, что мы это уже не доказали. Точно верно? Где-то я тут
перемудрил. Тем не менее, давайте мы в него просто поверим, тогда потом это исправится.
Значит, смотрите, что мы доказали. Давайте мы вот то самое применим для AN. Я утверждаю,
что AN обязательно активная. AN обязательно активная. Значит, почему так? Потому что AN-1 и AN,
они точно в разных долях относительно нашего разреза ST. В разных долях нашего разреза ST.
Потому что это был разрез между как раз AN-1 и AN, поэтому скажем, если это в S, то это в T
обязательно. Да, они обязательно в разных, поэтому вот эта вот последняя, она активная, она в новой доле
по сравнению с предыдущей вершиной. Поэтому для нее выполняется утверждение, ну, в смысле,
заключение утверждения нашего, что вот такой вот разрез меньше либо равен, чем С пересечь с AN,
T пересечь с AN. Ну, а AN это просто все вершины, потому что мы как-то там все перенумеровали,
и AN это все вершины. Здесь остается просто CST. Ну все, отсюда следует то, что нам нужно,
что вот этот разрез, который мы нашли, он на самом деле не больше, чем любой другой.
Окей? Тогда мой долг доказать вот это утверждение, из него следует все,
все для, ну, собственно, то, что мы хотели доказать. Вот. Странно вроде всегда доказывалось,
сейчас что-то не получилось. Ну ладно, тогда давайте не будем терять время, перейдем к
минимальным, значит, поток минимальной стоимости, потоки минимальной стоимости,
потоки минимальной стоимости. Начну здесь, конструкция такая. Теперь у нас есть какой-то штраф,
который мы платим за то, чтобы протолкнуть единицу потока по ребру. То есть теперь у каждого
ребра, кроме capacity, появляется также какая-то стоимость, кост. И это значит, что если я пропускаю
единичку потока по этому ребру, то я плачу кост, не знаю, кост рублей в бюджет. Да, и если я,
скажем, пускаю здесь F единиц потока, то мой штраф за это ребро равен F умножить на кост.
Равен F умножить на кост. Значит, тогда, соответственно, суммарный штраф, это сумма по всем
ребрам. Величина потока умножить на стоимость, пускай не единички потока по ребру. Вот, значит,
суммарный штраф. Это сумма по всем ребрам F от E на кост от E. И наша задача, например,
такая. Min-coast k-flow. Min-coast k-flow. Это найти поток величины k минимальной стоимости. То есть
мы хотим протокнуть k единиц потока, при этом так, чтобы общая стоимость была суммарно минимально
возможна. Поток величины k минимальной суммарной стоимости. Суммарной стоимости. Вот, ну и
родственная задача. Min-coast max-flow. То же самое, только k равно просто величине максимального потока
в сети. Тоже только k равно max-flow. Вот, ну и как мы увидим, научившись решать эту задачу,
мы научимся решать вот эту, потому что мы там просто будем пускать по единичке потока каждый
раз. Один, два, три и так далее. И так, в общем, пока в остаточной сети есть путь, мы будем пускать
поток, тем самым найдем максимальный поток, при этом минимальной стоимости. Если у нас на каждом
шаге было минимальный, то в конце тоже минимальный. Так, при этом, чтобы у нас все работало,
нам нужно будет добавлять обратные ребра, ну как всегда, в задачах на потоке мне нужны также
обратные ребра. И здесь, вот если у меня было прямое ребро с весом кост, то обратное будет
со стоимостью минус кост. Это отвечает, собственно, тому, что... Что такое вообще пустить единичку
потока по обратному пути? Это, по сути, отменить ту единицу, которую мы выпустили по прямому
ребру. То есть, если здесь мы заплатили, скажем, кост рублей и протокнули единицу потока сюда,
теперь хотим ее отменить, то мы как бы должны заплатить минус кост, то есть нам должны вернуть
кост. Вот как раз это означает, что нам вернется та самая величина, которую мы заплатили. Вот. И
ну тогда алгоритм, на самом деле, будет довольно простой. Алгоритм такой. Алгоритм Минко-Скофлоу.
Он просто ка раз находит в остаточной сети самый дешевый путь, самый дешевый, в смысле,
из стоимости. Находит самый дешевый путь, пускает по нему единичку потока и перестраивает
остаточную сеть, так делает ка раз. Значит, и от одного дока найти самый дешевый путь в остаточной сети,
дешевый по кост, в смысле, путь в gf, ну и пустить по нему единицу потока.
Ну, с одной стороны, похоже на Айдманскарпа, потому что мы когда-то уже так делали. Мы там искали самый
короткий, ну, кратчайший путь и пускали по нему поток. Только там, кратчайшись, понималось в смысле
числа ребер, там все ребра были невзвешеные, а тут у нас появляются стоимости, поэтому нам нужно будет писать
что-то типа Дэйкстры или Форда Бэлмана, который находит кратчайший путь от одной вершины до другой, до Т.
Ну, имеется в виду, конечно, путь из-за С в Т. Ну и мы знаем, что, скажем, алгоритм Форда Бэлмана
ну, в общем, с Дэйкстра здесь, как бы, на первый взгляд, проблема, потому что могут быть отрицательные
ребра. Да, Дэйкстра не умеет с отрицательными ребрами работать, мы научимся с этим разбираться,
но по умолчанию мы здесь можем писать алгоритм Форда Бэлмана. Алгоритм Форда Бэлмана. Он нам
позволяет находить кратчайший путь в этой сети, в остаточной сети, даже с учетом отрицательных
ребер. Ну и вот, собственно, по нему опускаем 1 поток. Почему это верно? Чтобы доказать,
что алгоритм находит правильный ответ, нам нужна будет такая лемма сначала. Лемма. Пусть Ф это поток
величины К, поток величины К, тогда Ф минко с кафлоном, если и только если в остаточной сети
относительно него нет циклов отрицательного веса. Нет циклов отрицательного веса.
То есть, собственно, у нас будет сейчас критерий того, что какой-то поток является потоком минимальной
стоимости, то есть в остаточной сети не должно быть циклов отрицательного веса.
Значит, ну почему это так? Доказательства скажем слева-направо. Лево-направо очевидно,
если Ф это минкост кафлог, и при этом в остаточной сети есть какой-то отрицательный цикл. Пусть есть
отрицательный цикл. То есть, в остаточной сети есть какой-то замкнутый маршрут, такой,
что здесь вся капаситет положительная, и при этом сумма кастов отрицательна. Значит,
если я просто по этому замкнутому маршруту пущу денечку потока, то у меня, во-первых,
поток останется потоком величины К, потому что вот такая циркуляция, когда водичка просто
течет по контуру, это не меняет величины потока, и при этом это будет, по-прежнему,
корректный поток. А стоимость уменьшится. Добавим циркуляцию по этому циклу.
Ну, собственно, останется поток тоже величины, потому что в каждую, ну, то есть, даже если кто-то
из них С, то в него что-то втекло и что-то вытекло. Короче, эта единичка, которую мы пустили,
она не повлияет на величину потока. То есть, величина потока не изменится, а при этом стоимость
уменьшится. Значит, наш исходный поток был не минимальным. Противоречие. Теперь обратно.
Значит, пусть нет резатных циклов, но пусть F не минимальный. Пусть F не минкост кофлоу.
Тогда рассмотрим настоящий минкост кофлоу. Значит, F звездочка, настоящий минкост кофлоу.
И рассмотрим вот такой поток. F звездочка, минус F. Значит, это будет тоже поток. Ну,
F звездочка, минус F. То есть, мы на каждом ребре просто вычитаем то, что текло в одном потоке из того,
что текло на другом потоке. Это будет тоже поток. Можно там убедиться, что все неравенцы
сохраняются, которые требуются в определении потока. При этом это будет поток величины ноль.
Потому что если в F к единиц потока исходила из S, и в F звездочка тоже к единиц потока исходила из S,
то значит, они все друг друга убьют. Останется ноль единиц потока, которые исходили из S,
поэтому величина останется нулевая. Значит, это поток величины ноль. То есть, это опять циркуляция.
При этом отрицательного веса. Да, потому что это поток минимальной стоимости, это поток чуть
большей стоимости, поэтому их разность имеет отрицательную стоимость. Минимум, минус что-то
побольше, а это что-то отрицательное. Получился у нас поток отрицательной стоимости, величины ноль.
Но это на самом деле значит, что относительно F у нас есть отрицательный цикл. В остаточности есть
отрицательный цикл. Как выглядит такая циркуляция? Несколько таких циклов.
Таких, что на них течет суммарный стоимость всех этих циклов отрицательно. Среди них есть хотя
бы один отрицательный цикл. Среди них есть хотя бы один отрицательный цикл отрицательного веса.
Значит, по нему можно, скажем, пустить единичку потока бесплатно. Ну, собственно, это и будет,
скажем, если здесь вес ноль, то это и будет тот самый цикл отрицательного веса в остаточности GF.
Ну и, собственно, все. Противоречие с тем, что мы предположили, что таких циклов нет.
А зачем нам бесконечно это делать? Вы про вот это, да? Не, нам не надо еще раз, смотрите,
мы просто берем один цикл отрицательный, пускаем по нему единичку потока, мы это можем сделать
один раз. И стоимость уменьшилась от этого. Противоречие, мы предполагаем, что изначально у нас
была минимальная стоимость, а получили меньше. Нам не надо бесконечно, нам достаточно один раз.
Вот, тем самым у нас есть критерий минимальности какого-то потока. Это значит, что в остаточности не
должно быть циклов отрицательного веса. Давайте подумаем.
Так-так-так-так-так, начнем поток включить ноль в исходной сети GF.
То есть, если вот нарисую GF, у меня будет какая-то сеть, остаточная сеть, такая, что остаточная
capacity у всех ребер будет что-то типа исходная capacity минус F от E. Дальше я строю новый поток G,
и получается, что поток по ребру равен F звездочка минус F от E. И тогда, соответственно,
остаточная capacity после этого есть исходная capacity минус F звездочка от E плюс F от E.
Ну да, уже с индексом же маленько, да.
Ну да, окей, значит, есть вот такой вот отрицательный цикл сети G с индексом G. И что это значит?
Значит, здесь все остаточные capacity положительные. То есть, вот эти штуки положительные. Нам хотелось
бы показать, что все тогда вот такие штуки положительные, чтобы можно было бы по этому
же циклу пропустить единицу потока. Ну или хотя бы чтобы на одном цикле так было.
Так, значит, поток отрицательной стоимости и отрицательный цикл.
Так, значит, поток отрицательной стоимости и отрицательный цикл.
Так, значит, поток отрицательной стоимости и отрицательный цикл.
Так, значит, поток отрицательной стоимости и отрицательный цикл.
Так, значит, поток отрицательной стоимости и отрицательный цикл.
Так.
Так.
Так.
Так.
Все, момент.
Значит, смотрите, вот у нас есть два потока, да, F и F звездочка. F и F звездочка. Значит,
я строю вот тот поток. Хочу, на самом деле, показать, что это будет во старшинности GF. Что
во старшинности GF будет вот такой отрицательный цикл. То есть я утверждаю, что как бы F равно F
звездочка плюс несколько циклов, плюс несколько циклов, ну то есть циркуляция, да, можно написать,
плюс циркуляция, GF. Вот. Значит, для этого я рассматриваю их разность.
Звездочка минус F. Понятно, что это какие-то отрицательные циклы. Почему GF? Ну, надо,
надо, видимо, понять, какие, как выглядит capacity. Ну, вот смотрите, если я на каком-то
ребре напишу, да, звездочка E минус F от E. Значит, это меньше либо равно чем, то есть поток по
каком-то ребру G от E не больше чем C от E минус F от E, что, собственно, есть осащенная пропускная
способность в графе GF. Ну, собственно, да, вот получилось. То есть, смотрите, есть у нас вот эти
вот два потока, которые мы один из другого вычли. Тогда поток, текущий по ребру E, это вот эта вот
разность. Оцениваем первый из них через capacity ребра. Ну, а такая разность, это осащенная
пропускная способность в графе GF. То есть это capacity в GF. Получается, что поток по ребру в
циркуляции же не превосходит осащенной capacity, то есть, ну, в общем, в этой осащенности оно есть.
Поэтому все вот эти циклы, на них действительно поток не больше, чем осащенные capacity в GF,
поэтому все такие циклы у нас есть. Вот вроде получилось. Итак, ну, хорошо. Лему вроде как
доказали. Теперь, чтобы доказать корректность этого алгоритма, который к раз просто находит
минимальный путь в осащенной сети, в смысле самый дешевый путь в осащенной сети, то нам
достаточно доказать следующее, что утверждение после этого шага наш алгоритм находит корректный
минкост и flow. Находит корректный минкост и flow. При условии, что в исходном графе GF нет циклов
отрицательного веса, что в GF нет циклов отрицательного веса. То есть, в исходном
графе мы считаем, что нет плохих циклов. Дальше мы каждый раз спускаем самый дешевый путь в
осащенной сети, так делаем K раз, и утверждаем, что после каждого шага у нас будет минкост-поток,
то есть, что эквивалентно, после каждого шага в осащной сети не будет появляться отрицательных
циклов. Поэтому нам достаточно показать, что если отрицательных циклов не было в начале,
то они не появятся никогда по дороге. Достаточно доказать, что не появляется отрицательных циклов.
Ну пусть появляются. Вот у нас была какая-то хорошая осащенная сеть GF, мы в ней нашли
кратчайший путь, самый дешевый в плане стоимости, пустили по нему динечку потока,
перестроили осащенную сеть, и у нас появился отрицательный цикл. Вот пусть GF, а был какой-то
путь P, кратчайший путь, мы по нему протолкнули динечку потока, и потом вдруг появился отрицательный
цикл. То есть раньше не было, теперь появился. Ну как он может тогда выглядеть? Раз он появляется,
его раньше не было, то он обязательно должен использовать одно из вновь появившихся ребер.
То есть обязательно хотя бы одно из таких обратных ребер он должен использовать. Потому что если
он ни одно из этих обратных ребер не использует, которые позволяют отменять вдоль пути P, то
соответственно он использует только остальные ребра, значит цикл был в исходной сети. То есть хотя
бы одно такое ребро мы используем. Давайте я какую-нибудь картинку нарисую, вот это был P. Что-нибудь
вот такое может быть, например. У нас мог появиться в осащенном сети GF штрих вот такой вот отрицательный
цикл. Давайте его назову C. Пусть в GF штрих появляется отрицательный цикл C. Тогда смотрите,
давайте я в GF посмотрим поток. Рассмотрим поток. Ну я вот так назову P плюс C. То есть давайте
вот в этой исходной сети GF пущу единичку потока здесь и единичку потока по этому циклу. Что у меня
получится? Ну во-первых, потому что этот цикл, у меня останется поток величины 1. Как он будет
выглядеть на этом конкретном примере? Вот смотрите, здесь у меня текла туда единичка,
но я ее здесь отменил. То есть по сути разорвал вот этот путь. Значит у меня будет... Так,
сейчас я нарисую. Значит будет вот здесь вот циркуляция, вот такая. И будет вот такой вот путь,
по которому течет поток. В данном конкретном случае, если я сложу этот путь и вот этот цикл,
то у меня останется цикл и путь. И так будет, соответственно, всегда. Если у меня есть поток
величины 1 и поток величины 0, то есть путь и циркуляция, я их сложу, у меня останется какой-то
поток величины 1, то есть какой-то путь из старта в T, из S в T. И еще какая-то циркуляция, там
будет несколько циклов. Вот эта штука, это путь плюс циркуляция. Потому что это поток величины
1, значит это один путь с капостью 1 из S в T. И еще там несколько циклов возможно. Вот,
но при этом смотрите, этот путь обязательно имеет вес больше либо равный, чем вес P, потому что P
был кратчайший. Это какой-то путь в остаточности GF. Значит этот путь имеет величину, стоимость
хотя бы как у P. А эта циркуляция в GF, то есть это несколько циклов в исходном графе GF, поэтому они
все имеют вес не отрицательным. Мы предположим, что в GF отрицательных циклов нет. Значит эта штука
большая на P, а эти все не отрицательные. По стоимости больше обыкновенна, чем стоимость P,
а это все не отрицательные. Так.
Но при этом вот эта вот вещь, мы же предположили, что стоимость C отрицательна. Получается,
что стоимость вот этой вот вещи, она как бы меньше должна быть, чем стоимость P, противоречие. То есть
с одной стороны стоимость P плюс C меньше, чем стоимость P, потому что это P плюс что-то отрицательное.
Давайте я напишу на этой доске.
Итак, с одной стороны стоимость P плюс C равна стоимость P плюс стоимость C. Это меньше, чем стоимость
P, потому что P это отрицательный цикл. С другой стороны, P плюс C это какой-то путь уличный хотя бы
кост P и несколько циклов, все из которых не отрицательные. Ну, противоречие. С другой стороны,
кост P плюс C больше равно, чем кост P, плюс что-то не отрицательное. То есть она меньше, с другой
стороны больше она равна. Противоречие, значит, не могло быть такого цикла C, значит, если его не было
в исходной сети, то его не будет ни после какого момента времени.
Вот. Ну что, значит, наш алгоритм корректен. Если в исходной сети, вот прям в G, в исходном нет
отрицательных циклов, то они никогда и не появляются. Они никогда не появятся. Поэтому наш алгоритм,
скажем, Форда Белмана, он будет просто отлично работать. Напоминаю, что алгоритм Форда Белмана,
там нужно немножко что-то обновить, если есть отрицательные циклы. Если есть отрицательные циклы,
то нужно делать на одну итерацию больше. Там тогда на каждом цикле хотя бы в одной вершинке что-то
меньше надо запустить. Ну, в общем, и так далее. Бывают расстояния равны минус бесконечности,
а тут такого не будет, потому что нет таких циклов. Ну и так. Нет отрицательных циклов.
Следовательно, Форт Белман работает очень хорошо.
Работает, ну, я имею в виду, без всяких минус бесконечности. Не надо вот с этим лишний раз
запариваться. Хорошо. Значит, в итоге алгоритм такой, что мы просто на каждом шаге, вот у нас
есть исходная сеть без отрицательных циклов, находим корочайший путь с помощью Форт Белмана,
пускаем поднимающую потоку, перестраиваем сеть и так делаем K раз. Асимптотика, соответственно,
будет от K умножить на асимптотику Форда Белмана, это, ну, видимо, VE.
Форт Белман — это динамика, в которой V слоев и каждый слой пересчитывается за VE.
Так, хорошо. Вот, но на самом деле можно делать все-таки что-то похожее с помощью алгоритма
Dijkstra. То есть, смотрите, Dijkstra как бы сама в себе неприменима, потому что у нас есть вот
эти отрицательные ребра. Если мы что-то пустили, то у меня появилось обратное ребро отрицательного
веса, и как бы Dijkstra с ними по умолчанию работать не умеет. Вот, но мы сейчас ведем,
так называем, потенциалу Джонсона, который нам позволит нашу Dijkstra модифицировать.
Вот, смотрите, пусть VE — это какая-то функция, тогда мы можем следующим образом исправить
стоимость любого ребра у V. Я буду называть эту функцию потенциалом. Тогда стоимость после
применения потенциала — это стоимость до применения потенциала, плюс потенциал начала,
минус потенциал конца. Fiat-V. Значит, вот так изменяем веса всех ребер. Прелесть такого
преобразования в том, что у нас не изменятся кратчайшие пути между любой парой вершин.
Потому что как устроен путь? Вот есть какой-то путь P из одной вершины в другую. Как меняется
его стоимость при навешивании, при переходе от костов к костам с индексом phi. Давайте проследим.
У нас добавится phi от начала здесь, вычтется phi отсюда. Дальше, на этом ребре добавится phi здесь,
вычтется phi здесь. То есть вот это вот как бы уничтожится. Здесь было плюс phi и минус phi.
Здесь тоже самое. Плюс от ребра и минус от этого ребра. Поэтому здесь тоже уничтожится. Короче,
по всем вот этим промежуточным вершинам у меня потенциал не войдет. У меня останется только плюс
потенциал начала, минус потенциал конца. Давай так напишем, что исправленный потенциал,
ну точнее исправленный вес любого пути, это его исходная стоимость, плюс потенциал старта,
минус потенциал конца. В частности, это означает, что у меня не поменялись кратчайшие пути сами
по себе. То есть любой путь по стоимости изменился вот на такую поправочку. И если у меня S и T это
какие-то фиксированные вершины, то значит, что они все поменялись на одну и ту же константу,
которая не зависит от пути. Значит, если на каждом пути мне прибавили одну и ту же константу,
значит все кратчайшие пути сохранились. Они просто изменили свой вес вот на столько.
И при этом мы хотим, чтобы после навешивания этих потенциалов у нас все косты стали
не отрицательными, чтобы можно было DX пускать. Мы хотим, чтобы кост Фи от УВ было
всегда не отрицательным. Это можно сделать следующим способом. Пустим один раз алгоритм
Форда Белмана и положим, что Фи от В это DIST SV. Раньше я пускал карат Форда Белмана,
теперь я запущу его только один раз. И скажу, что потенциал каждой вершины равен расстоянию от S
до нее, которую мы нашли в алгоритме Форда Белмана. Тогда смотрите, что такое кост Фи для какого-то
ребра. Это кост УВ плюс DIST SU минус DIST SV. Я хочу понять, что это не отрицательно,
но это просто не нравится треугольника. Если я примесю это в правую часть, у меня здесь написано
следующее, что DIST SV не больше, чем кост УВ, плюс DIST SU. Это очевидно, что если есть какой-то
путь до У и можно пройти ребро УВ, то вес пути до В он меньше равен, чем вот этот. Мы взяли
кратчайший путь от S до У, дальше приклеили ребро УВ. Понятно, что кратчайший путь от S до В либо такой,
либо еще меньше. То есть, возможно, есть какой-то более короткий от S до В, но такой точно есть,
поэтому это не нравится у нас. Если мы потенциально возьмем функцию расстояний и потом пересчитаем
с ее помощью все стоимости всех ребер, тогда у меня получится, что эти стоимости не отрицательны,
а значит, на них можно пускать DXT. Ну хорошо, давайте мы один раз пустили Форда Белмана,
посчитали все потенциалы, то есть все расстояния. Теперь у меня все стоимости вот эти не отрицательны,
и я понимаю, что искать кратчайшие пути в терминах кост В, то же самое, что искать кратчайшие пути
в терминах кост. Они все изменились только на константу, но сами пути не изменились. Поэтому давайте
найдем, пустим алгоритм DXT. Как он отработает? На весах кост с индексом Фи. То есть мы обновили
стоимости, теперь все стоимости это кост Фи. Как он отработает? Во-первых, мы понимаем,
что все веса не отрицательны, все вот эти косты индексом Фи больше нуля. Но также мы можем легко
заметить, что стоимость всех вот этих вот ребер, стоимость этого пути, это в точности ноль. Потому
что раньше, поскольку мы, ну то есть до этого, мы только что пускали Форда Белмана из С, и на каждой
вершине написали ее расстояние, расстояние от С до нее, а дальше все вот эти вот косты пересчитали,
как стоимость там, плюс разность расстояний. То на самом деле, тогда на всех этих ребрах кост
Фи нулевое, на всех ребрах на кратчайшем пути от С до Т кост Фи нулевое. А почему? Потому что
кост Фи у В это, ну давайте напишем, кост у В плюс Фиату минус Фи от В. Но поскольку это все кратчайший
путь от С до Т, то это в частности кратчайший путь от С до В. Значит, Фи от В отличается от Фиату
ровно на эту стоимость, поэтому это ноль. На ноль на кратчайшем пути от С до Т. То есть, как будто бы
можно даже было бы не пускать Dx, а просто найти произвольный путь веса ноль из С до Т. То есть,
как будто бы мы наставляем только ребра стоимости ноль, ну и там скажем, с помощью Dfs мы находим
произвольный путь из С до Т. Это будет самый короткий путь из С до Т. Но при этом после того,
как я опускаю днику потока здесь, у меня появляются обратные ребра. Но тоже нулевого
веса, нулевой стоимости. Потому что если здесь была нулевая стоимость, то здесь тоже стоимость
будет ноль. Противоположно, это ноль. И тогда как будто бы опять у нас не появляется отрицательных
ребер. То есть, мы опустили днику потока здесь, появилось несколько обратных со стоимостью ноль,
ну как будто бы опять применил алгоритм Dx. Потому что нет отрицательных ребер, не появилось
отрицательных ребер. На самом деле это пока что верно. На следующей терации все ребра не отрицательны,
но потом уже, вот на второй терации, если я опять запущу алгоритм Dx, у меня получится так,
что путь, который я найду, он уже возможно не обязательно состоит из нулей. И там могут быть
ребра положительного веса, и соответственно обратное к ним будет отрицательно. Поэтому мы сделаем
следующее. Вот мы опустили алгоритм Dx. Пусть, давайте напишу Pseud V, это dist Sv, который нашел
алгоритм Dx. Который нашел алгоритм Dx. И дальше, ну как бы, что мне было важно, почему я смог
применить алгоритм Dx здесь? В смысле, почему все веса были не отрицательны и веса обратных ребер
тоже были не отрицательны? Потому что к этому моменту потенциал это был dist Sv. То есть вот
к этому моменту потенциал это была функция расстояния от S до V. Теперь, значит, я хочу сделать
то же самое. То есть у меня теперь опять есть какая-то сеть, я пускаю в ней единичный поток,
поток единичной и единичной величины. Как-то у меня перестраивается граф. Я хочу опять, чтобы новая
функция, вот эта вот Pseud, опять была функцией расстояния. Ну вот, я ее, собственно, с помощью
Dx нашел. Дальше, чтобы правильно пересчитать потенциалы, мне нужно еще кост, ну, обновить на
величину вот этого потенциала. То есть сделать так кост у V. Сейчас, секунду. То есть мне нужно
теперь вот в этой остаточной сети применить то же самое преобразование, что я сделал с phi,
только теперь с Pseud. То есть нужно как бы учесть в потенциале наш потенциал Pseud, который мы нашли.
То есть нужно просто все стоимости, ну вот, опять увеличить на Pseud от U и уменьшить на Pseud от V.
И тогда у меня опять будет верно, что потенциал, который вот я сделал, у них это функция расстояния,
это функция расстояния. Значит опять все ребра не отрицательны. Корочайший путь, это путь по нулевым
ребрам. Значит, когда я сделаю следующий dx, у меня все обратные ребра тоже не отрицательны.
Поэтому алгоритм можно написать такой.
Значит, алгоритм. Ну, мне нужна будет процедура какая-нибудь типа Void. Применить потенциалы,
применить потенциал, phi. Ну, это вот ровно вот для каждого ребра сделать вот то преобразование.
Для любого ребра E нужно стоимость этого ребра исправить на phi от U минус phi от V.
Значит, это вот такое применение потенциала ко всем ребрам. Дальше.
Минкостка flow. Сначала мы считаем потенциальную функцию с помощью алгоритмов Форд Белмана.
Форд Белман. Собственно apply потенциал phi. Ну, а затем k раз. Находим корочайший путь,
пускаем по нему единичку потока и пересчитываем потенциал с помощью apply potential.
Значит, phi это алгоритм Dijkstra. Ну, на нашем графе. На текущей версии графа как бы.
Случно там вот этих вот уже примененных потенциалов.
Значит, дальше пустить единицу потока. Не знаю как это написать.
Комментарии, ладно. Пустить единицу потока.
И потом просто apply потенциал phi. Потому что когда я это делаю, у меня опять,
ну, я нашел корочайшее расстояние от вершины до, ну, от S до всех остальных,
применил. Соответственно могу применить алгоритм Dijkstra и все проблемы устранил.
То есть когда я вот здесь вот у меня появляются обратные ребра, возможно отрицательных весов,
я потом это исправляю с помощью пересчета потенциалов функции psi.
Вот, тем самым у меня алгоритм просто один раз Fort Bellman и потом k раз до extra.
Вот это? Да-да-да, конечно. То есть мы нашли корочайший путь от S до всех, в частности от S до T.
И вот по нему пускаем. Ну, корочайший у нас, конечно, всегда от S до T. В смысле,
пускаем путь по корочайшему потоку от S до T. Значит, симптотика напишу. Ну,
Fort Bellman у нас работает за VE, Dijkstra работает за, ну, например, kE log V.
У нас была такая Dijkstra или можно написать, что это kV квадрат, например. Если у вас граф плотный,
то здесь будет вместо E log V можно за V квадрат написать Dijkstra. Будет симптотика, ну, например,
вот такая VE плюс kV квадрат. Всё, спасибо.
