Так, да, всем добрый день.
Ну и в прошлый раз мы с вами закончили,
на самом деле почти закончили обсуждение темы поиска кратчайших путей в графе.
То есть мы рассмотрели две постановки.
Первая постановка – это single source задача, то есть задача поиска кратчайших путей из одной вершины до всех остальных.
Ну и рассмотрели задачу поиска кратчайших путей между, вообще говоря, всеми парами вершин.
Мы рассмотрели несколько постановок, что делать если у нас там граф разрежный, если у нас граф плотный,
соответственно в графе есть отрицательные ребра, если нет отрицательных ребра, что делать если есть циклы отрицательного веса,
что делать если их нет, ну и так далее.
В целом полный спектр задач, которые касаются кратчайших путей мы с вами рассмотрели.
И мы в следующий раз еще коротко к этой задаче вернемся.
Ну в целом такие основные результаты, основные алгоритмы мы с вами рассмотрели.
Чем хочется заняться сегодня, так это рассмотреть последнюю на самом деле в нашем курсе постановку задачи,
а именно поиска потока оптимальной величины.
Вот это тоже задача, ну и тоже считается задачей на взвешенную графику.
То есть я напоминаю, что после последних лекций мы с вами рассматриваем алгоритмы, которые принимают не только граф,
но и соответственно некоторую функцию, там неважно это весовая функция, там функция на ребрах, функция на вершинах,
ну так или иначе, в общем, некоторая функция, которая хранит полезную информацию, полезную информацию там на всяких сущностях в графе,
соответственно с помощью этого можно сказать либо минимально остальные деревья, либо там кратчайшее стояние и там подобное.
Так вот в чем заключается задача поиска потока максимальной величины.
Задача на самом деле довольно-таки, ну тоже по своей постановке довольно-таки понятна, довольно-таки понятно, какие у нее могут быть применения и так далее.
То есть самое простое, это, не знаю, у нас есть какая-то транспортная, транспортная сеть, собственно такие графы, на которых заданы там пропускные способности,
пропускные способности сейчас называют именно транспортными сетями.
Вот, значит, вам даны некоторые графы, соответственно есть некоторые дороги, неважно, что могут быть односторонние, на самом деле бусторонние,
ну как правило предполагается, что дороги односторонние, в смысле можем продвигаться только из одной вершины в другую.
Ну и соответственно на этих дорогах или, если угодно, ребрах, соответственно написана некоторая пропускная способность,
то есть сколько, ну давайте так считать, грубо говоря, единиц товара или единиц чего-либо, какой-то жидкости, жижи и тому подобного,
может протекать вот по этой трубе, по этой дороге и тому подобное.
Вот, соответственно, да, ну соответственно здесь, например, изображен некоторый граф, в нем, как обычно, есть вершины, есть соответственно ребра,
и на каждом ребре записана некоторая чиселка, это пропускная способность этого ребра.
То есть пропускная способность говорит о том, какое максимальное количество единиц товара мы можем проточить вот по этому ребру.
И также в этом графе у нас есть две выделенные вершины.
Ну на самом деле может быть такое, что вершин на самом деле не две, а может быть несколько.
Ну там в классической обстановке у нас есть две выделенные вершины.
Одна называется источником, а другая называется стоком.
Из источника, то есть источник может, грубо говоря, произвести сколько угодно единиц товара,
то есть из источника мы товары, грубо говоря, испускаем, а в сток это, собственно, наша целевая точка, то место, куда мы хотим этот самый товар доставить.
Ну и собственно задача довольно-таки понятна.
Мы хотим максимизировать количество перевозимого Тамара в товар в единицу времени.
Мы хотим назначить такой маршрут.
При этом важно понимать, что должен быть не обязательно путь, то есть не обязательно просто путь.
Это может быть просто несколько ручейков, которые выходят из источника в сток,
так чтобы суммарное количество товара из источника в сток было, может, больше.
Но при этом, естественно, мы хотим, чтобы по каждому ребру провозилось не более, то есть не более,
количество товара не больше, чем та самая профессиональная способность, которая написана на нем.
Ну вот, собственно, довольно-таки простая обстановка.
Ну давайте, собственно, подумать, как ее, как соответственную задачу можно пережить.
Ну для начала давайте, чтобы решить задачу, давайте, значит, для начала ее формализуем,
то есть запишем в каких-то математических терминах,
введем какие-то обозначения, чтобы можно было к этому обращаться при описании алгоритмов
и вообще при доказательствах и тому подобного.
Как я уже сказал, у нас есть транспортная сеть.
Транспортная сеть мы будем называть некоторой граф G с выделенной парой вершин,
которая называется источником и стоком.
И также на этом графе введена функция прописной способности.
Причем мы будем считать, что функция прописной способности задана не просто на ребрах,
она задана именно на парах вершин.
То есть для каждой пары вершин мы знаем, сколько товара можно за единицу времени провести
из первой вершины во вторую.
Ну причем будем считать, что если в нашем графе нет соответствующего ребра,
то просто соответствующая пропускная способность равна нулю.
Ну это довольно разумно.
То есть если между парами вершин нет никакого ребра, то, соответственно,
нисколько единиц товара мы между ними пропустить не можем.
Вот, соответственно, вот это условие здесь и записано.
Окей.
Ну и, собственно, поток.
С каким объектом мы на самом деле будем работать?
Ну поток тоже можно вести математически.
То есть потоком будем называть тоже функцию на парах вершин.
Тоже, соответственно, не отрицательно значную,
которая, соответственно, будет предварять двум соотношениям.
Довольно понятным, про который я уже сказал, для любой пары вершин.
Ну, во-первых, поток у нас не отрицательный.
Во-вторых, соответственно, тот поток, который мы проводим из одной вершины в другую,
не должен превосходить пропускной способности этого ребра.
Вот.
Ну и, соответственно, второй.
Ну это, собственно, первое условие.
Это условие, ну не знаю, значит, в физике это называется правило сохранения заряда.
Ну у нас как бы правило сохранения потока.
То есть сколько потока у нас вошло в узел, столько потока и должно выйти из узла.
То есть мы считаем, что в узле, в промежуточному узле у нас поток не накапливается
и не возникает из ниоткуда.
То есть единственные вершины, из которых поток может продуктироваться сколько угодно
и в которые поток может теряться сколько угодно,
это, соответственно, источник-исток из стока я могу воспользоваться, да,
сколько угодно потока.
То есть поэтом там поток рождается, да, потому там баланс, естественно, не сохраняется.
А в стоке, соответственно, этот поток, грубо, накапливается, да,
поэтому там тоже баланс не сохраняется.
там тоже баланс не сохраняется.
А во всех промежутках вершинок этот баланс должен сохраняться.
Давайте, например, рассмотрим эту вершину.
То есть тут мы видим, что входит в него поток 1,1,1,
и выходит поток равный 3.
То есть 3 потока вошло, 3 единицы потока и вышло.
То есть поток у нас в промежутках вершинок не накапливается.
Это тоже довольно-таки естественное требование.
Понятны ли данные определения? Есть ли вопросы?
Окей.
Будем считать, что все ясно.
Определение, как мне кажется, довольно простое.
Но как мы в дальнейшем поймем,
этим определением нам будет довольно неудобно пользоваться при построении алгоритма.
То есть несмотря на то, что кажется, что,
как я уже сказал, довольно-таки естественное определение,
мы будем пользоваться немного другим.
Прежде чем мы перейдем к другому определению,
давайте для начала поймем, что не так с этим определением.
Почему с помощью него нам не удастся сразу сходу решить
задачу поиска потока максимальной величины.
Давайте рассмотрим пример.
Для начала давайте закончим с определениями.
Нужно ввести еще пару важных понятий.
Во-первых, величина потока.
Я все это время говорил, что мы решаем задачу поиска потока максимальной величины.
А что вообще такое величина потока?
Есть величина исходящего потока и есть величина входящего потока.
По названию, я думаю, уже понятно, что величина исходящего потока
это количество потока, которое выходит из источника,
а величина входящего потока – это количество потока, которое входит в Восток.
Соответственно, если мы решим задачу поиска потока максимальной величины,
то величина входящего потока – это количество потока, которое входит в Восток.
Есть два обозначения.
Величина исходящего потока и величина входящего потока.
Я думаю, интуитивно довольно ясно, что если у нас в промежутных вершинах поток
не накапливается и не продуцируется, то весь исходящий поток,
который генерируется в источнике, должен в итоге пойти в сток.
На самом деле чиселка f плюс и чиселка модуль f минус – это две одинаковые чиселки.
Действительно, мы это в будущем докажем.
Поэтому, соответственно, это подтверждение мы докажем чуть позже.
Но в целом важно понимать, что такое величина потока.
То есть величину потока можно считать либо как тот суммарный поток,
который генерируется в источнике, либо тот суммарный поток, который заходит в Восток.
Чтобы не уточнять, какую чиселку я имею в виду, я буду говорить просто величину потока.
Все понимают, что неважно, обчитаем исходящий поток или входящий поток.
Это все одно и то же.
Задача формулируется следующим образом.
Нам дана транспортная сеть, нам дана некоторый граф, нам дана функция пропускной способности.
И, соответственно, нам нужно найти такой поток, такую функцию на парах вершин,
который бы максимизировал поток, при этом максимизировал величину потока.
При этом неважно, на исходящий поток или входящий поток.
Это все одно и то же.
То есть необходимо найти Fs звездой, который бы давал максимум этому самому потоку.
Но, соответственно, для графа, который изображен здесь на рисунке,
один из возможных вариантов максимального потока изображен здесь.
То есть мы видим, что из источника исходит 12 единиц потока и в сток входит 12 единиц потока.
Видно, что больше мы никак поток сгенерировать не сможем,
потому что нам не позволяют это сделать пропускные способности из источника и в сток.
А все остальные конфигурации представлены здесь.
Во-первых, все чиселки, которые написаны красным цветом, они, во-первых, никак не больше черных чиселок.
А во-вторых, соответственно, мы видим, что для любой промежуточной вершины без меток
величина входящего потока строго равна величине исходящего потока конкретно в эту вершину.
Ну и величина протока, естественно, тут в данном примере равна 12.
Вот. Окей.
Соответственно, давайте попробуем придумать какой-нибудь алгоритм,
который бы помог нам искать потоки максимально величины.
Давайте пока не думать об эффективности, а пока просто-напросто попробуем что-нибудь придумать.
Ну и соответственно, первая идея, которая приходит в голову, это действовать жадным.
Давайте, собственно, будем действовать жадным образом.
То есть просто-напросто возьмем источник, найдем какой-нибудь произвольный путь из источника в сток,
и вот по этому пути пустим какой-то поток.
Понятное дело, что если я из источника могу добраться до стока, то соответственно, вот по этому пути, который я нашел,
я, соответственно, могу пустить поток какой-то величины.
Ну, например, давайте, соответственно, тут изобразим.
Вот, допустим, я нашел путь по этому ребру, по этому ребру.
По этому ребру и вот по этому ребру.
Вот, соответственно, я нашел вот такой путь.
Ну и, соответственно, я вижу, что по этому пути я могу пустить, например, 3 единицы потока.
Давайте опущу 3 единицы потока.
И все.
Что я сделаю дальше?
Давайте снова найду какой-нибудь путь, например, не знаю, у меня есть путь вот такой, потом снова пойду вот по этому ребру и снова пойду вот по этому ребру.
Вот вижу, что по этому пути я могу пустить еще три дополнительные единицы потока.
Пускаю тут 3, тут 3, плюс 3, 6, тут 3, плюс 3, 6.
Ну и соответственно и так далее, пока у меня на пути будут встречаться, пока я могу построить путь по незаполненным ребрам.
Вот такой простой жадный алгоритм. Постоянно буду искать путь из источника в сток и, соответственно, что называется, дополнять этот путь новым потоком.
И соответственно алгоритм останавливается в тот момент, когда у меня не получится найти путь из источника в сток.
Понятное дело, что если у меня там какой-то момент, я вижу, что у меня вот это ребро насытилось полностью, то есть я не могу по нему пройти.
Если я вообще не смогу найти путь из источника в сток такой, что я не смогу пройти по насыщенным ребрам, по не насыщенным ребрам, то соответственно в этом случае алгоритм останавливается.
Ну тоже довольно простой алгоритм, жадный, и при этом кажется, что нам вообще не нужно никаких дополнительных алгоритмов тогда придумать.
Потому что мы знаем, как искать пути, банально, наверное, знаем поиском глубину, поиском ширину, можем найти произвольный путь, вдоль этого пути пустить какой-то поток и так далее, повторять до тех пор, пока, соответственно, не остановимся.
Но, как вы понимаете, проблема в том, проблема, как и практически любого жадного алгоритма, заключается в том, что если мы делаем все в тупую, то понятно дело, что на каждом шаге, пока мы дополняем путь, наш поток увеличиваем.
Но проблема в том, что, допустим, в какой-то момент мы остановились, в какой-то момент мы не смогли дополнить наш поток.
А кто, вообще говоря, сказал, что этот поток будет максимален? То есть то, что мы не можем дополнить текущий поток, вообще говоря, не означает, что мы нашли максимальный поток.
А вдруг мы как-то находили неоптимальные пути, вдруг мы как-то поток пускали по неоптимальным сетям.
Вдруг мы как-то для какого-то пути пустили слишком много потока, а на самом деле там можно было пустить какой-то более мелкий поток, и тогда, соответственно, в целом нам было лучше.
То есть для такого жадного алгоритма непонятно, почему мы в итоге придем к правильному ответу.
Ну и на самом деле мы не придем к правильному ответу, потому что довольно-таки просто придумать контрпример.
То есть контрпример изображен здесь. То есть изображен граф, транспортная сеть, и у него у каждого ребра, соответственно, по единичной пропускной способности.
И, значит, допустим, мы на том рахе выполняем первый путь, находим первый путь.
Допустим, нашли вот такое ребро, вот такое ребро и вот такое ребро.
И, соответственно, вот по этому пути мы, соответственно, пустили поток величины 1.
Ну и, соответственно, что мы после этого видим? Переходим в следующие итерации.
То есть снова пытаемся найти путь, и мы видим, что, соответственно, теперь в полученной транспортной сети, точнее, в полученной остаточной сети, у нас никаких дополнительных путей нет.
То есть мы просто-напросто не можем пустить путь из источника в сток.
Такой, чтобы он проходил по незаполненным ребрам.
Потому что у нас есть незаполненное ребро. Вот это ребро, вот это ребро.
Вот это ребро у нас, соответственно, между ними, то есть от одного к другому мы добраться не можем.
Ну, соответственно, всё. На этом наш алгоритм останавливается.
Но при этом мы видим, что очевидно, что наш поток не является потоком максимальной величины.
Потому что можно было пустить, например, если мы, наверное, опустили два потока, один по верхней ветке, другой по нижней ветке, то, соответственно, мы получили поток равный двум.
Что, во-первых, явно больше, чем то, что мы нашли до этого.
А, во-вторых, он явно является потоком максимальной величины, потому что пропускная способность источника и пропускная способность стока, они равны двум.
То есть проблема же одного подхода, который мы только что описали, состоит в том, что если мы в какой-то момент нашли плохой ручеёк,
что если в какой-то момент мы нашли плохой путь, то в будущем мы это никак не исправим.
То есть хотелось бы сказать, что вот этот путь мы использовали в какой-то момент зря.
Окей, мы его нашли, но хотелось бы в какой-то момент как-то понять, что этот путь мы нашли зря,
и если бы мы его не использовали, мы бы получили дополнительную возможность пустить поток вот так и пустить поток вот так.
Хотелось бы исправлять ошибки прошлого.
Если бы мы в какой-то момент пустили плохой ручеёк, хотелось бы как-то либо от него избавиться, либо его как-то исправить и так далее.
Ну и смотрите, в целом какая идея. Идея в том, что даже если у нас есть такой ручеёк плохой,
мы же что на самом деле можем сказать? Можем сказать, что давайте пустим поток вот здесь, потом поток пойдёт вот сюда в обратном направлении,
и потом пойдёт вот сюда. Мы тут видим, что в целом у нас встречаются два потока, которые текут в разных направлениях.
Но в целом баланс сохраняет. Если у меня один поток течёт в одну сторону, второй поток течёт в другую сторону,
то они друг друга взаимно уничтожают, и поэтому по этому пути, по центральному течёт 0 единиц потока.
А это нас устраивает, потому что 0 явно меньше равно, чем единица.
То есть хотелось бы уметь пускать потоки либо в обратном направлении, либо коротко говоря, исправлять какие-то плохие потоки или ручейки.
Вот. Идея понятна? Ну то есть в целом, да? Чего бы хотелось?
Чего бы хотелось и соответственно, чем нас не устраивает текущий алгоритм жадный?
Ну, собственно.
Да. Далее мотивация. Ну, смотрите. В чём изъян данного подхода?
Вот, допустим, вот для этого графа я нашёл вот такой путь.
Вот. Что нам говорит этот самый жадный алгоритм? Жадный алгоритм говорит следующее.
Давайте снова посмотрим наш граф. Вот. Ну, с уже введённым на нём потоком.
Вот. И попробуем вот в остаточной сети. То есть в той конфигурации, которая у нас есть.
Давайте попробуем в ней пустить ещё какой-то путь.
Но давайте посмотрим вот на этот граф. Можем ли мы в этом графе пустить какой-то путь, который проходит по незаполненным ребрам?
И кажется, что нет. Кажется, что нет. Почему? Потому что сюда я из С пустить путь не могу.
Могу пустить вот сюда. Но когда я добрался вот сюда, вот до этой вершины, из неё я уже никуда деться не могу.
Почему? Потому что сюда я двигаться не могу, потому что это ребро заполнено.
Сюда я двигаться не могу, потому что у меня в принципе нет ребра из этой вершины Х в вершину Y.
Ну и соответственно всё. То есть в итоге получается, что из вершины С я никак не могу добраться до вершины Т.
А всё почему? Потому что я изначально выбрал неправильный ручьёк. Изначально вот этот путь мне в принципе был не нужен.
Но с другой стороны, если бы я изначально выбрал вот такой путь хороший, сначала вот так, а потом вот так, то я бы получил подок максимальной вершины.
Вот. Но вот меня не повезло, и я выбрал вот такой путь.
И хотелось бы иметь какой-то способ по этому алгоритме довольно простому, хотелось бы иметь какой-то способ исправлять плохие ручьёки.
То есть вот я вижу что я получил плохой ручьёк, ну вот хотелось бы уметь как-то его исправлять.
То есть хотелось бы во-первых понимать, что он, наверное, плохой, да, что он мне не позволяет поучить дополнительные пути.
Вот, а во-вторых, если я понял, что он плохой, хотелось бы уметь его как-то исправить.
Скажем, заменить вот это ребро там, вот это ребро, и добавить вот это ребро.
Ну, точнее, поток. Понятно?
Окей. Соответственно, каким образом мы это будем делать?
Ну, значит, чтобы научиться это делать, давайте, собственно, как я уже сказал,
ведем несколько иное определение потока.
Оно полностью эквивалентно тому, что было до этого, да, то есть в нем, на самом деле,
получаются те же самые величины потоков и так далее, но просто вот это определение потока,
чуть более сложное, которое мы сейчас рассмотрим, оно просто более удобно на практике, на самом деле.
И это, соответственно, понятие симметризованного потока.
Значит, другое определение потока.
Значит, поток мы будем называть функцию, потом мы будем называть функцию, кстати,
тут надо брать R+, просто, из пар вершин в действительные числа,
которые удовлетворяют следующим соотношениям.
Во-первых, будем использовать следующую, выполняется первое соотношение.
Поток антисимметричен, то есть если из вершины В, вершины У течет поток F,
то в обратном направлении течет поток минус F.
То есть, грубо говоря, если у вас есть две вершины, У и В,
и в одном направлении течет поток 10, то мы считаем, что в обратном направлении течет поток минус 10.
И вот тут работает чистая аналогия, не знаю, прошу прощения студентов,
но тут работает чистая аналогия с протеканием электрического тока.
Почему? Потому что если у вас есть провод, то считается, что положительные частицы двигаются в одну сторону,
или можно считать, что отрицательные заряж 게стицы двигаются в обратную сторону,
это абсолютно эквалентная история.
Тут тоже самое, то есть если положительный поток течет в одном направлении,
то можно таким же успехом считать, что и отрицательный поток течет в обратном направлении.
Соответственно, поток симметризован.
То есть мы считаем важный момент, что между каждой парой вершин у нас обязательно есть какое-то ребро.
Точнее так. Между каждой парой виши у нас есть два ребра.
Одно в одном направлении, второе в обратном направлении.
И если по этому ребру в одном направлении течет какой-то положительный поток,
то в обратном направлении течет отрицательный поток точно такой же величины.
Второй момент.
Ну, второй момент, естественно, мы должны гарантировать,
что поток никак не больше, чем пропускная способность.
Значит, на этом тоже нужно остановиться подробнее.
Смотрите, я избавляюсь от требований, что у меня поток обязательно должен быть больше равен нуля.
Почему? Потому что у меня в обратном направлении всегда течет поток отрицательной величины.
Это во-первых.
А во-вторых, отрицательные вершины, то есть отрицательные потоки мне тоже ничего не портят.
Почему? Давайте посмотрим, например, вот сюда.
Что я тут вижу? Я тут вижу, что у меня есть обычное ребро,
которое идет сверху вниз.
И вот сверху вниз, соответственно, течет поток величины 1.
Но в то же время у меня есть такое же обратное ребро снизу вверх.
Напоминаю, что такое пропускная способность 0.
Пропускная способность 0 просто означает, что в исходном графе этого ребра просто нет.
Но я просто это ребро добавляю эффективно, чтобы было удобнее анализировать.
То есть я просто-напросто для каждого ребра добавляю эффективное обратное ему.
Просто нулевой пропускной способности.
И оно на самом деле ничего не портит. Почему?
Потому что вот по этому ребру снизу вверх у меня теперь течет поток минус единицы,
ну а минус единицы меньше ребра на нуля.
То есть что сверху вниз, что снизу вверх, у меня соответственно выполняется соотношение
на максимальный размер потока.
То есть тут как бы тоже все кажется нормально.
Ну и наконец третий пункт.
Давайте сравним третий пункт с пунктом, который у нас был в определении обычного потока.
О чем у нас был второй пункт по обычному определению потока?
Значит мы говорили, что ни в какой промежутке на вершине у нас поток не накапливается и соответственно не производится.
И для этого мы записывали вот такой раз.
Мы записывали, что сумма по ребрам, которые исходят из вершины В,
равна сумме потоков по ребрам, которые входят В.
То есть возникает некоторая несимметричность.
То есть мы отдельно должны учитывать ребра, которые исходят из вершины
и отдельно должны учитывать ребра, которые входят в вершину.
В случае симметризованного потока все записывается гораздо проще.
То есть так как у меня теперь каждому исходящему ребру соответствует входящее ребро,
то мне достаточно всего лишь написать, что сумма по всем ребрам, которые исходят из вершины равна 0.
Ну понятно почему, потому что давайте посмотрим.
У меня допустим был какой-то граф.
И у него были какие-то такие потоки.
Так вот я на самом деле утверждаю, что теперь мне достаточно всего лишь учитывать только исходящие ребра.
Почему?
Потому что я знаю, что для каждого ребра у меня есть соответствующее обратное ребро.
И соответственно если в эту вершину у меня входят 2 единицы потока,
то это означает что по этому же ребру у меня исходит 2 единицы потока,
или если минус 2 единиц потока, или если по этому ребру у меня входят 6 единиц потока в эту вершину
то по обратному ребру выходит минус 6 единиц потока.
Ну и соответственно мне теперь достаточно посчитать 5 плюс 3,
минус 2, минус 6.
И, соответственно, условия баланса, условия того, что у меня в никакой вершине не накапливается поток и не производится поток,
собственно, заключается в том, что у меня сумма зарядов, которые исходят из данного узла, из данной вершины, просто равна нулю.
То есть у меня заряды не производятся, то есть не возникают из ниоткуда.
И поток в вершине тоже не возникает из ниоткуда. Вот такие дела.
Понятно определение симметризованного потока?
Понятен смысл каждого из трёх пунктов и в целом, для чего они нужны.
В целом, на всё это определение можно смотреть чисто с формальной точки зрения,
что у нас есть некоторая функция, которая, во-первых, антисимметрична, во-вторых, она ограничена, специально ограничена функцией С,
ну и в-третьих, сумма для любой вершины В, сумма по РВУ равна нулю, кроме естественной вершины СТ.
То есть СТ это отдельные выделенные вершины, которым можно генерировать новый поток и, соответственно, принимать в себя поток.
В целом, как мне кажется, тут работает идеальная аналогия с электрическими цепями.
Во-первых, по каждому проводнику, сколько положительного заряда течёт в одном направлении, столько отрицательного заряда течёт в обратном направлении.
Плюс в узлах электрической цепи у нас не накапливается заряд, это, соответственно, третий пункт.
Ну а второе, собственно, ограничение просто на пропускную способность каждого проводника.
Так, есть вопросы по определению?
Окей.
Да, ну и, соответственно, первое, про что мы поговорим, это, собственно, как раз таки с помощью симметризованного потока давайте докажем утверждение, которое я анонсировал.
Давайте накажем, что величина исходящего потока в точности равна величине входящего потока.
А напомнили, что величина исходящего потока – это сумма потоков,...
Давайте просто напомним, что эти два подока равны, fundamentals only for enhancing the
Давайте я возьму все возможные пары v и u, все возможные пары вершин, и просуммирую функцию потока вот этих пар.
Я утверждаю, что нам будет равна 0. Почему?
Почему сумма f по всем парам v и u равна 0?
Откуда это следует?
У нас каждому ребру есть противоположное, которое его в ноль уводит.
По первому свойству потока. Для любой пары v и u есть пара v и v. У меня все слагаемые разбиваются на пары f1-2, f2-1, f1-3 и 3-1.
Соответственно они взаимно уничтожатся, потому что у меня поток антисимметричен.
То есть можно считать, что просто по антисимметричности потока.
Теперь я возьму эту же сумму и выделю слагаемые с первой координатой s и с первой координатой t.
То есть просто вытащу соответствующую сумму из этой двойной суммы.
В итоге останется такая сумма, в которой первая координата не равна s и не равна t.
Я утверждаю, что эта сумма тоже равна нулю. А это почему?
То есть если я возьму исходную двойную сумму и выделю из нее все f, которые в качестве первой координаты выступают s или t,
и оставлю только двойную сумму без первой координаты s и t, то у меня тоже останется 0. Почему?
Это будет сумма по всем ребрам, которые входят и исходят из не вершины s и t, а для каждой вершины это 0.
Ну да, то есть можно написать вот так.
Можно взять в скобке и сказать, что для любого слагаемого отсюда, то есть любое слагаемое, которое указано в скобках, оно равно нулю. Почему?
А это просто по третьему свойству.
То есть если первая координата не равна s или не равна t, то сумма по всем u, fvu, равна нулю.
Но окажется, что у нас тут ровно это написано. То есть это вот третье свойство.
Отлично. То есть у нас в итоге осталась сумма по всем su и сумма по всем tu.
По всем возможным u.
Ну и соответственно, чтобы завершить доказательство, что нужно понять, нужно понять, что fsu, точнее,
ну короче говоря, я утверждаю, что на самом деле мы уже все доказали.
Почему? Потому что у нас есть вот такая вот сумма, и эта сумма равна нулю.
Но окажется, это ровно то, чего мы хотели.
То есть единственное, тут можно поменять местами координаты и получить вот такую штуку.
То есть из этого следует, давайте допишем, сумма fsu всевозможным u равна сумме fut всевозможным u.
Но это, кажется, ровно то, чего мы хотели.
Величина исходящих потоков точно все равно величине входящего потока.
Ну вот.
Ну вот.
Так, вопросов нет, да? Все хорошо.
Окей.
Идем дальше.
И, соответственно, давайте вернемся к алгоритму.
Вот мы ввели симметризованный поток.
Даже с помощью понятия симметризованного потока доказали.
Но остается непонятным, что изменилось.
Почему понятие симметризованного потока позволяет нам, скажем так, решить исходную задачу простыми способами?
Вот на самом деле утверждаю, что я могу оставить тот алгоритм, который мы обсуждали в самом начале, без изменений, вообще никак.
Всего лишь ведя понятие симметризованного потока, и при этом мы получим хороший алгоритм, который будет решать нашу исходную задачу.
Давайте посмотрим как.
Ну вот, соответственно, я изобразил то, что было у нас до этого.
То есть у нас снова есть граф с простыми способностями 1, 1, 1, 1, 1.
Ну и плюс дополнительно я нарисовал еще обратные ребра.
То есть для каждого ребра.
Точнее, я нарисовал еще несуществующие ребра в обратном направлении.
Теперь пропускную способность 0.
Любимый Another.
вкусноvisee illness()
по этому ребру, пустил поток
Вот нашёл какой-то путь
пустил по этому пути ручеёк
сам поток написан красным цветом
при этом обращу внимание, что
если в прямом направлении течёт единиц потока, то в обратном течёт минус единица
тут течёт к прямому направлению единиц потока
в обратном направлении минус единица
вот have и так далее
Напоминаю, до этого, без симметризации потока, мы на этом просто останавливались и говорили,
что в нашем графе больше нет никакого пути. Давайте вернемся и покажем, что мы изобразили какой-то поток.
И, соответственно, на этом останавливались и говорили, что в этом графе больше нечего добавлять,
поэтому, соответственно, алгоритм останавливается. А вот в этом новом графе, в случае симметризованного потока, это не так.
Потому что в этом графе я могу пустить еще дополнительный поток. Давайте подумаем, какой.
Смотрите, во-первых, из S я могу пустить поток вот по этой дуге.
Почему? Потому что профессиональная способность этой дуге равна 1, а по ней сейчас счет 0.
Поэтому по ней я еще могу пустить дополнительную единицу.
Теперь находимся вот в этой вершине. Давайте подумаем, могу ли я куда-то двигаться из этой вершины.
Смотрите, поэтому рибро я двигаться не могу, потому что это рибро заполнено.
Поэтому рибро я двигаться не могу, потому что оно в другом направлении.
Но, смотри, теперь я могу использовать вот это рибро внезапно. Вот это фиктивное рибро.
Почему я могу его использовать? Потому что его профессиональная способность равна 0, но по нему сейчас течет минус 1.
Согласитесь, что я к минусу единицы могу добавить еще единицу потока, и все равно я не буду превосходить 0.
У меня теперь появилась возможность как бы исправить старый поток.
Сверху вниз я пустил поток, но мне он не нужен.
Вот у меня самый алгоритм в итоге подсказал мне, что давай-ка я опущу поток снизу вверх и убью этот поток, который течет сверху вниз.
То есть, грубо говоря, просто скажу, что вот этот поток в середине мне просто не нужен.
Ну и, соответственно, вот тут, понятно дело, тоже могу пустить единицу потока.
Ну и, соответственно, что вот тут происходит? Тут теперь течет единица потока в обратном направлении минус 1.
Тут теперь течет ноль потока, и тут теперь течет ноль потока.
Почему? Потому что я снизу вверх пустил единицу потока, минус 1 плюс 1 ноль, а 1 минус 1 тоже ноль.
Здесь я пустил единицу потока, тут минус единица.
Ну и вот, соответственно, если вы посмотрите, то все ребра разбиваются на пары.
То есть поток антисимметричен, то есть если в одном направлении течет единица, то в обратном минус единица.
Ну и при этом все потоки, они не превосходят пропускной способности каждого ребра.
И при этом, смотрите, действительно мы получили поток максимальной величины.
Давайте, кстати, убедимся, что в этом графе больше ничего дополнить нельзя.
Давайте просто посмотрим и попробуем что-то добавить.
Ну, смотрите, вот сюда я ничего добавить не могу, потому что тут уже ребро заполнено.
И вот поэтому ребро тоже пустить ничего не могу, потому что тут все заполнено.
Ну все, как бы ничего дополнительного пустить не могу.
И плюс, действительно, я получил поток максимальной величины.
Вот.
Пример понятен?
Понятно, как нам тут могла симметризация потока.
То есть, грубо говоря, симметризация нам помогла тем, что у нас появились эффективные ребра в обратном направлении,
с помощью которых мы как раз и можем исправлять старые плохие пути.
Да, какой-то вопрос был?
Кажется, все понятно.
А, ну окей, отлично.
Все понятно, да.
Да, ну единственное, ну все понятно, я надеюсь, про пример, да,
потому что, на самом деле, даже тут не очень понятно.
Ну хорошо, вот я привел конкретный пример, да, когда у нас было все плохо.
И вот привел конкретный пример, когда у нас стало все хорошо.
С помощью симметризации мы смогли найти в данном конкретном графе оптимальный поток.
Но вообще говоря, непонятно, почему это работает всегда.
Ну а что, если я смогу привести еще пример, в котором даже это не помогает?
Ну, на самом деле, не могу, потому что есть соответствующая...
Ну да.
Короче, план, на самом деле, алгоритм.
Давайте еще раз напомню алгоритм.
Алгоритм очень простой.
Действуешь одним образом.
Просто ищете произвольный путь.
Пускайте поток.
Ну, пускайте ручеек.
Снова ищете какой-нибудь путь.
Пускайте ручеек.
Ну и так далее, пока вы можете найти путь.
Как только вы пути найти не можете, то это означает, что вы, по сути, решили задачу.
И вот, собственно, главный вопрос, а почему это...
Ну, почему, если вы не смогли найти путь, почему вы на самом деле решили задачу?
Почему же один алгоритм действительно работает?
Ну, соответственно, давайте разбираться.
Ну, то есть сейчас мы переходим к тому, что мы докажем утверждение о том, что действительно все работает так, как надо.
И отсутствие дополнительных путей действительно будет давать нам правильный результат.
Ну, давайте докажем лему до перерыва, а после перерыва, соответственно, перейдем к утверждению.
В общем, перерыв будет.
Так, давайте ведем несколько определений.
Значит, первое определение – это остаточная сеть для графа G.
Остаточная сеть для сети G и потока F называется сеть с теми же самыми вершинами,
возможно, с другим набором ребер и другой пропускной способностью,
в котором пропускная способность ребер просто равна исходной способности минус текущий поток.
Короче говоря, все довольно просто.
Вот у меня был исходный граф G или исходная пропускная транспортная сеть G.
Черным цветом обозначены исходные пропускные способности.
Красным цветом обозначен текущий поток.
Что такое остаточная сеть?
Остаточная сеть – это просто-напросто некоторые новые графы,
в котором на ребрах написано, сколько еще поток я могу пустить по этому ребру.
Вот у меня есть ребро пропускной способностью 3 по которому течет поток 1.
Что это означает?
Это означает, что в остаточной сети будет тоже самое ребро, но с пропускной способностью 2.
Это означает, что в остаточной сети будет обратное ребро с пропускной способностью 1.
Почему?
С歷olt мы сами же понимаем, что есть эффективное ребро,
по которому течет минус 1 dagegen из-за пропускной способности в 0.
Это означает, что в обратном направлении, я могу пустить 1 — с потока.
Давайте посмотрим вот сюда. В исходном графе у меня пропускная способность 5, и в этом направлении
у меня уже течет 2 единицы потока. Что это означает? Это значит, что в остаточной сети у меня будет
это ребро с пропускной способностью 3, и в обратном направлении будет ребро с пропускной способностью 2.
Остаточная сеть – это просто-напросто сколько еще поток я могу пустить по этому ребру, и все.
Когда я говорю про остаточную сеть, я просто-напросто говорю про граф,
в котором, соответственно, у меня уже, грубо говоря, обновились пропускные способности.
Ну и, соответственно, арифметика потоков. Мы с вами говорили про ручейки всякие,
про то, что мы ищем какой-то путь, добавляем поток графа и так далее. Давайте, собственно,
докажем, что мы действительно можем взять два потока и сложить их. И более того,
можем взять два потока и вычесть один поток из другого. Арифметика потоков.
Потоки можно складывать и потоки можно вычитать. Первая лемма. Пусть у меня есть f-поток в g и h-поток
в остаточной сети g. Вот на это прошу очень сильно обратить внимание. Смотрите, арифметика потоков
работает только тогда, ну точнее, сумма потоков работает только когда у меня f.
Это поток в исходной графе g, а h это поток в остаточной сети от f.
То есть f- это поток в исходной сети, h- это поток уже в остаточной сети.
Вот тогда, если у меня f-поток в g, а h-поток в gf, тогда f, плюс h... Ну просто-напросто
арифметическая сумма по координатам, то есть просто арифметическая сумма двух
будет являться потоком в исходном графеже и при этом величина этого потока будет
просто равна сумме величин двух потоков. давайте еще раз f в графеже плюс h в графеже f
равно потоку f плюс h в графеже. если у вас уже есть какой-то готовый поток в графеже и вы
к нему добавили вот этот вот самый дополнительный ручеек h, то получите нормальный поток в графеже.
доказательства просто по определению. что проверить по определению, нужно проверить
выполнение трех свойств. ну первое свойство это свойство антисимметричности. ну я думаю оно очевидно.
то есть так у меня функция f и функция h они антисимметричны, ну так как f является потоком
и h является потоком, то f и h они антисимметричны, соответственно их сумма тоже антисимметрична.
вот я думаю все очевидно. вот дальше. теперь нам нужно проверить, что f плюс h,
и так напишем, что f в плюс h в будет меньше равно, чем c в любой пары в. вот мы то, что этот поток
не будет превосходить пропускной способности для каждого ребра. тоже доказывается очень просто.
у нас есть вот такое условие. откуда это следует? это следует из того, что у меня h это поток в gf.
так как h это поток в gf, то значит его величина для каждого ребра не превосходит вот такой
пропускной способности. то есть напоминаю, что в gf у меня пропускная способность c минус f.
c минус f это пропускная способность графа gf. ну и все. я теперь вычитаю и переношу в левую
часть и получаю, что f плюс h меньше равно, чем c. ровно то, чего я хотел. ну и треть свойство тоже
очевидно. мне нужно показать, что для всех промежутных вершин сумма исходящих потоков равна нулю.
ну очень просто. давайте просто просуммируем f плюс h от vu. так у меня сложение ассоциативно.
я могу сначала сложить все f, а потом сложить все h. но так как f это поток и h это поток,
то сумма всех f равна нулю и сумма всех h равна нулю. соответственно сумма тоже равна нулю.
ну вот мы просто тупо проверили все по определению и получили результат. все понятно.
то есть тут важные, даже нельзя сказать не самые сложные и так далее, просто самое важное тут
это понять условия. понять условия леммы. что нельзя просто взять два потока из графа и
сложить их. у вас обязательно один поток должен быть в исходном графе, а второй поток должен
быть в остаточной сети от этого первого потока и только тогда их можно сложить. просто взять два
потока произвольных и сложить их нельзя. но я думаю вы понимаете почему. дайте не знаю, самый простой
пример приведем. вот у меня есть s, вот у меня есть t и пусть тут профессиональная способность равна единице.
и соответственно вот у меня f просто равен. я не могу просто так взять и сказать что f
плюс f это поток. почему? потому что f плюс f это не поток. потому что если я возьму f плюс f,
то у меня получится что вот тут будет протекать 3 единицы потока, а это запрещено. вот это вот так
делать нельзя. поэтому просто взять произвольного потока и сложить я не могу. у меня обязательно
должен быть поток f в исходном графе и плюс должен быть поток в остаточной сети. то есть, грубо говоря,
краски это самый ручеек, про который мы говорили все это время. что вы пускаете дополнительный поток
и вот этот дополнительный поток краски ищете уже учитывая начальный поток. ну и лемма 2 оказывается
аналогично про разность потоков. вот тут условие уже чуть другое. пусть f1 и f2 это потоки в g.
то есть f1 и f2 это потоки именно в исходном графе g. тогда их разность f2 минус f1 будет
потоком в графе gf1. снова f2 поток в графе g минус f1 поток в графе g. и в итоге я получаю поток f2
минус f1 в графе gf1. то есть в графе, у которого пропускные способности записаны с учетом
потока f1. доказывается абсолютно аналогично. тоже просто-напросто в лоб проверяются
вот эти самые три условия. вот вопросы.
все понятно.
так ну отлично. давайте тогда сделаем перерыв 5 минут. до 16 часов и потом продолжим.
продолжим. и собственно вот на основе понятия о синтезованном потоке и о понятии об арифметике
потоков. то есть 5 минут назад мы говорили про сложение потоков, разность потоков. вот на основе
краски этих утверждений можно построить сразу большое количество алгоритмов. и первый
классический из них алгоритм порда палкерсона, который мы на самом деле уже, можно сказать,
обсудили. потому что он устроен довольно просто и устроен жадным образом. так как мы знаем,
что потоки можно ассумировать, то из этого следует довольно-таки простой алгоритм. для начала мы
говорим, что изначально у нас поток это просто обсуждательственный ноль. поток для каждой
пары вершин равен нулю. то есть нигде он не протекает. дальше берем остаточную сеть. на самом
деле строить, как вы понимаете, остаточную сеть не обязательно. достаточно просто-напросто
учитывать, чем остаточная сеть отличается от исходной сети. то есть просто-напросто она
отличается величной способностью. если в исходной графе у меня пропускная способность это c,
то в остаточной сети пропускная способность c-f. то есть у меня просто-напросто достаточно
соответствующим образом учитывать пропускную способность. если у меня по ребру уже течет поток
2, то соответственно пропускная способность уменьшается на две единицы. для формальности
я буду говорить, что мы ищем остаточной сети или в графе с измененными пропускными способностями,
я ищу путь из источника восток. при этом понятное дело, что путь я могу искать только вдоль
ребер, у которых все еще есть положительная пропускная способность, по которым я действительно
могу этот поток пустить. и этот путь можно искать с помощью dfs. алгоритм форда фалкса предлагает
искать этот путь с помощью поиска в глубину. понятное дело, что с помощью поиска в глубину вы
можете найти путь из одной вершины в другую. и соответственно после того, как вы нашли путь,
вот есть источник s здесь ток t нашли путь. допустим тут пропускная способность 7, тут
пропускная способность 5, тут соответственно 8 и так далее. и соответственно вот вдоль этого пути
вы можете пустить величайший поток равным минимуму из MercedesX disposNT на этом пути. понятное дело,
что пропускную способность 8 вы пустить на этом пути. не можете сеть все. потому что у вас есть
рябро, по которому вы можете пустить только величину потока равной 5.
Вы вдоль этого пути пускаете поток, равный максимально возможной величине.
Соответственно, и соответствующим образом обновляете ваш текущий поток.
То есть вы по каждому рябру пустили 5 емец потока, и соответственно обновляете ваш текущий поток f.
Повторяете алгоритм, берете полученуостаточную сеть, пускаете в нем DFS, ищите какой-то путь,
снова по этому пути пускаете поток максимальной величины, и так далее,
продолжаете до тех пор, пока у вас существует путь из SFD.
Я не сказал, но путь, который мы нашли на шаге 2, этот ручеек, который мы говорим,
он еще называется дополняющим путем. То есть мы итеративно ищем дополняющий путь, пока этот путь на самом деле находится.
Ну и как вы понимаете, соответственно, сложность этого алгоритма равна вот такой величине.
Почему такой? Потому что DFS работает в целом за V плюс E,
но тут я член с V опускаю, потому что считаю, что изолированных вершин у нас все-таки в графе нет.
Поэтому количество рябра, хотя бы как минимум, равно количеству вершин.
Поэтому соответственно, сложность алгоритма это E умножена на величину максимального потока.
Почему? Потому что в худшем случае вы просто к пот elку приближаетесь по одному шагу.
Увеличиваете поток на единицу, потом снова увеличиваете поток на единицу, потом снова на единицу,
и так далее, до максимального потока. Но это понятное дело в худшем случае.
Поэтому algorithm работает за E, умнож
на величину максимального потока. И это на самом деле не то, чтобы очень хорошо,
а в том смысле, что, вообще говоря, строго говоря, этот алгоритм нельзя назвать полинамиальным.
Почему? Потому что все-таки полинамиальные алгоритмы считаются алгоритмами, которые работают за полином от входных данных.
А тут мы не можем каким-то образом ограничить время работы какой-то функции от начальной конфигурации графа.
То есть у нас время работы зависит от ответа.
То есть нам нужно предъявить какую-то функцию, которая бы зависела только от характеристик исходного графа.
То есть, например, от количества ребер, от количества вершин и так далее.
Но, к сожалению, ничего более хорошего в алгоритме Порда-Павловича нам предложить нельзя.
Вот такая вот оценка.
Но мы рассмотрим алгоритмы, которые будут давать более оптимистичные оценки независящие от того, что мы делаем.
Так, алгоритм ясен.
Ну и, соответственно, все, что нам осталось доказать, это то, что...
Давайте докажем, что если мы действительно не сможем найти дополнящий путь, то это, по сути, означает, что мы уже нашли максимальный поток.
То есть из дополнящего пути мы не можем найти в том и только в том случае, если мы уже нашли поток максимальной величины.
Ну, собственно, теорема Порда-Павловича на правом на это утверждает, что поток в сети G максимален тогда и только тогда, когда в сети GF просто-напросто нет дополнящего пути.
Ну, давайте доказать это очень просто.
Опирается просто-напросто на алемы оба арифметики потока.
Начинаем докажем одну сторону.
Вот и закажем, что если поток в сети G максимален, то в нем нет...
То в нем мы уже никак не сможем найти дополнящие пути.
Ну, давайте предположим противное.
Вот, допустим, F это максимальный поток в G и в GF мы смогли найти некоторый дополнящий путь H.
То есть, допустим, мы смогли построить еще один ручей.
Тогда, что это означает?
Ну, это означает, что мы можем воспользоваться алемой о сумме потоков и прибавить к текущему потоку поток H.
Смотрите, F это поток в G, а H это, получается, мы нашли новый поток в дополнительности GF.
Ну, соответственно, мы можем их сложить.
Вот, мы их складываем, получаем некоторый новый поток в G,
и при этом величина этого потока равна величине потока F плюс величине потока H.
И при этом она строго больше, чем величина потока F.
Почему? Ну, потому что H – это некоторый дополнящий путь.
Да, дополнящий путь проходит только по ребрам с положительной профессиональной способностью.
Ну, это значит, что мы по нему можем пустить какой-то не отрицательный, не точнее, строго положительный поток.
Но тут мы сразу же приходим к противоречию.
Почему? Потому что по условию мы говорили, что F – это максимально возможный поток в графе G.
Поэтому противоречия.
Все, соответственно, никакого дополнительного пути в графе GF мы найти не могли.
Собственно, поэтому если поток в графе G максимален, то дополнящего пути нет.
Ну, теперь давай докажем в обратную сторону.
Верно ли, что если мы не смогли найти дополнительные пути, верно ли, что в этом случае поток максимален?
Ну, соответственно, давайте доказывать.
Отказать тоже простое и тоже опирается на лему об 잘 Communication потоков, но только уже на лему разности потоков.
Ну, ну, соответственно, давайте рассмотрим просто некоторый максимальный поток.
То есть мы сказали, что мы нашли какой-то поток F, для которого нет дополнящего пути.
Соответственно, мы не знаем, максимальный он или нет, но давайте просто рассмотрим какой-то максимальный поток.
Вот просто возьмем какой-то максимальный поток, про который мы еще ничего не знаем.
Соответственно, что можем сделать? Давайте построим разность этих потоков.
Построим разность к максимальному потоку и того потока, который мы нашли.
Полемия о разности потоков. Этот поток будет как раз потоком, заполняющим сети GF.
При этом, что мы еще знаем?
Мы знаем, что величина разности этих двух потоков будет равна просто арифметической разности величины этих двух потоков.
Но эта величина потока больше либо равна нуля. Почему? Потому что F, Fmax – это предположение максимальный поток.
Но с другой стороны, что мы знаем? Мы знаем, что в потоке GF мы вообще, говоря, никак не можем найти дополняющего пути.
А если в потоке GF мы не можем найти дополняющего пути, то это означает, что эта разность никак не может быть положительной.
Почему? Потому что если бы эта разность была положительной, то мы бы так сказали.
Вот есть разность между Fmax и F, и этот поток имеет положительную стоимость.
Значит, это дополняющий путь в GF.
А мы сказали, по предположению, что у нас в GF нет дополняющих пути.
То есть это означает, что у меня величина разности потоков меньше равна нуля.
То есть что мы получаем? Мы получаем, что с одной стороны Fmax минус F больше равна нуля, а с другой стороны мы получаем, что Fmax минус F меньше равна нуля.
Но кажется, что из этого следует, что как раз как у меня Fmax, точнее, величина потока Fmax совпадает с величиной потока F.
Но это означает, что F – это поток максимальной величины.
При этом заметьте, что я не доказал, что у меня Fmax строго равен F.
То есть я не доказал, что функция Fmax равна функции F.
Нет, я просто доказал, что величина потока F совпадает с величиной максимального потока.
Ну соответственно, по определению F – это максимальный поток.
То есть на самом деле в графе не обязательно единственный максимальный поток.
Таким образом я доказал, что какой-то максимальный поток, возможно отличающийся от Fmax, я нашел.
Но, так или иначе, этот поток имеет максимальную величину, максимально возможную величину.
Так, тут есть вопросы?
Ну вот, таким образом мы рассмотрели простейший алгоритм поиска потока максимальной величины.
Это первый алгоритм.
Но, соответственно, хорошая новость заключается в том, что все, что существует целая рослик алгоритмов, которые основаны на вот этой теореме for-default.
В общем, с помощью этой теоремы доказывается корректность произвольного алгоритма, который мы будем рассматривать в нашем курсе.
То есть вот сейчас мы будем рассматривать еще кое-какие, соответственно, алгоритмы поиска потока максимальной величины.
И, собственно, я сразу говорю, что все эти алгоритмы, которые мы рассмотрим в ближайшее время, они опираются вот ровно на эту теорему.
В чем может быть разница до алгоритма?
То есть на самом деле алгоритм довольно прост.
То есть что утверждает эта теорема?
Теорема, грубо говоря, утверждает следующее, что вы просто таким-то образом ищете дополняющие пути.
Ищете их до тех пор, пока они ищутся, пока у вас есть какой-то дополняющий путь.
И вся разница с алгоритмом заключается в том, а каким образом я все-таки ищу дополняющий путь.
То есть алгоритм for-default лично предлагает искать дополняющий путь с помощью алгоритма DFS.
Но на самом деле дополняющий путь можно искать и другими способами.
С помощью каких-то других алгоритмов поиска пути или каким-то более умным способом.
Давайте их рассмотрим.
Следующий алгоритм — это алгоритм Edmond-Scarpe.
И самый прикол в том, что алгоритм Edmond-Scarpe отличается от алгоритма Forth Bellman.
Уберем.
Тут стоит BFS.
То есть алгоритм Edmond-Scarpe отличается от алгоритма Forth Bellman всего лишь одной деталью.
Точнее одной буквой.
Это вот наречим буквы B вместо буквы D.
То есть алгоритм Edmond-Scarpe абсолютно точно такой же, как алгоритм Forth Bellman.
Но вместо алгоритма DFS есть алгоритм BFS.
Как и алгоритм Forth Bellman.
Но вместо алгоритма DFS в качестве поиска дополняющего пути он использует алгоритм BFS.
Ну, почему алгоритм?
То есть чем отличается алгоритм BFS от алгоритма DFS?
Ну, алгоритм BFS просто ищет дополняющий путь с наиболее короткий, наиболее короткий, рёберный, наиболее рёберно-короткий дополняющий путь.
Дополняющий путь с наименьшим количеством рёбер.
И всего лишь вот такое изменение одной буквы, всего лишь изменение алгоритма DFS на алгоритм BFS,
приводит к тому, что сложность алгоритма, я напомню, что у меня алгоритм Forth Bellman работал за E умноженное на модуль на величину потока F.
А вот алгоритм Эдман Сакарпа, соответственно, гарантирует, что он найдет решение за VL умноженное на E квадрат,
причем вне зависимости от величины потока.
Ну, собственно, давайте покажем, почему так, почему, соответственно, замена алгоритма DFS на алгоритм BFS приводит к тому,
что у меня, соответственно, сложность алгоритма меняется вот таким вот кардинальным, можно сказать, образом.
Начну.
Для начала нам нужно доказать лему, давайте докажем тоже, почему это полетело.
Вёрска, ну ладно.
Давайте, чтобы не смущало, напишу.
Откручивается.
Откручивается.
Появляется.
Значит, в чем состоит лемма?
Лемма заключается в следующем. Ну, смотрите, как работает алгоритм.
Ну, вот я инициализирую, то есть сначала у меня поток равен нулю,
дальше, соответственно, я запускаю алгоритм BFS, ищу какой-то путь из источника в сток,
дальше, соответственно, обновляю мой поток и снова ищу с помощью BFS путь из источника в сток, ну и так далее.
И вот утверждение краски заключается в том, что после каждой итерации алгоритма,
то есть на каждой итерации поиска пути из источника в сток,
то у меня реберная длина пути от источника в сток не уменьшается.
То есть, грубо говоря, если я на первой итерации попытался найти путь из источника в сток
и нашел путь длины 3, ну длины 3 в смысле проходя по трем ребрам,
то на следующей итерации я не смогу найти путь равный 2, то есть либо 3, либо 4, либо 5 и так далее.
На следующей там 5, 6, 7. То есть у меня длина реберного пути из источника в сток всегда не уменьшается.
Ну и в какой-то момент, естественно, надо достигать своего максимума, и в какой-то момент просто я пути найти не смогу.
Давайте, собственно, поймем, почему это так.
Ну, все, на самом деле, довольно прозаично и довольно просто.
Ну, давайте посмотрим вот на эту конфигурацию.
Вот, допустим, у меня был такой граф, да, вот тут ребра граф изображены черным цветом,
и, допустим, вот вдоль этого пути, вот, соответственно, допустим, вдоль этого пути я смог найти дополнящий путь величины 3.
Вот, что у меня, да, ну и, соответственно, после этого я обновляю свой поток и обновляю старшую сеть.
Что в итоге у меня произойдет? Ну, смотрите, что у меня может произойти.
Во-первых, у меня существует ребро, которое из графа исчезнет, ну вот оно.
Почему? Потому что это ребро я запомнил полностью, то есть у него прописанная способность равно 3, я полностью его заполнил.
Какие-то ребра у меня остались, ну, вот 다른 ребра два, вот это ребро, вот это ребро, вот это, вот это,
то есть вот эти ребра у меня они остались, да, так они заполнены, так они заполнены Мне до конца.
А какие-то ребра у меня появились. Вот этого ребра раньше не было,
то есть тут была парусная способность равную нулю.
Но так как я в прямом направлении пустил поток равной 3,
то теперь у меня в обновленном графе появился обратный ребро,
в котором я могу пустить дополнительный путь.
То есть у меня может произойти всего лишь две вещи.
На самом деле три, но третье – это то, что у меня ребра не меняются.
Но это нас не интересует.
Глобально может произойти две вещи.
Первое – у меня может исчезнуть ребро вдоль пути.
Я нашёл какой-то короткий путь, и вдоль этого пути у меня может исчезнуть какое-то ребро.
А второе, что может произойти – это у меня есть короткий путь,
и на этом пути может появиться обратное ребро, то есть ребро в обратном направлении.
То есть зафиксировали.
Я с помощью BFS нашёл какой-то короткий реберный путь,
и дкcakes пос><лиIG рв crabbrotherb.
Дополнительно опустил по нему дополнительный подог,
и всё, что может пройти на этом пути, это либо ребра могут не измениться,
во-вторых, какие-то ребра из источника в сток могут исчезнуть,
а какие-то ребра, которые идут наоборот из стока в источник, могут появиться.
Так вот, в чём утверждение?
Утверждение заключает в том, что ни удаление ребр не может укоротить этот путь.
ну, в смысле, количество ребр, никак не может стать короче.
И это довольно понятно почему.
Ну, снова тут все поехало, но давайте проще поступим.
Удаление, удаление, добавление.
Почему это так?
Ну, с удалением все довольно просто.
Вот у вас был какой-то короткий путь, у вас есть короткий путь.
Вот отсюда, вот сюда.
И вы вдоль этого пути удалили ребро.
Но согласитесь, что путь, короче, никак стать не мог.
То есть удаление ребер никак не может привести к корачиванию пути.
Поэтому это очевидно.
А теперь второй момент.
Вот представьте, у вас был короткий путь.
Ну, допустим, у вас есть короткий путь от общаги до НК, до ЛК.
И, собственно, представьте себе, что вам построили еще одну дорожку,
которая ведет, наоборот, в обратном направлении.
Ну, не знаю, как это так получилось, что она односторонняя.
То есть, наоборот, укротиться ли от этого ваш путь от общаги до ЛК?
При условии, что вы до них ходите.
Ну, в общем, укротиться этот путь или нет?
Ну, нет.
Понятно, что он не укротится.
Почему? Потому что вам в обратном направлении двигаться не нужно было.
Ну и формально это тоже можно показать.
Ну, вот пример.
Пусть у меня был какой-то короткий путь из С до У.
Ну, и представьте себе, что у меня вот это вот ребро исчезло.
Да, и появилось...
Точнее так, оно не исчезло, конечно.
Вот представьте себе, что у меня появилось обратное ребро.
Откуда В? Вот.
Мог ли у меня путь до В стать короче?
Ну, давайте подумаем, как он мог стать короче за счет этого ребра.
Ну, за счет этого ребра он мог стать короче,
только если я сначала дойду до вот этой вершины У,
а потом пройду по этому новому ребру В.
Ну, смотрите, что получается.
Чтобы дойти от С до У, мне нужно пройти вот такой путь.
Ройс У.
А потом за счет единицы дойти до ребра В.
А что я знаю про кратчайший путь до У?
А про кратчайший путь до У я знаю, что, соответственно, он никак...
Он никак не мог стать короче. Почему?
Потому что по предположению, другие ребра никак не изменились.
Поэтому это больше равно, чем Ройс У плюс единица.
И это как раз таки Ро штриха св.
Ну и смотрите, что получается.
Получается у меня следующая вещь, что новый путь от С до В
у меня больше равен, чем исходный путь от С до У плюс 1.
Новый путь от С до У плюс 1.
Но что я знаю?
Я знаю, что кратчайший путь из С до У проходит по ребру ВУ.
То есть это просто означает, что это в свою очередь больше равно, чем Ройс В плюс 1.
Что у меня получилось?
У меня получилось, что есть некоторые новые короткие путь до В.
И он больше равен, чем старый путь плюс 1.
Согласитесь, что он никак не укоротился.
Ну все, соответственно, получили противоречие.
То есть с помощью этого обратного ребра дополнительного у меня путь никак не мог стать короче.
Давайте еще раз проговорю, что у нас есть.
У нас был некоторый исходный кратчайший путь от С до У.
Я хочу проверить, верно ли, что при добавлении такого ребра, например,
у меня путь до В не мог стать короче.
Ну действительно, он не мог стать короче. Почему?
Потому что, ну, давайте посмотрим как.
Это означает, что у меня есть некоторый новый путь до В, который проходит вот по этому ребру.
Почему? Так как это ребро появилось, то, наверное, я должен его как-то заиспользовать.
Ну, соответственно, я пытаюсь его заиспользовать.
То есть я должен каким-то образом, оптимальным образом добраться до У,
а потом сделать плюс один шаг вот по этому новому ребру.
Ну что я знаю?
Я знаю, что кроме вот этого ребра, у меня никакие другие ребра не поменялись.
Поэтому новый путь до У никак, соответственно, не мог стать короче, чем исходный путь от С до У.
Ну а исходный путь от С до У проходил через вершину В.
Ну вот, соответственно, я получил, что новое расстояние от С до В больше равно, чем...
Ну, короче говоря, больше равно, чем...
Ну, кстати, плюс один, на самом деле, уже не играет роли.
Больше равен, чем исходный путь от С до В.
То есть путь явно не стал короче.
Более того, он даже стал длиннее, на самом деле, на две единицы.
Поэтому, соответственно, появление обратных ребер никак не укорочивает путь.
Понятна мысль?
Есть ли вопросы?
Ну окей.
Ну и наконец, давайте, собственно, покажем, что действительно алгоритм Edmund Scarpe работает за побольшое Ве квадрата.
Для этого мне понадобится следующий теорема, который говорит следующее.
Давайте называть ребро критическим, если его насытил поток.
Что значит насытил поток?
Вот у меня было какое-то ребро с пустной способностью С.
Вот, и я по нему пустил поток в точность равной С.
Вот, это, собственно, означает, что ребро стало критическим.
Вот, значит, что ребро стало критическим.
То есть оно просто исчезло из сети.
Но понятное дело, что это ребро, если какое-то ребро стало критическим, то оно стало критическим не навсегда.
Да, почему?
Потому что даже если у меня ребро стало насыщенным, то я в какой-то момент могу в обратном направлении пустить дополнительные 2 единицы потока,
и тогда, соответственно, означает, что в этом направлении потечет минус 2 единицы потока,
и тогда у меня величина потока в этом направлении будет равна c-2.
c-2 будет меньше, чем c.
То есть у меня на самом деле каждый ребро может становиться ограниченным несколько раз.
Допустим, может исчезать, в какой-то момент появляться за счет того, что я могу пускать потоки в обратном направлении, вот так далее.
Но что утверждает терема?
Терема утверждает то, что каждое ребро может стать критическим не более, чем в 1.5 раз.
То есть у меня какое-то ребро может быть насыщенным, потом, соответственно, оно может снова появляться, потом снова насыщаться, снова исчезать, и так далее.
Но такое не может происходить бесконечно количество раз, а именно не может происходить больше, чем в 1.5 раз.
Ну, давайте, собственно, докажем.
Давайте рассмотрим некоторые ребро в ВУ.
И, допустим, какой-то момент стал критическим.
Вот вопрос. Как оно могло стать критическим?
Ну, ребро могло стать критическим только в тот момент, когда оно находится на кратчайших пути от СДУ.
То есть я напоминаю, что алгоритмами Эдман-Скарпа мы пускаем дополнящие потоки или ручейки только вдоль кратчайших путей.
Это значит, что ВУ лежит на кратчайшем пути от СДУ.
Ну, и, соответственно, давайте предположим, что в этот момент времени у меня расстояние до У равно РОСУ,
соответственно, в точности равно РОСВ плюс один.
Почему? Потому что если до РОСУ расстояние минимальное, то, соответственно, и до ВУ у меня тоже расстояние найдено.
То есть путь до ВУ у меня тоже минимальный.
Это значит первый момент времени, когда у меня ребро ВУ, не первый момент, но какой-то момент времени, когда ребро ВУ стало критическим.
То есть в этот момент я ребро ВУ заполнил.
Теперь давайте рассмотрим следующий момент времени. Давайте рассмотрим момент, когда это ребро ВУ снова вернется в мой граф.
Значит, когда это произойдет? А это произойдет только тогда, когда я по ребру УВ, то есть в обратном направлении, пущу какой-то поток.
Ну а что это означает? Что означает, что я по ребру УВ пустил дополнительный поток?
А это означает, что я нашел кратчайший путь от СДВ, который проходит через вершину У.
Да, и вот это, собственно, верно по ЛЕМЕ 1, то есть по предыдущей ЛЕМЕ.
Так как у меня кратчайшие пути не уменьшаются, то новый короткий путь до У больше бы равен, чем старый короткий путь до У.
Ну все, теперь смотрите, что произошло. У меня ребро ВУ стало критическим, исчезло из графа.
Теперь я смотрел момент, когда оно снова появилось в графе.
А появиться оно могло только в тот момент, когда я пустил поток в обратном направлении.
И вот когда я пускал поток в обратном направлении, у меня расстояние до В было равно исходному расстоянию до У,
плюс один. Ну и давайте рассмотрим второй момент, когда ребро ВУ стало критическим.
Что произойдет в этот момент? В этот момент у меня кратчайшее расстояние от С до У будет равно кратчайшему расстоянию от С до В,
плюс один. И у меня будет кратчайшее расстояние от С до В, плюс один.
И у меня будет равно кратчайшее расстояние от С до В, плюс один.
Соответственно, я понимаю, что это больше либо равно, чем Ро штрих СВ.
Снова поле М1. Так кратчайшее расстояние не уменьшается.
А Ро штрих СВ в свою очередь больше либо равно, чем Ро СУ.
Плюс один, плюс один. То есть плюс два.
То есть смотрите, что я получил.
В начале моем тремени, когда у меня ребро ВУ стало критическим, у меня расстояние от С до У было равно Ро СУ.
А в следующий момент, когда ребро СУ стало критическим, у меня уже расстояние было Ро штрих СУ,
которое было как минимум на 2 единицы, больше, чем исходное расстояние от С до У.
Что это означает? Это означает, что между двумя последовательными событиями, когда ребро ВУ становится критическим,
у меня расстояние до У увеличивается хотя бы на 2.
Вопрос, а может ли расстояние до У увеличиваться бесконечно на 2?
Нет, у меня у графе всего V вершин.
то максимальная длина пути графе не больше, чем В.
Но увеличивать расстояние я могу не больше, чем на В.
Но мне каждый раз расстояние увеличивается на 2, то увеличивать это расстояние я могу не больше, чем в bajалом раз.
Ну и соответственно означает, что у меня ребро может быть критическими больше, чем в полном раз.
Потому что между двумя последовательными критическими моментами у меня
расстояние до вершины, конкретной U, увеличивается на 2 единицы.
Вот.
Ну, если совсем коротко, давайте скажем, что первый момент, когда ребро ВУ критическое,
у меня расстояние от S до U, ну не знаю, было равно, давайте скажем, РО.
Во второй момент
расстояние от S до U было больше брано, чем РО плюс 2.
Вот. То есть увеличилось минимум на 2.
Ну и соответственно из этого следует, что ВУ критическое не более, чем в полном раз.
Ну, давайте напишем, что так как РО с U обязательно должно быть меньше брано, чем В.
Ну это очевидно, да.
Так, все в порядке, вопросов нет?
Так, ну окей. Ну и соответственно, давайте на этом подойдем итог, у нас осталось еще пара алгоритмов,
но их мы, собственно, оставим на следующий раз.
Ну а пока давайте завершим анализ алгоритма Эдмонс Карпа, и давайте, собственно, наконец-таки
ну, собственно, докажем, почему у него время работы к краске O от VE2.
Ну, смотрите, да. За сколько работает BFS?
BFS работает за O.
Ну, в общем-то, у нас осталось еще пару алгоритмов, но их мы оставим на следующий раз.
BFS работает за O от E.
Ну, опять же, давайте считать, что у нас нет изолированных вершин и так далее.
Все-таки, если у нас есть транспортная сеть, то она действительно сеть,
то есть у нас всегда вершины связаны и так далее.
Поэтому алгоритм BFS работает за O от количества ребр.
Сколько всего будет итераций?
Сколько всего дополняющих путей найдено?
Ну, давайте проанализируем это так.
Каждый дополняющий путь делает какое-то ребро критическим.
Вот я нашел какой-то путь.
И вот на этом пути обязательно найдется какое-то ребро, которое будет полностью заполнено.
Ну, просто так алгоритм устроен.
Я опускаю путь, я опускаю поток максимально личный, который могу.
Соответственно, у меня обязательно какое-то ребро становится критическим.
Ну вот.
Ну, что я знаю?
Я знаю, что у меня ребро может стать критическим не больше, чем V раз.
V пополам раз.
А сколько у меня всего ребра?
А всего ребра у меня E.
То есть это означает, что у меня общее количество итераций или общее количество дополняющих путей
не может быть больше, чем E умножить на V, деленное на 2.
Согласны?
Ну, смотрите, простое соответствие.
Каждый дополняющий путь делает хотя бы одно ребро критическим.
Я знаю, что каждое ребро может стать критическим не больше, чем V пополам раз.
А всего ребра у меня E.
Значит, общее количество дополняющих путей у меня не больше, чем E умножить на V пополам.
Ну, соответственно, я беру E умножить на V пополам и умножаю на E.
Ну, это как раз идет BFS.
Да, это доп. путей.
Ну, и получаю, соответственно, V умножить на E квадрат.
Ну, пополам еще.
Вот.
Вот отсюда я получил нужную мне асимпточку.
Так, ну, алгоритм делится и алгоритм...
Ну, еще пару алгоритмов мы рассмотрим уже в следующий раз.
Этого, я думаю, пока достаточно.
Остались себе какие-то вопросы.
Может, что-то еще нужно повторить, проговорить?
Так, ну, тогда лекцию по алгоритму мы предлагаем закончить.
Сейчас давайте сделаем перерыв.
Ну, до 15, до без 15, до 16,45.
Вот. И потом, оставшийся, оставшийся сейчас час 2, сейчас 15.
Отсудим вопросы, связанные с C++.
Вот. Перерыв.
Вот.
