Поэтому, как вы уже догадались, обсуждать сегодня будем метод четырёх русских. Да,
но метод на самом деле решает несколько задач. Ну, то есть, конечно, классический пример,
который у нас сегодня тоже будет, это, конечно, решение задачи стать икромку за линейный
предподсчёт и единицу. Но сегодня выяснится, что метод, конечно, решает сильно больше.
Ну, с чего бы нам начать? Давайте начнём с самой простой задачи. Заодно попробуем
поиллюстрировать метод. Это, конечно, перемножение матриц. Давайте себе представим. Наверное,
вам уже не надо объяснять, что такое перемножение матриц, правда? Или у вас этого не было? Ну,
слава богу. А то мало ли. Так, давайте думать, за какую симпатику можно перемножить две матрицы.
Ну, давайте для простоты квадратные. Ну, всякое бывает. Ну, стандарты, если есть перемножать
матрицы прям в честную, то есть n куб. Да, ну, в общем случае, конечно, тут о чём можно думать. Ну,
то хочется как-то побыстрее. Действительно, какие-то технологии есть. Вот, мы сейчас,
конечно, будем обсуждать даже не самоэффективно, но действительно думаем, как бы это ускорить. Но мы
обсудим, правда, такой подвид, как 0,1 матрица. Вот так скажем. Вот давайте себе представим,
что матрицы состоят из 0,1. Вот. И попытаемся их перемножить. Ну, перемножать их будем честно,
даже не булевым образом. Хотя, в принципе, в этом месте говорят, давайте перемножим булевые матрицы,
но, кажется, показательнее будет, если мы перемножим эти матрицы всё-таки как числовые,
хоть они из 0,1. Вот. Значит, за счёт чего мы попытаемся ускориться? Ускориться мы попытаемся за
счёт следующего мистического заклинания, с которым мы будем начинать всё. Заклинание называется
зафиксируем к, который выберем позже. Вот. Ну, то есть, что это означает? Ну, то есть, ничего страшного
на самом деле это не означает. То есть, это означает, что у нас алгоритм будет зависеть не только от n,
но и от какого-то параметра k. А потом мы посчитаем 8-точку в зависимости от k и подгоним
k таким образом, чтобы синтоника была поменьше. Вот. Значит, в чём смысл этого k? А смысл вот в чём.
Вот, на самом деле, смотрите, если бы мы перемножали, допустим, булевые матрицы,
вот представьте, что мы перемножали булевые матрицы по булевому. То есть, что означает
перемножать по булевому? То есть, это означает, что перемножение это типа конъюнкция, а сложение это
типа дезюнкция. Вот. Тогда замечается маленькая интересная вещь. Мы могли бы условно перемножать на,
то есть, как бы там, скажем так, ряд на столбец мы могли бы перемножать не за n, а за что-то типа n
на 32, правда? Ну была бы у нас теоретически такая идея. Правда, мы бы это делали за счёт того,
что у нас в компьютере есть мистические какие-то там булевые операции, которые на 32 бита работают
там за единицу. Вот. Конечно, сейчас у нас такой операции нет. Вот. Но мы можем сделать следующим
образом. Мы будем говорить так. А давайте попробуем научиться перемножать ряд длины k на столбец
размера k за от единицы. Ну, то есть, нацеливаясь, конечно же, на то, что в итоге перемножать матрицы,
но там перемножать матрицы мы будем за, за сколько мы там их будем перемножать, за, получается,
n в кубе делить на k. Вот на такое мы будем нацеливаться. Как же мы это будем делать? Как научиться
перемножать любые два, так сказать, вектора размера k скалярда? Неожиданно просто. Дело в том,
что метод заключается в чём? Мы выберем такое k, что на самом деле векторов размера k будет не
слишком много. А сколько у нас всего векторов размера k, кстати? Да, два степени k. А пар векторов,
соответственно, два степени 2k. Ну да. Ну, мы будем записывать два степени 2k. Впрочем, можно и так,
и так. И действительно, то есть у нас, причём будет у нас такая наглая идея. Давайте переберём все
возможные пары векторов, прям вот предельно честно, за два в степени 2k. Каждую из них за k честно
перемножим и сохраним в таблицу. Вот, и сохраним в таблицу. Вот. Тогда после этого мы делаем вот,
то есть после того, как мы всё это перебрали и сохранили, остаётся только теперь действительно
выполнить честное перемножение и, собственно, всё. То есть теперь уже мы просто берём, получается,
каждую строчку делим на блоки по k. Вот, прям честно по k. То есть каждый столбец делим как-то
вот пока. И, соответственно, теперь каждый блок размера k, ну там, конечно, мы и по каждому,
предварительно по каждому блоку мы, конечно, должны пробежаться и там получить его порядковый
номер. Ну, то есть эту битовую маску записать, по сути. Вот. И после этого оказывается, что вот
любые два блока размера k мы теперь скалярно перемножаем за единицу, просто залезая в табличное
значение. Так что вот такой алгоритм. А теперь остаётся такой, внимание, вопрос. Так какое же k нам
выбрать? Чего? Вот. Ну да. Да. То есть стандартный метод такой. Да. То есть я мог бы просто сказать,
давайте подсунем k равно, я не знаю, корень третьей степени из n, и вот вам алгоритм. Но я не скажу.
Нет, ну я намеренно сказал заведомо неправильный ответ. Вот. Но давайте подумаем. Вместо этого
давайте попробуем повыжимать. То есть подумать, какую максимальную асимптотику мы отсюда можем
выжить. Но, опять, заметим, что у нас есть две составляющие, одна из которых возрастает,
а другая убывает. Но мы знаем, что если у нас в асимптотике сумма, то это то же самое,
что максимум. То есть такое упражнение на один балл могло бы быть. Докажите,
что там f плюс g равно θ от максимума f и g. Звучит как заклинание, но если вдуматься,
ничего страшного там нет. Вот. И тогда теперь получается нам надо, чтобы максимум этой штуки
был как можно меньше. Так, ну тогда смотрите, как же искать этот максимум. Ну тогда и видим,
что поначалу у нас одно убывающее слагаемое больше, потом они пересекаются, после этого вот это там
уже, наоборот, возрастающее слагаемое начинает выигрывать. Это дает нам возможность найти
оптимальное k бинпоиском. Ну примерно. То есть мы, например, ищем асимптотические. То есть, конечно,
в идеале мы могли бы, конечно, написать два в степени 2k на k равно n куб делить на k, но с другой
стороны, конечно, в радикалах это уравнение не уверен, что разрешимо. То есть там написать
там что-то типа, что k равно, и написать прям адекватную формулу не получится. Ну может там
ведется какая-нибудь там функция, какие-нибудь функции типа до ломбера или там что-нибудь еще в
этом роде, но не будем этого делать, нам это в общем-то и не нужно. Но тем более, что даже из точки
зрения практики на самом деле потом выяснится, что совсем такое точное k не надо, потому что тут же
еще константы вообще есть по-хорошему, тогда тут какие-то там c1, c2 надо еще учесть, то есть там,
но поэтому лучше сразу не заморачиваться. Ну вот, а теперь давайте думать, да, но теперь давайте,
но к можно попытаться найти ното симпатически оптимально. Как же мы это будем делать? Ну давайте
просто проверять, там что-то типа бинпоиска. Вот я, например, там что-то уже сказал про корень
кубический из n? Ну давайте думать. Если я подставлю k равно корень кубический из n,
что у меня получится? 2 в степени 2 корня кубических из n умножить на корень кубический из n плюс n в
степени сколько там получается? 8 третьих. Так, что больше? Да, ну как-то, явно, наверное,
левая слагаемость как-то многовато, потому что чтобы она претендовала на полиом, на полином,
тут должно быть что-то логарифмическое, да, поэтому вот, то есть это значит, что это слагаемое,
возрастающее слагаемое деминирует, поэтому пишем, что это много. Так, что можно было бы еще взять?
Ну кто тоже себе-то предложил, давайте возьмем логарифм. Так, что же у нас будет в логарифме? Ну да,
2 в степени 2 логарифма, как известно, это квадрат, то есть n квадрат лог n плюс n куб делить на лог n.
И получается наоборот теперь, вот это слагаемое теперь деминирует,
поэтому получается, что логарифм это мало. Да, но с другой стороны, оказывается, что принципиально
лучше симпатически мы, тем не менее, не выжмем. Почему? Потому что если возьму 3 вторых лог n,
то я получу n в кубе лог n. Ну ладно, там на 3 вторых и плюс там что-то типа 2 третьи n в кубе делить на лог n.
То есть тут наоборот получается много. То есть получается оптимальная k, это где-то между логарифмом
и полуторалогарифмами. То есть получается k надо брать просто θ от логарифма. Ну вот, если взять,
скажем, логарифм, то у нас получается, ну то есть это означает, что это слагаемый уже всегда будет
там n в кубе поделить на лог n. И причем там мы уже знаем, что ровно такую симпатику получить можно.
Ну вывод очень простой, значит получается мы берем там k равно лог n и получаем симпатику
θ от n в кубе поделить на лог n. Ну да. Нет, ну в принципе так оптимизировалось. Нет, ну понятно,
не лучший вариант, то есть конечно не лучший вариант, через битмаски на самом деле было бы
проще, там по n было бы дать. Понятно. Ну это, ну я вам так скажу, да. Я это рассказывал с целью того,
что просто ввести в метод четырехрусских. Это не самое, конечно, яркое применение. Да, конкретно,
что касается этой задачи, забирая вперед, да, что есть, конечно, существенно более быстрая симптотика
и в общем случае. Потому что есть как минимум метод Штрассена, видимо, есть как минимум метод
Штрассена, который работает за от n в степени там, сколько, лог 27. Ну там отдельная песня,
я думаю, видимо, просто видимо на первом занятии следующего семестра, видимо,
обсудим, ну собственно, откуда это берется. Аааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааа
ну нет ну как же задачи по математике да и сделайте за о малые да приват что там
конца до константа жуткая да но это но это нормально да такое бывает шоу гритусы
лукен быстрее алгоритма за энда бывает ну бывает вообще что алгоритмы да жили
были алгоритмы с одной синтетикой но один но один заходит и другой нет ну да что
делать за это даже что же здесь жить такая да как говорите если в жизнь была
математика и называется был бы кайф конечно да вот но здоровься ладно хотя в конце концов
можете хотя при спецпособках что взломать такую лойку потому что никто вас не обещал никто не
требовал писать именно штраса на кстати вот этот подойдет это тоже умалая там в кубе если что
так ну и да есть конечно проблем да только да это работает только нули единиц да но правда
легко заметить в качестве упражнения что есть тут будут числа от нуля такой константы то в
принципе тоже пойдет ну вот но в конце концов ладно чемпионские алгоритмы работают там по
моему за оттен степени два точка если бы 20 нет там 2 3 там что-то да нет там нет но там это там
что-то веселое на самом деле не помню точных цифр но там википедия в этом месте пишет веселые
вещи она говорит что оптимальный алгоритм работает за энд степени там два точка три условно
напишу 5 8 там примерно примерно суть такая это является улучшением метода капельсмита
винограда который работает за энд степени два точка там 2 3 8 4 да вот но отдельная песня как
то в общем не но я вообще не знаю там что там в этих методах то есть поэтому я никак не могу
прокомментировать но вот на чемпионат идет вот такой так же в принципе можете поучаствовать
то есть может у вас получится 2.229 тут сделать я не знаю да нет ну в конце концов знаете вон чем
вот так надо не делить надо вон чтобы степень оптимизировался нет может вам
удастся доказать что матрица нельзя перемножать быстрее чем за энд в степени 2.0001
да если бы нет ну нет насколько мне известно насколько мне известно что
вот пока так доказали понятно что перемножать матрицы можно только за мега тен квадрат все
но как бы это это очевидно добрый день пока не пробовали вот так же в этом смысле так ладно
но это перемножение матриц это отдельная песня но вот в конце концов там пулево перемножение
более во перемножение матриц вообще там там вероятность еще алгоритмы есть на самом деле там
как-то если она да если она если нам повезет то как бы у нас вообще в курсе возникнет просто
такое пафосное словосочетание как свидетели пулева перемножение матриц вот будьте готовы вот да на
полном серьезе так называется да вот на тип ну там но на самом деле да конечно метод
давайте раскрывается немножко в других местах это но вот но это конечно великая задача про статик
рэмку вот давайте вспомним вот у нас есть мистическая задача статик рэмку что это за задача то есть
задача простая дан минимум по дан массив и спасает на произвольных чисел он не меняется сделайте
какой-то предподсчет так чтобы потом на любом подотреске за достаточно быстро находить минимум
вот понятная идея да понятная идея да спрашивается чего нас это приводит да
сколько мы вообще-то умеем решать но у нас есть два способа в онлайне ну статик значит массив не
меняется да массив не меняется только запросы те дают в онлайн то есть нет такого что я там
данные заранее куча запросов может делать не все что хочешь да так конечно нет так конечно кстати
вообще была бы мечта да то есть дан массив и да но куча запросов заранее можно ли как-то
найти минимум побыстрее но да нет соте запросов по координате можно за линию потому что подсчет
нет ну хорошо там там другое другое песня как бы еще тебе это даст скорее нет на самом деле так ладно
если бы давайте так если бы у нас был снм на самом деле да то есть можно за обратную функцию керману
потому что там можно там применять собственно стэк и в листику сжатия путей видимо это имеется
в виду да но да то есть до по фада по факту до до практике наверно лучшего и желать нельзя но
мы попробуем ладно но это конечно если значит такой снм мы пока не знаем да впервые может
быть отчасти потому что может у нас есть мечта даже доказать что снм работать за какой-то
асимптутику в чем какая-то там это не логарифум естественно хотя это тоже будет но вот но пока
у нас значит если брать то что у нас было то у нас как бы есть n log n единица то есть там
спарса спарсы построим за n log n после этого минимум ищете за единицы а есть дерево отрезков ну ну или
там ну или там я не знаю это ваша любимая там овл вот ну или там что там не ваш короче что короче
то что можно там насчитываете за от но зато минимум придется потом залогарифум искать вот
но в принципе да то есть никто ни над кем не доминирует на самом деле то есть надо в зависимости
от количества запросов выбирать вариант вот но мы попробуем конечно это победить то есть нам
конечно хочется побыстрее ну в идеале да вот наша ставка то есть нам очень хочется убить лишний
логарифм сделать чтобы это был n единица будьте здоровы вот но здесь конечно нам принот ну конечно
классический метод требует от нас некоторые цепочки а именно то есть да то есть что что
можно сделать но если кто-то до матрицы вектора были от нуля из нуля единиц то мы догадываемся
что бы делали да ладно пока не догадываемся на неважно но мы пойдем другим путем мы просто
так задачи римку там произвольные какие-то числа ой произвольные числа ой это очень сложно
эти мы просто возьмем эту задачу не эту задачу возьмем и сведем ее к задаче л ца то есть раз
скажем что мы сделаем мы сейчас то есть вместо того чтобы решать задачу римку мы тут потратим
от времени и построим дерево и построим такое дерево в котором нот в котором нот в котором
на самом деле если нам захочется искать минимум в массиве за там между лр то это свернуто то
мы это сможем сделать просто найдя лца в этом дереве у правильно подобранных вершин ну пока
говорю на уровне идеи хотя в прочем поднимите руки кто знает собственно каким образом это
делается и редкий случай на самом деле что только две руки но хотя метод классический абсолютно вот
и так так что теперь мы так что теперь значит у нас что получилось значит теперь получается нам
просто нужно научиться решать задачу статик л ца за предподсчета вот единиц да но у нас уже
есть эпическое сведение л ца к римку потому что мы можем запустить dfs там вот это выписать там
все вот эти числа в общем выписывать когда мы идем вниз когда идем вверх да и потом там сводить вот
вот да казалось бы зачем мы стали действительно зачем мы свели римку к римку ну вот да выглядит
да как-то да как-то словосочетание да да появляется в голове словосочетание огромное количество
словочетаний самым цензурным из которых является имитация бурной деятельности вот но если бы не
одно но заметим что тут мы можем тут мы получим не любой массив а мы получим массив в котором
любые два числа отличаются на единицу и может быть эту задачу мы сможем решить попроще но и
действительно забирай вперед мы ее действительно сможем решить попроще ну как попроще да вот хотя
ладно там ничего сложного не будет но как как мы уже с вами знаем у нас в курсе вообще сложных
алгоритмов нету в принципе так что вот так что видимо да так что видимо да вопрос на отл называется
докажите асимптотику и сыном снизу не просто нет просто вот докажите что ну скажете вот есть
эсэнэм да можно доказать свеку что он работает там амортизировано за обратную функцию кермана так
вот докажите что лучше оценить нельзя ну может там корень из обратной функции кермана мало ли
а вот вот философский опрос там скажем так что-то там в истории были какие-то
будет кто-то кто-то писал доказательства потом потом вроде там
не но нет нет но это и цикла на практике там понятно что да это работает
какой-то функция керма дако трепре адекватных данных не более чем 4 хотя ладно у нас будет
а у нас будет еще более крутая функция которая про адекватных данных не более чем 2 вот нет
просто 4 это если локзвездочка просто обратная функция керма на это еще более медленно растущая
функция там вода 1 вот где-либо там просто разный просто там скажете я думаю крышак
докажут докажут что-то про логзвездочка обычно если доказывают логзвездочка это типа сколько раз
надо числа брать логарифом чтобы получилось меньше единиц вот по основанию двойки ну там
но хотя это хотя это константа если двойку заменишь там на допустим я не знаю восьмерку то как бы
этот лог звездочку увеличится в три раза так что не принципиально но вот то как бы если брать
по двойке то действительно окажется что там не более чем четыре там будет доказательство не
сложное но то есть обратно функция термана там и определение более сложное и собственно доказательство
тоже вот но отдельная песня можно ли оценить это еще лучше но вот на практике конечно понятно что
когда функция не превосходит каких-нибудь там четыре или два то уже не принципиально но но
интересно же и а то когда-нибудь да совсем совсем совсем совсем когда-нибудь может быть
там совсем да совсем в другой жизни даже это в другой цепочке другой цепочке
да ну да да это уже много нужно оптимизировать
почему корень 30
она ну так ладно все понял что наврал-наврал-наврал хорошо но вот но правда по-моему по-моему
принципиально суть от этого по мне поменяется да так вот ладно что мы сейчас делаем но давайте
ладно быстренько давайте вот давайте вот эту дырочку быстренько закроем потому что задача на
самом деле будет идентична по сути следующей то есть как по заданным приоритетам и ключам построить
декартово дерево за линию да мы с вами ну декартово дерево мы так с вами так скользь помещались
что как бы шутку декартово дерево все прекрасно знают вот но вот но этот момент тогда обсудим
подробнее но давайте помните декартово дерево вообще да декартово дерево как мы это такое
сбалансированное это такое двоичное дерево поиска у которого в каждой вершине есть не только ключик
но и приоритет и по ключам этот двоичное дерево поиска а при приитетам куча в нашем случае на минимум
вот но идея тогда будет такая и так допустим вот нам дан вот этот вот массив вот допустим
дан массив то есть что у нас будет там 5 там я не знаю 5 7 9 6 там я не знаю 2 4 8 6 да у нас на
минимум да но не важно можно и на но на самом деле можно нам больше да поэтому поэтому сейчас на
минимум да это важно вот 5 там соответственно ничего не быть еще 8 11 значит идея такая мы
объявим что это приоритеты это у нас приоритеты ключи будут а ключи будут прям честные 1 2 3 4 5 6 7 8 9 10 11
и вот наша задача построить декартово дерево корректное то есть заметьте мы не гарантируем что
оно естественно сбалансировано да то есть как бы если вам дают прессе приоритеты не сгенерировано
рандомно вот дан какой-то массив то конечно вполне вероятно что декартово дерево кажется бомбу
чап вот но тем не менее начинается алгоритм сейчас от этого зависит никак не будет значит он
сделает следующее значит он будет идти слева направо и пытаться добавлять вершины в дерево
даже не пытаться а успешно добавлять как он это будет делать делать будет так вот то есть ну давайте
начнем с того что у нас есть сначала вот этот вот 1 5 ну просто создадим декартово дерево из
одной вершины приходит следующая вершина 2 7 ну а первых заметим кстати что каждый если мы
будем идти слева направо то каждый следующий вершинка должна быть в дереве самой правой
очевидно правда потому что у нее максимальный ключ то есть значит да куда же подвести но заметим
что вот у нас есть самая про старая самая правая вершина 1 и мы знаем что у нее и тут оказывается
приоритет больше но тогда ничто нам не мешает просто взять и ее сюда подвести просто взять
и вот ровно в таком виде подвести 2 и 7 так более того абсолютно также мы поступаем из девяточкой
вот такая вот девять нот да потому что 9 у нас больше чем 7 а вот четверка такой
механизм не работает потому что выясняется шестерочка таки меньше девяточки что в таком
случае делать делать бы все еще мы будем поэтому правом пути идти снизу вверх вот идем идем и
видим что девяточка больше шестерочки семерочка больше шестерочки а пятерочка меньше шестерочки
что же делать тогда как оказывается корректно сделать вот что распиливаем этот переход смотрите
значит значит добавляем нашу шестерочку справа теперь от пятерочки вот у нас тут будет
шестерочка вот такая и а слева от этой вершиночки нот вешаем соответственно семерочку со всем
деревом который тут висит теперь двоечка так теперь мы идем всегда по правом пути поэтому
стартуем с той же шестерочки то есть по сути вы этот правый путь можете условно в стэке хранить
вот это шестерочка шестерочка больше двоечки пятерочка больше двоечки поэтому от чуда мы у
нас объявляется новый корень вот вот примерно так это и работает тут 4 тут 5 так что у нас дальше
но дальше видим шестерки есть четверочка больше двоечки поэтому здесь мы поэтому здесь ну и забираю
вперед в общем-то и вот так вот тоже вот будет и 48 что же будет дальше восьмерочка так восьмерочка
по ключу и шестерочка по приоритету это у нас тут получается вот такая шестерочка вот так ну я
думаю так смысл вы вроде поняли да наверное даже уже нет смысла дорисовывать вот то есть но
в принципе очевидно что он говорит он работает за линию правда ну потому что по сути мы тут
кто-то добавляем что-то один до каждой шаги добавляем один элемент стека перед этим сколько-то
достаем но достаем не больше чем положили туда пользуемся но мы эти ключи в явном виде сгенерировали
у нас от одного до n да редкий случай у нас приоритеты не рандомные да ибо мы вообще задачи
стать крымку решаем да да на самом деле дайся включение были отсортированы то конечно это был
бы кстати метод отсортировать ключи да то есть у вас ну то есть так есть у нас есть абстрактный
метод вакууме построим декартово дерево да тогда по декарту тысячи моего бы умеем строить в
общем случае за быстрее чем за н логан то увы и сортировали бы за н логан но конечно сейчас мы
явно пользуемся тем что ключи отсортированы да но в данном случае возникает вопрос зачем нам
это надо но идея оказывается очень простая если вы хотите найти минимум на подотреске lr в этом
массиве вам просто нужно взять вершины с ключами lr и найти у них лца утверждение в этом лца будет
написан минимум на отрезке вот доказательства очень простое но например потому что рассмотрим
минимум вообще глобальный минимум массиве да заметим что отрезки бывают трех типов которые
слева от минимума справа от минимума и которые через него проходит но если отрезок проходит
через него то тогда у нас получается в качестве lr вершины возьмем вершину слева под дерево корня
и правого под дерева корня лца будет корень ура то есть если на отрезке лежит минимум он будет
найден но теперь переходим с левой справа но это означает что мы переходим в левое правое под
деревой доказываем рекурсивно вот такое вот оказывается очень несложно алгоритм как свести
то есть внимание это он еще не решает задачу стать и крыльку он сможет ее задача статик лца
вот то есть пока это еще конечно это и сыкла так задача так сбежать из тюрьмы для этого нужно
обмануть бдительность охранников осталось только придумать как обмануть бдительных
задача упростилась вот так поднимите руки кто знает откуда это ой ой ой ой как это
сказка гарри потери свела планету с ума сказка о пори гаторе вправит вам мозги да очень рекомендую
да пори гаторе каменный философ там вот это все да не ребята вот я рекомендую не пожалеете
правда там прям трилогия да пори гаторе каменный философ там пори гатор там личное дело делом
эркеоны ну и соответственно 9 подлека сена если да так что прям то есть шикарно то есть это вообще
дайся просто самых вообще смешных вообще вещей которые в жизни читал и замечательно и про
технический прогресс там соответственно и тогда да ладно так ладно вернемся к методу четырех
русских так где он у нас возникнет так ну хорошо илса к рмку плюс минус один повторять не будем
мы уже научились это делать а теперь у нас задача опять же статья к рмку но гарантируется что
но вот но теперь у нас такой получается статья к рмку плюс минус один это означает что мы
пытаемся но что каждое следующее число на один отличается от предыдущего правда мы не всегда
знаем в какую сторону ну то есть вот тут конечно же но вот то есть как бы радуся их может колебаться
как угодно но она это делает непрерывно вот значит как же нам теперь искать минимум да ну как
да как в чем у нас заключается метод четырех русских ну как всегда зафиксируем как которые
выберем позже да то есть давайте начнем привыкать к этому заклинанию да что мы сделаем но у нас
конечно голубая мечта на массивах размера к или меньше научиться искать ответ за от единицы вот
да ну как мы это можем сделать а сколько у нас различных бывает различных массивов размера к
да то есть о формально да формальный ответ на этот вопрос бесконечно много но заметим что с
точностью до прибавления одной вычитание одного этого числа к массиву действительно всего два
в степени к-1 но по большому счету нам чтобы найти позицию минимума нам с абсолютные значения
не важны нам только важно как они изменяются в процессе то есть всего массива получается массивов
размера к у нас два в степени к но асимпатически и за отка в каждом из них можно минимум найти
ну на самом деле там более того на самом деле в эту осим точку можно упихнуть даже поиски
минимума не только на массивах размера к но и на массивах размера меньше к это нам тоже
пригодится ведь запрос может быть и меньше к правда но с другой стороны что это будет два
степени к-1 на к-1 до степени к-2 на к-2 2 степени к-3 на к-3 и так далее но заметим что на самом
деле это просуммировать то асимпатически все равно получится два степени к на к там оставим
в качестве упражнения почему вот хорошо то есть предподсчет делаем за такой предподсчет делаем
на два степени к на к теперь возникает вопрос а как же теперь мне хорошо вот да а если у меня
теперь массив длины больше чем к например n и как же в нем теперь пытаться искать минимумы на
больших отрезках ну вот ну идея это такая давайте поделим этот массив на блоки размера к вот но на
самом деле я утверждаю следующее что если бы нам гарантировалось что все запросы имеют размер
к или более то как и странно это было бы нам на руку и вот этого предподсчета делать вообще не
надо почему а потому что идея такая если запросе есть хотя бы к элементов то на самом деле можно
тогда рассматривать это так то за это любой запрос устроен так он включает себя суффикс
какого-то блока префикс какого-то блока и несколько целиком взятых подряд идущих блоков пока
логично но тогда идея такая давайте на каждом блоке найдем минимум более того давайте внутри
каждого блока найдем минимумы на префиксах и минимумы на суффиксах это там суварна в линию
обойдется правда то есть после этого тогда то есть теперь минимум на префиксе суффиксе минимум
на префиксе мы найдем за единицу остается только найти как искать минимумы на вот этом вот под
отрезке из блоков идея весьма неожиданно а давайте просто и был используем ну пользуясь тем что
целых блоков у нас теперь не n а n делить на к то есть получается предподсчет здесь нам дает n
плюс n делить на к лог n делить на к то есть обратить внимание да то есть вот эта часть нужна только
для одного она на самом деле нам нужна для того чтобы искать минимум на запросы на запросах которые
попадают целиком внутрь блока мелкий только ради этого да еще там конечно нужно там какие
тенд потратить для того чтобы там научиться для любого такого под отрезочек искать его
масочку конечно но но это думаю слишком просто для того чтобы прям отдельно на это это обсуждать
да ну и сами минимумы конечно вот и теперь внимание вопрос какое же к нам подогнать
так но давайте думать да давайте подумать сколько из этого можно выжить кара в нол гори фумен
сколько получается так получается действительно n лог n плюс n плюс смотрите n делить на лог n
лог n делить налога так ну здесь можно сказать шлёп шлёп дай согласен это не совсем прям поровну
но взрослые заметим что логен он больше либо равен чем лог от n поделить нашу угодно правда
но тем более что кстати асимпатически лог n делить налога н и лога н это одно и то же но
потому что это что-то типа логен минус лог лог и налог лог и на то мало вот да согласен
действительно так так скучно что можно заснуть действительно вот вот но видим что тут у нас
получается n а тут n лога поэтому получается много но с другой стороны без потери без особых проблем
на самом деле убил вот убить здесь n лог n очень просто надо просто взять ну классики говорят а
давайте скажем что у нас кара в до логен пополам что тогда получится два в степени логен пополам
это сколько корень из н совершенно верно то есть корень из н лога n а это меньше чем м да
собственно вы уже продвинутые люди даже наверно умеете доказывать вот ну я не знаю там может это
потом как-то помогут там все какие там правила лопиталя там какие-нибудь вот эти все ну там
доказать ну там сериям а да доказать что там там логен поделить на корень из н стремится к нулю да
при н стремящимся к бесконечности да там эти типа там плюс бесконечности плюс бесконечности давайте
применим правила лопиталя там блаблаблаблаблаблаблабла в общем никаких проблем вот если к экзамену
по матанальзу это не будет блаблаблаблаблабла то я боюсь вы вылететь если что вот это соответственно
я но вот значит здесь получается так здесь плюс n здесь тут получается уже там 2n поделить на
логен тут налог тоже там 2n поделить на логен но тут опять конечно же там шлюп шлюп и тогда
получается что это равно от то есть тут получается это наоборот даже мало ну как сказать ну с точки
зрения вот этой картинки чувства прекрасного требует что кара должно быть равно там 3 четверти
там 7 восьмых логен да то есть нет вот это сам явно что к должно быть что-то в районе нет нет
но тут вопрос как бы зачем да то есть принципе а симпатически в общем-то на этом можно успокоиться
потому что лучше чем это мы по-любому уже не выжмем как минимум из-за этого да и вообще как-то
глобально дайся нас массив размером то наверно уж считать его придется да поэтому в принципе
можно уже не заморачиваться то есть константа то есть реальная константа очевидно из чего
подгоняется да она подгоняется просто из практических душ то есть вам по практике нужно
смотреть сколько константа живет здесь сколько здесь там и все вот то есть так-то на самом деле
можно думать то есть здесь конечно парадоксальная ситуация что логарифм будет много а логарифм
любую константу меньше единицы будет мало и вот то есть там на самом деле то есть там
то есть можно креще там просто взять какой-то там супер крутой бин поиска штам пусть кара в но
лог 2 н минус там я не знаю там лог лог и смотреть сколько получится там не насколько получится там
вот как раз получится что-то типа n делит на лог n умножить на вот это вот шлёп шлёп и здесь
пол а здесь и симпатически тоже получится н делит на лог н умножить на лог н да вот то есть
заметим что это лучше чем логарифм умножить на любую константу меньше единиц с другой стороны
как бы это с другой стороны да с другой стороны вы и честно вы скажете совсем уже абстрактная
чепуха какая-то начинается и в общем-то будете прав такой абстрактное развлечение да вот потому
что в принципе она уже алгоритма ничего не даст так что вот таким образом у нас получился такая
вот длинная цепочка сведений то есть вот ровно в таком виде алгоритм называется алгоритм фарах
колтона бендера вопрос на внимательность сколько здесь сколько произнес фамилии да правильно две
да потому что до фамилии здесь фарах колтон это двойная фамилия господи сами погуглите почему
вот вот и бендер да вот как это называется да как-то настоящий программист должен
встретить своей жизни три бендера да из эльфы петрова из футурамы и да ну да нет ну да вы так
ладно попроще вопрос кто читал 12 тульев через серьезно господи уже 12 стульев ладно хорошо кто
смотрел ну хоть да ладно там еще отдельно в какой версии конечно да ну и господи нет ребят нет
мне конечно приятно чувствовать себя начитанным человеком да но вот хотя конечно
кошмар прям иногда уже хочется да уже до такой то лекции датчат она хочет рассказывать
сложно алгоритм но с другой стороны в качестве лебеза читаем 12 стульев да так открываем в уездном
городе м дата черт дальше не помню жалко хотя знаете ладно пока пока вот это стирать дайте
нам нет кто-то там на самом деле там утверждается что в японии разговор может быть такой какой
любимый стихотворение ну наверное в день я не гин прочти мне его это ну там же это несколько
тысяч строчек так если поэт писал там так нас столько много букв значит ему нечего сказать
о так ничего себе так хорошо так хорошо кто читал хотя бы один детектив про фонду рена давайте
так а так уже лучше хорошо хорошо да да да да да да а про пелагею ну там есть такие там пелагея
белый бульдог там например или там еще какие тоже акуни нет нет тоже рекомендую там отдельная
песня в какой-то момент даже просто активно активный разговор на тему того как там из
абсолютно обычного езды губернии сделать просто город сад просто с полным уничтожением преступности
так так вот не в таком виде алгоритм называется алгоритм фарох колтенбендер но мы пойдем немножко
другим путем на самом деле мало кто знает хотя на самом деле много кто знает но на самом
деле метод четырех русских можно применить задачи стать и к рмку напрямую без сведения колта то есть
конечно нам нужен был фарох колтенбендер как минимум ради того чтобы убедиться что а задача
эквалент и б что задачу л ца можно идеально решать кстати да обратите внимание то есть
принципе да мы научились решать задачи л цаза отн при статик л цаза отн предподсчета и единицу
на запрос вот да вот ровно этим вот способом да то есть мы никак не пользуясь тем что у нас
дерево двоичное вот но вот с рмку оказывается все серьезнее хотя ну начало конечно понятное то
есть опять ну понятно да зафиксируем как который выберем позже тут никуда не денешься но мы уже
поняли что оказывается у нас запросы бывают двух типов бывают большие то есть больше равно к и
маленькие которые меньше к и выясняется что именно маленькие запросы для нас проблема потому что
как вы только что убедились на большие запросы мы можем отвечать там за очень простые отн предподсчета
правда ну включающие спорсы на н делить на к на сека у нас мы верим что если ка будет порядка
там не более чем логариф но вот но оказывается маленькие запросы можно искать с помощью очень
простой технологии которые там знают все продвинутые олимпиадники восьмого класса вот ну
как у нас там действительно самый продвинутый алгоритм там который может встретиться на липяне
восьмого класса да не ну не на последний раз когда видела пято восьмого класса там была
помыла задача в которой желательно было бы понимать почему вектор хорошо амортизируется вот
ну не важно но на самом деле такой классический алгоритм восьмого класса как минимум в очереди
причем не тот который очень из очереди на двух стэках естественно значит отрите да давайте
не но вот то есть смотрите есть такой неожиданный алгоритм то есть предположим что вот у нас есть
задача да что нам нужно реализовать очередь то есть нужно добавлять элементы удалять
элементы и сообщать а кто у нас сейчас в очереди минимум да очередь никакая не
приоритетная прям вот предельно честная прям вот предельно честная что же в этом случае делать
но то дело здесь оказывается пример следующего допустим у нас в очереди оказались вот какие-то
числа там 5 4 8 там 1 6 4 9 там 11 5 7 вот давайте давайте на нее посмотрим да я буду предполагать
что мы вставляем элементы справа достаем слева но мне так больше нравится тогда заметим маленькую
приятную вещь вот у нас кто у нас сейчас минимум минимум у нас очевидно один и вот я могу заявить
маленькую приятную вещь что нет нет ну не то чтобы не нужны как бы нам нужно знать что они есть и
мы достаем потому что фронта может быть но факт остается фактом вот эти товарищи 5 4 8 они
минимумы не будут никогда потому что за ними идет число вот единица которая заведомо меньше да
может быть когда-нибудь сюда придет число меньше единицы понятно да но но тогда единицы
перестанет быть минимум 5 4 8 никогда с другой стороны заметим вот еще а предположим что мы
достанем 5 4 8 и 1 тогда минимум станет и ничего не добавим тогда минимум станет 4 отсюда
можно сделать вывод что шестерочка минимумом являться не будет так более того аналогично
можно вывести что вот 9 11 вот эти тоже минимумы никогда не будут потому что есть вот 5 7 вот то
есть давайте просто будем пусть поменьше будем так помечать так сказать те элементы которые могут
быть минимуме кого-то еще могут быть минимум или что тоже самое на самом деле можно это можно на
это посмотреть немножко по-другому можно заметить что это все минимумы на суффиксах то есть если мы
рассмотрим все суффиксы этой очереди то собственно мы сейчас отметили все что могло быть минимумом хоть
какого-то суффикс понятна логика да пока вроде не сложно так вот но теперь просто идея такая то
есть идея то есть идея на самом деле будет такая теперь то есть ну можно ну в исходном алгоритме
поиска минимум в очереди можно говорить так то есть давайте скажем хранить вот эти помеченные
элементы то есть можно даже эти помеченные элементы так сказать в отдельной в отдельном деке хранить то
есть работать это будет так то есть когда вы там удаляете элемент то вы смотрите то есть если он
был без галочки то дек не трогаем ничего не поменялось потому что а если например обнаружилось что у
нас там появилась какая-нибудь то есть мы удаляем вот этот минимум с галочкой то ну значит соответственно
этот элемент из начала дека и достаем единственное что а если мы добавляем новый элемент то здесь
оказывается работает так вот давайте я добавлю вот мне хочется 4 с половиной тогда если рассмотреть
по этим рассмотреть этот дек с конца то обнаружится следующее что у нас есть вот элементы 5 и 7 у которых
мы галочки торжественно снимаем и сами эти элементы достаем а вот 4 с половиной конечно по
любому кладем почему ну потому что 4 с половиной минимум на супер все из себя любимого вот то есть
вот получается такое но такое вот то есть такой минимум на очереди вот таким вот образом может
быть реализован то есть такой минимум на скользящем окне такой получается и он нам между прочим очень и
он нам сейчас очень сильно поможет поможет он нам следующим образом смотрите дело в том что если
мы возьмем ка не слишком большое то на самом деле помещенные элементы могут быть записан записаны
просто в масочку правда но если я тут просто вот нолики единички запишу то получится прям масочка
размера к и тогда у меня идея такая а давайте-ка я пробегусь по массиву за линию добивая и
добавляя и удаляя из него элементы таким образом что каждый подотрезок размера к то есть не только
вот этот блок но прям вот каждый подотрезок размера к там вот этот вот этот вот этот вот
этот там вот этот и так далее то есть каждый подотрезок размера к в какой-то момент будет
в очереди в чем не просто то есть все его элементы будут в очереди все вот и никаких других там не
будет тогда у меня идея такая вот я проверю вот этот алгоритм и для каждого из этого состояния
для каждого подотрезка размера к запишу его масочку вот сохраню себе в карман то есть пока
видите я это все за линию делаю тогда идея такая то есть оказывается теперь что после этого что
мне теперь нужно чтобы найти минимум на ком-то подотрезки да ну да то есть смотрите
предположим что я тут взял какой-то подотрезок длины меньше чем к хочу найти на нем минимум
тогда иди такая давайте возьмем подотрезок размера к который заканчивается там же где и
этот мелкий вот ну если он там на префексе то там разобраться легко если что вот ну потому
что там самые первые элементы когда добавляем там тоже вот эти масочки для префиксов тоже
сохраняются так вот что мы здесь имеем то есть мы знаем что у нас было состояние и мы знаем что
тут какие-то элементы помечены но тогда из вот обсужденного ранее очевидно что надо просто взять
самую левую масочку которая попала вот в этот вот маленький отрезочек то есть самый левый
уголочек то есть по сути будет идея такая то есть мы берем эту масочку оставляем из нее только
несколько последних элементов и в этой маске после этого нам просто нужно найти старший единичный
бит вот и все то есть получается единственное что нам нужно теперь научиться делать после этого это
но вот это то есть по масочке размера то есть по масочке состоящий не более чем ка бит найти
старший единичный бит в ней масочка задается к счастливке вот на самом деле тут сильно вообще
есть сомнитель крайне сомнительным является вопрос а надо ли вообще предпочитывать что-либо для
этого потому что кажется возможно в некоторых компиляторах едва ли не там какие-то специальные
битовые функции есть вот но как бы там есть она совсем не повезло с компилятором или мы там
называется там где что-то не догуглили то в конце концов предпочитать эту штуку за два
степеника на к ну совсем на тупнячка хотя в принципе можно было из-за 2 степени к просто
пересчитать на самом деле да то есть можно в общем-то там этот старший бит честно там
сохраните там записать сохранить в таблицу возрадоваться но после этого как всегда n плюс
n к логин делить на к ну второй раз решать не будем то есть получается там как всегда кара в но там
логин пополам побеждает или можно это ка вообще убить и тогда ка просто пишем логарифом и будет
хорошо ну потому что там ну для каждого числа потому что датам что там ну да там маски там
больше типа для для каждого числа от одного до n ну или там на какой-то степени двойки насчитать
там там этот бит но это там аккуратненько за линию делается вот собственно и все то есть алгоритм
в общем-то оказался не сильно сложно вот здесь в алгоритме ну просто мы говорим мы то есть мы
тратим вот и вот это время на то чтобы перебрать там все маски размерка то есть все числа
получается от нуля до 2 степенька минус 1 и для каждого из этих чисел за улотка найти старший
идеичный бит вот нет ну как сказать не совсем если
мы идем вот так прибираемся по массиву добавляем элементы в очередь слева направо то как бы у нас
тогда получается там мы можем искать минимумы на суффиксах очереди поэтому мы собственно тут
брали такой отрезок длины к чтобы за простой отрезок оказался его суффиксом именно ага
если билден если билден цлз это вот операция кто ищет старший
единичный бит то да да да да да да именно именно нету для рентгистов из зрения практики
не но все четыре то константа крыша такая себе ну такое да то есть то есть формально там как бы
в этом алгоритме не выплыла вот это вот бит ности опять да нет можно предпочитать потому что если
ты для маски z знаешь старший бит то для маски 2 z это старший бит тот же самый плюс один да правда
это будет работать за единицу а за нет если гарантирует нет если гарантируется что билден
заработает реально за единицу они они за какой-нибудь там количестве количество
если ваш процессор умеет это делать реально за единицу то
пожалуйста но это будет алгоритм получается не процессор и независимый получается сейчас
ответ чего для легкого запрос так берем маленький запрос находим подотрезок длины к такой что
маленький запрос является его суффиксом вот для этого подотрезка длины к у нас было какое-то
состояние очереди с ее маской так вот обнуляем все биты в этой масочке кроме вот этой вот
которые попадают запрос но там пишем там типа ма то есть масочка пишем там n равно там один
хрец хрец длина запроса минус один понятно да да да маски записывает потом тут обнуляем
мы находим старший единичный бит в этой маске все вот так что такая красота даже 4 там это и так
далее так что получается но вот так что но то в принципе да то есть метод четырех русских
здесь может работать с неожиданно вот таким вот способом старше бит для всех маски размера к
нет для да нет а ну не важно можно сказать размера кап потому что как бы если меньше
как тот как бы припишем нули слева и старший бит от этого не поменяется вот в общем это
действительно детали да но это может быть самое классическое применение метод четырех русских
но не торопитесь залезать телефоны есть еще
нет это попытка это попытка сказать что как и что какие-то объекты достаточно малого размера
мы умеем просто полностью перебрать и для них сложить это ответы табличным образом и потом
после этого оптимизируетесь им точку во сколько-то раз да но просто да но просто старше будет
просто в логарифм раз меньше поэтому получается хорошо более того но то есть эти так мы н лог
n превратили в н да но нам надо не нет у каждой маски размера к можно старше бит поддерживать
но нам же нужен старший бит не только маски размера к а у любого ее суффиксы
нет это это конечно да но чем это нам поможет вот так что да ладно но если отыть так ладно так
так дальше нет тут просто какое-то обсуждение это еще интересно ладно продолжаем поднимать
планку как говорится что же у нас оно вот что же еще можно решить методом четырех русских ну
конечно же это конечно всеми любимая задача лэвел анцестер квейли так а мы умеем решать
эту задачу вообще хоть как-нибудь бенапами да да то есть конечно говоря про дабы научились решать
задачи лца но да мы говорили что у нас есть конечно метод искать лца двоичными подъемами но
это за логарифом поэтому придумали такие другие методы а задачи-то осталось ведь здесь же такая
мечта вот в чем вообще заключается задача лэвел анцестер квейли вообще или как еще она известна как
элаку но задача заключается в следующем да но дерево но в нашем случае статическая и запросы
у него только одного типа элаку от вершины в и высоты аж запрос очень простой значит внимание
найдите предка до дерева подвешенные предка вершины в находящимся на расстоянии аж от нее
не путать не потомка предка предок один потомков много как всегда вот вот вот такая
мистическая задача но давайте думать так вот но мы пока на самом деле у нас нет особо вариантов
мы умеем решать пока эту задачу за м логан предподсчета и логан на запрос это просто двоичные подъемы
да была бы конечно то есть как всегда доцеливаемся мы крыша на то что хочется
делать линию предподсчета и единицу на запрос
ну ничего значит смотрим значит это был но вот значит как же это сделать ну естественно
с деревом нужно как-то поработать вот но обычно до у дерева конечно но заметим что дерево можно
как-то декомпозировать на пути вот у нас уже но была такая замечательная штука как хевилл и
декомпозиции вот который занимался тем что разбивал дерево на какие-то пути и чет с ними дел
вот так вот слушайте другую декомпозицию значит смотреть сейчас поедем сейчас у нас будет
сейчас сейчас нас поприветствует так какой маркер нас поприветствует пан пусть вот этот нас
приветствует лонгест пэс декомпозицию значит он но во первых да он будет стараться от каждой
вершины уж если путь в ней начался то хочется чтобы этот путь дошел до листа пойте в хевилл айте
это не обязательно ну такие существует реализация хевилл айта как мы обсуждали да что то есть можно
не заморачиваться кто тут тяжелые легкие просто для каждой вершины говорит что давайте объявим
тяжелым просто ребро который ведет самое жирное под дерево вот но вот здесь мы тоже будем поступать
примерно тем же способом но но вот но делать будем так давайте начнем с того что построим путь
куда мы пойдем из корня но мы пойдем теперь да в лонгест пэс декомпозиции мы хотим сделать этот путь
как можно длиннее поэтому мы пойдем да я специально тут так нарисовал поэтому потому что мы в каждой
памяти будем идти сам в под дерево самой большой глубины вот прям вот так вот жадно идти идти идти
ну тут вообще без вариантов идти идти идти идти ну а для остальных под деревья прям отсечка но
здесь получается вот такой путь здесь получается вот такой путь значит у этой вершины так идем
сюда и а дальше куда давайте посмотрим давайте раз два три четыре пять раз два три четыре пять
безразлично эти пойдем так хорошо так кто за то чтобы пойти вправо сейчас погодить
кто за то чтобы пойти влево не очевидно я посчитал руки 8 8 так короче так ладно
число все все спасибо вправо так нет я загадал что-то нечет просто не в моем случае то это идет
вправо так что не важно слушай 57 179 да это разная сторона да как бы 57 это слева от крылья 179
справа но сути одна кремль ряда вот конечно да когда как говорится дошу находится между 57 179
правильно кремль ладно в районе на самом деле неправильно нет кремль находится чуть по боку
между ними находка там что там между ними находится там так что там госдума между ними
находится сейчас что там еще на так ну дом пошла так ну дом пашкова там с библиотекой естественно
находится там еще еще а ну все в принципе там будут там так но да правильно дом пашкова она
же библиотека дальше библиотека так что там еще какие-то здания ну и в общем-то все госдума и
179 все что там еще может быть а в ладах есть онка там еще есть но она чуть левее
да это уже да так пум пум пум пум ладно для нас сейчас самое главное вот такое вот
у нас получилась вот такая декомпозиция значит идея такая то есть давайте сделаем как всегда
то есть давайте каждый путь честно выпишем сверху вниз прям честно все вершины естественно для
каждой вершины выпишем что она находится на каком пути она находится и где находится тогда заметим
что вдоль этого если мы находимся на каком-то таком пути то подняться на заданную высоту в
рамках этого пути мы можем за единицу правда тогда получается тогда идея такая кстати да что
самое приятное найти long space decomposition мы можем достаточно легко за линию правда там буквально
двумя дфсами по сути один дфс почитает глубину по дереву а второй честно вот эти вот пути
ну можно за один дфс и какой-нибудь там аккуратный бфс но это это звать кому как
проще это не принципиально вот принципиально другое хорошо предподсчет у нас конечно работает
за n но теперь вытекает вопрос а если у нас будет такой long space decomposition спрашивается за сколько
мы будем подниматься почему закорен вот ну не обязательно на один но действительно как
мы будем подниматься из каждой вершины так опять ну то есть из каждой вершины будем подниматься ну
понятно если можем в рамках пути подняться то поднимаемся завершаем работу если пока аж еще
большое то мы поднимаемся до начала пути проходим одно одно ребро выходим на другой
путь поднимаемся по другому пути и так далее остается только вопрос сколько путей максимально
мы пройдем да но оказывается но все давайте подумать то есть оказывается что каждый раз
когда мы находимся на пути длины и к следующей путь будет длины как минимум x плюс 1
больше к сожалению больше к сожалению нельзя есть конкретный тест
рано никаких 2x не будет пока пока никаких 2x нету не будет не будет
вот то есть на самом деле вот я тут я тут пока как раз рисую пример на котором вот видно
что 2x не будет вот то есть принципе дерево может быть устроено примерно вот каким-то вот таким
вот образом вот и тогда но вот ну и отсюда в общем-то очевидно да что то есть как бы если вы то
есть тогда получается если вы сделали l шагов то тогда вы все что вы можете гарантировать то что
в дереве есть хотя бы 1 плюс 2 плюс 3 плюс и так далее плюс l вершин и это не превосходит n но отсюда
автоматически выводится уж не буду расписывать что l не превосходит корня из двух n да такая вот
стандартная корневуха то есть мы неожиданно учились делать предподсчет за n и после этого
подыматься за корень из-за вот ну в принципе да уже тоже интересно ну как-то до корень из-за
как-то не очень мы за логарифом умели то ничего у нас есть но следующий уровень следующий уровень
ладно нет ну нужно просто что-то контрастненькое ладно леда декомпозиции
формально конечно декомпозиции то есть как по мне декомпозиции надо вставить скобочки потому
что это конечно сейчас будет не декомпозиция но же декомпозиции это когда каждая вершина
принадлежит ровно одному пути здесь будет интересно на самом деле чем отличается
лонгис пэс декомпозицион от леда он отличается вот чем берем обычный лонгис пэс декомпозицион
вот этот коричневый путь и каждый из этих путей продаляем вверх на его длину то есть прям в тупую
суммарная длина коричневых путей n поэтому про это продление будет суммарно за n даже
если в тупую делать вот такая красота что это нам дает это нам дает маленькую приятную вещь вот
теперь вот для этой вот в этом случае уже работает это то что есть у нас сейчас путь длины x то тогда
следующий путь будет длины 2x почему потому что если мы находимся на коричневом пути длины x то
мы можем то мы подымаемся вот по ледах декомпозициону как минимум на x правда то есть
мы подымаемся как минимум на x это означает что там мы пойдем на вершину с коричневым путем хотя
бы 2x и это приводит нас к тому что у нас все работает за n и log n так ну что мы неплохо мы
победили двоичный подъем уже неплохо пересекаются ну и что ну коричневый не пересекаются потому
что коричневая из вон гиспеса да но там просто три дебы и дебы такая вот мы находимся сейчас
какой-то вершине да сейчас но и сейчас при деле я сейчас расскажу значит мы тут значит если мы
внутри леда декомпозициона можем подняться за единицу мы это делаем да в противном случае у
нас тут есть какой-то путь мы поднимаемся до его начала и еще но вот и еще настолько же то есть
если тут был путь длины x то и тут будет путь длины x ну там плюс-минус один не будем придираться то
есть мы пойдем вот в эту вершину эта вершина тоже находится таком-то коричневом пути но этот
коричневый путь хотя бы 2x почему потому что у этой вершины глубина как минимум 2x так что как
мимо это еще только вниз может мы еще вверх куда-то ну собственно все но вот так что оказывается это
уже круче и это мы обошлись без двоичных подъемов но как в этом месте говорить гори коспаров как
говорится там мы с компьютера можно против компьютера бороться а можно им и воспользоваться вот
поэтому потому что потому что но потому что на самом деле следующий день может быть что а
вот двоичные подъемы все-таки можно использовать и ведь действительно можно каким образом давайте
вот это давайте в наглую двоичные подъемы так и насчитаем вот честно зен логан казалось бы да
тогда смотрите какая у меня неожиданная идея вот пусть я этого двоичные подъемы насчитал тогда
если мне надо подняться тогда я с помощью двоичного подъема одного за от единицы могу подняться на
высоту 2 в степень и такая что 2 степень меньше либо равно аж меньше чем два степень и л плюс
один логично да то есть я могу с помощью двоичного подъема там скушать больше половины но теперь
заметим давайте из после этого применим ледер декомпозицион но тогда оказывается что мы за один
переход по ледер декомпозициону теперь достигнем финиша почему ну просто перейдя на 2 степень
либо пойдем вершину у которой коричневый путь длины хотя бы два степени и правда следовательно мы
наверх можем подняться на два степени и она надо подняться на длину очевидно меньше чем два
степени и поэтому мы это теперь делаем за единицу то есть в результате то есть в результате у нас
получается новая симптомика то есть ледер декомпозицион плюс двоичные подъемы binary jumps
предподсчет получается n log n и на запрос мы отвечаем за единицу
какие логарифмы а ну да но ну знаете это детали реализации да это детали реализации
спорта тут ничего нет то есть таким образом видео у нас снова есть n и log n и n log n 1 хочется из них
каким-то мистическим образом сделать n и 1 как же это сделать мы это узнаем после переговора как
же нам как бы все-таки и n и dn log n не падать единицу сохранить нету первая идея ну да и тогда
вот логарифм но на самом деле есть конечно на садите есть на самом деле неожиданный чит я
утверждаю что на самом деле бинапы можно считать не для всех вершин ну заметить если есть у вас
есть ледер декомпозицион кстати да заметим первое такое маленькое приятное замечание заметим
что если у вас есть ледер декомпозицион то вы логарифм двоичных подъемов из одной вершины
можете насчитать не считая при этом двоичные подъемы для предков как это делалось раньше
почему ну потому что идея такая что если вы знаете куда из вершины скакнуть на 8 вверх то
тогда с помощью ледер декомпозициона вы за единицу можете скакнуть еще на 8 правда вот вам
и бинап на 16 вот из этой вершины скачет она там еще на 16 получается 32 но и так далее то есть
получается вы можете выбирать для каких вершин вы считаете двоичные подъемы поэтому идея такая а
давайте считать двоичные подъемы не для всех вершин а только для листов вот давайте насчитаем
для листов двоичные подъемы тогда оказывается следующее что на самом деле если вы хотите
подняться из какой-то вершины в то прежде чем подняться давайте просто опустимся из вершины
в какой-нибудь лист в ее поддельно но можно же заранее там в дфс предподсчитать для каждой
вершины какой-нибудь лист из ее поддельного а ну да тем более логи спресс декомпозицион и
вы это в явном виде делаете да да можно даже лишний дфс не запускать окей ну вот то есть тогда
получится что теперь надо подняться из этого листа но просто не на высоту ашта а на высоту аж плюс
там сколько там на сколько спустились это приводит нас к тому то есть это приводит нас к новой
мистической асимптотики так ладно кажется ну ладно а тот как-то вспоминаешь он аж на
пользоваться тем что у нас тут две доски стоит зачем-то да ну ладно пока не надо значит смотрите
значит идея будет такая то есть теперь у нас получается новый алгоритм то есть ld плюс так
сказать bg на листах тогда предподсчет будет работать теперь за симптотику n плюс лага
нот l лог n даже я вот правильно вот так нарисовать потому что вот ледер декомпозицион считается
за линию l log n это вот двоичные подъемы для листов коих у нас l большое то есть
принципе отсюда идея такая что если вам повезло и листов дерева у вас не слишком много например
не более чем n поделить на log n то тогда в принципе больше ничего делать не надо вы уже победили вот
вот я вчера не был на открытии вам вчера говорили что вы уже победите или
а точно да нет маруся помню да хотя и эту запись маруся должны были в начало ставить
конечно а то как-то да а то всем удачи дарю когда да а то всем удачи когда уже до контест
закончен все уже мертвые главное да давайте теперь да покажите лучше нашу на что вы
способны так так вот но теперь получается теперь неожиданная проблема что делать
если листов у вас больше чем n поделить на log n вот что такое лист второго уровня
для предком родителям да и что поможет
для ка и где ка это что и видеть и видеть и видимо маленькая да нет то на самом деле
смотрите нет тут идея оказывается немножко другой да то есть конечно да фиксировать
ка который выберем позже мы будем так давайте будет у нас такое красивое давайте ой нет давайте
вот такое у нас красивая ка будет они что нет там вот еще вообще нет у нас был метод а у нас
метр четырех русских уже был серий не ближе пусть и будет вот там ка так вот значит интуитивная
идея то есть идея хочется сделать так вот у вас есть какое-то дерево то есть какие деревья
вот такая вот красота красота красота красота вот так вот идея такая давайте
попытаемся по отпиливать от этого дерева таким вот снизу маленькие под деревья размера приблизительно
ка вот ну как-то так вот приблизительно но ну типа но но например жадным образом если выяснять
что то есть можно вершину объявлять корень под дерево если у нее размер под дерево не
превосходит ка а вот размер ее родителя ка превосходит ну например ну по сути да да придется
тут конечно вот так делать вот но конечно у нас была бы мечта чтобы таких листьев не было а тут
еще кстати вот все а на самом деле мы бы по отпиливали действительно именно под деревья
размера ка потому что смотрите если эти деревья как бы то есть идея такая что надо их отпилить
вместо них объявить такую мета вершину вот такое слово тоже есть да вот почему нам так хочется а
потому что хочется что наверное если мы тут пожимали под деревья размера ка то наверное листов у нас
оказалось не более чем инделить на кадр и дальше останется только маленькая идея останется
только научиться подниматься в деревьях размера не более чем ка вот да согласен да это конечно не
очень очевидно да да это не просто не очевидно это еще и неверно ну типа да ну типа да но на
самом деле но на самом деле да то есть более точная идея будет такая смотрите я буду жадным образом
отпиливать под деревья размера ка жадном в каком плане что я отпиливаю под дерево вершину который
не более чем ка но у родителя который размер больше чем ка то есть вот ее я то есть теперь
я гарантирую что ладно приблизительность не рассчитываю но что меньше либо равно ка гарантирую так
вот идея на самом деле такая значит да у нас тут здесь мета вершин куча некоторые из них из одной
вершины состоят но давайте посмотрим не на нее а посмотрим на родителя
вот родителей мета вершин посмотрим так что-то у нас а ну здесь кстати мета вершина будет не
такая она самом деле вот такая конечно вот ну вот ну и здесь будет там видим вот какая-то
вершина тут будет вот такая ну и так далее вот так вот на самом деле идея такая то есть
есть у нас мета вершины есть родители мета вершины так вот идея такая давайте отпилим вот отпилим все
мета вершины на этот целиком и в общем просто отпилим ничего вместо них делать брать не будем
Рыжая, то есть красные как раз оставляем, то есть мы будем говорить, что красная у нас останется вершина, от которой что-то отпилили.
Так вот, мистическое утверждение. Я утверждаю, что после этого безобразия листами могли остаться только красные вершины.
Обратное неверное, то есть не все оставшиеся выжившие красные вершины листы, но все выжившие листы это очевидно красные вершины.
Но отсюда следует маленькая приятная вещь. Каждому из этих листов в старом дереве соответствовало ее под дерево размера больше к.
То есть от нее отпилили хотя бы к вершин.
Следовательно, в этом дереве, то есть красных вершин, то есть красных листов не более чем n делить на k.
То есть идея получается такая. То есть тогда мы легко сделаем за линию теперь предподсчет, то есть если мы поднимаемся изнеотпиленной части, то там уже с помощью линейного предподсчета за единицу мы легко поднимемся.
Более того, как сейчас у нас было в фарах в Колтонбендере, если мы поднимаемся из отпиленной части, но высота потребует дойти до красной вершины и пойти дальше, то мы тоже это легко можем сделать за единицу.
Потому что заранее в ДФС мы в отпиленной части можем просто сказать, на каком расстоянии от нее находится корень и его родитель.
В одном ДФС не получится, потому что в первом ДФС придется ССЗ для всего этого посчитать.
В первом ДФС на ССЗшке, а потом уже во втором ДФС можно и лонгест ПС смотреть, и вот эти вершины мысленно отпиливать и так далее.
Но там придется много чего еще делать, потому что в чем еще фишка?
Мы научились решать задачу в предположении, что ответ всегда будет в этой неотпиленной части.
Остается только как ирагия, то есть самым мерзким случаем оказывается, а что делать, если вершина В находится в отпиленной части и ответ на нее находится где-то в отпиленной части?
Что делать?
Для всех деревьев, для всех вершин, для всех вопросов.
Ну да, ну да, собственно чего.
Давайте подумаем, а сколько у нас вообще подвешенных деревьев размера К?
В принципе-то вообще.
Особенно еще.
К в степени К-2, да?
Не, сейчас.
Ну да, если там еще источник перенумерации, там еще есть перенумерация вершин, дают другое дерево и так далее.
Нет, да, формула К или такая есть.
Но заметим, что нам, в общем-то, если мы под деревья поменяем местами, дерево принципиально не поменяется.
Поэтому, я отражаю так, если с точностью до изоморфизма...
Вот, кстати, вот отдельная задача. Даны два дерева, изоморфны ли они?
Да, нет.
Не сейчас мы этим будем заниматься, нет.
Это я просто прикидываю.
Заранее начну морально готовить к тому, что скорее всего у нас, собственно, остались в этом семестре занятия только вот это и через неделю.
Ну, то есть, формально говоря, там, конечно, занятие еще будет одинство, но я боюсь, я в этом время рискую оказаться в Питере.
Равно как и некоторые из вас.
Вот, собственно, отдельные счастливчики.
Кто вчера больше семи задач решил.
Ну или очень хорошо решил семь.
Ну, это так, просто в всякий случай.
Вот, поэтому это более нот.
Поэтому я тебе запоминаю, что надо закончить, чтобы в следующем семестре не возвращаться.
Так, значит, что делать, если вот мы хотим посчитать количество деревьев с точностью доизоморфизма.
Так вот, мистическое утверждение.
Деревьев, подвешенных с точностью доизоморфизма размера К, размера ровно К, не более чем.
Ну ладно, если брать по оригинальной статье, то не более чем два в степени 2К.
Ну да.
Ну, через скобчатые последовательности, конечно, не более чем КТ и число каталана.
Почему?
Ну, потому что мы помним, что дерево мы можем закодировать правильной скобчатой.
Ну, не совсем так.
Двоичное дерево.
Да, мы помним, что двоичное дерево мы могли бы закодировать правильные скобчатые последствия, причем взаимнооднозначно.
Здесь у нас дерево не взаимнооднозначно.
Не двоичное, да?
Но закодировать...
Ну, там...
Ладно, там...
Ну, кат, конечно, там будет не К, там, наверное, будет...
Там минус один, наверное, все-таки.
Ну, потому что как кодировать дерево?
Да, проходим по революции вниз, записываем открывающую скобку, проходим вверх закрывающую.
То есть явно там не все правильные скобчатые последствия получаются.
Ну, вот там правильные скобчатые последствия размера К минус один получаются.
Но там, по-моему, в оригинальной статье, если такая была вообще...
А, ну да, такая была, конечно.
Вот.
Ну, вот.
Тогда вот там просто сказали, что нам для наших целей можем не заморачиваться и просто сказать, что у нас правильных скобчатых последствий не более, чем два в степени 2К.
Вот.
Просто.
Вот.
То есть, смотрите, идея такая.
Перебираем все деревья.
Значит, что мы делаем?
Перебираем все деревья.
То есть, по сути, может быть, там все правильные скобчатые последствия.
По каждой из них пытаемся восстановить дерево.
И для каждого такого дерева мы честно, для Ка, прям перебираем в тупую все вершины.
И для каждой вершины в тупую перебираем все подъемы, прям в тупую их записываем.
Да.
Это прям вот очень в тупую работает.
За два в степени 2К на К в квадрате.
Ну, там не сильно будет принципиально.
Там хоть К в клубе можно писать.
И в четвертый.
Вот.
Правда, смотрите, тут надо, правда, аккуратнее.
Потому что после этого вам придется сделать еще следующее.
Вам придется пробежаться по всем отрезанным метавершинам.
И для каждой метавершины еще и запустить ДФС.
И желательно прописать, во-первых, какого типа это дерево.
Понятно, да?
Какого типа это дерево.
И самое главное, что каждой вершине поставить в соответствие, то есть какая вершина в табличном дереве его соответствия.
Потому что тут будут там вершины 57, 179, там 2007, 2009, там два.
Ну вот.
А в реальном дереве тут будет там 0, 1, 2, 3, 4, очевидно.
Вот.
Поэтому там надо такое соответствие.
Но это за линию уже делается легко.
Вот.
То есть получается тупо, что каждое дерево придется перебирать.
Но как бы смысл этого параметра K заключается в том, чтобы было выгоднее, чтобы различных типов деревьев было меньше, чем метавершин.
Вот здесь.
В этом, собственно, и смысл методов четырех русских.
Получается мы умеем делать 2 в степени 2K на K квадрат.
И после этого то, что выше, мы предподсчитываем.
Получается за сколько?
За N.
Ну, как мы уже выяснили.
Значит, за не более чем N делить на K, на log N.
Так.
Ну и, конечно, сам по себе ladder decomposition.
Плюс, соответственно, N.
Вот так это я уберу.
Вот такая красота у нас теперь получается.
Да.
С помощью этой красоты очевидно мы теперь за единицу можем искать все подъемы.
Правда?
Ну, первая чека это вопрос.
Какой нот?
Ну, тут уже даже проще.
Не будем сейчас подгонять идеально.
Просто какое бы нам K подогнать, чтобы это получилась линия?
Ну да, самое тупое, что можно подогнать, это K просто там logarithm на 4.
Да.
То есть на какой-нибудь это его там реальный.
То есть если там N равно миллион, то K получится равно 5.
То есть перебираем все подделения размера 5.
На практике вам, конечно, явно окажется легче, видимо, эти 5 шагов делать честно.
Но это уже вопрос константа, конечно.
Ну тогда подставляем K равно log 4.
Ну и что тогда?
То есть log делить на 4.
Тогда получается корень из N на log квадрат N делить на даже 16.
Плюс там получается 4N.
Ну 4N плюс N.
Короче, ОАТ.
Все.
Да, тут log N пошлеп-шлепался.
Чего?
Ну да.
Да, шлеп-шлеп.
Да.
Ой.
Кстати, а так, шлеп-шлеп вчера забрал свой диплом, кстати?
Окей.
Нет, кто-то вот не забрал, кстати.
Нет, я даже ожидал, Серге, кому-то из вас.
Но вот тут у меня сейчас...
А, вот была у меня команда Бэри Нор Адреналин.
В составе Ивана Белецкого, Алина Мансурова и Юрия Воженин.
Да, но окажется, впервые в жизни никого из них нет.
Чего?
Прям совсем расстроились после вчерашнего, что ли, или что?
Так что господина, не фартаанула называется.
Ну ладно.
Ничего.
Ну вот.
Так.
Ну вот.
Таким образом получается, что мы научились оказываться
и эту задачу, то есть и подниматься на нужную нам высоту
за единицу.
То есть у нас на самом деле не совсем из-за марксизма,
у нас из-за марксизма точно следует того, что мы еще
не меняем детей местами.
Ну, типа того, да.
Ну, то есть, ну вот.
То есть если как-то нормально описать все эти марксные
дети, их там окажется сильно меньше, что у нас еще
какой-то выигрыш в константе будет.
Ну да, но правда там да.
Ну может и будет.
Но там как-то отдельный вопрос о сколько существует
попарно незаморзных подвешенных деревьев.
Хотя бы симпатически.
Пока все, что я знаю, что там на Котфольсе была такая
задача, по-моему.
Там была задача, сколько существует попарно незаморзных
деревьев, диаметры которых не превосходит чего-то,
по-моему.
Десяти, что ли, или что-то в этом роде.
Нет.
Нет.
Если бы на подъеме.
Даже не на подмасках, там на деревьях каких-то.
Нет.
Ну может нет.
Ну может не десять.
Может там просто Н и К.
Просто до тысячи оба.
Или что-то в этом роде.
Но тогда нормально.
Да, но правда нам еще надо пообсуждать деревья.
Еще хорошо, чтобы понять, за счет чего такие задачи
вообще можно решать.
Вот.
Так.
Но пока у нас вот такая красота.
Так.
Ну потому что там в каждой дереве там К вершин.
Ну не более, чем К на самом деле.
Вот.
Для каждой вершины мы можем подняться на высоту 1.
Захотеть подняться на высоту 1.
На высоту 2.
На высоту 3.
И так далее.
До К.
Поэтому и как вот.
Но это совсем в тупую.
Если мы просто войдем и поднимемся.
Передается следующая реализация данного алгоритма.
Давайте пересчитаем вершинки, которые являются предками
на высоте 5 листьев.
И когда у нас приходит запрос, мы спускаемся до
листа, идем 5 шагов вверх и прыгаем.
Ну скажем так.
На нашей практике, да.
Логично.
То есть на реальной практике, конечно, такое реализовывать
сложно.
Да.
То есть алгоритм, конечно, скорее теоретически это
да.
Вот.
Потому что на реальной практике, скорее всего, там лишние
5 шагов можно и сделать.
Чем, конечно.
Хотя...
Хотя философский вопрос.
Там делать 5 шагов или там вы просто для каждой вершины
четко знаете в какую таблицу куда лезть.
Один раз.
Потому что вы же заранее предпочитали.
Так что может и...
Ну то есть, ладно.
Н, конечно, миллион вряд ли, но если там вам сгенерят
как-то рандомно дерево там, скажем, на 10 миллионов,
то...
То может на самом деле единица начнет работать.
Но это, конечно, тема для отдельного исследования.
Так.
Так.
Чего бы вам еще такое рассказать?
Я хочу просто сведеть к предыдущему пункту.
Ну да.
Ну да.
Ну точнее так.
После отпиливания метовершин листов оказывается не более,
чем отделить на к.
Да.
А мы такую задачу уже умеем решать.
Ну, значит так, с оговоркой.
Мы ее умели решать в предположении, что к порядка логарифма.
Но у нас так и есть.
Получился не логарифм, а логарифм делить на 4.
Но как бы...
А если запрос вот попадает по дереву?
Ничего, мука размера.
Мы же ради этого и предподсчитывали.
То есть мы как бы знаем про дерево какого оно типа
и просто лезем в табличку.
То есть соответствующее, что там есть вот это дерево,
у него из этой вершины надо подняться на какую-то высоту,
и там просто в табличке тупо...
То есть из этого предподсчета там будет тупо написано,
куда мы поднялись.
Ну это не сложный случай.
Нет, ну это самый сложный случай.
Мы ради этого делали предподсчет.
То есть когда сделали предподсчет,
это оказался просто там...
Ну я не знаю уже какой из этих случаев проще после этого.
Но просто суть в том, что именно вот для этого мы делали предподсчет,
чтобы отвечать на запросы, которые не будут вылезать за пределы лежи вершины.
Так, ну что, еще какие-то вопросы?
Нету?
Господи, что ж такое рассказывать-то?
Сомневаюсь, вам дерево хранить надо.
Ну, в плане на предподсчет.
В плане предподсчетки, он ведь...
Суть его прикол в том, что нам ведь могут дать другой дерево
с новым ножным запросом.
Есть предподсчет сохраняется?
Можно где-то предподсчет тебе взял?
Суп линомиального, да?
Ну не знаю.
Ну чтоб было прям суп линомиальный, я...
Ну не знаю, там что-то много вещей завязано на то,
что у нас линейная память,
то есть надо помечать там какие там...
Ну там красные вершины надо помечать, скажем их,
может быть порядка N.
Там, по-моему, да.
Ну, то есть можно, конечно, листы не отмечать,
но там вот эти...
СССшки, понятно.
Ну, смотри, ты даже рекурсивный ДФС,
на самом деле, он потребует тебя,
может потребовать тебя для бамбука линейной памяти дополнительной,
так что вряд ли.
Очень сильно вряд ли.
Так, ну что?
Нет, даже интересно.
Так, прям уже интересно, да.
Не, слушайте, прям действительно интересно открыть Уикипедию.
Интересно.
Просто напомните, я что-то уже запамятал.
А какие еще задачи решает этот четырех русских?
Все.
Все?
Яха Карасик тоже?
Там у нас строго NOP камеры.
А, так, ну NOP, а еще?
Ну тоже дедовично только.
Не только.
Нет.
Нет, NOP-то да, это мы сейчас, видимо, и обсудим.
Транзитивного замыкания графа.
О, как.
Так.
Так.
Ладно, давайте.
Нет, прежде чем переходить к NOP,
это прям отдельная песня.
Красивая.
Значит, ладно, давай, значит,
тогда еще как бы утверждать,
что у нас есть задача транзитивного замыкания графа.
Ну, то есть о чем задача?
То есть данный циклический,
ну, то есть в чем задача?
Данный циклический граф,
данный ациклический ориентированный граф,
и надо привести ребра
между всеми парами вершин,
между которыми есть путь.
Так, это понятно, что я сказал, да?
Это называется транзитивное замыкание.
Да, спрашивается,
за какое симпточку это вообще можно,
если в тупую, сделать?
Ну, в принципе, да.
То есть напрашиваешь все решения за куб.
Ну, либо DFS, либо там BFS.
Ну, с другой стороны, да,
заметим, что правилами BFS и масочками,
или бицетами можно это сделать
за n куб делить на 32.
Почему?
Ну, очень просто,
потому что как понять,
куда мы из этой вершины можем дойти?
Для этого нужно посмотреть,
куда мы из нее можем перейти
за один переход,
взять множество переходов,
куда мы тут можем перейти,
куда мы тут можем перейти,
куда мы тут можем перейти
и их тупо объединить.
Если мы это храним
в каких-нибудь бицетах,
то получается,
то мы это делаем
за то любые два бицета,
мы объединяем за n поделить на 32.
Логично, да?
Логично, да.
Ну, вот.
Ну, теперь возьмите какой-нибудь вопрос.
А теперь давайте подумаем.
Хорошо.
А если у нас нет опции бицетов?
А если у нас нет опции бицетов?
Ну, разбиваем на блоки пока.
Ну, это нет.
Это будет, ну, да.
Но есть риск, что это да.
Все их пары в два степени кассы храним ответ.
Ну, и нет.
Ну, как бы.
Как раз какие, по-моему,
это оптимальность.
И битности нет.
Ну, да.
Нет, скажи так.
А если у нас нет
волшебных битовых операций?
Давай так.
Как это без битовых операций?
Еще бицеты завязаны
на битовых...
Бицет, изветь, бицет
завязан на том,
что мы там две битмаски
размера тридцать два умеем
там Энди теорить за единицу.
У нас есть табличка,
для всех массов.
Число до два степеника.
У нас есть табличка,
где для каждой пары чисел
до два степеника.
Их о, в смысле.
Или о.
Энди.
И нам эти битвы играться не нужны.
Это тоже предпочитывается
за два степени пока.
А, то есть такой наглеж, да?
Ну, в принципе, да.
Да, в принципе, да.
Действительно.
Это метод четырехрусских, да.
Зафиксируем к, который выберем позже.
И объявим, что у нас к
это типа та часть бицета,
которую умеем Энди теорить
за вот единиц.
Если у нас нет битовых операций,
то, значит, просто переберем
переберем два в степени два к пар
массовщик.
И для каждой из них
прям честно за к посчитаем
энд или ор.
Вот.
Так.
И это, в принципе,
позволит нам
работать за энд в кубе
поделить на к,
но остается только подогнать
к так, чтобы было хорошо.
Ну, как вы уже убеждались,
к порядка там,
сколько там?
Ну ладно, просто к алгорифам
уже подойдет.
Так, окей.
Да.
Потому что ребер вот этих,
которые мы, то есть бицетов,
которые мы обетеряем,
их порядка квадрата.
Так что, соответственно.
То есть по факту это будет, да,
это работать за там,
по факту
то есть сейчас за сколько
это будет работать за
энд поделить на к
умножить на количество ребер,
по факту.
Вот так.
Вот.
Так что там в зависимости от этого,
то есть от этого параметра,
если у вас тут не энд куб,
а допустим, действительно,
энд эм,
то в соответствии с этим можно и к
подгонять.
Это же не совсем так,
потому что у нас количество ребер
увеличивается
по ситуации.
Поэтому изначально это может быть энд,
а в конце энд квадрат.
Нет, увеличивается,
но количество бицетов,
которые мы объединяем,
объединяем же не меняется.
Потому что какая разница,
у тебя есть вершины,
тебе нужно просто взять бицеты
для вот этих трех вершин
и их объединить.
Все.
То есть как бы оно,
то есть и там.
Ну хорошо, то есть в конце там
ты потрачишь энд квадрат времени,
разве что на вывод ответа.
Не более того.
Вот так.
Ну теперь, кстати, вот да.
Вот с этой точки зрения,
когда энд куб превращается в энд эм,
тут как бы вопрос,
какой ка предлагать?
А лучше на четыре.
Да.
Да.
То есть действительно ка
давайте скажем,
что это лог энд эм двойчный,
определить на четыре,
и что получается?
Что там получается?
Корень из энд эм,
корень из nm на log nm делить на 4 плюс 4nm делить на log, то есть получается даже, нет стоп,
а нет нормально да, то есть получается асимптотика nm делить на log nm.
но мы так а мы их не добавляем,
у нас у нас нет цели добавить, у нас цель для каждой вершины получить бит сет.
вот так. нет, ну в принципе да, log nm на самом деле, заметим, что nm, можно в принципе сказать,
что nm, то есть m не происходит n квадрат, поэтому log nm не происходит там log n в кубе,
поэтому асимптотические по барабану. но когда фишка здесь, даже оптимизация здесь,
что если m порядка n, то это даже не n куб поделить на log n, а на n квадрат поделить на log n,
то есть еще меньше. ну против с бит сетами у вас тоже бит сеты у вас тоже по факту работают не
за n куб на 32, а nm делить на 32 с теми же спецэффектами. так что вот такие вот, да, из истории русского
пехона, да. вот, ладно, так, хорошо, так, а что-то там еще кроме nop есть?
давайте. что там еще есть? ну есть расстояние редактирования, но есть подозрение, что это
примерно то же самое, что и nop. все? ну окей, ладно, значит мы сегодня изучим полностью метод
четырех русских. да, и так, да, теперь мы неожиданно переходим к задаче о наименьшем общей
подпоследовательности. и так решаем задачу о наибольшей общей подпоследовательности. так,
в чем заключается задача? даны две последовательности, выберите из них, каждый из них подпоследовательности,
которые совпадут. не путать подпоследовательности с подстроками. помним, да? так, но задачу все
знают. так, поднимите руки, кто умеет решать эту задачу за n квадрат, ну пусть там обе последствия
одинаковой длины. так, кто-то не умеет, да? да ладно, в данном случае называется хорошо
прикалываться. ну хотя ладно, если есть, придется рассказать. значит, как решается
задача? ну даны какие-то последовательности a, а последовательность b, обе длины n. они из чего-то
там состоят. тогда идея такая, dp и tgt. пусть это будет просто длина nоп для префикса длины i у
последствия a и префикса длины g по следовательности b. это такое определение. определение функции. да,
я ее почему-то называю dp, а ну люблю эти две буквы почему-то, вот, не важно. вот, ну и тогда
очевидно, что dp и tgt очень легко пересчитывать, потому что, ну идея такая, вот вы ищете nоп двух
последствий. очевидно, что если два последних элемента совпадают, то очевидно, что этот
элемент просто подпоследствия надо взять, правда? то есть получается, что это 1 плюс dp от i-1 и g-1,
если a и t равно b и t, ну а если они не равны, значит, как минимум кого-то придется взять не. но если
вы не берете, скажем, вот последний элемент b, то тогда эта задача сводится к задаче подпоследствия
dp и g-1, или если мы и это элемент не берем, то вот dp и g-1. да, то есть в принципе может
случиться, что мы не возьмем ни тот, ни тот, но этот случай будет и тут, и тут учтен.
ну-то погодите, погодите, тут как бы аккуратно. нет, чего оптимизировать, не понял. нет,
наоборот, оптимизация будет заключена в том, чтобы это не учитывать и рассмотреть только эти два
варианта. потому что мы же не количество вариантов перебираем, а только там выбираем максимальные
из имеющихся, поэтому не глобально. вот, это работает с n квадрат. для числовых там может и можно,
но действительно есть маленькая подлянка. потому что как это ни странно, метод четырех русских тут
вообще не поможет, что быстрее чем z квадрат эту задачу решить нельзя, если загнать очень жесткие
предположения. самое жесткое предположение, которое можно загнать, это такое, что у вас элементы
последовательства это камешки. да, почти те самые камешки из сортировки, но только теперь,
если бы камешки из сортировки умели хотя бы сравнивать, то есть кто меньше, кто больше,
то давайте скажем, что камешки мы теперь можем только говорить, равны они или нет.
тогда я утверждаю, что быстрее чем z квадрат вы эту задачу не решите просто в принципе. более того,
я даже просто утверждаю, я утверждаю, что какой бы у вас не был детерминированный алгоритм,
найдется случай, когда вы сделаете реально даже не омега от н квадрат, а просто н квадрат сравнений.
или даже еще тупее. в алгоритму придется сравнить каждый элемент массива a с каждым элементом массива b.
могло бы быть. если бы я вам просто сказал, докажите, что быстрее нельзя,
да, это может быть даже сложная задача, но сейчас я вам уже подсказывал так, что в принципе уже
практически все пробивается, хотя техника может быть не совсем стандартной, потому что техника тут
такая. пусть у вас есть детерминированный алгоритм. там черный ящик такой. но все,
что он делает, он иногда вас спрашивает, просит сравнить какие-то элементы, вы ему
отвечаете yes и no, и он из этого думает. так вот, идея такая. давайте подсунем ему тест,
на котором все двойные элементы по парде различны. я утверждаю, что для того,
чтобы ему вывести ответ 0, ему придется все пары камешков он вам сравнит. почему нет?
да, потому что тут идея такая. предположим, что какой-нибудь там 57 элемент массива а,
он не сравнился с 179 элементом массива b. тогда скорбим ему другой тест. скорбим ему тест,
в котором все элементы по паре различны, кроме вот этого и вот этого, которые равны. алгоритм
детерминированный. это означает, что если вы ему будете сообщать одни и те же ответы,
он будет задавать одни и те же вопросы. следовательно, он про эти ничего не спросит,
про все остальное выдаст 0 и выдаст вам ответ, следовательно, тоже 0. либо на предыдущем
тесте он вам тоже выдал не 0, а это wrong answer. ура, ящик взломан. чтобы убедиться, что 0,
ему придется сравнить все. вот такая вот неожиданная красота. получается,
что быстрее, чем за квадрат, вы эту задачу особо не решите. вот, спрашивайте, при чем тут
нет, но там, на самом деле, думать можно. так, сколько у нас времени, кстати, так,
значит, давайте смотреть, где тут можно оптимизировать. но оптимизация, естественно,
начинается тогда, когда мы при эти камешки все-таки что-то знаем. ну, в нашем случае,
конечно, давайте предположим, что, как в реальной жизни, у нас алфалит константный. ну,
давайте для простоты предположим, что у нас, на самом деле, вообще эти камешки это 0 и 1.
вот, ну, бывает такое, nop на бинарных строчках. нет, я не знаю, Капелевич мог вам дать это
развлечение, как бы даны бинарные строчки, найдите nop за n2 на 32. а кто знает, кто такой Капелевич?
а, ЛКШ не катается, да, ну окей. а куда катается? а, окей. нет, ну, Sirius это бывает. ну,
понятно, да, ой, ну, нет, ну, понятно. давайте, смотрите, какая у нас тут возникает идея. как
говорит, это dp, ну, предположим, у нас строчки бинарные. нам нужно насчитать вот примерно такую
квадратную табличку, да, ну, типа, по i и по j, да, то есть, типа, тут мы насчитываем, тут типа a, тут b и
тут dp, да, по идее, у нас же каждую клеточку, то есть, каждую клеточку надо честно посчитать,
да, вот, ну, теперь заметим следующий. давайте, тут, допустим, вот, так, вот, давайте,
тут просто для понятности тут нарисую, да, то есть, тут я прям честно 1, 1, 0, 1, 1, 0, 0, 0,
1, ну, я примерно, да, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, вот, ну, и, по идее, вот, да, то есть,
у нас, то есть, по сути, у нас там табличка выглядит примерно вот так, то есть, даже это не клеточки,
а скорее, давайте, вот, почему-то очень удобно мыслить в терминах, что у вас тут на самом деле в
узелках находятся, то есть, в узелках этой клеточки, в каждой клеточке находятся ДПшка,
вот, понятно, что имеется в виду, да, вот, ну, и, по идее, стандартный алгоритм говорит о том,
что надо прям честно, на самом деле, в каждом узелке числуку посчитать,
вот, но тут приходят четыре русских и говорят, зафиксируем, как-то выберем позже, хотя ладно,
я не уверен, конечно, что это их формулировка, нет, фразу я услышал, собственно, от Андрея Сергеевича
Санкевича, который рассказывал этот метод, вот, то есть, там, в оригинальных статьях, я,
честно говоря, ничего подобного не слышал, там, может, просто там, действительно, то есть,
там везде говорят, давайте просто там это, введем карта и сразу логин поделить на 4 и поехали,
и погнали, вот, и там неожиданно все сходится, но суть тут будет такая, дело в том, что мы с вами,
значит, возьмем тут кое-что, значит, сделаем такие метаклетки, метаклетки размера канака,
вот так вот, попилим. Просто в чем идея? Идея заключается в том, что для каждой метаклетки
верно следующее, если вы знаете значение вот в этих вот узелках, вот в этих узелках и вот эти
вот строчки, то, в принципе, этого вам достаточно для того, чтобы посчитать значение вот в этих
узелках, и вот эти промежуточные значения вам даже не нужны. Ну, хранить, по крайней мере,
не надо, да? Ну, тут, в принципе, заметим, что, на самом деле, вот, кстати, кто-то тут говорил про
доп память, да, то есть, заметим, что насчитать ДП можно за ОАТН доп памяти, то есть, вот это НОП.
Отдельная песня, это, видимо, будем в следующий раз обсуждать, а может, а может, сегодня,
собственно, отдельная песня, как потом восстановить это наибольший вообще последствия линии памяти.
Ну, идея такая, значит, разбиваем тут каждую подстроку на блоке размера К, а ДП, а табличку ДПшек
нам вот эти метаклеточки. У меня просто идея, я очень хочу насчитывать не все узелки, а только
вот узелки на вот этих вот границах метаклеточек. Для чего я это, чтобы это сделать, я замечаю,
я замечаю следующее, я замечаю, чтобы насчитать правые и нижние узелки каждой клеточки,
мне нужно знать, что он мне ждет. Вот только верхние узелки, левые узелки и, собственно, строчки.
А теперь давайте посмотрим, а сколько у нас этих вот четверок есть, то есть,
типа, а сколько у нас существует наборов, типа, вот эти ДПшки, вот эти ДПшки, там вот эта строчка,
вот этот строчек. Ну да, формуля бесконечно много, но, как всегда,
каждый следующий узелок, это как предыдущий, только либо такой же, либо плюс один, правда.
Поэтому получается, что у нас тут всего два в степени 2К, это вот на узелки уходит,
и еще два в степени 2К у нас уйдет на сами строчки. То есть различных клеточек у нас всего вот столько.
Давайте все их честно переберем, для каждой из них честно за К квадрат насчитаем вот эти узелки,
тоже в виде масочек, и положим их в таблицу. То есть после этого тогда окажется, что вы,
собственно, динамику теперь считаете, ну потому что вам теперь не надо считать все промежуточные
узелки, вы считаете только вот, собственно, узелки прямо вот на месте. И получается,
в результате делаете вы это теперь за Н квадрат делить на, соответственно, К квадрат.
Спрашивается, вот, спрашивается, теперь что, спрашивается, какое каму теперь подгоним?
Делить на 8, потому что первая 2 в степени 2К на узелки. Каждое следующее как бы два варианта
от предыдущего, ну там стоит вот, так что поэтому тут 2 в степени К, тут 2 в степени К. А вторые 2
в степени К, потому что у нас строки, то есть у нас еще вот эта строчка размера К, а вот
эта строчка размера К, и они бинарные. Поэтому возникают вторые 2 в степени 2К,
потому что вот эти DPS зависит не только от этих узелков, но и от строчечек самих.
То есть мы подставляем лог N делить на 8, получаем тут, как всегда, корень из N на лог квадрат N на
64, плюс там 64 N квадрат делить на лог квадрат N. В общем, короче, это от N квадрат делить на лог квадрат N.
Правда, с константой 64.
Вот, по крайней мере, на уровне теории этот результат можно усилить. Предположим,
что у вас размер алфавит константного размера, но этот размер не два, а допустим альфа.
Что поменяется? Да ничего, да. То есть на самом деле просто вот эту двойку вторую,
где мы строчечки считали, мы заменяем на альфа. Так, а какое нам K теперь надо взять?
Чего лог делить? Нет, зачем? Я бы сказал так, лог два альфа, там, соответственно, N делить на
лог 4, чтобы тут опять корень был. То есть тут опять, ну, по сути, опять получится лог квадрат N,
но правда там прото лог будет уже по основанию альфа. То есть чем больше альфа, тем меньше этот
логарифм, соответственно, понимаете. Поэтому тем ближе это будет к реальному N квадрату.
Ну, типа, если у нас как бы последователи стоят из символов какого-то константа алфавита,
ну, там, допустим, это, то есть обычно это как бы Nоп для двух строчек каких-нибудь,
допустим, 26 буквок, тогда можно решать, вот тогда тут можно поделить на лог квадрат,
чем логарифм берется по основанию 52. Вот такая красота. Вот, но мы замахнемся еще на кое-что.
Да, ну, мы в принципе любим замахиваться. Вот, соответственно, сколько у нас там времени?
А, нормально. Давайте замахнемся еще. А что делать, если алфавит у вас не
константного размера? Ну, сейчас я возьму максимально типичную ситуацию. Альфавит
не гарантируется, что константного размера, но при этом гарантируется, что элементы этого
алфавита можно сортировать. Ну, например, числовая последствия. Ну, или там любое линейное
паралитичное множество подойдет. Так, ну, начнем с того, чтобы за NLogN можете сделать сжатие координат
и свести задачу к NLogN. И какой задачи свести такую задачу? И тогда свести задачу, что у нас
действительно этот алфавит альфа состоит из чисел от 1 до N. Ну ладно, формально для двух N,
но на самом деле заметим, что все элементы B, которые, если прижатие выяснилось, что в B есть
какие-то элементы, нележащие в А, то их можно и выкинуть. Поэтому можно тут даже не два N считать,
а просто 2. Будем такая типичная ситуация. Будем считать, что A и B состоит из чисел от 1 до N.
Так, теперь вот давайте думать, что мы можем выжать из этого?
Чему NLogN по основанию N? Ага, ну как Константина? Единица. Да, не помогает. Хорошо. А что дот?
Ну действительно, что еще можно сделать? Так, нет, погодите, ну давайте, нет, у нас же есть вот метод.
Так, давайте выберем K. И давайте теперь, так, ну давайте теперь просто почешемся. Так, ну давайте,
так, давайте теперь почешемся. Что за нот? То есть каким образом можно делать сжатие? Ну конечно,
если мы тут будем писать клеточки там что-то N в степени 2K, это будет, конечно, много.
Ну что можно сделать? Можно заметить маленькую прятную вещь. В каждой клеточке можно сжать
координаты дополнительные. Это можно сделать за, причем, кстати, да, вот, причем более того,
суммарно можно сделать сжатие координат за вот какую-то адекватную симптомику.
Что? Да нет, нет, нет, ну если в каждой прям совсем независимо делать. Ну давайте так,
хорошо, ладно. Так, ладно, давайте, ну давайте так. Заметим, в каждой клеточке размера K на K сжатие
координат за кало K сделать можно, правда? Тогда идея такая, то есть, тогда смотрите,
сколько у нас клеточек? Ну вот, нет, не с этой точки зрения, а в смысле различных клеточек,
вот этих вот с точностью до этих эквивалентностей. Да, ну сжатых, когда у нас, предположим,
в каждой клеточке числа еще и до K. Так, получается K в степени 2K на 2 в степени 2K.
Да, ну пока так пишем, так-то 2K в степени 2K и в каждый из них мы тратим, получается,
как квадрат времени на то, чтобы насчитать динамику. После этого мы теперь перебираем все
клеточки, но в каждой клеточке мы работаем, получается, за кало K, потому что у нас
сжатие координат за столько работает. Так, в общем, в переводе говоря, 2K в степени 2K на K
квадрат, значит, плюс N квадрат, значит, умножить на лог K делить на K. Так, спрашивается, какое бы
к нам подсунуть, чтобы было хорошо. Лог-лог N. Лог-лог N. Единственный... Так, какой, говорите,
так, ну поехали. Итак, 2 лог-лог N в степени 2 лог-лог N на лог-лог N в квадрате плюс N квадрат
умножить на лог-лог-лог N делить на лог-лог N. А теперь, уважаемые издатаки, что из этого больше?
Очевидно. Сейчас будет очевидно, но неверно. А так я не знаю. Я сказал очевидно. Ну, как вам
сказать? Я думаю, знаете, чем вы выгодно отличаетесь от снежного человека? Вам не
нужно читать лекцию про такие понятия, как ирония, сарказм, юмор и так далее. Так, ну ладно,
страшно спрашивать, конечно, но спрашиваю. А сказку о тройке кто-нибудь читал? Так, хорошо,
попроще. Понедельник начинается в субботу. А, ну правильно, да, действительно, как-то книжку
по программисту нужно читать. Ну, программист в институте волшебства, ну, логично. Действительно,
да. Так, и чё? И будет L в степени L, замечательно. И чем это поможет? Так, ну давайте попробуем. Да,
давайте скажем, что N равно 2 в степени 2 в степени L. Так, хорошо, получается 2L в степени 2L на...
что там получается? Так, на L квадрат плюс...
Ну, так, плюс 2 в степени 2 в степени L плюс 1 на... так, L делить на лог L. Ну, я не смеюсь,
это-то 2 в степени 2 в степени, а N квадрат это 2 в степени 2 в степени L умножить на 2,
то есть 2 в степени L плюс 1. Так, и чё? Да, логично, да. Да, вот эта штука действительно равна,
действительно, у нас на самом деле 2 в степени 2L лог 2 в степени 2L. Ну да, здесь вроде и тут
уже действительно становится очевидно, что это что-то прям очень сильно меньше. Да,
что-то... как это? Что-то да, лог-лог это прям сильно мало. Так, ну давайте попробуем,
что ещё можно сделать? Так. Так. Где-то, наверное, возникает. Так, ладно, давайте сделаем попроще.
Так, слушайте, а если я сделаю K равно просто лог N? Чё мы тут логаем-то? Слушайте,
давайте сразу эту идею вообще себе зафиксируем ещё, потому что мне она понравилась. То есть давайте
так, когда непонятно, что такое K в степени K, давайте честно запишем, что на самом деле вот
эта штука, это на самом деле равна, то есть 2 в степени 2K лог 2K на K квадрат плюс N квадрат
на лог K делить на K. Вот, и после этого давайте будем часаться. Это откуда?
Где тут будет лог N квадрат, извиняюсь. Тут просто лог N будет. Будет 2 лог N. Ну,
то есть будет 2 лог N. Давайте. Так, ну давайте попробуем хорошо. K равно лог N делить на
лог N. Так, ну давайте подставлять это. Получается 2 в степени, ой, давайте на 4. Тут уже двойки есть.
Поэтому да. Итак, поехали. 2 в степени лог N делить на 2 лог N. Замечательно. На логарифом этого же
безобразие. Лог N. Так, это ещё домножить на лог N делить на лог N и всё это в квадрате. Так,
что у нас теперь? Плюс N квадрат на... Так, ну поехали. Лог этого безобразия делить на лог N. Делить
на лог N. Делить на лог N. Четёрка, ой-ой-ой. Ну хорошо, давайте тут четёрка. Что тут ещё? Тут
четёрка. И тут четёрка. Ну это мелочи. В общем-то, тихо-тихо это мелочи. Так, ну давайте разбираться.
Ну заметим, что... А что мы заметим-то вообще? Ну ладно. Ну на самом деле с точки зрения
оценки сверху у нас имеет место шлёп-шлёп. Как всегда. Поэтому 2 в степени, тут лог N пополам
остаётся только и получается, что это да. То есть получается что-то типа корень из N сверху на
лог квадрат N. На самом деле надо ещё что-то поделить, но это уже по барабану. И здесь получается...
Так, а тут получается N квадрат. Ну заметим так, а симпатически, кстати, лог от лог N делить на
лог лог N, а симпатически это то же самое, что лог лог N. Ну потому что это равно лог лог N
минус лог лог лог N. А лог лог лог N это очевидно умалое от лог лог N. Вот. Поэтому тут оставляем лог N.
Тут оставляем тоже лог N. И получается тут вообще мистическая штука. Лог N на лог лог N ещё и в квадрете.
Ну конкретно тут... Да, безусловно, безусловно. Поэтому да, у нас проблемы. Ну как проблемы? Мы
получили решение быстрее, чем за N квадрат. Да, это быстрее, чем за N квадрат. Ну теперь вот
остаётся... Ну вот. Так, ну давайте подумаем. А можно ли тут ещё что-нибудь всё-таки пооптимизировать?
Да, как говорили тому же Капелёвичу, а если подумать... Ну это рассказывал, да, как пойти, да.
Как Капелёвичу учили искать Гамильтонов путь. Ну это классическая история. Приходит такой
учитель в красном плаще и говорит, так сегодня мы снова будем учиться программировать. Вот тебе
задача найти Гамильтонов путь в графе. Ну Капелёвич, ну тут перебрать, тут перебрать, тут перебрать. За N
квадрат могу. Так, учитель, а если подумать? Ну тут отсечь, тут отсечь. А да, учитель, вы правы, за N квадрат
можно. Не так неплохо. А теперь подумай, нельзя ли оценить твоё решение лучше? Ну как, учитель?
Используй силу, силу амортизационного анализа. Ой, за N квадрат можно. Именно, вот теперь садись и
пиши, а я пойду отдохну. И, кстати, на тесток Сюги вообще линейно работать будет. Как говорится,
звёздные войны в ЛКШ бывают вот такими. Причём самое, причём действительно очень страшно,
да. Пошли сидеть, да, он сидит, что-то кодит. Господи, как же это за кодить? Ну, там доходящая
сзади фигура в чёрном пафе. Используй силу, силу СТЛ. Да. Так, ну догадывайтесь, на каком языке
светлые силы кодили там, да? И как они назывались, да? Они назывались Джавайи, да. Как назывались,
тёмные силы, рассказывать не надо, да? Вот, да, мистическим образом в ритоте капида, почему-то
в процессе капеллёвки превратился в лопатину, но это другой вопрос, да. Ладно, так вот, ладно,
начнём с первого шара. А если подумать, можно ли тут как-то вот, хотя бы на это, ну, то есть понятно,
тут мы, конечно, уже действительно больше не выжмём, поэтому, а отсюда мы больше можем выжать?
Ну, может, нет. Нет, я говорю, тут не надо переписывать,
я говорю, из алгебры мы больше ничего не сделаем. Тут как бы искать вопрос, а нельзя алгоритм чуть
получше реализовать? Вот давайте, начну с простой подсказки. Такой с простой. А точно прям сжатие
надо делать. Нет, мы уже знаем, что изначально у нас числа от 1 до n.
Ну, по сути так. Заметим, что это каждое сжатие можно проводить за отка просто с помощью хэшмапы.
А теперь заметим, что хэшмапу, если у вас заранее есть заготовленный массив от 1 до n,
то в общем-то хэшмапу можно реализовать без хэшей. То есть как бы, потому что элемент равный и вы
просто записываете в эту ячейку. Главное потом не забыть пробежаться и за те же отка всё там
стереть обратно. Так что на самом деле никаких там лишних логарифмов тут нету и на самом деле
тут н квадрат делить на к. Вот теперь думаем, вот давайте вот этот вот мы убили логарифом.
Спрашивается, что теперь, а что у нас теперь? Так, но на самом деле, да, что поменяется? Да,
но есть подозрение, конечно, что для того, чтобы штука была меньше там меньше н, но где-то
близко к нему, да, то есть чтобы вот эта штука была там какая-то там что-то логарифом n поделить
на что-нибудь там где-нибудь, то тогда оказывается, что оптимальная k примерно такой же. В результате
опять это опять всё не превосходит там корень из n на там лог квадрат n, но разница только в том,
что здесь никакого лога нет, поэтому здесь получается n квадрат на получается ну там 4 на
лог лог н делить на лог н. И квадрата как-то и квадрат алгорифма нету, ещё и лог лог н вылез.
Спрашивается, можно ли сделать что-то ещё?
Да, если по-другому, да, то есть в чём у нас проблема? Да, мы видим, да, у нас есть, конечно,
да, мерзкая проблема в том, что нам как бы, чтобы n квадрат вынужденный после деления на k квадрат
ещё и давно нажать на k, потому что к сожалению сжатие координат у нас, конечно, такое не очень.
Что? Да, только строчки нам дают элементы от 1 до n, поэтому вот так. Нет, ну не совсем,
получится, но в этом направлении направление правильное. Так, так ребят, тихо, тихо, тихо,
тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, т
тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, т
это не получится второй раз применить мета-четырех вопрос в них уже для такой-то задачи
не знаю, ну пока-пока я не понял что имеется в виду, так что зачем мне здесь нужна вторая константа
вторая не нужна, да, но имеется в виду, что мы можем как-то отдельно жимать карназы, чтобы было быстрее
так, ну да, нет, хотелось бы, нет, ну в принципе да, но на самом деле да, то есть идея тут
действительно в эти стороны бродим туда, мы могли бы пытаться сжимать координаты как-то быстрее
если бы у нас элементы были хотя бы от одного дока или хотя бы от чего-то подобного
поэтому то есть да, то есть на самом деле да, идея здесь конечно в этом месте заключается такая
да, у нас и так есть вот рыжие метаклетки, сейчас мы из них будем делать метаметаклетки
да, ну давайте я это сотру, просто общую картину поняли, да, то есть где-то у нас там то есть черная
клеточка, то есть черная сеточка становится совсем маленькой, маленькой и получается примерно следующее
значит у нас черная, это у нас рыжая, это у нас красная, ну вот, значит у нас, напоминаю, есть рыжие
клеточки размера к, там вот как-то так это выглядит, рыжий маркер посыпался, да ничего, так вот
и так вот теперь, значит, идея такая, что мы на этих клеточках, ну давайте не будем вводить вторую константу
то есть эту сетку из метаклетчик тоже поделим на, то есть метаклет, то есть получается каждый размер вот этой красной клетки
это получается даже не к на к, а даже как квадрат, так как квадрат, то есть к на к метаклетчик
да, мясо, да, ну что делать, вот, что же нам это даст, ну идея такая, мы можем, смотрите, мы можем попытаться
потратить значит на сжатие, ну во-первых, идея такая, то есть давайте сделаем сжатие координат, то есть будем делать сжатие координат
координат сначала по красным клеткам, сколько нам времени это займет, это получается нам займет что-то типа
n квадрат делить на k в четвертый, вот это вот, это как квадрат, вот, каждое будем делать сжатие за k квадрат
так, вот уже и получился n квадрат делить на k квадрат, о котором мы мечтаем, да, вот, значит получается так, хорошо, сжали
так, то есть получается каждую клеточку мы умеем сжимать адекватно, но что это нам дало, это нам теперь дает такое, что в каждой метаклеточке
у нас теперь чиселки от n квадрата, от одного до k квадрат, и получается, ну вот, да как квадрат, для нас как квадрат, но что это нам дает
то теперь просто идея такая, то есть теперь нам надо научиться, для того, чтобы делать сжатие координат в рыжей клеточке, нам теперь нужно научиться получается делать
сжатие координат на, ну вот, сжатие координат, то есть для строчек размера k, но при этом имею в виду, что символы там теперь не от одного до n, а от одного до k квадрат
так, делаем на них тотальный предподсчет, будет у нас он работать за, сколько там получается, получается, что там получается, там что-то типа, ну ладно, давайте сразу скажу
2k квадрат в степени 2k, вы видите, приятно, тут квадрат есть, а тут нет, то есть вот всего столько клеточек, и каждую такую клеточку мы, естественно, обсчитываем за k в квадрате
что это нам дает? то есть это нам на самом деле дает очень много шум, потому что я утверждаю, что мы теперь каждую клеточку теперь проходим за единицу
то есть, ну на самом деле так, как пройти нот, ну точнее так, вот, потому что нот, ну по сути да, то есть с помощью вот этих вот сжатий, то есть у нас получился, так сказать, класс эквалентности для каждой клеточки, точнее ее тип
ну тогда если мы для каждой клеточки вот этой рыжей знаем ее тип, то мы ее проходим за у от единицы, и в результате, то есть потом рыжие, то есть вот этих вот рыжих проходов у нас в конце окажется n квадрат делить на k квадрат
то есть мы добились того, просто что сжатия координат на самом деле тоже стали n квадрат делить на k квадрат, понятно, да?
вот, так, ну вот теперь внимание, вопрос, какое же k теперь мы хотим?
да, да, господи, да, тут прям все одно, да, тут прям, да, прям это, да, скучно, нет, ну почему?
нет, ну почему? ну почему наоборот, иногда даже позитивно, если у вас это, если вам не случайно дали в руки молоток, вы идете при этом, выясняется, что он везде работает
ну как бы у кого-то молоток, у Бахметева, например, это обычная пластиковая бутылка там, ну и так далее, вот, так, и так, поехали, там, соответственно, господи, так, ладно, еще понизим планочку, кто знает, кто такой Андрей Бахметев?
о, кошмар, слушайте, в каких разных мирах мы живем вообще, господи, а кто знает вообще, хорошо, какого-нибудь словосочетания пока все дома что-нибудь говорит, а словосочетания о чумелые ручки, понятно, да, нет, ну хотя ладно, вы уже то поколение, которое телевизор не смотрит, логично, да, да, кошмар, были времена, да
спасибо, я смотрел, если что, да, то-то я туплю, да, действительно, так, значит, поехали, n квадрат плюс 2 в степени 2k лог 2k квадрат на k квадрат, так, мы пытаемся ка подставить вот это вот.
Ну, по большому счету, да, сейчас чего вынести?
4k лог
На 8 надо
Уже на 8?
Да, потому что там k квадрат, лог 2k квадрат, лог еще вынесется
Ой-ой-ой, ну ладно, ну хорошо, 8 так 8, да, хорошо, ладно, это меньше либо равно, чем, давайте так, я пока, пока я не буду, значит, n квадрат k плюс 2 в степени, сколько там получается?
4k лог 2k, еще на k квадрат, ой, ну n квадрат, ну я их в один запихал, неинтересно, неинтересно, так, что еще у нас есть?
Так, хорошо, значит, теперь подставляем, там при подстановке выяснять, что это меньше либо равно, чем, значит, сколько там, 64 n квадрата на лог лог n в квадрате делить на лог n в квадрате, плюс, что там у нас получается?
Так, так, да, ну да, тут как бы и да, подставляем, лог лог n, тут на лог лог n там поубивается, поэтому, да, как всегда, корень из n, там лог квадрат n, так, ой, ну правда странно, видите, тут n, ну да, тут, тут вот возникает вопрос,
а нельзя ли еще поупихивать? Пока это получается тета от n квадрат на лог лог n делить на лог n все это в квадрате.
А что, поможет?
Нет, это да, но конкретно...
Нет, ну вы подозреваете, что вот это слога, да.
Вот это слога, да.
Нет, тут...
Ну да, ну нет, тут это да.
Ну, смотря как менять, если мы увеличиваем k, то мы как бы увеличиваем k, то мы уменьшаем вот эту штуку и увеличиваем вот эту.
То, с другой стороны, заметим, что слишком сильно увеличить эту штуку нельзя, потому что мы k можем увеличить на во сколько там, как там можем увеличить.
То есть, если мы подставим хотя бы 4, то как бы есть риск, что тут уже, как говорится, от n-ты и вылезет.
Вот, поэтому, соответственно, поэтому, кажется, принципиально другому мы тут уже ничего не сделаем.
Ну, значит, придется на этом восстановиться.
Нет, ну хорошо, давай подставим.
Тогда, смотри, тогда что тут будет?
Тогда здесь будет, тогда 4 до 4 тут сократится, будет log n, делить на log log n, умножить на там, на что-то, что там, близко к log log n.
Ну, а симпатически, по крайней мере.
Ну да.
Ну, хотя нет, не совсем, то есть там, хотя нет, там, хотя не, хотя не...
Хотя нет, а знаете что, давайте-ка, может, мы не совсем аккуратно, знаете, все-таки давайте-ка потратим время и подставим.
Вот давайте, подставим, кандидит на 4, но сделаем это предельно, попробуем сделать это предельно аккуратно.
Так, значит, давайте, пишем честно.
Так, ну ладно, тут 64 превращается в 8, тут прям честно, да.
А что тут получается? Откуда? 16. Ну, 16. Ну хорошо, 16, так 16, пожалуйста.
Так, ну давайте разбираться, подставляем 2 в степени, 4, так, ну там пошлеп-шлепали, поэтому log n делить на log log n,
на логарифом log log n делить на 4 log log n, да.
И все это на log n делить на 4 log log n в квадрате, да.
Нет, я по-другому напишу, я... Нет, я не все сотру, я просто скажу, что это как в квадрате.
Понятно, да?
Ну да. Так.
Так, ну хорошо, нет, просто...
Так, нет, просто вопрос, что это даст, просто конкретно тут просто... Нет, у меня просто идея возникла, что это равно...
Что это, допустим, равно пока n квадрат делить на k квадрат, давайте лучше честно напишем, да.
Плюс, смотрите, что это такое.
Дело в том, что на самом деле это равно 2 в степени, log n делить на log log n, и здесь домножить на в скобочках.
Так, тут log log n, в скобочках пишем log log n минус логарифом 4 log log n, на k квадрат.
Вот, что же тут у нас получается.
Это на самом деле равно n квадрат делить на k квадрат, плюс...
Ну на самом деле, в первом, получится, я утверждаю, что 2 в степени на логарифом n делить на 2 в степени логарифом 4...
Нет, не 4.
Там там мясо, да.
Там 2 в степени сейчас log n делить на log log n, а тут логарифом 4 log log n.
Нет, тут, как сказать, если тут скобочек раскрыть, то в одной log log сократится, а в другой тут еще мясо.
А, тут еще и 2 лога, кстати, log log от 4 log log n.
Четверку вынести...
Ну, можно, да, будет.
Так, ну хорошо.
То есть, нет, это получается...
Нет, это, в общем-то, не сильно принципиально.
Там получится просто так.
Получится просто n, а тут придется, если уж в точности его, на что-то поделить.
Причем это, что-то оно...
Это, что-то, да.
Главное, ничем не помогло, потому что симпатику здесь все равно никак не меняет, а тут как бы...
Ну, скажем так, то, что это, как бы, не о малой от n, это нам ставит немножко под угрозу.
Ну, скажем так, это, по-моему, не дает нам сильного ресурса для того, чтобы там была победа.
Я что-то не вижу пока.
Ну, можно просто сказать, что, окей, log-log n это что-то маленькое.
Давайте забьем на него, оценим сверху как.
Но вместо log-log n, напишем...
Вот, лог 4 log-log n, напишем ноль.
И как оно получится?
Вот, то самое n квадрат длинный как квадрат, плюс n как квадрат.
И еще?
Ну, это все еще, это от n квадрат длинный как квадрат.
А чем нам это помогло-то?
Ну, разве что.
Ну, разве что.
Ну, понимаете, пока мы тут не сделаем что-то принципиального, я не знаю.
То есть, не заявим, что k равно log-log n делить на корень из log-log n, например.
Ну, да.
А, ну, какая разница?
Нет, тут как бы была бы мечта только возникает вопрос, а можно ли тут хотя бы одну двоечку log-loga тут убить?
Нет, понимаете, ситуация такая.
Просто мы как бы к чему мы вообще пришли, да?
То есть, мы умеем, получается, решать задачу об n-op в ограничениях, когда у нас элементы сравниваем между собой.
Засим точку n квадрат умножить на log-log n делить на log n и все это в квадрате.
То есть, вот не та мечта, чтобы n квадрат делить на log квадрат, она как бы получилась до log-ru квадрата.
Вопрос было бы круто, конечно, если бы хотя бы двойку из числителя удалось бы убить.
Но, впрочем, если честно, как говорится, я не уверен, что человечество знает, как это сделать.
Ну, в принципе, да.
Я не знаю, есть какие-то подобные идеи из архивной статьи брались, на самом деле.
Но как бы в оптимале log-log в квадрате, то есть у меня иногда было ощущение, что log-log без квадрата.
Но совсем от него избавиться не удается.
Но тем не менее, вот такое выжить удается.
То есть, не то чтобы...
То есть, формально, видимо, чемпионская симптотика.
То есть, вполне верно, что это лучшее, что знает человечество.
Но соответственно.
Так, ну что, есть ли тут какие-то вопросы?
Так, ну если нет, тогда перегрев.
То есть, видимо, суперядерного сегодня уже не будет, потому что тупую уже не успеем.
Вот в следующий раз, видимо, будет тот OLCS по такому раскладу.
В общем, да.
В общем, очень мощная задача на НОП.
Но это будет отдельный взрыв мозга, сразу предупреждаю.
Просто обычно по опыту часа три называется на нее надо.
Нет, ну не знаю, может с вами будет быстрее, я не знаю.
За столько лет он обычно как-то...
Рассказывается, конечно, за полчаса.
Нет, пишется за 10 минут, там код просто минималистичный.
Но проблема в том, что у нас на парке цель, чтобы я не просто рассказал какие-то заклинания,
а чтобы вы еще поняли, о чем это вообще.
А обычно, чтобы с этого разобраться нуля, там все-таки называется три часа обычно надо.
Что?
Нет, ну это был просто ОНОП.
Нет, я имею в виду, что Ляймна ксиста.
Нет, ну погодите, так-то нам придется, как-то надо будет и Хишберга еще обсудить как минимум.
Нет, понятно, что там нечего особо обсуждаю.
Ладно.
Сегодня мы, пожалуй, давайте...
Хочется сегодня закончить просто с деревьями.
Но просто есть такие пара простых, таких вещей, которые достаточно простые,
но как бы просто важно их понимать надо.
Поэтому хочется сегодня обсудить там вместе с антроидной декомпозицией и, собственно, на этом и закончить.
Потому что давайте себе представим данные, конечно же, задачи про изоморфизм деревьев.
Потому что можно сказать, что самые интересные задачи сегодня сейчас будут задачи об изоморфизме деревьев.
То есть даны два дерева, скажите, пожалуйста, изоморфны ли они?
Да или нет?
Ну, в идеале, конечно, еще и желательно, если да, то как?
Да.
Ну, типа, ну, как бы, чтоб чекеру было удобно проверять.
Вот.
А то как бы вот.
Нет, хотя нет, я снова ему, конечно, так и так будет удобно проверять.
Ну да.
Ну да, поэтому я снова проще.
Так-то да.
Но так, по крайней мере, знаете, получается, если есть ЗЕС, то есть если юзер вывел ЗЕС, то его проверить, то как бы его можно заведомо проверить.
Вот, тогда чекеру придется проверить.
Авторский ответ тоже ноут.
Да-да.
Нет, ну если, ну да.
Если нужно знать, существует ли биекция.
Ну окей, ладно, тут уже так, окей, так.
Так.
Ну да, да, да.
Даны два теря, вы видите биекцию между ними, гарантируется, что биекция всегда существует.
Интересная задача.
Можно без автора.
Ну погодите.
Но для начала, для этого придется исследовать вообще, что такое дерево, как оно условно.
Ну понятно, что такое дерево, связанное с гравбис-циклов, это понятно.
Да, что такое подвешенное дерево, дерево, у которого одна вершина почему-то обзывается корнем.
Ну окей.
Ну а первое, конечно, что обсудим, это...
Ну давайте подумаем, что такое вообще эзоморфизм.
Ну на самом деле тут, конечно, можно относиться немножко к топологии.
Чем занимается вообще топология?
Да.
Нет, ну на самом деле нет.
Вот, да, это называется аудез была.
И там, в принципе, топология на самом деле изучает какие-то общие для каких-то вот пространств, поверхностей и так далее инварианты.
Ну то есть по сути, мы там, я не знаю, берем тесто, начинаем его растягивать.
Или там как-то вот там мять или что-нибудь еще с ним в этом смысле делать.
То есть внимание вопросов, какие варианты при этом будут сохраняться.
Вот.
Ну там вот что-то в этом роде.
Ладно.
Не знаю.
Вот.
Так вот, здесь у нас тоже давайте подумать.
Если мы возьмем дерево и начнем у него там вершину перенумерировать, что у него будет сохраняться?
Да, количество вершин, безусловно, будет.
Степень вершин.
Да, набор степеней вершин, конечно, тоже будет сохраняться.
Так.
Ну вот, конечно, такая нетривиальная вещь.
Это, конечно, диаметр.
Не, ну как?
Ну и количество.
В первую очередь, конечно, диаметр.
Но тут, кстати, это уже на самом деле интересная песня.
Потому что вот действительно есть диаметр.
Что такое диаметр?
Это самый длинный простой путь в дереве.
Да?
И теперь очень хочется понять.
Хочется вопрос.
Как его найти?
Да, ну как бы да.
Есть два способа.
Первый называется, давайте запустим две динамики на под деревьях.
А, ну можно даже одну.
Хорошо, можно даже одну.
Ну там по-разному можно делать.
Да, то есть идея в том, что подвесим за какую-нибудь вершину.
И давайте там скажем, для каждой вершины найдем длину пути, у которой лца именно эта вершина.
То есть для этого вам нужно, для каждой вершины,
во-первых, просто научиться насчитывать вот это вот.
Ну что-то типа Logis Post Decomposition.
Ну, короче, самый длинный путь из нее в ребенка.
А потом для каждой вершины, если вы знаете эту штуку для детей,
то надо просто из них выбрать два максимума и через нее поконнектить.
Вот.
То есть этот метод так относительно сложно пишет.
Оно относительно, конечно.
Но зато он самодоказывающийся.
Да.
Но есть, конечно, более известное решение такое популярное.
Просто, конечно, оказывается так.
Берем первую попавшуюся вершину, находим из нее самую удаленную.
Берем эту вершину и из нее находим самую удаленную.
Утверждение.
Вот это диаметр.
Да, это максимально просто.
Может быть, максимально просто пишется для всех.
Только возле нот.
Пока вас не спросят, а почему это найденное вообще имеет отношение к диаметру.
Метрику можно вложить в конечное мирное пространство.
В это пространство это удовлетворение очевидное.
На самом деле, адекватный пруд.
Ты можешь просто по диаметру посмотреть.
Да, да, да.
Если диаметр зафиксировать, то у тебя от каждой вершины
самый дальний путь в нее будет в один из концов диаметра.
Вот так.
Не, смотрите.
Так, погодите, погодите.
Давайте не будем сейчас просто откатать все с места.
Давайте просто все это нарисуем и изучим подробнее.
Тут попутно на самом деле еще будет интересно.
Да, потому что так-то да.
Можно, конечно, вводить там какие-то метрики на конечном
мирном пространствах, но как бы да, знаете.
Но как бы это, да, семиклассником это особо не объяснишь.
Значит, оказывать будем так.
Ну, во-первых, на самом деле интересно посмотреть вот то, что.
Значит, мы посмотрим на два разных случая.
Значит, первый случай.
Наш диаметр делится на два.
Вот так.
Пять, шесть, семь, восемь, девять, десять.
Вот, допустим, я рассмотрю какой-нибудь диаметр.
Вот эту вершину посередине я назову диаметром.
Я назову центр.
То есть я назову центром.
Я назову вершину, которая лежит на сей день какого-то диаметра.
А теперь, значит, смотрите.
Значит, теперь рассмотрим.
Ну, просто вот у какого-то диаметра есть центр.
И от него отходят два пути длины.
Ну, получается вот это вот Д пополам.
Ну, на самом деле много тут отчего отходит.
Тут еще под деревья какие-то есть.
Но можно заметить, что если объявить этот центр корнем,
то отходить мы от него в любую сторону будем на глубину не более чем Д пополам.
Потому что если хоть куда-нибудь мы отойдем на глубину там больше,
то тогда у нас и получится путь больше, чем Д.
Но тогда получается, смотрите, как устроены вообще диаметры в принципе.
Тогда получается диаметры устроены так.
То есть либо они не проходят через вот эту вершину,
но тогда они тут лежат где-то в поддереве,
и они как бы, получается, идут в сторону этого центра,
значит, на расстояние меньше, чем Д пополам,
а потом спускаются на расстояние более, чем Д пополам,
то есть диаметры не получается.
А если они проходят через центр,
то они, значит, из какого-то поддерева подымаются
на длину не более, чем Д пополам
и идут в другое поддерево на длину не более, чем Д пополам.
И более того, диаметром это получится,
только если у вас тут получится ровно Д пополам здесь и ровно Д пополам там.
То есть получается, этот центр будет являться центром не только вот этого первого диаметра,
но и вообще любого диаметра.
То есть мистический факт оказывается в том, что центр в дереве один.
Да, но правда давайте я сразу говорю,
то есть что если диаметр нечетный,
то центром я назову на самом деле не центральную вершину,
а центральное ребро с двумя вершинами.
5, 6, 7, 8, ну допустим 9.
То есть тогда здесь я центром назову вот это ребро
и тогда здесь можно аналогично,
даже еще более простым образом доказать, что центр один.
То есть смотрите, какой интересный факт, видите?
То есть оказывается действительно диаметров у дерева может быть огромное количество,
а центр один.
Неплохо тогда.
Да, кстати, не путать понятия, кстати, внимание,
не путать, пожалуйста, понятие центр с понятием центроид.
Да, потому что многие действительно там путаются,
что-то пугаются, то на самом деле это то есть как бы оба понятия простые,
но просто разные.
Ну, скажем так, вот допустим рассмотрим четный случай.
Рассмотрим любой диаметр.
Как он устроен?
Он, утверждение, этот диаметр через вот этот вот центр,
ну давай назовем эту вершину там В,
через вот эту вершину В точно проходит.
Да, потому что в любом подъеме будет строго меньше.
Но, значит, диаметр проходит через вершину В,
и тогда этот диаметр делится этой вершиной В на два кусочка,
но каждый из этих кусочков длины не более чем D пополам.
Ну, так как там левая часть не более чем D пополам,
правая не более чем D пополам,
но сумма должна быть D.
Следовательно, там D пополам, D пополам, В центр, ура.
Ну, здесь будет то же самое, но там оставим в качестве упражнения.
То есть центр это свойство диаметра?
Нет, это свойство дерева.
То есть как бы у каждой вершины,
то есть у дерева есть такое вот понятие,
как центральный, то есть такой вот просто центр,
и это одна вершина, ну или одно ребро,
которое жестко определяется.
Да, ну просто оказывается, что она от диаметра не зависит.
То есть дальше там начинаются веселые задачи вида,
там найдите количество диаметра в дереве,
ну понятно, по сути, с какими способами можно выбрать лист
на расстоянии D пополам от центра,
из разных поддеревьев.
Для ничего ты еще тупее.
Вот тебе надо просто количество листов из этого поддерева
умножить на количество листов из этого всего.
Да, потому что тут всего два поддерева,
с той стороны и с этой стороны.
Так что вот этот случай даже более сложный,
потому что тут как бы бывает несколько поддеревьев,
они там все могут быть глубины D пополам.
Ну совсем отсылка, вот просто звездочка.
Так, ну теперь, значит,
на самом деле глядя на это понятие,
можно уже подоказывать пару интересных фактов.
Например, докажем наш алгоритм
про поиск диаметра.
Значит, утверждение.
Когда вы запустите первый DFS,
вы попадете обязательно в лист,
который будет находиться
на расстоянии D пополам от центра.
Почему?
Ну как минимум,
допустим, вы находитесь на расстоянии
L от центра.
Ну тогда утверждение такое.
Во-первых, вы не уйдете
на расстояние от этой вершины
на расстояние больше, чем
L плюс D пополам.
Ну потому что вы некоторое время
будете приближаться к центру,
а потом уйдете от этого центра куда-то,
но дальше, чем на D пополам, не уйдете.
Утверждение номер два.
На такое расстояние вы пройдете.
Для этого вам нужно просто пройти
вот эти L, а потом уйти в другое под дерево.
Но очевидно, что для этого вам придется
именно что уйти в лист на расстоянии D пополам.
То есть вывод.
После первого DFS вы попали в лист на расстоянии D пополам от центра.
Но при этом
мы заметим тогда, что любой такой лист является концом
какого-то диаметра.
Потому что вы просто идете в центр
и знаете, что тут
существует еще хотя бы одно под дерево
с расстоянием D.
Но потому что вы знали, что у вас их в принципе два.
Хотя бы два. Может три, четыре, пять.
Попута, кстати.
Ну попута, естественно, вы еще...
Таким образом мы нашли диаметр,
ну и соответственно центр, кстати, тоже.
Потому что
мы можем пройти
за расстояние L до центра.
И теперь мы знаем, что существует другое
под дерево, в котором глубина
ровно D пополам.
Но мы знаем,
что существует хотя бы два, поэтому если мы из одного
из них пришли, значит пойдем в другое.
А в том же
под дереве... Нет,
тогда бы мы до центра не дашли, если бы не вылезали
из того же под дерева.
Просто утверждение, существует хотя бы два
под дерева, глубина D пополам.
Ну потому что какой-то диаметр
существует. Тогда если
ты пришел из одного под дерева, просто
пойдем в другое.
То есть у нас вопрос, что оно существует.
И мы можем так сделать.
Таким образом получается, что
диаметр находится, центр
находится.
Но тут
на самом деле неожиданно выясняется, что мы можем
решить и задачу про изоморфизм
деревьев.
Потому что отсюда уже возникает наша
первая неожиданная оптимизация.
Мы знаем вершины, которые точно
должны переходить друг в друга.
Первое, что мы должны проверить,
а вообще одинаковые ли у них
диаметры? Если у деревьев
разные диаметры, то, в принципе, до свидания
сразу. Ну можно еще там пару
метров проверить. Ну можете, пожалуйста,
там проверить себе стее, там набор
степеней вершин, там, пожалуйста, и так далее.
Там все что угодно. Но так, в принципе,
вы находите диаметры. Но если
диаметры совпали, то значит
центры должны переходить друг в друга.
В этом случае вам повезло, если диаметр чётной длины,
потому что центр прямо переходит чётко
в центр.
Здесь все хитрее, здесь у вас, в принципе,
два варианта есть.
Ну там есть вот это вот центральное
ребро. Оно как бы может совпадать вот так, может
вот так.
Но это все
с точностью до
домножения на константу сводит
задачу
к проверке изоморфизма
подвешенных деревьев.
То есть корни у нас не было,
но оказывается для нас это за ОАТН
не проблема.
Итак, задача.
Даны два подвешенных дерева.
Разрешается
изоморфизм, рассматриваемый изоморфизм,
только переводящий корень в корень.
Спрашивается, изоморфны
ли деревья?
Вот такая
задача.
Да, мы нашли за что подвесить.
Да.
Да.
Да.
Напрашивающаяся идея, давайте
хэшировать подвешенные
под деревья.
Ну, на самом деле можно, но сейчас
дойдем. Да, как это ни странно,
в данном случае нам поможет
хэширование, просто мы научимся
делать это без хэшей.
Ну, потому что идея такая.
Потому что, ну, на самом деле основное,
что нам хочется, потому что идея как бы такая,
то есть как хэшировать под дерево.
Надо пойти в его детей,
из каждого
дерева,
значит,
из каждого дерева, под дерева
рекурсивно достать хэш.
Ну, дальше, так как у нас с точностью
дозиморфизма отсортировать
эти хэши.
Прямо посортировать в явном виде.
И у вас получается такой
четверной, то есть там
массив, в данном случае на 4 хэша,
в данном случае на сколько там детей.
И, собственно, остается вам только захэшировать
вектор.
Вот, понимаете, да?
То есть, ну, там хэш какой-нибудь,
наверное, можно придумать.
Ну, да.
Ну, по сути,
N log N, ладно, формально там, конечно,
формально в таком виде,
ну, если вы адекватно хэш какой-нибудь полинамиальный делаете,
допустим,
то там получается
N
log, там максимальная степень,
на самом деле, если внимательно думать.
А, ну,
в принципе, смотрите,
ну, есть чит такой,
нет, есть еще чит такой,
но, на самом деле, каждому дереву можно сопоставлять
правильные скобочные последствия, правда?
Так вот, идея такая, а можно сопоставлять их
аккуратным образом.
А именно, когда вам достаетесь деревья в правильные
скобочные последовательсти, вы сортируете.
И только после этого там вот начинается
ставить, то есть вот как бы заводите 4 скобочки
и вставляете в них вот эти вот скобочные
последствия, снято 4, но только вы их
лексикографически сортируете.
Не, ну, можно не добавлять,
если у тебя одна, ну, скажем так,
сейчас.
Ну, там, да, можно сказать, что, да,
если у тебя одна вершина, то, допустим,
там просто пустая последовательность,
например.
А если у тебя кайдите, то вот рисуем
вот это, вот и все.
Вот, например, так.
Вот, то есть, выглядит вот такое.
Но теперь возникает вопрос, а можно ли обойтись
без хэшей?
Оказывается,
вполне можно.
То есть, идея
на самом деле такая.
Ну, да, но
правда тут, конечно, там.
Поради,
какой суффиксный массив, если
так, да, но несколько строчек отсортирую их,
а какой?
Так, нет, ну, хорошо,
да, ну, тут, хорошо, да,
то там проблема в том, да, какая
суммарная длина будет.
То есть, сколько суммарно?
То есть, в каждой вершине ты будешь работать за от
количества вершин в подделье.
А приравных?
Можно переливать.
Нет, в явном виде переливать.
Нет, вообще,
вообще, идея хорошая.
Нет, смотрите, да, можно на эту тему подумать.
Смотрите, давайте подумаем, действительно,
что давайте сортировать последствия
в первую очередь по количеству вершин в подделье.
Ну, СССР мы можем посчитать.
Да, замечательно.
Остается только вопрос, то есть, теперь идея такая.
Давайте только, если у нас есть равные
по размеру под дерево последствия,
тогда мы их тут,
тогда мы с ними будем что-то делать.
Да.
Чего?
Нет, при равных размерах, ну,
нет, ну, их надо отсортировать и сеграфически, чтобы было однозначно.
Ну, я и говорю, сначала по размеру,
потом минимально и сеграфически, это да.
Нам нужна однозначность, да.
Но давайте только, если у нас нашлись равные СССР,
тогда мы для них
уже эти скобочные последовательности
там как-то, там, видимо, в явном виде
генерируем.
Там генерируем, сравниваем и выбираем, кто первый,
кто второй, кто третий.
Ну, номер он тоже длинный, так что не поможет.
Вот, так вот.
Хорошо, скобочные последствия.
Почему-то какие-то переливашенные моменты
намекают, что это тоже может работать за n лог n или
хотя бы n лог квадрат.
Нет, но давайте думать.
Нет, давайте думать.
Ну, действительно, давайте подумаем,
как это действительно может быть.
Ну, на самом деле, то есть, заметим следующее,
что можно сказать, что когда мы сортируем
скобочные последствия, мы просто
говорим, что у нас, что у нас тут,
то есть, вот, допустим, если у нас оказалось,
что вот эти поддеревья равны,
то тогда мы можем в некотором смысле сказать,
что каждая вершина этого поддерева
участвует вот в этом вот сравнении.
И мы делаем это сравнение за o от количества
вершин в этих деревьях.
Ну, честно, выписали стройские сравнения
с помощью бора, например.
От количества вершин
с равными размерами?
Нет, от количества вершин
в равных по СС
под деревьях.
Вот.
И тогда вычекает вопрос. То есть, получается,
можем будем говорить, что в таких сравнениях
все вершины под деревья участвуют.
Просто это удобно мыслить. Удобно мыслить
в следующих терминах. А сколько раз
каждая конкретная вершина
на самом деле может участвовать
в такого рода сравнениях?
Ну, заметим.
Я утверждаю, что логарифм.
Потому что если размер
вот этого поддерева x и вот вершина
в нем участвует, то если на более
высоком уровне эта вершина опять будет
участвовать там в более высоких вершинах,
то ССС там будет уже как минимум 2х.
Ну вот. Так что в результате
так что получился.
Единственное только, алгоритм
будет такой технически сложный
немножко в том плане, что вам придется, конечно,
эту правильную скобочку в последствии в явном
виде выписывать.
Бор это не проблема
сделать на две скобочки.
Единственная проблема, что эти строчки
надо геней, то там это как бы понятно.
Потому что вам в каждой вершине нужно расписывать
в каком порядке перебирать ребра.
Если вы этот порядок знаете,
то ДФСом выписать в последствии не проблема.
Нет, а лог квадрат никто не претендует.
Это и так лог.
Нет, погоди, погоди.
Мы сначала сортируем
по СССшкам,
я имел в виду, а потом
только для равных СССшек
мы забабахиваем борт для каждой своего.
Так что
получается такой лог.
Но я все-таки расскажу
другой алгоритм за лог.
Просто на мой вкус сильно проще.
Ну пишется прям на муа.
Значит, смотрите.
То есть на самом деле он будет базироваться
на тех же самых хэшах.
Значит, смотрите.
Идея будет в том, что мы будем
запускать вершину.
То есть когда мы запускаем ДФС,
наша цель,
то есть прийти в вершину и выйти из нее,
сказав, что
эта вершина имеет
поддерева типа
L.
Где L это какое-то число
в нашем случае от 0
до 2n-1.
В общем, 2n-1.
То есть что мы хотим?
У каждой вершины есть свое поддерево.
Я хочу, чтобы
придать им такие номера, чтобы
понятно, изомовные
поддеревья получили одинаковые
номера, а не изомовные разные.
Понятно, да?
Ну вот так вот.
Тогда у меня возникает
такая неожиданная идея.
Как же мне это сделать?
Делать я это буду
весьма неожиданным образом.
Я заведу
маптик
из вектора
и назову ее
не тратя здесь силы
на фантазию.
Так вот, идея у меня будет очень простая.
Значит, как я буду давать
номер в вершине? Очень просто.
Я возьму вершину,
посмотрю, у нее детей.
DFS мне вернет
номера L1, L2, L3
и так далее.
Я эти номера
отсортирую.
Это уже номера. Если они равны, значит
у них поддеревья изомовные.
И проверю.
Запихну эти элементы в вектор
и проверю, есть ли у меня
такой вектор в маптике.
Если есть, то тогда в этом маптике будет
записан просто номер.
Что нужно, чтобы
задать дерево?
Чтобы задать тип дерева,
на самом деле он вполне
однозначно восстанавливается по типам
поддеревьев своих детей.
Например,
сразу можно заметить, что
дерево из одной вершины
задается просто пустым вектором.
У меня ноль детей.
Вот такая
штука. Я просто
проверяю, есть ли этот
вектор здесь. Если да, то записываю
вершину V то, что тут написано. Если
нет, то значит я тогда записываю
там вершину V, что такого поддерева
не было и оно у нас теперь появилось.
Вот и все решение.
Я запускаю это сначала для одного дерева,
потом не затирая мапа для
другого. Если у
меня у корней
получился один тип, мы победили,
то значит они заморфны. Если нет,
нет.
Да, да, смотрите, вот да, действительно
такой тонкий момент. Кажется, что
вектора сравниваются за линию.
Это правда, но за какую?
Если вы ищете в мапе вектор размера
там Z, то все сравнения
этого вектора с соседями будут
выполняться за O от Z.
Но сумма
Z по всем вершинам
это практически
суммарное количество детей
у всех вершин, то есть N-1.
То есть суммарно получается
эти поиски в мапочках у вас появятся
за N логом.
А зачем?
Ну без мапы мы делали абсолютно те же самые
хэши, просто
там более
с каких? Да ладно!
Давай, слушай,
давай
давай, слушай, нормально
давай, ты живешь в мире, где есть 11 и 14
стандарты, это как бы дохалялось.
Ну нормально, ну и что? Ну и кайф.
Господи, чем тут мап векторов-то вообще?
Да я не знаю, нет,
я извиняюсь.
Нет, нет, просто
что тут может быть
неприятного? Смотри.
Ну а в чем
неприятность?
В чем неприятность? Тут просто 10-10
кайфюжных строчек.
Большой ключ в мапе
интуитивно.
Но надо просто,
но как бы это надо иногда смотреть,
как всегда, если есть какая-то проблема,
два варианта, либо ее всеми правдами
правдами обвести, либо посмотреть на нее внимательно,
и возможно понять, что она не такая большая, как кажется.
Мы с этим столкнемся,
когда будем пытаться искать,
скажем, проверять, лежит ли
точка в ногу уголики.
Ну то есть стандартный метод
известен, пустим луч, там найдем,
сколько там, сколько пересеклось,
поделим на 2, да?
Да, не выпукло, конечно.
И тогда мы теряем вопрос. У вас проблема.
Луч может проходить через вершину.
Есть куча решений.
Запустим случайные
лучи, запустим
правильно
подогнанную бисектрису.
Ну там, правда,
есть горизонтальный луч, есть
самый низкий луч из всех,
запустим там между ними
что угодно между ними, вот этот вектор плюс
этот вектор, например, запустим.
Если эти точки целые,
давайте запустим луч в направлении
миллиард запятая один.
Уже этого хватит, на самом деле.
Все что угодно можно делать.
А есть неожиданный читерский метод
в качестве анонса.
А давайте тут запустим луч влево.
Да, может проходить через вершины,
но давайте внимательно рассмотрим случай,
и выяснится, что на самом деле там все не так сложно,
и на самом деле там получается все очень просто.
Там говорится так,
если у вас какое-то ребро пересекает этот луч
или имеет с ним хотя бы одну общую точку,
то тогда вы
прибавляете один,
если одна точка, одна вершина
строго выше, а другая
не строго ниже.
Остается только на бумажке
просто аккуратно проверить все случаи
и убедиться, что это работает.
Да, там...
Ну, не важно.
Ладно.
Нет, спокойно.
Сумма углов
это мерзкие даблы.
Даб.
Да,
но по константе...
Нет, смотри.
Нет, просто
это будет очень жирно,
потому что сам по себе угол, даже Сатан 2,
это больно.
То есть да, по точности проблем
нет, конечно, действительно, скорее всего,
но...
Граничка угла комплексной
число по модулю.
Это проблем вообще никаких нет.
Летает.
Летает и точность идеальна.
Летает и точность идеальна.
Издевательство.
Да.
Да, главное, чтоб там при умножении эти целые числа
не ушли в бесконечность куда-нибудь.
Ладно.
Сколько у нас там времени?
Так.
Сейчас
чуть-чуть.
Так.
Да.
Ну, значит,
что еще, конечно?
Ну, ладно, давайте за оставшиеся
20 такое.
Можно вопросить?
Вот у нас почему
мы можем от 0
до 0-1?
Нет, у нас вершина.
Состояние тоже.
У нас два дерева, у нас еще втранили.
А мы же как раз хотим,
чтобы у нас состояние потом сзали.
Не, в целом, да,
можно сделать навиады просто
если у нас по переустановлению состояние
говорит, чтобы мы уже
просто потом как в итоге сравниваем?
Мы в корнях сравним состояние?
Да.
Да.
Вот.
Но да, в принципе, даже после этого
в качестве бонуса вообще уже теперь начинаем
писать на запросы в духе даны две вершины
и заморфнули под деревья в них.
Ну вот.
Да, даже такие
развлечения уже начинаются.
Вот.
На самом.
Так вот.
А можно ли отвечать
на
можно ли делать предподсчет
за N?
Предподсчет за N?
Нет, там сортировать по-любому придется,
поэтому
честно говоря, да.
Да.
Чисто.
Да.
Да.
Да.
Да.
Да.
Да.
Да.
Да.
Так.
Идем дальше.
Следующий вопрос.
Так. Значит.
Для этого, конечно, у нас
помимо центра, конечно, у нас
бывают, конечно, еще и немножко другие объекты.
Вот. Ну, например.
Нет.
Нет. Ну, например, какая нот.
Ну, то есть тут у нас всякое бывает.
Потому что, например, есть такая классическая
задача.
То есть есть там какая-нибудь классическая
задача. Ну, например,
в простом виде, конечно, скажем.
Да, но дерево на вершинах. Скажите, пожалуйста.
Да, но дерево.
Причем даже взвешенное дерево.
То есть у каждого ребра есть
там какие-то длины. Допустим,
положительные, хотя это может быть даже
отрицательные.
Скажите, пожалуйста.
А есть ли
две вершины?
Сумма весов
ребер на пути между ними.
Такие-таки равно
к, где k это
заданное число.
Чего?
Так.
По высотам.
Ну, вот.
Ну, вот.
Ну, вот.
Ну, давайте так.
Это задача может быть относительно простой.
В том плане,
что, конечно, так. То есть в принципе
есть такое. Тут есть два стандарта.
Как ее решать?
Нет.
В первой пока переливайка.
Ну, то есть,
может быть,
по-хорошему надо было бы
разключить компьютер и немножко покудить.
Ну, давайте поговорим о чем речь.
Ну, потому что идея
на самом деле такая,
что хочется запустить
ДФС.
И очень хочется, чтобы
в каждой вершине,
когда мы выходим из нее,
у нас был сет расстояний,
который мы можем получить идея из этой вершины
в под деревья.
Ну, идея в том, что
когда у нас у вершины,
скажем, три ребенка,
то мы должны взять эти три сета и их объединить.
Правда, с оговоркой,
что эти сеты перед тем, как объедить,
мы к сетам должны прибавить
чиселку.
Тут просто, видимо, надо достать покудить,
потому что по умолчанию можно сказать,
что этот сет мы напишем самостоятельно,
поэтому прибавление на под деревья для нас не проблема.
Но я надеюсь, в этом месте
никто так не пишет.
Ну, смотрите,
прежде чем объединять, вам придется
ко всем вот этим вот элементам
прибавить чиселку.
Теперь внимание, вопрос.
Как это делать
без отложенных операций
в декортичках?
Ну, да.
Ну, честно говоря,
я в этом месте люблю хранить даже не пару,
а просто структуру.
Но оказывается очень
удобно.
Я сейчас просто на уровне
концепции показываю, я часто пишу.
То есть я это называю
set with add.
Я
люблю
предельно часто в ней храним, понятно,
set int
там s
и там int вот этот add.
То есть
чтобы понять, какие у меня элементы в сетте,
я должен взять элементы этого сеттайка, всем
им прибавить вот это число.
Ну, то есть такая
отложенная операция, но фишка,
но мы здесь гарантируем, что у нас отложенная операция есть только
на всем дереве, а не на под деревьях.
Вот.
Я тут прям честно, дальше
я просто честно начинаю прописывать методы.
То есть там
честный метод там, допустим,
insert,
там какой-нибудь insert от x.
Так, значит,
я не знаю, там bool там,
я не знаю, count от x.
Там какой-нибудь, ну, можно bool,
можно int. А, ну, кстати, size
не помешает.
Что там еще надо?
А, еще я очень люблю, конечно,
написать метод
clear
и люблю еще
написать метод вида, а выдай
мне все элементы, которые у тебя есть
в виде вектора.
Вот прям вот, знаете, вот очень полезно
написать. То есть я не буду прописывать,
конечно, этот метод очень просто пишется,
но просто
это технически, опять же, хорошо, потому что
с помощью таких,
то есть пользовать эти сеты и сливать их, потом легко
приятно. То есть как
слить, то есть как теперь объединить такие
два сета? Ну, очень просто. Надо добавить
элементы меньшего в большее, а меньшие зачистить.
Надо еще push сделать.
Ах, да, да, да, да, да, да, да, да.
Да, да, да, да, void,
add to all
от x.
Да.
Просто от x.
Нет, ну, а зачем?
Нет, ну, Гитаря просто...
А, все, да, да.
Нужно add to all, и нам еще нужно функции, которые
будут для удобства пропушивать, когда мы не сливать
два сета. Зачем нам функции?
Нет, фун...
Да, нам это...
Ну, нет, просто нет.
Get all это делает, да.
Нет, get all...
Нет, в этом и фишка.
Особенно правильное мышление какое-то должно быть.
Я реализую черный ящик,
который умеет реализовать вот эти методы.
Как он там внутри себя устроен,
на самом деле, с точки зрения интерфейса, мне абсолютно
торчать. Вот эти сеты, это я вообще
должен в приват запихнуть.
То есть это вот так
должно быть. То есть в идеале это
такой класс, и вот это
методы должны быть в паблике.
Все остальное, вот это в привате.
И важный принцип объекта
амбицировать, когда вы пишите просто
сложные, то есть сложенные с кусочком задачи,
то есть вы пишете, должны писать
систему черных ящиков. То есть когда вы пишете
сам черный ящик, вам...
То есть вы изначально
продумали, какие методы там должны быть,
но потом, когда вы уже определились с интерфейсом,
когда вы пишете черный ящик, вам абсолютно
начхать, в каком порядке
его используют.
А когда вы используете черный ящик,
то есть прописываете то, как
он используется, вам должно быть абсолютно
начхать, что он конкретно внутри
делает, что он к кому прибавляет и
так далее.
Понятно, да?
То есть это на самом деле просто...
То есть как бы это и вероятность
ошибки уменьшает и
увеличивает считабельность вашего кода.
Потому что вы знаете, что когда вы читаете этот код,
вы думаете только об этой вот задаче, а когда
вы читаете другую часть, вы
о внутренностях не думаете.
То есть вы думаете о том, что, возможно,
вы это неправильно использовали.
Ну, можно и так. Нет, у нас была задача
просто... Я сформулировал,
есть ли да или нет, да, можно было бы
сформулировать в виде сколько, да,
но это по барабадам, можно
мапочки, да, то есть можно сливаемые
мапочки сделать, да, пожалуйста.
Да, теперь давайте подумаем, как
теперь объединить... То есть теперь у нас
возникнет задача, как объединить два сета.
Ну два сета, то есть
выглядеть это будет на уровне
кода так. То есть, ну я обычно
пишу через указатели,
там,
то есть merge set
от, значит,
set там,
ну давайте я кратко буду писать.
SVA, звездочка
S1,
SVA, ну set VZ,
S2.
Значит, первое, что вы делаете,
если оказалось S1 size
больше, чем
S2 size,
то, соответственно, не забываем
swap.
То есть это я для чего делаю?
Для того, чтобы я точно знал, что я хочу
элементы из S1 перекинуть в S2.
Ну и после этого вы понимаете.
После этого я пишу vector id.
Там, допустим, a равно
S1, стрелочка
getall.
Вот.
А, ну и в общем-то все.
Потому что пишем, что
S1, допустим, clear.
Но я обычно не удаляю,
потому что я не делаю там new
сетов, я там все эти сеты в статическом
массиве на самом деле храню.
Вот.
Значит, и дальше пишем for
int x
2.a
S2
insert at x.
Ну и все.
Return S2.
Вот.
Так видите, то есть, знаешь, оказался
теперь пишет, а просто легко, приятно.
То есть единственное, что
самое умное, что я тут сделал,
теперь это вот этот иф написал.
Вот.
То есть очень
удобно.
Но
мы хотим для каждой вершины хранить
какие расстояния бывают
между этой вершиной и ее
потопками. Прям в явном виде
все выписываем.
Да, ноль, кстати, не забываю. Но я не буду сейчас полный код
писать, да. То есть не буду писать там
в каком месте мы там используем функцию
вот это вот add to all, да, вот это.
Там полный тот DFS
не буду. Но как бы
уже догадываете еще, наверное, вот с таким
интерфейсом это там тоже легко, приятно
будет.
Но еще, кстати, остается только один вопрос.
Но на самом деле, конечно, в
merge sets на самом деле придется еще кое-что
вписать. Потому что
на самом деле высекает вопрос, а в какой момент мы
собственно решаем задачу?
То есть пока это мы просто сделали
какое-то сферическое объединение элементов в вакууме.
Как же решать задачу? Очень просто.
Дело в том, что прежде чем объединять два
сета, надо выяснить, а нельзя ли выбрать
одну вершину в одну, а другую в другом, так
чтобы расстояние было к?
С точки зрения
сета это означает, что надо просто
можно ли из двух сетов выбрать по одному
числу так, чтобы сумма была ровно к?
Но на самом деле
вот в этом, это можно сделать
просто вот в этом месте. То есть прежде
чем вы добавляете элементы из вектора a,
надо просто для каждого x'а проверить,
а нет ли случайно в s2 элемента
k-x, и если да, то просто
выбрасываете с криком да.
Почему минус два?
Не-не-не, когда мы их объединяем,
мы уже вот это вот лишнее ребро прибавили.
И кстати, там не два, там
веса у этих ребра есть.
Вот. Но это не важно,
потому что, как я уже сказал, то есть где-то в
ДФС, да, вы запустите ДФС от ребенка
и к этому сету прибавите
вот это ребро.
Вот.
Так что в этом смысле,
так что как сказал бы тут классик,
в этом смысле, да, как бы нет необходимости,
как бы свой процент я уже взял.
Вот.
Так, но этот фильм вы точно не знаете, конечно.
Вот. Или знаете.
Вот фильм классик, не сталкивались?
Ну, про бильярд такой.
Там 97-го, ну не, ну да, это конечно
не особо известный фильм.
Вот. Ладно, не суть.
Вот.
Ну, теперь давайте подумаем, за какое
симптомико это работает.
К сожалению,
лог квадрат. Почему
лог квадрат? Да, потому что, да, очевидно,
что каждый элемент меняет сет
не более чем логарифм раз, потому что он перемещается
в сеты два раза больше.
Вот. Но, к сожалению,
поэтому перемещение получается суммарно
Н лог Н, но каждое перемещение
делается за логарифм, потому что
инсерт и инсерт в сете
работает за логарифм.
Поэтому лог квадрат. Но, в принципе, если бы сет был
онордерат сетом, то был бы Н лог Н.
Это один стандартный метод.
Слючите
другой стандартный метод.
Все.
Не нужен сет в классе.
Нам нужно
только нод вотмапа количества.
Зачем? До количества даже не обязательно.
У нас задача
просто, есть ли две вершины с расстоянием k,
да или нет.
Нет, почему сет хранит просто, какие расстояния
встретились.
Не-не-не-не. Нет, сеты
нужны, потому что ты ж вот в этом вот форе,
который я не дописал. Для каждого х должен проверить,
есть ли в соседнем сете число k-х.
Да.
Поэтому не вектор.
Да, пожалуйста.
Нет,
онордерат сет, пожалуйста.
Вот.
Но слушайте другой метод.
Значит,
когда, если вас
пугает вот это перекидывание
с сетами,
хотя, на самом деле, то, что я сейчас скажу, может выглядеть
нод, то, ну как бы идея тогда
могла быть такая.
Вот просто, как бы мы решали такую задачу в массиве?
Вот, допустим, да.
Ну, допустим, нам там дан массив,
скажите, пожалуйста,
есть ли в нем подотрезок, на котором там
сумма элементов равна k.
Да, вместо суммы
мы еще введем какую-нибудь такую мистическую
операцию, чтобы префикс, чтобы префиксными
суммами это не делалось.
Тогда у нас есть два варианта.
Тогда у нас, тогда идея
на массиве может быть
следующим образом.
Рассмотрим вот этот центр.
Подотрезки бывают трех типов.
Лежащие слева, лежащие справа и проходящие
через центр, правда?
Тогда идея такая.
Давайте за линию найдем тут ответы
на всех префиксах,
на всех суфиксах и дальше
можем пытаться для
каждого суфикса, попытаться
подходящий префикс прицепить.
Ладно, правда, если у вас нет
префиксных сумм, то, возможно, вам это не удаст.
Да, но тем не менее, таким методом
тоже можно, но пока я
просто для примера привожу.
То есть вот такой разделяем властвуй,
получается суммарная н лога n,
потому что тут n, потом дальше тут будет
n пополам, n пополам,
и так далее.
И желательно не обратимая еще.
Но была бы она обратимая,
то префиксные суммы начали
бы работать.
Значит, что еще надо?
А надо вот что.
Так вот, просто идея. Дело в том, что эта идея,
в отличие от префиксных сумм, может неплохо
масштабироваться на дерево.
Потому что возьмем у дерева корень.
Вот этот вот.
Просто у дерева какой-нибудь корень.
Тогда идея такая. У нас два варианта.
У нас два варианта. Либо путь проходит через корень,
либо лежит в каком-то под дереве.
На каждом из под деревьев запустимся рекурсивно.
А для корня, ну что делаем?
А то же самое, что и здесь,
только без рекурсивного перекидывания
сетами. То есть мы
запускаем def. То есть для каждого
под дереве, от дерева честно
генерируем, какие тут расстояния бывают.
То есть генерируем в данном случае четыре сета.
А потом нам надо просто проверить,
существует ли два числа из
разных сетов, чтобы их сумма была равна к.
Ну как это сделать?
Ну сначала проверяем, есть ли такие числа в этих
двух сетах. Если нет, то там
объединяем эти два сета, причем уже по барабану как.
Потом пытаемся
проверить, можно ли выбрать одно число в этих
двух сетах, а дальше в третьем объединяем,
ну и так далее.
Ну,
с этим корнем
разобрались n log n,
дальше потом,
потом тут берем корни какие-то,
и тут суммарно тоже
n log n получается, ну и так далее.
Получается n log n
на количество уровней
рекурсии.
Теперь возникает вопрос, от чему может быть равен?
А сколько тут
глубина рекурсии может быть?
Если в тупую корню брать как корни под деревьев,
то, возможно, вам фантастически
не повезет, и глубина будет n.
Это многовато.
Но фишка, конечно,
в том, что, заметим, что в каждом дереве
корень мы можем выбирать заново.
То есть мы
решаем, какой будет корень. То есть мы здесь
в этом под деревом можем брать не вот эту
вершину, а просто какую угодно.
То есть более того, я как-то в какой-то задачи
реализовал даже, что я это делаю, просто заново
копировал, перенабирал вершины и просто
кидал рекурсивно.
Не, ну помогло.
Правда, судя по разборам
и обсуждениям, видимо, авторы задачи не ожидали,
что там можно это пихнуть.
Ну, точнее, как-то
решение оказалось полной неожиданностью
для нас, мы не заготовили тестов.
Но, впрочем, я не уверен, что у меня
решение прям так плохо работает, прям сильно
заваливалось, скажем так.
Вот.
А как же? Ну, просто
что нужно сделать? Но идея очень простая.
Дело в том, что если размер N,
то, оказывается,
можно просто выбрать
такую вершину в качестве корня, чтобы у нее
все размеры под деревьев были
не более чем
N пополам.
Вот хочется такую сделать.
И такая вершина называется
центроинит.
Вот, не путать с центром.
Центр – это середина диаметра. Центроинит – это вот такая
вершина, что у нее все, что
если ее выкинуть, то дерево распадется
на компоненты связности
размера не более чем N пополам.
Такую вершину очень легко
найти за линейное время, попутно доказав,
что она существует.
Как это сделать?
Ну, сделать это очень просто.
Возьмем
первую попавшуюся вершину в качестве корня,
запустим из нее DFS, посчитаем СЗ.
После этого смотрим, если у детей корня
все СЗ оказались N пополам
или менее, значит, поздравляем,
мы центроинит нашли.
Если нашлась какое-то под дерево
с СЗ больше, чем N пополам,
ну окей, смотрим на детей
этого ребенка.
Если тут кто-то больше, чем
N пополам, очевидно, не больше,
чем одна такая вершина, то идем сюда.
Идем, идем, идем,
и вот в какой-то момент натыкаемся на вершину,
у которой все под деревья меньше
N пополам.
Утверждение
это центроид.
Почему?
Потому что, если его выкинуть,
то у детей меньше N пополам,
а то, что сверху меньше N пополам,
потому что у самого
эта вершина больше, чем N пополам.
Все.
Так что вот нот.
Сам центроид найти легко, и если вы будете в качестве корня
здесь запускать именно это,
то уровни у вас будет, очевидно, логарифом.
И суммарно,
это будет работать за O от N лог
квадрат N, то есть еще одна
такая версия.
То есть как бы либо центроиды, либо с этой в рекурсии.
Ну, например,
оба метода, конечно, полезны, то есть
в каких-то задачах помогает одно, в каких-то другое.
Вот. Но, конечно,
нот.
Но, на самом деле,
центроиды, конечно,
и структура этих центроидов
помогает решать, конечно, иногда и
более мощные задачи.
Ну, вот задачу,
которую мы тут много задач, конечно, не разберем,
но мы разберем такую классическую задачу.
Ну, точно так. То есть пока уже
поняли, что, в принципе, центроиды
позволяют решать какие-то задачи на деревья методом
разделяя и властвовать.
То есть всегда, если вы умеете
за какую-то асимптотику там
f от n, допустим,
решать задачу в
предположении, что
там все, что вам надо, проходит
через заданную вершину,
то тогда за f от n умножить
на log n вы, в принципе, умеете
решать задачу.
Вот. Но, оказывается, можно
решать еще мощнее.
Сейчас мы с вами будем делать
присваивание в радиусе.
Потому что, смотри, у тебя сейчас
под деревья размер n пополам,
то есть когда ты тут в каждом из них выберешь
центроиды, там дальше будет n делить на 4
и так далее.
И теперь
значит еще одна веселая,
но тем не менее прям очень классическая
задача.
Задача такая.
Да оно дерево.
Дерево взвешенное,
все веса положительные.
Нужно уметь
делать
два запроса. Каждая вершина покрашена
в какой-то цвет.
Нужно делать два запроса.
Первый тип запроса.
Скажи, пожалуйста,
в какой цвет покрашена вершина v?
Тип второй.
Покрась, пожалуйста,
все
вершины,
находящиеся на расстоянии
не более, чем r,
от вершины v,
в цвет c.
Вот такая классика.
Да, c произвольная, r произвольная,
веса до 10, там все веса тоже произвольные.
Ну там гарантируется, конечно,
что в каждом из деревней сумма весов не более,
чем там 10-18 и что-нибудь,
вот это все.
Можете считать, что все это веса до 10 в 9.
Расстояние
это сумма весов.
То есть, как бы, каждая
ребро имеет длину.
Как такое решать?
Ну вот,
центроиды нам, конечно, помогают,
но помогает, конечно, что-то более сильное.
Помогает то, что называется
центроидная
позиция.
Выглядит это примерно
следующим образом.
Вот жилов у нас
какое-то дерево.
Тут можно уже и побольше нарисовать.
Вот.
Здесь, смотрите,
идея тут
оказывается такая.
Ну, первое, давайте начнем с простого.
Давайте
предположим, что у нас
в пэнсе вот эта вершина В всегда одна и та же.
Как тогда решать за декю?
Ну вот.
Ну вот.
Ну, по сути, да. То есть там идея оказывается в том,
что для каждой вершины
мы можем хранить что-то типа стека,
в том плане, что мы знаем, что там, скажем,
все вершины от нее до расстояния
не более чем L1 покрашены в цвет
C1.
До расстояния не более чем L2,
но больше чем L1 покрашены в цвет
C2. Вот так вот, да.
То есть вот что-то такое там.
Потом дальше L3, C3 и так далее.
То есть когда мы решили что-то новое покрасить,
то есть мы тут проходимся по стеку, все меньше
длинные удаляем.
Ну вот.
А взамен там вставляем одно и красим
в новое C.
Так.
Понятно, о чем я говорю?
То есть достаточно хранить только эту информацию,
да, все, что вам останется, если когда
вам встанут там где-то от кого-нибудь,
то вы проверяете расстояние до вот этого
корнера, где вы все красите.
То есть находите расстояние, а вам останется только
бинпольском найти в какой-то цвет, что покрашит.
Удобно, да?
Вот.
Но что делать, если такие вершины,
если
пейнтимся мы в радиусе разного?
Корнячку и то же самое получится.
Корнячку?
Корнячку по запросам.
Ну да, если вы еще расстояние между двумя вершинами
за вот единицу умеете искать,
а ну вы уже умеете, естественно,
да.
Ну вот.
Хорошо.
Ну тут, как всегда, вы напишите корнячку,
она получит T, а автор скажет, извините,
у нас лог квадрат, который работает 10 раз быстрее
вашего.
Как-то он
нам очень жаль.
Вот.
Хотя, да, корнячка по запросам
тут, конечно, красиво было.
Вот. Ну ладно.
Значит, идея тогда тут такая.
Найдем в дереве
центроид.
Вот он.
Ну я надеюсь.
Тогда, смотрите, какая нот.
Вот жила была у нас вот такое глобальное
дерево, и был у него
центроид.
Вот.
В мире существует
этот центроид и все под деревья.
И заметим, что каждый запрос
paint может
касаться этого центроида
или не касаться. То есть этот центроид может быть перекрашен,
а может быть не перекрашен.
Ну теперь идея такая.
Предположим, что мы отправились
в какую-то вершину его под дерево,
какую-то вершину его под дерево,
на расстоянии, ну, допустим,
тут 57.
И сказали, в радиусе 179
перекрасить, пожалуйста,
там все вершины от него.
Тогда, оказывается, заметим следующее,
что надо перекрасить вообще все вершины
у центроида на расстоянии
122.
Но это еще не все.
Да, это не все, что мы перекрасили.
Но заметим, что все, что мы не перекрасили,
уже точно лежит вот в этом под дерево.
То есть, по сути, это у нас такая столица,
Москва такая.
Значит, в радиусе Москвы
мы все перекрасили.
Теперь давайте поперекрашиваем,
идем в эту вершину. А что у нас в этом под дерево?
Так, ну, какая у нас дальше?
Дальше у нас идут,
помимо Москвы, у нас есть, конечно,
федеральная круга.
Вот они.
То есть вот у нас это,
вот у нас это, что-то там у нас еще есть.
Вот этот у нас дерево есть.
Вот это вот такая
автономная область.
Такая-то мелкая.
Так вот,
вот так вот.
Что это такое?
А, ладно, где-то внизу.
Не, это, я не знаю,
это уже там Дагестан какой-то.
А вот это, да,
это Калининград.
Ну, а что европейцы жалуются?
Ну, нормально, ладно.
Ой, ну, знаете,
если землю реально в плоскости развернуть,
еще вопрос, кто там большой, будет кто-то маленький.
Вот это Сибирь вообще.
Это Якутия. Прикольная такая.
Так вот.
В каждом этом федеральном округе
мы тоже можем
забабахать центроид.
Вот.
Так, где у нас тут центроид?
Да, вот тут.
Это будет центроид второго уровня.
Это будет центроид второго уровня.
Так.
Что-то у нас тут еще будет.
Тут, видимо, где-то будет.
Вот.
То есть, идея такая, давайте в каждом из этих деревьев
тоже будем
иметь в виду перекаж.
То есть, если вершина находится вот в этом дереве,
дереве второго, в федеральном округе,
то мы попытаемся проделать ту же операцию
через вот этот центроид второго уровня.
Ну, а потом, как вы уже догадываетесь,
через третий, через четвертый и так далее.
То есть, сама вся эта центроидная декомпозиция получается такой
логарифом уровней.
То есть, получается, каждая вершина является центроидом какого-то уровня.
То есть, более того,
можно построить дерево центроидов,
в котором
каждая вершина будет глубина
не более чем логарифом.
То есть, идея нот.
То есть, будем делать вот как вот с этим сказали.
То есть, у нас получается,
у каждого центроида есть сигналы,
что, пожалуйста, в радиусе этого центроида
перекрась там,
в каком-то радиусе перекрась вершины в цвет,
но при этом, очень важно еще отметить,
что это касается только
его зоны ответственности.
То есть, когда мы требуем перекрасить с центром
вот в этом центроиде, мы в столицу не лезем.
И в другие поддеревья не лезем.
Даже если там расстояние меньше.
То есть, получается такая перекраска, но правда получается,
каждая вершина может быть перекрашенная несколько раз.
Но будьте внимательны, конечно, это операция неотложенная.
Поэтому гет у вас будет, конечно, не совсем тривиальный.
Но гет сделается получается так.
То есть, чтобы получить гет,
вам нужно взять вершину В
и подумать,
а какие центроиды могли ее вообще перекрасить?
Их до логарифма.
Вы перебираете все эти центроиды
и получаете логарифм
вариантов ответа.
Осталось только, если никакой из них правильный,
да, правильно, последний.
То есть, это означает, что когда вы перекрашиваете
для каждой перекраски, тут еще храните,
а когда это произошло.
И тогда получается,
что вы все сделали за
лог квадрат.
Потому что в каждом из логарифмов стека
делаете бинпорт.
В каждом из логарифмов стека
делаете бинпорт.
В каждом из логарифмов стека делаете бинпоиск.
Лог квадрат на гет
и лог пейнтов.
И памяти энлог.
Памяти энлог,
потому что
каждый элемент добавляется
в логарифм.
Памяти энлог,
потому что каждый цвет, который ты
красишь, он как бы добавляется в
логарифм массивов.
Нет,
теоретически
нет,
если тебе
нужно построить
только дерево центроидов,
то в общем-то тебе достаточно.
Тебе еще Сашке придется искать,
чтобы расстояние
дали две вершины,
найди расстояние.
Нет, на самом деле нет
необходимости,
если вы согласны за энлог
и памяти, то в принципе
можно для каждого центроида
посчитать расстояние до всех
подмандатох вершин.
Тебе по сути нужно
расстояние только до своего центроида.
Для этой вершины я буду хранить расстояние
до всех, а для этой я буду хранить
до своего дерева.
Потому что у центроида второго
уровня суммарно n будет.
Деревеж какого-то уровня
не пересекаются между собой.
Я бы сказал,
что каждая вершина
является центроидом своего уровня.
Давайте я возьму все вершины
соответствующего дерева
и в этом дереве
выпишу все расстояния
до своего центроида.
Таким образом у каждой вершины
получится расстояние
до всех своих родительских центроидов.
То есть до центра уезда,
до центра области,
до центра округа,
ну и собственно до Москвы.
Остается только надеяться,
что у нас как-то дорог не дерево.
Хотя иногда
как выясняется,
что там иногда
долететь из Владивостока
в Южный Сахалинск можно только через Москву.
Ну ладно, вру, через Новосибирск
все-таки можно, наверное.
Хотя и так
и так немножко экзотично получается.
Хотя нет, Владивосток может быть большим хабом
в этом плане.
Потому что Владивосток в Китай там летают
много на самом деле.
Хотите в Китай?
Летите в Благовещенск.
Да, там через речку.
Да,
добрая китайская деревня.
Да, у них жители
в Благовещенск уезжают, что у них
действительно есть опция пойти пообедать в Китай.
А там на проходе
отличают жителей Благовещенска от остальных
россиян?
Понятно.
Ну да, то есть можно, то есть кто-то
получает визу в Китай, а кто-то идет через
Благовещенск.
Ну да,
через общий центроид.
Нет.
Нет, ну как бы
да, у тебя просто...
Когда ты строишь центроиды для декомпозиции,
у тебя некоторое время две вершины отправляются в одно и то же под дерево.
А потом в какой-то момент
очередной центроид оказался на пути
между ними. Рано или поздно это произойдет.
Потому что, смотри,
тебе нужно перебрать логарифм центроидов.
И в каждом центроиде
надо полезть в этот стэк
и там бин поиском найти расстояние.
Да, поэтому...
То есть я не знаю, возможно там как-то
если тебе запросы даны в офлайн,
может быть там как-то амортизировано
это до логарифма допиливается.
Вот я помню, когда...
У меня вообще-то слезное ощущение, что когда-то когда-то пытался,
и что-то получалось. Не уверен,
что это прям имеет глубокий смысл
с точки зрения практики.
Но так.
Но вот так.
Так, есть ли тут
вопросы?
Нет, мы не считаем для центроидов.
Нет, я сказал так, что
для каждого... То есть вот у нас есть
дерево. Мы нашли билет центроид
и нашли расстояние от центроида до всех вершин этого дерева.
Но для нашей задачи... Нет, это в итоге
приводит к тому, что мы для каждой вершины
нашли расстояние до всех ее центроидов.
А мы ровно это и сделали.
Почему?
Из Москвы мы ДФС по всей стране
пускали.
Нет, нам интересны расстояния
и до сюда, и до сюда, и до сюда.
Нет, сохранили тоже.
Потому что
нас могли покрасить
как из Судиславля,
но так и из Костромы.
Ну,
допустим, мы там находимся в Бердеевых полянах.
Как устроен
пейнт?
То есть пейнт устроен так,
что мы идем в Судиславль и красим там
Судиславский район.
Потом идем в Кострому
и понимаешь, что сколько-то там эпизода кресла из Костромы красим.
Потом мы идем в Москву и красим еще
окрестность ее.
К чему это приводит?
Это приводит,
что если ты находишься
где-то там,
то есть
если ты находишься в Балашихе,
то как бы если
ты находишься там,
нет, ладно, даже не в Балашихе, а там.
Так, какой-нибудь пример.
Нет, значит,
если ты живешь там,
с формулировом так,
ладно, если живешь, допустим,
в какой-нибудь деревне под Яхомой,
то тебя, значит,
могли покрасить из Яхомы,
тебя могли покрасить из Дмитрова,
а могли и из Москвы покрасить.
Причем более тем
самым запросом, который пришел у Судиславля.
То есть получается я должен
перебрать,
хранить не только, то есть расстояние,
то есть расстояние, получается, мне придется хранить
все-таки до всех своих центроидов,
а не только до одной
ближайшей Яхомы.
Да, если что,
если что, расстояние от Яхомы до Москвы
не равно расстояние от Яхомы до Дмитрова
плюс расстояние от Дмитрова до Москвы.
Почему?
Расстояние от Яхомы до Дмитрова меньше,
чем расстояние от Яхомы до Москвы.
Так, короче, вот так вот,
есть железная дорога, вот эта темирская, да?
Так вот, значит, если ты едешь
вот тупо на север,
ты рано или поздно приедешь в Дмитров.
Так вот, за станцию до него есть Яхрома.
Так что вот так себе это надо уважать.
Так вот, поверь, Яхрома ближе, Дмитров ближе
к Яхроме, чем к Москве.
Если бы мы красили
ровно, радиус уже не работал бы.
Нет, то есть прям
на ровно, ну, конечно.
Хотя, нет,
нет, крепче.
Ну, хотя, да, не работает, согласен.
Нет, это правда, это не ровно.
Да, мы явно пользуемся тем, чтобы красить
не только на расстоянии, а на расстоянии не более,
чем Р.
В какой момент
мне нужно оставить расстояние?
Ну, как минимум...
Ну, потому что когда мы идем из Судяславля
в Москву,
нам нужно просто дать, какой конкретная
псилонокрестность Москвы красить.
Вот.
Так, ну, что, еще какие-то вопросы есть?
За лог квадрат.
Ну, потому что
в каждом центроиде там стек находится,
в котором надо бинпоиском искать.
Лог квадрат.
Логарифм стеков в каждом логарифме,
поэтому лог квадрат.
Потому что логарифм центроидов.
Как, чего, кого?
Мы должны перебрать
просто все мои родительские центроиды.
То есть, типа, если я берендирую поляну,
я должен перебрать Судяславль, я должен перебрать
к страну, я должен перебрать там,
я не знаю, там северо-осточный федеральный округ
или в каком-то округе находится к стране,
я не знаю. И концертов надо
перебрать всю страну.
Да.
Ну, нет, ну, как бы декомпозиция
подразумевает, что ты заранее там за НЛОГАН
как бы это все предподсчитал.
Для каждой вершины в явном виде знаешь, кто у нее
родительские центроиды?
По факту мы для каждой вершины храним стек.
Потому что каждая вершина
является центроидом своего уровня.
Почему отложены? Отложенных операций нет.
Ну, в самом стеке
конечно нет, отложенных операций нет.
В смысле?
Ну, чтобы
у нас
такие вопросы я не умею отвечать,
только у нас он так устроен,
что значит зачем?
Каждый
стек находится, каждая вершина
является центроидом.
То есть вопрос только, как бы она
всей страны центроид, или только там
своей области?
Когда мы берем
гет от В, мы должны для каждой вершины В понять,
то есть
найти центроиды всех деревьев,
внутри которых она лежит. Она лежит
внутри логарифма деревьев там,
потому что логарифм уровень.
Нет, В не надо искать.
Ну, как и с центроидом какого-то уровня.
Но это не важно.
Если она является центроидом
11-го уровня,
значит она лежит еще в 10
деревьях более больших.
И у каждого из них есть центроиды,
и их надо уметь находить.
Так что вот,
вот таким образом
восьмые задачи на все расщелкаются,
как орешки.
Ну, бывает.
Уже вторые, да?
Ну, это пожалуйста.
Ну, кому как проще.
Но тем не менее, вот метод мощный данный.
Да.
Это что такое нормальные люди?
Так, ладно, в финсе на сегодня все.
Да.
