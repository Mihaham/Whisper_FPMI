Я доказывал это на первой лекции без япотез, то есть с пустым ножетом япотез, но доказательство
практически не меняется, потому что, смотрите, если я использую аксиомы, она вообще всюду истинна,
если я использую япотезу, она истинна на этом выполняющем наборе. То есть в сущности нам
нужно доказать тоже, что если есть выполняющий набор для этого ножета формы, то тогда и а на
этом наборе равна единице. Но проверять нужно то же самое. Аксиомы истины, япотезы истины,
и по моду спонанс мы, если и а и за следует b истины на каком-то наборе значений переменных,
то b тоже истина на каком-то наборе значений переменных. То есть это то же самое и очень просто.
В обратную сторону это как раз полнотам. Ну если ножет япотез пустая, это в точности утверждение,
что тавтологии выводимы в исчислениях высказанных. Ну а если не пусто, это означает что-то дополнительное,
что вот мы можем вывести все следствия, которые содержательно есть из этого ножета формул,
мы можем получить нашими синтоксическими следствиями. Это и есть основной смысл этой
теоремы. То есть наша формальная система адекватно формализует значения формул,
извините, свойства функций задаваемых формул. Как я это буду доказывать? Есть на самом деле
несколько доказательств, есть очень простое конструктивное доказательство, вы можете посмотреть
у нас в учебнике. Но я расскажу более сложное, но зато необычайно полезное доказательство,
которое в принципе переносится на более сложные логические теории, и в котором используется очень
важные для логики идеи. Собственно цель даже представить эти идеи, а не только рассказать доказательства.
Первая важная идея состоит в том, что мы будем доказывать не напрямую. Не очень понятно,
как из того, что у нас есть какое-то такое симматическое свойство, скажем формула
Тавтология, как отсюда получить, что для нее есть вывод. Не очень понятно. Мы будем доказывать
равносильность другой пары свойств. Я их сейчас напишу. Мы называем множество гамма противоречивым,
если из него можно вывести какую-то формулу и можно вывести ее отрицательно. То есть из множества
этих формул получается противоречие. И мы называем множество гамма совместно,
если существует выполняющий набор для этого множества. На этом множестве мы тогда смотрим,
как на систему уравнений. Вот есть формулы. Мы пишем для каждой формулы из этого множества
уравнений. Фи от х равняется единицей. Совместность означает, что система уравнений может
бесконечно совместно иметь решение. То есть вполне естественное название. Так вот, на самом деле,
главный факт, это не вполне очевидно, но правильно доказывать именно вот такое утверждение, что не
противоречивость равносильна совместности. Это другая ипостась той же самой теоремы. Просто это
не так легко увидеть. В одну сторону, впрочем, не сложно. В какую? Ну, представьте, что система
совместна. Тогда, ясное дело, что она не противоречива, потому что, посмотрите на определение
противоречия, если система совместна, множество формул совместна, то тогда все, что мы можем вывести
из этого множества, также обращается в единицу на выполняющем наборе. Но если бы мы вывели
противоречие, мы бы получили такой странный факт, что формула истины на каком-то наборе значений
и отрицание формулы. Истина на том же наборе значений. Это невозможно, потому что отрицание
формулы и формула принимают в точности разные значения. В эту сторону это, по сути дела, теорема
корректности. Все очень просто. Теперь в другую сторону. В другую сторону сложно. Это основная трудность.
Мы пока переформулировали, но не вполне ясно, чем это нам поможет. Давайте, прежде чем рассказывать
доказательства в другую сторону, то есть основная часть моего доказательства будет вот в эту сторону.
Я буду доказывать, что непротиворечивое множество формул совместно. Это очень важный для логики момент,
что если мы написали какое-то множество условий и мы каким-то образом знаем или доказали, что
противоречия мы из этого множества вывести не можем, для него есть выполняющий набор, то есть эти
условия реализуются. Какими бы они ни были странными. Это, я не буду отвлекаться за недостатком времени
на историю математики, но это очень важный шаг в разных рассуждениях, связанных с основаниями
математики. Тем не менее, прежде чем начинать доказательства, я хочу вывести вот этот факт из вот этого.
Предположим, мы уже умеем доказывать, что непротиворечивость равносильна совместно. Как
вывести тогда полноту? Ну, смотрите, у нас есть условие, что из гамма синтоксически следует...
А, симонтически, извините. Тогда вот такое множество формул обязательно не совместно.
Посмотрите на определение. Если мы вдруг нашли набор значений и переменных, на которых все формулы
из гамма обратились единицу, то тогда и формула обратилась единицу, а отрицание формулы обратилось
в ноль. То есть у нас либо на любом наборе значений и переменных, либо какая-то формула отсюда
обращается в ноль, либо отрицание А обращается в ноль. Теперь смотрим на вот это утверждение. Раз это множество
не совместно, оно противоречиво. То есть мы по определению знаем, что из него можно вывести какое-то противоречие.
Очень хорошо. Но мы знаем также и теорему дедукции. Это утверждение означает, что из самого множества мы можем вывести
такие формулы. Из-за А следует В, и можем вывести также формулы, из-за А следует В. Ну, а зная эти факты, построить вывод
формулы А, нам же конечно в шуте нужно вывести формула. Уже очень легко. Как мы это делаем? Мы вначале выводим эти две формулы.
Просто выводы, которые там перечислены, записываем. Теперь пишем третью схему акцион.
И два раза применяем моду спонс. У нас уже есть такая формула, которая посылка в этой третьей схеме акциона. Значит, мы можем по моду спонс написать
заключение нашего вывода. Ну и такая формула у нас есть. Мы еще раз применяем моду спонс и получаем формулу А.
Так что видно, что в эту сторону совсем легко. В обратную тоже не сложно. Давайте я не буду на это тратить время. Но если у нас есть утверждение о том, что
несовместное множество обязательно противоречиво, мы уже все быстро можем после этого закончить доказательство теоремы полноты.
Значит, по крайней мере один шахмус делали, теперь мы можем сосредоточиться вот на этом утверждении. Из него будет следовать полнота, основная наша теорема, все будет следовать.
Как же доказать этот факт? К прежнему не очень ясно, но вот есть непротиворечивое множество форм. Нам хочется найти какой-то выполняющий набор значений перемен.
На самом деле есть очень хорошая идея, как это делать. Вот смотрите. Я давайте буду определять набор значений переменных так. Если из гамма выводится переменная х и п, я полагаю значение х и п единицы.
А если выводится отрицание х, я полагаю значение переменной ноль. Вот определил так набор значений переменных.
А теперь я утверждаю, что этот набор выполняющий. Почему? Давайте возьмем формулу из нашего мнения. В нее входят какие-то переменные х1, х2.
У нас есть Лемма Кальмахра, которая говорит, что из алфаверсий литералов, отвечающих этому набору значений переменных, они в точности так и определяются.
То есть здесь это будет отрицание, здесь это будет сама переменная. Выводится алфаверсия формулы. Альфаверсия, я напомню, это или сама формула, или ее отрицание.
Но формула уже сама принадлежит нашего множества хипотез. Конечно ее можно вывести из этого множества. Какие сомнения, просто вывод из одной строчки.
Если бы мы еще могли вывести отрицание формулы, мы бы получили противоречие. А множество не противоречило. Значит отсюда следует, что формула на этом наборе значений переменных должна равняться единице.
Если бы она равнялась нулю, ее бы алфаверсия была бы отрицательна по определению. То есть очень просто, если из наших формул вытекает, что мы вывели переменную эксы,
мы же знаем теорию корректности, нам надо эксы положить равным единицам. Если вытекает, что не эксы, значит мы должны положить равным единицам.
Но у нас точно не получится выполняющего набор. Все очень просто. Но есть одно большое но. Это хорошая идея, она работает.
И тут видно как используется Лемма Кальмара. Техническая трудность скрыта вот здесь. Я ее в прошлый раз преодолел.
Вот здесь нам нужно конкретные знания про конкретную формальную систему. А так эти общие рассуждения, они конкретному виду формальной системы даже не очень привязаны.
Но есть проблема. Проблема состоит в том, что, замечательно, если так, то так, если это, то это, а если не выводится ни то, ни другое.
Ну вот представьте, что множество гипотез пусто. Мы же хотим в частности доказать теорию о полноте. То есть если тавтология, то она выводимая.
Тогда мы должны взять пустое множество гипотез. И что делать? С пустое множество гипотез мы не можем вывести ни переменную, ни ее отрицания.
Потому что выводимый только тавтология. Ни переменная, ни ее отрицания, тавтология не выводится.
И это вроде бы создает какое-то немыслимое препятствие.
Тем не менее, это препятствие преодолимым.
Идея его преодоления, она как раз очень важна. Она в логике постоянно используется для доказательств самых разных фактов.
И для доказательств полноты самых разных логических систем, если они достаточно сложны, что-то такое обязательно приходится делать.
Идея состоит в том, что мы множество должны поповодиться. То есть сохраняя непротиворечимость, добавлять в него формулу.
Для чего? Чем больше формул, тем больше формул выводится.
Мы хотим добиться того, чтобы для каждой переменной выводился какой-нибудь из литералов, или позитивный, или негативный, или сама переменная, или ее отрицания.
Если мы этого добьемся, представьте, что множество гамма такое, что для любой переменной у нас выводится или переменная, или отрицание.
Тогда вот этот план прекраснейшим образом работает, потому что мы получим действительно выполняющий набор для, при своем значении, всем перемен.
Заметьте также, что из того же соображения про лему кальмара, из такого свойства будет следовать, что вообще для любой формул, из гамма выводится формула, или выводится отрицание формул.
Ну потому что раз мы вывели все переменные, дальше применяя лему кальмара, мы получим альфа-версию любой формулы. Альфа-версия это или формула, или ее отрицание.
Вот такие множества формул имеют специальное название. Они называются поумы. Просто по определению.
Таким образом наша цель, что нам осталось сделать, это доказать, что любое множество непротиворечиво содержится в непротиворечивом полном.
Ведь смотрите, а что тут существенно? Когда мы расширяем множество формул, совместность только сложнее становится доказывать. У нас появляются дополнительные формулы, они тоже должны обращаться в единство.
Уже если большее множество имеет выполняющий набор, то тот же выполняющий набор будет для любого его подножия.
А для полного непротиворечивого множества работает вот эта прекраснейшая идея с использованием лему оценки.
То есть мы смотрим какие из литералов выводятся, присваиваем им переменным соответствующие значения.
И все, дальше применяем лему оценки и получаем, что этот набор значений переменных является выполняющим для данного множества.
То есть все, что осталось, это каким-то образом убедиться, что любое множество можно расширить для полного непротиворечивого.
Ну, тут это действительно можно сделать, и это я и собираюсь доказывать.
Но доказывать я это буду в несколько шагов. Вначале я докажу лему о пополнении.
Предположим, что для какой-то формулы нельзя вывести из множества γ, гамма мы предполагаем непротиворечивым.
Ну, если нельзя вывести, на самом деле из противоречивого множества, как мы помним, выводится любая формула.
Поэтому это можно было бы и не писать, только тут я неправильно формулу писал. То есть нельзя вывести ни формулу, ни ее отрицания.
Тогда, если я добавлю к моему множеству еще и отрицание формулы, оно тоже непротиворечитно.
Это очень важный шаг. Он как раз показывает, что наша формальная система хорошо устроена.
Если мы уж не можем что-то доказать и опровергнуть не можем, тогда нам безопасно сделать.
На самом деле любой выбор можно было бы и добавить. Я для простоты доказываю, только для меня будет короче доказательство.
А в принципе, конечно, если добавить, то тоже будет непротиворечитно.
Если мы то, что не можем доказать, примем или примем отрицание, мы никаких противоречий все равно не получим.
Это очень важный момент, и доказательство такое синтоксическое.
На самом деле оно уже фактически было доказано, когда я выводил свою основную теорему из вот этой вот теоремы о том, что из непротиворечимости следует совместно, что это равносильно.
Но смотрите, я буду доказывать контрапозицию. Предположим, что это множество противоречий.
По определению это означает, что можно построить противоречие.
Я сейчас просто повторяю то, что я уже делал. Дальше потеря дедукции это равносильно тому, что выводится вот так.
Ну а теперь уже все совсем понятно.
Имея такие формулы, мы опять-таки пишем их выводы.
Тут где-то я забил отрицание. Не А, в любом случае, это отрицание.
Дальше пишем третью схему ОСЕО.
Ну и два раза модусполненсов применяем.
То есть это в точности тоже рассуждение, которое уже было.
Вот так вот.
Вот так вот.
Вот так вот.
Вот так вот.
Вот так вот.
Вот так вот.
Вот так вот.
Вот так вот.
То есть смотрите, мы получили вывод из множества гамма формулы А.
Пришли к противоречию с условием леммы, потому что мы предполагаем, что А невыводимо и отрицание А невыводимо.
Таким образом, мы можем пополнять наше непротиворечивое множество, сохраняя непротиворечивость.
А чем больше у нас формул, тем легче доказывать, тем легче выводить, тем больше у нас формулы выводятся.
Ну если мы получим противоречивое множество, начнут выводиться все, но так далеко мы заходить не будем.
Мы внимательно следим за тем, чтобы не добавлять лишнего, чтобы непротиворечивость сохранилась.
Ну и как теперь будем рассуждать?
Теперь рассуждение уже такое.
Давайте построим возрастающую последовательность множеств формы.
Бесконечно.
Я напомню, что в переменах у нас счетное количество, то есть все переменные как-то перенумерованы.
Все переменные, которые мы используем, они имеют номер.
Целая ручка в каждом положительном число, не важно какое.
И вот теперь я так и буду строить индуктивно свои множества.
Во-первых, в некоторых случаях множество просто не меняется.
У меня не струй порядок.
Не меняется, ну вот в каких случаях.
Если из предыдущего множества выводится или катая переменная, или выводится отрицание.
Тогда мы множество не меняем.
А в противном случае мы добавляем все переменные.
Мы добавляем отрицание этой переменной.
То есть вот такое определение последовательности множеств формы.
То есть мы начинаем с нашего множества, какое бы оно ни было.
Если оно еще не является полным, то мы выполняем эти шаги.
Но если оно полное уже, то просто все множества в этой последовательности будут равными.
Потому что первая строчка всегда выполняется.
А если оно не полное и для каких-то переменных ничего не определено,
мы просто добавляем множество отрицания.
Ну давайте посмотрим на лему и на это построение.
Ясно, что индукции пока можно доказать, что все эти множества непротиворечивы.
Просто мы по очереди добавляем формулы, применяем много раз эту лему,
и непротиворечивость сохраняется.
Но теперь мне же нужно вот полное непротиворечивое множество.
Что это будет? Это будет объединение всех этих множеств.
То есть такой предел.
И с пределом возникает сложность.
Какая сложность возникает с пределом?
Вы уже, я думаю, много математики изучали,
и знаете, что при предельных переходах свойства могут нарушаться.
Берете расширяющиеся последовательно замкнутых множества,
вложенные друг у друга,
а их объединение уже не замкнутое.
Ну я думаю, с легкостью такой пример построить.
Ну просто вы возьмите отрезки, которые от минус а до а,
где а там меняется нуля до единицы.
Это такая бесконечная система отрезков,
каждый из них замкнутое множество,
а если возьмете объединение, у вас получится интервал.
Ну единицу они включают.
У вас получится интервал, который уже не замкнутый.
Здесь может в принципе быть та же самая проблема, но нам везет.
На самом деле это множество тоже не противоречиво.
А следующие очень важные причины.
Но настоящая причина состоит в том,
что топология, которая стоит за этими конструкциями,
она другая, не такая как с числами.
И там той проблемы, которую я обозначил, не была.
Все открыты, но что ниже из-за.
Ну не все, но не буду на это тратить время,
потому что там аккуратное слово требует время.
Но доказать это очень легко.
Потому что, смотрите, предположим,
что объединение всех этих множеств оказалось противоречиво.
По определению это означает, что мы можем вывести противоречие.
Но противоречие это два вывода.
Вывод в какую-то формулу A, вывод в какую-то формулу N.
Вывод по определению это конечная последовательность формулы.
В этой конечной последовательности мы из всего этого множества,
можем использовать только конечное множество формул.
Потому что у нас всего конечное множество формул.
Но раз мы используем только конечное множество формул,
они все входят в какие-то гамма-каты.
Т.е. мы можем указать конкретно какая-то гамма-Mв,
гамма n большое, куда входят все формулы, которые нам понадобятся для вывода противоречия.
И тогда эта гамма n большое тоже противоречила, потому что ничего дальше мы не используем.
Таким образом, оно не противоречиво, и оно полно.
Но полно по тому трюку, который я с самого начала обозначил.
Ведь смотрите, после того, как я взял все эти формулы, я уже точно знаю,
что для каждой переменной выводится или переменная, или ее отрицание.
Потому что если какая-то переменная из предыдущего множества формул не выводится,
и не выводится ее отрицание, на следующем шаге мы прям добавляем отрицание этой переменной.
То есть мы так принудительно добиваемся того, чтобы для каждой переменной один из литераллов выводился.
И следим за сохранением непротиворечимости.
Тут основная сложность состоит, конечно, в том, что непротиворечимость нам надо сохранить.
Потому что если мы слишком легкомысленно отнесемся к этому делу, у нас возникнут проблемы.
Ну хорошо, значит, это вот доказательство теоремы о полноте.
Теперь я еще раз пройдусь в обратную сторону.
Значит, что мы сделали?
Мы доказали лему о пополнении.
Мы доказали, что используя ее в качестве шага индукции мы можем построить
полное непротиворечивое множество формул, содержащее данное множество.
А для полного непротиворечивого множества мы знаем уже, что оно совместно.
Мы явно указали процедуру нахождения выполняющего набора.
Раз оно совместно, мы доказали, что было непротиворечивое множество, то оно совместно.
И, как я уже говорил, отсюда будет следовать то, что я хотел.
Что если формула является следствием семантическим из данного множества формул,
то ее можно вывести синтоксически.
Это следует из нашего вот этой вот главного свойства исчисления высказаний.
Вот на этом мы закончили.
То есть я начал с того, что определил это исчисление высказаний.
Вот у меня почти две лекции ушло на то, чтобы доказать его адекватность этой формализации.
То есть что выполняется и корректность, и полнота.
Ну, корректность легко, как это обычно бывает, а с полнотой пришлось повозиться.
Это так почти всегда.
Ну, давайте теперь... На этом мы не закончили еще с булевыми формулами.
Есть два сюжета. Один короткий, другой длинный.
Я начну с короткого, а длинный может быть придется еще в следующий раз продолжить.
Еще точно придется.
Короткий сюжет такой.
Ну, у меня была странная аксиоматика.
Три схемы аксиом, которые выглядели очень странно.
И оправдывались, конечно, тем, что их очень удобно используют доказательства.
Как вы видели, на теоремы дедукции первые две схемы нужны.
А дальше почти во всех рассуждениях мы использовали третью схему аксиом.
Без нее как-то ничего не получалось.
А что будет, если я попытаюсь другую аксиоматику написать?
Действительно, можно написать другую аксиоматику для других связок.
Но та аксиоматика, которую я написал, она минимальна.
Я про это упоминал. Сейчас я хочу сказать немножко подробнее
и объяснить идею доказательств.
Вот представьте, что мы из трех схем всем оставили две.
Ну, скажем, первую и вторую.
Изменили числение высказывания.
Это тоже какая-то формальная система.
Все определения, выводимости и так далее, они все сохраняются.
Правила вывода я сохраняю.
Что про такую формальную систему можно сказать?
На ней какие-то формулы выводятся.
Например, из-за следует а.
Я прям явно вывод писал.
А какие формулы выводятся?
Ответ на этот вопрос не очень простой.
Я его давать в полном объеме не буду.
Но точно не все тавтологии.
Конечно, выводятся только тавтологии.
Корректность сохраняется.
Если я вывел, не использую третьей схемы аксиомата,
понятно, что теремму корректности все равно применить можно.
И для доказательства этого факта
используется такой популярный математический метод
контрмоды.
У нас есть формулы.
Я для простоты говорю о формулах,
которые используют только две связки.
Импликация и накрицание.
Одна связка от двух аргументов,
другая от одного.
И я их трактовал как болевые функции.
Функции, которые определены на множестве 0 и 1,
принимают значение 0.
Но совершенно не обязательно делать так.
Если я возьму какую-нибудь другую функцию.
Скажем, действительных чисел.
Буду считать, что импликация это функция х плюс эффект,
а накрицание это функция х переходит в х квадрат.
У меня каждой формуле моей будет соответствовать
Ну, если я возьму любое множество, любую пару функций,
то формулы будут задавать какие-то функции.
Так вот, смотрите, какая идея.
Нам нужно,
чтобы построить, как говорят, контрмодель,
нам нужно придумать
такой набор функций,
который обладал бы следующим свойством.
Все аксиомы,
соответствуют какие-то функции.
То есть, я определил функцию импликации и функцию отрицания.
Что соответствует импликация и отрицание.
Тогда первым был схема Максима,
будут отвечать какие-то функции.
И вот надо, чтобы эти функции были каким-нибудь хорошим свойством.
Вот как Тавтология. Тавтология, это, естественно, равный единице.
Функция константа, роман, какому-то константу мы скачиваем.
А та формула, про которую мы хотим доказать, что вывести нельзя,
нам нужно, чтобы модус понус это сохранил.
Что если у нас применяется модус понус,
то получается константная функция.
Это такие свойства, которые задают ограничения
на эти пары функций.
И если нам такое сделать удалось,
и мы нашли формулу, которая не задает константную функцию,
в этой модели, другой, не булилой,
то мы знаем, что ее вывести нельзя.
Если вот то, что я сказал, выполняется,
то теорема корректности тоже выполняется.
Ну и вот конкретно для этой формальной системы
функции определить очень легко.
Они заданы такие, действительно,
на множестве ноль.
И импликация задана, как и раньше было.
А вот отрицание,
это простоождественная функция.
Ну, имею право.
Тогда смотрите,
про модус понус там входит только импликация,
поэтому все наши рассуждения сохраняются.
Если функция тождественно равна единице,
формула задает функцию тождественно равной единице,
и формула из A следует B задает формулу,
функцию тождественно равной единице,
потому что импликация точно так же.
И первые две схемы аксема там вообще нет отрицания, поэтому они не меняются, они в этой функции тождественной равной единице.
А вот третья схема аксема уже с ней будут проблемы. Давайте я ее напишу.
Посмотрите, теперь отрицание это тождественная функция, поэтому функция, которая задается такой формулой, и функция, которая задается вот такой формулой, они просто-напросто совпадают как функции.
Функция была разная, а функция та же самая.
Но вот эта формула не является фактологией. Очень легко придумать значение переменных, при которых эта формула ложна.
Нам нужно, чтобы вот эта формула ложна, значит вот это ноль, это единица.
Ну главное, давайте возьмем х равную 0 или х равную 0, тогда это единица, это единица, из единицы ноль это ноль, и из единицы ноль это ноль.
Таким образом это не фактология. Копить очень просто.
Ну то же самое верно, если оставить, скажем, вторую и третью схему аксема. Тут пример немножко выраженный, потому что отрицание вообще в этих схемах первых двух не используется.
Но если оставить вторую и третью схему аксема, опять-таки найдется контрмодель, можно придумать такие функции, которые будут задавать, такие функции для импликации отрицания, которые будут задавать.
Вторую и третью схему аксем будут отвечать константным функциям, а первая схема аксем не будет отвечать константным функциям.
И то же самое, если оставить первую и третью схему аксема.
Но два других примера, они более сложные, значит там, во-первых, уже двузначной логики не хватает, нужно использовать трехзначную логику, то есть множество из трех значений, и функции, ну мягко говоря, непрозрачные.
То есть их как-то люди подобрали в свое время. Сейчас, конечно, это можно было бы сделать компьютерным поиском, потому что понятно, функций все-таки не так много, множество из трех элементов.
Но сделано это было давным-давно, и люди просто на бумажке подобрали. У нас в учебнике эти примеры примодятся и даже разобраны, но они как-то выглядят не очень убедительно.
Просто не очень понятно, какая математика за этим стоит. Вот за этой формальной системой стоит очень интересная математика, то, что называется интуиционистское числение высказываний, но я не буду про него ничего говорить.
Кому интересно, можете почитать книжки, у нас в учебнике есть голова, в курс, к сожалению, это не помещается, это было бы очень интересно, но не помещается.
Так, давайте сделаем перерыв. Я извиняюсь, я делаю перерыв, чуть-чуть затяну, потому что сейчас перерыв на пять минут давайте сделаем, и после перерыва уже займемся прыгом.
Ну, давайте потихоньку начнем, так по моим часам еще минута где-то от перерыва осталось. Я постепенно начну, потому что мы закончили разбор вот этого важного примера, исчисления высказываний.
Но что осталось не разобранным? Если вы помните, я начинал с задачи проверки тавтологичности формулы. У нас был совсем простой способ, просто по таблице выписать таблицу значений, их два в степени, строчек, применить и получить ответ.
Вычислить значения, если все единицы, то тавтология, если какая-то не единица, то нет тавтологии. Очень простой способ. Чем хороша система, которая назвала исчисления высказываний?
Она имитирует обычные математические рассуждения. То есть, по сути дела, мы строим доказательство того, что формула тавтологии. Такое доказательство в очень мелких шагах. Мы пишем какие-то очень простые факты, которые являются тавтологиями.
Просто наши схемы аксем, могли бы и более сложные тавтологии писать, про которые легко проверить, что они тавтологи. А потом применяем моду спонс. Это обычный способ математического рассуждения.
Если я доказал А и доказал, что из А следует В, значит я могу вывести В. То есть, эта наша система моделирует обычные математические доказательства.
Этим она сильна. Она на самом деле является частью более сложных логических систем, про которые я чуть-чуть скажу позже.
Но с точки зрения проверки тавтологичности, давайте подумаем, выиграли мы что-нибудь или нет.
У вас есть какая-то сложная формула. Как строить вывод, допустим, мы хотим доказать, что она тавтология. Нам надо построить вывод в исчислении высказываний. С чего начинать? Совершенно непонятно.
Исчисление высказываний настолько хорошо мимикрирует под настоящее математическое рассуждение, что возникают те же самые сложности.
Если у вас есть какая-то реальная содержательная математическая задача, тоже часто бывает, смотришь на нее и непонятно с чего начать.
То есть, это такая обычная проблема для математики. И тут она в полной мере присутствует.
А допустим, мы хотим писать компьютерную программу, которая проверяет тавтологичность. Чем нам наше исчисление в высказывании поможет?
А непонятно чем, потому что с чего начинать? Программа должна с чего-то начинать. С чего ей начинать? Неясно совершенно.
С другой стороны, почему математики вот так вот рассуждали, используя modus ponens и какие-то простые формулы?
Да потому что по почталеной Печкиной не было велосипеда, а у них не было компьютеров.
По-другому было очень сложно на бумажке делать. Если вы что-то сложное преобразование с формулой делаете, пойди его проверь, что вы нигде не запутались.
Поэтому математики старались все разбивать на максимально простые ходы.
Что изменилось в наш компьютерный век? Изменилось то, что даже если мы делаем какое-то довольно сложное преобразование формул,
но которое можно эффективно реализовать программой, мы можем проверить корректность программы раз и навсегда, то у нас нет проблем.
Сделаем это преобразование и будем работать с тем, что получилось. То есть с компьютерной точки зрения нам не обязательно привязываться к такому жесткому формату.
Мы можем какие-то совершенно другие действия выполнять.
И отсюда возникает очень важное понятие. Оно скорее относится не к классической логике, а уже к тому, что раздел теоретической информатики,
который называется сложность доказательств, но мне бы хотелось про него немножко сказать, чтобы стало понятно, о чем я буду говорить дальше.
Я буду в основном говорить все равно про классические вещи, но тем не менее. Возникает понятие системы доказательств.
Я в скобках напишу тавтологии, потому что мы будем доказывать тавтологичность формул, но вообще говоря, это и более общее можно определить.
Что такое система доказательств? Это алгоритм, у которого на вход подаются два аргумента.
Формула и второй аргумент мы называем доказательством, но он может иметь любой природу.
Вообще говоря, алгоритму на вход мы можем подавать какие-то двоичные строки. У нас есть двоичная строка F и двоичная строка P.
F как-то кодирует булевую формулу. Мы это подробно не обсуждали, но я думаю, вам понятно, как закодировать булевую формулу.
У нас есть алфавит, он, конечно, бесконечный, но вот как закодировать? Бесконечная часть у нас есть конечное число символов, которые, понятно, можно закодировать каким-нибудь способом.
И X и T. Как закодировать X и T? Давайте писать X, а дальше двоичная запись И. У нас в нашем алфавите нет ни символа X, ни нуля и единицы.
Мы получаем такой конечный алфавит, ну а конечный алфавит уже записать двоичными строками, это, я думаю, вы понимаете, что не очень сложно.
Таким образом мы можем кодировать формулы. Ну и в качестве доказательства мы предъявляем какую-то двоичную строку.
Какие требования к этому алгоритму, чтобы это была система доказательств? Требования такие. Во-первых, алгоритм должен работать достаточно быстро.
Он работает за время, которое полинамиально зависит от длины входа. То есть длина входа у нас это сумма длин, строки, задающие формулу и строки, задающие доказательства.
И вот алгоритм должен, то есть мы хотим все-таки, чтобы доказательство можно было легко проверить, потому что если доказательство еще и трудно проверить, то это уже вообще не очень понятно, что это за доказательство.
Доказательство должно подвергаться автоматически, просто, быстро. И, скажем, доказательство в нашей системе исчисления высказываний такому свойству удовлетворяет, потому что в качестве второго аргумента мы подаем просто последовательность формул, которая является выводом.
И все, что нам нужно проверять, это, во-первых, что первое слово задает формулу, второе слово задает вывод, который заканчивается нашей формулой, но это сравнительно легко проверить, чтобы одно двоичное слово содержит другое в каком-то формате.
И что все, что происходит внутри, подчиняется нашим правилам, то есть либо стоит аксиома, либо получается по моду спонс. А как проверить, что какая формула аксиома или полученная из двух других по моду спонс?
А для этого все, что нам нужно, это разбор формул. Вот если мы можем формулу приставить в виде дерева, как я рисовал, то есть разобрать, указать какая связка там первая, применяется потомков тоже какая первая и так далее, то дальше проверка, что формула удовлетворяет схеме аксиом или проверка, что формула получается по моду спонсу, тоже сводится к тому, что мы проверяем просто равенство конкретных двоичных слов.
С проверкой равенства двоичных слов проблем нет, а чтобы разобрать формулу, ну, проблемы есть, но не очень сложные. Фактически, за счет того, что я специально определял формулы так, чтобы там были правильные скобочные выражения, по сути дела вам нужно проверять, разбирать скобочные выражения, то есть находить вот эту скобочную структуру, и тогда вы можете сказать, какая операция применяется последней.
Про правильные скобочные выражения вам, может быть, уже на тряпе и объяснили. Это частный пример контекстно-свободного грамматика. Было уже или еще не было? Дошли вы до контекстно-свободного грамматика? А, еще нет. Ну, значит, будет.
Но, в общем, это несложно. На самом деле, конкретно со скобочными выражениями я подозреваю, что многие знают, как их разбирать. Ну, я очень коротко скажу, нужно скобочный итог считать. Скобочный итог – это разность между количеством открывающих и закрывающих скобок.
Ну и вот правильное скобочное выражение обладает таким замечательным свойством, что скобочный итог в конце ноль, а в каждой промежуточной позиции не отрицательный. Ну и тогда, если вы знаете это правило, очень легко понять, где там в формуле стоит последняя связка.
В общем, я пропускаю детали. Ну, а подсчет скобочного итога – это тоже очень эффективное действие. То есть исчислению высказываний отвечает такой алгоритм.
Но каким еще свойством должен обладать этот алгоритм? Если формула тавтология, ну, точнее, строка, кодирующая тавтологию, то существует доказательство для этой тавтологии. То есть алгоритм на такой паре F и P дает единицу.
Это то, что я называл полнотой. Для любой тавтологии есть вывод. Ну а третья – это корректность. Если F не тавтология, то для любого второго аргумента алгоритм дает ноль.
То есть алгоритм – это такой судья или, если угодно, преподаватель. Значит, студенту дается вопрос, является ли формула тавтологии.
Студент пишет решение. Это вот второй аргумент. Если это формула тавтологии, нужно, чтобы было правильное решение. Если нет тавтологии, то преподаватель отвергнет любое решение.
Вот этого на самом деле нам и хочется, по сути дела. То есть то, что мы так вот modus ponens используем, это следы от классической логики.
А в современном мире, если у нас есть вот такая система, доказательство, то есть такой алгоритм, то это ничуть не хуже, чем классическая логика.
Будем мы использовать компьютеры для того, чтобы для длинных формул запускать этот алгоритм. Руками может быть этот алгоритм запустить сложно.
Будем использовать компьютеры. Ну и что, мы их и так используем. Нужно, конечно, проверять корректность программ, которые выполняют этот алгоритм.
Ну это все-таки одна и единственная программа. Один и единственный раз можно потратить силы, написать, в конце концов, на коке, где, так сказать, вы пишете программу, которая одновременно с доказательством ее корректности.
В общем, есть способы добиться твердой уверенности, что программа работает правильно. Надо постараться просто. Это отдельная проблема, относящаяся скорее к программированию.
А в остальном ничем не хуже. И вот можно сказать, что такой алгоритм тоже задает некоторую формальную систему. Там даже непонятно, что у нас есть доказательства, оно не обязательно разбивается на какие-то шаги.
Так часто бывает, что оно разбивается на какие-то шаги. Но может быть и никаких шагов. Там может быть совершенно другая структура.
Вообще, для тавтологии таких систем доказательств известно много. Исчисление высказываний одно из самых сильных. В том смысле, что доказательства самые короткие.
Ну то есть, если уж есть доказательства, нас еще может интересовать доказательства покороче. Само доказательство может быть намного длиннее, чем формула. Это не противоречит нашему определению.
Мы считаем работу алгоритма по общей длине входа. Но тем не менее, в разных системах доказательств длины, доказательств разные.
Скажем, очень легко из табличного метода тоже получить систему доказательств. Ну вот просто вы записываете формулу, а дальше пишете вычисления всех этих строчек таблицы.
Это тоже система доказательств. Потому что проверить эти вычисления, ясное дело, легко, если вы уже все написали. Но она для любой формулы будет иметь длину не меньше, чем 2 в степени n, где n количество переменных формул.
И это много. А есть более экономные системы доказательств. Вот исчисление высказываний, как я говорил, одна из самых экономных.
Сейчас уже даже нельзя сказать, что самые экономные, потому что ее там научились сращивать с другими довольно мощными системами.
Идеи в этих системах доказательств очень разные. И я хочу рассказать, сегодня и в следующий раз, я хочу рассказать об одной из таких систем, доказательств.
Почему о ней? Вот если исчисление высказываний было выбрано, потому что, во-первых, все доказательства получаются достаточно короткими, и оно имеет ясные связи с классической логикой,
то вторую систему доказательств, которую я хочу рассказать, это тоже будет формальная система, я даже ее назову исчисления тоже. Она важна с точки зрения практики.
На самом деле, вот эта система, которую я буду рассказывать, она сидит, значит, проверки тавтологии, она практически важная.
И есть куча программ, которые это делают. И вот практически все эффективные программы, они содержат вот эту часть, и эта часть, на самом деле, основной мотор.
То есть хорошие программы содержат еще много чего, но я в следующий раз прокомментирую это, может быть, более подробно.
Но это оказалась некоторая очень важная вещь. И, собственно, люди придумали эту систему уже в конце 50-х годов прошлого века, когда появились компьютеры.
Система основана на так называемом правиле резолюции.
Ну ладно, я пишу какие-то, может быть, не самые удачные буквы, это все неважно.
Значит, смотрите, если у нас есть формулы A или не B, и формула C или B, то мы можем вывести формулу A или C.
Это называется резолюция.
Ну, прежде всего, конечно, важно понять, что это корректно.
Корректность я проверю так. Я докажу, что семантически, если вот это истина, то это тоже истина.
Что нам нужно для доказательства корректности? В точности вот такое утверждение, что семантически следует.
Ну а как доказать, что семантически следует? Да очень просто.
Смотрите, ну я уже стер, к сожалению. Что такое семантическое исследование?
Если вот есть выполняющий набор для этих формул, то тогда на нем эта формула равна 1.
Другими словами, если эта формула равна 0, контрпозиция, то тогда хотя бы одна из этих двух формул равна 0.
Ну давайте представим, что X или Z равна 0. Что это означает? Мы знаем, что это означает, что X равен 0 и Z равен 0.
Но если X равен 0, то отсюда мы получаем сразу такие вещи.
X или Y равен не Y, а Z или Y равен Y, потому что X и Z равны 0.
Ну и смотрите, у нас получается, что одна формула совпадает со значением Y, а другая с отрицанием Y.
Они обе единицы равняться никак не могут. Какая-то должна равняться 0.
Значит, если на каком-то наборе значений переменных X или Z обращается в 0, тогда и вот одна из пар в резолюции тоже обращается в 0.
Но это, другими словами, если здесь обе эти формулы равны единице, эта формула тоже равна единице.
Тут, как видите, ничего сложного. Вопрос в том, как применять это правило.
Оно уже, заметьте, не выглядит как часть логического рассуждения в классической математике.
Мы, конечно, можем так рассуждать. Такие рассуждения в жизни бывают, что мы доказали так и сяк, а потом вывели то, что хотели.
Этому можно придать самый разный смысл, в том числе и более-менее понятный с логической точки зрения.
Но тем не менее, чтобы применять такое правило, мы уже видим, что оно очень хорошо применяется к формулам, которые состоят из дизьюнции чего-то там достаточно простого.
И на самом деле мы будем применять резолюцию к тому, что называется KNF.
Конъюнкция дизьюнции литерала. Я надеюсь, что вас в прошлом году уже учили этим словам.
Тем не менее, я напомню, что вот это вот называется дизьюнктом. То есть формула, которая является дизьюнцией литерала, называется дизьюнктом.
Литерал – это переменная или отрицание.
Тут я написал конъюнцию, но можно считать, что у нас просто задано множество. Я в следующий раз это подробнее обсужу.
Давайте рассмотрим какой-нибудь простой пример. Допустим, мы хотим доказать, что такое множество дизьюнктов не совместно.
Тут еще один важный момент. Резолюциями мы будем не доказывать, не писать доказательства какой-то формулы, а строить опровержение.
Мы будем доказывать, что какие-то формулы невыполнимы, то есть всегда равны нулю.
Но невыполнимость формулы равносильно к автологичности ее отрицания.
Если формула невыполнимая, значит она на каждом наборе переменных равна нулю, значит ее отрицание на каждом наборе переменных равно единице.
То есть это логически равносильные условия, поэтому проверка невыполнимости, проверка тавтологичности – это задачи тесно связанные.
В следующем семестре вам объяснят тонкую разницу между ними, я сейчас на это не буду тратить время.
Ну и фактически опровержение состоит в том, что мы доказываем, что какой-то набор формул несовместный.
Вы уже видели из доказательства полноты, что мы скорее всего сводим к проверке несовместности.
Ну и как это сделать с помощью резолюции? Очень просто.
Смотрите, я беру вот эту пару формул и вывожу из нее формулу А. Ну А или А формально, если смотреть на правила резолюции.
Но мы в методе резолюции знаем, что А равносильно А или А. То есть мы лишних не пишем литералов в дизюнкте.
Хорошо, берем не А или Б, не А или не Б. Выводим по правилу резолюции точно также не А.
А теперь смотрите, у меня есть А и не А. К этой паре тоже можно применить резолюции.
Ну у нас формально там вроде бы как должно быть две члена, а тут всего по одному.
Но мы мысленно допишем дизюнцию с ложью. Вот такой вот значенка перпендикулярной логики так обозначают ложь.
Ясно, что А и А или ложь – это равносильные утверждения.
Это я написал, чтобы соответствовало нашему формату правила резолюции.
И мы выводим ложь. То есть получается так, что мы знаем корректность, я уже проверил корректность.
Все, что мы выводим резолюциями, если вот эти вот формулы истины, то на таком наборе значений переменных истина и все, что мы выводим.
А ложь ложна всегда. То есть если мы вывели ложь, это означает, что выполняющего набора просто нет.
Вот основная идея метода резолюции.
Возникает много трудностей. Не трудностей, а мы только начали, это основная идея.
Надо разбираться, что делать дальше.
И сегодня я попробую покрыть одну из этих проблем.
Во-первых, неясно, в каких случаях мы можем получить ложь, в каких не можем. Это все в следующий раз будем обсуждать.
Но есть другая принципиальная трудность, которую, может быть, вы уже заметили.
Я хочу систему доказательств для произвольных формул. То есть проверка тавтологии любой формы.
А здесь у меня есть КНФ, и я проверяю ее невыполнимость.
Другими словами, я проверяю, если я возьму отрицание КНФ, то это получится что?
По законам Деморгана, конъюнция перейдет в дизюнцию, конъюнция.
То есть получится ДНФ, дизюнктивная нормальная форма.
То есть я фактически буду строить систему, которая будет проверять тавтологичность ДНФ.
Но ДНФ – это не все формулы. Надо что-то про остальные формулы сказать, что-то с ними сделать.
Вот это, я надеюсь, сегодня объяснить.
И в следующий раз уже к этому возвращаться не буду.
То есть я даже не буду переходить к ДНФ, я буду именно на языке КНФ.
То есть мне хочется проверять невыполнимость формул.
Ясно, что если мне нужно проверять тавтологичность, я просто напишу отрицание формулы и сведу вопрос к проверке невыполнимости.
Давайте вспоминать, чему вас учили в прошлом году.
Учили ли вас, что любая булева функция представляется КНФ?
Про ДНФ я надеюсь точно учили, но про КНФ там двойственно.
Я сейчас напишу формулу.
Если у меня есть булева функция, то ее можно представить так, как конъюнцию по всем наборам, на которых эта функция равна нулю, дизюнции вот таких вот литералов.
Обычное обозначение, х в первой степени х, х в нулевой степени отрицания х.
Вот такой дизюнкт равен нулю только когда каждый из его членов равен нулю, и это бывает только на наборе альфа.
Тут все переменные входят от единицы до Н.
Ну и дальше уже легко проверить, что поскольку я беру конъюнцию по всем нулям функции, то получаю в точности эту функцию.
Таким образом, казалось бы, вопроса нет. У нас есть формула, есть соответствует какая-то булева функция, давайте эту булевую функцию представим в виде КНФ.
Но проблема есть. Посмотрите в каком контексте мы все это делаем. Мы хотим какую-то разумную систему доказательств.
А если мы будем делать так, то как правило нулею функ
функций очень много, экспоненциально много. И вот эта КНФ будет очень длинной.
Система доказательств получится. У нас и табличная система доказательств есть, но она получится такой, что более-менее для любой формулы ничего хорошего мы не получим.
Мы получим только очень длинные доказательства.
А нас, конечно, это неформально, это в определении системы доказательств не фиксируется, это такой показатель того, насколько система доказательств хороша.
Нас, конечно, интересует длина выводов.
Например, важный открытый вопрос, одна из центральных проблем теоретической информатики, есть ли система доказательств в том смысле, в котором я написал,
в которой для каждой тавтологии есть вывод полиномиального размера, полиномиального длины формулы.
Ответ неизвестен.
Люди предполагают, что нет, но никто этого не знает.
Никто не знает даже про наше исчисление высказываний, верно ли, что существуют формулы, для которых длина вывода больше, чем полиномы.
Я вам в качестве бонусной задачи предложил намного более простую.
Существуют формулы, для которых длина вывода не константа.
Это люди умеют делать, но не сильно больше.
То есть, если на самом деле вы чуть-чуть, любое решение этой задачи, если оно дает сверхконстантную оценку, там какая-то функция, растущая длины формулы,
она очень медленно будет расти, на самом деле сильно лучше люди делать не умеют.
Наверное, получше можно, но это настолько плохие оценки, что никто ими не заморачивается.
Вопрос открыт.
Но для нас это проблема.
Значит, мы не можем так просто взять и перейти к вот этой, как говорят, совершенной КНФ.
Она слишком длинная.
Мы хотим сделать такой переход, чтобы по формуле мы написали КНФ, длина которой не очень сильно отличается от длины формулы.
И вот тут проблема.
Равносильную такую КНФ можно задать далеко не всегда.
Это легко построить примеры, я не буду опять-таки на этом останавливаться.
Есть примеры, когда ничего лучше, чем совершенная КНФ, нет.
Так что же делать?
А делать нужно вот что.
Давайте вспомним, что нас интересуют вопросы выполнимости или невыполнимости формы.
Нам не нужно КНФ, которая равносильна нашей форме.
Это очень важная идея.
В той части курса я ее тоже буду использовать.
Ее вот очень важно прям сейчас осознать.
Нам достаточно, если у меня есть формула А, достаточно построить КНФ по этой формуле.
Такую, что выполнимость формулы равносильно выполнимость этой КНФ.
То есть, мы не обязаны, вот эта формула не обязана быть равносильной, задавать ту же самую булливую функцию.
Как мы увидим, в ней даже будет другое количество переменных.
И это тоже не возражает.
Единственное, что нам нужно, чтобы была эффективная процедура, как мы строим эту КНФ,
потому что у нас все должно быть эффективно в системе доказательств.
Ну и, в частности, длина этой КНФ должна быть не очень большим.
Вот это я как раз сегодня, у меня еще 10 минут.
И вот это я как раз хотел бы успеть рассказать.
То есть, я надеюсь, что понятно, какую проблему я решаю.
Я хочу по произвольной булливой формуле построить КНФ.
Такую, что выполнимость формулы равносильно выполнимость этой КНФ.
Процедура должна быть достаточно эффективной.
Ну и, в частности, длина КНФ не должна быть сильно больше длины формулы.
Сейчас я это проделаю.
И для этого мне потребуется разбор формулы.
Чтобы было понятно доказательство, я прямо сразу
напишу дерево разбора.
В конце у нас какие-то переменные тут сидят.
А тут, в этом дереве, сидят наши связки.
Можно доказывать и для формул с другими связками.
Рассуждение совершенно аналогичное.
То есть, то, что я сейчас говорю, верно для формулы,
которая использует любое конечное количество связок.
То есть, для простоты, чтобы меньше писать случаев,
я буду писать только отрицание и импликацию.
Если добавить дизюнцию и конюнцию, там вы сейчас увидите,
в каком месте нужно добавить.
Абсолютно ничего в рассуждении не меняется.
Ну раз у нас есть дерево.
Смотрите, вот листям приписаны переменные.
А внутренним вершинам пока еще никаких переменных не приписано.
Но каждая внутренняя вершина задает некоторую подформулу,
которую я буду обозначать B.
То есть, вот это вот все, это формула A.
И вот каждой внутренней вершине я сопоставлю новую переменную.
Вот я ее обозначаю ZA, ZB.
То есть, каждой внутренней вершине дерева разбора формулы
я сопоставляю новую переменную.
А ясно, что этих переменных не очень много,
потому что количество вершин в дереве разбора,
но оно линейно ограничено длиной формулы.
Тут совершенно понятно.
Что я делаю дальше?
Дальше я делаю вот что.
Я строю вот эту КНФ так.
Так, я пишу
конъюнцию.
Значит, там будет...
Один дизюнк будет состоять только из переменной,
вспоминания, отвечающей всей формуле.
Переменная за циндексом A.
А дальше будет конъюнция.
Ну, давайте я как-нибудь напишу
D, B, какое-нибудь обозначение.
То есть, у меня будет каждой внутренней вершине дерева разбора
будет отвечать своя КНФ.
Вот это вот КНФ.
Тут все-таки лучше я напишу какую-то другую букву.
Ну, пусть будет K.
D как-то на дизюнк слишком похоже.
Там КНФ будет.
Не один дизюнк.
Как это выглядит?
Правило очень простое.
Вот представьте, что я хочу
для вершины B, которая является импликацией.
Чего-то там.
Тут у меня вершина C.
Тут у меня вот C уже было.
Пусть будет...
Ну, пусть будет X и Y.
Неважно как я это назову.
Неважно какие здесь связки.
Вот переменная ZX, ZY.
Как будет устроена вот эта вот КБ?
Это КНФ, которая равносильна такой формуле.
Функции, задаваемые такой формулой.
Z beta
равносильно
импликации ZX, ZY.
Написано довольно сложно, но понятно, что это такое.
Что означает это логическое условие?
Оно означает, что значения в этих трех узлах дерева
связаны очень просто.
Значение в верхнем узле является импликацией значения нижнего.
Потому что эквивалентность это равенство.
То есть вот это логическое условие говорит,
что ZB это импликация нижних значений.
Тут могут быть не обязательно вспомогательные переменные.
Могут быть и основные переменные X,
и тогда надо написать просто основную перемену.
Ну и с отрицанием очень похоже, еще проще.
Потому что у нас один потомок.
Мы должны просто написать формулу,
которая равносильна ZB, равносильна отрицанию ZX.
Что мы выиграли?
Смотрите, вот эти вот формулы имеют конечный размер.
Тут две переменные, тут три переменные.
Если я для них напишу совершенную KNF,
там будет заведывание больше 8 дизъюнктов.
На самом деле верхней формуле будет 4 дизъюнкта.
Это легко проверить, сколько там нулей.
Нижнее того меньше.
То есть у нас вот эти вот KNF имеют константный размер.
То есть вот здесь у нас появляются какие-то дизъюнкты,
но в небольшом количестве.
Их количество не более чем 8 раз больше,
чем количество внутренних узлов дерева.
Поэтому вся формула очень компактная.
И, я думаю, понятно, что такое построение
резуется эффективным алгоритмом.
Если вы уж построили дерево разбора,
то дальше вот все остальное делается автоматически.
Ну, выписать для конкретной функции из трех переменов,
вы можете просто сразу выписать эту совершенную KNF.
Это прямо в код ее вогнать.
Не надо, чтобы это делал алгоритм.
Тут никакой сложности нет.
Все, что осталось, это доказать вот это утверждение.
Но оно практически очевидно.
Потому что вспомните, как мы определяли значение формулы.
Мы вычисляли его по этому дереву разбора.
И все, что нам теперь нужно доказать индукцией
по разбору формулы, это такое утверждение,
что предположим, что формула выполнима.
То есть на каком-то наборе значений переменных
она равна единице.
Давайте тогда припишем с помогательным переменным
значения, которые задаются на вот этом вот наборе.
И KNF на таком наборе будет истина.
Почему?
Ну, потому что, смотрите,
вот это и есть правило вычисления,
индуктивного вычисления значения формулы по дереву.
Переменным присвоили какие-то значения.
Вот из этого набора альфа.
Дальше, если у меня есть какой-то внутренний узел,
я вычисляю по связке.
И это в точности значение.
Мы видим, что это значение в точности соответствует.
Ну, и для каждого узла у нас своя формула.
Все вместе, это нужно, конечно, аккуратно написать индукцию
по разбору формулы, но это совершенно несложно сделать.
У нас получится то, что нужно.
Теперь в обратную сторону.
Предположим, что вот это выполнимо.
То есть, у нас есть какой-то набор значений переменных,
альфа основных переменных и бета вспомогательных переменных,
на которых KNF равна единице.
Что это означает?
Мы должны теперь доказать другую сторону.
Это означает следующее, что
я хочу доказать, что формула А только на альфа будет истинной.
И доказательство очень простое.
Мне нужно по индукции проверить такое же равенство,
что z бета от бета – это в точности значение под формулы альфа.
Ну, и по построению моей KNF это достаточно очевидно.
Вот эта вспомогательная KNF, которая отвечает внутреннему узлу,
она вообще равна единице,
если у нас правильно определено значение в верхний узел,
переменную, отвечающую верхнему узлу,
мы помещаем результат применения связки к значениям, которые получены ниже.
Ну, значит, по индукции будет вот это равенство сохраняться,
и так оно поднимется до самого верха.
Вот и все.
На этом доказательство, по сути дела, закончено.
Я пропускаю вот эти вот технические детали аккуратные,
запись рассуждения по индукции, но она достаточно очевидна.
То есть основная идея – понятно, что мы следим за выполнением…
То есть как мы вычисляем значение формулы?
Мы вычисляем индуктивно.
Если за одно из значений переменных мы берем внутренний узел,
который зависит только от переменных,
вычисляем в нем значение в соответствии с этой связкой и продолжаем.
Но раз мы вычисляем значение в соответствии с этой связкой,
это фиксируется вот таким вот условием,
что значение вспомогательной переменной в верхнем узле
равно значению связки от значений в нижних узлах.
Если мы добились выполнения всех этих условий,
конечно, мы все посчитали правильно.
Таким образом, я хочу зафиксировать,
чтобы в следующий раз особо на это время не тратить.
Мы убедились, что у нас…
Я напомню, что наша система доказательств
может содержать какие-то алгоритмические действия произвольного характера.
Наша система доказательств
к автологичности какой-то формулы будет устроена так.
Мы, прежде всего, приписываем к формуле отрицания.
Это очень эффективная процедура.
То есть, если у вас есть формула,
ну что там, просто три значка написать вокруг нее.
Дальше для этой формулы мы делаем разбор,
строим вот эту вот КНФ,
а на полученную КНФ мы уже запускаем некоторую другую формальную систему,
которая называется исчисление резолюций,
которую я в следующий раз опишу.
То есть, там уже доказательством
будет вывод в исчисление резолюций для полученной КНФ.
То есть, в нашей системе доказательств
будет важный вот такой шаг при процессинге,
когда мы произвольную формулу превращаем в КНФ.
И дальше доказываем невыполнимость.
То есть, опровергаем эту КНФ,
доказываем ее невыполнимость,
выводим из дезюмта в этой КНФ тождественную ложь.
Вот что мы делаем.
Как мы это делаем?
Это отдельная история.
Все в следующий раз.
И нужно, конечно, формально определить все эти манипуляции из КНФ.
Но тут за полпары точно это все не успеешь.
В следующий раз, я думаю, мы с этим всем разберемся.
Это все не так сложно.
А вот переход от общих формул КНФ, я надеюсь, стал понятен.
Ну, на сегодня тогда все.
