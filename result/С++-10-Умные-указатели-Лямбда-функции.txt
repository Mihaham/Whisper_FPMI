Следующий пункт называется EnableSharedFromThis Да, смотрите, есть следующая проблема.
Когда у вас есть какой-то класс, и вы хотите вернуть из метода этого класса указатель на него,
вот вы хотите сделать, типа, return this кому-то, сказать. А 12.4 у нас что было?
UQPTR. Make shared. Вот, у вас есть какой-то класс. Вы перешли и все, наступило светлое будущее,
и теперь все указатели у вас умные. Нету стишных пойнтеров вообще, вы пользуетесь только shared.ptr
и UQPTR, как и хотел Strausdrup. Но у вас есть this еще. Вот если вы имеете дело с указателем на
текущий объект, и этот указатель хотите куда-то передать, ну вот вы такие пишете метод класса,
и хотите куда-то вернуть this указатель на текущий объект, у вас возникает проблема,
потому что этот сишный указатель, а если до этого вы имели дело только с shared.ptr,
вы кому-то отдадите сишный указатель, то он просто не сможет его принять. У вас все указатели теперь
shared. Если вы кому-то отдадите сишный pointer, а примет он его как shared.ptr, то у вас будет
двойное удаление опять, потому что вы создадите таким образом вторую ветку shared.ptr на то же самое.
То есть вы не можете возвращать this в чистом виде, вы должны shared.ptr на себя возвращать,
чтобы кто-то им дальше там пользовался в какую-то функцию, если хотите передать. Но и написать
return shared.ptr от this вы не можете, потому что вы опять получится создадите вторую ветку shared.ptr
на то же самое. Короче, если вам надо создать shared.ptr от себя, вот вам нужно сделать
вернуть this как shared.ptr, что вам надо сделать? Как это сделать вообще внутри своего собственного класса?
Ну это близко. Есть стандартное решение для этого. И для этого существует такой библиотечный класс
называется enable shared from this. Решение заключается в следующем. Вы просто пишете,
ну, у меня там есть какой-нибудь класс, и я говорю, что это публичный наследник. Не публичный,
на самом деле. Я могу сказать, что это приватный наследник, потому что никому особо не надо
знать, что я наследник. Публичное наследование, вы говорите, что я частный случай того, и каждый
может этот факт использовать. При варпинг наследовании вы говорите, что вы ничего не говорите, вы лишь
используете методы поля того в себе, но другим рассказ не хотите о том, что вы их используете.
Публичное наследование это значит, что каждый может вызывать методы родителя у вас, когда вы
наследник. Так вот, ну давайте я скажу что-то private на самом деле, enable shared from this,
потому что не подразумевается, что кто-то должен вызывать. Ну, protected, ладно.
std enable shared from this с шаблонным параметром c.
Что, я создал класс c, наследник enable shared from this с шаблонным параметром c.
Чтобы уметь возвращать shared ptr на себя.
Как это вообще работает, да. Вот это называется
CRTP. Сейчас я расшифрую. Curiously recursive template pattern. У такого решения есть
название, это такой паттерн проектирования объекта ориентированное, вот он называется
CRTP. Curiously recursive template pattern. Когда вы делаете класс, наследник другого шаблонного класса
шаблонным параметром ваш собственный класс. Почему это корректно работает? Потому что, что по
сути означает, что вы инстанцируете вот это с шаблонным параметром вас. Это означает просто,
что компилятор генерирует код, формально подставив туда вместо шаблонного параметра это.
Но если при этом там не объявляется нигде объект вас, а объявляется лишь указатель на вас, то в этом
принципе, ну это нормально, ничего страшного. Вот. Нет, оно само по себе работает. В смысле
наследование себя от чего-то шаблонного с шаблонным параметром вы сами, это нормально. Просто. Это
нормально, все так делают. Ну просто компилятор формально подставит это в качестве T туда и
сгенерирует соответствующий код. Ну он там понятно, он сгенерирует там. Нет, скорее они
формально подставляют, просто если в какой-то момент получается, что действительно ты пытаешься
создать объект класса, который не объявлен, то это проблема, да. А указатель на объект класса,
который не объявлен, нормально. А, который неопределен, нормально. Который неопределен,
это нормально, да. Можем. Ну да. Ну указатель, чтобы знать указатель, тебе не надо знать ни
size, ни line, ничего. Указатель, это просто число, разыменование которого дает тебе все. Точно так же,
как и ссылку. Ну вот, короче, enableSharedFromThis. Теперь, когда мы от этого наследовались,
у нас появился метод sharedFromThis. И чтобы получить, собственно, sharedPtr на себя,
нужно просто вызывать этот метод sharedFromThis без параметров. Вот. Вопрос, как реализован enable
sharedFromThis. Нет, он хранит weakPtr. Смотрите, enableSharedFromThis, ну давайте попробуем реализовать.
Да, если вы уже внутри этого класса, значит, если у вас создался C, то sharedPtr на C уже создался,
вот так. Тогда бы у вас не было sharedPtr. Сейчас, на стеке. Мы должны weakPtr создать,
от чего? От sharedPtr. Что это за sharedPtr будет внутри enableSharedFromThis? Сейчас подумаем.
Сейчас напишу enableSharedFromThis. Нет, пока не научились. Да, пока не научились. И
я даже не уверен, что, что-то кажется, мы функции сегодня не успеем. Да, как-то затянулось. Наверное,
это из-за того, что у нас доска, и из-за этого замедляется. Вообще, на самом деле, когда две пары,
а не одна, но как-то время течет как-то по-другому, и получается, что одна тема рассчитывается на две
пары, вместо того, чтобы на одну. Это как-то неоптимально. Вроде пар две, а рассказать успел,
как будто одна всего прошла. weakPtr, на T я здесь храню. ВП я не знаю. Давайте подумаем. Как работает
sharedFromThis? sharedFromThis просто возвращает вот этот вот VP лог. sharedFromThis, ну, он, наверное,
const и возвращает VP.log. Причем, тут возникает вопрос, а что, если там был nullPtr? Ну, в смысле,
если он был экспарит, так вот давайте подумаем, может ли он быть экспарит. Для начала давайте
поймем вообще, как создается этот веб, чем он инициализируется, кто и в какой момент его
инициализирует. Вот главный вопрос, кто и в какой момент инициализирует это weakPtr. Вообще, в какой
момент создается enableSharedFromThis? EnableSharedFromThis создается тогда, когда создается C. Создание C
начинается с того, что создается enableSharedFromThis. То есть, вот этот вот weakPtr на C сейчас надо
чем-то проинциализировать. А чем проинциализировать? Когда что? Когда что просто так создаем? Да, это
поле. В какой момент, это никакой не момент, это просто поле класса, вот как здесь написано,
ты же не спрашиваешь здесь, что произойдет в этот момент, это никакой не момент, это объявление поля.
Так вот, теперь уже вопрос в динамике, что будет происходить. Ну, то есть, когда это все реально
начинает создаваться, как это инициализируется? Когда создается enableSharedFromThis? Ну, нам надо
написать конструктор enableSharedFromThis, наверное. Или что? Ну как? Вот что надо сделать? Смотрите,
я утверждаю, что когда создается enableSharedFromThis, уже должен существовать sharedPtr на то, на что нам надо.
Потому что, если мы собираемся, если у нас есть sharedPtr на C, то первичное именно создание
sharedPtr на C, а не C. Мы и собираемся возвращать sharedPtr на себя. Это значит, что до этого кто-то нас
должен был создать через sharedPtr. Сам класс C и владение им происходит через sharedPtr. То есть,
кто-то создал sharedPtr на C, после чего начали вызывать sharedFromThis. Бессмысленно, если у нас
бы не было sharedPtr на себя, то sharedFromThis вызывать было бы нельзя. Кого? Правильно,
нам нужно, чтобы, если создается sharedPtr на C, мы проинициализировали этот weakPtr правильным
sharedPtr. Так вот, на самом деле, нам нужен еще один конструктор sharedPtr. Мы сейчас sharedPtr еще
модифицируем снова. Мы сейчас добавим в sharedPtr специальный конструктор, еще один приватный,
который будет вызываться в случае, если наш класс это... Ой, я виноват, нам конструктор не
потребуется, нам просто if один потребуется в конструкторе. Мы просто в конструктор sharedPtr допишем
такую вещь. Если constexpr std isBasedOf t enableSharedFromThis t... Значит, isBasedOf – это метафункция,
которая проверяет, является ли один тип наследником другого. Причем неважно публичным
или приватным наследником, кстати. Ну, получается так, да. Нет, извне нельзя.
Статик кастом из внешней функции нельзя, конечно, да. Вы задаете правильные вопросы,
но мы реализуем его в очередь несколько пар. Значит, хорошо, std isBasedOf v, что является базой чего?
Ну, значит, isBasedOf. Base derived. То есть сначала пишем базу, enableSharedFromThis – это база.
EnableSharedFromThis – это база. EnableSharedFromThis t – это база.
А это наследник. Так вот, если это так, то надо вызвать… А то надо что сделать?
Кстати, отличный вопрос. Проинцелизировать ВП у чего? У t, у нашего объекта. Вот у того t
который… А где мы возьмем t? Ну да, у нас есть указатель на что-то там, на control блок, в котором t…
Короче, нам надо просто сказать, что base… Ну, вот этот вот наш блок, стрелочка. Блок, стрелочка, object.
Точка ВП. Так, object – это база enableSharedFromThis. Значит, у него есть поле ВП.
Ну, а если оно проточено через RETAPCAST? Оно проявляется. Оно уже проявляется, кстати.
В минимальном процессе никак вообще. Это вообще беда. Не, можно через RETAPCAST.
Ну, может, не надо? Это же код, на который никто никогда не будет смотреть.
Да, да, да. Кстати, да. А это поможет? Нет.
Да, потому что private, потому что вот это private, оно же с точки зрения C.
Ну, то есть это C запрещает нам ходить к своему родителю. Вот, что происходит. Ну, окей.
Ну, значит, наверное, здесь public все-таки надо, а не private. А protected-то чем поможет?
Нет, shared.ptr – это же не наследник C. Вот я здесь из метода shared.ptr пытаюсь обратиться к полю C,
которая от родителя. Ну, shared.ptr – это же не наследник C. Короче, надо public все-таки делать, видимо.
Нет, можно, конечно, написать, наверное, template class T, friend class T. Нет, наверное, так нельзя.
Все мои друзья… Нет, нет, забудьте, так нельзя. Надо, чтобы shared.ptr был другом этого.
Ну, значит public. Как не выбрано поле, object.vp. Почему?
Господи. Ну, shared.ptr – это public. Ну, а тут друзьями сделаем, кого надо.
shared.ptr и enabled.shared.fromthis – мы их друзьями просто сделаем, это нормально.
Ну все, говорим, что вот так. Ну да, видимо, публично все-таки, приватно не получится.
Так, понятно, вот эта строчка. Что здесь произошло?
shared.ptr. Звездочка this сейчас – это shared.ptr. Мы сейчас находимся в конструкторе shared.ptr.
И мы этот week.ptr инициализируем вот с собой, то есть тем shared.ptr, который мы сейчас являемся.
Таким образом, этот week.ptr будет инициализирован, как только создастся класс C, потому что создастся enabled.shared.fromthis от C.
А он, ну, если, виноват, если создастся shared.ptr на C, то в этот момент уже будет инициализирован вот этот.
Во всех, конечно. Ну, то есть, да.
Как только, короче, как только создастся shared.ptr на C впервые, сразу же будет инициализирован вот этот вот VP shared.ptr вот этим вот.
И таким образом мы сможем через функцию shared.fromthis его получать.
А если мы создали C не через shared.ptr, то есть просто создали C, shared.ptr на C не создали, просто создали C,
тогда эта штука инициализируется по умолчанию, и тогда вызов shared.fromthis будет кидать исключение.
Нормально?
У тебя исключение не нормально?
Ну, можешь не кидать исключение AOB делать?
Может, лучше.
Ну, каждому свое.
А?
А, не кидает исключение, да? Ну, значит, я ошибся, да, значит, не кидает исключение.
Ну, хорошо, ну вот.
Так, ну что, понятно с enabled.shared.fromthis, и как он реализован?
В каждом объекте теперь храним два лишних указательных.
В каждом каком объекте?
Ну, вот, написано C, в нем лишние два указательных.
Ну...
Ну, видимо, это не страшно, потому что указатели нужны для того, чтобы как раз-таки не влиять объект,
но, значит, объект можно самим сделать тяжелее, еще потяжелее, потом еще немного потяжелее.
И скоро мы получим...
И скоро мы...
Да, и так мы постепенно получаем джаву или питон, да?
Да.
Сейчас какие-нибудь атрибуты появятся, пишите на джаву или питон.
Так, мы постепенно сейчас придем к этому.
Я уже, знаете...
Значит, короче, не только с твоей стороны идет пропаганда питона,
но у нас сейчас параллельно нужно сделать примерно одинаковые проекты по плюсовому питону.
Ага, в смысле одинаковые проекты?
Вам надо лист с аллокатором на питоне написать?
Нет, на языке C++, на ТП.
И там просят на языке C++ написать, а у некоторых просят строго на языке.
Ну, короче, неважно.
И вот сейчас многие люди пишут примерно похожие проекты одновременно близок на питоне,
увидят, насколько проще писать их на питоне, и все.
Дегаше пропало.
Так, давайте следующим пунктом и последним в этой теме, наверное, на этот раз обсудим
самое болезненное, наверное, что связано с shared PTR.
Ну, как бы, все, что помещено красным, все боль.
Но это еще не такая большая боль, как то, что будет сейчас.
Так, про enable shared from this. Все понятно, да? Все, все поняли?
Классно.
Вот. Теперь смотрите.
Нет, нет, мы же уже говорили про это.
Неважно, эта штука в любом случае там будет написана.
Вот.
Так, следующий пункт.
И сейчас я вам вот о чем напомню.
Помните, у нас была такая договоренность, что вообще-то иногда мы можем хотеть
Ну, вообще-то, короче, библиотечные классы не должны обращаться к оператору Нью напрямую.
Потому что вдруг у нас вся память на стэке должна выделяться, на самом деле, а не в динамической памяти.
А shared PTR, как выяснилось, вызывает оператор Нью в себе.
Это неправильно. Он должен делать это через аллокатор.
Нам надо, чтобы shared PTR создавал этот control-блок свой, или что, как он там называется у нас, каунтер,
или как он там называется?
Каунтер.
Каунтер.
Каунтер.
Каунтер.
Каунтер.
Каунтер.
Каунтер.
Каунтер.
Каунтер.
Каунтер.
Каунтер.
Через аллокатор.
В частности, чтобы функция make shared не делала оператор Нью, не делала Нью control-блок, бла-бла-бла,
а делала это через аллокатор.
Не, ну, казалось бы, ладно, просто делаем через аллокатор и все.
Но.
Но.
Аллокатор – это не шаблонный параметр shared PTR.
Это означает, что.
А почему не шаблонный параметр?
Потому что в большинстве случаев ты не хочешь думать о нем.
И для shared.
Ну, в общем, так не сделано.
Почему не шаблонный параметром make shared?
На самом деле есть функция allocate shared.
Еще.
Вот давайте функцию allocate shared.
Ну, сейчас я до конца, наверное, не расскажу, как это реализовано.
Нам надо еще кое-что будет пройти, а потом мы вернемся.
Вот как раз это та проблема, решение которой будет, наверное, основную боль составлять.
У нас будет функция allocate shared.
allocate shared – это функция, которая принимает make shared, а потом еще arcs.
Какой make shared?
Который принимает allocator, потом arcs.
На самом деле make shared – она в одну строчку реализована.
Это просто allocate shared от std allocator и тех же самых arcs.
И главное интерес.
Что такое allocate shared?
Смотрите.
Давайте напишу.
Там template.
Ладно, напишу все-таки.
Type name t.
Type name alloc.
Type name arcs.
Shared ptr t allocate shared.
Allocate unique нет по понятным причинам, потому что у unique ptr нет такой проблемы, что им надо еще какую-то свою память выделить.
Shared ptr t allocate shared.
Ну и сюда я приму alloc.
Make unique не выделяет…
Ну, в общем, make unique…
Да, ну хорошо.
Ну в общем нету make unique, потому что считается, что если вы хотите выделить не на стандартном allocator, то делайте это сами.
Вот так.
Ну, с shared ptr так вы не сможете.
Потому что если вам нужно сделать unique ptr не на стандартном allocator, ну сделайте его просто.
Потом unique ptr передайте функцию удалитель там.
Не delete, а deal locate и что-то такое.
Мы еще, кстати, не обсудили, как кастомные функции delete передавать.
Но это мы тоже обсудим.
Но в allocate…
Но в make shared вы никак не заставите shared ptr…
У вас нет способа вручную создать shared ptr так, чтобы он вот этот свой counter не выделил на нестандартном allocator.
Вам только через allocate shared придется это делать.
Смысл в том, что shared ptr из-за того, что он выделяет дополнительные счетчики к себе,
вы никак не можете его заставить это вручную сделать на нестандартном allocator,
поэтому вам приходится через allocate shared это делать.
Так вот, allocator и arcs.
Но allocator я по значению принял, потому что типа он легкий.
Вот, теперь смотрите.
Теперь у меня есть allocator, но этот allocator – это allocator на t.
А мне нужно алоцировать не t, а control block.
Значит, я должен из этого allocator создать allocator на control block,
алоцировать на нем control block, вызвать там construct t по правильному адресу.
Вот, но что самое главное…
Ну и все, и казалось бы, и создал shared ptr от этого.
Но как потом этот shared ptr удаляться будет?
Вот shared ptr умирает.
А он должен освободить все за собой, удалить t, удалить…
Допустим, он заметил, что evict ptr-ов нет, ему нужно удалить все и control block, освободить память.
Но он же должен это сделать тоже тем allocator, который создавал, если изначально, если он не через new.
shared ptr-у надо помнить, каким allocator-ом он создавался.
Ты вот забываешь кое-что и переспрашиваешь, а почему shared ptr не может?
Сколько памяти мы ему выделили, пока всего 2 мт.
У меня памяти меньше.
У тебя памяти побольше, чем 8 байт, тем не менее, пока ты тоже довольно много забываешь.
Так вот, как shared ptr-у удаляться правильным allocator-ом?
Да, в блоке сохраним. А что сохраним?
Объект какого allocator-а?
Объект какого allocator-а?
А allocator сам каким будет?
Как будет выглядеть твоя структура? Ну, она называлась counter, да? Я зря ее стер.
У нас вот эти два счетчика, и давай, третий поле, это будет что конкретно?
Какой allocator-то?
Хорошо, и тогда здесь будет counter с каким шаблонным параметром?
Потому что мы договорились, что у нас счетчики и вся вспомогательная штука лежит в этой структуре.
Base control block, это там только T лежит. А тут лежат счетчики и дополнительная всякая вещь.
По умолчанию, вот здесь вот.
А мы решили, что нельзя.
Нет, shared PTR не имеет второго шаблонного параметра. Вот так вот сделано.
Он умеет, вот вы можете shared PTR сохранить что-то с помощью одного allocator, а потом присвоить этому shared PTR что-то выделенное на другом allocator.
То есть на другом принципиальном allocator.
Выделенный стандартным allocator.
Ты можешь ему присвоить указатель на T, но ты можешь ему присвоить shared PTR, у которого другой allocator.
В общем, ты не думаешь об allocator.
Вот такая проблема, и что делать?
Можно было бы создать вторым параметром allocator.
И просто когда мы делаем присваивание, возвращать...
Ну давайте хранить просто... Зачем нам знать, на каком allocator мы выделились?
Если у тебя есть оператор равно, то это очень трудно.
Если у тебя есть оператор равно, то это очень трудно.
Если мы дали без звездочки, я считаю, что она через стол.
Нет, я вообще не понимаю.
Если мы создаем... Мы забудем про все новые проблемы, которые мы создавали.
Если у нас есть T-звездочка, и нам ее дали.
Мы теперь за нее ответственны, а мы не знаем, как вы выделили.
Нет, в таком случае мы просто сохраним стандартный allocator.
Что ты назвал новыми проблемами тогда?
Если мы создали T-звездочки, значит мы создали стандартный allocator.
Не стандартный allocator можно было создать только через allocate shared.
Просто нет способа создать не стандартный allocator не через allocate shared у пользователя.
Почему?
Как?
Пользователь выделил не на не стандартном allocator, а счетчик на стандартном allocator был выделен.
Ну тогда пользователь сам виноват.
Поэтому лучше make shared использовать.
Да, поэтому тоже лучше make shared использовать.
Если пользователь выделил на не стандартном allocator, но не сказал нам об этом, не сказал sharedptr о том, что нестандартная функция удаления.
Ну извините.
sharedptr конечно не обещает тогда корректности.
Вот.
В общем нам надо сохранить здесь указатель на нечто...
Который умеет удалять.
Такая проблема с тем, что если нам дали указатель, мы не знаем чем удалять.
Решена. Давайте хранить какую-то функцию.
Ну не знаю.
Давайте хранить функцию, которая умеет удалять.
Функцию удалитель.
Ну, в принципе да.
Ну на самом деле нам бы надо еще хранить destruct.
Ну то есть нам надо...
А если делал бы стандартный?
Нет, нам надо...
У allocator же вызывать constra, destroy, вот это вот dialocate.
Причем что именно нам надо диалацировать?
Нам надо диалацировать то t, то что-то еще.
То есть нам же...
Иногда нам надо диалацировать просто...
А, нет, вру.
Если мы не стандартным нокатором, то значит мы через...
Можно просто здесь либо ничего...
Либо nullptr хранить.
Это будет означать, что нет никакой функции, не стандартная.
Просто delete.
Либо хранить функцию, которая...
Ну указатель на функцию.
Делать освобождение по адресу...
Короче, освобождать control-блок.
Ну и можно указатель на destroy тоже делать.
Смотрите, давайте тогда поступим вот так.
Я сейчас проблему запихаю вглубь.
То есть я не объясню как это реализовано внутри.
А я лишь скажу, что мы сейчас воспользуемся стандартным классом с defunction.
Опа!
Ну смотрите, есть такой замечательный класс с defunction.
Значит, stdefunction...
А вот я не помню, кстати.
Может быть function прямо в таком отклоде есть.
stdefunction
с шаблонными параметрами
void
от
void
от
void
от
void
от
Ну то есть...
Как там шаблонные параметры записываются?
Вы пишете возвращаемое значение,
с кубиц от принимаемых значений.
Значит void от
от
не t звездочки, а
control-блок звездочка?
Да.
void от control-блок звездочка.
Вот.
Ну вот.
Ну это вот такая синтоксическая конструкция,
которая вот...
Я не знаю больше, где она используется,
кроме как в шаблонных параметрах с defunction.
То есть ты можешь такой...
Короче, вот эта вот штука
это будет
вещь, которая...
Которая...
Которая что?
Которая вызывается,
когда...
Верно, что нам всегда их нужно вызвать обе?
Верно, что нам всегда их нужно вызвать обе?
Ну да.
Нет-нет, это только...
Нет, ну, в control-блоке
обязательно нужно и то, и другое,
потому что wikiptr потом должен это делать.
Хранить мы должны и хобби.
Ладно,
это все классно.
Мы сохранили, допустим, функцию,
аналогично, диалогей пусть будет функцией,
но она будет называться диалог,
я не знаю, диалог.
Вот, хорошо.
А чем мы пронициализируем это?
Вот мы здесь вот создаемся
от этого аллокатора. Чем пронициализировать
этот диалог?
Ну, нам нужно это пронициализировать
чем?
Нет, это штука,
которой можно присвоить любую функцию,
любой функциональный объект, давай так.
Ее можно пронициализировать как указателем
на C-шную функцию, так указателем на
метод, так и указателем
не указателем, а
просто функциональным объектом. То есть объекту,
у которого круглые скобочки определены.
Нет, функциональный объект
создавать не нужно, вот он. Вот это он и есть.
등, то есть это и будет функциональный объект.
Его можно tongulitzировать как готовым функциональным
объектом, так и любой функции в частности указателем
на метод.
Мы хотим видимо tongulizировать указателем на метод.
А тогда у
Ты не решил проблему, что ты аллокатор не хранишь.
Тебе нужен объект аллокатора, чтобы вызвать метод аллокатора.
От того, что ты сохранишь фанкшн...
Какой аллокатор?
А, блин!
Это присвоение...
Войт-звездочки вообще!
Что такое?
А?
Нам нужно как-то когда-то сделать...
Мы не понимаем диалогу, какое значение, да?
А мы знаем, какой у нас аллокатор, только у аллокейт-шерт.
Нам нужно либо сделать конструктор, который принимает аллокатор.
Шаблонный конструктор.
Особый диструктур надо...
Откуда...
Не, нам все равно, откуда надо аллокатор.
Так что...
Может реально шаблонный конструктор, который принимает еще аллокатор.
Давайте писаем аллокейт-шерт.
Давайте запишем про него.
Ну, в смысле?
Вот время конструктора прошло, мы сконструировались, что мы положили в себя.
Мы не можем положить в себя аллокатор, потому что мы не можем объединить его.
Короче, бегом от аллока и запихиваем...
Похоже, не можем.
Чтобы его вызвать потом, нам нужен объект класса.
Зачем нужны функшн?
Кажется, что функшн сейчас не поможет.
Именно у объекта аллокатора мы можем вызвать аллокейт через точку.
Не через аллокейт.
Чем еще нужны есть де функшн?
Не дестрой.
Да, но кажется, что идея этого была неправильной.
С де функшн, кажется, у меня не получится сейчас.
Что?
Как?
Шаблонный функшн.
Короче, я предложу вот что.
Я хочу сделать...
Так, сейчас.
Не, можно и так, да.
Это вариант у меня хранить один из двух типов.
Но можно описать SD Any?
Как это нам поможет?
Как это работает?
Я знаю, что это объект аллокатора.
Какого аллокатора?
Какого угодно.
Тебе, чтобы вызвать метод класса, тебе нужно сначала сказать, что за класс.
То есть даже если ты используешь Any, тебе нужно сказать AnyCast к такому-то типу точкой диалокейта.
А можно как-то хранить именно сам тип через какой-нибудь юзинг или что-то такое?
Через юзинг?
Ну, чрез юзинг нельзя, потому что мы не можем менять.
А как-то записать...
Строк выхранить, короче.
Название типа.
Я же предложил, вот звездочка на аллокаторе и typeof.
В общем, знаете, что я хочу сделать?
Я хочу на самом деле сейчас сказать, что давайте мы эту проблему отложим.
Потому что кажется, что надо про нее рассказывать.
Сразу вместе.
Это некоторая целая...
Короче, есть большая проблема.
Нам нужно как-то сохранить аллокатор, но мы не знаем какого типа.
Они могут быть разные, динамически подменяющимися.
Вот.
Давайте я скажу, что эта проблема будет нами решена через две лекции.
И вот тогда мы поймем, как это все работает.
А заодно поймем, как работает Function, Any и все прочее.
Вот.
Существует один способ.
Это сделать...
Ну, сейчас я не хочу про него рассказывать.
Но может кто-нибудь выяснил, что придумает до того, как я про него рассказывал.
Ну, может кто-нибудь выяснил, что придумает до того, как я про него рассказывал.
Ну, короче, мы с вами реализуем.
Через две пары мы с вами реализуем Any, во-первых.
И реализуем Function.
Ну через 3-и.
А когда мы это сделаем, мы поймем, как это сделать.
Вот так.
А то есть у нас возникла вот здесь проблема, которую мы пока не умеем решать.
И чтобы ее решить, мы с начала поймем, как вот эти вещи реализованы.
Изначально мы решаем все вот эти вещи.
И чтобы ее решить, мы сначала поймем, как вообще вот эти вот вещи реализованы изнутри,
а потом автоматически мы сразу понимаем, как и эта штука будет работать. Вот так.
Вот, короче. Все. На этом я хочу закончить тему умных показателей, но мы к ней еще вернемся, потому что вот.
А еще у нас может быть кастомный дилитер. То есть, смотрите, у нас может быть аллокатор нестандартный,
а еще может быть дилитер нестандартный. То есть...
Мы же убедим, что это птр.
Это не шаблонный параметр shared ptr, это шаблонный параметр...
Ты можешь создать shared ptr от t звездочка и еще объекта дилитер.
Дилитер — это функциональный объект.
То есть, это на самом деле может быть и аллокатор, и дилитер еще нестандартный.
Что такое нестандартный дилитер?
Это...
Кажется, что комбинировать их нельзя.
То есть, ты можешь либо создать shared ptr с нестандартным дилитером, но тогда обязательно от t звездочки,
либо allocate shared, но тогда у тебя нет возможности сделать нестандартный аллокатор, нестандартный дилитер.
Что такое нестандартный дилитер?
Это означает, что у тебя вместо освобождения памяти вызывается другая штука.
Просто функция освобождения. Она не удаление представляет себя, а что-то другое, например, закрытие с его усоединения.
А может быть, shared ptr от t звездочки и какой-то функции.
А может быть, shared ptr от нестандартного аллокатора.
И все это вот здесь вот нужно как-то сохранить, то есть, нужно сохранить некоторую вещь,
которой как-то вот динамически обращается, она может быть динамически подменяться на разные типы,
и смотря, что там был нестандартный аллокатор, нестандартный дилитер, мы туда ходим в деструкторе и понимаем, что вызвать сейчас.
Да, может быть, нужен нестандартный дилитер, если он может быть профессионально просто в деструкторе класса, который нам передали.
Почему мы не говорим, если уж ходить в нестандартный дилитер, пишите его в своем деструкторе?
Ну, мазохизм, ну, нет.
Ты... ну, давай подумаем.
Как это?
Ам, ну, сейчас.
Ну, вот, смотри, есть такой стандартный, наверное, пример, когда нужно RAII, кроме как с выделением памяти.
Например, если у тебя есть Mutex. Знаете ли вы, что такое Mutex?
Ну, короче, когда у тебя есть блокировка, в смысле, у тебя есть такой класс, которому ты вызываешь метод Lock, и это означает, что никто другой, пока ты не вызовешь Unlock, не сможет сделать Lock, он зависнет просто на этом Lock.
Вот, и тебе надо, выходя из функции, обязательно не забыть сделать Unlock, несмотря ни на что.
Ну, деструктор Mutex, он... Mutex у тебя в нескольких потоках, это один объект, к которому из нескольких потоков могут обращаться.
Вот, сам он не уничтожается, но нужно обязательно Unlock сделать, перед тем, как ты выйдешь из функции, и не забыть.
То есть, ты не уничтожаешь T, ты вызываешь некоторую функцию над ним.
То есть, у тебя должна быть какая-то операция, которую ты обязательно должен сделать над объектом T, перед тем, как функцию свою покинуть.
Вот, и это стандартный пример, как, может быть, нужно RAII не для выделения освобождения памяти.
Ну, вот для многопоточности, например.
И в связи с этим существует даже класс SharedLock, но ладно.
Интересно, интересно.
Я не знаю, понятен ли был пример, но, кажется, пример я привел.
Так, сколько времени у нас? 11.48.
12 минут. Ну, слушайте, мы начали, блин, на 15 минут позже, конечно.
И причем не из-за меня, я опоздал всего на 10 минут.
Вот, а сейчас 17 минут.
Так, короче, вот здесь я пока ставлю ToDo, непонятно, что делать.
И все, и сотру это все.
И теперь я перейду к следующей теме, а следующая тема это как раз будет про функции и функциональные объекты.
Значит, какой план?
Сейчас мы плюс-минус поняли, как устроено умные указатели, по-моему, для вот этой вот проблемы,
что непонятно, как свой аллокатор и свой делитер туда класть.
И сейчас я хочу еще одну рассмотреть языковую фичу.
Следующая тема будет называться лямбда-функции.
Так, значит, тема 13.
Лямбда-функции.
Проходили ли вы лямбда-функции на Матлогике уже?
Нет. Они в конце года.
Блин, ну жалко. Ну ладно.
Никто не проходил. Смотрите, есть функции, можно их объявлять.
Идем дальше.
Значит, лямбда-функции – это тоже, начиная с и плюс-минус 11, фича.
Классная фича. Можно же забирать, если будет видео.
Не понял пока про что ты, но ладно.
Можно же подтягивать в функции.
Так-то обычные функции такого не умеют.
Ну...
Потому что это же не функция, а объект-план.
Так, значит, лямбда-функции. Смотрите, план.
Сейчас мы поговорим про то, что такое лямбда-функции и, значит, какие дополнительные возможности, какие проблемы они приносят.
А потом поговорим как раз про CD-фанкшн.
Ну, про CD-фанкшн, в принципе, я уже и так сказал.
Ну, я просто скажу, что он есть, и, значит, мы им попользуемся чуть-чуть.
А потом еще мы обсудим некоторые другие вещи, например, CD-bind.
Ну, то есть, функциональные, библиотечные классы для работы с функциональными объектами.
Вот.
И у нас останется один большой вопрос, как это все реализовано.
Потому что там ровно такая же проблема с CD-фанкшн, как и с...
Вот, которая у нас была там.
А именно CD-фанкшн можно подменять динамический тип, который нам хранится.
Ну, ты можешь присвоить функции одно, потом присвоить другое.
Если типа возвращаем в изучение, принимаем их такие же.
Вот.
И когда мы поймем, что у нас эта проблема возникла второй раз, мы перейдем к разговору о том, а как вообще реализован.
Ну, и следующая тема у нас будет называться Type Eraser.
И мы как раз обсудим, как реализован Any, во-первых.
Как реализована Function.
А потом вернемся к разговору про shared pointer и поймем, как реализовать вот эту штуку с дилитером и саллокатором.
Вот такой план.
Но сначала давайте поговорим про функциональные объекты.
Так вот.
13.1.
Идея.
И базовое использование.
Так.
Ну, что?
Что такое лямбда функции?
Плюсах.
А кто?
Нет.
Это объекты.
Ну, хорошо.
Сами функции.
Они, наверное, это будут методы.
Так.
Кто уже умеет пользоваться лямбда функциями в плюсах?
Ну, почти все.
Все понятно.
Ну, хорошо.
Ну, хорошо.
Ну, вот у меня есть STD-сорт.
И я хочу
передать туда.
Ретерн не нужен.
Шариш.
В смысле, он правильно все говорит?
По стандарту говорят, что можно не писать.
По стандарту это все плохо.
Может еще нормальный человек должен маску носить всегда?
Маски отменили.
Так вот и ретерн ноль отменили.
Ретерн ноль отменился.
Так вот.
STD-сорт.
Ну, допустим, тут был вектор.
Ну, был.
В.
В.
В.
В.
И вот я хочу передать сюда
нестандартный компаратор.
Что я тогда
должен написать?
Ну, я мог бы указательно функцию передать в C-стайле.
Но мне это не нравится.
Да.
Но я не хочу объявлять.
У меня огромная простыня кода.
Вот большая функция, там много классов.
Я внутри какого-то класса нахожусь.
Мне, чтобы сюда передать это,
мне придется объявлять
где-то там заранее
в какой-то области видимости функцию,
чтобы ее сюда передать.
Или еще лучше объявлять функциональный объект,
объявлять целый класс с аппаратом
круглой скобочки, чтобы его экземпляр сюда
передать. Вот чтобы мне такого не писать,
у меня есть очень короткая
синтоксическая конструкция.
Я могу просто передать сюда
объект,
который будет
являться функцией, созданной
прямо на месте.
Без предварительного объявления
типа этого объекта.
Давайте я
что-нибудь вообще простое.
Сортировка по убыванию будет.
Я просто верну...
СТД грейтер, короче.
Я пишу
квадратные скобочки пустые.
Внезапно.
Нет, не всегда, конечно.
Это...
Да, вот это как раз интересно.
Но пока пустые.
Дальше круглые скобочки
и аргументы.
Какие аргументы?
Ну, да, ну просто
int a, int b.
Круглая скобочка закрылась.
Фигурная скобочка.
И тут я
что пишу? А тут я просто пишу
return
a больше b.
Фигурная скобочка закрылась.
Круглая скобочка закрылась.
Точка запятой.
Ну, это вот эта круглая.
Вот, это
совершенно базовый примитивный использование
лямбда функций.
Это...
Ну, пока не будем говорить, что это.
Значит, здесь просто пустые квадратные
скобочки пока оставляем. Они сигнализируют
в том, что лямбда функции начинается.
Дальше список аргументов.
И дальше тело функций. Здесь может быть
произвольное совершенно тело.
И...
Дальше фигурная скобочка закрывается.
Точка запятой. Заметьте, что
я не написал явно какой возвращаемый тип
у этой лямбда функции.
А он автоматически выводится.
Дедукция, да.
Вот.
Можно явно указать
возвращаемый тип, если по какой-то причине
я считаю, что это нужно.
То есть компилятор выведет его сам.
Если бы, например, я сделал что-то в стиле,
ну как у нас было с выводом типов,
if там,
не знаю, a больше b, return...
Ну, короче, в одном случае
вернуть char в другом int.
Ну, в общем, если я сделаю...
А?
Если у меня конфликтующий
return type,
то это будет, конечно же, ce, потому что компилятор
скажет, не могу вывести
возвращаемый тип лямбда функции.
Здесь, вот здесь, после этой закрывающей скобочки,
я еще могу написать
стрелочку и тип.
Явно сказать, какой возвращаемый тип.
Вот это не обязательная часть.
То есть если вы хотите для лямбда функции
указать, какой тип он возвращает,
явно, то после списка аргументов
стрелка и тип.
Это уже третья стрелочка, верно?
Это уже третья, да, стрелочка по смыслу.
Ну, это скорее вторая.
Третья, это вот кастомные
правила вывода шаблонов, это скорее третья.
Это вторая.
Так, ладно.
Хорошо.
Дальше.
Ну,
что...
Кажется, что basic usage закончился,
действительно.
И давайте...
Да, правильно, это правда.
Ну, давайте про это я тоже скажу.
В basic usage.
Вот.
Ну, давайте действительно...
Я могу написать так.
Auto f равно вот это.
То есть вот это
все, это expression.
Да, давайте я еще введу пару
терминов.
Вот это вот.
Expression
это длинное
определение, что мы уже этот вопрос обсуждали
неоднократно.
Вот это вот называется
lambda expression.
Вот это все вместе.
А тут круглоскобочка уже не нужна.
Вот.
А
объект такого типа, как lambda expression,
называется closure.
Замыкание.
Вот.
Значит, closure.
Ну, можно встретить такой термин.
Значит, замыкание.
Ну, замыкание
это вот как раз
эта штука, которая получается...
Не-не, замыкание
это объект того,
что получается.
Нет, closure это объект.
Да, f это closure получается.
По-моему.
Я мог перепутать.
Ну, просто слово closure
иногда употребляется в применении к этому.
Вы можете встретить там
вот бла-бла-бла, вот я сделал замыкание
и потом бла-бла-бла.
Вот что такое замыкание?
Объект lambda функции
это closure.
Что?
Что?
Нет, вот это
это lambda expression.
Но может создать объект
такого типа, как это.
Ну, это же expression.
Оно
порождает какой-то объект.
Вот тот объект, который получается, значит closure.
Какой у него тип?
Непонятно.
Ну, авто подойдет.
Да.
А, кстати, можно ли вот так написать?
Да.
Вы уже прониклись духом.
Вот явно прониклись
духом плюсов. Давайте начнем.
Можно ли так?
Да, это R-value, поэтому так не должно быть.
По стандарту, конечно.
Ну, в смысле,
просто мы когда перечисляли expression,
мы не упомянули lambda expression.
Теперь давайте упомянем.
Скажем, что lambda expression тоже
и помянем, да.
Lambda expression это тоже
ну, constaft %f, разумеется, можно.
По общему правилу.
Ну, тоже можно.
Вот, окей.
Значит...
А, че?
Че?
О, да.
А че вы смеетесь?
Мы будем этим заниматься скоро.
Че же я? О, ноу!
Что я тут делал?
Зашел.
Не хочу, нет.
О, ноу.
А вы зря смеетесь? Это, между прочим, не такая
в смысле операция.
В смысле, это действительно полезная вещь.
Move lambda full, move объекты такие
действительно иногда пригодны.
То есть, это практически полезная штука.
Окей. Ну, все.
Можете создать объект такого типа.
Да, у этого объекта определены круглые скобочки.
От вот таких параметров,
как тут написано.
Можно в пункте с пишем структуру
определяем операцию круглые скобочки.
Вот, у нее какой-то непонятный тип.
То есть, можно
попробовать спросить компилятор,
какой тип у этой вещи.
Ну, то есть...
Кстати, можно ли,
если не дали непонятно что,
вывести на экран его тип?
Пожалуйста.
Самый простой способ, это им звездочка,
звездочка, звездочка, а равно вот этому.
Я, знаете, наверное, я...
Че, че, че, че?
Ну, чтобы узнать тип,
можно писать int звездочка, звездочка,
звездочка, а равно это.
И компилятор тебе выдаст ошибку и скажет,
что ты попытался присвоить.
Да, да, да, да, это правда, да.
То есть, чтобы узнать тип,
как он есть, это
вы просто генерируете намеренно ошибку
компиляции, и компилятор говорит вам, какой был тип.
Тип main, когда скобочки не значены в этой точке,
и в трехскобочках lambda.int, int.
Ну...
Ну, вот умный,
это просто
ну, это просто user-friendly
компилятор тебе объясняет, что. На самом деле, конечно,
тип называется у него не так, но просто
в выводе лога компилятора он пишет так.
Ну, я допомню, что еще есть
оператор typeID. Ты всегда можешь спросить
typeID от объекта
и вывести точку name.
Я вам, наверное, неправильно сказал
closure, это кажется
скорее... вот closure называет... ну, там
путаница есть. Ну, closure
еще называется тип вот того, что получилось как раз.
Да, ну вот то ли тип, то ли объект.
Вот кто-то называет объект,
кто-то называет тип, словом closure.
Тип того, что получилось.
Так, а еще
одна деталь. Вот, смотрите,
есть
объект, который называется
type.
Так, а еще
одна деталь. Вот, смотрите, если я
хочу лямбда функцию использовать как компоратор
для мэпа,
я могу так сделать?
Вот я говорю map, допустим,
от int, запятая int,
запятая,
и что тут надо написать?
Ну, вот
допустим, я тут
вот это вот объявил, а потом
такой map хочу
с таким компоратором.
Что я должен
сделать?
Декл-тайп от этого?
Да, декл-тайп от этого, конечно.
А оно сработает?
Да.
Почему?
Почему?
Мэп требует структуру.
Да, мэп требует структуру.
Мэп требует,
он не примет.
В смысле структуру?
В смысле структуру, где определены
квадраты.
Что значит
он требует?
В мэп
нельзя передать.
В мэп есть шаблонный конструктор
от cmp, который принимает cmp, так?
Ну, так это мы и отдадим
туда. Его тип будет совпадать
с типом того, что мы отдали.
В смысле про то, что нельзя передать bool.
Вот, нельзя написать функцию bool
и передать ее туда.
Он тебе не разрешит.
А, ты не можешь указательно
функцию передать?
В смысле сишную функцию ты не можешь
передать?
Ну да, это же объект,
тип совпадает, значит я могу передать.
Еще он будет ругаться, если там
не конст, вроде
не констант, а персант
или что-то такое.
Нет, не должен.
Были какие-то сложности?
Да, здесь
надо поправить
с констами, ну ладно.
Ну, короче, нормально. Это должно работать.
Это сработает.
То есть, пожалуйста,
лямбда функцию можно использовать как
компаратор для мэпа.
Вот таким образом.
Вы создали f, локально,
вы фактически создали локально функцию,
функциональный объект такой,
типа, который компилятор сам за вас
сгенерировал. А дальше, пожалуйста, пользуйтесь им
как надо.
Окей, это был Basic Usage, ну давайте я расскажу
немножечко не Basic Usage, тоже
чуть-чуть.
Ну, еще пока не Advanced,
скорее Intermediate Usage.
Давайте
я пойду дальше,
что?
Так, следующий пункт
это
Capture
List.
Да.
Ну, ты видимо знаешь, что это такое.
Вот, что такое Capture List?
Есть такое понятие
захват в лямбда функцию.
Capture.
И вот это как раз то,
зачем вот эти квадратные скобочки нужны были.
Это, на самом деле, не просто так.
Сюда тоже можно кое-что вписывать.
Сейчас разберемся.
Вот так по кодстайлу
не надо делать.
Отлично.
Значит, смотрите.
Давайте вообще
поймем,
что происходит.
Что вообще это такое
для компилятора?
Это компилятор, когда это видят, он генерирует какой-то
класс за вас, фактически,
с оператором круглые скобочки вот от таких
аргументов.
А что, если я хочу здесь
пользовать? Ну, вот скажем, у меня было
тут еще какой-нибудь, не знаю,
int c равно 5.
И я хочу написать
не так, а вот так.
У меня c не является параметром
функции, потому что вызывать я ее хочу от двух
аргументов. Ну, то есть, я хочу, чтобы у меня
функция была компаратором,
сравнивающим два ключа.
Но для ее работы
нужен параметр,
который не является параметром функции,
а он скорее является некоторым,
ну, некоторой фиксированной
константой для данной функции.
Но эта константа, она, например, вот отсюда
везет.
Если я так напишу... Да.
Чего мы хотим?
Ну, вот смотри, у меня есть компаратор.
Пусть я после этих строчек
поменяю c,
и вызваю.
Я хочу, чтобы в f, c
поменялась или нет?
Это разные варианты, да.
Смотря по ссылке
или по значению ты принял.
Захватишь, да.
Так вот, ну, вот если я так
напишу сейчас, вот как сейчас напишу, то это не
скомпилируется.
Вот это будет c,
потому что c
из этой области видимости не видна,
ее нет тут.
c в мейне, но то, что в лямбда функции,
это только a и b, вот c нету.
Ну, еще глобальные переменные, понятно. То есть, грубо говоря,
представлять себе это надо так.
Компилятор сгенерировал класс
и поставил его
вот, типа, перед мейном.
Ну, вот, примерно.
И в этом классе
все, что есть, это оператор круглые скобочки,
от этих a и b
и все, никого с c там нет.
Правильно.
Так вот, если я хочу, чтобы у меня в лямбда функции
было доступно что-то из того, что было
локально здесь доступно, мне надо в квадратные
скобочки засунуть. И это называется
capturing, захват в лямбду.
Я здесь пишу c, причем я не пишу int,
я пишу просто c в квадратных скобочках.
И это означает, что у меня,
когда лямбда функция создается,
ну, когда создается этот объект,
то у него в качестве поля
присутствует вот эта c.
То есть, получается,
создается такой, генерируется такой функциональный объект,
в котором a и b это параметры функционального вызова,
а c это поле.
Какого типа?
Int. Такого же, как было это.
Потому что типа этого было int.
А я хочу нет.
Ну нет,
я нигде не передал
type. Я передал это объект.
Ну, того типа
ты можешь, нет,
ты можешь захватить в лямбду,
смысл в чем? Ты хочешь, чтобы из лямбда тебе было
доступно что-то из того, что было доступно
локально. Ты хочешь в лямбде заиспользовать какие-то
переменные, которые у тебя здесь были, помимо этих.
Тогда ты их перечисляешь просто
через запятую здесь.
Ты спрашиваешь, а как мне сделать, чтобы эти перемены еще и другого типа
были? Ну, не знаю.
Например, захватить сюда, потом сказать
double d равно c. Или здесь заранее
сказать double d равно c. Это просто способ
сделать себе здесь доступными что-то, что было
здесь.
К чему? К... А, можешь ли ты передать
выражение?
Ты можешь
не совсем с таким синтаксисом начинать
c++14, но в целом да.
Ну, это
будет еще один из следующих пунктов. То есть можно
здесь написать на самом деле c равно чему-то
и тогда он сам догадается, чему
равно c. Какой
типу c. Но это...
Там некоторые есть с этим тонкости, которые
мы, видимо, уже не сегодня обсудим. Вот, это
я... Так вот теперь твой вопрос.
А если я c поменяю после этого, то здесь оно
поменяется или нет?
А как сделать, чтобы поменялось?
Да, персант нужно
поставить перед c здесь.
Вот это называется захват по ссылке.
Бывает захват по значению,
бывает захват по ссылке.
Ну, в общем случае это выглядит
так. Я пишу авто f
равно... И тут в квадратных скобках
перечисляю
через запятую все, что я хочу
захватить. Каждый из этого
может быть как по ссылке, так и по значению.
Вот.
Поминали про просто равно
и просто амперсант, да. Что если
я не хочу перечислять...
Ну, просто я хочу сказать, пусть
мне будет в лямбда функции видно все, что
было локально доступно.
Ой, а вот это кстати
я не помню.
Нет, можно все захватить
по ссылке, а что-то по значению, вот так
можно, а все, кроме чего то, захватить
такого вроде нельзя.
Я могу написать вот так.
Я могу написать просто
амперсант
в квадратных скобках
Это будет означать, что все локальные переменные
я захватываю по ссылке.
А могу написать просто
равно в квадратных скобках.
Это будет означать, что все локальные переменные
я захватываю по значению, т.е. они все копируются туда.
Там просто будет столько полей, сколько у тебя локальных
переменных, и все они туда скопируются.
На каждой захваченной перемену у тебя поле в классе создастся
функциональным, который компилятор сгенерирует.
Да.
Вот можно провести эксперимент и посмотреть, какой будет
sizeof от f.
Вот я утверждаю, что сейчас он будет 4, потому что там
все, что есть, это одно поле int.
Вот.
Ну можно...
Что?
Нет.
В смысле...
Функция...
Это просто...
Нет, это просто метод класса.
Вот.
Ну да, можно написать вот так, там равно запитаем
Это будет означать, что вы все захватили по значению,
а вот с по ссылке.
К чему именно?
Да, конечно.
f это объект, да.
Ну на стеке у нее только поля лежат.
А оператор он нигде не лежит.
Это просто функция, которая сгенерирована комп...
Ну как это?
Это не виртуальная же функция?
Если была виртуальная, то там бы началось.
Если мы скажем, вернем объект f из функции.
Да.
Который захватил ее локальные перемены.
Ты...
Черт, Евгений, конечно, ты очень правильные вопросы
задаешь, но это следующее, о чем надо здесь сказать.
Ладно.
Значит, все совершенно верно.
Если вы вернете, то есть почему это опасно?
Когда вы что-то захватываете в лямбду, начинается куча
потенциальных проблем, поэтому нужно все делать очень
аккуратно.
Вот это следующая проблема, очевидная, которая возникает,
что если вы были в какой-то функции, в которой создали
лямбду, в которую захотели локальные перемены и по
ссылке вернули лямбду наружу, локальные перемены уничтожились,
конечно, вы получите битую ссылку, соответственно,
битую...
Ну вызов такой лямбда функции будет УБ.
То есть понятно, это еще один способ выстрелить
еще один способ сделать так, чтобы ссылка пережила
время жизни того объекта, на который она ссылается.
Понятно проблема, да?
Если вы захватываете по ссылке, а то, что вы захватили
умирает раньше, чем ваша лямбда, то понятно, у вас
УБ.
Будет битая ссылка.
Но это еще не все, это еще не вся проблема.
Давайте я сейчас вот что сделаю, скажу, что я нахожусь
в классе, и это я в каком-то методе класса, но он автовозвращает.
И в этом методе я такое беру и говорю, я, короче, захватываю
что-то тут.
То есть что я делаю, смотрите, я могу захватить, вот если
я в объекте класса, вот в этом и вопрос, мне могут
быть нужны поля класса, но поля класса, у меня в этом
классе какие-то поля, там не знаю, int опять-таки a.
Допустим я хочу в лямбда функции, вот сейчас я создаю
лямбда функцию, и хочу тут вот там не знаю int b, и вернуть
надо a умножить на b, ну вот я хочу, чтобы у меня было
a отсюда доступно.
Вопрос, как мне этого добиться, понятно, что если я так
напишу, то никакого а не будет здесь.
Тут есть вот какое правило, когда вы сюда что-то записываете,
это может быть лишь локальные переменные, стековые переменные,
нельзя захватить сюда, нельзя написать сюда a, потому
что захватывать можно только переменные со стека, не
поля класса, ну вот не отсюда, и не из какой-то там namespace,
только вот с функцией, вот если у вас что-то локально
было здесь, вы это можете захватить, поле вы не можете
так захватить, но вы можете захватить this, то есть можно
написать вот так.
Это указатель, не важно как его захватить, по ссылке
или по значению.
Это ссылка на int, нет, минуточку, то, что ты пишем, не, это
не expression, это не парсица так, амперсант c это не означает
адрес c, это просто означает, это другой синтаксис совершенно,
это совершенно забудь про это, амперсант c это просто
означает, c захваченный по ссылке, это значит компилятор
создает амперсант, создает int амперсант c, который там
или отсылкой, это ничего общего не имеет с expression
амперсант c.
Так вот, еще раз, я не могу захватывать что-то, не
являясь локальным переменом, могу захватывать только
либо viz, вот еще такое правило, если я из класса хочу захватить
поля, то я должен захватить viz, я не могу написать a как
поле захватить.
Вот поэтому, нет, viz стрелочка, я могу просто написать
либо viz, то есть я могу написать viz и, допустим, запитая еще
какие-то локальные штуки отсюда, по сути, чтобы захватить
поля, у меня выбор только либо захватить viz, либо не
захватывать viz.
Нет, ну в плане, а пощипска к a внутри ляма функции,
через viz?
Просто через a.
А это специальный синтаксис?
Ну, ты специально специальный синтаксис?
viz – это специальный синтаксис, да.
Такой захват нам сразу дает доступ к этим переменам.
А вот если мы напишем viz стрелочка, это не будет значит
другое, потому что мы не можем захватывать viz?
Нет, ну в плане, а пощипска к a внутри ляма функции
может быть как?
Просто через a.
А это специальный синтаксис?
Ну, ты специально специальный синтаксис?
viz – это специальный синтаксис, да.
Окей, все.
Сейчас, я на самом деле засомневался, надо писать a или viz стрелочка
a.
Лучше проверьте.
Я что-то засомневался, может быть, это не будет
работать без viz.
Ну понятно, что пока мы здесь, это нормально.
Я написал a или viz стрелочка, это в принципе без разницы,
ну просто что-то из этого может не скомпилироваться.
Но я захватил viz, тем самым я как бы получил, ну я захватил
фактически указатель на объект, через него я получаю
доступ ко всем полям.
Ну теперь я написал return f.
И вот здесь в мейне такой, создал объект класса c, там
от пяти, то есть это пронициализировал питью, допустим.
Создал авто f равно, так, что я должен сделать?
Ну я хочу, короче, создать ситуацию, что у меня f пережило
объект.
Ну то есть я могу сказать new, давайте я могу сказать
так, c звездочка c равно, ну просто чтобы создать
такую ситуацию искусственно, понятно, что это, c звездочка
cp равно new c от пяти, дальше auto f равно cp стрелочка метод
и метод там от, а что такое, кстати, b, а нет, все нормально,
да, метод без параметров и значит дальше delete cp.
Что будет после этого, если я вызову f?
Ну правильно, да, то есть я могу захватить, то есть
если я из класса захватываю, если я хочу захватить поля
класса, то я захватываю viz по факту, и если я это
все куда-то передаю или возвращаю наружу, то нужно
следить за тем, чтобы этот класс не уничтожился, этот
объект этого класса не уничтожился до того, как я буду пользоваться
этой функцией.
А как бы она это проверила?
Ну как, ты видишь указатель, он какое-то числовое значение
имеет, как ты поймешь под ним объект north или нет,
кажется дежавю, мы, по-моему, это обсуждали сейчас назад,
shared counter, vcounter заведет, да, вот это все, а просто захватит,
господи, как мы его делали, enable shared from this, от this,
что, пусть она захватывает не this, а что, что значит
захватывает enable shared, вот здесь что написать надо,
как эта функция называется, я не могу здесь написать
метод, я не могу здесь написать expression, я здесь должен
написать имя переменной либо this.
Получается, если бы мы вообще захватили какой-нибудь
локальный пример, поскольку это было бы еще хуже, потому
что когда мы просто возвращаем уже обитая ссылка.
Ну да.
А если у нас есть параметры метода, их можно каптюлить?
Да, по-моему, параметры можно.
Ну да, так и будет эта ссылка у нас там пролезать,
и если та штука уничтожится раньше, чем мы вызвали, ну
беда.
Ну хорошо, ладно, давайте, наверное, на сегодня закончим.
