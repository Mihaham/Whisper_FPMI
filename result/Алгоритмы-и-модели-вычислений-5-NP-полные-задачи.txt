Так, ну хорошо. Насколько я понял, в некоторых группах уже раньше разговоры про НПП-полноту, про конкретные задачи.
Ну, тем не менее, я про это тоже расскажу на лекции. Дайте я вкратце напомню, что мы успели изучить в предыдущие два раза.
Значит, НП-полная задача. Ну, определение, напомню, такое, что В, НП-полная, значит, если, во-первых, В лежит в НП,
и во-вторых, для любого А из НП верно, что А сводится к В.
Значит, и мы доказали термку Кукулевина.
Теорема Кукулевина заключается в том, что задача о выполнимости 3-кНФ, то есть множество таких ФИ, что ФИ имеет вид 3-кНФ,
и при этом ФИ выполнимо, то есть существует такой Х, что ФИ от Х равно 1, значит, такая задача НП-полная.
Ну и дальше, значит, дальше мы будем пользоваться таким утверждением, значит, утверждение, что если, значит, В, НП-полная,
значит, В выполняет свойство к С, и С лежит в НП, то тогда, соответственно, С тоже НП-полная.
Ну и вот это утверждение, это ключевая лемма, которая позволяет получать новые НП-полные задачи.
Ну и, соответственно, как правило, в качестве отправной точки выступает именно вот эта вот задача, выполнимость 3-кНФ,
ну, может быть, через каких-то посредников.
Ну и, в общем, за прошедшие 50 лет, даже 51 уже, ну, не, наверное, еще не 51, 50 с половиной,
значит, за прошедшие полвека очень про многие задачи была получена НП-полнота.
Значит, как правило, вот эта вот вторая часть, что цель лежит в НП, это достаточно очевидная вещь,
а что-то содержательное происходит вот здесь, вот, в сводимости.
Но бывает и не так. Бывает, что и вот эта часть содержательная, и даже, наоборот, вот это очевидно, вот это нужно доказывать.
Да, в общем, бывает по-всякому.
Ну, то есть можно смотреть на вот эти вот НП-полные задачи как на переформулировке одной и той же задачи.
Ну, можно считать вот этой задачей, можно какой-нибудь другой.
То есть переформулировки, перекодировки.
Значит, так что мы перекодируем так, что если решение было, то и в новой задаче будет решение,
если решения не было, то его и в новой задаче тоже не будет.
Вот.
Хорошо.
Ну, теперь давайте поговорим про несколько разных групп задач.
Значит, вообще НП-полные задачи, они в самых разных областях, где средства математики встречаются,
может быть там в алгебре, может быть в комминаторике, может быть в логике, как вот эта, собственно, задача.
Могут просто какие-то отдельные задачи, связанные там с головоломками там или с чем-нибудь.
Потому что вообще любая НП-задача, она имеет такой характер головоломки,
что вот есть Х, это как бы исходная позиция.
Нужно найти Y, которая подходит, которая является решением.
Ну, точнее, в НП-задаче вопрос есть ли решение в принципе, но, может быть, это похожие вещи.
То есть мы немножко поговорим в конце про задача поиска.
Один вопрос – это есть решение или нет, а другой вопрос – это прям-таки его найти.
Вот, хорошо.
Значит, первая группа связана с теорией графов.
Значит, рассмотрим вот такие вот связанные друг с другом задачи.
Значит, клика, независимое множество и вершинное покрытие.
Значит, клика, напомню, что это множество пар из графа и числа таких, что в графе G есть полный подграф из K-вершин.
То есть есть K-вершин, которые все друг с другом соединены.
Значит, такой полный подграф и называется кликой.
Соответственно, независимое множество тут, например, то же самое, только наоборот.
Значит, в графе G есть независимое множество из K-вершин.
Соответственно, должно быть K-вершин, которые все друг с другом по парно не соединены.
Ну и самое интересное, это вершинное покрытие.
Ну, самое интересное в смысле, что немножко сложнее формировка.
Здесь тоже пары из G и K.
Значит, здесь в графе G есть K-вершин.
Значит, такие, что любое ребро, ну это называется инцидентно,
то есть, можно сказать, содержит или касается хотя бы одной из вершин.
Ну или можно еще сказать так, что в любом ребре из двух концов хотя бы один лежит в этом множестве.
Значит, любое ребро на тем, что касается хотя бы одной из этих вершин.
Хотя бы одной из этих вершин.
Ну, можно себе представить такую задачу, которая к этой формализации приводит,
что пусть у нас есть сети аэропортов, какая-то авиакомпания как-то между ними летает,
какие-то маршруты у этой авиакомпании есть, и авиакомпания хочет,
чтобы как можно в меньшем числе аэропортов создать представительство,
но так, чтобы на любом маршруте хотя бы в одном городе представительство было.
Но вот это вот и есть задача вершинопокрытия.
То есть, здесь вершины это аэропорты, ребра это маршруты.
Соответственно, нужно, чтобы на каждом ребре хотя бы на одном его конце был представитель.
Вот.
И вот эти три задачи на самом деле друг на друга очень похожи.
То есть, проще всего показать, что они сводятся друг к другу.
А потом, соответственно, что к одной из них сводятся, ну, вот, например, три KNF.
Ну, давайте обсудим.
Значит, проще всего сказать, почему клика равна сильно независимому множеству.
Ну, просто можно взять дополнение к графу.
То есть, все ребра, которые были, удалить, а всех, которые не было, наоборот добавить.
Ну, и тогда, соответственно, если был полный под граф, то он станет пустым под графом.
То есть, как раз независимым множеством.
Но и наоборот. То есть, это сводится с обеих сторон.
Значит, если было независимым множеством, то в дополнении будет полный под граф на тех же самых вершинах.
Ну, то есть, формально можно сказать так, что gk превращается в дополнение g и то же самое число k.
Значит, такая вот сводимость работает и в ту, и в другую сторону.
Да, и клику к независимому множеству сводит, и наоборот.
Ну, я думаю, это понятно. Дальше чуть-чуть сложнее, но все равно довольно просто.
Значит, независимое множество равносильно вершинному покрытию.
А здесь идея такая же. На самом деле, дополнение e к независимому множеству в том же самом графе будет вершинным покрытием.
И наоборот, дополнение e к вершинному покрытию будет независимым множеством.
Так, это почему? Ну, потому что, смотрите, вот пусть у нас есть независимое множество, есть все остальное.
Но смотрите, внутри независимого множества ребер нет.
Значит, любое ребро, оно либо целиком снаружи, либо соединяет независимое множество с дополнением, со всем остальным.
В любом случае, каждое ребро имеет хотя бы одну вершину снаружи.
Ну и наоборот, если у нас есть вершинное покрытие, мы каким-то множеством все ребра покрыли, то если придем к дополнению, то там ни одного ребра уже быть не может.
Иначе там будет непокрытое ребро.
Поэтому здесь получается свадимость такая.
Значит, g и k превращается в g и n-k.
Почему нам тут даже не нужно уточнять?
Потому что здесь я говорю, что просто имеет размера дополнения, где начало вершин.
Ну, потому что если есть независимое множество, еще антиклик это называется, независимое множество,
значит, если есть антиклик размера k, то тогда ее дополнение это вершины покрытия размера n-k.
То есть если есть такое, то есть такое.
Ну и наоборот, если нет клики размера k, нет антиклики, значит, если нет антиклики размера k, то нет и вершинного покрытия размера n-k.
Потому что если бы было вершины покрытия такого размера, то его дополнение было бы независимо множеством размера k.
Поэтому это действительно свадимость.
И, конечно, это очень простые операции, они все полиномиальные.
Поэтому все эти три множества равносильны друг к другу.
Ну и, соответственно, нужно, можно сказать теорему, что, соответственно, все эти множества, значит, все эти множества или языки или задачи по-разному говорят,
все эти задачи n-k полные.
Ну, поскольку они уже все свойства друг к другу, достаточно какой-нибудь одной из них свести что-то, что у нас уже есть, например, трясат.
Так, ну давайте...
Так, а у кого-нибудь на семинаре к чему-нибудь из этого сводилось?
Клики сводилось, да?
Ну давайте для разнообразия к вершинному покрытию я сведу.
Значит, сведу выполнимость рек НФ, значит, к вершинному покрытию.
Значит, вообще есть некоторая общая диалогия, значит, как вообще такие свадимости должны быть устроены.
Смотрите, у нас изначально есть формула вида 3kNF.
Значит, в этой формуле есть какие-то переменные и какие-то скобки с переменными.
Соответственно, им всем должны соответствовать какие-то структуры в том, что мы строим в данном случае в графе.
Соответственно, должны быть какие-то структуры, которые соответствуют вершинам, которые соответствуют переменам,
и какие-то структуры, которые соответствуют скобочкам.
Такие структуры принято назвать гаджетами.
Ну и, значит, как правило, это не универсальное правило, но там в 90% случаев строятся какие-то гаджеты для переменных,
гаджеты для скобок, ну и каким-то образом они друг с другом связываются, чтобы это отражало устройство формулы.
Ну и дальше доказывать, что если форма выполнима, то тогда вот в этой структуре, которую мы построили, будет решение.
А если не выполним, то не будет.
Соответственно, в данном случае нам нужно, на самом деле, построить две вещи.
Нам нужно построить граф и нужно определить число, размер вершинного покрытия.
Давайте я сейчас это и покажу.
Так, значит, смотрите, пусть у нас ФИ, это 3kNF, значит, 3kNF с m-переменными и m-скобками.
Значит, тогда мы делаем следующее.
Каждой переменной сопоставляем ребро.
Вот, а каждой скобке треугольник, ну треугольник совершенно отдельный.
От всех переменных.
Давайте я покажу на каком-нибудь примере.
Вот, а каждый скобке треугольник, ну треугольник совершенно отдельный от всех переменных.
Вот, давайте я покажу на каком-нибудь примере.
Например, P или не Q или R.
И не P или Q или S.
И, например, не Q или не R или не S.
Например, вот так вот.
Вот, значит, тогда вот этому вершины ребра, которые мы сопоставляли переменным, пометим как раз с переменной и ее отрицанием.
То есть у нас тут получается P соединено с не P.
Дальше Q соединено с не Q.
Значит, R соединено с не R.
И S соединено с не S.
Вот, а треугольники пометим прям так, как какие тут стоят литералы.
То есть каждой скобке сопоставляем треугольник, у которого вершина прям вот этим вот и помечена.
Да, то есть тут получается P, не Q и R.
Значит, треугольник вот так вот.
Так, дальше.
Тут не P, Q и S.
Так, значит, и, соответственно, не Q, не R, не S.
Так, ну и как они соединяются?
А просто одноименная, значит, одноименная вершина из левой части и справой мы соединим друг с другом.
Да, то есть получается, что P вот так вот соединено.
Значит, здесь не Q вот сюда вот.
Значит, R вот сюда вот.
Соответственно, не P вот сюда вот.
Так, ну в общем, тут сейчас немножко будет запутано.
Наверное, здесь принцип понятен.
Так, и осталось вот так вот, вот так вот, и вот так вот.
В общем, просто одноименная, значит, одноименная вершина мы соединяем друг с другом.
Ну и осталось сказать, чему равняется K.
Значит, K у нас будет равно N плюс 2M.
Где N как раз? N число переменных, M число скобок.
Так, почему N плюс 2M?
Ну вообще идея, вот какая, смотрите, вот эти вот ребра, значит, изначально добавленные для переменных,
они друг с другом не пересекаются, то есть, а их нужно покрыть.
Соответственно, нужно хотя бы один конец, хотя бы один конец из них взять.
А чтобы покрыть отдельный треугольник, нужно хотя бы две вершины из него взять.
Но как раз, поскольку N плюс 2M, N это число Робер вот здесь,
а 2M это угольное число треугольников вот здесь.
То есть, получается, что как раз, вообще, если такое покрытие есть,
то нам должно иметь вид, что из каждого ребра вот этого взята ровно одна вершина,
значит, либо левая, либо правая.
Из каждого треугольника взят ровно две вершины.
А еще есть вот эти вот серебра, которые соединяют, соответственно, одну часть и другую.
Ну и, соответственно, дальше нужно доказать, что вот их можно покрыть
только когда это будет выполняющий набор.
Так, хорошо.
Так, ну давайте обсудим, почему это будет верно.
Ну давайте выберем какой-нибудь выполняющий набор вот здесь вот.
Ну, например, значит, это вообще нужно в две стороны доказывать,
что если есть выполняющий набор, то есть покрытие вот здесь вот.
И наоборот, если есть покрытие вот здесь, то есть выполняющий набор.
Так, ну смотрите, пусть, например, там вот такой выполняющий набор возьмем.
p равно единица, q равно единица, ну а r равно нулю.
Ну а s даже не важно, ничему равно, ну пусть тоже единица.
Значит, p равно единица, q равно единица, s равно единица, а r равно нулю.
Соответственно, мы берем, да, значит, вот что равно единице, то мы и берем.
Значит, тут вершину p, тут вершину q, тут вершину ea r и тут вершину s.
Так, а дальше смотрите, вот в этих вот уже треугольниках,
идея такая, что вот наоборот, то, что мы покрыли в левой части,
в правой части, мы, по возможности, не покрываем, ну хотя бы одну из них.
То есть, например, ну вот здесь прямо вот p не покрываем,
а тут, соответственно, не q покрываем, а r покрываем.
Да, вот здесь у нас и q, и s соединено.
Ну, например, q не покрываем, покрываем вот это вот и вот это вот.
И здесь у нас, да, здесь у нас не r.
Соответственно, покрываем вот это вот и вот это вот.
Ну вот в треугольниках, ну можно вот сюда смотреть, например,
первую подчеркнутую не покрываем, а остальные покрываем.
Вот, значит, почему это работает?
Так, ну смотрите, во-первых, поскольку у нас вот из этих двух
выбрано по одной, а здесь в каждом треугольнике выбрано две,
то покрыты все ребра вот эти вот и внутри треугольников.
А также почему покрыты все ребра между треугольниками и вот этими ребрами.
Ну, смотрите, вот у нас, например, вот здесь вот есть у нас три вершины,
из каждой из них идет ребро.
Соответственно, там где мы покрыли, вот здесь мы покрыли и вот эти вот ребра тоже.
А вот это вот у нас здесь не покрыто, но у нас оно соединяется с покрытым,
мы специально так делали, чтобы не покрыто с slightly покрытым,
поэтому вот это вот ребро покрыто за счет левой части.
Ну и так же у остальных, то есть вот это ребро покрыто за счет левой части,
вот эти два за счет правой, а есть даже за счет обеих.
Да, и здесь тоже вот это покрыто за счет левой части, а вот это и вот это за счет правой
части. Ну вот, поэтому, если это действительно выполняющий набор, то можно
устроить вот такое вот покрытие. Так, ну ничего, понятно. Значит, еще раз, это пока в одну сторону,
что если есть выполняющий набор, тогда есть покрытие. Значит, у нас нужно покрыть n
плюс 2m вершин. n вершин получается за счет левой части, где мы в каждом из n рёбер
покрываем либо левые, либо правые, в зависимости от того, чему равна перемена
в выполняющем наборе. То есть, если перемена равна 1, то мы покрываем левую вершину,
если она равна 0, то мы покрываем правую вершину. Вот, а 2m, это получается по две вершины на
каждый треугольник. И дальше, смотрите, поскольку есть, поскольку набор выполняющий, то здесь в каждой
скобке есть истинный литерал. А вершина, которая соответствует этому истинному литералу,
соединена с покрытой вершиной из левой части. Поэтому вот это вот ребро уже покрыто. И покрывая,
да, значит, беря в покрытие две другие вершины, мы, во-первых, покрываем все ребра треугольника,
во-вторых, покрываем те ребра, которые идут, соответственно, из этих оставшихся вершин
в левой части. И так с каждым треугольником. То есть в каждом треугольнике одно ребро покрыто
за счет левой части, а два других за счет того, что мы выбираем оставшиеся вершины в этом треугольнике.
Вот, вот такое вот рассуждение. Это в одну сторону, еще нужно в другую, что если есть покрытие,
то есть и выполняющий набор. Значит, это рассуждение так делается. Смотрите, во-первых,
у нас должно быть в каждом из этих ребра хотя бы одна вершина покрыта, и соответственно, то есть
больше либо равно один вот в этих n штуках, и в каждом треугольнике больше либо равно двух тоже в m
штуках. То есть вообще любое покрытие обязан иметь размер больше либо равно, чем вот столько. Но если
равно, а мы суммировали неравенство, значит во всех неравенствах равенство. То есть в каждом из этих
покрыта ровно одна вершина, в каждом треугольнике покрыта ровно две вершины. Ну а тогда получается,
что раз здесь ровно одна покрыта, то этому соответственно какой-то набор. Ну, пока еще не
выполняющий, а просто какой-то, да, что если левая вершина взята, тогда перимена равна единице,
если правая, то она равна нулю. Но дальше нужно доказать, что он выполняющий. Почему? Ну, потому что,
в каждом треугольнике покрыто две, значит, третья не покрыта. Значит, соответственно,
ребро, который из нее выходит, покрыто в левой части. Но раз покрыто, значит,
этот литерал истинный, а значит, соответственно, вот эта вот скобка получается тоже истинной.
Итак, мы получаем, что действительно в каждом треугольнике, в каждом треугольнике непокрытая
вершина соответствует истинному литералу в скобке. Значит, все скобки истинны, значит,
это действительно выполняющий набор. Вот, значит, ну, опять же, тут самое главное,
это не технические детали, а сам принцип, что нужно обязательно в две стороны доказывать,
что если был набор выполняющий, то в графе есть покрытие, и наоборот, если в графе есть покрытие,
то можно построить выполняющий набор. Так, хорошо, киньте вопросы. Так, ну ладно,
давайте двинемся дальше. Так, а три раскраска была на семинарах у кого-нибудь? Нет, ни у кого не было.
Три раскраски была, а Гамильтонов путь? А Гамильтонов и Цикл, да, и неориентированные тоже.
Так, сейчас, а все-таки три раскраска много где было? Много у кого? Видимо, не очень много, да. Хорошо,
тогда давайте Гамильтонов и Цикл оставим в любом случае для семинаров. Так, а три раскраску давайте я
расскажу, да, потому что это то, с чего мы начинали. Так. Значит, три раскраска. Значит, да, электрикол, но,
графов G, что, соответственно, вершины G можно правильно раскрасить три цвета.
Три цвета. Значит, тут у этих цветов будет некоторый смысл. Да, значит, именно эти цвета будут истинным,
ложным и вспомогательным. Ну, и так, давайте я прям сразу начну показывать, как это выглядит, граф. Во-первых,
у него есть первая часть, которая называется палитра. Значит, палитра и, ну, вообще ясно, что если у нас есть какая-то раскраска в три цвета, то их, на самом деле, минимум шесть, потому что можно поменять местами цвета, да, перекрасить, и любая перестановка цветов задаст другую раскраску, которая тоже будет правильной. Вот. А с другой стороны, если у нас есть треугольник, то он обязан быть покрашен
в три разных цвета. Вот. Поэтому мы просто зафиксируем, да, значит, зафиксируем три вершины и скажем, что вот эта вот вершина истинная, эта ложная, эта вспомогательная. Да, просто будем называть, значит, будем назвать тот цвет, который покрашен вот этой вершиной истинным,
в которой вот это ложным, а в которой вот это всплогательным.
После этого уже так нельзя спокойно все менять, уже
что-то зафиксировано.
Дальше для каждой переменной я снова буду заводить как
бы вот такое вот ребро, да, ну и можно сказать, что
там есть П и не П.
Вот, и смотрите, это получается еще один треугольник,
у которого вот одна вершина точно всплогательная.
Соответственно, тут остается два варианта, либо истинная
ложь, либо ложь истина.
Ну и, соответственно, истинная ложь будет как бы соответственно
тому, что П истина, а ложь истина тому, что П ложная.
Так, значит, соответственно, здесь будет Q и не Q, здесь
будет R и не R, ну и тут, соответственно, S и не S.
Вот, вот как бы такой веер.
Значит, палитра, палитра, потом веер.
Так, а вот дальше нужны специальные гаджеты.
Так, давайте, наверное, сейчас перерыв сделаем, да, там
звонок, извините, звонок, а потом я расскажу, что
дальше делать, что дальше, дальше нужно как-то скобки
моделировать.
Значит, смотрите, нам нужно придумать какой-то гаджет,
который будет соответствовать дизюнкту.
Да, значит, смотрите, прям напрямую, прям вычисляя дизюнкцию
не получится, но можно сделать как-то такой гаджет, который
раскрашивается, если, соответственно, дизюнкция верна.
Так, давайте я вот здесь оставлю место, да, значит,
я здесь отдельно нарисую гаджет сначала для двух.
Значит, для двух он выглядит вот так вот.
Так, давайте я его в двух экземплярах нарисую, чтобы
показать два варианта раскраски.
Ну, значит, смотрите, если тут ложный цвет и тут ложный
то, вот раз смотрите, что получается.
Ну, вот этот, непонятно, какой, либо истинный, либо
вспомогательный, но если вот этот истинный то этот
обязательно вспомогательный и наоборот.
Ну а тогда этот, опять же, соединен и с истинным
и вспомогательным то есть стser обязательно ложный.
Да, получается, что если тут две ложные вершины то
вот это тоже получается ложное и, в этом смысле,
это дизюнкция.
соответственно если тут две истинные, то все симметрично, значит если тут две истинные, тут тоже будет истина.
А вот если будет истинная ложь, тогда тут вообще-то есть несколько вариантов раскраски, но нам важно, что вот есть такой, чтобы здесь была истина.
то есть здесь вмогательность, здесь ложь.
Ой, не, наоборот.
Тут уже никак угодно.
Наоборот, здесь вмогательность, здесь ложь.
Вот.
Соответственно, можно так раскрасить,
можно так раскрасить, чтобы здесь была истина.
Вот.
Ну и вот в этом смысле этого члена дизюнкция,
то есть вот в правой вершине
может быть истина,
тогда и только тогда,
когда среди исходных
есть хотя бы одна истина.
Вот.
Но дальше можно соединить два таких гаджета
и получить то же самое для трёх.
Для трёх
получается вот такая вот
красивая штука.
Вот.
Ну тут видно, что
в общем,
это так красивно рисовано в виде квадратика.
А так-то видно, что тут две
таких же штуки, значит одна вот такая вот,
а дальше выход вот этого
будет входом к другой такой же штуке.
Ну и раз это как дизюнкция,
то дизюнкция одного
и дизюнкция двух
это дизюнкция два.
Одного и дизюнкция двух,
это дизюнкция трёх получается.
Вот.
Ну и дальше, значит такие гаджеты,
значит такие гаджеты подсоединяются
к соответствующим
вершинам вот весь.
Да, я это в самом начале не сказал,
например, меня спрашивали, да,
мы тут строим свадимость
из выполнимости 3KNF
к три раскрашиваемости.
То есть у нас тоже изначально
есть переменные,
есть скобки, значит
для всех переменных мы нарисовали
вот такую штуку.
Так, ну и для одной скобки
я нарисую, значит P,
P не Q и R.
Да, то есть вот есть P,
есть не Q.
Да, значит я соединяю
вот так вот.
И ещё R.
Да, значит соответственно
получается
вот так вот.
Да, и вот так вот.
Так, ну тут я не такой красивый
нарисовал,
не такой красивый гаджет,
но, в общем, важна нам
вот эта вот, значит
эта вот вершина нам важна
и нам нужно, чтобы она была
истинна.
А как этого добиться?
Ну во-первых, можно считать, что это
просто, вот для всех гаджетов
это одна и та же вершина
и она же вот эта вершина.
А мы её просто так
нарисовали,
так чтобы удобно было
смотреть. А так для всех гаджетов
одна и та же вершина вот эта вот.
Но если вам это не нравится, можно просто считать,
что она там соединена
вот сюда вот
и вот сюда вот.
И тогда тоже она обязана быть истинной.
Вот. Ну вот утверждает, что такая схема работает.
Так, значит, почему она работает?
Ну, во-первых, пусть форма выполнима.
Тогда есть выполняющий набор, ну, например, такой же, как там,
p равно едице, q равно едице, s равно едице, r равно нулю.
Ну, тогда, соответственно, p равно едице, значит, что тут истинна ложь.
Значит, q равно едице, значит, тоже истинна ложь.
r равно нулю, получается, истинна ложь.
И s равно едице, получается, истинна ложь.
Да, вот видите, здесь r равно нулю, поэтому она в ложный цвет покрашена.
Да, все остальные единицы, поэтому в истинный цвет.
Ну и дальше тут вот из этих трех есть одна истина,
поэтому можно тогда раскрасить, значит, вершина ложь истина,
смогательная ложь истина, и здесь смогательная ложь истина.
Значит, вот так мы раскрасим.
И так будет со всеми остальными.
Да, значит, для всех остальных скобок мы тоже такие раскрасим.
Значит, такие гаджеты сделаем, и они все раскрасятся.
Вот, значит, это в одну сторону.
Это в одну сторону, что если форма выполнима,
то тогда, соответственно, граф раскрашиваемый.
Вот, в другую сторону, в другую сторону, что если граф раскрашиваемый.
Ну, тогда, смотрите, тогда получается, что вот в этом веере
каждая пара должна быть раскрашена в истинные и ложные цвета в каком-то из двух порядках.
Соответственно, если истина ложь, то значит, перемена равна единице,
если ложь истина, то перемена равна нулю.
Вот, и дальше, поскольку этот гаджет раскрасился,
то получается, что из этих трех вершин хотя бы одна истинная.
Ну, а это значит, что в скобке есть истинный литерал.
Раз все гаджеты раскрасились, значит, во всех скобках есть истинный литерал,
значит, форма выполнима.
То есть, то, что получается из раскраски, это будет выполняющий набор.
Вот так вот.
Политра, чтобы потребовать, чтобы вот это вот было.
Ну, как бы вот эти вершины во всех гаджет должны быть одинаково раскрашены.
И этого можно добиться либо тем, что это одна и та же вершина из политры,
либо то, что они все соединены вот с теми двумя.
Раскраска вот этой части...
Нет, значит, смотрите, вот раскраска веера соответствовала значениям переменных.
А вот это просто, значит, если тут хотя бы одна истина есть,
тогда можно раскрасить так, что тут будет истина.
Ну, вот так вот.
Если там три ложных, то тогда нельзя раскрасить.
Так что тут была истина.
То есть, то, что вот здесь есть, гарантирует, что из вот этих трех хотя бы одна истина.
Вот.
Так, вот такое вот рассуждение.
Вот.
Так.
А вот такая задача у вас была.
На e-sat это not all equal.
Not all equal sat.
Это из логики задача.
Значит, не из графов дати я расскажу.
Значит, тут тоже дана 3kNF, но другое задание.
Значит, дана 3kNF.
Значит, вопрос.
Есть ли такой набор...
Есть ли такой набор,
что в каждой
в каждой скобке
есть и ноль,
и единица?
Да, но not all equal, значит, не все нули, не все единицы.
Вот. Ну, то есть,
можно еще сказать, что в каждой скобке
либо один литерал истин, либо два.
Но не все сразу.
Вот.
Значит, тут смотрите, понятно, что если
если вот это верно, то тогда формула выполнима,
но неверно обратная.
Значит, может быть, выполнимая формула,
в которой такой литерал,
в которой такой литерал,
в которой такой литерал,
может быть, выполнимая формула,
в которой такой штуки нет.
Вот. Ну, например...
Нет, например, можно взять просто все,
например,
скажем,
трехэлементное подмножество
из пяти переменных,
и взять все возможные дизюнкты из них.
Вот. И тогда из трех значений,
хотя,
то есть, из пяти значений будут три одинаковых,
то есть, я имею в виду, там будет
там P или Q или R,
и P или Q или S.
Дайте я, пожалуйста, что значит
P или Q или R,
P или Q или S,
P или Q или T,
и так далее,
и вплоть до последней,
последней будет R или S или T.
Значит, их там...
Десять.
Десять, видимо, штук будет.
Вот. Ну и дальше, смотрите, тут,
что вы не делаете, у вас либо
в какой-то скобке будет три единицы,
либо в какой-то скобке три нуля.
Вот. Поэтому это выполнимое,
но не наевыполнимое.
Да, то есть, вот эта вот штука
принадлежит
три сад,
но не принадлежит ная сад.
Вот. Поэтому это явно другая задача.
Вот.
Хорошо.
Тем не менее, как же к ней
сводить?
Значит, идея здесь следующая.
Значит, смотрите, пусть у нас есть
значит, какая-то
скобка, там
альфаите или бетаите
или гаммите.
И я ее превращу
в такие две скобки.
Посмотрите, альфаите
или бетаите
или
хите
и
нехите
или гаммите
или
зет.
Где хите свое
для каждой скобки, а зет
единая для всех.
Значит, хите свое
для каждой скобки
сейчас назовет ите
одно для всех.
Да, значит, я опять же
я свожу
три сад, выполнимость, вот
к такой выполнимости.
То есть, вот это вот
три сад
сводится
к
на е сад
таким вот методом.
Таким образом каждую скобку
мы модифицируем
ну и объединяем их все.
Вот, тогда идея
такая.
Значит, опять же нам нужно в две стороны
в две стороны свести.
Ну и дальше идея такая,
что на самом деле
можно взять
z равное нулю.
Значит,
мы берем просто вот
z равное нулю.
И тогда, ну, например,
если они все единицы, значит,
если они все единицы, то мы берем
вот так вот.
Да, тут один.
Вот.
Ну, тут даже не важно, какая гамма.
Да, значит, если
альфа и бета единицы, то будет вот так вот.
Если, например,
альфа равна
единице, бета равна нулю,
тогда можно в рот
икс равно взять единицы.
Да, тут будет
ноль.
В смысле, тут
будет один.
Сейчас, нет, подождите.
Если гамма будет не единица,
если гамма будет ноль,
то тогда будет вот так вот.
Если гамма будет ноль, то обязательно либо альфа, либо бета
равна единице, и поэтому
можно брать х равную нулю.
Если альфа и бета равны нулю, а гамма равна единице,
тогда берут х равную единице, а тут будет ноль.
В общем, тут такой небольшой перебор.
Да, там, в принципе, семь вариантов,
когда среди альфы, бета и гаммы
есть единица.
И для каждого из этих вариантов
можно придумать такое значение
икса,
что, соответственно, и в этой скобке будет
и ноль, и один, и вот в этой тоже и ноль, и один.
Так.
Ну, даже там,
дайте я аккуратно скажу,
что, смотрите, вот z равно нулю,
если гамма равно единице,
тогда в этой скобке уже
все нормально,
а в этой скобке
не важно, чем равны альфа и бета,
и х мы можем выбрать, даже если они одинаково,
мы х выбираем другим,
и в этой скобке тоже все нормально.
Если гамма равно нулю,
тогда среди вот этих есть единица,
и тогда мы берем икс равно нулю,
и тут будет единица и ноль, и тут будет тоже единица и ноль.
Ну вот, и так будет с каждой скобкой.
Более того, если z равно нулю,
то на самом деле верное рассуждение в обратную сторону.
Смотрите, если z равно нулю,
если гамма равно нулю,
ну точнее народ, если это равно единице
при этом,
то тогда все уже в исходной скобке единица есть,
а если гамма равно нулю,
тогда вот эта должна
быть ровно единицей,
вот эта должна быть равно нулю,
а среди этих
должна быть единица,
и тогда вот здесь тоже есть единица.
То есть получается, что если
z равно нулю,
нулю, то тогда форму, исходная форма, получается выполнена. Вот. Дальше вопрос, а что делать,
если в том наборе, где у нас есть 0 и 1, z равно 1. Да, может поменять вообще все, наоборот.
Да, что смотрите, если есть какой-то наe-набор, то тогда обращенный он тоже, тоже будет наe. Да,
то есть тут получается, что если существует наe-набор, то тогда его отрицание тоже наe,
и поэтому считать, что z равно 0. Так, коротко напишу, что z равно 0. А если z равно 0, то такой
же перебор говорит, что среди альфы, бета и гамма есть единица. Так, ну что, понятно?
Так.
Так, давайте я расскажу еще про одну важную задачу. Значит, я там как раз... Эта задача как
раз исключение, потому что там довольно легко доказать NP-трудность, да, но не очень легко
доказать принадлежности NP, и, соответственно, это доказать я пропущу, да, просто там объясню
в целом, что нужно доказывать. Вот. Но сама по себе задача очень важная. Это называется CLP.
Значит, CLP – это целочисленное линейное программирование. Ну, вообще есть просто задача
линейного программирования, не обязательно целочисленного. Это задача оптимизация линейных
функций на многогранниках. Значит, это очень важное понятие. В общем, даже Конторович за это
изобретение получил номерскую премию по экономике. Вот. И это очень много людей используется в самых
разных задачах. Я не знаю, у вас этого не было пока? Какой-нибудь SimplexMethod, там что-нибудь? Да, ну,
наверное, будет. А, вам прямо про CLP рассказывали? Ага. Ну, хорошо, да. Вот. Но, соответственно,
обычное линейное программирование хорошо, когда у вас есть какие-то ресурсы, такие делимые. Да,
то есть у вас есть, я не знаю, нефть, зерно, еще чего-нибудь в таком роде, металл какие-нибудь. Ну,
какие бывают задачи, что, например, у вас есть разные ресурсы, разные товары с линейной
технологией. То есть, чтобы получить такой-то товар, нужно столько-то нефти, столько-то зерна,
столько-то золота и так далее. Ну, что-то похоже на какую-то компьютерную игру с ресурсами. Вот. И вы,
соответственно, думаете, в какой пропорции это разделить, чтобы, например, наибольшая прибыль
была или какая-нибудь еще целевая функция. Вот. Бывает еще такая задача о диете, что, например,
вам нужно сделать сблансированное питание, в котором будет достаточное число различных питательных
веществ, витаминов и так далее, но при этом, например, чтобы корзина была бы как можно дешевле или
какое-нибудь еще другое задание. Вот. Значит, вот это вот нет-солочистственное, где можно
сколько угодно мелко делить все эти ресурсы, обычные линейные программирования. И с ним довольно
интересная ситуация, что, с одной стороны, теоретически эта задача полинамиальная. Значит,
там есть несколько методов, метод эллипсоидов, метод внутренней точки, которые теоретически
работают полинамиальное время, но также есть симплекс-метод, который теоретически работает
экспоненциальное время в худшем случае. Но на практике он как раз обгоняет вот эти вот
полинамиальные алгоритмы и на практике обычно используется. То есть, в каких-то очень редких
специально сконструированных случаях он работает очень долго, но в тех случаях,
которые возникают на практике, он работает быстро. Вот. Это довольно интересная ситуация сама по себе.
Вот. Ну вот. А вот есть CLP, значит, Солочистственное линейное программирование, где нужно найти
солочистственную точку в многограннике, на которой будет максимальное значение линейной функции. Но
можно на самом деле формулировать так. Да, потому что вообще как мы переводим задачи оптимизации
в задачи NP, например, мы не ищем максимальную клику. Мы спрашиваем, есть ли клик размера больше
либо равно, чем k. Да, потому что если есть размеры k, то есть, ну, точнее, если есть размеры больше k,
то есть и размеры k. Вот. Поэтому можно спрашивать, есть ли клик размера больше либо равно, чем k. Вот.
Но также из оптимизации, вместо того, чтобы спросить, сколько линей больше значения, можно
спрашивать, есть ли солочистственная точка, у которой значение больше либо равно, чем столько,
и тогда получается просто система неравенств. Да, да, да. Многогранник выпуклый. Ну, это просто
система линейных неравенств. Да, то есть, можно сформулировать так. Значит, есть ли, есть ли
солочистственная точка, есть ли солочистственная точка, удовлетворяющая данной системе, данной
системе линейных неравенств. Вот. Но и анпотрудность тут делается достаточно легко. Значит,
анпотрудность говорит следующее, что вот пусть у нас, ну так, я уже стер, давайте я снова напишу
формулу. Да, опять же, 3kNF. 3kNF сводим в вот какая-то задача. П или N, К или R. Не П или Н, Р или С.
И тут какой-нибудь не К, или Р, или не С. Вот. И тогда можно написать такую систему неравенств.
Да, мне нужно написать, что ноль меньше либо равно П, меньше либо равно единица. И это
либо ноль, либо единица. Да, точно также с Q, R и S мы напишем. Вот. А также мы напишем, например,
что P плюс 1 минус Q плюс R должно быть больше либо равно единица. Да, потому что вот 1 минус Q
это то же самое, что отрицание на нулях и единицах. И, соответственно, есть такая штука, больше либо равно единица.
Это означает, что из этого, этого и этого есть хотя бы одна единица. Ну и также для остального. Да, там 1
минус П, 1 минус П плюс 1 минус R плюс S больше либо равно единица. И там, соответственно, 1 минус Q
плюс R и плюс 1 минус S больше либо равно единица. Вот. Соответственно, фактически я просто переписываю
то, что вот эта дезюнкция верна просто в терминах вот таких вот линейных неравенств. Вот. Ну это более
или менее очевидно, что если здесь есть выполняющий набор, то просто ровно мы возьмем те же самые значения
нуля и единицы, и все эти неравенства будут выполнены. Ну и наоборот, если вот это все выполнено,
то мы возьмем вот эти самые значения как логически, и вот эти неравенства означают,
что дезюнкция выполнена. Нет, а это у нас такой вопрос ставится. У нас вообще вопрос
ставится, есть лицо-численное решение, вот такая система. Ну да-да-да. Вот. Соответственно,
получается, что вот сводимость получилась, что решение есть, да, если выполняющий набор,
тогда и только тогда, когда тут есть решение. Вот. Но загвоздка с тем, почему это, значит,
почему принадлежит НПА. Вот. Вот тут мне нужно отдельно техническое рассуждение, я его приводить
не буду, но лемма тут такая, значит, лемма такая, что если вообще есть хоть какое-то
целочисленное решение, значит, если есть целочисленное решение, то есть не слишком большое,
да, то есть и решение с экспедиционными значениями, с экспедиционными значениями,
но раз это экспедиционные значения, то они требуют полиномерничество битов. Значит,
то есть занимающими, значит, то есть занимающими полиномерное число битов.
Не-не-не, смотрите, принадлежит НПА или это уже не про эту систему, а вообще про любую систему. Да,
да-да. Да, вообще в любой системе CLP, почему вообще, значит, CLP лежит в НП? Значит, потому что,
ну, хочется сказать просто потому, что если есть решение, то мы проверим, что оно решение. Да,
посчитаем и проверим. Но чтобы это можно было посчитать и проверить, нужно, чтобы там значения
были не слишком большими. Вот, и вот лемма как раз говорит, что это есть. Ну, то есть экспедиционнее
от чего? Ну, у нас есть параметры, это там число переменных, число уравнений, и третье параметры,
на самом деле, число битов, которые использованы для записи коэффициентов. Да, то есть, ну, у нас
линейное неравенство, да, это констант умножить на переменную, плюс другая константа на другую
переменную, плюс и так далее. Больше всего, но там какой-то еще константа. Вот, соответственно,
вот эти все константы, они сколько-то битов требуют для своей записи. Ну, и вот получается
экспедиционное число от этого, ну, от всего вот этого, ну, от какого-нибудь там максимального
размера из этих констант. Вот, ну, вот это нужно отдельно доказывать. Там разного рода технические
рассуждения есть, почему это верно. Не-не-не, само значение экспедиционное, а число битов
полинамиальное. Да, всегда длина записи это логарифм от самого значения. Так, хорошо,
ну, у меня 5 минут остается. Я, наверное, чуть-чуть скажу про задачу поиска.
Значит, задача поиска. Значит, на примере Кликия.
Значит, пусть у нас есть граф и число, и мы хотим не просто узнать, есть ли Клика такого размера,
а прямо-таки ее найти, то как это можно сделать? Ну, вот на самом деле, если есть любой черный ящик,
который позволяет проверять, есть ли Клика, то можно на основе этого черного ящика составить
процедуру, которая будет искать эту Клику. Значит, каким образом? Ну, смотрите, пусть у нас есть какая-то,
берем какую-то вершину в графе, и ее просто выкидываем. Выкидываем вершину и все ребра, которые в нее вели.
И дайте спрашиваю, вот если эту вершину выкидать, то останется Клика искать вершину?
Значит, тут же без вершины и размера К. Спрашиваем, выкидываем вершину и спрашиваем, есть ли в этом новом, уменьшенном графе Клика искать вершину.
Если есть, то есть у нее точно так же рекурсивно. А если нет? Ну, а как это вообще выглядит? Вот есть какой-то там граф,
значит, это граф G, вот есть вершина В. Значит, если, соответственно, если нет Клики без этой вершины,
значит, любая Клика эту вершину содержит. Но дальше это означает, что в любой Клике, то есть вершины,
которые не соединены с этой В, точно в Клике не лежит. То есть после этого можно оставить только ту часть, которая соединена.
И искать только, вот N это слово neighbor, значит, искать только среди соседей. Вот, соответственно,
тут получается N от V и K минус 1. Ну вот, получается, что у нас есть, ну, с самого начала можно сказать так,
что мы спрашиваем, есть ли вообще в графе Клика искать вершину. Если ее нету, то мы искать не будем, скажем, что ее нету.
Если она есть, то мы ее будем постепенно искать. Рекурсивно. Дальше вот здесь и здесь рекурсивно продолжается то же самое.
Спрашиваем, вот если мы вершину В удалим, то она еще останется. Если останется, то и забудем про эту вершину В, будем дальше искать.
То есть дальше какую-нибудь следующую будем удалять. Если нет, не осталось, то тогда мы, наоборот, удалим.
Ну, мы удалим, да, то есть тут имеется в виду вот так вот, что мы и В удалим, и всех ее соседей тоже удалим.
И, наоборот, всех ее не соседей тоже удалим. Оставим только соседей, и среди них будем искать вершину Клика размера K минус 1.
То есть когда мы найдем, то мы к ней еще добавим В и получим клику размера K.
Вот. Ну, вот такая рекурсия закончится, потому что у нас каждый раз вершин становятся меньше в графе.
Соответственно, число шагов тут будет не больше, чем число вершин в графе.
Вот. Ну, если, да, значит, если клика есть, то мы ее найдем.
Вот. Ну, и получается, что вообще то, что вот здесь вот я изложил, называется свадимость по Куку.
Да, то есть мы несколько раз используем проверку, есть ли Клика как черный ящик.
Ну, тут уж неважно, может быть, P равно NP, поэтому можем полимерально запускать.
Да, значит, может быть, это просто какой-то оракул.
Вот. Главное, главный вывод такой, что задача поиска, по крайней мере для задачи о Клике,
не более сложна, чем задача распознавания есть и Клика.
Ну, и на самом деле такой же эффект будет для всех NP-полных задач.
Значит, я думаю про это, может быть, на семинарах разговора тоже будет.
Так. Ну, все. Спасибо за внимание.
