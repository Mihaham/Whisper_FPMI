Сегодня мы поговорим про концепты. У нас последние
разы были посвящены всяким type trait'ам. Как вы помните,
мы там обсудили реализации всякие упоротые. Из констрактебл,
из бейзов, поговорили про enable live, как им пользоваться. Но с приходом C++20
большинство из этого устарело на самом деле. То, о чем я сейчас буду рассказывать,
вы наверняка слышали про это, может вы сами где-то читали. Много сейчас, каждый месяц там,
понятно, люди пишут, появляются все новые и новые статьи. Это новая такая хайповая тема,
примерно как когда Move Semantic появилась в 2011 году, там тоже все постепенно уезжали. Но вот в 2020
году в стандарт внесли эту штуку, и с тех пор люди постепенно начинают ее осваивать, к ней привыкать.
Сразу скажу, что еще мало кто умеет этим пользоваться, ну в том числе и я. То есть,
ну я вам сейчас что-то расскажу, ну я вам расскажу так, ну, на плюс-минус базовом уровне,
что вот есть такие-то языковые возможности, вот и не так-то можно пользоваться. Но понятно,
что наверняка еще там в ближайшие месяцы люди откроют кучу новых способов, как это можно
использовать, найдут баги, в C++ 23-м что-нибудь переиздадут. Ну то есть, короче говоря,
это такая достаточно свежая прям вот новиночка стандарта уже, несмотря на то, что два года вроде
как прошло, но люди, сообщество довольно медленно осваивает новые фичи стандарта. Компиляторы еще
год назад не целиком умели это поддерживать, сейчас вроде плюс-минус поддерживают, но я, кстати,
до сих пор не уверен, что все, что я сегодня буду писать у меня скомпилируется. Ну должно,
но я не до конца уверен, что компиляторы вообще все умеют поддерживать, что там требуется от них.
Вот, ну а где это сейчас используется? Ну там какие-нибудь флагманы IT-индустрии типа Яндекса там,
наверное, ну не наверное, а точно уже используют, но далеко не все все равно умеют, даже в рамках
этих компаний. Постепенно люди осваивают, кто-то быстрее, кто-то медленнее, постепенно переходят
на C++20, во многих местах еще C++17, например, в Яндекс.Контесте еще только C++17, ну и так далее.
Ну короче, это новая свежая штука, вот, не судите строго, если я что-то не знаю, еще мало кто хорошо
в этом разбирается, ну и, соответственно, когда мы вас будем что-нибудь на экзамене про это спрашивать,
то тоже это будет очень лояльно, потому что, ну, вглубь пока мало кто умеет. Вот, будем так основные
возможности рассматривать. Ну так вот, концепты и констрейнты. Ну, сначала мы начнем с констрейнтов.
Ну давайте, наверное, файл назову Concepts. Ой-ой-ой, извините, это у меня уже тут что-то лишнее, его я удалю.
Так, дайте-ка я выведу список участников еще.
Значит, у нас какая была история? Мы пользовались раньше Enable и Form, чтобы сделать перегрузку по
принципу того, является ли тип, удовлетворяет ли тип какому-то свойству или нет. Вот, ну простейший
пример, это мы хотим написать функцию, которая по-разному будет работать в зависимости от того,
объект является объектом класса или нет. Ну вот, например, у меня есть std string s, и я вызываю f
от s, а есть просто int x, и я вызываю f от x. Вот я хочу опять написать функцию, это мы уже с вами делали,
но мы это делали старомодно. Сейчас я покажу новый, новомодный способ. Значит, написать функцию,
которая в зависимости от того, является ли тип классовым, хайповый способ, да, делает либо одно,
либо другое. Вот, ну способ с помощью Enable.if вы помните, я думаю, там еще была вот эта проблема,
когда мы неправильно используем Enable.if, что функции различаются только дефолтным шаблонным
параметром, это все неудобно для использования, но вот сейчас будет удобный для использования способ.
Ах да, это пункт 15.157, чтобы поддерживать нумерацию. Какой у нас был последний пункт?
Common Type был 15.6, да, значит это будет пункт 15.7 нашей программы, ну соответственно 15.8 будет
Conceptor. Ну давайте я назову Requires keyword. Значит, ключевое слово Requires, появилось оно начиная с
C++20. Что я могу написать, начиная с C++20? Я пишу template type name t, а вот дальше я пишу ограничение
на t, то есть я не пишу вот этот вот стрёмный Enable.if, бла-бла-бла-бла, фиг пойми что, а я пишу
Requires, и это новое ключевое слово, начиная с C++20, Requires и некоторое буллевское выражение,
но здесь не любое буллевское выражение можно написать, я потом уточню какое, но я могу написать,
например, std из класс v от t void f от const t ampersand, ну без const t ampersand, просто tx, и тут я выведу std
out 1. Вот, а теперь я это всё скопирую, ой, что я не то сделал, и уберу здесь Requires, и тут выведу 2.
Нет, не уберу Requires, оставлю Requires, просто сделаю отрицание его.
Requires не std из класс v от t. Вот, ну тут, правда, скобочки надо поставить, потому что отрицание
он иначе не распарсят. Вот, ну и давайте попробуем это затестить, как это работает, значит утверждается,
что вот это слово Requires, оно a c++20 concept cpp, и кажется он справился, да, 1.2, ура, это даже
g++10 справился, я приятно удивлён, я надеял, я думал, что мне 11 придётся использовать, но даже 10
справился. Странный вопрос. Да. Как работает обратная совместимость в случае, когда в язык
добавлено ключевое слово? Вдруг у меня переменная называлась Requires? Ну... Сорян, я не знаю, ну,
я не думал об этом. Ну, наверное, плохо, да. Вот. Окей. Да, ну, во-первых, я здесь должен ставить скобочки,
во-вторых, ну, я вот тут отступ поставил, ну так, вроде как люди обычно так пишут, а в-третьих,
а что в-третьих, да, про скобочки всё-таки хочу ещё отдельно сказать. Вот, когда я написал
Requires, после этого должно идти буллевское выражение, но с оговорочками, там может быть либо, вот если
я хочу написать произвольное буллевское выражение, то мне скобочки надо ставить, а если без скобочек,
то там есть список, что можно писать, и вот, в частности, вот именованные константы шаблонные
можно писать без скобочек. Вот. Хорошо, вот вопрос. Если я уберу вот это вот, то есть я такое взял и
в одном случае сделал Requires, в другом не сделал, что получится? А так вообще можно, в смысле,
если бы у нас и сверху не было Requires, то у нас вообще была бы одинаковая функция? Да, если бы у нас
не было Requires ни там ни там, то это было бы redefinition. Но вот утверждается, что чудесным образом в случае с
Requires так можно. Давайте я это проверю, и это всё ещё работает. Вот, значит компилятор, вот в чём у нас
была проблема с enable и form. У нас там были вот эти вот, ну, по сути, что там было? Там вот был вот
этот template typeNameT, typeName, равно, короче, у нас функции отличались тем, какой там дефолтный
шаблонный параметр, и это там работало плохо, потому что компилятор, в общем, он вычисляет,
подставляет там шаблонные параметры слишком поздно, позже, чем он решает, какая сигнатура ему больше
подходит, ну что-то такое. Ну вот, в случае с Requires, они решили все эти костыли похоронить и сказать,
что Requires вычисляется прямо раньше всего, ну, то есть, вот это ключевое слово Requires и проверка
того, что constraint выполнено, вот это называется constraints, то, что я сейчас написал, ограничение.
Она делается, ну, на очень раннем этапе, то есть, она делается до выбора перегрузки, ну, то есть,
я не могу вам точно сказать там, в какой последовательности, что делается, ну, в общем,
вычисление оценка Requires и какой из них более подходит делается очень рано. И существует
следующее правило, что если в одной функции Requires присутствует, а в другой отсутствует,
то первая предпочтительней, ну, при условии, что Requires подходит. И вот это на очень раннем
этапе комплятором оценивается, то есть, это там до, ну, грубо говоря, до всего того, что мы знали
раньше, наверное, даже, вот до того, как он начнет шаблоны там какие-то вычислять и так далее.
Вот такой вопрос. Да. Там под Requires стоит буллевское выражение, а можно ли под Requires поставить
буллевское выражение, которое с некоторыми кt тупо не скомпилиться? Отличный вопрос. Сейчас
мы как раз про это тоже поговорим. Ну, можно. Они и это предусмотрели. Значит, так, окей, мы два
примера пока разобрали простеньких, значит, мы поняли, что если у нас есть два разных Requires,
один подходит, другой не подходит, мы попадаем в тот, который подходит. Можно еще? Да. Скорее уже на
месте. Если убрать вторую перегрузку, верно ли, что оно со стринг скомпилируется все равно,
а со синтом просто не скомпилируется? Да, синтом не скомпилируется. Ну, давайте проверим.
Очень интересно, что он именно расскажет. А, кстати, да. Давайте тогда начнем с этого
примера. Вот что, если я просто оставлю одно требование и вызовусь от int? Еще одно важное
преимущество, это преподносилось разработчиками компилятора, разработчиками стандарта, как чуть
ли ни одна из важнейших причин переходить на вот это все дело, потому что ошибки компиляции
становятся гораздо более читаемыми. Вот. Ну, силенго, вероятно, они еще более читаемые. Значит,
раньше, когда у вас что-то не подставлялось в шаблон, то там был огромный какой-то просто поток
сознания компилятора, который что-то пытался подставить, в него невозможно читать совершенно.
С requires, одно из требований, как скажем, один из кпи, что ли, у них, короче, одна из целей,
которые они преследовали, это чтобы можно было легко диагностику читать. Вот, если у вас не
подходят невыполненные ограничения, то вам просто пишут, template sufficient failed, constraints not
satisfied, и вам говорят, какой именно, constraint не выполнен с каким типом. Очень удобно.
Прямо написано, что вот этот constraint оказался false. Вот, можно силенг из интереса, ну, кстати,
можно из интереса g++10, g++10 тоже справился. Можно силенг спросить, что он скажет. Ну, то
же самое, в принципе. Ну, то есть, и тот, и другой компилятор умеет нормальную диагностику выдавать,
если constraint not satisfied. Вот. Вот. Дальше. Что будет, если я здесь напишу
какое-нибудь, что-нибудь такое, что для некоторых t оно просто некорректно. Ну, например, вот,
вот value type. В t же есть value type, да? Ну, вот давайте я потребую вот такую вещь, чтобы было не классом
value type внутри t. Ну, внутри стринга это правда. Там value type, он char, наверное, он не класс. То есть,
для стринга это требование выполнено. Но для int это просто некомпилируемое требование. Вот,
что произойдет? Сейчас, это не работает, потому что я забыл type name. Ну, тут type name действительно
нужно, потому что никак не понятно, это число или тип. Вот, это компилируется и работает. Ну,
и с силенгом тоже самое. То есть, смотрите, какая магия. Это не просто вычисляет верно ли вот это
булевское выражение. То есть, вот, помните, какая проблема была с noexcept? Мы там не могли просто
написать тупо, что это конъюнкция, что isMoveConstructable и noexcept от blah blah blah. Мы так не могли написать,
потому что обычная конъюнкция, она хоть и не вычисляется целиком, но компилируется, пытается
целиком. И приводит к CE, если там что-то некорректное с точки зрения компиляции.
А сейчас есть вероятность, что меня выкинут из зума. Какой-то аккаунт зашел вместо меня. Ну,
что за дела? Ну да ладно. Будем надеяться, что нет. Вот, а requires умнее. Он работает не так. Он даже
если у него некомпилируемые выражения, он просто считает, что это false. То есть, они и это предусмотрели.
Вот, но при этом, если у вас, скажем, вот такая ситуация, давайте я, например, так напишу,
что у меня есть вот такой requires и вот такой requires. Что сейчас будет? То есть constraints,
внутри себя свиное содержит своего рода. Ну, в каком смысле содержит? Ну, по сути, да. То есть,
если неудачная постановка в requires, то это не CE. То есть, он умный. Логично, что они это предусмотрели,
потому что раньше это было болью, теперь перестало быть таковой. Вот, теперь смотрите,
что я написал. Я написал вот здесь requires true, то есть любое требование подходит, а здесь какое-то
более строгое. Вот, но, к сожалению, нет, так не работает. Компилятор определит какое из них
предпочтительнее. Да, вот здесь уже не получится, потому что, когда у вас в одном есть requires в другом
нет, то тут понятно. Просто по правилам такой, если там есть requires, там нет, значит, это
предпочтительно. А когда у вас и там, и там есть, то тут уже так не скажешь. Поэтому это амбигиус.
Если оба подходят. Да, вот такой вопрос. Я хочу сделать три перегрузки. Одна из которых вот та
верхняя. Вторая про то, что у Т вообще есть value type. И третья, ну, типа, общий случай.
Я думаю, что здесь как раз понадобятся концепты. Вот, с помощью чистой requires вот я сейчас сходу не
могу сказать как. Вот сейчас мы до концептов дойдем, и тогда это будет реализуемо. Так,
пока про requires я закончу. Значит, вот это один синтаксис. Есть и другой синтаксис. Значит,
requires можно писать и после сигнатуры. То есть, я могу написать вот так. Нет, не так, а вот так как
раз. Блин. Короче говоря, вот так я могу сделать. После того, как я написал сигнатуры, я могу написать
requires. Это два разных синтаксис. Ну, не знаю, один ничуть не лучше другого. В принципе, зачем так
сделали, не знаю. Ну, вот так сделали. Можно писать и до, и после. Ну, хорошо. Это было то,
что называется requires clause. То есть, ну, такой спецификатор requires. Вот, а есть еще requires
оператор. Это вам должно что-то напоминать. Что это вам напоминает? New. Нет. Ну, у нас уже была такая
ситуация. У нас было нечто спецификатором и оператором одновременно. Это был noexcept.
Вот requires он тоже бывает спецификатором и оператором. Значит, что такое requires оператор?
Это такая конструкция, которая эволуетится в true или false в зависимости от того, корректно ли
с точки зрения compile-time выражение, которое вы под ней напишете. Смотрите, как прикольно. Я
могу написать. Вот, например, я хочу понять. Ну, давайте у меня будет какая-нибудь шаблонная функция
g. Я сейчас рассказываю, что у нас есть, помимо requires clause, еще requires оператор. Вот это было
requires clause. Подобно тому, как с noexcept было, у нас есть noexcept спецификатор и оператор. Также
requires. Сейчас я продемонстрирую вам requires оператор. Вот, я сейчас вам выведу, правда ли,
что у t есть value type? requires от t x, а тут я напишу t 2.2.value type не знаю, что-нибудь.
Игрок. g от s. Сейчас, я надеюсь, нормально, например, сработает. g от s и g от x. Давайте проверим,
что? Что-то у меня там. Type name. Фигурной скобочки нету здесь. А, возможно, кстати,
type name нету. Это правда. Вот здесь type name нужно. Так. Сейчас.
Noexcept оператор работал абсолютно по-другому. Да, это правда. Сейчас я, возможно, я не совсем
правильно, ну, невозможно, а точно я не совсем правильно это использую. Сейчас я постараюсь это
правильно заиспользовать. Где же?
Да, я просто пишу type name и ничего не объявляю. Вот так. Довольно странно. Вот так должно
работать. Да, вот так работает. О, смотрите, как прикольно. Так, что я сейчас написал? Вот у меня
шаблонная функция. Вот это вот, то, что после cout, это буллевское выражение. Это expression,
requires expression. Ну, я не уверен, кстати, можно requires назвать оператором, возможно, я вас
немножечко обманул, и формально это не оператор. Но вот это вместе называется requires expression. Как
он устроен? Он имеет следующий синтакс. Если вы пишете requires в месте, где ожидается expression,
дальше в круглых скобочках как будто бы аргументы принимаете. Но здесь x я не использовал,
поэтому я могу, наверное, от него избавиться. Логично, что я могу не передавать имя. А дальше
открываете фигурную скобку, и в фигурной скобке вы пишете некоторую последовательность. Я бы даже
не сказал бы, что инструкции, потому что вот это не инструкция. Вы пишете просто некоторую
последовательность некоторых requirements. Я не знаю, как это. Это нельзя давать стейтнентами,
потому что вот это, например, не стейтнент. Но вы можете писать нам обычные expression. Вы можете
писать вот такие штуки. Мы сейчас через некоторое время откроем cpp-reference вместе и посмотрим
список того, что писать можно. А разве объявление переменной это не expression? Но я сейчас не объявил
переменную. Нет, я знаю, вы пытались, и у вас не получилось. Где? Нет, да, ну вот я пытался
сделать declaration. Вот declaration значит нельзя было. Но там довольно странный список того,
что можно. Не знаю, почему declaration нельзя. Я не выучил наизусть этот список, как видите. Но вот
чтобы проверить, что тип присутствует, вот так можно написать. Я могу проверить, что какая-то
операция присутствует. Ну то есть, как я могу сделать? Сначала я решил проверить, что у меня,
например, value type присутствует. Я еще могу проверить, что какая-нибудь операция присутствует,
x.size, например. Вот, еще я могу проверить, например, что складывать можно x плюс y. Ну то есть,
я пишу некоторые экспрешены, и компилятор смотрит на них и оценивает, они вообще компилируем
или нет. И если да, все они компилируем, то возвращает true. Вот. А вот в обычном requires,
как можно проверить, допустим, что можно складывать такие типы? Вот. Ну так же,
как с no accept. Вот у меня же после requires идет булевское выражение. Но requires это и есть
булевское выражение. Вот после requires clause должно идти булевское выражение. Значит, я могу после
этого requires написать еще requires. Ну давайте так и сделаю. Например, я напишу requires, что эти
типы складывать можно. Вот напишу вот не так. Давайте-ка я вот что сделаю. Вот я сейчас потребую от
типа t, чтобы можно было складывать, вычитать, умножать, ну, складывать, вычитать просто. Я пишу
requires и еще раз requires, потому что это начинается requires expression. Здесь говорю tx ty, фигурная
скобочка открывается, x плюс y, x минус y. Фигурная скобочка закрывается и точка запятой мне не нужна,
кажется, потому что я был... потому что... потому что потому. Вот, значит, и давайте проверим,
что сейчас будет. Так, вот здесь мне выведется 1 в случае строки, 0 в случае inta, потому что
value type у него нет. А здесь что будет? Когда я вызываюсь от s, выводится 1, потому что этот
requires не выполнен, строки вычитать нельзя. Когда я вызываюсь от inta, выведется 2. Давайте проверим,
что все работает. Все работает. Вот, я после requires написал... я могу после requires написать
произвольное... ну, вообще, я могу произвольное булевское выражение в скобочках написать,
но могу написать и некоторую вот... ну, могу написать без скобочек либо булевскую константу,
такую, например, из класс V или из base of V, не знаю, либо requires expression, который сам
его лейтится в bool в compile time, в зависимости от того, правда ли что. Вот. Вот. Можно вопрос? Да,
конечно. Можно написать requires внутри тела функции. Ну да. И если не выполнено выражение, то функция...
комплятор переходит к другому определению функции. Нет. Нет, подождите. Если я... у меня есть requires
clause, она вычисляется очень рано, в момент... еще до выбора версии перегрузки. Если он понимает,
что requires clause... по вот этим требованиям он не удовлетворяет, то он пойдет искать другую
версию функции. А вот это я показал. Это просто я показал, что бывает requires expression. Вот это вот
requires expression. Я могу вычислять его... ну, это так как sizeof или как noexcept. Я могу брать requires
от каких-то типов и дальше в фигурных скобочках что-то написать. И это все в compile time оценится в
true или false, в зависимости от того, какие типы были. Но он равносилен тому, что мы писали раньше.
Что значит равносилен? Ну, можно все то же самое взять и ctrl-x, ctrl-v в сигнализацию функции. Ну,
это будут разные совершенно вещи. Здесь я просто попросил его вывести 1 или 0. А там бы я попросил
его либо идти в эту функцию, либо нет, в зависимости от выполнения требований.
А, понятно, окей.
Это я просто попросил его сказать, мне выполнили требования здесь и вывести ответ. Вот, ну, я могу
использовать это, например, как? Ну, я могу написать с другой стороны, что я могу сделать. Я
могу сказать if constexpr requires вот это вот все. Вывести 1, иначе 2. Могу же я так поступить? Вот
давайте-ка я так сделаю. Я скажу if constexpr requires вот это вот все добро. Ну, это, конечно, кривоватая
конструкция. Я не знаю, это очень странно выглядит. Но, тем не менее, формально так можно,
никто мне не запрещает. И фигурная скобочка открывается. Так, сейчас. Я даже не знаю,
как здесь отступ правильно сделать. Ну, давайте std-seout 1 else std-seout 2. А почему я сказал,
что это криво? В смысле, здесь выглядит криво, но звучит как валидное использование? Ну, потому что,
я думаю, что... Пусть я хочу. Так, сейчас я как-нибудь вот так сделаю. Господи,
как же мне отступы-то расставить? Правильно, вот так, короче, я сделаю. Вот так, наверное,
правильней всего расставить отступы. Вот, ну... То есть, я могу заменить это вызовом функции,
в которой будет написано requires-requires и дальше вот это вот свойство. Ну, наверное, да, наверное,
это можно использовать. Я просто никогда не видел, чтобы такое где-то писали в реальном коде.
Возможно... Ну, люди как-то лет 20 подряд писали вообще без стипус-20. Нет, я видел использование
концептов и констрейнтов в реальном коде, но вот такого конкретно я как-то не встречал,
и поэтому оно мне как-то пока не выглядит как что-то. Возможно, это нормальное использование,
и так люди пишут, но просто мне сейчас как-то вот как-то оно мне эстетически вызывает неприязнь
пока. Может быть... Короче, не знаю, никак не могу прокомментировать. Ну, реально,
более красиво было бы просто вынести вот этот вот if в функцию. Ну, кажется, что было бы красивее
написать выше constexpr-bool requirement-satisfied равно requires-blah-blah-blah, а потом if constexpr-requirement-satisfied
сделать одно иначе другое. Вот так. Ну, под if писать вот эту вот огромную хрень, это очень
странно выглядит. Поняли, что я имел в виду? Ну, то есть, логично завести здесь переменную.
Я просто к тому, что под if писать вот эту странную конструкцию как-то очень криво
выглядит. Но формально можно, должно заработать. Давайте проверим. Сейчас будет смешно, если оно
не заработает. А, нет, оно заработало, мы уже проверили. Ну, то есть вот requires-expression.
Вот. Давайте посмотрим, какие еще можно требования перечислять в requires-expression.
Сейчас я открою соответствующую статью cpp-reference.
Значит, так. Ну, давайте посмотрим на это перечисление. Действительно, лучше просто
показать, чем я буду пытаться это все перечислять руками. Сейчас, значит, я расшарю экран. И вот эту
вот статью, страницу мы посмотрим. Значит, это страница cpp-reference, которая называется constraints-and-concepts.
Вот. Пока я не говорил о том, что концепт, пока мы игнорируем часть про концепту. Сейчас я как раз
про нее следующим шагом расскажу. Вот. Пока мы говорим только про requirements. Вот смотрите,
какие могут, можно делать requirements. Ну, пока что такое концепт мы игнорируем, мы смотрим только
на вот это выражение. Вот. Можно потребовать существования внутреннего типа. TypeName t2.hinner.
Вот это то, что я сделал. Можно потребовать typeName s от t. Потребовать, чтобы существовала специализация.
Значит, or that a class template specialization names a type. Ну, что существует, значит, специализация s таким t.
Наверное, это вряд ли означает, что существует... Да, это скорее всего означает, что просто такой
тип validin. Не что существует специализация выделенная, что просто такой тип validin. Было бы странно.
А как он может быть validin? Там тебе можно в шаблонах писать тоже requirements? Ну, например... Да-да,
requirements можно в шаблонах писать, кстати. В общем, не знаю, что это значит. Не знаю, не буду гадать.
Вот. Ну, давайте на другие примеры посмотрим. Вот, например, вот у меня есть common type. Что такое
common type? Это sd common type t от tu. Да, понятно. Объявили такой alias. Значит, теперь мы пишем requires.
Что мы хотим? typeName common type от tu. Да, вот хотим, чтобы common type от tu был valидным и names a type.
Ну, например, вдруг common type от tu это не тип, а константа числовая. Банальный пример. Это может
быть не names a type. Что-то другое. Что? Как это возможно? Ну, в смысле, я тебе сказал, что common type от tu это
bool. Это не using, а bool. Я же пишу код, я же не знаю. Я хочу, чтобы common type это был тип. Чтобы common type
от tu был корректный тип. Вот всё, что я сейчас здесь потребовал. Ну, пока не вижу проблем. Ну, типа,
понятно вроде нормально. Ты сказал, что чем ещё он может быть? Ну, common type tu может быть bool. Я могу
написать template typeName t typeName u bool. Const bool common type равно false. Ну, это булевская шаблонная
константа, как из класс V, может быть. Вот, а дальше что я потребовал? Дальше я потребовал, что вот это я
сделал, кстати говоря. Ну, я проверил, что common type конструируется от... ну да, я проверил,
что common type tu можно создать от вот этого, и проверил, что common type tu может создать от вот этого.
Вот. Непонятно, правда, почему я в фигурных скобочках во внешних это всё написал. Ну, здесь,
наверное, перечислено. Да, собственно, simple requirement, type requirements, compound requirements,
nested requirements. Вот, simple requirement это просто когда я написал expression. Type requirements это
когда я написал... да, это вот считается type requirements. Не знаю, почему это во внешних
фигурных скобочках написано здесь. Ну, значит, так надо. А не как? Ну, просто common type tu и вот это
вот всё, казалось бы. А, я понял, потому что тогда бы он воспринял это как simple requirement, вероятно.
Значит, simple requirement. Я могу просто потребовать, что expression валиден, а дальше я могу потребовать,
что type валиден, что type существует и валиден либо написать type name, либо написать внешние
фигурные скобочки и написать какой-то type. Видимо. Честно говоря, я всё ещё не понимаю,
зачем здесь внешние фигурные скобочки. Ну, чёрт с ним. Вот, могу сделать compound requirement. Что
такое compound requirement? Это я, значит, ну, вот тут придётся видимо пропустить эту секцию, потому
что здесь я, ну, я могу потребовать, чтобы некоторое выражение было само удовлетворяло какому-то
требованию. Вот, но для этого мне придётся объяснить что концепты. Вот, пока мы концепты ещё не
обсудили, я, наверное, пропущу этот кусок. Ну, если вкратце, то здесь, да, написано, я могу
потребовать, чтобы вот expression был удовлетворял концепту. Вот, ну и я могу делать nested requirements.
Это я могу внутри requires написать ещё requires. То есть, вот у меня есть requires, а я внутри него
пишу снова requires. Зачем я это пишу? Потому что, если бы я не написал requires, внутренний requires,
то это бы означало, что я просто хочу проверить валидность вот этого вот. А когда я пишу внутренний
requires, я требую, чтобы это было true. То есть, я говорю requires blah blah blah. И, например, requires
is same where от чего-то там чего-то там. Если я просто напишу внутри requires is same where от чего-то там
чего-то там, он просто проверит валидно ли это, а не проверит true это или false. А если я ещё
под requires напишу это, то это будет означать, что я требую, что это true, а не просто что это
валидная штука. Вот, я могу проверить, что что-то noexcept вот таким способом. Я могу говорю в
фигурных скобочках noexcept. Тем самым, я проверяю, что вот эта вся штука это noexcept.
Ну и вот то же самое. Я говорю requires там same blah blah blah requires same. И ещё проверяю,
что вот такая вот вещь валидная. Ещё бы ещё раз мысль фигурных скобочек ещё одних.
Всё, надеюсь, в лишних фигурных скобочках. Мы пока не поняли, что это. Да, я тоже пока не
понял, что это. Видимо, я понял, но забыл в какой-то момент, зачем это нужно. Compound requirement.
Почему это compound requirement? Так, сейчас. Сейчас, давайте быстренько посмотрим. Наверное,
тут должно быть объяснено, что означают для него лишние фигурные скобочки. Значит,
simple requirement. It asserts that expression is valid. Requirement blah blah blah. Type requirement.
А, это compound requirement. Это не type requirement, это compound requirement называется. Вот если оно
в фигурных скобочках, то это как раз третий вариант. Это называется compound requirement.
Собственно, вот. В фигурных скобочках expression, а дальше, возможно, no accept и, возможно,
требование к возвращаемому типу. Значит, я пишу в фигурных скобочках expression и это заставляет
его проверить какие-то свойства данного выражения. В следующем порядке выполняется подстановка и
проверка. Значит, сначала подставляются шаблонные аргументы в этот expression. Если no accept использован,
то expression должен быть no accept. Если return type представлен, то еще проверяется это. А я думаю,
вот зачем нужны фигурные скобочки, потому что я использую t внутри expression. Я думаю, вот зачем.
А иначе бы что произошло? Потому что, видимо, иначе бы он не подставил. Нет,
no accept понятно, как проверить. Вот здесь вот зачем фигурные скобочки, я все еще не понимаю.
Ну, черт с ним. Ну, можно быстро проверить на самом деле, в чем разница. Но я не уверен,
что сейчас мы это быстро распознаем. Ну, давайте, я не знаю, например, вот здесь вот. Ну, скажем,
вот здесь. Давайте я проверю, что t обладает деструктором. Что x.tilde t это корректное выражение.
Давайте проверим, что будет. 1, 2. Так, а если я фигурных скобочках напишу, то тоже, видимо,
будет 1, 2. Ладно, я не знаю, в чем разница. Возможно, они, блин, для красоты это написали.
А можно убрать все остальное? Все, кроме проверки деструктора? Да, пожалуйста.
Ну и, понятное дело, опять с и без. Так, понятно, должно работать. А без?
Ну, все одинаково. Сейчас, секунду. 1, 2, 1, 1. Мы вообще вызываем их в каком порядке?
Так, там кто-то нам в чате что-то пишет явно. Нет, ничего не поменялось. Просто от того,
что я... Теперь он стал под int подходить тоже. Вот что поменял. Под string стал подходить.
У int есть деструктор? Да, вызов деструктора int это корректно. Иначе бы, когда ты писал вектор,
у тебя было бы CE, как только ты вектор int'ов пытаешься делать. Убедительно.
Что такое существование? Я все еще не понял. Разницу, мне кажется... Нет, мне кажется,
что-то разница в чем-то другом, если она есть. Мы ее не видим. Но я предлагаю забить и начать
говорить про концепты, потому что, значит, мы не успеем. Все, короче, про requires я все,
что хотел, сказал. Вот. Если поймете, в чем разница, напишите в чат. Ну или кто-нибудь в комментариях
напишет потом под этой лекцией, в чем разница. Теперь концепты. Что такое концепты? Концепты
это, по сути, именованные наборы requirements. У меня есть requirement. Какой-нибудь. Вот,
допустим, я хочу, чтобы мой тип был, ну, я не знаю, удовлетворял концепт под ключевое слово. Да. Я
хочу, чтобы мой тип был, ну скажем, incrementable. Не знаю, вот хочу такое требование. Ну, я могу
много там разных штук придумать. А, ну давайте, вот, давайте я, например, вот какую вещь сделаю,
потребую от своего типа, чтобы он был, ну скажем, сравнимым на equality comparable. Вот я хочу написать
такую штуку, вот, чтобы мне не повторять сто пятьсот раз, что вот моя функция должна работать только
для типов, которые удовлетворяют следующему набору свойств. Я говорю, требую, чтобы мой тип был
equality comparable от t. Equality comparable от t это некоторая новая сущность, она называется концептом. Я
могу объявлять концепты, и концепты будут состоять из requirements. Я пишу template, type name t,
concept equality comparable равно requires от t, x. Ну, вот так могу написать. Ну, или в одну строчку даже
напишу t, x, t, y. Значит, x равно равно y, x не равно y. Вот я... Что-то не так. Так, и что же не так?
Да, значит, концепт пишется так. Я говорю, template, type name t, concept, название концепта, а дальше равно и,
ну, я могу вообще и bool написать. Я могу написать здесь std из класс v, что-нибудь там. Так тоже можно.
Ну, вы и написали bool. Вы же и написали. Я понимаю, но я говорю, что кроме requires можно и другое
писать. Здесь это не то, что требование обязательно requires писать. Я вам сейчас покажу некоторые
стандартные концепты, вы увидите, как они определены. Это забавно будет. Например, есть стандартный
концепт derived from. Он почти как из базов, только еще в него добавлено, что это публичное
расследование неприватное. Да, он проверяет конструируемость. Мы даже видели только что на
примере common type. А чем концепт отличается от просто using? Сейчас увидите. Если не подставляется,
то false, скорее всего. Ну, давайте я продемонстрирую, что это работает. Вот у меня есть template,
requires equality comparable t и какая-нибудь другая штука. Ну и давайте я сделаю структуру s,
которая не equality comparable. Ну и продемонстрирую. Вызовусь от s и вызовусь от inta снова. И мы увидим,
что сейчас я в одном случае попаду в одну версию, в другом в другую. В случае с s я попал
во вторую, потому что на ней equality comparable. В первом случае я попал в первую версию,
потому что на equality comparable. Концепты – это очень крутая штука, потому что она позволяет вам
очень красиво писать. Во-первых, вот то, что я сейчас написал – это, так скажем,
развернутая форма использования концепта. Существует сокращенная форма, которая мне кажется,
и плюс-минус и будет всеми принята как стандартная. Я могу в шаблоне писать. Вот смотрите,
вам наверняка хотелось раньше, когда вы пишете template typeNameT, typeNameU, если вы требуете от t и u
быть какими-то особенными типами, а не просто произвольными типами, то вам, наверное, хотелось бы
это как-то в самом заголовке шаблона указать. Наверняка вы уже, если вы достаточно долго этим
занимались, то вас наверняка должно было раздражать, когда вы видите template typeNameInputEther,
typeNameOutputEther, что-то там. Сами имена inputEther и outputEther никак не отражают смысл. То есть это
просто договоренность, что мы так называем шаблонные параметры в стандартных алгоритмах,
чтобы они соответствовали тому, что мы от них ожидаем. Но ведь назвать inputIterator шаблонный
параметр в стандартном алгоритме – это просто договоренность. Я могу любое имя туда подставить.
Но теперь в C++20 я могу говорить inputIterator прямо в заголовке шаблона. То есть я говорю
templateEqualityComparableT без всякого requires void f of t, x. Это эквалентно тому, что раньше
было написано. То есть я говорю, у меня есть template для equalityComparableT, а есть template для
произвольного t. В частности, теперь я могу, например, написать такую... ну, я могу, например,
определить концепт inputIterator, скажем. Да, вот я могу сказать, давайте я заведу концепт inputIterator.
Ведь по сути inputIterator – это же концепт. Ведь это вот то, что нам очень долго не хватало. Мы
хотели бы, чтобы у нас вот это вот название inputIterator было чем-то. У нас до сих пор были
named requirements в языке. У нас был named requirement – контейнер, named requirement – аллокатор,
named requirement – inputIterator. Теперь мы это все можем выразить в виде концептов. То есть если мы
ожидаем от типа, что он говорит какому-то набору констрейнтов, то мы говорим, этот набор констрейнтов
мы назовем концептом. Вот назовем концептом inputIterator штуку, которая умеет разыменовываться,
инкрементироваться и еще что-нибудь делать. Разыменованному X можно что-нибудь присваивать,
не знаю. Ну, звездочка X равно там что-нибудь. Звездочка X. Вот так, например, я могу делать.
Вот. Ну, еще стрелочку надо проверить, наверное, как-нибудь. Ну, в общем, ну, неважно. В общем,
мы перечисли какие-то штуки, которые я хочу здесь от inputIterator. Теперь, когда я пишу свой шаблонный
алгоритм какой-нибудь inputIterator, там Iter. Ну, тут, конечно, проблемы с именами будет. Iter 1. Ну,
я могу сказать inputIterator. Iter. OutputIterator. Неважно, вот так просто сделаю. И какой-нибудь
алгоритм void что-нибудь, я не знаю. FindIf. А, например, вот FindIf. Я хочу, у меня есть inputIterator,
а еще есть predicate. Я сделал концепт inputIterator и сделал концепт predicate. Унарный predicate,
который там от какого-нибудь, ну, от чего-то умеет вызываться. Не знаю, isInvocable с какими-то там
параметрами. Ну, тут надо подумать, как это выразить. Ну, в общем, to do. Ну, давайте я напишу,
не знаю, true просто. Ну, вот у меня, допустим, есть концепт inputIterator, есть концепт унарный
predicate. Теперь, когда я пишу FindIf, мне не надо вот этих вот искусственных имен, что input,
что Iter это inputIterator, pred это действительно predicate. Я просто за счет концептов потребовал
от типов того, чего мне нужно. И если я попробую вызваться, вызвать этот метод от не тех типов,
от которых можно, то мне скажет компилятор, что requirement не выполнен, поэтому от такого
типа вызываться нельзя. Илья, я сказал, что давайте проверим ещё, ну, тебе нужно ещё проверить,
что существует стрелочка. Я задумался и не придумал, как. Вот стрелочку действительно непонятно,
как проверить, потому что непонятно, чего её вызывать. Поэтому я не знаю действительно,
как стрелочку проверить. Но, в принципе, как с унарным предикатом, не очень понятно,
как его проверить, потому что предикат нужно от чего-то вызывать. Вот, написать что-то в стиле,
существует такой тип, что унарный предикат от него будет нормально работать. Ну. Илья, можно
просто ещё. Как работает? Это же есть find if, верно? Что в него передаётся? Два итератора и? Ну и предикат.
Что такое предикат? Ну, в смысле, функциональный объект. И предикат от чего? От value type, верно? От
value type, да. Фух, и мы идём и проверяем, что-что. Что? Предикат от очередного value type. А, разменование?
Да, конечно, мы идём. Он не пользуется стрелочкой. Обычный find if не пользуется стрелочкой. Да нет,
не пользуется. Это смешало. Понимаешь, окей. Да, ну возвращает он не void, а возвращает снова iter.
Вот, тут надо не запутаться. Тут надо, значит, вот здесь может начаться путаница, потому что у
нас возникла ещё одна сущность, концепт. Вот iter это тип, а input утератор это концепт. Я возвращаю
именно iter, а не input утератор теперь. Input утератор это концепт. А принимаю я типы и возвращаю тип.
Вот. Ну, давайте посмотрим на какие-нибудь стандартные концепты, которые есть в языке.
Я ещё, правда, вижу, что поэтому есть перегрузка. Да, всё так, сейчас мы это обсудим. Да, так,
сейчас только я потерял... где у меня... да что ж такое-то?
Так, сейчас мы посмотрим на... да, замечательно, мы пришли туда же.
Где? Concept library, вот она. Вот, давайте посмотрим на то, какие у меня есть концепты стандартные,
уже определённые в языке, C++20. Вот есть std same-as. Вот. Что такое концепт same-as? Это
такой концепт, который выполнен тогда и только тогда, когда ты и у одинаковый тип. Вот. Ну,
по сути, это наш старый добрый isSame просто по-новому записанный. Ну, можно same-as выразить
через него. Вот, собственно, здесь написано. Same-as. Что такое same-as? Это same-helper tu и same-helper ut.
Не знаю, зачем они сделали в две стороны, честно говоря, но по сути same-as это и same-where. Вот есть
концепт derivedFrom. Это наш старый добрый isBasedOf, только наоборот, и с дополнительным условием,
что приватное наследование мы не распознаём теперь. Что такое концепт derivedFrom? Это isBasedOf
where base derived наш старый добрый и конъюнкция. Кстати, конъюнкцию можно без скобок здесь
использовать. И, кстати, конъюнкция здесь работает не так, как... Вот конъюнкция в
requirement-ах работает не так, как конъюнкция в обычном смысле. Она не падает, если там CE. Вот это
важно очень тоже. Ну вот, isBasedOf и isConvertible. Ну, то есть, как мы... У нас был isBasedOf,
который распознаёт, в том числе, приватное и амбигиус наследования. Как мы из него... Как мы его
исправим так, чтобы оно перестало распознавать приватное наследование? Мы просто добавим
конъюнкцию, что ещё isConvertible, isConstDerived, constBased звёздочка. Вот. Note that this behaviour is different
from isBasedOf, потому что если база — это приватная или защищенная база, то она не распознается. Вот вам
примеры. Вот. Ну, много из концептов, которые тут есть стандартные. Вот, пожалуйста, common,
common with, integral, sign-integral. Собственно, вот все эти вещи, copy-constructible, move-constructible. Вот,
по сути, что такое концепт copy-constructible? Это move-constructible, и вот часть из этого концепта,
часть из этого... Ну, это всё уже концепты. Часть из этого... Почему copy-constructible,
это move-constructible и что-то ещё? Я не знаю, почему они так сделали. Ну, наверное, у них были какие-то
весомые аргументы так сделать. Вот copy-constructible — это не просто из copy-constructible, который раньше,
они добавили к нему ещё дополнительные требования, навесили. Ну, хорошо, вот destructible. Ну,
destructible — это просто то, что раньше называлось isNullThroughDestructibleWay, а теперь называется просто destructible.
Вот, но есть и более интересные концепты. А, вот, например, концепт copyable. Да, это copy-constructible,
moveable, assignNullFrom. Ну, тут много всего. Но в конечном счёте это всё выражается через наши старые добрые
просто более удобным способом. Вот, и давайте посмотрим на итераторы. Вот, я вам говорил, что есть...
Значит... Так, сейчас у нас... Что, у нас интернет отваливается, что ли?
Библиотека итераторов. Вот legacyInputIterator, legacyOutputIterator. Меня вы спрашивали там где-то зимой,
почему они legacy. Ну, потому что их заменили концепты в C++20. Вот то, что раньше называлось
namedRequirements, legacyInputIterator, legacyForwardIterator, сейчас стало заменено концептами. Например,
есть концепт inputIterator. Это концепт, который... Ну, он много чего проверяет. Вот, тут... Сложно
разобраться, но если вкратце, то он проверяет все требования inputIterator, которые можно проверить
в compile-time, что у вас всё, что нужно, определено, что у вас input or outputIterator, то есть это общие
требования для них indirectlyReadable, что-то ещё, и derivedFromInputIteratorTag, если взять
там вот... Если, короче, в IteratorTrades взять вашу IteratorCategory, то, видимо, она будет
наследницей stdinputIteratorTag. Вот, пожалуйста, inputIterator — это такой концепт. Что тут написано,
секундочку. ForwardIterator — это вот такой концепт. Там какой-то очень непонятный синтез был. Где?
Вот, например, std derivedFrom. Да, в inputIterator. Да. std derivedFrom, typeName, комментарий. Нет,
requires. Нет, подожди, тут requires ещё вложенный. Да. А что оно required? Ну, IterConcept — это какой-то
внутренний компиляторный тип, который мы не знаем, как называется. IterConcept — это штука,
которая... Какой комментарий? В смысле, это то, что нельзя здесь назвать. Это некоторый внутренний
компиляторный тип, который мы не знаем, как называется. Как-то он называется. Ну, в смысле,
это псевдокод, а не обычный код, разумеется. А кода нет? Этот тип как-то называется внутри
компилятора. Мы не знаем, как. Он нестандартный. Это тот тип, который бы у компилятора существует
из-за того, что он operator.trades там инстанцировал. Сейчас, секунду. Концепт этот написан на языке
C++, верно? Конечно. Просто вот этот тип... Это его код настоящий. Нет, это псевдокод, потому что
IterConcept — это тип, который... Ну, хорошо, вот std.visit. Вы видели, как все переференс описан? Нет,
потому что он сказал, что это очень страшно. Ну, здесь то же самое написано. Вот это же не настоящий
код. Возвращаемый тип, который мы не можем здесь назвать, потому что он сложно очень
определяется, и это компилятор решает, как его определить. То же самое с Invoke или с чем-нибудь
еще там. Это псевдокод, потому что тип, который здесь... NoExcept в зависимости от... Смотрите вниз,
от чего. Потому что это там... Забота компилятора. Правильно написать что-то там. Я не могу написать
свою версию. Ты можешь написать свою версию, если ты напишешь свой Iterator.trades, аналогичный
компиляторным Iterator.trades. В них у тебя будет какой-то мега супер-стрёмный тип, который обозначает
то, что надо. Вот он здесь будет фигурировать. Вот. Чем круты концепты еще? Можно делать перегрузку
по концептам. И здесь, поскольку у нас время почти закончилось, давайте я вам покажу тот самый файл,
который у меня был заранее заготовлен. Я его снова скопирую из старой папки. Сюда. Не скопирую,
потому что я затруэт. Ну, я просто покажу его. Смотрите, какая замечательная штука. Я могу делать
концепты, которые включают в себя, в конъюнцию другие концепты. Вот в этой конъюнции, вот в этих
вот Requirements, так вот это я затру, чтобы не смущало никого. Это прошлогодний просто код. Вот в этих
концептах, когда я пишу равно и требования перечисляю, я в конъюнции могу другие концепты
использовать. То есть, на самом деле, строго говоря, не только булевские выражения я могу здесь
использовать. Я могу использовать булевские expression либо другой концепт. Когда я определяю концепт,
ну или когда я делаю Requires, я могу использовать концепт. Например, я говорю bidirectional iterator
это forward iterator и еще требование, что его декрементировать можно. А random access iterator
это bidirectional iterator и еще требование, что можно прибавлять к нему число, вычитать, сравнивать
на меньше. И давайте вернемся к старому нашему доброму примеру с advance и distance. Вот функция
advance. У меня есть итератор, его нужно продвинуть на n. У меня есть две версии, одна для bidirectional
iterator, другая для random access iterator. Но здесь forward iterator на самом деле, наверное, надо. Давайте
скажем bidirectional. То есть, у нас там была какая проблема? В C++11 она решалась вообще с тремной
перегрузкой. В C++17 появилась ifconstext. Но с концептами я могу вообще очень сделать красиво,
без всякого if. Я пишу template bidirectional iterator и реализую одну версию, а template random access
iterator реализую другую версию. И смотрите, это работает. То есть, если я сейчас вызовусь от
листа, у которого bidirectional iterator, то my advance будет первой версией. А если я вызовусь от
вектора, то my advance вызовется второй версией. Давайте я продемонстрирую, что действительно так
работает. В первом случае вызвался, значит, my advance первой версии, во втором случае my advance
второй версии. А как он догадался? Как компилятор понял, что вторая версия более частная, чем первая?
Вот здесь опять сработало правило частное предпочтительнее общего. Но мы с вами говорили,
что если написать requires и какую-то конъюнкцию, то он не поймет, что оно предпочтительнее. Но если
написать на концепты, то он поймет. И это, кстати, ответ на твой вопрос. Как сделать, что сначала я
проверяю, если у меня тип вообще, потом я проверяю, есть ли у меня этот тип и что-то еще, и третья версия
для всего остального. На концептах это можно сделать. Для этого мне нужно, чтобы один концепт был,
имел вид другой концепт, конъюнкция, что-то еще. Вот если у меня концепты представляют из себя
другие концепты, объединенные конъюнкцией с какими-то дополнительными условиями, то он понимает,
какой концепт более частный, какой более общий. Это называется, что один концепт subsumes другого.
Он строит на самом деле частичный порядок на концептах. Это вообще просто пушка полная.
Он, компилятор, на концептах устанавливает частичный порядок в зависимости от того, какие там были
условия в этих концептах. Сейчас я вам покажу, ну давайте я опять открою страничку Concepts and
Constraints, возможно я быстрее вот так на нее дойду. Нет, не быстрее, что-то себе переференс лежит.
Да, значит Concepts and Constraints. Смотрите, есть понятие Atomic Constraints. Вот constraint,
которое представляет в себе просто выражение, это Atomic Constraints. Ну, например, вот это вот
requires что-то там, это атомарный constraint. Из атомарных констраинтов я строю концепты.
И когда у меня концепт включает в себя другой концепт и еще какой-то Atomic Constraints, то он
начинает упорядочивать констраинты по принципу, какое более частное, какое более общее. Это
называется Constraint Normalization. Он берет, значит Constraint Normalization, это процесс, который
трансформирует выражение с констраинтами в последовательность конъюнции и дизьюнции
атомарных констраинтов. Дальше определяется, что нормальная форма этого выражения. Ну,
по сути, он приводит его к какой-то конъюнтивной или дизюнтивной нормальной форме с этими
констраинтами и упрощает, короче говоря, преобразовывает так, что понимает, кто из них более
частный, какой более общий. Но вот утверждается, что если вы будете писать концепты, опираясь на
другие концепты, то он справится. Вот компилятор, я не уверен, насколько это
проформальное требование компилятору, что он должен уметь это все парсить, но на практике
он уже справляется, что же плюс-плюс, что силенг. Если у вас одни концепты выражаются через другие,
то он понимает, какие из них более частные. Вот такие дела. Таким образом, мы решили ту задачу
гораздо лучше, чем раньше. Вот ну и последнее, это значит compound requirements, связанные с
концептами. Вот здесь помните, когда мы говорили про compound requirements, здесь была возможность
в requirements писать требование, что что-то выполнено над этим выражением. Вот здесь опять используются
концепты. Я в requirements могу писать звездочка х, стрелочка, а дальше концепт. Вот здесь именно
концепт нужно писать. Не какое-то тамбулевское выражение, а концепт. Я могу потребовать от внутри
requirement составного, от какого-то выражения, чтобы оно удовлетворяло концепту. Например, что x плюс
1 это same as int. А там x умножить на 1, то convertible, тут t. Вот такие дела с концептами. Ну,
у нас, кажется, время закончилось, но, в принципе, я все, что хотел рассказал, там, за исключением мелких
каких-то возможных деталей. Ну, возможно, я скину какую-нибудь еще пару статейчик вам почитать для,
так сказать, более глубокого проникновения. Ну, и можно будет на этом закончить. В общем,
начинайте пользоваться. Если будете писать последние задачи, да, условия варианта,
я помню. В общем, если будете писать вариант или последнюю задачу, которую я еще тоже сейчас обдумаю
и повыкладываю, то можно, наверное, будет пользоваться концептами уже там. Вот такие дела. Ну что,
вопросы? Ну, тогда давай. У нас там было несколько неявных штук. У нас есть концепты от двух
переменных. Мы, на самом деле, руками не писали ни одного концепта от двух переменных и не смотрели,
как они работают. Вот, например, у нас есть концепт same as, который принимает два аргумента. А мы ему
передаем один аргумент, а второй неявно. Вот у нас там есть стрелочка same as. Вот так что-то нам
показывал. Сейчас. Сверху, чувствуешь? Нет. Да где? Так ладно, сейчас я поищу по странице просто. Да,
вот оно. Same as, у которого два аргумента. Вторым не явно передается то, что получилось в результате
выражения первого. Да, забавно. А вторым это с левой или справа? Я, кстати, не обращал на это внимание.
Мы уже так делали, фактически. Когда у нас было ноль аргументов, и мы передавали один неявно,
тогда все очевидно. Здесь у нас два аргумента, и мы один передаем неявно. Да, но вот тут... Да,
кстати, это забавное замечание, потому что я даже не заметил. Я подумал, что там с одним... Да,
значит, получается, что expression x plus one must be valid и same as... Ну да, вот он как это парсит,
значит, decal type от вот этого и int must be satisfied. Ну да, это именно в requirements так делается,
значит. Получается, что... Да, собственно, поэтому после стрелочки и должен идти requirement,
потому что иначе он не понимает, что делать. Именно concept, да. Что-то Даниил Максимов говорит,
код не компилится. Какой код не компилится? Вот этот? А у тебя плюсы двадцатые? А компилятор
какой? Версию компилятора еще надо. Ну g plus plus десятый уже справляется. Кстати, год назад еще...
Год назад еще не было std input-utterator. Ну то есть еще год назад, когда я рассказывал про вот это все на
аналогичной лекции, не было... В STL еще не реализовали в моей, по крайней мере, версии STL, там с g plus
plus, какими я не пробовал, или с C-Lang, не реализовали std input-utterator, std forward-utterator и так далее,
поэтому свои я писал. Сейчас уже они есть, сейчас они уже распознаются и работают. Ну то есть это прям
вот, ну вы понимаете, стандарты сдали два года назад, компиляторы, только вот в прошлом году более-менее
начали поддерживать все то, что тут написано. Но наверняка еще очень много багов, то есть понятно,
что такой фичи, как это, не может быть сразу с первого раза все идеально. Возможно, с 23-м что-нибудь
придется чуть-чуть поменять, но это как с большим любым нововведением язык, как и с лямбдами было,
как и с аллокаторами, как и с мосемантикой. Там через несколько лет обнаруживается, что некоторые
идеи были не так уж хороши, и приходится чуть-чуть их корректировать. Ну то есть я думаю, здесь вы
можете поэкспериментировать и открывать. Может быть, вы даже что-то придумаете, что-то сможете
предложить в комитет, что они даже рассмотрят, потому что тут есть еще простор для корректировки
и воображения и всего этого прочего довольно большой. Еще люди еще не наловчились с тем этим
пользоваться, как полагается. Вот. Ну да, интересное замечание про вот это. Я даже не замечал, что здесь так.
Ну ладно.
