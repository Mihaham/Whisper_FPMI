Всем доброго дня! Мы сегодня продолжаем с вами говорить про алгоритмы парсинга. Сегодня наш
цель является разобрать алгоритм early целиком. В прошлый раз мы с вами начинали с мотивировки того,
зачем нам нужен алгоритм early, точнее, какие абстракции у нас с вами в ней будут. И мы в
прошлый раз попытались построить гипотетическое дерево разбора для слова аб. Мы это успешно
сделали и с вами заметили, что у нас есть три вида операций. Первая операция — это спуститься по
дереву разбора вниз, вторая — это прочитать слово целиком, а третья — это подняться по дереву разбора
вверх. И мы с вами разобрали, допустим, следующую ситуацию, что на самом деле все гипотетические
деревья разбора мы можем зашивать в некоторые наборы ситуации. Вот эти вот множества называются
у нас ситуациями. Вот на примере, если мы находимся, вот мы разбирали пример, мы находимся в пятой
позиции, где-то в пятый момент времени, мы с вами смотрели, мы находились, где тут ab, ab,
но при этом мы находились в правиле из-за сводца SBS. Тогда мы с вами можем закодировать, значит,
позицию точки, где мы сейчас находимся в дереве разбора, как позицию DGT, а здесь мы кодируем эту
позицию как DGT, то есть то, где точку у нас находится у родителя. Почему этого нам хватит? Потому
что мы с вами говорили, что DFS — это такая вещь рекурсивная, и для эмуляции DFS, чтобы вернуться
из рекурсии DFS, нам нужно подняться на один уровень вверх. Вот, мы это говорили. И давайте
сразу скажем очень важный факт, что далее везде вывод является левосторонним, да, это нам поможет
в какой-то степени в доказательстве, чтобы не морочь себе голову. Вот, здесь на презентации есть
пример, опять же, тут более простая грамматика, у нас есть слово abc, и нам нужно понять, какое
правило нам необходимо приклеить к не терминалу A. Но на самом деле, что мы тут видим? Мы видим,
что когда мы предскажем правила из S выведем AB, дальше из A нам нужно с вами выбрать позицию
либо A, либо C. Но для того, чтобы ее выбрать, нам нужно взять и прочитать следующую букву в слове.
Ну, мы не можем двигаться, потому что нам нужна следующая буква. Да, то есть, если посмотреть на
дерево вывода, то как мы можем двигаться? Если мы встречаем не терминал, то можем спуститься вниз,
если мы встречаем букву, мы можем прочитать букву, прочитав при этом слово все целиком,
либо подняться наверх. Да, но при этом нам нужно, опять же, прочитать какой-то не терминал и точку
сдвинуть от этого не терминала вправо. Вот, поэтому здесь ответ на данный вопрос является, что мы
должны выбрать правило из A следует A, и оно будет у нас выполнено при операции, следующей операции
сканирования. Вот, и смотрите, я тут назвал три абстракции, они, конечно, не очень хорошие,
если вы их не поймете, ничего страшного. Вот представьте себе, мы с вами строим дерево,
мы собираем новогоднюю елку. Новый год же скоро, уже два месяца осталось. Вот, что нам необходимо?
Нам нужно три абстракции. Значит, первая абстракция — это наживитель. Что такое наживитель? Это мы,
по сути, к одному дереву подвешиваем второе. То есть у нас обычно, когда мы елку собираем,
у нас есть крепление, с которым мы, по сути, делаем защелку. То есть, ну, прикрепляем,
сначала наживляем. Это все история. Это мы будем называть раскрытие дерева по не терминалу. Вторая
история — это закрепитель. Что такое закрепитель? Это подтвердить, что правила грамматики
действительно подходят. То есть, вы собрали уровень елки, обвесили ее игрушками, и после этого
закрепляете то, что у вас произошло. По сути, это, если мы говорим в терминах системы контроля
версии, это, так или иначе, коммит. То есть, когда мы подтверждаем те изменения, которые у нас были.
И нам нужна третья абстракция, которая выберет, вычистит все лишние деревья разбора. Я ее назвал
шпателем. Вы проходите, у вас буква не та, выбираете, сдираете то дерево разбора, которое было. То есть,
вот мы с вами здесь показывали, как работает шпатель в прошлый раз. На самом деле, это такие
жаргонные понятия. Давайте сейчас их немножечко расшифруем. Но прежде чем мы это делаем, мы скажем
следующее. Важное замечание, что из-за того, что у нас вывод везде левосторонний, то если у нас
из С выводится какой-то, как это посредственнее терминала, в терминала ФИАСИ, то ФИ это на самом деле
буквы алфавита. Но почему? Потому что, точнее, смотрите, если, вот давайте вот так напишу. Сейчас я это
уточню. То есть, смотрите, у нас вывод левосторонний, из С выводится ФИАСИ, при этом дальше у нас за
один шаг, допустим, у нас было правило грамматики А, вводится Б. ФИБСИ. Если у нас картинка такая,
то ФИ принадлежит Сигма со звездой. Почему это так? Потому что в левостороннем деле вывода, если у нас
был какой-то не терминал слева от того, который раскрылся, то мы его должны были раскрыть раньше.
Вот. К сожалению, у нас это здесь не так. Вот. Это важное замечание, которое нам с вами понадобится в
будущее. А что здесь не так еще у нас? Где? Вы сказали, это здесь не так. А, на презентации не так, здесь еще
типа нужно сказать, что еще за один шаг мы должны что-то сделать. Ну иначе это вообще неправда. Вот.
Теперь смотрите, какие инструменты у нас есть. Опять же, пусть у нас есть слово на входе. И если у
нас с шаблом какой-то уже подходит, то на самом деле у нас работает такая абстракция, что из С мы
вводим какой-то ФИ, потом у нас находится не терминал А, и потом находится СИ. То есть у нас с вами С,
потом у нас вводится картинка ФИАСИ. Но при этом и дальше мы с вами, если не терминала А, за один
шаг раскрываем А на Б. Да, и мы находимся с вами в этой позиции. Тогда мы можем понять, что существует
такое И, что у нас СФИ выводится в префикс до этого символа. Но так как у нас ФИ это элемент
Сигма со звездой, то из этого следует ФИ, что ФИ у нас равняется В, до этого символа в частности. Вот.
И тогда мы с вами можем поставить точку. Из А мы выводим АБ, и мы находимся в позиции разбора здесь.
И тогда мы с вами можем сказать, что мы дошли до некоторой позиции G. И это значит тогда, что из А
мы вводим с вами под слово отитого символа дожитого. Вот. И чтобы эту абстракцию обозначать,
мы будем говорить следующее, что у нас есть некоторая А, которая находится для каждого правила
грамматики, которая у нас выглядит вот так ААБ. Мы будем обозначать ситуацию ИТ, и она будет
принадлежать множеству некоторому дожитому. Это ситуация. Такая, что выполнено некоторое свойство.
Я его сейчас напишу, и мы с вами будем его детально доказывать. Потому что, когда мы будем строить
с вами алгоритм, да, мы будем его строить по-другому. Не так, как есть. Давайте напишу. Хотелось бы
иметь вот такой, хотелось бы иметь и вариант. Такое, что существует некоторое, давайте скажем,
ПСИ, что из С мы выводим в ИТ А. А что у нас есть? У нас ПСИ уже в дереве разбора занято.
Это я картинку сейчас рисовал. Сейчас я просто поясню, как это все перекладывается. То есть,
я напишу это в формальных терминах. То есть, у нас получается, выводится так, и за один шаг у
нас выводится вот такая композиция. Альфа, бета, С. При этом из А будет выводиться у нас с вами
символ из ИТ пожитый. То есть, это, смотрите, мы хотим иметь такой вариант, который я описываю,
что мы прочитали символ. То есть, мы дошли до терминала А, потом его раскрыли. Здесь фишка
раскрывается в префиксов от ИТожитого, от нулевого до ИТого. Вот А открывается следующий символ. То
есть, хотелось бы иметь вариант. Это что мы хотим. Теперь нам нужно это все согласовать с алгоритмом,
который у нас был. Да, пока что мы не согласовали это все с алгоритмом. Давайте делать это. Значит,
это идея алгоритма. Мы про нее уже много раз поговорили. Все состояния с и позиции ажи будем
хранить некоторым множеством, которое будет называться ДЖТ. Вот, поэтому мы на самом деле здесь
пишем, что мы А стрелочка альф.б и Т принадлежит ДЖТ. ДЖТ это на самом деле множество вот таких
вот наборов. Можно еще вопрос? У нас получается Ж больше или ровно чем И, да? То есть, мы из А взяли какие-то первые буквы?
Ну, не из А, мы из А раскрываем. То есть, получается у нас такая вещь, что из С мы дошли
до не терминала А, при этом здесь раскрыли какие-то И символов, а из А типа мы обработали символы
от Итого до Житого. Можем обработать. А это разве не всегда выполняется? Нет, далеко не всегда. Если А порождающий,
то тогда... Не-не-не, тут важно, что какие А и Б написаны здесь. Да, то есть, это прямо правила
грамматики у нас. Вот у нас правила грамматики. Вот, тут я определил ситуацию. Давайте просто
сначала для каждого правила определим ситуацию вот таким вот образом. Это определение. А хотелось бы,
чтобы у нас появлялись ситуации только такого вида. Давайте теперь нам нужно научиться получать
ситуацию именно такого вида. Для этого нам нужно с вами посмотреть, какие действия мы с вами осуществляли
в дереве разбора. Вот, смотрите, первая операция. Вот, это пример. Значит, вот это вот дерево,
которое я разрисовал, я просто презентацию показывал. То есть, у нас С феапсид, из А вводится
альфа бета, точка стоит перед бета. Я сейчас буду показывать всю деревню, а слева буду писать
правила. Итак, смотрите, первые правила. Вот они раскрываются символом таким образом. Да, и всегда
давайте сразу скажем, что из а штрих мы добавляем правила из а штрих в с в грамматику, чтобы у нас
не было никаких конфликтов. Это нам будет важно. Итак, смотрите, первая операция это шпатель или
операция scan. Давайте я напишу. Значит, операция scan, она у нас заключается в следующем, что если у
нас есть из а альфа точка а бета и принадлежащее множество выжитых и при этом выжитая равно а,
то мы по сути можем с вами сдвинуть позицию в дереве. То есть, у нас из этого будет следовать, что а
альфа а точка бета и принадлежит дж т плюс один. То есть, мы позицию в точке в дереве двигаем
направо. Соответственно, у нас вот эта позиция будет меняться на единичку. Как это выглядит? Значит,
это выглядит вот таким образом. Def scan, когда мы будем выполнять, мы будем выполнять для множества
выжитого а. Мы будем говорить for а альфа а бета и принадлежащую дж т, if, так сейчас, пусть вот это у нас
с вами будет выжитая. If выжитая равно равно а, то мы будем с вами писать следующее, что в дж т плюс один мы
добавляем с вами вот такую ситуацию. То есть, когда я пишу вот этот вот вывод, это означает,
что мы в это множество добавляем эту ситуацию. Договорились? Вот, то есть, когда я пишу принадлежность,
то мы добавляем это множество. Давайте, кстати, а я дерево не показал. Ну, тут дерево не надо
показать. То есть, просто мы сдвигаем позицию. Так, со сканом разобрались? Ну, по сути,
это двезвик вправо, который мы с вами делаем. Теперь давайте следующую операцию. Операция
предикт. Смотрите, что делаем. Пусть у нас есть какой-то не терминал, ситуацию, перед которой не
терминал у нас с вами, и принадлежит дж т. И пусть у нас есть правила грамматики, из b выводится гамма.
Тогда мы можем с вами для них в множество дж т. добавить эту новую ситуацию.
То есть, давайте картинку посмотрим, как она будет выглядеть. Я тут разрисовал, я надеюсь не ошибся.
Смотрите, чтобы было видно, вот у нас из z штрих выводится phi abc, причем phi это у нас первый
e символ, а a раскрывается в некоторую альфу, это символ от it до jit. А из b у нас выводится гамма,
b гамма это правило. Но смотрите, нам нужно посмотреть, сколько символов мы обработали до
родительской точки, то есть до вот этой точки. Это первые g символов, поэтому мы сюда пишем
gt. И здесь нам надо посмотреть, сколько символов мы обработали до этой точки. Но поскольку здесь мы
ничего не раскрыли, то здесь опять же получается g символов у нас. Поэтому здесь g, а здесь принадлежность
тоже jit. Это предикт. Как это кодится? Это кодится следующим образом. Мы берем, перебегаем,
пробегаем по всем правилам такого типа, пробегаем по всем правилам грамматики и добавляем множество
вот этих элементов. Новые ситуации. То есть это два фара, внутри которых что-то происходит. Мы уже
добавляем туда же, откуда берем. Да-да, ну надо трекать типа была ли эта вершина или не была, была ли
эта ситуация в этом, может или нет. Вот предикт такой. Ну я специально хотел показать картинками. Нам
нужно будет просто с вами потом эти операции, поэтому я их выписываю на доске. А теперь операция
complete или закрепитель, как мы его назвали. В чем она заключается? Смотрите. Пусть у нас с вами уже
была операция B, стрелочка гамма, точка K, принадлежащая джитому. Да, то есть эта ситуация как раз подъем
по дереву вверх. Вот. Тогда нам нужно найти ситуацию, которая по сути позволит поднять нас на один
уровень выше. Эта ситуация такая. Выглядит так, альфа, б, бета и принадлежит дегатому. Да,
заметьте, что вот здесь K совпадает с этим K. Тогда из этого можно будет сделать вывод, что мы давайте
добавлять множество дежитов. Вот такие вот. Так, ой. Кажется, я тут не дописал. Давайте допишем. Альфа, бета,
точка, бета и принадлежащая дежитом. Вот. Давайте картинку посмотрим. Вот картинка. Значит, смотрите,
давайте внимательно смотрим. Мы закрыли с вами правило B гамма, которое выводило символы от K до
джитого. При этом здесь мы слева выводили от символа от 0 до K. Но мы берем правило, по которому мы
можем с вами пытаемся закрыть это дерево. Это правило из A следует альфа, точка, бета, бета. Да,
причем здесь вот мы понимаем, что до этого вывели символы от 0 до I, а здесь мы вывели символы от
I до K. Да, поэтому когда мы сдвинем точку сюда, вот сюда гипотетически поставим, то здесь мы
прочитаем символы от 0 до J, поэтому здесь дежитая. А в родительской вершине мы прочитаем уже символы
только от 0 до I. Поэтому здесь ставится I. Понятно ли операция complete? Что делает? Ну,
вообще давайте по всем трем ситуациям пройдемся. По всем трем правилам. По скану, по предикту и по
комплиту. Понятно. Хорошо, давайте так отдвинемся дальше. Значит теперь надо в этом алгоритме
поставить стартовую точку и конечную точку. Смотрите, стартовая позиция будет такая. Из S штрих
выводится точка S, 0 принадлежит D0. То есть смотрите, мы находимся в S штрих, у нас точка
родительская здесь, мы начинаем, двигаемся в S точку. То есть мы никакое слово не обработали,
а при этом у родителя тоже никакой префикс не был обработан. Вот. Теперь давайте подумаем,
какой у нас будет финиш. Давайте я нарисую картинку. Финиш хочется иметь такого типа,
что мы обошли все по дереву и у нас точка оказалась здесь. Как мы это можем закодировать с вами?
Давайте я подскажу чуть-чуть, а мы индексы простые. S штрих, здесь у нас выводится S точка,
здесь надо понять индекс какой и принадлежно с чему. Первый индекс он про родителей говорит 0?
Да, да, да. Значит 0 принадлежит D0W? Да, да и длинное слово D0W, потому что здесь мы хотим вывести
наш слово целиком. Поэтому все символы у него должны быть обработаны. Вот это стартовые финишные,
теперь нам надо все объединить, все объединить в наш алгоритм. Как мы это делать будем? Ну смотрите,
это алгоритм Erle в первом приближении, как работает. Значит смотрите, вы множество D0,
тут псевдокод на полупитоне, значит смотрите, что мы делаем. Мы говорим, что D0 состоит из
одной ситуации. S штрих стрелочка точка S, запятая 0. Потом мы пока D0 меняется выполняем операция
complete и predict. То есть пытаемся, ну вот в нашем классическом примере, в котором мы это делаем,
нам нужно получить все слова, все правила, затрекать, в которые мы можем спустить точку вниз. Поэтому нам
нужно вот эту вот опцию делать. То есть пока D0 меняется, мы выполняем complete и predict. А дальше
мы делаем следующее. Мы перебираем все буквы слове, выполняем операцию scan, то есть сделаем сдвиг
по букве и повторяем ту же самую историю. Выполняем complete и выполняем predict. На самом деле
порядок операции predict и complete не важно, потому что они выполняют до тех пор, пока слова не имеются.
Кстати, смотрите, важное замечание говорил Руслан, что при операции predict и при операции complete у
нас меняется только множество D0, относительно которого мы смотрим правила. Поэтому когда мы
выполняем операцию complete и predict, мы можем возвращать то же самое множество, просто в него
добавлять некоторый элемент. Вот. И в конце концов нам нужно будет проверить, действительно ли у нас
ситуация S'S.0 лежит в множестве D от длины слова W. Вот, вот такой вот алгоритм. Контрольный
вопрос. Почему у нас эти циклы не превращаются в цикл wild room? Всего конечная ситуация. Да,
количество ситуаций конечное. Их можно посчитать. Для каждого правила грамматики, для каждой у нас,
во-первых, индексы и ижи, они конечны, они ограничены длиной слова. Во-вторых, количество точек,
где мы можем поставить правила грамматики, оно тоже является конечным. Более детально посчитаем ближе
к концу занятия, как это все работает. А теперь смотрите вот такое замечание, которое я хочу
алгоритмами сказать. Давайте мы с вами посмотрим, что на самом деле у нас есть. У нас есть некоторые
правила, которые добавляются в некоторые магические множества, каким-то непонятным образом. Кажется,
они более-менее интуитивно работают. Но теперь, чтобы доказать корректность этого алгоритма,
нам нужно, по сути с вами, доказать, что вот эти вот множества, вот эти вот операции по вот
этому алгоритму, у нас удовлетворяют как раз вот этому соотношению.
То есть снизу у нас просто набор ситуаций, каким-то образом добавляющиеся, а здесь у нас с вами
хотим иметь вот такой вариант. Поэтому нам нужно доказать эквивалентность. Вот такой вот.
Можете еще раз прокомментировать тот инвариант. Там вот из А выводилась альфа-бета. Да, вот он,
давайте, вот он как раз тоже инвариант, вот прямо на экране. Сейчас его покромите. А как в моей
ситуации? Что нам нужно доказать? Смотрим, значит, что нам нужно доказать. Вот, допустим,
у нас в правиле в алгоритме early появилась вот такая вот ситуация. Вот по вот этому алгоритму,
вы какой-то момент времени алгоритму. Тогда нам надо доказать, что он появился не сбоку при пёку,
а именно по вот такому соотношению. Что у нас существует phi в c, принадлежащее n
abn sigma со звёздочкой. То есть вот этот вот инвариант, который мы хотим соблюсти в нашем алгоритме.
Такое, что из phi выводится v от 0 и. Мы сказали, что в левостороннем случае это просто у нас с
вами phi равно v it. Вот. Дальше у нас что? Из alpha выводится символ с it пожитый. И у нас
здесь вот такая цепочка. Из psi выводится phi ab psi. Дальше за один шаг мы выводим phi alpha beta psi.
То есть если, ещё раз, если у нас появилась вот такая ситуация в ходе алгоритма, она могла
появиться в том и только в том случае, когда выполнено вот это вот соотношение. То есть как
раз вот тот самый инвариант, который у нас с вами получался с деревом. То есть у нас, я не помню,
есть картинка у меня? Нет у меня картинка. Давайте нарисую её. То есть у нас phi a psi. Здесь alpha beta.
Здесь точка. Из этой штуки у нас выводится слово it пожитого. А здесь у нас выводится
слово с нулевого поитого. То есть мы по сути доказываем, что наш алгоритм согласован с той
концепцией дерева вывода, который мы хотим. То есть это у нас согласование.
Давайте я вот тут напишу. Появилась в ходе алгоритма.
Понятно, что утверждает Лемма.
Да, да, именно так. Изначально может показаться, что это факт очевидный, но на самом деле этот факт
вообще не является очевидным. Поэтому давайте мы его начнём доказывать. Доказывается он в обе
стороны индукции. Итак, поехали. Значит первое, что мы с вами докажем, это доказательство слева
направо этого факта. То есть мы говорим с вами следующее, что давайте мы у нас есть а стрелочка
и мы хотим показать, что у нас тогда есть тот самый вывод. Смотрите, будем делать следующую
вещь. Индукция по количеству эффективных шагов в алгоритме. То есть что такое эффективный шаг в
алгоритме. Это значит, что либо мы с вами делаем какую-то операцию scan, то есть у нас появляется
операция даже плюс первая, либо мы выполняем операцию добавления в дите нового элемента.
Да, в дите у нас элементы добавляются при помощи операции scan, ой, при помощи операции
предикт или при помощи операции complete. Давайте покажем базу этой индукции, чтобы было понятно.
База, значит я давайте буду адвансировать параметр t, это время. Значит что у нас происходит в
моменте времени t равное нулё. Какая ситуация у нас с вами уже есть в нулевой момент времени?
Да, у нас есть ситуация с вами. С, стрелька, точка, с, ноль принадлежная до ноль. Кажется да, давайте
посмотрим. Дальше мы с вами доказываем это. Вот, база индукции, да, вот такая вот. Ну,
давайте теперь посмотрим, что это означает. Нам нужно попытаться переложить это на этот язык.
Тогда у нас получается должна быть картинка такая, что из s штрих у нас выводится phi s штрих
psi. Хотим. Дальше за один шаг у нас раскрывается phi s psi. При этом скажите, вот если у нас
происходит вот такая вот штука, то phi чему равняется? Пустому слову. Да, phi равняется пустому
слову. Это v, можно так обозначать, двоеточие ноль. Да, и смотрите тут очень тонкий момент,
который хочется рассказать. На самом деле, давайте вот так обозначу его. Вот это в нашем случае
будет бета. Вот видите, а, стрелочка, альфа, точка, бета. А альфа равняется пустому слову.
Да, теперь мы собираем, что это такое. То есть это у нас тоже будет v от нуля до нулевого. В
итоге у нас получается, что из s штрих мы выводим phi s штрих psi. Нет, давайте лучше не так сделаем.
Я просто покажу. Значит, в лемме, что у нас с вами? phi выводится v ноль psi.
Существует phi, равное пустому слову, равное v ноль нулевому. А альфа тоже epsilon равно v ноль нулевому.
Вот, и у нас в итоге получается аналогичное дерево вывода. Только оно у нас будет с вами
выглядеть вот таким вот образом. s штрих v штрих v s. Ну, мы так можем вывести, но на самом деле мы
можем сделать эту штуку такой, что из s штрих мы выводим с вами, внимание, тут сейчас может
взорваться немножко мозг. epsilon s штрих. Тут epsilon, здесь у нас выводится epsilon epsilon s epsilon.
И в нашем случае вот это у нас альфа, а вот это у нас phi. Да, и в итоге у нас все идет с голосованием.
Вот это у нас с вами v нулевый, а вот это v zhi.
Понятно ли это? Если непонятно, вопрос задавайте.
Да, тут надо тонко расписать. Значит, теперь давайте будем делать с вами переход.
Переходы сделаем. Три варианта нам надо разобраться. Как у нас появилась ситуация?
Значит, у нас а стрелочка альфа точка b и t принадлежит дюжитам могло появиться тремя способами.
Первое это скан, второе это при помощи операции predict и третье при
помощи операции complete. Поехали разбирать эти три случая. Значит, первый случай это операция scan.
Тогда смотрите, что мы с вами можем сказать. Тогда мы говорим, что альфа это у нас некоторое
альфа штрих умножено символ а. Да, потому что мы эту штуку должны были продвинуть. При этом у нас получается
следующее было. Альфа, точнее нет, из а выводилась а штрих точка, сейчас, не выводилась только, у нас была
ситуация а штрих точка а бета и принадлежит джип минус один. Ну, потому что мы должны были
получить с вами правила а стрелочка альфа точка бета и принадлежит джип. Тогда по предположению индукции
мы получаем с вами следующую вещь. Из а штрих мы выводили в точка и, а, си, некоторое. Дальше мы за один шаг с вами
выводили в и джи, точнее в доитого символа, а штрих, а бета, си. При этом а штрих у нас выводят символы слова
с индекса и по джи минус один. Это все чисто из предположений индукции, у нас с вами выполняется.
Да, тогда, что мы с вами можем сделать? Из этого мы можем сказать, что а. Вот, давайте я еще тут
напишу, что в джи тогда равняется а. В джи минус первое равняется а. Тогда из а штрих а у нас выводится символ
уже с итого до джитого. Ну, а это то же самое, что из а у нас выводится в и т джи. Да, и что у нас
получается? У нас получается с вами, давайте я сейчас буду подчеркивать важные факты. У нас есть вот эта вот штука,
да, и у нас есть вот эта штука, а вот эта штука у нас и так или иначе тоже равняется в, так давайте не буду громоздить.
Давайте вот тут напишу, что за ноль символов и обведу вот эту штуку. Ну, за ноль, потому что мы это ровно то
же самое. За ноль раз мы выводим в и т а бета си. То есть таким образом мы с вами вариант доказываем.
Да, вот он. Давайте я буду вот, чтобы он у нас висел, вот он. То есть как раз у нас получается в джито а бета си раскрывается,
из а выводится от итого до джитого, а из фи у нас выводится от нулевого до итого. Ну, значит,
предположение переход доказан для сканов. Извините, вы не могли бы строчку написать как из леммы? Это не очень понятно сейчас.
А давайте тогда это, да, это то же самое, что фи альфа бе альфа бе си. Вот так. А какую строчку?
Ну, которую нам нужно доказать, вот которая внизу леммы. А, ну, а, хорошо. Да, ну, мы получаем ш-трих, выводится фи а си,
это выводится в нулевое и, а си, а вот это у нас выводится как раз фи альфа бе си. Но при этом это у нас от итого до джитого, да,
вот это у нас от нулевого до итого. Вот они как раз у нас тут вылетают, что из альфы у нас выводится бе и житое,
но а фи оно и так и было. Си у нас так выводился из нулевого до итого. Вот. Это скан. Если непонятно, задавайте вопросы.
Давайте дальше тогда двигаться. Давайте двинемся с операцией предикт, разберемся.
Итак, операция предикт. У нас появилось вот такое вот свойство. У нас с вами а стрелочка альфа точка бета и т принадлежащая джитому.
Что из этого мы с вами можем сразу сказать? Альфа заканчивается на не терминал. Больше даже мы про альфу можем что-то сказать.
Замечу, что предикт, ну, можно перед этим не терминалом только были буквы и потом один не терминал.
Не, даже более того. Давайте напомним, что такое операция у нас с вами предикт. Вот. То есть у нас появляется вот такое правило такого вида.
Я даже больше скажу. Мы можем точно указать, чем уравняется альфа в данном случае.
Смотрите, да. Пустое слово. Ну да, альфа пустое слово. И при этом и равно g. Вот это мы точно можем знать.
Но при этом смотрите. Существовало, это важно. Какое-то k. И существовала k и ситуация вида, давайте я напишем как-нибудь так.
B. Стрелочка гамма точка альфа дельта k, принадлежащая дежитому. Ну, потому что при помощи него мы с вами смогли вывести этот альфа стрелочка точка бета.
Да, на самом деле вот из этого мы можем написать, что это штука более простая, что это из альфы у нас выводится точка бета g, принадлежащая дежитому.
Вот. То есть применяя вот эту вещь и вот эту вещь, и правило a стрелочка бета, в грамотике мы получаем такую вещь.
Тогда смотрите, по предположению индукции, мы получаем, что из s штрих выводится v от 0 до k. Bb. Заметьте, что у нас тут k.
И из b за один раз мы раскрываем с вами v 0 ката гамма альфа дельта. Причем из гаммы выводится у нас с вами слово от ката в дежитово.
Теперь продолжаем. Раскроем еще один раз эту вещь.
Тут мы не будем с вами говорить, что у нас с вами левосторонний вывод, а попытаемся раскрыть, не, не будем говорить.
Давайте раскроем все терминалы гамма.
Тогда у нас получается с вами, смотрите что, у нас получается v 0 к, v k g, a дельта. Мы их должны раскрыть, потому что у нас вывод левосторонний.
И дальше за одно правило грамматики мы теперь можем с вами раскрыть a.
Мы получаем v 0 g. Давайте я поставлю сюда эпсилон, бета и дельта.
Вот так напоминаю, что у нас с вами альфа.
А большое раскрылось по правилам a, b. У нас a, b правила грамматики.
Ну и что мы с вами получаем?
Мы из этого получаем, что из альфы выводится v gt gt.
А вот эта вот штука, это как раз у нас говорит маркер символа g.
Давайте еще раз посуммирую, что мы хотим.
Мы хотели следующий факт, что если у нас из а выводится точка бета gt принадлежит для gt, то существует такой вывод.
Из s-трих мы выводим v 0 gt a psi, а здесь выводится для некоторого psi.
А здесь у нас получается выводится v 0 gt beta psi.
Ну вроде получилось то, что мы хотели.
Да, вот он, v 0 gt, эпсилон, здесь все, здесь psi.
То есть эту штуку мы тоже с вами показали.
То есть тут, смотрите, идея какая.
Мы просто берем, аккуратненько перекладываем то, что получается после каждого шага алгоритма.
Так.
Давайте комплеты, да.
Да, мне можно просто...
Давай.
Что нужно было доказать?
Там было три штопора.
Да, да, да, мы только, смотри, давай сразу скажем тогда.
Да, тут три штопора.
Да, я просто один из них по факту не нужен.
То есть мы можем вот этот штопор нафиг выкинуть.
Да, понятно.
Вот, ну вот.
Хорошо.
Давайте к комплету двигаться.
Значит, третье.
У нас появилась а, стрелочка, альфа, точка, бета.
Бета и принадлежит dg после комплит.
Тогда утверждается, что альфа, альфа равно альфа штрих на некоторые бета.
Да, потому что мы должны были вывести.
И...
При этом...
Что у нас было?
Тут очень важно.
Значит, смотрите, у нас получается а,
стрелочка, альфа,
штрих, точка,
b,
бета,
принадлежала dcat для некоторого к.
А из бета у нас выводилась некоторая гамма, точка,
ката и принадлежащая dg тому.
Опять же, давайте покажу операцию комплит,
чтобы она была...
Вот.
Вот она.
Видите?
Чтобы вот эту точку передвинуть,
которая у нас здесь появляется,
нам нужно как раз снизу вверх подняться.
Поднимаемся здесь по символука,
получаем вот такое вот соотношение.
А теперь нам надо все аккуратненько расписать.
Значит, смотрите, что мы хотим?
Мы хотим
показать следующее, что у нас
из штрих
выводится
v0i
a
psi
и из этой штуки у нас выводится
с вами
v0i
альфа
бета
psi. А вот из этой штуки выводится
v от этого дожитого.
Ну, поехали смотреть.
Что мы можем написать по предположению индукции?
Сначала напишем,
значит,
что у нас из штрих
выводится...
Пишем для вот этой вот штуки.
Давайте ее подчеркну.
Из штрих у нас выводится, значит,
phi...
Ой, не phi, давайте...
Позицию у нас v0i
альфа
бета
и из этой штуки
выводится
v0i
Потом у нас выводится
с вами
a
и выводится некоторое
psi, которое за один шаг
у нас раскрывается v0i
альфа штрих
бета
b psi. Я специально
пишу зеленым цветом, чтобы было понятно,
что у нас вот этот пыль. При этом
альфа штрих выводит
v от итого
до катого.
Теперь
мы смотрите, что с вами пишем.
Потом у нас идет...
Пусть это будет у нас с вами фиолетовый
цвет.
Раскрываем вот эту вот вещь.
Здесь
опять же раскрываем все альфы
штрих.
Раскрываем альфа
штрих.
Получаем,
что
здесь у нас v0i
здесь у нас получается
альфа штрих раскрывается v и k
бета
b phi
штрих. И дальше
за один шаг, используя правило
как раз которое у нас подсвечено фиолетовым,
мы получаем, что у нас
v0i
точнее v0k
Здесь у нас
получается с вами
гамма
бета-пси
Да, из предположения индукции
у нас получается,
что из гаммы у нас выводится
v
k
g
Давайте теперь собирать все детально,
потому что тут уже тонкая материя.
Вот смотрите, вот это у нас есть
из v0i
и apsi
Дальше мы раскрываем
и хотим понять
что из альфа штрих
у нас выводится
v и gt
Почему
альфа выводит
v и gt
Давайте отвечать
Смотрите, альфа
у нас это что?
Это у нас альфа штрих b
А что такое
альфа штрих b?
Из бета
у нас выводится гамма
альфа штрих гамма
Из альфы у нас выводится
и kt
А из гаммы у нас выводится
kgt
Мы получаем,
что это v и gt
Вроде получили
то, что хотели
Тут двойной переход индукции
после которого
мы заклепаем
то, что хотим
По идее
мы доказали с вами
переход в одну сторону
доказав подположение
по индукции
Я вас не кокну?
Нет
Ну хорошо
Это формальная индукция
просто ее нужно переварить
и воспринять
Так
Ну товарищи, теперь начинается
самая сложная вещь
доказать в обратную сторону
Давайте я
выпишу еще раз, что мы доказываем
Мы хотим доказать
что если у нас
есть такое
есть такое дерево вывода
v0i
a
psi
при этом за один шаг у нас выводится
v0i
α, β, ψ
то
что мы хотим сказать
то
при этом скажем, что
альфа у нас выводится
в it
gt
то у нас
ситуация
из a выводится
альфа.b
и gt появится в алгоритме
Смотрите, тут индукция не тривиальная
и нам нужно ее с вами оговорить
Значит
обозначим количество шагов
вот это за g
пусть это k
а вот это за l
индукция
в этом случае
у нас есть
альфа
индукция
по k плюс l
то есть считаем
количество шагов, за которые
мы раскрываем все необходимые
значимые вещи, которые у нас есть
давайте базу проверим
k плюс l равняется нулю
из этого будет следовать, что k
равняется нулю, l равняется нулю
тогда
только тут s штрих у нас
тогда смотрите, что у нас получается
s штрих
выводится
s штрих, ну за ноль шагов можем вывести
s штрих
здесь у нас v ноль и
здесь у нас psi
из этого следует
внимательно если посмотреть
то i равняется нулю
а psi равняется епсилу
потом за один шаг
мы раскрываем
эту всю штуку как
альфа бета
нет, смотрите
за один шаг и за штрих
что мы можем раскрыть
мы из штрих можем раскрыть s
потому что у нас есть только из штрих
правило, что из штрих выводится s
то есть у нас получается с вами
смотрим
так, сейчас
давайте я вот так обозначу
epsilon s
ну мы можем обозначить
то, что находится перед этим
и смотрите, что у нас с вами получается
вот это в нашем случае пусть будет альфа
а вот эта штука
у нас будет
альфа
а вот эта штука
у нас будет
альфа
а вот эта штука
у нас будет бетой
поскольку у нас вывод левосторонний
то мы сначала должны обеспечить раскрытие альфа
так, давайте
более аккуратно напишу
вот так вот
выводится альфа бета за один шаг
при этом альфа
за ноль шагов
должна вывести слово какое-то
v и gt
а альфа бета
это s
мы это знаем
смотрите
из этого будет следовать
что альфа равно
epsilon
а b равно s
а b равно s
а b равно s
что мы хотим при этом?
мы хотим
чтобы правила
какое у нас было в грамматике
в ситуациях
давайте смотреть
из s'
вот s'
вот это наш а
который равен а
вот это наш а
который равен а
вот это наш а
который равен а
выводил
стрелочка
альфа
который у нас
epsilon
точка бета
сопитая
i, которая равняется нулю
вот это s
принадлежало джитому
которое нулю
то есть по сути мы с вами
говорим
что
что иначе говоря
мы хотим чтобы из s'
точка s нулевое
принадлежит до нулю появилось
а извините это у нас старт
то есть из того
что мы вывели
от нуля до нуля
посмотрели что мы раскрываем
за ноль шагов
и дальше какой вывод у нас раскрывается за ноль шагов
мы получаем что это старт
то есть мы в старте
просто положили это множество до ноль
понятно ли база индукции
да
теперь переход
да важный
надо считать в количестве шагов
деревья грамматики сейчас мы будем делать
теперь смотрите переход индукции
я его тоже обозначил
надо посмотреть на последний символ альфа
итак смотрите пусть у нас
альфа равно альфа штриха
это первый вариант
тогда мы должны получить операцию ска
давайте смотреть
как мы это с вами будем получать
у нас получается
изо штрих
выводится
я буду так писать
за к шагов
в ноль и
а
и
дальше у нас
за один шаг
раскрывается
альфа штрих
а
бета
бета
и потом
у нас с вами
тут очень аккуратно
альфа
за л шагов
выводят
в и
ж
вопрос
альфа штрих
за какое количество шагов выводят какое слово
а как
альфы связаны
а
у нас есть правила грамматики
а стрелочка альфа б принадлежит
правилам грамматики
мы раскрываем его
вот он
мы пишем что
вот оно
из а за один шаг мы альфа бета раскрываем
смотрите
я утверждаю что нам
требуется на одно правило меньше
в
и
символ на один меньше
ну потому что нам не нужно
последнюю букву раскрывать
или подождите
или тоже за
сейчас давайте подумаем
за
л или за л минус один шаг
вроде за л
да тоже за л
да
тоже за л шагов у нас
выводится в и ж
минус один
и тогда
что у нас получается
давайте склепывать
эту всю вещь
возможно надо уточнить
индукционный переход
получается
вообще хочется сказать
хочется
что
из предположений индукции
мы можем сказать
что у нас было правило
а стрелочка альфа точка
а бета
и принадлежит
д ж т минус один
хочется сказать что у нас
будет такое
а
давайте сейчас сообразим
А когда это у нас, когда вот такую штуку мы можем получать из предположения дедукции?
Немножко дедуктивный метод.
Получается, что у нас с вами из z штрих выводится v0e g, v0e i, a, psi.
Дальше за один шаг у нас выводится v0e α' a, beta, psi.
А из α' у нас выводится v и g-1.
Мы знаем, что вот эта штука за k шагов выводится, а вот эта штука за l шагов выводится.
Смотрите, тут количество шагов то же самое получается.
Да, то есть тут шагов k, а здесь шагов l.
Давайте вот этот момент пока оставим.
Вот, если у нас база индукции сойдется, то окей.
То есть пока что оставим этот момент, чтобы у нас он был каким-то вот таким тонким местом.
Если что, я потом расскажу, как его доводить.
Второй случай, который у нас есть, это α'a.
Давайте пусть это будет α'b, потому что это некрасиво.
Значит, смотрите, α'b.
Тогда смотрите, что у нас с вами происходит.
У нас из s выводится за k шагов v0i, a, psi.
А здесь у нас с вами за 1 шаг выводится α'b, psi.
И дальше у нас с вами из α'b должно вывести слово отитого дожитого элемента.
Да?
Ну, значит, существует гамма, причем это за l шагов.
Такое, что из α' у нас выводится слово отитого докатого.
Давайте за m шагов.
А из β за n шагов у нас выводится слово откатого дожитого.
Причем, что важно сказать, что m плюс n равно l.
То есть у нас здесь выводится vитkt, а здесь у нас выводится vktjt.
А почему существует такое гамма?
Это из индукции или из чего-то другого?
Смотри, да, спасибо.
Значит, мы бета, я оговорка по Фрейду.
Смотри, давай вот так напишем.
Это вообще не из предположений индукции даже, а больше следует из того, что мы бета как-то раскрыть должны были.
То есть за 1 шаг мы раскрываем гамму.
И за, получается, n минус 1 шаг мы из этой гаммы получаем vktjt.
То есть вот это у нас за 1 шаг гамма.
А здесь у нас vktjt за n минус 1 шаг.
Тогда тут надо очень-очень аккуратно.
Смотрите, что у нас получается.
У нас получается, что, давайте считать количество шагов.
Из s штрих выводится, давайте посчитаем, за какое количество шагов у нас выводится слово v и t.
v0kt, kt, b, c.
Смотрите, вот эту штуку мы вводим за k шагов, вот эту штуку за 1 шаг, а вот эту за штуку за m шагов.
Поэтому здесь мы за k плюс m плюс 1 шаг выводим вот это соотношение.
При этом дальше за 1 шаг мы выводим с вами из беты гаммы.
А дальше за n минус 1 шагов мы выводим с вами v0k, vkj, γс.
Опять же смотрите, сумма шагов здесь такая же, но важно, давайте подчеркнем.
Вот я тут хочу подчеркнуть очень важный момент.
Сначала индукцию давайте сделаем по l, а потом по l и по l плюс k.
То есть если у нас шагов вывода из альфы меньше, то мы делаем предположение индукции.
Если они равны, то выполняем по сумме k плюс l.
А смотрите, что у нас получается. У нас количество шагов становится меньше, чем здесь.
А сумма при этом одинаковая.
То есть здесь у нас было k плюс m плюс n, и здесь у нас k плюс m плюс n.
И смотрите, что из этого мы получаем.
Из этого мы получаем, что у нас есть бета, стрелочка, гамма точка.
Так, сейчас давайте сообразим.
Значит у родительского ката у нашего gtk принадлежит джитому по предположению индукции.
Вот, так как n минус 1 точно меньше, чем l.
Ну, здесь мы требовали l шагов, тут n минус 1.
А теперь хочется сказать, почему еще...
Давайте посмотрим на следующую вещь.
А, стрелочка, альфа точка, б, бета и принадлежит декатому.
Почему это так?
Так как альфа штрих только.
Почему это так?
Потому что, значит, префикс мы выводим за k шагов, альфа штрих мы выводим за m шагов.
И выводится за k шагов, альфа штрих v и k.
За...
На сколько?
За m шагов.
Ну, тут как угодно можно сделать.
Давайте скажем, что m меньше, чем l.
Алло, вы меня слышите?
Да, слышим, слышим.
Доска повисла.
В общем, смотрите, идея какая.
Вот эта штука выводится за k шагов, эта штука за m шагов выводится.
И в итоге m плюс k меньше, чем k плюс l.
Из этого будет делать переход.
А дальше...
А вот если у нас такое есть правило, есть такое правило, то по комплиту мы с вами получаем исходное правило.
Ох ты...
Ох ты пёс.
Можно пока спросить?
Да.
У нас там был переход, когда мы из s штрихов выводили полностью слово.
У нас там было сначала k плюс m плюс 1, потом еще 1, и потом n минус 1.
Да.
На ком сумме получается k плюс m плюс n плюс 1.
Нет, там k плюс m плюс n получается.
Там мы 1 не считаем средний.
Никогда его не считаем.
Там индукция по суммарному количеству выводов из альфы в эту, и из z штриха в эту.
Да, то есть вот эту единичку среднюю мы не считаем.
Сейчас можете сказать, почему?
Потому что, к сожалению, экран отлетел.
Мы говорим, что количество шагов здесь такое и здесь такое.
Здесь мы получаем k плюс m плюс 1.
А здесь n минус 1.
В сумме k плюс m плюс n получается.
И поскольку здесь n минус 1 меньше, чем l заведомо, то мы...
Классно.
На самом деле давайте я сейчас тогда раз зависла.
В предикте ровно то же самое.
Давайте идею расскажу.
В общем, мы смотрим, когда у нас альфа это эпсилон, то есть никакой символ у нас не появляется,
нам нужно подняться наверх, посмотреть, как это чудо-юдо родное могло у нас появиться.
И дальше, сделав индукционный переход, сделать операцию предикт.
Там количество шагов будет меньше.
На единичку.
А вот как починить операцию scan, там нужно, наверное, будет сказать что-то в духе следующего.
Давайте еще посмотрим.
Там третий параметр в индукции ввести для того, чтобы это вычислялось по сумме подлинения терминала вот этого правила альфы.
Потому что там у нас как раз проблема возникла с тем, что у нас суммарное количество в грамматике.
Давайте я сейчас еще тогда буквально пару минут займу у вас.
Доказательство мы добьем в следующий раз, более точно.
Теперь смотрите.
Давайте быстренько оценим сложность алгоритма.
Пусть у нас суммарное количество правил в грамматике P.
Это суммарная длина всех правил в грамматике P.
Давайте оценим количество операции scan, предикт и конклит, которые у нас выполняются.
Смотрите, первое.
Давайте мы будем хранить дожитое в виде всех возможных ситуаций, причем будем хранить его таким вот образом.
То есть если у нас есть ситуация, а стрелочка альфа, точка х, бета и т, принадлежащая дожитое,
то мы будем хранить его в некотором множестве, которое состоит дожитое и х,
для того чтобы быстро посмотреть то, что у нас находится справа после точки.
Да, это можно сделать.
При этом мощность множества g мы можем посчитать как g плюс один умножить на количество правил в грамматике.
Потому что точку мы можем поставить в любое место, во всех правилах.
А i у нас не больше, чем g.
Поэтому у нас i прибегает значение от нуля до g.
Их g плюс один.
Теперь смотрите, что нам нужно для того, чтобы ощутить скан.
Нам нужно пройтись по всем правилам в дожитом и символе a.
И сдвинуть точку.
Это делается за o от модуль g, можно здесь написать даже количество правил в грамматике.
Предикт.
Значит, что у нас с вами в предикте получается?
Давайте подумаем.
Значит, нам нужно в дожитом пробежаться по всем множествам, которые здесь b.
То есть дожитое не терминал.
По всем пробежаться добавить новые правила.
Это будет сверху o от модуль дожитого.
А переходы мы же должны тоже перебирать, нет?
Какие? А, правила грамматики?
Или мы только самые левые используем?
Нет, мы должны перебирать их все.
Сейчас скажу, почему это так получается.
Там более тонкая настройка.
Там все равно получается o от модуль дожитого.
Значит, нам нужно пробежаться по всем правилам грамматики.
Это o от модуль g.
И по всем дожитое беты.
Тут, возможно, квадрат возникнет.
Но сразу скажи, что модуль g это константа.
Поэтому здесь все равно в сумме o длины слова получается.
То есть тут точная оценка будет o от модуль g умножить на модуль дожитого.
Но опять же, нам нужно просто посмотреть.
И третий комплит тут сложнее.
Значит, смотрите.
Что нам нужно?
Нам нужно пробежаться по всем правилам дожитого доллара.
Доллар это символ конца строки.
И по всем правилам дожитого бета.
Где b стрелочка точка гамма и принадлежит дожить.
То есть относительно это верхнее правило в комплите.
А вот это нижнее правило в комплите.
Да, и тут надо посчитать аккуратно.
Значит, смотрите.
Вот этих у нас правил будет o от модуля гамма.
Вот этих o от дит.
Ну, там сумма по всем i.
Не больше, чем g.
Здесь будет o от модуля гамма умножить на o от модуля v.
Значит, смотрите, как это получается.
o от модуля v это переход, еще перебор всех i.
А o от модуля гамма это все правила, которые заткнулись и здесь.
Вот, получаем, что это o от модуля дит на модуль g на модуль v.
Получаем o от модуля g в квадрате на модуль v в квадрате.
Вот, ну и в итоге смотрите, что получается.
Нам эту всю штуку еще нужно домножить на длину слова дубль v.
Потому что на самом деле мы рассуждали для определенного дожитого.
В итоге получаем, что сложность у нас кубическая от длины слова.
Но на самом деле, если посудить так, то тут можно доказать следующий факт,
что если грамматика является однозначной,
то именно вот такая версия алгоритма при более точной оценке будет давать квадратичную сложность.
То есть по факту алгоритм Эрли работает сильно быстрее, чем алгоритм Кока Янгера Касами.
Вот, но утверждение состоит в том, что можно делать линейный алгоритм парсинга.
Вот, и к линейным алгоритмам парсинга мы с вами переберемся уже в следующий раз.
К сожалению, доска нам не позволила довести доказательства.
Вот, давай, о.
А можно вопрос, а вот однозначная грамматика, это что?
Это для любого слова есть романтическая грамматика.
Извините, что я задержал вас.
Наша цель будет доказать это утверждение.
Тут вообще остался предикт.
Вот.
Ну и довести какие-то тонкие моменты.
В следующий раз мы уже с вами будем говорить про линейный алгоритм парсинга.
Вот.
Вот.
Ну и довести какие-то тонкие моменты.
В следующий раз мы уже с вами будем говорить про так называемый LR алгоритм.
Морально запасайтесь терпением.
Но я постараюсь его рассказать проще, чем классическим подходом он рассказывается.
Значит, те, кто хочет следующую лекцию смотреть, посмотрите как это.
Как делается детерминизация автоматов.
Это нам поможет.
Все, извините, давайте задавайте вопросы.
Видимо нет вопросов.
Да, надо осознать, задавайте вопросы.
В общем, можно в чате задавать по вопросам.
Ссылку на доску оставляю, ее можно комментировать.
Ох, мы идем.
Значит, ютубу спасибо.
