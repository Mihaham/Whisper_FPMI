Объясню, а вроде бы да, с одной стороны вы их прошли, но вы знаете слово контейнер? Нет, ну типа официально нет, давайте так, тот кто официально да, ой, тот кто да, вы молодцы, я очень за вас рад, но это не означает, что это да, и вы не знаете прям может быть всех тонкостей контейнеров, как только вы их пройдете, пожалуйста.
Вам о них рассказали на плюсах? Вы написали свои стринги? Си-стринг и стринг-вью это разные вещи, как только вы доходите до того момента, когда вы это написали, то в принципе после этого вы можете это использовать.
Пока нет, зачем оно вам? В смысле, у вас там нет таких задач, которых типа вы без стрингов не выживете.
Библиотеку си-стринг можно, ну то есть там типа кмп-кмп, вот это вот восхитительный стыр-стыр, вот это вот все, можете использовать, пожалуйста, я не против.
Ну то есть вот такие вещи, ок, но опять же типа если вы мне попытаетесь STD-сорт запихнуть в задачу сортировки, я скажу нет, и любой ассистент вам скажет нет.
Что если попытаешься? Напиши ты лист. Еще раз, ты вот это все прошел, ты хоть раз это написал?
Еще раз, то, что ты прошел, ты хоть раз написал? Ты вектор прошел? На лекцию? По-моему нет.
Ну так, и если ты считаешь, что ты прошел вектор, хорошо, ты можешь подойти ко мне после, я вот тебе задам миллиард вопросов про вектор.
Вот ответишь мне по каким схемам он работает, почему за столько, почему именно так, как это происходит, вот.
Тогда я пойму, ты знаешь хотя бы векторы или нет. Если знаешь, впихнешь свой класс вектора типа в задачу, используй его.
Ты же его прошел, значит ты написал. Еще есть вопрос.
Смотрите, объясню, вы знаете как работает STD-своп? Как? Нет, никогда в жизни, ну то есть нет, да, но нет.
Вы мув-семантику знаете? Нет, вы таких слов еще не слышали.
Мув-семантика это то, что типа используется в STD-свопе, потому что тот своп, который мы с вами рассматривали, не является каноничным и не является правильным.
В принципе, вы можете использовать STD-своп, предполагая, что он работает вот именно таким вот образом.
Ну еще раз, хотя бы в одной задаче реализуйте его, ну типа блин, вы серьезно что ли, не можете эти четыре строчки написать?
Ну друзья, ну пять ладно, извините. Объявление, три переменных и скобочка, да, в конце, пять.
Шаблонный напишите, это вообще нормальная тема, тогда вас ко всему подойдет. Тогда шесть.
То есть друзья, еще раз, я повторюсь, типа, когда вы считаете, что вы что-то знаете, не будьте уверены в этом, потому что даже я не всегда уверен в том, что я что-то знаю.
Вот, типа не знаю, мне когда-то говорили, типа вот человек, который ничего не знает, он всегда уверен, что он прав, потому что вокруг него очень маленький орел того, что он не знает.
Чем больше вы узнаете, тем больше вы понимаете, что вообще ничего не понятно. Это нормально.
Но опять же, типа, мой вам посыл, реализуйте, типа, господи, ну реально, четыре строчки, ну вы серьезно, мы за них торговаться будем.
Еще скажите, что вам обязательно нужна функция минимума, потому что вы тернартником пользоваться не умеете, строчку тоже написать.
Ну реально.
Хорошо. Ну еще раз, типа, ты можешь объяснить ассистенту, что ты не знаешь, как работает СТДСВОП.
Но как СВОП написать, типа, обычно, ну, во всяком случае, когда я проверял задачи, я просил, типа, либо мне объяснить, либо хотя бы в одной поменять.
И все.
Просто показать, что ты понимаешь, как это выглядит.
Хорошо. Давайте еще раз, типа, нет, важный момент, если мы говорим про СТДСВОП, то да, я понимаю, но если мы говорим про СТДСОРТ, то нет, это означает везде бан.
Окей?
Господи.
Как же вам с ним сложно-то?
Хорошо.
Что-то есть с пожеланиями.
Мне прям страшно, но ваши ряды все равно редиуют.
Я вам скажу так.
Можно.
Скоро.
Зачем?
У вас был перерыв в самом начале?
Ну, у вас был там колок, мы все понимаем, поэтому не трогали вас.
Смотрите, нет, еще раз, с контестами дела обстоят следующим образом.
Да, они у вас будут идти чуть ли не бесперерывно.
Потому что самое лучшее, как вас попросить что-то делать, это всегда что-то попробовать.
Вас по-другому не попросить.
Потому что вы скажете, блин, у меня матан, блин, у меня физика, надо скатать или ее сделать.
Вот это мне тоже нужно с этим что-то сделать, как-то жить.
Потом у меня еще начинаются какие-нибудь новые вещи.
И вы скажете, ну а зачем?
Если я питон выучу, то зачем мне вообще плюсы?
Скажете, вы мне, и я с вами не соглашусь.
Но вы так подумайте, если у вас не будет какого-то конкретного дедлайна.
Давайте уж честными будем друг с другом.
Я представляю, как работает дедлайн.
И когда вам говорят, что у вас три недели, вы такие, классно, две недели ничего не делаю,
но последние ничего не досделаю.
Я не встречал людей, которые начинают сразу же что-то делать.
Если они существуют среди вас, я бедмерно за вас рад.
Я таких не знаю в своем окружении.
У меня не получалось так тоже у самого.
Потому что у тебя до этого дедлайна будут какие-то другие дедлайны, которые тоже нужно закрыть обязательно.
Вот они вот так вот идут друг за дружкой, вот ты пытаешься от одного к другому прийти.
Еще раз, вам засчитывают задачу с каким-то баллом.
С каким-то баллом всегда.
Кроме того, что когда вы используете стд-сорт, вам ноль за него, сразу же поставите, друзья.
Но если вам сказали, что вот этот косяк, вот этот косяк, вот этот косяк, вот этот косяк,
ну типа sorry, у тебя получается 0,6 за задачу, то у тебя 0,6 коэффициент за эту задачу.
И потом ты можешь еще переделать и как-то ее апгрейднуть.
Ну вот еще раз, типа вам пишут, что у вас вот так косяки, ты можешь с этим что-то сделать.
Еще раз, у вас когда проверили, вам обычно дается неделя.
Поговорите в группе, господи, спросите, почему вот вы так это...
Смотрите, вы говорите семинаристу ассистенту, типа пожалуйста, вот типа если у меня такое происходит,
я могу передать? Чаще всего мы говорим да.
Но злоупотреблять этим тоже, типа очень-очень глупо.
Максимум один раз, пожалейте ассистентов тоже.
Им читать код, а потом плакать, типа давайте это, чуть-чуть сбавим обороты.
Еще есть вопрос?
Нет.
Давайте о ВЛ-дерево.
Отлично, 15 минут поговорили обо всем, надеюсь теперь все стало понятнее.
Сталось, чтобы вам понятно было, что такое ВЛ-дерево.
Смотрите, на всякий случай напомню про бинарное дерево поиска.
Бинарным деревом поиска что у нас называлось?
Это некоторая структура данных, которая работает с упорядочными по сути множествами.
Мы брали за множество числа некоторые, которые могли сравнивать.
Можно сравнить все что угодно между собой.
Хоть строчки, типа сравнивайте, не знаю, по какому-нибудь,
стройте по ней хэш-функцию для тех, кто знает такие слова тоже.
Ну или просто по количеству символов.
Всегда можно делать по-разному.
В бинарном дереве слева все меньше, справа все больше, правильно?
Помните такое.
Для облегчения жизни я считаю, что в бинарном дереве у нас нет никаких повторяющихся элементов.
В чем проблема, на чем мы с вами остановились бинарным деревом поиска?
Что не так?
Работает с высоту и чего?
Да, то есть смотрите, существуют некоторые проблемы,
когда у нас будет высота дерева равна просто количеству элементов.
Это не круто, это ничем не помогает, это очень похоже на лист.
Работает все за ОАТН, что поиск, что еще что-то.
Ты там контест делаешь, я не понимаю.
Понимаете, так делать не надо.
В этом начинаются как раз-таки проблемы с тем, что у нас вообще происходит.
Потому что если у нас что-то работает за ОАТН, это нехорошо с точки зрения бинарного дерева поиска.
Потому что, я думаю, вы еще с Бинпоиска помните, что отлично, когда что-то работает за логарифом.
Чудесно, восхитительно.
И хотелось бы попробовать это сделать.
И мы хотим сделать так, построить как-то наше дерево таким образом, чтобы вставка элементов,
удаление элементов, поиск элементов был за логарифом.
Здесь есть такое слово, возможно, амортизационно, воспринимайте пока это слово как в среднем.
Мы с вами рассмотрим, что такое амортизационно, попозже, на следующей лекции.
У нас будет лекция про амортизационный анализ.
Примерами вообще таких деревьев, на самом деле их множество.
Здесь вот просто некоторые из них прописаны.
Авель дерево, правда, всегда работает за логарифом.
Даже не амортизационно, вот просто работает за логарифом.
Красно-черное работает за логарифом.
Вот декартовое дерево с рандомными какими-то ключами и сплей дерева будет работать амортизационно в среднем за логарифом.
То есть не всегда, но в среднем оно будет вот примерно такое.
Встают еще различные версии красно-черного дерева, а-а дерево оттуда.
Встают а-би дерево и так далее.
И по названию миллион.
Мы рассмотрим какие-то основные и интересные для нас случаи.
И первый случай для нас – авель дерева.
Как вообще можно сбалансировать дерево?
Давайте зададимся таким вопросом.
Найти часть, которая является бамбуком и перерисовать.
Вопрос.
В момент построения дерева, что мы можем с ним такого сделать для того, чтобы этого не было?
Чтобы бамбука в принципе не было?
Мы вставляем по итеративно элементы.
Мы не можем медиану взять.
Еще есть идея?
Ну давайте.
Ну смотрите.
А что для меня балансировка дерева?
Части между собой равны, правда, по высоте?
Если они равны по высоте, то я пытаюсь как-то с ними что-то сделать, правда?
Ну вот мы будем пытаться сделать так, чтобы мы это балансировали.
Вообще первым приближением авель дерева можно назвать следующее.
Мы будем требовать то, чтобы высота левого и правого по дереву была одинакова.
Но это проблемная вещь, потому что что делать, если вот четное число?
И мы добавим еще один элементик.
У нас начинается проблема, разница какая-то появляется, правда?
Непонятно, куда лучше вставить в этом случае.
И авель дерева немного работает по-другому.
Оно названо здесь в двух советских ученых.
Я обычно не останавливаюсь на том, кто придумал что.
Но здесь важно знать, важно знать свои корни.
А в общем-то авель дерева действительно было придумано еще в советские времена.
И особенностью авель дерева и в принципе сбалансировано в смысле авель дерева
является следующее правило, что для любого узла дерева
высота его правого по дереву и левого по дереву отличается не более чем на единицу.
Ну то есть по модулю.
То есть может быть и правое чуть побольше, левое чуть побольше и так далее.
Побольше именно в плане высоты, не количестве элементов.
Я думаю вы это прекрасно понимаете.
И вот это выполняться должно для каждого узла.
Вот это характеристика авель дерева.
Вот это является сбалансированностью в смысле авель дерева.
Важный момент, сбалансированность бывает в разных смыслах.
Мы остановимся с вами еще на пары деревьев и вы поймете, что там другое вообще происходит.
Вот.
Поэтому да, с точки зрения авель дерева оно вот именно такая вот балансировка.
Пока понятно?
Что?
Хорошо. Пусть будет так.
Да.
Для каждого узла сумма разницы левого и правого по дереву высот.
Именно не более чем единица.
Для каждого узла.
Для каждого узла левое и правое по дереву.
Пока никаких детей и родителей.
Чуть попозже, скоро они появятся.
Смотрите, как из бинарным деревом поиска.
Мы начнем от обратного.
Мы не будем сначала смотреть, как нам вообще что сделать с деревом и так далее.
Мы ведем некоторые понятия, которые нам будут необходимы для балансировки.
А для того, чтобы каждый раз мы могли сказать, что дерево действительно сбалансировано.
Действительно его высота такая-то.
И как-то с ней балансировать.
На всякий случай я скажу.
Давайте отвлекитесь сейчас от своих нотов почти все.
Потому что я специально пишу код на плюсах для того, чтобы вам было проще потом в жизни.
В отличие от бинарного дерева поиска.
А оно достаточно простое.
Это раз.
Это раз.
Это раз.
Это раз.
А оно достаточно простое.
Это раз.
Во-вторых, контесты вы порешайте успеть.
И поговорить с кем-нибудь в телеге или в ВК тоже.
Так вот.
Для начала мы остановимся все так же на структуре узла.
Узла, что будет вообще храниться здесь.
Здесь мне в принципе не будут нужны перронты.
То есть я откажусь от них.
Мне они особо-то не нужны.
Я буду как-нибудь это по-другому вычислять.
Вот мы специально на этом сегодня остановимся.
Кроме того, большинство функций сегодня будут написаны рекурсивно.
Мы с вами писали их итеративно на прошлой лекции.
Сейчас посмотрим рекурсию.
В принципе, сильной разницы не будет.
А будет все плюс-минус понятное, думаю, для вас.
Так вот, что хранится в этой ноде?
В этой ноде хранится сам ключ.
Высота самого поддерева с корнем в этом узле.
Я буду ее поддерживать.
Корректный. Всегда.
Ссылка на левого ребенка, ссылка на правого ребенка и конструктор.
Я думаю, с конструктором вы теперь знакомы, правда?
Правда, здесь написано не через двоеточие.
Как должно быть и красиво должно быть сделано, а просто внутри.
Потому что я не знал, до какого именно части вы дойдете конструкторов.
Может, вы сегодня их просто чуть-чуть бы затронули.
Поэтому я написал так.
Вот у нас есть такая структура ноды.
Есть ли к ней вопросы пока?
Нету. Понятно, что в ней хранится.
Вот до этого сейчас дойдем.
Но, на самом деле, с точки зрения высоты.
Что такое высота?
Если мы рассмотрим это в некоторой такой рекурсии.
Вот на данном этапе высота узла.
Чему она равна, если я знаю высоту левого и высоту правого поддерева?
Высота левого или высота правого плюс один.
В зависимости от того, что из них больше.
Вот именно так мы и будем фиксировать, на самом деле, эту высоту.
Для начала я напишу функцию.
Можно.
А?
Выложу, выложу.
Презентацию выложу.
Даже записывают.
Все, смотрите.
Чудесно.
А в этот раз у вас все будет.
Так вот.
Простейшая функция высоты.
Для чего я делаю функцию высоты?
Ну потому что я просто буду проверять,
вообще эта нода существует или нет.
Она не на lptr или на lptr.
Мне это нужно будет с точки зрения дальнейшей такой архитектуры кода.
Это достаточно просто.
Я не буду в этом делать.
Я не буду в этом делать.
Но я буду в этом делать.
Я буду в этом делать.
длиннейшей такой архитектуры кода, это достаточно просто и понятно. Вы могли
возвращать здесь просто высоту, но у NALPTR вершинки не существует такого
понятия, как высота, потому что вы не можете ее разыменовать NALPTR.
Окей? Поэтому я делаю это именно в таком вот виде и смотрю на это все. Все же
понимают, что если P не NALPTR, тогда вернется высота иначе ноль. Вот то есть
вот эта P, это будет означать, что она либо NALPTR, либо не NALPTR. Просто так
легче написать кратко. Окей? Давайте, чуть-чуть синтаксиса языка. А?
Можно. Смотрите, вот когда вы, грубо говоря, с ИФами работали, давайте туда
кунемся. И вот если я пишу ИФХ, в каком случае будет выполняться ветка true, в
каком else? Когда не ноль, аналогично будет с указателями. Когда указатель не
нулевой, у вас будет ветка true. Аналогично для тернарного оператора. Если у вас
P не нулевой, тогда он вернет высоту узла. А? P это некоторый корень вот узла. Вот то
есть мы просто смотрим на узел и пытаемся понять, какая высота узла, если
корнем является P, для некоторого поддеревываю его.
Смотрите, я с вами работаю с конкретными нодами. Давайте сейчас как-нибудь, вот так
пойдет. Я могу в качестве P подать любой из этих элементов. P просто указатель на
некоторую ноду, на некоторый узел. И я возвращаю его в высоту.
Ну нет, еще раз. У меня в каждом узле хранится высота уже. У меня есть это поле.
Время работы, я думаю, вы не сомневаетесь, что у вас есть нички, правда? Это чудесно.
Чтобы вы дальше тоже не сомневались. Второе, balance factor. Вот это одно из самых
важных, что есть у нас в ВВЛ дереве. Balance factor поможет нам при балансировке
деревьев, так как именно по нему мы будем понимать, где происходит дисбаланс. Так как мы
будем вычитать высоту из правого по дереву минус высоту из левого по дереву.
Если это положительное число и больше единички, то у нас что? Что больше? Правое.
Причем дисбаланс у нас существует у этого дерева, согласны? Вот. Если же у меня будет
оно отрицательное, тогда в этом случае я говорю, что у меня левая часть его больше и дисбаланс
идет в сторону левого кусочка. Согласны? Понятно? Все равно, как много людей с нотами,
все еще у меня интригов. Что еще? Ошибка, извините. Так как я пишу в Markdown, у меня не всегда
правильно весь код компилируется, поэтому я не могу вам точно здесь делать. Да, это нужно
исправить. Нода здесь большой буквки. Название типа данных. Вот. Если balance factor у нас равен 1,
0 или минус 1, то дерево считается сбалансированным в плане AVL, с корнем в NODP. Согласны? Вот.
У нас есть это некоторая балансировка. Согласны, что это работает тоже за у от единички? Отлично.
Хоть что-то я вас научил. Вот. Уже мне нравится. Что еще? Восстановление корректности высоты. Вот
fix height — это как раз-таки восстановление некоторой корректности. Мы предполагаем,
что для левого и правого по деревьев уже все корректно, потому что мы всегда будем работать с
низу вверх. Мы будем восстанавливать рекурсивно. Это означает, что мы будем фиксировать те самые
высоты, которые есть. Тут нода тоже с маленькой буковки. Прошу прощения. Вот. У меня есть высота
левого, высота правого. Но это просто. И, кстати, height тоже с маленькой буквой. Кошмар. Столько ошибок
сделал. Ужас. Вот. Вот это бы не зашло, понимаете? Но зато поможет вам с точки зрения того,
что сделать. Я это перепишу и выложу сегодня. Так вот. Когда мы с вами говорим про то, что мы
фиксируем высоту, мы хотим ее пересчитать, у нас есть корректная левая, корректная правая. Я смотрю,
какой из них больше, и делаю плюс один. Смотрите, никакой формулы максимум мне здесь не нужно.
Никакой библиотеки алгоритм мне здесь не нужно. И написано все в строчку, друзья, представляете?
Чудеса. Так тоже можно. Вот. Поэтому, да, можно делать это таким образом. И так мы восстанавливаем
высоту. Мы точно знаем, что когда мы делаем ноду, у нее высота какая? Ноль. Правильно? Вот одна нода.
Какая высота? Смотрите, значит, вы не уловили типа еще в самом начале. А, хорошо, да, высота 1,
извините. Меня переклинило. Я тоже бывает, потому что... Я объясню, почему меня иногда переклинивает
в этом плане. Корман, дискретная математика, они немного идут по-разному, и корман считает
количество ребер. Я иногда подлагиваю, потом пишу что-нибудь другое. Да, у нода 1 высота. Мы
будем считать количество нод. Прошу прощения, важно признавать свои ошибки. Вот. Поехали дальше.
У нас с вами есть вот это фиксирование высоты. А согласны, что работает тоже завод единички?
Смотри. Представь следующее, что я добавляю куда-нибудь вершинку. Ну, вот куда-нибудь,
вот. Блин, оно у меня все будет тогда уже несбалансированное. Вот так. И вот так. Вот,
я добавил вот эту ноду. Да. Я пытаюсь пересчитать вот здесь высоту. Какая была высота до этого у
ноды вот этой? Она была единичка. Но я же добавил вершинку. Я попытаюсь сделать ее два. Потом
попытаюсь пересчитать еще выше что-то и выше, на всякий случай. То есть фикс hate это будет то,
что мы передаем сюда одну лишь ноду. Одну. И мы говорим, что у левой и правой его части корректная
высота, поэтому пересчитаем для нее высоту. Это просто пересчет высоты. Ну, то есть, грубо говоря,
представь, что у тебя есть дерево. Ты знаешь, что высота здесь равна х, что высота здесь равна у.
Какая высота здесь? Ну, вот у меня h left и h right. Высота левого кусочка, высота правого кусочка.
Видишь, это hate от p left и p right. Это высоты. Вот это и есть x и y. Тогда высота вот этого чему равна?
Откуда сумме-то? Чему равна здесь высота? Она максимуму равна из x и y плюс 1. Не сумме.
Потому что мы рекурсию будем записывать в другой момент. Мы до этого дойдем. Это будет
отдельный момент. Хорошо? Мы просто делаем вот некоторые такие функции, которые нам понадобятся,
просто при вызове. Мы все сделаем. Теперь что касается балансировки узлов. Нам нужен хороший
баланс в том, чтобы высота была логарифм. Мы с вами в конце докажем, что высота вл-дерево,
логарифм. Это в конце. Пока мы просто с ним живем. А в действительности строго доказывается,
что при добавлении нового одного узла у нас баланс-фактор у всего может поменяться на 2 или
минус 2. Максимум. Не может быть такое, что там будет минус 3 или 3 или еще что-то. Баланс-фактор
будет по абсолютной величине более двойки. Больше быть не может. И вот это возникает так
называемая разбалансировка дерева. Как работать в тех или иных случаях? Что же нам делать вообще,
когда у нас происходит разбалансировка? Кто представляет? У другого есть идея?
Правильно. Перенести, поворачивать. Это вот все об одном. Действительно нужно чуть-чуть
повернуть дерево, чтобы это было хорошо. Представим следующее. Вот у меня есть некоторая такая ситуация,
нужно понять, что с ней делать. И вообще для выпрямления ситуации, в управление того,
чтобы у нас было сбалансировано дерево, применяются повороты вокруг тех или иных узлов. Смотрите,
у меня есть A, B, C. Это по деревьям. И Q, P. Я точно знаю. Х и Y это внутри,
которые ключи лежат. Q и P. Я думаю, вы их видите. Правда? На всякий случай, я думаю, вы прекрасно
помните, что если я опущу все на ось все чиселки, тогда они лягут в ровную последовательность. То есть
возрастающую последовательность. Вот здесь аналогично, что A будет меньше X, A меньше B,
меньше Y, меньше C. Я думаю, вы это понимаете. Потому что это является бинарным деревом поиска.
И вот что такое правый поворот вокруг P или левый поворот? Если мы говорим про правый поворот,
тогда смотрите, Q и P по сути меняются местами. И у P левым его ребенком становится B. То есть в
одну сторону повернуть, это вот вправо пойти. Потом влево можно пойти. Вот здесь мы можем с вами
менять и самый поворот. То есть правый поворот, когда я Q и P меняю местами, то есть место P становится Q
сверху. Левый поворот наоборот. Окей? Понятно пока? Вот схематично. Что?
Переподвешивание. Ну смотрите, все, что нужно переподвесить. Нам нужно сказать, что у Q теперь
ребенок P правый. Ну вот если я говорю про правый поворот, что у Q становится правым ребенком P,
левое остается все также A. А у P левым ребенком становится B. Все. Только вот эти две вещи нам
нужно как-то обозначить. Мы не делаем здесь родителей. Я специально не брал эти указатели. Я
специально немного поменял формат самой ноды для того, чтобы хоть было что-то интересное. То есть
у бинарного дерева поиска мы брали парантов специально. Здесь я хочу без них вам показать,
как что будет жить. А, в этом плане, в этом плане, ну там не так уж это будет проблематично,
потому что мы будем опять же рекурсивно что-то делать. Вы увидите. Вот. Если мы говорим вот именно
такой вот концепции, как у нас происходит. А что мы можем сделать? Ну как бы еще раз. Все,
что нам нужно сделать. B переподвесить к P, а Q сказать, что у него ребенок теперь P. Вот. Если мы
говорим про тот самый правый поворот вокруг ноды P, тогда я говорю, что нода какая-нибудь Q равна
P левт. Для того, чтобы сбалансировать то самое дело. Почему я вообще вот начинаю эти повороты? Давайте
с вами посмотрим. Вот когда, в каком случае происходит правый поворот? Давайте начнем с этого
момента, то я боюсь, что я это не очень рассказал. Вот смотрите, у нас есть P, у нас есть Q, у нас есть
A, B, C. Я беру и поворачиваю и делаю следующее, что у меня будет здесь Q, B, B, A. Для чего я это
делаю? Для того, чтобы попытаться сбалансировать то самое дерево. Представим, что у меня вот эта часть
это H плюс 2, а вот эта часть H. Здесь, возможно, различные случаи между A и B. Я считаю, что вот
эта часть у меня сбалансирована. То есть у меня здесь, возможно, минус 1, 0, 1. Правильно? Вот такая
вот, возможно, штука. И мы рассмотрим различные его версии между собой. Но давайте возьмем, что пока
0. Посмотрим на 0, что будет происходить в этом случае. Если я скажу, что они одинаковые, тогда высота
каждой из этих частей, вот эта, это H плюс 1, согласна? И вот эта, это H плюс 1. Тогда, когда я вот
это сделаю, вот этот правый поворот, в этом случае высота здесь это H плюс 1, высота здесь это H плюс 1,
ну а здесь какая-то H осталось. Да, если balance factor 0, тогда в этом случае с P какая высота? H
плюс 2. Согласны ли вы с тем, что здесь H плюс 1, здесь H плюс 2, дерево стало сбалансированным в
плане ВЛ? Потому что разница не более чем на единицу. Окей? Понятно, что я сделал этим поворотом.
Вот это вот в случае нуля. А что будет происходить в случае, к примеру, минус 1? А если я это раз сделаю,
давайте еще раз это перепишу. У меня очень странно это выглядит, потому что высота вот этого H плюс 2,
вот этого H, но это ладно. А, дайте P, Q. Здесь H плюс 2, здесь также H. Я говорю, что у меня
минус 1 balance factor. Минус 1 означает, что правый меньше левого, согласны? Если я говорю,
что правый меньше левого, и он равен минус 1, тогда что? Все правильно, это H плюс 1, это H.
Я беру и поворачиваю, делаю правый поворот. У меня здесь Q, P, A, B. Вот это высота H плюс 1,
вот это высота H, вот это H. Согласны? Значит, высота вот этого сколько? Плюс 1. Значит,
вот здесь вот balance factor равен нулю. Согласны? Вот здесь вот balance factor равен 1. Остался
последний случай. Как вы думаете, он будет аналогичен этим? Кто считает, что да?
Просто повернул, да и все. Все так же вот и повернул, и у меня все хорошо.
Когда у меня balance factor вот здесь, вот единичка.
Это не так там. А это фактика, правда. Но мы сейчас до этого дойдем отдельно, посмотрим.
Пока считается, что у меня правый поворот, он разбирает вот этот случай по факту и вот этот
случай. Он отлично на них работает. У меня благодаря этому восстанавливается балансировка,
если у меня нижние уже были сбалансированы. Согласны? Кроме быть, может, одного случая.
Один случай мы рассмотрим отдельно. А? В смысле A и B поменять местами? Что еще раз?
Подожди. Что это? Куда это? Куда ты гонишь? Давай по это, по чуть-чуть. Так вот,
сбалансировка узлов с точки зрения того, как работает поворот направо. Поворот направо что
делает? Вот у меня есть вот это P, Q и так далее. Я говорю, что Q это P left. Левая его часть. Ну вот
оно. Водку и водку. Согласны? Я говорю, отлично, я нашел это. Дальше я говорю, что P left равен теперь Q
right. То есть, вот это B переподвешиваю к P. То есть, то, что я делаю, это вот я затираю,
я делаю вот так вот и затираю вот эту связь. Согласны? Чего еще раз? Так нет, еще раз. Я говорю,
что P left равно Q right. Значит, вот этой связи больше нет. У меня же связь односторонняя в ту сторону.
Вот поэтому эта связь исчезает, появляется вот это пунктиром. Согласны? Отлично, вот этой связи
у нас больше нет. Чего у нас осталось сделать? У меня у P теперь висит B и P. Осталось сказать,
что у этот B теперь правый ребенок Q. Согласны? Вот я это и делаю дальше. Я говорю, что Q right равно
P. После этого, смотрите, у A высота изменилась как-то у A, у B как-то изменилась, а у C нет. А вот
у P изменилась, да, и у Q изменилась. И так как я делаю вот этот вот восстановление корректности
высоты, я должен идти снизу вверх. Поэтому я сначала делаю P, затем делаю Q. Согласны?
Вопросы есть?
Презентация будет, правда, прям сегодня. Вот, если хочешь писать, пиши. Смотрите,
еще раз, A, B и C остаются ровно такой же высоты, как были с самого начала. Согласен? То есть,
как были здесь, так и остались. А вот у P и у Q поменялись высоты. Поэтому я в начале пересчитаю
P, а потом пересчитаю Q. Все. Вот. Это и будет делать вот это fixate. Ну а дальше я верну новый корень у
этого поддерева, окей? Этот новый корень, он будет потом переподвешивать на самом деле все,
что нам нужно. То есть, вот это восстановление связи с родителем, вот как ты говорила,
вот оно вот будет вот благодаря этому возвращению. В смысле, как родителю становится у Q новым
ребенком вместо P? Мы до этого дойдем. Давайте, по чуть-чуть. Мы здесь не просто так возвращаем
новый корень. Если мы вернули новый корень, мы сможем легко его переделать. Понятно?
Вопросы к этому есть? К правому повороту. Смотрите, левый поворот делается аналогичнейшим. Просто в другую
сторону вам нужно сделать. То есть, вот из этого случая получить вон тот. Все очень просто. Давайте
сначала разберем, за сколько работает этот поворот. За у от единичку. Потому что создать указатель
у от единички, присваивание, присваивание у от единички, а фиксировать высоту у от единички.
Вернуть у от единички. Все за у от единички. Вот левый поворот. Там будет происходить просто ровно
то же самое. Понятно? Здесь я специально, вот здесь тоже с маленькой буковки, тоже мне нужно переделать.
Здесь аналогично. То есть, я специально здесь взял Q как корень, чтобы вы могли спокойно,
симметрично друг друга вот эти случаи отображать. Вот вроде бы здесь все становится хорошо для левого и
правого поворота. Но мы с вами уже проговорили, я уже с вами порисовал, что мы один случай не можем
сделать. Почему мы не можем сделать? Давайте его отдельно рассмотрим сейчас с вами. У нас
случаи, когда у нас баланс фактор единичка. Давайте с вами это посмотрим. Да. Это действие,
вот здесь аналогично. Вот смотрите, у меня здесь УП. Вот это В я должен переподвесить Q.
Вот я отсюда это В. У него П левт, видишь? Становится Q райт.
Q райт у его правый ребенок становится В. А для того, чтобы на В я брал, вот это вот является P левт.
P левт должно стать Q райтом. Нет, почему? У нас что здесь будет? Я что должен сделать?
Сказать должен, что у Q теперь правый ребенок В и забить на эту связь. Ой, не на эту, на вот эту.
Q райт, вот она связь, равен P левт. Для того, чтобы у меня у Q был A ребенок и B ребенок. Понял?
Q райт это было вот это. Он указывал на П. А теперь он должен указывать на В. Это левый, это левый.
Вот. Окей. А давайте рассмотрим теперь тот самый случай отдельно. Вот у меня есть П, у меня есть
некоторая Q. А те, кто говорит, он уже все это, все в Эльдерево шарит. Кто-нибудь сможет мне
написать за 20 минут, пока я это рассказываю? Тогда чего? Окей, вот у нас есть этот случай B,
C. Я говорю, что у меня высота вот этого H, высота вот этого H плюс 2 и balance factor равен единичке.
Вот здесь вот. Если он здесь равен единичке, то что это значит? Что у кого? У B какая высота?
У B высота больше, чем у A, правильно? Правый минус левый. Значит высота вот этого H плюс 1,
высота вот этого H, согласны? Правильно я понимаю? Делаю тот самый правый поворот,
который мы с вами делали. Что я с вами получу? Я получу с вами Q. Здесь у меня будет P, здесь A,
A, B, C. У A высота H, у B высота H плюс 1, у C высота H. Значит высота вот этого сколько? H плюс 2.
Смотрите, я его перебалансировал так, что теперь у меня правая сторона перевешивает. Не прикольно,
согласна? Вот вообще не прикольно. Чего в этом случае делать? В этом случае на самом деле нужно
рассмотреть еще одну вещь. Нужно уйти еще ниже. Здесь я рассматриваю на самом деле, когда левый
поворот симметричен тому случаю, который здесь. Как хотите, давайте я по рисункам пойду лучше.
Вот здесь я с вами показал правый поворот, я покажу аналогичную ситуацию для левого поворота.
Левый поворот будет аналогичен, что у нас все перевесится. Что сюда я буду перевешивать,
что сюда. Давайте рассмотрим еще один узел чуть пониже. То есть вот то, что здесь написано,
я говорю, что h-a-hq равно 2. Сейчас будем рисовать тот самый левый поворот. У меня что там?
h-a-hq равно 2. Хорошо. Хорошо. Ладно. Вопрос нескорее не об этом? Ну да ладно. Окей, это правда.
Давайте смотреть, что у нас будет происходить. В чем у нас с вами будут проблемы и что мы захотим
сделать. В действительности, если я просто поверну в ту сторону, у меня ничего не изменится,
у меня будут какие-то проблемы. Почему? Потому что высота вот у этого кусочка у меня будет h
плюс 1, вот у этого h, вот у этого h. В этом вся проблема. Согласны? Давайте мы сделаем чуть-чуть
другие итерации. Я вначале возьму и поверну относительно вот этого кусочка. Что я с вами получу?
Я получу здесь p, здесь a, здесь s, у которого будет здесь b, аq, c, d. Я это поверну. В зависимости
от ситуации вот этого h плюс 1, где здесь больше, где здесь меньше, на самом деле здесь не сыграть
ничего из этого роли, потому что вот здесь у меня высота h, у меня высота c может быть какая,
ну либо h, либо h минус 1. Здесь высота какая? h может быть, h минус 1. В зависимости от
того, какую комбинацию мы просто здесь берем, у нас что-то получится. Либо h, h, либо h, h минус 1,
либо h минус 1, h. Но в любых из этих ситуаций, если вот здесь высота h, h минус 1, вот здесь высота h,
или h минус 1, вот здесь высота всегда h, согласны? Значит, баланс-фактор вот у этой части теперь
какой? Либо 0, либо 2. Не может быть. Еще раз, вот здесь высота h плюс 1 всегда. Сейчас, если мы с вами
вот таким вот образом поменяем, то вообще какой следующий шаг к этому всему? Давайте по отдельности
будем просто это делать. Sorry, я что-то... конец вечера, видимо, все, сломался. Вот здесь вот s,
вот здесь вот у меня будет a, ой, нет, вот здесь вот у меня будет, получается,
c, p, вот здесь вот будет a, вот здесь вот будет a, b, вот здесь вот у меня q, c, d. Согласны? Да. Высота
вот этого чему равна? h, вот этого h, вот этого h, или h минус 1, этого h, или h минус 1. Согласны?
Вот, теперь все будет хорошо. Да, вот этот случай нам не важно в середине, потому что я по итогу
получу то, что мне необходимо будет в любом случае. Мы повернули вот это s сюда. Ну, смотрите,
у меня сохранился порядок, у меня был порядок a, p, b, s, c, q, d. Давайте a, p, b, s, c, q, d.
A, p, b, s, c, q, d. Порядок не изменился. Я просто поменял вот это сюда. Когда я сюда вот это поверну,
что это означает? Что в p просто перенесется вот этот кусочек. Понятно? А вот эта связь уйдет,
и она будет вот так показывать. Ну, представьте, что я сделал левый поворот здесь.
Не, ну, смотри, представь, вот это все большим таким под деревом. Тебе нужно сделать левый поворот.
Левый поворот это означает, что ты должен вот из этой части вот сюда прийти. Не смотри здесь на
q, не смотри на c, d, вот возьми, что это большое-большое под дерево x. Так понятнее? Вот, ну типа все,
это повернется и будет так же. Хорошо? Вот. Ну вот, если говорить про x, то вот это вот будет
большое-большое под дерево. Окей? Теперь стало чуть яснее. Хорошо. Вот, то есть, смотрите,
в случае, когда у нас с вами возникает вот тот самый дисбаланс, когда по сути мы сделаем поворот,
и ничего не произойдет, мы сможем сначала сделать правый поворот вокруг p, а потом левый поворот туда.
Понятно? Я сначала вот сюда перенес, потом туда, и тогда в этом случае у меня баланс восстанавливается,
потому что тут h, тут h, тут h или h-1, тут h или h-1, тут h, здесь баланс сохранен, здесь баланс сохранен,
в общем баланс тоже сохранен, потому что высота вот этого h-1, вот этого h-1. Согласны? Всегда.
Понятно? Именно для этого случая. Задайте вопросы. Я, возможно, вас случайно убил, когда сам запутался.
Два. Еще раз. S, P, Q, потом вот сюда, потом S, P. Кого? Нет. Где? Еще раз. Вот этот случай.
Где я здесь поворачиваю? Просто рассматриваю этот случай отдельно. Я S поворачиваю в Q, получаю вот это,
потом S поворачиваю в P. То, что я здесь повернул и получил типа из одного случая в другой, я
специально вам показал, что они не работают. Простые повороты здесь не работают. Вот этот
поворот, когда мы поворачиваем сначала влево, потом вправо, или вправо, потом влево, называются
большие повороты. Либо большой правый поворот, либо большой левый поворот. А? Да. Вот. А в чем вообще
суть? Но эти повороты большие, состоят из маленьких, согласны, из двух маленьких. Причем, смотрите,
в каком случае нам необходимо будет выполнять большой левый или большой правый поворот.
Смотрите, balance factor вот здесь, вот какой был УП? Нет, ну здесь H плюс 2, здесь H. Минус 2. И у нас
не балансировалось дерево при единичке. Согласны? Аналогично здесь будет balance factor у Q будет
минус 2, а у правого или левого кусочка будет 1. Плюс 2, да, извините, плюс 2 и минус 1. То есть,
смотрите, здесь ситуация аналогична, то есть знаки различаются, у нас проблемы. Понятно? Запомните
таким образом. Почти уверен, что это помогает. Я в всяком случае всегда так понимаю, поэтому я
знал, какие случаи с вами разобраться. Вот. Но это просто удобно. Тоже касается большого левого,
большого правого поворота. Вот здесь, смотрите, я поворачиваю вправо, поворачиваю влево потом.
Вот это большой левый был. Большой правый аналогичен. Выглядит все достаточно просто. Я
не выписывал отдельно эти повороты, потому что они состоят из маленьких. Я лишь написал саму
балансировку. Смотрите, я пытаюсь сбалансировать некоторую ноду. Я для начала беру и фиксирую
у него высоту. На всякий случай, потому что мне нужна корректная высота будет. Так или иначе.
А фиксирование высоты повлечет за собой там еще некоторые вещи. Дальше я смотрю. Если у меня
баланс-фактор в П равен 2, то есть у меня правый кусок больше левого, тогда я в общем случае точно
буду делать rotate left. Согласно, левый поворот всегда будет присутствовать. Но в случае,
если я нахожу, что у меня баланс-фактор был у правого кусочка меньше нуля, то есть минус один
по факту, тогда я должен буду сделать большой левый поворот. Согласно? А для большого левого
поворота что я должен сделать? Вот если именно левый, вот здесь он указан. Я должен сначала вправо
повернуть вот здесь. Правильно? Это вот этот вот rotate right от P right. Вот он по сути. Это Q. Понятно?
Вот я делаю большой правый поворот относительно этой вершинки от P right. А дальше я делаю большой
просто левый поворот относительно P. Причем смотрите, вот спрашивали как связь восстановить. Вот то
есть у меня что тесс встала. Я просто пишу что P right равно rotate right или rotate left. Там не
есть разница. Rotate right от P right. Вот все просто. Так как он возвращает мне тот самый новый корень.
То есть еще раз я поворачиваю в одну сторону, потом в другую. Вот здесь вот эта балансировка
работает. Дальше я делаю следующее, что я просто смотрю. Если у меня баланс-фактор равен минус два,
тогда в этом случае я должен буду делать либо просто правый поворот, либо большой правый поворот.
Если большой правый поворот, то я сначала делаю поворот лево, а потом вправо. Все. Вот этот
if. Вот если if выполняется, значит мне нужен большой левый поворот. Тогда я делаю сначала
rotate left, а потом делаю rotate right. Большой правый поворот. Тогда у меня этот баланс-фактор не
может быть больше нуля. Еще раз говорю, у вас большой поворот в случае, если у вас баланс-фактор
в самой вершине, если он положительный, тогда в другой вершине он должен быть отрицательный.
И наоборот, если он отрицательный, тогда в другой вершине положительный. Большие повороты только в
этом случае. Мы рассматривали это здесь на примере, что для минус один и для нуля было все правильно,
для единички было плохо. Все. Ну вот эти if, я, возможно, из-за того, что не взял их в скобочки,
просто чтобы поместился код покрасивший, а из-за того, что не взял скобочки, возможно,
непонятно. По отступам поймите, пожалуйста. Понятно? Да, это мы сейчас дойдем. Это будет
происходить при insert или при delete. Если if не выполняется, у нас просто написано return
rotate right. Видишь? Rotate right это означает правый поворот. Он же не в if. Понятно?
То в то if зайдем, да. Вот. Все просто. Согласны, что это балансировка происходит за вот единички?
Потому что поворот правый, поворот лево они за вот единички. Поехали дальше. Давайте поговорим
теперь про вставку ключа. Вставку ключа мы будем делать рекурсивно и не будем забывать про ту самую
балансировку, которая нам необходима. Смотрите, я беру и вставляю какую-то ноду P с ключом K. Вот.
Если у меня нода P равна NALPTR, тогда я просто создам эту ноду. Если она не была равна,
тогда оставлю ту, которая была. Не суть важна, просто буду так сравнивать. Дальше я говорю,
что если у меня ключ меньше, чем ключ в вершинке, который нахожусь, тогда я иду куда? В левую его
часть. Потому что ключ меньше, значит то необходимое место, куда мне вставить ключ находится слева,
правильно? Если он больше, тогда иду вправо. Согласны? До каких пор я это повторяю? Я это
повторяю до тех пор, пока не наткнусь на NALPTR. Вот эта остановка рекурсии в P равна NALPTR и есть
та самая. То есть, смотрите, у меня есть некоторое дерево. Я вот сейчас рандомно рисую его, не обязательно,
что оно будет сходиться с тем, что там необходимо будет СВЛ-деревом, например. Так вот, у меня есть
это дерево и я нахожу, где мне найти это место? Ну, я пойду сюда, сюда и вот я вижу, что вот здесь
у меня образовался вот этот NALPTR. Я такой, ну туда и вставлю. Я вставляю этот элемент. Согласны,
что вот это дерево разбалансировалось? Проблема. Что в этом случае делать? Я вставил этот элемент,
поэтому в конце рекурсии я делаю balanceP. Так как я это делаю в конце рекурсии, у меня же стэк
вызовов рекурсии, как идет? Сначала вызов большой функции для корня, согласны? Потом вызов для
этого, давайте я это пронумерую. Там 0, 1, потом вот это 2, а вот это будет 3. Согласны? Ну,
вот эти вот инсерты как пойдут друг за дружкой, рекурсивно. Ну да, там return написано, так что нет,
не будет. Хорошо. 0, 1, 2. И дальше что он делает? Он делает return balanceP. То есть он просто берет и
сбалансирует сначала 2, потому что он идет в обратном порядке, потом 1, потом 0. И он будет
их сбалансировать между собой, так как я иду снизу вверх, у меня будет вся балансировка корректно,
потому что если этот не сбалансирован элемент, то он его сбалансирует, и значит для вот этого
элемента теперь все нижнее тоже сбалансировано. Я тоже его балансирую и так далее. Согласны?
Понятно, что я сделал? Не уверен, что для всех понятно. Это меня пугает.
Потому что в конце у вас может поменяться вообще корень.
Но у вас инсерт будет специально возвращать эту ноду со звездочкой.
На новую ноду в каждом разе. То есть смотрите, это не то что только для последнего случая. Смотри,
я сбалансировал вот этот кусок и предположим у меня здесь поменялся корень. Согласны? Я именно
для этого там пишу p-left или p-right равно инсерт чего-то. Почему? Потому что если у меня
здесь поменялся корень, то я должен заново его связать. Согласны? Вот я это и делаю здесь. То есть
вот здесь как-то поменялась структура, и я связываю это с корнем того, что у меня есть.
Балансировку мы обязаны делать каждый раз.
Можно, но когда ты делаешь вайлом, ты не раскрутишься назад. А как ты переподвешивать
будешь? Смотри, мне нужно вот это дерево, которое вот здесь. Нужно будет его перебалансировать. У
тебя поменяется структура дерева. Ну, например, господи, сейчас давайте я где-нибудь порисую.
Возможно, в прошлый раз я вас чуть раньше отпустил, в этот раз я вас чуть задержу. Так сказать,
закон сохранения времени. А если кому-то очень нужно будет спешить, станете уйдете. Я не обижусь.
В этот раз. Вдруг я обижаюсь. Короче, смотрите, представим, что у меня было следующее дерево.
Оно сбалансировано в плане АВЛ. Ну, вроде сбалансировано. Согласны? А, представим,
что я вставляю сюда элементы. Оно становится дебалансным. Я пытаюсь сбалансировать вот
этот элемент. Сбалансирую его. А? А вот тут? Здесь нет. Здесь нет проблемы. Я оставляю его таким же.
И вот эту связь я заново сохраняю. Вот эту. Окей? Потом я смотрю выше. Вот это сбалансированный кусочек,
но сбалансированный. Баланс не изменится. Я беру и вот эту штуку оставляю. Вот это теперь
часть сбалансирована. Вот эта часть сбалансирована между собой. Смотрим вот это и пытаемся
сбалансировать. Согласны, что у меня здесь разные вещи между собой? Согласны? Отлично. Мне нужно
сбалансировать. Эта часть больше этой. Ой, вот эта часть больше вот этой. Согласны? Что мне в этом
случае нужно делать? По-хорошему, повернуть налево. Либо сделать большой поворот налево. Здесь
хватит просто поворота налево то есть я должен получить здесь давайте я сделаю здесь 0 1 2 3 4 5
я должен сделать здесь 2 0 1 3 или мы каждый раз будем это переделывать то есть смотри
если бы у меня здесь нарушился баланс я бы здесь поменял да так как рекурсии стек
рекурсии раскручивается снизу вверх вверх вниз на самом деле рекурсивные функции друг на дружку
наслаиваться до тех пор пока не остановится понятно поэтому мне нужна рекурсия свайлом было
бы немного неприятнее но можно прислать это на байл указатель на какую-то на какую-то
ноду которая является корнем какого-то поддерево все поэтому я в начале буду балансировать 4 потом
2 потом 0 согласны что время работы это уатаж правда как бы логично вы вот инсертами ходите
туда сюда что касается удаления ключа удаление ключа аналогично тому что у нас с вами было мы
берем минимум пытаемся его вставить куда нам нужно но что происходит балансировка в этот момент
вопрос именно в этом то что у минимума а всего один ребенок я думаю вы это прекрасно понимаете
если один ребенок то ну как бы удалил вставил вот там максимум изменилось на единичку нужно
понять что с этим делать тогда в этом случае а если мы с вами говорим про поиск минимума то это
просто вот ну как бы все также рекурсивно находится очень просто find минимумом до тех пор пока я не
найду что слева у меня пусто то есть пока плф не пуст я минимум нахожу согласны друзья все вас
под конец убила я понял все нормально дальше хуже что касается удаление узла удаление узла будет
за собой подтягивать только одно я опять же здесь смотри смотрите remove mean я беру у конкретного
под дерево буду брать то есть я к примеру пошел вот в этот кусочек искать минимум я по нему
пойду здесь путем который происходит там как я еще минимум я просто иду вот так вот так вот так и
дохожу до этого момента рекурсивно после чего я беру и балансирую все это дерево заново потому
что я удалил один элемент структура дерева изменилась оно могло стать дисбалансным понятно
поэтому я опять делу баланс по ок вот так я удаляю тот самый минимум ну а дальше просто удаление
ключа но удаление ключа очень простая вещь здесь становится с точки зрения того что вы уже знаете
про бинарное дерево поиска но грубо говоря если вы нашли на лптр но я буду возвращать 0 по факту
это нулевой указатель можно писать ретер на лптр то есть не существует такой ну типа все закончили
на лптр теперь все равно а дальше я смотрю что если я ну это если я не нашел это вершина
которую удалить дальше я смотрю я пойду влево пойду вправо опять же рекурсивно видите ка меньше
ключа ка больше ключа окей окей что же касается удаления вот самого удаления то есть когда
мы нашли этот ключ когда мы нашли этот ключ я говорю что у меня есть левое по дерево есть правое
по дерево вначале я точно удаляю это вершинку п окей просто беру и удаляю и говорю что если у
меня справа на лптр то есть у меня нету справа ребенка есть только слева тогда я возвращаю
левт и в принципе почти все хорошо почему потому что левт всего один он лист согласны
то есть нам ничего не произойдет даже особо вот а дальше если это не так тогда я буду искать
минимум справа по дерево у этого правого по дерево убирать этот минимум перебалансировать
этот правый кусочек который у меня есть и сказать что у этой минимальной вершинки теперь левое
под дерево равно левту минимум райт он равен рему в минимума почему потому что рему в минимум он
удаляет эту вершину и перебалансирует все дерево согласны и возвращает корень этого кусочка если
я делаю рему в минимум правого кусочка то он вернет мне корень этого кусочка ок то есть у меня
минимум райт равен вот этому рему в минимум теперь левый ну минимум левого равен левому кусочку просто
и все окей вот у меня произошло удаление судя по всему вы взгрустнули это грустно
возможно есть проблему а мой вам совет пересмотрите презентацию в случае чего задайте мне вопросы к
этому всему чатике вл с как хотите окей а да будет будет будет а в чатике базы базового потока время
работы этого всего уатаж теперь мы приходим к самому забавному и интересному сколько это все работает
ему равна высота смотрите для высоты нам нужны числа фибоначи а очевидно очевидно что в
действительности вл дерево высоты аж содержит не менее чем ф аж плюс 3 минус одна вершинка где
f это число фибоначи порядковая с аж плюс 3 f нулевой нулев от единички 1 в два это единичка и
так далее вот существует такая теорема для доказательств этой теоремы существует два
утверждения первое утверждение возможно вы сталкивались когда-нибудь что число фибоначи
представим вот в таком вот виде с корнями из пяти а второе утверждение что вот это вот
все отен по модуле не более чем единичка вот ну типа плюс минус пока хорошо правда то
нормально чудесно как-то доказывает смотрите это доказывается индуктивно первое возьмем базу аж
равно нулю все пусто или это одинокая вершина ну типа если одинокая аж равно единичке тогда в
этом случае мы с вами должны сказать что не под аж плюс 3 а таж плюс 4 сорят тоже лагал чуть-чуть
вот я говорю у меня иногда в одну сторону и в другую короче здесь аж на единицу меньше чем
должен быть но не суть важна само доказательство важнее какой здесь будет переход переход будет
следующий если дерево имеет высоту аж то 1 1 из его потомкам имеет высоту аж минус 1 согласны
и потому он содержит не менее чем f от аж плюс 2 минус 1 вершинок ну это наше предположение индукция
она должна работать согласны другой должен иметь высоту не менее чем аж минус 2 может он имеет
больше но это неважно согласны может он имеет аж минус 1 также или что-то такое тогда он имеет
не менее чем f от аж плюс одну вершинку ага окей ну да минус один всего с учетом корня мы с
вами получаем что у нас есть корень 1 плюс f от аж плюс 2 минус 1 с одной стороны и f от аж плюс
1 минус 1 с другой стороны согласны ну видите сумму двух чисел фибоначчо
это количество это количество я говорю про количество количество вершин я суммирую
получает два числа фибоначчо подряд правильно значит получает 3 f от аж плюс 3 согласны ну и
один минус один минус один это минус один вот у меня получается что столько вершинок хорошая
теория мы доказали согласны ну достаточно индуктивно просто какое из этого следствие
этой теория мое следствие из этого всего что высота дерева это логарифм почему потому что
если мы с вами говорим что а n у меня больше чем f аж плюс 3 минус 1 но больше либо равно хорошо
не страшно окей больше либо равно тогда с учетом предыдущих двух утверждений которые у меня были
здесь я могу сказать что n плюс 2 то есть я минус 1 перенес f и psi в степени n перенес
окей понятно получая n плюс 2 оно больше чем один делить на корень из пяти фи в степени аж
плюс 3 и вот вот это вот ага чудесно тогда если мы про логарифмируем все и там вот все чиселки
подставим которые нам нужны в действительности мы получим что высота нашего дерева не более
чем вот 1 точка 44 логарифм двоичная тен плюс 2 минус там 0 32 но в действительности важно что оно
меньше чем логарифм высота согласны оно меньше чем высота это чудесно ой меньше чем логарифм значит
мы уже говорим
