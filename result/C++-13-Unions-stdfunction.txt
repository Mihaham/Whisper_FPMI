Тема четырнадцатая, пункт, видимо, третий. Вот, у нас план сегодня обсудить реализацию с
defunction, но мы ее обсудим не до конца, то есть мы сделаем ее не совсем
эффективной, а вот завтра, ну, у меня на самом деле бы уже, о, тут есть проект, кстати,
может тогда я смогу код написать, потому что завтра сдача, ну что ж мы теперь пары проводить
не будем, завтра будет сдача после пары, а все-таки пару я проведу, а потом уже принимаем,
вот, ну, может до одиннадцати принимаю место за сидеть, не знаю. Так вот, но прежде чем реализователь с
defunction, мы вот о чем еще поговорим, у нас есть такой важный, важная сущность в языке,
которую мы до сих пор никак не затрагивали, не обсуждали, это юнионы. Юнионы. Объединение. Вот,
но есть янамы, а есть юнионы. Эта штука тоже пришла из Си. Вот, кто знает, что такое юнионы? Юнион
хранится одной из нескольких. Ну, да, ну, вот там, в принципе, да, одни и те же люди, ну, в принципе,
ладно. Ну, вот, да, сейчас я поговорю о том, что такое юнионы и какими пользоваться, вот, довольно
скоро, примерно через неделю, а может быть даже и завтра, может и сегодня, мы поймем, что пользоваться
им почти никогда не надо, потому что есть современная, потому что есть, что? Сдовариант. Правильно, да,
Сдовариант, в Сибирь-17, который я заменил, и вашей четвертой задачей будет как раз он. Да,
спойлер небольшой. Ну, про то, как устроена Сдовариант внутри, это отдельная веселая песня, и там масса
приколов, которые вас, я уверен, очень порадуют, но это мы, видимо, обсудим уже через неделю, а пока
мы просто обсудим, что такое юнионы для начала. Ну, вот, смотрите, юнион, это, на виду с классом и
структурой, еще один способ объявить пользовательский тип данных, и у него могут быть поля, я могу
сказать, что в юнионе есть, не знаю, int x, ну, для начала что-то тупое, char c и там double d, вот, и, собственно,
дальше я могу объявлять сущности такого типа, где-нибудь в мейне. Вот, ну, я могу битовые поля какие-нибудь
делать вместо полей обычных, ну, то есть, я могу сказать, что на этом есть int x, там, 4 byte, ну, короче,
как обычно. Вот, а теперь, что я могу делать? Я могу... В смысле, есть 4 bit. О, bit, да, bit. Вот, теперь, ну,
главное, что отличает юнион от класса и структуры, это то, что размер его, это не сумма размеров полей,
а максимум. Вот, то есть, размер такой штуки будет 8. Тебя это удивляет? Да. Почему? Я не поднимал руку.
А, ты не поднимал руку? Я не поднимал руку. У меня ощущение было, что ты что-то там... А, просто остальные не делали даже
этого. Я это воспринял как положительный знак. Ладно, хорошо. Хоть бы голову почешу. Вот, человек уже голову чешет.
Ладно. Ну ладно, хорошо. Да, так вот, в чем смысл юниона? В том, что он позволяет вам прям вот так вот
топорно хранить вещь одну из таких на одном и том же участке памяти. То есть, ну, логично, что тогда его
размер будет максимум из размеров полей, и вы можете динамически подменять то, что там хранится в рантайме.
Ну, например, я могу сказать у точка х равно пяти, и там вывести х. А потом сказать у точка
с равно а в калычках. И снова вывести х. Х уже поменяется от этого. Ну, х перезатрется, потому что...
Ну, на самом деле, я не уверен, прям вот поменяется ли х от такого, потому что это зависит от того, в каком порядке там
что называется, литлэндион или бикэндион. Вот если я на какой-нибудь дабл, то уж точно поменяется. Вот если я так скажу,
то все, х точно перезатрется и будет... А мы еще не можем писать сяут х, а можем писать сяут у точка х.
Да, и у точка х. Я должен писать сяут у точка х, и здесь тоже напишу сяут у точка х. То есть, это в каком-то смысле рантайм RenderFedcast?
Да. Ну да. Не, ну RenderFedcast, он в общем-то... Ну, а что? А еще формально бы написать вот так, у в. Это правда, да?
А, ну да. Понятно. Ну, в смысле, вообще не гарантируется, как бы, что мы можем, когда мы... Если мы там присвоили у точка дэш,
то у точка х вообще корректно используется. Ну, если это int, то корректно, всегда. Ну, формально. Да, вот самые веселые вещи
начинаются когда-то с интервьюальными. Типа здесь, то есть, типа с интервьюальными конструкторами. Сейчас мы про это поговорим.
Значит, существует понятие ActiveMemberOfUnion. Вот. Есть... Ну, вот один... В юнионе в нем так дела обстоят. В нем один из членов активный,
а все остальные неактивные. Если я... Ну, вот, кстати, в такой... В таком случае я не знаю, кажется, активность становится первой по умолчанию.
Вот. Ну, если у меня все... У всех членов поля... О, и все члены — это примитивные типы, то есть, там, типы без интервьюальных конструкторов, ну, как обычно,
то активность члена, она определяется просто тем, кому мы последнему присвоили значение. Вот я сказал у точка х 75, и тем самым активным членом стал х.
Вот. Я могу в любом момент сказать у точка Derm314, и тогда активным членом станет D, а обращение на чтение, там, к неактивным членам в юнионе — это будет UBR.
Ну, на практике это будет реально просто интерпрет-каст, как будто бы. Вот ничего особо такого страшного.
Обычная UBR. Нормальная, типичная.
Обычная, да. Типичные плюсы, да.
Да, базовый плюс.
Вот. Хорошо. Я могу изначально юнион чем-то про создание проницилизировать, я могу сказать вот так.
Ну, тогда он просто проницилизирует то из полей, которое по типу подходит.
А здесь у вас все подходятся?
Нет, ну, понятно, что одно подходит точнее.
А еще у нас два инта — интыкс и интеллект.
Ну, вероятно, он же вообще...
Вроде он будет пытаться первый проницилизировать ситуацию.
А, кстати, да, наверное, я соманул, наверное, он проницилизирует... Слушай-ка, не помню, не могу точно сказать, он проницилизирует.
Ну, если агрегательно связывается, то первый. Ну, через фигурную скобочку.
Вот, а так... Даже не знаю, может он действительно первый будет пытаться проницилизировать, а не какой-то.
Но в любом случае я могу написать конструкторы.
Вот так некомпилируется.
А, так некомпилируется, да?
Окей.
Ну, хорошо.
Но я могу написать конструкторы.
То есть я могу честно сказать, что такое у, от, инта, у, от, чар.
В общем, я могу честно там задать конструкторы.
Там, ну, в принципе, вот так нужно работать, кажется.
Ну вот, значит, union.
Давайте я продублирую то, что писал, потому что сейчас дело пройдет быстро.
И конструктор, скажем, от, инт.
Вот, теперь я могу смело сказать так.
Давай вывести, значит, что там в иксе.
А теперь давайте я скажу, что у меня...
U, U раз в один.
Да.
А теперь давайте я скажу, что я на что-то поменял double.
И снова выведу то, что в иксе.
Это будет UB.
И снова выведу то, что в иксе.
Это будет UB.
Но мы, по всей видимости, увидим вот...
UXO.
Да.
Гитовое представление.
Какой-то части дома.
Первый, четвертый убит.
Ой, бай.
А это разве не unspecified behavior?
Почему это undefined?
Undefined.
Обращение к неактивному.
Ну, почему это undefined?
Потому что там может быть неймит.
Если нет, то это просто бред.
Ну, ты всегда его можешь интерпретировать.
Он очистит.
Как и нет, ты его не всегда можешь интерпретировать.
Это правда.
Это как бред не unspecified.
Это не undefined.
Ну, я думаю, что undefined, но это такие...
Это очень такие технические детали, не особо...
Существенные.
Будем честными, кто из нас это использует.
Все, да.
Все понимают, что будет, если...
Что так делать не надо.
Надо просто...
Правильно использовать union, да.
Но это не так...
Не так интересно.
Нет, почему?
Может кто-то из вас как раз будет использовать.
Вам вот в задаче реализация вариантов вполне пригодится.
Но...
Никто из нас не будет реализовывать, я понял.
Никто не будет цельно играть.
Все-таки из-за ахиды сюда...
В принципе...
Подход на боль.
Я знал, что...
Я в ходу признал, что так на боль.
А вы?
Вот.
Давайте рассмотрим случай теперь, когда у меня
в union тип с негривляльными конструкторами.
А...
Смотрите.
Давайте у меня в union будет, например...
И...
И стринг.
Нет.
Вот.
Но я могу сказать, что
U от...
От XA...
Ну, от NTA создается, получается, X.
От строки создается, получается, S.
Вот.
Что будет,
если я
попробую...
Ну, скажем...
Что сделать?
Ну, вот.
Вот, допустим,
я создал union, проницилизировал X,
а теперь хочу вот так сделать.
Ну, и вывести нормакресс.
Вот.
Проблем нет.
Проблем нет.
А вот, оказывается, будет секфолт сейчас.
Хороший коз, добрый.
Спасибо, я не хочу...
Если я сейчас ничего не накутал, то кажется, будет секфолт.
Давайте проверим.
А, ну...
Во-первых...
Так, извиняюсь.
Ну, во-первых,
сначала CE.
Давайте поймем, почему CE.
Потому что,
если у меня в union есть члены с нетрериальными конструкторами,
типа string, например,
то у такого union явно надо прописывать деструктор.
Ну, это логично, потому что
что должно происходить, когда union уничтожается?
Деструктор активного.
Да.
Деструктор активный, а кто из них активный?
Он же сам знает.
Кто знает?
Union не знает.
Union не знает?
Union...
Нет, не знает.
Блин, ты можешь просто не пропускать пары,
просто потому, что без твоих комментариев гораздо гуснее, чем...
У-у-у...
Я этого и думал, что 4,5,10 лекции.
Ну, вот давай, постарайся, а то прям вот...
Мы очень скучаем без твоих, значит, этих...
Хорошо.
Да, но проблема.
Потому что, как мы поймем,
что он уничтожит?
Union,
когда выходит из области видимости,
он должен что-то ветероятно уничтожить,
у него явно есть поле и string,
ему нужен деструктор.
Он же откуда-то знает, кто у него активный,
и вообще, как он?
На B кидает.
В том-то и смысл B, что он не знает,
он делает так.
О, какие беды, ладно.
Если бы он знал, то его можно было бы избежать.
В этом и смысл же.
Вот, ну давайте.
Плюс, кажется, надо вообще деструктор каждый раз,
когда мы переприсваиваем что-то.
Ну, меняем активный, да.
Ну да.
Я хотел предложить хранить еще и Bool,
но как бы он не затрется.
А вот, например, когда мы переприсваиваем,
как он понимает,
он понимает, кто был активным,
что он нужен деструктор.
Нет, он не знает,
он просто его еще называет.
В этом-то и причина segfault.
Ну, давайте я скажу, что...
Не понял.
Сейчас поймешь.
Ну, вот давайте я скажу,
что деструктор ничего не делает.
Так, наверное, должно быть, можно.
А, нет, default...
Default это что?
Просто не что.
Да, default он не умеет,
лучше пустой просто оставлю.
Вот.
Отлично.
И segfault, как я и говорил.
Здорово.
Кто понимает, почему?
Мне кажется,
в операторе присваивания строки...
Ну, у нас в строке
должна быть уже коррект
на каком-то виде,
когда мы присваиваем,
а у нас там лидично написано.
Ну, там у нас дел происходит
по новому патеру.
Конечно.
Ну да.
В этом вот месте
вызывается оператор
присваивания двух стрингов.
Это же стринг и это стринг.
Классическая проблема,
как бы ярко ли было.
Мы вызываем оператор присваивания,
хотя стринг-то никакого нет
на самом деле слева.
Там, ну...
Какие-то биты.
Продобные байты, да.
Слава, а если бы ты написал 0,
то это было бы...
0 где бы написал?
Ну, урона 0.
Ну, то есть...
Нам могло бы повести.
Зависит от того,
как внутри устроен стринг.
Ну да, зависит от того,
как внутри устроен стринг.
То есть, типа,
сейчас нам могло бы повести
и это бы означало, что...
Не понял.
Какая проблема с мусорной памятью?
Ну, типа...
Так ты дилит вызываешь.
Там...
Ну как?
Еще раз.
Какая была проблема?
Указатель какой-то.
Ну или что-то там.
Я не понимаю.
Но дилит он, наверное, не вызывает.
Он же через аллокаты должен.
Ну, какой аллокат?
А, да.
FC структура.
Класс.
Не-не-не.
Сейчас.
Это пришло FC,
но это не значит,
что у нас только C-шные разрешены.
Он вызывает дилит,
потому что стандартный жалобакар, конечно.
Вот.
Так.
Все подли, почему U-base,
а почему C-fold?
С 0 не получилось.
С 0 не получилось.
А давайте проверим.
Нет, я думал...
Я ставлю на то, что не получится.
Почему?
Не получится.
О-о-о!
Мы с дематикой сжали.
Ладно, хорошо.
А что попрямо с мусором?
Ну, значит,
значит,
в стринге первым полем лежит указатель, действительно.
Да?
Что мы поняли.
Так.
Вы поняли, что мы поняли?
Или сайд.
Хотя нет.
Да, указатель.
Типа, я должен явно вызывать структуру
каждый раз, обычно.
Да.
Да.
Значит, если у тебя union
состоит из полей,
которые являются интервьюальными типами,
то чтобы корректно...
Я не понял.
А если играли тип...
Ну, вот...
И все равно он падает?
Нет, нет.
Если у тебя есть...
Ты не можешь...
Во-первых, ты должен вызывать структуру,
прежде чем выключить одно из полей.
А чтобы включить поле новое,
ты не представляю, как должен использоваться placement tool.
То есть правильное использование было бы таким.
Не так.
А вот так.
У от...
Понятное дело такого.
СТД стринг АППЦ.
Вот это правильное использование.
Но теперь утечка памяти.
Утечка памяти и в прошлом коде была.
А чтобы утечки памяти не было,
мне нужно вручную вызывать структуру.
То есть мне нужно написать u.s.tilde...
А вот tilde что?
Basic string.
Да.
СТД basic string.
Если я напишу tilde st string,
то это не скомпилируется.
Давайте проверим.
Давай.
Потому что...
String это alias, поэтому...
Да.
Но должно же компилироваться.
Using.
Ну...
Нету такого метода.
А, виноват.
Почему?
Какой стд?
Да-да-да.
Здесь должно быть просто tilde.
Но, опять-таки...
Это не class string?
Да.
Ожидается имя класса, а не имя alias.
Поэтому...
Basic string char.
Вот так.
Вот так.
Вот так скомпилируется.
А если просто basic string?
Так она шаблонная.
Он скажет, я не знаю какой шаблонный аргумент.
А, или ты думаешь, что std сработает?
У нас же деструктор...
А, все.
Я понял.
Да.
Да, ты прав.
Действительно.
Что?
Ну, в плане, он смотрел, такой...
Опа.
Ну, у деструктора ты не указываешь шаблонный параметр.
Как-то в конструкторе копирования.
Кто шаблонный параметр реализовал, то знает.
Что шаблонный параметр...
У нас указанный не мешает.
Вот.
Basic string.
Вот, надо корректное использование теперь.
Можно еще раз посмотри, почему тогда он использовал?
Я не понял.
А, то есть ты все-таки не понял.
Еще раз.
Нет.
В точности такая же проблема, как когда ты реализуешь вектор.
Когда ты...
В чем была проблема, когда ты реализовал вектор?
Я же был прекрасный, я сдал мист.
Ну, до поры до времени.
Ну, смотри.
Еще раз.
Тебе нужно на новом месте создать объект.
Типа string.
Ну, у тебя вектор строк, допустим.
Там была проблема, что ты в новом месте хочешь создать string.
Там сырая память.
Ты не можешь делать присваивание string на то место.
Ты не можешь сказать u там.
Ты не можешь сказать там u r it присвоить старое.
Потому что оператор присваивания строк будет.
Оператор присваивания строк первым делом делает delete старого.
Но на старом месте не лежит string.
Там лежит сырый byte.
Он делает delete, как будто бы там был указатель, но там не указатель.
Получается, он делает delete по рандомному адресу.
И получает sigfault.
Здесь происходит то же самое.
Ты вызываешь оператор присваивания строк.
Как старый оператор.
Так это же expression.
Что это?
Оператор присваивания.
Слева string.
Справа const char звезда.
Ну, все.
Делается оператор присваивание.
Типа оператор присваивания строчный.
И это никакой специальный для union.
Для union может он и был бы специальным.
Но это не union, это строка.
Нет, ну для union может был специальный, чтобы он активно идти там очищал.
А здесь...
Что значит активно?
Какой тип?
Я понял, да.
Вот.
Это больно.
Но особенно, конечно, забавно, что он не байдает вот в такой случае.
Да ладно.
Он не байдает.
Ну, то есть, если...
У меня падает, например.
На G++11 падает, на Clang++ не падает.
Ну, реально, у B.
У B, да.
Ну, в корейской.
Причем интересно, что...
Ведь там не все байты нули, вероятно.
Не понял.
Ну, вот давайте я, допустим, скажу double-d.
Нет, давайте я еще скажу long-long.
Типа второй байт.
Long-long-y.
Вот что, если я выведу сейчас y?
Ну, просто указатель-то 8 байт, по идее, занимает.
А им только первые 4 байта обнулил.
Мне интересно, что вот он скажет сейчас.
Скажет, привет.
Секундочку.
Корректное использование, что-то там.
А где корректное использование?
Нет, нет, я некорректное использование уже делаю.
А с DSEALT US будет...
Сейчас, еще раз.
Он падет сейчас.
Не падает, все равно.
Да, то есть, у него, видимо, все байты обнулены.
Стоп, черт.
Ну, это, в смысле, это нормально.
Все объекты выделят, хотя...
Да, он мог бы и не обнулять.
Ну, короче...
В плане, более того, он обычно не обнуляет.
Ну, ты с юниевым...
Если даже интыксы выведешь x, то как будет?
Это правда.
Интыксы, а это юниевые.
О-о-о!
Глокая мысль.
Так, ладно.
Ну, в общем, повеселились и хватит.
В общем, пора к следующему от порциона переходить.
Изучили какой-то камин.
Теперь...
Как обычно.
Давайте...
Не знаю.
Посмотрим на, что нам говорят эти перейтлингс по этому поводу.
А...
У нас...
Да, вот это то, что мы сейчас разобрали, это только C++11.
До C++11 не разрешалось в юнионах содержать члены, которые...
Non-static data member, non-trivial special member function.
Да, ну, то есть нельзя было в юнионы класть члены, у которых нетривиальный кооп-конструктор, копия sign или диструктор.
Вот.
А начиная с C++11, как видите, ситуация опять поменялась, как часто бывает.
Если в юнионе есть такой член, то тогда эта соответствующая функция удалена в юнионе по умолчанию.
Ну, то есть, что значит, какая функция?
Вот.
У string есть нетривиальный конструктор, нетривиальный конструктор получали, нетривиальный конструктор копировали, написание диструктор.
Значит, соответственно, юнион у юнионных нет теперь.
То есть даже если я пишу там u.s, попробую u...
Нет, u.s есть.
Просто один юнион ты ни другому не можешь присвоить, тебе явно надо определять.
То есть, если у меня не было string...
Ты мог бы сказать u, v равно u.
Это был бы...
Опять, автоматически сгенерировался бы конструктор копирования юнионов.
Но только если бы не было строк, строки в нем в качестве поля.
Она есть, поэтому конструктор копирования, операция писания юниона, тебе придется определять самостоятельно.
А юнионы вообще хоть где-то используются?
Да.
И вот как раз сейчас мы...
Кругли варианты даже.
Придержать, например, где они используются.
Это вообще, скажем так, впервые на арене, впервые на сцене, значит, впервые на столе нашего курса.
То есть мы реально приведем предладной.
Пример кроме варианта.
Кстати, вариант можно и без юниона реализовать, и, вероятно, это даже удобнее будет.
А юнион без юниона реализовать нельзя? Случайно?
Ну да.
Да.
Ну да, ничего.
Ну...
Тебе придется явно риторпедкаст.
Ну да.
В смысле охранить.
Свой звездочек там выделить память.
Да, можно.
Можно просто делать.
Использовать будет примерно так же невозможно.
Типа, охранить в поля, равнивание.
Ну, чуть-чуть все равно.
За каждым...
За каждым...
И можно что-нибудь оценивать, скажем так.
Ну...
Нет, это будет такой обстрак на вопросе.
Ну, можно, короче.
Ну, вы все понимаете.
Ну, риторпедкаст придется делать.
Это лучше, чем юнион.
Да.
Ну и как и в структуре, доступ к членам по умолчанию у юниона не публичный.
Да.
Еще вот важный момент.
Union can have number function.
То есть я могу объявлять точно так же методы у юниона спокойно.
И даже операторы.
Но не виртуальная функция.
Юнион нельзя наследовать и не наследоваться.
Юнион нельзя наследовать.
И от него нельзя наследовать.
И у юниона не может быть non-steady native members or reference types.
В принципе, логично.
Почему?
Потому что тогда получается, что ссылку можно перепривязать.
Хитро, хитро.
Вот.
А...
Кстати, как вы думаете, может быть шаблонный юнион?
Да.
Правильно.
Почему нет?
Шаблонный юнион.
Слеверен.
Именно.
Именно.
Именно.
Именно.
Да что вы, дед?
Нет.
Стоп.
А может ли он быть...
С переменным количеством шаблонов аргументов, да?
Ну...
Стоп, стоп.
Я недавно написал чудесный код, где у меня был шаблон.
И типа это был класс шаблонный.
Так вот, этот шаблон класс, он наследовался в краске своего
параграмма.
Ну да.
Было весело.
Cd shortptr.
Смотрите.
Нет.
В плане типа паблика.
Я могу сделать следующую вещь.
Я могу сказать, шаблонный юнион...
А что, теста куда пишется?
Как мне сделать юнион, который хранит один из перечисленных
типов?
Юнион...
А, нужно говорить шаблонную магию написать.
Нет.
Ну какую, ладно.
Ну вот смотри.
Обычно шестнадцать три точки.
Чтобы такое выражение продлеваем много раз.
Да.
А план один хранить?
Ну, еще раз.
Я хочу сделать следующее.
Я хочу сказать.
Types.zip.
Types.zip.
Types.zip.
Types.zip.
Types.zip.
Types.zip.
Types.zip.
Types.zip.
Это звучит очень плохо.
Да, так можно вроде бы?
Обращаться к этому непонятно будет.
Так же.
Давайте сделаем так.
В плане так же.
Юнион.
В плане так же.
Юнион от одного аргумента и Types.
Нет, давайте определим.
Юнион и юнион если от одного аргумента.
Как мы полностью с этим работать хотим?
Как мы будем к этому обращаться?
Надо будет написать соответствующие конструкторы, деструкторы
и так далее.
Это правда.
Тут придется писать метод get, что-то в таком стиле.
Ну, собственно, примерно варианты получаем.
К этому мы и идем.
Дичь заступила, я понял.
Вот.
Ну, типичный способ, классический путь решения какой.
Я говорю, у меня есть type-name head и еще tail.
Только там три точки.
Да.
И здесь я просто храню head.
А еще
Юнион.
Юнион или template union?
Ой, template union.
Что-то именно такое я видел в исходниках тюпла.
Ну, смотрите, в исходниках тюпла, по сути, о, кстати,
очень сейчас красиво будет для кого-то может быть.
Нет.
Смотрите, что такое тюпл на самом деле?
Тюпл — это структура с переменом количественных шаблонных аргументов,
в которой есть поле head, а еще тюпл от оставшихся аргументов.
Это не красиво, это отвратительно.
Это отвратительно.
И это еще не красиво.
А что такой вариант, по сути?
Это то же самое, только не структура, а union.
Какой это union?
Ну, если вот здесь я напишу struct вместо union,
то получится, как будто бы я тюпл сделал.
Если бы я здесь написал union, то получается я сделал как бы вариант.
Ну, то есть, std вариант — это тип, который...
Ну, давайте ладно, не буду пока рассказывать про std вариант.
Ну, нужно писать соответствующий метод, потому что так просто оно не...
imp, std, sameweb, все такое.
Да, но...
Казалось бы, просто надо написать там всякие методы, шаблоны.
Нет, не sameweb, потому что у тебя самое...
Может несколько одинаковых типов в нем быть.
Типа in, double, union.
А может ли в нем быть несколько одинаковых типов?
Уметь ли это хоть какой-то...
Ну, тюпл же умеет, так?
Тюпл-то умеет, а тюпл-то тюпл и что?
Ну, а здесь...
Нет, я говорю, подожди, какая разница?
Какая разница?
Будем всегда использовать первый.
Возможно, для логики, типа, ну, они разные вещи, значит, условно.
Они могут знать разные вещи.
Ему всего один активный в каждый момент времени.
Ну, нет, вариант одинаковых типов — это какой-то...
Какая-то жесть там.
Я не помню, это сразу C или...
Ну, короче, такого...
Перегрузка, который будет...
Такого быть не должно.
Да, это очень...
Сохрани, пожалуйста, int или можно int еще.
Какой сложный выбор.
int или int?
Так, смотрите.
А может int как сам, а может int звездочка?
В общем, шаблоны имени, да.
Ну, STD-вариант, он позволяет делать...
Самая прикольная фишка STD-варианта в том,
что вы можете написать STD-вариант от blah-blah-blah там.
v равно, например, один.
И он правильный член принципизирует сам догадаться, какой.
Вот как раз вариант так умеет.
И вот реализовать вариант, самое интересное в нем,
это как раз чтобы он правильно делал это.
Про это мы поговорим, наверное,
либо завтра, либо через неделю, не знаю пока.
По ощущениям там что-то очень...
Так, давайте пойдем дальше.
И я хочу...
Это был пункт 14.3.
Я хочу сейчас показать...
Использование юнионов на практике реальное.
И оно прям полезное.
Где используются юнионы в стандартной библиотеке?
Я вам...
Гулту, кстати, тоже полезное.
Ну, юнионы используются для оптимизации кое-чего.
Гулту тоже.
Вообще...
Там как раз сложно эти условные конструкции...
Ну да, да, в принципе, да.
Так вот, продолжаем.
Значит, пункт 14.4.
Это будет...
Ладно, низкорубку называется, давайте вы, может, догадаетесь.
А может кто-то из вас знает?
Клей.
Нет, я шучу.
А лучше не шучу.
Юнион, например, используется...
Вот видите, вот у меня есть вкладочка.
Она не из проста.
Вот я сейчас во второй вкладочке.
Да, да, да.
У меня там открыт какой стандарт библиотеки.
Вы даже, вероятно, видели, какой.
Но на самом деле там открыт Basic String.
Там открыт библиотечный String.
Его реализация используется юнионом.
Отгадайте, для чего?
Чего я разумею думаю?
Нет.
Не завидую.
Да, Small String Optimization.
Собственно, об этом и пункт.
Значит, юнионы в стандартной библиотеке
используются,
ну, не только в стандартной библиотеке,
а вообще, на практике,
когда вам нужно сделать
Small Object Optimization.
Ну, в случае строк
называется Small String Optimization.
Ну, можно сказать
Small Object Optimization.
Давайте я просто покажу вам,
как выглядит,
ну, вот это вот просто
Basic String реализации.
Тут
ну, давайте найдем
юнион.
Ну, тут вот есть Alloc Hider.
А вот
юнион.
Смотрите, что здесь лежит.
Ну, во-первых,
прежде чем понять, что тут
в нем перечислено, я хочу обратить
вашу юниону на формулу.
У него нет имени почему-то.
Анонимный Юнион.
Анонимный Юнион.
А сверху тоже нет
миния.
Какой-то группа анонимных, я не знаю,
вообще.
Крупа анонимных членов.
Ну, ладно.
Крупа анонимных
членов стрима.
Там все надо быть анонимными.
Спресс где-то засунутый, нормально.
Что такое анонимный Юнион?
А вот как вообще понять,
это юнион, нет имени,
это мы в телеклассе находимся.
Ну, тогда все его объекты, они как бы
поля класса и ровно один из вот этих
всех активных.
Да, все так. Значит,
вы можете сделать юнионанимным.
И давайте я
вниз не пролистал, но вот тут есть
тут рассказывается,
что такое member lifetime, что такое
активный и пассивный член юниона.
Анонимный Юнион. Давайте посмотрим.
Смотрите.
Можно
сказать, что
у меня есть анонимный юнион.
И...
Значит...
Ну, вот так
это выглядит. Для анонимных юнионов
применяются дальнейшие ограничения.
Не может быть членов,
не может быть статических членов
и всех членов.
А...
Вот.
То есть, если я здесь написал
анонимный юнион, то у меня как бы появляется
одновременно int i и const char звезда b,
но они шерят одну и ту же
память.
То же самое могу делать
тут есть union-like classes,
но это какая-то довольно
устаревшая штука.
Так вот,
если я это в полях объявляю, то у меня
появляется как бы два поля,
одновременно вот такое поле, я блок,
elbuff и emulogic paste, и при этом
они оба...
Ну, при этом они шерят
одно и то же место в памяти.
А что это за ена
шедевральна?
А...
Я не знаю, почему это ена,
это просто константа, которая...
Не знаю, честно, почему это ена
сделана, но это константа,
которая...
В области видимости, то есть просто
сериал ена мы получим то же самое.
Нет.
Объявление константы.
Ну ладно. Я не знаю, почему это в виде
ена мы сделана, но
просто да, у меня такая константа 15 делить
на sizers чарты, но то есть
в случае чара обычного это будет 15.
Вот, и
эта константа используется для
объявления вот этого массива, то есть у меня
union из двух вещей,
localbuff размера 16,
а еще с свойства allocatedcapacity.
Соответственно размер этого
union 16.
Так вот, что такое small string optimization?
Идея в том, что
если строка у вас короткая,
короче, чем размер
полей, которые нужно, чтобы ее хранить,
ну вот, у вас есть
строка, у нее обычно
есть указатель
на начало там sizecapacity.
Если у вас строка
размера 8, скажем,
то ее можно
всю целиком поместить
в ту память, в которой вы указатель хранили.
Вам не нужно алоцировать
через new
динамической памяти
пространство для этой строки,
вы можете прямо на стеке ее положить.
А вот там pointer
он всегда существует.
Какой pointer?
Ну вот там, чуть-чуть выше,
pointer and the action data.
Да.
Есть, значит, pointer.
Давайте посмотрим на вот эту структуру.
Значит, я не буду сейчас
говорить про то, что такое log-hider.
Ну, в общем...
А, а там to do есть?
Ну, может потом как-нибудь поговорим.
Что там?
To do в коде.
Это нормально.
В кодис на библиотеке часто бывает to do,
это нормально.
Ну, короче говоря,
там эта структура,
она наследуется от локатора,
то есть
фактически получается,
что у вас есть локатор
и к нему еще более pointer добавлено.
Ну, зачем
это сделано, чтобы если локатор пустой,
например, STD-локатор,
то он вместо лишнего не занимал,
потому что когда вы наследуете пустого класса,
у вас лишних багging добавляется.
Это называется empty-base-optimization.
Это гениально.
Потому что если бы я
положил локатор как поле отдельное,
то оно бы занимало лишний,
а из-за пейдинга оно бы занимало целых 8.
Я понимаю, почему
человек в стрим...
Код?
Нет.
Почему он там бугуктит на комитете?
Я понял.
Короче, это довольно
распространенная техника,
кстати, в Sherriff PTR, и она тоже используется в Australian.
Но вам не надо.
Так вот, pointer
pointer, собственно, указывает
на данные строки.
Так вот, этот pointer
он указывает либо
на выделенную память,
либо
на...
на юнион.
И как мы проверяем,
у нас сейчас
строка выделена на стеке
или на куче.
Если этот pointer
равен адресу вот этого вот
поля,
то значит, строка выделена на куче,
и тогда нам не нужно
capacity.
А если она
выделена на куче, тогда вот здесь
активен член capacity,
а pointer указывает на адрес, где
она выделена.
Понятно? То есть мы экономим
один им, фактически.
То есть вот capacity может
быть поширена с
локальным буфером.
Ну один...
Это не им, это лонг.
А, да, один с айс-т, да.
То есть 8 чаров.
Это нихрена себе.
Сейчас, только единственное, что меня смущает,
то локаль бафт занимает 16 байтов, а айс-т
занимает 8.
Ну,
смотрите, мы уже сэкономили 8 байт
на локаторе.
Можно эти 8 байт, так сказать,
и занять по поводу.
Почему мы в юнио локатора
не положили?
Так, это называется
small string optimization.
За счет этого стандартная строка работает
гораздо быстрее, чем
ну, может, не гораздо быстрее.
Нет, не быстрее, именно экономия
по памяти.
Нет, это экономия времени
в первую очередь. Главное здесь
экономия времени, именно экономия эффективности.
То, что ты сэкономил 8 байт,
это не так важно. Важно то, что если твоя строка
короткая, тебе не придется в локацию
делать один ее.
Вот, и это на самом деле
очень...
Ну, такая популярная штука, а это
во всех.
Ну, может, и прямо во всех,
но, значит,
во многих классах.
Ну, странно, если
он во многих, что-то в каком-то векторе...
Ну, во многих можно
и вектори использовать.
Ну, почему эмо локаиры копальтики
это же просто число.
Да.
LocalBug это все такие
и не поможет.
Жива?
Сейчас. Ну, смотри.
Красавчик, тебе нужно
лишь одно из двух.
Тебе нужен всегда либо LocalBuffer,
либо Capacity число.
А одновременно они оба не нужны.
Capacity...
AllocatedCapacity это обычная Capacity
сфера.
Это штука, где ты хранишь
строку на стеке, если она слишком короткая.
То есть, я
объединил... Если у тебя
строка
переменной для хранения Capacity,
ты хранишь на одном и том же месте
с LocalBuffer. Если твоя строка короткая,
то тебе не надо помнить Capacity,
потому что ты его знаешь и так, какое оно.
И вот те байты, которые
под Capacity ты расходовал,
ты можешь занять LocalBuffer как раз.
Какая это...
Он каждый раз и файт?
Нет, он просто...
Он по пойтеру обращается.
Он просто по пойтеру обращается, да.
А как он поймет? Он сейчас вот, я не понял,
как мы понимаем...
Как он понимает, что
есть что и когда...
Ну давайте, давайте...
Указывает ли пойтер на юниору или нет?
Так...
Не, он не может... Типа, он всегда должен быть указан на юниору.
Нет, он может
на кучу указывать. Давайте посмотрим, как
диструктор работает. Есть функция
R-Sport. У тебя еще. У тебя юниор делит переменную,
которая отвечает за реальный Capacity,
если строка большая, или
Buffer. Ну...
Вот как работает диструктор.
Надо что-то одно из двух знать.
Как ты будешь понимать, что есть что?
Если твой указатель,
который ты отдельно хранишь, указывает на юниор,
значит... Он всегда указывает на юниор?
Нет!
Еще раз, у вас перьюниор
хранит либо Capacity, либо Buffer.
Он всегда должен быть, наверное.
У тебя кроме этого есть указатель. Есть указатель
отдельный, просто PTR.
У тебя есть пойтер. МПМ
называется.
Вот, блин, ну ты
вспомни свою строку. У тебя есть
пойтер,
Size и Capacity.
Пойтер остается,
Size остается, а Capacity
заменяется на юниор.
Либо Capacity, либо
Char, Massage Char.
Соответственно, твой пойтер,
если твоя строка короткая,
то тебе не нужно Capacity.
И ты на вот тех байках,
на которых бы ты хранил Capacity, хранишь саму строку.
И твой
пойтер тогда указывает на это
поле. Вот на это самое, которое было
в ЭКПС, ты на самом деле сейчас со мной хранил
Char.
А если твоя строка длиннее,
чем позволяет хранить эта
штука, то твой пойтер,
как в обычной строке,
как в той, которую вы писали, делает
U, и пойтер указывает куда-то во мне.
Тогда ты понимаешь, что
раз пойтер указывает не на моем поле,
значит строка выняли на кучу,
значит, на тех байках лежит Capacity,
а не Char.
Если она все еще умещается,
то нормально, а если она не перестала
участвовать, то реалацирует.
Кто понял,
как работает Small String Optimization?
М из Local.
Это я показываю,
как работает Диструктор.
Диструктор
просто вызывает функцию
fDispose, а функцию fDispose проверяет,
если не m из Local, то fDestroy.
Ну, понятно, что fDestroy.
А m из Local вот.
Ну вот, собственно,
mData равно mLocalData.
mLocalData вам просто вернет указатель
на то самое поле, а mData вернет...
Ну давайте.
Ну давайте проверим.
Кстати, можно догадаться, почему
оно так называется.
Вот mLocalData.
Значит, что она возвращает?
Ну она просто возвращает
pointer на LocalBuffer.
А mData
возвращает
тот pointer, который
в, ну вот, собственно, наш pointer.
Ну все,
мы просто проверяем.
Можешь еще
диструктор показать?
Какой из десяти?
Я про то, что если мы пишем
в кавычках
abc, это вот,
это что? Это литерал.
Типа const char звездочки.
А где, собственно, этот,
где, собственно, сам этот литерал
лежит в статической памяти?
Ну да.
То есть small string
optimization не применяется.
Или копируется.
Ну мы его скопируем просто.
А, ну да.
Мы не можем
указывать.
Указывать можем, изменить нельзя.
В смысле, мы не можем просто указывать
и надеяться, что мы отлично сработаем.
Так, окей, отлично. Мы разобрались,
как работает small string optimization на строках.
Хорошо.
Следующий пункт
это, знаете что?
Это realization of the function.
Кроме
std string,
следующий,
ну другой класс, который
существенно использует small,
не string, а small object optimization,
это std function как раз.
И там это важно
очень.
Давайте вспомним,
что такое std function?
А,
надо было на прошлые пары ходить.
Ну ладно.
Значит, что std function
должно делать? Оно нужно
хранить в себе указатель
на,
ну давайте, значит,
наверное, это прям закрою.
И, честно, сейчас я попробую написать
некоторое подобие std function.
Я решил в этом году
function не делать задачей,
потому что кажется, что
мы ее прям,
ну, мы ее почти реализуем и так.
Тут интересно очень.
А какая пятая задача?
А...
Typeist будет.
Шаблонное метапрограммирование будет
как кольненькое.
Ну, увидите.
Возможно,
возможно, я
позову Рому
в санду, который...
Ого.
Ну, в общем, да, у нас был
на физике пульс по шаблонным метапрограммированию
отдельный, я чем-нибудь это возможно,
чем-нибудь он расскажет на последних
парах.
Не знаю, посмотрим.
Значит, смотрите, я хочу реализовать
function.
Давайте по...
Рассуждаем, пообсуждаем,
как должна быть она устроена,
но, видимо, мы уже сегодня...
Ну, мы сейчас целиком ее не реализуем,
но мы реализуем как бы...
Ну, основные идеи мы изложим,
а там завтра, видимо,
мы когда-то делаем
уже еще там оптимизированную
некую версию.
Значит, во-первых...
Во-первых, я говорю...
А, ну, давайте
скажу, что у меня есть мое
пространство имен, чтобы они там
коллектовались со стандартным.
Ну, давайте я скажу, что у меня есть
function,
который без определения,
и теперь есть
вот такая вот
специализация,
вот от таких шаблонных параметров.
И вот ее-то мы будем реализовывать.
Res — это то, что возвращается.
Да, возвращаем идти
под принимаемых аргументов.
Секунду, почему мы могли так объявить
и сделать эту специализацию?
Это обычная специализация?
Это специализация.
Секунду, там был один type-name,
а тут их как-то...
Какая разница? Нет, минуточку.
Забыл отработать со шаблонов, видимо.
Я могу сколько угодно.
У меня есть...
Это не выглядит как специализация тоже сверху.
Может быть, на 3 точно же настаивать какой-нибудь?
Да, слушай, ты, наверное, прав.
Ну, давай я, наверное, вот так скажу.
Вот так, наверное.
Ничего не забывал.
Ладно, хорошо.
Не, наверное, так я сам тоже обработал,
но вот так было бы правильнее.
То есть, function от
произвольного набора типов —
это вещь без определения.
Function вот от такого странного
поднабора — это вот что.
Так.
Значит, мы хотим реализовать
функцию...
Значит, правила.
Мы хотим применить
Typerager.
Что мы хотим сделать?
Ну, что нам надо хранить? Вот function.
Что будет в поляне?
Нужно хранить объект, который...
Наш муссальный объект, в общем-то, хранить
может каким-то образом в конечном счете.
Нет, сам объект мы храним не в конечном счете.
Нет, указатель мы будем хранить слишком большим.
На control-блок.
Ну, не совсем на control-блок.
Так, сейчас.
Как у Strider Typer... Мы должны...
Мы применяем ту же идею, которая была при
реализации Any.
У нас есть какой-то... У нас был
kind of...
StructBase, virtual destructor.
Да, мы делаем
структуру Base,
у которой виртуальный
destructor.
У Any, наверное, должны быть виртуальные
операторы круглоскопички, что могли вызывать.
Или что-нибудь такое.
Или функция Call.
Ну, у нее там много чего...
У нее, на самом деле, должно быть
функции...
Ну, у нее должна быть функция Copy,
которая...
Давайте скажем. Давайте скажем
virtual res call
const или не const?
Мы хотим, чтобы можно было что
угодно сделать, поэтому не
const, видимо.
А мы хотим иногда const.
А что const function
умеет? Он не умеет меняться, но он умеет
хранить и вызывать. Значит, надо const.
Наверное.
Ну, а что если мы захотим
присвоить ей объект, у которого
круглоскопички не ограничены const?
Нормально или нет?
Ну, нам придется...
У нас же будет член, который
в геральде будет лежать
объект,
у которого будут круглые скопочки,
и мы будем
их вызывать, а они будут не константны.
Ну, да вызывай ему mutable.
const нам придется здесь не
писать.
Плохо, потому что...
Чего?
А почему не назвать mutable?
Ну, типа...
Если у него нечаянно констанен к
не конст, у него могут вызваться не те круглые
скопочки. Ну, а по логике вещей,
какой у нас
этот метод относительно класса B?
Давайте просто поймем
с точки зрения выяснения, этот метод константный
или нет? Нет, потому что он может менять
поля. Правда же? Он же может менять поля.
Ну, так, вообще проверка.
Поэтому я бы конст не писал. Но это на самом деле
действительно большая проблема. Вот в std
function есть проблемы с константностью
по этой, потому что вы можете туда
положить функцию, которая
помечена как
конст,
но здесь константность
потеряется. Сейчас, если у
меня есть два оператора круглые скопочки
с одинаковыми всем,
кроме последнего слова конст,
он может вызвать не то?
Вот...
Сходу не скажу,
но знаю, что есть этим проблема
у нас std function, не уверен.
Давайте сейчас
что-нибудь напишем, а дальше поймем, откуда работает
сравним.
Ну, короче, вот у нас и будет функция call,
и у нас еще будет функция
ну, копия.
Скажите, а могли ли мы
объявить виртуальный оператор?
Конечно. А почему мы
не сделали?
Ну, можно.
Для унификации, наверное.
Да, здесь args нужно.
Логично.
Те же самые args. Да, логично.
И он чисто виртуальный,
потому что у base ничего вызвать нельзя.
Ну, еще будет virtual,
base, звездочка,
copy.
А мы хотим так args принимать?
Да, потому что
когда мы вызываем,
когда мы создаем function, мы явно указываем шаблонные
инструменты, и это могут быть...
если это с ссылки, то мы явно скажем, что это с ссылки.
Я не о том, что там
mov...
Так mov это объекты, а это типы.
Это типы, все отлично, я ужасно старый.
Нам еще, наверное, нужно как-нибудь
delete, типа делокей, функция.
Нравится сама ссылка, конечно.
Нам нужно будет, который себя удалит еще,
потому что как мы его удалим?
Так подожди.
Это деструкторы.
Давайте напишем, собственно, derived.
Теперь у нас будет template
type name что?
То конкретный тип, который
мы хотим, function, да.
type name,
struct derived,
public base.
И здесь мы будем хранить, собственно, function.
И вот здесь мы определим все эти методы.
Ну,
наверное,
деструктор нам
сгодится.
Обычный.
Мы...
Хорошо.
Правда?
Где мы будем...
У нас же это будет хранить в климатической памяти?
Или как?
Да.
Кто будет удалять?
Да все.
Оператор delete.
А где?
Он будет удалять base.
Ну хорошо, да, нормально.
Так.
У нас есть еще что?
Нам нужно оператор круглой скобочки реализовать.
Значит, я пишу res,
оператор
круглой скобочки от args,
override.
Что мы должны здесь сделать?
Только...
с args именами уже.
Да.
И return.
f от std forward.
А вот std forward или просто args?
std forward.
Ну, он всегда...
он же хуже не сделает.
Ну,
сложно.
Дело в том, что
args-то может быть
само с амперсандами.
Если вы std forward
вызовете типа, к которому
амперсанды навестите, то это вы сделаете, кажется,
не то, что хотелось бы.
Ну, args.
У args, у типов args
могут у самих быть двойные амперсанды.
Может быть std
еще что-нибудь?
Похоже на forward, только не
forward.
New forward.
New forward.
Ну, можем пока лезть просто.
А в чем еще раз проблема? Мы же всегда...
Ну, мы хотим сделать backward forward.
В чем проблема?
Ну, если нам...
давайте разберемся в случае. Допустим,
мы не создали функцию res от
просто t.
Ну, пусть, не знаю, хорошо,
s. s у меня есть какая-то структура.
Вот мне сделали функцию, которая возвращает нам
void от s.
Тогда я по значению сюда
приму.
И по значению передам.
Ну, так оно, наверное, и хотелось бы сделать.
Ну, можно было бы еще...
Да, хорошо, да.
Вот. Если мне дали ссылку,
то я должен...
то я, получается, по ссылке приму.
Вот это args, оно будет сам лезвие
с одним амперсандом.
И по ссылке
же передам.
Ну, это совсем не страшно.
А у нас copy-illusion тут не сработает?
Copy-illusion...
сработано,
но это не связанная история.
Тут же мы пока про принимаем
аргументы и возвращаем их.
Нет, copy-illusion имеется в виду,
что res, если я верну res,
то он не скидывается.
Ну, мы сейчас про
принимаем аргументы говорим.
А если я вызовусь,
вот, ну, если
lvalue или обычная копия,
то нормально. А если мне передали
rvalue ссылку,
то что я сделаю?
Просто передаешь ее по значению дальше.
Почему по значению?
Ну, потому что... Нет?
Если функция принимает
rvalue ссылку,
то кажется, что это будет
вообще CE.
Потому что...
Ну, смотрите, пусть у меня функтов
принимает s, двойной отверсант.
А я передам ему arcs
просто так.
А это же будет lvalue ссылку,
я не смогу сбайнить.
Ну, короче, проблема, да.
Если мы не напишем move
у штуки с двойной отверсантом,
то они превратятся в обычные штуки
и просто не примутся в функцию.
Как наш случай
отличается от всех предыдущих,
потому что
в использовании forward
обычно вот так это выглядит.
У меня arcs, оно без
амперсантов. У меня
на arcs навешаны два амперсанта сверху,
а с forward я делаю arcs.
А тут сами arcs,
они с амперсантами могут быть.
Если я forward сделаю от них,
это будет странно.
Мы же хотим, чтобы в функцию
можно было принимать объекты по сути.
Вот допустим, у нас есть
среди arcs один с двумя амперсантами.
Вот мы передали в оператора,
и он здесь LV view.
Тогда он просто не примет его.
Будет CE.
Я бы даже и сказал.
Может сделать статикаст к arcs?
А если будет LV view,
то он скастует.
А он скастует, статикаст умеет делать
то же самое, что move?
А, секундочку.
Ну, кстати,
может быть.
Я, честно говоря,
не думал о этим местом.
Может быть, что и так.
Давайте я так напишу.
И
я оставлю здесь to do.
Вот так.
Я скажу вот так.
То есть, вроде должно работать
корректно во всех случаях.
Вдруг мы что-то забыли,
и влюбка там нужно красивее.
Ну хорошо.
Ну что еще? Копия.
А поля-то у нас какие?
Это private.
Это значит type erasure.
Теперь поля.
В полях мы храним B и звездочку.
Что?
F, наверное.
Да?
Да.
Вот.
И как мы ей пользуемся?
Если у нас
если нас создают
от какого-то объекта
function от
t
ну от const
f
Сейчас. Мы должны
научиться еще создавать
derived.
Что? Второй private пошел.
Нормально.
Ну я сначала private перечислил внутренние типы,
потом private начал перечислять поля.
Это быстроразделение.
А тут я напишу public.
А
ну конструктор.
Конструктор от чего?
От функтора,
видимо.
Да?
Это что?
Сойдет, наверное.
Ну, вроде.
Опять как
не понятно, как это все мувать.
Ну это
очень интересно.
Я думаю,
что да. Это не мысл.
Кто понимает, о чем мы делаем?
Я понимаю, что мы делаем.
А, что ты не понимаешь.
Нет, ну ладно, я тоже много чего не понимаю.
Как минимум это,
я тоже не понимаю.
Класс.
Нет, тут много проблем.
Мы пишем сейчас просто MVP.
Мы пишем такую вот
простейшую версию,
в которой куча проблем.
И эти проблемы мы будем решать
одна с другой. Но, видимо, завтра мы
пооптимизируем это.
То, что мы сейчас реализуем,
это далеко не...
Во-первых, сама SD-фанкшн,
в ней куча проблем.
И сам себе тип SD-фанкшн,
у нее есть недостатки
существенные.
Но нашему пока далеко даже не ее.
У нас есть структура,
которая недалеко до реальной структуры.
Ну, в смысле, реализовывали,
а стояли много раз подряд?
Пока нет.
Но SharedPTR будет довольно близок.
По счету.
Только там у вас не будет
empty-base optimization.
Но это нормально.
Он будет не совсем близок.
Он будет ближе, чем все остальное,
но все-таки, наверное, не очень близок.
Почему он список не ближе?
Ага, подкрой статуи.
Есть.
Кстати, может быть,
лист действительно довольно близок.
Ну, как?
Там, скорее всего, тоже есть
вот эти трюки
с Аллок Хайдер
и так далее.
Кстати, вроде
SD-фанк будет вполне себе прилично работать.
Не никаких целья, ничего.
Мне кажется, что мы что-то намудрили.
Потому что SD-форум, по сути, примерно то же самое
и делает, что мы сейчас написали.
Ну, например,
в чем, как я понял, сказать, что если
ARKS уже с двойной персоной.
Если функция принимает тебя
что-то по ссылке или по двойной ссылке.
Сложим ли мы в SD-фанкшн принимать
что-то по ссылке или по двойной ссылке?
Вот кажется, что да, все нормально.
И что SD-форум в данном случае будет работать
корректно.
Но что-то я уже запутался с вами.
Такой SD-форум.
Не, может реально запутали.
Ну, давайте пропустим эту часть
про формординг.
Мне тут больше хочется обсудить
другие детали.
Окей, мы создаем
мы учили ситуацию от функтора.
Но тут опять, конечно, есть история с тем
мы создаемся мувом или копированием.
Ну, надо мув конструктор
еще сделать.
Ну, то есть вот
у меня есть такая штука, да.
Вот, ну и чего?
Я говорю просто
что я здесь вот делаю?
В этом конструкторе
что я делаю?
Эээ, подожди.
Систэр функции, это далеко не самое все.
Ну, чекать имени не надо,
поэтому мы просто
вызываем под new.
Ну, надо
сказать new
F
derived
Вот. Ну, надо F
нацелезировать вот таким.
Да, F, да.
Ну, и тело пустое.
Вот.
Ну, соответственно, диструктор. Да, чего?
Такой стиль, как бы, вот с ног, это мы переносим.
Да, это нормально.
Это так нормально, да.
Да, это как раз так и надо.
Это как...
С оператора начинать новую строку.
Вот есть, кстати, еще вот такой.
Я еще рекомендую вам вот так делать.
Что это?
Запятую.
А, все, увидел. О, боже мой.
Ну, вот так. Давайте еще то, что мы вносили.
Ну, вот.
Ну, вот такой стиль
я очень рекомендую, потому что это
видно и удобно,
и добавлять новое поле удобно,
потому что самое главное, что вам не нужно
запятую. Вы с запятой
вы начинаете, а не заканчиваете.
Да.
Ну, просто...
Так, ну, что делает диструктор?
Ну, я делаю delete.
Что делает
конструктор копирования?
Копируют.
Ну, давайте скажу other.
Я говорю, что...
Так, мне нужно
сказать f это
что?
Это мое f
стрелочка getCopy.
Ну, там просто копия.
Давайте я скажу getCopy, а то, наверное, оно...
Наверное, other
f.getCopy.
Да.
Да, other
f.getCopy.
И, видимо, все.
Что это было секунду?
А мы свой не удалили.
Это же конструктор.
Справедливо.
Значит, b звездочка getCopy,
что будет делать?
Наверное, это будет константная функция.
Но она будет
возвращать new.
Собственно, derived.
Вот, наверное, да, пишу вот так.
И add.
Да.
Если мы...
А мы там не писали, ну,
какое шоу было, где мы дирали, когда new
делали в конструкторе, надо?
Где?
В конструкторе уже, ну,
function, вот тут.
А, здесь надо, да.
Дирается шаблон параметром f.
Большое это.
А он не повел у него же единственный конструктор от
const, functor, f?
Ну, может и сработается.
Лучше не бесковать.
Но я на всякий случай познакомусь,
потому что вдруг он поймет что-нибудь не то
и придет не туда.
Нет конструктора от base
звездочки.
Ну, вы пытаетесь это дирать от base
звездочки. Где?
Нет, я создаю, дираю звездочку,
а инициализирую, а возвращаю base
звездочку. Все корректно.
Это не явный кастинг для родителей.
Вот. Ну ладно.
Вот, окей.
Все то, что я сейчас написал, это...
Это база, да.
Это ковинушка.
Это тривиально. Короче...
Ой, что я здесь делал?
Смотрите, ну то, что я сейчас написал,
по сути ничего нового. По сути мы повторили
то, что делали неделю назад.
Просто теперь, просто с этими...
с функциями.
Вот. Но!
Это очень-очень плохая
реализация для function,
потому что она чертовски
медленная.
Потому что
если вы будете использовать...
Как правило, функции,
которые вы используете, они
небольшие.
И эта реализация
приведет к тому, что
на каждую функцию
новую вы будете
заново алоцировать.
Если вы используете сишный pointer,
или вы используете даже функциональный класс,
маленький компаратор, или вы используете
лямбда функцию, которая ничего не захватила,
вы всегда будете
алоцировать заново.
Это очень эффективно.
Поэтому для std function
как раз очень важную роль играет
вот эта вот small object optimization.
Мы хотим сделать так, чтобы у нас
не было локаций в случае,
когда мы можем уместиться
в какие-нибудь 16 байт, скажем.
То есть я хочу function
хранить не просто
вот это, вот.
А я хочу хранить
что?
Ну, указатель
на юнион.
Ну, вот как нам
организовать это дело?
Я хочу, чтобы
new, вот эта вот вся история,
да, кстати, еще с аллокатором наделать,
но аллокатора не будет.
Я обещал, что не будет аллокатора.
Я из-за этих аллокаторов
не могу спать.
Я реально спать не могу.
Я не понимаю, как это вскользь.
Я не понимаю, мне код устраивать.
Мне надо влезать что-то или не надо влезать.
А ты не забыл добавить аллокатора?
Что это такое?
Это.
Что нужно выдавать?
Последнее, пока Филипп не пришел,
придумаем что?
Здесь так написать, чтобы избавиться
от локаций, когда у нас тут
небольшой параметр.
Мы храним либо B-звездочку F,
либо что-то еще, видимо.
Но тогда мы не сможем
понимать, что именно мы храним.
Значит, нам нужно хранить B-звездочку F.
Просто нам нужен другая структура,
которая от B-а наследуется,
которая хранит что-нибудь клевенькое.
А как мы поймем, что она сейчас лежит?
Так мы могли бы сказать, или на B есть все равно.
Dynamic Cast, чувак.
Не знаю.
Нет, Dynamic Cast не очень приятно.
С звучит хайпово.
Сейчас сделать отдельного наследника,
который будет хранить всех
small челеков.
Но как это реализовать, не понятно.
Ну ты и small челек.
Человек не понимает, что этот челек small.
Оцени свою маленькую, да?
Да.
Ну, я
не знаю,
может быть, можно придумать что-то лучшее,
но то, что я предлагаю сделать,
это просто здесь сохранить отдельно.
Ну вот, к сожалению, так привез,
потому что надо будет тяжелее.
Это не круто, но, видимо, нам плевать на память,
нам главное время.
О, маленькая.
Ну, у нас function будет
не один указатель, а побольше.
И на самом деле
тут есть некоторый
обман.
Знаете почему? Вот здесь
все в пицце.
Ладно, не буду показывать.
Короче, тут бывают трудности
в случае, когда у меня
функция, функция
это указатель начлен, на самом деле,
pointer to member.
Это вообще проблема.
Если функтор это pointer to member,
то вот такая вот нотация
не будет
работать.
Но это мы потом
разберем. Давайте пока поймем,
что мы здесь храним. Здесь мы хотим
хранить, ну, прости
меня, господи,
а массив чаров что?
Значит, нам нужно хранить массив чаров.
Поможет не задавать массив чаров
хотя бы пять минут.
На стейке.
Но на самом деле есть более красивый
способ это написать.
STD вариант. Нет, STD
align storage.
Оу, е.
А что-нибудь...
Наверное,
нужно было раньше про него вспомнить.
Сейчас, давайте-ка я... А у меня интернета нет.
А, а, я не могу.
А, вот.
Прекрасно.
То есть, ну, как раз на этом
наверное придаваемся. Ну, короче,
что мы сейчас...
Какой план?
Ну, там два шаблон-фрагмента, len и align.
Ну, align это, наверное,
не обязательный.
Ну, да.
Align storage, не знаю, 16.
Бафф.
Значит, ну, все.
Какой план? В чем мы собираемся дальше сделать?
У нас есть вот это.
И дальше мы просто хотим...
Дальше мы просто вот этот
pointer, он будет
наверное уже не B из звездочка,
а B от звездочка.
Ну, я не знаю, надо подумать, чем он
именно будет, но этот pointer будет
указывать то на вот этот буфер,
то на что-то внешнее.
И мы будем таким образом понимать, если этот
pointer указывает на вот эту штуку,
значит, у нас локальная функция, мы ничего не
алоцируем. Если у нас pointer указывает на
что-то внешнее,
ну, значит, алоцируем.
Ну, и надо ивчики
будет расставить, соответственно, что там
когда мы алоцируем, когда нет,
когда мы должны пилить вызывать, когда нет.
Ну, ладно, тогда мы завтра
продолжим. Завтра у нас еще
предстоит нам решить проблему
с случаем, когда у нас pointer to member,
и еще одну
проблему, про которую я скажу потом.
Ну, в общем, все, пока.
