Всем доброго дня, мы с вами сегодня встречаемся на последней лекции.
И сегодня последняя лекция такая крайне интересная.
Она заключается в том, что мы возвращаемся к старой тематике,
но на самом деле мы сегодня немножко посмотрим новую тематику.
Это не странно, для того чтобы доказать старую тематику.
Значит, мы сегодня будем говорить про линейный селярный алгоритм,
и более того, мы с вами будем говорить про такое понятие,
как дет theCUBE детерминированный автомат с магазulinной памятью.
То есть нам нужно будет определить,
Что такое silhouette детерминированный автомат с магазе케
во-первых Vai direct vet,
и вы не поверите это разное определение.
И кстати у ceux, кто конечно был у меня на семинарах,
понимают в чем есть подвох.
Особенно как строить дет crocodile дет Lisa,
suspicious линейный автомат,
просто mp-автомат
просто mp, да
а говорили, что есть там
макер дна и вот это вот все
макер дна?
ну там элемент какой-то
черта с два
а, в плане элемента
который мы сейчас проявляем
да, да, да
так вот, оказывается, чтобы честно
распознавать слово в этом автомате
чтобы честно автомат нафигировать, ему нужно положить
символ конца слов
вот, если не положить, то
ничего работы не будет
да, это мы сегодня тоже докажем
значит, смотрите
давайте вспомним вообще, что у нас было
в предыдущих сериях, две серии назад
три серии назад
ну ладно, мы тут уже
проговорились, мы вообще
леоралгоритм доказали
вот, значит
доказали корректность леоралгоритма
более того, мы доказали однозначность леоралгоритма
и вот сегодняшняя цель будет как раз вести
новую конструкцию
и разобрать
как она работает
вот смотрите, давайте подумаем
пока мы не начали говорить
в чем будет состоять
детерминированность
классического ДК
что мы требовали для детерминированности
классического конечного автомата?
во-первых, это
буквенные переходы
а во-вторых
не было двух переходов по одной букве
да, не было двух переходов по одной букве
то есть
понимая, что у нас находятся
на входе
мы явно понимали, как работает наш автомат
давайте попробуем
сначала, прежде чем мы перейдем к другому определению
в определении ДК
убрать требование на однобуквенность переходов
тогда как, думаете, будет
выглядеть определение?
еще раз?
представьте себе, что в определении ДК
вы не требуете
однобуквенность переходов, но при этом
хотите, чтобы вы по входу однозначно понимали
префикс на свободное
префикс на свободное
то есть у вас не должно быть картинки такой
можно вас попросить
сейчас остановиться
я на пару минут прерыву запись звука
а то я заметил, что я записывал
звук через мобильный интернет
хорошо
что это?
плохо
оно уже работает
должно
скажите что-нибудь
раз, два, три
нет
сейчас я перейду в конференцию
колбасный цех 7
еще не произошел
кстати, совет
послушайте
а?
не-не-не, это не то
это, в общем
рэф вечеринка
так, теперь вам надо меня пустить
рэф вечеринка была в 70-х годах
ой, не в 70-х, в начале нулевых
нифига себе
так, теперь
разрешение на запись
ну, плюс-минус 30 лет 70-х
все, готово
в октябре было, кстати
20 лет отмечали
ладно, что, продолжаем?
да
так, возвращаемся
значит, префиксы свободны
что это означает?
это означает, что у нас не может быть переходов
таких, что у либо является префиксом v, либо v является префиксом o
вот такая картинка запрещена
а теперь давайте попробуем перевести это
в терминах детаминированности
в терминах mp-автомата
как вы думаете, что будет?
какое будет выполнено требование?
одновременно
согласованность стека и символа
то есть, смотрите
мы говорим следующее
давайте ведем следующий переход
определение, два перехода в mp-автомате
будут называться совместными
если у нас выполнено следующее условие
тут смотрите, важно правильно
это читать, по-моему
да, тут немножко
термины перепутаны, во втором месте
суффиксы должны быть не те
в общем
давайте определим совместные переходы
допустим, у нас с вами есть переход
значит
как пишут детаминированные
а?
детаминированные
можно
этот слово
детерминан взять
от него первые семь букв отрезать
а дальше написать ровные
итак, смотрите
у нас есть два состояния в mp-автомате
и нам нужно определить
когда мы не сможем ничего понять
но, во-первых
у нас должно быть выполнено условие
у1 является префиксом у2
да
а во-вторых
нам нужно понять, что у нас с вами
кажется
сейчас, по-моему
должен быть альфа2
если у нас
откуплю
так, смотрите
вот таких переходов быть не может
одновременно
то есть у нас получается, смотрите
если у нас
получается у1
у2
префикс у1
и одновременно
получается что?
альфа2
альфа2
суффикс альфа1
вот так
альфа2 суффикс альфа1
то есть тогда у нас
будет наручено, потому что
имея на входе букву а и на стоке b
мы не понимаем, что с вами делать
можем не понимать, что делать
то есть
получается у нас выполнено условие
следующее
либо 2
что такое это терминированный mp-автомат
в таком случае
как вы думаете
это mp-автомат без совместных переходов
да
это mp-автомат без совместных переходов
отлично
значит
это терминированный
вот это слово
значит смотрите дальше
важно следующее
теперь нам нужно определить
что такое терминированный
cs язык
это язык
это язык
в котором
смотрите
получается
это
множество слов w
таких, что
существует q
множество завершающих состояний
таких, что мы на входе читаем
символ w$
который не лежит в языке
и получаем
очищенный стэк
обращу внимание
символ $ здесь ваш
сейчас, это не то же самое
что у нас существует терминированный
мп-автомат
нет, не то же самое
для произвольных грамматик
что сделать
мы хотим сделать так
чтобы терминированные cs языки
были под множеством
классических cs языков
если мы с вами
этого не потребуем
то будет некоторая проблема
если мы не потребуем вот этого правила
я хочу сказать другое
логично предъявить терминированный язык
как тот для которого существует терминированный
мп-автомат его задающий
очевидно тогда это под множеством
это не работает?
нет, это не работает
сейчас будет некоторый пример
который задается
детерминированной cs грамматикой
в терминах вот таким
но не задается
детерминированной cs грамматикой
если мы с вами закроем символ $
давайте разберем такой пример
а что такое m в этом определении?
это dmp-автомат
вы строите
детерминированный cs язык
по автомату
да
и вот тот факт
который мы с вами не будем доказывать
если язык является
детерминированным cs языком
то он задается некоторой
однозначной грамматикой
а?
наша цель сегодня все таки не эта
а познакомиться с этим определением
итак давайте рассмотрим вот такой вот пример
и поймем что же в нем не так
а в mt и bnt
m равняется n
или n равняется 0
обвинение cs языков
обвинение cs языков
если мы даем обвинение cs языков
мы сразу нарушаем детерминированность
потому что у нас идет
2 ε на ε переходы
и мы не понимаем что делать
оказывается есть интересная конструкция
потому что если у нас есть
с вами символ $
смотрите
значит автомат
будет выглядеть так
а?
видимо понятно
то есть мы по доллару переходим в состояние
которое все стирает со стэха
а не по доллару будем стирать по одной буквы
да да да
сейчас я вспомню конструкцию
да
доллар должен бэшку за стэк есть
да
доллар может ничего не есть
просто мы потом соберем весь стэк и завершим
там состояние для b
либо перейти по b
и там уже есть по одной мысли
так
у нас m больше 0
или m равно 0
если m равно 0
то это их пересечение
то есть короче может звучать за день
у нас доллар отлучтен
согласен
так получается здесь что у нас
вроде нигде
совместных переходов у нас нету
хорошо
а теперь давайте подумаем что произойдет
если у нас с вами
нету стартового состояния
о нету доллара
в нашем слове
сможем ли мы построить такой
детерминированный ap автомат который
принимает слово без доллара
ну да
то есть смотрите
что здесь можно сказать
значит тут надо понять что
у нас распознаются слова
avente
и просто слова avente
да
что это нам дает
если мы съели avente
то дальше avente
это означает что если мы съели
слово avente
то есть в детерминированности
мы находимся в каком-то состоянии
вот
мы прочитали на вход avente
дальше нам нужно
собственно учиться читать
ну и дальше есть
какой-то путь
с каким-то стэком
который читает
состояние bmw
причем это состояние должно быть так
нет не обязательно это состояние должно быть
завершающее
сейчас
раскрутим
идея в том
смотрите сейчас расскажу в чем
а идея будет состоять в следующем
давайте воспользуемся принципом дирихля
и скажем что
слова вида avente у нас
задает большое количество языков
и из-за этого
как раз возникнут проблемы
потому что
у нас грубо говоря
по какому-то стэку
будет получаться слово avente
а потом мы
достроим это все некоторым
словом avente и мы проиграем
то есть у нас как бы из-за того что
конечно состояние у нас конечно
сейчас давайте я подумаю как это сделать
аккуратненько
так конечно
состояние конечно
состояние
до которого можно
идти двумя путями
по avente
но тут надо их именно как-то
тоже воспользоваться что у нас есть
слова вида avente bvmte
и слова вида avente
можно идти двумя путями
по avente
то до финала можно идти двумя разными bvmte
двумя разными bvmte
допомним у нас с стэком бесконечная
да-да-да тут со стэком есть проблемы
секунду
как же это лечится
что мы хотим доказать
мы хотим найти два состояния в которые мы можем
пройти под маковому стэку
причем это смотрите
идея такая что мы хотим
пройти до сюда
по словам вида avente и avente
хочется найти такой путь
что тут еще будет петля какая-то
то есть у нас есть avente
дальше есть петля которая идет в avente
и дальше мы
мы гарантированно знаем что мы можем
пройтись по avente
до пустого стэка
да
это слово лежит в языке
но с другой стороны
оттуда же мы должны уметь
пойти дальше по b
потому что мы еще не знаем
это конец слова
или нет
потому что у нас есть avente
да
да так
это что-то должно быть
а ну да
смотрите мы стоим в пустом стэке
и мы к нему пришли по avente
очевидно мы с пустым стэком
никак не сохраним информацию
точнее мы сохраним это состояние
а состояние конечного
и тогда мы не сможем понять сколько
флешек восстанавливается
сейчас я думаю просто
смотрите в чем может быть подвох
мы можем по факту
сделать следующее
у нас либо могут быть
переходы в духе epsilon a epsilon
а в другом переходе
допустим переход вида
а подождите
переход вида b
что-то там epsilon тоже не работает кажется
да потому что
ну еще раз у нас есть q состояний
возьмем q
плюс одно слово вида a в степени i
два из них придут в одно состояние
после считывания
вот и у всех
у них должен быть пустой стэк
да
точнее после считывания
и обнуление стэка
да да да
то есть сейчас
короче утверждение что раз автомат
терминированный значит
до того как считать int и pvnt
мы считали int у нас
какой угодно стэк а потом мы обязаны
его занудить и после этого
мы обязаны начать считывать qnt
вот так
потому что
терминированный автомат
значит
у нас каждый раз однозначно
сдающийся переход но при этом мы должны
уметь внулять
чтобы уметь принимать
Михаил прав то есть смотрите когда мы доходим
до финального состояния
то как бы мы должны
принять именно все слово
целиком то есть ключевое утверждение
то если мы приняли слова int
bnt
то у нас есть промежуточное состояние
да смотрите
если мы приняли слово avmt
bmt то мы таким же образом
должны принимать слово iavmt
любой его префикс
да потому что стэк
по словам мы должны понимать стэк
а на входе стэка пустое слово а не символ доллара
тогда давайте рассмотрим все
все состояния вида avmt
и поскольку у нас m достаточно
большое
то у нас существует два состояния
qxnx
qxnx
а дальше из этих слов
из этого состояния мы сможем с вами
прочитать как bvnt
так и bvnt
и в итоге у нас примутся два слова
где m не равняется n
то есть идея такая
по имеющему нас стэку
и по имеющимся выходу
который нам осталось прочитать мы четко знаем наши действия
не является контекстом свободным
в смысле
где мы здесь пользовались
детеминированностью
чего автомата
или чего
вот здесь мы пользовались
тем что мы как бы различили
какой у нас следующий символ доллар или b
да мы пользовались
ну в смысле да долларом
да
а так
если у нас просто детеминированность
то мы просто берем
разводим это
на две ветки
и каждый из них распознаем
то есть нам никто не мешает
чего?
то есть мы пользуемся всеми детеминированностью
в том что по выходному слову
и по алфавиту
по выходному
по слову который осталось прочитать
и по стэку который у нас здесь находим
мы четко восстанавливаем последность действий
вот такой пример
хорошо
так
возможно
да
эти значки
давайте смотрим на две определения
скажем что у нас запорядоченная пара
нет не там
внизу
смотрите второе определение
у нас же пары можно порядочить
вот так кажется
ну да ладно
можно вопрос
да
смотрите
давайте цель расскажу
цель вообще понять как ведут себя однозначные грамматики
которые можно было распознать конструкции
не связанные с грамматиками
а связанные с автоматами
вводим понятие логичное
который у нас есть детеминированный
это mp-автомат у которого нет
никаких развилок
вводим это понятие
и оказывается
что если мы введем
классическое определение mp-автомата
то оказывается
с ним будут проблемы вот для такого языка
поэтому чтобы этот
автомат был детеминированным
мы должны добавить символ
конца слова в распознавание
потом очистить стак
ну да для того чтобы потом очистить стак
если нужно
мы в lr-алгоритме
тоже добавили символ конца слова
напоминаю
то есть мы должны в автомат
еще добавить переходы с этим долларом
да конечно
ну а в общем случае
то есть у нас есть какой-то детеминированный автомат
и нам нужно как-то к нему добавить
переходы с долларами
смотрите тут история такая
что мы как конструкт
детеминированный автомат
вообще не привязан к символу доллара
но если мы хотим его привязать к реальной жизни
то нам нужен символ построить автомат
для слова плюс символа конца слова
то есть мы уже берем автомат с доллара
да да да
хорошо
так давайте докажем один факт
на самом деле он
не очень сложный
это упрощенный вид
mp-автомата
любой tmp-автомат
эквивалентен tmp-автомату
с переходами
выполнено такое соотношение
попробуем доказать
есть идея
как всегда
разбиваем ребра
надо разбивать
ребра с учетом детеминированности
мы говорим что
мы можем в нашем детеминированном mp-автомате
спросить чтобы у нас либо длина входа
либо длина выхода была
не более 1
длина входа либо длина стака не более 1
то есть у нас будут переходы вида
либо такие
либо такие
кажется кто-то уже понимает
намеку
собственно мы хотим это
провести все к шерптом и к редюсам
любой детеминированный mp-автомат
смотрите
что мы с вами говорили
давайте посмотрим
собственно
единственное
здесь нужно аккуратненько
рассмотреть
разного вида перехода
давайте начнем следующее
факт номер
пункт номер 1
если у вас есть
переход q1
q2b
то других переходов нет
если у вас есть переход
в состояние
в коде других переходов
в этом состоянии просто не может быть
а можете повторить
как мы сжали все это
в смысле все сжали
сжали многосрочные
мы сейчас как раз это доказываем
в смысле многосрочные сжали
в плане какая конструкция сама
конструкция
конструкцию я чуть позже сейчас
расскажу
нет
я сейчас просто покажу эту конструкцию
пока мы рассмотрим несколько случаев
в общем
случай номер 1
если у вас есть переход q1 и q2
q2b
то q1 больше переходов нету
вариант 2
значит у вас есть везде переходы
как разбить эти переходы
аккуратненько
чтобы не было проблем
с согласованностью
собственно идея
очень простая
раньше мы разбивали эти переходы
на
что у нас было
вот такие
вот у нас были переходы
то есть мы просто вкопали
сжав
да
на самом деле не совсем вкоп
здесь нужно будет аккуратно
все конечно сделать
потому что
если у нас есть переходы по буквам
то есть если у нас есть какой-то
префикс еще
у одинукатая
то мы должны
не нарушить согласованность
мы должны положить в тот же самый префикс
а дальше нужно
аккуратненько будет обрабатывать
эти конструкции по стеку
чтобы не было
не согласованных переходов
смотрите как это можно
хитро сделать
все знакомы с бором
даже будет там
хорошо
смотрите
строим бор для
для сигмы
для слова сигмы со звездой
для нанового перехода
строим бор
для гамма со звездой
сигма бор и гамма бор
да сигма бор и гамма
определим сигма бор и гамма бор
и дальше
делаем следующее
мы просто делаем переходы
допустим у нас с вами есть
переход у1 у2 и так далее
что-то там
мы делаем переход в
в вершину этого бора
точнее не в вершину бора
у1
то есть как бы из одного бора
переходим в другой бор
это мы вот так вот эти переходы совместно
аккуратно отделяем
а с декартово произведение этих боров?
не декартово они после сумма
я бы так сказал
то есть у нас есть бор
для чтения символов алфавита
есть бор для разбора стека
нам нужно аккуратно сделать
переходы из одного бора в другой
то есть по одному бору мы считываем
слова которые у нас есть со стека
а по другому бору мы снимаем символы
со стека
понятная идея?
да
на уровне идеи можно и оставить
это все дело
детали придумайте как и займено
на самом деле мы когда раскрывали
эти переходы мы делали ровно так же
мы же не доказывали формально
точнее у нас было
две строки возможно они вообще даже совпадали
у них просто были разные
суффиксы
так как мы
мы сначала
по ним
мы сначала по ним
прошли по префиксу
дальше либо второй поехал
либо эти префиксы у нас разъехались
это тогда все хорошо
либо разъедут эти стеки
либо один поехал дальше
другой поехал в другой бор
в другой бор
а вот как он поехал в другой бор
он на А1 поехал?
да он на А1 поехал
не на А1
а на Энтли поехал
тогда он на А
мы пока сжимаем только
УИФы
мы эти сжимаем
пока у нас есть общие чуваки
сейчас у нас суффикс должен совпадать
у этих
это мне нравится на 1 и 7
в смысле суффикс совпадает?
ну а 1-то
последняя буква
а, а 1 последняя буква
сжимаем
вроде нормально
сначала различаем
одним бором
да, потом различаем вторым бором
бор в квадрате
можно алгоритм сам еще раз
алгоритм
значит смотрим все
у нас есть состояние Q1
и смотрим все переходы
из состояния Q1
в другое состояние
а, слушайте я понял в чем проблема
я задетектировал
проблема Михаила
что у нас алфавиты могут
различаться, а стеки могут совпадать
ну там боров несколько
гамма боры на каждую бибетку вешать
ну это да
скорее всего это декарта во происхождение будет
ну я так и понимал
у меня затык в том
что мы во первом
не храним историю как мы до него дошли по УИТам
да, да, да
на самом деле гамма бор вешается
на каждый выход сепсвонбора
там свой гамма бор
там декарта
да, там декарта во происхождение
так
вы вышли из зума
на каждом выходе сепсвонбора вешается свой
гамма бор
ну да
я надеюсь я вернусь в свою же встречу
но если вы откроете ссылку
из переписки
он можно да
да, да, да
да, все, я вернулся
да, то есть нужно их в последнее соединить
то есть сначала
распознаем стек
да, да, да
да, то есть смотрите еще раз
значит мы сначала разбиваем
стек
да
а потом когда нам надо распознать
стек при разных суффиксах
если у нас префиксы разные
то мы различаем их на вот этом боре
если у нас уже
стеки разные
точнее
внутри эти слова являются одинаковыми
а стеки разными
то распознаем уже на различных стаках
да
то есть такая двухуровневая конструкция
получается
ну то есть на самом деле мы свели
согласованность переходов к тому
что мы берем
у ушки
записываем какой-то разделитель
и потом берем
перевернутые ашки
и нам нужно чтобы
вот здесь просто одной не было
чтобы вот это уже было беспринято
да, да, да
ладно, замучил я вас
на самом деле надо было
просто расходить все такие пути
и сложить все пути в вбор
и тогда нормально
да, это точно
в общем тут конструкцию можно
правильно переводить
главное что это распознать
да, а идея такая что мы в собственном модном строте
то есть мы делаем переходы совместно
за совместностью оказывается скрывается вбор
ладно, а теперь вопрос
тем-то какая лекция у нас сегодняшняя
LR
вопрос, а где тут LR
что такое LR
LR алгоритм
Эклер
ну LR
смотрите, утверждение
работа LR алгоритма
эмулируется работой DMP
некоторого DMP автомата
это логично
что
у нас в курсе LR алгоритм
есть слово или нет или разбор
есть слово или нет
по умолчанию, но в принципе мы можем написать
историю всего того что мы делали
получить разбор
ну вы на семинарах
писали вот эту вот штуку
вот она в принципе история
по ней можно легко восстановить работу
но для этого нужна другая конструкция
нет, ровно та же самая
написаны правила shift и reduce
по которым вы делаете
shift от считывания буквы, reduce от сворачивания по правилам
так
вопрос, а как
работает LR алгоритм
как его эмулировать
у нас был автомат
да, у нас был автомат
и мы что-то в зависимости
от наших действий
что-то делаем
смотрите, в качестве стека
вот тут важно
будем использовать стек LR алгоритма
который мы с вами храним
так, давайте еще
с откатами
вот это интересно
это кстати вот такой пункт
который я почему-то сам сразу
не распарсил
ну вот сейчас я попытаюсь
это рассказать
главное, что он должен быть еще
детерминирован
смотрите
давайте настроим
какую-нибудь грамматику
точнее по автомату
давайте что-нибудь простое
вы не против
если я нарисую LR0 автомат
потому что для LR1 на самом деле все будет точно так же
ну да, автоматы там будут
одинаковые
а?
да
разбор-то будет те же самые
тут везде доллар можно сделать
да
смотрите
если вот это у нас 0
1
2
3
то, смотрите, если у нас 3
и следующий символ доллар
здесь
то мы должны будем сделать
редюс по этому правилу
при этом что у нас
на стеке с вами хранится
то есть
при этом что у нас на стеке с вами хранится
давайте сделаем следующее
значит
если у нас операция shift
будет с вами
то что мы с вами сделаем
собственно мы берем
делаем переход
из куитова
A
и все
вот тут
вот тут
A
и на стеке, смотрите, кладем A
как эти нацить вот эти вот у строк
как сделать редюс
сейчас что еще раз мы shift
мы shift эмулируем вот таким вот образом
если мы из состояния
куитова по букве A
пошли в переход
go to в автомате
то на самом деле мы на стеку BMP автомата кладем A
и go to куитой от A
да да да
а вот с редюсом все хитрее
да, смотрите
давайте я напишу
в качестве примера
что мы делаем в качестве редюса
в качестве редюса
мы делаем
следующее
у3
значит
на стеке смотрите что у нас мы снимаем
мы снимаем с вами
Q0
A
Q1B
Q2CQ3
и кладем на стек
Q0 от
получается
S
Epsilon
а нет
подождите
мы кладем S
вот такую штуку мы кладем
то есть мы снимаем правую часть стека
и кладем
вот эту часть
то есть у нас
стек это тот самый стек
который был в алгоритме
и больше ничего на нем нет
а состояние
а состояние это что
вот эти состояния
это те же самые состояния которые у нас были
в этом DKA
тут осталось внимательно понять
почему не будет редюс-редюс конфликтов
поэтому нужно грамматику
ввести определение
не ну
для иллера грамматика у нас не будет
конфликтов почему потому что у нас есть
редюс-редюс конфликт то у нас
одно из правил
является суффиксом другого правила
стека в переходе
а shift-редюс конфликт у нас
ломается тем что
фришифте мы читаем букву
должны
прочитать букву а при редюсе мы должны
прочитать что то со стека
то есть это оказывает что
автомат будет стиминирован
мы можем либо
по одной букве его прочитать
либо по одному правилу его
свернуть
все а это значит что мы можем с вами
работать в терминах DMP-автомат
более того сейчас важный момент
состоит в том
что мы можем с вами даже
просить вот это вот свойство
у нашего DMP-автомата
для иллера алгоритма
можем
да то есть что у нас
вот это правило OK
а вот здесь
требовать что мы читаем ровно одну букву
со стека
да да да
а теперь
главная идея иллера алгоритма
когда мы снимаем со стека
мы же можем
сразу много букв снять
да
так там у нас не нарушится
а после этого мы приведем
ну мы сначала
встроим вот наш
наш детерминированный DMP-автомат
а дальше его приводим хорошим убедом
все
ну на самом деле видно что
эта зависит только от
вот эта конструкция зависит только от размеров алфавита
сейчас
на одном правиле редюс
нам надо вратить на Q0
мы же могли в один прийти по A с двух состояния
не не не мы
так
смотрите здесь важный момент
в том что мы рассматриваем все
такие правила редюс
да
и если бы мы пришли в какой-то момент
а кстати сейчас
каждому надо снять со стека Q0
да да да
надо со стека Q0 снять согласен
вот
вот это точно
вот
я бы даже возможно
при желании бы отсюда тоже
какой-то бы снимал
ладно то есть понятна конструкция
а теперь главная мысль
собственно а в чем
будет заключаться линейность алгоритма
давайте подумаем
ведь если у нас алгоритм
линейный
по времени от длины в слово
это означает что
вот давайте
поймал сколько у нас будет шифтов
всегда
шифтов всегда для нас слово
если мы докажем что
количество редюсов ограничивается
тоже на среднем на одну
букву
некоторые константы
сверху
то мы победили при этом констант
может быть очень большой
там более жирная константа
сейчас будем доказывать это
смотрите
а если у нас
количество правил
в среднем будет превышать эту константу
как вы думаете что будет
с нашим анализатором
нет если он даже
LR анализатор
по их лише не может быть
там будет wild true
в LR алгоритме
чего быть не может
то есть мы будем доказывать
что если у нас количество состояния
длина пути
будет больше
чем какая то константа
то алгоритм
зацикливается
а у нас он
зацикливаться не может
а мы доказали что он корректно распознает
да
такая идея
вот собственно основная теорема
которую мы сейчас
попытаемся доказать
так
ладно
значит
теорема
она заключается в том
что если L
длина самой
длинные строки
на стеке
так что у нас получается
у нас разве L
не всегда 1 или 0
на выходе по бете ограничиваем
здесь по этому ограничению идет
большая длина бета возможно
да
дальше говорит
что существует такая константа
которая зависит
как некоторая функция
это уже какой то дискран
наверное вам напоминает
такая
что
смотрите
есть конфигурация
что мы снимаем букву со стеков
и после этого количества шагов
мы с вами получаем
то
то
есть цикл
что означает цикл
это означает следующее
что у вас будет некоторое состояние
состояние
а поскольку мы работаем
по автомате
значит что алгоритм зациклится
на этом переходе
ну что давайте думать
то есть не давайте думать
давайте я вам расскажу доказательства
здесь надо рассмотреть длину
стека в пути
здесь есть два варианта
первый вариант
длина стека в пути
это вот эта длина альфа
которая у нас будет
с началом времени
первым моментом это длина стека не более
чем
модуль q на модуль гамма
на модуль r
и из этого будет
выводиться константа f
то есть представьте себе
что у вас
вот вы разворачиваете это все
по пути стека
и у вас длина этого стека
никогда не будет больше
чем вот эта вот константа
тогда если мы правильно
смотрите тут очень хитрый момент
возникает в том
что если мы правильно введем константу n
посчитаем это все
то по принципу дирекле окажется
что просто у нас есть две вершины
у которых стекса впадает
вот эта мысль понятна
что типа вот на этом месте мы с вами
можем задать константу
где мы n используем вообще?
n мы будем использовать дальше
ну то есть n мы можем сами
сколько угодно большим задать
главное чтобы эта функция была
вот она
там кстати пропущена
вот тут вот за n шагов
вот и второй вариант
когда существует путь
модулей
так
что?
два варианта рассматриваю
то есть длина стека в пути
я считаю здесь два варианта
первая это длина стека не ограничена сверху
вот эта константа
вторая в какой-то момент времени длина стека оказалась
больше чем такая
значит идея такая
здесь мы с вами будем просто утверждать
что есть константа и по принципу дирекле
у нас найдутся две вершины
с одинаковой вершиной стека
а вторым мы будем внутри
этого пути искать цикл
одинаковые стека
и видимо одинаковые состояния
да одинаковые стека и одинаковые состояния
тогда очевидно цикл
да очевидно цикл
так
я пожалуй извините
я тут должен
открыть конспект
потому что да и тут наверное этим тоже
можно будет пользоваться
так
значит
просто тут константа страшная
часограмма
какая неважно главное что есть
500 размер
грамматический квадрат
гамма в степени
это будет
надо же
диреклей воспользоваться
да
я должен сказать спасибо
тем людям которые все таки написали
этот конспект
а с нами поделитесь
да
поделимся
значит смотрите
N будет
равняться следующим
значит модуль Q
на
так это первый случай
сейчас идет
вот такая
вот
вот
то есть смотрите
что это такое
вот это
максимальное
число
стеков длины
не больше чем гамма
не больше чем
модуль Q
на модуль гамма на модуль A
понятно да
то есть мы перебираем все возможные
варианты стеков длины вот такой
модуль Q это количество состояния
в нашем автомате
но это означает
что если величина у нас
у нас есть
переход хотя бы за
Н шагов
да это значит что в какой-то момент
у нас просто два стека совпадут
типа если учить эту констату может быть страшная
но это самое такое что мы можем делать
ну да
этого достаточно
так
это первый
второй пункт
значит в втором пункте все интереснее
у нас
с вами тогда
существует
какой-то вывод
да вы блин задолбали
это не вам
это было людям которые пишут
в мессенджерах
вот я поэтому прошу
не писать большое количество
раз по одному сообщению
потому что происходит именно вот такое
так длина бета у нас получается
нужно просто не видеть людей
тоже вариант
вот то есть у нас получается
вот такая вот величина
а теперь смотрите
вот этот вот путь
который у нас есть
давайте будем отмечать
последнюю конфигурацию стека определенной длины
а мы сейчас уже предполагаем что мы свели к
а нет
да
да да да
мы по факту уже свели
потому что мы явно видите
используемся тем
что у нас буква одна у нас со стека снимается
да мы свели к тому
виду что у нас сумма переходов не больше
чем один
так вот
так вот
так вот
к тому виду что у нас сумма переходов не больше чем один
значит
смотрите
идея отметим
последние конфигурации
длины g
в пути
то есть что это означает
это означает следующее
что вот у нас здесь есть путь
у нас написано правая часть
то что мы кладем на стек
и вот отследим последний момент
когда в этой части на стеке у нас лежит g
мощность слова длины g
хорошо
а тогда сколько у нас таких отмеченных ситуаций будет
нет
нет
утверждение будет отмечено
хотя бы модуль q на модуль g
плюс одно состояние
давайте я тут картинку
нарисую
смотрите
шкала времени
здесь у нас единичка
это символ a
это длина стека
значит здесь у нас получается
следующая вещь
вот это вот у нас
длина бета
а и длина бета у нас больше
равно чем
вот эта константа
насколько мы можем каждый раз
подниматься вверх
это ограничено сверху l
вот
l это длина
самые длинные строки на стек
которые мы кладем
то есть у нас вот эта вот величина
каждый раз растет не больше чем на l
логично
ну хорошо
а теперь смотрите в чем
интересный момент
значит тогда мы
отметим
хотя бы
плюс
плюс одну ситуацию
мы отмечаем последнее вхождение
какой-то длины
стека
то есть мы отмечаем последнее вхождение
длины ровно g
в нашем пути
для всех g
мы утверждаем что у нас разных длин
да
у нас разных длин
смотрите
то есть смотрите
наша цель добраться
по отмеченным вершинам
от единички к модуль бета
значит смотрите мы отметили
хотя бы столько позиций
так а это что такое
сколько у нас состояния всего
модуль q
а это значит что в какой-то ситуации
у нас с вами по отмеченным позициям
во-первых у нас
длина стека не уменьшается
секунду
а что нам еще дает отмеченная позиция
последняя отмеченная позиция
это очень важно
что означает позиция отмеченная
это означает что
после нее
стек только растет
последняя позиция
последняя позиция
последняя позиция отмеченная
с длиной g
возможно он только падает
мы с единички начинали
смотрите в чем фишка
если мы падаем то на единичку
только
можем на 2 упасть
на 1 и еще на 1
и так мы можем
подниматься каждый раз на l
и потом падать на l-1
пилой
расти
нет отмеченных позиций
все равно будет столько
нам важно чтобы
еще стек под этим подмеченным позициям
и не поменялся
мы рассмотрим ситуацию
когда мы заходим в d
вверх
вот у нас есть путь
и мы смотрим его премикс
до момента когда мы вышли в b
еще раз
говорим следующее что у нас будет 2 отмеченных позиций
у которых последняя буквы на стеке
совпадает
еще раз мы отмечаем позиции которые
но последняя позиция с такой длиной стека
или у нас
почему он просто
растет
а?
почему они
не могут убивать
а может убивать
у нас
скрета не прирылась
у нас скрета не прирылась только вниз
ну вот у нас помеченная позиция
когда мы вниз
но мы все еще остались выше, чем они
ну да, нет, тут важно, что
он стоит больше, чем
да, тут получается, смотрите
если тут допустим, здесь
а, да, а здесь что-то, плюс еще
что-то, плюс а, и вот это что-то
оно у нас
не меняется уже
да, но та позиция,
в которую мы спустились может быть
отмеченной, может быть
еще раз
куда? у нас вон так
вершина горки может быть тоже
отмеченной позиции
а, вот эта?
а, ну да
после нее мы вместе
она тоже может быть отмеченной
да, действительно
так, сейчас давайте подумаем
можно ли этому быстро полечить
можно поменять определение отмеченной позиции
но тогда вопрос
сколько их будет?
да
да, тогда их будет мало
ну не знаю, мне хочется записывать
не сразу все это, а
по одному
ну вот такое тоже можно сделать
сейчас, если мы будем говорить
что это
нам важно, чтобы стэки
чтобы все, что находилось под стэком
совпадало
почему?
ну потому что тогда мы, собственно, получаем
топливо для
дальнейшего движения
так, хорошо
две отмеченных позиции
главное, чтобы каждая отмеченная позиция
вторая отмеченная позиция шла
после первой отмеченной позиции, выше
нее, тогда мы доказали
все три могут быть отмечены
ну да, ну смотрите
если у нас такая картинка
здесь у нас стэк не менялся
а, смотрите
фишка в чем?
вот представим себе
что у нас есть
отмеченная позиция, да?
и вторая отмеченная позиция оказалась
после этого и ниже, чем
текущая
вот смотрите, мы поднимаемся всегда
как минимум намного, а спускаемся
на один, это значит в какой-то момент времени
мы пройдем через этот уровень еще раз
мы можем дальше не спускаться
мы можем не подниматься
после отмеченной позиции
мы можем спуститься
то есть утверждение, что типа
мы чисто спускаемся
а потом прыгнем вверх
но мы можем видимо взять
давайте скажу следующее
а тут есть лайфхак
мы просто заменим нашу отмеченную
на минимальных пути, она только ниже
смотрите, здесь кстати есть
очень тонкий лайфхак
он очень важный
я его произнесу
он заключается в следующем
оказывается, что количество таких ситуаций
вообще ограничено сверху
давайте сделаем это другому
давайте сдвигать
отмеченные позиции как можно правее
вот у нас есть две позиции
если мы прыгаем вниз
то она сдвигается, но у нас все еще
остается их вот столько штук
мы просто сдвинемся
мы просто сдвинемся
направо, насколько можно
ну да, вот смотрите
есть несколько вариантов
как это обходить
вариант номер один
что означает, что мы спускаемся вниз
это какой переход у нас получается
нет
важно, что это тогда у нас будет переход
вида унитая
епсилон а
епсилон
таких переходов ограничено количество
ок, ограничено
что с того
это значит, что мы в эту константу
можем внести ограничение на вот это количество
таких переходов будет не больше
чем модуль n, а модуль q
а давайте возьмем лексик графическую минимальную
последовательность из отмеченных вершин
зарастающих
вот да
давайте возьмем мвп
в этой последовательности отмеченных вершин
и все, это понятно
на мвп кажется будет
длина у него кунагава плюс один
короче, просто хочу сказать
вы предлагаете наименьшую
минимальную из таких позиций
чтобы каждый спик уменьшал
да, а при этом
длина у нас плыть зависит от
модуль q, модуль гаммы и модуль l
мы сначала зафиксировали путь
от одного до бета
в нем есть вот столько
отмеченных позиций
а теперь мы берем
просто
нижнюю огибающую
вы предлагаете брать мне больше возрастающую
подпасительность
с ограничением
да, ладно
но в целом
давайте спрашиваем, понятна ли вот эта идея
ключевая идея просто какой-то
полуинвариант брать
да, полуинвариант, в котором при этом у нас
стэк будет совпадать
а сколько у нас прыжков вверх будет?
сколько прыжков вверх будет?
как минимум
q на модуль гаммы плюс один
если мы берем
прыжка вверх
вершина с прыжка вверх
понятно, что низ
из всех отмеченных мы смотрим
прыжки вверх
после прыжка вверх
максимальную подлине
среди них легзографически наименьшую
можно так, да
хорошо, ну в целом
смотрите, что мы с вами получаем
мы получаем с вами, что если у нас
в итоге
если у нас существует такая константа
за какое-то количество шагов
и внезапно
эта буква a со стэка
оставляет что-то еще
на стэке
то мы зацикливаемся
вы понимаете теперь
что это приведет нас
по факту доказательств линейности
алгоритма
еще раз
мы не доказали
еще теорию уже
в смысле?
мы не доказали, потому что
смотрите в чем вещь
вещь стоит в следующем, что
если у нас, смотрите, хотя бы вот столько ситуаций
есть, то по принципу Дерехле
существует два состояния
у которых
одинаковые вершины, одинаковые верхние буквы
да, а еще стэк под ними лежит одинаковый
нет, вот стэк одинаковый
стэк одинакового там не будет
нет, смотрите, q1
получается epsilon alpha
a
и q1
epsilon alpha gamma a
вот такой стэк у нас будет
ну и все
мы из этого в этот пришли
у нас будет линейный конечный автомат
сейчас
альфа
он за разрастами пошел
вагабу можно в ванную стеклю звонить отсюда
а зачем намаг конца?
ну чтобы дальнейшие действия были по циклу
ровно такие же
сейчас, у нас зависит от вершины, которая первая на стэке?
конечно
у нас переход зависит
нет, мы же ее снимаем только
сейчас
мы снимаем, а потом что-то еще кладем
а почему мы не можем два раза снять?
почему мы не можем два раза снять?
почему нам только вершины?
кажется да, можно просто без дала сказать
что если у нас была
два состояния, у которых
альзаковая вершина
и мы вывели состояние
с большим стэком
ну да, но главное, чтобы потом
мы дальше двигаться могли по ним
у нас может быть движение
у вас стэк только растет из этой вершины
если вы вышли из этой вершины, стэк только растет
это состояние
из отмеченной
да, это состояние из отмеченной
тогда нам они нужны
ну да
потому что если мы из стэка
можем что-то забирать, то они достаточно
потому что можно забрать несколько раз
а если мы можем ничего забрать, то у нас
стэк не влияет
да, согласен
так или иначе
мы в итоге доказали теорему
с поправкой
на некоторые ограничения
то есть мы можем экспонент
в корень гаммы степени взять?
мы можем просто гамму в эту степень
выводить все
у нас выводится бесконечный стэк
то есть смотрите, у нас выводится бесконечный стэк
а теперь
после этого, как мы это все сделали
мы можем наконец-таки доказать
линейность
или оргаритм
я скорее про то, что у нас была оценка на n как гамма
мы можем изменить на гамму в степень гаммы л
а мы можем изменить на гамму в степень гаммы л
ну да
так смотрите, теперь линейность
как доказывается
значит у нас есть операция шифки
и есть операция редюс
ну, этих понятно, что
будет длина нашего слова
да
у нас есть утверждение сверху, что
это будет
не больше, чем
смотрите
модуль гамма
так, сначала не больше, чем длина нашего слова
умножить на вот эту константу n
умножить еще на некоторую
небольшую константу c
да, блин
так, это задал...
я же не угадал
да
да
так, это...
режим
да
можно общая режим
ну да, хорошо
так, смотрите
количество шифтов сверху такое
количество редюсов сверху будет такое
собственно, как это доказывается
методом потенциалов
мы вводим потенциал
под ситуации
значит, смотрите
число
число терминалов на стеке
число нетерминалов на стеке
и утвоенное число
непрочитных букв
и утвоенное число непрочитных букв
значит теперь фишка стоит в следующей
по-моему есть презентация
а в чем смысл складывает число терминалов
в не терминальных, когда будут для нас теков
В чем смысл складывать числа терминально и по числу не терминально как-то для нас тега?
Ну, не всем стоит, смотрите.
Теперь идея.
Значит, когда мы делаем операцию shift,
то внезапно,
смотрите.
Большой вопрос.
Вот мы в теореме,
у нас тег был изначально
не пустой кажется.
Сейчас.
Не, мы говорили, что мы начинаем с одной буквы какой-то.
Это на stack.
Да.
То есть мы говорим, смотрите,
давайте суть теоремы,
что если внезапно у нас был
stack какой-то длины,
определенной,
и через определенное число шагов
у нас stack по длине
не уменьшился,
то мы зациклились.
Вот в чем
суть этой теоремы.
Мы доказали,
что если у нас stack
из одной буквы,
то...
Ну, смотрите, где мы этим пользовались.
Мы хотели, чтобы длина stack
была по...
А, ну...
Ну, по факту...
Если у нас изначально длина stack была большая,
то мы не сделаем высоких шагов, чтобы у нас было
своих отмеченных вершин.
Почему?
Сейчас.
Мы, видимо, хотим
у нас длина plus один плюс уже
обывшая длина stack.
Да, наверное.
Да, наверное,
я согласен.
Давайте я сейчас как раз расскажу
вот этот факт. Там, на самом деле,
чуть-чуть точнее оценку нужно сделать.
Но в целом
главное, чтобы понять идею.
Смотрите. Давайте складывать.
Значит...
А, это...
Да, смотрите.
Значит, при
операции stack push
вот это на один увеличивается
в числоне терминалов
на stack.
Вот это увеличивается
на один... Ой, на ноль.
А третья величина
уменьшается на два.
Вот это логично?
То есть, вот это на плюс один,
вот это на плюс один, вот это на минус два.
Ой, плюс один, ноль, минус два.
При операции shift.
Да ведь?
То есть, в итоге минус один.
А теперь важный момент.
Отметим
правила
ситуации, в которых
stack уменьшился относительно
предыдущего.
Уменьшением stack.
Значит, смотрите.
А число терминалов и не терминалов
на stack уменьшится
будет минус один, как минимум.
Меньше равно минус один.
Количеством непрочитанных букв останется ноль.
В итоге потенциал у нас уменьшится
на минус один.
А будем отмечать последние ситуации,
в которых для нас stack растет.
Да?
Окей.
Какой изначально у нас потенциал?
Два длины слова.
Два длины слова.
В конце?
Ноль.
Да, ноль.
И вот между такими вот ситуациями у нас
длина stack уменьшается.
Ну, длина потенциала уменьшается как минимум на один.
Ну, типа.
Типа.
А теперь подумайте, что такое
reduce с уменьшением stack относительно входа?
Если у нас reduce идет
с неуменьшением stack
в какие-то моменты.
На самом деле, здесь константа
не двойка,
а сильно больше.
Вот это как раз цель.
Вот откуда эта константа
и возникает.
А дальше делайте следующую вещь.
Что означает, что вы делаете
reduce, операции с reduce
с неуменьшением stack относительно
какого-то момента?
Из одного не терминала в другой.
Из одного не терминала в другой, либо
ну да, по факту.
Не, это правила типа вида AB.
Смотрите,
это правила вида, значит,
из Sv Epsilon.
Вида из A в Epsilon
и правила вида из AB.
Они могут порождать большое количество
правил, они могут разрастаться.
Вот таких правил, кстати, ограниченное
сверху количество.
Вот, поэтому здесь
не константа 1,
а больше.
Потому что их нужно учитывать.
Вот,
то есть мы с вами
поймем
следующее, смотрите,
что если у нас в какую-то ситуацию
встретилось вот это правило,
и мы попали в эту ситуацию
два раза,
в одну и ту же, мы зациклились,
то есть если в двух
разных ситуациях,
мы попали в одно и то же состояние
и нам нужно применить
редюс по этому правилу.
Да, то есть это получается
у нас как раз
замыкание будет здесь,
поэтому здесь константа не единичка.
А второе, что у нас есть,
а теперь вот эти правила.
Давайте посмотрим.
А их же тоже ограниченное?
А их тоже ограниченное сверху,
но даже несмотря на то, что эти с этим
растут, длина стека у нас
не уменьшается.
А это значит, что если количество
шагов, которые мы сделаем,
будет больше, чем это большое,
то мы зациклимся.
Значит, тут сверху у нас будет
вот асимптотика
вот этого у от 1,
вот это асимптотика
n на c.
Плюс один, скорее всего.
Ну вот мы получаем
с вами
линейную асимптотику алгоритма lr.
Вот так вот теория.
Линейная билайк с константой
стремящейся к конечности.
Да, lr таблицу
собственно можно найти в интернетах,
они обычно константы
картинка 10 тысяч на 10 тысяч пикселей
или таблица для грамматики
какой-нибудь.
Вот, в общем мы с вами закончили.
Я надеюсь вас не сильно
перегрузил, но вот такая вот
интересная теорема, которую впервые
реально мы доказали.
Не бойтесь, нас перегрузили до нас.
По ходу курса,
я думаю, что это было крайне
интересное, хотя
хоть что-то нетрегальное.
В отличие от самого lr, это часть нормальной.
Я, кстати, разобрался с lr
только пока его писал.
Надо было выбирать
Тиор Платон.
У меня больше шансов дать нормальную
экзотику.
Так, спасибо большое, что
на самом деле ходили на лекции.
У нас даже ряд вроде разошелся.
Что?
По количеству. А сколько на потоке?
2, 4, 6, 8, 10, 12, 13.
Вы считаете проценты посещения?
1,15 или больше здесь
есть потока?
Нормально.
Аппроксимация не бесконечность.
Давайте скажу, что нового в этом курсе было.
Мы на самом деле убрали одну лекцию,
но при этом заменили ее нормальным
доказательством lr-алгоритма.
Вот, раз. И второе, что мы добавили
тиремахонского шуцембиржа,
которая была в прошлый раз.
Тоже.
Замкнули наш курс в итоге.
Значит, на экзамене выиграть победили.
Ну, да.
Это самое сложное, кстати, вспомнить сначала.
Поэтому, если есть вопросы, задавайте.
Вот.
А так, всем большое спасибо за курс.
Чем более тики горят, тем больше
заблагодарят.
Забирать 20 тирем, как обычно было так.
Ну, понятно, как назвать.
Там будет тема на досроке.
Там будет тема на досроке.
Если что, попросите конспект.
Скажем спасибо Виталию,
который написал этот конспект.
Это конспект Виталия?
Да.
Он же по Ахаульмуру читает?
Нет, про линейный lr-алгоритм.
По Ахаульмуру, но линейный немного проще.
Нет, там новый конспект был написан.
Где он раньше был?
Там раньше был, когда у нас просто lr.
Ну, lr я читал по другому конспекту.
Все, спасибо всем большое.
