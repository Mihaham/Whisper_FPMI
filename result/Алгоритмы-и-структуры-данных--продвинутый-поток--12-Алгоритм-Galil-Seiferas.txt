Мы с вами попробуем повысить планочку, потому что, смотрите, мы говорим о задаче поиска подстроки
в строке. Мы с вами уже изучили там уже даже целых два способа, не считая фешей, как это
сделать, собственно, за ООП дополнительной парити. Убедились, что и в зете, и в префексе, в общем-то,
ООП предоставчит. Но идеал, но, конечно, тут может разходиться больше, но идеальный
алгоритм, конечно, потребовал бы тогда, ну, куда уж идеальный, так, конечно, казалось бы,
мы ищем подстроку в строке за ООП суммарной длины строк, то есть за ООП года. Можно лучше. Да,
но можно лучше. Можно сделать, можно как бы, совсем идеальный, чтобы за ту же самую
асимптотику был еще и за ООП дополнительной памяти. Ну, на самом деле, конечно, если мы,
конечно, верим в хэши, то забегаем вперед, скажем, что такой способ, конечно же, есть.
Ну, вот, действительно, потому что, вообще, ну, потому что пробежаться там, этим вот там,
условно, окошков там, или каждый подстроки длины П, собственно, там, оперативно поддерживать
его хэш, это, собственно, не такая большая проблема. Но этот метод такой, полувероятностный,
полуподхачить шмысла. Вот, поэтому мы сегодня начнем приближаться к этому. Значит, действительно,
существует идеальный алгоритм, статья, по которому, значит, была получена в августе 1981
года, собственно, таким журналов как Journal of Computer and System Science. Вот, но, как говорится,
да, видимо, называется review, но прошло в июле 82-го. Так что, ну, так что, да, нормальная ситуация,
что если вы послали статью, то журнал ее посмотрит когда-нибудь там месяцев через 20.
И в этой статье, соответственно, описано, как искать подстроку в строке, ну, как минимум,
отвечает на уровне, входит ли это подстрока в текст, входит шаблон в текст как по строкам,
да или нет, хотя бы. Хотя, по факту, он, в общем-то, и все обхождения тоже, вроде как, найдет. Ну вот,
и использовать будем при этом от единицы до полнительной памяти. Ну, честно скажу, нам не
удастся же сегодня полностью изучить этот алгоритм. Ну, да, почему? Вот, ну, там, к сожалению,
ну, во-первых, алгоритм сейчас не тривиальный будет, а с другой стороны, это еще выясняется,
что, к сожалению, в каком-то месте авторы начинают отсылаться, собственно, на тоже
какую-то другую свою статью, в которой они тоже что-то делали. Вот, поэтому мы сегодня только
сделаем некоторый наскок в этом направлении. Очень надеюсь, что нам в будущем удастся,
собственно, и добиться этого. Ну, в любом случае, ну, так или иначе, это интересно, по стоку, по
скоку, нам тоже удастся еще в этом месте подумать о каких-то интересных свойствах строчек. И там всякой
переводи. Значит, давайте попробуем вести для этого некоторые понятия. Так, какие же, значит,
понятия мы введем? Так, ну, во-первых, да, как это, в некотором месте, да, на всякий случай еще скажу,
что, тут мы берем слово, как говорится, американским коллером, собственно, одного коллера зовут
Галю, второго будут звать Джоэл Сейкерс. Ну, как американским? Ладно, первый представляет
с одной стороны Тель-Авивский университет, с другой стороны департамент компьютерсайнса
университета Коллаби. Второй представляет отделение компьютерсайнс университета Родчерс, это тоже Нью-Йорк.
Правда, видимо, в одном случае, во втором случае это просто Штаты, в другом не только Штаты, но и
в диаграфии Соединенных Штатов я, к сожалению, плохо не знаю. Вот, значит, вот попробуем смотреть, что же они нам
предлагают. Ну, предлагают они нам примерно следующее. Первое, что мы сделаем, это, внимание, введем
мистическую константу K. Значит, ну, тут специально, вот они ее отдельно выделяют как K, да, по факту она будет
4, хотя в принципе алгоритм может работать и там для K равно 5, 6 и так далее. Ну, с чем-то подобным мы уже
с вами сталкивались, когда искали медиа. То есть там делим на пятерке, но по факту могли, как мы уже
выяснили, делите на семерке, на девятке, в общем-то, проблем бы не было. Вот, соответственно. Ну, вот такая
мистическая константа. Смысл ее, на самом деле, будет очень интересен. То есть, когда у нас есть какие-то
строчки, нас очень будет в каких-то строчках интересовать ее префиксы, у которых есть вот
K одинаковых блоков в начале. Ну, вначале так. Тут, конечно, длины этих блоков могут быть разные, но вот разные
длины нас как-то интересовать и будут. Вот с этой точки зрения она будет очень интересна. Значит, смотрите.
Ну, во-первых, сразу скажем, что мы будем жить с вами в один индексации. Вот, вот там есть какие-то подстроки.
Значит, еще сразу введем определение. Значит, строка Z, вот они тут очень оригинально пишут, смотрите.
Строка Z будет называться периодом строки, период строки S, если определение такое S, префикс строки Z в бесконечной степени.
Ну, что, собственно, равно. Просто Z, Z, Z, Z, Z. Вот такое оригинальное определение.
Вот. Ну или вот эквивалентно, но здесь они сразу же приводят, что это эквивалентно, то есть вот это вот
утверждение, на самом деле, оно эквивалентно тому, что строка Z период, точнее, не период, а префикс.
Соответственно, S, префикс строки ZS. Ну, думаю, эквивалентность этого очевидна.
Ну, понятно, что это эквивалентно тому, что, конечно, тут можно правильную Z функцию, конечно, сказать.
Ну, можно еще просто сказать, что там что-нибудь еще в духе нам сегодня пригодится. Допустим, Z от, так сказать,
то есть это, да, не путать Z функцию с этой строкой Z, да, проявить, наверное, другую звуку, ввести на всякий случай, но уже ладно.
Ну вот, что Z функция с индексом S от Z плюс 1, соответственно, должна быть равна модуль S минус модуль Z и, ну и, конечно, Z префикс S.
Хотя, заметим, что формально, по такому определению, это неправда. Почему неправда?
Да, на самом деле, заметим, что по такому определению вполне может быть, что Z даже длиннее S.
И это нас исправит. Вот. Так что тут придется тогда написать или, не знаю, S префикс Z, ну вот такие всякие оговорки, но это уже мелкие.
Ладно, общую судьбу мы поняли. По факту, наверное, периоды длиннее S мы, в общем-то, рассматривать особо и не будем.
Вот. Так что, да, значит, теперь еще одно определение. Значит, еще одно определение, которое нам потребуется.
Что называется? Пусть P, значит, у нас это целое число от 1 до модуль Z, модуль S, пардон, тогда мы введем такое понятие.
Рич с индексом S от P. Рич с индексом S от P это равно, ну, в формале так, это равно максимальному такому Q.
Значит, Q должно быть меньше или в равно модуль S. Вот. Где, соответственно, вот этот вот, где вот префикс P, вот S, это период S.
Вот.
Вот теперь внимание вопрос. А чему это, как вы думаете, чему это равно в терминах Z?
Видел мы даже назначение Z функ P plus 1 и прибавить. Да, совершенно верно, это равно. Ну, раз уж мы живем в 1 индексации, то это P plus Z с индексом S от P plus 1, да, совершенно.
Знаете, вот еще одна интерпретация. Это вот что такое Z функция. Это называется, мы хотим рассмотреть префикс, который периодичен с периодом P.
То есть Z функция нам указывает, где эта периодичность будет заканчиваться. Еще одно такое интересное определение. Вот такое понятие нам потребуется.
Так, значит, далее, значит, у нас тут, да, я вот попытаюсь тут написать все необходимые понятия вот на этой доске, а на другой доске будем пытаться что-то умное делать.
Потому что тут, да, тут есть какие-то нетривиальные достаточно понятия, нам придется думать. Значит, внимание. Еще одно определение.
Строка S называется базовая, если не существует такой строки Z.
Ну ладно, лучше T давайте напишем. А то они любят вот Z и это, но они Z функции не функционируют.
И не существует T и такого числа И больше единицы, такого, что S равно T в степени B.
Ну, в переводе говоря, S нельзя представить как кондонацию двух или более одинаковых строчек. Понятно, да?
Ну, то есть, вот, например, типичный пример, который тут любят авторы, например, вот AB, AB, AB, например, она, очевидно, не базовая, потому что она получается AB в кубе, видите, да?
Но при этом вот AB, AB, AB, A, она вполне себе базовая.
Да, вот есть такое вот базовое строка.
Так, и вот тут сейчас будет такое совсем мистическое определение, в котором, наконец, вот эта константа H начинает играть.
Она на стопу вообще так начинает играть, как будто хоть ее отдельным цветом выносить.
Значит, определение.
Будем говорить, значит, строка T это префиксный период, да, внимание, новое словосочетание, префиксный период.
S, новое слово.
Если, значит, выполнены, тут я давайте уже аккуратненько два пункта напишу. Во-первых, T базовая, это вот, во-первых, базовая.
И, внимание, T в степени K, префикс S.
Обратите, вот сразу обращаю внимание, ну, собственно, то есть я авторы обращаю, что, обратите внимание, префиксный период строки S, при, там, периодом, прям, всей строки S быть вообще не обязан.
То есть вот такая вот интересность.
Ладно, будем жить в той терминологии, в которой будем жить.
Вот, ну, например, вот тут можно еще приводить. Вот давайте, а, ну, в принципе, заметим, что это можно, то есть, на самом деле, есть эквивалентность.
То есть, на самом деле, эквивалентное определение такое.
То есть, эквивалентное определение такое.
То есть, на самом деле, вот эта система эквивалентна такой, что, значит, T у нас префиксный период, если T базовая, значит, T префикс строки S.
И, соответственно, можно, вот, терминология, это reach от модуль T, на самом деле, больше либо равен, соответственно, K модуль T.
Чтобы, может быть, немножко поиграться.
На самом деле, ну, я мог бы то же самое через Z функцию написать, но лучше, наверное, через reach.
Понятно, да?
Понятен?
То перича.
Ну, вот, ну, значит, что у нас тут есть?
Значит, ну, в принципе, можно, на самом деле, еще тут тоже поиграться.
Да, вот с этими базовыми, поняли?
Да.
Кстати, какие периоды вообще есть у этих строчек?
Давайте уж, если последовать на по всем определению прибегаться.
Какие периоды есть у строчки AB, AB, AB?
AB?
Так, AB.
AB, AB.
AB, AB, AB.
Ну, да.
Ну, на самом деле, это не все.
Как вы уже выяснили, любая строчка с префиксом AB, AB, AB является периодом.
Да.
Вообще, можно убедиться, что вот у этих двух строчек, как это ни странно, вообще абсолютно одинаковые периоды.
Ну, обратите внимание, потому что AB, AB, AB, AB, AB это тоже период.
И этой строчке тоже.
Ну, сразу у первой строчки есть период AB, AB, AB, AB.
AB, AB, AB.
Ладно, все, набрал, набрал.
Неправ одинаковые нельзя сказать, да.
Но можно отметить, что у этой строчки период AB, AB, AB, AB вполне есть.
Хотя, да, AB, AB, AB.
Вот.
Ну, и тут можно действительно поразвлекаться еще.
Потому что, вот давайте рассмотрим строчку, допустим, S равную, смотрите, AB, AB, AB, AB.
А в степени K.
Вот то самое K.
Давайте попробуем поиграть в эту штуку.
Чему равно reach относительно S от единицы?
Единицы.
А чему равно reach S от двойки?
Шести.
Шести.
Шести.
Даже семьи.
Семьи совершенно верно.
А, там же.
Да, да, да, там А.
Но дальше тоже А, поэтому, поэтому на этом настанавливаемся.
Если я напишу reach, вот, семьи.
Семь К.
Семь К.
Вот.
Ну, да.
Получается, да, с точности длина этой строчки.
Семь.
Да.
Да.
Да.
Интересно, почему у меня написано Семь К плюс К четыре?
Аж страшно.
Аж страшно.
Чего?
Перепроверю.
А.
Да, все правильно.
Потому что они еще, да.
Думаю, что да.
Ладно, давайте так.
Если делать совсем как Лектора, то они тут еще А, Б, А, Б приписывали,
тогда тут действительно плюс четыре.
А эти не поменяются.
Вот.
Ну, это развлекается.
Так.
Ну, вот.
Это были понятия.
Но теперь мы с вами
пытаемся рассмотреть вот еще что.
Так.
Потому что дальше нам потребуют нот.
То есть, попробуем рассмотреть
какую-нибудь красивую теорему.
В роли красивой теоремы
у нас будет
Так, ладно.
Пишу какую-нибудь красивую макию
для этого использовать.
Так.
Ну, ладно. Давайте пусть будет
синий макия.
И
есть такая вот важная
просто мистическая теорема.
Которая, может быть, внутри тоже
могла бы нам помнить.
И говорит она, называется она
смотрите.
Лемма
о периодичности.
Значит, мистическая лемма.
Пусть
значит, строка
С
и
и
и
и
и
и
и
и
имеет
периоды.
Ну, будем говорить так.
Имеет
скобочка длин
п1
и
и
п2
с иами веду именно к числовке.
Ну, понятно, что так как у нас
формально, конечно, периодом строки
является строка, но
можно задавать строку длиной,
потому что это все равно пресс.
А, но
если только эти строки не длиннее С,
в данном случае это не так.
Потому что в данном случае
что модуль S должно быть больше либо равно P1 плюс P2.
Тогда, утверждаю я, строка S имеет период длины нод P1, P2.
Вот такая вот неожиданная интересность. Вот такая вот лемма, которая видимо считается такой важной, известной леммой.
В этом есть они тоже ссылаются на какие-то там статьи. На этот раз попробуем без этого обойтись.
Ну вот ваши ставки. Откуда же такое счастье, что называется это, мы взяли.
Ну, наверное, можно взять какую-нибудь строку длины ног от P1 и P2.
То есть жила была строка длины 12. Это 5 периодично и 7 периодично. Мы берем строку длины 35.
Ну, получается, если мы докажем, что там будет период нод, то вот эта вот большая строка, это будет S будет под строкой этой большой строки.
В чем общая идея? Ну вот мы знаем, что если у нас там P1 и P2, то они, понятно, на P1 и P2 тоже спадают.
Хотелось бы нод P1 и P2 представлять как пленнее комбинации?
Представляется.
Вот, например, что-то он будет равен, не знаю, A P1-B P2, где A и B, допустим, положительные.
Ну вот хотелось бы суметь, значит, показать, что мы можем от элемента, как бы до элемента плюс этот нод, пропрыгать по P1 и P2.
Ага. Желательно не выдать на это пределы.
Да, но кажется, что мы каждый раз хотя бы один шаг можем сделать. Из тех, которые нам остались.
Да, из тех, которые нам остались.
Но осталось только доказать, что это действительно так.
Ну, понятно, потому что мы всегда можем либо, например, прыгнуть влево на P1, либо вправо на P2, хотя бы одно из них.
Вот. Если нас не устраивает, значит, нам остались прошивки только одного вида, в одну сторону.
Ну, тогда мы точно, как мы до конечной, конечной позиции в строке, значит, мы доплыкаем.
Ну, можно, да. Ну да, можно так аккуратно докрутить.
То есть, типа, взять логуную, пытаться переставлять ее звенья так, чтобы мы оставались там в нужном диапазоне.
Да. Но, мне кажется, можно сильно проще.
На самом деле нам достаточно доказать, что S имеет период P2-P1.
Ну, если мы это, да, лучше все доказывать, то дальше понятно.
Мы дадим фу по предъявлямам алгоритма Евкрида, правда?
Но как доказать, что это строка P2-P1? Ну, допустим, давайте я присматриваю P1-P2.
Как это доказать?
Очень просто. Рассмотрим любые два символа на расстоянии, допустим, друг от друга.
Действительно, вот это. Вот пусть будет P2-P1.
Ну, тогда, если левый символ, например, находится левее этой границы, то этот символ равен вот этому символу на расстоянии P2.
А этот символ, в свою очередь, равен вот этому символу на расстоянии P1.
Легко, правда?
Ну и, соответственно, второй случай автоматически, если этот символ оказался правее границы,
то на самом деле мы...
А граница у нас какая?
Ну, у нас строка длины P1-P2, да?
То есть граница, где вот, собственно, P1 и, собственно, P2.
Теперь возникает такая идея. Если у нас это правее граница, так давайте просто сдвинемся влево на P1, а потом сдвинемся вправо на P2.
Ну, то есть вот, если такие вот... Если двое оказались вот целиком с этой стороны.
Ну, третий случай, конечно, если они оба оказались вот, допустим, целиком с этой стороны.
Вот. И тогда... Ну, тогда что? Если у нас уже P1 меньше, чем P2, ну, Господи, давайте тогда можно и вот так.
То есть таким образом мы убеждаемся, что, да, у нас есть период P2-P1, ну, хотя бы модуль.
Ну, а после этого мы включаем алгоритмы в клид, и говорим, что ноты там, знаете, последовательными вычитаниями ГЦД, да, выколыгиваем.
Ну, и да, здесь, конечно, есть вот интересность, потому что на самом деле... Вот давайте внимательно подумаем.
Потому что на самом деле считать так, что... То есть авторы клянутся и бажатся, и, в общем-то, в этом смысле можно верить, что левмы в таком виде нам хватит.
Но на самом деле, на самом деле, эту оценку можно уточнить.
А сам, Гень, я тут еще вот эту штуку. Еще нот дополнительных модуль выключу.
А если сейчас... Если у нас как раз получилось, что P1 столько больше, чем S? А, такое невозможно дальше?
Нет, ну и... Ну, как сказать?
Ну, такое невозможно.
Ну вот, теперь давайте поймем, можно вот такую оценку поставить.
Почему это так?
Действительно, давайте подумаем. Действительно, заметим, что конкретно такое доказательство уже может не прокатить, потому что мы здесь прям действительно красиво пользуемся тем, что у нас именно P1 плюс P2.
Ну вот, ну и теперь давайте думать. Если мы хотим доказать что-то более серьезное.
То есть, допустим, у нас тут оказалось, допустим, P1, а потом оказалось P2 минус 0.
Вот возникает тогда такой естественный вопрос. То есть, наш вот этот вот механизм, да, ну, если хотим доказать, что строка там P2 минус P1 периодично.
Но при этом может так оказаться, что, например, что какие-нибудь правильные два скачка вот, например, там где-то вот достаточно близко вот этой границы, вот отсюда, допустим, до сюда, видимо, мы рискуем уже не сделать, правда?
А почему мы не можем взять какую-нибудь строку длиннее S, и S будет являться ее под строкой, скажем, к Эфисам?
Так, что значит, какое длиннее? Ну, с такими же двумя атриудами, но только длиннее.
Потому что, а что если у тебя там какой-нибудь элемент, ну, просто нельзя добавить, потому что два разных периода дают разными элементами?
Ну, да, вот такая проблема есть. Вот, внимание, вопрос. Что же в таком случае делать? Как это такой механизм мы не применим?
Ну, можно пытаться сказать, что все-таки…
Возможно, что P1, ну, как бы, что P2-P1 не будет являться, но в таком случае оно будет.
А, нет, невозможно, это бред, да, если нот переедет, то куда-то тут пройдет.
Нет, тут действительно, давайте посмотрим. Это у нас оказывается… Ну, тут, впрочем, действительно, смотри-ка, какой интересный плач получается.
Что, допустим, если у нас P2-нот, то вот есть вот эта граница, если это длина, то как бы вот, то есть вот эта вот длина может оказаться, допустим, P1-нот.
Вот P1-P2, да, то есть получается, эта длина такая, а вот эта длина у нас получается такая.
Ну вот, тогда в чем у нас, собственно, проблема? Ну, мы замечаем, что… Ну, теперь смотрим, если у нас есть две точки, то есть у нас, допустим, две точки на состоянии P2-P1, если они обе находятся, допустим, левее вот этой границы,
если одна из них находится левее вот этой границы, то, в общем-то, P2 и P1 вполне себе работают, правда?
Ну и, соответственно, и наоборот, если… То есть, значит, следовательно, нас интересует только случай, когда обе точки находятся левее вот этой границы.
Ну, с другой стороны, если у нас одна из точек находится здесь, то что мы тогда можем сделать? Ну, вот.
Ну да, хотя наоборот. То есть теперь мы понимаем, что с другой стороны, да, в фейловом случае левая точка должна находиться как минимум здесь.
Но с другой стороны мы замечаем, что если эта левая точка находится… То есть, левая точка находится где-то здесь, то тогда что мы получаем?
Тогда мы получаем, что действительно мы можем сдвинуться на P1 и на P2.
У нас, правда, только вот между ними.
Получается, да. Видим, проблема, что левая точка должна находиться и здесь.
Вот.
Ну и здесь, впрочем, тоже у нас действительно, ну вот, что здесь может возникнуть.
Да, то есть правая точка может оказаться тут практически где угодно.
Так. Ну хотя, ладно, не где угодно, да.
То есть мы заметим следующее, что, как вы думаете, что больше?
Вот, действительно, как вы думаете, может ли так оказаться, что левая точка окажется здесь?
Нет, конечно.
Ну то есть, конечно, да. Может ли быть так, что P2-P1…
Ну вот, допустим, P2-P1 окажется, допустим, строго даже меньше получается, чем нод от P1-P2?
Нет.
Самое смешное, что это неправда. Такое можно.
Но мы знаем, что P2 больше, чем P1.
Да, это точно так. Ну, формально говоря, лемма фамилирует из случая, когда P1 и P2 равны.
Но тогда лемма, конечно, становится интересной.
Да, если у нас P1 меньше, чем P2, то, значит, тогда такого, очевидно, не бывает.
Ну максимум меньше и не поровну, правда, ну максимум.
Поэтому получается, что для нас плохой случай – это когда одна точка лежит здесь, а вторая автоматически попадает вот сюда.
Вот. Но, правда, заметим, что так. К этой точке мы, к сожалению, не привяжемся.
Ну, как же не привяжемся? Мы не привяжемся в том плане, что мы к ней не можем применить плюс или минус P2.
С другой стороны, правда, с оговоркой, что мы к ней можем применить, конечно, плюс 1.
Но с другой стороны, проблема еще в том, что к этой точке мы можем применить только минус P1 и, возможно, плюс P1.
Ну, хотя, с другой стороны, если бы мы могли здесь применить плюс P1, то мы бы тогда могли бы спокойненько…
Тогда мы могли бы потом учесть P2 дать.
Хорошо.
Так, ну с другой стороны, видимо, почему-то не можем. Видим, там застреваем.
Да, здесь вот это вот расстояние оказывается явно меньше, чем P1, потому что вот это расстояние у нас, напоминаю, равно P2 минус P1.
Так, вот, получается, да, на это расстояние у нас почему-то какой-то маратур.
Ну, что ж, тогда можете сделать.
Ну, можно попрыгнуть туда, куда мы можем. У нас, собственно, по одному варианту есть каждый, кто отчет.
Ну, да. Ну, в принципе, да, можно заметить, что из каждой из этих двух точек…
Ну, во-первых, да. Ну, во-первых, да, ладно.
То есть, действительно, мы можем действительно…
Ну, во-первых, да. То есть, во-первых, мы действительно…
Если у нас действительно вот…
То есть, из каждой точки мы можем пытаться прыгать на P1.
Вот так вот. P1, P1, P1.
Можем пытаться так прыгать? Можем так пытаться.
Вот.
Ну, и можно, ну, вот, да, можем, можем так пытаться.
Внимание, вопрос. Верно? Ну, вот.
Ну, по-моему, да, возникает интересно.
А верно ли, что хотя бы из одной из этих точек вот P1, P1, P1
всегда можно прыгнуть, можно найти такую точку, из которой можно заведомо прыгнуть на P2.
Еще раз.
Посмотрите. Существует ли хотя бы, хотя бы одна…
Вот, смотрите, вот, предположим, рассмотрим все точки, вот, по которым мы можем из этой точки прыгнуть на вот…
P1.
Слева мы на нее вообще не можем прыгнуть.
Что-что?
Ну, слева мы не можем прыгнуть, потому что она меньше, чем P1, у нее номер.
А, да. Хорошо. Определенно.
Вправо можем.
Теперь внимание, вот мы прыгаем, прыгаем, прыгаем, и в конце, соответственно, допрыгались.
Внимание, вопрос. Можем ли мы теперь прыгнуть из нее на P2?
Назад.
Ну, конечно, назад.
Не обязательно. Что если в конце у нас осталось…
По-моему, можем, потому что P1 всегда больше.
Ну, P1-то больше.
Ну и что?
Проблема в том, что как бы…
Нет, на самом деле кажется, что…
На самом деле, да, кажется, что само по себе это проблемы дает.
Потому что все, что мы знаем, и то, что расстояние между последней точкой границы, оно меньше, чем P1.
Само по себе, из того, что оно меньше P1, то есть нам, для того, чтобы прыгнуть на P2…
Смотрите, смотрите, как интересно.
Для того, чтобы прыгнуть назад на P2, нам требуется, чтобы вот это расстояние должно было быть, допустим, меньше либо равно, чем P1-0.
P1, P2.
Вот возникает естественный вопрос. А так ли это?
Вернулись, что если это расстояние действительно меньше…
Я вроде бы составил систему уравнения.
В неравенстве там вроде бы все сходится.
Сходится? Какие же неравенства?
Какие же неравенства?
Ну, то, что у нас, допустим, P1-0 плюс KP1, это будет меньше, чем P2…
А, там же P1-0. Извините, я прошу всех.
Не, вот эти вот, даже интересно просто попытаться либо доказать это, либо попытаться еще и опроверкать.
Мы можем, как бы, всю строку поделить на блоки по ноду.
Ну, давайте сразу скажем.
Пусть у нас нод P1-P2 равно…
Ну, раз мы блоки уже сегодня обозначали режим все, давайте скажем, что оно равно D.
То есть, допустим, там P1 равно D…
Ну, я не знаю… L1… Нет, L плохо.
Какую тут еще букву с индексом M1 написать?
Q может быть… Давайте.
Тоже не… Ну ладно. DQ2. Хорошо.
Тоже плохо, конечно, там Q такой смысл будет иметь.
Так, и давайте посмотрим.
Вот у нас получается P1, вот у нас получается P2.
Минус D.
То есть, получается, примерно, следующее, что у нас блоки устроены как-то вот так.
То есть, это блоки D, D, D…
То есть, у нас блоки устроены как-то вот так.
То есть, это вот блоки D, D, D…
Вот.
И тут еще, ну вот, и тут эти блоки D, D, D, D, D, D…
Ну да, и в идеале нам что хочется показать?
Нам хочется показать, что все эти блоки равны.
Вот. Ну и теперь заметим, что у нас тут полгода застава заключается в том, что…
Да, вот это количество блоков, это вот Q1, и вот это вот Q2.
Вот. И по сути мы сверили вот нашу поприклакать слему,
ну вот то, что мы можем прыгать, к случаю, когда взявим просты.
То есть, что на самом деле происходит?
Мы прыгаем вправо, например, на Q1 блоков, да, и остаемся на той же позиции в блоке.
Ну что, всегда или так же на Q2 можем прыгать.
Ну да.
Вот. И мы по сути хотим показать, что если мы будем начинать из блока с номером как раз Q1 лично номерации,
то есть последнего блока в P1, вправо на Q1 блоков,
то мы пойдем в такой блок, что потом мы как бы не…
У нас есть один блок, из которого мы не можем ни вправо впрыгнуть на Q1, ни влево на Q2, только один такой.
Вот. И нужно показать, что мы в него не попадем обязательно.
А этот блок получается с номером Q2-1, да?
Да-да. Нет, ну туда. Давайте так.
То есть, ну заметим, что… Да, действительно, давайте сначала скажем, что в общем-то по большому счету,
да, если взять вот это D, то есть если рассматривать отдельные символы с индексами равными по модулю D,
с одинаковыми остатками, да, то по сути мы будем решать ту же самую задачу,
где у нас просто длинный строк Q1 и Q2, и Q1, Q2 взаимно просты.
Да, вот, кстати, с этой точки зрения, давайте я вот этот блок сотру.
Ну, чтоб было 4,7 взаимно просты, допустим.
Вот. Так, хорошо. То есть теперь нам надо показать, по сути, следующее, что у нас есть строка длины Q1 плюс Q2 минус 1,
и известно, что она Q1 периодично и Q2 периодично.
Нам требуется показать, по сути, что все, или опровергнуть, что все символы в этих строках оказываются равными.
Как же это сделать?
Ну вот, в общем, у нас получается вот единственный как раз плохой символ, да,
который мы там рассматривали, из пары вот с нас, по Q1,
он как раз находится на позиции Q1 в один номерации.
Это единственный, то есть из всех остальных можно либо сначала вправо на Q2, влево на Q1, либо сначала влево на Q1, потом вправо на Q2.
Ну да.
Вот. Ну, если мы будем спрыгать с него на Q1 вправо несколько раз, пока не сможем,
то мы придем в позицию с индекса Q2 до конца строки.
Ну, потому что у нас это как бы отрезок длины Q1.
Вот. Но мы не можем прийти в позицию ровно Q2.
Вот мы начали позицию в Q1.
Так, давайте я тут даже подлиннее нарисую.
Так, хорошо. Жила-была позиция Q1.
Отлично.
Ну вот. Да.
Вот. Да. То есть заметим, это действительно, допустим, единственная позиция, из которой мы не можем пойти влево на Q1,
ни влево на Q1, ни вправо на Q2.
Да. Да.
По большому счету, да.
Вот. То есть это, ну вот.
То есть, в общем-то, да.
Как мы уже говорим, что любые два символа на расстоянии Q2, Q1,
на самом деле, в любом ином случае, на самом деле, оказываются великолепно равны.
Почему они оказываются равны?
Ну просто потому, что если там этот символ слева, то можно там Q2, потом Q1, да.
А если они там, скажем, левый символ оказывается правее вот этой позиции, то скачем вот так-вот так, и нас тоже вот устраивает.
Понятно, Вадик? Да? Понятно? Ну вот.
Ну вот. То есть единственное, когда это нас не устраивает, ну вот.
То есть, когда конкретно из левой позиции мы не можем решить вопрос,
когда левая позиция оказывается просто ровно в символе Q1.
И тут у нас радость.
Что тогда... Ну вот. Вот давайте думать. Что тогда мы могли бы про это сказать?
Вот. Ну давайте в этой позиции, да, плохой прыгать право на Q1.
То есть на самом деле, вот смотрите, ладно, есть такая, есть такая позиция, есть вот это вот Q1-1.
Есть симметричная позиция, когда вот здесь Q1-1.
Вот про эти символы как будто вообще непонятно.
Вот про эти символы вообще непонятно. Ровные они или нет?
Ну потому что стандартным образом мы убедиться не можем.
Ну просто скатнуть ни с того ни с того, на самом деле мы никуда не можем.
Сейчас, а мы просто хотим, чтобы мы могли бы про это сказать?
Ну, скажем так, мы пытались доказать, что строка имеет период P2-P1.
В данном случае P2-P1.
Вот мы говорим, что наш стандартный механизм, который мы это раньше делали, когда у нас сумма была строк,
он застопрился вот на конкретно этой паре и больше ни на какой.
Ну, это неправда, что между ними ровно куда-нибудь сходится.
А конкретно этой паре и больше ни на какой.
Ну, это неправда, что между ними ровно куда-нибудь сходится. Вот эти две нарисованные точки.
А почему?
Сейчас, потому что... А, нет, или правда.
Да, ладно.
Нет, правда, правда. Ну, как сказать, да.
То есть расстояние между ними Q2, ну да, хотя вот длина вот этой подстроки Q2 плюс 1, да.
Получается, что композиция этих элементов это Q1 и Q2, собственно.
Композиция этих элементов, ну да, Q1 и Q2, совершенно верно.
Это композиция Q1, это композиция Q2.
Ну, а теперь давайте думать, что здесь можно сказать.
Причем напоминаю, что Q1, да.
Как бы так, Q1 минус Q2 действительно просты.
А, понятно. Давайте из вот этой позиции левой прыгать право на Q1 пока можем.
Так, ну будем прыгать.
Вот, мы попадем в последний Q1 символов, ну в один из последних.
Ну, точнее так. Это будет вот так.
Потом это будет вот так. И в какой-то момент это будет вот так.
Вот. Если мы попали вот, ну как раз, в этот символ с позиции синекса Q2, то мы победили.
Ну, это то, что сначала Q2 делится на Q1, такого не бывает.
Ну, не бывает, но я просто в обществе говорю.
Если не так, то мы прыгаем от него влево на Q2 и продолжаем право прыгать на Q1 до конца.
И так далее. Ну, типа в какой-то момент мы придем в символ Q2.
Ну да.
Ну, ведь мы можем зациклиться иначе.
Нет, не зациклимся. Потому что, смотрите, раз они взаимно просты.
То, что, ну, как бы действительно, как мы скачем.
То есть, когда мы скачем, скачем, скачем, скачем, скачем.
То есть, рано или поздно мы будем либо в символ Q2, либо в то, что правее.
Потому что вот этот последний блок ровно в длиной Q1, правда?
Но если мы попадем строго правее этого Q2,
то, значит, мы сумеем перескочить на, действительно, Q2.
После этого, значит, раз уж мы тут, ну вот, после этого,
ну, что у нас тогда будет получаться?
После этого, значит, из этой позиции мы тоже будем теперь скакать,
ну вот, и, соответственно, скакать.
Правда, заметим, что в этом блоке мы можем прискакать как куда-то вот сюда, так и куда-то вот сюда.
Понимаете, да?
То есть, когда мы в следующий раз перескачем Q2, мы можем оказаться как левее Q2, так и, в общем-то, правее.
То есть, мы могли вот так оказаться, а могли прийти вот так. Понятно, да?
Хорошо, да.
Но, как бы, так как Q1 и Q2 взаимопросты,
по крайней мере, верно то, что, во-первых, конкретно в эту позицию мы точно, вот, мы точно, видимо, не прискачем.
Да.
И более того, для того, чтобы нам вернуться в ту же позицию, на самом деле мы будем вынуждены заключить,
что для этого нам придется прям все остатки перебрать, перед чем мы не вернемся.
Поэтому, ну вот, получается, что рано или поздно мы вынуждены будем ткнуться вот сюда.
То есть, перебрав, возможно, все вот это.
Поэтому получается, что конкретно здесь хорошо.
Вот.
Но тогда уже, знаете, хочется, тогда уже добивка. Интересно.
Вот, хорошо, если минус один, это работает.
Как вы думаете, а если минус два?
Интересно, работает или?
Ну, то есть, минус два, тогда доказательства не работают, потому что тогда кто-то мимо этого блока может промахнуться.
Верно тоже неверно.
Ага.
Да, действительно, вероятно, что это уже неверно.
Но давайте попробуем, знаете, вот для примера давайте попробуем составить граф.
Вот, допустим, у меня Q1 равно, ну, я не знаю, 5, а Q2 равно 7.
Давайте я попробую 5, 6, 7, 8, 9 символов, да?
8, может, минус два.
5 плюс 7, 12.
А, ой.
А минус два, вообще 10.
Минус два, даже 10, вообще-то.
Вот теперь внимание, вопрос, нужен ли нам 11 символ для того, чтобы тут обнаружился связанный граф?
Так, ну, давайте думать.
Вот, допустим, если вот этот символ A, да, то тогда автоматически давайте вот этот символ A и вот этот символ A.
Ну, это проходит шестой и восьмой.
И шестого мы деться больше никуда не можем.
А из восьмого мы тоже...
А, из восьмого можем деться в единичку, а можем деться в тройку.
Вот сюда получится A.
Так, что же у нас теперь получится?
Из тройки я могу деться в восьмерку, а могу деться в десятку.
Так.
Ну из десятки я могу деться в тройку, могу деться в пятерку, то есть в пятерке я не могу деться никуда.
Картинка называется ой, не замкнутая ли система, получилось. Они легко убедиться, что замкнутая,
потому что вот тут 2, 4, 7, 9, для каждой для каждой штуки из них очевидно, что на 5 и 7 мы из
пустых клеток скачем в пустые клетки. Следовательно, я могу спокойненько тут нарисовать любые символы
B и сказать, что подходим. Так что, видимо, да, граница точная. Возможно, можно прям для любых
P1, P2 прям действительно аккуратненько доказать, что строго меньше пример прибудется. Да, то есть
это вот такая вот лемма о периодичности, которая нам, в принципе, очень может помочь. Ну то есть,
на самом деле, конечно, для алгоритма нам, в общем-то, вот эта прибавка не важна, на самом деле,
но и не будет пользоваться. Но, тем не менее, так в случае чего, помнить полезно, равно как и вот
про вот эти вот блоки. Ну, в принципе, это такая хорошая штука, на самом деле, она очень помогает.
Так, что там у нас дальше? Ну ладно, это вот остальные вещи, которые хотелось.
Ну вот, что же нам еще потребуется? Лемма о периодичности A. Ну, заметим, ладно, это была лемма,
она, на самом деле, верна в достаточно широко глобальном смысле. Ну, в том плане, что она, в общем-то,
не привязана к нашему конкретному алгоритму, она вот просто абстрактно есть. Вот, но, значит,
на самом деле, у нее есть мистическое следствие. Сейчас я вам его попробую, значит, расписать.
Ладно, я тут не буду уже упишиваться. Значит, смотрите, следствие, внимание, в чем следствие,
тут мы попытаемся прям максимально четко провести. Следствие. Вот. Различные префиксные периоды.
Одной и той же, естественно. Строки различаются по длине.
Строго больше, чем в х-1 раз. Вот там очень, на самом деле, будет помогать, на самом деле,
вот эта маленькая приятная вещь, что на самом деле, как бы, да, у строки могут быть различные
префиксные периоды, но по длине они отличаются хотя бы вот в х-1 раз. То есть, как бы там,
ну, то есть, это будет каким-то мистическим образом нам помогать. Вот. Но мы сформулируем,
знаете, мы назовем даже, я так скажу, вот у нас есть следствие, но мы не его будем доказывать,
мы будем доказывать его усиленную версию. Да, может, будем писать УСЛО. Вот. Так вот,
усиленное следствие звучит так. Значит, смотрите. Где тут у меня это усиленное следствие?
Значит, смотрите. Пусть у строки С есть, внимание, префиксный период
P1. Ну, длины давайте аккуратно писать уж тогда, когда тема сложная, лучше не подразумевать,
что что-то понятно. Понятно. И базовый, внимание, даже более славно, базовый префикс длины, внимание,
P2. Ну, я надеюсь, вас не будет путать понятие базовый префикс, потому что базовый префикс
это не более чем префикс, являющийся базовой строкой. Но, правда, это небезопасно, да? Потому что
вот видите, префиксный период, это словосочетание вообще что-то другое означает, да? Ну, то есть,
знаете, фрезеологизм, типа, что там, то есть, типа, там go означает идти, on – идти на, go on – продолжаться.
Ну да, префикс одно, период – другое, префиксный период – вообще треть. Но в данном случае вот
все честно. Базовый префикс, значит, префикс, который является базовой строкой. Значит,
причем, я так скажу, P2 больше P1 и reach с индексом s от P2 больше либо равно 2P2. То есть,
обратите внимание, это требование к вот этой вот более длинной строке, это более слабое
требование, чем то, что она была бы префиксным периодом. Что префиксный период бы в этом месте
требовал вместо двойки каши, правда? Ну, базовый, базовый. Так вот, уже этого, оказывается,
достаточно, чтобы сказать, что P2 больше, чем k-1 на P1. Вот такая вот интересная ситуация.
Вроде понятно.
Даже вроде понятная?
Так, ну, давайте, конечно, все сотрую, будем разбираться, почему это понятно.
Так, ну, поехали. Так, вот жила была, допустим, строка S. Жила была строка S. Так, что?
Ну, мы хотим, конечно же, рассмотреть какой-нибудь ее префикс, правда? Ну, естественно, ладно,
идем, как говорят на латыни, от абсурда. По-лативски так звучит, от абсурда, если что.
Предположим, что P2 меньше либо равно P1 на k-1.
Можем такое предположить, правда?
Тогда, смотрите, что можно сделать. Рассмотрим префикс S длины P1 к.
Ну, мы можем заметить, что эту строку можно разбить на k, в нашем случае буквально 4 блока по P1.
И они все будут одинаковые, правда?
Вот.
Ну, смотрите, как интересно, что означает, что у нас P2 меньше либо равно.
Это означает, что это P2 так жественно вписывается куда-то вот сюда.
Под линию, правда?
Ну, хотя бы под линию.
Ну, теперь мы заметим вот что.
Причем более того заметим, что эта строка, в принципе, вот в этой строке вполне себе равна, очевидно, правда?
Почему начали по 2-х без какого-то странного места?
Нет, это не странное место, это конец первого блока.
Я просто хотел показать, что из неральностов следует, что оно заканчивается не правее, чем вот это.
Вот.
Ну, теперь заметим следующее.
Рассмотрим префикс, вот этот вот префикс.
Длины P1 плюс P2.
Как легко заметить?
Заметим, да?
Что я утверждаю, что префикс длины P1 плюс P2, он, во-первых, P1 периодично, то есть у него есть период P1.
Ну, это очевидно, потому что это под строка, по этим периодическим строке, правда?
И P2 периодично.
А почему он P2 периодично, кстати?
Потому что P2 больше P1, а та у нас периодически больше.
А P1 плюс P2, а не P2 P2.
То есть, дело в том, что, да, у нас есть, действительно, можно взять префикс 2P2, но про 2P2 мы сказать ничего не можем.
Но мы знаем, что уж, да, во-первых, P1 плюс P2 меньше, чем 2P2, это мы точно знаем.
И мы знаем, что вот какой-то префикс, там непонятно, здесь или здесь, но это строка P2 периодично.
Ну, и длина ее равна 2P2.
О, я как раз примерно по удвоенную вот эту и нарисовал.
Вот, но это неважно.
Значит, важно другое.
То есть, получается, раз этот префикс P1 периодично, P2 периодично, то по имеющейся у нас лемме, значит, из этого следует,
что S от 1 P1 плюс P2 нод P1 P2 периодично.
Мы уже с вами это выяснили.
Вот, что из этого следует?
А из этого следует маленькая приятная вещь.
Что его голубой префикс этой строки в лице P2.
Именно P2.
Значит, нод P1 P2 периодично.
Уже догадываетесь, к чем противоречие будет?
С тем, что P2 базово.
Не только.
Во-первых, с тем, что базово, но тут еще важно уточнить.
Важно уточнить, что P2 делится на этот нод и при этом P2 строго больше этого нода.
Потому что, в принципе, если бы этот нод был равен P2, нас бы все устраивало.
Но тут-то и важно, что мы пользуемся тем, что P1 строго меньше P2.
То есть, поэтому вот так.
Можно даже написать P2 больше P1 больше либо рабочим строк.
Отсюда следует, что F1 P2 не базовая.
Ну вот, доказательство от противного на этом заканчивается.
Вот такая вот у нас получается строка.
Это префикс нод.
У нас была строка нод периодичную.
Взяли префикс, она будет иметь такой же префикс.
Да.
Ну, оказывается, она не базовая.
То есть, вот еще одна действительно очень-очень приятное усиленное средство.
Ну, значит, давайте прежде чем формулировать какие-то еще леммы.
На самом деле, я попытаюсь сейчас формулировать
кое-что еще.
Так, что тут нам предлагают?
А, еще одно определение.
Значит, на первый дат.
Так.
Ой.
Где бы его написать?
Так, давайте прямо так сделаем.
Смотрите.
Черный маркер, я сам думаю.
Так.
Значит, еще одно определение.
Смотрите, я еще введу, значит, определение.
Вот мы сегодня его уже утром вводили.
То есть, пусть, действительно, 1 меньше либо равно Q меньше либо равно bs.
Тогда, внимание.
Тогда мы вводим такое понятие, как shift.
Shift s от Q.
Значит, этот shift будет равен.
Минимальное такое l больше 0.
Такое, что, ну, по факту, s от l плюс 1.q равно s1.q.
Авторы предлагают вот такое.
Да.
Ну, очевидно, в нашей терминологии мы можем это двумя способами.
То есть, на самом деле, заметим, что это торжественно равно минимальному такому.
l больше 0 такому, что l плюс z с индекс ms от l плюс 1.
Ну, получается, больше либо равно q.
Логично, да?
Логично.
Логично.
Ну да, можно было написать z от l плюс 1 больше либо равно q минус l.
Ну, или как мы вообще знаем, что это на самом деле равно, ну, банально, я не знаю, q минус p.
Если мы живем в слабом червящем непоительном мире префекса z функции, то можно было этот shift еще вот так определить.
Ну, суть, в общем-то, одна.
На самом деле, правильно написать так.
Так, shift – это минимальный период префекса строти-ездленной пункты.
Понимаете, да?
Вот мы сегодня уже активны.
Я ровно по этой повреждению этого определения, я его назвал shift сегодня.
Так что вот такая у нас красота.
Так что тут у нас shift.
А-а-а-а, да.
То есть приятный такой shift.
Так вот.
Значит, я вот еще определение забил, но теперь я все-таки перескорю.
Значит, потому что в этом месте авторы начинают забавачивать некоторых философий.
Ну, потому что как у нас вообще глобально выглядят огромное количество алкогитмов поиска под строки-в-строте?
Значит, то есть если мы ищем, как всегда, шаблон P, строкет T, то чаще всего это выглядит так.
Смотрите, мета алгоритм. Даже не уверен, правильно ли его называть, мета алгоритм у Галилы Сейферса,
конечно. То, что алгоритм предлагается так устроить. Значит, во-первых, заводим пару PQ,
которая, картриджик типа, изначально. Ну ладно, в нашей терминологии придется немножко по-другому
1,1. Значит, говорим, while, допустим, P меньше либо равно модуль T. Ну, я давайте сразу поясню.
Значит, вот инвариант. Будем поддерживать инвариант. Инвариант будет звучать так.
Т значит что? Т значит PQ не включительно. Равно S отъединив сюда. То есть я хочу рассматривать какие-то подстроки,
которые являются префиксами строки P. Ну, помните, это паттер, это текст. Мы ищем шаблон в тексте.
И P предлагается искать примерно следующее. Вот P меньше либо равно T. Значит, что нам предлагается?
Ну, во-первых, поддерживаем такой инвариант. Вот PQ у нас такой. Ну, во-первых, начинаем с того, что while,
естественно, значит, PQ меньше либо равно TQ меньше либо равно P. Ну и как вы уже догадываетесь,
что мы тут пишем? T от PQ равно PQ. Ладно, тут меньше, конечно. Ну, в общем, практически та часть кода,
которую бы все функции там писали как в тупую. Вот. Ну, можно тут же писать что-нибудь там.
If Q равно равно mod P, то там бла-бла-бла как-нибудь сохранить ответ. И самое интересное, почему этот
алгоритм становится метод алгоритм, PQ присвоить P' Q3. Желательно, наверное, P' больше P1. Ну,
скажем так, напишу вопросик, потому что лично мне так кажется, что это логично. Почему это металгоритм?
Металгоритм это ровно из-за вот этой ситуации, потому что откуда я возьму вот это? Вот я так напишу. Вот на
самом деле поэтому я это называю металгоритм. То есть каждый алгоритм должен просто отвечать на
вопрос откуда я вот это возьму. Ну, по большому счёту заметим, что тут на второй начинают ссылаться
на алгоритм кнута Мориса Пратта. А, да, мы не знаем, что алгоритм кнута Мориса Пратта. Так вот. Ну, по сути, алгоритм кнута
Мориса Пратта это когда вы ищете подстрок в строке через префикс функции. Когда мы пишем через решетку и
присутствует что ли? А вот тут деталей я не помню. Вот тут я не скажу. У меня почему-то жуткое
предположение, что они всё-таки использовали олацпай дополнительной памяти. Ну, честно скажу, из какой
логики они приходили к этому, я не знаю. Вот честно, вот их статья я не смотрел. Но, соответственно, что у нас тут
происходит? Но давайте так, но давайте, вот прежде чем мы перейдём, пойдём на перерыв, давайте вот что мы
представим. Скажите мне, пожалуйста, вот как устроено п штрих и q штрих, как вы думаете, в КМПшке?
О, наверное, это индекс, а П это максимальный префикс.
Стой близко индекс, а П это как бы значение префикс функции.
Ну да, но по большому счёту да. Можно сказать, что q это действительно значение префикс функции.
Обычно там можно это сформулировать так, что q присваивается, можно сказать так,
значит П плюс П, пишу так, П плюс П1 значит q минус П1, где П1 равно чему? Ну, можно сказать, что
действительно обычно оно равно, можно сказать, что q минус префикс функции от q минус 1, правда?
Ну ладно, п от q у нас один индексация, правда? Ещё п с индексом П, обратите внимание данным башням.
Ну на самом деле правильнее сказать, конечно, что П1 равно на самом деле shift, shift с индексом
П. Потому что, давайте ещё раз вспомним, в чём заключается, вот как можно ещё интерпретировать логику кнутам
или сопратам. Логика была примерно следующая, вот жила была строка П, мы её ищем. А может П1 это П плюс в этот shift, а П1 это индекс в строке Т, может достаточно большим, например.
Да, поэтому я тут пишу П плюс П1, а не просто П1. А, всё П плюс П, ага. Да, смотрите, как это работает, то есть работает это так.
Допустим, мы убедились, что какие-то все вхождения левее, чем вот эта позиция П, не путать, кстати, П маленькая, вот с этой вот строкой П, да?
Вот, допустим, она оказалась здесь, и вот, допустим, мы на q прошли, вот тут q и тут q, но выяснилось, а дальше fail, х левый, да?
Тогда, какую границу нам имеет смысл рассматривать следующий?
Если мы хотим вот сдвинуться на какую-то границу, допустим, пик, там, A, то есть сказать, что вот эта позиция П плюс A, то мы обнаружим, что вот эта вот штука должна быть префиксом вот этой штуки.
И одновременно с префиксом, правда?
А это, как мы уже выяснили, просто эквивалентно тому, что L это, ну вот, L это что? Это фактически вот период этой строки.
Ну что вот? Ну то есть, фактически, если у вас вот есть такие префиксов, падает с суффиксом, и префикс суффикс начинается на расстоянии L, то это означает, что строка и периодичная.
Фактически, это означает, что надо сдвинуться на минимальное такое, чтобы это было, тогда получается, что L это просто тот самый shift.
Еще иногда, когда у нас, типа, строка пустая, нужно что-то сдвинуть?
Не, ну L может быть и, честно, P, это нормально.
Тогда мы скажем, что, действительно, shift это минимальный период при префиксах LQ. Этот shift может быть равен Q.
То есть, это означает, что у нее никаких внутренних периодов, кроме Q, нет.
Не, ну просто, если мы пишем ровно так, у нас никогда суббописку не поменяется. Это очевидный бред.
Чего не поменяется?
А, сейчас.
Q меняется вот здесь.
Ну, в общем, все равно, если у нас, например, Q там чему-то равно, Q равно 0, то и Q не совпадает с первым Q строки P, то у нас просто, ну, не будет меняться, не паникуй.
Нужно какой-то еще ИВ добавить, в каком случае мы прибавляем просто Q по 1.
Нет, в смысле, не пойду. Смотри, начнем с того, что P1 0 быть не может никогда.
Если Q равно 0, что происходит?
Если Q равно 0...
То, наверное, мы должны что-то другое делать.
Например, просто Q добавлять 1.
Ну да, или...
Ну хорошо, хорошо, ладно.
Ну да, давайте скажем, что...
Или P plus 1 0, хорошо.
Если Q совершенно случайно оказалось...
Рабло, 0.
Хорошо, уговорили, уговорили.
Вот. Ну, то есть вот алгоритм, но там не супратто, как бы, со ссылкой на статью, интерпретируется вот ровно таким образом.
Соответственно.
Ну а на самом деле, конечно, да.
Чтобы его, правда, это делать, нам придется в этом алгоритме параллельно эту префикс-функцию, собственно, насчитывать.
Вот, собственно, ровно исходя из этих соображений, она, в общем-то, и взялась.
Ну а не помните, когда мы владели префикс-функцией, мы тоже пытались двумя указателями, это, честно, находите, хэшами.
Потом научились вычитать префикс-функцию, собственно, хэши избавляться.
Но мы же будем здесь пытаться работать как-то сепрее.
То есть, скакать может не настолько, насколько реально можно, может быть, иногда скакать будет чуть на поменьше.
Но чтобы в совокупности все равно работалось за...
Но, правда, тут, конечно, скакать надо очень-очень-очень.
Так, ну, я думаю, пришло время сделать переговор.
Значит, смотрите, так.
Значит, мы тут воспроизвели вот этот алгоритм, мы его тоже себе металгоритм пририсуем.
Ну, с КМПшкой мы все поняли.
Значит, что мы... Ну, понятно, алгоритм будет оставаться вот на этой штуке.
Но при этом будет пытаться, конечно... То есть, заметим, что сам по себе вот этот...
То есть, заметим, что все, кроме вот, на самом деле, вычисления ПКПШТРИХ,
на самом деле до памяти никакой практически не требует, правда?
Логично, да?
Или нет?
Так, кто живой?
А, вот тут вот... А, нет.
Ну, да.
То есть, по большому счету, вопрос только вот в этом месте.
То есть, как бы... Ну, это, правда, самое магическое место.
Ну, давайте попробуем... Ну, прежде всего, конечно, тут хочется немножко поиграться.
Ну, во-первых, давайте еще пару леночек попробуем.
Да, ничего не хочется стирать.
Значит, смотрите, утверждение такое.
Если оказалось, что shift с индекса S от Q меньше либо равно Q делить на K,
то я утверждаю, что shift S от Q, а точнее S от 1 до вот этой мистической числа,
это префиксный период S.
Ну, вот.
Ну, действительно.
Если какие-то ноты...
Ну, в принципе, да. Давайте разбираться.
Давайте кратенько поймем.
Ну, я сейчас тут нарисую, потом смотрю.
Жила была вот где-то позиция Q.
И, допустим, вот у нас shift оказался где-то индекса.
И он оказался меньше либо равен, чем Q делить на 4.
Еще shift я нарисую.
Вот.
Вот.
Ну, заметим, что этот префикс, он на самом деле shift-опериодичен.
Вот как мы выяснили, да?
Могло быть и 5, и 6, но главное, он shift-опериодичен.
Поэтому мы понимаем, что...
То есть, как минимум, что...
Ну, как минимум, то есть, видим, что как минимум 4 копии тут есть.
Следовательно, это кандидат.
В префиксной цивилизации.
Почему он только кандидат?
Потому что вообще надо еще установить,
не является случайно эта строчка...
То есть, является ли эта строчка базовой.
Если она не базовая, то shift можно взять.
Да, совершенно верно.
Потому что, на самом деле, если выяснилось,
что эту строчку еще, там скажем, на 3 строчки,
можно распределить.
То легко убедиться, что, на самом деле,
не только вот этот префикс равен вот такому,
но и, на самом деле, даже вот этот префикс
будет, на самом деле,
вот такому равен.
Вот. То есть, вот такая вот красота.
Красота? Красота.
Вот.
Красота? Красота.
Гравится? Ну, вот.
Поэтому, если эта строка, да,
противоречия, то есть,
с определением шифта, так что, да.
То есть, минимальный шифт,
то есть, минимальный шифт,
это заведомо базовая строчка.
Будь здоров!
Спасибо.
Вот.
Ну, вот. Ну, на самом деле, сейчас
еще будет лемма, которая, в общем-то,
незначительно сложнее,
но она будет немножко более навороченная,
потому что она уже
привязана непосредственно
к алгоритму.
Значит, смотрите, звучит она так.
Значит, она будет звучать так.
Значит, пусть,
вот, допустим,
s от 1l
префиксный
период s.
Тогда, утверждаю я,
для любого q,
для любого q,
ну, естественно,
от одного до модулеса,
естественно,
верно. Внимание!
Внимание! Следующее мистическое утверждение.
Значит, внимание!
Значит, l равно
шифт
с индекс ms откуда
значит,
меньше либо равно q поделить
на k.
И это не все, внимание.
То есть, ну, во-первых,
это два утверждения.
Да, тут очень хитро
написано, на самом деле, там утверждение.
Но, во-первых, это два утверждения,
что, во-первых, l равно шифта с s от q,
и, второе, что шифт s от q
меньше либо равен q поделить на k.
А во-вторых, это еще не все.
Это, если вы думаете, почему это верно,
нет, это, конечно, не верно.
Можно вопрос в условии?
Тут вот s, 1,
а, все, я,
все, я понял.
Отлично. Вопрос был задан не зря.
Так вот,
утверждается, что
эти два утверждения верны
тогда и только тогда,
когда верны другие
два утверждения.
k умножить на l
меньше либо равно q,
меньше либо равно
q поделить
с от q.
Вот.
Красота.
Вот теперь вот фаза.
Кстати, да, никто не утверждает, что это
верно. Ну, просто потому, что
вообще говоря, q можно рассмотреть
какой-нибудь, скажем, меньше, чем l,
поэтому вот это вот, конечно, может быть
неверно в принципе.
Но утверждается
на самом деле следующее.
Ну, то есть по факту утверждается следующее.
Видите, в обоих утверждениях
так или иначе фигурирует, что k умножить
на l должно быть меньше либо равно q,
правда?
То есть по факту
говорится следующее, либо k умножить
на l меньше либо равно q,
и тогда одновременно выполнено
и вот это, и
вот самое главное,
ну, самое главное вот это,
либо q больше,
либо q
на самом деле строго меньше, чем
q умножить на l, и тогда
ни это заведомо не верно,
ни вот это заведомо
не верно.
Вот такое утверждение.
Так вот.
Как же это?
Вот теперь давайте думать.
Как же это доказать?
Ну, давайте думать.
Если смотреть в эту сторону.
Понятно вроде.
Ну, вроде да.
Ну, в эту сторону, да, что-то совсем очевидно.
Сейчас тогда в статье так и написано,
не тривиальное рассуждение
требует только вот в эту сторону.
Ну, действительно,
потому что в эту сторону, что означает, что у нас
вот этот вот shift,
то есть там,
предположим, что у нас l не просто оказался
shift, то есть вот допустим
вот этот вот l, ну вот, то есть
это вот l, он еще меньше либо равно
уподелить на k, и еще и shift оказался,
но тогда это означает, что вот тут у нас
k на месте,
l, l, l, да?
Вот.
И не просто k, а еще
просто эта строка еще l периодично.
Поэтому очевидно, что
поэтому очевидно, что rich s от l,
а, ладно, я неправ, неправ, неправ, неправ.
Правильное утверждение, конечно, требует
не l, а l плюс 1.
Так у нас же в определении
rich от l, это как раз
у нас,
у нас rich
от p, это
z от p плюс 1,
так что все правильно.
Хорошо, так туда проверяйте.
Хотя на самом деле вот определение написано.
Нет, вспоминается
это прямо как в телевизионной своей игре.
Это называется, ведущий
называется, зачитывает вопрос по своей табличке,
хотя за его спиной вопрос на экране.
Ну, в общем, красиво получается,
но он тоже как раз
вот.
Это вот называется l, l, l, l, вот так.
Ну и здесь очевидно, что rich от l
как раз вот больше либора q,
это нас устраивает.
Вот теперь давайте думать
в обратную сторону.
Значит, да, тут
в общем-то само все очевидно.
Давайте предположим, что совершенно случайно
выяснилось, что у нас есть префиксный период
строки s, и неожиданно выяснилось,
что q на l меньше либо равно q.
То есть начало
в общем картинке абсолютно тоже самое.
То есть
жило было вот это вот l.
И выяснилось,
что q на l меньше либо равно q.
В принципе, это мы знаем.
Вот, то есть
оказывается,
что это вот префиксная периодность,
она заканчивается q.
И более того, неожиданно
выяснилось,
то есть неожиданно выяснилось, что это строка l
периодично прям до q.
Да, кстати, это не вся строка,
это нас там правильно нарисовать, чтобы вот q.
А тут еще может быть дальше что-то.
И тут q, и может быть дальше что-то.
Но самое главное для нас
это то, что rich на самом деле
вот тоже идет
куда-нибудь вот там.
Вот так мы рисуем. То есть куда-нибудь дальше q.
У нас
в общем-то интересует до этого момента.
Но выяснилось, что k блоков
здесь на лицо.
Что тогда можно сделать?
Тогда можно заметить,
тогда отсюда
очевидно следует, что, что если это
a, то отсюда
очевидно следует, что a
больше либо равно,
больше либо равно
чем что, чем шизм.
У нас
обязательно
q содержит
именно точно количество
периодов p.
Почему у нас
нарисунки там
содержат ровно
какое-то количество периодов?
Он же может как-бы...
Это потому что
нет, мы совершенно правы, но я просто не очень
удачно нарисовал.
На самом деле я нарисовал здесь, что ведь он заканчивается
чуть раньше. Давайте, чтоб вас это не смущало,
я перенесу эту границу чуть-чуть.
Да, безусловно, конечно,
этого никто не даёт.
Да.
Ладно, как говорят,
как сказали бы очень бедонтичные
математики, q не обязана
быть на границе блоков, хотя
может там находиться.
Вот дайте это классику.
Полином в четвёртой степени это функция вида
ax в четвёртой плюс bx в кубе плюс
c в квадрате плюс dx плюс e,
где e не обязана быть основанием
натурального логариума, но может им быть.
Вот.
Что мы теперь имеем?
Что нам вообще
мешает сказать, что мы
победили? Ну, l меньше либо равно
уделить на h здесь очевидно.
А, ну не очевидно, а просто
то было, то было. Нам надо доказать, что shift
равен l.
Мы знаем, что l это кандидат в shift.
Следовательно, теперь думаем,
а вдруг есть меньше?
У нас вроде
лемма есть.
Нет, ну не совсем.
Ну, лемма, сейчас надо ещё применить
эту лему. Действительно так,
предположим, что совершенно случайно оказалось,
что у нас есть
там, я не знаю.
В общем, l'
в общем, короче, сдвиг меньше.
Ну, тут мы начинаем
пользоваться тем, что даже
2a меньше, чем q.
Ну, потому что
у нас q больше либо равно даже чем
4, на самом деле, да.
Но,
но тогда, что мы знаем?
Тогда, если, тогда уже эта строка
заведомо длиннее, чем l
плюс l', даже.
А из этого следует что?
Правильно. Что на самом деле эта строка
тогда gcd
от l' периодично. Правильно?
Ну да. А значит,
вот это gcd меньше l? Да, да, да.
То есть, если берём gcd,
но если вот это вот это gcd
от l',
даже вот давайте
вот,
или 4,
или такое, то
но тогда мы что видим?
Ну, тогда мы видим, что и эта строка, простите,
не базовая.
Просто она абсолютно не базовая,
потому что её можно распределить на
l' поделить на gcd одинаковых
кусочек.
Вот. Ну, что это тогда значит?
Ну, это значит, что это не префиксный период,
просто потому что в определении префиксного
периода прописано, что это ещё и
базовая строка.
Ну, то есть, видим, что
леммочка тоже не сильно
убольная, согласны?
Значит, ну и соответственно,
ну, в принципе,
значит, ну, в принципе,
на самом деле, да, эти хлеб на самом деле нам
хватит, чтобы хотя бы попытаться
сформулировать, ну, тоже
ещё не полностью, но алгоритм,
правда, который там будет,
как всегда, некоторые данные
запрашивать с небес по факсу.
В какой строке мы применяем теорию?
В какой-то абсолютно
поиспольной строке без.
Нет, нет, нет, вот у нас доказательствия,
у нас же должно быть больше
какого-то размера строка.
А, мы применяем эту теорию
к префиксу длины q строки s.
А почему у нас
q больше
чем s плюс?
Ну, не s, а l плюс l'.
А, очень
просто. Дело в том, что, во-первых, l'
меньше, чем n,
ну, мы же предполагаем,
что и 4 меньше, чем n, да?
А во-вторых, заметим,
что q больше, чем 2.
Потому что она даже больше, чем 4.
А, да, да.
Тут очень интересно получается.
Вот тут, да.
Вот.
Так что вот такая
красота.
Есть ли тут ещё какие-то
вопросы?
Всё понятно?
Всё понятно. Хорошо.
Нет, просто я тогда это должен
ликвидировать, потому что у меня тут
ещё алгоритм надо писать.
Двух досок
недостаточно.
То есть, с одной стороны, двух досок недостаточно,
что с другой стороны, это не та лекция, где вот
все эти определения леммы хочется стирать.
Так вот.
Итак, значит,
леммочка есть?
Лемма раз,
лемма два.
Что?
Нет, ну, смотри,
в том-то и смысл, что хочется,
чтобы весь написанный текст оставался
на доске.
Потому что где-то так-то
можно делать что угодно там.
Да, доску можно повергнуть там,
мел тут где-то и валяется, но я могу там
сберить, раздобрить это там.
Или вообще можно там достать экран
и я там буду статью показывать.
Пожалуйста.
То есть, тем более, что, по-моему,
надо вспомнить,
честно это,
на сколько в общем доступ
это статья находить.
Она 82 года, поэтому вполне вероятно, что
можно и так сделать.
Хотя, честно говоря, я вообще этот алгоритм, по-моему,
написание даже на русском языке, если честно.
Ну, тоже так.
82 год, то есть алгоритм придумали не вчера,
поэтому, возможно,
кто-то его уже переописал.
Так вот. И так пришло
время алгоритма.
А, нет,
не пришло время алгоритма.
А теперь придется, а теперь,
вот вы тут говорили о теореме.
Так вот. Ой, я ее
даже, наверное,
придется ввести
новый маркер.
Давайте введу новый маркер,
какой-то красивый.
Ой, так.
Мы в этой теореме красным не пользовались.
Да, мы пользовались только рыжим.
Ладно, давайте
воспользуемся красным. Внимание!
Теорема
о
те композиции.
Оп!
Внимание!
Любую строку П
можно
разбить
Разбить
на вот две строки.
То есть сказать, что
П равно УП.
Где?
Ну, давайте так.
Первая.
У В
не
более одного
префиксного периода.
И вторая.
И вторая.
Для нас еще будет важно,
что длина строки У
будет равна
очень сметанеющей.
О, вот.
Шифт
О
Шифт
Чего?
Странно, конечно.
То есть мы теперь смотрим на префиксные
периоды суффиксов.
У нас появляется
Нет, смотрите, фишка такая.
Просто, ну, утверждение
Утверждение здесь будет такое.
Нам просто будет
очень удобно
будет искать
подстроку в строке,
если у этой подстроки не более одного
префиксного периода.
И мы и будем. Значит, да, сразу
уговорить теорему мы, пока и не сегодня, доказывать не будем.
Да, вот, ровно тут начинается мистика.
Но там еще два проблем.
Во-первых, надо теорему доказать.
Во-вторых, там самого доказательства
будет недостаточно, надо еще
предъявить эффективный алгоритм,
потому что алгоритм потребует
не только это разбиение,
но и, собственно, желательно вот этот сдвиг.
Не, ну ладно, там в ложке, правда,
константом будет что-то типа
четыре трети, на самом деле.
Да, кстати, алгоритм
хорошо себя рекламирует.
Он упреждает, что сравнение символов
будет не более чем
что-то типа 5M.
Вот, кстати, еще приятно.
Ну, значит, идея
будет заключаться в следующем.
То есть идея будет такая, что
давайте пытаться искать
все вхождения строки В
под каким-нибудь вот этим алгоритмом.
А потом будем говорить,
что хорошо, мы найдем
все вхождения строки В,
но заметим, что
каждое вхождение,
которое мы найдем, к каждому из них
будем честно за О от У проверять,
нельзя ли к нему там слева перерисовать
еще В.
В чем, обратите внимание, уже из этой теории
мы следуем, почему само
по себе перерисовывание
вот этого У,
вот это перерисовывание У,
на самом деле асимптотики нам не испортят.
Вот давайте себе представим,
за какое время будут работать
собственно проверки У.
Вот смотрите.
Жил был наш любимый
текст Т.
Наши вхождения в текст Т
не больше, чем
генотетерит на шипство В.
Ну или, ну я вот по-другому
немножко сформулирую,
может быть, такую более простую мысль,
из которой следует твоя формулировка.
Я скажу так. Допустим,
у меня есть
вхождение строки П.
Где может быть следующее?
Ну, заметим, что
вот эта штука обязана быть
больше либо равна,
чем, соответственно,
шифт П
от модуль П.
Ну условно, логично, да?
Или в нашем случае,
если это П, это В,
то я здесь везде пишу В.
Логично, да?
То есть получается
расстояние между вхождениями,
минимум, шифт от В.
Следовательно, действительно,
самих вхождений будет не более,
чем Т поделить на шифт.
И, как следствие,
все сравнения У,
потому что каждая мысль сравнивает У,
только когда мы точно убедились, что В тут есть, да?
То есть сравнить вот это.
Они будут делаться за О от,
получается, У умножить
на Т поделить на шифт от В,
то есть получается О от Т.
То есть, следовательно, вот эта вот
гарантия того, что
достаточно искать
только под строки В,
и это нас застроит.
Все?
Значит, что я сейчас говорю?
Я говорю, значит, еще раз попытаюсь.
Теорию мы не доказываем, мы в нее верим.
Но я утверждаю следующее.
Теперь, с точки зрения алгоритма,
я утверждаю, что все, что нам нужно,
это найти, перечислить.
Конечно, у нас единицы памяти,
все вхождения мы, конечно, в В записать не можем,
но хочется в том или ином
виде перечислить все вхождения
именно строки В.
Не все строки П, но только
такой строки В.
Почему этого достаточно,
если мы это за линию сделаем?
Достаточно это
вот почему.
Дело в том, что мы можем заметить,
что любые два вхождения строки В
в тексте,
они, между ними,
их начало по позициям
находится на расстоянии, как минимум,
вот это. Правда?
Логично, да?
Ну, потому что shift это буквально.
На какой минимальный число символов можно тут сдвинуть
строку В, чтобы тот префикс совпал с суфиксом?
Правда? Прямо по определению.
Отсюда автоматически следует,
что количество вхождения
В в Т,
количество вхождений
В в Т
не превосходит
модуль Т делить на
shift.
Ну ладно, чтобы совсем формально было
плюс 1, конечно.
Потому что есть первое, а каждое следующее
плюс shift, плюс shift, плюс shift.
Хотя ладно.
Скорее всего, ну давайте
напишем плюс 1, потому что нам по барабану.
По хорошему, конечно, если очень внимательно посмотреть,
тогда на плюс 1 можно избавиться.
Ну да,
его можно избавиться, потому что
для каждого вхождения
существует его префикс,
на который в качестве начала другого
вхождения никто не посягает.
Следовательно, плюс 1 можно даже не писать.
Вот.
Это мелочь.
Вот.
Просто дело тогда такое.
Предположим, что у нас будет алгоритм,
а у нас будет алгоритм,
который перечислит
в том или ином виде
все вхождения строки В через Т.
Ну представьте себе, что мы пишем алгоритм
на питоне и пишем его
в формате генератора.
Понятно, о чем я говорю?
Да, у нас был генератор.
Может, у вас там генераторов не было,
я не знаю.
Ну понятно, малы вероятны, конечно,
что у вас такой красоты не было.
Тем более, что в питоне это святое.
Ну то есть, предположим, что мы там
просто в этом алгоритме каждое очередное
вхождение, которое мы нашли, мы там
называем, конечно, умное слово, Yield.
Ну вот, соответственно.
Или Yield.
Yield.
Игры или Yield.
Вот.
Так вот, теперь алгоритм такой.
Запускаем этот генератор, и он нам Yield
вот эти все В.
Тогда каждой найденной В
мы проверяем,
а нельзя ли к этой В
привисовать еще и ушку слева.
Проверяем честно за U.
И тогда получается,
тогда сама по себе проверка
ушек будет работать за вот это
умножить на U.
Но если U это O от шифта,
то тогда тут шлеп-шлеп получается O от D.
То есть, таким образом,
мы с вами, пока имели идейно,
свели задачу
к тому, что
вот, ну не свели задачу,
но там вот к двум задачам.
Во-первых, как за O от P действительно
найти такую-нибудь композицию?
Эту мы сегодня решать не будем.
И второе,
как найти все вхождения
строки, у которой
не более одного
префиксного периода.
То есть, мы как бы теперь,
то есть, мы как бы ввели на шаблон требования.
Ну, на самом деле, идея
здесь очень простая.
На самом деле, они нам говорят,
значит, просто
если мы в это поверим,
если мы в это поверим,
то сейчас будет немножко баня.
Значит, если мы сейчас верим
в эту,
если мы верим в эту
сеть,
то получается,
то алгоритм значит такой,
ну, то есть,
то значит, нас сейчас
интересует что?
Нас сейчас интересует,
как мы будем
превращать
P Q
в
P' Q'
Ну, вот. То есть, нас
вот этот шаг будет интересовать.
И при этом, ищем
В
В вот так.
Смотрите.
В случае номер изя.
Видите, в случае номер изя.
У В нет
префиксного периода.
Вот можем себе представить
вот пусть у нас в легкий случай
префиксного периода нет вообще.
Тогда
сейчас
тогда решение будет
неожиданно тупо.
Тогда P' Q'
равно
вообще, просто неожиданные вещи.
Все.
Все.
Ну, ладно.
Тут, конечно, надо еще подписать кое-что.
P плюс максимум
из вот этой штуки
и единицы, конечно.
Ну, Q' может так нулемой остаться,
как бы,
ну, Q' может так нулемой остаться,
как там Антон уже правильно говорил.
Ну, вот. Внимательно
посмотрите на доску
и скажите мне, откуда
я это гляну.
То есть, мы, по сути, утверждаем,
что у нас уже не может быть точно в хождении
В.
Ну, вот. Начинаешься от P
до P плюс максимум.
От P плюс Q'
Ну, потому что если оно есть,
то вот
и префикс длины Q как раз,
вот тот, на котором мы сейчас,
и тот, который будет в хождении,
у них разница между их началами
меньше, чем Q' на K,
ну, не больше, строго.
А значит, тогда как раз префикс длины
Q' на K, он, ну, как бы
этот шифт, он
хотя бы 4 раза подряд встречается.
А шифт еще и базовый,
то есть, это префиксный период, который
существует.
Ну, на самом деле, это рассуждение было уже
как черный ящик зашиться вот сюда.
Да.
То есть, он примерно воспринимал доказательство
этого утверждения.
То есть, действительно. То есть, это утверждение говорит,
то есть, если его развернуть, звучит так.
Если у этого, значит,
если у S нет префиксного периода,
то шифт от Q
заведомо, строго больше
или больше либо равен, чем
Q' делить на K,
округленное вверх.
Ну, просто больше либо равен, чем Q' делить на K,
а значит, еще и округленное вверх.
То есть, поэтому я тут просто приписываю
в тупо лемма один.
Но вот теперь самое
интересное.
Самое интересное.
Хорошо.
То есть, это, конечно, очень удобно.
То есть, алгоритм предельно тупой.
То есть, я беру P, насчитываю в нем
типа Z функцию, а потом каждый раз
скачу вперед на четвертую
часть отнасчитанной Z функции.
Внимание, вопрос.
Так, теперь внимание, вопрос.
А вот, если мы подставим такие
P' в Q' них, будет ли это работать
за линейное время?
Ну, вроде должно, потому что
на каждое тупое прибавление Q'
один, потом
в Q' один,
и в Q' один,
на каждое тупое прибавление Q' один,
потом мы сделаем сдвиг
на одну четверть.
На каждое четыре прибавления в тупую,
у нас сдвиг этого P' на один вправо.
Ну,
на каждое
четыре
сдвига Q'
у нас будет вот
в этом цикле.
Каждая конкретная Q' может двигаться
с нуля сколько угодно, но
на каждые четыре шага, идущие подряд
Q' мы заявляем, что P'
хотя бы на один увеличится.
Ну да, но если это не последний какой-то шаг.
Ну да, кроме последнего шага,
который мы отбрасываем.
Получается, четверок
Q'
будет суммарно
не более чем. Получается, суммарно
и текушки будут увеличиваться не более
чем на
4n, ну kn.
Ну, может там k плюс 1n.
Так, вообще-то
странно. Вот, кстати, те самые
5n, в смысле 5 модуль
t, в общем-то уже и вырезаны.
Нет, не 5 модуль, а 5 модуль
t.
Так, то есть понятно,
почему алгоритм с такими
поштрих-пуштрих работает за лиги.
Да, нет, наверное.
Да-да.
Так, если не понятно,
если не понятно, лучше переспросить.
Потому что зрителям тоже может быть непонятно.
Почему мы можем применить
Y1?
Потому что, смотри, мы прописали,
что у V нет
префиксного периода вообще.
А мы еще обхождение есть именно в F.
Сейчас смотрим.
Вот мы тут, теперь мы насчитаем,
мы говорим.
Так, вот жили-были мы,
вот мы где-то в позиции P
и насчитали префикс длины Q.
То есть вот, просто
в V-шке это вот
префикс длины Q.
Теперь мы можем
сдвинуть P на
фактически shift
от Q. Правда?
На shift с
индексом V от Q можем сдвинуть.
Правда?
Ну как там завещали?
Shift, да, shift причем строки V.
Но теперь заметим следующее.
Префиксного периода
у строки V
нет.
Тогда, согласно лейме 1,
из этого следует, что shift
от Q тогда должен быть строго
больше, чем Q поделить на K.
Поэтому мы четырим
следующим образом. Мы не знаем,
чему равен shift, но мы знаем, что он
больше, чем Q на K. Поэтому давайте
тупо на Q на K сдвинем и будем
соответственно дальше засекать
в тупую.
То есть видим, что мы тут
из Q этот shift не вычитаем, а
просто говорим, давайте с нуля и не заморачиваемся.
Вот такая идея у нас.
Это был вопрос
на тему того, почему этот алгоритм
вообще работает.
Тут два всегда вопроса. Почему алгоритм работает
и почему он работает быстро?
Есть ли еще вопросы, почему этот
алгоритм работает правильно?
Есть вопросы?
Нет вопросов?
Ни у кого нет вопросов.
А почему работает он
быстро, тоже понятно?
Сейчас только что был
вопрос на тему того, почему этот
алгоритм работает.
Не было вопросов, что он работает
быстро?
Ну нет.
Почему?
На эту тему пока вопросов
не было. Я пытался спрашивать, все ли понятно,
но вместо этого
вспомнил вопрос, почему он работает.
Поэтому я уточняю. Есть ли еще
вопросы на тему, понятно ли, почему
вот предложенный алгоритм работает за
линейное время?
Можете еще раз это повторить?
Почему у нас, когда мы
сбрасываем до нуля,
это не возвращается в какую-то большую
связь?
Заметим, что у нас
в хождении, ну то есть
давайте теперь я так порисую.
Gил, нолт, хб. Мы начинаем
с нуля и мы обрабатываем.
Сначала у нас есть
позиция х0,
потом позиция х1,
потом позиция х2,
потом позиция х3,
ну они там так куда-то
доходят,
так куда-то доходят и так далее.
Так куда-то доходят,
там их несколько.
При этом мы
проходим, получается
длинные q1,
q2, вот может
q0,
ну да.
То есть мы начинаем,
проходим q0, q1, q2
и так далее.
То есть получается,
наше время работает,
то есть наше время
оно на самом деле
примерно o от q0
плюс q1, плюс q2,
плюс и так далее,
плюс q там какой-нибудь там
colt, col-1,
ну и плюс там
mt, ну и плюс там mt.
А q у нас же
не больше,
не больше чем 1п?
Да, нет, но q,
на самом деле, да,
то есть каждая qt,
оно,
каждая qt,
оно чему, оно
фактически чему равно?
Оно на самом деле не превосходит
x и плюс 1,
минус x иt,
умножить на k.
Логично, да?
Тогда получается,
то есть это получается
меньше либо равно, чем o от
значит
x1 минус x0 на k,
плюс x2 минус
x1 на k,
плюс там x3 минус
x2 на k, там плюс
и так далее, плюс mt.
Но если я это все посуммирую,
то это получается равно o от
mt умножить на
там что-то типа k плюс s.
Но как-то это константа.
Вот.
Ну то есть вообразить
себе можно так,
что
вообразить себе можно так,
что допустим
ну вот
ну да, то есть по сути, да, то есть заметим,
что
правильно сказали, что
каждые 4 прохода кушки
за каждые 4 прохода кушки
мы получается
на каждые 4 прохода кушки мы тратим монетку
мы тратим монетку
сдвига
будущего, следующего начала
и сдвигать это начало мы можем не более,
чем t раз.
Ну можно еще и так, вот тут какая-то такая идея
вот, честно говоря,
может совсем прям красивый амортизационный
образ придумать.
Ну хотя, видите, в основной действительно
каждые 4 шага кушки это как бы
один шаг больше.
Вот, получается красота, ну по модулю того,
что откуда такую v взять?
Поэтому теперь давайте попробуем
более сложный
что-то более сложное.
Значит давайте
попробуем.
Значит это я сейчас все убираю.
Ну, то есть
амортизационная логика это будет более-менее
та же,
но теперь будет чуть-чуть более сложная.
Значит b
если же
у v
есть
единственное, внимание,
единственное
префиксный период f
и вот
f
1
ну, в смысле все спало.
То
идея такая.
Значит первое.
Значит
при
хп1
меньше либо равно
f это префиксный период?
Чего?
хп1 это префиксный период
или просто период?
Префиксный, ну как бы
все время требовалось префиксный период.
Значит мы будем прибыть. Вот пусть мы
знаем, что v не просто единственный
префиксный период, но мы еще его откуда-то
выкопали.
Да, нам для алгоритма придется его знать.
Тогда, смотри.
Тогда, когда мы насчитали х,
предложение будет следующее.
То есть, если выяснится,
что хп1 меньше либо равно
проверить это легко, потому что
хп1 мы заранее знаем,
ричадп1 мы тоже можем заранее
быстренько вычислить. Правда?
Вот, поэтому это для нас
большой проблемой не будет.
Но, тогда, раз так,
то тогда, в этом случае,
что мы должны сделать?
Ну, мы можем леммой 2, видимо, воспользоваться.
Да, мы можем воспользоваться
леммой 2.
Что это верно тогда и только тогда,
когда получается шифт ради
чему?
Префиксному периоду строки С,
правда?
То есть,
то есть, префиксному периоду,
но тогда, действительно,
то есть, тогда пишем, что
pq просто превращается
в p плюс p1
q минус p1.
Заметим, что
действительно, в этом смысле,
то есть, в этом смысле, да,
то есть, амортизация тут не совсем такая получается,
но замечаем, что у нас, получается,
правый указатель никуда не сдвинулся.
То есть, как мы тему решим прайти.
Вот, нашли префикс, значит,
начинаем отсюда и знаем, что до сюда
уж точно дойдем.
Вот. Ну, сейчас давайте я вторую допишу,
потом мы попробуем.
Ну, вот.
Ну, а если иначе?
Ну, а
если обнаружилось, что это
не верно,
то что тогда можно сказать?
Ну, тут
странно.
Потому что в таком виде, конечно, утверждение
говорит, что если вот это случается
и не верно,
ну, как бы, то
тогда утверждается, что
shift, на самом деле, будет просто строго
больше, чем q на х.
И все, что мы делаем тогда, это
как всегда.
Значит, пишем тут
p плюс
максимум, как всегда,
из q на k
1.
Вот.
И дальше, соответственно, пишем.
Вот. Ну, и здесь, соответственно, пишем.
Швы будет больше, чем q на k,
потому что если он не больше, то по лейме 1
это и будет как раз
примерно так.
Ну, получается, так. Да, действительно.
Да.
То есть, действительно, какой тут должен быть shift?
Да. Если shift будет...
Да, то есть, получается, тут пишем лемма
2.
Ну, а тут получается обе леммы.
Давайте внимательно посмотрим.
Значит, как получится?
То есть, действительно, какой shift должен быть?
То есть, если тут shift оказывается
меньше либо равен, чем q делить на k,
действительно,
то оказывается, что это
префиксный период s.
И тогда надо сдвигаться на
p1.
Нет, хотя нет, погодите.
А может быть, он и есть префиксный период?
Ну, p1.
Вдруг p1? Здесь же никто не требует.
Может, вот это утверждение верно?
А может быть, вот это не верно?
Не может, потому что мы уже по лемме 1
как раз понимаем, что shift будет обязательно
префиксным периодом s, а у него
единственный префиксный период p1.
Ну, а кто сказал, что l не равно
по стату по p1?
Тогда, наверное, правая часть по лемме 2 же.
Ну, так, прям полностью верно.
Ну, еще раз. То есть, мы сейчас
говорим, что если вот правая часть не
верна по лемме 2, то мы хотим сказать, что shift
больше, чем q делить на k.
Почему? Если он не больше,
то по лемме 1 бы замещать shift
и будет равен
p1. Ну, тогда по лемме 2
будет верна правая часть.
Ну, тут, правда, какая из них не верна?
Так, ну давайте разбираться.
Так, нет, нет.
Сейчас может быть равен p1,
но тогда он будет все равно больше q
на q.
Ну, shift может быть
равен и p1,
shift может быть равен и p1,
и меньше p1, и больше p1.
Нет, нет. Вроде все же работает.
Так, ну давайте разбираться.
Мы хотим показать, что shift от садков больше,
чем q на q, чтобы показать,
что мы можем на q сдвинуться. Да.
Ну, предположим, что это не так.
Так, пусть shift действительно
меньше либо равно q на q.
Тогда по лемме 1 shift
равен линии префесного перевода s.
То есть равен обязательно
p1. Да.
Да, он равен p1.
Ну, тогда p1 равен shift
не больше q на q. Да, по лемме 2
p1 на q не больше q
не больше, чем reach s от p1.
Это вот первый случай в пункте b.
Так, хорошо. То есть это утверждение верно.
То есть ладно, это утверждение
тогда в этом случае верно. Если там
вот это верно, да?
Ну, с другой стороны, тогда, ну вот,
тогда нигде пока
противоречия не вижу.
Ну, противоречие с тем, что shift
не больше q на q. Ну, с тем, что вот
мы в пункте 2, вот тут внизу,
и с тем, что shift не больше q на q.
Ну, как бы нет.
Ну, само в себе
ну, как бы нет. В этом пункте
говорится, что пока мы знаем только одно,
что kp1 может быть меньше либо равно q
во втором пункте, просто при этом может быть,
что q как бы
строго больше. Ну, да-да-да.
То есть в первой части l2
l2 не верно, значит первая тоже.
Ну, а если shift не больше q на q, то первая часть верна.
Так, хорошо.
Значит, если это не верно,
то это тоже не верно.
А так как вот это верно, то получается,
что l не равно p1.
Так.
Если shift не больше q на q,
то по лейме 1 shift
будет прежним периодом s.
А у нас единственный прежний период
у s, он и есть p1.
А l2 будет равен shift не больше,
чем q.
Так.
Ну, да.
А, ну да, l.
Да, он так...
Ну, да, правда может быть,
что этого...
Ну и что? Ну, правда.
Так, не, при l это прежний период.
Допустим, это p1.
Но при этом, может быть,
так, сейчас.
А, ну да, по лейме 1 этот shift
еще и претекстный период.
Поэтому они равны l меньше либо равно k.
Да, противоречие.
Вроде да.
Все, нет, все еще нет?
Так, ладно, давайте как все то же самое,
но в текстом подпишем.
Значит, смотрим.
Итак.
Значит, поехали.
Итак, значит, вот в этом случае,
вот во втором,
пишем рассуждение.
Значит, хотим показать,
что shift,
давайте, аккуратненько,
хотим показать,
что shift
с индексом v
от q строго больше,
чем q поделить на.
Ну, фактически,
там это достаточно попадается.
Значит, поехали.
Значит, от абсурда.
К
допустим умножить
на shift.
В от q оказалось
меньше либо равно.
Вот, а лучше
shift это
не шли бы.
Вот.
По лейме
1
значит,
значит, s от
1, ладно, v
от 1
shift
v
префиксны.
И вот.
Ну, как минимум,
v от 1
и 7v.
Ну, понятно, если он
как бы префиксный период какой-то v-шки,
то он и префиксный период сестры.
Правда?
Значит, из этого
автоматически следует,
ну, так как у нас
помним, что v единственный
допоминаем префиксный период.
То есть, из этого следует,
shift v
от q
равно тупо p1.
Вот.
Тогда,
то есть, тогда
получается
этот p1
равно
shift v
от q
меньше либо равно q поделить на k.
И тогда
по лейме 2
из этого следует,
что k на p1,
прям честно лему переписываю,
меньше либо равно q,
значит,
меньше либо равно reach,
значит, с индексом
получается той же самой v
от l.
А l в нашем случае p1.
Так.
Так.
Так.
Ну, вот.
Но,
а противоречие в чем?
А противоречие в том, что
это другой случай.
То есть, получается, что
получается, что так можно.
Получается, что так можно.
И получается,
мы победили.
Остается только теперь
более аккуратно взглянуть на это
и посмотреть, почему вот эта теперь
версия начинает работать за линию.
Ну, слава богу, в случае вот этих мы можем,
если нам p1 кто-то из кармана
достал,
вот кто-то взял,
да, действительно, достал он
из кармана, ну вот,
мы легко можем убедиться в том,
что мы-то как бы за вот единицы
можем на каждом шаге проверять, какой случай реализовался.
Правда?
Но теперь получается следующее, что
в первом случае получается
каждое увеличение куб,
то есть, по сути,
получается так. Каждое...
Ну, тут вот не совсем так.
Нет, хотя нет, так.
Тут
хитрость такая,
что, на самом деле,
видите, пэшка получается
увеличиться на...
То есть, тут так, с одной стороны,
пэшка увеличится на...
всего лишь на p1.
Ну вот.
Но при этом кушка никуда
не встретился.
Понятно, да?
Вот, поэтому...
Ну, то есть, на самом деле,
теперь последняя, конечно,
на сегодня задача, это
померить вот эту амортизацию с этой.
То есть, если была верна только эта,
то это были бы просто два указателя.
Вот это работает, по принципу,
что каждое движение,
каждые четыре движения кушки,
дают движение пэшки вправо.
Здесь это как бы откровенно не так.
Тут я открыл эту статью,
тут гениальная просто идея,
как это сделать.
Вот, можно посмотреть на число
k плюс 1p плюс q.
K плюс 1p плюс q?
Оно не убывает при любой
из этих операций.
Ну, вообще, практически каждая операция
дает нам прибавление этой штуки.
K плюс 1p плюс q?
Да.
Слушай, какая красота.
Ну ладно, не буду сейчас
бумажку отыскать.
Да, действительно.
То есть, можно действительно заметить,
рассмотрим число,
так сказать, псевдо-фи такое.
Псевдо-потенциал.
Так, ладно, давайте оруди
псевдо-фи.
Псевдо-фи.
Псевдо-фи.
Псевдо-фи.
Псевдо-фи
будет равно k.
Все там k плюс 1 на p, да?
Да, плюс q.
Да.
Ага.
Ну да, заметим, что да.
Каждое, ну,
каждое само по себе движение q,
конечно, увеличивает этот потенциал, да?
Так, каждое q увеличивает.
А теперь, когда мы делаем
неожиданно q заменяем на вот это,
то потенциал увеличивается.
А когда мы делаем
вот это,
то потенциал тоже увеличивается.
Да, он уменьшается на q,
но зато сразу увеличивается на
больше, чем на q.
Да.
Красивый способ.
Но так как q у нас больше, чем
модуль v не становится, то получается, что
в 5v действии мы как-нибудь уложимся.
Остается
только, правда, один момент.
То есть, во-первых,
поверить в эту теорему.
А во-вторых, что более сильно?
Значит, во-первых, найти,
как за линию распилить эту строку
p на такие две строки.
А еще желательно убедиться, есть
любый префиксный период, и если есть,
то кто он?
Вот.
По-моему, в этом месте они
тоже начинают говорить, что мы уже писали
статью, как что-то там делать.
Знаете,
подлянка такая, что обычно эту статью
вы читать, может, особо не будете, потому что
статья называется,
сейчас скажу как, ссылка
номер 8, тоже
То есть, видимо, 80-го
года, тоже 20-го лет. Будет выглядеть как
просто маленькие лайфхаки, как сэкономить памяти.
В чем? Насколько они будут принципиально
непонятно с ледом, поэтому непонятно,
читать или нет. Но потом, как бы они скажут,
а мы на этих лайфхаках все по всему.
Там, вроде бы,
ну, все темно и видно, что они
в этом, как раз вот эти статьи, ссылки по
номеру 8, они уже предложили алгоритмы,
которые используют достаточно
мало памяти, чтобы можно было временно
укладывать ее внутри строки, или что-то
такое, что
это такая ерунда.
Ну, это да. Но, на самом деле, нет, ну, как бы
для полного счастья будет, конечно, интересно
просто, наверное, открыть эту штуку,
потому что, возможно, там еще пара слоев каких-нибудь
интересных строчек есть.
Так что, я очень надеюсь, что
нам удастся в какой-то момент, действительно,
это добить, потому что, так, минимум
интересно.
