У нас 11 лекция, и в основном мы будем говорить про сумму
Минковского, но также про некоторые другие алгоритмы.
Начнем в частности с другого алгоритма, но главная тема
будет суммой Минковского, значит первый алгоритм
будет такой, первый алгоритм позволит нам найти две
самоудаленные точки в данном множестве точек, значит
есть множество с, есть с множество точек, мы хотим
найти максимум расстояния между любыми двумя из них,
максимум расстояния между п и q, где п и q это произвольные
точки с.
То есть две самые далекие точки с данного множества.
Вот, ну там, разумеется, можно перебрать все пары
за n в квадрате, но это не интересно, мы сделаем алгоритм
за n лога.
Значит первое замечание, которое можно сделать, чтобы
решить эту задачу, это понять, что на самом деле нам достаточно
в качестве п и q рассматривать только вершины выпуклополочки,
то есть максимум достигается на вершинах выпуклополочки,
множество с.
То есть это легко понять, если это не так и мы нашли
какое-то расстояние между двумя точками по и q, то скажем
мы можем просто этот отрезок продлить до тех пор, пока
он не пересечется с границы выпуклополочки.
Ну вот как-нибудь так, например, вот здесь пересечется.
И тогда либо мы уже автоматически попали в вершину и соответственно
мы получили какой-то больший отрезок, то есть п мы оставляем,
а вторую точку меняем, так что у меня увеличилось
расстояние, значит искомый отрезок не максимальный.
Значит если мы попали в вершину, все очевидно.
Если же мы попали на отрезок, то я утверждаю, что можно
обязательно смещаться либо вверх, либо вниз по этому
отрезку так, чтобы расстояние обязательно увеличилось,
ну или по крайней мере не уменьшалось.
Потому что, ну значит, по сути мне интересно изучить
функцию расстояния от точки какой-то p до точки вот
этого вот отрезка, до точек на стороне.
Ну понятное дело, что если мы из p, скажем, опустили
бы перпендикулярно эту сторону, то у меня было бы минимально
возможно расстояние, а дальше вот в эти две стороны
вверх и вниз, расстояние будет только расти, соответственно
здесь будет гипотенуза прямоугольного треугольника
со все большим вот этим вот углом, поэтому гипотенуза
будет расти.
Ну и здесь тоже самое, все синетричное, гипотенуза
будет тем больше, тем больше угол, то есть чем дальше
точка удаляется от основания перпендикуляра.
Значит точно так же и здесь, если бы мы опустили
p на продолжение стороны, то есть на прямую содержащую
нашу сторону, то движение в любую сторону от этой
точки мне будет увеличивать расстояние, значит то же
самое здесь, если мы продлили отрезок q и пересекли сторону
в какой-то точке r, то обязательно движение в одну из сторон
нам точно будет увеличивать расстояние, поэтому вместо
q можно будет взять вот эту вот вершинку, расстояние
только увеличится.
Значит то же самое с p, и получается, что в качестве
обеих вершин q можно брать только вершиновую коробочку.
Давайте что-нибудь напишем, иначе отрезок можно продлить
до пересечения со стороной коробочки, ну а дальше как
я сказал подвинуть в одну из двух сторон, чтобы увеличить
расстояние.
Все, понимаем, что нам достаточно рассматривать вершины новой
коробочки, все внутренние нас не интересуют.
Значит благо у нас уже есть алгоритм построения
в коробочке за n log n, мы его делали в прошлый раз несколько
всяких, тогда первый наш шаг это за n log n построить
в коробочку, встроим, конвекс от s, ну где n это как всегда
число точек less, а дальше, ну по сути, что такое максимально
расстояние, это не можно говорить диаметр, диаметр
просто по определению, диаметр любого множества, это
максимальное расстояние между 뭔ими и либо двумя
его точками, это по сути мы ищем диаметр нашего
множества с, расстояние между двумя самыми далекими
точками, тогда есть следующая простая лемма, лемма пусть
q это диаметры с, но то есть расстояние q, расцена между
q максимально среди всех возможных пар точек s, то
то есть dist между p и q равно максимуму по всем p звёздочка q звёздочка из s, dist p звёздочка q звёздочка.
Хорошо, вот мы взяли диаметр, тогда давайте мы проведем две прямые перпендикулярные этому диаметру, которые проходят через p и q.
Проведем прямые l1 и l2, перпендикулярные q.
Ну, соответственно, проходящие через p и q, соответственно, через p и q, соответственно.
Тогда, утверждается, s целиком лежит между этими двумя прямыми l1 и l2, s целиком лежит в полосе между l1 и l2.
То есть, картинка будет такая, вот есть у вас ваша, ну, выпукла оболочка, да, мы понимаем, что мы можем заменить s на выпукла оболочку, ничего от этого не изменится.
И есть у вас какие-нибудь две точки, на которых достигается диаметр, вот по yq.
Мы проводим этот отрезок, проводим прямые, ортогональные этому отрезку, проходящие через точки, да, через вершины этого отрезка,
будет вот такие две прямые l1 и l2, соответственно, здесь прямой угол, и здесь прямой угол.
Ну и тогда Лему утверждает, что как бы левее l1 и правее l2 ничего нет, то есть как раз надугольник, так, сломалась, надугольник s целиком лежит между этими двумя полосками.
Ну, это очень простое утверждение, потому что если это не так, и, например, есть какая-нибудь точка за l1, тогда мы можем просто вместо p взять эту точку, и тогда расстояние q до этой точки будет больше, чем расстояние до qp.
Потому что от q ближайшее расстояние до l1, то в точности qp, да, ну, потому что это отрезок, вот, ортогональный обеим левым уголом.
Ну, конечно, это просто расстояние между прямыми, минимально возможное расстояние.
Тогда если есть какая-то точка за вот этой вот l1, где-то левее, тогда расстояние от нее до q будет только больше.
Ну, потому что, во-первых, вот здесь какой-то кусочек отрезка, потом еще гипотенуза вот такого вот прямоголемо-триугольника, прямой угол,
два катета и гипотенуза, то есть тоже еще больше, чем qp.
Поэтому любая точка за пределами вот этих вот двух прямых, за пределами этой полосы нам говорит, что диаметр на самом деле должен быть больше.
Ну, значит, тогда противоречие. Доказательства просто опротивлены.
Хорошо, значит, мы поняли, что если вот так вот подпереть, провести такие опорные прямые перпендикулярные диаметру в точках диаметра, в концевых точках диаметра,
то получится полоса внутри, которая целиком заключила наш нагугольник.
Значит, опорные прямые ограничивают полосу, в которой целиком лежит наш нагугольник.
А давайте мы вот эти вот две опорные прямые l1 и l2 будем синхронно вращать.
Значит, мы понимаем, что l1 и l2 параллельны, раз они не ортогональны одному и тому же отрезку.
Тогда давайте их синхронно как-нибудь монотонно вращать.
Скажем, ну, вот тут повернул мне какой-то небольшой угол, здесь тоже повернулось, тут продолжаем вращать, тут продолжаем вращать.
Ну и в какой-то момент мы дойдем до состояния, когда l2 совпадет, ну, там одна из прямых совпадет с одной из сторон.
И когда при дальнейшем вращении, скажем, l1 продолжит вращаться относительно точки P,
а l2 начнет вращаться относительно уже другой точки.
То есть мы не можем в старое состояние, если мы продолжаем вращать, скажем, по часовой стрелке,
тогда у меня меняется как бы опорная точка, вокруг которой происходит вращение.
То есть это обязательно становится другой конец стороны.
И всегда, когда одна из прямых начинает проходить через сторону, и мы продолжаем поворот,
тогда опорная точка, вокруг которой вращается прямая, она меняется.
Ну и давайте так просто обе эти наши прямые совместно синхронно вращаем целиком, да, пройден весь круг, весь многогольник.
И по сути мы получили все возможные опции для того, как могут выглядеть вот эти две опорные прямые.
То есть две прямые, проходящие через вершины диаметра, проходящие через вершины диаметра.
Ну и значит мы как бы переберем таким образом все потенциальные пары на диаметр,
да, мы берем все пары вершин такие, что вот между ними,
что если провести опорные прямые в этих точках, то получится как раз кандидатный диаметр.
Ну тогда мы просто все такие перебираем, их будет от n, в этом легко убедиться,
потому что, ну в общем, когда у меня вращается одна прямая, она проходит всего от n конфигурации.
L1 проходит как бы n возможных, ну там сторон или вершин. L2 точно то же самое.
Ну и в каждом момент времени у нас получается там какие-то две точки рассматриваются в качестве кандидатного диаметра.
Ну и соответственно мы всех этих кандидатов просто переберем и выведем максимальное расстояние между ними.
Вот такой вот наш лейтенант.
Вот этот пагаритм.
Такой. Ну давайте в самом начале поговорим, что L1, L2 это крайняя левая вертикальная и правая вертикальная прямая.
L1 это крайняя левая вертикальная прямая.
L2 это крайняя правая.
Ну то есть в нашей оболочке мы находим вершину с минимальным x и с максимальным x.
Вот так и нарисуем.
Вершину с минимальным x проводим здесь L1 и вершину с максимальным x проводим здесь L2.
А дальше начинаем эти L1, L2 синхронно вращать.
L1 и L2 синхронно, то есть одновременно вращать.
Так, я вот тут начал по часовой стрелке делать.
А давайте я все-таки переделаю и давайте против часовой.
Мне так будет немножко удобнее.
Синхронно вращать против часовой стрелки.
Против часовой стрелки.
Ну большую часть времени у меня это вращение, оно ничего не поменяет.
Например, если я ненамножко, на чуть-чуть вращаю обе эти прямые относительно вот этих вот опорных точек,
то у меня будет что-то вот такое и вот такое.
Они обе останутся опорными.
Опять, кандидатный диаметр это все та же пара точек PQ.
Самая крайняя левая и крайняя правая, то есть минимальным x и максимальным x.
И ничего не поменяется.
У меня новой пары кандидатов не появится.
Дальше, если буду вращать, продолжать, то что-то начнет меняться только когда одна из прямых совпадет с одной из сторон.
То есть будет ей параллельно, будет ее содержать.
Ну и тогда в этот момент мне нужно переключиться и сказать, что теперь вращение происходит не относительно вот этой старой точки Q,
а относительно вот этой точки следующей точки Q звездочки.
И так будем вращать, понимать, когда происходит переключение, то есть когда у меня меняется опорная точка вращения у каждой прямой.
И тем самым каждую пару опорных точек мы будем проверять на, ну, мерить между ними расстояние и выбирать максимально.
Итак, значит, переключение опорных точек происходит, ну, давайте я пишу O10 раз, O10 раз.
Потому что L1 суммарно, значит, когда она вращается, ну представьте, чтобы вот эту исходную вертикальную прямую вращаете вот так вот,
целиком прокручиваете весь круг с градусным мером 2p.
Тогда у вас, значит, будет такая прямая, потом будет вот такая, она продолжит крутиться, крутиться, крутиться,
и в итоге она за весь круг обойдет весь ваш ноглугольник.
И таким образом каждая вершина побывает опорной ровно один раз для каждой из двух прямых.
И поскольку у меня две прямые, то, соответственно, каждая вершина побывает опорной два раза для L1 или для L2.
Ну, соответственно, суммарное переключение будет O10, 2n максимум.
Вот, и тогда, значит, в каждый момент, в каждый момент переключения опорной точки, ну одной, одной опорной точки,
измеряем расстояние между текущими опорными,
между текущими опорными,
ну и обновляем ответ, обновляем ответ.
Вот, ну такой несложный алгоритм, просто нужно все провращать.
Соответственно, каждая пара вершин, в которые мы убираемся, слева и справа, это есть наш кандидатный диаметр.
Поняли, да, что если есть диаметр, то обязательно вот эти две прямые будут обязательно будут опорны, и мы их когда-то переберем.
Ну, тогда мы как бы перебираем все возможные кандидаты на диаметр, все их измеряем,
и соответственно максимальное расстояние между ними будет диаметром нашего множества.
Вот, ну давайте немножко технической технических деталей, как делать вот эти вот все повороты.
Значит, есть у меня наш многоугольник, вот изначально L1 где-то здесь, L2 здесь.
Тогда вопрос, когда впервые у меня при вращении будет изменена опорная точка?
То есть я вот как рисовал, если я на небольшой угол поверну, то у меня ничего не поменяется,
ничего не поменяется, ну и в итоге что-то изменится, когда у меня одна из прямых начнется держать в сторону.
И причем эта сторона должна иметь наименьший вот этот угол, то есть вот здесь мы измерили как бы угол,
вот здесь измерили угол, то есть на какой угол надо перевернуться, чтобы начать содержать следующую сторону,
и соответственно минимальный из них, и скажет мне где происходят впервые переключения опорной точки.
То есть мне по сути надо померить вот эти два угла и сказать какой из них меньше,
какой из них меньше, соответственно, там будет переключение первое.
Но вместо того, чтобы мерить углы, мы можем просто сравнить векторные произведения.
А именно, смотрите, вот есть у меня сейчас такое вертикальная наша прямая, вертикальная прямая.
Давайте проведем векторы, соответствующие вот этим вот двум следующим сторонам.
Первая сторона, вот эта вторая.
Так, значит, тогда я утверждаю, что, если их назвать УВ, тогда переключение L1 произойдет раньше,
то есть раньше, раньше, чем на L2, если только, если векторное произведение векторов У и В,
сейчас скажу иметь какой знак. В этом нашем случае у меня векторное произведение отрицательно,
а здесь было бы положительно, меньше нуля. Ну то есть смотрите, вот я рассматриваю сторону,
где будет следующий поворот по L1, вот она У, и сторону, где будет следующий поворот по L2,
вот она В. Ну тогда понятно, что если у меня исходная прямая была какая-то вот такая вертикальная,
то раньше происходит поворот по У. Ну то есть если я отложу У в эту точку, у меня кратчайший
поворот от У до В будет почасовой, то есть отрицательный. Да, ну вот как раз кросс отрицательный,
получается, что L1 переключается раньше, чем L2. А если гугл наоборот, смотрите, если бы у меня У был бы
какой-нибудь таким, а В был бы каким-нибудь таким, сейчас его еще более крутым нарисуем, вот таким.
Ну вот так. В. Тогда понятно, что когда мы вот так вот вращаем относительно вот этих опорных точек,
то первое переключение произведет на L2. Первое переключение произведет на L2. Это как раз значит,
что если мы отложим У и В от одной точки, то кратчайший поворот от У к В будет против часовой,
то есть кросс должен быть положительным. Кросс должен быть больше нуля. Вращение в положительном
направлении против часовой стрелки. Вот значит, тогда L2 переключится раньше. Ну и все. Собственно,
тогда алгоритм и код будет очень простым. Мы просто значит запоминаем как бы текущий указатель,
где мы стоим вот здесь вот, в какой вершинке мы стоим левой прямой и в какой вершинке мы стоим
в правой прямой. Точка Ж. Дальше измеряем вот эти два вектора У и В, как там скажем П и плюс первое
минус П и Т, вот этот вектор, и П же плюс первое минус П и Т. Дальше смотрим на знак вот этого
векторного произведения, и по этому знаку мы понимаем, какая из сторон переключится первой,
то есть какая из прямых L1 и L2 переключится первой. Ну тогда если например вот это вот верно,
тогда мне нужно сначала сделать И равно И плюс 1, то есть перейти вот по этой этой
стороне и увеличить И на единичку. Ну и не забыть обновить ответ расстоянием между ИТ и точкой и Житой,
то есть у меня получается новый кандидат на диаметр выдают, вот мне нужно им обновить ответ.
Если же наоборот этот кросс был скажем ну больше равен нуля, тогда мне нужно сначала увеличить G,
вот здесь вот перейти G равно G плюс 1, и не забыть померить расстояние от G плюс первой точки до Итой,
то есть вот этот вот отрезок взять в рассмотрение, и это будет кандидат на диаметре.
Ну вот кажется и всё. То есть мы просто так проходим, понимаем какая сторона будет следующей
для переключения с помощью векторного произведения, переключаемся и меряем текущий диаметр,
как бы текущую вот длину вот этой вот полоски, ширину этой полоски, и соответственно максимальная
длина полоски, внутри которой расположен наш многогольник S, это и будет наш диаметр.
Вот такой алгоритм, то есть если мы построили выпуклую оболочку, то всё что нам осталось
сделать здесь, это занимать линейное время. Все вот эти вот повороты, это на самом деле просто
проход L1 целиком по многогольнику, и L2 целиком по многогольнику, ну это линейное время,
все эти сравнения, то есть определение того, кто переключается раньше, делается за вот единицы,
потому что просто знак векторного произведения, ну и соответственно время работала. Вот если cross
равно нулю, давайте что-нибудь порисуем, давайте порисуем, например какой-нибудь вот такой случай,
так вот так вот так вот так вот так.
Так, значит, мы, видимо, здесь какую-то пару точек не рассмотрим, правильно ли я понимаю, если мы так будем делать, что мы какую-то пару точек не рассмотрим.
Мы знаем вот это, потом переключаем, скажем, сначала вот эту, и мы измерим вот это, потом переключаем вот эту, и измерим вот это.
Так, сейчас одну секунду, давайте поймем, есть ли здесь какая-то проблема. То есть у меня есть, по сути, что...
Нет, просто трапеция какая-то.
Вот, ну и по нашему алгоритму, да, вот у меня было здесь исходно и здесь g, потом мы сначала переходим в g плюс 1 и, соответственно, меряем, то есть у нас было вот это расстояние,
а затем измеряем вот это расстояние, и потом переходим из i в i плюс 1 и меряем вот это расстояние.
Вот, но главное, что мы вроде обе диагональки померили, мы измерили обе диагонали и, в частности, в качестве ответа мы взяли, ну то есть, максимум из двух длиннодиагоналей.
Ну и вроде бы верно, что в трапеции максимальная из длиннодиагоналей, она больше равна, чем длина любой стороны, ну длина в смысле вот этой вот наклонной стороны.
То есть вот если я так нарисую трапецию какую-нибудь, то что мы поняли, что вот просто наш алгоритм, тот, который был выше, то есть мы не паримся о точном значении,
что если cross равно 0, то ну давайте там сначала переключать l2, то есть увеличивать g на единичку.
Вот, тогда что? Тогда мы поняли, что мы обязательно рассмотрим обе диагонали, обязательно рассмотрим обе диагонали, да, и, возможно, не рассмотрим какой-то из двух сторон вот этих вот наклонных сторон,
какой-то возможно не рассмотрим. Так, почему тогда мы все равно найдем диаметр? Вопрос к вам, можно ли это как-то просто здесь увидеть?
То есть почему максимальная из вот этих отрезков это обязательно диагональ?
Ну, может быть, что-то есть, что-то есть, что-то есть, что-то есть, что-то есть, что-то есть, что-то есть, что-то есть, что-то есть, что-то есть, что-то есть, что-то есть, что-то есть, что-то есть, что-то есть.
Ну, может быть, что-то есть, что-то есть, что-то есть, что-то есть.
Ну, может быть, что Hartwell иfree с этим диаметром не//может быть более, чем в диагонали?
Сейчас... А еще раз здесь, есть рапет, рапет, который мы д mauvиз во внизу, там вполне может быть нижняя сторона диаметром, ну, если сделать...
Дижняя сторона может быть диаметром. Да, но, смотрите, это будет соответствовать другому положению, то есть это мы рассмотрим когда-то позже,
это мы рассмотрим когда-то позже, когда у меня, грубо говоря, как-то вот так вот будет
наша прямая проходить, то есть вот так вот и вот так. То есть мы тогда даже... Сейчас, секунду, нарисуем на нашем примере.
Здесь у меня были вот такие вот две L1 и L2. Ну а чтобы найти вот это, у меня будет... То есть я просто
продолжу вращать, и я найду вот эту вот штуку. Вот эти вот там две пары L1 и L2, которые нам это увидят.
Сейчас единственная проблема доказать, что хотя бы одна из диагоналей, она больше равна, чем вот
эти вот остальные наклонные стороны. Так, рассуждение про выпуклый ногогонник я и не особо понял.
Сейчас, только геометрия... Может потеряем костюмусов? Нет, вообще хочется сказать, что если
предположим у нас диагональ меньше, чем сторона, если нарисовать такую трапезу, то будет видно, что она не выпуклая.
Диагональ меньше, чем сторона, да? Сейчас.
Например, вот здесь, если у меня есть... Просто одну из наклонных сторон рисуем больше. Так,
вот давайте, на этом рисунке у меня есть вот эта вот красная диагональ, вот эта наклона сторона,
которая больше, чем диагональ. И вот есть еще какая-то другая.
Тогда обязательно вот эта вот диагональ будет больше, чем та.
Ладно, тогда, наверное, те же задания. Хорошо, давайте попробую я тогда нарисовать, что я хочу.
Значит, смотрите, утверждение, что пусть ABCD это трапеция, трапеция с основаниями ABCD,
тогда... Значит, кто у меня диагональ? Диагональ это AC и BD. Тогда максимум из AC и BD больше
либо равен максимума между наклонными сторонами. Так, сейчас мне нужна опять картинка.
BCD, наклонная сторона, это будет BC и AD. Вот так. Ну, давайте попробуем так доказать. Пусть не так.
Пусть не так. Соответственно, пусть, давайте не умоляемся, что BC это максимально из сторон,
максимум из BC и AD. И эта штука строго больше, чем AC и больше, чем BD. Хорошо, ну как это может быть?
Вот смотрите, есть две параллельные стороны у меня, параллельные основания, параллельные прямые,
на которых лежат основания. И есть какой-то отрезок BC, какой-то отрезок BC, который выступает
стороной. Давайте я чуть более наклонно нарисую. То есть мы можем так повернуть нашу трапецию,
что ее основания будут параллельные оси OX, то есть горизонтальными, и соответственно лежат
на двух таких прямых. Дальше, значит, если я нарисую BC, то получается, что у меня вся трапеция лежит
вот здесь слева, лежит левее этого отрезка BC. Теперь, если я опущу здесь перпендикуляр,
то что это значит? Это значит, что вот, что значит вот это условие, что BC больше, чем BD? Это значит,
что точка D, она лежит ближе к перпендикуляру, чем C. То есть она либо лежит где-то вот здесь вот,
либо лежит, вот если я отражу С относительно основания перпендикуляра, С штрих возьму,
либо же где-то вот здесь. Так, давайте рассмотрим случай, когда D лежит вот здесь, на этом отрезке,
от С до основания перпендикуляра, скажем, H. Что тогда? Тогда мне нужно еще обеспечить,
чтобы BC было больше, чем AC. А, сейчас, или даже нам не нужно было насмотреть,
сейчас, ну секунду. Да, нам не нужно было смотреть на D. Смотрите, можно про D было забить. Главное,
что D лежит где-то вот здесь слева. D лежит где-то слева от С. Ну хорошо, а теперь у меня есть еще
неравенство, что BC больше, чем AC. Но когда такое может быть? Опять-таки, вот если я опущу из C
перпендикулярно противоположную прямую, то у меня, раз BC больше, чем AC, то у меня точка A должна
лежать ближе к вот этому основанию, чем B. То есть A должна лежать, ну там, где-то вот здесь,
или где-то вот здесь. Но мы договорились, что правее точки B нет ни одной прямой на этом
луче. Поэтому такого быть не может, и обязательно AC, оно обязательно больше, чем BC. Ну вот кажется,
все. В итоге мораль такая, что действительно от стропеции нам, то есть стропеция, это вот такой
случай, когда у меня L1 и L2 параллельны, вот такие вот они, L1 и L2. И мы как бы, ну с формальной
точки зрения должны перебрать все пары. Значит, AC, BC, BD и AD. То есть все вот эти вот четыре пара
нужно перебрать. Но на самом деле это делать не обязательно. Мы доказали, что достаточно перебирать
только диагонали. Ну а их наш алгоритм найдет. Потому что, значит, если у меня было вот здесь
и, вот здесь g, то я там кого-то из них увеличу. Сначала скажем g плюс 1, получу одну диагональ.
Потом здесь будет и плюс 1. Сейчас, секунду. Сейчас, сейчас. Давайте я скажу, что вот это L1 и L2.
Ну, собственно, я уже рисовал, что я обязательно убедить диагонали. Проверим. И g. Значит, сначала
я возьму. То есть у меня уже изначально была вот эта и g диагональка. Потом будет g плюс 1,
потом будет и плюс 1. Вот эта вторая диагональка тоже измерится. Ну все, получается обе диагонали
у меня обязательно будут учтены. И, собственно, мы сделали все, что хотели. Вот, ура. То есть,
на самом деле, можно со случаем cross равно 0 не париться и обрабатывать его точно так же,
как мы обрабатываем, скажем, cross больше 0. Просто переключать g или просто переключать i.
Так же, как cross меньше 0. Вот, ну все. Это был алгоритм Zeyn-Logan нахождения диаметра множества на
двух самых далеких точек множества. Хорошо. Значит, теперь второй алгоритм. Это Сумма Минковского.
Сумма Минковского. Сумма Минковского. Значит, пусть m1, m2, какие-то два многогольника,
ну, со внутренностями, со внутренностями. То есть, многогольник, это не только его там
вершины и стороны, но и все, что лежит внутри. То есть, как на многогольнике с мясом. Тогда
определение. Значит, сумма Минковского называется вот такое множество. Это просто сумма попарных
точек. Ну, попарная сумма всех возможных точек из m1, m2. То есть, это сумма a плюс b по всем таким
a из m1 и b из m2. Вот, что такое сумма Минковского. То есть, вот есть у вас на плоскости два
многогольника. Там, не знаю, квадрат и треугольник. Вы хотите их сложить. Да,
разумеется, они идут у нас с мясом. То есть, со всем, что внутри. Тогда вы просто перебираете
точку a внутри этого квадрата, точку b внутри этого треугольника и их поогернатно складываете. То
есть, если это было там, скажем, x1 и y1, x2 и y2, то вы в результате в сумме пишете, что есть точка
x1 плюс x2 и x1 плюс x2. Вот, ну и результат там, не знаю, будет какой-то многогольник. Пока давайте
не будем задаваться вопросом, как он именно выглядит. Ну, там что-то, что-то вот типа такого,
мне кажется, будет. Это будет результат m1 плюс m2. Так, ну вот, определение. Дальше утверждение,
что если m1 и m2 это многоугольники, то их сумма это тоже, давайте выпуклые многоугольники считать,
выпуклые многоугольники, то их сумма тоже выпуклые многоугольники.
Значит, сумма выпуклых многоугольников, во-первых, выпуклая, во-вторых, многоугольник.
Показательства. Давайте сначала докажем выпуклость. Чего выпукла здесь довольно
простая. Смотрите, вот пусть у меня что-то такое вообще в выпуклости. На всякий случай напомню,
что если у нас есть какие-то две точки p и q, лежащие в фигуре, в какой-то m,
тогда весь отрезок между ними тоже должен лежать в фигуре m. Вот это выпуклость. Требование выпуклости,
что отрезок между любыми двумя точками фигуры целиком лежит внутри этой фигуры. Хорошо,
ну вот пусть есть какие-то две точки внутри нашей суммы. То есть есть, скажем, p и q,
лежащие в m1 плюс m2, но раз они там лежат, тогда они получаются в виде суммы, скажем,
p1 плюс p2 и q1 плюс q2, где p1 лежит в m1, q1 лежит в m1, а p2 лежит в m2. И то же самое с q2.
Ну раз каждая точка лежит в сумме, то значит она распадается в сумму каких-то двух точек из
m1 и m2. Вот здесь это p1 плюс p2, здесь это q1 плюс q2. Ну тогда смотрите, что мы знаем. Мы знаем,
что отрезок p1 q1 целиком лежит в фигуре m1, поскольку по предположению это выпукло на угольник.
И то же самое с фигурой с отрезком p2 q2. Этот отрезок целиком лежит в m2, потому что m2
это выпукло на угольник. Были две точки, лежащие на угольнике, тогда целиком отрезок между ними
тоже там лежит. Картинка. Было p1 q1, отрезок в m1, и было какой-то там p2 q2, отрезок в m2.
Что мы хотим? Мы хотим сказать, что отрезок между вот этими вот точками лежит в сумме.
Ну интуиция здесь очень простая. Давайте мы просто, значит, ведем, ну нормируем эти отрезки одной
и той же длиной. Ладно, плохо сказал. Давайте мы просто эти отрезки будем проходить с одинаковой
скоростью. Нет, продам, не с одинаковой скоростью. Будем проходить эти отрезки так, что в момент
времени 0 мы стоим в p1 и в p2, а в момент времени 1 мы будем находиться в q1 и q2. То есть проходим
их с линейными скоростями, они будут разные у нас на самом, ну в общем случае будут разные, но так,
что в общем в нулевом момент времени мы здесь находимся в p1, а здесь в q1 в первом момент времени,
здесь в нуле p2, в 1 q2. То есть это что такое? Это просто p1 плюс t умножить на q1 минус p1. То есть
мы рассмотрим вот такое движение по этому отрезку, которое в момент времени t имеет вот такую координату.
Т от 0 до 1. То же самое здесь. Мы рассмотрим движение p2 плюс t на q2 минус p2. Дальше мы сложим
две эти точки и давайте посмотрим, что получится. Получится p1 плюс p2 плюс t на q1 плюс q2 минус p1 плюс
p2. Это вот когда мы взяли точку здесь в момент времени t и точку здесь в момент времени t, их
сложили, получили вот такой результат. Ну а это в точности какая-то точка на отрезке между p и q.
Вот было у меня p и q, лежащие в сумме. Соответственно p это p1 плюс p2. q это q1 плюс q2. Ну и тогда любая
точка на этом отрезке тоже задается вот таким вот образом. Это start плюс некая t на разность
конец минус начала q минус p. Ну все соответственно любая точка здесь, она получается, то есть если мы
на этом отрезке ведем ту же самую скорость прохода, так что здесь в нуле, а здесь в единице мы
находимся, то тогда любая точка в момент времени t получается как сумма вот этих двух точек в момент
времени t. Поэтому действительно любая точка на отрезке q является суммой некоторых двух точек
в первом многугольнике и во втором. Ну вот просто тут какой-то там линейный отрезок как-то прошли
с линейной скоростью, с постоянной, так чтобы сумма была вот ровно такая как нужно. Это у нас
получилось выпуклость. А теперь второе. Почему это многоугольник? Мы докажем более сильное
мы докажем, что m1 плюс m2 равно выпуклой оболочки множество точек p плюс q, где p это вершина
m1, а q это вершина m2. То есть чтобы найти сумму нам достаточно попарно сложить все вершины,
то есть вот давайте вернемся к примеру с квадратом и треугольником. Нам достаточно сложить
каждую вершину квадрата с каждой вершиной треугольника, ну там будет не знаю сколько,
12 вершин, и построить на этом выпуклую оболочку. И это и будет наша сумма, вот что я утверждаю.
Ну почему это верно? Вложение в аду все равно очевидно. Понятно, что m1 плюс m2 будет целиком
содержать вот этот вот конф, потому что любая такая точка p плюс q, она конечно лежит в сумме,
потому что это по определению сумма точки из m1 и точки из m2, значит вот эта любая точка лежит
в m1 плюс m2, ну а раз у меня несколько точек в m1 плюс m2, то поскольку m1 плюс m2 выпукло,
то и выпуклая оболочка тоже их лежит. То есть вот здесь стоят какие-то точки лежащие в сумме в m1
плюс m2, а дальше я на них натягиваю выпуклую оболочку. Но раз у меня вот это множество,
как можно доказать выпукло, то соответственно и выпуклая оболочка каких-то точек из этого множества
там тоже лежит, про само множество выпукл. Поэтому вложение в эту сторону мы по сути уже доказали,
когда доказали выпуклость m1 плюс m2. Теперь вложение обратно. Почему m1 плюс m2 вложена
в выпуклую оболочку вот этих точек? Ну для этого мы рассмотрим произбольную точку вот отсюда.
Рассмотрим точку. Так у меня заканчивается буква. Давайте x плюс y лежащую в m1 плюс m2,
то есть x из m1, y из m2. А дальше давайте поступим следующим образом. Давайте мы эти точки x и y
найдем в наших многоугольниках m1, m2 и нарисуем какой-нибудь треугольник, в котором в которых они
лежат. То есть вот был у меня там какой-то m1, в нем была точка x и был какой-то m2, в котором лежал y.
Тогда я утверждаю, что можно обязательно рисовать треугольник с вершинами в вершинах многоугольника,
чтобы в нем лежала наша точка x, или вот здесь в этом случае, например, можно рисовать так y.
Вот это очевидное утверждение, потому что по сути достаточно просто построить
реангуляцию угольных многоугольников. Это в общем-то разбиение всего многоугольника на какие-то
треугольники. Ну и тогда любая точка многоугольника хоть в одном треугольнике долежит, возможно,
на границе, а главное внутри кого-то треугольника. Это просто немедленно следствие из того,
что существует реангуляция, а с треангуляциями мы уже умеем работать. Итак, давайте мы как-то
найдем положение x, что он лежит в каком-то треугольнике. Вот здесь давайте красный выделим.
И y, он тоже лежит в каком-то треугольнике с вершинами в вершинах m2. Давайте подпишем,
что такие треугольники существуют так как существует реангуляция. Вот, ну хорошо, тогда
едем дальше. Давайте вот мы сузим наши m1, m2 до вот этих треугольников. То есть есть какой-то
треугольник, лежащий в m1, в котором лежит еще x, и есть какой-то треугольник, лежащий в m2, в котором
лежит y. Следующий шаг, это давайте мы выразим x и y через вершины этих многоугольников. Вот
есть этих треугольников, извините. Значит, если треугольник с вершинами a1, a2, a3, то в общем-то
легко понять, что x это какая-то выплыклая комбинация точек a1, a2, a3. Сейчас я напишу и скажу,
что это значит. Где лямбда 1, лямбда 2, лямбда 3 больше нуля, и их сумма эта единица.
То есть смотрите, есть у вас треугольник a1, a2, a3, есть точка внутри него, ну внутри или на границе.
Тогда, ну почти очевидно, что можно x представить в виде вот такой вот линейной комбинации вершин
треугольника, где коэффициенты не отрицательные, а их сумма равна единице. Вот, ну мы не будем это
доказывать, можно считать это очевидным. Вот, можно сказать, что чтобы доказать, можно, например,
сделать так. Давайте проведем отрезок, как это называется, чвяну из a3 и через x, да, то есть она
где-то пересчет отрезок, ну, в сторону a1, a2. И поставим сюда такие веса, лямбда 1, лямбда 2, то есть
поставим сюда такие гирки, что центр масс a1, a2 будет лежать в этой точке. Центр масс a1 и a2
будет лежать в этой точке. Ну и дальше нужно будет сюда поставить какую-то гирку лямбда 3, чтобы x
был как раз центром масса вот этих двух точек, a3 и того, что здесь вот лямбда 1, лямбда 2, a2. Вот тогда,
если здесь поставить нужный вес, то x будет в этой точке. То есть таким образом можно обязательно
всегда подобрать какие-то коэффициенты, чтобы x было вот такой комбинацией, ну, выпухлой комбинацией,
точек 1, 2, 3. То же самое с y. y, если это вершины b1, b2, b3, то y это какой-то там, скажем, мю1, b1,
плюс мю2, b2, плюс мю3, b3, где все мюшки не отрицательные, а сумма их равна единице.
Вот, ну хорошо, хорошо. Так, что я хочу сделать дальше? Что я хочу сделать дальше?
Момент.
Я хочу сказать, что точка x плюс y, давайте напишем x плюс y,
это лямбда 1, a1, то есть лямбда 2, a2, плюс лямбда 3, a3, плюс мю1, b1, плюс мю2, b2, плюс мю3, b3,
что она лежит в выпуклой оболочке, она лежит в выпуклой оболочке, множество точек, ну там a1
плюс b1, a1 плюс b2, a1 плюс b3 и так далее, в общем, все пары мы перебираем, в итоге будет 9 точек,
вот, и в выпуклой оболочке такое множество должна лежать на точке x плюс y. Сейчас скажу почему-то так.
Больше конду.
да все я понял значит надо просто взять это с коэффициентом лямбда 1 мю 1 лямбда 1 мю 2 лямбда
1 мю 3 и так далее и вроде вроде все получится как раз коэффициент при а1 будет лямбда 1 да ну все
все получится значит так смотрите мы поняли что цикли выражается такой вот линией комбинации
наших точек и чтобы доказать утверждение мне нужно показать что это точка лежит в выпуклой оболочке
множество сумм всех пар вершин из из м1 и из м2 для этого достаточно показать что он лежит в
выпуклой оболочке вот таких вот девяти точек когда мы складываем только вершины этих двух
треугольников вот ну а это уже сделать легко смотрите давайте мы вот каждую такую точку возьмем
с коэффициентом ну там лямбда и т б это естественно есть аи плюс бж то давайте возьмем такую точку с
коэффициентом лямбда и мюжи и все это просуммируем по всем точкам ижи тогда смотрите что получится у
меня если я просуммирую отдельно по аитам какой коэффициент будет при аитам я соответственно
могу варьировать g и у меня при аитам будет коэффициент с точностью лямбда это на сумму мюшек
а сумма мюшек это единица поэтому у меня вот эта штука будет просто с коэффициентом лямбда и т
то же самое у меня будет с бшками у меня будет сумма по ж и бж и вот здесь если я варьирую ишку
то у меня будет мюжи и т умножить на сумму лямбда и т их где сумма лямбда и лямбда и т это единица
поэтому здесь будет просто бж и т и таким образом мы получили в общем-то выпуклое представление
точки x плюс y через вот эти вот 9 точек по которым мы строим выпукло оболочку вот ну и понятно что
сумма всех этих коэффициентов то есть вот эти коэффициенты я беру в качестве вот этой вот коэффициент
в линиейной комбинации понятно что не все они отрицательны и их сумма равна единице сумма этих
коэффициентов единица потому что ну там если вы если у вас есть два набора вот таких вот да сумма
единица и вы их попарно по точечно перемножайте попарно перемножайте тогда сумма опять будет
единица ровно из этих же соображений которые мы вот здесь а что сумма бюджета единица потом
сумма лямбда и т это единица вот ну и все мы получили в общем-то представление x плюс y как
выпуклого комбинацию вот этих вот 9 точек ну а значит належит конечно выпукло оболочки то есть
если у меня есть несколько точек и вот да то есть вот эти вот суммы вершин а1 плюс б1 и так далее
а3 плюс б3 и какая-то точка выражается их выпуклой комбинации то есть суммой с не отрицательными
коэффициентами сумма единицы тогда конечно выпукла вот эта точка любит выпукло обложить их
точек вот но тоже собственно давайте мы собственно сформулируем утверждение которое нам здесь нужно
давайте без доказательства оставим точка x лежит в выпукло оболочки множество п1 п2 и так далее
если только если существует не отрицательные лямбды сумма единицы
сумма единицы такие что x это вот это вот линейная комбинация наших точек лямбда 1 п1 плюс так далее
лямбда и вот это что называется выпукла комбинация комбинации
ну и все кажется мы то есть помолли это утверждение мы все доказали то есть мы
взяли точку лежащую в м1 и 2 рассмотрели в каких треугольниках лежат ее компоненты
вымоги на м2 сложили два треугольника получили какой-то ну там какие-то точки взяли на них
в обложке показали что наша точка исходная лежит обязательно в этом сумме этих двух треугольников
то есть выпукла оболочки попарных сумм вершин этого этих двух треугольников вот так
ну помолли это это утверждение но оно там на самом деле простой может его сами показать
мы не будем женатым останавливаться здесь здесь все просто вот если мы показали вложимость в обе
стороны показали что сумма м1 и 2 вложена и содержит выпукла оболочку множество там всех
по плюску где п и кое-что вершин это вершина м1 кое-что вершина м2 все значит на самом деле просто
сумма минковского это выпукла оболочка всех пар сумм сейчас как сказать выпукла оболочка сумм
всех пар вершин вот так выпукла оболочка сумм всех пар вершин вот хорошо это мы поняли ну и
соответственно отсюда следует что это многоугольник потому что здесь какое-то
конечное количество точек и выпукла оболочка конечно множество точек это всегда на гугольник
вывод м1 2 это выпукла на гугольник выпуклы на гугольник хорошо тогда давайте построим
алгоритм который находит м1 и 2 алгоритм нахождения суммы минковского
а так
алгоритм такой давайте как мы это любим найдем крайние левые нижние точки обоих наших
многугольников м1 м2 значит то есть возьмем самой левой точки если их несколько то есть
если скажем вот такая вертикальная сторона самой левой то возьмем среди них самый нижний
выберем левой нижней точки то есть сначала самые левые потом самые нижние если таких несколько
точки м1 м2 пусть это какие-то точки с1 с2 тогда легко понять что с1 плюс с2 это будет обязательно
вершина нашего результата это обязательно вершина м1 плюс м2 вот ну грубо говоря потому
что левее этой точки точно быть никого не может да потому что если есть что-то левее то абсциссо
одно одного из слагаемых обязательно даже быть меньше чем абсциссо соответствующего там с1 или
с2 а такого не бывает нет ни одной точки левее с1 нет ни одной точки левее с2 поэтому когда вы
складываете две точки из м1 м2 то сумма их абсцисс будет хотя бы такая же как у с1
с2 но и тоже самое нет ни одной точки внизу потому что при фиксированной сумме абсцисс у вас нет ни
одной точки здесь и нет ни одной точки здесь потому что мы взяли самый левый самый левый нижний
вот получается что что мы получили что относительно с1 плюс с2 нет ни одной точки внизу и нет ни одной
точки левее вот тогда понятно что понятно что это вершина оболочки потому что можно
просто провести вот такую вот прямую вот вот такую полуплоскость которая отсекает все что
находится левее ну соответственно тогда с1 плюс с2 это какая-то точка на полуплоскости которая
ограничивает наш многогульник с левой значит ассоединится в этой вершине а дальше будем делать
следующее дальше будем делать что-то очень похоже на вот то что мы делали с нахождением диаметра
смотрите мы нашли с 1 с 2 дальше утверждается работает следующий алгоритм давайте мы просто
рассмотрим векторы соответствующие всем вот этим вот сторонам в порядке против всего стрелки то есть
мы нарисуем эти векторы нарисуем эти векторы а дальше будем делать следующее из стартовой точки
с1 плюс с2 будем смотреть значит выбираем из этих двух векторов из двух первых векторов самый крутой
то есть тот который смотрит на его ли вниз но это понятно будет вот этот данный и тогда рисуем его
из стартовой точки все его прошли переключились на следующий теперь опять сравнил вот этих два
вектора первый вектор здесь и второй вектор здесь смотрим какой в них более крутой то есть кто из
них смотрит больше вниз и конечно merde вот этот его и рисуем вот здесь и переключаем его на следующие
теперь опять из 2 вектора мы сравниваем понимаем кто более крутой我们 по beb padding борщев низ
вот таким горизонтальным. Переключаем. Затем будет вот этот вектор. Затем будет вот этот вектор.
Потом потом вертикальный. Вертикальный отрезок. Ну и здесь там что-то остаётся. Давайте я там
дорисую как получится. Вот так, вот так, вот так. То есть я просто иду в порядке, в точно таком же
порядке обхода против всего стрелки обольтного угольника и записываю в качестве новой стороны
ту из сторон, которая наиболее крутая. То есть то, что векторное произведение от нее до следующей
положительно. То есть я взял по сути два вектора. Вот это вот у и в. И что значит, что у на одном
сете раньше, чем в? Это значит, что у кросс в положительно. То есть вращение от у к в против
всего стрелки. То есть если кросс у в, если кросс двух сторон больше нуля, то у нужно расположить раньше в.
Нужно расположить раньше. Вот такое говорим. То есть просто проходим по сути у нас есть два
указателя. Указатель на сторону первого ногового угольника, указатель на сторону второго. Смотрим
знак векторного произведения между ними. И если он положительный, тогда выписываем в сторону первого
ногового угольника. Иначе второго. Ну и сдвигаем указатель в том ногового угольника, который мы
прошли в сторону, в котором мы прошли в сторону. Вот легко понять, что мы, конечно же, обязательно
замкнемся. То есть обязательно придем в ту же точку, где начали. Ну просто потому что, скажем,
сумма вот этих векторов это ноль, потому что мы прошли какой-то круг и вернулись туда не начать.
Сумма векторов, сумма сторон первого ногового угольника это ноль. Тоже самое сумма сторон
второго ногового угольника это ноль. Ну а здесь мы в каком-то порядке просто прочередовали стороны
первого ногового угольника. Понятно, что их сумма от этого не поменялась. Поэтому стартовая точка будет
равна конечному. Мы обязательно вернемся в ту же точку, откуда начали, получим какой-то
ногового угольника. Ну и понятно, что он выпухлый, потому что у меня как раз стороны будут упорядчены в
порядке убывания крутизны. То есть сначала самая крутая больше всего вниз, потом чуть более пологая,
чуть более пологая, потом вообще оно выворачивается в ту сторону и так далее и так далее. То есть понятно,
что это будет выпухлый ногового угольник. Потому что просто его стороны, как раз мы записываем
стороны в таком порядке, чтобы кросс всегда был положительным. То есть между двумя последовательными
сторонами вот это вот скажем и вот это. Кросс обязательно будет положительным. Тогда это просто выпухлый
ногового угольник. Вот это будет выпухлый ногового угольник. Так, ну и осталось понять, что это действительно
будет сумма Минковского. Что это будет действительно сумма Минковского и наш алгоритм не обманывает.
Он не строит какую-то фигню, а на самом деле строит настоящую сумму Минковского. Ну здесь можно, например,
рассуждать так. Давайте мы построим настоящую сумму Минковского. Давайте ее синий нарисуем. Как она
выглядит? Мы уже поняли, что вот эта вот точка с1 плюс с2 это обязательно вершина суммы Минковского.
Ну и соответственно нет никого левее, нет никого ниже. Хорошо, давайте начнем строить наш
многоугольник. Ну и пусть он скажем, то есть будем рисовать его стороны в порядке против часовой
стрелки и пусть несколько, скажем, первых сторон совпадет. То есть скажем вот это вот равно вот
этому. Да, то есть у нас начало одинаковое. Начало вот такое одинаковое. А дальше смотри, что может
быть? Какая может быть следующая сторона? Понятно, что она не может идти левее, чем вот этот вот красный
вектор. Потому что, ну, понятное дело, мы построили какой-то многоугольник, и он, ну, почти очевидно,
вложен в М1 плюс М2. Потому что, по сути, значит, что мы делали, когда строили вот этот вот красный
многоугольник, когда мы обходили контуры наших многоугольников, мы, по сути, фиксировали какую-то
вершину одного многоугольника и прикладывали к ней вектор равной стороне второго многоугольника. То
есть мы стоим в какой-то точке, да, и прикладываем, скажем, вот здесь, прикладываем вот этот вектор.
Ну вот, собственно, мы его здесь нарисовали. Поэтому то, что мы рисуем красными стрелочками, это точно
лежит в сумме Минковского. Да, красный многоугольник, который мы построили, который мы, собственно,
проверяем на то, что он является суммой Минковского в точности, он точно в нее вложен. То есть все,
что мы нарисовали, это точно какое-то подношение суммы Минковского. Вот. Ну и тогда, соответственно,
если у меня есть какое-то расхождение суммы Минковского, то не может быть такого, что, ну,
отрезок следующая сторона ведет вот куда-то сюда в обнутренность, ну или там туда. Потому что просто,
ну, вот это же лежит в сумме Минковского. Тогда мне нужно эту сторону точно содержать. Ну а если я
пойду сюда, то я ее никак не буду содержать. Да, поэтому если отличие есть, то оно обязательно,
как бы, ну, правее, что ли, чем, ну, правее в смысле вот этот кросс будет, вот такой угол поворота будет
положительный, на кросс будет положительный, правее, чем наша сторона, которую мы построили
нашим алгоритмом. Вот давайте поймем, что такого быть не может. А для этого, наверное, мне нужно
будет новый слайд, и я немножко перерисую картинку. Значит, что было? Мы как-то там строили
куклу суммы Минковского, нарисовали что-то такое, а в решении сумма вот такая. Вот так,
а следующая сторона какая-нибудь вот такая, да, то есть более, более крутая, чем наши отрезы,
которые мы нашли. Вот, ну хорошо. Как такое может быть? Давайте поймем, вот, давайте посмотрим на эту
точку. Мы понимаем, что опять вершина нашего выпуклого многогольника, вершина М1 плюс М2.
Вершина М1 плюс М2. Ну, раз эта вершина М1 плюс М2, то это какая-то вершина выпуклого
оболочки, да, то есть мы понимаем, что М1 плюс М2 — это выпуклая оболочка множества сумм каких-то
пар, пар вершины наших двух многогольников. Значит, эта вершина просто там какой-то П1, ну,
П плюс Куб, да, где П — это вершина М1, Куб — это вершина М2. Потому что, повторюсь, да, мы стоим в
какой-то вершине суммы Минковского, но мы знаем с вами, что сумма Минковского — это выпуклая оболочка
сумм пар всех вершин М1 и М2. Поэтому раз это вершина, то это обязательно, ну, она в свою очередь
является какой-то суммой. Вершина из первой, вершина из второй. Вот это П плюс Куб. Хорошо, давайте
нарисуем П и Куб в наших двух многогольниках М1 и М2. Так, сейчас немножко перенесу.
Вот сюда куда-нибудь. И нарисую, как выглядит П и Куб. Значит, П где-то здесь, Куб где-то здесь,
и у них там какие-то вот такие стороны есть. Как мы построили вот этот красный вектор? Что это за
красный вектор? Это как бы наиболее крутая сторона из вот этих двух, из вот этой и вот этой. Давайте
я нарисую вот эту вот штучку другому как-нибудь вот так. Ну и тогда понятно, что вот этот просто
отрезок красный взялся вот отсюда. То есть это когда мы стоим в пояку, мы сравним две стороны,
вот эту вот и вот эту. Смотрим какая из них более крутая, то есть от которой до другой кросс
положительный. Ну, соответственно, это оказывается вот этот отрезок. То есть мы его вот сюда и нарисовали.
Тогда вопрос, как мы могли получить вот этот синий отрезок? Откуда он мог взяться? Почему он может
лежать в сумме Минковского? Неформально нам нужно как бы взять еще более крутое что-то, либо вот здесь,
либо вот здесь. Но такого понятно быть не может. То есть мы и так находимся вот в каком-то том углу,
значит мы не можем взять что-то более крутое, чем соответственно наиболее крутая из этих двух сторон.
Значит это неформально. Чуть более формально давайте рассмотрим, как может получаться вот этот
синий вектор. Ну, не знаю, давайте возьмем вот эту вершинку, вот эту вторую вершинку. Это обязательно
какая-то сумма двух точек. Так, можно пить опять буквы. Давайте R1 плюс R2. То есть это какая-то
точка в первом многугольнике, какая-то точка во втором многугольнике. Какая-то сумма, вот этот
конец и него. R1 плюс R2. То есть, смотрите, мы взяли, сложили две вектора, из P в R1 и из Q в R2,
и получили синий вектор из P плюс Q в R1 плюс R2. Значит, сумма векторов P R1 и Q R2. Это вот этот наш
синий вектор с началом в PQ и концом в R1 плюс R2. Вот, ну тогда надо понять, что этот вектор, он не может
быть круче, чем, ну, наиболее крутой из этих двух сторон. Да, то есть, не более крутой, чем вот этот
красный вектор. Чем вот этот красный вектор. Так, ну, для этого давайте мы сделаем следующее. Значит,
давайте введем здесь какие-то, давайте мне нужна какая-то буква здесь еще будет. Давайте, это будет
точка A, это точка B. Тогда это будет точка A плюс Q. Да, потому что мы написали эту сторону, то есть, по
сути, мы взяли вот этот вот конец, конец того ибра, написали здесь A плюс Q. Ну, тогда, смотрите,
векторное произведение от P A до P R1, оно явно больше ибравно нуля. Да, потому что P A1 это какая-то
сторона. Значит, если мы рассмотрим любую другую точку внутри нашего выпукла на гугольника M1,
тогда направление поворота от P A до P R1 будет прочь всего стрелкой, то есть положитель,
но не отрицатель. То же самое здесь. Cross QB и QR2 больше или равно нуля. Ну, или даже можно
рисовать так. Если я вот здесь нарисую вот этот наш вектор, давайте я вот этот вектор обозначу за
какой-нибудь U. Вот это будет вектор U. Тогда, если его здесь нарисую тоже в этой точке, то он будет
как бы еще более крутой, чем B, поэтому вот этот векторное произведение Cross U и QR2 будет подавно
больше нуля. То есть если я заменю вот здесь вот в этом произведении QB на еще более крутой
вектор U, то есть который получается еще поворотом почасовой относительно QB, то тогда я получу
заведомо еще больше ибравное векторное произведение. Так, ну и тогда что у меня получилось? У меня
получилось, что Cross U PR1 больше нуля, Cross U QR2 больше нуля. Так, ну и тогда я хочу как-то доказать,
что Cross, то есть мы по сути что хотим доказать? Мы хотим доказать, что Cross U, да, потому что вот
этот вектор это U, а здесь мне нужен вектор как раз вот это, да, P plus Q, P plus Q PR1 plus PR2. Вот если я
докажу, что такой векторное произведение больше нуля, тогда вот эта картинка не может иметь
места, потому что раз здесь больше нуля, тогда, соответственно, наоборот, синий вектор, он
может быть только левее, чем красный, потому что угол поворота здесь должен быть положительный,
больше нуля, то есть тогда синий вектор должен быть левее. И как раз тогда получится наше
доказательство, что, ну противоречие, у нас этот вектор R1, R2 не может торчать правее, чем вектор U,
а красный, как раз у меня U. Так, ну, чего здесь нужно сделать? Ну, это, видимо, просто линейность
векторного произведения, то есть если я вот эти вот два неравенства сложу, сейчас, одну секунду, да,
значит, когда я складываю вот эти два неравенства, легко понять, что векторное произведение у нас,
эта штука линейная, значит, мы получим кросс U и, скажем, PR1 плюс QR2 больше равно нуля, ну а вот
этот вектор, это как раз представляется в виде суммы PR1 плюс QR2, поэтому, собственно, мы отсюда
сразу немедленно следует, что вот такой кросс больше равен нуля, а значит наш вектор синий,
он не может находиться правее, чем красный вектор U. Вот это формализм. Мораль очень простая.
Построенный нами многоугольник действительно является суммой Минковского R1 плюс R2, потому что,
если не так, мы рассмотрим какое-то первое различие, то есть когда мы нарисовали, когда наш алгоритм
нарисовал вектор U, а правильный вектор какой-то более правый, да, вот такой более крутой R1 плюс R2.
Ну, тогда, значит, если все аккуратно проанализировать, то мы можем понять, что вот этот угол поворота не
может быть в ту сторону, да, не может быть поворот от U к вот этому вектору по часовой
стрелке. Он обязательно может быть только против, ну, потому что U вот такой самый экстремальный,
да, и что R1, что R2 лежат как бы в порядке против часовой стрелки превращения относительно
этого вектора U. Ну, значит их сумма, ввиду там линейности вектора напряжения, тоже должна
жать левее, чем U, ну не строго левее, то есть вообще в оптимальном ответе, конечно, R1 плюс R2
будет вот ровно такой вектор, вот такой вектор, совпадает с U. Вот, ну все, значит, мы доказали,
что M1 плюс M2 это в точности сумма Минковского, и таким образом мы построили алгоритм,
который находит сумму за линейное время. Вывод, предъявленный алгоритм строит сумму Минковского
за, ну, я напишу от N плюс M, где N и M это количество вершин в наших нагугольниках M1 и M2. Ну, потому
что по сути давайте вспомним, что мы сделали. Мы нашли крайние левые нижние точки в обоих
нагугольниках, это просто линейный проход по всем точкам и нахождение вот этих halves. А дальше
мы, значит, смотрим у нас есть два указателя, один указатель на сторону первого маг hash
и второй маг hash. Смотрим, какая из них более крутая, то есть от которой до другой CROSS
положительной и выписываем ее и задвигаем указатель. То есть, по сути, мы просто один раз
прошли первый маг hash, один раз прошли второй маг hash, ну и в каком-то порядке написали их
тогда получается, конечно, что время работы линейно, время работы линейно. Вот такой
прелестный алгоритм получился. Применение. Первое применение такое, проверить,
пересекаются ли два выпуклах многоугольника. Проверить, пересекаются ли два выпуклах многоугольника.
М1, М2. Значит, решение такое, смотрите, что такое пересекаемость. Это значит, что есть точка,
скажем, P, лежащая и там, и там. P, лежащая в М1, и P, лежащая в М2. Но тогда, если я смотрю
разность Минковского М1-М2, то есть множество всех разностей А-Б, где А из М1, Б из М2,
то мне нужно просто проверить, лежит ли в этом многоугольнике точка 0. Потому что как раз P-P будет
равно 0. В итоге, пересекаемость, условия того, что они пересекаются, равносильно тому, что точка
0, 0 лежит в многоугольнике М1-М2. А чтобы посчитать разность Минковского, можно просто посчитать
сумму Минковского с отраженным многоугольником М2. Я просто, ну там, меня все координатно,
домножаю все координаты на минус 1. Получается там, по сути, отраженный относительно 0, 0 многоугольник.
Главное, что он по-прежнему выпуклый, по-прежнему можно его обойти в нужном порядке, ну и сложить
с нашим многоугольником М1 за линейное время. А потом, если у меня есть какой-то выпуклый
многоугольник, вот этот результат. Мне остается проверить, что точка 0, 0 лежит внутри нашего
выпуклого многоугольника. Ну это уже простая задача. В частности, на семинаре вы должны были
обсуждать, как проверить, что точка лежит внутри выпуклого многоугольника. Это можно делать вообще
бинпоиском. Ну короче, мы свели какой-то более простую задачу принадлежности точки к
многоугольнику, и это уже как-то решается более просто. Вот, второе применение это, ну обобщение,
на самом деле предыдущего, это расстояние между двумя, так, а я сказал, что они выпуклые? Да, сказал,
конечно. Расстояние между двумя выпуклыми многоугольниками. Ну здесь идея такая же, что такое расстояние,
это distance, там скажем, где p из m1, q из m2. Ну а distance это, на самом деле, просто модуль разности
p-q, ефидова норма, вектора p-q. Поэтому, если мы вновь построим разность Минковского, то мне
нужно в этом многоугольнике найти точку, ну по сути, с минимальным расстоянием до нуля. Или там
просто с минимальным модулем. В этом многоугольнике нужно найти точку с минимальной, я напишу так,
ефклидовой нормой. То есть, с минимальным расстоянием до нуля. Расстояние до нуля,
это в точности ефклидова норма каждой точки. Вот. Ну, а расстояние от... То есть, по сути,
мне нужно найти кратчайшее расстояние от точки для многоугольника. Есть точка 00, есть вот этот
выпуклый многоугольник, мне нужно найти расстояние между ними. Ну а расстояние между ними можно
искать, как расстояние от 00 до всех сторон многоугольника. Это расстояние равно расстоянию от 00 до
до ближайшей стороны. То есть я могу просто перебрать все стороны нашего многоугольника m1-m2,
перебрать все стороны, найти расстояние от точки 0,0 до каждой стороны, и взять из них минимум.
Ну расстояние от точки до отрезка, потому что по сути каждой страны просто отрезок. Расстояние
от точки до отрезка уже считается тривиальным, нужно опустить перпендикуляр. Если перпендикуляр
попал на отрезок, то это есть расстояние. Если не попал, тогда расстояние равно минимуму из этих
двух отрезков. То есть расстояние обязательно достигается в вершине отрезка, если перпендикуляр
не попал на сторону. То есть мы опять свели задачу к более простой, к задаче поиска расстояния
от 0,0 до всех сторон. Это уже элементарная задача, там просто какие-то уравнения решать
и найти расстояние. Вот такие применения.
Такие применения.
Хорошо.
Ну давайте, я не знаю, давайте я отскрою упражнение такое, что если мы просматриваем задачу
суммы Минковского в двух не выпуклах многоугольниках, М1 и М2 не выпуклые многоугольники,
и нам все равно хочется найти их сумму, а хочется найти М1 и М2. Тогда эту задачу можно решить так.
Можно триангулировать оба наших многоугольника, благо, триангулировать мы уже умеем за
клажитичное время от количества вершин. Ну а дальше, поскольку каждый многоугольник у меня
разбился на трикольнике, дальше могу просто по парам все триугольники сложить и построить в конце выпуклую оболочку.
А благо, триугольники тоже выпуклые фигуры складывать, соответственно, трикольники мы уже умеем.
Поэтому мы все пары трикольников сложим, трикольник из М1, трикольник из М2 сложили
и потом в конце построили выпуклую оболочку... Нет, выпуклую оболочку – это неверное,
мы сложили так все трикольники, про выпуклую извини. Это я глупо сказал, конечно.
Мы так сложились в паре треугольников, получили какие-то куски областей их результата,
но дальше их нужно просто объединить,
то есть там, конечно, могут быть какие-то невыплости,
вот главное, что нужно просто их все объединить в один большинный треугольник.
Тогда решение будет такое, давайте это запишем,
что мы триангулируем м1 и м2,
затем попарно складываем эти треугольники по Минковскому,
складываем по Минковскому эти треугольники,
ну и в конце нужно как-то объединить это все в одну фигуру,
в конце объединить в одну фигуру.
Ну и, собственно, в качестве упражнения можете понять, как их там объединить,
то есть по сути у вас на плоскости нарисовано несколько многоугольников,
каждая из которых это сумма двух треугольников, но это уже неважно,
есть несколько многоугольников, и вам нужно понять, какую область они ограничивают,
если их все объединить, какую область они ограничивают.
Вот это, на самом деле, простая задача, например, на графы,
вы просто в каждой вершине смотрите, какие отрезки из нее выходят,
смотрите там два самых экстремальных,
вот это там будут две стороны вашей границы, вашего многоугольника.
Вот и все.
Надо понять, как это делать, и плюс понять, за сколько это работает,
а симптотика, какая у этого дело,
и как вот это делать объединение в одну фигуру.
Так, хорошо.
То есть, в принципе, сумму можно делать и на невыпуклых,
на невыпуклых с помощью того, что мы уже изучили, с помощью треуголяции.
Так.
Хорошо.
Тогда третий сюжет, мы его уже полностью не успеем,
но сколько успеем, только успеем.
Это проверка принадлежности точки в многоугольнику.
Проверка принадлежности точки в многоугольнику.
Это мы уже видели сегодня, когда нам нужно было понять,
что принадлежит ли точка ноль-ноль в многоугольнике.
Значит, упражнение семинарское,
что если многоугольник выпуклый, то это можно делать за алгорифом.
Если многоугольник выпуклый,
то можно делать за алгорифом.
Значит, идея очень простая.
Давайте мы возьмем там левую нижнюю точку,
посмотрим вот такую триангуляцию нашего многоугольника,
ну и там бинпоиском определим тот,
то есть по сути у меня весь многоугольник разбился на вот такие вот углы.
Вот есть угол, вот этот первый, есть угол второй, есть угол третий.
Давайте мы бинпоиском по этим углам определим,
в каком из них, в каком секторе лежит наша точка,
просто бинпоиск за алгорифом как раз.
Ну и потом внутри, если мы знаем, что точка лежит внутри такого сектора,
то нам нужно понять, лежит ли она внутри треугольника
или она там где-то за пределами этого треугольника.
Соответственно, за алгорифом мы определяем треугольник,
в котором должна лежать наша вершина,
и потом просто за от единицы проверяем, лежит ли точка внутри треугольника.
Это уже совсем простая задача.
Значит, есть решение также и для невыпуклого тоже через триангуляцию.
Даже это не упражняет замечание.
Я и так все сказал.
Замечание.
А если нагугольник не выпуклый,
его можно, как мы любим, триангулировать.
Его можно триангулировать.
Ну, за квадрат.
У нас был критик триангуляции за квадрат.
А дальше давайте просто проверим точку,
которую мы тестируем на принадлежность нагугольнику.
Проверим, не лежит ли эта точка в одном из треугольников.
Проверим точку на принадлежность
всем треугольника.
Ну и понятно, что раз мы исходы наш нагугольник разбили
опять в множество каких-то треугольников,
их, кстати, будет линейное количество,
даже, на самом деле, N-2 всегда будет.
Треугольников в треугольнике всегда линейное количество
числа вершин.
Ну и соответственно, раз мы разбили все на треугольнике,
давайте просто переберем все треугольники,
попытаемся проверить ли есть точка внутри одного из них.
Если лежит, то значит, есть во всем нагугольнике.
Если ни в одном не лежит, значит, она лежит вне нагугольника.
Вот и все. То есть мы за N в квадрате триангулировали,
и потом за линейное время
спросили, лежит ли точка в каждом из треугольников.
Там это определили.
По этому поняли жидкие точки в многогоннике и линии.
Вот, хорошо.
Получилось решение за квадрата.
То есть мне нужна триангуляция,
и потом в каждом треугольнике проверить решительная линия.
Есть другое решение.
Есть решение за линией на время.
Понятно дело, что мы решаем уже в случае не выпуклого многогонника,
или, по крайней мере, не обязательно выпуклого.
Потому что если он выпуклый, то мы можем делать это за алгоритм.
Значит, решение за от.
Решение такое.
Давайте мы пройдемся по всем сторонам многогонника.
Вот есть СКП, который мы тестируем на принадлежность.
Пройдемся по всем сторонам АВ.
И померим ориентированный угол из ПА в ПВ.
То есть, ну, поймем градусную меру вот этого ориентированного угла.
И все их сложим.
То есть мы узнаем, с помощью атан-2, с помощью какой-то эффективной функции,
узнаем значение этого угла и его ориентацию.
То есть положить или отрицать.
Значит, знаем величину угла.
Все такие величины сложим по всем сторонам.
Все их сложим.
Тогда я ожидаю следующее, что если эта сумма равна нулю,
то точка лежит вне многогонника.
Это соответствует вот такому случаю.
Если П вне, то смотрите, что происходит, когда мы проходим...
Давайте я веду ориентацию на многогоннике.
Теперь представьте, что я провожу вот эти вот отрезки в вершины многогонника
и складываю все вот эти вот углы.
Ну, здесь там будет угол, не знаю какой, вот такой.
Потом будет такой угол, он его отчасти отменит.
Потом будет такой угол еще немножко отменит.
Такой угол еще отменит, такой угол еще отменит.
В итоге сумма будет равна нулю.
То есть если он там какой-то не выпуклый, какой-то более сложный,
то, собственно, логика та же самая.
У нас сначала какой-то угол, потом его частично занулили,
потом обратно прибавили, занулили, прибавили, и так далее.
В итоге будет нул.
Ну, а наоборот, если точка лежит внутри многоугольника,
то сумма этих углов обязательно будет кратно 2П.
Видимо, просто равна плюс-минус 2П,
но да, то есть если наугольник простой, то будет просто плюс или минус 2П.
Потому что вот в этом случае у меня что происходит?
Вот есть точка, я провожу вот эти все радиус-векторы во все вершины.
Считаю, этот угол, он будет такой угол.
Такой угол здесь у него немножко отменится.
Здесь он вернется.
Еще добавится такой и такой.
В итоге, когда я вращаю такой вектор, он у меня прокрутится 2П радио.
В итоге, когда я вращаю вот такой вот вектор, он у меня прокрутится 2p радиан, там 2p или минус 2p, в зависимости от направления обхода.
А здесь, если точка была вне многогольника, и я вращал вот этот радиус-вектор по всем вершинам, то он, собственно, нисколько не прокрутился, он как бы где начал, там и закончил, и ни разу точку p не опаясывает.
Ни разу точку p не опаясывает, он просто там где-то болтается и заканчивает там где-то иначе.
В итоге, просто по ударе сумме углов, я могу определить ответ.
Давайте запишем, что если сумма углов равна плюс-минус 2p, то точка внутри, то p внутри, иначе если сумма равна нулю снаружи.
Мы не будем доказывать корректность, потому что здесь нужны какие-то, то есть это более-менее очевидно из таких рукомахательских соображений, что там какой-то вектор плавает, и что если внутри, то он должен целиком пройтись, хотя бы один раз обернуть всю окружность, иначе он ни разу не обернет.
Вот, ну там для формального доказательства нужны какие-то теоремы в стиле там, теорема Жардана про кривую, что есть у вас здесь кривая, то она разделяет плоскость на две части, ну замкнутая кривая, то она простая, то она разбивает плоскость на две части.
Вот, ну короче, мы не будем в это врезать, вроде так на пальцах все равно понятно, что это работает.
В итоге, значит мы просуммировали сумму всех углов, если она ноль, то точка снаружи, если она не ноль, то она внутри.
Значит, проблема две. Первая проблема этого решения в том, что тригонометрия, тригонометрия это, ну это просто, я напишу так, тяжело.
Тяжело в том смысле, что операции вот эти вот все там атан-2 и все вот эти вот операции вычислений углов, они ну в общем работают довольно долго.
То есть если мы хотим намного таких запросов отвечать, то лучше от тригонометрии избавляться.
Ну если в общем сопрешенная проблема, это точность, это точность. То есть если мы сложим и получим там, не знаю, ну сумму явно ноль мы уж не получим, ну почем там ноль-ноль-один примерно.
Ну понятно, что это к нулю конечно, да, и в принципе проблем нет.
Но не знаю, если у вас там очень-очень много сторон, то в принципе можно накопиться такая огромная погрешность, что она ноль вашу превратит в 2П.
Может накопиться такая погрешность, что она вам перевернет ответ.
Этого конечно тоже хотелось бы избежать.
Ну и вот в следующий раз мы решим обе эти проблемы и построим алгоритм, который вообще не переходит к не целым числу.
Значит в следующий раз алгоритм в целых числах.
Ну все тогда спасибо за внимание, извините, что задержал.
И до следующего раза.
