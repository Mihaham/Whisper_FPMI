А давайте, значит, сегодня будем работать в такой оболочке.
Посмотрим, там вот в одном месте надо будет навести какой-то фраболизм.
Посмотрим, насколько у нас это получится. Давайте начнем.
Попытаемся фраболизм навести. Значит, пусть есть сколько множества...
Ну, давай сначала выпукываем нож, чтобы видим, что такое.
У нас множество на плоскости.
А пресс называется выпуком.
Если для любых двух точек, лежащих в С,
отрезок их соединяющих тоже целиком вложен в С.
У меня вот так хорошо отрезок между их суммой и длиной вложен в С.
То есть, если множество, какие бы мы две точки не взяли внутри нашего С,
все, что между ними тоже в С.
Причем это определение не только в R2 работает, оно в любых пространствах работает.
Удаление классическое такое.
Ну и дальше выпукала оболочка.
Это пустец.
Пустец.
Множество мы пока в плоскости живем.
Тогда его выпукалой оболочкой.
Что мы будем обозначать ОН в адрес.
ОН от слова конвекс.
Его выпуклая оболочка называется
пересечение всех выпуклых множеств содержащих оси.
С.
Это пересечение всех таких фигур С, содержащих ФС.
Просто пересечение всех таких ФС.
Пересечение фигур товарищей, содержащих С.
Представьте, мы будем работать сегодня с конечными множествами С.
То есть, если это конечная множество точек.
Ну вот представьте, давайте рассмотрим все выпуклые множества, которые вот эти вот точки содержат.
Вот это будет что-то вот такое.
Вот такой квадратик.
Все вот эти вот штуки там.
Вот такая полуплоскость.
Все такие штуки выпуклые.
Следующий С мы берем в одно большое перечень и пересекаем.
Вот.
Ну интуитивно чувствуется, мне кажется, что выпуклая оболочка это вот такой вот наглубой.
Ну давайте покажу, как это воспринимать можно именно на уровне интуиции.
Вот представьте, давайте в плоскость зовем гвоздики.
В тех точках, где, собственно, короче, в элементах это создаем гвоздики.
Давайте протянем какую-нибудь достаточно большую резинку, достаточно большого радиуса вокруг всех этих точек.
Ну так, чтобы она их все точно содержала.
И давайте ее потихоньку начнем вздувать.
Начнем она начать как-то вздуваться.
Единственное препятствие у нее это как раз точки С.
Ну, представьте, то, что она вздувается, вздувается.
В какой-то момент она упирается под эти гвоздики.
Ну, она так потихонечку стягивается, стягивается.
И там, где она станется, и внутрь уже пройти не сможет.
Если мы рассмотрим вот это вот, вот такое состояние виначки, то внутрь она уже не пройдет.
Ей не будет внутрь сдвигаться.
Поэтому у нас такой выпукленный угольник, построенный на каких-то вершинах нашего множества,
возможно не на всех, возможно и на вершинах каждого внутри.
Или там, скажем, на границе.
Вот. Но такой выпукленный угольник будет в оболочке.
Ну, соответственно, давайте попробуем это показать.
Что если я сконечно,
то выпукленный оболочек может быть от С.
Это какой-то выпукленный многоугольник.
С вершинами каких-то из точек С.
С вершинами каких-то только С.
По определению считаем, конечно,
точка сама по себе,
какие бы вы две точки не взяли, вы множите из одной точки,
отрезок между этими точками лежит в выпуклом.
И отрезок тоже.
Отрезок тоже, какие бы вы две точки не взяли на отрезке,
отрезок между этими точками лежит на отрезке.
Ну, давайте попробуем.
Давайте сделаем следующее.
Давайте мы рассмотрим.
Ну, во-первых, то, что это выпуклая фигура, очевидно.
Потому что мы пересекаем выпуклую фигуру в вершине выпуклых выпуклов.
Давайте первое замечание, что пересечение выпуклов все же выпуклое.
Значит, упон в отец больше не хочет выпуклых выпуклов.
Поэтому выпукла стена более менее автоматична.
Почему пересечение выпуклых выпукло?
Ну, представьте, у вас есть две фигуры,
для которых выполняется вот это соотношение,
что если есть две точки, то отрезок между ними тоже целиком внутри фигуры.
Когда какие фигуры пересекли их,
давайте возьмём какие-то две точки из пересечения.
Раз они лежат с пересечением, то они лежали в обоих фигурах до пересечения.
Значит, целиком отрезок между challenges лежал в обоих фигурах до пересечения.
Значит, в возр cot Cody? отрезок тоже целиком справится.
Поэтому, когда вы пересекаете две фигуры,
если какие-то две точки попали,
то отрезок между ними будет полностью лежать в border future как в пересечении.
Вот.
Ну, с выпуклостью вып lavor�도.
Давайте попробуем показать, что это мidents ratios.
Давайте сделаем следующее. Давайте рассмотрим, пусть это будет объединение всех многоугольников с вершинами в С.
Объединение всех многоугольников с вершинами в С.
Например, на этой картинке я рассматриваю треугольничек. Все, что здесь можно нарисовать.
Причем, возможно, даже не взять пункты.
Поскольку у меня конечные 100 точек, то и многоугольников тоже будет конечное количество.
Как определяется многоугольник, то есть под множеством точек, на которых я его строю, и каким-то порядком обхода.
На каждом под множестве может быть свое порядок.
В любом случае, этих многоугольников конечное количество.
Значит, их объединение тоже многоугольник.
Очень не хочется, да?
Многоугольник это что-то определяемое, ломанное своей границей.
Когда мы конечное количество этих ломаных объединяем, получим уже конечное количество.
Давайте запишем.
Таких многоугольников конечное количество.
Следовательно, П тоже многоугольник.
Причем, понятное дело, что...
Ну нет, не обязательно.
Хотя сказать, что его вершины это обязательно какие-то точки вес, но, видимо, не обязательно.
Пока что могут быть какие-то пересечения рюк.
Потому что, когда вы два многоугольника объединяете, у вас одно здесь может выступать пересечение рюк.
Ну, боксно.
Давайте покажем, что П на самом деле выпукло.
Почему?
Ну, вот мы обвиняли какие-то многоугольники.
Давайте возьмем какие-то две точки в П.
И покажем, что их вдалеке движение тоже лежит.
Что значит, что были какие-то две точки?
Значит, что у меня пришла какая-то точка Х из одного многоугольника.
Смотрите, какая-то точка И, возможно, из другого многоугольника.
Я хочу доказать, что эти две точки между ними тоже в каком-то многоугольнике лежат.
Ну, интуитивно вроде понятно.
Надо как бы склеить эти два многоугольника, объединить, и тогда х будет между ними лежать.
Можно продлить добирание.
А, ладно, не важно.
А может это значит, что любое не выпукло может объединить этого многоугольника?
Ну, вот как это сказать, непонятно.
Ну, потому что не выпукло просто какая-то часть, которая...
Типа, можно слезать и таким не выпукнуть, когда будет?
Да, да, да.
И о него есть объединение.
Давайте попробуем.
Значит, утверждается, что для любого не выпукла многоугольника, который мы объединяли,
есть какой-то выпукло его содержащий, тоже с вершинами на точках С.
Ну, почему?
Вот все-таки многоугольник.
Давайте тоже нарисуем такой вот стрелок.
Ну, давайте вершину назовем выпуклой, если угол при ней меньше, чем П.
Да, и соответственно, не выпуклой, если угол при ней больше, чем П.
Такая шарская выпуклость, это вот такие вот врезания вкуда-то внутреннего уголника.
Вот, тогда утверждается, что если мы возьмем любую не выпуклую вершину,
ее срежем, то есть, если у меня были три последние вершины ПИ минус один, ПИ минус один,
я ПИ-то уберу, тогда у меня останется многоугольник.
Там пресечения будут появиться.
Да.
Ну, угольник может быть.
Вот это будет, когда будет.
Да, это будет следовательно.
Ну, может, так разбираться.
Не думаю.
Да, может быть, вот здесь вот что-то было, там такое вот.
Это где пресекулся.
Получилось.
Может, в Пи будем смотреть все-таки только выпуклую?
Или это будет лажа?
Может быть, идут все уголочки с точки.
И как там?
Ну, если точку, которая будет лежать внутри у ПП-плошки остальных точек,
если нет, то соединим карты с крайними вершинками
и докажем, что пучили.
Ну, касательно сетки.
Ну, хорошо, давайте попробуем.
Так, сейчас.
Одну секунду, я еще надо идти.
Сейчас, как на пресечении?
Просто это точка, которая пресечена.
А что значит?
Ну, тогда, если оно было просто вот так,
тогда у меня пропадет какая-то часть угольника.
Если я просто уберу.
Ну, хорошо, можно убирать.
Просто забить на эту неудачную точку.
Ну, звучит здраво.
То есть, можно удалять все такие углы больше, чем ПИ.
То есть, у нас просто есть последний точек на границе.
Давайте удалять углы, которые больше, чем ПИ.
Просто вот пока они есть, давайте их высекать за дня две соседние.
Две как бы, ну, предыдущие, следующие вершины, как здесь.
Потому что там будут какие-то пересечения кофе.
Давайте так делать, пока какие углы есть.
Значит, в конце их не будет.
В конце все углы будут меньше равно, чем ПИ.
Но, возможно, будут самопересечения.
Ну, просто рассматривать на угольник формально, как последний точек на границе.
Вот, ну, сейчас тогда не пойму, что кое-кто будет.
Ладно, пофиг, давайте, давайте в минуту.
Ладно, пофиг, давайте.
Ладно, пофиг, давайте.
В индукции, думаете, получится?
Хорошо, я попробую.
Окей, индукция по С.
Ну, наверное, какая-нибудь база С не больше, чем два.
Тривиально, потому что если я сравниваю один, то это просто одна точка.
Одна точка по размеру 1 является выполнодугольником.
Ну, так себе видно в целом.
Если я по размеру 1, то это просто одна точка.
Одна точка является выполнодугольником.
Если я сворну два, значит у меня есть две точки, ну и этот между ними является, как раз, буклоболочкой выпунулой.
Так, теперь, значит, переход, пусть у меня была какая-то, пусть у меня на предыдущих N точках,
S без какой-то UR,
был построен многоугольный флеш с буклоболочкой, потому что это какая-то новая точка.
Значит, если она внезапно попала в руль этого многоугольника, то утверждается, что выпуклая булочка осталась такой же, как была.
Потому что, в частности, в качестве одного из тех пересекаемых множеств, можно выбрать старый многоугольник,
он содержит V, ну а меньше взять нельзя, тогда он остается.
Внутри выпуклой булочки S без V, тогда выпуклые булочки сохраняются.
А вы же что-то наслаждались?
Э-э-э, просто дождение.
Так, ладно, теперь иначе, пусть вы не многоугольник.
Давайте тогда и из вершины V проведем касательно многоугольника.
То есть мы проведем две такие экстремальные прямые,
чтобы это целиком находиться внутри вот такого угла.
А как угол руптовидности чей-нибудь получается?
Еще раз?
Не понял.
Мы для чего-то здесь...
Еще раз.
Я докажу кождение индукции по размеру S.
То есть у меня скажут, для N.1 теперь N.1 добавляется,
если она внутри старой выпуклой булочки, то старая и останется,
теперь пусть она вне.
Тогда давайте берем касательно многоугольника.
Они пересекают, ну как бы они касательно многоугольника,
каких-то точек.
Значит тогда утверждается, что если добавить внутренность вот этого вот угла
гранического точки, то это будет не так.
То есть если добавить внутренность вот этого угла,
внутренность вот этого вот угла гранического точки по E.
Ну то есть иными словами, если я в старой выпуклой булочки
добавлю треугольник в E.
Вот эту старую выпуклой булочку.
И объединяю ее с треугольником в E.
Понимаешь, что это будет новая выпуклая булочка?
Ну почему-то, а понятно, что
вот этот треугольник должен лежать внутри новой выпуклой булочки.
Треугольник должен лежать внутри выпуклой булочки.
Ну что, Бресс?
Ну потому что это какой-то треугольник натянут на вершины.
Ну нет, сейчас, сейчас.
Ну да, конечно, еще раз.
Потому что этот треугольник натянут на вершины
на какие-то три точки нашего множества веса.
Если у меня все эти три точки лежат внутри выпуклой булочки,
то и треугольник на них натянут и тоже.
Да, потому что если лежит точки и точки, то отрез
合 между ними, точкой и точкой отреза между ними,
и здесь точкой и точкой отреза между ними.
То есть все, что внутри этого треугольника тоже лежит в выпуклой булочки.
Хорошо, то есть треугольник точно мы можем безопасно добавить.
Ну и утверждается теперь, что если мы этот треугольник замкнем оставшейся частью ломаной,
попавшую по другую сторону под разделение ПП,
получится выпуклая фигура, которая содержит все точки и при этом является наугольником.
Это обязательно будет?
Да.
То есть осталось разборить в машинке по другую сторону нос,
он выходит и назначает отрезок при жидком.
Вот у нас отрезок после ПП придет точно с меньшим углом, чем 180.
Да.
Там если взять, ну если посмотреть такой отрезок и попросить с другой частью ломаной,
которая по ту же сторону, а то, что и вы, там на точку смотреть,
то есть у нас получится, что этот отрезок это как два отрезка,
и вот верхняя часть содержится в облочке, потому что в треугольнике,
а нижняя у меня потому что в облочке по предыдущему.
Да, окей.
Давайте попробуем.
Смотрите, мне осталось доказать, что вот эта штука это выпуклая фигура.
Если я покажу, что это штука выпуклая,
тогда у меня как раз я построил какой-то наугольник,
содержимый в точках множества С.
Значит, в частности, это одна из пересекаемых фигур.
Ну, прейду к самому минимальному.
Но она является, конечно, выпуклой оболочкой,
потому что мы построили, ну, грубо говоря,
то есть нам надо показать, что есть какой-то выпуклый наугольник,
содержащий все точки, свершенными в этих точках.
Ну, понятно, что это делается минимально просто по включению множества.
То есть у нас содержатся все точки выпукла,
поэтому никакого другого под множество нет.
Поэтому заодно это будет просто минимально из пересекаемых множеств.
Окей, значит, почему штука выпуклая?
Ну, давайте рассмотрим две части фигуры.
То, что идет по одну сторону от прямой БК, вот эта первая область,
и по другую сторону от прямой БК, вторая область.
То, что идет по этой треугольнике, все точки, которые, значит,
все пары точек, попавшиеся сюда, лежат в отрезке,
они лежат в треугольнике, все точки, лежащие здесь,
это выпуклая часть наугольника, потому что явно
гугольник старый пересек был у плоскости,
вот все, что по одному сторону.
Все, что идет внутри, здесь тоже,
любые две точки, тоже соединяют отрезки.
Теперь, если я соединю какие-то две точки
между частями, то есть кинут какой-то отрезок,
проходящий через пыку.
Там, не знаю, х, да?
Вот если х целиком в старом многоугольнике лежал,
то все хорошо.
Теперь пусть картинка именно такая, что х
внутри.
Старое выпукло в оболочке.
А игрек вне.
То есть он лежит в треугольнике,
но не в старого выпукло в оболочке.
И, наверное, мы их сбьем не полностью внутри
старого выпукла.
Ну да, да, да.
Ого!
Какие они по разной стороны выпущут?
Правильно?
Да.
Просто, ну, ставь просто, что есть.
Да, я понял.
Ну, давайте, давайте.
Что есть игреки по разной стороны.
Так.
Ну, давайте пересечем.
Да, на самом деле это даже было неважно.
Главное, что они просто по разной стороны выпут.
Пересечем.
С отрезком быку.
Вот.
А еще, ей не кажется, может лежать старый выпукло в оболочке.
Да.
Ну, если он и так лежал, то икс игреки так, и так телеком.
А, нет, нет, нет.
Это мы поговорили.
Тогда мы пересекаем эти два отрезка.
В какой точке z?
Тогда эта часть лежит в выпукло в оболочке,
потому что она вся внутри старого ногоугольника.
И эта часть лежит внутри выпукла в оболочке,
потому что она вся внутри треугольника.
Все.
Значит, весь отрезок лежит,
и реальная фигура получилась.
Давайте сойдемся, что этого не будет на экзамене.
Да, я даже так думал.
Ну, короче, можно поверить в это?
Это правда.
Да, в угольное экзамене все.
Когда-нибудь я придумаю нормальное доказательство этого факта.
Давайте на до бал кому-нибудь дадим.
Давай.
Так, прикол в том, что в общем случае мы не в ногоугольнике пересекаем.
Потому что по определению в оболочке отпущение всех выпуклых фигур.
Там может быть всякие, всякие стремные вещи.
Нормально получилось.
Ну ладно.
Все, в офисе.
Короче, доказательство.
Вот.
Ладно, теперь давайте алгоритм мы какие-то построим.
Как можно находить, собственно, в оболочке.
Как можно расположить.
Алгоритм первый.
Заворачивание под ад.
А второй это разворачивание.
Это же разворачивание в оболочке.
Разворачивание под ад.
Мы не будем разворачивать под ад.
Да.
Мне точно.
Итак.
Значит вот.
Пусть есть набор дочек на возрасте.
Давайте найдем среди точек.
Самую левую среди таких, самую нижнюю.
То есть точка с минимальным уксом, среди таких, с минимальным игреком.
Ис.
Ни ма 니.
А в чём его задача заключается?
А, задача найти набор даучек.
То есть дан набор точек, дан найдение буквы.
Это может стать.
Логично.
Наоборот, это вообще конечная задача.
Да, набор точки конечная.
Вот.
Давайте найдем среди всех точек.
Точку с минимальным уксом, среди тех, с минимальным игреком.
Я представлю, что это обязательно вершина.
Выпуклого волочки.
Ну, вроде опять-таки понятно, да.
Например, можно сказать так.
Посмотрите, среди тех фигур, которые я пересекаю для получения выпуклого волочки,
есть, например, вот такая вот глупостность.
Все как бы по правой стороне.
Раз уточка с минимальным ныцом,
то такая глупостность содержится в любом все эти точки,
значит, входит в множество пересекаемых.
Вот.
Ну и раз уточка с минимальным игриком,
то, более того, я могу ее чуть-чуть наклонить.
Ну или даже просто.
Я могу просто выколоть все, что находится вот здесь.
То есть у меня был блок, и беда этого луча тоже будет выпуклаться.
Ну и все.
Значит, значит, это как бы одна из коронических точек,
она является выше.
Ну опять, скорее интуиция чем?
Ну это правда.
Вот.
Значит, данные даже очень с минимальным ныцом,
все такие как бы самые нижние, самые левые мне точки.
Давайте попробуем найти,
на какой стороне эта точка лежит.
То есть, раз мы считаем, что это вершина,
то давайте проведем, какая сторона ее содержит.
Давайте для этого проведем из этой точки все вот эти радиосеки,
во все точки множества вес.
Все такие стрелочки написали,
и давайте выберем из них самую, самую нижнюю.
Тогда понятно, что, опять интуитивно ясно,
что вот этот отрезок является стороной многогольника.
Но потому что вот эти все отрезки, в частности,
лежат на многогольнике,
из них самый экстремальный, вот в этом направлении,
я его специально выпил вот этим самым нижним.
Он лежит в выпукл discovers,
но ниже нам нет смысла идти,
потому что в частности есть такая глубокость,
которая содержит, раз это экстремальный объект,
то все остальные лежат выше глубокости.
Да, значит в частности вот это вот странно.
Самый нижний, значит.
Самый нижний, значит, смотрите, у меня вот есть точка,
вот эта вот самая левая, самая нижняя,
я пророжу все радиус-векторы,
они все лежат вот в такой вот полуплоскости,
справа вот вертикальная прямой.
Из них давайте рассмотрим вектор,
ну, неформально смотрящий наиболее вниз,
формально просто вектор с минимальным углом до вот такого направления,
то есть вот этот вектор,
который ближе всего к направлению вниз.
Собственно, ровно так на него и будем выбирать.
Мы можем любые два вектора,
если у меня есть какие-то два радиус-вектора,
я не знаю, вектор А или вектор В.
Как понять, какой из них ниже?
Надо посчитать векторное произведение,
мы тем самым поймем знак поворота,
и если, скажем, поворот от А к В идет по часовой стрелке,
то В лучше, В ниже.
А если поворот по часовой, то В ниже.
И, значит, ну, как раз В лучше.
Вот, значит, среди всех таких векторов я нахожу самый низкий,
сравниваю их по парам узнавать колярные векторные произведения.
Ну, и, соответственно, вот эта вот штука,
на этой картинке вот эта, будет странно.
И нашли первую сторону.
Ну, а дальше делаем то же самое.
Если нашли первую сторону,
то давайте теперь поймем следующую сторону,
содержащую вот эту точку.
Мы, опять, из нее рисуем все возможные радиус-векторы
во все точки нашей множества С.
Вот.
Ну, и, как бы, если теперь вот эту вот картину вот так повернуть,
а вот эту вот считать полуплоскостью,
относительно которой мы измеряем все углы,
опять выбираем угол наиболее, ну, как бы,
наиболее отстроенной вот этой вот горизонтальной,
а вот этой вот стороны.
Самый далекий угол этой стороны.
Ну, или, например, самый близкий вот к этому вот противоположному направлению.
Делайте точно так же.
Можно попарно любые из двух векторов понять,
какой лучше.
Если у меня есть вектор А и вектор В,
то, опять-таки, если атаковый поворот по часовой,
то В лучше.
А если вот это вот векторное произведение меньше нуля,
то есть поворот по часовой,
то В лучше.
Ну, и так мы можем любые два сравнить.
Тем самым выбираем самый экстремальный угол направлений.
Это сейчас алгоритм за n квадрат будет?
Типа того, да.
А, ну тогда я вопросу не дам.
Вот.
Да, хорошо вопрос.
Если много внимания,
то берем наибольшую подлиннюю.
Да, это верно.
Если здесь есть несколько точек,
соответственно, векторы сонаправлены,
то мы берем самый далекий,
потому что, ну понятно, это сторона,
на которой есть другие вот подразделяющие в сторону точки.
Вот.
И так делаем, пока не вернемся в изначальную точку.
Понятно?
Ну вот, давай черт напишем,
значит, быстренько, да?
Значит, выбираем
q1
с минимальным x
с минимальным лынком среди таких.
Дальше qt
ну давайте qi плюс 1
выбирается там.
Вот пусть у меня фиксированная точка qi,
я знаю, что это одна из точек на границе.
Я рассматриваю все райус-векторы
из нее ведущего все остальные точки.
Ну и соответственно,
ну давайте формально пишем, да,
что если векторное произведение
вектора qi да a
и qi да b
меньше нуля,
то есть как раз поворот по часовой,
тогда b лучше.
Ну и соответственно qi плюс 1
выбираем как самую лучшую
среди всех точек на глуголе.
Qi плюс 1
самую лучшую.
И если таких несколько,
то самую далекую вот будет.
Ну и так делаем, пока не вернемся
к точку qi.
Давайте какую-нибудь картину нарисуем.
Ну было такое множество точек,
из них самое левое минимальное,
это явно вот это.
Дальше я из нее рисую все
райус-векторы.
Сюда, сюда, сюда, сюда, сюда, сюда.
Понятно, что самое крутое
это вот этот вот самый крутой,
в смысле, если я по парно
любые два перемножу векторно,
то из них, как бы,
вот к этому все самые
самые крутые точки,
которые у меня есть,
вот к этому все остальные будут
двигаться по направлению
почасовой стрелки, то есть от любого до него
направление почасовой стрелки.
Поэтому у меня первая сторона это вот это.
Дальше отсюда рисую все райус-векторы.
Из них самое крутое это вот этот вот,
потому что к нему от всех остальных движения
почасовой. Отсюда видимый
экстремальный это вот этот вот,
потом вот это, вот это и вот это.
Пока не зацепились, пока не вернулись
ну как бы находим следующую сторону.
Окей?
Ну вот, получился алгоритм
за, давайте пишу,
pnk, где m, ну понятно,
для размера s, а k
это число вершин на любую оболочку.
Число вершин
в комбатрес.
Мы просто на самом деле смотрим
на векторы на последний и все.
Потому что, смотрите, вот давайте в этот момент,
например, вот я был здесь, вот это вот там уита,
я хочу найти k и плюс 1.
Я отсюда рассматриваю
все вот эти вот векторы.
Хочу найти из них лучший.
Что такое лучший?
Давайте просто по ним посмотрим.
Вот это вот.
Вот это вот.
Вот это вот.
Что такое лучший?
Давайте просто по ним по всем пойдем в произвольном порядке
и будем погеровать лучше с одинаковым.
Например, давайте вот эти
вот эти два вектора посмотрим.
Вот эти два, да, в точку i и в точку b.
Перемножим их векторами.
Понимаем, что вектор напряжения отсюда до сюда
отрицательный.
То есть здесь движение по часовой.
Значит b лучше чем a.
Окей, тогда a игнорируем.
Берем следующий вектор, скажем вот это, a5.
Перемножаем вот это на то, что
текущий найденный лучший вектор.
Перемножили? Поняли, что здесь опять b лучше.
Потому что движение к нему по часовой.
Значит b игнорируем.
Пока что b лучше найденный.
Теперь, например, сравниваем текущий лучший найденный b
вот с этим.
Ну понятно, что c лучше.
Потому что к нему вектор отрицательный.
То есть он как раз по часовой.
Про b забываем, теперь c это лучше.
Ну и так далее. Его сравним
со всеми оставшимися. Скажем, сначала
поймем, что он лучше чем вот это, лучше чем вот это.
А потом найдем вот это, вот это.
Он лучше чем c, и d будет отвертым.
То есть я даже направление рисую,
я просто смотрю на вектор напряжения,
как только оно отрицательно,
туда спущу.
Потому что
чтобы найти одну сторону,
я рассматриваю все раневые секторы из данной точки
и хлен. Из них выбираю лучший.
То есть просто сравнил 1 с 2,
выбрал один из них лучший.
Сравнил лучший с 3, оставил лучший.
Лучший с 4 и так далее.
И у меня будет все ка и тараться,
потому что ка сторон.
Хорошо.
Вот.
Значит, зачем мы это сделали?
Во-первых,
это бывает довольно эффективно,
ну если у вас откуда-то известно,
что точек на выпуклоблочке мало.
Например,
вот говорят, что если точка сгинела
случайно,
особенно с каким-то там распределением
внутри какой-то фигуры,
то обычно выпуклоблочкой точек мало.
То есть, грубо говоря,
если бы вы захотели написать задачу,
подготовить для нее тесты,
да, ну типа задачу найти выпуклоблочку данного множества точек.
Если бы вы кидали точку случайно,
просто на рандоме или что-то,
тогда, скорее всего, на выпуклоблочке у вас было бы очень мало точек.
Там оценка типа
то ли логарифм,
то ли корень третьей степени,
в зависимости от того, как вы генерируете
внутри какой фигуры.
Ну и, соответственно, тогда
в случайном случае,
как бы при случайном распределении
точек, это уже довольно
неплохо.
Вот.
А потом начинаются контратесты,
там заинтересованы.
Ну да.
И если завтра не позаботится о том, что есть хорошие тесты,
то...
Я думаю, что да.
Ну, если вы хотите сделать точку случайного партии,
то надо это сделать в слово время.
А если мы отсветили точку,
потому что вот эта последовательность на рандоме,
ну как последовательность на рандоме,
а что от сортировки точки?
Ну, если вы уголосы взбивает кто-то внимание,
ну,
то вот в этой реакции у нас выпуклоблочка
это последовательность.
И что, вы не следующим просто вопросом?
А, ну, не согласен.
У вас...
Может, одна срона с точкой смотровой портросит.
И от нижней и верхней
она посредственно оборудует.
Ну, это не под последовательность.
Ну, то есть, как бы вы сюда провели,
ну, как бы вот если бы вы отсюда все истрелки провели,
у вас вот эта не под последовательность.
А, сейчас под последовательность, да?
А, да-да-да-да-да-да.
Сорри.
Мы сейчас ровно так и будем делать, да.
Сортировку по углу.
Да, все правильно.
Сорри, мы к этому переходим.
Я сегодня туплю безбожно.
Давайте перережем потом.
Сортировку по углу.
Как раз то, что предлагали.
Смотри, давайте сделаем следующее.
Давайте мы фиксируем
вот эту вот первую точку,
точку, с которой мы начали.
По один, да, самая левая, самая нижняя.
Давайте ее фиксируем.
Давайте так же проведем
радиус вектора из нее во все остальные точки
нашего множества.
Давайте их сортировим по углу.
То есть, раньше до этого я просто их попарно сравнивал,
понимал, какой из них самый экстремальный
в эту сторону, а теперь давайте сейчас
их посортируем за инлоги.
Сортировка векторов по углу.
Да, мы понимаем, что они все лежат,
давайте я нарисую так.
Строго внутри вот такой вот фигуры,
то есть их углы по направлению,
ну, по сравнению вот с этим вертикальным направлением
от нуля включительно
до став не включительно.
Поскольку это самая левая, нижняя точка,
то все остальные векторы пьют вот вверх
либо вы это вправо,
но точно не вниз, потому что иначе
можно было бы ее взять вниз.
То есть у меня все векторы лежат внутри вот такого диапазона
от нуля до пьения включительно,
я могу их посортировать, скажем, просто смотря
на像 disconnecting.
Как clarifying 4 Daniol,
כן��اааааа
pourquoi она не включится?
prмо- thinks
est ...
expmo
ga-
rayau
Č
walking
Б идет раньше чем.
Да, да, именно так. То есть у меня есть просто набор вот этих точек.
Я ввожу такой компаратор на точку, что одна раньше другой, если вектор укрепления такой это.
И сортирую с помощью этого сравнения.
Если вектор укрепления равен нулю, то есть если, скажем, у меня две точки оказались на одном вот таком вот векторе,
на одной такой прямой, то давайте скажем, что раньше...
Нет, раньше идет та, которая на меньшем расстоянии. То есть сначала вот это, потом вот это.
Ну, скорее всего... Нет, важно потом... Важно, важно, важно, важно.
Значит, сначала X, потом Y, потому что чтобы мы это X удалили.
Вот. Ну, а дальше будем... Окей, то есть у нас теперь есть какой-то порядок на этих точках, грубо говоря, в соответствии вот этим вот поворотом.
Тогда давайте теперь идти и делать следующее.
Давайте считать, что мы прошли какой-то префикс наших точек в этом порядке и построили на их корректную выкупку оболочек.
То есть пусть вот что-то такое у меня уже есть.
Я прошел несколько первых точек. Вот в таком вот порядке, 1-я, 2-я, 3-я, 4-я.
Построил у них выкупку оболочек. Рассматриваю следующую в этом порядке.
Что это за точка? Она либо лежит на продолжение вот этого луча, то есть если у меня были два вектора с кроссом равным нулю,
тогда у меня это будет после этого.
Либо же она лежит вообще где-то выше этого угла, то есть кросс до нее... Ну, короче, все было против всего остального.
Короче, следующая либо на новом каком-то луче лежит, либо на продолжение скала.
Значит, в любом случае эта точка лежит вне оболочки, которую мы уже построили.
Потому что она лежит вне вот этого оболочи, значит вне оболочки.
Поэтому из нее достаточно провести касательный к нашему надугольнику, ну и сделать то, что мы уже делали.
То есть в этом случае я провожу вот такую касательную, и все, что попало внутрь вот этого треугольника,
вот это касание, я просто высекаю и вижу, что теперь выпукла оболочка это объединение старого и нового точки.
То, что мы делали в доказательстве, у нас была старая корректная оболочка, появилась точка вне,
я провожу касательный, и все, что вот на границе между этими точками касания, вот здесь вот, все, что здесь было,
я удаляю и говорю, что это новая вершина надугольника.
Причем касательный искать довольно просто.
Давайте напишем, что корректную оболочку для первых и точек, давайте будем хранить ее в векторе.
Ну в каком-нибудь векторе.
Вот в таком порядке, первая, вторая, третья, четвертая, пятая.
Ну вот, короче, в соответствии с тем полях, на которые у нас эта точка существует.
Дальше приходит новая точка, какая-то точка B.
Как провести с нее касательное?
То есть я уже что одна из касательных будет как раз у один B,
ну потому что вот эта точка как бы, вот эта точка в любом случае, самая левая, самая нижняя,
да, любое другое вектор отсюда, сюда, лежит как бы правее вот этого вектора PQ1.
Значит PQ1 обязательно надо взять, это одна из новых сторон на буквы.
Ну а из этих мне нужно выбрать какую-то точку, такую, что как бы вектор на нее ИСП,
самый правый, наиболее удален, наоборот, вектор PQ1.
То есть одна из касательных у меня всегда будет PQ1,
а вторая мне нужно найти, давайте побольше картинку нарисую.
Прости господи, тернарным поиском?
Не-не-не, все сильно проще.
Да-да-да, вот пусть у меня был такой стернный уголик,
пусть у меня вот здесь где-то пришла новая точка PQ1, вот здесь.
Их идеи.
Да, у меня первая касательная здесь, вторая у меня вот сюда.
Представьте.
Нормально, ну понятно, точка где-то там.
Вот, когда смотрите, у меня точки были в порядке вот в таком вот порядке.
Я утверждаю, что мне достаточно просто несколько последних из нашего вектора удалить вот эту вот эту.
И вот это порядок удаления, первая точка...
Сейчас надо нарисовать платью, все-таки мне придется кое-что описывать.
Чего?
Она не может быть внутри, я утверждаю.
Я вроде даже сказал, что она либо на новом луче, не лежащем внутри на уголике,
либо на продолжение луча все равно не лежит внутри на уголике.
Вы всегда свежие, она всегда не лежала в старом уголке.
В общем, мы вообще уже построили уголок, уже только справим, десантировали, начинаем идти...
А у меня имплементально он горит, пусть я построил до первых, и сейчас поборок я построю для их успехов.
Так, ну где-то здесь пришла номер точке В, это одна касательная, тут вторая.
Что я делаю?
Смотрите, можно, например, сделать так.
Ну, вообще говоря, мы что хотим?
Вот если я нарисую вектор вдоль правильных сторон на угольника,
то они как раз по такому мы заворачивали подарок, они все идут вот так, в порядке, в прочую сторону стрелки.
Вектор на предвлечение каждого предыдущего со следующим, оно положительное,
потому что поворот от предыдущей стороны к следующей идет у меня в прочую сторону стрелки.
Ну, давайте тогда все неподходящие удалим.
То есть все старые стороны, у меня раньше была вот такая вот сторона,
она по сравнению, если бы я, например, просто оставил все, что было раньше в векторе и добавил просто В,
тогда у меня было бы нарушение вот с этим условием, потому что у меня поворот отсюда-сюда, он идет уже по часовой стрелке.
Значит, точка плохая, она не может быть на границе на угольник.
То же самое с этим вектором.
Если я просто был в конце моего многогольника добавил точку П,
то есть у меня после вот этой стороны было бы вот это,
у меня опять поворот от этой стороны к...ну, как calibration, на точку П,
опять поворот идет по часовой, то есть отрицательной.
Поэтому эту точку надоburghить.
И, наконец, если бы у меня после этой стороны шла вот это,
опять было бы произведение отрицательное, было бы подчасовое, я ее удаляю.
А вот после этой стороны уже точку P можно добавить, потому что здесь будет хорошее положительное произведение вектора.
И просто точку P можно будет добавить.
Значит тогда, давайте напишем, пусть у меня как-то называется пресс.
С, слово кондекс.
Пока С хотя бы две точки, давайте рассмотрим вектор, образованный последними двумя.
Давайте я их как-нибудь назову.
С это какое-то последнее, СМТ и СМ минус 1.
Пусть они две последние точки.
В таком порядке.
Ну и дальше я вам говорю, что если векторное произведение от этой стороны СМ минус 1 С
К СМП.
Минус 1, да?
Тогда я просто удаляю СМ. СМ делаю цедочку пупа.
То, что их не должно быть в какой-то лочке, мы в этой бездоказательстве?
Еще раз.
То, что эти точки нужно удалить, мы в бездоказательстве?
Ну, да.
Очер.
Очевидно.
Напишу алгоритм, станет понятно.
Тут как-то интуиция все перебивает, а что-то накатывает.
Короче, все эти ветки, все эти стороны, которые нарушали правильность следования вершинок на глубине,
я все эти вершинки удаляю, удаляю, удаляю, пока они идут до последней стороны.
Такое, что направление от никела на новую точку уже будет как раз в правильном направлении и прочее.
В смысле, если ровно ноль, давайте подумаем.
Мне кажется, что вот таких они бывают.
Да, тогда меньше правил.
То есть, если, например, у меня была вот эта точка вот здесь вот,
предыдущая точка была вот здесь вот,
то ее тоже надо было бы удалить.
Поэтому любые тоже лучше удалить.
Ну вот тем самым у меня как в конце останется список точек такой,
что все последовательные вот эти вот стороны, все эти ветки на сторонах
будут только заворачиваться против всего сделки.
Сейчас мы не говорим, что x-ray and shape.
x-ray and shape, да.
Не, смотрите, смотрите.
Нет, такое бывает.
Вот такой же артик, представьте.
Вот у вас был вот такой надлугойник.
Тут все коряне, да, у меня случилось вот этот,
ну, короче, сначала все вот эти, потом добавляйте вот этот.
Все равно может быть такое, что у меня, ну, короче,
какие-то две стороны совпали по направлению с точкой B.
Так, в этом случае эта точка попала вот в эту сторону,
ее надо допить.
Это же не все, там другие будут есть,
плюс сетка, а сетка там очень разная.
Да, они разные, они разные.
Ну, то есть у меня сначала это, потом это,
но все равно вот в этом вот случае может быть этот сонокарт.
Потому что вот этот, я тебе вот это, а не сонокарт.
Просто может быть он.
Ну вот, то есть я, получается, все вот эти точки ударил.
Но дальше, в конце этого файла, я просто делаю цеплю швы B.
Ну, потому что B, эта точка как раз вне многогоника,
я ее добавляю как вот экстремально.
Как одну из ушей на двух.
Все, вот, я вот это ударил.
А B добавил.
Конец, я сделал переход.
Логично вроде.
Почему мы завершаемся, когда у нас...
Еще раз.
Почему мы завершаемся, когда у нас меньше двух точек?
Разве не раньше, когда мы должны завершиться?
Ну, окей.
Элф брейк, я здесь говорю.
Ну и иначе у меня просто бесконечный подход.
Пока есть хотя бы две точки, я смотрю на ту сторону,
которую они образуют.
Пытаюсь продолжить многогоник этой точкой.
Если, ну, если нельзя продолжить, то удаляю последний.
Иначе, ну, как бы, значит, иначе у меня все починилось.
Значит, это в какой-то момент, когда у меня вот эта сторона,
и дальше вот эта, ну, образует правильный подход.
Поэтому иначе можно просто изваривать,
потому что у меня больше этого не сработает.
Все идет?
Ну вот, если ты знаешь, что это работает суммарно с МОГ,
потому что у меня сначала одна сортировка, одна.
А дальше я просто иду по вот этому списку вершин,
поддерживаю текущую версию выкладывалотики.
Ну и вот тут еще какая-то вайла, но понятно, что
каждая итерация, каждая успешная итерация вайла
удаляет одну вершину из С.
Ну и правда ли, что быстрее нельзя, казалось бы?
Быстрее нельзя – это правда, да.
Ну, то есть, в общем случае, если у вас...
Иначе мы сортировали в каком-то смысле.
Ну, короче, да.
Если можно быстро строить ВПП-болочку,
то можно быстро сортировать число.
Ну, это вроде...
Можно припостроить.
Мы не делаем ее, она обязательно будет вне.
За счет того, что мы так сильно сортировали,
она всегда будет вне.
А если уже сортированы ВСМ?
Да.
Ну, это как раз вряд ли.
Сортированы по углу относительно вот этой самой левой нижней точки.
И это прямо совсем вовремя.
Почему новые точки вне?
Давайте картинку еще раз посмотрим.
Пусть у меня построена вот эта оболочка
для первых и точек в порядке сортировки.
Я добавил, у меня сейчас такая оболочка.
Точки новые, когда добавляются,
они по сравнению вот с этим вот последним вектором,
с радиус-вектором на последнюю точку,
как может выглядеть новый вектор?
У него либо векторное произведение с этим.
Положительно в том смысле, что она лежит...
Еще нужно прокрутиться выше.
То есть она либо здесь,
либо векторное произведение так ну левое,
но она дальше отходим.
То есть новая точка где-то здесь.
Все нормально?
Хорошо.
Теперь давайте третий алтеритм как раз,
который у вас может работать за линию,
с большей вероятностью,
по сравнению будут в этом порядке.
Значит, это сортировка по корзинам.
Давайте я пока для удобства буду считать,
что у меня все x-ы различны.
Что все x-координары по парам не различны.
Потом разберемся, что делать,
если они бывают совпадающими.
То есть первое, что мы сделаем,
давайте отсуществуем все точки по x-ам.
Вот так вот они сьема направо будут отсуществлены.
Опять делаем то же самое.
Идем по точкам в этом порядке
и поддерживаем группу оболочку.
Но в этом случае мы будем поддерживать группу оболочку
не одним вот таким вот куском,
не в одном векторе,
а двумя нижней и верхней частью
группы оболочки.
То есть в этот момент времени,
когда я рассмотрю вот эти вот точки,
у меня нижняя группа оболочки
это вот эта вот,
на эту углу,
а вот эта вот эта одна,
верхняя группа оболочки.
Что такое нижняя?
Это когда я отхожу
мой набор точек,
вот в обычном моем порядке,
против всего стрелки,
начиная из левой нижней.
Что такое нижняя часть группы оболочки?
Это движение от самой левой,
где мы начали,
ну до самой правой.
Вот та часть многоугольника,
та часть группы оболочки,
которая идет от самой левой до самой правой,
это нижняя группа оболочка.
А все, что будет дальше по направлению многоугольника,
от этой до начала,
это верхняя.
То есть, самая левая и самая правая
рассматриваемые точки.
То же самое, да, то же самое.
Я покажу, что все x одинаковые,
потом мы рассмотрим,
если они вместо меня совпадают.
Вот все x были одинаковые.
Вот.
Ну, окей, тогда смотрите,
пусть у меня хранится вот эти две группы оболочки,
верхняя и нижняя,
тогда, когда рассматриваю новую точку
в этом порядке,
у нее х больше, чем все предыдущие,
поэтому сейчас она точно в выпуклолочке не лежит,
потому что новый х больше, чем все остальные,
она точно вне выпуклолочки,
вот такая вот точка.
Тогда опять, чтобы перестроить выпуклолочку,
надо провести две касательные.
Надо провести две касательные,
и так будет.
Мы обе, обе сразу.
Вот, и при этом
работает та же самая идея, что, смотрите,
если я нижнюю выпуклолочку lower
буду хранить в таком же векторе,
ну или типа в стеке,
то мне нужно будет опять удалить несколько последних,
потому что у меня нарушается вот это вот свойство,
что следующая точка,
ну как бы направление стороны
предыдущей и следующей,
они должны быть
правильно направлены.
Не может быть такого,
что у меня сначала вот эта сторона,
потом вот эта сторона, значит, я эту точку обязан выпить.
Вот, и то же самое с верхней,
вот у меня была верхняя выпуклолочка,
если я слева направо так пойду,
если я просто добавлю эту точку,
то у меня была бы сначала вот эта сторона, потом вот эта,
а это неправильный заворот,
да, у меня нужно, чтобы верхняя выпуклолочка,
у меня все было почасовой,
у меня заворот должен быть почасовой,
а здесь внезапно получается против,
то есть вот такой вот излом,
это плохо, давайте удалять все точки
из обеих частей выпуклолочки,
пока не нарушится правильность
значений векторных произведений.
И это как раз будет
происходить до тех пор,
вот такая картинка какая-то,
это как раз у меня удаляются все точки,
лежащие внутри вот этого угла между касателями,
вот все эти удалятся, все эти сохранятся.
А как мы понимаем
к апер или к ловер?
Как мы понимаем?
У нас есть просто два вектора,
у нас есть два вектора,
ловер и апер,
нижняя верхняя выпуклолочка,
вот скажем,
что-то такое у меня есть,
и что-то такое у меня есть,
приходит новая точка,
я делаю то же самое,
давайте сначала с нижней разберемся,
у меня есть нижняя выпуклолочка,
пока в ней хотя бы две точки,
я рассматриваю
последнюю сторону,
в ней,
и пытаюсь, ну опять,
то же самое, вот у меня была эта последняя
и последняя точки,
я рассматриваю вектор из последней точки в п,
если нельзя
просто добавить п в ловер,
тогда значит надо удалить c.
То есть давайте в ловер,
у меня условие такое,
пока кросс
cb-1
cbm
cbmb,
мне нужно, чтобы
последовательно из вот этих векторов
она заворачивалась против часовой,
то есть чтобы она была положительной,
так вот пока она не положительная,
давайте ее и c удалим,
только вместо c надо взять полку.
Пока у меня нарушается вот это условие,
что все векторы должны заворачиваться против часовой,
я удаляю последнюю,
ну а в конце я просто добавляю b в ловер.
Пока нарушается условие,
удаляю последнюю, и b в любом случае
в конце добавляю, ну потому что b это экстремальная
точка по x, самая правая точка,
она просто по определению
у меня лежит и в нижней, и в верхней части
частях рукопроболочки.
То есть я все эти удалил, b в конце добавил.
Ну а с верхней частью рукопроболочки
была верхняя какая-то.
Секунду, мы в итоге точку закинем в обе оболочки?
В обе, в обе, да.
Значит вот у меня была какая-то верхняя
рукопроболочка, пришла новая точка b.
Пока векторное произведение
последней стороны
на новую точку b
не отрицательно,
мне нужно последнюю удалить.
То есть там будет все то же самое,
значок противоположный,
потому что здесь точки
наоборот, здесь стороны
заворачиваются по часовой стрелке,
пока это нарушается, то есть пока здесь
поворот против часовой, я их удаляю.
Пока здесь этот кросс положительный,
я их удаляю.
Эти удалю, да потому здесь
поворот неправеден.
И это удалю, потому что здесь поворот
опять против часовой,
а эту же оставлю, потому что здесь вот,
вот и вот эта поворота идет по часовой,
Оставляем и добавляем b в конец.
Самка аналогична.
Что-то меняется с знаком неравенства.
Ну все, и так же в конце ватки добавляем b.
Окей.
Ну все, получается, что мы построили обе части рукоголовечки, нижнюю и верхнюю.
Взаймываем.
Опять, потому что у меня одна ассортировка, а дальше просто проход с двумя векторами и стэками.
Каждая точка добавляется максимум один раз, поэтому суммарно все вот эти удаления работают уже в линейное время.
Ну а если у нас такие были все-таки точки с этакой миксами?
Теперь давайте поймем, что происходит, если есть точка с этакой миксами.
То есть я утверждаю, что на самом деле алгоритм можно вообще не менять.
Просто надо сказать следующее, что если у меня есть несколько иксов,
в смысле несколько точек с одним иксом, то это надо посердцевать, скажем, сверху вниз.
То есть я, как обычно, сортирую просто пары x и y.
Как у меня обычно работают компараты.
Сначала по иксу, потом по икле.
Вот, тогда утверждаю, что если у меня даже на одной вертикальной приму несколько точек взялись,
то алгоритм все равно правильно.
Вот этот же алгоритм, не надо еще ничего ифать, он хорошо отработает.
Ну почему, давайте слово сначала отработать.
Вот у меня была какая-то там вот такая вот корректная нижняя укрополочка.
Пришла вот эта точка.
Ну понятно, что в нижней укрополочке по факту надо хранить вот эту.
То есть мы снизу вертимся?
Да, как обычно.
В смысле при равном иксе в порядке возраста ниже.
Аккуративный? Это что?
То ж самое, самое левое ис FIFA самое нижнее.
Вот.
То есть тогда мы должны будем для нижней укрополочки брать самую нижнюю точку для верхней, самную малой?
Вообще говоря, да.
Можно сказать так, что если не хочется думать, то можно просто сказать,
okay, если есть несколько точек с одним иксом, то понятно, что extra это надо하기 в нижнюю,
это facto в верхнюю.
А все остальные игнорируют.
Вот, можно сделать так, можно этого и не делать.
Можно просто сказать, о'кей, давайте все эти точки
по одной добавляją в икру сначала в нижнюю укрополочку.
Скажем, добавляем вот эту. Ну окей, метка секается, а остается вот такая штука.
Потом добавляется вот эта, потом добавляется вот эта, добавляется вот эта.
Ну и заодно все эти привяжущиеся удалились, потому что когда у меня cross равен 0, я их удаляю.
То есть я сначала добавляю это, потом эту удалю, добавляю вот эту, эту удалю, добавляю вот эту.
В итоге у меня нижнюю проводить будет вот такой.
Это норм.
Потому что тайская кругновая сумма.
Это заболевание уже какое-то.
Ну вы посмотрите это уже.
А в случае с опором, разве тогда будет работать? Стоп.
Да, да. То есть у меня был такой новый.
Вот эти две точки. Ну а дальше все как обычно.
У меня добавляется новая точка, я перебираю, как бы я рассматриваю последнюю сторону
и смотрю на направление от нее до точки П. Опять вижу, что это надо удалить, удаляю.
Ну и она видимо в любом случае удалится. То есть если это не конец многогонника, точка обязательно удалится.
Потому что последний вектор здесь был. Строго вверх.
Какую бы точку я не рассмотрел, вектор напряжения вот этого на вот это
будет плохого знака и точка обязательно удалится.
Логично.
То же самое с верхним. Если у меня была какая-то корректная вертолетовая полочка,
у меня пришло несколько точек напрямую. Давайте добавлять их по одной с конца.
Ну давайте добавим вот эту, например.
Потом приходит вот эта, у меня здесь получается неправильный равенство, я ее удалю, добавлю вот эту.
Потом опять рассматриваю ногу, и оттуда опять неправильный равенство, добавляю вот эту.
То есть кажется, что в верхнюю руководочку вообще уйдет только верхняя точка.
Да, ну просто потому что, как бы, если у меня здесь есть несколько,
последний вектор руководки такой.
Следующий вектор руководки не может идти вверх.
Потому что если предыдущий пришел из левой полуплосности, дальше вверх,
тяни, надо было туда идти вниз.
Значит у меня просто все предыдущие точки на этой прямой пропадут.
И таким образом руководство будет строго вот такое вот.
Заканчиваться будет на верхней точке этой прямой.
Все остальные удаляются, потому что вот таких износов не бывает.
То есть в нижней у меня будет вся нижняя, включая вот эту последнюю, вот эту нижнюю, вот эту верхнюю.
А в верхней будет только верхняя.
Ну и вроде так.
Короче, от того, что появляются точки с одинаковыми цами, ничего не ломается.
В лучшем случае можно не думать головой и брать из них наибольшую и наименьшую.
Ну да.
А можете нарисовать, как вначале работает, когда у нас просто после этой точки все остальные вверх?
Все остальные что?
Ну там несколько вверх.
А, вверх.
Ну первое просто давайте ловер построим.
Сначала просто добавляется, потому что если одна точка, то туда просто пушбеккается.
Потом приходит новая.
У меня вот такой вектор и вот такой.
У них кросс равен улю, поэтому это высякается, остается вот этой вот.
Дальше, у меня к последней стороны вот эта, новая сторона вот это,кросс равен улю, поэтому эта высякается остается вот этой.
То есть в нижней оболочке у меня будут вот это и вот это.
А верхней будет, кажется, то же самое, пусть вот это вот у один несколько точек.
Сначала это добавится.
Э-э-э...
А, вот верхний, сейчас, сейчас, сейчас, сейчас, да?
Ну что, я понял, у нас должна быть герметичная точка.
Давайте попавайте на ней.
Да, да, я вас понял, сейчас, секунду.
А, да нет, нет, все нормально.
Сейчас, это как раз с саппером все нормально.
Потому что я рисовал, на самом деле, про апер работает.
Да.
Сейчас, давайте еще раз ловим.
Так, это добавилось.
А, тут все равно то же самое, да, будет?
Неважно, какой апер или ловер, потому что я рассматриваю
точку, которая лежала на той же прямой, что последняя
сторона, поэтому последняя всегда будет удаляться.
У меня после рассмотрения вот этой прямой, и в апере и
и в ловере будет только две крайние точки,
потому что все остальные удалятся из-за того,
что кросс здесь ну или здесь ну.
Поэтому у меня ловер именно будет из этих двух точек
состоять, а дальше, когда приходит новая точка,
в случае ловер, то есть в случае ловер
у меня как бы вот такой вот вектор, ну как бы вот такая
вотldoщка. В случае ловер, reform обязательно произойдет
который пытается найти злом. Эта точка удалится maybe if this politicians fault are not always clear
в случае ловорı эта вот плохая
И вот эта вот плохая верхняя точка удалится, а в случае апер у меня наоборот, как бы
вот у меня такой вот на ней порядок. Ну, это нормально, да, у меня Ir is going
на mercy. То есть когда приходит новая точка у меня начинается вот такая вот верхняя
накладка. То есть картинка такая, что у меня есть на самой левой прямой две точки
здесь много точек, и на самой правой прямой есть много точек.
Тогда у меня ловер будет вот такой вот, то есть оно содержит только нижнюю здесь и все здесь,
а апер будет вот такой вот, он содержит все здесь и только верхнюю здесь.
Вот это апер, вот это ловер.
Так оно найдется.
Ну можно просто нарешать в предыдущий алгоритм и не париться.
Вот.
Ну, хорошо.
Теперь давайте последняя идея,
что можно делать, например, с этим сортировками.
Если мы посортили вот в этом третьем алгоритме,
по иксам это все, ну то есть по координатам просто иксы,
то можно здесь научиться делать динамическую пуклооболочку.
Да, добавляются новые вершины, надо перестраивать пуклооболочку.
Без удалений просто добавляются новые точки, надо перестраивать пуклооболочку.
Да, все в рандомное место.
То есть раньше у меня было фиксировано множество точек С, я по нему строил кроме х.
Теперь у меня множество точек динамички выполняется,
мне нужно каждый раз сообщать, как пересчитывать пуклооболочку.
Вот.
Я буду хранить опять-таки две части пуклооболочки, нижнюю и верхнюю,
и давайте я буду хранить их в каких-нибудь сетах.
У меня будет верхняя пуклооболочка в виде сета точек и нижняя.
Ну внутри сета точки порядочны так же, как обычно, по иксу, потом по игре.
Это соответственно совпадает с порядком как раз на пуклооболочке,
потому что у меня на обеих частях они срочно слева-направо.
Здесь и здесь.
И снизу и сверху.
Вот. Хорошо. Ну вот представьте, у меня была такая нижняя пуклооболочка, такая верхняя.
Пришла новая точка.
Давайте, давайте.
Значит, как понять, лежит ли она внутри пуклооболочки в предыдущем множестве точек.
И если нет, то как, как она перестраивается?
У нас вроде был...
А, ну это на семинаре, возможно, был за бинпоиском.
Можно за логен найти сегмент, в котором она лежит.
Ну, типа того, да, типа того.
Значит, вообще говоря, если она вне, то нам нужно опять провести две вот такие касательные.
Да?
И все, что пропало в отрезок между ними, надо удалить.
Как найти эти две касательные и как понять, что нужно удалять?
Давайте мы из этой точки опустим вот такую вертикальную прямую.
Посмотрим, где она пересекает, ну, скажем, наши, наши...
Давайте сверху попробуем.
Где она пересекает нашу верхнюю пуклооболочку.
И это делается просто бинпоиском.
Да, потому что нам нужно найти вот в этом вот нашем списке точек,
списке вершин верхней пуклооболочки,
нужно найти такие две соседние, что одна левее эта вертикальная прямая,
вторая правее.
Это просто бинпоиск по х.
А вот мы тем самым найдем первую точку с почли в равной абсциссой,
предыдущая будет с меньшей.
Поэтому мы нашли отрезок, который пересекается этой вертикальной прямой.
Ну, если отрезок попадает в вершину, то ему надо еще отдельное что-то.
Давайте это просто, я считаю, что отрезок не пересекает в сторону.
Вот.
Как понять, лежит она выше или ниже?
То есть, лежит ли точка внутри выпуклооболочки или вне?
Надо посмотреть, видимо, вот на такое электронное произведение.
Потому что если точка вне, то направление здесь противчасовое,
если бы она была внутри, то есть как бы под этой выпуклооболочкой,
у меня бы направление было бы, наоборот, почасовое.
Когда в соответствии со знаком вот этого векторного произведения,
можно понять, лежит ли точка внутри или вне выпуклооболочки?
Вот.
Давайте теперь разберемся с случаем, что делается она вне.
Вот она вне.
Я понимаю, что мне нужно провести две касатели.
И более того, мы вроде как уже умеем понимать вот как бы,
как надо расходиться от вот этой точки.
То есть мне нужно как бы идти в обе стороны, влево и вправо выпуклооболочки,
и удалять все возможные изломы.
То есть, если у меня есть сторона такая, что...
Вот такая сторона.
Ну да.
Ну понятно, притерировать с одной стороны...
Если у меня есть такая сторона, я вот ее начало рисую,
направление на добавляемую точку B.
Если здесь как раз происходит в неправильную сторону...
Нет, не так, не так. Сейчас оно испортно.
Не отсюда надо.
Ну нам нужно две последние точки посмотреть, да.
Не так. Наверное, предыдущую сторону нарисую и вот эту вот.
То есть как бы здесь видим, да?
Ну как бы мне бы по идее просто хотелось добавить эту точку вот в то место,
куда она lower bound попала.
Куда вот она биткоистом попала, внутрь сета.
Мне хотелось бы сюда просто добавить.
Но я не могу ее добавить сюда, если вот здесь вот происходит излом.
То есть если здесь вектор образения вот этого вектора на это
идет не в правильном порядке по часовой стрелке.
То есть если здесь противечасовой, а здесь противечасовой направление.
Мне нужно эту точку удалить, потому что как бы на ней получился бы излом.
Ну и так далее.
Я иду вот в этом направлении по моей блоковой оболочке.
Считаю вектор напряжения с стороны и новой потенциальной стороны,
то есть что было бы, если бы я эту точку добавил просто в конец, в конец вот этой части.
И пока у меня происходит излом, я текущую точку удаляю.
То же самое я делаю вот здесь.
Ну то есть, а когда нет, я просто ее добавляю в конец, в конец моего сета.
То же самое здесь.
Значит у меня как должно было бы быть, да, если бы я стартовал отсюда,
то все векторы должны были бы опять идти вот так вот по часовой стрелке.
Вот, я рисую вот этот вектор и следующий за ним, то есть сторону рассматриваю.
Когда здесь излом в неправильную сторону, то это может идти по часовой,
а здесь излом против. Поворот идет противечасовой.
Тогда я это опять должен удалить.
Давайте еще вот такую картинку побольше рисуем.
Например, было бы что-то вот такое.
Тогда я провожу вот такие векторы, вижу излом, потому что мне нужно, чтобы оно шло по часовой.
И здесь излом я это удаляю.
Рассматриваю такой вектор и такой, опять излом, потому что здесь противечасовой удаляю.
Ну а здесь все будет хорошо, если будет по часовой.
То есть вот этот вектор и за ним направление становится по часовой, так как должно быть.
Вот, и все. То есть я, получается, сначала один раз нашел,
ну как бы бенбольским левербанком, за логарифм, разделение моей верхней части выпуклоточки на две.
И дальше здесь влево удаляю точки, пока нарушается выпуклость.
И здесь удаляю точки, пока нарушается выпуклость.
Все, то же самое с нижней делаешь.
Удаление больше чем н, все зарегулируется.
Да, удаление больше чем н, поэтому это работает, амортизировано за логарифм на отравлении точки.
Потому что там просто бенбольский и много удалений.
На удалении суммарно максимум н, значит можно считать, что каждый работает за логарифм.
Это на оптимизацию динамики, в общем.
Ну, я бы сказал так, это само по себе отдельный алгоритм,
но его можно использовать для оптимизации динамики, когда, ну да.
Какой динамики?
Скорее наоборот, в динамике, возможно, иногда надо хранить такие выпуклооболочки.
Вот, и вот как их можно хранить. Все, спасибо.
