Давайте сделаем вид, как будто мы сначала пропустили, вот мы уже все это написали.
Мы продолжаем разговор про эллеровые циклы, эллеровые графы. Напомню, что мы пытаемся в графе
найти такой цикл, который идет по всем ребрам этого графа, причем ровно один раз.
То есть этот цикл не пропускает ни одного ребра, и плюс по каждому ребру
проходит не более одного раза. Мы выписали два критерия эллеровости.
Один критерий эллеровости для неориентированных графов,
второй критерий полуэллеровости для неориентированных графов.
Теперь давайте разберемся с тем же самым, но только для ориентированных графов.
Так его один, эллеровость урграфов.
Так, давайте слабо связанный урграф G эллеров, тогда и только тогда.
Но смотрите, в случае неориентированных графов что у нас было?
У нас степень каждой вершины четна. Для чего это нам нужно было?
Ну чтобы если мы попали в какую-то вершину, то мы из нее обязательно должны выйти.
То есть у нас не бывает такое, что путь где-то прерывается.
Но здесь это условие вырождается в следующее.
Для любой вершины из множества вершин графа G выполнено следующее.
Входящая степень, точнее степень захода вершины V совпадает со степенью ее исхода.
Ну и естественно, уже слабо связанный.
То есть если у вас есть какая-то вершина, то количество исходящих ребер должно совпадать с количеством входящих.
Вот, ну доказывается все аналогично.
Аналогично теореме 1.1.
Вот.
Ну и аналогичная теорема.
Аналогичные проблемы.
Теорема 2.2.
Ну соответственно полуэйлерость.
Ну слабо связанный граф G полуэйлеров.
Тогда и только тогда, когда...
Смотрите, ну в чем отличие эйлерового графа от полуэйлерового графа?
В эйлеровом графе есть цикл, который проходит по всем ребрам.
Полуэйлеров тоже проходит по всем ребрам, но он не цикл.
Вот как из нет цикла сделать цикл?
Да, ну просто добавить некоторых ребров.
То есть если у вас цикл был ориентирован так, то достаточно добавить всего лишь одно ребро.
Точнее, наоборот, да, должно быть вот так.
Вот, а теперь, ну смотрите, это граф эйлеров.
По критерию эйлеровости у него, у каждой вершины, степень захода равна степени исхода.
А теперь давайте уберем это ребро, что у нас получится.
У всех вершин степень захода равна степени захода, кроме двух,
у которых степень захода на один больше и степень исхода на один больше, ну соответственно.
Окей?
Так вот, у всех вершин, кроме, может быть, двух, степень захода совпадает степень захода.
А у оставшихся, степень захода минус степень исхода равна,
на этом напишу, плюс 1 и минус 1.
Ну, у одной вершины степень захода больше.
Точнее, вот у этой вершины степень захода больше на одну,
сходы на одну больше. Вот. Ну в смысле, у одной из них плюс один, у другой из них
минус один. Вот. Ну, оказывается, тоже аналогично.
Теоремия 2.1. Нет, 1.2. Всё. В общем, данные две теоремы, они дают что нам? Они дают нам
некоторые способы, как понять, можно ли на данном графе построить эллировцикл или нет.
То есть, что мы делаем в случае неориентированных графов? Просто смотрим на степени всех вершин.
То есть, если у нас граф связный, ну может быть, за исключением каких-то изолированных вершин.
То есть, понятное дело, что если у вас есть какие-то изолированные вершины, а весь остальной
граф связан, то в нём тоже можно построить эллировцикл. То есть, грубо говоря, если у вас есть
ровно одна компонента связанности, которая содержит ребра, и тут все степени вершин чётные,
то значит, постановка задачи поиска эллирового цикла корректна, и можно запустить какой-то алгоритм.
Для ориентиранных графов то же самое. Проверяем на всех вершинах неизолированных, что степень
захода равна степени исхода, и если это так, то можем применять на нём поиск эллирового цикла.
Ну и давайте наконец разберёмся, как эти самые эллировые циклы искать алгоритм.
Да, и заодно как раз докажем, что мы там. Мы не доказали обратное следствие.
Помните, мы писали, что в одну сторону понятно, а в другую сторону докажем конструктивно.
Ну вот сейчас мы как раз предъявим алгоритм и покажем, что он корректно находит эллирово цикл.
Вот алгоритм, как бы странно это ни звучало, тоже будет использовать обход в глубину.
То есть мы за рамки обхода в глубину в принципе пока не выходим.
Идея такая, давайте возьмём какой-нибудь граф.
И запустим на нём обход DFS. В чём проблема? Если мы запустим обычный DFS,
то всё будет плохо. Почему? Потому что DFS в каждую вершину заходит ровно один раз.
А нас это как бы не очень устраивает, потому что в принципе эллиров цикл может в каждую вершину заходить по несколько раз.
Вот например здесь. Мы можем пройтись вот так, потом вот так, потом вот так.
Снова зайти в эту вершину и из неё достроить путь.
То есть это свойство DFS, что он заходит в каждую вершину ровно один раз, нас не устраивает.
Поэтому, давайте сделаем следующую вещь. Давайте забьём на то,
что у нас DFS заходит точнее так. Давайте уберём требования на DFS, чтобы он в каждую вершину заходил ровно один раз.
А что нас на самом деле интересует?
Нас на самом деле интересует обход графа, при котором он ходит каждое ребро ровно один раз.
То есть нам не нужно в каждую вершину заходить ровно один раз, нам нужно в каждое ребро заходить ровно один раз.
Ну а давайте DFS модифицируем таким образом, что он будет просто следить за
непосредственно посещенными ребрами, а не за посещенными вершинами.
Вот давайте напишу
DFS для поиска error цикла. Значит есть граф g.
Есть p.
Что такое p, потом объясню. Давайте запускаемся DFS на графе g
от вершины v.
Что мы делаем?
Что мы делаем?
Просто проходимся по всем ребрам, точнее по всем соседним вершинам v.
То есть по всем ребрам, которые торчат из v.
Что мы сделаем? Во-первых, мы скажем следующее.
Удалим ребро v.
Так как мы по каждому ребру хотим пройтись ровно один раз, то в тот момент, когда мы начинаем проходить по ребру v, мы это ребро удаляем.
Ну, от греха, чтобы потом его еще раз не пройти.
Удалили.
Ну а дальше просто запускаем рекурсивно
поиск error цикла на графе g от вершины u.
И здесь пишем вершину v. Вот эта вершина p, это что? Это
родитель, ну или предок
DFS.
То есть это та вершина, из которой мы вызвали DFS от этой вершины.
То есть мы вызвали DFS для вершины u, находясь в обходе для вершины v.
И DFS для вершины v мы вызывались находясь в вершине p.
Ну, по сути все, дальше в конце просто делаем следующую вещь.
Push front
ребро v. Нет, ребро pv.
P это родитель вершины v. То есть мы как-то с помощью нашего DFS гуляли, попали в вершину v. И вот в вершину v мы попали находясь из вершины p.
Точнее, в вершину v мы пришли по ребру pv. Вот так. Ну, то есть можно сказать, что pv это то ребро, по которому мы попали в вершину v.
Вот.
По большому счету все. То есть LRPAF, естественно, это изначально
пустой массив.
Пустой массив, а потом в начало просто добавляем ребра. Вот весь алгоритм.
Чуть-чуть модифицировали DFS. Понятно?
Асимптотика. Ну, с асимптотикой...
Ну, это на самом деле не интересно. То есть тут нельзя просто сказать, что асимптотика это просто
асимптотика DFS, потому что мы тут немного поменяли алгоритмы. Но в целом понятно, что по каждому ребру мы проходим все ровно один раз, поэтому от E.
Да?
Вот.
Вот E.
Ну, еще плюс V. Ну, давайте скажем, что
V это чтобы найти
компоненту связности,
содержащую
ребро.
Ну, что имеется ввиду? Вот ту картинку, которую я рисовал, да, вот, допустим, у вас есть какая-то компонент связности, вот, есть изолированные вершины.
То есть нельзя просто взять из произвольной вершины и запустить поезд LRW цикла. То есть вы обязательно должны стартовать вот этот
компонент связности. Ну, чтобы этот компонент связности найти, нужно потратить там V шагов. Ну, поэтому
такая асимптотика.
Давайте попробуем применить алгоритм, чтобы понять, как он работает.
Ну, 1, 2, 3, 4.
Ну, из какой вершины запустимся? Так, давайте сделаем граф неориентированным. Хотя этот алгоритм работает и для ориентированных, и для неориентированных графов.
Важно. Давайте запустимся от вершины 1.
Запускаемся от вершины 1. Ну, давайте, я тут порядок вызова DFS буду писать. Из вершины 1, допустим, идем в вершину 4.
Дальше. Удаляем ребро. Как только мы прошли по ребру, мы его удаляем.
Дальше. Из вершины 4, мы проходим, допустим, вершину, давайте, 3.
4, 3. Из вершины 3 проходим вершину 2.
Из вершины 2 проходим вершину 4.
Здесь не очень получилось. Ну ладно, из вершины 4 проходим вершину 0. Из вершины 0 проходим вершину 1.
Все, из вершины 1 никуда нельзя попасть, поэтому мы начинаем выписывать ответ.
Выписываем 0, 1.
Дальше откатываемся в вершину 0, из него нельзя никуда пройти, поэтому пишем
4, 0. Ну и так далее. То есть мы как раз в этом порядке и выпишем.
2, 4. 3, 2. 4, 3. 1, 4.
Что?
Во, да, давайте такой вариант разберем. Вот мне как раз такой вариант и нужен был.
Ну в таком варианте все понятно, да? Ну как бы мы прошлись как раз по эрилу циклу. Давайте теперь действительно разберем плохую ситуацию, когда мы
пошли не совсем по эллеровому циклу. То есть стартовались единицы.
Стартовались единицы. Дальше прошли в четверку, а из четверки прошли в ноль.
Из нуля прошли в единицу.
Из единицы идти некуда.
Все, выписываем ответ. Точнее, выписываем
ребро 0, 1. Потому что в единицу мы пришли через ноль.
Откатываемся в ноль. Из нуля снова нельзя никуда пойти, поэтому пишем 4, 0. Так, я тут...
Так, выписали 0, 1 и 4, 0.
Из нуля вышли, возвращаемся в четверку. Вот, а из четверки можем пройти куда хотите? В двойку, в тройку.
Вот, из четверки проходим в двойку. Из двойки проходим в тройку.
Из тройки в четверку.
Все, из четверки идти некуда.
Из четверки идти некуда, поэтому завершаем одни работы и выписываем ребро 3, 4.
Из тройки идти некуда, выписываем ребро 2, 3.
Ребро 4, 2 и 1, 4.
Ну вот, в порядке завершение.
Давайте проверять. 1, 4, 4, 2, 2, 3, 3, 4, 4, 0, 0, 1. Корректный эйвер в циклу.
Ну, естественно, вы мне на слово не поверите, что он работает всегда, поэтому давайте попробуем доказать, что
опять же, этот результат получился не случайно.
Доказательства проведем в три этапа.
Утверждение 1.
Алгоритм.
Утверждение 1.
Алгоритм.
Проходит
по всем ребрам
ровно один раз.
Ну это утверждение, я думаю, понятно, да? У нас все вершины достижимы.
И плюс при обходе каждой вершины мы проходимся по всем ее соседям.
Давайте без перерыва сегодня, окей?
Вот.
Доказательства.
Все
вершины
достижимы.
И у каждой
просматриваем
все инцидентные
ребра
по одному разу.
Ну почему по одному разу? Потому что как только мы прошлись по ребру, мы его тут же удаляем.
Следовательно, в следующий раз мы больше никогда по этому ребру не пройдемся.
Так, это утверждение понятно.
Дальше, более содержательное утверждение.
Заключается в следующем.
В момент
добавления
ребра в ответ
степени всех вершин
всех
вершин
четны.
В случае ориентированных графов в степени всех вершин
есть баланс.
Давайте для случая ориентированного графа я буду обсуждать.
Для ориентированного все аналогично, естественно.
Степени всех вершин четны.
То есть, что имеется в виду?
Вот в этой строке
степени всех вершин снова четны.
То есть, я запускаю
алгоритм, у меня у всех вершин степени
четны по теореме.
Понятное дело, что в процессе работы
у меня степень каких-то вершин
могут становиться нечетными.
Хотя бы в самый первый момент времени,
когда я просто беру
и прохожусь по первому ребру.
В этот момент я у стартовой вершины
и у этой вершины отнял по одной степени.
Поэтому в этот момент их степень нечетный.
Но вот утверждается, что как только я дошел
до этой строки, вот до последней,
все степени вершин снова четные.
Доказательство будет картинкой.
Вы не против?
Ну, смотрите, вот мы берем
какую-то вершину v
и запускаем поиск
скейлерового цикла из нее.
Что мы делаем?
Мы как-то идем, идем, заходим
повторно в какие-то вершины,
вот так.
То есть, в принципе, мы не запрещаем
себе заходить в некоторые вершины
по несколько раз.
И вот, допустим, мы будем
и вот, допустим, мы закончили
обход DFS в какой-то вершине u.
То есть,
пусть
мы закончили
в вершине
u, при этом
не совпадающей с v.
Что можно сказать про степень вершин?
Ну, понятно, что у всех
промежуточных вершин, вот здесь,
на этом пути, у них все
все степени четные.
Почему? Потому что мы в нее вошли и вышли,
вошли и вышли.
В вершины здесь.
Мы в нее один раз вошли, один раз вышли.
Вот эта вершина. Мы в нее два раза зашли
и два раза вышли.
Путь так просто на пусту устроен.
А есть ли здесь вершины, у которых
степень нечетная?
u и v.
u и v, да.
Меня на самом деле больше интересует вершина u.
Могло ли получиться так,
что я вошел
в вершину u, а выйти из нее не могу?
Цикл.
Почему?
Да, понятно.
Изначально в моем графе все вершины четные.
Точнее, все степени вершин четные.
Поэтому, если я в какую-то вершину попал,
то я из нее обязательно могу выйти.
То есть, если я закончил в вершине u,
которая не совпадает v,
то это значит,
что
это значит,
что
ее степень
нечетна.
То есть, если я в нее попал,
то если я в нее попал
и из нее не вышел,
то я отобрал у нее одно ребро.
То есть,
если у нее изначально была степень
четная, то я отобрал у нее одно ребро,
соответственно, у нее стала степень
нечетная. А если у нее степень нечетная,
то что это значит?
То есть, у нее есть хотя бы одно ребро,
которое мы еще не посетили.
Понятно это?
Это значит,
что степень нечетна,
Есть непосещенное ребро, исходящее из У.
Ну, противоречие. Согласны?
Вот мы и предположили. Пусть закончили вершине У, которое не совпадает с В.
Вот я просто показываю, что такого быть в принципе не может.
Значит, У равно В. Если я где-то и закончил, то только в стартовой вершине.
У из этого, собственно, следует в момент завершения степени всех вершин черный.
Вот, то есть я запустил мой обход из вершины В, как-то походил-походил, и завершился в В.
Выписал какое-то ребро. Дальше с помощью DFS откатился в какую-то вершину вот эту.
Снова из нее как-то походил-походил, и снова в нее вернулся.
Снова все степени вершин черные и так далее.
То есть в момент добавления каждого ребра у меня степени всех вершин оставались черными.
Вот и все. Понятно?
Какие вопросы есть? Все окей?
Что значит в момент завершения?
В момент завершения давайте обозначим. В момент завершения, в смысле в момент завершения вызова.
Давайте вот эту строчку обозначим звездочкой.
В момент завершения, то есть в момент звездочка в степени всех вершин черные.
То есть что это означает? Если вам больше некуда идти, то значит вы вернулись в начало.
Еще вопросы? Хорошо.
Ну и последнее утверждение.
Выписанные ребра образуют корректный путь.
Что это значит? Это значит, что если мы посмотрим на массив в любое время, то у вас будет следующая картина.
Здесь v, здесь p от v, здесь снова p от v, здесь p от p от v.
Последовательно выписанные вершины совпадают конечная. У того ребра, который стоит слева, конечная вершина совпадает с начальной вершиной следующего ребра.
Понятно, что это значит, что у нас путь корректный.
Пусть выписали ребро p, v и v.
Что это значит? Это значит, что мы закончили обработку вершины v и откатываемся по рекурсии dfs обратно.
А куда мы откатываемся? В p от v, да? Потому что p от v по определению родитель вершины v.
Откатываемся, ну или продолжаем запуск dfs от p от v.
А что мы знаем о запуске dfs от p от v? Вот в этот момент что я знаю? В этот момент все вершины, все степени всех вершин четные, да?
По утверждению 2, степени всех вершин четные.
А из этого что следует? Вот смотрите, я как-то походил-походил, закончил искать путь для вершины v и откатился в вершину p от v.
И в этот момент у меня в графе все вершины четные. Но согласитесь, что из p от v я куда-то пройдусь, да?
Ну, либо никуда не пройдусь. Ну давайте рассмотрим случай, когда я куда-то все-таки пройду. То есть из p от v есть какой-то путь.
Ну что тогда? Тогда по утверждению 2 я и закончу в вершине p от v.
То есть если я начал снова искать путь из вершины p от v, то и закончу я в этой же вершине p от v.
Следовательно, этот вызов завершится в вершине p от v.
А если этот вызов завершится в вершине p от v, то что это значит?
Да, то это значит, что как раз таки следующим ребром я выпишу ребро, которое будет заканчиваться в вершине p от v.
А в следующем будет выписано ребро p от p от v в.
Мне кажется, все. Ну то есть еще раз. В чем смысл данного утверждения?
Я запустил dfs от v, как-то гулял-гулял-гулял, и в ней же закончил. Это следует из утверждения 2.
Я в ней закончил. То есть когда я в ней закончил, я выписал ребро p от v.
Если я закончил с вершины v, то я должен откатиться в ее родителя. То есть я откатываюсь в родители p от v.
В этот момент для p от v я начинаю искать новое ребро, куда бы мне еще пройтись.
Если я не нашел никакого ребра, который торчит из p от v, то я просто его сразу выписываю. То есть все верно.
Просто выписываю ребро p от v, и тогда у меня конец этого ребра совпадает с началом предыдущего.
А если мне есть куда идти, то я из него выхожу и начинаю искать какой-то еще маленький цикл.
Ну и по утверждению 2 я обязательно закончу в той же вершине p от v.
Но раз я в ней закончу, то соответственно я как раз выпишу ребро, которое заканчивается вот в вершине p от v.
Ну и там теорема, корректность,
алгоритм,
корректно
находит
феверов
цикл.
Ну это просто-напросто следует из утверждения 1, 2 и 3.
Ну почему это следует из утверждения 1, 2 и 3? Ну на самом деле следует из утверждения 1 и 2.
Что там говорит утверждение 1? В утверждении 1 говорит, что все ребра будут выписаны.
Ну помните, да? Все ребра будут подсяжены, вследствие всех ребра будут выписаны.
А утверждение 3 говорит, что те ребра, которые я выписал, они будут образовывать корректный путь.
Ну все, если у меня есть все ребра и они образуют корректный путь,
ну следовательно, Элер в цикл найден.
Все.
Вопросы?
Что осталось непонятное?
Для доказательств утверждения 3.
Всё, можем идти дальше?
Отлично. Ну хорошо, с эйлеровым циклом закончили.
Давайте в качестве упражнения оставлю.
Есть такое понятие, как гамелитонов цикл.
Ну, это как эйлеров цикл, только он проходит по каждой вершине ровно один раз.
Ну и упражнения придумать алгоритм.
Нет, нет, только гамельдонов. Эйлеров отдельно.
Всё, давайте к следующей теме перейдём.
Следующая тема у нас
точки сочленения.
А следующая тема у нас
точки сочленения.
Точки сочленения.
Что такое точки сочленения?
Точки сочленения это в некотором смысле такие слабые места в графе.
Точка сочленения такая вершина графа, удаление которой приводит к разваливанию графа на несколько кусков.
Грубо говоря, при удалении точки сочленения у вас теряется связанность какой-то из компонентов.
Давайте определение.
Эта вершина
удаление которой
приводит
к увеличению
компонент связанности.
Ребра не могут идти
никуда.
Поэтому удаляется вершина и все инцидентные ей ребра.
Пример какой?
Тот же самый граф.
Вот эта точка сочленения.
Если я удаляю эту вершину, то у меня граф компонент связанности разваливается на две.
Вот это является точкой сочленения?
Нет, это не точка сочленения, потому что я ее удаляю и число компонентов связанности у меня никак не меняется.
Нет.
Вот такая ситуация.
Вот это является точкой сочленения?
У меня есть граф и изолированная вершина.
Нет, число компонентов связанности у меня уменьшилось, а должно было увеличиться.
Это не точка сочленения тоже.
Отлично.
Ну и как вы понимаете, задача состоит в том, чтобы посмотреть на граф
и найти в нем точку сочленения, то есть найти все эти слабые вершины.
У вас есть какая-то глобальная компьютерная сеть, вам нужно найти сервера или пункты, узлы,
уничтожение которых приведет к раку, к коллапсу.
Вот такие места, которые нужно усилить.
Так, давайте разбираться.
Давайте теорему сразу напишем.
Теорема, которая позволит искать точки сочленения в графе.
Пусть...
Важный момент.
Это я, конечно, плох.
Вершина удаления, которая к увлечению компонентов связанности.
Точки сочленения имеют смысл только для неориентированных графов.
В случае ориентированных графов, точки сочленения не играют никакой роли.
Пусть...
Неориентированный граф.
Говорить про точки сочленения в контексте ориентированных графов не имеет смысла.
Поэтому зафиксировали, граф у нас неориентированный.
Пусть запустили DFS.
Вот.
Со стартовой вершиной.
Р. Ну корень.
То есть взяли граф, выбрали какую-то вершину, запустили от нее DFS.
Вот утверждается следующее. В теореме два пункта.
Первый пункт такой.
Вершина U равная R.
Точка сочленения тогда и только тогда.
Вот как вы думаете, когда?
Какой-то граф.
Я запустил от него DFS. От вершины R.
Как-то обошел одну часть, обошел вторую часть, еще что-то обошел.
Вот в каком случае R будет являться точкой сочленения?
Ну не совсем.
Ну точнее так, если из вершины R мы нашли более одной белой вершины.
То есть понятно почему так.
Вот смотрите, мы запустили DFS от R и обошли какую-то компоненту здесь.
Вот нашли какую-то белую вершину, обошли здесь.
Потом, вернулись в эту же вершину и из нее нашли другую компоненту.
А потом еще одну.
Что это означает? Это значит, что из этой компоненты я не смог попасть в эту компоненту.
И из этой же компоненты я не смог попасть в эту компоненту.
Единственное, что связывает вот эту компоненту с остальными, это вершина R.
увеличению числа компонент связанности. Согласны? Вот поэтому вершина, то есть корень обхода DFS
является точкой сочинения тогда и только тогда, когда у r более одного сына
в дереве обходы в глубину.
Так, ну давайте сначала с чем докажем достаточность. Ну вот есть вершина r и вот у нее более одного сына. Что? Что еще раз? Да, потом. Сначала давайте сразу пункты и сразу доказательства, потом второй пункт.
Ну, собственно, я уже все проговорил, да? Если более одного сына, то вот 1, 2 и так далее k.
Но из этого следует из, из под дерева 1 не можем добраться в 2, 3 и так далее k.
Из этого следует, что r единственная вершина, которая их связывает. Все.
Ну и наоборот. Вот если r это точка сочинения, то что можно сказать? Ну, допустим, давайте так. Допустим, у r один сын.
Ну, то есть r образует только одно под дерево. Ну, точнее, картинка должна быть такой. Есть r, есть один сын, из которого торчит дерево.
Ну чего? Ну, тогда r не точка сочинения. Ну вот отсюда следует. Да? Вот я взял вершину r, запустил из нее DFS.
Соответственно, я нашел всю компоненту связанности, в которой лежит r. Ну, тогда граф у меня выглядит следующим образом.
Из r я могу добраться в какую-то вершину. Ну, хорошо, возможно, еще есть такие перебра.
Ну так или иначе, удаление r вообще ни на что не влияет. У меня как было вот это дерево, точнее под дерево, так оно и останется связанным.
Вот все. Противоречисла человек.
А, да, кстати, ну вообще можно понять так. Допустим, мы попали сначала в вершину 1. Вот. Если мы могли из вершины 1 по какому-то другому ребро добраться до вершины 2, точнее, до под дерева 2,
ну тогда мы бы его тоже обошли. Просто по лемме о белых путях. Вот. Но можно сказать все умнее. То есть мы вроде говорили, что на семинарах мы обсудим следующую вещь, что в неорграфах
нет прямых и перекрестных ребер.
Следовательно, если вы построите дерево обхода DFS для неориентированного графа, то у вас ребра могут идти только вот так.
Но при этом между компонентами ребер быть не может. То есть перекрестных ребер быть не может для неориентированных графов.
Второй пункт. Ну, что? Вершина U не равна R. Точка сочленения тогда и только тогда.
Тогда что? Когда U существует потомок V, даже не потомок, а давайте сын напишем.
Ну, сын в смысле обхода в глубину, естественно. Существует сын V такой, что из V нельзя попасть в предка U,
двигаясь только по ребрам дерева и обратно.
Ну, что это значит? Давайте в одну сторону. Давайте смысл второй части поясню. Вот у вас есть вершина U, и у нее есть сын V.
Не смущайте, что я пишу стрелки. Я считаю, что у меня граф по-прежнему не ориентирован.
Просто я пишу стрелки сверху вниз, я рисую ребра дерева, а снизу вверх это обратные ребра.
Ну и, соответственно, у U есть какой-то предок. Там есть какое-то поддерево, которое ведет в U.
Ну, смотрите, если я из V, то есть что у меня есть V? Из V у меня торчит какой-то свой подграф.
Представьте, что из V, из этой вообще компоненты, я вообще никак не могу подняться выше U.
У меня есть вершина U, есть поддерево, которое торчит из ее сына V.
Представьте, что отсюда я вообще никак не могу подняться на высоту ни в какого предка вершина U.
Загласны ли вы, что тогда у меня U является точкой сочленения?
Вот такие ребра у меня могут быть, а вот таких быть не может.
Тогда понятно, что если я удалю вершину U, то тогда у меня вот этот компонент отвалится.
Вот, собственно, второй пункт как раз об этом.
Пусть U точка сочленения. Пусть для любого сына V, из любого сына V можно попасть в предка U.
Что это значит? Вот есть вершина U, и у нее есть куча детей.
Из каждого из них можно попасть в какую-то компоненту.
Тогда что получается? Получаются у меня предки вершины U связаны со всеми потомками вершины U.
Значит, U не является точкой сочленения, потому что U связывает предков и своих детей.
Если я удаляю вершину U, то дети и предки остаются связаны.
Ну все, U тогда не является точкой сочленения, у меня ничего не разваливается.
У меня нет точек сочленения.
Ну или вот эта картинка. Если у меня есть хотя бы одно ребро, то удаление вершины U ни к чему плохому мне не приводит.
У меня есть предки, у меня есть мой сын.
Поэтому предки и сын связаны, а больше ничего другого U не связывает.
Здесь обратное.
Обратное. Что у нас? Пусть у U существует сын.
Ну действительно, пусть у вершины U есть потомок. Ну, собственно, все уже нарисовано на самом деле.
Есть U, есть некоторый сын V.
Если из V нельзя добраться в предков вершины U, то что это значит?
Это значит, что V и предки U связаны только посредством вершины U.
Ну и все из этого следует. U разделяет V и V.
То есть в таком графе они связаны, то есть V от U и V.
А если я вершину U удалю, то так как из V я ни в какого предка не могу попасть,
ну двигаясь вот по этим ребрам и по обратным ребрам, то все плохо.
Все понятно?
Ну, собственно, теорема как раз дает нам некоторый алгоритм, ну, точнее как дает,
дает нам некоторую идею алгоритма, как можно находить точки сочленения.
То есть что мы делаем? Мы берем произвольную вершину, запускаем от нее DFS.
И дальше смотрим. Вот если вершина корень, то считаем ее количеством детей.
Если вершина не корень, то есть та вершина, которую мы посетили, не является корнем,
то смотрим, существуют ли у нее дети, из которых нельзя попасть в предков.
Вот и все. Причем заметьте, что пункты 2 и 1, они не пересекаются.
То есть нельзя применять корню пункт 2.
И к вершине, которая не является корнем, пункт 1 тоже нельзя применять.
Окей. Контрпримеры привести или? Понятно. Что? Верим. Окей, хорошо.
Вот. Но на самом деле остается непонятным что.
Ну, для корня все очевидно. Ну, посчитали количество его детей и окей.
Точнее, непосредственных детей.
Для пункта 2 непонятно, как проверять для каждой вершины, верно ли что из предка,
точнее верно ли что и сына нельзя попасть в предка.
Ну, кажется, звучит как что-то сложное.
Ну, давайте попробуем разобраться, как можно это все распутать.
Давайте нарисую какой-нибудь граф.
Точнее, давайте я сразу нарисую некоторые дерева обхода в глубину.
Вот так.
Пусть это вершина 0, 1.
Вершина 0, это 1, это 2, пусть это 3, 4, 5, 6.
Вот. Допустим, так выглядит дерево обхода в глубину.
Ну, в смысле, я нарисовал сейчас ребра дерева.
Как мы обозначали обратные ребра?
Красным цветом, не помните?
Ну, ладно. Вот так. И вот так.
Это обратные.
Ну, пусть красным будет, у меня обратные ребра.
Ну, пусть красным будет, у меня обратные ребра.
То есть вот я обошел мой граф с помощью обхода в глубину,
черным цветом я нарисовал ребра дерева, красным цветом обратные ребра.
То есть у меня граф не ориентированный по-прежнему.
Я просто нарисовал направление обхода.
Так, а помните, на самом первом лекции с DFS мы там что-то подсчитывали, какую-то дополнительную информацию?
В качестве одной из такой информации было время захода.
То есть время, когда мы впервые посетили вершину.
Вот сейчас эта информация нам пригодится.
Давайте для каждой вершины напишем время ее посещения.
Ну, стартовали мы с вершины 0, поэтому мы посетили ее в момент времени 0.
Дальше, допустим, мы спустили с вершины 2.
Время посещения это 1.
Дальше вернулись в вершину 0 и, допустим, пошли в вершину 5.
Значит, здесь момент посещения 2.
Вершина 3, момент посещения 3.
Дальше пошли в вершину 1.
4, здесь 5, здесь 6.
Все, посчитали время захода.
То есть время первого посещения данной вершины.
А теперь смотрите.
Идея такая.
Давайте посмотрим произвольный путь.
Путь по ребрам дерева, сверху вниз.
Заметьте, что время захода вдоль каждого пути только возрастает.
Но оно и понятно, потому что если какая-то вершина является потомком другой вершины,
то время ее захода позже.
Потому что в процессе обхода этой вершины я обнаружил своего потомка.
То есть потомка я обнаружил позже, чем предка.
Поэтому, соответственно, время захода больше, чем время захода для предка.
То есть время захода на пути от предка к потомкам возрастает.
А это значит, что time in можно использовать как меру глубины.
Условно глубины.
Давайте в кавычки возьмем.
Грубо говоря, чем больше у меня time in, тем глубже у меня находится вершина.
Понятное дело, что не имеет смысла сравнить, например, вершину 4 и вершину 5.
То есть какая из них глубже.
Имеет смысл только сравнить вершины, которые находятся вдоль одного пути.
Но тем не менее, вдоль одного пути я могу говорить, что чем глубже у меня вершина, тем больше у нее там in.
Давайте я заведу еще одну характеристику и назову ее time up.
Time up от вершины v.
Это глубина, глубина в смысле time in,
на которую можно подняться, двигаясь только по ребрам дерева
и одному обратному вибру.
То есть, грубо говоря, time up говорит, насколько высоко вы можете запрыгнуть.
Допустим, из вершины 3 вы можете сразу прыгнуть,
или вы можете как-то оттолкнуться, спуститься вниз и потом резко выпрыгнуть на один шаг вперед.
То есть time up, насколько высоко вы можете выпрыгнуть.
Давайте просто для каждой вершины посчитаем через черту.
Для вершины 0 насколько высоко я могу подняться?
Только в нее же саму, поэтому 0.
Из вершины 2 как высоко я могу подняться?
Ну снова, только в нее саму.
Выше в нее я подняться не могу, поэтому 2.
Так, не 2, а 1, потому что у нее time in 1.
Смотрите, глубина, на которую можно подняться, двигаясь только по ребрам дерева и одному обратному вибру.
У нее есть ребра дерева?
Нет, из нее не торчит ребра дерева.
Обратное вибро торчит, поэтому я могу остаться только в ней, то есть 1.
Ну 1 это time in ее.
То есть глубина задается у меня time in.
1, 1.
И с пятерки.
Вот с пятеркой поинтереснее.
Могу в 0, согласны?
Смотрите, из пятерки я могу сначала оттолкнуться, то есть пойти в тройку,
а потом резко подняться в 0 по обратному ребру.
Поэтому 0.
Для тройки.
Для тройки я могу сразу прыгнуть в 0.
Поэтому 0.
Ну 0 в смысле time in, вот этот.
Я сюда смотрю.
Вот.
То есть я смотрю не на номер вершины, а на time in, потому что time in мне задает глубину.
Для четверки.
Да, и с четверки тоже могу подняться только в 0.
И с четверки.
Тут была единица, тут четверка.
Могу остаться только в ней.
То есть шестерка.
Шестерка.
Давайте, чтобы никому не смущать, напишу 1.
Тут 0, окей?
Чтобы вы отличали номер вершины и time in.
Пример понятен?
Все.
Ну а теперь.
Все, самый главный пункт на сегодня.
Второй пункт.
Теоремы.
Эквивалентен следующему.
Time up от v.
Связан с time in от u как?
Из вершины v нельзя попасть в предка.
То есть что это значит?
Это значит, что глубина, на которую я могу подняться из вершины v,
она больше либо равна, чем time in от u.
Согласны?
u это вершина, v это сын, вершина u.
То есть так как из сына u, то есть из вершины v, я не могу подняться выше, чем вершина u,
то это значит, что у нее time up больше, чем time in.
То есть она находится ниже, чем вершина u.
Понятно?
Нет, все нормально.
Из v нельзя попасть в предка u означает, что time up от v.
Давайте я нарисую, чтобы было понятней.
В терминах глубины так, мне кажется, будет проще осознать.
От u.
От v.
Вот так понятней, да?
То есть вершина u находится выше, чем то место, куда я могу подняться из вершины v.
Давайте по этому критерию попробуем в данном графе понять, где у меня точки сочленения.
Является ли вершина 1 точкой сочленения?
Вот таким критерием в вершине 1 нельзя пользоваться. Почему?
Потому что это корень, для корня отдельный критерий.
Вершина 1 является точкой сочленения?
Да, у нее больше, чем один сын.
Поэтому, давайте, звездочка, это точка сочленения.
Проверим для пятерки.
Смотрим, у нее time in 2, и с тройки можно подняться в ноль.
То есть time up у ее сына меньше, чем у нее time in.
То есть 2 больше, чем ноль.
Поэтому это не точка сочленения.
Time in от u это 2, time up от v это ноль.
Вот это неравенство не выполнено.
Все, это не точка сочленения.
Тройка у нее вообще нет сыновей, поэтому она не может в принципе являться точкой сочленения.
Так, эта вершина тоже у нее нет сыновей, она не является...
В общем, тут ничего не пишите, она не является точкой сочленения.
Эта вершина, по тем же самым причинам, не является точкой сочленения.
Шестерка не является точкой сочленения.
Вот ноль, давайте проверим ноль.
Является ли ноль точкой сочленения?
Она является точкой сочленения почему?
Потому что у нее существует сын, вот этот вот гаденыш,
у которого time up 6, и он больше либо равен, чем time in у этой вершины, то есть 4.
Да, существует, существует достаточно одного.
То есть здесь 4 меньше либо равно, чем 6.
Поэтому ноль это точка сочленения.
Ну и мы не успели выписать алгоритм,
на самом деле алгоритм заключается просто в одном обходе в глубину.
Давайте я просто выпишу формулу, по которой можно посчитать time up.
Ну а алгоритм разберете на семинарах, ну и в следующий раз лекцию начнем с этого.
Time up от v посчитать очень легко прямо во время обхода dfs.
То есть если вы думаете, что time up это что-то сложное, нет,
его очень просто посчитать прямо во время обхода в глубину,
ровно так же как и time in и time out.
Это просто минимум из следующих величин.
Ну, во-первых, зададимся таким вопросом,
как высоко я могу подняться из вершины v?
Я могу никуда не двигаться, могу остаться сам в себе.
Я могу никуда не двигаться.
Поэтому time in от v.
То есть это у меня никто не отберет.
Дальше.
Меньше и минимум из time in от...
Давайте back напишу.
Где vback это обратное ребро.
Ну понятно, как еще можно подняться наверх?
Можно просто взять, подпрыгнуть и подняться в предках с помощью обратного ребра.
Да?
То есть что мы делаем?
Мы сначала инициализируем time up от v с помощью time in от v,
дальше запускаем обход в глубину,
только мы встречаем обратное ребро, мы обновляем наш time up.
То есть берем минимум.
Ну и последний.
Как еще можно подняться по жизни?
Можно посмотреть в time up детей.
То есть если вы сами не можете прыгнуть,
то можете воспользоваться связями и спросить,
а вы там можете подняться?
Если вы можете, то и я могу.
Time up от 3, где v.
3 это ребро дерева.
Ну то есть для вершины v я могу остаться на том же уровне,
могу подняться с помощью обратного ребра,
могу спуститься в ребёнка и подняться из него.
Вот три возможных способа обновить time up.
То есть обратные ребра мы умеем определять во время обход DFS?
Умеем.
Рёбра дерева мы умеем определять во время обход DFS?
Умеем.
Соответственно time up от v тоже умеем вычислять во время обход DFS.
