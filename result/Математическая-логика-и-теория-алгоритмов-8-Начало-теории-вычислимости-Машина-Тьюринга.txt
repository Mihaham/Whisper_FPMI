Сегодня поговорим про модели вычислений.
Мы начинаем новую большую часть курса о теории вычислимости,
которая оправдывает слова о теориях алгоритмов в названии курса.
Сначала поговорим про то, что вообще такое алгоритм, что такое вычисление.
Что такое алгоритм?
Тут есть два подхода к ответу на этот вопрос.
Один подход стоит в том, что мы понимаем, что такое алгоритм.
Это такое же неопределимое понятие, как множество, точка и другие понятия в математике.
Мы не можем дать прямоопределение, а можем дать только некоторое пояснение.
Такое словарное определение, а не математическое.
Второй подход стоит в том, что мы вводим некоторую формальную систему,
которая как раз некоторые формальные определения не дает,
которая в каком-то смысле ловит какие-то ключевые вещи в неформальном понятии.
Если мы говорим неформально, то что такое алгоритм?
Это некоторая инструкция или процедура.
Это инструкция по решению некоторой задачи.
Соответственно, у алгоритма есть вход, то есть условия задачи.
И выход. То есть то или иное решение.
При этом и вход, и выход, и сам алгоритм как инструкция могут быть описаны некоторыми конечными строками.
Вход, и выход, и сам алгоритм описываются конечными строками.
Ну или как вариант можно считать, что натуральными числами это стандартный подход,
что можно смотреть на все эти конструктивные объекты, как на строки, может как на числа.
Смотрите, исторически первый подход это смотреть как на числа, потому что это все шло из формальной арифметики, теории Гёдали и так далее.
Но более современный подход это смотреть как на строки из нулей единиц, потому что мы привыкли, что в компьютерной памяти все записывается битами, нольками, единичками,
и любые данные можно так закодировать.
Но конечно строки и числа можно взаимно однозначно друг другу декодировать, поэтому это не очень важно.
Что еще важно? Еще важно, что любой алгоритм выполняется пошагово, то есть там время дискретно, любой алгоритм выполняется пошагово.
В каждый момент есть некоторая конфигурация, которая также описывает с конечной строкой,
и соответственно от текущей конфигурации к следующей переход происходит при помощи вот этой самой инструкции.
В каждый момент, ну нельзя сказать, что там алгоритмы находятся, но исполнение алгоритма находится в некоторой конфигурации.
В каждый момент исполнения алгоритма задана некоторая конфигурация,
ну и соответственно переход от данной конфигурации к следующей,
переход от данной конфигурации к следующей происходит в соответствии с инструкцией.
Ну в общем более-менее это вот такое рамочное описание, любая конкретная модель этому всему соответствует.
То есть есть преобразование входа в выход, да, еще важно отметить, что тут в принципе входов, тут бесконечное число,
а при этом сама инструкция конечная. Если входов в конечное число, то это не очень интересно,
тогда более-менее любую функцию можно описать просто таблично, но если входов в бесконечное число,
а описание конечное, то вот это уже получается что-то интересное.
Ну вот, значит есть преобразование входа в выход с конечным описанием,
и вот это описание применяется как инструкция по переходу от одной конфигурации к следующей,
и соответственно в результате конечного числа таких переходов возникает ответ.
Вот, хорошо, значит это вот общее рамочное определение, которое годится и для всех моделей,
и для реальных вычислительных устройств.
Вот, значит существует, да, значит в принципе существенную часть теории можно изучать
и вот в такой общности, то есть без конкретизации, в общем, многие вещи можно объяснить
просто из каких-то общих соображений, либо вообще без конкретизации,
либо имея в виду какой-то там обычный язык программирования.
Вот, хорошо, ну а тем не менее на этой лекции я хотел бы рассказать про некоторые конкретные модели,
ну а именно мы в основном будем работать с машиной Тьюринга,
которая в общем-то исторически была самой первой прям такой математической моделью,
ну и она до сих пор остается сравнительно популярным подходом.
Значит, особенно хороша машина Тьюринга для теории сложности вычислений,
когда нас интересует число использованных ресурсов.
Вообще бывают и другие модели, например, рам-машина со случайным доступом к памяти,
еще там разного рода машины с регистрами, где можно хранить целом натуральное число в некотором регистре.
Разные другие подходы, но вот машина Тьюринга довольно хорошо сбалансирована,
с одной стороны она достаточно простая сама по себе, с другой стороны с ней довольно удобно работать.
Поэтому, значит, мы с ней будем работать.
Так, значит, пока что я давайте на этом слайде нарисую неформально, что это такое.
Значит, имеется вот лента, которая разбита на ячейке.
И в каждой ячейке находится какой-то символ.
Например, может быть, AB, C, AC, AB, что-нибудь такое.
И, например, есть еще управляющий блок, который находится в каком-то состоянии Q
и указывает на какую-то ячейку.
Соответственно, здесь есть память, эта лента разбита на ячейке, причем эта лента бесконечная.
Можно говорить, что она прям бесконечная, можно говорить, что потенциально бесконечная.
Потенциально бесконечная, это означает, что если мы дошли до края,
то можно подклеить еще кусочек и работать на этом новом кусочке.
Вот, значит, есть что-то типа процессора, то есть управляющий блок,
который может находиться в одном из конечного числа состояний.
Ну и, соответственно, в каждый момент машина указывает на только одну ячейку.
И у машины есть программа, которой команда вот такого вида.
Например, Q, C переходят в S, A, E, R.
Значит, если вот такая команда, то это означает, что...
Давайте каким-то другим цветом покажу, что будет происходить на следующем этапе.
Это означает, что вместо Q...
Давайте я так отдельно нарисую.
Значит, вместо Q машина оказывается в состоянии S.
Значит, дальше вот эта вот C она заменяет на A.
И сама сдвигается направо, то есть указывает вот на клетку прогрения.
А после этого ей нужно искать следующую команду, там S.
Значит, дальше будет какая-нибудь другая команда, S, A.
Например, будет снова Q, а тут будет B, и тут будет R.
Да, R большое, значит, направо.
Там еще бывает L налево или N на месте, то есть нейтрально.
Ну, значит, там либо один из двух, либо один из трех, но третий, в смысле, на месте.
Да, на одну клетку направо.
Тут, смотрите, тут нет того, что называется произвольный доступ,
и что как раз активно используется в настоящих компьютерах.
Призвольный доступ означает, что машина может получить адрес ячейки и, соответственно, пройти по этому адресу.
Считать данные, расположенные по этому адресу.
Тут такого нету.
Тут, чтобы куда-то дойти, нужно делать по одному шагу, пока не дойдем до того места, куда нужно прийти.
Но, тем не менее, рано или поздно дойти можно.
Можно все это как-то взять и посчитать.
Так, хорошо.
Ну, теперь давайте я покажу, что такое формально.
Так, формальное определение машины тюринга.
Во-первых, определение немножко зависит от того, для какой задачи мы это используем.
Например, пусть у нас задача то, что называется распознавание или разрешение языка.
Задача распознавания языка.
То есть ответ да или нет.
Здесь получается, что вход некоторый х, а выход это один, если х принадлежит а, и ноль, если х не принадлежит а.
Тут важно, что ответ это один или ноль.
Получается, что есть всего два варианта, и можно эти варианты прямо записать в состояние.
Еще вопрос, откуда это а.
Давайте считать, что у нас есть какой-то алфавит, сигма.
Например, сигма может быть из нуля единицы, может быть какой-то другой алфавит.
И, соответственно, вот это вот а, это под множество всех слов в этом алфавите.
А тут, соответственно, х тоже в том же самом алфавите записан.
Хорошо, начну тогда. Машина тюринга.
Машина тюринга это кортеж.
Кортеж из большого количества разных вещей.
Во-первых, тут есть сигма, и это сигма то же самое, что вот этот.
Сигма, гамма, q, дальше q0, qa, qr и дельта.
Сейчас расскажу, что все это такое.
Сигма мы уже изучили. Сигма называется входной алфавит.
Сигма это входной алфавит.
То есть символами этого алфавита записывают все, что на вход подается.
В нем, соответственно, записан вход алгоритма.
Дальше гамма. Гамма это ленточный алфавит.
Тут есть лента, но тут как минимум есть такие пустые ячейки.
И вообще, раз лента бесконечная, там должна быть только конечная информация.
Соответственно, все, кроме ограниченной части, должно быть занято пустотой.
Ну и проще всего считать, что это такой специальный символ.
Он называется бланк или правильный символ, которым и занята вся лента, кроме конечного числа ячей, где-то, собственно, какая-то информация.
Ленточный алфавит, соответственно, предполагается, что он включает в себя сигма, но при этом строго включает в себя.
Например, есть специальный символ бланк. Он, например, вот так обозначается.
Но эта решетка, это похоже на пустую клетку. Это мотивируется такое обозначение.
А бывает по-другому. Может быть там буква Б какая-нибудь специальная, может быть там какое-нибудь подчеркивание.
Разно есть обозначения. Соответственно, вот этот бланк будет лежать в гамма без сигма, но, возможно, там какие-то другие еще есть.
То есть тут не ограничивается. Вот эти могут быть какие-то другие вспомогательные символы.
Ну, например, можно считать, что там буквы разного цвета, что мы как-то там помечаем.
Или там буквы со звездочкой, какие-то пометки мы делаем. Или просто какие-то совсем новые символы, зачем-то нужные.
Это скорее для удобства. То есть, в принципе, можно считать, что сигма это 0 и 1, а гамма это 0 и 1 и пробел.
Да.
Нет, лямбда это пустое слово обычно обозначает. Пустосил? Нет, я сказал, есть там буква Б, есть просто подчеркивание.
А вот лямбда или епсилон это пустое слово.
Вот, дальше Q. Q это множество состояний, просто какое-то конечное множество.
Q это множество внутренних состояний.
Значит, множество внутренних состояний, но обязательно конечное. Собственная алфавита тоже обязательно конечная.
Вот, значит, теперь Q0, Qa и Qr.
Сейчас давайте-ка, знаете что, я лучше сделаю это не Q0, а Q1. Так удобнее.
Значит, пусть это будет Q1.
Вот, а Q0-то будет другое состояние.
Так, хорошо. Значит, Q1, Qa, Qr это просто элементы Q. Различные.
Значит, Q1, Qa, Qr это элементы Q.
Конечно, Q1 это начальное состояние.
Значит, Qa это принимающее состояние.
И Qr это отвергающее состояние.
Ну, то есть, иными словами, A это accept, R это reject.
Соответственно, вот эти вот принимающие отвергающее состояние завершают работы машины и, собственно, дают ответ.
Значит, получается, что они дают ответ.
Ну, и еще бывает вариант. Другой вариант, что есть одно завершающее состояние, а ответ каким-то образом берется с ленты.
Другим цветом напишу. Другой вариант.
Другой вариант. То есть, одно завершающее состояние Q0.
Ну и, соответственно, ответ записывается на ленте.
Значит, ответ записывается на ленте.
Ну и дельта. Дельта самая интересная. Дельта это функция перехода.
Дельта функции перехода.
Соответственно, она отображает, читайте так, Q без Qa и Qr.
На, соответственно, леночный алфавит гамма, и тут, соответственно, Q на гамма и на сдвиг.
Налево, на месте или направо.
То есть, получается, что функция перехода получает состояние, но не конечное состояние.
Если конечное состояние, то уже дальше никаких изменений не происходит.
Значит, дельта получает состояние, получает символ.
И дальше, соответственно, возвращает тоже еще одно состояние, еще один символ.
И один из трех сдвигов. Налево, на месте или направо.
Ну вот, также дельту могут называть программой машины тюринга.
Ну а тогда, соответственно, отдельные значения этой дельты называть командами.
Вот. Хорошо.
Ну дальше, как устроена работа машины тюринга.
Дальше, соответственно, в начальный момент вычисления.
Начальный момент вычисления.
Значит, на ленте записан вход X.
Вот, соответственно, машина находится в состоянии Q1 и указывает на первый бит X.
Ну и тут нужна оговорка, что вообще-то вход может быть даже и пустой.
Да, пустая строка это тоже возможный вход, тогда у нее нет первого бита.
Ну тогда просто вся лента на входе пустая, ну и машина там куда-то указывает.
Вот. Ну, после этого происходят перемены в соответствии с программой.
На каждом шаге машина заменяет символ, на который указывает.
На который указывает в соответствии с программой.
Значит, она заменяет символ в соответствии с программой.
Вот.
Меняет состояние, переходит в новое состояние и сдвигается.
И все эти три вещи в соответствии с программой.
В соответствии с тем, в каком машине было состояние и на какой символ она указывала.
Ну и в итоге, если машина приходит в завершающее состояние,
если машина приходит в QA или QR, то вычисление завершается.
Значит, вычисление завершается с соответствующим ответом.
Но очень важно, что может быть и бесконечное вычисление.
То есть может машина никуда не прийти, никогда не остановиться.
Значит, может быть и бесконечное вычисление.
Причем бесконечное вычисление может быть по самым разным причинам.
Может быть, потому что машина зациклилась.
Например, из-за зацикливания, но не только.
Ну понятно, что такое бесконечный цикл, я думаю, все более-менее понимают.
Например, если машина будет бесконечно инкрементировать клейный счетчик,
если такой идеальный счетчик, который без ограничения на память,
то это будет бесконечный процесс, не зацикливающийся, но бесконечный.
Но могут быть и еще какие-нибудь даже более сложные вещи,
например, связанные с какой-нибудь математикой.
Например, никто не знает, есть ли нечетное совершенное число.
Знаете про совершенные числа?
Совершенные числа это такие числа, которые равны сумме всех своих делителей, кроме самого себя.
Есть число 6, у него делители 3, 2 и 1.
Есть число 28, это 4 плюс 7 плюс 4 плюс 2 плюс 1.
Следующие уже 496.
В общем, этих чисел известно какое-то конечное количество,
не известно их всего конечное количество или бесконечное количество,
и также не известно ни одного нечетного совершенного числа.
Неизвестно нечетного совершенного числа, но также нет теоремы о том, что его нет.
В общем, это открытый вопрос.
Но смотрите, можно писать программу, которая будет идти по всем нечетным числам,
раскладывать их на простые множители, искать все делители и проверять, будут они совершенными или нет.
Например, если aye найдет совершенно нечетное число, то оно остановится.
Но тогда получается, что мы вообще не знаем, остановится такая программа или нет.
Если она остановится, значит нечетное совершенно число есть, если не остановится, значит нету.
Но также ясно, что если оно не остановится, то не то, чтобы там был какой-то регулярный процесс.
Ну, он, конечно, в каком-то смысле регулярный, но не то, что там все повторяется,
а там какие-то сложные вещи с разложением на множество и так далее.
Поэтому вывод, который я хочу сейчас сделать, что вопрос об установке важен,
и также важен не только внутри теории вычислений, но и вообще во всей математике.
Так, ладно, сейчас сделаем перерыв, потом немножко еще поговорим формально,
что все это вот значит, что такое вычисление.
Давайте продолжим. Да, перерывы задавали разные вопросы.
На самом деле эта проблема установки – это очень интригующая вещь.
С одной стороны, она связана со многими такими открытыми вопросами.
Если вообще какая-то задача стоит в том, что нужно найти пример или контрпример чего-нибудь
про конечные объекты, типа числа, графы и так далее, то тогда, конечно, можно написать программу,
которая будет перебирать все такие объекты и пытаться найти пример или контрпример.
И, соответственно, исходный вопрос будет эквивалентен тому, остановится эта программа или нет.
И таких задач очень много на самом деле.
Ну, соответственно, возникает вопрос, а нельзя ли научиться решать проблемы остановки
и с помощью нее решить все остальные проблемы.
Но вот нет, к сожалению, так не получается, и мы это, собственно, изучим.
Мы прямо изучим, что нет. По крайней мере алгоритмически сама по себе проблема остановки неразрешима.
То есть нельзя написать программу, которая будет получать текст другой программы
и вход этой другой программы, и, соответственно, говорить, остановится эта программа на этом входе или нет.
Это вот ключевой результат, который мы подойдем, наверное, через пару лекций.
И более того, можно и ряд более конкретных задач, уже не связанных с машинами тюринга
и с программами, а связанных с группами или многочленами или чем-нибудь еще,
много таких задач, для многих задач можно показать, что они тоже неразрешимы,
иначе можно было бы проблемы остановки разрешить.
Но тот, наверное, самый известный пример – это диафантовое уравнение.
Это была проблема Гильберта, только я не помню, какая по номеру.
Проблема была такая, дана система диафантовых уравнений,
то есть алгебридических уравнений с целыми коэффициентами.
И вопрос стоит в том, есть ли у этой системы уравнений целочистое решение.
И оказывается, что если там хотя бы квадратичные уравнения будут,
то эта задача неразрешима алгебридически.
Вообще Гильберт не так ее ставил.
Гильберт ставил задачу, что надо научиться решать,
что дана система диафантовых уравнений, надо научиться решать,
находить все решения или понимать, что их нет.
Но оказалось, это Матисеевич доказал, когда-то в 60-х или 70-х годах.
Матисеевич доказал, что нельзя так вообще сделать,
что это алгоритмически неразрешимая задача,
и не может быть алгоритм, который будет искать все решения.
Ну и вот есть ряд других задач в разных конкретных предметных областях.
До этого я уже не знаю, дойдем мы или нет.
Так, хорошо, теперь немножко подробнее про механику работы машины тьюринга.
Смотрите, из чего стоит вообще конфигурация.
Конфигурация машины тьюринга.
Это содержимые ленты,
плюс внутреннее состояние и плюс положение указателя.
При этом вообще у нас лента бесконечная, но там только конечное число непробельных символов,
поэтому все это вместе будет конечным объектом.
Да, в принципе, конечно, указатель может быть и на пустом символе,
который как бы за пределами этой части, но все равно мы добавим пустую часть.
Так, хорошо, получается, есть лента, есть какая-то ячейка, есть какой-то символ.
На эту ячейку указывает головка, она находится в состоянии Q.
Ну и есть какое-то слово A и какое-то слово B.
Значит, A слева от выделенной ячейки, B справа от выделенной ячейки.
Кстати, я вот тут вот раньше, знаете, я на несколько слайдов назад это иду.
Давайте я напишу, чтобы мы различали, что Q не пересекается с гамма.
То есть про каждый символ мы понимаем, то ли это символ ленточного алфавита, то ли это состояние.
Тогда мы их можем подряд записывать и понимать, что где.
Соответственно, вот такую вот конфигурацию мы кодируем строкой AQAB.
Ну теперь, в зависимости от команд машины, можно просто описать, как будет меняться конфигурация.
Да, вот это вот однозначно расшифровывается, ровно потому, что состояние и символ – это разные объекты.
Поэтому, если есть строка, в которой ровно один символ состояния, все остальные символы из леночного алфавита,
то эта строка однозначно декодируется в такую конфигурацию.
Так, изменения конфигурации при разных командах.
Ну значит, смотрите, самое простое – это когда у нас команда QA переходит в S, B и на месте.
Вот такая вот команда. Это я так записываю.
Можно написать, что функция дельта от значений Q и A равняется тройке S, B и N.
Коротко можно вот так через стрелочку написать.
Значит, тогда будет просто QAB переходит в ASBB.
То есть тут, соответственно, префикс и суффикс никак не меняются, меняется только то, куда мы указываем.
Ну хорошо, пусть сдвиг направо.
Например, R, C и R.
Новое состояние R, новый символ C и сдвиг направо.
Ну тогда тут есть разные варианты в зависимости от того, B пустой или не пустой.
Значит, если B не пустое, то у него там есть какой-то первый символ.
Например, AQABB', значит, переходит в ACRBB'.
Ну это похоже на то, что я в самом начале рисовал. У меня A заменилось на C, но при этом указатель сдвинулся на B.
Поэтому это C записано как-то слева от состояния, потом состояние, потом B, которое подним.
А если B пустое, то тогда вот так вот просто.
Ну на самом деле, можно считать, что не пустое, а там есть пустой символ пробеленный.
Тогда будет ACRBB'.
Ну и аналогично, если тут какое-нибудь состояние T, D и L,
то тут, аналогично, если A не пустое, то тут будет какой-то A',
значит, A'Z, тут будет QAB, значит, это превращается в A'TZDB.
Ну я тут считаю, что кое расстоит от состояния, все остальное это символы.
Значит, что здесь произошло? Здесь A заменилось на D, вот оно здесь D,
но потом мы сдвинулись налево, поэтому теперь на Z указываем, и еще перешли в состояние T.
Значит, поэтому вот так вот. Ну а если A было пустым, то просто QAB переходит в T'DB.
Ну вот, соответственно, получаются вот такие строковые операции. То есть то, что делает машина тюринга,
это вот такая вот, в общем-то не сложная строковая операция, довольно локальные замены одних символов на других,
может быть, транспозиция небольшая. Это тоже очень важная концепция, что на самом деле вычисления происходят локально.
В каждый конкретный момент изменения, это и про обычные компьютеры, верно?
В каждый конкретный момент изменения происходят в какой-то небольшой части.
Но все в целом так организовано, что возникает какое-то вот такое сложное вычисление.
Да, может быть, то, что называется там многоядерный процессор, тогда действительно может быть несколько мест,
где одновременно происходит вычисление, но все равно, значит, все равно каждое ядро, оно как бы в каждый момент работает с небольшим участком памяти.
По крайней мере, принципиально это должно быть верно.
Да, ну и возможно это есть некоторое отличие с тем, как человеческий мозг работает,
потому что там тоже, в принципе, есть разные измерения активности, что при одних активностях одни области мозга работают,
при других другие, но все равно в целом много разных процессов параллельно происходят.
Не то, что где-то в одном месте только какие-то нейроники что-то изменяют.
В принципе, мы утыкаемся в философскую дискуссию про то, является ли мышление вычислением.
Да, этой дискуссии уже там 400 лет, это еще либнец в таком духе рассуждал, но в общем,
окончательного ответа нет, и разные ученые сейчас думают по-разному.
Вот, хорошо.
Так, ну тогда можно сказать, можно закончить формальное определение, можно сказать, что такое вычисление.
Значит, вычисление – это цепочка конфигураций.
Значит, вычисление – это цепочка конфигураций.
Значит, такая что для любых двух соседних,
переход осуществляется в соответствии с программой.
Да, то есть вот как раз по этим правилам, как раз для любых двух соседних вычислений происходит переход.
Так, ну хорошо.
Значит, дальше можно сказать, что означает, что машина распознает язык или разрешает язык.
Значит, машина разрешает или распознает язык А.
Значит, верно следующее, для любого х, принадлежащего А, существует вычисление,
значит, начинающиеся с Q1х.
Это как раз начальник конфигурации, как мы ее описывали.
Да, записано только х. Машина в состоянии Q1 указывает на первый символ х.
Значит, начинающиеся с Q1х и, соответственно, заканчивающиеся в конфигурации, содержащие QA.
Ну а для любого х неиза, будет все в общем то же самое, только тут будет QR.
Ну да, а у нас есть стигма со звездочкой.
Ну как правило, можно считать, что это нольки и единички, можно считать, что натуральные числа.
И вот это называется разрешимый язык или разрешимое множество.
Слово язык тут тоже по историческим причинам употребляется просто как синоним слова множество.
Просто когда эта вся наука бурно развивалась в 50-х годах, то ей много занимались с прицелом на лингвистические приложения.
Тогда думали, что можно довольно легко создать компьютерный переводчик, хотя бы в итоге оказалось, что это существенно более сложная задача.
Да, но вот рассуждали в терминах языков, поэтому часто говорят про разрешимые языки, но могут говорить и про разрешимые множества.
В общем, термины взаимозаменяемые у нас будут.
Ну и также очень важно определить, что такое вычислимая функция.
Что означает, что машина вычисляет частично определенную функцию.
Значит, f из 0,1 со звездочкой... ой, давайте из sigma со звездочкой.
Так, из sigma со звездочкой в sigma со звездочкой.
Так, верно следующее.
Для любого x, во-первых, если f от x определено...
Что такое частично определенная функция?
Это означает, что она либо определена и равна чему-то, либо не определена.
Значит, для любого x, если f от x определено, то тогда существует вычисление,
значит, переходящее из конфигурации q1x в конфигурацию q0 f от x.
Ну и важно следующее. Если f от x не определено,
то тогда должно быть бесконечное вычисление, начинающееся с q1x.
Значит, тогда существует бесконечное вычисление, начинающееся с q1x.
То есть, ну иными словами можно сказать так, что программа начинает на входе x работать,
если f от x определено, то программа останавливается и возвращает f от x,
а если f от x не определено, то программа не останавливается.
Значит, вот это тоже самое, но немножко более формально записано,
как свойство некоторых кортежей, последовательств и так далее.
Надо дать, я неформально тоже расскажу, значит, что если f от x определено,
то тогда машина на входе x возвращает f от x, да, значит, если f от x не определено,
то тогда машина на входе x не останавливается.
Вот, и это очень важно, что именно так, да, потому что можно было бы определить по-другому,
что если функция определена, то тогда машина возвращает f от x,
а если функция не определена, то машина сообщает, что функция не определена,
возвращает там какой-нибудь специальный символ неопределенности.
И это будет другое определение, не эквивалентное, и в общем там теория
с таким определением похуже получается, да, и это на самом не то, что мы хотим.
Чтобы получилась правильная теория, нужно именно такое определение давать.
Так, ну хорошо.
Так, теперь что я еще хочу сказать именно про модели.
Значит, вот это вот, да, значит, важное определение, разрешимое множество,
значимые функции, то, с чем мы будем плотно работать на следующих лекциях.
Вот, а сегодня я еще хотел бы немножко сказать про модели.
Значит, мы на самом деле делали довольно произвольный выбор.
Когда мы давали определение, то мы много довольно произвольных вещей выбрали,
например, ну вот мы сказали, что асфальт произвольный,
а можно было бы сделать какой-нибудь фиксированный, например, бинарный.
Мы сказали, что лента бесконечная обе стороны, а можно было бы,
что она была бесконечная в одну сторону, или наоборот, была бы не лента,
а целая кратиклечистая плоскость или несколько лент.
Вот, у нас двиги налево, направо и на месте, а можно было бы только налево или направо,
а можно было бы, наоборот, разрешать какие-нибудь прыжки.
Делается команда, что перепрыгнуть настолько-то шагов в такую-то сторону,
может быть, даже на произвольное число шагов там можно записывать.
Ну и так далее, значит, и так далее.
Вот машина Тьюринг – это очень устойчивое определение,
то есть для очень большого числа вот таких вот вариаций будет то же самое.
Ну, конечно, не для всех. Не для всех, например, если разрешить только
на месте или направо сдвигаться, то это будет уже не то же самое,
будет более слабая модель. Но, например, если запретить на месте,
то тогда это будет то же самое.
Ну вот, значит, получается, что класс разрешимых языков или разрешимых множеств
или вычислимых функций, получается, одним и тем же
для огромного числа различных моделей.
Значит, для самых разных вариаций машины Тьюринга
и других вычислительных моделей.
Значит, этот эффект суммируется таким утверждением,
что называется тезис Чорча. Ну и тезис Чорча Тьюринга он часто называет.
Значит, тезис Чорча Тьюринга.
Почему такое странное слово тезис?
Почему там не теорема, там не аксиома?
Но суть в том, что это вообще не математическое утверждение,
это утверждение об окружающем мире.
И утверждение такое, что любая функция, которую можно вычислить,
можно вычислить на реальном вычислительном устройстве,
можно вычислить и на машине Тьюринга.
Можно вычислить и на машине Тьюринга.
Сам Чорч такой же тезис не для машины Тьюринга выдвигал,
а для своей собственной модели общерекурсивных функций.
В отличие от машины Тьюринга эта модель сейчас представляет
исторический интерес, напрямую мало где применяется.
А вот приведение к машине Тьюринга он стал довольно известен, популярен.
Ну и даже есть такое понятие Тьюринг полные языки программирования.
Это, собственно, кивчатинские модели, для которых вот этот тезис верен.
Разумеется, все стандартные языки обладает вот этой самой Тьюринг-полнотой.
Тьюринг-полнота означает, что вы на языке можете запрограммировать любую функцию вычислимую.
Ну в частности, если вы на языке можете запрограммировать машину Тьюринга,
то значит вы и как следствие любую другую функцию тоже можете запрограммировать.
Потому что вы можете запрограммировать ту машину Тьюринг, которая вычисляет данную функцию.
Но, соответственно, если есть какая-то конкретная вариация, то этот тезис становится теоремой.
Ну, например, давайте, это больше для семинаров тема, дайте какой-нибудь простой пример.
Да, например, почему можно не стоять на месте.
Значит, пример, если сдвиги только L и R, то получится эквивалентно.
Очень просто, если нужно стоять на месте, а вы не можете стоять на месте,
но нужно сделать шаг налево, потом шаг направо.
То есть если есть старая программа, в которой была команда QA,
превращается в R, B и на месте, то в новой программе будет две команды.
Значит, QA превращается в R', B и, например, налево, а дальше R' и что угодно превращается в R, что угодно, и направо.
То есть получается, что мы сначала заменили, сдвинулись, а потом ничего не меняем и сдвигаемся обратно.
И по итогу две вот эти команды работают точно так же, как одна команда вот эта.
Если у нас есть программы, в которой есть сдвиги налево и направо, и на месте тоже,
то можно написать новую программу, в которой сдвигов, ну, не сдвигов, а наоборот,
состояние на месте не будет, все будет заменено на сдвиги налево-направо.
Ну, соответственно, вот такие более или менее сложные конструкции получаются.
Так, ну, у меня есть еще некоторое время.
Давайте, значит, другие примеры оставлены в семинарах. Есть еще одно очень важное понятие.
Давайте я постараюсь про него рассказать, по крайней мере вкратце.
Значит, вкратце понятие это универсальная машина, универсальная машина тьюринга.
Значит, тут опять же можно немножко удариться в историю учительной техники.
Да, и концепцию архитектуры компьютеров. Значит, есть вообще два принципа компьютерной архитектуры.
Значит, есть Гарвардская архитектура, да, есть Принстонская, Принстонская или Неймановская.
Гарвардская архитектура, грубо говоря, означает, что программа это часть железа.
Ну, можно сказать, что программное обеспечение выражено в аппаратном.
Программа это часть аппаратуры, а данные отдельно, данные на некотором носителя.
Ну а Принстонская архитектура заключается в том, что программа на таком же носителе, что и данные.
Значит, на таком же носителе, что и данные.
Ну и, соответственно, подавляющее большинство современных компьютеров построено как раз на Принстонской архитектуре.
На одном и том же жестком диске есть и операционная система, и программы, и пользовательские файлы.
Все это вот в одном и том же месте, все это одними тем же битами записано, и как-то это все работает.
Ну и, соответственно, чем хороша Принстонская архитектура, что ее очень удобно перепрограммировать.
Если вам нужно обработать по-другому, ну вы там меняете программу, которая лежит там же для данные.
Престанавливается операционную систему, установится новая программа и так далее. Все это очень легко делается.
Если у вас программа это часть аппаратуры, то получается, что чтобы сменить программу, вам нужно что-то перепаивать.
Заменить какие-то детали, и это явно более сложная задача.
Поэтому сейчас вот такая гарморская архитектура только для каких-то нишевых вещей, которые точно нужны для одной цели.
Например, в аудиоаппаратуре бывает такое, что какая-то обработка звука делается так, что у вас прямо программа запаяна в микросхему,
которая там обрабатывает звук. Ну или еще один пример, это фермы для майнинга криптовалют.
Они тоже могут быть сделаны для конкретной криптовалюты с конкретной там хэш-функцией.
Специально все запаяно так, чтобы именно очень быстро и экономно по электричеству получалось именно эту валюту майнить,
а больше там ничего она делать не может.
Ну хорошо, соответственно, вот то, что у нас до сих пор было, это на самом деле была гарморская архитектура, вот эта машина тюринга.
Там отдельно получались данные на ленте, а отдельно программа, которая вообще неизвестна где.
Ну вот, а универсальная машина, она вот работает на принцессской архитектуре.
Так, ну я уж только определение успеваю дать.
Соответственно, универсальная машина тюринга работает как, ну можно писать так, u от mx равно m от x.
То есть здесь m это какое-то описание машины тюринга в каком-то формате, в том, как мы описали, как кортеж,
или какие-нибудь конкретные соглашения могут быть, как записывается программа.
m это получается описание машины тюринга, а x это получается ее вход.
Соответственно, универсальная машина тюринга получает эти вещи и возвращает как раз то, что эта машина на этом входе возвращает.
Ну, теорема, которую тюринг доказал, что универсальная машина тюринга существует.
Но мы ее прям так подробно не будем доказывать.
Да-да-да, и на самом при этом машина тюринга.
Вообще это похоже на компилятор какого-нибудь языка программирования, который написан на этом же самом языке программирования.
Да, это не очень удивительно, что так можно сделать.
Можно вообще не доказывать теорему, а оставаться на тезисчорча.
Мы же можем там на питоне написать машину тюринга.
Ну, раз на питоне можно написать машину тюринга, значит и на машине тюринга можно написать машину тюринга.
Ну все, на сегодня все. Спасибо за внимание.
В следующий раз у нас будут свойства вычислимых функций и разрешимых множеств.
А также еще появятся перечислимые множества, которые тоже очень важны.
