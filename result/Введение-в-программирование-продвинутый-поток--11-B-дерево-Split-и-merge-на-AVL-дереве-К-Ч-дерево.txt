Давайте тогда поехали. Как говорится, и было у нас двоичные деревья поиска, и обсудили мы их в целых, получается, четыре штуки.
Сегодня мы обсудим еще. Но важна оговорка. Сегодня мы снова будем решать всякие задачи, попытаться решать задачи построения черного ящика,
которые очень удобно добавлять, удалять, искать элементы, а также желать на минимум и максимум, а лучше еще и какие-нибудь следующие, предыдущие.
Ну, серечь лавербаунды, айпербаунды и наоборот.
Но сегодня мы попробуем отойти от концепции двоичных деревьев поиска. Ожидается у нас сегодня две структуры данных на эту тему.
Что хочется? На самом деле заметим, что до этого момента мы обсуждали всякие деревья такие, что все элементы по памяти явно влезут куда-нибудь в оперативную память.
Ну, причем в олимпиадах это не новость.
Но возникает такая проблема, что когда вы смотрите в вершину, если задуматься о том, что пусть у нас элементы хранятся не в оперативной памяти, а где-нибудь там на диске.
Вот, и эти элементы надо доставать. То, как мы уже с вами знаем из внешней сортировки, оказывается, что доставать вот по одной вершинке вот в тех объемах, которые мы изучали, это как-то очень неэффективно.
То есть в идеале хотелось бы доставать как-нибудь побольше.
Поэтому возникает такая интересная идея. А можно ли сделать дерево, в котором в вершине находится не один элемент, а несколько?
Вот такая вот интересная идея. Ну и желательно, чтобы оно было каким-нибудь сбалансированным, естественно.
Ну, собственно, вот на таких предпосылках предлагается такая замечательная структура данных, как B дерево.
Почему B? А чтобы я знал. Название такое.
Итак, значит, смотрите, выглядеть оно будет следующим образом. Вот что было у нас раньше?
Раньше у нас в двоичном дереве поиска обычно тут был какой-то элемент, и у него было два под дерево.
Тут находятся элементы, условно, меньше пяти, а тут находятся элементы больше пяти.
Ну, соответственно, в B дереве оказывается позволительно делать кое-что более продвинутое.
То есть в демпере оказывается, что у вас может быть перечислено, скажем, например, три вершины.
Вот, допустим, три вершины. Ну, не три вершины, а три ключа, если быть точнее.
Вершина одна. Но тогда у него будет четыре ребёнка. Здесь элементы будут меньше пяти.
Тут, соответственно, от пяти до семи. Ну, здесь, соответственно, от семи до девяти.
Ну, вот и здесь, соответственно, больше девяти.
То есть вот такая технология. То есть обратите внимание, что количество вершин, что в вершине может быть больше одного ключа.
Но теперь, поэтому, если вы захотите доставать, скажем, вершину из какой-нибудь памяти,
то тогда вам пришлют сразу несколько ключей, ссылку на несколько деревьев, и тогда это даст вам возможность
сокращать количество поисков, условно, не совсем в два раза, а, соответственно, может быть чуть больше.
Вот такая у нас возникает идея.
Итак, но, конечно же, это условно в два раза и в четыре, это всё условно, пока мы не вводим такое понятие, как сбалансированность.
Но давайте думать, что же мы хотим. Итак, хотим же мы следующие.
Значит, смотрите, в определении по дереву у нас будет следующее.
Значит, во-первых. Итак, поехали.
Значит, каждая вершина у нас содержит ключи.
Значит, такие х1 меньше, и так далее. Значит, х соответственно.
Ну, я так напишу. Допустим, k от v. Значит, обратите внимание, почему k от v?
k от v, потому что у нас будет такая фишечка, что количество ключей в вершине не обязано быть константой.
Ни в коем случае.
Ну, на самом деле, не то чтобы у вас может оказаться, что в вершине находятся все инэлементы, нет.
Ну, у нас будут какие-то разумные ограничения, сейчас вы увидите.
Но тем не менее, по крайней мере, мы отказываемся от концепции, что в вершине хранится ровно сколько-то вершин.
Поэтому я пишу k от v. Вот. А также указатели на дереве, ну, на под дереве можно было бы сказать, конечно.
Значит, там, ну, я их назову там, альфа 0, альфа 1, там альфа 2, и так далее, альфа k от v.
Вот. Обратите внимание, да, видите, я не случайно тут пишу именно с нуля, потому что, да, деревьев у нас на одно больше, чем ключей.
Ну, почему это уже по картинке, видите?
Вот. Ну и, соответственно, такое, что, понятно, в альфа 0 все ключи, значит, там все ключи меньше х1, в альфа, значит, i, для i равно, да, вот это так пишет,
в альфа i, значит, в, значит, полуинтервале, вот, соответственно, х и, и, соответственно, х и плюс 1, значит, i равно 1, 2, пум-пум-пум, соответственно, k от v минус 1.
Ну и, соответственно, в альфа, значит, k в этом, соответственно, тупо больше, чем х в этом.
Вот, если совсем формально написать, то вот можно написать так.
Вот. Но, как вы уже догадались, это только первое условие.
Вот. Ну, это, так сказать, определение структуры.
Значит, еще важный момент, значит, еще, соответственно, вот, также еще для дерева важно зафиксировать одну константу.
Значит, смотрите, зафиксирована константа T.
Ну, я тут не буду писать, но целая.
Потому что именно эта константа будет ограничивать количество ключей в дереве.
Значит, тут я сразу что-то просто в этом жопу тут же и пишу.
При этом в любой вершине дерева, значит, внимание, смотрите,
k от v не превосходит 2t минус 1.
Вот. То есть у нас все-таки будет такое ограничение.
И вершина, ну вот, и b, значит, тут внимание, в любой, внимание, некорневой вершине.
В вершине, оказывается, что вот предлагается, что k от v было больше либо равно, чем t минус 1.
Да, вот внезапно оказывается, что у нас на всей вершины, по крайней мере, кроме корня, есть не только верхнее ограничение количества ключей, но и еще и нижнее.
Понимаете, да? Вот.
Вот. Но и это еще не все. Потому что само по себе пока, конечно, эта сбалансированность не гарантирует.
То есть пока это дает в определенной степени нам развязывают руки, но исключительно в определенной, но сбалансированности нам пока не дает.
Вот. А сбалансированность нам даст следующее.
Ну, давайте выразимся в терминологии предыдущих лекций.
Понимаете, мы вот это с указателей на пустые деревья обозначаем крестиком.
Так вот. Тогда я сформулирую следующим образом.
Все вот эти вот крестики находятся на одной и той же глубине.
Да. Ну, на самом деле, да, но на самом деле нет. На самом деле нет.
Контр-пример вот такой, смотрите. Дело в том, что если мы рассмотрим такое дерево как бамбу-ча, ну вот проблема, да.
Ну, то есть более формально тут надо написать, что все листья находятся на одной и той же глубине, и у всех вершин либо все поддеревья существуют, либо все поддеревья не существуют.
Вот. Ну или там типа у меня листов, вот это хотелось написать, но раз уж у нас есть такое понятие как крестик, вот кажется мне удалось сформулировать ту же самую мысль сильно более коротко.
Ну да, помните о том, что да, то есть в обычных деревьях действительно у нас там какие-то дети могут существовать, а другие в то же время не существовать.
Вот. А здесь у нас действительно достигается определенного рода сбалансированность, потому что, ну давайте вот подумаем, как у нас вообще дерево может выглядеть.
Вот давайте зафиксируем какую-нибудь константу, там я не знаю, t равно 3, что мы тут видим.
Вот. Но мы можем заметь, давайте скажем, что допустим у нас корень может состоять из, там я не знаю, из четырех элементов, видите, то есть у нас их должно быть от двух до пяти.
Там допустим, там я не знаю, пять, давайте. Не-не-не-не-не. Ну снизу да, но ограничение сверху-то не для корня.
Да. Так-то да, но в корне от одного до пяти, а у всех до двух до пяти. Ну я все равно пока нарисую так. Вот есть, то есть здесь до пять, там допустим, 15, 28, 57, например.
Вот. Ну в принципе, да, одна вершина это, конечно, тоже корректное дерево поиска. Вот. Ну что у нас здесь? Ну здесь у нас может быть там, что-нибудь там, я не знаю, минус три, там скажем, там что-нибудь, ноль и там допустим три.
Вот. И тут какие-нибудь листья на эту тему. Ну вот. Ну скажем, их может быть от двух, поэтому так и напишет там, минус два, минус 20 и минус четыре. Тут допустим, минус два, там минус полтора и минус один.
Ну и так далее. Тут тоже что-нибудь типа там один, два, два с половиной, два и семь. Ну и тут, соответственно, тут должно быть от трех до пяти, поэтому тут три, один, три, два, три, три, три, четыре. Вот.
Ну то есть вот на самом деле типичное такое под дерево, под дерево, особенно на низкой глубине, может выглядеть вот таким вот образом. Вот. Ну можно тут, конечно, аналогичные всякие вещи тоже порисовать. Вот, например, давайте я тут еще пару вершин нарисую.
Вот. Соответственно тут семь, восемь, там допустим одиннадцать. И тут тогда обязательно существует какие-нибудь четыре дерева. Пум-пум-пум-пум. Там ну вот. Ну и тут что-нибудь там шесть, там шесть с половиной, ну и так далее.
Ладно, я думаю, дорисовывать смысла особого нет. Я думаю, так все понятно уже. Ну это пока дерево, конечно, малой глубины, оно может быть и побольше. Ну и, конечно, как правильно замечено, то есть на самом деле, конечно, тут все может быть и побольше.
Вот. Ну, например, ну вот. Ну то есть замечаю, что корень может быть и поменьше. То есть в принципе какой-нибудь там корень, в котором находится одно, одно, одно число пятьдесят семь, это нормально. Даже вот при любой константе Т.
Но в любом случае у детей, конечно же, всех обязано быть уже меньше. Значит ноль, там два, там то есть два пять, ну хотя бы два должно быть.
Там вот либо ноль-два вот так вот, чтобы два было, либо наоборот побольше. Двести, триста, четыреста, пятьсот.
Да, в любой не корневой, да, это важно. Вот.
Вот, соответственно, все крестики находятся на одной и той же глубине. Или что то же самое, ну то есть отсюда следует, да, не то же самое, но следует, что все листья находятся на одной и той же глубине H.
Ну вот давайте подумаем. Как бы, какой высоте дерева это нас приводит? Ну вот давайте смотреть, да. То есть давайте подумаем, что если у нас, давайте так, если у нас высота дерева H, то есть расстояние от корня до листа H,
то тогда мы можем заметить, что минимальное количество, значит, что тогда размер, размер в смысле количество ключей, да, вот обратите внимание у нас это впервые, теперь у нас количество вершин и количество ключей это разные вещи.
То есть раньше вот мы как-то могли это путать, вот теперь будьте внимательны, здесь такое уже не сработает. Значит сколько у нас может быть ключей?
Ну поехали, на нулевом уровне их не менее чем один и соответственно не менее чем два дерева, два ребеночка. Вот, ну в этих двух ребеночках не менее чем там скажем T, T-1 ключик, видим, да?
Вот, и у них как минимум, и как следствие у каждого из этих детей получается как минимум T внуков, то есть видите количество детей от T до 2T получается.
Вот, то есть получается тут 2 на T-1T, там дальше соответственно на T-1T в квадрате и так далее. То есть там до, там соответственно какой там степени?
Ну давайте напишем 2T-1 на T, там степень H-1 получается. Вот, ну что это такое? Что это такое? Это 1 плюс 2T-1 на геометрическую прогрессию, 1 плюс T плюс бла-бла-бла, да?
Ну если ее просуммировать, то вот есть такая гистическая формула T в степени H-1 поделить на T-1, так как вот T больше одного, поэтому мы так сделать можем.
Ну тогда мы тут замгновенно получаем шлеп-шлеп, и получаем там 2T в степени H-1. Вот, ну откуда соответственно мы понимаем, что H меньше либо равно логарифам двоичной, там вот формально говоря N плюс 1 попало.
Да, только логарифам не двоичной, а, что приятно, по основанию T.
Почему нет? Смотри, двоечка домножается.
Так я вот это вот вынес. Вот это? Так, вот это? Мы измеряем количество ключиков. То есть у нас, смотри, вот у нас допустим два ребенка, и в каждом из них как минимум T минус 1 ключиков.
Почему? Потому что вот у нас вот эту. У корня может быть два ребенка, ну потому что тут ключик может быть один, нуля ключиков не бывает, то есть каждая вершина не пустая.
Да, там хотя бы два ребенка. Да, их может быть 3-4, в общем, хоть 2T, но в худшем случае их 2.
Итак, то есть мы понимаем, что высота дерева у нас логарифмична.
Но, причем логарифм у нас по основанию T. Причем обратите внимание, то есть вообще с точки зрения какой-нибудь такой классической, такой олимпиадно-логаритмической, допустим, в общем-то, раз T константа, то в общем-то нам не было бы особо принципиально логарифм по основанию T или логарифм по основанию 2.
Вот, понимаете, да? Вот. Но теперь если внимательно думать, что мы тут хотим действительно отопираться с этим деревом, то мы понимаем, что здесь вот эта вот высота, то есть это, возможно, количество, если мы хотя бы вообразим себе уже операцию search в этом дереве,
то понятно, что мы возьмем в себе корень, поймем в какое дерево надо лезть и будем в него там лезть, условно вайликом. Но заметим, что в процессе тогда получится, что тогда у нас будет какая-то последовательность вершин, и каждую из них надо подгрузить.
Помните, да? Вот. Значит, вот надо подумать, действительно, каждую из них надо прям очень-очень-очень аккуратно подгрузить. Вот. И поэтому сразу возникнет вопрос, можно ли так сделать insert и delete?
Ну, давайте для начала все-таки попробуем search написать, то есть в такой технологии. Но, правда, теперь заметим, правда, для этого теперь давайте поймем примерно, что у нас вообще, что у нас из себя представляет вообще вершина.
Ну, вот. Ну, сама в себе вершина. Ну, тут замечаем, что количество детей у нее может быть какое угодно, вот. Поэтому придется вводить, видимо, вектор. Да, в общем, мы так еще и в один индексация это определили, да, ну ладно.
То есть, допустим, вектор, там, допустим, типа T, ключи. И что-то еще. Вот. И еще нам, конечно, придется завести вектор.
А вот здесь важная фишка, смотрите. Потому что, казалось бы, хочется сказать, конечно, указатели, но давайте я все-таки вот так напишу.
Что? Ну, почему на массиве, на векторе? Нет. Это не совсем число. Ну, можно сказать, число, но это некий ID, который, значит, полезет в базу данных и достанет соответствующую вершину.
Или, ну вот, по которому можно, или, наоборот, сказать, что давай вот по этому ID-шнику положи ее на место. Потому что, смотрите, в качестве дополнительного веселья мы себе скажем, что мы, что так у нас дерево, например, большое, памяти, там, каждая вершина может там даже кушать много.
Поэтому мы хотим хранить, ну, может быть, не совсем там по одной вершине в памяти, но O объединиться. Ну, то есть, нет, одну вершинку-то мы, наверное, загрузим и даже там две-три-пять, допустим, загрузим, но все N нет.
И более того, вот этих всех загрузок-подгрузок нам бы хотелось, конечно, сделать как-то поменьше. Вот давайте посмотрим, как это будет выглядеть. Вот.
Ну, я тут не буду прописывать эти все там, чтобы можно было там вести там шаблонное дерево с константами, там, с типом T и шаблонный констант, еще вот это и вот, да.
Вот. Но мы этого не будем делать.
Так. Ну, а теперь возникает вопрос. Как же у нас будет выглядеть search?
Вот.
Ну, допустим, соответственно, значит, вот, идти так, bool search.
Ну, значит, что он у нас получает на вход?
Ну, получает он на вход, конечно, какой-то ключик и наш корень.
Ну, как бы у нас тут всегда что есть, то есть.
Вот. Ну, пишем, что nodev равно, я так напишу, я вот тут введу такую операцию readFromDisk от рута.
Значит, поехали. Что мы тут будем делать?
Ну, и тут мы можем сделать так, ну, например, while пишем, while true.
Ну, вот. Ну, допустим.
Вот. Ну, вот.
Ну, вот.
Ну, первое, что нужно сделать, это, конечно, понять действительно, где этот ключик у нас вообще лежит в этом массиве кис.
Ну, значит, поехали. В. Ну, вот так и напишем.
Ну, как, соответственно, найти?
Ну, нам желательно найти, понятно, минимальный ключик, который больше либо равен нашему, правда?
Вот. Ну, у нас как бы все. У нас есть вот вершина v, какая-то последовательность.
Нам нужно понять, собственно, где находится v, причем, может быть, она где-то здесь находится, малая. Мы же пока не знаем, да?
Хотим.
Ну, скажем так, можно, так как t константа, то можно не хотеть, потому что по большому счету это ничем особо не поможет.
Ну, с одной стороны, да, но тут еще такая говорка есть, что, скорее всего, вот эта вот операция, скорее, как это ни странно, там перешибет все равно все эти загрузки.
Тем более, что так или иначе, уж, наверное, вот эту операцию вы все равно уатте делаете, правда?
Причем там такие жирные уатте, потому что там лезть куда-то надо. Мы же их, да, хотим.
Ну, вот. Ну, не важно.
Ну, нет, это-то да, но как бы захотите ужать, значит, и вершин захочется побольше.
Вот. Ну, хорошо. Значит, как теперь? Ну, хотим бинпольском. Ну, да.
Ну, как у нас делается бинпольск? Ну, делается бинпольск у нас, естественно, std-overbound.
Вот. Если вы делаете бинпольск иначе, то зря вы это делаете.
Значит, v.tees.begin plus 1 и там v.tees.end. Ну, и, соответственно, что там еще у нас?
А, ну, конечно, сам ключик. Вот. Ну, и что мы тут понимаем?
Ну, и что мы тут понимаем?
А потому что мы тут прописали, что у нас ключи с единиц нумируются.
Да, нулевой элемент пустой. Поэтому я так пишу. Можно так не писать? Пожалуйста.
На ваше усмотрение. Ну, раз вы просто один раз ввели. Нет, можем переписать определение, конечно.
Давайте. Ой, да, очень долго. Ну, хорошо, хорошо.
Ну, хорошо, хорошо. Пожалуйста. Так. Действительно несложно. Так.
Ага. Так, значит. Так.
Так, так, так, так, так, так, так.
Ну, да, да, да. Да, тут, соответственно, x0.
В этом. Так, теперь тут надо написать, что x-1 и xit. Вот еще надо написать.
А, нет, не так. Это остается тут минус один.
Ну, да. Ладно, да. С нас сильно нюк было, да.
Окей, хорошо, хорошо, хорошо. Ладно.
Значит, что у нас теперь?
Значит, если оказалось, ну, я тут надо сразу аккуратно прописать, что там.
Чего? А, ну, хорошо, хорошо, хорошо.
Ну, да. Ладно, теперь он без единички.
А больше вас ничего не смущает, да?
Вот. Да.
Ну, есть разница.
Ну, надо, что иногда чуть-чуть и сам поучиться, да.
Так. Чуть-чуть. Так.
Ну. Ну, надо, что иногда чуть-чуть и сам поучиться, да.
Так. Чуть-чуть. Так.
Ну, теперь надо просто проверить. Если соответствующий элемент оказался,
что он тут есть, то можно прям сразу вернуть трушечку.
Вот. Ну, а в противном случае тогда мы вынуждены обратиться к товарищам из ревизионной комиссии.
Вот. Соответственно. Итак, ну, в какое дерево мне теперь надо обратиться?
Ну, да. То есть я теперь утверждаю, что в В теперь мне придется кое-что загрузить.
Ну, просто, ну, да, просто true-false такое, да.
Вот. Ну, теперь все, что нам остается, да, это загрузить дерево.
Ну, дерево какое у нас будет? Дерево у нас будет номер int на самом деле.
То есть давайте так и напишем теперь. ReadFromDisc.
Ну, можно даже так, а можно даже лучше правильно так сказать, смотрите.
Вот так лучше.
Но дайди там, допустим, child равно, значит, лезем там, соответственно, в children.
Значит, v.children. Номер int. Ну, не int, конечно, а int там, минус v. вот этого точка begin.
Ну, что делать?
Так нет, это рано.
Во. Вот, вот, вот, да.
Вот.
Ну, и все. Ну, вот. Ну, и, конечно, почему я тут это отдельно написал?
Потому что, значит, если оказалось, что, скажем, этот ID не валитен,
потому что оказалось, что это лист, допустим, да?
Вот. Вот.
Вот.
То есть если там оказалось, что условно, допустим, он не валитен,
да, можно было просто, наверное, даже написать для наших целей, что, типа, если оказалось, что это лист, то...
Ну, вот. То, значит, мы просто сразу пишем, что у нас все плохо.
Вот так вот.
Ну, а в противном случае, конечно, мы просто говорим, что v просто загружаемся от child.
Вот примерно так. От, соответственно, этого child.
Вот. Ну, вот примерно вот таким вот образом у нас будет выглядеть...
Ну, типа, ну, то есть если там реально под дерево или там пустота.
Вот так.
А, ой, да-да-да-да. Да, считываем из диска, конечно. Да-да-да-да.
Ну, мало ли. Нет, теоретически возможно.
Вот.
Так. Ну, вот примерно, то есть это там, то есть код может выглядеть вот примерно таким образом.
Вот.
То есть вот такая вот тут примерно работа.
Вот.
И так.
Ну, теперь давайте... Ну, соответственно, понятно, это работает за тот самый логарифм, даже по основанию t, что приятно.
Да, конечно, умножить на t формально говорят, но вот.
Вот. Но при этом самих по себе фактов считывания у нас ровно логарифм t.
Да, да.
Да.
Вот, собственно, да, что очень приятно.
Вот.
Но заметим, что совсем уж в инсерте, наверное, совсем уж в инсерте у нас так, скорее всего, не получится.
Не получится.
Потому что заметим, что в инсерте нам придется делать не только условно read from disk, но и write from disk.
Ну, в целом только одно, как записывание.
Что?
А нет.
Ну, тут, смотрите, вот тут надо внимательно подумать, как нам себе красиво организовать жизнь.
Вот, да.
Вот.
Вот.
Как вот нам организовано, вот.
Как нам вот очень аккуратно себе организовать жизнь.
Ну, что значит такое?
Ну, давайте просто, можно если пока без аккуратности, как, давайте себе представим, как мы вообще хотим делать вставку.
Давайте split, а потом не нарушим.
Еще это мы каждый раз делаем эти вставки, raise, а потом очень все делаем split.
Ну, скажем так, до этого мы тоже дойдем, кстати.
Да, куда же без этого?
Куда же без сплитов и мержей?
Да.
Но пока попробуем обойтись без этого.
Значит, ну, смотрите, напрашивающаяся технология, конечно, заключается в том, что надо просто действительно поискать элемент, дойти до листа и, собственно, в этот лист элементы вставить.
Правда?
Да, если он слишком большой, то...
Да.
Да, ну вот, да, вот вычислять маленькая проблема.
Что делать, если там вот в листе окажется слишком много детей?
Фон расследовал ключей.
Ну и пустых детей тоже.
Что вот тут делать в такой ситуации?
Вот окажется, что у нас тут в листе целых 2t ключиков.
Но, смотрите, если это корень, то проблема решается легким движением руки.
Мы просто берем какой-нибудь элемент, который в середине.
Да, он не обязательно тот, который мы реально только что вставили.
Может, мы вставили сюда, а там отдуваться будет кто-то в центре.
Вот.
Ну вот, и мы...
Вот.
И что мы делаем?
Мы тут поднимаем, тогда мы можем объявить этот элемент корнем.
Вот, благо, а вот ровно ради этого мы тут, собственно, и говорили, что у нас в корне может быть и один элемент.
Вот.
Ну и, соответственно, вершинок у нас тоже оказывается две.
Видите?
Тем более, что если тут были какие-то дети, то и здесь, соответственно, тоже эти дети никуда не деваются.
То есть они, конечно, относительно корня становятся глубже, но ничего страшного.
Что в этом нет?
Вот.
Но это если вершина корень.
А если вершина не корень, то что делать?
Ну, в принципе, возникает та же идея.
То есть вот даже если у нас тут что-то есть, и тут висит какое-нибудь веселое дерево, и у него тут оказалось целых 2т этих вот детей.
Там ключей.
Ну, не важно, есть лист это или нет.
Что тогда можно сделать?
Ну, сделать абсолютно то же самое.
Берем элемент из середины и отправляем его вот сюда повыше.
То есть получается вот пум-пум-пум.
Тут такая штучка.
И вот.
Соответственно.
Соответственно.
То есть обратите внимание, тут что произошло.
Правда, тут вот было 8 поддеревьев.
Вот я их даже назову.
Там бета 0, бета 1.
Там бета 3.
Там бета 4.
Ну, смысл вы поняли.
И тогда вот идея просто сказать такая, что если тут вот эти все там альфа, альфа, альфа, альфа.
То есть вот висели, висели, висели.
И вот теперь на этот уровень неожиданно переходит вот это дерево, которое тут было.
В данном случае это b3.
И тут соответственно b4.
Ну, по сравнению с вот этим вот он еще жив.
Хотя, конечно, да.
Да.
Вот.
Значит, смотрите.
Произошло следующее.
Мы тут взяли вершину на 2t.
И подняли ключик.
Вот.
Справа от него будет висеть дерево b3.
Но ладно, тут я, конечно, наврал.
Но b3 было снизу.
Да, b3 было снизу.
Но обратите внимание вот на что.
У меня тут рядом с ним будет два ребенка.
Вот тут будет, тут будет вот.
Соответственно, тут было три ключика.
И тут будет целых четыре.
Так.
Beta1, beta2 и beta3.
Вот они куда делись.
Во.
То есть вот обратите внимание.
То есть произошло фактически следующее.
Вот у нас теперь вот фактически.
Так вершина расплитилась на две вершины и ключик между ними.
Обратите внимание.
Так как тут стало 2t ключиков.
То тогда слева и справа у нас оказывается не менее чем t-1.
Ну там в одном t-1, в другом t, формально говоря.
Вот.
Ну и с этой стороны тоже примерно то же самое.
Там я уже совсем рисовать не буду.
Ну вот, но суть та же.
То есть теперь стало все хорошо.
На этом уровне.
А вот на этом уровне, да, обратите внимание, в этой вершине количество ключей вполне могло тоже.
Кто? Кто потерялся?
Нет, обратите внимание.
Нет, все листы всех этих вершин остались на месте.
Максимум, что могло произойти, если эта вершина была листом, то количество листов увеличилось на 1.
Но ограничений, технических ограничений на само по себе количество листов у нас с вами нету.
Мы рассматриваем вершину, в которую мы добавили.
Мы здесь просто оттратим, в которую вдруг стало 2t.
Да, вдруг стало 2t.
Нет, мы вообще мыслили.
Нет, смотрите, мы исходно сюда пришли даже не из этого, а думали,
а что делать, если у нас в какой-то вершине окажется там, скажем, 2t ключиков.
Ну да, то есть алгоритм, как бы исходя из этих картинок, алгоритм теперь такой.
То есть мы ищем элемент, где он должен быть, доходим до листа.
Когда доходим до листа, вставляем его, только не как раньше тут создаем там новую вершину,
а прям в списочек вставляем.
Ну в листе это уже не проблема.
Вот.
А после этого теперь говорим, так, в листе, если в листе после этого стало все еще не более чем 2t-1 ключи,
то в общем-то больше ничего делать и не надо.
А если стало 2t, ну значит тогда вот по этой схеме мы поднимаем центральную вершинку вверх и распиливаем вершинку на 2.
То есть на этом уровне теперь все хорошо, но на этом уровне теперь тоже могло стать 2t.
Почему?
Почему?
Ну типа да.
Да.
Но вот этой вершины не 2, степень этой вершины увеличилась на 1.
Потому что обратите внимание, потому что у нее в этом месте, в этом месте списка,
у нее тут было какое-то поддерево.
Да, вот тут, кстати, тут не обязательно, что тут 3, 4, тут в принципе давайте я тут для дисбаланса еще нарисую.
Вот так вот.
Так.
Вот так вот.
Вот так.
Вот.
Нет, то я просто для того, чтобы говорить, что здесь нам принципиально, что мы делим пополам,
а тут вот как раз может быть все что угодно.
Потому что даже не мы говорим, где мы тут живем.
Та переча.
Но теперь смотрите, тогда оказалось, что вместо вот этого дерева,
смотрите вот, давайте попробую все-таки воспользоваться,
образовалось вот это вот.
То есть было просто одно поддерево, осталось два поддерева и одна вершинка.
То есть нет, эта вершинка абсолютно равноправная со всеми, то есть она отправится в вектор кис,
а вот эта штука отправится в детей.
Понимаете, да?
Нет, это пока мы просто обсуждаем это, как взять проблему,
если у нас есть вершина из 2T, то как эту проблему перекинуть на уровень выше?
Да, типа распилили, отправили ключик в список выше и так далее.
Да, конечно.
Нет, ну а мы легко находим, потому что мы все вообще знали, что у нас в этом.
Да.
Ну, хотя как знали?
Тут вот начинает маленькая проблема, кажется, что знали,
но это подразумевает, что мы как будто это все сделали рекурсивно.
А мы не делали рекурсивно.
Потому что, действительно, мы помним, что если вы запустили 7 раз у вас рекурсия глубины n,
то она жрет от n памяти.
А если в каждой функции рекурсии хранится еще какую-то вершину,
то тогда в рекурсии глубины какой-нибудь, глубины 8, будет храниться реально 8 вершин.
Это нас не устраивает.
С другой стороны, что-то это родителя мы себе что-то не прописали.
Ну, это, конечно, можно и прописать, в общем-то, айдишник родителей.
Ничего страшного в этом не будет.
Ну, кроме того, что эффективность работы с базой данных, наверное, несколько попортится.
Вот.
Ну, значит, давайте думать.
Ну, вот.
Ну, вот.
Ну, действительно, но основная проблема даже не в том, что, смотрите,
что получается, сколько мы проходов делаем по дереву в таком раскладе?
На самом деле мало, но пока что кажется, что много.
Но все относительно.
Так мы, конечно, делаем от единицы.
Но у нас получилось, что их два.
Потому что мы один проход делаем сверху вниз,
а потом теперь снизу вверх вот делаем вот это вот проталкивание,
ведь в худшем случае мы можем и до корня дойти.
Но мы уже мало раз доедем до корня.
Мне кажется.
Ну, пооценивайте это.
Ну-ка.
Потому что, смотрите, у нас когда самая нижняя вершина переполнилась,
только в этот момент следующая, в следующих на один увеличилась количество сценарий.
Нет, ну, в среднем количестве, конечно, да, действительно.
Для того, чтобы там, да.
То есть это, да, то есть, конечно, там самое худшее,
лучше можно, скажем, мочить в одну и ту же точку,
и то будет, и то там доходить будет не всегда.
Но правда, для этого надо родителей ввести.
Но на самом деле можно все равно еще круче.
Вот.
Потому что я утверждаю, что на самом деле мы можем попытаться обойтись одним проходом.
Без рекурсии.
И без родителей.
И без родителей.
Вообще так, может быть, нам, конечно, придется, наверное, две-три вершинки у себя внутри хранить,
но проход будет один.
Логика очень простая.
Ведь, заметим, вот мы тут делаем вот этот подъем с вершиной, в которой 2t ключей, да.
Но заметим, что у нас инвариант позволяет делать подобную махинацию,
и когда их 2t-1.
То есть, в принципе, с корректной вершиной можно так сделать, правда?
Поэтому, в принципе,
то есть, на самом деле наша цель будет такая.
Мы будем пытаться идти сверху вниз и уже делать проталкивания.
Уже вот, соответственно, делать эти все проталкивания.
Но просто соблюдаем вариант, что вот мы живем в вершине,
и в этой вершине меньше, чем 2t-1 ключей.
Меньше, чем 2t-1 ключей.
Ну, не проталкивал, но вот эти вот подъемчики.
Ну, понятно, что совсем без них не обойтись.
Да, да, да, да, вот.
Чего? Нормально?
Нижняя граница.
Нижняя граница чего? Ну, да.
Но обратите внимание, просто маленькая приятная вещь,
что 2t-1 это 2 умножить на t-1 плюс 1.
Глубокая мысль, да?
То есть, обратите, я тут не случайно, видите, вот это что-то автоматически.
Еще то есть рисуем, что обратите внимание, да, что...
То есть, когда я в центральную вершинку одну вытаскиваю,
у меня остается по t-1 вершин.
Поэтому все корректно.
То есть, видите, тут циферки вот специально ради этого подолганы.
Чтобы я так умел.
Ну, вот.
Ну, то есть, в результате получится так.
Ну, тут, конечно, будет неприятность, что надо работать отдельно с корнем.
И отдельно с некорнем.
Вот. Ну, то есть, в корня, конечно, тут все просто.
Вот. Ну, давайте, ладно, так.
Можно еще раз объяснить, что мы будем делать, когда мы поднимемся до полня, у нас там 2t.
А мы не поднимаемся.
Мы сразу, мы подразумеваем, что мы идем вниз.
Нет, то есть, мы подразумеваем, что мы должны добиться того,
что у каждой вершины, которую мы видим, должно быть ключей не более чем 2t-2.
То есть, это наша цель.
Потому что работать это в итоге будет так.
Ну, как добиться этого в корне?
Ну, в корне это добиться тривиально.
Если случайно оказалось, что в корне, значит, там 2t-1 вершина.
Если вот так оказалось, что в корне 2t-1 то, что мы видим.
Ну, вот.
То тогда мы легко просто создаем новый корень.
Вот, например, в красночерном дереве у нас оказывается, что там корень можно было перекрасить в черный, если что.
А тут можно поднять вершинку и распилить это все на 2.
И сделать тут 2 ребеночка.
То есть, обратите внимание, ровно в этом месте происходит такое эпохальное событие, как изменение глубины дерева.
Ну, так...
Вкусовщины.
Не, ну вкусовщины немножко, мне кажется.
Не важно.
То есть, это...
Как-то нетрилекты в таких случаях говорят, это детали реальные.
Это детали реальные.
Это детали реальные.
Как-то нетрилекты в таких случаях говорят, это детали реализации.
Это детали реализации.
Это детали реализации.
Ну ладно, вообще да, согласен, что этот код еще пишем.
Ладно, раз уж пишем.
Ну нет, в принципе да, можно все что угодно, но давайте тут на каждом шаге полностью код уже не переписывать.
Вот.
Так, значит, что у нас тут сейчас будет?
Вот.
Значит, хорошо, с корнем разобрались.
То есть, теперь мы легко сделали так, что вот теперь мы находимся там, вынесли вершину и переселили в какую-то вершину, где у нас ключей меньше, чем 2t-1.
Ну и общая технология у нас теперь будет какая?
Пум-пум-пум.
То есть, у нас тут ключиков теперь немного.
Там их меньше, чем 2t, допустим, минус 1.
И все, что нам теперь ост...
Ну вот.
Ну работаем очень просто теперь.
Что значит... Думаем, куда вставлять?
Ну вот, куда вставлять?
Ну во-первых, сразу начнем, что если это оказалось листом, то сюда же и вставлять, и больше ничего делать не надо.
Вот, что мы все это делали.
Если тут оказались дети, ну что ж, давайте поймем, куда-то надо вставить.
Вот давайте для разнообразия попробуем вставить на край.
Ну можно и не на край, там это не принципиально, как вы сейчас увидите.
Значит, что мы тут делаем?
Мы загружаем вот эту вершинку.
Что у нас тут происходит?
Если там ключей оказалось меньше, чем 2t, то больше нам ничего не надо.
Понимаете, да?
Вот.
То есть там больше нам ничего не надо.
И мы туда идем.
Если оказалось, что тут их 2t-1.
Вот прям много оказалось, да?
Пум-пум-пум-пум.
И то тогда нам остается только распилить эту вершинку на 2.
Вынести ключик.
И, собственно, теперь перейти куда-то сюда.
Ну там, либо сюда, либо сюда, в зависимости.
То есть таким образом мы добьемся того, что нам будет интересно только одна конкретная вершинка.
Вот и все.
Может, может, может.
В итоге, в этой вершине может оказаться 2t-1.
Но нас это уже не волнует.
Потому что на более низком уровне это будет меньше, чем 2t-1.
Да, так-то, конечно.
Да.
То есть мы не требуем, чтобы прям весь путь, но мы хотим, чтобы пока мы идем, нам нужен запас, чтобы снизу можно было в случае чего вершинку поднять.
То есть фактически мы заранее делаем это проталкивание такое.
Ну и тогда это позволяет нам, по крайней мере, read-from-дисков сделать ровно на один проход, ровно вот один логариф.
Ну, конечно, да, есть, конечно, оговорочка, что нам вот эти вершинки, конечно, может быть, придется перезаписывать, конечно.
Вот.
Там прям по идее, прям, возможно, по тому же самому ID-шку и записывать, потому что мы же родителей не храним.
То есть как бы, то есть там есть же еще там кто-то там.
Кто-то там, у которого эта вершина является ребенком.
То есть, соответственно, надо еще аккуратно перезаписать, чтобы он потом не узнал, что оказывается, что твой ребенок ушел в другое место.
Я не знаю.
Это нехорошо.
Вот.
Так, ну что, попробуем написать или нет смысла?
По-моему нет.
Мне как-то написать вот это.
Ну, вот это вот в виде код.
Ну да.
С одним проходом.
Ну да. Нет, с одним проходом. Вот мы обсудили, как.
Имеет смысл?
Или суть уже понятна?
Если другим маркером, то и нет.
Другого да.
Правда, за другим маркером сходить, правда, придется, я боюсь.
Перерыв.
Перерыв?
Ну ладно.
Так, нет, ну перерыв сейчас пока рановато.
Ладно, давайте дальше.
Ладно, давайте тогда думать, что можно сделать с удалением.
Ну, сразу скажу, как говорится, одного прохода не обещаю.
Ну, в смысле одного прохода в смысле одного алгоритма скачивания тут я не обещаю.
Потому что если мы тут делаем сверху вниз в удалении, то тогда что бы нам хотелось?
Ну, в идеале, конечно, хотелось бы, да, как всегда, дойти до листа, в котором не менее чем t элементов, и нужно удалить, правда?
Очень хотелось бы.
Но что же нам не дает это сделать?
Что?
Но мало того, что лист может быть маленьким, на самом деле есть еще более страшная проблема.
Да, там хуже всего, что удаляемая вершина вообще не обязана быть в листе.
И вот это больно.
Вот.
Поэтому у нас будет такая более хитрая цель, такая амбициозная, попытаться эту вершину все-таки в лист протолкнуть.
Вот.
Как же мы это будем делать?
Вот давайте думать.
Как же мы эту вершину, как же мы можем это протолкнуть?
Ну, на самом деле у нас сейчас у нас будет две фазы.
Такие две фазы, в которые мы тоже будем идти сверху вниз, но у нас будет две фазы.
Сначала до того момента, как мы эту вершину обнаружим, ключик, точнее ключик, который надо удалить.
И потом уже, когда мы этот ключик будем реально проталкивать.
Ну, первая фаза это практически что бы мы делали, если бы, вот давайте предположим пока для простоты, что то, что мы удаляем находится в листе.
Тогда все, что нам нужно, это найти этот лист и желательно, ну, если вот верить технологии инсорта, тогда нам нужно все протолкнуть.
Это просто сделать так, что бы в этом листе на момент удаления вершины оказалось, ну, хотя бы этой вершины, правда.
Ну, что бы можно было безболезненно удалить.
Так. Ну, давайте думать.
Итак, что же мы можем сделать?
Значит, пытаемся идти, как всегда, сверху вниз, и у нас качественный вариант, мы говорим, что у нас прямо сейчас вершина больше либо равно, чем t вершин.
Тогда у нас психологически есть уверенность, что мы из этого поддерева можем удалить ключик и ничего не поменять.
Ведь обратите внимание, кстати, да, то есть почему-то это как-то да, то есть заметим, что если бы у нас тут могло быть t-1 детей,
то вообще могло так оказаться, что мы не можем удалить вершину и вообще ничего не попортить.
Потому что если в этой вершине t-1 ключиков и у всех ее потомков по t-1 ключику, то удалить из этого дерева ключик без выпиливания,
без полного перепиливания дерева вообще не получится.
В чем не в смысле, что это там, мы недостаточно много подумали на эту тему, а в принципе невозможно,
потому что из оставшихся ключиков вы на этом месте дерева нужной глубины тупо не построите, правда.
Вот, но тем не менее, если их больше либо равно t, то шанс есть.
Как же мы это будем делать?
Ну, давайте посмотрим. Вот, предположим, выяснилось, что наш ключик должен оказаться где-то здесь.
Вот у нас деревце. Нет, это не лист этот как раз. Нет, если бы был лист, мы бы тупо нужную вершину удалили бы и все.
Вот, например, мы сейчас пока для простоты живем в предположении, что наш удаляемый ключик находится в каком-то листе.
Да, мы занимаемся тем, что в него идем, и пытаемся поддерживать вариант, что в каждой вершине, в которой мы идем,
по крайней мере в тот момент, в который мы идем, в ней хотя бы t ключиков есть.
Вот такая идея. Значит, смотрим. Так, это пока еще не лист. Значит, смотрим, в какого ребенка надо пойти.
Если оказалось, что там уже ключиков много, то больше ничего делать не надо.
Ну, а самый интересный случай, конечно, если их оказалось t-1.
Ну, давайте смотреть. Да, на самом деле, да. То есть, тут смотрите, какая операция.
Первое, конечно, что приходит в голову, это если посуды в соседа. Заметим, что мы имеем право морально смотреть только в одного соседа, кстати.
Нет, не в этом смысле. Дело в том, что вот это вот дерево, я его нарисовал в середине, но оно могло оказаться слева и справа.
Поэтому желательно обойтись одним соседом. Он у нас безограничие общества правы.
Ну, давайте смотрите. Если тут оказалось t-1 детей, то тогда я могу просто вот с этой вершинкой провернуть операцию обратную вот этой вот.
То есть, я ее могу обозначить так. То есть, я могу просто этот ключик торжественно отправить вот сюда и эти вершины объединить.
Тогда я гарантирую, что у меня тут тогда будет очень много вершин, я тут с ними могу развлекаться как угодно.
Но это, конечно, если у нас вот такая мечта и тут t-1.
А что же делать, если оказалось, что у нас тут пом-пом-пом-пом-пом-пом, значит, что мы тут вот куда-то пошли.
Оказалось, что тут у нас t-1 вершина, а у соседа их оказалось больше.
Какие варианты?
Отнять его детей?
Нет, но не совсем.
Его детей мы положим наверх, а сверху наверх.
Ну да, на самом деле, да. Более корректно, конечно, не отнять там что-то у кого-то там.
Это будет более похоже сейчас на какой-нибудь малый левый поворот в ВВЛ.
Вот допустим, пусть вот этот элемент оказался х.
Эти оказались у0.
Игрок 0, игрок 1, игрок 2.
Ну и в конце тут у нас игрок t-2.
И здесь оказался какой-нибудь там z0, z1, z2 и так далее.
Так, и у них еще дети какие-то есть.
Ну там, как всегда, не дети, а целые деревья.
Знаете ли вы, как все знают, у нас дети растут на деревьях.
Ну ладно, у нас, правда, дети не растут, у нас они просто висят.
Ну и тут в конце там b, что-нибудь там k от этого соседа.
Вот, значит, какую комбинацию предлагается делать?
Как это предлагается перестроить?
Перестройкой нас не напугать.
Хотя ладно, больше, конечно, перестройка у нас будет возникать, когда у нас будет корневуха.
Так, смотрите.
А, а те дадут, так.
Ну нет, ну можно попробовать там, скажем так, на первом этаже.
На первом этаже, вот там есть вход, вот рядом с ним есть пара дверей.
Вот, собственно, в правую из них надо обратиться.
Вот, так, ну что, а мы тут пока.
Так, ну вот, чего?
Ну да, да, да, да, да, как это да.
Ну вот, значит, смотрите, внимание, количество вершин мы тут содержим.
Ну вот, значит, смотрите, внимание, количество вершин мы тут, смотрите, количество вершин мы сейчас менять не будем.
То есть это нужно было делать, только если тут было по t-1 и мы пихали сверху.
Но смотрите, теперь вместо х, да, так, вместо х мы сюда повесим вершинку z0 внезапно, ну не вершинку, а ключик.
А теперь смотрите, значит, да, у нас, понятно, у него будут те же самые соседи, но обратите внимание теперь, куда же делся х?
Ну, с х тут все в порядке, то есть вершинки у нас будут у0, у1, значит, у, наш любимый t-2, и вот здесь, собственно, этот х мы и поставим.
То есть мы просто теперь добавим этот х вот сюда, и у нас теперь здесь будет t ключиков.
Что касается под деревьев, да, ну понятно, все альфы тут на месте, в частности вот альфа t-1 на месте.
Ну понятно, тут эти все альфа 0, это не альфа 1, понятно.
Но справа от х тоже должно что-то висеть, и это будет бета 0.
Вот, вон то, вот это вот, видите, было оно тут самым, было оно тут крайним, оно и тут крайним будет, вот.
Так что да, как говорится, называется, позаимствовали ребенка у брата, называется.
Вот, ну, как говорится, как говорится, после проверок случаев является ли дядя его дети черными, знаете.
Так, тут-то сюда, как говорится, ну, в концерт, да, да, у нас был всплой дерева, у нас вон дедушка, у нас тут это, внуки дедушками становились.
Там, как вы помните, так что тут ничего страшного.
Ну вот, ну, а чем приятно.
Но, как говорится, ладно, это называется, ладно, у брата, это называется, детей много.
Вот, то есть одного, пока не миром, можно и позаимствовать.
Ну и соответственно, тут все вот эти деревья, бета 1, бета 2, там бета 3 и так далее, и бета какой-нибудь КАТВ.
Так что вот такая вот, то есть вот такая вот радость нас ждет.
То есть как минимум, видите, идти сверху вниз и добиваться того, чтобы в каждой вершине, в которой вы сейчас находитесь, было по Т или более ключиков, в общем-то нас устраивает.
Вот, то есть поэтому, если удалять вершину надо откуда-то из листа, то, в общем-то, обратить внимание, больше нам ничего делать не надо, правда?
Согласны?
Чего?
Да, ну виртуально понятно, да?
Ну типа, да.
Так, нет, ну да, в принципе, хорошо.
Ну вот теперь возникает такой маленький вопрос.
А что делать, если мы тут взяли и наткнулись, что какой-то ключик, который мы удаляем, оказался не в листе?
О, спасибо.
Так, так, так, давайте, что из этого надо дорисовать?
Так, сейчас.
Так, ничего не видно, да?
Да, да, да, ну да.
Не, ну так иногда кажется, да.
Как это, знаете?
Вот.
Вау, какая красота, вау.
Вот.
Так, так, вау.
Так, вот, вот так вот, вот так вот.
Сейчас.
Один сосед всегда есть.
Ну потому что у любой вершины, если дети есть, то их хотя бы два.
Нет, если у нас нет соседа справа, то есть сосед слева.
Уцеждение, если у вершины нет брата справа, то у нее есть брат слева.
Вот.
Ну как, в общем, брат, он у нас это, он либо справа, либо слева.
А что вот тут?
Не, просто.
Так, ну хорошо.
Ладно, вот давайте мы воспользуемся, ой, летающим маркером.
Так.
И сейчас я нарисую то же самое, но с другой стороны.
Значит, смотрите.
Это все очень просто при атаке соперника.
Так.
Вот.
Итак, мы отдаем им все пространство.
Вот так, так, так и вот так.
Вот, давайте вот.
Вот предположим, вот мы, вот тут, пытаемся удалять вот отсюда.
И тут T-1, да.
И, получается, и вот тут у соседа оказалось больше либо равно T.
Но если оказалось T-1, то понятно.
Ну вот, тогда у нас тут, оказывается, х.
Тут у нас, оказывается, альфы.
Альфа 0, альфа 1, альфа 2, альфа 3, там и так далее.
Тут, соответственно, альфа T.
Сколько там? Минус 1, на самом деле.
Ой.
А, ну да, альфа T-1, да.
А то я думал.
Так.
Ну вот.
Ну, а что у нас тут?
Получается тоже там какие-то бета 0, там бета 1, там бета 2 и бум-бум-бум.
И тут бета, там K от V штрих Т какой-то.
Вот.
Ну и вот этот ключик.
Мы назовем этот, понятно, что ключики мы называем тут Z 0, Z 1 и так далее.
Z, соответственно, K от V штрих.
Спасибо.
Да, да, да, да, да.
Вот, безусловно.
Вот.
И Х.
Ну вот теперь, и теперь делаем маленький поворотчик.
Вот.
Как всегда.
Что же мы делаем?
Ну это уже.
Так, стоп.
Значит, соответственно.
Значит, так.
Этот бывший Z K V штрих Т минус 1 так жестко висит теперь здесь.
Значит, в этой вершине у нас теперь.
А что сейчас происходит?
Да.
Для последней.
Да.
Тут просто заказывали, что происходит слева.
Вот я теперь использую черный маркер.
Спасибо Тихону.
И, соответственно, дорисовываем.
Вот он.
Х.
Вот.
Значит, и.
Значит, альфа 0, альфа 1, альфа 2.
И что тут еще, да?
Там альфа Т минус 1.
И вот здесь теперь будет висеть вот это вот поддерево.
Бета K V штрих.
Ну а вот.
Ну а с этой стороны просто висит все то же самое, только
на один меньше.
Ну, да.
K V штрих минус 2.
Ну тут понятно.
Z 0.
Тут понятно эти все.
Бета 0 висит.
Бета 1.
Бета 2.
Ну и прочее бла-бла-бла на эту тему.
Вот.
Ну вот.
Вот такая вот у нас получилась радость.
То есть вот такая, в общем-то, приятная красота, если
выяснилось, что вершина, которую мы хотим удалять,
находится почему-то в листе.
Ключ.
Да.
Да-да-да-да-да.
Правильно.
Правильно.
Правильно.
Так.
Абсолютно правильно.
Сам сказал.
Вот.
А теперь давайте думать.
Что делать, если ключ удаляемый оказался рад такой не
в листе?
Ну вот вы думали как проталкивать, осталось просто как-то
красивое.
А не скажите.
Не скажите.
Потому что обратите внимание, дело в том, что мы вот эту
вершинку проталкиваем не всегда.
Ведь обратите внимание, если бы, потому что мы ее проталкиваем
только в той ситуации, когда у нас тут, вот там, скажем,
тут реально оказалось t минус 1.
А кто нам запретил это сделать в другом случае?
И не в самом крайнем?
Есть вариант.
Смотрю.
Если у нас вершинка х, которую мы будем удалить,
и два ближайших к ней дерева, оба t минус 1, то все очень
просто.
Так.
Если оба t минус 1 протолкнули, так.
А если какой-то больше, чем t минус 1, то можно сделать
поворот.
Х улыбится вниз.
Да.
Есть один маленький нюанс.
Ну тогда можно переповернуть и увеличить.
И, короче, сделать.
Кого?
Можно взять поворот.
Так.
И сплик.
А, кстати, можно сделать.
Циклический поворот делать.
Она будет менять просто вот так.
Отсюда, сюда, сюда, сюда, сюда.
Чего, чего, чего?
Циклический поворот.
Напоминаю, у нас это дерево поиска, они там в задном порядке
лежат.
Поэтому так это...
Так.
Сейчас сюда.
Да.
Вот действительно.
2t минус.
Да.
2t минус 1, это, конечно, да.
Да.
Можно, конечно, до икса пытаться, да.
Действительно, делать более аккуратные подгодочки,
чтобы тут и t минус 1 не было, и 2t минус 1 не было, да.
Сейчас у кого, какой представитель?
У этого икса, чтобы представить, буди-бы какого-то мотивчика.
Он может так сказать.
Не понял.
Может как сказать, кто это лежит в этом мотивчике, да.
Он лежит, но как бы он с ним связан.
Сейчас.
Он лежит, но он не с ним связан.
Сейчас, он лежит, в этом массиве он буквально лежит. Ну и что?
Ну и что?
Не по очереди, так, не по очереди.
А х им, а х скинем вниз, и вот так вот сделаем вообще везде, на всех под деревьях.
Не, а зачем? Нет, в эту сторону можно даже гораздо проще сделать.
Помните, мы этот чит на самом деле уже применяли в свое время.
Помните, когда у нас оказалось, что мы хотим удалить вершинку в обычном дереве поиска, у нее возьми и делай, оказалось два ребенка.
Помните, что мы в этом случае делаем?
Да, мы шли вправо ребенка, находили в этом под дереве самый левый элемент, их свопали, а потом вот эту самую левую, вот ее уже и удаляли, помните?
А что нам мешает?
То есть единственная аккуратность, идея может быть такая теперь, что мы найдем, эту вершину мы себе сохраним.
То есть мы сейчас пойдем вправо и будем пытаться удалять у нее самый минимальный элемент.
То есть нас будут спрашивать, так, какое вам под дерево надо?
Он говорит, так, давай, самые левые, самые левые, самые левые.
И соответственно, ну вот, и тогда придем мы в эту вершину, ее удалим, то есть вот эту самую левую, условно, пум, пум, вот на уровне идеи вот, то есть ее мы удалим, но мы запомним этот ключик и просто его сюда запишем, все.
То есть обратите внимание, пока мы тут не храним этих ваших там всяких статистик, всяких там типа суммы на подотрески и так далее, в общем-то их проблем нет.
Ну, в общем, когда, в общем, заметим, что это вся технология мечты о минимальной загрузке, они все равно начинают вылетать в трубу, если, если вы там пытаетесь начинать хранить какие-то отложенные операции, правда?
Ну, собственно, об этом мы тоже поговорим сейчас, конечно, но вот, вот, значит, смотрите, то есть в принципе тогда нам просто ничего не мешает.
Ну, единственная, конечно, оговорка, то есть на самом деле не совсем сказать, что мы эту вершину сохраним и просто будем удалять отсюда, потому что, напоминаю, если тут оказалось t-1 ключиков, то может возникнуть такая ситуация, что просто так автономно из этого дерева мы ничего не удалим, правда?
Поэтому, на самом деле, тут надо аккуратно, поэтому, на самом деле, просто начиная с х, мы, то есть пытаемся делать, там, удалять элемент, да, справа от него, но при этом следим, что, как бы, где находится х, потому что если произошло так, что х повернулся куда-нибудь вот сюда, ну, у нас там могло быть вот в данном случае, явно произойдет поворот, который перенесет х поглубже.
Самый правый, самый нижний, но его еще и вернуть бы хорошо, и все, так же рекурсивно продолжаем удалять.
Ну, не рекурсивно, ну, во-первых, мы...
В таком же цикле примерно продолжаем.
Нет, смотри, разница в том, что до какого-то момента мы этот х будем реально пропихивать вниз, но до какого-то, потому что в какой-то момент выяснится, потому что, напоминаю, у нас есть один случай, когда этот х оказывается не в ребенке.
Случай называется, если в теку, вот там, мы, тут, жил был х, допустим, мы отправились в нужного ребенка, и бабах, и там количество детей оказалось адекватным, то есть больше либо равно т.
Тогда в этом месте х остается на месте, обратите внимание, вот, поэтому так.
Поэтому в этом, как только это произойдет, вот тогда этот х остается на месте, надо запомнить, где он, чтобы потом записать вот это вот удаляемое.
То есть потом мы свапаем новый х с самым левым элементом?
Да, да, ты можешь сказать, даже не свапаем. Мы его там, мы это самое левое достаем оттуда, удаляем, потому что мы у нас о его цели удалить, да?
Ну, потому что мы вот, наконец, шли, шли, шли, шли, шли, шли, и вот, наконец, дошли.
И вот у нас нашелся вот этот самый левый элемент, мы знаем, что их тут больше либо равно t, мы, собственно, ради этого все это делали, да?
Тогда эта идея такая, мы сохраняем, что этот элемент равен х-трих, удаляем его отсюда, и записываем сюда.
Просто тупо вставляемся, говорим, что тут х-трих, все.
Ну, в общем-то, да. Точнее так, то есть как это у нас уже раньше было, то есть как бы избавились мы от х самого по себе как ключика в одном месте,
а от физической позиции мы избавились в другом месте.
Вот. Собственно, в общем-то, для нас технология не новая, но получилось так, смотрите, то есть проход у нас получился один.
Но правда, конечно, скачивание вершин у нас оказалось уже чуть-чуть, все-таки в два раза больше.
Почему? Потому что для каждой вершины мы теперь скачиваем уже не одного ребеночка, а все-таки двух, потому что нам нужно делать поворот.
То есть опять, как у нас уже неоднократно бывало, как у нас бывало неоднократно, что удаление оказалось несколько сложнее вставки.
Ну, потому что, да, вставка это, да, вставить куда-нибудь, а удалить надо из того места, где оно находится.
Вот. Ну, то есть вот такая вот, оказывается, такая приятная структура данных.
Да.
Ну, мегаинтересного ничего делать не умеем.
Ну, да, более того, да, если мы в принципе захотим с ней делать, вот, как там, скажем, какие-нибудь суммы на каких-нибудь подотресках, там, в явных, в явных-неявных, то, нет, то в принципе тоже можно,
потому что на самом деле пока у вас нет отложенных операций типа прибавления на отрезки и присваивания на отрезки, да, на самом деле как бы тоже все можно делать за проходы сверху вниз.
Вот. Хотя, а, хотя, да, точнее так, операции можно делать, пока вы не хотите что-то менять.
Как только вы хотите что-то менять, то есть вам придется там во всех предках потом все пересчитывать обратно.
Да, проблема. Потому что, да, проталкивать операции сверху вниз мечтает, а, собственно, ради этого они и создавались, да.
Но здесь-то проблема. Вот. Ну, что делать? Что делать? Как быть, значит, возможно тут нужно тогда не усложнять.
Вот. Но, правда, тем не менее, да, вот возникает, возникает, конечно, такой вопрос хорошо.
Прибавляйте, допустим, если, конечно, мы сейчас просто отойдем от баз данных и будем относиться к этой структуре данных как, а бы, как просто к обычной какой-нибудь такой структуре,
которая лежит у нас в оперативке, и мы можем там, называю, это делать, если ничего хотим, без лишних там скачиваний и там записей.
Вот. То тогда, вот возникает вопрос. Тогда хорошо, что мы с ней можем делать?
Ну, всякие присваивания на подотрезке. Ну, вот. Ну, там какие-нибудь отложенными операциями мы делать можем, конечно, всякие суммы идти искать.
А вот можем ли мы, ну, там, да, ну, вот, а вот можем ли мы делать всякие реверсы?
Да, для этого нужно делать сплит и мерч. Возникает вопрос, нужен ли нам для этого перерыв, кстати, время которого подошло.
Ну, давайте. Вот, ладно, значит, поехали. Итак, значит, как мы поняли уже еще до перерыва, у нас возникла веселая мечта научиться делать у Б дерева сплит и мерч.
Вот. Причем желательно, потому что если мы научимся делать сплит и мерч, то выяснится, что нам больше, что у нас будет достижение.
То есть тогда у нас получится дерево, которое умеет абсолютно то же самое, что и дикартовое дерево.
Только обратите внимание, логарифм у него будет честным.
А не вероятностным, как в дикартовом дереве, и не, собственно, амортизационным, как в сплит дереве.
Вот такая вот у нас мечта.
Что?
У Б дерева звучит хорошо.
Ну, вот.
Дерево даже ничего не гарантирует.
Сколько будет заодить?
А.
Ты сказал, сейчас научишься делать сплит, у Б дерева.
А, понял.
Красиво.
У Б дерева.
Ну почему, как бы.
Хорошо, там, если готов был, то давай, если он погнал, мы всё им сразу.
Начнём мы, как-то не странно, с мержа.
Но, смотрите, сейчас нас ждёт такая неожиданно интересная фишка.
Значит, мержить, сейчас мы немножко отойдём от концепции мержа, просто даны два дерева и надо их объединить.
Значит, мы пойдём другим путём.
Да, мы всё ещё говорим про Б дерева, да, совершенно вероятно.
Значит, смотрите, раньше мы говорили, что у нас даны два дерева, в одном там, тут все элементы меньше либо равны вот этих, да, и нам их надо как-то слить.
Так вот, теперь у нас будет более крутая технология.
Значит, у нас будет два дерева и ключик между ними.
Тут все меньше икса, и тут больше икса.
И я хочу эти деревья объединить.
И ключик тоже будет...
Ключик будет внутри них, но лишним не получится.
Да, то есть я хочу объединить как бы не два дерева, а два дерева и вершины.
Ну, замечаем, как бы, идейно вы можете увидеть, что не особо принципиально, потому что теперь можно в принципе вот так два дерева объединить, да, потому что я просто создам фиктивную вершину по значению типа между ними, особенно если там строго меньше, вообще не проблема, а потом эту лишнюю вершину тупо удалим.
Мы только что научились делать, правда?
То есть поэтому, в общем-то, пока как бы идейно мы себя не сильно ограничили.
Я бы сказал, даже никак.
Но именно такая технология нам очень так поможет.
То есть у нас есть дерево, потом все элементы меньше икс, все потом больше икс, а у нас есть икс отдельно.
И, собственно, сам икс, да.
Смотрите.
Что тут приятно?
Приятно в этом дереве, конечно, то, что... Смотрите.
Смотрите.
Ну вот, что на самом деле эти деревья очень легко объединить, если совершенно случайно оказалось, что они одинаковые высоты.
Видите, да?
Как их объединить?
Нет, это одна и та же буква, просто тут ножка маленькая.
Да.
Да, очень-очень-очень, да.
Так.
Ну идея тогда очень простая, смотрите.
Вот у нас тут икс был, да?
Значит, рассмотрим корни.
В общем, берем эти корни.
Вот у них тут висели... Давайте лучше сотру это, да?
Вот.
Так, вот это мы... Вот так вот.
Вот так вот.
Вот такой вот.
Вот, значит, смотрите.
Вот.
Вот-вот-вот-вот-вот.
И вот.
Такая красота, видите, да?
Вот.
Но тогда, смотрите, в принципе, нам практически ничего не мешает мысленность объединить эти два корня, одну вершину, в один большой корень.
Вот обойтись, Мария.
Чтобы объединить два корня, да, у нас единственная была проблема, что тут с краю есть дерево, тут с краю есть дерево, между ними должно что-то стоять, и вот оно, что-то.
Вот мы собственно ради этого этот иксик и ввели.
Видите, да?
Вот, да.
Конечно, маленькая проблема.
Может стать больше, чем 2k.
Ну, там, чем 2t.
Минус один.
Но это не проблема.
Потому что после объединения корней нам ничто не мешает взять середину.
Да, середина, кстати, не обязана оказаться иксом, как вы понимаете, да?
Более того, как бы, может так оказаться, что тут в корне было один элемент, а тут 2t минус один, понимаете, да?
Поэтому что-то надо вынести, но икс не подойдет.
Но какую-нибудь серединку, списочка мы, конечно, просто вынесем в корень, у нас получится тогда дерево высоты h плюс 1.
Вот, понимаете, да?
Тогда получается, что если у нас два дерева высоты h, то мы легко можем сделать мерч.
Причем, что очень для нас важно не просто за o от логарифма, а на самом деле за o от единицы.
Ну, в смысле, за o от t.
Которая для нас константа.
Вот.
Так, уже неплохо, правда?
Декартовые деревья, например, у нас декартовые деревья, в которые мы объединяем, по-моему, за o от единицы, это только если одно из них пустое.
Отнесение вершины, это типа мы вершину вытащили, а ее дерево как бы подняли соседом.
Наоборот, распилили.
Ну, просто помните, как мы решали, у нас, как бы, какая тут проблема, если тут вершин слишком много?
Как мы эту проблему решаем?
Распиливаем вершину надвое, вершинку выносим вверх и объявляем ее новым корнем.
А еще, зачем нам x нужно взять?
В чем он помогает?
Он помогает тем, что вы, как бы, смотрите, когда вы...
Вот представьте себе, что у вас просто два корня, да?
Вот вам хочется взять и объединить эти два корня.
Но маленькая проблема.
У них есть еще дети.
Вот тут пять детей, тут пять детей.
Тут пять детей, тут пять детей.
Как бы, если просто так объединить, то получится, что вот между этими двумя детьми должно быть вот эти вот два дерева.
И тогда надо либо эти деревья как-то объединять, желательно с сохранением глубины причем.
Либо между ними должно что-то встать.
Вот ровно за этим нам этот x понадобился.
Вот.
Это был мерч, когда у нас высоты одинаковые.
Значит, давайте повысим планочку.
Что делать, если мерч оказался...
А что я убираю?
Вот.
А что делать, если у нас мерч, если у нас деревья оказались разных высот?
Вот скажем, давайте без ограничений особого общности скажем, что тут высота какая-нибудь h1, а тут какая-нибудь высота поменьше h2.
И надо их как-то пообъединять.
Хочется из h1 максимально жирное дерево высоты h2 выпилить.
Максимально правое.
Максимально жирное?
Ну точно максимально.
Ну да.
Максимальное по количеству что ли?
Ну и чем это поможет?
Где-нибудь там в середине дерева у него есть какое-то жирное дерево.
Мы вот это сюда не вставим, потому что у нас же порядочность напоминаю.
Чего?
Да?
Как?
Нет, ну тут как-то порядок-то надо соблюдать.
Да.
Да, на самом деле действительно заметим следующее, что чем приятны дерева?
Что глубина у нас все одинаковая.
Вот.
То есть это у нас приятный случай.
И вот наконец мы вот дошли до вот этого.
То есть идем по правому пути, вот у нас тут наконец-то глубина h2.
Ну не глубина, а высота.
Ну тогда идея какая-то такая.
А давайте вот эти деревья объединим вот на этом уровне.
Вот.
Опа, прокашечки.
Вот.
Ну и теперь что делать?
Если оказалось, что тут слишком много вершин,
ну значит тогда опять же мы проталкиваем эту вершину вверх.
То есть просто распличиваем обратно и проталкиваем вверх.
Но соответственно в худшем случае мы это делаем по цепочке.
Потому что если тут оказалось тоже больше, чем t-1 после этого,
значит тут проталкиваем, проталкиваем, проталкиваем.
Понимаете, да?
Вот.
То есть вот такая вот идея.
Можно же опять-таки опускаемся?
Да.
Кстати, да.
То есть можно просто идти сверху вниз до высоты вот до этой вершины,
добиваясь того, чтобы тут была высота, чтобы тут не было 2t-1 вершины.
Да.
Можно этого действительно добиться, и тогда, когда вы тут будете объединять, вы уже без проблем справитесь.
Да.
То есть при таком мерже можно обойтись одним проходом, что приятно.
Вот.
Да.
Но тогда смотрите, за какой асимптомикой это работает?
Разница высоты.
Да.
Формально говоря, все-таки от единицы плюс там допустим h1 минус h2.
Вот так.
Значит смотрите, как мы делаем мерж?
Мы делаем мерж так.
Вот пусть у нас левое под дерево по высоте оказалось больше право.
Да, отдельный вопрос, как мы об этом узнали, но неважно.
Вот.
Значит смотрите, мы идем тупо по правому пути.
И доходим до дерева высоты h2.
На этом уровне мы, собственно, мерж делаем вот аналогично этой технологии.
Видите, да?
Да.
У нас же какие-то элементы могут...
Что?
Типа вот, если на уровне большими посмотреть сейчас, то когда мы запускаемся, то у нас все элементы новые, они должны быть больше, чем вот элементы предыдущие.
Совершенно верно.
Ну мы и требуем в мерже, что когда мы сливаем два дерева, помните?
Помните, напоминаю, мы ни в одном дереве не умеем сливать два произвольных.
То есть мы когда сливаем, мы жестко требуем, что ключи тут меньше, чем ключи тут.
Вот везде, что в ВВЛе, что там...
А, ВВЛ мы пока не умеем.
Ну это ладно.
Ну это ладно, это научимся минут через 10.
Вот.
Нет, через 10 не научимся.
Ладно.
Вот.
Пока у нас есть красивые маркеры, научимся.
Вот.
Значит, смотрите.
То есть это вот важный момент, поэтому, конечно, вот.
Но здесь, соответственно, мы смёрживаем.
И дальше, если тут слишком много вершин оказалось, то есть ключиков, то тогда мы опять начинаем сплитить и проталкивать там элементы вверх.
Ну и в худшем случае так вот до высоты и протолкнем.
Ну или, как уже было сказано, то есть если у нас как бы мы не хотим второй раз проходиться вверх, то лучше просто сразу идем сверху вниз и следим за тем, чтобы в каждой текущей вершине у нас количество вершин было не более, чем 2t-1.
Ну, главное добиться, чтобы вот в этой вершине было не более, чем 2t-1.
Не более, чем 2t-2.
И тогда, если тут надо сделать подъём, мы его сделаем и завершаем в этом месте работу.
То есть получается, да, можно ещё и за один проход это всё делать.
Вот, понятно?
Вот такая красота у нас получается.
И мы это делаем теперь за О от единицы плюс разность высот.
Ну, это прям максимально общее получается.
Вот. Ну, тогда получается подходит и случай, когда высоты равны.
А мы считаем, что внутри вершин стоит это за О от единицы?
Да. Потому что мы считаем, что тет константа.
Вот тет константа.
Потому что там мы ещё считали количество обращений к базе данных, из которых мы достаём вершину.
А сейчас?
Ну, сейчас мы, помитуя эти все проталкиваемые операции и потенциальные пересчёты, мы на это забиваем.
Потому что, смотрите, дело в том, что если вы храните какие-то там всякие вещи, типа суммы на подотреске,
то это суммы на поддереве или там какие-то минимумы или что-нибудь ещё в этом роде,
то вам всё равно придётся скорее всего по всем этим вершинам пробежаться.
Ну, либо в каждом конкретном случае там как-то извращаться.
Но скорее всего просто сами по себе эти рекалки вам придётся переделывать.
Вот в чём проблема.
Так, ну что, ещё вопросы?
Так, ну что, с Миржом всё понятно?
Так, отлично.
Ладно, тогда давайте это.
Так, ладно, тогда за скучавшие могут вылезать из телефонов.
Вот. И тогда теперь будет его величество сплит.
Вот.
Значит, смотрите.
Итак, что такое сплит?
Значит, со сплитом у нас тоже будет не совсем то, что нужно.
То есть наша цель, то есть у нас сплит должен быть обратен на Миржу.
То есть у нас есть великое дерево, в котором где-то внутри есть там какой-то х.
И мы хотим его расплитить на дерево с элементами меньше, чем х,
на сам х и элементы больше, чем х.
Вот такая у нас цель будет.
Значит, поехали.
Как мы это будем делать?
Делать будем так.
Отправляемся в корень.
В нём есть сколько-то элементов и на один нод, и чуть больше детей.
Ну, заметим, что если нам фантастически повезло
и х оказался где-то здесь, то тогда мы в общем-то произвести соответствующий сплит можем без труда.
Согласны? То есть каким образом?
Ну, условно говоря, просто вот сейчас вот так вот.
И вот так вот условно.
Там всех детей вот так вот повесим.
И вот этот вот х остался здесь.
Чего?
А, ну, на тему того, что если х крайний, что ли?
Ну, условно, да.
Заметим, что в результате сплитайте.
Деревья могут оказаться одинаковой высоты, а могут и разной высоты, но это не принципиально.
Вот.
Ну, что делать, если х оказался глубже?
Ну, смотрите.
В этом случае тогда смотрите.
Да.
Значит, вот пусть оказалось, что, значит, этот х находится вот где-то вот в этом мистическом дереве.
Тогда идея оказывается следующая.
Смотрите, вот пусть он, это дерево, допустим, вот сейчас общий случай рассмотрим, оказалось между ключами, ну, допустим, там х, х1 и у1.
Тогда смотрите, что я делаю.
Значит, смотрите, тут какие-то кто-то там висит и тут кто-то там висит.
Так вот, тогда я из этого сделаю следующее.
Тогда я скажу, что у меня теперь есть вот эти вот, видите, вот эти четыре элемента, с висящим на них деревом.
Точка х1, значит, точка у1, вот то, что тут справа, вот тут у нас немного осталось.
И, что еще?
Да.
И, соответственно, давайте осталось вот это вот лишнее дерево, и надо его посплитить.
И вот с этим деревом мы будем поступать, ну, условно, рекурсивно.
Вот, понимаете, да?
Будем поступать с ним рекурсивно.
Да, сразу скажу, хранить тут у1 с вершин, скорее всего, не получится.
Почему?
Почему?
Потому что, если мы будем с этим деревом повторять эту операцию, то тогда, по-видимому, мы возьмем корень, и у нас тут образуется еще пара вершин.
Видите, да?
Ну вот, тут там образуется еще там пара вершин, и еще там какая-нибудь вершина, и тут х2, тут там, допустим, х2.
Вот.
Но мы можем ударить, что местами она образоваться не будет, потому что если вот это дерево оказалось крайним,
то тогда у нас останется только дерево справа, а дерево слева не останется.
Понимаете, да?
Но в любом случае тут получится вот...
То есть, получится такая последовательность, и в самом конце, наконец, мы все-таки найдем сам вот этот х, и тогда вот этот финальный сплит сделаем.
Что у нас получилось?
Мы хотели получить два дерева и вершину, и успешно перевыполнили этот план.
Вот пока не обратили.
Можно пока пояснить почему нам нужно вообще идти дальше в дерево х1, между х1 и х1?
Ну потому что именно в этом дереве находится х.
То есть, смотрите, мы знаем, что вот это все должно находиться вот типа в левой части ответа, да?
Ну потому что это все заведомо меньше х.
У нас есть какое-то общее условие, если у нас известно, что дерево лежит между х1 и х1, которое выполняется для всех элементов этого дерева?
Нет, у нас есть...
И все лежат на границах х1 и х1?
Ну да, все элементы этого под дерево лежат между х1 и х1.
Потому что...
При этом они лежат строго или нестрого?
У нас строго, мы с f.
То есть, все элементы этого под дерево, они строго, ведь больше х1 получаются?
Да, и строго меньше и гк1 заодно, да.
А х1 же это не х, все-таки, да?
Да, это немножко другое.
Нет, если вас смущают...
Ладно, если вас смущают буковки, то...
Нет, я просто...
Нет, давайте...
Ладно, если нас х смущает, давайте я тут буду...
Я напишу а1 и b1, пожалуйста.
Ну да, лучше давайте по возможности избавляться от колизии с буковками.
Итак...
То есть, получается, да.
Смотрите, у нас получилось...
То есть, у нас слева и справа получилась вот такая последовательность деревьев с убывающими, что приятно, высотами.
Видите, да?
Ну вот, и между ними...
Ну вот, и между ними там, соответственно, вершинки.
То есть, в переводе говоря...
То есть, в переводе говоря...
Так, давайте это мы уберем.
Как бы все равно...
А, это еще видно, да?
Эх.
Так, смотрите, в чем у меня есть.
Значит, тогда получается, что у нас слева и справа...
То есть, вот этот х у нас где-то на границе.
И тут получилось, смотрите, какое-то дерево.
Вот я его давайте так и назову t1.
t1 условно а1.
Да, ну надо было альфа его, наверное, назвать.
А, ну что надо было?
Вот, пожалуйста.
Как говорится, мы сегодня не такие.
Это переобувание делали.
Так.
Вот.
Ну вот, какая-то вот такая вот штука.
То есть, вот такая последовательность.
И в самом конце у нас остается какое-то там дерево высоты.
Там, допустим, альфа катая.
k это не высота, это просто количество.
Мы про эти деревья, мы не знаем, какие высоты у этих деревьев.
Мы только знаем, что они строго убывают.
Понимаете, да?
Но что мы знаем?
Теперь вот нам бы единственное хотелось бы составить из них единое дерево.
Но с другой стороны, а что нам мешает?
Сначала мы заметим, что мы можем вот тут, вот у нас в самом низу есть альфа к-1, альфа к, и между ними вот это вот число ак-1.
Но заметим, что я могу эти деревья слить.
Мы только что вот это научились делать.
В чем, за какое время мы научились это делать?
Мы заучились, вот единица, плюс по факту аж от альфа к-1, минус аж от альфа к-2.
Можно, пожалуйста, пояснить, почему мы добавляем единицу?
То есть, мы так отмечаем, что нам будет вызовы делать подружами?
Для общего случая.
Ну, то есть, смотрите, ну, во-первых, мы, смотрите, от аж 1 минус аж 2 это вот количество вот этих операций.
Нет, единичку мы, на самом деле, добавляем, потому что, формально говоря, разность высот может быть ноль.
Да, а от нуля это, к сожалению, вообще что-то некорректное.
Поэтому мы для формальности пишем 1.
Конечно, если вы гарантируете, что высоты различные, то, конечно, единицу можно не писать.
Впрочем, в нашем случае мы можем и писать, потому что все равно этих единиц будет суммарно логарифмическое число, нас это устраивает.
Да, правда, вы думаете, что, а что, неужели мы тут будем это все прям вот так вот мержить?
Ну, да.
Вот, вот поехали.
Потому что самое приятное, что нас ждет, это то, что, ну, единственная проблема, что вот кто-то может сказать, так, у нас тут были убывающие высоты.
Вот, хорошо, следующее.
Теперь, когда мы будем мержить это с деревом альфа к минус 2, тут вообще может возникнуть, что для того, чтобы это была телескопическая сумма, да,
хочется, чтобы вот эта h от альфа к минус 1 оказался в минусе, правда?
Да, кстати, тут не k минус 2, а k.
И тогда вот этот вот следующий мерж мы будем делать тогда за o от единицы плюс h от альфа к минус 2 на этот раз, минус h от альфа к минус 1.
Вот так и говорим, то есть будем вот так вот фактически идти, идти, идти, и в конце у нас там получится o от единицы плюс h от альфа там, скажем, 2 минус 2.
Х от альфа 3.
И в самом конце мы заявим, что у нас тут будет o от единицы плюс h от альфа 1 минус h от альфа 2 шлеп-шлеп.
Ну вот, нет, это еще не шлеп-шлеп, это скобочки.
Шлеп-шлеп начинается здесь.
Но это не совсем правда.
Сейчас, ну.
Но теперь, да, только вот есть важная роль.
Просто если высоты действительно у нас будет так, оказывается, что левое дерево всегда будет по высоте не меньше правого, хотя бы не меньше, да, то тогда мы действительно можем раскрывать модуль именно таким образом,
и тогда у нас получится вот такие красивые шлеп-шлепы.
В сумме у нас получится там логарифм единичек плюс разность высот.
А высот, так как высоты у нас не происходит логарифма, то получился логарифм.
То есть sumar, то есть o от старой высоты.
Только маленькая оговорка.
Мы сказали, что каждое следующее дерево будет получаться по высоте не меньше правого.
Это казалось бы очевидно.
Потому что вроде как у нас, как бы мы же говорили, что вот высоты этих деревьев убывают, да?
Да, строго убывают.
Но была маленькая оговорка.
К сожалению, когда мы сливаем два дерева, никто не сказал, что результат слияния будет равен максимально из высоты этих деревьев, правда?
Да, но важное, но тут важное замечание, что в результате мержа двух деревьев у нас оказывается высота этого дерева, она не будет больше, чем высота максимума плюс один.
Ну плюс один она может быть, потому что если тут прям вот это, если вот этот вот подъем вершины прям до корня аж дойдет, то да, высота могла увеличиться на один, но не более того.
Но тогда если они строго, но тогда обратите внимание, если они строго убывали, то тогда мы просто теперь по индукции получаем факт, что результат слияния, он по высоте не превосходит предыдущего дерева.
И тогда просто по индукции, то есть если там даже два равных дерева, то все равно высота у них больше, чем на один, не увеличится.
И поэтому получается, что вот расписывать вот таким образом, но единственное, да, тут конечно может быть, видите, не минус h от альфа-3, а может быть даже от альфа-3 минус один получается.
Но обратите внимание, меньше высота от мержа не станет, ну а то, что мы тут это, как бы тут h от альфа-3 минус один, ну значит мы тут лишний минус один просто сверху оценили.
То есть таким образом мы получается можем сделать вот такой телескопический мерж, значит слева, и соответственно аналогичный мерж справа, естественно.
Вот, то есть помните, самое важное делать его, видите, здесь нам принципиально, что мы его делаем именно снизу вверх, потому что тут я боюсь совсем проталкивания этих всех операций там в духе, там сначала сделаем этот мерж, потом этот, потом этот, может не прекратить.
Хотя, хотя в принципе эту технологию можно тоже делать так справа, потому что вы тоже можете добиваться, что там, когда у вас два дерева, вы там превращаете их в одно, допустим, да, но при этом гарантируете, что на нужной вам высоте количество вершин не превосходит 2t-2.
И вот на самом деле, и тогда таким образом вот можно все-таки выкрутиться и сделать так, чтобы проход тут все-таки один будет, а не два.
Вот, понимаете? Ну правда, если конечно вы не начинаете там что-нибудь еще делать, там суммы пересчитывать и так далее.
Вот, но в принципе, то есть, по идее так, если забивать на все эти базы данных, то замечаем, что таким образом сплит и мерж мы делаем, причем, как и ранее, мы делаем сплит и мерж, по сути, проходами сверху вниз, то есть это означает, что все присваивания на подотреске реверса, на подотреске и прочей отложенной операции, собственно, вы теперь тут без труда делаете.
Ну вот, без дополнительного интеллектуального труда, по крайней мере, на уровне идеи. Нет, в общем-то, если вы уже научились делать сплит и мерж, то все, что вам нужно делать, это в нужном месте вставить функцию recalc.
Вот, ну там вообще две функции, там надо вставить функцию push и функцию recalc, помните, в декартом дереве, ну вот, собственно, везде и в декартом, и мы сплеем, и тут вот, пожалуйста.
Вот, но, как говорится, мы не остановимся на этом, потому что тут возникает интересная идея. Вот давайте теперь попробуем придумать, смотрите.
А нужно ли нам было гардить бета-дерево, чтобы получить честный логорифм в этом месте?
Ну вот, хорошо, бета-дерево нам гарантирует теперь, что у нас теперь все честный логорифм. А теперь вы сказали, что AVL этого не умеет всего случайно?
Вот, смотрите, возможно, теперь возникает вопрос, ну, сейчас вот, собственно, да, возможно, у кого-то задавался вопрос, почему это мы к AVL-ке вернулись именно сейчас, они стали обсуждать сплит и мерж когда-нибудь, хотя бы на прошлой лекции, когда мы обсуждали.
Вообще, что такое сплит и мерж, да? Вот, но на самом деле давайте попробуем, просто идея такая, давайте попробуем просто придумать AVL, сплит и мерж AVL-дерево, базируясь на подобной технологии.
Вот, ну вот, давайте посмотрим, чем у нас будет отличаться, чем у нас будет отличаться вот действительно мерж в AVL-дереве от мержа, соответственно, в где-нибудь еще? Вот, в B-дереве.
Ну вот, давайте попробуем, сейчас вот это мы, так, так, давайте-ка, ладно, давайте будем вот это стирать.
В конце концов определение B-дерево там уже не понадобится, думаю, мы по нему уже все поняли, вот, значит, смотрите, вот, так, так, так, так, так, так, так, так, так, так, так, так, так, так, так, так, так, так, так, так, так, так, так, так, так, так, так, так, так, так, так, так, так, так, так, так, так, так, так, так, так, так, так, так, так, так, так, так, так, так, так, так, так, так, так, так, так, так, так, так, так, так, так, так, так, так, так, так, так, так, так, так, так, так, так, так, так, так, так, так, так, так, так, так, так, так, так, так, так, так, так, так
думать. Итак, ну, казалось бы, да, как делать мерш в ВВЛ-дереве? Ну, как всегда, значит, здесь вот у нас жили-были дерево, и у нас тут есть вершинка, и жила была тоже вершинка, у нее есть дерево. И хотим мы их шлить, в чем, как всегда, у нас тут еще, в чем, опять же, давайте, пользуемся той же технологией, что у нас есть меньше х, больше х и, собственно, Вася. Вот.
Как же эти деревья сливать?
Ну да, если они равны высоты, или даже их высоты отличаются на плюс-минус один, обратите внимание, да? То есть, если тут, действительно, тут h, а тут, допустим, h плюс-минус даже один, то, в принципе, вообще думать не надо.
Просто объявить Васю корнем, подвесить два дерева и возрадоваться. Все.
Вот. Ну хорошо. Так, хорошо. А есть у них все-таки высоты прям вот разные. Вот у нас тут высота h, но h1, а тут h, но h2.
И тут Вася. Что тогда делать?
Так, спустимся. Да, пойдем. Ну даже не, скорее во правого-правого, ну-ка скорее. Ну в принципе та же технология. Правда, есть, правда, одна маленькая, тонкая разница.
Тонкая разница заключается в том, что вот этого, вот на правом пути вершины высоты h2 может и не оказаться.
Вот. Но, ну как, да, если конкретно высоты h2 не будет, то будет высота h2 плюс-1 и h2 минус-1, правда? Есть такое подозрение, да?
Вот. Ну поэтому находим какую-то вершину на глубине, ну допустим, от h2 до h2 плюс-1. И тогда что мы делаем?
Высоты. Вот так. Чтобы высота под... Ну, например. Хотя надо подумать, как нам выгоднее.
Ну хорошо.
Ну это просто не поможет. Возможно и так, и так будет приятно.
Но неважно. Но нет, на самом деле ничего страшного не произойдет. Потому что, значит, смотрите, вы найдете вот этот дерево, вот у него родитель.
Тогда что вы делаете? Вы объявите, что правый ребенок вот этого родителя это Вася. И к Вася подвесите вот эти два под дерево, правда?
Что может произойти? Тогда мы, ну в этом случае понятно, мы гарантируем, что у Васи теперь, значит, глубина теперь точно высота h2 плюс-1.
В принципе, могла возникнуть такая нехорошая ситуация.
Да, что давайте посмотрим. Вот у левого какая глубина может быть?
Я боюсь, тут все хуже. Если вот эта высота h2 минус 1 до h2, то в принципе тут получается глубина от h2 минус 2 до h2 плюс-1.
Вот. Поэтому мы по этому понимаем, что просто так, ну вот поэтому, что просто вот так смертно, что у нас даже плохо.
Потому что если бы тут неожиданно у этой вершины глубина оказалась там на 2 больше, то тогда мы просто делаем, с этой ситуацией мы уже сталкивались в инсерте, помните?
То есть инвариант прям идентичен, поэтому прям просто вот там поворотами добиваемся того, что надо.
Но если глубина 3, то у нас проблемы. Что же делать? Можно было найти более подходящую вершину.
Можно. Ну можно просто сказать, что давайте просто с h2 минус 1 не связываться, а просто связываться с именно h2 и h2 плюс-1. Все-таки как раньше и хотели.
Тогда мы замечаем, что, ну вот, тогда что тут может произойти? Ну да.
Ну да. Нет, ну давайте смотреть. Нет, то же самое, да, не то же самое.
Смотрите, потому что да, формально говоря, если совсем в тупую анализировать, то тут глубина h2 минус-1, значит, то есть может быть h2 минус-1, h2 плюс-2 теоретически.
И кажется, может быть такая ситуация, когда тут h2 плюс-2, тут h2 минус-1.
Но мы замечаем маленький тонкий момент. Для того, чтобы тут было h2 плюс-2, теперь нам нужно, чтобы тут было h2 плюс-1.
Понимаете, да? А тогда у нас здесь h2 минус-1 не будет. У нас же все хорошо было, значит тут как минимум h.
Потому что более точно анализ здесь провести лучше так. Смотрите, то есть да, то есть на самом деле сказать, что тут была какая-то высота, вот я назову ее h2 минус-1.
Х3. Да, и она лежит на отрезке h2 и h2 плюс-1. Вот так.
Тогда, смотрите, тогда если очень аккуратно сделать, то тогда у нас получается, что здесь у нас получается h3 плюс-1. Железно, да, потому что максимум точно здесь.
А здесь мы получаем от h3 минус-1 до h3 плюс-1. И тогда получается просто, что в худшем случае тогда у нас, вот.
И тогда мы получаем, что в худшем случае тогда разность высот между вот этим и вот этим может оказаться 2.
Ну вот, ну и в этом случае мы нужные повороты, конечно же, без труда делаем.
Вот, понятно?
Вот. То есть, то есть, то есть тут возникает просто, да, некоторая, такая маленькая закувычка, но с сохранением вот такой асимптотики, правда?
Пока вроде, то есть, по крайней мере, с мержом разбрались.
Ну ладно, ну да, на всякий случай. Надеюсь, ни у кого не вызывает сомнений, что если у правого дерева высота больше, то мы все можем аналогично сделать, просто симметрично рассмотреть, правда?
Вот.
Вот. А то мало ли там кто-то умер уже, да?
Ну, ну, как сказать, на самом деле, если написать там 0.1 и передавать параметры, то это можно даже без копипасты сделать.
И вот, там у кого-то там такие красивые технологии на эту тему были.
Ну, возможно.
Как-то это хорошая идея.
Так, значит, смотрите, что у нас дальше.
А теперь давайте думать, что у нас будет со сплитом.
Значит, давайте, так ладно, давайте эти картинки с бодерей мы тоже уберем, потому что, вот, а технологию оставим.
Значит, смотрите.
Так, вот нам бы в идеале хотелось бы теперь делать сплит по вот этой вот технологии. Видите, да?
Ну да. И так у нас, ну вот, нет, тут та же схема.
То есть, ищем х. То есть, нам нужно опять то же самое.
У нас есть дерево, в нем х есть.
Как-то если х нет, то можно его сначала туда вставить, а потом развлекаться.
Вот. Соответственно.
И тогда у нас, значит, получается следующее.
Ну, правда, конкретно ВВЛ деревья, кстати, не сильно критично будет.
Потому что если х нет, то просто у вас эта последовательность в какой-то момент упрется в пустое дерево.
А если одно из этих деревьев там в конце будет пустым, кстати, в общем-то мы сильно не пострадаем, правда?
Значит, поехали.
Значит, что у нас тогда получится?
Что у нас тогда получится?
У нас опять получится, значит, тогда у нас, то есть, как мы берем корень.
Если он оказался меньше х, то мы этот корень, значит, обзываем А1 и отправляем влево вместе с под деревом А1, да?
Вот. Ну, дальше там потом, ну, а ты, в результате, потом получилась та же самая последовательность.
Только, видите, только разница в том, что у нас теперь тут, ну, никакой разницы нет.
То есть, опять, да, как был ключик, так и остался.
Может справа ниже, у нас лево справа ниже, а пирослева ниже?
На каждом шаге, да.
Ну, понятно, да, но понятно, что тут, может, тут на этом шаге, вот, Б1, я его чуть ниже специально рисую, но суть останется той же.
Вот, можно даже так обозвать тут А1, а потом Б2, а потом А3, там А4, Б5, можно так написать, но мы не будем этого делать,
потому что сливать все равно надо с одной стороны.
Да, то есть деревьев суммарно будет меньше, конечно, вот.
Вот.
Но, правда, принципиальная суть это не меняет.
Вот, допустим, у нас А3 и А3, ну и так далее.
И в конце у нас опять АК.
Ну и хочется вроде делать по той же самой технологии, да, то есть давайте смёрживаем, казалось бы, снизу вверх,
всё суммируем, там суммируем, телескопически всё сокращается и радуемся жизни.
Да, но теперь вот возникает маленькая проблема.
Раньше мы это работало, потому что мы гарантировали, что нам нужно две вещи гарантировать было.
Что, во-первых, что тут высоты строго убывают у Альф, и второе, что когда мы смёрживаем, у нас высота становится не менее того,
ну там, желательно, не менее того, что не менее максимальной высоты сливаемого и не более, чем это максимум плюс один.
Но второе мы, впрочем, гарантировать можем, правда?
Потому что помните, мы же при инсекте следили за тем, что у нас высота в итоге не уменьшится, но увеличится не более, чем на один, помните?
Аккуратненько было, да, очень аккуратненько.
А вот здесь у нас проблема, потому что что мы можем гарантировать?
Потому что, смотрите, давайте я здесь вот в качестве ашек запишу, какая высота была у вершины,
когда мы её в исходном дереве.
Вот была такая высота.
Вот h1, h2, h3 и так далее.
Но что мы теперь можем сказать про высоту Альфа1?
Что мы можем сказать?
Мы, к сожалению, не можем сказать, что она равна h1-1.
Мы можем сказать, что она равна, что она где-то от h-1-2 до h1-1.
То есть вполне могло оказаться, что правое дерево по высоте больше, чем левое.
Значит, Альфа2, что про неё?
Ну здесь она тоже h2-2 и h2-1.
Ну h2, конечно, что мы точно можем сказать?
Ну что мы точно можем сказать?
Мы можем точно сказать, что высота h1 точно больше h2, правда?
Но гарантировать, что вот эта высота строго больше этой, мы так просто не можем.
Потому что могло так оказаться, что мы вычли здесь больше, и получилось, что h1-2 равно h2-1.
Но это единственный проблемный случай, но он есть.
То есть могло оказаться, что у каких-то соседних деревьев высоты таки совпали.
Вот, понимаете, да?
Ну как вам сказать?
Понимаете, это на самом деле потенциальная проблема.
Потому что, да, можно даже заметить, что подряд больше, чем двух идущих подряд деревьев совпадающей высотой у нас, конечно, не будет.
Нет, на самом деле даже понятно почему.
Потому что если вот тут h2-1 совпало с h1-2, то тогда, смотрите, тогда h3 не превосходит h2-1.
Нет, ну в идеале хотелось бы снизу вверх.
Нет, смотрите, мы сначала идем сверху вниз, получаем эти деревья, а потом снизу вверх сливаем.
Помните, мы в б-дереве так делали, да?
Пока у нас смысл в том, что применим ту же технологию, попробуем доказать, что все работает.
И вот мы обсуждаем в том, что возникают какие-то проблемы с тем, что у нас некоторые альфы, к сожалению, могут оказаться равными.
То есть мы, конечно, ограничиваем неприятность, доказывая, что трех идущих подряд деревьев с одинаковой высотой у нас не будет.
Я это утверждаю.
Почему я это утверждаю?
Ну просто потому, что если тут так произошло, значит, вот это дерево было именно h2-1, тогда h3 точно не более, чем h2-1, и тогда следующее дерево заведомо меньше.
Вот, понимаете, да?
Но тем не менее, тем не менее обгон все-таки теоретически произойти может.
Ну на уровне, что у нас может быть так, что вот хорошо, тут две равные высоты, а тут мы вот взяли, все пообъединяли, и у нас оказалась высота равная h2-1.
Вот эти два дерева объединили, у нас правое дерево вообще оказалось выше левого.
Не очень хорошо, правда?
Правда, с другой стороны?
Нет, ну да, могло так оказаться.
И тогда, получается, конкретно вот в таком виде доказательства предстает работать.
Что делать?
Все?
Если показать, что асимптотику потом как-нибудь докажем, хочется показать, что у нас не будет никогда ситуации, когда разница отличается на 3.
Потому что потом, ну, что можно сказать?
Можно мы хотим крайне сказать, что у нас есть какая-то последовательность, и каждый элемент отличается от того, что нам хотелось бы не больше, чем, например, с минус каждым 2?
Нет, в принципе, я согласен.
То есть, заметьте, если мы докажем, что вот этот результат может стать выше следующего дерева, но не более, чем на 2, то в принципе нас это устроит, потому что вот эта разность высот там где-то превратится вот в единичке.
То есть ее в единичку запихиваем, тут телескопическая сумма условно сохраняется.
Да, с другой стороны, а верен ли этот факт?
Верно ли, что все работает вообще? Верно ли, что если так написать, оно хотя бы не сломается?
Нет, в смысле, если вы просто запускаете там условно просто функцию merge на каждых двух деревьях, то не проблема.
То есть, естественно, оно все работает.
А что бы ему ломаться-то? Мы просто вызвали merge и все, у нас проблема только в асимптотике.
То есть, даже Больтова, если нас устраивает асимптотика лог квадрат, то у нас тоже нет проблем, кстати.
Обратите внимание.
Но, конечно, да, то есть в идеале, конечно, да, тут возникает вопрос. Вот давайте подумаем.
А можно ли действительно показать, что в результате слияния деревьев у нас не может получиться высота, то есть высота дерева не может стать больше, чем, скажем, высота вот этого максимального дерева плюс, допустим, два?
Вот можем ли мы такое попытаться по индукции доказать?
Так, ну давайте попробуем. Вот жила была вершина, и была у нее высота аж.
Давайте все-таки а1 оставим, ну неважно, поехали.
И жила была у нее дерево а1. Что у нас тут получилось?
Значит, тут было, значит, здесь тут а1, тут тут а1-2, а1-1.
Но давайте думать. Жила и было у нее тут под дерево, теоретически, какое-то большое правое под дерево, вот, хотя неважно, то есть было у него тут условно а2 там какие-то, а2 и так далее.
И вот все вот это мы как-то смерзили, и у нас получилось какое-то единое дерево бета, которое по высоте не превосходит вот высоты аж от а2 плюс два.
Допустим такое, да? Но давайте думать. По умолчанию, конечно, аж от а2 плюс два это меньше либо равно, чем, значит, а1-1 плюс 2, правда?
Ну понятно, что если у дерева высота а1, то, наверное, у него под дерева высота строго меньше, правда? То есть получается, что это меньше либо равно, чем а1-1.
Плюс один, да, спасибо. Так, ну тогда выясняет вопрос. Итак, мы сливаем дерево а1 высоты а1 плюс один, и дерево высоты а1-2 а1-1.
У нас получается, но тогда у нас, как мы уже знаем, результат из слияния двух деревьев получится дерево высоты не более, чем максимальная высота плюс один, правда?
Это мы уже точно знаем. О чем многовато? Мы заказывали, что тут это не более, чем плюс два?
Нет-нет-нет, у нас глубина аж от а2 плюс два. А здесь нам случилось а1 плюс 2.
Нет, погодите. Так, погодите. Мы сейчас по индукции пытаемся доказать, что если мы сливаем прямо снизу вверх прям в тупую, как раньше делали, в чем не заморачиваемся.
Справа оказалось более высокое дерево, по барабану все равно сливаем. Мы пытаемся сейчас доказать следующее. Мы пытаемся доказать, что в результате слияния, значит если мы дошли до дерева а3, то результат слияния по высоте будет не более, чем а3 плюс 2.
Именно а3 плюс 2. Да, именно аж от а3 плюс 2, да. А у нас случилось совсем не это.
Так, у нас получилось не совсем. Аж от а1 это либо а1 минус 2, либо а1 минус 1. Разница в 4 пока что вылезла.
Ну ладно. Хорошо, хорошо, проблема. Хорошо. Тогда нам всяко понадобится воспользоваться фактом того, что у нас трех одинаковых деревьев подряд не бывает, иначе мы точно проиграем.
Нет, ну это, кстати, вполне может быть на самом деле. Вот что-то мне кажется. Нет, ну на самом деле хорошо. Пока я бы хотел выделять такая мысль. Хорошо.
А если мы сейчас переформулируем утверждение так, то давайте так видите, у каждой ажки есть вот эти вот высоты аж, правда?
Да. А давайте попробуем доказать, что результат всех их слияния будет не превосходить вот этой же высоты плюс 2.
Это больше похоже на правду. Больше похоже на правду, да. Значит поехали. Смотрите.
Тогда, значит, если тут у нас был результат, он не превосходит, значит высота тут аж было меньше, поэтому не происходит аж 1 минус 1, значит не происходит аж 1 плюс 1, да, как можно сказать.
Но тогда слияние дерева аж высоты не более чем аж 1 плюс 1 и дерева там какой-то высоты уже не важно какой, тоже не больше чем аж 1 плюс 1, явно даже меньше.
Но тогда он тоже получится не более чем аж 1 плюс 2.
То есть вот такая вот технология.
Так. Нет, пока баги нет. Утверждение по индукции доказано. Вопрос, что оно нам дает?
То есть бага скорее подозрение мне кажется больше вызывает, собственно, а как бы приводит ли это нас там к победе.
Вот, понимаете, да?
Ну а давайте смотреть внимательно. Ладно, согласны ли вы с тем, что мы действительно доказали, что в результате такого слияния там, собственно, получится дерево высоты не более чем аж 1 плюс 2?
Хорошо?
Вот.
Кстати, вытекает вопрос, интересно, а плюс 1 мы тут доказать не можем так по индукции?
На самом деле?
Ну, кстати, можем. Если у нас, по крайней мере, переход индукции доказывается легко, обратите внимание.
Так что все, что нам остается, так что на самом деле проверить плюс 1 или плюс, или может быть тут вообще даже не плюс 1, а можно там что угодно ставить, хоть минус 57 на самом деле.
Обратите внимание, да? То есть на самом деле, что нам поможет сказать, что я тут в точности могу написать, это, конечно, база индукции.
База индукции, да?
Вот.
Но с другой стороны, ну давайте смотреть, потому что база индукции, это когда у меня вот этой вот А2-шки уже нет, правда?
То есть база индукции, это когда у меня здесь вот осталось А, и тут два дерева, и тут какая-то высота аж.
Но в результате слияния двух этих деревьев, ну в результате этих деревьев теоретически высота может уйти в аж плюс 1, а может, правда, и не уйти, потому что заметим, что у нас просто есть два дерева, просто вершина и слияние.
Кстати, вот действительно возникает вопрос, а может мы тут на самом деле просто больше, чем аж, не получим?
Не, не может. Потому что, смотрите, тут меньше либо равно аж минус 1, и тут меньше либо равно, чем аж минус 1, да?
Тогда, смотрите, когда мы их объединим даже вот на этом уровне, ну или в другую сторону, то тут высота увеличится на 1 и будут какие-то повороты, но все равно в этом дереве выше чем аж вы не получите.
Поэтому вывод на самом деле крутой, то есть на самом деле оказывается, вот действительно, можно по индукции заявлять себе, ну вот, то есть на самом деле окажется, что мы получим не выше, чем аж 1.
То есть, смотрите, если мы тут получим не выше аж 2, которая, собственно, не выше, чем аж 1 минус 1, то тогда получается, что при слиянии вот этих деревьев мы получим дерево в высоте не более, чем аж 1, и все в порядке.
То есть получается, вот действительно крутизна. То есть получается, что мы получим, то есть на каждом шаге мы получаем дерево не выше, чем, то есть здесь не выше, чем, то есть не выше, чем аж, там, ака 1 бывшая, тут не выше, чем аж, ака минус 2, ну и так далее.
Правда, ну вот, ну возникает, правда, теперь такой маленький вопрос. Как это нам, как конкретно это нам помогает победить вот эту асимптотику? Потому что, к сожалению, про, там, вот эти вот, ну вот, про разности вот этих вот альфа ашка минус 2 ашка альфа ка минус 1, по-моему, нам это пока не поможет. Победить.
Ну-ка давайте, как говорится, как эту проблему теперь за минуту решить?
Чего? Как это называется, да. Как говорится, да.
Ну да, то есть, на самом деле, да. То есть, идея такая, что, в общем-то, вот эти все ашки, они от, вот, тех ашек отличаются на, там, от единицы, правда? Ну, там, на единицу двоечку.
Поэтому, в общем-то, мы можем теперь заявлять, вот, что, на самом деле, действительно, эти, ну вот, то есть, там, эти мержики у нас, ну, хотя нет, тут не совсем, ну вот, то есть, да, отличаются они не меньше.
А еще высота при слиянии тоже не уменьшается, да. То есть, мы не можем слить, там, дерево высоты 7 и дерево высоты 2 и получить дерево высоты 5, правда?
Вот. То есть, у нас, по крайней мере, так слияние у нас устроено. Вот.
Но тогда получается, что, ну, если совсем вот так формально писать, да, то у нас получается все за от единицы плюс там модуль, допустим, hk-1-hk. Ну да, то есть, в реальности там, конечно, вот, действительно, модуль разности этих деревьев, да.
Вот. Ну, точнее так, здесь, ну вот, мы замечаем, что у этих деревьев, действительно, они отличаются на плюс-минус 2. То есть, вот этот модуль отличается от этой вот модули разности этих вершин не более чем на, условно, там, 4, да.
И эти 4, собственно, вот в этой вот, в константу 1 спокойно впихиваются, правда? Вот.
Да? Ну.
Хотя, на самом деле, не этот бронё. Вот этот, вот это под дерево, оно может быть очень-очень-очень сильно меньше, на самом деле. Да, но это и не... Ну ладно.
А, кстати, начнём с того, что hk вообще не существует.
Ну там, да, ну ладно, допустим, за от единицы плюс hk мы это успешно делаем, да?
Ладно, теперь вот эти слияния. Тут дерево высоты от, то есть, дерево альфа к-2.
Оно имеет высоту, значит, от hk-2-1. Так, давайте нарисую, да. Вот. У нас есть вершина ak-2. У неё есть под дерево альфа к-2.
Значит, тут высота была h2, значит, тут высота от h-2 до h2-1, да.
И тут у нас результат слияния, значит, получился не превосходящим чего, бывшие высоты этой вершины, то есть hk-1, да.
Так, тут hk-2, если что, да. Понимаете, да?
Ну вот, с одной стороны. Но с другой стороны обратите внимание, результат тут больше либо равен, чем hk-1-2.
Потому что мы помним, левое под дерево здесь, как минимум, было хотя бы такой высоты, помните, да?
Поэтому с точностью, да, там, плюс-минус 4 мы можем утверждать, что здесь там, ладно, можно так написать, от 5 плюс, там, значит, модуль, там, скажем, hk-2.
Ну, тут можно модуль не писать, минус hk-1, даже без модуля.
Ну да, но для понятности мы это тоже бы написали, ничего страшного.
Ну, помните, мы в сплэй-тереве тоже там себе писали, что у нас там 2 плюс что-то там, да.
Ну, а плюс-минус 2 было, но ничего страшного там.
Так, hk-3 минус hk-2 здесь аналогичным образом, ну и так далее.
Плюс h1 минус h2, ну там шлеп-шлеп, ну понятно, тут везде там эти вот шлеп-шлепы, шлеп-шлепы, шлеп-шлепы.
И вы представляете, получается логарифм пятачков и h1.
Ну вот, ну и таким образом, да.
Получилось, что, оказывается, даже такая технология в тупую, на самом деле, уже прекрасно работает.
Хотя, на самом деле, если вас, на самом деле, эта технология смущала, то есть, на самом деле, потому что ей там можно было предложить такое программистское решение.
Ну как бы да, если вы видите проблемы в доказательстве, что делать?
Либо написать более крутое доказательство, либо просто написать код, который железобетонно работает.
Да, на олимпиаде чаще, конечно, второй работает, потому что так быстрее, правда.
Ну потому что, на самом деле, ну вот, пока у меня изначально была опция, на самом деле, просто говорить, давайте идем сверху вниз, если встретили два равных дерева, а давайте их тупо на месте смержим.
Вот тупо на месте смержим, если там следующее дерево по высоте оказалось равно предыдущему, то значит тоже смержим.
Ну, практически, вот просто кладем деревья в стэк, и в случае чего там просто стэк уменьшается.
Понимаете, да, то есть, это все равно все делается за О от единицы, поэтому, ну вот, и на каждом шаге уменьшается количество деревьев, поэтому таких О от единичных слияний будет мало, правда.
Вот. Да, даже если там, ну, если хранится плюс-минус один, правда, могут быть, возможно, те же проблемы.
Ну а нет, просто нет, смотрите, просто поэти, в чем фишка, это даже уже не важно.
Ну, если плюс-минус один, то там начнутся какие-то обгоны, может, лучше не рисковать.
Вот. Потому что, как бы, если вы добиваетесь вот этого равного типа вот мержим, вот так телескопический мержим, то в итоге у нас оказывается, что эти, значит, глубины тогда строго убывают, и тогда остаток можно вот так сверху вниз спокойно мерзить.
То есть, можно было вот так выкрутиться на самом деле еще. То есть, такой программистский такой более надежный метод, но, как мы убедились, на самом деле, и необходимости-то в нем толком нет.
То есть, на самом деле, как говорится, и так сойдет. То есть, тут, конечно, больше проблем в том, чтобы это очень аккуратно сформулировать и доказать, но вот, идеи, наконец, думать не надо.
Так, эх, 17 минут осталось, да?
Вот. Не, просто пролетаю туда. Принципиально новую тему не начнешь, то ладно. Теперь тогда такой, может быть, вопрос уровня правды, уровня бога. А красно-черное это не умеет?
До связи.
Ну, там.
Ну, что сразу это?
Конечно же, умеет.
Ну вот, да, у нас еще есть. У нас, оу, чудо, у нас остался красный маркер. Вот жалко у нас. В прошлый раз вообще кайф был. У нас был черный маркер, красный маркер и синий маркер.
Во.
Вот жалко.
Вот жалко, потому что это была красочная лекция.
Вот, значит, смотрите.
А теперь давайте думать,
может ли вот эту местическую технологию,
местическую технологию, действительно, адаптировать на красно-черные деревья?
Ну, давайте, давайте, с самого начала. Уровень изи.
Ну, давайте вспоминать, что у нас было, что такое красно-черное дерево. Красно-черное дерево, это когда у нас вершины бывают красные и черные.
Значит, мы, нет, значит, мы хотим поддерживать что?
Например, мы помним, что у нас у красных вершин нет черных детей. У нас у каждого корень дерева черный.
И что самое главное, до каждого, на пути от корня до любого крестика количество черных вершин одно и то же.
Помним, да?
Тогда мы понимаем, что слить два дерева одинаковой черной высоты, да, то есть, помните, да, это в красно-черном дереве нам все равно, нам плевать на высоту,
нам главное, чтобы черная высота была одинакова, да, вот. И тогда получается, что если у нас есть два дерева высоты BH, корень у них черный, да,
поэтому как бы слить с какой-нибудь новой вершины Х тоже без проблем.
Просто подвешиваем, объявляем эту вершину черной и радуемся жизни, правда? Вот, согласны?
Вот. А теперь, правда, возникает вопрос, а что делать, если высоты оказались различными?
Что делать?
Ну, хотелось бы спускаться, но нельзя.
А что нет? Нет, смотрите, а что нет? Честно спускаемся, все нормально.
Значит, идем, идем, идем. Я жалко, у меня нет синего маркера, но ладно.
Спускаемся, спускаемся, спускаемся, спускаемся. И доходим до ситуации, когда у нас черная глубина равна вот BH2.
Вот тут она была BH1, а тут справа стала BH2. И тут у нас тоже мистическое дерево на BH2. Видите, да?
Так вот, идея такая. Значит, давайте их объединим, но для того, чтобы черная высота оказалась той же, х на этот раз мы объявим красненьким.
Вот, видите, да? Вот так вот. То есть вот тут какая-то связь была, мы ее убили, а теперь она тут есть, вот тут красненький х.
Да, его не видно, но он есть.
Что?
Нет, оно бинарное. Нет, у нас только одно не бинарное дерево, пока это B дерево. Все остальные были бинарными двоичными деревьями поиска.
А элементарно, смотри, мы убили, ну да, вот так вот. То есть это мы могли просто, с точки зрения двоичного дерева поиска, мы эту операцию могли проделать не только к этой вершине, но и как абсолютно любой.
А могли просто объявить х скорким, повесить bh1 слева, bh2 справа?
С точки зрения двоичного дерева поиска было бы все в порядке. Плохо было бы только с точки зрения вариантов красно-черного дерева уже самого.
Да, кстати, приятно. Да, мы действительно можем добиться того, чтобы слева была прям черная вершина.
Правда, у нас есть проблема. То, что родитель х не красной вершины при этом будет, мы гарантировать не можем. Но проблема ли это?
Мы помним, что у нас уже была ситуация, когда у нас все хорошо, глубины все адекватные, там все дерево корректное, только единственная проблема, что там существует одна красная вершина, у которой есть красный родитель.
И это единственная проблема. Как вы помните, в инсорте мы эту проблему уже решали, помните?
Нет, тяжело, это когда мы рэй сделали. А тут у нас там какие-то перекраски-перекраски, пара поворотов и до свидания.
То есть инсорта это еще халява была. Но тогда что у нас получается? Но при этом, давайте вспоминать нот, но при этом обнаружим, что максимум, что у нас могло произойти, опять же, эта черная высота могла увеличиться на один.
Да, в итоге, помните, да? Такое могло быть, но понятно, что на веки вечной после инсорта высота оставаться одной и той же не может, потому что у нас рано или поздно количество вершин станет слишком много и дерево должно увеличиться.
Но черная высота увеличивается не более чем на один. Мы можем оценивать этот мерч за от, обратите внимание, единицы плюс модуль разности именно черных высот.
Ну потому что заметим, что разность длина самого этого пути это не более чем удвоенное вот это вот, правда?
Да, напоминаю, фишка доказательства этого факта базируется на том, что у нас на этом пути нет двух подряд красных вершин.
Нет, нет, нет. Чего шлепать нельзя?
В данном случае написано корректное утверждение.
Так.
Но когда мы попытаемся сделать сплит, у нас будет проблема в том, что у нас эта оценка и там может быть два и мы не можем просто взять и сократить друг друга.
Почему? Ну в смысле, в этим точке мы пишем так, то есть это не происходит не происходит с умножить на вот один плюс там разность высот.
Так что поэтому тут может быть не в шлепе проблема.
Проблема может быть в том, что когда мы делаем вот такой сплит, то есть мы обнаружим, что эти деревья могут не быть корректными деревьями в том плане, что вот корни этих деревьев сами по себе могут и красными оказаться.
Да, это не проблема.
Это не проблема.
Но по модулю того, что от того, чтобы взяли у этого по дереву покрасили вершину красной, то вообще-то у него черная высота увеличилась.
Поэтому тут надо придется еще, может быть там пять превратиться еще в какую-нибудь гадость.
Ну ладно, не превратится.
То есть раньше у нас глубина просто могла тут скакнуть на два, типа могла скакнуть на один, тут скакнуть на два.
А тут получается она могла уменьшиться на один или остаться прежней.
Но правда, получить примерно сопоставимая проблема.
То есть там будут те же пятерки, но суть останется той же, потому что по факту черные высоты могут остаться теми же.
То есть как бы уменьшиться на один или остаться теми же.
Поэтому тут последовательность будет тоже такая.
Последовательность будет неубывающая.
будет там какая-нибудь неубывающая, то можно...
Что?
Да, невозрастающая, да,
как говорится.
Но, тем не менее,
суть останется прежней, потому что, если я в качестве h1
буду писать везде букву
b, это типа бывшая высота черной вершины,
то я могу вот писать вот
ровно то же самое, правда?
То есть, я это
могу писать, я это буду писать,
и, собственно, у меня тоже получится 5 очки, ну или там,
если совсем правильно эти минус-единички писать,
может, там даже шестерочка-семерочка вылезет.
Но, как вы понимаете,
принципиально это не поменяется,
и получается, что даже красночерное дерево
теоретически прекрасно
умеет эти ваши протоэнот
реверсы на подотреске.
Нет, приеда.
Нет, в принципе, получается любое дерево,
у которого вы все делаете там, скажем, сверху вниз,
и там, скажем, можете
посвапать детей без нарушения всяких инвариантов,
там каких-нибудь
красночерных, а в красночерном дереве это так,
равно как и в любом, рассматриваемом нами другом,
тогда получается, что
любое такое дерево, на самом деле,
скорее всего, там
сплитом и мержем,
а как следствие
и всеми операциями на подотреске будет делать.
То есть получается и красночерное дерево это прекрасно делает.
То есть получается, да,
чисто математически, на самом деле,
развитие этого всего можно было остановить и в ВВЛке,
или сказать, что ладно,
лучшее дерево красночерное, потому что там будет
мало поворотов.
Ладно, тут мы, конечно, мало поворотов при сплите
и мерже не обещаем, правда?
То есть мы обещаем только,
что при каждом мерже поворотов будет
не более чем один.
Ну или там может быть... Нет, я не удивлюсь,
честно, я не знаю ответа, но я не
удивлюсь, если выяснится, что там
можно аккуратно доказать, что при этом телескопическом
мерже, на самом деле, у вас там
поворотов тоже будет у отъединиться,
особенно если тут
где-нибудь в процессе там не особо
закачиваться на тему красного корня.
То есть может быть,
не знаю.
Но, по крайней мере, на уровне идеи вот поняли,
что да, то есть декартовый дерево
мы пишем только потому, что оно просто пишется.
А не потому, что там
соответственно.
Так что вот такая вот красивая вещь.
Так что вот такие вот красивые мерже.
Сразу видно, почему я не стал это сразу
рассматривать, потому что, как заметим,
эта вся технология в B дереве, она
наиболее красивая, конечно.
Потому что там, собственно, с высотами все четко
и понятно, а вот в ВВЛке красно-черном
надо еще додумывать чуть-чуть.
Но чуть-чуть. Так, есть ли тут
какие-то вопросы?
Не понял.
Так, не надо.
Ну хорошо, ладно.
Ну ладно, тогда соответственно ладно.
Тогда, думаю, на этом можно пока остановиться
и тогда в на следующем занятии перейти
к дереву OneMDBoss.
Нет, смотрите, значит да.
Видимо, приблизительный план так,
что из деревьев, на самом деле,
две штуки из обязательной программы
у нас такие. Ну, во-первых, раз уж мы
упомянули дерево отрезков, то, наверное,
тупо было бы когда-нибудь не упомянуть дерево
отрезков. Но тем более, что там
есть отдельные, тем более, что там есть
отдельные красоты, на самом деле.
Но, конечно, тут еще возникает вопрос.
Вот это мы с вами пообсуждали вон десятью
способами, как реализовывать черный ящик с
поясом, с инсортом, дилитом и прочими
саксессами предыссессорами при желании.
Вот.
Но возникает
такой естественный вопрос,
как уже, как в кеф-патрик-сорте.
А если мы работаем там с целыми,
не отрицательными числами,
нельзя ли сделать круче?
Вот.
Да, то есть, оказывается, если, как всегда,
очень обнаглеть и сказать,
что у нас памяти там бесконечно много
и любой индекс является
ячейкой в реальной памяти, как
кеф-патрик-сорте, вот,
этот наглеж называется Transnichotomial
Model, вот.
Так что вот в науке так называется.
Вот. То вот
оказывается, да, что можно
попытаться это действительно делать не за log n,
а за
условно там
log log c.
Где c это максимальное
число, которое вы там юзаете.
Вот. Но как это сделать?
Соответственно, к этому мы перейдем
тогда уже на доске
с мелом.
Да, преимущество
мела, он точно работает.
