Думаю, можно начинать. Запись, тем более, тоже стартовала. И кто хотел, тот подключился. Начнем с теории,
опять же, потому что у вас нет отдельных лекций. Ну и периодически я буду переключаться на какие-то
практические моменты. Итак, в прошлый раз мы разобрали штуковые сокеты. В качестве домашнего
задания вам даже нужно было сделать простую реализацию веб-сервера. Но кроме того, с прошлого
года вы помните, особенно 12-я группа, как устроить протокол HTTP. Ну и как мы обрабатываем
протокол HTTP и на каком уровне это все лежит. Вот у нас есть всякие низкоуровневые протоколы,
которые мы не затрагиваем в рамках нашего курса. И поверх этого сетевой интерфейса, то есть что
нужно знать? У вас есть некоторый сетевой интерфейс, неважно, это провод, какой-то VPN,
виртуальное соединение или Wi-Fi. Вы можете отправлять какие-то пакеты через сетевой интерфейс,
которые имеют строго фиксированный размер, в который вы можете запихать полезную нагрузку.
Дальше, внутри этих пакетов запихиваются некоторые IP пакеты. Что есть в IP пакетах? В IP пакетах
у нас уже появляется IP адрес, как отправителя, так и получателя. И на уровне IP у нас определяется
маршрутизация, как от одного компьютера до другого доставить какой-то содержимый блок данных.
Ну а дальше мы можем передавать либо короткие сообщения UDP, либо выстраивать двусторонние
цепи взаимодействия, которые от UDP отличаются тем, что мы можем в две стороны туда-обратно
передавать данные, как будто вы взаимодействуете с каким-то, например, локальным терминалом.
Ну и на уровне процессов тут уже можно выстраивать что-то более высокого уровня,
в частности, протокол TCP, который, по сути, работает поверх протокола TCP, обмениваясь текстовыми данными.
Я не помню, я вам в прошлый раз телнет показывал, телнет, в котором было написано example.com,
да, было такое. Так вот, в чем прикол? В случае с example.com все хорошо, все замечательно,
напоминаю, как выглядит host example.com, обычный текстный запрос и получаем ответ в обычном текстовом виде.
Так, теперь другая проблема, если я напишу то же самое, но, например, не example.com, а какой-нибудь
yandex.ru, google.com, неважно что, любой современный веб-сервер и напишу точно такую же строчку,
host.yandex.ru, то никакого ответа я не получу, точнее, я получаю ответ, но он не содержит никаких данных.
Получается, код ответа http 301, страница постоянно перемещена на какой-то адрес. Это не ошибочный заголовок,
то есть в http все коды, которые начинаются с цифры 1, 2, либо 3, это статус успеха, и их можно по-разному интерпретировать.
Если начинаются четверки, либо с пятерки, это ошибка. И что значит страница постоянно перемещена?
Здесь в заголовке указан location, вроде как тот же самый yandex.ru, но не протокол http, а протокол http с буквкой s на конце.
Что означает буквка s на конце? Значит, что явно требуется шифрование данных, и без этого дальнейшее
действие невозможно. Браузеры обычно это запоминают, и каждый раз потом лишний раз не загружают
yandex.ru по обычным протокол http, а сразу и протокол https. И вот протокол https уже подразумевает шифрование,
и обычным телнетом здесь уже не обойтись. На самом деле верхний уровень процессов, если посмотреть на
классическую модель Ic, которая приводится во всех стандартных учебниках, и которые почему-то
иногда любят спрашивать некоторые HR на собеседованиях. Там еще есть разделение на три подуровня, это уровень
сеанса, уровень представления, уровень приложений. На самом деле в современных реалиях четкой границы
между этими тремя уровнями нет, поскольку в зависимости от протокола здесь любое приложение может
взаимодействовать так, как ему захочется. Итак, на уровне приложений. Вот протокол http, у вас есть четкий
текстовый запрос, четкий текстовый ответ, который в том числе может содержать, например, уровень представлений,
как данные дальше передаются, либо половинтекстом, либо используя какое-то сжатие, но заголовки
вас идут все равно обычным текстом. А вот уровень сеанса обычно подразумевает, что вам нужно
предварительно как-то установить соединение, после этого как-то согласовать сеанс и используя
то же самое http-соединение уже по какому-то другому протоколу выполнять взаимодействие. В частности,
таким образом работает протокол https, на самом деле это обычный телнет, когда отправляются какие-то
команды на согласование сеанса, и после этого уже идет взаимодействие в каком-то бинарном виде
по другому протоколу. В частности, для взаимодействия https, тут мы можем использовать вместо телнета
другую утилиту, точнее это некоторый швейцарский нож всех возможных разных утилит под названием
OpenSSL, и одна из утилит, входящая в поставку OpenSSL, называется sClient, secure client, который
подключается и работает подобно телнету, но уже в the strongly. Команда OpenSSL есть во всех Linux
дистрибутивах, в том числе и в BSD дистрибутивах, включая Mac. Общий вид команда OpenSSL, дальше какая-то
из утилит, входящая в состав OpenSSL, поскольку там много разных инструментов, и вот connect, дальше
яндекс.ру, там много всякого мусора, поэтому уж, конечно, я.ру, ну ладно, будет яндекс.ру, и порт
443, в отличие от 80-го, он как раз явным образом подозревает, что используется защищенным соединением.
Соединяемся, и что у нас происходит? Сначала происходит согласование сеанса, вот OpenSSL нам пишет
кучу всяких протокол взаимодействия, на самом деле вдаваться в подробности здесь пока не обязательно,
здесь сервер отправляет фотосертификат, выполняет свою проверку, в случае, если он успешен, то
клиент генерирует свой ключ, отправит серверу, про это я чуть позже более подробно остановлюсь. Вот и после
того, как выполнено какое-то согласование сеансов, я могу написать строчку get slash htp11 host
yandex.ru, и после этого яндекс меня переодресует на какую-то штуку, пройти какую-то капчу,
потому что он думает, что я какой-то робот, который массово что-то пытается сделать, но ладно,
это уже заморозь к яндексу. Тем не менее, мы получаем уже какой-то другой текст, самое главное,
что здесь мы получаем в отличие от обычных протоколов. Если я запущу какой-нибудь инструмент,
например wireshark, это опенсорсный инструмент, есть под разные операционные системы, неважно
какие, windows, linux, mac, он кроссплатформенный, позволяет мониторить, что у нас происходит
в плане сетевого взаимодействия. Давайте я запущу это wireshark на текущем соединении, он сейчас
будет генерировать огромное количество, видите, сколько данных передается, чтобы не засорять вывод
и понять, как у нас происходит взаимодействие с кем-нибудь конкретным. Давайте зафиксируем,
что мы будем смотреть на вывод example.com, чтобы сфильтровать это все от остального мусора. У него есть
какой-то определенный IP-адрес, для этого напишем фильтр, что IP-адрес у нас ровно такой-то и будем
просматривать, что у нас будет выдаваться. Я пока время выйду из виртуалки, чтобы это действительно
честно отлавливать. Итак, example.com хорош тем, что он позволяет работать так по обычным 80-м
протоколу, так и по протоколу HTTPS. Итак, подключаемся по 80-м порту, что мы видим? Мы установили
какое-то TCP-соединение, то есть мы отправили от нашего источника какой-то пакет у протокола TCP
с флагом SIN начала взаимодействия. Нам в ответ пришел TCP фрагмент, ответ, что это флаг SIN
подтверждение взаимодействия, ну и дальше мы что-то отправили, transmission control, да, ну просто первый
блок пустой, мы готовы что-то писать. Ну давайте напишем get slash HTTP 1.1 host example.com. Отправляем
запрос и ответ, что мы наблюдаем? Огромное количество дальше пакетов на отправку. Вот чем
плох протокол TCP? У него даже на небольшое взаимодействие нужно отправлять огромное количество
запросов. И вот где-то есть содержательная часть внутри протокола TCP. Что у нас вообще представляет
вывод утилиты Wireshark и как это все интерпретировать? Выбираем нужный нам пакет, вот мы отправили
запрос GET по протоколу HTTP. Во что он превращается? Вот наш текст, который мы отправили плейнтекстом.
GET, host такой-то, все. Дальше, этот HTTP кусок, вот он виден в наших бинарных данных чуть пониже,
он в свою очередь заворачивается внутрь протокола TCP, то есть у нас есть какая-то полезная нагрузка,
здесь она выделена зеленым цветом. И что у нас есть еще внутри протокола TCP? Внутри протокола TCP есть
некоторый порт исходника, 53138, порт назначения, вот порт source 5.3.138. Насколько смыслено это число?
Кто помнит с прошлого раза? Это некоторый рандом, который ядро само выбирает. Указывается порядковый
номер пакета относительно всего сеанса. Здесь уже утилита Wireshark сама это пересчитывает
относительно установки соединений, на самом деле в самих TCP заголовках идет сквозная нумерация
от того момента как ядро запустилось и все пакеты у нас как разным образом умируются. А если переполняется,
то сбрасывается и ничего страшного в этом не происходит. Номер подтверждаем пакетом и так далее.
Ну и где-то среди этого, среди, после заголовков TCP у нас уже следует, у нас заканчивается заголовок,
где-то 0D, 0A и после него уже идет полезная нагрузка. До протокола TCP у нас есть заголовок IP
протокола, что у нас содержит IP протокол, который идет до протокола TCP, до заголовка TCP. В заголовке IP
у нас есть размер, identification, разные флаги не очень важные по дефолту, time to leave 64,
протокол нежележащий, это некоторое число. Для TCP это соответствует номер 6, для UDP номер 17,
насколько я помню. Остальные в принципе не используют числа. Вот когда противоположная
сторона получает IP пакет, она смотрит на номер протокола в заголовке и уже понимает,
как дальше интерпретировать следующий заголовок. Ну и самое важное, source адрес и destination
адрес. Ну а дальше это все запихивается уже в Ethernet пакет, у которого есть MAC адрес,
но здесь уже MAC адрес привязан уже жестко к конкретному компьютеру и особо нам не
интересен. Ну и в конечном итоге нам присылают какой-то еще ответ, который точно так же можно
наблюдать. Как обычный плентекст, вот то, что нам прислали. Понятно, что вся информация,
если я ее вижу wireshark, значит все то же самое видят те, кто сидят за маршрутизаторами всех
уровней. То есть вы фактически передаете данные открытым текстом и никакой приватности,
безопасности речи в принципе не идет. Давайте теперь я это все очищу и
сделаем все то же самое, но уже через протокол SSL. OpenSSL as client connect,
тот же самый для честности example.com or 443. Тоже самое напишу строчку get-htp11, host-example.com.
Получает точно такой же ответ, но если посмотреть на вывод в том же wireshark,
что у нас происходит? У нас происходит установка соединения. Дальше мы отправляем заголовок уже
некоторого протокола TLS, он же SSL, это просто два разных названия, двое тоже протокола. Дальше
взаимодействия, обмен сертификатами и когда речь доходит до HTTP в самом конце, где-то мы
отправляем application data, что мы видим? Мы видим просто какой-то application data и какой-то мусор. Узнать,
что мы реально передаем, ни на каких уровнях здесь уже невозможно. Понять это может только тот сервер,
которым мы отправляем данные. И по дороге нет способа как это все разобрать. Для этого как раз
предназначаются безопасные соединения, которые называются, правильным словом, transport player
security. Этот стандарт TLS. Почему я говорю, что есть синоним SSL? Потому что SSL это вообще зарегистрированный
товарный знак некоторой компании Neatscape, которая была кем-то куплена, потом наверняка еще
раз кем-то куплена. Но исторически так называют, потому что многие библиотеки называются SSL. Фактически
одно и то же, только TLS это открытый стандарт. Как вообще можно взаимодействовать по протоколу TLS,
либо SSL? В случае протокола HTTP есть просто приговоренность, что используется отдельный
номер порта. То есть телнетом я подключаюсь к порту номер 80 и текстом взаимодействую. А если я
хочу взаимодействовать с защищенным протоколом HTTPS, то здесь уже приходится использовать другой
отдельный порт 443, и тем самым мы не перепутаем, что мы хотим взаимодействовать по другому протоколу.
Порты меньше тысячи. Если они открываются на сервере, то их можно открыть. Есть два способа.
Первый способ простой небезопасный. Это просто запускать сервер с правами root, хотя это небезопасно,
но единственное, где это может быть использовано, это запускать, например, с ssh сервер. И второй способ,
это локально для выполнения операции bind, делать повышение привилегий для того, чтобы связать
с портом. Как вообще в общем случае это можно сделать? Хороший вопрос. Поскольку у нас сервера обычно
запускаются непривилегированные, то как сделать реализацию сервера, которые работают на порту
меньше тысячи? Есть так называемый сет user ID flag. Например, его можно наблюдать у некоторых
команд, например, классическая команда sudo.
Давайте посмотрим на usr bind sudo, какие у нее права. Чтение запись выполнения для владельца и
чтение выполнений для всех остальных. И еще вот стоит такой флаг под названием s, который называется
sticky bit. А что этот флаг означает? Это означает, что программа, исполняемый файл, который в составе
sticky bit, всегда запускается из-под того же пользователя, в данном случае root, который является
владельцем данной программы. То есть, как можно безопасно открыть порт, который явно меньше
тысячи, и при этом сам процесс запускать не с правами рута? Вы можете написать вспомогательную
программу helper, которая выполняет ровно одно действие, вызывает системный вызов bind.
Почему мы можем вызвать bind из какой-нибудь дочерней программы, передав ей койнт номер socket?
Потому что, когда вы запускаете дочерний процесс, файловый дескриптор у нас наследуется. И файловые
дескрипторы связаны с каким-то объектом, который в ядре персональной системы работает
одинамаково для всех. То есть, локальное решение есть библиотека, которая использует как раз такой
подход и выполняет только bind. Я сейчас сходу не вспомню, как это называется. Но она используется
многими веб-службами, хотя никто не мешает на вам ручками написать. В общем, общий подход как
открыть порт с портом меньше тысячи. Вы запускаете дочерний процесс, и в нем запускаете через exec
маленькую программку, у которой стоит setUserIdFlag стикибит. Это не стикибит, это
называется suidflag, setUserId. Выставляет setUserIdFlag, и она выполняет только операцию bind на
файловый дескриптор с определенным номером. И связывает его с определенным номером порта.
И завершает свою работу. Поэтому весь сервер у вас может работать без рута дальше, и все достаточно
безопасно. У нас есть 80-й порт для HTTP, 440 для HTTPS. В некоторых случаях вы можете не открывать
отдельный порт, если вам требуется защищенное соединение. Например, протокол почтового сервера,
он поразумевает, что вы в текстовом виде начинаете эмоциировать тлс-сессию просто
отдельной командой для переключения в режим тлс. Здесь как вы договоритесь, так и исключите.
Зачем это бывает нужно? Мы могли наблюдать через Wireshark, что у нас данные теперь перехватить
в принципе никак невозможно. А для чего наши данные могут перехватывать? Во-первых, если мы
заедем в кафе Теория, там есть бесплатный Wi-Fi. Он без пароля. Чем плох Wi-Fi без пароля, кто знает?
Ну, казалось бы, да. Там требуется авторизация, нужно один раз ввести номер телефона и подтвердить
мак-адрес. Тем не менее, Wi-Fi без пароля подозревает, что шифрование данных вообще в принципе не
используется. И данные в пределах этой кафешки летают в не зашифрованном виде. Запускайте
снифер и начнете раздвигаться. Второй момент, в московское метро. Что? В программе Wireshark? Да, нет.
Но чтобы Wi-Fi ловить, вам еще дополнительные тулзы нужны, чтобы прослушивать именно трафик.
Для телефонов такое есть. Во-вторых, в московское метро бесплатное. Сейчас они вроде бы поправили,
раньше, точнее сейчас не только поправили, в московском метро стало бесполезно. Так же,
как и некоторые нехорошие мобильные операторы, не буду называть их названия, любили подмешивать
свою рекламу в обычный Http-трафик. При этом иногда ломался ежимая страница, падла сверсь,
невозможно пользоваться. Плюс есть некоторые протоколы, которые поверх Http, например,
Microsoft Exchange Server работает. Тоже они выдавали кучу ошибок. Ну и банальное шифрование данных,
оно всегда полезно, чтобы никто не подглядывал. Поэтому сейчас очень сложно встретить ресурсы,
которые работают только, например, протокол Http без шифрования. Есть только Example.com,
поскольку его назначение так раз демонстрировать, как устроен интернет. Все остальные ресурсы уже
давно перешли на Http с принудительным образом. Причем стало это возможным относительно недавно,
почему все ресурсы перешли на зашифрованный протокол. До этого сертификаты стоили достаточно
ощутимых денег, и нужно было их покупать за деньги. И на самом деле многие делали деньги из воздуха,
просто продавая сертификаты. Сейчас можно купить на бесплатном ресурсе Ветсенкрипт, даже не купить,
а бесплатно получить для своего ресурса. И бесплатная польза, например, на Еджа же стоит,
денег не просят, вполне себе безопасна работа. Что такое Http? Я про это напомню. Для шифрования
вот протокол Http требуется специальный сертификат, который является кем-то подписанным. Я чуть позже
расскажу, зачем он вообще нужен. Хотя в общем случае, на самом деле, с технической точки зрения,
он не нужен. Если вы доверяете самоподписанному сертификату, который вы сами выпустили на
своем сервере, раскидали по своим ресурсам, по своим клиентам, этого вполне достаточно. Но на
общей публике вы должны кому-то доверять. Теперь краткий обзор, какие вообще бывают
криптографические алгоритмы. Они бывают в трех разных видов. Во-первых, это алгоритмы,
которые по какому-то блоку исходных данных произвольного размера строят блок данных
какой-то фиксированного размера и получают просто некоторое число определенного размера.
Например, бит четности. Это тоже в какой-то мере криптографический алгоритм, который по произвольному
биту данных, под произвольным данным говорит, четная получается ваша сумма или не четная. Это
простейшая хэш-функция. Есть хэш-функция более сложная CRC32, которая обычно используется для
контроля целостности файла и более популярные MD5 и SHA. Что это за функции такие, как ими
пользоваться? В большинстве дистрибутивов есть вот такие команды, например, MD5SUM или SHA256SUM,
которые по произвольному файлу считают какое-то число. SHA еще 512 бывает.
Так, технологий программирования у вас были, да? Вот такие длинные цифры. Где эти вам раньше
встречались технологии в программировании? Не только токен, а еще у гита используется SHA256 для того,
чтобы однозначно определить какой-то конкретный комит. Точнее у гитхаба, у гита, там он сокращается,
то есть средняя часть вырезается. Можно по сокращенному варианту первые и последние цифры
достать, но в случае, если есть неоднозначность, то можно полностью написать полную длину хэша.
Ну да, то есть очень высокая вероятность, что хэш будет уникальным, если взять только его
начальные цифры и конечные цифры, но если он не уникальный, то можно в дите по крайней мере
использовать полную хэш. Так вот, что такое хэш? Это некоторое значение, которое всегда является
уникальным для разных дан. На счет всегда, тут на самом деле это не совсем так, поскольку мы никак не
можем взять из хэша обратно данные, восстановить и поставить строго точное соответствие. И понятно,
что есть возможные комбинации. Например, для алгоритма MD5 у нас два в 128 степени разных комбинаций
вообще всех любых объемов данных, которые только могут быть. Понятно, что есть какая-то вероятность,
что для двух разных данных, разных кусков данных у нас получится одинаковый хэш. Такие ситуации
называют хэш-коллизиями, и чем больше у нас длина хэша, тем меньше вероятность хэш-коллизии.
И есть отдельные задачи для хакеров. Это нахождение осмысленных каких-то одинаковых данных,
для которых хэши совпадают. Такое решение, задача называется компрометацией хэш-алгоритма.
MD5 уже давно скомпрометирован, то есть подобраны такие данные, для которых хэши совпадают.
Для SECHE256, я не помню, для неосмысленных каких-то рандомных данных это подобрано,
для осмысленных пока еще нет. Для SECHE512 пока еще нет. То есть это считается устойчивым,
не взломанным хэш-алгоритмом. То есть мы можем гарантировать, что если у вас данные совпадают,
то хэши их совпадают. Где на практике используется хэш-сумма? Например, скачать какой-нибудь
дистрибутив, рядом обычно с большим файлом лежит контрольная сумма по одному из алгоритмов,
fmd5 либо SECHE256. Для чего она нужна? Для того, чтобы посчитать локально контрольную сумму и удостовериться,
что во-первых, файл не был поврежден при скачивании и скачался полностью до конца. Во-вторых,
чтобы скачали его из правильного источника, он не модифицировал. Например, если это код из зеркала.
И еще один способ применения – это файл с базой данных пользователей и паролей,
и tc-паспорт. В современных UNIX-системах он, конечно, не хранится паролей одновременно, но можно
посмотреть на файл tc-shadow, который хранит только пароли. Он, правда, доступен только из-под рта
для увеличения безопасности. И по какому-то из алгоритмов хэширования, я уже не помню какой
здесь у меня, в большинстве случаев это какой-нибудь blowfish, хранится пароль. Можете ли вы восстановить
мой пароль на этой системе? Наверное, это возможно только методом прямого перебора,
что займет очень много непозвонительного времени. Хэши обычно используются в межных целях, в том числе
для того, чтобы хранить пароли. Можно использовать в том числе алгоритм md5. Для этих целей его обычно
бывает вполне достаточно, не обязательно использовать с lch. Допустим, у меня есть пользователь Вася,
который хочет слагониться в систему. Что должна сделать система? Кроме команд md5 есть аналогичная
команда в составе фреймворка OpenSSL, которая работает похожим образом. Закодируем какой-нибудь
пароль, например, самый популярный пароль qwerty и направим в пателете md5. Если пользователь вводит
пароль qwerty, для него вычисляется какой-то хэш. Этот хэш один раз может храниться как правильный,
потом пользователь, например, входит с неправильным паролем. Что у него будет? У него будет какой-то
другой хэш. И сравнивая только хэши, можно принимать решение о том, допускаем мы пользователя
систему или не допускаем. И по хэшу обратно декодировать пароль у нас не получится. Кстати,
вот в нулевые годы по телевизору зомбоящиков как-то в новостях активно педалировали всякие дурацкие
абсолютно новости. Например, о том, что какой-то школьник сделал супер крутую мега операционную
систему сейчас Windows станет нужда, слава России. Что операционная система себя представляла?
Назвалась на BOLGNVS. Куча мемасиков про нее в интернете распространилась, может даже и живые.
Просто убонту с другими нескучными обои. Одна из новостей в контексте таких же новостей,
которые журналисты пиарят, сами не понимают техническую составляющую, какой-нибудь школьник
российский сделал супер мега софт архиватор, который сжимает очень сильно. Архиватор имеется
в виду обычные утилиты хэширов. Понятно, что это все ерунда, верить такому нельзя, и по 128-битному
значению нельзя декодировать обратно какие-то произвольные данные. Здесь, возможно,
трансляция данных только в одну сторону. Допустим, у нас есть база паролей, вида, что есть
я сделаю свою базу паролей, по названию, что есть пользователь с ID 1000, которого зовут Вася,
у которого пароль вот такой-то. Как ты захэшировал? Пользователь с ID такой-то, по названиям Петя,
у которого хэш какой-нибудь, например, вот такой.
Казалось бы, хорошая безопасная система хранения паролей, согласна? И, например, есть пользователь
под названием Admin, который может делать все что угодно, даже пользователь root. И так случайно
совпало, совершенно случайно, что пароль хэш вот такой, что злоумысленник может,
получивший доступ к этому файлу, сказать про пользователя root.
Да, злоумысленник может понять, что есть пользователь Вася, можно подойти к Вася,
сказать Вася, скажи пароль. Если Вася не хочет говорить пароль, можно на Вася как-то воздействовать,
материально, физически, еще как-нибудь, и добыть пароль Вася. Если мы добудем пароль Вася, то что
получается? Мы добыли пароль root. Такая система явно небезопасная, и для рандомизации какой-то
хэшей обычно дополнительно используется какое-то еще одно значение. Что мы можем здесь, как мы можем
эту ситуацию исправить, чтобы гарантировать, что даже при одинаковых паролях у нас всегда будут разные хэши.
Дописывать какое-то уникальное для каждого из пользователей значение до хэширования,
и считать это частью пароля, используя какой-нибудь нелегальный символ, который им не в пароли не может
встречаться. Например, user ID, либо имя пользователя. Если мы хэшируем пароль не просто qwerty, а qwerty
собака Вася, то мы получим один хэш, qwerty собака root, какой-нибудь другой хэш. Они
гарантированно будут различаться, и вот такая операция по добавлению к данным каких-то дополнительных
сведений для того, чтобы сделать их более разнообразным, называется добавление соли.
Солью мы еще чуть дальше более подробно обсудим, когда будем использовать блокчина эшифрования.
В Linux в дистрибутивах обычно этот файл защищен, во FreeBSD, насколько я помню, он не защищен.
В Linux хранится в отдельном файле, на счет FreeBSD не помню. Обычно тоже делается запрет на
доступ, но кроме обычной базы пароля в Unix бывают разные другие стемы авторизации, где можно
достаточно легко получить доступ. Банально в базе данных SQL доступ пользователя к сайту, если вы
получили доступ к базе данных, если какой-нибудь пользователь, задача которого выполнять по счету
статистики или выполнять обслуживание базы данных, то все равно у вас есть какой-то доступ к паролям,
потому что у вас есть доступ к базе данных. И если вы храните пароли плейнтекстом, ну некоторые так и делают,
да, я думаю, если почитаете хаббор, поиск по информационной безопасности, будет описание
многих разных кейсов, когда реально хранятся пароли плейнтекстом и каким последствиям это приводит.
Просто вот из-за банальной глупости. Если хотя бы хэшировать, тогда уже такой глупости не возникает.
Если вы хэшируете не только пароль, но пароль с добавлением соли, то такой проблемы нет.
Более того, есть разные движки, типовые там Django, например, или какие-нибудь движки там типа WordPress.
Типовой софт, который имеет свою какую-то базу данных использовать. И там обычно есть еще при установке
генерации своего рандомного токена, который хранится строго закодирован для конкретного сервера,
на тот случай, если пользователь вдруг с одинаковым именем, одинаковым паролем, будет регистрироваться
в разных сервисах на одном и том же движке, чтобы добавить еще какую-то соль дополнительную уже
привязку. Совпадающие хэши это как раз в зависимости от того, какой хэш вы выберете. Как раз хорошая хэш-функция,
идеальная хэш-функция, она подразумевает, что для разных данных у вас будут всегда генерироваться
разные хэши. Поэтому такая вероятность, она стремится к нулю. Если вы используете SCE 512,
то очень малая вероятность, что на 10 миллионов пользователей у вас такая ситуация возникнет.
То есть понятно, что если вы выбраете MD5, такая вероятность повышается. 512 битных ключей с
LTE, свою проблему уже не должно возникнуть. И об этом можно не заморачиваться с практически точки
зрения. Хотя, если будут кланаты вычисления доступные, тогда все пропало. Это то, что было
про хэш-функции. Что такое хэш-функции с алгоритмической точки зрения? Я думаю,
на алгоритмах вам рассказываю, как они реализуются. Тут плюс-минус все стандартно.
Другой класс алгоритмов – это блочное шифрование. Причем для них может использоваться некоторый
симметричный ключ. Что такое блочное шифрование? Это когда вы бьете данные на блоки код фиксированного
размера и каждому из блоков применяете какое-то преобразование. Одним из самых простых преобразований
является шифр Цезаря с ключом. Бывает, кстати, блочное шифрование не обязательно подразумевает,
что вы используете какой-то шифр, подразумевающий наличие ключа. Давайте сделаем какой-нибудь файлик,
чтобы было с чем работать HelloText. Этот файлик теперь с помощью утилита OpenSSL закодируем во
что-нибудь. Кодирование и декодирование OpenSSL вставляется командой Yank. Кодирование прямой – это
без двукоцин, минус D, это в обратную сторону. Закодируем с помощью шифра base64 наш файл HelloText.
Закодируем полное название команды OpenSSL, закодировать. Дальше название шифра, например,
base64. И in-out – это если не нужно работать с стандартом ввода, стандартом ввода. Да, в ридинг
немного хабидно, подробно описаны все команды, которые вам понадобятся. И вот получаем какую-то
штуку. В чем особенность этой штуки? Эту штуку я могу теперь обратно декодировать, указывая тот
же самый алгоритм base64. Я не указываю теперь имя входного файла и в этом случае вторая часть
команды OpenSSL, просто прочитая все стандартно потока ввода. И обязательно опцию минус D. И получаем
обратно декодирование хлыб. И обратите внимание, что здесь у меня утилита OpenSSL не запрашивает
пароль ни в каком виде, потому что бывают алгоритмы, которые ключ не требуют. Кстати,
что за вывод такой? Получился S, G, V, S, B, G, 8K. На самом деле это просто какая-то последовательность
латинских букв и цифр. В случае с текстовыми файлами это не особо осмыслено. А вот если я применю
это к какому-то бинарному файлу, такое становится уже более осмысленным. Я получаю какой-то текст из
abracadabra, который как-то даже красиво отформатирован, но содержит внутри себя только ограниченный
набор кодировки ASCII. Для чего бывает полезен шифр BS64. Он сделал размер нашего файла намного больше,
поскольку он использовал только 64 символа из ASCII. То есть каждому байту соответствует только 64
элемента. Это понятно, что у нас очень сильно увеличивается объем данных, но зато мы можем теперь
скопипасить вот это как обычный текст и использовать систему передачи данных,
которые могут работать только с текстом. Например, электронная почта, как ни странно, это тоже текстовый
протокол. Когда вы нажимаете в почтовом приложении приложить файл, файл кодируется одним из образов
либо OE, либо BS64, и дальше таким плейнтекстом вставляется содержимое вашего письма как приложение.
Везде, где нужно использовать передачу текста, BS64 позволяет закодировать данные так, чтобы они
гарантированно не повредились, неважно какая у вас кодировка, неважно как вы текст форматируете,
все равно вы дальше обратно сможете восстановить ваш файл, и этот файл будет в точности до байта
совпадать. Ну и все-таки более смысленно использовать BS64, это использовать
блочное шифрование, это использовать какой-то из шифров, которые уже требуют ввода какого-то ключа.
Минус IES, да, название, например, IES 256, это один из алгоритмов. Так, здесь уже требуется ввести
какой-то пароль, например, самый популярный пароль, и получаем какой-то мусор винарный,
с которым можем дальше что-то сделать, например, сохранить
какой-то зашифрованный файл. Так, вот я еще, так, выбираю QRT.
Ну и вообще-то теперь, у меня получился файл примерно такого же размера, на самом деле,
не совсем такого же. И что я могу с этим файлом сделать? Я могу теперь выполнить к нему обратную
операцию. Так, в качестве входного файла я указываю это Hello Young, минус D чтобы делать обратно,
но поскольку у меня ожидается текстовый вывод, я не указываю имя выходного файла. Так, теперь,
если я ввожу правильный пароль, то я получаю содержимое этого файла. Все хорошо, все замечательно.
Так, если я ввожу неправильный пароль, то я получаю некоторую ошибку, причем здесь,
в зависимости от того, какой алгоритм используется, мы можем либо поймать эту ошибку на
стадии декодирования, либо получить просто неправильный ответ. Например, вот классический
шифр Цезаря со сдвигом там на определенное количество символов, он не контролирует ошибки,
но получается какой-то мусор. А ворнинг кидают? Депракейка и деривейшн. У меня просто в поставке
не стоит утилита для проверки паролей по словарю. Это, кстати, кидается в поток ошибок,
поэтому он не будет записан в файл. Такие у нас бывают наиболее популярные криптографические
на самом деле их много, но исторически одним из первых и когда-то популярных был алгоритм ДЭС,
когда-то его даже студентов заставляли писать его реализацию. Сейчас используется в основном
один из двух, либо алгоритм АЕС, это американский, но и его аналог под названием Ghost 3412-2015,
но просто потому что у нас в России требуется в некоторых случаях использовать российский
криптографический алгоритм. Там где-то требуется, там используется алгоритм Ghost и вообще его называют
кузнецик. На самом деле они работают по одному и тому же принципу. У вас данные бьются на блоки
фиксированного размера, каждому блоку по отдельности применяется некоторая последовательность операций
из применения ключа по какой-то схеме со сдвигами, по разрядным операциям и так далее.
Причем для каждого блока применяется несколько раз несколько итераций применения ключа из
входного блока, называется один раунд, обычных несколько раундов и все это потом сохраняется в
качестве итогового результата. И причем здесь очень важно, что для криптографических алгоритмов
с симметричным ключом эта операция является обратимой, если вы знаете ключ. Какие есть параметры
у алгоритмов с симметричным ключом? Самый главный параметр это размер блока, он же размер ключа,
и этот параметр фигурирует в частности по названию алгоритма AES-256. Здесь подразумевается ключ
размером 256 бит. Чем больше у вас размер ключа, тем более стойкий у вас алгоритм шифрования.
Можно посмотреть с помощью команды pencil-eng, swifters или еще более простой это лист. Вот такая
команда отображает список всех поддерживаемых в данной поставке OpenSSL алгоритмов шифрования.
Причем в разных дистрибутивах, в разных системах они могут быть разными. Например, в Debian это один
список, российский Alt Linux, Astro Linux или еще что-нибудь, там еще наверняка будет какой-нибудь
алгоритм Ghost, например в Mac тоже. Не странно, в Mac поддержка Госта, правда 89 года тоже есть,
а более современный по-моему здесь отсутствует. Что еще есть у алгоритмов шифрования из параметров,
кроме того, какой разрядность ключа они используют. Даже у одного и того же алгоритма AES,
256. Есть разные вариации по кодируем. CFB, CTR и ECB. Что это такое? Это способы, как у нас применяются
данные к разным блокам шифрования. Здесь возникает некоторая проблемка о том, как мы включаем камеру.
Надеюсь, что-то будет видно на этой доске. Так, если не видно, говорите. Давайте закодируем
какую-то последность данных. Я постараюсь пожирнее рисовать. Видно что-нибудь? Вот у нас есть блок данных.
Или не видно? Похоже, это потрачено.
Так, тогда будем учиться рисовать на доске.
Вот у нас есть какой-то блок данных.
Мы бьем его на какие-то кусочки равного размера. Так, мы знаем какой-то ключ.
Теперь, как мы получаем подходу к данным? У нас есть ключик. Мы каждому блоку применяем
вот этот ключик. На выходе получаем какой-то результат. Раз блок, два блок вместе с ключиком.
Куча независимых кусочков. Вот такой алгоритм шифрования называется ECB, он же электроник код-боку.
Чем такой способ кодирования хорош? У нас каждый блок, по сути, независимо при чем, кодируется как
отдельный блок данных. Чем это хорошо? Тем, что вы можете пропустить огромное количество данных,
и вам не обязательно декодировать все до начала. Взять и зашифровать, либо разшифровать,
только один кусочек. И середина. Да, вы можете этот поток просто пропустить,
но зная какие у вас есть предыдущие куски, если вы знаете хотя бы один кусок, либо вы знаете
какую-то закономерность, то вы можете легко зашифровать. Есть классическая картинка по этому
поводу, которая называется ECB-пингвин.
Вот, пингвинчик исходный.
И что будет, если мы будем применять вот такое алгоритм шифрования к нашей картинке? Понятно,
что мы данные испортим, и картинка станет не похожа на то, чтобы она стала другой. Мы кучу
данных потеряли. Мы потеряли данных о том, какие тут цвета, некоторая точность пикселей и так далее.
Но в целом очертания пингвинов здесь видите? Да, в целом очертания пингвина наблюдать можно,
и это реальный use case, что происходит, если мы кодируем обычным IS с ECB, просто применяя там
к отдельным пиксикам. В исходных статьях, где это все проводилось, там не png брали, там делали
сохранение в текстовый файл, он назывался... В общем, есть форматы, которые прямо в тексте...
А вот ppm называется. А ppm это просто текст, который выглядит... Там название сейчас...
Короче, там текстовый файл, каждый пиксель, он отдельной строкой, это очень неоптимальный формат.
Да, ну там просто как текст, там можно откусить заголовок и дальше просто уже... В общем,
с разными вариациями можно получить просто поврежденные картинки, но все равно пингвин будет
здесь прослеживаться. Просто за счет того, что мы используем какие-то знания о том, что каждый
блок независимо кодируется, каждый блок независимо преобразуется во что-то другое,
не похоже на исходное, но все равно в зависимости от ключа мы получаем в целом картинку очень похоже.
Например, вот такая проблема при шифровании видеопотока очень хорошо себя проявляет.
Если вы кодируете видеопоток, с одной стороны, да, вы легко можете начать его декодировать с середины,
но дальше восстановить это до какой-то картинки, особенно если это видео, исходное не составляет
никакого труда. Другой способ, который возможен, здесь просто каждая разная картинка, это разные ключи.
То есть в зависимости от того, какой ключ, мы получаем просто разные вариации картинки,
но при этом все равно чертание пингвина у нас всегда можно делать.
Один блок, все-таки не один, пиксель, 256 бит можно достаточно много запихать,
но просто пиксель и его окрестность. Все это дальше зависит от того, разрешающегося пространство этой картинки.
Нет, на этих картинках, то, что здесь у меня, на экране здесь,
каждой картинке соответствуют разные ключи, просто разные варианты, что у вас может получаться.
То есть в зависимости от ключа вы получаете картинку с разными искажениями,
но в целом от чертания пингвина вы наблюдать можете. Просто еще от того,
что у вас каждый блок кодируется независимо друг от друга.
Так, это можно поправить.
Обложаем рисование тачпедом.
Престираем это все.
Теперь другой способ.
Это елки.
Кто знает, как в зуме рисовал?
Рисуем.
Бьем блок опять же на кусочки равного размера.
У нас опять же есть ключ.
Что мы можем сделать так, чтобы у нас блоки не зависели только от ключа?
Решение достаточно простое.
Мы можем применять ключ для вычисления блока.
И помимо ключа вычисляем следующий блок.
Хотим закодировать следующий.
Что мы применяем?
Мы применяем ключ и предыдущий блок.
Либо какая-то статистика основанная.
То есть есть два способа.
Если использовать весь блок дорого, то можно хотя бы какую-то статистику,
которую вы посчитали в предыдущем блоке.
Не обязательно весь блок целиком.
Мы зависим каждый раз от предыдущего вычисленного блока,
который тоже участвует в кодировании.
И тем самым у вас в зависимости от того, какие исходные данные,
независимо от того, насколько у вас стойкий ключ,
все равно увеличивается мусорность зашифрованных данных.
И здесь уже вы не сможете даже общее чертание картинки никак восстановить.
Но чем такой подход плох?
Ну тоже понятно, почему он не всегда используется.
Например, если вам нужно прочитать только среднюю часть,
вам не нужно все это делать, то вам придется все равно декодировать все от самого начала,
даже если сначала вам не нужно.
Такой подход плох, например, для шифрования дисков.
Поэтому для шифрования дисков это не используется.
И здесь еще возникает одна особенность.
Каждый последующий блок зависит от предыдущего и ключа.
А самый первый блок что?
Самый первый блок от ключа.
На самом деле в такой ситуации есть некоторый начальный initialization vector.
Понятие initialization vector надо запомнить, оно вам дальше пригодится при решении, в том числе, домашки.
Ключ plus initialization vector это два числа,
которые каким-то образом получаются с помощью хэширования из данных произвольного вида.
И вот такой способ называется code block chaining.
Одна из вариаций всех распространенных алгоритмов симметричного шифрования.
Возвращаемся к обычному sharing без картинок.
Списки этих всех алгоритмов.
Тут есть разные вариации.
IS, ECB это как раз независимое кодирование.
IS, CBC это код блок чейнинг.
IS, CTR, CFB это примерно то же самое, что CBC,
но только вместо блока целиком используется просто статистика полученной на вычислении предыдущего блока.
То же самое для алгоритмов DES.
То же самое для алгоритмов GOST, ECB.
GOST counter тоже подсчет по статистике.
ECB, CNT, CBC нет у GOST.
Просто GOST это алиас на какой-то из более сильных GOST.
Вариация алгоритмов, когда у вас не указывается способ выбора блоков,
это просто алиас более стойкого.
Эта операция является обратимой для шифрования.
Все же чем такой способ шифрования данных плох.
Здесь вам всегда требуется некоторый ключик.
Если у вас требуется какой-то ключ, то это уже возникает слабое место,
потому что помимо передачи данных вы еще как-то должны передавать ключ в противоположной стороне,
которая должна вашу данную разшифровывать.
Ну и как вы этот ключ можете передать?
Вы можете использовать какой-то побочный канал связи.
Например, данные передаете по интернету,
а ключ на какой-то защищенной флешке,
в сопровождении солдат с автоматом,
но солдат с автоматом тоже может стукнуть по башке и флешку отобрать.
Это ненадежно.
Точно так же, как любая бумажка.
Все равно побочный канал связи тоже бывает ненадежным.
Другой класс алгоритмов, который не заменяет полностью собой симметричные шифры,
а дополняет его,
это алгоритмы со симметричной парой ключей,
когда у вас ключ состоит из двух частей.
Одна из частей является открытой,
а другая является закрытой.
И вы делите ключ на две части.
Одну часть передаваете в противоположной стороне,
в том числе можете использовать какие-то открытые,
не зашифрованные каналы передачи данных.
А дальше используя противоположную часть ключа,
вы данные только дешифруете.
Ну и такой подход он используется практически повсеместно,
в частности и в TLS, в подколе HTTPS.
Вы же не договаривались с Яндексом о том,
что вы получаете какую-то флешку с ключом для шифрования вашего персонала?
Вообще нет.
Здесь сначала выполняется согласование ключей,
а потом уже шифрование данных.
Ну и вот SSH, например, тоже.
Кстати, я часто показываю, что я к виртуалке цепляюсь по SSH,
и при этом я ни разу не ввожу парой.
Как это вообще возможно?
Есть паточка с сервертлогинами, которые руководят их за троллеймусом?
Что это такое, что они себя представляют?
Давайте показываю сначала.
Вот есть такой каталог у текущего пользователя в домашнем каталоге SSH,
в котором есть файлики IDRSA и IDRSAPAL.
Это в случае клиента, вот эти два файла.
Вот IDRSA его показывать не буду ни в коем случае,
а IDRSA.PAP является публичным ключом,
который в принципе разошелся.
Вы когда заводили себе аккаунт на GitHub,
вы тоже такой ключик создавали.
Было дело такое.
И вот эту часть, точнее вот этот весь текст,
дальше копировали куда-то на GitHub.
Точно так же вы можете на удаленном сервере
сделать этот ключик.
На удаленном сервере, куда хотите подключаться,
там есть еще файлик по названию AuthorizedCase.
Он тоже не является секретным.
Туда вы просто добавляете отдельной строчкой каждый отдельный ключик.
Публичный ключик.
Что дальше происходит?
Когда вы подключаетесь к серверу по SSH?
Когда вы подключаетесь к серверу по SSH,
то сервер, используя вот этот закрытый ключ,
который соответствует вам,
генерирует какую-то последняя часть данных
и просит вас ее расшифровать.
Если у вас, используя вашу приватную часть,
расшифровать получается,
то сервер вас пускает.
Если не получается, значит не судьба.
Это называется использование пары ключей.
Работает эта штука примерно следующим образом.
Я уже спрашивал у ИВТ-шников, знакомы ли им имена Ника и Вадим.
Это студенты, которые уже отчислены.
Когда-то читали с заданиями.
Допустим, один товарищ хочет передать другому какие-то искреченные данные.
Как это делается?
Предварительно один товарищ, получая этот синенький,
должен создать пару ключей.
Обычно это делается при инициации сессии.
Ключи генерируются рандомным образом.
Дальше один ключик, который называется открытым,
он передает для ошифрования в противоположной стороне,
противоположная сторона ошифрует.
А дальше для ошифровки используются уже две части.
Во-первых, исходные данные, которые получили зашифрованные,
и противоположная часть ключа.
И получаем какие-то данные.
Все хорошо, все замечательно.
Все-таки слабое место здесь есть в этом взаимодействии.
Ключ Е.
Этот ключ может быть использован только для ошифрования.
Для расшифровки он бесполезен.
Даже если его кто-то перехватит,
он не сможет данные декодировать.
Зато можно подсунуть какие-нибудь фейковые данные.
Что тоже не очень хорошо.
Если кто-то подхватит этот ключ и сможет использовать его как фейковый,
то можно подсунуть неправильные данные.
Кто раньше данные отправит,
то те данные будут использованы из жарки.
Оба из них генерируют два файла,
используя один и тот же открытый ключ,
подписывают и отправляют.
А дальше что мы получаем?
Совершенно непонятно.
И здесь уже дополнительным фактором безопасности
является сертификат открытого ключа.
Тот самый, который когда-то нужно было
за приличные денежки покупать.
Сейчас уже не обязательно за это платить.
Точнее, для прокурора HTTP
вы ключик можете заказать в Let's Encrypt.
Он бесплатный.
Бывают еще также ключи подписи для софта.
Кто устанавливал софт, например,
под Windows или под Mac,
может видели, что
выскакивает окошко,
доверяет ли вы не доверять этому производителю.
Причем под Mac вы вообще не сможете
ничего установить,
если сами не подпишете софт
локально.
Под Windows вам требуется
подвести про администратора.
Под Windows вы можете просто
в яму и образом ключик.
Что это такое?
Я думаю, что и PortWatch.PS вам нужен
какой-то сертификат,
который достоверяет,
что я являюсь отправителем,
а не злобным троллем.
То есть свои данные при согласовании сессии
я обязан отправить какой-то сертификат,
который дальше должен быть проверен
уже самим клиентом и с чем-то сферем.
С чем он может быть сферен?
Есть некоторый набор
удостоверяющих центров.
Это какая-нибудь из уважаемых
организаций, которая выдает
эти сертификаты вашим серверам
и подтверждает,
что данный сертификат соответствует
какому-то доменному имени,
либо если вы подписываете софт,
что он соответствует какому-то разработчику,
и так далее.
Задача этих удостоверяющих центров
это хранить ключи надежным образом
и выдавать свой открытый ключ
всем клиентам, включать его
в поставки всех возможных браузеров.
Например, в браузере Chrome
и в браузере Safari
достаточно трудно
добраться до сертификатов.
Например, в Firefox
под Windows он открывает
родной системный, под Linux есть
общий хранический сертификат.
С каждой поставкой операционной системы
есть свой набор сертификатов
разных удостоверяющих центров,
этих корневых,
с помощью которых проверяется
корректность, что действительно
именно удостоверяющими центрами
написаны те сертификаты,
которые вы получаете в протоколу HTTP.
Если вы получаете правильный
сертификат, то
хорошо вы проверяете
уже содержимый сертификат,
и он должен совпадать с тем доменом,
с которым вы взаимодействуете.
Если злобный тролль
вам отправляет данные,
например, какое-нибудь
доменное имя,
фейковый сайт,
кто-то, например,
подменил вам в DNS ответ
госуслуги.ру не на госуслуги.ру,
а на какую-нибудь там созданную копию сайта,
что произойдет,
если это именно копия сайта,
а не настоящий сайт,
то, соответственно,
на СССР сертификат у вас не будет
валидным, и браузер отругается,
что вы даете кучу предупреждений,
действительно ли вы хотите зайти,
сертификат недействителен либо устарел.
Это лишний повод
задуматься, правильно ли вы
ничего непроисходит.
Вот, кстати,
взаимодействие через
бесплатный Wi-Fi в Московском метро
сейчас уже
такого не происходит,
а вот раньше, в первое время,
пока все сайты по качеству EPS
не были массовым явлением,
вот часто такие ошибки выскакивают,
потому что пытались что-то подменить.
Что?
А, девочка Ника,
товарищ Вадим
пытался сдать
и окост, и прогу,
я уже не помню, что из них,
по-моему, окост все-таки,
комиссию по окост.
Девочка Ника сливала ему
решение готовых задач,
собирая всех одногруппников и прямо
скидывая в чат.
В общем, так делать нехорошо.
А?
Нет, товарища
отчислили за окост, Нику потом
отчислили за что-то другое.
Не за окост.
И не я.
Главное требование к этим
удостоверяющим центрам
это доверие, потому что бывают случаи,
когда закрытые ключи
тоже утекают.
И что происходит в ситуации,
когда утекают закрытые ключи
удостоверяющих центров?
Это означает, что кто угодно
с этим закрытым ключом и подписать себе
кучу неволидных сертификатов
самоподписанных,
что очень плохо.
И в таких ситуациях обычно
объявляется там большая паника.
Google срочно выпускает не только
Google и Microsoft, Apple
все срочно выпускают обновления браузеров
с исправлением базы данных сертификатов
и так далее.
А взаимодействие я вам в принципе уже показывал
по утилите опыт-сель S-Connect.
Сервер отправляет свой сертификат,
который содержит этот ключ.
Дальше клиент проверяет
базы данных открытых ключей.
То есть клиент – это браузер,
который используя поставку базы данных
открытых ключей из операционной системы
проверяет сертификаты,
выполняет проверку подлинности.
Если сертификат действительно подлинный,
то клиент уже дальше генерирует пару ключей.
Одну из них отправляет
серверу.
Но открытый ключ свой, опять же,
поскольку у нас уже есть
открытый ключ сервера,
то мы можем зашифровать данные,
отправить это к серверу,
и сервер дальше дешифрует этот ключ
и может его использовать для шифрования данных.
Такое двустороннее взаимодействие
с обязательной проверкой,
что это действительно общение с сервером,
а не с кем-то другим.
И корневые сертификаты.
Про покупку это уже стало не очень актуально,
можно в лице накрепить получить.
Но и когда они были дорогие,
еще была распространена практика
корпоративных корневых сертификатов,
когда крупные компании
могли просто покупать,
генерировать сами
свои сертификаты
и просто раскидывать по всем
локальным компьютерам своим
для того, чтобы браузеры
выполняли взаимодействие
и выполняли проверку,
что действительно правильный сертификат.
То есть это тоже вручную установить возможно.
Вручную добавить, если у вас есть право администратора,
тоже произвольный сертификат.
На счет реализации шифрования,
помимо команды OpenSSL,
есть еще библиотека
под названием LibreSSL.
Что такое библиотека LibreSSL?
LibreSSL – это
форк библиотека OpenSSL,
который прямо по API один в один
с ним совместим.
Чем он лучше в библиотеке OpenSSL?
Кроме того, что там меньше багов,
у него хорошая документация.
В OpenSSL документация отвратительная.
Поэтому, когда вы будете делать домашки,
вам нужно будет писать вот,
используйте библиотеки LibCrypto,
пользуйтесь документацией
из LibreSSL.
Здесь библиотеку документация не понравилась,
в итоге Stack Overflow поможет?
Stack Overflow может помочь,
но в документации по LibreSSL
поковыряться по правильным названиям
этого более чем достаточно.
OpenSSL – плохая библиотека,
хотя является стандартом.
Почему LibreSSL
до сих пор не во всех дистрибутеях
по умолчанию? Потому что по функциональности
она пока еще не полная,
но там выкинули всю функциональность,
которая считается условно на legacy.
Но в большинстве случаев это
более чем достаточно.
Ладно, время 8.23,
поэтому кто хочет отключиться
от семинара – отключайтесь.
Мы, пользуясь традицией
12-й группы,
вечерний продолжаем
семинар дальше.
Закрываю разбор задач,
продолжаю запись семинара.
Давайте посмотрим теперь
практически, что мы можем
делать с разными данными,
как их кодировать и декодировать.
Кодирование
еще раз напомню,
что у нас есть алгоритм кодирования
с симметричным шифрованием.
Здесь мне приходится вводить
какой-то пароль,
также повторять навод,
если мы
хотим как-то
это автоматизировать.
Как мы можем...
Понятно, что если у вас, например,
есть какая-то система
по автоматизации шифрования,
то
вы не будете вручную вводить пароль.
Все должно работать автоматически,
например, сясь, борк.
Но что вы можете сделать?
Написать echo,
qwerty,
или направить вывод,
OpenSale и так далее.
OpenSale умный,
он команду echo не понимает,
но зато вы можете написать
явно образом пароль
либо плейнтекстом,
потом c-pass задает,
таким образом вы указываете пароль.
Разные варианты.
Во-первых, вы можете написать
вот такую штуку.
Все, пароль у вас никто не спрашивает
с стандартом протока ввода.
Вы такую строчку можете запихать, например,
в файл скрипта, задеплоить на сервер.
Согласны?
Это плохо.
Это плохо, потому что смысл шифрования
теряется у вас
в файле скрипта, который выполняет
шифрование прямо за хардкожин пароль.
Что нехорошо.
Какие еще возможные варианты
указания пароля?
Вы можете пароль написать, например,
в отдельный текстовый файл
с паролем.
Уже немножко лучше, но
если вы, например, используете GitLab,
какой-нибудь GitLab.si для сборки,
опять же, у вас файл
должен где-то лежать в доступном месте
и достучаться до него.
Здесь его сможете.
Тоже не панацея.
Какие еще варианты?
Еще вариант.
Запустить OpenSCale из внешней программы,
создать явно файл-дискриптер
и указать номер
файла-дискриптера, например, третьей.
Такое тоже возможно,
но обычно для этого требуется создание
внешней обертки скрипта,
которая запускает OpenSCale.
Это жутко неудобно, хотя в некоторых случаях
например, когда OpenSCale
вызывается из каких-то внешних программ.
Например, программка запросить пароль.
Диалоговая кошка,
которая спрашивает пароль, передает
OpenSCale и так далее.
И более
полезный вариант
это временное переменное окружение,
которое как-то сдается в конфидегах,
которые скрыты.
Как эта штука работает?
Вы пишете пример окружения
с паспортом
и запускаете команду OpenSCale.
Но когда стало не нужно,
он сет паспорт
либо еще что-нибудь.
Это наиболее безопасный способ,
когда вы отдельно передаете
переменное окружение
отдельно от файлов, которые у вас хранятся.
И это переменное окружение
берется откуда-то снаружи.
В том числе вы можете закодировать
произвольные данные большого размера.
Дальше этот ключ
с паролем кому-то передаете.
Хорошо, все замечательно.
Теперь вариант шифрования
без использования пары ключей
а с использованием
симметричного шифрования.
Это уже интересно.
Допустим, у нас есть
передатчик
и третья вкладка.
Это будет
получатель.
Вот две вкладки.
Я создаю два подкаталога
на одном и том же серии
для того чтобы симитировать процесс передачи данных.
Тут нас будет интересовать
только
непроцессный процесс шифрования.
Итак, для того чтобы использовать
пару симметричных ключей
у нас
нужно чтобы получатель
сначала сгенерировал какую-то
удобную пару ключей.
Открытый ключ, закрытый ключ.
Для этого использовать инструмент
OpenSSL под названием
GenRSA.
Это примерно аналог
SSH KeyGen, который вы использовали
для SSH ключов.
В самом деле ключ SSH
и ключ RSA это одно и то же.
Это один и тот же RSA ключ.
Одна и та же пара ключей, но просто они могут
храниться в разных форматах данных.
GenRSA
и дальше вы
можете опционально указать
размер ключа
на примере
4096 бит
или
65536 бит
только здесь.
Эта штука будет очень
долго считаться.
Кто-нибудь из вас
по базовым указаниям у вас еще не было распределения.
На некоторых базовых
хафедрах еще есть отдельный курс
по криптографии, по монояндексе.
Там более подробно
будут разбираться математические основы
этих алгоритмов.
RSA он
основан на использовании
разных пар
из временно простых чисел.
Соответственно, простые числа
они
сложности генерации
возрастают квадратично.
Очень большой
размер чисел
размер ключа
дает нам
очень медленное время работы.
По умолчанию у нас используется ключ
размером 2048 бит.
Давайте будем его использовать.
Сохраним его
как приватный ключ.
Сгенерировали.
Что-то
бинарное закодировано
в кодировке
BS64.
Чтобы этот текст можно было передать
сохранить как-нибудь с копипастить
и так далее.
Теперь нам нужно
из этого приватного ключа извлечь
публичный ключ.
OpenSSL здесь
используется
утилита RSA
для манипуляции ключами
берем наш
исходный файл
приватный
выполняем операцию
pubout
и получаем
какой-то более коротенький ключик
который опять же можем куда-то сохранить
например файл public.
key
ключ, заметьте,
получается намного более короткий
чем пара ключей, которые здесь
в приватном ключе сохранены.
Теперь
можем скопировать наш публичный
ключ нашему
отправителю
и переходим к отправителю.
Что должно сделать отправитель?
Отправитель должен сделать
какой-то файл, который хочется отправить
пусть будет строчка
hello
Дальше
отправитель
использует
RSA
утилита
утилита
кто не запоминает такие вещи
на гитхабе
проведены прямо в тексты
которые можно использовать в качестве бипасты
шифруем, используя
публичный ключ
и используем в качестве ключа
файл
public. key, который нам передали
имя файла
hello.txt
out.hello.
зашифрование
Получаем некоторые файлы
что он представляет?
он представляет какой-то мусор
самое интересное, что этот мусор
имеет размер
256
что такое 256?
256 умножаем на 8
получаем 2048
что этого мне напоминает?
это размер ключа RSA
результатом работы алгоритма RSA является
что-то совпадающее с размером ключа
и там как-то закодированы наши данные
дальше отправитель может
отправить
нам эти данные
наш получатель
RSA
URL
дальше Decrypt
обратная операция
может использовать
либо злобный тролль
может использовать наш public. key
ничего не получается
если мы перехватили
этого ключа нам недостаточно
поэтому здесь придется
задействовать наш private. key
который есть только у нашего
получателя
и больше никому не доступен
но ему строчку нормально дешифровать
почему?
тогда нужно
еще пару ключов
публично имеется в виду тот ключ
который вам не страшно
потерять и раздать кому угодно
обычно в реальной жизни он генерируется
рандомно
теперь
сделаю все то же самое
но только зашифрую файл
не int.xt
а какой-нибудь
usr, bin, cat
и файл
пусть будет cat.exe
получаем ошибку
ошибку потому что
мы наступили на ограничение
алгоритма RSA
размер данных
не должен превышать
размера ключа
как можно все-таки
зашифровать безопасным образом
вариант первый блоками
вариант второй
у нас же есть хорошие быстрые алгоритмы
надежные для симметричного шифрования
всякие IES и прочие
главная проблема здесь в чем?
потому что нам надо еще каким-то образом
передать ключ
поэтому как используется настоящий взаимодействие
по протоколам ssh
либо htps
там используется несколько алгоритмов
то есть мы можем
сгенерировать рандомно
какой-то ключ
размером например
не превышающим
200
2048 бит
дальше этот ключ мы кодируем
по RSA, передаем в противоположной стороне
а дальше уже
используем этот ключ
кодируем обычным алгоритмом
IES AMCBC
и на самом деле вот такой подход
реально используется различными серверами
то есть зайдем там
у Яндекса
какая-нибудь экзотические
алгоритмы
хотя можно посмотреть
какие алгоритмы он использует
short certificate
в подробностях есть еще
какие алгоритмы у нас используются
для шифровой подписи
у нас используется
256 RSA
нет у нас не RSA
яндекс использует алгоритм
для передачи ключа
а для
непосредственного шифрования данных
используется
где найти это
в Safari
не особо представляю
ну так
лептические кривые
давайте откроем
другой браузер
Яндекс
Яндекс ком
смотрим на
7 баллов в пробке
зима
где там
подробности
подробности
о сертификате
вот connection
connection encrypted
IES 1056 CG
дальше подробности
елки
в разных базах
можно посмотреть
для каких сайтов
какие алгоритмы для чего используются
а Google тоже может
что-нибудь нестандартное
какой у него адрес
Moodle
Moodle Fistahead
Кафедра АТП
обратиться к тем
кто его создавал
Кафедра АТП
не по отношению к IT следей
не имеет абсолютно и полностью
IES 128 CG
и RSA для
подмена ключей
все равно какая-то вариация ключа
либо RSA, либо лептические кривые
по отношению к IES
странно, что ребята используют IES 128
вот вам наводка
что-то старое, что не поддерживает
IES 256
на самом деле IES 128 тоже достаточно надежный
обычно используется именно пара
алгоритмов шифрования
это
что-нибудь типа IES
либо RSA, либо лептические кривые
и немножко про симметричное шифрование
и про использование соли
один важный момент
и потом я вас тогда уже отпущу
строчка Hello
давайте мы ее закодируем
обычным
IES 256
и также
используем одно имя тоже файла
hello.txt
используем пароль
plain.txt
чтобы все было честно
и запишем за все файл
1.eng
и сделаем то же самое
для файла 2.eng
файл содержит одно и то же
закодированный паролем qwerty
размер первого файла
32
размер второго файла
тоже 32
вроде как
пока похоже на правду, согласны?
как там понять одинаковые файлы
или не одинаковые, несмотря на их содержимое?
да, можно посмотреть хэш-сумму
можно использовать OpenSSL
можно использовать более короткие команды
если у вас Linux
давайте посмотрим одинаковые эти файлы или не одинаковые
файлы-то у нас разные получились
с чем это может быть связано?
да
здесь у нас повлияла соль
которая использована для дополнительной
рандомизации данных
если посмотреть
хэкс-дампом
содержимое
хэкс-дампом некрасивое
xxd-r
хэкс-дамп
что у нас есть в файле?
так лучше
минус c
кто помнит опцию xxd
чтобы он побайтовый
и не группировался?
никто не помнит
полезно это вспомнить
формат calls
а
минус c1
нет
не то
а
минус page
так вот у нас получается
ладно
не буду извращаться
извращаться с выводом
у нас есть вывод salty
это обычный ASCII
некоторый префикс salty дальше
а после
идет какой-то рандом
если мы посмотрим на
то же самое в файле 2
эти байтики у нас отличаются
и они каждый раз берутся
рандом
если я напишу
при оцифровании
опцию еще одну
но salt
то же самое
и для первого и второго файла
теперь посчитаем
на 5
каждого из файлов
они будут совпадать
и что у нас будет представлять собой
в этом представлении
в этом представлении у нас уже не содержит
префикса ASCII salty
и каких-то дополнительных 8 байтов
это может быть вам полезно
для отладки
когда вы генерируете себе тестовые данные
для решения второй задачи
вот таким образом можно указать
и дальше
строчку вида 00
01,02,03,04,05,06,07
что это такое
это соль
заданная
явным образом
получаем salty
а дальше циферки 01,02,03,04,05,06,07
8 байтиков
16 личной записи
соль фиксированная
может использоваться
либо для тестирования
каких-то криптографических алгоритмов
например получать какой-то
строго фиксированный результат
в наборе тестов
либо при дебаге
других назначений у фиксированной соли
у нас нет, иначе смысл весь соли у нас теряется
на этом все
есть ли у вас вопросы
соль это значит фактически ее отсутствие
это фактически 0 бит
да, просто не будет соли
это просто оски представления
но это то же самое
что в коне
каждый символ 1 байт
в предположении что это оски
то что не оски
оно кодируется просто
все невидимые символы кодируются невидимыми символами
так
последние
раз, два, три, четыре
пять, шесть, семь
да, восемь байт
то есть если оно совпадает с сольской солти
два подчеркивания, значит соли есть
если нет, не совпадает, то соли нет
да, соли может быть
файл, который сгенерирован
с опцией no-salt
если соль есть, тогда нужно
вот эти байтики извлечь
все остальное
у нас идет
можно посмотреть
опять же
я уже удалил
если даже не будет
я убираю явную соль
и сразу
это будет файл
1 янк и xxd 1 янк
давайте сравним
что у нас отличается
у нас отличаются вот эти байтики
данные все равно отличаются
да, логично
так, ладно
есть ли у вас еще вопросы
так, ну и что у нас там дальше
давайте немножко посмотрим
на
конец семестра, поскольку сегодня
22 ноября
вот и хороший вопрос
сколько вам, да
я реально там оставил что-нибудь
на потом, что можно просто выкинуть
так, open-sale тема важная
согласны? согласны
давайте сразу календарь
так, 28
значит 29 все заканчивается
логично
так, дальше 29 у вас закрывается конец
до 6
это еще один
там по плану было
фьюзы
это реализация своих файловых систем
а потом у нас еще остается
хайлоут
а, ну в принципе нормально
все укладываемся, все хорошо, все замечательно
29 по 6
вы делаете
блин, да
следующий контент открывается
27, 4, 11
в любом случае
да, у вас по семинарам количество
ходит
и там задачи, которые
на
файловые системы
они не сложные, но они
громоздкие по реализации
а задачи, которые на епол они
небольшие по объему, но там
требуется понимание писать
ну смотри, на фьюз там нужно
писать пеленку в несколько экранов кода
поэтому
их проходим раньше, а потом
хайлоут
нормально все успеваем по 15 часам
домашней которой
нет, там главное
аккуратно все писать
и локально потестировать, прежде чем отправлять
потому что если вы
типовая проблема прошлого года, то что
отправляли не протестированные решения
совсем
на тесте, где
размер чуть больше, чем размер ключа
если вы хотя бы протестируете, что у вас
входные данные размером больше, чем размер
ключа, проходят, то большая часть
работы уже выполнена
оглашу, но не сейчас, да
чем больше, тем лучше
стандартный ответ
но вы фистейки, чем больше, тем лучше
