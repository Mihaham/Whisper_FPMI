Так, ну что, давайте начинать.
Значит, у нас остаются две лекции последние, и их мы посвятим лямдоисчислению.
Значит, лямдоисчисление – это, ну, можно сказать, что это некоторый альтернативный подход к понятию учислимости.
Значит, лямдоисчисление.
Значит, можно сказать, что подход с машинами тюринга в конечном счёте основан на понятии множества.
Ну, что такое машина тюринга? Ну, это какой-то картеж из каких-то множеств и функций.
Ну, а что такое картеж? Ну, картеж – это в конечном счёте такое множество.
Потому что мы определяли картеж через там пару из головы и хвоста, а пары тоже такое множество.
Функции – это тоже множество пар, то есть тоже какое-то множество.
В общем, в конечном счёте понятие машина тюринга основан на понятии множества.
Ну и, в принципе, такой стандартный подход в математике, на что все числа, функции, любые такие объекты
в конечном счёте идут от понятия множества. И теория множества – это фундамент всей математики.
А вот лямдоисчисление – концепция другая. Значит, лямдоисчисление – ключевой объект – это функция.
Вот, то есть как бы функции – это такие преобразования одних функций в другие функции,
и логические значения – это такие функции, и натуральные числа – это такие функции специальные, и так далее.
В общем, все объекты идут от понятия функции.
То есть можно сказать, что девиз. Девиз состоит в том, что всё есть функция.
Но есть такая парадигма функционального программирования, которая тоже основана на том же самом девизе.
И некоторые задачи в функциональных языках решаются проще, чем в других.
Есть специальные языки программирования типа Хаскела, которые основаны в конечном итоге на лямдоисчислении, на концепции.
Ну и, соответственно, если вы захотите их изучать, их использовать, то для этого будет полезно понимать основы теории.
Соответственно, вот это две причины, по которым мы изучаем эту тему.
Ну, можно сказать, что это историческая причина, потому что, в принципе, и лямдоисчисление, и рекурсивные функции, и машина тюринга,
и ещё несколько концепций появились примерно в одно и то же время, в середине 30-х годов прошлого века.
И все эти концепции по-разному описывали, определяют, что такое вычислимость, ну и, конечно, все эти концепции и планеты между собой.
И судьба их сложилась по-разному. Некоторые утвердили своё место в теории, некоторые остались скорее в истории науки.
Ну вот, у лямдоисчисления оказались ещё и другие приложения. Вот, и это вторая причина, по которой мы его изучаем.
Так, хорошо. Значит, теперь что мы будем за эти две лекции изучать?
Значит, вообще на лямдоисчислении можно смотреть как на формальную теорию.
Тут будет некоторый язык с некоторым синтаксисом и некоторая семантика, то есть, что эти записи будут означать.
И, соответственно, семантика будет как раз для разных конкретных числовых систем.
Будут номералы, которые означают натуральные числа, будут комбинаторы, это называется.
Будут комбинаторы для логических значений, для образования пары.
И будут комбинаторы уже для настоящих функций, которые будут производиться вот с этими номералами или логическими значениями и так далее.
Вот, но начнём из синтаксиса.
Почему оно лямдоисчисление? Потому что есть тут символ лямдо, который очень много используется.
Значит, синтаксис лямдоисчисления.
Значит, синтаксис начинается с языка.
Ну, или можно сказать, что синтаксис – это есть язык, но язык начинается с алфавита.
И алфавит тут, на самом деле, довольно просто устроен.
Алфавит стоит из переменных.
Переменная. Ну, обычно будут маленькие латинские буквы.
В общем, всякие.
Переменная.
Значит, дальше квантор. Лямдо квантор, или квантор лямдо абстракции.
Ну, и он как бы будет стоять из двух частей, из двух символов.
Значит, будет лямдо и будет точка.
Вот. Ну, и скобки ещё.
Значит, скобки. Всё. Больше никаких символов в алфаите нет.
В общем, алфаит довольно простой.
Так, дальше начинается правило построения.
Значит, правило построения выражений, которые называются лямдо-термами.
Так, ну, наверное, давайте прежде, чем я формально буду говорить, как они строятся,
я постараюсь объяснить, что означает этот квантор лямдо.
Да, как бы смысл вот этой лямдо, смысл лямдо явно сказать,
от чего зависят последующие выражения.
То есть, например, лямдо х точка х плюс у.
Аль, давайте я лучше буду...
Это не совсем так, как... Вот так вот.
Лямдо х точка ху.
Вот этот ху можно считать как конконтинация, можно считать как умножение.
Это означает выражение ху как функция от х.
Лямдо у точка ху.
Это то же самое, только как функция от у.
А, например, если написать лямдо ху точка ху,
то это будет как функция от двух переменных.
Ну, а если вообще без лямдо ху,
то это значит, просто выражение вообще не воспринимается как...
Ну, оно не может вообще не восприниматься как функция,
ну, и вообще можно сказать, что это просто такая константа, что ли, параметр.
Вот.
Вот, хорошо.
Теперь, наверное, давайте я с основной страницы начну.
Теперь как, собственно, строятся лямдо термы.
Построение лямдо термов.
Значит, вот корректные выражения называются лямдо термами.
Ну, и, как всегда, есть базовый случай.
Значит, база просто однопременная.
То есть, если х-переменная, тогда х это лямдо терм.
Ну, и, как всегда, есть базовый случай.
Если х-переменная, тогда х это лямдо терм.
Вот. Значит, дальше есть...
Ну, давайте пронумеру, это первое.
Значит, второе можно назвать конкассинацией,
и это такой синтоксический взгляд.
А можно назвать еще по-другому.
Аппликации.
Аппликации не в смысле переводная картинка, а в смысле application,
то есть приложение или прикладывание одного к другому.
И это как-то такой семантический смысл.
Значит, тут, следующий.
Если уже есть два терма,
если m и n это лямдо термы,
то тогда, если мы их напишем друг за другом, m и n,
то это даже будет лямдо термы.
Вот. Ну, а почему это аппликация?
Ну, потому что смысл тут такой,
как бы, функцию m применили к аргументу m.
То есть когда мы записываем два терма друг за другом,
то это означает, что мы первые из них сменяем как функцию
и применяем ко второму.
Соответственно, получается, что когда вообще было x и y,
то есть вот это вот x и y, это как бы и есть аппликация,
то есть мы x применяем к y.
Если просто написано x и y, то это вот такое выражение.
А вот это вот, как бы, лямдо x.xy,
означает, что это как-то такой оператор, который получает x произвольно
и применяет к конкретному y.
А лямдо y.xy это наоборот.
Это фактически обычная функция x,
что мы фиксируем функцию x, применяем к произвольному y.
А вот третья, лямдо x.xy, означает, что мы сразу получаем
и функцию, и аргумент для нее, и это что-то типа такое
универсальная машина. Она получает функцию, получает аргументы
и вычисляет значения. Ну, вычисляет, не вычисляет,
но, в общем, вот это вот x и y мы понимаем как результат,
процедура, которая получает и функцию, и аргумент,
и возвращает значение функции на этом аргументе.
Так, это, значит, второе.
И третье.
Третье называется лямдоабстракция.
Значит, лямдоабстракция возникает в следующем образом.
Значит, если у меня есть m, лямдо терм, а x это переменная,
то тогда в скобках вот так вот, лямдо x.m,
в скобках, значит, это тоже лямдо терм.
Вот.
И смысл тут такой, что раньше m было просто выражением,
а теперь оно будет не просто выражением, а именно функцией от x.
Да, то есть тут... Да.
Нет, ну как, это индуктивное определение.
То есть вот это вот лямдо термо означает построен по этим же правилам.
Не, ну это может быть сложное выражение, это не обязательно какое-то название.
Ну, можно считать, что это формула,
можно считать, что это формула, но она может быть сложной формулой.
Значит, m понимается...
Ну да, да, да, это вот...
Ну а то, что здесь было, пока было просто x, y, это вот выражение x, y.
А теперь мы понимаем не просто x, y, а как именно функции от x или от y.
Или от того и другого.
Вот. Значит, вот это вот три правила.
Ну и как всегда бывает в индуктивных определениях,
лямдо термами называются всё, что можно построить вот по этим правилам.
Начиная с базы, применяя второе и третье правила,
всё, что можно построить, это будет как раз лямдо термам.
Да.
Сейчас поговорим об этом.
Даже то, что я вот здесь писал, это вообще всё не соответствует
вот этим правилам в плане скобок.
То есть там в каждом выражении минимум две пары скобок должно быть,
а лямдо x, y тут вообще нету.
Значит, вот по этому поводу есть соглашение о сокращениях.
Значит, соглашение о пропуске скобок можно сказать.
Соглашение о пропуске скобок.
Так, первое.
Значит, первое, что если у меня после точки что-то такое идёт,
то тут вообще можно двумя способами скобки расставить.
Это равняется...
Так, давайте я все скобки расставлю.
Нужно вот так вот ставить скобки, если их вообще не стоит.
И это не равняется вот такой штуке.
То есть если на самом деле нужно вот так вот, то тогда нужно явно скобки поставить.
А по умолчанию, если скобок не стоит, то тогда вот так вот.
Так, второе.
Второе, если мы длинную контактинацию напишем.
То есть что-нибудь типа MNPQ.
В общем, по умолчанию мы это как бы читаем слева направо.
И когда можно, то и применяем.
А во всех остальных порядках нужно скобки ставить.
Ну и третье.
Третье, когда у нас много переменных.
То есть, если мы делаем скобки,
то у нас много переменных.
Ну и третье, когда мы делаем скобки,
Третье, когда у нас много переменных.
Ну а тут нужно писать, например, лямбда x, y, z, точка M.
Так, значит это будет...
Сейчас, нет.
Лямбда x, точка лямбда y, точка лямбда z, точка M.
Вот. И это тоже стандартное отождествление.
Значит, что функция от N...
Так, нет, лучше не такой.
Функция от N переменных, значит, это тоже,
что функция, сопоставляющая первой переменной
функцию от остальных N-1 переменных.
Но это, в общем, тоже стандартное...
Ну, одно из стандартов понимания того, что такое функция Нинских переменных.
Можно считать, что мы, как бы, сначала делаем дикартовое произведение,
и потом в каждой ячейке определяем значение функции.
А можно сказать, что, например, о двух переменах,
что мы каждому значению ординаты, наоборот, каждому значению авсцисы
сопоставляем функцию от значения ординаты.
И когда мы все эти функции сложим, то получится функция о двух переменах.
Несложно, а скорее склеим.
Ну, теперь можно там какие-нибудь несложные примеры,
примеры каких-то таких лямбда-термов, но с некоторым значением.
Так, примеры записей некоторых функций.
Так, ну, например, лямбда х.а.
Ну, это функция константа.
Константа.
Там лямбда х.х.
Ну, это что называется, тождественная функция.
Лямбда х.х.
Но это можно сказать, что это удвоение.
Но можно, пометуя о том, что когда мы два терма друг за другом записывали,
то это как бы первый применяется к второму,
а можно сказать, что это такая диагонализация.
То есть это как раз мы функцию х применяем саму к себе.
Можно сказать, что это удвоение, а можно сказать, что это применение функции,
та самая аппликация, применение функции к самой себе.
Ну, можно писать, например, лямбда х.у.x.
Ну, можно это назвать транспозицией.
Ну а что, берем и меняем местами х и у.
Ну, наверное, пока хватит.
Ну, опять же, транспозиция получается в синтаксическом смысле.
Это соответственно удвоение вот здесь.
Ну а в симпатическом получается, что мы как бы применяем наоборот.
То есть меняем аргументы функцию местами.
То есть перемена местами аргумента и функции.
Так, хорошо.
Значит, пока, наверное, хватит.
Значит, перейдем дальше по синтаксису.
Что еще можно делать?
А, сейчас, надо еще сказать, что тут все переменные делятся, как обычно,
на свободные и связанные ноль, точнее, вхождение их.
Значит, все переменные терма, точнее, вхождение переменных.
Делятся на связанные и свободные.
Ну, соответственно, если...
Вообще, у каждого лямбе квантера есть область действия.
И если у каждого лямбе квантера с SamePath и SamePath,
то у каждого лямбе квантера есть guardingя,
то у каждого лямбе квантера есть гибель,
то есть гибель, в котором он находится.
есть область действия, и если переменная попадает в эту область,
то тогда она будет связана, а если не попадает, то свободна.
То есть, например, если написать что-нибудь такое, лямбда xy.yx,
а потом, например, xx, то тогда получается, что вот это вот вхождение в лямбду
и попадающая подобность действия, это связанное, а те, которые тут просто остались, это свободное.
Видно, что в этом моем примере есть такой эффект, который вообще не очень любят, хотя он и не запрещен.
Эффект такой, что связанные свободные вхождения одной и той же переменной обозначены.
Это может запутать, но это не противоречит правилам.
Тут есть, например, назначенность разбора, даже с этими соглашениями осколковых есть
эта назначенность разбора, можно это, в принципе, доказывать.
Но, конечно, в такой записи повышается вероятность ошибки, что-нибудь куда-нибудь не туда переписать.
Но, кстати, не только не только вероятность ошибки, а еще и некоторые действия невозможные.
Поэтому есть понятие альфа-конверсия.
Альфа-конверсия – это переименование связанной переменной.
Например, лямбда xy.yx мы превращаем по альфа-конверсии, скажем, лямбда ty.ytt.
Это корректные действия.
А те невозможные, в общем случае, лямбда x.m может быть преобразована в лямбда y.m, в который y вместо x.
Но при этом, как и в случае с исчислением первого порядка, здесь возможны некорректности, которые нужно запретить.
То есть тут должна быть корректная замена.
Ну а какие могут быть проблемы?
Как и раньше, могут быть две проблемы.
Либо у меня какая-то старая переменная подпала под новый квантор, либо новая переменная подпала под старый квантор.
Давайте я покажу примеры.
Примеры некорректной замены.
Красным цветом, как не должно быть.
Например, лямбда x.xy превратили в лямбда y.y.
Давайте я перечеркну эту стрелку.
Что здесь произошло?
Здесь вот этот параметр y внезапно стал внутренней переменной, по которой стоит лямбда квантор.
То есть тут и смысл изменился.
Если раньше у меня было применение переменной x к параметру y, то теперь у меня получается, что переменная y сама к себе применяется.
Это совершенно другой смысл.
Тут что получилось? Получилось, что старая переменная подпала под новый квантор.
Тут свободная переменная в m попала под замененный квантор.
Но может быть наоборот.
Может быть наоборот замененная переменная подпала под старый квантор.
Давайте я тоже покажу пример.
Например, лямбда x, а тут будет x и, например, лямбда y.xy.
И тут я тоже x заменю на y.
Получится лямбда y.y и тут лямбда y.y.
Получилось, что раньше вот этот x был связан вот этим квантором.
Помните, когда у меня скобок нет, тогда все, на что влияет x, до конца выражения идет.
А здесь у меня получилось два раза лямбда по одной и той же переменной, и само в себе это еще не очень страшно.
И даже то, что это вложено, не очень страшно.
А страшно то, что вот в этом месте переменная подпала уже под действие другого квантора.
Если раньше вот это было под действием вот этого квантора, то теперь она получилась под действием вот этого квантора.
То есть теперь получается, что после замены переменная связана другим квантором.
Вот два примера некорректной замены.
Соответственно, не должно быть ни того, ни другого.
Нет, сама по себе запись, как и справа, может тоже некрасивая, но она допустима.
И она даже не осмысленна.
Вот этот y это локальный пример внутри этой скобки, а вот этот y подчиняется вот этому квантору.
То есть получается, что мы вот этот y применяем не просто кому-то параметру, а к результату диагонализации.
Вот эта скобка фактически константа, а именно функция диагонализации.
Или удвоение, как я писал.
Так что сама в себе эта запись приемлемая, но проблема в том, что она не соответствует этой записи.
Здесь у меня вместо удвоения просто другая функция применения y и x.
И более того, никакому угодно x, а ровно к тому, который задан вот здесь.
Хорошо, альфа-конверсия, альфа-конверсия, это вот такая замена.
Так, ну вроде мы разобрались с этой штукой альфа-конверсия.
Тут, конечно, может быть какой-то формальный индуктивное определение, но его давайте пропустим.
На самом деле даже две лекции, это не очень много на лямбеисчлене.
Сейчас давайте перерыв, а после перерыва будет самое важное, что есть лямбеисчлене, это редукция.
Ну что ж, давайте продолжим.
Второе преобразование, самое важное, это бета-редукция.
Бета-редукция, это и есть суть аппликации, что если мы функцию с параметром x применяем к какому-то объекту,
то это означает, что мы этот объект представляем вместо x в исходное выражение.
То есть тут выглядит она так, лямб до x, m, n, это преобразуется в смысле бета к m от n вместо x.
Что здесь написано? У нас есть какое-то выражение m, которое не просто так, а понимается как функция от x.
И мы это выражение как функцию от x применяем к аргументу m.
Но это означает, что мы в это выражение подставляем вместо все вхождения x значение m.
Как всегда, должна быть корректная замена.
А, кстати, я еще и здесь не сказал про эту корректную замену, что мы заменяем только те вхождения x,
которые зависит именно от этого квантора, а то там в глубине могут быть какие-то еще кванторы по x.
Это примерно как то, про что мы вот здесь говорили.
Если мы теперь вот здесь еще раз будем...
Да, это некорректный результат этой альфа-конверсии, но в принципе мы можем к этому выражению принять альфа-конверсию,
и тогда только вот эти y будут заменяться, а вот эти вот нет.
Или наоборот, я это тоже не сказал, но сейчас, наверное, после бета-редукции запишу,
что и альфа-конверсию, и бета-редукцию можно применять не только всему терму в целом, но и какому-то его фрагменту.
К любому фрагменту, который строится в ходе индуктивного построения, можно применить альфа-конверсию и бета-редукцию по тем же правилам.
То есть, например, к этому выражению можно вот здесь вот заменить вот эти вот y.
Можно вот эти вот y заменить.
Так.
Хорошо.
Значит, ну тут опять же должна быть корректная замена.
Значит, корректная замена.
Ну, тут смотрите, что может быть, какие могут быть некорректности.
Значит, может какой-нибудь квантор из N, не квантор, в смысле, а наоборот, свободный применный из N может попасть под действие какого-то квантора, который был в M.
Вот. А другого, в принципе, вроде ничего не может быть.
Так. Давайте я здесь напишу.
Значит, пример некорректной редукции.
Пример некорректной редукции.
Ой, это не то.
Так, пример некорректной редукции. Ну, например, может быть так.
Значит, лямбда х точка х, а тут лямбда у точка ух.
Значит, все это меняется к у.
Значит, это не должно редуцироваться к там у, лямбда у точка уу.
Да, потому что получилось, что раньше вот этот х не зависел от вот этого квантора, зависел от того, который вообще исчез, и теперь его вообще не должно быть.
А оно у нас попал в зависимость вот этого.
То есть, как получается, что вот это попало вот сюда, а было вот сюда.
Так, ну и давайте слоистное описание.
То есть, свободная переменная, свободная переменная из M попала под квантор из M.
Ну, на самом деле, других никаких проблем не может быть.
Потому что обратной ситуации быть не может.
Значит, никакая свободная переменная из M не может подпасть под действие квантора из N.
Ну, потому что все области действия кванторов из N, они в этом Н и остаются.
И там никакие ранее бывшие переменные попасть туда не могут.
Так, ну и соответственно и альфа-конверсия, и альфа-конверсия, и бета-редукция могут быть применены.
Не только ко всему выражению, но и к какому-то фрагменту.
Вот, в частности, правильное действие вот с таким вот будет, смотрите какое.
Значит, правильное действие, что если вот нам нужно упростить это выражение,
то нужно сначала применить альфа-конверсию и вот этот вот Y переименовать.
Значит, лямбда X.X, а тут будет лямбда T.TXY.
И вот после этого уже можно применить бета-редукцию, и получится Y лямбда T.TY.
И теперь уже никакого конфликта нет, как был вот этот X зависелен только от внешнего квантора, который исчез при бета-редукции,
так вот этот вот Y и остался свободной переменной.
Вот так.
Значит, что же дальше?
Дальше можно определить понятие нормальной формы, точнее термо-нормальной форме.
Да, логики вообще любят нормальные формы.
У нас уже были конъюнтивно-дезюнтивные нормальные формы, придворённые нормальная форма.
Ещё бывает нормальная форма хомского, но это вы, наверное, не знаете пока.
Это в терреформальных языках контекста свободных.
Ну и в лямбда-учлене тоже есть нормальная форма, но она без эпитета, просто нормальная форма.
Так, значит, терм находится в нормальной форме, если к нему нельзя применить бета-редукцию.
Даже после нескольких альф-конверсий.
В общем, даже после нескольких альф-конверсий.
В частности, смотрите, в этом примере к первому терму нельзя было применить бета-редукцию.
Но он ещё не в нормальной форме, потому что к нему можно применить альф-конверсию.
Причём он здесь вот как бы в подформуле.
А после применения альф-конверсии можно применить бета-редукцию.
Но к тому, что получилось в конце, уже нельзя применить бета-редукцию даже после каких-то замен.
И поэтому вот это тоже в конце, это уже нормальная форма.
Так, хорошо, значит, теперь возникает понятие равенства лямбдо-термов.
Равенство лямбдо-термов.
Но это, так говоря, научно.
И это симметричное транзитивное замыкание.
Ну, как бы альф-конверсии и бета-редукция.
То есть это симметричное транзитивное замыкание альф-конверсии и бета-редукции.
Значит, при этом альф-конверсия вообще-то и так симметрична.
Это там можно формально доказать.
Но вообще более-менее понятно, что если мы смогли в одну сторону переименовать корректно,
то в другую сторону тоже сможем, что там никаких новых проблем не возникнет
при обратном переименовании.
То есть вот это вот альф-конверсии и так симметрична.
Ну или иными словами, если раскрывать определение.
То есть симметричная означает, что бета-редукция, конечно, не симметрична,
но это означает, что мы как бы можем ее и в ту, и в другую сторону применять.
Ну а транзитивно означает, что мы можем выстраивать цепочки.
То есть можно сказать, что m равно m,
если существует цепочка, значит, m0 равно m, там m1, m2 и так далее.
Какое-то mkT равно n.
Такая, что для любого их, значит, mIT альф-конверсии преобразуется в mIT плюс первое,
значит, преобразуется бета-редукция в mIT плюс первое или, наоборот,
и плюс первое преобразуется в mIT.
Соответственно, симметричность означает, что мы бета-редукцию и в ту, и в другую сторону применяем,
а альф у нас и так и в ту, и в другую сторону.
А транзитивно означает, что мы вот такую цепочку устраиваем.
Вот. Значит, это понятие равенства лямбдо-термов.
Так, понятно ли определение?
Так, а тут еще нужно такой пример привести.
Ну, точнее, как бы такой вопрос.
Да, вопрос. Всегда ли у лямбдо-терма есть равный му-терм в нормальной форме?
Всегда ли у лямбдо-терма есть равный му-терм в нормальной форме?
Оказывается, что нет. Нет, не всегда.
Потому что, смотрите, рассмотрим омего.
Омего большое, стандартное обозначение именно для этого.
Вот, это как бы такой удвоитель, примененный сам к себе.
Но вот этот удвоитель, примененный сам к себе, он самого себя удвоит, и получится снова удвоитель, примененный сам к себе.
То есть вот этот омего бета-редуцируется только сам к себе.
Омего бета-редуцируется к омеге, и поэтому к нему всегда можно применить бета-редукцию.
Потому что он от этого не имеется. Он как эта самая экспонента при дифференцировании.
Ну хорошо, а когда есть?
Да, будет ли она единственной, если есть?
Значит, а будет ли нормальная форма единственной, если есть?
Ну ответ да, но с точностью до переименования переменных.
Ну то есть до альфа-конверсии. Ну действительно, если там какие-то лямда остались, то тогда можно альфа-конверсию применять.
И это все будет... и бета-редукцию нельзя будет применить, потому что по определению даже после альфа-конверсии бета-редукции нельзя применить.
Но ничего другого на самом деле не может быть. Но это сложная теорема, я ее целиком не буду доказывать.
Сейчас докажу с опорой на некоторых утверждений без доказательства.
Вот, да, при этом может быть так, что в одном порядке бета-редукция приводит к нормальной форме, а в другом порядке будет бесконечная цепочка.
При этом может быть так, что бета-редукция в одном порядке
приводит к нормальной форме, а в другом будет бесконечная цепочка.
Ну, например, может быть какой-нибудь тривиальный пример.
Тривиальный пример. Вот такой вот лямда х.а, примененный комега.
Значит, с одной стороны, можно с него сразу ва перейти. То есть константу вообще, если не важно, чем применять, будет эта константа.
Значит, с одной стороны, это просто ва и а. Это, конечно, нормальная форма.
Но с другой стороны, можно его сам к себе свести. Значит, это если мы будем бета-редуцировать внутри омега.
Вот. Вот этот эффект показывает пользу от того, что называется lazy evaluation.
Значит, это вообще такая концепция в программировании, а точнее даже в компиляции.
Лazy evaluation означает, что мы значение переменной вычисляем только тогда, когда оно реально нужно.
Вот. И это с одной стороны, это ускоряет процесс, а с другой стороны, это маскирует ошибки.
Может быть, что как раз там в вычислении скрыта ошибка, а вы ее не заметите из-за того, что это вычисление не запускается.
А потом в ответственный момент запустится и будет ошибка.
Соответственно получается, что такое зацикливание можно считать ошибкой.
И, соответственно, когда мы просто выручаем а, то значит, мы не вычисляем, к чему именно мы применяем, а просто берем константу.
А если мы начнем вычислять, то там-то мы и зациклимся, и, соответственно, ничего не закончится.
Вот. Но тирем говорит так, что если мы все-таки не зациклились, то будет то же самое.
Что, в принципе, никто нам не мешает, скажем, десять раз делать вот здесь, а потом все-таки привести вот это вот в это редукция.
Вот. Ну ладно, так вот.
Сейчас, формулирую теорему. Сначала обозначение.
Так, давайте вот так вот обозначу. Как бы такая двойная стрелочка.
Значит, m двойная стрелка n.
Но это если есть цепочка альфа-конверсии бета-редукции, которая приводит из m в n.
Если можно прийти из m в n цепочкой альфа-конверсии и бета-редукции.
Вот.
Так, значит, тогда теорема Чорчеросера это такая теорема о замыкании ромба.
Так, значит, теорема Чорчеросера без доказательства.
Так, значит, теорема Чорчеросера заключается в следующем.
Пусть из m можно прийти в n и из m можно прийти в p.
Значит, тогда существует q такое, что из n можно прийти в q и из p можно прийти в q.
Вот. То есть это действительно такое замыкание ромба.
Значит, вот есть m.
Значит, из него можно прийти в n.
Также из него можно прийти в p.
И это уже дано.
Тогда утверждается, что это как бы разошедшееся дерево.
Но, грубо говоря, интуиция здесь такая, что мы какие-то одни преобразования делаем вот по этой линии,
а какие-то другие делаем вот по этой линии.
И те, которые мы делаем по другой линии, все равно можно еще провести вот в этой линии.
И наоборот.
Вот. И тогда, когда мы проведем эти преобразования,
то это что-то типа вне зависимости от порядка.
А при образовании, проведенной вот здесь, мы приведем вот тут, то мы приведем к одному и тому же.
Это, конечно, такая интуиция, реально там более сложное рассуждение, но идея именно такая.
Вот. Тогда отсюда следствие, что на самом деле можно попроще.
Значит, следствие такое, смотрите, что m равно n, тогда и только тогда, когда существует q, такое, что из m можно прийти q и из n можно прийти q.
Вот. Как это следствие доказывается.
Ну, смотрите, у нас же там была длинная цепочка, там были стрелки в одну и другую сторону.
Но можно все подряд параллельный стрелок как бы склеить, и тогда будет получаться...
Так, давайте я для ускорения буду стрелки как бы одиночно рисовать.
Вот m, вот m. Что такая цепочка получается по определению.
Вот это черное, это по определению.
Ну а дальше мы можем начать это как бы...
Сначала вот здесь ромб применить, потом вот тут вот применить ромб, и так далее.
И в итоге вот эта вот часть по теореме Чорчеруссера.
Ну и в итоге вот получится, и это как раз наша q получится, что и из m получится цепочка, и из n получится цепочка.
Вот.
Вот, это уже некоторый результат, что вот такое более простое определение равенства.
Что еще раз?
А, нет, так в обратном случае это частный случай.
Да, то есть справа налево, это просто то, что здесь написано, это подходит под определение.
Просто общий случай, когда много вот таких вот зигзагов, а частный случай, когда одна галочка.
Не, ну правильно, вот это вот такой случай, когда у нас сначала все стрелочки в одну сторону, потом все стрелочки в другую сторону.
А в общем определение у нас стрелочка как угодно стоит.
Сейчас, что-то я не понимаю, о чем вопрос.
Сейчас, смотри, давайте вернемся тогда.
Так, вот здесь равенство, да.
Вот, видите, что тут есть длинная цепочка, где в каждой паре либо альфа-конверсия,
которая может быть и в ту, и в другую сторону, либо это редукция в одну сторону, либо это редукция в другую сторону.
Дальше мы их можем склеить подряд дующие стрелки в одну сторону,
и как бы заменить вот эти вот однократные редукции на как бы такие цепочки редукций,
но все равно они все будут то в одну, то в другую сторону.
А, соответственно, вот это вот следствие говорит о том, что можно считать, что сначала они все в одну сторону из m в q,
а потом все в другую сторону из q в m.
Так, ну вот, значит, теперь теорема о единственности нормальной формы.
Так, значит, теорема о единственности нормальной формы.
Значит, теорема будет такой.
Значит, пусть из m можно прийти в p, из m можно прийти в q,
и, соответственно, и p, и q в нормальной форме.
Ну, тогда из p, и q можно прийти альфа-конверсиями.
Тогда можно прийти из p в q альфа-конверсиями.
Вот. Ну, тоже это из теоремы Чорча-Россера довольно легко следует.
Да, значит, вот есть m, значит, вот оно пришло в p, вот оно пришло в q.
Ну, теперь, смотрите, с одной стороны получается, что им нужно прийти, значит, еще в какое-то одно и то же r.
Вот. А, давайте я продолжу.
Значит, поскольку p нормальная форма, то в цепочке из p в r только альфа-конверсия.
В цепочке из q в r аналогично.
Вот. Но тогда, поскольку альфа-конверсия обратимая, то можно сразу прийти из p сначала в r, потом в q.
Значит, так как альфа-конверсия обратима, то получаем, что из p можно сначала прийти в r, а потом прийти в q.
Ну, вот это и есть то, что нам нужно.
Ну, более-менее на этом заканчивается синтактическая часть.
Если у меня есть какие-нибудь вопросы, то у меня 5 минут еще есть, я бы чуть-чуть поговорил про номералы.
Нужно ли что-нибудь пояснить? Да, очень хорошо.
Так. Ну, а значит, про номералы в основном мы будем в следующий раз говорить, но сейчас я, может быть, все-таки успею о чем-нибудь сказать.
Так. Значит, вообще и бывают разные номералы. Я буду говорить про номералы Чорча.
Так. Нумералы Чорча. Чтяк они выглядят.
Так. Значит, сами номералы я буду писать как циферки с подчеркиванием.
Значит, номерал 0. Нумерал 0 это будет лямбда fx.x.
Так. Значит, номерал 1. Это лямбда fx.fx.
Нумерал 2. Это лямбда fx.fx.
Нумерал 3. Это лямбда fx.fx.
Вот. Ну и вообще, значит, номерал n. Это лямбда fx.fx.
Вот fx. Значит, где всего вот это вот f будет n раз.
Вот. То есть можно сказать, что номерал n переводит функцию f в ее n-ную итерацию.
Нумерал n переводит f в... Ну fn я напишу.
Но не степень, а итерацию.
N-ную итерацию.
Вот. Да, поэтому, значит, число это такое преподавание одной функции к другой функции.
Вот. Почему здесь лямбда fx? Ну потому что, смотрите, когда мы f подставим, то останется лямбда x.
Ну и лямбда x будет как раз функцией от x.
Так. А теперь, смотрите, если мы вот такие преобразования договорились считать номералами,
то дальше возможны уже разные действия над номералами.
Так. Тут еще есть такое слово комбинатор, которое я там один раз вскользь сказал.
Значит, на самом деле комбинатор это просто замкнутый лямбда терм.
Значит, комбинатор это замкнутый лямбда терм.
Вот. Ну и говорят, что, скажем, g большое...
g большое это комбинатор функции g малая,
которая берет ка-аргументов, возвращая значения.
Значит, комбинатор не функция, а там для функции или вычисляющая функция.
Комбинатор для функции g.
Значит, если, верно, следующее.
Если для любых n1 и так далее, nk, g.
А потом подряд идут номералы n1, n2 и так далее, nk.
Я здесь скобок не ставлю, но это значит, что они стоят по умолчанию.
То есть, вычисляется слева направо.
Если вот это вот равно, и вот здесь это равно в смысле равенства лямбда термов,
и тут будет g от n1 и так далее, nk, и как бы это все подчеркнутое.
То есть, если вот это комбинатор g на номералах действует точно так же, как функция g на числах.
Значит, вот это вот равенство в смысле нашего определения.
В смысле равенства лямбда термов.
Так, давайте я один пример успею показать за минутку.
Пример это инкрементация.
Значит, инкрементация, то есть, прибавление единицы.
Значит, инкрементация, это будет вот такая вещь.
Лямбда fx точка, ой, нет, подождите.
Лямбда nfx точка f от nfx.
Ну, тогда действительно, если мы применим,
значит, напишем инкрементация n, эта вся штука, примененная к n,
это означает, что мы просто вот эту лямбду убираем по n, а сюда подставляем номерал.
В смысле эта редукция, это будет лямбда fx точка f от nfx.
А теперь по определению, что это означает.
Это означает лямбда fx точка f.
Так, значит, а здесь будет...
Так, давайте я уже с бета, как бы, с переименованными напишу.
Значит, лямбда gy точка g, вот g, и так далее.
Вот gy, тут всех всего m.
Так, и тут еще fx.
Так, вот так вот, fx.
Ну, тогда, смотри, тут вот лямбда gy, а тут fx.
То есть снова эти же y на fx обратно заменяются.
Получается, что тут лямбда fx, вот это вот f остается,
а потом будет f от f от, и так далее, fx.
Вот, и как бы вот этих вот будет m.
Ну а вместе с этим будет еще plus 1.
То есть всего получается как раз номерал n плюс 1.
Вот, хорошо, значит, вот это самый простой пример.
План на следующий раз научиться все остальные функции делать.
Ну, на самом деле все остальные архиметические функции,
почти так же легко сделать сложение и умножение, ну и возведение в степень.
А вот для отрицания, особенно деления, нужны некреухищрения.
На следующий раз мы быстренько поймем, как делать сложение и умножение,
а потом, надеюсь, что успеем вычитание и деление,
и на этом наш курс закончится.
Вот, все, на сегодня все, спасибо.
