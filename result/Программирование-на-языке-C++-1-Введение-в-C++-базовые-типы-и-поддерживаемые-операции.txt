Фи-шна-шна-пи-на-пи-шна-пи-шна
Фи-шна-шна-пи-на-пи-шна-пи
Фи-шна-шна-пи-на-пи-шна-пи
Фи-шна-шна-пи-на-пи-шна-пи
Фи-шна-шна-пи-на-пи-шна-пи
Фи-шна-шна-пи-на-пи-шна-пи
Фи-шна-шна-пи-на-пи-шна-пи
Фи-шна-шна-пи-на-пи-шна-пи
Фи-шна-шна-пи-на-пи-шна-пи
Фи-шна-шна-пи-на-пи-шна-пи
Фи-шна-шна-пи-на-пи
Фи-шна-шна-пи-на-пи
Фи-шна-шна-пи-на-пи
можно и лично. В общем, как меня найти в телеграмме, вы знаете. У нас годовой курс
программированный C++. В первом семестре у нас будет зачет, во втором семестре у вас будет
экзамен. Зачет будет устроен примерно так, что... Зачет будет так выглядеть в первом
семестре. Примерно 60 процентов вашей оценки это задача. Примерно 30 процентов вашей оценки
это будет... Даже не так, наверное. Я бы сказал, где-то 65 процентов вашей оценки будут задачи,
35 процентов вашей оценки это будет теор-зачет в конце, а еще 10 процентов вашей оценки это будет
бонус от семинариста. Семинарист вам может иногда будет давать какие-то свои мелкие задачки,
или, возможно, за хорошую работу на семинарах вам начистится какой-то бонус. В общем, бонус.
Почему суммарно 110 процентов? Ну, потому что, чтобы набрать отл 10, вам можно в чем-то немножечко
продолбаться. Если бы суммарно было 100 процентов, то набрать 10 было бы слишком сложно, а так это не
настолько сложно. Хотя, что может быть. Ну, а во втором семестре у нас будет экзамен, и там будут другие
правила, про них уже весной расскажу. Экзамен будет годовой. Ну, курс, наверное, вас и так запугали,
что курс довольно сложный, материалов очень много, экзамен тоже довольно сложный. Короче,
вот это придется усиленно. И еще одна из проблем этого курса, в отличие от курса алгоритмов,
например, который начинается, так сказать, вместо карьеры, резко поехали. Наш курс, он очень
коварный, потому что начинается он очень легко. И вторая лекция не сложная, и третья лекция не
сложная, и вы такие, что тут все просто. И, короче, вы такие, думаете, генсилизируете, ну ладно,
а потом вы выясняете, что оказывается, на самом деле, все было сложно, просто сложность,
она растет вот так, и она как бы каждый год вот так возрастает. И поэтому, если вам первые четыре
раза кажется, что все легко, то это обман, и на самом деле дальше будет только хуже с каждым разом. Короче,
не поддавайте обманщему впечатлению, и не забивайте в середине. Вот, сейчас я поговорю
некоторое количество времени про какие-то вводные вещи, типа я поговорю общие слова о языке C++,
и почему он так устроен, а потом, и почему мы его замечаем, а потом начну уже содержать для
участия. Вот, значит, ведение, пролог, я бы сказал. Ну, язык программирования C++, вы, наверное,
большинство из вас на нем уже умеет писать, вот, в какой-то мере. Как вы знаете, он произошел
от языка C, и это все где-то происходило в годах 80-х, был такой язык программирования C, вот,
и в нем еще тогда не было объектно-оментированного программирования, не было, значит, всяких там
классов, ну, вообще, все было очень примитивно, были только функции, сырая работа с памятью, вот,
программы тогда были маленькие, большие проекты особо, мало кто писал, вот, я, к стыду своему,
не помню в каком году, но, в общем, когда-то человек, которого зовут Бьерн Страуструк, мы его
будем называть в курсе не иначе как создатель, придумал язык C++ на основе языка C, так что
обратная совместимость почти поддержана, то есть почти любая программа, которую вы пишете на C,
будет верна и на C++ за редким исключением, но это исключение там какое-то детальное,
ну, какое-то техническое, мы даже не будем такие программы рассматривать, в общем, можно с
достаточной долей точности считать, что если что-то вы на C написали, то оно и на C++, правильно,
аналогично будет работать, вот, я бы нарисовал такую картинку, вот, если это язык C и все его
возможности, то язык C++ это примерно вот, чтобы вы понимали примерно соотношение объема того,
что есть в этих языках, вот, если вы знаете язык C, ну, на самом деле, возможности языка C мы с
вами пройдем примерно так разно за первые там три недели, условно, и весь оставший год будем
говорить о том, что появилось в языке C++ по сравнению с C. Количество всяких фичей и возможностей,
которые современный язык C++ предоставляет, просто огромно, просто колоссально, и оно настолько
колоссально, что уже ни один человек в мире не помнит всю спецификацию языка C++ наизусть
полностью даже сам создатель. Это просто невозможно, вот. Существует такой документ,
который я вам сейчас покажу, который называется международный стандарт языка C++, вот, я вам
открыл версию 2020 года, это такой документ, в котором, как вы видите, 1841 страница мелкого
английского текста, это формальное описание, ну, вот, я не знаю, кто-нибудь из вас когда-нибудь читал,
там, какой-нибудь, не знаю, налоговый кодекс Российской Федерации, вот, примерно такого же уровня текст,
абсолютно формальный, очень мелкий, очень такой строго формализованный, ни в коем случае нельзя
воспринимать как учебник какой, допустим, C++, этот документ написан скорее для разработчиков
компиляторов, а также для тех, кто, в общем, ну, как справочник он скорее написан, здесь
формализовано, полностью описано все возможности. Я вам, например, открою какую-нибудь, значит,
статью, ну, вот, я не знаю, например, давайте я вам открою, вот, страницу 347, вот, параграф 13.2,
template parameters, и вот, пожалуйста, the sequence, вот, template parameter, и поехали, значит, вот, что
бывает, вот, какие бывают, значит, template parameters, вот, что такое type constraint, значит, вот,
формальное определение, вот, значит, ну, я думаю, вы поняли примерно стиль того, в котором этот
документ написан. Тут есть примеры, тут есть какие-то, значит, определения, в общем, 1800 страниц
вот такого текста, это современный язык C++. Конечно, мы с вами постараемся более-менее охватить
поверхностное, все то, что, ну, большую часть глав этого документа, но, разумеется, конца этого года вы
все еще не будете знать язык C++ полностью, и я его, конечно, не знаю полностью, ну, никто его не знает
полностью, вот. Тем не менее, язык C++ выбран нами как главный язык для изучения на первом курсе,
потому что есть такое поверье, что если вы уже на C++ пробовать умеете, то дальше вам все будет легко.
Ну, действительно, на примере языка C++ можно показать большинство концептов современного
программирования, вот, переход с других языков программирования на C++ довольно сложный, а C++ на
другие языки кажется проще, потому что когда вы после C++ учите другие языки, вам это кажется так,
а, ну, вот, эта штука как C++ только чуть-чуть по-другому, и все. Почти любой язык программирования
современный можно так изучить, просто зная C++, и даже если вы какие-нибудь вакансии будете смотреть
потом, например, я не знаю, вакансии на расте, зачастую бывает так, что в объявлении просто на
работу написано, ну, мы ожидаем, что вы знаете раст, но если знаете C++, то тоже подойдет. Вот
эта вот фраза, если вы знаете C++, то тоже подойдет, ее всегда очень приятно читать, потому что понимаешь,
ну, ты знаешь, это универсальный язык, к которой подходит много ничего. У языка C++ есть несколько
версий, давайте я вам нарисую последовательность версий, а хотя даже я, наверное, на предыдущем
слайде останусь. Значит, изначальная версия языка C++ называлась C++98, это был такой первый
исторический вот этот стандарт, который был издан в 98 году, потом он был несколько доработан,
улучшен и стал называться C++03, все это по годам, вот, потом через 8 лет издали версию языка,
которая называется C++11, с тех пор новые версии стали издаваться раз 3 года, после C++11 был
C++14, после C++14 был C++17, после C++17 был C++20 и после него был C++23, которые издали только в этом
году. То, что я вам открыл это C++20 и на самом деле, ну да, после C++23 будет C++26, как вы можете
догадаться. Вот, я несколько прокомментирую вот эту историю. Мы с вами будем в основном пользоваться
вот этой версией, и я сейчас вам объясню почему. На самом деле, если кто-то из вас сейчас думает,
что мы такие несовременные, на 3 года отстаём от трендов, это неправда. На самом деле,
мы очень как раз современные. C++20 это, пожалуй, самая современная версия,
которой сейчас люди пользуются. C++23 не пользуются в мире ещё, наверное, почти никто. Это даже не в России
мало кто пользуется, почти никто, а в России уж и подавно. Дело в том, что с момента выхода этого
стандарта проходит где-то года два, прежде чем компиляторы научатся его поддерживать. C++20
ещё не целиком поддерживается компиляторами, если что. Вот, мы с вами даже в этом году, в прошлом
году и позапрошлом постоянно такое было, а в этом году мы будем с вами постоянно сталкиваться,
ну иногда всё ещё будем сталкиваться с ситуацией, что эта фича вот уже три года как добавлена в язык,
но компиляторы всё ещё не научились нормально с ней работать, и есть некоторые тонкости,
что вот тут вот это не до конца имплементировано. Вот, но с тех пор как компиляторы научаются
поддерживать, ещё проходят года два-три, пока сообщество научается этим пользоваться. Ну то есть
сейчас я бы сказал, что большая часть, ну так, наверное, в основном все пользуются сейчас C++17
в индустрии. На C++20 более-менее вот современные компании переходят, там какие-нибудь флагманы
отечественной IT-разработки, вот они пользуются C++20. На C++20 ещё не все перешли, а C++23 ещё перешёл.
На самом деле, большая часть того, что я буду рассказывать, она актуальна для всех версий C++,
и разница между вот этими версиями, она у нас во втором семестре только проявится. То есть мы с
вами будем примерно идти, можно сказать, примерно в хронологическом порядке, то есть первый
семестр мы с вами будем изучать в основном вещи, которые были ещё до 2011 года актуальны. Вот,
почти весь второй семестр мы будем с вами изучать версии, которые после 2011 года появились.
Вообще C++11 это очень важная версия, это такая, я бы сказал, рубежная версия, ну прошло уже лет
перед ней. C++11 по сравнению с предыдущей версией был очень сильным расширением языка, ну я бы
примерно вот так нарисовал, если нарисовать круги, то вот обычный C++, там C++03, это примерно,
я не знаю, вот столько, по сравнению с C. C++11 это, я не знаю, примерно вот такой круг, ну и дальше
маленькие расширения появляются, там C++14, это ещё чуть небольшой круг вокруг него и так далее.
То есть новые версии, они всё расширяют, расширяют множество возможностей языка, и тем самым он становится
всё более и более необъятным, и выучить его целиком становится всё сложнее и сложнее. Вот. Ну последнее,
наверное, что я скажу про, а не, не последнее, я ещё пару вещей скажу. Вот, мне очень нравится такая
метафора, сравнение C++ с питоном, метафора связана с рестораном. Вот, как можно фигурально
описать, чем C++ от питона отличается. Вот, когда вы приходите в ресторан, у вас есть меню и там
перечислены блюда, которые вам могут приготовить. Если вы пробуете на питоне, то вы, по сути,
делаете так, вы приходите и у вас там готовые как бы реализованные средства под всё. А бывает так,
ну то есть не бывает, а представьте, что вы пришли в ресторан, а вместо блюд в меню вам просто
перечислен полный список ингредиентов на кухне, хранящихся, и вы целый мисс бумаги у вас пишите,
как хотите, рецепт какой угодно приготовим. Вот, понятно, что во втором случае вы приготовить можете
довольно странные вещи, которые бы на нормальном ресторане вам не сделали. Но с другой стороны,
даже чтобы сделать какую-то простую вещь, вам потребуется больше текста написать,
сильнее подумать, чем если бы вы были в обычном ресторане. Вот эта метафора, на мой взгляд,
идеально описывается между питоном и плюсами. Плюсы — это язык, в котором у вас просто почти
полная свобода, вот у вас белый лист и просто уйма того, что вы можете сделать, и надо всё
аккуратно прописывать, в случай не допустить ошибок, если там что-нибудь вы неаккуратно пишете,
у вас и сломается. На питоне и на более простых языках за вас всё сделано, только пользуйтесь
готовым набором возможностей. Вот, это объясняет, почему плюсы довольно эффективны, если их
правильно использовать и очень опасны, если использовать их неправильно. На плюсах пишутся
обычно очень крупные проекты, такие как Яндекс, Яндекс на большей части написан на плюсах, большая
часть сервисов Яндекса — поиск, почта, карты, такси, Яндекс диск, что ещё, музыка, большая часть этого
написана на плюсах. В ВК много чего написано на плюсах, Телеграм почти полностью написан на плюсах,
или вообще полностью. В Гугле и Фейсбуке тоже аналогично, многие части написаны на плюсах. Многие
игры написаны на плюсах, особенно те, которые требуют большое количество ресурсов компьютера.
Операционные системы написаны на плюсах, такие как Windows и MacOS, они написаны не полностью,
но частично на плюсах. На смеси C и плюсов они написаны, ну и C sharp немного, в случае Windows.
И ещё на плюсах пишутся биржевое программное обеспечение, ну мост биржа написано на плюсах,
сервер мост биржа на плюсах крутится. И криптовалюта, например биткоин, написано на плюсах. Ну и всякие
трейдинговые конторы тоже на плюсах пишут, которые с биржей взаимодействуют. Короче,
область применения очень широкая, много всяких научных вещей написано на плюсах,
плюсы используются, насколько я знаю, физиками для расчётов каких-то научных, тоже в силу своей
низкого уровневости эффективности. Короче, вот эти плюсы не прогадай. Вот. Ну и я вам покажу ещё две
полезных ссылки, даже три. Вот это так называемый рейтинг языков программирования TIOBE, пожалуй,
наиболее известный рейтинг языков программирования. Вот по состоянию 2023 года у нас сейчас самые
популярные языки программирования, согласно этому рейтингу, как вы видите, Python, C++ и Java. Ну в общем-то,
это и будут те языки, которые вам предстоит изучать. Python поднялся на первое место только в этом году,
он очень популярен за счёт изменения в машинном обучении, а также за счёт того, что низкий
порог входа. Ну а вот C и плюсы, те языки, которые имеют высокий порог входа, применяются на того,
что я сказал, и вот их нам с вами предстоит изучать весь первый курс. Следующая полезная ссылка – это
CPP Reference. Это такой сайт, это такая википедия о языке C++. Вот если у вас, если, значит, стандарт – это
полностью формализованный документ, по которому невозможно учиться, его невозможно читать,
просто только если вам нужно какую-то вот очень глубокую деталь выяснить, то CPP Reference – это такая
википедия, по сути, которая вам в более читаемом виде излагает возможности каких-то фичей. Ну,
например, вот вы хотите узнать, что такое Вектор, вы открываете, и тут объяснено, что такое Вектор,
и тут написано, значит, какие у него есть общие слова о том, что он умеет, и дальше вот какие у него
есть методы, какие функции есть. Ну, например, вот как работает Вектор, там, не знаю, оператор
квадратной скобочки в Векторе. Ну вот, пожалуйста, вам здесь написано, что умеет оператор квадратной
скобочки в Векторе, как он работает, и пример. Очень удобно также здесь то, что про каждую фичу
написано, как она с входом версии менялась, то есть, вот видите, до C++20 было так, а начиная с C++20
стало так. В чем разница? Ну, вот слово context добавилось, чтобы это не значило. И так про все
здесь написано, то есть, про некоторые вещи, может, и прям целую историю, там, до C++11 так, C++17 так,
и так далее. В стандарте, конечно, вы такого не увидите, потому что в стандарте фиксируется версия
для кого-то. Вот. Я рекомендую вам именно этот сайт для того, чтобы, ну, так, на начальных кварах
что-то узнавать по плюсы, причем рекомендую английскую версию in.sik.com. Есть и русская версия,
но она раза в три меньше информации содержит, поэтому, короче, все вот эти английские и читаете
англоязычные источники информации в интернете. Ну и сейчас я вам сообщу самое главное знание,
которое вы должны запомнить с этой лекции. Вообще, если вы запомните единственный факт этой лекции,
а все остальные забудете, то пусть это будет он. Есть такой замечательный сайт, называется Stack Overflow.
Когда вы не знаете чего-то, когда у вас что-то не работает, какой-то баг, и вы не знаете,
как его чинить, значит, вообще у вас есть любой вопрос о программировании, вашим источником ответа
на вопрос должен быть этот сайт. Ну, вашим источником ответа на вопрос должен быть Google,
конечно, в первую очередь, или Яндекс, кто там что любит. Вы открываете Google, вбиваете свой
вопрос, желательно, на английском, и с вероятностью 90% вы найдете ответ на этом сайте. Этот сайт построен
как вопросно-ответная система, то есть это такой форум, где люди просто задают вопрос типа,
ой, у меня баг, что же мне делать? И люди в ответ пишут, что же это значит и что ему делать,
но, разумеется, все по-английски. Вот, я вам гарантирую, что вот 99% вопросов, которые у вас будут
возникать по плюсам в течение этого семестра, да и 90% вопросов, которые вы найдете в течение этого
года, уже содержат ответы на этом сайте. Поэтому, если вы хотите написать в чат, а что значит эта
ошибка, то задумайтесь. Наверное, вы не первый, с этой ошибкой, и, наверное, ответ уже есть в интернете.
Вы, конечно, можете написать в чат, но по секрету вам скажу, старший разработчик отличается от Джуна тем,
что он умеет искать решение проблем самостоятельно, и если вы научитесь гуглить и пользоваться сайтом
Stack Overflow, прежде чем напрягать других людей, это будет огромный плюс вам в карму. Ну, не только в
учебе, а вообще в работе, вообще в жизни. Если у вас есть ошибка, постарайтесь, в первую очередь,
найти ее на этом сайте. Ну, или в гугле на этом сайте найти перепись, потом пишите в чат. Наверное,
это все, что касается вводной части. Дальше можно перейти к неводной части, но неводная часть все равно
будет несколько вводная, потому что сейчас я начну первую главу моего представления,
которая называется «Введение в C++». Я для удобства, по традиции, буду делить материал на главы,
а внутри глав на параграфы. Мне кажется, так удобнее структурировать. И первая глава называется
«Введение». Как ни странно. Я скажу, что первая глава называется «Introduction C++»,
и первый параграф будет называться, значит, параграф 1.1, у меня будет называться, ну,
компилятор и первая программа. На самом деле этот пункт вам, скорее всего, уже изложили на семинарах,
не так ли? Ну, у вас у всех или почти у всех уже был первый семинар. Задача первого семинара была
то, чтобы вы все из вас научились запускать команду и строчку, выполнять базовые команды и компилировать
простейшую программу на плюсах. Я очень коротко повторю, вкратце, быстро напомню, как выглядит
простейшая программа на плюсах и как вообще она запускается. Я сейчас нахожусь в терминале
линукса. Вам, наверное, всем сказали, что мы настоятельно рекомендуем установить что-то
линуксподобное на свой комп. MacOS, в принципе, подойдет, потому что там все почти так же,
с точки зрения терминала и, значит, команд в нем. Вот, если у вас винда, то, возможно, вам подойдет,
там, значит, VSL, так называемая, да, значит, Windows Subsystem for Linux, вот, но не то, чтобы винда это
что-то, за что мы будем вас наказывать, нет, конечно, если вам по какой-то причине очень нравится винда,
можете продолжать и пользоваться, но просто, так сказать, дружеский совет состоит в том, что чем
раньше вы привыкете к линуксу, тем лучше. Вот прямо сейчас, вот прямо вот в ближайший, не знаю, месяц,
вы вообще не умрете от того, что у вас линукс, а не винда, а не линукс, и в ближайшие два месяца, но вам
может будет зачет посложнее сдавать, потому что вам придется там, у вас на компе это не будет
просто воспроизводиться, вам зачет в декабре будет сдавать очень неудобно под виндой, но тем
не менее вы выживете и с виндой. Другой вопрос, что вам же лучше этим к линуксу начать привыкать
раньше, и чем раньше вы к нему привыкнете, тем легче он потом будет и на втором курсе, когда
линукс уже непосредственно будет нужен, на втором курсе месяц, он будет посвящен линуксу, и на работе,
если вы придете на работу, вам, вероятно, тоже надо будет иметь пользу целиться. Короче, чем раньше
начнете привыкать, вам же лучше, поэтому рекомендую начать привыкать уже сейчас, чтобы через полгода
для вас было естественным все эти команды, и на втором курсе, тем более, чтобы вы свободно с командой
с такой работой. Вот, ну, значит, я нахожусь вот в этой директории CEP 2023 внутри моей домашней
директории, я могу посмотреть полный адрес этой директории командой ПВД, я могу перейти в другую
директорию команды ЦД, я это все очень быстро проговариваю, потому что вам это на семинаре,
скорее всего, рассказывали, правда? Вот, я могу использовать команду ЦД, change директория, для того,
чтобы ходить по директориям, вот, например, могу перейти на директорию на уровень верх, вот так, вот,
могу использовать команду ЦД минус, чтобы вернуться туда, где я был до этого, очень полезна команда,
может быть, вам про нее не рассказали, рекомендую, очень удобно. Ну, назад, просто, туда, где вы были до этого.
Две точки это директория над моей, это как бы кнопка вверх, а минус это назад, вот, это полезно.
Извините, нам сказали, что ЦД минус один раз только работает. Это правда, только один раз работает,
к сожалению. Несколько раз в подряд не получится, будете ходить между двумя последними. Вот, ну,
если вам хочется ходить много раз назад вперед, то есть такие специальные команды ПушД и ПопД,
можете погуглить про них, я сейчас не буду про них рассказывать, в общем, если интересно, погуглить.
ЦД без параметров — это возвращение в домашнюю директорию. Вот, также есть команда, да, ну,
также есть, значит, абсолютная адреса, slash в линуксе обозначает корень всей файловой системы,
вот, я могу перейти в него. У меня есть команда ls от слова list, которая мне показывает список,
что есть текущая директория, где я сейчас нахожусь, вот, причем у меня синим цветом изображены папки,
ну, или другие директории. Голубым цветом у меня изображены ссылки, ну, файлы, которые являются
ерунками в терминах Windows, в терминах Linux, это ссылки на другие файлы. Вот, я могу также написать ls
minus l, чтобы отобразить информацию подробно о файлах, в которых текущая директория содержится. Вот,
здесь перечислены права доступа к файлу, кто является владельцем файла, размер файла и дата
последнего изменения. Вот, значит, ls — это чтобы отображать, какие файлы у меня есть, ну и, да и все,
наверное, что мне сейчас больше ничего особо не потребуется. Значит, вот, я возвращаюсь в папочку
cd2023. Вот, я хочу сейчас написать, скомпилировать и запустить простейшую программу на плюсах. На самом
деле, она у меня уже написана, вот, я ее подготовил, программы, да, я буду называть согласно,
нумеровать согласно пунктам нашего изложения, вот, один, знак подчеркнение 1, это значит программа,
которая будет соответствовать первому параграмму первой главы. Вот, чтобы написать простейшую программу,
мне пригодится... ладно, нет, про текстовый редактор я позже расскажу. На самом деле у меня
программа уже написана, я вот ее заранее заготовил, вот такая простейшая программа. Я вывел просто
содержимое этого файла с помощью команды cat. Про нее вам тоже рассказывали, да, в линуксе cat — это значит
вывести содержимое некро, значит, кошечку позвать надо. Вообще, в линуксе названия команд порой очень
забавные, я даже не знаю, там, в общем, иногда они бывают очень смешные и делают совсем не то,
что вы ожидаете, исходя из названия, вот, например, там, не знаю, команда kill забавная,
послать сигнал в процесс. Ну вот, знаете, такие названия, они исторически сложились, но они порой
очень странные. Ну вот, что делает эта программа? Ну, как вы, наверное, понимаете, эта программа, она
вводит в клавиатуру число и выводит его же увеличенное на пять. Вот, здесь у нас первой
строчкой написано include eostream, это так называемая директива при процессора, которая говорит о том,
что мы хотим подключить заголовочный файл eostream к нашей программе, то есть мы хотим
воспользоваться той частью стандартной библиотеки, которая содержит средство стандартного
ввода-вывода, ну, input-output-stream, мы хотим как бы подключить потоки ввода-вывода, чтобы можно было
пользоваться вводом-выводом к консолям нашей программы. Если бы я не написал include eostream, то вот
это вот бы у меня не работало. std-in и std-out были бы не определены, потому что они как раз определены вот
здесь. У вас, конечно, может возникнуть вопрос, а что конкретно означает вот это include eostream,
а что именно написано в этом файле include eostream. Мы сейчас не будем в этом углубляться, сейчас наша цель
это быстро научиться писать программы и там познакомиться с базовыми возможностями языка,
поэтому что конкретно делает include и что именно написано в файле eostream, мы пока опустим это,
будем воспринимать как некоторые заклинания, которые необходимы, чтобы работали потоки ввода-вывода.
Дальше у нас есть функция main, которая традиционно имеет возвращаемый тип int, ничего не принимает,
и вот внутри этой функции мы, собственно, и пишем код, который хотим, чтобы исполнялся. Main это
такое вот название, которое обязано быть в каждой программе у функции, если вы хотите, чтобы с нее
программа начиналась. Main это захардкоженное название, которое требуется от функции,
чтобы она была точкой входа в программу. Main, в принципе, при некоторых условиях, иногда возвращать
имя int, кажется, и она может тогда что-то принимать, но мы сейчас опять не будем про это говорить, это все
тонкости, в которые углубляться мы когда-нибудь потом начнем, а пока что мы это опять воспринимаем как
заклинание, если вы не понимаете, что такое int, main, вот это все, ну просто воспринимаем как заклинание,
надо это писать и все. А, собственно, код, который будет выполняться, уже мы начинаем писать внутри
Main. Ну, собственно, что здесь написано, мы объявили переменную X, ввели ее с консоли с помощью CIN,
вот CIN это такой как бы поток стандартного ввода, с помощью вот такой операции из него, как бы,
можно вводить переменные, а CAU это поток вывода, на который можно что-то выводить. Теперь я хочу
программу скомпилировать, и чтобы ее скомпилировать, мне нужно воспользоваться компилятором. Да,
компилятор, которым я обычно буду пользоваться, TG++, есть и другие компиляторы, например,
C-Lang, а еще MSWC, это, пожалуй, три основных компилятора, которые есть для языка C++ на данный момент,
вот, мы в основном будем пользоваться G++ и C-Lang, у них, кстати, открытый исходный код,
вы можете прямо найти в интернете код компиляторов, и код стандарта библиотеки
тоже можете найти, как реализован, вот, но мы сейчас опять будем просто пользоваться
черным ящиком, я пишу G++ и название своей программы, и она успешно компилируется,
вот, ничего не выявилось, это значит, что не произошло никаких ошибок, ну и хорошо. Я могу
снова посмотреть, что у меня есть в директории, и увидю, что появился файл a.out, ну вот, по некоторому
соглашению, опять, я воздержусь в комментариях, почему так, но вот почему-то, если вы компилируете
свой файл, то по умолчанию, результат компиляции приобретает имя a.out, в принципе, я могу явно
попросить, чтобы было имя другим, например, я могу попросить b.out, ну я вообще могу как угодно
назвать, не знаю, вот так, для этого я должен написать "-o", от слова output, и какое-то имя,
и теперь у меня скомпилируется эта программа, файл, который будет называться вот так, но мне
это будет точно никогда не нужно, я буду просто, у меня стандартное имя, короче, будет устраивать,
вот, я удалил выезжний файл, команда rm удаляет файл, remove, вот, отлично, теперь у меня есть этот
файл, и его я могу запустить уже, это уже исполняемая программа, вот, c++, в отличие от питона, это
компилируемый язык, как вы, наверное, знаете, языки программирования бывают компилируемые и
интерпретируемые, что такое компилируемый язык, это язык, что такое, чтобы запустить программу,
написанную на этом языке, нужно сначала взять целиком исходный код этой программы, и проделать над
ним некоторую операцию компиляции, которая превращает исходный код в исполняемый файл, и вот уже
исполняемый файл можно запускать, этим c++ отличается от интерпретируемых языков, например питона, где,
если у вас есть файл с расширением файла, вы можете его исполнять построчно, вам не нужно превращать
файл с кодом на питоне в какой-то специальный файл, в динарном, ну, с какой-то другим кодом, чтобы
его исполнять, нет, вы можете исполнять просто файл на питоне, как он есть, как он написан строчкой за
строчкой, файл на плюсах, вы так исполнять не можете, ну, если только вы не занимаетесь дебатом,
отладкой специально, специальные утилиты, которые позволяют построчно выполнять, но стандартно вы
должны собрать из c++ кода исполняемый файл, и вот его уже исполнять, я могу написать cat a.out и
увидеть кучу какой-то белеберды, вот, да, a.out так исполняемый файл, вот, если я попрошу вывести
содержимое файла a.out на экран, то я увижу, что там куча какой-то белеберды непонятны, это потому,
что это файл с бинарным кодом, то есть это уже не человекочитаемый код, это бинарный код,
который понязан процессору, но тут какие-то значки, какие-то символы, на самом деле там просто какие-то
вот непонятные рандомные символы, но в бинарном представлении это инструкции, понятные процессором
для исполнения, понятные центральным процессором, чтобы он исполнял свой саммерный инструкции,
тут есть какая-то дополнительная техническая информация, какие-то там слова, но вообще это
как бы бинарный код, поэтому неудивительно, что файл a.out не читает, в отличие от файла 1.cpp,
вот, ну чтобы его запустить, мне нужно писать .slash a.out, вам наверное рассказывали, почему я должен
писать .slash a.out, рассказывали, чтобы запустить какую-то программу, я обычно просто пишу ее название,
если я так напишу, мне скажут command not found, почему, потому что по умолчанию программы для
исполнения ищутся в стандартных директориях, где хранятся исполняемые программы, а не в моей
текущей директории, конкретно вот есть такая системная переменная path, в которой перечислены
директории, в которых ищутся программы для исполнения по умолчанию, значит, я сейчас написал,
ну опять-таки вам, я надеюсь на семинаре про это рассказали, но если не рассказали, вам расскажут,
попросите семинариста, чтобы он пояснил поподробнее, есть системная переменная,
так называемая path, которая вот содержит список адресов и директорий, в которых ищутся программы
для исполнения по умолчанию, команда echo, это команда, которая позволяет вывести на экран
значение переменной, либо какое-то сообщение, например, я могу сказать hello, выведите просто hello,
а если я пишу dollar, то он как бы пытается взять система, прям операционно-системистская переменная path
и в ней хранится вот это, и вот если бы моя программа a.out лежала где-то в одной
директории, тут они двоеточем разделены, то я бы мог ее запустить без указаний откуда,
но поскольку она лежит в моей текущей директории, мне нужно явно указать сколько
директорий я выпускаю, и точка обозначает текущую директорию, вот две точки обозначает директория
над моей, на уровне вверх, а одна точка обозначает текущую директорию, поэтому чтобы мне указать,
из какой директории я выпускаю, я пишу точка slash a.out, ну вот и запутился, ввожу 5, вводится 10,
ввожу 3, выводится 8, прекрасно. Можно просто еще? Да. Path, это что такое? Path это системная
переменная, ну вот в операционной системе, как и в программах, есть некоторые переменные, вот,
и в этой переменной содержится строка текстов, в которых перечислены адреса директории,
разделенные двоеточем, и эти адреса обозначают директории, в которых ищутся исполняемые файлы
по умолчанию. Ну, например, я могу вот написать ls, вот тут у меня есть usr local bin, вот я могу
написать, например, ls usr local bin, чтобы посмотреть все, что лежит в этой директории, там почти ничего
не лежит, ага, только мои вкаджеры чек не лежат, ну хорошо, давайте я какую-нибудь другую директорию
попрошу, ну просто usr bin, например, там лежит куча исполняемых файлов, то есть это как бы директория,
в которой лежат исполняемые файлы по умолчанию, вот, программы ищутся в ней, если вы по умолчанию
запускаете, если бы я вот этот файл a.out положил в одну из этих директорий, то я бы мог писать
просто a.out, он был запущен, нашелся, мне бы не приходилось директории явно управлять. Ну, кажется,
в принципе, это все, что я даже хотел рассказать про компиляцию запуск простейшей программы на
плюсах, ну, наверное, пожалуй, пара вещей, которые я добавлю, это некоторые параметры компиляции
полезные, да, во-первых, у компилятора какого языка программирования есть версии, вот, я могу
написать g++-v, и тем самым я попрошу g++ сообщить мне некоторую информацию о себе, да, вообще,
там, довольно часто бывает так, что параметр –v, ну, он либо означает version, либо означает
the ghost, что означает многословный, если вы добавляете параметр –v в какой-нибудь
команде, зачастую это заставляет ее вывести побольше текста, пояснить, что происходит,
g++-v сообщить информацию о g++, о моем текущем, вот, и здесь много чего написано, вот, тут написано,
как он сконфигурирован, значит, под какую платформу, там, еще что-то, вот, что интересно,
gcc version 9.4.0, скобочка к убунту 9.4.0 под убунту 20.04, вот здесь написано, какая версия компилятора 9.4.0,
это довольно старая версия, а современная версия уже, по-моему, 12-ая последняя, или 12-ая,
я не помню, может, 14-ая, вот, но не надо путать версию g++ с версией языка, это разная совершенно
вещь, вы можете думать, что версия g++ 20-ая, значит, вам g++ 20-ой нужен, нет, неправда, вот,
у меня есть еще g++ 11-ый, и он, ну, у меня просто установлено разные, g++ здесь, вот, есть 9-ый, есть 11-ый,
вот, g++ 11-ый спокойно справляется компилировать gcc g++ 20-ый, вот, g++ 9-ый в меньшей степени поддерживает,
gcc 20-ый, если вообще поддерживает, ну, короче, просто имейте в виду, что версия компилятора это не версия
языка, они разные, и вы можете открыть сайт gcc.gnu.org, и там будет написано про каждую версию gcc, g++,
что он уже поддерживает из стандартов c++ каких, ну, вот, g++ 11-ого нам для почти всех нужд хватит,
c++ 20-ого он почти полностью поддерживает, 11-ая версия g++ нам достаточно почти для всех целей, вот,
так что можете пользоваться нейтам, если вдруг будет чего-то не хватать, мы там отдельно.
У нас в контесте, по-моему, будет 14-я версия силенга стоять, так что ориентируйтесь на это, вот, ну, в контесте,
нам задачу давать надо будет, версия силенга, наверное, 14-ая, но опять-таки имейте в виду, что это никак не связано с версией языка,
14-ая версия силенга это не значит, что 14-ая версия плюсов, там 20-ая, помните, версия плюсов, но версия просто
имена компилятора 14-ая, еще версии у стандартной библиотеки разные бывают, и они тоже там номерация
отличается, в общем, запутаться есть много возможностей, вот, я могу g++ явно указать, в какой версии c++ я хочу компилировать,
вот, по умолчанию, кажется, он у меня сейчас компилирует версии, я даже не знаю в какой, ну,
неважно, вот, я уверен, что в, что меньше, чем 20-ый, вот g++ 9-ый, g++ 9-ый по умолчанию компилирует, скорее всего,
либо в 14-ой, либо в 17-ой версии, g++ 11-ый, наверное, по умолчанию компилирует в 17-ой версии, я могу явно попросить его компилировать в другой версии языка,
для этого мне нужен параметр, минус std равно c++ и какая версия, например, 20-ый, вот, я могу явно попросить
компилировать мою программу в версии языка c++ 20-ый, вот, а вас, кстати, учили пользоваться vim'ом,
прекрасно, да, ну, сейчас мне потребуется открыть vim, чтобы отредактировать файл,
да, значит, ну, я сейчас чуть-чуть хочу поменять свою программу, чтобы проиллюстрировать разницу
версий языка, вот, чтобы редактировать файлы из консоли, ну, я, конечно, могу, в Ubuntu есть там
текстовый редактор графическим, графическим интерфейсом, я, в принципе, могу и си-лайн какой-нибудь
установить сюда и в нем писать, но я, в основном, буду все делать из консоли, но мне так нравится,
заодно вас буду мотивировать забота с консоль, потому что, когда вы пробуете из консоли, вы
выглядите крутым, вот, на самом деле, уметь пробовать из консоли полезно, уметь редактировать файлы из
консоли тоже полезно, потому что, когда вы, например, ну, опять-таки, вы приходите на работу, я не знаю там,
я привожу примеры из Яндекса, потому что я дольше всего работал в Яндексе, но если вы придете в какое-нибудь
другое место и вам нужно зайти на какой-нибудь удаленный сервер и на нем что-нибудь отредактировать,
то у вас, конечно же, нет графической оболочки, вы просто заходите на удаленный сервер через консоль,
и вот у вас консоль, вы находитесь на удаленном сервере, не знаю, на серваке какого-нибудь Яндекса,
ВК, не знаю, какого-нибудь банка, и вам нужно там что-то сделать, как вы будете это делать, вам нужно
уметь из консоли что-то, ну, файлы редактировать, и поэтому вам полезно уметь пользоваться текстом
редактором из консоли. Ну вот, пожалуй, самый крутой текстовый редактор, который существует в консоли,
это ВИМ, его крутость вы пока в скорейшем состоянии оценить, но, если что, ВИМ, так же, как и язык C++,
можно изучать целый год и до сих пор не знаю, и все еще не знать всех его возможностей. В интернете есть
целый обучающий курс по ВИМу, можно там семестровый курс по ВИМу почитать. В чем именно крутость ВИМа как текстовый редактор,
или почему мы из консоли хотим научиться пользоваться? Потому что, вот еще раз, вот я
работаю на работе, у меня есть, не знаю, вот сервера Яндекса, они стоят там в дапп-центре, где-нибудь там,
вот, не знаю, во Владимирской области, и вы должны зайти на этот сервер, на удаленный, и на нем что-то
сделать. Например, у вас там крутится бэкэнд, не знаю, Яндекс.Такси, и вот вы обнаружили, что там байки какие-то,
Яндекс.Такси сломалась, залогала, или там, я не знаю, Яндекс.Музыка. Вот вы зашли на сервер, где работает
непосредственно программа, которая отвечает пользовательные запросы, и поняли, что что-то не так работает,
и вам нужно из консоли суметь это починить. А как вы это будете делать? Вы же удаленно зашли, у вас же
нет графического интерфейса, и вам нужно текстовые файлы какие-то отредактировать, например, и что вы будете делать?
Да, 2 гигабайтные текстовые файлы с логами всего того, что происходило на сервере за день. Вам, конечно,
удобнее будет перекинуть себя на комп, отредактировать у себя, потом закинуться обратно. Нет, лучше
редактировать прямо там. Вот, короче, из консоли полезно увидеть пользователь с текстовым редактором.
Чем крут ВИМ? ВИМ, по сути, это тоже среда программирования. Короче, профи по ВИМу, они умеют
прямо в ВИМе писать скрипты, которые текст редактировать, вы можете прямо в ВИМе, там, я не знаю,
написать скрипт, который бы ваш текст обработал каким-то очень сложным образом, там какой-нибудь
алгоритм обработки вашего текста бы сделал прямо внутри текстового редактора. Вот, мало
какие текстовые редакторы умеют так много, как ВИМ в плане обработки текста, но главное,
этим надо уметь пользоваться. Ну, по ходу дела вы увидите, что умеет ВИМ, я думаю, по мере
того, как мы им пользуемся. Вот, я открыл, значит, твой файл. Самое главное знание про ВИМ какое?
Как выйти из ВИМа. Как выйти из ВИМа, да, потому что есть анекдот, мой знакомый пользовался ВИМом
20 лет, потому что не знает, перед ним выйти. Как выйти из ВИМа? Двоеточие Q, воскресательный знак Enter.
Да, но это выход без сохранения изменений. Чтобы выйти с сохранением изменений, двоеточие WQ Enter.
Если вы ничего не меняли, то можно просто написать двоеточие Q Enter, и вы выйдете. Двоеточие что? X.
Я такого не знаю. Двоеточие WQ Enter. Двоеточие WQ, да. Прикольно, ну вот вживи, как учись. Нет, я сразу говорю,
что я ВИМ плохо знаю. Как и плюсы. Да. Каждый год узнаешь что-то новое. Чего?
Еще раз сохранение. Да, WQ. Ну вам это на семинарах расскажут, это сейчас не тема лекции, это вы там на семинарах разберетесь.
Так, окей. Значит, чтобы начать твой текст, нажимаю клавишу I, и теперь могу редактировать текст.
Можно еще вопрос? Да. А пишет ВИМ не найден, его надо написать вии? Да, сюда отсюда. Да, ты можешь написать вии,
а если у тебя не найден ВИМ, у тебя челкунта или что? Я просто не знаю. Ну если у тебя он не установлен, то надо установить. Судо, аптенстал, там. ВИМ. Чего? Манжара.
У него манжара. Это что? Это дистрибутник. Я не знаю. Ну короче, теперь надо тебе его установить. Но скорее всего у тебя должен быть ВИМ, а не ВИМ.
В общем, это неважно. Сейчас это не тема пары, тема рассказать о основном программе на плюсах, поэтому ВИМ это такое. Про ВИМ вы на семинарах поговорите.
Вот, ну давайте я что-нибудь такое напишу, но я не знаю там. Ну вот, например, вот есть такой задаловочный файл с ВИМ,
на первом мне пришедшего в голову, который только 720 появился. И вот я, значит, давайте попробую скомпилировать свой файл сейчас.
И вдруг обнаруживается, что нет такого. Почему? Ну потому что версия языка не та. Я даже с G plus 11 скорее всего не смогу это скомпилировать. А нет, смог.
Ну вот если я G plus плюсу явно скажу, скорее всего это не сработает, потому что G plus plus 9 еще не умеется, G plus plus 20. Да, к сожалению.
Ну я могу какую-нибудь другую, наверное, использовать штуку. Ну вот, например, есть такой еще замечательный задаловочный файл VARIA.
Вот он с G plus 17 появился. Неважно абсолютно, что это. Я просто вам показываю пример того, как вот я сейчас компилирую, а блин, задаловочный файл у меня не работает.
Ну, что-то пример мне не дается раз за разом. Что-то что-то не так. Ну он не должен был скомпилироваться. Ну да, да. Ну...
Ну поставьте версию там с G plus плюс 9. Ну хорошо, давайте я напишу минус с T D равно с G plus. Ну просто загаловочный файл это есть, в самом-то и дело.
Ну вот если я напишу так, то все равно работает, потому что загаловочный файл есть. Ну давайте я попробую этот VARIA здесь создать.
Ой, господи, что я пишу из GUT-а? Вот я пишу STD VARIAN от INV. Ну и если я сейчас скомпилирую, то вот это он уже не сможет сделать, потому что загаловочный файл хоть и есть у меня в файловой системе, но сам VARIAN это не член STD, если я компилирую без версии C plus 17.
Вот видите, написано STD VARIAN, Available from C plus 17 onwards. Ну если я попрошу минус с T D равно с C plus 17, то все работает. То есть я могу явно указать вещь в языках, которые я компилирую.
Наверное, это все, что я расскажу сейчас про компилятор и компиляцию.
Витя, может, вопрос? А чтобы запускать с командой STD, типа вот мы отредактировали его и нажали GEPTPS 1.1.1.1.cpp. Это значит, ну когда мы сделали GEPTPS 1.1.1.cpp, это типа мы сделали так, чтобы все изменения произошли, или что?
GEPTPS 1.1.1.cpp, это значит, я взял вот этот файл 1.1.1.cpp и превратил его в исполняемый файл.
Да, и после этого уже можно что угодно вводить и он будет выводить?
После этого я могу запускать в исполняемый файл, и будет омоценная программа.
А, сейчас, то есть, типа, написать название исполняемого файла, потом входные данные?
Ну, не обязательно входные данные, у тебя может и не быть входных данных, просто когда я запускаю a.out, запускается вот эта программа, да, которая вводит X, а потом выводит XQS 5.
Ну, еще-то какой-то variant создается, но это неважно, что он не выводит.
А, то есть, это просто сама программа.
a.out, запуск самой программы, которую я написал.
Конечно, я же про это говорил.
Так, окей, на этом закончилось знакомство с компиляторами первой программы.
Так, следующий пункт нашей программы это основные типы и операции над ними.
Вообще, зря я закрыл зум, потому что белая доска-то мне сейчас все-таки нужна, потому что я начал ее рисовать.
Сейчас я буду снова рисовать, и это будет параграф 1.2.
Ой-ой-ой-ой-ой.
Значит, параграф 1.2, ну, скажем так, базовые типы и поддерживаемая операция.
Я пишу по-английски, по привычке, потому что, ну, вся информация, которую вы будете гуглить, скорее всего, будет на английском, и чтобы привыкать к терминологии, мне кажется, полезнее на английском.
Итак, как вы, наверное, знаете, а может, вы не знаете, C++ это язык с статической типизацией.
Что такое статическая типизация? Ну, какая еще бывает типизация?
Динамическая.
Да, еще была динамическая типизация.
Еще вообще бывает, что нет типизации, но это вообще приемлемо.
Значит, пример языка с динамической типизацией, это, например, что?
Питон.
Да, опять питон. Вот.
Ну, что такое динамическая типизация?
Это когда типы переменных меняются по ходу выполнения программы.
Вот в питоне вы написали x равно 5, а потом внезапно взяли и написали x равно abcde.
То есть x был int целым числом, стал строкой.
Нормально, бывает.
Потом x опять стал чем-то другим.
То есть прям по ходу выполнения программы тип переменной меняется.
Это называется динамическая типизация.
Типы определяются в рантайме.
В рантайме, то есть во время выполнения.
Вопреки этому статическая типизация означает, что в момент компиляции программы,
уже на момент, когда исполненный файл создан, типы всех переменных известны,
и в ходе выполнения программы они не могут меняться.
Вот.
Это одно из важных знаний про язык C++,
которое может, скажем так, в трудные, темные времена
спасти вас от заблуждения, от неверного пути.
Запомните раз и навсегда, что типы переменных C++
никогда, ни при каких обстоятельствах в ходе выполнения программы не меняются.
Конечно, вы можете создать другую переменную,
которая называется так же, при некоторых обстоятельствах,
и это будут две разных переменных с именем X.
Одна будет им, другая будет строкой.
Но это все еще означает, что если какая-то
переменная начальна была интом,
она не может стать строкой по ходу выполнения программы.
Во втором семестре у вас может возникнуть обманчивое ощущение,
что это все-таки не так,
а что типы переменных удалось поменять в рантайме.
Нет, это обман были.
Значит, несмотря на то, что я вас буду пытаться обмануть в какой-то момент,
не верьте,
типы переменных не могут меняться в ходе выполнения программы.
В какой-то момент это нам пригодится.
Так вот, статическая типизация.
Типы переменных раз мы всегда обманулины
в момент, когда программа
перед запуском программы.
Вообще, понятия статические и динамические,
они будут очень часто в нашем курсе встречаться,
несколько раз будут встречаться,
этот первый раз.
Статический означает такой,
который на этапе компиляции происходит,
или известный этап компиляции.
А динамический, который в ходе выполнения происходит,
или что-то с ним случается.
Пока что у нас только типизация статическая и динамическая бывает,
потом будет еще что-то, кое-что.
Еще много чего.
Ну хорошо, вот я научился объявлять
переменные там.
И типа INC,
и, значит, вонить-вонить на экран.
Давайте поговорим о том,
о какие еще были типы.
Ну, наверное,
первая, это
целочисленные типы.
Integral types.
Целочисленные типы,
это типы, которые позволяют хранить целые числа.
Самый распространенный тип,
самый базовый, я бы сказал,
который мы будем всегда пользоваться,
и в большинстве примеров он встречается,
это INT.
Но кроме INT, еще какие есть целочисленные типы?
Еще есть LONG,
еще есть LONG-LONG.
Вот.
Давайте сначала вот про эти поговорим.
Чем они отличаются?
Они отличаются диапазоном значений,
которые в них можно хранить.
INC, как правило, позволяет хранить
два представной степени возможного значения.
Это не документировано сандартом,
сандартом документировано,
потому что INC хранит как минимум
два шестнадцатой степени значений.
Но на практике почти везде, почти всегда,
вот если вы будете запускать программу на плюсах,
я уверен, что почти у всех из вас
на компе будет выясняться,
что INC размером 4 байта.
То есть возможных значений в нем 2 в 32 степени.
Вот INC это 4 байта.
И в примерах, которые мы будем разбирать,
я всегда буду считать,
что INC это 4 байта.
Хотя он может быть и другого размера,
но, как правило, он 4 байта,
я буду это считать в дальнейшем, что это там.
Шорт это, опять-таки,
как правило, 2 байта.
Лонг-лонг, как правило,
8 байтов.
Типом лонг мы никогда не будем
пользоваться, потому что он
то ли 4 байта, то ли 8, непонятное.
По-разному бывает, смотря,
где вы работаете, на каком компе,
на какой машине, с каким компилятором.
Нам, для наших примеров,
мы будем использовать обычно либо INC, либо
INC. То есть INC, если нужно
4-байтное число, лонг-лонг, если 8 байтов.
Что значит 4 байта?
Ну, то есть 32 бита, то есть 2 в 32 значений.
Вот.
2 в 32 это значит, что мы можем хранить числа
от минус 2 в 31
до
2 в 31 минус 1,
включительно.
Да?
Ну, 8 байт, соответственно, означает,
что мы можем хранить числа от минус
2 в 63 до 2 в 63 минус 1.
Ой.
Это что я сделал?
Подождите, пожалуйста.
До 2 в 63 минус 1.
Я куда-то не туда нажал.
А, я нажал ваус-шер
вместо того, чтобы на руку нажать.
Вот.
2 в 31 минус 1 это
сколько кто помнит?
Вот это.
Число чему равно?
Два на десять девятнадцатый,
примерно.
Да нет, два в тридцать... Максин,
максимальное значение имта в плюсах какое?
А.
Два миллиарда
сто сорок семь миллионов
четыреста восемьдесят три
тысяча шестьсот сорок семь.
Не то, чтобы я вас
просил помнить это наизусть,
но это полезно помнить,
потому что
полезно помнить хотя бы примерный порядок величины.
Это два миллиарда с чем-то.
Два миллиарда и сто сорок семь миллионов.
Кстати, это простое число
еще добавлено. Всему очень удобно.
Полезный факт.
Или бесполезный, не знаю.
Вот. Почему полезно
помнить, какое максимальное значение может
хранить им? Да чтобы переполнение не происходило.
Когда вы пишете программу, вы держите в уме,
что им примерно два миллиарда
сто миллионов может хранить, а если у вас
число больше, то у вас переполнение будет.
Вот.
С переполнением
Intouch четыребайтного связано много
интересных историй, много
в
программировании, вообще в мире
программирования есть немов,
связанных с переполнением.
Вот. Наверное, такая
самая яркая вещь,
самая яркая явление,
о котором даже есть статья на Википедии,
это так называемая проблема
2038 года.
Знаете,
какая проблема 2038 года?
Да.
Это
ситуация,
19 варианта 2038 года
наступит момент, когда
юниксовое время
переполнится. Дело в том, что
в юникс-системах, в линуксе,
в мак-аси и вообще во всех
большинстве операционных систем,
ну там, я не знаю
как везде, но вообще в компьютерном мире
принято считать время как количество секунд,
прошедшее от 1 января
еще 1970 года.
По иронии судьбы, как раз
Линус Торвальдс родился за три дня до этого,
так что можно считать, что все мы считаем
время как количество секунд от его
рождения. Вот.
Но в 19 января 2038
года их станет больше, чем вот это
число, и
все, кто не перейдут на 64 бит
формат хранения времени, схватят переполнение
и все часы, когда компьютерные
уйдут с ума и вернутся
в 20-й век. Вот это называется проблемой
на 2038 года. Вот.
К этому времени всем надо успеть перестроиться
на 64-битный формат хранения времени.
Другая интересная
вещь, которую я люблю упоминать, связанная
с Максом Том, это
такая, что
вот если вы в ВК
много переписывались
когда-нибудь, вы, возможно, замечали,
как тут выглядит адресная строка, там,
когда вы как-нибудь пишите сообщение, у вас там адрес
nuk.com, slash, im, знак вопроса
sam равно, а дальше
ID-шник пользователя. Ну, это когда
вы чат с пользователем открываете.
И вы могли заметить, что если вы переписываетесь
например, с сообществом,
то там написан не ID-шник сообщества, а
2 блярда плюс ID-шник сообщества.
Вот. Или
или когда вы с группой
переписываетесь, по-моему, вот ID-шник
ну, чата,
то ли ID-шник чата,
то ли ID-шник переписывается
сообществом, вы считаете как 2 блярда
плюс ID-шник соответствующий.
Почему так? Ну, потому что вот им нужно было
как-то отделить ID-шники
юзеров от ID-шники не-юзеров.
И что они придумали? Они не придумали ничего
лучше, чем 2 блярда, давайте. Почему 2 блярда?
Ну, потому что, чтобы Максин продолжал
влезать, ну, как бы чтобы точно противник.
Вот. Это довольно забавно, мне кажется.
Вот. Ну, шор хранит
до 32 767.
Ну, вы уже
слишком молоды, чтобы такое знать,
но вот в мои времена, когда я был
когда мне было 10 лет, у меня была игра
Герои Меча и Магии, там максимальное число
существ в отряде было идет 32 767.
Вот.
С чего бы это, думал я,
но потом я подрос и понял.
Потому что
это Макс число, которое в Губайке
не знает.
Ну, хорошо. Наряду с этими
типами есть еще unsigned их версии,
то есть можно их сделать беззнаковыми.
Можно
попросить так называемого unsigned int,
то есть int, в котором нет
знака. Тогда он будет уметь хранить
числа от 0 до 2
в 32 минус 1.
Соответственно.
Unsigned можно сделать любой из этих,
то есть можно сделать unsigned int, unsigned long, unsigned long
и так далее.
Можно
даже не дописать int,
а просто написать unsigned.
Если вы просто написали unsigned, не уточнили что-то,
вы читаете, что вы просили unsigned int.
Кроме того,
есть
типы с фиксированной
шириной, о которых полезно знать.
Это
int 8, знак подчеркивания
t, int 16,
знак подчеркивания t,
int 32, знак подчеркивания t,
int 64, знак подчеркивания t.
Сейчас объясню.
Это типы с фиксированной шириной.
Что значит с фиксированной шириной?
Гарантируется, что их размер ровно такой.
Ну, например, int 32t
гарантируется, что это ровно 4 байка,
то есть ровно 2 в 32 возможных значений.
Зачем это надо? Потому что проинт
не гарантируется.
Если вам в какой-то ситуации нужно, чтобы
вы были уверены, что
примерно занимает ровно 4 байка,
то вы можете написать int 32t,
чтобы быть уверенны, что там ровно столько.
Вот. Иногда это бывает нужно,
например, когда вы строго соблюдаете
какой-нибудь формат данных, вам нужно там
ну, вы какие-нибудь там данные
куски передаете в каком-нибудь определенном
строму формате или, не знаю, там с какой-нибудь графикой
работаете, у вас там поля должны быть фиксированной ширины.
Ну, тогда используйте переменные
фиксированной ширины.
У них также есть беззнаковые версии.
uint 8t,
uint 16t, uint 32t,
uint 64t,
u от слова unsigned.
То есть uint 32t
это тип, который хранит
гарантированно от 0 до 2 в 32-1.
Еще есть такой тип,
называется size t.
Нам с ним довольно часто
придется сталкиваться.
Это тип, который, как правило,
эквивалентен
типу unsigned long и long,
может быть unsigned long,
может быть unsigned int, не знаю.
Но смысл в чем?
Это такой тип, который
используется для хранения
числа,
применяемого для индексации.
Вот, когда у вас есть какой-то массив,
здесь же все знают,
что такой массив, да?
Это хорошо.
Ну, вообще, так неправильно
спрашивать? Вообще, да,
когда лекто спрашивают, здесь все знают,
что это такое, он как-нибудь подразумевает ответ
да и не хочет тратить время на адмиссию.
Да, это лайфхак.
Если вы хотите проверить,
действительно знают люди,
то вопрос будет по-другому.
Короче, да, я думаю,
что все знают, что такой массив
из школьной программы.
Когда вы обращаетесь по индексу в массив,
то ожидается, что индекс
будет...
индекс, как правило,
ожидается именно size t.
Например, когда вы в vector,
в std vector обращаетесь по индексу
там индекс именно типа size t ожидается.
Size t это тип
достаточный для хранения индекса,
который позволяет проиндексировать
любую ячейку оперативной памяти.
Он может не совпадать с unsigned int
или unsigned longlong,
в зависимости от того, как много у вас адресное пространство,
сколько большое.
Но вот чтобы индексировать, чтобы гарантировать,
что вам достаточно ячеек проиндексировать всю память,
предменяется такой тип.
Может быть больше longlong?
Думаю, что нет,
потому что
больше чем 64-битная память
как-то я не уверен,
что бывает.
Ну, как-то даже на четвертой памяти
мне кажется, столько и нет.
Это где сколько памяти-то бывает?
Я не знаю, ну, короче, вряд ли.
Я не встречал.
Size t это как правило unsigned longlong,
возможно это unsigned int,
вот, зависит от того,
сколько памяти у вас, вот говоря.
То есть это беззнаковый тип,
размер которого зависит от того,
как много памяти вы можете проиндексировать.
Но я их буду использовать
с unsigned int в перемешку
с unsigned longlong,
то есть разница
не особо чувствуется.
Можете считать, что это unsigned longlong
или что это unsigned int,
для наших целей это будет без разницы.
Вот.
Еще есть такой замечательный тип char.
Это тип,
который позволяет хранить символы.
Но на самом деле
это тоже целочисленный тип.
По сути char это тип,
в котором вы храните 1-байковое число.
Char от слова character, символ.
Ну, буква одна
может в нем храниться.
Вот.
Особенность этого типа в том,
что если вы переменную типа char выводите на консоль,
то вам выводится именно
символ с этим кодом,
а не само это число.
Но вы же понимаете, что у всех символов
есть коды,
и когда вы имеете дело
с каким-то символом,
программа его воспринимает как 1-байковое число.
Просто если вы его выводите на консоль,
вам выводится не это число,
а символ соответствующего кода.
Вот.
Но на самом деле это тоже целочисленный тип,
и тип char, как и им,
поддерживает все арифметические операции.
То есть можно складывать char и друг с другом умножать,
char и друг на другу делить и так далее.
То есть это целочисленный тип,
полноценный, просто 1-байковый.
Как правило, 1-байковый.
Ну, можно с достаточно
уверенностью утверждать, что он 1-байковый.
К char, также как и другим
целочисленным типом, применима приставка unsigned.
Вы можете попросить unsigned char.
Дело в том, что заранее неизвестно char,
если вы написали, это будет signed или unsigned.
Это недокументировано.
Вам может быть нужен unsigned
char.
Вы, может быть, хотите, чтобы гарантированный тип
хранил в 0,255
это значение.
Тогда вы можете попросить unsigned char, чтобы быть уверенным,
что у вас беззнаковый char.
Вы можете явно
написать signed
char,
и тем самым явно попросить, чтобы он был
беззнаковый.
Тогда он будет хранить от минус 128 до 127.
Еще раз повторяю, char
это, по сути, тоже целое число,
1-байковое. Просто, особенность его в том,
что, когда вы его на консоль выводите,
оно превращается в символ, соответственно.
Вот и все. А так, вся рифутическая операция
к нему применима.
Ну, еще есть тип bool.
Я здесь же про него расскажу.
Это тип, который
позволяет вам хранить
логические значения.
True или false?
Вот.
Этот тип
занимает памяти, сколько?
1-байк.
1-байк.
Кто-то может подумать, что 1-бит,
но нет, 1-байк.
Почему 1-байк, а не бит?
Казалось бы, чтобы хранить bool,
требуется всего лишь ноль или единичка и одно значение.
Дело в том, что в языке C++
у всех переменных должны быть
разные ячейки памяти, а ячейки памяти
индексируются байками, а не битами.
Нельзя положить две переменных
в одну и ту же ячейку.
Поэтому если вы заводите переменные типа bool,
то одна ячейка памяти у вас все равно истращена.
1-байк он занимает, а не 1-байк.
Правда, если вы заводите вектор из boolei,
то, значит, такой вектор,
в этом случае boolei будут упакованы
по 8-байк.
Про вектор мы попозже поговорим.
Значит, bool позволяет
нам хранить логическое значение.
Соответственно, к boolei применима операция
логическая и, логическая или,
логическая не,
отрицание bool.
Также bool не явно конвертируется в int
и обратно. То есть из bool
можно не явно получить целое число,
и наоборот.
А как bool превращается в int?
Если у вас true, то это считается единицей,
если это false, то это считается ложью.
Вот, то это считается нулем.
То есть, например,
если у вас есть bool,
ну вот пример,
допустим, у вас есть bool,
b равно true,
да,
и вы написали,
ну там,
вы все аут вылили
5 плюс b,
ну посмотрите,
все аут,
то выведется 6,
потому что b
не явно превратится в 1.
Это будет неявная конверсия bool.
Обратно, если у вас есть int,
а требуется bool, то произойдет
неявная конверсия, по правилу,
все, что не ноль считается истиной,
а ноль считается ложью.
То есть если вы пишете if
и под if пишете int,
например, не знаю,
минус 3,
что-то сделать, да,
то минус 3 считается истиной,
потому что это не ноль.
И не явно превратится в bool, по такому правилу.
Так, это были целочисленные типы.
Ну, видимо,
последнее, о чем я успею сегодня рассказать,
это типы с плавающей точкой.
Вторая часть,
вторая, значит,
второй пункт,
здесь это floating point times.
Типы, позволяющие
хранить дробные числа.
Их в основном три,
это float, double
и long double.
Это типы, позволяющие
хранить дробные значения.
Ну, здесь, наверное, стоит сказать о том,
а как вообще можно представлять
в памяти дробные значения.
Вот, когда у вас хранится
дробное число, оно же должно
в двоичном коде как хранить,
как это вообще работает?
Ну,
дробные числа,
как правило, вообще,
почему они называются floating point?
Плавающая точка. Float — это плавать.
Почему он так называется?
Потому что они хранятся
в формате
мантиса плюс экспонента.
У вас есть как бы мантиса,
обозначающая значащие цифры.
Экспонента обозначает на два,
в какой степени надо домновить значащие цифры,
чтобы получить нужное число.
А еще есть бит, отвечающий за знак.
Ну, подобно тому, как в физике у вас,
я не знаю, может быть,
1 из 63 умножить на 10 минус 3.
Да, ну, аналогия с физикой.
Вот это называется мантиса,
а вот это называется экспонента.
То же самое в программировании.
Мантисовое значение числа представляется
вот в такой форме.
Только вместо 10 минус 3 у вас 2.
Ну, основание стимучления — 2.
То есть, когда у вас кодируется
дробное число, оно примерно
так устроено.
У вас один бит отвечает за его знак.
Дальше какое-то количество бит
отвечает за мантису.
То есть, ну, просто это биты,
кодирующие значащие цифры,
чтобы это не значило.
Ну, просто сколько-то, не знаю.
315.
А дальше у вас есть экспонента,
который обозначает степень двойки,
на которую нужно домножить
вот это вот число, закодированное
вот этими битами, чтобы получить нужное.
Например, я могу здесь закодировать
315 битами двоичными,
а здесь закодировать
минус 5.
Тогда это будет число, обозначающее
12 на 2 в минус 5, ну, условно.
Понятно, что там не совсем так,
но идейно так-то хранится.
А еще вот этот бит отвечает за знак.
Вот примерно так хранятся
дробные числа. Понятно?
Соответственно...
Чего-чего?
Ну, умножаем или делим?
Здесь может быть как половительная степень,
тогда отрицательная.
Вот.
Соответственно,
float,
сокращение от слова floating,
это тип, который
как правило, хранит
4-байтное дробное число,
то есть в нем
количество бит, отведенных по мантису и на экспоненту,
ну, 4 байта, это значит 32 бита,
и я боюсь соврать,
я не помню,
но по-моему, что-то типа там,
ну,
не знаю, условно,
19 бит отведено под мантису
и 11 под экспоненту.
Какое? Я не помню.
Я, честно, не помню, это не очень важно,
но вот примерно, то есть у вас 32 бита
всего, да, в 4 байках,
значит, и в них сколько-то отведено под мантису
и сколько-то под экспонент.
Окей? Вот.
Double это дробное число, которое, как правило,
занимает вот один байт,
и в примерах мы будем, как правило,
в дробных числах они используют в формате double.
Вот.
Почему называется double?
Потому что двойной относительно float.
Двойная точность по сравнению с float.
Long double это
еще более широкий тип,
как правило, он занимает 16 байков,
хотя, может, где-то и вольсы, то есть позволяет
еще больше точностью дробные числа представлять.
Понятно, что
эти типы не позволяют вам абсолютно точно
представлять дробные числа. Если у вас число
в боечной системе непредставимо,
то у вас будет некоторое приближение к нему.
Понятно также, что,
значит,
если у вас
число по модулю большое,
то вариативность минимум становится.
Вот обратите внимание,
какое следствие из-за того, что числа
так хранятся. Если у вас
число по модулю маленькое, близкое к нулю,
не знаю, одна миллионная,
вы можете его закодировать
в таком представлении. Вам надо просто написать
один и экспонент минус шесть,
условно.
Но если у вас число
очень большое по модулю,
например, миллион целых, одна миллионная,
такое число вы уже не представите
в виде
флот и в виде даббл тоже не представите,
потому что вам бита на мантису не хватит
просто. Чем больше
по модулю ваше число,
тем шире
шапка.
В диапазоне от нуля до единицы
вы очень много чисел можете закодировать, а в диапазоне
от миллиона до миллиона одного
вы очень мало или почти ничего
не можете закодировать, потому что
на мантису уже потрачено тем, чтобы написать число
миллион. Понятно? Вот это
побочный эффект. Но полезное
свойство даббла заключается в том, что
все, что представимо интом, представимо дабблом
без потери точности. Это полезный
факт, который
часто пригодается. Если у вас что-то
влезает в инт, то оно и в даббл тоже
влезает. Без потери точности.
Целые числа кодируются без потери точности
дабблом, в рамках которого
влезает.
Вот.
Вот это то, что касается
чисел с плавающей точкой.
Ну, понятно также, что числа
давайте в последнее скажу, что числа
могут неявно конвертироваться
из
целых в дробные и обратные.
То есть, например, если вы написали
там
понятно, что
если вы написали какой-нибудь
int х равно там
и написали
даббл
д равно х,
то
без проблем произойдет конверсия.
Но вы должны понимать, что в этот момент происходит именно
конверсия, потому что int
это одно представление числа, это просто
целочисленные литы, а перевести его в даббл
это нужно вот этому антисуэкспоненту вычислить.
Происходит неявная конверсия в этот момент,
но она происходит без потери точности.
Но бывает конверсии
в обратную сторону, если
я написал там даббл д равно 3.14
а потом сказал х равно д,
то
произойдет конверсия в обратную сторону
с потерей дробной части.
То есть int присвоится даббл,
но поскольку переменной
своих менять не могут,
х станет равным просто 3.
Просто от даббла трешется дробная часть.
Это не округление, это именно отрезание
дробной части. Если у вас было бы 39,
то будет
снова 3 все равно.
А если отрицательная, то
Ой!
Не знаю, не помню.
На самом деле лучше
так не делать просто.
Неявные конверсии они
в настоящем коде не рекомендуются
и более того
хорошие компиляторы выдадут вам
предупреждение, если вы делаете неявную
конверсию из даббла выдают, потому что
это специальная ошибка в коде.
Я не помню правил неявной конверсии
по причине того, что
их вообще лучше избегать.
Когда Страустро
поспросили несколько лет назад,
что бы он сделал по-другому,
если бы сейчас разрабатывали язык с
пятипустью заново, он сказал что
он бы запретил неявные конверсии,
потому что они порождают очень много
ошибок, которые очень трудно отлавливать
из-за того, что вы одно число
сконвертируете в другое незаметно,
у вас что-нибудь сломалось.
Ну, наверное, это все, что я сегодня
успел рассказать.
