короче сегодня продолжаем немножко про числа говорить цель в конце лекции
разобрать алгоритм факторизации довольно быстрый который ну факторизация это
разложение на множители значит ну наверное многие из вас сумеют раскладывать за корень из n
просто перебираю все числа от одного до корня и типа деля на них пока делится ну не обязательно ну
типа если число это квадрат простого то вы быстрее чем за корень не сделаете я думаю ну и
если только не извлечу теперь ну неважно не там типа корень не именно что это сам он
он хорош точная оценка короче вот ну сначала еще какие-то просто задачки вокруг по рассматриваем
в частности попроверяем число на простоту просто перед тем как раскладывать число на множителя мы
сначала научимся проверять что оно простое вот и перед этим еще такая задача это извлечение корня
значит ну начнам данные два числа а и п причем п простое надо решить вот такое уравнение вот то
есть решить по факту извлечь квадратный корень из а да но смотрите если п как бы какие у нас
будут просты у нас все просты либо четная двойка либо нечетная с п равно два как нибудь разберемся
наверное за ифаем что если по равно два то как нибудь там корни по извлекаем вот теперь давайте
отсюда до конца лекции считать что п нечетно просто вот а и тут есть два случая один простой
сложный значит случай первый это когда п это тройка по моделю 4 значит тогда утверждаю что
x равная плюс-минус а в степени п плюс один на четыре ну помодлю п конечно это единственный два корня
уравнение у этого уравнения вот но понятно там если мы живем в zp то наверное у уравнений
второй степени не больше чем два корня вот это дежда что оба они вот тут написано значит почему
но давайте возведем это в квадрат если мы вот это вот воздумать в квадрат то у нас получится
а в степени п плюс один пополам правильно плюс-минус уйдет здесь будет а все п плюс один пополам так хорошо
ну и видимо надо еще сказать что есть такой простой факт давайте утверждение без доказательства что
если а это элемент zp звездочки то есть любой нелевой вычет то тогда а является квадратичным
вычетом то есть является квадратом какого-то числа давайте а напишем равно b в квадрате для
некоторого b если только если помните условия да да это правда
значит это условия на квадратичный вычет и аналогичные условия на квадрате не вычет
так не вычет но это наоборот квадратичный не вычет это число из которого не извлекается корень
то есть число не равно никакому квадрату это верно в случае если а в степени по минус
пополам это минус 1 так для кого новая информация да хорошо ну простой факт он на самом деле на
теориям и фирма в ком-то смысле основывается потому что а в степени по минус один всегда
единица по моделю п вот а если это квадратичный вычет то есть оно уже квадрат то получается что
если вы это вот это вот б в квадрате воздействует еще в эту степень до края будет б в степени по
минус 1 значит единица вот но если не вычет то можно доказать что будет минус 1 так пардон здесь
здесь двой конечно вот ну хорошо а значит тогда на самом деле первый первым шагом конечно здесь
хотелось бы провести что а это квадратичный вычет потому что мы хотим из него извлечь корень
но понятно если это не вычет то решений нет на то есть первое что мы делаем это проверяют что
А это квадратичный вычет. Проверяем, что А квадратичный вычет. То есть мы запускаем
просто такую проверку, возводим А в степень по месорин пополам. Благо мы потенцировать умеем
быстро, мы умеем быстро возведет степень по модулю П. Но если такая степень 1, то значит это
квадратичный вычет, иначе не вычет. Вот, значит если А это квадратичный не вычет, то решений нет,
и делать нечего. Вот, а иначе я утверждаю, что, значит, давайте вернемся сюда, что если возьму
такой х, возводую в квадрат, получится а в степени p плюс один пополам, это можно так расписать, это
а в степени p минус один пополам плюс один, но мы знаем, что вот эта единичка, потому что а это
квадратичный вычет, но, значит, это просто а по моделю p. Согласны? Ну вот. Так, мне не хватает света, мне кажется.
Это простой случай, если p отстройка по моделю 4, то вот мы оба корня умеем опять-таки получать,
возводя в степень. Ну здесь мы пользуемся тем, что это целое число, p плюс 1 на 4 целое число,
значит, мы можем так сделать. Ну и вот оба корня мы извлекли. Значит, теперь второй случай,
когда p единичка по моделю 4. Так, хорошо, ну давайте мы запишем p в таком виде. Значит,
p можно представить как 1 плюс m на 2 в степени s, где m нечетно. Ну понятно, раз p нечетная,
то после вычитания единички и после многократного деления на двойку можно
добиться того, что мы, в общем, высекли все двойки, которые там были, осталось какое-то нечетное m.
Хорошо. Давайте я тогда скажу следующее. Давайте рассмотрим у нулевое равное а в степени m,
в нулевое равное а в степени m плюс 1 пополам. Ну, поскольку им нечетно,
то это будет тоже целое число, можно возводить в такую степень. Тогда будет ясно, что в 0 в квадрате
это а на у 0. Ну, естественно, по модулю p, потому что в 0 в квадрате это просто а в степени m плюс
1, здесь будет 1 а, здесь будет а в степени m еще. Это тривиальное равенство. Вот, но если бы нам
так повезло, смотрите, представьте, что нам так повезло, и у 0 эта единичка по модулю p. Ну вот
представьте, так случилось, что у 0 равная вот этой штуке эта единичка по модулю p. То есть ее можно
тогда закрыть, и мы извлекли корни за то, что нам нужно. Мы знаем, что плюс-минус в 0 это корни.
Согласны? Вот. И это на самом деле ровно то, что происходит в первом случае. Вот если p это
единичка, perdон, тройка по модулю 4, то, ну по факту мы вот делаем ровно вот это вот, потому что там
m будет как раз p плюс 1 на 4, точнее, p плюс 1 пополам, и потом мы еще делим его пополам, короче, будет
вот ровно оно. Ну, значит, вот на этом шаге, в случае 1, нам бы уже на самом деле повезло. В этом
случае нам не обязательно повезет, у может быть совсем не единицей, но мы хотим добиться того,
чтобы она стала единичкой. Так вот давайте мы будем строить последовательность таких пар у, в, что они
будут последовательно удовлетворять вот такому вот соотношению, что v² равно a на ui по модулю p.
Вот. Ну и будем дождаться момента, когда уишка станет равна единице по модулю p. Окей. Значит, как
мы это будем делать? Давайте мы посмотрим на порядок элемента u0. Значит, напомню, что порядком
элемента называется его минимальная положительная степень, в которой он равен единице. Ну, если есть
какое-то число x, мы записываем все его степени подряд по модулю p и дожидаемся, когда впервые
он становится единицей по модулю p, тогда это будет порядком. Какая-то порядок элемента x по модулю p.
Ну, это же, наверное, многим знакомо. Что такое порядок? Хорошо. Ну вот давайте посмотрим на порядок
элемента u0. Чему он может быть равен? Смотрите, мы знаем, что u0 это а в степени m, и мы знаем,
что p вот в таком виде представима. Поэтому в частности можно заметить, что u0 в степени 2 в
степени s это единица. Ну потому что u0 это а в степени m, давайте распишем, это а в степени m в степени
2 в степени s, то есть это а в степени m на 2 в степени s. То есть а в степене p минус 1. Ну, значит,
тогда порядок u0 обязательно делит 2 в степени s. Мы знаем, что если в какой-то степени мы получили
единицу, то порядок обязательно делит эту самую степень.
Ну, значит, мы точно можем сказать, что порядок – это
какой-то делитель 2 в степени s, причем… Так, мне это сейчас
одну секунду… Важно ли мне это будет? Будьте здоровы.
А, ну да, более того, можно сказать, что порядок этой
штуки даже делит 2 в степени s-1, потому что если
бы я здесь написал s-1, здесь – s-1, здесь – s-1, тогда
получится p-1 пополам. И даже это тоже единица по моделю
p. Да, можно немножко уточнить оценку, сказать, что у нас
здесь порядок не 2 в степени s, а 2 в степени s-1, потому
что a – квадратичный вытяж, значит, его достаточно
в такую степень возвести, чтобы получить единицу.
Ну, в любом случае, так или иначе, мы понимаем, что
порядок у нуля делит какую-то степень двойки, значит,
сам этот порядок является степенью двойки. Давайте
напишем 2 в степени r0, да, где r0 какое-то число меньше
чем s. Хорошо. Теперь давайте вот будем делать эти переходы.
Вот пары u0, v0. Мы будем строить все новые и новые пары ui,
и будем стараться уменьшать порядок u, потому что мы сказали,
что если в какой-то момент u – это единица, то есть у нее
порядок 1, то мы победили. Мы нашли корни из a, это будет
просто v, плюс-минус v. Так вот давайте сейчас сделаем
такие итерации, будем строить новые пары u, v, чтобы уменьшать
порядок u, но при этом сохранять вот это вот равенство, что
у этого выитая квадрата, это а на уитая. Окей, давайте
этого будем добиваться. Для начала мне нужно будет
найти произвольный квадратичный невычат. Давайте скажем,
что пусть b – это произвольный квадратичный невычат в
zp. Мы знаем по этому утверждению более-менее, что кроме нуля
квадратичных вычетов и квадратичные вычеты их
поровну. Их ровно по p-1 пополам штук. У меня есть 0, у меня
есть p-1 пополам квадратичный вычет и p-1 пополам невычат.
Поэтому их там примерно поровну, и грубо говоря,
если мы возьмем случайное число, то с вероятностью
около 1 в 2 мы попадем как раз таки в невычат. Ну и
чтобы его найти алгоритмически, давайте просто сгенерируем
много чисел, точнее генерировать число b много раз, пока не
станет выполняться вот это вот, пока его вот такая-то
степень не будет минус 1. Поскольку их около половины,
то мы довольно быстро его сгенерим. Среднее число
шагов, которые надо сделать, это будет 2, потому что около
половины невычаты, значит мы с вероятностью 1 в 2 каждый
раз попадаем куда надо, а от ожиданий будет очень
хороший, очень маленький. Вот, значит раз это невычат,
то мы знаем, что b в степени p-1 пополам это минус 1. Что
такое p-1 пополам? Это m на 2 в s минус 1. Значит b в степени
m на 2 в степени s минус 1 это минус 1 по модулю p. С
одной стороны, с другой стороны, b в степени m на 2 в степени
s это уже единица по модулю p. Помалтерим фирма, потому
что это p-1 в точность. Хорошо. Давайте обозначим, я скажу,
что c это b в степени m. Так, давайте сюда перенесу.
Значит, я говорю, что c это b в степени m. Тогда для
него выполняются те же самые соотношения. Тогда c в степени
2 в степени s минус 1 это еще минус 1, а c в степени 2 в степени
s это уже единица по модулю p. Хорошо. Ну, теперь начинается
следующая магия. Давайте я скажу, что… Сейчас подумаем.
Значит, смотрите, пусть у меня была пара ui-vi, такая,
что она удовлетворяла всем вот этим соотношениям.
Значит, во-первых, vt квадрат это a на ui-t. Во-вторых, порядок
элемента ui это 2 в степени какой-то ri. 2 в степени ri.
Ну, что тогда можно написать? Можно написать, что ui-t в
степени 2 в степени r минус 1 это минус единица. Да,
но потому что вот такая-то степень u это 1, значит, если
у в этой степени единица, то у в степени это пополам
как раз минус единица, потому что из единицы есть только
два корня плюс минус 1. Ну, соответственно, если порядок
не вот это, значит, эта штука как раз минус 1. Теперь давайте
умножим вот это вот на это вот. Что тогда получится?
Получится ui-t в степени 2 в степени ri минус 1 умножить
на c в степени 2 в степени s минус 1 равно единицы по
модлю p. А теперь я хочу сгруппировать и вынести
в скобках, ну, видимо, просто u на c. Нет, плохо, так будет
плохо. Сейчас, секунду. Наоборот, наоборот, наоборот,
виноват. Значит, ui-t на c в степени 2 в степени s минус
r и t. Вот так. Вот. И это все будет оставаться в степени
2 в степени r и t минус 1. Это будет единица по модлю
p. Вот. Короче, я вот здесь вот сгруппировал. Короче,
я вот эту вот степень 2 в степени r минус 1 выношу
в качестве степени за скобку. В скобках остается u и c
в степени разной степени 2 в s минус 1 минус 2 в степени,
ну, точнее, поделить на 2 в степени r минус 1. Остается
такая степень. Нет, s, s, нет, нет, нет. s это часть
определения p. Да, оно фиксировано. Так, ну, это просто отсюда
получилось вынесение в скобку. Ну и все, теперь давайте
я скажу, что u и плюс первая, это вот то, что у меня стоит
внутри скобки. А v и плюс первая? Сейчас, сейчас,
сейчас, все будет, не переживайте. Значит, это k на c в степени
2 s минус r минус 1, правильно? И, и, и. Вот, смотрите еще
раз, значит, я, я все это сделал, чтобы теперь перейти
к такой паре u и плюс 1 v и плюс 1. То есть у меня была
старая пара u и v и, для которой что-то там выполнялось.
Вот, давайте я для нее проверю, что выполняются те наши
два условия, которые я хочу. Значит, во-первых, v и t в
квадрате должно быть a на u и плюс первая, но давайте
посчитаем, что такое v и плюс первая в квадрате.
Это v и t в квадрате умножить на c в степени удвоенной
вот этого, то есть просто c в степени 2 в степени s
минус r и. Но v и t в квадрате, мы знаем, что это a на u и t
в квадрате. Так. Да, действительно, спасибо, спасибо. Да, ну,
а это как раз u и плюс первая, правильно? Да. По определению
просто, вот оно u и плюс первая. Вот. Значит, первое соотношение
выполнено. Второе. Ну, смотрите еще раз, у меня на пары
мои есть два соотношения всего, то есть я поддерживаю
такие пары u и v, что, во-первых, квадрат v это a на u, во-вторых,
порядок ушки это степень двойки, 2 в степене r.
Но они будут у меня убывать, на самом деле. Так вот,
смотрите еще раз, давайте просто формально, у меня
была такая пара с таким свойством, я перехожу к
такой паре, проверю для нее аналогичные свойства.
Во-первых, я хочу, чтобы квадрат v был a на u, давайте
считаем квадрат вот этой v, вот этой v. Получается v
и квадрат на c в удвоенной вот этой вот степени, v и
t в квадрате, мы знаем, что по предположению это a на
u и оставляем эту c, и получается у нас как раз множество
u и плюс 1, поэтому мы получили аналогичное соотношение,
что u и плюс 1 в квадрате это a на u и плюс 1. Не торопитесь,
вот это понятно? Хорошо, теперь давайте посмотрим на
порядок ушки, когда мы вот так вот сделали. Ну смотрите,
если раньше u был порядок 2 в степени r и, то теперь
я утверждаю, что у нее порядок меньше либо равен, чем 2
в степени r и минус 1, ну потому что вот мы взяли u и плюс
1, вот оно под скобками стоит, и мы знаем, что его вот такая
степень уже единица, значит порядок обязательно еще
ну как бы не больше, значит порядок u и плюс 1 делит вот
эту вот штуку, потому что его такая степень это единица,
значит порядок может быть еще только меньше. Все,
мы сделали переход, значит у нас по-прежнему выполняется
вот это соотношение, что v квадрат это ау, и мы уменьшили
показатель степени в порядке u. Да, да, да, ну s точнее. Вот
отсюда. Вот это u и плюс 1, вот то, что под скобками,
это u и плюс 1, мы знаем, что его вот такая степень это
единица, значит порядок может только делить эту
степень. Вот, ну все, значит мы сделали переход, и давайте
делать эти переходы, пока u не станет равна единице.
Наша мечта, давайте вспомним в самом начале, наша мечта
это, что u единица, тогда мы знаем, что v это корень
низа, плюс-минус v это корень низа. Вот, но тогда если
мы так будем делать и каждый раз будем уменьшать показатель
у u, то мы рано или поздно дойдем до единички и победим.
Да. Смотрите, если мы знаем, что x в какой-то степени,
значит x хоть в какой-то степени, давайте скажем n это единица,
то тогда порядок обязательно делит, делит n. Нет, обязательно
делит. Еще раз? Ну вообще нет, типа я считаю это предреквизитом,
как это доказать? Ну нет, не у всех теорий групп, видимо.
Да, да, хорошо. Ну окей, давайте попробуем, давайте
вот этот попробуем наказать быстренько. Мне предлагают
поделить, если n не делится на порядок, давайте поделим
с остатком. Хорошо, значит тогда будет n это порядок
x на какой-то q, плюс какой-то r. Значит, и мы знаем, что x
в этой степени 1, и x в этой степени 1. Ну тогда x в этой
степени 1? Значит, обязательно x в этой степени 1. Противоречие
с тем, что это порядок, да. Вот. Поэтому действительно
если в какой-то степени единица, то порядок обязательно
делит эту степень. То есть у нас на самом деле структура
вот этих вот n-ок, структура степеней, в которых x единица,
она очень простая, это все делители, порядка и все,
и больше ничего нет. Ну вот. Вот вроде все, значит
мы тогда научились делать переход, мы делаем эти переходы,
пока ушко не станет равной единице по моделю p, и в тот
момент, когда она единица, мы нашли корни за. Ау. Ну
вот если представьте, что у вас это 1. Представьте,
что это 1. Тогда у вас написано, что v квадрат это a, а вы знаете
v. Значит v это корень. Я думаю, вы это так понимали. Ну
у вас есть вопрос? Ну все тогда. Нет, все мы решили
задачу. Да. Хороший вопрос. Как мы его находим? Ну можно
просто возводить во всей степени u в квадрате, u в
четвертой, u в восьмой и так далее, дождаться первого
момента, когда будет единица. Тогда мы найдем r, r плюс
первое. Да. Это правильный вопрос, но это легко сделать
просто как бинарную степень возводим, дожидаемся когда
впервые 1, а это будет как раз r плюс первое. Ну что
со симптотикой? Мне кажется, что лог p в квадрате, потому
что вот тут внутри у меня всякие возведения в степень,
которые за логарифом работают, за лог p. И плюс у меня примерно
лог итераций, потому что на каждом шаге у меня убывает
r. Вот да, если раньше было r и t, то теперь не больше,
чем r минус 1. Значит на каждом шаге убывает r, их тоже максимум
логариф, ну, наверное, примерно около лог квадрата
работают. Вот. Ну да, ну типа если не вычет нашелся,
то дальше лог квадрат. Вот. Понятно? Ну ладно. Хорошо.
Ну это, видимо, если как-то хитро вот здесь вот степень
возводить и не возводить два раза то, что уже было,
то, наверное, можно побыстрее. Ну, короче, в любом случае
неплохо. Так. Хорошо, давайте пойдем дальше. Дальше давайте
посмотрим задачу проверки на простоту. Что-то дано
число n. Проверить его на простоту. Вот. Ну n какое-нибудь
большое, типа там 10, 18 или может быть даже еще побольше.
Надо проверить его на простоту. Хорошо. Значит давайте, значит
тут в основе опять лежит терем, терем фирма. Мы знаем,
что если n простое, то тогда для любого a от 1 до n-1, нас
в степени n-1 это единица по моделю n. Вот это для простых
n. Для составных это, типа, соответственно, тогда будет
неверно. Вот. Ну вот да. Нет, там как раз для них это
тоже будет неверно, но неважно. Значит, хотелось бы вот на
основании такого факта основать какой-то алгоритм
проверки на простоту. Можно было бы просто генерировать,
скажем, случайные а из этого отрезка, возводить их в
такую степень, проверить, что они единицы. Вот. Ну и,
соответственно, то, что мы получим, это называется
простой тест фирма. Тест фирма на простоту. Он работает
так. Мы генерируем много случайных а. Ну там, не знаю,
давайте k каких-нибудь шагов возьмем. k маленько от одного
до k большого. Генерируем случайное а из вот этого диапазона.
Говорим, что если а в степени n-1 не равно единице по моделю
n, тогда n, очевидно, непростое, ну потому что как бы для
него вот это не выполняется, значит, не выполняется вот
это. Значит, сразу говорим, что n непростое. Стритерн,
там не знаю, n составное. Вот. Ну если мы в течение
большого числа итерации такого числа не нашли,
то объявляем его простым. Стритерн. Ну давайте я так
напишу, скорее всего, n простое. Вот. Ну тогда понятно,
что если алгоритм в какое-то время вернул, что число
составное, то он точно составное, потому что для него не выполняется
термин фирма. Значит, он точно не простое, точно составное.
Вот. Ну а иначе, как бы, ну вот, типа оно надеется,
что n простое. Вот. На самом деле, к сожалению, он работает
не всегда. Ну вот, есть там числа, какие-то числа,
для которых, ну, которые почти вот этому закон удовлетворяют,
что там почти для всех чисел его n-1-ой степени это единица
по моделю n. Типа, такие числа есть, значит, это, в общем,
недосадженодежный тест. Можно, например, убедиться,
что если дать в качестве n 561, это наименьшее простое,
которое проходит такой тест. Извините, наименьшее
составное, которое с хорошей вероятностью этот тест не
проходит, то есть на нем ошибается. Вот. Тогда если
возьмете любое а, взаимно простое с n, то его n-1-ой степени
будет единица. Ну вот, короче, типа, бывают числа, которые,
бывают составные числа, которые этот тест проходит,
и они будут считаться как бы простыми, хотя на самом
деле это не такие составные. Вот, но это, например, на
три делится, поэтому точно не простое. Вот. Поэтому
это не очень такой, не очень адекватный алгоритм. Ну,
к сожалению, их до 10-18 около миллиона, поэтому не получится.
Ну, кстати, да. Но то, как вы их построите, не очень
понятно. Предпосчитаю. Ну, хорошо, удачи вам. Вот.
Давайте поделаем что-то более интеллектуальное.
Смотрите. Давайте сделаем что-то более интеллектуальное,
похожее на то, что было в прошлой задаче. А именно,
ну давайте опять загенерим какое-нибудь случайное а.
Понятно, что если для него а в n-1-ой не единица, то а
уже точно составное. Пусть единица. Ну, а, значит,
пусть для какого-то а, а в степени n-1, это единица
по модулю n. Хорошо. Давайте опять скажем, что n это 1
плюс m на 2 в степени s для каких-то m и s, где опять-таки
m нечётно. Вот. Ну, если n само по себе чётное, то,
ну, наверное, проверить чётное число на простоту не очень
сложно. Вот здесь я могу в начало ещё добавить в
проверку, что если n-чётное, то там, если двойка выводи
простой, иначе составное. Что если n, давайте так,
n-чётное отдельно. Дальше считаю, что он нечётный.
Значит, вот такое. Мы знаем, что а в степени n-1-ой единицы
по модулю n. Давайте тогда повозводим опять а во все
степени кратной m. То есть давайте посмотрим на а в
степени m, а в степени 2m, а в степени 4m, ну и так далее
вплоть до, собственно, вот этого вот. А в степени
m на 2 в степени. Это есть а минус 1. Давайте весь отряд
посмотрим. Мы знаем, что последнее число здесь – это
единица. Давайте пойдём тогда по этому ряду справа
налево найдём первую не единицу. Это какие-то вычёты
по модулю n. Давайте посмотрим на последний из них, который
не равен единице по модулю n. Нет, мы просто линейным
проходом. Тут s маленькая, поэтому можно не делать
бинпоиск. Давайте найдём самое последнее, которое
не сравнимо с единицей по модулю n. Тогда, если это
не минус единица, то n точно составная. Давайте напишем.
Пусть а в степени m на 2 в степени какой-нибудь t. Нет,
t не хочу. r. Это не единица по модулю n. А в следующей
степени, то есть а в степени m на 2 в r плюс 1, уже единица
по модулю n. Так вот, если вот эта вот штука даже не
минус единица, то n составная. Если я нашёл самую правую
степень, которая не равна единице, и при этом она ещё
и не минус единица, то n составная. Почему?
Потому что для простых это должно быть не единица.
Иными словами, мы нашли такое число, квадрат которого
единица, но при этом само число не плюс 1 и не минус
1. Такого в простых полях не бывает. Мы нашли решение
вот такого уравнения, где x не плюс-минус 1. Я тогда
думал, что это обязательно n составное. Идея самая
простая, что если бы n было простым, то в ZP у нас многочлен
второй степени имеет максимум 2 корня. А это как раз плюс-минус
1. А мы сказали, что есть ещё какой-то третий противоречие.
Либо, если вы не верите в эту теорему, можно было
бы сказать, что смотрите, что значит, что x квадрат
единица по моделю n. Значит, что x минус 1 на x плюс 1 делится
на n. Вот отсюда оно следует. Причём, более того, давайте
вот это вот сотрём всё. Да, ну если как раз x не плюс-минус
1, тогда это означает. Потому что, смотрите, вот эти вот
числа x плюс 1 и x минус 1, это какие-то элементы от
1 до n минус 1. Вот эти два числа – это числа от 1 до n минус
1. Да, потому что… Так, ну… Ну, x 0, тогда здесь будет
n минус 1 и 1. Ну, имеется в виду, что если я их сначала
возьму по моделю n, как элементы от 0 до n минус 1, тогда это
будут… Короче, ни один из них не 0. Вот, ни один
из них не 0 по моделю n. Значит, как остатки по моделю n – это
числа от 1 до n минус 1. Но тогда n не может быть простым,
потому что простое число не может быть представлено
в виде разделения двух меньших чисел. А здесь ровно это
написано. Так, ладно. Ну, мы что-то поняли. Значит,
мы поняли, что если в какой-то момент вот так вот при проходе
справа-налево мы нашли последнюю не единицу, если она еще
не минус 1, то n точно составная. Вот. И этого нам хватит для
алгоритма. Значит, алгоритм тогда будет следующим. Значит,
алгоритм – это называется тест Миллера Рабина. Значит,
на вход подается число m. Значит, опять в начале если
как-то отдельно это разбираем, то разбираем отдельно. Иначе
делаем следующее. Много раз, к большой раз, генерируем
случайное a. От 1 до n-1. Значит, во-первых, если… Ну, считаем…
А давайте не буду это говорить. Давайте просто посчитаем
все вот эти вот степени. Давайте еще в самом начале
скажем, что n – это 1 плюс m на 2 в степени s. Посчитаем… Ну,
давайте как-нибудь это назову. v i t – это a в степени m на
2 в степени i. Для всех i от 0 до s. То есть посчитаю все
вот эти вот числа. Если v s t не единица, то n составное
– это тест Ферма. Иначе давайте найдем самое правое
неравное единица. Да, как вот здесь. Ну, если такого
нет, если все эти единицы, то нам это число ничего
не дает, и мы его просто скипаем. Если все они единицы,
то тоже скипаем. Если… Ну, а все они единицы только
если первые из них единицы. Потому что остальные получаются
просто воздействиями в квадрат. Если v 0 равно единице,
то continue. Это просто значит, что они все равны единице
и мы никакой информации не получили. Иначе пусть
r. Пусть r минимальное такое, что v r t, наоборот, максимальное
такое, что v r t не единица. И если это самое v r t не минус
1, то опять n составное. Ну, я просто повторил то, что
я на самом деле здесь объяснял. И в конце, если мы за все
эти k и t рации ничего не нашли, если мы не выявили, что n составное,
то давайте скажем, что n скорее всего простое. Значит,
иначе n скорее всего простое. Не знаю, нужно запятая
или нет. Вроде нужно. Да нет, мы не пользуемся этим.
Мы просто степень двойки делим, пока делится и все.
Нам m не надо раскладывать. Только двойки выделить.
Так, поняли алгоритм? Значит, смотрите, давайте я договорюсь
сам собой и буду называть вот такие вот числа свидетелями.
Ну, точнее, значит, если я сгенерировал такое a, что
для него верно вот это или вот это, то я a называю свидетелем.
Ну, свидетель непростоты. Я говорю, что a свидетель непростоты,
если оно однозначно свидетельствует о том, что n составное. И
моя цель как бы, мне бы хотелось, чтобы при генерации вот
этого числа a я бы попадал в свидетеля. Давайте докажем,
что свидетелей достаточно много. Значит, утверждение
такое, что с вероятностью хотя бы одна вторая при составном
n мы пойдем в свидетеля. Значит, при n составном, при составном
n случайное a является свидетелем непростоты с вероятностью
хотя бы одна вторая. Вот. Ну, если это мы докажем,
что получается с вероятностью одна вторая хотя бы мы всегда
попадаем в свидетеля, значит, тогда свидетель либо вот
здесь вот скажет что n составное, либо вот здесь вот скажет
что n составное. Если мы сделаем, скажем, сто раз, то вероятность
хотя бы один раз попасть в свидетеля, это будет уже
ну там один минус два в минус сотый. Ну, короче, вероятность
ошибиться будет очень маленькой. Специально маленькой, пока
большом. Хорошо. Давайте попробуем доказать это. Я это буду
доказывать так. Я докажу, что свидетелей больше равно
чем несвидетелей, предъявив инъекцию из несвидетелей
в свидетеля. Значит, ну понятно, несвидетель это те, для
которых это неверно все. То есть, если вы сгенерили
a в качестве несвидетеля, то ни одна проверка не сработает
и он посчитает, что n пока что простое. Так вот, я построю
инъекцию из несвидетелей в свидетелей. Это будет инъективное
отображение. Ну и значит, этих должно быть хотя бы
столько, сколько этих, значит, их хотя бы половина. Да?
Вот. Ну, давайте попробуем это сделать. Хорошо, давайте
посмотрим на несвидетеля. Что такое несвидетель? Несвидетели
бывают двух типов. Это либо когда во всей этой последовательности
все единицы, да, это вот случай, когда r даже не нашлось
такого, что vrt не равно единице. Значит, первый тип свидетеля
– это когда все вот эти единицы. Тогда мы что сказать не
можем, мы его просто скипаем. Значит, да, давайте напишем,
что первый тип несвидетелей. Первый тип – это когда
все степени, все v вплоть до, какого там, s-того, они
все единицы. Значит, могут быть такие. Второй тип свидетелей
поинтереснее. Это когда не все единицы, но последние
не единицы – это минус единицы. То есть там сначала идут
какие-то числа, потом какой-то vrt равно минус единицы, а
начиная с vr плюс 1 уже все единицы. Да? Других не бывает.
При составном случайной… Нет, все правильно. Ресвидетель
хотя бы на второй, да, все правильно. Хорошо, значит,
более того, смотрите, я утверждаю, что свидетелей второго
типа существуют. Например, это минус единицы. Точнее,
это не свидетель второго типа. Ну почему? Потому что
m у меня нечетная, v0 – это a в степени m. Значит, это будет
минус единица, потому что я минус единицы возвожу
в нечетную степень. Значит, v1, как v0 в квадрате, уже будет
единицей. Значит, неверно, что они все единицы, но
начиная с какого-то момента они минус 1, а потом и единица.
Ну, значит, в самом начале v0 будет минус 1, а потом все
остальные будут единицами. Значит, по крайней мере один
такой чувак есть, по крайней мере один несвидетель второго
типа точно существует. Хорошо, тогда я имею право рассмотреть
среди всех несвидетелей второго типа того, у которого r максимально
возможно. Значит, среди всех несвидетелей второго типа
рассмотрим такое h. Давайте я так напишу, что h в степени
m на 2 в степени j равно минус 1 по моделю n. Значит,
j максимально возможное. Здесь m на 2 в степени j написано.
То есть я рассматриваю такое число, что у него в этой
последовательности v1, который я здесь построил, v0, v1 и так
далее, минус 1 находится на самом правом месте, имеет
максимально возможный индекс. Среди всех возможных
чисел такого типа я отодвигаю как можно правее эту минус
1. Беру максимальный aj, для которого существует
какой-то такой aj. Ну и поскольку они существуют, я имею право
выбрать из них максимальное. Да, хорошо. И вот я с ним
сейчас буду работать. Давайте рассмотрим n. Я сейчас живу
в парадигме, что n составное. При составном n. Значит,
как может выглядеть составное n? Ну, давайте рассмотрим
первый простой случай, когда n это степень простого,
причем степень хотя бы вторая. Случай первый. Пусть n это
какой-то кувьетой, где e хотя бы двойка, а q простое. Так,
сейчас, мне получается aj здесь будет даже не нужно,
насколько я понимаю. Да, ну ладно, не страшно. Зато
мы поймем, в какую сторону тут можно будет думать. Так
вот, смотрите, давайте возьмем в качестве, пусть n это степень
кушки какая-то. Тогда, давайте посмотрим на такое число.
Значит, я отражаю, что это свидетель. Почему свидетель?
Давайте возведем это все сначала в n степень. Давайте
возведем t в степени n. А, сейчас, или даже в степень
q мне хватит. Сейчас, одну секунду. В степень q я просто
возвожу. Да, да, да. Ну, могу a написать. Ну, то же самое,
да. Ну, это в смысле вот, я просто его по-другому
назвал, чтобы оно было вот именно таким специфическим.
А это у меня было случайно, aj это вот такое, которое
я здесь выбрал. Да. Итак, значит, почему свидетель? Давайте
возведем в n степень, посмотрим, что получится. Это будет
1 плюс q в степени e-1 в степени n. Дальше давайте по биному
Ньютона я это раскрою. Начнем вот единица. Плюс n на q в степени
e-1. Это e, да, везде. Ну, можно, не важно какая-то
буква. У меня e. Плюс и так далее. Значит, там все будут
множители, которые делятся на квадрат вот этого. Значит,
делятся на n. Все вот эти остальные будут делиться
на n. Потому что они делятся на квадрат q в степени e-1,
поскольку e хотя бы двойка, то квадрат будет хотя бы
q в степени e. Все вот эти вот штучки будут делиться
на n. Ну, и это тоже делится на n. На самом деле мы получили,
что t в n на этой единице по моделю n. Ну, вот. Значит,
тогда t в n минус первой уже не может быть единицей
по моделю n. Потому что если бы это было единицей по
моделю в n и это было бы единицей по моделю в n, то обязательно
t должно было быть единицей по моделю n. А t как мы видим
ну не единица, а вот это вот по модулю n.
Ну смотрите, мы знаем, что t в n – это единица по модулю
n.
Тогда, если бы это тоже было единицей по модулю n,
то t обязательно было бы единицей по модулю n, а t – это не единицей
по модулю n.
Ну вот, значит t – свидетель, потому что для него просто
тест Свермасс работал.
Да?
n – первая степень числа не единица по модулю n.
Значит t – свидетель, очевидно.
Хорошо.
Так, значит, хотя бы одного свидетеля мы нашли, супер.
Теперь давайте вот ту самую инъекцию приявим.
Инъекция очень простая, она просто берет и любого
несвидетеля домножает на t.
Значит, вот если d был какой-то несвидетель, то мы в качестве
инъекции рассматриваем просто d умножить на t по
модулю n.
Нужно доказать две вещи, во-первых, что для любого
несвидетеля это свидетель, а во-вторых, что это инъекция.
Ну давайте первое докажем, почему dt – это свидетель.
Ну смотрите, если d был несвидетелем, в частности, он проходил
тест фирма, то есть для него d в степени n-1 было единицей
по модулю n, но раз-то не свидетель.
А t в степени n-1 не единица, значит их произведение в
n-1 тоже не единица.
Значит, мы знаем вот это, значит dt – это не единица
по модулю n.
Значит, это свидетель.
Да?
Хорошо, теперь почему это инъекция?
Почему f-инъекция?
Ну пусть не так, пусть какие-то две d-шки он склеивает, пусть
d-1 на t внезапно склеилось с d-2 на t по модулю n, пусть
они склеились.
Хорошо, так, тогда давайте напишем следующую цепочку
сравнений.
Значит, d-1, давайте я умножу d-1 на t в степени n.
Я знаю, что t в степени n – это единица, поэтому я могу
написать, что d-1 – это d-1 на t в степени n.
Потому что это – это 1 по модулю n.
Дальше, я вычленяю одну t-шку из вот этого вот произведения,
у меня остается d-1 на t в степени n-1.
Вот это вот равно d-2 на t в степени n-1, но вот эта единица,
поэтому остается d-2.
Значит, если для каких-то d-1, d-2 вот это верно, то d-1
равно d-2.
То есть, еще раз, я предположил противно, что f не инъекция,
f склеивает какие-то две дешки, то есть для двух разных
дешек d-1, d-2 их образы совпали, то есть d-1 на t равно d-2
на t по модулю n.
Ну и дальше каким-то арифметическими трюками доказал тогда,
что в этом случае мы победили, мы доказали то, что хотели,
что свидетелей хотя бы столько, сколько не свидетели.
Значит, вероятностью больше, чем одна вторая, хотя бы
одна вторая, мы поведем как раз вне свидетеля.
Это только в первом случае.
Теперь второй случай.
Да.
А неважно, неважно.
Это работает для любого несвидетеля, хоть первого, хоть второго.
Тут я нигде это не использую.
Так, ну второй случай, когда n это не степень простого,
тогда я утверждаю, что n можно разложить в произведение
двух взаимно простых чисел.
q и r взаимно простые, то есть их наибольший общий делитель
единицы.
Ну понятно, если n составной, а при этом не степень простого,
то при разложении на степени простых можно, скажем, в
качестве q взять все степени одного простого, в качестве
r все, что осталось.
Тогда они будут взаимно простые.
Вот.
Хорошо, тогда вот нам сейчас придется вот с этим h повозиться.
Вспоминаем, что у меня было какой-то h.
Тогда, значит, я утверждаю, что существует такое t, что
t сравнимо с h по модулю q и при этом сравнимо с единицей
по модулю r.
Скажите, пожалуйста, почему.
Да, китайской теряемостатках у меня просто взаимно простые
модули q и r.
Я такие системы умею спокойно решать.
Это просто КТО.
Это просто китайская теряемостатка.
Вот.
Теперь давайте докажем, что t свидетель.
Если t является решением такой системы, то t обязательно
свидетель.
Покажем, что t свидетель.
Так.
Ну, давайте рассмотрим его вот эту вот степень m на
2 вжитой.
Давайте рассмотрим его степень m на 2 вжитой.
Ну, понятно тогда, если я просто вот это вот сравнение
возведу в степень m на 2 вжитой, у меня здесь останется
h в степени m на 2 вжитой и это будет минус 1 по модулю q.
Ну, потому что h в этой степени был минус 1 по модулю
m.
Значит, по любому делящему ему оно тоже будет минус
1 по модулю.
Значит, с одной стороны, с другой стороны, t в этой
же степени это единица по модулю r.
Ну, потому что я просто это возвожу в любую степень,
остается справа единица.
Так.
Ну, и тогда я утверждаю, что t свидетель обязательно.
Почему?
Потому что, если я наконец рассмотрю эту степень t по
модулю n, то это одновременно не плюс-минус единица.
Потому что, если бы она была единицей, то здесь было
бы 1, 1.
Если бы эта степень t была бы единицей по модулю n,
то определение и на q, и на r у меня бы тоже оставались
остатки 1.
Но мы знаем, что здесь минус 1, 1.
То же самое.
Эта штука не может быть минус единицей, потому что
иначе бы здесь было минус 1, минус 1.
Значит, эта штука не может быть плюс-минус единицы
по модулю n.
С одной стороны.
С другой стороны, если я наращу степень ж на единицу
хотя бы, то у меня будет здесь и здесь единица, потому
что все возвертывается просто в квадрат.
Значит, вот это не минус 1, однако t в степени m на 2 в
степени g плюс 1 уже единица по модулю n.
Значит, t-свидетель.
Потому что мы нашли какую-то его степень, равную единице,
такую, что предыдущая степень не единица и не минус единица.
Значит, t-свидетель там, в одной из строчек это было
проверено.
Ок?
Да, и теперь то же самое.
Вот, значит, мы нашли свидетеля.
Теперь давайте докажем, что точно такое же отображение
из не свидетелей, получается, путем домножения на тот
самый t, это будет опять такие инъекции, которые мы искали.
Значит, опять давайте для любого не свидетеля положим
f от d, это d на t по модулю n.
И опять давайте докажем те же самые две вещи, что
мы получаем обязательно свидетеля и что это инъекция.
Тогда мы победим.
Ну, короче, сделаем то же самое во втором случае.
Значит, первое, почему dt-свидетель?
Почему dt-свидетель?
Сейчас скажу.
Причем d был не свидетель, да?
То там минус 1, 1.
Да.
Ну, смотрите, раз d не свидетель, то получается, когда мы
считаем его степенью, вот это вот d в m-той, 2 в m-той,
4 в m-той, 8 в m-той и так далее, то у нас либо не все единицы,
либо с какого-то шага, ну, в каком-то моменте минус
1, а потом все единицы.
Причем этот шаг, он не правее, чем g.
Мы специально взяли g, такое, что...
Ну, короче, максимально возможное g взяли.
Это значит, что, смотрите, раз d не свидетель,
то получается, что...
Ну, давайте я так в общем виде напишу, что какая-то его там степень
d на m в степени 2 в i-той.
Вот здесь вот минус 1, а все, начиная с и плюс 1,
уже единицы.
Ну, вот, в общем виде не свидетель такой.
И при этом и не больше, чем g.
Это мы знаем, потому что g мы специально выбрали максимальным.
Среди всех не свидетелей мы выбрали g такое, что...
Ну, короче, при нем это максимальная степень, при которой получается
минус 1 вот здесь.
Значит, и не больше, чем g, ну и тогда если я все перемножу,
то у меня как раз получится то, что надо, потому что, смотрите,
значит, это значит, что d в степени m в степени 2 в степени g
это плюс-минус 1.
Да, потому что если это минус 1, то все, что правее,
ну как бы все, что начинается с этой позиции правее,
либо единицы, либо минус 1.
Поэтому d в такой степени это плюс-минус 1.
Ну, и тогда dt в степени m на 2 в степени g.
Это мы знаем, что значит d-шка это минус 1 или плюс 1.
А t это не плюс 1 и не минус 1.
Значит, тогда это тоже не плюс-минус 1.
Нет, иногда может быть минус 1, если и равно g.
Да, если равенство, то здесь будет минус 1.
Вот, значит...
Да, да, да, да.
Ну, значит, их произведение в этой степени не плюс-минус 1.
Если здесь плюс-минус 1, если вот это в степени будет плюс-минус 1,
а это не плюс-минус 1, то когда перенажать,
не может получиться плюс-минус 1.
Вот.
Значит, эта штука реально не свидетель.
Ну, мы показали, что в такой степени это не плюс-минус 1.
А если я степень еще наращу и напишу 2g плюс 1,
тогда мы знаем, что и эта единица, и эта единица, значит, g будет 1.
Значит, dt свидетель.
Потому что его ds с едной степени одна единица, а предыдущая не единица и не минус единица.
Ну, вот.
А почему эта инъекция докажется аналогична?
Ну, а почему инъекция?
Почему инъекция?
Значит, ну пусть d1t сравнимо с d2t.
Не на t в минус 1, только на что-то другое надо.
Не на t в минус 1, только на что-то другое надо, видимо.
Видимо, на вот это вот надо домножить.
То есть мне надо домножить на что-то, чтобы потом свернулась в единицу.
Ну да, да, да.
Значит, ну давайте домножим на t в степени m на 2 в степени g плюс 1, минус 1.
Тогда у меня как раз слева и справа будет t в степени m на 2 в степени g плюс 1.
M на 2 в степени g плюс 1.
А это мы знаем что единица, потому что вот это тут написано.
Значит, за 1 равно d2, противоречие.
Да, да, да.
Ну я просто показал, какие они бывают.
Сказал, что есть хотя бы один второго типа.
И там выбираю максимум. Внутри второго типа выбираю максимум, да.
Нет, смотрите, инъекция у нас одинакова.
Я просто, во-первых, у меня различные t, по-разному t выбираются.
Ну то есть мне надо доказать, что есть какой-то свидетель, грубо говоря.
В разных случаях по-разному я доказываю, во-первых.
Во-вторых, вот здесь по-разному доказательства проходят.
Ну да.
Не, не, не, еще раз.
Я два раза доказываю в разных случаях.
В первом случае я доказывал, когда n это степень простого.
Там немножко другое рассуждение, потому что я там по-другому выбираю t.
Да, там такое же отображение, там та же инъекция.
Но там другое t, и там я по-другому доказываю.
А здесь другой случай. Я уже так доказать не могу.
У меня n это произведение двух взаимнопростых чисел.
И надо по-другому рассуждать.
Просто два случая, они по-разному разбираются.
Их одинаково не получается.
Ну вот.
Все, значит, мы доказали, что свидетелей хотя бы половина.
Значит, с хорошей вероятностью, если мы много раз запустимся,
то с хорошей вероятностью мы хотя бы один раз по путем свидетеля.
Такие дела.
Ну, хорошо, хорошо.
Тогда с проверкой на просту разобрались.
Так, остается 15 минут. Правильно, понял?
Интересно. Ну ладно, посмотрим.
Может, у тебя на уровне идеи просто.
А? Нет, наоборот.
Значит, теперь давайте перейдем к последней задаче.
Значит, факторизации.
Представьте, что вам дано число n.
Вы, например, прогнали его через тест Миллера Рабина,
поняли, что оно составное.
И вам надо разложить его на множители.
Разложить на множители.
Вот. Ну, давайте я это явным образом пропишу,
что если у вас такая задача, вам просто дается n,
и вам надо его факторизовать, то есть разложить на множители,
всегда сначала разумно провести тест на простоту.
Потому что если оно простое, то можно ничего больше не делать.
Конечно, оно само по себе является своими разложениями на простые.
Перед этим запустили тест на простоту.
Теперь мы считаем, что n составное,
по крайней мере с вероятностью экспоненциально маленькое,
оно может быть простым.
Но вот мы считаем, что оно наоборот.
Короче, мы считаем, что мы правильно посчитали простоту.
Мы считаем, что оно составное.
Вот давайте теперь составное число раскладывать.
Так. Что будем делать?
Мы будем жить в Zn.
То есть будем рассматривать все числа, как остатки по моделю n.
И, смотрите, вот здесь нам хочется вести какую-то функцию,
которая довольно случайно перемешивала бы элементы Zn.
Вот в качестве такой функции обычно берут x² плюс 1.
Вот если я живу в Zn, и просто по x считаю x² плюс 1,
то вот это, скажем так, эмпирически очень похоже на просто случайное перемешивание.
Но это не объект.
Ну, во-первых, и бог с ним.
Да, во-вторых, почему?
А, x минус x склеится, да.
Ну, окей, там, скорее всего, на самом деле, типа...
Короче, нормально, пофигу.
Ну, значит, не перемешивает.
Хорошо, перемешивает плохое слово, близко к плохому случайно, скажем так.
Иными словами, на самом деле, по значению вот этой штуки x найти сложно.
Это прям точно.
То есть, если вам дали какое-то большое число n,
если вы знаете вот этого число, ну, грубо говоря,
ну, иными словами, вы знаете просто x², то вот x найти сложно.
Короче, извлечь корень по произвольному модулю – это сложная задача.
Вот.
И это там где-то в криптографии используется, что вот такая вот функция является односторонней.
Ну, по крайней мере, предположительно.
Что по x² найти x сложно.
Но давайте жить в таком предположении, давайте считать, что это, ну, окей,
там, если не случайно перемешивать, то как-то там, похоже на случайно, в каком-то смысле.
Тут алгоритм будет именно такой, эвристический, про него ничего не доказано,
но как-то вот он на практике хорошо работает.
Вот.
Хорошо, значит, что будет происходить?
Значит, мы сделаем следующее.
Значит, идея такая.
Давайте выберем случайно какой-то x0.
x0 – случайный элемент из Zt.
Ну, и давайте строить последовательность, получающуюся просто применением f от предыдущему x.
Просто многократно навешиваем f.
Вот.
Значит, вот это всё.
Мы навешиваем f.
Вот.
Значит, если бы мы жили в мире, где f, значение f реально случайное,
то скажите, пожалуйста, через сколько шагов мы бы зациклились?
Когда у нас в этой последовательности начинается повторение?
Можно гораздо лучше сказать.
Вот если f случайное, вот представьте себе, что f не такая конкретно детерминированная,
а вот у вас было это случайное число, вы к нему применили случайную функцию,
то есть по факту взяли ещё одно случайное число,
потом ещё раз случайное число, ещё раз случайное число и так далее.
Вот когда вы впервые зациклитесь, когда у вас впервые будет повтор?
Ещё меньше.
Да, примерно в корне, потому что есть парадокс день рождения,
что если вы сгенерируете n случайных…
примерно корень из n случайных величин из отрезка от 1 до n,
то с реальностью близко к единице у вас будет повтор.
Да.
Значит, парадокс день рождения
говорит вам, что если бы f была по-настоящему случайной,
то в среднем через корень из n шагов у вас было бы зацикливание.
Через примерно корень из n шагов
последовательность зациклится.
Значит, зацикливание можно изобразить так.
Вот у вас было какое-то x0, вы посчитали от него x1,
то есть применили функцию f, от него x2,
давайте картинку перерисую, x0, x1,
x2, ну и так далее, короче, считали, считали,
и когда-то вернулись туда, где уже были.
Не обязательно в x0, ну короче, вот зациклились в какой-то момент,
попали туда, где уже были.
У нас получается такая фигурка,
которая похожа на греческую букву «рор»,
и поэтому алгоритм, который здесь мы будем использовать,
называется «рор алгоритм Поларда».
Ну, типа того, да, по образованию бабочки, да,
очень похож на букву «рор», с кубочками нет, но неважно.
Сейчас все будет, не торопитесь.
Значит, вот мы понимаем, что если бы f была реально случайной,
то у нас будет фигурка, которая похожа на букву «рор»,
и поэтому алгоритм, который здесь мы будем использовать,
называется «рор алгоритм Поларда».
Сейчас все будет, не торопитесь.
Значит, вот мы понимаем, что если бы f была реально случайной,
то мы бы примерно через корень zhen шагов зациклились.
Вот, ну и более того, как бы как-то так на практике получается,
что даже если f не случайная, вот такая конкретная,
то через корень zhen тоже на все будет получаться.
Если что, мы всегда можем сгенерить случайное новое x0
и заново пойти, если надо, да,
и тогда, там, рано или поздно, скорее всего, это сработает,
и мы зациклимся.
Вот. Хорошо.
Значит, более того, смотрите, если это составное,
то, ну, давайте я напишу, что n это какой-нибудь pq.
Давайте я из n выделю его минимальный простой делитель.
Минимальный простой делитель.
Вот.
Ну, давайте p на...
Продон, да.
А пофиг, p на q, пофиг.
Вот.
Значит, я выделю минимальный простой делитель zhen.
Тогда, если я рассматривал бы эту последовательность
не как последовательность zten,
а как последовательность zp,
она бы еще быстрее зациклилась,
потому что здесь был корень zhen,
а здесь будет корень sp.
То есть, если я все это теперь погружу в zp
и рассматривал бы все это zp,
тогда бы она у меня еще быстрее зациклилась,
ну, примерно за корень sp действий.
Значит, здесь тогда длина вот этого цикла
была бы примерно корень sp.
Вот.
Ну а p это что такое? p это не больше, чем корень zhen.
Да, минимальный простой делитель составного числа
не больше, чем корень из него.
Значит, у нас длина вот этого цикла
на время, когда мы впервые зациклимся,
будет примерно корень четвертой степени zhen.
Вот.
И такая симптомика у нас у алгоритма и будет.
Ну, еще раз,
если бы мы рассматривали вот эту вот рожку
не в zn, а в zp,
она бы зациклилась еще раньше,
она бы зациклилась через столько действий,
через вот корень sp.
Поскольку p это наименьший простой делитель,
значит, он не больше, чем корень,
значит, это корень четвертой степени.
Вот. Но при этом p мы
саму по себе не знаем, к сожалению.
Наша цель — его найти.
Сейчас, погодите, сейчас будет.
Значит, смотрите.
Что я хочу?
Вот давайте
скажем, что по модулю p,
то есть в zp, у нас происходит зацикливание.
Что это значит?
Значит, что какие-то два числа, два элемента последовательности,
скажем, x it
и x jt,
они попали в одну и ту же точку в zp,
то есть они сравнимы по модулю p.
Это как раз значит зацикливание.
Вот. Более того,
можно надеяться,
что они не сравнимы
по модулю n.
Ну, потому что p
все-таки число довольно маленькое,
корневое по n.
Если они совпали по модулю p,
это еще не значит, что они совпали по модулю n.
Здесь
тут все довольно такое эмпирическое,
тут мало что доказывается.
То есть вот просто представьте себе, что мы
вот в нашей последовательности x,
мы считали, считали, считали, в какой-то момент
представьте, что мы зациклились по p, но не зациклились по n.
Вот пусть у меня есть такая пара x it и x jt.
Тогда я утверждаю, что отсюда можно легко извлечь
хотя бы какой-то делитель n,
не тривиальный.
Можете ли вы
что-нибудь придумать?
Вот представьте, есть два числа сравнимы по модулю p,
где p это делитель n,
но не сравнимы по модулю n.
Можно ли как-нибудь из них извлечь,
с их помощью найти какой-нибудь делитель n?
Ну да, давайте напишем разность.
Давайте пусть скажем, не знаю,
а это x it и – jt.
То есть мы знаем, что это делится на p,
разность делится на p, но
не делится на n, то есть иными словами
а это какое-то число от 1 до n-1.
Можно считать.
При этом а делится на p.
Как бы тогда это p извлечь?
Сложить чего?
Мы тогда получим n.
А, нет.
Ну непонятно сколько,
не понятно сколько раз складывать.
Да, значит
вот есть число кратное p, лежащее в таком диапазоне,
как найти p, грубо говоря.
Давайте просто найдем наибольший
общий делитель a и n.
Это будет не тривиальный делитель n.
Да, потому что
у нас есть какое-то число кратное p,
и n тоже делится на p,
поэтому, по крайней мере, это gcd будет
на p делиться. Но, поскольку
а – это маленькое число, а это разность каких-то двух
остатков, значит эта штука будет
меньше, чем n. То есть эта штука хотя бы p, но
меньше n, значит это не тривиальный делитель.
Не тривиальный делитель.
Причем gcd мы умеем реализовывать
быстро, открытыми в кляда.
Да?
Ну, типа того, да.
Не обязательно.
Не обязательно. Ну, типа если
n – это p на q на r,
то, может быть, там, может быть, ну, короче,
не важно. Это какой-то делитель. Не обязательно.
Ну вот, значит, наша цель
теперь дождаться
такого момента, что вот эта вот
перестановка зазыкливалась в zp, но еще не зазыкливалась
в zn.
Значит, как я это буду делать? Смотрите.
Да, и причем как бы я
не знаю длину цикла, я не знаю p, то есть я
не знаю длину вот этого цикла в zp, я не знаю p,
вообще ничего не знаю. Мне просто хотелось бы
найти такие два элемента
последовательности, чтобы
их разность
дала бы мне какой-то нейтральный делитель
n с помощью gcd.
Ну, тем не менее, я знаю, что как-то они так зазыкливаются.
Давайте вот что сделаем.
Давайте поставим...
Значит, это на самом деле похоже
на задачу о нахождении цикла
в односвязанном списке.
В каком-то смысле у нас вот эти вот переходы
это односвязанный список. Каждая вишина говорит
какая следующая. Каждый вычет говорит
какой следующий. Так вот,
моя цель... А?
Нет. Моя цель...
Слишком много памяти будет.
Значит, моя цель найти вот эту точку.
Ну, точнее не так. Моя цель
на самом деле найти такие
просто два индекса x и xg, разные
два индекса, что они попали в одну и ту же точку
в zp.
Давайте я сделаю следующее. Давайте я поставлю
сюда черепашку,
а сюда зайчика.
И на каждом шаге
черепашка будет идти на один шаг вперед, а зайчик
на два шага вперед.
Ну, и так буду делать.
Зайчик на один шаг...
Сейчас.
Ну, не важно, на самом деле.
Давайте их в одно место поставлю для улупства.
Давайте в одно. Наверное, так лучше.
Просто зайчик
на два шага каждый раз будет прыгать.
И первое из совпадений не считаем до
совпадения.
Блин.
Значит, тогда я утверждаю,
что в какой-то момент,
короче, пока черепашка дойдет
вот до сюда, зайчик уже будет где-то вот здесь.
И потом зайчик будет догонять
черепашку. И поскольку черепашка движется
со скоростью один, рано или поздно
они встретятся в одну и ту же точку.
Вот здесь будет черепашка, а зайчик пройдет еще на один цикл
больше и окажется в той же позиции.
Получится, что мы найдем
два элемента последовательности, как раз
x и xg, которые
попали в одну и ту же точку в zp.
То есть, ну, как раз
у нас будет верно вот это вот.
Но мы с хорошей вероятностью надеемся,
что они различны по модулю n.
Вот.
Получается алгоритм такой. Мы просто
поставили сюда два
итератора, которые двигаются с разными скоростями.
Один движется на один шаг
за такт, другой на два шага
за такт. И каждый раз у нас
есть, получается, две перемены. Давайте скажем, что там
черепашка это t, зайчик
это h. Каждый раз t двигается на
1, h движется на 2.
И каждый момент времени мы просто смотрим
на t-h, считаем
gcd с n
и дожидаемся, когда это будет не
единица. Короче, когда
найдем какой-то делитер. Вот.
Итак, рано или поздно, когда
и черепашка, и зайчик, во-первых, дойдут до цикла,
потом зайчик догонит черепашку,
поскольку он в два раза быстрее ходит.
И здесь рано или поздно как раз будут
такие два числа. То есть, t и h будут
одинаковы по модулю p,
но разные по модулю n, и это даст какой-то
н. Все.
Значит,
ожидается, что это все
будет работать примерно за вот столько вот
тактов.
Ну, потому что мы знаем, что длина этого цикла
максимум корень четвертой степени,
то есть вообще длина всего этого графика
корень четвертой степени z, значит
впервые они зациклются там примерно через столько
итераций, и мы найдем
здесь интервьюальный делитель.
Еще раз?
Откуда p взяли?
Ну, мы не взяли, мы знаем, что она есть.
То есть, еще раз, мы на самом деле
p, вот когда у меня
черепашка и зайчик ходит, они не знают p.
Они просто ходят с разными скоростями.
1 и 2. И каждый раз
там, когда они ставят в каких-то
двух точках, скажем, здесь t, здесь h,
я просто беру их разность и считаю
gcd с n.
Да,
хождение в ztn у меня. У меня все
в ztn, просто
я каждый раз беру gcd разности с n.
И поскольку
если бы я рассматривал в ztp, я бы скоро
зациклился, я бы зациклился через столько действий.
Значит, мне достаточно сделать примерно столько
действий, чтобы найти
в качестве вот этой вот разности
какой-то делитель интервьюальный.
То есть, мы сначала сделали действие, а потом gcd?
Да, у нас перешли зайчик
и черепашка взяли gcd, перешли gcd, перешли
и так на каждом шаге берем gcd.
Да, здесь ничего не доказано,
это ирвистический алгоритм, который хорошо
работает на практике, но
про него не доказано ничего, да.
Это правда.
Мы всегда можем сгенерировать новое случайно
x0 и запустить
заново эту процедуру.
Все, спасибо за внимание.
