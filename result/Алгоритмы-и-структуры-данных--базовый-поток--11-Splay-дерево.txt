Все, окей, смотрите. Сегодня мы с вами... Странно будет так говорить, но ладно. Открывайте
презентацию, и главное не чатитесь в это время, я все замечу. Я замечу, что вы делаете вот так. Так
что давайте. Сегодня мы с вами поговорим про сплей дерева. Я периодически буду тогда часть
рисовать здесь, потому что это будет проще, это будет понятнее. Какие-то основные тезисы тоже
буду делать именно здесь. Сейчас, момент. Смотрите, на прошлом с вами занятии мы рассматривали... С вами
амортизационный анализ. До этого мы рассматривали бинарные деревья. Два получается... Две недели подряд
бинарные деревья. Обычные. Потом амортизационный анализ. И для чего-то же амортизационный анализ мы с
вами проходили. Так вот, сплей дерева именно об этом. Но это мы узнаем в конце. Пока что давайте поговорим
с вами про... Перелистывайте слайд. Про сбалансированность. Смотрите, является ли пермоментная
сбалансированность тем самым святым гралем, серебряной пулей, всегда по-разному называется.
За которым вообще следует гоняться и следует его использовать. Как вы думаете?
Удобная штучечка, так.
Ну здесь это не проблема. Не то чтобы проблема, у нас указатели-то все равно лежат на стэке.
Эти хранятся просто в динамической памяти. Еще есть идея. Что может быть не так? Долго?
Это быстро работает. Мы с вами доказывали это в прошлый раз. Это не так сложно. Это достаточно быстро.
Да, да. Вот у нас есть АВЛ-дерево, но пермоментно сбалансировано. Но оно прям сбалансировано-сбалансировано,
потому что у нас разница высот всегда не больше единицы. Смотрите, представьте следующий случай.
Вот вы, не знаю, являетесь разработчиком какой-нибудь библиотеки. Библиотеки, я имею в виду реально
каких-нибудь книжек. Вот электронные книжки. И вот к вам приходят студенты, и вы знаете,
что сейчас у вас экзамен по мотану. Какие книжки будут брать студенты? По мотану. Логично, правда?
А что делать, если у вас по сути много-много-много разных предметов, много разных книжек. Но вот в данный
момент будет все по мотану. Не лучше ли взять и подвинуть, грубо говоря, эту полочку к вам,
ну либо вот просто выдать пользователю именно те книги, которые есть, именно связанные с мотаном?
Звучит логично, правда? Вот в бинарном дереве поисков, в том числе ВВЛ-дереве, мы бы каждую
книжку искали за логарифм. Ну то есть мы попытались быстро пройтись, но искали бы за логарифм.
И получается, что если бы нам нужно было сделать n книжек, то это n книжек, это было бы n логен.
Согласны? Ну m логен, давайте так, m книжек. А вот если мы точно знаем, что пользователь будет, грубо
говоря, брать и постоянно запрашивать чаще всего какую-то информацию, вот либо из какого-то
промежутка, либо просто один и тот же файлик, ну вы все будете там ботать. Блин, я не помню,
какой мотан. Ну можно сказать, ладно, про линал. Линал по Бекли Мишеву и алгем, скорее. Вот.
Ну большинство в стихе будет делать так. К примеру, это, может быть, уже все поменялось и я уже живу
типа в старом мире, но опять же, например, это так. И вот вы выдаете все время одну и ту же книгу и
один и тот же запрос. И хочется сделать и попробовать сделать так, чтобы на этот запрос повторяющийся,
мы не искали его на протяжении всего дерева, а отвечали на этот запрос быстро. То есть,
если у нас есть какое-то большое количество запросов, мы знаем, что часть из них будет
очень часто повторяться, но в то же время какая-то часть запросов может быть извне, ну не знаю,
кто-то уже готов к мотану и он такой, я хочу ботать физику. Вот пришел этот рандомный человек,
вот надо ему. Или колгосом подготовиться к последнему экзамену. Опять же, такое возможно,
и тогда мы будем искать ровно как со всеми деревьями, то есть просто приходя с помощью рекурсии. Вот это и
будет связано со сплей-деревом, то есть сплей-дерево позволяет работать с такими данными, когда у вас
какое-то количество запросов есть и есть одни очень часто повторяющиеся. Поэтому, когда мы с вами
говорим, что у нас есть, если что, может быть следующий слайд. Если у нас есть каких-то n элементов
и m запросов, то в этом случае обычное дерево за m log n работает. Я хочу это делать быстро и
попробовать это сделать за линию, как это возможно. И вот с этим мы сегодня будем разбираться,
перелистывать еще раз, там написано сплей-дерево. Что такое сплей-дерево? Сплей-дерево это
самобалансирующее бинарное дерево поиска. Оно само как-то балансируется. Важные моменты про
эти деревья. Эти деревья, они не являются перимоментно сбалансированными. Я имею в виду перимоментно
сбалансированными, что каждый момент времени есть какой-то баланс в плане сплей-дерева. Нет,
такого нет. У него немного другой характер и в плане овель, тем более, то есть это вообще не всегда
возможно в сплей-дере. А на отдельных каких-то видах запросов он работать может действительно
линейно, то есть на какой-то определенной выборке. Такое возможно. И для каждого запроса данное
дерево будет полностью менять свою структуру. Как вы думаете, как? Есть какие-нибудь идеи? Вот как
нам сделать так, вот у нас есть дерево, чтобы повторяющий запрос я делал быстро? Вот откуда я
его должен быстро взять? А? Не, это, это... Не. Да. Представим, что мы ищем число 5 типа 100 раз,
а число 1 там 1 раз и 100. Вот если я буду число 5 держать в корне, я же всегда его найду сразу.
Согласны? Вот. У меня же просто есть некоторое дерево и вот с ним пытаюсь как-то работать. И вот
сплей-дерева направлена на то, чтобы после каждого запроса к какому-то конкретному элементу мы бы
поднимали это в корень. Но перед тем, как и к этому всему перейти, перелистывайте слайдик. Вот. Там
будет некоторое описание узла. Я здесь вам специально вернул parent. Это тоже не обязательно
в сплей-дереве, если что. Но иногда бывает полезно. Поэтому я типа и так, и так. Я вот вам
по-всякому рассказываю. Выберите, какой путь вам больше нравится. И можете от этого отталкивать. Да.
Но вот AVL дерево, оно постоянно сбалансировано. У тебя гарантируется, что на каждом шагу разница
высот ни более чем единица в любом поддереве. Ну, перимомента постоянно. Оно постоянно сбалансировано.
Вот. Здесь же мы не говорим, что у нас будет балансированность с точки зрения AVL.
Описание узла выглядит очень просто. У нас есть ключ, у нас есть левое поддерево, правое поддерево,
есть родитель, ну и есть просто небольшой конструктор. Окей. Больше нам чего-то не надо. Вот.
Надеюсь, нигде дальше я там не написал какую-то чушь случайно. А, да, написал. Там написано
нода void, а это void. Я поправлю попозже. Я объясню, я просто заменял буквку v везде, когда писал,
и он случайно заменил везде ее совсем. Это void и это void. Это просто некоторые вспомогательные
функции setParent и keepParent. setParent ну просто устанавливает родителя, если это нода не NullPtr,
а keepParent, если это нода не NullPtr, то устанавливает взаимосвязь родителя и детей. То есть представим,
что у меня есть указатель на детей, мне нужно взять и восстановить родительскую связь. Ну как бы все
просто. Понятно, что они делают? С чем непонятно? setParent или... Нет, это void просто. Да просто void.
void, keepParent, void, setParent. Согласен. Стрелочка. Ну, видимо, да, я что-то это переборщил. А, да,
в действительности это правда. Простите, я исправлю и выложу. Нет, почему? Нода-то сама может
быть NullPtr. Мы можем передать туда NullPtr? Можем. Вот. Ровно как с child. Вот. А для того,
чтобы обращаться к чему-то, нам нужно обращаться к этому, поэтому там нужна девочка. Надеюсь,
дальше у меня получше. Я не помню. Уж простите, я что-то, видимо, когда делал сегодня, сломался.
Смотрите, представим, что у меня есть нода и у нее есть дети. Да? Вот keepParent берет и восстанавливает
вот эту связь. Если у нас есть родитель и он указывает на своих детей, но эти дети не
указывают на это родители. Для того, чтобы поддержать эту взаимосвязь, я делаю keepParent. Понятно?
SetParent устанавливает взаимосвязь. У меня есть раз нода, есть два нода. Он устанавливает
связь от parent до child. Ой, от child до parent. Прошу прощения. Это потом другой вопрос.
Там нигде это будет легко. Вопросы еще есть? Нет. Перелистывайте тогда дальше. Вот у нас есть
такие ноды и самое важное, что есть в сплэй-дереве, это Evristic Muf2Root. Evristic Muf2Root означает следующее,
что после каждого обращения к любой вершине она поднимается в корень. То есть, если вы сделали
find какой-то вершины, она взялась и поднялась в корень. Вы сделали insert какой-то вершины,
она взялась и поднялась в корень. И так далее. То есть любые обращения, они поднимают эту вершинку.
Неважно, что вы с ней делаете. Вот. И подъем реализовывается через повороты вершин. Повороты,
по факту, вам знакомы. Я пишу их немного по-другому. Но повороты здесь правые,
левые повороты, большие правые будут присутствовать и так далее. Вот. В действительности для сплэй-деревья
эти повороты нужны и важны. И будем смотреть, как это делать. Я хочу объединить и левые повороты,
и правый поворот в одну и назвать их rotate просто поворотом. То есть, чтобы мы могли и так, и так
делать. Перелистывайте дальше. Вот. Это аналогично тому же, что было в ВВЛ, но я просто все запихнул в rotate.
А в каком плане? Ну, во-первых, я сделал там, у меня есть какой-нибудь grandparent, грубо говоря,
у меня есть дедушка, родитель и ребенок. Вот. Вот эти три каких-то взаимосвязи. И дальше я говорю,
что у меня в зависимости от этого я буду делать как-то взаимосвязь, потому что мне нужно
parent восстановить. То есть, к примеру, в ВВЛ дерево мы без parent жили, там нам не нужно было это,
здесь нам понадобится для того, чтобы восстанавливать какие-то взаимосвязи. Ну и дальше там несколько ифов.
Если у нас grandparent не на lptr, тогда что я должен сделать? Я должен сказать, что левым ребенком
нашего дедушки должно стать ребенок или правым ребенком в зависимости от того, где был parent. Ну и
дальше все переподвесить. Все достаточно просто. То есть, вот эти взаимосвязи, они ровно такими же остались.
Единственное, что мне потом нужно восстановить вот это вот отцовство у узлов? Вопросы есть к поворотам
или нужно нарисовать это все? Можно нарисовать. Смотрите. Вот у меня есть parent, есть child,
вот у него есть что-то, и вот тут тоже есть. Смотрите, что я вначале смотрю. Я смотрю,
есть ли у меня здесь, здесь может быть и с этой стороны, и с этой стороны вершинка grandparent.
Правильно? Вот. Я смотрю, есть ли у меня grandparent не на lptr, тогда что я должен сказать? Я должен
сказать, что этот grandparent должен теперь указывать на ребенка, не на parent. Согласны? И вот там
вот их написано, если grandparent left равен parent, и если grandparent иначе. Grandparent left равен parent,
если он является левым ребенком. Вот это является. Понятно? Вот. Аналогично, ну правое это else.
И я переподвешиваю вот эту связь, и она становится уже вот такой. Ага. Пока все понятно. Вот.
У child еще пока он указывает на parent и все такое. Теперь я смотрю следующее. Я говорю, что parent
left равен child, то есть является ли левым ребенком мой child. Если он является, тогда в этом случае
я должен что сделать? Я должен сказать, что у меня меняется parent left, вот эта связь,
на child right, то есть на вот эту связь. Вот эти связи должны поменяться. И грубо говоря, это будет
выглядеть следующим образом, что у меня есть некоторый grandparent, который указывает на child,
а теперь child будет связан с его правым ребенком. Становится parent, потому что я поменял вот эти
связи между друг дружкой. То есть представьте, что я свопну. Вот. У parent здесь давайте a, b, c. Вот это
стало a, вот это стало b, а вот это стало, ой, вот это a, вот это b, вот это c. Вот. У меня пока вот
такая связь. Единственное в чем пока проблема в том, что child указывает все еще на parent,
а parent указывает на grandparent. Вот это двойные, это как раз таки, ой, пунктирные линии, это как
раз взаимосвязь родителей. Мне нужно восстановить. Я восстанавливаю для child, я восстанавливаю для parent.
Понятно? Потому что это самый начало такая взаимосвязь была. У тебя есть child, для которого родитель parent,
родитель grandparent. Вы поменяли child и parent. Это просто левый поворот. Ой, правый. Простите,
я путаю правый и левый иногда. Пока еще не за рулем, так что все хорошо. Да, смотрите,
вот эти связи, они подразумеваются как от родителя к детям. Потом мне нужно восстанавливать связь.
Вот. Это он и есть, просто здесь описано. Но здесь благодаря этим вот else, которое написано,
тут вместе есть и левый поворот. Есть правый поворот, есть и левый поворот. Они аналогичны
вот таким вещам. Просто здесь добавились те самые parent, которые нужно держать. Понятно?
Вот. Окейшки. Поехали дальше. Смотрите, с точки зрения евристики, что у нас происходит?
С точки зрения евристики происходит следующее. Мы будем использовать три вида поворотов. В
действительности их можно назвать шесть, но по факту их три. Вот. Это зиг-зиг, зиг-заг и просто
либо зиг, либо заг, как хотите называть. Мы сейчас пройдемся по каждому из них, вы поймете,
что они делают. Поехали дальше. Первый. Это зиг-зиг поворот. Зиг-зиг это когда ребенок, родитель и
grandparent, у них взаимосвязь одна. Они все являются левыми детьми, то есть parent является
левым ребенком для grandparent, либо наоборот. Там все правое. Смотрите, зиг-зиг означает следующее,
что у нас был child, parent, grandparent, либо мы пойдем вправо, либо мы пойдем влево. Как эти вещи
превращаются? Что из этого всего меняется? После того, как мы все повернем, у нас будет наоборот.
Child, parent, grandparent. Аналогично здесь, когда мы повернем, у нас будет child сверху, дальше parent,
дальше grandparent. Здесь как-то все остальные вещи легко переподвешиваются, то есть все их
под деревья. Это понятно пока? Зиг-зиг берет и поворачивает вот так. У нас такого с вами особо
не было. Это по сути либо два правых, либо два левых поворота. Мы так не делали в ВВЛ дереве,
если вы помните. У нас такого там не было. Вот это считайте, это тот самый зиг-зиг, который есть.
Вопросы к зиг-зигу есть? Нет, объясню. Считается, что у них есть зиг-зиг, зиг-заг и заг, а дальше
все их комбинации делается. То есть да, возможно такое, что это будет зиг-зиг-зиг-зиг, но это просто
называют типа n подряд зиг-зигов. Это важно с точки зрения симпотики работы. Мы когда это оценим,
вы поймете. То есть благодаря этому, а это дерево, его придумал Тарьян вместе, не помню с кем, где-то
в 80-х годах. Вот, благодаря этим действиям оно так и называется. Оно оттуда и пошло, что они называются
зиг-зиг-зиг-заг. Оно там и осталось. Это такая традиция. Никаких больших правых,
левых поворотов. Неинтересно так называть. Поэтому в Советском Союзе вот типа четко сказали
в математике ВВЛ дереве большой правый поворот, большой левый, левый поворот, правый. Здесь
зиг-зиг-зиг-заг-заг-зиг и так далее. Да, так и должно быть. Если я обратился к элементу В,
который там написан, то этот элемент В должен стать в корне. Если я сделал find В, то В становится в
корне. Понятно? То есть мы не просто на один двигаем вверх, мы двигаем прям до корни.
Да, да, да. Вот. Давайте следующий слайд. Там зиг-заг-поворот. Вот зиг-заг-поворот это либо
большой левый, либо большой правый поворот. В зависимости от того, как у вас выглядит дерево.
Это происходит в тот момент, когда у вас просто элементы находятся, либо parent является левым
ребенком, а child является правым ребенком, либо наоборот. То есть когда у вас нарушена вот эта
одинаковость. И в зависимости от этого мы с вами говорим, что это будет уже зиг-заг. Зиг-заг,
потому что в разные стороны идет. Я думаю, вы понимаете. Зиг-заг по одну сторону, зиг-заг в разную
сторону. Они смотрят. Просто, понятно? Но я надеюсь, большим правым поворотом и левым поворотом вы
помните еще с прошлой лекции. Еще раз. Смотрите. Давайте следующий. Нам нужно будет подвешивать
вершину в корень, которую мы будем с вами там делать find или что-то еще. Если мы с вами это
подвешиваем в корень, тогда в этом случае ее необходимо как-то повернуть туда. Чтобы сдвинуть
вершинку в корень. Считается, что элементарными движениями с точки зрения вот этих сдвигов будет
зиг-зиг, зиг-заг и заг. Все. Объясню попозже, почему, когда мы с вами в действительности остановимся на
анализе всего этого алгоритма. Окей? Хорошо. Зиг-загом понятно. Но смотрите, зиг или заг поворот,
но это просто типа левый поворот или правый поворот. Понятно? Постройте себе вот эти ассоциации.
То есть у вас добавилось только одно. У вас добавилось, что у вас есть теперь зиг-зиг или заг-заг.
Как хотите назовите. Вот. И причем зиг или заг делается только в одном случае, если grandparent не
существует. То есть parent был тем самым корнем. Понятно? Вот. Теперь переходите дальше. Функция
splay, она как раз и делает ровно то, что нам необходимо. Она берет и поднимает нашу вершинку. Она
поднимает эту вершину как можно выше и по сути ставит в код. Давайте смотреть, что там происходит.
Первое, что вы там видите, если у нас нет родителя. Но если нет родителя, то это означает что? Что
это вершина корень. Если она так в корне, то мы ничего не делаем. Логично? Логично.
Всего. Но еще раз, в каком случае вершины нет родителя? Это когда у нас нету вершинки
выше какой-то. Вот когда вот это отсутствует, это является корнем. Корень. Да. Самый корень. Вот.
И splay это делает как раз таки. А дальше смотрите, у меня есть parent, у меня есть grandparent. Ну все
достаточно просто. Причем grandparent тоже может быть на lptr. Вот если grandparent равен на lptr,
тогда у нас что происходит? Тогда у нас выглядит примерно следующим картином с точностью десиметрии.
Что вот это является корнем. Вот этот parent является корнем. Тогда мне достаточно сделать
один zig или один zag и это будет корректно. Согласны? Вот. Поэтому вот этот if,
который там написано, вот этот rotate parent нода, вот этот rotate parent нода, он и есть здесь. Мы
просто повернули, получили, что он сверху. Согласны? Теперь смотрите, что у нас происходит дальше.
Если это не так, если у нас действительно существует grandparent, если у нас есть grandparent,
тогда в этом случае мы должны сделать либо zig zig, либо zig zag. А как мне проверить,
что у меня есть zig zig или zig zag? Ну у меня должно быть либо два левых ребенка, либо два правых
ребенка. Согласны? Смотрите, какая там переменная написана. Bool zig zig. И она говорит следующее,
если grandparent left равен parent и если parent left равен ноде. То есть grandparent left равен parent,
это будет true, если это правда, иначе false. И parent left равен ноде, это true, если это правда.
Если у нас true равно true, то левый и левый будет true. А если они будут оба false, то это будет
означать, что они все являются правыми детьми. Согласны? То есть false равно false тоже будет true.
А вот все остальные комбинации это будет уже zig zag. То есть вот эта переменная zig zig
означает, что они находятся вот именно по одну сторону, либо все слева, либо все справа. Понятно
пока? Точно понятно? Кто-то уснул, кому-то уже плохо. Ладно, окей. То есть смотрите,
у нас есть такой момент. Ну и дальше. Если у нас есть zig zig, тогда мы с вами в начале делаем
rotate. Ну для того, чтобы сделать zig zig, оно в какой последовательности происходит? Смотрите,
вот у меня есть вот такая последовательность. Тут у меня child parent grandparent. Он переделывает
в начале в parent, который будет здесь child grandparent. Первый поворот будет означать. А
следующий поворот будет делать child parent grandparent. Вот это zig zig. То есть мы сначала
поворачиваем вот просто направо, потом еще направо. Понятно? Вот это там и происходит. То есть вот
те два rotate, которые там написано, что мы изначале делаем grandparent и parent, поворачиваем, и он их
выставляет таким образом. После чего я делаю поворот parent и node и получаю вот такой вот элемент.
Если же у меня будет zig zag, то что я в начале должен буду делать? Какой первый мой шаг будет?
Да, у меня в начале будет поворот снизу. У меня будет поменять местами child parent. То есть я
буду делать child parent. А после этого я поворачиваю child и grandparent. Поэтому у меня будет вот так.
Вот это zig zag. Но он стал выше parent и grandparent. Он стал некоторым корнем вот этого поддерева,
которое было здесь. То есть это все является каким-то поддеревом. Может быть это финальное поддерево,
может быть нет. Мы будем повторять zig zig, zig zig, zig zig, zig zag и так далее. Будем постоянно
повторять это и все. То есть представь следующее, что у тебя есть вот такое какое-нибудь дерево.
Мы на fine посмотрим. Это будет рекурсивно просто делать.
Но представь я обратился вот к этой вершинке. Давай я ее закрашу. Что я в начале сделаю? Я в
начале сделаю zig zig. Я получу, сейчас считать надо. Раз, два, три. После этого получу вот
здесь эту вершинку, а от нее будет еще вот так две. Я тебя нумеру. Ноль, один, два, три, четыре,
пять. Пять, четыре, три, ноль, один, два. Вот это мой первый zig zig. Следующий опять zig zig будет.
А что непонятно? Ну давай сделаем вот так. Так лучше?
Ну так понятно, что будет zig zag когда-нибудь. Вроде должно, правда?
Ну смотри, в начале у меня будет zig zig. Согласен? То есть в начале я получу пять,
четыре, три. А дальше здесь будет эта закрашенная вершинка и влево идет уже один, два. Теперь вот
эту вершинку наливаю, я делаю сюда. У меня вот такая вот штука. Это zig zag. Согласен? Давай
смотреть, что здесь произойдет. Пятерка останется, если что, на месте. А ты хочешь поэтапный или финальный?
Понял, смотри. Что мы делаем здесь? А давайте я лучше, наверное, поэтапный тоже сделаю. В начале,
что у меня здесь происходило? Я менял child и parent. Если я меняю здесь child и parent,
тогда в этом случае у меня четыре пока остается на месте. А что происходит с child
и parent в этом случае?
Так, остальные? Все согласны?
Что не так? Один, два должно быть правее, чем три. Смотрите, очень просто.
Кто там что обсуждает? Скажите тоже. Видите, как перемещается A, B, C? B становится чем? Оно было
левыми детьми C, а стало правыми детьми P. Почему? Потому что P должно быть меньше, чем B,
правильно? То есть B больше, чем P. А все, что больше лежит где, правее. Поэтому здесь становится вот так.
Один, два. А, ой, sorry, я это, да. Извините. Закрашенная клеточка, ту, которую мы ищем как раз,
нулевая, которую мы поднимаем. Вот, я сделал один лишь поворот вот этот вот. Теперь мне нужно
сюда их повернуть. Когда я это делаю, я с вами получаю здесь пять, здесь что? Ну и так. А слева три.
5, 4, 3, 2, 1. Это номера вершин? Это номера вершин? Это не числа? Нет, нет, нет. Это просто номера для того,
чтобы нам было легче понимать и воспринимать. Вот, у нас получилась вот такая вот штука, согласен?
Но осталось сделать один зиг. Или зак, как хотите назовите. Ок, но это легко уже сделать, согласен?
Ну, типа на всякий случай. Вот у меня здесь останется три. Один, два. Вот. А здесь будет 5,
и у пятёрки где будет четвёрка? Слева. Вот такое дерево получится. Вот так мы поднимали эту вершинку.
Понял? Теперь стал понять, нет? Вообще без разницы. Сейчас без разницы. Я объясню в конце,
почему это так выходит. Хорошо? Мы проанализируем. Вот, функция Play работает вот именно по таким
концепциям. То есть у нас есть зиг-зиг, у нас есть зиг-заг. И вот в зависимости от того,
что происходит, мы с этим делаем. Вот здесь у меня был зиг-зиг, вот дальше у меня здесь был зиг-заг.
А, вопрос? Да. Нет. Нам для оценки нужно больше, иначе у нас будет проблема. Окей? Окей.
Вот здесь? У нас зиг-заг, но я расписал его по действиям. Сначала вот этот кусочек,
потом вот этот, чтобы не запутать вас всех. Хорошо? Готовьтесь к тому,
что я вас попрошу поделать эти вещи на контроль. Хорошо? Да, да, да. В виде рисуночков. Я захочу
от вас получить итог. Вот. В общем, так работает Play. Теперь переходите на следующий слайд. Там
будет Find. Смотрите, Find работает просто рекурсивно. То есть, опять же, нашли ключ,
выводим ключ. Нашли, если меньше, тогда идем влево. Если больше, тогда идем вправо. Ну и так далее.
Все просто. И здесь единственное, что добавляется, знамите, сплей root. Видите функцию сплей? Вот это
сплей и является тем самым отличием от обычного бинарного дерева поиска. Оно показывает,
что наша вершина поднимается вверх с помощью рекурсии. Почему? Потому что сплей делает один лишь
зиг-зиг, зиг-заг или зиг или заг. Или заг-зиг или заг-заг. Вот. В общем-то, сплей делает только одно.
Но важный момент здесь следующий. Так как у нас есть стек рекурсии, то этот стек, когда
начнет раскручиваться, этот сплей начнет выполняться последовательно и поднимая нашу вершинку. Понятно?
Но это примерно так же, как мы ищем минимум, максимум всякие такие вещи. Вот. То есть, мы здесь
будем брать и поднимать эту вершину в корень с помощью зиг-зигов, зиг-загов. И все. Все становится
хорошо. То есть, мы тянем ее вверх, все получается. Вопросы есть? Пока что. А? Нет, почему?
Подожди. Ты не понял. Смотри, при ретернете делаешь сплей. Этот сплей поднимает вверх. Но важный
момент, когда мы нашли ключ. Мы же когда искали ключ, он вызывал еще один файнт рекурсивно. Там еще
один сплей. То есть, смотрите, там много сплеев. Эти сплеи будут вот все время браться для этих
вершин и поднимать ее вверх. Нам настолько без разницы, как будет выглядеть дерево в любой момент времени.
Понятно? Вот. Да. Ищет положение ключа. Да. Ну вот key равно root key. И вот этот файнт, по факту,
он берет, находит этот ключ. Ключ-то где он находит? Он возвращает ноду звездочка, он возвращает эту
ноду, указательную эту ноду. Но эта нода будет в корне. Сплей возвращает на новый root. Ну то есть,
когда он поднял какую-то вершинку, вот после вот этого, к примеру, действия, он вернет указательную
вот это. А предполагаем, что все есть. Если нет, тогда все будет хорошо тоже, потому что мы будем
поднимать в корень что-то. Подожди. Ты дойдешь до этого. Мы все дойдем до этого момента. Обычно в
конце все говорят, что очень плохо. Вот. Но мне очень нравится это дерево, сразу скажу. Прям
категорически. Если этого числа, к примеру, нет, тогда он вот этим ифом пройдется по максимуму,
по которому есть, и найдет ближайший, и поднимет его, если что. Ну потому что он
будет все равно выполнять этот сплей. Понятно? Странная реализация будет. Очень странно это
всего. Вот. Поехали дальше. С точки зрения какой-то сложности, у нас осталось две новые вещи. Вставка и
удаление. Вставка и удаление нужно их как-то реализовать, нужно понять, как это делать. И на
самом деле для реализации вставки и удаления существует такая вещь как сплит и мерч. Вы еще
познакомитесь, точнее не познакомитесь, вы будете вспоминать скорее про вот эту лекцию на декартовых
деревьях, потому что сплит и мерч тоже применяется. Объясню, что такое сплит и что такое мерч.
Смотрите, сплит умеет разделять, думаю вы поняли из названия, разделять дерево. Представим,
что у меня есть какое-то единое дерево, и я вот по какому-то ключу K хочу его разделить на два.
Я сделаю сплит по этому ключу. Вы там это не буяньте, если скажете, что все совсем плохо и непонятно,
лучше скажите. Вот. Я хочу получить из него два дерева T1 и T2. Причем это все еще бинарные деревья
поиска и все ключи в T1 меньше, чем T2. Причем вот здесь они меньше, чем K, вот здесь они больше,
чем K. Если у нас был равный K, то мы его выкинули. Понятно? То есть сплит занимается именно таким вот
делом. Понятно, что он делает. Понятно, что так можно сделать, я надеюсь, правда? Все понимают это.
Делим дерево. Нет. Нет, этот ключ не обязательно существует вообще в этом дереве. А если существует,
то мы его выкидываем. У меня два дерева в результате T1 и T2. Мы знаем, что в T1 у нас меньше ключа
все значения, в T2 все больше. Вот. В результате такое. Два дерева. Он разрезал просто дерево.
А в чем проблема вернуть два дерева? Кто вам такое сказал? Зачем вы проходили структуру?
Вам нужно вернуть два указателя, два указателя на рут. Правда? Вот два указателя на эти деревья
сделать. Пока с этим сделаю. И следующий слайд именно об этом как раз-таки. Сплитет 3, пока вы еще парни
знаете и так далее, вот здесь можно использовать это. Там будет указатель на левое дерево, указатель
на правое дерево. Ну и просто его конструктор для того, чтобы было проще жить. Понятно? Ну вот,
он может вернуть объект сплитет 3. Логично? Логично. Вот. И мы самостоятельно будем гарантировать,
что в этом сплитет 3 левое дерево меньше правого. Вот. И разрезана она ключом. Поехали дальше.
Теперь реализация. Возможно, вам не нравится эта реализация. Она выглядит чуть-чуть громоздко,
но в действительности что здесь вообще происходит? Давайте разберем два таких
корнер-кейса. Как этот сплит работает. Смотрите. Предположим, что у меня было некоторое дерево.
Вот у меня было дерево и в нем внутри где-то лежал этот ключ K. Ага. Если я сделаю find этого
ключа, что у меня произойдет с плей дерева? Всплывет вер и у меня тогда будет ключ здесь. У меня будет
левый его кусок и правый его кусок. А теперь смотрите. Согласны ли вы, что в левом куске находится
все меньше? Это и есть наш T1. Согласны ли вы, что в правом куске находится все больше? Это и есть
наш T2. Осталось удалить ключ. Теперь следующий вопрос. Что будет, если нет ключа?
Там left и right. Да, мы удалили root. Sorry. Там left и right. Да, это правда. Я тоже умею лагать.
Знаете этот факт. Это бинарное дерево-поиск. Как оно может это не поддерживать? Да, правые-левые
повороты абсолютно все всегда сохраняют. Еще раз, тут чиселки означают номера вершин. Не числа.
Хорошо. Давайте значение. Я понял вас. Вам сложно. 15. Давайте я буду обводить это. 15.
Нет. Сейчас. Момент. Давайте тут 14. Тут 6, 7, 8 и 9. Поехали сюда. 9, 8, 7, 6,
14, 15, 15, 14, 9, 6, 8, 7, 15, 14, ой, нет, 9, 14, 6, 8, 7,
так стало понятнее. Мы сохраняем. Любые повороты сохраняют это все, а не на той повороте, а не изменения
дерева. Вот. Так вот, если мы вдруг нашли ключ, тогда в этом случае мы с вами говорим о том,
что у нас есть ключ, все хорошо. Если же такого ключа не существует в нашем дереве,
а, заметьте, я делаю все равно find, root и key. Когда я делаю этот find, что он делает? Он тот самый,
вот, грубо говоря, ближайшее значение его и выкидывает вверх. Вот этот find все равно его
выкидывает наверх. И дальше мы смотрим, это ближайшее значение, оно меньше или больше моего ключа?
Если оно меньше, то есть значение, вот тут которое лежит, там x, если оно меньше, то какое дерево оно
должно войти? Влево или вправо? Влево. То есть я сделаю так разрез. Если оно войдет, если оно
больше, то оно влево или вправо войдет? Тогда я сделаю так разрез. Все. А вот. Поэтому здесь мы можем
это делать таким вот образом. Вопросы есть? Нет.
Обязательно. У нас нет этого ключа, иначе бы find нашел этот ключ. Понятно? Да. Только не
нет. Еще раз, у тебя find кладутся вот так. F там 1, F2, F3, F4. Это все find и так далее. Самый
верхний find, что делает? Он делает, вызывает сплей. Сплей того, до чего дошел. Самое близкое нашел. Согласен?
Он делает этот сплей. Потом следующий find тоже делает сплей. Того же элемента и так далее.
Он либо находит этот элемент, либо если он его не находит, то он берет и делает сплей.
Тоже его. Он делает элементы близкие к нашему. Простите, пожалуйста. Смотрите, я спрашиваю, вот
find. Давайте еще раз. Мы говорим, что если у нас ключ меньше, чем ключ, который лежит в корне,
тогда в этом случае мы идем в левую часть, иначе в правую часть. Вот он идет в левую часть и ищет там,
потом ищет еще, ищет еще и так далее. И он находит близкий к нашему ключу значение,
самое ближайшее, которое находится. Меньше, больше. Понятно? Да, ближайшее значение.
У нас нет балансировки. Забейте пока на нее, типа не существует ее.
Балансировка по высоте это ВВЛ деревьев. В ВВЛ деревьев у тебя высота лево-право по
дереву отличается не более чем на единицу. Не, все нормально. Так вот, у нас есть сплит. Сплит,
я надеюсь, вы поняли сутивый смысл этого сплита. Как он берет и распличивает эти моменты. Понятно?
Это было понятно, надеюсь. Отлично. То есть он берет и раскидывает эти элементики. А теперь
смотрите, когда он взял их и раскинул. Что у нас есть? У нас есть два дерева. В одном меньше ключ,
в другом больше ключа. А теперь представьте, что я должен вставить ключ. Куда мне его вставить,
если у меня есть два дерева? У меня есть дерево Т1, у меня есть дерево Т2. И я знаю, что вот этот вот
меньше key строго, вот этот больше key. Где у меня должен встать key, если я его вставляю? Корень.
Вот этой будет insert. Кто делает insert? Можете следующий слайд посмотреть. Insert делает
следующее. Он берет, сплитит наше дерево, разрезая его на два. Где у нас меньше ключ, где у нас
больше ключ. После этого, после этого он просто берет и говорит, что я создаю новую ноду. У нее
теперь левый ребенок. Это левое под дерево, правое ребенок, правое под дерево. А он становится корнем.
Просто. Там и вопрос типа в сплите. Вот если сплит вы понимаете, то все очень просто. Ясненько?
Прекрасненько. Поехали дальше. Merge. Смотрите, кроме сплита бывает merge. А когда у нас с вами есть
вот два, грубо говоря, таких же дерева, одно меньше, чем другое, то нам необходимо взять и склеить их
периодически. То есть мы их могли расплитить. Иногда нужно взять их и склеить. Как мы можем это
сделать? Но мы с вами уже подобное проворачивали. Помните, когда мы переподвешивали всякие вершинки?
Что может быть корнем у этих двух деревьев? Да, то есть мы можем просто найти здесь вот тот самый
минимум и запихнуть его наверх. И сказать, что он будет корнем. Понятно? Потому что мы его найдем,
он точно будет больше, чем все остальное. И в то же время он будет меньше, чем здесь. А теперь
смотрите, какая хитрость здесь. Мы можем с вами искать это, потом переподвешивать, еще что-то. Зачем
нам нужно это делать? Если мы просто можем взять с вами и сделать find в дереве T2 какого-нибудь
ключа, например, корня из T1. Что в этом случае он найдет? Он найдет самый ближайший элемент к
нашим. А самый ближайший какой будет? Наименьшим, потому что там все элементы меньше ключа, а там все
элементы больше. А find мы ищем относительно дерева T2. То есть последовательность действий примерно
следующая. Вот здесь. Ну какой-то вот здесь х лежит. Я делаю find х в T2. Если я делаю find х в T2,
то он поднимет вот этот минимальный корень, потому что find делает еще display. А если он поднялся в корень,
то смотрите, у меня есть вот этот вот минимум. Где все дерево T2 остальное лежит? Правее. Вот этот
вот T2 без минимума. И у него левого ребенка-то нет, потому что он поднялся в корень, а левый
ребенка быть не может, потому что нет ничего меньше в T2, чем он сам. А значит мы просто сюда подвесим T1.
Да, merge должен сделать из двух деревьев в одно. Ну склеивает их. Понятен смысл того,
что я сейчас сделал. Ребят, да, нет, смерть, не знаю, что. Типа все плохо, непонятно. Так вот,
ну если вы перейдете в реализацию следующий слайдик, то там написано гораздо меньше,
чем в сплете. Почему? Потому что мы просто проверяем есть там это имя или нет. Но если
что-то какое-то из деревьев на lptr, тогда мы просто возвращаем одно из этих деревьев. Если же у нас
они оба не на lptr, тогда в этом случае я возвращаю. Я говорю, что правое дерево у меня равно find в
правом поддереве ключа из левого. Он находит ближайший к нему, этот ближайший находится где. Это
минимальный элементик. Поэтому у этого минимального элемента нет левого ребенка. Значит, я говорю,
что right left равно left. Left это дерево слева, вот тот t1, который я вам нарисовал. Ну и все. Дальше
parent восстанавливаем и закончим. Merge очень простой. Согласны или не согласны? Ну ладно. Хорошо.
Теперь remove. Ну то есть когда я хочу удалить что-то, следующий слайдик. Для того, чтобы удалить
некоторую вершину, вам нужно всего лишь поднять ее наверх, а потом слить ее левое и правое поддерево.
Согласны? Вам нужно просто замерзнуть их. Поняли, что я имею ввиду? То есть еще раз,
я делаю тот же самый find этой вершинки. Она поднимается наверх и если что потом склеивается.
Okay. Remove гарантирует, что у нас такая вершинка есть. А зачем split? Еще раз, если вы делаете
find некоторые ключи, которые у вас присутствуют, гарантируется примеру, что у вас присутствует
этот ключ, тогда что в этом случае делается? Ну потому что иначе вообще нет смысла. Ну вот
вы можете в этот записать типа, не знаю там, если root key не равен кею, тогда выкинуть на
SNALPTR. Но еще раз, remove что делает? Когда вы сделаете find key, у вас будет вот этот key.
Согласны? Вам нужно удалить этот ключ. Вы берете его, удаляете и делаете merge t1 и merge t2.
Ну просто. Ну мы можем сказать, что если у нас корень равен ключу, а не равен, тогда в этом
случае SNALPTR выкинь. Ну можно так. Можете добавить, я не против. Но в принципе это все достаточно
понятно и просто должно. Согласны? Смотрите, мы с вами разобрались со сплей деревом с точки
зрения, вставки, поиска, удаление, элементика. Осталось понять главное, за сколько это работает.
И вот тут я сразу прошу прощения, но там доказательства объемные и большое. Я специально
выпишу почти все шаги на презентацию для того, чтобы вы потом не сломались мне перед экзаменом и не
говорили, что мы ничего не понимаем. Хорошо? Мы могли спокойно сесть и прочитать. Вроде бы там все
понятно написано. Поехали. Анализ времени работы алгоритма. Смотрите, заметьте, мы в любом алгоритме
с вами используем сначала find, а потом какие-то простейшие операции. Завод единички. Согласны?
Вот. А сама по себе функция find работает пропорционально глубине искомой вершины,
после чего делает сплей этих всех вершин. Согласны? Отлично. Вот. И, по сути, вот эта
функция сплей, она тоже работает пропорционально этой глубине. То есть ровно столько же, сколько там
было, если смотреть весь сплей. Ок. То есть нам нужно оценить просто время работы сплей дерева.
Ой, просто сплей. Господи. Функции сплей. Будем оценивать это с помощью нашего любимого
амортизационного анализа. И в особенности с помощью метода потенциалов. И вот здесь потенциалом будет
выступать следующая величина. Представьте, что у нас есть размер под дерево в количестве вершинок.
Количество вершинок. Окей? Вот это вот S я назову. S от V. Вот по дереве с корнем V, S от V вершинок.
Рангом вершинки назовем двоичный логарифм от этого количества вершинок. Всё понятно. Ну просто
логарифм от количества вершинок с корнем в этой вершине. А теперь смотрите. Потенциал дерева
T, то есть состояние, потенциал нашего состояния, он будет сумме всех рангов в этом под дереве.
Ранг это двоичный логарифм от количества вершин в этом под дереве. То есть смотрите. Я же говорил,
что потенциалы это не очень просто и не всегда их можно легко найти. Вот в этой
задаче нужно было подумать на тему того, как это сделать. Что еще раз? Да. Да. Это обычно бильет.
Смотрите. Сплей дерева одно из самых сложных в нашем курсе. Это правда,
но то, что он может вам попасться просто так в билетах, конечно.
Ну давайте про это поговорим попозже, про экзамен. Да.
Ну мы когда докажем, вы поймете, что это работает.
Да, метод мат-индукции ты понимаешь, как для суммы делать, для суммы квадратов. Ты вот понимаешь,
откуда эта формула предполагается? Ну нет. Опять же, нет. На самом деле здесь есть
некоторый смысл. Смысл в том, что мы хотим доказать, что наш сплей работает за логарифм.
Логарифм от количества вершин. Ну то есть мы хотим доказать, что это сплей дерева, в принципе,
отвечает на запросы в амортизационном случае за логарифм. Мы хотим сказать,
что оно не хуже, чем, в общем, другие деревья. Поэтому здесь это так. Но потенциал это сумма логарифма.
Понятно? Да. Не-не-не. Под дерево имеется в виду следующее. Вот у меня есть там, как-то связано было,
вот у меня есть вершина В. Вот у него есть его по деревьям, но все вот это по дереву. Вот это
вопросы. А? Снизу. Снизу в анализе времени работы. Смотрите, а что такое фиатэ? Фиатэ это сумма
всех рангов вершинок, которые вот здесь вот есть. То есть это некоторая сумма таких логарифмов двоичных.
Всех вершин, которые здесь есть. Это сумма логарифм. Это не логарифм. Это сумма логарифм.
Сумма этих рангов. Пока понятно? Это только начало. Поехали дальше. Следующее утверждение,
которое по факту покажет нам то, что будет действительно эта все работа за логарифм.
Амортизационная стоимость операции сплей от вершины В в дереве Т с корнем R. Ну короче,
у вас есть дерево, у него корень R, и вы находите, ну вы делаете сплей от вершинки В. Поднимайте.
Вот амортизационная стоимость этой операции будет 3 на ранг R минус ранг В плюс единичка.
Вот это мы сейчас будем доказывать. Это дальше. Это не утверждение без доказательства. Это
просто то, что мы будем с вами доказывать. Заметьте, пожалуйста, что ранг R это что логарифм.
Ранг R это один логарифм. Логарифм этого всего дерева. Это не потенциал. Ранг это просто логарифм от
суммы всех элементов, которые там есть. Сумма всех узлов. То есть это все узлы. То есть от логарифм N.
От количества, да. То есть логарифм N от количества. И минус ранг В. Ранг В может быть каким угодно.
Хоть ноликом и так далее. Потому что одна вершинка тоже может быть. А может быть и не ноль.
То есть в общем-то ограничено по факту тремя логарифмами. Вот это здесь говорится. Поехали
доказывать. Поехали на следующий слайд. Их будет много с таким большим текстом для того,
чтобы вы могли, если что, сесть почитать. Я сейчас буду вам рассказывать. Вы должны
меня останавливать в моменте, когда вы что-то не понимаете. Хорошо? Смотрите. Если вы это корень,
то утверждение очевидно. Правда? Но все логично. Нам нужно сделать одну проверку и это будет одно и
то самое действие. А дальше логарифм друг друга убьют. Ок. Ок. В противном случае мы разделим
функцию сплей на несколько этапов. У нас возможен один из трех поворотов. Зик, зик-зик,
зик-зак. Зак-зик и зак-зак это одно и то же. Симметрично нас не сильно интересует. На
простой поворот, то есть зик, уходит единичка времени. Для того, чтобы поменять местами вершинки,
мы будем говорить, что у нас единица времени какая-то уходит. На два простых поворота,
то есть на зик-зик или зик-зак две единички времени. Ок. Ок. После каждого этапа ранг вершины будет
меняться. Пусть он в начале равен ранг В0, то есть там, где он находится, то есть ранг В по факту,
ранг В0. А после этого ранг ВИТ. И для каждого этапа, может быть, кроме последнего, мы покажем,
что мортизационное время на его выполнение можно ограничить сверхувеличенной вот этих три ранг
ВИТ, минус ранг ВИТ, плюс единичка. Вот если мы все это покажем, то у нас все получится. Как это
можно показать? Ну, для начала все просто. Если мы возьмем и скажем, что действительно будет так,
тогда эту единичку мы с вами выкинем. В действительности она нам будет не нужна. Это плюс единица, она за суммой.
А дальше там сумма рангов, ну как бы ранг ВИТ, минус ранг ВИ, минус первая, а где-то было плюс ранг ВИ,
минус первая, минус ранг ВИ, минус вторая и так далее. Но это ровно как с потенциалами. Мы получим
итоговое значение, минус начальное значение. Да, нам нужно это показать. Ну, мы в утверждении это
написали, что мы хотим такое показать. Понятно? Теперь поехали следующие. Анализ времени работы
каждого из zig, zigzag, zig, zig, zig, zigzag. Первый zig. Фактическое время единичка. Посмотрим
на рисунке и поймем, как работают у нас здесь ранги. Напомню, потенциал — это сумма всех рангов.
Согласны ли вы, что ранги из А, Альфы, Беты и Гаммы, они не влияют для нас, потому что там
сумма рангов одна и та же. Правда? Ну вот, что была до этого, что и осталось. Там не изменилось
количество вершин, оно ровно такое же осталось. Поэтому мы рассматриваем лишь нашу вершину В и
П. Прошу прощения. В и Р. Ок? Ок. Смотрите, каким стал потенциал? Ну, во-первых, единичка в
начале, которая стоит, это тот самый плюсик от того действия, что мы поменяли. Дальше мы смотрим на
разность потенциалов. Потенциал стал это ранг В штрих плюс ранг Р штрих. Правда? Ну вот справа то,
что нарисовано, потенциал такой. Ранг Альфа, Бета, Гаммы меня не интересует, потому что они вычтутся
друг из дружки. Они не меняются. Альфа — это под дерево, Бета — это под дерево. Ну смотри, АИТО — это
количество времени, которое ты потратил на это действие. Да, помните, как мы искали в амортизационном
анализе с помощью метода потенциалов? Мы говорили, что у нас затрачивается время ТИТ, плюс разница
потенциала ФИСИТА минус ФИСИ-1. Было такое. Да, мы это и считаем. Мы говорим, что у нас единичка — это
та самая единичка из-за того, что мы тут поворачиваем. И у нас есть ранг В штрих плюс ранг Р штрих.
Нет. Еще раз, АИТО как работает? Вы подождите, вы сразу пытаетесь уйти в утверждение. Помните,
мы с вами говорили, что время работы с методи потенциалов — это равно ТИТ, реальное время работы,
плюс ФИСИТА минус ФИСИ-1. Было такое. Вот это ТИТА равно единице. Вот это ФИСИТА — это, по сути,
ранг В штрих плюс ранг Р штрих. Но там есть еще плюс АЛЬФА, БЕТА, ГАМА ранги их. Еще раз,
ПИ — потенциал. Потенциал я как задал? Как сумма рангов. Но это состояние дерева. Это состояние. То
есть то, как выглядит дерево. Я говорю, что мой потенциал равен сумме всех рангов. Что такое ФИСИ-1?
Это ранг В плюс ранг Р плюс АЛЬФА, БЕТА, ГАМА. Тогда АЛЬФА, БЕТА, ГАМА я их никогда не буду
учитывать. Они сразу испаряются. Еще раз, АЛЬФА, БЕТА, ГАМА — это те самые. Они вычитаются друг
из друга. У них не меняется количество элементов. Поэтому у меня там написано ранг В штрих плюс
ранг Р штрих минус ранг В минус ранг Р. Ровно так же. Все потенциалы складываются. Ранг В плюс ранг Р
плюс АЛЬФА, БЕТА, ГАМА. Возьмите две вершинки, которые нарисованы, плюс все по деревьям. Я прошу
прощения, но я вас задержу, потому что потом вы мне скажете, что я вам не объяснил свой дерево.
Да, для всего дерева. Да, потенциал равен сумме всех рангов в нашем дереве. Понятно?
Еще раз, мы анализируем зиг, зиг-зиг и зиг-заг. Мы каждый из этих случаев рассматриваем, а после этого мы
уже сказали на предыдущем слайде, что если мы рассмотрим там, а каждый из них в отдельности,
то там будут ранги эти вычитаться и все будет хорошо. Вы можете посмотреть.
Вы поменять местами должны Р и В. Чтобы поменять местами, вам нужно потратить единичку
времени. Мы считаем, что на переподвешивание у нас единица времени какая-то уходит. Еще вопросы?
Нет. Теперь смотрите, согласны ли вы с тем, что ранг Р равен рангу В штрих?
А остальные?
Хорошо. Но это является корнем, у него количество элементов внутри ровно такое же,
как и было. Поэтому они вычитаются. Поэтому ранг Р и ранг В штрих, они вычитаются и уходят.
Поэтому это равно 1 плюс ранг Р штрих минус ранг В. Чудненько. А теперь смотрите,
согласны ли вы с тем, что ранг Р штрих меньше, чем ранг В штрих?
Потому что В штрих находится в корне, а Р штрих под ним. То есть В штрих априори находится,
как минимум, на 1 узел больше. Согласны? Поэтому я могу это сделать. У меня получается меньше
либо равно, чем 1 плюс ранг В штрих минус ранг В, но я получил наше равенство. Если я
домножу на 3 ранг В штрих минус ранг В, то у меня ничего не изменится. Я доказал свою первую часть
для Зиг Зига. Поехали дальше. Для Зиг Зига и Зиг Зага. Я постараюсь максимально быстро,
и понятно. Давайте так. Согласны ли вы с тем, что фактическое время здесь это 2? Ой, господи,
две единички времени. Потому что я должен 2 раз переподвести вершинки. Согласны? Отлично.
Подсмотрим на рисуночек и поймем, как меняются ранги у вершин В, П и Ж. На всякий случай альфа,
бета, гамма, дельта они тоже не меняются рангами, я их не пишу дальше. Они сокращаются, нам не
интересно. Ну, мы считаем, что один поворот это одно действие, но они все за 1 работают,
поэтому это быстро. В общем-то, смотрите, давайте вернемся с вами к Зиг Зигу. Во-первых,
у нас делается два простых действия, поэтому у меня ТАИТА, давайте прям расписывать это
по чуть-чуть, я думаю, будет полегче и понятнее. Это в действительности одна из самых таких,
но одна из моих любимых тем, поэтому те, кто ко мне подойдут, могут ее спокойно получить.
Вот, смотрите, у нас есть вот это ТИТ, плюс ФИСИТ, минус ФИСИ-1, вот мы с вами это так
определяли. ТИТ, мы говорим, что оно сейчас равно двум, да? Мы делаем два действия. Теперь смотрите,
что у нас такое ФИСИТ? Альфа, бета, гамма, дельта не меняют свои ранги, мы их не учитываем,
потому что они вычислются друг из друга вот здесь. Понятно? Ну, то есть они в сумме убьют друг
другу. Мы смотрим ФИСИТ. А что там есть, что могло меняться? У нас есть В, П и Ж, вершинки В, П и Ж.
Нужно их и рассматривать. Мы говорим, что ФИСИТ это ранг Ж-плюс ранг В-плюс, какой-то
рандомный последователь не спешу, но ладно, ранг П- и минус ФИСИТ это то же самое, что ранг
получается Ж-плюс ранг В-плюс ранг П. Теперь смотрите, что являлось корнем в первом случае? Вот
после изменения, ой, до изменения давайте так Ж-и, а после П-штык. Согласны, что их можно тогда
сократить, потому что они просто являются корнями, а количество элементов у нас никак не менялось,
поэтому я делаю вот так и вот так. Ага, теперь смотрите следующее. У меня это есть, можете перелеснуть
следующий слайдик. Смотрим, что у нас дальше. Вот там много буквок будет, много именно с точки
зрения того, что там формулки. Мы с вами можем знать, что у нас ранг П-штык, он меньше либо равен,
чем В-штык. Если вы взгляните на предыдущий рисунок, то вы знаете, что П-штык меньше,
чем В-штык. Почему? Потому что В-штык стоит выше. Согласны? Вот, кроме того, ранг П больше либо
равен рангу В. Почему? Потому что ровно так же в предыдущем случае. Я просто это сохраняю,
потому что у меня будет неравенство всегда, мне удобно. Так больше. Ну, если П существует.
То есть, смотрите, вот эта часть, то есть ранг П, он больше либо равен, чем ранг В. А вот этот ранг
П-штык, он меньше либо равен, чем ранг В-штык. Согласны? Так как это здесь стоит со знаком минут,
тогда я могу вот это применить. Тут минус ранг П, минус ранг В. Ранг В будет больше,
минус ранг В. Ну, отрицательное число. Тут если 5, тут 3, то минус 3 выше, чем минус 5. Окей? Это понятно.
Поэтому я могу это подставить. И я с вами получаю, если все это подставляю, что АИТ меньше либо
равно, чем 2, плюс. А там что у меня получается? Плюс ранг В-штык, он вот отсюда пришел.
Плюс ранг В-штык, все верно. Плюс ранг Ж-штык, это вот отсюда. И минус, минус два ранга В.
Ага. Окей? Это понятно. Смотрите, я хочу привести к тому, чтобы у меня было 3 ранга В-штык,
минус 3 ранга В. Как я это могу сделать? Давайте. Ну, там ноль меньше либо равно,
минус 2. Вот я попытаюсь сложить два неравенства. Ноль меньше либо равен минус 2, плюс 2 ранга В-штык,
минус ранг Ж-штык, вот. И минус ранг В. Согласны, если я сложу два этих неравенства, то я получу
нужное мне. Ну, то есть, вот этот же штык, он уйдет. Осталось лишь понять, что делать с этим.
И как с этим жить? На самом деле, жить это просто. Если мы перенесем там, оставим минус два здесь,
вот это все туда перенесем, мы получим ранг Ж-штык, плюс ранг В, минус ранг,
минус два ранга В-штык. Меньше либо равно, чем минус два. Смотрите, здесь дальше происходит
следующая хитрость. Вспоминаем, что такое ранг. Ранг — это логарифм от количества вершин. Согласны?
Получаю, что у меня будет логарифм двоичный от количества вершин, если у нас корень Ж-штык,
плюс логарифм от количества вершин В, минус два логарифма В-штык. Когда у вас вычитаются
логарифмы, что делается с одинаком основанием? Деление. Я получаю с вами двоичный логарифм от
деления СЖ-штык на СВ-штык, плюс логарифм СВ на СВ-штык. Ага. Согласны ли вы с тем,
что мы знаем, что СВ-штык больше либо равен, чем СЖ-штык, плюс СВ? Посмотрите на картинку. СВ-штык
больше либо равен, чем СЖ-штык, плюс СВ. Почему? Потому что, смотрите, в СВ входят альфа, бета и В.
Согласны? В Ж-штык входят гамма, дельта и Ж-штык. А вот в В-штык входят все это, плюс еще П-штык.
Понятно, почему больше либо равно количество элементов. То есть, если я с вами посмотрю на это
все, тогда согласны ли вы с тем... Тогда я применю следующее утверждение. Логарифм двоичный Х плюс
логарифм двоичный У меньше либо равен минус двух, для любых х и у положительных, и х плюс у меньше
единички. Согласны, что х плюс у меньше единички? То есть, СЖ-штык плюс СВ делить на СВ-штык это меньше
единицы, потому что там присутствует как минимум П-штык, В-штык. Ага. Вот тогда мы получили нужное
нам неравенство. Потому что мы вот эти логарифмы там посчитали, все хорошо. Вот это минус два,
но действительно будет правдой. Мы доказали это.
Но здесь нам хватит х плюс у меньше единиц. Но в любом случае у нас будет СЖ-СВ. С чем?
Ну да ладно, в чем проблема? В смысле, нормальная? Все хорошо. Но мы складываем потом два неравенства,
получаем нужное нам. У нас будет ААИТ меньше чем 3 ранга В-штрих минус 3 ранга В. Это понятно? То есть,
вот эту логическую цепочку нужно вам в голове простроить. То есть, на какие штуки смотреть.
Но в общем-то все действительно адекватно здесь. ОК? Точно ОК? Да. Ой, это ЗИК или ЗАГ? ЗИК или ЗАГ
на последнем этапе будет. Теперь поехали дальше. Последний анализ это зигзага. Смотрите, анализ зигзага
аналогичен в начале. Два действия у нас будет простейших. Дальше мы складываем все также ранги
и получаем что у нас будет два плюс ранг П-штрих плюс ранг Ж-штрих минус ранг В минус ранг П. Но я все
так же сократил вот эти корни, потому что у них ранги одинаковые. ОК? Это принято. Теперь поехали
с последний слайд. Смотрите, мы с вами получим что у нас АИТ будет два плюс ранг П-штрих плюс ранг Ж-штрих
минус ранг В минус ранг П. Видимо, мне надо было буковками разными назвать. Ну не знаю, хотя бы
соотношение какое-то. Ой, у меня там оскобочка съехала. Смотрите, мы с вами знаем что ранг П больше
либо равен чем ранг В, но это логично. П-ранг был выше вершинки В в самом начале. Согласны? Значит,
я могу так как там опять с минусом, я могу его оставить у меня будет АИТ меньше либо равно чем два
плюс ранг П-штрих плюс ранг Ж-штрих минус два ранга В. ОК? А теперь смотрите, я буду утверждать,
что в этом случае АИТ меньше либо равно чем два ранга В-штрих минус ранга В. Как мне этого добиться?
Мне этого добиться очень просто. Я ровно такое же вот какое-то неравенство попытаюсь сделать,
чтобы убралось вот это ранг П-штрих и ранг Ж-штрих. То есть мне достаточно будет показать, что ранг Ж-штрих
плюс ранг П-штрих минус два ранга В-штрих меньше либо равно чем минус два. Нет, нет, нет. Здесь будет
ровно в такой же последовательности. Вот когда мы получили это неравенство, вы получили ровно то
же самое с логарифами. Ровно такое же утверждение используете, потому что В-штрих это сейчас корень
моего всего дерева, а в Ж-штрих и П-штрих там уже частички их. Понятно? То есть это будет ровно то
же самое доказать, что было в предыдущем. То есть просто расписать те же самые логарифы. Ну и все,
вы получили эту сумму. Получили, что она меньше либо равно чем вообще два умножить на ранги.
Дальше мы говорим следующее в действительности. В два меньше либо равно чем два, но это то же
самое, что меньше либо равно чем в три. Но если у меня было там какое-то число, то умножу я на три,
и оно точно меньше этого числа. Согласны? Число положительное, поэтому все логично. Это нужно для
того, чтобы мы вычитали эти времена друг с дружки хорошо. Чтобы ранги можно было вычислить друг
с другом. Потому что там где-то три ранга, где-то два, у нас проблемы будут. Когда у нас будет три и
три, мы их просто вычитаем друг с другом. Так вот, последний слайд. Итог. Любой ранг,
он просто ограничен логарифмом. В конце мы получаем с вами то самое доказательство того утверждения,
которое было. Что у нас минус ранг V, минус ранг R, минус ранг V, плюс один. Три ранга. Согласны?
Было такое утверждение в самом начале, которое мы и доказывали сейчас. Три ранга R, минус три ранга
V, плюс один. Нет, плюс единичка появилась у тебя только в зиге или только в заге. Вот. Поэтому это важно.
Так вот, мы с вами получаем этот логарифм, мы это доказали. Ну там просто просуммировать все эти
моменты, мы это в самом начале с вами и сделать. И получается, что функция сплей работает, а
амортизационно за логарифм. А если она работает амортизационно за логарифм, то функция Fine работает
за логарифм, функция Insert работает за логарифм, функция Remove работает за логоифм. И все это работает
амортизационно за логоифм. И это хорошая структура данных, потому что в среднем она будет давать вам
результат ровно такой же, какой должен быть с балансированных деревьев. Но важный момент,
эта структура данных лучше всего подходит в моменты, когда вы берете один и тот же
элемент и ищете, грубо говоря, и он всегда находится где-то высоко. Понятно? Надеюсь,
вы преисполнились этой структурой данных. Надеюсь, вам понравилось. Вы сможете ее реализовать.
Надеюсь, что у меня там сильно много багов в коде нет, по-моему, не особо. Вот. А во всем
остальном хорошего вам вечера. Вот. Удачи. Все. Пока-пока.
