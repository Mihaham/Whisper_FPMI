Всем здрасьте.
Нам сначала нужно доделать суффиксный автомат алгоритм.
Давайте напомню, что мы делали.
Мы говорим, что мы будем строить автомат дописыванием
по одному символу и вот считаем, что для строки
С автомат уже построен.
Мы дописываем новый символ С, следующую буквовку
к нашей строке.
Хотим перестроить автомат.
Мы поняли, что обязательно появляется новый класс,
который отвечает всей строке СС.
Обязательно будет такой новый класс.
И еще потенциальный какой-то один класс возникает.
Давайте напомним, что у нас есть строка С0.
Это максимальный суффикс С, который является по
строкой С.
Так же у нас было, да?
Мы понимаем, что вот это СС будет обязательно новый
класс, обязательно новая вершинка, которая возникает
в нашем автомате.
Без нее никак не обойтись.
А вот эта С0, она, возможно, образует нам новый класс,
возможно, не образует.
Зависит от того, являлась ли вот эта строчка в старом
автомате лонгистом в своем классе.
Если она была лонгист, то ничего не меняется, это
состояние остается неизменным.
Если же она не была лонгистом, но стала лонгистом, тогда
вот это старое состояние расщепляется на два.
Вот если у меня было несколько строк в одном состоянии,
то несколько самых длинных остаются там же, а вот эти
остальные, среди которых самый длинный это С0, они
отщепляются в отдельное состояние, соответственно,
число состояния увеличивается на два, а не на один.
Хорошо, значит, это мы уже делали в прошлый раз.
Также я напомню такой полезный факт, что если у меня есть
какая-то вершинка В, то множество ребер, которые ведут в нее,
устроено следующим образом.
Что, во-первых, на них на всех написана одна и та
же буква.
Давайте не С, давайте какой-нибудь D.
На них на всех написана одна и та же буква, во-первых.
Во-вторых, вот эти вот вершинки – это часть суффиксного
пути.
То есть если посмотреть на самую длину из них, то
суффислка из нее будет вести во вторую по длине, из нее
суффислка ведет в третью по длине, из нее в четвертую
и так далее.
И это вот все все ребра, ведущие в данную вершинку.
Этим мы тоже будем пользоваться.
Хорошо, значит, мы многое уже поняли, и теперь давайте
поймем, как будут меняться ребра при добавлении вот
этого нового символа С.
Мы понимаем, как меняется состояние, либо плюс один,
либо плюс два.
Теперь вопрос, как меняются ребра.
Ну, я утверждаю следующее, что после добавления С, большинство
ребер как бы не изменятся.
Большинство ребер в старом автомате сохранятся.
Ну, понятно, если у меня меняются только два состояния,
то, наверное, просят какие-то изменения только с ними.
Так вот, что может измениться?
Во-первых, понятное дело, должны появиться какие-то
ребра, ведущие в новое состояние С.
Ребра в класс, отвечающие С.
Ну, это понятно, появилась новая вершинка, туда явно
должны вести какие-то ребра.
С одной стороны.
С другой стороны, из этого состояния ребра точно не
будет, потому что там уже лежит самая длинная строка,
если бы было еще какое-то исходящее ребро из нее,
это бы означало, что автомат должен применить какую-то
еще более длинную строчку, чем все С.
Понятно, что такого не бывает, значит, ребер отсюда
точно не исходит.
Дальше, что может появиться или измениться?
Дальше вот эти вот события могут происходить только
в случае, если С0 это новый лонгест, то есть не был
лонгестом, но стал лонгестом.
То есть это в случае, когда у меня какое-то состояние
расщепляется.
Расщепление.
Когда, значит, что может быть?
Вот было какое-то состояние Q, оно распалось на два.
Там какое-то новое Q и клон.
Значит, вот как-то оно расщепилось на два.
Тогда как меняться ребра?
Ну, во-первых, могут поменяться ребра те, которые входили
вот в это, могут теперь перейти в, ну, то есть в одно
из них, надо понять, куда.
Ребра.
Давайте я сразу назову вот эту вот вершинку Q, та
вершина, в которой лежала изначальная С0, которая
расщепляется в этом случае, давайте назовем ее Q.
Так вот, что-то происходит с ребрами в Q.
Ребра в Q.
Надо с ними понять, куда они теперь ведут?
Куда теперь ведут?
Раз это состояние расщепилось, там было какое-то множество
слов, оно расщепилось, понятно, что тогда ребра, какие-то
входящие сюда, должны переместиться сюда, а какие-то входящие
тоже сюда должны переместиться в другую вершинку, поскольку
здесь расщепилось множество слов, то и множество ребер
тоже должно расщепиться. Вот, это входящие ребра в эту вершинку, ну и еще могут быть
какие-то исходящие. То есть надо понять, как ведут себя исходящие ребра из этих двух
новых версий старой Q. Рёбра из Q тоже. Ну скорее откуда теперь?
Откуда теперь? Потому что у меня была старая вершинка, из нее что-то исходило,
а теперь старая вершинка расщепилась на две. Ну тоже надо понять, какие ребра
теперь исходят из этих двух, из этих новых версий старой вершины. Вот, и больше
ничего не изменится в нашем графе, больше никакие ребра не исчезнут, не
появятся и не изменятся, потому что какие у нас остаются не учтенными ребра?
Ну, только те, которые вели между вершинками, между состояниями, которые
не поменялись. Только между состояниями, которые не поменялись, потому что
поменялось только вот эта вот SC появилась и Q могла расщепиться. Больше у нас в
в автомате с точки зрения состояния и множеств слов, которые лежат в одном
состоянии, ничего не поменялось. То есть, если я возьму любую другую вершинку, в
которой было какое-то множество слов, то есть правый контекст, у которых одинаковый,
и вот все они соответствуют одной вершинке, то это состояние не поменялось.
Ну, потому что мы поняли, что меняются только два лонгеса, значит, два
состояния. Поэтому здесь ничего не меняется, и значит, никакие входящие рёбра,
никакие исходящие рёбра, ведущие ни в Q, ни в SC, они поменяться не могли, поэтому
большая часть графа у нас остается. В итоге может меняться только вот эти вот
три потенциальные пункта. Хорошо, давайте тогда разбираться с первым. Какие рёбра
нужно провести в SC? Ну, понятно, что поскольку мы должны провести рёбра в SC, то все
рёбра, которые туда ведут, обязательно на них написана одна и та же буква, это мы уже
замечали. И ну какая это буква? Понятно, что это последняя буква во всех этих словах,
то есть C. Поэтому в этой SC нужно обязательно провести несколько вот таких рёбер, на всех из
которых написан букв КC, и они ещё образуют такой суффиксный путь. Ну, давайте тогда скажем,
что я должен провести ребро из, скажем, строки, чего у нас ещё не было, давайте из строки U,
из строки U я должен провести, точнее вот так, да, из класса, соответственно,
я должен провести ребро по букве C в класс SC. Если, ну если у C это такой суффикс SC,
что у C при этом не под строка S, вот так, не под строка S, потому что мы помним,
класс SC состоит в точности из всех строк, которые получили новое вхождение, вот раньше не входили,
а теперь входят, вот это класс SC, те суффиксы, которые раньше не входили, теперь входят. Поэтому
рёбра, ведущие в этот класс, это обязательно рёбра из таких слов U, что дописывание новой
символа C как раз переводит меня в этот класс, то есть это такой суффикс, что он не является под
строкой S, не является под строкой S. Ну тогда понятно, что незаведомо нужно провести ребро из
класса S, вот такое вот, потому что если есть здесь слово S, то при прописывании к нему буквы C мы как
раз перемешаемся в класс SC. Затем нужно взять от него суфсылку, мы помним, да, что все вот эти
вот рёбра, они обязательно должны образовывать путь по суфсылкам, поэтому я беру суфсылку от этого S,
перехожу сюда, и опять, да, если здесь, скажем, нет ребра по C, то я его строю, опять перехожу по
суфсылке и так далее. Вот, и что значит, что, то есть я так делаю, пока не найду первую вершинку,
из которой есть переход по C. Есть переход по C. Тогда вот для всех вот этих вот, я утверждаю,
что мне нужно эту стрелку перенаправить, то есть создать стрелку по C и перевести ее в SC,
а для этого ее менять не нужно. Вот почему. Значит, пусть это P, пусть это вершинка P. Для всех вот этих,
повторюсь еще раз, для этих вершин не было ребра по C. То есть это такие строки, такие строчки U,
что в исходном автомате, в старом автомате, который отвечает строке S, приписать к строке U букву
C нельзя. То есть после U не может следовать C. Это как раз означает, что U-C было не под строкой S,
но теперь при дописывании C в конец у меня будет U-C, это суффикс SC. И поэтому вот во всех этих
вершинках, где не было ребра исходящего, исходящего ребра по букве C, мне нужно его создать и
переместить сюда. Потому что это как раз будут такие вершинки, которые раньше вот это U-C не
было под строкой S. А теперь станет, поэтому такое ребро нужно завести. Так, ну и здесь давайте сразу
же, давайте я напишу такой маленький код. Давайте я напишу маленький код. Я скажу, что P это класс
соответствующий S, пока, ну скажем, P не равно минус единице и из P нет перехода по C. Мы делаем
следующее. Мы создаем этот переход, говорим, что он ведет в это SC. Я обозначу это так. To P по
букве C равно SC. Ну вот так напишу. И P равно link от P. Скопка закрылась. Стал вот сюда и прыгаю
после ссылки, пока не найду переход по C. И всюду, где не было такого перехода, создаю его в новую
вершинку SC. Теперь, самый простой случай, это когда мы такими вот прыжками дошли до самого корня,
до, ну до, до начальной вершины нашего софт-томата, которая, кустарта. И даже если, и вот хорошо,
если даже из старта нет этого перехода по C. Это соответствует случаю, потому что P стало
равно минус единице, то есть якобы попытался взять ссылку от корня и уже, соответственно, дальше
ничего не делаем. Первый случай. Если из корневой вершины, корневой, то есть стартовой,
нет перехода по C. Это соответствует тому, что P равно минус единице в конце
исполнения этого вала. То есть, я считаю, что я дошел до корня, не нашел у него переход по C и его
построил в SC. Потом взял опять сувсылку и сказал, что у меня P стало равно минус единице. То есть,
сувсылка от корня как бы это минус один. То есть, тогда картинка вот такая. Я провожу такие рёбра,
беру сувсылку, провожу рёбра, беру сувсылку, провожу, провожу, и в конце концов я приду в корень.
Это будет корень начальной вершины автомата. Вот, ну тогда я утверждаю, что S0 это просто
эпсилон. В таком случае S0 это просто эпсилон. С одной стороны, с другой стороны, C не встречалась
в S. Не встречался, да? Наверное, символ C не встречался в S. Ну, когда может быть такое,
что я дошел до корня и даже из корня не было перехода по букве C. Только в случае, если C это
вообще новый символ, которого не было в строке S. Скажем, в S были только Ашки и Бэшки, пришла
новая буква C, ну тогда понятно, что из корня нет перехода по C, потому что его раньше в принципе
не было нигде в автомате, не было в строке, не может быть в автомате. Ну и наоборот, да, если
нет сейчас перехода, то значит, что нигде раньше этой буквы просто не было, иначе бы этот переход
обязательно был бы, потому что у него автомат хранит себя по строке, поэтому все символы точно хранит.
Хорошо, получается, что C это какая-то новая буква, которой раньше вообще не было, ну и так дошли до
корня, ну и тогда что такое S0? Так, я S0 стёр. Напоминаю, это максимальный суффикс СС, который
является по строкой S. Но, извините, я не могу взять никакой нетривиальный суффикс, потому что они
все содержат это последнее C, а С раньше нигде не встречалось, поэтому самую длинную строчку,
которую я могу в качестве S0 взять, это вот эта пустая строка. Самый длинный суффикс, который
является по строкой С, это просто Эпсилон, пустая строка. Ну, а мы ещё в прошлый раз заметили, что
сувсылку мы должны определить так, что сувсылка СС это обязательно класс С0. Ну, потому что как раз
относительно СС, самый длинный его суффикс, который лежит в другом классе, это вот эта вот С0,
поэтому сувсылка ведёт сюда. Значит, мне нужно просто в конце вот этого вот вайла, когда я дошёл
до корня, мне нужно сказать, что сувсылкой вот этой вершинкой будет вот это, то есть просто корень,
и на этом обработка новой символы С закончилась. То есть я целиком построил все ребра сюда. Понятно,
что С0, как было лонгестом, так и осталось лонгестом, оно, собственно, только в корне лежит,
поэтому там ничего не расщепляется, и вот эти вот ребра не меняются. Поэтому на этом как бы
обработка заканчивается. Мы провели все ребра в СС и говорим, что сувсылка у нас теперь ведёт вот
так из СС в корень. Всё, это простой случай разобран. Так, вопросы? Хорошо, значит тогда
случай второй, когда мы вот так вот идём и закончили где-то раньше, чем корень, то есть мы
так шли-шли-шли, по сувсылкам поднимались, или у меня тут на картинке спускались по сувсылкам,
и дошли до какой-то вершинки, из которой есть переход по С. Вот так я давайте это нарисую.
Значит, мы проводили ребра по С2 класс соответствующей СС, и дошли до вершинки,
из которой уже был такой переход по С, который ввёл в какую-то другую вершинку. Давайте я вот это
вот, значит, после нашего цикла, вот это будет как раз П. П — это последняя вершина,
точнее первая найденная вершина, из которой есть переход по С. Первая найденная, из которой есть
переход по С. Хорошо, значит вот мы её нашли. Тогда я утверждаю, что вот это как раз будет
состояние Q, в котором лежит С0. Вот это будет такое состояние Q, в котором лежит С0, тот самый
максимальный суффикс, который является по строкой С. Ну, вроде понятно, потому что как у меня
устроены вообще все суффиксы строки СС? Это обязательно нужно взять какой-то из суффиксов
исходной строки, которая получается по вот этим вот сувсылкам. Вот это вот было С, да? Как
получается все суффиксы строки С? Это нужно встать в С и прыгать по суффиксам. Тогда как раз здесь,
на этом пути, будут все суффиксы. Это мы тоже обсуждали. Тут будут все суффиксы. Значит,
как может быть устроена С0? Это обязательно встать куда-то вот сюда, в одну из этих вершин и
приписать С, потому что С0 это вот такая какая-то штука. Какой-то кусочек старого суффикса с приписанием
С. То есть я должен встать куда-то сюда и пройти по букве С. Но из этих вершин я пройти по букве С не
мог, а из этой уже могу. Ну, значит, тогда понятно, что самая длинная строка вот этой вот С0, это как
раз самая длинная строка СП, то есть лонгест от П, плюс С. Значит, С0 равно лонгест от П плюс С. Самый
длинный суффикс, к которому можно приписать С. Он обязательно вот здесь. Просто есть такое ребро.
Поэтому я напишу так. С0 лежит вот в этом состоянии Q. Принадлежит классу эквивалентности строк,
в которой все схлопаются. Вот. И здесь может возникнуть потребность это Q расщепить. Это Q расщепить
в случае, если С0 не было лонгестом. То есть мы понимали, что оно не было лонгестом, теперь оно
обязательно лонгест. И мне потенциально это нужно расщепить. Давайте рассмотрим хорошую ситуацию,
когда не нужно расщеплять. Когда это не нужно делать? Нам не нужно расщеплять Q,
если и только если С0 уже была лонгестом. То есть С0 было равно лонгест от Q. Ну и это,
с точки зрения чего-то, что можно проверить за вот однице, равносильно такому условию.
Лен от Q равно лен от P плюс 1. Мы напоминаем, мы вот эти лонгесты явным образом не храним,
потому что если их хранить, то тогда у меня будет квадратичная память. Я храню только лен,
только длины этих самых лонгестов. Ну и понятно, что вот эта вот С0, которая получается приписыванием
вот сюда буквы С, она будет лонгестом здесь, если и только если выполняется вот такое соотношение
на длины наших состояний. Что длина максимальной строки вот здесь ровно на 1 больше, чем вот здесь.
Лен от Q равно лен от P плюс 1. Ну потому что С0, это как раз взять вот эту вот строчку длины лен от
P, приписать к ней один символ, и мы как раз поводим в Q. И если это самая длинная строка,
то собственно вот это равенство должно выполняться. Поэтому второй случай, это как раз случай вот
этого равенства, когда лен от Q равно лен от P плюс 1. То есть С0 была уже лонгестом, ничего расщеплять
не нужно, и мой автомат больше не меняется, у него состояние не меняется. Тогда как нужно это обработать?
Очень просто. Я утверждаю, что в таком случае нужно просто сказать, что линк вот этого С,
это просто Q, и на этом закончить. То есть мы сначала вот так вот пропрыгали из вот этого
S по субсылкам, провели такие ребра по букве С в СС, а затем дошли до первой вершинки P,
с которой уже был переход по С, и пусть выполняется в такой условии. Тогда достаточно просто назначить
такую субсылку, и случай целиком разобран. Вот. Ну почему? Почему это так? Мы поняли, что это
состояние не меняется, поэтому ребра, входящие в него и исходящие из него, никак не поменяются,
это старое состояние, которое не помнялось, поэтому с ним все остается так, как было.
Вот, поэтому ребра, которые могут поменяться, появиться, удалиться или измениться, это только
ребра ведущие в СС, которых раньше не было, которые теперь появляются. Ну такие вот я провел, а
işte ребра, исходящие отсюда, уже было ребро по С, и оно именно что должно вести сюда, а не в СС.
да и вообще какие еще могут быть ребра какие еще ребра могут мы потенциально не
провели ну вспоминаем какие ребра нужно провести в эсце это такие суффиксы с такие суффиксы с
что дописаны к ним буковки ц перестает быть суффиксом с быть под строкой с давайте давайте
еще восстановлю это давайте восстановим что я провожу ребро из у в эсце если у меня у ц это
не под строка с да не под строка с но еще у это суффикс с это вот у меня было здесь написано я
просто восстанавливаем у суффикс с ну все суффиксы лежат в этом пути по ссылкам и теперь мне
нужно получается найти только те из них из которых не было перехода по букве ц потому что у ц должно
быть не под строкой то есть просто не могло быть там перехода по ц все такие я нашел здесь уже
сувсылки многократно тоже будет переход по ц потому что если вот отсюда есть переход по ц значит
и у более коротких строк их тоже можно продолжить этой буквой ц да потому что например тут была
какая строка вот этой вот лонгестат п и мы знаем что лонгестат п плюс ц это под строка с что лежит
здесь здесь как какой-то вот это вот суффикс вот этой строки к нему понятное дело тоже можно
Здесь лежит какой-то суффикс, вот это строки, к нему, понятное дело, тоже можно приписать С.
Потому что если вот это под строка, то это тем более под строка С.
Ну и так далее. Когда мы проходимся по этому суффиксному пути, у меня эта строка всё уменьшается и уменьшается,
тогда понятно, что всё это время можно её продлить С, и это всё будет под строка С.
Поэтому все вот эти вот ребра, из них уже был переход по С, поэтому его не нужно менять.
Нужно менять только те, которых не было.
А эти не изменятся.
В итоге автомат не поменяется, кроме вот этих ребр.
Остаётся только назначить суффсылку, ну а мы уже неоднократно замечали, что суффсылка из СС должна вести в С0.
Ну а С0 это как раз вот это ку.
Хорошо.
Тогда последний случай, который нам остаётся, это плохой случай.
То есть, во-первых, из П есть переход по С в вершину ку.
Но при этом вот эта равенство не выполняется.
Ну я могу написать просто «неравно», могу написать «строго больше».
Это будет одно и то же.
Понятно, что здесь неравенство, вот такое неравенство всегда выполняется,
что лен от ку всегда больше равной лен от П плюс один.
Потому что, если вот здесь есть какая-то строка длины лен от П, то строка длины на один больше точно здесь лежит.
Поэтому здесь максимальная будет больше равной, чем вот это.
Здесь не может быть значка меньше, может быть только больше, если не равенство.
Так, окей.
Что же тогда происходит?
Это как раз случай, когда ку нужно расщепить.
Ку нужно расщепить.
Давайте я нарисую следующую картинку.
Вот была ку, там был какой-то лонгест.
И несколько его самых длинных суффиксов.
Такая картинка, такая картинка.
Так, сейчас я буду рисовать довольно долго.
Ну вот что-то такое.
Мы поняли, что s0 это не самое длинное из них.
То есть скажем, ну вот это вот какое-нибудь s0.
Давайте скажем, что вот это вот это s0.
Так, и как оно получается?
Оно получается переходом из p по букве c.
Но здесь вместе с этим s0 в состоянии p могли же идти еще другие строки.
Ну там давайте их несколько нарисуем.
Вот это вот там и вот это, например.
Что мы должны сделать?
Мы понимаем, что у меня теперь s0 становится новым лонгестом.
Значит мне нужно вот это ку вот здесь расщепить по вот этой линии.
Эта строка как была лонгестом, так и осталась.
Мы помним, что лонгест у нас сохраняются.
То есть если когда-то лонгест, то всегда лонгест.
И просто вот эта строка становится новым лонгестом.
Тогда расщепление происходит именно по этой линии.
s0 стало новым лонгестом.
Новой самой длинной строкой для всех более коротких.
Ну а все, которые более длинные, остаются там с этим лонгестом от ку.
В итоге у меня будет два состояния.
Давайте я это состояние оставлю, буду называть ку.
А это состояние я назову клон.
вот прям клон Q, потому что она будет очень похожа на Q. В ней практически все
будет совпадать с с кушкой. Так, это вот случай расщепления. Тогда вспоминаем, как
может поменяться мой граф, какие у меня могут появиться или измениться ребра.
Во-первых, какие-то ребра, ведущие вот в это вот старое Q, могли перенаправиться
и теперь вести в клон. То есть какие-то ребра, ведущие сюда, остаются вести вот
в это Q старое, а какие-то должны переместиться вот сюда. То есть это первое,
какие-то ребра отсюда должны начать вести вот сюда. Во-вторых, нужно понять, какие
ребра из них исходят, из нового Q, из нового клон, и сообразить, как здесь
определяется всылка. Это мы все сейчас сделаем.
Так, ну первый шаг, самый простой, это как ведут себя ребра, ведущие в исходное Q.
Значит, вспоминаем, как ведут себя вообще ребра в автомате, которые ведут в какую-то
вершинку. Это часть суффиксного пути, и на всех стрелках написано одно и то же.
Мы понимаем, что вот это вот P, это самое длинное состояние, ведущее вот это S0.
Соответственно, там от него сувсылка тоже вела куда-то вот сюда. Ну скажем, не знаю, там было,
например, одно слово, вот это вот. И еще, когда мы берем сувсылку, тоже есть переход по
букве C, которая соответствует этим двум последним словам. Раз, два. Но также этот суффиксный
путь можно продолжить как бы вот в сторону более длинных строк. Это будет соответствовать вот
этому вот начальному отрезку, который остается в том же самом состоянии Q.
То есть тут еще было какое-то предначало. Вот такое начало, да, еще там какие-то более длинные
строки, которые тоже переходят по символу C в состоянии Q. Вот такой получается весь кусочек пути,
которые описывают все ребра, ведущие в Q. Тогда я утверждаю, что вот эти вот вершинки, которые
лежат выше, чем P, соответствуют более длинным состояниям, у них ничего не изменится. Они по
прежнему будут вести вот сюда. Ну потому что понятно, что я из Q вот это вот как бы отсек,
более короткие строки, начиная с 0 и вниз, я их отсек. Тогда понятно, что вот эти вот ребра,
которые соответствуют более длинным строчкам, они не изменятся. Потому что скажем вот здесь,
вот эта строка переходила вот в это. Ну значит это ребро и сохранится, да, то есть оно не задействует
нижнюю половинку. То же самое, если были там еще какие-то строчки, они все вели обязательно вот
сюда. И поэтому нижнюю часть они как бы не задевают, их можно вообще гноевировать. Все вот эти вот строчки,
которые длиннее, чем P и ведут в Q, я их оставляю. Ну давайте я напишу букву А. Ребра из вершин
с лен больше, чем, наверное, P, ведущие в Q не изменяются. Ну я тут постарался объяснить,
да, что вот еще есть какие-то ребра, ведущие в Q, которые, ну сувсылка от которых равна P или там
несколько раз взять сувсылку, получишь AP. Тогда они остаются, вот эти стрелки остаются, потому что
они ведут вот в этом множество. С ними понятно, их не трогаем. Но есть вот эти вот какие-то,
да, от которых раньше мы вели в Q, а теперь, понятное дело, нужно вести в клон. Потому что отсюда мы
раньше вели в Q, но вот в эту вот строчку S0. И теперь эта строчка S0, она уже будет лежать в этом клоне.
Поэтому все вот эти вот ребра нужно перенести вот сюда. Потому что эти ребра ведут все во все более
и более короткие строчки. И поэтому, понятное дело, что они теперь в новом состоянии клон лежат,
поэтому нужно эти ребра перевести туда. Давайте я напишу такой цикл. Опять, пока мы не дойдем до упора,
и пока переход из P по букве C равен Q, ведет в Q, мы его перенаправляем. Мы говорим, что tool PC
это клон. P равно link от P. Это как раз соответствует тому, что мы проходимся по всем с усылком P,
и те стрелочки, которые вели раньше в Q, мы перенаправляем в клона. И там в какой-то момент
мы дойдем до вершин, которые изначально вели в другое состояние, собственно их мы там оставляем.
То есть, если есть ребра отсюда-сюда, в другое состояние, отличное от Q, то мы его оставляем на
месте, потому что это неизменившийся состояние, их не нужно менять. Меняются только те, которые вели
в Q. Да, вот мы их, собственно, перенаправили в клон. Так, это сделали. Это мы разобрались с ребрами,
ведущими в изначальное Q. Какие-то остались на месте, какие-то переместились в клона. Хорошо. Теперь я хочу
понять, как ведут себя ребра, наоборот, исходящие из Q и из клона. Давайте пункт B. Ребра исходящие
из Q и из клона. Так, ну для этого давайте заметим следующее, что правый контекст в новой строке SC для
состояния клон отличается от правого контекста в строке SC состояния Q добавлением пустой строки.
Причем оно добавляется дизъюнтно. То есть, раньше его, то есть, здесь нету эпсилон, мы вот насильно
добавляем, получаем R от клона. Так, ну почему это так? Почему это так? Нам нужно просто понять,
как отличаются множество вхождений в SC вот этих строк и вот этих строк. То есть, вот эти строчки,
как бы, были какие-то вхождения там, они остаются, а здесь тоже какие вхождения у вот этих строк в
нашу строчку SC. Ну смотрите, понятно, что вот этот вот лонгест от Q, лонгест от Q, оно не получило
нового вхождения в SC, потому что это раньше была какая-то по строка S, и теперь она не соответствует
никакому суффиксу SC, потому что суффиксы SC, они, ну вот там, сначала была сама строка SC, потом
будет идти сюда. То есть, лонгест от Q это точно не суффикс SC. Лонгест от Q это не суффикс SC,
поэтому, на самом деле, правый контекст не изменился. Не так. Скорее, множество вхождений Q в SC не
изменилось. Множество вхождений лонгест от Q в SC совпадает с множеством вхождений в S.
Совпадает с множеством вхождений S, потому что была какая-то строка, да, она не получила
нового вхождения, значит, у нее просто никак не поменялось множество вхождений. Что было,
то и осталось. А что получается у S0, у этой строки лонгест от клон? Какое у нее вхождение? Ну,
а у нее как раз появилось новое вхождение, потому что S0 это максимальный суффикс SC. То есть,
сейчас только что при дописывании к S символа С, у меня появилось новое вхождение S0. То есть,
раньше его не было, теперь появилось. А у S0 появилось одно новое вхождение. Появилось
одно новое вхождение. Ну и тогда как раз получается вот это вот соотношение, что правый контекст клона
отличается от правого контекста Q только добавлением эпсилона. Потому что, давайте еще что-нибудь
нарисую, да, вот везде, где у меня встречался лонгест от Q, у меня там же встречался S0 в исходной
строке. Они раньше были в одном состоянии, потому что S0 лежало просто в состоянии Q,
поэтому они встречались в одном и том же множестве мест. А теперь у меня появилось новое вхождение
S0, которое заканчивается вот этим символом С, да, концом строки. И больше вот это вот это уже не
не лонгест от Q. То есть, просто отличается у них множество вхождений только вот этим вот последним
вот вхождением S0. Значит, просто правый контекст отличается тем, что вот здесь эпсилона нету,
а здесь есть. Эпсилон это напоминает, что как раз строка заканчивается в конце строки,
является суффиксом. Вопрос есть?
Хорошо. Так, это мы доказали. Вот, да, значит, тогда на самом деле у меня вообще чем отличаются
эти две строчки? Они отличаются только тем, что вот это вот терминальное, а это не терминальное.
У них правый контекст отличается только тем, что здесь, в этой вишенке, эпсилон есть, то есть эта
вишенка терминальная является суффиксом, а это не является суффиксом, она не терминальная. А значит,
множество исходящих ребер у них будет одно и то же, и они будут вести в одни и те же позиции.
Значит, из этого соотношения мы получаем, что клон отличается от Q в плане исходящих ребер
только тем, что клон терминальная, а Q нет.
Потому что, по сути, у этих двух состояний, у Q и у клона одинаковый правый контекст,
если не учитывать пустую строчку. То есть, если я из определения правого контекста выкидываю
эпсилон, запрещаю дописывать пустую строчку, то у них, по идее, одинаковый правый контекст. То есть,
по сути, это практически все еще одно и то же состояние, только что такое правый контекст?
Способы отсюда добраться до терминальной. Что можно дописать так, чтобы попасть в терминальную?
Поэтому это почти что одно и то же, только одна из них терминальная, другая нет.
Значит, множество исходящих ребер и то, куда они ведут, будет точно таким же. Потому что,
как бы, именно правый контекст, это множество путей, множество способов попасть до терминальной
вершины. Что можно дописать справа, чтобы попасть в терминальную? Но если они одинаковые,
за исключением того, что здесь есть эпсилон, а здесь нету, то тогда и все стрелки, нет смысла никак
менять. Они будут вести в те же, то есть, стрелки отсюда будут вести туда же, откуда эти вот стрелки
там иску. То есть, если это был как символ по Е, то здесь тоже стрелка по Е будет вести в ту же вершинку.
Значит, в итоге все, просто все ребра, которые были иску, мы копируем и делаем их ребрами из
клона. И это целиком описывает все ребра, исходящие из клона. В итоге, давайте я вот так скажу,
что ту от клон просто равно ту от ку. То есть, я целиком все, что было здесь, копировал вот сюда.
Все исходящие ребра из клона я перекопировал, все исходящие из ку я перекопировал в клона.
Все. Окей? Окей. Так, ну и на это мы разобрались вот с этими ребрами исходящими из клона. То есть,
мы поняли, что отличие только в том, что одна терминальная и другая нет. Значит, но что исходящих
должно быть одинаково. Все, это мы тоже сделали. И в текущий момент мы уже написали, как меняются
все ребра. Как меняются ребра входящие в ку и как меняются ребра теперь исходящие из ку из клона.
То есть, просто все, что было в ку, мы копируем в клон. Тогда последнее, что нужно сделать, это
простая всякие вот эти вот лены, линки и так далее. Ну, во-первых, что такое лен от клона? Это лен П плюс
один. Это лен П плюс один, потому что здесь самая длинная строка является С0, которая как раз
получается приписыванием клон Бисту от П, символом С. Поэтому лен от клона на один больше, чем лен от П.
Дальше. Что такое линк от клона? Линк от клона, я утверждаю, линк от ку. Раньше у меня было как-то
определено линк от ку. Оно вело вот в эту вот строчку, следующую за вот этой вот самой короткой.
То есть, я откусываю так по одному символу, пока не поведу в новое состояние. Теперь смотрите,
у меня это состояние расщепилось. Тогда как у меня поменялись линки? Ну, линка отсюда должна вести
вот сюда, потому что они в разных состояниях. А линка отсюда должна вести вот сюда. Ну, давайте
вот я ей скажу, что линк от клона. Вот эта стрелка будет вести сюда, а вот эта стрелка будет вести сюда.
Равно клон. Так, ну и последнее, не забываем сказать, что линк от СС, от класса СС, равно клон. Потому
что это как раз то самое, где лежит С0. И мне нужно линк отправить отсюда сюда.
Вроде все. Мы, кажется, посчитали все, что нужно. Все линки, лены для всех изменившихся вершинок мы
посчитали. Так, окей. На самом деле, алгоритм на этом закончился. То есть, мы разобрали все три случая,
во всех них сказали, что делать. Вроде блесны нас доказали. Давайте тогда пять минут перерыв,
докажем асимпротику и пойдем дальше. Ну что, давайте продолжать. Все, мы построили алгоритм,
доказали его корректность в тех местах, где это нужно было. Давайте формулируем следующую
теорему, которую оставим без доказательства. Это про максимальное число вершин и максимальное
число ребер в автомате, построенном по строке длины n. Так вот, в суффиксном автомате,
построенном по строке длины n, не больше, чем 2 и минус одна вершина и не больше,
чем 3 и минус 4 ребер. Ну если n там достаточно большое. Я напишу так при n, больше оно, чем n0,
потому что точно границу не помню. Ну то есть там для маленьких n наблюдаются какие-нибудь другие
эффекты. Например, если n равно единице, то это число вообще отрицательно. Понятно, что число ребер
не может быть отрицательным. Ну вот, начиная с какого-то момента, порядок, то есть верхняя оценка на
число, оно вот именно такое, что 2n вершин и 3n ребер, ну еще минус константа. Вот, вообще говоря,
это про ребра как минимум, это не очень очевидно, потому что вот здесь тонкий момент такой, что когда
мы ребра, исходящие из Q, перекопируем в ребра, исходящие из Q1, мы как бы там нужно учитывать,
сколько раз мы вот эти вот ребра копируем. То есть мы как бы ребра раздваиваем, и тем самым меня может
как бы сильно увеличиться это количество. Если их там было 10 штук, то станет 20. И вот этот скачок
нужно как-то аккуратно понимать, сколько именно ребер мы копируем. В худшем случае, там вообще может
быть вплоть до размера алфавита, если все возможные исходящие ребра были из Q, то в клон
все эти ребра нужно скопировать. Поэтому скачки могут быть довольно резкими. Ну вот, суммарно
амортизировано, вы в среднем максимум 3 ребра добавляете. Ну а это там задачка на семинар, если не
разбирали, то попросить семинаристов это несложно. Ну здесь имеется ввиду при всех n, начиная с
некоторого. То есть существует такое н, что ли, а, а, а. Вот. Хорошо, ну и тогда вот с использованием этой
теоремки, которая отдельно доказывается, и на самом деле как бы не обязательно базируется на наш
алгоритм, просто можно как бы безотносительно того, как мы строим софтомат, доказать, что в софтомате
максимум столько вершины, максимум столько ребер. Так вот, используя эту теоремку, мы сейчас
докажем асимптотику нашего алгоритма. Асимптотика алгоритма. Ну здесь либо от n, если вы считаете
алфавит константным, либо скажем o на лог сигму или o, sorry, o, n на лог сигма или просто n сигма,
если у вас алфавит не константный. Если вы считаете, что алфавит константный, то есть, как мы любим,
да, маленькие латинские буквы, тогда можно просто говорить, что от n. Либо же, если у вас алфавит
может быть довольно большой, скажем там, ну, в сентуральные числа, тогда нужно немножко аккуратнее
быть, так же, как у нас в Боре, собственно, было. Мы либо в каждой вершинке храним, ну не в
сентуральных числах, числа, не знаю, от 1 до 1000. Тогда нам нужно либо в каждой вершинке хранить
массив длины 1000, чтобы знать, есть ли ребро с таким, ну, по такой букве, либо хранить там какую-нибудь
структуру данных, которая по каждой букве может определять, есть ли такое ребро, есть ли есть,
куда оно ведет. Короче, здесь, как обычно, будет n на лог сигму или n на сигму. Иначе, если сигма не
константа. Вот. Ну, либо аккуратно написать хэш таблицу, тогда тоже асинкротика будет, вроде
будет у от n, но если не хочется писать хэш таблицу, то можно с помощью std map сделать логарифом или
просто с помощью массива сделать n на сигму. Тоже это там обычно сойдет. Почему? Почему это так? Ну,
вот сейчас сделаем. Нужно пройти по всему алгоритму и понять, как бы какие его куски у меня не учтены
в вот этих вот, скажем, вершинах или в ребрах. Значит, смотрите, давайте еще раз овервью всего
алгоритма. Во-первых, мы на каждом шаге добавляем максимум две вершинки, одну точно, и проводим в нее
вот такие вот ребра. И там по какому-то пути из там старой максимальной вершинки s. Проводим такие
ребра. Ну, время работы вот этой вот этой итерации, да, то есть проведение ребер, которых раньше не
было, оно вот здесь будет учтено. Потому что каждая такая итерация, она заведомо нам добавляет
новое ребро. Значит, суммарно, таких шагов будет максимум 3n-4. Это у от n. Такие шаги у нас учтены.
Дальше. Если я завершился в корне и даже из корни не было перехода по c, то все, дальше алгоритм
ничего не делает. Иначе, вот мы так прошлись, дошли до p, нашли переход по букве c в какое-то
состояние q. Если ленод q, это ленод p плюс 1, то тоже ничего не происходит. Мы просто говорим,
что всылка отсюда ведет вот сюда, и на этом тоже шаг алгоритма заканчивается. Самое сложное,
только возникает в третьем случае, когда q расшепляется. Да, у меня из вот такой картинки,
получается какая-то такая картинка. Остается где-то там q в небесах, и у нее возникает копия клон,
ребра, и дальше ребра ведут себя так. Все, которые показывали раньше в q и были на пути
по всылкам xp, то есть все такие ребра перенаправляются в клон. Если было такое ребро,
то оно теперь ведет сюда. Если было такое ребро, то оно теперь ведет сюда, ну и так далее. То есть все
вот эти ребра я перенаправляю. И вот это у меня уже не учитывается в количестве проведенных ребер,
потому что они и так были учтены, а теперь их просто поменял. То есть я не могу сказать,
что я суммарно все это делал за 3 и на 4, потому что они уже когда-то учтены, а я их меняю.
Поэтому здесь нужно как-то более тонко это проанализировать. Мы сделаем следующее. Мы поймем,
как выглядит вообще путь по всылкам из максимальной вершинки. То есть вот было раньше у нас где-то s,
была у него всылка. У него всылка, у него всылка, и так до корни. Теперь появилась новая вершинка
s, тоже у нее есть какая-то суфсылка, которая как раз равна клону в нашем сложном случае. У него
суфсылка, у него суфсылка, ну и в конце придет тоже корень. Так, у меня какая-то картинка,
интересная получилась. В общем, я утверждаю, что на вот этом суфиксном пути число вершин,
оно тем меньше, чем больше ребер мы вот так вот перенаправили. Ну а именно, мы понимаем,
как ведут себя стрелки. Несколько самых верхних вершин имеют стрелку сюда, потом несколько имеют
стрелку сюда, несколько сюда и так далее и так далее. То есть по сути весь вот этот вот старый
мой путь развивается на такие кусочки. Давайте я здесь многоточие нарисую, как-то не интересно
получилось. Весь старый путь развивается на кусочки, так что внутри каждого кусочка ребра ведут в одну и ту
же вершинку. Вот эти ведут в s, эти в клон, эти там вот сюда, эти туда и так далее. Ну и тогда понятно,
что время работы, за сколько работало вот то перенаправление ребер, которые вели в ку, теперь ведут
в клон. Это время пропорционально просто размеры у этого блока. Время вот этой итерации пропорционально
размеры у этого блока. Те ребра, которые теперь ведут в клон. Но тогда смотрите, если здесь было
много вершин, для которых мне потребовалось перенаправлять эти ребра в клон, тогда каждое такое
действие у меня как бы уменьшает количество вершин вот в этом пути. Потому что чем больше здесь
было вершин, тем больше они схлопнут здесь. Значит на этом пути будет меньше вершин. В итоге я хочу
сказать следующее, что если на этом шаге у меня было, хотя бы k вершин перенаправлялись, из них
ребра стали вести в клон, то и здесь всего было скажем m вершин, то вот на этом пути вершин не
больше, чем что-то в стиле m плюс 1 минус k. Ну или там m плюс 2, сейчас я пойму. Нет, вроде просто
m плюс 1, потому что у нас появляется новая страница, из этого плюс 1, а вот эти вот все,
ну это ладно, давайте плюс 2 на всякий случай напишем, то есть появляется новая c, а затем все вот
эти вот k вот этих штучек склеиваются в одну вершинку клон. Получается плюс 1 минус k, вот как раз
плюс 1 минус k. Ну и тогда понятно, что чем больше здесь было k, тем меньше станет вершин на вот этом
следующем суффиксном пути. И тогда на следующем шаге, когда я буду переходить от s c к s c и
следующая буква, у меня опять, если я долго буду работать, то у меня уменьшится количество вершин на
вот этом суффиксном пути. Ну и тогда понятно, что поскольку у меня на каждом шаге вот эта вот
длина увеличивается максимум на 2 за счет двух новых вершинок, и каждая итерация цикла уменьшает
мне эту длину хотя бы на единицу, то таких итераций цикла будет максимум отn. Понятно? Ну значит,
суммарно, вот этих вот перенаправлений тоже будет отn. В итоге, перенаправление рёбер
тоже будет отn. Ну и всё, тогда мы доказали всё, что нужно. То есть, во-первых, рёбер,
который мы проводим, их линейное количество, и перенаправление тоже линейное, и вершин,
которые мы создаём, тоже линейные. Поэтому нужная симпотика доказана. Помодлю вот этот
теориям. Так, ну хорошо, теперь давайте напишем целиком этот код, на всякий случай. Вот, и наверное
пойдём дальше. Я считаю, что у меня у каждой вершинки есть параметры link и множество
переходов to. Множество переходов to для каждой вершинки, по каждой букве у меня есть там либо
минус один, если перехода нету, либо номер вершинки, куда ведёт это ребро. Ещё давайте я буду
хранить переменную last, которая отвечает вот этой штуке. Отвечает самому длинному суффиксу,
построенному на текущий момент. То есть, самая вот эта последняя вершинка. Изначально last это вот
это, потом last нужно будет переносить вот сюда. Я пишу код, который не претендует на хороший,
хороший стиль оформления, но я скорее хочу, чтобы это было написано просто на доске. Итак,
как добавить новый символ к нашей строчке? Во-первых, нужно обязательно завести новое
состояние. Давайте считать, что... Не так я хочу сделать. Сорри, давайте я немножко поменяю.
Напишу, как я привык. Давайте считать, что вот это на самом деле поля у какой-то структуры,
то есть у меня есть структ ноде, структуры вершинки, и в каждой вершинке хранится длина link,
tu и там еще что-то, если нужно. А все вершинки я буду хранить в векторе. Вектор t будет хранить
все вершинки. И изначально там лежит, значит изначально где-то в main я добавлю туда корень,
который отвечает просто пустой вершине, стартовой вершинке pushback node. Вот так. То есть изначально
в автомате просто лежит одна вершина, которая ничему не соответствует. Теперь добавление символа,
add c. Сначала нужно завести новую вершинку, новое состояние, и добавить ее в конец нашего
нашего списка. Я сделаю t pushback ноде, добавляю туда свежую вершинку, и создаю новую переменную
cur для удобства, которая будет как раз на нее показывать. То есть переменная, которая равна номеру
этой вершинки. Ну вот так, например. Это просто номер той вершины, которую мы только что добавили.
Дальше p равно last и делаем вот тот самый цикл в поисках первого ребра, исходящего по букве c.
Пока p не равно минус 1, и t, p, tu, c не равно тоже минус 1. То есть пока из состояния с
номером p есть переход по букве c, я его направляю в cur. tp.tu.c равно cur. Это символ,
который мы добавляем к нашей строке s. И переходим к сусылке. p равно t, p, link. Так,
первый вал закончился. Мы провели все ребра. Это начало первого случая. Мы проводим все ребра,
которые ведут в наше новое состояние cur, в которое соответствует sc. Что дальше? Дальше,
первый случай. Если мы дошли до корня, то есть если в конце этого вала p стало равно минус 1,
то есть я дошел до корня, и даже из корня не было перехода по c, то я опять сделал сусылку,
перешел как бы в неволидный минус 1. В случае p равно минус 1. Тогда мы помним,
что нужно сделать. Нужно сказать, что сусылка для cur – это просто корень. t, cur, link равно 0.
0 – это вот та самая корневая стартовая вершинка. Это соответствует случаю, когда c впервые вообще в
строке появляется. То есть раньше буквы c нигде не было, а теперь это ее первое хождение. Тогда
сусылка от вот этого суффикса должна вести в пустую строчку. Ну и в самом конце не забываем
сделать last равно cur и return. Я до удобства пишу вот так. То есть этот первый случай целиком
закончен, из функции можно выйти и сказать, что теперь last – это cur. Напомню, last – это вот тот
самый указатель на последнюю вершинку. Раньше он соответствовал sке, теперь он будет соответствовать
sc. Вот как раз last равно cur нужно не забыть сделать. Это первый случай был. Теперь второй случай,
когда это не выполняется. То есть мы дошли до вершинки, из которой есть переход по p. Тогда давайте
скажем, что это переход, sorry, есть переход по c, извините. Мы дошли до вершинки p, из которой есть
переход по bqc. Давайте скажем, что он ведет в cu. То есть cu равно tpt.tu.c. Ладно, наверное 25 строк
это я погорячился, но в общем порядок правильный. Ведет в cu. Второй случай – это когда длина вот
здесь, вот на 1 больше длина вот здесь. Пишем, если tqt.len равно tpt.len плюс 1. Это второй случай.
Тогда, но мы тоже уже все описали, нужно сказать, что сувсылка от cur ведет в cu.
И вроде и все. То есть мы понимаем, что ничего не расшепляется. s0 – это как раз
longest в cu. Сувсылка – правильно. Ничего делать больше не нужно. Не забываем last равно cur и return.
Нет, так там не минус 1. Ой, извините, здесь опечатка, здесь равенство, конечно, извините.
Вот здесь было не равенство, здесь должно быть, конечно, равенство. То есть я так делаю, пока
нет перехода по c. Да, извините, это я описал. Я вот это вот ребро создаю, если его не было.
Соответственно, выход из цикла – это либо доход до несуществующей вершинки, либо до вершинки,
из которой этот переход был. А если он был, то я говорю, что cu – это как раз то, что нужно. Да,
спасибо. Ну, остался третий случай. Третий случай, когда все плохо. Тогда мне нужно завести новую
вершинку clon. Создаем t pushback node. Говорим, что ее номер равен clon. Ну и дальше аккуратненько,
давайте мы также в том же порядке. Сначала проведем ребра, которые должны вести в clon.
Напоминаю, я стою в p, должен брать в несу ссылки, и все ребра, ведущие в clon,
должны перенаправить в clon. Ведущие в cu должны перенаправить в clon. Пока p не минус 1 и tp,
tp, tc равно cu. Все ребра, ведущие в cu, я должен перенаправить в clon. tp, tc равно clon. И поднимаюсь
по су ссылке. Вроде это кусок воды у нас уже был. Все ребра, ведущие в cu, перенаправляю в clon.
Это пункт A у нас был, пункт B. Нужно все ребра, ведущие из cu, перекопировать в clon. Напишу так,
tclon.tu равно tcu.tu. Ну подразумеваю, что так можно делать. Если тут есть какой-нибудь вектор,
да, там вектор размера sigma, тогда я могу просто скопировать все, что здесь вот сюда. Ну и третье
это все вот эти поля link, len и так далее. Это я просто переписываю то, что уже было написано.
Значит tclon len равно, так, ну давайте я это напишу, но это будет неверно, сейчас мы это исправим
быстренько. Мы понимаем, что len от clon, len от p плюс 1, только это нужно было сделать до вот этого
while, да, потому что в этом while мы уже взяли p и там несколько раз ее поменяли, взяли су ссылку
многократно, поэтому p изменилась. Это будет корректно только до вот этого, до вот этого while.
То есть это нельзя делать до присвоения len. Есть. Теперь с линками. Во-первых,
link от clon. Это то, что изначально было в link от cu. t от cu.link это clon и t от cur.link это тоже clon.
Мы тоже уже писали. Ну и чего? И вроде мы все присвоили. То есть мы присвоили len, мы присвоили
t, мы присвоили link. И теперь для вершина cu и cur мы тоже обновили линки. Все, больше делать
ничего не нужно. Не забываем еще в конце написать last равно cur. Last равно cur, потому что мы завершили
наш третий случай. Вот вроде все. Вот только эту одну достаточно. То есть можно и все,
но достаточно одну. Вопросы? Кажется, мы написали все. 35 строчек у меня получилось.
Так, хорошо. Если нет вопросов, тогда давайте мы завяжем со строками. Но на чуть-чуть.
Так, вообще наша цель следующая. Мы хотим решить такую задачу. Все,
мы с автомат закончили, забываем про него. Мы хотим решить такую задачу. Есть шаблон p и
текст t. Нам нужно узнать, сколько раз шаблон входит в текст t, если можно ошибаться максимум k раз.
То есть мы пытаемся приложить p везде, где только можно. И если число ошибок не больше чем k,
число несовпадений не больше чем k, где k какая-то константа данная, то мы говорим,
что вот он здесь входит, но там неточное вхождение имеет. То есть вхождение с максимум k ошибками.
Значит, нужно найти все неточные вхождения с не большим k ошибками. Да, они могут идти где угодно.
И причем эти позиции, где возникают ошибки, могут тоже как угодно меняться. То есть тут может быть
три ошибки, тут может быть две, тут может быть тоже три, но в других позициях где угодно. И нужно
найти все такие вхождения с максимум k ошибками. Для этого нам нужно будет научиться быстро
перенажать многочлены. Мы научимся это делать в один из следующих разов с помощью быстрого
преобразования фурье. Ффт, на следующий или через раз лекции мы разберем. И с помощью этого решим
эту задачу. То есть мы как бы все еще решаем задачу на строках, но сначала нам нужно будет
немножко в теорию чисел погрузиться, построить алгоритм быстрого перенаживания многочленов,
вот и сюда мы еще тоже вернемся. Это пока такой анонс того, почему мы сейчас вдруг переходим на
теорию чисел. Вот, но сегодня уже у нас времени особо много не остается, поэтому мы разберем
что-нибудь простое, что либо вы знаете, либо где-то слышали, либо узнаете сегодня. Так,
давайте начнем с простого алгоритма Евклида. У меня есть ощущение, что он у вас не у всех был.
Скажите, пожалуйста, у кого он был? Поднимите руки, пожалуйста. Черт, у всех был. Нет? Или не у всех?
Но все равно, мне кажется, что нам это точно нужно, по крайней мере это просто. Задача такая, у вас
есть какие-то два числа, скажем A и B, и вам нужно найти их наибольший общий делитик, то есть такое
максимальное натуральное число, которое их обоих делит. Давайте пока что жить в парадигме, что у
меня все числа целые, вот, и нужно найти их наибольший общий делитель. Ну что, можно легко заметить,
что если, скажем, B больше справа, чем A, то наибольший общий делитель не поменяется, если я
вычту из второго числа первое. Если B больше справа, чем A. Это легко доказать. Давайте докажем,
что наибольший общий делитель не поменяется. И смотрите, если здесь был какой-то общий делитель
D, то есть D делил и вот это, и вот это, то ясное дело, что он будет делить и вот это и вот это. То есть
A он по-прежнему будет делить, B- un тоже будет делить, как делит разность двух чисел, делящихся на D.
Обратно, если тут какое число G делил, и вот это, и вот это, то G также будет делить A, и будет
делить их сумму. Будет делить Beaut B-аéléста be. Прorable если будет б. Поэтому не просто у них
наибольший общий делитель совпадает, но просто все
множество делителей общих совпадает, все, что делит
это, делит это, и наоборот.
Поэтому такой переход мне не меняет наибольшего
общего делителя.
Тогда алгоритм будет очень простой.
Давайте мы делаем такое вычитание, ну или точнее
будем брать по модулю до тех пор, пока не придем
к чему-то очевидному.
Вот это же утверждение можно обобщить на такое.
То есть вместо вычитания можно взять остаток отделения
по модулю, потому что если я просто много раз буду
вычитать, скажем, это число очень маленькое, это число
очень большое, то когда я буду вычитать много-много-много-много
раз вот это число, а маленькое, то в итоге я по сути просто
дойду до b процента, остатка определений b на а.
Ну и тогда алгоритм будет такой, давайте я его назову
как-нибудь int gcd, int b.
Сначала давайте поменяем числа местами, если вот это
мне нравится, не выполняется.
Давайте я не буду писать std, просто пишу swap a b.
И в конце нужно еще написать условия выхода, условия выхода
будет такое, меняется пери a, это самый маленький звук
чисел, если оно ноль, то я знаю, что gcd равен второму.
Если оно ноль, то gcd равен второму, потому что gcd нуля
и чего угодно, это то самое что угодно, потому что 0 делится
на любое число.
Но в конце, если это не выполнено, то нужно просто вернуть
гcd того, что тут написано, a запятая b процента.
Конечно, да, но я не буду гнаться за константы в большом.
Да, можно сказать, что действительно можно сразу передавать
сначала b процент а, а потом а, то есть я хочу сначала
маленькое, потом большое, и я понимаю, что остаток
предельно а всегда меньше, чем а, то есть если их поменять
местами, то вот здесь у меня не будет слопа, можно
так сделать, но мне лень, давайте не будем переделывать.
Вот, значит работает это за сколько?
Время работы.
Время работы на самом деле будет о от логарифма b, ну
я считаю, что b это максимальный из двух чисел, работает за
логарифм от максимального числа.
Так, почему это верно?
Для того, чтобы доказать такое время работы, мне
нужно как-то оценить, как быстро числа убывают, то
была пара ab, станет пара a и b процента, вот вопрос,
как быстро там уменьшается какое-нибудь число.
Ну, давайте немножко рассмотрим случаев, значит была пара
ab, она переходит в пару, как мы правильно заметили,
b процента запутая a.
Вот, в хорошем случае, если a по сравнению с b очень маленькое,
тогда вот эта вот взятие, взятие остатка, оно уменьшит
b существенно, да, то есть было там, не знаю, если a в 10
раз меньше, чем b, то этот остаток, по крайней мере, в 10 раз
меньше, чем b, то есть b сильно уменьшится.
Давайте скажем следующее, что если a, если b больше
сбравного, чем 2a, то, ну мы понимаем, что b процента
меньше, чем a, меньше сбравного, чем половина b, тогда в этом
случае у меня число b сразу уменьшится хотя бы в два
раза, то есть было какое-то b, а поменялось на число
меньше либо равное, чем 1 вторая b.
Если так было бы всегда, то есть максимальное число
всегда уменьшалось хотя бы в два раза, то понятно,
что с этим точкой будет лог b, да, на каждом шаге делим
максимальное число пополам, тогда в итоге, чтобы дойти
до случая, когда одно из чисел ноль, нам достаточно
логарифминического числа операции.
Значит, что происходит иначе, иначе, у меня b лежит в отрезке
от a до 2a минус 1, тогда b процента это просто b минуса.
Так, b процента это b минуса, но на самом деле тогда выполняется
то же самое, тогда я вычитаю из b хотя бы его половинку,
можно писать так, что a это хотя бы половинка b, даже
строго больше, поэтому b процента меньше либо равно,
чем b минус половинка b, то есть даже в этом случае
взятие остатка это вычитание a, и если a достаточно большое,
это хотя бы половинка b, то тогда у меня этот остаток
хотя бы в два раза меньше, чем исходная b, то есть выполняется
на самом деле то же самое, неважно какой из двух случаев
верен, маленькая или айли, или достаточно большой,
у меня все равно наибольшее число уменьшится хотя бы
в два раза, понятно?
Ну отсюда следует требуемое, симпатотика, вот лог b,
вот, хорошо.
А вы про то, что здесь возможно можно писать как бы меньшую
симптотику, что лог a, а не лог b?
Да, да, ну можно, можно, вы правы, да, да, вы правы,
то есть здесь можно написать там лог a плюс 1, грубо говоря,
да, то же самое, что лог a, да, можно так, ну, опять
же, этого хватает, все равно у нас как бы обычно, если
мы предполагаем, что все вот эти операции типа процента,
сравнение и так далее работают за от идицы, как мы предполагаем,
да, работают на наших компиляторах, мы пишем такое,
предполагаем, что это работает за от идицы, тогда в принципе
все равно все эти числа достаточно маленькие, там помещаются
в какой-нибудь лонг и лонг или что-нибудь такое,
и все равно это логарифм, там не важно от чего брать,
от максимального или минимального из двух чисел,
все равно что-то очень маленькое.
Ну, давайте считаю, что симпточка такая.
Хорошо, тогда давайте еще успеем, наверное, расширенный
алгоритм Евклида.
Значит, это алгоритм, позволяющий сделать следующее.
Давайте считать, что пусть наибольший общий делитель равен d,
тогда нам нужно найти такие целые x и y,
тогда ищем x и y, но я не пишу, что они целые, потому что
здесь мы говорим только про целые числа,
что линейная комбинация a и b с этими коэффициентами
в точности равна их наибольшему общему делителю.
То есть это так называемое линейное представление нот.
Линейное представление наибольшего общего делителя.
Отрицательное.
Меньше чего?
Нет, целое, обязательно целое, конечно целое.
Целое, возможно отрицательное,
но если они не целые, то это не интересно,
можно считать, что здесь 0, а здесь d делить на b.
Они обязательно целые, но, возможно, отрицательные,
да, конечно.
Вот, решение такое, смотрите,
мы можем воспользоваться нашим вот этим алгоритмом Евклида
и считать, что он, то есть он что делает,
он переходит от пары a, b к паре b процента запятая a.
Давайте считать, что рекурсивно он решил эту задачу,
понимаешь, чтобы цена не меняется,
вот это вот d остается тем же самым,
но пусть наш алгоритм решил задачу для пары b процента запятая a.
Пусть найдены,
не знаю, там x с крышкой и y с крышкой,
да, такие что?
Первое число нужно x с крышкой,
плюс второе на y с крышкой,
равно тому же самому d.
То есть я спустился в рекурсии для новой пары
b процента запятая a,
там ГЦД не изменился,
и я считаю, что мне рекурсивно вернули нужную пару x с крышкой и y с крышкой.
Тогда я сейчас по этой паре x с крышкой и y с крышкой
построю исходные x и y, которые мне нужны.
Так, ну давайте вот это вот заменим на
следующие, на b минус
b умножить на
a умножить на b slash a, вот так.
Остаток деления
это разность b и, собственно, не полного частного,
умноженную на делитель.
Это вот это b процента.
И давайте раскроем здесь все скобки.
Тогда мне написано, что b x с крышкой
плюс a y с крышкой
минус
a на b slash a
на x с крышкой
равно d.
Ну и тогда, если я сгруппирую слагаи,
мы правильным образом
сгруппируем слагаи.
У меня получилось то, что нужно.
Вот это x, вот это y.
И в итоге у меня переход, вот этот переход рекурсии
будет выполнен.
Если я для более простой пары
b процент a и a нашел нужный коэффициент x
с крышкой и y с крышкой,
а эти коэффициенты высчитываются вот так.
То есть их нужно поменять местами.
Из первого нужно еще вычесть
какую-то такую подравку.
Все.
И здесь, собственно, это все легко
встраивается в наш алгоритм.
То есть теперь там можем считать, что
gcd возвращает не число, а
тройку x, y и d.
И если вот здесь
рекурсивно мне вернулась тройка,
то мне нужно с ней проделать то преобразование.
То есть gcd не поменяется, а первые два
когда как-то поменяются, мне их нужно
вернуть из рекурсии.
Единственное, нужно еще понять, что
происходит вот здесь. Вот когда я дошел
до шага с нулем, ну тут все просто.
Если у меня a равно нулю, b не равно нулю,
то можно считать, что x равно нулю,
y равно единице
и gcd равно b.
Все. Тогда выход
из рекурсии у меня тоже корректно определен.
То есть если одно число 0,
второе равно b, тогда с какими
коэффициентами их нужно взять, чтобы получить gcd.
Ну первое можно игнорировать или там поставить
сюда что угодно. Второй коэффициент равен единице,
тогда как раз вот эта вот сумма
будет равна b, что я равно
gcd. И тогда вот так
рекурсивно если это раскручивать по той форме,
то у меня получится правильный набор
правильных коэффициентов x, y.
Вот. Ну все,
всем коэффициентам не хочется,
я найду правильную пару x, y,
и все будет хорошо.
Так.
Давайте тогда скажем, что мы нашли
какое-то
какое-то решение
x, y.
Одно из решений.
Одно из решений.
Тогда
все решения описываются следующим образом.
Это x плюс kb
y минус ka
для целых а.
Вот. Ну это тоже упражнение.
Несложное.
Должно быть в семинаре.
Что если мы нашли одно решение, то все остальные
решения описываются как добавить
сколько-то раз b к первому коэффициенту
и вычесть столько же раз а из второго коэффициента.
Ну и это число раз произвольное,
целое.
Если вопросов нету,
то на сегодня все. Спасибо.
До свидания.
