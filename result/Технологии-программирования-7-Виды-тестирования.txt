Всем доброго дня! Мы с вами продолжаем наш курс. В прошлый раз мы начали говорить про тестирование,
точнее продолжили детально говорить. И, наверное, где-то еще полторы лекции мы с вами будем
говорить про тестирование, потому что тема достаточно обширная и обычно не очень хорошо
покрывается. Значит, организационное объявление. Как раз после темы тестирования у нас будет
первая контрольная работа. То есть все темы, которые мы пройдем, выключая тестирование,
они попадут в контрольную работу. Чтобы у вас не было переживаний по поводу того, что что-то
непонятное будет в контрольной, мы пришлем пробный вариант, который можно будет посмотреть и
который можно будет решить, если можно будет задавать вопросы по этому варианту. Это у нас
получается 3 апреля в 10.45. По аудиториям мы еще попытаемся вас развести, наверное, где-то по
двум-трём аудиториям в лекционное время, чтобы у нас не было вот такого большого хаоса. Потому
что я представлю, что будет, если сюда придет 400 человек, писать контрольную. Это будет...
Это очень плохой опыт. Как говорится, тесноте да не в обиде. Мы постараемся все-таки развести,
найти аудиторию, заранее написать, кто в какую аудиторию пойдет. Это что касается контроля.
Давайте сразу, есть ли еще какие-то организационные вопросы. У кого нет организационных вопросов.
У меня есть организационный вопрос, что... Да, вопрос какой-то? Это просто слишком громкий
разговор. Хорошо, значит, мы в прошлый раз с вами остановились на том, что у нас есть разные уровни
тестирования. И мы поговорили о том, что у нас с вами по факту есть четыре уровня. Так, секунду,
сейчас мне Visual Studio CAD кажется задолбет сегодня, если я его не закрою. Это мы сделаем вот так.
Значит, мы сказали, что у нас с вами есть unit-тестирование, у нас с вами есть интеграционное
тестирование, после этого у нас идет системное тестирование и в конце у нас с вами идет приемочное
тестирование. То есть, мы по факту с вами можем расширять наши уровни тестирования до максимально
высокого уровня. Приемочное тестирование является самым неприятным, потому что, как ни странно,
не выполнение приемочного тестирования обычно приводит к штрафам. Но не к штрафам за сдачу
задания, образно говоря, а к физическим штрафам на энную сумму денег. Потому что там как раз
проверяются условия договоров. Так, значит, смотрите, теперь про каждый уровень тестирования
мы вкратце пробежим. Я не хочу детально тут останавливаться на всех аспектах, потому что
это, наверное, будет большое количество теорий, которые сейчас, наверное, не особо нужно. Хотя
неплохо было бы понять. Если мы говорим про каждый уровень, то для каждого уровня тестирования нам
необходимо задаться 5 вопросов. Во-первых, первое, это задаваемые цели, то есть, что мы хотим проверить
уровне тестирования. Второе, это входные данные для данного уровня тестирования. Это называется
базисом тестирования. Вот смотрите, тут важный момент будет состоять в том, что иногда для
некоторых уровней базис тестирования – это как ни странно не то, что мы с вами тестируем. То есть это
не объект тестирования. Иногда может показаться, что что-то может являться объектом тестирования.
но на самом деле мы это не тестируем мы это подаем на вход что вы понимали после этого мы говорим
про типичные дефекты и сбои давайте я спрашиваю с прошлой лекции что такое дефект а что такое сбои
да да только уточню значит дефект это то что нашли в процессе разработки не обязательно в
процессе отладки это могло произойти и в процессе тестирования а программный сбои это то что нашли
конечные пользователи вот и последний момент который здесь есть это подходы к решению то есть
кто является проверяющим на этом уровне тестирования кто проводит тестирование и так далее то есть мы
будем говорить с вами про эти пять пунктов давайте начнем следующего значит начнем мы с первого
тестирования unit тестирование или компонентное тестирование значит и цели этого уровня тестирования
заключается в следующем, что, во-первых, мы даем некоторую уверенность в том
качестве компонента, который мы с вами тестируем, проверяем модуля. Дальше мы
говорим следующее, что у нас с вами должен быть, мы должны находить дефекты в
компоненте, ну и сбоя, да, ну сбоя мы не находим, да, потому что сбоя нам сообщают.
И более того, мы для каждого уровня тестирования будем говорить следующее,
что он как бы является опорой в верхнем уровне тестирования и сбоем, точнее основой,
смотри, то есть он является основой для более верхнего уровня тестирования, и при этом,
если у нас находится сбои в уровне x, то на уровне x-1, собственно, скорее всего у нас есть баг. Вот это
цель тестирования. Вот теперь важный момент, который касается того, что является базисом
тестирования, и как ни странно нам на вход подают код. Вот это очень важно, то есть мы не код
тестируем, мы наоборот на вход получаем код. Значит, дополнительно, что нам может еще прийти,
это проработанный дизайн компонента, да, то есть как у нас компонент выглядит. Можно, кстати, это,
я не знаю, взять ту же самую CRC-карточку или диаграмму классов в определенном компоненте,
то есть вы видите взаимосвязь. Дальше, у нас должна быть некоторая модель данных. Что это означает,
я сейчас расскажу. Смотрите, у вас есть, допустим, какие-то наборы полей, образно говоря, вы начали
уже работать с проектом. У вас есть какие-то классы, которые хотелось бы сохранять и
использоваться ими именно как данными. Вот как раз модели данных, это вот эти вот классы и их
хранение. Нам про их хранение пока мы не говорим, здесь мы пока говорим про бизнес логику нашего
процесса. И должна быть еще дополнительная спецификация компонента, то есть application
programming interface, то есть каким образом мы можем к этому компоненту подключиться. Объекты
тестирования, вот это важно. Значит, первое, это компоненты и модули. Ну, модули это имеется в
классы в том числе. Структуры данных, классы и модули баз данных. Пока что мы не затрагиваем
базу данных, но давайте поймем каким образом мы с вами можем протестировать структуру данных.
Давайте попробуем написать определенный тест. Как протестировать то, что перед нами stack?
Тут именно нужно конкретно. Давайте я даже при помощи Google теста напишу.
Так, не знаю, checkorder. Значит, у нас есть, не знаю, допустим, stack and of a,
я пишу однобуквенные переменные. Итак, и немного псевдокод. Что нам нужно сделать с этим stack,
чтобы проверить, что это stack? Так, давайте пусть это не будет stack and of, а пусть это будет
наш stack какой-нибудь, который мы хотим протестировать. Сколько нам элементов нам нужно будет?
Давайте проголосуем. Кто за 3? Кто за 2? Там нужно проверить, что перед нами stack.
Каким свойством обладает stack? First in, last in, first out. То есть тот элемент, который последним
заходит, тот первым и выходит. Соответственно, можем ли мы проверить это при помощи одного
элемента? Нет, если мы положим два элемента. Ну да, минимальный тест, если чисто задаваться,
то это будет два элемента. Понятно, что можно сделать более сложный тест, допустим, для того,
чтобы отличить его от другой структуры данных, которая связана с каким-то порядком. Так, давайте
как раз реализуем. Значит, у нас получается stack push 1, stack push 2. Так, дальше что нам нужно сделать?
Надо посмотреть топовые элементы. Давайте я использую питоновский синтаксис для того,
чтобы код сократить. То есть с поп возвращается элемент сразу с нашей структуры. Ну и тогда нам
нужно написать что-то в духе assert equal. Так, двойки stack top, stack pop и assert equal 1 stack.pop.
Вот у нас тест, который проверяет последовательность лифа. То есть для очереди это не пройдет.
Кстати, вопрос. Затронем тоже интересную тему, связанную с тем, что будет в реализации в
зависимости от того, что мы попробуем вытащить еще один элемент из стека после того, как вытащили этот.
Как поведут себя разные языки программирования? Давайте поговорим про этот аспект. У кого какие
варианты? Кто-то сёкфолкнется. Давайте с точки зрения реализации. В одном из случаев у нас может
прилететь exception. Если мы говорим про C-подобные языки. Там не то что undefined behavior,
либо используется специальный флаг. Это флаг ерно. То есть мы можем задать флаг,
с которым мы по факту дадим код возврата для нашей функции. Кажется, кто-то уже задавал такие вопросы,
о как в UML диаграбе реализовывать возврат ошибки. Некоторые языки программирования делают следующее.
Они возвращают пару. Error, exception и result. Что означает этот вывод? Это означает, что если у
нас есть какая-то ошибка, то вот здесь ошибка становится не нулевой, и мы можем получить код
исключения. А если у нас нет никакой ошибки, то возвращается результат. В Rust, в JavaScript вот такой
код пишется. Просто всегда это работает по-разному. В зависимости от языка программирования и как раз
обработка исключительных событий производится по-разному. Так, хорошо. Про тест понятно?
Как пишется для стека? Такой простой достаточно пример. Понятно, что у нас тесты могут быть
намного сложнее. Так, теперь смотрите, типичные ошибки, которые у нас могут быть. Первая типичная
ошибка это некорректная логика. Грубо говоря, мы в каком-то месте поставили больше, а должны были
поставить меньше. То есть какие-то простые знаки где-то опечатались в каком-то значении. Вот,
дополнительно у нас может быть проблема с потоком передачи данных и управления. Это,
образно говоря, if и else местами поменяли. Можешь такое случиться в коде, когда вы пишете код?
Нет, нет, нет. Условия, которые вы написали, то есть вы написали условия внутри if, если оно
выполнено идет в одно место, если не выполнено идет в другое место. Да, понятно, что эти условия
можно поменять. Или, допустим, вы забыли, чем while do отличается от do while. Такое тоже вполне возможно.
А еще, возможно, вы используете какие-то более продвинутые операторы. Кстати,
про вот такой момент. Наверное, вы знаете, что это делает. A равно b++. Такой код сложно
читать, если, особенно, не посвященный человек. Ну, честно, иногда вас могут не понять. Это,
опять же, сугубо субъективная вещь. И, опять же, такие вещи в том числе проверяются на стадии
верификации. То есть команда разработчиков, с которой вы работаете, готова читать такое или
не готова читать такое. Если готова, то окей. Если не готова, то придется корректировать это все
дело. Значит, смотрите, для специфика. Блин, я вспомню, что я книги забыл. Надо себе напоминание
поставить. Специфика компонентного тестирования заключается в том, что требование, которое у нас
появляется для тестирования, выявляется, на самом деле, через процесс code review или через демо
продукты. То есть, когда вы идете с заказчиком и показываете ему разные функциональности. А потом,
представьте себе, ваш заказчик вбивает формочку поля, и у него программа падает.
Значит, если мы говорим про гибкие методологии разработки, то тут зачастую применяется так
называемый тест driven development. Собственно, что такое тест driven development? Это методика,
которая позволяет делать следующее. Сначала вы пишете тесты, потом пишете минимальный код,
который проходят эти тесты. Давайте в качестве эксперимента попробуем это сделать.
Сейчас секунду. Так, давайте я открою. Где у меня? Green Feed Patterns Collection, да. Давай, перезагружай.
Сейчас у меня проект загрузится.
Я использую библиотеку Pytest для демонстрации. И после этого мы с вами как раз покажем пример.
Грузит, грузит, грузит, грузит, грузит. Давайте, короче, удаленное исполнение сегодня нам
сказала привет, поэтому мы напишем все в командной строке. Или сделаем... Да. Отлично.
Значит, как работает методика тестирования? Так, я открываю новую сессию. Сейчас активирую
и поставлю библиотеку Pytest, чтобы быстрее написать. Все, она стоит. Значит, смотрите,
давайте мы напишем с вами код в файле test.py. Значит, fromTriangle import isTriangle. Сейчас я...
Кстати, обращу внимание. Сразу... Так, я не знаю, видно или нет. Мне кажется, плохо видно, да? Так,
сейчас поменяем. Так, лучше. Ладно, from не видно, ну и ладно. И вы не поверите, это первый тест.
Почему он у нас не выполнится? Кто понимает? Ну, смотрите, мы написали с вами модуль под
названием Triangle. Ну да, можно, кстати, вот видите, то есть у нас вообще framework не запустился,
нам явно выдают ошибку. То есть, мы первый функциональный, с которым можем вообще проверить,
это test import. Да, это бред, но все-таки это... О, видите, тест провалился. Один тест failed. Отлично.
Как его починить? Нам, наверное, нужно создать Triangle. Смотрите, у нас методика red, то есть у нас
тест не прошел. Дальше мы пишем минимальный код, который проходит тест. Тест прошел. Так, теперь
давайте, наверное, что-нибудь более умное сделаем. И как раз тут важно именно минимальность тех
итераций, которые у нас проходят. Значит, дальше давайте тест... Сделаем следующее. Теперь мы
можем сделать три фактор, потому что у нас код есть. Я пока что продублирую код. А дальше мы с
вами сделаем следующее. Assert 3, 4, 5. Является ли это треугольником? Да, является, но тест у нас не
прошел. У нас тест не прошел, потому что мы не передали большое количество аргументов. Смотрите,
дальше мы переходим с вами к концепции ABC. Вот. Почему у нас тест не прошел? Ну, потому что у нас
none возвращается. Как сделать минимальный код, который проходит этот тест? Да, бинго.
Нам нужно всегда возвращать true. Так, давайте я перенос в конце строки поставлю, потому что это
важно. Вот. Да, тест проходит. Теперь какой тест нам нужно это написать? Да, некорректный. Not
triangle. Да, тесты при этом стараемся писать triangle. Что там? Какой-нибудь треугольник. Надо было в
прошлый раз записать все ответы, которые у нас были. Так, смотрите, тест не проходит. Как его
починить? Минимальный код, который учинят. Да, кстати. Да, кстати, проблемы с логикой и про то,
что я говорил. Ты что? Вы сохранили? Нет, не сохранил. Спасибо. О, тест проет. Так, смотрите,
вы написали один тест на true, один тест на false. И дальше возникает методика в методологии TDD,
называется триангуляция. То есть у нас получается, смотрите, у нас есть вершина треугольника 1,
в ней ответ true, допустим. Вершина треугольника 2, в ней ответ false. И есть вершина 3,
которая определит, правильно у нас логика или нет. Давайте придумаем тест.
Не-не, пока полтора. Так, назовем его. Пока назовем его middle, конечно,
видите, у нас провалился тест и, наверное, здесь уже надо применять какую-то логику.
Да, какая минимальная логика теперь? Нет-нет-нет, ну понятно, что ефать уже здесь, наверное,
не надо. Ну, то есть надо. Наверное, хочется сказать return a plus b больше c. Четыре,
четыре теста пройдено. И вот, смотрите, здесь наступает, вот поп-ти, в прошлый раз говорили
про принцип тестирования, наступает парадокс пестицида. То есть, как бы, тот код, который мы
с вами уже добавили, на самом деле, для этой реализации некоторая функциональность уже не нужна.
Какой тест мы можем выкинуть после того, как появилась вот эта реализация? Ну, на самом деле,
можно либо выкинуть, либо первый тест. Ой, получается, во-первых, первый тест можно выкинуть,
потому что у нас есть импорты. И вот один из, первый тот, который на импорт, либо один из этих.
А, наверное, лучше выкинуть. Давайте, допустим, мы сделаем refactoring и уберем вот этот тест.
И тест импорт. Да, тестов стало меньше, но при этом функциональность у них стала ровно такой же.
Хорошо. Так, и теперь еще один тест, который нам нужен. Какой? Да, кстати, тест.
Не, не 1.511, 1.511 пройдет. 2.111. Вот, то есть, мы пишем вот такой тест.
Что? Ну, на самом деле, зависит от того, который мы напишем. Поскольку мы все-таки пишем на
питоне, то реализация, которая поменяет это все, она очень такая. Опять же, ай, дайте выйти.
Вот так вот. Все, вот нашлись мы. На самом деле, мы сделаем вот такое вот. Опять же,
этот код не читабельный, сразу говорю. То есть, вот, тест. Теста пройденным,
наш функциональность есть. Ну, теперь смотрите, я включу статический анализатор кода. Это вещь,
которая проверит наш код на качество. То есть, есть статический анализатор кода вида Flake 8,
по которому я, в принципе, старался мой код оформлять. Но если мы с вами запустим как раз
вот этот код, как вы думаете, на что он сругнется? Слишком короткие названия переменных. Да, он еще
любит оценки ставить. Ну, кстати, он сругнулся, что у нас не хватает dot string, лишний перевод строки
в конце. О, видите, нам оценку повесили. То есть, здесь некоторые штуки можно игнорировать.
Давайте тесты пройдемся статическим анализатором кода. Да, что-то у меня тут много переносов
строк. Кстати, странно, что он не сругнулся на однобуквенные переменные. Хотя, по идее,
должен был сделать это все. Вот. Но есть еще другой анализатор кода. Аккуратнее. Flake 8 triangle pi.
О, и вот он нам уже сказал, что single letter variables like a нельзя использовать. Ну,
или мы можем использовать Flake 8 для тестов. Он, наверное, сказал, что это однобуквенные
переменные. То есть, имеется в виду аргументы функции, он не позволяет. Так, и смотрите,
здесь он сказал, что нам нужно сделать два переноса строки. Вот. То есть, это уже статический анализ кода.
Во, все. Ну, здесь, в принципе, можно оставить abc. Главное, что аккуратнее делать. То есть,
можно прямо поставить, образно говоря, Flake 8 ignore на такую-то строку, чтобы статический анализатор
кода понимал, что ему не надо проверять эту функциональность, и он пробежал бы дальше. Вот.
Вот такая методология. Понятно, что чем больше у нас опыт в этой штуке, тем больше мы можем
проскакивать некоторые шаги. То есть, я сейчас просто показал, так сказать, для новичков, как это
работает. Да, понятно, что там, чем больше человек, тем больше у нас с вами как раз тестов будет
написано. Да, причем имеем хорошую основу на тестов, вы можете спокойно проводить рефакторинг,
потому что, в принципе, если что, вы в гитте потом откатитесь. Так, понятно суть? Вот это,
что, вот эта методология. Хорошо. Так, фасад нам. Лево. Давайте дальше. Следующий уровень.
Поднимаемся выше. Интеграционное тестирование. Цель удостоверится, во-первых, что два уровня,
которые ниже, унит и системный, у нас с вами является фундаментом. То есть, у нас получается,
интеграционное тестирование является фундаментом для системного, и при этом, если у нас есть
ошибки на интеграционном уровне, то мы спускаемся с вами на унит уровень. Вот. Дальше нам нужно будет
убеждаться в качестве интерфейсов наших, и дополнительно мы можем с вами проверить здесь,
что какие-то функциональные требования к определенным сервисам, взаимосвязи между ними как раз
корректно проведены. Значит, какие бывают виды интеграционного тестирования? Значит, если мы
говорим про обычные интеграционные тесты, то они идут либо между компонентами, то есть, у нас
код есть, у нас компонента A есть, есть компонента B, и есть взаимосвязь между сервисами или микросервисом.
Про сервисы мы будем говорить чуть дальше, мы будем поднимать свои маленькие серверы, между которыми
будет происходить взаимодействие между собой. Вот. Значит, при этом базис тестирования, кстати,
здесь уже некоторые знакомые вещи есть. Значит, первое это дизайн системы и софта, второе это
диаграмма последовательности, то есть можно использовать их. Варианты использования тоже можно
смотреть их, дать пример с регистрацией, я не помню прислал или нет, если не прислал, напишите,
пожалуйста. Спецификации протоколов, то есть по какому протоколу вы отправляете данные и при
помощи какого формата вы принимаете данные между сервисами. И последнее это описание внешних
интерфейсов, то есть у вас есть описание, у вас есть диаграммы и все такое. Значит, вы тестируете
либо под систему, либо уже целую базу данных, а не табличку допустим одну, вы тестируете интерфейсы,
микросервисы и вообще application programming interface, то есть мы с вами тестируем как раз уже полностью
наши взаимодействия. Значит, типичные дефекты, это не совпадение интерфейсов, то есть образно
говоря, здесь возникает интересная картинка, не знаю, знаете вы, сейчас. Круг. Во.
Дреугольник квадрат мем. Да, то есть, а? Все смотрели теократию. Вот, и дальше, если мы говорим,
то в технических вещах лучше настроить сразу инструмент непрерывной интеграции и определить
связи между компонентными сервисами. Про непрерывную интеграцию мы будем говорить с вами как на
семинарах, так и, возможно, на лекции, затронем эту тему. Значит, как проводить интеграционное
тестирование? Как раз здесь нужно будет создавать некоторые заглушки, про заглушки мы поговорим чуть
позже, и цель будет как раз сделать так, чтобы заглушить все, кроме самого механизма передачи
данных, то есть вы по факту делаете, грубо говоря, стену, то есть вы отправляете запрос на какой-то
сервис, да, то есть у вас есть А, вы отправляете запрос сервису В, а посередине вместо В ставите
С, который вам будет возвращать конкретный ответ. Вот, и как раз такое можно делать при помощи заглушек.
Вот, собственно, когда вам нужно протестировать взаимодействие между сервисом А и, допустим,
между остальными сервисами, допустим, у нас был еще какой-то сервис Д, и нам нужно протестировать
взаимодействие, но при этом у нас от А перед тем, как мы отправить информацию в Д, должны
отправить что-то внутри сервиса В, и с А должна произойти отправка в В, это означает следующее,
что нам нужно по факту заглушить механизм, посмотреть, что нам возвращается, и с этими как раз
данными прийти в сервис Д. И вот как раз видно, что если попытаться просто нарисовать это все на
диаграмме, на той, которой я показал, что это вообще непонятно, что происходит, и в данном случае как
раз будет более полезно использовать диаграмму последовательности, то есть как бы давайте как раз
проведем ее, значит, пример, у нас есть объект А класса А, значит, у нас дальше есть, значит, кто
получается объект B класса D, и есть экземпляр D класса D, значит, я тут не буду специфицировать
именно то, в каком порядке они вызываются, точнее, как, с какими параметрами они вызываются,
но в целом следующее, значит, у нас получается идет вызов сервиса D, а нет, сначала у нас идет вызов
сервиса D, дальше у нас возвращается определенный результат, то есть это шаг 1, а после этого у нас
идет вызов к сервису D, вот, да, кстати, тут тоже стрелочки, вот такие, да, и как раз вы вот сюда в
качестве менедзе мидла вставляем объект C, который перехватывает наши запросы и будет возвращать какие-то
готовые результаты, вот, и видно, что вот то, что я рисовал на вот этой диаграмме, оно не является достаточно
точным, но на вот этой диаграмме, кажется, это стало понятнее, давайте проголосуем, кому понятно,
что, кому понятнее вот эта диаграмма, кому понятнее вот эта диаграмма, ну, остальные воздержались,
или не поняли обе две диаграммы, так, кто не понял обе две эти диаграммы, не стесняйтесь,
тогда давайте вопроса, ну, как-нибудь я помогу переформулировать, вот эти блоки на вот этой
диаграмме означают, когда эта функция или когда этот объект является активным, то есть когда по
линии жизни, если мы посмотрим, наложим ось T, это означает, когда эти объекты реально выполняют
какую-то роль, функцию, то есть в другое время объекты просто существуют и не выполняют никакую
функциональность, да, вызов функции, да-да-да, вызов ведется с функцией функцию D, вначале функцию B,
потом вот пунктирная стрелочка означает, что у нас идет результат, да, кстати, правильно еще вот
эту штуку заштриховать, да, потому что у нас объект A тоже как бы ждет результатов вызовов других
функций. Ну да, ответ приходит не сразу, то есть оно могло быть сделано так, смотрите,
тут еще есть некоторый важный аспект, но он касается именно UML, обычно его не четко обрисовывают,
значит, если у вас стрелочка такая, это означает, что у вас функция синхронная, это означает,
что вы же ожидаете результаты ответов, если у вас стрелочка не синхронная, то тогда у вас могло
произойти следующее, у вас могло, я не знаю образно говоря, вот эта функция когда-то работает и
не обязательно вам приходит ответ от этого объекта, то есть это допустим мы запускаем что-то в отдельном
потоке, то есть делаем отложенный вызов, то есть нам результат функции не обязательно вернет,
а возврат обычно происходит при помощи другого механизма уже, но это нам надо будет тоже немного
про будущее поговорить, потому что я тут уже, если я сейчас начну рассказывать это, мы начнем
говорить про сетевое взаимодействие, прямо здесь и на месте, так, я ответил на вопрос,
все, хорошо, давайте двигаться тогда дальше, значит, поднимаемся еще на уровень выше,
системное тестирование, это уже иногда их называют end-to-end тестами, потому что мы запускаем нашу
систему от самого начала до самого конца, и цель этого уровня тестирования заключается в том,
что мы валидируем то, что система готова к работе и то, что система работает корректно,
далее мы пытаемся с вами находить дефекты в работе всей системы целиком, то есть вы запускаете,
грубо говоря, сайт локально, либо какое-то приложение и начинаете его тестировать,
кнопочки, а дальше вы пытаетесь уменьшить риски, то есть то, что если у вас есть хоть какие-то
тесты и при этом это тесты не простые совсем тесты, какие-то даже нормальные тесты, грубо говоря,
что у вас программа запускается, вы можете ввести какие-то поля, нажать на enter, это уже, знаете,
успех, потому что, кстати, проводили исследования, брали, значит, по-моему, гитхаб, брау,
джупитер ноутбуки людей, джупитер ноутбук это тетрадка, в которой люди пишут код, ну, грубо
говоря, на питоне, дальше интерактивно его исполнять, так вот, оказалось, что 35 процентов джупитер ноутбуков,
которые лежат в сети, они выполняются неверно, то есть их начинаем прогонять с самого начала
до самого конца и там возникают ошибки, вуаля, то есть запустите проверить, что все подряд
выполняется, это уже хорошо, так, теперь что касается системного тестирования, какой тут базы
тестировать, во-первых, спецификация системы, это функциональные и не функциональные требования,
дальше отчет анализа рисков, то есть, грубо говоря, вы приходите, вам присылают следующую
информацию, вы запускали систему и вам говорят, образно говоря, у вас, значит, существует риск,
на улице сейчас будет минус 30 и, возможно, вы останетесь без отопления, вот, где может прорвать,
просто говоря, дальше, значит, у нас могут быть эпики, это большие наборы задач в agile,
прямо, типа, от начала до конца, линия жизни, так сказать, и user stories, то есть, у нас можно
использовать как раз фичи, которые просят от нас заказчик, собственно, мы идем по этим фичам,
раскладываем этот вариант использования и идем и просто по вариантам использования проверяем то,
что у нас происходит, ну и, конечно же, не надо забывать гайды и мануалы, потому что если у вас
есть, представьте себе, вы открываете мануал, читаете его, пытаетесь выполнить по шагам и у вас
не работает, будет интересно, как такой продукт сертифицировали, значит, что мы тестируем с
вы? Мы тестируем с вами здесь приложения, все целиком, все целиком, далее системы под различными тестовыми
нагрузками, то есть вы проверяете, образно говоря, справляется ли ваша система с разными нагрузками,
то есть, вы делаете пять запросов в секунду, десять запросов в секунду, двадцать запросов в секунду,
сорок запросов в секунду и так далее, вот, как ни странно на выходных система не справилась
правила с нагрузкой из-за неправильного распределения
ресурсов.
Но про это вам уже будут говорить на курсе распределенных
вычислений, потому что тут уже тематика связана
с тем, что на самом деле АКЧЕКТО находится не на одном
компьютере, а на большом количестве компьютеров.
Вот, и конфигурация системы, то есть вы можете допустить
допустим вашу систему в одном режиме, в другом режиме,
в третьем режиме, то есть у вас всегда, если вы запускаете
какую-то нормальную систему, у вас возможно не то чтобы
отладка, у вас существует механизм логирования действия,
то есть когда вы пишете, что, образно говоря, куда
каждый пользователь зашел, какая функция вызывается,
более того, можно отслеживать время работы этих функций.
Вот, это объект нашего тестирования.
Значит, типичные ошибки, значит, неверное поведение
системы в различных ситуациях, да, просто появляется какая-то
нештатная ситуация, в которую мы не могли вызвать.
Очень легко, на самом деле, в данном случае, проамулировать
какое-нибудь тестовое взаимодействие.
И давайте, кстати, я вам покажу один из примеров тестирования.
Зайдем на check и откроем вкладку разработчиков.
Ну, кстати, эмулировать тут даже ничего не надо.
У меня медленный интернет.
Да, но если вы действительно хотите протестировать
медленный интернет, то у вас есть кнопочка слоу 3G.
Или кнопочка оффлайн.
Да, либо кнопкой mipton.g, то есть мы, кстати, можем сделать
ноутротлинг.
Типа, это вот те системы, которые загружаются именно
так, как она должна.
Дополнительно вы можете здесь использовать разную
функциональность.
О, наконец-таки он начал что-то грузить.
Ура!
О, отгрузилось.
Да, ну и дополнительно вы можете сделать, кстати,
по-моему, где-то тут есть вкладочка.
Вот такая.
Оба.
И вы можете протестировать, как это будет выглядеть на
одном из устройств.
Ваш сайт.
Или ваше приложение.
То есть на iPhone SE видно, что юзер-тестинг, юзабилити-тестирование
не проходит.
Да, потому что оно выглядит вот таким корявым образом.
Надо это чинить.
Как это чиниться?
Это обычно выводится специально, так сказать, кнопочка.
Я забыл, как называется.
Бредкам, по-моему.
Нет, не бредкам.
Короче, вылетающее окошко сбоку, чтобы можно было
зайти и как раз на него кликнуть.
Вот.
То есть, видите, здесь тоже можно что-то тестировать.
То есть на личных устройствах посмотреть, как это работает.
Вот.
Дополнительно, значит, невозможность выполнить антуэт задачи.
То есть мы как бы хотим пройтись по всему варианту использования,
он у нас не работает.
Ну и система работает не по гайдам.
Тоже вполне корректный вариант.
Значит, про решающую таблицу поговорим позже.
Выяснить, система работает корректно или нет.
Максимально важно прорабатывать альтернативные сценарии
вариантов использования.
Мы с вами сказали, что альтернативных сценариев у нас порядка
90% случаев.
Ну и больше используется статическое тестирование.
То есть это улучшаем спецификации, улучшаем мануалы, варианты
использования.
Видите, user story.
Значит, хочется всегда, так сказать, я не знаю, творить,
писать какой-то код.
Но зачастую вам придется сидеть и писать документацию.
Ну или писать мануал для того, чтобы это визуально
представить.
Нет, конечно, есть люди под названием технические
писатели, которые это могут делать, но все-таки лучше,
если ваш код хоть немного задокументирован, его читать
намного проще.
Так, и последний уровень тестирования, это приемочное
тестирование.
Вы проверяете то, как работает у вас операционная составляющая.
И в приемочном тестировании как раз есть спецификация
по видам.
Первое пользовательское, user acceptance testing, это система
работает, ультворяя потребности пользователям, может вообще
установиться на его компьютере.
В образе говоря, вам там, не знаю, нужно запустить
сайт.
Кстати, такое было до недавнего времени.
Вам нужно было запускать всякие сайты госструктур,
именно финансовых структур, связать с бухгалтерией,
вы не поверите на интернет-эксплоре 11.
Да, потому что там было достаточно, то есть в свое
время интернет-эксплоры, это был достаточно большой
комбайн, в котором было все намешано.
То есть иногда было проще ножками топать, чем идти
и что-то тыкать в интернет-эксплоре, вот честно, я даже сам с таким
столкнулся.
Однажды, когда я пытался что-то сделать в банковской
экосистеме, когда это было там года три еще назад.
То есть модные кнопочные приложения, это далеко
там не старые технологии, это достаточно современные
технологии.
Дальше, значит, операционные тестирования, это очень
важно, тестирование бэкапов, установки, развертывание
приложений, обновление до новой версии, то есть
правильно ли обновляется, либо бенчмарки, то есть,
грубо говоря, тестирование производительности.
Оно тоже здесь может идти.
Дальше, контрактное.
Вот это очень важный вид тестирования, пока что
кажется, что это не важно с точки зрения по, но когда
вот мы выходим на приемку, это имеет очень важный фактор.
Тестирование, что не нарушены никакие лицензии, условия
контрактов между разработчиками и тестировщиками, разработчиками
и заказчиками.
Так, давайте честно, есть такая вещь, как лицензионные
соглашения.
Наверное, вы видели их.
Да, как вы думаете, почему заставляют вас поставить
галочку?
Да, то, что какие-то предложения не являются афертой, побуждением
к какому-то действию, ну и просто описывают регламент.
То, что вы согласны на то, что если вы сделаете какое-нибудь
санкционерное действие, допустим, у вас будет какой-то,
понесет вам какой-то ущерб, вы согласны с этим.
Если вы положите стать, то виноват, то вы и они будут.
Ну, тут опять же, это уже будет обсуждаться в судебном
порядке.
Опять же, вот эти лицензионные соглашения должны регулироваться
законодательством, поэтому это очень важно.
И последнее, это альфа и бета-тестирование.
То есть, мы про них уже говорили, альфа-тестирование
выполняется внутренними сотрудниками, бета-тестирование
выполняется внештатным сотрудником.
И базис тестирования, это уже самый высокий уровень,
это бизнес-процессы, требования системы, пользовки и соглашения,
установочные процедуры, описание процедуры бэкапов.
Объекты тестирования системы под различными тестовыми
нагрузками, там, образно говоря, в ночь перед дедлайном
или в спокоен или в летние каникулы.
Отчеты производительности, их тоже можно получать,
мы, кстати, их выводили, в свою очередь, и поведение
системы после намеренного падения.
То есть, тем может падать.
И как она восстанавливается.
Так, а теперь, а, еще типичные ошибки.
Значит, рабочий процесс кеолитворяет требованиям,
то есть, грубо говоря, вообще бизнес-процессы в компании
нарушены, образно говоря, вам пишут обратную связь,
а вам не отвечают.
Вот, возможный взлом системы, тоже, кстати, вполне возможное
поведение.
Да, и поэтому важно следить за ошибками в безопасности.
Или сайт упал под нагрузкой 100 тысяч человек в онлайне.
Так типичный кейс вообще, когда система не выдерживает
нагрузки.
То есть, по идее, нагрузки надо считать и рассчитывать.
Особенности, значит, кто тестирует?
Если говорится про Agile, то тестирует Product Owner, заказчики
и пользователи.
Если мы говорим про Scrum, то это хороший вариант.
Это вы берете Sprint Demo, либо день релиза, и у вас все
падает.
Очень хороший тест, вообще, все замечательно.
Но, конечно, лучше тестировать нагрузку на альфа и бета
тестирования.
Вы получаете отчет о производительности, а дальше уже их выкатываете.
Так, дальше, по-моему, будет пример приемочного тестирования.
Да, чтобы вы понимали.
Значит, картинка.
Что мы видим на картинке?
А, ну, программу, которая ломает некоторые сервера,
и ты проверяешь, выйдет ли программа работать, если
что-то пойдет не так.
Да, если часть серверов будет отключена.
Это так называемое хаос-тестирование.
Разумеется, мы видим здесь обезьянку, которая берет
что-то шалить с проводами и выключает некоторые
компьютеры и системы.
И дальше вы проверяете, работает ли система или
нет.
Ну, то есть какие-то вносить неполадки в эту систему.
Значит, это методология, которая была разработана
в Netflix, и она как раз активно применяется именно в Netflix.
Слышали ли вы когда-нибудь, что Netflix падал?
Именно надолго и серьезно.
Ну, это у вас, а у большого количества пользователей?
Да, ну, то есть обычно, кстати, если бы упал и у вас,
этих поддержков вам бы ничем не помогло, ну, тогда
нет, конечно, если это только незаконодательно каким-то
образом было запрещено.
Допустим, вам написали, что ваше устройство, увы,
мы не будем поддерживать, потому что, я не знаю, 0,1%
пользователей, которые операционную систему обладает
такой, возможно, что не стоит поддерживать.
То есть смотрите, система после намеренного падения
вполне спокойно живет.
Так, это что касается про уровни тестирования.
И теперь давайте немножко попрактикуем и разберем
пример.
Пример, вам нужно будет назвать уровень тестирования.
Тестируем, что класс, принимая в качестве входа три стороны
треугольника, является он устроугольным или нет.
Какой это уровень тестирования?
Ну, да, говорят, что это unit-тестирование.
Действительно, это unit-тестирование.
Так, второе.
Тестируем, что сервис получения курса доллара.
Значит, это какая-то подсистема.
Отдает там показатели курса доллара,
которые вы получите сегодня, или которые вы получите завтра.
Да, это интеграционный уровень.
Следующий.
Блин, черт, пропалился.
Тестируем, что программа запускается на Core i5
какого-то железа с 512 МБ амперативной памяти.
Это уже больше приемочное тестирование, потому что
вы под конкретное железо говорите.
Вот не зря на компьютерах, на дисках и так далее,
на ПО пишут минимальные системные требования,
с которых у вас вообще программа запустится.
Так, и последнее.
Тестируем, что при заходе на страницу МИПТРУ
можно кликнуть по ссылке расписания.
Смотрите, если бы это был на реальном сайте,
под нагрузкой, грубо говоря, 100 тысяч человек,
ну, не знаю, вряд ли 100 тысяч человек пойдет
нажимать на расписание.
Это было приемочное тестирование.
А так вы можете локально развернуть сайт МИПТРУ,
версию сайта, и так разработчики делают,
и они проверяют, что действительно можно зайти
на кнопку расписания и получить ее.
И получить конкретное расписание.
Как раз я предлагаю, вот этот сценарий мы с вами
рассмотрим, как можно протестировать автоматически
на следующей лекции.
Я даже покажу, как это можно делать.
Это с тем тестированием.
Так, давайте вопросы по уровням тестирования.
Конечно, немножко галопом по Европам, но...
Хорошо, двигаться дальше можем?
Так, давайте поговорим про фреймворк и тестирование,
которые существуют. Поскольку у нас курс
зачетую заточен именно под C++, Python и Java,
то у нас в качестве фреймворка и unit-тестирования
мы перечисляем именно эти языки.
В C++ известно два...
Ранее всего дела два популярных фреймворка
и unit-тестирования. Первый это Google Test,
с которым вы, кажется, уже начали знакомство свое.
Кто-то начнет знакомство, кто-то даже, возможно,
начал с ним знакомиться через CMake Advanced задание.
Ну и вообще, через CMake, если вы будете делать
базовую версию задания, вам нужно будет подключить пару тестов.
Это сделано специально, чтобы вы смогли адаптироваться
к теме, связанной с тестированием.
И, как бы говоря, вот такой вот код у вас не вызывал страха.
А это, в принципе, код тестов написан на Google Test.
И другая библиотека, если она тоже является популярной,
но не настолько популярная, это библиотека Catch2.
У нее немножко другая парадигма.
В качестве Python мы используем две библиотеки.
Одна, встроенная, это unit-тест, вторая, внешняя, это PyTest.
Кстати, вы, наверное, могли заметить, что тесты для TDD
я написал на PyTest, потому что она поддерживает функциональный стиль.
И третий фреймворк, третий, это Java.
И в Java как раз используется G-unit.
Да, и понимаете, насколько этот формат стал достаточно важным?
На том, что все отчеты по тестированию,
то есть, если вы хотите запустить результаты тестов,
то они называются G-unit.xml формат.
Давайте как раз и покажу.
То есть, если мы с вами попробуем запустить
minus-minus-help, то мы с вами видите G-unit, G-unit, G-unit.
И у нас получается отчет о пройденных тестах.
Вот он не полностью выводится,
но в целом, как мы видим, все test-yout и test-yout у нас тут есть.
А, подождите, а что, он теста не нашел?
А, мы правильно, потому что не указали модуль, который тестировался.
test.py
Вот тест-report.
Тут его можно привести в красивый вид,
и, в принципе, видно, что вот у нас тесты именно такие.
То есть, это полезный вывод.
Так, то есть, с этими фрейворками можно использовать.
И когда будет задание по тестированию,
вы сможете написать его на одном из трех языков.
Реализовать.
Там будет код, нужно будет его протестировать.
У нас есть три версии задания для Python, Java и C++.
Какой?
Goa.
Ну ладно, попробуем.
Если время будет, постараемся.
Просто надо код написать на Goa еще.
И подключить все фреймворы, все кавереджи и так далее.
Так, значит, еще раз.
Это больше напоминание не семинарской части,
что, значит, жизненный цикл unit-тестов.
Что у нас unit-тест запускается следующим образом.
У нас с вами есть test-case или test-suit,
и у нас есть некоторые вызовы методов.
То есть, у нас есть setup for test-case,
который запускается один раз перед всеми тестами
в наборе тест-кейсов.
Дальше у нас запускается метод setup,
который работает перед каждым тестом,
и потом по циклу у нас все происходит.
То есть у нас запускается unit-тест,
после этого teardown-test-case,
и мы повторяем эту процедуру.
После того, как у нас все тесты закончились,
мы вызываем этот teardown-test-case.
То есть он запускается после всех тестов.
Опять же, детальнее на семинарах это будет рассматриваться.
И мы переходим еще с вами к одной важной модели.
В методологиях разработки, про которую я показывал,
но здесь надо про нее рассказать чуть подробнее.
Значит, если мы с вами вдохновились
всеми методологиями, которые были,
и обнаружили следующее, что, как ни странно,
пирамида тестирования очень хорошо
можно разложиться на составные части.
То есть на самом деле приемочные тестирования
проверяют бизнес-требования.
Дальше системные тесты проверяют вашу систему целиком.
То есть это называется system-design.
То есть как вашу систему функционирует.
Дальше, если мы спускаемся на более низкий уровень,
то у нас работает интеграционное тестирование.
И как раз мы тестируем с вами взаимодействие между компонентами.
А взаимодействие между компонентами
описывается архитектурой нашего PO.
То есть мы проверяем архитектуру.
И последнее это unit-test и module-design.
То есть дизайн конкретных компонентов.
И смотрите, что у нас получается.
У нас в правой части возникает стадия валидации.
Да, смотрите, здесь, как ни странно,
очень хорошо помогает нам английский язык,
потому что он показывает разницу.
В стадии валидации проверяют, что мы сделали right-product.
То есть это продукт, который сделан вроде по спецификации.
И вроде как работает.
Но если мы поменяем слово product-right и right-product,
то внезапно у нас все поменяется.
Потому что мы специфицируем,
что мы строим наш продукт правильно.
То есть именно с учетом тех рекомендаций, которые у нас есть.
Вот это очень важно.
То есть, грубо говоря, автоматические тесты могут проверить одно,
а человек дополнительно может проверить и другое.
То есть сразу скажу, что стадии верификации происходят зачастую в выручном режиме.
То есть автоматика возможна только при стадии верификации нашего процесса.
Опять же, не путать, пожалуйста, эти термины.
Они очень похожи, но они...
они всю про проверку.
Но именно верификация зачастую важнее именно валидации.
Так, теперь поговорим про виды тестирования.
У нас бывают несколько видов тестирования.
Первый – это статическое тестирование,
второй – это динамическое тестирование.
Статическое тестирование – это то тестирование, которое не запускает наш код.
А динамическое тестирование, которое запускает наш код.
И в статическом тестировании обычно выделяют 2 подаспекта.
Первый инструмент – это код review.
Но не только review – мы можем review-ить код, дизайн, веб-страницу.
можем посмотреть на диаграмму и понять, допустим, что у нас с вами границы в
системе выстроены неверно. И статический анализатор кода. Он же называется линтер.
То есть мы как раз с вами запустили два статических анализатора кода, которые
проверили, что наш код оформлен согласно требованиям. Как вы думаете, почему важно
оформлять код согласно требованиям?
Что-что? Ну да, в том числе. То есть мы как бы поддерживаем наш код на хорошем
уровне, чтобы другие коллеги могли его тоже выполнять. Так, хорошо. Это что касается
статического тестирования. Дальше будем говорить не только про статическое
тестирование, но будем говорить про другие вещи. Так, начинаем интересный
момент, в котором мы будем говорить следующее. Мы разделим наши виды
тестирования и сейчас мы будем говорить про виды тестирования по методам и по
доступности. То есть по методам тестирования, если мы говорим про
стандарта СТКБ. Но про доступность, как раз это типа доступен код или нет.
Здесь выделяет три метода. Это whitebox-тестинг, тестирование белого ящика, когда у нас
программа вся видна. Greybox-тестинг, то есть когда у нас в отчестве видна
программа. И blackbox-тестинг, это тестирование черного ящика. И для каждого из них
разные методики. Значит whitebox-тестинг. Белая коробка, все видно. Я бы сказал,
лучше назвать не whitebox, а transparentbox. То есть мы видим, как у нас взаимодействуют
модули между собой и можем смотреть весь код. И как мы видим, статик тестирования
обычно относится к whitebox-тестингу, потому что у нас как раз наш код виден. И здесь
выделяет три основных аспекта, которые мы можем проверять. Первое это execution
testing, то есть мы проверяем после запуска. Второе это mutation testing, это
тестирование мутантами. Мутантами или мутационное тестирование его называют.
То есть цель будет такая, что мы будем наш код изменять автоматическом режиме
таким образом, чтобы проверять те тесты, которые мы написали, выпускают,
пропускают какие-то дефекты или не пропускают. То есть насколько у нас хорошая
база для тестирования задана. Так, значит теперь основным инструментом execution
testing, тестирования именно выполнения, является код coverage. Значит покрытие кода тестами.
И здесь выделяет, вы не поверите, четыре вида тестирования, четыре вида coverage.
Первый это statement coverage, второй это branch coverage, третий это decision coverage по
решениям и четвертый это pass coverage. Значит сразу скажу, что здесь на этой
штуке будет нарисовано частичного порядочное множество. Да, то есть они,
некоторые из них между собой связаны, некоторые из них не связаны. То есть
какой это является более строгим, какой это является менее строгим. Поехали.
Значит первое statement coverage, он замеряет следующую метрику. Количество
statement, которое у вас есть, количество statement, которые у вас прошли тесты. То
есть что вы делаете? Вы запускаете код ваш тестов, каждую строчку помечаете,
пройдена она была или нет. Важно всеми тестами. То есть хотя бы одним тестом эта
строчка была пройдена или нет. После этого вы замеряете процент statement.
Да, к сожалению, здесь некорректные результаты именно по statement, но в целом
смотрите, давайте оценим. Вот мы зашли в функцию. Раз, два, это result a plus b.
Третье if result больше нуля. Это statement. Четвертый результат, это у нас
print. Пятым иногда можно в принципе оценивать его, можно не оценивать его.
Здесь как раз у нас так сказать line coverage. То есть какие строки кода мы прошли.
Если мы говорим про statement, то мы покроем раз, два, три. Три строки из пяти. То есть
это вторая, третья и четвертая строка. Всего у нас строк statement будет шесть. Ой,
пять. Поэтому в этом примере coverage будет три пятых. 60 процентов. То есть какие три у нас?
Это два, три, четыре. Всего у нас получается два, три, четыре, пять, шесть. То есть statement
coverage считать обычно проще всего. То есть у вас инструмент должен позволять
уметь считать сколько веток вы прошли. Точнее не столько веток, сколько statement вы прошли.
Кстати, важный момент. В зависимости от языка программирования statement coverage может отличаться.
Так, вот это понятно? Вот этот coverage. Как обеспечить coverage 100 процентов?
Какие тесты надо запустить? Ну да, ну тут обычно когда говорят какие тесты,
это значит конкретные тесты. Да, значит нам нужно запустить тест минус один, минус один и допустим
тест два ноль. Ну вот мы получаем statement coverage 100 процентов. Ну что мы начнем проходить и по
пятой, и по шестой строке тоже. Так, это понятно? Вот вам один из номеров твой контрольный, кстати.
Вам будет код дан, вам будут даны тесты, вам нужно будет посчитать statement coverage.
Так, вторая branch coverage. Каждая ветвь исполнения пройдена один раз. То есть мы в нашем коде выделяем
количество ветвей исполнения и считаем сколько ветвей исполнения мы с вами прошли. Тут важно
именно рисовать четкую схему алгоритма действий. Значит и считать именно количество ветвей,
которые у нас есть. Здесь количество ветвей равняется, не поверите, восьми в этом участке кода.
Смотрите, первая ветка это как раз от входа функции до if. Дальше у нас идет разветвление if на да и нет.
И обращу внимание, что вот обычно забывают следующее. Не количество ветвлений, а количество веток,
то есть количество путей. То есть у нас есть стрелочка связанная с двойкой, с четверкой,
с пятеркой, с шестеркой, с семеркой, с восьмеркой. То есть у нас все условия считаются. На самом деле
после if, если у нас идет return, тут вообще идет девятая инструкция, которая есть. Давайте попробуем
посчитать branch coverage для такой штуки. Кстати, если мы подадим тест 50-50. То есть мы даем x
равной 50 и x равной 50. Сколько веток мы с вами проходим? Давайте считать. Какие ветки мы проходим?
5, 6 или 7? 7. У нас сумма ровная 100. 7 и 9. Вот тут вот девятое. Ой, извините.
Тут типа ее не хватает. Ее неплохо было бы дорисовать. То есть тут вот у нас как раз есть
девятая ветка. Вот. То есть смотрите, мы прошли 5 веток. Всего 9 веток. То есть branch coverage у
нас 5 девятых. Это приблизительно 55,6 процентов. Смотрите, если мы к этому тесту даваем дополнительно
тест 51,50, то что у нас произойдет? Какие дополнительные ветки мы с вами покроем?
Да. 24 только. И в итоге общий coverage. Посмотрите, мы меряем coverage не по каждому тесту, а общий.
Он уже будет 7 девятых. Это 7,7-8 процентов. Ну и как добить слой coverage в 100 процентов?
Получаем 100 процентов. Давайте скажем так. Скажите, пожалуйста, какое количество кода нам нужно
будет добиться для того, чтобы получить statement coverage 100 процентов? Какое количество тестовых сценариев?
Нет, не три. Statement coverage, не branch coverage. Предыдущий. Что мы по всем statement'ам пройдем?
Или три? С одной стороны, да. Но утверждается, что мы можем пройти по всем statement, но не по всем развилкам.
Смотрите, что такое statement coverage? Нам нужно в каждый оператор попасть. Смотрите, в statement
coverage нам будет достаточно два теста пройти, чтобы получить statement coverage 100 процентов. Это нам
нужно будет взять вот этот тест и вот этот тест. Но при этом, чтобы получить branch coverage 100
процентов, кстати, какие нам тесты? Нам, кажется, те же самые два теста понадобятся, да? Да-да-да. Нам
те же самые два теста понадобятся, главное, нам надо будет пройти по всем веткам. Но утверждение,
что ивристически можно сказать, что branch coverage это более строгая вещь, чем statement coverage.
Так, следующий coverage. Decision coverage. Количество пройденных логических операторов. Логических
операторов это имеется в виду те, которые стоят внутри ИФА, внутри ИЛСА и так далее. Да,
внутри ФОРОВ. Итак, интересный кейс, который показывает, чем decision coverage отличается от
branch coverage. В чем особенность? В чем отличие этих двух функций? Да, побитывая И. Да,
смотрите, чтобы обеспечить decision coverage 100 процентов, нам нужно будет проверить,
что каждый из внутренних скобок в каждом операнте выполняется хотя бы один раз. То есть нам
нужно будет привести примеры, что A меньше 5, A больше 15 и так далее. А вот у нас получается,
чтобы достигнуть decision coverage в 100 процентов, нам нужна пара A меньше 5, B больше 15. Кажется,
такая. Для того, чтобы получить decision coverage и там, и там 100 процентов. Decision,
то есть что мы каждый логический оперант пройдем как минимум один раз. Нет, я имеется в виду,
хочется сказать сейчас. Хорошо, но по крайней мере точно можно сказать, что код с точки зрения
обветвления coverage будет сильно разным. То есть справа, грубо говоря, branch coverage можно получить
достаточно легко, закинув один тест. Здесь же нам одного теста не хватит. Ну да, нам нужен тест,
где A больше 5, а второй тест, который нам нужен на самом деле, нам нужен еще один тест, в котором A
меньше 5. Ну потому что нам нужно разматывать эту логику. Нет, для decision, сейчас давайте подумаем,
сколько нам. А для decision 2 тоже нужно. Ну смотрите, нам нужно, чтобы у нас все операнты были хотя бы
один раз true выполнены. То есть получается у нас первый тест, допустим, A больше 5, B получается
меньше 15, A меньше 5, B больше 15. Вот два теста. Тут иногда бывает разная трактовка. В некоторых
трактовках говорят следующее, что давайте мы с вами попробуем именно тестировать в outcome,
то есть что каждое решение было принято как минимум один раз. То есть решение там связанное
с true и с false. Иногда нам нужно именно все логические операторы проверять. А в branch coverage
тоже на самом деле те же самые тесты будут проходить. На самом деле здесь нужно будет больше тестов.
Вот. И A меньше 5. Вот. То есть в decision coverage нам хватит двух тестов. В обоих случаях. В двух
случаях. А вот в этом случае для branch coverage нужно будет три теста. Нам нужно будет пройти по всем
веткам. И последний есть coverage, который обычно никто не измеряет, потому что избыточное тестирование
невозможно. Это path coverage. Количество пройденных путей. От начала до конца процент. Опять же видно,
что процент пройденных путей может быть очень большой. Очень маленький. То есть все пути вы
точно не пройдете. А еще непонятно, что делать с циклами. То есть там нужно считать, типа,
прошли вы ноль раз, один раз или больше одного раза. Вот. Какая строгая сложение, как вы думаете?
Какой самый строгий coverage? Path coverage. Path, да. Path coverage самое строгое. Остальные могут быть
между собой не взаимосвязаны. То есть существуют такие примеры, когда один вид coverage перекрывает
другой вид coverage и наоборот. Так, сто процентов path coverage. Как вы думаете, стоит ли добиваться
сто процентов path coverage? Конечно нет, потому что избыточное тестировать невозможно. Отлично.
Вот. И давайте последний момент, который разберем. Сегодня я сделаю затравку. В следующий раз мы с
вами... Ой, блин. Кажется, тут все плохо. Ладно, надо будет его переводить на какую-нибудь другую тему. Да,
мутант. Смотрите, давайте я скажу следующее. У вас слева есть функция add, которая возвращает
a плюс b. Сверху функция, которую вы делаете следующее. Вы пишете просто a плюс b и потом возвращаете
null. То есть вы забываете ключевое слово return. Ну просто дайте return, зачеркиваете в вашем коде.
Во второй части вы передаете... Господи, что там? Вы меняете public на protected, а в третьем
кейсе вы плюс на минус меняете. То есть вы реально это можете автоматически запрограммировать. То
есть каким образом вы меняете операнды. И дальше вы проверяете ваши тесты. Значит, если внезапно
ваш framework, ну или ваши тесты пропускают один из этих вариантов, то у вас появляется мутант.
Да, и это как раз говорится, какой процент мутирующих вариантов у вас не проит. То есть
mutation coverage это как раз процент тестов, который был, точнее процент мутантов, который не был
определен, не отломлен ни одним тестом. Не отловлен ни одним тестом. В чем заключаются цели
мутационного тестирования? Цель заключается в том, что слабо протестированные участки у нас есть,
и при этом у нас остаются мутанты. После этого мы можем слабые тесты обнаружить, потому что,
если у нас есть слабые тесты, то есть у нас каркас маленький, и мы грубо говоря тестировали наш код,
грубо говоря, нашу систему на скорости ветра 1 метр в секунду, 2 метра в секунду, 4 метра в секунду.
Не протестировали на 8 метров в секунду. Берем 4 на 8 и меняем, у нас вылетает все в их хлонину.
И дополнительно мы можем проверить, какие ошибки могут внести в программу. То есть потенциально
какая именно проблема с логикой нашего процесса может существовать. Это что касается тестирования
белого ящика. В следующий раз мы поговорим про методики тестирования и добьем тему,
связанную с тестированием, и, собственно, после этого напишем контрольную. Ну, имеется в виду
через раз, не в следующий раз контрольную. Если есть вопросы, задавайте.
