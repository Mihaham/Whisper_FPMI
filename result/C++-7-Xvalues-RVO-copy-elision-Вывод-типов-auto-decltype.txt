Мы почти закончили тему Move Semantic Air Value ссылок,
и нам осталось обсудить одну связанную вещь,
а именно понятие Return Value Optimization и Copy Elysium.
Прежде чем я расскажу, что это такое,
я бы хотел как раз вернуться к вот этой таблице,
где мы определяли, что такое L-Value и R-Value,
и поговорить о том,
что это такое R-Value и R-Value.
Но я думаю, что на самом деле это не все категории и значения,
которые есть и плюс-плюс 11.
Параграф 10.9 будет назван RVO and Copy Elysium.
Смотрите, в стандарте, начиная с 2011 года,
категории и значений на самом деле стало не 2, а 5.
И выглядят они следующим образом.
Есть так называемое GL Value,
а есть R Value.
R Value.
Частным случаем GL Value является,
а еще есть загадочное понятие X Value,
которое одновременно является частным случаем GL Value
и частным случаем X Value.
А давайте я расшифрую, что значат эти слова.
GL Value.
Означает Generalized L Value.
Как бы обобщенное L Value.
Что такое Pair Value?
Это сокращение от Pure R Value.
Истинное R Value.
А X Value расшифровывается как Expired Value.
И это Pair Value.
И это Pair Value.
И это Pair Value.
И это Pair Value.
И это Pair Value.
Все то, что я раньше говорил про L Value и R Value, это правда.
То есть вот это все по-прежнему является L Value,
а это все по-прежнему является R Value.
Именно вот в старом смысле.
Вот это L Value, а это R Value.
Просто надо сейчас понять, что L Value – это лишь частный случай
некоторой более общей концепции Generalized L Value.
А R Value включает в себя как X Value, так и Pair Value.
Что?
Из перечисленного является Pair Value.
Все, кроме вот этого вот как раз.
Вот это…
Ой, виноват.
Кроме вот этого.
Вот это X Value.
Значит, все вот эти вещи, которые я назвал R Value,
они на самом деле Pair Value.
И только начиная с C++11 появилась особая,
подкатегория R Value, которая называется X Value.
И к ней как раз относятся вот эти вот вещи.
Возвращаемая R Value ссылка из функции и результат каста.
Ну, а также вызов метода…
Ну, давайте почитаем просто.
Вернемся на описание Value категории.
Возвращаем X Value.
Какие выражения X Value?
Значит, вызов функции, у которой возвращаемый тип R Value Reference.
Результат каста к R Value Reference.
Ну, а также, очевидно, следующее из этого.
Результат вызова квадратных скобочек.
Если у меня массив…
Там был R Value.
Результат обращения к члену точкой.
Если этот объект был R Value.
R Value, причем, заметьте, не обязательно X Value, просто R Value.
Результат обращения точки со звездочкой.
Результат тернарного оператора в определенных условиях.
Ну и, в общем-то, все.
Все остальные R Value – это Pair Value.
Вот для понимания Move Semantics на самом деле понятие X Value не нужно.
Вот все, как работают Move и Forward, мы уже поняли без вот этого X Value.
Для чего же в стандарт ввели это понятие X Value?
Почему?
Что означает слово Expired Value?
Типа просроченное Value.
Смысл в том, что это выражение, представляющее собой объект,
который реально существовал когда-то, жил, имел имя,
но сейчас он трактуется как R Value.
То есть, это реально существующий объект,
который когда-то кем-то трактовался как L Value,
но теперь он трактуется как R Value.
Expired Value.
В чем смысл?
Почему нужно объединять X Value и L Value в одну общую категорию JL Value?
Почему?
Вот мы можем тут посмотреть на определение того, что такое R Value.
Вот R Value – это просто Pair Value или X Value.
И на самом деле у них известные нам свойства, мы их все обсуждали,
и понятно, что X Value и Pair Value, они почти одинаковыми свойствами обладают.
Но какие же свойства X Value отличают его от Pair Value?
Ну, тут, по сути, есть всего три пункта, из которых первый – это несодержательный,
просто говорят, что JL Value может быть неявно сконвертированно в Pair Value,
но это не говорит нам о свойствах самого JL Value.
По сути, содержательных свойств только два.
Значит, JL Value может быть полиморфным,
а именно динамический тип может не совпадать со статическим типом.
А также JL Value…
JL Value может иметь incomplete type.
Давайте сначала разберемся, что значит, что JL Value может быть полиморфным.
Ну, смотрите, если я возвращаю из функции R Value ссылку на родителя, скажем,
то тип этой ссылки…
Base двойной имперсант может на самом деле скрывать под собой наследника.
Да, ну, то есть с Pair Value так не бывает, с X Value так и бывает.
То есть для X Value должна быть построена таблица виртуальных функций, по сути.
Если у вас X Value объект, объект, ну, точнее, если у вас X Value выражение ссылочное на какой-то объект,
то это должен быть объект, у которого в рантайме построена таблица виртуальных функций,
точнее, у которого есть указатель на таблице виртуальных функций,
потому что его статический тип может не совпасть с динамическим.
Ну и can have incomplete type.
Что такое incomplete type?
Это когда вы, например, объявили какой-то класс, но не определили его.
Тогда вы не можете создать Pair Value такого типа, но можете создать X Value.
Я не понял, что мы сейчас, чего пытаемся отличить.
Тут написано GL Value, и мы пытаемся отличить L Value от X Value,
но ты говоришь, что мы пытаемся отличить JL Value от Pair Value.
JL Value.
JL Value – это либо L Value, либо X Value.
Вот их общее свойство, вот эти два, которые отличают их от Pair Value.
Может быть полиморфным, может иметь incomplete, может иметь неполный тип.
Так, ну это все еще ничего не проясняет,
и вот на самом деле кажется, что это какие-то странные формальные определения,
непонятно зачем нужны.
Сейчас я попробую навести какой-то смысл содержателей под это подложить.
И для того, чтобы под это подложить содержательный смысл,
мы как раз вернемся к коду и поговорим о том, что такое Copy Elysian.
Вот смотрите, ну давайте я открою новый файл.
Значит, это пункт 10.9, и последний в этой теме – RVO and Copy Elysian.
Вот смотрите.
Вот я пишу std string str равно std string от Pair Value.
Аббат с.
Вопрос.
Сколько раз будет вызван конструктор string?
Наверное, один раз вопрос поставился такой.
Да.
Ну, казалось бы, если формально следовать правилам языка, которые мы до сих пор знаем,
то должно быть два раза.
Но если в SimpleSys 0.3, то вообще два раза, причем еще и с копированием.
Но после того, как мы мув семантиково узнали, мы поняли, что второй раз уж точно не требуется копировать. Ну что сейчас происходит? Тут создается стринг от стринг. Справа же стринг, справа rvalue стринг.
И поэтому, создавая стринг, вот от этого стринг не нужно копировать, можно мув-конструктор вызвать и мувнуть.
Но это все еще звучит как что-то не очень оптимальное. Зачем мувать? Хотелось бы, чтобы вызывался всего один конструктор.
Хотелось бы, чтобы стринг сразу создавалась на месте, где надо, никакого промежуточного.
Стринг бы не создавалась. Так оно и работает.
Зачем мы вообще так пишем? Зачем мы пишем так, а не str от abc?
Ну, если тебе не нравится такой пример, я могу тебе привести такой пример.
Ну давай std vector.
std vector от int, а тут я верну std vector от int, там от 10, запятая 1.
Вот здесь сколько раз должен вызваться конструктор вектора?
Убедил.
Хочется, чтобы вот при такой записи конструктор вызывался лишь один раз.
Что?
В первом случае, что в втором случае?
Как этого добиться?
Это работает.
Гарантированно.
На практике это и в C++11 уже так было.
Да и до C++11 во многих случаях уже так работало.
Но в C++11 это почти все компиляторы в большинстве случаев стали поддерживать.
Большинство ситуаций подобных.
В C++17 это гарантированно.
Стандартно.
Как работает.
Был такой пропозал, который не без участия наших российских ребят приняли.
Назывался ultimate copy elision.
Вот это явление называется copy elision.
То есть, казалось бы, нужно сначала создать вектор, потом из него создать вектор, потом из него еще создать вектор.
Пусть даже move'ом.
Это все равно как-то выглядит довольно...
По-тупому.
Зачем три вектора создать, а нужно сразу один создать?
И вот тут как раз нам пригождается понятие pair value.
Дело в том, что у pair value есть следующее интересное свойство.
Pair value не обязано соответствовать какому-то реально существующему...
В памяти объекту.
Это может быть такая проходная вещь, которая только вот в создании компилятора существует,
но в реальности никакому объекту в памяти не соответствует.
А x value обязательно соответствует.
Понимаете идею?
Вот это pair value.
И это pair value.
Компилятор имеет право...
Для pair value просто не создавать объект, соответствующий ему.
Он может мысленно проделать все преобразования одного pair value в другое pair value в таком количестве,
пока не дойдет до какого-то уже места, где финальный объект создается.
Вот в данном случае компилятор вызовет конструктор вектор лишь один раз.
И это будет конструктор от чисел 10 и 1.
И создаст v сразу.
Компилятор увидит, что тут возвращается pair value, которым инициализируется pair value,
и с помощью pair value инициализируется вот это v.
Поскольку это все было pair value, можно не создавать их в промежуточных шагах,
а просто создать сразу v от нужных параметров.
Это называется copy-election.
Но если бы это было x-value, то уже не так.
Правда, кажется, была бы...
Нет, вот смотрите.
Давайте теперь представим, что это у меня x-value.
Вот сейчас у меня f, круглые скобочки, это x-value.
Для x-value компилятор обязан создать объект ему соответствующий.
И x-value, в отличие от pair value, нельзя мысленно проглотить и сказать,
ну мы не будем его создавать, мы пропустим и посмотрим, к чему оно в итоге приравнивается.
Тут компилятор создаст этот вектор и r-value ссылку на него сделает.
Ну а дальше что?
Ну дальше произойдет, кажется, ub, потому что...
Произойдет продление жизни ссылки.
Но она продлевается, покуда мы из функции не выходим, а мы выходим из функции,
поэтому у нас ub.
Но сейчас я думаю, какой бы пример привести, чтобы это было жизненно.
Ну окей, смотрите, давайте вот так.
В некоторых ситуациях, в общем, компилятор не может вот так вот это все пропустить,
и он должен создать промежуточный объект.
Но вот с возвращением r-value ссылки отсюда не очень хорошо.
Ну давайте скажем, допустим так, вот у меня есть моя структура.
В ней опять-таки есть поле std-вектор int v.
И здесь я возвращаю v, но этот вектор, он по умолчанию там...
Правильно, std-вектор int от 10 до t1.
А эта штука, она, значит, его мувает.
Так, я что-то сейчас нафантазировал тут.
Сейчас я подожду, сейчас я соображу вообще-то нормально.
Хорошо.
Вот, извините, забудьте про эту функцию вообще.
Вот давайте представим, что я написал вот так.
mystruct.v.
Вот что я сделал.
Все, забудьте про f.
f.
С f не получился пример.
Вот у меня было два примера.
Первый пример это просто сказал равно f, результат вызова f.
А второй пример вот такой.
std-mystruct.v.
И тут есть поле v.
Эти две ситуации отличаются, потому что вот это уже не pr-value, это x-value.
Почему это x-value?
Потому что это оператор точка, у которого левый оперант r-value.
В такой ситуации компилятор не имеет права...
Ну, то есть, может, он имеет право, но не обязан.
Так, правильнее сказать.
Пропустить, мимо, так сказать, мимо глаз, не создавать промежуточный mystruct,
и в нем, типа, сразу понять, что ничего не происходит,
и просто вектор v провинциализировать сразу 10.1.
Вот здесь компилятор, скорее всего, создаст промежуточный объект mystruct.
Значит, еще раз, в чем идея?
x-value – это объект, который...
Это такое выражение, которому соответствует реальный существующий объект.
pr-value может не соответствовать никакого объекта в памяти реальной.
Отсюда вывод, если у меня несколько pr-value последовательно итилизируют друг друга,
то объект при этом может создаться лишь один раз.
Если где-то по дороге было x-value, то объект создастся один раз.
В этот момент.
Если бы был бы static, было бы pr-value.
Кажется, да, потому что в определении x-value было написано, что он static должен быть.
Вот.
Вот это явление называется temporary materialization.
Значит, какое именно явление?
Явление, что из-за того, что мы pr-value на каком-то шаге превращаем в x-value,
его приходится реально создать.
Вот здесь происходит temporary materialization.
Причем я раньше сам неправильно переводил это.
Не временная материализация.
Temporary здесь – это существительное.
То есть это словосочетание существительное и предсуществительное.
Материализация временного.
Temporary – это...
Это временный объект, который проскакивал сквозь функции и не создавался.
Если в какой-то момент, на каком-то этапе его превратили в x-value,
к нему обратились через выражение, которое x-value, он создается в этот момент.
И вот здесь, скорее всего, конструктор будет вызван дважды.
Ну, второй раз будет move конструктор, но все-таки дважды.
Вот что такое copy-evision.
Понятно?
Понятно.
Теперь что такое return-value-optimization.
Return-value-optimization – это ситуация, когда у вас функция возвращает объект по значению,
при этом объект локально создан в этой функции,
и, казалось бы, его можно не копировать.
Сразу понятно, что он и будет возвращен.
Вот здесь происходит return-value-optimization, это частый случай copy-evision.
Когда речь идет о возвращении из функции.
Вот здесь происходит return-value-optimization.
Интерес представляет случай, когда у меня имеет место так называемое
named return-value-optimization.
Что это такое?
Это ситуация, когда я создал
там какой-нибудь результат,
написал вот так, и вернул результат.
Вопрос – вот здесь сколько раз вызывается конструктор вектора?
Ну, то есть, если я сделаю вот так.
В этом функция будет называться g.
Сможет ли компилятор здесь избежать второго вызова конструктора вектора?
Скорее всего, сможет, но не обязан.
Компилятор имеет право не создавать вектор второй раз,
если он понимает, если он видит, что вы возвращаете из функции объект,
который локально в ней же и создали.
Вот.
Помните, я вам показывал пример про…
Один из наших первых примеров был про сложение двух big-интеджеров.
Вот я вам говорил, что сложение big-интеджеров,
big-интеджер оператор плюс,
можно было бы определить так –
big-интеджер a const big-интеджер ampersand,
ретерн b, и что сделать?
a плюс равно b, ретерн a.
Вот в такой ситуации big-интеджер вряд ли…
Компилятор вряд ли сделает return value optimization.
Я так думаю, он не сделает, потому что a – это объект, созданный не…
Ну, может, и сделает, конечно.
То есть a – это объект, созданный не…
Ну, может, и сделает, конечно.
А a – это объект, не являющийся локальным, как бы, объектом, созданным функцией.
Это аргумент функции.
Вот в такой ситуации я…
Компилятор return value optimization, хотя может и сделать, я не уверен.
Ну, может, и сделает.
Вот.
Более интересна ситуация, когда компилятор…
Когда мы пишем вот так.
Допустим, я сюда принял big-интеджер тоже по константной ссылке.
Вот здесь компилятор наверняка сделает return value optimization.
Однако, если бы я написал вот так, компилятор бы не сделал return value optimization.
Это довольно интересная ситуация, которую в первом семестре в прошлом году мы…
Я имею в виду в прошлом учебном году.
Вы заметили.
Так.
Микрофон там у кого-то включен.
Вот.
Что компилятор справляется с RVO, только если он явно видит, что возвращается то же самое, что только что создали.
Вот если так написать, это выглядит короче.
Ну, и оптимальнее вроде как.
Но компилятор не справляется сделать RVO.
Ему приходится делать лишнюю копию.
Вот в такой ситуации можно было бы написать std move.
От вот этого.
Тогда компилятор бы мувнул.
Но вообще, если вы из функции возвращаете объект, который в ней же локально и создали, писать std move не нужно.
И вот это как раз вопрос, который вы задавали там полтора часа назад.
Вот в такой ситуации не надо писать std move от копии.
Потому что компилятор должен сделать RVO.
И даже если по какой-то причине у него не получится RVO сейчас, он мувнет все равно.
Вот компилятор, если имеет дело с локальным объектом, если вы возвращаете из функции переменную, которая локально создана в этой функции,
компилятор обязан либо сделать RVO, либо мувнуть сам по себе.
Не надо писать std move, потому что этим вы лишите его возможности сделать RVO.
Если я здесь напишу return std move от копии, компилятор гарантированно вызовет move конструктор.
Но если бы я не написал, компилятор бы попытался сделать RVO.
И только если бы не получилось, вызвал бы move конструктор.
Поэтому здесь понятно, как работают RVO и копии.
Вот это называется RVO.
Когда компилятор может не смочь сделать RVO?
Он может не смочь, например, когда у вас тут какой-то if написан.
То есть, тут у вас создана копия 1, а еще копия 2.
И написано какой-то if, и в одном случае вы возвращаете копию 1, а в другом копию 2.
Тогда компилятор заранее в Compile Time не знает, что ему.
То есть, какой из этих объектов сразу конструировать на месте возвращаемого значения функции.
не нужно до вас им верном коде просто на месте возвращаемого значения функции в том регистре
условно куда кладется зачем значения сконструировать сразу вот этот объект если он
в рамках в компаниями не понимает что будет из этого возвращено то он может не смочь сделать
его в таком случае на улицам понятно ну конечно если ваш объект поддержку в семантике
да если это все было на примерах стандартных структур данных вообще все что вообще можно
поддержать поддерживают так если я пишу за какой-то своей структурой например
момент
от 10 то есть первый случай где общему в семантике не участвует сейчас маэстракт вы
равно что вот тоже снизу написано с вектором да да вызван конструктора потом равно нет это
не зависит вот вот этот вот то что сказал про муфти мать про копии лежит не зависит
от наличием в конструкторах да понятно для моего для моей структуры тоже будет вызвано
и
конечно это не зависит от того поддерживать твою структуру в семантику компилятор обязан
оптимизировать цепочки prv начинайся плюс 117 компилятор обязан если prv и инициализируется
через prv а потом этим что-то инициализируется то вот эту промежуточную штуку он не делает он
инициализирует сразу то что в конце не будет везти на концу оператор равно если переопределен
оператор равно оператор равно тут никак не участвовать только конструктор власти вот
то есть он тут написано но его тут нет реально вообще нет оператора представления нигде да
оператор равно вообще ни при чем здесь тут только вызов конструкторов речи только вызов конструктор
это не оператор равно да вот вот кстати говоря
еще один
интересный момент
давайте теоретически представим что у меня тип не поддерживает копирование а только мы поддерживают
вот
допустим у меня есть тип который поддержит только они копировали
получится ли скомпилировать или вот такой код
да скомпилируется ну то есть казалось бы я вызываю я возвращаю битвин таджер а написан
return копик опета и л валью казалось бы я создаю новый объект от л вайл и его возвращаю если у меня
объект если у меня у типа запрещен папе конструктор разрешен лишь move конструктор то казалось бы по
старым правилам это не должно скомпилироваться но нет это скомпилируется потому что не будет вызван и
будет вызван никакой конструктор а если даже и не получится его будет вызван в конструктор потому что
компилятор видит что мы возвращаем в точности переменную локальную которую создали в этой
же функции поэтому это будет компилироваться даже для объектов которых запрещен явно копи конструктор
мы же когда пишем беги дышит копировал мы тогда вызываем да это правда ну тут вот ну понятно да
вот так надо сделать и это будет компилироваться
можно еще раз тут прервал уточнить ну вот например вот как раз вот в этой функции у нас
какой момент копию так если ну то есть какой минус копия создается и когда вызывается его конструктор
если рассуждать низкоуровневая компилятор не видят ассамблерный код этой функции как
когда происходит вызов этой функции откуда-то компилятор в нормальной ситуации там
кладет нас так там что-то там параметры этой функции адреса возврата вы заходите в код функции и
начинается что-то происходить на стыке какие-то вещи начинают создаваться уже после того функцию
вызвали случай рву компилятор делает по-другому он не он как бы кладет вот тот объект который
вы локально собираетесь вернуть вот тот локальный объект который он знает что функции сейчас будет
создан и он будет возвращен он создает
не на стыке уже после того как положил туда все в эти самые параметры и адреса
возврата а в каком-то другом месте в каком-то регистре памяти процессора скажем куда должен
поместиться был возвращаем результат этой функции после его вычисления не создается на стыке объект
копия после того как функция вызвана а создается объект копии в другом месте не после не после не
за вот этими параметрами вот в том месте где он бы создал в нормальной ситуации возвращаем объект
он сразу создаст вот с точки зрения символизма года
вот окей
но можно открыть про это
значит
кстати вот пробитого и поля отдельное правило например значит если у вас
битовое поле то это всегда желаю expression
так
a можно открыть про это дело статью
ну вот тут написано темп что такое темпы рематизация начинать
117 вот тут перечисленные условия при которых происходит темпы рематизация
то есть создание объект вот этот пример который вам привел вот в этой в этом вот выражение павел и
превращается в x value и создается объект с
bemuse
теперь
примерно
она
имеет
такой
такой
рисунок
теперь
тогда
не
будут
увеличиваться
но
parallels
Au10
это он не может пропустить на этом все мы закончили тему максимально скорую ссылки
теперь начиная с этого момента во всех задачах мы будем требовать ее поддержки то есть ваша
задача с листом и строка локатором к там не буду симметрику все оставшиеся задачи мы будем
уже писать и обсуждать зная что у нас есть мы все мантика и что надо ее правильно поддержать
вот в частности вот я выложу на днях задача на удар тмэп которая в которой надо будет
переиспользовав лист который вы написали раньше или знать собственно на удар тмэп
но на этот раз уже с поддержкой муфти мантики ну скорее всего вам нужно будет муфти мантики
дописать и к листу тоже чтобы все правильно было там чтобы все мугалось когда не надо
копировать и копировалась когда не надо мугать я вас обманул я можно просто да
давай вопрос
а если бы я писал какие-то свои классы какие-то свои структуры полезные мне вообще мне же не очень
часто нужно было бы поддерживать мусульман почему они составные обычно у них во всех
и обычно у всех просто полях конь вектор лежит конь строка вот если есть объект мой
у которого просто несколько полей это ветора и строки автоматически мы в конструктор поддерживать
хорошо не будет или будет сейчас еще раз если у тебя в полях стандартные объекты ты можешь сказать
в конструктор равно дефолт а если этого не скажу то он не будет если у тебя ну это мы обсуждали в
прошлый раз если у тебя никаких конструкторов явно не определено то они все дефолта будут сами если ты
копий конструктор то есть правило 5 мув конструктор за тебя тогда не сгенерируется
но обычно мне об этом чтобы думать не надо мне в лучшем случае нужно писать равно ли пол
ну я бы так не сказал но ведь если у тебя все да хотя бы один указатель есть в полях то все
тебе об этом нужно думать ровно тогда ну как ты можешь таким же успехом спросить когда мне
нужно вообще не тривиальный конструктор копирования определять если у тебя хоть
что-то хоть какое-то более не стандартный тип что-то там ссылка указатель или массив
или что-нибудь в таком стиле или константа то все у тебя возникает вопрос как мувать
в бегунте ничего до бегунте ничего сайтом просто дефолтный подошел а стримы не подошел
бы потому что все
так я вас обманул вот в чем я сказал что все смысл мантикой еще не совсем все я чуть
не забыл еще один важный пункт и как хорошо что я про него вспомнил давайте я про него
сейчас расскажу смотрите пункт будет такой так ну что такое я опять вернусь к вектору
и это будет пункт 1010
давайте посмотрим еще раз вот на это
так не на это вот на резерв посмотрим
ну мы уже понимаем что тут должно быть написано на самом деле аллокатор трейд
а
а
а
а
а
а
а
а
а
а
а
а
а
а
а
а
а
а
а
а













아
вот давайте посмотрим на конструкторы вектора еще раз
посмотрите вектор от вектора но и xm начинайся efecto 17 почему-то только
интересно начинаю 117 а наверное потому что сама которым могла быть проблема
Gates
��는
Xss
Back seeming
gonna be
easy
лад не хочу разбираться в общем начинать 17 муф конструктор вектора это право вот с функцией
резерв на самом деле все еще немного сложнее а именно что если тип не поддерживает копирование
ну то есть смотрите я могу вектор создать из объектов которые нельзя копировать только
бывать можно что тогда будет если я резерву начну перекладывать а мы в конструктор не но
except при этом тогда цель и что не будет но вот в той реализации которая сейчас написал
получится и потому что я попытаюсь скопировать мне вернет это поэтому на самом деле это тоже
не совсем еще конец и нужно еще там ивчик написать некоторые то есть логика следующая
вот написано если мы в конструкторе
ну то есть вот то о чем я говорю если у меня в конструктор не но except и еще и скопировать
нельзя то вектор будет использовать в конструктор все равно и просто тогда будет говорить что нету
да тогда гарантии гарантия нарушается и все и
тем более а есть воевkar да и все вот 그래도 такойyeah примерно фаза
разработчиком ага то есть про вектор и motor trainer вы Birmingham
Tesla sei да читал про вектор у меня да ештstop
sinful tone тоと思います это ведь так alive ритм дорого спонсора
лучше затем скажем она присутствует так что если вы задумали на процессе объекта
то это соотечественная фаза только номер одинube а falsify или ваши замыкина то есть заболевает
она yelling да зачем такая фраза стрим как mountain но еслиits не значит что это code
неanderling ну написали свой string и 눌러 fl stupid но не знаю быстрее чем обычный вы думаете и
определенный себя сформулировать вот и как бы это может выглядеть ли вы можете дать себе
свой copy-конструктор и свой move-конструктор.
И забыли move-конструктор написать noexcept.
И стали вектор из таких строк создавать.
И в итоге у вас будет копирование этих строк при резерве,
а не мувание.
Потому что у вас copy-конструктор есть,
move-конструктор есть, и он не noexcept.
Значит, вектор, чтобы не нарушать гарантию,
начнет копировать вместо мува.
Такая история.
Помнишь, ты рассказывал, что noexcept –
это чисто такая пометочка,
чтобы авторам было легче видеть,
что он не вкидает, что он не вкидает.
Ну вот, да, но…
Вот отстой.
Не совсем.
Да, вот такой момент.
Вот отстой.
А как реализован move-noexcept?
Я сейчас не буду рассказывать,
потому что мы еще не знаем нужной шаблонной магии.
Но ближе к концу семестра мы поймем,
как он реализован.
То есть если noexcept, то move-нуть,
иначе не move-нуть.
Ну вот теперь точно все про move-семантику.
И в оставшиеся, сколько там у меня,
20 минут, я хочу поговорить про следующую тему.
Следующая тема будет очень короткой.
Она называется «вывод типов».
Значит, следующая тема очень короткая и простая.
Type deduction.
Type deduction.
Сейчас мы быстренько обсудим,
что такое авто, decal type и связанные с ними вещи.
И параграф 11.1 будет называться ключевое слово «авто».
Ну, я думаю, ни для кого не секрет, что такое авто.
Начиная с C++11, опять-таки,
вы можете заставить компилятор самостоятельно определить тип,
переменной, которую вы создаете,
которую вы объявляете,
исходя из типа выражения справа.
Вот.
Интересные вопросы возникают, как всегда,
когда начинаются приколы со ссылками.
Вот смотри,
int равно одному,
int r равно x,
я написал авто,
y равно r.
Вот.
Да.
Какой будет тип игрока?
int или int-инперсант.
Да, как-нибудь.
Вообще, скорее всего, int,
потому что можно написать авто-инперсант,
а это должно что-то значить.
Да. Значит, правильный ответ будет int.
И тут правило такое.
Авто работает так же,
как если бы это был вывод шаблонного параметра.
Ну, то есть,
как если бы,
бы вы передали в шаблонную функцию type name t t y и отдали 2 р вот так же и будет работать
этот вывод все очень логично поэтому если вы напишете авто амперсанд то будет одиночный
амперсанд если напишите авто без амперсандов то неважно сколько было амперсандов справа будет без
амперсандов ам а если два амперсанда как вы думаете это также как принятие
значит это универсальная ссылка значит это универсальная ссылка опять получится
персан да и будет им там персан давайте проверим вот сейчас я утверждаю что а
x изменится потому что у меня будет им там персан
читая не то сделал а мне на том что дедакшн
купить
вот в данном случае у меня получилась универсальная ссылка а если бы написал вот так
то это был бы было бы рвл и ссылка
вот-вот авто с двумя имперсант отличается
в данном случае
где вот-вот если я здесь напишу авто 1 амперсанд да будет цель и
ну ничем потому что р это вещь фиксированного типа но если мы находились шаблонной функции
где r само по себе могло бы быть то lv литой рвл ну нет хорошо
r всегда было бы r value всегда был бы l value поэтому
у нас бы получилась строчка авто двойной имперсант игр равно their где бы оно ни была
написано всегда Scene always строчки всегда даст лв литой ссылку
lv если бы справа было написано что-то странное например f от r и это все было бы шаблонным то
есть я бы находился в шаблонной функции было бы шаблонной то эта штука могла бы быть как
рвл и так и lv да понятно есть f могла мне бы вернуть как рвл и так и lv и в зависимости от
этого у меня y бы стал либо одиночными персонами либо двойными персонами вот иногда вы можете
встретить в каком-нибудь продакшн коде объявление с авто двойным персонам это нужно в тех ситуациях
когда то что справа может как рвл и так и лвл и оказаться в зависимости от ситуации и если мы
здесь замените на одиночный амперсант то вообще говоря это может иногда не скомпилироваться если
у вас справа рвл по какой-то причине вернулась а если вы просто уберете амперсанды то это приведет
к лишнему копированию внизу
ситуациях или к лишнему если у вас справа xpl и
хорошо дальше и так это тоже универсальная ссылка дальше а где еще может взять автор
но вообще хороший код style советует писать авто как можно чаще какие плюсы есть у авто
авто, вы точно не ошибетесь с типом.
Вот начиная с текущего момента, я буду вас призывать
и буду на код-ревью это заставлять исправлять.
Вместо явных названий типов писать авто, ну, кроме ситуации,
когда это, скажем так, не вводит в заблуждение остальных участников
дорожного движения.
Ну, то есть, кроме ситуации, когда надо написать типа,
то непонятно ни черта, что происходит.
Вот если у вас какой-то длинный тип, то прям сам Бог велел авто писать.
Потому что вероятность того, что вы случайно ошибетесь в типе
и вам не повезет, вы не словите CE, и будет лишнее копирование, высока.
Пример вы знаете, с unordered map мы разбирали.
Вы можете случайно забыть const перед ключом.
Вместо того, чтобы писать const stdpr key value, надо написать const stdpr
как const key, запятая value, а вы забудете второй const.
И у вас будет лишнее копирование.
Так вот, авто избавляет вас от таких проблем.
Поэтому, мораль, пишите авто, кроме ситуации, когда это по какой-то причине,
ну, когда у вас есть аргументация, почему вот сейчас лучше так не делать.
Вот.
Когда авто может внезапно оказаться, когда, например, может быть лучше так не делать?
Ну, например.
Вот когда.
Представь, что у меня есть вектор bool.
Я вам говорил, что вектор bool – это такой классный контрпример ко всему.
Как в ботане какая-нибудь функция sin1 делить на x, так у нас вектор bool.
Вот если я скажу вектор bool там авто x, авто b равно v нулевое,
то понятно, что будет.
Я получу не bool, а bitreference.
Вот, например, в такой ситуации авто неуместно.
Но это нам не сильно помешает, в общем-то.
Ну, потому что bitreference всегда ведет себя, как будто это bool.
Но, хотя нет, не всегда, потому что вектор потом может мувнуться куда-нибудь,
а bitreference останется.
Ну, в общем, наверное, можно придумать сценарий, когда это будет плохо.
Вот.
Ну, другой сценарий, но это уже вкусовщина.
Мне лично.
Иногда бывает тяжело читать код, когда там очень много авто.
То есть иногда хочется написать не авто просто, чтобы явно сказать читателю кода,
что я такой тип ожидаю, чтобы было проще выражать явно свои мысли.
Но в большинстве случаев это не нужно, и лучше писать авто.
Идем дальше.
Где еще можно писать авто, кроме как при объявлениях переменных?
Можно писать авто при объявлениях функций.
То есть я могу, опять же,
на C++11 сделать функцию, которая имеет возвращаемый тип авто.
Компилятор сам выведет возвращаемый тип по выражению, которое после return стоит.
И, опять же, я могу написать как авто, так и автоамперсант, так и авто2амперсанта будут опять работать те самые правила.
Я могу написать const автоамперсант.
Да, вы, конечно же, тоже понимаете.
Все работает как с шаблонным параметром t.
Я могу написать автозвездочка.
То же самое, как и с t.
Считать, что авто – это как будто t подставленный.
Все это будет работать так же, как в случае с шаблонными функциями,
как будто я подставил туда тип.
Понятно, что если я, например, сделаю вот так,
и в x больше 0, то return 1.
А иначе return 0,5.
Я какую-то чушь написал.
Ну вот, что сейчас произойдет?
Ну, это будет не c, ну или точно w будет возвращаться.
Вот. Ну, произойдет c, потому что конфликтующий return type.
Если у вас разные ретерны…
Ой, что происходит?
Что?
Так, извините.
Если у вас ретерны с разными типами,
то авто не способно понять, какое оно нужно вывести тип,
и выдается e.
Дальше.
Но если бы это был тернарный оператор,
если бы я написал return x больше 0, знак вопроса 1, 0,5,
то возвращаемый тип был бы double, понятное дело,
потому что тип выражения определяется однозначно.
При разных ретернах тип уже однозначно не определяется.
Так, ну хорошо.
Ну, хорошо.
Сейчас.
Сейчас я подсмотрю, что еще сказать надо.
Ну, в принципе…
В принципе…
Про авто, наверное, все почти.
Вот за каким исключением.
Начиная с C++20 еще можно стало писать авто
в принимаемых параметрах функций.
Вот здесь.
Это то же самое, что писать template.
Только…
Да.
То есть, начиная с C++20, просто это такие шорткаты для того,
чтобы написать template type name t,
void f от t, x.
Ну, кажется логичным, что можно просто писать авто x вместо этого,
и оно должно работать.
Правда, если у вас таких типов несколько,
то, ну, если вам надо, чтобы шаблонные типы там первого и второго аргумента
были одинаковыми, тут уже так не получится.
Но если у вас там они никак не связаны,
то можно писать авто, и оно должно заработать.
Начинается с C++20, то есть это прям свежачок.
Это прям недавнее нововведение.
Еще не все компиляторы поддерживают, я думаю.
Вот.
Ну, в принципе, все, что я хотел сказать про авто сейчас.
И давайте я скажу дальше про decal type.
Что такое decal type?
Декал type.
Декал type – это второе…
Очень полезное слово, тоже начиная с C++11 появившееся,
которое вам позволяет в compile time вернуть тип выражения,
которое вы под ним поставили.
Ну, например, я написал int x равно 5,
и decal type от x, y равно 6.
Декал type берет в скобках какое-то выражение
и в compile time заменяет себя на тип выражения,
которое вы подставили.
Вот.
Ну, я не уверен,
что я могу привести пример сейчас достаточно практически полезный,
когда вот именно в таком виде decal type надо применить.
Но decal type можно применять очень удобно для ситуации,
когда надо, ну, например, понять, что сейчас вывелось,
вот какой тип выражения,
какой тип имеет данное выражение в данной функции.
Как, например, когда бы нам это могло пригодиться?
Вот у нас…
Мы тут с вами…
Мы тут с вами обсуждали forward тот же.
И я тут писал там is same way, вот это вот все.
Я мог бы…
Вот я узнал, какой тип у t.
Что такое t.
А как мне проверить, какой тип x реально получил?
Вот здесь.
Я могу написать decal type от x вот здесь.
Ну, то есть, если я хочу понять, какой тип сейчас имеет переменная x,
то я могу написать decal type от x.
Важный момент про decal type.
Он не отбрасывает ссылки, в отличие от авто.
У decal type другие правила вывода типов, нежели у авто.
Decal type не отбрасывает амперсанды.
Если у меня был бы…
Была бы вот такая ситуация, что r от x…
Я сказал decal type r от y равно…
Снова x, а потом поменял бы y, то x бы поменялся.
А можно написать decal type от r амперсанды?
Да, можно.
Чего я не вывел, сейчас выведу.
Estesiaut y.
Ой, estesiaut x.
Вот, x стал…
А можно было бы и так сделать.
Decal type от x…
Ну, да, понятно, что если бы я, например, вот так написал,
то это было бы ce, потому что я фактически объявил ссылку
и попытался проинциализировать pure will.
А можно было бы и так написать decal type от x амперсанд к этому.
y равно x.
Я навесил амперсанд на результат decal type.
Получилось снова то же самое.
Мой любимый вообще максимально упоротый пример –
это вот такое выражение.
Смотрите.
Что если я напишу decal type от throw std exception,
std runtime error?
Звездочка p равно new int.
Чего?
Ну, смотрите, это все работает очень формально.
Я могу…
Ну, new int, ну, ptr, давайте.
Пишу.
Какой тип имеет выражение throw что-то там?
Оно имеет тип void.
Поэтому если я сделаю decal type от throw,
а потом звездочку к навешу, получится void звездочка.
Ну, до такой степени смешно.
Ну, это, конечно, дурацкий пример.
Так никуда никто не делает, но это просто смешно.
Вот, хорошо.
Смотрите.
Смотрите.
Ну, я могу, понятное дело,
навешивать двойной имперсант.
Вот, например, ну, давайте опять упражнение.
То есть я так напишу, что будет.
Универсальная ссылка, значит, просто ссылка.
Нет, это будет ce.
Это уже не универсальная ссылка.
Decal type от x заменяется на int.
У меня как будто написано int двойной имперсант y равно x.
x – это не r, v, l, u, поэтому это ce.
А, да.
Значит,
универсальные ссылки бывают только при шаблонных параметрах
и при авто.
Вот это уже не универсальная ссылка, поэтому это ce.
Вот.
А если бы я так написал,
то что было бы?
Нормально, потому что был бы один имперсант.
Да, это был бы референс коллапсинг.
Получился бы один имперсант.
Хорошо.
Еще важное замечание про Decal type.
Decal type, как и sizeof, как и noexcept, как и typeid,
не вычисляет выражение под ним стоящее.
Он лишь говорит, какой тип был бы, если бы оно вычислилось.
Если я говорю Decal type от плюс-плюс x,
то x не увеличится.
А теперь еще более странное.
Это не странное правило.
Если Decal type вызываю, то вычисление выражения не происходит.
Просто возвращаю его в своего типа.
А вот теперь странное правило.
Decal type не отбрасывает имперсанты, но иногда навешивает имперсанты.
До сих пор я рассматривал только Decal type от имен переменных.
Если я возьму Decal type от выражения,
то
я могу сказать, что это не странное правило.
Иногда Decal type навесит имперсант на него.
Например, как раз сейчас.
Я написал Decal type от плюс-плюс x, y равно x.
Как вы думаете, какой тип будет у y?
Секундочку.
Что такое Decal type от плюс-плюс x?
Плюс-плюс x возвращает имперсант сам по себе.
Какой тип был бы, если бы был плюс-плюс x?
Да, то есть
тип плюс-плюс x, он
ну, на самом деле
я не уверен, что он
прям что-то там возвращает,
потому что это встроенная в язык вещь.
Но это
L-value. Это L-value типа int.
Это то, чего можно присваивать
и тип у него, и оно
как бы int.
Чтобы
вот это было консистентно,
с нашим пониманием того, что такое
L-value, L-value в плане имперсантов,
тип возвращает имперсант сейчас.
Вот сейчас будет int-имперсант.
Вот если я так напишу...
Decal type ничего не навесил.
Я не понимаю, почему ты говоришь, что
ничего не навесил.
А вот так...
А вот так будет просто int.
Да, и это логично, в смысле.
Если мы напишем Decal type от x плюс,
равно y, тоже будет
int-имперсант.
Ну, x плюс равно что-нибудь.
Ну...
Он же не сам навешивает.
В смысле, он просто берет реально
и вообще... Да, вот просто у int-ов
не так хорошо определен, потому что int-ы — это не структура.
А если бы была наша структура,
это было бы совсем очевидно.
Что за звуки там?
Да.
А что, если бы я вот так написал?
Просто int.
Вот, и сейчас будет
int-имперсант.
Вот это, что я имею в виду, когда говорю, что он навешивает
имперсант на l-value.
Если у меня l-value, причем не просто
имя переменной, а какое-то нетривиальное
l-value, появляется лишний
имперсант.
Я думаю, это связано с тем, что
формально в стандарте нету... То есть
плюс-плюс x, он
не возвращает
в стандарте.
int-имперсант.
Он имеет тип int.
Плюс-плюс x имеет тип int.
И это l-value типа int.
То есть в стандарте
это не функция просто,
это встроенный оператор.
Про него нет смысла спрашивать, какой у него
возвращаемый тип. Он int.
Там нету ссылки. Про ссылку
это начинает быть осмысленно говорить только,
когда у вас свои собственные операторы.
Поэтому с decltype такое правило.
Он просто, если l-value,
он имперсант сам добавляет.
Это приводит к тому, что decltype от плюс-плюс x
это int-имперсант, но как следствие
это приводит к тому, что decltype от вот такого
это int-имперсант.
А что еще более
смешно или грустно, я не знаю.
Если написать x в скобочках,
то это тоже будет
имперсант лишний. Потому что
x в скобочках это уже не просто
переменная,
это переменная, это не тривиальное выражение,
это скобочки.
И сейчас опять будет int-имперсант.
Вот.
А если выражение
x-value, то он 2-имперсантно
добавляет.
Например,
если у меня есть
структура,
структура
s,
в ней есть поле m,
и я написал
decltype
s, круглой скобочке, точка m,
то тип этой штуки
будет не int, а int-двойной имперсант.
Потому что работает следующее
правило. Если у вас x-value,
то decltype возвращает
вам тип с двумя имперсантами.
В круглой скобочке точка m, как мы знаем,
это x-value. Поэтому сейчас будет
ce из-за того, что справа не
r-value.
Так, чего?
Ух ты, я вас обманул.
Значит, не так, а как же.
Хм.
Возможно, там есть исключение
из правила, которое я
не знал. Сейчас я его
найду.
Ну и на этом мы закончим.
Кажется, это такое же исключение, когда мы просто
имперемены пишем на super-effet.
Ну вот, да, написано.
Если аргумент — это
любое другое...
А, да. Если аргумент — это
просто не в скобочках
id-expression, то есть
импеременный, или
class-expression — это то, что я сделал
сейчас, то тогда он просто
возвращает тип этой штуки.
Да, это попадает вот в этот пункт.
То есть это как будто считается, мы просто
имя переменное написали.
А дальше,
работает правило, что если
value-категория — это x-value, то у нас
получается тип с двумя амперсанами. Если
l-value, то с одним амперсаном, а если
pair-value, то просто
тип без амперсан.
Сам x тоже l-value. Почему? Потому что
я говорю, потому что вот это правило, вот оно. Если
у нас просто имя переменной, то
вот так.
На самом деле тут просто
два разных
типа decl-type'а. Один для
entity, другой для expression.
Ну все. На сегодня
все.
