Давайте начинать. Значит, сегодня у нас начало второй половины курса, где мы будем говорить про формулы с кванторами.
Тут действительно небольшой предтечей была как раз 33 задача из сет-контрольной, которая вызвала много вопросов.
В том числе там был вопрос, что что-то вообще не булева формула.
И имел в виду следующее, что если какой-то знак встречается одновременно и как индекс, и непосредственно как переменная формуля, то вот это уже не булева формула.
То есть получается, что есть зависимость одной переменной от другой переменной.
Ну а если есть такая зависимость, то дальше можно какие-то кванторы на это навешивать.
И в целом получается то, что называется языки первого порядка.
И вот это наша тема до конца семестра.
Языки первого порядка.
Ну и связанная ими логика первого порядка.
Но пока что сегодня сегодня будем говорить именно про язык.
То есть про то, как формулы строятся и что они означают.
А про логику как бы как это выводится.
В узком смысле про логику, то есть про выводимость мы в самом конце поговорим.
А несколько лекций будут про то, что формулы означают, как их интерпретировать и так далее.
Так, давайте вкратце про что этот раздел и почему тут первый порядок.
Если первый, наверное, и второй бывает. Бывает второй, но в нашем курсе не будет.
Значит, можно сказать так, что могут быть какие-то выражения с параметрами.
Значит, это во-первых могут содержать выражения параметрами.
И эти выражения могут быть типа функции и типа отношения или операции отношения.
Вот, то есть есть эти выражения делятся на два типа.
Значит, это могут быть термы.
Но это такое обобщение алгебрических выражений.
То есть там могут быть какие-то знаки, которые как принимают значение в каком-то множестве.
Их можно комбинировать, и операции тоже берут значение из этого множества и возвращают новые значения из этого множества.
Можно сказать, что термы это обобщенные алгебрические выражения.
Вот, и есть, собственно, формулы.
А это, можно сказать, обобщенные булевые формулы, где вместо переменных могут быть как раз тамарные формулы.
Но сейчас я пытаюсь кратко сказать длинное определение.
В общем, можно сказать так. Если коротко, значит, это выражения, которые могут быть истинные или ложные.
То есть, например, если вот какой-нибудь терм, это вот что-то такое.
Скажем, sin x plus y в степени z поделить на логарифм n по основанию 2.
Вот это, если подставить какие-то конкретные x, y, z и n, то это будет чему-то равно, если еще на 0 не поделим.
Считаем, что на 0 тоже можно делить, и получается, скажем, какое-нибудь специальное значение не определено, или специальное значение бесконечности.
Если 0 на 0, то неопределено, если положительно на 0, то плюс бесконечность, если отрисоветельно, то минус бесконечность.
И дальше еще нужно определить, что означает, если на бесконечность плюс или минус, тоже формулы подставляем.
в общем, можно доопределить рейсметику так, чтобы на ноль можно было делить
какими-то специальными значениями. Вот, тогда, соответственно, для любых конкретных
значений x, y, z, n у этой штуки будет какое-то значение. Вот, а вот формула это,
например, если написать, что x в квадрате больше, чем y плюс 3, то тогда это не будет
какое-то число, это будет просто истинная или ложь. То есть вот терм,
терм это что-то, что принимает какое-то значение, грубо говоря, числовое, ну или
может из какого-то другого множества объектов, а формула принимает значение
истинная или ложь. Вот, значит, и кроме того, можно, значит, можно навешивать кванторы
по объектам. Значит, можно добавлять кванторы по объектам. Вот, но не по множеству и не
по функциям, но не по множествам. И вот как раз, если можно еще и по множествам
ставить кванторы, то это же будет логика второго порядка. Да, вот, например,
наверное, на мат-анализе вы проходили два определения непрерывности или там
предела функции по каши и по гейна. Было что такое? Вот что такое предел по каши?
Там для любого эпсилон существует дельта, там и так далее. Да, вот там для
любого эпсилон существует дельта, тут там то, что нужно написано. Это вот первый
порядок. Вот, а что такое предел по гейна? Там для любой последовательности, да,
что такое последовательности? Это там функции из натуральных чисел в числах,
то есть получается квантор по функции. Соответственно, есть поднаписано для
любого, для любой последовательности хн, да, значит, где она приедет к бесконечности, да, и
дальше там что-то верно, то вот это уже будет второй порядок. Вот, соответственно,
второй порядок в нашем курсе не изучаем, а так вообще в книжках некоторых написано.
В гречатенькой шине, правда, нету, но там во всяких более толстых книжках там это тоже есть.
Но имеется в виду, что множество объектов – это числа. Вот, и эпсилон дельта – это тоже числа.
А последнее слово – это не число, это вот именно функция.
Значит, астипизации не будет, да, то есть бывают шатипизированные теории,
где есть объекты одного типа, есть объекты другого типа, и как-то с ними тоже там
соотносятся, что если там n натуральная, там ax действительная и так далее, и так далее,
там af там функция. Вот, значит, у нас такого не будет, да, у нас все объекты будут одного типа.
Ну и тогда произвольная последовательность – это явно объект другого типа, чем число.
Ну хотя бы у них там разная мощность, да, там чисел-континум, а произвольных…
А, не, ну хотя если она счетная, то…
Не, ну сейчас будет не махание руками, сейчас мы четко принесу такую формулу первого порядка,
и, соответственно, и под нее вот это не будет подходить. Ну а там, конечно, да нет, не будет подходить,
потому что на самом деле тут как бы функциональный символ, да, то есть вот это x, вот сама x,
не x, наверное, а само в себе x, обозначает некоторую функцию из натуральных чисел там куда-то.
Вот, и это все-таки другого типа объект, чем сами числа.
Вот, хорошо. Значит, давайте тогда определять постепенно, что такое, собственно, язык,
да, то есть построение формул, построение формул. Значит, начинается любой язык с алфавита,
да, то есть с того, какие вообще символы могут участвовать в формуле.
Значит, алфавит, да, значит, какие есть символы.
Значит, во-первых, есть символы переменных, но это не те же самые переменные, которые у нас были раньше.
Конечно, буквы могут быть те же самые, но смысл другой, ибо в формуле они участвуют по-другому.
Так, значит, первая это индивидная переменная. Ну, обычно это просто какие-то там маленькие буквы,
может быть, с индексами. Значит, будешь считать, что их хотя бы счетное число, но тут, как всегда,
можно считать, что их счетное число отдельных символов, можно считать, что можно как бы слова писать,
и это будут переменные. И тогда, если можешь писать слова, тогда букву будет конечное число.
Вот, что значит индивидная? Ну, вот индивидная как раз и означает, что они обозначают индивидов,
то есть какие-то базовые объекты. Индивидная, значит, обозначают объекты. Объекты нашей теории, это мог быть числа,
если речь идет про числа, это мог быть точки на плоскости, мог быть множество, мог быть там вершины графа и вообще там все что угодно.
Да, про любой математической теории можно построить какую-то такую, такой язык записан.
Так, значит, дальше вторая вещь, самая важная, это сигнатура называется.
Значит, сигнатура, это следующая, значит, это набор функциональных и предикатных символов.
Набор функциональных и предикатных символов, да еще и с указанием валентности.
С указанием валентности. Валентность означает, сколько аргументов можно подавать на вход, то есть количеством аргументов,
значит, которые можно подавать на вход.
Вот так, хорошо, значит, теперь, почему я пишу не функции предикатов, а именно символы?
Ну, имеется то следующее, что сложение это функция, то есть преобразует два числа в одно число.
Значит, например, сложение это функция, ну, я использую бидарные сложения, которые не по множеству суммируют,
берет два числа и возвращает третье. Значит, функция преобразующая пару чисел в число.
Вот, а еще есть знак плюс. Значит, знак плюс это функциональный символ валентности два.
Ну и, собственно, символ, символ это часть алфавита, а функция это математический объект.
Ну и вот этот символ представляет вот этот математический объект в формуле.
Вот, поэтому важно отличать символы от самих объектов.
Так, значит, еще про валентность. Значит, на практике бывает так, что у одного и того же символа бывает разная валентность,
ну и классический пример это минус. Ну и, собственно, символ, символ это часть алфавита,
ну и классический пример это минус. Минус бывает бинарный, когда вычитание вычитает с одного числа другое,
а бывает унарный, когда берет с противоположного числа. Значит, в нашей теории мы такого не будем допускать,
мы самую простую теорию изучаем, которая уже будет не очень простая.
Будем считать, что у каждого символа ровно одна валентность.
Будем считать, что у каждого символа ровно одна валентность.
Да, значит, на практике давайте, на практике, например,
минус, значит, знак минуса бывает и бинарным, и унарным.
Да, это простейший пример. Ну а так, ну, например, знак там, корня тоже может быть унарным, когда это квадратный корень,
да, и бинарным, когда есть кто под корнем стоит, до какая степени взлекается.
Вот, и это еще хитро записывается, да, что там специальное место, куда записывается.
У нас все будет в строчку записываться, да, без всяких там дробей, там интегралов с пределами,
да, у всяких корней, там индексов. В нашей теории ничего этого не будет, все будет записываться в одну строчку.
Так, хорошо, значит, очень важную роль играют функциональные символы валентности 0.
Функциональные символы валентности 0, что такое вообще, они как бы представляют функцию нуля аргументов.
А что такое функция нуля аргументов? Ну, это константа, да, потому что множество степени 0 – это там символетон,
и вот на этом одном элементе функция равна чему-то. Ну и можно просто эту функцию отожрить с ее значением на этом одном элементе.
Соответственно, вот эти функциональные символы валентности 0 также известны как константные символы.
И в некоторых книжках их выделяют в отдельную категорию, да, вот есть отдельно константные, отдельно функциональные и отдельно предикатные.
Ну, примеры, ну, не знаю, скажем, ноль, да, ноль – число ноль, да, и все остальные цифры тоже можно считать константными символами.
Да, бывает, скажем, число пи. Да, пи, если имеется в виду именно число пи, то это тоже получается константный символ.
Ну и там е, соответственно, вот, ну и так далее.
Вот, предикатные символы валентности 0 обычно не рассматриваются, потому что это, получается, логические константы.
Ну а логические константы, если очень нужно, можно прямо напрямую как именно логические символы включить.
Ну, формально можно их рассмотреть, да, но обычно их нет.
Предикатные символы валентности 0, значит, наоборот, обычно, обычно не рассматривают.
Так, хорошо, это вторая часть.
Значит, дальше, это все еще алфавит, да, это самое начало еще алфавит, да, значит, третья часть.
Ну, этот раз сейчас закончится алфавит.
А, ну, давайте, да, давайте вообще поговорим тогда подробнее немножко.
Ну, это, в общем, то же самое, только они в итоге могут быть листными или ложными.
Да, значит, скажем, предикатные символы валентности 2, предикатные символы валентности 2, но это символы отношений.
Символы отношений там равно, да, там меньше либо равно, да, там какое-нибудь подмножество, там и так далее.
Вот, могут быть предикатные символы валентности 1, это какое-то свойство, или могут быть и валентности 3, в принципе.
Например, вот такую запись, скажем, что х сравнимо с у по модулю х, да, это можно понимать как предикатный символ от трех аргументов.
Да, значит, можно понимать как предикатный символ, значит, валентности 3.
Сейчас, правда, я напишу такие правила построения формул, что вот это не будет допустимо, но можно там переставить листами так, чтобы такое тоже подошло.
Предикат, нет, вообще предикат это функция, которая получает много аргументов, возвращает логическое значение.
Что такое отношение? На отношение можно на двумя способствования смотреть.
Можно смотреть на то, что это подмножество декартового квадрата, а можно смотреть, что это функция, которая получает пару и возвращает да или нет.
Но здесь как раз второй взгляд, что, в общем, предикаты от функции не сильно отличаются.
От отличается только тем, что функция возвращает какой-то объект, а предикат возвращает логическое значение.
Ну а значит, остаток, что еще у нас есть в алфавите, третья часть это символы логических операций.
Ну, может это в любой базе рассмотреть. Можно наш стандартный конъюнкция-дизюнкция импликации отрицания.
Можно добавить логические константы, если нужно, можно кинуть любые другие функции, там большинство.
Хороший вопрос, значит, почему это не предикаты?
Ну, в общем-то, это не предикаты, это не предикаты, это не предикаты, это не предикаты, это не предикаты, это не предикаты.
Если нужно, можно добавить.
Хороший вопрос, значит, почему это не предикаты?
Значит, потому что они другие вещи на вход получают.
То есть, например, меньше. Меньше получает на вход, скажем, два нуральных числа, а возвращает логическое значение.
А вот эти все штуки, они получают на вход логические значения, возвращают тоже логические значения.
Бывает, конечно, ситуация, что у нас как бы речь идет тоже о булевой алгебре какой-нибудь,
и, соответственно, объект это тоже 0 единицы.
Но вот тут как раз начинаются сложности. Такого лучше избегать, если даже так сложилось,
и вы работаете с булевой алгеброй и изучаете конъюнс, как функции булевой алгебры,
то надо просто разные значки взять для функций с булевой алгеброй и для функций как бы из логических формул про булевую алгебру,
иначе там все перепутается.
Так что тут важно разграничивать, что получается на вход, что подается на вход и что получается на выходе.
Так, значит, четвертое это кванторы.
Значит, кванторов у нас будет два.
Значит, существует это для любого.
Вот, ну и пятое это служебные символы.
Служебные символы это скулпки и еще запятая.
Так, ну вот, значит, на этом определение алфавита закончено.
Сейчас будем разбираться, как из этого алфавита конструировать формулы.
Но сейчас до формул еще дойти надо.
Сначала нужно конструировать термы.
Значит, конструкция термов.
Так, значит, это мужского рода слова, то есть терм в единственном числе, терм на английском, вот так.
Вспоминаем, что это такое, это какие-то выражения, у которых значение это какое-то число.
То есть, какие-то выражения, которые обозначает какой-то объект.
Ну а что у нас самое простое, что может обозначать объект?
И это, собственно, переменная.
Значит, правила в строении тут рекурсивные.
Есть базовые случаи самые простые и есть все более и более сложная конструкция.
Значит, тут будет три правила.
Два базовых и одно рекурсивное.
Значит, первое базовое правило такое, что если X это индивидная переменная, то тогда X это терм.
То есть, просто переменная сама по себе может обозначать какое-то число или какое-то множество.
Или какую-то точку на плоскости и так далее.
Вот второе.
Это как раз константные символы.
То есть, если C это константный символ, то есть, функциональный символ валентности 0, тогда он сам по себе будет термом.
Но это как вот эти вот.
Можно 0 включить в формулу, можно P включить в формулу и так далее.
И даже если формула из одного символа P состоит, то это уже что-то обозначает.
То есть, это не формула, это терм.
В общем, эта запись обозначает как раз число P отношение длины окружности к диаметру.
Вот.
Значит, и третья.
Третья часть.
Это рекурсивное правило.
Значит, рекурсивное правило, это если у нас есть F.
Это функциональный символ валентности K.
Что иногда в некоторых книжках записывают эту валентность в букву.
Да, вот так иногда записывают F, а тут в скобочках K.
То как бы она.
Это не карта и производная, да.
А это что как бы приклеено ярлычок такой, что вот у этой буквы валентность K.
Вот.
И также есть.
Те уже готовых термов.
P1 и далее TK это термы.
Вот.
Тогда можно скомбинировать.
Значит, можно написать, что F от T1 и так далее TK.
Это тоже терм.
Вот.
Ну и вот.
Вот.
Ну и тут на самом деле то, что здесь написано, уже отличается от того, к чему мы привыкли.
Да, мы привыкли, что если символ бинарный, то он записан в инфиксной записи.
Не плюс от XY, а X плюс Y.
Ну и со всеми другими бинарными связками обычно тоже так.
Но вот для единообразия.
Так.
Но это правда не предикатный символ.
Если не функционально предикатный символ.
Но здесь еще более сложная запись.
Да.
И бывают всякие там дроби, индексы и так далее.
В общем, мы это все.
Пока.
Ну и вот.
И считаем, что у нас единообразная вот такая вот инфикс.
Нет, не инфиксная, а префиксная запись.
Да, что сначала идет символ функции, а потом в скобках все аргументы.
Вот.
Ну, собственно, если у значка нет никакого собственного значения, как у плюса, умножения и так далее,
то обычно я двух примерных тоже так записываю F от XY.
Вот.
Так.
Все.
Больше правил нет.
Соответственно, можно сказать, что T создается деревом разбора,
где на листьях стоит одно из первых двух правил,
а в других вершинах стоит одно из этих правил.
Так.
Вот.
В общем, можно сказать так, что термом называется запись.
Термом называется запись, полученная конечным числом.
В общем, вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Полученное конечным числом применение правила 3, значит, к, соответственно,
термам, да, как бы к термам, из пунктов 1-2.
То есть, ну, что-нибудь такое, скажем.
Ф от g от x, y, z и 0.
Вот, например, пример, пример корректного терма.
Значит, если x, y, z – переменная, 0 – константный символ,
f – символ валентности 2, g – символ валентности 3 функционально.
Нет, имеется в виду, что сначала, ну, как бы эти применения могут быть рекурсивные.
Ясно.
Ну да, наверное, надо немножко по-другому записать.
Так.
Как бы не к термам, да, там, скорее, начиная.
Начиная термов из пунктов 1 и 2.
Да, то есть у нас, вот именно, что у нас есть дерево, да,
на листьях стоят термы.
Вот.
Вот, хорошо, что у нас есть терм из пунктов 1 и 2.
Да, то есть у нас, вот именно, что у нас есть дерево, да,
на листьях стоят термы из пунктов 1 и 2,
а в каждой другой вершине стоит какой-то еще функциональный символ,
который применяется, соответственно, к под деревьям.
Вот.
Хорошо, значит, дальше следующий понятие – это атомарная формула.
Или просто атом.
Атомарная формула строится аналогично.
Значит, здесь тоже есть термы.
Атомарная формула – как раз то, что переводят из объектов в логику.
Да, то есть здесь Т1 и так далее.
Здесь нет никакой рекурсии, а просто одно правило.
Т1, Т2, ТК – это термы.
Значит, АП – это предикатный символ валентности К.
Предикатный символ валентности К.
Значит, из этого следует, что П, вот Т1 и так далее, ТК – это вот атомарная формула.
Ноль. Сейчас нет. Ноль – это константный символ, то есть функциональный символ валентности.
Но ноль как число ноль имеется в виду.
Но не логическая ложь, а ноль как число ноль из дурами чисел там или из целых.
Не, нет. Константный символ там был написан.
Тут, давайте я отчеркну, что это примеры к верхнему относятся.
Вот, функциональный символ валентности ноль.
Не, а что такое обычный символ?
В чем отличие константного символа от переменной, видимо, вопрос?
Это не очень большое отличие, но они по-разному интерпретируются.
Так, давайте сейчас перерыв сделаем, потом определим формулы.
Значит, следующее понятие – это уже формулы произвольные.
Что такое просто формула?
И здесь, соответственно, атомарная формула становится уже базой рекурсия.
Давайте снова соединиться с значенными нумерациями.
Первое, что если фи – это атомарная формула.
Кстати, я не сказал еще про предыдущие.
Давайте я допишу.
Любая атомарная формула.
Давайте про предыдущие я скажу, про константные символы.
Уже был вопрос, зачем нам вообще понадобится второе правило,
что вообще-то, если бы говорили, что константный символ – это частный случай функционального,
то можно третье, в принципе, и использовать.
Но второе нам понадобится синтоксически,
что если третье правило применить к константному символу,
тут будут еще скобочки.
Просто название функции, а потом скобочка открывается, скобочка открывается.
Такое бывает в языке эси, например, и в других языках.
Но в мотиватических формулах так обычно не делают.
Даже символ п пишут для всяких скобочек.
Тем более символ 0.
Поэтому есть отдельно синтоксические правила, чтобы все-таки в этом месте было похоже на то,
что реально происходит, к тому же это не сильно обременяет.
Ну и в принципе, если разрешать предикатные символы валентности 0,
то для них желательно тоже оговорить вариант,
что тогда скобочки тоже не ставить.
Но давайте скажем, что у нас просто предикатный символ валентности хотя бы 1.
А функциональный мог быть валентности 0.
Ну а дальше уже логические правила.
Второе, что если phi формула, то можно навесить отрицание.
Не phi формула.
Отрицание, в принципе, без всяких скобочек навешивается.
Но если вы возьмете скобки, то в принципе ничего страшного.
Бывает, что для облегчения чтения ставят даже те скобки,
которые не нужны и без которых однозначно получается.
Но для облегчения чтения можно и лишние скобки поставить.
Хотя иногда это просто трудняет.
Так что тут надо какой-то баланс искать.
Вот, значит, третье правило.
Это как раз бинарная операция.
Логически. И они будут в обычной инфиксной записи.
Что если phi и psi это формула, то тогда и конъюнция phi,
и дисъюнция psi, и phi-импликация psi.
Значит, это формула.
Вот, значит, и четвертое.
Это добавление кванторов.
Значит, если phi это формула, а х это переменная,
то тогда существует x и для любого x и phi,
то тогда существует x и для любого x и phi,
тоже без кванторов, это формула.
Тут может возникнуть вопрос.
А что если этого x и phi вообще нету?
Может тогда квантор навешивать?
Ну, значит, тут опять же есть разные подходы.
В нашем подходе это будет можно, но, так сказать, бессмысленно.
Но синтрастически можно.
То есть существует x такой, что y больше z.
Это немножко бессмысленно, но синтрастически корректно.
Значит, тут никаких лишних символов мы здесь не ставим.
Никакие там двоеточие и так далее.
И это считается, что существует x, для которого верна формула phi.
А тут, соответственно, для любого x верна формула phi.
Все, на этом определение заканчивается.
То есть теперь любая формула должна быть получена
рекурсивным применением этих правил.
Ну, соответственно, к атомарным формулам.
Получается, что у нас в том числе допустимые записи.
Значит, допустимые записи.
Ну, например, существует x какой-нибудь p от y, z.
Значит, и даже существует x для любого x там q от x.
Опять же, они не особо полезны на практике.
Нет никакой разумной ситуации, когда нужно писать вот так вот.
Но если мы это будем запрещать списать, то нужны дополнительные правила.
И снимем дополнительные возня.
Если мы что-нибудь доказываем, то нужно рассматривать эти исключения.
Так что давайте...
Значит, есть ученые, которые так делают.
Которые делают так, чтобы такая запись не корректна.
Но мы давайте будем такое разрешать.
Так, хорошо.
Значит, сейчас давайте поговорим вот такую вещь.
Значит, есть разграничения свободных и связанных переменных.
А точнее, у нас это будет свободное и связанное вхождение переменных.
Свободное и связанное вхождение переменных.
Давайте я покажу пример.
Вот, например, что-нибудь такое.
Существует x от xy.
И, скажем, для любого y существует z.
Тут какой-нибудь, скажем, звук.
Следует, ну, например, z от t.
Что значит свободное и связанное?
Связано, значит, связано квантором.
Во-первых, в холостом, в холостом, в холостом.
В холостом, в холостом.
В холостом, в холостом.
Что значит связанное? Связано, значит, связано квантором.
Получается, значит, вот x вот здесь вот и вот здесь вот.
Он связан.
У каждого квантора есть, так сказать, зона действия.
Вот если x внутри этой фии находится
и при этом свободен внутри фии, сейчас обсудим, что это значит,
то вот этот квантор его связывает.
Соответственно, вот этот y тоже связанный.
И вот этот z связан.
А вот этот вот y свободный.
То есть, смотрите, если у вас в разных частях формулы
используется одна и та же переменная,
то может быть так, что она в одной части, как и y здесь,
в этой части будет связанной квантором,
а в этой части будет свободен.
То есть, квантором не связанной.
А вот с этим t, если иметь только формулы,
не знать сигнатуру, то про это t вообще ничего нельзя сказать.
Да, ну не то, что совсем ничего нельзя сказать.
Можно сказать, что она не связанная переменная.
Вот, но может быть, что она свободная переменная,
а может, константный символ.
Может, константный символ.
Это вот к вопросу о том, чем константные символы
отличаются от остального.
Если нет контекста, то чистый сформул нельзя
отличить свободную перемену от константного символа.
Вот, если у нас есть список константных символов,
есть список переменных, то можно отличить одного другого.
Если списка нету, то только если стоит квантор,
квантор только по переменной стоит.
Если квантор не стоит нигде в формуле, то это может быть и то, и другое.
Хорошо, значит, теперь...
Да, сейчас я как раз хотел сказать...
Ну, тут, смотрите, можно давать определение множества,
от которого формула зависит,
а можно свободу или связанность к вхождению переменной.
Ну, в принципе, можно сказать так.
То есть, индуктивное определение...
Рекурсивно бывает определение, индуктивно бывает доказательство.
Значит, рекурсивное определение свободных и связанных к вхождению.
Значит, смотрите, у нас четыре правила и, соответственно,
тут тоже будут четыре этапа определения.
Четыре этапа определения, четыре этапа определения,
что кое связанное, что кое свободное.
Так, значит, первая ватамарная формуля, все вхождения свободные,
если это переменная.
Ватамарная формула.
Ватамарная формуля.
Все вхождения...
Значит, все вхождения всех переменных свободные.
Ну, то есть, все, как бы всех, всех переменных, которые вообще есть формуля,
если они входят, то уходят свободно.
Так, значит, два-три, если у нас логическая комбинация, они не меняют.
Да, то есть, вот отрицание ФИ, значит, и конъюнция СИ.
Значит, ФИ, дезюнция СИ.
Значит, ФИ, импликация СИ.
Значит, тут все вхождения, все вхождения такие же.
Такими же, как в ФИ и СИ.
В том числе может быть так, что в одну формулу перемены входят свободно,
а в другую связано. Или даже в одну формулу и так и так входят.
Значит, опять же, эта характеристика не переменной в целом,
а конкретного символа, который эта перемена означает на конкретном месте формуля.
Вот, 0.4.
Значит, существует X ФИ и для любого X ФИ.
И для любого X ФИ.
Значит, здесь все вхождения X становятся связанными.
Все вхождения Х связанные.
А остальных переменных такие же, как были в ФИ.
А остальных переменных такие же, как в АФИ.
Вот, соответственно, можно даже расширить определение,
говорить, что переменные связаны конкретным квантором.
Тогда нужно сказать, что свободные вхождения ФИ
и прямо вот этот X, который под квантором, они все связаны этим квантором.
А если там были связанные вхождения Х, то чем были связаны, тем и остались.
В частности, в этой записи получается, что на этот X влияет только вот этот квантор.
Для любого Х.
А этот внешне он просто ничего не меняет.
Вот. Да.
Да-да-да.
Первый порядок, что кванторы по переменным.
Так, можно еще похожие вещи написать по-другому.
Вместо свободности связанности вхождения можно написать множество параметров.
Так, множество параметров.
И тут надо начинать...
Тут надо начинать прямо с самого начала, с термов.
Но, впрочем, тут тоже довольно понятное определение.
Значит, параметр от переменной...
Множество параметров от переменной, соответственно, это одноэлементное множество.
Значит, множество параметров от константа это пустое множество.
Значит, множество параметров от рекурсивного терма.
F от T1 и так далее.
Ой, не так.
F от T1 и так далее.
Tk.
Значит, это, соответственно, объединение.
Значит, параметры T1, объединение и так далее.
Объединение параметры от Tk.
И то же самое с F.
Не с F, а с P, наоборот.
При дикат от T1, так далее, Tk.
Это то же самое.
Объединение.
Так, значит, дальше множество параметров от отрицания.
Это то же самое, что у исходной формулы.
Значит, множество параметров у, соответственно, динарной связки.
Значит, а также, неважно какая связка, это будет объединение.
Множество параметров от фе и множество параметров от пси.
Вот.
И пока что множество параметров только растет.
И только для формулы с квантов оно уменьшится.
Как раз этот х перестанет быть параметром.
Значит, множество параметров от формул существует в х фе.
Значит, или для любого х фе.
Значит, это будет множество параметров от фе без переменной х.
Это соответствует тому, что этот квантор свяжет все свободные входы, которые там были,
и больше свободных входов не останется.
То есть можно, в принципе, исходя из этих двух определений, доказать теорему несложную,
что множество параметров – это множество тех и только тех переменных,
которые входят в формулу свободно, у которых есть хотя бы одно свободное вхождение.
Хорошо.
Это мы пока только синтактически анализируем, как мы это все выстраиваем в цепочке символов.
Теперь вопрос, что все это значит.
Давайте обсудим.
Давайте пока вернемся к обычной записи, чтобы было удобнее рассуждать.
Вот, например, у нас написано, существует х, что х меньше у.
Это верно или неверно?
Ну, непонятно, от чего зависит, верно это или неверно.
Верно или нет.
Нужно по крайней мере три вещи сказать, чтобы было понятно, верно или нет.
Значит, непонятно.
Если просто такая запись, то непонятно.
Может, верно, может, нет.
А именно, чтобы ответить, нужно знать три вещи.
Первая очевидная вещь – что вам нужно сказать, чтобы сказать, верно это или нет?
Ну, да, в общем, слышишь правильные ответы.
Что?
Не, что кое верное, мы знаем.
Я бы сказал так, что, по моей точки зрения, самая очевидная вещь – это чему равно у.
Вот, но вторая связанная вещь, ну, например, если мы настроены только на натуральные числа,
то тогда достаточно сказать, чему равно у.
Что, если у равно нулю…
А, сейчас, это другой квантор, если это существует.
Если для любого…
Сейчас, давайте я квантор поменяю, чтобы было более естественно.
Потому что, давайте вот так вот.
Значит, тогда, если у равно нулю, то это неверно в натуральных числах,
а если у не ноль, то это верно.
Вот, но отсюда же возникает вторая вещь.
Да, как бы, в каком множестве можно искать х?
Значит, в каком множестве можно искать х?
Значит, в каком множестве должен найти х?
Да, опять же, пусть мы скажем, что их равен нулю.
Но тогда, если существует х натуральный, то это будет неверно.
Если существует х целый, то это будет верно.
Вот, а третье…
Третье, да, что означает меньше?
Значит, что значит меньше?
Потому что даже если мы скажем, что это натуральные числа
и сказали, что их равно нулю,
то, тем не менее, если меньше понимается в обычном смысле,
то это неверно.
А если меньше понимается, как то, что у делится на х,
то это, наоборот, верно.
Да, что действительно нуль делится на что угодно.
Ну вот, соответственно…
Сейчас будем определять, что это такое.
Более-менее, эти вещи – это все, что нам нужно.
Вот эти две вещи вместе называются интерпретация.
А вот это называется оценка.
Сейчас я расскажу в общем виде, что это такое.
Тут еще опять же такая лингвистическая проблема,
что вот то, что я называю интерпретацией,
некоторые других школах называют моделью.
А в нашем курсе модель будет другая вещь.
А у них интерпретация – другая вещь, правда, редко используемая.
Но так сложилось еще в середине XX века,
там разные школы разошлись,
где одни и те же слова по-разному употребляют.
И я, соответственно, использую терминологию своей школы.
Вот, и это прямо даже там я учился,
и там лектор говорил в одних терминах,
а семинарист в других терминах,
потому что они из разных школ были.
Вот, а что такое интерпретация?
Значит, интерпретация, у чего она, во-первых, бывает?
Интерпретация сигнатуры.
Это тоже некоторая перечень.
Значит, первая, первая – это носитель интерпретации,
это некоторое непустое множество.
Носитель интерпретации – это M, которое непустое множество.
Значит, непустое обязательно, да,
то есть нужно, чтобы хотя бы один элемент можно было взять.
Иначе там кванторы поменяют местами свои значения.
Для пустого множества там как бы существует,
наоборот, будет неверно, для любого верно,
и, в общем, там всё на перекосяк пойдёт.
Так что будем считать, что у нас носитель.
Носитель – это как раз ответ на второй вопрос.
То есть, из какого множества всё берётся?
Значит, у нас нет типизации,
то есть все перемены берутся из одного и того же множества объемнощего.
Так, ну а второе – это значение символов.
Значит, значение символов.
Значит, тут давайте я немножко…
Константный символ отдельно рассмотрю.
Если C – это константный символ,
то его значение будем обозначать таким же C,
но в квадратных скобках.
И это какой-то элемент M.
Соответственно, если у вас…
Если было пустое множество в качестве носителя,
то константный символ вообще нельзя было бы интерпретировать.
Какая-то ерунда бы получилась.
Ну а так, значит, каждому символу константному
соответствует какой-то конкретный элемент.
И может быть даже, что двум разным соответствует один и тот же элемент.
Вот, значит, дальше…
Если F – это функциональный символ…
Функциональный символ валентности K,
то ему соответствует функция…
Функция тоже в квадратных скобках,
которая отображает M в какой-то степени в M.
Ну и аналогично, значит, если P – это предикатный символ,
предикатный символ валентности K,
то он отображается, значит, в предикат…
Тоже P в квадратных скобках,
которые отображает M в степени K в 0,1.
Теперь мы знаем ответ на второй и третий вопросы.
Ну, то есть, если интерпретация задана,
то тогда мы знаем ответ на второй и третий вопросы.
Вот, а на первый вопрос отвечает как раз оценка.
Так, я вам выше говорил про число P,
а здесь тоже самый символ P я буду использовать
как обозначение произвольной оценки.
Значит, так как-то часто делается,
все-таки букв не так много,
и одни и те же буквы в разных контекстах используются по-разному.
Вот, значит, оценка,
оценка бессмысленна без интерпретации,
точнее без носителя,
потому что оценка – это функция
P из множества переменных в M.
Значит, здесь вот это самое var –
это множество индивидных переменных.
Ну вот, если задана интерпретация и задана оценка,
то можно определить, чему равна формула,
истинна она или ложна,
и также, чему равен любой терм.
Наверное, мы только про терм успеем сегодня поговорить.
Так.
Да, кстати, я вот пропустил с предыдущего.
Давайте сейчас скажу.
Значит, есть понятие «замкнутая формула».
Замкнутая формула –
да, это формула без параметров,
то есть у которой, ну, есть форма без параметров,
и она не имеет никакого значения.
Да, это формула без параметров,
то есть у которой множество параметров – это пустое множество.
Ну или можно иначе сказать, что
любая переменная отходит только связанно в этот формул.
Или можно сказать, что по любой перемен стоит квантор.
И еще есть понятие «замкнутый терм».
Это нам пригодится в самом конце,
по полноте она, наоборот, доказывает.
Да, у нас в курсе две термы Гёдаля.
Одна о полноте, другая о неполноте.
А полноте будет в конце этого семестра,
а неполноте – в конце следующего.
Вот. И так раз будут замкнутые термы.
Прямо сейчас поймем, что это такое.
Это как бы терм, который собран из констант.
Да, то есть там нет ни одной переменной,
есть только константы, то есть константные символы.
Это терм без параметров, а значит и без переменных.
Без переменных, то есть собранный
только из константных символов.
Вот.
Ну хорошо, значит теперь определим,
определим то, так не что, а почему,
какое значение, какое значение принимает
формула Фи, значит при данной интерпретации,
при данной интерпретации
и на данной оценке.
Вот, значит это так определяется.
Сначала для термов.
Вот у нас, смотрите, у нас три этапа определения терм,
потом четыре этапа определения формулы,
и все остальные свойства, как вот связанные переменные,
параметры и все остальное, все будет проноситься
через вот эти вот семь этапов.
Вот частоте значения.
Так, ну я не знаю, на все семь не успею сегодня,
продолжу в следующий раз, но сколько успею.
Так, первый этап у нас переменная.
Вообще про переменную у нас оценка говорит,
чему она равна.
То есть тут получается такая логичная запись.
Да, значит значение терма.
А, это обозначение.
Обозначение это в тоже самых фаератских скобках на оценке.
Формула, точнее не формула, извините, терм,
который состоит из одной переменной,
на оценке Пи принимает ровно такое значение,
как это оценка предписывает.
То есть, смотрите, что здесь написано.
Чему равен терм из переменной Х,
если мы знаем, что там Х равно тому-то,
или равно тому-то, или равно тому-то и так далее.
А вот нужно посмотреть, чему равно Х,
и вот чему написано, тому он и равен.
Понятно, базовый случай всегда будет простой.
Ну а про констант, если у нас просто напрямую в интерпретации сказано,
даже оценка не нужна,
что если это терм,
какая бы ни была оценка, это на то она и константа,
что будет одно и то же значение.
Так, ну а дальше будет как раз рекурсивное правило.
За этим нам и нужна интерпретация F.
Да, значит, третий этап,
что основной терм F вот T1 и так далее,
Tk на оценке pi.
Но, смотрите, что нужно сделать.
Нужно посчитать, как это по действиям,
что если у вас какое-то большое выражение,
то сначала каждую часть в отдельности посчитать,
чему равна, и потом применить действие.
Ну вот, ровно то же самое.
То есть, применить действие, это что означает символ F,
и применить соответственно к значению T1 на этой интерпретации и так далее.
На значение Tk на этой оценке.
На значение Tk уже посчитаны на этой оценке.
То есть, это получается как бы вычисление по действиям.
Значит, вычисление по действиям.
Ну и, собственно, ровно то же самое
будет товарной формулой.
Давайте я всё-таки перепишу.
Значит, отличие будет в том, что если вот эта интерпретированная функция F
выдаёт какое-то значение числовое,
то интерпретированный предикатный символ P
выдаёт логическое значение.
Вот.
Так.
Ну, наверное, мы сейчас можем про квантуру с ней поговорить.
Вот.
Значит, 5 и 6, то, что у нас уже было в логике высказываний.
Что связка интерпретируется как значение соответствующей булевой функции.
То есть, если у нас формула это отрицание какой-то другой формулы
на оценке P,
то что тут нужно сделать?
Значит, нужно вычислить значение этой формулы на этой оценке
и взять отрицание как булевую функцию.
Давайте я напомню, что вот это символ из формулы.
Значит, а это булевая функция.
Ну и, собственно, то же самое будет и для других связок.
Шестое.
Да, если, скажем, конъюнция,
ну, то это будет функция логическая E,
применённая к значению одной формулы
и значением этой формулы.
Применённая к значению одной формулы
и значению другой формулы.
Вот эти все записи можно ещё воспринимать как такие инструкции к конфилятору.
То есть, вы пишете программу,
которая читает по символу на формулу,
откуда-то может брать вот эти вот функции,
и вот нужно ей понять, верна формула или нет.
Вот как эта программа будет считать?
Ну, вот, примерно так.
Ей нужно научить разбирать синтактические выражения,
то есть выделять вот это phi, вот это psi,
там вот это t1, t2, t3.
Но если она уже научилась разбирать формулу,
то после этого она вот так вот, по действиям,
будет вычислять, чему формула равна.
Ну и, соответственно, если тут другая связка,
то она будет сюда поставить другую функцию булевую.
Вот так.
Ну и самое сложное.
Значит, самое сложное – это кванторы.
Значит, смотрите, тут я с этого ещё начну следующую лекцию,
но что-то могу уже сказать.
Значит, нужно понимать, что квантор существования –
это что-то типа бесконечной дезюнции.
Значит, существование – это бесконечная дезюнция.
То есть существование – это бесконечная дезюнция.
Что если хотя бы одно истинное значение есть,
то тогда, соответственно, существование выполнено.
Ну а всеобщность – это бесконечная конъюнция.
Ну и так, соответственно, можно интерпретировать.
Такая, что мы как бы заменяем значение х.
Вообще говоря, у нас в оценке есть значение всех переменных,
в том числе и той, которая под квантором.
Но мы, когда понимаем верно ли, что существует х,
мы как бы забываем, чему он равен, перебираем всевозможные варианты.
Если там где-то есть единица, то тогда, соответственно,
говорим, что существует.
Ну и получается, например, вот такая формула.
То есть существует х и на π.
Значит, это будет следующее.
Это будет дезюнция по всем м из носителя.
Значит, значение φ на…
Ну можно вот так обозначить.
Пи здесь в индексе х, стрелка м.
И это понимается так, что вот эта штука, пи х, стрелка м.
Да, на х это м.
Значит, а на любой другой переменной, значит, на у.
И это то же самое, что раньше, было пи от у.
То есть все остальные значения переменных как были,
а х вот подкручивается.
Ну вот, и рассмотрите важные значения,
и берется вот такая бесконечная дезюнция.
Ну а, соответственно, если тут для любого,
то тут будет конъюнция по м из м.
Вот так это определяется.
Соответственно, понятно, что компьютер никакой бесконечный
перебор не может сделать, но он может делать конечный перебор.
То есть если большой конечный множество,
то можно взять вот такую дезюнцию или конъюнцию
по всем элементам этого конечного множества,
и это записать тоже квантором.
Все, спасибо за внимание.
В следующий раз продолжим.
