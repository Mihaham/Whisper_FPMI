Итак, первая тема, о которой мы говорим, — это персистентность.
И когда мы говорим о персистентных структурах данных, мы говорим о таких структурах, которые помнят все свои старые версии.
Как-то в сжатом виде хранят не только свое текущее состояние, но и все возможные свои предыдущие версии.
Самый такой для нас близкий пример — это система контроллер-версии, что-то в стиле гитхаба или гитлаба, где у вас там, на семинарах, где вы работаете.
Это система, которая хранит все версии вашего кода.
Вот вы написали какой-то код, запушили его, а вот он там хранится.
Потом внесли какие-то правки, и вам доступна как конечная версия, так и предыдущая.
Вы знаете, в чем они отличаются. Вы можете к любой версии быстро получить доступ.
И когда мы говорим про персистентные структуры, мы тоже хотим ровно этого, что пришел пользователь, что-то поделал, поделал.
Потом такой сказал, — ой, не хочу, откатывай все к такой-то версии.
Или просто, а вот что было там год назад, что было в базе данных наших год назад?
Просто какие-то такие запросы к каким-то более ранним версиям нашей структуры.
И вот самое простое, что можно сделать, одно из самых простых, это персистентный массив.
Ну, в такой простой версии нам нужно уметь обрабатывать, по сути, два типа запросов.
Значит, в какой-то момент времени нам приходит запрос изменения,
и мне нужно в какой-то позиции запрос обновить число и положить его равным числу вал.
А пери присвоит какое-то значение.
И второй запрос — это, например, а скажите, пожалуйста, что было в такой-то ячейке массива на такой-то версии?
То есть вывести или там найти апостая в этой версии, в этой версии.
Ну или там в такой-то момент времени у вас приходят запросы, вы у каждого запроса знаете, в какой момент времени он приходит,
и когда поступают запросы второго типа, вам говорят, а вот типа тот запрос, который я тебе вчера прислал, скажи, пожалуйста,
у него в той ячейке. Ну и понятное дело, что вот идет поз, они могут варьироваться от запроса к запросу.
От запроса к запросу.
Вот здесь решение может быть следующее, очень простое.
Давайте мы просто для каждой позиции запомним всю историю ее изменений.
Для каждого индекса, для каждого аитова запомним, какое число там было в начале,
потом как оно поменялось и в какой момент времени оно изменилось.
То есть там аито было сначала х, потом оно в какой-то момент времени т1 стало у, потом в момент времени т2 стало z, ну и так далее.
То есть мы знаем просто целиком историю и ее храним в некотором векторе, в динамическом массиве,
который нам позволяет добавлять информацию в конец. То есть мы вот так делаем pushback в наш вектор,
добавляем новые сведения о том, что в такой-то момент времени наш элемент так-то изменился.
baum с loved one linem eh
тогда если мне приходит запрос, извлечение какого-то
элемента, ну точнее нахождения кого-то элемента в в какой-то
момент времени наш не�опросто понять она вот мне
нужна посмотреть на апост tsp давайте посмотрю на апостно и на всю
историю unhappy что там было какое-то число сначала так то поменялась
문 одни ст occasion и так то другой так далее и так далее и тогда все что не
нужно сделать это понять, чему равно число в тетый
момент.
Значит, мне нужно из вот этих вот пар, если я храню
пары t1, y, t2, z, там t3 какой-то еще, не знаю, буквы кончились,
а, b, тогда мне нужно просто найти первый момент времени,
точнее не так, мне нужно видимо найти последний
момент времени, меньше или равный t, чтобы найти,
чтобы найти апостоля в момент t, в этом списке нужно найти
как бы последние изменения, которые произошло к моменту
времени t, то есть вот там какой-то префикс изменений
произошел, да, и вот то последнее изменение, которое произошло
до момента t, нам нужно как бы его и вывести, да, то
последнее изменение, которое произошло до момента времени
t, это есть наш ответ.
Так вот, в этом списке надо найти последние изменения
в момент меньше либо равный t.
Ну а это уже простая задача на конюнвен поиск, если
у меня есть отсоцированный массив времен изменений,
что там тогда-то поменялось на то, тогда-то на то, то
дальше просто бин поиском нужно найти вот эту вот последнюю
позицию, где число, где момент времени больше,
чем t, потому что сначала идут меньше и равные t, потом
идут больше t, у нас есть такая монотонность, возрастание
времени изменений, значит можно просто запустить
бин поиск и найти там, собственно, последнюю операцию, которая
повлияла на это апостол.
Тогда получается, что у меня запрос вот этого второго
типа, мы на него отвечаем за логарифм, ну логарифм
q, где q это общее число запросов, потому что в худшем случае
все запросы приходят к одному этому же элементу, и тогда
мне нужно хранить массив длины q и в нем делать бин
поиск.
За лог q работает.
Вот.
А запрос изменения работает за амортизированную единицу,
потому что это просто pushback-вектор.
Амортизированная единица, потому что это просто pushback-вектор.
И в этом случае можно в it-вектор сообщить, добавить
новое значение, t запятая вал, что в t этот момент времени
число поменялось на вал.
Вот такая очень простая структура, мы просто помним
историю каждого элемента.
Так, есть ли вопросы сейчас по персидентному массиву?
Сейчас.
А мы же, наверное, в каждой паре мы должны хранить не
только t1 и изменения, но еще и то значение, которое
было до этого изменения.
Да.
А зачем?
Ну, а как, иначе вы поймете, что было момент t, ну, то
есть, а или а, окей, ой, все, все, я понял.
Ну, если вопрос возникнет, я все равно на него отвечу,
давайте я нарисую вот такую вот временную ось.
Значит, смотрите, это увеличение времени, значит, в нулевом
момент времени там был какой-то x, потом в какой-то
другой момент времени появился y, в третий момент времени
появился z, и так далее, и так далее.
Ну, а дальше, если мне приходит запрос, скажите, пожалуйста,
какой час облау в момент времени t, то я просто нахожу,
как бы, куда это t попадает, между какими двумя запросами,
ну, скажем, вот куда-то сюда он попал, t, скажем, вот
здесь, и тогда ответ – это y, это последнее изменение,
которое произошло в момент времени меньше равных t.
То есть я смотрю на все, что находится левее чем-то
t, нахожу последнее изменение, и это будет наш ответ.
Потому что, ну, позднее, чем это изменение, ничего
не происходило, значит, это есть наш ответ.
Да, возможно, у нас происходит запросы к элементам, нам
же нужно весь массив копировать при каждом запросе и изменять
один элемент в нем, ну, чтобы поддерживать такую структуру
данных, или это как-то по-другому реализовано?
Нет-нет, смотрите, у меня на каждый запрос я добавляю
только одну, ну, в общем, под единицей памяти у меня
нужно лишний, потому что, смотрите, я ничего не перекопирую,
я для каждого элемента, для каждой позиции i хранил
всю его историю.
То есть я знаю примерно следующее, что в момент
времени 0 оно было каким-то значением там x.
Потом, если у меня приходит новый запрос, где i t меняется,
то я это добавляю в вектор, соответствующий i t ему элемент,
то есть я вектор там, не знаю, в kt и t, я добавляю информацию
о том, что в новый момент времени t1, оно поменялось
на y.
То есть, на самом деле, каждый запрос изменения, он не требует
никаких копирований, он просто требует добавления,
ну, одного pushback, то есть одного добавления в конец
в i t векторе, тем самым я как бы знаю целиком вот
этого одного элемента.
Да, я ничего не копирую.
Извините, то есть у нас векторы столько же, сколько
элементов, сколько элементов, да, для каждого элемента
свой массив, свой вектор, свой вектор, да, хорошо.
Так, это мы обсудили, теперь, ну, наверное, я на семинар
оставлю какие-нибудь упражнения типа персистентный стэк
или персистентная очередь, но с очередь там вроде сложно,
наверное, персистентный стэк, вот, а сейчас мы обсудим
персистентный дерево отрезков.
Персистентное дерево отрезков.
Идеология абсолютно такая же, да, мы хотим делать какие-то
запросы в нашем деле, скажем, изменять элемент в точке
и находить сумму на отрезке, но еще мы иногда хотим как
бы откатываться во времени, или, ну, можно сказать так,
можно сказать просто запрос, что текущая версия должна
быть равна там, та, которая была когда-то в этот момент
времени, то есть, ну, реально, вот, текущую версию откатить
до какой-то более старой, либо просто поступают запросы,
что нам нужно вот в такой-то версии найти сумму на отрезке.
Вот давайте вторая версия, она более общая, давайте
ее, значит, и зафиксируем.
И так, и того, есть два типа запросов, первый это по
позиции и значению, мне нужно сделать обновление
этого элемента, да, и забыть то, что там было раньше и
поменять на значение вал, и второй тип запроса следующий,
если мы рассмотрим эту версию нашего деревоотресков,
то есть версию деревоотресков, которая была после первых
Т изменений, допустим, то есть, вот у меня есть изменение
значений, и я храню, я спрашиваю в момент не когда все они
уже обработаны, а в момент, когда только первые Т обработаны,
значит, первые Т обработаны, мне нужна сумма на отрезке,
чтобы найти, нужна сумма AL плюс AL плюс 1 плюс так далее
плюс AR в этот момент времени.
Давайте пример, чтобы точно было понятно того, что мы
хотим от этого дерева, пусть для начала был такой массив,
не знаю, там 7, 8, 3, а 0, 1, 2, первый запрос такой, поменяйте
пожалуйста 1 на 2, а 1 заменить на 2, хорошо, заменили, как
будто бы запомнили, что вот есть у меня исходная версия
7.8.3, теперь текущая версия 7.2.3, на самом деле мы не будем
целиком копировать массив, вы как спрашивали, мы не
будем так делать, но как будто бы, да, текущая версия
у меня 7.2.3, представляем виртуально, что мы его скопировали
и один элемент заменили, приходит следующий запрос,
а вот если мы забудем про это текущее изменение,
испортим в себя, что было в момент времени 0, то есть
до всех запросов, и там найти сумму элементов, не знаю,
с 0 по 2, значит, T равно 0, L равно 0, R равно 2, тогда
мне нужна сумма на отрезке от 0 до 2 элемента до всех
изменений, значит, мне нужно просто найти 7.8.3, то есть
18, дальше приходит третий запрос, хорошо, это мы, значит,
узнали, что было до всех изменений, а если все-таки
вернуть то изменение, то есть если первое изменение
сделать и считать, что этот запрос все-таки у меня нужно
обработать, сначала A1 поменять на 2, ну теперь, например,
тот же самый запрос, L равно 0, R равно 2, тогда здесь уже
мы должны написать 7 плюс 2 плюс 3, потому что из-за
вот этой единицы мы вынуждены сначала A1 поменять на 2,
только потом найти всю сумму, это уже будет 12, то
есть в зависимости от этого T мы как бы ограничиваем
себя некоторым префиксом, то есть некоторым начальным
отрезком запросов изменения, несколько первых запросов
изменений мы сохранили, их обработаем, и в этот
момент времени как бы откатываемся в истории, в этот момент
времени, когда дерево было таким, когда массив был
таким, мы выводим сумму на отрезки. Вот такая задача.
Решается следующим образом. Давайте мы будем писать
как будто бы обычное дерево отрезков с суммой в поддереве,
только когда мы обрабатываем запрос обновления в какой-то
точке, давайте нарисую как это работает, когда мне
приходит запрос обновления в какой-то там позиции
поз, я спускаюсь от корня, то есть от лишинки номер
1 по какому-то пути, и вот во все эти элементы сумму
увеличу на дельта, во всех элементах сумму увеличу
на дельта. Это мы обсуждали в прошлый раз, если значение
опосты выросло на дельта, то тогда, соответственно,
во всем пути, который контролирует эту вершинку, то есть на
всем пути от корня до этой вершинки поз, мне нужно
прибавить ту же самую дельту, потому что сумма выросла
на этом пути только и на нем ровно на дельту.
Так вот, давайте мы вместо изменений на этом пути в
исходном дереве отрезков, мы все эти вершинки как
бы продублируем, вот давайте мы вместо них, вместо вот
этих четырех вершин, создадим четыре новые вершины с той
же самой структурой, и в них напишем вот эти новые
значения, то есть скажем, если здесь был х, то здесь
мы напишем х плюс дельта, если здесь был у, то здесь
мы напишем х плюс дельта, ну там zb, здесь тогда z плюс
дельта, b плюс дельта, то есть мы не заменяем вот тот
путь, а как бы его копируем и меняем там значения, как
нам нужно, то есть мы старый путь не затираем, мы помним,
какая там информация хранится, копируем эти все вершинки,
и вот в них уже меняем, вот этих скопированных что-то
меняем, вот, то есть это как бы наша текущая версия
вот этого пути, что вот это как бы правильно, текущая
версия, а это как бы старая версия, что было до этого
изменения, но, когда смотрите, давайте мы вот эти вершинки,
которые синие, мы их оставим и сделаем так, давайте я,
нет, не так, у меня у корня был левый сын какой-то,
левый сын, и он не поменялся, поэтому давайте левая ссылка
как вот это вот нового корня, будет вести туда-же, то
есть мы понимаем, что вот это вот новый корень, в
нем хранится текущая новая информация и левый сын
в новом под� deputy он как бы не поменялся, у меня
изменения какие-то прошли только в правом сыне, тогда
давайте ссылку на левого сына мы как бы. не поменяем,
мы ее оставим такой же, она будет вести туда же,
куда вела раньше, вот эта вот ссылка в левого сына
будет вести туда же, значит ну правый сын, соответственно,
у меня обновился, правый сын это вот эта новая вершинка,
что дальше, дальше у меня, у этой вершинки, мы знаем
левого сына. Это вот эта новая вершина, ту же синяя. Но что с правым сыном? Правого сына здесь нет.
Но понятно, что правый сын у этой вершинки равен правому сыну у этой вершинки. Потому что когда я могу
здесь нарисую правого сына, то понятен, что во всем этом подделе ничего не поменялось. Поэтому можно
эту ссылку сохранить. Что правым сыном ją выступает теперь старый правый сын membership minus Littlestanden,
было написано y. то есть по сути я оставляю ссылки на всех детей, на лево-право сына, меняю
только вот этот путь, вдоль которого произошли изменения. давайте еще какое-нибудь другое дерево
нарисую. вот у меня было дерево, давайте на трех элементах нарисуем. дерево отрезков на трех
элементах выглядит так. и допустим изменения произошли вдоль вот этого пути. соответственно
вот этот путь будет новой версией того пути, на котором произошли изменения. это левый сын остается,
он показывает новую вершину. правым сыном нового корня будет выступать старый правый сын старого
корня. то есть вот этот старый корень это новый корень. а правый сыновья у них одинаковый,
потому что все правое под дерево корня у нас не поменялось. у нас поменялось что-то только в
Здесь вот в левом под дереве. поэтому мы меняем только левого сына. левый сын у меня новая вершинка.
а правый сын мне не поменялся, поэтому я могу вот эту ссылку просто перенаправить. то, что было
раньше правым сыном, то и остается. вот это правая ссылка корня. дальше у этой вершинки, наоборот,
поменялся правый сын, поэтому здесь появляется новая стрелка в новую вершину, а левый не поменялся,
потому что у этой вершинки, которая является предшественником новой вершинки, у нее в левом
под деревень ничего не произошло, поэтому здесь левую ссылку, точнее ссылку на левого сына,
мы оставляем такой же, как было раньше. Вот такая идея. То есть мы просто перекопировали путь,
а ссылки на неизменившиеся вершинки мы их оставили такими же, как были.
Так, ну здесь несколько технических деталей, что, во-первых, мы отказываемся от сплошной
нумерации вершин, точнее от нумерации, что там у вершинки В обязательно деть это 2В и 2В плюс 1.
Отказываемся от удобной нумерации. Ну потому что, если там раньше это было верно, да, и вот у
вершинки В были вершинки 2В и 2В плюс 1, то теперь я создаю новую вершину с каким-то номером еще
больше, чем 2В плюс 1, да, новый номер какой-то завожу, то у нее правый сын, как бы, имеет тот же
самый номер 2В плюс 1, да, поэтому здесь с номерами уже все будет совсем по-другому, и мы вместо этого
будем просто в каждой вершине хранить, ну а вот, а кто является моим левым сыном, кто является
моим правым сыном? То есть я не буду хранить, ну, то есть у меня не будет верно, что с лева 2В,
с права 2В плюс 1, да, у меня просто будет стрелка на левого сына и ссылка стрелка на правого.
Ну, это номер левого сына и номер правого сына. Вот, ну, давайте напишем такой небольшой код,
значит, можно завести структуру вершины, структ ноде, это что будет у меня храниться в вершине дерева
отрезков. Ну, во-первых, там нужна сумма, сумма в подделье, пусть будет long-long сам, и мне нужны
вот эти две ссылки на левый и на правый сына, int, давайте назову их left и int right.
Ну да, пусть будет так. Вот есть такая структура вершинки, которая имеет как бы ссылку на левый
и на правый, на левый и на правый сына, но это будет не ссылки, а как бы номер левого сына и номер
правого сына. Вот тогда, какие у меня поступают запросы? Что мне нужно делать? Мне нужно уметь
заводить новую вершину, которая является копией одной из старых вершин. Вот скажем, у меня был
какой-то старый корень, мне нужно завести новый синий корень и по умолчанию скопировать вот эти
вот ссылки, которые были у детей старого корня, подвесить эти же ссылки вот сюда. Если у меня был
какой-то старый корень, не знаю, там вершинка с номером v, то мы создаем новую вершинку, скажем,
с номером w и говорим, что twt.left равно tv.left. То есть я как бы перекопирую информацию о левом
сыне из старого корня в новый корень. Завел новый корень w с новым номером w и сказал,
что его левый сын равен левому сыну вот этого старого корня вершинки v. Тоже самое с правым
сыном twt.right равно tv.right. Это мы скопировали ссылки на детей. Дальше нужно исправить сумму,
если сблокать сумма s, то здесь станет сумма плюс дельта. А потом нужно спуститься вот в одного из
этих детей и с ним сделать то же самое. Если человек меняется, если вершинка меняется,
то мне нужно ее как бы скопировать, завести новую вершинку, перекопировать ссылки на детей и обновить
сумму. На самом деле все очень просто. Мне нужно скопировать, мне нужно научиться перекопировать
одну вершинку в другое место, сохранить ссылки на детей и просто в новой вершинке изменить
значение суммы, изменить сумму, увеличить ее на дельту. А ссылки на детей у меня сохранятся.
Потом я понимаю, в какого из детей мне нужно спуститься. Туда спускаюсь и там изменяю то же
самое, ее перекопирую, сохраняю ссылки на детей и там изменяю значение. И так далее спускаюсь до
листика. В итоге как раз будет сделано то, что хочется. У меня будет отдельно храниться старое
дерево. Если я буду поддерживать указатель на старый корень, то у меня будет оно целиком доступно,
потому что все эти ссылочки не поменялись. Там все равно хранится вся информация про предыдущую
версию. Единственное, что добавится, это появится как бы новую такую путь. Новый путь, который где-то
ссылается на, ну вот частично ссылается на старое дерево. Тут какие-то есть такие стрелочки. Ну и
хорошо получается, что как раз у меня есть как раз отличие на нового дерева от старого, что
отличается на таком маленьком пути, а все остальное как раз ссылается на старое дерево.
Может пресс? Да. То есть у нас все дерево хранится в массиве нодов? Да, можно так, ну в векторе скорее,
чтобы уметь добавлять конец. Да, хорошо. А можем ли мы отбросаться от этого и хранить только вот
основные вершины, то есть вот корни в векторе? Зачем им всех детей тоже хранить вектор? Да,
ну это хороший вопрос. Это так можно сделать, но тогда вам нужно сделать, ну в смысле они же все
же в какой-то памяти должны храниться. Да, это можно сделать, но тогда видимо, вам нужны указатели,
чтобы не хранить явно, то есть не хранить их в массиве, можно просто их где-то заводить, хранить их
по указателям, и потом, если вам нужно очистить память, то вам нужно будет от всех корней пройтись
и запустить delete от всех таких достиженных вершин. То есть можно сделать так, что в массиве
Т хранятся не вообще все вершины, а только корни, только, ну вот все версии корней. Да, и потом,
чтобы очистить память, вам нужно будет пройтись вниз и сделать дилет, так тоже можно сделать.
Ну и когда мы такую штуку сделали, потом отвечать на запрос второго типа, то есть второй тип это
когда в момент времени t нужно найти сумму на отрезке, мне нужно просто вот во всем этом
огромном наборе деревьев отрезков, то есть по сути у меня есть как бы первый корень,
какой дерево отрезка было с самого начала, второй корень, то есть как дерево поменялось после первого
запроса, третий и так далее и так далее, вот есть опять цепочка корней, как у меня, ну изменяется вот
этот вот верхний вершина моего дерева, тогда нам нужно просто найти там тетую версию, если это равно
трем, то мне нужно посмотреть, видимо сюда, да, 0, 1, 2, 3, нужно посмотреть в эту версию дерева отрезков,
и в ней просто обычным образом найти сумму, в этом дереве ищем сумму на отрезке, но так
он уже умеем делать, просто сумма на отрезке в дереве, в дереве отрезков, и здесь всё, да, вопрос,
а что у нас в итоге момент времени t хранится? а так у меня кстати конфликтовозначение, что у меня t
это с одной стороны массив вершин, с другой стороны момент времени, давайте скрутаем,
ещё раз, что хранится? у меня хранится, ну я пишу так, я пишу, что у меня есть один большой вектор t,
в котором хранятся вообще все когда-либо использовавшиеся вершины, ну раз мне всё равно
нужно иметь доступ к любой версии, то значит где-то у меня должны храниться все эти вершины,
пусть они все в каком-то порядке лежат в векторе t, в этом векторе t, также мне нужно ещё какой-то
список корней, roots это список всех корней всех деревьев отрезков, на счет вот у меня есть эта вершинка,
она лежит в roots, эта вершинка, эта вершинка, эта, и так далее, короче, все корни, все версии корней,
потому что корень всё равно всегда меняется после каждого запроса, поэтому как раз версия
у меня будет ровно столько, сколько запроса изменений, соответственно и корней будет столько,
сколько запроса изменений, храню, то есть таким образом я на самом деле всего два массива,
массив t и массив roots. а дальше, когда приходит запрос о том, чтобы в какой-то момент времени time
узнать какая была версия деревоотресков, я просто обращаюсь к элементу roots.time, и это как раз у меня
указатель или номер вершины в массиве t, который соответствует корню дерева в момент времени time.
и вот эти roots, вот эти корни как раз складывают таким образом в массив roots, что roots от time это
версия корня в момент времени time, то есть после запроса с номером time. так, ответил ли я на вопрос?
ясно. хорошо. нам в самом вот векторе с элементами не нужно хранить обратных указателей на новые
деревья, потому что если нам придут запросы к двум разным веткам, то мы не сможем правильно
дать ответ на вопрос, какая сумма будет на подотреске. что значит к двум разным веткам, я не очень понял.
ну, допустим, у нас левый и правый элемент будут изменены, а нас попросят найти сумму, ну, допустим,
на всем подотреске. ну, короче, главное, чтобы ответ не лежал в вертушине, тогда мы не сможем указать
ответ, потому что мы имеем только одну ветку. смотрите, значит, утверждение следующее, что если вы
рассмотрите вот этот вот roots от time, то все дерево, достижимое по стрелкам из этого, из этой вершинки с
номером roots от time, это корректное дерево отрезков в момент времени time, то есть после запроса с
номером time. доказывается простой индукции. если у меня time равно нулю, дерево еще не менялось,
не происходило ни одного запроса, то я в самом начале построил корректное дерево отрезков,
там в каждой вершине хранится правильная сумма. дальше, приходит первый запрос изменения. что
меняется? меняется некоторый будь, вот этот синенький будь меняется, те вершины, которые не
меняются, я на них пересылаюсь, вот эти вот черные стрелки длинные, я на них пересылаюсь,
таким образом меняется только сумма на вот этом вот синем буди, только в этих вершинах меняется
сумма. вспоминаем утверждение, что если я встану вот сюда, вершинку с номером roots от единицы,
это корень корректного дерева отрезков в момент времени после первого запроса. действительно,
вот есть корень, в нем лежит правильная сумма, потому что, по сути, я в нем как раз увеличил на
то самое дельта, который мне пришла. запрос изменения, вот здесь было плюс дельта, я это учел.
дальше, слева у меня левый сын, по сути, это все старое левое под деревом, оно не поменялось,
я в него ссылаюсь, то есть там ничего не поменялось. значит, как раз это есть корректное
дерево, что в момент времени mình, ноль, то и в момент времени один. оно не поменялось,
я могу туда сослаться. идем вправо. здесь что поменялось?
поменялось по сравнению это с старой версией только то, что сумма увеличилась на дельту.
ну, мы это учли, когда создали новую вершинку, у меня там сумма увеличилась на дельту,
поэтому здесь тоже все верно. получается, что у меня у корня и левый сын правильный и правый сын
правильный. но для всех остальных у меня, либо поменялась вершина и там увеличилась сумма
сумму на нужное значение, либо по дереву не изменилось, вот как здесь. и я на него
просто пересосвался. ну и раз там все было раньше корректно, ничего не поменялось,
ну и теперь корректно. давайте запишем утверждение. дерево,
достижимое по стрелкам из roots of time. это правильное дерево отрезков,
то есть в каждой вершине написано сумма из под дерева. правильное дерево отрезков
после запроса номер time. вроде я на пальцах объяснил почему-то так, потому что корень
я правильно написал, левый сын у него правильный, правый сын у него правильный, дальше пошли в ту
ветку, которая поменялась, и там точно так же все рассуждения проходят, что в одной вершинке
я изменил сумму на дельта. да, согласен. да, правый сын не поменялся, и там все скопировали просто.
сейчас, а у нас, мы же никогда не поднимаемся, да, наверное, по каким-то, то есть нам нужно такое узнать,
ссылку, ну, как добраться до детей, но за родителя детей не надо добираться. да, нам ссылка в родителя
нам не нужна, верно. хорошо. как мы обновляем? обновляем, в смысле, вот эту плюс дельту делаем?
ну, смотрите, значит, это вот то, что я выше писал, значит, вот то, что я здесь рисовал, смотрите,
если у меня есть какой-то корень, если у меня есть старая версия вершинки, вот это вот Т от В,
у меня было правильное в этой вершинке, у нее был правильный левый сын, правильный правый сын,
и мне нужно было поменять значение С здесь на значение С плюс дельта, тогда изменение такое,
я завожу новую вершинку В, ну, там в вектор Т, pushback, новую вершинку, сумма в ней это С плюс дельта,
потому что сумма на дельта должна увеличиться, а ссылки я просто перекопировал, то есть левый сын
ссылается сюда, туда же, куда и раньше, и правый сын ссылается сюда, тоже туда же, куда раньше.
Получается, я вот одну вершинку так скопировал, как бы сохранил ссылки и поменял значение,
а дальше, чтобы поменять в поддереве, я, ну, как бы по сути спускаюсь рекурсивно, что если
мне нужно поменять что-то в этом поддереве, то я встаю в эту старую вершинку, встаю, сначала ее
копирую точно так же, как, ну, в общем, процедура копирования вершинки вот в какую-то новую,
создаю новую вершину, если здесь была какая-то сумма, не знаю, у, то я здесь пишу у плюс дельта,
и вот эти вот ссылки перекопирую просто из старой вершинки, то есть обновление это просто
вот копирование вершины с перенаправлением стрелочек и рекурсивный спуск до правильного листика.
А массив roots мы как заполняем? Когда мы копируем корень, мы врут с pushback-ом новый корень.
Когда мы копируем, ну, на моменте времени t равное i, мы же копируем t-ity корень. Ну,
как бы мы из предыдущего корня, не из основного, который был на 1 раньше.
Да, мы всегда смотрим на предыдущую версию и оттуда перекопируем, да.
Ну, у нас задача такая, что у нас есть как бы сплошной поток изменений, и каждое изменение
это изменение по сравнению с предыдущим запросом, что вот всю предыдущую историю мы
сохранили, а еще нужно сделать новый запрос, изменение. А запросы второго типа, это вот во
всей этой истории изменений, длинной и большой, мы делаем какие-то случайные хаотические тыки,
а вот там, не знаю, 5 лет назад что было, а 10 лет назад, а там, не знаю, а вот 5 секунд назад что
было, да, то есть есть сплошная история изменений подряд, каждый запрос изменяет массив по сравнению
с предыдущим, с предыдущим состоянием, а потом тыки в произвольные места, это вот как раз просмотр
какой-то версии, какой-то более старой версии. Так, окей, вроде плюс-минус, еще раз палец
вопроса. Давайте тогда заметим про время работы всего этого дела. Во-первых, время, время работы,
как всегда, логарифм на запрос, логан на запрос, значит, логан на запрос, ну потому что, то есть,
какой у меня запрос, у меня есть запрос изменения, запрос изменения, у меня работает так, я по сути просто беру
какой-то путь в старом дереве, в предыдущем дерево, перекопирую его, точно так же, да, то есть,
создаю вершины к столику, сколько было в нем, ну и там перенаправляю вот эти стрелочки, вот эти все
стрелочки перенаправляю. Это работает за длину пути, то есть, за логарифм, потому что, ну, глубина
дерева у меня по режиму логарифм. Это запрос изменения, запрос нахождения суммы, это нужно просто в
такой-то версии, да, в конкретной версии дерево отрезков, найти сумму на отрезке, сумму на отрезке мы
знаем, как искать за логарифм, как обычно. Вот, но единственное, что здесь такое неприятное по сравнению
с обычными деревьями отрезков, это затраты памяти, затраты памяти. А именно, у нас каждый запрос изменения,
он связан с логарифмическим количеством новых ячеек. На каждое изменение, каждый запрос изменения,
изменения, это создание логен новых вершин, логен новых вершин. Ну и нам все эти вершинки надо
хранить, да, либо в явном виде, вот как я пишу, в массиве t, ну, в векторе t я их все сохраняю, либо мы можем
явно на них ссылки не хранить и просто писать все по указателям и хранить только ссылки на корней,
вот. Но все равно они где-то же в памяти лежат, это все равно учитывается в количестве затрачивания
памяти, поэтому это нужно, этим нельзя пренебречь, у нас на каждом шаге заводится логен новых вершин.
Поэтому память здесь построена с обычным деревом отрезков, у меня память растет от запроса к запросу,
и тем самым, если у меня было всего q запросов, q запросов, то память у меня тогда задействуется,
ну я напишу так, n плюс q log n, n это от исходного, ну, от исходной версии дерева отрезков,
от самого начального дерева отрезков, и q log n по логарифму на каждый запрос.
То есть, по сути, все здорово, мы отвечаем за такой же логарифм на каждый запрос,
только немножко растет память, память растет логарифмично от каждого запроса.
Такое важное замечание.
У вас спрашивали, как обновлять дерево, и вы говорили, что сверху вниз, а что если не
получится обновить сверху вниз. Ну, например, задача у нас на семинаре была, к массиву поступают
запросы изменения элемента, и после каждого запроса нужно сообщить под отрезок всего массива
с максимальной суммой. Вот, это не получится изменить сверху вниз, это нужно снизу вверх
изменить. Получится, да, получится сверху вниз. Ну, на самом деле, снизу всегда более слабо,
чем сверху. Давайте кратко отсудим. Значит, раз вы это решали, то вы, наверное, хранили в каждой
вершине отрезок с максимальной суммой в поддереве, сумму на всем отрезке, а также максимальный
суффикс и префикс, правда? Ну, тогда, смотрите, если мне нужно обновить в каком-то элементе
значение, а это нужно поменять. Значит, я иду сверху вниз, запускаюсь рекурсивно вдоль этого
пути, и, допустим, вот здесь, когда я дошел до этого листика, понятно, что там нужно написать,
то есть у меня контролируется только одна вершина, а там все эти вершины понятно пересчитываются.
Дальше мы эту рекурсию как бы разворачиваем и идем снизу вверх. То есть, когда я там сначала
спустился в сына, посчитал, что в сыне нашлось правильное значение, и теперь я склеиваюсь,
ну, то есть пересчитываю значение в текущей вершине, зная значение в новом сыне. То есть,
скажем, вот здесь у меня есть вершинка В, я запустился от там правого сына в В плюс один,
и в нем хранится новое правильное значение, мне нужно пересчитать значение В. Ну, как это делать?
Собственно, мы храним эти четыре значения для того, чтобы это можно было склеивать. Если я знаю
максимальную подсуму здесь, максимальную подсуму здесь, то нужно здесь взять из них максимум,
потом максимальный префикс это либо максимальный префикс отсюда, либо, сумма здесь плюс максимальный
префикс отсюда, ну и так далее. По сути мы склеиваем ответ на vibrations pounds с левой
и с правой, и получаем ответ с вершинки В. Ну, то есть вы сначала спустились сниз,
по нас издавав новые вершины по капусты... Да, и с родновными значениями. Потом поднимаетесь
здесь вверх, пересчитываешь все? Да, я понял. В каком-то смысле да, то есть я иду по сути снизу,
то есть я проталкивал информацию снизу вверх, но перед этим я все равно прошел снизу вверх,
извините, сверху вниз, все перекопировал, ну и уже по этому новому пути иду снизу вверх.
хорошо, так это обсудили, персентное мы обсудили, вот, и зачем это может быть,
например, нужно. давайте вспомним задачу, которая была в прошлый раз, про количество
чисел на отрезке, количество чисел на отрезке, которые больше или равны чем x,
напоминаю кратко, есть какой-то статический массив неизменяемый, статический массив,
а 0, 1, так далее, n-1, и поступают запросы одного типа, это три числа rx, мне нужно на отрезке с
a или rt найти количество чисел, которые больше или равны чем x, то есть количество чисел,
которые лежат на отрезке, и при этом сами хотя бы больше или равны чем x. вот мы решили в
прошлый раз с помощью fractional cascading, да, это вот когда там, ну, не буду, не буду обсудать,
еще раз, с помощью merge sort 3 мы это сделали, теперь мы это сделаем с помощью персентного
деревоотреска, то же самое, только альтернативный подход. значит, давайте сделаем следующее,
давайте мы отсортируем весь наш массив, там, любым алгоритмом сортировки, хоть merge sort, хоть
quick sort, хоть что хотите, а именно, давайте мы заведем массив sort от вот таких вот пар,
а 0 запятая 0, а 1 запятая 1, и так далее, а n-1, n-1, то есть мы не только посортируем,
но также запомним, как бы, откуда каждый элемент пришел, заведем такой массив пар,
отсортируем их, ну, как обычно, как обычно, сортируются пары, сначала сравниваются
по первому элементу, потом по второму, так вот, после сортировки, когда я вызываю алгоритм,
там, любой алгоритм сортировки нашего массива, sort, у меня как раз будут расположены числа
в порядке возрастания, и при этом я про каждое число знаю, где оно лежало изначально, не знаю,
там, сначала будет минимальное число с позиции этого минимума, потом, какой-то второй максимум,
да, second минимум, его позиция, ну, и так далее, то есть, по сути, у меня есть сортировка массива,
а также, откуда пришел каждый элемент, тогда давайте сделаем следующее, давайте мы сначала убьем все
элементы, будем считать, что все элементы мертвы, все элементы мертвы, ну, и заведем дерево отрезков,
которое считает количество живых элементов в поддереве, которое хранит количество живых
элементов, значит, сначала все мертвые, и у меня в каждой вершинке ноль живых, затем мы будем
оживлять эти числа, эти элементы в порядке возрастания, то есть, мы сначала оживим минимум,
нет, давайте, наоборот, в порядке убывания, извините, оживляем, в порядке убывания, да, и сначала мы оживим
максимум, потом предпосреднее, увеличенное число, потом предопред, последнее, и так далее,
оживляем элементы, элементы в порядке убывания, порядке убывания, и получается, что у меня к дереву отрезков
отрезков вступает запрос оживить какой-то элемент, но соответственно, когда элемент оживает,
мне нужно на всем пути от него до корня, или что-же самое, от корня до него, прибавить единичку,
там у меня ожило по элементу в каждом из этих вот, ну в каждый из вершинок один элемент ожило,
мне нужно прибавить один, то есть по сути оживление это плюс один на пути в дереве,
на пути в дереве, и мы это дерево будем хранить персистентно, персистентное дерево отрезков,
то есть мы будем хранить все его версии, мы будем хранить версию, когда все мертвые,
потом когда один живой, потом когда два живых, три живых, и так далее, и так далее,
все эти версии мы будем хранить. а дальше что? а дальше, когда мне приходит запрос в стиле,
сколько есть чисел на отрезке lr, которые больше равны, чем x, я посмотрю на дерево отрезков в
момент времени, когда живыми были только элементы, больше равные, чем x. у меня же все равно,
у меня есть версия дерево отрезков, когда живые все, ну там сколько-то максимальных элементов,
есть версия, когда жив только максимальный, есть версия, когда живые два максимальных,
и так далее, и так далее, то есть по сути для каждого x. у меня есть версия дерева отрезков,
в котором живы все элементы больше равні, чем x, и больше никто не жив, но если в этом дереве
отмечено как раз только те самые элементы, которые мне нужны, да, те живые элементы,
которые больше равны, чем x, мне нужно просто найти кори full живых на отрезке в каком-то дереве,
ровно это мы и будем делать. мы просто обращаемся к нужному дерево отрезков,
когда живые элементы это те самые, которые мы больше равные, чем x, и потом
просто находим количество живых на отрезке. можно вопрос? да. как мы определяем версию,
в которой были... бинпоиском. а, бинпоиском. все, понятно. так, давай сейчас мы все это напишем.
итак, давайте... обжимем просто номер махива. еще раз? а, у нас же числа нечестные. ну скорее
любые целые. ну да, ну может быть вещественные. не только те, которые лежат в дереве. да-да,
могут быть не обязательно из массива. итак, давайте напишу следующее. для любого и от одного
у нас есть версия DO, у нас есть версия дерево отрезков, в котором живы только элементы,
больше либо равные этой порядковой статистике. этой порядковой статистике. я напоминаю,
что эта порядковая статистика это как раз число, которое находится на этом месте после сортировки.
и вот здесь, когда я массив сортир посортировал, у меня как раз там, да, на первом месте хранится
Pure numbers в минимум. то есть первая порядковая статистика на втором, второе минимум, то есть вторая
статистика, и так далее. и вот когда я иду в порядке убывания, в ite-м дереве есть все числа,
которые больше равны, чем ite, после сортировки. то есть больше чем ite порядковая статистика.
и для каждого ite, то есть для каждой порядковой статистики, у меня есть для каждого числа,
по сути. у меня есть версия DO, которая хранит все числа больше, равно чем оно, да и живые,
только они. тогда значит ответ на запрос такой, ответ на запрос lrx. мне нужно найти такое и, найти
минимальное и, что и та порядка статистического массивя, и та порядка статистического массивя
больше равна, чем x. потому что мне нужно сейчас рассматривать, ну считать живыми, только те
элементы, которые больше равны, чем x. давайте тогда вот найдем в нашем массиве sortit, в ассортированном
массиве нашем sortit, мы найдем первое число больше равна, чем x. и тогда как раз живыми
нужно считать только те, кто стоят правее. вот эти вот живые. раз мне нужны все больше равны,
чем x. и это какое-то там какое-то итое число. значит мне нужна просто ита версия деревоотресков
посмотреть в ней, вот просто посмотреть, что было в ита версии. и количество живых там на отрезке lr,
это в точности интересующие меня значения. в точности количество чисел на отрезке lr,
которые больше равны, чем x. в конце нужно найти количество живых на отрезке lr в итом деревоотресков.
вот такое симпатичное решение. мы все посортировали, потом прошлись порядки возрастания и храним
персидентное деревоотресков, храним персидентное деревоотресков, которое знает все свои версии,
и для каждого числа знает, есть версия, где живые как раз все числа больше равны, чем это число.
потом просто по x мы находим вот этот и минпоискам, что живыеanno сflowed table,
что все числа больше равны x находим этой версии деревоотресков, and then we just need
найти число живых элементов, потому что живые и больше равны x% в том дереве, в той версии,
же одно и тоже. живые и больше равны x �о, в этой версии деревоотресков. ну все количество живых
а мы в каждой вершине в качестве значения мы храним что то есть количество живых клеток на
отрезке который эта вершина контролирует верно да да все верно количество живых а запросы меня
это просто ну какой-то элемент из мертвого сделать живым и тогда нам нужно на пути сделать
плюс один просто пути откорнят эту вершинкой сделать плюс один вот давайте тоже померяем
асимптотики всякие время n log n потому что что у меня значит у меня есть сортировка за n log n
сначала потом я иду в порядке убывания по всем элементам и для каждого числа я за логарифом
делаю обновление как всегда в дереве отрезков у меня как бы когда я перешу к персистентной
версии у меня логариф на запрос сохраняется то есть n log n на предпочет ну и потом там давайте
ку логен на запрос плюс ку логен чтобы обработать все запросы потому что если у меня всего ку
запросов на ку запросов то каждый запрос я обрабатываю за логарифом потому что нужно сначала
сделать запустить один поиск чтобы найти вот этот самый и да больше ну что это порядка стрифика
больше нашим икс нужно найти правильную версию до а дальше в этой дереве в этом дереве отрезков
еще найти сумму на отрезке этом еще логариф поэтому время такое ну а память здесь будет
просто логен потому что мне нужно хранить n версии персистентного дерева отрезков да и выше
мы писали что каждая версия это плюс логариф памяти раз всего n версии то соответственно мне
нужно n логен памяти иметь вот такая престь хорошо это было персент на дерево отрезков
теперь давайте еще одну модификацию рассмотрим это динамическое дерево отрезков динамическое
дерево отрезков вдохновиться можно следующей следующим примером есть у вас вещественная
прямая с координатами там от нуля до 10 18 изначально в каждом в каждой точке как бы записан 0
в каждом числе ну в каждой позиции написано число 0 в каждой толчочной позиции написано число 0
и поступают запросы как всегда как мы любим двух типов значит в какой-то точке x поменять
число написать туда вал а икста присвоить вал и второе это запрос суммы нужно найти сумму с
аэль по аэр то есть это практически обычное дерево отрезков только у меня массив на котором все
строится да вот этот массив он имеет не какой-то адекватную длину n а длину 10 18 я даже не буду
это означать и н кай потому что ну это обычно что-то вот ну адекватно да что можно работать
за вот он или вот он уген здесь конечно не за 10 18 и не за 10 не за илоген не заработать поэтому
нужно что-то лучше то есть по сути это как обычное дерево отрезков по крайней мере задача такая же
только у меня очень большой исходный массив массив имеет длину как бы 10 18 и он даже ну явно
мы его нигде не будем хранить конечно вот он вот изначально ну ли в каких-то точках изменения и
потом сумма на отрезках вот идея такая давайте мы как будто бы построим дерево отрезков на
всем этом огромном массиве длины 10 18 прям целиком да построим такое большое дерево отрезков но
будем хранить в нем только вершины в которых хоть что-то происходило потому что понятно что
изначально у меня во всех решениях хранятся нули дай и каждая сумма в любом подделе это 0 поэтому
по сути нам даже ничего хранить не нужно там заведем корень и приличия таковым что корень
соответствует отрезку 0 до 10 17 и в нем сумма равно 0 потом если придет запрос изменения в
точке то что происходит по сути давайте пересуе чтобы у меня не было наложение насчет есть у меня
огромный массив который явно нигде не хранится есть корень 0 10 18 сумма равна
потом приходит изменение в какой-то точке их нужно написать что вал что меняется меняется
что-то в очень небольшом числе вершин нам уже понимаем только что наблюдали персоветом
что меняется у меня только ну вот этот путь мне нужно там как-то правильно дойти до вершинки
и кстам какой-то длинный будет путь ну короче как-то мы сюда пришли тогда давайте вот эти вершинки
их как бы пока что явно еще нету у меня просто нету ссылок ни налево ни налево ни направо сына
у корня их вообще еще не существует давайте заведем то есть понятно что раньше был 0 поэтому
в принципе то что мы ее не хранили это не страшно мы так знаем что вам сумма равна 0 поэтому
можно было бы не хранить но если у меня теперь поступает к ней запросы мне нужно туда спуститься
но что делать заведем ее создадим вот этого права сына скажем что там отрезок ну какой-то
видимо 10 18 пополам 10 18 сумма все еще ну вот и так далее короче спустимся до вот этого икса и
все эти вершинки по пути создадим ну их там раньше не было там был ну вот их сначала создать а потом
уже если у меня есть этот путь то мне нужно просто вдоль этого пути пройтись и в них
вовсе прибавить вал на что это все нужно сюда поставить и соответственно сумма на всем этом
пути увеличивается в точности на вал потом если приходит какой-то другой запрос там в какой-то
другой точке игрек нужно что-то что-то поменять я опять как будто бы спускаюсь в эту вершинку
игрек как я спускался бы в обычном дереве отрезков только каждая вершина которая пока не существует
который я пока не создал мы ну я ее создаю там мне нужно спуститься в левого сына ну что
поделать спускаюсь и создаю его здесь будет там координаты от нуля до 10 18 пополам сумма тоже
ну давайте здесь плюс один чтобы не перескалось вот сумму ровную все вершинки тоже на пути
создаем которые там еще не были и потом обратно поднимаемся и делаем плюс там какой-то вал новая
не вал на всем этом пути вот и так будем работать просто если нужно пойти вершины вот прям по зарез
нужно и там что-то поменять то и причем ее еще нету то создаем пишем что там сумма равна нулю раз
мы там еще не были там еще ничего не приходил сумма точно 0 создаем и туда заходим а если вершинки
нету то значит ну и собственно там сумма нули то и нам туда не надо не надо идти то ее просто не
храним то есть такое динамическое зерево отрезков оно очень ленивое оно хранит только что-то
полезно оно не хранит все вот эти подделия где сумма точно 0 нам это не нужно там точно ли и
если нам потребуется мы всегда эти вершинки сможем завести вот ну давайте напишем какой-нибудь такой
микрокод что я хочу иметь давайте я ну тоже у меня будет вершинка структ нот которые хранится
сумма давайте я для удобства напишу здесь же tltr вопрос какой-то
нету она значит в вершинке я вот поддерживаю координаты отрезка который который она контролирует
значит дальше что мне нужно мне еще нужна ссылка налево право сына и левт и трайт
я строит вот дальше значит как у меня работать скажем процедура дай да ну и давайте еще
конструкторе промолчанию то есть дефолтными значения вот этого левта и райта мы поставим
чисто минус один как знак того что у меня нету изначально ни левый ни правого сына и там как
бы нулевая сумма там ничего не происходил это скучные вершины мы их как бы даже не
создаем говорим что минус один так вот как работает апдейт как работает апдейт скажем
в вершинке в когда мне нужно в позиции какой-то пост так плохо давайте ниже
сейчас сур апдейт находится в какой-то вершинке в понимает что в какой-то позиции пост мне нужно
ну давайте я буду хранить не вал а сразу дельта пусть там я знаю что мне нужно увеличить вдоль
пути все надо и простой случай что если да и да и у меня будет вот здесь вектор этих решений
вектор нот также как раньше мне будет вектор всех всех у меня будет в одном месте хранится
информация во всех решениях в каком-то перемешанном порядке да да да да правильно все пишете по факту
умеет все то же самое что и обычно что и обычно но без лишних затрат на память при этом да все так
да при этом как на большей массиве тоже работать и так если ты в это точка tail равно ты в этой
точке tr то есть если я спросился в листик или выгонить срадно правой тогда мне нужно просто
обновить сумму тв это точка сам плюс равно дельта и ретерк если я спросил соблисты делать ничего
не нужно мне нужно просто обновить сумму на этом закончится дальше наступает интересное понятно
что мне нужно во первых в этой вершинке обновить сумму на то есть что раз по деревья поменялся
какое-то шло на дельта то и сумма здесь изменилась на дельта поэтому здесь давайте вот этот трешку
просто вынесу до этого и факт я в самом начале в любом случае понимаю что сумму надо увеличить
сумму увеличил если в листе то сразу делаем ретерн иначе нужно пойти в детей и возможно
какие-то здесь не существует если не существует давайте создадим я напишу это следующим образом
лонг лонг тм это как всегда наша любимая полусумма координат до полусумма границы
тв тл и тв т тр пополам больше больше один теперь нужно сделать следующий если мне
нужно пойти в левого сына и при этом его не существует то пожалуйста создай его напиши там
сумму ноль и запустись рекурсивно от левого сына значит если т в это точка т л равно минус
единицы и при этом поз меньше в равно чем тм так меньше и равно чем тм да то есть мне нужно пойти
в левого сына и при этом его еще как бы я не создал тогда вот нужно его прямо сейчас срочно
создавать ну создадим давайте мы добавим в вектор т новую вершинку с какими параметрами ну давайте
я напишу так вольно я хочу чтобы у нее сумма была нулевая тл у нее такой же как у вершинки в
датель равно тв это точка т л а т равно т м потому что левого сына мы знаем что у него граница
этот т л заветает и вот мы создали такую вершинку в нее сослались и с текущей вершины т в этой
точке левт равно т точка с ась минус 1 потому что как бы я добавил новую вершинку на нее
сослался и с текущей то есть это мой текущий новый левый сын тем самым не нужно как бы ты
в это точка левт обновить вот я обновляю ну и в конце нужно запуститься рекурсивно а даже даже
не так я вот это сделать а то есть я сейчас создал левого сына и теперь если мне нужно пойти в
лево сына то я запускаюсь в него рекурсивно update т в этой точка левт пост дельта вот иначе
если мне нужно работать с правым сыном то тоже аналогичный кусок кода обработки правого сына
если правого сына нету мне туда нужно пойти то есть если пост больше чем тм то мне нужно
право сына завести создать новую вершинку положить туда правильное значение сумм т л тр сослаться
из в в качестве правого сына на эту новую добавленную вершинку и запуститься из нее
рекурсивно вот и я разнес вот это вот условия да что я вот это вот не вписал сюда потому что
а что делать если левый сын был то есть если левый сын был то его не нужно пересоздавать я
просто в него спускаюсь рекурсивно а если его не было то я сначала создал и потом потом в него
перешел это создание левого сына создание а это это спуск в это самое дело сын все его сначала
создал если его не было а потом если туда нужно то я туда и спускаюсь вот ну такой вот будет код
для апдейта соответственно гет я я уже писать не буду но смысл такой что если вам нужно найти
сумму на каком-то отрезке и скажем вы пытаетесь пойти в под дерево где написан минус один то есть
вы показать и пойти вершину которая несоздана но значит туда идти вообще бессмысленно сумма там
все равно ноль если решение создана значит туда вообще никаких запросов еще не приходила значит
сумма в том под дереве 0 млн дайте это же бессмысленно сумма все равно будет мореisode мы в
enschaftа не идем если ускорити только в те вершины которые существуют которые немецоним и так вот
я все обойду если я пытаюсь пойти в не существующие рияна не accelerator а все остальные который
который я обойду, а тут нужно сложить сумму и получит сумму на отрезке.
А мы правого сына игнорируем?
Нет, это я просто не дописал, вот то, что я здесь написал,
многоточие по скотчу tm, это в смысле нужно написать аналогичный код для правого сына,
то есть если правого сына нет, то мы его создаем, и если нужно пойти в правого сына,
то мы в него спускаемся рекурсивно, я просто не буду писать, потому что код аналогичный.
Мы его не игнорируем, отдельно пишем, просто я здесь этого не отобразил.
Так, а мы не поднимаемся потом вверх, чтобы обновить вал, не поднимаемся,
потому что мы в самом начале, я вот эту строчку написал прямо вот первой при заходе в апдейт.
Я зашел в апдейт, сразу же, я понимаю, что поменялось, у меня все увеличилось на дельту,
поэтому давайте вот прям сразу в этой вершинке увеличу все на дельту,
и потом просто рекурсивно спущусь в сына, мне не нужно будет передавать информацию снизу вверх,
я уже знаю, ты в этой точке сам, мне его не нужно пересчитывать.
Так, отлично.
Так, еще вопрос. Вывне должно быть tv-tlf равно минус один вместо tl?
Ой, ой-ой-ой, это я видимо отписался.
Да, спасибо большое, это я виноват, конечно, здесь конечно левт, да, левт.
Спасибо, tl это граница, которую я контролирую, то есть вершинка v контролирует отрезок с tv-tlf по tv-tlf,
а tv-tlf это ссылка, точнее номер левого сына, ссылка на левого сына.
И если вот это вот tlf равно минус 1, если нет левого сына, тогда нужно его создавать.
Да, спасибо, не справили.
Вот, отлично. То есть это мы и научились как бы решать задачу, когда массив мой большой.
Что-то вот со временем, время...
Ну, что здесь можно сказать?
Ну, понятно, что каждый запрос обрабатывается опять-таки за логарифм,
только логарифм будет вот 10 и 18.
Давайте я напишу log c на запрос,
где c равно 10 и 18.
То есть если длина вот этого вот как бы неявного массива это 10 и 18,
то, как всегда, работает все за логарифм, потому что там это обычный спуск по дереву,
либо сумма отрезки, либо апдейт точки, это все работает как в обычном массиве.
А все вот эти операции на создание, ну, в Одиссеи, то есть создание вершинок, которых раньше не было,
они не заменяются всегда от единицы, поэтому все равно главное слагаемое,
это вот глубина нашего дерева будет log c.
Ну, с памятью здесь все то же самое, что в персистентном,
потому что в худшем случае на каждом запросе мне придется создать log c новых вершин.
Поэтому в худшем случае опять-таки плюс log c на запрос.
Потому что может быть такое, что я иду по такому странному пути, где я еще ни разу не был,
поэтому и каждую вершинку мне нужно создать, значит в худшем случае будет log c.
Получается, работает за константы, да, все верно.
Ну, это так, шутка, конечно, потому что, ну, это, это, конечно, большая константа, ее лучше учитывать,
но так тоже можно сказать.
Так, хорошо, хорошо.
Давайте тогда в последнее время, которое у нас остается, мы обсудим разницу подходов онлайн и офлайн.
Онлайн против офлайн.
Здесь имеется в виду следующее.
Всюду, кажется, до этого момента мы говорили про ответственность запроса онлайн.
То есть следующий запрос приходит только после того, как мы обработали предыдущий.
Давайте я это запишу.
Онлайн – это когда следующий запрос приходит только после ответа на предыдущий.
Ну и, собственно, всюду выше мы делали ровно так.
Сначала пришел запрос, я сначала на него отвечу, потом перейду к следующему.
Это вот такой подход, когда мы сразу отвечаем на то, что нас просят.
Есть другой подход, есть подход оффлайн.
Это подход, когда вам все запросы известны заранее, то есть, я не знаю, вы всемогущий предсказатель,
который знаете, какие запросы у вас будут просить пользователя,
либо у вас такая структура, что, не знаю, пришел заказчик и сказал,
вот, типа, у меня будет такая машина, к ней будут такие запросы, пожалуйста, быстро их обработайте.
То есть я вот знаю все, что будет, точно, мне нужно просто это быстро обработать.
То есть оффлайн – это подход, когда все запросы известны заранее.
Все запросы известны заранее.
И вам не нужно отвечать на текущий запрос перед переходом к следующему.
Вы сначала их все можете прочитать как-нибудь интересным образом переупорядочить, как вам удобно.
Потом отвечать в каком-то произвольном порядке, как вам удобно.
Опять, да, вы можете сначала ответить на первый запрос, потом на 20-й, потом на 3-й и так далее.
Вот как вам хотите, так можете отвечать.
Но главное, чтобы только не конкретовали, чтобы там, ну да, то есть не было, чтобы изменений там между 1-м и 20-м,
если вы сразу так телепортируетесь.
В общем, как-то эти запросы вы можете так и порядочить, что вам будет удобнее на них отвечать.
И в оффлайне, конечно, вы чуть более способны.
У вас есть больше возможностей, вы больше знаете про задачу, и довольно часто у вас задача сильно упрощается.
Давайте рассмотрим несколько примеров того, почему переход в оффлайн, он чаще, ну, то есть иногда дает вам какие-то новые возможности,
дает возможность решать задачу быстрее или проще на использовании более простой структуры.
И такое довольно часто наблюдается, но мы все-таки по умолчанию, то есть если в задачах не прописано прям словами,
то скорее всего имеется в виду, что нужно решать онлайн.
То есть на каждый запрос отвечаем вот прям сразу же, как только он пришел.
Ничего не известно заранее, нужно отвечать сразу, как только он пришел.
Но иногда, когда это не так, когда все известно заранее и об этом прямо сказано, тогда можно все это делать.
Итак, первая, первая иллюстрация вот этого оффлайна против онлайна, это сжатие координат, сжатие координат.
Значит, вспоминаем задачу, которая у нас была в динамическом дереве отрезков, динамическое дерево отрезков.
И пусть нам все запросы известны заранее, пусть все запросы известны заранее.
То есть мы знаем, что там сначала придет запрос изменения в такой-то точке, потом придет запрос суммы на отрезке.
Потом такое изменение, такое изменение, такая сумма и так далее, и так далее. Мы знаем все запросы.
Тогда идея следующая. Нам не нужно динамическое дерево отрезков, нам хватит обычного дерева отрезков.
Потому что, ну вот смотрите, если все запросы известны, тогда как бы что это значит?
Это значит, что я знаю какие координаты в принципе вообще важны в этой задаче.
в принципе, вообще важны в этой задаче. То есть в каких координатах что-то будет происходить.
Я знаю все x, в которых что-то происходит, я знаю там все l и все r. Я знаю в каких точках что-то будет
происходить. Давайте тогда я возьму этот вектор всех координат, сложу их в один большой вектор,
и посортирую. Еще есть такая удобная функция c++, это unique. После того, как мы все посортировали,
если написать такую строчку sorted.precise.unique.sorted.begin.sorted.end.
минус sorted.begin, то у вас из массива удалятся дубликаты. То есть мы понимаем, что какие-то
там x могут быть равны каким-то другим, x равны быть каким-то l. Здесь могут быть равные числа,
чтобы от них избавиться мы вот так вот проявляем, запустим функцию unique, которая все равные числа
вам. По сути для нас просто их удалит, удалит все повторы. Вот такая строчка удалит все повторы из
массива. А дальше смотрите, у вас есть список всех интересных позиций. Тогда давайте мы построим
дерево отрезков вот на этих вот позициях. То есть я знаю что-то, не знаю, ну пусть sorted,
после этого всего sorted. Это какой-нибудь там массив 3, 4, 10, 15, 17, 22. Тогда давайте просто
построим дерево отрезков на вот этом вот массиве из шести элементов в данном случае и будем с ним
работать как с обычным деревом отрезков. Не как с динамическим, а как с обычным деревом отрезков.
И тогда у меня будет, ну во-первых, прелесть, что это обычное DO, а не динамическое. То есть обычно мы уже
умеем писать. То есть динамическое конечно не сильно сложнее, но обычное DO, ну как минимум быстрее,
потому что там меньше число под логарифмом. Там было 10, 18, здесь откуп по сути, от числа запроса.
Сейчас отвечу на вопрос чатча. Мы построили дерево отрезков на этом запросе, и мы можем отвечать
как бы на вот этом массиве, можем отвечать на все запросы. Потому что когда приходит запрос
обновить число в позиции 10, мы находим где-то число 10 находится в нашем массиве сорта бин поиском,
и говорим, что вот здесь в DO надо сделать плюс дельта. Когда приходит запрос суммы,
там на отрезке 4.17, я понимаю, что вот 4, вот 17, опять двумя бин поисками нахожу эти два
числа в мою массиве, понимаю на каком отрезке нужно найти сумму, и там нахожу сумму в обычном
дереве отрезков. И как раз прелесть в том, что я выкинул те числа, к которым заведомо не будет
запрос. И в итоге мне достаточно обычного дерева отрезков. Достаточно обычного дерева отрезков.
Без всякого динамического, без этих указателей, большого, не явного большого массива данных,
мне достаточно будет DO на массиве сорта. Вот такое преимущество по сравнению с подходом онлайн.
Если все в оффлайне, если я знаю все запросы заранее, то можно это сделать все быстрее.
Так, вопрос про еник. Как он работает? Удаляет повторяющиеся элементы только из ассортированного
или можно с произвольным? Чтобы он делал то, что нужно, нужно сначала ассортировать. Потому что
еник, он проходится, и если видит несколько подряд равных, то, грубо говоря, удаляет вот как бы
блок равных, оставляя из него только одно. Если у вас, например, будет там, не знаю, 3 единицы,
2-ка, 3 единицы, тогда он удалит вот эти 2 единицы, вот эти 2 единицы, но не поймет, что вот эти 2 единицы
одинаковые. И оставит вам и то, и то. А мы хотим как раз, чтобы каждое число встречалось ровно один
раз из тех, которые есть. Поэтому нам нужно его сначала ссортировать, сгруппировать блоки равных,
и потом удалять. Еник работает за ОАТН, потому что это просто проход по массиву. Ну то есть,
раз у меня все ассортировано, у меня сначала идет блок единиц, потом двое, потом тройка,
и так далее. Он просто идет по блокам, видит единицу, ее сохраняет, остальные удаляет. Ну там не то,
что удаляет, а перемещает их как бы в конец массива. Вот. Короче, за ОАТН. Просто нам нужно из каждого
блока оставить по одному числу, это работает, понятно, за любым. Вот, вторая иллюстрация. Это, давайте
мы обсудим кратко дерево поиска. Дерево поиска онлайн. Мы скоро к нему перейдем, видимо, через
лекцию, не на следующую, а через одну. Дерево поиска оффлайн. Дерево поиска, мы еще будем подробно
про это говорить, но дерево поиска это такая структура, которая умеет отвечать на запросы,
скажем, трех типов. Она как-то поддерживает множество S. Со следующими операциями insertX,
то есть добавить XS. EraseX. Удалить XSS. И третье findX. FindX. Сообщить, есть ли XS. Вопрос в чате
set или multi-set, неважно. Давайте считаем, что set без повторяющихся элементов. Без повторяющихся.
Давай считаем, что запросы такие, что не бывает двух подряд insert одного и того же числа. Вот,
то есть мы почти что умеем это делать с помощью кучи на самом деле, потому что куча умеет делать
insert и умеет делать erase. Вот это наша хитрая реализация про хранить кучу удаленных элементов.
Но, к сожалению, она не умеет делать find, потому что find в куче, чтобы найти какой-то элемент в куче,
нужно ее всю пройти. Никак по-другому это сделать нельзя. Эффективно. Мы чуть позже будем изучать
разные подходы к тому, как это можно сделать. Там куча-куча всяких разных реализаций есть,
как вот у кучи есть двоичная, биномиальная, фибоначчо и много-много других. Также у дерева
поиска есть, наверняка знакомый многим из вас, дерево декартовое дерево, которое все это умеет
делать. Ну и плюс также мы посмотрим на кучу всяких других. АВЛ дерево, red-black дерево,
красно-красно-черное, которое лежит в основе того, что как раз set в C++. Ну и там еще какие-нибудь
другие. Посмотрим тоже интересно. Так вот, теперь представьте, что вам все эти запросы
известны заранее. Вам известно заранее, что придет такой-то запрос insertX, потом findY,
потом erase что-то, insert еще что-то и так далее. Вы все знаете. Как всегда в оффлайне все запросы
известны заранее. Тогда нам не нужно никакого декартового дерева, нам не нужно никакого дерева
поиска, потому что если мне все известно, то давайте сделаем практически то же самое,
что было выше. Давайте мы зафиксируем себе, про какие в принципе элементы приходят запросы,
insert, erase и find. Сохраним какой-то вектор, посортируем, проявляем и будем хранить,
извините, массив просто, булевских флагов есть это число или нет. Запрос известны заранее. Мы
считаем все интересные назначения, все интересующие назначения, посортируем,
проюникаем, то есть удалим дубликаты, потому что если приходит insertX, потом findX,
то X будет два раза, мы хотим, чтобы каждое число было по одному разу. И теперь у меня в массиве
sorted будет информация о тех числах, которые в принципе когда-либо приходят, ну придут в запрос.
Пусть это там, не знаю, опять 3, 4, 8, 15, 20. Тогда давайте мы будем хранить 5 булевских значений,
true, false, 0, 1, true, false, true, false, true, false. И если приходит insert, не знаю, insert 15,
то мне нужно это 15 найти в этом массиве, bin поиском, нахожу 15 и говорю, что здесь единица,
то есть я это число добавляю в моё множество. Приходит erase 8, нашёл эту 8 bin поиском, сказал,
что мы её удаляем, теперь она не хранится в массиве. Приходит find, я опять нахожу bin поиском,
и просто то число, которое, ну там true или false, если true, то значит число есть, если false,
то значит числа нет. Ещё раз find, это просто bin поиск, и просмотр, true или false, если true,
то число есть, если false, то числа нет. Получается, что какая-то симптотика, ну тут сортировка,
если всего к у запросов, то всё это обрабатывается за кулак ку, потому что сортировка ку чисел в
худшем случае, а потом на каждый запрос мне нужно один bin поиск и одно изменение булевского
значения, true or false, или просто просмотр его. Получается обработка всего за кулак ку, повторюсь,
если все запросы известны заранее, и по сути нам не нужно никакого декартового дерева, если всё
известно заранее, но, к сожалению, это далеко не всегда так, и поэтому приходится всё-таки
отвечать в онлайне, то есть не знать, какие числа будут дальше, и при этом всё равно примерно за
столько отвечать на все запросы, всё равно примерно в среднем залог ку на запрос хочется отвечать.
вот и третье, давайте мы закончим тем же, что в прошлый раз, и тем с чего начали, это количество
чисел на отрезке больше равных чем x, опять есть неизменный массив статический, приходится
просто с тремя параметрами lrx, мне нужно отрезкой lr сообщить количество чисел,
которые больше равных чем x, давайте считать все запросы известны заранее, тогда давайте мы их
все отсортируем в порядке убывания x, отсортируем запросы, в порядке убывания x,
а дальше воспользуемся той же самой идеей, которая была в персистентном дереве отрезков, только
теперь мне уже не нужна будет персистентность, потому что, если я иду по запросам в порядке
убывания x, что это значит? это означает, что как бы изначально все элементы мёртвые, а дальше они
постепенно оживают, и мне нужна только текущая версия дерева, то есть вот, не знаю, там какой-нибудь
x пришёл, я оживил все элементы, которые больше равны чем x, и ответил на запрос, это просто число
живых на отрезке, потом у меня x уменьшился, пришёл запрос с меньшим x, значит мне нужно несколько
элементов оживить, и потом опять сумма на отрезке, то есть число живых на отрезке, то есть это как
будто бы персистентный дерево отрезков, только мне не нужно иметь доступ к любому дереву, у меня
вот этот вот запрос к дереву, он будет как бы сдвигаться в порядке убывания x, а мне не нужно
тыкать в разные-разные места, у меня будут просто, ну вот эти запросы к разным деревьям,
они будут такие последовательные в порядке убывания x, а то есть в порядке процессинга,
обработки всех чисел в порядке убывания. давайте напишем, что храним одно дерево отрезков,
не персистентное, обычное, одно обычное до, в каждой вершине храним число живых под деревом,
число живых под деревом, тогда если я скажем ответил на запрос там, не знаю, l,
l' x', на его мы допустим ответили, приходится следующий запрос l2' r2' x2' , где x2' меньше
чем x', я же их посортил, теперь у меня как бы приходит запрос с меньшим x, ну тогда мне
нужно просто пройтись по всем числам от x' до x2', то есть все числа, которые оживают в отрезке
между этими запросами, в промежутке между этими запросами, все их оживить и теперь делать запрос
на новом отрезке l2' r2' оживляем числа, принадлежащая отрезку от x2' до x' невключительно,
все их оживляем, то есть у меня еще отдельно ассортированы все элементы исходного массива,
так же как было у меня в персидентном подходе, я сначала ссорчиваюсь массив исходный, иду в
порядке убывания и то есть по сути я иду в как бы параллельно в порядке убывания по моему
массиву ссортит исходному, по моему массиву статической, которая в порядке убывания значений,
а также иду параллельно по запросам, в порядке убывания x' запроса, если у меня скажем вот здесь
нашелся какой-то одинаковый x, тогда у меня живые, выменьшаются все вот эти вот элементы,
соответственно тогда мне просто нужно сумма顆ить живых отрезок, потом приходится следующий запрос x,
х' x2', тогда мне нужно продвинуть вот этот указатель вниз, оживить несколько элементов и потом сделать
запрос на отрезки, и каждый раз когда у меня вот этот x все уменьшается, усиливается, мне нужно оживить
несколько элементов и сделать запрос на отрезки, и именно из-за того что у меня x вот эти вот линейно
убывают подряд, всё меньше и меньше и меньше. Это значит, что мне не нужно персистентное ДО,
мне нужна его последняя версия, нужна последняя версия, в которой всё оживают и оживают новые
элементы, мне нужна всегда только одна версия без всей истории. Нужна только одна версия ДО.
Ну вот тоже такое упрощение подхода, который был выше, про персистентное дерево отрезка. То есть,
по сути, мы отказались от персистентности, заодно, кстати, сэкономили память, потому что
персистентное ДО требовало от нас N log N памяти, потому что у нас N обновлений,
и каждое обновление алгоритм занимало. Заодно память уменьшили, заодно уменьшили память.
А время стало точно не хуже. Кула куразов, чтобы её, чтобы все запросы поспортировать.
Ну короче, всё это точно не хуже, чем онлайн подход с персистентным ДО, потому что здесь всё,
ну короче, просто более простая структура. ДО явно более простая, чем персистентный ДО.
Так, ну всё, спасибо. Если нет вопросов, то тогда до свидания, до следующего раза.
Маленький вопрос. Значит, вот мы, когда у нас приходит очередной запрос, мы оживляем элементы
от, ну, допустим, x' до x'2. А как это, собственно, в дереве это происходит? Ну, то есть, вот...
Ну, смотрите, вот сюда, сюда смотрите. Есть у меня, я изначально посортировал массив sortit.
Исходный массив отсортировал, он теперь хранится в sortit. Там все элементы в порядке убывания.
Соответственно, если у меня, если мне нужно оживить все числа от x' до x'2, я понимаю, где они.
Это вот такой отрезок, мне нужно просто вот, я понимаю, какие числа нужно оживить. Ну,
а оживление числа, это просто там, ну, плюс один в ДОшке. Я понял, но если мы все эти числа оживляем,
то у нас получается время работы вот этого запроса, оно будет там x'-x2' умножить там на налог.
Ну, да, количество чисел вот здесь умножить на алгорифм, да. Но еще раз, смотрите, если мне все
запросы известны заранее, то есть, я все равно их сначала все считаю, считываю и на все отвечаю,
да, то есть, якобы, трачу время на то, чтобы ответить на все. И вот эту всю сумму я считаю
временем работы, то есть, каждый конкретный запрос добра в этот задолб, потому что мне нужно
сначала считать все остальные. И, ну, как бы, я отвечаю на все, то есть, я считаю сумму только
на все запросы сразу. Вот поэтому, сколько трачу времени на каждый конкретный, это даже, даже
некорректно спрашивает, потому что, ну, мы сначала нужно все остальные прочитать. Так,
еще вопросы в чате. То есть, мы сохраняем ответ на каждый запрос, запросы, запросы. Да, ну, конечно,
то есть, ну, здесь нужно, там, чуть формальнее, если писать, то мне нужно для каждой тройки lrx,
еще запоминать, какой-то номер запроса был, да, то есть, мне нужно сортировать четверки lrx,
запятая i, да, там, номер запроса. И дальше я их все посортил, и когда смог ответить на какой-то
i-й запрос, мне нужно запомнить, ага, на i-й запрос такой-то ответ. Куда-то это себе записываю в массив,
да, и потом, когда я на все запросы ответил, после этого мне нужно вывести этот массив. То есть,
я сначала записал все ответы, потом в должном проекте вывел. Так, может быть, в оффлайн-подходе
другая симпатика отличная от онлайна. Ну, конечно, может. Пример сходу не назову, но вот,
вот что может быть. Точно может быть что-то в стиле, если у вас онлайн-лог-квадратный запрос,
то оффлайн, возможно, можно за логарифм. Вот. Пример, к сожалению, да, сейчас сходу не назову,
но, типа, уменьшение степени логарифма вполне бывает. Ну, все тогда спасибо за внимание,
до свидания. Запись я скину и надеюсь, что это тоже на youtube залетит.
