Сегодня у нас с вами шестая лекция, то есть мы уже прошли с вами треть семиастра, и это была
самая простая треть. Дальше будет только хуже, так что не расслабляйтесь. Окей, так,
7-12, да, так, лекция 6. И мы продолжаем изучать деревья поиска. Сегодня у нас будет два
новых дерева. Ну, если успеем, то может быть чуть третье заденем. Это будет декартовое дерево
и Б-дерево. Вот, ну давайте начнем с первого. Давайте определение. Декартовое дерево,
это бинарное дерево, бинарное подвешенное дерево. Оно будет хранить в себе пары внезапно. Вот,
мы привыкли, конечно, на сток ключей, а теперь у нас будут пары, хранящие пары x и y, где x мы
будем называть ключом, а y это приоритет. И в чем, собственно, суть этого дерева? В том,
что по x это будет дерево поиска. Дерево поиска. А по y это будет бинарная куча,
или бинарная пирамида. Русский язык достаточно богатый, а декартовое дерево как-то слишком
долго, поэтому у него есть куча разных названий, которые соединяют в себе бинарная куча, то есть
куча и дерево. Можете подумать сами названия, которых объединяют. В одно слово дерево и куча
получите разные варианты. Вот, например, дуча. Можно по-другому их слить, вот вы получите тоже
прикольное слово. Вот, по-английски его называют трип. Ну, не тот трип, который вы могли подумать,
это дерево плюс кип куча. Вот. Окей, и зачем вам все это надо? Ладно, вопрос сложный, давайте сначала
поймем вообще как это выглядит. И внезапно, почему это дерево называют декартовым,
ну и там нарисуем какие-нибудь пары. Не знаю, какие у нас будут пары. Давайте 1-3, 2-4, 3-1, 5-7 и не знаю,
что-нибудь такое, типа 4-6 какой-нибудь. Такой вот набор пар. То есть по х у нас будут ключи,
по y приоритеты. Давайте отметим их на этой карандатной плоскости, чтобы посмотреть,
как это дерево выглядит. Блин, у меня по y 7, если не влезет так много. Ну, поменяем.
О, идеально. Так, по x1, по y3 это здесь, по x2, по y4 это где-то здесь. Так, и вот так вот. То есть
вот наши вершинки дерева на декартовой плоскости. Давайте посмотрим, как ребра проведены.
Так у нас по y это внезапно куча, значит у нас в корне минимум стоит. Вот. Значит этот корень,
у него дети сюда и сюда, причем идут к минимальной y. Вот так вот, раз, два. Дальше здесь будет отсюда.
Будет вести влево-вправо, справа никого нет больше, поэтому будет только сюда вести
ребро. Ну, здесь вот такое у вас дерево получилось. Понятно, примерно? Вот, геометрически это выглядит
так. Это первое дерево, растущее вверх у программистов. У нас получилось с вами, обычно они вниз растут.
Вот. И теперь хочется понять, зачем нам это надо. Ну, замысел будет наш простой. Мы введем две
новые операции split и merge и внезапно выясним, что они очень хорошо реализуются на этих деревьях,
а потом через них выразим все остальное. Давайте операция split по дереву и ключу. То есть дерево
t ключ x, она вас ведет в t1 и t2 такие, что те ключи, ну давайте здесь поставим равенство, меньше либо равно x,
а вот t2 строго больше, чем x. То есть у вас есть два дерева, которые распилины как-то по x. Ну,
например, что-то вот такого вот. Хочу вот так вот распилить его. То есть у меня здесь вот одно будет
дерево, здесь другое будет дерево. И он будет корректным. Вот здесь вот 1, 2, 3, 4, это будет по
одном дереве, здесь в другом. Ну, давайте подумаем, как будет это выглядеть. То есть как-то вот так у нас
устроено наше дерево прекрасное. Этот корень, там его дети, и мы хотим его разбить по кому-то ключу x. Давайте подумаем,
как будут образованы деревья. Ну, допустим, давайте мы этого чувака обозначим за r, корень это будет l. Ладно,
давайте не r, какой-нибудь p, а это r, потому что правый, левый и primary, типа главный. Допустим,
p.x, давайте здесь k, чтобы у нас не было путаний с этими ключами. Вот, допустим,
что p.x окажется меньше, чем k. Ну, строго. То есть мы хотим как-то вот так вот разрезать наше
дерево. Как-то вот так вот хотим. Ну, или там будет правее проходить эта линия разреза, это не особо важно,
главное, что он справа от этого. Тогда куда пойдет узел p? В t1 или в t2? В t1. И кто будет левым под
деревом в t1? Вот это вот все дело. Поэтому говорим, что t1 root равно p. А как дальше разобраться? Как
будет устроено t2 и правый ребенок в t1? Ну, да, рекуссивно узнаем split от ребенка просто.
t1.root.right.t2 равно split от rk. То есть вы просто рекуссивно
сплит отсюда. Ну, понятное дело, что если у вас здесь другой знак, то есть больше либо равно, вы
делаете все симметрично. В тонущей студии наоборот. То есть у вас однозначно определяется вот эта вот
часть, а вот эта вот будет рассекаться на две. Итого, сколько действий мы здесь делаем? Ну да,
от 1 на каждый узел и при этом каждый вызов сплит вызывает нас на 1 вниз рекуссивно. Поэтому от h.
Правый ребенок в t1. Да, t1 t2. Вот видите, здесь t1, здесь t2. Вот, он как бы рекуссивно себя вызывает.
Ну, понятное дело, что если вы вызвались от пустого дерева, то вернее два пустых дерева. Вот база рекурсии,
так сказать. Потому что у вас вот это вот неравенство выполнено. То есть смотрите,
еще раз. Вы поймете, допустим, что вот так вот. То есть у вас линия разреза как-то так
проходит. Тогда вот у вас вот эта вот часть, вот этот кусочек и вот это вот все пойдет в t1.
Поэтому про t1 вам известно, что вот эта вот будто бы левая часть, а правая образована вот
этим вот кусочком оставшимся. И чтобы его вычинить, вам нужно разрезать r. Вот этот вот узел.
Вот. Окей, поехали. Вторая операция. Эта операция merge. Давайте я здесь напишу.
Она принимает два дерева и внезапно возвращает одно. При этом все ключи t1 меньше всех ключей
t2. То есть у вас есть два дерева. В одном, грубо говоря, одно находится строго левее другого. Вот
если у вас есть два таких дерева, вы их можете слить в одно дерево. Как это делать? Давайте посмотрим.
Типа такого. Это будет снова p, lr. Только p1 или 1r1, потому что у нас будет здесь первое дерево и второе
дерево будет. p2, l2, r2. Ну, давайте подумаем с вами, что есть у каждого дерева? Отлично, корень. Кто из этих
двух чуваков может быть корнем? Ну да, потому что у нас еще должно быть куча при этом. Допустим,
p1.y меньше, чем p2.y. Иначе будем делать симметрично. То есть допустим, вот этот
чувак должен быть корнем. p1. Что нам известно дальше? Кто может быть в левом поддереве t1?
Почему p2 может быть? У вас известно, что у вас вот такое вот соотношение на ключи?
Ну да, потому что смотрите в чем прикол. Потому что у вас вот здесь вот все ключи больше, чем все вот здесь вот. То
есть неподавна больше, чем p1. А это значит, что все они пойдут вот сюда вот. А все, кто меньше чем p1,
они все вот здесь вот находятся. Они все пойдут вот сюда вот. Вот, эта часть нам известна. То есть мы
говорим, что t-root равно p1. Теперь осталось определить правого ребенка. Кто будет правым ребенком?
Да, давайте замерзим просто. Да и все. Он уже умеет делать. Давайте замерзим вот это вот и p2. И все,
мы себя будем гарантировать. Но, понятное дело, если у вас одно из деревьев пустое передается в мерзь,
вы должны вернуть другое. Если вы пустое, верните пустое дерево. Вот база рекурсии. Равно мерзь от
чего будет? от r1 p2. Все. Ну, если симметрично у вас, то вы все делаете опять же. Вот здесь, если у вас не
равенство в другую сторону, вы делаете, что у вас вот эта вот часть известна, а вот эти вот две сливаются.
Ну, понятное дело, время работы тогда какое. Так и не разных высот у вас могут быть.
Почему максимум? Вы можете здесь на один уровень спуститься, здесь на один уровень спуститься. Да.
Ну, вроде бы все просто. Сплит и мерзь есть. Но вопрос, зачем они нам нужны, не очень понятен.
Ведь мы же хотели делать другие операции изначально. Мы хотели insert и erase.
Да, давайте выразим остальные операции через insert и erase, через сплит и мерзь.
Так, insert. Ну, принимает дерево и ключ к. Как его сделать? Предлагается следующее.
Первый шаг это сделать сплит по т к, получить т1 и т2. Ну, понятное дело, если у вас ключ к уже
будет, то там не надо его вставлять, поэтому можете вызвать find перед этим. Допустим,
ключа к нет в дереве, тогда у вас выполнено вот такое вот неравенство. Ну, я здесь немножко
некорректно, потому что у вас типа здесь множество, здесь множество, потому что я сравниваю с каким-то
имптом. Ну, поэтому иметь в виду, что все элементы множества меньше, чем ключ к, меньше, чем все другие
элементы множества. Поэтому шаг второй это сделать вот такой вот мерзь интересный.
Вроде бы все так и ускобки. То есть вы сливаете вот эти вот два дерева в одно и дальше к этому
проливаете сюда. Что такое? Что? Вот. Это оставим вопрос открытым пока что. Потому что изначально
для пользователя по-хорошему, когда вы пишете дерево поиска, он не должен вздумываться о том,
как оно внутри устроено. Он должен знать, что есть find, insert и erase. То есть генерация приоритетов
будет на вашей стороне на самом деле. Вы как-то будете по ключу генерировать приоритет,
по тому, который вам подают. Вот. А как это правильно делать, мы обсудим сами буквально через минут 5,
когда дойдем до этого. Вот. Окей, теперь давайте разберемся второй. Со вторым вариантом это erase.
Как делать erase? Давайте считать, что ключка, во-первых, там есть. Получаем T1, T2.
Так, мы определяли split, чтобы у нас ключка попадал в T1, если он есть. Окей.
Давайте подумаем с вами. Ключка, он лежит в T1. Согласны ли вы с таким вот утверждением?
Что? Ну вот оно описано. Что ключка совпадает с максимальным ключом в T1. Да. Ну вы создаете
дерево по… Ну смотрите. Разумеется, что у вас есть… Я могу говорить слово конструктор? Ну я не знаю,
вдруг вам еще не рассказали, что такое конструктор. Хорошо, вы хотите создать дерево просто по ключу K.
Разумеется, только вот это вот здесь. То есть вы создаете единственный узел и говорите,
что теперь это дерево из одного узла. Вот. То есть K – это максимальный ключ здесь. То есть у вас
вот это есть дерево. T1. Вот у вас ключ K. Какой-нибудь Y, не знаю, приоритет у него. И у него правого ребенка
быть не может. Потому что он максимальный, иначе был бы кто-то больше. Поэтому у вас есть только вот так
вот. Левое под дерево у него. Раз у него есть только левое под дерево, ну давайте мы просто возьмем и
выкинем этого чувака и вот это вот перестаем сюда. Ну как мы делали в наивном дереве поиска,
удаление узла с одним ребенком. Просто брали, вырезали и ставили ребенка на место. Поэтому шаг
второй. Делаем удаление K из T1, как в наивном дереве поиска. Вот. Так как у этого ключа будет
лишь один ребенок. Так давайте я все-таки это сотру, чтобы оно никак тут не было похоже на X
какой-нибудь. Вот. То есть у вас здесь нет ребенка, у вас только левый ребенок. Поэтому здесь все легко
будет удаляться. Причем вы даже знаете, что у вас этот узел является левым сыном. То есть вообще
все легко будет. Ну и шаг третий. Это мерч. Давайте скажем, что это переведет нас в T1 штрих,
без элемента. Дальше вы делаете мерч в T1 штрих и T2. Это конечно классно, но есть более крутой
способ сделать и рейс. Это целых три операции. Два сплита и мерч. У вас здесь один сплит, один мерч.
Да, именно так. Поэтому второй вариант реализации рейс. И все-таки мне не хватило досок.
Это смотрите. Это вот ваше прекрасное дерево. Вот вы здесь как-то дошли до пары KY. У него могут
быть дети, может не быть детей. Нам не особо это важно. Как-то вот так вот он устроен. То есть шаг
первый. Предлагается сделать find от дерева T, ключа K. Получите пару KY. Получим узел KY,
то есть что у вас есть указательный этот узел. Шаг второй. Давайте обзовем L и R его детей. Делаем
мерч от LR. Ну и шаг третий. Когда вы сделали мерч от LR, что нужно сделать? Заменить узел KY на,
давайте это C обозначим. Результат типа child. Все. То есть вы вырезаете этот узел, вот у вас
здесь какой-то родитель, там не знаю есть, и вот так вот P. И вы говорите, что ребенок P вместо
вот этого узла, это мерч от двух его детей. И заметьте, здесь у вас, если здесь у вас выполняется
одна операция за высоту. Тра-та-та, другая операция за высоту. Здесь у вас find спустился,
а мерч дальше выполняется лишь за вот эту вот часть, за вот эту вот высоту. То есть за вот эту
вот маленькую штуку на самом-то деле. Поэтому суммарно вы все делаете за одну высоту, а не за две или
там если спитить пока, пока минус один и мерч, вообще за три. То есть такой вот очень быстрый вариант.
Утверждается, есть короче теорема, которую мы доказывать не будем. Ее доказали буквально,
ну в этом году, я не вспомню когда точно. Которая говорит, что здесь вообще очень мало будет на самом
деле. Не, мы сейчас с вами скажем одну теорему, потом я скажу ее усиление для этого случая. Ну как,
я попытаюсь сформулировать, но заточенность не ручаюсь. Потому что там очень сложная теорема,
но точнее она сложно формулируется. Собственно смотрите, мы все говорим в терминах высоты,
но кто нам вдруг вообще сказал, что у нас это дерево логарифмично по высоте? Это же вообще не
очевидно. В ОВЛ было понятно, мы всегда там поддерживали разность высот маленькой, поэтому
все было хорошо. А здесь почему не может быть такого, что у нас дерево бамбуком станет?
Логично, да, но как выбрать приоритеты, чтобы при любом наборе ключей все было хорошо?
Какую серединку? Какую высоту нет? У нас нигде не хранится высота. Вот мы не хотим ничего больше
менять дерева. Вот можно случайно. Есть теорема о высоте. Вот был бы здесь, только второй курс мы
бы доказывали, но здесь есть первый курс, поэтому доказывать мы не будем в курсе. Она звучит так,
если приоритеты выбираются независимо из равномерного распределения,
распределения, чей домен по мощности превосходит размер дерева,
дерево, то мотождание, что? Я сейчас скажу все это, подождите. Мотождание высоты составит от
log n. Теперь я поясню все слова, которые здесь входят. Ну, независимо, мы с вами уже говорили вроде бы,
что имеется в виду здесь по словам независимо знать, что у вас все выборы приоритетов никак не
зависят друг от друга. То есть, например, вы каждый раз случайно подбрасываете кубик и брать приоритет
до 6. Вот это независимо равномерно оценивать, что у вас любой возможный приоритет равновероятен.
Как правило, вы их выбираете из какого-то конечного множества. Обычно это 0, 1,
не знаю, какой-нибудь там, значит, у игр большой минус 1. Вот. Это ваше множество возможных приоритетов.
Вот если вы выбираете независимо друг от друга, причем все числа с равновероятностью из этого
множества то, это значит, что независимо равномерного распределения. Что здесь домен? Домен
производит краски вот это множество. Откуда вы можете выбрать приоритеты? Все. То есть домен по
мощности превосходит, это значит, что у вас n всегда меньше либо равно, можно строго меньше, чем вот этот
у большой. Ну, понятное дело, что это заведомо выбрать нельзя, но это очевидно плюс-минус. Но
понятное дело, что можно там сделать какую-нибудь оценку, что у вас там, ну, явно дерево не будет
больше чем 10.9, допустим, по размеру. Значит, у можно взять как 2 на 10.9 и все будет хорошо.
И утверждается тогда, что в среднем высота будет от log n. Вот сейчас в последних парт тут видно,
а то он совсем умер, этот маркер под конец. Хорошо. Вот, вот так вот это надо понимать. То есть в
среднем здесь все за логрейвом будет делаться, но бывают случаи, когда эта штука действительно
похожа на бамбук. Вот. Опять же, был бы только второй курс, мы бы считали бы все эти вероятности,
когда он там станет бамбуком и так далее. Развал в контесте задача. Почитать вероятность получить
дерево высоты h на n элементах. Но, к сожалению, такого нет. Во второкурснике вас спасает первый
курс. Радуйтесь. Так. То есть у нас получается высота в среднем log n. Значит, все операции
сплит, мерч insert и рейс за log n работают. Более того, есть такое утверждение, доказанное в этом году,
что в среднем высота каждого из LR от 1 составит. На самом деле. Но это такое сильное утверждение,
которое доказывается сложным, и там куча других условий еще допомнительно накладывается. Утверждается,
что там вообще все будет быстро. Вот именно при таком случае. Не при том и рейзе на дальней доске,
а вот про это вот. Поэтому пишите вот так вот. Как там не пишите. Ну, я доказать-то не могу. Это
в среднем. Имеется в виду вероятность там берется по всем возможным приоритетам, под множеством,
по всем возможным узлам, которые будут спрашивать у вас. Узнается, что в среднем там будет маленькая
высота. Вот. Ну, если вы очень хотите, я вам скину ссылку на статью. Там по-моему страница 20.
Вот. Там типа несколько разделов. Вот это теория. Мы под номером 4.7. Так что вам нужно прочитать
много теорий до этого будет. Поэтому я не доказываю. Потому что только в этом году я доказал. Так.
В том, что если они случайны, то у вас как-то все в среднем сбалансируется. Так нет,
ты его выбрал один раз и все. Фиксировано. Для каждого узла. Вот. Есть задача интересная.
Вот смотрите в мерже, который я тут стер. Вот он тут был, да. Вот там было сравнение приоритетов,
да. Вот утверждается, что если вы замените сравнение приоритетов на подброс монетки 50 на 50,
то вроде как здесь ничего не меняется на самом деле. То есть вы можете вместо выбора
приоритетов подбрасывать монетку просто здесь, в каждом мерже. Вот. Ну, у вас мерж работает,
используя приоритет, их сравнивает. Ну в смысле, ну мы так и будем делать, в этом и суть. У нас не будет
кого-то специального алгоритма, который будет выбирать за нас. У нас будет вот подброс монетки,
это у какого-то Y грандного кубика, который будет нам выдавать чиселку и мы будем называть ее приоритетом.
Почему? А почему нет? Почему это? Куча было меньше либо равно всегда. Ну все. То есть у вас вот
такого дерева, например, куча является. Поэтому одинаковый приоритет допустимый. Вот. У вас будет
на семинарах задача про то, что если все X попарно различны и все Y попарно различны,
то существует лишь единственное дерево на таких X-Y, на таких парах. А если Y могут быть
одинаковые, то таких может быть много деревьев. Так. Ну про дикартовое дерево мы закончили говорить.
Ну там еще на семинарах до конца договорите про него, уже там не очень интересно. Сейчас нас
интересует другое. Это B дерево. Собственно, перед тем, как мы вообще поймем, зачем это нужно,
и поймем вообще, что это такое, давайте забудемся о следующем. Вот какие у вас виды памяти есть в
нашем компьютере, ноутбуке. Есть стековая, есть куча, да, оперативка так называемая. Есть еще
жесткий диск. И вот есть как бы такая проблема интересная, что оперативка, она вроде бы
быстрая, но она там не очень большая по размерам. Там несколько гигабайт, да. Допустим, даже 64 гига
у вас оперативка. Я не знаю, зачем она такая, но допустим, она у вас такая и есть. Такая как жесткий
диск, он там, ну, понятное дело, там до терабайта у вас может доходить, ну, чуть-чуть побольше.
Вообще в реальной жизни такое бывает, что ваши данные не влезают в оперативку, а влезают только
в жесткий диск. А жесткий диск, он все-таки так устроен, что это, грубо говоря, диск. Внезапно.
То есть как бы он так устроен, что у вас здесь есть какие-то вот такие блины, насаженные на общий
стержень. Есть там что-нибудь типа такой вот головки читающие по нему. И понятное дело,
что скорость чтения очень ограничена. Ограничена не в плане вашим возможностям, ограничена
физической скоростью вращения этих дисков, чтобы ваш жесткий диск не разлетался. Физики, я думаю,
понимают, что если ее очень сильно расскрутить, то может быть очень плохо. Вот. И как бы
и с оперативкой скорость этого доступа вообще несравнима. Вот, по некоторым замерам скорость
доступа к оперативке несколько раз быстрее, чем к жесткому диску. И в этом мы приходим этим
самым к идее, что нам нужно считать не только время, которое тратится в оперативке самой,
но еще и время, которое тратится, собственно, на сами доступы к диску. Потому что это очень долгие
операции. Вот. И поэтому от и бы дерева краски созданы для того, чтобы хранить данные на каких-то
вот таких вот носителях, которым, скажем так, у нас есть один большой носитель, который все
вмещает. Вот. Есть оперативка отдельная, в которой мы можем там маленький объем загрузить. Вот.
Дерево как бы реализует эту идею, чтобы нам пришлось как можно меньше лезть в сам диск. Вот. Потому
что если это обычные деревья поиска, то нам бы пришлось бы за логарифм вот этот спускаться,
и каждый этот спуск, это чтение с диска было бы. Потому что мы бы сравнивали бы с вами ключ.
То есть, помните операция Find? Она берет ключ в узле и сравнивает там что-то. Идет либо влево,
либо вправо. Проблема в том, что с точки зрения, если расписывать это подробнее, то есть вот наша
была Find от node, node, не знаю, intk какой-нибудь. Что мы с вами делали? У нас был какой-то там вот
такой вот код, что if not left меньше, чем k, то делай Find at node left k.
Иначе, делай. Иначе, если там node value. Давайте напишем самую неэффективную версию сначала.
Если это больше k, то там Find, вот там право. Иначе, там что-нибудь типа return true не знаю.
Как-нибудь это отметить. Считайте, что это псевдокод и не претендуют на корректность.
Окей, то есть смотрите, что мы с вами делали. Мы с вами должны были прочитать. Вот у нас есть
нода, она лежит в оперативке на самом деле. А node left может вообще лежать где-то на диске. Внезапно.
Потому что у нас вообще может не влезать в оперативку много чего. У нас может лезть в оперативку
нода и k. И допустим, у нас может влезть 3-4 ноды в оперативку. Все, больше ничего влезть не
может. Потому что внутри лежат вот этот вот k, это не int, не знаю какой-нибудь, а что-нибудь вообще огромное.
Какая-нибудь огромная строка или еще что-нибудь. Что вы хотите тогда? То есть,
по идее, вот здесь, когда вы берете node left, у вас здесь происходит чтение диска.
Здесь, понятно, find, он там рекурсивно почитает себя. Дальше здесь у вас происходит чтение с диска.
Во-первых, эта реализация не эффективна тем, что у вас есть целых два чтения с диска.
Можно же поменять else if node value совпало с k? Подождите, а почему здесь left и right пишу?
Господи, а мне никто не поправил. Это все полная лажа. Что-то увлекся, извините.
Конечно, здесь просто value надо сравнить. Зачем мне сравнивать значение в левом и в правом сыне?
Понял. Прошлая лекция прошла для вас зря. Ну не настолько же. Ладно, все, извините.
Все, это все обман был. Это все не нужно. Все окей. Я что-то думаю, что слишком все как-то
красиво получается, что не может быть все так плохо. Окей, в любом случае node value это все окей,
здесь нет проблемы никакой. Проблема в том, что на самом деле вот это вот и вот это в оригинале,
это будет чтение с диска. Потому что вас node будет хранить номер диска, расстояние от центра диска
до того, где этот блок лежит в памяти и угол phi от оси. Что-нибудь такое. Ну геометрически он так
будет хранить. Фактически, конечно, нет. Фактически, я не знаю, как он хранит адресацию, но физически
что-то такое вот. То есть вам нужно здесь читать диск, это как-то покрутить ваш читатель и диски
подвигать. Также здесь. Короче говоря, это долго. Поэтому надо стремиться как-то уменьшать высоту
дерева. Казалось бы, как уменьшить высоту бинарного дерева, если она у AVL так почти оптимальная. Там
типа разность высот по деревьях плюс-минус один. То есть логарифм. То есть мы сами там имеем,
что высота у всех этих деревьев, типа AVL дерева, константа c на лог 2n. Ну там c это,
ее можно вывести из этих. Ну из соотношений с числом фибоначи, которое у нас было. Я его не
хочу выводить, просто вот такая вот оценка есть. Ну или от лог n. А давайте с вами задумаемся вот о
чем. Что можно же как-то это дело оптимизировать, что ли, если хранить не два ребенка, а больше. И
тут мы приходим к идее, что можно не только бинарные деревья поиска делать, а на самом деле какие-то
там экзотические деревья. Вот. И поэтому давайте сформулируем определение B дерева наконец-то.
B дерево ранга t это такое дерево что и здесь будет несколько свойств. Существо первое это каждый
узел, кроме корня хранит хотя бы t-1 элемент. Элемент k1
k л ты какой-то, да. При этом k1 меньше, чем k2 меньше, чем k л ты. Вынутка вот соотношения. Второй пункт
узел с l детьми, с l элементами, извините, элементами. Сколько, думаете, детей он умеет?
Ну у нас же может быть хотя бы t-1, но мы же не говорим сколько конкретно, поэтому l. То есть вот у
вас раз ребенок, два ребенок, три ребенок, четыре ребенок, пять ребенок. Да, имеет l плюс одного ребенка,
при этом давайте обзовем здесь так, как бы это обозвать так, чтобы это было удобно. Так,
это k1, k l ты. Давайте это обозначим c0, c1, c l. Ну c от слова ребенок. При этом c0 точка мин,
то есть минимальный узел конкретно в этом ребенке, вот из этих вот ключей, меньше, чем k1,
ой тут max, меньше, чем c1 точка мин, меньше, чем k2, меньше, чем c2 точка max. Сейчас c0 мин меньше,
к1, c1 мин больше, чем k1, c1 max меньше, чем k2, меньше, чем c2 точка мин. То есть у вас вот здесь,
вот в этом вот ребенке все ключи меньше, чем k1, все ключи находятся между k1 и k2.
Т2 все ключи будут между k2 и k3, c l все ключи больше, чем k l будут. Третье свойство. Так,
те узлы содержат не более 2t-1 элементов, включая корень. Вот здесь вот, кроме корня,
то есть корень может хранить меньше, чем t-1 элемент, но больше он хранить не может.
И четвертый пункт, самый интересный, все листья на одной высоте. То есть вы хотите себе такое
дерево, которое вот такое вот куча свойств, и в придачу чтобы все его листья находились на одной
высоте. Кажется, немножко неизбыточным наше желание. Еще 10 секунд на то, чтобы осознать.
А мы сформулируем пока теорему о высоте. Если вы возьмете палочку и сделаете на ней l надрезов,
сколько у вас кусочков будет? Окей. А теорема о высоте утверждается,
что h меньше либо равно, чем логариф по основанию t от n плюс 1 пополам.
Давайте доказывать что ли. Как мы доказывали с вами про AVL-дерево? Мы с вами говорили,
что давайте посчитаем s от h, минимальное число вершин, которое может храниться дерево высоте h.
Минимальное число элементов деревя высоты h. То есть m у нас больше либо равно, чем s от h.
Число элементов оно больше либо равно, чем эта штука, если мы знаем высоту дерева.
Давайте теперь s от h посчитаем. Ну это значит, что у вас не может быть вот такого вот дерева.
И тем более, у вас такого дерева даже быть не может. Так вы можете хранить много ключей в одном узле.
Мы с вами это еще все нарисуем, не волнуйтесь. Пока что это просто теоретический конструкт,
которого не существует в природе. Бамбук это, конечно, сильное заявление,
давайте считаем, что у дерева хотя бы два листа, тогда все понятно. Ну типа, ладно, все пути от корня до
листьев имеют одинаковую длину. Он тоже будет один, то же самое. Ладно, не суть. Так, давайте s от h пока посчитаем.
Какое минимальное количество может храниться? Сколько может быть минимум в корне, давайте.
Один, да. Потому что корень, каждый узел кроме корня, хочет хотя бы t-1 элемент. Значит, корень может хранить один.
Давайте здесь рисовать. Здесь один. Дальше здесь, на втором уровне, сколько у него может быть детей?
Узла один, сколько детей? Два ребенка у него только. Раз и два. Сколько хранит каждый?
Почему-то по три. Сколько этот чувак может хранить? t-1. Какое 2? У вас дерева порядка t.
Еще раз.
Может быть больше. Смотрим второе свойство. Узел с l-элементами имеет l плюс одного ребенка. Узел с одним
элементом имеет 1 плюс 1 ребенков. Поэтому у него два ребенка, при этом они уже не корни. Значит,
у них хотя бы t-1 элемент. Мы считаем минимальное количество, поэтому в них должно быть ровно t-1. Согласны?
t-1, t-1. Да, в каждом. Здесь 2t минус 2. Вот на этом суммарно. Сколько у этого детей? t штук.
Здесь будет по 2t. Согласны? Потому что у вас здесь t детей и здесь t детей. 2t детей умножить на t-1.
Потому что в каждом из них по t минус 1 узлов. Этот узел t-1 элемент, этот узел t-1 элемент. Это один
узел. Но суммарно все они содержат, потому что у вас здесь 2t узлов на этом уровне, по t-1 элементов.
Короче, узел теперь это не чиселка, это вот такой вот прямоугольничек разделенный с
такими вот. И здесь тоже дети будут прямоугольнички. И так далее. Давайте третий уровень посчитаем
хорошо. Сколько детей у этого узла? Ну да, потому что в нем t-1 элемент. Ну понятно тогда, что у вас
на следующем уровне будет 4t квадрат на t минус 1. Или нет? А на самом деле здесь, тогда 2 на t минус 1.
Сейчас.
Сейчас, подать почему. Сейчас давайте подумаем. Может не 4. Действительно, сейчас давайте посмотрим.
Вот у каждого из этих узлов по t детей. Здесь t. Да, согласен. Потому что здесь из каждого
узла превращается t детей, поэтому просто на t умножаем. Итого на самом деле это 1 плюс,
то есть давайте 2 на t в нулевой, на t минус 1 2t, на t минус 1 2t квадрат, на t минус 1 и так далее.
Плюс сумма 2t в степени i на t минус 1, где i от каких пределов меняется? Сейчас, от нуля до и
дерева высоты h. Начнем с h уровней или h минус 1? Нет, важно, мы же хотим точную оценку вроде бы.
Так, сейчас. Окей, здесь у нас для третьего уровня для высоты 3 h минус 2 будет. Да, h минус 2 считаем.
Теперь надо лишь посчитать эту штуку.
Дважды t минус 1, на сумму по i от нуля до h минус 2, t в степени i.
Сейчас 1 плюс 2 на t минус 1 умножить на, сейчас будет сложно, вроде бы так.
То есть 1 плюс дважды на t степени h минус 1 минус 2. Вот что тут такое вот?
То есть n больше либо равно, чем 2t h минус 1 минус 1, t в степени h минус 1
меньше либо равно, чем, что? n плюс 1 пополам.
А, ну окей, хорошо. Здесь прикол получился в том, что я, когда описывал это утверждение,
что я считал, что в ребрах, а не в вершинах. То есть я считал, сколько ребер именно.
Поэтому давайте я здесь напишу все-таки, если высота в ребрах измеряется, а это если высота в вершинах.
Ну, понятно, что h тогда у вас. Короче, доказано, да? Согласны, что доказано?
Нет, одно и то же.
А, ну, а здесь имеет, окей, хорошо, согласен. Внутренний узел. Внутренний узел, вот они лист.
Окей, здесь право. Так, доказали высоту. Теперь давайте разбираться с тем, как с этой громоздкой
конструкции работать. Ну и первое, это как делать файнт вообще в таком дереве.
Ну, файнт здесь вроде бы легкий. Просто прикол в том, что вам придется не сравнивать не с одним
элементом, а с массивчиком элементов. Давайте я нарисую.
Что-нибудь такое. Вот такое классное дерево. Соответственно, чем оно хорошо? Да, давайте
обсудим вообще, чем оно хорошо сначала, зачем его делали. Утверждается, что вот t подбирают так,
чтобы у вас вот одна страничка, вот этот вот узел один, он целиком помещался в оперативку. Ну там,
чтобы их 2-3 помещались в оперативку, потому что нам это еще пригодится для разных операций. Вот,
и в реальности там t, они бывают разные, что-то порядка 500 выбирают. То есть, большие числа
все-таки. Ну там от 50 до 2000 где-то больше, где-то меньше, по-разному, короче. Если мы с вами
говорили, что здесь что-то порядка лог двоичный, ну двоичного логарифма, да, там логариф по основанию
t. И того, какой у вас прирост производительности? Прирост производительности, что вы берете лог
t от n делить на лог два от n, получаете что? Лог два по основанию t. То есть, вот столько раз,
примерно, у вас меньше обращения к диску идет. Ну при t равном 500, это ну сколько? Порядка 9. То
есть, в 9 раз меньше обращений к диску. Это сильно. Учитывая то, что у вас обращение к диску тысячу
раз медленнее, чем обращение к оперативке, внезапно получаете огромный буст. Собственно,
B-деревья используют для базданных всяких разных, для хранения, например. Вот. Окей, теперь как
работает Find? Он принимает все дерево t и ключ k. Он берет и сравнивает, просто берет форум.
Опять же, это псевдокод, не претендующий на работу. Сразу дисклеймер такой. Делаем следующее,
что если и меньше, чем l, строго, потому что я хочу форум. BinPoisk компонентное дело тоже можно,
но мне лень писать BinPoisk. Что? Хорош. Давайте я лучше форум напишу, а с BinPoisk на семинаре
разберетесь. Что если верно следующее, k и ты меньше, чем k, меньше, чем k и плюс 1,
то вы делаете Find от узла n, от к, от с и к. Вот, это основная часть цикла, то есть вы здесь
вот просматриваете вот этих вот чуваков. Куда-нибудь сюда еще надо вставить if k совпало с k и ты,
то делай типа return true, не знаю. Это узел, который вы смотрите, узел n. Это у нас будет k1,
k и ты, но это будет c0, c1, c и ты. Да, да, return true. То есть здесь мы посмотрели вот эти вот всех
чуваков и все возможные значения k и ты. Но племя в том, что k еще может либо здесь, либо здесь лежать,
поэтому на самом деле надо сюда еще засунуть проверки, что если k меньше чем k1, то делай
return, делай find от c0 к и сюда в конец надо вставить делай find, ну типа если ты его не
нашел, рекурсивно не вызвался. Не знаю, делай find dot c, l, t, k. Что-то такое. Опять этот код не
будет работать, потому что здесь нужно if и else понатыкать хорошим, чтобы вас эта штука не вызывалась
всегда. Вот, но схема примерно такая работает, что вы смотрите, если ваш ключ меньше чем k1,
вы рекурсивно называетесь от c0. Иначе, если вы пробегаетесь в форум по всем ключам, проверяйте,
может ли у вас где-то быть ваш товарищ, если нет, то он здесь. Окей, собственно говоря, в чем
выгода-то? Заметьте, что find хранит в едином времени только один узел и все, ему не нужны
значения детей, ему нужны только вот эти вот каиты. Поэтому достаточно один раз прочитать узел в память,
по нему в оперативке очень быстро бегать можно. Вот, это не проблема. Вот, а проблема лишь в том,
что у вас здесь как бы этот. Точнее так, тут проблемы нет, у вас как бы скачок вот этот вот,
он один делается и все хорошо. Ну скачок один раз вниз, поэтому вы делаете это от высоты. Давайте
подумать, за сколько find вообще работает. То есть, чтение из диска у вас только на самом деле. Мы
будем замерять в двух плоскостях в этот раз время, сколько чтения из диска, потому что это долгие
операции. Есть быстрая операция, работа в оперативке. Сколько действий в оперативке суммарно будет сделано?
Ну да, от t, логариф по основанию t от n. Работа в оперативке. Вот такое действие в оперативке.
Но если у вас t порядка 500, а у вас чтение из диска порядка в тысячу раз медленнее, то вы
получаете примерно равенство к краске здесь. Но там плюс-минус. Поэтому t подбирают скорее всего даже,
я думаю, имперически для каждого отдельного устройства, чтобы оно было оптимальным. Вот.
Как-то так. Работает find прекрасный. У нас время еще. Что, мы и рейс не успеем, что ли? Это грустно.
Окей, ладно. Так, тогда поехали быстро обсудим вставку. Там сколько успеем уже.
Так, insert. В чем проблема инсерта? Инсерт делается просто. Давайте считать, что элемента нет в
дереве. Можно проверить find. Но проверять мы find не будем, потому что это лишний спуск по дереву,
это куча времени. Мы будем прямо внутри инсерта проверять, правда ли, что мы нашли такой-то
элемент. Если да, то мы заканчиваем наш алгоритм. Если нет, то мы продолжаем там спускаться.
Окей, в чем проблема? Как делается инсерт? Он делается вставь в нужный лист, в нужную позицию.
Все. Есть проблемы? Какие? Какое? В смысле хотя бы t-1, но я увеличил и нет проблем. Вот проблема в том,
что у вас в узле может быть 2t-1 элементов в листе в этом. А вот нет. А вот сейчас мы скажем,
как будет делаться на самом деле. Смотрите, в чем прикол. Вот ваш прекрасный узел,
содержащий 2t-1 элементов. И вы хотите сюда всунуть еще один элемент. Он будет содержать
2t-1 элементов. Это грустная история. Если мы содержим 2t-1 элементы, почему она грустная?
Потому что так нельзя по определению. Пакты. Я не знаю, как на это ответить, если честно. Ну,
так придумано было. На самом деле, когда мы разберем инсерт и рейс, то мы поймем,
зачем это было придумано на самом деле. Опять же, пока что мы верим, что это просто теоретический
конструкт, который мы еще даже не построили с вами. Мы вообще еще ничего про него не знаем. Мы знаем
определение и знаем, что если такая штука существует, то мы умеем делать пайн в нем за столько. Но больше
мы ничего не умеем с ним делать. Мы даже создавать не умеем. Ладно, клеить сделать легко. Это инсерт
одного чувака. Это легко сделать. Но мы инсерт еще не знаем, как делать. Окей, вот я хочу ставить
сюда элемент. В чем проблема? В том, что казалось бы логичным было бы превратить его вот так вот.
Чего-то типа такого. Вот тебе твой ребенок. Минусы. Сколько пунктов определения вы нарушили,
сделав так? Во-первых, вы нарушили четвертый, потому что у вас появился новый лист, он вообще глубже
всех. Во-вторых, вы нарушили этот, потому что у вас узел содержит один элемент. Вот. При этих
вы нарушили этот, потому что это был лист и у него не было детей. Теперь у него только один ребенок.
Нарушили ли мы третий? Вроде бы нет. Вот это единственный пункт, который мы не нарушили.
Ну да, мы вот у него и нарушим второй пункт. Третий пункт мы не нарушили. Да, вот единственный пункт,
как отлично. Мы нарушили всего лишь три заповедей из четырех. Вот, Б дерево не прощается. Да,
действительно, мы сейчас задаваем деревья-то, наверное. Окей, как решается эта задача? Решается
задача операции разбиения узла на самом деле. Чем хорошо 2t-1? Это число какое? Нечетное, вау.
Поэтому давайте посмотрим более глобальную эту конструкцию. Что-нибудь такого. Вот, не так. Давайте
вот так, наоборот. Это должен быть меньше, чем нижний. Вот так вот, раз. Вот ваш родитель,
вот ваш лист, который вы хотите вставить. Вот сюда элемент куда-то. Что делается? Берется серединный
элемент и говорится, чувак, ты поднимаешься наверх. Давайте мы позначим это... Давайте я нарешу
просто дерево реальное, и мы будем наслаждаться этим. Сейчас будет верх изобразительного искусства.
Давайте я возьму t равно 2, чтобы было проще. Что? Не-не-не-не, ты издеваешь надо мной. Какое 3?
Тут уже надо 3 элемента в узле рисовать. Давайте. Т больше, правда, 2. Блин, нужно английский алфавит вспомнить.
Нет, ну дальше. G-H-E. Вот, это ваш узел, в который вы хотите... Нет, давайте J. Вот, J будет. Так,
сейчас. Теперь у меня будет родитель, который будет содержать в себе, пускай для приличия,
2 узла сначала. A, P. Вот. Тогда это... Вот это ребенок... Давайте здесь не знаю, что-нибудь типа D.
А, ну P пойдет. Здесь у него там будет ребенок какой-нибудь, не знаю, ST. Здесь ребенок AB,
что-нибудь такое. Ну давайте Z будет 3, хорошо. А, Б, С. И вот вы хотите сделать insert от E. Вставить
букву E. Казалось бы, она должна встать сюда. То есть вы должны были превратить этот узел в G-H-E-J.
Но это грустная история. Почему она грустная? Потому что у вас нарушается вторая заповедь. Нет,
сейчас скажу какая. Третья заповедь. Поэтому делается следующее. Берется и делается вот так.
Вот сюда создается новый элемент. Здесь у нас была P, да? Сюда пишется. Здесь выполняется
разбиение узла на 2. Переносится медианный элемент вверх. Медианный, то есть серединный. Вот
у вас два новых узла. Дерево корректное теперь, да? И теперь в нужный узел вставляют букву E.
То есть у вас была операция. У вас был один узел, стало два. Вы их разделили буквой H,
причем дети буквы H вот так вот располагаются. Это понятное дело. Поймем следующее, что раз у нас
было 2t-1 элементов, то когда вы выкинули один, стало 2t-2. Вы делили пополам t-1. То есть здесь
t-1 и здесь t-1 оказалось. Находите связь между 2t-1 и t-1, откуда они взялись? Вверх, вверх. Вы
создаете новый корень из одного элемента, потому что корень, видите, каждый узел кроме
корня хранит хотя бы t-1, а корень может хранить меньше. То есть если у вас, ну понятно дело,
что это операция, здесь у вас могло быть три элемента, то есть 2t-1. Нам нужно снова вверх.
Допустим, у вас здесь стало типа 2t в корне, тогда вы можете его тоже разделить и у вас как бы
появится. Вот у вас ваше дерево, допустим, оно состоит из ключей A, B, D. И вы хотите
insert A, C сделать. Вот ваш прекрасный дерево, insert A, C вы от него делаете. Что происходит? Вы
понимаете, что у него размер 2t-1. Ну t равно 2, он опять же берется. Значит, вы должны выделить
медианный элемент, новый корень B, A, D и вставляется C. Не больше 2t-1. Все, это все ограничения на корень.
То есть давайте теперь проговорим с вами итоговый алгоритм. Давайте его где-нибудь пропишем. Вот мы
вставляем в лист нужную позицию. Если лист содержит 2t-1 элементов, то выполняем разбиение
как-то разбиение работает. Первый. Берем kθ, ну это будет краски тетой элемент, медианный, и добавляем
в родителя разделяемого узла. Шаг 2. k1, kt-1, kt-1, k2, k3, k4, k5, k6, k7, k8, k9, k9, k10, k11, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12
k12, k12, k12, k12, k12, k12, k12, k12, k12, k12,
k12, k12, k12, k12, k12,
k12, k12,
к12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12,
к12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12,
к12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12,
к12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12, k12,
то есть утверждается, что когда вы разделили узел и спустили сюда рекурсивный инсер делать, его уже сам делить не будет, не надо будет.
Возможно, где-то дальше внизу вам придется делить дальше узлы, но даже если так, если вам нужно будет его ребенка какого-нибудь здесь что-нибудь поднимать наверх, один узел,
то у вас здесь будет только t узлов, но никак не 2t-1, чтобы вам не пришлось бы его еще раз заново бить. Почему? Потому что 2t-1-t больше либо равно 1, при t больше либо равным 2.
То есть вам нужно делать хотя бы еще один инсерт туда, чтобы его пришлось бы заново сплитить.
Поэтому здесь так подобраны вот эти t-1, 2t-1 и так далее, чтобы вам все можно было делать за один нисходящий проход на самом деле.
То есть примерно понятно, как делает инсерт за один проход. Потому что в любом случае, если вы находитесь в узле в каком-то, значит, что он будет либо модифицирован, либо нет.
Вот на этом пути каком-то. А если в нем 2t-1, то он, очевидно, должен быть модифицирован, потому что вы там вставите элементы какой-то.
Поэтому давайте их все разделять и все.
Окей. Тогда и рейс мы обсудим на следующей лекции.
Он раз в три сложнее, наверное.
Вот, но короче говоря, как-то так. Есть и вопрос.
