Сегодня последняя лекция по динамику, на следующей неделе у нас годной, потому что праздники, и к следующему неделю лекция по динамику.
Вот, а сегодня я буду говорить про динамику по маскам, по подножию.
Сначала договоримся, как мы можем удобно кодировать маленькие множества.
Вот такое множество, зарегиум какое-нибудь небольшое число.
Я обычно говорю, что n примерно 30.
Давайте так и оставим.
n не больше чем 30.
Я хотел бы иметь образ, иметь эффективно кодировать его под множество.
Понятно, что это всего 2,7n, включая все множество.
И как мы будем кодировать эти множества?
Ну, мы могли бы кодировать их, например, просто списком элементов.
Или как-нибудь, например, бинарной строковой динамик, которая имеет линию на тех местах, где элементы есть, и ноль их там, где нет.
Но все это очень эффективно.
Мы будем в виде чисел.
Мы запишем вот столько бинного числа в зависимости от системы числения.
Ну и будем опять-таки ставить ноль там, где числа нет, и ноль там, где числа есть.
Только еще я разверну это множество и буду писать рог матш.
Вот, например, давайте я ставлю у меня универсум.
Я его немножечко сейчас переверну.
Например, вот такой он у меня.
Это если я хочу закодировать множество, например, 4, 3 и 1,
то на этой битовой маске будет вот такая строка.
Мы ноль у нас нет, мы ставим ноль, 1 есть на 1, 2 нет, 3 и 4 есть, 4 нет.
Значит, вот эта битовая строка, если мы будем воспринимать ее как число в зависимости от системы числения,
будет наша маска, наша множество.
Соответственно, ее можно перейти в дизельную систему числения.
Что это будет? Будет 2, плюс 8, плюс 16. Ну, сколько там будет? Это 26.
Таким образом, мы, получается, любому подморостю смогли поставить битовую строчку,
а значит, просто обычное число.
И коль скоро на сцену вот такое не очень большое,
то мы можем это даже в какой-нибудь, типа, инт поместить.
Если надо, если там, например, до 60, то мы можем использовать long block.
Ну и так далее.
То есть мы, в принципе, можем какой-нибудь стандартных данных использовать для хранения множества.
Вот. И это чтобы подниматься маской нашего множества A.
Маска A.
Вот.
Таким образом, мы научились довольно компактно,
используя всего одну, по сути, переменную хранить разовольное подморство заранее фиксированного множества.
Да, еще раз повторюсь, что мы записываем биты, как бы, вот наших Сашин.
То есть с правой, с правой с конца отвечает мю,
с второй с конца единица, с третьей с конца двойки, и так далее.
Вот. Ну и раз мы договорились с этим кодированием,
то давайте научимся еще что-нибудь с ними делать.
Да, например, давайте научимся этим множествам как-нибудь пересекать, обеднять, и так далее.
Ну вот представьте себе, у меня были два множества заданные какими-нибудь масками.
Ну давайте я назову вот эту маску A, эту маску B.
Как их объединить?
Что происходит с этими масками, что происходит с этими строчками,
когда я пытаюсь объединить два множества?
Ну не всем складывается, они скорее логично или берется у них.
Потому что в тех позициях, на тех разрядах, где есть хотя бы одна единичка в A или в B,
то есть есть элемент в объединении, значит мы должны здесь тоже поставить единичку.
А если здесь и здесь контр разрядик были нули, значит и в объединении нет этого элемента,
значит и в логическом или их небудь.
То есть получается логическая или действует вроде так, как объединение маски.
Как объединение множества, окей?
Просто по разряну, по битвам мы смотрим, какой элемент есть тут, какой элемент есть тут,
и понимаем, что объединение, это в точности дизинкси, да? В точности логической или.
Вот, ну аналогично, значит, давайте я вот так вот написать.
Пересечение это канюкция, побитывая i, потому что чтобы
какой-то разряд, какой-то элемент был в пересечении,
не нужно чтобы он был там и там, а это соответственно
в точности отражается в логической операции i.
Так, что еще?
Ну, симметрическая разность бывает полезна довольно часто.
Это ксор.
Симметрическая разность, давайте я Кругейлера нависую.
Симметрическая разность это все, что лежит ровно в одном из двух нольцев.
Вот так выглядит.
То есть это объединение без пересечения, можно так сказать.
Ну и ксор делает ровно вот это.
Что такое ксор, да?
В конкретном разряде в ксоре у меня единичка получается
когда и только тогда, когда ровно один из двух предыдущих битиков был единичкой.
То есть я смотрю на этот разряд, чтобы в этом разряде у ксора была единица,
либо чтобы здесь была единица, а здесь нет, либо наоборот.
Ну это вот сочность тошной картины.
Тогда либо я попадаю сюда, либо сюда.
Ну не сюда и не сюда. То есть не в пересечении и не во внешности.
Окей?
Так, разность.
А тут есть миллион способов, дайте какой-нибудь предложительный и его задержишь.
Да, вот то, что я первое понял, давайте я его напишу.
Так, сори, только маленькие буквы я не напишу.
Да, я сначала возьму, дизинуюсь, а потом выступаю.
Так это годится.
То есть вот эта вот штука, это я сначала взял все объединение, включая пересечение.
И потом с помощью ксора я вычел B.
И осталась у меня только вот эта вот часть A без B.
Вот.
Так работает.
Значит, почему без этого не работал?
Если вопрос написал A ксор B, ну мы знаем, что это уже симметрическая разность.
Значит, мне нужно, чтобы вот этот ксор работал именно как исключение.
Чтобы он работал как исключение, нужно сначала B насильно туда вставить.
Я сначала B как бы добавляю A и потом его высекаю через ксор.
Например, так.
Так.
Ну, еще давайте...
Все, операция, наверное, хватит.
Еще полезный проверка того, что одно множество, это подношение другого.
Есть две маски, как проверить, что одна это подношение другого?
Пересечение.
Пересечение?
Нет, подношение.
Сначала берем первые две маски и потом сравним, равна ли она с той, которая была.
А что пересечение равно A?
Да, пересечение равно A.
Про или я тоже не понял.
У нас есть первая маска, есть вторая маска.
Ага.
Мы берем...
Обычные или?
Обычные или.
Получится вторая.
Она...
А.
Если одна вторая, то...
Да-да-да-да-да-да.
Логично, действительно.
Ну, давайте я тоже первый, который понял, напишу.
Значит, загодется такая проверка.
Конъюнция равна верминку.
Да, потому что что такое вот это?
Мы знаем, что это сочности пересечения.
Если это верно, то есть если пересечение равно A, то получается это множество A входит как подношение и сюда и сюда.
Значит, A это подношение B.
И наоборот, если A это подношение B, ну, собственно, короче, в обратную сторону тривиальный рассуждение.
То есть это может быть верно.
Ну, в общем, ант двух массок равен 1 из них, если только если вот эта вот одна из них вложена во вторую.
Потому что это тривиальный рассуждение.
Вот.
Но такой нам лучше не нужен.
Окей?
Так, ну, хорошо.
Вроде операция нам хватит.
Ну, давайте дальше повторим.
Дан граф.
Пусть он опять-таки задан материзмежности.
Задан он еще.
Материзмежности.
Надо найти в нем наиболее что по размеру клику.
Значит, клика – это набор вершин, которые попарно соединены между собой ребрами.
Вот, например, клика на четырех вершинах.
Значит, четыре точки, все попарно между собой соединены.
Если хотя бы одного из ребр нет, то это уже не клика.
Нужно, чтобы вот прям все, все ребра были между ними.
То есть есть некий граф.
Давайте скажем, на N, N, N, N, N.
Есть материзмежности, то есть таблица N на N,
которая говорит, соединены соответствующей вершинкой или нет ребром.
Ну и вот мне нужно найти как можно больше вершин,
так чтобы они попарно были соединены,
то есть чтобы в материзмежности, в соответствующей вершине были единички.
Понятны условия?
Да.
Ну, вот.
Ну, вот.
Ну, вот.
Ну, вот.
Ну, вот.
Ну, вот.
Понятны условия?
Хорошо.
Значит, ну давайте сначала что-нибудь совсем простое.
Я обычно здесь в три шага решение рассказываю.
Ну, давайте попробуем проследовать.
Значит, первое решение просто перебор.
Полный перебор.
За сколько он работает?
Ну, смотрите, подмножество всего два в степени N,
и каждое подмножество на корректность можно проверить за квадратичное время,
потому что если у нас здесь, скажем, K вершин,
которые я хочу проверить на кликовость,
то мне нужно за K квадрат перебрать все пары
и проверить, что там есть ребро.
Поэтому получается решение за два ВН, это N пара.
То есть мы сначала перебиваем маску.
Перебираем подмножество.
И потом за квадрат проверяем, что в этом маске является клик или нет.
Проверка подмножества на кликовости.
Так.
Ну, для этого вот, в частности, например, нужна будет следующая процедурка.
Давайте я тоже выпишу.
Здесь вот, пожалуйста, будет.
Процедура извлечения бита.
Это, собственно, способ узнать, что вот здесь стоит на каком-то конкретном месте.
Вот здесь маска.
Я хочу узнать, какой у нее там бит, скажем, итый.
То есть какой бит находится на итом с конца места.
Ничто или нет.
Процедура.
Я ее так буду обозначать.
Бит.
Как извлечение бита.
Где и далее маску.
Ну и позицию.
Нужно узнать, что стоит на постом месте нашей маски маска.
Так.
Так.
Вот это все знают, что такое больше-больше?
Ага.
Значит, почему это работает?
Вот у меня была маска.
Я хочу узнать, что здесь находится на посте справа позиции.
Вот на пост.
Тогда я сначала сдвигаю ее вправо битого на пост.
На пост бить вправо.
Что это значит?
Это по факту значит, что я вот здесь вот ее обрезаю.
Все, что было левее, за нуляю.
Да, и вот получается моя маска.
Поэтому ее последним битом теперь станет тот, кто раньше был постом.
Тот, кто раньше был постом, теперь последний.
Ну и чтобы его извлечь, нужно просто поандить соединичкой, собственно.
Тогда, если последний бит был единичкой, то у меня в ане будет один.
Если последний бит был ноль, то ан будет ноль.
Поэтому логическое значение вот этого числа это в точности значение нужном не битом.
Согласны?
Вот.
Можно делать наоборот.
Можно андить маску с два в степени поз.
То есть оставить маску так, как бы было, посчитать число.
Вот это вот здесь единичка, а здесь ноль.
То есть один нынче-нынче поз.
И поандить.
Тоже работает с такой реализацией.
Но там, когда ан будет не совсем ноль или один, а будет ноль или два в степени поз.
Два в степени поз костуется к true, конечно.
Но...
Ну, короче, тогда надо понимать, что у вас там возвращается...
Вот в этой вот штуке, на самом деле, как бы не было возвращается, а integer.
И оно костуется к true, и вот как бы у вас либо ноль, либо два в степени поз.
Поэтому, если вы пишите по-другому, то тоже как бы понимаете, как оно работает.
То есть если вы сначала единичку сбегаете вправо, и потом андите маску и вот этот вот два в степени поз,
тогда он как бы считает два в степени поз, а не единичку.
Ну вот, значит, давайте здесь какой-нибудь другой код напишу.
Перебор массы, понятно, от нуля до два в степени n-1.
Дальше давайте сначала скажу, что эта масса хорошая, от равно true.
Потом по всем биткам проходимся и от нуля до n-1.
Уже от нуля до n-1.
Если оба эти бита включены в маску, то между ними должно быть ребро.
Ну давайте я здесь даже сделаю не от нуля, а от i-1.
Вот.
Значит, соответственно, если это неверно, то есть если оба бита есть на выясненном реброне, то маска плохая.
Если бит маск i, и бит маск j, и неверно, что между ними есть ребро, то есть матрица смежности нет или брается и в j,
ну, напишу так, м и т же т равно 0.
Да, тогда вот равно 0.
Ну вроде все, тогда получается на каждой маске мы, по завершению вот этого цикла, знаем корректина на линии.
Является на клипе линии.
Да?
Вот.
А как вы считаете, что есть, например, как узнать, какого размера эта маска, то есть сколько там вершин она содержит?
То есть мы сейчас знаем, для каждой маски, вот после этого фора, там ток либо true, либо false, корректная она или некорректная клика.
Как узнать размер, то есть как узнать, сколько вершин в ней находится?
Да, например, так, можно еще один цикл по всем битам запустить, просумирую, сколько раз оно вышло в единичку, да, я думаю, в сущности размер.
Вот.
Либо же можно воспользоваться встроенной функцией в плюсах, по крайней мере, если вот такая вот, built into count.
Вот.
Эта функция, которая вам за единицу разрешает количество бит в маске.
Соответственно, вместо того, чтобы писать еще один цикл, можно вызвать встроенную функцию, которая вам размер маски вернет.
То есть давайте напишем, что это возвращает количество единиц в маску.
Вот.
Ну и соответственно, нужно вывести маску, которая является кликой, то есть которая, ок, равно true, и вот это значение максимально возможно.
Так.
Решение второе.
Будет за, я в ступене nine.
Смотрите.
Давайте мы, вот эти значения, оке, давайте будем вспоминать.
Давайте для каждой маски, для которой мы уже нашли ответ, сохраним в какой-нибудь DP-шку.
Пусть DP вот маска.
Ну и соответственно, true или false, является ли маской или кликой.
True.
Если маска, то клика.
False и nine.
True.
Если маска, то клика.
False и nine.
False и nine.
Будем эту пэшу насчитывать.
Если мы ее всю насчитаем, то опять-таки мы для каждой маски знаем, является ли она кликой или нет.
И с клик нужно выбрать самую большую, потом поразумерить, с помощью built-in попкана, например.
Значит, как это делать?
Как это делать? Смотрите.
Вот если есть какое-то множество маск, как проверить, что он является кликой?
Например, можно сделать следующее.
Давайте мы из этого множества вытащим одну произвольную вышивку.
Откусим В из множества.
Соответственно, тогда мне нужно, чтобы вот это все было кликой.
То есть маска без В была кликой.
А еще В была бы соединена со всеми вот этими вот вышивками.
Вот вам решение.
То есть мы сначала находим произвольную вышивку В, отбрасываем ее из маски, проверяем, что маска без В это клика.
А потом за линию проверяем, что В соединена со всеми вышивками из маски.
Значит, пусть В произвольная линия в маске.
Давайте я пока напишу так вот, как неудобно.
А маска без В является кликой.
То есть эта штука равна трубе.
И В соединена со всеми вершинами из множества маски без В.
То тогда маска это клика.
Ну вот, собственно, необходимая достаточная условия.
Мы можем любую вершину откручивать, проверить, что остаток это клика.
И отборщенную вершину со всеми предыдущими соединяем.
Ну, собственно, вроде бы все.
Если у меня фиксирована какая-то маска, я сначала за линию нахожу в ней какой-нибудь бит, включенный произвольно.
То есть я делаю цикл по всем позициям.
Узнаю, какой бит у меня включен.
Пусть кажется, это какой-то В.
Проверяю, обязательно у меня должна быть маска без В.
Это должна быть клика.
И В еще одним циклом.
Я проверяю, что В соединена со всеми вот этими товарищами.
Это еще один нынешний цикл.
Итого, если точка будет ровно З.
Окей?
Хорошо.
Так, а как мы, кстати, вот это вот в коде реализуем?
Вычитание элемента.
Сор.
Сор с чем?
Как его построить?
Да, да, да, все правильно.
Эту штуку можно писать так.
Маск, сор, один меньше В.
Так, потому что один меньше на HV.
Это как раз вы написали 2-ичное число.
В смысле, число в зависимости от единицы.
Потом ее бинарно 2-ичное сдвинули налево на В шаговку.
У вас получается единичка, за ней вынулись.
То есть представьте, у вас был вход число 1.
Вы взяли его сдвинули на В влево.
Причем все позиции, которые появились, вы заполнили 0.
То есть когда вы двигаетесь на В влево, у вас единичка получается как раз в этом разряде.
А справа все остаются умеряя.
Поэтому эта штука это в точности вот эта вношность лежащая только в В.
Но если вы это не исключите, то можете делать XOR.
Можно с вами просто минус написать.
Потому что если мы знаем, что в маске так это В находится, то вычитание сейчас работает точно так же, как XOR.
Поэтому можно XOR, можно минус. Не особо важно.
XOR, наверное, побыстрее, но минус, скорее всего, так дооптимизирован в этом случае до XOR.
Поэтому не важно.
Так.
Хорошо.
Значит, теперь смотрите, чтобы получить решение за просто 2 ступени m.
И нужно учиться вот эти два шага находить за под единицей.
Во-первых, проверять, находить, точнее, какой это перед из маски.
Во-вторых, делать вот эту проверку.
В соединяет со всеми вершинами с кого-то множеством.
За единицей.
Давайте оба эти шага сделаем.
Во-первых, как находить какой-то бит.
Как находить какой-то бит.
Вот здесь, повторюсь, нам не важно, какой была В.
В была произвольной вершинкой, я мог брать ее какой угодно.
Вот. Обычно, очень часто, очень удобно использовать старший бит.
Усть твой это старший бит.
То есть вершина с наибольшим номером, который мы имеем в нашем множестве масок.
Тогда, как меняется старший бит у числа, если я буду перебирать наши маски именно вот в таком порядке, в порядок увеличения.
От 0 до маски всех верениц.
Ну понятно, там, типа, сначала старший бит это единичка, потом двойка, потом тройка, потом четверка и так далее.
Причем меняется она только на степнях двойки.
Потому что, например, у вот такого числа, да, у вот такого числа, старший бит это двойка, а второй с конца бит в ноль дексации.
Потом у вас эта двойка будет кучу раз старшим битом.
Вот. А потом, очередной раз, когда у вас меняется старший бит, вы переходите через следы двойки.
У вас старший бит сдвигается влево на единичку.
Поэтому, если мы просто перебираем маски в порядок увеличения, то мне нужно увеличить старший бит на единицу каждый раз, когда мы перевалились за степень двойки.
То есть, точнее, каждый раз, когда мы стали следами двойки.
Вот.
Значит, это можно сделать так.
Потому что мы храним полдист.
Как раз таки старший бит.
Ну, для нулевой маски какие-то проблемы, наверное, со старшим битом.
Там вообще не исключенных бит, поэтому мы нулевую маску.
Для нулевой маски мы старший бит не определяем.
А вот для тех, кто остается, спокойно можно.
Значит, для всех масок к единичке до 2 степени минус 1.
Если маска до степени двойки, то надо сделать плюс-плюс олдист.
Тогда, как раз, олдист будет всегда текущим старшим битом.
Вот.
А как проверять то, что маска является степенью двойки, мы уже когда-то делали.
Когда Спарстейл писали.
Но давайте я здесь какое условие как бы.
Я пишу словарно.
Если маска до степени двойки.
Если мы пришли к еще одной степени двойки, она сделает плюс-плюс олдист.
Да, тогда, например, для маски равной единицы, единицы до степени двойки.
Мы получим олдист равно 0.
То есть как раз у единицы старший бит это 0.
Ну, то есть самый левый культурный бит это 0.
Дальше для маски равной двойки мы еще раз увеличиваем.
Будет 1, 4, 8 и так далее.
Каждый раз олдист будет увеличиваться.
Вот.
Ну, можно по-разному это сделать.
Я пишу вот так.
Степень двойки это в точности те случаи, когда при конъюнкции с предыдущим числом у вас получается 0.
А потому что маска это получается 1, 0, 0, 0, 0, 0.
А маска минус 1 это 0, 1, 1, 1, 1, 1.
Тогда понятно, что это конъюнкция нулевая.
Вот.
А если бы у вас была не степень двойки, то у вас тогда хотя бы одна единичка вот здесь вот сохранилась бы при переходе к маске минус 1.
И у вас там был бы какой-то не нулевой, ну в смысле, да, не нулевой бит.
Вот.
Вроде все.
Теперь мы олдист знаем, собственно, для всех масок за единичку.
Для каждой маски я посоветую вычитать олдист за единичку.
Окей?
Так.
Ну и второй шаг.
Мне нужно проверить, что вот этот олдист конкретный, да, соединен со всеми словами множества.
Ну как это сделать, ваше предложение?
Кого?
Детей.
Ну соседней скорее.
Ну да.
Действительно, да, давайте мы просто заведем какой-нибудь массив.
Давайте его назовем neighbor.
Для каждой вершины.
Это маска соседей вершины В.
Маска соседей вершины В.
Ну мы знаем, что соседей вершины В это какое-то множество, да, вот с кем вводится имя.
Ну с какими-нибудь вершинами, да, это конкретное множество.
Ну давайте это множество представим в виде маски.
Уже умеем множество маскам задавать.
Вот зададим.
Так сделан для каждой вершины.
Тогда, чтобы проверить, что вот эта вот наша область соединена со всеми из кого-то множества,
мне нужно просто проверить, что вот то множество, да, маска без областа,
маска без областа, в этом В я пишу,
должно быть вложено в множество соседей вершины.
Это как раз пример того, что В с ними со всеми соединена.
Соответственно, если я этот массив neighbor посчитаю на всех вершин,
то я могу за единицу проверять,
что В с ними со всеми соединена.
Мы уже вот здесь вот недавно было
в проверке того, что одно множество в одно что другое,
можно сделать за единицу, там какой-то AND, XOR, короче, да,
проверка на равность вам.
В общем, как-то за единицу мы это научились делать уже.
Ну вот здесь вот и есть пути.
Вот.
В общем, как-то за единицу мы это научились делать уже.
Ну вот здесь вот и есть пути.
Вот.
Ну а neighbor посчитать будешь просто,
надо просто пройтись по всем ребрам графа,
если у В какое-то,
то мне нужно в neighbor от В добавить вершинку У,
а в neighbor от У добавить вершинку В.
Это просто, ну там, включение какого-то битика.
Вот.
Все, получили за два степени, два степени на решение.
Окей?
Так.
Так.
Ну и теперь, собственно, кульминация,
это решение за два степени наполам.
Так, это будет сантимальное решение,
за два степени наполам.
Вот.
Если предыдущие решения работали
за адекватное время, там,
для n порядка 20-30,
то это вполне себе нормально работает
для n порядка 50-60.
То есть, если мы в два раза сократили показатель,
то за то же время
мы работаем для входа
в порядок двух ручек.
Итак.
Как будем действовать?
Давайте мы наш граф
довольно случайно,
ну, точнее, довольно произвольно
поделим на две равные части.
l и r.
Скажем, что в l будут лежать вершины с номерами
от 0 до n пополам,
минус 1.
В r, вот n пополам,
до n минус 1.
Ну, короче,
первую половинку влево,
а вторую половинку в правой.
Тогда шутку любая клика.
Как выглядит произвольная клика?
Ну, она немножко вершин вот отсюда содержит,
и немножко вот отсюда.
В общем случае.
Она как-то содержится и там, и там.
При этом, что мне нужно?
Мне нужно, чтобы вот этот кусочек был кликой
сам по себе.
Вот этот кусочек был кликой сам по себе.
И они попарно между собой,
между долями были тоже соединены
попарно лево.
То есть, внутри условия,
которые необходимы и достаточно,
для того, чтобы это было кликой.
Еще раз.
Во-первых, в сужении на левую долю клика,
во-вторых, в сужении на правую долю клика,
и в-третьих,
попарные ребра между сужением на левую долю
и на правую долю все есть.
То есть, есть все ребра слева направо.
Вот.
Ну, будем это делать.
Так.
Ну, смотрите, я сделаю следующее.
Давайте я веду новую нумерацию
на наших обеих долях.
Раньше исходная нумерация была вот такая.
Теперь давайте я пронумеру ее и слева
все вершины от нуля до этого пополам.
И справа тоже все от нуля до этого пополам.
То есть, теперь формально каждая вершина,
она задается не только номером, но и своей долей.
Где она лежит, то и номер в этой доле.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
И у нас будет такое номер в этой доле.
И мы их не будем путать, потому что
нули здесь и нули здесь находятся в разных долях.
Но я для удобства нумеровал динамик.
Для удобства представления дальнейшего.
Значит, нам нужно будет несколько динамиков.
Во-первых, для всех подмножеств левой доли
я хочу проверить является ли данная ноздка клипой.
Давайте я это назову, скажем, ДПЛ.
ДПЛ. Вот маски.
Это случай, когда маск – это какие-то вершины в левой доле.
И я просто хочу узнать, трогалифолс является ли это множество клика или нет.
Значит, маск – это какое-то множество левой доли.
Вопрос является ли клика.
Ну, благо, вот только что мы научились за 2х размер графа проверять все его подножства на кликовость.
Поэтому этот шаг мы можем сделать спокойно за 2,5.
Давайте сделаем то же самое для правой доли.
Теперь маск – это какое подножство правой доли.
Ну, как вы знаете, является ли оно кликой.
Тоже самое, да, является ли оно кликой.
И работает тоже за 2,5.
Так, и третья.
Самая интеллектуальная динамика будет следующая.
Маск – это множество вершин правой доли.
А значение динамики равно наибольшему размеру под клики, которая целиком вложена в маску.
ДП – это размер наибольшей клики, которая лежала бы внутри маска.
То есть, вот здесь какое-то множество справа, вот здесь маска.
Маска самой по себе, возможно, кликой не является, но там может быть довольно большая клика.
Вот, например, вот это вот все, это клика.
То есть несколько вершин надо удалить, чтобы получилась клика.
И вот я хочу для каждой маски знать, какой будет наибольший размер клики, вложенный в эту маску.
Окей?
Тогда, смотрите, вот если у меня все это есть, как я буду действовать?
Сейчас нарисую.
Как я буду действовать?
Я перебираю множество вершин в левой доле, которые образуют клику.
Давайте это будет у меня А.
Я перебираю клику в левой доле.
Дальше.
Я знаю, это довольно просто сделать, я, в принципе, знаю множество вершин, которые были бы соединены со всеми вершинами из А.
То есть, есть такие вершины, которые соединены со всеми вершинами множества А.
Вот такой вот полный граф у нас получается.
Полный двудольный граф.
Вот это для меня, конечно, маска.
Если я знаю эту маску, то в дополнение к А, чтобы получить клику, мне нужно как раз взять ДП от маски.
То есть, еще раз, если А это клика, давайте подпишем, что А это клика,
Маск это множество всех вершин правой доли, которые соединены со всеми вершинами из А.
Множество вершин Р, соединенных со всеми из А.
То есть, это все потенциальные кандидаты на добавление в клику.
Итого, если мы возьмем А и что угодно из маски, то мы выполним уже два условия из трех.
Мы выполним, что А это клика, и что есть ребра между долями или Р.
Осталось делать так, чтобы вот здесь была еще клика.
Но из всех возможных под кликой этого множества, мне нужно наибольших понятных делать.
Потому что уже я выполнил свое выполнение, осталось одно.
Мне осталось, чтобы здесь выбралось клика.
А это идет за помощью ДП.
И вот если я научусь находить наибольшую под клику в данном множестве,
то объединение А и, собственно, это наибольшее под клики, это один из потенциальных эффектов.
Дальше я просто перебираю все вот эти возможные А,
нахожу размер вот этого ДП от маски,
и это, как бы, одна из ровнорных кликов.
Ты жив?
Вопрос я еще раз письменно запишу, что я здесь делал.
Повторю.
Что такое клика?
Да, любая клика в нашем графе развивается на два кусочка, левая и правая.
То есть, ее стужение на левую долю и на правую долю.
Клика характеризуется тремя свойствами.
Во-первых, слева клика.
То есть, вот это множество самого бы себе клика.
Для него вернули ДПР или ОТС.
Второе условие.
Все, что справа, это клика.
ДПР, вот эта маска, должна быть труп.
И третье условие.
Есть все попавшие ребра между вершиной слева и справа.
Как будет работать наш алдейфинг?
Во-первых, перебираем А под множество левой доли, которая является кликой.
Тем самым, первую сходу можно выполнить.
Слева клика.
Второе.
Каким-то образом мы находим маск.
Это множество всех вершин правой доли, которые соединись со всеми вершинами из А.
Вот я так пока что не учу.
Как-то находим маск из ДР.
Это множество всех вершин.
Это множество всех вершин.
Соединенных со всеми из А.
Тем самым, я уже удовлетворил третье условие.
Есть все ребра попавшие слева направо.
Просто по определению, маск содержит те и только те вершины, которые сведены со всеми из А.
Третье условие уже есть.
И последнее, что осталось сделать, это в этой маске эту маску превратить в клику.
Но поскольку она сама по себе, возможно, кликой не была,
мне нужно в ней выбрать наибольшую под клику.
А это в точности ДП.
Вот это все доступные вершины, но мне в них нужно выбрать под клику.
А это в неизвестности ДП.
Мне нужно из данного множества выбрать наибольшую под множество вершин клики.
Это ДП просто.
Наибольшая клика это А в объедении ДП от маски.
То есть А вот отсюда и ДП от маски вот отсюда.
Что осталось нам сделать?
Это каким-то образом научиться находить эту маску.
Но что всех соседей всех лишен из А.
И, видимо, ДП вот на одном числе находиться.
Давайте пойду с конца, как насчитывать ДП.
Ну, смотрите, вот есть некое множество маски.
Я хочу в ней найти наибольшую под клику.
Наибольшая подножие является кликой.
Значит, понятно, что если маска сама по себе клика, то делать нечего.
Наибольшая под клика это она сама.
В первый случай, если ДП от маски, то ДП от маски это, собственно,
давайте на шоу, built-in pop count от маски.
Я хочу хранить размер, поэтому с ДП я буду хранить прям размер.
Вот ДП от маски это просто-напросто количество бит нашей маски.
Потому что это уже клик.
Дальше. Пусть это не так.
Маска сама по себе это не клика.
Давайте опять посмотрим какую-то произвольную режим из нашей маски.
Мы знаем, что произвольная это обычно старший бит.
Вот давайте рассмотрим старший бит oldest.
И давайте спросим себя, а входит ли этот старший бит в нашу маску, в нашу лучшую клику?
Входит ли oldest в наибольшую клику?
Но если не входит, то можно просто смело откусить
и найти ответ для ДП маски без oldest.
Второй случай.
Если oldest не входит в наибольшую подклику, а в наибольшую подклику, то.
Значит он в принципе не участвует в этой клике.
Его можно выкинуть.
И находить наибольшую подклику маски уже поменьше.
Маски без oldest, если мы будем перебирать маски в порядке возрастания,
то ДП вот в маске без oldest будет нашим ответом.
ДП вот в маске.
ДП вот в маске без oldest.
Согласны?
Ну и последний случай, когда oldest входит в нашу подклику.
Oldest входит в подклику.
Значит мы можем брать только вершины,
которые являются соседними вершинками в oldest.
Только вот эти вот вершины.
Значит есть вот эти хорошие, есть все остальные плохие,
которые точно брать нельзя, потому что если я взял oldest,
то соответственно не соседей oldest брать нельзя.
Ну и поэтому вот отсюда из всех соседей мы должны выбрать
теперь опять-таки наибольшую подклику.
Если я обещаю себе, что я oldest в нашу клику взял,
то мне необходимо и достаточно взять клику вот в этом подмножке вершин всех соседей.
Потому что ну всех других брать точно нельзя.
А если я здесь возьму любую подклику,
то oldest можно будет спокойно к ней добавить.
Поэтому я напишу так.
Если oldest входит в наибольшую подклику,
тогда оно будет выполнить что-то в стиле следующего.
Такой вот маски это единица за счет собственно oldest'а
плюс db.
Мне нужно маску сузить на множество соседей вершины oldest.
Это что такое?
Это пересечение маски и всех соседей вершины oldest.
Вот и все.
Еще раз картинка, вот последний случай.
Есть все множество маски.
Есть вершина, которая я предполагаю обязательно лежит в нашей подклике.
Вот она oldest.
Она точно в нашей клике лежит.
Если не лежит, в же случае разоба.
Если она лежит, то в дополнение к ней я могу брать только ее соседей.
Вот если я всех соседей нарисую, вот они все.
Я могу брать только вот эти вот вершины.
Но более того, из них я могу брать кого угодно.
В дополнение к oldest я могу брать что угодно,
будь оно кликой, oldest можно к ним спокойно брать.
Потому что она и так совсем не несоединена.
Поэтому теперь мне нужно в этом множестве
маск пересеченная с ней брат oldest
найти наибольшую подклику
и добавить и расширить ее единичкой за счет oldest.
Ну вот форму, пожалуйста.
Все, мы начитали db за 20 минут пополам.
Потому что у меня
у нас есть вот такая форма.
Ну то есть как? Я сначала делаю проверку
является ли она кликой.
Если является, то собственно вот это вот верное
больше делать ничего не надо.
А если не является, то у меня oldest уже известен.
Мы oldest для всех масок посчитали
за линейное время от их количества.
И дальше просто выбираю, да,
наибольшие значения кладу его в dp от маска.
Все это считается спокойно за единицу.
Здесь там обращение к dp,
здесь обращение к ней, обращение к dp,
плюс один, это все за единицу работает.
Ну суммарно все вот это dp
насчитывается за 20 минут пополам.
Вопросики?
Нет вопросиков.
Так.
Последний шаг.
Это вот это вот.
Помножившим левой долей,
найти, умножившим правой долей,
которая связана со всеми слева.
Значит как находится маска?
Ну как вы можете сделать n
с делами ракселя?
Ну да, но только перерятки
не можно, потому что будет еще
умножитель на n.
Если мы все переберем.
Вот, а так можно просто dp
еще один.
Да, то есть если мы знаем
Если мы знаем AND всех, кроме одной, тогда еще AND не вновь последний, и получается результат, да, собственно, да.
Вот, значит, нам нужна мне еще одна деклажина.
Так, ну, буквы кончились, давайте на другу как-нибудь G, что ли.
G вот A.
Собственно, собственно, вот этот вот маск.
Значит, как ее находить? Если у меня есть...
Давайте опять картинку больше нарисую.
Вот если есть большое множество A слева,
что такое, как правильно заметили?
Что такое все соседи всех вершин из A?
Это на самом деле конъюнкция, то есть пересечение всех множеств соседей вершин вот отсюда.
То есть, если я знаю множество соседей вот этой вершинки, множество соседей этой вершинки, вот этой и так далее,
то мне посуднее вопрос, всех множеств пересечь?
Если я знаю, с кем соседствуют все вершины из А в правой доле, то мне нужно просто все эти множества пересечь, потому что это множество соседей первой вершины, это множество соседей второй вершины, это третьей, и так далее.
Вершины соседей со всеми ними – это пересечение этих множеств.
Поэтому мне нужно взять множество соседей всех этих вершин пересечь их, и это будет с точностью нашу желудку А. Множество всех вершин соединено совсем из А.
Поскольку я не хочу делать перебор бита из А, давайте я какой-нибудь бит исключу, буду знать пересечение вот этих вот всех множеств, то есть всех кроме одного, потом пересеку его с последним, и будет у меня желудка.
Сейчас мы будем писать вот так. Желудка – это желудка без олдеста пересечь, ну собственно, с множеством соседей олдеста в правой доле.
Давайте я его паркну еще по особенному зву, давайте я его назову neighbor с индексом R от олдеста.
Да, потому что вот он – олдест, вот какой-нибудь битик, neighbor у меня исходит в множество соседей, но сейчас мне нужны соседи только из правой доли, поэтому я вот вел такой neighbor с индексом R.
Да, я знаю все соседи из правой доли, которые соседи с этим олдестом. Мне нужно просто взять и пересечь это множество с G от A без олдеста.
И тем самым у меня в конце G вот так будет пересечение всех тех множеств, которые мне нужны.
Профит. Что-то понятно? Ну хорошо. Но скажу, что это тоже работает за два в степень и пополам, потому что олдест мы знаем, neighbor мы изначально посчитали, то есть эта масса за единицу мы можем к ней обращаться.
Ну и все, вот здесь переход тоже за единицу.
Так, круто. Вот все, мы наконец-то научились находить наибольшую клику за два в степень и пополам.
Вообще говоря, опять, здесь на самом деле тоже прикол, что в задаче с рюкзаком. Этот алгоритм, он тривиальный с кондициацией.
Он здесь прям так и написан, два в степени. Размер графа пополам.
И пока что опять-таки неизвестны алгоритмы, в которые бы работали запылено. Неизвестно ни одного алгоритма, который бы находил наибольшую клику в графе.
А можно попробовать этот шанс алгоритма применять в теннингах?
Мы же можем, в принципе, все время, если просим...
Я такого не знаю.
Саму клику?
А?
Мы же вроде как можем, в принципе, все время, если просим, хранить саму клику, которую мы нашли...
Ну конечно, да.
Не знаю. Сходу, мне кажется, не рабочий, потому что вам все равно...
Чтобы все стыковать, вам все равно примерно такое время.
Есть какие-то другие алгоритмы, которые работают чуть быстрее, но там другие идеи используются.
То есть скорее это вы не до оптимизации, не до чего докладываться.
Есть другие, как бы чуть получше.
Потому что, насколько я знаю, есть примерно вот такого, примерно 8.
Но это ни пофрес какое улучшение.
Хоть какое-то, но...
Есть там еще чуть-чуть лучше, но это все экспоненты все равно.
Каждый полином никому не поддался.
Вот.
Так, ну что, идем дальше.
Тогда следующая задача.
Задача о хроматическом числе графа.
Значит, задача есть граф, надо найти его хроматическое число.
Чистое хроматическое число.
Значит, это следующее.
Мне нужно покрасить все вершины в несколько цветов.
Так чтобы вершины, соединенные ребрами, были разного цвета.
А вот, например, если есть какой-то ребро, то в конце этого ребра то хроматическое число будет разным цветом.
А вот, например, если какой-то ребро, то в конце этого ребра должно быть обязательно разный цвет.
Например, это один, вот этот два, вот этот три, вот этот один, вот этот четыре.
Это корректная расчет Rank.
То есть, если вершины сせstate ребром, то они должны быть обязательно разным цветом.
Можно?!
モху так выاجать
Да, извините.
Да, если соединены ребром, то они обязательно разным цветом.
И наша цель это смочь покрасить наш граф в как можно меньше
чемого цветов.
Например, вот здесь понятно дело, что четверка совершенно
изыгрышная, можно здесь поставить единичку, а уже
меньше чем тремя цветами не обойтись, потому что
есть этот цикл, его меньше цвета не распрасишь.
Найти наименьшее к, такое, чтобы граф, ну давайте
лучше вершины графа, можно правильным образом раскрасить
граф к цвету.
Независимая лимба, называется форма включения-включения.
Так, пусть, у нас есть tn под множеством множеством
m, в объединении дающейся все b, тогда мощность множества
перед всеми дополнениями равна вот такой сумме.
Так, x под множество множество индексов, минус один степень
мощность x, мощность пересечения из x, незнакомая запись.
Ну формула, наверное, вы многие знаете.
Чудесно.
Ну, возможно, задача не привычная, но давайте я,
я все равно без доказательства, я даже не говорю, что я
буду есть какой-то основной полюс, но тем не менее.
Что это значит, смотрите.
Представьте себе, что вот эти h, как плохие множества.
Тогда, что такое хорошее, значит, вот это вот плохие
множество, а я хочу узнать количество хороших элементов.
Так, нет, наверное, вот это вот глупо.
Сейчас, наверное, не лишнее.
Да, сейчас будут все плохие.
Так, сейчас извините на всякий случай.
Да, это я лишнее, это я лишнее взял.
Так вот, пусть это плохие множества, мне нужно Mage
количество хороших элементов.
То есть, те, которые не попадают ни в одно множество, — это
как раз размер множества пересечений дополнений.
Доболнение — это как раз не попадающее в АИТ,
пересечение всех дополнений, это те элементы,
которые никуда не попадают.
Так вот множество элементов, которые никуда не попадают,
это что такое?
Это все множество, все элементы, кроме тех, которые попали в а1 и т.д. а, плюс те, которые попали в 2 из них,
минус те, которые попали в 3 из них, ну и т.д.
А это уже обычная, собственно, формировка форму в члене исключения.
То есть мы сначала берем все, как бы все элементы, это будет слагаемо,
означает, что их равно к кустовому множеству, когда здесь будет 1,
перечисление по кустовому множеству считается равным b, то есть всему универсуму.
Ну и дальше вычитание по одному элементу, прибавление попарных переченей, вычитание по троечных переченей, ну и т.д.
Так вроде нормально.
Дальше, смотрите, давайте я скажу, что b это множество вершин нашего графа, множество вершин нашего графа g.
А в качестве вот этих ашек я возьму все независимые множества нашего графа.
Значит, клика, вот только что у нас были клики, это наборы вершин, которые попарно ребрами соединены,
а независимые наоборот, когда нет ни одного ребра.
Значит, вот давайте я все заминирую, пусть и 1 и так далее, и самым большой, это все независимые множества.
Независимые это такие, внутри которых нет ребр.
Независимые множества внутри него нет ребр.
Смотрите, зачем нам они нужны?
Например, вот на этой картинке мы можем легко заметить, что если я рассмотрю множество конкретного цвета,
например, вот здесь я рассмотрел вершины столько первого цвета, это гарантированно независимая множество.
Потому что пусть между ними ребро, они не могли бы быть оба одного цвета.
Не могли бы быть эти вершинки одного цвета.
Ну и в общем случае, если у нас есть корректный раскраску концветов, то множество любого конкретного цвета,
множество вершин покрашенных определенного цвета С, это всегда независимое множество,
потому что между ними не может быть ребр по определению.
Вершины одного цвета, они обязательно не соединились, потому что если соединились, то должны быть разные.
Поэтому наша цель, в какое-то смысле множество В, это разбить в объединение независимых множеств.
Давайте я нарисую такую картинку.
Мне нужно взять несколько независимых множеств,
а там Исим в режиме И1, Исим в режиме И2, Исим в режиме И3.
И соответственно покрасить все вот эти в первый цвет, все вот эти во второй, эти в третий и так далее.
Если моя цель это найти раскраску в конец цветов, то мне нужно В покрыть К независимой множеством.
Согласны?
Согласны.
Я запишу, что раскраска цветов, это то же самое, что покрытие В, покрытие В к независимому множеству.
Более того, для простоты мы позволим себе этим множеством пересекаться.
Мы позволим, что эти множества могут между собой пересекаться.
Ну, если по-прежнему выполняется, что объединение всех этих независимых множеств по-прежнему В,
то мы все равно имеем корректную раскраску в конец цветов.
Ну, потому что если есть пересечения, то я могу спокойно одно из высших множеств сузить до такого, чтобы у меня раскраска однозначно определялась.
От того, что они пересекаются, мне только как бы легче жить.
Потому что если они пересекаются, то значит я вот эти вершины могу покрасить и во второй, и в третий цвет.
Но главное, что хоть как-то могу.
Поэтому я не буду заботиться о том, что они не пересекаются.
Вообще говоря, в нормальном мире раскраска – это именно разбиение вершин на несколько независимых множеств.
Так что множество вершин покрашено в первых цветовых сторонах, и они не пересекаются очевидно.
Но я для того, чтобы решить задачу, не буду в этом заботиться.
Давайте это отдельно пропишу, что независимые множества могут пересекаться.
Главное это обеспечить то, что они в объединении покрывают все В.
Если они в объединении покрыли все В, то у меня точно есть правильный раскраска цветов.
Чудно.
Что я хочу?
Я хочу научиться покрывать В несколькими независимыми множеств.
Точнее, ровно к независимым множествам.
Вот хочу такую штуку сделать.
Сейчас, момент.
Да.
Вот что обозначим.
Out X.
Out X.
Это количество таких независимых множеств, которые с X не пересекаются.
Количество таких, давайте скажем, жи, что и житое пересечение с X это пустое множество.
Есть отдельно X, есть отдельно независимые множества из X уже.
А вот X это количество независимых множеств, не пересекающихся с X.
Тогда, теорема.
Количество покрытий В с помощью K независимых множеств
равно сумме по всем X под множеством V минус 1 в степени мощности X на Out X в степени K.
Вроде правильно.
Да, конечно, это тоже трудная задача, там на коленом надеяться нельзя.
Значит, смотрите, давайте поймем, что это написано.
Вот тут есть слагаемое нулевое, для X все равно пустое множество.
Что это за сумма, смотрите, для X все равно пустое множество, у меня получается слагаемое Out пустого в степени K.
Что такое Out пустого множества в степени K?
Да, общее количество зависимых множеств.
Я вам обозначил N большого, это будет N большого в степени K.
Out пустого множества, понятно, что любое независимое пересекается с пустым по пустому множеству.
Поэтому Out пустого множества это вообще все независимые множества.
Что это такое, соответственно, это N в степени K?
По факту это общее количество вот таких вот наборов, упорядоченных наборов, I, I1 и так далее, I и K,
где все I-шки это независимые множества, но произвольные, произвольные независимые множества.
То есть вот это вот количество, первое слагаемое в нашей сумме, это общее количество кортежей длины K из независимых множеств.
Дальше, мне нужно из них вычесть те, которые, скажем, не покрыли первую вершину.
Да, потому что если я учел все возможные кортежи длины K из независимых множеств,
то из них плохие те, кто первую вершину не покрыли, потому что мне нужно покрыть все.
Это соответствует слагаемой для X равно множество из единиц.
Тогда как раз А от множества из единицы это в точности количество независимых, не содержащих единицу.
То есть количество независимых множеств, не содержащих вершину номер один.
Их я вычитаю, потому что здесь будет минус один.
И соответственно я вычитаю все возможные кортежи длины K из независимых множеств, такие, что в них нет единиц.
Дальше я вычитаю все, которые не содержат двойки, тройки, так далее, m.
Потом прибавляю все попарные.
То есть, скажем, когда х равно 1 на 2, я, наоборот, прибавлю все возможные кортежи длины K из независимых множеств,
которые не содержат ни единичек, ни двойки.
Потом по множеству размера 3 я их вычитаю, по множеству размера 4 прибавляю.
То есть по факту я просто использую форму исключений, где b это общее количество покрытий,
общее количество, точнее, кортежей длины K из независимых множеств.
А все h, 1, так далее, am, это кортежи без какой-то конкретной вершины.
Сейчас давайте напишу конкретно это все, и получится, что мы теперь мы казали.
Значит, по факту доказательства из двух строчек.
b это...
Давайте просто так напишу. Все кортежи из K из независимых множеств.
А и t это то же самое.
Но причем эти множества должны не содержать вершин. Не содержащих.
Тогда то, что написано в левой части нашей леммы, вот это вот,
количество кортежей длины K, которые не лежат ни в одном из аи.
Это точно все кортежи, покрывающие целиком множество v.
Потому что принадлежность к любому из аи, это значит, что какой-то элемент в нашем покрытии не участвует.
А если я лежу в пересечении дополнений к аи, тогда у меня по-красному все вершины покрыты.
Получается, что количество хороших покрытий нашего v, то есть по факту то, что мы ищем,
равно вот такой сумме, ну и собственно там какие-то пересечения по под множествам аи,
ну пересечения по множеству аи, если я пересеку какие-то ашки,
то у меня будет в точности вот это вот количество всех независимых, которые не содержат ни одной из вершин данного множества.
То есть формально просто вот это вот лемма для должных а и b.
Вот, ну и таким образом, смотрите, если я научился каким-то образом находить для каждого икса
количество независимых множеств не пересекающих x, то я могу посчитать эту сумму,
если она больше нуля, то значит есть раскраска в кадр цветов.
Давайте напишем следствие.
Раскраска в кадр цветов существует.
Раскраска в кадр цветов существует.
Только если эта сумма больше нуля.
Вот так вот.
То есть мне осталось научиться делать следующий шаг.
Мне нужно для каждого множества научиться находить количество независимых не пересекающихся из данного множества x.
Как найти all of x для всех x?
Так, сейчас, момент.
Ну, давайте немножко переформулируем.
Во-первых, all of x это все такие независимые множества, которые вложены в a без из.
Да, потому что не пересекающие с x, а то же самое, что вложено в дополнение x.
Поэтому теперь мне достаточно научиться для каждого множества, давайте еще переформулируем, назову их как-нибудь y.
Вот если я напишу, что b вот y, это множество всех независимых множеств, вложенных в y,
то дальше просто all of x, сейчас будет y просто, ну, как бы сменой маски напротиволожных.
А all of x это будет b без x.
Поэтому достаточно научиться находить вот эту b.
Мне достаточно научиться для каждой маски узнавать, сколько в ней есть независимых подмасок.
То есть множество маска, да, какая-то y.
Нужно узнать, сколько в ней есть независимых подможеств.
Внутри этого множество есть.
Так, ну давайте сделаем.
Мне нужна будет еще одна вспомогательная штука, это мы уже делали.
Это проверка того, что y является независимым.
То есть штука, если y независима множеством, но если иначе, да, иначе.
Тогда b это просто сумма c по всем подмножествам.
Это сумма по всем, ну давайте z там из y, c вот z.
То есть я перебираю все подмножества.
И либо оно независимое, тогда оно дает 1 в нашу сумму.
А если оно не независимое, то оно дает 0 в нашу сумму.
Как раз мы считаем количество из этих множеств.
То есть смотрите, у меня есть массив c, который мы уже умеем считать за 2 в степени n.
Раньше мы для каждой маски могли посчитать динамику за вот такое время,
которая проверяет, является она клика или нет.
Но то же самое работает с независимыми множествами,
потому что клика и независима очень похожи.
Можно просто взять дополнение графа, когда поменять ребро на отсутствие ребра,
и наоборот отсутствие ребра пролететь в ребро.
Когда у вас клика и независимое множество поменяются места.
Так вот, мы можем посчитать от массива за 2 в степени n,
а дальше мне нужно учиться находить сумму по подмаскам вот этого массива c.
То есть я фиксировал какую-то маску, нужно брать все подмаски и найти сумму cоз.
Ну давайте быстренько это сделаем.
Значит, пусть dp, mask, pos, эта сумма по всем подмаскам,
совпадающих с маской хотя бы в pos первых бит,
Так, нужна буква f, я браю все подмаски,
и при этом f и mask совпадают в первых, по крайней мере, pos бит.
Совпадают хотя бы в первых pos бит.
С от f.
Ну тогда если мы такую динамику ввели,
тогда соответственно ответ у нас b от y.
Это просто dp от y.
Да, потому что когда pos равно 0,
это значит, что мы не накладываем никакое ограничение на подмаске.
А здесь если pos какой-то,
то мы опять-таки рассматриваем сумму по всем подмаскам,
но только они, вот эти подмаски f должны обязательно совпадать в первых pos битах.
Если pos равно 0, то это точно то, что нам нужно.
Как бы не требуется никакое совпадение.
Теперь как делать переходы.
Ну точнее давайте начнем с базы.
База dp, mask, b, это просто c от маски.
Потому что если мне нужна подмаска данной маски,
совпадающая с ней в первых n битах,
то это просто она сама.
У нас сумма ведется по одному элементу,
остается просто c от маски.
Вот, ну теперь переход.
Давайте я самый сложный случай рассмотрю.
Представьте, у вас была маска какая-то.
Вот вы хотите найти dp, mask, pos.
Если здесь единица,
то мы можем эту единичку проварировать.
То есть в подмасках она либо 0, либо 1.
В подмасках она либо 0, либо 1.
И соответственно тогда совпадают первые pos минус...
совпадают...
Так, наоборот я иду с конца.
Да, значит я могу фиксировать этот бит каким-нибудь.
И тогда сказать, что совпадает не первый pos бит, а первый pos плюс один бит.
И будет такая форма, по примеру.
Так, извините, пару минут мне еще нужно.
Значит, если...
если...
после письма еще...
тогда dp, mask, pos.
Это dp.
То есть я сначала этот бит оставляю.
И говорю, что мы совпадаем в pos плюс одном бит.
То есть я здесь насильно оставил единичку.
И скажу, что мы совпадаем еще на одном бите побольше.
То есть я оставил там гарантированную единичку.
Либо же я могу эту единицу занулить.
И соответственно взять dp от маски без...
ну без вот этого бита.
Это будет что-то в стиле...
2 в стиле не минус pos.
Да, потому что номер этого бита...
примерно как раз 2 в стиле не минус pos.
Ну и опять-таки совпадают с первым pos и с одном битем.
То есть еще раз, если в маске здесь была единица,
а я хочу, чтобы они совпадали в этих вот битах первых,
то я перебираю, что стоит здесь.
Что в подмаске стоит в этом бите? Либо 0, либо 1.
Если 0, тогда соответственно я могу здесь насильно поставить 0.
Его вычеркнуть из маски.
И сказать, что мы совпадаем с первым pos и с одном битем.
Либо здесь стоит 1, и я совпадаю просто с pos и с одном битем.
Вот дыру, которую пошел.
Соответственно я в этой сумме разбил слагами на две части.
Те, у которых тут 1 и те, у которых тут 0.
Ну и сложил, которые сложил через dp.
Вот.
Все, тем самым у меня получается ответ.
Я насчитал за...
ну типа 2 в стиле не минус 5.
Все, теперь значит, с конца пройдемся еще раз.
Мы не считали dp.
То есть мы для каждого множества знаем, сколько у меня есть независимых подмножек.
Значит, знаем массив a, вот этот вот, который нам был нужен.
Ну и теперь, если там с правильными процентами их сложить все, в каты степени возвести,
то мы будем знать количество покрытий k независимым множеством.
А этот раз решает нашу дачу про k-раскраску.
Все, спасибо. Извините, что я немножко субботно.
