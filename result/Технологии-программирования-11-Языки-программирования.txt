Так, всем доброго дня. Мы с вами продолжаем наш курс. И нынче это такая последняя обязательная
лекция в нашем курсе. Скорее всего, будет еще две дополнительных, потому что, сами понимаете,
сейчас будет переход на 1 мая. То есть следующая среда это 1 мая. Наверное, никто из вас на пару
не придет. Хотя я могу прийти на 1 мая на пару. Вот. Дальше у нас 8 мая будет контрольная,
вторая. Вот. И 15 мая понятно, что после проведения всех контрольных будет только
доп-лекция, в которой мы скорее всего поговорим про антипаторное программирование. То есть про то,
как делать не надо. На самом деле, так или иначе большое количество антипаторных мы выявляем в
то время, когда мы проверяем, когда мы делаем какие-то задания. Вы пишите проект. Собственно,
у вас так или иначе подсвечивают эти антипаторные. Вот. Но сегодня мы с вами поговорим немножко о
другом. Возможно, сразу скажу, что эту лекцию нужно было поместить немного раньше. Где-то сразу
в середине курса, может быть, даже в самом начале курса с него начать наш блок лекций. Но так сложилось,
что, в принципе, сейчас мы можем как раз поговорить про базовые понятия о языках
программирования. Потому что, так или иначе, к концу семестра, возможно, кто-то из вас уже
освоил два языка программирования в каком-то базовом варианте, а, возможно, кто-то и более,
чем два языка программирования, потому что решили написать проект на своем собственном языке. Ну,
не на своем собственном языке, имеется ввиду на языке, который выбрали. Да, собственно, язык там
мы не заставили. А? Ну, на любом языке. Вот. И нам нужно понять вообще, в чем особенность
каждых из этих языков и понять некоторые основные фишки, которые мы с вами наблюдали в разных
языках программирования. Вот. Значит, и первое, с чего мы сегодня начнем. Давайте расскажу план.
Мы начнем с вами с рассмотра разных парадигм-программирования, а потом приведем
классификацию языков программирования. Какие они бывают, в чем у них есть особенности. Поехали.
Давайте начнем с такого понятия, как парадигма программирования. Что такое парадигма
программирования? Это, так сказать, область, в которой мы с вами рассматриваем вообще наш
процесс написания кода. То есть, вообще, как мы именно мыслим в точке зрения написания кода. И
здесь есть несколько различений того, где мы с вами пишем код. То есть, есть основная категоризация,
да, и есть, так сказать, перпендикулярная ей категоризация. Вот это нужно понимать. То есть,
сейчас мы поговорим про основные вещи, после этого мы с вами поговорим про дополнительные аспекты.
Итак, давайте начнем со следующего вопроса. Когда мы пишем инструкции в коде, пишем какой-то код,
давайте поймем, на какой мы с вами отвечаем вопрос. Тут именно нужно понять, какой вопрос мы
задаем, когда мы говорим, что мы пишем код. Вот, давайте представим, мы пишем с вами код на C++,
да, что мы говорим программе нашей? Исполни какие-то команды. То есть, мы даем именно
императивный стиль написания кода. То есть, мы говорим, каким образом ты должен выполнить эти
функции. И вот первое порадигма, первое разделение на парадигмы как раз состоит в том, на какой вопрос
мы с вами отвечаем. То есть, первый вопрос это, как мы все делаем, второй это мы отвечаем немножко
на другой вопрос. То есть, первое основное деление в парадигмах программирования это то, какое оно
у нас. Оно у нас инперативное и мы работаем с вами в императивной парадигме или декларативной
парадигме. И вот здесь явно нужно будет различить, на какие вопросы каждый из них
отвечает. Итак, давайте начнем с первого. Императивная отвечает на вопрос как. То есть
мы говорим то, именно как мы пишем наш код. Хорошо. Значит, давайте посмотрим, что это означает.
Значит, с чем у нас заключается императивное программирование? Значит, смотрите, у нас в коде
есть набор инструкций команд. То есть мы говорим выполни функцию foo, выполни функцию
var, выполни функцию fi. Значит, дальше что мы говорим с вами? У нас инструкции выполняются
последовательно. Ну преимущественно выполняются последовательно. Понятно, что мы не говорим про
параллельное программирование, хотя это тоже одна из парадигм, в которой мы с вами должны
уметь работать. Но они на самом деле, если мы говорим про разделение, то параллельное
funçãoом 열�ная программирования
параллельнаяâlシня
парадигма
которая
перпендикулярна
направление императивное и декларативное
да? есть именно декларативные
ой
есть именно
декларативные параллельные языки
и императивные параллельные языки
то есть этим нужно
это нужно учитывать
далее
значит
говорится следующее
что данные
которые у нас есть
после выполнения в drin
могут читаться
инструкциями. То есть мы с вами говорим, что вот та инструкция, то есть мы записали
результат в какое-то значение и дальше мы можем использовать этот результат для
выполнения следующих операций. То есть одна из самых важных, смотрите, важных
особенностей императивного программирования заключается в том, что мы можем записать
в переменную какое-то значение. Вот это я подчеркну. То есть мы именно можем
записать то, что у нас находится в переменной. То есть у нас есть такое
понятие, как регистр, и с ним мы работаем. И вот оказывается, как ни странно, такой
интересный аспект заключается в том, что на самом деле и на уровне железа у
нас все по факту устроено в императивной парадигме. То есть мы именно с
тачкой по императивной парадигме. То есть сейчас как раз идет параллельно курс по
компиляторам. И у меня коллега, который пишет компилятор, решил написать компилятор
для функционального языка программирования. И вот у него возникли огромные проблемы с
тем, как вот, собственно, функциональный язык внедрить в императивную парадигму.
Потому что на последних стадиях компиляции там именно преобладает императивная
парадигма. То есть не состыковка парадигм, и это все ломает. В итоге мы договорились,
что мы пишем компилятор, который, собственно, обходит все эти стадии. Ну, то есть обходят
императивные стадии. Вот, значит, и при этом данные, которые у нас получены при
выполнении некоторой инструкции, могут записываться в память. То есть мы записываем
их в память, либо мы записываем на стэк, либо мы их записываем на память. Давайте
тут нужно сразу сказать, как у нас выглядят разные аспекты. Значит, хорошо. У меня вопрос.
Все знают, что такое куча или нет? Не структура данных. ХИП. Да-да.
То есть, в принципе, давайте еще раз тогда напомню на всякий случай, что у нас, когда
вызывается любая функция, у нас с вами возникает стэк. Значит, у нас есть у нашего стэка указатель
на фреймпоинтер. То есть это то, в каком месте у нас начинается функция. Дальше мы в эту функцию
кладем аргументы. Вот. До четырех аргументов обычно передается при помощи регистров. Дальше
переменные передаются при помощи уже элементов на стэке. Ну и дальше мы с вами лоцируем элементы
на стэке. Причем, что у нас может быть? Дальше мы говорим следующее, что если нам нужно выделить
какой-то участок памяти, то мы делаем следующее. Мы выделяем некоторый участок памяти, а после этого
он у нас отправляется в отдельное хранилище. То есть, ищется место, где мы можем выделить ХИП.
Вот. При этом сразу хочу сказать, что на самом деле объем памяти, которая мы с вами явно требуем
для процесса, он может быть больше. То есть мы можем затребовать данных больше, чем на самом деле
этой памяти нам нужно. То есть у нас есть такое понятие, как виртуальная память, которая мы явно
лоцируем. Она может полезна быть. И есть как раз выделенная память у всех процессов. Давайте я как
раз покажу, что они сильно различаются. Так, я не знаю, тут видно? Нет, посмотрите, пожалуйста,
на четвертый столбец. Какие числа там выглядят? То есть с правой стороны это процент памяти,
который в MEM у нас процент памяти, который действительно у нас используется. Так, давайте
sort by %mem. Вот. То есть у меня сейчас процесс Google Chrome занимает три с половиной процента
реальной памяти. Но при этом выделяем мы именно виртуальной памяти 422 гигабайта. То есть в принципе
вот процесс, для того чтобы он жил в отдельном адресном пространстве и у него хорошо работало,
ему нужно как раз вот такое количество виртуальной памяти. При этом из этой виртуальной памяти мы
резервируем некоторую часть. То есть мы по запросу можем выделить какое-то количество оперативной
памяти. Вот. И как раз malloc, как раз функция ala malloc, они как раз позволяют выделить участок этой
памяти. Функция aloc, malloc, new и так далее. Вот. То есть это что касается у нас операции. То есть
в принципе данные мы можем записать вот в один из участков памяти. То есть либо мы записываем
нас так, либо мы записываем на кучу. Хорошо. Так. Это понятно? Давайте подумаем, попробуем привести
примеры языков с императивной парадигмой. Ну да, на самом деле большая часть языков,
которые вы знаете, обладает императивной парадигмой. Это значит, что поскольку у нас большое
количество языков работают в императивной парадигме, то нам нужно каким-то образом их
отклассифицировать. Вот пример императивных языков. То есть это c++, это java, python, javascript,
rast и так далее. Понятно, что они могут работать и в других парадигмах. То есть сейчас как раз
возникают мульти парадигмальные языки программирования. Вот. Ну и давайте приведем
некоторую категоризацию императивных языков, потому что они на самом деле есть разные и как
минимум их можно выделить пять подкатегорий. Значит первые языки это языки с процедурным
программированием. То есть мы с вами пишем функции, а после этого мы их выполняем. Давайте подумаем,
какой язык является каноническим представителем процедурного программирования. Assembler. Ну c точно,
да, потому что у нас там нет никаких классов. Assembler ну в целом тоже может сойти. То есть у нас
по факту там называется это не процедура, это называются фреймы. Да, и мы в принципе выполняем
команды по фреймам. Так, значит дальше у нас идет структурное программирование, то есть в котором
мы сами собираем объекты, которые являются структурами и которые по факту не могут
обладать своими методами и функциями и так далее. Вот. Это тоже на самом деле си, потому что мы
можем как раз объекты собирать в определенную структуру. Да, но при этом мы не можем создать
именно, то есть мы их не можем лоцировать на куче, мы их лоцируем преимущественно на стэке. Значит,
третья вещь это аспекты ориентированное программирование. Значит, смотрите в чем интересная
особенность. Особенность в том, что мы акцентируемся не на выполнении функции, а на выполнении
некоторых аспектов, то есть выполнение некоторых точек триггеров для выполнения нашего кода. Вот.
Какой здесь есть канонический пример для аспектов? Они обычно встроены в языке программирования,
но в целом давайте вспоминать тему, связанную с тестированием. Какой у нас есть аспект, связанный
с тестированием? Когда мы пишем с вами тестовый класс, что у нас помимо тестов может быть в
этом тестовом классе? Это да. Да, смотрите, у нас есть некоторый набор функций, к которым мы
задаем жизненный цикл нашего теста. Напоминаю, какие это функции. Первое это setup test class,
которая вызывает, создаёт тесты перед, вызывается один раз перед созданием всех тестов. Дальше у нас
есть функция setup, которая вызывается перед каждым тестом. То есть видите аспект как раз. То есть
перед всеми тестами, перед каждым тестом. Потом после каждого теста у нас выполняется teardown,
и в конце концов у нас все завершается тем, что мы вызываем функцию teardown test class, которая
очищает все окружение. То есть у нас есть прямо аспекты, которые мы с вами прописываем. Понятно,
что аспекты тоже могут быть и не только в императивных языках. Это что касается аспектно-ориентированного
программирования. Следующая парадигма – это объектно-ориентированное программирование. То
есть мы говорим, что у нас появляется такое понятие как объект, у которой мы можем с вами
инстанциировать. У объектов у нас с вами есть возможность их создания и прописывания их
атрибутов, полей модификаторов и методов. При этом понятно, что когда мы вводим объектно-ориентированное
программирование, то у нас возникают три основных понятия. Какие? Энкапсуляция, полиморфизм и
наследование. Все это знают? По идее сейчас у всех должен идти курс по объектно-ориентированному
программированию. Ну да. Собственно как раз мы говорим, что у нас есть энкапсуляция. Давайте напишу.
Наследование и полиморфизм. То есть энкапсуляция нам позволяет сокрыть детали реализации,
наследование позволяет обобщить особенности определенного объекта, а полиморфизм позволяет
определить поведение к какому объекту мы именно идем. Разделение, да. Согласен. Так и последняя
категоризация императивных языков это обобщенное программирование. Что такое обобщенное
программирование? Обобщенное программирование нам позволяет создавать объекты и объекты метода
и функции, которые могут работать не только с одним типом данных, но и с несколькими типами данных.
Давайте попробуем привести примеры. Да, конечно, это шаблоны. То есть ВС++ это шаблоны. Если мы говорим
про джаву, то это... Так, есть здесь люди, кто джаву знает? Какой механизм в джаве? О том,
что мы можем у функции подставлять разные типы, принимать разные типы, его класс принимать разные
типы. Ну, конечно же, дженерики. Да, понятно, что в джаве дженерики работают не по такому
принципу, как в С++ шаблоны. Да, потому что С++ шаблоны у нас определяются на этапе компиляции. В джаве
все-таки дженерики, они смотрят на дерево наследования от типа object. Вот, это нужно учитывать. Вот,
значит, это основная категоризация императивных языков, которые у нас существуют. Давайте по этим
всем аспектам вопроса. Здесь кажется, что... Смотрите, здесь важная особенность состоит в том,
что кажется, что это... С этим мы так или иначе уже сталкивались. Совсем. Давайте перейдем в другую
парадигму. Парадигма декларативного программирования. Она отвечает на вопрос «что». Не как, а что. И
должно быть сделано. Пример. Классический пример. Представьте себе, что некоторые друзья идут в гости.
Значит, что вы сделаете в императивном языке программирования? Вы скажете «выйти на остановке
ААА, пойди туда не зная куда, поверни налево, зайди в первый подъезд». Да, то есть мы говорим именно
набор команд, при помощи которых мы с вами можем дойти до определенной цели. У кого-нибудь есть
мысли по тому, что в декларативном программировании нам нужно? Да, просто вот вам адрес, координаты,
вперед. Решайте сами, как вы добираетесь до этой цели. Да, именно так. Значит, вы в декларативном
у нас есть адрес bbb, нам важно быть к cc2.dd, каким образом неважно. И это позволяет сделать некоторые
специальные вещи, которые, так сказать, позволяют нам ограничить наши действия, то есть ограничить
некоторые ошибки. Понятно, что тогда язык программирования на себя должен брать гарантии по
поводу того, что у нас могут быть ошибки. Давайте я приведу один классический пример. Он касается
не именно языков программирования, а именно самой парадигмы. Представьте себе, что бедный Паша
увидел, что наступил дедлайн, и сказал, что ему нужно поставить 10 серверов АхЧек. Значит,
он берет на АхЧек ставить 10 серверов. Дальше ему говорят, что надо поставить... Потом пришел не
только курс по телевизору программирования, пришло еще какое-то количество курсов, и ему говорят,
что нам теперь нужно 15 серверов. В интервативной парадигме мы можем очень легко запутаться и
сказать следующее. Либо нам нужно поставить еще 5 серверов для того, чтобы у нас было 15,
либо мы можем спутать команду и сказать, что нам должно быть... Сколько? Еще 15. То есть нам
нужно производить какие-то вычисления. Особенно если у нас где-то неявная этипизация,
мы работаем в Javascript, но так-то понятно, что мы получаем 25 серверов. И затраты сильно возрастают.
Понятно, что 25 серверов это много, поэтому во всех таких языках, особенно в облачной инфраструктуре,
когда мы уходим арендовать серверы, обычно работают чисто в декларативной парадигме,
для того чтобы таких ошибок не было. А система должна сама решать, каким образом прийти в это
состояние. И здесь, извините, мне нужно сделать некоторую отсылку к Матану. Как раз Матан был.
Для того, чтобы работать в этой парадигме, нам важно, чтобы, особенно в установке серверов,
нам очень важно обеспечить то, что мы можем прийти в это состояние. И для этого нужно два
свойства основных. Во-первых.
Первое. Это сходимость к предельной точке. То есть, смотрите, пример такой, что у вас надо
арендовать 15 серверов, потом вы в какой-то момент понимаете, что вам осталось 14 арендовать,
13 арендовать, 12 арендовать и так далее. То есть вы сходите в предельной точке. В математике есть такое
понятие, как сжимающее отображение. И, возможно, эта идея у вас уже была в курсе математического
анализа, когда вы берете какой-то набор точек, дальше каждый раз вы понимаете, что расстояние
между точками уменьшается. Не было? Ну, к примеру, классическая задача, что у вас есть какая-то
возрастающая функция, да, и она, известно, что ограничена сверху. Ну, значит, да, и причем
она является у нас непрерывной. Вот это важно. И тогда в этой точке у нас существует предельное
значение, которого мы придем, когда мы дойдем до правой границы. То есть мы можем дойти до
предельной точки. И как раз цель вот этих вот декларативных языков, особенно в инфраструктуре
настройки оборудования, как раз потихоньку приходить к этой предельной точке. Возможно,
не за одну итерацию, а за большое количество итераций. Почему, как вы думаете, нельзя
гарантировать, что мы придем к финальной точке за одну итерацию? Ну, все очень просто. Сеть
может оборваться, сеть может выключиться и так далее. То есть у нас есть факторы, которые могут
повлиять на это. А второе свойство, оно тоже очень важно, и оно говорит о том, что нам не стоит вообще
рассчитывать на ошибки. То есть, смотрите, это свойство называется идентпотентностью.
Наверное, у вас этого определения в курсе математического анализа еще не было?
На алгейме было. Ну, давайте я тогда введу определение идентпотентности.
Собственно, мы говорим, что функция f является идентпотентной.
Функция f из x в x такая, что для любого x f от x равно f от f от x. Что это означает?
На терминах языков программирования это означает, что мы какую-то функцию выполнили один раз,
получили какой-то результат, и в принципе нам не страшно выполнить эту же функцию еще один раз для
того, чтобы получить тот же самый результат. Потому что у нас могут быть ретраи, то есть нам
нужно будет повторять какое-то действие. Давайте пример попробуем привести идентпотентной функции
с точки зрения программирования. Ну, каких-то утилит, которые вы уже смотрели.
Ладно, давайте это. Пример.
Чего? А какое было?
Ну, вполне возможно. Я просто, видимо, разограничил его на два определения. В принципе, первое обычно
позволяет ослабить определение. То есть через некоторое количество итераций мы получим тоже
самое значение. Давайте пример идентпотентной функции. Ну, ls нет, она не является идентпотентной,
потому что у нас кто-то в какое-то время может создать какую-то директорию, вывод будет не тем
же самым. Давайте мы как раз сделаем следующее. Так, мы выполнили функцию mcadirtest. Что произойдет,
если мы еще раз выполним эту функцию? Вы уверены? Мы получим ошибку, что такая директория уже
существует. Это неидентпотентная функция, потому что мы применили ее один раз, применили ее один,
второй раз. Мы на второй раз получаем ошибку. Понятно, что возвращение ошибки не то же самое.
Кто может сказать, какая функция будет идентпотентной в данном случае? mcdir-p. Она говорит,
что я не буду создавать директорию, если она уже существует. Более того, она создает родительские
директории. То есть мы теперь можем сделать и повторять эту функцию бесконечное количество раз,
и у нас результат этой функции не поменяется. Вот это пример идентпотентной функции. Понятно,
что для того, чтобы реализовать эту идентпотентную функцию, нам нужно проверять,
существует ли директория, если нет, то ее создавать. То есть мы берем переклады в другую парадигму.
Вот, то есть это важно сказать в аспекте декларативного программирования, что если мы
уходим на какую-то инфраструктуру, обслуживание инфраструктуры, то нам нужно обеспечивать вот эти
два свойства. Так, хорошо. Понятно ли вот эту вещь? Так, теперь давайте попробуем понять,
какие же парадигмы есть в декларативном языке. Значит, здесь есть несколько категоризаций.
Первое из них это функциональное программирование, то есть где мы считаем, что все, что у нас есть,
это функция. Значит, и здесь обычно выделяют тройку лидеров в этих языках. Первый язык это хаскель,
он очень часто используется именно даже в промышленной сфере. Второй язык, ну понятно,
что это, так сказать, как называется, противопоставление языку хаскель, это язык f-sharp,
в котором у нас с вами по факту аналогия с c-sharp. И третий это lisp. И есть логическое
программирование, в которых мы пишем некоторый набор логических утверждений, а дальше мы делаем
вывод, пытаемся сделать некоторый вывод из тех инструкций, которые мы с вами написали. Сейчас
я буду показывать примеры языков, поэтому не бойтесь. Значит, смотрите, давайте поймем
функциональное программирование. Вот пример кода на языке хаскель. Так написан qsort. Давайте
поймем, что здесь у нас все, что есть, это функция. Да, это qsort. Давайте разбираться. Значит,
смотрите, что у нас получается при получении пустого списка. Возвращает пустой список. Дальше
что оно делает? А дальше p.xs, это мы берем список на две части разделяем. То есть мы говорим,
значит, что p.xs, дальше мы говорим, что нам нужно будет запустить функцию... Это, кстати, не
оптимальная реализация qsort, я сразу скажу. Это просто для показаний демонстрации. Значит,
что нам нужно сделать дальше? Нам нужно будет сконкатенировать списки qsort от лесор,
дальше взять наш код p и дальше использовать qsort от greater. Где greater это функция и lesser это
функция. То есть все, что у нас есть, это функции. То есть у нас lesser это filter меньше, чем по
значению p от xs. То есть мы оставляем результаты тех функций, тех значений, которые меньше,
чем p. С другой стороны greater это тоже применение результатов функции filter к объекту xs. Ну,
к списку. То есть у нас что? У нас есть список. В нем у нас есть...
Значит, мы, когда работаем со списками, мы можем выделить голову p и xs. Вот. Значит,
после применения функции lesser мы оставляем только те элементы, которые меньше, чем p. А те,
которые greater, это те, которые имеют значение больше, равно, чем p. А дальше мы говорим,
что нам нужно сконкатенировать вот это, вот это и вот это. А, когда мы начинаем применять эту
функцию к какому-то объекту? То есть у нас получается по факту труба, в которую мы загружаем наш базовый
объект. И после этого мы получаем какие-то результаты. То есть видите, здесь именно main
это функция. То есть когда я запущу, она проницилизирует список и через этот конвейер
прогонит этот список. То есть она для этого значения 834 начнет выполнять вот эту функцию. Она
принимает огромное значение. После этого она отцепляет наши переменные, отцепляет наше,
так сказать, значение 8 на 34 и делает сортировку. То есть она запускает qsort от lesser. Значит,
что у нас lesser? Нам нужно как раз его получить. Собственно, мы применяем функцию lesser к
аргументам xs, прогоняем ее на значение меньше чем p и greater на значение больше чем p. После этого
у нас собирается итоговый результат. То есть у нас получается такой конвейер по выполнению этих
функций. Вот, значит сразу скажу, что в отличие от языков, от классических именно чисто
функциональных парадигм, список из 8, 3 и 4 это тоже функция. Если мы говорим про чисто лямбда
исчисления, то восьмерка это специальная константа, тройка это тоже специальная константа и вообще нам
нужно вводить операцию конкатинации для наших списков. Но давайте мы этого делать не будем.
Но одна из важных особенностей функционального программирования, которая сильно помогает
работать как раз в этой парадигме, это имутабельные объекты. То есть по факту вы не можете изменить
объекты. То есть у вас все есть функция, вы ее зафиксировали, вы с ней работаете. То есть у вас нету
такого свойства, как присвоить переменные какое-то значение. И если вы в каком-то
функциональном коде видите имутабельные, присваивание переменной значения, значит вы
выходите из функциональной парадигмы. Вот такой пример. Вот тоже организован таким
образом, что мы берем один элемент и мы его тянем. Одним из главных важных особенностей
функциональной парадигмы это коррирование. Давайте я его покажу на примере. Давайте открою
какой-нибудь Python 3. Я открываю Python. Вот так. Так, вот мы написали функцию edit от
аргумента phi и b. Вот в чистой парадигме мы бы выполнили так, что у нас 3 плюс 5 равно 8.
Но что позволяет делать функциональная парадигма? Она позволяет выполнять опцию
коррирования. То есть вы можете из объекта вида функций создать новую функцию. В Python это
реализовывается следующим образом. По-моему, так модуль называется. Вот. Мы создали с вами
функцию edit3, которая является partial объектом от add3. То есть по факту это новая функция,
в которой вместо одного аргумента уже подставлено значение. То есть у нас получается функция add3.
Это функция, которая будет возвращать на вход b значение 3 плюс b. Вот. И это одна из важных
фишек как раз в функциональной парадигме. Зачем это может быть полезно? Как раз для того,
чтобы если мы обрабатываем какие-то списки, чтобы у нас новая функция применялась не к нашему
объекту вида списка, а уже к списку без головы. Там все как раз работает на списке. И тут,
конечно, давайте я попробую сейчас найти какой-нибудь интересный пример. Я не помню,
есть ли он у меня тут. Возможно... Нет, я не найду. В общем, там тоже есть некоторые приколы.
Потом, возможно, если попросить, я покажу примеры. Как некоторые функции написать
чисто в функциональной парадигме. Там будет взрыв голова. Так. Это что касается функциональных
программирований. Теперь давайте перейдем к логическим языкам программирования.
Собственно, здесь как раз у нас идет вывод в виде инструкций. Это язык пролог. На нем до сих пор
можно использовать. Даже я где-то читал, что его можно использовать для искусственного интеллекта,
правда, чисто для вывода всяких логических высказываний. Итак, смотрите, что мы делаем с вами.
Здесь изначально на языке прологи мы делаем некоторую констатацию фактов. Что у нас есть?
У нас есть некоторое магическое число x. Мы задаем некоторые условия. Там давайте,
чтобы это не быть голословным, я покажу пример.
Вот. Смотрите. Это констатация фактов. То есть у нас есть 3 магических числа 7, 9 и 42.
То есть мы работаем в другой парадигме. А дальше мы говорим, что у нас есть некоторое
магическое число x. И мы хотим сделать некоторую вещь. То есть plus x, y 100. Давайте как раз я
попробую запустить это. Все дело. Значит, мы с вами загружаем. Это факт загрузки из файлов. Мы загрузили.
Видите, plus это операция. И он нам выводит ответы, которые нам подходят.
При этом можно сделать вывод всех ответов, не только этого текущего. То есть в принципе мы
пытаемся из некоторого набора утверждений, которые мы задаем, получить некоторый вывод о том,
какие значения нам подходят. То есть обычно мы делаем набор операций для того, чтобы получить
результат. А здесь мы говорим наоборот. Что вот у нас есть какие-то финальные действия, и нам нужно
вычислить последствия операции, которые нам нужны. То есть у нас есть финальный результат,
что у нас есть магическое число x, и нам нужно получить, что x plus y равно 100. А какой x? То есть
как именно получить наш результат? Тоже интересная вещь. И сразу скажу, что когда мы говорим про
парадигмопрограммирование, просто важно понимать, что, грубо говоря, мы можем мыслить не только в
текущей парадигме, в которой нас обычно учат писать наш код. Вот такие вот интересные примеры. Так,
это что касается примера на языке пролог. Значит, голову сильно меняет. Нам учатся писать с этими
языками. Так, понятно ли, в чем заключается декларативная парадигма? То есть здесь у нас
получается, мы заранее декларируем функции, по которым мы должны работать, а после этого выполняем
результат. Здесь мы говорим, что у нас есть набор уже утверждений, и в конце вот этот чисто
декларативный язык. И мы вычисляем последствия действия, которые нам нужно сделать. Так,
можем двигаться дальше. Теперь мы идем в другую периметикулярную ветку и рассмотрим другие
парадигмы программирования, которые у нас могут существовать. Первое парадигма программирования
это метапрограммирование. Я не буду тут детально говорить, тут вообще на четвертом курсе отдельный
курс есть по метапрограммированию, в котором учатся писать. Это главная суть, что программы
могут генерировать новые программы на этапе компиляции. Сразу тут есть небольшая добавка,
версии 2023-2024 года. И это не прочат ГПТ. Да, потому что сейчас уже появились промежуточные искусственные тела,
которые могут генерировать программы. В общем, суть в чем? Суть в том, что мы пишем инструкции,
которые на этапе компиляции позволяют нам генерировать разные функции. Ну да, я согласен,
поэтому про этап компиляции здесь как раз у нас не проходит утверждение. Смотрите, вот примеры два.
С++ поддерживает несколько парадигм, перпендикулярно. Первое это ООП, и второе это
метапрограммирование. Итак, у нас слева видно, что у нас есть класс блинкер, который обладает
некоторыми атрибутами. То есть это у нас конкретный класс, в котором мы можем видеть объекты. А справа
это у нас с вами метапрограммирование, которое позволяет нам создать уникальный объект определенного
класса. То есть мы по факту делаем UniquePTR над определенным объектом. И при этом мы можем получить
как L-value, так и R-value. То есть L-value это то, во что можно присваивать значение, R-value это то,
во что нельзя присваивать значение. То есть в принципе чем особен как раз язык C++,
что в нем можно разные интересные инструкции писать. Вот, такая интересная вещь. Значит,
это что касается вот классического, классической парадигмы. А сейчас мы перейдем к некоторым
перпендикулярным парадигмам, которые на самом деле сейчас изменили современный веб,
современную веб-разработку. Это реактивное программирование. Да, в том числе через нее
происходит динамическая генерация страниц. Значит, суть в следующем, что наша цель стоит в следующем,
что как только мы изменили данные на входе, мы должны перезапустить триггер на изменение данных
на выходе. То есть смотрите, за течение времени у нас есть какое-то событие, которое изменяет,
допустим, данные нашей формы. То есть представим себе, что у нас возникло какое-то новое поле.
У нас возникло какое-то поле, да, ну то есть при нажатии клика к нам приехали новые данные,
и мы как раз получаем этот ответ и обновляем наш графический интерфейс на лету. Вот,
давайте вопрос. Как вы думаете, какой инструмент поддерживает реативную парадигму, сказать,
нативно? Это его важная особенность. Нет, JavaScript немножко по другой парадигме работает. Она работает
больше по событийной парадигме. Нет, Django это прям модуль view-контроллер. Шутки шутками,
но сейчас я кое-что сделаю.
Да, это Excel. Пишем один, пишем два, пишем три, пишем четыре. Дальше делаем, я извините,
с этим. Теперь смотрите, вот у нас, а как тут шрифт увеличить? А, зум нашел. Теперь смотрите,
вот у нас функция есть, один плюс два плюс три плюс четыре равняется десять. Теперь мы меняем
значение с четверки среднички на пятерке, у нас меняется значение. Меняем значение, получаем новое
значение. Вот это как раз пример того, как работает реактивная парадигма. Да, согласен. На самом деле,
смотрите, здесь особенность в том, что реактивное программирование это часть, я читал вчера
действительно всякие разные вещи, когда готовился к лекции, и они говорят, что реактивное
программирование это подмножество событийного программирования. То есть как раз вы описываете
сейчас аспект событийного программирования. То есть у нас прилетает какое-то событие, именно это
событие начинаем вешать, ограничить, вешать какие-то изменения. И вообще все современные как раз
фреймворки, они так или иначе поддерживают эту реактивную парадигму. Давайте как раз посмотрим,
что это за фреймворки. Значит, кем образом они работают. Значит, примеры Excel и библиотеки
семейства Rx. То есть это именно, прям выделили отдельные семейства библиотек, которые работают
именно в такой парадигме. Значит, здесь мы говорим следующее, что обычно есть два классических
примера. Первое это Rx.java, который используется и в андроиде, то есть для того, чтобы обрабатывать
события. И второе это Rx.js, при помощи которого используются все фреймворки. То есть, в принципе,
наверное давайте рубрику эксперимент. Мы пойдем посмотрим package.json. То есть когда мы говорим про
JavaScript. Ну, собственно, о чем нужно говорить? В зависимости от пакетов, несмотря на то,
что написано это все на фреймворке Angular, видите под капотом стоит Rx.js. То есть для того,
чтобы как раз динамически обрабатывать события при изменении данных. Ну и, собственно, как это
пишется, допустим. Господи, я сейчас попытаюсь найти это.
Так, давайте сделаем вот так.
Вот пример. Парадигма называется ngif. Вот видите форма? То есть мы прямо в язык
программирования, мы прямо в код вставляем вот такую вещь, что вот у нас есть некоторый класс,
формочка. Видите? Формочка под названием форма. И мы говорим, что если у нас, когда она отображается
у нас, она у нас отображается в том случае, если у нас не установлен пароль, переменная
password set. Иначе мы ставим success message. То есть как только у нас в данных значение переменной и в
password set будет установлена true, у нас эта форма пропадет и у нас появится success message.
Месседж success, где он у нас? Вот он. Так, success, господи. Вот он, шаблон. То есть у нас после отрисовки
этого поля у нас появится вот это вот поле. Давайте теперь посмотрим, как это работает.
Смотрите, здесь есть форма. Вот она, форма. Вот, это форма смены пароля. Я поставил новый пароль.
Вот, и у меня пропала форма как раз. Правда, нас по идее должны было редиректнуть. Ну,
видимо это... А, это set new password. То есть это меню, когда мы пытаемся восстановить пароль. Вот,
он дальше написано, что оно меняет на поле, где у вас пароль установлен. Да, пожалуйста,
зайдите на страницу логина. То есть идет подмена форм в реактивном виде. Вот,
и это основная вещь. Значит, и вот пример, собственно, который здесь есть, в каком стиле это
можно написать, это можно написать и в функциональном стиле. То есть вот этот пример как раз у нас есть.
У нас создается объект типа observable, элемент. То есть у нас есть некоторый список ops1,
ops2. Список наблюдений. Да, то есть над объектом. А дальше мы говорим следующее, что давайте мы
смёржим эти два объекта. То есть они у нас будут лететь. Вот эти два стрима, которые у нас летят.
Дальше мы отфильтруем значение, которое меньше чем 4. После этого применим функцию map, которая будет
менять из и и в и плюс один. И дальше у нас возникает подписка на определенные события. То есть это
даже больше уже событийная история. То есть у нас получается, что по факту будут печататься только те
элементы, которые у нас получаются меньше чем 4, и к ним прибавляется значение 1. И в итоге мы получаем
подписку на наши события. Так, это понятная штука, что по факту мы можем работать именно в такой
парадизме. Что у нас есть труба, в которую грузят данные, изменения данных. А дальше мы после изменения
данных их устанавливаем в какой-то момент времени. Так, ну хорошо. Значит и здесь нам нужно будет,
опять же, остановиться и понять, что у нас с вами здесь есть некоторый объект типа observable. У нас
есть какая-то подписка на события. Это значит, что у нас должен быть новый паттерн. Ну собственно,
как это реализовывать? Нам надо понять. Значит, для этого как раз используется паттерн Observer. Его
вообще много как пишут. Это либо Observer, либо Publisher-Subscriber, либо Event Emitter. В общем,
у него есть большое количество разнообразных определений, но важно в целом суть. Значит,
цель этого паттерна будет состоять в том, что одним предоставить возможность подписки на какое-то
событие, другим предоставить возможность отправлять подписчикам сведения о совершаемых изменениях. То
есть, мы присылаем и совершаем изменения, и дальше мы делаем некоторые результаты. Вот.
Реализация паттерна достаточно простая. Значит, у нас есть с вами Subject, у которого есть, значит,
метод обновления всех полей, view. Вот. И мы можем установить какое-то значение для всех подписчиков.
То есть, дальше, что у нас у этого субъекта есть? У нас есть у этого субъекта список всех
подписчиков на событие, и дальше каждый из обсерверов пытается получить как раз состояние
нашего субъекта и обновить состояние в связи с этого обновления. То есть, таким образом работает
push-уведомление. Да, то есть, мы по факту говорим, пожалуйста, что мы хотим отправить всем необходимым
клиентам некоторое push-уведомление через определенный канал связи. Значит, а дальше у вас как
раз у вас стоит обработчик. У каждого клиента. Принимать это push-уведомление или нет. То есть,
если у вас это push-уведомление запрещено в настройках, то вам ничего не работает. То есть,
у вас это уведомление появляется. А если нет, то вам приходит уведомление. Кстати, в некоторые
моменты времени, ну, то есть, сразу скажу, что push-уведомление это вещь как хорошая, так и плохая,
потому что на самом деле один из способов как раз рассылки данных, зачастую, это отправка
push-уведомлений. То есть, она проходит по отдельному протоколу связи, поэтому она может прислать
некоторые метаданные, которые можно использовать. Ну, такая отсылка, что Telegram работал несколько
лет назад благодаря push-уведомлению в нашей стране. Вот. Значит, каким образом это можно применять?
Первое, это что у нас неизвестна реакция на события, которые у нас есть. И, возможно, что у нас
некоторые люди по-разному наблюдают, используют наблюдение на сервисе. Ну, вы, наверное, уже
знаете, что бывает такое, что вам говорят, пожалуйста, нажмите на колокольчик для того, чтобы это видео
до вас доходило в первую очередь. А, собственно, вы меняете способ приоритета отправки уведомлений.
То есть, в первую очередь будут рассылаться темы, у кого колокольчик, а вторую, с точки зрения, темы,
у кого нет этого колокольчика. Ну, и с колокольчиками есть проблемы, и это недостаток паттерны. Какая
проблема есть с уведомлениями на ютубе? Обычные блогеры любят жаловаться на эту тему. Не доходят,
уведомления могут не дойти. То есть, во-первых, возможна задержка, во-вторых, уведомления могут
не дойти. И, значит, более того, подписчики могут оповещаться в случайном порядке. Но, в принципе,
мы это можем решить, если мы зададим приоритет наших подписок. Так, давайте я покажу пример.
По-моему, он у нас есть. Так, Observer. Да, есть. Значит, здесь все в одном файле. Итак, смотрите,
что у нас здесь есть. У нас здесь есть следующая вещь. Здесь очень простой механизм. Значит,
у нас есть хранение сообщений. Это, кстати, базовая реализация очереди сообщений. И у нас есть мир.
Да, тут переменные однобуквенные, к сожалению. Надо это исправить. Значит, у нас есть хранение
сообщений. То есть, у нас как раз есть мир и есть отдельные существа для хранения сообщений. То
есть, у нас по факту здесь реализован pattern-мост в какой-то степени. Пользуем композицию. Дальше у
нас есть Editor и есть Listener. Значит, дальше мы делаем следующее. У нас мир. Мы подписываем игрока
P1 на события во всем мире. И подписываем игрока на события во втором мире. При этом у нас Editor
начинает читать сообщения, а T2 начинает писать сообщения. Т2 начинает писать сообщения T1.
Собственно, значит, что делает process message? Он делает пока while true и мы указываем,
к какому игроку мы отправляем сообщения. То есть, представь себе, что у нас будет чат. И у нас P2
будет отправлять P1 по первому сообщению в чат. А когда мы делаем подписку на события, то мы
добавляем наших игроков в чат. И дальше у нас как раз что происходит? Когда у нас один товарищ
отправляет сообщения, смотрите, плеер отправляет сообщения определенному миру, он отправляет
сообщения как раз во всю историю. Он отправляет сообщения во все место. Единственное, что здесь
нужно сделать так, чтобы сообщения шли в правильном порядке, поэтому здесь идет некоторый примитив
синхронизации. В общем, для того, чтобы у нас один поток не заходил, два потока параллельно не
заходили в эту инструкцию. То есть, для того, чтобы сообщения рассылались всем подряд. Давайте как раз
я, наверное, возьму прямо этот пример и его скомпилирую. По ходу дела.
Кто лисенер, кто эдитер. Вот, эдитер, потому что мы его подключаем на функцию отправки сообщений,
а остальные будут как раз получать сообщения. То есть, получается, мы подключаем отдельный поток
на отправку. О, ошибка линковки. Надо не забывать линковать билетеку с PSRED. Вот, то есть, у нас
получается вот, вот у нас идет отправка сообщений, у нас есть push message, вот, и дальше у нас в отдельном
потоке у нас висит сообщение именно, чтобы мы получаем это сообщение. Понятно, что мы их могли,
допустим, директивно поменять, то есть, отправить его в другое место. То есть, здесь по факту нужно
было бы написать следующее, что это не классическая реализация, а именно, там,
да, тут лучше было бы написать, что мы отправляем сообщение от определенного игрока и вызвать
функцию игрока как раз, что мы можем прочитать сообщение. То есть, это не идеальный пример,
конечно. То есть, как его как раз допиливать, так я остановлю. Вот-вот сюда нужно именно
чтение сообщений, то есть, хранение сообщений должно отправляться к определенному игроку. То есть,
то есть, что-нибудь типа вот функции void read, вот, и именно через нее отправляет сообщение. Ладно,
это я, наверное, добавлю тогда обновленный пример, посмотрите это, как он реализуется. Просто здесь
у нас у всех игроков возникает бра-отказ на весь мир, просто мы подключились как раз к текущему
игроку. Если бы у нас было несколько игроков, был бы бра-отказ на несколько игроков. Немножко допилить
этот пример надо мне, я это сделаю. То есть, по факту, все, что у нас работает в мире сейчас,
это на системе паблишер, на системе подписок. Давайте я спрошу, понятно ли суть этого паттерна?
То есть, одни отправляют сообщения, другие их получают. Кстати, вопрос, как вы думаете,
кого больше, отправителей или получателей в мире? Да, получателей, причем в разы больше. Ну и всегда
запоминаем, что операции на запись у нас обычно намного меньше, чем операции на чтение. На порядке.
И как раз благодаря этому можно и проектировать архитектуру наших приложений. Так, следующая
парадигма это обобщение реактивного программирования, это событийное программирование. Что такое event?
Тут надо вести понятие. Event это значимое событие, которое возникает в программной среде. И на эти
сообщения необходимо каким-то образом реагировать. Более того, некоторые события, к сожалению,
мы с вами даже перехватить не сможем. Это особенности операционной системы устроено так. То есть,
какие виды событий у нас с вами есть? У нас есть виды системных событий, которые передают,
виды событий, это системные события, которые передаются через ядро с операционной системы,
прямо нам прилетают. И есть пользовательские события, которые создаются пользователями через
объект EventEmitter, то есть именно класс, который умеет отправлять определенные события. Значит,
в качестве системных событий давайте я приведу пример. Я правда сейчас опять же могу сильно,
я создам окружение и создам. Вот оно. Мы находимся в событии и здесь мы можем выполнить отправку
определенного системного события, на которое мы даже не сможем отреагировать. Команда Kill.
Давайте поймем, что она делает. Ответ неверный. А? Нет. Нет. Она отправляет сигнал. Она отправляет
события под названием сигнал другому процессу. Правда сигналы бывают разные. Некоторые срабатывают,
некоторые не срабатывают. Давайте мы попробуем эксперимент.
Видите, набор единичек у нас. Так, смотрите. Если мы откроем сейчас HOTOP.
Вот. И смотрите, здесь есть как раз F9 Kill.
Теперь повторю в другом процессе, чтобы вы поняли, что произошло. Мы повторяем эту инструкцию
и отправляем сигнал под номером 2. Поведение ровно такое же, если бы мы нажали на клавишу
CTRL-C. Это называется interrupt-сигнал. То есть мы отправляем сигнал, который позволяет нам
прервать исполнение. По умолчанию, кстати, любой процесс может принять событие обработки сигнала.
Кроме, есть два сигнала, которые не перехватываются. Можете посмотреть,
какой из них является вторым, а первый следующий. Этот сигнал не перехватывается под номером 9.
Это нужно для экстренной остановки процесса. Вот такие системные события бывают. Понятно,
что есть еще другие системные события. То есть, допустим, можно посмотреть, изменились ли файлы
в определенной директории, можно подписываться на такие события. Это системные события. Значит,
есть пользовательские события, которые создаются пользовательными. Так, понятно, что я пока... Да.
Можно еще раз про перехват сигнала. То есть мы можем его проигнорировать? Да, да, да. То есть можно как раз посмотреть.
Модуль сигнал, в нем как раз можно написать функцию, которая будет делать некоторые действия. Допустим,
бывает такое, что вы хотите остановить какой-то процесс, но вам нужно сохранить данные,
которые у вас были в этом процессе. Тогда вы делаете следующее. Вы пишете некоторый обработчик,
который говорит, что если вы не нажмете на кнопку в течение какого-то момента времени,
то мы остановим ваш процесс. Иначе мы продолжим работу. Давайте далеко ходить. Все видели
Джупитер ноутбук? Ух, е-мое. Вот, у нас ноутбук. Видите, смотрите, и написано, что use ctrl-c to stop server and
shutdown on kernels. Я нажимаю на ctrl-c и, видите, у меня возникает вот такая плашка. Видите,
я не обработал событие в течение пяти секунд, значит оно продолжает работать с операцией.
То есть как раз стоит сигнал-хендлер. То есть там можно установить тип сигнала и сказать функцию
обработчика. Про это будут говорить на курсе операционных систем, как это делать. Поэтому я
просто скажу, что вот такие события у нас действительно существуют. Так, двигаемся дальше.
Значит, двигаемся дальше. Один из важных как раз механизмов работы с событиями это event loop.
Значит, у нас есть некоторые, мы накапливаем некоторые стэк вызова функций и у нас функции
могут разделиться на несколько основных частей. Это именно для веб-программирования работает,
но в принципе работает и для других вещей. Значит, смотрите, когда мы работаем с вами в браузере,
у нас есть несколько, некоторый набор вещей. У нас могут быть некоторые задачи, которые мы с
вами отправляем. Есть некоторые микро задачи, которые мы по факту должны обработать достаточно
быстро. То есть это маленькие задачи, которые просто проверяют, допустим, готов ли у вас какой-то
результат. То есть если мы говорим с вами про chain of responsibility, нам же нужно по цепочке передать
результат выполнения функции. Собственно, готов ли результат выполнения нашей функции для того,
что мы его помогли передать по цепочке в следующее событие. Значит, дальше, если мы говорим про
классические задачи, это может быть установка тайм-аутов или интервалов. То есть мы ставим
событие о том, что у вас какое-то окно, какое-то событие должно пройти через какой-то промежуток
времени. Через секунду, через две, через три. То есть вы сами ставите событие, которое вы можете
потом обработать. То есть у вас, допустим, загорелась плашка, у вас загорелась плашка на 10 секунд.
И есть информация про рендер, то есть каким образом мы отрисовываем наш объект. Тут в браузере
тоже можно попробовать посмотреть, как можно поставить события. Функции обычно называют set
timeout и set interval. И, собственно, у нас есть отдельный цикл, который у нас как раз вращается и
позволяет обрабатывать задачи. То есть все вот эти вот истории, связанные с ассинхронным
программированием, зачастую реализуются через event loop. То есть создается цикл, в котором мы
начинаем обрабатывать события. В том числе в питоне, если вы посмотрите на любое событие,
то на любое ассинхронное программирование вам тоже там будут создавать event loop, в котором вы
начинаете обрабатывать задачи. И у вас возникает эфемерность многопоточности, хотя на самом деле
там никакой многопоточности нет. Мы просто грамотно обрабатываем микрозадачами. И вот как раз
вот по созданию вот таких вот event loop плюс еще квантовости времени внутри центральных процессоров,
как устроено центральный процессор, у нас на самом деле возникает у каждого потока кванты
времени, в течение которых он выполняет какой-то процесс. После этого мы можем переключиться на
другой поток, и он тоже будет выполнять процесс в определенный квант времени. И в итоге у нас
возникает иллюзия многопоточной системы, иллюзия многозадачности. Хотя на самом деле мы работаем
в одном ядре. Какие библиотеки позволяют реализовывать event loop? На самом деле их много,
и они так или иначе работают. Первая из классических реализаций, это самый низкий уровень
библиотека, это libUV для C++, она достаточно большая. Более того, веб-твишки в браузерах работают
на libUV под капотом. Второе это Async.io, это библиотека для синхронного программирования в Python,
и она тоже внутри себя создает event loop. И третье это Qt. В чем особенность Qt? В нем есть как раз
события, они называют сигналы. Вы можете отправить какое-то событие и к этому сигналу привязать
слот. То есть какая функция должна быть выполнена в другом объекте при наступлении определенного
события. То есть реагировать на кнопки. На то, что кто-то нажал кнопку, на то, что кто-то закрыл окно,
кто-то убрал фокус с определенной вкладки в браузере. В общем, это можно как раз реализовать
при помощи таких библиотек. На самом деле вы с event loop встречаетесь достаточно часто. Даже вот
сейчас есть какой-то event loop скорее всего, который нам позволяет получить информацию. Так, давайте
вопрос по вот этому слайду. Опять же понятно, что это больше части на будущее, затравка. Но в целом
вы теперь понимаете, что если вам нужно реал тайм-игру реализовать, то вам сюда. Поэтому мы не
требовали реализовать real-time-игры, потому что это сложно. Хорошо. Значит, собственно, в чем у нас
отличаются реактивные событийные программирования? Реактивное программирование обычно работает на
изменения данных, событийные на на обработку каких-то созданных событий. В нем отличие. Теперь давайте,
это все, что касается парадигмопрограммирования. Давайте перейдем немножко к другим аспектам
языков программирования. Вкратце их вспомним. Как раз на 10 минут. Значит, у нас есть компиляция и
интерпретация. Кто может сказать, что такое компиляция? У кого есть какие мысли? Да, это это
частное определение. На самом деле, если говорить честно, то с одной точки зрения, компилятор это
язык, который транслирует наш текст в другой язык. Зачастую это машинный код, но при этом это может
быть произвольный язык программирования. То есть оно может трансформировать код из одного языка
программирования в другой. Примером того является TypeScript, который трансформирует наш код из TypeScript
в JavaScript. При этом у нас могут быть трансляции именно в машинный код, в какие части машинного кода
это может быть. Это может быть либо, собственно, исполняемый уже файл. Давайте вспомним языки
программирования, которые транслируют все в исполняемый файл. В машинный код именно. C, C++, Go.
Нет, Java не исполняемый файл транслирует. Ну окей. А есть еще промежуточная вещь. У нас есть как
раз виртуальная машина, в которой мы выполняем наши действия. Это как раз Java. Что касается других
языков? Это интерпретируемый язык. Интерпетатор выполняет команды текста программы по очереди.
То есть мы как раз задаем инструкции и дальше мы задаем инструкции, которые мы выполняем по очереди.
Важно сказать, что иногда мы можем использовать не чистую интерпретацию, а мы можем использовать
трансляцию в промежуточное исполнение, в bytecode. И дальше интерпретировать этот bytecode. Таким
образом работает Python, допустим. В третьем точно уже было. Модуль дезассомблирования там появился.
Вот, значит здесь как раз есть пример того, как это все работает. То есть компилируемые языки это
CC++, Pascal, Go. Она трансформирует машинный код в Java, Scala, Kotlin, C Sharp. Сразу скажу, что Scala,
Kotlin и Java это одного поля ягода. Они транслируют JVM. C Sharp тоже на самом деле транслирует это в
виртуальную машину Винды. Интерпретируемые языки это Python и JavaScript. Они являются интерпретируемыми
по сути. А есть языки программирования, которые являются хитрыми. Они могут работать как в
интерпретируемой основе, так и в компилируемой основе. Если мы говорим про язык Basic, то в нем так
это происходит. А в языке R происходит чудеса. В общем в чем заключаются чудеса? В нем есть два
факта. Первое это сборка пакетов. Вы устанавливаете какой-то пакет. А второе это вы запускаете какой-то
код. Так вот, когда вы запускаете какой-то код, вы его интерпретируете. А когда вы собираете
проект какой-то, когда вы собираете ваши функции, набор в отдельную библиотеку, вы компилируете
эту библиотеку. Причем компилируете C с примочками. Когда вы делаете компиляцию, то есть когда вам
нужно запустить какой-то код на R, вы не можете пройтись с дебаггером в определенное место точку
проекта. То есть вам нужно включать как раз дебагг ключи для того, чтобы собрать этот проект.
Вот, ну R это вообще замечательный язык. Давайте сейчас время останется, я про него немножко
порассказываю. Какой? Ну по факту да. Ну просто у нас последуются инструкции, которые нам надо
выполнять. Вот. Так, хорошо. Про языки программирования я думаю понятно. Дальше,
какая типизация существует? Статическая и динамическая. Статический тип переменной я известен
до момента выполнения программы. Вот, динамическая тип переменной определяется по ходу выполнения
программы. Вот. И как раз мы говорим следующее, что, собственно, давайте приведем примеры языков
со статической и динамической. Да, много языков статической типизации. Да, а с динамической
типизации? Ну скорее даже джовескрип. Питоне у нас. Ну да, да, да. Все, да, согласен, что Питон 4,
который неизвестно будет еще или нет. Но в принципе Питон можно превратить как раз в статический язык,
по большей части. По-моему, Никифор нам в чате присылал код на Пайдантик написанный. Вот,
Пайдантик как раз включает статическую типизацию, когда он этот скрапер вариантов контрольной
прислал. Ой, скрапер результатов работы написал. Вот. И есть еще одна интересная вещь, это сильная
строгая типизация и слабая типизация. Значит, сильная типизация это мы берем a равно 5, b равно
name и дальше a присваиваем значение b, получаем ошибку, потому что у нас тип переменной уже
известен и мы его не можем конвертировать. А слабая типизация это a равно 5, b равно name,
складываем a плюс b, получаем 5 name. Давайте попробуем привести языки с слабой типизации. Да,
это и есть джовескрипт. То есть он неявно умеет кастовать типа. Опять же, тут надо посмотреть,
какие у нас в языке реально могут быть, так сказать, отголоски с точки зрения слабой типизации,
но они там обычно ограничены каким-то свойствам. То есть нам нужно переопределять операторы,
которые позволят нам менять эту типизацию. Так, это по-моему. А, вот еще последнее есть,
явная типизация и неявная типизация. Мы в C++ устанавливаем определенные значения,
и у нас видно, что явно, что тип переменной a это типа int. Есть неявная типизация, это Python,
где можно написать a двоеточие float или string равно 5, и при этом у нас типы не будут соблюдаться.
Так, это, кажется, конец презентации. Что? Расскажите вам немножко про Rast. Ой, про R.
Ну, про Rast, к сожалению, не расскажу, но про R расскажу. Это вообще чудо-язык в кавычках.
Байк стоит в том, как вы привыкли обращаться к переменным. Точнее, к полям и методам класса.
Точкой, да, то есть это ключевое слово. Я не знаю, почему, но если какой-то человек увидит код на R,
он скажет, что он всячески нарушает закон Demetri. Почему? Закон Demetri. Это на первой лекции,
когда мы говорили, что a является другом b, b является другом c, значит a не является другом c.
Смотрите, вот такой код. Как мы это прочитали в языке c++, c и c++ и так далее? У нас есть экземпляр
foo. Дальше у него есть volle var, volle van. Ну да, это мы так прочитали в c++. Var это читается как
переменная, которая имя foo.var.van.front. Это просто кардинально нарушает концепцию других языков
программирования. И здесь еще есть одна важная вещь, что в языке R это надо писать вот так.
Ну не знаю. Специфика, так сказать. Вот какая еще есть специфика в языках? Ну, в принципе,
она тоже бывает. В современных языках можно создавать иммутабельные объекты. В разных
языках, если мы говорим про те объекты, которые не меняются, и если мы ставим значение, по факту мы
перезатираем объект, бывает иммутабельный объект. Смотрите, если мы говорим про R, то там есть два
оператора, равно и стрелочка. Собственно, равно создает иммутабельный объект, стрелочка создает
иммутабельный объект. И в других языках тоже есть такие именно объекты. То есть обычно они
дают модификатор const. То есть если мы говорим про JavaScript, то там есть led, есть const, а есть var.
Значит, что делает var? Var создает глобальную переменную, led создает локальную переменную,
а const создает константу, которая в дальнейшем меняться не может. То есть, а здесь именно нету
возможности создать иммутабельного объекта, который мы можем переписать var. Это есть возможность.
Мощно. Собственно, давайте просуммируем. Я рассказал про языки программирования, некоторые
вводные вещи. Понятно, что в этой стезе можно развиваться, можно даже записать компиляторы.
Значит, что у нас будет в следующий раз? В следующий раз у нас по фактическому расписанию будет
контрольная. Возможно, я предзапишу какую-нибудь лекцию интересную, уже связанную с, так сказать,
какими-то более крутыми особенностями, которые мы не можем рассмотреть. А не забываем, что 15
мая все-таки лекция будет, но она будет дополнительной. Постараемся сделать. Ну,
я думаю, на этом все. Если вопросов есть, то задавайте.
