Ну что, молодые люди, по запросам трудящихся будет
рассказ у нас про макросы, просто отвратительные.
Все эти макросы тоже просто отвратительные.
Это как Некрономикон прочитать, обратно уже не вернуться.
Если вы готовы, то мы пойдём.
Наверное, все мы должны знать, что такое препроцессор.
Но это не так.
Мы вообще не знаем ничего про препроцессор.
Вам только кажется, что подставляем, и всё работает.
Сейчас будет слайдов 20 про то, как он работает.
Ну, значит, define есть.
Define macros, вот такие макросы без круглых скобок.
О, четвёртый человек пришёл.
Ура!
Макрос без скобок называется объектным, а со скобочками функциональным.
Сначала с объектными макросами разберёмся.
Начинаем идти слева направо.
Понятно, что он по строкам идёт, отдельно и независимо.
Это препроцессор.
Каждую строку он начинает идти слева направо, под токеном.
Токены, я думаю, примерно представляем, что такое.
Тут детали не так важные.
Всё, что не идентификатор, мы тупо пропускаем.
Знак плюс, а это знак плюс, и не идентификатор пропустили.
X, он идентификатор.
Дальше начинается что-то странное.
Вот он не синий здесь.
Я думаю, вы согласны, что вот это красное не синий,
поэтому мы просто идём дальше.
Но это также не макрос.
Вот нету никакого макроса, который типа define X.
Поэтому мы просто его пропускаем.
А вот на токене объект мы уже увидим, что он таки макрос.
А дальше есть условие, что нет некоторого дизайблинг-контекста.
Это вот DC будем называть дальше.
Тоже пока непонятно, что такое, но вот две важные мысли.
Чтобы всё у нас шло дальше хорошо,
и подстановка произошла, нужно, чтобы не было синего цвета,
где его сейчас нет, не было дизайблинг-контекстов.
А макрос объектный, поэтому там простые правила.
Просто берём и подставляем.
Ну, тут ещё есть кое-что, всякие решётка токен в макросах.
Знаете про такое?
Остальные.
Ну, сейчас увидим во всяком случае.
Там две решётки ещё есть, чтобы конкатонацию делать.
Но тут всего этого нет, поэтому мы просто подставляем.
1, 2, 3.
И никуда дальше не идём.
Вот это ключевое.
Мы остаёмся на том же токене,
но при этом создали object-DC,
то есть дизайблинг-контекст для макроса-обжекта.
Ну, я думаю, по названию уже понятно, что эта шняга говорит о том,
что больше в рамках вот этого вот интервала токенов
раскрывать макрос-обжекта нельзя.
Ну, понятно, что это нужно, чтобы не было рекурсии, правда?
То есть если мы определили object-object?
Да.
То вот этот дизайблинг-контекст бы сказал, второй раз раскрывать уже не надо.
Поэтому мы...
Ну, у нас тут не object-object, у нас тут 1, 2, 3.
Это не идентификатор.
Соответственно, вот теперь мы можем идти дальше.
И так как мы вышли за рамки дизайблинг-контекста полностью,
и больше нам ничего не интересно, что раньше было,
мы его выкидываем.
Ну и последнее, тоже не идентификатор, скипаем.
Окей.
Пока не очень сложно.
Сейчас будет чуть сложнее.
Вот как object-object, только, ну, object-object, очевидно уже, что не работает.
Давайте вот define-им A как B, а B как A.
Вдруг сейчас получится?
Ну, вот такая последовательствия, звездочка.
А это объектный макрос, ничего там нету,
что мы проговаривали не синий, не дизайлинг-контекстов.
Ой.
Уберись.
Иди.
Так, поэтому мы просто его подставляем.
Подставляем, получили B.
Дизайблинг-контекст на A висит.
Ну, мы все еще здесь.
Видим B, это объектный макрос.
Надо его подставить.
Получили вот такую конструкцию,
где теперь A лежит внутри.
Да, у нас только A, и оно вокруг обернуто в дизайблинг-контексте для B,
и все вокруг в дизайблинг-контексте для A.
И вот когда мы обнаружили A внутри дизайблинг-контекста для самого же A,
мы покрасим в синий этот токен A,
а все синие токены мы просто пропускаем.
То есть, тут такая конструкция будет.
Вот.
И вот эта синяя краска достаточно долго на самом деле живет.
Она просто никогда не исчезает, насколько я помню.
И вот тут был простой кейс, что покрасили в синий, и уже сразу ушли.
Но могло быть хуже, могло быть, что мы там заново это пройдемся по всей этой последовательности по тем или иным причинам.
Эта синяя краска, она останется.
И больше не позволит нам этот A раскрывать.
Вот. Какая-то такая процедура.
Теперь с функциональными макросами надо.
Функциональный макрос.
Следующий токен — это его инвокация,
потому что если токена открывающей скобки нет, то мы его оставим, как есть.
Видим в некоторой табличке, которая в компиляторе хранится, информацию про макросы.
Что вот был такой макрос функциональный объявлен, и у него нету аргументов.
Он нулярный, так что мы смотрим, чтобы дальше была закрывающая круглая скобка.
Если ее не найдется, мы идем дальше без изменений.
По-моему, так.
Или могу соврать.
Забудьте, что я сейчас сказал.
Раскрываем.
Но вот тут раскрытие уже идет с вот этими вот приколами.
Раскрываются все конкотинации внутри этого макроса.
То есть вы могли просто даже, несмотря на то, что у вас нет аргументов,
взять и написать конкотинацию каких-то токенов,
и вам плюсы слепят эти токены вместе, и будет один токен.
И вот как только...
Да, и причем это раскрытие, оно происходит до подстановки.
То есть мы как бы отдельно, виртуально смотрим вот в эту часть,
и вот здесь все сконкотинируем, и только потом уже подставляем на место.
И получится вот это.
Давайте еще раз поупражняемся.
Тот же самый прикол с А и Б, но функциональные макросы теперь.
Ну да, слайдов нету.
Но я думаю понятно, что работать будет примерно так же.
Все просто будет полностью подставляться, и все будет работать.
А вот интереснее вот так.
Видите, что происходит?
Ну вот мы подставляем вместо А Б, и получаем вот такую штуку.
Одну скобку сожрали вместе с А, и получили дизейблинг-контекст на А.
Казалось бы, ну окей, теперь есть вот такой вот вызов Б.
Его тоже надо подставить.
Но мы возьмем и подставим.
Но после этого пропадет дизейблинг-контекст на А.
К чему-то.
Ну, строгой причиной я объяснить не могу.
Потому что тут происходит магия.
Но интуитивная причина в том, что новый вызов инвокации, так называемая макрос,
Б, круглые скобки, она не полностью лежала внутри дизейблинг-контекста А.
Так как мы не полностью были внутри ДЦА, мы старые ДЦ просто выкидываем,
стоимся только с ДЦ на Б.
Ну и можно опять А раскрыть.
И опять раскроем.
И в конце-то, когда идем до Б, уже без скобок.
И вот он уже будет покрашен синий.
Какая мораль?
Вот А круглые скобки.
А Б все покрашен синий и больше нечего раскрывать.
Вот мы его не можем раскрыть, потому что скобок нет, действительно.
Давай считать, что да.
Я не помню.
Можно открыть сейчас подробное объяснение с почтовой рассылки какого-то 90-го года,
где мужик, который пишет при процессе РС, все это объясняет в деталях.
Ну судя по тому, что я на слайдах сделал вот так, наверное, все-таки действительно получается так,
что если мы увидели макрос, скобок нет, но он в дизейблинг-контексте,
то мы покрасим его синий.
Он в дизейблинг-контексте А, нет?
Значит, я немного соврал.
Значит, дизейблинг-контекст Б он как-то остается.
Да, ну вот, видимо, я в этом месте соврал, что дизейблинг-контекст А выкидывается.
Он не то чтобы выкидывается, он просто не влияет на это.
Или дизейблинг-контекст А со скобочек.
Ну да, дизейблинг-контекст был у нас на первом токене.
И как бы после того, как такая подстановка произошла...
В смысле, неправильно описано А, Д, С, а можно А, скобочки, Д, С?
Нет, нет.
Дизейблинг-контекста это типа...
Фактически что это такое?
Это два индекса, начиная с какого токена и по какой.
И макрос, прямо вот его название.
Вот либо А, либо Б.
То есть тут вот именно так, и видимо смысл в том, что у нас при подстановке Б
как бы вот этот дизейблинг-контекст на А, он остается только на вот эту А.
Но инвокация вся вместе, она там не влазит в дизейблинг-контекст.
Ну, что-то такое.
Они могут быть функциональными объектами?
Нет.
Каждый макрос он один, уникальный, никакой перегрузки.
Нет, ничего такого нет.
Ну вот, тут происходит какая-то...
Они перезаписывают, да?
Нет, если ты два раза Defina сделаешь, то у тебя будет ошибка.
Нужно сначала Undef сделать, чтобы старые объявления убрать.
Потом новое можно уже сделать.
Но тут мутно все.
Мутно.
Я не смогу сейчас вот за эту одну лекцию полностью вам рассказать.
Так, чтобы у вас в голове модель была, и которую вы могли в голове раскрывать эти макросы.
Отлично.
Поэтому я вас мотивирую прочитать про это смостоятельно.
Если то, что будет дальше, вам покажется полезным хоть сколько-то в вашей практике.
Но вот как факт, здесь есть вот эти лютые механизмы с дизейблинг-контекстами и синей краской.
Вот они нужны, чтобы не было рекурсии, и мы при процессоре не зацикливались навечно.
Ну и опять же, как факт с неба, вот такая конструкция работает.
Все эти синие краски, дизейблинг-контексты, они не запрещают этого.
Просто оно так получается.
В частности, объяснение на сайтике и в почтовой рассылке, которое плотно читал,
оно вот про это очень акцентировало внимание, что вот эта вот инвокация, она не вложена в это.
Там есть понятие географикали-нестинг.
Не знаю, где здесь географию они нашли.
Но когда вот такое происходит, у нас как бы дизейблинг-контексты перестают работать.
Ну и можно поверить, что в целом вся вот эта конструкция работает и не вырубается
после первых двух раскрытий, ровно из-за того, что вот этого и это не вложено.
А может, я и на самом деле соврал, что здесь синие красится,
и в этом все проблемы, и на самом деле все просто.
Предлагаю это пропустить, можно потом вернуться в конце и посмотреть этот mailing list.
Внутри defi надо добавляться скобки?
Внутри defi надо добавляться скобки.
Написать сюда сами скобки мы можем, да.
И они будут раскрываться или...
Если там очень скобки, то они не раскроются, потому что они будут полностью лежать в децентре.
Отличное замечание делаешь.
Предлагаю это проверить.
Как мы будем эту фигню проверять?
Мы будем...
Да нет, ну можно с минус E, я сейчас попроще сделаю.
Не спрашивайте, что я сейчас пишу, надо.
Ну вот и пошли.
Define A, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E.
так, ну вот и пошли defineA,B, defineB,A и попробуем сделать
спаут, принт, от, что мы хотим, вот интересно, что получится. Вообще не стал раскрываться, да?
Давайте вот так для олидации, что у меня вот эта вот херня правильно работает. А, ну вот, видите,
вот это какая-то магия, я ее написал, она работает. Когда мы просто вот такие штуки делаем,
кучу круглых скобок, то да, вот она полностью раскрылась, да, а вот если вот так, если AB впихнуть,
то мы сколько скобок сожрали? Тут было раз, два, три, четыре, пять, шесть, а осталось пять. То есть один
раз мы раскрыли вот эту всю фигню в B, две круглые скобки, да, сейчас А, их должно было быть на столько
же остаться, да, ровно шесть осталось. Потом мы один раз раскрыли B, получилось А и пять круглых
скобок. Ну и, видимо, действительно, вот этот disabling-контекст, он как бы получился длиннее. Когда
мы вот эту штуку раскрывали, она раскрылась вот в это, и вся эта шняга попала в disabling-контекст,
и типа и длина его было три символа, и тут она осталась три символа. Вот, то есть, видимо,
в этом дело. Экспериментально выяснено. А если и Y? Тут уже есть скобки, еще скобки.
Сколько у нас уявилось? Шесть, нет, семь. То есть на первом раскрытии у нас получилось семь скобок,
потому что мы два раза подставили, да. После этого мы решили раскрывать B и раскрыли в А,
ну и есть то же самое. На какой? Вот одни скобки пропали, ну потому что вот так подставилось. Но это
все неважно, потому что disabling-контекст, типа вот такой получился, видимо, пять символов. Все это
в нем, поэтому macros не получилось раскрыть. Вот, ну хорошо, подразобрались. Но это все очень круто,
на самом деле, потому что это позволит нам делать последовательности в при процессоре. Последовательность
это вот такая шняга. Куча скобок друг за другом написаны. Внутри каждых скобок по чему-то. Можно
букву, можно цифру, можно какой-то код на плюсах. А дальше с этими последовательностями можно
творить непотребство. Можно взять и свернуть эту последовательность вот ровно таким алгоритмом,
с как бы A и B, вот такими вот. Тут теперь параметр появился. Мы пока еще не сказали, как эти
параметры работают, но тут, очевидно, они работают. И когда мы вот элементарно напишем A и my macrosec,
вот это вот все, оно как бы тоже начнет раскрываться волшебным образом. Ну, с некоторой оговоркой,
вот просто так, по-моему, не сработает, оговорка будет позже. Ну, пока интуитивно можно представить,
что мы macrosec заменили на вот эти скобки и начали сворачивать. Ну, мы пока так не умеем,
но скоро научимся, чтобы сначала второй подставить, потом первый. Потому что если в тупую начать эта
парсия, то мы пойдем слева направо, увидим функциональный macros A, увидим, что справа токен,
это не скобка, и пропустим, и ничего не произойдет. То есть представим, что мы два раза запустили при
процессорной этой строке просто. Первый раз мой macrosec подставится, а второй раз у нас уже будет A
и куча скобок. И мы вот эти скобки начнем просто раскрывать, раскрывать, раскрывать. Каждый раз вот эти
вот A и B, такая рекурсивная функция, она дописывает то, что пришло в аргументы, в начало, и получается
через пробел A, B, C, D, E. А можно не через пробел, можно через знак плюсика. О, просто написал его сюда.
Прикольно, да? Можно просто взять и какой-то список чего-то взять и вот так вот через запятую написать,
через плюсик. Чем-то фолды напоминает. Но это не единственный способ задавать в каком-то смысле
последовательности при процессоре. Поэтому в конце нужно дописать ноль. Ну, значит, так просто не
прокатывает, да? Тут надо, короче, колдовать. Вот так просто не будет, но давайте пока мне поверим,
что можно вот эту проблему побороть кое-как. Большая буква не исчезнет. Ну, можно с этим...
Можно как-то закостылять, очень легко это. Одновременно объектный и функциональный
макрос нельзя у нас объявить. Просто от буквы избавиться. Короче, ладно, без хитрых фокусов не выйдет,
но вы можете в той точке, где этот код написали, просто взять и написать типа int A равно нулю,
оно тоже сработает, потому что осталось A, ну и осталось. Теперь это не какой-то токен при процессоре,
это перебедное, которое там значение есть. Ну, вот такие штуки можно делать. Конечно,
вот да, правильное замечание про лишнее в конце. Скоро поборем. Вот, теперь надо с аргументами. Тут
есть маленькая деталь, но из которой вытекает масса следствий. Ну, первых, аргументы у нас
разделены только запятыми, и вложенность проверяется только через круглые скобки.
То есть, если вы когда-нибудь пробовали в макрос запихивать стд пейр от int и char через
запятую, то у вас макрос все это распарсит, как стд пейр меньше int, это первый аргумент,
а второй аргумент это char больше, и вот. Это немножко неприятно, но вот такова наша жизнь,
и это надо помнить и иметь в виду. Можешь все в круглые скобки дополнительно обложить. То есть,
вот оно уважает только круглые скобки, поэтому если ты напишешь макрос и два раза круглые скобки,
то это будет один аргумент насильно, а не два аргумента или там больше даже. Теперь вот про
подстановку. Когда у нас функциональный макрос есть аргументы, и происходит подстановка.
Происходит она хитро. Мы сначала раскрываем вот эти вот решеточки с тем, что пришло к нам. То есть,
это конконтанция. Пришел один токен, пришел другой, мы их конконтанировали, получили один.
Потом происходит конверсия в строке. Решетка ARC это взять токен ARC и вот как его препроцессор
видит как последовательность символов. Вот так сделать строковый литерал, то есть в кавычках
написать. А дальше аргументы без всяких решеточек раскрываются. Но раскрываются они хитро.
Да, сейчас тут есть некий прикол. Я вот тут сказал, что они не раскрываются пока. Ни конгодонации,
ни подстановка строк не происходит. Мы только подставляем в текст макроса, в сам текст макроса,
токены, которые снаружи пришли. Вот вы макрос запустили от каких-то строчек токенов, они пришли к
вам внутрь и вы их подставляете сюда-сюда, сначала подставляете и туда, где нет решеток, тоже
подставляете. Прям в тексте макроса, пока обратно не вернулись. И вот этот арг без решеточек,
он рекурсивно сканируется еще раз. То есть заново запускается препроцессор на как бы тексте макроса.
Только самом тексте макроса в изоляции от внешнего мира. Это очень смешной факт. Это,
например, вам подставляет, пусть у вас есть макрос ассерт, знаете же, что ассерт это макрос,
и вы туда подставили m, p. На самом деле, в какой момент m, p раскроется в 3,14? Оно раскроется вот
в этот момент, потому что вы там где-то в ассерте, у вас какой-то код и там где-то вот эти вот аргументы
использованы, которые прислали извне. И так как тут рекурсивное сканирование будет запущено,
у вас это m, p еще до подстановки макрос ассерт обратно заменится на его значение. Сейчас
увидим, какие еще последствия у этого есть. Вот, и только после того, как вот эти рекурсивные
сканирования замечательные произошли, мы конкатенируем и превращаем в строки,
причем с неопределенным порядком. Не уверен, что будет, если ты два раза решетку применишь.
Наверное, оно два раза в кавычке возьмется. А, потому что пробела нет. Две решетки подряд это один токен,
а одна решетка это другой токен. Вот. Прямо на уровне грамматики языка. То есть, если здесь
пробел вляпнуть, то же самое, что равно пробел равно. Вот два равно это вместе. Вот. И только после
всей вот этой вот чехарды, мы вот то, что у нас там наколдовалось внутри макроса, подставляем
обратно в код программы. Вот здесь вот. И создаем дизайвлинг-контекст на этот макрос. Прошу прощения.
Так, надо за временем следить. Ну вот. Да, оно раскрывает дефайны, которые были внутри аргументов,
которые ты передал в этот макрос. Да. Потому что в функциональных есть аргументы. Вот если ты
в эти аргументы передал какие-то другие макросы, то они еще внутри обработки этой подстановки будут
раскрыты. Где? Вот здесь? Нет, смотри, в наших примерах нету никаких аргументов. Наверное,
немножко мутно говорю, поэтому скажу более явно. Вот если есть аргумент х, вот здесь х, и мы как бы
напечатаем там а, круглые скобки, ноль. То вот этот ноль, он как бы просто подставился сейчас, да.
А может это быть другой а. Вот. И вообще-то такое не должно работать, правда? Казалось бы. Потому что
что будет происходить? Мы раскроем а как х, и будет а от нуля. И у нас как бы уже дизайвлинг-контекст.
То есть вот было такое, мы раскрыли первый слой а, и уже дизайвлинг-контекст, и все, мы умерли. Да?
Но это работает, потому что ты не сразу в текст программы подставляешь обратно, а сначала такую
виртуальную программу отдельную компилируешь. Эта виртуальная программа, это как бы вот эта строчка,
вот то, что в Define а написано. Но и там было написано х. Запустили это у нас с х равным вот такой
последовательности токенов. А скобка ноль скобка. Поэтому мы подставляем а скобка ноль скобка еще
внутри как бы макроса. Давайте это. Внутри макроса происходит. И раскрываем, пока без дизайвлинг-контекста.
То есть заново вся эта процедура начинается, и после этого уже мы там подставим в качестве х0.
А после этого мы вот в эту строчку, которую мы обрабатывали на данный момент, результат всей
тысячи хорды, подставим вот этот результат, подставим вместо всего вызова а.
А если в том случае не х, а, а скобка, а скобка и х?
А скобка.
Кинули а скобка и х. Типа еще раз обернусь в а скобка.
Что еще раз?
Еще раз обернусь в а скобка.
Да.
Там же без ка еще остается?
Нет. Потому что дизайвлинг-контекста в какой-то момент появится.
Внутри все поставляется, да?
Ну внутри тоже дизайвлинг-контекста появляется. То есть мы просто рекурсивно запускаем
препроцессор на более маленькой программе. С нуля как бы запускаем препроцессор.
Ну не совсем с нуля, ладно. Но давай попробуем понять, что здесь происходит.
Когда мы первый раз попали внутрь а?
У нас там такой код написан, да?
Но нам в качестве аргумента х выдали что?
А от нуля.
Давай подставим, а от нуля.
Теперь надо вот это вот заново запропроцессить.
Нет, вот нам а от нуля. Вот х был, а от нуля.
Мы его подставили, и теперь заново запускаем препроцессор.
Давайте я буду говорить правильное слово, сканирование.
Ну вот сканирование, это мы сканируем всю строку токенов
и выполняем подстановки препроцессора.
Вот после того, как мы подставили вместо ха вот здесь то, что на самом деле нам прислали,
мы еще как бы внутри вот этого кода а начинаем заново сканировать.
Идем сканируем.
Ну вот у нас вызов а.
Только х, кажется ты прав.
Кажется ты прав, мы сканируем только х.
Ну да, было бы...
Нет, даже если бы мы полностью сканировали, там бы все было хорошо.
Ну вот...
Мне кажется, мне интересно просто сканировать как аргумент.
Очень-очень...
Очень тяжело, конечно. Давай будем подглядывать.
То есть вчера оно открывалось, а сегодня и не открывается, да?
Или это MFTI-пишник забанен?
Давайте-то я не знаю.
Прокси откроем.
Ну слушайте, это крайне печально, надо выгрузить эту цепочку писем,
потому что без нее невозможно заниматься препроцессором.
Может так найдется...
Что?
Ну давай поверим, что я правильно составил слайды.
И предположим, что действительно только вот это сканируется заново.
А, ну это и будет...
Да, это действительно будет совпадать с тем, что у нас в итоге получилось.
Потому что если бы полностью рисканировалось, чуть-чуть другой результат был бы, по-моему.
Ладно, окей, вот это рисканируем.
Ну и надо подстановку выполнить.
А от нуля.
А это что такое? Это АА и опять Х.
И вот так.
Правда? Правда.
Все, мы подставили Х, рисканировали.
И больше ничего делать не надо.
Мы подставляем все вот это вот мясо, которое мы там наворотили обратно туда, где был принт.
В частности, вот эта магия, которую я здесь написал, она же ровно так и работает.
Зачем я завел два макроса принт?
Давайте, чтобы вас немного не смущать, мы там заменим вот эти вот три точки, которые там на всякий случай стоят.
На просто Х.
Ничего не изменилось.
Ну почему вот принт и принт нижнее подчеркивание?
Давайте принт нижнее подчеркивание здесь напишу, который просто аргументы превращает в Х.
В результат изменился.
А что нам выдали?
Нам выдали только вот эту штуку.
Вот ровно то, что мы сюда вписали, нам и выдали.
А почему?
А потому что вот эта шняга, она подстанавливается, но рискан на нее не происходит.
Вот, поэтому вот такой макрос принт, он просто выводит то, что вы в круглые скобки ему передали.
Понятно?
Давай.
Да, сейчас мы это будем обузить.
Так можно сделать. При желании можно.
Вот.
Чего?
Что не будет раскроется само по себе?
Я не могу понять, в чем вопрос.
Ну вот, короче, вот так не работает, потому что это просто подставит вам вот сюда вот эти токены и ни разу их не просканирует.
Они не были просканированы вообще эти токены.
А если я сделаю вот так, то у меня при подстановке вот в этот макрос принт, вот эта вся шняга, она будет подстанавливаться как просто Х.
И мы только что разобрали, что в таком случае рисканы запускаются.
Что если написать принт2, который делает принт1?
Ну, кстати, ничего не изменилось, на удивление. Видимо, у нас действительно такой макрос.
Но не будем забегать вперед. Продолжим послайдовать, там все это будет.
Окей. Так.
Прошу прощения, я вчера пел весь вечер, был корпоратив, почувствовал себя певцом и тяжело говорить.
Так, ну и из той же области примерчик.
Только что принт я вам показывал на годбалте.
Вот это конкат. Вы его можете, привет, вы его можете увидеть, ну, примерно везде.
Ну, это очень частый макрос, вот куда ни плюнь, в любой кодовой базе он раза три хотя бы заново переизобретен.
Точно.
Ну и вы понимаете, почему он так работает, да?
Потому что если просто конкат нижнее подчеркивание использовать, у вас вот эти аргументы ни разу не просканируются.
И вот такой бы код вам бы просто вывел вот эту часть, первый аргумент, и второй аргумент, прилепленный к нему.
И была бы фигня какая-то.
А вот если вот так сделать, то у нас на аргументы рискан делается.
И вот этот вот, вот этот аргумент весь зарисканится.
И это хорошо.
Ну, коли оно делает рискан, народ придумал магию.
Он объявляет макроскан.
Ну, народ, наверное, это вот типа много раз независимо было открыто разными людьми.
Вот макроскан.
Вот правоаргзы я еще не сказал, да?
Но что это на самом деле?
Вы можете сказать, что мне пофиг сколько мне прислали аргументов.
Я их хочу воспринимать как просто последовательность токенов, некоторые из которых это запята.
То есть вот это говорит, я принимаю любую последовательность токенов, включая запятые.
Пофиг сколько их.
А вот это говорит, подставь мне, пожалуйста, всю мою последовательность токенов вот сюда, включая запятые.
Вот так об этом правильно думать, если я не путаю ничего.
Ну и что это за макрос будет?
Ну, вы ему любую последовательность токенов прислали в этот скан.
А он их просто взял и как бы подставил как есть, ничего не поменяв.
Но потом произойдет рискан.
Это макрос, который еще раз раскрывает все макросы, которые были в этой последовательности токенов на один уровень.
В чем понт?
В том, что это на самом деле нам позволяет добиться в какой-то степени рекурсии.
Потому что если мы там какой-то код написали там с какими-то A круглые скобки, B круглые скобки,
и напоролись на то, что дизейблинг, контекст нам вырубает нашу рекурсию,
то мы можем обойти это.
Мы запустим скан два раза.
Можно три раза, четыре раза.
Каждый скан, то есть скан два это скан, и соответственно при этой подстановке один раз рискан произойдет.
И при этой еще один раз.
И мы просто заново будем эту последовательность токенов рисканировать.
Каждый раз сбрасывая дизейблинг контексты.
И мы просто увиливаем от этого и заново раскрываем, раскрываем, раскрываем.
Ну и вот тут есть пример.
Вот какой-то макрос, который в строку что-то превращает.
Вот там A и B, они просто складывают X.
И мы написали вот такой смешной код.
str пробел A от единиц.
Но это как бы не вызов функционального макроса.
А вот это вызов.
И если мы это запустим, то нам, например, процесс это вот так.
str останется как есть, а вот эта фигня раскроется в 1 плюс 1.
Но мы видим, что это можно еще раскрыть.
Просто нужно просканировать еще раз.
Давайте напишем scan.
И он просканирует еще раз.
И таки превратит, но каким-то немножко странным образом я подозреваю, что у меня здесь и печатка может быть.
Значит, я себя как-то путаю.
Потому что A...
Что будет происходить?
Мы подставляем scan, вот эту последовательность токенов.
Вот туда.
Или сканируем ее.
str мы здесь не засканируем.
Мы только A от единицы раскрываем.
Scan принимает как?
Это не через запятую принимает?
Смотри.
Scan – это вариадик макрос.
Он принимает любую последовательность токенов.
Любую.
Раз токен, два токен, три, четыре, пять.
Последовательность токенов – последовательность.
Все.
Тут запятые никак не влияют.
То есть об этом не нужно думать в каких-то вариадиках C++ или C.
Это просто любая последовательность токенов.
То есть пробелы, можно через запятые, они ни на что не повлияют.
В ARX просто всю последовательность токенов вот сюда впасчивает.
Вот как она была, так ее и ляпает.
Пробелы разделяют токены.
Нет, это разделитель токенов.
Ну да, пробелы вообще ни на что не влияют.
Они просто разделитель токенов.
В ARX подставится вот этот токен, потом вот этот, потом вот этот и этот.
Короче, у меня какие-то сомнения.
В сомнениях всегда надо вбивать good bolt, чтобы сомнений не было.
Так.
Принт вот этот мы оставим.
Он нам там пригодится.
Ну вот.
И мы хотели посмотреть вот эти штуки.
Здесь их где-нибудь вот так вот.
Так.
Принтить будем str a от единицы.
Ну вот.
Оно один раз просканировалось и один раз раскрылось.
А, ну я понял, почему я так написал.
Потому что если я сейчас скан дописываю сюда,
то оно действительно вот так раскроется.
Но это не совсем честно.
А, ну ладно.
Это все абсолютно честно.
Это все абсолютно честно.
Потому что, ну действительно, мы вот...
Как же легко запутаться.
Сейчас все, говорю как есть.
При подстановке в скан вот эту фигню мы раскроем a от единицы.
Так?
Раскроем.
Все остальное не раскроем.
Это вот одна штука.
Все остальное не раскроем.
Это вот одно сканирование было.
И потом вот это вот...
Вот такое выражение получится, по сути, да?
Внутри скана.
Внутри скана будет вот это.
Но потом вот это мы подставим обратно вот сюда.
Где мы это написали.
И продолжим сканирование.
И увидим str от 1 плюс 1 ну и...
В общем, один раз раскрывается макрос,
а потом раскрывается то, что получились.
Ну ты пропустил момент,
где я все это объяснял подробнее.
При подстановке аргументов в функциональный макрос
аргументы сами по себе сканируются еще раз.
Вот тут об этом речь.
Ваарксы это как один аргумент или как много аргументов?
Это один аргумент,
но в котором могут быть запятые как просто полноценные токены.
Так нет, вчера он два раза раскрывается.
Первый раз оно раскрывается, когда мы вот здесь парсим ваарксы.
Привет.
Да, ну вот как мы принт смотрели.
Да, или...
Точно так же, как вот здесь раскрывались.
Вот при подстановке сюда A и B раскрывались.
Рискан происходил.
Вот точно так же здесь ваарксы рисканятся.
Это первый раз.
Потом мы как бы завершили запускать вот этот вот макросскан.
И весь результат... А результат вот такой получится.
При первом сканировании вот этой строки
результат будет вот такой.
И вот этот результат мы подставим обратно туда,
где скан запустили.
То есть вот сюда.
И продолжим сканирование.
Потому что мы помним, да,
после того как подстановка макроса произошла,
мы не сдвигаемся вперед, мы продолжаем с той же точки.
И сканируем еще раз.
Поэтому уже получим вот такое.
Жутко.
То есть мы второе получаем вне скана уже, да?
Чего?
То есть у нас вне скана вы еще раз сканируете, да?
Да-да-да, вне скана, просто потому что мы вот это при процессе
еще одно сканирование.
Но можно вот так написать еще.
Будет вот такая забавная шняга.
Почему, конечно, надо задуматься.
Сколько раз здесь можно раскрыть?
Первый раз раскроется от единицы при подстановке в скан.
Так?
Вот это вот внутри скана раскроется.
Второй скан произойдет...
Второй рескан произойдет,
когда мы уже результат обратно сюда подставим,
и здесь мы увидим b от вот этой фигни.
То есть b от 1 плюс 1.
Его тоже раскроем.
И останется последовательность токенов str
от того, что нам b от 1 плюс 1 вернуло.
Но если в b подставить 1 плюс 1 в качестве x,
то мы получим вот ровно это.
Скобочков не должно быть?
Где?
Скобочка 1 от 1 плюс скобочка 1?
Нет, нет.
Потому что мы...
Очень сложно, я понимаю.
Препроцессор это мозголомательная штука,
которой нужно привыкнуть правильно о ней думать.
Это прям очень грустно.
Ну, будем верить,
что вот этот мой макроспринт ничего не ломает здесь.
Скобочки...
Там на слайде была ошибка.
Да, вот эти скобочки это ошибка,
и вот эти скобочки это ошибка.
Давайте я исправлю,
чтобы меня это не смущало.
Да, по идее все вот ровно так.
После этого он превращает всю эту шнягу
просто в строку,
и она уже сканироваться не будет.
Поэтому дополнительный скан
после того, как сам принт раскрылся,
мы как бы подавили.
Вот так в биле.
Давайте вот так.
Подробно, что происходит.
Внутри скана
мы подставим
вместо вот этого варкса
всю последовательность токенов,
которые внутрь прислали.
Прислали вот эту.
Теперь ее надо просканировать заново.
Мы просканируем А
и подставим вместо нее 1+,1.
Ну видите, что А объявлено от единицы,
1,1.
Ну теперь мы это подставим
обратно за место скана.
И получим выражение
снаружи
str b 1+,1.
Но его тоже надо просканировать.
Мы его просканируем.
B вызвано
от выражения 1+,1.
Поэтому
будет 1+,1
плюс 1+,1.
Вот так вот.
Теперь понятно, почему
скобочек не будет вот в этой шняге.
Тут надо очень
чувствовать, что это не вызовы функций,
а какие-то лютые механизмы с подстановкой,
где у вас аргументы сначала сканируются,
потом все возвращается,
и потом заново сканируется.
Это сложно и неинтуитивно,
и противокак-то естественно человеку.
Но надо понять.
И вот мораль.
Скан 2, он еще один лишний раз
просканирует результат.
То есть то, что скан
такое выражение вернуло нам,
вот это вот,
если рей сканировать еще раз,
то понятно, что получится ровно это.
Но скан 2 это и делает.
Но теперь задумайтесь,
что если сделать скан 100-500?
Можно геометрической прогрессии
вообще их растить,
потому что вам никто не мешает здесь написать два раза скан.
Можем просто скан
для n написать?
Для конкретного фиксированного n,
который ты заранее у себя в голове представил
во время припроцессинга?
Да.
Нет, если у меня есть какой-то скан
не очень большой,
то я... Нет, по-моему это невозможно,
иначе мы бы были полны по тюрингу.
А макросы...
Не уверен.
Я таким не особо страдаю.
Вы не слышали, что какая-то курсия,
которая есть в шаблонах припроцессинга
делается через икру самого себя,
среди глобального стейта?
Нет, про инклуды мы поговорим
в самом конце. Я не уверен,
что они позволят действительно сделать скан
для произвольного количества. Не уверен.
Надо пробовать. Может, кто-то это умеет.
Но обычно
просто фигарят скан,
скан 2 это скан два раза,
скан 4 это два раза скан два,
и оно в геометрической прогрессии растет.
Сколько вам нужно рисканов, столько и...
А еще,
вот это вот похоже на композицию функции,
правда?
Или что-нибудь из Хаскеля.
Мы взяли композицию СТР,
Б, А, и к этой композиции применили 1.
Просто
единственная проблема, что надо вызвать
скан еще от всего этого столько раз,
сколько вы закомпозировали тут.
Это немножко мозговзрывательно,
но пойдем дальше.
Сейчас будет совсем...
Сейчас не совсем убойно, сейчас будет полезно.
Хитрый трюк,
который у нас
используется, пожалуй, сильно
чаще в продакшене,
чем хотелось бы.
Хмакрос называется.
Хмакрос — это вот этот вот макрос.
Лист.
Как видите, он представляет собой
последовательность токенов,
в которой
какой-то другой f используется,
который может быть, функция может быть
макросом, спокойно может быть макросом,
но он пока не определенно нигде выше.
Но он используется,
ему в аргументы передают
A, B и C.
То есть это тоже в каком-то смысле такой список
или последовательность.
Просто список или последовательность заранее написано
с применением какого-то
f наперед неизвестного.
Вот.
Еще про вот этот бэкслэш надо сказать.
Знаете, что делает
бэкслэш в конце строки?
Не совсем.
Он делает следующий символ токеном,
если я правильно помню.
Следующий символ токеном.
То есть ньюлайн станет
токеном, и когда вы подставите...
Ну короче, сейчас, идем дальше.
Кажется, бэкслэш, пробелы
совершенно не выпиливают целиком.
Это второй этап.
Ладно, неважно.
Ну короче, да, оно продлевает макросы на следующие строки.
Нам это даже не так важно.
Но даже тут какие-то.
Коментарий может продлевать.
Ну все продлевает. Короче, конкатонируют
строки типа без новой строки.
Подавляет ньюлайн как
сущность языка,
в том числе при процессоре.
А вот теперь как использовать этот
x-макрос? Мы дефиним
f от x как
какую-то фигню.
Ну взяли,
прилепили к x подчеркивая id
и сделали, вызвали какую-то
функцию глобальную. Get id
от строкового представления x.
Вот сdefine или f.
А теперь напишем просто
сам лист, объектный макрос
напишем и
undefine f.
Вот этот объектный макрос лист
раскроется вот в следующую фигню.
Понятно почему.
Потому что просто мы
ну да, f объявлена
позже, но она есть, и когда мы будем
это раскрывать, мы спокойно f применим
и все будет работать.
Вот.
Это очень полезно, когда вам нужно
какой-нибудь вот такой дурацкий
boilerplate писать, чтобы какие-то строки
в какие-то idшники
превращать там
где-нибудь, в что-нибудь
статическом. Ну вот такое
бывает, что у вас какая-то система, она там
работает со строками очень часто.
Какие-нибудь строковые названия каких-нибудь
ресурсов, там
биндингов, еще чего-нибудь такого.
Ну вот вы их все забиваете
в такую шнягу,
и idшники, ну тут
статик-то писать еще, да, и
idшники просто в какой-то
хэшмапчик засовываете
строки, получаете idшники,
один раз их сохранили, и вот.
Дальше у вас всегда можно
писать там название
строковое какой-нибудь шняге,
и вам его дадут.
Ну, способ
подавлять boilerplate, не очень хороший.
Лучше просто не иметь таких функций getid,
и как-то по-другому эту проблему решать.
Ну ладно, пошли дальше.
Теперь
начнется убойная.
Ну давайте как-то это парсить
с конца. И че
я написал?
Case export1, case export2,
case пустые скобки,
и
как бы default
автоматом получать. Ну зачем это нужно?
Затем, что я не хочу
брейки писать, но я хочу
нормальный синтаксис,
что просто кейс, фигурные скобки,
все.
Ну я хитро поступил, я в начале
каждого следующего кейса делаю брейк
для предыдущего кейса.
Ну switch так работает, c++,
fc, что можно так сделать?
И получается
вот такая шняга.
Единственная проблема
это че такое
вообще?
Вот как вот это вот все работает?
Почему мы
же не можем перегружать макросы?
Вы в курсе? Не вообще не можем.
То есть нельзя сделать два макроса
кейс, один от одного аргумента,
а другой от другого.
Кейс это один макрос,
который принимает, ну как бы в ряде
к просто любую последовательность токенов.
И при этом мы каким-то
образом, когда эта последовательность
пустая, умудрились
вместо кейса
написать дефолт.
Как?
Написано, но распарсить
это невозможно.
Во-первых,
cat и pcat.
Ну мы их видели уже, да?
Cat это просто конконтонация,
а pcat это конконтонация с ресканом.
Ну то есть чтобы можно было
в pcat еще какие-то макросы передать.
И оно работало.
Ну вот здесь мы собственно и передаем.
В pcat еще какие-то макросы,
потом произойдет рескан.
Внимание, какие макросы мы передаем?
Ну мы передаем
кейс
и некоторые изэмпти.
Изэмпти раскрывается в ноль,
когда вот в этой
последовательности токенов
есть хоть один токен
и в единицу иначе.
Изэмпти в единицу.
Изэмпти в единицу,
если это пустая последовательность токенов,
иначе в ноль.
И мы конконтонируем кейс
с вот этим нулем или единицей.
А кейс 0 и кейс 1 они вот тут задефайнены.
Дальше еще раз круглые скобки,
видите?
То есть результат этой конконтонации
это название другого макроса.
Либо кейс 0, либо кейс 1,
который потом сразу запускается
в токенов.
Вот к вопросу Петя, можно ли?
Да, можно.
Тут очень хрупкая конструкция.
Вы должны следить за ресканами.
Потому что может быть такое,
что вы вот этот ПКат прекрасно
раскроете и у вас типа все круто,
но после этого
внезапно окажется,
что не хватило лишнего скана,
чтобы раскрыть все это вместе.
Вот такое может быть.
Благо здесь хватает,
потому что мы на самом деле,
вот сам кейс,
он никак ресканы аргументов не использует.
Тут они не интересны.
Поэтому просто считаем,
что сразу все подставилось сюда
и начало дальше раскрываться.
И вот как бы ПКат, он как-то там раскроется,
все будет, будет кейс 0.
Ну и дальше рескан просто напрямую идет.
Ну как бы, то есть не рескан,
окей, скан просто продолжается.
Вот ПКат весь раскрылся
в кейс 0 или кейс 1, и просто отсюда же
рескан продолжается, и как бы
все нормально, и все цветочки.
Но как только вы такое пытаетесь в рекурсивном
чем-то писать, там всякие DC
возникают, синие краски и прочее.
Поэтому надо быть аккуратным.
Но тут вроде очевидно, почему работает.
Правда?
Все прекрасно.
Нет, из empty это наш следующий вопрос.
А как это написать вообще?
Давай.
Это неважно.
Да.
Вот эти? Да ничего не будет.
Ну,
это тоже ничего не будет.
Ну то есть свитч, он работает
совсем не так, как вы думаете.
Если у вас есть интуиция про то, что свитч
это как такой ИФ с несколькими этими,
то это вообще неправда.
Свитч это, да,
такие гоуту, по сути.
Типа структурированный
гоуту.
Давай посмотрим на Х, и
в зависимости от того, что в Х написано,
пойдем сделаем гоуту
на какую-то из строчек внутри
моих фигурных скобок.
И вот эти кейсы это просто метки, куда делать
гоуту. А брейк это гоуту-конец.
Все.
Больше из себя свитч ничего не представляет.
Поэтому если вы в конце брейк пропустите,
вот, заметьте, в дефолт, и там дальше
нету брейка. А ему пофиг.
Потому что какая разница в конце
дефолта, в конце последнего этого сделать
гоуту-конец или просто вывалиться за конец?
Ну вывалились и вывалились.
Да?
Я делал на Си стэклу струтину
с помощью
девайса и да.
И я делал сеспент внутри файла
или внутри флора. Да.
Более того, можно свитч
можно
можно внутри свитча
просто вот
втупую внутри свитча написать
абсолютно любой код. Вот без всяких
кейсов брейков. Любой код внутри свитча
пишете вообще любой.
Ифы, вайлы, что угодно.
А потом рандомно в этот код
натыкиваете кейсы куда хотите.
И это будет работать.
Вы не слышали про это?
Какие вы молодые, наивные.
В первом семестре
кидали в профи цифров.
Что оно выведет?
Там что-то совсем не очевидно было.
Так, знакомьтесь.
Устройство Дафа.
Даф.
Мужик такой.
Что здесь интересно?
Вот свитч идет.
Дальше идет кейс ноль.
И прямо внутри него,
внутри этого кейса ноль открывается
вайл цикл.
Посреди этого дуайл цикла
на пендюре на кейсов.
А потом этот
дуайл цикл закрывается.
Итак, когда мы придем
в это место впервые,
хватит мне писать, я занят.
Когда мы придем в это место впервые,
мы возьмем этот каунт по модуле 8
и прыгнем туда, куда надо.
Ну, предположим, получилось
там 5. Прыгнем сюда
и прямо отсюда начнем идти дальше.
Пыры-пыры-пыры идем.
Дошли до... Все кейсы игнорятся.
Это просто метки.
Дошли до вайла.
О, n еще великоват. Пойдем в начало.
И опять просто идем подряд, игнория все метки.
Ну, это просто обычный цикл.
Метки уже ни на что не влияют.
А потом мы из этого цикла просто вывалимся
и свитча вывалимся, и все.
То есть вот этот свитч — это просто
гоуту-нужная строчка.
Компилятору норм.
Я не умею отвечать на такие вопросы.
Обратите внимание на то, как объявлены параметры этой функции.
Да. Вы такое видели когда-нибудь вообще?
Ну, это...
Кернигенричи диклорейшнс.
Да. Когда-то...
Когда-то в языке C не было сигнатур.
Вообще.
Вот ничего не было.
Вы просто писали там send.
Это объявление функции.
Как будет линковаться?
Ну, по строковому имени.
Как и всегда в C.
Ну, просто в языке C
линковка, она...
Ну, нет перегрузок, нет никаких приколов.
Линковка работает тупо по названиям функции.
Все, сигнатуры им не нужны.
И когда-то давно в языке C сигнатуры выглядели вот так.
Что говорить, ну, у меня функция принимает два аргумента.
И все, в принципе.
Вот это вот ваша диклорация функция.
По дефолту возвращает int.
А потом вы
в теле функции,
уже в definition, да?
Эта вот часть definition.
Берете и говорите, ну, а теперь я решил,
что первый аргумент я интерпретирую как int,
а второй аргумент как чарт две звездочки.
Че?
Нет, ну, прикол в том, что
тебе все это не важно.
Ты думаешь, что тебя это очень волнует,
тебе это очень важно, но тебе это не важно.
Так, смотри, это теперь не main, это теперь foo.
Это foo.c,
это foo.h,
foo.h объявлено.
Есть foo.
Все.
Че? Зачем?
Ну, и ты в точке вызова,
где ты заинклюдил вот этот foo.h.
Если ты вот там заинклюдил foo.h,
ты такое делаешь.
Если ты вот там заинклюдил foo.h,
ты такое делаешь.
foo от там
3
и там какой-то указатель.
Ну, смотри,
смотри.
Смотри, вот ты видишь,
у тебя вызвано от int,
это же int,
и вызвано от чарт две звездочки.
Ну, ты же знаешь, как int
и чарт две звездочки укладывать
на stack или в регистры,
чтобы вызвать функцию такую?
Знаешь. Ну, так здесь и уложи.
Уложил? Ну, прекрасно.
Потом этот вызов через линковщик
и вот эту вот хренотень придет сюда,
а здесь в определении функции
написано,
ну, ты же знаешь, как доставать
аргументы со stack из регистров,
если они были типа int и чарт две звездочки?
Ну, так и достанье.
Вопрос, что происходит,
если здесь на самом деле был не int?
Или если здесь было три аргумента,
а вот это вот
вообще int, а не чарт две звездочки,
у него там размер 32 бита,
а чарт две звездочки
64. Ну, происходит
бум. Программа
крашится, если он повезет, если не повезет,
продолжает работать, как ни в чем не бывало,
какой-то мусор, просто читая, непонятный.
По стандарту это просто нарушение
ODR. Отлично.
Вот эти финиши уже нет
для такой сигнатуры? Нет.
Ух, прекрасно.
Ну вот, когда-то люди на C писали
так, а потом в последний день
перед стандартизацией ANSI C,
вот C89 стандартизировали
первый раз, когда,
по-моему, Ричи Деннис прибежал
и сказал, это невозможно,
мы это выпиливаем, и вот, ну, типа
за один день пропихнул стандарт
современной синтаксис объявления определения
функций. Вот.
Без всякого опыта предыдущего,
без там, какие-то проверки,
как оно вообще будет работать,
просто человек понимал, что вот это хрень,
а вот то, что он новое взял,
придумал за один день, оно отлично,
и до сих пор мы с этим отлично живем,
и в принципе не жалуемся.
А потом, когда в C17
смеют добавить
какую-то новую фичу,
набегают люди и говорят, стандарт
призван стандартизовывать существующие
практики, вы что, это не существующая
практика, вы тут сами что-то себе
придумали, это никому не надо.
Вот, лично Денис Рича
добавлял стандарт, не существующую
практику, которая никому не нужна, и все
и так прекрасно жили.
Можно вкинуть. Вкинь.
В C17 это фу от
просто слезковочек.
Вы знаете, что она не может понимать
любой рэп. Да.
Это легаси как раз с этих времен.
В флюшах по-другому.
В флюшах по-другому.
Я наконец-то понял, зачем
это тут. Да, это не было
сделано, а это так сложилось,
так было изначально.
Ну ладно, уже закрыл.
Да.
Мейн просто две круглые
скобки. Это мейн от произвольного количества
аргументов. Ну и на самом деле
тебе покинут туда инт и
чар для звездочки.
Ну короче, да.
Керниган и Ричи, вот это два мужика,
которые оригинально разработали
язык C, еще там
в 70-е.
Ну, видимо,
я не уверен. Я вот эту вот
историю плохо помню.
В общем, Ричи главный.
Ну да, вот они там
придумали язык C в Bell Labs работая,
по-моему.
Ну и язык C выглядел вот так.
А потом он стал популярным,
и его решили стандартизовывать
международный комитет стандартизации
и Iso,
который там диаметры гаяк
и болтов тоже стандартизирует.
И вот, ну, там буквально
за, грубо говоря, день до
стандартизации Ричи понял, что вот
это хрень это надо выпилить. И выпилил.
Но деприкейтнуть и совсем удалить
это получилось только
40 лет спустя? 30?
30 лет спустя.
Вот, очень-очень сильно отвлеклись
от нашего любимого этого
препроцессора.
Ну ладно, мистерическую справку навели.
Продолжим. Разобрались мы
с этим, правда?
Вот по модулю из-эмпти
понятно, что происходит.
Из-эмпти
ключевая идея.
Есть такой макрос из-эмпти-экспант.
Он во что-то
экспандится, да? Ну, запятая
ткань. Это на самом деле абсолютно
неважно. Сравним
вот две такие записи.
Вот это, если просканировать,
раскроется что-нибудь?
Нет.
Тут нету вызова этого функционального
макроса. Потому что здесь
какая-то аркс, какой-то токен, непонятный
влез. А вот это
раскроется.
Ну, они останутся просто висеть.
Ну,
останутся висеть.
Да, они просто останутся висеть,
они ни на что не влияют, эти скобочки.
Ну, короче, так работает.
Я напоминаю, мы хотели понять
последовательность токенов, она
пустая или не пустая. И вот
мы обнаружили такой смешной факт,
что вот этот вот код
раскрывается в
ничего, а вот этот раскрывается
в запятая 1.
То есть, если мы напишем
как бы вместо аркс сюда в аркс,
когда оно было пустое, мы превратимся
в этот кейс, иначе в этот.
Давайте так и сделаем.
Вот он
наш прекрасный изэмпти.
Понять бы ток,
что происходит.
Здесь есть еще функция f от x,
макрос f от x.
Макрос f от x применяет f ко
всему остальном, с ресканом.
Ну, такое просто вы можете встретить,
если будете читать про boost pp
или еще какие-то библиотеки
припроцессорные. Популярный, модный
макрос. Везде есть.
Ну и что мы делаем? Мы применяем
tuple add 2 к какой-то фигне.
Что такое tuple add 2?
Вообще, что такое tuple?
Про tuple пока не было слайда.
Странно, что в такой последовательности.
Ну ладно. Но tuple это просто
через запятую написаны какие-то
токены.
Нет, то же самое.
Мы говорим, что мы принимаем два аргумента
и последовательность любых
токенов.
Два аргумента, в смысле, разделенные запятыми.
А вот дальше, что там есть, вообще пофиг.
Вот так тоже можно.
И что а, что вот эту произвольную
последовательность токенов мы выкидываем нафиг,
и оставляем только второй элемент.
То есть это как tuple считается,
второй элемент из него достали.
О!
То есть тут как бы через какой-то
f от x странный, но написано
tuple от всего, что справа.
Так.
Ну вот тут.
Вот.
Да, f от x
rescan делает, неважно, запомнили.
Надо распарсить все остальное.
То есть вот это
ровно та идея, которую я только что сказал.
Видите, вот из empty expand
дальше в args подставлен.
И круглые скобочки.
А потом еще какое-то колдовство.
Запятая, ноль запятая.
Видите, из empty
expand, правда?
Вот он просто в запятая 1 раскрывается.
Скажите мне, во что
вот эта вот вся фигня раскроется,
на что я указываю,
если в args пустой?
Продикцуйте последовательность токенов, кто смелый.
Ноль запятая.
Нет, ну в args пустой был.
Что?
Ну я tuple закрыл, вот это все неинтересно.
Ну в запятая
неважно.
Это все внутри аргументы.
Ну без tuple, да.
Без tuple.
Так, еще раз.
Да, запятая 1,
запятая 0, запятая.
Просто из empty expand раскроется в запятая 1,
а дальше запятая 0, запятая останется.
А если в args
не пустой, во что это раскроется?
Ну непонятный вопрос,
но по факту просто в args раскроется как-то.
Правда?
Все остальное нам не особо важно.
Ну будет в args написана какая-то лютая
последовательность токенов,
но нам особо и неважно.
А теперь,
что на самом деле произойдет?
tuple это 2.
Будет брать второй элемент.
В args?
Если в args есть запятые,
то все немножко сломается, это правда.
Но не факт,
потому что здесь ресканы,
хитрое число раз запускается, и может быть,
но не факт.
Надо попробовать, сейчас попробуем.
Но если вот предположить,
что в smt не пихают запятых,
а мы где его использовали?
Мы его использовали вот здесь.
И тут как бы
ну могут пихнуть запятую.
Ну не должны.
Кажется там
синтоксический максимум
cast expression в кейсе разрешен.
А, а у нас в кейсе скупки опять.
Ну да,
как бы считаем, что нет
запятых. Потом их тоже можно
побороть, но давайте хотя бы так справимся.
Если запятых нет,
то вот эта все последовательность
докинов без запятых,
а вот это второй аргумент
для tuple add 2.
То есть tuple add 2
вернет нам ноль, если вот этот
из mt-expand не заэкспандился.
А если
в args был пустой и он заэкспандился,
то вот это вот запятая
1, это и будет
второй аргумент для tuple add 2.
Да?
Потому что первый аргумент, он между вот этой
запятой и вот этой, и он пустой.
Ничего.
Вы поняли,
как это работает?
Это жутко просто.
Этот фокус постоянно
нас будет преследовать.
Вот этот фокус, что типа подставим в args
и куда-нибудь, потом там типа если
он раскроется, то раскроется, если не раскроется, то нет.
Tuple add 2 вернет вам
либо ноль, либо один.
Типа того. Нет, из mt-expand
оно раскроется.
Вот сейчас вот это вот от из mt-expand
до вот этих вот круглых скобок в конце.
Вернись назад. А это нет, наоборот,
это не раскроет.
Назад. Да. Вот.
От из mt-expand до круглых скобок оно раскроется
либо в один,
либо в выражение
без запятых, либо в выражение с одной запятой.
Тем самым поменяв,
кто здесь будет второй по номеру.
Вот. В этом вся идея.
Давайте так. Поднимите руку, если эта идея
до вас дошла.
Ну вот. Плюс-минус.
Ну хорошо.
Да. Может,
вопросы какие-то.
Потому что дальше оно будет...
Что?
Функциональный макрос не варарганный
нам тупо выдадут ошибку.
Да, тупо при процессоре
выдадут ошибку. Вы не столько, сколько я ожидал
аргументов дали.
Вот так вот.
Плохо старался, значит.
Нет, еще есть УБФ при процессоре.
Ну, с этим борется
активно один из разработчиков
к вам, которому не нравится
всю УБФ за седьмой фазотрансляцией.
Да.
Не пусто.
Вот этот из mt-expand
не раскроется.
А в арксах мы предположим, что
запятых нет.
Значит, посчитаем, ну вот, что
2 делает.
Возвращает второй аргумент.
Вернее,
в последовательности разделенные запятыми
возвращает все, что после
первой запятой.
Если вот эта
вся херня не раскрылась...
Прошу прощения.
Тут хочется ругаться.
Если все это не раскрылось,
то первая запятая будет вот эта.
Вот она.
Иначе вот она.
И из mt-expand.
У нас вот пришел из mt-expand.
Ну, напиши сюда еще
хэш какой-нибудь, чтобы никто не догадался,
как это называется.
Из mt, от mt-expand
и без скобок.
Мне кажется, что вместо
вареж поставится еще раз из mt-expand
и там придется один respawn.
А, на походу уже два respawn.
Ну, просто сделайте так, чтобы ваш пользователь
не мог вот эту фигню куда-то
вписать. Хэш впишите длинно.
Не совсем.
Там, по-моему, уже в таковый скан.
Ну, короче, вот еще...
Хэш это плохо, потому что пользователь
в какой-то момент решит, а я хочу хэш
и он случайно выберет его.
Ну, окей.
Есть нижнее подчеркивание
каунтера. Ну, короче, сейчас будет
как можно уникальные имена для этих штук
сделать. Окей.
Трюк лютейший,
но полезный.
Теперь
немножко опять вот сейчас
погрузились в какую-то лютую дичь.
Сейчас будет немножко простого и полезного.
Вы пишете свой
macros for each.
Ну, захотелось вам.
Или вы можете писать свой macros
assert once. Видели когда-нибудь
такое?
Ну, типа assert, но который
срабатывает только один раз.
Ну, assert не обязательно убивает программу.
Можно сделать assert, который
типа выскакивает окошко и такое.
Окошко сломался. Хотите попробовать продолжить?
Да. Фигарь дальше.
Ну, вот в геймдеве они постоянно
используются.
И можно... Ну, если это каждый кадр
происходит, то не очень вы поиграете,
что у вас каждый кадр окошко сломался.
Ну, вот можно сделать кнопку
пропустить насовсем и больше не показывать.
Ну, и чтобы эта кнопка работала,
нужна там какая-нибудь статическая bool
меня пропустили.
Внутри macros assert объявляйте static bool
меня пропустили и дальше уже пишете
и если условие не прошло,
то там показывай плашку, что я
сломался.
Ну, тут попроще. Ну, просто цикл
и цикл. Вот вы так написали код.
И все сломалось.
Ну, с каким-то macros
foreach еще очевидно, что оно может сломаться.
Но если это
assert или assert
once, то не очевидно.
Оно может выглядеть как обычный вызов функции.
И на самом деле ничего
не работает. Почему сломано? Видите?
Да.
Что только первая строчка будет внутри цикла,
а все остальное наружу вылетит и все.
Конец.
Как это фиксить?
Просто фигурные скобочки
обернуть плохо.
Там начнутся еще проблемы с else.
Потому что если вы напишете
два if без фигурных
скобок внутри свой macros,
а потом else, то в зависимости от того,
есть ли сейчас или что-то такое было.
Да,
только фигурные скобочки
тоже ломаются в каком-то случае.
Предлагаю об этом вам самостоятельно подумать.
Может вопрос?
Да.
В принципе,
на отдельной строчке является
foreach.
Я привел пример, где такое реально может пригодиться.
Здесь это
бесполезно.
Это лучше, конечно,
как-то делать.
Не, он не вытаскивается.
Тут шедуинг как бы происходит.
Это еще случайно получилось.
Короче, нормальный пример
это assert once.
Реальный пацанский пример,
где нужно сначала объявить статик-применную,
уже произошел ли ассерт,
а дальше какой-то код написать.
Здесь игрушечный пример.
Чтобы это сломалось.
Это искусственный пример.
Давайте придумаем кейс,
когда фигурные скобочки ломаются.
Давайте реально придумаем
или мы можем загуглить
подумать интереснее.
Давайте мы задефинили
какой-нибудь assert once
и задефинили его как
статик,
бул,
кек
и еще.
Вот так считаем.
В какой момент это сломает?
Бул равно нулю.
Я, конечно, C-программист.
В какой момент сломается
assert once?
В какой момент он будет вести себя не так,
как вызов функции?
Что будет, если
с if сделать?
2if, а вот это шняга.
else
по дефолту он куда?
Сюда пойдет?
К последнему.
Кажется, к последнему, но это
не повлияет.
Плохо.
Что-то я
не могу вспомнить.
Давайте это найдем.
Но это тоже
странно.
Почему
фигурные скобки не работают?
Где-то должен быть пример точно
на...
Где-нибудь...
О!
О, во!
Все.
Я вспомнил.
Вернее, я подсмотрел.
Давайте, да.
if условия
assert once.
else, что-то там.
Что-то не работает, да?
Видите, где оно сломалось?
Точка
запятой.
Противно как-то, да?
Вот если вы функцию вызываете
вот так пишете, вот с этим макросом
надо так писать.
Вот.
То есть вот объективная причина,
почему просто фигурные скобки,
это ну как-то да.
Ну и это
бывает, что вызывает
реальные баги.
Да, опять же,
я правильно начал думать про ifelse,
потому что если мы еще один
с dc добавим, скажем, что вот это все
у нас было вот так, и тут еще один
if был.
У тебя точка запятой
перегрывает все вложенные
стейтменты. Все вложенные.
Типа это простой стейтмент, который идет
после всех ifов. Блин, ну ладно.
Ну по-моему там еще что-то такое
происходило в каких-то ситуациях.
Короче, это может быть очень опасно.
И ну были всякие истории
ужасов про то, как это взрывалось,
настолько не очевидно, что
ой-ой-ой. Поэтому
просто не надо пытаться
выпендриваться, что-то придумывать.
Вот этот дедовский метод, который
просто всегда работает.
Do while 0.
Оно ведет себя как блок,
первое, но второе, после
этого нужно ставить точку запятой.
Все.
Если не поставить, то вам скажут не хватает
точки запятой, как и при вызове функции.
Вот. Оно
просто работает. Я рекомендую вам все
такие многострочные макросы обращивать
в Do while 0 вообще всегда
и не рисковать
с этой жуткой наукой
припроцессорной.
Вот тут
еще есть такие странные выражения,
где скобочки вокруг аргументов.
Понимаете, зачем это?
Что?
Да.
Что-то вроде SQL injection
можно устроить, потому что никто же
не мешает вместо f здесь написать
какую-нибудь хрень,
точка запятая, и потом уже нормальное
название функции.
Смотрите, если вместо, если вот здесь
круглые скобки убрать вокруг f и просто
f оставить,
может кто-то ваш forage
вызвать, вписав вот сюда
вот внутрь,
вызов чего-то вообще другого.
Точка запятая и название функции.
Оно сюда подставится, и как бы будет
cout handle, а потом
название функции, и оно вот к этому идет.
И вот тут, ну как бы, такая SQL
инъекция.
Короче,
подставить мусор можно всякий,
который поверх этого всего идет.
Я вижу в глазах непонимание, неужто
вы этого никогда не видели, молодые люди?
Скобочки предотвращают
влияние
ваших аргументов
на окружение
того, что происходит.
Ммм,
что нам нужно?
Ммм,
да.
Это хорошая идея, но
нету.
Ну,
ну,
ну,
ну,
ну,
ну,
так,
что там у нас сругается?
Точка запятой.
Да.
Я не знаю зачем.
Ну,
точку запятой нельзя, но я могу по-другому,
у меня есть оператор запятая.
Мм,
Ладно, нет, ну плохо. Как привести пример, когда это совсем ломается?
Можно строгу стереть строгую литералу.
О, вот. Вот так действительно очень странно ломается.
Вот с текущей нашей реализации, где в круглые скобки заключено, получается бред.
Мы подставили САУДФУ, и получилось САУДФУ в скобках, и какая-то хрень.
Правда? Если эти скобки убрать, то получится вполне нормальный код.
Ну потому что мы... ну хлам вывелся, потому что я здесь рандомную память просто накидал.
Но подставилась вот такая шняга вместо F.
И это уже интерпретируется совсем не так, как вы думали.
Теперь вот только этот хвост это как бы вызов функции,
а вот это еще как бы сделать инъекцию какой-то хрени непонятной,
которая меняет синтоксический смысл происходящего.
А вот теперь мы можем точку запятой вкинуть в аргумент макроса? Верни обратно.
Какую?
Вот сейчас верни макрос обратно туда, как был.
И вот теперь вот мы вот на DCA, интересно, D&L хотели сделать.
А, да, подожди, может там это...
Еще вот так бахну.
Ну вообще, кажется, точка запятой от нее...
Прекрасно. А точка запятой обычный токен, как бы всем рекомендую.
Видите, какой бред произошел?
Ну типа...
На какой стороне это может быть?
Ну то есть... это же бред какой-то.
Вот вы, наверное, не хотите все-таки, чтобы пользователи вашего макроса такую дичь писали.
Прекрасно.
Короче, поэтому всегда все же все аргументы, которые вы используете в плюсовом коде внутри макроса,
их надо в скобке заключать, чтобы вот эту дичь избежать,
когда неправильно интерпретируется, типа, что произошло.
Да, ну, короче, вот с скейл-инъекциями кто имел опыт, вот это вот примерно из той же области.
Когда не сонетаясь данные, вот все ломается.
Давайте возвращаться и ехать дальше.
Так что вот рекомендации.
Если вы пишите макросы, которые вставляют всякий обычный плюсовый код в программу,
заключайте их в do while 0 и аргументы в круглой скобке, везде где их используете.
А если вы делаете там макрос, который скрывается в укрытии скобки, и там что-то потом...
Тогда вас просто уволят или на код-ревью как бы забанят.
Ну, всегда можно обойти, поэтому препроцессор – это зло.
Вот мы только что занимались как бы извращениями со скобками и всяким прочим.
Это все неадекватно сложно и обычному программисту нафиг не нужно.
Да, как бы все, что я тут рассказываю, кроме маленького процента, лучше никогда в жизни не использовать.
Перерыв? Ну ты действительно прав, что пора перерыв, потому что у меня горло уже болит.
Давайте тогда перерыв на 9 минут до 50.
Шоу должно продолжаться. Избиение продолжится, пока настрой не улучшится.
Так, ну пока еще нормально. Парочка встроенных макросов.
Они просто прикольные. Вы некоторые из них уже видели. Вот есть Pretty Function, мы его знаем, любим.
Там файл и лайн есть. Ну, очевидно, что они выводят, правда?
Файл заменяется на название текущего файла, лайн – на текущую строку.
И вот из-за них как раз ассерт макрос, про это вроде тоже уже говорили.
Ну да, потому что ты как бы сначала подставляешь макрос ассерт, а потом раскрываешь этих ребят.
Ну там хитро, короче, да. Вот, но чего вы, скорее всего, не знали?
Текущую строку, текущий файл можно менять. Можно писать line 42, и я теперь капитан.
Ну да, пользуется. И как бы… Зачем?
Ну, когда ты как бы раскрываешь кучу каких-то лютых макросов, ты, возможно, сам хочешь проконтролировать,
что тебе, например, в дебажных символах или там вот в этих же файлах и линах будут показывать
о этих строчках. Вот ты, возможно, хочешь, чтобы у тебя там дополнительная какая-то дебажная информация
была про то, кто где и что происходит. Вот через это можно сделать.
Текущая строка новая. Не знаю, мне кажется, только цифры. Если можно что-то другое, то это будет…
В смысле? Ну, компиляторы, например, используют. Когда он macros.assert подставляет, он говорит,
ну типа macros.assert, где-то вот этот файл align написан, и он как бы, ну вот, окей, по-другому.
Вот ты запропроцессил весь свой файл, и дальше хочешь дебажную информацию сгенерировать.
Ну, после того, как вот такой файл с несколькими там macros-ами запропроцессился, может получиться вот такая шняга.
Тебе нужно знать маппинг из вот этой огромной шняги, какие здесь строчки соответствуют каким строчкам в изначальной программе.
Вот ровно через это оно и делается.
Ну, у тебя припроцессится при каждой компиляции файл заново. Да?
Ну да, в твоем коде просто так line писать не надо.
Ну вот, мы видим, что тут оно припроцессировалось, нам тут все STD впихнули.
А вот наш сам мейн, и тут...
Вот эти приколы как слайны.
Какие приколы?
Ну вот, видишь, там просто решетка, по-моему, были когда-то.
Да, это они есть, это они есть.
Если мы сейчас clang...
Вот этот, например.
Ну и тут не через line.
Ну, короче, видимо, оно по-разному работает для того, что вы сами пишете, для того, что компилятор генерирует.
Ну вот как бы, вот на это если посмотреть, то...
Если вот так написать...
Ладно, не могу. Ну, представьте, что это line.
По сути, вот в этом припроцесснутом файле мы говорим компилятору, что вот отныне мы на самом деле идем по коду, который вот в этом файле входном, который слева,
начиная с 21 строки. Вот на 21 строка этого нашего входного файла.
Ну и дальше подряд идет этот код.
Вот, а все остальное как бы уже выкинулось.
Ну вот, зачем это нужно? Как бы компилятор это использует, и вы тоже можете использовать, если у вас какая-то хитрая макросная магия.
Ну, вряд ли вам когда-то доведется.
Там только ее стрим.
Вот этот огромный ее стрим, вот он там прям прилетел, журнющий.
Да.
Мне кажется, что да.
Ну вот, есть, что вот мы сейчас на каком-то билтыне, потом обратно это и обратно сюда.
Ну, что-то такое происходит.
Ну, в общем...
А кто их добавляет?
Припроцессор.
Как, где, когда?
Ну, неважно.
Я не знаю.
Ну плюс-минус, когда ты что-то инклюдишь или какие-то штуки происходят.
Ну, это вот настолько нерелевантно.
Я предлагаю тебе загуглить самостоятельно, если тебе интересно дальше узнать про эти лайны.
Тут слишком много информации.
Мы еще сейчас не успеем что-нибудь, будет обидно.
Давайте побыстрее.
Дейта-тайм есть, вы не поверите.
Можно текущую дату и время смотреть.
Что, их практически было в курке, да?
Прямо в припроцессоре.
И еще каунтер.
Каунтер вам каждый раз новое число выдает.
К вопросу, как получить уникальное имя для вашего нового макросса.
Слепите каунтер с каким-нибудь там майфу.
Если кто-то решит еще раз майфу использовать, но тоже с каунтером, то у вас каунтер уникальный будет.
Но обычно это все-таки используется не для этого, а для объявления переменных.
Если вы в макроссе какую-нибудь глобальную переменную или функцию объявляете,
прилепите через две решетки каунтер к ней, чтобы не возникало конфликтов, когда этот макросс несколько раз использован был.
Еще есть такие штуки.
Про них, я надеюсь, вы слышали, хотя может и нет.
В-первых, hasInclude.
Вы можете проверить, есть ли у вас Include какой-то прямо.
Найдется он или нет.
То есть можно писать, типа if hasInclude, Include.
Иначе вы дай ошибку, что вы не установили такую библиотеку, как ее установить.
Решетка Error, такое тоже есть.
Оно просто выведет то, что вы дальше напишете, как ошибку при процессинге.
И ворнинг еще.
Есть еще Defined.
Вот Defined проверяет, определен ли макросс, который справа написан.
А он не со скобками работает?
Нет, это префиксный оператор, как и Сайзов.
Да, ну обычно пишут Defined и в скобках что-то, но на самом деле он префиксный, без скобок работает.
Проверяет на что?
Ну, объявлен ли такой макросс?
Был ли Defined для него?
А есть же IfDef и IfOnDef?
Ну да, есть отдельно Defined.
IfDef это аббревиатура для...
IfDefined...
Какой прикольный макросс у нас есть? Scan.
Вот это полный спеллинг IfDef.
Чем он круче?
Можно вот так делать.
То есть здесь вообще произвольные болевые выражения.
Можно писать и при процессорах вам их вычислят.
Это что? А какие ограничения?
Какие ограничения? Ну, арифметика...
Арифметика...
Отсутствует скорее всего.
Присутствует.
Что, не может?
Да.
Можно писать if 1, 2, plus 2.
По-моему, так работает.
Вот она просто вырезала нам I, T, I, S, D, F.
А если бы я был писать, то будет ошибка к белярцам.
Она умеет делать арифметику.
Она умеет с булями работать.
Она что угодно умеет.
Важная такая штука, но и вот тут обычный HasInclude.
А если бы в этот раз была белярция?
Белярция, да.
он очень угодно умеет. Важная такая штука. Ну и вот тут обычный hasInclude.
Вот такой, например. Вот ялстрим у нас есть. Вот такие штуки встроенные есть. Иногда они
полезны. Иногда вы их просто на работе встретите. Ну, не иногда, часто. Всякие hasInclude и defined
это очень частая штука. Поехали дальше. О, пришло время жести. Ну вот есть тут такой прикол.
Ради чего я это все показываю? Ради вот этого трюка. Ну давайте как-то сначала. Вот loop
это какой-то macros. Он объявлен как x. Какой-то loop indirection. Какие-то там костыли. Но в конце еще
раз от x запускается. Да, вот что такое loop indirection empty? Двое скобок. Но loop indirection
это просто loop. То есть если empty закрыть, то будет просто loop indirection заново запущенный,
который заново сделает loop. Вот те круглые скобки x заново этот loop запустят. И мы как бы пойдем
рекурсивно, да? Но вот как бы понятно, что мы никуда рекурсивно не пойдем на самом деле. Потому
что будут disabling контексты и будут всякие синие краски. И вот трюк заключается вот в этом empty.
Он откладывает вот defer про это. Он откладывает раскрытие вот этого loop indirection на следующий
скан. Тем самым выкидывая все синие краски и disabling контексты. То есть если мы так напишем,
то у нас раскроется вот так. 1 loop indirection. Если мы скан напишем loop 1 и тиры-пыры,
у нас два раза рекурсия пройдет. И две единички допишется. Ну и можно сделать eval много, сделать много
единичек. Вот эту рекурсию ровно на n шагов. Как это отпилить? Вас это так интересует. Вы
действительно хотите это посмотреть? Это можно. Ну где он? Вот он. Ну давайте смотреть. Значит смотрим.
Вообще это и дальше и сам расскажу. Вот у них ровно такой eval defer как у нас. Может отсюда
взято. Тут начинаются трюки. Да, трюк состоит тут в этом чеке. Хотим мы его сейчас разобрать или,
ну наверное давайте сейчас, потому что дальше все равно я про него скажу. Что здесь происходит? Вот
этот самый наш loop, который был. Он просто делает f от x, ну применяет к первому аргументу f. Дальше
делает loop indirection. Да, а что мы в итоге хотим сделать? Мы хотим f применить к списку элементов и
закончится и получить вот это вот. Цикл такой сделали. По теплу. Я напоминаю, что через запятую
написанные штуки называются теплами. И вот мы тут сделали цикл по теплу. Loop 0 делает то, что мы уже
видели. Ну тут он как бы отщипывает первый x, а все остальные x хвосту рекурсии передает. Но при этом
вот запуск этой рекурсии отложен до следующего рескана через вот этот вот empty, который просто
пустой define. А loop 1 в свою очередь, ну это пустая фигня. Соответственно нам надо сделать так,
чтобы у нас куча раз ресканился loop 0, а потом в какой-то момент стал loop 1 и он уже вот бы
стер вот эти вот лишние штуки в конце. Как это делается? Ну опять, по названиям можно догадаться,
что сейчас будет трюк с конкатенцией. Вот есть loop 0, есть loop 1. Мы хотим что-то поконкатенировать
и понять, что у нас получится. Плюс-минус. Смотреть теперь надо сюда. Чек чего-то там и просто запуск
того, что получилось в результате. Что этот человек может в итоге выдать после сканирования?
Либо он loop 0 выдадет, ну как-то, идейно должен, либо он должен выдать некоторые loop end-end,
которые раскроются в loop 1. То есть вот задача. Сделать так, чтобы здесь был либо loop 0, либо loop
1. Потом мы пошли ну сюда, потом loop indirection раскрыли в loop и заново пошли проверять,
дошли ли мы до конца или нет. И так далее, и так далее. То есть нас интересует чисто вот этот
чек, как понять, дошли ли мы до конца или нет. Здесь можно было из empty заюзать на warx, но вот
автор кода сделал не так. Он заюзал вот такой token end. Ну вот token end просто берется и лепится к,
вернее не так. Текущий элемент, который мы обрабатываем тупо лепится к loop end. Для большинства
элементов это будет loop end 0, loop end 1, loop end 2, и это ни во что не раскроется. А дальше это все пихается
в чек. Чек возвращает первый элемент тепла. Причем тепла странного. То есть нам передали x
еще что-то, мы это что-то в начало ставим, а x в конец. Вот такой прикол странный. Но tuple-end-1 при
этом это типа первый, в смысле с нулевой индексацией. Да, ну вот так странно тут написано. Да, из empty мне
кажется понятнее, чем вот это вот написано. Но суть здесь абсолютно одинаковая. Если loop end, сюда
пришел x end, и вот эта хрень получилась loop end end, она раскрылась, запятая loop 1, то при
подстановке сюда у нас здесь будет три аргумента, как бы в кавычках. Loop 0, вот эта запятая, еще одна
запятая, и loop 1. И тогда вот эта шняга loop 0 поставит в конец, а здесь останутся две запяты,
одна запятая и один. Вот так вот. Одна запятая и один, и тогда первый элемент это будет loop 1.
То есть если мы дошли до end, то вот эта вся шняга раскрывается в loop 1, иначе раскрывается в loop 0.
Зря. Зря. Ну короче, тут всегда трюки примерно одинаковые делаются. Ты делаешь вот такой check,
который аналогичен из empty, а свою рекурсию как-то еще разбиваешь при помощи какого-то
промежуточного макроса, который там либо действительно продолжает, либо идет и это,
либо останавливается, не оставляя за собой вот этого всего мусора.
Хороший вопрос. Наверное, сейчас я не могу на него ответить. Ну тут такие магии происходят,
все можно. Весь мир в труху, но потом. Ну и не сегодня вообще, самостоятельно. Вот айсберг,
вы главное что запомните, это что есть вот айсберг макросов C++, вот заходите туда,
и там по всем ссылкам, там еще больше, чем я тут рассказываю. Так, в общем, можно подавление,
да, вот. Дефер — это подавление запуска рекурсии на следующий рескан, а Ивал — это форсирование
вот этого подавленного запуска рекурсии. Вот такая техника. Постоянно используются всякие
перепроцессоры буста на этом основу. Ой, теплы. Мы уже видели, ну просто скажу, что вот такие
штуки через запятые — это теплы. И с ними можно работать, ну примерно как типа с чем-то в хаскеле,
что ли. Потому что просто в начале дописываете название функции, достающий элемент, и вы как бы
вот достали из теплый элемент. Просто вот такая последовательность токенов считается теплом.
Вот. Ну и их там можно как нервыть, если очень там извернувся, наверное, всякие другие штуки
делать. Мы этим заниматься не будем. Мы вместо этого еще накинем сущность такую, типа контейнер
времени при процессинга. Контейнер называется «листы». Наша любимая. Head и tail. Вот эти,
это tuple, да, из двух элементов пара. Только есть пара из двух элементов, у нас с автоматом есть
листы. Head — это первый элемент, tail — это второй. Вот какие-то листы тут написаны. Прикольно?
Прикольно. Ну, еще надо, конечно, научиться проверять, что мы в конце листа. Опять,
чтобы вот эти рекурсии прерывать и тыры-пыры. Ну, тут примерчик точно такой же, как мы только что
видели с чеком. Что тут происходит? X дописывается к лист-энду. Видите? То есть там какой был трюк.
Мы к... что-то там, что-то там добавляли двумя решетками токен. Если он был end, то у нас
слопалось. Здесь вместо этого мы после лист-энда пишем справа X. А дальше зададемся вопросом,
а что это будет, когда X подставится? Либо это будет вызов макроса, который принимает
что угодно, вот этого лист-энда, либо это ничего не будет. Ну и, соответственно, что такое хвост у
такого списка из одного элемента? Это пустая последовательность токенов. Соответственно,
если х это была пустая последовательность токенов, то ничего не произойдет. А любой не пустой список,
это как минимум круглые скобки. И когда мы их допишем к лист-энду, это будет инвокация вот
этого макроса функционального, и у нас раскроется в запятая ноль. Ну и опять старые фокусы. Берем
второй элемент теплее, вот если запятая лишнее вписалось, то там он меняется, и вот мы научились
проверять. Вот, еще пример вот этой техники. Есть вопросы по этому?
Что? Ну тут никогда не будет лист-энда с пустыми скобками. Ну, тоже запятая ноль.
Вот этот вот. Да, тоже запятая ноль. А лист-из-энд. Ну, выдаст true. А нет,
это не будет запускаться даже. Здесь же не врядик, здесь токен нужен.
Это не является корректным списком, вот ответ. Эта штука работает корректно только на корректных
списках. Корректный список это либо голова запятая хвост в скобках написанная, либо пустая последовательность
токена, в которую здесь можно получить только как хвост для вот этого.
А в этом смысл. Не чувствуешь, да? Вот tuple это разделенные запятыми последовательность в скобках.
Почему она в скобках? Чтобы можно было запускать макросы и функции на этом тюпле, тупо дописывая
слева название этого макроса. Мы тупо дописали. Вот эта вот вся последовательность это tuple. Все,
что в скобках, грубо говоря. Мы тупо дописали слева название и запустились. То же самое тут.
Мы хотим тупо дописать к листу. Вот есть лист. X это лист. Мы тупо к нему дописали слева название
макроса и запустились от этого листа. Тут другое соглашение о том, как оно работает.
Ну можно было сделать так, можно было сяк. Ну вот так получилось. Другого ответа нет.
Ну идея, надеюсь, понятна. Я просто крикаю, пустой лист как записывается?
Пустой лист никак не записывается. Нельзя записать. Вот лист tail 9 и пустое. Ну вот так только.
По-моему нету такого способа пустую последовательность. Ну короче, никак. Да, никак не записывается.
Окей. Ну это еще не последний контейнер времени, компиляция. Ну вот про листы времени при
процессинге. Да, про листы я тут не особо много чего написал, но с ними тоже всякие операции
можно делать. С теплами не только эти можно, и с листами тоже не только эти. Если постараться,
там можно очень-очень разные штуки делать, но каждый алгоритм на вот таких вот структурах,
это нужно сидеть и минут 30 втупливать, чтобы понять, что происходит, и потом
я понял, но у нас нету столько времени. О, я забыл, да, потому что это невозможно просто.
Домашнее задание на отл 20. Ну вот последний контейнер, давайте уже дотянем, это гайды.
Гайды. Знакомьтесь, вот эта маленькая шняга, это гайд. То есть это последовательность чего-то,
разделенное скобочками, улыбочками. Вы понимаете, что мы собрались делать, да? Вот как бы теплые листы
были так сделаны, чтобы можно было слева дописать имя и запуститься. Ну вот как бы теплый, это всегда
уже со скобками, значит просто слева дописываем название макросса и запускаемся. Гайды сделаны
так, чтобы слева надо было дописать название макросса, открывающую скобку, и все, оно дальше запустится.
Если вот к этой гайде, если к нему слева дописать там фу и открывающую круглую скобку, то мы запустимся
в первого элемента гайда. Ну и давайте как бы перед тем, как перейти к вот этой вот жесте,
которая будет на следующем слайде, посмотрим, как нам последовательность, я помню, у нас был
sequence, вот этот вот, это sequence был, как его конвертировать в гайд в качестве такого упражнения работы над
sequence и чтобы не оставалось сзади хвоста, да, вот к этому же. Что тут происходит? Нас интересует
to-guide, to-guide берет sequence, ну вернее берет, ну да, берет прям весь sequence и пихает в некоторую
рекруссивную шнягу. Sec term, ну это рискан по сути, что там еще за RM, вообще неважно,
а to-guide-a применяется к секу, да, к секунсам функции, так же как к спискам или к тюплам,
применяется дописыванием слева. To-guide-a что делает? Берет и все, что в первых круглых скобках этого
секунса просто имитит, пишет, да, правую закрывающую скобку пишет, ну через macros,
чтобы оно отложено происходило на самом последнем рискане, тут в это надо поверить, просто что вот так
работает, если сразу написать круглую скобку, то не работает. Потом empty, чтобы еще вот этот вот rparen
отложить совсем на давний, на поздний рискан, да, если бы не хватило вот этого empty, можно было бы
еще один empty написать, и тогда бы мы там на три рискана отложили подстановку скобок, чтобы в
самом последнем моменте, и дальше идет to-guide-b, но так как мы как бы вот это вот to-guide-a заменяем на всю
вот эту шнягу, то мы как бы, да, откусили первый элемент, когда запустили вот это вот все, заменили
его на один закрывающую скобку, а дальше написали to-guide-b, и он применяется к секу, ну и дальше мы как бы
идем, идем, идем, идем, применяемся, применяемся, применяемся, и в какой-то момент дойдем до вот
этой вот оставшейся скобочки, которая нас волновала, ну, до чего оставшегося, to-guide-a останется
какой-нибудь, да, когда вот этот вот sequence весь исчерпается, останется to-guide-a, был вопрос, как от него
избавиться, вот здесь ответ, вот эта вся шняга завернута вот в этот вот сектер, который конкатенирует
воаркс с нижнее подчеркивание рм, что это значит? Это значит конкатенируем вот это, to-guide-a, последний
токен из этого воаркса, да, потому что вот это вот все, to-guide-a сек, он же развернется в куче кучи
токенов, и в конце будет какая-то to-guide-a, наверное, да, вот последний токен воаркса, он будет
сконкатенирован с рм, ну, потому что воарксы раньше вот этих двух решеток, оказывается, раскрываются,
соответственно, это распарсятся как кучу кучу токенов, потом последний токен, вот же он,
to-guide-a, конкатенируем с рм, получили to-guide-a рм, который задефайнен на пустую эту, вот мы
избавились от последнего элемента в рекурсии на секунсах. Это похоже на лютую жесть, но тем не
менее, мы конвертировали вот такую последовательность с открывающими скобками в секунс, в последовательность
только с закрывающими скобками. Вы помните, как работает прохождение по такому секунсу?
Как бы define-a от чего-то b, define-b от чего-то a, они так сжирают, сжирают, сжирают,
имите перед собой то, что было, и в конце концов, вот этот вот a или b, оно как бы до конца доехало,
осталось последним. В самом начале про это говорили, отсылочка. Так, два человека, кажется,
поняли, возможно, три или четыре, ну вот такая шняга. Окей, а нафига нам гайды нужны? По ним можно
делать fold, накапливать контекст по дороге с этим сворачиванием всем. Надо морально собраться,
да? Это вот последний рывок. А нет, подождите, у меня еще полчаса. Вообще нормально. Ну сейчас,
сейчас тогда все успеем, получается. Вот куча кода. Знакомые нам tuple.at1 и checking. Мы уже запомнили
примерно, как этот алгоритм работает. Ну читать, наверное, надо с конца. Я хочу написать конкатенацию
последовательности. Через последовательности это особо не пишется. Непонятно, как какой-то контекст
протаскивать, что там накапливать. Не получится. А по сути, что надо сделать? Пройтись по этой
последовательности и накапливать уже сконкатенированные префиксы. Просто так это не
получается. Поэтому cat.seq определен как cat.guide, tu.guide от sec от end. Зачем здесь end? Ну пока непонятно,
да и неважно. Но главная идея, что мы будем по гайду идти, а потом... Это теперь последний элемент
последовательности. Окей, да. То есть sec от end, это мы как бы к sec дописали еще один, вот к этому,
еще один элемент, end. И вот tu.guide он... Ну зачем-то ему нужно, короче. Вот tu.guide он с этим справится,
и cat.guide уже сможет сконкатенировать. Окей, tu.guide мы видели, поверили, что вот эта вся
последовательность превратилась в правильный гайд. Ну вот такой вот, да. Но в конце еще end
написан. И теперь начинается интересное cat.guide. Где он? Я потерял. Вот он. Да, мы опять имеем пару cat.guide
A, cat.guide B, будем их чередовать. Но cat.guide A уже запускается каким-то вообще невероятным образом.
Он запускается открывающая скобка запятая и гайд. Да? Что произойдет? Ну вот cat.guide A и cat.guide B они
принимают внутрь контекст и один элемент гайда. Один элемент. Тут пустой контекст, и первый элемент
гайда это будет, ну вот эта единичка, потому что гайд состоит из один закрывающая скобка, и это будет
вполне себе легальная инвокация вот этого макрос, cat.guide A от контекста пустого единички. Ну и понятно,
что дальше мы собираемся cat.guide A сделать так, чтобы он раскрылся в примерно такую же конструкцию,
только здесь B должно быть. Будет cat.guide B, открывающая скобка запятая, и остаток гайда,
он как бы снаружи от всего этого. То есть вся вот эта вот чехарда, с которой мы будем разбирать,
с cat.guide A к cat.guide B, она происходит со всем, что до второго элемента. То есть только вот эта
закрывающая скобочка и единичка. Все остальное остается нетронутым. И когда вот этот cat.guide A
полностью отработает, он сюда допишет cat.guide B, но он уже схавал вот эту один закрывающую скобку.
И мы, ну когда cat.guide B будем раскрывать, мы будем использовать уже двойку и закрывающую скобку.
Потом опять cat.guide A получится и три закрывающие скобки. И вот так пойдем сжирать-жирать эти циферки
и закрывающие скобки. Контекст? Да, сейчас увидим. Ну во-первых, что здесь происходит? Тут опять
какие-то чеки лютые. Чек проверяет, пришел ли нам вот этот end. Мы уже там представим,
что мы понимаем, как этот чек работает. Кажется, это действительно правда. Вот x пришел,
мы присоединяем. И того, что? Зачем нам этот чек? Чтобы если получилось, что мы в конце,
то мы сюда бы вписали cat.guide end и в общем мы выбираем, куда пойти. Это if при процессоре,
да, по сути. Либо в cat.guide next идем, если еще не конец, либо в end. В next что мы делаем?
Мы прокидываем, во-первых, контексты x, а в третьих, что дальше запустить? A говорит дальше запустить B,
B говорит дальше запустить A в самом вот там конце. И cat.guide next просто берет cat.guide,
прилепленное next, контекст и к нему элемент прилеплен. То есть весь алгоритм конкатенации
он на самом деле вот в этой строчке содержится. cat.guide next. Все остальное это инфраструктура,
чтобы дойти до конца, а потом в конце мусора не оставить и вот это вот все. Вот, ну и вот
она главная идея, что когда у вас вот эта шняга раскроется с первым элементом гайда, у вас останется
cat.guide B с контекстом, к которому приконкатенирован первый элемент, накоплен, да, как бы вот фолт он
вот ровно здесь происходит. И запятая. А дальше уже второй элемент гайда остался. Вот он идет там,
ну есть. Ну и нужно дальше идти сканировать, и оно будет раскрывать, раскрывать, раскрывать. И в итоге
вот в этом контексте постепенно каждый элемент гайда будет к нему приконкатенирован. И, соответственно,
в самом конце в cat.guide end мы выйдем от контекста, будет 1, 2, 3, 4, 5.
Ну, видимо. Ну, на секунсах непонятно, как контекст где накапливать. Если просто в аргументы,
то оно получится, что да. Нет, если слева мы пишем, то мы ничего не рисканим. Ну, когда мы просто
слева дописываем это, то тут без рисканов можно обойтись. То есть Ewaldifer, которые позволяют
рисканить много раз, тут не нужны. Просто мы как бы слева пишем, вот да, когда проходимся по секунсу,
мы слева дописываем то, что там осталось. А контекст куда пихать? Ну, непонятно. Мы как бы к тому,
что уже было раньше, не вернемся, когда по секунсу идем. Потому что мы свою рекурсивную инвокацию,
мы ее пишем после ответа. Вот мы обработали что-то, элемент, выдали ответ, и после него пишем
следующий вызов, то Гайд Б. Да, вот это легко трансформировать, то есть мап делать,
поэтому. А вот это легко фолдить Гайды. Вот мы Гайды сфолдили. Поднимите руку, кто понял,
как фолдить Гайды. Ну так, плюс-минус, да? Ну нормально, нормально. Лотыш, конечно,
таким не заниматься, да. Особенно на публику. Ну, жертвую собой. Да нет, ну лучше дома запереться,
в ванной, чтобы никто не видел таким заниматься, стыдно же. Кто-то хочет переспросить и попытаться
все-таки доразобраться, как работает этот фолд по Гайду. Как он работает, понятно. Все, все ясно. Все,
совсем все. С теплами так непонятно. Ну, ни с теплами, ни с секунсами, ни с листами непонятно,
как накапливать какой-то контекст, идя по дороге. Потому что, когда ты секунс, проходишься по нему,
да, ты какой-то результат обработки одного элемента, ты его пишешь слева от рекурсивного
запуска. Вот слева ты написал ответ, вот он. А рекурсивный запуск у тебя дальше, правее. Это
кардинально отличается от Гайдов, потому что с Гайдами ты следующий запуск пишешь левее, чем
свой ответ. Вот твой ответ, а запуск он как бы слева. Понимаешь? В тюплах, нет, в секунсах. В тюплах,
и вообще не знаю как, а вот тут, если попробовать, может получиться, но вот, я говорю, это невозможно
в голове представлять никогда. У тебя сто процентов будут проблемы с окраской, с рисканами и вот этим
всем. Ну вот, скорее всего, можно. Если ты готов Эвал Дефер использовать вот этот вот рискан запускать
300 тысяч раз, то, конечно, все можно. Но если ты не готов, то как бы приходится вот так извращаться.
То есть, да, формально тут можно протащить еще один аргумент и как-то его там делать. Ну вот,
я говорю, в рисканы уткнешься. Вот Андрей изначально правильно сказал, получается.
Можно спросить, почему этот улыбающийся хрень называется Гайд? Понятия не имею. Ну вот,
тем не менее, такое есть. Кто-то это даже использует, наверное, в проде. Я за них боюсь. Вот. Давайте
последний прикол, убойный. Андрей, ты же был на этой лекции в прошлом году или нет? Не особо что-то
помнешней. Эта лекция не очень хорошо напоминается. Да? Ну ладно. Ну да. Каждый год как в новый,
потому что это, конечно, все мда. Читаем сверху вниз. Читаем сверху вниз. Объявили слот. 2 умножить на 3
плюс 1. Заинклюдили какой-то волшебный слот.с, магический. И у нас теперь в макросевал посчитан
результат. Вот это вот выражение. Перемножили, прибавили. Вот он посчитан. Теперь undef-нули слот.
Выкинули. И задефинили заново, как старый вал на минус 1. Слот заинклюдили. Декрементнулся. Вал
превратился в вал минус 1. Еще раз заинклюдили, еще раз декремент произошел. Как это? Что это такое?
Ну хорошо, undef-нули задефинили. И там вообще какие-то там ксоры, оры побитые, знак больше.
Чего только не впихнули. Заинклюдили слот. Вычислилась. Как это работает? Почему это работает?
Это вообще возможно. Но сейчас будет магия. Ну как ты напишешь, такие ограничения и будут. Давайте
смотреть. Приоткроем завесу тайное. Мы задефиним все комбинации бит. По количеству бит, которые нам
по факту нужны в наших числах. Ну тут как бы я, вот здесь немножко лукавлю, потому что там более
сложный код. Вот здесь я как бы за три бита не выпрыгивал по факту в размере ответа. Ну вот мы
задефиним. Если вам нужно 16 бит, ну делайте побольше их. Побольше строчек. Какие проблемы. Вот задефинили,
а дальше задефиним вот такой вал ц. Прикольный. Ну он опять на два разбит, чтобы рискан был. Вал
ц берет и квал нижнее подчеркивание дописывает а и б и ц. Тем самым вызвав вал ц от там последовательности
нулей единиц, мы получим одно из вот этого всего. Так, а дальше вот этот слот точкой h, но он был
c, теперь h, не важно. Дальше мы если у нас нет какого-то a0, инклюдим a, если есть, то инклюдим b. Зачем
это? Ну чередоваться. На четных инклюдах слота мы будем инклюдить a, на нечетных инклюдах слота
мы будем инклюдить b. Ну, я думаю, вы можете представить, да, как это. В секундах тоже самое было,
да, мы чередовали a, b, а тут мы будем файл, который инклюдим, чередовать. Что? Пока непонятно. Сейчас
увидим. Ну вот как факт, оно чередуется. И код там будет примерно одинаковый с точностью до симметрии.
Какой код в a? Берем, что у нас в этом слоте написано, да, вот это выражение наше. И с помощью вот этого
решетка if, помните, я говорил, что он все выражения умеет считать, да, и с помощью вот этого ifa любое
выражение мы во время припроцессинга посчитаем, возьмем первый бит и объявим a0 в единицу, ну иначе в 0.
Ну и дальше идем. Если второй бит выставлен, то а1 будет либо 1, либо 0, если там третий бит
выставлен, и вот так, сколько надо, столько и напишите. Теперь через вот этот макрос вал c,
который мы только что определяли, да, вот он вал c, задефиним вал как комбинацию всех вот этих
вот штук и получим нужное нам число. Работает. Ну и вот тут какие-то b0, b1, b2, они дефинятся,
но это на самом деле что такое? Это вот симметричные вот этим вот a0, a1, a2 в b-шке
дефинятся b0, b1, b2. Ну и вот просто абсолютные симметрии, они чередуются и друг друга они
дефинят. Вот. Теперь зачем такое чередование? Надо почувствовать, что когда мы дефиним слот как вал
минус 1, нам нужно старый вал не побить как бы. Старый вал, он на самом деле является там каким-то
вал a, чем таким или еще, ну не совсем, ну короче ладно, старый вал нужно не поломать и вот ровно
чтобы вот такое вот использование вал внутри слота работало, нужно четное и нечетное. Вот. То есть
это сохраняет старые там v-шки до момента, когда мы уже определили новые. Понять, почему это так
работает и по-другому не работает, сложно да и не нужно, но почувствуйте силу, что мы типа научили
препроцессор быть калькулятором. Но зачем? Но научили. Вот и на этом в целом.
Ну потому что у тебя, если ты раздефинишь v-шки, то вот этот вал, он мог быть задефинен на не
просканированное что-то. То есть вал-то у нас как определяется? Как вал c и вот это вот нужно
рисканить. То есть когда ты просто пишешь вал, у тебя на самом деле не сразу подставляется число,
у тебя подставляется вот это выражение, которое дальше продолжает сканироваться, еще сканироваться
и только там через несколько раскрытий получаешь число. А в процессе этих раскрытий ты к чему
придешь? К 2, 1, 0. И если ты уже старые а-шки раздефинишь вот здесь, то новые типа ну короче вот так.
Ну ладно. Что? Что значит материализовать? А вычислить нет, потому что ну
хорошо, ты можешь написать наверное 3 скана от вал и нет, все равно не получится.
Ты же не можешь зафорсировать. Да, то есть ты когда дефинишь новые макросы, ты не можешь
форсировать раскрытие чего-то старого. Поэтому приходится вот такие вещи делать. Все раскрытия
все равно отложены на момент, когда твой макрос уже будет посчитан. Здесь никаких раскрытий не
будет происходить, кроме как аргументов. Но аргументы тут тоже нам не очень подходят. Вот,
ну вот такая шняга есть. Слоты. Память в припроцессинг тайме с калькулятором.
Это было очень опасно. Мы уложились, поэтому мы можем посмотреть на бонус. Зачем я рассказывал про
эти слоты? Ну, с ними можно наломать дров. Так, это все нам не нужно. Мы сейчас... ну, кстати,
к вопросу гайдов, это вот здесь. Ну, давайте посмотрим. Ну, в общем, include date. Сейчас,
так, история. Когда я вот это увидел, я тоже такой, что? И, в общем, мне понадобилось где-то час сидеть
и вдуплять в эти там пару строчек, чтобы понять, что имеется в виду. И с тех пор я уже забыл. Ну,
вот, кстати, chaos pp есть. Вот ровно слоты происходят. Вот наш... ну, pp — это припроцесс.
Да, boost pp ket. Обычное название какого-то макроса из буста.
Вот, ну, в общем, что-то тут происходит невероятное какое-то. Include chaos pp assigned slot file function
table indexed as slot number 0. Хотим попробовать понять, что тут написано? Вот я боюсь,
что опять долго понадобится думать. Ну, вот тут ссылка какая-то есть. Может,
нам там еще сразу картинку покажут? Что? Так, я не понял, куда смотреть, чтобы смеяться.
Ну, pp map dd. Ладно, тогда не надо. Да, короче, что они делают? Они в compile time умудряются
выяснить, что лежит в таймедейте. А, распарсить таймедейт. Я забыл, честно. Вот я в прошлом году
про это показывал, потому что это было прикольно, но сейчас мне уже стало так грустно. А, ну, вот они
парсят типа дейты тайм на... О, полезно. Ну, типа если 2036 год или больше, то они компилируют.
А, все, господа, я вспомнил. Короче, зачем это нужно и что это делает? Дея следующая и проблема
следующая. Вот, вот идея. Вы создаете 3 мегабайта пустых файлов, у каждого из которых название
соответствует какой-либо дате. Вот, а дальше include соответствующий файл через include date. Вот. Ну,
то есть вот про что это. То есть это буквально include date и в зависимости от сегодняшней даты
будет include разный файл. Чувствую сарказм, но... Да, вот как... Ну, это же жесть, ну просто жесть.
Ну, давай все, закроем это, не будем дальше. Просто отвратительно.
Я хотел показать прикольную штуку, но мы еще отвлекаемся. Прикольная штука, а где она была?
Наверное, как раз в слотах. Вот, слоты нас интересуют. Ну, тут тот самый пример,
откуда он сперт, вот ровно отсюда. Ну, где она? Видимо, вот внимание. Вот тут интересно. Вот,
можно с помощью слотов сделать нечто невообразимое. И вот тут как бы некоторое... Да, рекурсивный
include как бы. И мы... Вот как бы проблема в чем? Мы делаем слот, который value уменьшает. А дальше
мы смотрим. Вот value оно не ноль. Если не ноль, то include себя. А мы что делаем? Мы define слот как
value-1, вычисляем его. И если не ноль, то include себя. Ну, вот мы так по сути include себя столько
раз, сколько надо, и дойдем от 7 до единицы, и вот как бы вот. Понятия не имею. Наверное,
есть. Ну, любые вещи есть ограничения. То есть вот как бы изначально инициализация с семерочкой,
вал вывели и дальше пошли рекурсивно include себя. Вот. То есть можно как бы в слотах хранить
какие-то данные персистентные и даже это модифицированные данные. Ну, слот значения
value можно менять. Это прям read, write, память. А дальше мы можем идти в рекурсии через вот include
самого себя. И как бы в слотах можно закодировать состояние машины тюринга, а шаг машины тюринга
сделать через вот эту рекурсию. Соответственно мы получаем такую хитренькую полноту по тюрингу.
Мы можем выполнить любую программу полную по тюрингу с наперед заданным количеством
итераций. Вот если ограничиться там десятью итерациями, то мы можем взять вот десять
вписать за хардкодить программный код, и вот мы как бы в какой-то степени полны по тюрингу. Ну,
и что это позволяет делать? Ну, вот тут есть примерчик жуткий. Вот. Define attrition file. Такой-то
радиус берут. Какие-то константы. Начинают творить какие-то непотребства с каким-то языком
вычислений в припроцессоре. То есть вот это совсем что-то убойное. Вот этот ордер pp,
это там некоторое ответвление chaos pp, видимо, или какой-то бонус к нему. И вот этот ордер pp
он интерпретирует некоторый простой язык, который с виду похож на lisp. То есть, ну, я вот сейчас не
удивлюсь, если они типа интерпретатор lisp'а написали на макроссах. Ну, давайте выясним.
Нет, ну, не знаю. Нету документации, да? Вот, doc есть.
Ну, это прям какой-то интерпретируемый язык, с виду похожий на lisp. Наверное, не совсем lisp.
Который интерпретируется в момент припроцессинга. И вот они на этом смешном языке написали
какой-то небольшой типа скрипт, да? И типа что-то такое тут написано, но, по сути,
здесь написано уравнение сферы окружности. Не знаю. Что-то происходит жуткое. Возможно,
это объявление функции. Наверное, это объявление функции, это у нее аргументы,
радиус x и y. А тут дальше даже принт какой-то. Ну, видимо, да. И, типа, вот,
какой-то equation проверяют по чему-то. Видимо, это x и y. И печатают пробел. А, нет, стоп. Это символы
просто. Да, кажется так. Типа, если у нас уравнение окружности, которая... Наверное,
ниже. А, вот оно. Во-во-во. Вот, заодно, уравнение окружности, x в квадрате плюс y в квадрате меньше
радиуса в квадрате. И если вот это уравнение верно, мы печатаем процент. Иначе там тильду и
пробел и еще что-то такое. Ну вот, а потом начинаются какие-то абсолютные непотребства.
Вот задаются какие-то параметры итерации. И дальше вот в этом скриптовом языке как раз
какой-то forage делается. Вообще убойно. Ну и forage, как вы можете догадаться,
он делается ровно через include самого себя с новыми значениями в слотах. Вот. И, типа,
йота. О, прекрасно. Наш любимый yotaview только в припроцессоре. Вот как бы для каждого значения
в радиусе, видимо. И для этого это, видимо, вложенные циклы. Ну, короче, по x и по y пробегаются
в рамках квадрата по всем координатам. И, в общем, когда вы припроцессор запускаете на этом файле,
вы получаете круг. Видите круг? Вот круг. Что? Ну да, если
вы просто припроцессинг запустите на этом файле, вы получите вот такой круг. Ну, вы же видите круг?
Я вижу. Вот. То есть просто на припроцессоре написали скрипт, который выдают круг. Вопрос,
можно ли написать на этом raytracer простенький? Я думаю, что да. Ну вот. Если вам скучно и нечем
заняться, напишите raymarsher на припроцессоре через вот это вот. Собственно, у меня на это все. Вот
это самое убойное, что только можно представить. Да, процент двоеточий — это диграф, который
превращается в решетку. Зачем? Не спрашивайте. Есть европейские клавиатуры на раскладке? Нет,
это да. Зачем они изначально были нужны? Это понятно, но это, конечно, идиотская идея,
абсолютно. Ну как бы поменять раскладку? Нет. Ну вот, их включили в язык. Вопрос в том, почему
вот эти строчки с решеткой, а вот эти с диграфом? Это явно влияет. Это явно имеет прям какой-то
смысл жесткий, чтобы не решетку, а диграф использовать. Но я не понимаю, какой. Ну да. Ну вот. Я
надеюсь, вы разочарованы в жизни в языке C, макросах и вообще всем на свете. Больше никогда не будете
писать макросы. Вот. Но, видимо, нет, да. Черт. У меня в ходовой классе есть несколько макросов, которые пользуются вести. Ну такой у всех есть,
и, к сожалению, пока такого не избавится. Но это, мне кажется, прям... Но хорошие макросы, они более
Ну окей, но вот это, это прям застрелится. И хорошо. Так, наверное, надо заканчивать. Вряд ли
какие-то вопросы есть по вот этому. Поэтому давайте останавливать запись и расходиться.
