Добрый день, как я собрал вас, чтобы сообщить вам про неприятие известия.
Помимо пришедшего сюда ревизора, похоже, наш проектор, что и аудитории объявил нам санкции.
И более не работает 239 аудитории.
Похоже, что в санкции скоро нам объявят всякие процессорные системы.
Придется написать их самостоятельно.
Ну и как же это мы сделаем?
Есть такие вот замечательные примеры.
На I7A2 рождили язык ассамбля.
Который мы сейчас соберем и попробуем запустить.
А в частности, вот такой код.
Hello world from diskette.
Берем этот код.
И собираем.
Собирать будем в простой бинарный формат.
Нас выдал размером 512 байк.
Очень такой характерный размер.
Совпадающий, как и странно, с размером сектора на большинстве устройств, в которых можно добиться.
На дискетках, жестких дисках, флешках, оптических дисках.
И как же он работает?
Во-первых, обратите внимание, сколько бит на это код.
16 бит.
Потому что все наши x86 компьютеры в момент старта работают в 16 битом реальном режиме.
И только выгрузившаяся операционка переключает их вообще остальные.
Базовая система ввода-вывода, она же BIOS, закинет.
Вот это самое первое сектор, считанное загрузочным устройством.
Если он, конечно, имеет сигнатуру.
Вот эти два байта, а5.5 указывает на то, что сектор у нас загрузчий.
Расположит по адресу 7C00.
Видим, что для этого достаточно 16 бит на адреса.
И передал с управлением.
Все, а дальше эта операционка загружается сама.
Все, а дальше эта операционка загружается сама.
Без всяких габилетик.
Все самостоятельно.
Вот мы оказались здесь.
И запрещаем все прерывания.
После этого обнуляем AX.
Заносим в регистр дат сегмента, стэк сегмент, этот самый 0.
Стэк-поинтер у нас будет расти, начиная с от нашей метки старта.
А пересекутся при этом стэк и код.
Стэк растет у нас вниз, в сторону уменьшения адресов.
Код растет в сторону увеличения адресов.
Так что они не пересекутся, как раз не подерутся.
После этого мы прерывания разрешаем.
А вдруг кто-то в этот момент прервет нашу работу и что-то не будет на порту.
Это для нас очень критичное зеркало.
После этого мы хотим позвать функцию.
У нас свои операционные системы соответственно свое соглашение вызовет.
В качестве соглашения вызовет договоримся, что мы как в современных системах передаем все через регистры.
В частности через регистры SE.
Передаем аргументы через SE.
И вызываем нашу функцию капусту.
Целые функции с помощью команды loadSB мы делаем сразу кучу вещей.
Загружаем по адресу SE 1 байт в регистр AL и увеличиваем это самое SE наедине.
И загружаем и увеличиваем.
Да, это циск.
Проверяем.
Делаем побитого умножения AL на AL.
Результат выбрасываем.
Но у нас что-то остается.
В чем остаются следы вычислений?
Да.
И мы смотрим не поднялся ли у нас лок-нуля.
Нет, не поднялся.
Тогда продолжаем работу.
А если поднялся, куда-то прыгнет.
А что означает у нас, что в некой строчке у нас встретился нулевой байт?
Строчка закончилась.
Все как в обычных SE строчках.
После этого мы все-таки решили с биосом нашим пообщаться.
Пока еще мы имеем такую возможность.
Через прерывание, а аргументы на него передадим через регистр.
В AH заносим, что мы от него хотим, вывести символ.
В AL сам символ.
Нет, сам символ.
И прыгаем обратно на начало SE.
Если же мы упрыгали на вот эту метку, выходим из функции.
Ну а после этого мы запрещаем все прерывания.
Никто нашу программу не прервет.
Мы имеем на это право, потому что мы находимся в реальном режиме процессора.
Никто нас не ограничивает пока еще.
Остановим процессор.
Если этого не хватило, делаем бесконечную цепь.
Прыгаем на то место, где сейчас находимся.
Вот наша данная.
Строчка.
Два байта ее завершающий перевод строки.
Потому что BIOS как и многие антикварные системы используют два байта для завершения строки.
Нулевой байт для окончания строки вообще в конце сигнатура.
А дальше нам нужно заполнить все это нулями до размера 512 байтов.
Чтобы сигнатура оказалась в нужном месте в конце этого секр.
То есть, 510 минус текущее положение минус начало.
Почему 510 и не 512? Потому что вот еще два байта.
Просто 0.
А для того, чтобы все это запустить, мы воспользуемся,
поскольку он у нас нужен для того, чтобы все это писать и показывать, виртуальный машин.
Виртуальный машин.
Вот она.
Oracle VirtualBox.
Создаем новую виртуальную машину.
Да, там будет что-то другое.
Наша.
Четырех мегабайтов хватит всем. Жестких дисков нам не нужно.
Зато мы добавляем floppy-контроллер.
Почему нужно дискет? Потому что у них наиболее простая конструкция.
Там нет разметки на разделы.
И это существенно упрощает нашу работу.
По созданию такого загрузочного порта.
IDE-контроллер нам не нужен.
И к этому floppy-контроллеру мы добавляем образ нашей виртуальной дискетки,
который собрал нам нас.
И запускаем.
Разворачиваем побольше.
Вот наша операционная система сумела загрузиться.
Сигнат того есть.
И дальше операционка.
И даже выбрал нам текст.
Можно операционкой выходить что-нибудь еще.
Сейчас у нас был один единственный процесс.
Работающий в режиме реальном.
То есть ему можно все управлять в 16-битном.
Хочется чего-то большего, чем 16-бит.
А в 16-битах какие адреса мы можем адресовать?
Сколько памяти мы можем адресовать в 16-битном режиме?
Ну хорошо. Мы можем адресовать каждый отдельный байк.
Именно. Два шестнадцатого байта.
Как-то не очень много.
Ну нам хватило. У нас вообще весь код нашей операционки 512 байтов лет.
Нам хочется адресовать побольше.
А допустим в 37-битном режиме мы сколько сможем адресовать?
Это сколько?
Где-то 4 гигабайта.
Мега? Вот что вы на таком компе габали.
На 4 гигабайтах.
Все-таки математическая школа умеет считать.
4 гигабайта.
Вот это уже явно прииск.
А еще мы хотим чтобы у нас были...
Еще какие-то...
Процессы. И чтобы они друг с другом не передрались.
А для этого нам нужно чтобы процесс переключился в защитном режиме.
Так. У нас есть всяческая магия.
А может быть кто-то из вас читал толкины?
Есть такие? Кто толкины читал?
Ага. Хорошо.
Все приключения Борсеточника по кличке Бильба были из-за того, что он спер некий магический артефакт.
Какой?
Кольцо.
Ага.
С некое кольцо.
Какие-то кольца предназначались у нас для всяких эльфов.
Ну, в частности программа Вэйс Пиддогла из мутного формата.
Может быть там вводятся также всякие гномы.
Ну, в общем моды и environment.
Один из вариантов графического интерфейса.
Вот. Нашелся поклонник гномов.
Формат finals-dwarf тоже есть.
Ну и гном это аббревиатура.
Сколько-то их там было? Ну, минимум штучки три.
Ну и самое главное.
Что там было?
Что там было?
Две централизации управления всем этим. Из некой башни, типа той, в которой мы сейчас находимся.
Одно кольцо, чтобы править ими всеми.
Хуже всем этим.
Вдохновлялись разработчики Intel и AMD, когда создавали кольца привилей.
Так.
Было для архитектуры x86 сделано изначально четыре кольца привилей.
Изначально четыре кольца привилей.
Ну, роздавая всем гномовым людям третье кольцо.
Для того, чтобы просто работала какая-то предлагательная программа.
В каждом следующем кольце у нас доступны все те регистры и команды, которые в предыдущем, но доступны еще какие-то.
Предполагалось, что второе кольцо это чуть-чуть больше прав.
Может пригодиться для чего-нибудь типа атлантчика.
Первое кольцо еще больше прав для каких-нибудь программ, управляющих физическим устройством, драйверу.
Ну и наконец нулевое кольцо, чтобы править ими всеми.
Там располагается ядро торцовной системы.
На нулевом кольце привилей.
Что же получилось в реальности?
Реально эксплуатируется третье кольцо для обычных программ и нулевое кольцо.
Потому что разработчики операционных систем забили на возможность и полезность того,
что какой-нибудь драйвер будет работать так, чтобы не стеснить всю операционку.
И обычно получается, что все ядро и все его модули работают на нулевом кольце привилей и можно все.
Ну, как и в Толкина, там развелись всякие, помимо этих колец, развелись всякие мудрые энты и прочее.
Потому что внезапно выяснилось, что мы хотим запускать операционку, чтобы она ничего не подозревала, что она на компания 1.
Ну и появились дополнительные расширения для виртуализации.
То есть, вот все этот метод VirtualBox, который мы продемонстрировали, работает за счет того, что у нас есть расширение.
Например, какие у нас есть способности у процессора?
Что он у нас умеет?
Процессор у нас интеловский.
А где-то там среди флагов должна быть его возможность и поддержка Intel VTD.
И вот это все.
В AMD, в MX, в общем, какие-то...
На самом деле, все эти средства безопасности, как выяснилось, еще несколько дырявые, и через них кое-что может потенциально проплавиться.
Но до сих пор все эти технологии используются, баги падятся, типа не будем создавать условия, в которых что-то может быть записать куда попало.
Но чтобы это работало, нужно это хотя бы включить.
Так, попробуем это включить.
Тут все по-старому. Обнуляем сегментные регистры, стэк у нас растет от начала кода вниз.
Дальше мы должны описать глобальную таблицу дискриптеров.
У нас тут будет три дискриптера, которые описывают три кусочка памяти.
В частности, будет нулевой дискриптер.
Если вы пойдете по нулевому адресу, то что с вами будет, судя по опыту написания программы CES++?
Вам скажут, что вам туда идти нельзя, и программу срочно предприят.
Еще два сегмента.
Это сегмент кода и сегмент данных, начинающийся по нулевому адресу, лимитом в 4 ГБ, чем-то не отличаются.
Хотя оба предназначены для нулевого кольца привлеки до того самого тронуземол.
Но посмотрите внимательно, в чем между ними разница.
Если вы не заметили, то у сегмента кода есть вот этот битик, а здесь это битик-брос.
Вы подумайте, что это битик означает?
Какое право нужно сегменту, в котором есть исполненный плод, но не нужно сегменту, в котором есть просто данный?
Да, правильное исполнение. Вот он, битик правильный исполненный.
Ну, это один из методов, которым пытаются затыкать всякие были.
Давайте мы пометим, что вот эти кусочки памяти мы можем исполнять, и в эти кусочки памяти мы можем писать. Желательно, чтобы они не пересекались.
Ну, а значение, которое будет загружено в GlobalDescriptableTail регистр, это ссылка на массив ГДТ с дескрипторами и вот эта константа.
Ну, дальше, циск-то циск, регистр специальный, команда для работы с ними специальная, ЛГДТ, Load GlobalDescriptableTail.
А дальше начинается магия, связанная с тем, каким антиквариатом на самом деле является X76.
Ну, во-первых, вспомните, что до сих пор мы находимся в 16-битном режиме.
И сколько же памяти мы можем с помощью этих 16-битных рисовать?
Ну, в самом деле все страшнее. Оказывается, мегабайт.
В какой-то момент осознали, что 6,4 килобайта не всем хватает, и нужно сделать какую-нибудь систему, которая позволяла бы адресовать больше.
И в какой-то момент решили, что на мегабайты-то всем хватит.
А для мегабайтов сколько бит нужно?
Как нам сделать из двух кусочков по 16,2?
Решили складывать?
Вот таким образом.
Взяли, сложили.
Получили 20-битный адрес. Из двух регистров один из которых сдвинут на 4 бита.
Ну, как?
Доставать целый мегабайт можно. Ну, как известно, 640 килобайт хватит всем?
Ну, вот такие костыли сделали.
Хуже того, вот у нас от процессора отходили линии адресной шины от А0 до А19, которые были подключены к памяти.
А начиная с линии А20, контроллеру клавиатуры.
Да, было совершенно логичное решение, а именно, использовать те же линии, которые нужны идти к памяти, на управление клавиатурой.
Вот такие быстрые и медленные устройства. Абсолютно логичное решение.
Ну, и соображение совместимости, оно до сих пор работает так, вы заставьте.
К счастью, ее можно переключить.
Чтобы включить 20-ю адресную линию и дальше, мы читаем из регистра A из порта.
Вот с таким номером, общаясь с нашим чипсетом материнки, читаем в регистр.
С помощью побитого O ставим битик и записываем обратно.
Все, у нас включена 20-я линия и мы можем адресовать больше 1 ГБ.
И наконец, нам нужно включить защиту, чтобы, работающие на третьем конце привилегии, программы не могли залезть и помыть друг друга.
Для этого у нас есть всякие управляющие регистры. В частности, нас интересует нулевой управляющий регистр.
Заносим его содержимое в ЯХ, ставим самый младший битик в единичку и записываем обратно.
Ну, нельзя так просто взять и поменять битик в регистр.
Ну, зато можно не инстаграммировать.
Мы не можем напрямую записать селектор нужного сегмента в регистр код и сегмент.
Ну, просто нет такого кода, запиши в регистр цельствия.
Но вспоминаем, что джампы это на самом деле мовы инструкционпоинта и код и сегмент.
То есть, до этого адвеса были такие.
То есть, сегментный регистр и инструкционпоинта.
Какой сегмент и по какому смещению он находится?
ЦС это первый регистр, который со смещением на 4, то есть с умножением на 16.
Второй просто прибавлялся. Ну или, допустим, дата сегмент.
Сорсинг. Какие данные могли по такому адвесу лежать?
То, что лежит на 4, плюс С.
То есть, ЦС заносится смещение на 8 от начала глобальной интервью из дискрипторов.
А, в инструкционпоинтер заносится адвес у следующей метки.
Мы наконец-то в 32-битном защищенном режиме после всех этих страшных преследований.
В отличие от ЦС мы в ДС и СС сможем писать в даты сегмента и стэк сегмент.
Туда записываем 16, то есть адвес, где у нас описаны сегменты данных.
Дальше делаем то же самое, только уже в 16-битном режиме.
Заносим туда СИ и вызываю функцию.
Там расстановим процессор.
Прерывание не обращаем. Все. Никто нас не прервет. Билса больше нет в 16-битном режиме.
Никто нам больше не помешает.
И, если это не помогает, то цепляемся.
Но, есть одна проблема. В прошлый раз мы вывод делали с помощью прерываний, с помощью функции, которая обеспечила нам билс.
А теперь билс у нас больше нет.
Мы уже, мы теперь ядра операционной системы, мы на все ответственны.
И как ли нам что-нибудь взять и вывести?
Есть такая возможность.
Дело в том, что VGA-шные карточки отображают память видеоадаптера по адресу 8.0.
По краю дефолтного видеорежима в момент старта.
И мы можем прямой записью видеопамяти что-то замести в память видеокарты.
И, соответственно, это может появиться на экране.
Ну, если, конечно, к этой видеокарте экран подключен.
Мы хоть и в своей операционной системе, самое главное, все равно соблюдаем соглашение VGA.
Мы запихиваем все регистры, стэп.
Да, вот для этого нам и нужен был в стэп-сегменте конкретный адрес.
После окончания функции мы все оттуда выпихиваем и возвращаемся.
У нас со своем соглашением две аргументы через ESC.
Никакие регистры портить нельзя.
Наше собственное соглашение VGA.
Аналогично, загружаем по адресу S.
То, что лежит по адресу.
Если вылечим на единичку.
Проверяем, не дошли ли до нуля. Если дошли до нулевого байта, значит все.
Зарешаем нашу программу.
Если не дошли, то записываем куда-то в видеопамять.
Увеличиваем это число.
И снова возвращаемся в начало цепи.
В свой простой бинальный формат, а не в эльф как раньше, мы компилируем нашу программу в тот же файл.
А теперь мы хотим запустить нашу программу.
Хочу видеть режим масштабирования.
Запускается наша программка, и она вывела нам сообщение.
Теперь посмотрим внимательно на код и выводы функций.
Во все байты видеопамяти мы что-то пишем.
Если не все, то почему?
Курсор – это у нас переменная. Даблорд – проинферизированный уровень.
Она у нас постепенно увеличивается.
А что будет, если туда все-таки что-нибудь записать?
Добавляем единичку.
А что туда будем писать?
ЕЦХ у нас увеличивается, курсор у нас увеличивается.
Значит, младшая часть ЕЦХ.
Какая у нас младшая часть ЕЦХ, самая маленькая?
Ну, также как АЛ, младшая часть АХ и ЕАХ.
Попробуем туда занести цель.
Так, а если бы...
Сделаем масштабирование.
Собрали.
Запустили.
Что у нас получилось?
А теперь попробуем объяснить эту картинку.
Мы туда записывали число, которое постепенно увеличивается.
То есть, вот у нас ноль.
Это черная буквы на черном поле. Естественно, она не видна.
Нет, это одинаковость цвета фона и цвета шрифта.
Затем у нас синяя буква на черном поле.
Там, где у нас единичка.
Это цвет чего?
У нас, похоже, завелся хороший ревьюерсер.
Который, всего лишь взглянув на цветную картинку, понял, какой формат представления цвета.
Итак, у нас есть 8 бит.
И что за что означает?
12 бит. Как тут уже предположили.
Означает что?
Да.
Хорошо. Следующий бит.
Хорошо. Зеленый.
Ну, может быть, это как раз D3.
Дальше?
Дальше?
Дальше?
Да. Ну, какой-то он сероватый.
Темно-белый.
Дальше?
Да. Какой-то светло-черный.
Значит, за что отличается следующий бит?
На магическом обыске.
Хорошо. То есть мы сделали предположение, что за яркость фона...
Хорошо. Если наше предположение верно, нам нужно что-то, чтобы попало в старший бит.
И доказать.
Давайте сейчас проверим.
Уложим на 16.
Сдвигом влево на 4 бита.
Цель нам портить не надо, да и можно портить.
Почему можно портить?
Все регистры мы спрятали, а потом мы их все вернем.
Мы честно соблюдаем соглашение о вызове.
Сборка.
Так, и вообще, что это мы мелочимся?
Каждый раз команду набирать.
Не забываем про символ табуляции.
Ну и что у нас получилось?
Так, значит, за что отвечает у нас старший бит?
Да, за мигание.
Как бы это примить?
Больше всего у нас пушит ОПСК.
Мы ее прибили.
Добавим это в мейпфайл.
Чтобы, если она фейлится, ничего с ней не случилось.
Чтобы мейпфайл продолжал выполняться, если у нас нет ни этого процесса.
Значит, это у нас мигание.
Ну вот, мы расшифровали, как у нас представляется дело.
Теперь, как из этого делать что-нибудь полезное?
Мы умеем наладить любой текст на любом ходе.
Купы желания ложим, дарим мне.
Одинаковый.
Примерно как на некоторых форумах какие-то, помните ли, добавляли в плотность картинку.
Дивки с текстом от библии, что за косяк форума, буквы пляшек.
Ну и буквы, дай гипситой гребещей.
А, у меня буквально вчера, он будет, в своем плане, все отформливать на треночках, и он просто писал как-то.
Вообще, я бы сказал, на самом деле, это как раз такая, я просто, я просто, я просто, я просто, я просто, я просто, я просто, я просто, я просто, я просто, я просто, я просто, я просто,
То есть, записанное вот сюда, мы пишем.
Так, пишем цвет, здесь, выписывая здесь, пишем текст.
И у нас есть цикл. В этом цикле мы последовательно, лол, или байт за байтом, или через байт, пишем какой-то, и что-то пишем.
У нас есть объявление константа.
А как мы будем из памяти читать?
Как мы, вот так мы память пишем из регистра, а как будем читать из памяти регистра?
Стоп, привет, вспомняйте.
Вот, мы по адресу просор читаем из памяти регистра.
Но в наше время верить нельзя никому, не можно.
В том числе нельзя верить оперативной памяти.
Как бы нам эту оперативку проверить?
Что она работает не как псы, а именно как памятник.
То бишь, то что туда записал, то оттуда и прочитал.
То есть записать и сразу же считать, так?
Итак, делаем большой цикл, и от одной константа до другой пишем что-то в память.
От какой константа можно начинать, чтобы точно ничего не затереть весь наш код?
Нет, от начала видеопамяти не стоит, потому что мы хотим что-нибудь на экран все-таки вывезти.
Ну смотрите, мы спокойно работали с выпищенной линией А20, и наша программа спокойно жила, и никто ее не трогал.
Наконясь в самом первом мегабайте памяти.
Значит, начиная с первого мегабайта памяти вполне можно тестить.
Адрес видеопамяти находится где?
Внутри 0 мегабайта, не дальше.
Ну, мегабайт это 2 в 20, то есть 20 битиков.
А адрес педалично, значит это сколько?
То есть до 5 эффек это у нас 0 мегабайт.
Это у нас меньше, чем 5 эффек.
Значит, это все в 0 мегабайте, все хорошо.
То есть 0 мегабайт мы зарезервируем.
Оставим там наш код, наш стэк, данные и все прочее.
Ну, а также видеопамяти.
А адрес куда нас возместил биос тоже находится внутри 0 мегабайта. Все хорошо.
А начиная с первого мегабайта по сколько там мегабайт можно тестировать?
Стоит ли в одном цикле записывать и сразу считывать?
Ну, если мы так будем делать, записать и сразу считать, то мы памяти протестируем.
Мы протестируем, как работает пэш.
Нам нужно записать больше памяти, чем у нас отъем кэша процесса.
Тогда им действительно придется писать памяти.
Большим циклом написали, а тем большим циклом считали.
Если мы хоть раз считали не тот байк, который писали, например, припишем один константный байк.
Тогда проводим текст. Текст мы вводим уметь.
Это даже выведется на отдельную функцию.
Опустим на сильном фоне.
Если нашли ошибку, а для целях отладки мы можем между циклами записи и чтения
и не поставить просто запись по слединке какого-то одном нового байка.
И вывесим на красный фоне memory bet, если нашли ошибку.
Ну и дома попробуйте взять эти примеры, которые лежат на i7 True в разделе языка ассемблера.
Вот это слово ассемблера.
И попробуйте их модифицировать и превратить в i7 True.
Цикл в записи. Возможно, выкомментированный этап внесения ошибки и цикл чтения.
Вот какой-то классный, но какой-то короткий.
Собирать просто насмом, в простой бинарный формат, испытывать можно на виртуоблоксе.
Вот еще один случай, когда ассемблер действительно нужен, это вот как раз разработка нискованного пазового печенья,
разработка загрузчика, ну по крайней мере из намых первых его этапов.
Когда нам действительно нужно сделать некие действия, для которых нет подходящих выражений в языках ассокуума.
Вот, например, вот эти.
Ну вот, просто смотри в виртуоблокс, дальше.
Создаете новую виртуальную машину, называйте как-нибудь, никаких подсказок, что эта система ему не нужна, указывайте обе виртуальные памяти.
Кстати, смотрите, что будет, мы будем исследовать больше памяти, чем дальше в виртуалбоксе.
Виртуальный жесткий диск нам не нужен, вместо этого настроить машину, носители.
И две контроллеры нам не нужны, вместо этого добавляем floppy-контроллер и образ дискетки, который собран на нас.
Вот это виртуальный памятник.
