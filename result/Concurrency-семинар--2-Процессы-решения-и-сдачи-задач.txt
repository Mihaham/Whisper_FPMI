Что, сегодня у нас очень скучный семинар, очень нудный, мы хотим поговорить про какие-то технические нюансы, про инфраструктуру курса и разобраться с ней один раз и навсегда, то есть на весь семестр, чтобы больше к этому никогда не возвращаться и чтобы у нас у всех все работало, работало предсказуемо, понятно и на защитах тоже работало, что не очень важно.
Я вам что-то расскажу сейчас, что-то, что мне кажется важным, что мне важно, чтобы вы все понимали, но если у вас есть вопросы, то это гораздо более ценно, если вы столкнулись с каким-то сценарием, который вам кажется очень неэффективен или непонятен, то, пожалуйста, давайте его проговорим и раз и навсегда поймем.
Все вы, наверное, уже решили задачу А плюс Б, чтобы не потерять баллы на пустом месте, так что вы все склонировали репозиторий курса, настроили себе контейнер, возможно, установили консольный клиент, поработали сиай и, возможно, вы что-то не поняли, возможно, вам что-то казалось просто неудобным, было такое?
Ну, семинар там можно заканчивать.
Хорошо, давайте все-таки...
Вопрос.
Вопрос, да, давай начнем с вопроса.
Как работают клипы тарги? Что эта команда подозревает вообще?
Вот, то есть на самом деле ничего не понятно. Ну, хорошо, давай тогда начнем сначала.
Как выглядит вся конструкция? Вообще, все, что я расскажу полезно понимать, потому что, во-первых, у вас может что-то разломаться, и вам придется все перенастраивать, и как-то обидно перенастраивать все вообще с пустого места, можно понимать, что именно разломалось.
И вообще, если у вас что-то идет не так, то вы получаете от клип или где-то какие-то ошибки, хорошо, если вы умеете их интерпретировать, понимать, каких инструментов они касаются и примерно как их починить.
Не просто пишите в support. Не то чтобы в support писать не нужно, нужно, но если вы больше понимаете, то вы просто умеете эффективнее справляться с такими маленькими проблемами.
Итак, у нас есть диаграмма устройства нашего курса. Эта диаграмма касается только двух компонентов, а именно репозитория в клипе.
Докер-контейнер и C-Line и DE, это вот вещи посторонние, мы их оставляем за скобками. Можно жить без них, с ними жить удобнее, настраивать все удобнее, но по-разному бывает.
Но курс без них можно пройти, поэтому мы сейчас про них не говорим. У нас есть репозиторий курса, он лежит в моем профиле GitLab, вы его клонируете к себе, и вот в этом репозитории вы решаете все задачи, пишете код решения, запускаете тесты.
И параллельно с этим у вас есть репозиторий с решениями, которые создается, когда вы регистрируетесь в приложении, и команда клипе attach, которую вы запускаете при настройке всего этого, клонирует этот репозиторий вам локально.
Ну вот первые две команды, с которыми вы сталкиваетесь, это attach и update, наверное.
Давайте сразу про эту команду прокомментирую. Вот если вы зовете gitpool, то, возможно, вы пострадаете. Пожалуйста, не обновляйте репозиторий через gitpool, потому что gitpool обновляет сам репозиторий, но он не обновляет сабмодуля.
В репозитории есть сабмодуля, собственно, клипе это сабмодуля, и если там исправится какой-то баг или что-то изменится, то вы пропустите, поэтому вот, пожалуйста, используйте эту команду.
Команда attach тоже почти ничего сложного не делает, она клонирует репозиторий и ставит ссылку из этой директории в это, чтобы просто клипе знало, что ваш репозиторий решения вот он.
Ну а дальше какие-то команды клипе работают с этим репозиторием, какие-то работают с этим репозиторием, какие-то работают вот с gitlab и с этим репозиторием с ремутом.
Что вы в первую очередь делаете? Ну, вы пишете код, запускаете тесты, команды клипе тест. К ним мы вернемся, я объясню, собственно, почему, про то, что ты спрашивал про цели, про все это, про таргеты.
Еще вы используете ринтеры. Ну, может быть, вы не используете ринтеры прямо сейчас, но в CI используются ринтеры, и вы видите, что если вы отправили код неформатированным, он нарушает styleguide, или в нем есть какие-то странные паттерны, в смысле кода или комментарии лишние, то у вас CI разломается и тесты даже не запустятся.
Вот все это вы можете воспроизвести локально, для этого у вас есть команды клипе, про них всех есть документация, и я сейчас расскажу про команды tidy и format.
Это две команды, которые запускают, соответственно, два ринтера, clang-tidy и clang-format. Оба эти ринтера нужны для того, чтобы форматировать или валидировать ваш код.
Мы пишем на google styleguide, соблюдение его обязательно, примеры есть в документации, но даже если вы где-то его нарушили, поставили лишние пробелы, что-нибудь еще, вы можете написать клипе формат, для вас форматирует код.
Клипе формат работает в первую очередь просто с каким-то наивным представлением AC++, он форматирует, ничего сложного он не занимается.
Но если вы хотите что-то настроить в нем, то смотрите, в корне репозитория есть два конфигурационных файла, clippy-format и clippy-tidy, это конфиги ринтеров.
Когда вы вызываете clippy-format, вы вызываете clang-format, и этот clang-format использует этот конфиг. То есть он отталкивается от google styleguide, и к нему добавляются какие-то маленькие настройки.
Ну скажем, мы требуем оформлять в фигурной скобке даже однострочные рямды с переносом строки if с одним выражением, с одним statement, ну и так далее.
Почему в google styleguide я не знаю, может быть Рома, который спрятан здесь в аудитории, знает.
Я не помню, может быть этого достаточно будет.
Ну вообще говоря, если строго говорить, мы где-то можем отступать от styleguide и google, то есть мы, скажем, используем все-таки исключения, ну потому что мы не google, а у нас нет причин не использовать их.
Какие-то минорные отличия возможны. Ну или скажем, конкретно вот у этого семинариста мы не очень жалуем объявления нескольких переменных, нескольких полей в одной строчке по разным причинам.
Мне кажется, что это довольно плохая практика. Но в целом мы соблюдаем styleguide google, достаточно прочесть его, а дальше какие-то минорные отличия мы проговорим просто на защитах.
Ну или вы столкнетесь с тем, что линтер не пропускает ваш код, он отформатирует то, что он считает правильным.
Clangtide он интереснее, потому что он все-таки парсит C++, он там его компилирует, он понимает, как программа ваша устроена, и скажем, он может какие-то довольно интересные, неинтересные, скверные паттерны в вашем коде обнаруживать и их исправлять.
Вот скажем, вы пишете решение задачи A плюс B, и вот вы пишете вот такой код.
Ну он, конечно, бесполезен, дело не в коде, а в том, что этот код можно переписать гораздо разумнее.
Давайте мы запустим.
На этом решении Clangtide.
Вот одна из проверок, которую Tidy выполняет, он проверяет, что мы используем вектор empty на контейнере empty, а не сравниваем size с нулем.
Кажется, для этого есть специальный метод, который может быть реализован.
Ну или, скажем, вы можете написать вот такой вот код. У вас есть функция fo, она возвращает, не знаю, 34 часа, и вы пишете.
Что с этим кодом не так?
Тернарный оператор? Давайте не будем.
В if вы должны написать какое-то логическое выражение. 34 это не логическое выражение.
Ну всем мы понимаем, что 34 может проинтерпретироваться как true, но вот нет, так делать не нужно.
Если вы хотите написать условия, то вот напишите не равно 0.
Вот Clangtide тоже этот код попросит вас переписать.
Он, в принципе, переформатировать его может сам.
Ну то есть по дефолту, если мы сейчас нажмем на enter, то он запустится и этот код исправит.
Ну на всякий случай будьте осторожны, он иногда исправляет, иногда его немного ломает.
Все разные случаи бывают. В простых сценариях можно ему точно доверять.
Это команда ClipFormat, ClipTidy, они называются просто по имени ринтера.
Есть ClipValidate, которая делает и Tidy, и Format.
И помимо этого еще проверяет, что в вашем решении просто нет некоторых запрещенных подстрочек.
Вот если вы с этим сталкиваетесь, возможно это вас фрустирует поначалу,
но вот в конфиге Clip есть набор запрещенных точно подстрочек,
которые у вас не должно быть нигде ни в одной задаче.
Тут они разные по смыслу.
Это просто это бесполезные комментарии, которые есть в шаблоне для того, чтобы вы смогли сориентироваться,
где писать код, а есть строчки, которые запрещены,
потому что мы в курсе используем некоторый нетривиальный фреймворк для тестирования,
и он не совместим просто со StdMunix, StdAtomic, нужно заменять их на какие-то обертки.
Поэтому мы запрещаем просто использование этих примитивов.
Если вы их используете, то у вас тесты запускаются, к сожалению,
но работают они совершенно непредсказуемо, получается просто OB, ожидать ничего разумного нельзя.
Вы их запускаете, получаете бессмысленные результаты и не знаете, о ком их поинтерпретировать.
Так что Std запрещен, но и вся и мы проверяем, что вы действительно всего этого не используете,
иначе просто решение не тестируется.
Вот, вы пишете решение, вы форматируете его, запускаете тесты, они, допустим, проходят,
и дальше вы пушите решение, вы сначала комитите решение,
команда commit в клипе, это не что иное как обертка над командой git,
мы прыгаем в соседней репозитории, которую вы приаттачили, копируем туда файл решения, говорим commit,
заводим ветку, говорим в нее commit, а потом, когда вы говорите push,
клип и push, то эта команда пушит решение в ремуд.
Дальше вы говорите merge request, и клип через apigitlab создает merge request из этой ветки в мастер.
Вот, ну и если вдруг вы сталкиваетесь с какими-то проблемами о авторизации,
то это из-за того, что команда клип и push работает с git,
команда clip и merge request работает с apigitlab, и там есть отдельный токен для авторизации.
Так ты же конфиг для этого и заводишь, там лежит твой токен.
Что? Куда вставлять?
Подожди, ты заполняешь, в инструкции тебе просят заполнить поля конфига, в частности токен лабовский,
но ты один раз его заполняешь, потом говоришь, просто merge request любой задачей, и клип идет...
Ну, про push ты тоже можешь сделать, наверное, что же тебе мешает.
Просто ты в контейнере живешь отдельно.
Ты можешь настроить доступ через SSH, положить ключик, в документации тоже про это есть.
Тебе кажется, это рекомендуемый способ, чтобы не вводить каждый раз пароль.
Просто инструменты немного разные, в одном случае мы работаем с gitlabом, в другом случае с git,
поэтому все это немного по-разному настраивается.
Этот цикл бесконечный.
Ну прям, напиши в support, мы почитаем, посмеемся вместе.
Ну, ты жалуешься на то, что мир несовершенен, в нем бывают такие вот циклы, ну да.
Я думаю, что человек справится с исправлением.
Проблема не существующая, мне кажется.
Мне кажется, мы немножко праздными вещами занимаемся.
То, что ты говоришь, интересно, напиши, мне интересно посмотреть.
Но кажется, что с нами такой ситуации не произойдет.
Вот если произойдет, то мы будем думать.
Но пока эта проблема не считается актуальной.
Понятно ли все это? Понятна ли эта конструкция?
Если к ней вопросы.
Ну вот тогда займемся вот этим репозиториями и командами, которые работают с тестами,
с запуском тестов, то есть ClipyTest, ClipyTarget.
Итак, смотрим на наш репозиторий.
Что такое наш репозиторий?
Это C++ проект.
Мы загружаем его в IDE.
В корне лежит CMakeList.
И дальше IDE этот CMakeList разбирает и понимает структуру нашего проекта.
Что значит проект?
Это набор исходников, из которых можно собирать какие-то исполняемые файлы, какие-то библиотеки,
которые линкуются к этим исполняемым файлам.
Ну вот, можно посмотреть, например, попроще.
Вот у вас есть TinyFibers.
И в корне репозитория есть CMakeList,
который описывает, что нужно пойти в директорию с TinyFibers и собрать там библиотеку.
Вот не сюда пойти, а вот сюда.
В этом листе написано, что нужно собрать библиотеку.
Если мы пойдем в эту поддиректорию,
какую-нибудь еще вложенную,
то мы увидим, что здесь мы собираем не библиотеку уже,
а исполняемый файл.
Вот с таким вот именем, где libtarget – это переменная CMake,
в которой написано имя всего проекта, то есть TinyFibers.
И мы собираем исполняемый файл вот с таким вот именем.
Из такого MainCPP и линкуем библиотеку TinyFibers,
которая описывалась вот здесь, в этом листе.
То есть у нас такая совокупность листов, мы их обходим,
и в отдельных листах написано, что мы добавляем библиотеку,
а у других, что мы добавляем executable.
Что это вообще значит?
Вы, наверное, знаете про CMake что-нибудь или ничего не знаете.
Вы написали библиотеку, какой-нибудь алгоритм поиска подстроки в строке,
KnudMorrisPrat.
У вас есть header, где объявлена функция,
и у вас есть cpp-файл, где описана реализация.
Вы хотите из этого сделать библиотеку.
Вообще, вы хотите скомпилировать все это.
У вас есть MainCPP с тестом, и у вас есть вот эта библиотека.
Что вы делаете?
Вы должны вызвать компилятор, передать ему исполняемый файл
и сказать, что я хочу скомпилировать объектный файл.
Что вы можете сделать?
Вы можете написать скрипт make,
сказать, что есть цель Compile,
и сказать, что в этой цели вы запускаете компилятор с такими-то
исполняемыми файлами.
Для того, чтобы руками все это не писать,
мы используем CMake,
и вот с помощью этих CMake листов,
с помощью команды CMake,
этот самый CMake генерирует уже скрипты,
в которых описаны компиляторы,
исполняемые файлы,
параметры компиляции,
и уже из CMake вы получаете набор вот таких таргетов.
То есть каждый таргет у вас здесь это либо библиотека,
например, вот эти таргеты,
либо исполняемый файл.
То есть библиотека, она появляется,
когда мы в CMake листе пишем Add Library,
исполняемый файл, когда мы пишем Add Executable.
Ну а дальше мы эти цели можем, цели-таргеты,
в смысле CMake, можем их собирать,
и можем их запускать.
И в репетитории курса, когда вы загружаете проект,
когда он загружается, наконец,
в контейнер или в фос-системе,
в зависимости от того, что вы делаете,
вот у вас здесь в списке есть все-все таргеты,
которые в проекте вообще существуют.
Эти таргеты это чаще всего
какие-то тесты к отдельным задачам.
Иногда это библиотеки,
иногда это библиотеки внутри задач,
но чаще всего это цели с тестами,
unit-тесты, stress-тесты.
Ну вот, ты загружаешь CMake проект,
CMake генерирует все файлы для сборки,
ну и там получается набор таргетов.
Вот эти таргеты это библиотеки либо
исполняемые файлы, либо вот какие-то
таргеты, которые делают что угодно,
но у нас таких мало того.
У нас в основном в библиотеке программы.
Ну если где они есть,
они есть в уме IDE,
они есть в скриптах мейка.
Вот здесь они просто все перечислены
в одном списке, и дальше мы можем их запускать,
ну то есть если мы хотим запустить тесты
для A плюс B, то вот мы выбираем этот таргет,
собираем его,
и запускаем его.
И вот он предсказуемо разломался,
потому что там тест разломается.
Это мы тоже понимаем все, надеюсь, да?
Теперь.
Не понимаю.
Задай вопрос.
Нет.
Еще раз, где они все решат?
Где их список?
Где их список?
Списка их нет.
Есть совокупность листов,
CMakeList, cxt,
и в некоторых этих листах описаны таргеты,
а в некоторых написано вот,
обойдем директорию,
и возьмем CMakeList оттуда.
Вот то есть, смотри, у тебя есть
корневой CMakeList проекта курса,
там написано, добавить под директорию tasks.
Это значит, что нужно пойти в эту директорию,
CMake,
и найти там еще один CMakeList.
Там написано, а вот пойдем теперь
во все поддиректории с домашками.
В следующем написано,
пойдем в директорию задачей.
А там уже есть
CMakeList листовой,
и в нем, с помощью
вспомогательных функций написано,
скажем, что мы добавляем
цель
с тестами.
И вот, CMake
где-то компилирует
какой-то скрипт для мейка,
где собирается такая-то программа
с такими-то зависимостими,
из таких-то файлов.
То есть, если я хочу
вызвать какой-то какой-то тест
у одной задачи,
я в папке задачи CMakeList
закрою, и там смотрю,
я на тесты подсасываю.
Ты работаешь сейчас, я пропустил
через IDE или через консольный клиент?
Или ты работаешь вообще голыми руками,
ты про это говоришь?
Вот голыми руками, смотри,
в репозитории с файберами у тебя есть инструкция
для случаев, когда ты работаешь
с голыми руками.
Вот мы клонируем себе проект с файберами,
вот мы заходим в директорию, создаем
директорию, где будут биллскрипты,
мы в ней с помощью CMake
генерируем эти биллскрипты для мейка,
а дальше мы уже говорим make, пожалуйста,
собери такую цель,
и он запускает компилятор,
собирает там
исполняемый файл в библиотеке,
ринкует все это, и результат
оказывается в какой-то директории,
и ты уже оттуда можешь
исполняемый файл позвать.
Вот IDE от тебя все это
старается скрыть,
у тебя просто список вот этих целей
будет в таком выпадающем списке,
и ты просто выбираешь, нажимаешь на
зеленый треугольничек, и все
просто работает.
Но под капотом это все
понятные инструменты.
И IDE от тебя скрывает
вот эту вот механику внутреннюю,
и Clippy тоже старается скрыть
до определенной степени.
То есть Clippy она же ничего самостоятельно
не делает, она просто это
материтка, которая зовет
make, CMake,
git, там что там, clang-tidy,
clang-format, все вот эти инструменты.
И в принципе про них можно
не знать до тех пор, пока все работает,
но когда что-то сломалось, то полезно понимать,
какой именно инструмент был задействован,
и почему он упал,
и что в выводе будет его ошибка.
Так вот,
что для тестирования полезно понимать?
Ну вот в A плюс B, наверное, не очень нужно,
а в задачах про взаимоисключение
уже нужно понимать,
что запуск
тестов, скажем,
для MuteXM.
Давайте их здесь найдем,
ну или даже вот этих тестов,
через IDE.
Это совсем не то же самое,
что запуск этих тестов через
команду ClippyTest.
Почему? Потому что в команде
ClippyTest запускаются на самом деле
все эти тесты не один раз,
а несколько.
Ну вот,
давайте посмотрим
на что? На какой-нибудь pipeline
IDE, ой, pipeline
CI, простите.
Вот вы задаете задачу, отправляете ее,
и вот какой-то выхлоп.
Ну, во-первых,
как мы его нашли? Давайте
вернемся в прошлое.
Как вообще читать отчет
о запуске тестов в IDE?
Вы приходите в свой репозиторий,
где-то здесь есть мой, там решена задача
A плюс B.
У меня есть там один MergeRequest.
И вот список pipeline.
Вот, если что-то идет не так
или все хорошо, вы можете ткнуть сюда и
посмотреть отчет.
Что мы видим?
Во-первых, мы видим, что
вот в этом
в этом выхлопе
от тестирования вашего решения
всего лишь запускается много раз
Clippy. То есть происходит
то же самое, что вы можете воспроизвести
локально на вашей машине.
То есть все,
что происходит в системе тестирования,
вы можете воспроизвести локально
и вот
столкнуться с той же ошибкой,
которую вы видите здесь.
Ничего нового здесь нет, никаких тестов
новых секретных не бывает.
Что здесь происходит?
Здесь также есть два репозитория.
Репозиторий курса и репозиторий с вашим
и ваш репозиторий с решениями.
И точно так же
Clippy сначала
оттачит репозиторий с решениями
к репозиторию курса.
Вот для каждого java.ca и для каждого
вашего решения оттачится
репозиторий с вашими решениями
и дальше ваше решение
намазывается на репозиторий с задачами.
Вот эта команда,
она в противоположном комиту,
она двигает решения из репозитория
с решениями локального
в репозиторий с задачами.
Если вдруг вы все снесли
с вашего компьютера, но при этом вы успели
запушить решение в ремут,
то после повторения
инструкции вы ничего не потеряете,
потому что
решения здесь останутся,
значит вы их склонируете сюда,
а с помощью команды Clippy и Apply
вы можете перенести их обратно в задачу.
Итак, выполняется
команда Apply,
а дальше выполняется команда CMake.
И вот вообще мы в курсе
на CMake писать не будем,
CMake листы мы писать свои не будем,
но кое-что про CMake
все-таки нужно понимать.
Ну вот нужно понимать, зачем он,
что он генерирует Billscript.
И здесь он запускается
потому, что вы в некоторых задачах
можете создавать свои
директории,
свои новые хедеры,
файлы с реализациями и так далее.
Пока у нас задача совершенно
тривиальная, там вы
правите буквально один хедер какой-нибудь,
но это скоро кончится, у нас будут
библиотеки, и там уже у вас будет
свободно, можно завести директорию,
и там сложат какие-то файлы.
Так вот, для того, чтобы
библиотека смогла скомпирироваться,
нужно к императору про эти файлы
рассказать. А для этого у вас есть
CMake листы.
Вот, нет, для этого вы будете
звать команду Clip и CMake,
и эта команда Clip и CMake будет
перегенерировать Billscript
и просто брать все файлы
из вашей там поддиректории.
Вот, если вы там что-то создали, то просто
Clip и CMake сгенерируют новые скрипты
и уже будет знать, что
CMake уже будет знать, что нужно использовать
новые исходники.
Вот, для этого задача,
для этого команда зовется в CI,
чтобы узнать
про ваши новые файлы, которые
вы сами завели в задачу. Если вы
создаете новый файл в решении, то
после этого вы вызываете CMake, иначе его видно
не будет.
Ну и вот видите, что здесь
CMake обходит директории и вот
печатает все цели, которые он нашел.
Ну, точнее, это наши скрипты печатают, но
внутри листов. Вот, это все
продолжается некоторое время,
не очень быстро, наверное, вы видели.
А дальше запускается команда Validate
и в ней запускается сначала Tidy, потом Format,
потом поиск
странных комментариев и там
стд-атомиков.
Опять же, вы можете это воспроизвести
у себя дома все,
если CI сломалась.
И наконец запускается тест.
И в случае с A plus battle ничего интересного не происходит,
а в случае с
сложной задачей
происходит уже довольно много всего.
Вот давайте найдем начало команды тест.
Начало команды
Validate
вот тест.
С задачей про философов
там есть стресс-тесты.
И если вы задачу решали, то увидели, что
в клипе тест запускает эти тесты
много раз.
То есть тесты написаны один раз,
запускаются несколько. Но они запускаются
в разных профилях.
Тут правда без подсветки,
но у вас в терминале будет подсветка
еще разными цветами.
Сначала мы запускаем эти тесты в профиле
Faulty Fibers, они собираются
и вот
пробегают.
Здорово, прошло 19 секунд.
Потом вы запускаете стресс-тесты
в другом профиле.
Снова собираются исходники
и снова те же самые тесты
пробегают, но уже как-то по-другому.
Потом вы еще раз собираете
стресс-тесты в другом профиле и так далее.
Вот если
вы запускаете тесты локально,
то есть вы запускаете
просто target теста в IDE,
то вы используете только
некоторый профиль. В клипе тест
используют разные. Что такое профиль?
Когда вы настраивали IDE,
то вы создавали
свои toolchain и создавали
свои профили в CMake.
Toolchain это
очень простая вещь. Вы IDE указываете
набор инструментов, которые нужно использовать
для сборки, для отладки.
То есть вы указываете
CMake, Make,
Compere,
Отладчик. И у вас есть
toolchain ваш локальный
для сборки в вашей хост-системе,
и у вас есть toolchain
для контейнера, где вы указываете
Compere и Debugger CMake в контейнере.
Вот вы настраиваете toolchain,
а дальше вы настраиваете профиль CMake.
Профиль CMake это
грубо говоря набор опций для CMake,
которые
можно варьировать снаружи,
не меняя сходный код,
не меняя содержимое проекта.
Ну скажем, в профиле CMake
участвует toolchain.
То есть каким именно Compere
собирать ваш проект? Собирать ваши исходники
в библиотеке.
То есть Compere это такая вещь параметризуемая.
И скажем,
если вы пытались
склонировать репозиторий с файберами
дома,
если вы ничего
не делали специально, то скорее всего у вас были
проблемы, потому что вот в этом месте у вас
программа не собиралась.
Потому что скорее всего у вас
дефолтный Compere в системе это GCC,
а проект собирается под клангом.
Где-то здесь это должно быть написано,
надеюсь.
А может быть не написано,
не помню.
Ну в общем,
требуется кланг,
и для этого нужно CMake
как-то это указать.
Вот в IDE вы делаете это с помощью
заполнения отдельного toolchain
с Compere'ем кланг.
Ну вот скажем,
я на маке установил Homebrew,
в нем поставил LWM,
и у меня есть компиляторы
нужные мне для сборки.
Я настроил toolchain для них,
и я настраиваю сборку.
Вот говорю, что используется вот такой вот toolchain.
А дальше я могу
указать какие-то опции
дополнительные, которые тоже на что-то влияют.
Вот например,
здесь вы указываете опцию CMake,
смотрите вот какую.
Tiny Fibers Examples.
Эта опция
используется следующим образом
в репозитории.
Сейчас, ну это не константы, это некоторый флажок,
который в CMake-листе как переменная некоторая.
То есть CMake-лист заранее не знает,
во что она
не знает.
Истинно этот флажок
приложен.
Так вот, в корневом CMake-листе написано
следующее, что если пользователь установил
этот флажок,
то он добавляет в список целей примеры.
А если нет, то я просто в директорию не хожу.
Ну зачем это нужно?
Если мы экспериментируем с фиберами,
то нам хочется примеры запускать.
А если мы используем библиотеку фибера
в курсе, то зачем нам в список целей выгружать
примеры другой библиотеки?
Мы их прячем.
Вот, этот пример не слишком важен
для нас, он важен
в том смысле, что вот есть опции
CMake-а.
Когда мы собираем...
Когда вы запускаете клиппи-тест,
то вот эти
разные варианты сборки,
Faulty Fibers они называются,
Faulty Threads,
с адрес-санитайзером
еще какие-то, вот все эти профили
они отличаются некоторым набором
флажков для CMake-а.
И вот они, кстати, здесь перечислены.
Скажем,
Faulty Threads Assan, что это означает?
Что запускается
тест с потоками.
Правда, там все Atomic и MuteX
заменяются на свои реализации,
где есть Fault Injection.
То есть вы говорите Atomic Store, а вместо
этого, а перед этим Atomic Store
выполняется переключение потока на другой.
Есть флажок Assan.
Он означает, что
программа инструментируется
с адрес-санитайзером,
который в рантайме может обнаруживать
обращения
к освобожденной памяти, там ошибки
или фрии, ну, какие-то другие,
которые у нас были на лекции
со списком односвязан.
Указывается Компириатор.
То есть разные профили, это разный набор
опций, и в зависимости от этого набора
опций очень по-разному собирается
код тестирующего фреймворка.
И очень по-разному исполняются
в конечном итоге ваши тесты.
Так что клип и тест
делают сильно больше, чем вы просто
запуская вот здесь цель.
Но, если вам хочется локально
уметь запускать
сборку точно так же, как делает клип,
то вы снова идете
в настройки,
и здесь создаете профиль новый,
и в нем указываете вот эти самые
опции.
Они, на всякий случай, перечислены
вот в корневом
конфиге
ClippyBuildProfiles.
Вот добавив эти опции в профиль
CMake, вы сможете из IDE
собирать цель
под другим профилем.
Вот здесь список целей,
а здесь список профилей.
Вы можете выбирать вот какую-то цель
в каком-то профиле.
Нет, зачем?
Фолтон Джекшн
увеличивает вероятность багов.
Тредсенитайзер их обнаруживает.
Зачем их по отдельности запускать?
То есть там не все варианты
комбинируются, но те, которые комбинируются,
комбинируют разумно.
Да, и вот смотрите,
есть команда, возвращаясь к твоему вопросу,
который был очень давно,
есть команда
ClippyTest, которая запускает все
вот под всеми режимами, которые описаны
в конфиге задачи.
Скажем в mutex описано
mutex mutex, и вот тут
написано, как
задача запускается.
Вот такие профили
и вот такие цели.
И вот они просто перемножаются
два этих списка.
Но мы можем вот лобзиком выпиливать.
То есть мы можем
пойти в задачу
и
допустим deadlock
и можем запустить
в ClippyTest.
И мы запустим сейчас
все тесты, посмотрим, чем это
закончится.
Первый тест прошел,
потому что я, кажется, написал здесь решение.
Да, вот оно.
Второй тест упал, потому что
я ничего не написал там.
Вот, допустим,
мы хотим запустить только первые
задачи попроще.
Тестовые цели
запускаются в разных сборках.
Вот первое, что мы можем
сделать для отладки, если у нас какая-то
цель под какой-то сборки,
мы можем запустить только эту цель
только в этой сборке.
Для этого у нас есть команда ClippyTarget, называется target,
потому что она запускает конкретный target,
они просто все возможные тестовые таргеты.
И у нее
два позиционных параметра.
Первый это имя цели.
Цель
печатается где-то
вот здесь вот.
И профиль
печатается здесь.
И вот я запускаю только цель
simulation, только под профилем
debug.
А все профили, все цели, они
они
не в каждой задачи
можно любые варианты запускать.
Вот допустимые варианты
они описаны в конфиге задачи.
Мне просто с чем была проблема.
У меня одна из задач
вызывала тл.
Я видел, что вы в чате
ответили, что тл это скорее все дедлог на самом деле.
Давай еще раз говорить, что тл это дедлог.
Это не то, что скорее всего, это точно дедлог.
И
почти всегда дедлог.
И если
ты напишешь дедлог просто на решении
с потоками, то есть ты заведешь там
стд трды и заведешь их в дедлог,
то твоя программа просто зависнет.
Ну и исчерпается
таймлимит для теста и вот
ты получишь ошибку таймлимит.
Но проблема это в дедлоге на самом деле.
И если ты хочешь получить какой-то более
внятный отчет, что именно дедлог возник,
то сами по себе голые трды
этого тебе дать не могут.
Но скажем, в сборке с тред санитайзером
тред санитайзер может обнаружить
дедлог. А может и пропустить, ну как повезет
уже.
Или в сборке под файберами, если мы
в сборке faulty fibers симулируем потоки
с помощью файберов, то если планировщик
там увидит, что файберы все остановились
и чего-то ждут, то он
выкинет ошибку и напишет, что у тебя
вот честно дедлог. Поэтому если
у тебя задача поддерживает тестирование
под файберами, то ты запускаешь
таргет, нужный тебе,
в нужном профиле faulty fibers
сразу, и там
получаешь ошибку,
которую ты видимо ожидал.
И убеждаешься, что да, случился
дедлог.
Но можно еще более
фигурно выпиливать тут все,
потому что так мы можем
задать конкретную цель с конкретным профилем,
но внутри одной цели
может быть еще много тестов.
Если мы посмотрим
в CI, то смотрите,
здесь запускается
здесь вот. Запускается
несколько стратстестов.
И допустим, у нас беда
на какую-нибудь, не знаю, третью.
Вот мы хотим запустить только его,
а не хотим запускать все предыдущие
и ждать их там по пять секунд.
Для этого
мы можем оставить здесь
два defisa
и указать вот такие вот опции.
suit
deadlog
Вот он. В нем
два теста.
И тест
one fiber.
И вот мы запустили только его.
То есть мы запустили только target
simulation, только под профилем debug,
и в нем запустили внутри
только тест one fiber
и suit deadlog.
То есть если у вас не работает что-то,
то есть тесты могут длиться 5 минут,
и если у вас не работает тест, который
исполняется через 4 минуты, то, пожалуйста,
не ждите его 5 минут, научитесь вызывать
ровно его.
Да, вот
это не работает.
На всякий случай ответ уже написан
в документации, в вопросах на ответы.
Но давай я объясню, в чем суть.
Вот код,
который не работает.
Вот мы хотим поставить...
Хотим поставить breakpoint.
Если мы сделаем все это
прямо наивно, ну вот поставим breakpoint,
и не знаю, на что здесь Идея ругается с нами.
Вот, отлично.
Если мы
просто запустим эту цель,
то, скорее всего, ничего не случится.
Вот мы нажали на жука,
поставили breakpoint,
вот какая-то муть случилась.
Почему?
Потому что, вот, когда мы запускаем
тесты,
то вот каждый тест, который здесь
описан, он запускается в отдельном
подпроцессе. То есть запускается
программа, которая для каждого теста
форкается, и уже в ребенке запускает код
теста. Почему? Ну, потому что тесты
могут взрываться самым диким образом,
и мы хотим как-то адекватно
на это отреагировать
и сгенировать отчет.
Или, скажем, в дедлоке, в задаче дедлок
там вообще ситуация довольно любопытная.
Давайте я это проговорю, потому что, ну,
я не знаю, насколько это нам важно,
но, по крайней мере,
маленький шажок в понимание файберов.
Вот вы пишете здесь дедлок, и вот вы написали
дедлок. И вот вы запускаете
функцию runShadower.
Она запустилась, в ней файбер
взял Mutex, потом пробовал еще
взять Mutex. И он заблокировался,
и все. Он не завершится.
То есть, где-то
в памяти существует какой-то
файбер с какими-то
ресурсами. Вот там родился,
запустился, взял Mutex,
взял Mutex, и все застрял.
Вот у этой функции runShadower
нет какого-то адекватного
способа завершиться.
Программа там пришла в
какое-то очень странное терминальное
не то что неволидное, безвыходное
состояние.
Мы не можем корректно разрушить,
освободить все ресурсы, которые там были
алоцированы.
Вот эта программа не может завершиться,
но при этом это успех теста.
То есть, мы получили то, что мы хотели.
Поэтому, что мы делаем?
Когда происходит дедлог, мы просто
завершаем весь процесс.
То есть, мы из этой функции не выходим
никогда. Мы
форкаемся и в ребенке запускаем
runShadower, в нем заходим в дедлог,
и когда мы обнаружили дедлог,
то мы понимаем, что восстановиться из него программы
не может, и просто мы программу завершаем
нулем.
Вот. Вот поэтому иногда мы
тестом полезно форкаться.
Так вот, если ты хочешь форки отключить,
то, во-первых, задачный дедлог
ты не сможешь его сделать, скорее всего,
потому что, ну вот, это плохо кончится.
А в задачу A плюс B почему бы не отключить?
Вот, для этого
можно я
кое-что проясню
перед тем, как я объясню ответ.
Вот, видишь, тут мы запускаем
команду target с такими опциями,
потом ставим два дефиса.
Зачем два дефиса? Вот эти
параметры, они передаются команде
к липе,
а вот остальные, которые после двух дефисов,
они передаются запускаемой программе.
Так вот,
программа с тестами поддерживает кроме
вот этих фильтров
такие флажки
disable forks и disable time limits.
И, кстати,
это даже написано при запуске.
Намерено, чтобы
помочь вам.
Но, видимо, никто не читает.
Вот, если мы
запускаем цель
с такими вот флажками,
то слишком мелко,
наверное, не видно, да, но вот я написал
disable forks и disable time limits.
И теперь я ставлю breakpoint
вот здесь вот,
то я теперь уже ожидаю,
что я в него попаду.
Давайте узнаем.
Ну вот, получилось.
Но, честно говоря, надеяться над дебаггер
я бы в курсе сильно не стал, потому что
багги у нас возникают недетерминированные
и любое внешнее вмешательство, оно
как-то очень сильно влияет на исполнение.
Мало шансов, что так можно
что-то поймать. Можно поймать
лагирование, но только не через сиаут, конечно,
потому что, во-первых, это упадок, во-вторых,
опять же, вот вывод, консоль, он
очень сильно влияет на
переключение поток,
не на переключение поток
влияет, а
как бы это сказать?
Короче, исполнение получится совершенно
другим, потому что там гигантские паузы
в нем возникают, какие-то сисколы.
Для этого у нас есть логер,
я, по-моему, не рассказывал про это,
но библиотеки, которые мы используем,
вот здесь есть
еще и логер.
Если вы пойдете в эту библиотеку
на GitLab, то увидите, что
есть способ логировать события
из вашего исполнения,
причем логировать его
не задерживая
исполнения текущих поток.
То есть, вы пишете что-то в лог, пишете на экран,
но при этом текущий поток, на самом деле,
не делает никаких сисколов, ничего не пишет
у сидаут сам.
Он перекладывает эту работу на другой
фоновый поток, в котором уже можно заблокироваться.
А ГДБ умеет, допустим,
несколько
влазить в вечерние процессы,
в дочерние.
Во-первых, это не нужно, а во-вторых,
я думаю, не умеет, то было бы странно.
Умеет?
Ну, короче, сейчас ты можешь
указать правильный тест,
указать вообще не форкаться,
то есть, ты...
Нет, вот эти знания нет, сейчас наоборот.
Ну, в общем-то,
я думаю, что
у вас есть
специальный метод,
который может быть
очень удобным,
потому что, представь себе ситуацию,
что у тебя три теста,
вот эти знания нет, сейчас наоборот.
Все наоборот.
Твои знания полезны, потому что они
за рамки курса распространяются конкретного фреймворка.
Но мы можем поступать
разными способами, ну, выбери, которые тебе удобнее.
Мне кажется, что
работать с конкретным инструментом
лучше про него побольше знать, чтобы
тебе было удобнее, а универсально, кажется,
конечно, опции
флажки для ГДБ более
полезны для тебя.
Что еще приходит в голову?
А, наверное, вот что,
я не сказал об этом.
Полезно
пойти в модуле стимейка,
где настраиваются опции для компилятора.
Потому что...
Смотрите, что здесь есть.
Ну, во-первых, здесь есть флажки для того,
чтобы генерировать очень много ворнингов.
А во-вторых, здесь есть флажок
VR, который говорит, что ворнинги
интерпретируются как ошибки.
То есть, вы не сможете
про эти тесты, они даже не запустятся,
потому что ваша программа не соберется,
если в ней есть ворнинги, если она
неаккуратно написана.
Это разумно,
потому что зачем писать программы с ворнингами?
Это просто небрежность.
Но, с другой стороны, если
с другой стороны,
если вы отлаживаете код,
если у вас какая-то задача,
вы пишете, там, экспериментируете, пишете
что-то неаккуратно, небрежно,
ну, это нормально вообще-то.
Но вам мешать самому себе.
Поэтому
разумно в вашей копии
проекта вот эту строчку
закомментировать.
И жить с ворнингами.
Но просто, перед тем, как
вы закомитите решение, отправите его
в CI тестироваться, эти ворнинги
исправьте.
То есть, они вам не будут постоянно мешать,
а в CI они все равно будут
проверяться.
Кажется, так было бы
разумно поступить, если
зачем себе палки в колеса ставить?
Хорош флаг в эррор
или нет? Это вообще-то вопрос дискуссионный.
В смысле, некоторые считают, что
хорош, некоторые считают, что
есть
заметка по этому поводу, я могу в чате
потом переправить, если вам интересно.
Какой-нибудь у 0
ненавидимый брейк для старых игр
Что?
У 0 ненавидимый брейк для старых игр
А, мы
в первой раз не будем
в нём
Не совсем
понимаю.
Компиляция, опции
оптимизации, они ставятся
в режиме сбора
Вот эти вот штуки используются
в любом режиме
0 или 0.1
Но можно их больше не восстановить.
Но зачем?
Потому что это параметры внешние.
Вот если мы фиксируем стандарт 1,
потому что нельзя в разных сборках
под разными стандартами собираться,
не то, что нельзя, это бессмысленно здесь,
но вот разные режимы оптимизации
или там разные настройки файберов
потоков,
это вещи параметризуемые, их нужно
настраивать не внутри репозитория,
а в профиле сборки, в симейке.
Просто место неподходящее.
Кроме того, я не совсем понял, как к этому вопросу
вообще пришёл, потому что про другое
А, это просто посторонний, ну не посторонний,
в смысле другой вопрос.
Ну вот, это
релиз дебака у тебя есть.
Опять идёшь в ВДЕ, настраиваешь
здесь профили.
Так, что ещё нам может пригодиться?
Какие знания?
Или по-другому?
Что ещё непонятно, с чем вы работаете?
Потому что не хочется, чтобы это были
магические заклинания.
Сейчас.
Откуда они берутся
описаны здесь?
Это мы в
Девторий Лайбрери, в симейке листе.
Тут с помощью модуля фетч-контент, симейка
подтягивают все зависимости.
И они кладутся вот
в той или иной
билдиректории. Тут есть
подчёркивание depth, и вот
сюда фетчится
все зависимости.
Вообще, я должна это сама
понимать. Если она не понимает, то нужно...
Ну, я не знаю, к сожалению, что нужно.
Какая-то магия происходит.
Скорее всего, нужно...
Вот что я вам не сказал. Давайте я про это.
Если вы настраивали Docker и настраивали
Sealiant, наверное, вы заметили, что
это не очень удобно.
В смысле, настраиваете их связь,
там какой-то SSH появляется, там
какие-то файлы копируются.
Но вот сейчас, точнее, вот,
по инструкции, которая написана в репетитории,
всё работает так.
То есть Sealiant — начало прошлого года.
Есть
container, есть в хост-система в ниже,
вот Sealiant. Sealiant SSH
ходит в контейнер, копирует
туда в tmp файлы
проекта, там их собирает.
Это работает довольно хрупко
всё, и проблема
где-то в Sealiant, а во-вторых, проблема
фундаментальная в том, что у вас появляются две копии
исходников. Одна в хост-системе, вот
настоящая, исходная,
истинная, а есть копия
в tmp, в контейнер. Если Sealiant там
что-то не синхронизирует, то
собирается несколько другой код, и это всё очень
странно выглядит. Так вот,
в конце прошлого года в Sealiant, кажется,
добавили поддержку Docker в более
нативную, и теперь, если у вас
Sealiant свежий,
то вы можете при
настройках профиля,
при настройках
toolchain, наверное,
указать уже не
remote host, а прямо Docker
контейнер. И
в
репозитории курса, в merge-реквестах,
сейчас найду,
есть merge-реквест, он ещё не замёрзан, но, кажется,
уже пора. Про то, чтобы
старую инструкцию удалить и
ввлечь новую, где
уже с новой версией IDE,
необходимо новую версию IDE поставить,
можно построить коммуникацию
с Docker, можно выстроить коммуникацию с Docker
гораздо эффективнее,
эффективнее
и просто надёжнее.
И мне кажется, что это может получить
какие-то проблемы, связанные с
подсветкой хедера,
ну, подсветкой зависимости, библиотека,
вот этого всё.
Если не
решить, то нужно беспомощно
гуглить issue-трекер
Sealiant или что-то подобное. Это, скорее всего,
не поможет, но, по крайней мере, мы пытаемся.
Какого-то готового ответа
на то, что там происходит, когда так...
Почему так происходит иногда? У меня, честно говоря,
нет.
Вот можно избавиться от такого хрупкого звена
с remote-хастом, заменить его на Docker
в настройках.
Что-нибудь ещё?
Может быть, вот вы попробовали
решить какие-то задачи уже простые,
вот может быть есть какой-то сценарий, который
вам просто кажется избыточным.
Вы что-то делаете и чувствуете, что вы делаете
лишнее, что можно было бы меньше шагов совершать.
Или где-то не хватает диагностики,
любые подобные...
любые подобные вещи.
Ну, под дебаггером я боюсь, что...
Смотри, если ты запускаешь тесты
под файберами, то
на самом деле файбер это исполняется
детерминированно,
и под дебаггером там вполне можно жить.
