Так, ну, давайте начнем тогда. У нас сегодня лекция 13 и будем говорить сегодня с вами про многоугольники.
Вообще-то вот, все, что можно сказать о многоугольниках, почти все мы сегодня скажем,
остальное скажем через неделю. Наверное, не надо плевать, что такое многоугольник,
поэтому у нас первая задача на сегодня — это выпукло из многоугольника.
А вот что такое выпукло, наверное, надо определить. И давайте дадим следующее определение — множество
точек на плоскости выпукло, если для любых P и Pg из этого множества отрезок от P и до Pg
целиком лежит в этом множестве. Ну, самый простой пример выпуклого множества — это одна точка.
Чуть более сложный пример — это отрезок. Вот, вы можете рассмотреть любой конечный набор точек,
показать, что он не выпуклый. В общем, в случае о плене немного другое — там нужно вводить
линейную комбинацию, выпуклую комбинацию и смотреть. Мы не будем этим заниматься,
на плоскости нас удовлетворит вот такое вот определение. На это еще можно смотреть
подтверждение или упражнение, если вам не доказывали еще нигде в курсе, что это равносильно тому,
что множество точек... сейчас не так, неравносильность... давайте для многоугольника
сформулируем. Многоугольник выпуклый тогда и только тогда, когда, скажем так, он лежит в одной
полуплоскости относительно любой из прямых, проведенной через его сторону, относительно того,
что он лежит в одной полуплоскости относительно прямой, содержащей произвольную сторону.
Или что еще можно сказать для многоугольника — его выпуклость равносильна тому, что любая
его диагональ целиком содержится в многоугольнике. Ну, вроде как нам это не понадобится,
поэтому я это не буду выписывать. Оказывается, я его не буду, это будет вам как упражнение,
потому что больше на математику, геометрию и все такое. Ну, простой пример не выпуклого
многоугольника — это такая вот галочка. Понятное дело, он не выпуклый, у вас найдутся две точки,
например, вот эти вот две вершинки его, ну или здесь вот где-нибудь взять можно. Такие,
что отрезок не содержится целиком. Или же у вас есть сторона, например, вот эта вот,
что если вы проведете прямую, то многоугольник будет по обе стороны от нее располагаться. Или
же, что у вас есть диагональ, вот такая вот, что она лежит вне многоугольника. Вот.
Ну, простейший пример выпуклого многоугольника — это треугольник любой. Вот. Окей. Теперь мы хотим
научиться проявить многоугольник на выпуклость. Зачем нам это нужно? Ну, потому что работать с
выпуклыми телами как-то попроще чуть-чуть, чем с неупуклыми. Алгоритм будет следующий.
Пусть дан многоугольник P1Pn. Думаю, такого, такой части нам хватит вполне.
Вот. И давайте просто проверять для каждой критерии того, что у нас все лежит в одной
полуплоскости. Как это можно сделать? Будем рассматривать соседние точки, будто бы проводить
через них прямую и смотреть, правда ли, что у нас следующее за ним ребро лежит в так называемой
нижней полуплоскости относительно него. Что значит полуплоскость нижняя? Это значит,
что если мы рассмотрим вектор направляющий и рассмотрим вектор P2P3, то у нас кратчайший
поворот будет от направляющего вектора до P2P3, он будет меньше 90 градусов. Кратчайший угол по
часовой стрелке. Ну или против часовой стрелки, если как обычно смотреть, то он будет больше 180
градусов. Вот. Окей, как проверять того, что какой-то угол больше, чем 180 градусов? Ну,
посмотреть на его синус. Потому что если у вас синус положительный, то он меньше 180 и наоборот.
Соответственно, что еще нужно здесь учесть? Учесть нужно то, что можно вычислять не синус угла,
а просто векторное, ну, псевдовекторное произведение, которое мы в прошлый раз
определили. Поэтому угол есть, на самом деле, очень простой.
Да, заметьте, здесь вот меньше, чем 1 плюс 1, ну или меньше, либо равно им нужно будет поставить,
потому что у нас будет еще закольцовывание вот здесь вот. Вот, я утверждаю тогда, что если,
так сказать, синусы всех вот таких вот углов будут одного знак, то многоугольник выпухлый. Иначе это
неверно. Да, естественно, мы работаем только с простыми многоугольниками. Потому что,
если у нас есть какие-то самоперещения, то совсем сложно становится дело. Вот. Так, окей. Ну,
давайте напишем так, что нам нужно проверять, что все вот эти вот штучки, все векторные произведения
будут одного знака, псевдовекторные. Ну, как-то можно делать. Например, просто брать и смотреть,
правда ли, что вот эти вот наши штуки будут все время одного знака последовательно. Если они все
одного знака, так, так, так, тогда это будет правдой. Иначе у вас есть момент, когда знак поменялся.
Поэтому можно делать это следующим образом. И векторное произведение pi, pi плюс один умножить
на векторное произведение pi, i плюс один, pi плюс два. Что значит, что они одного знака,
что они там все больше нуля. Да, мы здесь можно по-разному пределять правды, что у нас разрешается,
например, вот такой вот многоугольник, то есть три точки на одной прямой. В некотором плане вырожденная
сторона. Но это не будет играть особой роли, чтобы проверить, если у вас три точки на одной прямой.
Ну, здесь можно больше бревна поставить просто-напросто. Что если это верно,
точнее давайте не так, если это не верно, то мы делаем return false. Вот. Так, окей. Что
здесь нужно сказать? Наверное, здесь нужно сказать, давайте в ноль андексации все-таки,
точки. А, ну, сейчас, да, можно сейчас, давайте, это правда, здесь немного некорректно написано.
Мы сейчас это будем делать. Просто когда у вас здесь один, у вас не очень приятно
смотрится писать. Давайте все-таки п0, здесь p-1 будет у нас. Так,
p0, p1, p2, n-1. Так, давайте выписывать вектора p и p-1. Это будет первый вектор от 0 до n, да.
p и plus 1, это вот этот вот вектор. Мы смотрим вектор с следующим вектором, то есть p и plus 1,
а здесь вектор p и plus 2. И здесь мы смотрим следующий вектор, а здесь p и plus 1, p и plus 2, p и plus 3.
Вроде вот так вот. Должно работать. И только здесь меньше, чтобы false вернуть. Да, здесь везде по
модуле имеется в виду, да. Здесь везде надо написать %, да, чтобы вернуть false, что он не выпухлый.
Если у вас меньше 0, значит у вас в какой-то момент знаки разные. У вас все равно знаки
одни и те же будут. Просто они будут... И что? Произведение двух чисел больше 0? Это больше 0.
Произведение двух чисел меньше 0? Это больше 0. Здесь именно поэтому так написано, чтобы не
выписывать, правда ли, что первый знак был положительный. Если да, то траляля, иначе траляля.
Мне немножко лень, я просто напишу такой вот код. Он немножко менее эффективный с точки зрения
вычислений, потому что у вас здесь все считается по несколько раз. Ну, банально вы будете считать
этот вектор два раза. И вот у вас каждое вектор произведения по два раза посчитается. Жизнь
несправедлива. Если у вас закончится этот цикл, то return true, что у вас многоугольник выпухлый.
Такой алгоритм. OOTN работает. То есть еще раз, что мы делаем? Мы берем и смотрим следующее,
что для каждой пары сторон мы смотрим вектор продолжения одной и следующий. Если все эти
повороты будут в одну сторону, значит наш многугольник выпухлый. Значит неправда. Доказательство
корректности из того, что у вас в те штуки одного знака, равносильное тому, что у вас для каждой
прямой весь многугольник лежит в одной полуплоскости. Вот. Я здесь подпишу, чтобы осталось на доске.
В то время работаю.
ОТН. Окей. Если у вас в зависимости от того,
определяете ли вы это выпухлым или нет в такой кейс. Тут уже зависит от задачи то,
что вы хотите. Нули можно обработать отдельно. Если вы встретите в какой-то момент ноль, то все.
Типа можно либо сказать, что он не выпухлый, потому что вы так не считаете, либо про скип
идёт в сторону, грубо говоря. Тут уже как бы модификация, как вы хотите. Основной ядро алгоритма, вот оно.
Окей. Второй сюжет. Это принадлежность точки-многугольнику.
У нас будет два случая. Все-таки надо маркер искать, будет новое. Ладно, так принадлежность точки-многугольника.
У нас будет два разных случая. Первый будет общий алгоритм, а второй будет алгоритм специально для выпухлых там с определенными пиколами.
То есть пункт А. Общий случай. То есть как у вас стоит задача? Вам там какой-то многугольник,
быть может выпухлый, быть может не выпухлый. Надо понять, лежит ли точка внутри его или на его границе. Ну или снаружи.
Окей, как действовать будем? Здесь будем очень просто на самом деле. Давайте скажем, что первый будет метод такой читерский.
Потом мы его доработаем до адекватного. Какой-то классный у вас есть многоугольник, не выпухлый. Вот у вас есть точка.
Давайте пустим случайный луч из нее. Утверждается, что если мы пересечем нечетное число раз, то мы объявляем, что точка внутри, иначе точка снаружи.
Или здесь.
То есть пускаем случайный луч.
Если число пересечений со сторонами четно, то то, что снаружи.
Ну иначе внутри. Этот метод, конечно, гениален при простоте уникальности, однако у него есть проблема. Проблема заключается в том, что он может попасть в вершину.
Ну сейчас я подумаю как-то здесь продемонстрировать. Вот, например, такой луч. Повезло мне так. Пройти даже через две вершины, допустим.
Тогда казалось бы, я пересек раз, два. Ну или сторон раз, два, три, четыре. То есть четное количество. То есть будто бы я снаружи, а она внутри нахожусь.
Вот здесь есть такой гениальный лайфхак, что если вы убираете случайный луч и попали в какую-то вершину, то пустите другой случайный луч.
Чтобы вы два раза подряд попали в вершину, это надо быть не очень везучим человеком. Можно вайл, даже двувайл. Можно двувайл, пока вы попадаете в вершину, перезапускать ваш алгоритм.
Вот. Ну утверждается, что вероятность попасть в точку, в вершину очень низкая. Особенно если вы убираете вещественные коэффициенты.
Проблема с точностью, поэтому выбираете целые коэффициенты. Ну короче, да. Второй метод. Ну есть два варианта как эту штуку улучшить. Не то, что мы далеко уйдем от этого.
А второй вариант такой. Давайте возьмем точку, которая находится на один вправо и на, грубо говоря, бесконечность вверх.
Под бесконечность называется самая верхняя точка плюс один. То есть вот такое вот. То есть утверждается, что вы в вершину никогда не попадете.
Просто-напросто. В силу того, что у вас угол настолько близок к прямому, что вы не можете попасть в вершину. Вообще никак.
Ну все, тогда это не случайный луч и вы победили. В вершину вы никогда не попадете, алгоритм работает.
Ну вот смотрите, вот у вас ваш карнатная сетка.
Где-то у вас есть ваш многоугольник прекрасный. Выберете вашу точку, сдвигаете на один сюда и почти на бесконечность вверх.
Ну типа если у вас все карнаты до 10 в 9 помудрят, то на 1 и 10 в 9 сюда. 10 в 9 плюс 1 вообще возьмите.
Вот. То есть утверждается, что у вас на этой прямой не может быть ни одной вершинки, если у вас целочисленный многоугольник.
На этом луча. Если многоугольник не целочисленный, это не работает, конечно.
Макс поиграет и ты плюс 1.
Ну тогда у вас вы находитесь внутри этого тоненького прямоугольника и вы никогда не попадете ни в какую вершину на этой стороне.
Ну потому что у вас просто все они ниже будут лежать.
Ну это если у вас многоугольник целочисленный, то есть все его вершины в узлах целочисленной сетки находятся.
Если у вас это не выполнять, то этот метод не работает.
Поэтому его не будем даже с тобой описывать.
Давайте теперь нормальный метод.
Он касается того, а что им считать пересечением.
То есть как понимать, что мы пересекаем какое-то ребро на самом деле.
То есть мы сейчас будем разбираться с этим случаем, когда мы в вершину попадаем.
А делать следующее.
Считаем, что луч пересекает сторону.
Тогда и только тогда.
Когда одна из этих двух вершин, из концов ребра будет находиться строго ниже луча.
Привожу пример.
Вот ваша конструкция.
Допустим это кусок многоугольника.
Тогда мы считаем, что мы пересекаем и это ребро, и это ребро.
Получилась магическая шляпа.
А в этом случае вы считаете, что вы ноль раз пересекли, потому что у вас все время выше.
То есть у вас нет точки, лежащие строго ниже луча.
Как это интерпретировать?
Интерпретировать можно следующим образом.
Чтобы касание сверху, мы взяли и подвинули точечку вверх на епсилон.
То есть мы пересекли обе стороны.
Эта идея вытекает из того, что у вас в общем случае многоугольники, координаты у них вещественные,
поэтому у вас есть точность вычтения с плавающей точкой.
И из-за этого будто бы эти епсилон подвигали вверх-вниз.
То есть тогда и только тогда, когда одна из вершин при ребре строго ниже луча.
Почему я здесь говорю? Потому что у нас есть какой-то верх-низ.
В общем случае понятие верх-низ не существует в геометрии.
Здесь все просто.
Чтобы пускать луч горизонтальный на самом деле.
То есть уберете точку, пускаете из нее горизонтальный луч,
считаете число пересечений по такому алгоритму,
у вас все получается.
То есть смотрите, вы для каждой вершины, у которой такой угол,
как бы так сказать, то есть вот у вас лучик, что у вас такой вот угол,
это значит, что вы лежите целиком в ее полуплоскости, внутри угла,
этот вот угран, ну просто угол, да?
И это значит, что вы учитываете будто бы только одно пересечение.
Ну что логично, потому что вы находитесь внутри этого угла.
В некотором плане можно еще считать, что вот этот метод,
он про то, что вы находитесь внутри соответствующих углов многоугольника.
Вот.
А если у вас есть вот такой вот случай, да?
Ну вот как вот здесь вот мы рисовали, да?
То вы считаете, что оба ребра пересекли?
Ну если у вас есть такой вот случай,
ну специально для вот таких вот случаев.
Здесь считается, что новое пересекли, чтобы сбалансировать вот такие вот шпы.
Ну главное то, что у вас все время сохраняется четность.
Что вот такие вот выраженные случаи у вас учитываются по два раза,
либо два, либо ноль.
А вот такие вот случаи, adequately нормальные, учитываются один раз.
Собственно из этого и работает правило у вас про четность.
То есть вы игнорируете вершинки такого специфичного вида,
а вершинки неспецифичного вида краски не игнорируете.
Вот. Ну, алгоритм работает за линию, если что. Опять же, вы
пробегаете просто форм по всем сторонам и смотрите, правда ли, что у вас это работает.
Давайте посмотрим на этом примере для вот такого вот луча. Сколько у нас будет пересечений?
Так, здесь я выше, поэтому этим будто бы не пересекаем. И вот здесь мы пересекаем лишь одну
сторону, вот эту вот на самом деле. Этого не пересекаем. Поэтому количество нечетно и все
сошлось внутри. А, попапа, ну где еще тут можно взять?
Ну, что-нибудь такое, да? Здесь вот вы тоже. А, ну нет, у нас горизонтальные лучи, и все. Ну, давайте
такой вот луч тоже рассмотрим. Это типа горизонтальный луч. Вот он из точки выходит.
Тогда вот здесь тоже будет пересечение лишь одно, а с этим мы и не считаем его.
Единственная проблема с тем, что делать, если у нас есть горизонтальные стороны,
например, у нас какое-то, нет, закончилось место. Вот здесь вот угольник.
Ну, что-нибудь такое, например, да? Ну, буква Г. И вот ваш луч проходит прям целиком через
сторону. Как вы думаете, мы считаем, что он пересекает или нет? Согласно нашему определению, нет.
Это будто бы да, да? Потому что внутри у нас будто бы нечетное количество сторон пересекается или нет?
Сейчас. А, у нас вот она. Вот одна сторона, лишь которую мы пересекаем. Ну да, все, вот мы пересекаем
только эту сторону, а эту мы вообще не включаем в рассмотрение. И эту тоже. Поэтому, опять же,
согласно определению, если у нас сторона целиком лежит 0, чем ее игнорируем?
Вот. Как-то так. Так, окей, пункт Б.
Выпуклый многоугольник.
И множество запросов. Что здесь подрывается под множеством запросов? То, что у вас многоугольник
один, а дальше к нему поступает несколько точек. И для этих нескольких точек нужно определить,
лежат ли они внутри или снаружи. При этом желательно, конечно, для одной точки быстрее,
чем за линию считать. Вот здесь важна выпуклость. Давайте посмотрим вообще,
как красиво устроены выпуклые многоугольники на самом деле.
Такой прикольный многоугольник возьмем, да. Шаг первый. То есть у нас будет две стадии.
Предподсчет и ответ на запрос. Давайте обозначим, что там P1, P2, Pn. P0 так. Жем в 0 индексации все-таки.
Н-1. Шаг первый. Пусть Pi. Точка, самая нижняя точка.
Есть в таких несколько, самая левая. Левая из них. То есть вот у нас две самых нижних точки,
из них берем эту и объявляем ее. Ну типа это какая-то поитая, да. Делаем циклический разворот
нашего массива точек так, чтобы это стало P0. Так, я их нумерал по часовой стрелке, это плохо.
Это грустная история. Давайте их против часов пронумеру. Просто чтобы было чуть удобнее жить.
Сейчас, подождите. Да-да-да, меня по часовой устроят. Ну скажем так, я буду хотеть,
чтобы по часовой было, чтобы было чуть удобнее расписывать. Потому что вы можете определить,
по часовой у вас задан или нет. Если нет, то просто реверснуть массив и будет по часовой.
То есть я делаю циклический сдвиг так, чтобы это стало P0. Ну просто вот так вот сдвигаю
массив циклический. Вот, то есть после этого шага делаем циклический сдвиг так, чтобы поитая на
нулевой месте. То есть теперь это у нас P0, это P1, это P2. Сейчас, подождите, куда сейчас уходим?
Ну да, это по часовой. Окей, нет, сейчас. Всё, да, это против часовой. Извините, что внес, ну туда,
против часовой, конечно. Ну, 21 век. Кто видел последний раз настенные часы? Кроме тех,
что на ЛК висят. Вот, окей. Так, это у нас теперь, теперь у нас всё красиво задано. Почему? В общем,
красота. Красота заключается в том, что давайте рассмотрим просто диагональ этого прекрасного,
шедеврального чувачка. В плане, да, это, конечно, триангуляция, но мы не для этого их рисуем.
Пусть αiT это угол между осью OX и P0PiT. То есть это будет α1, α2 и так далее. Вот я утверждаю,
что для угловного угольника верно следующее неравенство. То есть здесь будет αn-1 и оно у нас
будет строго меньше, чем P. Ну, изменьшить это 80 градусов строго. Почему это так? Потому что у вас
нет точки со следующего угла с 88 градусов. Мы специально выбирали из самых нижних в
самое левое, чтобы у нас такого прикола не было, что здесь было строго неравенство. Ну, а 0 может
быть, если у вас там типа вот такой вот классный многоугольник. Бесполезный, конечно, пример,
допустим. Здесь нам наличие точек на одну прямую не очень помешает. OX, это ось OX. У вас есть
система координат, в которой вы живете. O, X, Y. Ну как еще ось OX обозначают? У меня так вроде
обозначали. Вот, тогда это вроде очевидно. Если у вас многоугольник выпуклый, то это неправда просто-напросто.
Сейчас. У нас так совпало.
Ну, здесь в общем случае имеется в виду. А, это да. Ну да, это тоже не очень принципиально,
будем честны. Все эти конкретные, все эти частности. И что мы можем дальше делать тогда? Шаг 3. А, ну,
предпочет закончился, ответ на запрос. А, кстати, если у вас вот такие вот верные соотношения,
из этого следует в частности, что у вас вот какое-то прекрасное неравенство есть.
Сейчас. Да, строгие неравенства будут. Косинус альфа 2. Косинус альфа n-1. Строго больше, чем
минус 1. То есть вы можете теперь не углы считать. Зачем считать как-то точно углы, если можно считать
косинуса. Да. Окей, ответ на запрос. Пусть угол фи. Это будет угол между осью х и сейчас.
П0 ку. Ку это точка из запроса. Вот у вас ку. Угол, это будет фи. Тогда бинпоискам мы можем найти вот по
массиву. Ну, каким бинпоискам можем искать? Например, важно посчитать косинус этого угла и по массиву
косинусов идти. Вот. То есть найдем такой сектор, в котором мы еще лежим. Что такое сектор? Сектор
если здесь треугольничек. Это может быть бинпоискам, потому что у нас массив косинусов. Тут убывающий,
можете его реверснуть, будет возрастающий. Бинпоискам. Найдем сектор. Окей, нашли бинпоискам
сектор. Ну, теперь вам нужно проверить, лежит ли точка в треугольнике или на его границе. Ну,
это, я думаю, уже просто проверить, лежит ли точка внутри треугольника. Ну, например, не знаю.
Можно провести описанную окружность, посмотреть расстояние. Нет, ты жала же. Самый простой метод,
который я знаю, это взять, построить треугольнички и посчитать сумму площадей. Если
попадается в площадь исходного треугольника, то вы внутри. Иначе у вас будет избыток. Ну, типа...
Да нет, почему? Ну, у вас есть функция площадь многоугольника, которая у нас будет дальше, кстати.
Вы должны проверить, что вы лежите внутри треугольника. Ну, окей, это уже на ваше усмотрение,
как хотите делаете. Ну, можете проверить, что он лежит внутри всех трех этих полуплоскостей,
например. Не знаю. Да, ну, либо углы тут, как хотите. Ну, вообще обычно костюмы сыпьешь,
чтобы оркосинусы от них еще не брать. Вот. У меня был сектор дальше за от единицы. Хоть не знаю,
за три факториала поперебирайте все такие перестановки. Не знаю, за сколько тут можно
проверить, что точка в треугольнике. Короче говоря, это можно делать, конечно, очень сложно.
Можно делать площадями, что он лежит в полуплоскостях. Короче говоря, можно куча способов это сделать.
Вот. Почитали и победили. Ну, поэтому этот запрос в логарифм будет делаться. Потому что все-таки у вас
точка лежит внутри треугольника. Это за от единицы у вас делается. Ну, значит, вы можете брать...
То есть, эта вот часть, проверка того, что кул лежит внутри, это у от единицы,
и бинпоиск по углу. Это, соответственно, этот логарифм по числу вершин. Поэтому у вас будет
О от Н плюс число запросов на лог, итоговое время работы. Это, так сказать, одна из подзадач,
прекрасной задачи Decontest, где нужно строить набор оболочек и дальше искать номер слоя.
Ну, значит, вы лежите внутри. Все. Ну, либо вы лежите отдельно на границе. Тут есть вместо того,
что вы хотите. То есть, как бы здесь, вот про задачу, лежит ли точка внутри многоугольника,
можно сказать, что есть точка на границе. Наверное, она лежит внутри все-таки. Ну,
принадлежит многоугольнику. Так, окей. У нас времени еще. Не, мы сегодня поздно начали,
у нас времени нет на перерыв. Так, площадь многоугольника. Сегодня медленно идем, надо ускориться.
Площадь многоугольника. Здесь тоже будет не очевидно, почему это будет работать,
я оставлю это без доказательств. У нас будут два варианта. Первый вариант – это такой метод
треугольников так называемый. Подержится следующее. Возьмем наш многоугольник, васях координат.
И сделаем вот что. Рассмотрим ориентированные площади вот таких вот треугольников,
построенных на ребре и точке в начале координатов. Утверждается следующее, что площадь – это будет
модуль. Сейчас. Вроде бы здесь 1 и 2. Давай так напишем. От суммы pi от 0 до n-1, площадей треугольника
o, pi, pi плюс 1. Здесь давайте напишу s со звездочкой. Сейчас объясню, что это значит.
s со звездочкой – это ориентированная площадь. То есть у вас s со звездой. Будем считать,
что это 1 и 2 бекторного, ну 50 бекторного произведения. В нашем случае o, pi, pi плюс 1. Здесь
будет браться как 1 и 2 от o. Сейчас. На самом деле не важно. В каком порядке брать. Вы все равно берете
модуль потом от этой суммы. Вот это метод треугольников. Можно так за линию посчитать площадь. Что?
Здесь? Важно. Главное, чтобы в одном порядке все время писали. Можно было бы их помять местами,
но тогда везде надо было бы их помять местами. Тут уже как вы хотите. Главное, чтобы здесь берем модуль,
в конце концов. Конечно, да. Везде модуль здесь соберется. Нам нужно закольцовываться как-то.
Да, если вы будете читать площадь многоугольников, то у вас как будут приколы с тем, что вы можете
случайно пропускать по среднюю сторону. Сразу же здесь скажу, что у вас есть классная задача
про губку-облочку в контесте, где нужно найти ее самой площади. Там типа N ритуальных колонн,
надо построить арену для покемонов, там минимальной площади, бла-бла-бла. Короче,
надо построить губку-облочку, это называется. Там есть умные ребята, которые уже умеют это делать.
Вот, половина таких спадкается на 20-м тесте. Чем этот тест хорош? Он выглядит примерно вот так,
если что. Ну, дизельтирующая губка-облочка у него такая вот. Корднаты этой точки
А вот длина вот этого треугольника, так сказать, это один, и по этой стороне будет тоже один.
Поэтому вам точности дабла просто не хватит. Ну, дабл просто не умеет такой точности считать.
Вы будете брать эту сумму, считать-считать-считать-считать, у него, по-моему,
точности он гарантирует, что 15 знаков первых. Вот, а здесь у вас 18 целых знаков. Вот видите,
он там умирает. Вот, поэтому считайте площадь целочисленная, а дальше там мучайтесь с выводом.
Вот. Все. По-моему, тоже не хватит в контесте. Вам нужно короче езгать IN64T в вашем случае,
а потом смотреть. Если он четный, то уйдите просто деленное на 2.0 в этом контесте специально.
Вот. Иначе, если вы не делите на 2.0, если у вас число не делится на 2.0, вы делите его на 2.0
с остатком и точку 5.0 выводите. Вот, можно доказать, что площадь у вас всегда полуцелая, на самом деле.
То есть, что удвоенная площадь целая. Ну, это вроде очевидно. Почему? Потому что у вас,
если координаты целые, то у вас удвоенная сумма таких штук тоже целая. Потому что эта штука
просто там разность произведений, которая тоже целая. Ну, это так. Лирическое отступление по контесту.
Есть второй метод подсчета площади. Он плюс-минус похож. Просто, я не знаю, мне он как-то кажется
более прикольным. Однако этого хватит, плюс-минус везде. B это метод трапеции. В чем его смысл?
Я позволю себе воспользоваться этим рисунком. Снова будет рассматриваться сумма похожая,
только немножко по-другому устроенная. Будут рассматриваться сумма ориентированных площадей
таких трапеций. То есть, вы берете каждую сторону, проецируете точки на оси и считаете
площадь такого трапеции. Оно не проще, мне просто так кажется красивее. Полу целый. Здесь? Ну, у вас же здесь
электронное произведение. У вас тоже будут трапециями, тоже полу целые получатся. У вас целые не получится
нигде. Как это считать? Как посчитать площадь этой трапеции? Вспомним, что площадь трапеции это
полусумма оснований на высоту. Основание у вас это у, высота это разность х. Внезапно вы поменялись.
Давайте так выпишем, что площадь равна модулю суммы от 0 до n-1. Давайте f' ее обозначим.
f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f' f
это средняя линия трапеции, ну или полсуммы оснований. Вот как считать вот здесь вот эту штуку?
Вот казалось бы, если мы все будем учитывать со знаком плюс, здесь будут приколы. Приколы как бы будут, да.
Поэтому давайте мы будем считать, что мы все время смотрим из ПИТ и в ПИП 1 точку.
Поэтому у нас некоторые трапеции со знаком плюс, а некоторые со знаком минус будут.
Ну и в итоге у вас вот эти вот лишние кусочки, они просто компенсируются трапециями выше них.
Умножить на ПИТ точка.
Давайте из И плюс 1 вычитать.
Все.
Можно на Y проецировать? Ну не знаю, но типа мне как-то на X проще, красивее смотреть.
Вот. То есть да, можно на любую прямую проецировать.
Более того, можно сказать, что на самом деле трапеция это выражен, что треугольник это выражен в случае трапеции.
Что вы проецируете все в 0,0 просто.
Более того, казалось бы, почему мы берем в треугольниках 0,0? Можешь любую точку выбрать.
Ну и это будет правдой на самом деле, для любой точки это верно.
И здесь проецируя на любую прямую, это тоже будет верно.
Вот просто если вы проецируете на ось X или Y, у вас получаются формулы красивые.
Все. Сюжет с треугольниками закончен наконец-то. Я рассчитывал у него потратить минут 25.
Ну ладно.
А теперь второй глобальный сюжет, о котором мы сегодня говорим, это рубклооболочки.
Выпуклые оболочки.
Ну так как мы давали определение выпуклости только в 2D, здесь я себе позволю наглость тоже только в 2D дать определение.
Определение выпуклой оболочкой множества S под множество из R2.
Считаем, что это конечное. В конечном случае набор точек на плоскости берется.
Называют выпуклый многоугольник.
Минимальной площади такой, что для любого S маленького из S большого, S маленький либо внутри, либо на границе.
Обозначается CONF от S.
CONF это конвекс выпуклый. По-английски выпуклый оболочек конвекс HAL называется.
Сейчас я напишу.
Так, конвекс HAL. Вот так вот это пишется дело.
Вот. Чем-то нужно?
Заказал бы незачем.
На самом деле нет, очень много алгоритмов используют всякие выпуклые оболочки.
Ну, самое банальное, это если вы помните, я не знаю, достали вы или нет выигры приставок PSP или геймбоя.
Короче, F2D игры вот так вот скажем.
И там у вас есть, например, стенки.
Ну или там какое-нибудь тело, состоящий из точек, вы просто хотите проверить, что вы там бежите и врежетесь в это тело.
Зачем хранить тело целиком, если можно хранить просто точки какие-то.
И просто строить на них выпуклую оболочку и потом уже все делать.
То есть выпуклая оболочка позволяет ограничить область какую-то, которая должна содержать все точки, чего-либо.
Как это представить себе на интуитивном уровне?
Допустим, у вас вот стоит, ну, самая классическая интерпретация.
Допустим, у вас есть гвоздики на плоскости впитые.
Вы берете канцелярскую резинку обычную.
Вот так вот все помещаете в нее внутрь и отпускаете.
У вас резинка как-то связывает эту штуку.
И получается контур фигуры образованной резинкой.
Вот такой вот.
На самом деле.
Вот.
Окей.
Ну или там, не знаю, например, у вас есть, вы там хотите понять, какого размера у вас тут.
Вы знаете, там грозового облака, например, вы считаете, что оно выпуклое.
Вот там Яндекс.Погода в приложении спрашивает, правда ли, что сейчас идет дождь.
Вот там разные люди понатыкали, да, да, да, в разных точках мы считаем, что земля плоская все еще.
Вот.
И получается, мы можем построить такую выпуклую оболочку, где дождь наверняка идет.
Ну потому что мы считаем, наверное, что у нас туча не имеет дырок внутри себя.
И нет такой области, где везде сыр.
У нас туча не имеет дырок внутри себя.
И нет такой области, где везде света, вокруг дождь.
Вот.
И при этом туча, скорее всего, выпуклый объект все-таки.
Мы верим в это.
Ну что не может быть туча с каким-то таким вот надломом.
Как-то это неестественно немного.
Вот.
Наша реальность естественная.
Ну.
Нашей реальностью все естественно.
Вот.
Ну есть как бы разные задачи связанные с ней.
Это ее построение.
Это добавление точек в множестве, соответственно, ее перестраивания.
Об этом мы говорить не будем в курсе, о динамической выпуклой оболочке.
Будем говорить о статической.
Допустим, что мы на какой-то момент там насобирали данных.
Там тут идет дождь, тут идет дождь, тут идет.
Собрали там выпуклую оболочку.
Вот.
Ну понятно дело, что у вас есть, может быть, наглец, который там стоит по центру и говорит, что на него не капает.
Вот.
Там не знаю, давайте убьем его обманщиком.
Там что-нибудь такое с ним сделаем.
Ну то есть, казалось бы, задача очень простая.
Она в реальности, конечно, усложняется очень сильно.
Вот.
Но алгоритмический или геометрический примитив, который стоит за этим, это выпуклая оболочка.
Вот.
Вот.
Как ее строить?
Ну, есть два алгоритма.
На самом деле гораздо больше, мы будем рассматривать только два.
И первый алгоритм – это алгоритм Джарвиса так называемый.
Или в простонародье алгоритм заворачивания подарка.
Почему он так называется?
Потому что он очень похож на то, как вы будете заворачивать плоский подарок.
Я не знаю, кому вы будете дарить 2D-подарок, но это похоже на это будет.
Вот.
А алгоритм следующий.
Вот ваш, может, точек.
Да, то, что я жуку в первой четверти координатной, это потому, что я так хочу.
Вот.
Что делают?
Шаг первый.
Пусть по ноль.
Самая нижняя.
Из них самая левая.
И вот.
Из них самая левая точка.
Из С.
Так, эта точка не существует.
Вот и наша П0 прекрасная.
Что я делаю дальше?
Шаг второй.
П1.
Такая точка.
Из С.
Что угол между ОХ и П0 П1 минимален.
Минимален имеется в виду абсолютно его значение.
То есть рассматриваем просто все лучи до всех точек.
За линию находим такую точку.
Вот ваша ось ОХ.
Вы рассматриваете до всех точек, вот у вас поясняется ваша П1 прекрасная.
Вот.
Но утверждается, что у вас как-то можно еще написать.
Что это, так сказать, отрезок состоящий из двух самых нижних точек.
Поэтому они обязательно лежат вокруг оболочки.
Как это можно доказать?
Как можно доказать, что П0 лежит в оболочке?
Давайте просто рассмотрим полуплоскость вот такого вот вида.
Извинем ее на ε вдоль этого вектора.
Тогда у вас П0 обязательно лежит в оболочке.
Вдоль этого вектора.
Тогда у вас П0 обязательно должна лежать, потому что она как бы крайняя точка в заданном направлении.
То есть если вы будете двигать вашу полуплоскость вдоль этого вектора, то у вас эта точка окажется крайней в этом направлении.
И более того, для произвольного направления верно, что крайняя точка в нем должна оказаться в выпуклой оболочке.
На самом-то деле.
Ну почему это так? Допустим, что у вас в каком-то направлении крайняя точка не лежит на границе выпуклой оболочки.
Ну грустно.
Допустим, что у вас выпуклая оболочка не содержит вот этой вот точки, она идет как-то вот так вот.
Ну тогда у вас очевидно, что если она не крайняя в таком направлении, значит что у вас есть точки, лежащие по обе стороны полуплоскости.
А мы с вами писали, что тогда многоугольник не выпуклый, просто-напросто будет.
То есть у вас что-либо вы построите многоугольник не выпуклый, либо он у вас не будет содержать все точки.
Потому что если у вас многоугольник выпуклый, то у вас все его точки лежат по одной из сторон.
Вот.
Ну сейчас по этому можно рассмотреть направление автогональное P0P1 и понять, что вот оно будет нужным нам.
Поэтому P0P1 обязательно лежит внутри оболочки, ну на границе оболочки.
Так, ну ладно, все это база индукции была.
Шаг третий и тому подобное они будут строиться следующим образом.
Мы берем текущую P и эту точку.
То есть допустим, что у нас уже первые и-точки набраны.
P и плюс один.
Это будет argmin по углу от, сейчас я скажу кого с кем.
Так, P2 будет получаться как argmin с таким вектором.
Поэтому будет P и минус два P и.
P и минус один.
S, где S маленькое лежит.
Где S маленькое лежит.
С.
Ну можно сказать без этого множества, ну можно забить на самом деле.
Вот так вот будет.
Давайте оставим все-таки, что С без P0.
P0, Pi, плюс один.
Пi-то я просто, потому что у нас уже первые и-точки набраны.
Вот такое вот выражение будет математически.
То есть как это понимать с точки зрения рисуночка, картиночка?
Как найти P2?
Смотрим, P2, то есть i равно единичке, это argmin по этому множеству интересному.
От вектора P0P1, то есть вот он ваш вектор смотрится.
И перебираем из P1 все оставшиеся точки.
И смотрим, до какой из них угол меньше, ну самый минимальный, вот он.
Поэтому это P2.
Дальше вы строите все абсолютно то же самое, вот ваш новый вектор.
С продолжением снова все точки перебираете, у нас получается вот эта вот точка.
И так пока вы не вернетесь в P0, вы утверждаете, что вы рано или поздно это сделаете.
Почему данное множество выпукло?
Ну оно выпукло просто по построению.
Всего того, что вы выбирали минимальный угол все время между продолжением и потенциальной новой стороной,
у вас все лежит в одной полуплоскости.
И так для каждой стороны.
А мы говорили, что для многоугольника это равносильно его выпуклости.
Окей, это сказали, почему выпуклый.
Понятно, почему многоугольник получится.
Потому что вы все время строите отрезки.
Почему у вас получится...
Почему вы все время вернетесь в P0?
Это уже интересный вопрос.
Предлагаю вам над ним подумать.
Рано или поздно это сделаете.
Вот.
Ну типа того, да, например.
Нет, почему вы именно в P0 придете, а не в P1?
Например, это вопрос.
На самом деле ответ здесь плюс-минус еще виден, потому что вы встраиваете точки,
если вы рассматриваете их в полярные углы относительно OX,
вы рассматриваете их ровно до тех пор, пока он у вас все время растет.
Вот как у нас был случай с тем, что мы искали площадь для выпуклого многоугольника,
вот, не площадь, а лежит ли точка внутри выпуклого многоугольника,
вы также можете рассмотреть из P0 вот эти вот углы, которые вы построили.
У вас будут эти порядки возрастания.
И по идее вы должны были бы дойти до 180 градусов,
однако у вас там точек нет, поэтому вы придете в P0.
У вас просто закончатся точки.
Вот.
Окей, дальше что?
Почему он минимальной площади из возможных?
Ну, думаю, это плюс-минус тоже видно по строению,
потому что вы просто-напросто не можете его никак уменьшить еще сильнее.
Вот.
Вот.
Почему это называется заворачиваемым подарком?
Потому что по одной сторону будто бы так вот вы и заворачиваете, в общем-то.
Вот.
Окей.
Да.
Мы берем форум, бежим просто и ищем, у кого угол минимальный.
У кого угол минимальный, тот и победитель.
Да.
И минус один.
Здесь и минус один.
Минус два.
Давайте оценим сложность, да.
Ну, здесь можно оценить, на самом деле, сложность не просто в терминах Ошкия.
Вот такое вот страшное обозначение, если еще помните, из начала семестра.
Тета большая.
Что вы делаете?
Вы, по сути, делаете на каждое вычисление новой точки оболочки n действий.
Поэтому здесь на самом деле действит это n на h.
h это...
Давайте напишем так.
h равно...
Это число точки выпуклой оболочки.
Я пишу алгебридически, потому что это долго писать.
В худшем случае понятно, что у вас множество исходное может быть выпуклым просто-напросто.
Поэтому в худшем случае от n квадрат.
Однако, опять же, если оценка важна будет, если у задачи D, когда будете решать, возьметесь, нормально оценивайте с этим точку.
Это число... это мощность t.
Исходный размер множества точек.
Ну, то есть у вас p0, teta, pn-1 здесь будет.
Ой, фу ты.
Это будет ph-1.
Здесь у вас где-то существует pn-1 внутри.
Ну, или она будет с какой-то из них совпадать, не очень важно.
Важно то, что у вас всего n элементов, а их оболочка и советы с h элементов.
Окей.
Так, ну давайте...
Еще один алгоритм разберем, потому что n квадрат все-таки не очень круто.
Кого?
Точек?
Да вы можете просто поставить булевую пометку, использовали вы ее или нет.
Просто завести массив, типа была ли она использована уже.
И просто их скипать.
Нет, зачем?
Оно рационально придется какие-то хэш-функции там считать. Зачем?
Вы же можете просто завести массив.
В котором будет говорится, что эта вершина уже взята в оболочку.
Все, и лезть в него постоянно.
То есть у вас кое-какого кализни никаких нет.
У вас множество маленькое.
А, пункт B – это алгоритм Грэхама.
Грэхама.
Грэхама.
Грэхама.
Грэхама.
Шаг первый.
Это отсортировать точки по Y, внутри них по X.
Отсортировать точки.
Давайте скажу так, по парам Y, X.
То есть вы можете просто передать ему сравнение по такой вот паре координатов.
То есть здесь мы искали минимум, а здесь мы сортируем сразу.
Что уже?
Вот он.
Логан по времени.
Что?
Это все отлукало.
Вот эти ваши поразрядные сортировки.
Ну да, коронаты целочисленные.
Ну да, раз у нас коронаты все вылежат в N64T,
ну, наверное, можно их сравнивать, будто бы это два Лонг-Лонга и все.
Можно, да, но зачем?
Давайте жить в прекрасном добром мире, где все вещественное и ничего не работает.
Что?
ЛСД.
Я отказываюсь отвечать на такой вопрос.
Пользуюсь 51 статьей Конституции.
Сейчас, зачем по Y их сортировали?
Это лажа полная, нет.
Там не так это делается, я перепутал, sorry.
Можно и так сортировать, тоже будет работать, но я не про это хочу рассказать.
Первый шаг такой, что P0 как в алгоритме Джарвис.
P1 тоже.
Так, кстати, нужна база.
База является как в Джарвисе, то есть у вас что?
P0 так строится и P1 так строится.
Наш P0, P1.
Ну, можно P1 не строить явно, конечно, но построим.
Это все равно немного действует.
Всего лишь линейное.
Шаг второй.
Сортируем точки по углу P0, P1, P0, Pi.
Почему я говорю, что можно было P1 не искать?
Вы бы посортировали их между тогда.
Просто сюда поставил OX вместо P0, P1 и ничего бы не изменилось.
Давайте мы занумируем точки, в каком порядке будем рассматривать.
А, да, в случае равенства, то есть если вы лежите на одной прямой P0, Pi, Pj лежат.
Равенство по возрастанию модуля P0, Pi.
То есть если у вас есть несколько точек на одной прямой с P0,
тогда вы берете сначала эту, потом эту.
Давайте занумируем точки.
То есть это будет первое рассмотрение, это вторая, это третья, это четвертая, пятая, шестая.
Дальше мне будет ли не рассматривать.
Ну окей.
Заведем stack.
Я назову его st.
Вы так не делайте в коде.
Положим туда P0, P1.
То есть stack push P0, push P1.
Называйте нормально.
Если вы скажете, что stack можно буквы f-с называть, это будет очень грустная история.
Окей.
Дальше шаг какой.
Ну кладем.
То есть for.
То есть вы уже сфотировали их.
Ну не знаю.
То есть P0, P1 уже положили.
Вы будете говорить stack.push от P и T.
То есть будто бы вы говорите, ага, эта точка я сразу добавляю себе в оболочку.
Дальше я смотрю.
Смотрю вектор между P0, P1.
Дальше я смотрю.
Смотрю вектор между P0, P1.
P1, P2.
Так, это против часовой стрелки, да? Да.
Если кричащий поворот от этого вектора продолжения до этого вектора против часовой стрелки будет меньше, чем 180, то я ее оставляю в stack.
Иначе буду делать кару небесную.
То есть пока что клад окончен. Сейчас он будет меняться.
Теперь допустим рассмотрим эту точку.
Ну почти по прямому провел.
Вот.
Смотрим угол между P1, P2 и P2, потенциальный P3.
Поворот против часовой стрелки больше 180 градусов от продолжения до вектора.
Значит P2 не лежит в оболочке.
И мы ее будем делать pop из нее.
Ну давайте.
Давайте даже пушить будем просто 4.
Да и все.
Сейчас будет while.
А потом будем туда пушить.
Ну а так скажем следующее, что.
While.
Будем считать, что у нас stack умеет выдавать последнюю и предпоследнюю точку.
Верхний и верхний на один ниже элемента.
То есть есть такая операция, pref top так называемый.
То есть если вот ваш stack, то вот это будет top, а вот это будет pref top.
Будем считать, что у нас stack умеет так делать.
Ну это можно эмулировать тем, что вы делаете pop, делаете top, обратно пушь.
Вот.
While.
Сейчас будет страшно.
Нам нужно будет рассмотреть, что угол меньше 180 градусов, то есть больше 180 градусов.
Вектор будет st, pref top.
st.top.
Это будет первый вектор.
Здесь я воспользуюсь нотацией через точку запятой, потому что здесь все-таки сложно.
То есть это так называемый вектор, последний вектор из сторон в стеке, которые лежат.
В нашем случае это p0, p1.
В первом шаге алгоритма.
Потом мы положили p2 туда и стал p1, p2.
То есть у вас st.top это p2, st.pref.top это p1.
То есть вы смотрите вектор p1, p2.
И st.top запятая pi.
Во, наконец-то мы дошли до pi.
То есть вы рассматриваете два вектора.
Раз, вектор.
Два вектора.
Если их псевдовекторное произведение меньше нуля, то есть у вас происходит то, что...
Как сказать?
То есть у вас происходит вот такой вот поворот.
Вы делаете страшную кару и говорите, что st.top не достоин быть.
Выпукло оболочки.
Что это вектор из двух точек.
У вас эта точка, эта точка.
OK.
То есть while это верно, вы будете выкидывать точки одну за другой.
То есть, например, если бы у вас была бы еще какая-то точка между ними.
Не знаю, какая-нибудь вот такая вот бы.
Сейчас, чтобы была острее.
Ну или где-то вот так вот.
То бы вы построили бы p1, p2, p3.
Потом бы дошли до этой точки.
Выкинули бы эту.
Посмотрели бы, что угол снова плохой.
Выкинули бы эту и только потом бы ее вставили.
И говорите, что st.push от pita.
То есть здесь вот такой вот алгоритм.
То есть смотрите, что у вас происходит в нашем примере конкретном.
Точку мы уберем.
У вас происходит то, что у вас угол больше 180 градусов.
То есть выполняется это условие.
Виноват.
Всегда нужно будет еще вставить условие, что...
Что у вас размер стэка хотя бы два.
Что бы вы могли делать при втопе от него.
Вот.
У вас p2 выкинется из стэка.
Все, ее не было как будто бы, да.
И добавится вот эта вот точка, которую мы рассматривали.
Все, этой точки больше нет с нами.
Мы о ней забыли.
И вот она наша новая p2.
Почему мы здесь сортируем по расстоянию, по такому?
Ну, чтобы этот алгоритм сработал.
Потому что сначала мы найдем эту.
Потом поймем, что здесь все плохо, потому что угол вот такой вот.
Выкинем ее и добавим вот эту сторону в оболочку.
Ну и так далее.
Достроим, достроим, достроим в конце концов.
Строили, строили.
Они наконец построили.
Чему это работает?
Доказывается это по индукции тем, что у вас на каждом шаге перед вайлом в стэке лежит выпукла оболочка текущего рассмотренного множество точек.
То есть, например, когда вы добавили эту точку сюда, утверждается, что у вас внутри стэка лежит выпукла оболочка вот этих вот пяти точек.
Дальше потом у вас происходит добавление этой точки.
Вы такие, ага, все понятно.
Это было полной лажей и выкидываете ее.
Когда добавление, видимо.
Сейчас.
Да, вот это вот.
Когда вот это вот добавили, вы поняли, что это полная лажа.
Ее выкинули оттуда.
Вот.
Ну, доказывается чисто геометрически то, что у вас каждый раз при каждом новом шаге перед вайлом в стэке лежит выпукла оболочка.
Вот.
Ну, доказывается чисто геометрически то, что у вас каждый раз при каждом новом шаге выполнения вайла у вас все будет хорошо.
Вот.
Сколько это работает?
Да.
Что именно?
Мы считаем, что иначе у нее был бы больше полярный угол просто-напросто.
Угол между P0 и P1 и вот этой точкой был бы больше, чем у этой и этой.
Мы бы ее рассмотрели позже, чем эту.
А у нас в нашей ситуации они будто бы на одной прямой лежат.
Но я специально так нарисовал.
Сначала по углу, в случае равенства угла по расстоянию.
Время работы следующее.
Давайте оценим каждый шаг.
Это от.
Потому что просто нужно найти два минимума.
Сортировка у от n log n.
Потому что у вас время работы компаратора.
Посчитать угол, посчитать расстояние.
Это от единиц, наверное, всего n log n.
Вопрос в этой вот странной штуке.
Казалось бы, вайл может работать хоть у от n раз.
Ну, действительно, можно построить такой пример, когда у вас вот этот вот вайл будет выполняться там порядка n-3 раз.
То есть у вас вот за одну итерацию фора, итерация вайла будет n-3 штуки.
Вот.
Ну, на самом деле, давайте подумаем, что происходит с каждой точкой.
Вообще, в чем ее, как живет наша точка прекрасная.
Она живет очень хорошо.
Сначала она жила-нетужила.
Ну, жила-нетужила, вот.
Потом ее закинули в стек.
Она такая, о, я стал кандидатом, выпукло оболочку.
Ну, а что происходит с этой точкой?
Она выпукла оболочку.
Ну, а что происходит с кандидатами в нашем мире?
Они либо побеждают, либо их выбрасывают, вот.
Как бы точка может быть либо выброшенная, она больше никогда не будет рассмотрена.
Потому что она с меньшим полярным углом, она больше никогда не попадает в нашу систему в выпукло оболочку.
Вот.
Либо она победила и осталась в выпукло оболочке.
То есть с каждой точкой происходит два действия.
Не больше двух действий.
Ее один раз добавили в кандидата, а второй раз ее, возможно, не выбросили, а, возможно, выбросили.
Вот.
Все, больше никаких действий с точкой пройти не может.
Это весь ее жизненный цикл.
Поэтому суммарно вайлов внутри всех форов будет отn.
Поэтому весь этот страшный шаг – это отn, на самом деле, суммарно.
Собственно, алгоритм Грехома называется алгоритм Грехома за счет прекрасного прохода с стеком по точкам.
Поэтому суммарное время работы отn log n.
У всего этого дела линия, линия, ам лог н.
Вот.
Да, да, конечно.
Потому что, ну, если у вас есть точка, ну, опять же, в терминах направлений, да, если возьмете вот этот вот трезог,
то вдоль этого вектора вам нужна самая дальняя от нее точка, самая крайняя множество.
Ну, потому что, значит, просто нет смысла ее включать.
Ну и все на этом.
В общем, это весь алгоритм.
Если есть вопросы, обращайтесь, мы больше не успели.
