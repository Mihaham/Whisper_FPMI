Мы продолжаем говорить по динамику, первое что мы рассмотрим это задание перед ноги.
Так, но задача классически сформулируется так-то грустно, что у вас есть гражданитель, который пришел в банк, у него есть рюкзак в местимости W.
И он выйдет там, ну не знаю, не скидки золота, а какие-то драгоценные материалы.
Вот, у каждого предмета есть стоимость и вес.
Стоимость цельная, вес дубльвый, это характеристика каждого предмета.
У каждого своя стоимость, свой вес.
И он хочет украсть как можно больше, то есть максимально суммарную стоимость, чтобы потом продать ее, как можно подороже.
И в этом все должно поместиться в рюкзак, то есть сумма весов тех предметов, которые он пройдет, должна быть больше дубльвая.
Вот, такая классическая обстановка.
Ну ничего, значит решается динамика.
Давайте считаем, что у каждого предмета решается следующим образом.
ВПР, ВПР.
Так, давайте понемногу уберем.
Давайте я их снышу здесь.
Это максимальная суммарная стоимость предметов.
Если можно брать только первые и предметов, то есть у вас не все предметы доступны, а только первые и.
И при этом суммарная веса это х.
Мы ограничиваем нашу задачу, ограничиваем тем, что рюкзак имеет размерность не дубльвое большое, а х какой-то.
И можно использовать не все предметы, а только первые и.
Так вот, максимальная суммарная стоимость предметов.
Если можно выбирать только первые и предметов, ну только из первых и предметов, а суммарная вес ровно х.
То есть у нас доступны первые и вот этих вот товаров, и нам надо набрать вес ровно х.
Хорошо, ну база какая.
Давайте когда у нас, скажем, доступны 0 предметов, тогда ВПР 0,0 это 0.
Когда у нас есть 0 предметов и мы хотим набрать вес 0, то понятно, что у нас максимальная суммарная стоимость 0.
Просто ничего брать мы не должны.
А все остальные ДП 0 больше 0 равно минус бесконечности.
В том смысле, что если у нас доступны 0 предметов и мы пытаемся набрать вес ровно какой-то положительный,
то мы этого не можем сделать.
Поэтому максимальная суммарная сумма их стоимости может быть только минус бесконечности.
Ну это нет ничего, мы соответственно кладем сюда нейтральный элемент относительно максимума, то есть минус бесконечности.
Это как бы знак того, что нельзя набрать такую стоимость.
То это точно не такой вес, да? Никакой положительный вес мы брать не можем.
Так, ну тогда переход.
Если мы добавляем в рассмотрение новый предмет, увеличим его до 1 на 1.
Как у нас может поменяться наш содержимый, наш рюкзака?
Ну понятно, мы добавили один новый предмет в рассмотрение, значит нужно переврать, участвует он у нас в рюкзаке или нет.
Кладем его в рюкзак или нет.
Поэтому будет следующий, начальовательный шуток у формулы.
Здесь, например.
ДП и 1 и С.
В этом акции мы целимся в большую.
По-первых, если мы не берем ДП и 1 предмет,
тогда это соответствует случаю ДП и Х, потому что мне нужно из оставшихся первых И,
если я ДП и 1 точно не беру,
тогда из оставшихся мне нужно выбрать вес ровно Х.
Либо же я и плюс первый предмет беру,
тогда из оставшихся И.
Нужно выбрать сколько-то, чтобы суммарный вес был ровно Х,
и выводить, ну, ДП и 1.
ДП и 1.
Значит, я один предмет в этом насильно беру.
Он уменьшает оставшуюся необходимую массу на свой вес.
Получается мне нужно брать такую массу за первый предмет.
При этом стоимость здесь вот растет на целью сферы.
Значит, еще раз давайте пробежимся.
Если у меня доступны плюс один предмет,
и я хочу набрать сумму весов ровно Х,
тогда у меня есть два способа это сделать.
Либо взять и плюс первый предмет.
Либо не взять.
Если его не беру, тогда мне нужно брать ту же сумму,
меньшим числом предметов, и соответственно получить максимально возможную сумму.
Либо я его беру,
тогда мне нужно брать вот такую вот массу,
такой вес с помощью первого предмета.
Ну, соответственно, понятное дело, максимальная стоимость.
И я еще учитываю вес до этого последнего предмета.
Вот это не вес, а стоимость.
Сэйм просто.
Понятно?
Хорошо, ну и здесь, значит, я считаю,
что если вот эта сумма минус бесконечность,
то минус бесконечность плюс какая-то стоимость,
какое-то число, это тоже минус бесконечность.
То есть, если вот эта флешка не доступна,
то все это вот второе значение тоже минус бесконечность.
Ну а если эта штука отрицательна,
то тоже считаем, что там,
вот так с такой ДПМ не лезем.
То есть, если х меньше, чем w и плюс первая,
тогда вообще вот эта вот сумма не растет.
И платим, чтобы просто это было другое.
Так, хорошо.
Значит, форму у нас легко доесть.
Ну, дальше нужно порядок пересчета.
Ну понятно, нужно просто идти в порядок возрастания
и в порядок возрастания х.
Потому что видим, что каждая новая ДПШ
идет дальше через меньшее значение первого аргумента
и меньшее значение второго аргумента.
Поэтому можно просто в таком варианте перебирать.
Значит, сфор и, там можно было дать,
сфор х, а у меня будет его большое.
Значит, ну мы не вот этот формул записываем,
а это так, что считаем ДПИТХ.
Используем этот переход.
А, и опять, корректно работает,
потому что у нас вот этот ДПИ поражается
через ДПИ с меньшим первым аргументом
или с меньшим вторым аргументом,
точнее, и с меньшим вторым аргументом.
Такое, такое, последствия переходов нам больше подойдет.
Так, значит, что есть?
Определение форму перехода, порядок пересчета,
база, да, и остался ответ.
Ну, ответ здесь тоже несложный.
Это максимум по всем х-ам отряда w,
ДП, n и х.
Тогда мы можем взять любые предметы,
то есть мы можем использовать любые предметы из первых n
и набрать суммарную массу ровно х.
Мы не знаем, какая масса оптимальна,
мы знаем лишь то, что она не больше,
чем w большое.
Ну, давайте всех переберем,
мы возьмем ту, которая дает максимальную возможную стоимость всех предметов.
Вот.
Все, ну и понятно, да, что вот этот х,
оно нигде, собственно, здесь я написал в цикле,
х отряда w,
нет смысла брать х больше, чем w,
потому что, ну, мы никогда точно,
у нас не будет рюкзака,
в котором можно вместить больше, чем w большое,
килограммов, все предметы.
Вот, все.
Такая задача.
Значит, со симптомикой что здесь?
Времени здесь будет t на w большое,
естественно, начало предметов w большое,
это птички мастер рюкзака.
Да, ну понятно, потому что вот у меня здесь два вложенных цикла,
первый заберется в торозе w,
и за лог единицы внутри цикла
насчитывается карта значений w.
Насчитывается, естественно, w это работа цикла,
и внутренняя часть работы за единицу.
Значит, столько времени.
Вот.
Ну и памяти.
Вот в такой релизации, как я написал,
памяти будет столько же.
Но опять, если мы заметим, что каждый слой w,
выражается через предыдущий,
то достаточно будет от w памяти.
От w памяти.
Давайте я еще раз это разговариваю,
но в прошлый раз это замечали,
но сейчас еще раз, конечно.
Я хочу нарисовать эту дыка в виде таблицы,
соответственно, n на w.
Вот это будет дыка моего.
И на эту формулу я вижу, что у меня
И плюс первая строчка, когда у меня первый аргумент сенсирован, и плюс один, а второй пробегает все возможные значения.
Так вот, и плюс первая строчка выражается через иту.
И чтобы найти и плюс первый, мне достаточно знать только иту.
Вся остальная эта история мне не важна.
Поэтому на самом деле, чтобы все вот это насчитать, чтобы узнать последнюю строчку, где лежит ответ, максимальный число здесь – это ответ.
Чтобы все это найти мне, не нужно хранить целиком это таблец.
Мне достаточно хранить только две последние строчки в ней.
и я использую вот эту память, которая хранилась для икру с первой строки.
Теперь мы используем для хранения икру с третьей строки.
Вот, поэтому памяти всего будет по W.
Храним. Ну, я это называю два слоя, но можно говорить, что две строчки в нашей динамике.
Два слоя, то есть, две строки в ВП.
Вопросы есть? Хорошо.
Вот это. Если мы просто, смотрите, что такое вот эти аргументы.
Это значит, что мы хотим набрать вес ровно х, взяв несколько приметов, суммарного веса ровно х.
И при этом мы можем брать только первый икру с один предмет.
Первый и второй, когда икру с первый.
Какие-то из них надо выбрать так, чтобы вес был ровно такой, а суммарные струбки тогда можно больше.
И вот это значит недоступность.
Ну, хорошо. Если у меня есть в доступности только вот эти предметы, и я хочу набрать этот вес,
тогда давайте посмотрим, входит ли икру с первый предмет на последний предмет в оптимальное множество.
Беру я его или нет.
Но если я его не беру, тогда динамика просто равна вот этой штуке.
Раз я гарантирую, что икру с первым я это не беру,
тогда мне нужно, следя оставшихся предметов, взять несколько предметов веса ровно х в максимальную суммарную стоимость.
Это вот это слагаемо, когда я не слагаю до этого момента, до максимала.
Когда я не беру икру с первым предметом.
Если же я его беру, когда я беру икру с первым предметом,
тогда мне нужно из оставшихся предметов, из первых им, выбрать несколько суммарного веса вот такого.
А чтобы потом, когда я добавляю эту дублевую икру с первым предметом, вес стал ровно х.
Ну и дальше я гарантированно получаю такую стоимость из-за икру с первым предметом.
То есть я его взял, отложил в сторонку,
и из оставшихся им мне нужно получить несколько суммарного вот такого веса в максимальную суммарную стоимость.
То есть это просто по случаю с 30 миллионов последних предметов.
Хорошо.
Так.
Что я хочу сказать еще?
Можно сделать немножко по-другому депешку.
Давайте я раз это обрисую.
То есть можно поменять местами вес и стоимость.
Давайте я везу депешку 4.
Вот y.
Это, наоборот, минимальный суммарный вес.
Если я могу брать только такой вес.
Это, наоборот, минимальный суммарный вес,
если я могу брать только какие-то предметы из первых и,
чтобы набрать суммарную стоимость ровно y.
То есть там раньше я фиксировал вес и считал максимальную стоимость.
А теперь сделаю наоборот.
Фиксирую стоимость и буду считать минимальный суммарный вес.
Минимальный суммарный вес
в предметах
если доступны
первые и
а их суммарный вес,
нужно взять суммарную стоимость ровно y.
Так, нужно взять метов
суммарную стоимость ровно y.
То есть все похоже на предыдущий,
только я поменял местами вес и стоимость.
Здесь, соответственно, не максимальная стоимость,
а минимальный вес.
Тут, короче, я базу не буду писать.
Форма перехода аналогичная.
Давайте рассмотрим y плюс первый предмет.
Если мы хотим получить стоимость суммарную ровно y,
то давайте поймем,
вот этот предмет плюс первый,
он учитывается в оптимальном наборе или нет.
Ну, тогда, соответственно, здесь нужно взять минимум из.
В первом случае, когда я не беру y плюс первый предмет,
значит мне нужно взять любое просто итое, игритое.
А когда я y плюс первый предмет не беру,
значит доступность, это только первое и,
мне нужно набрать уже суммарную стоимость.
Вес меняется.
Второй случай, когда я его беру,
значит доступность предметов опять первое и становится.
Стоимость, которую они должны образовывать,
это y минус c и плюс первое.
Потому что я взял предмет,
соответственно, стоимость вот тех товарищей ровно вот такая.
Ну и вес здесь увеличился на w и плюс первое.
Очень похожая форма,
только по сути места менялись весы,
ну и там максимум на минимум поменялся,
потому что мне нужно прификсировать стоимость,
как бы пытаться минимизировать суммарный объем,
суммарный вес сетками.
Вопросы?
Ну и тогда, написав такой же цикл,
то есть поняв, что здесь работает все аналогично,
мы получаем алгоритм со синтозикой,
примерно умножен на c,
вместо n умножен на w.
И, соответственно,
это полезно может быть в случае,
когда у нас, например,
предметы тяжелые, но не очень дорогие.
Например, там, не знаю, какие-то
слитки какого-нибудь металла недорогого,
но зато тяжелые.
Тогда оптимальнее было бы работать
за временем пропорциональной суммарной стоимости,
ну или там, а че-то вот c большое,
c большое суммарная стоимость всех предметов.
C большое это суммарная стоимость
всех предметов.
Ну понятно, что пытаться брать y больше,
чем c большое, бессмысленно,
потому что невозможно брать стоимость
больше, чем c большое,
нельзя взять больше, чем сумму всех стоимости.
Поэтому y недостаточно ограничивать
вот этим вот c,
от 0 до ci можно перебирать.
То есть если раньше у меня было от 0 до w,
то теперь будет от 0 до c большого.
Ну и вот так я сказал,
а если предметы тяжелые,
но дешевые,
то вот это будет оптимальнее.
Если наоборот они легкие,
но дорогие,
тогда оптимальнее будет работать вот тем
он говорит, ну тогда у меня, ну в общем,
время работать за результат веса суммарного,
ну или там, от месимости рюкзака,
тогда это будет получше, чем вот это.
То есть поскольку я просто сравниваю
с ц и w, то лучше и порой применить.
Вот такая идея, что видите.
Да, хорошее замечание.
Нет, не будем.
То есть ничего лучше,
чем то, чтобы
их там умножить все на одну и ту же константу,
ну там на 10 в степени 100500,
чтобы они все стали целыми.
Я ничего сказать здесь не могу,
поэтому считаем, что они все целые.
Вот, давайте
опять попытаемся понять,
нельзя ли было здесь действовать
как-то более, ну в лоб что-ли.
Давайте попытаемся понять,
почему не работает жатану горить.
Наверное, надо было
то динамит рассказывать, то не важно.
Ну как здесь может выглядеть жатный алгоритм?
Например,
просто из всех предметов, которые я вижу,
брать самый дорогой,
который еще умещается в рюкзак.
Да, вот есть у меня там много предметов,
я смотрю, какой из них для меня самый ценный,
и кладу его в рюкзак, если он умещается.
И так делаю много раз, пока рюкзак не заполнится.
Первое, что приходит в голову,
возможно там что-то есть более оптимальное,
ну давайте я такой алгоритм предложу.
То есть наивный.
Показать предмет максимальной стоимости,
пока он умещается в рюкзак.
Так, ну на какой-нибудь пример,
есть у кого-нибудь готовый?
Ну очень много предметов.
Есть один большой,
тяжелый и очень ценный,
а есть куча маленьких, очень легких,
но в сумме их стоимость больше,
чем один большой, тяжелый.
Один предмет в рюкзаке,
который получается полностью в рюкзаке,
а остальные любятся один предмет,
и стоят один.
Да, да, да, действительно, да.
Давайте что-нибудь до гульве конкретное возьмем,
возьмем С1 равно двойке,
а в гульве первое равно сотне.
И потом у вас есть еще куча предметов,
не знаю, там С2, С3 и так далее,
они все имеют стоимость один и вес один.
Тогда жадный алгоритм возьмет этот предмет
как самый ценный, у него стоимость двойка,
это самое большое число среди всех стоимости,
мы его возьмем и все,
и больше никого в рюкзак положить не можем.
Получим стоимость два.
Понятно, что можно сделать получше,
можно взять вот этих предметов много,
поскольку у них присоединится их там вместе со 100 штук,
ну и суммарная стоимость будет минимум
иста и количества этих предметов.
Если там как-то алгоритм на это подхачивать,
и сказать, что давайте мы будем
брать предмет с максимальной плотностью,
в том смысле, что мы будем брать
максимальное значение стоимости на вес,
то есть максимальная удельная стоимость,
максимальная удельная стоимость,
то есть стоимость, поделенная на вес.
Ну здесь тоже самое будет работать,
то есть в этом случае мы отработаем правильно,
потому что у этого предмета
удельная стоимость типа 1,50,
одна единица веса стоит 1,50 рубля,
а здесь удельная стоимость единицы,
каждая единица массы
весит одну единицу денег.
Ну на самом деле,
к этому тоже можно сделать пример,
если хотите, можете подумать,
что они просто тоже строятся.
Короче, никакие такие жадные штуки
у прайдонса.
Чтобы вы не передумали,
я вам могу подобрать какой-нибудь пример.
И на самом деле, лучшее,
что здесь можно сказать,
ну на самом деле,
нам мало известно хорошего прайдонса задачи.
То есть смотрите, вот этот алгоритм жадный,
он должен был бы по идее работать
за какое-нибудь время
по ненавиальной аттенне.
То есть как работает жадный там по идее?
Он как-то ранжирует все предметы
в порядке хорошести,
и каждый раз играет самый хороший предмет.
То есть у него есть там какой-то порядок по предметам,
либо, как я вот здесь в начале сказал,
просто в порядке убывания стоимости сортируется,
либо в порядке убывания вот эту делину веса.
И каждый раз берется просто самый хороший
из доступных предметов.
Но на самом деле,
пока неизвестно ни одного алгоритма,
который бы работал за принимальное время
в этой задаче, что за прямую аттенну?
А это в общем-то случае.
И давайте напишем следующее,
что пока неизвестно ни одного алгоритма решения по задаче.
Так бы работал за полимерное время вот размера фок.
За полином, вот я напишу так,
полином один и вход.
Начну почему это так.
Ну, окей, это сложный факт, конечно,
но почему вот это не является полиномом от входа?
Потому что смотрите, на самом деле,
чтобы задать вот эту цель,
давайте в этом случае.
W занимает входных бит сколько?
Чему равен разный вход,
если мы пытаемся написать число W?
Ну, там говорится логарифм от W.
Если мы вот этот W подаем как набор битиков
нашему компьютеру,
то на самом деле разный вход будет примерно
логарифм от W.
А чтобы задать число, нужно логарифм bit.
И потом у меня еще есть пара чисел,
каждый из которых, ну не знаю,
вес не больше, чем логарифм.
Вот этого числа bit занимает,
W bit, и еще там стоимость тоже какая-то
тоже логарифмическая,
а вот общая стоимость.
Поэтому на самом деле вот эта штука,
это не полинома от длинных входов,
а экспонент, потому что вот это W большое,
это экспонент от длинных входов.
Давайте подробнее это напишу.
Значит, напомню, как у нас выглядит вход
в этой задачи. Есть число предметов n,
стоимость,
вместимость рюкзака от W,
и потом n пар,
W gt, ct,
дофиг n пар.
Давайте посчитаем суммарную длину
этого входа, как мы это подаем компьютеру.
Сколько нужно потратить бит
или цифр, чтобы дать всю эту информацию?
Сколько бит нужно, чтобы передать n?
0 в n, 0 в 2n.
Сколько бит нужно потратить,
чтобы передать w? 0 в 2 w.
И потом еще n раз
мы передаем пару,
где первые компоненты,
ну, давайте скажем, тоже занимает
максимум логи 2,0 бит.
И есть какая-то мешок значения,
скажем, на стоимость логи 2,
cmax.
Что если все стоимости не больше,
чем cmax, то каждая вот эта штука
занимает вам столько битиков,
для того чтобы передать на карту.
Вот, ну, здесь
основное излагание это вот это
и вот это.
То есть лог 2 и меньше,
чем n на какую-то константу.
Ну, здесь там cmax мы
поделим. Вот, получается лог 2 w,
здесь и лог 2 w.
А вот это вот w, которое время работает здесь,
но это, понятное дело, не пальном от той штуки.
Там вы не можете улагорить ни в какую степень
возвести, чтобы получить пальном.
Вам нужно только взять экспонент
от этой суммы,
возвести тройку в эту степень,
только тогда получится w.
Вот.
Ну и
часто такое бывает, что есть
какие-то задачи, которые не решаются
пальном от длины входа,
то есть от описания вот этих входных данных.
Такие задачи часто бывают
очень трудные.
Мы не будем вводить это определение,
но так
короче,
будет у вас какой-то будет курс
по сложности вычисления, вот такая задача будет.
Для нас
это важно только тем, что мы не умеем
решать за пальном, и не только мы не умеем,
но никто не умеет пока что.
То есть если, например, где-нибудь хотите
решить задачу о рюкзаке
с большими параметрами C и W,
здесь сделайте как-нибудь супер-быстрее,
быстрее, чем вот то, и ожидаете, что
ну и я там сейчас решу за пальном
от длины входа, то
либо вы действительно это сделаете
толще миллион долларов в придачу за решением трудной задачи
за пальном, либо вы будете долго думать,
и у вас ничего не получится.
То есть, чтобы реалистично оценивать свои силы,
надо понимать, что какие-то задачи
сложные, и если вы хотите пытаться их решать,
то надо либо вовремя себя
останавливать, либо действительно себя целиком
этому посвящать и пытаться делать за пальном.
Но пока никто не умеет.
Это длина входа.
Значит, давайте я напишу так.
Количество бит
для формировки задач.
То есть, чтобы нашему компьютеру передать информацию
о том, какую задачу мы решаем,
мне нужно передать ему вот этот набор чисел.
Я посчитал его длину и понял,
что вот это время, которое здесь у меня подсчитано,
не является пальном от этой штуки.
Там оно является пальном.
Ну, смотрите.
Мне нужно вот этого степени получить.
Н на w.
Что можно сделать с этой функцией?
Только получить n на w.
Но в какой бы степени я ее не возводил,
там, во 2, 3, 5, 10, у меня никогда
не будет множества вот такого.
У меня не будет w никогда.
У меня будет степень только логеритма по w.
Чтобы получить само w, мне нужно возвести
двойку в эту степень.
Вот если я возведу двойку в степень этой суммы,
тогда у меня получится, ну да, один из множеств и будет w.
В большей степени это там w на что-то там.
Вот.
А если просто буду возводить это в степень,
то я не получу никогда w.
Получу только степень логеритма w.
Окей.
Хорошо.
Так.
Ну все.
Заком мы справились.
Так, давайте еще
про восстановление ответа
пару слов скажем.
Восстановление ответа
всегда в динамике, когда мы хотим получить
ну, грубо говоря, не только численное значение,
но и то, как мы его получаем.
Вот в этой задаче игроке наша цель была
как бы сказать грабителю, какие приметы
надо взять. Ну то есть понятно, что просто
информация о том, какую максимальную
мощность он может утащить, в принципе не очень полезна.
Ему скорее нужно дать стратегию действий,
что грабим первый предмет, седьмой и восьмой.
Вот. А мы ему сообщаем
только вот наш ответ, вот этот вот.
Это просто значение, да, которое
нужно украсить. Просто смартфон.
Давайте тогда сообщим, какие
предметы именно нужно взять.
Вот. Это делается
в многими способами.
Ну давайте самый простой я скажу такой.
Вместе с dp-шкой
мы будем насчитывать
массив
как бы того,
как нужно действовать. Вот смотрите,
когда у меня фиксировано, ставим dp и т.д.,
я выбираю одну из этих двух значений
и давайте буду еще дополнительную
информацию хранить. А как мы получили
вот это значение? То есть мы либо одни из
первых предметов не взяли, да, соответственно,
вот эта штука равна вот этой штуке,
мы сохраним отдельную териенцию, которая говорит, что
в оптимальной стратегии
для таких параметров нужно не брать
первый предмет. Либо, наоборот, его надо было
брать, и тогда, соответственно, dp-шка
равна вот этому, и я сохраню отдельную
териенцию, которая говорит, что нужно его брать.
То есть формально я скажу
следующее.
Ну вот b пусть будет.
Itxt
это ноль, если
значение
dp и itx
достигается
без взятия
иитого предмета.
Ну и один иначе.
Это
насчитать очень просто. Вот в той формуле,
когда мы считаем dp
через что-то предыдущее,
можно написать следующую стручку.
Значит, окей, вот я хочу
найти dp-пусть первое xt, давайте я
сравню уже два выражения. Вот это и вот это.
Если вот это больше, тогда понятно,
что dp-пусть первое xt равно dp-питовое xt,
и в p я
положу нолик, положу нолик.
То есть это означает, что в оптимальной
стратегии для вот этих параметров брать
последний предмет не выберу. Поэтому давайте
я скажу, что dp-пусть первое xt это ноль.
Вот это что-то перевешивает. Если в максимуме
мы берем максимального значения,
второй аргумент, тогда я набросил,
что p равно единице, а p-пусть первое xt равно единице.
Это означает, что в оптимальной стратегии
выгодом взять последний предмет.
То есть, по сути, я просто запоминаю,
как именно я получил все значения динамики.
Вот. Ну а дальше все уже очень просто.
Если у меня есть, скажем,
если я знаю, что ответ
это какой-нибудь dp
n и xt,
то есть я знаю, что чтобы поучить максимальную
стоимость, мне нужно набрать вес
ровно x и использовать первый n-й предмет.
Тогда, по сути,
используя вот эти значения p, я могу
восстановить целиком ответ. Потому что
переменной pnx
у меня лежит информация,
в том, надо ли брать n-й предмет
в ответ. Так если я знаю, что
вот это оптимум, что вот здесь лежит оптимум,
то вот эта штука мне говорит о том,
лежит ли n-й предмет в ответе.
Лежит ли он в оптимум.
Тогда, соответственно, если эта штука ноль,
я просто коррекфанширую,
два случая,
то есть здесь ноль,
тогда я просто пытаюсь набрать тот же
вес ровно x предметов,
а если здесь единица,
тогда, давайте,
стрелочку нарисую.
Если единица,
то я пытаюсь опять использовать
ровно x предмет, набрать вес
уже x минус wn.
Ну, мне просто говорят,
надо использовать предмет или не надо,
если не надо, тогда я уменьшаю количество
и оставляю вес, а если надо,
то я, соответственно, его печатаю и говорю,
что порт, пожалуйста, украдите n-й предмет
и реши задачу для n-й предмета
веса x минус wn.
Значит, дальше, для вот этого я знаю,
что ему ровно w, то и знаю, надо или не надо
брать последний предмет, где последний
уже вот этот вот n-й предмет, ну и так далее.
Итак, я как бы от n к нулю,
я про каждый предмет знаю брать его
или не брать, ну и тем самым выведу все
предметы, нужно взять развертку
оптимально от этого.
Окей?
Да, значит, здесь память действительно
нельзя будет у меня
с крошками находиться, как мы делали
по оптимизации, вот такая память не получится.
Ну, лучше,
по крайней мере, с такой такой реализацией
действительно будет n на w память нам здесь
потребуется.
Потому что здесь, чтобы
восстановить ответ, мне нужны
будут все значения p,
мне нужна будет целиком табличка
за это значение p,
потому что, когда я буду проходить снизу-вверх,
мне нужно будет запоминать, как я все ответы
получал, поэтому нельзя будет
уплотить на только 2-3 крошки,
нужно будет хранить всю историю значений p.
Вот, а на самом деле можно
здесь что-нибудь улучшить,
а Машке будет задача придумать, как
здесь память чуть-чуть порезать,
типа, в корень раз,
по крайней мере, то, что это можно сделать,
но это будет отдельное упражнение
по дозе.
Хорошо.
Ну что ж, тогда, переходим к динамике на матрицах.
Это p на матрице.
Вот, начнем с такой задачи.
Найти
dfn
в процент m
за
вот эвитмическое время,
где f – это число бананчика.
dfn
– это n на число бананчика.
Вот, у нас были числа бананчика в
прошлом смеси, когда мы что-то там про Вэйль-дерево
рассуждали. Давайте я скажу, что f0 – это
1, f1 – это 1.
Вот, а все последующие –
это сумму с предыдущим.
Значит, мне дает какой-то n
достаточно большой, ну там, не знаю,
10,9, скажем,
ну, примерно 10,9 по порядку,
и какой-нибудь модуль m,
по которому надо произвести вычисление.
То есть, если бы я не передавал здесь
модуль и просто просил бы нас
найти fn, то
ну, здесь будет быть сядь линку,
потому что мы знаем, что эти числа довольно
быстро растут.
Там есть как формула, что fn
ну, давайте я напишу так,
а симпатически равно там fi в n,
где fi – это золотое сечение,
то есть эта штука растет как специально
быстро. И если мне
надо будет найти точное
значение, то, ну там,
то само это число растет довольно быстро,
вот, значит,
вообще даже, просто чтобы его вывести,
мне нужно будет потратить какое-то большое
время, пропорционально, ну, по сути,
потому что если на росте fn сайта,
то длина растет линией на 1,5,
вот, ну, да, фальминально как-то.
И, в общем, ну, мы не хотим, да, мы не хотим
теряемому числу печатать, вот.
И часто в задаче кто таких наших?
В общем, которые будут в контестах,
часто ответ нужно будет вывести по модулю.
То есть это нужно нам в основном для того, чтобы
не париться с длинной арифметикой и не учитывать
то время, которое выходит на, в общем,
на подсчет, там, на сложение длинных чисел,
умножение длинных чисел и так далее.
Вот, поэтому мы обычно будем
довольствовать с выводом ответа
к какому-то модулю, нам это будет хватать.
Ну и вообще понятно, что если вы там угадали
fn на процент m, то, наверное, и
без модули вы это сможете, сможете сделать.
То есть если вы знаете ответ,
если вы знаете остаток определения на m
какого-то там большого числа, который надо найти,
то, наверное, вы и само число умеете как его находить.
Если вы угадали остаток определения,
то и само число, наверное, как-то знаете.
Вот, ну хорошо, значит, здесь
работает следующее.
Так.
Так, здесь работает
следующая штука.
Ну ладно.
Давайте заметим следующее соотношение.
Вот.
Вот.
Если я напишу такое умножение двух матриц,
здесь матрица 2 на 2
из нички нулей,
здесь матрица, ну, в общем,
один столбец, два, после этого
будет цепать по началу. Тогда понятно, что если я умножу 1 на 2,
я получу ровно вот это.
Ну потому что как это будет умножение матриц?
То есть я первую строчку умножаю на первый столбец,
получаю fn-1 умножить на 1,
а вторую стручку умножу на 1.
Это как раз fn.
Беру вторую строчку умножаю на столбец,
получаю, значит, просто fn-1,
а это не учитывается,
поэтому вот здесь копируется fn-1.
Вот.
Есть такое простое соотношение, которое, собственно, берется
из вот этого рамки,
что каждая число матрицы равно союет в двух предыдущих.
Значит, если я продолбываю эту штуку
и распишу вот этот столбец
аналогичным образом через предыдущий столбец
значения ровки,
у меня будет вот такая
записка.
Да, но то же самое.
Если fn-1 я выручу через fn-2 и fn-3,
получится, что этот столбец
заменяет вот такое произведение матрицы.
Вот. Но если я так буду делать
до упора,
у меня получится
что-то такое.
У меня получится, что эта матрица
произойдет в степени
а... сейчас, как я покажу.
Ну, видимо, и минус первую.
Вот. А в конце получится столбец f1 в ноль.
Значит, чтобы решить нашу задачу исходную,
чтобы найти fn-1,
мне достаточно будет возвестить как-то быстро
вот эту матрицу в ноль на первой степени,
посчитать от всей значения по мобиле грамма.
Ну, и потом может столбец f1 в ноль.
Потому что fn в ноль в ноль не единицы.
Но давай здесь запишу.
Вот.
Результат у меня будет вот такой.
Значит, чтобы найти начало типа нача,
мне нужно просто вот эту матрицу
быстро всех возвестить.
Окей?
Хорошо.
Она нам не поможет скорее,
потому что вот тут я когда писал,
там есть явная формула
через n степень золотого сечения.
Но смотрите.
У меня есть ли вы вот это число как эффективно
возвестить в степень?
Один плюс торминский по баллам.
Мы его даже представить не можем точно.
Мы можем его представить как бесценечную
дистичную дровь
и возвестить в степень с какой-то точностью.
Но непонятно с какой точностью.
Да, и там придется как-то округлять.
В общем, непонятно.
То есть в этой явной формуле
есть воздействие степень дробного числа,
национального.
И что с ним делать, не очень понятно.
А там с матрицами все хорошо.
У нас все численное.
Все будет замечательно.
Осталось научиться возвестить матрицу в степень
быстро.
Это делается следующим образом.
Пусть нужно найти
а в степени m
по модулю m.
То есть все значения в матрице
надо брать по модулю m.
А это какая-то квадратная матрица, скажем,
k на k.
Матрица k на k.
Тогда есть следующие
простые соотношения.
Во-первых, если n нечетно,
то можно сказать, что av
на это просто a на av минус 1.
Если n нечетно.
А если оно четно, то давайте
мы возведем av в степень сначала m пополам,
а потом возведем в квадрат.
Если n нечетно.
И на этом можно построить
очень простой рекурсивный алгоритм.
Чтобы посчитать в какой-то степени матрицы,
точнее n степени матрицы,
то если оно нечетно, то мы просто
уменьшаем n на единичку и рекурсивно
вычисляем av на n минус 1,
уменьшаем ответ на a.
Либо если n четно, то мы можем
поделить его пополам,
рекурсивно найти av в степень пополам
и возвести в квадрат.
Но понятно, что вот здесь
возвести в квадрат
это сильно проще, чем
найти вот эту штуку
и там на что-то еще умножать.
То есть когда мы знаем этот результат,
то знаем вот это,
то можно получить это
вот.
Получится у нас рекурсивный алгоритм.
За?
Какая будет эта симпозиция?
Скажите мне, пожалуйста.
Я хочу написать k в кубе лвн,
потому что да,
шагов в рекурсе у меня будут
в алгоритмическое количество,
на каждом шаге у меня либо n
из нечетного становится черным,
потом 9 попало, либо оно сразу 9 попало.
Тогда, конечно, глубина моего спуска
она ограничена
двумя алгоритмами, двоичными,
потому что на каждом втором шаге
я делил n пополам,
но на каждом шаге рекурса
я еще либо умножаю результат на a,
либо возвышу результат в квадрат.
То есть по сути я умножаю 2 градуса на k.
Но это является заказом.
Поэтому если a достаточно большая,
то это значительный склад,
и его пренеберегать не стоит.
Вот, в общем-то,
такой несложный алгоритм
за k в кубе лвн.
Ну и замечу,
что так можно воздействовать
не только матрицу,
но и любые числа.
Если у вас будет число a,
вы его хотите почитать в степени лвн,
то работает то же самое,
но здесь будет просто алгоритмическая симпозиция,
а у вас число самостоятельно умножается.
Ну и вот здесь,
давайте еще отмечу,
что когда я беру по модулю,
мне нужно все умножения,
воздействия в квадрат,
делать по модулю,
чтобы никогда не переполнялся тип,
не нужно было делать длинную рифметику,
я просто всегда,
когда возникает какая-то сложная операция,
я ее беру по модуле m,
и здесь я умею решать задачу за логер,
потому что мне нужно вывести матрицу
2 на 2 в степени минус 1,
и это делается за время,
что в 2 кубе множество логер,
и потом может быть вот эта матрица,
которая получится,
на отбой столбец 1 на 1,
тем самым я получу даже не только фн,
но и фн минус 1,
я сделаю больший процент задач,
я найду не только одну числу,
но и 2 соседних,
фн и фн минус 1.
Так, хорошо.
Ну, на самом деле,
можно сказать, что просто фн
на меня искать не получится,
то есть если я не буду писать такой столбец,
а просто буду пытаться высчитывать
фн и фн,
то у меня ничего не получится,
у меня не получится решить задачу,
найти только f1,
а фн минус 1 не находить,
мне придется в мой столбец добавлять
фн минус 1,
потому что иначе что получится?
Если я попробую как-то фн
выразить домножением чего-то
на матрице,
ну значит это столб,
нужно иметь такой же вид,
чтобы оно перекурсивно также расписывается,
если я фн расписываю через фн минус 1,
фн минус 2,
фн минус 1 через фн минус 2 и так далее,
ну понятно, что фн и фн минус 1
я не выключу,
я не беру такое выражение,
мне нужно знать фн минус 2,
поэтому если здесь есть фн минус 2,
то фн минус 1 еще добавляю фн минус 1,
вот и так далее,
получается тот вид матрицы,
который там справа лежит.
Кажется,
можно домножить
на соответствующую строку столбец,
чтобы
был только верхний элемент
из какого-то столбца матрицы
в матрицу 1 на 1.
Не понял.
В финальном выражении
можно домножить на
ну да, можно домножить на матрицу,
которая просто
верхний элемент столбца нам вылез,
то есть
есть матрица, домноженная,
которая столбец, мы получаем просто
первый элемент столбца,
то есть слишком можно.
Я про то, что да,
я про то, что в твоем выражении
скорее нужно две вычитать.
Так, хорошо.
Хорошо, мы это сделали.
Вот, ну и давайте еще
какой-нибудь пример
аналогичного вида.
Главное, чтобы найти
значение конфликтуемки
в какой-нибудь точке.
Например, ну я
от молодыши что-нибудь напишу, пусть.
А 0, а 1, а 2
как это число?
И я знаю,
и я знаю выражение для аяного,
что это какая-нибудь там
ленинная комбинация
нескольких предыдущих слагаемых,
нескольких предыдущих чинов
последовательностей.
Там скажем 3, а-1,
минус 4,
а-2,
плюс а-3,
плюс 1.
Вот что-нибудь такое хочу сделать.
Тогда скажите, пожалуйста,
как мне поступить вот в том же стиле,
какой столбец, вот здесь надо написать,
чтобы был выразлен
через аналогичный столбец предыдущего слоя.
И соответственно, какую матчу надо дам.
4, правда, и что мы тут храним в столбце?
а-1, а-1, а-1,
а-2, а-3,
а-4,
все верно, да?
Давайте вот такой столбец
вещать через аналогичный предыдущий столбец.
Последний элемент столца будет единица.
Выглядит супер тупо, конечно,
вычислять значение единицы
столбец, ну, чего поделать.
Зато получится.
Ну чего, напишем, значит,
мне нужно взять на столбце 3,
минус 4, единицу единицу,
потому что это 3 на вот это,
минус 4 на вот это, плюс 1 на вот это,
плюс 1 на вот это.
Дальше здесь будет такая строка,
такая строка,
и вот такая строка.
Похоже, правда?
Например, единица это 0,
плюс 0, плюс 0, плюс 1.
Все, получается, тоже значение единицы.
Ну и соответственно,
если я хочу вырызать через начальный столбец,
который вот на 0,
1, а-2,
тогда мне нужно эту матчу возле степи,
небольшую.
Тоже, видимо, минус первая.
Здесь будет
а-2,
а-1,
а-0, единица.
Ну и опять, у меня есть
рекурсия на логарифм, который за логарифм
от вот этого умножит на куб размера матрицы,
то есть за 4 в кубе умножен на логарифм,
находит вот этого матрицу
по какому-то данному модулю,
м,
и потом надо будет просто их переноть,
чтобы получить вот эту значение а.
Вот,
вот,
вот,
вот,
вот,
вот.
Окей.
Так, ну собственно, почему это вообще про динамику?
Ну потому что можно, значит,
было бы решать как-нибудь по дуберия
за t,
за t, за t.
Даже можно сказать, за линейное время,
ну можно просто, если у вас есть первые 3 значения,
то можем из них выразить
а-3, потом а-4,
ну и так далее,
то есть просто из этой формулы можно
за линейное время простейшей динамикой,
то есть завести массив длины n,
и выражать каждое значение через 3 предыдущих вот в этой форму.
То есть это как простейший динамик.
Использовать по счёту
числа через несколько предыдущих.
Вот, но её можно оптимизировать
таким образом возле а.
Так, мы сейчас рассмотрим ещё пример
задачи, которые можно
решить с помощью вот этой вот апутехники.
То есть это количество путей
в динамику.
Задача такая, у вас есть
один пункт,
который называется
а-1,
а-2,
а-3,
задача такая, у вас есть
вот этот граф, давайте считаем, что ориентированный,
и нам нужно узнать,
сколько есть путей длины ровно k
из u в v.
Найти
число путей
из u в v
длины ровно k.
То есть граф ориентированный, то есть
за каждый шаг проходит какое-то ребро,
то есть из u сначала попали в какую-то вышину,
потом из неё куда-то ещё перешли, и так далее,
сделали ровно k переходов,
и вам нужно очутиться в v. Вопрос, сколько
способов у вас есть это сделать?
Что?
Да, можно, никаких ограничений
на повторное посещение нет.
Вот, если бы были, то
было бы сильно-сильно сложно.
Значит, здесь я утверждаю следующее.
Пусть m это максимально
высокая графа.
Матрица смежности
с графом.
То есть это такая матрица n на n,
где значение
элементов этой житой клетки
этой единицей, если есть переход из fg
и нолик, если нет.
Мы считаем, что из вершины можно
из вершины перейти. В смысле
стоять на месте?
Но если есть петля, то можно, если нет, то нельзя.
То есть у нас 2 петли.
В принципе, да, ничего не мешает,
то есть это ничему не мешает.
То есть m или ж равно
единица, если
есть
едро из ж.
И ноль иначе.
Поскольку граф ориентированный,
то некаких ограничений
на какую-нибудь симметричность.
То есть не обязательно, если есть едро из ж, то есть
едро из ж и, такого ограничения нет.
Ну и петли, в принципе, тоже никто
не заключает. Возможно, можно
пройтись по петле и остаться
в вершинке, пройдя
как бы одну ребро. Петли, это когда на главной
диагонали стоят единицы, то есть есть вершинки,
можно перейти в себя за один шаг.
Ну тогда, верно, следующее.
Я утверждаю, что если я возведу матрицу
в карту степени
и посмотрю на
ячейку из ж,
то это будет с точности то количество,
которое мне нужно.
Это в точности число путей из ж длины
ровно там.
Число путей из ж
длины ровно там.
Число путей из ж
длины ровно там.
Число путей из ж
длины ровно там.
Вот, ну давайте докажем
индукции по к.
В к равной единице очевидно,
потому что когда
в к равной единице мы получаем
м в первой степени, то есть матрицу смежности,
в матрице смежности
содержимые ячейки из ж
это единицы, если есть путь из ж длины 1,
ну то есть если есть зебро,
и нолик, если нет путь.
Поэтому база очевидна, просто матрица смежности
она отражает, ну по сути, количество путей
за один шаг, можно перейти или нельзя.
Начну переход.
Пусть верно для k-1.
Верно для k-1.
Тогда давайте поймем, что такое
м в степени k в точке ежи.
Вообще, что такое какая степень матрицы?
Это, например, м в первой степени матрицы,
у нас на k-1.
М на м в степени k-1 в клетке ежи.
Значит так, сейчас у меня есть произведение матрицы,
и я хочу посчитать, чему равно значение
в клетке ежи, но я знаю
формулу для
произведения матрицы,
чему равна какая-то клетка.
Это будет сумма,
не окончили буквы.
Пусть будет с, да и нибудь.
М и д д
умножить на м в степени k-1
в клетке ежи.
Правильно верно?
Хорошо.
В этой картинке можно рисовать такую.
Есть вершинка и, есть вершинка ж,
есть вершинка т.
Тогда что здесь написано?
Это я сначала пытаюсь попасть из и в т за один шаг.
И потом из т в ж закануться один шаг.
Ну и понятно, что если я переносу эти количества,
то я получу всевозможные куди
из и в ж длины ровно k,
которые проходят на первом шаге через т.
И потом нужно будет просуммировать а т,
чтобы получить общее количество.
И еще раз?
Не обязательно.
Ну типа это не важно.
Если у нас есть петля,
то может быть таковски я на первом шаге делаю петли,
а потом делаю кубинный каменный сеттинг.
И нет проблем с этим.
То есть возможно т равно и,
тогда мы просто делаем.
Стоим на месте, это будет одно лимо.
И потом еще ищем кубинный ровный каменный сеттинг.
Поэтому это ничему не мешает.
Вот. Ну и еще раз.
Там мы получили такую формулу.
И поняли, что если вот это отображает
количество путей длины 11 в т,
ну по предположению индукции,
вот это количество путей длины ровно k,
не из и из д в ж.
Тогда понятно, что если я их переносу,
то я получу количество путей из и в ж длины ровно k,
которые проходят на первом шаге,
который идет в т.
Затем если я просуммирую это по всем т,
я получу всевозможные пути,
они все упущутся ровно по одному рам.
Приказать.
То есть это действительно вот эта вот штука
в тожке и в ж.
Это как раз количество тех самых путей длины ровно k.
Значит, чтобы решить задачу,
мне нужно просто возвести эту матуцу в степень,
возвести матуцу в степень так,
какой нужно, ровно k,
ну и вывести там какой-то элемент.
Да, все верно, все верно.
Я просто скажу, значит,
на всякий случай давайте считаем,
что мы считаем все по модулю k.
Чтобы опять, да,
поскольку когда мы возводим матуцу в степень,
там будет куча единиц, они будут перемножаться
и складываться очень-очень много раз,
и возможно здесь будут слишком большие числа,
чтобы про это не париться,
мы будем думать, что все литмичные операции
занимают одну единицу времени, один такт.
Это обеспечивается, например,
мы все берем по модуле m.
Да, значит, следующее замечание
действительно про то, что
можно было бы считать, что у нас не граф,
а как это, мультиграф или что-то такое,
тогда у нас бывают кратные ребра.
То есть, например, если здесь я пису одни единицу,
а когда есть много, скажем,
ребр из NG,
из NG может быть несколько ребр,
и вот здесь я буду писать не единичку,
а просто количество ребр между ними.
То есть, просто им это же число ребр.
А у меня здесь ничего не испортится.
У меня по-прежнему m в первой степени
это число путей длины 1,
ну а дальше у меня в k-той
ровно по тому же аргументу
это количество путей длины ровно k,
с учетом того, что у меня будет
несколько разных ребр
между одной и долей парой вершин.
Поэтому вот здесь можно считать,
что у меня может быть одни единицы,
а просто число ребр, то есть могут быть кратные ребра,
это ничего не противоречит.
То есть, оказывается, это рекладывается доском.
Да, у нас исходный граф не взвешен,
то есть у нас нет.
Типа число ребр с суммой длины ребр,
число путей с суммой длины ребр ровно такое.
Ну, не видно как, я не знаю.
Думаю, что нельзя, это звучит...
В общем, короче, думаю,
что не получится даже никак это сделать нормально.
Например, я не знаю.
Итак, значит, следующая вещь,
я хочу предложить, это найти
схожую задачу, только теперь надо найти
число путей длины не больше чем k.
Найти число путей длины не больше k.
Не в точности k, а вот не больше чем k.
Так, есть идея, как решить такую задачу?
У нас есть еще один эффективный вариант,
сколько стоит матрица,
ты скажешь, что это нулевой город, который...
Да, мы сейчас так и сделаем.
Да, а какие матрицы мы суммируем?
Типа того, да, мы сейчас так и сделаем.
А то, что вы сказали про введение
как бы эффективной решения,
то есть, как я понял, вашу идею,
у вас есть граф, да, и...
А, ну, непонятно, вам нужно
попройти что-то потом сюда,
и потом g как бы прийти, да?
Да, просто так можно,
но идея будет подведена несколько раз.
Ну, в котором-то эффективно.
Ну да, вот, хорошо,
мне кажется, что можно доверить,
но чуть-чуть больше надо готовить.
Значит, действительно, ответ такой,
значит, ответ следующий.
Давайте мы сложим...
Ну, я не...
Возможно, и равно g,
поэтому я буду складывать
с ульевой степени.
Давайте сложим все возможные
в этой матрице
и выведем содержимое
и т.ж. течет.
Потому что что такое
подлинный в большем кадре?
Это либо подлинный 1,
когда у нас есть в этом матрице
либо подлинный 0,
либо 2, и тогда 3 пока.
Если мы все эти матрицы сложим
и выведем содержимое и т.ж.,
то получится вот ровно то, что нужно.
Получится, мы сейчас
сделаем целый геймплей.
А, ну я сейчас,
ну да, да, да, все получится.
Значит, первое соблазнство
это следующее. У нас есть геометрическая прогрессия,
давайте напишем форму
геометрической прогрессии и что-нибудь сделаем.
Я напишу, что это идея.
То есть это на самом деле
не решение, а только идея решения.
Сейчас больше может быть
не обратимая матрица.
Именно так.
Это я хочу сказать.
Значит, если мы напишем форму для геометрической прогрессии,
у нас получится что-то вот такое.
Так, где есть единичная матрица
такого же размера.
Вот.
И, как бы, тогда
хотелось бы сказать следующее.
Возьмем матрицу m, все пинка плюс 1, вычисляем единичную матрицу
и делим на матрицу m-e.
Вопрос, как выделить на эту матрицу,
потому что иногда это невозможно сделать.
А эта матрица может быть выраженной,
и, соответственно, просто нельзя поделить.
Ну да, ну в общем, нельзя делить на а.
То есть это поделение, по сути, умножение на обратную,
в эту матрицу может не быть обратной.
Что?
Если мы знаем какую сумму dk из m в карте,
то мы можем узнать ее до двух кратче.
Да-да, мы сейчас так и делаем.
Значит, давайте я допишу, что вот это вот
может быть необратимым.
Поэтому вот такая идея не работает.
И нам придется модифицировать тот наш алгоритм,
который бинарно возводит матрицу в степени.
При этом мы теперь будем не только степень узнавать,
но и сумму первых степеней,
первых нескольких степеней.
Сделаем следующее.
Пусть f, m, dk, d,
это пара из двух матриц.
Первая пусть будет m в карте,
а вторая вот та самая сумма
степеней от 0 до карты.
m в 0, m в 1,
и так далее m в карте.
А вот эта сумма
степени от 0 до карты.
М в 0, m в 1,
и так далее m в карте.
То есть если мы раньше считали
просто карту из степеней,
то теперь мне нужна сумма вот этих вот первых
степеней, ну точнее от 0 до карты.
Вот тогда вопрос.
Как выразить эту штуку
через типа там f от m,
k пополам?
Так, сейчас.
Тяжело, конечно, написать.
Давайте я по-другому.
Давайте это будет f первая
от m, k.
Ну короче, функция с двумя компонентами,
мы на самом деле,
если мы хотим это закодить,
у нас будет просто функция, разучающая пару.
Вот эта матрица и вот эта.
Итак, что такое это f первая
от m, k?
Ну здесь все как обычно.
Если k нечетно, то это просто
f первая от m, k минус 1.
Если четная, то мы выводим матрицу в квадрат.
Вот так, если
k нечетно
и квадрат
вот этой штуки,
если k четко.
Тут пока ничего нового.
Что с f два?
Если k нечетно,
то можно, например, сделать следующее.
Если k нечетно,
то давайте мы отдельно посчитаем
последнее спагами,
рекурсивно найдем предыдущую сумму
и добавим в той сумме вот это
последнее спагами.
То есть я сделаю следующее.
f два от m, k минус 1
плюс f один
от m, k.
То есть мы как бы сначала нашли
к одной степени
в нашей матрице, потом рекурсивно нашли
вот эту вот сумму и добавили
то спагами в конце.
Есть ли конец?
Значит, начнется оно черно,
давайте я напишу, как это может выглядеть.
То есть там будет где-то k пополам,
k пополам плюс один,
так далее.
Пусть хочу.
Тогда можно сгруппировать
первую половину спагаемых
и вторую половину спагаемых.
Сейчас, сейчас, сейчас.
Давайте я все-таки
нулевой убью отсюда.
С ним как-то неприятно получается.
Потом я это еще добавлю в конце.
Давайте вот просто сумму в первой касте
меня и без нулевой.
Вот так виноват.
Вот, тогда будет приятней.
Смотрите, я могу из этой второй скобки
вынести я мкника пополам
и после того, как это получится,
слежим на первой скобке.
Как раз с мкника пополам вынести
я мкника первой, здесь я мкника второй,
и тогда я мкника пополам.
Поэтому здесь можно взять такое.
Сначала я сумму первых
как пополам степеней,
потом нужно один разрядить вот это,
а этому нужно мкника пополам.
Ну, я буду взять линию сням адреса
плюс мкника пополам.
Согласен?
Потому что здесь,
ну, на сути, я выношу просто
вот этот общий множитель,
здесь умножается слева на е,
а здесь умножается слева на мкопполок.
Вот, поэтому что?
Смотрите, а вот эта штука,
это уже f2 от mкоппола.
Е понятно, что такое единичная марка,
тебе считать не нужно.
А это f1 от mкоппола.
Вот, и если я все равно рекурсивно считаю
f1 от mкоппола, f2 от mкоппола,
то потом я их могу вот так вот клеить,
чтобы получить f2 от mкоппола.
Поэтому формула здесь будет такая.
f2 от mкоппола
умножить на
е плюс f1 от mкоппола.
Здесь f1 от mкоппола.
Здесь точно.
Похоже?
Хорошо.
Вот, ну и все, получается, что
опять то же самое, что если мне нужно,
то есть еще раз, я пишу функцию f,
которая означает пару из двух матов,
левую компоненту вот этой пары правой,
f1 и f2,
то если k нечетно,
то я запускаюсь от k-1
и сначала нахожу
вот эту бензебеника,
потом использую эту вещь и использую то,
что почти рекурсивно, нахожу f2, mk.
Возвращаю f2. Если k четно,
то я возвращаюсь с левской
вот так пополам, возвожу
первую компоненту в квадрат, получаю
fкатой, затем вот такой комбинации
получаю сумму
первых кастепеней.
Хорошо. Ну вот.
Все. Получается, что
ассимпозиция здесь
будет такая же, потому что
хотя бы на каждом втором шаге я делю как пополам,
то есть если он нечетно, то я уменьшаю на один,
а он стал четно делю пополам,
если он исходно был исходно, то я сразу его делю пополам,
а поэтому хотя бы каждые два шага
надеются на два.
Поэтому ассимпозиция будет такая же
размер матрицы в кубе,
пусть, например, в кубе,
на лога.
Логализм от показателя умножить
на сложность вот тут
возведения в квадрат, там у меня был
возведение в квадрат, умножение на матрицу,
тут сложение тоже умножение, но понять, что
все эти грозы есть же
ну за отвертку.
Поэтому исходное значение тоже у нас решилось
за fклок и kлок.
Здесь я еще вот этот рем 0 удалил,
ну вот смотрите, рем 0
можно в конце просто всегда добавить,
то есть если я знаю вот эту вот матрицу,
то в конце добавить рем 0 это не очень сложно,
это просто единичная матрица.
Ее можно добавить в ответ.
Я ее такое,
она сильно выкинул, чтобы было проще считать ремку,
но можно обратно ее вставить, чтобы найти
ответ правильной.
Вопросы?
Хорошо.
Так, тогда я хочу
еще немножко переформулировать эту задачу.
Значит нас спрашивают следующее,
а есть ли
хотя бы один путь
из бифжи
длины ровно k.
То есть в прошлой задаче,
мы нашли число путей
длины ровно k, потом длины не больше
чем k, а здесь у нас спрашивают,
а есть ли он хотя бы один.
Можно не считать число путей,
а просто достаточно узнать,
есть ли он хотя бы один или нет.
То есть сравнить это, конечно, с 0.
Есть ли хотя бы один путь.
Можно, конечно, сделать то, что мы делали
до этого,
на возвести матрицу 7 и все такое.
Но я хочу
провестирую на этом значе
другой подход.
А именно, что можно
переопределить умножение матрицы.
Значит, смотрите, пусть так же,
как раньше, это матрица смежности.
Тогда я хочу
примерно следующее.
Я хочу, чтобы дым скатать,
ну вот здесь,
давайте я напишу.
Я хочу
какой-то новый путь навернее ввести на матрицу.
Чтобы содержимое для кедежи
было единице,
если только есть
путь длины ровно k между ними.
Короче, если
вот это вот есть
хотя бы один путь длины ровно k.
0 иначе.
То есть я хочу знать
не число путей,
а просто да или нет.
Едничку или ноль.
Тогда, во-первых,
не надо будет париться с тем,
что мы считаем ответ по модулю.
То есть то, что не нужна будет
ни длинная аризметика,
ни подборку модуля,
правильно я считаю задачу.
Но
для этого нам
будет по-другому определить умножение матрицы.
Давайте сделаем следующее.
Пусть A умножить B,
вот это вот стиль умножения
матрицы С,
чтобы цей кедежи Т
это дизюнкция
вот таких конъюнкций.
Раньше у меня формула для умножения
была такая,
сумма папарных произведений.
Здесь была сумма,
здесь было произведение,
но здесь я взял дизюнкцию конъюнкцию.
То есть по сути
вид формулы остался,
только я теперь использую
другие операции.
Не сумма и умножение,
а дизюнкция конъюнкции.
И тогда смотри,
смысл будет ровно такой,
потому что раньше,
здесь стоял сумма,
и я считал число путей.
А здесь стало произведение,
я считал число путей из IfT
в.
А теперь, смотрите,
если у меня вот эта вот,
это 1 или 0 означает,
есть ли путь из IfT длинной 1,
а эта 1 или 0 означает,
есть ли путь из Т в Ж длинной коинс 1,
тогда, когда я беру конъюнкцию,
я узнаю есть ли путь из Т в Ж через Т.
Я теперь не количество считаю, просто узнаю, есть ли он хотя бы один.
Точно так же, пока можно показать, что точка в гружочной степени карм.
То есть это в каждой степени не относительно обычного умножения, а относительно вот этого хитрого, буливского умножения в адрес.
Так вот, вот это вот матрица, это ровно то, что нужно.
Ну понятно, да, я еще раз на пальцах объясню, что если я перемножаю вот эту длину, а это m в кадре,
тогда это будет m в кадре, с точки зрения вот этого нового умножения.
Я пытаюсь пойти из i в t за один шаг, и потом из t в g, пока минус один шаг.
Здесь единица, если есть такой путь, здесь единица, если есть такой путь.
А то есть на конюнце это единица, только если есть путь из i вживленный карм через t,
когда первая революция идет с t.
Ну и потом я через дизюнцию пытаюсь все такие первые вершины, наверное, после i перебрать.
Соответственно, дизюнция равна единице, если только есть, если я войдет в выгрузку.
Из i в t, потом из t в g. Длины суммарны ровно карм.
Поэтому, если бы мы умели возводить степень вот этой матрицы от такого произведения,
то мы бы решили такую задачу без явного почитка рейтинга.
Хорошо?
То есть по сути мы просто опять объявляем новое умножение и понимаем, что для него
выполняется его то, что мы хотим от этого.
Ну и на самом деле его точно так же можно возводить в степень.
Вот эти матрицы относительно нового умножения ровно так же хорошо работают.
Значит, ну почему?
А что мы там использовали?
Мы использовали обычно, да, что m вкатый.
Это m в степени каппула в карате и слегка четко.
Здесь мы хотим получить что m в этой стильной степени кулифской степени k.
Это то же самое. m в степени кулифской как пополам.
И в квадрате в точку зрения вот этого вот кулифского произведения, если хочу.
Вот это мы хотим. Если это верно, то у нас, собственно, выполняется то, что мы хотим
от длинарного возведения степени.
Опять, достаточно возлагарить москвоскоп в рекурсии,
и потом матрица сама на себя вот так у кулифского нажать.
Но чтобы доказать, давайте мы, наверное, будем доказывать.
На самом деле, здесь достаточно только ассоциативность этой операции.
Факт.
Для этого достаточно ассоциативности.
Экоперации мы уже делим кулифском, но уже не матрица.
Ну, точнее, потому что это факт, это почти очевидно,
потому что если у нас есть ассоциативность,
то есть мы можем доказывать скопки как хотим.
Тогда, что это количество m в степени k в кружочке?
Ну, это m на m, на m и так далее, на m.
И если у меня есть ассоциативность,
я могу в этом произведении расширять скопки как хочу.
Значит, давайте я расставлю скопки вот так вот,
получившись в степени k в полам,
потом вот так вот, еще получившись в степени k в полам,
и потом их перемножим.
Соответственно, если ассоциативность есть,
то точность будет работать.
Сначала первая половина множества литератур,
потом вторая равна ей,
и она выводит сама квадрату и сама на себя.
Поэтому ассоциативности очевидно достаточно,
ну и утверждать, что эта штука E обладает.
Обладает ассоциативностью.
Давайте напомним, что ассоциативность,
это когда a на b на c,
то же самое, что a на b на c.
Ну и так же, как вы там на первой лекции
по линалу кунуг доказывали,
ассоциативность обычного произведения материи,
можно доказать ассоциативность вот этого
гулию кунугу не материи,
когда вместо суммы произведения
стоит резинца и конец.
Вот, в этом мораль такая.
Иногда может быть полезно ввести путь новое произведение,
то есть необычное произведение.
Обычное произведение нужно,
когда нужно какое-то количество посчитать,
посчитать различные способы,
но иногда можно придумать какую-то свою функцию,
свое произведение матрицы,
и в семидарском листочке будет такая задача,
где там нужно будет максимум плюс умножения ввести.
Максимум плюс умножение.
Когда вместо резинца стоит максимум,
а здесь вместо резинца стоит сумма.
В зависимости от задачи,
вам может пригодиться
разные произведения матрицы,
и они соответственно работают точно так же.
Если бинарного произведения в степень,
то мы можем решить задачу
произведения матрицы в степень,
ну и ассимботика тогда будет как всегда
куб размером матрицы
и множного алгоритма в степень,
который вы возводите.
Вот, тогда давайте на этом закончим.
Сейчас спасибо за внимание,
я с вами очень рад.
