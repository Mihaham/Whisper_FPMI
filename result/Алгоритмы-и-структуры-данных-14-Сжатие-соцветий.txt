Так, ну что, мне выпала честь прочесть вам последнюю
лекцию в этом семестре.
Ничего не обещаю.
Вот.
Если где-то обману, то не намерено.
Значит, давайте попробуем построить алгоритм поиска
максимального прочитания в произвольном графе.
Мы умеем в двудольном, с помощью куна.
Вот давайте в произвольном попробуем учиться.
Значит, называется алгоритм Эдманса сжатие соцветий.
Значит, поиск максимального прочитания в произвольном
графе.
Коротенько напомню, у нас есть какой-то неориентированный
невзвешенный граф.
Давайте считать, что там нет петель, нет кратных
ребер.
Вот.
Про сочетание напомню, да, это набор ребер в нашем
графе, таких, что они попарно не имеют общих концов.
То есть, например, вот эти три ребра это про сочетание,
но, например, вот такое вот к ним добавить нельзя,
потому что тогда вот эти два ребра бы пересекались
по вершинке.
Вот мне нельзя, чтобы они пересекались.
Вот.
Значит, это про сочетание.
Соответственно, задача такая, что в данном графе
нужно найти максимальное по размеру про сочетание.
И у нас уже есть удобный инструмент, у нас есть теорема
Бержа, которая говорит нам, что про сочетание максимальное
если и только если нет увеличивающих путей относительно данного
про сочетания.
Мы эту теоремку доказывали, когда говорили про алгоритм
Куна, для двудольных графов, но на самом деле эта теорема
верна и для произвольных графов, и доказывал я ее
в полной общности, не опираясь на двудольные графы.
Давайте напомню быстренько, что такое увеличивающий
путь.
Да, увеличивающий путь – это буквальный путь в нашем
графе, который начинается и заканчивается на ненасыщенную
вершинку.
То есть, ненасыщенные – те, которые не являются
концом ни одного ребра про сочетание, полностью
свободные, никак в про сочетании не участвуют.
Вот.
И дальше по дороге все типы ребра должны чередоваться.
Ребра не из порсочи, потом из порсочи, не из порсочи,
из порсочи и так далее.
Значит, я рёбра не из про сочетания буду рисовать
пунктиром, скорее всего, рёбра из порсочи – сплошными.
Что-то такое должно быть, тогда вот это увеличивающий
путь.
У меня-то было как-то три свойства, что должно быть
хотя бы одно ребро, что концы свободные, и что типы
ребра чередуются.
Вот как раз увеличивающий путь.
Ну и, соответственно, теорема бержа.
Что, значит, m максимально, если только если относительно
m нет увеличивающих путей.
Вот это мы доказали когда-то там месяц назад.
Вот.
Ну, хотелось бы сделать что-то такое же, хотелось бы как-то,
ну то есть мы будем, собственно, наш алгоритм, он по-прежнему
будет просто пытаться находить увеличивающие
пути, так же как и в Куне у нас было, но как бы тут
возникают некие проблемы, потому что, ну вот как искать
увеличивающие пути?
Вот, например, у нас есть какое-то текущее уже набранное
про сочетание, не максимальное, а просто какое-то вот набранное,
мы хотим его увеличить, хотим найти какой-то путь увеличивающий.
Ну вот там, не знаю, давайте переберём как-нибудь эту
стартовую вершинку.
И, ну вот, что делать, там можно запустить, конечно,
полный перебор всех путей, но это будет экспонента,
понятно, куда идти в каждую вершинку, если всё перебирать,
это долго.
Вот.
Ну а как по-другому действовать, не очень понятно, потому
что, ну если пускать какой-то DFS, который как бы пытается
идти по предписанному типу ребер, то есть мне нужно
вот отсюда выйти как бы по неиспользованному ребру,
потом пойти по использованному, потом по неиспользованному
и так далее.
Если запустить какой-то DFS и, ну, не приходить в вершины,
в которых мы уже были, то это не очень хорошо, потому
что если, скажем, вот из стартовой вершинки есть
пути разных длин до какой-то вершины х, ну там, не знаю,
давайте вот так вот как-нибудь нарисую, значит, сначала
здесь было пунктирное ребро, потом сплошное, потом пунктирное,
потом сплошное, потом пунктирное, вот есть такой путь и есть
вот такой путь.
Вот, например, вот что-то такое внезапно получилось.
Тогда, в зависимости от того, как мы сюда в этот
х пришли, да, сначала вот по верхней веточке или по
нижней веточке, в общем, возможно, только один из
этих двух случаев правильный, ну там, не знаю, скажем,
правильный путь это вот такая штука, например,
да, то есть вот это вот увеличивающий путь, но если я внезапно
взял и сначала пошел по вот этому вот пути, пометил
все вот эти вершинки от посещенными, да, и вот как
бы, ну ладно, в эту я не посмотрю, но неважно, эту я уже пометил
посещенной, все, как бы из нее больше ничего смотреть
нельзя.
А дальше я нахожу ее во второй раз, но поскольку
она уже помещена посещенной, я как бы в нее не наступаю,
ну потому что defest так работает, он не ходит повторно в вершинке,
где уже был.
Ну и тогда он не найдет, он вот этот путь не найдет.
Ну вот, как бы, понятно, что просто defest нельзя, потому
что нужно наложить требования чередования типов ребер.
Я вот говорил про defest, который как-то умно пытается именно
чередовать типы ребер, что, скажем, ну не знаю, в defest
я передаю текущую вершину v, да, и какое-нибудь типа состояние,
какой тип ребра нужно сейчас взять, пунктирный или сплошной.
Да, да, да, да, да, да, да, а по нижней пытается, но
сюда не приходит, потому что тут уже был.
Вот, поэтому как-то, ну вот, defest вроде схода не получается.
Вот.
Ну и на самом деле тут как раз проблема именно в том,
что вот возникают такие нечетные циклы, проблема,
на самом деле единственная проблема ровно в том, что
до какой-то вершины может быть два пути разной четности,
это как раз значит, что есть циклы нечетной длины.
Вот.
Это, во-первых, нарушает, ну как бы, таких циклов
нет в вдовдольных графах, поэтому на самом деле алгоритм
куна спокойно работает, потому что кун по факту
просто defest.
Он более-менее ровно это и делает, пытается defest
какую-то пустить.
Вот.
И там таких проблем не возникает, потому что в вдовдольных
нету нечетных циклов, а вот тут бывают.
Вот.
Ну и в целом, как бы, у нас сегодня много будет именно
про нечетные циклы, мы будем их стягивать.
Мы вот найдем такой цикл и сожмем его в одну большую
вершинку, и дальше будем чего-то с этим делать.
Вот.
Ну идея такая.
Значит, давайте, я веду определение, оно такое довольно искусственное,
но с точки зрения рифметики нам будет приятное.
Значит, определение дефектом парасочетания называется
количество непокрытых вершин.
Значит, дефект парасочетания m – это количество ненасыщенных
вершин.
Вот.
Ну тогда понятно, что наша исходная задача максимизации
мощности m – она, по сути, эквивалентна задаче минимизации
дефекта нашего просочетания, ну потому что они там тривиально
связаны.
Если мы знаем размер в плане количества ребер парасочет,
то мы тривиально знаем число непокрытых вершин.
Вот.
Ну это, как бы, эти две задачи эквивалентны, но в этих
терминах чуть проще формулировать некую утверждение.
Вот, поэтому буду говорить про дефект иногда, а минимальность
дефекта нам нужна.
Вот.
Значит, давайте лемма, наверное.
Лемма, тата и бержа, значит, такая.
Минимальный дефект больше либравен, чем максимум
по всем возможным под множеством r в множестве вершин.
Так, как бы это обозначить-то?
Давайте я это назову, наверное, c1 от g – r, минус мощность
r.
Вот.
Где c1 – это количество компонент нечетного размера в графе
g после удаления всех вершин r.
Значит, количество компонент связности, поторопился,
ну ладно, связанности нечетного размера в графе g без r.
Так, значит, перед тем, как сюда переходить, давайте
я задам такой вопрос.
Давайте я поставлю перед собой задачу попроще.
Не поиск парсоча минимального дефекта, а давайте я хочу
узнать, существует ли парсочный львового дефекта, то есть
можно ли покрыть вообще все вершинки.
Можете ли вы мне назвать какое-нибудь тривиальное
достаточное условие того, что такого парсоча нет,
что не существует совершенного просочетания, какой-нибудь
тривиальный этот пояс.
Ну да, что если просто в графе нечетное число вершин,
то, понятно, делать все покрыть невозможно, потому
что каждое ребро насыщает две вершинки.
Ну и это, собственно, дает вот эту вот лему, что если
я что-нибудь удалю и посчитаю количество таких самых
нечетных компонент, то у меня миндефект должен
быть больше или равно вот этому.
Да.
Нет, ну вот так вот, да, конечно.
Доказательство очень простое, давайте выберем произвольное
р, произвольное множество вершин, удалим его из графа,
весь граф распадается на несколько компонент связности.
Вот у меня был какой-то р, давайте я его облачком
нарисую.
Значит, я его удаляю вместе со всеми ребрами инцидентными
этим вершинам, а остаются какие-то компоненты связности.
Ну давайте я их разобью на четное и нечетное.
Вот это пусть будет нечетное, вот это пусть будет четное.
По количеству вершин, четность по количеству вершин рассматриваю.
Ну вот давайте предположим, что я вот это вот все удалил.
Как оптимальным образом может выглядеть просочетание?
Да, ну понятно, что если в каждом из кружочков нечетное
число вершин, то хотя бы одна вершина, если вдруг
существует там совершенное просочетание, то каждая
из этих вершин должна хотя бы одним концом торчать
вот из этого кружочка, потому что их нечетное количество.
Причем торчать она не может ни в другой кружочке,
ни в квадрате, потому что иначе у меня бы склеились
компоненты связности.
То есть на самом деле все ребра, они либо внутри
этих компонентов, либо между R и чем-нибудь, то есть только
такие вот ребра бывают между компонентами.
Ну и значит, чтобы покрыть каждую вершинку вот отсюда,
мне нужно по крайней мере одной вершинкой из R пожертвовать.
То есть мне нужно, чтобы вот эти все чуваки, они
если кем-то и насыщены, то в паре с какой-то вершиной
из R.
Ну отсюда вот это и получается.
Что если скажем, не знаю, вот здесь вот четыре кружочка,
а здесь R имеет размер всего лишь 3, тогда понятно, что
по крайней мере хотя бы одна из них будет ни с кем
не состыкована.
Ну как бы нельзя четыре вершины насыщить с помощью
трех, насытить с помощью трех, поэтому хотя бы одна
будет не насыщена, ну и вот собственно отсюда
возникает эта форма.
Чем больше компонент по сравнению с размером R,
тем больше дефект, то есть тем больше вершин никак
потенциально насыть нельзя.
Так, понятно?
Ну хорошо.
Значит вот такая простая лемма.
На самом деле вот это вот здесь может писать равенство.
На самом деле минимальный дефект в точности равен
вот этому максимуму по всем возможным подможествам.
Вот.
Но мы как бы это вот где-то явно докажем в конце лекции,
ну или не явно.
Короче вот, короче это на самом деле равенство
и это будет ясно после рассмотрения всего алгоритма.
Но нам будет нужна сейчас только вот эта вот неравенство.
Так, что дальше?
Что дальше?
Хорошо.
Дальше мне видимо нужно чередующееся дерево.
Или череду...
Неважно, пофиг.
Нечедающие дерево.
На сете вот что.
Смотрите.
Давайте возьмем какую-нибудь ненасыщенную вершину.
Та, которая не участвует нигде.
Ненасыщенная.
Ну, поскольку она ненасыщенная, то все ребра ей инцидентные,
они не в парсочи, они пунктирные.
Они не в парсочи.
А давайте я еще сразу ее синий покрашу.
Я сейчас буду все вершины красить в два цвета.
Это будет синий.
Значит все ребра из нее исходящие, они автоматически пунктирные.
Ну, значит я могу их несколько вот таких вот нарисовать.
Дальше.
Вот рассмотрим вот эти следующие вершинки на следующем слое.
Если какая-то из них внезапно ненасыщенная,
то мы уже нашли увеличительную вершину.
Если какая-то из них внезапно ненасыщенная,
то мы уже нашли увеличивающий путь.
Ревиальный увеличивающий путь из одного ребра.
Все хорошо, можно его просто добавить к ответу.
Поэтому обычно они будут скорее насыщенные.
Раз они насыщенные, то каждый из них инцидентно какому-то ребру про сочетание.
Ну и давайте их вот здесь вот так вот нарисуем.
Дальше.
Я эти вершины покрашу красными,
вот эти вот, которые являются началами ребер из порсоча.
А их концы опять синими.
То есть у меня будет просто в дереве чередоваться цвета.
Красный-синий, красный-синий.
Ну дальше опять вот эти синие вершинки.
У них уже нарисовано одно инцидентное ребро порсоча.
И дальше могут из них торчать еще какие-то ненасыщенные.
Ну вот там здесь, скажем, два, тут одно.
Тут ничего не торчит.
Тут три, тут одно, тут ничего.
Опять какие-то вершины появились.
Если внезапно нам повезло
и это опять какая-то из них ненасыщенная,
то мы опять нашли увеличивающий путь
и победили, в общем-то.
Можно увеличить порсочетание.
Иначе все они насыщенные,
мы их красим в красный,
и они дают нам новые ребра в нашем дереве.
Концы которых мы опять красим в синий.
Ну, вот это чередующее дерево.
Ну, строить его можно как-нибудь
очень наивным способом.
Например, мы фиксировали корень,
мы фиксировали произвольную ненасыщенную вершину.
А дальше просто, давайте,
какую-то часть дерева я построил,
давайте возьмем последнюю,
необработанную синию вершинку.
Рассмотрим все ее исходящие ребра.
Начнем с этой вершины.
Если есть пунктирная, вненасыщенная,
то путь до корня это увеличивающий.
Если мы рассматриваем новую, свободную,
но она насыщенная,
то сразу строим сплошную ребро вниз.
Это простые случаи.
Но могут быть ребра еще куда-то
внутрь этого дерева.
Может быть ребра куда-нибудь вот сюда,
или сюда, ну короче, еще куда-то.
Значит, это синий вершинка.
Но если мы рассматриваем
новую, свободную вершину,
то мы сразу будем строить
эти случаи посложнее.
Вот.
Ну давайте пока что
на этом остановимся.
Давайте я это дерево назову Т,
и давайте скажем,
что B от T
это множество синих вершин
в этом дереве.
Ну R от T это множество красных.
Вот.
То есть по сути цвет определяется
просто четностью глубины.
Четная 0, 2, 4 это синие,
1, 3, 5 и так далее это красные.
Вот. Хорошо.
Значит, ну давайте считать,
что это дерево полностью рассмотрели,
и таких больше
никуда расточков вниз нету,
из синих. То есть смотрите,
красные я раскрывать не буду.
То есть если я пришел в красную,
то я однозначно ее продлеваю вниз по сплошному ребру,
и никаких выцелений здесь у меня не происходит.
То есть я по сути DFS из красной
не запускаю, только из синих скорее, на обход.
Вот.
Ну а для всех синих, из которых
были ребра куда-то во внешности этого дерева,
давайте я все эти добавлю в мое дерево.
Теперь ребер во вне этого дерева,
из синих совершенно нету.
Вот.
Ну, значит, наблюдение...
А, сейчас, момент.
Наблюдение первое.
Что если
ребро...
Смотрите, у меня остались
ребра теперь только внутри, то есть
из красного куда-то во внешность,
либо из синего во внутренность дерева.
Вот замечание такое, что если
из каждой синих
ребра ведут только в красные,
то
не существует
пути, содержащие вот эту вот
вершинку.
Не обязательно, могут быть.
Могут быть во внешность дерева.
И во внутрь тоже могут быть, да.
Главное, что из синих нет наружу.
Сейчас, сейчас, сейчас скажу.
Значит, смотрите, вот, по-другому скажу.
Давайте я запущу вот этот обход,
который строит мое дерево, из всех
ненасыщенных. Вот пусть я для каждой
дерева ни разу не нашел увеличивающего
пути, но вот эти все деревья
как-то вот так вот построились.
Одно такое дерево,
очередующее другое,
третье.
Все вершины теперь покрашены
в красные и синие.
И для каждой синих
ребра
ведут только в красные.
Вот так.
Вот.
Ну, тогда понятно, что, значит,
тогда я утверждаю,
что дефект минимальный,
он больше равен число вот этих вот деревьев.
А значит,
парсоль уже нельзя увеличить.
Вот.
Значит, почему? Ну, давайте просто вот это леммия
в качестве R возьмем вот то самое R,
как множество всех красных вершин
всех деревьев.
Пусть R это все красные
деревьев.
То есть тогда, когда я его удаляю,
поскольку у меня синие
инцидентно только красным,
ну, точнее, смежно только с красными,
то у меня каждая синяя вершинка
станет отдельной изолированной компонентой связности.
Такой вот, ну,
буквально изолированной вершины из одной точки
состоящей. Да, потому что,
ну, я предполагаю,
что синие между собой не соединены,
соединен только с красными.
Ну, значит, если я просто все красные удалю,
то каждая синие будет сама по себе.
Да.
Нет, не игнорируем.
Почему? Смотрите еще раз.
Давайте гипотезу.
Вот я рассматриваю ситуацию,
когда мы не нашли увеличивающих путей.
Значит, не нашли
увеличивающих путей.
Вот.
А,
значит,
ребра из синих
ведут только в красные.
Вот такая гипотеза у меня сейчас.
Да, то есть они могут быть,
во-первых, смотрите, во-первых, могут быть
ребра между красными, да, например, вот.
Между деревьями, между,
между разными деревьями могут быть ребра между красными вершинками.
Могут быть
даже, наверное,
ребра между синим и красным
из разных деревьев.
Ну и, конечно, внутри дерева
тоже могут быть какие-то ребра.
Но главное, что если один конец синий,
то второй обязательно черный.
Красный, красный, красный.
Если один синий, то другой обязательно красный.
Так вот, ну тогда понятно, что если я
удалю все красные,
то у меня все синие останутся отдельными
изолированными вершинками,
и их будет ровно на три больше.
Из деревьев настолько их и больше.
Потому что в каждом дереве
легко заметить, что вот в каждом дереве
синих ровно на одну больше, чем красных.
Потому что мы начали с синия,
а дальше они парами добавляются, красный, синие,
красный, синие сразу.
Ну все, значит, если я их просто все удалю,
вот, вот, если я их во всем графе
все эти красные удалю,
тогда у меня понятно, что минимальный дефект
окажется большим равен,
чем количество деревьев,
то есть чем количество ненасыщенных вершин.
Значит, больше увеличивать некуда.
Потому что мы
добились такой ситуации,
что ненасыщенных минимально возможное количество.
То есть в любом просочетании
дефект хотя бы такой, как вот в этом,
на счету оптимальный.
Значит, следовательно, текущая м
обладает минимальным дефектом.
Так, что-то понятно?
Значит, давайте еще раз повторю
Смотрите, я строю вот
моё чередующееся дерево
со стартом в любой ненасыщенный.
Вот давайте возьму произвол ненасыщенного,
тут как-нибудь его построю.
Я не специфицирую, как именно конкретно я его строю,
там DFS или BFS, мне не важно.
А вот если вот такая конструкция выполняется,
то это чередующийся дерево.
Вот.
Пункт первый.
Если внезапно во время построения этого дерева
я нашел путь в ненасыщенную,
то есть если вот так вот делал, делал, делал,
и из синих нашел ребро в свободную вершинку,
то можно сделать
чередование вдоль пути
и запуститься заново.
То есть я перестроил парсоч и
сбрасываю алгоритм, начинаю заново.
То есть моя задача это найти увеличивающий путь.
Вот если его нашел, то я прочередовал вдоль него и иду дальше.
Запускаю заново наш алгоритм.
Это первое.
Теперь пусть таких не нашлось.
Таких увеличивающих путей не нашлось.
Значит, второе странное
предположение.
Эти деревья настолько неудачные,
что из синих
бывают ребра только в красные.
Вот как у меня там написано,
что из синих нет ребра в синюю,
есть только в красные.
Она сама по себе в дереве только в красном, инцидентно.
Но еще вот какие-то другие деревья,
другие ребра, которые есть в графе,
они тоже либо в красные,
то же самые компоненты, либо в другое дерево.
Ну не важно.
Тогда вот по тому утверждению можно завершать алгоритм,
потому что лучше некуда.
Порсочи больше быть не может.
Но я стал встретить
содержательный случай.
Это когда бывают ребра между синими.
Давайте аккуратненько
еще раз это законспектирую.
Первое.
Нашелся увеличивающий путь.
Тогда выполнить чередование.
И запуститься заново.
Второе.
Ребра из синих ведут только в красные.
Тогда просто ретёрн.
Всегда просто ретёрн.
Ну и третье.
Есть ребра между синими.
Есть, по крайней мере, одно ребро.
Есть хотя бы одно ребро
между синими.
Вот.
И вот.
Вот.
И вот.
И вот.
В этом случае
мы как раз
будем сжимать нечётный цикл.
Давайте попробуем понять,
что такое ребро между синими.
Если внезапно
есть ребро между синими
разных компонент-связанности,
разных деревьев,
тогда на самом деле
есть увеличивающий путь.
Потому что синие вершинка
в каком-то дереве.
Причём он заканчивается ребром из порсочи.
Предыдущая красная,
это синие.
Потом я иду по ребру не из порсочи,
потому что, очевидно, предыдущий был из порсочи.
И теперь если подняться вверх,
то там будет опять чередование типа фребер
из порсочи, не из порсочи и так далее.
Поэтому если внезапно оказалось ребро
между синими разных деревьев,
тогда всё это склеивается
в один увеличивающий путь.
И мы находимся в первом случае.
И всё хорошо.
Когда мы будем кодить,
на самом деле,
происходит следующее.
Я вот это дерево
строю,
как это по-русски?
Ну максимально, да.
Я его строю до тех пор,
пока не исчерпаются все возможные ребра.
Если исчерпали,
значит таких уже не будет.
Можно считать,
можно считать,
можно считать,
что
это ребро внутри
какого-то дерева.
Внутри дерева Т.
Вот.
Ну и тогда легко понять,
что это ребро стягивает в нашем дереве
цикл нечётной длины.
Значит,
это ребро
стягивает
цикл,
а нечётной длины.
О, здрасте.
Давайте его сожмём.
Почему нечётной длины?
Давайте тут что-нибудь нарисую.
Почему нечётной длины?
Потому что синие всегда
на чётной глубине.
Как устроен путь в дереве?
Это всегда, вот у меня есть две синие вершинки,
возможно они сами на разной глубине,
но обе на чётной.
Что такое путь между ними?
Это сначала надо подняться в общего предка
и потом прыгнуть с помощью вот этого ребра
между синими.
Поскольку вот здесь
происходит ветвление,
то это тоже синие,
потому что у красных всегда один сын.
Это точно синие,
и получается, что у меня здесь чётная длина,
потому что это путь между синими.
Здесь чётная длина, и ещё плюс одно ребро.
Поэтому цикл обязательно нечётный.
Вершинка его,
можно назвать базой
база вот этого цикла,
самая верхняя вершина.
Будет синие,
а весь цикл называется
в оригинальной статье соцветием.
Как это соцветие устроено?
Давайте на этом примере нарисую.
Если здесь есть вот такое ребро,
то вот это соцветие,
значит у него база Синяя.
Из Синий базы исходит два
ненасыщенных ребра.
А дальше чередования по циклу
насыщенную-ненасыщенную-насыщенная.
То есть у меня есть единственная вершинка,
единственная синие, самая верхняя вершина,
из которой торчит два ненасыщенных,
а потом по циклу чередования.
И он ничётной длины.
Единственное нарушение чередования
происходит только в базе,
только в самой верхней вершинке цикла.
Вот. Ну и давайте сделаем следующее. Давайте возьмём и просто вот это всё сожмём, буквально сожмём это в одну большую мегавершинку, то есть вот это всё склеим, все исходящие ребра тоже склеим.
Давайте какую-нибудь картинку нарисуем. У меня было что-то такое, и там куда-то туда торчало ребро, куда-то сюда торчало ребро, что после склейки вот этого всего в одну большую вершинку, у меня вот просто ребро сюда и сюда.
Ну если там кратные, кратные надо удалить, потому что в поиске парсочек кратные нам не нужны. Они на ответ не влияют.
Вот. И утверждается, что так реально можно сделать, то есть можно сжать вот это вот соцветие в одну большую мегавершинку, и от этого ответ не поменяется.
То есть если в этом новом графе с сжатой вершинкой будет, ну точнее не так, в исходном графе существует увеличивающий путь, если только если в новом существует увеличивающий путь.
Идейно, почему это верно. Смотрите, у меня по факту теперь вот эта вот вершинка просто превратилась в большой нечётный цикл.
А что такое увеличивающий путь в новом графе, где вот эта вот сжата? Ну если он вообще через неё не проходит, то и бог с ней, можно просто разжать, и оттого тот увеличивающий путь не изменится.
А если как-то внезапно увеличивающий путь проходит через эту вершинку, если он проходит через эту вершинку, то на самом деле, видимо, нужно чуть более аккуратный анализ.
Ладно, давайте это запишем уже.
Утверждение. Пусть G штрих получается из G сжатием одного соцветия.
Значит тогда в G штрих существует увеличивающий путь, если только если в G существует увеличивающий путь.
Вот, интуиция такая. На самом деле, если в G штрихе, вот в этом новом графе со сжатой мегавершинкой, если здесь есть увеличивающий путь, проходящий через сжатую вершинку, то на самом деле этот путь обязательно проходит через базу, он обязательно входит в базу, это мы сейчас докажем.
Этот путь обязательно на самом деле содержит ребра, входящие в базу, ну а дальше понятно, как тогда это разжать, то есть моя какая цель. Моя цель была сохранить этот увеличивающий путь, разжав вот здесь вот, то есть мне нужно сказать, как мне нужно пройти внутри этого цикла, чтобы сохранилось чередование ребр.
Но если я вышел в базу, если одно из ребр привело меня в базу, то понятно, мне нужно пройти либо вот так вот, либо вот так вот. У меня как раз чередование, ну там, скажем, при проходе по часовой стрелке, у меня будет чередование, начиная, у меня в любом случае будет ребро сначала не насыщенное, потом чередование, но выйти я могу, как бы последнее ребро может быть как насыщенным, так и не насыщенным, как хочу, так и будет.
То есть либо я вот так вот пройду, либо вот так вот пройду, в зависимости от того, что мне нужно от этого ребра.
А если мне нужно, чтобы оно было...
Это фигню, да, сказал?
Да, да, да. Ну, короче, надо показать, что если увеличивающий путь вж-штрих, как выглядит увеличивающий путь вж-штрих? Он обязательно входит с помощью насыщенного ребра в базу, и дальше, понятно, можно, пройдя в эту сторону или в эту, выйти, в данном случае надо вот так вот идти, чтобы дальше было не насыщенное.
Ну, идея такая. И в обратную сторону тоже верно, если здесь какой-то был путь, то после сжатия он будет в ж-штрихе, он тоже останется.
Так, давайте, наверное, пять минут перерыв, и потом это докажем.
Так, что давайте дальше? Да? Да, да, да, да, все нормально, я продумал, все хорошо.
Ну, тут повозится, но вроде получается.
Давайте слева-направо сначала. Тут в обе стороны нет реальной доказательства, но ничего, разберемся.
Слева-направо. Пусть в ж-штрихе после сжатия, после того, как я сжал соцветие, пусть внезапно есть увеличивающий путь.
Ну, надо еще тоже сказать, что я не только в вершинке жимаю, но и по рассочетанию тоже жимаю.
Депенс. Да, именно так, именно так.
Если она была корнем, если база была корнем нашего дерева, то надо еще просто проговорить, как порсочи сжимаются.
Не только граф, но и как порсочи сжимаются.
Ну, понятно, что все ребра вот здесь, бывшие, они пропадают, потому что они становятся ребрами внутри вершинки,
ну и там остальные ребра, какие были ребра в порсочи, такие остаются.
Поэтому, соответственно, вот эта вот насыщенная, если только, если она была корнем.
Ну понятно, если она была корнем, то тут никаких ребер...
Она не насыщенная, только если есть корень.
Вот эта вот новая мега-вершинка не насыщенная, только если есть корень.
Потому что если она была корнем, то там никаких ребер не было и не появилось.
а если она была некорнима какой-то промежуточной вершинкой в нашем дереве, то в неё сверху идёт и
ребро из красной. У меня из красной сверху идёт вниз синяя, значит вот это вот ребро сверху,
оно остаётся, поэтому эта вершина будет насыщенной. Так, это хорошо, это важно.
Ну окей, пусть в же штрихе появился увеличивающий путь. Ещё раз, если он нашу сжатую вершинку
просто обходит стороной, где-то здесь находится, то ну и бог с ним. Понятно, что он будет в же,
поскольку эти вершинки в этом пути не участвуют, поэтому он остаётся. Теперь пусть он как-то проходит
через нас сжатую вершинку. Надо понять, как он через неё проходит. Значит, она либо концевая,
либо какая-то промежуточная. Два случая. Давайте как-то назову, пусть будет W. Пусть W сжатая вершина.
Значит, случай первый. Увеличивающий путь в же штрихе. Ну, одним из концов имеет W.
Ещё раз, два случая. Либо она концевая, либо где-то посередине этого пути находится. Того
увеличивающего пути, который в же штрихе нашёлся, она либо в конце, либо где-то посередине. Первый
случай пусть она концевая. То есть у меня есть W и дальше чередование. Вот что-то такое. Это
увеличивающий путь в же штрихе. Если она концевая, значит, она не насыщенная в новом графе. Значит,
она, как вы правильно заметили, обязательно корень исходного дерева. Раз она в новом графе не
насыщенная, она должна быть корнем в исходном графе. Теперь как разжать. Давайте вспомним,
что такое тогда корень. Корень — это такая не насыщенная синяя вершинка. И дальше, раз мы сжали,
значит, здесь было что-то такое. Ну, как-то так. Смотрите, она является концом увеличивающего
пути. По определению, концы увеличивающего пути не насыщены. Хорошо. Значит, она не насыщена.
Значит, W — это сжатие вот этого вот соцветия. Ну, давайте просто поймём вот это пунктирное
ребро. Ну, где торчит? Ну, где-то торчит. Ну, там вот здесь, например. Ну, тогда понятно,
как надо обойти этот соцвет. Вот так надо рожать. Потому что мне что нужно? Мне нужно всего лишь в
этом цикле указать, в каком направлении пройти отсюда до сюда так, чтобы происходило
чередование. Ну, тут понятно. Тут надо либо вот так вот, либо вот так вот идти. Понятно,
что всегда можно. Как раз за счёт нечётности у меня в одном из двух направлений будет победа. Нет?
Нет? Ну, ещё раз смотрите. Вот W — это вот это вот сжатое вот это вот всё. Дальше давайте рассмотрим
вот это вот ребро. Это на самом деле ребро между вот этой точкой и какой-то из вершин этого
соцветия. Какой-то конкретной вершины вот этого соцветия с базой S. Да, да, да. Если бы она была
здесь, то можно бы выбрать так. То есть мне нужно добиться чередования. Вот, пожалуйста,
вот чередование последнее насыщенное, здесь не насыщенное. Будь она вот здесь вот, я бы пошёл,
наоборот, по другую сторону. Опять чередование. Ну и так далее. Как раз за счёт нечётности у меня
ровно один из двух путей будет хороший. Ровно один из двух путей будет заканчиваться насыщенным
ребром, а значит после него можно рисовать не насыщенным. Так, ну бомба. Всё, значит,
мы разжали в этом случае. Второй случай. Пусть она какая-то промежуточная. Да, W — промежуточная
вершина. Ой, ну давайте рисовать. Вот есть W, она промежуточная, в каком-то увеличивающем пути.
Это значит, что ей инцидентно два ребра, одно из которых ребро парсоче, а другое — не ребро
парсоче. Ну и там ещё что-то. Здесь что-то происходит, мне это не важно. Но главное,
что одно из них ребро парсоче, а другое — не ребро парсоче. Мне нужно отражать, мне нужно
указать, как вот здесь пройти внутренность этого цикла, чтобы всё это вместе превратилось в
увеличивающий путь в исходном графе. Ну тут вроде всё приятно. Смотрите, раз есть насыщенное
ребро, я знаю, что это за ребро. Это вот это ребро. У меня было это ребро, входящее насыщенное ребро
в моё соцветие, никаких других входящих ребров появиться не могло, потому что ребра парсоче не
пересекаются. Вот это ребро — это обязательно вот этот стебелёк, торчащий в нашу базу, в базу
нашего соцветия. Ну а дальше мне нужно выйти каким-то образом по ненасыщенному. И дальше,
как я уже говорил, в одну из двух сторон опять то же самое. Можно пройти либо поучиться,
либо против, так чтобы закончиться насыщенным ребром и выйти по ненасыщенному. Давайте я картинку
на 90 градусов переверну. Вот так вот нарисую. Вот. Ну и всё, вот это получается база. И дальше
в одну из двух сторон можно рожать. Понятно? Ну всё, значит, этот случай разобран, в одну сторону доказали.
Теперь обратно. Теперь обратно. Значит, в обратную сторону. Если в исходном графе g
существовал увеличивающий путь, то после сжатия соцветия он не пропадёт, он по-прежнему будет.
Так, ну хорошо. Давайте я как-нибудь это всё поназываю. Давайте я как-то назову. Давайте я скажу,
что вот в этом исходном графе я рассматривал просчитание m, после сжатия оно стало m-штрихом.
Давайте я нарисую наши соцветия. Как у меня выглядят соцветия? Ну как-то вот так. Вот. И
здесь соцветия, собственно. Вот здесь вот какая-то такая штука, которая образовывала соцветия.
Вот это вот соцветие. Вот. Всё вместе это иллюстрация просчитания m. Первое,
что я сделаю, это возьму и внезапно прочередую типы ребер вот на этом вот пути от корня до базы.
У меня всё поменяется, и вот это станет ненасыщенной. Это станет насыщенной, тут поменяются типы ребер.
Вот. Больше ничего не меня, то есть я поменял только вот этот вот стебелёк. Я изменяю и
очередую всё на стеблю. Я на стеблю что-то меняю, а здесь у меня всё остаётся. Тогда вот это станет
свободной, потому что единственное инцидентное ребро из парсочи пропало, а это станет насыщенной.
Пусть это будет n. Парсчитания n. Так. Хорошо. Значит, давайте то же самое в же штрихе сделаю.
То же самое сделаю в же штрихе. Это всё было в графе g. Это симметрично для же штриха.
Ж штрих отличается от g только тем, что в соцветия сжата в одну вершинку, но там вот эти вот типы
ребер на стебле они не отличаются. Они такие же. Там такое же чередование. Сначала они насыщенные,
потом насыщенные. Вот. И вот это вот всё. Это одна большая вершинка w. Так, это у меня парсчитания
m. Ну и n штрих я аналогично построю, про чередовах на стебле. Значит, тогда у чудо опять w станет
ненасыщенной. Что здесь база была ненасыщенная, что здесь теперь w стала ненасыщенная. Потому что
опять, ей был инцидент на одно ребро, я его инвертировал, оно стало ненасыщенным. Значит,
вершинка тоже свободна теперь. Вот. И что? Я хочу теперь доказать по факту, что если здесь был
увеличивающий путь, то он будет и вот здесь вот. Вообще говоря, зачем я это сделал? Вообще говорят,
сделать непонятно как. Потому что что такое увеличивающий путь в этом исходном графе? То есть,
моя цель какая? Моя цель была взять какой-то увеличивающий путь в этом старом графе и построить,
как он выглядит после сжатия этой вершинки. Но это непонятно как сделать априори, потому что
увеличивающий путь может внутрь этого соцветия заходить как угодно. У меня же не только вот эти
ребра есть, но и всякие другие. Увеличивающий путь мог войти сюда как-нибудь пройти, потом опять
выйти, походить, погулять, зайти обратно, выйти и так далее. Когда его сжимаю, части пути тоже
сжимаются и, возможно, там будут какие-то противоречия. Поэтому надо повозиться. Ну возимся.
Еще раз, я хочу доказать, что эта штука, что есть увеличивающий путь, если есть увеличивающий путь
здесь, то есть здесь. Но давайте сначала скажу следующее, что если есть путь здесь, то есть здесь.
Значит, утверждение, если в исходном графе g был увеличивающий путь относительно m,
то в том же графе g, но с прочесанием n, тоже есть увеличивающий путь. Это почему?
Это совсем простой факт.
Нет?
А Бог его знает? Ну я не знаю, но как раз я утверждаю, что если тут был, то и здесь останется.
Нет, в этом ты прикол, что увеличивающие пути сами по себе никак на цвета вот эти не завязаны.
То есть в каком-то смысле я DFS просто запустил, что-то там покрасил еще внутри DFS,
а мне нужно все пути рассмотреть. Ну непонятно. У меня вполне возможно какие-то увеличивающие
пути я просто пропустил. Что-нибудь сильно петляющее между деревьями, я такие пути не уловлю.
То есть мой алгоритм пытается найти только увеличивающие пути по типу начали в одном дереве,
спустились вниз, перепрыгнули в другое, поднялись наверх. Возможно, есть другие,
как ты между деревьями перепрыгиваешь. Вот, но если есть тут, то есть тут.
Так, ладно, давайте по-другому сформулирую. Какое у нас есть эквивалентное условие на наличие пути
от увеличивающего? Да, просочный максимален. У них мощность одинаковая, потому что я сделал
чередование вдоль четного пути. Поэтому это максимально, если только если это максимально,
у них просто мощность одинаковая. Значит, увеличивающие пути тоже. Если тут есть, то и тут есть.
Почему? Так как мощность m и n максимальная, значит, они либо оба одновременно максимальны,
либо одновременно не максимальны. Но поскольку относительно m был увеличивающий путь,
значит m не максимально, тогда и n не максимально. m не максимально,
следовательно, n не максимально, следовательно, есть увеличивающий путь относительно n.
Сойдет? Вот. Ну, то же самое тут. Значит, вот это импликация. Если вот здесь,
в новом графе g' относительно n' был увеличивающий путь, то и относительно m' он тоже будет,
ну, по той же самой причине, потому что они отличаются чередованием вдоль четного пути,
и значит, эта просочи одинакого размера, они либо оба одновременно максимальны, либо оба
одновременно не максимальны. Значит, если есть путь тут, то есть путь тут. Ну, осталось доказать
одну импликацию между n и n'. Так, ну, это вроде можно сделать. Мне осталось доказать следующее,
что если в графе g есть увеличивающий путь относительно n, то в g' есть увеличивающий
путь относительно n'. Относительно этого прочитания. Вот. Ну, давайте как-то вот,
я его тут нарисую. Пусть есть какой-то увеличивающий путь относительно n. Если он сюда
не заходит, если он вообще не задействует это соцветие, то и отлично. Оно полностью наследуется
в n' в новом графе, оно таким же остается. Пусть оно как-то здесь заходит. Ну, давай что-нибудь
стрёмно нарисую. Как-то заходит сюда, что-то использует, выходит. Потом опять зашло,
поиспользовало, вышло. Ну, и там рано или поздно началось и закончилось в ненасыщенной вершинке.
Вот. Ну, давайте возьмём, скажем, последний момент времени, когда мы были ещё в соцветии. А дальше
просто давайте по циклу замкнём сюда или сюда. Так, чтобы сохранилось чередование. То есть я вот
всю стрёмную часть пути отрезаю и оставляю только более короткий путь из ненасыщенной сначала до
соцветия, ну и потом внутри соцветия так, чтобы оно шло вот до сюда вот. Тогда, соответственно,
я любой мой увеличивающий путь обрезал до пути, которая начинается вот здесь вот. Ну опять,
за счёт того, что у меня цикл нечётный, я могу пройти либо вот так вот, либо вот так вот,
сохраняя чередование ребер. Значит, можно считать, что мой путь увеличивающий на самом деле не такой плохой,
а вот такой вот просто. Как раз я пользуюсь активно тем, что вот это вот ненасыщенное,
значит, можно вот это всё лишнее обрезать и просто пройти вот сюда вот. Ну и всё, понятно. А этот путь
уже очевидным образом вот здесь вот наследуется. Просто вот это всё сжалось вершинку, соответственно,
здесь вместо пути просто точка, вот эта вот w, ну а это всё наследуется как кусок пути. То есть я, да?
Ну ещё раз, смотрите, вот пусть был какой-то стрёмный путь. Такой вот какой-то, да? Который
начинается и заканчивается в ненасыщенный. Давайте пойдём с конца и найдём последнюю вершинку,
ну точнее как бы последнюю вершинку из соцветия. Значит, это какая-то вершина, все вот эти в соцветии
не лежат. Это какое-то ребро, насыщенное или ненасыщенное, мне до лампочки. В зависимости
того, насыщенное оно или нет, я могу пойти либо вот так вот по циклу, либо вот так вот, чтобы
здесь было чередование. Насыщенное, ненасыщенное, насыщенное, насыщенное и так далее. Значит, я начинаю,
заканчиваюсь в ненасыщенной и у меня сохраняется чередование. Поэтому я любой мой более сложный путь
урезал до пути, проходящего внутри соцветия полностью. Неважно, да, неважно. Ну что такое вообще
увеличивающий путь? Это просто путь между ненасыщенными, чередующийся, чередующийся путь
между ненасыщенными. Вот был такой большой, длинный, но я тебя покороче построю, вот он есть. А дальше
его уже легко нарисовать в же штрихе. Кажется, все, корректность доказали. Вот, так еще раз, смотрите,
я для этого специально, вот у меня был длинный путь, я иду с конца и выбираю первую вершинку в
соцветии. Значит, все вот эти не в соцветии и они никак не конфликтуют с этим вот путем. Не с этим,
не вот с этим. Да, вот здесь вот что-то было внутри соцветия, но я все это отбросил. Я оставил только
вот этот хвост, а он у меня полностью снаружи лежит. Так, вопросы можете? Ну еще раз, потому что мы же
обстроили, что DFS не работает. Да, DFS, если предписать ходить по очередному типу ребер. Еще раз?
Ну, ну, ну. Еще раз, ну DFS вам на чередование обустроить обязательно. Как в чередовании в DFS
обеспечиваете? Да. Ну еще раз, я примерчик же рисовал, что если вы, вот скажем, вот это и вот
этого, надо отсюда до сюда найти, дойти на самом деле. Давайте продублирую. Так, фигню, фигню. Еще раз,
вот что вы тут делаете? Вам надо найти вот этот путь, это единственный увеличивающий. Пусть вам
не повезло и вы пошли вот так вот. Вы помечаете ее использованной или нет? Если помечаете,
то GG, потому что надо было вот так вот пойти, по-другому никак. А если вы не помечаете и ходите
из нее и вот так вот, и вот так вот, это экспонента, конечно, потому что если у вас вот столько много
треугольничков будет, и вы в каждом, то есть тут проблема в том, что вы в вершину могли
прийти и четным путем, и нечетным. Если вот такую цепочку сделать, то вы как бы, ну тут будет два
в степени пополам. Вот еще раз, да, вот это как раз то, что я сказал. Если вы храните два бульских
флага, можно прийти так и так, то вы из каждой вершинки можете в худшем случае дважды запуститься
DFS. И вот на таком примере это будет экспонента, потому что вы вот сюда придете дважды, потом сюда
четыре, сюда восемь раз, ну и так далее. Ну там, может как-то можно соптимизировать,
но короче, это в общем случае не сработает. Короче, я обещаю, что не работает. Ну подумайте,
ну что-то там должно довольно быстро все сломаться. Так, значит еще раз, вот к секущему моменту,
что мы доказали? Я там стер наш три этапа, ну три варианта, ну ладно. Значит еще раз,
моя задача была найти увеличивающий путь. То есть мой алгоритм такой же, как всегда. Пока можно,
находи увеличивающий путь, чередуй, запускай заново. Пока есть увеличивающий путь, чередуй,
запускай заново. Итого, либо я нашел увеличивающий путь, либо ребра из синих ведут только в красный,
тогда return, потому что нельзя увеличивать по лемме. Либо нашлось ребро между синими,
но тогда можно бесплатно сжать соцветия и решать задачу в меньшем графе. Поскольку я сжимаю,
у меня уменьшается число вершин, у меня упрощается граф, можно в новом графе искать
увеличивающий путь. И дальше, по доказанному утверждению, если наличие увеличивающей пути в
исходном равносильно наличию увеличивающей пути в получившем ж-штрихе. Значит, я сжал соцветия,
попытался найти здесь увеличивающий путь, если нашел, отлично, сделал чередование с помощью вот
этих всех трюков, то есть что я должен уметь разжимать соцветия. Ну и соответственно увеличил
в исходном графе. Если в новом не нашлось, то и в старом не было. Значит, можно опять же завершиться.
Ну всё, более-менее такой алгоритм.
Вот, про время давай что-нибудь скажу немножко.
Значит, в наивной реализации это будет работать за
n2m, где n как обычно число вершин, m число ребер. Ну почему? Потому что, как работает у меня алгоритм
примерно, что я примерно n итераций, не больше n раз, пытаясь найти увеличивающий путь.
Ну понятно, что в увеличивающих пути у меня столько каков размер просочетания, значит,
это не больше n пополам даже, но не важно. Значит, n раз я ищу увеличивающий путь. Внутри процедуры
поиска увеличивающего пути у меня в худшем случае мне нужно будет много раз сжать соцветия.
Вот я один раз построил эти деревья, нашёл ребро между синими, сжал. Ещё раз всё это заново
запускаю, опять нашёл ребро между синими, сжал. И так далее понятно, что сжатие будет опять
максимум n раз, потому что у меня уменьшается число вершин, значит, максимум n сжатий.
Значит, внутри вот этого вот, внутри попытки найти увеличивающий путь у меня будет не больше,
чем n сжатий. Ну понятно, каждая из которых, каждая итерация, каждая попытка сжатия,
это по сути просто DFS, построение деревьев моих. И потом, когда я нахожу ребро между синими,
я сжимаю ещё какой-то линейный проход. То есть, каждая из которых, каждая из которых,
это по сути просто DFS. Ну давайте я буду сейчас за от m, как обычно,
предполагаю, что m больше, чем n у меня. Потому что иначе можно разбить графные
компоненты связанности, в каждой решать отдельно, а в пустых графах ничего не делать.
Ну вот асимптотика как раз. То есть, я n раз нахожу путь, чтобы найти путь,
мне нужно сделать n сжатий, каждая из которых занимает линейное время.
Да, конечно, конечно. Вот если я после нескольких сжатий нашёл какой-то путь,
то мне нужно рекурсивно всё это развернуть, всё это разжать. То есть у меня, по факту, кстати,
у меня после многочисленных сжатий внутри одной вершинки могут быть и вершинки, и мега вершинки,
каждая из которых, само ещё рекурсивно является сжатий, соцветиям. То есть вот это всё соцветия,
каждая из которых, возможно, тоже внутренней соцветиям. Вот вам надо всё это рекурсивно разжать.
Ну у меня есть процедура однократного разжатия, вот по утверждению. Он может, соответственно,
многократно разжать до исходного графа. Вот. Будем крадем. Ну вот утверждается,
что если повозиться, то можно сделать просто за НМ. Так же, как в Куне.
Давайте поумнее реализация будет за НМ. Вот. Поумнее реализация следующая. Смотрите,
давайте ещё раз в наивной подчеркну. Здесь я делаю следующее. Если я внезапно нашёл соцветия,
то я его сжимаю и заново всё, я забываю про цвета, я забываю про те деревья, которые я строил. Всё,
у меня новый граф же штрих, я в нём работаю с нуля. Это вот наивная реализация. То есть я сжал,
и всё, забыл про то, что это вообще какое-то соцветие, я решаю задачу на новом графе.
Можно сделать поумнее, и можно не забывать, что это на самом деле, как оно было получено,
и просто сказать, окей, значит, вот это вот, это на самом деле теперь одна большая мегавершина,
которая сжимается в одну большую синюю вершинку, и дальше можно продолжать, как бы вот,
in place, искать здесь, ну короче, строить деревья дальше. То есть теперь я просто считаю, окей,
вот это дерево у меня подсократилось, поджалось, я считаю это всё одной большой синей вершинкой,
и продолжаю строить деревья. Ну а там я нахожу какие-то ребра, крашу что-то в красный, нахожу
увеличивающие пути и так далее. Вот, ну вот если это аккуратно реализовать, аккуратно
реализовать такое сжатие как бы внутри процедуры построения дерева, то будет что-то такое. Ну вот,
ну то есть как бы давайте что-нибудь напишем. После одного сжатия можно продолжить процедуру
построения дерева. Идём дальше. Ну то есть что такое идём дальше? Что вообще, как работает наш
алгоритм построения дерева? Он видит синюю вершинку, рассматривает все исходящие из неё
ребра. Если внезапно нашлось ребро в ненасыщенную, то пообеда мы нашли увеличивающий путь. Ну,
значит мы можем разжать эту штуку по дороге. Если он нашёл ребро в какую-то насыщенную,
то значит мы её красим в красный, и у меня появляется новое ребро, у меня дерево расширяется.
Ну и вот так вот делаю, пока весь граф не обойду. Всё, значит поэтому у меня по-прежнему также будет
максимум n раз. То есть я по-прежнему у меня внешний цикл такой же, что я n раз ищу увеличивающий
путь. Но внутри я не запускаю рекурсивно каждый раз новый DFS построения дерева после каждого
сжатия, а по сути это всё один большой сплошной DFS, внутри которого происходит сжатие соцветий.
То есть код такой. Не больше n раз найти увеличивающий путь. Внутри просто DFS,
ну как бы параллельно, да, вместе со сжатиями. Ну и как раз это будет nm. Если это всё аккуратненько
хорошо рисовать, надо ещё подумать над тем, как именно мы делаем сжатие, потому что, ну как будто
бы у меня вершинки объединяются в одну компоненту, да, и мне нужно как-то вот там
ребра ещё объединить. Ну короче надо повозиться, но вот можно это реализовать так, чтобы работал
nm. Вот. Ну чё вроде всё. Ох, вопрос. Ну кажется память на самом деле не растёт. Окей, давайте
попробуем что-нибудь сказать. Значит на самом деле можно реализовать алгоритм примерно следующим
образом. Значит можно сделать, то есть смотрите, я не буду пользоваться там nm никаким. Я просто скажу
примерно так. Вот когда я сжимаю вершинки, я их все, то есть я теперь скажу, что они все соответствуют
вот этой вот базе. То есть у меня есть база, база моего соцветия. И я у них, у всех как бы перенаправлю
указатель вот сюда. То есть на самом деле, что все они, по сути я всё это сжал вот в эту точку. Вот так
я сюда всё это сжал. Теперь они все указывают вот на эту вот базу. И дальше, если я в какой-то
момент времени хочу как бы посмотреть на список ребер, исходящих из вот этой вот мега вершинки,
то я на самом деле просто могу просмотреть вообще все вершинки, входящие вот сюда вот,
и независимо рассмотреть все списки смежности. То есть я не делаю склейку вот этих вот, ну то есть
еще раз, у меня у каждой вершины есть исходящие ребра, но я не делаю их склейку там ни через мерч,
ни через какой-нибудь СНМ. Я просто поддерживаю, что у меня здесь есть много вершин, и чтобы
рассмотреть все исходящие ребра, я в тупую прохожу сначала соседи этой, потом этой, потом этой,
потом этой. То есть у меня ребра не дублируются на самом деле. Не, СНМ был бы. Как работает СНМ?
СНМ скорее, что я создаю новую мега, буквально новую какую-то структуру, которая хранит все вот
это вот вместе со всеми исходящими ребрами. То есть как раз вот СНМ, это как если бы я создал
нечто новое, туда все свалил, скопировал, и у меня бы как раз память начала бы расти. А тут я так
не делаю. Я говорю, что наоборот, как бы у меня все сжалось в одну точку, и при ее рассмотрении,
при рассмотрении ребер инцидентных ей, я рассматриваю все вот эти вот и просто пробегаюсь
по их спискам смежности, по тем, которые в самом начале у меня в исходном графе есть. То есть я не
завожу новых списков, я буквально их не мерзжу, я их не склеиваю в один. Их было 5, вот они 5 будут.
Да, да, да, да.
Да.
Так же. Ну типа...
То есть у вас теперь как бы вот, у вас каждая вершина исходного графа теперь соответствует
какому-то соцветию в новом графе. Ну то есть о соцвете номируется номером базы, вершинкой
базы. То есть теперь каждая вершина графа исходного соответствует некой базе. У вас есть по факту
отображение из вершины исходного графа в базы нового графа. Ну не, мы не проверяем наличие
ребра, мы по факту рассматриваем список соседей. Построение дерева по сути ДФС, я рассматриваю
просто все исходящие ребра. Чтобы просмотреть все исходящие ребра, я рассматриваю все исходящие
ребра для каждой из вершин, составляющих эту базу, которые наверное можно получить просто
просто пройдя вообще по всем вершинам графа и проверить те из них, которые вот на эту базу
ссылаются. Ну это надо подумать. Типа вектор тех, которые вот в ней лежат. Ну возможно можно так.
Я просто видел реализацию, где вообще никаких новых структур не заводится, вот буквально
просто все. Ну да, там что-то вылезет явно. Ну как-то так. Я тут в детали примерно такая идея,
что никаких новых структур не используется, что как бы каждая вершинка ссылается просто на новую
базу. А дальше уже надо думать. Так, ну наверное это все. Вопросы какие-нибудь может быть?
Тогда спасибо за внимание. Всем удачи на зачетенном экзамене. Всем пока.
