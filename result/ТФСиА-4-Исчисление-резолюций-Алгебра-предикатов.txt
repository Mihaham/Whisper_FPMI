Давайте начнем, наверное, по моим часам уже пора.
Я напомню, что в прошлый раз я начал рассказывать
о другой системе доказательств, основанной не на исчислении,
высказывание, основанной на правильной резолюции.
Я напомню, что такое правильная резолюция, это когда у нас
есть две формулы, А дизюнция В и не А дизюнция С, мы можем
вывести формулу В дизюнция С, но то, что это корректно,
что если верхние две формулы истины, то нижние истины
легко проверить, я в прошлый раз проверял, и я уже в прошлый
раз сказал, что мы будем применять правила резолюции
только для дизюнцев, то есть для дизюнций литералов
переменных или их отрицаний, то есть фактически будем
проверять для КНФ, причем для КНФ мы будем проверять
невыполнимость, то есть мы будем доказывать автологичность
ДНФ, а как в случае общих формул сводить к этому
частному, ну в прошлый раз я объяснил сводимость.
По любой булевой формуле я объяснил, как построить
КНФ, выполнимость которой равносильна выполнимости
исходной формулы, и построение достаточно эффективно.
Для системы доказательств нам существенно, чтобы действия,
которые мы выполняем были эффективны, занимали полимериальное
общий длины входа-время, длины формулы и длины доказательства,
но это я повторять не буду, это сводимость вам еще
понадобится в следующем семестре в курсе по вычислительной
сложности, поэтому вы с ней еще раз столкнетесь,
но в ней вроде бы ничего особо сложного нет.
Сегодня я хочу рассказать вторую часть этой системы
доказательств, собственно некоторое формальное
исчисление, которое я буду называть исчислительной
дизолюцией.
Оно устроено совершенно не так, как исчисление вы
сказали, например у нас не будет ни одной аксиумы
в этом исчислении, а что будет, будут дизюнкты, причем
не произвольные, а некоторые стандартные дизюнкты.
Что такое стандартные дизюнкты?
Давайте я сразу напишу очевидные эквивалентности,
если у вас есть дизюнкты х и не х, то это обязательно
единица, если есть дизюнкты х и не х, то это равносильно
х, поэтому если у вас есть дизюнкты, то есть дизюнкты
переменных и их отрицаний, каких-то переменных, какие-то
переменные могут быть позитивны, какие-то негативны, то что
мы можем легко сделать с этим дизюнктом, мы, во-первых,
можем проверить, что нет вот таких вот пар противоположных
литералов, потому что если они есть, этот дизюнкт
х и не х и не единица, мы его можем из рассмотрения
выбросить, и никакой литерал не повторяется, потому
что не только х или х равносильно х, но и не х или не х равносильно
не х, значит, если у нас какой-то литерал повторяется,
то мы можем выбросить повторение, оставить только одно вхождение.
Другими словами, стандартный дизюнкт мы можем рассматривать,
вспомним еще, что дизюнкты коммутативно и ассоциативно,
неважно в каком порядке в дизюнке записаны литералы,
и вот стандартный дизюнкт нам удобно так будет считать,
это множество литералов, не содержащие противоположных
литералов. Ну вот как в этом примере. Множество
это уже самокупность, то есть нам не важно в каком
они идут в порядке, мы просто будем рассматривать как
множество, хотя записывать я буду точно также с помощью
операции дизюнкт. И вот мы будем строить исчисления,
в котором будут использоваться стандартные дизюнкты,
это будут те формулы, которые мы используем, никаких
других формул у нас не будет. На стандартных дизюнктах
я определю операцию дизюнкт, определю я немножко необычным
способом, это настоящая дизюнкта, если она не содержит
противоположных литералов, ну а если вдруг возникают
повторения, мы их убираем. А в противном случае мы
будем считать, что операция не определена. То есть вот
смотрите, если я возьму дизюнцию двух таких литералов, ну
то есть дизюнция х или у или х или не у, то у меня получится
в результате, если я просто как множество объединю, у
меня получится такое множество х, у, не у. Ну вот мы считаем,
мы хотим ограничиться только стандартными дизюнтами,
результат перестает быть стандартным дизюнтом, поэтому
мы считаем, что операция в этом случае не определена,
а так удобнее. То есть у нас дизюнция на стандартных
дизюнках не всегда определена. Есть конечно специальный
дизюнт, вот я его так напишу, ложь это пустое множество
литералов. И теперь используя эту операцию и правила резолюции
я определю, что такое вывод в исчислении резолюции.
Я буду называть резолютивный вывод. Ну поскольку у нас
вообще нет аксиом, из чего-то выводить нам нужно, поэтому
мы считаем, что у нас есть некоторое множество дизюнтов
заранее заданное, и мы строим из него вывод. Вывод, это
как раз похоже на то, что у нас было раньше, это последовательность
дизюнтов. Вот это вот вывод. Если выполнены обоснования,
я напомню, что когда у нас было исчисление высказывания,
у нас вывод тоже был последовательность формул, и каждая формула
в выводе должна была быть обоснована. Обоснования
у нас теперь будут другими. Первое обоснование для
любого и одно из возможных обоснований, что этот
дизюнт просто входит в множество гамма. Это напоминает вывод
из епотез вычислений высказываний, то есть то, что у нас множество
гамма входит, мы вывод можем вставлять, этого достаточно
для обоснования этого дизюнта. А вот второй случай, он такой,
у нас наш дизюнт получается из каких-то предыдущих
правилам резолюции. Я сейчас формально напишу, что это
означает. Вот у нас есть какие-то индексы ж и к, строго
меньше, чем и. Дж т – это какой-то дизюнт х или дизюнт
с чем-то там д штрих ж т. Д к т – это наоборот не х или
какой-то дизюнт д штрих к т. А д и т, вот посмотрите
на эти два дизюнта, на правила резолюции, что мы с помощью
этих двух дизюнтов можем вывести в новую дизюнцию
этих вот хвостиков. То есть мы убираем переменную х,
которая входит противоположно в эти дизюнты и берем дизюнцию
всего, что осталось. При этом здесь я имею в виду, что
я применяю операцию на стандартных дизюнтах. То
есть это все стандартные дизюнты. Я дальше снова
стандартные буду все время пропускать, потому что
в этом исчислении у нас только стандартные дизюнты
используют. И в частности мы не можем вставлять не
стандартные дизюнты, там х или не х мы не вставляем.
Хуже бы от этого не было, но так удобнее для последующего
доказательства, удобнее сразу запретить такие вставки.
Это вывод. Значит мы пишем, что из множества гамма,
вот я напомню такая вертикальная черта, сопровождаемая горизонтальной
чертой, означает синтаксический вывод. Чтобы отличать от
вывода в исчислении высказывания я букву QR припишу. И вот
если из множества дизюнктов гамма мы можем вывести
пустой дизюнт, то это называется, такой вывод называется
опроверирование гамм. Ну почему так называется? А вот
почему. КНФ мы можем рассматривать тоже как множество дизюнктов,
потому что кайюнтся тоже коммутативно и ассоциативно,
не важно в каком порядке мы ставим дизюнкты. У нас
есть КНФ, мы можем взять множество входящих в нее
дизюнктов и начать делать вот такие резолютивные
выводы. И если у нас получилась ложь, я сейчас вам докажу,
это очень просто, это означает, что КНФ не выполнимо. И верное
и обратное, если КНФ не выполнимо, мы можем вывести
тождественноложные дизюнты с дизюнтом этой КНФ. То
есть у нас есть теоремы корректности и полноты.
Корректность означает, что если мы вывели пустой
дизюнт, то, ну я это запишу, вот использую значок семантического
следствия, потому что это коротко, а на словах расскажу,
что это множество невыполнимо, то есть у нас нет выполняющего
набора для гаммы. Какой бы набор переменных мы ни
взяли, хотя бы один из дизюнтов обращается в ноль. И тогда
только такие невыполнимые наборы, из них может семантически
следовать ложь, потому что если хотя бы на каком-то
наборе все дизюнты были бы истинны, мы пришли бы
противоречию с определением к тому, что этот дизюнт всегда
ложен на любом наборе. Ну а полнота это в обратную
сторону. Если наше множество дизюнтов не выполнимо, то
существует резолютивный вывод тождест наложенного
дизюнта, то есть можно опровернуть с помощью резолютивного
вывода это множество дизюнтов. Вот сейчас моя цель доказать
эти две теоремы. Первая, как обычно, проще намного.
Вторая чуть посложнее, но тоже не сказать, что очень
сложная. Давайте корректность. Удобно доказывать контрапозицию.
Я напомню, что если из А следует Б, равно сильно
тому, что из НЕ Б следует НЕ А. Это контрапозиция
называется. И я буду доказывать, что если наше множество
дизюнтов выполнимо, то есть на каком-то наборе значений
переменных все дизюнты обращаются в единицу, то
тогда из такого множества мы точно не сможем вывести
пустой дизюнт. Как это доказывать? Индукции по длине вывода.
Смотрите база. Если у нас в выводе всего один дизюнт,
то он не может получиться резолюцией, потому что резолюция
требует, чтобы было хотя бы два предшественника.
Значит первый дизюнт в выводе всегда принадлежит
гамма и значит на вот этом наборе, у нас по предположению
есть выполняющий набор, он равен единице. Теперь
я буду доказывать, что любой дизюнт в этом выводе, да
вот тут я это забыл написать где-нибудь, вот что я буду
доказывать по индукции, что любой дизюнт в этом
выводе не выполним. И этого достаточно, потому что понятно,
что это ждестоложный дизюнт не выполним ни на каком
наборе, значит он в выводе не встретится. Ну давайте
смотреть, что нам нужно осталось проверить. Перехват шах индукции.
Опять-таки если dkt принадлежит гамма, уже разобрались,
то пусть dkt получается правилом резолюции. И из каких-то ds dr с меньшими индексами.
По индуктивному предположению ds на выполняющем наборе
равен единице и dr на выполняющем наборе равен единице. Но
тогда мы проверяли корректность правила резолюции тогда
и то, что получается по правилам резолюции тоже будет равно
единице. Ну и все, значит все дизюнты, если у нас
есть выполняющий набор для множества дизюнтов гамма,
то все дизюнты, которые мы можем резолютивно вывести, они все на
этом наборе обращаются в единицу. Так что, как видите, теорема корректности совсем
простая. Теорема о полноте существенно проще, чем теорема о полноте для
исчисления высказываний, но она тоже, конечно, требует некоторых рассуждений.
Давайте я, ну про стандартные дизюнты я думаю это понятно, я это сотру.
Так я буду доказывать полноту. Причем я опять-таки буду доказывать контрапозицию,
что если из гамма не выводится пустой дизюнт, то тогда гамма выполним. Доказательство тоже
использует идею пополнения, как и в случае исчисления высказываний. Но там, если вы
помните, пополнение было таким достаточно хитроумным, здесь пополнение будет существенно проще.
Ну у нас вообще и аксиом нет, сама формальная система выглядит проще. В пополнение я включу
все дизюнты, которые можно вывести из этого множества. Тут самое время сказать, посмотрите
на формулировку. От множества дизюнтов я не требую, чтобы оно было конечным. Дальше,
во второй части курса, это мне будет очень существенно. Когда мы проверяем выполнимость
КНФ, у нас, конечно, мы все выводим из конечного множества дизюнтов. Но дальше мы будем использовать
исчисление резолюции в более сложной ситуации, у нас будет бесконечная множество дизюнтов. Так вот
то, что я сейчас рассказываю, на всякий случай держите в голове, если возникнут подозрения,
то обязательно переспросите. Множество гамма может быть бесконечным. Ничего не испортится
в моем рассуждении. Итак, это я буду называть пополнением. И по нашему предположению, если взять
контрапозицию, я знаю, что пустой дизюнт не принадлежит пополнению, его нельзя вывести. И вот
исходя из вот этого, мне нужно, исходя из этого условия, мне нужно построить выполняющий набор.
Здесь построение будет просто конструктивным. Я вам сейчас явно предъявлю правила, как этот
набор строить. Вот пусть мы уже присвоили значение первым К переменным. Первым К
минус одной давайте переменной.
Да, здесь мне удобно ввести еще одно понятие, еще одно обозначение.
Я хочу разбить вот это пополнение на множество.
В каждой дизюнт входит лишь конечное количество переменных. И вот в множество гамма К-та я включу
те дизъемки, куда входит только переменная с номерами х1, х2, хк. У нас множество переменных,
оно вообще говоря бесконечно, но оно счетно. Мы считаем, то есть оно занумеровано какими-то
натуральными числами. И поэтому возникает такое разбиение в соответствии с тем, какие перемены
входят. Если входит только первая К переменных, причем К-та обязательно входит, то это дизъюнт из
множества гамма К-та. Второе условие нужно для того, чтобы эти множества не пересекались. То есть у нас
всегда в каждом дизъюнте будет литерал с наибольшим индексом, переменная или отрицание с наибольшим
индексом. Вот в соответствующее множество этот дизъюнт будет входить. И вот теперь правило,
как определить значение альфа-катова. Альфа-ката это значение переменной хкатой на наборе альфа.
И мы его определяем так. Это ноль. Сейчас давайте я напишу, чтобы потом сказать словами, а то получится
плохо. Смотрите, мы пробуем все дизъюнты из гамма К-това. То есть я сейчас присваиваю катой
переменной значения. Смотрю на все дизъюнты из гамма К-това. И смотрю, есть ли такой дизъюнт,
что вот всем предыдущим переменным значение уже присвоено. Теперь я катой переменной присваиваю
значение ноль. И смотрю, не случилось ли так, что какой-то из дизъюнтов обратился в ноль. Если не
случилось, я присваиваю альфа-катой ноль. А если случилось, то тогда присваиваю единицу. Причем
заметьте, что вот этот вот случай, он не обязательно означает, что у нас есть дизъюнты
в гамма-кате. Поэтому я тут так сложен и писал. Нет, дизъюнта. Если гамма-катая пустой, такой же
может быть, что нет дизъюнта, в котором максимальный индекс литерала именно ровно к. Почему нет? Такое,
в принципе, может случиться. Ну, тогда у нас все равно нет дизъюнта из этого множества, на котором,
который бы обращался в ноль, вот на таком наборе. И значит, мы смело присваиваем катой
переменной значения ноль. А в противном случае, если такой дизъюнт нашелся, мы присваиваем единицу.
То есть, как видите, очень простой процесс.
Простое правило. То есть, мы присваиваем ноль, если мы не видим, что какой-то из дизъюнтов уже
обратился в ноль. Тогда плохо. Я напомню, что мы хотим построить выполняющий набор. Если бы я вот
в такой ситуации присвоил бы катой переменной значения ноль, соответствующий набор значений
переменных уже не был бы выполняющим. Вот он дизъюнт, который обратился в ноль. То есть, мы
присваиваем единицу только в том случае, когда мы явно видим проблему, что вот если присвоить ноль,
то плохо. Конечно, правило однозначно. Он задает набор значений переменных. Но будет ли этот
набор выполняющим, пока не ясно. Почему? Потому что может же так случиться, что какой-то другой
дизъюнт обращается в ноль, когда значение этой переменной равно единице. Это мы пока не проверяли.
И вот нам нужно убедиться. Значит, альфа-выполняющий набор я хочу доказать. И доказывать я это буду по
шагам индукции по вот этому k. То есть, я буду доказывать, что каждый дизъюнт из каждого множества
гаммакаты на этом наборе выполнимый. Заметьте, что у нас пустой дизъюнт не входит, поэтому объединение
гаммакатых, начиная с единицы, она просто совпадает со всем пополнением. То есть, если я докажу вот это
утверждение, то это и будет означать, что все пополнение выполнимо на этом наборе. А пополнение,
конечно, содержит все дизъюнты исходного множества. Потому что один из возможных
резолютивных выводов это просто написать дизъюнт из исходного множества. То есть, гамма-штрих заведомо
содержит гамму. Вот план доказательства. Теперь надо проверить, что все-таки построенный набор выполняющий.
Ну, сейчас сделаем. Опять-таки база. У нас есть ровно два дизъюнта, которые могут входить в множество
гамма-1. Это переменная х1 или отрицание переменной х1. Оба этих литерала входить не могут. Почему? Потому
что иначе по правилу резолюции мы могли вывести пустой дизъюнт. Я напомню, что к таким дизъюнтам вполне
себе можно применить правила резолюции. И получается как раз пустой дизъюнт. А мы знаем, что пустой дизъюнт
вывести нельзя. Значит, у нас входит либо один, либо другой. Давайте рассмотрим два случая. Пусть
входит х1. И это тогда в точности гамма-1. Может вообще ничего не входить, но тогда вообще проблем
нет. У нас все дизъюнты выполнимы, поскольку ни одного нет. Значит, если входит х1, давайте смотреть.
Это правило применимое при к равном единице. Просто вот присвоенных значений пока ни одного
нет. Значит, есть ли у нас дизъюнт, который в нуле обращается в ноль? Есть. Это х1. Значит, по нашему
построению в таком случае альфа-1 равен единице. Ну и на таком наборе значений переменных, понятное
дело, дизъюнт х1 выполним. А если отрицание входит в гамма-1, то тогда смотрите, нет дизъюнта,
который бы в нуле обращался бы в ноль, потому что отрицание обращается в единицу. Значит,
альфа-1 равно нулю. И опять-таки вот этот дизъюнт выполним. Вот база разбор двух случаев. Теперь шаг.
Значит, мы предполагаем, что мы уже доказали, что дизъюнт из множества гамма житом на наборе
альфа обращается в единицу при всех же меньших k. Теперь мы рассматриваем дизъюнт из множества
гамма k. Давайте рассуждать от противного. Пусть он обращается в ноль. Что мы можем сказать про
этот дизъюнт? Я утверждаю тогда, что альфа-катая обязательно равно единице. Посмотрите на правило.
Альфа-катая равно нулю только в том случае, когда все такие дизъюнты не обращаются в ноль на
таком наборе. Значит, альфа-катая равно единице. А при этом, да, и переменная х-катая входит в этот
дизъюнт. Как она может входить? Только позитивно. И это вот какие-то в дизъюнт д-штрих входят какие-то
переменные с меньшими номерами. Потому что, если входило отрицание х-катого, то этот дизъюнт
обращался бы в единицу. Сейчас, или я перепутал. Перепутал. Должен ходить негативно, потому что на
единицу он должен обращаться в ноль. Значит, если я подставляю вместо х-катого единицу и стояла бы
позитивно эта переменная, то тогда это уже была бы единица. Нет, нам нужно именно, чтобы он входил
негативно, то есть входило отрицание этой переменной. Это вот то, что мы из нашего предположения,
что есть какой-то дизъюнт, который обращается в ноль. Но теперь давайте извлечем информацию вот
отсюда. Посмотрим на наши правила. Раз мы присвоили единицу, значит, у нас должен быть какой-то
другой дизъюнт D1, который обращается в ноль вот на таком наборе. Что это означает? Это означает,
что D1, вот в D1 как раз х-катая должна входить позитивно. То есть сама переменная не ее отрицание,
потому что если я подставляю вместо х-катого ноль, этот дизъюнт должен обратиться в ноль. И в
частности, кстати, вот эти вот хвостики один и другой тоже должны обращаться в ноль. Это же у
нас дизъюнт С. Раз D от α равно нулю и D это дизъюнт С2 формул, то каждая должна обращаться в ноль.
То же самое здесь. И D' это два штриха уже принадлежат меньшим множествам. То есть D' принадлежит
ну какому-то гамма и тому и меньше k. D' принадлежит какому-то гамма ж тому и меньше k. Потому что мы
выделили х-каты это максимальный к это максимальный индекс переменной, которая входит в дизъюнт D. Все
остальные имеют меньшее номера. И мы знаем, что они еще обращаются в ноль. Ну теперь смотрите. Вот у
нас есть такой дизъюнт. Есть такой дизъюнт. Поскольку мы говорим о множестве гамма kt, это множество
пополнения. То есть оба эти дизъюнта можно вывести резолюциями из исходного множества гамма. Но я
утверждаю, что тогда, смотрите, тут х-каты или D' а тут не х-каты или D'. Но применим правило
резолюции. Значит получаем, что вот такой дизъюнт, ну он принадлежит какому-то, он тоже принадлежит
множеству гамма, пополнению. Потому что он получается из имеющихся дизъюнтов применением
резолюции. В пополнении мы включаем все, что можно вывести. Мы могли бы добавить этот шаг в вывод.
Ну и теперь смотрите, этот дизъюнт обращается в ноль. И второй дизъюнт обращается в ноль. Ну
значит их дизъюнт обращается в ноль. А мы предположили, вот смотрите, у нас есть индуктивное
предположение, что все дизъюнты, которые попали множество с меньшими номерами, обращаются в единицу.
Пришли к противоречию. Рассуждение всем хорошо, но есть в нем один недостаток. Может быть кто-то уже
видит. Ну тут может быть это трудно заметить, я тщательно это замаскировал. Когда я так лихо
применяю правила резолюции, у меня же на стандартных дизъюнтах резолюция определения
всегда вдруг правила резолюции применяют только тогда, когда то, что получилось является стандартным
дизъюнтом. Вдруг так не получится. На самом деле в этом рассуждении уже скрытое объяснение,
почему такого в нашем случае не будет. Ведь смотрите, если бы D' это два штриха включали
в себя пару противоположных литералов, скажем Y и не Y. В дизъюнтце входило бы Y или не Y и такой
дизъюнт был тождественно равен единице. Но мы знаем, что и этот дизъюнт ноль, и этот дизъюнт ноль,
значит дизъюнция двух нулевых дизъюнтов тоже ноль, поэтому такого быть не может. Значит правила
резолюции в данном случае применяют. Ну вот и все. Полнота тоже доказана. То есть как видите,
здесь доказательства проще. Идея очень похожа. Вот почему я хотел рассказать именно то доказательство
для исчисления высказаний. Идея пополнения, она очень важна. Это такая путеводная идея для
доказательства полноты в логике. Здесь это все гораздо проще во многом за счет того, что мы
можем вот так вот достаточно просто построить выполняющий набор. Нам, помните, для исчисления
высказаний нужна была лемма кальмара, какие-то там строить выводы, то есть там было такое очень
неявное построение. А здесь буквально мы просто смотрим, то есть все очень конструктивно. Мы
смотрим на дизъюнты, которые у нас есть. Причем, заметьте, это для будущего будет полезно. В каждое
множество гамма вкатая входит лишь конечное множество дизъюнтов. Потому что стандартных
дизъюнтов на N переменных, их не очень много. Какие у нас варианты для каждой переменной? Ну три. Входят
позитивно, входят негативно или вообще не входят. Значит всего стандартных дизъюнтов на N
переменных 3 в степени N. То есть когда я делаю такое построение, я на каждом шаге этого построения
работаю только с конечным множеством. Все конструктивно. Даже если все множество бесконечно,
каждый шаг, тем не менее до каждого шага с номером K я дойти могу за конечное время. Это будет
существенно дальше. Ну и вот все, значит эти теоремы доказаны. Давайте теперь соберемся вместе,
то что я говорил в прошлый раз. Это исчисление резолюции. Я напомню, значит у нас появляется
такая система доказательств тавтологии. То есть я напомню, что это значит. У нас есть какой-то
алгоритм, который получает на вход формулу. То есть он получает два текста. Формула и
доказательства. Доказательства в кавычках, потому что это может быть все что угодно. Важно что этот
алгоритм работает эффективно, то есть за полимониальное время от длины записи формулы и доказательства.
И он дает единицу в том случае, если это действительно доказательство для формулы. То есть
что это означает? Что если формула тавтология, какое-то доказательство это подтверждает. Может
быть ни одно. Я напомню это важное понятие. Если у нас формула тавтология, то мы можем
подобрать подходящее доказательство. Если ФИ не тавтология, то какое бы доказательство мы не
совали в систему доказательств, система доказательств его отвергнет. Будет говорить,
что нет. Доказательство неправильное. Где-то там есть ошибка. То есть наш алгоритм проверяет,
что П является доказательством тавтологичности формулы ФИ. И вот какую же систему доказательств
мы построили? Берем формулу. Первым делом мы ее заменяем на отрицание. Затем, посмотрите на
левую доску. Применяем сводимость, строим КНФ. А затем мы должны построить резолютивный вывод
лжи из этой КНФ. То есть мы должны... У нас П, доказательство, будет содержать себе такую вещь.
Ну мы можем записать туда вот эту вот КНФ и резолютивный вывод. И теперь что нам нужно? Что
наш алгоритм должен сделать? Он должен проверить, что вот эта запись корректно соответствует
формуле. То есть что алгоритму несложно приписать к формуле отрицания. После этого он должен
проделать те шаги, которые я в прошлый раз описал. То есть сделать разбор формул отрицания ФИ,
ввести дополнительные переменные, построить эту КНФ, которая там у меня была построена, и проверить,
что в доказательстве записана именно она. После этого остальная часть доказательств это резолютивный
вывод. Ну и алгоритм должен проверять, что каждый следующий шаг в этой выводе обоснован. То есть
что либо мы видим в соответствующем, в этой КНФ видим соответствующий дизюнт, если нет,
то нужно из предыдущих дизюнтов получить данные с помощью резолюции. Понятно, что это проверяется
эффективно. Вы просто перебираете все пары, возможно, и смотрите, получается ли данный дизюнт.
Из этого применением резолюция. Правило-то очень простое. Таким образом у нас получается система
доказательств. Так, ну давайте продолжим. Значит, итак, у нас появились две системы
доказательств тавтологии. И, как всегда, в таких случаях хочется их сравнить. Какая лучше? Ну,
в каком смысле лучше? Они обе адекватные, они обе доказывают тавтологичность. Лучше в том смысле,
в каких доказательствах короче? Я напомню, что нас, естественно, больше интересуют случаи,
когда есть короткие доказательства. Если все доказательства очень длинные, это не очень
интересно. И тут ответ на этот вопрос, какая лучше, он очень неожиданный. В теории исчисление
высказываний лучше исчисления резолюции. Что это означает? Это означает две вещи. Что если у вас
есть короткое доказательство резолюциями, то есть и короткий вывод в исчисление высказываний.
В эту сторону довольно легко, и я даже сформулирую это в виде очередной бонусной задачи.
Это, я думаю, все-таки посильно, хотя и не очень просто. Значит, и так пусть у нас есть КНФ.
В ней К дизюнктов, N переменных. И существует дизюнктивное, дизюнктивное
опровержение этой КНФ, в котором L дизюнктив. Ну, это основные параметры, от которых зависит
доказательство в системе доказательства, основанной на резолюциях. Нам нужно записать
КНФ, нам нужно записать резолютивный вывод. Тогда утверждаю я, уже в исчислении высказываний мы
можем доказать отрицание этой КНФ. Ну, раз существует вывод теждеасположенного дизюнка,
КНФ невыполнимо. Значит, отрицание КНФ – это автология. Так вот, мы можем доказать отрицание
этой КНФ в исчислении высказываний. И длина вывода не очень большая. Она оценивается,
как О, плюс число дизюнков, плюс число переменных, умноженное на длину резолютивного вывода. Длина
вывода – это количество формул, я напоминаю. Это важно. Потому что, если считать количество
символов, то есть длину текста, который у нас там доказательствует, получится немножко другие
оценки. Я считаю именно число формул вывода. Ну, О, я думаю, вы знаете, что значит с точностью до
константа. Так что, видите, если у нас есть короткое опровержение резолюциями, мы в исчислении
высказываний его можем смоделировать. В обратную сторону неверно существует КНФ. Такая, что есть
вывод отрицания этой КНФ, размера там, полиномат, размера записи КНФ, в общем, я не буду уточнять.
И она, конечно, поскольку она невыполнима, то у нас существует возможность вывести пустой дизюн. Но любой вывод
содержит что-то там экспоненциально большое от длины записи КНФ. Ну, экспоненциально большое,
это имеется ввиду тоже, на самом деле, тут квадратный корень можно поставить, в общем,
какая-то степень от размера КНФ. Но раздувание получается экспоненциальным, то есть доказательство
вычисления высказываний достаточно короткое, а любое опровержение отрицания в резолюциях
достаточно длинное. То есть, в теоретической точке зрения все понятно. Исчисление высказываний лучше.
Вообще, исчисление высказываний это очень сильная система, она лучше почти всех систем, которые
изучаются в сложности доказательств. Ну, на самом деле, можно скомбинировать эти системы, как всегда,
если у нас есть несколько систем, мы их можем как-то скомбинировать и получить еще что-то более
мощное. И такие вещи проделываются и с исчислением высказываний, но, в общем, это достаточно сложно.
Тем не менее, и, в общем, оно настолько сложное, что мы вот не знаем результатов такого типа. Есть ли
вообще тавтологии, у которых любое доказательство вычисления высказываний имеет сверхпальномиальную
длину? До сих пор мы не можем исключить такого варианта, что для каждой тавтологии есть какое-то
короткое доказательство. Может быть, его очень трудно придумать, но оно есть. Люди, правда, в это не верят,
но это вот в следующем семестре вам будут объяснять про НП, про кое НП, почему не верится такое. Это сейчас
меня бы слишком далеко в сторону. Но вопрос открыт. Но это, я говорю, в теории. Теперь практика.
Исчисление резолюции гораздо лучше. Исчисление высказываний. Первое преимущество я уже в прошлый раз
называл. Если вы пытаетесь написать программу, которая доказывает тавтологичность формулы с
помощью исчисления высказываний, совершенно непонятно, с чего эта программа должна начинать. Какую
аксиому она должна первой написать, абсолютно не ясно. То есть можно, конечно, если вы готовы
согласиться на доказательства экспоненциальной длины, то есть стандартный способ для любой
тавтологии написать с помощью леммы кальмара, написать доказательства. Но не интересно,
он всегда будет очень длинным. А чего-то более разумного придумать не удаётся. А для исчисления
резолюции понятно, что нужно делать. Я, собственно, показал, вы берёте KNF, но даже если вам нужно
проделать все эти шаги, вы потом берёте KNF и начинаете применять резолюции. У вас есть конечное
множество дезюнктов. Каждый раз вы знаете, что всё, что вы можете сделать следующее, что добавить к
этому множеству. Если добавили, отлично, пытайтесь ещё добавить. В какой-то момент вы уже не можете
ничего добавить. Если пустого дезюнкта не появилось, теорема о полноте гарантирует,
что KNF выполним. То есть, в общем-то, понятно, как писать такую программу. Но, на самом деле,
исчисление резолюции даёт даже больше. Я всё-таки потрачу пять минут, это интересный сюжет,
про него хочется сказать. Оказывается, сейчас существуют программы, они называются SAT-солверы.
Ну, вот эта вот задача проверки выполнимости, она SAT называется. Так вот, существует очень
эффективная SAT-солвера. Настолько эффективная, что в последние годы, даже в научных статьях,
можно увидеть такое рассуждение. Ну вот, нам надо какую-то трудную комбинаторную задачу решить,
не понятно, как это делать, а давайте мы её сведём к SAT и запустим какой-нибудь SAT-солвер хороший.
Хотя, теоретически, все эти солверы должны работать плохо, теоретически, на каких-то входах. А если
вы берёте реальные входы, они все работают хорошо. И это вот действительно удивительная ситуация. То
есть, вот тут возникает разрыв. Там, где вот эта вот экспонента, тут стоит всё-таки корень квадратный
из размера. То есть, если посмотреть, чтобы достигнуть этой границы, ну вот ещё пока не хватает мощности
компьютеров. То есть, плохие примеры, они пока за тем горизонтом, который мы видим на практике. Ну,
SAT-солверы, конечно, применяются их очень большим формулом, там, длиной в миллионы символов, но это
формулы, возникающие из индустрии, и там эти формулы, они не произволены, они имеют достаточно
специальный вид, ну там, скажем, описание какой-нибудь микросхемы. Понятно, что там очень много структуры есть
в этой формуле. Поэтому то, что для неё работает какой-то SAT-солвер, это может быть даже не так удивительно.
Откуда взялись такие хорошие SAT-солверы? Это тоже очень интересная история. В теории же их быть не
должно. А на практике они есть. А взялись они вот откуда. Уже больше 20 лет проводятся чемпионаты.
По-моему, они называются SAT-competition. Я боюсь ошибиться, но думаю, что если вы поищете вот по такой ссылке
в Google, вы найдете сайт, на котором собираются результаты. То есть люди стали соревноваться, стали писать
программы, которые проверяют выполнение. Все знали, что задача трудная, поэтому это интересно. У кого-то
получается лучше, у кого-то хуже. Понятно, что программы пишутся на каком-то стандартном коде, там, не знаю,
как сейчас. Поначалу это был чистый C, и этот чистый C запускался, ну, на некотором тестовом компьютере, то
есть все программы запускались на одном и том же железе, чтобы можно было сравнивать время. Ну и устраивались
соревнования, как обычно, как в легкой атлетике. Есть много видов бега. Тут тоже очень много видов.
На случайный КНФ, на три КНФ, где не больше трех литералов, на КНФ, которая там дерется из каких-то вот из этих
теоретических вот оценок. Ну и понятно, что дальше. Дальше люди пытаются победить. Соревнуются не программы,
соревнуются люди, которые пишут программы. И это очень мощный стимул. За 20 лет люди насобачились писать эти
программы очень эффективно, потому что каждый хотел победить, и каждый вот что-то такое придумал,
вкладывал. Это оказалось намного эффективнее любых заказов от индустрии, от военно-промышленного комплекса,
от чего угодно. То есть вот игра это очень мощный двигатель прогресса. Так вот, что я хотел сказать,
почему этот разговор сейчас затеял? Дело в том, что в основе практически всех соц.олверов, конечно,
чемпионские соц.олверы сейчас устроены очень сложно. Они обрабатывают там какие-то специальные
случаи. То есть они проверяют, что, допустим, КНФ имеет какую-то специальную структуру. Тогда запускают
какую-то отдельную листику. То есть это гигантские программы. Они уже имеют коммерческую ценность,
поэтому они не открыты. Сейчас, по-моему, чемпионские программы типа 14-15 года открыты. Они считаются
уже старьём и их открывают. Ну, и они очень хороши. У меня был студент, который использовал
такие программы как раз для решения совсем другой задачи. Ну, вот он взял эту программу
чемпионскую 14-го года и ускорил свою программу в 600 раз, когда её применил. При том, что ему там
ну, там не очень сложная сводимость, но всё равно нужно было ещё программа должна была его задачу
превратить в SAT. Так вот, внутри всех этих программ, там, помимо всех наворотов, есть базовый такой
комплекс. Вот как в автомобиле может быть много всяких разных плюшек и фентифлёшек, но бензин
нужен. Вот бензином для всех SAT-солверов являются резолюции. Точнее, резолюции в комбинации с ещё
одной очень простой идеей. Вот какая идея. Идея такого частичного разбора переменных. Вот,
представьте, мы берём переменную X1. Она может равняться 0 или единице. Если я присвою значение 0,
у меня может упроститься моя КНФ. Ну, если в какой-то дизьюнт ходит отрицание переменной X1,
то он уже обращается в единицу. Дальше можно его не рассматривать. Если входит позитивно,
мы просто сокращаем этот дизьюнт. Мы можем выбросить переменную. В любом случае происходит
упрощение. И дальше мы можем вот так вот разбирать, разбирать, разбирать. Но не обязательно строить
полное дерево перебора. В какой-то момент мы окажемся в ситуации, когда вот по этим частичным
значениям мы можем определить дизьюнт, который обращается в ноль. Тогда дальше разбирать не нужно.
Если какой-то дизьюнт обратился в ноль от того, что вы ещё каким-то переменным присвоите значение,
он нулём быть не перестанет. То есть эта ветка уже, ну её нужно обрывать. Вот здесь есть какой-то
дизьюнт. Там X и вот тут вот X ветвимся. И D1. Поэтому мы можем сделать здесь рекурсивный
возврат и начать ветвиться по другому значению. И здесь тоже может так случиться, что произойдет
рекурсивный возврат. Где-то может быть глубже. Потом мы вот так вот рекурсивно продолжим до этого
уровня. У нас каждый раз, когда мы делаем рекурсивный возврат, мы знаем дизьюнт, который обращается в ноль.
А теперь смотрите. Это же ровно те дизьюнты, которым можно применить резолюцию. Мы можем вывести
новый дизьюнт. То есть мы дизьюнт, резолюцию применяем не просто так вот как-нибудь, а мы
смотрим, какие мы будем применять правила, глядя на этот частичный разбор. Чем это хорошо? У нас
получается такой взаимоподдерживающийся процесс. Чем больше дизьюнтов, тем больше условий, тем
быстрее будет обрываться вот этот частичный перебор. А когда он обрывается, мы увеличиваем
количество дизьюнтов. То есть получается такой самоподдерживающийся процесс. И он действительно
получается очень эффективный. Даже без дополнительных наворотов при разумных и вристиках, как строить,
как выбирать эти переменные. Мы же можем каждый раз выбирать, по какой переменной мы витвимся.
Но лучше, например, витвиться по той переменной, которая сильнее всего упрощает формулу, по тому
или иному функционалу. Если написать даже очень простые такие вристики, у вас получится программа,
которая не чемпионская, она будет очень хорошо работать. Гораздо лучше, чем можно было бы себе
представить на первый взгляд. Ну а дальше уже начинаются хитрости. Сейчас, конечно, люди используют
разные другие идеи. Линейная алгебра очень не тривиально используется. Но вот это используется
всегда. Потому что, да, а и вристики, которые строятся сейчас, вы знаете, эпоха нейронных сетей. А тут
безумное количество, это же вот все очень большое. То есть там еще проблема, что если это дерево
начинается, если достаточно большим, нужна и вристика, какую его часть держать в памяти, какую обрезать.
И на такие гигантские данные просятся напустить нейронные сети. Современные программы, они устроены
так. Вот они эти вристики по ветвлению определяют, ну вот как бы анализируя предыдущие ветвления. То есть
там запускают нейронную сеть, которая говорит, вот теперь надо бы ветвиться по такой переменной. Тут
уже вообще непонятно, как оценить, насколько эта вристика хороша. Но она работает, то есть они все
больше и больше решают задачи. То есть это вот такая интересная деятельность практического
плана. В общем, здесь есть некоторый разрыв, который до конца не закрыт. И это некоторая очень интересная
тема в теоретической информатике. То есть теорему никто не опровергнет. На самом деле, за лекцию я
бы вам ее доказал, просто у меня нет этой лишней лекции. То есть построить такую КМФ и доказать,
что все резолюции длинные, это не очень сложно. Там есть даже несколько идей. Сейчас эта техника
вообще очень развита. И для более сложных систем доказательств есть доказательства. Но проблема
в том, что это доказательства асимпатические. Они там на каких-то очень больших значениях что-то
дают. А вот на практике получается другое. Хорошо. На этом я, в интересном сюжете, но выходящем за
рамки этого курса, я закончу рассказ про булевые формулы, про тавтологичность. У меня еще сегодня
есть время и я начну рассказ про вторую часть курса. Сегодня будут разные предварительные
замечания. Что будет во второй части курса? Я напомню, я в самом начале про это говорил,
что логика вообще возникла как попытка обосновать математические доказательства. Вот тавтологи и
всего вот этого вот, там исчисление высказываний, исчисление резолюций, нам недостаточно, чтобы
формализовать даже математические утверждения. Это все-таки только частный случай математических
утверждений, относящихся к конечным множествам. Поэтому нам нужен какой-то более широкий
формализм. И оказалось, что такой формализм есть. Я про это говорил и, в общем-то, я буду
ему рассказывать, что называется логика первого порядка. И вот этого формализма уже достаточно,
чтобы по крайней мере сформулировать любое математическое утверждение и по крайней мере хоть
как-то описать, как устроены математические доказательства. Разумеется, те формальные
выводы, которые получаются в процессе, они не напоминают рассуждения настоящих математиков.
Они гораздо более дробные. Вот вы видели вычисления, высказывания. У нас очень мелкие шаги. То есть,
если вы проверяете тавтологичность какой-то формулы, вы можете себе позволить какие-то
более сложные рассуждения. А в формализме они разбиваются на очень мелкие шаги. Здесь то же
самое. И поэтому прям так записывать всю математику в формализме первого порядка это может быть не
самая разумная идея. Но если, скажем, вы хотите что-то доказывать с помощью программ, то есть
конкуренты, но они не доработаны. То есть, в сущности, это почти что единственный способ. Там другое дело,
что у этого формализма есть, как всегда, много вариантов. Но более-менее, так сказать, это базовый
способ как-то представлять математические знания так, чтобы можно было писать программы, которые
чего-то там доказывают, проверяют корректность каких-то доказательств. Поэтому это важная, в общем-то,
вещь. У нас же не все сводится только к проверке тавтологии формул. Бывают более сложные структуры.
И сегодня, вот за оставшееся время, у меня где-то 20 минут есть, а я начну вот с чего. Я начну с
некоторых предварительных замечаний. Значит, смотрите, у нас так же, как было с буливыми
формулами, как вообще всегда в логике, у нас есть две стороны. Синтакс и сомантика. То есть, вот
формализм какой-то, как мы пишем какие-то там слова, которым мы придаем смысл каких-то утверждений. И
семантика, о чем мы, собственно, говорим. Так вот, чтобы замахнуться на такую гигантскую цель, как
получить формализм, на котором всю математику можно выразить, он получается неминуумо сложный.
Ну, достаточно сложный. И я сегодня начну с того, чтобы скорее объяснять семантику, которая за этим
стоит. А вообще, почему всю математику можно так изложить, я оставлю на потом. Наконец, этой
второй части. Сейчас пока у нас будет конструкции, которые, на первый взгляд, может их и не хватить.
Как я буду брать эти конструкции? Давайте просто вспомним, как мы рассуждаем в математике, что нам
нужно, что нам не хватает вычислений и высказываний. Ну вот, вот два типичных математических утверждения.
Четыре меньше семи, четыре делитер семи. Вот то, что одно истинно, а другое ложно, это даже мне не
очень важно. Важно, что я не могу вот эти утверждения представить в виде высказываний. Это уже
элементарное высказывание. Ну, либо истинно, либо ложно. Но внутри, видите, есть структура. Это не
просто какое-то абстрактное высказывание, которое истинно или ложно, а это высказывание о каких-то
объектах. То есть, все математические утверждения, они о чем-то. И вот этого у нас в вычислении
высказываний совсем не было. А здесь это должно появиться. И проявляется это так. Это называется
отношение или предикаты. Логики любят слово предикаты. Математики любят слово отношения. Что
это такое? Вот как всю совокупность вот таких вот высказываний можно объединить? Можно рассмотреть
множество пар чисел таких, что их строго меньше. Тогда вот это вот утверждение с 4 меньше 7 просто
означает, что пара 4 и 7 принадлежит этому множеству. Мы делаем такой хитрый финт. Мы массу однотипных
утверждений объединяем в одно множество. Вот это множество называется отношение. Другим словом,
если у нас есть какое-то множество m, то k-r отношение. Это под множество декартового
произведения, декартовой степени k этого множества. То есть, это наборы из k элементов нашего множества.
Какое-то множество таких наборов. То есть, вот получается, что у нас есть вот такие базовые высказывания.
То есть, с каждым отношением или предикатом. Я дальше часто это буду называть предикатом,
поскольку мы про логику говорим. Как связаны вот такие вот утверждения конкретного типа. Возьмите
какие-то элементы из вашего множества и скажите утверждение, что эти элементы, этот набор,
порядочный набор k-элементов принадлежит данному множеству. То есть, еще логики говорят, выполняется
на этом наборе, выполняется предикат. Вот я определил предикат для отношения меньше. Ясно,
что аналогично можно определить предикат вот здесь. Сразу могу сказать, как это будет у нас
устроено синтоксически. Видите, здесь мы используем в математике всякие хитрые записи. Вот, в частности,
очень часто для бинарных отношений принята инфиксная запись, когда знак отношения стоит
между аргументами. Вот так получаются более читаемые формулы, но нам хочется иметь общий
формализм. И в общем формализме мы будем это записывать вот так. То есть, у нас будет имя отношения,
какой-то символ. И дальше в квадратных скобках мы перечисляем переменные. Вот это вот будут
переменные. Это будут предикатные символы, а это будет переменная. И вот такого рода запись будет
означать вот это вот утверждение. Она уже будет истиной или ложной. И дальше с этими утверждениями
можем применять булевую логику. А булева логика, заметьте, хорошо согласуется с теоретико-множественными
операциями. Вот я определил отношения как под множество, но тогда если я применю, скажем,
к двум отношениям объединения, это то же самое, что взять дизьюнцию этих отношений. Единственное,
что смотрите, вот эти отношения могут определяться быть разной арности. Например, я могу взять
дизьюнцию отношений а меньше b и а простое. Или а простое. Тогда у меня получится какое-то
странное отношение, но какая у него будет арность? Арность будет 2. То есть, смотрите,
если я беру а меньше b или а простое. Вот это бинарное отношение, это унарное отношение. Тут
для одного числа оно определено. Если я возьму такую дизьюнцию, как это в виде теоретико-множественной
операции представить? Ну надо представить, что здесь у нас есть несущественная переменная b,
от которой не зависит вообще значение этого высказывания. Ну и взять тогда уже просто объединение.
И понятно, что не только дизьюнцию, можно и конъюнцию применить, и отрицание, это получится
дополнение к этому множеству. И импликацию. В общем, мы можем применять булевые связки из
каких-то заданных отношений, ну скажем, там меньше, делимость, еще что-то. Можем строить
новые отношения, записывая их в виде булевых форм. Это напоминает то, что мы делали раньше,
потому что у нас теперь вместо булевых переменных, которые были раньше, будут вот такого рода объекты.
То есть в каком-то смысле мы так расщепляем булевые переменные, как расщепляют атомы. У нас
возникает там структура. Вот ядро, предикатные символы, вот эти вот переменные. В общем, у нас
возникает внутренняя структура. То есть помимо высказывания, которые имеют значение истина и
ложь, у нас появляются части в нашем формализме, которые отвечают уже не за истину или ложь, а за
какую-то содержательную часть. Это элемент какого-то множества. Какого? А это вот мы должны указать,
чтобы придать смысл такому выражению, мы должны объяснить на каком множестве это отношение задан.
Если мы изменим это множество, та же самая формула будет нам задавать что-то совершенно другое.
Это самый важный этап при построении формализма, но его недостаточно. Точнее,
как? Им можно обойтись, но очень неудобно. Давайте вспомним, что нам хотелось, а нет,
только им точно нельзя обойтись, но чего нам не хватает с точки зрения вот обычной математики.
Но уже даже в этих примерах видно, я же использовал тут не переменные, а именно конкретность 4, 7,
это константы. А есть еще функции. Вот допустим, я хочу сформулировать такое утверждение,
x квадрат плюс один равно нулю. Ну как это сделать? x это какая-то переменная, то есть вообще это вот
то, что здесь написано, это какое-то утверждение в зависимости от значения x оно истинно или
ложно. То есть так хочется верить, что это получается унарный предикат, зависящий от одной переменной,
но как его задать? Тут у меня есть единица, ноль, квадрат. Вот в том, что я до сих пор делал,
ничего этого нет, а хочется это иметь. Поэтому у нас еще будут функции. Функции это очень похоже на
отношения, но только у нас значение функции лежит в том же самомножии. То есть это фибрическая
операция, как еще любят говорить в математике. То есть у нас есть для каждого набора упорядоченного
k элемента множь, то мы задаем значение функции. В случае предиката мы задаем булево значение,
то есть на предикат можно еще смотреть как на функцию со значениями в 0,1. То есть мы берем опять
такие наборы элементов нашего множества и сопоставляем каждому 0 или 1, находятся они в
этом отношении или нет. Ну а в общем случае мы строим функции в то же самое множество. Вы конечно
скажете, что не обязательно в то же самое, что вы уже заведомо видели ситуации, когда функция бьет из
одного множества в другого. Мы хотим, чтобы было попроще, поэтому давайте ограничим все этим случаем.
А кажется, что его достаточно. Это пока не столь очевидно, но я не хочу все мыслимые вещи из
математической практики засунуть в свой формализм. Я хочу что-то самое необходимое. Но функции нам
нужны. Константы нам нужны. Константы это очень просто. Константы это просто-напросто элемент
какого-то множества. Скажем множество действительных чисел. А функция, ну вот, то есть это просто имя
какого-то конкретного числа. Вот так у нас и будет ходить формализм. У нас для константа будут
запасивные специальные символы, которые обозначают константы. А функции будут записываться, похоже на
предикаты, тоже имя функции, потом в скобках перечисления ее аргументов. И вот обратите
внимание, вот это уже не высказывание. Смысл вот такой записи уже другой. Это элемент множества
m. Чтобы появилось логическое значение, мы этот элемент должны в какой-то предикат вставить.
То есть логические значения у нас появляются только из предикатов. Функции нам дают элементы множества.
Но что они нам позволяют? Вот если у нас там был только вот такой совсем простой предикат,
то здесь смотрите, что получается. Получается так, у меня есть предикат, ну давайте я его назову
равенством. И здесь я применяю функции. Какие? Я применяю функцию сложения к функции квадрат и
константе единица. А второй элемент предиката равенства 0. То есть вот такая вот запись в формализме,
мы так, конечно, писать обычно не будем, но нужно понимать, что в формализме это превращается вот
что-то такое. Предикат, а аргументы могут быть не обязательно переменными, а могут быть константами,
или какими-то более сложными выражениями, состоящими из функции, и констант, и перемен.
Вот эти вот выражения, я прошу прощения за это слово, в синтаксе все будут называться термы.
Почему прошу прощения? Потому что опыт показывает, что почему-то формализм не то чтобы очень простой,
но безумно трудный. Но вот когда появляются термы, почему-то люди перестают воспринимать. То есть вот
рассуждения, в которых возникают термы, кажутся уже какими-то совершенно ясными. Хотя вроде бы
вот так все понятно. Пока я не начал давать строгие определения, вроде бы все хорошо. Термами я
просто называю имена каких-то элементов нашего вот этого основного множества, на котором мы рассуждаем.
Предикаты это отношение. Вроде бы понятно, но тем не менее возникают сложности в этом месте.
Давайте подумаем, все ли у нас есть, чтобы начать высказываться о разных интересных
математических вещах. Одного у нас точно нет, а именно кванторов. Вы знаете о кванторах,
вы их используете, там на анализе без этого не обходится. И это не удивительно, потому что
если использовать только вот эти выразительные средства, мы конечно много предикатов можем
выразить. На самом деле разных интересных утверждений мы сделать не сможем. Например,
вы знаете, что в действительных числах это уравнение не имеет решения. Как это записать?
Вот для этого нужен квантор.
Что эта запись означает? Ну отрицание это понятно. Это я применил логическую операцию. То есть
предикат неровно. Что у нас есть предикат равенства, то отрицание будет предикат неровенства. А что такое
квантор? Вот заметьте, вот здесь стоит предикат от одной унарной предикаты. Навешивание квантора
на переменную, которая входит в предикат, уменьшает арность предиката. Вот все вот это становится
нулярный предикат. Вы скажете, а что такое нулярный предикат? Предикат, у которого нет переменных.
Что это такое? Ну предикат всегда принимает логические значения, а переменных нет. Значит это
просто одно из двух логических значений. То есть нулярный предикат это всегда истинная или
ложная. То есть когда я навесил квантор на ту переменную, которая входит в этот предикат,
у меня уже получится истина или ложь. Но в данном случае, если x мы считаем, берем из
действительных чисел, это будет истина. Если мы их будем брать из комплексных чисел, это будет
ложь. Тут нужно помнить, что значение нашего высказания зависит от того, как мы понимаем
переменные. Переменные принадлежат некоторому базовому множеству, которое будет называться
областью интерпретации, но давайте про это в следующий раз более аккуратные слова скажу. Как
в общем случае определить предикат? Вот у нас есть НР предикат, я навешиваю квантор, ну давайте
по первой переменной все будет совершенно симметрично. Это какой-то предикат, как я уже
сказал, который зависит от всех остальных переменных, кроме вот той, на которую навешан квантор.
Навешивание квантора делает эту переменную мнимой, от нее уже значение высказывания не зависит. И
определяется это очень просто. R с тильдой от каких-то значений x1, x2, xn равно единице, если для
любого x1, вот наш исходный предикат, я подставляю теперь аргументы со второго по Энтой. Те, что у
меня здесь есть, а вот вместо недостающего аргумента подставляю какое-то. Вот если для любого это истина,
то тогда единица, иначе ноль. Ну это обычное понимание кванторов все в общемстве. То есть
содержательно мы говорим, что для любого x должно что-то выполняться. Но формально это означает,
что мы должны зафиксировать все переменные, кроме вот той, по которой мы навешиваем квантор, и
посмотреть при разных значениях этой переменной из квантора, что получается. Второй квантор,
который у нас всегда в математике используется, квантор существования, он определяется очень похоже.
Собственно единицей будет, если для какого-то,
х1, предикат под квантором обращается в единицу. Ну с остальными значениями переменных. И здесь
ноль. Иначе. Легко видеть, что кванторы существования и кванторы всеобщности связаны. Вас почти заведомо такой
формуле учили, что отрицание квантора всеобщности это квантор существования по отрицанию вашего
высказывания. Это просто вот из этих определений мгновенно следует. Мы к этому вопросу еще вернемся,
конечно. Смотрите, что значит, что для любого x, r ложен. Смотрим на определение. Это означает,
что найдется такой набор значений переменных x, что r ложен. Но если r ложно, отрицание r истинно.
Когда смотрим вот здесь. Но это означает, что наш предикат вот этот квантором существования истинен.
Ну и в обратную сторону рассуждения точно такое же. Это равносильные, как говорят, высказывания.
Ну вот. Вот у нас появляется такой формализм. Удивительным образом больше, если ставить цель
просто принципиально выразить всю математику, то больше ничего не нужно. Это кажется странным,
потому что в математике формализм больше гораздо там много чего там хитрого и сложного. Но вот
оказывается, что вот этого достаточно. Точнее, я скажу аккуратнее. Есть очень продвинутые области
математики, которые никто никогда до уровня этого формализма не доводил. Математики верят,
что это можно сделать. Но в книжках написано иначе. Написаны какие-то другие слова. И некоторые
математики говорят, а вот представьте ситуацию. Мы начнем доводить до уровня вот этого формализма
и столкнемся с проблемами. Потому что слова-то мы уже там 50 лет говорим гораздо более сложные.
Может быть, мы уже используем какие-то принципы, которые выражаются таким образом. Но логики в
это не очень верят. Большинство математиков тоже. Но такие еретики имеются. Может быть,
в математике уже где-то сидит что-то большее, чем этот формализм. Потому что опустить продвинутое
содержательное математическое рассуждение до этого уровня достаточно трудно. Тут, вы видите,
возможностей на самом деле очень мало. На первый взгляд, кажется вообще странным, как мы можем
обойтись только этим, при том, что даже та математика, которую вы знаете, там много чего еще
есть всяких выразительных средств, которые буквально так не выглядят. Тем не менее есть
универсальный способ выразить все с помощью этого формализма. Но у меня время вышло, поэтому я тут остановлюсь.
