Поехали, пришло время концептов.
Концепты это невероятно просто.
Сейчас, а вот часть, которую мы прошли, это гуд, бетт или агет?
Это все пока гуд было.
Так.
А сейчас бетт, да?
Нет, ну бетт, но это аналогия.
Вот ключевое слово концепт, оно не отличается от пары ключевых слов
constexpr bool, кроме угадайте чего.
Да, вот эти две палочки и два амперсандра работают по-другому, единственное отличие между ними.
Да, для этого и ввели новое ключевое слово, долгое время даже говорили, зачем новое ключевое слово,
давайте просто constexpr bool переменной использовать, все будет хорошо и казалось бы нормально.
Но деталечки с тем, что не или не выинстанцируется все, что там в бинарных бульевских операторах,
из-за этого пришлось все-таки ввести новое ключевое слово.
Ну а зачем это все вообще?
Ну принципиально концепты нужны, чтобы выделять какие-то подмножество типов всех.
Это предикат на типах.
Он говорит нам, какие типы подходят, какие не подходят, какие хорошие, какие плохие.
Ну чуть поподробнее об этом будет потом, сейчас наверное просто посмотрим, как это может выглядеть,
да вот так может выглядеть.
Ну вот типичное определение концепта, оно вот такое.
Концепт тыры-пыры равно requires, набор переменных, которые вам нужны и просто вот этот requires expression
внутри чет пишете.
Ну и все они в принципе дальше будут так выглядеть, мы на них сегодня еще много посмотрим.
А на удивление можно концепты определять не только на типах, но и на всяких вот этих дурацких интах,
можно на шаблонных-шаблонных аргументах.
Какая функция должна быть?
Справа?
Ну справа может быть, да, вызов context про конставал функции, другой концепт,
или там конъюнкция, дизюнкция, еще, да, короче, все что угодно может быть.
Да, да, да, это констэкспер булт, вот с этого все началось, то, что справа, строго в компайл тайме вычисляется.
Так, да, ну нужно это, чтобы явно, вообще в принципе концепты нужны, чтобы явно имена давать вот этим
подмножеством, да, что выделить под множество типов мы могли и раньше каким-нибудь лютым сфенае,
но теперь мы можем вот этим вот хорошим набором типов давать какое-то разумное имя.
Ну вот subtractible это не очень разумное имя, сразу скажу, но читающему код уже понятно,
что вот эта вот функция, она принимает аргументы, которые можно вычитать друг из друга.
Ну вот просто из одного слова понятно. Достаточно тривиальный пример, но когда там вот такая функция на 200 строк,
достаточно ценно иметь такую вот возможность вместо комментария просто вот симантически,
ну, синтаксически обозначить, что имеется в виду. Ну вот сюрприз, можно писать вот так.
Ну это неправильно, мы же не из-за убрать, то получается...
Ну да, не по-английски получается, но вот так было, да, это мы все видели, это все понятно,
просто концепт теперь, но еще ключевое слово концепт отличается тем, что можно делать вот так.
Видите, куда он передвинулся, а?
Это похоже на джемерики в росте.
Ага, нет, ну на самом деле это все берет корни в каких-то старых языках, которые там еще 50 лет назад,
вот это все имели и спокойно этим орудовали. Ну вот C++ наконец-то дорос.
Ну, очевидно, да, что берется, подставляется it как бы вот туда, и это все одно и то же эквелентно.
Знаете, менее очевидные кейсы. Вот концепт constructable from. Тут сразу навалилось, да, там врядик эти,
и первое T это что мы пытаемся конструировать. То есть мы проверяем T, и в фигурных скобках написали
аргументы типа args. Будет ли конструктор запущен и все сработает или ошибка компиляции.
Можно вот так сделать. Понимаете, что тут написано?
Нет, нет, нет. Да, здесь написано, можно ли контейнер с конструированной конструкцией.
Вот этот контейнер, то, что мы вместо type name теперь пишем концепт, и то, к чему мы это применяем,
вот этот контейнер, он всегда первым аргументом подставляется. Остальные аргументы, вы не поверите,
карируются. Кто функциональным программированием занимался? Ну, давай не будем об этом говорить.
Частичное применение функции. То есть мы фиксируем некоторое количество аргументов и рассматриваем эту
функцию как новую функцию от меньшего количества аргументов. В мотоне такое иногда делали, типа
давайте вот возьмем нашу многомерную функцию, там палку ставим, и зафиксируем x равно нулю. Теперь
это функция одного аргумента y. Вот это как бы есть карирование. И здесь в каком-то смысле вот это
вот выражение constructible from vector, оно как бы карирует вот этот вот концепт, и мы получаем как бы
новый концепт уже только от одного аргумента, который мы потом подставляем отдельно. Ну, что-то
общее есть, но в целом далеко на таком карировании не уедешь. Ну, жалко, но...
Ну да, но в плане, когда как бы человек, любящий функциональное программирование,
видит карирование, его сознание сразу будоражится, и он хочет какие-нибудь
монады выразить через это. Не получится. Ничего не выйдет. Это слишком ограниченная штука. Она сделана
исключительно, чтобы проще читать было. Потому что слева направо. В шаблону нужно
constructible from vector, контейнер. То есть нужен контейнер, который можно сконструировать от
вектора. Ну, на английском нормально читается, на русском у нас другой порядок слов и что-то
все ломается. Окей, ну вот такое это преобразуется. Я уже все это проговорил, взглянули, закрепили,
пошли дальше. А ну и все, в принципе, про концепты. Вот это все, что они умеют. Какой?
Сейчас, у нас же ты говорил, что если у нас два requires вычисляются в true, то это
ambiguous call. Но в случае с концептами это не так. Про это будет позже.
Я думаю, там все имплисит касты наши любимые. Про то, что int имплисит ли кастец к булу,
если ноль, то false. Все это работает. Мне кажется, да. Но проверьте лучше это в Годбалте. Потому
что я наизусть как Библию стандарт не учу. И Библию я тоже не учу, если что. Есть люди,
которые учат. Но вообще аналогия с церковью хорошая. Вот я как такой дичок из деревни вам,
прихожанам проповедую. А есть вот там, где-то вот там вот поп, который вот, а еще выше,
там есть вот этот, как это? Кто самый главный у нас в церкви? Патриарх. Вот где-то там есть
патриархи, которые сидят на синоде своем и вот разрабатывают эти все вещи. Решают,
как правильно интерпретировать Библию. А мы тут так. Где? Что?
Я просто пока не до конца рассказал, как работают волшебные две палки и два
амперсанда. Они еще более волшебные, чем я сказал. Сейчас будет про них еще,
но для начала про более сложное, что можно в Requires Expression еще написать. А внезапно очень
много чего можно написать. Такое мы уже видели. Достаточно обыкновенная фигня. Потребовали два
две переменные T и U. Причем пафос-то в чем? Это будут универсальные ссылки, как бы в каком-то
смысле. Потому что оно работает так же, как у вас работают функции. Если вы вот такой код написали,
то это вам гарантирует, что приняв функцию T и U, которые Swappable, вы вот такой код функции
напишете, приняв причем по универсальным ссылкам их, вот такой код напишете, он будет работать.
Наверное, это даже самый правильный взгляд на Requires Expression.
Что? Смотри, про что я говорю. Если ты вот это вот... Смотри, предположим, мы удовлетворили вот
этому концепту нашими типами. Тогда если мы вот это все зачеркнем, Requires и концепт, все это
зачеркнули и написали здесь просто функция foo, void foo, то это скомпилируется. В этом смысл. Но если
здесь уже не вот это вот все, а void foo, то это универсальные ссылки, так? Ну вот. Значит,
и в концепте они как бы работают в кавычках как универсальные ссылки. В каком-то смысле. На
самом деле это просто обычные R-value ссылки и просто мы их forward'ем. И мы как бы понимаем,
что T и U, они вообще-то могут быть сами ссылками, причем L-value. И тогда вот это схлопнется,
вот это схлопнется и все как бы как обычно. Короче, да, это универсальные ссылки. Они выводятся,
когда ты вот этот концепт функции будешь использовать. Ты же концепты не просто так
где-то ставишь, ты пишешь функцию какую-то, которой нужно что-то с чем-то свопнуть. Вот ты в этой
функции поставишь концепт swapable, а типы-то выведутся, наверное, в этой функции. И тогда
вот они будут как бы универсальными ссылками. В этом смысле. Я чувствую непонимание. Возможно,
вам просто надо это на практике потрогать, пописать код, и тогда будет понятней. А мы поедем
дальше, потому что вот это все мы видели, а вот это не видели. Можно писать так. Догадайтесь,
что это значит. Да, проверка, что следующее выражение называет тип. Вот так вот даже.
То есть справа пишется любое выражение, а мы проверяем, что это имя какого-то типа. Ну,
заметьте, просто какой-то шаблон инстанцировать тоже можно. А когда вот это вот вообще может быть
фолс нижнее. Да, но вот я не уверен, что тогда в этом случае произойдет, потому что у тебя
форбрек-декларация все равно будет. Вот статик ассорт, по-моему, вообще тут все сломает,
но я не уверен. Вот с этим надо экспериментировать. Вот концептами покрыт, да, а еще с может быть
переменной вообще-то. Вы не забывайте, что мы работаем с именами. Это просто какие-то имена.
С чего вы взяли, что это вообще тип? С переменная. Нет, просто есть глобальный шаблон переменной,
с. У вас концепт проверяет, что в глобальный, в имя глобального шаблона какого-то вот в этот
шаблон можно подставить t и получится тип, а мы подставили и получилась переменная. Что?
Справа тип, выражение, которое называет тип, то будет фолс и все это вместе будет фолс. Тоже
самое с инером. Смотри, да, про то вообще зачем писать концепт, а не просто впендюривать, да,
почему бы не впендюрить это все в саму функцию, два раза requires написав. Нет, нет, нет, лучше аналогии
есть. Это интерфейсы. Вот ВОП есть интерфейсы, где вы описываете там требования, которые вам
позволяют что-то там делать с какими-то объектами. Аналог интерфейсов ВОП для метапроги это концепты,
они описывают список требований к типу. Но зачем вообще ВОП интерфейсы? Все же можно по ссылке на
объект передать, ну в джаве по крайней мере, да, там любой класс наследует объект, давайте из ДО
объекта передавать. Зачем нам интерфейсы? Ну и тут такая же примерная идея, да, зачем нам
передавать, зачем нам указывать какие-то концепты требования, когда можно просто как бы любой
шаблонный аргумент принять, а дальше уже компилятор разберется, скомпилируется оно или нет. Смысл этого
в том, чтобы выделять разумные абстракции, чтобы у человека в голове образовывалась концепция,
что есть такое вот понятие как итератор. Некоторые типы являются итераторами, и вот тебе говорят, что это
итератор, и сразу понятно как с этим работать, что это значит вообще, что это за тип такой. Это вот
абстракция, абстракция выделенная при помощи концепта, ну и много еще таких можно назвать,
да, собственно они дальше будут. Мы сейчас будем смотреть концепты стандартной библиотеки, вот там
мы увидим кучу уже выделенных абстракций, выделенных в концепты, с которыми удобно работать и
мыслить. То есть тут даже цель не как-то механически на уровне языка чего-то добиться, а добиться более
плавного взаимодействия кода с вашими мозгами, вот так скажем.
Еще такой момент, вспомнил у нас как концептор, вот это не твой ответ, а пока мы здесь, что если мы пишем
функцию, у которой вариантик шаблон, и делаем там концепт, ну то есть концепт фу какой-то есть у нас
функция, сигнатура там плей, многоточие, full types, если мы хотим несколько таких имен написать, то концепты не вкладываются друг
друга, даже если они более строгие. Многоточие ломает перегрузку по более строгим. Я еще не рассказал про
перегрузку по более строгим концептам, а ты уже лезешь вперед, но это да, вот ровно то, что там
Андрей приходил, говорил, да, я вспомнил теперь о чем он там маялся, давай не будем пока про это, никто
ничего не понял же, ну и нормально, сейчас все будет. Так, про type name все поняли, просто можно проверить,
тип это или не тип, да, последнее, что я говорил, а меня прервали, inner тоже может быть переменной,
да, а может быть функций, а мы хотим, чтобы именно тип был, а можно вот так еще писать, вот это самые
забавные мощные синтаксис. То есть мы в фигурных скобках пишем некоторое выражение, которое может
вернуть какой-то тип, вот у этого выражения есть тип, да, и после стрелочки мы пишем другой концепт
и говорим, что тип, который вернула это выражение, он должен удовлетворять вот тому концепту, то есть здесь
написано, хэша т объект создали, вызвали от а, в итоге должны получить что-то, что convertible2 size t,
ну что такое концепт convertible2, я думаю, интуитивно, понятно, пока детали не нужны.
Окей, да, что-то тут выделяю, можно вот так, то есть не суть важна, что угодно пишете и круто, вопрос,
тоже ли это самое, что вот так вот ручками взять и расписать, мнение да.
Я тоже думал, что здесь есть подвох, но раз за разом убеждаюсь, что его нету, хотя это могут быть баги в компиляторах,
но в общем и целом кажется это одно и то же, просто вот здесь очень чистенько, очень понятненько, ну и тут у вас может
быть список и будет список из там пяти разных выражений и как-то видно, вот это написали, получили это, это написали, получили это,
а здесь какой-то ужас, и все это вот какими-то словами непонятными разбавлено, какие-то деколвалы, деколтайпы,
но если вы...
Сейчас нельзя ли тогда написать компактные типа low-crizal какие-нибудь?
Да можно, но все равно это менее удобно, чем вот это, но в целом, если вам не нравится так, можете писать так, я не буду изникать.
А это еще не скомпилируется я себе?
Скомпилируется, в том-то и прикол, все, что справа от концепта, оно работает опять же волшебным образом,
и если где-то что-то произошла ошибка, оно на самом деле false сделает, но я не уверен, что так задумано стандартом,
местами мне кажется, что должна быть все-таки ошибка компиляции, но на моем опыте все компиляторы просто false в концепт возвращают, и все.
То есть вот тут, конечно, надо перепроверить 10 раз, но лучше с реальностью мириться,
все компиляторы, что я пробовал, просто делают false, какая бы здесь ошибка не происходила, и чтобы вообще не было написано.
Но он репортит, что именно пошло не так?
Ну да, возвращает false, но репортит.
Ну да, репорты, вот здесь, репорты самое важное, когда вы используете вот эту машинерию,
у вас будут очень понятные репорты, вам напишут, вот в этой строчке вот это выражение вернуло такой тип,
вы потребовали, чтобы он был секой, а у него не хватает вот этого и вот этого.
То есть тут максимально красивые будут сообщения об ошибках, а вот здесь вы получите, я не спок.
Evoluted to false, sorry.
Потому что для компилятора это все прозрачно.
Какие-то шаблоны друг друга подставляют.
Ну same as, evaluated to false, because, ну вообще зависит от компилятора.
Скорее всего он скажет, что есть вот этот тип, где компилятор, скажет, что он просто не SST.
Ну я говорю, зависит, да, зависит от крутости компилятора, потому что частенько и то и другое одно и то же дает.
Но мне кажется, задумка всего этого в целом была в первую очередь сделать более удобную жизнь компиляторам,
ну и пользователям, писать проще, читать проще ошибки.
Ну есть бонус небольшой.
Я сомневаюсь, что только из этого бонуса добавили эту фичу, но он есть.
Вы можете написать noexcept после фигурных скобок, и компилятор еще и проверит вам, что вся эта фигня в скобках noexcept.
Можно написать noexcept, констрация.
Да.
Вопрос какой-то.
То есть получается у нас, я просто удивлен, вот эти вот фигурные скобки, которые окружают какой-то expression,
это нововведение 20 плюсов тоже, правильно?
Да, и только внутри requires, может.
А как это называется?
Вот этого, ой, что-то типа complex или compound, compound requires expression, что-то такое.
Ну, в том, что вот этот синтез, ну короче, это все нововведение, все сейчас, что мы смотрим, это 20-ые плюсы.
Ну да, у этого всего есть какие-то названия умные.
Ты посмотри это на cpp-reference лучше.
Просто я чему-то прошу, чуть-чуть чужерогому кажется это плюсов.
Да, да.
Да, мне тоже кажется, что вот этот весь синтаксис, он как-то, ну, нигде в других местах в плюсах вот такого синтаксиса не встречается,
что в фигурных скобках выражение и стрелочка потом.
Но вот так решили.
Возможно, это заделка на будущее какое-то.
Ну, посмотрим.
Вот, можно вообще без стрелки.
Просто в фигурных скобках что-то noexcept.
И оно проверит.
Это должно быть noexcept.
Проверяет, что тип вот этого выражения удовлетворяет концепту.
Ну, причем сюда оно подставляет его первым аргументом.
Такое же карирование происходит, да, как и раньше.
Чего?
Наличие атрибутов.
Наличие атрибутов?
Нет.
Ну, атрибуты, это которые в двух квадратных скобках.
Нет, они не являются частью языка
и могут безопасно игнорироваться,
как бы, абстрактные машины.
Муть.
Можно нет шаблонные концепты?
Нет, концепт, только шаблонные.
Здесь есть какой-то слайд.
А, да.
На слайде загадочное выделение.
Я не понимаю, что значит это выделение,
но это еще одна штука,
которую можно написать
в requires expression.
Видите?
Второй раз requires написан.
И requires, и дальше какой-то концепт.
Ну, или более вообще, какой-то буль,
наверное, тоже можно.
Ну, это по референсу только такой пример.
Ну, что это значит?
Ну, это то же самое, что
через два амперсанды еще раз написать
same test звездочка и вот это вот.
Ага.
Выделение, наверное, про то, что в второй строке
еще требовали концепт.
Ну, да, да.
Здесь не явно накладывается еще одно требование,
что вот это вот newt скомпилируется.
Но как бы
хотелось сказать, что оно не накладывается,
если мы снаружи это напишем
через два амперсанды, но на самом деле
тоже накладывается.
Поэтому вот тут какой-то тонкий момент.
Ну, то же самое, что два амперсанды,
просто можно вот так писать. Зачем?
Читайте, зачем это
заключается от запися без requires?
Нет, если ты просто вот такую запись делаешь,
то это будет очень плохо.
Потому что это самый распространенный
источник ошибок, когда ты пишешь
концепты. Вот без ключевого
слова requires ты просто потребуешь,
что инстанцировать
концепт можно.
А концепт всегда можно
инстанцировать. Просто
может быть true, может быть false.
Но инстанцировать можно всегда.
Просто написать такую строку
это все равно, что ничего не написать.
Ну или грубо говоря,
это то же самое, что написать только
newt. Вот так вот.
А вот здесь именно требуется, что и вот это
все инстанцировалось нормально,
и вернуло true.
То есть если вы вот с таким
синтаксисом забудете где requires написать,
то это баг, и у вас все будет
плохо. Ну, то есть
мне кажется, стоило бы оставить это
через два амперсанды, а не добавлять вообще такой
синтаксис, потому что, ну реально, очередная
пушка, направленная нам на ноги,
спасибо, блин.
Ну, есть так есть.
А...
Да, да, да, да, да, да.
Ну нужно как-то вот себя в тонусе
держать так, уф.
Это некрасиво выглядит, когда мы пишем
много для них амперсандов.
Если нам нужно,
чтобы requires...
Но вообще,
это может быть, наверное, тем
удобно, чтобы пусть мы пишем
в requires
какой-то список методов
и...
Ну, блин, это было бы странно,
если бы мы где-то в середине хотели бы
проверить...
Ну, бывает. Видимо, для этого и добавили.
Ну, просто для красоты. Так удобно.
Один requires пишешь, и туда все пихаешь, и...
Вот, мы пока на слайд
смотрим, да?
Что, вы как думаете, здесь происходит?
Ин звездочка ноль,
это 0ptr или что?
Ну, да.
Я просто хотел, чтобы это был
не 0ptrt тип, а именно
ин звездочка тип.
Ну, что?
Что скажете
об этом коде?
Что?
Про более частая
скомпилируется.
Ну, да, код скомпилируется. Что в первом случае
будет вызвано? Первая
F или вторая?
Первая.
Почему?
Окей, а во втором случае что будет вызвано?
А почему?
Да, да.
То есть, если мы пишем requires внутри,
то у нас нет такого наследования?
Или оно включено?
Нет, все есть.
Смотри, два амперсанда
в requires просто здесь
или вот здесь и в концепте,
они одинаково работают.
Для этого нужно ключевое слово концепт, чтобы везде все одинаково работало.
Нет, я про то, что мы можем
написать то же самое, что requires t
большой от маленькой,
а внутри, кстати, require, например,
от t. И в таком случае будет происходить
концепция.
О, как же ты прав.
Действительно.
Да, видимо, тот синтаксис
нужен, чтобы запретить вот это.
Гениально.
Нет, эта мысль
неважная. Давайте сначала разберемся
с тем, что вот здесь происходит, а потом к ней вернемся.
Вот, что значит более частное?
Так, ребят,
если у вас вопрос, давайте задавать. Нет? Все.
Более частное. Ну, тут как бы
интуитивно видно, что если что-то
rev итератор, то оно автоматом
decrementable. Так?
Есть импликация.
Ну, и когда у нас
как бы
эта импликация есть,
она и распространяется на вызовы вот этих функций.
То есть любой тип, для которого можно
вызвать что-то от rev итератора,
то есть нижнее,
если нижнюю f можно вызвать для t,
то верхнюю тоже можно. Верно?
А вот если верхнюю
можно вызвать, это не значит, что можно
нижнюю. То есть если нам
пришел какой-то тип, который приходит в обе,
наверное, лучше нижнюю запустить,
потому что она более частная, она больше
требований накладывает.
Ага.
Да.
Не будет работать.
Вот.
Давайте посмотрим
сюда.
Констраинты влияют
на overload resolution. Про это мы
не говорили еще.
Помните три этапа того, как мы функцию
ищем? Там было
составление всего множества имен,
потом инстанциация всех шаблонов
в нем, а потом overload
resolution. Вот с 20 плюсами
второй шаг поменялся. У нас там
констраинты проверяются. Поменялся
теперь и третий шаг. Из всех
шаблонов, для которых констраинты
прошли, нужно выбрать самый
подходящий.
Внезапно. То есть вот здесь
в случае второго вызова
оба этих имени,
оба этих шаблонов
функции, они будут найдены,
оба они пройдут инстанциацию
успешно, проверку констраинтов
оба тоже пройдут, и оба
попадут в итоговый overload set.
Множество перегрузок.
Надо выбрать в этом множестве
перегрузок наиболее подходящую
функцию. Без
каких-то изменений
не обойтись. Изменение следующее
ввели. По импликации
между
атомами,
который
матлок атомы,
строится граф.
И в этом графе выбирается наименьшая
перегрузка.
Вот здесь сейчас все слова важны.
Все слова важны, потому что
частичный порядок строится
по импликации на атомах,
где атомам считается
выражение, написанное в коде,
в том месте, где оно написано.
А вершины этого
графа импликаций...
Хорошо.
Вершины это функции.
Overload set
это вершины графа.
Мы строим ребра. Где мы строим ребра?
Где мы можем доказать, что есть
импликация между
констраинтами?
Концептом и внутри концепта
к этимологическим операциям?
Да.
Да.
Мы как бы работаем здесь
на уровне исчисления высказываний,
не предикатов.
Поняли, что я сказал?
Мы
не залезаем внутрь вот этих элементарных
термов, вот этих атомов.
Внутри requires expression. Мы работаем
с ними как вот просто символ.
Символ исчисления высказываний.
Ищем импликации.
И вот здесь, если вы там
распишете на бумажке, обозначив
вот этот терм за символ
A, а вот тот терм
requires... за символ
B, и посмотрите,
общезначим или формула
re-iterator, стрелка,
decrementable. Вы обнаружите,
что да, она общезначима.
Я бы даже, наверное, написал,
но я не знаю. Вот тут какие-то
доски, наверное, ничего не выйдет.
Да.
Проверка импликации исчисления
высказываний, она
сильно дешевле, чем там проверка.
Ну, она вычислима хотя бы. Этому
уже радуйся. Ну, ладно,
это не особо быстро. Это там...
Это экспоненциально.
Да, да. Ну, давайте, кто
будет хорошо там теорию сложностей
вычислений, вот за сколько проверяется
SAT-задача? Это задача
SAT, да? Нам нужно проверить
общезначимость формулы. Сейчас я даже
ее напишу.
Сад?
Ну,
3SAT это же...
3SAT быстро вроде, да?
3SAT это
NP полное значение. 3SAT это NP
полное, а 2SAT, по-моему, P.
Вот. Ну, короче, мы NP
полную задачу решаем. Давайте я нарисую.
Ну, SAT-солвер
в компиляторе
теперь есть. Вот это символ
A.
Вот это символ
Вот это символ B.
Мы хотим проверить.
Сейчас.
Да, давайте вот это за D
обозначим, вот это за R обозначим.
Ага.
Нет, сюда
подставится вот это вот сам... Вот это будет D.
Вот это как
бы будет D, да?
Вот эти вот они как раз совпадают за счет
того, что мы здесь использовали еще раз
концепт, они заново написали
терм, они как бы
один и тот же символ.
Если бы мы заново написали вот это выражение,
то ничего бы не сработало. Ага.
И что мы проверять хотим?
Мы хотим проверить импликацию вот в эту сторону.
Видите в какую?
Ну, как эта импликация
будет выглядеть? R стрелка D.
Раскрываем определение R.
Это D и
B.
Стрелка
D.
Стрелка D.
Ага.
Ну, это общезначимая формула.
Доказали.
Ну так, Сёма даже.
Да, теперь
надо вычислять экспедиционную штуку
во время overload resolution функций.
Да, все компиляторы
теперь так делают.
Ну так.
Да нет, просто не пиши дурацкий код,
а все нормально будет.
Ну, вообще, да,
а что вас смущает
то, собственно, у вас NP
полный язык шаблонов есть
во время компиляции, как вот тут люди говорят.
Вы можете свой сад
solver на нем написать.
Никто не запретит. Теперь он
стройный есть. Ну, неплохо.
Чего?
Ну,
ну,
ну,
ну,
Ну,
ну,
ну,
ну,
ну,
ну,
ну,
ну,
Это в тех местах, где...
Короче, там нормально всё.
Я не могу это срагументированно объяснить.
Эмпирически было выяснено, что это не так больно, как кажется,
не так долго, как кажется,
если вы, конечно, целенаправленно не будете писать
какой-то супердурадский код с супердурадскими хаками,
где суперогромный граф.
Может, там какие-то обвенчания на более уфоро, которые придут в концепцию?
По-моему, там никаких ограничений нет.
А если это был пустырад?
Нет, просто вот надо проверить.
Любое... Восчленение высказываний формулы,
надо проверить, что вообще значимое, да, и решаем сад.
Ну, что поделать?
Это всё равно быстро, потому что у вас максимум 100, наверное, функций.
Нет, ладно, бывают и по тысяче функций в оверлот-сете.
Нет, не так.
Проблема в том, что у вас концептов столько не наберётся разумных.
Вот максимальная цепочка концептов по включению,
которую мы сможем найти, наверное, будет где-то 10.
А то и меньше.
И там достаточно быстро можно выяснить, кто в кого включается.
Потому что они все выглядят одинаково.
То есть никто не пишет сверхдурадские выражения в концептах, да?
Пишут в основном только амперсанды или редко бывает.
Поэтому в целом это не страшно.
Но это очередная пушка вам на ногу.
Да, вы можете взять и с лёгкостью написать код,
который там положит компилятор.
Прикол.
Опасно.
Всё, давайте пойдём дальше.
Я надеюсь, вы про этого поняли, что тут с перегрузками всякая магия происходит.
Вы идёте в какую версию функций этой каждой?
А, да, мы же выяснили.
Ой, мы выяснили, что здесь есть импликация.
Она прошла.
А из верхней F следует нижняя.
По-моему, мы так доказали.
Если F не сразу...
А, да.
Да, ты права, абсолютно права.
Есть такая импликация.
И мы выбираем на И большей.
На И... Короче, вторая выберется.
Самая общая.
Самая общая.
Да.
Самая частая.
Тут сложно сказать, в какую сторону частности, в какую общность.
По-разному можно интерпретировать.
Короче...
Самая занициализированная.
Короче, инициальный объект в категории.
То, откуда все стрелки растут.
Корень, типа дерева.
Да, как бы корень.
Исток.
Будет выбран исток.
Окей?
Ну, давайте просто дальше договоримся, что это там наибольшее.
Идем дальше.
Куда мы идем?
О, никуда мы не идем.
Вот.
Я написал наименьшее.
Пусть будет наименьшее.
Развернем порядок в крайнем случае.
Понимаете, почему написано наименьшее, да?
Порядок частичный, может что-то быть не так.
Если у вас нету наименьшего, то это ошибка компиляции Ambiguous Call.
Может быть, наименьшее выключение типа...
Наименьшее выключение типа...
Да, наименьшее выключение типа...
Короче, как-то так.
Я, кажется, как сказала.
Ну да, по-моему, сказали, что-то аналогичное есть.
А вот про это вопрос.
Вообще скомпилируется это?
Прямо, это же раз, прямо.
Нет, кажется, если объект сверху более общий,
либо просто класс В,
это будет как специализация, то да.
И потом обелится более часто.
Ну, как бы да, по дефолту это скомпилируется,
а зависит от того, от чего звать будем.
А, видимо, мы тут ничего звать не будем.
Давайте я спрошу.
От 63 это скомпилируется?
Да.
А от 20?
Уже нет.
Потому что компилятор внутрь термов не заглядывает,
он не понимает, что вообще-то здесь есть импликация.
Импликация строится только на уровне исчисления высказываний,
чтобы еще раз вдолбить вам это совершенно точно.
Вот.
Здесь есть ссылка.
Ну, в репозитории есть ссылка на папку с презами.
Там преза, вот можете пройти, если хотите, тут или просто нагуглить.
Там есть целая статья, где все это очень подробно описано
на SPAP-референс.
Когда надо освежить память, освежайте.
И мораль всего, что было сейчас,
это с финай мы больше вообще не пишем, нигде, никогда.
Оно не нужно.
Да.
Так.
Если мы вынесем в концепт вот этот отрывок меньше 32,
и здесь потребуем и меньше 32, и меньше 64.
Нет, наоборот, очень легко перепутать порядок.
Мы вынесем в концепт меньше 64.
Так будет концепт С.
Здесь поставим С, а здесь поставим С и влево.
И вот здесь мы вынесем в концепт меньше 64.
Здесь поставим С, а здесь поставим С и вот это.
То есть мы и С потребуем, и меньше 64, и меньше 32.
Тогда сработает.
А здесь еще есть указание, что у него порядок,
потому что там ленивый или неразрешенный?
Да, да, но вообще мы не подставляем никакие термы, да.
Для нас каждый терм, каждое вот это выражение булевое
или что-то еще, они полностью прозрачные.
Мы с ними работаем как с символами исчисления высказываний
и проверяем общезначенность формулы.
Мы сами вот эти вот выражения не вычисляем.
Вот эти высказывания, мы их истинность или ложность не проверяем.
Мы проверяем общезначенность формулы импликации из одного другого.
Да.
Еще на один.
Еще на один.
То есть в момент, когда мы заменяем в определении рефлактератора
документу ЛУТ на определение документу ЛУТ,
и у нас предстоит работать.
Проблема в том, что он не может увидеть, что у нас одно и то же написано.
Да.
Да, если я не ошибаюсь, он не может увидеть, что одно и то же написано.
Вот тут я могу ошибаться.
Проверьте это, пожалуйста, в годбалте у кого он открыт.
Ни у кого он не открыт, да.
Я могу очень быстро открыть.
Ладно.
Как раз то, что я говорил, здесь в слайде можно монетрирует,
если поставить многоточки после документа, после фотората.
Да, давайте вкратце вот то, о чем Аркадий говорит.
Как только вы используете вриадики,
вот эта вся технология с импликациями и прочим
ломается к чертовой бабушке.
Починить, возможно, хотят к 26-м плюсам.
То есть будьте осторожны, в домашке вам придется писать вриадики,
и вы на это наткнетесь.
Вам нужно будет написать концепт, нужны вриадики,
следствия не будет, и вам будут говорить, ой, все сломалось, амбигиоз.
Ну вот надо...
Что он так делает?
Не допилили стандарт просто и все.
Вы не допилили или там типа написал какой-то код,
который ломается за то, что в теории можно ничего не передать?
Не допилили стандарт.
Просто там недопродумали,
потому что стандарт невозможно просто взять и что-то впилить.
Нужно продумать взаимодействие этого со всеми возможными корнер-кейсами.
Вот этот вот корнер-кейс не успели продумать.
Специализация шаблонов есть?
Специализация чего?
Ну, явно специализация шаблонов.
Концептов? Нет.
Таким извращением нельзя.
Ну, это буквально специализация сейчас.
Что, в концептах нельзя писать концепты?
Нет, не совсем.
Это о чем?
Ну, если ты пишешь типа template, type-name,
type-concept, то в концептах нельзя писать другой концепт.
Вот это я нигде не упомянул.
Вот сюда вместо type-name другой концепт писать нельзя.
И require все тоже писать нельзя.
Иначе бы вы обнаглели.
Такого не дозволено.
Все.
Свиная запрещено, не пользуемся им,
пользуемся концептами.
И в домашках тоже.
Я хочу, чтобы весь этот материал,
как бы конкретной домашки на него не будет.
Но во всех домашках мы пишем шаблоны.
Соответственно, хочу, чтобы вы в этих шаблонах писали концепты,
constraints и прочее-прочее.
Но... Сколько у нас времени осталось, скажите мне?
Полчаса.
Ну, пробежаться попробую.
Но свои концепты изобретать – это тяжело.
Потому что это дизайн кода, это архитектура кода,
это выделение хороших абстракций удачных.
Вот абстракция итератора крайне удачная,
и выделили ее далеко не сразу.
Свою такую же классную абстракцию вы вряд ли сможете придумать
в субботу вечером, пиша домашку по метапроге.
Поэтому мы идем смотреть,
какие уже есть концепты, именованные наборы требований в стандарте.
Да.
Вопрос можно?
Но перед этим... Да, вопрос. Давай-давай-давай.
То, что вы с Аркадией только что обсуждали про...
Это у нас там ворядик...
Как бы это...
В случае с финайеном, будет как-то нормально или нет?
Не понимаю вопроса.
С финайеном истарляется порядок.
Значит, я, видимо, не понял, о чем вы сомневались.
О том, что вся эта технология с построением ипликаций
умирает, если у тебя ворядик функция.
Вот она принимает произвольное количество аргументов.
Наверное, проще буквально на этом примере продемонстрировать,
вернуться к нему и сказать, что нужно сделать,
чтобы код перестал компилироваться.
Вот если мы после decrementable и после ref-этератора
напишем многоточие, а в сигнатуре функции после t многоточие,
чтобы она стала ворядической, да?
Да.
То и больше вообще никаких изменений сделаем,
у нас будет ошибка компиляции с ambiguous whole.
Ну, это бак стандарта.
Все, кто понял хорошо, кто не понял,
сами споткнетесь в домашке, это не страшно.
На своих шишках гораздо лучше, понимаешь.
Давайте идти дальше.
Да, вот тут вопрос глобальный,
что концепт — это у нас такой именованный набор требований.
Вот вопрос каких?
И все, что мы пока что видели,
это лишь одна сторона того, что такое концепт.
У нас есть синтоксические требования в концепте.
И мы их пишем с помощью этих всех requires прямо в коде.
Но это ведь на самом деле не единственное, чего мы ожидаем,
когда говорим слово итератор.
Вот представляя в голове итератор,
вы автоматически ожидаете, что сдвинув его на единичку вперед,
потом еще раз на единичку и сдвинув его такой же или его копию на двоечку,
у вас получится одно и то же, да?
Это семантические свойства.
Вот окей, компилируются эти выражения, класс.
Синтаксис, понятно, какой.
Но как оно работает, непонятно.
Мы не можем вот эти вот семантические требования...
Да, я начал дальше говорить.
Когда синтаксическим требованиям мы удовлетворили,
то есть концепт true в коде,
мы говорим, что он удовлетворен, satisfied.
А вот есть семантические требования,
в коде мы их проверить никак не можем,
потому что это опять же все к теореме к линии сводится
и к проблеме останова.
Не можем мы в коде проверить семантические требования,
что итератор любой мы от такого типа полученный откуда угодно,
если его там двигать так и двигать сяк, то получится одно и то же.
Невозможно это проверять.
Ну и вот, собственно, для семантических требований говорят,
что концепт смоделирован.
И для всех концептов определенных в стандартной библиотеке
как бы есть их определение, которое вот просто код,
концепт ла-ла-ла равно и так далее.
И это только синтоксические требования.
А есть еще набор семантических требований отдельных
для каждого концепта в стандартной библиотеке.
И вот ровно на них мы сейчас будем смотреть.
Ну и на то и другое, собственно.
Ну и к чему это все?
Ты сказал, что концепт это...
Так контингенстератор это несложно.
Я сказал, что концепт это абстракция.
Ну вот абстракция она и синтоксическими свойствами,
и семантическими должна обладать.
Одно мы теперь в коде умеем писать,
другое вряд ли когда-то научимся.
Поэтому вы все еще, если пишете свой концепт,
вы должны сесть и задуматься,
а какие семантические требования я накладываю?
Как я ожидаю, что вот эта штука будет работать?
Понятно вот это вот различие, о чем я сейчас говорю.
Ну типа чтобы там в сортировке или там прочее,
сравнение было удовлетворяло ксиомам.
Да, ксиомы, вот это хорошее слово.
Тут можно другой пример привести.
Знаете, что такое маноид?
Нет, группа. Давайте группу.
Вот какие синтоксические требования к тому,
чтобы у нас был класс группой в каком-то смысле?
Ну да, должно быть определено умножение.
Еще, наверное, какая-нибудь инверс-функция должна быть определенна.
И единица, да?
Ну давайте, c2,1.
Такой концепт легко написать, правда?
Но этот концепт – только синтоксические требования того,
что такое группа инкапсулирует в себе.
Мы же хотим еще, чтобы это умножение нормально работало,
чтобы умножение на единицу давало тот же элемент,
чтобы умножение на обратный давало единицу.
Вот эти семантические требования мы все равно в коде никак не запишем,
поэтому они должны быть в комментарии перед концептом,
написаны на английском языке.
А начнем жестить.
Первое смешное семантическое требование,
которое требуется много где в стандарте.
Называется оно equality preservation.
Про выражение говорят, что оно сохраняет равенство,
если из равенства набора каких-то аргументов
следует равенство этого выражения,
вычисленного от этих аргументов, причем в широком смысле.
Вот значение выражения здесь имеется в виду
не только то, что вернулось, но и измененное глобальное состояние,
и аргументы, модифицированные по ссылке.
То есть весь результат работы функции для равных аргументов
должен быть такой же.
Это свойство чего?
Это свойство выражений.
Если не произошло оба?
Что?
То есть как это соответствует субботу?
То есть условно говоря, если оба не разматываются,
это в контексте с C++ программы?
Это свойство выражения.
Выражения в C++, корректные выражения в C++,
бывают equality preserving, а бывают нет.
Например, сложение для интов – это equality preserving выражения.
А плюс B. Это equality preserving выражения.
Потому что если мы одинаковые A1, A2, B1, B2 возьмем,
подставим, то результат получится один и тот же.
Глобального состояния не модифицировано,
по ссылкам инты плюсик не принимает и их не модифицируют.
А вот...
Надо проверить, что результат вычисления выражений один и тот же, равный.
Для равных аргументов результат вычисления выражения равный.
Относительно оператор равенства.
Пока так.
Вот это сами переговоры.
Ну как бы да. Про это сейчас поговорим еще.
Окей, вот это понятие ясно.
Приведите пример equality preserving выражения.
Рандом.
Рандом, да.
Вот с консоли.
Оно очевидно не equality preserving, потому что ввести на могут что угодно.
Считывание чего-то из сети.
Вот это все оно как бы не equality preserving.
Если оно глобальный счетчик увеличивает и возвращает разные результаты,
в зависимости от этого, не equality preserving.
Если...
Чего?
Да, вот ты абсолютно прав.
Даже если оно увеличивает глобальный счетчик, но никак его не возвращает,
оно все равно не будет equality preserving.
Потому что измененное состояние внешнее тоже считается частью результата.
Состояние в целом же, все системы...
Ну как бы да.
Но если они одинаково изменяют этот счетчик,
то это все еще equality preserving.
Да, если они меняют этот счетчик, присваивают ему единицу,
тогда это equality preserving.
Если увеличивают, то нет.
Сейчас, подожди.
Ты понимаешь, это странно, как мы это понимаем.
Мы понимаем, что если мы упали на программе,
напишем два последовательных...
Если...
Да.
...совпадут и сайд-эффекты...
Да. Да.
Но просто здесь можно было бы предложить...
Завернулось.
И сказав, что мы написали две программы,
если плюс-плюс и в одной это вот этот объект,
а в другой другой объект.
Нет, мы как бы в рамках одной программы требуем, чтобы было равенство.
Это были последовательные вызовы?
Типа того, да.
А лучше откройте это, если интересно, в стандарте
и прочитайте точную формулировку.
Она убойная, но да.
То есть у нас, как в рамках какой-либо, в какой-либо потоке
мы увеличиваем счетчик,
состояние системы меняется,
но только меняется не в этой функции?
Да, все равно не equality preserving.
Да, даже так.
Нельзя все это писать ни в операторах присваивания,
ни в операторах сравнения, нигде.
Сейчас узнаем, почему.
Второе определение, тоже убойное, но которое, опять же,
ну сейчас скажу,
стабильное выражение.
Выражение называется стабильным,
если выполнила следующая фигня.
Был у нас объект,
и мы два раза от одного и того же объекта
подряд посчитали это выражение.
Вот результат должен быть один и тот же,
опять в широком смысле.
То есть опять мы еще какие-то виды
глобальных изменений состояния запрещаем.
Окей?
Мораль.
Ну, выражение, короче,
которое и то, и другое,
они просто как чистые функции считаете, математические.
И сейчас нам хочется как-то формализировать тогда,
что вкладывается в понятие глобального состояния.
Формализируйте.
Ответ был ясен, вы читали.
Ну да, как бы это...
Это очень формально написано в стандарте.
Если хочешь формализировать, формализируй.
Нам нужно вот на этом остановиться и пойти дальше,
иначе мы ничего не успели.
Что?
Операторы не стабильные считаются.
Что оператор?
Оператор перемещения.
Присваивание, муф, присваивание.
Нет, он стабильный.
Но мы не можем есть два раза одного объекта подряд.
Ну, значит, я неправильно выписал определение.
Сейчас там как-то хитро было.
Да, кажется, здесь должен быть не один, это тот же obj,
а два, как бы, клона.
Да, потому что по ссылке можно изменять объекты, когда...
Нет, нет, если будут равные,
то мы получим все еще quality preserving.
Тут важно, что именно два раза подряд вызвали.
Посмотри стандарт, пожалуйста.
Это в бойная вещь,
но почему я так настойчиво про нее рассказываю?
Потому что каждое выражение,
написанное в любом концепте стандартной библиотеки,
от него каждого требуется, чтобы оно было equality preserving.
И кажется все-таки да.
Хотя... Ну ладно, сейчас разберемся.
А что значит написанное в интернете для концепта?
Ну, сейчас мы будем смотреть концепты стандартной библиотеки.
Там определяют концепты movable, copyable, еще какие-то.
В каждом из них написаны какие-то выражения.
В синтаксических требованиях.
А, в приквалинах.
Да, в синтаксических требованиях написаны выражения.
От всех них требуется и equality preservation, и stability.
Но это же не учисляемая.
Да, да.
Это опять проблема останова.
Если вы нарушили эти требования, у вас не defined behavior.
Ну, то есть мораль этого не считайте random в операторе сравнения, пожалуйста.
Или в операторе присваивания какого-нибудь. Вот не надо.
Есть вопрос, как глобальный счетчик увеличиваем.
Да, тоже не надо. Не увеличивайте глобальный счетчик.
И статик переменный не трогайте в операторах присваивания.
А если хочется...
Смотреть сколько раз нельзя написать?
Нельзя смотреть, сколько раз вызвали.
Все, это убея по стандарту.
Несколько запрещают.
Ну вот.
Если вы это нарушите, наверное, ничего плохого не будет.
Но со временем компиляторы начнут оптимизировать код
относительно предположений, что все нормально.
И тогда мы можем пострадать.
Но не факт.
Да, все, начинаем смотреть.
Вот как бы сейчас было немножко bad, потому что...
Сейчас пойдет ugly, да, постепенно.
И bad, и ugly, все в перемешку.
Ну вот простые, понятные концепты.
Вы их сами написать сможете.
Ну, то есть тут, конечно, специализации какие-то
нужно будет пописать, чтобы проверить, что типы одинаковые.
Про convertible2 не очень очевидно, про drive-from тоже.
Ну, есть оговорочка, convertible2,
оно должно быть и имплиситле, и эксплиситле.
Помните, что есть имплисит-каст,
когда вы просто пихаете в аргумент одного типа значения другого,
и имплисит кастует неявный каст.
А есть эксплисит, где какой-нибудь статик, каст, что-нибудь такое.
Ну вот convertible2 и то и другое требуют.
Ну и draft-from только публичное наследование проверяет.
Но, кажется, и другие и не надо, а зачем?
Идем дальше. Еще простая кучка, какие-то для типов примитивных.
Integral, signed integral, unsigned integral, floating point.
Кстати, вы, наверное, не сказали, что requires тоже,
если метод публичный, то его наличие нельзя.
А, ну, конечно.
Нет, это надо было самому догадаться.
Потому что, если вы такой код напишете с приватным методом,
он не скомпилируется, а requires проверяет компиляцию.
Соответственно, понятно, что он как бы не сможет.
А destructible?
Шаблонный из base, он в том числе приватный.
Из base приватный умеет.
Да, потому что ошибка вылетает на другом репиляции,
и он это отличает.
Прикол. Забавно.
Ну да, такие детали обычно cpp-референс
каждый раз заново смотришь, наизусть невозможно.
Destructible.
Ну, noexcept destructible, да.
Вот мы его даже... А, нет, смотреть мы его не будем.
Ну, я думаю, вы представляете, как выглядит этот концепт.
Там тильда T, в фигурных скобках noexcept, все.
Может быть, не destructible.
Что? А приватный деструктор.
Это достаточно полезный трюк.
А еще это может быть... А, нет, ладно, все.
Вроде из base только публичное проверяет.
Там просто нужно было еще в один слот ворачивать,
чтобы на приватном не ломаться.
Вот, давайте...
А в чем смысл приватного деструктора?
Приватного деструктора в том, чтобы только определенные сущности
могли вызвать дилит на твоем типе.
Типа...
Нет, когда это просто... Когда это может быть необходимо.
Сейчас у меня были хорошие примеры, но я уже подустал,
и, кажется, они где-то дальше по сходу лекций нам встретятся.
Поэтому откладывается вопрос.
А в каком примере не деспрактно выучить?
Ну, как бы можно, но как бы нет.
Ладно, нельзя, да, ты прав.
Вот тогда просто сказать, что приватный деструктор,
когда мы хотели зафорсить родителей из-за этого объекта?
Да не форсится там ничего.
Ладно, я не помню, честно, у меня был очень хороший пример,
я специально его помнил и забыл.
Поэтому в один из следующих разов вернемся к этому,
поговорим об этом.
Констракт был фром.
Сингл тон.
Ну, как бы хорошая идея, да.
Вроде сингл тону не нужен публичный деструктор,
можно его спрятать.
А, я... Что?
Разрушится на статической дестракшене,
когда программа завершает работу.
Так она уже будет пробивать.
Ну, это не помешает ронтайму запустить деструктор.
Сейчас, вы так хотите пример...
Стоит ли говорить, что имеется на самом деле приватный деструктор,
когда какой-то другой объект выманижит лайфсайдл?
Ну, как бы да, но это не информативно.
Ну, у симмофора, например, иногда...
Есть у нас какой-то референс каунт,
кто нам вообще будет показывать, что только про него надо делать?
Я вспомнил, у интерфейсов виртуальных в ООП
периодически надо делать приватный деструктор.
Почему?
Чтобы можно было вызвать только конкретно типов наследования?
Типа того, чтобы никто не мог сохранить объект
по указателю на этот интерфейс
и потом его удалить по указателю на этот интерфейс.
То есть бывает так, что вы используете интерфейс
просто чтобы две части кода разъединить друг от друга.
И вы знаете, что вот этим интерфейсом только вот этот класс лежит.
Ну, и удаляет его он сам как бы.
Например, Fiber. Fiber сам себя удаляет.
Помните такое?
Если вам нужно вызвать что-то на Fiber,
но как бы по ссылке и не зная, что это Fiber,
вы можете сделать интерфейс,
у него приватный деструктор, и как бы кому-то это передать,
он что-то вызовет какой-то виртуальный метод,
но сохранить или удалить этот Fiber не сможет.
Вы ему это запретили.
А вот Detach еще проще вариант.
Detach.
Там что-то тоже было, по-моему, это еще сложнее.
Не помню. Да?
Если я правильно понял, вот этот пример,
это обычно советуют виртуальный деструктор.
Да, а я советую его делать приватным.
А мы не хотим соответственно виртуальности?
Да, мы не хотим виртуальный вызов дополнительный на разрушение,
потому что мы знаем, какой тип в момент разрушения этого объекта.
Короче, ладно, вы поняли, да?
Многие говорят, всегда делай виртуальные деструкторы,
я говорю, нет, это тупая мантра, делай их приватными, если нужно.
Если знаешь, какой тип будет в момент удаления,
то кастуй к этому типу и удаляй явно.
А деструктор просто сделай приватным,
чтобы нечаянно никто не написал плохой код,
который по ссылке на интерфейс что-то удаляет.
Все, давайте идти дальше. ConstructibleFrom.
Первый концепт, который мы реально посмотрим.
Смотрите, какой он классный.
Он требует destructible и destructiblev.
Ну, вот первое неожиданно, кажется, да?
Ну, вот почему-то требует.
Второе, это в принципе вот такое выражение в общем и целом,
примерно, типа, ну, там можно запустить конструктор,
и оно как-нибудь разберется, может, и конструктор вызовет,
а может, и не конструктор, может, оно там оператор каста
какой-нибудь вызовет, неважно.
Default initializable.
Простая штука, да?
ConstructibleFrom.t внезапно.
Ну, мы помним, что это на самом деле просто вот так вот будет.
Там был вырядик, а мы ноль аргументов ему дали,
то есть мы просто проверяем, что t и круглые скобки компилируются.
Еще раз на синтаксис. Можно предучитать?
Ничего, просто...
А, все, нормально.
Ага.
А зачем тогда еще тот концепт, ну, предыдущий, destructiblev?
Зачем? Чтобы импликация была.
Ага.
Тут вот в этом все кроется как бы.
Какой второй?
Вторая строчка.
А, вторая строчка, потому что initializer через круглые скобки,
через фигурные, это разные вещи.
Есть как такая книжка, типа там 250 способов
унициализировать переменную C++.
Возможно, я как-нибудь кину вам ссылку на нее.
Но вот так надо.
Вот это место объяснить какой-то логикой невозможно.
Это вот реально типа такая бюрократия по вышкребыванию стандарта
и поиску всех крайних углов и лазеек.
В смысле? Зачем мы тут можем initialize?
Нет, окей.
И с круглыми и фигурными понятно.
Окей. Третий зачем нужен?
Почему через Нью еще должно быть?
Ну, вот тут как бы ответ мы нашкребли,
не помню, Яли или прошлый препод, который метапрога вел.
Но кто-то из нас в общем обнаружил, что это значит вот это.
А ну, групповый вариант даже может быть перегружен в Нью.
А мы его перегрузили и хотим, чтобы с ним можно было работать.
Как здесь?
Да, здесь как бы не про это.
Здесь вот именно про то, что вот такое выражение, statement,
statement объявления переменной без фигурных скобок, без круглых,
просто скомпилируется.
Ну, почему это так странно написано, да?
Ну, надо радоваться, конечно, что это за вас все продумали,
вот этот концепт, вам не нужно вот это все самому догадываться и выяснять.
Но почему так?
Вот такой код скомпилируется?
Нет, потому что не expression, это statement.
Statement нельзя писать, поэтому вот так странно.
Громче?
Нет, просто в requires expression нельзя писать statement.
Чего у них нету?
Все есть, для int этот концепт пройдет.
Так когда мы по всей штуке можем что-нибудь скачать?
Бюрократия, бюрократия.
Я говорю, не очевидно абсолютно, почему все три нужны,
почему если выкинуть одно из них, то этого не хватает.
Это абсолютно не очевидно, это лютая бюрократия стандарта.
Потому что есть какие-то крайние случаи,
когда кто-то какую-то гадость специально вот так намешивает
и получается плохо.
Вот я предлагаю об этом не думать,
а если хотите, то, опять же, дома в ванной запершись,
читайте стандарт, чтобы никто не видел.
В это надо поверить.
Вот есть хороший концепт, default initializable,
используйте его и никогда сами не пишите его с нуля,
потому что вы до этого не додумаетесь, как я, в принципе,
как любой другой человек нормальный.
Да.
Почему вот это странное выражение с new дает нам то, что tt – это well-formed?
Вопрос отклоняется.
Я один раз в этом разобрался.
Мы знаем, что tt буквально называет конструкцию по адресу.
Да, а у нас адрес не ttr.
По адресу?
Это placement new на какой-то адрес любой,
который нам подойдет, потому что вот так надо.
Я не знаю, что более читаемым было бы просто написать функцию,
где происходит...
Тут нет, вызов функции, это всегда скомпилируется.
У тебя функции здесь вызываться не будет.
А, то есть тут...
Да.
Да, смотри, если ты здесь вызов функции напишешь,
то у тебя проверят, скомпилируется ли отрывок кода, вызывающий функцию.
Да, он скомпилируется.
А саму-то функцию вызывать никто не будет?
А что за well-formed?
Это такой бюрократический термин, скомпилируется.
То есть умный способ сказать, так писать можно.
Вот, ну то есть это нельзя, поэтому вот так вот кружимся,
в итоге мораль такая, вот у нас три штуки требуется,
посмотрели, забили.
Move constructable.
Ну, тоже не сильно плохо, да?
То есть constructable.from сам себя,
и видимо там в этом constructable.from
зашита как бы инициализация outer-value, на самом деле,
но мы этого не заметили, ну ладно.
И convertible.to в обратную сторону.
Ну, в принципе, можно поверить, что все нормально.
Надеюсь, да.
Что я хотел сказать? Ничего не хотел, неважно.
Импликация работает, все хорошо, требования.
Тут, внезапно, есть дополнительные требования на move constructable.
Семантические, которые я анонсировал изначально.
А требования следующие, давайте попробуем в них чуть-чуть разобраться.
Значит, нам дано T, тип объекта.
Что это значит?
Не void, не указатель на функцию, а что-то нормальное.
Не базовый тип, наверное, тоже, int, float.
Их можно, нет, они тоже считаются объектами.
Не объект, это void, не объект, это указатель на функцию.
Все остальные объекты.
Rv – это некоторое rvalue типа T.
А u2 – это...
Некоторый другой объект, не тот, на который ссылается rv,
но равный rv.
Да? То есть, setting.
U2 – это объект, объект.
А rv – это expression, rvalue.
rvalue ссылается на что-то, равное u2, но не то же самое.
Требуется, чтобы после объявления tu равно rv,
u было равно u2.
То есть, объект, инициализированный с помощью rvalue,
равного какому-то объекту u2, в свою очередь, тоже станет равным u2.
Ну вот, заметьте, про вопрос с equality preservation and stability,
в концепте...
В концепте синтетических требованиях
там вообще равенства, по-моему, не было приравнивания.
Либо там было оно зашито в convertible tu,
с оговоркой не требуется equality preservation.
Такие места тоже есть.
То есть, требуется везде, кроме оговорок,
где прямо под слышами написано «здесь не требуем».
Скорее всего, там действительно не требуем.
Вот, второе.
Просто временную переменную типа t, если от rv инициализируем,
как функцию послали, тоже равно u2.
И третье, это вот какая-то жесть, что тыры-тыры после вот этих выражений,
если t не const, rv в валидном, но он специфирует состояние.
Сложно переводить бюрократические термины на русский.
Ну, он специфирует это как не…
Как антифальт, только чуть более…
Как вектор после…
Любой, да, как вектор после move.
То есть, тут говорится, что любой тип после move, а он как вектор.
В каком-то состоянии, непонятно каком, но валидном.
Вот.
Теперь мы знаем, что такое правильный класс, который можно move-ать.
И всякий раз, когда вы делаете какой-то класс, который можно move-ать,
вы обязаны все это проверять формально.
Понятное дело, что…
Ты лично инженера проверяете.
Глазками проверяй. Ты что?
Доказательства пиши. Вот у тебя стандарты-таксиомы.
Из них пишешь вывод, доказываете утверждение.
Я бы не указывал, что вы просто пишете, что главная конструкция.
Это вот самая главная конструкция,
в которой я вообще лично не работаю.
Смотри, да, у тебя есть несколько кейсов.
Первый кейс. Ты не удовлетворил синтоксические требования.
Тогда ты точно не move-констракте был, и все нормально.
Кейс второй. Самый ужасный.
Ты удовлетворил синтоксическим требованиям, но нарушил симантические.
Это самый ужасный кейс. Это УБ, но которые никак не диагностируются.
Ну и вряд ли что-то сломает на самом деле.
Но может сломать. Это же УБ. Вдруг.
Ты не move-констракт был, но компилятор не умел.
Да, но компилятор не может понять, что ты не move-констракте был.
Поэтому он ложно-положительно срабатывает.
Типа «да, это move-констракте был».
Но на самом деле нет, потому что вот это вот не пройдено.
Или какой-нибудь quality preservation нарушен где-нибудь, не знаю.
То есть вот такие проблемы могут быть, но по факту не возникают.
Ну русская войска здесь работает вот так.
Так что все хорошо.
Давайте дальше двинемся. Сколько у нас времени осталось?
У нас 5 минут.
5 минут, 5 минут. Это очень плохо.
Давайте торопиться.
Копик констракт был. Что может быть проще?
Чат тоже самое будет, наверное, да?
Ну там просто...
Ну ссылки какие-нибудь добавятся и нормально.
Ну как бы да, но как бы нет.
То есть вот move-констракт был и все комбинации констов и ссылок.
Ну в принципе не так плохо пока что.
Ну и конечно же там опять требования.
А требования опять точно такие же в принципе.
Только вот про valid-button-specify третий пункт убавился, да?
Но осталось два пункта.
Про то, что мы говорим, что после инициализации новой переменной
с помощью v, где теперь это lvalue,
раньше было rvalue, теперь это lvalue,
u будет равно v и v не изменился.
Внимание, какой класс,
который удален был из стандарта c++ в какой-то момент,
не удовлетворяет вот этому пункту,
хотя синтоксически будет моделировать copyable.
Автоптр.
Автоптр. Почему?
Потому что он на самом деле винил птр и он умолился.
Да, он менял v вот в этом выражении.
t равно v, автоптр в этом месте, v менял.
А тут написано v is not modified.
Вот вам пример, собственно,
класса, который синтоксические требования с нура проходят,
а симонтические нет.
Ну и такие классы, они всегда плохие.
Это, кстати, ещё одна такая глубокая философская мысль,
в которую вы можете только поверить.
Если ваш класс нарушает симонтические требования,
то он автоматно плохой.
Плохой класс, выкинуть его,
его неудобно людям будет использовать.
Они не будут ожидать того, что он делает.
В премьере серая я трепелился домом без майка.
Да.
Но он работал неожиданно, и от него люди офигевали.
И это свойство общее для всех таких классов,
которые нарушают симонтические требования.
Обычно это всегда плохой код.
Ну и тут вот Т от В, опять же, точно так же модифици...
Такая инициализация временной переменной, и тыры-пыры.
Ну, очевидный пример, там вот так, вот сяк.
Да, нет, не очевидный.
Где не очевидно?
Видите, С, копик инстрактибл.
А Ц, наоборот.
С не копик констрактибл.
Мы удалили оператор копирования, конструктор копирования.
А Ц с имперсантом уже копируемо.
Потому что ссылку копировать можно.
Опасно, да?
То есть когда какой-то шаблонный код пишете,
нужно здесь вот где-то не забыть в районе вот этого всего
рему в референс какой-то, скорее всего.
Возможно.
Ну и здесь то же самое, да?
То есть ссылка, как бы она спокойно мувается внезапно.
Ну...
Что?
Нет, ссылку нельзя мывать.
Ну, то есть...
Короче, не пихайте ссылки в эти вот концепты морали.
Это значит новую ссылку, но забиндить на ту же самую ссылку.
Ты как бы ее скопировал?
Да, да, как бы вот эти 8 байт ты спокойно муваешь.
Вот это подводный камень.
Будьте осторожны.
Assignable from.
Ну, английский знаем, понятно, что имеется в виду.
Можно написать lhs равно rhs.
Интуитивно.
А по факту...
Ну как, неплохо.
Мы требуем, чтобы lhs был lvalue-ссылкой.
Ну да, к lvalue-ссылкам присваивать нельзя.
К просто типам, скорее всего, тоже.
Нужна lvalue-ссылка.
И компилирует соображение, где мы берем и присваиваем.
Просто типам нельзя присваивать?
Ну как бы да.
Если ты напишешь выражение, у которого тип просто t,
то ему ничего присвоить не получится.
Например, типа инициализируешь переменную и попытаешь ей что-то присваивать.
А там не просто t?
Нет, нет.
Ну, короче, это опять бюрократическая деталь языка.
Всегда, где можно присваивать, считается, что это lvalue-ссылка.
Вот это понятно, понятно.
Same as lhs.
Ну, вам теперь запрещается возвращать из оператора присваивания
что-то, кроме указателя на this.
Ну, вернее, что-то, кроме указателя на такой же тип.
Или ссылки на такой же тип.
Ну, сейчас дальше увидим.
Чего-то не хватает. Можете догадаться, чего не хватает?
Ну, я не могу.
Потому что это просто невозможно.
Это бука.
Это бяка бука, которая вот призвана сейчас всех кокнуть.
Это ее цель в этой жизни.
А что такое common reference?
Давайте смотреть.
Пока посмотрим вот на это.
Assignable from B и A.
Оператор присваивания сделали.
А assignable from проваливается.
Потому что мы не бэкерсан, а бэкерсан.
Что-то такое?
Нет, нет, нет, нет.
Ну, как бы все нормально. Мы пытаемся присвоить к B, A.
Не с констом.
Просто мы неправильно используем этот концепт.
Он не предназначен для использования
с вот такой вот мерзостью, как перегруженные операторы присваивания.
Да и в принципе перегруженные операторы присваивания делать не надо.
Если вы хотите, чтобы B можно было инициализировать от A,
сделайте конструктор.
Не оператор присваивания.
Implicit конструктор.
Или сделайте оператор каста у B.
Знаете про оператора каста?
Да, вот.
Или его сделайте. Вот так делать не надо.
Потому что вы резко нарушите вот эти все требования.
А...
В том, что с точки зрения обывателя ты пишешь код B,
B маленькая равно там что-то типа A.
И он работает, он компилируется из-за оператора присваивания.
А концепт assignable from будет говорить false.
Потому что он не про это.
Он на самом деле проверяет не просто, есть ли там оператор присваивания
и работает ли он, а есть ли адекватное присваивание.
Какое присваивание считается адекватным в этом контексте?
Вот такое считается адекватным.
Когда у нас B наследует A.
То есть A это какой-то интерфейс, может быть.
Тогда к ссылке на A можно присвоить B.
Да? Правда ведь?
Ну в целом да.
Вот это считается адекватным.
Присваивание через имплисит касты интов к лангам
и вот это все тоже считается адекватным.
А вот ваши свои собственные операторы присваивания кастомные
адекватными не считаются.
Это достаточно странно, но пока поверим.
Есть еще куча требований внезапно.
Целая стена на этот assignable from.
В целом говорят, что вернуть вы должны this,
звездочка this обязательно.
Ну тут какие-то про адресов, понятно, что ровно это.
И дальше опять говорят, что в зависимости от rvalue
или lvalue у вас RHS должно произойти либо move,
либо копия.
И типа либо вы там move-нули,
valid non-specified и все нормально, либо ничего не изменилось.
То есть то же самое, что было раньше,
только вот герократия переформулирована
под именно оператор присваивания, а не конструкторы, как там было.
Окей, все-таки что такое common reference width?
Ну это такой простой тип, который говорит,
что должен быть common reference t.
Это простой концепт.
Ну и какой-то convertible to.
То есть должен быть некоторый общий тип ссылки.
Что такое common reference t?
Сейчас, должен быть общий тип ссылки,
к которому и то, и другое конвертируются.
Что такое convertible to?
Фу, что такое common reference t?
Ну то есть ссылка на cpp-reference вы можете открыть и просто сдохнуть.
Я не советую.
Нас спасет Эричи.
Вот он на stacker flow ответил.
Если у нас было бы время, я бы сейчас открыл и вам все зачитал,
и стало бы понятно.
Времени нет, поэтому вот у вас даже те задания.
Откройте и прочитайте, что такое common reference t, вам понравится.
А еще есть вот эта вот ссылка на вот конкретную статью,
где самый правильный пример того, зачем эта сложность была введена.
Зачем, вот если дальше будем смотреть,
ну сейчас, наверное, чуть-чуть досмотрим еще и все.
Половина стандартных концептов, они где-то и доиспользуют common reference with.
Просто он повсюду.
И возникает вопрос, нафига так сложно?
Вот ответ на него есть вот здесь.
Это в 23-е плюсы добавили,
и там вот прям нормальное обоснование, зачем все эти свистопляски были.
Окей.
А вот чел на свадьбе назад еще...
Эрик Нибблер.
Это чувак, который сначала Ranges пилил,
ну совместно с другими людьми, но он достаточно много в Ranges поконтрибутил.
А потом пилил Lunifex и P2300.
Это мужик из NVIDIA.
Теперь это мужик из NVIDIA, был мужик из Фейсбука.
Короче, он и крутой и в конкарнсе, и в метапроге,
и вот крутой мужик, в принципе, много чего хорошего сделал.
Не один, конечно, но, в принципе, да.
Короче, мы к нему еще вернемся, у нас в честь него даже термин будет.
Нибблойды.
Да, ну хватит его ЧСВ тешить,
надеюсь, он этот запись не увидит.
Концепты простые. Вот Swappable.
А вот то, о чем я говорил. Есть Swappable with,
где разные типы и где common reference with должен быть.
И так везде будет.
А еще немножко терминологии, чтобы вы могли читать preference хотя бы.
Вот есть Boolean testable.
Такой концепт, но не концепт.
В стандартной библиотеке его нет.
И тут такое понятие в стандарте есть exposition only.
Типа, мы эту сущность ввели,
в стандарте в библиотеке ее быть не должно,
но нам ей удобно пользоваться, чтобы определить то, что будет дальше.
А сущность говорит, B конвертируется к Bulu,
и можно восклицательный знак писать, и тоже конвертируется к Bulu.
Ага. Тупо. Очень тупо.
Что-то, похожее на Bool, конвертируется в Bool.
Вот убойные концепты.
Equality comparable, equality comparable with.
Мы только первый смотрим, второй, понятно, там common reference.
А это там, где-то участок, где есть,
что нужно правильно делать характер одного равно?
Не-не-не, про это потом будем говорить.
Equality comparable, ну, равенство должно быть и неравенство.
Все просто, да, boolean, testable, все хорошо.
У меня вопрос.
Да.
Получается, у нас возможна ситуация,
когда equality comparable true, а второй нету?
Нет, если ты два разных типа сюда, это два разных типа должны быть.
Этот концепт нужно, чтобы проверить, можно ли одну фигню
сравнивать с другой, когда не разных типов.
А если один одинаковый тип остался?
То это будет то же самое, что вот это.
Несмотря на common reference.
Да, да, common reference для двух одинаковых, тот и возвращает.
Так, самый catharsis, самое убойное.
Могу я вот это вот подвинуть?
О, ушло.
Catharsis, ну, какие-то правила для вот этого equality comparable,
что там можно поменять местами у и т, да, симметричное отношение.
Ну, восклицательный знак можно вынести и будет ровно то, что мы хотели, да?
Нормально, да?
Заметьте, везде здесь пишется каст к булу.
А мы помним, что там boolean testable написано, а не same as bool.
И, то есть, в принципе, у нас оператор сравнивания может возвращать
не bool, а вообще что угодно.
И, например, не важно, может строку вернуть, вполне окей.
Ну, и тут тоже симметрично неравенство.
А вот теперь внимание.
Читаем вот это вот дословно.
Пусть A и B объекты типа T.
T моделирует equality comparable тогда и...
А только если bool от A равно равно B верно, когда A равно B.
Что это значит?
A равно B is true when A is equal to B.
Ну, как бы да, но по-моему, я по этой сноске прошел,
ничего хорошего не увидел там.
Они же везде пишут equal to вместо...
Ну, как бы да, там везде было equal to.
И равно равно, оказывается, определено через equal to.
И вот я ему когда-то сказал, что equal to, это значит оператор равенства.
А тут оказывается, что оператор равенства корректно определен,
только если есть какое-то обстоятельство.
Оператор равенства корректно определен,
только если есть какой-то абстрактный equal to.
А откуда этот equal to берет?
Ну, циклические определения почувствовали?
Хигня какая-то.
Вот тут уже начинается спекуляция,
потому что за два года ведения этого курса
так и не вышло однозначно дать на этот вопрос ответ,
который вот прям бы железно ставил точку.
Текущее мое мнение с прошлого года не поменялось.
Определение слова equal для нашего типа мы уводим руками.
Это наше интуитивное понимание того, что такое равенство для этого типа.
Например, если мы моделируем целые числа, рациональные числа,
то две четверти и одна вторая equal –
это могут быть разные битовые представления в памяти,
но они equal с точки зрения значения нашего типа.
Ага.
И мы хотим, чтобы равенство через этот оператор равно-равно
было полностью согласовано с нашим вот этим вот определением равенства в голове.
Вот они должны быть согласованы.
Вот, понятие значения типа.
Ага, представление.
Если типа мы вектор с вектором сравниваем,
мы должны сравнить бухера, а не показатели?
Да.
Потому что это нормальное, интуитивное представление
о том, что такое равные вектора.
А там он их прописал, да, и получается…
Короче, вот три пункта, они должны быть все согласованы,
что при копировании получается то же самое,
что оператор равенства, если определён,
он как бы согласован с вот этим вот и нормально себя ведёт,
и что интуитивное понимание, что такое значение типа
со всем этим хорошо соотносится.
Если у вас…
рациональные числа, то у них есть представление в памяти.
Оно может быть две четверти, может быть одна вторая.
Представления разные, а значения одинаковые.
Да, вот разница между этими терминами.
Но если вы напишете функцию,
которая во вне позволяет вытащить именно представление,
как два отдельных инта, а не значение,
то вы внезапно наткнётесь на нарушение
equality preservation где-нибудь.
Потому что вы определили equality так, что как бы равные дроби равны,
но вы смогли вычислить ли знаменатель одинаковых дробей,
которые на самом деле разные, и всё нарушилось.
И вот тут нужно быть дико аккуратным
и делать абстракции, которые не текут.
И тогда у вас всё будет хорошо.
Давайте про это всё.
По-моему, это вообще последний слайд.
Я понимаю, устали, надо досмотреть книжка.
Total ordered, опять, помним про импликацию,
всегда надо надстраивать это семейство,
всё больше и больше требований накидывать.
И quality comparable требуем.
Ну и просто вот эти вот меньше, больше, меньше либо равно.
А опять же из MatLogo или OKTCH
помним, что total ordered – это линейный порядок,
он же полный порядок,
и нам нужно, чтобы любой элемент с любым был сравним.
Нам нужно, чтобы ровно одно из трёх было,
меньше, больше и равно, верно.
Типа транзитивность должна быть,
и вот это очевидное требование на то,
что меньше либо равно, как один оператор,
адекватно определён.
Ну и всё, в принципе.
Вот, вот это точно последнее.
Давайте я… Нет, я не смогу посмотреть, точно ли?
Ну, это, судя за свой слайд, все-таки и есть.
Откуда там так много?
Блин, ну мы чуть позже начали.
Давайте… Очень хочу закончить,
потому что это тяжело будет на следующий раз перекидывать.
Семейство из четырёх концептов.
Я ускоряюсь, а вы меньше вопросов задаёте.
Четыре концепта movable, copyable, semi-regular, regular.
Они все в друг друга как бы вложены и нарастают,
и больше требований накладывают.
movable — это, во-первых, объект, void,
и указатели на функции запрещены.
movconstructable, assignable from — это…
Ну, короче, movassignable, считайте, и swapable.
Внезапно отдельно. Он здесь написан для импликации.
Всё понятно, всё просто.
Да, вот тут подробно написано.
Copyable — ну, примерно то же самое.
Во-первых, movable добавился,
а во-вторых, вот тут какие-то консты и опять перестановочки их.
Всё.
Да, и тут assignable, соответственно.
Там было…
copyconstructable — это именно конструктор, а тут присвоение.
Окей, semi-regular — это копируемый,
и можно по умолчанию унициализировать.
И последнее, добавляется равенство.
Regular is a quality comparable.
То есть вот такие семейства, да, ещё…
Ну, это сейчас словами скажу.
Столбцы.
Все эти семейства утверждаются,
что 99,9% случаев ваш тип должен попадать в одно из них.
Или ещё пятое, которое вообще ничего не удовлетворяет.
movable — это всё, что похоже на Unique PTR.
copyable — это всё, что похоже на структурку,
где кто-то написал ссылку.
Да?
То есть, заметьте, копировать можно,
а по умолчанию унициализировать нельзя.
Дальше идём.
Если по умолчанию унициализировать можно,
то это, наверное, просто какая-то структурка,
но сравнить её нельзя.
А если мы regular, то с нами можно делать всё,
и мы ведём себя как любые примитивные типы —
инты, булы и прочее, ну или как Shert PTR.
То есть вот все эти категории, они привычные программисту на C++.
Если вы пишете что-то выбывающееся из этих категорий,
то вас не поймут просто.
И ещё раз напоминая, здесь и конструктор,
и оператор требует mov,
здесь и конструктор копирования,
и оператор присваивания с копированием.
Одно из них, если пишете, то вы не правы.
Да, дальше пачка.
Invokable — это что-то, что можно вызвать как функцию.
Ну и там аргумент, соответственно, надо писать через запятую.
Я думаю, вы такое уже писали.
Regular Invokable — это тот же самый Invokable,
но с equality preservation.
Потому что вообще-то, бывает так,
что вы хотите принять какую-то лямбду-функтор
или ещё что-то в функцию,
которая, в свою очередь, не equality preserving.
Бывает.
Вот для этого есть Invokable, не equality preserving,
а Regular Invokable как бы подразумевает,
что ваша лямбда не меняет никакие глобальные состояния и нормальное.
Проверяется.
Ну он подразумевает, но ничего не проверяет.
Просто для экспозиции.
Да, как бы это для того, чтобы программист проверил.
Predicate — это просто аббревиатура типа что-то,
что принимает T и возвращает буль.
Equivalence Relation — это опять такая аббревиатура,
что-то, что принимает пару T-шек и возвращает буль.
Типа меньше или нет.
Ну и вот этого вообще не будем про это потом.
Вот, всё, пачка выводов.
У нас плюсы вообще делятся на две такие половинки.
Если мы их изучаем, то половинка про технику и половинка про дизайн.
Сейчас я много-много техники набросал в начале,
и в прошлый раз было много техники.
Всякие вот наследования, шаблоны, виртуальные вызовы RTTI,
всё эти фичи синтоксических языка — это всё техника,
которая позволяет вам решать какие-то задачи.
Ну такие мелкие, да, локальные.
А есть отдельный дизайн,
который при решении глобальных и крупных задач.
Если вам пришли и сказали, нужна система, которая делает это,
нужно такую систему раздизайнить,
разбить на подкомпоненты, разбить на подзадачи,
придумать абстракции, с которыми будет удобно работать и сейчас
в рамках этой системы,
и которые помогут вам эволюционировать её в будущем
и не переписывать всё с нуля десять раз.
То есть вот такие вот выделения абстракции, обобщения,
построение архитектуры, это всё про дизайн.
Вот если первому технике я вас легко могу научить
или вы сами можете прочитать цепь референс и всё будет здорово,
то вот этому почти невозможно научиться.
Это такое ремесло.
Нужно это делать десять раз, сто раз, тысяча раз,
и в какой-то момент оно щёлкает.
Поэтому сейчас мы долго и внимательно смотрели
на существующие стандартные концепты.
Из них должны сделать какой-то вывод,
про то, как это вообще дизайнили, как это получилось
и как этот инструмент технических концептов правильно использовать.
То есть всё, что в стандартную библиотеку включено,
считается правильными концептами, пока не доказано обратное.
Когда вы пишете свои, берите с них пример, пожалуйста.
Да, и соответственно, как ответы на все эти вопросы дать,
вы можете только сами по ходу дела научиться,
используя эти инструменты, пиша код,
становляясь сеньорами-помидорами,
по ходу дела как-то оно всё к вам придёт.
Я как-то помочь могу, но не думаю, что сильно.
Есть такая ссылка.
Там немножко написано про то,
как правильно применять инструменты концептов,
а как неправильно.
Мы сегодня уже видели какие-то отрывки оттуда.
Да, и выстрелить себе в ногу здесь очень легко.
Как обычно, будьте аккуратны, берегите себя и своих близких.
И всё.
Всем спасибо, все свободны.
