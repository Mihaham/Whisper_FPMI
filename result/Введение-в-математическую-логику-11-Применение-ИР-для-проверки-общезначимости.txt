Ну что, видимо пора начинать.
Я напомню, что в прошлый раз я рассказал про исчисление
резолюции применительно к булевым формулам, но
основная наша цель это, конечно, проверка общезначимости.
И сегодня я буду объяснять, как применить исчисление
резолюции к проверке общезначимости.
Ну, фактически тоже некоторая формальная система, более
сложно устроенная, чем вот эксиоматическое исчисление
предикатов.
И прежде всего я хочу зафиксировать, какие у нас будут шаги.
Часть из них мы уже сделали.
Итак, вот нас интересует общезначимая ли некоторая
формула.
Мы это уже несколько раз обсуждали, что отрицание
формулы выполнимо тогда и только тогда, не выполнимо.
Тогда и только тогда, когда формула общезначена.
Ну, выполнимость означает, что формула истина в какой-то
модели, на какой-то оценке переменных.
Соответственно, если вдруг отрицание истина, значит,
формула ложна, и тем самым не общезначима.
Ну и наоборот, если отрицание ложно в любой модели, на
любой оценке переменных, значит, сама формула истина.
Тут ничего сложного нет, и это первый шаг, переход
к отрицанию.
Второй шаг по отрицанию построить предваренную
нормальную формулу.
Ну давайте я ее как-нибудь обозначу, не знаю, фиш-трих
пока.
Этот шаг мы как раз уже обсуждали, что такое предваренная
нормальная форма и как строить по произвольной формуле
равносильную предваренную нормальную форму.
Предваренная нормальная форма, я напомню, это
такая формула, где все кванторы стоят вверху дерева
разбора.
То есть, если смотреть на формулу как на слово,
то вначале написаны кванторы, а потом какая-то бескванторная
часть.
И это можно построить, мы это обсуждали как.
Дальше, предваренной нормальной формы нам недостаточно.
Я напомню, что когда мы обсуждали исчисления
резолюций для булевых формул, нам нужен был переход
к НФ, потому что непонятно, что делать с произвольной
формулой.
Здесь тоже фактически нужен переход к НФ, но он даже
будет несколько более сложным.
Он в два шага делается.
Вначале нужно сделать переход к тому, что называется
П1-формуле.
И здесь уже равносильности невозможно достичь.
Давайте я ее как-нибудь в ФИ2 штриха обозначу.
Единственное, что мы можем утверждать, что ФИ-штрих выполнимо,
тогда и только тогда, когда ФИ2-штриха выполнимо.
То есть, цена избавления, П1-формула это формула,
в частном случае КНФ, это формула, у которой все кванторы-кванторы
всеобщности.
Это напоминает КНФ, потому что КНФ это конъюнкция.
Но здесь КНФ мы можем построить равносильную для любой
формулы, вы это знаете, но здесь это уже в принципе
невозможно.
Можно только построить формулу, выполнимость которой
будет равносильна выполнимости исходной формулы.
Как это делается?
Это называется сколемизация.
Как это делается, это еще нужно обсудить.
Вот здесь я обведу кружочком, это шаги, которые понятно
как делать уже, а без кружочков пока те шаги, которые нужно
еще объяснять.
И следующий шаг из, ну или давайте, как я уже начал
писать, по ФИ2 штриха, построить множество универсальных
дизъюнктов.
Что это такое, это я объясню, это частный случай, конечно,
ФИ1 формул, но эту часть ее тоже нужно сделать, она
не очень сложная, я чуть позже ее объясню более
подробно.
Смысл такой, что когда мы получим формулу вот на
этом шаге, пусть даже у нас все кванторы все общности,
но бескванторная часть может быть какой-то произвольной
булевой формулой, и нам нужно еще ее превратить
во что-то удобное для нас, удобное для дальнейшего
применения исчисления резолюции.
И вот дальше построить вывод, давайте как-нибудь
это множество гамма обозначу, вывод противоречия из множества
гамма в исчислении резолюции.
Его нужно формально определить, опять-таки это я позже сделаю.
У нас нужны еще вот эти три шага, которых пока нет.
И ближайшая моя цель как раз эти шаги объяснить.
То есть вот это вот такой план.
Выглядит сложнее, чем исчисление предикатов, хотя там тоже,
как вы помните, ксиомы не такие уж не вполне очевидные.
Здесь все шаги на самом деле достаточно естественные,
мы сейчас их увидим.
Но выглядит сложнее, для классических логиков это менее привычный такой подход.
Плюс его в том, что доказать корректности полноту получившегося,
ну скажем так, системы доказательств я позже объясню.
Ну собственно, я уже говорил про систему доказательств,
тут в общем достаточно понятно, что это она, но подробности я позже объясню.
Так вот доказательства корректности полноты в этом случае намного проще,
чем для исчисления предикатов.
То есть технически исчисление резолюции анализировать проще.
Собственно поэтому оно и важно, ну и всякие его другие достоинства я в прошлый раз рассказывал.
Давайте, значит, двигаться по шагам, начнем со сколемизации.
Ну наша цель, она там зафиксирована,
мы хотим по формуле, значит, мы хотим, чтобы вот эти вот шаги делались эффективно,
чтобы был алгоритм, который по формуле ФИ-1 строит формулу ФИ-2,
а по ФИ-2 строит множество универсальных дизинутов.
А с выводом противоречия, там немножко сложно, но вы видели, как устроен резолютивный вывод,
ну вот поскольку здесь у нас множество будет почти всегда бесконечно,
то там надеяться, что прям алгоритм будет, не приходится, но это мы обсудим позже.
Последнюю часть, она с точки зрения алгоритмической самая проблематичная.
А со сколемизацией особых проблем нет, но нужна лемма, на которой все основано.
Давайте возьмем формулу ФИ, которая имеет вид какие-то кванторы всеобщности и потом квантор
существования. Давайте я для наглядности, для кванторов всеобщности буду использовать буква
X и T, их произвольное количество, а для квантора существования переменную Y.
Ну и какая-то формула, зависящая от этих переменных, как от параметров. То есть это
бескванторная формула, даже не обязательно бескванторная, прошу прощения, это просто какая-то
формула X1, Xn и Y, это просто параметр. Ну вот есть квантор существования, значит в чем проблема
на этом шаге? Дело в том, что неверно, что для любой формулы есть равносильная P1 формула,
вот для любой формулы есть равносильная PNF, но там могут встречаться кванторы всеобщности и
кванторы существования. И вот избавиться от кванторов существования на самом деле невозможно,
я пропущу доказательство этого, это не очень сложное упражнение, но суть в том, что хотя
равносильности мы достичь не можем, но нас интересует, насколько нас интересует проверка
выполнимости, то нам важно, чтобы у полученной формулы, полученная из нашей формулы формула,
была выполнима тогда и только тогда, когда исходная формула выполнима. Ну давайте я напишу,
какую нам формулу нужно построить. Тут мы берем формулу А и делаем в ней подстановку, формулу А
будут входить какие-то, возможно будут входить в принципе, может и не входить конечно, какие-то
свободные вхождения переменной Y, вот каждое свободное вхождение переменной мы должны заменить на
такой терм. f от x1 xn, где f новый функциональный символ. И утверждение такое, что phi выполнимо,
тогда и только тогда, когда psi выполнимо. Тут понятно, что шансов при таком преобразовании
формул получить равносильную формулу нет никаких, у нас изменяется количество параметров под
кванторами, у нас возникает новый функциональный символ, ясно, что придав ему какой-нибудь дурацкий
смысл, мы получим явно неравносильную формулу, но выполнимость сохраняется, а нам только это и нужно.
То есть смысл этой леммы состоит в том, что мы избавляемся от квантора существования путем
замены его на новый функциональный символ. То есть мы убираем квантор существования и используем
новый функциональный символ. Идея конечно очень простая, она восходит, собственно, почему это
называется сколемизация, это был такой логик с Колем, и он заметил очень простую вещь, что
содержательно, что значит такое утверждение, для любого набора x1, xn найдется y такой, что вот что-то
выполняется. С Колем сказал, ну смотрите, это же что означает, что мы можем построить функцию такую,
что если мы поставим значение этой функции вместо y, мы получим истину. Ну что, существует, в принципе,
может быть и много, но если много, мы какой-то выберем один из вариантов. То есть функцию построить
можем. Это вот такое несложное наблюдение содержательное, и в общем, лему доказать не очень
сложно. Сейчас я это сделаю. Но смысл вот тот, который я сказал. Давайте доказывать. Допустим,
ФИ истина. Значит, я напишу, что эта формула замкнутая. Хотя, ну, мне это не понадобится,
а вообще, конечно, эту лему с Колем можно применять и для незамкнутых формул. Но давайте считать
замкнутую. Когда я пишу весь этот план, я предполагаю, что ФИ замкнутая. Вот давайте,
чтобы у нас не было лишних проблем технических. Это по сути ничего не изменит, но просто усложнит
рассуждение, придется оговаривать. Будут переменные, которые выходят свободно. Итак, ФИ истина
в какой-то модели М. Ну, это и означает, что она выполнима. Давайте построим другую модель М штрих.
Такая же, как М, с дополнительным функциональным символом. Вот тот самый Ф, который у нас
возникает в формуле ПСИ. И чтобы это была модель, нам нужно теперь определить, как
интерпретируется этот функциональный символ. Интерпретируется он так. Значит, берем, определяем
интерпретацию на наборе, ну, каком-то. Значит, у меня там М, да, на наборе каких-то элементов из модели.
Как нужно определить? Значит, смотрите, вот та самая идея с Колемо. Мы знаем, что ФИ истина.
Значит, для этих М1, МН существует, ну, какой-то, ну, давайте обуковку, это какую-нибудь напишу. Такое,
что, значит, вот формула А вот, ну, давайте А, как мы обычно записываем в подстановке,
ХИТ равняется МИТ, и У равняется ЭТО. Истина. То есть, для набора М1, МН, формула ФИ истина,
значит, существует какое-то значение для переменной У, которое обозначил ЭТО. Такое,
что при постановке вот этих значений переменных, ну, или при оценке с такими параметрами, других
параметров у этой формулы, нет, мы получаем истину. И вот мы полагаем значение функции
как раз этому самому ЭТО. Опять-таки, то, что я уже говорил неформально, таких значений переменной У
может быть несколько, мы выбираем как-то произвольно. То есть, мы живем в рамках классической
математики, поэтому у нас есть аксиома выбора, мы как-то выбираем для каждого набора М1, МН,
мы выбираем какую-нибудь это из имеющегося списка. Ну, не списка, а множество значений,
которые делают истинами. То есть, мы смотрим на те значения, которые делают истинами вот такую
формулу. Я определил М штрих. Давайте посмотрим, как будет оцениваться формула ПСИ в модели М
штрих. Ну, как она будет оцениваться? Смотрите, у формулы А после такой подставки остается
только n параметров, х1, хn. Возьмем какие-нибудь их значения и будем оценивать формулу А. Что мы
знаем по построению функции Ф? Мы знаем, что Ф принимает такое значение, которое тут обозначено
это, что если во все места, где вот написано значение функции Ф, подставить это, формула станет
истиной. Ну и отлично. Значит, ПСИ будет истиной. Какие бы сюда я значения из модели М не подставил,
эта формула будет истиной. Это я доказал в одну сторону, вот в эту. Но давайте посмотрим в другую
сторону. Допустим, теперь у нас есть модель, ну я постараюсь минимизировать, пусть есть модель М
штрих такая, что формула ПСИ истинна. Как построить модель М? Ну, наверное, вы догадались, что у нас есть
лишний функциональный символ, формуля его нет, значит, надо просто та же самая модель без
функционального символа. Мы его выбрасываем, никак не интерпретируем, получаем М та же самая,
та же без Ф. И почему же тогда, давайте вот это я сотру, это было в одну сторону, теперь нам нужно
в другую сторону. Почему же тогда формула ФИ, мы должны ее сейчас оценивать, вот берем вот такое,
а ну и тут х и то у. Почему такая формула истина? Ну, давайте вспоминать, как мы оцениваем формулы.
Мы должны присвоить значения какие-то переменным, параметрам, x1-m равно m1, xn равно mn. И после этого
получаем формулу, существует y такой, что, давайте я где-нибудь здесь отдельно напишу, существует y такой,
что, а от m1, mn, y. Ну вот это уже какие-то конкретные значения в модели. Я немножко отклонился от своего
стандартного синтаксиса для наглядности. Ну, почему это формула истина? Мы знаем, что истина формула
С. То есть, если в те места, которые отвечают в формуле А, вхождением у, подставить некоторую
функцию Ф, она в модели m' определена. Мы ее, конечно, выбросили, но она же никуда не делась,
она все равно определена. И вот в этом месте, мы, если подставим y, равный F от m1, mn, мы получим,
что это формула истина, потому что она будет совпадать с вот этой частью под первыми
кланторами формулы С. Вот в сущности и все. Я просто более подробно рассказал основную идею,
она очень не сложная, но вот чтобы были видны все технические детали, я пересказал это рассуждение
достаточно подробно. Теперь нужно доказать, возвращаясь к нашему плану, я хочу теперь иметь алгоритм,
который по любой PNF строит вот P1-формулу, выполнимость которой равносильна выполнимости
исходной. Как это делается? Ну, по индукции. Смотрите, у нас есть какая-то формула PNF, то есть
она начинается с набора кванторов. Мы берем префикс вплоть до первого квантора существования,
все остальное мы объявляем вот этой формулой А, применяем лему, то есть убираем этот квантор
существования, кванторы все в общности так и остаются, а вместо вхождения переменной,
отвечающей квантору существования, мы подставляем вот этот свежий функциональный символ от
переменных, которые стоят до этого первого квантора существования. И дальше эту процедуру повторяем.
Мы получили формулу, в которой уже стало на один квантор существования меньше, и выполнимость
которой равносильна выполнимости исходной формулы. Дальше просто продолжаем, пока у нас остаются кванторы
существания. В результате в окончательной формуле будет уже несколько новых функциональных символов.
И то, что это можно сделать алгоритмом, совершенно понятно. Если уж мы построили pnf, то наши
преобразования выглядят очень просто. Нам нужно в формуле А искать свободные вхождения переменной.
Это стандартная вещь. Если есть дерево разбора, то нужно смотреть на листья, отвечающие этой
переменной, помеченной этой переменной. И ровно на такие, что путь из этого листа в корень не
проходит через квантор по этой переменной. И вот в такие места мы должны вставить новый терм,
вместо переменной вставить терм. То есть формула станет немножко глубже. Ну давайте конкретный
пример разберем. Наверное, так будет нагляднее. Сейчас напишу какую-нибудь формулу. Нас интересуют
в основном кванторы, поэтому я саму формулу напишу какого-нибудь самого простого вида.
z. Ну что тут написать? u. Существует t. Ну и просто вот такой вот предикатный символ,
который зависит от всех этих переменных. Я просто хочу проиллюстрировать саму работу этой
процедуры, поэтому мне не очень важно, что там без кванторной части. Что мы должны сделать,
чтобы сколемизировать? Мы должны вот этот квантор существования обработать. Если посмотреть на
лему, у нас возникает проблема. У нас нет кванторов всеобщенности перед этим квантором существования.
Я про этот случай в лемме не сказал, но он более-менее очевиден. Нужно вместо соответствующей
переменной в данном случае x подставить константу. Тут мы используем такую простую идею, что константа
это как бы функция без аргументов, с нулем аргументов. И все эти рассуждения, разумеется,
сохранятся, потому что в доказательстве лему, если представьте, что в этой функции f нет аргумента,
ничего не испортится. Поэтому первым шагом мы подставляем какую-то константу. С это уже символ
константы. Дальше для любого у хорошо, теперь у останется соответственно. Теперь z. Вот тут уже
мы применяем нашу лему. У нас есть для любого у существует z. И по нашей лемме мы должны ввести
новый функциональный символ, в который в качестве аргумента подставить у. Он такая унарная функция,
f это функциональный символ. Дальше для любого у хорошо, кванторы всеобщенности мы приветствуем.
И наконец существует t. Теперь смотрите, мы от этих кванторов существования избавились,
а вот эти кванторы всеобщенности так и остаются. Поэтому теперь мы должны использовать лему в
ситуации, когда перед квантором существования стоят две переменные. И соответственно мы должны
записать функциональный символ уже бинарный, который зависит от y и от u. И кванторы всеобщенности
все выжили. То есть вот мы получаем сколемизацию. Уже остаются только кванторы всеобщенности,
а кванторы существования заменены на константу и на функциональные символы. Вот так работает
процедура сколемизации и она дает нам вот этот вот третий шаг. Теперь уже дальше мы будем
работать с формулой, которая имеет вид p1 формулы. Только кванторы всеобщенности и
какая-то бескванторная часть. Я обозначил фи2 штриха. Ну давайте, пусть будет фи2 штриха.
И тут уже a бескванторная формула. Что мы хотим сделать, чтобы приблизиться максимально
похожим образом получить что-то похожее на knf. Ну кванторы всеобщенности это уже хорошо, это аналог
конъюнции. Но в формуле может вставить все что угодно, какие-то булевые связки. Так вот мы
преобразуем, кванторы всеобщенности мы вообще не трогаем, мы преобразуем a к виду knf от тех же
переменных. И вот это knf, она должна быть как булевая формула равносильно а. Ну мы знаем один
способ это сделать. В прошлый раз я его выписывал. Совершенно knf то, что называется, мы должны написать
конъюнцию по всем нулям функции, отвечающей булевой формулы и дальше дизюнция обратных там литералов,
противоположных. Иногда бывает удобно записать иначе, сейчас мы соответствующий пример разберем.
Но что у нас в результате получится? Получится какая-то конъюнция. От чего? От формул вида,
ну давайте пока что ли. А тут будет стоять атомарная формула, ну или ее отрицание. Я
формально напишу все параметры. То есть значит смотрите, у нас есть формула. Она как мы помним
составлена как? Булевые связки, раз она бескванторная, булевые связки, а потом в какой-то момент
атомарные формулы. Вот knf мы можем построить только по той части, которая относится к булевым
связкам. Когда мы доходим до атомарных формул, мы на них теперь должны смотреть как булевые
переменные. Это очень важная идея для всего дальнейшего, что я буду рассказывать. Мы теперь
атомарные формулы воспринимаем как сложные имена булевых переменных. Ну кто нам мешает?
В программировании придают имена, там переменным какие угодно, там неманические. Вот у нас
атомарные формулы будут именами булевых переменных. И вот я это записал, и уже эту
булевую формулу, когда я превращу в knf, у меня получится кайюнкция, дизюнкция вот этого вот.
Давайте я вот эту вот формулу вот такого вида и буду называть дизюнктом. Это не совсем точно,
потому что дизюнктом вообще мы называли булевую формулу, которая является дизюнкцией литералов,
то есть переменных или отрицаний. А теперь я дизюнктом, ну для краткости, буду называть
формулу первого порядка, которая является дизюнкцией атомарных формул или отрицания
атомарных формул. То есть в сущности, вот тут видно вот то, что я сказал, мы просто меняем
всюду переменные булевые на атомарные формулы. Вот получили такую формулу, но это еще не все,
что мы можем сделать. Давайте вспомним, давайте вспомним, что квантор всеобщенности с кайюнкцией
коммутирует. То есть верно следующее, что если у нас есть формула для любого xA и B, она
равносильна формуле для любого xA и для любого xB. Мы эту равносильность проверяли. Ну ее не сложно,
можно и из оценок, давайте на всякий случай поставлю скобки, хотя это не очень обязательно.
Из оценок это понятно, потому что когда такая формула истина, когда при любой оценке перименная x,
вот эта формула истинна. Но конъюнкция истина, когда оба члена истинны. Значит при любой оценке
xA должна быть истинно и B. Ну и наоборот, если A истинна при любой оценке xY и B истинна,
при любой оценке x, ну тогда естественно�а конъюнкция uh B правдой. То есть это не сложное
преобразование и мы получаем формулу вида вот эти вот конъюнции теперь у нас
переезжают вверх ну а здесь будет записаны какие-то переменные и давайте
вот так вот напишу джт вот этот вот дизюнкт я его обозначу джт для упрощения записи и вот
такая формула дизюнкт в нашем смысле то есть дизюнкция тамарных формул и литералов на
которую навешаны кванторы всеобщности по всем переменам она как раз и называется универсальный
дизюнкт ну и мы видим что вот смотрите у нас была одна формула а теперь появилось целое
множество универсальных дизюнктов гамма которая как раз вот состоит из давайте джт штрих что ли
напишу чтобы не переписывать формулу ну и тут у нас g меняется там скажем от единицы до какого-то
получаем множество уже множество формул гамма это множество универсальных дизюнктов то есть мы
получаем множество формул каждой из которых является универсальным дизюнктом вообще говоря
множество по формуле получается конечная потому что смотрите когда мы делаем вот это преобразование
мы берем булевую часть нашей формулы, какая-то булева формула, она КНФ приводится к какой-то
конечной, поэтому количество дизъюнков в этой КНФ конечна, значит множество вот этих универсальных
дизъюнков тоже у нас будет конечным. Тут я написал все переменные, которые были в исходной формуле,
конечно, если какой-то дизъюнк не содержит переменной, скажем, x1, то вы этот клантор
всеобщности по x1 можете смело опустить. Если вы вешаете на формулу квантор по переменной,
которая в нее не входит, то просто ничего не меняется, получаете равносильную форму.
Поэтому такая запись сделана для единобразия, для удобства записи, но в реальной жизни можно
выбрасывать лишние кванторы, это просто ни на что не влияет. И это вот мы сделали четвертый шаг,
давайте его проиллюстрируем на каком-нибудь примере. Давайте возьмем какую-нибудь не сложную формулу,
про которую мы знаем, что она общезначимая, и попробуем применить все эти рассуждения.
Ну, вот эта формула общезначимая, я надеюсь, что вы это сообразили, уже глядя на формулу,
но если нет, мы сейчас будем доказывать это. Значит, что первым шагом мы должны сделать? Мы
должны записать отрицание этой формулы. Ну, это легкий шаг. Вот записал отрицание формулы.
Ну, что мы должны, это первый шаг, я его просто буду нумировать шаги. Что мы должны сделать на
втором шаге? Мы должны построить pnf. Ну, это мы обсуждали, как делается, значит, тут нам нужно
вот этот квантор перенести через отрицание. Получится квантор. Да, ну первым делом нам нужно,
давайте я все-таки аккуратнее напишу, нам нужно разделить переменные. Решить,
какую переменную мы переименовываем. Ну, давайте вот эту. А теперь уже выносим кванторой. Ну вот,
как мы это делали, значит, это равносильно тому, что для любого x тут отрицание, для любого y от
y. Это я перенес квантор существования через отрицание, он изменился, стал квантором
всеобщенности. Теперь вот этот квантор всеобщенности мне нужно вынести через импликацию перенести,
значит, это он останется квантором всеобщенности, как мы знаем, потому что квантор стоит в заключении
импликации. Вот получаем такую формулу. Ну и что последнее сделать? Вот она последняя неприятная
связка, связка квантор. Нужно перенести этот квантор через отрицание. Эта формула еще равносильно
отрицанию исходной формулы. Это вот мы пока шаг 2 сделали. Теперь шаг 3. Что? Y. А, здесь Y. Я внимательно
следил, чтобы написать Y в бескванторной части, а про кванторы как-то вот что рука написала, то и
написала. Y, совершенно верно. Иначе бы фокус не удался. Теперь мы должны применить сколемизацию.
Сколемизация это тоже такое простое действие. Вот смотрите, у нас есть формула для любого X,
существует Y. От квантора существования надо избавиться, надо заменить вхождение Y на
функциональный символ от всех переменных, которые стоят под кванторами всеобщенности перед этим
квантором существования. Ну, значит, получим вот такую P1 формулу для любого X. Отрицание A от X,
а тут нужно написать A уже от F от X. Вот мы Y, отвечающий квантору существования, заменяем на F
от X. F, новый функциональный символ, у нас вообще не было функциональных символов в формуле,
поэтому мы так делаем. Это третий шаг. Ну и теперь четвертый шаг, вот который я только что описывал. Мы
должны, прежде всего, написать KNF равносильную вот этой бескванторной части. Ну, тут можно писать
совершенную KNF, она будет длиннее, а можно вспомнить как записывается отрицание импликации. Это,
конечно же, A от X и отрицание заключения. Когда истина отрицания импликации, ну когда сама
импликация ложна, она ложна, когда посылка истина, а заключение ложное. И это уже KNF. Так,
мы привыкли, что KNF это что-то такое с переменными только, но я напомню, у нас атомарные формулы
теперь играют роль переменных. Вот A от X это у нас одна теперь переменная, а A от F от X это
вторая переменная. Ну и получается очень выраженная KNF, каждый дизюнк содержит только один литерал,
но нам только лучше. Формула-то простая, в общем, неудивительно, что она к чему-то простому свелась.
И теперь, значит, вот это вот множество гамма, оно будет состоять из чего? У нас квантор всеобщенности
нужно подействовать и на один дизюнк, и на второй дизюнк. Вот мы получаем множество универсальных
дизюнктов. Ну и теперь надо строить, как я говорил, вывод противоречия из этих дизюнктов,
но вот это надо объяснять. Значит, осталось не очень много времени до перерыва, я содержательно
пока ничего говорить не буду, так общую идею скажу, которую я буду реализовывать.
Значит, общая идея как раз уже, наверное, даже и понятна. У нас мы хотим использовать исчисление
резолюций, то есть мы должны каким-то формулам применять резолюции, и это будут как раз дизюнкты
вот такого вида формулы. То есть теперь у нас вместо переменных атомарные формулы. Но что это за
атомарные формулы, как они будут браться? А браться они будут вот из этих универсальных дизюнктов,
мы вместо переменных, на которые навешаны кванторы всеобщенности, будем подставлять любые термы.
Ну, строго говоря, достаточно подставлять термы в сигнатуре, которая у нас получилась,
так, можно взять какой-нибудь еще функциональный символ и подставить соответствующие термы,
но от этого нам пользы не будет. Это можно будет сообразить, а термы в той сигнатуре,
которая получилась, можно подставлять любые. То есть в частности, ну вот сейчас как раз звонок
на перерыв, после перерыва продолжу. В частности, вот тут написано a от x, это означает, что мы
можем получить и a от f от x, и a от f от f от x, то есть, в общем, вместо x можем поставить любой терм.
Это снова получится атомарная формула, и вот ее, ну, точнее дизюнк соответствующий, тут у нас
выраженный дизюнк, соответствующий дизюнк мы можем использовать в результативном выводе.
Ну, давайте, давайте я сейчас пока остановлюсь, делаем перерыв и после перерыва продолжу. Тут
лучше как раз, это важная часть, которую лучше не смешивать. Итак, как будет устроено
исчисление резолюции? У нас будет некоторое множество гамма, множество универсальных дизюнктов.
Я сразу определю по нему множество уже просто дизюнктов,
которое получается так, вот какой-то дизюнк D принадлежит этому множеству, это означает,
что D получается подстановкой термов в какой-то D штрих из вот нашего множества универсальных
дизюнктов. Ну, давайте я какой-нибудь пример приведу. Вот пусть у нас будет, ну,
это как-то совсем просто, давайте пусть уже все-таки будет какой-нибудь настоящий дизюнк. Вот,
ну вот смотрите, у нас дизюнкты, дизюнкты уже двух атомарных формул, точнее атомарные формулы
и отрицания, и тут уже термы использованы. Это вот пусть будет множество гамма. Теперь что
получается подстановками? Я беру бескванторную часть универсального дизюнкта и каждую
переменную заменяю на какой-нибудь терм. Я все, естественно, выписать не смогу термов,
бесконечно много, но я выпишу что? Я выпишу, например, то, что может получаться. Может
получиться, например, так. Что это за подстановка сделана? Ну, я каждую переменную заменил на ее
саму. Переменная это тоже терм, поэтому вместо переменной мы можем поставить ее саму, ну,
получим вот дизюнк. Мы можем сделать другую подстановку, например, вместо х подставить z,
ну, а вместо у тоже подставить z. Получим что-то такое z, z или не а, z, f от z. Каждую
переменную я заменяю на свой терм. А можно сделать еще какую-нибудь более хитрую подстановку,
например, вместо x подставить f от y, а вместо y подставить f от z. Это тоже термы, я их могу
подставить, значит, что у меня тогда получится? У меня получится такой дизюнкт, а вместо x я
подставляю f от y, а вместо y подставляю f от z. Это вот будет первой член дизюнкции,
а второй член дизюнкции. Вместо x я подставляю f от y, а вместо y я должен подставить f от z,
но там уже один f был, поэтому у нас получится что-то вот такое. То есть, видите, у нас после
подстановки дизюнкт может оказаться гораздо более сложным. Любой терм, который мы можем
построить в нашей сигнатуре, можем использовать и подставлять его. Получаем множество дизюнктов
всеми такими подстановками. Заметьте, что тут, если есть хотя бы один функциональный символ,
термов бесконечно много, и это множество, даже если мы стартуем с одного универсального дизюнта,
ну или из конечного множества, мы получим бесконечное количество просто дизюнтов,
не универсальных. То есть у нас сразу вот это множество становится большим. Но это нас не
смущает. Я напомню, что мы обсуждали исчисления резолюции и выводы из бесконечного количества
дизюнктов. Здесь именно такая ситуация и будет. Собственно, резолютивный вывод
это вывод из вот этого множества дизюнктов D г в исчисление резолюций. Только тут надо опять
таки помнить, что атомарные формулы это у нас имена переменных. То есть мы должны либо,
то есть если вот давайте я напишу какой-нибудь резолютивный вывод, значит D i t или это
подстановка там в какой-то D' i t, подстановка вместо переменных там X j t, каких-то термов
тожитых. То есть это возможно. У нас D г содержит все такие подстановки. То есть я просто взял
какой-то из D г дизюнкта. Либо у нас есть дизюнкт, который имеет вид какая-то атомарная формула A,
или что-то там еще. Есть дизюнкт вида отрицания той же самой атомарной формулы и какой-то другой
дизюнкт. И мы тогда можем вывести какой дизюнкт, вот такой D i t или вот такое D j t с двумя волнами.
То есть это я по сути дела повторил определение дизюнктивного вывода, резолютивного вывода,
прошу прощения. Либо мы используем данный нам дизюнкт, либо мы применяем резолюцию к тому,
что уже мы ставили вывод. Ну и как обычно, мы говорим, что если у нас есть вывод
пустого дизюнкта, это называется опровержение гамма. То есть опровержение множества универсальных
дизюнктов является вывод высчисления резолюции пустого дизюнкта. Это вот как раз последний шаг,
который у меня написан. Ну давайте вот в этом примере, прежде чем что-то доказывать, чтобы
стало яснее, что происходит, давайте этот шаг сделаем. Вот у нас есть такое множество универсальных
дизюнктов, давайте построим вывод. Значит, когда вы записываете вывод руками, удобно мыслить так,
вот это множество d гамма, оно бесконечно, вы его не можете сразу выписать. Поэтому можно считать,
что это у нас такой шаг. Обоснование одного из дизюнктов в выводе состоит в том, что он
получается подстановкой. Вот давайте возьмем вот этот дизюнкт, поставим вместо x, f от x. Давайте
этот я как-нибудь 1 обозначу, этот 2 обозначу. Это значит 1 и мы вместо x подставляем f от x. То
есть это вот получается такой дизюнкт, совершенно корректная запись, вот это обоснование первого
типа. Теперь возьмем и сюда сделаем тождественную подстановку. Вот у нас уже появились в выводе два
дизюнкта. Я напомню, что атомарная формула это имя переменной, то есть у нас есть переменная и
есть отрицание переменной. Но отлично, значит мы можем что сделать? Можем применить правила
резолюции, вывести пустой дизюнкт. И вот последнее, что нам осталось доказать, что к чему мы пришли.
Формула вообще значима, если вот построенное таким образом множество универсальных дизюнктов не
совместно. Ну не совместно, значит соответствующая формула невыполнима и значит и отрицание исходное
формула невыполнима. Так вот нам теперь нужно доказать, что если множество универсальных дизюнктов
не совместно, то опровержение существует. Мы можем построить резолютивный ввод, который дает
опровержение. И наоборот, если оно совместно, то этого мы сделать не можем. То есть как обычно,
полнота и корректность. Вот давайте это доказывать. Так, мне нужна доска. Наверное,
я пример сотру, ну пример он уже есть, пример больше из него не выжмешь, а определение резолютивного
вывода пусть пока будет. Я его слишком размашисто написал, но ничего. То есть я фактически хочу
доказывать теперь такую теорему. Да, вот тут я напомню, что у меня синтоксический вывод был
еще в вычислении предикатов, а сейчас мы говорим о выводе в вычислении резолюции, поэтому я
буковку R добавляю. Так вот, возможность построить опровержение равносильно несовместности множества
универсальных дизъюнктов. Но несовместность, это мы помним, это семантически следует из-за ложь,
потому что если бы они были совместны, то ложь никак бы не получилась семантическим следствием.
Ну давайте доказывать. Значит проще, как всегда, доказывать корректность. Если что-то выводится,
то... ну нет, корректность означает следующее, что если семантический ложь не получается,
если это множество совместно универсальных дизъюнктов, то и вывести в вычислении резолюции мы тоже не
сможем. Ну да, если взять контрапозицию, это будет означать отключение в эту сторону. Все,
что выводится, все из чего выводится противоречие, все несовместно. Ну давайте доказывать. Значит,
у нас в посылке сказано, что множество гамма совместно. Это значит, что существует модель такая,
что все дизъюнкты из гамма истины. Ну я хочу теперь доказать, что тогда, если у меня есть
резолютивный вывод, это вот резолютивный вывод, я хочу доказать, что все дизъюнкты в этом выводе
истины в М. Ну давайте смотреть. Как обычно, база, и это вот этот вот случай, подстановки,
ну и он может встречаться и дальше. Допустим, мы включаем в наш вывод формулу, которая вот
получается подстановкой в бескванторную часть какого-то универсального дизъюнкта. Мы знаем,
что в модели М этот универсальный дизъюнкт истинный. Но тогда, если вы подставите что-то в качестве
значений и переменных, вы снова получите истину. Тут обратите внимание, я долго вас учил правильно
писать аксиому специализации. Когда у нас была формула для любого XA, и мы подставляли вместо
X терм, я говорил, вот не любой терм можно подставлять, и какой он пример приводил. Там существенно, что в
примере возникал квантор существования. Если все кванторы всеобщности, то никакой проблемы в этой
подстановке не возникает, потому что истина это утверждение при любых возможных значениях X1,
Xn. Поэтому, если вы поставите какие-то термы, какие бы они значения не приняли, они все равно
должны получиться истинными. Поэтому в этом случае истина. Ну а здесь это уже обычная резолюция.
Представьте, что у вас уже встретились в резолютивном выводе какие-то два дизъюнкта,
и по предположению индукции они истинны в этой модели. То, что мы построили с помощью правила
резолюции, обязано быть истинным, потому что тут уже просто преобразование на булевом уровне. Мы
никакие кванторы не преобразуем. Если это истинно, значит обязательно это истинно. Ну вот это шах
индукции, то есть это теорема корректности. С полнотой чуть хитрее. Ну не сказать, что сверх,
но посложнее. Сейчас будет, я подумаю, по-моему, это новый для вас прием. И по первому разу он
выглядит немножко шокирующе. Я заранее предупреждаю. Тут в логике так бывает, что возникают некоторые
вещи, технически очень простые, проще, но остального, но они настолько необычные,
что нужно заранее настроиться. Теперь я хочу доказывать полноту. Полнота это в обратную сторону,
ну и мне опять-таки удобнее доказывать, что если из гамма не выводится пустой дезъюнкт, то гамма
совместна. То есть я доказываю, заметьте, как я вам обещал, обсуждая исчисления в высказывании,
что непротиворечивость равносильна совместности это базовый для логики факт. Удобно пересказывать
для самых разных формальных систем, удобно пересказывать утверждение об их адекватности именно
в таком виде, что непротиворечивость равносильна совместности. Вот опять у нас есть непротиворечивость,
мы хотим доказать совместность. Ну здесь уже кажется все сложнее, потому что, смотрите,
тут-то все было понятно, ну просто у нас сильное предположение, что есть модель, а тут нам надо
модель построить. Из чего нам ее строить? У нас есть какие-то дезъюнкты универсальные, там что-то
написано. Модель-то откуда брать? Сейчас вы увидите, это странное немножко действие, но прежде чем его
делать, давайте заметим следующее, что вот это равносильно тому, что из множества дезъюнктов,
вот я уже стер, к сожалению, я напомню, что для множества универсальных дезъюнков я строю
обычное множество дезъюнков, делая все возможные подстановки вместо переменных универсальных
дезъюнков, в подстановке произвольных термов. И это вполне очевидно, что если мы из множества
универсальных дезъюнков не можем вывести пустой дезъюнк, значит из этого множества дезъюнков мы
тоже не можем вывести пустой дезъюнк. Но потому что у нас все выводы построены так, что мы в начале
из множества универсальных дезъюнков получаем какие-то дезъюнкты из D гамма и из них выводим.
То есть это по сути дела одно и то же утверждение. Но что это значит? Смотрите, тут важно, что мы
ограничивали себя в количестве переменных. Я напомню, что когда я определял формулы первого
порядка, я сказал, что переменных счетное количество. Значит, у нас есть счетное множество дезъюнков,
ну и счетное множество атомарных формул, которые у них входит. Эти формулы мы можем как-то
перенумеровать. И после этого мы можем запустить процедуру обычного вывода в исчислении резолюций.
То есть вот для каждой атомарной формулы, ну давайте как-нибудь F, да, это атомарная формула,
мы ей сопоставляем, ну давайте я как-нибудь переменную назову X индексом F, булевопеременная.
Тогда вот смотрите, вот наше определение показывает, что после такой мысленной замены у нас вывод в
исчислении резолюций для универсальных дезъюнков будет тем же самым, что вывод в обычном исчислении
резолюций булевым для вот соответствующих булевых переменных. Я еще раз вот эту идею
подчеркиваю, она действительно очень важна, нам нужно смотреть на атомарные формулы как на
имена булевых переменных. Тут удобнее прям это явно выписать. И значит из этих булевых
переменных мы не можем вывести пустой дезъюнк. Мы в прошлый раз доказали, что это означает,
что соответствующие множество дезъюнков совместно. То есть у нас есть набор значений
переменных. Давайте я для атомарной формулы f обозначу это соответствующее значение альфа f.
Такое, что все d из вот d гамма при наборе альфа истины. Это полнота обычного исчисления
резолюции булева, мы в прошлый раз ее доказывали. Помните, там я строил специальным образом этот
выполняющий набор. Ну и сразу оговорился, что если в переменных бесконечно много, это тоже не
страшно, там все сработает. Существенно, что счетно, потому что если бы не счетно, пришлось бы
объяснять паразоносфенитную индукцию. На самом деле там тоже конечно все сработает, а может быть не
все, кстати, я не проверял. Но у нас множество счетно. Мы так считаем, что не счетное множество
переменных нам не нужно. Логики иногда рассматривают и не счетное множество переменных, но мы считаем,
что это чересчур. Значит, у нас есть вот эти вот буковки. И я напомню, что нам сейчас нужно
доказывать, что существует модель, на которой все дизюнкты из гамма истины. Вот мы эти
булевые значения будем в этой модели использовать. Теперь, значит, модель. Множество, носитель модели.
Термы в сигнатуре. Ну, я напишу в сигнатуре гамма. То есть у нас вот есть какое-то количество
универсальных дизюнктов. Там используются какие-то функциональные символы, константы. А там
предикатные символы. Вот мы всю эту сигнатуру используем, записываем. Ну, извините, носитель
это именно термы, то есть без предикатных символов. Именно термы, то есть функциональные символы. И вот
это то место, про которое я говорил. Смотрите, мы не знаем, что все эти формулы обозначают. Мы не
можем содержать на них и рассуждать. Мы начинаем рассуждать формально, но еще бы нам построить
множество. Но у нас есть подходящий набор, есть термы. Как на этих термах интерпретируются
функциональные символы? Вот это вот какие-то термы, то есть элементы нашей модели. И мы хотим применить
функциональный символ. Но у кого идея, как можно применить функциональный символ к термам? Что?
Не слышу громче. Ну, не тождественным, а скорее тавтологическим. Мы считаем,
просто по определению, что это вот такой терм. И смотрите, значением этой функции должен быть
элемент носителя, то есть еще какой-то терм. Ну, у нас есть терм, который описывает применение символа f.
Вот мы его и объявим значением. Этот трюк, кстати, в программировании на языках, вот такой
логическом программировании, он постоянно используется. И на самом деле иногда вызывает
трудности для понимания, потому что мне всегда все это аккуратно прописывается. Я вот стараюсь
как-то квадратные скобочки ставить, еще что-то. Бывают тексты, в которых ровно это и говорится,
но объясняется так, что не сразу понятно, о чем идет речь. Так что это надо идею помнить,
она может всплыть в каком-то неожиданном контексте. Ну, нам нужно определить функцию. У нас
множество носителей модели – это термы. Вот есть символ f. Как определить функцию? Нужно написать
какой-то терм, отвечающий термам t1, tn и функции f. Но есть совершенно естественный кандидат. Терм,
который состоит в применении функционального символа f к этим термам t. Ну, непонятно,
что еще можно написать. Тут, как часто бывает, если условия очень слабые, то шаги почти что
вынужденные. Ничего другого в голову не придет, потому что у нас ничего не сказано. Хорошо,
но это еще не все. Теперь нам нужно определить значение предикатных символов. Вот берем
нам нужно в модели определить. Вот есть какой-то предикатный символ, в который подставлены термы.
Ну, это атомарная формула. Как определить значение атомарной формулы? Это истина или ложь? А вот тут
мы используем построенные вот эти вот булевые значения на предыдущем шаге. Ведь это же получается
атомарная формула. Для каждой атомарной формулы мы вычисли булевое значение, обладающее таким
свойством, что все дезюнкты из нашего множества, которые получаются из универсальных дезюнктов
подстановками, истины при соответствующем значении. Вот мы именно так и присваиваем,
так и определяем предикаты. То есть присваиваем истину или ложь в зависимости от булева значения,
которая у нас получилась. Ну вот смотрите, получилась модель. Все, мы уже все определили. Нам
нужно было проинтерпретировать предикатные символы и функциональные. Функциональные вот таким
тавтологическим образом, а предикатные, используя то, что мы знаем из полноты обычного булевого
исчисления резолюции. У нас возникает набор значений для всех атомарных формул, вот мы их и используем.
Почему эта модель? Теперь утверждение. В этой модели все формулы из гамма истины. Ну формулы
из гамма, это я так сказал, сильно. Это универсальный дезюнкты. Значит, каждая формула, вот если у нас есть
формула из гамма, это на самом деле что? Это вот такая формула для любого x, для любого xn. И дальше
дезюнкты. Куда входят эти переменные? То есть D уже принадлежит вот... Теперь смотрите, я хочу
оценивать эту формулу в модели. Что это означает? Я должен вместо переменных подставить термы. Смотрим
на определение модели. Элементы модели это термы. Значит, я беру формулу, подставляю вместо
x, ну какие-то термы. Что я получаю? Я получаю D, в который вместо x подставлены какие-то термы. Но
это дезюнкт, который принадлежит вот этому самому множеству дезюнктов D гамма. Мы так его и строили.
Брали дезюнкты универсальные, бискванторную часть универсальная, и подставляли вместо переменных
термы. И что мы знаем? Мы знаем, что при вот таких значениях атомарных формул, как мы задали,
все дезюнкты из D гамма истины. Значит, и этот истинный. Ну и поскольку я подставлял произвольные
термы, то это и означает, что истина D штрих. Потому что, какие бы я термы не подставил,
я получу дезюнкты из множества D гамма, и выбор булевых значений гарантирует нам,
что соответствующий дезюнкт будет истинным. Все. Мы доказали, что в этой модели все универсальные
дезюнкты из множества D гамма истины. То есть, это множество D гамма совместно, у нее есть модель.
Более того, для будущего это будет полезно. Сегодня я уже, наверное, это не успею сказать,
я только начну разговор об этом, а закончить его придется в следующий раз. Более того, обратите
внимание, что мы доказали чуть больше. Мы доказали, что существует счетная модель.
Если множество универсальных дезюнктов совместно, для него существует счетная модель. Вот мы запускаем
все это рассуждение. Что является носителем нашей модели? Носителем являются термы. А сколько у
нас термов? У нас счетное количество переменных. Ну пусть даже счетное количество функциональных
символов. Понятно, что слов, которые мы можем построить в счетном алфавите, их счетное количество.
А наши термы это под множество таких слов. То есть, под множество счетного множества счетно. Значит,
мы построили счетную модель для любого множества гамма. Почему я так педалирую? Да, давайте закроем,
как в последнее время принято говорить, гештальт. Это не совсем точно. Мы план завершили. Мы объяснили,
как все устроено с точки зрения нашей схемы построения общезначимых формул. Давайте,
я немножко отвлекусь от счетных моделей. Мы про это еще поговорим. Я сейчас хотел бы вернуться
сюда и объяснить то, что я говорил в начале. Что вот этот план, он дает нам систему доказательств.
Я напомню, что такое система доказательств. В данном случае я просто ее расшифрую.
Значит так, система доказательств – это алгоритм, который по двум аргументам f и p дает 1 или 0. То есть,
он проверяет, является ли второй аргумент p доказательством общезначимости формулы f. И если
f общезначима, то тогда существует такое p, что система доказательств принимает это p в качестве
доказательства формулы f. А если f не общезначима, то для любого p система доказательств выдаст 0.
На этом можно смотреть так. Система доказательств – это преподаватель. Он, конечно, умственно
ограниченный, это просто алгоритм. А доказательства, ну, вопрос, который студенту задается, это f,
а p – это то, что придумывает хитроумный студент. Студент, конечно, хочет дать ответ на вопрос,
что преподаватель принял. Так вот, система доказательств устроена так, если преподаватель
правильный, что если ответ на вопрос – да, формула общезначима, то студент сумеет преподавателя
убедить. Он придумает аргумент, он хитроумный, он придумает этот аргумент. А если формула не
общезначима, то тут уж, что б студент не придумывал, преподаватель отобьется. Он скажет – нет,
эту формулу. Эту доказательству я не принимаю. И давайте посмотрим, что я в сущности определил
систему доказательств. Что я не проверял пока. Я не проверял эффективность этого алгоритма.
Когда я говорил про систему доказательств, я еще говорил, что алгоритм эффективен. А это правда.
Давайте это пропустим. То есть, на самом деле, давайте проверим, что работает алгоритм. Для
дальнейшего несущественно, что есть хоть какой-то алгоритм,ą необязательно эффективный. Ну,
Построить отрицание. Есть алгоритмы, если вы построили дерево разбора, все наши процедуры
начинаются с того, что мы для формулы строим дерево разбора. То есть вообще формула это дерево,
конечно, это правильное понимание формулы, что это дерево. И как построить дерево, отвечающее отрицанию
формулу? Надо новый корень завести, поставить отрицание и подвесить все остальное как потомок
этого корня, то есть никаких проблем. Теперь надо построить pnf, но тут дело хитрое, но мы это обсуждали.
Нам нужно вначале разделить переменные, это выполняется алгоритмически, потом к формуле с
разделенными переменами применять вот эти вот общезначимые эквивалентности, которые переносят
кванторы через связки, но тем не менее это алгоритм, мы это обсуждали. Теперь сколемизация. Ну,
со сколемизацией никаких проблем нет, вы видели, это очень конструктивная вещь. У нас есть формула,
мы берем, находим первый квантор в существовании, придумываем для него новые функциональные символы,
делаем подстановку, что сложно. Ну, множество универсальных дезюмптов, но тоже, по сути дела,
мы берем бескванторную часть полученной p1 формулы и заменяем ее на knf, считая атомарные формулы
именами булевых перемен. Никаких проблем. Ну и, наконец, вывод. Вывод, как я уже говорил,
дело может оказаться сложным, потому что ведь все, что я утверждаю, что если формула общезначима,
то есть вывод противоречия из построенного множества. Ну, как его строить, я ничего не сказал,
это мы будем обсуждать, это тонкий момент. Но, по крайней мере, если этот вывод предъявлен,
ведь p у нас просто какой-то текст. Ну, вот я туда включу этот вывод, и тогда что останется
умстно отсталому преподавателю? Ну, проверить, что все сделано вот по этим правилам. И это
несложно, потому что вот они правила есть, вот есть вывод, я смотрю, а вот этот дезюмп получается
там, 29 дезюмп получается с 17 и 18 правилам резолюции. О, вижу. Особенно если студент хороший и
прямо написал комментарий, что вот этот дезюмп получается с 17 и 18, ну тогда совсем легко,
уже понятно куда смотреть. Но даже если не написал, я переберу все пары, мы сейчас обсуждаем
алгоритмическую возможность. Эффективность нам не так важна. Значит, мы получаем систему
доказательств для общезначимых формул. Это важный момент. Системы доказательств не для любого
множества существуют. Дальше примеры у нас появятся. Но сейчас я хотел бы сказать немножко
другое. Прежде чем переходить к последней части курса, где у нас внезапно возникнут алгоритмы,
уже так на весь рост, я хотел бы все-таки закончить тему с основаниями математики. Мы пока обсуждали
логику. А я в самом начале говорил, что это все относится к обоснованию математики. Как это
происходит? Ну вот у меня уже осталось совсем мало времени, поэтому я начну. Мне удобно использовать,
поскольку я доказал корректность и полноту для исчисления резолюции, мне удобно использовать
качество синтоксического следствия. Вывод в исчисление резолюции. Что это означает по
определению? По определению это у меня теория какая-то, то есть замкнутые формулы. А это какая-то
формула. Ну пусть тоже замкнутая. Я теперь хочу объяснить, что значит, что это синтоксическое
следствие. Это означает, что я могу из множества гамма и отрицания А могу вывести противоречия.
Какое противоречивое множество формул уже понятно. Мы должны построить множество универсальных
дизайнтов для каждой формулы и вывести в резолюциях противоречия. Так вот принципиальный факт,
который для обоснования математики нужен, он верен конечно и для исчисления предикатов, но там
мы не доказывали теоремы о полноте, поэтому я предпочитаю вот это доказательство использовать.
Он состоит в том, что вывод синтоксическое следствие равносильно симантическому. Симантическое
следствие означает, что если у нас есть модель для теории гамма, то все формулы там истинны,
то тогда и формула А истина. Это собственно то, что нас интересует математики. А это какое-то
утверждение о группах, например, и мы хотим, чтобы оно было истинно в любой модели для групп.
Ну скажем, такого типа утверждения математики интересует. Любые такого типа утверждения с
помощью этой теоремы сводятся к манипуляциям с формальными символами. Теперь мы уже имеем
формальный вывод в исчисление резолюции. Это преобразование совершенно формального типа.
Ну как доказать эту эквивалентность? Ну достаточно легко. Смотрите, вот это что
означает, что такое множество противоречиво? Мы только что доказали, что корректность и
полноту исчисления резолюции. Ну раз множество гамма и отрицание А не совместно, это означает,
что в любой модели гамма формула не А должна быть ложной. Раз формула не А ложна, значит А истина.
То есть мы и доказали, что А следует. То есть вот это вот и означает, что из гамма семантически
следует А. Ну и наоборот, предположим, что то же самое. Теперь давайте в другую сторону. Если из
гамма семантически следует А, это означает, что множество гамма и отрицание А не совместно. Ну
потому что тут тоже можно поставить равносильность на самом деле. Ну да, так вот лучше все поставить
равносильность и не писать лишнего. Это тоже понятно. А дальше это опять наша теорема корректности
и полноте. Она же дает нам равносильность вот этих условий. Значит мы переходим сюда и отсюда
переходим вот к вот этому. Вот и все. Значит мы получаем, что несовместность равносильно
противоречивости. Ну или совместность равносильно не противоречивости. В том числе для формы первого
порядка. И давайте я сразу скажу, что в следующий раз про это не говорить. Я не буду
доказывать. На самом деле вывод в исчисление предикатов равносилен выводу в исчисление
резолюции. Почему я это не доказал? Это на самом деле можно доказать синтоксически. Но это мучительно.
Не хочется тратить на это время, потому что если доказать теорему о корректности и полноте
для исчисления предикатов, то это получится автоматом, потому что мы доказали, что синтоксическое
следствие равносильно семантическому для исчисления резолюции, то же самое можем доказать для
исчисления предикатов, ну поэтому они друг другу будут равносильны. Но это по модулю корректности
и полноты исчисления предикатов. Корректность мы доказывали, а полноту я не стал доказывать и не
буду ее доказывать, на это нет времени, поэтому мы просто вот это утверждение держите в голове,
то есть я буду часто уже опускать вот этот значок R, просто использовать синтоксический вывод, ну в общем
в любых синтоксических средствах, которые равносильны исчислению предикатов, например,
исчисление резолюции. Но про исчисление резолюции мы все аккуратно доказали, это существенно. Хорошо,
значит на сегодня я уже останавливаюсь.
