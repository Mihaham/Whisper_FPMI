Ну окей, Лан, давайте начинать. У нас сегодня с вами новый
семестр начинается, я вас поздравляю с прекрасной
первой парой нового семестра. Тут должны были быть…
Нет, сверчки. Соответственно, в этом семестре мы занимаемся
глобально двумя вещами – это графы и строковые
алгоритмы. Быть может, еще что-нибудь зацепим, но
это вряд ли. Собственно, на графы у нас будет примерно
три модуля. Первый – это будут всякие обходы графов
DFS, BFS. Второй – это будут кратчайшие пути и около
задачи. И третий – это будут потоки. Вот. Как бы план
очень простой. По поводу системы оценения она немножко
изменится, потому что, ну, как бы так мягче сказать,
теорки дискредитировали себя наличием мобильного
непроверяемого плагиата. Вот. В связи с этим было
решено их удалить из системы оценивания. Вот. Это первое
в нововведении. Второе – задачный ревью будет меньше
с одной стороны. С другой стороны, требования будут
общими для всех групп базовые. То есть, это значит, что
у вас условно задача из прошлого семестра, не знаю,
про многоугольники, найдите выпуклую оболочку. Вы должны
уметь шаблоны закидывать тип параметризующей точку,
многоугольник тип параметризующий саму точку многоугольника
в класс, получающий выпуклую оболочку, задавать произвольные
скалярные произведения и так далее. Вот. Это будет
общим для всех. Вот. Да, я надеюсь, что я вас обескуражил
этим заявлением. Зато таких задач в контесте будет
максимум 2-3 к каждому. Тобственно, вот. Может быть, 2-1. Я не знаю
еще точно, что это такое будет. Соответственно, сочувствую,
но ничего не поделать. По поводу системы оценивания
точная формула будет выложена на этой неделе. Первое задание
тоже на этой неделе. Ну и все остальное тоже на этой
неделе будет. Вот. А теперь давайте оторвем момент
и прием к содержанию. Так, лекция первая. Ну, давайте
наверное скажем еще, что такое граф. Вот. Ну, один
раз скажем и забудем. Потом будем воспринимать картинку.
Пара VE называется графом, если, ну, давайте, не так,
не если, а где V меньше бесконечности, это множество вершин. Да,
мы будем рассматривать только конечную графу. А E, оно будет
у нас под множеством V на V. Таким что. Ну, сейчас
будем перечислять требования. В общем случае в графе
мы не позволяем себе петель в определении именно графа,
поэтому для любой V из V пара VV не лежит в множестве
ребер. Это требование на отсутствие петель. Второе,
что мы будем требовать, что для любой, для любых UV
из вершинок наличие ребра VU лежит в E. Это равносильно
тому, что у вас есть ребро UV. Это неориентированность.
То есть по умолчанию мы считаем графы неориентированными.
Если нам требуется ориентированная графа, мы будем это явно
проговаривать. И третье, самое интересное, это то, что
у нас отсутствуют кратные ребра. Я долго думал как-то
записать на языке кванторов, но давайте запишем это
так. Ну будто бы да, но будто бы можно сказать, что
можно рассматривать это как мультимножество из
этого множества. Ну это просто набор элементов. Все, это
мог быть повторяющийся ответ такой. Вот что такое
мультимножество. Ну окей Илон, давайте скажем, что
кратных ребер нет, и если что мы их ведем. Ну давайте
так определим. Хорошо. Не особо принципиально, потому
что к этому определению мы возвращаться особо не
будем больше. Вот. Ну графы ориентированы, если, давайте,
неориентированность, это отсутствие петель. Ну и
как замечание, то, что у нас действительно нет кратных
ребер. Если в графе есть петли, то это называется
мультипсевдограф. Если граф вот этот вот неверно,
то граф ориентированный. Вау. Если в графе есть кратные
ребра, это называется мультиграф. Тобственно, вот эти вот слова
ориентированный, мультипсевдограф можете переставлять как хотите
и получать любые комбинации. Вот. Окей. Все, договорились
о определениях. Теперь начнем с... Закончим с математикой.
Там снегопад пошел. Во время ночи лекция. Окей. Так. Как
хранить граф вообще в программах? И вообще какая мотивация
работать с графами? Ну графы это вообще достаточно
естественная структура для представления каких-то
данных. Ну и самое простое, такие там карты городов.
Вот. Окей. Так, хранение графа. Потому что чтобы работать
с графом, нам нужно его хранить вообще как-то. Есть несколько
способов. Мы будем развивать обычно два. И первый это
матрица смежности. Что такое матрица смежности? Это
матрица В на В размеров. Размеров, естественно. Вот. Мощность
В на мощность В. Где... Да, я сразу буду говорить, что,
в общем-то, у нас не всегда существует индексация на
множество вершин. Ну, если следовать этому определению.
Вот. Ну и вообще не очень понятно, как можно индексировать
такие объекты. Вдруг вершина, это что-то сложное. Но я
позволю себе наглость, что раз на бесконечное множество
я могу как-то их пронумеровать. Вот. А если я могу как-то
пронумеровать, то имеется в виду, что здесь жито и
жито. Это индикатор того, что из вершины И, ну с номером
И. Дальше тут просто вершина И говорится. Есть ребро
в вершину с номером жи. Просто жи. Далее. Вот. И второй
вариант. Это список смежности, ну или списки смежности.
Что такое список смежности? Это массив списков размера,
имеется в виду массив размера модуль В здесь. Списки могут
быть произвольного размера. Так. Где в этом списке лежат
соседи этой вершины. Сразу скажу в ориентированном
графе. То есть если у вас есть какая-то такая картинка
у ВВ, то соседом вершины В является В только. То есть
мы обратные ребра не рассматриваем. Под соседями подживаются
те, до кого вы можете достичь непосредственно по ребру.
Вот. Так. Это список смежности. Давайте рассматривать
разные операции, которые мы хотим от графа вообще.
Ну, наверное, хочется узнать операция. И первое узнать,
есть ли ребро между У и В. Ли ребро у В. Так, давайте
это будет матрица смежности. Это будет список смежности.
Какую табличку будем делать? Матрица смежности, за сколько
мы умеем узнавать, есть ли ребро? За единицу, да. А списки?
Ну не совсем. Более точно от степени вершины. Да,
DECU – это степень вершины, то есть число нисходящих
ребер. Вот. Ну что еще? Наверное, хочется уметь получать
список соседей вершины явно, чтобы по нему итерироваться.
Получить список соседей У. Ну, будем считать, что
матрица смежности, так как у нас есть нули, нам все
равно придется там… То есть, что мы хотим? Мы хотим
по нему итерироваться на самом деле. Мы явно список
не хотим получать. Мы хотим уметь получать какой-то
контейнер, который имеет метод «дай мне следующего
соседа». Вот. Итого полное время итерирования – то,
что нас интересует. В частности, для матрицы смежности нам
придется добежать до конца, в любом случае, до конца
строчки, чтобы понять, есть ли в конце там соседей.
То есть от числа вершин. Тогда как для списка смежности,
в общем-то, вам не нужно будет пропускать вершины,
которые не являются соседями, потому что они у вас просто
не хранятся здесь. Поэтому полное время итерирования
также составит ту отстепень. Ну, и классическое время
и построение, и память точнее на построение. Время построения.
Вот за сколько матриц смежности можно построить? Ну, будто
бы давайте считать, что мы можем память вылить за
единицу. В на В. Ну, мы же можем, не знаю, там у нас есть
в графе, наверное, список ребер какой-нибудь нам данный.
То есть, казалось бы, от Е хочется делать. Но давайте
мы все-таки оставим этот спор за тем, что нам хватит
оценки в квадрат. Ну, потому что, банально, давайте там
считать, что память выделится немгновенно, потому что
можно нулями все заполнить хотя бы изначально. Окей.
Списки смежности. За сколько он строится? Ну, еще ни
одного правильного ответа нет. Да, В плюс Е на самом
деле. Почему это так? Почему здесь нужно модуль В вообще
учитывать? Потому что вдруг у вас в графе очень мало
ребер. Ну, он разреженный такой. Но он же все равно
нужно там пройтись и создать какие-то пустые списки
за модуль В. Поэтому обычно это учитывают так или иначе.
Ну и память. Здесь я уже заполню сам, потому что слишком
просто. Вот. Итого. То есть, матрица смежности, конечно,
неплохая сама по себе, потому что позволяет нам проверить,
есть ли ребро. Но есть нюанс в том, что у нее время и память
занимают. То есть, как бы для графов, которые не близки
к полным, вот это вот очень плохая оценка. Это вот куда
лучше. Вот. Так, Кейм. Есть ли вопросы по тому, как граф
хранить? Супер. Так, ну теперь мы будем учиться обходить
граф, потому что пока что мы с ним ничего делать не
умеем. Ну, точнее, мы уже умеем его в память записывать.
Это, конечно, классно. Но как с ним надо оперировать?
В том семестре мы научились с вами обходить деревья.
Ну, было такое там преордер, энордер и так далее обходы.
Вот здесь немножко сложнее, но не сильно на самом деле.
И первое, что мы будем рассматривать, это DFS. Расшипровывается
как depth-first-search или по-русски поиск в глубину. Вот. Собственно,
в чем суть алгоритма? Вы запускаете от какой-то
вершины, перебираете всех ее соседей, перешли в первого
соседа, запустились рекурсивно. Ну, все. Все гениально и
очень просто. То есть, казалось бы, что-нибудь там типа void DFS от int v.
Ну, вообще, от вершины здесь произвольно написать. Ну,
давайте от int a по номеру вершинки v. Давайте мы будем считать,
что у нас есть int v от graph. Graph g int v. Если, что здесь если? Зачем здесь если?
Нужен for. Мы проявляемся по соседям for, after, u, g, getNeighbors от v. Ну да,
допустим у нас у графа есть метод дай мне соседей по вершинке.
Собственно, то, что мы с вами обсуждали. Делай DFS от g u. Какие есть проблемы у этого кода?
Да, если у вас есть просто ребро в графе, он зациклется. Очень просто. Потому что он будет
ходить туда-сюда. Поэтому, наверное, надо как-то это фиксить. Фиксить это очень просто тем,
что мы вводим массив visited, used. Там куча названий у него. Давайте напишем так.
Пусть used от v. Это индикатор того, что v уже посещена обходом. Вот тогда что мы должны сделать?
Мы должны здесь будто бы проверить. Если вершина не посещена, то делай то-то и
поставь, что она посещена. То есть сюда нужно вставить следующий блок кода. Что если не used от v,
то used от v равно true. И вот это вот все дело, этот цикл можно вот сюда вот запихать. То есть
я хочу проверить, что если вершина не использована, то давайте сделаем не так. Проверим по-другому,
чтобы это адекватно смотрелось. Да, давайте сделаем так, что если она использована,
ужасные тряпки, стерки в этот раз. Если она использована, то return просто делаем. И здесь
делаем used от v равно true. Вот так вот это пойдет. Даже соберется по идее. Первый вопрос,
за сколько это работает? Ну да, потому что мы посетим каждую вершину один раз и каждое
ребро не более двух раз. Давайте допустим, что у нас тут есть какое-то ребро. Это вершина u,
v. Допустим, DFS пришел в вершину u раньше. Тогда DFS посмотрит сюда и пойдет в вершину v. ДФС
по вершине v просмотрит всех соседей, включая вершину u. Но u-то уже была посещена, поэтому
он ее дальше рассматривать не будет. Но ребро мы посмотрим ровно два раза. Из вершины u и вершины v.
Поэтому всего ребра мы посмотрели два раза и каждую вершину тоже не очень много раз
Посмотрим на самом деле. Вот, по крайней мере мы DFS от нее будем вызывать. Вот, поэтому время работы.
Окей, казалось бы круто, да? Но на самом деле этот код не рабочий и он не обойдет весь граф,
в общем случае. Да, потому что на самом деле мы запускаемся лишь от одной вершины, будто бы
где-то там в мейне. Если мы вызовем DFS от одной вершины, то пока еще не докажем утверждение,
то мы посетим ровно компоненту связанности с вершиной v. Не более чем. Да, это еще придется доказывать.
Поэтому в общем случае DFS выглядит так, что вот эта вот сама функция рекурсивного обхода, а есть еще
мейн, который перебирает вершинки в порядке возрастания, и если она еще не помечена вот этим вот used,
то она будет запускать от него DFS. Вот, тогда мы все посмотрим. То есть здесь будет что-то типа for v
меньше, чем уголь v. Если не use.v, то делай DFS над gv. Что-то такое будет. Теперь мы посетим весь граф,
и тут вы уже можете заметить, что с архитектурной точки зрения массив used будто бы это какая-то
глобальная переменная, потому что мы вот здесь никуда не передаем. И в текущем написании это как бы да.
А как именно исправлять это, вам предстоит познакомиться на семинарах. А именно тысяча и одно
архитектурное решение, как писать DFS. Там действительно куча способов разных. Ну окей.
Так, теперь надо сформулировать несколько утверждений о DFS, чтобы понять, зачем он нам нужен, кроме того,
чтобы ходить по графу. И давайте введем такое понятие, как цвета вершин. Цвета вершин.
Одя DFS. У нас будет всего три цвета. И немного не толерантно получится, но все-таки в ходе классики
у нас будет все-таки три цвета. Это будет белый, серый и черный. Вот. Первый цвет-то белый. Эта вершина не была еще посещена.
Вот. Второе. Это серцвет. Уже посещена, но не обработана. Под словом обработана,
здесь я подразумеваю, что вызов DFS от этой вершины закончился. То есть мы вызвались от всех соседей
рекурсивно и вылетели из такой рекурсии уже из этой вершинки. Вот. А мы находимся где-то,
что еще не вышли из нее. И третий. Это будет черный цвет вершинки. Уже обработано.
Давайте посмотрим на примере графа эволюция цветов. Давайте нарисуем граф какой-нибудь.
Много вершин получилось, но я думаю, мы поймем, когда остановится. Вот. Ну и запускаем DFS 3 единицы.
Что мы будем делать с этим всем? Ну, окей. Давайте сделаем вот что. Посмотрим на эволюцию цветов вершин.
Один, два, три, четыре, пять, шесть. Здесь будут цвета. И изначально все вершинки белые,
потому что мы никого не посетили еще. Окей. Ну W это white. Дальше запускается DFS к единице.
Что происходит? Мы помечаем ее серой, потому что мы зашли в нее. То есть она останется с gray.
Окей. Запускаемся от вершины один. Ну и там вот рекурсивный запуск от всех соседей. У нее
все только двойка. Поэтому становится снова gray. Gray это W. Ну и давайте положим, что мы идем в четверку
для начала. Ну, так жизнь сложилась. Пришли в четверку. W, W, W. Ну и в четверке мы
интеррируемся по соседям. Допустим, в пятерку пришли. Серый, серый. Белый, серый. Серый, белый.
Смотрим соседей пятерки. Это 4,6. Казалось бы, 4 с меньшим номером, поэтому будто бы мы в нее
пошли сначала. Но она уже использована. Ну, типа у нее use там равно true. Ну или она уже не белого
цвета. Поэтому мы должны идти только в шестерку дальше. Окей. Из шестерки пытаемся пройти соседи.
Смотрим. 5. Уже использовано. 4 уже использовано. То есть мы не можем как бы из шестерки никуда
дальше пойти. Поэтому stack recursion выходит из шестерки наверх. И раз мы вышли из шестерки,
мы пишем ей black. Черный цвет. Прошли обратно. Ну, я думаю, дальше понятно, да, как будет
устроено все. Вот. Как можно вводить цвета эти явно? Куда в коде их вставлять? Ну, вы делаете
следующее, что у вас изначально, забывайте такой массив уже new stack colors. И здесь у вас изначально
у вас все тут пишут, что там цвета все белые. Дальше у вас здесь что? Цвет вершинки в серый. И
пытайтесь вот здесь вот типа. А потом, когда уже вы закончили for, вы пишете, что цвет вершинки
черный. Здесь как бы ничего интеллектуального нет. Зачем мы вводили эти цвета вершин? Для того,
чтобы доказать очередное утверждение, очевидно же. Алема о белых путях. О белых путях.
Звучит так, что рассмотрим все такие вершины,
что достижимы из V по белым путям в момент покраски V.
Серый цвет. То есть рассматриваем все такие вершинки, что как только мы пришли в V,
это все достижимы из нее по белым путям. По белым путям это значит, что все вершины в пути белые.
В момент покраски V черный. Данное множество вершин
станет черным. Формулировка сложнее доказательства на самом деле. Ну ладно,
не прямо уж это так просто. То есть что иметься в виду? Рассмотрим момент времени,
когда ДФС зашел в вершинку 2. То есть 4-5-6 еще не посещены. То есть мы находимся на вот этой
вот стадии. Покрасили двойку в серый. Вот утверждается, что когда мы покрасим двойку в черный,
все вот эти вот вершины станут черными. Вот что утверждает Лемма. Давайте доказывать.
До момента покраски этой вершины в черный цвет эти уже будут черными. Ну или к моменту. Давайте
пробуем доказать. Давайте докажем, что будто бы это, предположим, что это неверно. Докажем
противного. Предположим противное. То есть у нас есть какая-то вершина, которая была, то есть у нас
есть какая-то вот наша вершинка В. Вот это все они были достижены по белым путям.
Еще тут как-нибудь так. Они все белые. Вот этот момент времени 1, когда мы покрасили в серый.
Теперь времени 2. Это уже черная. Вот все они были достижены по белым путям. Теперь предполагаем,
что здесь есть какая-то вершина, которая не стала еще черной. Допустим, это вершина У. Пусть
вершина У. Ближайшая не черная вершина к В. Ближайшая имеется в виду по числу ребер.
Вот она. Какие у нее могут быть варианты? Может быть белый вообще в этот момент? Будто бы.
И пусть П это предок У на пути из В У. То есть как мы могли отметить, что DFS он просто строит
какие-то ребра, потом поднимается наверх, тут что-то строит и так далее. Граф вход DFS он не очень
интеллектуальный. То есть если рассмотреть путь от вершины У до В, то вот наша вершинка П.
Вот. А, ну и соответственно, если П, заметим, что раз П это предок, значит П ближе к В. Раз
мы выбрали У, это ближайшая не черная вершина, значит П не черная. Ой, да-да, извините, да. Значит
П черная. П черная вершина. Ну если П черная вершина, то мы что с вами сделали? Давайте рассмотрим
случай У белая. Первый случай У белая. Ну что тогда? Ну если У белая, значит мы в нее еще не
заходили, но есть ребро ПУ, которое мы уже проверили, потому что П это черное, значит У не может быть белый,
но У белое, но П черное, и ребро ПУ лежит в множестве ребер. Ну раз так, следует, что и У не белое,
так ребро должно было быть рассмотрено. Второй случай У серое. Хорошо. Что значит, что У серое?
Ну это не очевидно, кстати. Давайте посмотрим так, что если У серое и при этом П черное,
значит будто бы мы должны были сначала зайти У, потом в П. Согласны? Только такая конфигурация, возможно.
Ну тогда да, тогда у вас нет, не в этом проблема. Прям в том, чтобы вы в П раньше вошли, чем в У,
потому что у вас П это предок вершины У в дереве ДФС. В плане? Ну окей, мы можем взять из У в В корчайший путь для определенности, это не сильно ломает.
Ну даже если не так, все равно мне кажется ничего не сломается здесь. То есть если у вас У серое, следует что? И П черное.
То есть смотрите, если у вас У серое и П это черная вершина, это значит, что вы все-таки вышли из П раньше, чем вышли из У.
Ну хорошо, вот так вот согласны. То есть вышли из П раньше, чем из У. Но проблема-то в том, что П у нас будто бы выше на пути.
То есть мы должны были бы раньше выйти из У, чем из П. П предок У. Мы определяли предка так, что у нас есть отношение быть предком, что мы из вершины П пришли в вершину У в ходе ДФС непосредственно, в ходе перехода.
Вы, в общем, докажете, что у нас в вершине все вершины в черной покрасятся?
Нет, я утверждаю, что в момент этого оно покрасится. То есть я утверждаю, что все вершины достижены по белым путям, они покрасятся в черный. Вот. Я предполагаю противное. И вроде как я доказал, что такого быть не может.
Ну там есть два варианта, как доказывается. Первый вариант через того, в кого раньше пришли. Вот смотрите, если у нас П черная, так, давайте так посмотрим, что П была посещена ДФСом раньше, чем У, потому что мы П у ребра рассматривали в ходе ДФСа.
Вот, но с другой стороны, если У все еще серая, а П черная, это значит, что у нас будто бы рассматривалось ребро УП.
Но это же не правда, мы рассматривали ребро ПУ, то есть в обратную сторону. Это первый вариант. Второй вариант через времена выхода.
Ну плюс-минус рассуждение будет аналогичным в итоге придем. То есть мы придем, что в такой посылке, в таком предположении, что будто бы мы в У пришли раньше, чем в П, но мы положили, что П определяется ровно так, что наоборот, чтобы сначала в П пришли, а потом в У.
Можно так? Это абсолютно аналогичное рассуждение, что рассматриваются, чтобы быть предком на самом деле. Вот, окей, ну будто бы доказали.
Лему о белых путях. И у нее есть несколько следствий. Первое следствие, тривиальное, это то, что если вы рассматриваете ДФС от вершинки какой-то, то к моменту окончания ДФС от этой вершинки, вы пустите всю компоненту связанности и только ее.
Доказывается тривиальным образом тем, что давайте рассмотрим ДФС от С, стартовой вершины С. Хорошо, она была белой. Рассмотрим это, когда ее покрасили в серый, то есть самый старт ДФС. Утверждается, что все вершины, которые достижены из нее, они достижены ровно по белой вершине С.
А к моменту конца они все станут черными. То есть мы все их посетим, и других вершин посетить мы не могли. Вот. Давайте я просто напишу утверждение, а этот полет мысли ставлю вам на вольное конспектирование.
Так.
л
в
Так, следствие первое, DFS от V посетит все вершины
достижимые из V и только их. В частности, да, здесь говорят люди уже про компоненты
связанности, но здесь я немножко их предостережу, что если графы ориентированы, то там немного
некорректно об этом говорить. Поэтому оставим формулировку, что все вершины достижимые из.
Второе, в графе есть цикл, цикл достижимый из V. Тогда и только тогда,
когда есть ребро в серую вершину. Как вам идея ставить это упражнение для читателя?
Нет, смотрите, у вас будто бы ситуация в эстанатом графе следующая. Вот у вас четверка
серая здесь уже, да, и вот вы рассмотрите ребро 6-4. Вот вы пришли в серую, а четверка серая,
потому что. Все, значит цикл. Во все графы это верно. Ну имейте в виду это, да. Хорошо,
давайте в ходе обхода. Когда в ходе обхода есть ребро. Давайте так. В ходе обхода обнаружено
ребро в серую вершину. Ну будто бы да. Такое средненькое. Все еще не прокатывает,
когда у вас одно ребро. Давайте вот так вот. Не предок. Вот так вот. Теперь никакой педант не
докопается. Ну вы могли бы, не знаю, как-нибудь там фильтровать, что ли, чтобы предок у вас не
рассматривается в ходе ДФСа по другим причинам. Не то, чтобы он там какой-то цвет другого,
не белого. Вот. Читателям это утверждение оказалось неочевидным, судя по вопросам,
в то время пережил, поэтому давайте доказывать. Ну это примерно так, как сказать, что и будет
сейчас устроено. Ну давайте докажем, что если есть цикл, то есть ребро в серую вершину. Хорошо.
Ну рассмотрим этот цикл. Рассмотрим цикл С, вершина В. Это первая посещенная ДФС,
вершина С. То есть давайте нарисуем. Вот у вас есть цикл какой-то. Что? Что считаем?
Это В, а это У. То есть вот у вас, вот у вас вершинка В ваша, из которой вы стартовали ДФС,
вот у вас первая посещенная вершина У. Вот я утверждаю, что в первое время, то есть когда мы
только пришли в вершину У и покрасили ее серой, все вершины на цикле, они белые. Согласны, да?
Потому что это все по белым путям было. Но когда мы выходим из У, то есть когда мы У крашим в черный,
у нас все эти вершины уже черные. Давайте рассмотрим момент, когда мы эту вершину покрасили в серый,
вот предшествующей по цику. Допустим, что мы пошли в этом направлении. Но когда это было серой,
это и подавно было серой. Значит мы нашли ребро в серую вершину. Сложный логический переход. Давайте,
окей. Пусть это W. Пусть W это предшествующая у вершины С. То есть вы выбрали вот такое направление
обхода цикла, ваш ДФС так пошел. И вот вы пришли в вершину В. Рассмотрим момент, когда вершина В была
покрашена в серый. Рассмотрим момент, когда покрасили W в серый. Вот я утверждаю, что в этом
по премию вершина У все еще серая. Почему это так? Потому что вершина У белой быть не может,
мы уже ее посетили. Значит она либо серая, либо черная. Почему она не может быть черной? Потому что
если это серая, то по лемме о белых путях мы еще не вышли из У. Раз мы еще не вышли из У, значит она серая.
Все. По лемме о белых путях. Этот момент времени. У все еще серая.
Ну доказали в эту сторону. Нашли льбров в серую вершину в ходе обхода. В обратную сторону,
что если у вас есть льбров в серую вершину, доказывается совсем просто. Вы просто
рассматриваете стек рекурсии и говорите, окей, я нашел льбров в серую вершину. Значит у меня в стеке
рекурсии лежат все вот эти вот вершинки. Потому что в стеке рекурсии лежат только серые вершины.
Белые там не могут лежать, потому что они еще не посещены. Черные не могут лежать, потому что они
соответственно удалены были бы уже из стек рекурсии. Все. Доказывается в обратную сторону. Давайте
напишем здесь такое. Напишите для формальности. Стек рекурсии только серые вершины. Откуда
следует, что ребро первое, это ребро в вершину. Здесь я должен еще сильнее наклониться. Нет,
я постараюсь держать. Плюс-минус горизонтальное написание. Вершина из стека. Просто переход
в вершину стека. Значит у нас в стеке рекурсии лежит весь цикл, который мы хотели. Все. Конец.
Вроде бы доказали. Если вы верите, то давайте начнем еще один раздел.
Вот его мы, видимо, уже не успеем сегодня закончить. Но если успеем, то будет вообще классно. Это
ДФС на ориентированных графах. Что это значит? Это не значит, что все выше сказанное не работало
для ориентированных графов. Это значит, что то, что будет сказано сейчас, работает только для
ориентированных. Вот так надо понимать. И определение первое и следующее. Определение.
Пусть ж ве, то есть граф, потому что он вершин ве, потому что он вере, это ориентированный граф.
Назовем sigma из s модуль v, то есть перестановку топологической сортировкой. Вы что, не ждали,
да? Сортировки даже здесь бывают. Мне здесь к топологии мало отношения с сортировкой. Ну или я,
крайне вероятно, его не знаю. Если для любых ув из v таких, что пара ув лежит ве, верно,
что sigma от u меньше, чем sigma от v. То есть вы пронумеровали вершины так, чтобы были ребра,
то есть вот если у вас ребро из u в v, то ребра только из меньших больше. То есть у вас как-то
пронумерованы вершины, ну не знаю, давайте скажем что-нибудь такого. 1, 3, 2. Топологическая
сортировка у вас превратит эту нумерацию в 1, 2, 3. То есть у вас из меньших больше шли ребра и только.
Казалось бы, зачем это нужно? Ну это вам позволит, ну считать, что будто бы, ну, то есть это вам
позволит удобно итерироваться по вашему графу, если вы хотите что-то считать. Потому что вам
достаточно допустить хор от минимальных номеров и победа, в общем-то. Во, это важно. Я же не сказал,
что она существует. Я говорю, что вот назовем эту штуку такой. А теперь давайте доказывать
утверждение. Топологическая сортировка или топ-сорт на жиргонизме, на жиргоне существует
тогда и только тогда, когда граф цикличен. Вот такое утверждение или теорема, можете считать.
Давайте доказывать. В какую сторону кажется проще? Ну да. От противного. Доказываем отсюда-сюда.
Давайте скажем, что если в графе есть цикл, то топ-сорт не существует. Это вроде очевидно на самом деле.
Ну что, если у вас есть график цикл, то как бы вы не переставляйте, у вас стоит, что одна вершина
строго меньше другой. Ну давайте так рассмотрим произвольную сигму и цикл v1, v2, vn, v1.
Узнается, что мы как-то переупорядочили. Тогда сигма топ-сорт. Этого следует, что сигма v1 меньше,
чем сигма v2 меньше, чем сигма vn меньше, чем сигма v1 конец. Противоречие. Здесь можно бы сказать тем,
что у вас порядок меньше, цикличен, и вы пытаетесь его вести на вершинах. Но можно описать это подробнее.
Давайте в обратную сторону. Если у вас граф цикличен, то топ-сорт существует,
и у вас есть методы доказательств того, что что-то существует.
Ну да, давайте просто приведем алгоритм, который у вас строит.
В обратную сторону. Я забыл ввести парочку штук определения, которые ему удобно оперировать.
Давайте мы их сначала введем, потом будем им оперировать.
Соответственно, определение t и над v. Время вода в вершину v.
Момент, когда ее посетили. Когда покрасили ее в серый.
Т.е. tout от v. Это время выхода из вершины v.
Момент, когда покрасили ее в черный.
Все, теперь я могу говорить на родном языке, языке DFS.
Все, доказываем в обратную сторону. Я утверждаю следующее, что если отсортировать вершины
по убыванию времени выхода, то это победа. Для этого нужно рассмотреть ребро uv, рассмотрим
uv из e, т.е. ребро. Вот я утверждаю, что время выхода из вершинки u строго больше, чем время
выхода из вершины v. Утверждение tout от u строго больше, чем tout от v. Доказательства.
Первый случай. t in от u больше, чем t in от v. Т.е. мы сначала вошли в вершину v, затем в вершину u.
Графоцикличен, значит, мы не можем добраться до вершины u никак.
Т.е. так как графоцикличен, из вершины v нет пути в u. Откуда следует, что мы сначала
выйдем из вершины v, потом как-то наш DFS дойдет до вершины u, а это строго меньше, чем tout от u по
определению. Доказали. Второй случай. t in от u меньше, чем t in от v. Что это значит? Это значит,
что мы сначала пастили u, потом пришли v. Полемия о белых путях снова. К моменту,
когда мы покрасили вершинку u в черный, это уже должна стать черный, вершина v. Полемия о белых
путях. Что это значит, что tout от v меньше, чем tout от u? От v меньше, чем tout от u. Так,
эта часть доказали. Ну все, победа. Если у вас есть графоцикличен, то значит tout от u, tout от v
не устроит порядок на touts на самом деле. Вот. Почему это так? Потому что я предполагал,
что графоцикличен, тогда у меня, если есть ребро в Waze, то верно вот это вот. То есть меня
устраивает полностью порядок touts. Значит, порядок в убывании touts, tout,
нас устраивает. Окей, казалось бы, все. Давайте для каждой вершины
посчитаем tout, за v лог v отсортируем победу. Это уныло. Так не хочется делать. Почему? Потому
что быстрее, может, за линию. Потому что на самом деле, в ходе DFS, а что вы делаете? Вы,
когда красите вершину в черный, вы можете добавлять ее просто в какой-то списочек,
ну там вектор, пушить ее. Он утверждается, что у вас вершины будут отсортированы по возрастанию touts.
Значит, вам нужно просто развернуть этот список, это победа. В ходе DFS,
момент покраски в f черный, будем добавлять ее в массив.
Это к чему вопрос?
Будто бы это неправда.
То есть, там как бы не очевидно, что у вас, то есть, в прямом том, что у вас есть
есть interval v и z, у вас может быть что то, что это. Но tout и точно соотношение соблюдено.
Покраски f черный, будем брать ее в массив. Добавили в массив, тогда в массиве вершины
отсортированы по возрастанию tout. Следовательно, осталось
превернуть. Конец. Заодно привиляет алгоритм по строению топологической сортировки за линейное
время. Почему за линейное время? Потому что tout и можно считать за линию. Это просто DFS запустить.
Так, по этому вопросу остались?
Это? Ну мы рассмотрим, что tout больше, чем tout. То есть, мы сначала вошли в...
Сейчас. Сначала вошли в u, потом в v. Нет, наоборот в room. Сначала в v, потом u. Потому что tout
в v меньше, значит мы к ней пришли раньше. Пришли раньше в v. Так как у нас графоцикличен,
у нас нельзя отсюда как-то прийти в вершину u. То есть, нет такого пути. Иначе мы нашли цикл.
Значит, DFS, когда пришел в вершину v, он сначала тут как-то походит, потом выйдет из вершины v и
только потом придет в вершину u. Когда мы его запустим из другого в мейне, когда будем запускать
вот этот вот. То есть, нам есть фор и запускаем вершины, если они еще не посещены. То есть,
мы придем в u позже. Вот это этот случай. Второе, это когда у вас сначала пришли в u, потом v.
В полеме о белых путях, когда у вас u покрасилось в черный, v уже стало черным. Значит, в момент
времени того, как v покрасилось в черный, произошел раньше, чем мы покрасили u в черный. Ну все,
это вот это и есть. Окей, давайте еще определение попишем тогда. Определение. Вершины u и v сильно
связаны, если есть путь из u в v и есть путь из v в u. О как! Очень концептуальное определение.
У вас есть ориентированный граф. Например, вот такой вот граф. Вот есть ли в нем хотя бы одна
пара сильно связанных вершин? Что? Да, здесь нет вершин сильно связанных. Хотя, казалось бы,
граф ориентированный. Соответственно, вершины u и v называются слабо связаны в ориентированном
графе, если убрать ориентацию ребер и найдется путь из u в v. Окей, так, что нам нужно теперь?
Я утверждаю, что это отношение транзитивно. То есть, если у вас u и v сильно связаны,
и v w сильно связаны, то и u w сильно связаны. Это очевидно, да. Очевидная симметрия данного
отношения. То есть, если у вас u и v сильно связаны, то v и u сильно связаны. Концепт. Теперь надо
разобраться с рефлексивностью. Давайте для галочки будем считать, что она выполнена. Что из u есть путь
в u и из u есть путь в u длины 0. Вот, поэтому рефлексивность формально выполнена. А значит,
это отношение эквивалентности. А если у нас есть отношение эквивалентности, значит, что мы можем
сделать? Вот, да, определение. Нет, давайте утверждение сначала, что это отношение эквивалентности.
И доказательства будет, ну, не знаю, это, наверное, любой семиклассник,
который умеет рисовать стрелочки, проведет. Вот, данное отношение. Это отношение эквивалентности.
Да, данное выше, которое. Следующее определение. Назовем классом. Назовем классу. Классом мы
называть никого не будем. Класс эквивалентности. По данному отношению компоненту, компонент
сильной связности. Сильной связности. Далее их буду называть КСС. Есть еще компоненту слабой связности,
внезапно. Это те, которые достижимы, если брать ориентацию. Но мы их рассматривать не будем,
поэтому КСС определяется однозначно. Вот. Зачем они нам нужны вообще? Ну, на самом деле,
есть много интересных применений. Да, наверное, то, что в КСС вы можете от каждой вершины добраться
до каждой. Вот. То есть, это такой аналог связности в ориентированных графах. И очень хотелось бы,
чтобы все графы были сильно связанными, но нет. Так, к сожалению, не получится. А, ну да,
в качестве замечания граф называется сильно связанным, если он представляет собой одну большую
компоненту сильной связности. Аналогично, как граф называется связанным, если он связан.
Ну да, как бы тут лучше договориться о понятиях заранее, иначе можно разойтись
на достаточно концептуальном уровне какое-то время. Вот. Ну ладно. А-па-па-пам. Еще определение.
Графом конденсации по отношению какому-то, по произвольному отношению, по отношению эквивалентности
назовем граф, где классы эквивалентности сжаты в одну вершину. Да, заметьте, здесь не уточняю,
какое именно отношение эквивалентности, потому что у нас будет следующая лекция отношения
реберной двухсвязанности, вершины двухсвязанности, будут соответствующие компоненты,
соответствующие конденсации, бла-бла-бла. Вот. Так, это про граф конденсации. Утверждение.
Граф конденсации по отношению сильной связанности оцикличен. Надеюсь, доктатство,
то есть минус возникло в голове. Или надо пояснить, что такое граф конденсации все-таки? Давайте пример.
Хорошо. Нарисуем. Сжаты. Ну, по-хорошему надо. Скажем так, я ограничусь картинкой и вашим
пониманием. Ну, окей, вы можете рассмотреть ребра в новом графе, описать их по-хорошему,
что да, действительно переберем все ребра в старом графе, посмотрим, каким классом эквивалентности
лежат их концы и скажем, что вот нам новое ребро в графе конденсации. Если такое ребро уже было,
то пропускаем. Мы не на формалках, чтобы это вводить. Вот. По действиям конденсации эта штука
перейдет вот такой вот. Почему? Потому что вот у вас компонента сильной связанности одна. Здесь все
друг с другом достижимы. Но расширить ее не можете. Из-за этой вершины эти не достижимы уже.
Аналогично здесь все достижимы. Поэтому по действиям конденсации вот эти вот компоненты
мы сжали. Ну и вершинка осталась. Вот и все. Ну, тогда, я думаю, доказывать здесь особо не нужно.
Ну, давайте докажем. Вперед времени много. Да, вы это будете доказывать. Вы будете доказывать,
что любой сильно связанный компонент есть цикл. Да, это правда. Потому что если у вас...
А вот это не факт. Утверждается, что компонент сильно связанности можно разбить в объединение циклов.
Быть может пересекающихся. Вот это будет правдой. Окей, так, что мы хотим? Доказать,
что граф конденсации отличный. Ну, от противного. Пусть C1 и C2 это вершины графа конденсации.
Да. И C1 и C2 лежат на цикле. Да, то есть вот C1, вот у вас C2. Можно как-то добраться сюда,
можно как-то добраться обратно. Ну, логично, что тогда это все одна большая компонента сильной
связанности. Потому что вы возьмете какую-нибудь отсюда вершину U, какую-нибудь отсюда вершину V,
и вы получите, что они сильно связаны. Почему? Ну, давайте рассмотрим маршрут между C1 и C2.
Это будет U1, это будет V1. В силу сильной связанности существует маршрут из U в U1,
здесь из V1 в V. Логично рассмотрим V2 и U2. Ну, все, вот мы построили в общем-то маршрута.
Пусть U1, U2. Так, рассмотрим произвольную, рассмотрим произвольную,
произвольную U из C1, V из C2. И маршруты, ну или пути U1, V1, где U1 лежит в C1, V1 лежит в C2,
и V2, U2, где V2 лежит в C2, U2 лежит в C1. То есть рассмотрим вот такие вот маршруты.
Так как C1 и C2 КСС, с этого следует, что существуют маршруты U, U1, U2, U. Также существует,
это потому что C1 КСС. Дальше существуют маршруты V1, V, V2, потому что C2 КСС.
Значит, что из этого всего следует, что U, маршрут U1, маршрут V1, маршрут V, маршрут V2, маршрут U2, маршрут U – это цикл.
Откуда следует, что U и V лежат в одной КСС. Но мы утверждали, что они в разных КСС, потому что C1 и C2 – разные вершины.
Но здесь нам вообще без разницы. Мы можем просто вырезать этот кусок. Здесь, ну, можно сказать, что это...
Скажем так, обычно циклы разрешают делать и то, и то. Чаще всего подразумевают, что цикл не пересекается по вершинам,
потому что если у вас есть какое-то пересечение по вершинам, что-нибудь типа такого, то вы можете эту петлю просто вырезать.
То есть это то, что это был цикл, цикл он останется. Здесь проблем особо нет с этим, как определять.
Вот. Не, ну я достаточно знатно растянул время, доказывая это простейшего утверждения.
В целом, можно закончить на этом лекцию. На следующей лекции нас ждет алгоритм Касараю,
который нам позволит искать КСС. Вот с помощью утверждения на той доске про таута как раз.
Вот. А пока на этом все. До следующей недели.
