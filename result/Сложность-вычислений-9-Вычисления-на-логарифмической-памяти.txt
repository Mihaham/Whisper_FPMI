Поговорим про логарифмическую память.
Мы в прошлый раз изучили, что логарифмическая память
и в детерминированном варианте, и в нетерминированном
варианте, в котором она лежит в P.
Тут получается L, вложено в NL, это вложено в P.
Возникает вопрос, какие задачи решаются в NL.
Поскольку теорема Сейвича нам не позволяет сказать,
что NL равно L, и вообще это неизвестно, то возникает
некоторая градация задач.
Давайте посмотрим на некоторые задачи из L.
Во-первых, будет в L лежать все автоматные языки,
они же регулярные.
Там вообще никакой памяти не нужно, потому что можно
просто слева-направо пройтись и получить ответ.
Есть что-нибудь более сложное.
Как бы сам по себе автомат, это такая очень простая
машинтюринг, которая движется только слева-направо.
А нам не нужно чего хранить, мы просто идем по ленте
слева-направо, и соответственно, когда встретили конец слова,
нужно понять, в каком мы состоянии, в принимающем
или отвергающем, и уже вернуть соответствующий ответ.
Все автоматные здесь будут лежать, но, например,
можно рассмотреть задачу про баланс скобок.
Это множество правильных скобочных последовательностей.
Это уже не автоматный язык, но, тем не менее, он не очень
сложный, но он там контекст свободный.
Сейчас, кстати, я не знаю, все ли контексты свободные
тут лежат или не все.
Но он, конечно, неограниченный.
Нет, наверное, если все что угодно, можем класть там
вот какие-нибудь проблемы.
Ладно, это наверняка где-то написано, но я просто не знаю.
В общем, короче говоря, вот этот язык, он точно будет
в Эль, потому что там не нужен большой стэк.
Например, потому что есть теорема о том, что последовательность
правильная, тогда и только тогда, когда во всей баланс
нулевой, соответственно, в любом префиксе баланс неотрясательный.
Что можно делать?
Можно просто идти слева направо и считать баланс.
Но на это удобно смотреть, ровно так, как мы вводили модель в прошлый раз.
То есть есть отдельная лента неизменяемая со входом,
и есть рабочая лента.
Вот на рабочей ленте у нас есть отдельная лента,
если мы встретили открывающую скобку, то мы его увеличиваем на единицу,
если закрывающую, то уменьшаем на единицу.
Если пытаемся ноль уменьшить, то значит эта ошибка нужно вернуть до ноль.
Нужно вернуть отрицательный ответ.
Если дошли до конца, то смотрим, что баланс нулевой,
и соответственно, что баланс нулевой.
Если дошли до конца, то смотрим, что баланс нулевой,
и соответственно, если нулевой, то выдаем наоборот единицу,
а если положительный, то выдаем снова отрицание.
Соответственно, баланс точно будет не больше, чем число символов.
А раз баланс не больше, чем число символов,
то это значит, что на него уходит как раз логорифм от числа символов,
то есть память как раз какая нужна.
Так, ну можно не записывать, да?
Да, с двумя парами скобок уже нифига не работает.
Ну, с двумя парами скобок не работает такая простая вещь,
но на самом деле работает.
Значит, пар бра, это parenthesis, это круглые скобки, а брекетс квадратные.
Значит, здесь два недоскобок.
Любой какой язык?
Ну, нет, на самом деле...
Да, я не знаю. Это у вас такая теорема была?
Нет, там еще раз что-то издало, какие-то преобразования.
Ну, в смысле, не просто скобка.
Так, ну давайте с двумя скобками разберемся.
Но проблема такая, что нужно смотреть не только на баланс каждого вида скобок в отдельности,
но и на то, как они друг к другу относятся.
Но дальше идея такая, что для каждой скобки можно найти парную Ей
через тот же самый баланс по одному виду скобок.
То есть если у нас есть, скажем, открывающая скобка,
то мы можем идти, считать, соответственно...
Значит, на самом деле, смотрите, нужно считать две вещи.
Нужно считать общее число шагов. Зачем?
Чтобы потом сюда можно было вернуться.
Смотрите, если два вида скобок, то нужно больше одного счетчика.
Мы не можем никаких меток оставлять на ленте, потому что мы не можем считать.
Но мы можем считать, в каком месте мы находимся.
Завести отдельный счетчик.
Ну или можно поставить метку, но не в виде изменения символа,
а в виде того, что мы просто отсчитываем число шагов от этой клетки.
Поэтому какое-то константное число меток можно поставить.
Соответственно, если у нас есть два вида скобок,
то мы идем слева-направо.
Во-первых, просто считаем шаги, насколько далеко мы ушли.
И во-вторых, считаем баланс по именно скобкам такого вида.
И, соответственно, в первый момент, когда он обратился в ноль,
это закрывающая скобка.
Там критерии на самом деле такое, что, во-первых, у каждой скобки есть парная ей,
и, во-вторых, если посмотреть на участок между двумя видами скобок,
то тогда в нем будет соблюден баланс для другого вида скобок.
И это, как раз, тоже нарушается вот здесь.
Если мы посмотрим этот участок между парными круглыми скобками,
то тут будет одна квадратная, которая, конечно, не сбалансирована.
Ну это, в общем, управляемое место.
Ну а дальше понятно, что делать.
От открывающей скобки мы ищем закрывающую,
и потом идем назад, следя за балансом по другому виду скобок.
Ну и, соответственно, как раз за этим нужен счетчик,
насколько далеко мы ушли, чтобы вернуться туда же.
И еще нужно какой-то глагол, чтобы вернуться туда же.
То есть глобальная программа, что мы идем слева направо,
и для каждой открывающей скобки ищем ей закрывающую.
Нет, почему самую удаленную, самую ближнюю?
Значит, смотрите, можно с самого начала проверить,
что здесь в целом с балансами все правильно,
но если бы мы ищем самую удаленную скобку,
то мы ищем ее ближнюю.
Смотрите, можно с самого начала проверить,
что здесь в целом с балансами все правильно,
чтобы там никаких хвостов не оставалось.
А потом уже анализировать отдельные участки
между двумя парными скобками.
И тут, конечно, это ближайшая должна быть,
то есть та, которая парна именно этой.
Ну, соответственно, есть какой-то один счетчик,
до которой мы уже дошли,
один счетчик, насколько далеко мы отошли от этой штуки,
и третий счетчик, это просто счетик баланса,
чтобы найти эту закрывающую.
И потом можно тот же самый или другой счетчик
использовать, чтобы баланс по другому виду скобок.
В принципе, вообще это можно в один проход делать.
Можно отдельно идти слева направо
и считать отдельно баланс по круглым,
отдельно по квадратным.
И в тот момент, когда по круглым
первый раз баланс обратился в ноль,
то по квадратным он тоже должен быть нулевым.
Ну и ни в какой момент в минус не уходить.
И да, аналогично между квадратными.
Нет, а это мы просто идем слева направо,
вот это глобальный цикл слева направо,
где мы каждые открывающие скобки ищем парну
и проверяем, что между этими парными все балансы совпадают.
Да, ближайший закрывающий, который обращает в ноль баланс,
который начинается отсюда.
Ну это как по индукции по построению доказывает,
что это правильный критерий.
Ну вот, в общем, нужно несколько счетчиков,
и это на самом деле основной смысл логарифмической памяти,
что память логарифмическая, если достаточно
конечного числа счетчика, который в полимерном диапазоне варьируется.
Так, хорошо.
Значит, что еще можно сделать на логарифмической памяти?
Ну, например, двоичная арифметика работает.
Значит, тут будут небольшие различия,
связанные с тем, что если у вас несколько аргументов,
то вопрос, будут ли они на одной ленте
или на нескольких записан, это во-первых.
И во-вторых, если речь идет, например, о сложении,
то тогда еще есть два варианта.
Либо вы проверяете правильность сложения,
что данные А, Б, С, и нужно проверить, что действительно С это А плюс Б.
Либо вам нужно печатать прям С,
и тогда нужно еще отдельное понятие логарифмически вычислимой функции,
а не предиката.
Сейчас, наверное, обсудим, там есть два определения.
Одно определение связано с тем,
что у этой самой логарифмической машины еще есть лента выхода.
На нее можно только печатать, наоборот.
Читать нельзя, значит, можно только печатать.
И, соответственно, на этой ленте нужно печатать ответ,
использовав логарифмическую рабочую память.
Второй подход связан с...
Ну, в общем, через ряд предикатов это определяется,
грубо говоря, что эта бита ответа может иметь три вида.
0, 1, или что слово уже закончилось.
Ну и, соответственно, для трех вариантов ответа
одного бита не хватит, но двух хватит.
Соответственно, оба бита нужно уметь вычислять в логарифмическое время.
Вот, хорошо.
Так, значит, двоечная арифметика.
Но сначала, ну, совсем просто, если это, наверное, сравнение чисел.
Значит, сравнение чисел в двоечной записи.
Вот, как это делается?
Ну, давайте считать, что...
Мы не будем предполагать, что там они в корректном виде,
то есть без ведущих нулей.
Пусть там даже будут ведущие нули,
и они могут быть даже разной длины.
Ну, что нам нужно сделать?
Ну, нам сначала нужно найти, где там старшие единицы.
Вот, значит, это даже...
Сейчас, это можно делать даже ничего не записывая,
а просто идти с мальших разрядов.
Соответственно, да, где стоит единица,
то есть как бы текущее большее число.
Вот, если и там, и там стоит единица в новом разряде,
то как бы текущая одинаковая.
Вот, и так мы идем, пока оба числа не закончатся.
Вот, значит, если у одного числа более старшие единицы,
значит, нам и больше.
Вот, если они в одинаковом разряде,
то тогда нужно, как полагается, идти теперь к более младшим
и сравнить лектик графически.
Искать первое разночтение.
Вот, и тут, значит, если они на разных лентах,
то тут вроде даже логихмической памяти не нужно,
а вообще константной будет достаточно.
Сейчас.
Мы идем еще сначала.
Если они на одной ленте ленте будут просто узнавались...
Если на одной ленте, то они записаны через пробел,
и тогда нужно все время ходить туда-сюда, сравнивать эти разряды,
а чтобы разобраться, куда именно идти, нужны счетчики.
Есть еще способ написать, что чередую разряды.
А, чередую разряды.
Да, если чередует, то это очень удобно, конечно.
Не нужно никуда бегать.
Да, если чередует, то даже автоматное получится.
Ну, типа того, да.
В общем, разобрались, да, можно не рисовать.
Так, хорошо, значит, сравнение более-менее очевидно.
Так, сложение.
Зачем договариваться, когда во всех случаях получаются логерестнические?
Нет, каких-то, да.
Если чередует на двух лентах, то вообще константная память нужна.
Сложение тоже к константу, опять же, если две ленты, или если чередует.
Ну да, если чередует на двух лентах, то вообще константная память нужна.
Сложение тоже к константу, опять же, если две ленты, или если чередует.
Просто обычный алгоритм в столбик.
Вообще, кстати, долгие века алгоритмами назывались именно методами сложения и умножения в десятичной записи.
Это, собственно, от имени Альхаризми произошло, и его труды были переведены на латинский,
где там фамилия автора как-то переделалась в существительное, просто алгоритмис или как-то так.
И, соответственно, алгоритмами долгое время называли именно вот это, как складывать столбик и так далее.
Но потом уже, во времена Эйлера и Гаусса, уже более-менее современное понимание постепенно пришло,
и более сложная теоретика числовой манипуляции.
От числа, конечно, лог-лог.
Когда мы говорим про лог-память, мы считаем логарифм от длины записи.
То есть тут n битов, число 2 в степени n битов и логарифм n памяти.
Если разные ленты, то даже логарифма не нужна, опять константа.
Потому что мы просто идем с мальчик к старшим, складываем, переносим, и все как полагается.
А неважно.
Если нам нужно вывести ответ, то мы идем с мальчиках разряда, складываем, храним только бит переноса.
Да, если нам нужно проверить, то мы просто то, что должны сейчас напечатать вместо печати, сравниваем с тем битом, который у нас в предполагаемом ответе есть.
Да, мы не будем сохранять. Все, что мы сохраняем, это есть у нас перенос предыдущий разряд или нет.
То есть мы, в случае складывания, считаем, что у нас 3 полноделки для чтения, для записти и для работы.
Ну, типа того, да.
И считаем только то, что на работе.
Так, давайте мы про умножение поговорим, потому что это немножко более хитрая вещь.
Если умножать в столбик, как в школе, то там даже не то, что логорист, а n в квадрате будет память.
Такая квадратная табличка.
Ну да, соответственно, можно не записывать, но констант это все равно не обойдешься.
Что здесь получается?
Так, вы старшие биты хотите маленькими дексами, или большими?
Большими.
Большими, да. То есть тут а n, а n-1 и так далее.
1 давайте a0.
Мы это умножаем на b.
Пусть для простоты точно такое же число, но нулями дополним.
Да, ведущими нулями дополним, чтобы было одинаково.
b1, b0.
Соответственно, все a i и b i это просто биты.
Вот, и тогда что здесь получается?
Ну получается, что здесь, если это 0 или единичка, то либо мы просто копируем то же самое число, либо просто все нули.
То есть тут что-то такое получается.
Ну, значит, на самом деле будет там а n умножить на b0.
Значит, скажем b0 это 1, а b1 это 0.
Ну и так далее.
Дальше мы все суммируем.
Соответственно, ответ как будет выглядеть?
Можно побитого записать.
c0 это будет просто a0 b0.
Да, значит.
А, слушайте, давайте лучше s. s от слова сумма, а c будет от слова carry переноса.
Значит, s0 это a0 b0.
Дальше s1 это будет a0 b1 плюс b1 a0.
Вот, ну от этого a0 b0 переноса не может быть, а от этого уже может быть.
А если здесь получилось 2, то, соответственно, сюда получается еще бит переноса c1.
Соответственно, s2 это будет a0 b2 плюс a1 b1 плюс a2 b0 и еще плюс вот этот c1.
Вот, и это в принципе даже 4 может получиться.
То есть даже не в один следующий разряд, а в два следующих может получиться перенос.
Но мы будем считать, что просто в предыдущий переносится как бы 2.
Ну и так далее.
Значит, и так далее все это будет вычисляться.
Соответственно, смотрите, получается, на катом уровне вот эту сумму мы можем вычислять, имея логографическое число счетчиков.
То есть нам нужен счетчик, чтобы запоминать, с какого места мы сейчас начинаем складывать.
Мы можем считать, что у нас, скажем, один счетчик вот здесь, и мы так идем навстречу друг к другу.
И, соответственно, перемножаем, складываем.
Плюс еще добавляем перенос предыдущего этапа.
Ну да, после этого, как бы, четность это в ответ.
Вот такая большая сумма получилась.
Значит, ее четность это очередное скт.
А целая часть, половина, ну, в общем, все, что как бы без последнего бита, четность это и есть последний бит.
А все остальное без последнего бита.
Значит, это получается перенос на следующий раз.
Ну и что же получается? Получается, что все эти биты будут не больше, по размеру все эти переносы будут не больше n.
Нет, значит, 2n это уже сумма получится.
Потому что, смотрите, вот эта часть не больше n, потому что здесь не больше n слагаемых.
Ну n плюс 1 там может быть, если я так начал.
Вот, значит, вот эта часть не больше n по предложению индукции, значит, сумма не больше 2n.
А тогда, когда мы последний бит уберем, то снова будет не больше n.
Кстати, даже n плюс 1 здесь не сломает ничего, потому что n плюс 1 и еще plus n, 2n плюс 1.
Но уберем последний бит, все равно не больше n получится.
Соответственно, значит, перенос не больше n.
Для остального нужны счетчики, где мы тут находимся.
И, соответственно, хранить нужны эти счетчики и перенос.
Вот логорифмены получается.
Ну опять же, сколько точно, зависит от того, храним мы это на разных лентах или на одной ленте.
Да, логорифмены – суммарная память.
То есть должна быть константа счетчиков и каждый счетчик в полиномеральном диапазоне.
Если будет так, то это логорифмическая память.
Ну что, с умножением тоже понятно.
Ну ладно, тогда давайте что-нибудь посложнее.
Давайте я сразу сформулирую очень сложную теорему.
Я ее доказывал на спецкурсе, но это прямо на много лекций.
Там 4-5 лекций на спецкурсе.
Но сформулировать ее несложно.
Теорема Рейнгольда заключается в том...
Это, конечно, очень большой контраст по сложности, но формулироваться она легко.
Если мы рассматриваем задачу достижимости в неориентированном графе.
Она обычно называется U-path.
Undirected path – неориентированный путь.
Это множество троек G,S,T таких, что в неориентированном графе G есть путь из S в T.
Мы все хорошо знаем, что она лежит в P, но оказывается, что она лежит и в L.
И тут видно, почему это сложная теорема.
Все алгоритмы, которые вы знаете, связаны с тем, что мы ходим по всему графу и там какие-то метки оставляем.
То есть, грубо говоря, использованная память примерно равна размеру графа.
Оказывается, что можно так не делать.
Конечно, это будет ценой большего числа хождения по графу.
Но оказывается, что можно так хитро его обходить, так что хранить совсем немного данных и так, что все равно проверить.
Я могу чуть-чуть сказать, какая там общая идея.
И заодно это будет такая удочка в следующую тему.
Смотрите, есть алгоритм рандомизированный.
Как рандомизированный проверить, есть путь из S,T или нет?
Запустить просто случайное блуждание.
У вас случайных процессов еще не было? Что такое марковский процесс, вы не знаете?
Ну ладно, тогда надо поверить.
Надо, конечно, считать, сколько мы шагов сделали.
Нам нужно доказать, что если путь есть, то если мы сделаем, скажем, N в четвертый шагов,
то мы с очень большой вероятностью все достижимые вершины посетим.
Это не совсем тривиально, но и не очень сложно.
Может быть, мы на лекции про вероятность это обсудим.
Смотрите, тут то, что называется одностроенная ошибка.
Если пути нет, то если мы сделаем, хоть и на четвертый, хоть и на десятый шагов,
то мы совершенно точно не достигнем вершин, до которых пути нет.
Но если путь есть, то нужно сказать, что с вероятностью, скажем, 99%
во время случайного блуждания мы до той вершины дойдем.
Так вот, что показал Рейнгольд.
Для такого алгоритма, очевидно, нужна алгоритмическая память,
потому что нам просто нужно хранить предыдущую вершину и случайно выбирать следующую.
Тут зависит от того, как именно грамм записан.
Если есть список ребер, то можно выбирать случайно ребро из этого списка.
Если это матрица смежности, то удобнее брать вообще случайную вершину
и дальше смотреть, есть туда ребро или нет. Если нет, то брать другую случайную вершину.
Но может быть, так получится немножко дольше.
Уф-то должно быть N в четвертой, а бросаний тут N в пятой получится,
если одно ребро выходит, то нужно N раз в среднем кинуть, пока мы на него наткнемся.
Соответственно, тут нужна алгоритмическая память,
потому что нужно несколько номеров вершин хранить.
Рейнгольд показал, что можно этот алгоритм дерандомизировать,
то есть на похожих идеях построить детерминированный алгоритм.
Это очень интересная большая тема дерандомизации,
можно ли в принципе вероятностные алгоритмы превратить в детерминированные.
Но может поговорим на эту тему на последних лекциях немножко.
Что с теоремой Рейнгольда следует?
Например, что связность тоже лежит в L.
Если рассмотреть связность в неориентированном графе, то это тоже, конечно...
Сейчас, я не дописал теорему, я сказал, но не написал, что это лежит в L.
Связанность тоже лежит в L, но почему?
Потому что можно просто перебрать все вершины, и это еще пара счетчиков.
А может даже еще проще сделать, можно вести один счетчик и для каждой вершины проверять, что есть путь в следующую.
Если из каждой есть путь в следующую, то из любой есть в любую.
А из последней в первую еще нужно проверить.
U-кон, U это undirected, con это connectivity, то есть что граф связан.
Если мы умеем на логотипическом планете проверять для любой пары вершин, то можно либо вообще все вершины проверить,
либо для каждой вершины проверить, что есть путь в следующую.
Тогда есть из любой в любую.
Есть еще некоторые, например, можно двудольность проверять, или, скажем, оцикличность.
Сейчас давайте как раз про оцикличность поговорим.
Как проверять оцикличность или, наоборот, цикличность?
Что такое вообще цикличность? Это означает, что есть какое-то ребро,
что если его из графа удалить, то все равно останется путь между этими вершинами.
Оцикличность означает, что такого нет.
Как это проверять?
Можно много раз запускать UPS для исходного графа без одного ребра.
А как его запускать?
Если алгоритм решения вот этого запрашивает, есть ли такое ребро,
то мы смотрим, не совпадает ли это ребро с удаленным.
Если он совпадает, то говорим нет, а если не совпадает, то отвечаем то же самое, что в исходном графе.
Это совсем небольшое изменение.
Нужно перебирать просто все ребра.
Граф, который связан и без циклов, мы знаем, как называется.
Это дерево. Дерево тоже лежит в L.
Удивительным образом, оказывается, что вот этот последний факт можно доказать проще,
не ссылаясь на тюрем Рейнгольда, а из некоторых простых соображений.
Можно доказать непосредственно.
Сначала такая неформальная картинка.
Пусть есть какое-то дерево.
Вот есть какое-то дерево.
Я немного жульничаю, нарисовав его на плоскости.
Вот так его можно обходить.
Получается, что каждое ребро будет пройдено два раза.
А если тут есть какой-то цикл,
и мы начнем вот так вот обходить,
то получится, что мы некоторые ребра пройдем только один раз.
Такое, на самом деле, будет верно, если мы это действительно расположим на плоскости,
и сможем так обходить по правилам левой руки.
Но если игра вообще будет не планарной, то прямо так обходить не получится.
Это как бы идея.
Если мы сможем сказать, что это за обход,
то надо проверять следующее. Во-первых, что число ребер на один меньше, чем число вершин,
это мы сможем проверить, и это для дерева должно быть верно.
Во-вторых, что такой обход делает шагов в два раза больше, чем ребер, прежде чем вернется на исходное ребро.
На самом деле проблема с формулировкой, что это за обход не геометрически, а абстрактно.
Я, наверное, сразу раскрою все карты, что на самом деле, если там будет не один цикл больше,
то при формулировке обхода он может и для недерева тоже каждое ребро пройти два раза.
Поэтому мы проверяем на самом деле три вещи.
Первое, что число ребер это число вершин минус один.
Второе, внимание, что нет изолированных вершин.
Нет изолированных вершин.
А что значит, что если у вас число ребер на один меньше, чем число вершин,
и нет изолированных вершин, если при этом не дерево, то значит там хотя бы две компоненты связности,
в которых есть ребра. Вот почему это важно.
Есть две компоненты связности, и в обеих есть ребра.
Ну а третье, это уже условий на обход.
Ну вот как устроен обход.
Смотрите, когда у нас просто граф записан списком ребер или матрицы, то у нас там нет никакого вложения в плоскость.
Ну что у нас есть? У нас есть номера вершин.
В любой вершине есть естественное направление по номерам вершин.
То есть там вот это ИТ, вот это ЖТ, это КТ.
То это естественный порядок. И потом Ж, потом К, потом по циклу снова И.
Да, совершенно верно.
Обход такой, после ребра и Ж,
Смотрите, хотя сам граф не ориентированный, но обход ориентированный, в обходе ребра со стрелочками.
После ребра и Ж идет ребро ЖК.
Такое, что К это будет минимальное из тех Л, которые больше И, таких, что ребро ЖК есть.
Где вот это минимальное понимается по циклу. То есть мы идем и плюс один, и плюс два, и плюс три и так далее.
Если до Н дошли, и ни одного нету, то соответственно идем с единицы.
В самом крайнем случае, если Ж это вообще висячая вершина, то мы придем снова к И и пойдем обратно.
Соответственно, этот обход должен сделать два умноженных число ребер, прежде чем вернется на исходный ребро.
Значит, обход делает два умноженных число ребер шагов до воздушного.
Но, соответственно, для всего этого нужна рифмическая партия.
То, что это корректные критерии, давайте я оставлю в качестве задачи.
Мне кажется, это полезно подумать.
Значит, нужно ждать, что до дерева он сработает, что дерево будет распользовано, как он здесь нарисовывается.
Что будет для ни дерева неважно, потому что проверяем наисторежные вершины.
Потому что, смотрите, если больше, чем столько, он точно не может сделать.
Потому что у нас столько ребер, и каждый в двух направлениях может быть поединат.
А если повторилось, то уже до возврата, то есть до повторного.
Это, в принципе, диреклия.
Ну, не понятно, почему оно повториться не может.
Ваня, как мы проверяем, что мы пришли в конец?
Нет, нам нужно еще хранить самое бедное ребро.
Хорошо, мы хранили ребро, но непонятно, почему мы не можем социклиться где-то под ним.
А, в смысле, почему циклы будут обязательно без предприюта?
Да.
Ну, надо доказать дальше.
На самом деле, потому что это обратимо.
То есть в обратную сторону делается то, что так же.
Ну, не очевидно даже, что обратимо.
Ну, не очевидно, да.
Ну, вот задача какая-то.
Ну, можно, наверное, сказать, что-то странное.
Ладно, да, сейчас сделаем перерыв, и потом я правильно хочу уйти.
Давайте.
Значит, Энель.
Значит, Энель означает новый трибунный тепловый спейс.
Да, значит, не натрагинировал.
У меня, очевидно, делается ежевеса.
Да?
У меня, очевидно, делается еда.
И едульку.
Да?
Ну, реалитированный пылок.
Да-да.
Значит, бой-то это будет Энель Пол.
Знача?
Мол.
Значит, П.
То есть, нам только G, S, T.
Такая, что в ориентированной грани.
G, еще двой.
Куть.
И дальше как?
А, нам как-то, короче, ориентировать в неориентированную грани,
или это то, что мы, типа, в неориентированной грани
в неориентированную грани не может, случайно,
вождание тебя испортит, случайно.
А в ориентированную мы туда пойдем,
и дальше, поэтому, тут только,
все тебе не сможет выйти обратно.
Да, значит, рандомизируемо алгоритмы.
Да, алгоритмы можно вообще выйти
в неориентированную связанность.
Ну, да, то есть, у нас обратимый процент в съемке пас.
Да.
Да, точно.
Значит, в ответ мы можем вообще выйти никуда.
Да.
И во-вторых, даже если есть случайное вождание,
да, то может быть такой, да?
Да, в общем, пограется кучка.
Вот.
И тут каждый будет, значит, вот так.
Да, да?
Вот.
И тайна, соответственно, чтобы,
тут как бы не теряется возможность пройти
к конецу.
Да, да, да.
Вот.
Но дело в том, что если я делал нечаянно,
да, то, соответственно,
много раз подряд,
одинаковый момент.
Да?
Ну.
Хорошо.
Вот.
Ну вот.
Не на терпенизм позволяет ценить правильность.
Да.
Но,
как бы каждый раз идем не на терминировано,
да, если ветка есть,
в графе.
Да, если есть путь в графе, то есть ветка в вычислении,
которое было по этой пути.
Вот.
И более, да,
значит, интуитивно, почему плет – это наиполная задача.
Значит, наиполная.
Потому что можно рассмотреть наш великий интуитивный граф.
Да, значит, можно,
то есть любая интуитивная задача,
любая интуитивная задача
сводится
к поиску пути,
к поиску пути
в лакомственном графе.
Вот.
Надо только об этом сказать,
в каком смысле, собственно, сводится.
Да, потому что понятно, что наш старый сегодня пуск не годится.
Вот.
Ну, значит, вообще,
так,
значит, насколько нас интересуют вопросы про Эй и Эмей,
да,
Эй и Божий и Эмей,
то всегда
смысл один и тот же,
да,
что мы смотрим на сводимых, которые большего класса,
а сама сводимых будет меньшего класса.
Да, то есть тут должна быть географическая своденность.
Вот.
Ну, вот сейчас вкратце обсудим
два варианта понятия географической храницы.
Вот.
То есть так, в целом,
в этом линии,
точно такое же,
что сводимость не подменяет на географическую.
Ага.
Так.
А,
то, значит,
а,
логеретическую сводьбу В,
где-то вот тут,
ну, есть
логеретическую сводьбу В.
Вверх
настоят логеретические сводьбы X,
будут скоммунированы
географические храницы,
там географика не подменяет на храницы,
но будут.
Ну, теперь, что такое логеретические вычисления?
Ну, я в храническом языке уже говорил,
давайте спешим.
Логеретические вычисления.
Значит,
первый вариант определения
такой, что есть машина,
есть
машина,
значит,
с
одной входом вентой,
значит, с одной
входом вентой,
значит, с одной работой
и одной выходом.
Так.
Значит, это использующая
логеретический пальц на рабочей ленте
и
печатающая фрадыкс на выходной,
значит, ну,
слева.
Использующий
логеретический пальц
на рабочей ленте.
Ну, печатающий
фрадыкс
на выходной,
значит, слева.
Так.
Ну, при этом понятно, да?
Это определение один,
значит, определение два,
что есть
два языка,
выжащие
Так.
Значит, такое язык,
потому что пар
х
и х,
значит, таким,
что
х
меньше
х,
значит,
такой язык
выжащий.
Сейчас.
Нет, это
ну,
очень важно,
за этим
очень важно.
Вот.
И, соответственно,
ну, такое вот
язык,
и
язык из ката,
что
просто ката,
вид, как вот
разумеется,
то же же.
Так.
Значит, чуете,
я тебе не говорю?
Так.
Значит, определение кавалюты,
ну, значит,
главное, что
давайте сначала из второго в первое.
Значит, из второго в первое
мы просто,
значит,
запускаем
вычисления.
Ну, да.
Сначала
спрашиваем,
верно ли,
что длина и фаты
вышедшую на единицы?
Если не верно,
значит,
на где-то будет
то и слово,
мы его печатаем.
Ну,
сразу остановимся.
Если
на этой
большинстве на единицы,
то мы смотрим
на первый бит.
Да,
спрашиваем,
вот,
по этой программе
первый бит район единицы
мы его
упечатаем.
Дальше
спрашиваем,
верно ли,
что длина хотя бы 2?
Если не верно,
значит,
то, что напечатали,
это ответ,
и это наоборот.
Значит,
если верно,
пока ответ
не закончится.
Значит,
запечатаем
на выходную ленту.
Читать нам
оттуда
не нужно.
Да,
ничего
переправлять
не нужно.
Рабочее
пространство
каждый раз
используем
одно и то же.
Сейчас,
а это
сводимость
по кому?
Ну,
это
лагерезническая
сводимость
по карту.
То есть,
нам по карту
лагерезническая.
Вот.
Ну,
вот.
То есть,
нам можно хранить
счетчик
какой-то
кущей Х
и плюс
парой,
чтобы
числять
вот это вот
и вот это вот.
Значит,
она
все это
будет
электрическое.
В основном,
как-то
органично
длина
отыгрывается.
Просто,
если она
в конфигурации
содержится,
то
это
вообще
правильный
вопрос.
Вообще,
наверное,
да.
По
второму
мнению,
нужно
сгорать
варианты.
Потому что
в первом
она
автоматически
будет
предминальная
просто из-за
числа
конфигурации.
Потому что
что
не
можно
напечатать,
не влияет
на конфигурацию,
не
влияет
на
конфигурацию
и
длина
отыгрывается.
Вот.
Значит,
здесь,
наверное,
да,
она
будет
потребоваться
для
длины
отыгрываться
детективно,
либо
требовать,
чтобы
этот
логариф
был
не
откатан
отыгрывается.
Да,
значит,
это было
из
второго
певца.
Ну,
как раз
длина
ограничена,
по-любому,
да,
то,
как
будет
логарифмически,
да,
и все
это
будет
логарифмически.
Вот.
А
в обратную
сторону,
ну,
тоже понятно,
да,
значит,
тут
вот.
А
здесь
можно
просто
ждать
катего
гита.
Вот.
Если
дождались,
то
это
не
будет.
Если
закончилось
раньше,
то сказать
нет,
ну,
это
в принципе
не
важно.
Вот.
Ну,
а
силы нет
так.
Ну,
чего?
Примерно понятно,
да.
Сейчас,
я не могу понять
второе
проверение
сейчас-то.
Нет,
ну,
смотри,
значит,
у нас
смысл
такой,
что на
уровне
количества
памяти
можно понять
ответ
длиннее
данного
порога
или короче,
а если
длиннее,
то
вот,
естественно.
Да.
Угу.
Так.
Ну,
хорошо.
Так.
Ну,
теперь,
значит,
то,
что
то,
что
без
этой
энергии
полная,
это
в принципе
развитием
на
более-менее
очевидно,
надо только
сказать,
что
сводимости
горизонтическая,
и это
довольно
техническая
вещь,
значит,
я
это
отпущу.
То есть,
нам
нужно
аккуратно
показать,
что
конфигурационный
граф
по
исходному
входу
мы
понимаем.
Вот.
Тут,
конечно,
просто
я
не
граф
записываю,
но
в
я
матрице
смешности.
Надо как-то
договориться
о
том,
как
мы
кодируем
конфигурации,
и
дальше
нужно
объяснить,
что
в духе
второго
контурина,
для сколько
состояния,
да,
сколько
того,
как
это
мы
посчитали.
Вот.
И дальше,
чтобы понять,
какой
символ,
фактически это означает,
что
мы
на
всю
матрицу
смежности,
то есть,
нам
было
двум
конфигурации,
надо понять,
есть
конфигурация,
но
в
проекте
все
почти
одинаковые,
кроме
маленького
фрагмента,
который,
соответственно,
меняется
разным
значением.
Вот.
Ну,
тут
куча
каких-то
технических
деталей,
как мы
записываем
конфигурацию,
как мы
сделаем
фрагмент,
как проверяем,
домовые
состояния.
Вот.
И это
даже,
наверное,
будет
повторно
нагореть.
Четче,
потому что
у нас
стилон
нагореть
надо длина
в символах.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Сейчас,
а может,
вот в Афхин
даже
ничего
сложного
не нужно.
Смотрите,
тут есть такая
фишка,
что даже
если у вас
нагоритмическая
память,
но при этом
конкретный вход
тоже
нагоритмический,
то с этим
входом
можно как вообще
все,
что угодно
делать,
ну,
что требует
понимания
памяти.
Вот.
Да,
даже
не нужно
технических
деталей,
а просто
сказать,
что у нас
как бы
номер
вершины
графа,
он же
является
входом
конфигурации.
Да,
он
занимает
алгорифы
гитов.
И
второй
номер
тоже
занимает
алгорифы
гитов.
Вот.
Ну,
а
то,
что
мы
можем
провести
корректный
переход
на
линейную
память,
да,
все,
что
может быть
на
линейную
память,
с такой
конфигурацией,
мы можем
сделать.
Вот.
Ну,
а что,
чтобы
мы
могли
в
следующий раз
выскажу,
нам
по крайней мере
понадобится
следующее.
Значит,
нам
понадобится
альтернативное
определение
ANN
через
сертификат.
Альтернативное
определение
ANN
через
сертификат.
Вот.
С
ANNB
было
очень
удобно.
Да,
значит,
были
ненавидимированные
машины,
значит,
были
сертификаты.
Вот.
Но если
вы возьмете
просто
определение
ANNB
через
сертификаты
и
заметите,
например,
время на
линейную
память,
то у вас
получится
все
равно
ANNB.
Да,
значит,
конечно,
на самом деле
проверять
на
скажем,
формулу
в 3KNF
и прямо
в данный
список значений.
Вот.
И вам нужно проверить,
что эта формула
на этом
списке
истинная.
Ну,
что вам
фактически
нужно
делать?
Ну,
вам нужно
читать
эту формулу
по одной
скобочке,
да,
смотри,
какие там
применные,
да,
там
есть
еще
несколько
счетчиков,
чтобы
ходить
туда-сюда,
значит,
между
формулой
сертификатом.
Да,
то есть это
будет
логеристическое.
Да,
логеристическое
дополнительная
память.
Вот.
Значит,
это будет
неправильное
определение.
Значит,
это тоже
правильное определение.
А
значит,
будет
входная
элемента.
Значит,
это
будет
только
для
счетчика.
Значит,
будет
следующая
элемента
сертификата.
Ну,
что вам
нужно
делать?
Ну,
что вам
нужно
делать?
Ну,
что вам
нужно
делать?
Ну,
iser
asteroids.
И
rainbow
Inter comics.
Вот.
И
будет
соответственно
рабочим.
Там
будет
?
Ммм.
Jason
ptions,
да,
вс mega
bra.
Сп takiej
арте
конк facing
по
subd realize,
Ну и, значит, машина для чтения и для записи.
Ну вот, соответственно, будет, как на управляющий
блок, будут указать на направлении.
Нет.
Ну, наверное, здесь, когда указатель может
убедиться и налево, и направо, он не может
записываться.
А вот этот вот указатель, только слева направо
может быть.
Ну, это, конечно, стоит.
Вот.
Ну, и после этого будет точно такое же.
То есть, это зрение, что там A на жидкость
D, светло существует, лагеринческая маска
дюлинга вот такого вот вида.
Значит, такая, что, значит, тогда и что?
У любого X будет верно, что у слева два.
Тогда и только тогда, когда существует
у, такое же, когда у проявляется.
Так.
Значит, почему это то же самое?
Ну, мне понятно почему, да, что вот в такой
формулировке уже получается, что доказательство
экваленции примерно так же, как в NP.
Ну, как это?
В одну сторону.
Значит, мы же у нас есть такая машина.
Значит, тогда нетерминированный аналог будет работать так,
что просто, когда нам нужно прочесть следующий
мексиканский хаха, мы будем нетерминированно
брать либо ноль, либо единичку.
То есть, вместо счетения след, ну, мы просто
нетерминированно браться.
Ну, и тогда, если он существует, то тогда мы
на какой-то вес вычисления ровно его и возьмем, да,
вот другую сторону.
Значит, другую сторону, если нетерминированная,
то здесь мы ровно сертификат записываем,
по какой ветке идти.
Да, то есть, например, для задачи ПЭС
сертификат просто сам в пути есть.
То есть, нам поддают, чтобы пэс плывет в этот
дырах и две вершины.
Значит, дырах и две вершины.
Значит, игрек это кончит.
Вот. А вы, Алексей, проверяете карьерный способ?
Значит, так проверять карьерный способ.
Ну, нужно вспоминать там будущее, шевелить и кушать.
И проверять, что, соответственно, это ребро есть в графе.
Вот. Если нет, то отвергаем сертификат.
Если есть, то предыдущего времени текущую,
текущую читаемую сертификата, ей снова проверяем.
Ну, и так далее.
Соответственно, вот нам нужно хранить там две вершины.
Ну, и вот еще какие-нибудь счетчики небольшие.
Нам нужны счетчики, чтобы проверять, что есть ребро.
Ну, это тоже там еще пара счетчиков.
Вот. И поэтому это будет логическое.
Так.
Ничего. Понятно?
Логническая память.
То есть память, она рабочая идентина.
Не здесь, не здесь, не считается.
Память, считается, она забавная.
Хорошо.
Но теперь, к чему эта вся подготовка?
Значит, вот есть такая теорема
им. Мана Солепчения.
Солепчение – какое-то венгерское имя.
Я все время забываю, как оно пишется.
Это очень странно.
Сейчас, может быть, вот так вот.
Может быть, вот так вот.
И какие-то там еще точно есть диагнетические знаки.
Если венгерский не изучать, то это невозможно.
Помните?
Так вот, начнем чему теорема.
Значит, теорема в следующем.
Что n и n равняется coin и n.
Значит, coin и n мы пока не изучали,
но язык нам не выделяется.
Да, значит, это дополнение к языкам из n и n.
Ну и, соответственно, достаточно доказать,
что дополнение к p,
значит, p в чертовой режим в n и n.
Как раз за счет того, что p в n и n полный,
то если он будет и в coin и n,
то есть это то же самое, что дополнение к p в n и n,
то сразу все из coin и n лежат в n и n,
и наоборот тоже получится.
Так, ну что, понятно, почему это достаточно?
Ну, например, как с n и p.
Если coin и p полный язык лежит в n и p,
то n и p равно coin и p.
Значит, здесь точно не так же.
Ну вот так.
Вообще сейчас может немножко и успеем,
может не целиком, еще 8 минут.
Давайте обсудим.
Можно каким-то образом составить сертификат.
Значит, можно составить сертификат,
который будет доказывать, что пути нет.
Значит, как даже пути нет.
Так, что я этим показал?
Значит, как доказать, что пути нет.
Ну, смотрите, можно просто,
если мы откуда-то знаем,
сколько всего достижимых язык,
то можно предъявить такое число достижимых,
среди которых нет t.
Ну, про каждую мы заказали число достижимых.
Да, смотрите, доказывать достижимых мы умеем.
Если мы знаем число c,
доказательства,
значит, если знаем
число c,
вершин
достижимых из s,
то можно доказать,
что можно доказать недостижимость.
Т.е. просто предъявить,
предъявить c различных
достижимых языков,
различных
достижимых вершин
из s,
среди которых нет t.
Так, как это делается?
Значит, тут вот
различные, это
очень важные условия,
чтобы все были разные.
А мы не можем всех хранить
на всякой технической партии.
Ну, а что мы можем?
Мы можем их предъявить в отсортированном порядке.
Т.е. можно прям
рассмотреть v1 меньше v2,
меньше и т.д.,
меньше vc,
начиная с достижимых вершин.
Значит, и сертификат
будет быть где-то так.
Значит, v1,
потом, соответственно, путь
из s в v1,
значит, потом v2,
потом путь
из s в v2,
и т.д.
Нам будет даже не важно, да?
Что?
Нам будет даже не нужно, как-то сказать.
Нет, почему?
Мы же должны проверять, что мы достижим.
Мы же умеем сами проверять, что мы достижим?
Нет, сейчас, смотрите, я
прошу программу сертификата.
Я прошу вот эту нервную программу
сертификата.
Потому что
мы не будем взмешивать два подхода,
если сертификат не интервенируется.
Соответственно,
сертификат мы умеем проверять,
если мы его напечатаем.
Значит, v1, потом
путь с v1, v2,
и т.д., значит, vc,
и т.д.
Значит, как это проверять?
Ну как?
Нужно вспоминать предыдущую вершину,
проверять путь,
и потом проверять, что новая машина
больше, чем предыдущая.
Ну и что не совпадает с t.
Вот.
И так, соответственно, старую забываем,
новую дверь записываем,
проверяем путь,
читаем новую, проверяем, что она больше,
не совпадает с t, и так далее доходим до конца.
И еще у нас есть счетчик, сколько
и т.д. И нужно, чтобы в конце этого счетчика
совпался не в самом центре.
Вот.
Хорошо. Ну, а ответственно вопрос
о том, кто цель взять.
Ну, значит, дальше
идея такая, что
мы, значит, кроме
c,
просто достижимых, рассмотрим, может быть,
число достижимых
путем, ну, конвертной длины.
Да, то есть
cхt,
значит, это число
достижимых
причем длины
не больше k.
Не больше k.
Тогда c равно есть c.
Да, потому что если путь есть, то есть простой путь,
который не больше
отверший.
Значит, c равно c.
Вот. А c0
мы все это знаем, да, c0
это единица.
Ну, значит, c0 это единица.
Вот. И, соответственно,
нам вот так же получиться
предъявление
спирика при
известном цейте, статикат, что цейт
т.д.
То есть нам нужно написать
предъявление
т.д., значит,
при известном
и известном цейте.
Если мы это умеем, то более непонятно.
Дальше, соответственно,
c0 мы знаем, значит, c1
считаем, не забываем, то далее cn,
а cn дальше тоже надо
получить.
Да, так все это раздается.
Вот. Но, соответственно,
вот, основной вопрос,
значит, как спирит при этом.
Дело в том, что
мы можем
предъявлять
как сертификат достижимости, так и
сертификат недостижимости.
Вот этот сертификат
это набор
сертификатов,
значит,
сертификатора
достижимости, нет, достижимости
не достижимый.
Значит, ученый и плюс один
для всех вершин.
Может, так сейчас
значит, ученый. Так, сейчас
дому и плюс один
для всех вершин.
Мы сейчас там, соответственно, достижимы в краю.
Сейчас! Приизвестны в ЦИ.
Сейчас, давайте я за пару минуток скажу.
Достижимысть, это понятно. Достижимысть, это просто путь.
Надо только проверить, что мы уже недели,
это мы еще чуть-чуть замедленные и посчитаем тут.
Достижимысть.
И это просто путь.
Путь длины не больше,
не больше, чем И плюс один.
Потому что у нас ЦИ плюс один уже.
Значит, недостижимысть.
Это вот примерно как мы там сделали.
Значит, смотрите, мы знаем ЦИТ.
Мы знаем ЦИТ. Это значит ЦИТ.
Различных.
Достижимых вершин.
Пучом длины не больше И.
Значит, пучом длины не больше И.
И мы теперь проверяем, что ни одна из них не совпадает с данной.
И ни из одной из них нет ребрафта.
Значит, которые не совпадают с данной.
Не совпадают с данной.
И из которых нет ребрафта.
И вот это мы как раз позволили отмечить еще что-то.
Да, что не только сама межинка достижена.
Она не достижена за И, она не достигает.
Значит, она не достижена за ВСН.
Ну а дальше о чем собирается.
Например, у нас будет сертификат.
Там уже длина будет сертификата С4.
Потому что у нас ЭН этап пока ВСН считает.
Эн этап для интерсертификата.
Но сертификат на достиженности тоже не убирает квадрат.
Ну, если цепь достаточно большая, будут длинные пути.
И их будет тоже достаточно много.
Ну, соответственно, дальше мы это все прочтем.
И все правильно.
А потом в итоге мы посчитаем СН и добавим еще этот сертификат.
И получается, что мы можем достигать недостижения.
Вот, значит, вот такая хитрая конструкция.
Но для НТВ и КМП ничего такого нет.
А в оконнеле равно кое-что.
Так, ну ладно, какие-то вопросы остались.
Вы на первой лекции говорили, что интервью дальше одна.
Так, значит, что QR не равно NB.
Это, ну, по слову, значит.
Нет, это... так, это просто...
Так, когда-то не нужно коммунировать.
Ну, понятно.
Ну, QR, по-моему, плодно.
Да.
Ну, это то, что...
Нет, то есть нормально.
Мы предъявляем алгоритм, в котором решаем, ну, какую-то из интересных задач.
Ну, какую-то из интересных задач заклинован.
И вот он и проверяет, соответственно, наш алгоритм.
А это значит, что алгоритм работает?
Нет, это конечно.
Это значит, что работает?
В общем, работает.
Да.
Но там алгоритм работает лишь, когда там алгоритм работает.
А, ну какие-то препятствия предоставляются или нет.
Вообще неприятно, вот и иначе.
Надо поискать.
Надо поискать, но вообще...
Некоторые исследователи, они вообще сомневаются, что они не равны.
Да, вот, как говорят.
NL или QL получились равными, да.
Почему NL или QL не равны, так как-то не очень понятно.
Вот.
А особенно, что касательно равномизированных.
Да, то есть почему равномизированные?
Вероятно, если ты равномизированный, то ты чувствуешь себя более чем равномерным.
Это вообще не понятно.
Скорее всего, просто ты не привыкешь, если ты равномизированный.
Да, я понимаю.
Вот.
Да, вообще интересный вопрос.
Надо поискать.
Наверное, что это будет называть?
Ну, хотя я не знаю.
Те методы, которые для PNP, они здесь точно не работают.
Так, ну важно, чтобы подпалили на это время.
Нет проблем.
Ну, что-то кинускально для разных задач.
Красный, да.
Подходы из одной там не переносится.
Не переносится.
Так.
Ладно, давайте заканчивайся, ты уже все время назад.
Спасибо за внимание.
