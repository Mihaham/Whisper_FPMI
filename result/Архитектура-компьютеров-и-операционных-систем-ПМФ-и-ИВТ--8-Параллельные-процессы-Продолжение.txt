Всем привет. Мы начинаем, наверное, пока не понятно последнее или не последнее нормальное занятие в этом семестре.
Ничего пока определенно сказать не могу, кроме того, что рекомендуется, кто не привился, все-таки прививку сделать.
Но и не забывайте, особенно в общественных местах, маски, перчатки это фигня полная, маски это полезно.
Тема сегодняшнее занятие это каналы, которые предназначены для передачи данных одного процесса к другому.
Но для начала нам нужно немножко вспомнить про то, как запускаются программы и разный дочерний процесс.
Итак, давайте вспомним материал двух предыдущих занятий.
Начнем с того, что пишем дурацкую пеленку из огромного количества include файлов, которые, возможно, пригодятся, возможно, не пригодятся, но их много.
Унистэдэст, тогда его, что нам еще обычно бывает нужно?
Систат, файл-контрол, если нам понадобится, open.
Дальше, систат, если нам нужно про что-нибудь, про право доступа.
Так, истэдэст, стат, сиз, вейт, это там, где ожидание процессов.
Ладно, надеюсь, что пока хватит.
Эрнон, точно.
Маленькая программа, которая сделает две вещи.
Запускает какой-то процесс, в этом процессе запускает новую программу.
Ну, примерно то, что было у нас на прошлом занятии.
Для этого нам нужен... Систайпс забыл.
Систайпс – это важный заболочный файл.
Так, у нас есть некоторые дочерние процессы.
Запускаем Fork.
Дальше возможны три варианта.
Fork равен нулю, либо минус один.
Ну, или номер процесса у нас строго больше нуля.
Про обработку ошибок я сейчас не буду подробно останавливаться.
Но вы все помните, что процесс мы можем неуспешно создать, если у нас закончились лимиты.
Так, ну, если мы запускаем родительский процесс, то он должен в какой-то момент дождаться,
пока завершится наш дочерний.
WeightPit – нужный процесс.
Status – с нулими флагами.
Ну, и теперь дочерний процесс, который должен сделать что-то о смысле.
Например, запустить какую-то программу.
Если вы знаете на стадии компиляции опции этой программы,
то exec suffix l.
Если не знаете, то v.
Ну, если хотите запускать что-то из переменной окружения pass, то буквка p обязательно.
Здесь я сделал маленькую паузу.
Давайте составлю чуть более усложненный пример, а не просто какую-нибудь программу типа ls.
И в качестве тестовой программы это будет скрипт на языке Python.
ПМФ-ники Python знают, и ВТ-шники вы Python не особо знаете.
Но ничего страшного.
И маленькая программа, которая что будет делать?
Она будет читать какие-то строки из стандартного потока ввода.
Модуль C, с которым есть файлы stdio, stdio, в него можно писать и читать.
Его можно использовать как облик для итерации, чтобы читать оттуда строки.
Строки в конце содержат еще символ slash n.
От этого можно избавиться.
Strip все пробельные символы.
И для того, чтобы понять, что мы действительно что-то осмысленное сделали,
давайте выведем просто удвоенную строку.
Что делает программа?
Она читает все со стандартного потока ввода.
СИС, СТДА, не СТДО, а СТДИН.
Там отдельно СТДИН, СТДА.
Читает какой-то текст стандартного потока ввода и вводит удвоенный текст.
То, что здесь продублировался СД, это уже особенность EMACS.
Как нам остановить эту программу?
Завершить поток вывода?
Просто послать сигнал завершения, закрыть стандартный поток ввода, CTRL-D.
Наша программа находится в питомском файле.
Нам нужно запустить Python 3.
Какие у нас аргументы?
Например, Python 3, дублирование, либо...
Зачем дублировать?
Потому что вот это программу, которую надо запустить.
Дальше вот эта штуковина, это argv0.
Дальше идут argv1 и так далее.
Программа называлась program.py.
Запускается все из текущего каталога, поэтому никаких особенностей нам не нужно.
Нал, естественно, здесь нужно все проверять, что мы корректно работаем,
что успешно запустили.
Почему я не делаю проверку на ошибки?
Потому что если мы вообще попали сюда, то этот код, значит, экзек выпался неуспешно.
Этот код при хорошей ситуации является недостижимым.
Вот наша программа занимается следующим.
Она запускает Python, и Python дальше у нас считает стандартного потока ввода что-то
и дублирует содержимое.
И завершить работу этой штуковины либо Ctrl-C, либо Ctrl-D.
Теперь мне неудобно вводить что-то на стандартный поток ввода.
Как я могу это поправить?
Я могу написать какой-то текстовый файл с входными данными для стандартного потока ввода.
Например, строчка hello, строчка world.
И на выходе мы ожидаем увидеть удвоенную строчку hello, удвоенную строчку world.
Как нам запустить эту программу launch и перенаправить все со стандартного потока ввода?
Почему эта штука у нас отработала для дочернего процесса?
Мы же в программе launch скормили на стандартный поток ввода что-то, а вовсе не нашим Python.
Почему это работает?
Потому что файловые дескрипторы наследуются.
У нас произошло наследование файловых дескрипторов.
И тем самым наш Python честно прочитал вместо стандартного потока ввода содержимое файловых дескрипторов.
Но есть еще один способ.
Я не зря подключил FileControl.
Давайте перед тем как выполнить exec я сделаю вот следующие вещи.
Закрою стандартный поток ввода и открою нужный нам файл на чтении.
И теперь я могу, естественно нужно все перекомпилировать.
Просто запускаю launch и уже просто без указания переопределения стандартного потока ввода.
Вот именно для дочернего процесса у меня этот стандартный поток ввода переопределен на какой-то файл.
И Python уже работает, ничего не зная про существование файла input.txt.
То есть фактически мы сымитировали вот такое поведение, которое делает интерпретатор bash
либо любой другой shell, когда запускает какую-то программу.
На самом деле вот здесь вот я вас и в прошлом занятии, и сегодня вот сейчас немножко обманываю.
Потому что вообще говоря вот такая штука это не определенное поведение.
Вот я написал здесь все это в одну строчку и казалось бы это две связанные между собой инструкции.
На самом деле это две разные инструкции.
И что будет если вот мы сделали закрытие, дальше что-то у нас происходит,
вы потеряли контроль над вашей программой, например,
клоус у вас происходит на одном экране, спустя несколько скролов вы написали open,
гарантируется ли вам, что open откроет файл descriptor с номером 0?
На самом деле между операциями close и open может происходить все что угодно,
но особенно это актуально для многопоточных программ,
поскольку у вас потоки выполняются независимо друг от друга.
И здесь даже если у вас будут подряд строки close и open, все равно что-то может произойти.
И для того чтобы более корректно отработать эту ситуацию,
то есть нам по сути нужно заменить файл в descriptor 0 на другой файл в descriptor
от какого-то другого открытого файла.
И на самом деле для этого предназначен, есть уже готовый системный вызов, называется dab, но только с цифрой 2.
Итак, что делает файл в descriptor dab?
Он просто создает копию файлового descriptor.
Что означает копия файлового descriptor?
У вас есть какой-то один открытый файл или файлоподобный объект.
После того как вы создаете копию, то вы с этим файлоподобным объектом,
который имеет уже другой номер файлового descriptor,
просто работаете точно так же, как с тем файлом, на который остался исходный файловый descriptor.
То есть по сути это копирование одного файлового descriptor и присвоение ему еще какого-то нового номера.
Системный вызов dab возвращает новый номер файлового descriptor, который также случайным образом просто выбирается.
То есть здесь я мог бы написать следующую строчку.
Я мог поменять местами open и close.
Здесь сделать новый файловый descriptor.
Затем я делаю close.
Здесь у нас input fd скорее всего будет номер 3, но это совершенно не обязательно.
Дальше я могу закрыть файл descriptor 0 и сделать вызов dab.
И присвоить input fd.
Dab, поскольку у нас свободный файл descriptor с номером 0, будет использовать этот самый файл descriptor с номером 0.
Давайте скомпилируем, проверим, что оно работает.
Да, вот оно честно работает.
В момент, когда мы сделали закрытие и сделали dab, у нас уже файл открыт с двух файловых descriptor 0 и 3.
И они указывают оба на один и тот же файл.
Как в этом можно убедиться и проверить?
Так делать очень плохо.
Гетчар.
Кстати, не факт, что это будет работать.
Это некоторый аналог систем паузы для Windows.
И так делать на самом деле очень-очень плохо.
Я это делаю только для того, чтобы поставить нашу программу.
Не спасло. Почему не спасло? Потому что на старом потоке воды у нас много всего.
Ладно, сделаем тогда просто длинный sleep.
Sleep это система вызов, которая приостанавливает программу на определенное количество секунд.
Я думаю, 2 минуты нам хватит, чтобы посмотреть что-нибудь, что у нас происходит.
Так, запускаем.
Так, ладно. Мы знаем, что наш процесс называется launch.
Давайте найдем, что за процесс с этой программой.
Ой, а у нас их два.
Кстати, почему два?
Потому что мы сделали fork.
И какой из них нам интересен?
Наверное, тот, который имеет больший process ID.
Почему нам интересен тот, который имеет больший номер process ID?
Потому что мы запустили какой-то процесс, вот наша функция main.
Дальше вызываем fork.
И с очень большой вероятностью наш номер нового процесса будет больше, чем номер нашего исходного процесса.
Но вообще на это полагаться не стоит.
Поэтому лучше сделать какой-то явный вывод.
Особенно когда вы работаете запуском разных процессов, то удобно делать вывод отладочной информации.
С нужным вам процесс ID.
Останавливаю, компилирую, запускаю.
Так, ну вот теперь я уже не могу не запускать программу PS, а сразу перейти в прок номер этого процесса.
И там есть подкаталог FD, что в нем содержится.
Вот три файла дескриптора. 0, 1, 2 и 3.
0 указывает символическая ссылка на файл input.txt, так же, как и номер 3.
А вот файлы дескриптора 1 и 2 указывают на обычный файл псевдотерминал.
Так, ладно, это я останавливаю.
Так, но тем не менее это не решает эту проблему, что между close и dub у нас может происходить все что угодно.
Поэтому нам нужно как-то все-таки схлопнуть эти две инструкции в одну.
И если вы внимательно смотрели MAN на стены вызов dub, то могли бы обратить внимание, что есть еще стена вызов dub с цифрой 2,
который делает то же самое, что система вызов dub, но при этом он имеет еще дополнительный параметр, целое число, новый номер файлового дескриптора.
И на самом деле сам по себе стена вызов dub достаточно бесполезен в современных условиях, он мало где используется,
зато система вызов dub 2 используется много где, достаточно широко.
То есть что он позволяет сделать? Он позволяет мне писать строчку close, пишем dub 2 input файловый дескриптор и указываем число 0.
Что он делает? Если файловый дескриптор с указанным номером, в данном случае число 0 существует, то предварительно файловый дескриптор с номером 0 будет закрыт
и вместо него будет переназначен файловый дескриптор, который вы присваиваете.
Если такого файлового дескриптора не существовало, то у вас просто будет создан файловый дескриптор с указанным номером,
и он будет ссылаться на тот файл, который вы указали.
Перекомпилируем, так, slip, наверное, мне тут уже не нужен, хотя посмотреть... ладно, он нам все равно ничего хорошего не даст.
Запускаем, вот получаем тот же эффект, но более безопасно.
То есть у нас гарантируется всегда, что файл, который мы открыли, имеет файловый дескриптор с номером 0.
И этот файл дескриптора с номером 0 уже наследуется нашей программой на Python.
Ну и в прошлый раз вот в PMF-ной группе возникал вопрос, как нам обрабатывать вывод от того процесса, который мы запустили.
Здесь понятно, что мы можем запускать какие-то программы, у нас может перенаправляться куда-то вывод.
И бывает полезно не перенаправлять этот вывод куда-то на стандарт-путок вывода, не делать перенаправления в какой-то файл.
Например, вы запускаете два процесса, либо вы запускаете только один дочерний процесс, и уже в родительском процессе с ним как-то взаимодействуете.
Для того, чтобы родительский процесс мог что-то осмысленное сделать с тем выводом, который дает дочерний процесс.
Но можете придумать ситуации, когда это бывает полезно.
Ну хорошо, вот здесь вы видите текстовый редактор с подсветкой строк, с кучей всяких сложенной поддержкой многоаконности в текстовом виде.
И внутри этого текстового редактора запущен еще Shell-терминал, и этот Shell-терминал еще делает запуск каких-то дополнительных программ.
При этом на самом деле у нас на настоящий терминал ничего из этого Shell-а не попадает.
Все попадает внутрь нашего текстового редактора, дальше текстовый редактор этот буфер вывода хранит, еще рисует тут номера строк.
То есть на самом деле любая среда разработки, где запускается компилятор GCC, отладчик ГДБ, ну и так далее, они все используют запуск дочерних процессов.
И при этом как-то обрабатывают их вывод. Причем здесь мы можем вывод отдельно разделять, по-разному обрабатывать вывод ошибок и стандартный поток вывода.
Например, рисовать какими-то разными цветами.
Итак, для того, чтобы перенаправить вывод из одного файлового дескриптора из одного процесса к другому, нам нужна пара файловых дескрипторов.
И эта пара файловых дескрипторов должна быть доступна обоим процессом. То есть нужно сделать что-то до форка.
Пара файловых дескрипторов это значит пара из двух целых чисел, которые можно хранить в виде массива.
И системный вызов, который свяжет между собой как-то эту пару файловых дескрипторов, называется pipe.
Pipe в переводе с английского означает труба.
Немножко тер материал о том, что такое труба.
Труба это такая длинная штука, обычно круглой в сечении, и в трубу можно что-то заливать, и из трубы иногда что-то выливается.
Она является одно направлением.
Если посмотреть на системный вызов pipe, то можно обратить и внимательно почитать, что там про него написано в description.
Тут написано, что это два файла у дескриптора с номерами 0 и 1, которые записываются в виде массива.
И очень важная особенность, которую надо запомнить.
Вся жидкость по трубе у нас течет не слева направо, а справа налево.
Почему справа налево?
Ну, на самом деле, кто из них потом, кто родитель, не совсем понятно, потому что они равнозначны.
Версия про арабов, которые проектировали POSIX API, тоже как-то не очень достоверна, поскольку это было еще в 70-80-е годы.
Арабов было в Америке не так много.
На самом деле ответ достаточно прост.
Что вы можете делать с файлом дескриптора с номером 0?
Вы можете из него читать.
А файл дескриптора с номером 1 вы можете писать.
Поэтому в POSIX API трубу спроектировали именно таким образом, чтобы удобно было, просто глядя на индексы элементов массива, правильно понять, какой это файловый дескриптор.
Нулевой предназначен только для чтения, писать него невозможно.
Первый предназначен только для записи.
И труба – это только одно направленная передача данных из одного места в другое.
Мы к дальнейшим свойствам трубы еще вернемся, поэтому я ее не стираю.
Нам нужно сделать трубу и для этого вызвать системный вызов под названием Pipe.
Если внимательно посмотреть на сигнатуру системного вызова, в некоторых манах написано int звездочка, в некоторых написано int PipeFD и явным образом число 2.
Мы на самом деле можем передать указатель на целое число, но массив сам по себе является указателем.
И на самом деле нам нужно обязательно проверять на значение минус 1.
Значение минус 1 – это какая-то ошибка. Что может означать ошибка при создании трубы? В каких ситуациях она может появиться?
Здесь же мы просто вызываем Pipe от двух чисел. Мы не передаем никакие имена файлов, которые могут не существовать, у которых не будет прав доступа.
В этом случае тут скорее будет SegmentationFall в какой-то момент, поскольку на языке C трудно это проконтролировать при реализации функции Pipe.
А причем тут права к файловому дескриптору?
Нам Pipe просто создает два файловых дескриптора и сохраняет их в чен. То есть это выходной параметр.
У нас количество файловых дескрипторов – это ограниченный ресурс. Pipe у нас даже не один открывает, а сразу два файловых дескриптора.
Поэтому вероятность того, что вы встретите ошибку и закончили с файловой лимиты, является единственной возможной ошибкой, почему у вас Pipe может завершиться с ошибкой.
После того, как вы создали Pipe, у вас в трубе появилось два новых файловых дескриптора. Один из них предназначен для чтения, другой – для записи.
Обычно они складываются слева направо, то есть если у нас свежезапущенная программа Main, запускаем в чистом окружении, где нет никаких открытых файлов родительского процесса,
скорее всего у них будут номера 3 и 4, но опять же гарантировать это никто не может.
Мы создали два файловых дескриптора с номерами 3 и 4. Теперь мы хотим запустить какую-то программу, ее вывод перенаправить к нашему родительскому процессу.
Что нам для этого нужно сделать? У нас есть труба, в которой все может протекать справа налево. Мы можем записывать файловый дескриптор, который хранится в элементе массива с индексом 1.
То есть мы должны в ДАБ-2, мы импут переназначили и точно таким же образом мы можем переназначить что-то из трубы, то есть файловый дескриптор, который хранится в качестве первого элемента, доступного для записи, связать с файлом дескриптора под номером 1.
Так, вот я это связал, компилируем, запускаем, наша программа была запущена и мы уже не наблюдаем никакой вывод, в отличие от прошлого раза, хотя процесс честно был запущен, он честно отработал, что-то записал на стандартный поток вывода, но этот стандартный поток вывода просто попал в трубу, из которой мы ничего не прочитали, эти данные у нас пропали.
Так, ну теперь возвращаемся к нашему родительскому процессу, после того как мы запустим процесс, в то время пока процесс работает, мы можем что-то сделать, ну например, мы можем сымитировать вот такую команду Python3, как нам посчитать количество символов в выводе.
Мы можем запустить некоторую программу, перенаправить стандартный поток ввода, что мы уже сделали, ну и дальше, например, вызвать команду wc, с опцией "-c", это посчитать количество символов, что такое wc, помните, это подсчет разных статистик по тексту, посчитать количество слов, посчитать количество строк, ну или количество символов, оно же количество byte.
Так, давайте сымитируем теперь подсчет количества символов, которые нам выдала наша программа из дочернего процесса.
Для этого нам нужен использовать системный вызов read, который читает что-то куда-то в определенный буфер, в самом деле содержимое буфера нам особо неинтересно для этой задачи, нам больше интересно, что нам вернет системный вызов read.
Так, читаем мы откуда? Из нулевого элемента того массива, который связан у нас с трубой.
Так, мы передаем ему наш буфер и указываем максимальный размер, который мы имеем право прочитать.
Так, на самом деле здесь по-хорошему надо сделать все это в цикле, ну ладно, вывод у нас небольшой, поэтому для демонстрации этого достаточно.
И сообщаем о том, что мы прочитали сколько-то байт из нашего канала.
Так, только здесь по-хорошему надо сделать тогда приведение типов, поскольку SSST имеет размеры либо 32, либо 64.
Ладно, компилируем, запускаем и сообщаем о том, что мы прочитали 22 байт из нашего канала, но это похоже на вывод команды WC.
Ну и таким образом вы можете связывать между собой произвольный процесс.
Так, на текущий момент у вас возникли какие-то вопросы или нет?
Хорошо.
Так, вот хороший вопрос, давайте мы это поменяем местами.
Вот у нас буфер, дождались.
Компилируем и запускаем.
Получаем тот же самый вывод, но здесь одна есть маленькая тонкость.
Труба. Какие есть свойства у трубы?
Труба – это что-то, у чего есть длина, что еще есть у трубы, кроме длины.
Наверное, радиус.
Теперь вопрос, площадь сечения какая?
PR квадрат.
Так, это у нас площадь сечения.
А объем трубы?
Да, объем это у нас получается PR квадрат, умноженный на длину.
И чему это равно?
Это равно 65536 байт.
Так, но это только в линукс, в других операционных системах это может быть по-другому.
Так вот, если у вас вывод не превышает 65536 байт, то совершенно неважно, где написать до ожидания процесса, либо после.
У вас данные хранятся в трубе, и вы сможете их прочитать то, что у нее записано.
Данные хранятся просто в некотором бусе.
На самом деле тут еще возникает проблема, что произойдет, если не один процесс будет писать, а два процесса будут писать в трубу.
У нас есть файлодискриптор с номером 4, который хранится в первом индексе нашего массива.
Так, ну и никто не мешает, например, родительскому процессу, после запуска, либо до запуска, неважно когда, сделать какую-нибудь гадость, например, написать вот такую штуку.
Куда? Ну, в тот же самый файлодискриптор, который нам доступен.
Записываем какой-то текст.
Так, здесь не забываем про он минус один, за счет того, что у нас есть нулевой завершающий символ.
Так, вот что здесь у нас произойдет теперь?
То есть у нас есть два процесса, родительский и дочерний.
Дочерний запускает питон, питон что-то делает, что-то записывает, мы это подсчитываем в родительском процессе.
Так, и у нас есть еще сам по себе родительский процесс, который мало того, что читает, дождавшись завершения дочернего процесса, но сам еще при этом что-то пишет в трубу.
Так, ну окей, запускаем, получаем уже 33 байта, прочитано из трубы, то есть наши исходные 22 символа, плюс, ну здесь, раз, два, три, четыре, пять, шесть, семь, восемь, девять, десять, так, еще один, ну да, плюс слышен, это одиннадцать, плюс еще одиннадцать символов, ну, часто получаем 33.
И в каком порядке у нас все это будет выводиться?
Кто первый записал, того этапки, а почему не чередование?
То есть у нас может быть ситуация, например, что два процесса работают примерно одинаково по скорости.
Так, первый из них пишет слово I am parent.
I am probability.
Дальше, в какой-то момент времени с опозданием у нас запускается что-то, что пишет hell low.
Так, здесь некоторый у нас люфт по времени.
И вообще говоря, в общем случае можно было бы наблюдать такую ситуацию, что сначала запишется часть того, что успелось записаться, I am, а дальше рандомным образом, что-то h, пробел, p, e, a, l, ну и так далее.
На самом деле такая ситуация, она в чем-то верна, но не совсем.
А именно, разные процессы, которые могут писать в трубу, делают еще некоторые фрагментарные деления атомарные.
То есть данные в трубе у нас идут некоторыми блоками, и размер одного блока гарантируется, что должен быть для любой UNIX системы не менее чем 512 байт.
Вот для этих 512 байт в одном блоке, то есть на одну операцию write, гарантируется, что эти блоки идут последовательно и не перемешиваются друг с другом.
То есть у нас будет отдельно строчка I am parent и отдельно вывод нашей программы, потому что у них вывод очень малый.
Для любой UNIX системы гарантируется, что не менее чем 512, в линуксе это число, не только в линуксе, но и в большинстве современных систем 4096.
Поэтому если вы, например, запускаете программу со стандартным потоком ввода, стандартным потоком вывода, обычно у вас и стандартный поток ввода, и стандартный поток вывода идут в один и тот же терминал.
Но при этом вы же обычно не наблюдали ситуации, когда у вас что-то по букве насмешивается.
У вас обычно есть какие-то читабельные куски текста и стандартного потока ошибок, и стандартного потока вывода.
Это достигается тем, что у нас данные передаются блоками по 4096 байтов.
Можем в этом даже убедиться, а именно вывести не только количество символов, мы, например, само содержимое буфера, которое у нас тут записалось.
Так, ну вот, просчитано 33 байта. I am parent, затем идет Hello, Hello, World, World.
Так, теперь про...
А если мы сделаем read, то вы совсем же не пакшнупнули что-то?
В этом случае действует стандартное правило для read, что если у вас данных нету, то read просто ждет, пока появится хотя бы один байт.
Так, то есть на самом деле здесь...
Да, вот, хороший вопрос. Давайте посмотрим, чтобы если мы read вернем обратно, где он стоял, то есть до weightpida,
что мы здесь ожидаем увидеть?
На самом деле я тоже сейчас не знаю, мне это интересно.
Да, здесь мы прочитали только один кусочек.
Почему мы прочитали только один кусочек?
Потому что мы здесь записали уже что-то в канал, поэтому read имеет право что-то прочитать и уже это выдать.
Даже несмотря на то, что потом появится еще какая-то порция данных, которая запишет дочерний процесс.
Поэтому чтение с каналом правильно как делать?
Нет, не после завершения всего. У вас есть некоторый каунт, ну и пока этот каунт у нас...
Так, это относится к buffer, это к read, пока это значение у нас больше...
Нет, не это, вот это. Больше чем ноль.
Так, проверяем баланс скобок, что-то мне расстановку не нравится.
Так, пока у нас все успешно читается, мы читаем какие-то независимые друг от друга кусочки и их выводим,
для того чтобы не потерять никакие данные.
То же самое относится к любому большому выводу, не только при выводе из канала, но также при работе с файлами,
потому что у вас в любом случае файлы могут быть по размеру больше, чем размер буфера, который вы передаете.
Так, вот сейчас компилируем, запускаем.
Так, прочитали I'm Parent, прочитали Hello.
Так, и вот здесь мы словили интересную штуку.
Что происходит?
Программа у меня почему-то не завершилась.
Хотя вроде как мы прочитали I'm Parent, затем прочитали 22 байта Hello World и Hello World.
Да, потому что здесь у нас read ждет, пока у нас что-то не будет записано с противоположной стороны.
Так, теперь вопрос.
Точнее, маленький вопрос с подвохом.
Я, если я уберу этот самый write...
А нет, все равно.
Так, ладно, что у нас тут случилось?
Почему у нас...
У нас происходит ситуация, что read честно ждет, пока какие-то данные не будут записаны в наш канал.
Так, а почему он ждет?
Ну, потому что, наверное, что-то у нас не закрыто.
Хорошо, давайте посмотрим, я наоборот, на нашу программу.
Что у нас делает Python?
Что у нас делает дочерний процесс?
Дочерний процесс честно запускает Python.
И этот Python что-то там сам уже делает.
Ну, хорошо, давайте я модифицирую нашу программу на Python, чтобы гарантированно сделать...
Так, только не close, там sys, stdin, stout, close.
Все, вот.
А когда мы будем скрывать наш канал, наш filter, который мы будем делать?
Да, на самом деле, хороший вопрос.
Вот эта штука поможет вообще или не поможет?
На самом деле, здесь, когда у вас процесс завершается, что происходит с процессом?
Если он действительно честно завершился.
Закрываются все его файловые дескрипторы.
То есть, на самом деле, как только у вас программа на Python не закончилась,
у вас завершается работа интерпретатора Python,
процесс тоже завершается,
и гарантированно освобождаются все открытые файловые дескрипторы.
Поэтому то, что я сейчас в Python там дописал, маленький фрагмент,
чтобы принудительно закрыть stdout, не помогает.
Давайте внимательно теперь посмотрим нашу программу.
Максимизируем так, чтобы текст влезал, хотя это не очень получается.
И посмотрим на жизненный цикл наших файловых дескрипторов.
Есть ли тут тряпка?
Если нет, тогда придется, видимо, рисовать на другой части доски.
Надеюсь, нам этого хватит.
Ну ладно, я думаю, нам последнего кусочка доски должно хватить.
Итак, у нас есть
некоторые таблица файловых дескрипторов, связанные с какими-то процессами.
Давайте посмотрим с самого начала нашей программы, то есть запуска нашей функции Main.
Что у нас есть? У нас есть файлы дескриптора с номерами 0, 1 и 2.
Дальше мы создаем трубу к нашим главным родительском процессе.
И у нас появляется файл дескриптора с номерами 3 и 4.
При этом файл дескриптора с номером 3 – это вот здесь.
Файл дескриптора с номером 4 – он вот здесь.
Дальше. После этого мы вызываем системный вызов FORG.
Вот здесь происходит очень что-то интересное.
У нас создается копия нашего процесса, в котором наследуются все наши файловые дескрипторы.
То есть у нас есть файлы дескриптора с номерами 0, 1, 2, 3 и 4 точно такие же, как у родительского процесса.
Пока еще 0 указывает на терминал, 1 тоже указывает на терминал.
Ну хорошо, теперь посмотрим, что у нас происходит с дочерним процессом.
В дочернем процессе мы открываем еще один файловый дескриптор уже с номером 5.
Это наш файл input.txt.
Дальше происходит некоторая магия.
Мы создаем дубликат файлового дескриптора.
И то, что у нас было на файл input.txt, теперь оказывается в двух файлах дескриптора.
0 и 5 у нас являются одинаковыми.
Но при этом у нас открыты сразу же несколько файловых дескрипторов.
После этого мы делаем дублирование файлового дескриптора с номером 4, куда можно что-то записывать.
И назначаем его на файловый дескриптор с номером 1.
То, что будет для ввода, я буду таким минусиком обозначать.
Еще одна копия. Давайте это будет символ плюсик.
И вот что у нас в данный момент происходит.
У нас есть труба. На нее ссылается файловый дескриптор с номером 4.
Потом еще на нее ссылается файловый дескриптор с номером 1 у дочернего.
То есть уже два файловых дескриптора.
Могут писать в одну и ту же трубу.
После этого там запускается Python.
Python у нас что-то делает, как-то отрабатывает.
Что происходит после того, как у нас процесс с Python честно завершается.
Либо если мы не смогли запустить Python, мы в любом случае гарантированно доходим до системного вызова exit с номером 1.
После того, как Python у нас завершился, у нас грохаются все вот эти файловые дескрипторы.
То есть у нас все, что связано с трубой, это исчезает файловый дескриптор с номером 1, который связан с child.
Теперь смотрим, что у нас происходит с родительским процессом.
Родительский процесс никак не создает новые файловые дескрипторы.
Он просто читает что-то из трубы.
И система вызовRead ждет пока одно из двух событий.
Либо пока мы что-то запишем в трубу, либо пока труба не будет полностью закрыта.
А почему она не закрыта полностью?
Потому что есть еще файловый дескриптор с номером 4, который относится к нашему родительскому процессу.
И он указывает на тот же самый трубу.
Поэтому мы получаем ситуацию Python deadlock или взаимная блокировка.
То есть мы не можем в принципе теперь продолжить наше выполнение.
В том числе мы не можем что-то уже записать, поскольку мы что-то читаем.
То есть максимум, что это может сделать, это только запустить еще один либо процесс, либо поток, который что-то запишет и после Read у нас выполнение продолжится.
Так, как нашу программу исправить?
Нужно четверку закрыть.
Вопрос когда?
Перед вайлом.
На самом деле, чем раньше, тем лучше.
Экономим файловые дескрипторы.
То есть если мы после раздвоения процесса на два сразу позакрываем все, что нам не нужно, то жизнь у нас упростится.
Так, ну давайте в самом начале жизненного цикла.
У родительского процесса какие файлы дескрипторы нам сейчас не нужны?
Очевидно, нам не нужен файл дескриптор с номером 4.
Потому что он предназначен только для записи, если мы не хотим ничего писать.
Либо если мы хотим писать, то сразу после записи, давайте вот здесь я оставлю.
А сразу как только нам файл дескриптор с того не нужен, мы закрываем его у нашего родительского процесса.
Все, мы его закрыли и уже не используем.
Файл дескриптор с номером 3 нам нужен или не нужен?
Родительскому процессу.
Да, вот родительскому процессу он как раз нужен.
Ладно, посмотрим теперь на дочерний процесс.
А есть ли у нас там лишние какие-то файловые дескрипторы?
Так, какие?
В дочернем процессе.
Давайте разберемся с пятеркой.
Пятерка у нас появилась в тот момент, когда мы открыли файл с определенным названием.
Используя темно-юзов open.
И в какой момент мы эту пятерку можем закрыть?
После того как мы сделали переназначение, то есть здесь уже честно мы после переназначения можем этот файл дескриптор закрыть.
И тем самым сэкономить драгоценный ресурс.
И файл дескриптор с номером 3.
В какой момент он у нас получается?
Он у нас получается при создании канала.
И после форка мы уже знаем, что если мы не будем ничего читать из этого файла дескриптора, то прямо сразу после форка для дочернего процесса мы здесь тоже можем его моментально закрыть.
Только не явным образом лучше число писать.
Нужен нам элемент массив.
Так, ладно, мы и позакрывали все, что нам мешает и что нам не нужно.
Перекомпилируем, запускаем.
Ну вот честно получаем работающее решение программы, которое у нас не будет зависать.
То есть на самом деле закрытие файловых дескрипторов, почему оно важно?
Оно важно не только для того, чтобы экономить файловые дескрипторы, но и для того, чтобы избегать возможной ситуации с дедлоком.
Это нужно делать очень аккуратно.
Так, ладно, допустим вы поняли историю о том, что нужно все всегда закрывать.
Давайте мы на всякий случай позакрываем все лишнее.
У нас есть родительский процесс, который что-то читает.
И есть дочерний процесс.
Например, мы хотим что-то записать предварительно до запуска питона.
Сделаем некоторую копию.
Какое-то сообщение, скажем, что я уже не парент, я уже child и пишу какой-то текст.
Так, записываем это все в канал с номером 1.
Так, кстати, запись в канал с номером 1. Здесь у нас опять же лишний файловый дескриптор с номером 4.
Мы его должны закрыть когда? Ну вот после того, как сделали DAP2.
Так, все. И писать соответственно уже файловый дескриптор с номером 1.
ДАП3 он не может автоматически закрывать старые дескрипторы?
ДАП2 автоматически закрывает. Он для этого предназначен.
Насчет DAP3 не знаю, он вообще не стандартный. То есть это линук специфичная штука.
Так, ладно. Проверяем, что мы ничего не сломали.
Так, вот. Да, записываем I'm a parent, дальше I'm a child и Hello World, Hello World.
Два разных врайта. Размер не превышающий размер блока.
Так. И сделаем выход.
И теперь я сделаю еще какую-нибудь гадость.
А именно, до этого врайта я на всякий случай
чтобы максимально экономить ресурсы, я просто закрываю файл дескриптор с номером 1.
Так. Компилируем.
Запускаем. Так, что мы получаем?
Получаем бабах.
Так, ну здесь бабах получили в питоне. Ладно.
Чтобы показать, что это делать неправильно.
Так. Вот мы честно записали I'm a parent.
Окей. Теперь давайте еще запишем.
Так, вот у нас есть врайт. Давайте сделаем close channel 1
нашего парента.
Так. Питон у нас грохнулся.
Родинский процесс у нас не грохнулся, но в некоторых системах
это может приводить к ошибке, которая вас просто прибьет.
Называется ошибка broken pipe.
В питоне, да, мы пытались закрыть, не выключить.
Почему объект non-type, кстати, у питона?
Потому что файлов дескриптора у нас нет, связан с стандартным потоком.
То есть на самом деле закрывать все на всякий случай это тоже плохая идея.
Так, ну и последняя вещь, на которую здесь нужно обратить внимание.
Давайте я верну теперь нашу испорченную
программу, то есть закрывать файлы дескриптора до записи.
Это плохая идея. Так, а что-то еще в моей программе
есть нехорошего.
Что такого нехорошего есть в нашей программе?
Для того, чтобы это понять, давайте мы дождемся процесс и опять поставлю
какой-нибудь сон на две минуты.
И немножко поисследуем наш процесс.
Так, компилируем, запускаем.
Вот мы сделали все, что захотели.
Сейчас мы просто спим на 51-й строке.
Тем временем где-нибудь в отдельной вкладке я хочу посмотреть,
что у нас происходит с процессами.
Почему у меня только один процесс лаунч?
Казалось бы, мы сделали форк.
Сколько у нас должно быть процессов?
Один слеп здесь все честно.
В этой программе все как раз нормально.
Походит пример.
Я сделал вот так.
Беру вот этот white pit.
Мы все вывели и немножко модифицирую программу на питоне.
Сейчас у меня будет дочерний процесс долго делать.
И посмотрим на HPS.
Наш процесс лаунч
все-таки запущен.
А, он ждет на риде.
И просто висит.
Тяжело это сымитировать.
Сис, std, out, close.
Бропкин байк поймали где-то.
Последний запуск.
Запускаем программу,
которая закрыла стандарт с боток вывода.
Лаунч все-таки болтается.
Давайте посмотрим где.
Все-таки не удалось меня привести к плохой ситуации.
Тем не менее, чем эта ситуация плоха в данной программе?
Вот этот white pit на что влияет?
Если программа не висела на риде.
Если два независимых процесса запустить, тогда это будет лучше проявляться.
Зачем нам нужно ждать, пока завершится дочерний процесс,
а не завершать родительский процесс раньше?
Что делает white pit?
Для чего им нужен статус?
Чтобы получить то, что вернул ребенок, некоторый exit статус.
А если мы не прочитаем exit статус, то что у нас происходит с процессом?
Он станет зомби.
Современные системы UNIX-подобные
переназначают все зомби на процесс
Дальше процесс обязан аккуратно прочитать код возврата
и выкинуть его никуда, чтобы процессы не оставались в зомби.
Про пайпы.
Все понятно, что это такое, как они работают.
С даб 2 понятно, что такое создание копии файлового дискриптора?
Я остановлю запись.
