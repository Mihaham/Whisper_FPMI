Мне бы хотелось ответить на некоторые анонимные
вопросы, которые были в форме.
Например, спрашивали, как же так 20 часов в неделях
курс занимает.
Вот.
Я как-то поспрашивал специально, сколько там в шаде курс
занимает, подобные вещи, и выяснил, что на самом
деле, конечно, курс будет занимать в это ожидание
примерно до 10 часов в неделю, на самом деле даже
меньше.
Но если вы будете рассчитывать на 20 часов в неделю, то
у вас точно все получится со отлом 10.
Но учитывайте, что он в общем-то такое в ожидании
10 часов, больше вы точно успеете.
Так, ну давайте, может, перейдем к лекции.
Чисто такой вопрос, в ожидании для студента шада?
Ну получается, что да, для студента шада.
Но они на самом деле говорили чисто меньше, кто-то говорил
3 часа в неделю, кто-то говорил 6 часов в неделю.
То есть до 10 часов не доходило, это я уже и сам рулю.
А это на какую цепь?
Это на максимум, на отл.
Вот.
Ну, может быть, у вас, конечно, будет больше, но, я думаю,
несчастно.
Еще раз, конечно, в лекциях были некоторые непоследовательности
и, к сожалению, как я не пытался, ну, я делал вторую лекцию
и выяснился, что на самом деле, конечно, лучше было
чуть-чуть по-другому прочитать материал, поэтому мы чуть-чуть
будем теряться на второй лекции, но я постараюсь вам
по-другому на вопросы отвечать, чтобы вы все поняли.
Ну, просто такая проблема, что курс первый раз читается
и могут быть запросто какие-то ошибки в нем.
Вот.
Ну, давайте, наверное, перейдем к баррелчекеру, про который
мы не успели поговорить на первой лекции, до конца.
Так, кто у нас сделал первую домашню присутствующих?
Ну, то есть, в принципе, все можно считать, да, буквально,
с редким исключением.
Столкнулись ли вы с баррелчекером в домашней лекции?
Что, что еще?
Столкнулись ли вы с баррелчекером в домашней лекции?
Ну, он говорит обычно что-то вроде там использования
Borrowed Value.
Что это такое?
Ну, амперсанды вроде бы там ставить нужно было
только в единичных строчках.
Ну, то есть, там одна строчка.
Ну, можно понять, куда именно там эти амперсанды вставить.
Проходилось прииграть в переборки.
Там компилятор же обычно говорит просто, куда поставить.
Что-то он плохо там говорил в одном месте точно.
Что-то не знаю.
Вот вся домашка должна была быть такой достаточно
простой.
Даже компилятор бы справился справить ошибки.
Ну, ладно, было бы интересно увидеть, что ты конкретно
сделал в домашке.
Ну, то есть, чтобы понять, где я накосячил, потому что
я постарался сделать так, чтобы с баррелчекером
первой домашней лекции просто не столкнулись.
Ну, что вы думаете?
Ну, что вы думаете?
В общем, она была бы для вас простой.
Ну, и какую код вы писали, можно будет потом посмотреть.
То есть, чтобы сделать какие-то выводы.
Интересно.
Вот.
Ну, баррелчекер предназначен для того, чтобы, собственно,
у нас получилась memory-safety-vrasti.
Это одна из составляющих частей.
Ну, насколько мы помним, memory-safety-vrasti – это такая
вещь, которая дает нам гарантию о том, что мы не будем,
что у нас не будет double-free и подобных ошибок.
Ну, то есть, мы смотрели на сижный код, смотрели
на примеры, ошибок, которые у нас могли возникнуть,
и что у нас мог, от чего нас мог спасать раст.
Давайте конкретно на это посмотрим.
Вот давайте посмотрим на такой код.
Те, кто делали домашку.
Что не так в этом коде с точки зрения раста?
Мы сначала, ну как-то, мы сохраняем подписывку
на первый элемент, ну, нулевой элемент векторе,
но вызываем метод push, который должен
изменить состояние вектора.
Ну, я не знаю лексику, это как-то захватить…
Ну да, да, ты на самом деле правильно говоришь.
Ну, то есть, мы уже заборули вектор,
и push мы его тоже хотим сделать, а два раза…
Так, да, действительно, у нас получается такая
проблема, что у нас есть вектор, мы берем ссылку,
а после этого делаем push.
Например, в плюсах этот код прекрасно бы сработал,
но у нас бы стала ссылка потенциально невалидной,
потому что у нас мог бы реалуцироваться вектор.
Раст этого просто не позволит сделать.
У нас есть вот такая вот ошибочка.
Что наш вектор уже немутабельно заборвен,
то есть, мы взяли на него ссылочку,
которую мы хотим изменить.
Это потенциально опасно, это Раст запрещает.
Это общая на самом деле правила для Раста, то,
что если у нас на структуру внутри есть какая-нибудь
любая ссылочка, она может быть обычной, может быть
mute-ссылочка, про которую мы говорили на первой лекции,
у нас вектор будет становиться немутабельным в самом себе.
Ну и любая структура данных. Мы еще на этой лекции
успеем обсудить и посмотрим другие структуры данных,
которые у нас есть в Расте, кроме вектора.
Вот такая вот у нас возникла ошибочка.
Давайте посмотрим еще на какой-нибудь примерчик.
Этот пример исправить нужно просто удалить вот этот
letx и просто взять println x0.
Да, это сработает, потому что у нас
letx Раст посмотрит на эту ссылочку
и решит, что ее время жизни оно будет до vpush.
То есть у нас есть вектор,
если бы у нас не было println, тогда бы он жил до push
следующего. Ну и то, что по центру x
он инициализируется и сразу
дезинфицилизируется, Раст решит, что это безопасно,
потому что ей дальше электроника не пользуется.
Дальше у нас есть такой код, который делает
сумму элементов в векторе. Вот мы создаем
какой-то вектор, считаем сумму,
push что-то вектор и считаем вторую сумму.
У нас здесь на самом деле есть сразу несколько проблем.
Как вы думаете, какие?
Да, во-первых, мы умувнули вектор
в сумму и умувнули вектор.
Соответственно он будет у нас недоступен в main.
В плюсах, насколько вы помните, если мы
напишем подобную вещь, то в таком случае у нас произойдет
копирование вектора. То есть если бы у нас было
написано какая-то функция intsum,
которая принимает на вход istd-вектор, то в таком случае
мы бы скопировали вектор, просуммировали,
а в Rast по умолчанию у нас move-семантика. То есть
то же самое, что вы в плюсах напишете istd-move.
Он будет забирать владение, скажем так.
Посмотрим, что такое владение.
У нас вот такая вот будет прекрасная ошибка компиляции.
Rast очень подробно, как видите,
показывает. Вот у нас есть ошибка
такого рода. У нас есть V.
Он объясняет, что он имплементирует trade-копию.
У нас были, кстати, вот вопросы в чатике
по поводу того, что такое копии clone. Это тоже мой промах,
который я объяснил на первой лекции. Наверное, стоило сразу сделать.
Все ли поняли разницу между копией clone?
Нет, не очень.
Ну, смотрите, копия — это когда у нас
для того, чтобы что-то скопировать, достаточно просто скопировать
саму структуру. В случае вектора это
неправда, потому что если вы скопируете вот этот вот буфер,
скопируете его длину, скопируете его capacity,
то в таком случае вы получите такой же вектор,
который указывает на тот же самый буфер.
Это не прямо будет копия. Вам нужно будет скопировать буфер
сам по себе, то есть сделать новую локацию,
перекопировать туда все элементы.
Поэтому он имплементирует не копию, а clone.
Копия — это когда вы копируете
сами байтики, из которых состоит структура.
Например, просто можно скопировать int и 32,
но просто для того, чтобы его склонировать, достаточно
повторить байтики, из которых он состоит.
Конструктор копирования перемещения в плюсах — это более
общая вещь.
Если структура тяжелая, в частности, если она владеет
какими-то данными на куче, то в таком случае
у нас будет клоун, например.
Я могу сходу придумать такой пример.
Например, у нас будет структура хранить, какой будет
идентификатор U64. Казалось бы, просто
скопировать этот U64 внутри копии.
А мы можем сделать так, чтобы у нас по умолчанию
вот этот идентификатор на самом деле сначала идентификатор
на каком-то внешнем сервере. И он что-то значит
для внешнего сервера. И для того, чтобы склонировать
структуру, мы можем сделать такой пример.
В таком случае по умолчанию РАС на самом деле
не имплементирует даже копии и клоун для структуры.
Потому что это просто небезопасно, он не понимает,
как вы пользуетесь этой структурой.
Соответственно, для того, чтобы
вам нужно явно показать, что тип
является копией, либо указать явно, что тип
является клоуном. Возможно, даже имплементирует
механику клонирования, если она у вас особенная.
Примерно понятно объяснил?
Особенная механика это,
давай на следующей лекции, у нас там будет
TradeClone, мы прямо посмотрим на функцию клонирования.
Вот, а сами разница между CopyClone.
Тут он пишет, что он
move-нул, потому что не реализовал CopyTrade.
То есть, если бы мы его реализовали, он бы move-нул?
Нет, на самом деле он бы просто скопировал.
Да, он понимает, что это дешевая структурка,
но почему бы ее в сумму просто не скопировать?
И он ее скопирует, и дальше он посмотрит, и дальше используется.
Значит, у нас будет здесь Copy.
Я не могу понять, например, зачем, но если мы хотим
именно move-нуть, то это никак не сделаем.
А именно move-нуть то, что Copy?
Чтобы он не Copy, не копировал.
Кажется, это невозможно.
То есть, если Copy, тогда это обязательно какая-то дешевая штука.
Может быть только у подтипов?
Копии может быть не у произвольного типа.
Копии, конечно, это бы на третьей лекции рассказывать,
но вообще это маркерный трейд.
Он говорит Расту, вот эту структурку нужно просто
по байту скопировать, сделать нам мем-код.
И все.
То есть, если вы что-то хотите более произвольное,
там более сложная структурка, тогда вы можете
сделать мем-код.
То есть, если вы что-то хотите более произвольное,
там более сложная структурка, тогда обязательно Copy.
Примерно ответил на вопрос,
или я все-таки неправильно тебя понял?
Мы можем написать дирайв-копии у конституции,
и так будет работать даже в сейфе.
В плане, если ты написал?
Ну, если у тебя там 10 интов,
то ты можешь написать дирайв-копию,
и она будет прекрасно работать.
Ну, socket это уже такая вещь,
которую даже планировать нельзя.
Повтори, пожалуйста, еще раз.
Да, мы не можем приметировать для стринга Copy.
Там еще есть прикольная
такая штука у трейтов, что вы τрейт
можете имплементировать
только для структуры, которую вы только что
объявили. Либо для трейта,
что вы только что объявили. То есть, имплементация трейта
существует для одного, либо другого.
про трейд. Вот, ну там, в общем, может быть, такая фигня, что у нас раз
не будет знать какую функцию просто вызвать. Вы будете вызывать, например, клоун, и если
у вас там клоун имплементирован для типа как-то по-другому, в другом
библиотеке, в общем-то, крейте, то он не будет понимать, какую из двух вариантов
вызвать. Ну, мы посмотрим на третью лекцию такой пример. Вот. Так, а вот с этим вот
примером на слайдах есть вопрос?
Просто с move и вот этим вот push, который у нас был.
Да-да, у нас тут вот и push есть, и sum. То есть у нас вторая проблема, это то, что мы
пытаемся еще со концом потом посчитать. Тут вообще лучше всего оптимальнее
написать сумму так, чтобы она принимала на вход slices и 32. Это оптимально. Потому что
тогда вы будете на слайсах работать и на векторах. Просто вектор можно будет передать по ссылке и все
А slice не move-ается? А что еще? Slice не move-ается? Ну, то есть если бы у нас B было не электром, а slice-ом?
Slice, ну, именно ссылочка slice move-ается, потому что это обычный копий-тип. Это
просто два указателя, по сути, начало-конец где-то. Они отлично копируются и все.
Ну вот, получается, если бы B было бы slice-ом, и мы бы сумму запихивали B, то он бы тоже move-ался.
Если бы это было slice-ом, ну да, это бы работало, потому что на slice-у копий-тип. А можно как-то сказать не move-ой?
Нельзя. Если это копия, то тогда копия. Все. То есть, ну, это дешевая тогда штука. Наверное,
это, кажется, вопрос, который вызывает самые обширные у вас эмоции копии и клоун.
Ну, клоун, понятно, но то, что он move-ает, когда он не хочется, это грустно.
Ну, ты имеешь в виду...
Если ты допускаешь копирование, то ты его разрешаешь, и потом как-то выиграться с ним как хочешь.
Потому что это значит какое-то странное применение.
Так, давайте мы поговорим о правилах вообще владения. У нас до этого были такие примеры, что у нас
был владеющий, например, вектор. Владеющий вектор, мы его move-аем отсюда, и теперь мы не можем
с ним взаимодействовать. До этого у нас был пример, что, опять же, владеющий вектор, мы берем на него
ссылочку, а теперь мы пытаемся его изменить. То есть у нас v — это владеющий тип здесь является.
Сейчас я покажу более хороший пример. У нас у каждого значения в расти есть один момент времени,
owner, владелец. Owner — это тот, кто владеет аллокацией на объект. То есть он, как все плюс-плюс, если у вас есть
какой-то тип STD-вектор, то в таком случае он ответственный за то, чтобы очистить за собой память.
В один момент времени может быть только один owner. Понятным причинам, потому что иначе мы бы могли,
например, дважды освободить память. Ну и вот когда у нас owner уходит из копота, в таком случае у нас
сам owner дропается, то есть становится неволидным значением. Вот смотрите, у нас есть какой-то вектор,
потом у нас есть u, равняется s. И смотрите, в данном случае у нас владение этим вот векторами,
за 1,488, передается в u. И в таком случае, когда мы пытаемся запринтить u, это отлично сработает,
а когда мы пытаемся запринтить s, то в таком случае у нас уже будет ошибка, потому что мы передали владение.
Ладно, ошибка комбинации не вставил в слайды, но вот в общем-то он скажет, что это не работает,
потому что уже s, как бы деинтилизированная переменная, владение было передано u.
Вот, то есть вот запомните то, что у нас до этого было self, те, что просто значение типа t, они все
владеющие, они владеют локацией, они владеют объектом. Вот. Так, ну это еще раз мы повторяем,
у нас есть правило ownership. Каждый владелец имеет право, у него есть ответственность очистить за
собой память. Это мы поговорили. И потом дальше пример. Когда мы что-то move в s, то вот это вот s
внутри становится, собственно, владельцем. То есть мы move-нули, соответственно, у нас уже s не
владелец внутри функции. Так? Технически получается, что s это у нас own теперь. Ну и, соответственно,
мы не можем это не использовать. А вот c++, опять же, мы здесь в этом моменте создадим копию.
Да, получается, что у нас было s вот это вот, и мы его передали во владение вот сюда.
Да, он скажет, что я там съел s, да, и после этого, где вот эта закрывающая скобочка,
он уже дропнет, собственно, сам s, и все. То есть того же самого в плюсах можно было бы добиться,
если бы вы сделали steady move. То же самое произошло бы. Абсолютно. Так. Ну и, опять же,
вот, вспомним про копии clone. Посмотрим вот на то, что здесь происходит. У нас есть какой-то int n,
потом мы делаем m равное n, и абсолютно спокойно и n, и m, и, в общем-то, и выводим. Ну как,
уже десять раз мы в этом поговорили. Скажите, в чем проблема, почему это работает возле счет
вектора? Верно, потому что это копия типа. То есть, ну, они вот копируются абсолютно спокойно,
и, соответственно, оно работает не так, как у нас должен был бы работать вектор. Так. И еще давайте
теперь подумаем про ссылочки. Давайте представим такую вымышленную ситуацию, что у нас есть группы
каких-то юристов, которые смотрят на какой-то контракт в Google Docs. Кто-то пытается его
подписать, кто-то его пытается заревьюить, да. И какие мы должны установить правила для того,
чтобы у нас не получился хаос. То есть, что кто-то нашел ошибку, а другой уже подписал, например,
контракт. Что-нибудь вот такое вот. Это будет нормально, если мы будем модифицировать до того,
как, ну, сейчас-сейчас. Если мы будем модифицировать наш контракт до того,
как его кто-то подпишет, тогда это нормально. Но если кто-то подпишет его, а потом мы будем
модифицировать, то это уже плохо. Ну, чем-то напоминает конкарнти, да. Соответственно,
мы должны разрешить только одному человеку одновременно менять, либо всем читать. Похоже
на конкарнти, да. Вот какие-то, если вы помните курс, что у нас есть. Часто мы хотим,
чтобы у нас только один кто-то менял, либо много кто читал. Так, у нас получилось два
немного слабее, но не важно. Таким образом, мы хотим, ну, вот если мы это как-то сформулируем в
терминах языков программирования, то мы хотим иметь либо сколько угодно константных указателей,
либо если у меня есть какой-то неконстантный указатель, то есть мутабельный, то в таком случае
мы, как сказать, в таком случае это может инвалидировать константные указатели другие,
которые у нас уже есть. Так, давайте чуть-чуть приостановимся, все ли понятно пока что,
что я говорю. Смотри, если у нас есть константные указатели, их может быть сколько угодно,
а если у нас есть кто-то, кто умеет модифицировать, то есть мутабельные, ну, указатель,
который умеет мутировать, то это уже плохо, да. То есть мы просто попробовали интуицию перенести на
языки программирования сейчас. Так. Соответственно, если у меня в любом момент ремни не больше такого,
не больше одного неконстантного указателя, то это должно быть окей, хорошо. Так, теперь давайте
вообще в термных раз тогда поговорим. У нас может быть сколько угодно немутабельных ссылок в любой
момент времени, то есть за то, что мы брали просто амперсандик, это просто ссылка. Мы могли сколько
угодно раз в векторе взять на элементы, ссылки обычные, там на B0 хоть десять раз берите,
такую ссылочку. Потом. Но мы можем иметь только одну мутабельную ссылку за раз. И это уже на самом
деле важно, потому что если мы, например, возьмем мутабельную ссылочку на B0, то в таком случае
взять немутабельную ссылочку мы уже не сможем, потому что она ожидает того, что элемент не будет
меняться. Вот так мы сможем его поменять. И, соответственно, в Rust появляется контракт,
что у нас в любой момент времени есть либо одна мутабельная ссылка, либо много немутабельных
обычных ссылок. То есть как раз либо один писатель, либо много читателей. Это вот как раз то,
что мы, типа, MSO изучали и то, что у нас возникает у Rust. Так. Потом у нас есть такое понятие,
как lifetime значение. Lifetime это, ну, пока что давайте мы конкретно этом слайде подумаем про это,
как про scope, чуть более упрощенно. Ну, вот мы видели, как у нас виктора, например, когда выходит за
границы scope, то они дропаются. Например, когда мы move им какую-то функцию, тогда у них заканчивается
их lifetime. В общем, lifetime значение заканчивается, оно дропается. Соответственно, Rust не разрешает
вам иметь ссылки, которые имеют больше lifetime, чем само значение живет, само уноразначение живет,
потому что иначе у вас будет висяча ссылка. Так. Потом Rust это очень хитрая такая штука,
она проверяет lifetime прямо в compile time. Мы очень подробно будем говорить про lifetime в какой-то
момент попозже, где-то около шестой лекции. Пока что мы посмотрим такую интуицию скорее.
Естественно, когда мы вычисляем lifetime на этапе компиляции, вот есть такая проблема у всяких
статических инструментов, что они частенько дают ложноположительное срабатывание. Ну, то есть,
если у нас, ну, код может быть валидным, но при этом он не скомпилируется, потому что раз подумаешь,
что что-то в нем не так. В роучекер со временем становится умнее, и он начинает пропускать какие-то
вещи. Например, вы могли видеть, как Андрей разов в чате скидывал пример того, как в
Knightly компилятор у него что-то компилировалось с каким-то флагом, а без этого всего не компилировалось
тейбл. Здесь как раз пример того, как роучекер становится умнее со временем. То есть, соответственно,
возможно, когда-нибудь он практически не будет реджектировать правильный код, но сейчас пока что
иногда приходится с роучекером как-то дружить и находить какие-то входные пути. Раньше прямо
часто приходилось. Сейчас уже, я бы не сказал, что часто, но бывает такое. Например, там всякие временные
переменные. Иногда приходится сначала объявить временную переменную, потом, например, у нее взять
итератор, просто чтобы она жила достаточно долго. Ну и, соответственно, вот последняя строчка у нас
раст вызывает специальную функцию drop, когда у нас lifetime заканчивается. Вот то, что называется в
расти drop, это как раз наш деструктор в плюсах. Просто у него другое название. Там, конечно, есть еще
небольшие нюансы, но мы их посмотрим успеем. В принципе, это деструктор просто. Как
имплементировать drop? Как вы думаете? То есть вот мы написали, и после этой строчки я ожидаю,
что drop скажет, что, в общем-то, если, например, я попробую у вектора взять нулевой элемент,
то в таком случае это не должно скомпилироваться. Я хочу, чтобы у меня drop было значение. Да, правильно,
это нужно просто узнать функцию. А какая будет сигнатура? Нет-нет-нет, все очень-очень просто,
Андрей, это же раст. Да, self, давай вспомним, что не self является, скажем так. Ну, чтобы мы приняли
любой аргумент, а не просто именно саму структуру. Так, давайте подскажем, нам просто по значению,
грубо говоря, принятия надо, ничего внутренне делать. Как написать такой drop? Смотри, вот я хочу,
чтобы после этого я написал век 0, мне сказал раст, а я и век уже, век съели. Да, и мы хотим
просто drop имплементировать.
Конечно, это не век, вот это drop, self, это общий. А, черт, я не написал генерику. Ну, тут это тоже нормально, в принципе.
Ну, если это в генерике, то будет то же самое, что ты сказал, просто будет drop t, внутри будет
какое-то value t. Внутри будет такая пустая имплементация, просто ничего не будет абсолютно.
Ну, естественно, просто move не туда, раст, ничего с этим не сделай, и все будет хорошо. В общем, то, что мы хотим.
Да.
Да, он просто все так вот имплементирован, drop ничего не делает. Он даже по-дефолту это...
в std-прилют, это то, что у нас по-дефолту раст импортит, он даже есть, просто вот, можно вот так вот написать в коде, drop из значения.
И он будет вот так вот работать.
Да, он просто съедает.
Да. Ну, он диалоцируется прям, все, drop вот.
Не, при выходе из кова по drop происходит.
Мы применили по значению.
Ты про то, как вообще раз понимаешь, что он уже drop-нет, drop-нет по значению.
Когда, конечно, происходит локация, если у нас вообще ничего не оптимизируется?
Это, кажется, диалокация, наверное.
Вот смотрите, мы говорим, что по выходу из скопа у нас происходит drop, и по выходу из скопа у нас происходит диалокация.
Поэтому если мы напишем так drop...
Не, ну диалокация, то, что я имел в виду диалокация, это как раз drop происходит.
Drop, на самом деле, когда что-то съедается, он там...
То, почему drop рекурсивно...
Почему рекурсивно называется drop?
Почему не происходит цепочки после...
А, почему drop не вызывает drop от полей?
Нет, нет.
Там тоже заканчивается область видимости.
И в конце области видимости функции drop должен вызваться drop.
А, ну это опять же, это то, что я проговорил...
Я вот спросил вслух, это про то, как раз определяет, что нужно переменной drop-ать вопрос.
Да?
Там есть drop flex.
Мы сейчас поговорим, там есть drop flex.
Такая штука, это битки на стеке, за счет которых раз понимает, что что-то drop не то.
Конкретно в данном случае, конечно, ему даже битки на стеке не понадобится.
Он просто поймет, что вектор диалацируется раньше, потому что все линейно.
А если там будет нелинейный код, то там будут флаги.
Ну, мы сейчас посмотрим.
Что происходит с self, когда мы заканчиваем drop?
Смотри, внутри drop-а у тебя должна быть какая-то произвольная логика.
На самом деле drop- это тоже trade какой-то.
По умолчанию в нем ничего нет.
Просто пустая имплементация, в которую запускается self.
Когда self умирает, у нас же self-владейший объект, владейший объект умер.
Просто понимает, ага, нужна диалокация.
Он запускает диалокацию, но drop от всех полей.
Ну и диалокацию, соответственно.
По ходу drop- это какая-то магическая вещь, которая усиленно drop не допускает.
Ну, усиленно от того же объекта.
Ну да, видимо раз отличается, что это именно drop, а не какая-то другая функция.
Наверное, вот этот drop- это все-таки пользуется?
Это в любом случае пользуется функцией, потому что она уже есть в дублятеке.
Это не то, что конкретно подставляет книг-копы.
Он явно это подставляет.
Но не это же drop, есть в ОМВ.
Да, но там drop-ы вызывают trade-овый.
Короче, свой библиотечный, но он вызывает drop, действительно.
Мы сейчас это увидим, дальше как раз будут примеры про drop flex и все такое.
Надеюсь, давайте мы попробуем сейчас приостановить вопросы, пойдем дальше.
Посмотрим другие примеры, если вопросы останутся, продолжим на тех слайдах обсуждать.
Так, вот как раз вопрос про drop flex.
Вот у нас бокс.
Бокс, насколько мы помним, это что-то на хиппе.
То есть это, грубо говоря, int, указатель на int x, равняется new int 92.
А можно прятаться над знанием шляпки бокса?
Бокс это просто, это как юник-пойнтер, только без нула.
Обязательно не нул.
Потом мы какое-то условие проверяем.
В зависимости от условий либо y при своем значении x, либо z при своем значении x.
Это будет компилироваться, это будет работать.
Но как раз-то понять, что ему надо диалоцировать, y или z?
Тут, конечно, он пользуется невидимыми флагами, такими на стеке.
Он указывает, какая переменная была инициализирована из двух.
Соответственно, либо y он будет диалоцировать, либо z.
В зависимости от того, какая из них инициализирована.
А это все уже в рентале?
Ну, конечно, в рентале.
Диалокация, но локация-диалокация, это все рентально.
Ну, он же не может заранее по условию понять.
Ну, если оно, конечно, константное, он это соптимизирует.
Но если не константное, например, в зависимости от какого-то инпота, то он уже не поймет.
Ему нужно не поймать.
А если после этого кода мы напишем print z?
Он будет ругаться на то, что я использую инициализируем?
Да, он скажет, что она maybe initialized.
Ну, конечно, такой код лучше не писать.
Лучше написать там, не знаю, в рентале.
Лучше не писать.
Лучше написать там, не знаю, let t равняется if condition x.
Хотя там в любом случае x уравняется.
Поэтому код в любом случае странный.
Вообще это странная фигня, потому что у нас нет муд, как минимум.
В плане нет муд.
У нас RAST позволяет просто неинтилизированное переменное создавать.
Там есть несколько этапов.
Есть это pattern matching вообще.
Да, это правда.
Я как-то не понимаю, что он здесь делал и почему это работает.
Ну, когда он let y, он просто создает неинтилизированную переменную.
Там есть несколько этапов в жизни перемен.
Неинтилизированная, неинтилизированная не используется,
инициализированная используется, и потом диалацирована.
Какого типа неинтилизированного?
Ну, смотря какой ты укажешь.
Ну, то есть либо ты какой укажешь, либо какой выведет RAST с помощью type inference.
А если он не может вымесить?
Он пожалуется на тебя.
Годей.
Скажет, я сам не могу, укажешь мне какой тип.
Ну, просто в любом случае тогда не будет знать,
сколько ему нужно на стейки байтов выделить.
Вот это вот, кстати, прекрасный пример с такой прекрасной книжки.
Называется RAST for Ostasians.
Если у вас есть прям фанатизм RAST, то я очень рекомендую эту книжку.
она очень глубокая и в ней очень много полезного материала.
Давайте мы посмотрим такую вот штуку.
Мы создаем применную x, потом мы присваиваем значение,
мы пока что не обращаем внимания на комментарии.
x присваиваем значение 42, потом у нас y это какая-то
ссылка на x, и к сумму присваиваем значение 43, и это компилируется.
И примерим, что ссылка на y равняется 42.
Как же это работает?
Это все добро.
Почему оно компилируется?
Ну, это на самом деле не помнится.
На самом деле давайте мы подумаем, как Borrow Checker.
Да, это он говорил упрощенно.
Вот у нас есть какие-то скопы, в которых все что-то проверяет раз,
что у нас время lifetime это scope.
На самом деле lifetime это целый flow, то есть вы знаете control flow, что такое,
да, там UEFI, например, вы либо в одну веточку пошли, либо в другую, да.
Да, и вот по сути то, что проверяет раз, это на самом деле не просто scope, а целый flow.
То есть то, куда может пойти переменная, и где она может деинцелидироваться,
всевозможные варианты.
У нас разве не было гарантий, что у нас в одно время может быть либо мутабельная ссылка, либо...
А мы сейчас как раз проверим, почему это компилируется, мы прямо увидим.
Мы сейчас проговорим, как она там работает, эти flow, да, какое у нас есть.
Так, смотрите, для начала у нас есть первая штука.
Мы сначала пытаемся X присваивать значение...
Давайте так, sRTQLX42, это, естественно, не сработает, потому что раз, понимаете,
X дальше используется, соответственно, как минимум вот такой вот у него будет flow,
то есть он будет жить вот в этот момент.
И в этот момент X обязательно будет неинцелизирован.
Раз, пожалуй, он скажет, что он пользуется неинцелизированной переменной.
Да, он просто не скомпилирует этот код, он скажет, что X неинцелизирован, как же так.
То есть, например, в СИБе этот код скомпилировался, и мы бы могли потенциально получить CV-шку
с прошлой лекции, которую я показывал как раз.
Вот.
Потом дальше.
Мы можем, естественно, взять ссылочку на X, потому что у нас X все еще живет.
X у нас, как мы видим, живет вот аж до этого момента, да.
Это окей, потому что мы можем взять из этого flow, то есть взять ссылочку на X и присваивать значение Y.
Y в таком случае имеет тип ссылка на Y32.
И вот это вот уже здесь создается второй мутабельный flow.
То есть у нас flow до этого был не мутабельный, а сейчас он становится мутабельный.
И это важно, у нас два типа flow.
Flow может быть не мутабельным, flow может быть мутабельным.
То, что мы хотим, это чтобы не пересекались два мутабельных flow одновременно.
Сколько угодно не мутабельных, мы не хотим, чтобы пересекалось много мутабельных одновременно.
Иначе мы нарушим гарантии раста.
Да, до этого у нас просто был X, но мы инцелизировали перемен, но это пока что не мутабельность.
Просто инцелизация переменной.
Вот мы берем какую-то ссылку, а дальше мы уже начинаем мутировать.
Соответственно, раст уже такой, ага, значит мы у нас мутируем переменную, мутабельный flow.
Но нужно, чтобы у нас в этот момент ссылочки не жили, которые у нас обычные.
Так, дальше вот будет момент, сейчас мне самому нужно вспомнить.
Вот так.
Так, ну вот мы как раз вот делали все.
Так, а почему это, почему это так?
Просто вроде бы мы изменили X.
Сейчас, секундочку, я вот сам запутался.
И при этом у нас мутабельный flow, у нас вроде бы закончился.
Но дальше я не совсем понимаю, почему у нас тогда вот это вот так сердце работает на 42.
Да, у нас все-таки два объекта, и у них разные омеры.
Может быть, все-таки 223 разные объекты, если считать.
Ну или кто-то у нас ссылается на один тот же X.
Не, не ссылается, да, на один тот же X.
Ссылка на X я вот сейчас, я сейчас чуть-чуть потерялся.
Так, знаете, я вот пока что запутался.
Давайте я потом пересмотрю в книжке, почему это работает.
Просто наскажу, подзабыл.
Ну посмотрим сейчас.
Ну не сейчас, а переменка будет, она буквально совсем скоро.
Я посмотрю в книжечке, я вам сразу же отвечу.
Свернемся к этому слайду, вернемся.
Просто я не пересмотрел эти слайды, если честно, и в итоге вот сейчас путаюсь.
Все хорошо с таким решением, да?
Все равно отвечу на ваш вопрос, просто чуть попозже.
Вот.
Так.
Потом у нас есть X1 равное 42.
Так.
Потом у нас Y1 это какой-то бокс.
У нас он создает новый скоп.
Ну он создается новый скоп.
У нас можно делать точно так же, как в плюсах, скажем.
То есть вот такое создание скопа.
Внутри у нас есть Z, которое состоит из X1 и Y1.
И так как оно выходит из этого скопа, оно должно быть дропнуто.
Ну и соответственно он дропает X1 на X2.
Так.
Ну и соответственно, так как X1 это копит, в таком случае оно не было мувнуто в Z.
То есть оно было там внутри, где тюпол, оно было скопировано.
Поэтому у нас будет работать X2 равнятия X1.
Но при этом сделать Y2 равнятия Y1 мы не сможем.
Потому что у нас бокс это не копий тип.
И раз, соответственно, это как-то не скомпилирует.
Потому что мы мувнули на третью тюпол.
Этот пример достаточно простой.
Мы уже много раз говорили про копийку.
Да, Y1 мы муваем, а X1 мы копируем.
И вот получается, на этом первая лекция у нас заканчивается.
Так.
Ну, в общем-то мы на нее успели узнать, почему у нас...
Раз тут.
Который вот этот?
Сейчас.
Вот этот?
Значит там...
А попробуй сорок раз.
Ну, в общем-то, мы на нее успели узнать, почему у нас...
Раз тут.
Который вот этот?
Значит там...
А попробуй сорок три поставить.
Или там как-то другая ошибка.
В общем, давай я посмотрю это конкретно на переменке.
И прямо вот хорошо объясню.
Что здесь произошло.
Вот прямо останемся на этом слайде.
И передвинемся к следующему.
Ну, давайте, может, чуть-чуть еще позанимаемся.
Потому что еще только шесть, прошло меньше часа.
Ну, давайте, может, чуть-чуть еще позанимаемся.
Потому что еще только шесть, прошло меньше часа.
Потому что еще только шесть, прошло меньше часа.
Ну, и потом перерывчик идем.
Так.
Так.
Если мы пришли ко второй лекции,
на ней мы поговорим про стандартную библиотеку РАСТа.
И то, что она из себя представляет.
И даже сравнимую с Пельсовой библиотекой.
Что там у нее есть?
Так.
Конкретно мы посмотрим на опцион и результат.
На век и век дек.
Ну, соответственно, B3M, B3Set,
HashMap и HashSet.
Бинарная куча, LinkItList.
Строка ее Slice.
А еще, еще раз посмотрим.
Чуть-чуть буквально на бокс.
И на IRC.
Вот.
Это такие ключевые вещи
в библиотеке РАСТа.
И вы знаете писать какие-то вещи,
которые связаны больше с алгоритмами.
Так. Ну, начнем мы, конечно, с опцион и результат.
Так. Вы же, наверное, встретились
с ними в домашке. Особенно во второй домашке.
Так.
А что-что?
Ну, как минимум, в ком точно было.
Ну, я там в первой домашке
очень точно делал результат.
Я немножечко игнорировал.
Ну, во второй домашке он уже появился.
Первая, которая первая, вторая.
Не, вообще, SDDCollections
это которая вторая домашка.
Так. Давайте вспомним
в первой лекции как же они выглядят.
Это просто вот такие вот янамчики.
Самые-самые глупые янамчики.
Ну, опшена себя представляет опять же какое-то значение
либо наум.
А результат это либо какое-то значение
либо ошибка
с каким-то типом. То есть ошибка тоже
является какой-то структуркой.
Так.
Что мы умеем делать с опшеном?
Во-первых, мы умеем матчить.
Вы это, наверное, делали
в домашке.
Мы уже почти наверно.
Ну, на самом деле, это не самый
эффективный способ работать с опшеном.
Мы сейчас посмотрим немножко на его афи.
Вот.
Это не функция. Это один из вариантов янамы.
У нас же вот, смотри.
Смотри, опшен это либо самти
либо наум.
Вот, видишь?
Мы же хотим
по матче. То есть мы хотим
в одном случае пойти либо
сам какое-то значение
и в другом случае если наум.
Это паттерн матчинг здесь
подходит. Смотри, у нас
результат какой-то опшен либо
сам либо наум. И он пытается
поматчить результат сам с.
Если там наум, то тогда сам с и наум
они друг под друга не подходят.
Правильно?
Ну, наум и сам это разные вещи.
Это название.
Это название.
На исполе.
Это не очень правильно
описать это, потому что
могло быть третье
поле.
Да, могло быть третье поле, которое
бы тоже конструировалось.
Да, это все разные конструкты, все хорошо.
Ну, тут можно просто путать.
То есть можно было написать
сам а.
В смысле, имеется бы другое имя.
Да, можно сам а написать,
можно написать свое имя.
Что угодно.
Так.
Вот так вот примерно работает
матча. Вы их наверняка писали.
Вот.
Потом
у нас есть очень важные
две функции.
Вы ими тоже, наверное, пользуетесь.
Expert не факт, а Unwrap, наверное, использовали.
Вот. Unwrap
у нас паникует, если у нас наум,
иначе он возвращает тип T.
То есть он применяется в том случае,
если вы прямо уверены, уверены, что
у вас внутри лежит сам T.
Ну, иначе он будет считать, что это фатальная
ошибка и будет пениковать, что вы
где-то нарушили свои же инвериенты.
Expert это то же самое, что Unwrap,
только он будет еще сообщение
в панике выводить, то, которое вы ему дадите.
То есть не просто там
Unwrap on a non-value,
а какое-то более
информативное, которое вы сами зададите.
Это бывает полезно.
Ну, примерно вот такие
вот давайте
посмотрим, например, использование.
У нас есть
какой-то OPT, это сам
от нашей сегодняшней даты,
которая кстати, зеркальная.
Вот. Соответственно, она имеет тип
Option от I32.
Естественно, это сам
и это не наум.
То есть у нас есть такая функция и сам есть наум,
которая позволяет узнать, какой
из вариантов Unwrap перед нами на данный момент
находится.
Потом
можем сделать Unwrap
и посмотреть на значение внутри.
Причем,
вот здесь вот вы можете обратить внимание
на то, что Let X равняется
Opt Unwrap тоже сработает.
Но как же так? У нас же Unwrap принимал
на вход Self. То есть мы
по сути передали ему владение
и забрали T. А здесь
это скомпилировалось, да?
Потому что у нас если тип
3 это копия, то в таком случае
Option это тоже копия.
Он наследует.
Вот.
То у нас есть какой-то
другой Option. Ну я назвал его
там Option I32, который
будет пусть вариантом наум.
Ну и соответственно, я вам примерчик
такой дал того, как работает
Expect.
Он выдаст сообщение I'll panic.
Потом
давайте еще какой-то New Opt
сделаем. Это будет сам от какого-то
вектора I32.
И попробуем Unwrap.
Оно точно так же
сработает хорошо. Но когда мы попробуем
Unwrap еще раз,
как мы это сделали сверху,
то это не сработает. Потому что у нас
тип вообще-то Vector это clone, и поэтому
когда мы Unwrap,
то мы действительно уже передаем владение.
А не просто копию.
В плане
определить методы
для Enum.
В плане
определить методы для Enum.
Вот я написал там свой Enum,
но методы для него я не смог
написать, чтобы вот точкой
выискать. У нас же Option
это Enum.
Да, ну в смысле ты говоришь
сделал какой-то свой
MyOption, да, и там.
Ну ты же можешь написать ему IMPAL
типа MyOptionT внутри сделать.
Тебе это должно было компилироваться.
У нас даже примеры
будут даже, по-моему,
когда имплы есть.
По крайней мере, такое точно было в первой лекции,
оно должно было компилироваться.
Так.
Есть еще такая вот волшебная функция
SRF. Она вам понадобится,
когда вы будете писать такие
домашки, активно использующие
Option. У нас такие будут.
Она делает
так. Если у нас есть ссылка на OptionT,
то в таком случае она превращает
это в Option от ссылки на T.
То есть ссылочку внутрь загоняет.
Это весьма и весьма полезно.
То есть позволяет, например, сделать
Unwrap после этого SRF, Unwrap,
и после этого мы получаем ссылку на T, не просто
T. То есть мы с одной стороны не сломали
Option, мы его
не съели, и с другой стороны
мы получили ссылку на T, как хотели.
Почему мы не съели?
Потому что передали нас.
Смотри, SRF у тебя до этого
был какой-то Option.
Сейчас посмотрю пример.
Давай посмотрим сразу на код,
который я написал. У нас есть NewOpt
какой-то. Это сам от вектора.
Если мы Unwrap, мы получим
соответственно вектор.
Если мы попробуем Unwrap еще раз,
мы получим ошибку. Это ровно то же самое,
что мы делали на прошлом слайде.
А теперь давайте попробуем SRF.
У нас есть NewOpt SRF Unwrap.
Мы передаем NewOpt наш
Option по ссылке.
То есть у нас там ссылка на Option по T.
Когда мы сделаем Unwrap,
то мы получим ссылку
на T.
Соответственно мы здесь получили
ссылку на T, и мы не сломали NewOpt.
Потому что мы убрали
по ссылке, соответственно его никто не
закомсюмил, никто не съел, и поэтому можем
дальше сделать Unwrap LetX.
Это даже будет работать.
Сейчас я в этом примере еще не
использую SRF Unwrap.
А, вот, не использую.
Вон там есть SRF Unwrap.
Какое качество?
Там, где нижний ассерт, там должен был быть
Opt-Ref.
Какой еще раз нижний ассерт, который
NewOpt? А, да, Opt-Ref.
Здесь обсяточка.
Опт-Реф.
Да, да, это обсяточка получилась.
Это не Opt-Ref, это Opt-Ref.
Да, вот здесь Opt-Ref, Opt-Ref, Opt-Ref.
Сейчас, а во втором ассерте
еще раз, если SRF убрать,
то что будет?
Если убрать SRF,
вот здесь вот.
В таком случае ты просто, смотри,
передашь по ссылке Unwrap.
Вот, видишь, Self. Он законсюмит в таком
случае.
А у нас SRF работает как ссылка
на Self.
Ну, мы же сделаем Unwrap,
мы получим, соответственно,
вектор I32NU.
Обратите внимание, что здесь просто
вектор I32NU.
То, что мы получим здесь вот
T, а вот здесь получим ссылку
на T.
Сейчас, просто вектор I32NU
он создаст абсолютно новый вектор,
там основы и ссылки
на кучу. Почему?
Ну, сравнивается, что они не побитые.
Из-за того, что они пустые.
Сейчас, подожди.
Вектор на равенство проверяется
по элементам просто.
И все.
Здесь то же самое, здесь, правда, там будет чуть хитрее,
там будет trade DRF.
Ну, короче, в общем, по ссылке он тоже
будет сравнить их.
Вот, корректно.
Так, потом.
Есть такая прекрасная функция
Web. Это, наверное, самое частое, что
я использую.
Она превращает option T в option U.
Сейчас.
А мы не будем обсуждать, как работает
под роботом SRF?
SRF, на самом деле, очень просто работает.
Там внутри, но я могу тебе даже
сказать, что там происходит.
Там вот SRF написан, option T.
Внутри написан match self.
Ну, self – это ссылка на self,
то есть ссылка на option.
Если это сам X, то возвращается X,
все.
Ну, просто там получается по системе типа фразы,
что когда ты матчишь ссылку на
self, то в таком случае он не
consumes option. Он просто
уберет по ссылке и вернет ссылку
на внутренность.
То есть в матче фор они как бы прогрессуют ссылку
на элемент.
Матч, да, ты про фор сейчас
сказал. Да, и фор
по умолчанию он тоже по значению
забирает. Там можно по ссылке, по мутабельной
ссылке передавать, и в матче то же самое.
Вот.
Ну, соответственно у вас конечно
будет меньше прав, да, вы сможете
только читать элемент.
Ну, это никакой проблем.
Еще я, кстати, забыл сказать, кроме
SRF есть еще SMUTE. Это то же самое,
только будет мутабельная ссылка на option
и возвращается мутабельная ссылка на T.
Просто мутабельность.
Так.
Смотрите, у нас дальше есть
option и
ну, мы пытаемся
перевести из одного типа в другое, с T в U.
Это очень-очень полезно.
Часто нужно, на самом деле, на практике.
Особенно
когда у вас там всякие error-handling
и даже без них иногда хочется
просто поменять типа option.
Вы можете написать мэп
и внутри него закинуть, ну, пока что
можете читать лямбду. На самом деле это называется
closure. Такая штука.
Вот.
Ну, то есть вы пишете через вот такие вот
палочки
понимаемое значение.
Ну, и там, соответственно, внутри уже
саму лямбду. Если она однострочная,
то можно без фигурных скобочек либо фигурных
скобочков.
Вот. Ну, работает, в принципе,
как лямбда в плюсах. На самом деле
чуть-чуть по-другому, потому что она
все-таки zero-cost abstraction.
Но мы пока что не будем
подробно останавливаться. Можете это
смотреть как на лямбду.
Вот.
Ну, и здесь у нас в примере
мы берем string from HelloWorld,
маппим строчку,
изменяем наш
auction, маппим в SLAM.
То есть у нас...
Так, вот
мы как раз когда будем говорить про строки,
мы как раз поговорим про это.
Ну, смотри, у нас просто
HelloWorld, это, я в двух
словах наперед скажу, это на самом деле строковый
slice просто. А для того, чтобы получить
именно саму строчку, владеющий тип,
ну, у нас же есть вот вектор, есть slice
вектор. Вот это тоже самое.
У нас есть строка, есть slice строчки.
Чтобы из slice строчки HelloWorld
получить владеющий тип, нужно сделать string from.
То есть прямо пролатировать.
Вот.
Так. Ну, вот
мы маппим в SLAM. После этого,
как вы можете заметить, я
проверяю, что это действительно сам 13.
Сейчас обводую я
еще один спирт.
Это называется closure, это типа лямбда.
Вот. Вот это вот типа на вход
принимается. Это то, что у нас внутри
само опциону лежит.
А это где?
В маппе не нужен. Как я запутаю?
Сейчас это
а, это дальше
тема.
Так.
Вот.
Ну,
у нас на вход здесь принимается тип T,
а потом возвращается тип U. Вот эта вот
строчка, она будет иметь тип string.
Это будет иметь тип, соответственно,
U-size, потому что LAM возвращает
U-size. Соответственно, мы изменили тип
из option string
в option U-size.
Вот здесь.
Так.
Здесь вот это вот просто, чтобы вас
показать все, что
умеет option, умеет очень много.
И это настолько, вот
вы...
Кто-нибудь из вас знаком хотя бы издали
функциональными языками.
Так.
Так, давайте
вернемся к Расту.
Раст, кстати, это
такая
зажигательная
функциональность.
Так, давайте
вернемся к Расту.
Раст, кстати, это такая
зажигательная
функциональность.
Так, давайте
вернемся к Расту.
Раст, кстати, это такая
забавная информация.
Раст, на самом деле, можно рассматривать
как в каком-то смысле
функциональный язык без garbage collection.
Да, по некоторым причинам, просто в
функциональных языках, я, честно, примеров
так не могу вспомнить, но они прям есть.
Когда в функциональных языках
просто нельзя обойтись без garbage collection,
потому что они вот так вот устроены.
Ну, я сам, честно говоря, не шарю.
Ну, Раст вот устроен так,
что, в принципе, можно смотреть в него как
функциональный язык без garbage collection.
Вот.
И вот, смотрите, здесь вот можем с option вот
такой вот машинелью делать. Можем его преобразовывать
так, что у нас в итоге
получается
на самом деле прикольный код.
Вот.
Не, ну, это пока что для вас смешно, типа, но потом
вам понравится.
Да, там может быть
map, потом можно преобразовать это
в result, потом из result,
если ошибка вот это, если
вот это.
И это все через pattern matching.
Да, это внутри там pattern matching, это
на самом деле все zero-cost, то есть тут работает
быстро. Давайте я про эти функции
в паре слов что-то скажу.
Они
все прекрасные, они на самом деле умеют
такие штуки. Например, map,
or, в случае, если у вас
какое-то значение t внутри хранится, он применит
вот этот лямуток f,
вот функция, в которую
вы передадите. А в противном случае, если там
now, то тогда он запомнит его каким-то
дефолтным значением u.
И это на самом деле удобно
бывает. То есть у нас в таком случае получается
в конце просто u, как вы видите.
То есть даже не option, просто типа u.
Map or else там делает
еще какую-то вещь, то есть он смотрит
по-моему там просто вторая функция,
то есть там дефолтное значение задается
функцией.
А не просто значением.
То есть там получается
уже два closure, а не closure и значение.
Есть всякие end.
То есть это логические операции. Если у вас
option это sum, и второй option это sum,
тогда он возвращает
первый option.
Например.
В первом случае функция
должна вернуть типа u?
Да, она должна вернуть типа u.
Обязательно.
Просто преобразуемся в u, и тогда
все раз пожалуются.
Вот.
Ну или там or, например.
Если у нас первое это sum,
то тогда возвращает первое, иначе возвращает
второе значение.
То есть можно
писать, по сути, это такой декларативный язык,
на котором можно написать такую произвольную
логику.
Я вам очень советую почитать документацию.
То есть у нас там есть, например, ссылочки,
буквально там, я прямо покажу,
в каждой главе у нас есть
option documentation и result documentation.
Считайте их, это очень полезно.
И постарайтесь, когда вы будете
писать код,
минимизировать число матчей.
Сначала будет очень больно, но потом вы поймете,
что от этого код гораздо короче.
Гораздо короче, гораздо красивее,
и на самом деле гораздо даже понятнее.
Ну и даже безопаснее, на самом деле,
потому что это функциональный код.
Такой с точки зрения телевизора типов
что появляется.
Так.
У нас на самом деле в option есть еще
такие вот вещи, которые связаны уже с
ownership'ом. Это take, replace,
insert.
Такая вот отличная функция,
которая нам частенько будут нужна, когда мы будем писать всякие
структуры данных на расти.
Take, если у нас есть
option, то в таком случае он берет мутабельную ссылку
на этот option.
И если этот option noun,
то в таком случае он возвращает noun,
иначе он возвращает сам te
и оставляет на месте
это option, в котором мы это вызвали, noun.
Верно?
Еще раз.
Ну он возвращает option te.
Он возвращает option te,
просто по сути он возвращает этот же
option.
И ставит там noun.
То есть он вернет текущий option и оставит
noun на том месте, в котором мы это вызвали.
Это полезно, когда вы хотите забрать
владение над типом, но при этом
не хотите уничтожать сам option.
Это полезно, например, во всяких бинарных деревьях.
Потому что иногда у вас есть только
мутабельная ссылка, когда вы там по нему
интерируетесь, и
владение вы не можете забрать.
Просто так. То есть у вас есть take, который
это позволяет сделать.
В том есть replace.
Реплейс это, знаете, частенько
когда рассказывают про всякие стд мемы
replace, которые еще есть в Rust, и вот этот вот
replace показывает такую картинку с
Индиана Джонсом. Наверное, помните, где он так
менял вот, там быстро
какой-то там грааль, вроде бы, точно
не помню. Но в общем, replace
это такое, то что inplace, оно быстро
меняет значение на te и возвращает то, что было.
То есть оставляет на нашем
типущем месте сам te
и возвращает то, что было.
Так?
И опять же, это все происходит
так, что мы ни в какой момент
времени не оставляем неинициализированного
пустого значения.
То есть, например, если бы мы в каких-нибудь
плюсах хотели сделать вот такой вот, ну, допустим
take. Take чуть попроще.
То мы бы
наткнулись на то, что пытаясь взять значение,
оно в какой-то момент было бы неинициализированным.
Мы move-нули его оттуда и оп, и у нас
в какой-то момент остался неинициализированным. Как-то
небезопасно.
В какой-то момент времени там не будет
неинициализировано. Это ладно для многопоточного кода.
В плане
чего?
Ну, вы сказали то, что replace, он как-то
вот так, сразу. Да, он для нас
так со стороны выглядит, как-то мы Indiana Jones.
Ну, в однопоточном коде нам не
важно.
Если что, в общем
многопоточном коде так не получится.
С ним работать, он не многопоточный.
Это просто для того,
чтобы с barrel-checker-ом это хорошо работало.
И чтобы в любой момент времени у нас был
какой-то инициализированный, хороший
auction-сохранящий вариант.
То есть либо там sum-t, либо num.
А не sum и bit-t.
Которые нам нельзя исполнить.
Ну, insert даже проще.
Он вставляет просто значение.
И возвращает на него мутабельную ссылку.
А то, что у нас там было внутри, он просто
съедает и ничего с ним не делает.
С этим значением.
Давайте посмотрим такой пример.
Я думаю, на этом сладе мы задержимся
дольше всего.
Потому что это попытка
посмотреть на single-linked-list
на Rasti.
Как вы, возможно, когда-то слышали, на Rasti
очень сложно писать такие структуры данных.
Но здесь был настолько сладкий пример, что я не мог просто
устоять и решил вам показать, как можно
воспользоваться общем.
Давайте для начала посмотрим на структуру ноды.
Ну, у нас же есть ноды.
Она хранит какой-то тип T.
Вот элемент T.
То есть у нас есть следующий элемент.
Это option-box-not-T.
Вот.
Насколько вы должны помнить с первой лекции, option-box
это как unique-pointer.
То есть это либо next у нас
now, то есть нет следующего элемента.
Либо сам box-not-T.
То есть что-то есть.
Box нам нужен для того, чтобы следующая
локация была на хипе.
То есть чтобы у нас каждый следующий элемент был
на кучу.
Ну и соответственно, потому что следующий элемент
у нас not-S, соответственно not-T.
Вот эта вот конструкция из
четырех типов. Понятно?
В принципе, должен быть
присутствовать. Понятно.
То у нас есть лист.
Спрашивается, а почему мы там не храним просто
box-not-T, казалось бы, да?
Лиза у нас может быть пустым, да?
Например.
Поэтому у нас либо нет хеда, либо
есть какой-то там.
У нас тут тоже вот такая структура.
Еще скажу, что частенько прописывают
option-box-not-T как
type какой-то, там type-link.
Наверное, знаком с таким
ключевым словом, но просто это
способ написать это все
кратко.
То есть сделать алиэс.
Все это в длинной машинейре.
То у нас есть функция. Давайте посмотрим
на pop.
Это такой вот очень правильный растовский
дизайн. Возвращать
если у нас лист пустой, то возвращать
науны. Не паниковать, например,
выдавать УБ как в плюсах.
Поэтому встречаем либо науны, если у нас ничего
не было, либо Т.
Вот мы смотрим на наш self-head.
Забираем хед.
Если
если у нас нода, в общем-то
не пустая, то в таком случае у нас
работает мэп и мы
скажем, self-head это теперь node-next.
И возвращаем
элемент, который у нас есть.
То есть таким образом мы
преобразовали option-T.
с option-box-node.
Все полностью повторить?
Нет, отличная стейк.
Не можете наполнить стейк?
Take он собственно дает
текущий option и оставляет
на месте старого науны. То есть у нас
в тот момент, когда мы сделали self-head-take,
head стал наун.
То есть мы забрали просто его.
Да, мы его маппим.
Если у нас наун, то
наун. То есть мы забрали наун
с хеда, у нас пустой список, нам нечего
делать, мы возвращаем наун. То есть у нас мэп просто
не сработает, потому что он работает на сам.
Мы вернем наун
в общем-то. Если же
там было сам какое-то значение,
тогда мы посмотрим на эту ноду.
Принимаем наход.
И делаем, мы захватываем
наш self отсюда.
Мы говорим self-head, теперь это node-next.
То есть мы берем
первую голову списка.
У нас был лист, мы забираем
голову списка себе.
Потом мы говорим, что у нас теперь
если оно не нам, то в таком случае у нас
self-head. Self-head это теперь
node-next. То есть мы делаем ссылку
сюда с листа теперь.
А следующий элемент.
И возвращаем элемент отсюда.
То есть тем самым мы диалацируем это все.
И эта вот ссылка, все это пропадает.
Бокс диалацируется.
Мы забрали отсюда t.
Так.
Поскокнуло?
А там так и реализовывали?
Где там?
Ну, вообще там
double-linked-list в Rastia.
На single-linked-list
мало значения имеет, потому что
можно в деку просто написать.
Там нет конструкции unsafe, или там они
на unsafe все написали?
Там на unsafe
скорее всего, потому что
производительность была высокая, там наверное
лишние байтики эти
не держат с опшены.
Прям пишут на unsafe.
Мы используем
нода.
А нод это не отличная структура.
Это хороший вопрос,
но это вопрос, наверное, при четвертую лекцию
про cargo.
Ну, вообще, даже если мы здесь беру папу,
вот эту беру папу, она все равно будет работать.
Это просто будет означать, что
вот это все находится в одном файлике, как можно
догадаться, да, весь этот код.
И он будет доступен
с любой точки этого файла, будет доступен
с любой код с этого файла.
Папа
для кода вокруг, типа, то, что
вне этого файла.
Ну, там
я не знаю, как джаг работает.
Нет, они
все приватные, то есть если хочется сделать публичный
поэк, то нужно написать pub elem, например.
Я же обращаюсь к элементу
ноды.
А здесь внутри, я говорю, файла,
ты можешь как угодно обращаться, то есть ему
без разницы, но то написал ты pub или нет.
Это будет иметь значение.
Elem, next, они публичные
в рамках файла.
Да, в рамках файла, да, если ты с соседнего файла заимпортишь
лист, вот он как раз pub struct, да,
и вот здесь как раз pub fnpub,
то при попытке, например,
заинтересировать какую-то ноду, он скажет, что
структура приватная.
Сделайте публичную, либо изменить свою.
Растяжение туда классное.
Да, вот это вот struct,
struct и trader, все.
Здесь вот написаны какие-то
страшные вещи,
часть из них не обязательно понимать
прямо на данном этапе.
Да, раз гарантирует
нам то, что option будет
оптимизировать,
ну, option будет оптимизировать
свою репрезентацию для
некоторых структур. Например, для бокса.
Бокс у нас, например, насколько
мы помним, не null, да. Соответственно,
если мы сделаем option box,
то в таком случае у нас
null-овый указатель
в боксе будет означать, что у нас вариант
null. Ну, то есть он
раст это, будет учитывать
и не создавать новое
повали в дискриминанте.
Это как раз то, что мы обсуждали в первой лекции.
Аналогично, про ссылку. Ссылка не может
указывать на null
элемент, только на нейтализированный.
Соответственно, option
отсылки на t тоже
оптимизируется. То же самое
с мутабельной ссылкой.
Вот это дальше. Можно всякие функции
внутри держать. Функции, естественно, тоже
не могут быть пустыми, потому что вы указываете
какую-то конкретную функцию, которая будет в option.
Если вы какую-то функцию
сишную вызываете, то она тоже
не пустая. То есть, ну, там не
сишная, какую-то внешнюю функцию,
она тоже какая-то не пустая,
она тоже будет проницилизирована. Соответственно,
раз этим пользуется, раз оптимизирует
репрезентацию option.
Чтобы он занимал ровно столько же байтов, сколько
занимает указатель на
функцию.
Сейчас еще раз. Почему?
Почему
не можно написать option
от node.t? У нас бы тогда
все было на стеке.
Вообще все, весь лист.
Просто бокс, нам же нужно, чтобы
у нас указатель все на хипе было.
Мы бы могли, конечно, это сделать, но
тогда бы просто...
Ну, если у нас хотя бы одна нода
выйдет тогда за
радиус видимости, раз нам скажет,
за свою область видимости, тогда раз нам скажет,
что лист
живет слишком мало
для того, чтобы это содержать значение.
В общем-то нам
наверное мало смысла имеет содержать
такой option node.t.
Еще, кстати, есть одна проблема.
Она не скомпилируется...
Да, я вот это хотел сказать.
Это рекурсивный тип, поэтому он не скомпилируется
на самом деле.
Если просто убрать бокс, то это не скомпилируется.
Потому что это рекурсивный тип
потому что node, node, node, node, node
типа option же он должен занимать
как минимум место node.t
и оно будет рекурсивно вычисляться
и расскажет этот рекурсивный тип.
Вот.
Так видите, презентация транспорта.
Это означает просто то, что
у нас структурка
будет иметь тот же самый вид
что... Смотрите, структурку, например
создал с одним полем.
Структуру с полем X
какого-то типа.
Если он представит репорт транспорта,
то в таком случае эта структура будет иметь
абсолютно точно такую же репрезентацию,
как и само поле X в памяти.
А по умолчанию, раз, не дают никаких
гарантий по поводу того, как этот тип
будет выглядеть.
То есть он может перемешать их.
Казалось бы, одно поле из одного
типа. Казалось бы,
просто вставляя репрезентацию этого типа,
он на самом деле нас может перемешать, потому что
ему так захотелось.
Репорт транспорт нужен
скорее для оптимизации
и для того, чтобы быть
уверенным в том, как это будет все работать.
То есть уверенным репрезентацией
когда ты хочешь,
чтобы ты был уверен, тогда ты это пишешь.
Вот.
Я думаю, что мы сейчас досмотрим
на опшен и пойдем на перерывчик.
А, мы досмотрели
на опшен.
Идем на перерывчик. Давайте
через 10 минут,
ну 35 минут.
Так, для начала
вернемся к этому примеру. Давайте.
Самая большая проблема,
когда я на нее смотрел, я с одной стороны
вижу, что он не должен компилироваться,
а с другой стороны у меня в голове мысль о том,
что это пример должен компилироваться.
То есть, я думал, что у меня где-то
противоречие в голове. Казалось, что он
не должен компилироваться. То есть, это
пример того, как пересекаются
мьютабл флоу и мьютабл флоу.
Смотрите, у нас есть
let mute x, вот там x 42,
и здесь x 43.
Вот с этой строчки по этой строчке,
с x по 43, это все
мьютабл флоу. То есть,
вы увидите, у нас есть x, и мы его мутируем.
Вот мы его здесь не перемутируем.
Там мы присваиваем, вот здесь x
создается. Вот это все
мьютабл флоу, вот эти вот три строчки получается.
Так?
И здесь у нас есть
мьютабл флоу. То есть, у нас есть
let y, это ссылка на x.
Дальше с артикул y
и 42. Здесь у нас уже
получается мьютабл флоу.
И они пересеклись, как вы видите.
То есть, у нас есть имутабельное
и имутабельное флоу, и имутабельное флоу они
пересеклись, и раз, закономерно, наш код
блокчет. Говорят, что так нельзя делать.
Так понятно, да?
Оказалось, я просто-просто
не противоречиваю голове, извините.
Так. Вернемся
к результатам.
Так.
Мы обычно, ну, вообще
результат это один из способов
фарер хендинга. Ему же относятся
в принципе.
Но результат это уже такой для того, чтобы
посмотреть, какая ошибка была.
То есть, если у вас их там может быть много, например,
ошибки EO. Какая конкретно там ошибка?
Например, файлы не смогли открыть.
Я не буду, наверное, перечислять
миллиарды файлов все.
Вот.
Вот, например, ошибка EO может быть
одной из этих.
Вот.
Собственно, в SDCrate
результат преимущественно используется для EO.
Вот.
Еще есть такая вот штука. Результат
обязательно должен быть использован.
Мы не можем скипнуть его использование.
Вы, наверное, знаете, у нас
в плюсах есть такой атрибут.
Что-то я, честно говоря, название подзабыл.
Нолдискар.
Вот.
И, наверное, на курсе TPCC
вы вспоминаете про эхо.
Задачку.
Файберную.
Он кидает варнинги,
насколько я помню.
А потом...
Вот.
Ну, в общем-то,
как раз в этой дачке
у вас появлялся результат.
Как такая структурка.
Это как раз был результат из Rust.
То есть был с нолдискартами
такой, конечно, немножечко обрезанный,
но уже очень похоже на то,
что у нас есть
в Rust.
Я в прошлом году помню,
что-то говорил Липовский про то,
что Rust — это наше светлое будущее.
Мне больше всего запомнилось.
Должна была быть заставка курса.
Да, я, кстати, думал
что-нибудь скриншотик сделать субтитрами.
Ладно.
В общем, здесь у нас
есть такой атрибут mustUse.
Тоже есть атрибут.
И он говорит нам о том, что мы не можем
скипнуть с пользы резалта.
Мы точно так же будем получать варнинги.
Он будет говорить, что вы должны явно
что-то сделать с резалтом.
Один из вариантов — это, например, сделать
let underscope.
Помните, нижнее подчеркивание,
то, что игнорирование значения равняется
какое-то выражение с резалтом.
Или, например, просто поработать с резалтом.
Например, сделать sunwrap,
вот.
Я очень советую такую статью,
если вы ее на курсе конкарнации
не читали.
Там как раз примерно половина статьи
подводит к тому, как устроен
собственно резалт в Rust.
И так, как он устроен, по-моему, в одном из фрейнворков
C-sharp. Я могу
соврать, если честно. Я ее давно не читал
и перечитывал.
Но она очень хорошая.
Она прямо хорошо вам объяснит, почему
такая модель обработки ошибок
на хорошее.
Конечно же, резалт можно точно
так же мачить, как и обычный любую янам.
Вот у нас есть matchVersion.
Это ок, какая-то версия.
Вот мы принтим версию.
Или, например, если какая-то ошибка,
то мы принтим ошибку.
Честно скажу, этот код, наверное, не скомпилируется,
потому что у нас не видно, какой у нас
тип error янама.
То есть там нужно явно прописать,
что это std.evr.
А так раз скажет, что
вывел здесь вот в этом янамочке
А, ну у нас просто очень далеко
в начале лекции, вывел янамочки
тип ten и не вывел тип e.
Ну, в целом, наверное, понятно,
как мачить янамы.
Возможно, вы это даже сделали в домашней ком
какой-нибудь, если вы ее
уже делали.
Вот.
Тут тоже есть миллиард всяких функций.
Это, на самом деле,
если возвращаться к функциональным
программированию, то все дело называется
монады.
Вот. Монады.
Ну, это
просто забейте, я не буду рассказать.
Функциональное программирование,
если вы хотите вспомнить,
можете почитать про монады.
Вот.
Потом
есть всякие функции.
Можно точно так же, как и самый знал,
было выяснить ошибку у нас
или окей.
Unwrap сделать или Unwrap ошибки.
То есть на этот раз мы, если мы
ожидаем ошибку, то мы можем сделать Unwrap error
и получить тип ошибки.
То есть то, что у нас
внутри лежит.
То же самое с экспектом.
К тому же у нас тут есть
SRF и SMU точно так же.
То есть он превращает ссылку
на result в result от
ссылки на T и ссылку на E.
То же бывает полезно, но редко
в случае result.
Так.
Ну и есть тоже очень полезная функция
map, которая часто нужна.
И map error. То есть
map изменит тип
сам T, а
map error изменит тип ошибки.
Ну и там так далее
есть всякие функции.
Тоже рекомендую почитать.
Так, ну давайте для начала посмотрим
на такую структуру.
Она очень простая, в ней есть
имя этой строка и edgeState32.
Так.
Давайте мы попробуем записать какую-то
информацию.
Вот. Нам передали инфо.
И сейчас мы
пытаемся сделать на самом деле
не очень дематично. Попробовать
записать что-то в
myBestFranceTxt.
Помните, что это за результат?
Круглоскобочки это
то, что unitType, который просто
пустой, пустотюбный.
Вот.
Ну то есть в случае, если у нас нет ошибки,
то у нас просто возвращается
unit.
Вот.
Ну смотрите, если у нас
есть ошибка при создании файла, то есть
есть такая функция библиотеки
FileCreate. Если
случилась ошибка, то мы возвращаем ошибку.
Иначе мы возвращаем файл.
Дальше. Если
у нас есть ошибка
при
записи файла,
то в таком случае мы вернем ошибку.
Если у нас опять же есть
при записи файла какая-то ошибка,
то мы еще раз и вернем.
Ну как видите, много более плейта.
Главное, что мы здесь увидим на этом слайде.
У нас с самого начала какой-то матч, а дальше
мы и FlatError, то есть проверяем
является ли это ошибкой.
Очень некрасиво.
На самом деле у Rasta есть решение
назвать оператор вопросительный знак.
Это можно переписать вот так.
И это прекрасно.
Вот.
Ну как он работает?
На самом деле он просто делает матч, если
если у вас там ошибка, то он
делает ретурн ошибки
в функции.
А если там окей, то он возвращает
тип T.
И все.
Ну то есть это на самом деле просто такая
синтоксическая вещь, которая как-то обесахаривается
в один матч.
Вот.
Здесь вот я когда готовил лекцию,
я очень хотел вам показать такой пример
того, как на самом деле происходит
рэхендлинг в ГО и в Rasta.
То есть показать вам пример
двух
подходов.
Если вы работали с ГО, то вы наверное помните, что у вас
если функция возвращает
что-то,
допустим вы там пишете
значение error
равняется и там какая-то функция.
И дальше if error
не равняется new return error.
У вас много
такого кода может быть.
Вот у меня был такой, где-то вот я видел
такую прекрасную картиночку, в которой
взяли произвольную функцию на ГО с какого-то
большего проекта.
И взяли произвольную функцию на Rasta с произвольного проекта.
И подчеркнули желтым
все, что касается рэхендлинга.
Но в ГО это было больше половины кода.
Там просто все if и вот эти вот
if error не равняется
new return error.
Это вот бесконечное. А в Rasta весь
рэхендлинг был просто вот в вопросике.
Подчеркивали где-то в конце и все.
Если у нас
возвращается ошибка,
мы же потом не сможем сделать
рэхендлинг.
Вот если у нас
возвращается ошибка из правил
кэйки, то у нас же не сработает
на райдол, на край.
Ну да, у нас же вопрос
вернет ошибку. Он вернет ошибку
из функции. Функция, смотри, видишь,
его result имеет сигнатуру.
Она вернет ошибку, припыхнет выше.
Что еще?
Если видишь, у нас return
так вот возвращает ошибку.
Вот этот match сверху есть,
это то же самое, что делает вопросик
в точности.
А, то есть он сразу возвращает?
А если этими функциями?
В плане функции.
Вот там return третьей строчки
это return из функции?
Да, да.
Это return
всегда работает
в изратость функции.
То есть если у вас там будут циклы,
все равно у вас все из функции возвращаться.
Ну как и в C, в C++, там точно
такая же логика.
А если мы в main
напишем?
О, кстати, если вы в main, такое тоже бывает.
В получении main у вас, конечно, возвращает unit.
Но вы можете в main, я так сделал в Rover,
в нашей тулзе, он возвращает
тоже какой-то result
от unit.
Вот, и вы можете пропихивать
даже в main дальше ошибки.
И куда они пропихиваются?
Они пропихиваются в трамплин, а там все по умолчанию
просто ангрэпами делается.
И он поймет, что вы ему пропихнули ошибку
из main и вывезет ее на экран.
Все.
Правда, там на самом деле
в Rover хитрее, там используется такой крейт
называется Anyhow.
То есть в Rust у нас, как вы могли
заметить,
используется template для ошибок.
То есть там T и E есть,
тип T и тип E.
Но дело в том, что иногда бывает такое,
что у вас в одной функции очень много разных
типов ошибок. У вас может быть там ошибка
IO, еще какая-то ошибка
из библиотеки там своя
и так далее.
Это не очень удобно
бывает, когда вы
пытаетесь привести все к какому-то
одному result. У вас тогда появляются
свои какие-то янамы ошибок, это больно.
Нет, поэтому там просто
динамический result.
То есть там просто динамически приводится
все к типу ошибки.
Там как там называется?
Похоже на T и E.
В общем, виртуально
это все.
Я забыл слова, если честно, как они там
называются точнее.
Похоже на T и E.
Ну, что-то типа того.
Тогда это TypeRanger, мы стираем тип.
Да, но там просто
динамически врантами все происходит.
Так и T и E.
Тоже врантами.
Так.
Давайте пойдем дальше.
У нас есть еще
вот такая вот функция, которую знают
очень мало даже профи Раста.
Звается Transpose.
Вы можете о ней прочитать даже документацию.
Я сама не узнал, на самом деле только тогда,
когда сходил на одну конференцию по Расту.
Там рассказывали про...
Ну, один такой
достаточно розумный парень
рассказывал про то, как можно
делать какое-то на Расте более дематичное и красивое.
Потом он сказал про Transpose.
Transpose — такая штука,
которая между собой представляет
Option и Result.
То есть если вот, например, у вас тип
Option и Result от T и E,
то в таком случае у вас появляется
функция Transpose от Self.
И то, что она делает, она
выпихивает Result вверх,
а Option засовывает внутрь.
И то же самое
в случае ошибки. Если у вас Result
Option от T и E, в таком случае
у вас тоже меняются местами.
Это порой бывает очень удобно.
Так, у меня даже есть пример.
Отлично.
Смотрите, вот, например, мы
читаем что-то вот из CDIn.
Мы взяли строчки из CDIn.
Какая-то output-строчка.
Я просто напомню.
InputNext — это у нас итератор.
Мы с итераторами особенно не работали пока что.
Но он будет возвращать.
Каждая строчка у нас ResultString.
И так как итератор
сам по себе либо нам возвращает,
либо сам значение, тогда это OptionResult от String.
Понимаете, да?
То есть у нас Result от String,
потому что у нас может быть
ошибка при чтении из CDIn.
Ну и Option, потому что у нас строчки
могли закончиться.
Смотрите, вот что мы
делаем здесь.
До тех пор, пока мы какую-то строчку
прочитали, мы Line
зачем-то, если у нас Result
с Error, то в таком случае мы припихнем
дальше с учетом вопросика.
В плане Line
у нас будет сейчас ResultString.
Когда мы сделаем вопросик, то это просто String станет.
Типа Shadowing будет.
Вот.
Если строка пустая, тогда мы
брейкнемся, да, иначе мы в Output
запушим строчку.
В самом деле с помощью Transpose
можно сделать чуть красивее.
— Это наша домашка?
— Нет, не наша домашка.
У нас комму,
там нужно еще хэштаблиться и пользоваться,
чтобы помочь строчке.
— Хэштаблиться.
— Так.
Здесь у нас, смотрите,
используется Next и Transpose,
и вопросик сразу же.
И мы получаем просто Line, это String.
То есть у нас Next — это OptionResult от String,
потом я делаю Result,
ну Transpose, я получаю Result от Option
от String.
Соответственно, я потом
делаю вопросик, получаю просто Option
от String,
матчу с самым Line и получаю просто String.
Какая машинерия хитрая.
Одна вот строчечка —
оп, и у вас так красивее становится.
Сколько я помню, в ровере в одном месте даже используется.
Где-то было полезно.
Давайте, наверное, прежде чем
контейнером перейдем, есть
какие-то вопросы по Option и Result?
— Получается от двух типов всегда.
— Да, там два типа.
— То есть аналог для STD-варианта нет?
— STD-варианта,
напомню, это что, пожалуйста?
— Это вот, по сути, то же самое,
только с несколькими типами.
— По-моему, туда
можно запихнуть какие-то произвольные типы.
— Да.
— Это, по-моему, вообще никак
не сходится с Result
логически.
— А, ну,
я не знаю.
— Не, ну, можно считать Result
какой-то особо интерфейсным вариантом
от результатов и ошибки, собственно.
— Я бы сказал, что это там
скорее Union внутри Unum.
Вот.
— Просто проблема Union в том, что
Union не знает, что в себе хранение.
— Да, поэтому деструктор не вызывается.
— Поэтому есть вариант.
Это Union с паниточками.
— Как
вернуть ошибки?
Меня Синцева за счет писал
не сконструировать ошибки?
— Смотри.
— По-хорошему, без практики.
— Ну, сконструировать ошибку
тебе это нужно только тогда,
когда ты хочешь сконструировать свой тип ошибки.
Ну, если у тебя не свои типы ошибки,
то они просто пропихиваются какие-то чужие
наверх, чаще всего, да?
Если у тебя свой тип ошибки,
тогда у тебя, чаще всего, какой-то свой Unum.
Ведем какие-то свои варианты
ошибок. И чтобы создать,
ты просто пишешь Error
и внутри один из вариантов Unum.
— Просто есть какой-то
стандартный Unum
для ошибок?
— Ну, стандартный Unum,
дело в том, что каждая ошибка
из разного рода,
скажем так. Его ошибка, они
одни. Ошибки
какие-нибудь в библиотеке,
другие, например, там могут быть ошибки,
неправильно распаршен
конфига, там свои Unum добавляются.
То есть, ну, по каждому
случаю добавляются свои Unum,
если нужно.
Вот, я еще, наверное, не
проговорил, option, над option
на самом деле тоже вопросик работает.
То есть, он точно так же
либо пропихивает Unum наверх, либо
возвращает то, что он там
есть. Совершенно точно так же.
— В общем, чтобы свое описание
определить, знаю вопрос.
— Не, это только вещь, которая работает
для optional result.
Ну, там просто custom на обе сахары
у меня, да? Там в одном случае сам она,
а в другом случае OK Error.
— Ну, как-то ведь
создана эта сахарка просто
дебрик-компилятор.
— Что конкретно
дебрик-компилятор?
— Ну, да, это синтоктический сахар
и там
его нельзя перекрутить
на свои Unum какие-нибудь.
— Ну, если ты припишешь компилятор, наверное...
— Ну, на свои Unum
не сказать, что это дебрик-компилятор,
это просто вставляется какой-то
заранее определенный, вполне определенный матч
внутрь. Ну да,
ты не можешь написать для своих типов
вопросик.
— Компилятор...
...
...
...
...
— Так, перейдем к контейнерам.
На самом деле, это будет достаточно прикольно,
на мой взгляд.
Давайте для начала поговорим
об общих свойствах контейнера в Rasty.
Во-первых, мы чаще всего боимся
локации в Rasty.
На самом деле, во многих функциях
пытаемся как-то переиспользовать локации.
Ну, мы это заметим, когда мы посмотрим
на то, как работать с его в Rasty.
В общем,
стараемся по максимуму не вызывать всякие омолоки,
потому что это зачастую
очень сильно понижает производительность программы.
Вот.
Потом, мы не хотим как в плюсах,
если у нас какой-то некорректный импут,
например, на пустом векторе мы попросили
попнуть последний элемент.
Мы хотим вернуть просто наум,
что такого элемента нет.
Поэтому мы активно используем
OptionResult во всех стандартных контейнерах.
Ну, и особенно OptionResult,
я там сходы не вспомню, где есть,
но, по-моему, где-то есть контейнеры.
Потом некоторые
для удобства,
например, вот вектор, если вы будете
написать в квадратной скобочке,
то в таком случае у вас
будет возвращаться сам тип T,
ссылка на тип T.
Для того, чтобы вам было...
Это же удобнее, чем, например,
написать в квадратной скобочке
и возвращался бы в Option,
но все равно нужно было бы писать какие-то андрэпы.
Поэтому раз, делай так. Если у вас
ничего там, например, не было,
например, в случае вектора вы вышли за границу массива,
в таком случае квадратные скобочки
просто паникуют, они не делают никаких проверок.
То есть это
точнее проверки делают,
за счет этого паникуют, просто что
не возвращают Option для вашего удобства.
Это хороший вопрос.
Замедляет ли это код? На самом деле нет
по замерам. Даже в какие-то моменты
выяснялось, что почему-то код с проверками
работает быстрее. Ну там есть
branch prediction, просто зачастую он
работает процессор очень эффективно,
и в итоге эти все бранчи просто даже
никак не замедляют процессор
с проверкой того, входите вы
или нет в границы.
В плюсах у нас есть такие вот произвольные
итераторы. Мы там можем взять 10 итераторов
в разные части вектора.
У нас нет таких произвольных
итераторов, как
C++, потому что у нас есть
ownership. Мы можем, например,
на мапу взять несколько
мутабельных
entries, то есть
ссылочки на хэшмап.
Поэтому у нас
это влияет на то, как у нас будут
устроены контейнеры. Сейчас мы как раз на это
будем смотреть и сравниваться.
И это очень сильно на самом деле влияет
на то, как устроена у нас стандартная библиотека.
И как-то странно, в лучшую сторону.
У нас гораздо более быстрая алгоритма, чем в плюсах
в стандартной библиотеке.
Кстати, вот интересный такой факт.
В расти, например, если вы делаете
push, он внезапно может запаниковать.
Почему может запаниковать push?
Потому что у вас, например, локация не удалась.
Почему еще он может запаниковать?
Или, например, если вы пытаетесь залоцировать
больше, чем усайс элементов.
Даже не усайс, а усайс максимум.
Точно не припомню.
Только, конечно, не залоцируйте
числа там во вселенной.
На самом деле, такие вещи, как
fallible locations, они на самом деле очень мешают
работать
прямо в ядре линукса, например.
Ну и сейчас одна из вещей,
которая преграждает
расту попасть в ядро линукса, это то,
что fallible locations
случаются иногда.
Поэтому добавляют векторы try push.
В боксе есть try new.
То есть они возвращают
option, если удалась локация.
То тогда он возвращает
сам бокс, например, в случае бокса.
Либо наоборот, если она не удалась.
Просто было бы плохо, на самом деле, если вы пишете ядро,
и оно там из-за того, что вы
запустились на каком-то ужасном железе, на котором мало памяти,
у вас запаниковало ядро, да?
Как-то плохо.
Поэтому...
Тут есть как раз
РФС,
РФС 21.16, это как раз про то,
как поддерживать fallible locations,
и есть
письмо Торвальдзу об этом еще.
Можете почитать в свободное время,
если вам будет интересно.
Давайте посмотрим, собственно,
на нашу стандартную структуру.
Вектор, с которым вы уже очень хорошо знакомы.
Он, в принципе, устроен уже так же, как плюсакт,
не учитывая то, что там есть какие-то
разницы, например,
связанные с тем, что
move в плюсах внезапно может провалиться,
поэтому вам приходится это
поддерживать. В Расте у вас такого
не может быть, потому что это просто копирование байтов.
Нет-нет, я хочу сказать про то,
что элементы вектора, если когда-то их
move вышли из одной локации в другую, могут...
Ну, потому что
в плюсах у тебя в move может быть
произвольная логика,
а в Расте у тебя это просто
мем-копия элемента самой структурки.
И все.
Поэтому там не может быть никаких ошибок,
если локация уже случилась,
ты просто приписываешь байтики, никаких ошибок
быть не может.
Ну,
то есть, конечно, мы это все проговорим,
потом на лекции про unsafe
мы прям посмотрим на импрементацию вектора внутри.
Если кому-то тоже интересно,
можете посмотреть наперед, есть такая книжка
Rastamamecon, там
объясняется, как вектор внутри устроен.
Растовский.
Вот. Давайте поговорим...
Ну, конечно, не будем говорить про всякие там
индексации, все такое, это все достаточно скучно.
Давайте посмотрим
на базовые алгоритмы. Очень прикольные.
Во-первых,
есть sort. Ну, sort стабильная, естественно,
сортировка, но от нее это
ожидаем. Там используется какой-то
модифицированный team sort, я сильно не разбираюсь в этом.
Работает за аналогенную
в среднем, в худшем случае.
Про описание этого модифицированного
team sort. Честно говоря, я не знаю
конкретно про team sort. Вот про следующую сортировку
я могу тебе даже накидать.
Нет, там книжка про unsafe,
она не про эти алгоритмы.
Они уже есть. Вы зайдите
в репозиторию, посмотрите на
additional reading.
Там целый список, есть интересных книжечек
и статей надо почитать.
Особенно очень много книжек всяких.
Да, сейчас я расскажу.
Вот есть sort unstable.
Нестабильная сортировка,
напоминаю, стабильная сортировка,
она ни в коем случае не понимает
порядок элементов, которые равны.
Нестабильная сортировка может
поменять, и за счет этого она быстрее
может работать, потому что она дает меньше гарантий.
В Rust используется
PDQ sort, это pattern defeating
quick sort.
Это крайне дикий алгоритм, очень
быстрый.
Я снизу сделал
на Данилу Кутене насылочку.
Это такой очень шаристый чувак
с Google, синьор, и, возможно, вы даже
знаете его.
Когда-нибудь экспериментал.
Он рассказывает про то,
как они
что делают в Google,
и так далее.
У него есть пост про
PDQ sort. Его комментарии
это, похоже, самая лучшая сортировка,
и сейчас его вообще делать лучше не могут.
PDQ sort это просто стандартная
библиотека, используется sort unstable,
и вот там самая быстрая сортировка,
которая только может быть.
В худшем случае она работает
за nlog n, но на практике она работает
так же, потому что она учитывает
всякие паттерны, которые частенько
возникают на практике.
Там всякие уже отсортированные массивы,
куски отсортированных массивов,
и так далее.
Это практически очень-очень быстрый алгоритм.
В плане, что
ее лучший кейс это просто oAten работа.
Еще, кстати, Данилу Кутене
писал в блоге про то, как они
пушили, есть такая еще сортировка bitset sort,
я с разницей
с PDQ sort не разбираюсь,
я не разбирался с этим алгоритмом.
Это тоже какая-то очень быстрая сортировка,
и они хотели ее в lvm
libcxx в гугле
пропушить.
Данилу в своем канале жаловался
про то, как же сложно
что-то пропушить в lvm,
потому что люди очень-очень
настроены консервативно.
То есть они отправляют непонятно куда.
Я очень советую почитать
это интересное такое наблюдение,
что в плюсы очень сложно,
даже с учетом того, что это соответствует стандарту,
запихнуть самый лучший данный алгоритм сортировки.
Дальше есть бинарный поиск,
но с бинарным поиском все понятно,
если массив отсортирован, но ищем за логин.
Потом есть select-enfance-table,
это quick-selector, основанно
PDQ sort, как вы понимаете,
тоже работает очень быстро.
Я, кстати, не уверен,
пытается ли он это понять.
Я могу только сказать...
Возможно,
тоже умеет.
Можно просто почитать документацию,
выясните.
Я могу только сказать,
что будет в кейсе,
если вы дадите некорректные входные данные
к этому алгоритму. Он в таком случае
гарантирует, я не дам никакого undefined behavior,
я вам не дам memory unsafety,
unspecialized результат,
который вы получите.
Вы можете получить аборт программы,
вы можете получить панику,
вы можете получить неправильный ответ
binary-search. То есть у вас будет
корректно продолжать работа программы,
у вас даже не сломаются никакие варианты,
которые вокруг, конечно,
кроме binary-search.
Но при этом
у вас может произойти
произвольная фигня.
То есть лучше так не делать, конечно,
а то
мало что может случиться.
Это выбрать n-перемент
по...
Это я сейчас еще про binary-search был вопрос,
я чуть-чуть рассказал про то,
как он хендлит кейсы, когда
у него ошибки.
Да, я имел в виду фуксы, которые мы и поняли.
Select nfrontstable,
это просто quick-selection
PDQ-сварт, который работает даже в курсе
случаев за OAuthn, очень быстро
такая штука.
Выбирать n,
она сортирует точно так же,
в плюсах частично сортирует массив.
И у тебя
после вызова этой функции
на n-м месте гарантированно будет
n-ный элемент. Все остальные элементы
как-то возможно подвинутся.
Потом еще есть...
Так как все эти алгоритмы основаны на сортировках,
вы хотите, возможно, пользоваться
компаратором, который вы сами сдадите.
Для этого есть buy и buykey варианты,
которые позволяют констамизировать компаратор.
Например, sort-buy
или sort-unstable-buykey
Вот такие вот варианты.
Еще есть легендарное
rotate-left и rotate-right.
Я скинул going-native.
Возможно, вы помните эту пражу
it's-a-rotate.
Не помните?
В общем, там фанат
переиспользовать код.
Говорил про то, как можно
в банальные алгоритмы
в плюсах писать короче.
И там почти все решалось rotate-ом.
На самом деле
прикольный толк. Советую посмотреть.
Так.
Потом есть veg-deck.
Асимптотики... Ну, я не буду
прописывать конкретные асимптотики.
Те, которые вы ожидаете.
Вот единицы на пуши,
мактизированные на попы единицы,
вот единицы
рандомный аксесс.
Но тем не менее
внутри алгоритм не тот же, что в плюсах.
Давайте мы об этом поговорим.
Есть, во-первых, те же самые функции,
что в векторе деке.
Во-вторых, есть те же самые
отличия от unsafe-языков.
То самое, что мы обсудили
в начале главы про коллекции.
То есть, про ссылочки,
про итераторы, все такое.
То, что мы пытаемся меньше локаций делать.
Потом.
Дело в том, что veg-deck
расловски основано
просто в циклическом деке.
То есть, вы, наверное, на первом курсе
заставляли писать какой-нибудь
дек простейший, в котором был
был вектор и просто два указателя,
которые с ширеалистом по кругу ходили.
Вот это вот просто расловский дек.
Он не выпиандривается.
На самом деле, из-за этого мы получаем
очень много хороших пропорций.
Во-первых, есть make-continuous.
Так как мы знаем, что
дек в памяти расположен
так вот хорошо,
беспрерывно,
то мы можем просто его зареаренджить
и сделать одним большим слайсом.
Мы можем, например, использовать всякие
SIMD инструкции.
В плюсах мы сейчас обсудим, почему это невозможно.
Еще есть всякие функции,
вроде as-slices.
Если make-continuous делает один большой слайс,
то as-slices возвращает слайс
до одного конца,
а слайс после другого конца.
То есть, из этих двух слайсов у вас
получится весь дек.
Представляете, да?
В плане,
валидируется или ссылки?
В плане,
валидируется или ссылки?
Ты просто не можешь валидировать ссылки
в Rast, потому что если ты попробуешь мутировать,
когда у тебя есть ссылка, то Rast тебе забанит код.
Это очень-очень хорошее замечание.
Мы сейчас будем про это говорить.
Вот смотрите,
вот буквально следующий слайд.
Тут буквально человек посмотрел будущее
и сказал нам, что у нас интераторы не валидируются
в плюсах. Действительно, это так.
У нас в лицо на стандарте написано,
мы ожидаем на стандарте дека,
что когда мы его модифицируем,
у него не ломается интератор.
И в итоге,
ну как вы понимаете, циклический дек
мы просто не используем,
потому что если вдруг реаллокация,
то в таком случае у вас ломаются все указатели,
ломаются все индексы.
Вы никак не можете просто оставить там
интераторы. Приходится использовать
другую имплементацию.
Вот.
Ну, это вот как раз проблема, о которой мы не воткнулись.
Давайте мы пробуем решить.
Как мы решим?
Ну, какой-нибудь простой вариант.
Не-не.
Это плюсовый дек как раз решает эту проблему.
Ну, кучки это уже следующий шаг.
Давай мы сделаем чуть-чуть попроще.
Мы будем вместо самого элемента
в циклическом деке хранить
указательный этот элемент, да.
И допустим,
в простом варианте будем хранить
из этого,
будем даже хранить не самый элемент,
а указательную структуру,
которая содержит элемент
и указательную его позицию в деке.
Давай, допустим, так сделаем.
Да, у нас все вообще медленнее работает.
Ну, за счет этого у нас получается так,
что если у нас есть итератор,
ну, понятно, как работает
random access, тут итераторы у нас
не инвелидируются, потому что если мы
содернем ссылку на элемент,
то когда мы возвращаемся обратно
в дек,
нам достаточно просто вернуться обратно в дек,
посмотреть следующий элемент
и пойти вниз, да.
Обратно, если можно.
Ну, вот.
Обратно, если мы
ну, когда мы пишем на таком деке
итераторы.
Но есть проблема, что это все работает медленно.
Ну, захотим мы, допустим, проитерировать
по этому деку.
И выясним проблему, что у нас на каждый элемент
получается,
что мы идем по указателю.
Какой-то бред получается.
У нас все работает очень медленно, мы постоянно
ходим по указателю, это ничем не лучше
списка. Ну, давайте мы чуть-чуть
улучшим. Мы скажем,
ну, вот.
Мы не кошлокальны, да.
Забываю слайды листать.
У нас есть еще такая
проблема.
Ну, не такая проблема, я так говорю.
Давайте вместо одного элемента будем
хранить, скажем, тысячу элементов.
Ну, и теперь, когда мы будем
проходить по указателю, мы будем
получать сразу же тысячу элементов.
И, соответственно, там
чуть-чуть изменится механика, например,
Access, потому что нам нужно будет посмотреть
сначала на первый
наш буфер. Возможно,
будет где-то там слева недозаполнен.
Нам нужно будет знать, сколько
элементов. Ну, чуть-чуть изменится, но при этом
от единиц как было так осталось.
Вот.
Ну, и вот, в общем-то,
будем хранить чанки,
и у нас все станет хорошо.
Давайте мы сейчас посмотрим
на картиночку и заодно
выясним, все ли поняли,
как это все устроено в плюсах.
Сейчас это разве уже не STDDEC?
Да, это STDDEC.
Теперь понятно, почему ссылки
не лидируются.
Как итераторы.
Ну, ты понимаешь,
random access на обычном
циклическом деке, да?
Ну, просто самый левый кусочек, да?
Разберемся.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Разберемся.
Вот.
Вот такая вот у нас структура.
Все ли понятны?
Ну, получается, да.
Ну, это все, на самом деле, чисто техническое.
Если ты хочешь на какое-то произвольное,
ты просто, например, вернешься,
в каком-то элемент сейчас находишься,
вернешься в деку, знаешь глобально на каком-то элементе,
добавишь число и попрошу дека
указательного элемента. Ну, допустим.
Это, возможно, самое эффективное,
но зато работает.
Нет, по чанку ты никак не поймешь,
конечно. Тебе нужно будет узнать,
где ты находишься в чанке, а потом вернуться
в деку. Где-то в чанке ты можешь узнать.
У него же указатель глобально на чанк
и номер какой-то, где он там находится
внутри чанка.
Этот номер внутри чанка
не ломается.
Внутри чанка не ломается, только в циклическом деке
самом сверху сломается, но мы же не пользуемся
номерами уже.
В общем,
не будем особенно подробно опускаться.
Примерно поняли структуру, что у нас
на самом деле
таким вот чанком все хранится.
Несмотря на то, что этот дек
достаточно сложный,
если вы посмотрите всякие перформанс-тенсы,
то выяснится, что он на самом деле не так
медленно работает. Возможно, это хорошая
цена для того, чтобы у вас
не было инвалидации итераторов.
Ну, конечно, радость в кидек будет
гораздо быстрее, более того, он будет настолько
быстрый, что вы его сможете использовать вместо вектора.
Ну, если вы при условии,
что вы не делаете поп-фронт,
он вообще будет работать как раз с кидек
1 в 1.
Ну, там с фронтом, только с бэком не становится.
И тем не менее, еще в плюсах
со счет такой обрывистой структуры вы не можете
использовать всякие символи инструкции.
То есть вы не можете работать
с деком как с единой
такой непрерывной
фигней в памяти
локации.
Наверное, если бы мы умели настраивать
длину чанка.
Ну, это бы ничем нам не помогло,
в принципе.
Ну, если, конечно, сделать достаточно
большой чанк,
то, в принципе, внутри симдинструкции
внутри этих чанков и там
между ними, но это в любом случае требует
кастомного дека.
Да, ну, внутри чанков мы можем,
но в рамках всего дека нам придется
прыгать, он же по памяти где-то
хрен знает как прыгнет.
Как будто бы можно
прыгнуть.
Ну, в общем, она, наверное,
не очень удобна,
потому что, типа, у нас
в границе вот этих патчей
патчей для... Ну, все равно хуже, чем просто
иметь на беспрерывной деке все.
Так.
Ну, там максимум два
слайса будет.
А если ты сделаешь Make Continuous, то это
вообще, наверное, с одним слайсом.
А, видимо, будет как-то переписывать.
Переписывать это у ATTEN там
и там будет чисто копирование.
То есть это It's a Rotate.
А? It's a Rotate.
Да.
It's a Rotate.
У ATTEN, ну, там
быстро и достаточно, в принципе.
Ну, всегда можно на двух слайсах просто пуститься,
но два это не миллион слайсов, так что
все хорошо.
А так?
Знаете, у нас с деком еще не было
каких-то особых проблем. В принципе, перетерпеть
можно. Работает плюс-минус быстро
симбод инструкции, но, может, не надо в конце концов
использовать вектор, если он вам...
они вам нужны. Но тут
мы приходим к сету и мэпу.
Раз у нас включается в себя
bitremap и bitreset,
это коллекция сортированная по ключу.
Точно так же, как сет и мэп в плюсах.
Вот.
Во-первых,
как можно назвать это название, там внутри
B-дерево. B-дерево, если вы
знакомы с этой структуры данных, ну,
вы можете даже, наверное, не задумываться о том,
как оно там конкретно работает. Вам важно только то,
что оно кэш-локально. То есть там
кусками элементы хранятся.
Это достаточно быстро.
Modern CPU сработает быстро.
Современные процессоры
за счет этих кусочков
все кладут в кэш и быстренько делают поиски.
Плюс ко всему, там еще
проходов меньше по памяти,
потому что там лог-бэя симптомтика,
а не просто лог под логи.
Вот. Ну и
еще мне нравится
название, но это просто мой
хамбал ампийин. Он написал, что
std-мэп и std-сет как-то не
показывают, какая там структура данных внутри.
То есть сразу не поймешь, что там
красно-черное дерево обычно используется.
Ну и тем более, что
еще std-мэп и std-сет.
Ладно, еще красно-черное дерево.
Непонятно, что там вообще дерево.
Там может быть хэштаблица, а может вообще
и декартач сидеть, и ты не поймешь
вообще по названию что там.
А, да-да, хэштаблица я конечно соврал.
Нужно убрать вообще.
Да.
Так.
Да, и вот очень
важный момент, я говорил
то, что с бинарным поиском.
Если вы любым способом
поменяете внутри мапа
или сета, то почему он сортируется?
На самом деле, такие способы есть даже
в SafeRust, то есть даже не нужно использовать
unsafe, там есть такие читерские способы.
Ну, на самом деле, это
читерские способы, они используют
InterimMetability,
с счетом того, что InterimMetability
это редкая штука, и
в общем, там, где вы ее
используете, она будет явно, и
более того, вы сами себя малейшего
сбратины, если вы так сделаете.
Так что не беспокойтесь, вы просто так эту ошибку
не сделаете, вы не будете модифицировать ключ,
который лежит в мапе.
Но если вы вдруг так сделаете, то
мап вам говорит, что результат
unspecified, это
не будет никого на DefinedBehaviour,
не будет MemoryOnSafety, ну, вы можете
например, Abort, Panic и так далее.
Словите какую-то
произвольную ошибку, которая
программу вам сломает,
но тем не менее, она не
принесет никаких там
MemoryOnSafety, там, произвольным
к CV-шкам
каким-нибудь, то есть ошибкам безопасности
и так далее.
Ну, то есть это хорошая гарантия Rust,
несмотря на то, что вы ломаете структуру, все равно
что-то хорошее гарантирует.
Так,
C++
у нас тоже есть
MAP и SET, они имплементированы обычно как
красно-черное дерево. Если по стандарту
можно еще EVL-дерево использовать,
но красно-черное дерево, конечно, в практике
работает быстрее, поэтому они, наверное,
поэтому и написаны.
Ну, спрашивается, а почему, если B-дерево
такое классное, вы не используете
пресса? Это же, конечно, локальное, быстрое, классное,
однозначно лучшее. Почему не используете?
Нет, нет, там есть явная причина.
На самом деле, мы ответ на этот вопрос уже проговорили
в деке. Там тоже требуется
не инвалидация итератора.
Причина это то, что в стандарте
есть ли мы меняем
с SET и MAP?
Мы не можем больше одного элемента
эффективно хранить в одной музее.
Да, иначе они перестают с местами.
Без плохого.
Так как бы деревья они
как я уже говорил в чанках содержат
элементы, поэтому незаметно быстрее,
чем обычные BST-шки.
Но тем не менее в плюсах мы не можем
использовать эту всю фигню, потому что
в общем-то стандарт нам это запрещает.
И у нас в плюсах нет
быстрого MAP и SET.
Ну, почему это не добавили в стандарт?
Ну, я не знаю. Наверное, никому не надо.
Все написали все, что нужно, и все.
Да.
Да, ты не можешь иметь одновременно ссылочку
на структуру и имитируйте одновременно.
А в плюсах именно это
мы разрешаем и даже поддерживаем.
Причем, если
знаете, в деке мы еще могли
как-то с этим пожить.
В MAP-е еще плюс-минус тоже могли пожить.
Но сейчас
мы дошли до hashMAP и hashSET.
И сейчас мы будем плакать, потому что в плюсах
здесь просто все ужасно.
Так.
Что у нас за язык без хештаблицы?
У нас есть целых две. Это hashMAP и hashSET.
Симпатики, естественно, предсказуемые,
какие мы ожидаем.
Эти хештаблицы достаточно
быстрые, универсальные.
И хештаблица, которая внутри
используется, она
буквально очень быстрая.
Она использует квадратичное прорабирование
и симпт внутри инструкции.
Поэтому она очень быстрая.
А если быть более конкретным, то внутри
там используется растовый порт,
называемый hashBrown,
Google Swiss Table.
Google Swiss Table это такая универсальная хештаблица,
которая на данный момент считается самой быстрой в мире.
Она написана на плюсах.
Вот. Ну, если вам интересно,
вы можете построить конференцию в Cpp.com
и там рассказывать более конкретно, как работает
алгоритм.
Вот.
B3set точно
проходится, но hashMap, hashSet,
ну, хештаблица проходится,
но алгоритм гонотильный.
Не, B дерево проходили.
С ним кроме F2 его прям железно
проходится. Это вопрос на хор вроде.
Так.
Давайте продолжим.
У нас есть
может быть потенциальная та же
самая ошибка, что и в всяких
структурах данных, которые
за счет сортировки работают.
Здесь мы если изменим ключ
так, что из него изменится hash
или изменится равенство,
то в таком случае мы опять же сломаем хештаблицу.
Ну, и все то же самое.
Никакого B, никакой вариант
safety, но результат он спешифает.
Опять же
хорошая гарантия
даже тогда, когда вы все делаете плохо.
Хештаблица.
Итак, вспоминаете ли вы
AnordertMap и AnordertSet?
Они имплементированы
очень страшно.
По крайней мере, когда я открыл лекцию
ли мещерина, то мне стало страшно,
поэтому я решил
про это не рассказывать.
Давайте еще раз. Если у нас Google
Sustain был такой крутой, то почему мы его не
используем в плюсовом стандарте?
А, инвалидация итератора.
Давайте еще раз поддержим то, что никому не надо.
Поддержим это.
Да,
сидим за счет этого
с метом разрешения цепочек.
Цепочками коллизии.
Вот.
Это в итоге приводит к тому,
что мы не можем использовать хештаблицы,
которые с YouTube и production.
В плюсах.
До этого структуру данных
мы реально могли еще потерпеть.
Но хештаблицы это никому не нужно, чтобы
итераторы не инвалидировались.
Поэтому в конечном итоге получается,
что у нас бесполезная хештаблица в плюсах.
Которую используют разве что
тогда, когда лень писать свою.
Когда не лень,
тогда используют какую-то стороннюю,
потому что она горит гораздо быстрее.
Вот.
Кстати говоря, я еще...
Это тема больше для лекции по
оптимизации кода на раз,
когда вы сравните по производительности
unorderedMap
и hashMapRust,
то вы неожиданно выясните, что они с
одинаковой скоростью работают.
Почему так?
Да, вот прям одинаково
с скоростью работают. А как же так?
Вы спрашиваете. Такая быстрая хештаблица
столько всего раз гарантировал.
На самом деле раз просто
использует очень-очень хороший хеш.
Но этот хеш
на самом деле очень хорошо
распределяет элементы.
За счет этого получается так, что
сломать только хештаблицу в плане за счет
хеша практически нереально.
То есть она стабильно очень работает.
А прессовую очень даже легко можно сломать,
потому что там простой хеш.
Если вы хотите, чтобы она работала действительно
как Google SwissTable, то вам нужно будет
поменять хеш на какой-нибудь попроще,
вычислительно простой.
Это мы поговорим, конечно, на лекции
по оптимизации Rust кода.
Тогда у вас получится прям такая
оптимизирована под средний случай для
обычного родового пользователя.
Еще у нас есть binary heap.
Так же, как и в плюсах, у нас это
max heap.
Работает точно так же, как в плюсах,
только используется
и vector тоже используется
в template.
А мой взгляд то же самое.
Название гораздо лучше
у Rust, потому что binary heap
она точно говорит, какой алгоритм
используется внутри. А здесь у нас не понятно,
что. У нас может там binomial куча
или Fibonacci куча в плюсах. Вообще не понятно.
Конечно, priority queue
очень много говорит на такое название.
Но это такое просто.
Я вам решил пожаловаться очередью.
Потом.
Абсолютно то же самое.
Если вы меняете каким-то образом
что-то binary heap,
то у вас не происходит
ничего особенно плохого.
Не буду проговорять.
Это очередной Rust, но это правда и для нее.
За концов у нас есть еще
linked list.
Нужно было наверное тоже сделать, чтобы
он открывался подряд.
Симптотики такие же, как вы от них ожидаете.
Push front, push back,
pop front, pop back.
Rust
Во-первых, на Rust
линкет-лист очень сложно.
Мы увидели какой-то пример,
конечно, но написать
сейф Rust и линкет-лист сложно.
Но на самом деле
правда в том, что он почти никогда не линкет.
Вот так вот сложилось, что пофигу
на линкет-лист.
Но он тем не менее стандартной библиотеки есть
и на самом деле в случае Rust практически
ничего особенного не умеет.
Поэтому я рекомендую его обходить
стороной, если только у вас не
есть специальный алгоритм.
И за счет второго пункта
у нас в плюсах нет итераторов,
поэтому список тем более
становится бесполезным, потому что случайные элементы
вы из него просто так не удалите.
Нужно его прямо искать.
Ну и советую вам прочитать такую-то
тоже книжечку.
Это такая онлайн-книжка,
как же вы говорите, Rust Doc.
Learn Rust, with and without
to many linked lists.
Там человек пишет несколько листов.
Это простеньких стеков,
unsaved,
persistent,
очень на самом деле полезная штука.
Вы очень хорошо подружитесь с Barrow Checker
после этого.
Советую.
Так, есть ли вопрос по контейнеру?
Нет вопроса по контейнеру.
Давайте перейдем к строке
и ее слайсу.
Я думаю, мы как раз, кстати,
на лекцию успели прочитать.
Это такой способ
в Rust
сохранить строку,
но это тотально отличается
от способа сохранить строку в плюсах.
В плюсах у нас есть DString.
Ключевая разница, конечно же,
сразу же.
Потому что ETA 8.
В случае Rust
строк у вас ETA 8.
ETA 8, напоминаю,
это формат,
в котором у вас разная длина
у символов.
То есть таким образом вы не можете, например,
random access на строчке сделать.
Потому что если вы возьмете
random access символ какой-то,
то на самом деле вы можете взять
только byte.
А чтобы найти символ, вам нужно прочитать всю строчку,
распарсить и выяснить,
где же он находится,
потому что у вас символы могут быть
до 4 byte.
На самом деле
так все современные языки делают,
потому что со строчками вы работаете с UTF 8.
В плюсах то, что есть DString,
это фигня,
которая из себя представляет
просто вектор чаров,
без каких-либо инвариантов.
То есть там хранится только
ASCII текст.
В общем,
никакими хорошими
свойствами
плюсовая строка не обладает,
в отличие от растовской.
На самом деле, если вам нужно
работать с ASCII,
то во-первых, у вас есть OString,
мы попозже посмотрим.
Он убирает этот инвариант UTF 8.
Во-вторых,
у вас есть возможность
просто работать с byte.
То есть вы можете написать строки sbytes.
Это вам, кстати,
почти наверно пригодится в домашке,
когда будете писать за дачку префикс.
Эта строчка
растет
как вектор,
и она точно так же, как вектор,
созданная из каких-то bytes, длины и capacity.
Соответственно, у нас
из этого очень много функций,
похожих на вектор.
Так,
но это я уже приговорил,
так получилось.
Вот.
Вот смотрите на эту вот.
Посмотрите на первую строчку.
Это прям пример хорошего
растовского дизайна.
Это буквально скопировано
в стандартной библиотеке.
Я зашел в стандартную библиотеку Rasta
и скопировал определение строки.
Просто вектор U8,
вектор byte.
Как лучше писать
new self
или new style?
Что еще раз?
Вот style.
А, писать лучше
new self, конечно.
Можно было
на слайде и так написать,
но у меня просто уже такой вариант.
То есть, и то, и то валидно,
но если есть возможность, лучше и self использовать.
Он для того и сделан.
Есть такие важные методы.
Можно создать новую строчку.
По умолчанию она не алоцирует.
Кстати говоря, как и вся коллекция Rasta,
как и вектор, век, дек и все что угодно,
они все не алоцируют по умолчанию.
Только тогда, когда вы начинаете добавлять туда элементы.
Потом можно вив capacity.
Ну, когда вы создаете вектор, то
вы же можете...
вы строчки можете capacity вообще задать, да.
При создании вам точно также вернется строчка,
которая уже алоцирована с каким-то
размером байтов.
Вот. Вы можете создать строчку
из UTF-8.
Вот.
Вы принимаете на вход вектор byte.
Заметьте, что вы его кушаете, скажем так.
И вы возвращаете
либо строчку,
либо какую-нибудь from UTF-8 error.
Это как раз то, что вместо
UoError у вас может быть
какой-нибудь UTF-8 error.
Тоже вот, ну, такой.
Дополнительный тип ошибки.
Ну, просто может так получиться, что у вас
вектор byte,
он UTF-8, тогда у вас будет ошибка.
Кто-нибудь знает, почему вектор здесь
именно consume?
То есть мы забираем над ним
обыкновенные ошибки здесь.
Ну, давай конкретнее.
Замугал вот туда.
Да, ну, чтобы замугал вот туда,
ты скажи так чуть более конкретно.
Да, буферу вектора забрать
мы не хотим алоцировать.
Мы не хотим аллокацию.
Поэтому мы говорим, отдайте нам вектор
уже готовый, пожалуйста.
Тогда будет работать быстрее.
Потом есть UTF-16
скодировка. UTF-16 скодировка
это не variable length,
она состоит из 2 byte.
Ну, и создает на ее основе UTF-8.
Здесь мы, к сожалению,
так как она не variable length,
она там по-другому устроена,
то, к сожалению, мы можем только слать принять.
Мы не можем принять на вход
веку U16 или U8, потому что нам
придется перестраивать.
В любом случае алоцировать что-то.
Потом мы можем
into byte сделать.
То есть мы consume self,
съедаем свою строчку
и возвращаем вектор byte,
который внутри находится.
It's byte это то же самое, только возвращает
ссылку на slice внутри byte.
Потому что мы не хотим алоцировать.
Ты как раз на этот вопрос пытался ответить.
Вот, как вы думаете, что этот код запринтит?
Так, варианты есть 6 и есть 12.
Давайте, кто за 6?
Поднимите руку, кто за 6?
Так, а кто за 12?
Так, за 12 чуть больше людей
и 12 это правильный вариант ответа.
Потому что length возвращает число bytes
в строке, а не число символов.
Чтобы узнать число символов, то нужно
за o от n они проинтеррироваться.
Не, на самом деле это более правильно
так делать.
Если ты хочешь узнать число в чарах,
тогда тебе нужно вызвать chars, это
итератор, и сделать count.
Тогда это o от n будет.
Да, это будет o от n.
Тогда ты будешь явно понимать, у меня
итератор по chars, у меня variable length строка,
я должен проинтеррироваться.
А здесь length непонятно, что оно будет,
o от n, не o от n, но в Rust всегда
отвечайте на вопрос так.
Мы не хотим алоцировать, мы не хотим делать
лишнюю работу, мы хотим, чтобы все было
быстро.
Почему они не могли поддерживать щутчатку?
Есть подозревающий щутчик, нигде
кроме ввода вывода особо не пригодится,
а там тому можно, нам привезут и кратя
все равно идти.
Потом есть еще, про chars я
как раз сказал.
Мы можем взять строчку
привет, проинтеррироваться по символам
и вывести наш вектор.
Это такая функция,
которая возвращает итератор по chars.
А что такое char?
Ты его вообще понимает?
О, точный ответ.
Это UTF-8
CodePoint.
Хотя стой.
Это не то же самое.
Я попытал, там раз в следующий слайд
CodePoint был.
CodePoint другой.
CodePoint это что-то типа символа,
но я сейчас покажу пример.
Читали ли вы задачу Prefix?
Там как раз был пример такой,
про кэфе, кофеина.
Да, вот.
Ну там задача как раз была
объяснение, что довольно
сложно сравнивать UTF-8
строчки, и там даже одна и та же
строка может за двумя разными способами
написана.
Вот как раз у нас есть такой примерчик.
Давайте посмотрим.
С виду два одинаковых символа.
E с ударением, E до ударением.
В одном случае это,
как вы видите,
какая-то UTF-8 строчка,
chars next, она работает.
А в втором случае
это будет наум.
То есть мы притеремся по char, мы получим один char.
Логично, да?
Заметьте, что просто E это строчка,
я итерируюсь по ее символу.
Это просто получаю наум
во второй раз. То есть тут один символ.
А когда я буду итерироваться
по второй строчке,
то в таком случае
я выясню, что символов уже два.
То есть потому что один символ
в первом случае у нас был просто
E with acute,
то есть, короче, E с ударением.
Это был один символ. В втором случае у нас это
суррогатные символы. Это у нас там E
и есть ударение.
И UTF-8 это все приплесовывает в
E с ударением.
Вот так.
Я не эксперт, у тебя 8 на самом деле.
Вроде бы тут два кодпоинта как раз.
Это один кодпоинт, но два
в первом случае.
Вроде бы так.
Я честно скажу, я такой не эксперт,
у тебя 8.
Еще чар размера 4
байта всегда.
Но если бы он был 1 байта,
то в лучшем случае он бы, конечно,
был 1 байта.
А так он может хранить какой-то
UTF-8.
В том стримке есть.
Он очень похож на стримвью.
Я бы даже сказал, что очень
похож на. Практически одинаково.
Просто что одно плюсовое, другое
растовское, соответствующими различиями.
Смотрите, до этого у нас был вот вектор
и есть слайс вектора.
Потом мы делаем какую-то строчку
hello и у нее
берем
с первого по третьего символа и получаем
L.
Я вам сказал, с первого по третьего
символа.
Сейчас мы посмотрим. На самом деле
это слайс байта.
Я специально это сказал, потому что в данном случае
это выглядит как слайс символа.
Тут есть хитрость.
Давайте возьмем UTF-8 слайс.
Привет и мы берем
1.3.
Что вы думаете
будет?
Раз не может
просто такое сделать.
Говорит, трейдмейн паникт.
Границу не входит, извини.
Он в рентамент проверяет.
Он просто смотрит на начало
и проверяет, что вы действительно дали байтик, который
соответствует началу символа.
На самом деле это дает гарантию вам,
что ваш слайс это тоже
UTF-8.
Это удобно, это хорошо.
Если вы захотите взять по символам,
в таком случае вам придется
проэтерироваться честно
и сделать слайс. Вам хочется
за 1. Поэтому раздает вам возможность
с байтов сделать.
Если вы уже вычислили,
то вы просто оставляете байты.
Номера байтов. И все очень быстро
за 1. А так нужно
этерироваться, и это очень плохо.
Я не представляю.
Он это в рентамент проверяет?
Да, но это 1. Он же смотрит
за соседей байтов.
Он не хранит, но он имеет такой вью.
Он имеет ссылку на нашу текущую
строку, два указателя.
И мы дали по сути байтовых.
И он рядышком проверяет,
все ли хорошо во время своего создания.
Он просто дает нам гарантию,
что если строка UTF-8,
то слайс тоже UTF-8.
Соответственно, вот так это работает.
Где-то я помню,
в Fifth Community недавно был
там был просто пост
про то,
что не все знают,
мол, что в ГО, если вы проэтерируетесь
по строчке, то будете этерироваться по байтам
на самом деле. И там был комментарий
от кого-то, мол, чего вы ожидали?
Это же UTF-8-строчка.
Здесь, кстати,
если вы попробуете проэтерироваться по строчке,
расскажете, что этерироваться по строчке нельзя.
Вы напишите либо чарс уже,
чтобы по символу этерироваться, либо байт,
чтобы по байтам. Укажите явно,
пожалуйста, что вы хотите.
Так.
У нас у стринга есть
некоторые функции,
которые есть и в строчке тоже.
Например, sbyte,
chars или trim.
Например, с sbyte понятно,
и с chars, в принципе.
Stream — это функция, которая убирает
пробелечки в начале и в конце просто.
Наверное, пользуются.
В питоне мне особенно часто пригождается,
когда я что-то пишу.
А может быть и даже trim.
Помню, что там что-то депрекирует, а что-то работает.
Я могу и соврать.
Есть split.
Кстати, вот здесь уже
появляются какие-то страшные
закорючки в виде кавычки a.
Это называется lifetime.
Вы его именем прям прописываете.
Конкретно тут написано что?
Здесь вы просто его в дженерике объявили,
а дальше говорите,
что вы берете ссылку с lifetime a на self,
то есть вы берете строчку, которая есть
какой-то lifetime a.
И вы говорите, что split живет столько же,
не больше, чем столько.
Мы конкретно
поговорим об этом, когда будем говорить
о именованных lifetime, их чуть попозже.
И в сплите просто там внутри
в объявлении структуры ссылочка должна быть
на строчку, естественно.
Да, мы lifetime посмотрим.
У нас вообще будет лекция
целая по memory safety, даже будем одну статью разбирать.
Ну и с replace тоже самое,
в принципе.
Берем какую-то строчку,
здесь это replace, как вы понимаете,
а да, replace и split.
Здесь, видите, pattern есть какой-то
и в том и в том случае.
Здесь проблема как курица и яйца.
Что вы ожидаете? То, что строка ищет
себе pattern или то, что
pattern себя ищет в строке.
Или кто-то третий вообще ищет
pattern в строке.
Раз решает проблему так, что вы делаете
pattern, внутри него есть search.
Мы чуть попозже обсудим,
как оно устроено.
В общем-то, здесь pattern
ищет себе строчки.
В принципе, это так работает.
Тут можно в качестве pattern просто указать
строчку, потому что они имплементируют нужный
trait pattern и оно там
превратится в pattern.
Да, можно написать что-то произвольное.
Там просто что-то, что имплементирует
pattern trait. Мы попозже поговорим.
Везде, где можно искать pattern.
Я думаю, что
можно даже векторами написать.
В общем, я и сам сейчас
еще посмотрю, как это конкретно устроено.
To,
replace, куда?
То есть это как бы буфер.
Сейчас, подожди, replace.
Я могу тебя собрать сейчас.
Конечно, буфер.
Ты ищешь
pattern что-то заменяешь,
а потом to на что-то заменяешь.
А string — это, ну, потому что тебе
возвращается именно string, потому что
тебе потенциально нужна будет локация.
Ты же можешь менять длина
произвольного что-то.
Это важный еще момент.
Все строковые константы — это
ссылочки на string.
Если вы пишете hello world, то на самом деле
он имеет тип ссылочки на string.
И поэтому не очевидно, когда
вы пишете hello world.to string.
В смысле, строков к строке
провести. Вообще непонятно, что происходит
в начале.
На самом деле, вы привозите
к строке, то есть к владеющему
типу
в данном случае.
То есть to string и to own it делают, по сути,
одно и то же.
Человеки разные?
Когда они разные?
В смысле, когда?
В случае строчки — никогда.
To own it — оно просто
к какому-то владеющему типу
привозит.
Это не странно, то что to string приводит
к string.
В смысле, to string приводит не к str,
а к string. То есть он берет
ссылочку на str и привозит
в стринг владеющий тип, то есть
в локацию.
Str — это просто что-то не у владеющего
локации, просто ссылочка.
Вот, наверное,
осталось только 9 слайдов. Давайте мы их добьем.
Тут box и rc.
Это достаточно быстро.
С box мы уже хорошо знакомы.
Давайте мы проверим
одну такую...
Посмотрим на
advanced функции. Во-первых, есть такая функция
leak.
Как вы думаете, что она делает?
Течку памяти. Yes.
Она просто
берет и делает течку памяти.
Такая наглая функция.
Ну, еще есть inturall,
который вообще берет
в box и превращает его в указатель.
То есть leak она превращает хотя бы
в какую-то строчку,
ссылочку на t.
А inturall вообще
меняет на указатель.
Вы думаете, что leak может быть в
advanced моде?
Нет, это save функция.
Вот смотри.
Вот смотри, вот твой вопрос
на слайде. Как же так?
Раз безопасно. У нас тут memory leak и просто
в save берем leak.
Так.
Зачем там?
Стрих что?
Смотри, ты просто
должен явно указать, какой ты lifetime
хочешь. Сколько должна
жить эта ссылка?
В любом случае, можешь не заняться, пока что мы
ставим статик. Это означает, что он живет всю программу.
Сколько хочешь.
Все вообще.
Вот.
Подождите, у нас раз такое безопасное,
мы взяли и memory leak сделали.
В save раз.
На самом деле,
когда вы пишете на системе
в языке программирования,
то вы ожидаете того, что вы должны
делать leak. Потому что, например, если
вы взаимодействуете с другим языком
программирования, то вы хотите
салоцировать какую-то вещь.
А потом, да, и отдать другой язык,
чтобы он менеджил эту память, не вы.
Вот.
Поэтому, на самом деле, вы должны
делать leak и должны уметь их делать в
save языке. Более того, почему
это Rast вообще разрешает? Потому что это считается
безопасным в Rast.
То есть memory leak, почему он безопасен?
Потому что
он не дает memory on save, он не дает
уб, он просто плохой, согласен.
Если у нас leak, то мы негодяи.
Но при этом он
безопасен, он не ломает нам программу,
он не ломает никаких гарантий. Все хорошо.
Вот.
А мы изучим,
как передавать память с другой программой?
Да, у нас будет FFI
в конце.
Будем с плюсами и си работать.
Ну, даже, наверное, си просто.
С плюсами числа.
Ну, да.
Так.
Потом у нас есть RC.
До этого мы работали с боксом.
Бокс просто был каким-то указателем.
RC это тоже не нул указатель, но это
reference counting указатель.
Он однопоточенный.
То есть у нас есть
какой-то указатель,
который, в общем-то, менеджит,
сколько локаций было сделано.
Ну, да,
shared pointer, только shared pointer
шарить может тогда не можно, да, Андрей?
Нет.
А?
Шарить pointer там, ну, с трудами сложно,
потому что там только атомарная операция
на этом счетчике всего.
Я там просто помню atomic shared pointer.
Shared pointer, честно говоря, уже чуть попутано.
Ну, с 20-х плюсов, да, для атомика появилась
специализация по shared pointer,
которая, чему более нормальная,
чем была раньше.
Вы можете брать RC.
Когда вы создаете новый RC,
то вы его можете склонировать.
Если вы пишете RC clone,
то вы копируете сам reference counting pointer.
То есть у вас становится два указателя на память.
Внутри это выглядит так.
Когда вы создаете новую RC,
то у вас алоцируется память
под тип T, который вы алоцируете.
И внутри там есть
два счетчика.
Один strong pointers, другой weak pointers.
Что такое weak pointers, мы сейчас поговорим.
Ну, про strong pointers, в принципе, понятно.
Просто число RC, чтобы мы знали,
в какой момент мы алоцируемся.
Ну и дальше RC
дропается, когда
все инстанции RC дропнут.
Ну, это при условии, что у вас нет weak pointers.
Есть такие вот самые ключевые функции.
Во-первых, getMute, она
возвращает мутабельную ссылку
опционально на T. Если мы узнаем
то, что мы сейчас единственные, у кого есть
ссылочка на тип T,
то в таком случае мы можем
взять не мутабельную ссылку.
Логично, никакие гарантии не ломаем,
раз это проверяет в runtime
сколько у нас там ссылочек.
Есть downgrade, который превращает нас в weak.
Weak я сейчас покажу прямо
хороший слайд.
То у нас есть weak count
и strong count. Это, собственно, то, что у нас
внутри есть.
Ну, наш count.
Давайте посмотрим еще
то, как пользуется RC.
Вот, допустим, мы создали RC,
выводим его на экран.
Ну, и потом
так как у нас RC 1, мы можем
вызвать getMute.
Соответственно, у нас он вернет сам,
так как мы одни, и мы сможем
модифицировать. Я отнял 41, например,
и получил, соответственно, единичку.
Первый раз я выведу до 42, второй раз я выведу
единичку.
Потом я сделаю RC clone.
И еще раз выведу.
Оно все еще будет работать.
То есть у меня хоть и несколько
ссылок, но я беру
какую-то не мутабельную ссылку в очередной раз
и что-то увожу.
Но если я пробую взять еще
одну мутабельную ссылку, то на этот раз
он скажет, что
он опционен в драг.
Потому что у нас
2 RC теперь.
RC и RC 1.
Соответственно, мы не можем иметь мутабельное владение,
потому что иначе мы бы могли иметь две мутабельные ссылки
и нарушили бы гарантии раз.
То есть она же уже
две мутабельные?
Нет.
GetMute дает мутабельную
ссылку, он дает ее только тогда, когда RC
только один.
А вот то, что мы
делали в GetMute?
Ну, смотри, дело в том, что
когда мы сделали GetMute, то у нас
эта мутабельная ссылочка, она стерлась.
У нас мутабельный flow, как мы говорили,
пропал. Теперь мы можем снова
сделать клаун.
Мы делаем клаун, и дальше
делаем изменения.
Мы пытаемся еще раз вывести
и на этот раз сломаемся, потому что
у нас уже две RC, и мы не можем мутировать
элемент внутри RC, когда мы
имеем несколько ссылок на элементы.
Я думаю, осталось
пять действий.
RC – это сильный
указатель.
В то время как WIC – это слабый указатель.
Они оба имеют
властвование,
владение над локацией.
Но только RC имеет
право на значение внутри.
Ну, как сказать, если
у вас есть 10 RC
и 10 WIC pointers,
то в таком случае у вас
аллокация будет продолжать
жить. Если у вас
умрут все 10 RC, останутся только
10 WIC, то у вас
диалоцируется значение
внутри T, она дропнется,
прям дроп вызовется.
Но при этом аллокация будет жить
сама. То есть, ну, я имею в виду аллокация,
что на T и вот эти вот две ссылочки.
А если вы уже диалоцируете и все WIC,
тогда у вас диалоцируется вообще
все. То есть, идеалокация
произойдет самого этого
на хипе двух кантров и
вместо под тип T.
Вик, тебе иногда хочется, чтобы у тебя продолжала
жить аллокация, да, и проверить то, что
у тебя там ничего нет.
Потому что если у тебя RC
все умрут и диалокация тоже произойдет,
тогда попытка использовать WIC приведет
к аллокации.
Но WIC просто так значение
не дает доступа.
Вот. Есть еще upgrade
функция. Она WIC превращает в RC.
Ну, при условии, если у вас все
RC умерли, то в таком случае
у вас вернется NAO. Ну, потому что уже значение
диалоцировано, извините. Вы не можете
получить RC обратно.
А если RC хотя бы одна живая,
тогда у вас вернется
самый RC какой-то.
Вот.
Ну, вот и здесь вот прекрасный такой слайд,
в котором объясняется, как
происходит это все дело.
Ну, смотрите, я создаю какую-то RC,
в которой хранится строка.
Я клонирую
эту RC.
Потом я делаю WIC.
Два WIC указателя.
Я делаю downgrade RC1, еще раз downgrade RC1.
Сам RC1, если что,
это не модифицирует.
То есть это просто создает новый WIC pointer.
Ну, то есть вы можете там и RC1, RC1,
и RC2, RC2 написать,
и RC1, RC2, вообще неважно, что.
Так.
Потом мы дропаем RC1.
Ну, строка не
диалоцируется, потому что у нас все еще есть
еще один RC.
Вот мы можем даже попробовать WIC1 апгрейднуть
и получим даже какое-то значение в том, что у нас
живая локация.
Что такое downgrade и downgrade?
Downgrade
возвращает из RC
WIC, а
Upgrade из WIC возвращает option RC.
Ну, это то, что
проверяет, если у нас
локация.
Вот.
Дропаем WIC1, у нас ничего не происходит, естественно.
Совсем. А вот если мы
дропим RC2, то тогда уже диалоцируется
строка в этот момент. То есть вместе
с дропом RC2 происходит локация строки.
Так.
Ну и вот дальше
давайте мы посчитаем число
7 указателей, выясним, что оно 0.
Логично. А дальше вот эта вот строчка,
если мы посчитаем WIC count,
вы, конечно, ожидаете значения 1.
Я тоже ожидал, Тимур, значения 1.
Так скажу.
Я получил 0 и в самом начале не понял,
почему. Решил обратиться к документации
и вижу, что если никаких сильных
указателей не осталось, то это вернет 0.
Поэтому
несмотря на то, что WIC count остался
1, WIC count вернет 0.
Потому что RC
закончились. Извините.
В чем смысл функции WIC count
когда я исполняю?
WIC count, ну, просто
посчитать число слабых ссылок.
Но оно работает,
возвращает какое-то не нулевое значение
в том случае, если у тебя есть WIC count
и если у тебя RC живое есть.
А иначе возвращает 0.
Вы прям очень хорошо это, кстати, проработаете.
Когда будет такая сдача,
как ГЦ называется.
Хорошая сдача.
Да, ГЦ. Ну, там типа
garbage collection такой.
Ну, на самом деле не garbage collection,
там просто забавная такая
штука получается.
Ну, дальше давайте
пытаемся прообновить
WIC2,
получаем наун, потому что все RC
умерли и дропаем WIC2.
Еще я сделаю
замечание, есть еще такой
среди всех показателей, box,
RC, есть еще ARC.
ARC – это Atomic Recurrence
Counting. Его можно
шарить между тридами.
Мы в этом подробно поговорим попозже.
Просто упоминание для вас, чтобы
вы знали, что это
все одна вещь.
Еще
один момент, последний.
Из RC-шек,
если вы захотите, ну, можете сделать
RC-option внутри
и внутри какой-нибудь,
не знаю, в общем, RC-option
сделать и
можете сделать цикл на локациях.
То есть сделать так, чтобы
один RC владел другим RC,
тот другим, и этот владел
первым.
Так можно сделать.
И дело в том, что в таком случае
диалокации никогда не произойдет, они же друг другом
владеют, верно?
Поэтому, будьте осторожны,
на RC-шках можно тоже получить
memory WIC.
Потому что, ну,
можно просто...
Нет, WIC не нужно использовать
для этого вообще.
Просто на RC-шках можно сделать цикл.
Ну, то есть сделать так, чтобы оно никогда
не делал отсылывалось, потому что там всегда
не нулевые RC.
Имеет в виду, чтобы
решить проблему можно использовать WIC.
Да, вот как раз
у ГЦА вы увидите, что решить, чтобы
решить проблему нужно использовать WIC, там как раз
будут циклы на RC-шках всякие.
Посмотрите.
Но это будет тогда, когда мы хотя бы
разберемся с макросом, потому что там задача еще есть
макрос.
Вот.
Ну, получается, это все,
что мы хотели сегодня изучить.
Мы изучили Option и Result.
Мы изучили всякие
дефолтные коллекции Rasta
и изучили Smart Pointer.
Какие-нибудь вопросы есть?
