Значит, ну во-первых, давайте быстренько закончим разговор про вариант и про лондон,
потому что в прошлый раз я в конце пары понял, что я сам не умею решать проблемы,
о которой начал говорить, а именно у нас была проблема, я напомню, что,
значит CP-2021, вариант, ну вот здесь мы писали, у нас была следующая проблема, вот здесь,
когда мы делали пут, мы поняли, что вообще-то, если мы по тому же самому адресу кладем объект
другого типа, нежели лежал там изначально, компилятор имеет право это соптимизировать,
формально для него это УБ, вот я на самом деле нашел, значит, я нашел место в стандарте,
в котором описывается формально, значит, это база, значит, это глава Basic Concepts, значит,
пункт 66 Memory and Objects, и вот параграф Object Lifetime, тут есть следующий пункт 66384,
значит 6638, тут это параграф, в котором рассказывается, что такое время жизни объекта,
тут сказано, если после того как время жизни объекта закончилось и прежде чем сторож под него,
который он занимал, переиспользовано или освобождено, новый объект создается на том же
месте, на котором старый объект лежал, это описано выше, ну короче, если вкратце,
то мы вызвали деструктор старого и на том же адресе построили Placement View нового, причем,
если мы есть там объект с тривиальным деструктом, то деструктор даже не обязательно вызывать,
просто как только мы сделали Placement View нового на том же адресе, а объект другого типа так вот,
указатель, который указывал на старый объект, ссылка, которая указывала на старый объект или
просто имя старого объекта, будет автоматически ссылаться на новый объект, и как только время
жизни нового объекта начнется, он может быть использован, чтобы манипулировать новым объектом,
если выполнены следующие четыре условия одновременно, ну то есть, у нас был указатель
на старую штуку, мы решили его переиспользовать под новый объект, и объект оказался,
ну мы уничтожили старый объект, новый объект положили в тому же указатель, вот если одновременно
четыре условия выполнены, то это не УВ, что storage нового объекта в точности overlays,
storage location значит в точности overlays, я кстати даже не знаю, что означает, видимо,
оно не в точности, оно не превосходит, наверное, его по размеру, новый объект такого же типа,
как и старый, игнорируя сивиблей и квалифаеры, тип оригинального объекта не const.qualify,
и если это класс, не содержит никаких нестатических членов, которые const или reference,
а также оригинальный объект был most derived объект типа T, и новый объект тоже most derived объект
типа T, то есть они никакие не объекты базовых классов, ну вот тут пример, собственно, что вот я взял
C1, C2, присвоил C1, C2, а оператор присваивания работает так. Каждый раз серебрыд описывается. Вот.
То есть, допустим, у нас оператор присваивания так устроен, что он уничтожает старый объект по
этому адресу и кладет новый. Вот. И еще и вызывает F зачем-то, не знаю зачем, но видимо для примера.
Вот, после этого я у C1 вызываю F. Корректно ли это? Да, это корректно, ввиду вышесказанного,
что мы уничтожили объект по старому адресу, положили плейсментом new, на него новый, но поскольку
тип тот же самый, const qualifiers не было, ничего там на следовании не было, все нормально, это не
УБ так делать. То есть, по факту, тут написано условие, при котором компилятор не может ничего закрешировать? Да, да, да, да,
именно, смысл этого же в чем эти условия? В том, что компилятор, вот в чем смысл вот этого ограничения,
что там не было констант, что не было const и не содержалось никакой non-static data member,
который const или ссылка. Да, потому что, если бы у него был non-static data member, который const или ссылка,
компилятор мог бы решить, например, что, а, ну, так это же const, значит, она точно не поменяется,
значит, зачем мне второй раз ходить по указателю, там то же самое число и та же сама ссылка. А вот этот
пункт еще более интересный. Зачем здесь нужен пункт про то, что они оба most derived объекты типа T,
то есть, не было никаких у них наследников, которые навследовались бы от T, то есть, если у нас был
B и D, то они оба должны быть derived, если они в иерархии наследования лежат, то оба должны быть...
Ну, может derived, то есть, если они оба в какой-то иерархии наследования объекты, например...
Они же одинакового типа, в смысле? Да, но при этом они не могут быть базами, они должны быть derived.
В смысле, здесь у меня лежит аргент на BASE и еще один объект BASE, в смысле, я не могу подменить BASE на BASE?
Да, получается так. Они оба должны быть most derived объектами. А, у них не должно быть ни одного derived?
Да. Зачем это условие нужно? Что компилятор мог бы соптимизировать, зная, что они...
Они... Ого-бейтс.
Тут же написано, they are not BASE class sub-objects. То есть, он мог бы empty-based это не точно делать?
Нет, он мог бы...
Тут же написано нет, BASE class sub-objects, такое ощущение, что вот на derived лежат мать, отец и так далее.
Вы имеете в виду, что мы вывожу отца на другого отца за минуту, внутри сына.
Я вот так это понимаю. Разве нет? А, хотя нет, правда.
Original object plus most derived object, но я не хочу лезть в детали, тут можно прочитать формально, что называется most derived object, там, скорее всего, будет объяснение с каким-нибудь...
В общем, даже не хочу нажимать. А, ну это не так далеко отсюда, 662 всего лишь.
Ну, в общем...
А, ну вот написано, если это complete object, блаб-блаб-блаб. Короче, вот определение, что там most derived object.
В общем, компилятор может делать дивиртуализацию.
Вот есть такая легендарная статья на хабре, которую вы, возможно, даже видели. Кто-то из вас не видели вы?
Никто. Не открывал.
Вот ты, наверное, открывал, да, раз ты ко мне подходил с этим вопросом, вероятно, ты статью начитался.
В общем, здесь Чел в прошлом году, это статья даже получила премию хабра, текст на тексте из 2021, Чел запарился и рассказал, что такое CD-LONDER на самом деле.
Вот. И что оно делает именно с точки зрения... Вот здесь в конце объясняется, как именно CLN реализовывает LONDER.
Вот. Вот здесь написано, значит, код во внутреннем представлении компилятора, что происходит, и как LONDER меняет то, что делает компилятор.
Идея в том, что компилятор мог бы дивиртуализировать вызовы F.
Если у вас F — это виртуальный метод, давайте вот посмотрим на какой-нибудь пример отсюда.
Вот, скажем, здесь. Вот. Смотрите. Вот здесь у нас есть виртуальная функция F и виртуальная функция G.
И компилятор принимает, значит, функция указатель на A, указатель на B. B — это наследник A.
Мы вызываем F, вызываем G, вызываем еще раз G. Вот. А что это превращается в Assembler?
Первый вызов F оказывается прямым, то есть без прохода по Vpointer'у.
Знаете почему? Потому что FILE позволяет компилятору соптимизировать виртуальные вызовы и не ходить по Vpointer'у.
Ну, как-то под O, как-то, как-то он должен компилировать, как читается, а он же сразу.
Ну, под O0 из-за слова FILE он все равно. Ну, вот слово FILE на самом деле, вот вы когда-нибудь думали,
я там в конце первого семестра говорил, что слово FILE есть еще один смысл, кроме просто допсу чтения.
В самом деле FILE — это подсказка компилятору. Вот зачем нужно FILE?
FILE — это подсказка компилятору, что вызовы соптимизировать можно в некоторых ситуациях.
Вот, например, в такой ситуации. Если у вас на каком-то уровне написано, что виртуальная функция FILE,
то значит, даже при O0, как видите, он это превратит не в хождение по Vpointer'у, а в просто прямой вызов.
ВАЙ.
Потому что он знает, что в классе A никто не может приопределить F.
Значит, зачем Vpointer?
Даже O0 же за этим нужно. Там нет O-1?
Нет, в смысле FILE? Ну, блин, это то, что ты заведомо... Ну как, ну...
Это как-то тривиально достаточно.
Что я правильно понимаю, что если, допустим, у нас A, B, C, у A есть F виртуальное, у B есть FILE, у B есть C,
то тогда он, если ему дать на C, то он автоматически понимает, что указатель на C есть и дать, а здесь еще D, допустим.
Если ему как D подсунуть в C...
Нет, просто если ему подсунуть...
Если глубже, чем FILE, то он автоматически разберется до уровня FILE.
Ну да, скорее всего, да.
Ну, скорее всего, потому что это уже вопросы к разработчикам Капилятора, смогут они их оптимизировать в всех случаях или нет.
Ну, короче, вызов G в A они не могут оптимизировать, вызов G требует вот таких вот маникуляций.
Тут видите, какие происходят действия.
A в вызов G от B он снова прямой.
Вот, ну тут в этой статье еще перечислены ситуации, когда Капилятор может оптимизировать вызовы.
Короче, смысл в чем? В том, что когда вы переиспользуете объект под другой тип, ну, даже под тот же самый тип,
но у этого типа были какие-то наследники, Капилятор мог бы раньше думать, что вы...
Ну, в общем, это попортило Капилятору возможность дивиртуализации.
Вот это условие, насколько я понимаю, нужно для того, чтобы Капилятор мог делать дивиртуализации, чтобы у Капилятора не ломалась оптимизация дивиртуализации.
Потому что если вы подменили бейс на бейс, а то...
Ну, если у вас был указатель на бейс, а под ним лежал дирайвт,
а то... Не знаю. Вот утверждается, что почему-то этот пункт нужен, чтобы Капилятор мог дивиртуализацию делать.
Ну, я так это понимаю. Я до конца не понимаю, работает Лондор, как вы, наверное, догадались.
Ну, мы можем только предполагать, что в C++20 они все еще раз поменяли, это, я считаю, C++17 стандарт.
Но в C++20 там эти условия ослабили, и вроде как убрали вот это условие, 8.3, про константность.
Вот, но... Вроде, видимо, они Капилятору запретили что-то, какие-то оптимизации делать. Не знаю, ну, в общем...
Если кто-то... Конкурс, ну, бонусные баллы, если кто-то мне объяснит...
Нет, на самом деле интересно, потому что мы с вами видели пример... В прошлом году я не знал еще... Где он вообще?
В прошлом году мы не видели примера, когда Лондор реально что-то делает.
Вот этот вот пример с вариантом, который я вам показал в прошлый раз, это вот...
Известный мне пример, когда Лондор реально влияет на поведение Капилятора.
Ну, то есть, если вы просто возьмете пример из вот этой вот, из статьи про Лондор,
то тут от того, что убрать Лондор или добавить Лондор, оптимизация включить-выключить, ничего не меняется.
Ну, может, сейчас что-то меняется, но в прошлом году я тестил от того, что Лондор убираешь, ничего не меняется.
Поведение, наблюдаемо. Вот. Этот пример, который я вам показывал в прошлый раз, он был известным, единственным мне примером,
при котором Лондор реально меняет поведение Капилятора. Вот. Ну, там УБ было в этом примере.
И так и так или без Лондора?
И так и так УБ, как мы выяснили в прошлый раз, потому что в прошлый раз мы как раз выяснили, что даже с добавлением Лондора УБ остается.
Вы же помните?
Потому что мы обращаемся к объекту до того, как мы его... его создал хоть кто-то.
У него время жизни началось вообще там, вот там просто неинцелизированная штука, и...
Вот. Сейчас я расскажу вам как раз как это фиксить, но вопрос о том, привести пример, когда Лондор реально влияет на поведение Капилятора,
остается открытым. Короче, если кто-то найдет и приведет пример того, как функция Лондор реально меняет поведение,
наблюдаемое поведение программы, и при этом это не УБ, то, не знаю, дам какие-нибудь бонусные баллы.
У нас в прошлом году была такая история. Последняя пара пар. Вот у нас на последней неделе, которая будет, значит, там, 10-го,
ну, наверное, 16-17 мая, это будет уже зачетная неделя, вот, я предлагаю сделать на зачетной неделе так же, как в прошлом году мы делали,
а именно можно будет подготовить какой-нибудь рассказ по выбору. В прошлом году у нас человек рассказывал про рейнджи,
вот, потому что у нас в курсе про рейнджи не рассказываем, видимо, в этом году тоже не расскажем. Может расскажем, не знаю, не успеем.
Вот, короче, как вариант, вот, если кто-то хочет, я не знаю, какие-нибудь дополнительные плюсы к оценке, можно поговорить об этом,
если вы найдете, если вы реально разберетесь там, как это работает, и приведете пример вот этому, вот, короче, приведете пример,
как Лондор меняет поведение, но при этом это не УБ, то есть, корректный использователь, который реально меняет поведение.
Вот это интересно, потому что, ну, в этой статье на Хабре есть пример, ну, есть объяснение, что делает Лондор с точки зрения внутреннего представления компилятора,
но примера, в котором был он реально, короче, того примера, который я ищу, там нет. Давайте устраним УБ. А как устранить УБ?
Ну, надо еще осхитить немножечко. То есть, УБ из-за того, что мы вот здесь делаем это Нью до того, как вообще имеем право обращаться к этой памяти.
Потому что мы сейчас родители конструируем, а наследника еще, вообще, у него поля еще даже не, ну, время жизни полей не началось.
Как устранить УБ?
Ну, на самом деле, вот что надо сделать. И если мы посмотрим в стандартную реализацию варианта, мы примерно это увидим.
Ну, я это уже исправил в втором ходе. Значит, давайте просто сделаем еще одного наследника. Родителя, точнее.
У меня будет теперь вариант storage отдельно, а вариант alternative после него.
А storage, а не вариант storage?
Да, и storage хранится вариант storage. Теперь вариант alternative будут конструироваться после того, как создался вариант storage.
А значит, в момент, когда создается вариант alternative, storage уже будет чем-то пренциализированным. Нам осталось лишь подложить перед него другую штуку.
Классно, Петров.
Вот такое решение предлагается.
А сейчас, секунду.
Тест. Кто понял проблему и ее решение.
Я понял. С кем я разговариваю вообще?
Три человека. Так, остальные?
Нет, это как-то не очень. Давайте все-таки, чтобы я не стремлялся к ней общаться, давайте, не знаю, вопросы задайте какие-нибудь.
А кто собирается варианты писать?
У меня вообще еще, наверное, писано.
Да, в принципе, можете не писать как-то. Это если кто плюс баллы хочет.
Но я предупреждал в начале семестра, что задачи на плюс баллы будут не очень простыми.
Ну так чего, есть вопросы?
Или повторите все с самого начала?
Да.
У меня есть вопрос, связанный с этим поэтому.
Зачем мы изобретали такую страшную реконструкцию в виде двух-тройдач, если мы могли просто сделать СТП?
Почему мы не могли просто передать вариант-альтернативу type.variant?
Не понял. В смысле передать?
Ну и сейчас. Зачем мы создаем миллиарды родителей, в каждом из которых передаем все наши аргументы, если вместо всех наших аргументов можно делать себя?
А ты хотел бы сказать, что вариант-альтернатив, что вариант, это наследник варианта-альтернатив от нас самих, то есть от варианта?
Да.
От варианта какого?
От варианта с нашими типами.
Вот это type... заменить на...
Что это изменит?
Идея на ничего просто новая. Идеи не будет. Просто старая терта по-обычной.
Нет, но...
Что это даст?
У нас все равно будет множество наследований.
Конечно.
А у нас там все равно будет триточка?
Конечно. Я просто пытаюсь понять, почему мы считаем, что вот это нечто совершенно новое, гениальное, изобретенное с какими-то там гениальными людьми, если фактически такое же мы уже делали.
Но мы не делали с...
Сейчас ты хочешь написать вот так. Вариант, от types, а многоточие ты хочешь оставить внешнее?
А я могу просто вариант...
Нет, так я же не могу.
А как ты предлагаешь тогда? Я не понял.
В смысле?
Чего идеи не поменять просто?
Сейчас. Почему я не могу просто варианты, кстати, написать?
Так, а...
У нас главная проблема, что T нужно.
Мне нужно импортировать N конструкторов.
Да.
Чтобы перегрузка между ними делалась.
Мне нужны N родители.
Для этого N родители.
И внешне многоточие будет.
А внешне многоточие, оно будет что распаковывать?
Если это вариант от types?
Нет, нет. Понятно, что нужно types.
А что здесь тогда написать?
Ты предлагаешь вместо того, что было написано?
Types, запятая, вариант.
А, вариант от types?
Типа.
Не просто types многоточие, а вариант от types многоточие?
Да.
Это выглядит как что-то более сложное, чем то, что было раньше написано. Не так ли?
Ладно.
Ну, то есть...
Граждалось, что можно просто так сделать, а еще не дополнительный вариант от этого.
Ну, а потом нужно быть...
Ну, тогда сверху нужно...
А хотелось, чтобы написать вариант.
Ну, и к тому же здесь, например,
я вычисляю индекс, имея types многоточие.
Да, это правильно.
А если бы у меня не было варианта, то...
Так. Так что?
Все? Вы это там...
Никто ничего больше не хочет сказать по этому поводу?
Ну,
на самом деле,
я действительно в прошлый раз
сам сделал некоторые открытия
благодаря этому,
благодаря этой истории СУБ,
потому что у нас там
люди, которые сдавали вариант
вот по этой модели,
которую я вам пропагандировал,
а у них...
Ну, в общем,
в общем, там
приходилось
отключать
жалобы...
Там warning был один,
и если поставить minus or all, то компилятор ругался.
Maybe I'll initialize.
И теперь я понял, почему нам приходилось,
чтобы у них зашло в контест отключать
конкретный warning.
Теперь мы не будем отключать warning, я понял.
Там просто действительно было бы это...
Да.
Ну, просто вот...
Я сам не замечал этого УБР,
я думал, что так нормально,
а вот теперь только мы поняли, что так ненормально.
И сейчас нам лаундер больше не нужен?
Нет, лаундер формально все равно нужен.
Потому что ты же нарушаешь эти условия,
ты же покладываешь вместо одного типа другой тип.
Разве?
Вообще на другое место.
А, потому что у меня там вообще чадр.
Формально лаундер
все еще нужен,
но реально теперь
лаундер не меняет поведение.
Я вот, если сейчас это скандирую с лаундером без лаундера,
с телландером без СС, ничего не меняется.
Поэтому и...
А если лаундер не написать,
будет УБР?
Формально, да. Кажется.
По крайней мере все плюс 17.
Я не уверен, все плюс 20 поменялись ли условия.
В общем, пишите лаундер на всякий случай.
Ладно.
Так, окей, мы наконец-то,
слава богу, закончили разговор про вариант.
Да.
Наверное, выложу условия сегодня.
Я надеюсь.
Все.
Давайте пойдем дальше.
Ну дальше будет чем попроще, наверное.
Какое-то время.
Нам глобально, так,
осталось две темы пройти.
Но
в каждой из них можно много где
развернуться. Значит, сейчас
тема, которую я хочу начать, это
с Финайе и концепты.
Ну, про концепты мы, видимо, поговорим
завтра.
А сегодня мы пока поговорим
просто про
шаблонный метапрограммин, использовавший
Финайе.
Значит, давайте я
начну.
Что такое Финайе?
Видимо, я так сказал,
что все это знают.
Кто не знает, кто не понял, тот поймет.
Значит, тема 15-я.
Ну, давайте я скажу,
template,
метапрограмминг.
Финайе
и
концепт.
Сейчас
наша главная цель
на сегодня, это реализовать
все тайп трейты, которыми
мы до этого пользовались без реализации.
А именно, мы сейчас реализуем
ну, не сейчас прям,
сейчас мы сначала кое-что обсудим.
Одну гениальную идею
изобретенную, там, еще до 17-19.
Вот.
Значит, тизер на сегодня.
Сегодня мы реализуем с вами
compileTime проверку, есть ли в классе
такой-то метод.
И тем самым поймем
окончательно, как работает
в локатор trades,
которые, если метод есть, вызывают его,
а иначе делают не у сами,
как вы помните, да.
Дальше мы реализуем с вами
мета функции
из constructable, из convertible,
из copyConstructable и moveConstructable.
То есть, ну, такие тайп трейты,
которые проверяют, существует ли конструктору
класса таких-то аргументов и так далее.
Можно ли move-нуть этот класс там.
Дальше мы с вами реализуем проверку
из no-from-move-constructable.
Правда ли,
что данный класс move-ается
с noexcept?
И как следствие, мы реализуем
move of noexcept.
Помните, у нас была проблема в векторе,
что мы использовали move of noexcept,
потому что не могли move просто так,
должны move, если noexcept, и копировать иначе.
Вот. Сегодня мы реализуем move of noexcept.
Ну и реализуем еще
из baseof. Проверку, что один класс
наследник другого, в том числе, приватный.
Вот. Секунду.
std из baseof проверяет...
std из baseof приватное наследование тоже распознает, да.
Ты это уже спрашивал.
Сейчас. Это логично, что это?
Можем ли мы после этого
присвоить... Вот у меня есть
два типа u и t. Я проверяю,
верно ли, что t, base, от u.
Да. И потом пытаюсь
к t присвоить u, а он такой ругается.
Вы думали, что из baseof распознает приватное наследование?
Да. Ну...
Вот комитет решил, что
для цели std из baseof это логично.
Впрочем, c++20
они передумали.
Ну, нет, замечание очень правильное.
Типа, должен ли этот...
Функция... Ну, type-trade std
из baseof распознает приватное наследование?
А вот концепт
baseof, который в 20-м появился,
он же не распознает приватное наследование.
Мы про это поговорим уже в непохожей.
Вот, давайте начнем. Вот с чего.
Бейсик.
Наверное, меня просят, чтобы что-то работало,
чтобы кому-то можно было присвоить его наследник.
Я же должен это делать только если
не приватное наследование.
Ну, напиши свой из baseof.
Сегодня мы... Нет, мы сегодня
поймем, как писать, который распознает.
Ну, раз буквально в одной строчке разница.
Приватное или не приватное наследование,
чтобы он включал false или true.
Там, прям, увидишь, это легко.
Вот.
Ну, хорошо.
Начнем
с базовых приметилов для
шаблонного метапрограммирования.
Честно признаться, что
вот эта тема, она моя вторая
по любимости в курсе после
муфсемантики. Я говорю, что муфсемантика
любимая тема. Вот эта вторая из любимых тем.
Это весело. То есть,
весело, сейчас увидите. Давайте сначала...
Вернитесь к нам.
Вот его нет, очень жаль.
Прям максимально так, что его сегодня нет.
Я просто... Я мечтал
наконец-то послушать его комментарии
об этом, когда он его услышит. Видимо, мы не обним
знаем его мнениях по этому вопросу.
Значит...
Очень жаль, конечно.
Очень жаль, что я не услышу этих
комментариев. Ну, ладно.
Смотрите. У нас
в чем
вообще суть метапрограммирования?
Идейно, вкратце. Мы сейчас
пишем с вами некоторые функции.
Типа функций, вот типов.
То есть, мы берем типы
и...
Какое большее слово
тип?
Типа функция, типы.
Мы берем типы
и про них что-то
говорить. Например, у нас была
совсем простая метафункция
Say.
Ну...
Ну, давайте я там наполню вот совсем
быстро, значит. Что... Что делала...
Я буду называть их метафункциями.
Что делала функция метафункции Say?
Там была
using...
Не using, там был static const
bool value
равно false.
А еще у нее была специализация, которая
для одинаковых типов
говорила true.
Вот. Ну, это все
и так знают.
Должны знать,
по крайней мере.
Вот. Ну, и была
и saveware.
Да, значит...
Которая просто говорила,
что...
Это была
булевская константа.
Вот это метафункция,
которая принимает два типа и возвращает
bool.
Есть... Бывают и другие
метафункции, которые...
Ну, например,
бывает метафункция, которая принимает
bool и возвращает тип.
У нас была STD conditional.
В зависимости от compiletime
условия, либо мы
возвращаем один тип, либо другой.
Ну, или у нас была еще метафункция
там remove reference, например. Вот давайте я
напомню, что такое remove reference.
Type name t,
структура
remove
reference,
которая
в себе определяет using type
равно t
и ее специализация для ссылок,
которая
делает то же самое,
просто убирает
интерсант.
И ее специализация для двойных
ссылок, кстати. Когда мы писали remove
reference впервые, мы еще не знали про
существование remove, про существование
R-value ссылок, поэтому нужна еще такая
специализация.
Вот. Я все к чему...
Здесь это не считается?
Универсальной ссылкой?
Нет. Ну как?
Универсальная ссылка
только по параметрам функции обычно.
Вот.
Я это все к чему? Я к тому,
что я сейчас хочу
определить несколько примитивов,
чтобы нам не приходилось в дальнейшем вот эти вот
value и type все время
определять.
Все это определено в type traits.
Во-первых, существует
такой
примитив,
называемый integral constant.
Ну, наверное, вот так.
Значит...
Значит, integral constant...
Да, да, да. Значит, у меня
struct integral
constant.
И в ней будет
static
constant
t
value
равно x.
Сейчас я
на всякий случай
перепроверю.
Internet banking. Спасибо.
Integral constant.
Интернет не работает.
Все так.
Да, все правильно.
А tv, давайте
вот.
Это такая статическая, ну, по сути,
это такая метафункция, которая просто
константная функция.
Она принимает тип
и
возвращает
какую-то константу этого типа.
Вот. И дальше...
Почему это все работает?
В смысле, что
а почему пока здесь не работает?
Тебя смущает, что можно так
на mttv?
Мы-то вообще могли только int
запихивать. Ну, в смысле...
Ну, t должно быть...
Ну, t должно быть таким, понятно, что если изведет sd-вектор,
то так это вряд ли сработает.
А что должно быть?
Ну, вот наиболее типичное
использование integral constant. Следующее.
У нас сейчас будет такая структура
под названием
true type.
Да, структура true type
это будет
integral constant
от bool
и
true.
Возможно, это юзинг. Наверное,
правильно сказать, что это юзинг.
Не знаю, честно говоря.
Наверное, юзинг все-таки, действительно.
Наверное, это в точности такой же тип.
А false type,
соответственно, это следующее.
Это integral constant
от bool
и false.
Теперь, на самом-то деле,
вот это все можно не писать.
А вместо этого можно просто написать, что
isSame, вот тут уже не юзинг,
тут уже наследование.
Это
false type.
А isSame
от одинаковых типов, это true type,
но только надо
тело пустое оставить.
Сейчас, еще чего-то не нужно случайно.
Как
им теперь пользоваться?
Все, теперь у тебя
в isSame от двух разных
типов есть value boolev, которое равно
false.
И isSame v мне все еще придется определить.
Да, блин.
Type name.
Я когда-нибудь
я установлю силуэр.
Извините, статик,
не статик, просто const,
const export надо написать.
Давайте я пишу const export,
пока не совсем хорошо объясняю, что это.
Но давайте я буду использовать слово const export
иногда все-таки.
const export значит константа времени компиляции.
const это просто константа,
const export константа времени компиляции.
const export константа времени компиляции.
Пока не будем сильно вдаваться
на разницу, но просто вот
здесь тоже const export правильно написать.
Про const export у нас мы отдельно потом поговорим.
Здесь еще где?
Ну, статик const export value boolev.
Статик const, оно и так
const export будет, но
скажем, каноничнее написать
const export.
isSame v
равно
isSame
tu
v.
Вот, короче, это просто
примитивы, через которые мы будем определять.
То есть я в дальнейшем не буду писать никогда,
вот сейчас мы будем с вами реализовывать всякие метафункции.
Я не буду писать
статик что-то там boolev
or true, или там статик что-то.
Нет, я буду просто
наследоваться от true type.
Когда буду хотеть, чтобы у меня была структура
статик const boolev
вот
вот, теперь ему
референс.
Здесь
а, еще
смотрите, еще есть
bool
bool
на, значит я открыл type traits
здесь еще есть
bool constant
bool constant это просто
integral constant от boolev
типа 17, зачем мы добавили еще bool constant?
Давайте посмотрим теперь вот на такое.
Чтобы у нас все это сможет было так.
Да, да, да.
Давайте такое определим метафункцию type identity.
Ну, я просто
да, перепишу сейчас, чтобы значит
следующий примитив, который я буду активно использовать
template
typeNameT
struct
typeIdentity
это метафункция,
которая принимает типа возвращать его же
using type
равно T.
Зачем?
Да, чтобы когда мы вот такое определяем
мы просто не писали вот это using
метафункция, а говорили это typeIdentity
от T
а здесь мы скажем, что это
typeIdentity, ну и здесь мы скажем, что это
typeIdentity от T.
И здесь мы скажем, что это
typeIdentity от T, но наверное проще будет
скопировать вот это и 1%
убрать.
Хорошо.
Вот.
Еще typeIdentity
T.
Давайте подумаем,
не можем ли мы воспользоваться, чтобы
чтобы
не писать ему в референс
T свое?
Боюсь, что нет.
Да, ну потому что
они догадались,
что можно
Да, да, да. Ну это просто
это примитив, который
позволяет сэкономить, не писать вот
это вот.
Так.
Remove Reference T, кажется, мне все равно
придется определить.
Давайте подумаем,
не могу ли я с вами typeIdentity T как-то
от Remove Reference T
избавиться?
У нас может быть using вот мы
а ладно, это пресс будет, да.
Ну нет, кажется, не могу.
Кажется, не могу.
Вот.
Ну дальше, в принципе, все.
Легкое упражнение
для вас должно быть теперь реализовать
все, ну почти все
вот эти вот typeTrait
из Function.
Вот. Ну. Нет.
Из Function это не очень просто.
Из pointer.
Из array.
Из array легко.
Специализация для T квадратной
скобочки и все.
Ну что такое?
Секунду, что такое type
T квадратной скобочки?
Вот тебе реализация STD array.
Из array.
Общая из array. У тебя общая версия
false type, а если у тебя
от типа с квадратными скобочками или от квадратных
скобочек? Что?
Что происходит?
Ну что, вот.
Чем начались последние две?
Ну, вероятно,
ну вероятно формально это два разных типа.
Тип просто квадрат массив
массив от n.
Если вам в системах вывода
типов есть два разных, да?
У нас в специализации может быть больше шаблонных параметров,
чем было?
Конечно.
Почему это все еще специально?
Потому что часть лучше покрывает.
Сейчас. Главное, что вот здесь вот
ты говоришь array.
В специализации у тебя один шаблонный параметр.
А из array от чего-то конкретного?
О господи, да.
Я же не говорю из array от A запятая B.
Тут мне просто нужно два
метапараметра, чтобы объяснить
от чего я хочу специализироваться.
Ну вот из array. Это просто мы взяли
и...
Что мы сделали?
Мы специализировались
для случая, если у нас
это массив.
Что такое?
Ну ПТРТ?
Ну ПТРТ это тип,
который имеет выражение NullPTR.
Это мы в самом начале года обсуждали.
У вас есть NullPointer.
А зачем?
Ну потому что какого типа
должен быть NullPTR?
Я обнаживаю не одна голос, нормальная.
Ну, вот звездочка...
Не знаю почему.
Вообще в shared BTR можно делать
специализацию, когда мы принимаем NullPTR
именно через NullPTRT.
Отдельно.
Ооо!
Это идеально.
Наверное, просто NullPTRT чуть удобнее,
чем void звездочка иметь.
Он не явно кастится void звездочкой.
Я думаю.
Ну это как так передавать.
Можно свой так делать.
Вот. Как понять?
Из void. Ну это просто проверка, что типа
из integral.
Как реализовать из integral?
Ну просто проверить,
что это один из следующих.
Из floating point, аналогично.
Проверить, что он один из
этих трех.
Очень легко. Из Null.
Как реализовать из Null?
Боюсь, что никак.
Возвредливо.
Потому что у нас нет синтеза
проверить.
Является лететь янумом.
К сожалению. По крайней мере, я не знаю.
Вот.
Возможно...
Здесь я должен сделать важную оговорку.
Я говорю, что
большинство этих вещей легко реализовать.
Это простое упражнение,
но некоторые из них не могут реализовать.
Возможно.
Понятно, что некоторые вещи
нельзя реализовать на уровне языка,
и они вшиты в компилятор.
Например, из union и из class
нельзя реализовать.
Вот проверку из class
реализовать нельзя,
потому что...
Сейчас мы с вами напишем
проверку из class o union.
Нет. Class и структура
ничем не отличаются.
Class от union
отличить нельзя.
Это только компилятор умеет.
Из янума, из union, из class
только компилятор может.
Это внутреннее представление, как реализовывать.
А int это class?
Int это не class.
То есть class — это user-defined
либо class, либо структура.
Ну да. Но не union.
То есть мы можем определить, что это class или union,
просто что-то не что-то из built-in types.
А enum class тоже class?
А...
Enum class — это не class. Нет, это не enum.
А...
Class o union можно определить,
как что-то из built-in types.
Можно, но можно короче.
Мы сейчас разберемся, как.
What is function, кстати?
Ну, я бы не сказал,
что...
Ну, идея напросто, много кода, но идея напросто.
Как реализована проверка, что нечто является функцией?
Rx6...
Просто...
Сейчас...
Почему шесть?
Точка.
Так.
Понятно, что is function
общая версия — это false type.
Дальше. Is function вот от такого
это true type.
Я обосновился на этом шаге, честно говоря.
Что дальше?
Дальше нужно перебрать всевозможные комбинации
const volatile, ampersandы,
двойные ampersandы,
accept, начиная с C++17,
но accept является частью сигнатуры,
поэтому на accept тоже надо дописывать.
Только у нас здесь 2х5 их?
Ну...
Волотайл — это вещь, которая
связана...
Ну, в общем...
Сирик-валифаеры — это значит,
что на тип, наверное, const или volatile.
Ну, если вкратце, volatile —
это некоторым образом
подсказка компилятору,
что эта переменная может
быть изменена в неожиданный момент,
например, другим потоком,
поэтому ее нельзя...
Обращение к ней нельзя оптимизировать,
но это слово...
Вероятно, вы это на втором курсе обсудите,
когда будете изучать много поточек,
мы про это не говорим,
но вообще слово volatile устарело, по-моему,
C++20, поэтому про него можете вообще...
А шесть точек — это что значит?
Давайте лучше разберемся, что такое шесть точек.
А есть какой-нибудь версии,
для чего это?
Там будет пакет пакетов.
Ну, блин...
Интересно.
У вас функция может в C-стайле
принимать пакет
и еще запитать многоточие.
У нас же есть C-стайл,
переменное количество
аргументов для функции.
Функция может принимать
какие угодно типы,
запитая многоточие.
Это C-стайл многоточие.
Оно означает, что там нужно завести
какую-то с лишней структуркой,
из нее вычисляется аргумент.
Ну, потому что там не обязательно
запятую ставить.
Ну, ты просто пишешь
f от int многоточие,
и это означает,
что она принимает int
и еще что угодно.
Вот, то есть, если у тебя функция
ну, типа print...
А почему не делать так, чтобы там
забегать многоточие?
Да просто так.
В C-м уже сделано, все, больше не ставить.
Дядюшка C.
Ну вот.
Вот для этого 6 точек надо.
Хорошо. Ну, из pointerZLLEReference
из memberObjectPointer.
Что это такое?
Негонятно.
Указатель на поле.
Проверка того, что это указатель на поле.
Что это?
Что ему можно передать?
T является указателем на поле.
Ну, давайте сначала
из memberPointer просто
прочитаем. Что такое из memberPointer?
Проверка того,
является ли T указателем
to non-static member object or pointer,
то есть static member function.
Ну вот, собственно.
В общем,
в общем случае
это false type,
а в частном случае, когда у вас
вот такой тип,
ну то есть memberPointer,
это true type.
А зачем?
Зачем там
наследование типа
через код?
Потому что
чтобы не перебирать всевозможные
видимо, и волатайлы.
Пожалуйста, нет для него Максимова.
Почему из function не делали?
Почему бы из function не делали так?
Может там нельзя?
А от чего ты removeCV-то сделаешь?
От всего.
Кстати,
почему-то здесь typeName
removeCVType, а не removeCVT.
Что странно, потому что очевидно же есть
removeCVT.
Что-то написано до того, как придумали removeCVT.
Это потому что, да,
потому что видимо это писали до того, как придумали.
Можно спросить, почему у нас вот это один тип?
Где?
Struct из memberPointer helper,
tyut, вытащи звездочку.
Это один тип?
Ну, как ты объявляешь указатели на члены?
Я не объявляю указатели на члены.
Зря.
Ну вот, у тебя есть структура ASP.
Я думал, что это просто какой-то костыль.
Давай объявим указатель
на член структуры.
Давайте.
Это будет int
s
2.2. звездочка
p равно
амберсант s 2.2.x.
Какой тип у p?
Видимо int 2.2.x.
Сейчас узнаем, какой.
А, а,
крылья тоже урганятся,
и мы увидим, на что.
Да.
Sphinae,
ой, не то, не то.
StarCityPd211
Может быть, даже нужна
да, конечно,
увидим.
Ну, вот, в принципе, мы увидели.
Кратко наверт
вот такой тип int, правильно?
Ну, у тебя нужно, у тебя два параллитета.
Вот этот вот table.
Его можно принять? Можно функцию f, пожалуйста, принять вот это?
Конечно.
Замаста.
Нет, без авто.
Я не собирался.
Нет, я бы сказал авто, я не против, можно.
Пожалуйста.
Это будет указатель на член структуры.
И ему точку звездочку можно прибелять.
Где он?
Там где-то.
Так, а что у меня не так-то?
Они закрыты.
Вот здесь.
Все, теперь все нормально.
Ну, понятно.
Нет, ленивое.
Ага, понятно.
Ну вот, специализация
для такой штуки.
Так.
Так,
ну, что еще здесь имеет смысл?
Ну, мы не поняли, там мы использовали member function.
Да, member function pointer, давайте посмотрим.
Как отличать?
Потому что это, а, member и еще это function,
что-нибудь такое.
Ну да.
Значит, как понять,
что это member function?
У нас, кажется,
была специализирована для...
А там же
именно, там так, ну,
у нас тип выглядит, что нам не нужно специализировать.
Потому что t является member function.
А, ну да, если мы...
Это является просто function.
Да-да-да.
Member to function
pointer to function member
он подойдет под вот этот вот
синтаксис.
Когда function писали, у нас же pointer to member
попадали в ту специализацию, правильно?
Поэтому, чтобы проверить,
что мы member function pointer, мы просто проверяем,
что мы member
pointer и function.
Вот.
Ну, а
чтобы сказать, что мы member object pointer,
мы просто говорим, что мы
member pointer и не
member function pointer.
Там показывают,
что есть оператор круглой скобочки.
Где?
У всех этих объектов.
У каких объектов?
На стримочке.
Считается, что
там написано, что
ему STD integral type
есть круглый скобочек, который возвращает его
в 2.4.2.
Они, видимо, подставят с употреблением.
Ну, да. Это не вот. Устранится
притара из фаната.
Вместо того, чтобы писать STD
допустим из array t,
можно писать STD из array
круглый скобочек.
Можно.
Э, что?
Где?
Вот-вот-вот-вот.
Синий квадрат.
А, это?
У integral constant такое есть?
Да, 400 круглых скобочек.
Сибирь плюс 14 добавили. Клёво, да.
Прикольно, я не знал.
Ну, это
да, чтобы не приходилось
писать, надпочеркиваю,
чтобы не приходилось писать
выточить выдачу value.
Нет, ну вместо написания
не t, это же integral constant.
А, ну вот нельзя, да?
Валют просто есть.
Не, в тоже можно было.
Да, ну, либо ты пишешь
не подчерк.
Я не уверен, что есть integral constant v.
Не уверен.
Я думаю, нет.
Ну, в общем, да,
просто можно круглые скобочки писать.
Ну ладно. Так, всё, member object pointer тоже понятно
построен. Это просто
ну, понятно, это
просто integral constant.
Сейчас операторы наследуются.
Конечно.
То есть теперь мы всем можем писать круглые скобочки.
Всем, кто наследует integral constant.
Вот, это гораздо круче.
В этом суть, да.
Теперь мы не должны писать
надпочерк ни одной нигде.
Да, это клёво.
Правда же, что
функции, которые там
в классах, они по сути не явно принимают
указатель вот здесь в себя.
А это как-то можно, это как-то видно
в смысле, из того,
как у них тип или что-то такое.
Ну, в смысле, ну,
вот у них же тип, а там что они принимают?
Какие аргументы там будут? Видно, что они не принимают
указатель на
объект или нет?
В смысле,
ну, вот, когда мы писали
из function, там вот эти арки.
У него будет первый? Нет, конечно.
Ну, это же скрытно.
Ты не...
Если бы так работало,
то тебе было бы очень неудобно этим пользоваться
в нормальных случаях.
Когда STD function
используешь, ты не хочешь думать о том,
что это метод.
Ты просто...
А, нет, ты как раз должен
до этого думать, если у тебя указатель на метод.
Если у тебя указатель на метод, да, ты должен
это упоминать туда.
Если у тебя указатель на метод,
то ты первым аргумент придёшь ссылку на
объект класса.
Можешь себе, к примеру, объяснить?
Вот этот? Да.
Нет, это книжник.
Вот, давай посмотрим.
int от... вот что это выражение значит?
int от seo
2.2.2.2 звёздочка.
Вот что это? Seo...
С той классы вообще, что это?
Ну, вот это означает то же самое,
что я писал только без скобочек.
Вот так можно делать.
Ну...
Это...
что?
Второй скобочек на цикле.
Сейчас, нет, это... Нет, нет, нет,
виноват, виноват, здесь не так, здесь не так.
Дело в том, что это поле.
Давайте я метод объявлю.
void.je
фу
от...
вот у меня будет int.fu
Нет чего.
А, тогда как мне объявить указатель на фу?
Это будет int.
Мне надо указатель на функцию объявить.
В обычной ситуации указатели на функцию объявляются так.
Я говорю, возвращаемый тип
звёздочка
pf от чего
равно амперсантом
f.
Ну, вот я могу объявить указатель
на вот эту функцию f.
А
если это указатель на метод,
то вот здесь
мне как раз в этих скобочках нужно
писать s2.2.2 еще.
Вот.
Вот так.
И вот здесь мы просто
указатель на метод класса
CLS.
Мы просто не даём ему имени.
Это не важно.
Является этот тип
int.cls
звёздочка
указателем на метод.
Ну, и он является
сигнатурой такая.
Да.
Вот это...
Это всё-таки указатель
на член.
Если я поставил вот здесь скобочки,
но не поставил скобочки
после этого, то нормально.
Это указатель на объект.
А если я вот так написал
после этого еще скобочки,
то это уже указатель на функцию член.
Скобочки нужны, чтобы перечислять
то, что он принимает, если он принимает.
Ну да, вот эти скобочки всегда и аргументы перечисляют.
Красота.
Кто придумал это так писать?
Это же вообще непонятно.
Я не знаю.
Создатель
страуструб какой-нибудь.
Я не уверен, что Таллот придумал.
Возможно, он смирился с тем,
что кто-то до него уже это придумал.
Окей.
Да.
Так.
Ну, в принципе,
всё более-менее...
Всё очевидное прошло.
Всё очевидное закончилось.
Давайте только я... ещё вот.
Давайте ещё парочку.
Все эти вещи, они
гораздо более хитро
реализуются. Мы сейчас посмотрели на
type rate, которые реализуются банально
доследованием каких-то базовых проверок
integral const.
Фактически мы сейчас всё выражаем через the same
с какими-то преобразователями.
Remove, reference, add, что-нибудь там.
И или пишем.
Давайте ещё посмотрим вот на такие
три
полезных вещи.
Конъюнция, дизьюнция,
отрицание.
Смотрите.
В смысле? Где? Что? Как? Что?
Давайте вот посмотрим на такой замечательный
тип метафункции
SD convolution.
У вас может быть несколько
гульевских констант.
И вы хотите сделать
И по ним по всем.
Так.
Ну, то есть, например, вы хотите проверить,
что все типы в пакете
аргументов это, не знаю,
ссылки.
Тогда вы говорите
conjunction от
args многоточие
веточие, веточие value.
Ну, conjunction от is
lvalue, reference
от args
веточие, веточие value.
Сейчас. Что?
Можно вопрос? Там?
Ну, давайте я, хорошо,
давайте это напишем. Вот у меня есть
какая-нибудь функция ещё одна, которая
принимает
type name, не знаю,
args.
И она принимает вот там
args многоточие.
Ну и давайте
я что-нибудь проверю про них про все.
Ну, например, я хочу проверить, что все они,
не знаю, константные.
Или все они floating point.
Я говорю
static assert.
Понятно, какой static assert, да?
std
conjunction
v
e
так, из conjunction
v, да, conjunction v, все нормально.
std conjunction v, от чего?
от
std
из
не знаю.
Ну, давайте скажу, is lvalue, reference
от args
многоточие.
Вот.
Что я сделал сейчас?
Я сейчас проверил, правда ли,
что f я вызвал от всех
lvalue.
Ну, например,
int x равно 0, int
y равно 0
и напишу f от x
zeta u.
А здесь напишу
f от, ну, вот
вот это должно быть true.
Я по всем, по всем аргументам
пакета проверил, что они lvalue.reference.
Но если я вызвался
от lvalue, то arg все будут с lvalue
с одним и персантом, правильно?
Вот сейчас должно все
нормально быть.
Нет, не все нормально, а почему
std
lvalue.reference v
conjunction
нет, нет, нет, вроде
там буквы n хочется conjunction.
lvalue.reference без v нужно использовать.
Почему?
Почему?
Потому что он принимает типы,
которые внутри есть value, он их использует.
О, конечно, потому что
не может bool и принимать.
О, все нормально.
Как bool и принимать?
Conjunction должен типы отдать,
а не значения.
А почему я не могу пакет block дать?
А как там написать?
У тебя есть type.
ты не можешь написать bool 3.
bool.bools
Нет, вообще можно было
написать conjunction, которое принимает bool.
Переменное количество
block. Как
принять переменное количество block?
ну
bool.bools
А
syntax такого нет, наверное?
template
нет, сейчас, подождите.
template
есть
а еще, кстати, у нас штук
многоточие, я могу так написать?
О, да.
что, так можно?
в шаблонах можно, да. Прикольно.
У меня может быть переменное количество
аргументов шаблона,
но они не обязательно type name, ну давайте я
может, например, вывернуть
или stconjunction
принимает именно type. Давайте вам покажу
сейчас пример, когда
То есть если мы хотим передать
просто bool, мы можем
вообще этим не пользоваться
и просто... Вот, пожалуйста.
Нет. Вот вам пример.
Штуки, которые принимают
переменное количество вещей, типа
t, ну, это шаблонные аргументы.
ImpagerSequence
Или мы можем просто оператора
n использовать?
А, у нас же есть
уже сейчас
Folded Session
Мы можем здесь использовать
Да, мы можем здесь, в принципе, использовать
все это в круглые скобочки поставить.
Ну, то есть, давайте я это продемонстрирую.
Можно написать так. Мы написать
круглые скобочки, и вторые закрываются.
Estadale, will you reference
V, arcs
и запитая многоточие.
Скобочки закрываются.
Почему запитая?
Ой, не запитая,
а двойной имперсон, конечно.
А почему можно еще одни скобочки?
По синтексу, потому что Folded Expression
требует скобочек.
Своих скобочек.
Ну, можно и так и так, да.
Ну, если вы
метапрограммированием занимаетесь, то
вам удобнее
принимать именно типы в качестве.
То есть вы не работаете с...
Вы стараетесь не работать с константами
числовыми. У вас есть TrueType.
Will you reference это либо TrueType,
либо FalseType. Вы в конжанкцион
отдаете TrueType и FalseType, и возвращает
она вам опять либо TrueType, либо FalseType.
Это просто логично. Почему
в конжанкцион уйдете bool, а отдаете TrueType
и FalseType?
Потому что эта метафункция, она из TrueType
и FalseType делает вам снова либо
TrueType, либо FalseType. Понимаете?
Ну вот, если я сейчас
сделаю f от x запитая 5,
скажем, то будет
f и e.
Static Asosian failed.
Оба причем failed.
Понятно? Почему?
Я не f от x запитая 5,
а f от x запитая 5.
Ну, по правилам
универсальных ссылок,
второй акс стал без ангерсанда,
поэтому конжанкция не сработала.
Вот.
Можно реализовать
а мы с вами реализовывали
например, метафункцию изомоджинирус,
которая проверяет, что все типы
в пакете одинаковые.
А мы...
конжанкшн мы не реализовали.
Конжанкшн мы не реализовали, да.
Но давайте реализуем.
Я не буду писать, наверное,
а то что-то мы долго уже сидим на этом.
Но давайте реализуем.
Давайте конжанкшн
реализуем.
Ну как работает
конжанкшн?
Во времена конжанкшн
занимает квадрат времени компиляции.
Во время компиляции занимает квадрат
количества аргументов.
Давайте подумаем.
Я думаю, что нет.
Конжанкшн, общий случай
это true type, конжанкшн от одного
типа это просто он,
конжанкшн от типа и еще каких-то типов
это conditional,
а значит
если он
если он true
то остальные, иначе он
вот и все.
Причем возвращает первый false type или
Вот. Придется ли
сколько типов придется компилятору
инстанцировать, чтобы вычислить конвьюнцию?
Ну понятно, дело дается.
Эти типы тоже длинные все.
Это никак не влияет
на...
Даже не будет 256,
он запихивает тебя, правда?
Я?
Вполне возможно, что
в принципе так будет снимать.
Может еще помедленнее поработать.
Ну в общем, да,
это не очень эффективно, наверное.
Это правда.
И о чем это?
Ну тебе нужно инстанцировать n типов,
каждый из которых содержит n шаблонных параметров.
То есть ты в этот квадрате всего типов
ну, у тебя как бы
смаражная типа большая.
Ну суммарная длина каких-то типов там довольно большая.
Вот.
Смотрите,
здесь есть примечание.
Short-circuit instantiation
differentiates конвьюнцию
from false expressions.
Кстати, да. О, заметьте.
Чем конвьюнция
лучше, чем вот это?
О, знаете, важное замечание.
Почему использовать conjunction
лучше, чем второе?
Потому что в первом случае
инстанцируется лишь
до первого false type, а во втором случае
инстанцируется все.
Ну смотрите, вот.
Short-circuit instantiation.
Как short-circuit вычтение
гулевских выражений.
Он инстанцирует
только те типы, которые
ну, то есть он говорит
гуль вот от этого
если true,
то нужно инстанцировать конвьюнцию
от вот этих.
Если бы мы упомянули, значит он инстанцируется?
Мы же его написали
в таком виде.
Сейчас.
Вот, когда ты дойдешь до
если видишь, что b1 value это false,
то ты не делаешь
инстанцирование вот этой конвьюнции.
Почему? А она же написана?
Она же написана. Мы уже упомянули так.
Вот в этом и есть short-circuit instantiation.
Капиллятор умеет
short-circuit instantiation. Точно так же, как
как он догадался?
Так он же в compa-time все вычисляет.
Нет, потому что
он догадался
он догадался, в чем смысл
std-conditional-t?
Слушай, он догадался, в чем смысл.
Ему нужно понять, что такое
что за тип std-conditional-t.
А std-conditional-t устроен так.
Если 1 false,
то значит там
если 2...
У std-conditional-t специализация для true и для false.
Он увидел, что false
и не пошел инстанцировать ту версию,
которая для true.
Потому что он увидел, что
чтобы понять std-conditional-t, ему достаточно
понять, что он специализация std-conditional-t для false.
Он инстанцировал только ее, и ему не пришлось
понимать, что std-conditional-t.
У него же шибонным аргументом было
второе, но он его тоже не инстанцировал.
Короче, он слишком умный.
Ну это, блин, это
логично, что он так умеет.
std-conditional-t это
юзер определенная функция практически
шаблонная. Ну то есть он...
Почему тебя это удивляет?
Это логично, что он...
Потому что обычно, если юзер что-то определил, то он ничего не делает.
Это какая-то мгда циклятора.
Ну, почему бы не?
В смысле, это не общая тенденция.
Это просто компилятор такой сел,
подумал, решил, что вот так можно
сделать. Он никому
не обещал, что он... Нет, в смысле, я хочу
сказать, что это логично, это очень...
Это не должно вас удивить. В смысле,
по сути, это мета-аналог
сокращенных вычтений булевских выражений.
Просто аналог вычтений,
в данном случае инстанции. Пришлось
в компиляторе очень много что поменять, чтобы он
так начал делать. Ну, в смысле...
Да я не думал, что много поменять.
Ну, к компилятору нужно
понять, что такое конжанкшн
от ваших типов. Обычно, если вы видите
упоминания какого-то типа, шаблонного,
но вы инстанцируете. Нет.
Ну,
если у тебя переменный число аргументов,
то ты не... Тебе нужно понять,
что... Тебе пользователь сказал,
сделай мне, пожалуйста, конжанкшн от вот этих.
А там написано,
конжанкшн от вот этих, это
если true, то вот этот тип,
иначе этот тип. Так зачем же компилятору
понимать, каким бы типом это было бы,
если бы там было true?
Это полный аналог, фактически шерцорка
для булевских выражений.
Даже если там false, у него все равно
вторым аргументом передается конжанкшн.
Но он...
Он не будет делать его.
Так как он его не использует, он может понять,
что его можно инстанцировать.
Просто проблема в том, что когда вы писали
другую стиль из Prime, вот эту штуку,
там, если то же самое сделать на ней,
ну так нельзя использовать кондиционом,
потому что там не типы.
Поэтому там приходится просто пользоваться
тернарным оператором. И вот если пользоваться
тернарным оператором, то он инстанцирует...
Да, тернарный оператор он инстанцирует,
потому что тернарный оператор это...
это expression.
Если ты в expression упомянул,
то ему нужно инстанцировать все.
Зачем?
Он же может понять, что первое уже true и все?
Нет, тебе нужно понять, какой тип
expression в любом expression.
Если у тебя тернарный оператор написан,
то тебе нужно проверить,
что он вообще корректен, тебе нужно
раз-раз, ну, инстанцировать.
И второй тип,
и третий тип, чтобы понять,
что это за типы реально.
Ну, типа, что в них.
Тебе нужно развернуть шаблоны и рекурсы полностью,
чтобы expression вычислить.
А это не expression, потому что conditional
T, либо этот тип, либо этот тип,
тебе не нужно понимать, что это за тип второй,
тебе достаточно сразу сказать, что это третий тип.
Ты его не инстанцируешь.
Ну, короче, не знаю, почему тебя это делает,
меня это не удивляет.
Ну, по сути спора нет. У нас просто
один удивляет, а другой не удивляет.
Я не знаю.
Все, блин.
Ну, у нас пара, похоже, закончилась первая часть.
Давайте, значит, видим enable live сейчас.
Ну, давайте маленький перерывчик
и про enable live, про
SFINAE поговорим, значит, вот сейчас
все реализуем, как раз оставшиеся.
Ну, перерывчик сейчас делаем,
пойдем.
Значит, идем SFINAE и enable live.
SFINAE расшифровывается
substitution failure
is not an error.
Substitution failure
is
not
an error.
А ошибка
неудачная
шаблонная постановка
не ошибка компиляции.
Давайте я
продемонстрирую на
простейшем примере.
Пусть у меня есть
какие-нибудь две функции,
я их буду называть full.
Вот у меня есть функция
full,
функция, значит,
full,
которая
принимает
темперсант
и возвращает
такое,
что
она будет выводить
один.
А есть еще функция,
которая
вынимает периметы,
периметы
и просто
выводит два.
Сейчас, а стрелочка
вот эта декл-пайка
стрелочка декл-пайка, ну, это
trailing return type, кажется, я про это
говорил когда-то.
Что вместо авто повторять, короче.
Да.
Ну, типа нельзя
на момент.
Почему-то сейчас нельзя.
Нет, можно, я просто trailing return type
такой написал, имею право.
Можно было вместо этого написать декл-тайп
от t-комщика к икс-фу.
Была проблема, когда мы trailing type.
Ну, давайте я так сделаю, чтобы
просто обычно люди пишут так в конце.
Давайте так напишу.
Вот.
И давайте я теперь из мейна
что-нибудь делаю, вызову.
Вот у меня тут как раз...
А будем возвращать что-нибудь
функции, которые должно возвращать?
Или неважно?
Нет.
А что?
Давайте вот так сделаем.
Что происходит?
декл-тайп от чего?
Это жестоко.
Значит, смотрите.
Давайте попробуем.
Это просто жестоко.
Это плюсы.
Ну, это оператор запятая.
Тихий выражение.
Но
подстановка t в этом выражении
заставит его попробовать сделать
t-комщика к икс-фу. Смотрите.
Давайте попробую вызвать эту функцию
от s.
Так, а мы не должны
дополнительно к икс-фу это запятать?
Нет.
Это же запятая. Зачем?
Это же не fold expression.
А если у нас структура, которую мы речь
произведем?
декл-тайп принимает выражение
expression.
В нем есть оператор запятая.
Вот.
А еще я вызову
фу от int.
Смотрите, если я вызываю
фу от объекта s,
то выводится 1.
А если от int, то выводится 2.
Как же это
произошло?
Ну, что...
Как вообще компилятор выбирает
версию? У него есть два варианта.
У него есть вот эта версия перегрузки
и вот эта версия перегрузки. Перегрузка функции.
Какая предпочтительней?
В обоих случаях
предпочтительней первая.
Если она подходит.
Потому что, ну, пока не если,
просто она предпочтительней по правилам
перегрузки. Потому что она принимает один аргумент,
а та принимает переменное количество
аргументов. Первая лучше.
Ну, дальше начинается интересная.
Ну, давайте рассмотрим сначала первый вызов.
Фу от s. Из двух версий
предпочтительно первая. Компилятор выбирает ее.
И ему
нужно понять, какой возвращаемый тип.
Ну, какой возвращаемый тип?
Он говорит... Ну, давайте
даже без запятой для простоты.
С этой запятой мы потом...
Вот так просто я сделаю.
Ой.
А тут будет ретерн.
Тоже ноль.
Ну, тоже int сделаю. Просто чтобы у них
типы возвращаемые были одинаковыми.
Без запятой пока.
Возвращаемый тип. Ну, он пытается понять,
какой тип выражения. Т, круглые скобочки,
точка х. А это int. Значит,
возвращаемый тип int. Все хорошо. Функция выбирается.
Вызывается. Выводится один.
Возвращается ноль. Теперь второй вызов.
Фу вызывается от int.
Предпочитнее первая версия.
Но
компилятор
приходит к неудачной шаблонной
подстановке, когда пытается подставить сюда int.
Потому что
int, круглые скобочки, точка х
это некорректное выражение.
И тут
срабатывают следующие
правила. Если в момент выбора
версии функции
у компилятора случилась
неудачная шаблонная подстановка,
то он не
делает ошибку в компиляции,
а просто выбрасывает эту функцию из кандидатов
и смотрит среди остальных.
Хорошо.
Важно понять, что
ошибка должна случиться именно
в момент выбора версии. То есть,
если я вот здесь напишу
t, круглые скобочки, точка х,
это будет ce.
Так нельзя.
Будет ce сейчас. Сейчас не будет.
Почему? Он выберет.
Он уже выберет.
Вот если бы я здесь
сделал int,
а t, круглые скобочки, точка х
сделал бы просто int.
Да, казалось бы,
первое слово не подходит, но
оно не подходит на этапе каком-то другом.
Да.
Вот если я так сделаю, то
будет ce, потому что
он уже выбрал ее.
И начал инстанцировать тело.
И если в момент инстанцирования
тела он понял, что t – неудачная
подстановка, то это будет ce.
Но если он понял, что это неудачная
подстановка в момент инстанцирования
самого объявления,
то это будет не ce, это просто
выбрасывание версии
из кандидатов и выбор другой,
менее предпочтительный.
Вот этот принцип называется SFINAE.
Это идиом называется SFINAE, то есть
substitution failure is not an error.
Значит, еще раз, если в момент выбора
версии перегрузки компилятор
неудачно подставляет
t,
и в момент инстанцирования
объявления, понимая, что t
не подходит, он не делает так ce.
Как я думал, именно такие правила?
В чем?
Вот нет, почему, когда
в объявлении ошибка всё про...
всё просто принимается в другую функцию,
а когда в теле ошибка...
всё, выбор закончился.
Почему не продолжить выбор
после этого типа?
Я думаю, что это просто разные стадии компиляции.
Тебе нужно сначала понять,
какие тебе версии и функции надо инстанцировать.
У тебя же там объявление в одном месте, а реализация в другом.
Тоже правда.
А, ну или, например, по Apple.
Да, например, по Apple.
Вот.
Ну, в случае шаблонных функций
кажется,
так оно не должно быть.
Скорее я бы сказал, потому что
сначала компилятор понимает, что ему нужно
инстанцировать, потом инстанцирует.
И наоборот, он типа не инстанцирует тело,
пока не считает, что...
Он же типа не инстанцирует функции, которые ни разу не вызовут.
Ну да.
А, он тебе должен обещать.
Короче...
Какая только в этом есть.
Да, могла бы быть другая абсолютно.
Вот, таким образом мы можем
А...
Например.
Добиться
перегрузки функций по принципу
каких-то compile-time-проверяемых условий.
Стоп.
Какая-то чайная мультика стили, нет?
Ну, можно так сказать.
Мы можем написать
такую функцию
enable-if, метафункцию.
Давайте напишем.
enable-if
значит...
значит bool
b
type-name
t
Бейсик юзач не будет?
enable-if. Чего бейсик юзач?
Вот бейсик юзач.
enable-if-то где?
Сначала я реализую enable-if,
потом покажу использование.
Значит, вот здесь
просто пустое тело.
А вот здесь
template
type-name
это гениально.
t
struct enable-if
это гениально, я согласен.
от true.t
это будет type-identity
от t
Господи.
Смотрите, как теперь это можно использовать.
Вот у меня будет функция bar.
Я хочу сделать следующую перегрузку.
Я хочу, чтобы
если я вызываюсь от
ну, скажем,
floating-point type,
то вызывалась... ну, не floating-point,
это чем-то поинтереснее.
Если я вызываюсь от
ну, от класса.
Вот если у меня
пункт, который я вызываюсь, это из класс.
Мы еще пока не реализовали из класс,
но будем считать, что у нас type-thread такой есть.
Из class or union
мы можем реализовать, сейчас реализуем.
Вот из класс, у нас такой type-thread
есть в библиотеке. Вот смотрите,
я хочу, чтобы функция, если у меня это класс,
то вызывалась одна версия.
Если не класс, то другая.
Я пишу void, ну,
template
template, пока просто не пишу,
void bar
от const c&
и здесь
буду выводить
stdl
чего?
1
ну,
вот так буду говорить.
А если меня вызвали не
от класса,
то...
template type-name
template type-name какой-нибудь
где-нибудь, что-то с.
Да-да-да, template сейчас сделаю.
Значит,
c это будет шаблонный параметр.
Вот, как мне добиться того,
чтобы у меня
секундочку,
я понимаю, что можно написать template класс
c, но ничего не поменяется.
Ничего не поменяется.
То есть в качестве класс inc подойдет
здесь, а здесь нет.
Как мне сделать так, чтобы у меня
в одном случае вызывалась
первая версия, в другом
вторая, если у меня в одном случае
класс, в другом нет.
Я могу сделать, конечно, это с помощью
трюка, ну, я могу сделать, чтобы она
была предпочтительнее другой. То есть, что я
делаю? Я говорю, например,
ну, типа, здесь я скажу, что
у меня еще есть какое-нибудь
переменное количество аргументов.
Ну, это пока плохо.
Я говорю,
я хочу, чтобы первая версия была предпочтительнее,
а вторая нет. Но если первая не получилась
вызвать, так, чтобы это вызвать вторую.
А что мне надо написать, чтобы первая
отваливалась в случае, когда это не
класс? Войдет, ну, что-то
запятая войдет в качестве возвращаемого типа.
Вторым аргументом принять утип
Да!
Давайте я только сделаю
template, значит,
bool b, type name
t,
using enable
if t равно
enable if
от
bsp t 2.2.type
type
type name
еще.
То есть, интересная штука, в большинстве
напишу type name равно
enable if
t
type name по умолчанию. Да, я могу
сказать type name
какой-то, но я не собираюсь
его использовать, поэтому я просто скажу, что он
по умолчанию равен такому, но имя ему не дам.
Вот, enable if
t
что?
из класс в
от c
стд из класс
из класс в
от c
и все.
Запятая еще не нужна.
Вот, запятая не нужна, вот здесь обычно пишут
равно void по умолчанию.
То есть, я могу
в enable if не давать
никакой
тип
ну,
ты можешь хотеть там, если вот эту
штуку там, ты хочешь использовать не в таком
контексте, а в какой-нибудь другом, чтобы действительно у тебя там
enable if тебе какой-то тип
возвращал, но на самом деле обычно
тебе не надо, чтобы enable if возвращал тип, поэтому
здесь я пишу type name t равно void
и
здесь у меня шаблонный аргумент по умолчанию
чтобы это легче парсивалось, я, наверное, тут
как-нибудь вот так сделаю
и вот это будет закрывающая угловая скотка
вот здесь.
Теперь к чему это приведет?
Это приведет к тому, что
ну, вот если я вызову сейчас
бар от s и бар от 1
в одном случае я попаду
в первую версию, то есть
бар от s пытается выбрать
эту, потому что она предпочтительней
и пытается ее инстанцировать объявление
но по умолчанию она подставляет в качестве второго
type name enable if от вот этого
но это же
ну, но это в труб, поэтому все нормально
ничего не отваливается и
я вызываю бар от s
первая версия предпочтительней
потому что?
потому что она принимает один аргумент
а, сейчас она старается принимать, а это запятая триточка
это сично
да
ну и все
если я вызываю бар от 1
то первая отваливается, потому что вот эта
enable if t некорректна
там нет type
вот в этом месте некорректна, там нет type
в этом enable if, который от false
поэтому придется выбрать
вторую, давайте проверим
у меня цени достаточно
он не может выбрать, потому что я не имею
возможно ему
но, сично
вот можно перегрузить
так, сейчас
почему у меня
что?
что-то не то
что?
может фу выкинуть вообще?
55, нет, неинтересно, что сейчас не то
инт лишним
а
да, спасибо
но
это не меняется
окей, давайте здесь сделаем
многоточие args
первый c и потом args
или не важно
ну, args
вот так, просто сделаем
сейчас точно нужно быть нормально
вот
все сработало
ну вообще
вообще
можно и вот так написать
просто здесь я напишу
тут не есть класс
а это будет работать?
должно работать
args убить, пожалуйста
что?
а вообще
его удалить надо
блин, не работает
очень жаль
потому что у него
две функции
с одинаковым набором аргументов, конечно
это плохо
да
у меня
не получился
да
так нехорошо
давайте
возможно здесь есть
более красивый пример
с enabled form
не знаю
красивый ли это пример
да, common mistake
вот я сейчас совершил common mistake
common mistake is to declare two function templates
that differ only in their default template arguments
this does not work
because the declarations are filled with other declarations
да
какой театр
может
сейчас
я поправлю
я сейчас справлю
my common mistake
вот так, что это за синтез?
кому-то что-то присвоили
ну это слова
пускай им название
а, это
это же шаблонный аргумент
у него есть значение
по молчанию true
enabled ft это тоже
блин, блин
сейчас, у меня там тип не тот
мне нужно сделать bool
да
вот
вот так
класс
enabled ft
вот здесь скобка закрылась, равно true вот здесь
да, вот так
все работает
очень так себе
это типа написано как лучший пример использования
enabled ft
не лучший, а базовый
но это классический пример, я бы сказал
классический, а?
можно через концепты
да
два вопроса
почему у нас, вдруг, две круги с
одинаковой сигнатурой теперь хорошо стали
второй вопрос, что значит присвоить
присвоить к какому-то тайку
у них теперь разная сигнатура
enable ft в разных классах
это разный тип
у них сигнатуры одинаковые
но разные шаблонные
аргументы, вот так
почему?
ну то есть у тебя получается
у тебя есть функция
которая принимает
у тебя есть функция, которая принимает
у тебя есть шаблонная функция
у которой два шаблона аргумента
а один, три, а другой
какая-то штука
какая-то
непонятная штука
для каждого конкретного цэ у нас в одном случае
тип bool второй, а в другой тип
никакой
я бы подставлял только одна из двух
никакого смысла
непонятно
Вена, или что мы
это уже знали, или что это что-то новое
вот такой вопрос
какая вообще должна работать смысл?
ну это примерно так же как с перегрузкой функций
вы не можете перегружать обычные функции
лишь по наличию или отсутствию дефолтного аргумента
вот так
то есть смотрите, у вас
две отдельальные функции, у которых у каждого из них
дефолтный аргумент
нет, это не дефолтный аргумент
это обязательный аргумент
это не аргумент
нет, нет, нет
смотри, в одном случае
у тебя функции различаются тем, что
в одной дефолтный аргумент ты подставил такой
а в другой другой
то есть у меня там есть f,
которая int и которая
еще возможно
но глобально enableft
они разворачиваются в одно и то же
а здесь у тебя
шаблонная у тебя функция
у которой обязательны оба
шаблонных аргумента
почему обязательны?
потому что я обязательно
должен использовать второй аргумент
шаблонный аргумент
не обязательный
а у меня
у него есть значение по умолчанию
у кого он был?
это шаблонный аргумент, типа
не типа, а значение
как это, чищенка
можно, пожалуйста, без enableif
написать строчку,
в которой было бы
там был бы type не c, запятая bool
равно true
enableift type
не enableif v
enableift
а bool равно true
там бы только type, это bool
у нас бы
bool, которого мы имя
не назначили
раме умолчания true
не понятно, что значит присвоить
типу и число
почему в одном случае
это считается не однозначностью в другом
нет
ну
какие правила
не знаю
default template argument
for and function template equivalence
я не помню, что такое function template overloading
что именно
а, это
так можно было все это время
overload
2
и сжиг
почему бы и не отсутствовать
и сжиг
и сжиг
разные вещи
разные
ну вот, два выражения
включающие шелонные параметры
эквивалентные
если два определения функции
как все разнообразно
сложно
в общем
ладно, я не
не хочу дальше разбираться
правильно
а так неправильно
это не костыльное
это и есть классическое
стандартное использование
не костыльное, это концепт
вот это нормальное использование
до секретизации 20
вот эта штука
это способ сделать перегрузку
по признаку класса
линии класс
вот, мы научились
сделать перегрузку функции по признаку класса
у нас или не класс. Вот это пример enable.if. Понятно, что я могу по
любому по бизнесу, по любому тайт-трейд, а так делать перегрузку теперь с помощью
enable.if.
Когда ты предлагал enable.if, который между классами запихнуть, ты предлагал именно вот это там написать?
Ну да.
Совершить common mistake, копаться 2 часа, понимать почему.
Нет, я не помню, что я там конкретно предлагал.
Просто, куда ты enable.if напихать, чтобы...
Нет, enable.if напихать, ну вот так я имел в виду. Возможно, я там совершил common mistake и сказал take name равно enable.if.
Да, это было неправильно, надо вот так сделать.
Кто понял? Ну вот, короче, что написано здесь?
Там люди опять чего-то...
Извините, я еще не понятно, чем... то, что мы сейчас написали лучше, чем...
Мне тоже не понятно. На этом мы забыли.
Ну, мы поняли.
Ну, просто по стандарту это работает, а то нет.
Ну типа, таковы правила выбора версии шаблонной перегрузки, что вот это считается разными версиями, а то считаются неоднозначностью.
Там и там просто разница type name равен по умолчанию одному, а другой type name равен по умолчанию другому.
Это считается неоднозначностью.
А так не считается неоднозначностью, никакие правила.
Нет, тут просто формально разные выражения, ими будут p от других аргументов, несмотря на то, что он возвращает тоже bool, но мы же не можем заранее знать, что он вернет bool, поэтому мы просто считаем, что эти выражения не идентичны.
Наверное, p.
Нет, он не вернет bool, он ничего не вернет.
В каждом случае он вернет, в другом ничего не вернет, да.
Ну вот, для любого класса только одна из них вообще может подставиться.
Ну да.
А мы можем также сделать, чтобы какая-то функция у нас была только одна, которая работает только для классов, то есть оставить только первые варианты.
Да, конечно.
А что будет, если вы же у меня от класса, то будет себе другой от версии, нет?
Конечно.
Так.
Зная это, зная принцип, теперь мы можем реализовать остальные type traits, наконец.
Ну, enable if нам уже не потребуется, мы будем просто напрямую все наесть bool.
А может и будем сейчас использовать эти самые.
Вот давайте реализуем, чтобы нам реализовать.
Чтобы нам реализовать.
Давайте я не буду новый пункт начинать, а просто покажу какой-нибудь пример с использованием SFINAE.
Вот, например, как реализована isClass...
Как реализовать isClassForUnion?
А, тут мы не найдем с вами этого, потому что это требует...
Вот давайте попробуем реализовать такой type trait.
TypeNameT struct isClassForUnion.
И нам мы от этого отличаем.
И нам отличаем, да.
Что я хочу сделать?
Ну вот, я хочу, чтобы это было...
Значит, содержало value равное true, если это класс или union, и false иначе.
Вот я утверждаю, что классов union отличить мы средствами языка не сможем.
Это только напилятор может.
Но вот отличить класс или union от чего угодно остального мы сможем.
Нам нужно придумать какое-то такое...
Ну как, я не знаю...
Заклинание, что ли?
Что...
Вот...
Что-то такое сделать надо с типом T, что если бы это был класс или union, то было бы true, иначе false.
Ну, у всех классов union есть destructor.
Ну, у некоторых он приватный.
Да, обычно первая идея ко всем приходящая, это давайте к destructor попробуем обратиться.
Может using?
Using что?
А мы не measures using?
Я говорю на класс.
Мы можем sometime то же самое.
Приватный destructor что-нибудь помню.
Тем не менее, они думают...
Мы даже просматривали ситуацию, если у вас, например, класс, который можно создавать только на куче, а не на стеке.
И destructor приватный вызывать вы можете только по определенной...
Friend?
Да.
Вот.
Значит, какой-нибудь магический слава на тишину, которая запретит приватность.
Какое...
Каким нужно... Какое выражение? Какое expression?
Мы можем наследоваться тентов?
Нет.
Ну, наследоваться может только от класса.
Да, но нужен expression.
Мне нужен какой-то expression, который я подставлю.
Ну, то есть я хочу сейчас сделать что-то в стиле...
Написать какую-нибудь функцию, у которой возвращаем идти, будет декл-тайп какой-то там.
И вот этот expression, включающий в себя тип T, должен быть коррекцией.
Тогда только тогда, когда...
Надо отложить действие от одной.
Пока что ничего умного.
Правильный ответ указателей на члены.
У любого класса есть члены?
У любого класса можно объявить указатели на члены.
И у Юниона тоже.
Ну, просто писать T2.
Я могу написать T2.2.
И когда это класс или Юня, это будет корректным expression.
В смысле, я могу...
Ну да.
Хотя бы не комментария для него.
Хотя бы не комментария для него.
Ну да.
Значит, смотрите.
Мне сейчас надо что-то такое написать вот здесь вот.
Ну, то есть...
Ну, давайте я пока скажу static const bool value.
Хотя, конечно, надо бы унаследоваться от чего-то там.
А равно чему?
Ну вот, что-то...
Ну даже не что-то, просто вот либо true, либо false.
Вот мне надо просто вызвать...
Сейчас мне нужно какую-то сделать...
Ну, функцию с перегрузкой также?
Ну да, функцию с перегрузкой, наверное, надо сделать.
Мне нужно как-то в compile-time понять, какая версия функций вызовется.
Constexpr?
Ну, можно и без constexpr.
Давайте я создам две функции.
Одна из которых будет...
Decltype и пытаться...
Ну, давайте, значит, template typeNameT.
А возвращаемый тип потом напишу.
IsClassOrUnionHelper.
Который ничего не принимает.
Да хотя ладно, пусть она принимает int.
Чем?
Ну, потому что я же буду...
А, ну хотя, сейчас, подождите, да, мне, наверное...
Она ничего не понимает?
Не, не надо, я же и на Ebbool сейчас просто использую.
Правильно?
Нет, не спокой, на Ebbool я использую, мне нужно явно.
Мне нужно, чтобы она была предпочтительней, но при попытке ее выбора...
компилятор бы наткнулся на плохой Decltype.
Хорошо, давайте себе.
Return, здесь я скажу return true.
Сейчас мы поймем, что надо дописать.
А здесь скажу return false.
Как мне добиться того, чтобы она была предпочтительней?
template typeNameU.
Да нет, я просто здесь приму int, а тут приму что угодно.
А, c перегрузка full.
Ну да, так.
А здесь я напишу Decltype...
от...
int t...
звездочка.
Не знаю.
Что, я не знаю, какое-нибудь просто действие.
Это я объявил сейчас указатель на член,
но я могу попробовать объявить указатель на функцию, еще ее вызвать.
Зачем?
Ну, мне нужен expression здесь какой-то.
Испытай bool.
Испытай bool.
Испытай bool.
В втором случае можно просто...
bool круглые скобочки только, потому что это expression должен быть.
А во втором случае просто bool.
Зачем нам двойные скобочки порабить?
Потому что это...
Должен быть expression.
Должен быть вот это указатель на функцию,
которая ничего не принимает.
Возвращает int, ничего не принимает.
Я не уверен, сейчас когда распарсится,
может быть я лучше вот так напишу.
То есть вот так скажу, что это int.
В общем, вот такое выражение напишу.
Да?
Звучит более логично.
А это что, наверное, на члене?
Это указатель на член.
И вызов его пустого конструктора.
То есть создание его по умолчанию.
Ну да.
Запитай a bool,
потому что я хочу, чтобы в итоге тип-то был bool.
А здесь мы пишем что?
Ну просто я говорю, из класса Union Helper...
из класса Union Helper...
От чего?
От t.
От нуля, скажем.
Будет ошибка.
Давайте посмотрим, понятно, что будет какая-то ошибка.
Expected primary expression for int.
Он так не понял.
Сейчас, чего ему не понравилось?
Давайте, наверное,
даже без депутата я это сделаю.
А просто скажу typeName
u равно int
2.2.2.
вот так сделаю.
Наверное, так будет лучше.
А возвращаем и типу.
У них обеих будет bool.
О!
Кажется, вот так.
Сейчас, сейчас.
Все, скомпилировано.
Все, скомпилировалось.
Зачем ему что-то принимать?
Потому что я
здесь вызываю от нуля
и мне
надо, чтобы он хотел пойти в эту
в первую очередь.
А чтобы это было менее предпочтительное.
Что если это класс или union,
то он бы попал сюда и все было бы хорошо.
Вот.
Ну, я добавил шаблонный аргумент
по умолчанию вот такой упадатель на член.
Давайте проверим, что это работает.
Сейчас-то не сработает.
Ну, давайте я...
Понятно, что не сработает.
Но вызов функции при вкупляться...
Да, потому что мы пытаемся сделать
вызов функции в compareTime. Это так нельзя.
Пока что нельзя.
Значит, я сейчас скажу
const
А почему?
Потому что он не инстанцировал пока.
Из classOrUnionW равно
из classOrUnion
от
t2.2.0
Здесь мы просто текст пропишем, а там не можем.
Потому что
формально я еще не
объяснил, да.
Все логично.
Пока еще люди не поняли проблему. Только ты только понял проблему.
Сейчас я продемонстрирую, что будет проблема
из-за того, что мы так написали.
Сейчас мы напишем constexpr
для функций.
Давайте...
Проверь, что?
Можно и без него.
Сейчас я и сниму без него.
Ну, давайте я
выведу
из classOrUnionW
от s
и
из classOrUnionW
от int
Сейчас, скорее всего,
будет ошибка компиляции.
Вот. И именно
понимаете,
или вы в чем ошибка? Кто понимает?
Ну, большинство на этот раз.
Это хорошо.
Потому что я в compile-time заставляю его
сделать function call. Вот здесь.
Вообще говоря, в compile-time
компилятор отказывается делать вызов функций.
Просто сказать value
равно здесь какой-то
compile-time вычтение сделать можно,
но вызов функций — это не compile-time вычтение.
Чтобы его заставить
сделать вызов функций в compile-time,
мне надо функцию пометить как constexpr.
Что?
Что?
Дальше. Какие
ограничения это малорядится? Что мы...
Все, получилось. В одном случае да, в другом нет.
Но я не хочу пока
углубляться в тему того, когда функция
может быть constexpr, когда нет — не любая может быть.
Но я
просто сделаю это
то, как это делалось до
constexpr функции. Я просто
скажу, что здесь возвращаем идти в bool,
а здесь возвращаем идти в int.
И здесь я просто
скажу...
СТД
is same
where
decaltime
decaltime
Измучили, нам не хватало.
bool
Все, мы обошлись без constexpr.
Интересно. Вы молодцы.
Вы смеетесь,
а до C++11 это был аминтак реализован.
Это было лучшее в том, что
можно предложить язык C++.
А почему
мы не могли это
сучение на using поменять?
И всем, кто работает функцией на using.
Сделать using...
Что-то там ровно decaltime, а вы делали функционный.
Ну, здесь вот
template на using, он же тоже может повалиться.
Ты еще так же копируешь.
Где ты предлагаешь using написать?
Вот вместо того, чтобы объявлять
из class or union
как функцию, почему
мы не могли ее using сделать?
Наш фото.
Еще раз, где именно ты хочешь написать using?
Где именно ты хочешь написать using? Я не понимаю.
Ты хочешь из class or union написать using?
Нет, написать using
из class or union фокер равно чему-то.
И чему?
Да неважно.
Неважно.
С Finae работает при перегрузке функций.
Выпускай равно int.
А если вот в первом сжалке
слушай и написать равно в
и тогда мы можем
стандармировать...
А, вот так? Давай попробуем.
Я не уверен, что Finae так сработает.
Не, подожди, а как ты
у тебя будет typeNameT,
typeNameU равно такой, а ты просто
typeNameT, и как ты сделаешь между ними выбор?
У тебя будет
два конфликта. У тебя не бывает же перегрузки
using?
Перегрузки using.
Ну да.
У меня функции с разными сигнатурами, с разными
наборами шаблонных параметров, а если два using
с разными наборами шаблонных параметров, так кажется не должно работать.
Так, понятно
как это работает.
Ну, чтобы не
заниматься вот этим вот,
я обещал, что не буду писать
стандарм с Bluel, я просто скажу, что это
STD...
что?
LulConstant?
Ладно.
Вот такая.
Lul надо оставить,
угловая скобка закрылась.
Зачем
LulConstant, который
кто-то задавал?
Ну, если можно было вместо LulConstant
писать...
Я бы делал еще хуже.
Правильно, у меня все скобочки сходятся,
то есть вот эта скобочка, Bluel,
ну да.
И пустое тело структуры.
А чем LulConstant отличается от LulConstant?
Потому что LulConstant
типа Bluel.
Да, а зачем писать LulConstant
от ESM Wave, а можно как-то писать ESM?
Что написать?
Нет.
А, выточь, да, просто
можно и так, да, это еще проще.
Чего-то мы переговорили.
Лучше писать LulConstant, а просто написать, что это
унаследование STD ESM вот такого.
Да.
Выглядит очень
безобидно.
Берегите наш язык, наш прекрасный язык C++.
Это клад, это
настояние перед нам, наше напишение.
Все?
Вот, ну давайте теперь наконец
реализуем что-нибудь полезное.
А именно, сейчас мы реализуем
compileTime проверку, есть ли метод
в классе.
Ну в принципе и так уже понятно, как это реализовать.
Давайте, значит, это будет пункт 15.3.
compileTime
check
of
methodPresence
в классе.
Когда нам это
надо было? Ну вот, в локатор
trace, да,
hasMethodConstract.
Ты, видимо, лекции в прошлом году смотрел, да?
Просто я это...
Я смотрю раньше, чем его локатеры
изучали. А, я понял. Просто hasMethodConstract
я это называю. Ну да.
Давайте реализуем метафункцию hasMethodConstract.
Это будет что?
Это проверка, имеет ли класс
такой-то метод констракт
от таких-то аргументов,
от таких-то типов. Собственно,
в локатор trace это и написано.
Значит, у нас будет шаблонная структура.
templateTypeNameT
TypeName многоточие
args
Значит, метафункция
hasMethodConstract
Вот.
Что в ней будет?
Ну.
Ну давайте,
что мне надо? Мне нужно
стать aCostBullValue
Ну, которая будет...
Как всегда,
нужно сделать выражение,
в котором мы попросим вызов
метод констракта. Ну, не вызов, а просто
метод того, что мы запитали.
Ну да.
Запитая будет.
И отлично.
Ну, можно сделать опять
hasMethodConstractHelper
Я не буду это прям в структуре.
У меня будет hasMethodConstractHelper
Это, наверное, функция?
Да, это функция.
Которая возвращает
деклтайп
Ну да. Что она делает?
деклтайп
Тут я вот это вот...
Тут можно точно так же делать. TypeName
Но тут, правда, TypeName многоточие
уже есть. Это плохо.
Давайте напишем здесь деклтайп
Вот чего?
t
что?
t это type
Да.
А, да, все правильно.
t2.2.construct
Нет, стоп.
Нельзя. Нужен констракт, даже не статический.
Мне нужен объект типа t.
Так, круглые скобочки
для выточения констракта.
А если круглые скобочки, приватный констракт?
Отличный вопрос.
Это сейчас мы исправим.
Пока давайте считать, что
он есть.
Значит, вот такой мне нужен
примерно.
Syntaxes
zptBool
круглые скобочки.
Так.
А тут bool has met oi.
Это страт.
И англична проблема с args,
но правда args.
У args не было конструкции по умолчанию,
но у t есть определенный констракт.
Все это правильное замечание.
Вы пока еще не...
Сейчас, а что такое args?
Зачем они нам нужны вообще?
Констракт данных аргументов.
А, есть ли у него метод констракта,
понимающий данные аргументы?
Все. А раньше у нас не было проблем с...
А, у нас был только bool.
Все хорошо.
А здесь просто bool.
И опять мы делаем, что
этот хелпер принимает int.
А может быть он не принимал ничего,
а этот принимал три точки?
Первый ничего, второй три точки.
Возможно.
Давайте проверим, наверное, да.
Ну и это будет return true,
а это будет return false.
И констракт спор.
Да, ну и давайте...
Ладно, я не буду все-таки так делать.
И констракт спор давайте напишу здесь,
чтобы он не жаловался,
что я...
вот так.
Так.
За секунду.
Мы сделали
две штуки.
Одна от ничего, вторая от чего.
И давайте теперь я напишу,
что это просто...
А что это такое?
Ну, он должен...
У нас следовался bool constant,
а т.д. констракт, я вот перекручиваю скобочки.
Ну, там конкретными...
Ну, получается так, да.
Давайте у нас следуемся т.д. bool constant.
Она же 17 появилась, да?
А мы могли свои пользоваться.
т.д.
констракт.
Ну, можно было бы без констракт спор
петь через the same.
HasBetConstructHelper
под t запятая arcs
многоточие
с пустыми круглыми скобочками,
угловая скобочка закрылась, пустое тело.
Ага. Так, и через...
Какой у нас был bool из класса UnifB,
а под констракт спора?
Причем еще раз метод включался?
Мы дикто это написали.
Вместо того, чтобы возвращать
bool из функции, мы просто
из функции возвращаем разные типы,
а здесь мы сравниваем, какой тип вернулся.
Здесь я точно
так же мог бы сделать.
Ну, давайте будем считать, что мы понимаем,
что это констэкспорт. Ну, в данном случае
понятно, что это констэкспорт. Вообще
констэкспорт появилась в 2011
плюсах, к слову,
и оно появилось исходно для
функций, т.е. вот это вот слово...
Слово констэкспорт много смысла.
Мы с вами уже видели один из них,
а именно if констэкспорт.
Но это только в 17 появилось.
Исходно констэкспорт появилось именно для функций,
именно вот для такой ситуации.
И ограничение на функции было,
что они могут состоять только
из одного return и все.
Вот в C++11
ограничение на констэкспорт функций
было таким. Просто нужно быть
return сразу же, не быть этой в большей действии.
Если функция что-то кроме return содержит,
то это CE. Дальше эти ограничения
ослаблялись вплоть до того,
что констэкспорт Vector можно создавать
в C++20, потому что констэкспорт
Properator.New появился. Но
это мы покозже обсудим, а пока...
А, еще появились...
Констэкспорт Properator.New это не самое смешное.
Были констэкспорт циклы?
Это понятно. Констэкспорт циклы уже давно были.
Это нормально.
Появился констэкспорт полиморфизм
и констэкспорт динамик кастом.
Я вам покажу пример
с констэкспорт динамик кастом.
Это самое смешное, если за последний год.
Я просто ржал голос
когда мне лекцию про это рассказывали,
но это мы через пару недель
обсудим.
Вот сейчас
только так используем.
Так вот.
Какая у нас проблема?
Круглые скобочки.
Ну давайте
сначала проверим, что это работает.
Давайте какую-нибудь структуру заведу, не знаю...
Не знаю...
Эмпти.
Тест.
Сейчас я...
Давайте проверим, что
у меня
в тесте есть метод констракта
от двух интов, скажем.
И нет метода кон...
Вот есть метод констракта от двух интов,
есть метод констракта от трех интов.
Не знаю, от int, double, int.
Но нет метода от одного инта.
Ну ладно, от двух интов, от трех интов, но нет от одного.
Причем у них будут разных типов
возвращенных, это не важно.
Вот давайте проверим, что...
И констракт от int...
А, значит, проверяю, hes... Ну, hes-метод-констракт В еще, конечно, надо.
Господи, ладно.
hes-метод-констракт В равно... это какой-то статистический букл?
hes-метод-констракт В это...
hes-метод-констракт?
hes-метод-констракт
Да, у нас T маленький, кстати, да.
Как это произошло?
Что я сделал?
Капс не нажал.
Нет, я же вроде... ладно, ладно.
hes-метод-констракт, вот T, запытаю, arts...
value
Давайте проверим, что hes-метод-констракт от тест-инт-инт,
hes-метод-констракт В, тест-инт...
Но нет hes-метод-констракт от...
Ладно. Нет, нет, нет hes-метод-констракт...
Ну, есть hes-метод-констракт от двух интов, есть hes-метод-констракт от трех интов.
У меня плохие новости. Call is ambiguous, то есть так нельзя в перегрузках.
Сейчас выпаиваю логик. Не привыкать, не переводить, говорится.
А, мы перегрузки... ну, там ими можно принять.
Да, да.
А, то есть твоя идея... это же ты сам и предложил.
Все, завалили.
А, сейчас. А может, не в эту проблему?
То есть перегрузка, по принципу, нет аргументов или что угодно принято, не работает?
Не, у тебя же не в эту проблему есть.
Так, сейчас, короче, давайте я протестирую.
Call is ambiguous, потому что у него есть версия...
Ну, давайте сделаем, давайте проверим, если здесь добавить инт.
А здесь добавить... а здесь... да, и здесь я буду вызывать... вот инта получается.
От нуля.
От нуля.
Все, работает. Ну, значит, такая перегрузка, все-таки, не разрешена.
Ну, все, работает.
Помогу на вопрос, хотим ли мы распознавать приватные...
Я думаю, что это будет вопрос на какой-нибудь вход на экзамен, на такой курсе.
Раньше это было вопросом на отм, но я думаю, что пора повышать форму.
Ты послушаешь несколько... давай, короче, на экзамене можно менять... повышать оценку постфактом.
Потому что первые несколько людей, которые очень сильно обосрутся,
и ты еще будешь считать, что они просто тупые, а не весь поток такой.
Они получат низкую оценку, а остальные, когда ты уже посмиришься с ним, что все тупые,
и начнешь с него все выше и выше стоять, можешь потом первым, если менять,
каким-нибудь оценку поднять обратно.
Вот до этого и нужен письменный экзамен.
А, точно, все, письменный экзамен будет. Все, все, отлично.
Потому что на усном есть еще и такая проблема, что твои ожидания от людей меняются
по мере того, как новые люди, прикольно.
Поэтому, кстати, когда на экзамен запускают сначала людей с высокими результатами семестра,
а потом с низкими, то для последних это более плохие новости, чем когда запускают наоборот.
Ну да, для первых сложных, для всех.
Да, для всех, да.
Но запускать наоборот было бы как-то совсем халяво.
Ладно.
Так вот, вопрос главный, не главный.
Вопрос, хотим ли мы уметь распознавать приватный конструктор?
Да.
Все.
А можем ли мы, а можем ли мы можем сделать ремни, шаблонные?
Сейчас, мы не можем сейчас тем, что у каждого из элементов ARX есть конструктор по умолчанию.
Да, да, значит, у этой реализации есть одна фундаментальная проблема.
Ни ты, ни ARX, вообще говоря, не обязаны иметь конструктор по умолчанию.
Ага.
Или они могут его иметь, но он приватный.
И вся эта конструкция перестанет работать, ну, для локатора.
Ну, где собираемся? В локатор трейдс.
Это важно, потому что если у какого-то из ARX нет конструктора по умолчанию,
это все отвалится, но не по причине, что методоконстракт не было,
а по причине, что вот в этом выражении он ARX не смог сконструировать по умолчанию.
Что же делать?
Нужно как-то научиться конструировать, когда мы вообще не знаем, есть у меня хоть один конструктор.
А кто-нибудь знает? Ты знаешь решение?
У меня есть идея, но очень странная.
Ты просто если смотрел лекции прошлых лет, то может ты знаешь.
Я их смотрю домой, я их смотрю, когда хотела взять матрицы, и мне там...
А, понятно.
У меня есть очень странная идея.
Ну, вот мы хотим когда-то получить объект нашего типа, из ничего.
Да.
Ринтерпрет кастом, каким-нибудь.
В смысле.
А из чего ты подумаешь?
Да хоть из ЛПТР.
В принципе, можно.
То есть ты говоришь, Ринтерпрет кастом.
Каркс.
Каркс.
Нет, Каркс.
Каркс звездочка, и потом еще звездочка.
Звездочка.
Может еще...
Без X и плюс-плюс не исчерпаем.
И все обогащается с быстротой поражающей.
Ну, вроде так...
Проверим.
Вроде так должно работать.
Это ужасно.
Это работает.
Но это не очень хорошее решение.
Мы сами понимаем, почему.
Нет.
Оно менее костылем, чем все, что мы писали до этого.
Ну вот а что с Т делать?
То же самое.
То же самое?
Ну да.
Просто тут знаете, какая проблема есть?
Тут есть еще проблема с value.
С видом value.
С каким?
Какого value?
Мы сейчас получили L-value, типа ARKS.
Если мы так сделаем с Т, у нас будет L-value типа T.
А мы хотим...
R-value.
Вот.
А мы хотим, чтобы...
Мы хотим скорее R-value.
Чтобы у нас есть...
Чтобы если у нас был констракт от R-value, мы его тоже распознали.
Ну то есть, вдруг у нас конструктор мог принимать констракт, что...
Сейчас, сейчас, сейчас.
Вот этот рибер-пидкаст нам что отдал?
L-value.
Этот рибер-пидкаст дал pointer.
Но мы разаменовали pointer.
Разаменование pointer дает нам L-value.
Ну, можно вообще...
Можно, да.
Что?
Мне очень нравится мой предмет тем, что наверняка это единственный предмет,
на котором просто на последних...
В апрель-май это каждая вторая лекция.
Это люди просто время прям держат в голове.
Мне кажется, в других предметах такого нет.
Я очень горжусь.
В общем, нас...
Да.
В таком-то смысле, да.
В замечении такое весело.
Я покажу вам, что придумал комитет для решения этих проблем.
Я думаю, сейчас вы посмеетесь еще сильнее.
Смотрите, нам нужна просто какая-то конструкция,
ну, просто не хочется построиться от ринтер-пидкаста.
Наверное, так можно было бы, то есть всегда лепить ринтер-пидкаст,
но на самом деле есть...
А если напишем фигурные скобочки, что будет?
Тоже самое.
Тоже самое, да?
Можно просто...
Ну, есть примитив метапрограммирования, еще один,
который позволяет просто по типу T получить объект типа T.
Стаб иногда бывает нужно по типу T для вот таких контекстов,
для Anomaly Edited Context.
Это же Anomaly Edited Context.
Мы под декл-тайпом находимся.
Он не будет реально создавать объект типа T.
Ему нужно просто некоторые выражения типа T подставить, имея тип T.
Ну да.
Для этого в стандартной библиотеке существует функция,
которая называется DECLVAL.
А можно же ее сделать через ринтер-пидкаст и больше не мучиться?
Смотрите.
DECLVAL.
Что она делает?
Она имеет следующий синдекс использования.
DECLVAL с шаблонным параметром T, пустые скобочки.
Ой, шаблонный параметр MAX.
И здесь я пишу DECLVAL с шаблонным параметром T, пустые скобочки.
Это выражение, это функция, которая просто возвращает T.
И ничего не принимает.
Это будет R-value.
Но если я ему бы сказал так, это было бы L-value.
Но я могу ему сказать, понятно, сколько амперсантов я доведу.
То есть она возвращает тип...
Ну, какой надо.
Вот.
Вопрос.
А что на самом деле, как она реализована?
Ответ.
Никак.
Все.
Ей не нужна реализация, потому что она никогда не должна вызываться.
Но ее не может быть реализована.
Ну, вероятно, можно с интерпрет-кастом намутить то, что вы там придумали.
Ну, наверное, это...
Я не знаю, может быть, кстати, это действительно бы ракомпилировалось во всех случаях.
Нам нужна реализация DECLVAL.
А если 40, 50, 100 константов не нужно, потому что DECLTYPE...
Вот DECLTYPE не нужно даже.
Я не вызываю константов.
А разве факт в том, что...
Нет.
Не вызываю.
Это ангелы от конкурса.
Я не смотрю тип выражения, который получится, если бы ее вызвали.
Но я не собираюсь ее вызывать.
Нормально, да.
Классно.
Почему она называется DECLVAL?
Ну, это value, который используется DECLTYPE.
Не знаю.
Потому что это в каком-то смысле противоположность DECLTYPE.
Это операция обратная DECLTYPE.
У вас DECLTYPE по выражению говорит, какой у него тип.
А DECLVAL, наоборот, по типу дает вам выражение какого-то такого типа.
DECLVAL и DECLTYPE это взаимно обратные в каком-то смысле операции.
DECLTYPE вам дает из типа и значение тип.
DECLVAL вам из типа дает значение.
DECLTYPE от DECLVAL от T это T.
Ну, да.
DECLVAL это функция, а DECLTYPE это метафункция.
На него реально работает.
Хорошо, вопрос такой.
Если у нас есть констракт...
Два вопроса.
У нас у констракта могут быть, во-первых, value, что-то там справа.
Во-вторых, может быть const qualifier.
В-третьих, может быть volatile qualifier.
Я сейчас вызвал констракт от R-value.
Да.
Любой из твоих вариантов...
Ну, только если...
Нет, нет, нет.
У ARKS все нормально, все понятно.
Типа ты хочешь спросить, что если у меня...
У меня в констракт обязательно...
Что распознает эта функция сейчас?
Я даю R-value.
Вот я сейчас пытаюсь от R-value типа T вызвать констракт,
и издав туда R-value типа в ARKS.
То есть, если бы у меня был L-value qualifier...
Ну, давай я просто тебе...
Вот я сейчас L-value qualifier здесь поставлю,
и мы увидим, что ноль будет пристрелиться.
Во, да, окей.
То есть, мы сейчас распознаем.
Если нет...
Все.
Все, ну, логично.
Все понятно, в смысле.
А хотим ли мы так?
Или нет?
Нет.
Ну...
Ну...
Можно еще одну версию написать?
В смысле?
Чтобы идти и те распознавать?
Ну, да.
Ну, это разная штука просто, да, поэтому...
Пока.
Ммм...
Вот, можно здесь...
Можно вот так сделать.
Тогда это будет распознаваться.
Но мы должны выбрать, по сути, что с этим, как распознать.
Я вот здесь имперсан поставлю.
Да, да, да.
я вот здесь имперсант поставил, понятно что теперь это стало L-value и поэтому
теперь это распознает. Да, но теперь если L-value-coolifier написать, то обратное
программное. Да, конечно. Вот сейчас я вас немножечко еще удивлю, вероятно. Но вообще, если мы
проверяем только наличие, сейчас. Мы сейчас не умеем проверять просто наличие.
Ну по сути она спрашивает, если бы у меня был объект такого типа, был бы у меня такой метод, вот он тебе ответит.
Да, он правильно ответит. Сейчас я вас немножечко удивлю. Давайте посмотрим на DecalVal.
Внимательно. Вы можете заметить, что сигнатура не совсем такая, как я сказал.
Adderley Reference. Вопрос. Зачем? Обычно нужно. Почему DecalVal на самом деле
возвращает не, во-первых, но Accept. Это очень важно, кстати. Почему? А разве? Да. Вы поймете почему.
Мы же не вызываем ее. Давайте, ладно. Сейчас вызовем. Ладно, DecalVal берем на Accept.
Почему Adderley Reference, а не просто T? Потому что мы не можем просто так взять T и добавить два амперсанда.
Зачем вообще добавлять два амперсанда? Сейчас, пусть нам дали тип T, в смысле вот мы хотим
здесь использовать, сейчас. Пусть мы хотим использовать HasMethodConstruct. Да. И нам отдали в качестве
шаблонного аргумента T двойной амперсант. А FTD Adderley Reference не просто добавит два амперсанда,
а сделает ровно два амперсанда. Я спрашиваю, почему у нас Adderley Reference вместо двух амперсанда?
Зачем вообще добавлять амперсанды? Более того, что ты не можешь это сделать руками. Зачем? Почему мы
возвращаем T двойной амперсант, а не просто T? Снять проще, чем навесить. Сейчас. Чего? Нет, у нас
возможно там правило того, какой тип выражения. Вот этот пункт с углоскопочкой, он же, кажется, немножко и так определяется просто.
Сейчас, я не помню, есть ли здесь ответ.
Не помню, есть ли ответ у нас. Во, вот этот вопрос.
Ну, потому что, потому что, если бы мы возвращали чисто T, то ему бы приходилось, ну, вот вам пример, когда это бы не сработало.
У вас существует так называемое понятие incomplete type в стандарте. Это тип,
либо у которого тело, это либо класс, который объявлен, но не определен, либо это, например,
класс, у которого деструктор приватный. Нет, у него не определен деструктор, он не объявлен, но не определен. А еще он приватный.
Он написан в комментариях, ошибка inaccessible destructor. Inaccessible, это значит он приватный. Недоступный, недоступный, значит приватный. Вот.
Спасибо. Следующие типы incomplete. А, нет, виноват. Значит, класс приватным деструктором не считается incomplete.
Ну, вот эти типы считаются incomplete. Короче, что меняет, что я возвращаю T, а не T2? Если бы я попытался, например,
для такого класса попробовать сделать Decal Perval, это было бы CE. Потому что, чтобы компилятору,
ну, чтобы корректным было выражение, чтобы вернуть ссылку на что-то, не нужно, чтобы это что-то
можно было бы создать. А чтобы вернуть сам этот тип, нужно еще, например, проверить, что деструктор не приватный,
или что у него вообще есть определение. Вы можете вернуть RLU ссылку на T, ну, то есть возвращение RLU ссылки на T
не приводит к Compiled-up Error'у в аналогической контексте, если объект типа T нельзя создать в принципе.
А возвращение объекта типа T привело бы к CE, потому что, ну, например, если бы у него был приватный деструктор,
то нельзя было бы вообще вызывать функцию, которая возвращает T. Само возвращение T, потенциальное, приводило бы к CE.
Вот вам пример с приватным деструктором, вот вам пример с классом, который объявлен неопределен.
Вот, еще интересный момент. А если бы T был каким-то шаблонным классом, то возвращение T
не заставлял бы компилятор инстанцировать этот шаблонный класс. А если вы возвращаете прям T,
то компилятор пытается понять, что это такое, он мог начать выинстанцировать.
Вот, поэтому здесь возвращается T-двойной амперсант.
А почему там это...
Это следующий хороший вопрос, сейчас поймем.
А мне что? А не T-двойной амперсант?
Сейчас, смотрите. Давайте сначала, почему двойной, а не одинарный?
Потому что одинарный всегда выдавал L-value, а двойной никогда не портит категорию значения.
То есть, если я здесь пишу с одинарным амперсантом, то мне и возвращается одинарный амперсант.
А если я пишу T без амперсантов или с двойным амперсантом, то мне двойной и вернется.
То есть, категория value никогда не испортится от того, что я возвращаю двойной амперсант.
Просто я в случаях, когда у меня был приватный деструктор или неопределенный класс,
сумел бы его тоже здесь использовать.
Почему adder value reference...
А, потому что константность, если есть.
Почему adder value reference, а не просто T-двойной амперсант?
Потому что если бы это был void, то навешивание бы двойного амперсанта на void выдавало бы CE.
Но здесь написано, the return type is T-двойной амперсант, unless T is posted to CV-qualified void,
in which case the return type is T.
Condition void?
Ну да.
Не трогай меня, астроту.
Вот.
Потому что...
Ну вот еще такое adder value reference.
Если T...
Бла-бла-бла-бла-бла-бла...
Ну короче, если...
Ну, написано в ноуте, как раз, про то, что...
Смогли.
Adder value reference. Это double-type detail try adder value reference.
От нуля.
Try adder value reference.
Это, значит, либо такая штука...
Ну, опять с финагея.
Смотрите, что такое adder value reference.
Это...
Try adder value reference.
От нуля.
Try adder value reference. Это функция...
Без дела.
У которой есть перегрузка от intitle, от чего угодно.
Она пытается добавить adder value reference.
И если получается, то, значит, такой типы есть.
А если не получается, например, это был void,
то, значит, это просто void и остается.
Вот и все.
Вот вам применение с финагея в очередной раз.
Type identity.
Почему их четыре? Трое?
Потому что там LL еще есть.
Так, ну все. Кажется, мы справились.
Оно можно, наверное, adder value reference.
Т.
Ну да.
Капитанчик.
Так, ну еще. Попробуем реализовать, например, из constructible быстренько.
Из constructible, из copy constructible, из move constructible.
Вообще, конечно, в идеале нам реализовать из no from move constructible и move no accept еще.
Но давайте реализуем из constructible.
Как устроим...
Из constructible.
T, args.
Что это такое?
Например, до того, существует ли конструктор...
По умолчанию?
Нет, от args.
То же самое.
Он даже проще.
Ну, в принципе, можно сказать, упражнение это слушать.
Или то же самое, например.
Да, то же самое. Ничего интересного.
Ну просто я проверяю вот здесь.
Все то же самое абсолютно.
Просто здесь я напишу...
Я попытаюсь decalval T.
Круглые скобочки.
Круглые скобочки.
Нет, не так.
Я здесь без decalval.
Круглые скобочки от decalval от args.
Вот и все.
Все остальное абсолютно то же самое.
Даже не хочу реализовывать.
То же самое.
Ну, какая разница?
Нет, я помню, что я угадал.
Если он только T, то угадал.
А как такое может быть?
Если у тебя есть конструктор от T и T2S.
А как он вообще должен выбирать?
Если у тебя есть конструктор от T и T2S,
то это ambiguous call.
Ты не можешь делать перегрузку
по значению или по ссылке.
Ты можешь перегрузку делать по разным видам ссылок,
но не перегрузку по значению или по ссылке.
А вот это не используется как раз.
Да.
Ладно?
Да.
Короче, давайте считать, что мы поняли,
как реализовывается конструкция.
Просто объекты, это все одно и то же.
А что ж там?
Ну, из constructible...
Ну, тут еще есть test-privilege-constructible
и no-fro-constructible.
Вот я сейчас хочу реализовывать...
Блин, я не знаю, может все-таки я это скопил.
Давайте я, наверное,
вот сейчас скопипашу
и скажу просто, что мы
вот это вот все я копирую
и говорю...
Просто заменяю здесь
heads-method-construct, везде на is-constructible.
На is-constructible.
Что?
heads-method-construct.
Неужели я опечатываюся?
В смысле?
Так, еще раз.
А, потому что надо сказать s же.
Вот. И здесь просто я пишу
не 2 колвала t, а просто пишу t...
Да, приятно.
Ну и все.
Просто is-constructible.
Еще интересно.
Теперь, как определить
is-copy-constructible и is-move-constructible?
Правда ли, что
тип копируемый
как-то определить?
Темплей type-name-t, ну давайте я
просто здесь вот так вот
эту часть копирую.
Значит, что такое
copy-constructible?
Мне уже не нужно args вот здесь.
is-copy-constructible.
Так, у вас следующая пара есть,
а то у вас уже, наверное, пускать надо.
А, ну все тогда, сейчас.
А, блин, уже все, у меня пора заканчивать.
Жаль.
Видимо, move-move-move-accept мы не успели реализовать.
Ну ладно.
Is-copy-constructible.
Что мне надо написать?
Ну это просто
is-constructible, причем я даже думаю, что
это уже
is-copy-constructible.
Is-constructible
от
te-
const-em-percent.
Type-name
нет. Все, я просто сказал, что это точно
такой тип. Is-copy-constructible
это вообще-то
та, что
ну да, это тип.
А te
is-copy-constructible
v это просто будет
все то же самое, просто is-copy-constructible.
Ну is-move-constructible
то же самое, только с двумя персами.
То есть, формально вот,
который
в общем и тихо направлял
с тем
template, конструктором копии,
и формально здесь же ответ
да будет copy-constructible,
хотя, ну здесь
непонятно.
Проблема была в том, что
copy-constructible
был
нет. Ответ
вопрос, можно ли
является ли тип копируемым?
Если вызвать тест, попробовать создать
от const-em-percent, это будет работать?
Да. Как это будет работать?
Непонятно, но
а если вот, типа копируемый
у него нет?
А если именно, если copy-constructible
не пересекнуть delete,
надо оставить template.
Скорее всего, он будет работать как надо
в таком случае. Нет, это нет.
Будет false, конечно.
Конечно, ты же выбираешь
версию перегрузки и видишь,
что она delete.
В этом именно и смысл.
Ну is-move-constructible
тоже понятно.
Вот, нам
видимо, так придется
закончить сейчас, ну значит завтра
продолжим. Мы хотим реализовать
move-of-no-except.
Но нужно придумать... move-of-no-except
это функция, которая должна возвращать
lvalue, если
там тип был no-from-move-constructible.
Наоборот, она должна move-ить,
если это был no-from-move-constructible.
И
не move-ать, если это был не no-from-move-constructible.
Нужно уметь проверять qualifier
no-except. У нас есть
no-except, есть копочка выражения
У нас есть оператор no-except.
Ну вот, короче...
Вроде это звучит не очень сложно.
Да, это не очень сложно, но там
есть над чем подумать.
Ну минут за 10 мы будем реализовали
и обсудили, но уже
я не буду задерживать, поэтому давайте закончим.
