Мы продолжаем говорить про суевкисный автомат.
Давайте напомним, на чем мы остановились.
Мы остановились на том, что если есть произвольная
вершина, то множество ребер в нее входящих обязательно
имеют написанную одну и ту же буковку, допустим,
С.
На всех ребрах, входящих в какую-то конкретную вершину,
на одну и ту же букву, а также вершины начала этих
ребер, они являются, в общем, они лежат на одном пути
по суевиксным ссылкам, то есть если мы рассмотрим
на них самую длинную с максимальным лен и будем
брать многократно суевиксную ссылку, то мы целиком этот
весь путь как раз покроем все множество вершин, из
которых есть ребров В, в произвольную фиксированную
вершину В.
Это мы доказали в прошлый раз.
И теперь нам надо, зная все вот это вот безобразие,
нам нужно построить алгоритм, напоминаю, как он у нас был
устроен.
У нас был суфиксный автомат для строки С, и мы инкрементально
по одному символу расширяем нашу строчку, дописываем
новые и новые символы, там С, Д и так далее.
Идем просто по строке и дописываем их по одному
и перестраиваем автомат из старого в новый.
Что мы еще установили?
Мы установили, что у нас будет новых максимум два
состояния, у нас обязательно появляется вершина, отвечающая
классу СС, ну потому что это новая строка, которой
не было, теперь она появилась, для нее нужно обязательно
И мы также охарактеризовали весь этот класс, значит,
это все суффиксы СС, которые не являлись под строками
С.
Не являлись под строками С.
То есть у нас обязательно появляется новое состояние,
это как бы всем новым подстрочкам.
Все, что раньше не являлось под строками С, а теперь
после дописания очередного символа стало под строкой
СС, ну под строки СС новые это только обязательно
суффиксы, у нас никаких подстрок не возникло.
Значит, здесь в этом классе лежат в точности все суффиксы,
которые раньше не присутствовали, а вот теперь появились.
То есть это СС и несколько его самых длинных суффиксов,
которых раньше никогда не было, раньше в С не встречались.
Вот, и у нас есть еще второй кандидат на новое состояние,
я его обзывал Т, но давайте вот ведем, обозначим через
С0 самый длинный суффикс строки СС, являющийся под
строкой С.
И в прошлый раз мы доказали, что если появляется хотя
бы еще какой-то класс, если есть что-то новое, если есть
еще новое состояние, то обязательно С0 это лонгис
в этом классе.
Если какой-то еще класс появляется, появляется,
то С0 это лонгест в нем, это было у нас в прошлый раз.
То есть мы там, я там говорил, пусть кроме этого класса
есть, появляется еще какой-то новый, в нем Т, строка Т это
лонгест, тогда она обязательно удовлетворяет такому условию.
Поэтому если я сейчас через С0 определю вот ту самую
строчку, самый длинный суффикс, который раньше встречался,
то если вот это вот Т и появляется в качестве нового лонгеста,
то она обязательно равна С0.
Но, возможно, Т не появляется, потому что, возможно, больше
вообще нет никакого класса нового, кроме вот этого,
потому я как бы за С0 обозначаю строчку, а Т это вот новый
лонгест, и если он есть, то он обязательно равен С0.
Так, ну тогда смотрите, давайте мы разберемся вот с этим
классом, что здесь происходит.
Плюс к тому же мы уже знаем, как устроены все ребра ведущие
в это самое С.
То есть мы знаем, пусть у нас был какой-то суффиксный
автомат для строки С, автомат для С.
Мы понимаем, что обязательно должно появиться новое
состояние, отвечающее строке СС, и вести в нее должны
все стрелочки, значит, в нее нужно нарисовать ребра
из вершин, лежащих на суффиксном пути, на пути по суффссылкам,
и на всех этих ребрах должен быть написано вот тот самый
символ С, потому что этот символ указывает на то,
какой символ мы приписываем в самом конце.
Поэтому из каких-то вершин, вот здесь вот нужно нарисовать
такой переход по буквке С, вопрос, что это за вершины.
Вот это, например, какая вершина?
Да, просто самая длинная строка, из которой после
дописывания С мы попадаем в новый класс СС, ну конечно,
это С.
Но вот строка С раньше лежала в автомате для строки
С, в частности для нее гарантированно появляется такой переход
из СВС, ну, точнее, из класса, отвечающего С, в класс, отвечающий
СС.
Ну и значит, здесь мы должны несколько раз взять суффиксную
ссылку и провести все вот такие вот ребра по букве
С.
Надо понять, сколько раз их нужно взять.
Значит, самый простой случай.
Давайте мы возьмем в этом автомате строчку С, будем
брать от нее суффссылку, и предположим, что вот мы
берем-берем-берем суффссылку, и из всех вершин на этом
пути ни разу не было ни одного ребра по букве С.
То есть, я вот беру суффссылки многократно, я понимаю,
что из них должны быть ребра, из этих вершин должны быть
ребра по букве С в нашу новую вершинку.
И вот пусть ни за одной из них не было перехода
по С.
Так, как бы я это обозначил.
Ну давайте я прям сразу псевдокод напишу, пусть
П это класс, отвечающий строке С.
Значит, дальше пока П не минус единица, и из П нет
перехода по букве С.
Мы этот переход заводим.
Ну я вот так напишу, что если П это текущая вершинка
на этом пути, и из нее раньше не было перехода по С, то
теперь я его насильно добавляю, говорю, что отсюда есть
переход в С.
И перехожу по суффссылке.
П равно линк от П.
Вот, и в случае, если у меня этот вайл заканчивается
кейсом П равно единице, то есть П равно единице это
когда я поднимаюсь, ну вот так вот, спускаюсь по суффссылкам
вплоть до корня, и потом пытаюсь взять суффссылку
у корня.
Потому что только у корня у меня суффссылка вот такая
П равна минус единице, потому что у корня ничего нельзя
отрезать, чтобы получить из-под строка.
Поэтому у корня суффссылка как бы не определена, и
тогда оно закончится в П равно минус единице.
То есть если П равно минус единице, то это как раз случай,
когда из всех вершин не было ни одного перехода по
С.
Тогда я утверждаю, что в этом случае нужно просто
сделать, назначить суффссылку от СС вот сюда вот.
Напишу так, линк от СС равно root, то есть суффссылка будет
вести вот сюда.
И на этом обработка закончится.
Давайте я напишу там что-нибудь типа return.
И так, я утверждаю следующее, что если у меня был автомат
для строки С с таким свойством, что если я беру и прыгаю по
суффссылкам от С вплоть до корня, и из всех этих
вершин не было перехода по С, то для того чтобы перестроить
автомат с появлением новой строки СС, ну точнее с добавлением
нового символа вот этого вот, мне нужно просто из
всех вершин на этом суффиксном пути добавить с перехода
по С, ну а также назначить, что суффссылка отсюда ведет
в корень.
И на этом перестройка автомата закончится.
В частности, вот не будет этого нового состояния Т.
Так, ну начальная вершина автомата.
Да, спасибо, это я не вводил, давайте я это запишу, корень
это стартовая вершина автомата, собственно то откуда мы все
слова читаем.
Вершина автомата, то есть Q0, да, да, ну например так,
или так же как у нас было в Боре, например, мы храним
мапу, не вектор, а мапу, для каждого символа, если
есть переход, то куда он ведет, если нет, то у нас
нет такого ключа в мапе просто, то есть это можно
и как вектор, и как мапу.
Тут как раз набор переходов, это для каждой вершины
и для каждого символа мы храним, куда есть переход.
Ну да, да, да, только с такой помеченной, с пометочками
на ребрах, с буквами.
Ну да, то есть тут как бы нужно еще класс написать,
иметь в виду вот именно та вершина, которая соответствует
строке СС.
Итак, почему-то верно, значит, я утверждаю, что характеризация
такого кейса, это когда, значит, это происходит, это
происходит ровно в том случае, когда символ С, символ
С не встречался в С, не встречался в С, значит, вот эта картинка
соответствует случаю, когда С вообще впервые у нас
появился в нашей строке.
Его раньше нигде не было, в С его не было, и только
после приписа у него впервые стрейтлс.
Ну, собственно, это более-менее понятно, потому что раз у
нас даже из корня нет перехода по букве С, собственно, раньше
его нигде быть не могло, в строке С он не мог встречаться,
потому что, ну, как минимум, если у нас был корректный
автомат для строки С, то из корня уж точно должны
были быть переходы по всем буквам, потому что все
это как бы начальные символы каких-то суффиксов, поэтому
точно из корня можно прощать любой символ, встречающийся
в строке.
А если его раньше здесь не было, то, соответственно,
его и, ну да, если его здесь не было, то, значит, его
и во всей строке тоже не было.
Вот, ну и в этом случае, конечно же, не просто из
корня его не будет, а его вообще нигде не будет.
Так, ну окей, значит, сейчас, надо, наверное, как-то по
формане наказать.
Давайте слева направо, да, слева направо.
Если мы так пропрыгали и даже из корня нашли символ
С, то, значит, конечно, его нельзя прочитать.
Значит, если даже из корня нет перехода по С, то С не
встречался в С, это очевидно, потому что из корня точно
можно прощать все символы строки.
Значит, обратно, если он не встречался, то, конечно,
перехода по символу С вообще нигде нет, поэтому, если
я буду прыгать по сувсылкам начиная с С, то я всюду
не найду такого перехода и из корня тоже не найду.
То есть я весь этот путь проскочу, здесь не найду
ни одного перехода, закончу, когда П будет равно минус
единиц.
Значит, право-налево то же самое, если С нет в С,
то в автомате нет ни одного перехода помещенного
буквой С в автомате, нет ни одного перехода, помещенного
символом С, значит, вот такой вот проход по сувсылкам
закончится в корне и даже от корня попробую взять
сувсылки.
Значит, в конце будет П равно минус единицы.
То есть я прыгаю-прыгаю-прыгаю по сувсылкам в поисках перехода
по С и нигде не нахожу, тогда вот как раз, когда мы дойдем
до корня, мы возьмем сувсылку, сувсылка ведет в пективную
вершину минус один, мы как бы считаем, что у корня
сувсылка минус единица, ну и вот как раз ровно это
случай происходит.
Вот, ну а в этом случае нужно поступать ровно так, как
я здесь нарисовал, потому что, смотрите, какие мне
вообще нужны переходы.
В СС у меня содержатся все суффиксы, которые впервые
встретились, но если характеризация этого кейса – это когда
у меня С впервые вообще появился в строке, то здесь
находятся вообще все суффиксы, кроме пустого, здесь находятся
все суффиксы, кроме пустого, потому что они все заканчиваются
на символ С, ну и соответственно они раньше нигде в автомате
не встречались, они содержат символ, который только что
появился.
Значит вот сюда вот мне нужно провести ребра из всех
предыдущих суффиксов, потому что здесь все новые суффиксы,
поэтому мне нужно из всех старых суффиксов провести
ребро отсюда по букве С.
Ну вот я ровно это и делаю, потому что раньше у меня
сувсылки, начиная от С, если я многократно применяю
сувсылку, то я как раз прохожу все возможные суффиксы,
потому что сувсылки для С устроены, это все суффиксы
порядка убывания. Ну, из них и всех я должен провести переход по C. Почему
сувсылка для СС это корень? Ну, потому что здесь находятся все суффиксы, кроме
пустого. Давайте я нарисую класс СС в этом случае. Это сама строка СС и все ее
непустые суффиксы, вплоть до суффикса из одного элемента C.
Когда сувсылка такого класса, напоминаю, сувсылка, это нам нужно взять самую
короткую строчку и отбросить один символ. Тогда будет пустая строка в качестве
сувсылки. Ну, вот это мы и назначаем. Мы у последней вершинки говорим, что
сувсылка это корень. Ну и, соответственно, давайте посмотрим на С0,
почему она не образует дополнительного класса. С0-то самый длинный суффикс строки СТ
являешься под строкой С. Чему равно С0 в этом случае?
Да, пустая строка, потому что все остальные суффиксы, ну как бы все
суффиксы длины хотя бы один, не были под строками С, потому что С нигде не было.
Поэтому в этом случае С0-эпсилон. Ну, оно и так раньше было
лонгистом в своем классе. Это как бы корень. Пустая строка у нас соответствует
корню, корень автомата. Ну и поэтому новым состоянием эта штука точно не будет,
потому что она и так уже была лонгистом. Стать новым лонгистом она не может,
потому что это был уже отдельный класс. Все, значит обработка в этом случае закончилась.
Окей? Хорошо.
Так, едем дальше.
Значит теперь происходит что-то другое. Мы шли-шли-шли вот так по суффсылкам и в какой-то момент мы нашли переход по С.
У нас была С. Мы несколько раз берем суффсылку. Из всех вот этих промежуточных не было перехода по С,
а вот из какой-то очередной вершинки П был переход по С. Пусть он ведет в какую-то вершинку Q.
То есть вот здесь переходов не было и я их соответственно тогда просто провожу по
букве С в наше новое состояние С. А из очередной вот следующей вершинной пути такой переход уже был.
Был переход по символу С в какую-то другую вершинку Q. Тогда я утверждаю, во-первых,
следующее, что С0 обязательно это лонгест от П плюс С. То есть вот та самая наша строка С0,
которой самый длинный суффикс С является под строкой С, это лонгест от П плюс С.
Ну почему это так? Вспоминаем, когда мы берем суффиксные ссылки от С, мы по сути перебираем все суффиксы С в порядке убывания длины.
Здесь С вместе с несколькими своими самыми длинными суффиксами, потом следующий по длине суффикс вот здесь опять с несколькими своими самыми длинными суффиксами.
Ну и так далее. И вот в какой-то момент мы доходим до какого-то суффикса С, который можно было продлить буквами С.
А вот эти все более длинные нельзя было. Да, то есть после них, если я там как-то дошел на этой вершинке,
то я С не мог прочитать в исходном автомате. То есть вот эти строки не продолжались символом С в исходной строке С.
Все, вот это вот нельзя было продолжить символом С, а это можно. Ну значит, просто самая длинная строка, ведущая в П,
является суффиксом строки С, после которого можно прочитать С. Ну значит, собственно, это есть наша самая С0.
Давайте это запишу, что поскольку... Не обязательно, потому что здесь, возможно, еще какие-то другие слова.
Ку могут быть какие-то другие слова.
Поскольку те более длинные суффиксы С, строки С не продлевались символом С вправо.
Символом С вправо.
Но это продлевается, соответственно, это вот та самая длинная строка, которая была раньше в автомате.
Самый длинный суффикс С.
Так. И вот здесь опять возникают разные случаи. В хорошем случае, если, как вы сказали, С0 это вот
лонгест от Ку, тогда все хорошо. Это будет второй случай наш.
Если лонгест от Ку равно С0. То есть С0 это самая длинная строка в классе Ку.
То новых классов не появляется.
Новых классов не появляется.
Потому что мы с вами знаем, что единственный кандидат на то, чтобы стать новым лонгестом
Это Вот эта самая С0, которой мы знаем, как выглядит.
Единственный кандидат на новый лонгест — это С0.
И если он раньше был лонгестом, мы знаем, что С0 лежала в этом состоянии,
И если он раньше и был лонгестом в своем состоянии , то нового ничего не появляется .
Единственная новая вершина — это Сce.
А С0, как тут была лонгестом, так и остается.
В этом случае, если s0 это longest был изначально, то
у меня больше вершин не появляется.
И единственное, что мне нужно сделать, это видимо
назначить просто link от sc равно q и return.
Так, значит, почему это верно?
Почему в случае, если s0 раньше было longest и соответствовал
вершинке q, то мне ничего не нужно делать, новый хребер
не появится, мне нужно только назначить сувсылку
из scq.
Во-первых, почему такая сувсылка корректная, это
более-менее понятно, потому что мы с вами замечали не
однократно, что link от вот этого класса sc это обязательно
s0.
Потому что в sc лежат те суффиксы sc, которые не являются
под строками s, и если я, то есть вот это sc, потом
еще следующий суффикс, не являющийся под строкой
s, еще-еще-еще-еще, мы так вот уменьшаем до того момента,
пока не встретим суффикс sc, являющийся под строкой
s.
И это будет в точности наша s0, самый длинный суффикс
sc, являвшийся под строкой s.
Поэтому сувсылка от sc обязательно всегда ведет
в s0, пунктирная сувсылка обязательно ведет всегда
в s0.
Так же как вот здесь у нас получилось, смотрите,
вот в этом случае, у меня сувсылка из sc вела в корень,
а корень как раз соответствовал s0, здесь также выполняется,
что сувсылка от sc ведет в s0, точнее от класса, отвечающего
sc, ведет в класс, отвечающий s0.
Поэтому этот переход по сувсылке будет корректный,
но больше ничего не происходит.
Ну мы поняли, что вершин больше не появляется, потому
что только это могло стать новый вершин, но оно и так
было лонгистом, поэтому ничего нового не происходит.
Почему мы добавили все ребра?
Ну давайте думать, какие вообще могли появиться
ребра?
Раз у меня вот эти вот вершины все не меняются, в старом
автомате не появляется новый вершин, кроме вот
этого, то значит, ребра, располагавшиеся внутри
вот этого старого автомата также не меняются, просто
потому что здесь не меняются как бы классы, классы эквалентности
здесь не меняются.
Все, кто были лонгистами, они же и остались, но их
не появилось.
Поэтому все классы эквалентности внутри старого автомата
сохранились, а значит, и все переходы между ними
тоже сохранились, потому что мы там рисовали, как
у нас устроен переход из одного стани в другое.
Если есть слово здесь, такое, что после дописания одного
символа мы попадаем в слово сюда, но раз все классы здесь
не изменились, то значит, и переходы между ними остались
такими же.
Итак.
Сейчас, секунду.
Ну, у вас лонгистов.
Кроме СС.
Не появляется.
Значит.
Классы эквалентности.
Классы эквалентности.
Старого автомата.
То есть автомат для строки С.
Не изменяются.
Потому что новых лонгистов не появляется, там тоже
самое разбиение на классы, и эти классы, как множество
слов, сохраняются прямо такими же.
Значит, между ними сохраняются все переходы.
Значит, между ними сохраняются все переходы.
Поэтому вот то, что у меня было здесь, старый кусок
автомата, он вообще никак не изменился.
Потому что здесь с ним не поменялись классы, не поменялись
ребра.
То есть здесь я ничего не меняю.
Единственное, что меняется, это только ребра в СС.
Ну, а собственно, вот я их здесь все построил.
Все вот эти вот вершинки, из которых не было перехода
по С, я завожу переход в СС, и все, и это все возможные
переходы в СС.
То есть, смотрите сейчас, что я сказал.
Я сказал, что вот в этом случае, если С0 это лонгистат Ку,
то у меня старый автомат не поменялся, и все, что
нужно сделать, это провести ребра из вот этих вершинок
на все, что мы дошли до П, провести ребра по букве
С в СС, и больше ничего делать не нужно.
Что значит, что лонгисты сравним по длине?
Нет, лонгисты – это какая-то конкретная строка.
Да, но вот если они одинаковы как строки… Ну, это одно
и то же, что по длине, это то же самое, что длинный
процесс сравнить.
Вот это условие равносильно тому, что лен от Ку равно
лен от В плюс один.
Так, значит, мы поняли, что внутри старого автомата
ничего не меняется.
Нам нужно понять, какие появляются переходы в СС.
Как в него должны выглядеть ребра, ведущие в это самое
СС.
Ну, мы знаем, что это несколько ребер, на которых написан
один и тот же символ, отвечающий последнему символу вот здесь.
И они являются друг от дружки с уфиктными ссылками.
И мне нужно вспомнить, какая классификация у этого
множества слов.
Значит, это слова, у которых раньше не было вхождений.
Это такие слова, которые получили первое вхождение.
То есть это суффиксы СС, давайте их нарисую.
Так вот СС, это такие суффиксы, которые раньше не встречались.
Иными словами, это такие суффиксы С, что приписывание
С к ним в строке С невозможно, а теперь стало возможно.
Ну, а то есть вот здесь вот хранятся все такие суффиксы,
вот эти вот кружочки, овальчики, которых раньше не было
в строке С.
То есть это мы должны были взять какой-то суффикс
из строки С, дописать к нему один символ.
И как бы вот раньше нельзя было дописать С, то есть
раньше с дописанием С это не было под строкой, теперь
стало под строкой.
Ну, значит, мне нужно просто взять всевозможные суффиксы
строки С, из которых не было перехода по С, и добавить
переход в СС.
Вот ровно это мы и сделали.
А мы прошлись по всем суффиксам строки С и проверили, если
не было перехода по С, то я его создаю, а если есть,
то я останавливаюсь, потому что из всех более коротких
тем более есть.
Ну, значит, вот мы целиком работали, это случай, вот этот.
Так, давайте это напишем.
В СС есть переходы из всех суффиксов С.
Из всех суффиксов С.
Из которых раньше не было перехода по С.
Из которых раньше не было перехода по С.
Значит, мне, чтобы восстановить все эти переходы, нужно
взять С, многократно взять всю ссылку, то есть рассматривать
все суффиксы строки С.
Когда нет перехода по С, нужно его создать, а
как только он появляется вот этот переход есть,
то значит из всех коротких суффиксов тоже падавно
будет такой переход, потому что это, соответственно,
в какой-то строке в каком-то суффиксе после которого
можно было прочитать С, а это какой-то еще
более короткий суффикс, patent j negitime- crisesires takes
meaning after a longer time probably could be
куда они ведут неважно, они сохраняются, но главное,
что больше ничего перенаправлять не нужно.
То есть мы вот эти вот просмотрели, добавили такие переходы
и на этом автомат перестроили.
Так, вопрос есть сейчас?
Хорошо.
Ну и остается третий случай, это когда лонгест от Q не
равно S0.
Лонгест от Q не равно S0.
То есть лен от Q не равно лен от P плюс 1.
Значит, в этом случае картинка примерно следующая.
Вот у нас была вершина P, отвечающая нескольким строчкам.
Например, что-то такое.
Самая длинная из них была S0.
S0 это не так, не совсем.
Два какая-то лонгеста от P.
Дальше я дописываю символ C и получаю состояние Q.
Поэтому все вот эти вот строчки после дописывания
C попадают тоже в состояние Q.
Что-то я их здесь нарисую.
Вот.
И это уже S0.
Вот это вот самая длинная строка SP после приписывания
C, это S0.
Но это не самая длинная строка в Q.
Значит, кто-то есть еще более длинный.
То есть в Q есть какие-то более длинные строчки.
Они тоже, конечно, все заканчиваются на C, потому что они все
суффиксы один другого.
Ну вот какие-то строчки есть более длинные.
Значит, в частности, чтобы они существовали, сюда
в Q должны быть какие-то еще другие переходы по букве
C из каких-то там других более длинных вершин.
Потому что здесь есть какие-то слова лишние.
Ну не лишние, а длиннее, чем S0.
Поэтому они в частности откуда-то появляются.
Есть еще какие-то другие входящие ребра.
Ну смотрите, мы же с вами знаем, что S0 – это теперь
будет обязательно новый лонгест.
S0 обязательно становится новым лонгестом.
Если оно раньше не было лонгестом, то теперь обязательно станет.
Так, это надо объяснить почему.
Секунду.
То есть я утверждаю, что в этом случае на самом деле
вот этот класс большой, который раньше отвечал
одной вершинки Q, он расшипляется на 2.
Он расшипляется вот по этой линии.
То есть слова, которые были длиннее, чем S0, остаются
в этом состоянии Q.
А все, которые S0 короче, вот это все ниже, чем S0,
это будет отдельное состояние, которое вот образуется
за счет того, что S0 становится лонгестом.
Так, надо вспомнить критерий лонгест.
Продлевается…
Продлевается налево двумя разными буквками, да?
Раньше не продлевался.
Ну да.
Значит, почему S0 становится…
Это вот мы в конце прошлой лекции обсуждали, да?
Почему это то самое, наша T?
Потому что раньше, в предыдущем автомате,
S0 влево продолжался единственным образом.
Единственный образ, единственный способ,
как эту строчку можно дополнить, буквой слева,
до под строки S, это дописать вот эту букву,
которая лежит в том же состоянии…
Ну точнее, нужно взять строчку на один побольше
из того же состояния, вот эта строчка,
и этот символ сюда записать.
Больше никаких других предыдущих символов быть не могло,
потому что иначе, если бы эту строчку S0
можно было бы двумя разными способами продлить влево,
то это был бы уже обязательно лонгест.
У нас есть критерий лонгеста.
Напоминаю, критерий лонгеста – это что?
Либо это префикс, либо есть два разных продолжения влево.
И вот если у нас уже одно продолжение влево точно есть,
то это не префикс, а если было бы другое,
то это был бы лонгест.
Но раз это не было лонгестом раньше,
почему он теперь становится новым лонгестом?
Ну потому что мы получим новое вхождение,
и...
Момент.
Rick Showy
Самый длинный суффикс.
Да, да, смотрите, раньше у меня S0 влево продолжалось
единственным образом, вот этим символом, а теперь
мы точно знаем, что линк от класса, отвечающего
S0, это S0, да, поэтому если я запишу S и все более короткие
суффиксы, лежащие в том же классе, вплоть до S0, то
мы понимаем, что гарантированно S0 должен быть лонгистом
в своем классе, потому что я вот так вот отрезаю по
одному символу, отрезал, отрезал, отрезал, вот все
вот эти первые были не под строками S, а потом начиная
с кого-то стали под строками S, ну значит, просто потому
как устроен у нас класс эквивалентности, S0 обязательно лонгист в своем
классе, потому что я отрезал по одному, оставался в
одном классе, отрезал очередной, перешел в другой класс,
да, ну как бы, если это не лонгист, то какая-то из
этих должна была быть лонгистом в своем классе, поэтому
вот эта вот S0, оно обязательно должно быть лонгистом в
новом автомате, S0 обязательно является лонгистом в новом
автомате.
Ну вот, собственно, вот отвечает в случае, что вот этот символ
какой-нибудь там, не знаю, X, отличен вот от этого Y,
мы рисовали тоже в конце прошлой лекции, что это
такая самая длинная строка, что у нее раньше каждое ее
вхождение продлевалось влево Y, а теперь продлевается
в частности каким-то новым X, что X не равен Y, вот, и
это тогда обязательно новый лонгист, и раньше оно
лонгистом не было, то теперь происходит расщепление
вот этого класса Q, да, потому что раньше здесь было все
вместе, а теперь это стало лонгистом, а поэтому здесь
должно произойти расщепление.
Так, вывод, класс должен расщепиться, должен расщепиться.
Ну и понятно как, да, значит, должно появиться новое
состояние, содержащее S0 и все более короткие, а
в Q остаются все более длинные, чем S0.
Давайте тогда для этого заведем новое состояние,
заведем новое состояние, я его назову клон, потому
что оно будет во многом очень похоже на Q, значит,
лонгист от клон это будет S0, вот тот самый новый класс,
который возникает из расщепления Q, ну а в Q остаются все остальные,
остаются все остальные, все остальные строки, которые
раньше там были, да, то есть вот эти вот более длинные,
чем S0 остаются в Q.
Так, значит, тогда у меня возникает новое состояние
клон, где в частности лежит S0, строка S0, мне нужно понять,
что происходит с ребрами из Q и в Q и из клона в клон,
мы понимаем, что больше никаких вершин в нашем
автомате не появляется, мы сказали, что их максимум
две, вот они две появились, поэтому больше точно ничего
не происходит, новых вершин не появится.
Значит, что происходит с ребрами, смотрите, ну мы
знаем, что в Q лежит в частности S0, поэтому вот этот переход
из P по буквице мне нужно точно будет перенаправить
вот сюда, да, потому что S0 это что такое, S0 это лонгист
от P плюс C, вот я его должен точно так перенаправить,
потому что раньше как бы этот переход был сюда,
теперь он ведет в клон, потому что ну просто S0 тут
лежит по определению, это ребро я удаляю, это перенаправляю
сюда, ну и то же самое я должен делать со всеми
вершинами на суффиксном пути, ну на пути по ссылкам
из P, которые раньше вели в Q, то есть все вот эти вот
ребра, ведущие раньше в Q, я должен удалить и перенаправить
их в клон, потому что давайте опять S0 картинку, значит
в Q лежит какая-то самая длинная строка, затем в какой-то
момент будет S0 и какие-то ее суффиксы, соответственно
Юна П отвечает какому-то вот этому отрезку и вот
эти все отрезочки я должен перенаправить в клона, потому
что теперь это новый, отдельный класс, отвечающий
к клону, да, я должен все эти стрелки перенаправить,
потому что они просто отщепились в отдельный класс, то есть
это будет отвечать следующему, пока, ну как это можно реализовать,
k, p не минус 1, и tu, p по букви c равно cu, мне нужно перенаправить
стрелку клона и взять сувсылку. p равно линк от p.
Потому что, как бы, вот я стоял в p все более ранние
как бы сувсылки, ну точнее многократно применю сувсылки к p. Если из них был
переход в cu, то соответственно это какие-то более короткие строки, чем с 0,
они обязательно должны вести вот в новое cu, потому что сюда я свалил все более
короткие строки. Так, вот, это я какие-то ребра перенаправил, но причем, смотрите,
важно, что в cu какие-то ребра по-прежнему будут входить. Я многие перенаправил,
но какие-то по-прежнему входят, которые отвечают вот этим более длинным строчкам.
Мы уже замечали, что раз в cu были какие-то более длинные строки, то в cu еще кто-то входил,
еще были какие-то ребра из более длинных строк. Вот это вот, да, вот оно. Что-то здесь было,
какие-то были еще ребра, которые не лягут на пути по сувсылкам xp, и их я не трогаю. Все,
что отвечало более длинным строкам, я не трогаю, оставляю так же, как было. Потому что это какая-то
старая строка, она не изменилась при дописывании c, значит и в автомате тоже ничего не происходит.
Вот, то есть какие-то ребра остаются, не то что у меня cu остается подвешенным в воздухе, в него
кто-то ведет, но я просто на эти вершинки, я их даже не перебираю в моем алгоритме, я перебираю
только те, которые вот, начиная с s0 и к более коротким. Их все я перенаправляю в клон. Так,
что еще? Да, ну вот здесь в какой-то момент я мог перейти к вершине, которая по буквице вела уже
не в q, а в какую-то другую вершину, не q. Тогда с ней я уже ничего не меняю, потому что мне нужно
было только перенаправить вот эти вот ребра, ведущие в то, что было в q. То, что я от q отщепил
какой-то кусок, в них нужно перенаправить ребра. А все, что еще более короткое, да, вот эти вот еще
более короткие строки, они как были в отдельном состоянии, так там и остаются, поэтому я их тоже
не меняю. Я меняю только то, что отвечало вот этому вот куску с s0. Так, это перестроил. Вот, и тем
самым мы с вами уже определили все входящие ребра в q и в клона. То есть в q остаются все более
длинные, вот эти вот мы их не трогаем, а все более короткие, которые раньше вели в q, теперь
перенаправляются в клона. Вот, вот в этом цикле я перенаправляю все ребра нужные из q в клона,
больше ничего делать с этими ребрами не нужно. Последнее, с ребрами это нужно разобраться,
какие ребра ведут из q и из клона, что происходит с ребрами, исходящими из q и из клона. Ребра
входящие в них мы разобрались. Что такое входящие ребра в q и в клон? Так, что сказал? Наоборот,
исходящими. Что происходит с ребрами, с ребрами, исходящими из q и из клона.
Чтобы это понять, полезно заметить следующее.
Если мы рассмотрим правые контексты вот этих наших состоений относительно нового слова s,
то они отличаются только эпсилоном. А именно, что в клоне есть эпсилон в качестве одного из
элементов правого контекста, а в q его нет. Значит, почему это верно? Почему это верно?
Ну, давайте смотреть. Чтобы понять, как соотносятся правые контексты, по сути,
мне нужно посмотреть на вхождение вот этих вот слов в нашу строчку s, потому что каждый
элемент из правого контекста, если что-то лежит в правом контексте, то значит вот
здесь вот заканчивается очередное вхождение одного из слов нашего класса эквивалентности.
Поэтому, по сути, правые контексты тоже самое, что множество вхождений в каком-то смысле. Множество
вхождений однозначно создает правый контекст. Вот. Значит, как тогда отличаются правые контексты
клона и q? Ну, мы знаем как. Единственное, чем они отличаются, то, что s0 получило новое вхождение,
которое вот отвечает суффиксу строки sc. То есть, раньше они были все в одном классе, раньше все эти
строчки были в одном классе. Потом у меня появился, у меня s расширилась, и s0 получило новое вхождение.
Ну, значит, все вот эти более короткие тоже получили новое вхождение. А эти не получили.
Раз они как бы не являются суффиксами sc, то есть s0 это самый длинный суффикс sc,
то это значит не суффикс sc. Поэтому эти строчки вхождения как бы не получили, а эти получили. И,
значит, единственное отличие множества вхождений, это то, что эти получили вот только что вот последнее
вхождение. Оно заканчивается там же, где заканчивается sc. Давайте это запишем. Строки
из множества клон, отвечающие классу клон, имеют на одно вхождение вsc больше,
больше, чем строки sc. Да, то есть если вот, ну давайте я там нарисую какие-нибудь вхождения,
вот там где-то какие-то вхождения элементов sc, то в дополнение к ним у клона есть еще вот такое
вхождение. Ну, значит, правый контекст у них отличается только тем, что вот появляется такой,
как бы правый контекст для такого слова, то есть епсилон. Ну и, собственно, ровно это здесь и
написано. На что единственное отличие правых контекстов уклона и уку только в том, что здесь
есть епсилон, а здесь нету. Ну и здесь нету, потому что это не суффикс sc, а это суффикс sc.
Отсюда будет следовать следующее. Смотрите, правый контекст этих двух классов отличается
только тем, что здесь есть епсилон. Поэтому эта вершинка как бы должна быть терминальная,
терминальная как раз те, у которых, у которых в правом контексте есть епсилон. Значит,
это должна быть терминальная, а кроме этого их как бы продолжение, всё что можно дописать
справа, не отличается. Поэтому если я рассмотрю вершины к и клон, то все возможные пути добраться
из к и или из клона до терминальной должны быть одинаковыми. Ну просто потому что у них одинаковые
правые контексты кроме вот этого епсилона. То есть все не тревиальные пути из к или
из колона до терминальной – это как бы одни и те же пути, просто потому что у них одинаковые правые
контексты, по сути. А правые контексты — это как раз вот если я встал, то как я могу добраться до
терминальной? Правые контексты — это то, какие строчки можно дописать справа к этой вершинке,
чтобы попасть в терминальную вершину. Если у них одинаковые правые контексты, то эти пути у них
устроены одинаково. Все, что было здесь, ну как бы все пути отсюда до терминалов, это то же самое,
что пути отсюда до терминала. Кроме еще добавления, что это тоже терминальная сама по себе. И это
единственное отличие между ними. Поэтому скажите, пожалуйста, какой вывод? Как должен выглядеть
массив переходов из клона? Чему он равен? Что? Да, да, да. Просто тот ку. То есть еще раз,
клон — это такая вершина, которая с точки зрения правых контекстов, с точки зрения продолжения
до терминальных вершин ничем не отличается от ку. Поэтому вот если здесь были какие-то
переходы, не знаю, там по а сюда, так сейчас я нарисую, это ку, по а сюда, по б сюда, то если
я просто проведу такие же ребра, по а сюда же и по б сюда же, то у них будет одинаковый правый
контекст. Все, что как бы справа написано, у них одинаковые пути. Просто потому что одинаковое
начало, ну и дальше тоже все одинаково. Поэтому если я просто перекопирую содержимое этого массива
вот сюда, ну или там мап, да, смотря как вы храните все эти переходы, вот если это просто массив для
каждой буквы хранится, куда есть переход, то мне нужно просто этот массив целиком сюда перекопировать.
Вот. И тем самым мы разобрались, как устроены ребра, исходящие из клона. Ну а ребра, исходящие из ку,
остаются, потому что, ну тут все равно, да, тут остаются какие-то слова, вот ку это слова,
которые длиннее, чем ис 0, там все переходы остаются такими же, как были, потому что если
был какой-то переход отсюда по какому-то символу D в другую вершину, то он по-прежнему остается,
да, здесь есть все равно, можно взять любое слово отсюда, дописать D и попасть сюда,
поэтому все более старые переходы остаются. Появляются только новые переходы из клона,
которые по сути просто дублируют все, что было раньше из ку. Вот. Все, значит все время разобрались,
да. Вот, да, осталось с линками разобраться, давайте напишем сейчас. Ну, линк от ку чему равно? Это вы
можете мне сказать. Да, давайте напишу так, new link от ку равно клон, ну просто надо посмотреть
на картинку, вот оно ку, а вот он клон, что такое сувсылка? Это нам нужно отбрасывать первый символ
до тех пор, пока не перейдем в новое состояние, вот оно новое состояние, поэтому сувсылка
ведет сюда. А что такое новая сувсылка для клона? Это предыдущая для ку, потому что предыдущая для
ку это была вот эта вот как раз маленькая строчка, да, лежащая в другом классе, ну,
поэтому нужно ее сохранить в качестве новой сувсылки для клона. New link для клона это то,
что раньше было линк от ку, потому что линк от ку это самая длинная строка, лежащая не в ку,
но теперь я просто ку расщепил, расщепил на два, значит эта сувсылка будет теперь новой сувсылкой
для меньшего из классов для клона. А сувсылка для sc мы уже знаем как выглядит, это всегда s0,
сувсылка для sc это всегда класс содержащий s0, но в нашем случае это клон,
потому что в клоне как раз самая длинная строка будет s0. Вот вроде мы все написали.
Так, тогда давайте сейчас я напишу код этого всего безобразия вместе, все три случая,
и мы разберемся с асимптотикой. Значит, что мне надо? Мне нужно какая-то струк нод,
где я храню как бы всю информацию про вершинку. Здесь в частности есть линк, тул, лен, ну нет,
флаг терминальности не буду, вроде этого хватает мне, да. То есть у меня вершинки будут
занумерованы числами, линк от вершинки это номер вершинки куда ведется сувсылка,
лен это длина лонгиста в этой вершинке. Ну а тут давайте сейчас что это мапа по каждому символу,
если этот символ есть в множестве переходов, то мы отобираемся в номер вершинки куда попадаем,
если символа нету в множестве переходов, то просто такого ключа в мапе нет. Что дальше,
например, какой-нибудь вектор нодов, ну я его привык называть Т, пусть он у меня будет Т,
это вот собственно наш сувстамат, там будут просто перечислены вершины, в смысле просто в каком-то
порядке валяться все вершины. И в мейне где-нибудь там в самом начале мы в Т пушбэкнем пустую вершину,
пушбэк нод, это будет корень. Изначально мы добавим в наш в наш автомат просто корневую вершинку,
это будет автомат отвечающий в пустой строке, то есть корень без переходов, вот просто пустая
вершина да стартовая из которой ничего нельзя прочитать, это пустая строка. Дальше наша процедура
добавление символа C, чар С. Так момент, сейчас мне еще нужна переменная last,
это переменная отвечающая S, переменная номер класса S, изначально С это пустая строка и last
равно нулю как номер корня, номер корня ноль. Добавляем символ. Для этого сначала мы заводим новую
вершинку отвечающую классу, отвечающую строке С, ну давайте я сделаю T пушбэк нод, да добавил
список вершин к еще одну вершину. Давайте я скажу, что у нее номер кур равен там T.size-1,
да простит меня автоматическое приведение типов. Так, что еще? Что еще я хочу сделать? А, ну нужно
у кура например выставить лен. Скажите пожалуйста чему равно T кур точка лен? То есть кур это вершина
отвечающая С, вон она, давайте я здесь нарисую, что вот это вот это это кур, а это last, предыдущая
вершина отвечающая С. Тогда чему равно T кур точка лен? Какая у нее длина? Ну да, last точка лен плюс один.
T last точка лен плюс один, потому что отличается дописывание одному символу от С. Дальше,
P равно last и я беру многократную сувсылку от этого P пока нет перехода по букве С. Этот кусок кода
я уже писал, но продублирую, значит пока P не минус 1, а да здесь по умолчанию значение сувсылки
это минус 1. Кур это вершина отвечающая С. Так, ну раз-то у меня мапа, то я должен написать,
я вот так это пишу, tp to counts C. Вот так, да, то есть если в мапе tp.to нет буквы С,
тогда я должен переход создать tp.to по букве С равно кур. Я создаю переход из P кур и прыгаю по
сувсылке из P. P равно tp.link. Встал сначала в last, вот P равно last. Потом многократно применяю
сувсылку до тех пор, пока не найду переход по букве С. И пока этого перехода не было,
я завожу переход по букве С в новой сцене кур. Первый случай, если P равно минус 1. Это
случай, когда буква С появляется впервые в нашем слове. Буква С раньше никогда не было,
нет ни одного перехода по букве С. Тогда больше ничего с автоматом не происходит. Нужно просто
назначить кур.link. Мы знаем, что в этом случае нужно отправиться в корень, то есть вершинку
номер ноль. Здесь я еще напишу last равно кур, потому что меняется указатель на последнюю вершину,
отвечающую всей строке, ну и return.
Иначе, P это какая-то вершинка, нормальная вершина, из которой есть переход по C.
Тогда давайте пусть он ведет в вершинку Q. То есть Q это tp.tuc. Второй случай, если tq.len равно tp.len
плюс 1. Это хороший случай, когда S0 не является новым лонгестом, потому что она и так раньше
была лонгестом. S0 было равно лонгест от Q. Ничего не расщепляется, нужно просто переназначить
су-всылку. tq.link равно Q. Точно так же last равно кур и return. Это второе случае у нас было,
когда ничего не расщепляется. Ну и, конечно, третье, когда Q расщепляется в две вершинки Q и
clon. Нам нужно сначала завести новую вершинку, то есть в вектор вершин добавить новую какую-то,
t pushback node. Добавили новую вершинку и сказали, что она равна, ну ее номер это clon. clon равно
опять t.size минус 1.
Так, теперь перенаправляем ребра, ведущие в Q, чтобы они теперь вели в clon. Пока p не равно
минус 1 и tp tu t равно clon равно Q. Нужно их перенаправить в clon.
Что? Да, да, действительно, спасибо. Так, это мы сделали. Теперь надо разобраться,
наоборот, с исходящими ребрами. Я могу прям так написать tclon.tu равно tq.tu, потому что это
мапы и можно их просто перекопировать. Теперь нужно с характеристиками clon еще разобраться.
Во-первых, какая у него link мы знаем. Это то, что раньше было линкой для Q. И мы знаем,
что у него линка, у него лен. tclon.len. Это что такое tclon.len? Еще раз.
Ну, мы с вами писали, что s0 – это лонгест… Да, да, да, да. Напоминаю, что s0 – это лонгест от
p плюс символ c, и при этом оно же – это лонгест от clon. Мы clon так вводим, что s0 – в нем новый
лонгест. Значит, просто длина этой штуки на один больше, чем длина лонгеста от p. То есть,
мы нужно взять tp.len и прибавить единицу. Так, len, link, разобрались. Дальше напишу вот так.
tqr.link равно tq.link равно clon. Ну, мы писали, что у обеих этих вершинок ссылка будет вести в clon.
Вот, я их здесь же переназначаю. Вроде все, last равно qr и return. Конец.
Вот. Еще раз. А нам p не нужно уже. Да, вы гений. Надо вот сюда просто написать. Давайте вот
это вот просто сюда перенесу. Спасибо. Вот. До вот этого подсчета я посчитаю tclon.len. Так
лучше? Все, хорошо. Действительно, да, это важное замечание. Иначе у нас p какая-то фигня. Вот. Ну,
вроде все сделали. Все случаи рассмотрели, написали. Значит, повторюсь, что эта штука,
add c, она добавляет по одному символу, и если мы хотим постойте автомат для строки s,
то нам нужно запустить add для всех символов строки s. Вот. И дальше, если нам нужно еще
терминальности пометить, значит, после add, давайте я напишу. Значит, add. Если запускаю add для
всех символов строки нашей, от s0 до sn-1, то в конце last отвечает классу строки s. Ну, и чтобы
пометить терминальности, чтобы отметить все вершины, которые являются терминальными,
не нужно многократно брать у этой штуки соусылку и все их помечать терминальными,
потому что как раз last – это s и несколько самых длинных суффиксов. Чтобы взять следующий
суффикс, нужно взять соусылку, ну и так далее. Чтобы пометить терминальные вершины,
нам нужно сделать что-то типа такого. Пока while last не равно минус 1, нам нужно там сказать
t last.term равно true, пометить терминальные и взять соусылку. last равно t last link. Да,
если у меня есть вершина, отвечающая все строки s, то мне нужно просто много раз взять у нее
соусылку, все их пометить терминальными. Это будут как раз все суффиксы и только они. И только они.
Вот в самом конце, в мейне, грубо говоря, когда вы все эдды запустили, в мейне вы делаете еще вот
это while. То есть это не в эдде, а в самом конце в мейне. Вопросы? Окей. Значит,
всегда нужно разобраться с симптотикой. Для этого нам нужно будет следующее утверждение.
Пусть суффиксный автомат постоит по строке длины n. Тогда в нем, во-первых,
не больше, чем 2n-1 вершина, во-вторых, не больше, чем 3n-4 ребра. Вот это все работает,
кажется, если n хотя бы тройка. Давайте напишем, да, если n хотя бы, давайте напишу n хотя бы n0.
То есть при всех n, начиная с некоторого, вот это будут верные оценки. Вот, то есть асимптотически
у нас вершин максимум 2n и ребра максимум 3n. И отсюда будет следовать, что время работы будет
линейная, потому что если у нас... Т.е. у нас на самом деле так, почти понятно, что все линейное,
потому что на каждом шаге заводятся две вершинки всего, максимум. У нас тутża непонятность,
что с ребрами. Когда мы их перенаправляем, вот, например, вот здесь, вот. Вот, тут когда мы
делаем перенаправление ребер, и тут когда мы копируем это вот это теклон. avail.tu,
равно текуто т. т., непонятно сколько там ребр копируется. Но если вот суммарно их всего линейное
количество, в то время работа будет тоже линейным.
Так, ну доказательства.
Во-первых, а, ну хорошо, да, давайте так напишем,
начиная с двойки.
Значит так, а2, да, похоже на правый.
Давайте попытаемся понять, как может выглядеть автомат
на слове из двух элементов.
Если он равно 2, то у нас есть всего два слова, по сути,
это слова аа и аб, ну как бы с точки зрения равенства
символов, с точки зрения того, как выглядит автомат,
либо это одинаковые символы, либо разные.
В этом случае, что такое автомат?
Это же, видимо, что-то такое, ну там терминальность
не буду обозначать, но это вот такая штучка, и это
как раз 2n-1, в этом случае будет вот такой путь, и видимо
вот такой путь.
Аа это аб, тут тоже максимум 2n-1 вершина, еще раз, ага,
да, ну значит, хорошо, значит, это верно для всех n, начиная
с двойки, а это, видимо, для всех начиная с, ну вот
я поэтому и написал, начиная с какого-то, вот, ну, давайте
все-таки верну вот эту вот общую запись, потому что
неважно, что там происходит для маленьких n, вот, но
здесь уже верно для двойки, что там, как бы строка ни
выглядела, здесь максимум вот столько вершин, но дальше,
раз на каждом шаге добавляются максимум две, то их всего
максимум 2n-1, начиная с, наверное, двойки, так-так-так-так-так,
при n больше двойки каждый раз добавляется максимум
две вершины, каждый раз добавляется не больше двух
вершин, значит, их всегда не больше, чем 2n-1, так,
пункт b, пункт b, давайте я веду такое, в общем, буду
называть ребро жестким, если оно ведет, ну, не так сейчас
момент, значит, ребро из p в q, назовем жестким, назовем
жестким, если len от p плюс 1 равно len от q, ну, это вот
как раз тот хороший случай, когда мы взяли лонгест отсюда,
дописали один сим и получили лонгест отсюда, тогда такое
ребро я буду называть жестким, а если у них len и на 1 отличаются
ровно, тогда, во-первых, понятно, что в каждую вершину
входит ровно одно жесткое ребро, кроме корня, в каждую
вершину, отличную от корня, входит ровно одно жесткое
ребро, потому что, ну, что такое вершина, вот какая-то
вершина, есть соответствует некий набор слов, мы знаем,
как выглядят все ребра, ведущие в эту вершину, это какое-то
разбиение вот этого множества слов на подотрезке, да,
от них от всех надо отбросить последний символ, соответственно,
это там первая вершина, это вторая, это третья, значит,
просто если возьму вот эту, то это будет жесткое ребро,
в каждую вершину кроме корня входит ровно одно жесткое
ребро, значит, если я оставлю только жесткие ребра, то
у меня будет максимум 2n-2 ребра, и останется посмотреть
только на нежесткие ребра и доказать, что их не очень
много. Каждую вершину, отличную от корня, ведет ровно одно
жесткое ребро, следовательно, всего жестких ребер не больше
чем 2n-2, верно? Все кроме корня, не больше чем 2n-2. Теперь
рассматриваем нежесткие ребра. Нежесткая. Давайте
докажем, что нежестких ребер мало. Для этого давайте
каждому нежесткому ребрусу поставим следующую строчку.
Сначала мы берем, ну, по сути, просто лонгест, вот
у меня есть ребро из ПФК, нежесткое. Сначала я беру
лонгест от П, то есть самый длинный путь от стартовой
вершинки, вот корня, до П, самый длинный путь. То
есть это по сути просто лонгест от П. Затем пишу
этот символ на этом ребре, и в конец еще приписываю
самый длинный путь из Q в какую-то терминальную вершину.
Самый длинный. Из всех возможных окончаний Q до терминала,
из всех возможных путей отсюда до терминальной
вершины, я выбираю самый длинный. И для этого нежесткого
ребра, ну, как бы, ставлю ему в соответствующую строчку,
давайте я напишу ее там, альфа, ц, бета. Ц у меня
приходит в альфа, ц, бета. Самый длинный путь из стартов
П, потом ц, потом самый длинный путь из Q до терминала. Тогда,
да. Нет, не обязательно. Более того, гарантировано,
гарантировано неравно, потому что если бы это было всей
строкой, то все ребра были бы жесткие по дороге на
самом деле. Мы еще это заметим. Значит, верно, чуть более,
верно, другое. Верно, что все вот эти вот строчки
для различных нежестких ребер, во-первых, суффиксы
строки С, во-вторых, все различные, попарно различные.
Значит, почему это все суффиксы? Почему это суффикс? Да,
это не С, это суффикс С. Ну, просто потому что это
означает в некотором пути от старта до терминала,
поэтому это гарантированно суффикс. С другой стороны,
все вот эти строчки по разным нежестким ребрам С, они обязательно
различные, потому что можно легко понять, что на этом
пути обязательно все ребра жесткие. Ну, потому что если
здесь есть хоть нежесткое ребро… Так, давайте разбираться.
Давайте разбираться. Сейчас, одну секунду. Сейчас, сейчас,
у меня есть некая стартовая вершина и вершина П, я выбираю
самый длинный путь из Q0 в П. Почему на нем все ребра
жесткие обязательно? Почему Лен каждый раз увеличивает
все равно на 1? Ну, здесь все понятно, потому что
здесь есть какой-то конкретный Лен от П. Лен от П у нас
означает как раз самое длинное слово, которое можно
пересчитать от старта до вершинки П. Поэтому… Ну,
точно есть путь вот такой длины. Что происходит с
ребрами на этом пути? Почему они все обязательно жесткие?
Ну, я вот так вот беру и еду по этому пути, вот такой
вот длины из стартов П. Они все у меня обязательно
жесткие, потому что Лен вот здесь возрастает ровно
на единичку. Здесь у меня было слово длины 0, тут слово
длины 1, 2, 3, 4 и так далее, Лен от П. И если в какой-то
момент у меня было такое, что Лен отсюда, ну там не
знаю, пусть это будет х, у, если вдруг Лен от у больше
чем 1 плюс Лен от х, то значит этот путь можно был… Да,
то значит отсюда до сюда есть более длинный путь. Противоречие,
потому что я предположил, что это самый длинный. Значит
просто на этом пути от Q0 до P самый длинный путь имеет
такую длину, поэтому все ребра на нём обязательно
жесткие, иначе есть какой-то более длинный путь. Ну то
же самое с Q и каким-то терминалом. Да, если я рассмотрю самый
длинный путь от Q до терминала, почему здесь все ребра обязательно
жесткие. Так, секунду.
Ну видим примерно потому же, что если здесь есть неколебро
из х в у, такое, что Лен от у больше чем 1 плюс Лен
от х, то значит, что до у можно дойти более длинным
путем и опять путь увеличить. И возможно, если что, можно
будет перейти в другую терминальную вершину, как-то вот так,
и тем самым еще больше наш путь увеличить. Так,
значит здесь я понял, что я не до конца понимаю.
Давайте это оставим на следующий раз. Сейчас не могу сказать.
На пути. Здесь все понятно, просто потому что если
есть нежесткая ребра, то тогда вот это начало можно
изменить на более длинное. Тут я пока не до конца соображаю.
Так что давайте это оставим пока. На пути от Q до терминальной,
все ребра тоже жесткие.
Почему? А, просто первое... А, ну да, кстати.
Типа просто у них отличаются первые... Да, действительно,
смотрите. Возможно, это и правда не нужно, потому
что что я здесь утверждал? Я утверждаю, что вот эти
вот строчки А, С, Б, которые я строю для всех нежестких
ребр, они все будут попарно различными. Но это просто
верно потому, что если я рассматриваю различные
нежесткие ребра, то по сути у меня вот эта А, С, Б, это
первое нежесткое ребро. И если у меня вот эти строчки
совпадают для каких-то разных ребер, то получается, что
здесь есть... Да, то есть у них тогда вот совпадают
эти префиксы по жестким ребрам, значит они вот здесь
вот общие, потом идет то же самое обязательно нежесткое
ребро, а мы предположим, что они разные. Поэтому вроде
действительно нам не обязательно даже понимать, что здесь
все ребра жесткие, главное, что на этом префиксе они
жесткие, потому что тогда если двум разным нежестким
ребрам отвечают одинаковые слова, то у них должны совпадать
первые нежесткие, то есть С, С штрихом, а это мы предположим,
что разные ребра. Окей, значит ну все, тогда получается,
что нежестких ребер не больше, чем различных суффиксов
строки С. И при этом более того, вся строка С никакому
вот такому цени соответствует, потому что если мы рассматриваем
строчку С, значит в пути, отвечающем строке С, все
ребра жесткие. Ну просто потому что это вообще самый
длинный путь из ку-ноль куда-либо. Самый длинный
путь из ку-ноль куда-либо, это как бы самая длинная
подстрока С, то есть С, так как С самый длинный путь
из С0, из ку-ноль, из стартовой вершинки. Итого, с тем нежестким
ребром отвечают различные суффиксы, и при этом С как
суффикс никому не отвечает. Вывод нежестких не больше
чем n-1. Нежестких ребер не больше, чем n-1. На каждом
ребру соответствует суффикс, все суффиксы различные,
при этом ни один из суффиксов не равен S. Ну и не равен
конечно Эпсилоном, потому что в Эпсилоне у меня вообще
нет ни одного символа, а тут есть символы. Поэтому
всего суммарно мы получили, что ребер максимум 3n-3.
Сейчас еще единичку можно тоже скостить. Так, 5 минут
осталось.
Ой, значит из того, ребер не больше чем 3n-3, но при
этом их может быть ровно 3n-3, если у меня вот здесь
вот достигается ровно 2n-1. На самом деле можно показать,
можно показать, что вершин будет 2n-1, если и только если
строка имеет вид, если и только если строка имеет
вид, а, и потом куча раз Б. Если что-то другое, то
классов меньше будет. Ну и соответственно нам нужно
понять следующее, что для строк такого вида у меня
максимум 3n-4 ребер, а для строка другого вида мы уже
понимаем, что здесь тогда будет меньше вершин 2n-2,
и поэтому здесь можно оценку будет еще на один уточнить.
Для строк вида А и Б повторено, наверное, с один раз, но
нужно вот понять, как выглядит автомат, давайте его нарисую.
Так, и кажется, кажется, он будет выглядеть вот так,
значит это будет сюда вот, а нет.
Ну и здесь ребер, в общем-то, столько же, сколько вершин,
потому что просто один цикл, и здесь ребер на самом деле
будет ровно 2n-1, да, да, ребер 2n-1, что меньше либо равно
чем 3n-4, для тех и начиная с некоторого. Вот, ну и все,
а для всех остальных строчек у них меньше вершин будет
обязательно меньше, чем вот столько, поэтому оценку
можно еще на один уточнить, из-за вот здесь вот, да, у
меня здесь было жестких ребер, не больше, чем вершин.
Если у меня число вершин еще можно точнее, точнее
оценить, то еще будет минус 1 вот здесь вот в оценке,
и будет как раз 3 и минус 4.
Так, questions.
Хорошо.
Ну и осталось, что со симптотикой? Симптотика алгоритма, да,
симптотика алгоритма.
Ну, мы сказали, что почти все линейное, потому что вот,
например, когда мы делали операцию teclon.tu равно tecu.tu,
мы как бы по сути, да, перекопируем всю мапу отсюда-сюда,
но поскольку ребер суммарно на каждом этапе у меня максимум
линейное количество, то когда я вот отсюда перекопирую
ребра сюда, у меня их будет, ну, все еще не более, чем
линейное количество суммарно, значит, но амортизировано,
все такие перекопирования занимают единицу, а суммарно
ребер линейное количество, поэтому это можно считать
работать за амортизированную единицу.
Самое тонкое место, это когда мы перенаправляем ребра.
Значит, у нас в какой-то момент мы перенаправляем все
ребра, ведущие ску, чтобы они теперь вели в клона,
чтобы они теперь вели в клона.
Вот. И это как раз у нас число ребер не меняется,
сколько ребер удалил, столько ребер добавил, поэтому
число ребер не увеличивается, но можно проследить, что
когда я делаю вот это перенаправление, у меня уменьшается
следующий потенциал. Давайте скажем, что потенциал
и это число вершин на пути по совсылкам от максимальной
вершины.
Значит, если раньше у меня была S, да, и какие-то вот
у нее были родители, ну, точнее, путь по совсылкам,
то теперь, когда я пишу СС, изменяю автомат и смотрю
на этот путь по совсылкам, то у меня будет примерно
следующее. Несколько первых вершинок будут иметь ребро
в СС, затем несколько вершинок, начиная с П, будут иметь
ребро в клона, который является совсылкой вершинки СС.
Вот. Ну и так далее оно будет разбиваться вот такими
вершинами, что из них и всех будет ребро в очередную
вершину на вот этом суффиксном пути. И соответственно,
чем больше вершин вот из этого второго слоя я перенаправил,
тем короче у меня будет путь по совсылкам, начиная
от СС, тем короче будет вот этот вот путь. То есть,
чем больше ребер я перенаправил отсюда, ну, точнее, из кув
клона, тем как бы больше у меня вершин вот здесь вот
склеилось в одну, и значит у меня стал этот путь короче.
Путь по совсылкам стал короче. Значит, каждая
итерация вот этого вайла перенаправления ребра уменьшает
длину пути по совсылкам на единицу. Ну и поскольку
он растет на единицу, максимум на единицу за счет добавления
новой вершинки, а убывает каждый раз, когда делает
итерацию цикловайл, значит суммарная итерация цикловайл
вот здесь вот перекопирование будет линейное количество.
Ну все, все остальное это там линейные перекопирования,
которые, понятно, занимает ОАТН. На этом все. Спасибо.
