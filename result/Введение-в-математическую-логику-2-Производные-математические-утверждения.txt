В прошлый раз я замялся, потому что не уточнил, какой
по новому курсу будет форма отчетности.
Форма отчетности – дифференцированный зачет, зачет с оценкой.
Поэтому программа курса, она в общем-то объявлена,
ее можно скачать на сайте кафедры и собственно оценку
вам будут ставить преподаватели семинаров, то есть они я
думаю вам объяснят, что и как делать, я в своей группе
объяснил, ну и в общем, вот так.
Это единственное мое организационное объявление, простое и можно
переходить к сути.
Прошлый раз я напомню, я остановился на том, что
определил способ описания буллевых функций.
Простейший способ – это таблицы значений задать, но есть
более сложный способ – формулы.
И формулы у нас появились в двух разных видах.
Во-первых, я говорил, что формула – это такое бинарное
дерево, корневое, у которого есть в листьях написаны
имена переменных, а в каждом внутреннем узле написана
связка.
Соответственно, оно бинарное, потому что у нас только
бинарные связки.
Ну и по дереву очень легко определить, как вычисляется
значение формулы, когда заданы значения переменных.
Это я в прошлый раз делал, сейчас не буду повторять,
но это я думаю, процедура достаточно очевидна и все
ее запомнили.
Но был второй способ, я сказал, что это определение
логиком кажется недостаточно строгим и надо много чего
математического определять, чтобы это было аккуратно.
Поэтому есть другое определение, это значит слова в алфавите.
Ну алфавит я напишу так, это символы переменных,
это символы для связок, что нам еще нужно и скобки
нам нужны.
Здесь, по крайней мере, нет запятых и немножко легче
хотя бы через запятую можно перечислить и так взять
даже фигурные скобки.
Это вот алфавит, давайте его как-нибудь sigma обозначу.
Алфавит, в котором мы строим слова-формулы, а определение
формулы индуктивное, значит слова длины 1, которые состоят
из переменных, это формулы.
Соответственно если, там не знаю, B и C формулы, то
тут два случая надо рассмотреть, вот такое слово, которое
начинается с открывающей скобки, дальше отрицание
формулы и закрывающая скобка формула и соответственно
то же самое, но только с бинарной связкой.
Значит вот этот кружочек, это любая бинарная связка.
Что у нас там еще было, эквивалентность.
Получаем два разных определения, на самом деле это одно и
то же определение, это определение равносильное, очень легко
понять как по дереву писать формулу, потому что смотрите,
вот у меня связка, вот я теперь смотрю на левую
подформулу, пишу ее здесь и на правую подформулу
пишу здесь.
Здесь вообще писать нечего, а здесь конечно надо еще
потрудиться, потому что будет связка, будет вот эта
вот формула, а здесь нужно еще вот так вот написать.
То есть вот получается формула, совершенно естественное
построение по дереву формулы.
В обратную сторону тоже вроде бы все очень естественно,
но возникает проблема.
Почему, если я имею слово, которое является формулой,
почему дерево получится однозначным?
В случае обратного преобразования вроде бы все очевидно, потому
что вот то, что я написал, это вот, ну тоже можно сказать,
а вдруг мы как-то можем по-другому сопоставить, но это я задал
сопоставление.
А здесь, если задавать сопоставление, мы должны сказать, вот давайте
посмотрим, к какому из трех типов принадлежит формула,
этому, этому или этому, и построим соответствующий
корень дерева, и дальше будем рекурсивно продолжать
в левом и правом потомке, ну или в одном потомке, если
бинарная связка, но проблема в том, что для этого нужно
быть уверенным, что формуле можно однозначно указать
самую последнюю применяемую связку.
Вообще говоря это не очевидно, может быть иначе.
Это утверждение, оно называется однозначность дерева разбора.
Формально у нас будет такая терминология, вот слова
это все-таки вот такое, а деревья будут называться
деревьями разбора.
И вот первая вещь, которую я сейчас хочу доказать,
это однозначность дерева разбора для формулы.
Рассуждение не сложное, но оно очень поучительное,
и к тому же выяснилось, я надеялся, что какие-то
остатки контекстно-свободных языков в курсе алгоритмов
параллельно останутся, но нет, выяснилось, что там
все строго, там будут у вас регулярные языки, а потом
сразу уже такие универсальные модели вычислений, разрешимые
и так далее.
Поэтому контекстно-свободных языков не будет, а на самом
деле вот это вот это, при некоторых уточениях, которые
я чуть позже сделаю, это типичный пример контекстно-свободного
языка.
Ну что это такое, я объяснять конечно не буду, это слишком
долго, но нам нужны будут конкретно вот такие вот
формулы.
Будут немножко более сложные формулы, у них тоже будут
деревья разбора, то есть вот такое определение, что
в нем типично для логики, что вот оно так рекурсивно
и скобки позволяют нам определять структуру, что применяется
в начале, что применяется потом.
И доказательства, которые я расскажу, я не буду уже
повторять для более сложных формул, потому что в сущности
такой же, там только меняются специальные знаки, которыми
помечены вершины дерева.
А сама структура дерева, она определяется скобками.
И тут полезно доказать лему, достаточно очевидную,
что если у нас есть формула, то количество открывающих
скобок равняется количеству закрывающих скобок, ну
в этой формуле, естественно.
Это более-менее очевидное из определения, но давайте
посмотрим, как это доказывается, потому что доказательства
тоже очень получительные, у меня будет много доказательств
такого же типа.
Доказательства фактически индукции по длине формулы.
Длина формулы – это количество символов в ней.
База индукции, естественно, длина 1, переменная, для
переменных эта лемма выполняется, там 0 открывающих, 0 закрывающих.
А теперь шах индукции.
И шах индукции он состоит в том, что если формула
имеет длину больше 1, то должны выполняться вот эти
вот два случая.
Я базу вообще на доске писать не буду для экономии времени,
а шах индукции, он распадается на два случая.
И имеет вид отрицания, и тогда, смотрите, опять-таки
писать нечего.
По индуктивному предположению в Б количество открывающих
и закрывающих скобок одинаково, ну и мы добавили по одной
такого и такого типа, доказано.
Теперь второй случай, когда бинарная связка.
Ну здесь то же самое, в левой подформуле одинаковое
количество открывающих и закрывающих, по индуктивному
предположению и в правой.
Доказательство такой полной индукции, то есть мы считаем,
что для всех меньших длин наше утверждение справедливо.
Ну мы добавили по одной открывающей и закрывающей.
Рассуждение настолько простое, что его можно было
бы очень быстро сказать, словами вообще ничего не
записывая.
Я хочу подчеркнуть, что оно типично и я буду ссылаться
на рассуждение такого типа, как индукция по разбору
формулы.
То есть вот индукция по разбору формулы, фактически
полная индукция по длине формулы, а устроена она
так.
Мы проверяем для самых простых формул, в данном
случае это просто переменные.
В каких-то рассуждениях это может быть даже и сложнее.
А потом мы зная из определения, которое здесь такое, а в каких-то
случаях будет немножко другим, мы рассматриваем возможные
случаи, как вот эта формула может быть устроена, ну
и доказываем утверждение в одном и в другом случае.
То есть это будет типичное для нас рассуждение.
И теперь, наконец, вот эта теорема об однозначности
разбора.
Сейчас я ее докажу, значит она… Для ее доказательства
мне понадобится еще одно понятие – скобочный итог.
Вот давайте вот это, я так нарисую формулу, выберу
какое-то место в ней между символами.
В комбинатуре кислов очень часто удобно указывать
не символ в слове, а положение между символами.
Тогда у нас, во-первых, возникает начальная позиция, конечная
позиция, ну и вот позиции между этими.
И вот скобочный итог, он по определению равен числу
открывающих скобок минус число закрывающих скобок.
Вот до этого места.
То есть мы дошли до какого-то места, прочитали уже сколько-то
символов и считаем разность открывающих и закрывающих
скобок.
Но тут вот, поскольку скобки мы без того используем в
формулах, давайте под индексах что ли напишу, чтобы было
ясно, что я ничего в скобки не беру.
Мне просто на словах я сказал, ну а записывать все эти слова
на доске места немного мне не хочется.
Так вот, что верно?
Однозначность разбора.
В каждой формуле скобочный итог перед любым символом
Давайте я напишу короче любой связкой.
Я имею в виду символ связки, но просто чтобы писать
короче положительный.
И если есть связки, то ровно у одной скобочный итог равен
плюс один.
Вот это и дает нам способ определить самую внешнюю
связку, это и будет самая внешняя связка.
Дальше доказательства однозначности разбора такое, если формула
длины 1, то дерево однозначно строится, потому что у него
все одна вершина, а во всех остальных случаях мы применяем
определение, но такой же разбор по построению формулы
мы находим самую внешнюю связку, она находится однозначно,
потому что это вот и есть та связка, у которой скобочный
итог 1.
Ну давайте в эту сторону посмотрим, ясно, что здесь
скобочный итог 1, потому что перед этим только одна
открывающая.
Здесь может быть чуть менее ясно, но смотрите, здесь
уже одна открывающая скобка появилась, дальше внутри
формулы B они будут прибавляться и убавляться, но они никогда
не станут, по предположению индукции, там никогда не
будет отрицательного.
И когда мы дойдем до конца, у нас вот на этой вот связке,
на всех внутренних связках скобочный итог будет больше
единицы, потому что если верно индуктивное предположение,
что вот эта единичка добавилась, и тут еще будет какая-то
единичка по индуктивным предположениям, значит единственный
случай, когда у нас возможно, это вот когда появляется
связка.
Поскольку вот это свойство, оно не связано с самим построением
формулы, с разбиением на подформулы, то мы и получим
то, что нам нужно, у нас внешняя связка предназначена.
Ну осталось вот это доказательство, на самом деле половину доказательства
я уже сказал, пока вот объяснял, что я хочу потом однозначно
с разбором выводить.
Потому что, смотрите, доказываю это утверждение опять-таки
разбором.
Ну вот я сейчас повторю то, что я говорил, но уже
ровно про это рассуждение.
База понятная, там скобок нет, все выполняется, связок
нет, все выполняется.
Теперь шаг индукции, предположим, у нас есть какая-то формула,
если она имеет вид вот такой представлено, то мы знаем,
что у этого символа связки скобочный итог один, а дальше
для всех символов связки внутри подформулы B скобочный
итог будет уже положительный.
Больше единицы, извините, потому что по предположению
индукции он положительный, но у нас еще добавилась
вот эта единичка, и она, когда мы смотрим на позиции
внутри подформулы B, эта единичка дает нам увеличение
на один, значит плюс один уже никак не будет, будет
больше.
Ну и все, а потом, конечно, скобочный итог станет равным
нулю, когда мы прочитаем последнюю скобку.
И здесь такое же рассуждение.
Единственное, что теперь у нас нет вот этой вот связки,
мы начинаем читать открывающую скобку, потом подформулу,
когда мы читаем подформулу, там скобочный итог каждой
связки будет положительный, и на самом деле больше единицы,
потому что у нас уже единицы еще есть.
Только когда эта формула будет полностью прочитана,
скобочный итог равен нулю, значит, поэтому скобочный
итог вот этой связки будет ровно плюс один.
Вот эта вот скобочка, она останется, она же не входит
под счет скобок внутри формулы B, поэтому она даст
плюс один.
Ну вот, в общем-то, и все, и все доказано, то есть я
не так мало времени потратил, но мне хотелось, чтобы это
было ясно.
Я потрачу даже еще чуть больше времени, потому что я хочу
сказать, сделать замечание, что это не просто теорема,
она дает эффективный алгоритм.
То есть если у вас есть слово, которое задает формулу,
вы можете действовать таким способом, эффективно найти
внешнюю связку и начать строить дерево рекурсивно.
Нашли внешнюю связку, это корень дерева, потом рекурсивно
вызывает алгоритм разбора на левой подформуле и на
правой подформуле, получается там два под дерево, ну или
одно, если связка лонарная.
Тут только нужно говорить вот что, смотрите, у нас
алфавит, у нас алфавит бесконечный.
И это для алгоритмов не очень хорошо, потому что
мне очень понятно, как на вход алгоритму компьютеру
подать символ бесконечного алфавита.
Ну нет у нас компьютеров, которые могут читать символы
из бесконечного алфавита.
Ну эта проблема решается понятно, как бесконечный
алфавит надо кодировать в конечном, а потом в конечном
счёте в унарном. Конечный алфавит, который я буду
всегда подразумевать в таких случаях, он такой.
Вот эти символы переменной заменяются на символы
решётка 0, 1. Дальше всё то же самое, там меняться
вообще ничего не будет. И когда у меня есть символ
x этой формули, он будет меняться на вот такое слово, значит,
а потом двоичная запись индекса и. Понятно, что если
я сделаю такие замены, они обратимы. Когда я буду
читать соответствующее слово, если я вижу решётку,
мне надо дочитать все 0, 1, которые после решётки
стоят до любого следующего символа, отличного от 0,
1, и превратить эту запись в число и я буду знать,
что там написано переменная x. То есть это вполне такой
конструктивный, эффективный способ кодирования формул.
Ну а чтобы закодировать двоичного алфавита, ну там
можно любой конечный алфавит, можно всегда то, что называется
блочное кодирование. Давайте вот я тут sigma f тогда напишу.
Выбрать достаточно большое k, ну чтобы 2 степени k было
больше размера алфавита, и кодировать как-то, построить
то, что называется инъекция. То есть для каждого символа
алфавита выбрать ровно одно слово длины k.
У решётки смысл такой, что он указывает, что это
начинается описание переменной. У нас переменных бесконечно
много, мы должны как-то в конечном алфавите это
бесконечное множество задавать. Ну это такой простой способ,
решётка как указатель, что в этом месте стоит переменная,
а какая переменная дальше записана двоичной записью.
Ну у нас будут более сложные случаи, когда такие переменные
могут иметь два индекса, ну я думаю понятно, что нужно
сделать. Нужно поставить одну решётку, первое число,
второе, второе число. Думаю, что вам понятно, что такие
не сложные проблемы с кодировками решаются. Я буду немножко
уточнять, но основная идея дальше, я сейчас потратил
довольно много времени, а потом я буду уже достаточно
быстро объяснять, как именно мы кодируем какие-то более
сложные формулы, потому что идея, она будет той же
самой. То есть в конечном счёте мы всё можем закодировать
двоичные слова, ну и понятно, что вот этот алгоритм будет
работать эффективно, потому что, смотрите, ну читать
блоки по k, где k константа, это вообще не проблема, это
эффективное действие. Вы прочитали, дальше просто
написали разбор случаев, что вы видите на этом месте.
То есть можно считать, что ваша программа читает
сразу символы из этого конечного алфавита. Ну и
дальше, что нужно делать, надо прочитать, следить за
скобочным итогом, то есть вы двигаетесь по слову и
каждый раз считаете, вы дошли до символа связки, какой
в этот момент скобочный итог. Как только он стал
равен плюс один, отлично, вы знаете, что у вас слева
должна быть подформула, справа должна быть подформула.
Применяете рекурсивный алгоритм к построению дерева.
Если вам нужно вычислять потом значения, то это вот
как я объяснял, если у вас еще есть набор значений
для переменных, вы потом на этот набор смотрите и
наоборот двигаясь от листьев к корню вычисляете значение
формулы. Ясно, что это эффективно, ну по крайней мере в этом
случае для более сложных формул это уже вопрос не
столь простой, но здесь это эффективно, то есть это
дает нам эффективный алгоритм и разбора и вычисления значения
формул. Хорошо, давайте продвинемся
чуть дальше про формулы. Это еще не все, что я хотел
сказать про формулы. У нас в результате сейчас есть
два языка описания булевых функций, один таблицами значений,
другой формулами. Чем удобнее формулы, как я говорил уже
в прошлый раз, они удобны тем, что позволяют компактно
задавать функцию. Задание таблицами значений требует
всегда указания два в степени n, то есть строка длины два
из битов вам нужна как в любом случае. А формула
может быть гораздо короче. Там не требуется перечислять
все возможные значения переменных, а вот это вот
дерево, которое разбора формулы, оно дает просто
рецепт как вычислять значения, он может быть намного короче.
Но это плюс, но есть минус. Таблица значений функции
определяет однозначно. А формула нет. Сейчас появятся
примеры, но я думаю вам и так это понятно. Потому
что для связок выполняются разные итогиства. Понятно,
что если вы используете итогиства, у вас получится
равносильная формула, которая имеет те же самые значения.
И уже нетривиальным становится вопрос о том, какие формулы
представляют очень простые функции. На самом деле самую
простую. Самая простая функция тождественно равна единице.
Что? Сейчас я скажу. Нулю тоже можно, но так вот получилось.
Я объясню почему единица. Давайте я напишу определение.
Это правильно. Но 0 и 1 не очень сильно различаются,
я сейчас скажу. Просто для нуля нам будет удобнее немножко
другое понятие сейчас. Формула Тавтология, если она принимает
значение 1 для всех x. То есть задает просто тождественно
равную единице функцию. И Тавтологии очень много.
Давайте я сразу приведу пару примеров, потом мы их немножко
будем обсуждать. Вот, например, x или не x. Или
x и из x следует y и из всего этого следует y. Вот примеры
Тавтологии можете проверить. Как проверять я обслужу
чуть позже. Значит, и родственное понятие, вот возвращаясь
к нулю. Такое, phi выполнимое, если phi от x равно единице
хотя бы для одного x. Почему так? Я напомню, что в прошлый
раз мы уже обсуждали смысл нуля и единицы в логике.
Единицы мы кодируем истину, а нулем ложь. Тавтология
это не случайно называется Тавтология. Это то, что верно
всегда, какие бы вы не подставили логические значения вместо
переменных, у вас все равно получится истина. И есть
такой основной смысл слова Тавтология, он в обыденном
языке носит скорее отрицательный характер, а для логики это
наоборот очень важное позитивное понятие. Но часто нам бывает
нужно другое, выполнимое. Вот у нас есть какие-то
логические условия, мы хотим проверить, можно ли их выполнить.
Тогда нас интересует другое, как приписать логические
значения переменным, чтобы получилась наша формула равная
единице. Например, формула задает условия, там какая-то
сложная промышленная установка взрывается, есть ли то-то, то-то,
то-то и то-то. И это практически важный вопрос, есть ли набор
значений в оливах переменных, при которых установка может
взрываться. Потому что если есть, надо как-то специально
их отслеживать по мере того, что параметры приближаются
к этим опасным значениям, что-то все-таки предпринимать
до взрыва, а не после. Ну, это такой простой пример.
Ну, в общем-то, я думаю, понятно, что это тоже с точки
зрения содержательной вроде бы полезная вещь. Теперь
возвращаемся к разговору про тождественно равную
нулю функцию. Ну, ее логики скорее назовут противоречием,
потому что простейший пример такой функции – это
х и не х. Ну, вот она всегда равна нулю, как нетрудно
догадаться. И она вроде бы тоже не менее важна, но
есть очень простая связь. Значит, смотрите, если фи
тавтология, то это равносильно тому, что отрицание фи равно
нулю для всех х. То есть, если вас интересует вопрос
от автологичности, а вы умеете отвечать на вопрос
о том, что функция тождественно равна нулю, ну, привесьте
отрицание, и будет вам то, что нужно. И в обратную
сторону, потому что отрицание, понятно, оно просто инвертирует
бит, поэтому это вот переход в одну и в другую сторону.
Ну и эти две связанные, связаны похожим образом. Фи тавтология.
Значит, да, на самом деле, если равна нулю, это по
сути дела, это как раз отрицание выполнимости. То есть, не
фи от х невыполнимо. То есть, вот тут я перепишу это
логически более важная вещь, что отрицание фи невыполнимо.
Это очень простые преобразования формул. Навесить отрицание
никогда несложно. И поэтому переход от вопросов к выполнимости
и тавтологичности, но с точностью до замены, равносильно от
тавтологичности невыполнимость. И, соответственно, не тавтологичность
и выполнимость. Но сам переход простой, поэтому, вообще говоря,
из всех этих понятий можно оставить одно. Логики оставляют
тавтологии по очень важной причине. У связок, когда я
их определял, я думаю, вам было понятно, может быть,
я даже про это успел сказать. У связок есть простой логический
смысл. Они отвечают за некоторые наши конструкции,
которые мы делаем, как мы составляем составные
высказывания. А тавтологии отвечают за законы логики.
Вот левая тавтология. Что это такое? Х или не х? Это
то, что логики называют закон исключенного третьего.
Если у вас есть высказывания, то вы твердо уверены, что
оно ложно или оно истинно. Поэтому выполняется тавтология.
Не все логики с этим согласны, и математики некоторые
считают, что нет такого логического закона, и там
возникает своя логика, но ее мы обсудить, пожалуйста,
вообще не успеем, но посмотрим, если и будем, то существенно
позже. Сейчас у нас классическая логика, это выполняется.
Вот это называется modus ponens. Ну, modus ponens формально
будет у нас называться немножко другая вещь, когда мы дойдем
до выводимости, но можно эту тавтологию называть
modus ponens. Ее смысл тоже, содержательность совершенно понятен. Как
устроена математика? Мы доказываем условные утверждения.
Если х, то и у. А дальше мы берем какой-то запас утверждений,
про которые мы говорим. Вот эти утверждения заведомо
истиной. И из этих условных утверждений мы получаем
истинность еще огромного количества других утверждений.
Вот так с высоты птичьего полета выглядит математика.
И в основе этого приема лежит как раз эта тавтология.
Смотрите, если х истинна, то вот эта импликация упрощается
до у, мы получаем, что из у следует у. Если х ложна,
то вообще посылка ложная в импликации, импликация
истина. То есть наше рассуждение основано на том, что если
мы уже как-то получили х и из х следует у, мы можем
смело сказать, что у тоже есть. Ну и примеров очень
много. Я не буду приводить еще примеры. В общем-то их
можно продолжать. Что-то, наверное, на семинарах будем
разбирать. Потом, когда дойдем до выводимости, там появятся
еще примеры. Но это, конечно, только частный случай
логических законов. У меня все-таки цель как можно
быстрее перейти к самым общим логическим законам.
Объяснить, что такое закон математической логики.
Не вообще любой логики, потому что люди изобрели
много разных логик. Ну, как оситрина, вы знаете, бывает
первой свежести, второй свежести, ну вот тут примерно
так же. То есть есть логика, есть вот математическая
логика, а дальше люди начинают фантазировать разные другие
логики. При этом в математической логике изучают совершенно
другие системы. Как я сказал, никто вам не гарантирует,
что в статье по математической логике выполняется закон
исключенного третьего. Наоборот, если там где-то
в названии стоит интуционистская логика, вы можете смело
знать, что там никакого исключенного третьего
нет. Там игра идет по другим правилам. Ну вот, я к тому,
что возникает теоретически важная задача. Какие вообще
формулы являются тавтологиями? Какие у нас бывают законы
логики хотя бы такого вида? Ну и учитывая связь с выполнимостью,
это тоже естественно. Вот мы хотим узнать. Ну ладно,
про взрыв это я для драматизма сказал. А типичная задача
из индустрии такая. У вас есть описание микросхемы.
Ну там миллион вентелей. Каждые вентели могут находиться
в состоянии 0.1. И у вас получается формула из миллиона переменных,
которая описывает, что собственно эта микросхема делает.
Конкретно инженеры ее так будут паять. А вам нужно
проверить, что эта микросхема вычисляет сложение чисел.
Если на входы поданы два массива битов, то на выходе
будет именно сумма их, если смотреть на это как на представление
чисел. Ну или еще какую-то функцию. Потому что никто
же не обещал, инженеры могут ошибаться. Они вот написали
какие-то схемы. А что реально происходит? Ну из какого-то
конечно здравого смысла. Но что реально происходит?
Мало ли где-то человек ошибся. Поэтому возникает вопрос
как проверить такую формулу. Саму формулу в результате,
когда инженеры принесли свое описание, можно автоматически
построить по этому описанию. Никакой проблемы нет. Она
будет очень большой. На диск влезет. Миллион переменных.
Но формула будет 100 миллионов. Ну поместится. Там небольшой
файл получится. Ну надо проверить, выполнима она
или нет. Ну или тавтологично это значит, что все условия
выполнены и функция работает правильно. И как это делать?
Ну один способ мы знаем. Можно используя определение
выписать таблицу значений и проверить, что в ней встают
только единички. И чем плохо этот способ совершенно
понятно. Если у вас миллион переменных, два в миллионной
вы уже не выпишете никогда. Ни в одном месте, ни просто
у вас не будет времени столько. Есть второй способ, который
я уже сейчас проиллюстрировал, вот когда я обсуждал почему
вот этот тавтология. Частичный разбор. То есть мы берем
какую-нибудь переменную и присваиваем ей два возможных
значения. Скажем, беру переменную х. Она может равняться нулю,
может равняться единице. Дальше формулу можно упростить.
Если х равняется нулю, мы подставляем формулу, части
формулы начинают упрощаться. Вот смотрите, если здесь
ноль, то вообще вся эта конъюнкция ноль. И у нас получается
формула из нуля следует игре. И тут опять-таки есть тождество
упрощения. Мы знаем просто, что значение тут равно единице.
Уже про у нам ничего знать не нужно. Ну а если единица
получается чуть сложнее, но это тоже довольно простой
случай. Его конечно придется здесь разбирать. То есть вот
чтобы увидеть. Неравномерное дерево разбора. Ну вот оно
какое-то такое. Из этого примера видно, что выбирая
разные переменные, вообще говорю, у вас будет получаться
разное частичное дерево разбора. Ну и нужно как-то
говорить правила, как мы применяем упрощение.
Это пока только голая идея, как устроим частичный
перебор. Ну ее можно довести до конца, и она в принципе
лучше, чем полный перебор, конечно, чем составление
таблицы значений. Иногда лучше, иногда нет. И все равно
обычно не очень хорошо. Позже мы узнаем очень хороший
способ проверки тавтологичности, который основан как раз
на логическом выводе. Точнее, особо хорош он в сочетании
как раз частичным разбором. Это то, на чем основаны
современные программы, из-за которых задача проверки
тавтологичности формул, ну на самом деле скорее выполнимости,
но считается не очень трудной. Считается, что для индустриальных
приложений эти современные программы работают достаточно
хорошо. Но я должен подчеркнуть, что это иллюзия. Эти программы
они так устроены, что, ну, уже совсем сложные программы
я не буду утверждать, что можно прям точно все доказать,
но основной принцип, который лежит в основе этих программ,
его можно проанализировать и убедиться, что не на всех
формулах все так хорошо. Иногда вот такой способ
тоже дает очень большое время работы, сравнимое
с построением таблицы значений. То есть там что-то типа,
какая-то экспонента степени n. Ну и возникает вопрос,
а можно ли лучше? И на этот вопрос наука ответа не
знает. Это по сути дела примерно то же, что одна из знаменитых
задач тысячелетия, за которые там институт Квея
миллион долларов дает. И в общем-то современные
специалисты в теоретической информатике считают ее
безнадежно трудно. То есть никаких перспектив решения
в обозримом будущем нет. То есть, но поскольку люди
над этим долго думали и ничего не придумали, считается,
что эта задача с теоретической точки зрения трудная. Мы
не только не знаем алгоритма, который бы эффективно ее
решал, но у нас нет никаких идей вообще как такой алгоритм
построить. То есть все подходы, которые есть, они заведомо
будут давать алгоритмы, которые в худшем случае экспоненциальны.
Ну это про сложность алгоритмов я уж точно подробно рассказывать
не буду, я просто хотел бы, чтобы вы понимали вот эту
ситуацию. Как раз с точки зрения проверки тавтологичности
формул сейчас есть разрыв между теорией и практикой.
С точки зрения практики эта задача хорошая, потому
что люди придумывали много хороших алгоритмов ее решения.
Но в принципе теория говорит нам, что эти алгоритмы будут
не всегда хорошо работать. И проблема понятна, вы не
знаете, когда у вас возникло, инженеры вам принесли описание
микросхемы, вы не знаете, сработает она на нем или
нет. Ну вроде выработала, на похожих работала, но
конкретно на вашей может заткнуться и никакого ответа
не дать. То есть никакой гарантии, что на конкретно
том входе, который вам принесут, будет получен
результат, нет. Это важно понимать. Трудность понимается
в основном в таком виде. Хорошо, это вот значит я немножко
забежал вперед, чтобы тему вот округлить вот эту с
булевыми формулами. Но пора двигаться дальше. Пора
переходить к более сложному формализму и научиться
математически задавать произвольные математические
утверждения. Я вам это обещал с самого начала. И более
менее ясно, что булевые формулы для этого слишком
слабый способ. Они что-то говорят о конечном множестве.
Понятно, переменные принимают конечное множество значений.
Ну вот об этом конечном множестве булевая формула
вам может что-то сказать. Да и то, если формула не
очень длинная, тоже это немножко сложно, я не буду
говорить подробнее, но легко написать утверждение
о конечных объектах, про которые никто не знает,
можно ли их задать коротко формулами и утверждениями
о формуле типа тавтологичности, выполнимости или нужны
существенно более сложные утверждения. А тогда, если
нужны существенно более сложные утверждения, все
равно, что мы расширяем язык описания булевых
функций, непонятно в какую сторону. И то, что на самом
деле делают люди, они используют как раз идеи из более общего
способа, который приходен в гораздо более широком
контексте. Вот к нему мы сейчас и перейдем. Это
формализм получается довольно громоздкий, я не буду спешить,
потому что формально можно определение минут, наверное,
за 15 все написать, но они будут абсолютно непонятны,
все равно их придется потом истолковывать. Поэтому
давайте действовать индуктивно. Вот представьте, у нас есть
задача, мы хотим научиться как-то формально фиксировать
математические утверждения. Что нам для этого нужно?
Почему не хватает высказываний? Потому что высказывание
непонятно о чем, это оно истинное или ложь, а о чем
оно вообще сделано. Математики всегда высказываются о
чем-то, о каких-то объектах. Ну, например, давайте посмотрим
типичный пример математического высказывания. Четыре меньше
семи. Это истина или ложь, да? Если я поставлю любые
два числа, это будет истина или ложь. И это высказывание
значит оно истинное или ложное. Или четыре является
делителем семьи. То же истина или ложь. И сложные математические
высказывания, они где-то там внизу должны содержать
вот какие-то такие простые. Потому что в конечном счете
сама структура высказывания может быть существенно
сложнее, чем вот такое примитивное указание, что там два объекта
сравнили. Но в конечном счете нам нужно про какие-то
объекты говорить, как они соотносятся между собой.
Вот эти примеры, сравнение чисел или делимость целых
чисел, это примеры того, что математики называют
отношениями. А логики любят слово предикаты. Предикаты
отношения это синонимы. Я буду стараться говорить
отношения, когда говорю о семантике и предикат,
когда говорю о синтаксе. Но, конечно, могу сбиваться,
потому что очень легко запутать. Отношение на множестве,
ну давайте, каком-нибудь m, это просто-напросто под
множество, но не самого m, а некоторой его декартовой
степени. Тогда это отношение называется коарным. Такое
название есть унарные отношения, бинарные отношения, тернарные
отношения, и многие люди предпочитают в общем случае
говорить о коарных отношениях. А некоторым это странное
ублюдочное слово не нравится, и они говорят, что есть валентность
k и отношения валентности k. Но вроде как по-русски
звучит глажа. Что? Не понял. И валентность, но все равно
валентность нужно называть, понимаете. То есть отношения
валентности k и k отношения это то же самое, но слово
длиннее. Ну и предикат это то же самое, я буду иногда
говорить, что это предикат. Вот примеры. Меньше это
под множество, скажем, действительных чисел. Делимость, пар действительных
чисел, делимость это под множество. Ну давайте на целых числах
это в принципе можно определить. Так, сейчас перерыв. Давайте
в этом месте прервемся. Про отношения я еще не все
сказал, но это довольно естественная точка для перерыва. Я определил
отношения. Причем, заметьте, в примерах я использовал
запись отношений такую инфиксную, как говорят, когда символ
отношения стоит между объектами, которые находятся в отношении.
Это удобно для бинарных отношений иногда, неудобно
для тернарных, в общем даже не очень понятно где этот
символ ставить. Поэтому, когда мы будем задавать, у нас
дальше будет в основе нашей формализации будут лежать разные
предикаты. И вот тут давайте я напишу где-нибудь справа. Значит, это еще пока
такой синтаксис, давайте я возьму в кавычке, это не строгие определения, я
просто буду объяснять, как я дальше буду писать формально предикаты. Вот это будет
выглядеть вот так вот. Тут многоточие, это не синтаксический знак, это может быть
много переменных, то есть карное отношение надо указать много переменных. Вот это
вот символ отношения, а это переменная. Этого нам будет недостаточно, сейчас я
буквально через пять минут уже объясню, чего тут не хватает.
Ну вот у нас запись будет именно такой, то есть имя предиката дальше в скобочках
через запятую список аргументов, которым относятся эти предикаты. Ну в общем, в языках
программирования так задаются и функции, но на предикаты или на отношения можно
смотреть как на функцию с значениями 0,1, потому что если вы взяли какой-то набор
значений переменных и спрашиваете о значении предиката, отношение либо истинно
либо ложно, но можно считать, что предикат вам отправляет этот набор значений
переменных 0,1. То есть на предикаты можно смотреть как на функции с
логическими значениями или на отношения тоже самое. Еще такое не очень важное
замечание, но полезно сделать, что будет если k равно нулю. Тогда у нас есть ровно
два. Да, у нас получается так, что тогда у нас есть ровно две возможности. Предикат
либо должен быть всегда истинным, либо всегда ложным. То есть нулярный предикат
это просто логические значения, истинно или ложно. Никаких аргументов нет, всегда
должно быть что-то одно. Их всего два, вот они такие. Ну и с предикатами можно
выполнять разные операции. Например, это же множество. Вот я беру там один предикат и
другой предикат. Ну и как обычно могу записать объединение этих множеств. Тогда тоже будет
предикат по определению. Формально он будет записываться как-то вот так. Значит, что такое
объединение? Дизьюнция. То есть мы знаем, что между теоретико-множественными и логическими
операциями есть соответствие, поэтому когда мы выполняем какие-то теоретико-множественные
операции с предикатами, мы получаем более сложные предикаты, и они записываться будут уже как раз
булевыми формулами, потому что в булевых формулах как раз есть вот эти связки. То есть вы видите,
почему я так про булевую формулу долго говорил, потому что они нам все равно будут нужны. Один из
способов построения новых предикатов это как раз брать какие-то вот такие логические условия,
ну или теоретико-множественное это обсуждать. Причем возможны, конечно, ситуации, когда предикаты
разной арности. Какое-нибудь такое условие я могу написать. Этот предикат бинарный, этот унарный,
и такое тоже вполне возможно. Получится какой-то предикат, который зависит от тех переменных,
которые в него входят. Ну зависит как? Зависит формально. В принципе, я могу вот так вот записать,
я могу написать r там от x1 xk, а потом сказать, а этот предикат тождественно истинный. Это не
возбраняется. Под множество может совпадать со всем m степени k. То есть тут надо различать
существенные переменные и формальные зависимости. Конечно, в синтаксисе мы можем только за
формальными зависимостьми следить. Ну это что касается предикатов. И в сущности наша идея
состоит в том, чтобы строить разные предикаты. Брать какие-то за основу и строить новые. И бунт
получает то, что отвечает математическим утверждениям. Ну когда они станут уже нулярными предикатами.
В чем проблема? Значит, ну проблем две. Во-первых, как из бинарного предиката сделать нулярный,
например. А вторая проблема состоит в том, что видно, что выразительные средства,
которые мы задаем предикатами, они не очень удобны. Когда мы говорим о математике, у нас есть еще
желание не только сравнивать объекты, что находятся ли они в отношении, но и выполнять с ними действия.
Давайте я напишу какой-нибудь типичный пример. x2 плюс 1 равно нулю. Это некоторое утверждение,
у него входит неизвестное нам число и экспериментное. Но равенство это, конечно, предикат. Это важный
предикат. Равенство, он тоже бинарный, тоже записывается обычно инфиксно. Но здесь написано
что? Написано константа. То есть нам бывает удобно каким-то объектам специально присваивать
отдельные имена. Ну вот в арифметике и в алгебре очень часто бывает удобно иметь 0 и 1. В левой
части возникает другая константа 1. Вот это вот константы. Их полезно в формализм вести. Ну и
вот это константы. Ну это предикат, это мы уже знаем. А что еще тут есть? Тут еще есть плюс и вот
этот вот квадрат. Что это такое? А это функция. То есть у нас есть возможность делать утверждение
о некоторых таких преобразованиях. Берем сколько-то объектов и из них изготавливаем
новый по определенному правилу. Ну скажем складываем. Функция это... Мы под функцией всегда
будем понимать тотальную функцию. Ну в этом контексте этого формализма. Которая действует из
катой декартовой степени в m. И тогда функция называется тоже k-арная. Так же как и предикаты.
То есть k указывает на количество аргументов. Тогда на константы можно смотреть вообще как на
нулярные функции. Аргументов нет, а значения есть. А минус этого скорее синтоксический. Как
записываются функции? Функции записываются похожи на предикаты и совсем похожи на то,
как мы это делаем в языках программирования. То есть имя функции дальше в скобках через
запятую параметры. Но если бы мы константы... А константы записываются просто буковкой какой-нибудь.
Если бы мы считали, что константы это просто нулярные функции, нам пришлось бы задавать более
сложный способом константу имя и пара скобок. Но это как-то не хочется писать. А на самом деле
есть более важные причины. И константы и функции. Без них можно обойтись. Мы позже наверное это
обсудим, что в нашем выразительном формализме выразительные возможности функций можно имитировать
предикатами. Примерно понятно как. Если у вас есть функции, вы можете задать k плюс одинмерный
предикат, что k плюс одно число принадлежит графику функции. То есть значение функции от первых k
аргументов равно k плюс первому числу. И в общем-то более-менее ясно, что это то же самое. Но что
такое функции? График функции и функции более-менее одно и то же. Но оказывается, что для чисто
логических целей, которые относятся не к выразимости, а к доказательствам, к выводимости,
удобно иметь функции константа. Но это будет у нас еще не скоро, поэтому я сейчас только таким
коротким замечанием на этот счет ограничусь и не буду пока это продолжать. Но зато когда у нас
появляются функции, становится ясным, что вот это вот представление, что мы будем предикаты задавать
вот так, оно немножко примитивное. Потому что вот на эту запись можно смотреть как на предикат от
одной переменной. То есть это унарный предикат. Он зависит от x. Возьмете какой-нибудь x, подставите,
получится верное или неверное равенство. Но его уже вот в таком виде не представить, потому что
переменная x одна, а тут еще много чего наворочено. Нам в окончательном формализме придется уметь
вот такие вот вещи. То есть формально нам нужно написать что-то такое, там ноль, и дальше вот что-то
такое сложное, отвечающее сложению и возведению квадрата единицы, а не переменным. И соответствующий
синтоксический объект у нас появится. Сейчас я про него подробно говорить не буду, потому что
содержательно понятно, что я хочу сказать. Я хочу сказать, что если у нас уже есть какие-то
функции, мы можем одну функцию подставлять в другую, подставлять в них константы, то есть получать
функции от другого числа переменных в результате. А формально это называется термой. В следующий раз,
я когда буду давать аккуратное определение, мне это слово придется использовать, и оно создает
определенные трудности в понимании формального определения. Но сейчас я просто хочу указать,
что у нас в синтаксисе будет вот описание таких атомарных высказываний, с которыми мы будем
делать. Оно будет чуть более сложным, чем просто имя предиката и имена каких-то объектов переменные,
потому что вместо переменных могут стоять какие-то сложно сочиненные конструкции,
когда мы переменным еще что-то такое применяем. Ну, функции сильно расширяют наши возможности
выразительные, хотя, как я сказал, по сути дела ничего не расширяет. Вот что точно расширяет,
то есть у нас есть логические связки, есть функции, но это, как мы увидим, так по сути,
то есть это создает удобство, но не меняет, по сути, выразительные силы. А вот что меняет
выразительную силу, это вот что. Если у нас есть только выражение того вида, про которое я сказал,
совершенно непонятно, как очень простые математические высказывания в ним ими записывать. Ну,
например, уравнение x2 plus 1 равно 0 не имеет решения в действительных числах. Это типичное
утверждение, которое в математике встречается. Чего нам не хватает? Уравнение само мы задать
можем, но когда мы говорим не имеет решений, мы еще что-то делаем. Мы делаем суждение о всех
возможных значениях переменных. И фактически мы утверждаем, что для всех, давайте вот этот
предикат сложно сочиненный, я как-нибудь назову E от X, и мы фактически делаем утверждение,
что E от X сложно, ну или отрицание E от X истинно для всех x. Это очень типичная математики форма,
вы с ней заведомо сталкивались, и нам потребуется соответствующая операция с
предикатами, которая называется навешивание квантора. Сейчас прямо напишу название.
Навешивание квантора состоит в том, что мы записываем формально, вот я уже и на той
доске напишу, потому что это элемент синтаксиса. Вот это уже будет кодировать высказывание,
что то, что стоит под квантором, истинно при любом значении X. И заметьте, что вот если этот
предикат был унарный, то этот предикат уже становится нулярным. Почему? Потому что в этом
высказывании мы говорим сразу обо всех возможных значениях X, поэтому от конкретного значения X оно
зависеть не может. Значит оно не вообще, поскольку там только от X было зависимое, значит итоговый
предикат он нулярный, то есть истина или ложь. Ну и в данном случае мы знаем, что это истина,
бывают ложные высказывания. То есть у нас появляется такой вот способ навешивания квантора. Это
операция с кванторами, которая по предикату, давайте я как-нибудь запишу, переменные для
наглядности назову по-разному. X и еще сколько-то там N переменных Y. И вот я сопоставляю, навешивание
квантора сопоставляется, это N плюс один арный предикат. А я сопоставляю ему N-арный предикат,
который уже зависит только от значений Y. Тут X надо конечно добавить, прошу прощения. Это
вот высказывание того типа, который я сейчас сказал, что для всех X выполняется то, что написано под
квантором. Но там могут быть другие переменные, то есть это вообще говоря может быть предикат,
но арность предиката при этом уменьшилась. Если мы навесим достаточно много кванторов,
из любого предиката мы получим просто истину и лёгушу. Ну и есть другой важный способ навешивать
квантор, который мы будем использовать, навесить квантор существования. То есть высказать такое
осуждение, что для какого-то X наш предикат истинный. Помните, когда я говорил про автологичность и
выполнимость, это очень похожая ситуация, типичный пример квантора существования и квантора
всеобщенности. Что это называется? Квантор всеобщенности, а это называется квантор существования. И тот и другой
уменьшают арность предиката. Увеличивается арность предиката очень просто. Вы можете,
вот как вот в этом примере я писал взять предикат и там, ну тут же может вообще стоять, скажем,
X3. Был унарный предикат, был бинарный предикат, я записал вот такое выражение, он стал тернальный.
А уменьшается вот как раз у нас, по крайней мере в нашем формализме, он уменьшаться будет
именно применением кванторных операций. В каком смысле формальная? Тут давайте у нас,
поскольку мы еще и говорим про формализацию, нужно как-то уточнить ваш вопрос. То, что я сказал,
это математическое определение. Я описал как, вот у меня есть известный мой предикат, и я
описываю новый. Он однозначно определен этим правилам, что я сказал. Если заданы значения Y,
то вот этот предикат истинный, если исходный предикат истин при любом значении X. И ложный,
если хотя бы при каком-то значении X он ложный. С квантором сочетания наоборот. Он истинный,
если хотя бы при одном значении X истинный. И ложный, если при всех ложных. Это математическое
определение. Формализм, мы просто будем использовать вот такие записи в качестве формул.
Смысл их будет вот ровно тот, который я сказал. То есть, с точки зрения семантики,
я дал определение, как устроен такой предикат. А если вы уточните вопрос и скажете,
как, чего более формального вы хотите, я попробую на него ответить.
Ну, оценки переменных у нас появятся. Смотрите, тогда вы говорите вот о чем. Я
пока не дал определение, с какими формулами мы будем иметь дело. Я пока рассуждаю
содержательность семантически. У меня есть предикаты, я с ними выполняю какие-то операции. Вот
это сейчас еще не синтаксис. Я на правой доске просто отмечаю, какие у нас будут возникать
элементы в синтаксисе. Определение я не дал. Формулы первого порядка, которая состоит из этих
выразительных средств. Как ее оценивать, тем более не дал. Это пока рано. Прежде чем говорить об
этом, нам нужно еще продолжить на семантическом уровне разговор, потому что иначе значение формулы
не припишешь. Это тогда другая проблема, что вы сейчас сразу хотите, чтобы речь шла о формулах,
но я не хочу торопиться. Я мог бы сейчас прямо определить формулы, начать говорить о них,
но давайте все-таки лучше в том порядке, в котором я иду. Смотрите, нужно расставлять
приоритеты. Наша основная цель – это формализовать математические утверждения. Поэтому первое,
что мы хотим сделать – научиться выражать математические утверждения в каком-то формальном
способе. Для этого нужно вначале развить этот формализм и отталкиваться надо от содержательных
утверждений, потому что если в содержательных утверждениях есть что-то более сложное, чем мы
запасем в формализме, то нам будет трудно. Поэтому я хочу продолжить все-таки сегодня разговор
про семантику, а в следующий раз уже более аккуратно говорить про синтаксис. Он, конечно,
будет связан с семантикой, значение формулы надо будет определять. Само определение формулы не
очень длинное, но давайте лучше пройдемся чуть дальше. Дальше из всех этих элементов, которые
я сказал, собираются, это в общем-то даже не только в логике. Есть такая абстрактная алгебра, которая
очень близка к этому. Собирается то, что мы будем называть моделью. Что такое модель? Модель – это
множество, причем мы договоримся, что оно всегда не пустое. Если у нас есть модель, это называется
носитель модели, и он должен быть не пустой. Множество, сколько-то предикатов. Вообще говоря,
может быть даже бесконечно много, но я напишу конечное число тут. Какое-то множество предикатов,
какое-то множество функций и какое-то множество константов. Вот это и есть модель. Множество и
какие-то простейшие вещи, которые мы про элементы этого множества можем делать. Мы можем делать
высказывания, которые зафиксированы в этом списке, применять вот эти функции, и у нас для каких-то
элементов это множество есть зарезервированные имена. Вот это все называться будет сигнатурой.
Нет, переменные в модель не входят. Мы считаем, что у нас достаточно большой запас переменных в
любой модели. То есть мы себя в количестве переменных не ограничиваем. А в базовых предикатах,
из которых мы что-то хотим выражать, мы себя ограничиваем. Дальше возникает то, что можно
назвать алгебра предикатов. Вот у нас есть базовые предикаты и функции, и мы из них,
используя вот эти средства, которые я сейчас описал, можем строить новые предикаты. Можем
брать какие-то булевые формулы, они будут задавать новые предикаты, можем навешивать
квантры и так далее. Получается гораздо больше множество предикатов. И вот это называются предикаты,
выразимые в модели. То есть когда зафиксирована модель и зафиксирован вот этот формализм,
ну в следующий раз мы доопределим аккуратнее, но уже сейчас ясно, какие операции мы выполняем,
то возникает вопрос, на самом деле ясно, я немножко лукавлю, может быть я успею сегодня
прокомментировать точнее, а может быть уже в следующий раз. В общем, пока такое не до конца
формализованное понятие алгебры предикатов, предикатов выразимых в данной модели. Давайте
посмотрим на примеры, потому что так сейчас легко запутаться, потому что определение очень
формальное, да еще и пока не очень строгое. Но прежде чем давать строгое определение,
я хотел бы, чтобы вы посмотрели на примеры, чтобы было потом проще соотносить формальные
синтаксические конструкции и какую-то реальность. Вот давайте посмотрим на такой пример группы.
Вот у нас есть группа, она задает модель. Что является носителем модели? Ну множество
элементов группы. Какие у нас есть предикаты? Предикат 1 равенство, а есть также бинарная
функция умножения, унарная функция взятия обратного, есть константа единица. Вот мы
зафиксировали такую модель и дальше мы можем выражать какие-то другие вещи в этой модели,
какие-то высказывания группе можем выражать. Ну вот, например, я пока использую кванторы,
не очень формально и записываю тоже пока не очень формально. Формализм это превратить достаточно
легко. Вот смотрите, что здесь написано. Единица, да, константа, то есть вот это вот предикат,
это функции, а это константа. Вот давайте смотреть, поскольку у меня вот здесь явно написан бинарный
предикат, я на него два раза навешал кванторы по одной и по другой переменной, должен получиться
нулярный предикат, истина или ложь. Как вы думаете, это истина или ложь? Истина для любой группы,
потому что это просто обычная формула взятия обратного произведения. А если я, скажем,
напишу для любого х, для любого у, х, у равняется ух, это уже мы не можем сразу ответить, истина это
или ложь. Почему? Потому что это зависит от свойств группы. Если в качестве носителя модели мы возьмем
абелевую группу, это будет верно тоже. А если, скажем, возьмем группу перестанова, где больше чем три
элемента, это уже будет неверно. То есть зависимость от того группы абелева или не абелева, это формула
истина или ложна. То есть когда мы пишем вот такое высказывание, строим предикат нашими операциями,
он может в одной модели быть истинным, в другой быть ложным. Потому что вот эти вот элементарные
предикаты и функции, они имеют в разных моделях, могут иметь разную интерпретацию. Вот как в случае
группы. Если же это группа целых чисел, то вторая формула истина. А если же это группа перестановок,
там, скажем, трех элементов, она уже ложна. Но тем не менее, я сейчас говорю про истину и ложь,
а в принципе можно выражать предикаты. То есть какие-то новые отношения выражать с помощью
наших выразительных средств. Ну и здесь очень показательно есть две модели. Давайте я их прямо
напишу. Они у нас будут очень часто возникать. Ну не только они, но эти точно будут возникать.
Ой, а тут... Все время забываю, что сюда нельзя класть, там вода. Наверное, предыдущий подсох.
Первая модель называется алгебратарского. У нее носитель – это действительные числа.
Предикаты – это равенство и неравенство. То есть сравнение чисел на равно и на меньше. Это
арифметические операции. Достаточно сложение и умножение. И константы 0,1, допустим. Вот такая
модель. В ней можно делать высказывания о каких-то действительных числах и о наборах
действительных чисел. Ну вот самый первый пример. 4 меньше 7 – это такой простейший предикат,
который выразим в этой модели. Просто сразу выразим. Такой атомарный предикат. То есть
меньше х и у – это уж точно выразим. То есть предикат меньше выразим по определению. Он у
нас есть. Но можно выразить что-то более сложное. Например, вот есть квадратное уравнение и мы
хотим, а и b мы считаем параметрами, мы хотим написать предикат от а и b, который выражает
такое свойство, это уравнение, что у него есть корни. Но вы, наверное, знаете, как такой предикат
записать, да? Ну да, то есть это будет вот такой вот a квадрат – 4b больше либо равняется нулю. Тут
уже нам нужны функции, которые есть. Четверки у нас нет, у нас константа только один. Но как
сделать из 0 и 1 четверку, я думаю, все догадываются, что можно выразить 4. То есть это можно выразить,
минус можно выразить через сложение. Там это требует некоторых усилий, но можно. Тут сравнение не
строгое, но это тоже не очень сложно. Не строгое сравнение – это дизюнция. Или строгое сравнение,
или равенство. А дизюнция – это объединение, то есть это как раз то, что у нас из булевых форм
приходит булева-связка дизюнция, позволяет нам не строгое, не равенство. Да, имеющиеся функции мы можем,
то есть вот теми способами, которые я говорил, мы подставляем в одну функцию другую. Ну, пожалуйста.
Существует такое s, что? Существует такое x, что x? Ну, давайте вот я буду, чтобы знак умножения был
виден, я его звездочкой буду писать. Звездочка x, x равно 1 плюс 1. Вот, пожалуйста, значит, ой,
извините, я два раза написал кванторы. Вот, тут один, конечно, нужна одна переменная. Вот я написал
такую формулу. Ну, что такое формула, я буду говорить потом, но это операции с предикатами,
сейчас для нас это операции с предикатами, которые определены. Ну, вот хороший вопрос. Вы прям с вами
спешите, я хотел в следующий раз про это поговорить. На самом деле давайте, нет-нет, это буквально то,
о чем я хочу сказать. Понимаете, p выразить вал гибритарского невозможно. Но как это доказать?
Прежде чем это доказывать, тут вот в следующий раз я буду давать строгие определения, они очень
занудные и громоздкие. Чтобы было понятно, почему это приходится делать, это вот нужно обсудить
именно такого рода вопрос. Хорошо, а вал гибритарского p выражается или нет? Или для меня более даже
принципиальный пример, вот такой более простой предикат x целое число, это унарный предикат.
Можно его выразить вал гибритарского или нет? Ну, это такое. Давайте я напишу немножко другой
предикат n от x, это целое положительное и напишу что-нибудь такого типа. Буду применять операции
каким-нибудь таким способом. Значит так, n от единицы. Нет, не так. Я хочу задать n от x.
n от x равняется, значит, или x равняется единице, или существует такое y, что n от y и y плюс 1 равняется x.
Чем не задание? Я знаю, что условия будут влиять только положительное целое число. Ну,
а все целые числа, я думаю, не нужно объяснять, что там, ну, противоположно еще раз. Задать это
легко. Тут надо какие-нибудь скобки поставить, чтобы было понятно, где логика, где математика.
Ну, действительно, либо целое положительное число равно единице, либо есть предыдущее.
В сущности, вот то, что написано вторым условием, это то, что есть предыдущее число. Предыдущее
такое, которое на единичку меньше. Оно тоже целое. И понятно, что только целые числа попадут в это
определение. Ну как, вот устраивает вас такое? Что? Нет, вы торопитесь. Устраивает ли вас такой
способ задать предикат x целое в рифметике тарского? Почему? Да, на самом деле, потому что
использованы индуктивные определения. А вообще, логика знает много разных способов определений.
Индуктивные не самые сложные. Есть то, что называется определение с неподвижной точкой. Это
почти индуктивное. Это можно было бы переписать как логику с неподвижной точкой, но там чуть
более общая конструкция, которая... Сейчас мне не хочется тратить время, например, где она будет
отличаться от индуктивного определения. И если мы это разрешаем, у нас будут одни выразительные
возможности. Если не разрешаем, другие. То есть, прежде чем доказывать, что что-то нельзя выразить,
нам надо зафиксировать, ну вот как говорят модели. Кстати, вопрос про x равно pi вы мне напомните. Я
никогда не думал, я думаю, что не очень трудно доказать, что невыразимо. Ну, предикат x равно pi,
такой вот унарный предикат. Он равен единице только на pi. Потому что что значит выразить
констант? Это по сути дела вот такой унарный предикат задать. Что мы можем различать,
ну как я с корнем из двух делал. По сути дела, это способ, если убрать вот это вот существует,
то это способ задать предикат, что s это корень из двух. Он равен единице, ну надо еще, наверное,
написать условия, да. И s больше 0. Как-нибудь вот так. И это уже будет предикат, который вот такой
вот. То есть, он будет истиннее, если s корень из двух и ложь его всех остальных случаев. Вот про x
равно pi. Про x равно pi, я уверен, что задать его, конечно, нельзя. Но как это?
Доказать. Давайте я подумаю. Я сейчас не готов сходу. Ну, даже про их целое я знаю,
как доказывать, почему невыразимо. Я не готов сейчас рассказывать, вам даже определение не
дал еще. А, конечно, там доказательства еще используют некоторый довольно мощный прием
рассуждения. Так что давайте это мы подвесим через некоторое время. И более того, я не докажу
основное утверждение про алгебру тарского, из которого следует способ доказательства невыразимости
вот таких предикатов. Я только объясню, как можно доказать. Там довольно громоздкое доказательство,
я само доказательство планирую пропустить. Мы похожие утверждения про другие модели будем
рассматривать, а это мы пропустим. Но это мы опять забежали вперед. Тут вот, понимаете,
некоторая проблема в том, что хочется от формализма быстрее перейти к каким-то
содержательным вопросам. Но логика в этом смысле очень коварная, что пока мы не зафиксировали
формализм, можно очень много времени тратить впустую просто из-за того, что спорить будет это,
выражать или не будет, и как избавиться от таких выражений. Понимаете, да, мы избавимся тем,
что просто четко зададим вот ту неформальную алгебру предикатов, которую я сказал. Но я хочу
сразу, почему у меня вот этот предикат очень важен, я хочу сразу задать модель,
которую я буду называть арифметикой, которая отличается от алгебритарского в сущности только
носителем. Это тоже сравнение чисел, тоже арифметические операции с числами и константы
0 и 1, но на множестве неотрицательных целых чисел. Вот это я буду называть арифметикой
для определенности. И хотя тут действительно числа тут натуральные, неожиданным образом это
я сразу анонсирую, выразительные способности арифметики гораздо выше. И связано это с очень
важной причиной. Мы когда изучали алгебру, мы рассматривали деление с остатком. Мы можем
написать условия, что число делится на другое число с остатком. А существуют такие Q и R,
что A равняется QR плюс QB, прошу прощения, плюс R. Ну и R еще должно быть, как вы помните,
когда мы говорим про остаток, оно должно быть, тут два неравенства еще должно быть. Так вот,
этот предикат, его можно записать и в алгебритарском, но в алгебритарском ничего интересного не
выражают, потому что более-менее всегда, там за исключением какого-то выраженного случая нуля,
вы можете подобрать остаток равный нулю, ну то есть у вас действительно числа можно делить
друг на друга. Если B не равно нулю, лучше, чтобы B не равнялось нулю и пределение со остатком.
А если B не равняется нулю, у вас этот предикат всегда истинный по тривиальным причинам. Остаток
ноль, а Q это частное, A разделить на B, для действительных чисел. То есть в этом смысле,
говорят, что в действительных числах нет деления с остатком, у вас нет вот этого возможности
разделить число на частное и на остаток. Вот у вас все сливается. И это сильно уменьшает выразительные
способности алгебритарского, как мы позже увидим. Тем не менее, мне осталось пара минут и я хочу
про алгебритарского сказать, но уже очень бегло. В конспектах я может быть какие-то более подробные
напишу слова, чтобы было понятно, но на самом деле я надеюсь, что это не очень сложно. Вообще,
за что отвечают выразительные возможности алгебритарского? Ну, прежде всего за
элементарную геометрию. То есть алгебритарского, хотя называется алгеброй, но это такое естественное
место, где живет элементарная геометрия. Ну, знаете, там всякие теоремы, что все прямые
проходят через одну точку, все точки лежат на одной окружности, таких много. Ничего удивляюсь,
есть такие теоремы. Ну, не совсем такие, но есть. Ну, что высоты пересекаются в одной точке. Хорошо,
есть треугольник, его высоты пересекаются в одной точке. Три прямые проходят через одну точку. Ну,
не все, но вот три. Но таких теорем очень много. Там прямых в треугольнике можно провести сотни,
и все тройками, и все эти тройки будут иметь общую точку. Поэтому я так немножко ехидно говорю,
что все. Конечно, не все. Но теорем таких очень много. Почему это можно выразить в алгебритарского?
Это… Время у меня почти заканчится, я только скажу общую идею. Это, естественно, просто метод
координата, аналитическая геометрия. Вы можете задать точки на плоскости парами чисел, уравнения
прямой записываются алгебраически, уравнения окружности записываются алгебравически, пересечение
прямой и окружности или прямой и прямой задается просто условием, что существуют такие x и y,
что вот выполняются два уравнения. Что такое высота? Ну, это условие перпендикулярности двух
прямых, но тоже его можно записать алгебраически. Например, используя скалярное произведение.
Скалярное же произведение позволяет обходиться без углов там с градусами или с pi, неважно. Мы
вместо этого будем говорить о скалярных произведениях единичных векторов. Это будет
более-менее то же самое, что косинус угла. И все теоремы элементарной геометрии, которые вы знаете,
можно пересказать. Единственное, что там действительно появятся условия, что для любых там трех точек выполняется
то-то и то-то. Или для любых трех точек существует еще какая-то точка, для которой выполняется,
допустим, существует описанная окружность. Как это сказать? Ну, вот существует точка,
существует еще ее радиус такой, что все три вершины треугольника лежат на этой окружности.
И комбинируя вот эти вот операции с кванторами, можно любые теоремы выразить. Ну, и это более-менее
все. На самом деле, если не говорить о планеметрии, а взять произвольную размерность, то вообще
получится более-менее как раз то же самое. То, что называют полуалгебрайческие множества. То есть
у нас есть возможность задавать не просто решение системы линии уравнений алгебрайческих, а решение
алгебрайческих уравнений и неравенств. Вот в этом разница. Ну, почему так? Это я немножко объясню.
Я говорю, до конца я, по видео, это не доведу рассуждения, но основной способ, что надо сделать,
я объясню. И это будет чуть позже. В следующий раз мы наконец определим все формально. Но потом
нам надо будет еще поупражняться с аналогами тавтологии. Только после этого уже начнем
доказывать невыразимость разных предикатов. Ну, на сегодня все.
