Сегодня мы будем писать мета контейнер.
Вот.
Какой это пункт? 16.5?
Ну, давайте все-таки собраться.
Typelist, meta-container and value-based metaprogramming.
Значит, сейчас я объясню, что такое value-based metaprogramming,
но сначала я объясню, что такое Typelist, meta-container.
Ну, на самом деле, ничего, по сути, сложного сейчас нет,
потому что я сейчас буду говорить первые минут 15.
В принципе, и так понятно, что я сейчас буду писать.
Мы хотим написать примерно следующее.
Typelist. Я буду эти структуры уже с маленькой буквы писать теперь.
Вот.
Что такое Typelist? Это meta-container.
Что такое meta-container?
Ну, это хранилище типов.
Вот он хранит последовательность типов.
Вот. И я хочу написать такие метафункции,
которые будут по этому meta-container возвращать что-то другое.
Ну, например, самое банальное, что я могу сделать, это push-front, pop-front.
Ну, или просто front.
Вот давайте я напишу template, type-name.
Давайте сначала напишем функцию, которая возвращает первый элемент.
Type-name t, type-name многоточие ts, struct front.
Ну, просто front у нас будет без тела, front от чего palo звать нельзя.
А вот front от типа, вот такая специализация будет, type-name t, type-name многоточие ts,
front от type-list от t, запятая t и s многоточие.
Что это такое будет?
Это будет type-identity.
Давайте я напишу using std type-identity, потому что мне будет часто нужно.
Using std type-identity.
Ну, я подключу type-trades.
Type-identity от t.
Вот, дальше.
Ну, давайте сделаем push-front и pop-front, например.
Как будет выглядеть push-front?
Ну, опять, наверное, опять-таки я скажу, что push-front от чего palo звать нельзя.
Да и push и pop-front.
Ну, вот сначала pop-front напишем.
Pop-front от чего palo звать нельзя.
Pop-front от type-list.
Вызывать можно.
Что это будет такое?
Это будет type-list.
Тс, многоточие.
Сейчас.
Если мы напишем двоеточие, наверное, будет неправильно.
Мне надо, чтобы pop-front от него был...
Type-list, ts.
Нет, все правильно.
Pop-front-identity от type-list.
От тс, многоточие.
Просто у меня же будет еще pop-front-t.
Вот я здесь написал front-t.
Pop-front – это будет меташтука, которая представляет из себя структуру, в которой объявлен type,
которая называется type-list.
А pop-front-t – это будет сам type-list.
Я о чем же вы тогда сразу не пишем?
Твоечное дерево поиска вместо списка.
Ну а о чем компиляция?
Компиляция долгая.
Не бедите.
Ну, мы на самом деле сейчас что-то подобное...
Попытаемся здесь...
Ну нет, двоечетнадцать деревьев.
Нет, что? Веритель, нет.
Front-t – это будет type-name.
А front – вот type-list.
От т, запятая.
Тс, многоточие.
Дветочие, дветочие, type.
Да, и pop-front-t тоже самое.
А что такое pop-front-t?
Это pop-front, type-list, т, тс, дветочие, дветочие, type.
Вот, ну можно сразу написать какие-нибудь простые тестики.
Например, можно написать static-assert.
Я еще напишу здесь, что я использую стд-is-same.
Is-same-where.
Вот, ну можно написать static-assert, что is-same-where.
Type-list.
Сейчас, pop-front-t под type-list, int-double-char.
И просто type-list, double-char.
Что?
Сейчас, я проверяю, is-same-where, pop-front-t, раз-два, раз-два, type-list, double-char, не лишнее.
Все нормально.
Pop-front-t, вот у меня голова скобка открылась, две голоскобки открылась, две закрылась.
Is-same-where.
Еще type-list вот такой, и вторая голова скобка закрылась.
Давайте какой-нибудь.
Я вот сейчас такой вопрос. А почему мы не делаем?
Да.
Только не спрашивай, зачем это надо.
Почему мы не делаем?
Садака вексель свое десятый умеет.
А почему мы тут сделали? Мы ничего не сделали.
Ну я только type-list использовал.
Почему мы не делаем front именно методом type-list?
А как?
Ну то есть мы делаем его using, ну не using, но типа функцией, у которой нету имплементации, а в качестве результата будем использовать стандарь результатов.
Или там декол-type, чего-нибудь.
Ну, методом type-list.
Ну потому что тут писать, я не знаю, type-list 2.2.pop-front, но это хоть сколько-то лет меньше, чем pop-front type-list.
Ну да.
Это привычнее.
На самом деле ты мыслишь в правильную сторону, в том смысле, что мы сейчас вот это все понапишем, а потом ясно, что это все плохо и мы сделаем по-другому.
Вот то, что я сейчас написал, это как раз такое самое наивное метапрограммирование, которое было до появления constexpr.
Вот я сейчас еще несколько функций напишу, а потом мы их переделаем более красивые.
Вот.
Сейчас я пока показываю, как это бы выглядело до того, как мы constexpr узнали.
После того, как мы узнали constexpr, на самом деле это все проще можно сделать, сейчас мы как раз это сделаем.
Но для начала я покажу вот такой вот довольно лидовский способ.
А так вот, type-list.
Ну, конечно, тут не все так легко.
Да, я забыл тело.
Здесь забыл тело.
Вот.
StaticAssociationFailed.
Почему?
Да, вот еще DebuggingTemplates.
Это ужасно.
Здесь самые плютов, брейп-пойнты на уровне компиляции.
Сейчас, секунду.
Кто еще не выпустил дебайдер?
Буквально нечего делать, просто...
Так, сейчас.
Я где-то что-то...
Читаем код очень мимо.
Давайте прочитаем код очень мимо.
Поперерасии на строчки разные, просто чтобы не запутаться.
У тебя сейчас фигурных треугольных скобочек, как будто я делал.
Не-не.
Да-да, с треугольными скобочками все нормально.
Значит, у меня есть темплейт, специализация темплейта Popfront.
Те?
А что нужно делать?
Да, я умею...
Да, вот так надо писать.
Темплейт.
TypeName.
Те.
Popfront.
Сейчас.
Мне нужно сделать, чтобы Popfront...
Popfront принимает в себя...
Сейчас.
Для этого Popfront нужно просто лист принимать.
А-а-а...
Да, если я написал Popfront...
Что, пишем концерт с TypeList?
Неприятно.
Здесь у вас Popfront от Те.
Вы должны читать.
А, да, господи.
Не надо TypeList писать.
Все, все нормально.
Да, вот так.
О, отличный, да.
Вот.
Ну, хорошо.
Popfront.
Ну, можно сделать еще Pushfront.
Это уже...
Неинтересно.
Скучно.
Да, упражнения для читать.
Да.
Упражнения для...
Неленивого слушателя.
А-а-а...
Что насчет Pushback и Popback?
Ну, Pushback можно сделать.
Как сделать Pushback?
Нужно просто принимать...
Ну, сейчас.
Что у нас тут проблемы?
Делать Pop...
Давайте я напишу Pushback.
И тут специализация будет.
Pushback.
Popfront может перейти сейчас и куксе и бежать на конца.
От TypeList.
TS.
Popfront.
И бежать на конца.
От TypeList.
TS многоточие.
TypeT.
Popback.
А, ну да.
От TypeList.
TS.
Это был бы...
Это был бы Popback.
А Pushback будет выглядеть так.
Это TypeIdentity.
От TypeList.
TS.
TypeT.
Что-что-что сейчас произошло?
Мы фронт опять удалили.
Как удалили?
А, это...
Это Push.
Все хорошо.
Да.
Теперь я могу сказать...
Popback плохой.
Да?
Popback.
Вот с Popback будет проблема.
Да.
Вот я могу теперь, например, проверить, что StaticAssert Pushback...
Так, мне нужно еще PopfrontT тоже скопировать, сделать PushbackT.
Ой.
PushbackT.
Это Pushback.
T.
Type.
Вот.
И я проверяю, что PushbackT...
Pushback у меня специализирует только для TypeList.
А для остальных, если я вызову Pushback, то это пациент.
А, PushbackT.
А, PushbackT.
PushbackT.
А куда мы Type передаем?
А, да, кстати.
Отличный вопрос.
Тогда мне нужно Pushback.
Действительно, мне нужен...
Первый, мне нужен вот такой параметр.
Нет, слева.
Вот знаете почему?
Потому что я смогу писать тогда Pushback...
В PushbackT тоже надо добавить.
А, нет.
Ну да.
Не важно.
Можно с этой стороны.
Ну, бежим тогда TypeNameT, TypeNameU.
Вот.
А здесь TypeNameU.
Может TypeNameList, пожалуйста.
Или там кто-то из них Лист.
Хотя бы, если уж не концепт, то хотя бы...
Нормальный.
Давайте все судьбу.
Вот.
Значит, проверим, что Pushback...
Вот в такой TypeList.
Типа Ч.
Это будет TypeList от int Double запятая Ч.
Проверим?
По-моему.
Получилось.
Подожди, а что...
А что получилось?
А.
Я Pushback-нул.
В Int Double запятая Ч.
Получилось Int Double запятая Ч.
Я сказал, что запустите, а не надо запускать.
Это что-то из-за кадра, я не знаю.
Все, нигде.
Я ничего скажу, а у тебя их нет.
Вектор TypeID.
Чем мы будем этим заниматься?
Ну, там же есть TypeID или Typeof, что-то прикольное.
TypeID это runtime-вещь.
А мы хотим compile-time-container.
А может быть, в обычном статике TypeID?
Ну, а если не за TypeID, у констекспорта...
Как?
Констекспорт TypeID?
Э...
Кстати, не знаю.
По-моему...
Что происходит?
Я ничего не вижу.
Ты не про что не про то, что...
Все, вот здесь сейчас написано pushback.
Вот у нас есть struct pushback.
Да.
Он принимает один аргумент.
Два аргумента.
И еще куча аргументов TypeList.
А мы ему передали list и te.
Нет, нет, нет.
Этот pushback, он от двух шаблонных параметров.
Первый из которых TypeList, а второй te.
О-о-о!
А от любого другого, на больше много параметров,
его вызывать нельзя и будет te.
Э, молодец.
Это еще не так.
Скоро станет.
Окей.
Понимаете ли вы, почему такими способами
получится резать pullback?
Ну, получится, но не получится.
Не получится.
Прям вообще не получится.
Мы не сможем, да, сейчас.
Ну, в смысле, вот так в лоб не сможем.
Да.
Мы только за квадрат сможем popback сделать.
А почему popback от TypeList и te?
Потому что, чтобы нам сделать popback,
нам здесь надо написать TypeList,
te многоточие, te запятая te.
А так нельзя.
Нельзя специализировать от te.
Написать typeName многоточие te,
te запятая typeName te, можно.
А вот написать в специализации
Type многоточие te.
Нет, так тоже нельзя.
Что, type после многоточия разве можно?
Нет, в объявлении шаблона можно,
а вот в структуре...
Что это будет иначе?
Ничего.
Нет, так можно.
Мы это даже однажды делали.
У нас, по-моему, один раз этот вопрос уже возникал.
Как мы за шаблон попасть?
В смысле, он просто увидит,
что ты вызываешь так многих аргументов,
откусит последнее, а первый сделать пакетом.
Короче, так он умеет, а вот так нет.
Но это неважно.
В любом случае мы не сможем.
Ну, а...
Это только в экспрешенах,
а у нас тут нет ни одного экспрешена пока.
Вот.
Как нам сделать что?
Ну, например,
add
или...
Ну, давайте сделаем обращение по имбексу.
Давайте в квадратной скобочке.
Квадратной скобочке мы не сможем сделать.
Давайте сделаем обращение по имбексу.
Можно назвать нашу структуру просто
Square Veteran Braces
Square Braces
Square Braces T
Вот хорошо.
Значит, Teamgrade.
Какая была ваша методика?
Ну, мне надо
сделать...
Он должен быть фиксированным?
Да.
Add, она должна принимать число
и Type List.
Да, спускаться вниз, пока у нас...
Вот.
А, поэтому, мы...
Ой, size T.
Я здесь не буду даже, потому что я
это без тела оставлю.
Вот.
И специализация для нужных мне типов.
А надо голову отсоединить отдельно?
Как же это прекрасно заниматься?
Add,
где первый шаблонный аргумент
это...
Вообще, я бы, конечно,
сделал add
чтобы index был первым
шаблонным аргументом.
А этот,
второй.
Index запитает Type List
в тис многоточие.
Да, нужно
в другом порядке.
Ну, чтобы я писал add по индексу
как бы от Type List.
Ну,
может быть...
Не знаю.
Я очень плохо выживу pushback
от листа.
Может, все-таки лучше от листа.
Сейчас мы...
Сейчас я напишу add, и потом мы все
сделаем по-любому, я думаю.
Значит, как сделать add?
Я...
Голову, видимо, придется
откусить, да.
Голову, видимо, придется откусить, да.
Голову надо откусить,
но я пишу index и add.
Если нет, она не называется
index-1.
Стоп.
Если не называется для индекса,
ну и все.
Значит,
у нас будет
type-name-head, получается.
Type-name
многоточие tail.
Я правильно понимаю,
что мы уже официально уверены,
что все животные это только голова
и хвост.
И что мы делаем-то?
Ну, дальше надо проверить то,
что index 0?
Index 0 точно, потому что иначе мы в специализации.
Значит, нужно просто type identity.
Но нам надо сказать, что мы
type-identity, почему плохо?
Нехрена, буквально.
От add,
от type-list
tail
index-1.
Типа...
Мне не нравится, мне вообще не нравится.
Не, ну, мне тоже пока не нравится,
и поэтому мы сейчас все переделаем.
Просто будет приключение количества наследников.
Да, да, да.
Это не очень хорошо.
Мы делали это в тупую, без инструментов,
сколько там появилось type-identity,
мы делали это лучше.
Типа, мы просто объявляли
внутри...
Сейчас можно здесь внутри объявить,
type-name что-то там,
using что-то там
равно type-name.
Ну, мы и так сделаем, если так тебе больше нравится.
Я не понял, причем мы здесь.
Потому что мы наследоваться...
Мы наследоваться не будем миллиарды раз.
Типа, type-list не хочет identity,
он хочет 2 раза больше.
Так, и нам нужна специализация
для нуля, да?
А вы или надо написать?
Это штука вы или?
Еще раз мы type-name.
Using type равно
add
type
и еще type-name.
Так, а теперь
для нуля все то же самое.
Зачем я это сделал выше, не знаю,
но не важно.
Так,
add
от вот этого и нуля
using type равно
add.
Да?
Ну, и template type-name
что?
Type-name T, type-name
type-name
не type-name, а size-T.
Type-name T,
size-T
index
using type
add
type-name
type-name
add
от T as index
и от index
вначале.
А, вы меня переделали чего?
Точки запятые.
Точки запятые не хватает, да, спасибо, а то мы сейчас
не бажали этого.
А, вот, видите, нельзя.
Что?
Все-таки нельзя.
Сначала size-T надо?
Да, забавно.
Да, забавно.
Я спросил,
мне сказали, что все окей.
Ну, как минимум
можно два пакета
в разных делах.
Как он их разделит?
А?
Зачем он отдельно size-T и type-name
на той, чего мы тут постоим?
Потому что мне надо, чтобы это все
было специализация метабол.
У нас еще хет есть.
Вот, теперь
меня эти не являют специализациями.
Мне нужно, чтобы
сначала был индекс, потом какая-то хрень.
Ну, и ноль, аналогично, сверху.
И ноль тоже здесь.
Ну, обещал шаблон
менять с индекс.
Да-да-да.
Он не закопил.
А?
А, потому что здесь индекс
вначале.
Ну, ладно.
Я как чувствовал.
Ну, потому что
не на прессе аналогия тоже.
А вот там шаблон
меняет тоже.
Ну, все.
Так, давайте стать аксер, хоть напишем.
О, жестко, видимо, сами стать аксер.
Да, что-то верим.
Я сам признаться
не буду.
Из C&W, что, например,
вот такого type
сначала индекс, потом
type-list.
Int, double,
char,
zpt, double.
Что по
индексу 1 в type-list
int, double, char лежит double. Мы сейчас проверим.
Я уже знаю, что лежит
по индексу 1
на type-list.
А, потому что
это я сделал все-таки наоборот.
Сначала type-list, потом type-list.
Ну да, чтобы красиво было.
Здесь я наоборот.
Может, не надо это же запутывать?
А ты же не будешь пользоваться.
Не обязательно.
Это просто примеры.
Я больше не буду ничего реализовывать.
Потому что иначе мы не успеем.
Но самое главное.
Вот.
Это было
очень такое
type-list в старом стиле.
Потому что здесь
мы делали все чисто на типах.
Вот мы и здесь
все довольно
плохо. Все довольно
грустно. Потому что, например,
даже add,
даже обращение по индексу
требует
работать за сколько?
Ну вот за квадрат, да.
Но если считать, что
создание каждого типа...
Компилятору приходится инстанцировать
n типов, каждый из которых
длины от n.
Ну что, ему надо...
Он сначала инстанцирует type-list
от t1,
и так далее tn. Потом type-list от t2,
и так далее tn. И так
до type-lista вот в последнем.
Это очень эффективно, мало того,
что компилятору приходится
инстанцировать кучу типов,
еще и рекурсивно.
Ну и в целом
эта работа очень медленно.
Вот такая организация
type-lista нас не будет устраивать.
И мы сейчас делаем
по-другому.
И мы будем заниматься, как называемым,
value-based метапрограммированием.
Вот value-based метапрограммирование
это то, что стало возможным с приходом
constexpr.
Что стало возможным с приходом constexpr?
А с приходом constexpr
мы будем писать
просто настоящие функции,
которые будут нам возвращать
настоящие значения.
И все это будет в compile-type.
А потом мы будем писать
один раз декл-type и все?
Ну да,
мы можем декл-type писать,
но на самом деле нам даже
это не
пригодится сегодня.
Кстати, сейчас, а зачем нам constexpr,
если мы можем просто...
Чтобы, кстати, кассерт делать.
Смотрите, что я хочу.
Я хочу...
Я к тому, что мы можем просто написать
функции и писать декл-type.
Ну мы можем,
но я не так собираюсь делать.
Value-based
type-list.
Смотрите.
Я начну с того же самого.
Напишу
template.
Нет, я так не буду делать.
Я просто скажу
cp-type-list
value-based-type-list.
И открою value-based-type-list
и удалю все.
Вот начинается по месту.
Вот.
Я
сделаю вот что.
Сначала я напишу
операторы сравнения.
Я буду считать
два type-lists равными,
тогда и только тогда, когда я
буду писать декл-type.
Это из same.
Ну да.
Чтобы мне не делать из same,
я хочу, чтобы функция просто была.
Я буду говорить
const-export
обязательно.
Можете, пожалуйста,
вкратце наумить, что это за бред
с тремя торгующими?
Два
пакета параметров.
Пакет, смотри.
Как их передать?
Я принимаю параметры.
У меня будет type-list
js многоточие,
type-list us многоточие.
Я ничего не понял.
Вот я хочу его
откуда-то вызвать.
Если вызвать от двух type-lists.
Нет, ты можешь вызывать
его только от двух type-lists.
Когда ты вызываешь от двух type-lists,
он понимает
от каких пакетов были type-lists.
И эти пакеты представляют параметр шаблона.
Здесь-то у него однозначно все.
Вот. Тут будет false.
А будет еще специализация.
Перегрузка?
Да, давай, перегрузка.
Перегрузка вот такая.
Если типа одинаковая...
В чем разница специализация шаблона функции перегрузки?
Специализация
Шаблона функции
это то, что начинается с темплея
и простые угловые скобочки.
Вот это будет true.
Так, в стандарте написано.
Так и есть. Я сказал, как есть.
Еще у меня будет оператор неравном.
Который будет наоборот.
Здесь будет true, а здесь false.
А нельзя return
противоположность и оператор вовно?
Ну, можно, но
я уже написал так.
Тут мне придется имена давать.
Заметьте, я параметры принимаю безымянные.
Я никогда не собираюсь их изменить.
Кстати, это можно было еще как только ты
его смартфлекс поделать, потому что
один return это ничего.
Да, это можно было
начинать себе плюс 11 делать уже.
В принципе, ну нет, не все,
что мы тут пишем себе плюс 11.
Что?
Так, окей.
Давайте напишем push.
Даже я написал памятку.
Чего-то по порядке надо написать.
Popfront сначала напишем.
В каком формате?
Я хочу, чтобы у меня была функция popfront.
Чтобы я мог стать
кассертом.
Вот так делать.
Popfront
от
TypeList
с параметрами
int double check.
Сейчас увидим, что он хочет написать.
Круглые скобочки?
Круглые скобочки, наверное.
Ты хочешь метод
TypeList, который возвращает другой
TypeList?
Я еще не понимаю, что сейчас может
стать кассертом стоять в линзете.
У нас сейчас popfront это функция.
Чтобы она не вернула,
она не может вернуть TypeList.
Она возвращает что-то типа TypeList.
Объект.
Смотри,
вот у меня popfront
от TypeList
и
там
сконструируется объект
по умолчанию
и вызываются еще конструкторы всех
внутренних...
Он пустой.
У нас структура пустая.
Возвращаемый тип такой.
Он уже знает, какой.
Он его возвращает объект по умолчанию
такого типа.
То есть по дефолту мы можем
в нешевеленном месте, но в любом типе.
Это не нешалайзер-лист.
Это скорее...
И что это?
Я не понимаю, что это.
Этот дождь-то будет
передаваться в конструктор.
То есть я здесь мог бы написать фигурные
скобочки?
Можно бы написать std string и
фигурные скобочки в 5.
И тебе бы вернулся стринг
из 5...
Если бы я написал
возвращается std string
и return фигурные скобочки 5.
Я не уверен, что для return специально сделали
отдельную конструкцию.
Я не уверен, что формально является
этот нешалайзер-лист.
Нет, это не нешалайзер-лист.
Это copy initialization. Мы же можем написать
вектор равно и фигурные скобочки с
что-нибудь.
А вот это будет тайп-лист.
А вот это будет тайп-лист.
А вот это будет тайп-лист.
Ну да.
Да, это наверное все-таки нешалайзер-лист.
Правда.
Это...
...через год у вас будет.
Что?
Что будет через год?
Co-return.
Кознак, подчеркни, return.
А это Co-return?
Это Co-return, да.
В этом я буду сказать мнение.
Окей, все, поп-фронт написали.
Давайте напишем push-фронт.
Как написать push-фронт?
TypeName многоточие.
На самом деле опять typeName.
TypeName.ts
Type-лист на этот раз будет вот такой.
Push-фронт
от вот такого
тайп-листа.
И не писать return пустые скобочки.
Ну и мы можем проверить, что
push-фронт
от
вот такого тайп-листа
это вот такой тайп-лист.
И не писать return, это все еще не правильно?
В смысле?
Где?
В функцию без тела ты хочешь?
Ну с пустым.
В смысле тогда это вот вызываемый.
Ну а он не догадается, что по умолчанию?
Нет, я не догадаюсь.
Ну в смысле это очень...
Маленькое количество кейсов,
где ты поставишь в функцию
значение умолчания.
Типа как в мейне.
Это только в мейне так работает,
в остальных функциях нет.
Окей.
Ну можно
написать push-back, но
не интересно.
Pop-back, вот с поп-back опять проблема.
Та же самая, что и раньше была.
Написать pop-back
не очень понятно как,
потому что
я не могу сделать...
А, нет, стоп.
Может быть я не могу.
Ну давайте подумаем, смогу ли я написать
pop-back.
Что, это все, я скомпинировал.
Где имп?
Так, подожди.
А вот это, кстати, странно.
А потому что я
не тот файл все это время компилирую,
может быть...
Какие хорошие тесты.
Да, да, да.
А, это вы, конечно.
Это вы хорошо заметили.
В какой-то момент я мог
позайти слишком далеко.
Это все компилируется.
Да, все компилируется.
Идем дальше.
Хорошо.
Окей, ну как сделать
push-back?
Опять нам надо сделать
take-name-t, take-name-ts,
take-list, take-list,
take-list, take-list,
take-list, take-list,
take-list, take-list,
take-list, take-list,
take-list,
push-back,
take-list, take-list,
take-list,
take-list,
and that's it.
So, push-back, how to identify it.
Нас же ничего лучше
не сталоよ,
Ну, конкретно с pushback, pushfront мы не выиграли, хотя мы все равно выиграли, потому что компилятору легче делать из-за функций, чем и сейв и вот это все.
Ну сейчас на полмаге выиграли, а точка это непонятно, как у нас будет лучше.
Чего?
Как у нас будет лучше точка это.
А вот сейчас я хочу до этого успеть дойти.
Ну pushback вроде понятно, typelist ts запятая t, pushback от вот такого.
А вот нам нужно в шаблонных параметрах сначала t, а потом ts?
Я сначала t, потом ts и проверю, что pushback от вот этого, это будет вот такой typelist.
Давайте проверю.
Pushfront, pushfront.
Pushback.
Pushback.
Работает.
Ну вот с pushback-ом так просто кажется не выйдет, потому что, потому что, почему?
Ну вот нам нужно вернуть вот такой typelist, а принять надо вот такой typelist.
И кажется, что такой вот типов сейчас не сработает.
Ну может уже по-приветному.
Давайте проверим еще раз.
Кажется, что такой типов не сработает, но может быть я и не прав.
Давайте проверим.
Значит pushback.
Почему у нас?
Нам надо первым править.
Да, мне не нужен шаблонный параметр t и все.
И он не поймет, как его отпустить от конца.
Вот в этом проблема.
Давайте попробуем.
Ну.
Ну я думаю, что он не поймет.
Это должно быть int double char.
Должно стать просто double char.
Ой.
Вот.
Ну, к сожалению, не получается вывести шаблонный параметр t.
А почему мы не можем дать шаблонный параметр t?
Мы не знаем, что это мы можем сделать.
Да, мы очень счастливы.
Вот если мы оставим.
Ну это странное, типа странный pullback какой-то.
Мы просим дать его в конце какой-то конкретный.
А если другой попросим?
Интересно.
CE, конечно.
У нас в данной случае хотя бы уже есть L-функция.
Ну в общем, pullback пока подвопросим.
То есть все-таки можно все прям хорошо?
Ну можно будет.
Когда-нибудь.
Но не всегда.
Нет.
Когда мы много чего другого реализуем, то это вы потом реализуете.
Это будет у нас последней задачей.
Да, да, да, да.
Но это будет самое простое, что там.
А там еще интересно.
Сорт.
Сорт.
Сорт.
Я хочу сегодня показать вам сорт на тайп-листе.
Вот.
Я надеюсь, что можно.
Ну чуть-чуть, чуть-чуть, чтобы начали опять в 17-20.
Мне кажется, у меня есть моральная права.
Мне, кстати, не по моей вине, да.
Ну да ладно.
Так, давайте напишем.
Давайте что-нибудь более интересное напишем.
Давайте напишем функцию.
Contains, которая проверяет, есть ли в листе такой элемент.
Содержит ли лист такой элемент.
Ну цена тейтс.
Темплей, тайп-лей, многоточие.
Тейс.
Ну, тайп-нейм-тей, тайп-нейм-тейс.
Вот.
Значит.
Конст-экспорт.
Конст-экспорт.
Спасибо.
Контейтс.
Контейтс.
Что дальше?
Тайп-лист.
Тайп-лист.
Тейс, многоточие.
А ты не нужно принимать.
Ты шаблонным аргументом будешь.
Вот.
Что нам сделать?
Давайте подумаем.
Как выглядит контейтс?
Ну, нам нужно вернуть, типа, что-то, ну, либо, если...
Сейчас.
Слушайте, а давайте напишем цифру, которая будет проходить на тайп-нейм-тей.
Нет.
Надо бы из тейтс выделить первый, что ли, так удобно, что-то.
Ну, тогда, правда, будет, ну, такая самая тупая.
Вот, вот сейчас мы уже начнем выигрывать очень сильно,
потому что, если бы мы писали это на шаблонных мета функциях,
то нам пришлось бы делать рекурсию шаблону.
То есть, понятно, что я могу сейчас обкусить первый тип
и вызвать контейнс от всего оставшегося, ну, и,
подсмотреть, совпадает ли тип сейчас первым, иначе вызвать от оставшегося и так далее.
Я вам запрещаю.
Я хочу написать, чтобы это за линию работало,
ну, потому что в такой виде это будет за квадрат работать.
Как сделать, чтобы это за линию работало?
Мы уже умели проверять, есть ли тейтс среди данного кричка.
В смысле, можем fold expression типа, мы хотим проверить что?
Да.
Вот, я передаю его, а принимаю тайп-лист.
И что я делаю теперь?
Ну, то же самое я делаю, только вместо этого я говорю
f от t, s, y.y.y.
Так.
Find it, можно что-то название применить?
Find it, да.
Вот это, кстати, только начиная с C++, в C++17 это не было бы скомпилироваться,
потому что find, std find не было в std export, но до C++2.
Ну, std find мы сами можем сделать.
Да, ну, std find можно фориком.
Мы с тобой еще не подходили.
Ну, я не знаю.
Ну, я не знаю.
Ну, я не знаю.
Ну, я не знаю.
Ну, я не знаю.
Ну, я не знаю.
Ну, я не знаю.
Ну, я не знаю.
Ну, я…
Я абсолютно горел было,습니다, чтобы я просто в Challenger за Ostsol Kids
Especially when we got testing, when we presented the first game conscious
We had people talking aboutィwork, we have people talking about it.
It's fun, isn't it?
Yep.
Yeah.
Okay.
So, now we read the description.
We Scotland.
Ну, кстати, может быть, и можно.
По-моему, Максимов шутил.
Нет, вообще, начиная с 2020 авто можно писать.
Шутка удалась.
Но здесь это не сработает, потому что это же не тип.
Если у вас был бы не типовой шаблонный параметр, то можно было бы написать авто, и вы бы могли тогда создать шаблон.
Но здесь не сработает авто, потому что он будет ожидать не типовой шаблонный параметр.
А передал я ему... ну, короче, не сработает.
А авто-авто что-нибудь?
Нет.
Ты слишком рано родился для этого.
Как же это?
Видно, что я живу.
Это уже поздно.
Друзья мои, нам надо успеть реализовать get и reverse.
И потом я вам покажу сортировку.
Сортировку я не буду реализовывать сам, я ее покажу готовую.
Блин.
Давайте реализуем get.
Значит, я хочу, чтобы у меня была функция get, чтобы она работала за линию, а не за квадрат.
Функция get.
В смысле, неважно.
Просто что это то же самое.
В оригинале, откуда я это брал.
Где get?
Значит, хорошо.
Функция get.
Get, понятно.
Просто что это одно и то же, что мы делали, что за квадрат.
Ну, по индексу я возвращаю, что там лежит.
Мне кажется, get более правильное название.
Так, значит копим мне шаблонные параметры.
У меня будет шаблонный параметр число.
Вот тут, кстати, можно и авто написать.
Даня, что ты сделал?
Замечательно.
Concepts for...
авто.
Вот здесь авто, потому что мы не знаем, какой тип будет.
A.
A.
A.
A.
A.
A.
A.
А это так.
Это здесь я все-таки S.A.S.P. напишу, потому что...
Это не приниматель.
Это аргумент S.A.S.P., а не как template.
Это аргумент S.A.S.P., а не как template.
Кажется, это уменьшит поличься template.
Так.
Что?
Что не приниматель?
Почему бы это не принимал аргумент S.A.S.P., а не параметр template?
Ну...
Мне кажется, это как-то...
Стоп.
Еще раз.
У тебя будет одна и та же функция, как бы префиксирована TS, которая...
и она будет понимать разные индексы как аргументы.
И будет возвращать разные типы.
Одна и та же.
Это не может быть, такому не может быть.
Сейчас.
А почему не такое может быть?
Еще раз.
У нас будет функция S.A.S.P., которая принимает индекс, вот type list.
У нее аргументы, шаблоны.
Вот эти аргументы type lista.
То есть при фиксируемом type list'е и разных индексах она будет решать один и тот же тип.
А это невозможно.
Она будет очень счастливой.
Разной.
И они все разные, а по факту будет еще один.
Ну пока и мне так кажется.
Я перестал понимать.
Она должна решать.
Вот сейчас видите, авто работает как.
Авто смотрит, что мы на самом деле вернули.
И вместо того, что мы на самом деле вернули,
создает новую шаблонную функцию.
Да, индекс как аргумент, у нас будет
куча вариантов того, что мы вернули.
В теле одной и та же функции.
Это бред.
В принципе, можно ли было написать
следующую конструкцию.
Просто
авто add.
Просто авто функция.
Если что-то
ретерн штуку одного типа, иначе
ретерн штуку другого типа.
Это же бред.
Так нельзя.
Возвращаем и тип.
Но да, кажется, это правда.
В данном случае,
данного индекса и данного
номера типов, тип всегда должен быть один и тот же.
Он и будет один и тот же.
И здесь все будет одно и то же?
Нет, потому что если у тебя индекс
не перестанет быть шаблонным параметром,
то непонятно, какой будет возвращение тип.
У тебя разные возвращения типы.
Ну все, поэтому так и делаем.
А как?
Я, к сожалению,
я себе
заготовил шпаргал, потому что я
не смогу это быстро произвести.
Поэтому воспроизведу наизусть.
Воспроизведу быстро, но не наизусть.
Если бы у нас было больше времени,
я бы, возможно,
по...
Значит, я сейчас
напишу сначала функцию addInfo.
Сразу понятно.
Тайп-нейм. Не тайп-нейм, а ССТ.
Ну, addHelper могу назвать.
Тайп-нейм ТС.
Значит, функция.
FunctionExport.
Это не функция,
это структура.
addHelper.
Вот.
Ну и у него будет специализация
для...
Кажется, мы вернулись
к СТОКу.
Нет, я споймел, почему нет.
Тут мне потребуется
одна замечательная вещь
в стандартной библиотеке,
которая называется
STD Index Sequence.
Сейчас я расскажу, что это такое.
Ам...
Это все неправильно.
Сделал.
Мне нужно переменное количество индексов.
И вот здесь будет опять
переменное количество индексов.
А типов не будет вообще.
Затянули типы.
Значит, getIndex...
getAddHelper.
Что такое type?
Integer Sequence.
Вот этих индексов.
Он старался остаться с нами.
Вот. Давайте
сначала обсудим, что такое
Index Sequence.
Это довольно полезная штука.
Да. Примерно так.
Значит, в стандартной
библиотеке
есть такой тип Integer Sequence.
Это, по сути, compile-time
последующих чисел.
Но у нее есть специализация для
случаев, когда T это с
ST, она называется Index Sequence.
Вот. Ее
прелесть в том, что
она реализована
внутри компилятора так,
что создание Index Sequence
от N, это не
квадратичная библиотека,
это линейная по времени.
Качество эссоциальных шаблонов
прикурсивных? Да. Он не инстанцирует
N разных шаблонов
от 1 до N, чтобы создать
Index Sequence размера N.
То есть мы истинно...
Мы опять стерили, да?
Мы, по сути, свели...
У нас была задача, мы могли
написать сейчас гензо квадрат, если бы
сами реализовали
вот что-то такое. Ну, что-то в таком
виде, потому что нам пришлось бы вот
рекурсию делать шаблонными инстанцированиями
от 1 до N. Но мы сейчас
воспользуемся вот таким вот замечательным
типом
Index Sequence.
Причем тут есть
Make Index Sequence, которая
от N, она создает Index Sequence
0,1,2 и так далее, плюс 1,
а есть Index Sequence 4.
Это штука, которая создает Index Sequence
для пакета типов.
Ее можно реализовать...
Все это можно самому реализовать, но оно квадратичное будет.
А вот в стандарте, в компиляторе
вот так реализовано, что
встроено в компиляторе, поэтому работает за...
за линию.
Так, сейчас я напишу такое заклинание.
Еще одно.
Template, type name
there.
Так, что тебе не нравится?
Что-то неправильно сделал.
Ладно, мы считаем, что
понравится.
Static Const Export
T,
Darmit
от Interval Type.
Indices.
Запятая
без комментариев.
Просто ладно.
Ладно, я понимаю, что это без комментариев.
Это что такое?
Да, значит...
Закрыл.
Вот, мне нужно поставить многоточие.
Запятая T звездочка, запятая многоточие,
скобочка закрылась.
Все, все, все очевидно.
Я должен вам показать,
потому что до этого нельзя догадаться.
Вот, а теперь
как будет работать
Get.
О, господи.
Нет.
А как тут еще два многоточия?
Сейчас я напишу, как работает M.
У нас же любая функция вторая многоточия,
c-style.
Да, да, да, да.
Да, да, да, да, да.
Type identity.
Плюсы?
Базахист.
Нет, на плюсы.
Нет, именно плюсы.
Нет, нет.
Так вот.
Да, мазахист скорее.
Я могу что-то писать.
Значит, я Type identity сделаю
с параметрами
add helper
код std
make
index
sequence
от
index
и
выточить, выточить даме
от
вот
вот такого
значит
ts
null ptr
и
сейчас.
Закрытая
многоточие, скобочка закрылась.
Все.
Кажется так.
А
здесь
точка за битой.
Ну, я могу сказать type.
Ну, это, конечно, прикол.
Я не согласен.
Давайте
поймем, что здесь написано.
Нет.
Нет, не понятно.
Мне кажется,
мы воспользовались
тем, что
это
что-то сделал, а когда не
сделал, то не сделал.
Вызвать надо, да?
Декл-тайп закрыть.
Декл-тайп у меня закрылся.
А, да-да-да.
Вот здесь надо.
Да.
Почему мы возвращаем,
значит...
Нет, все нормально.
Смотрите.
Что такое
кред-хелпер? Вот тут есть
он, во-первых, отыдных sequence,
и тут есть такая функция
констетского, у которой это функция.
Вот это объявление функции, обычной функции,
у которой нет тела, потому что мы ее вызывать никогда не будем,
а возвращает она T.
А что она принимает?
Вот. Она принимает почти все.
Это, ну, типа
Стивна?
Void звездочка.
Вот это выражение с
опять.
Вот. Его тип
это Void звездочка.
И
здесь таких Void звездочек будет в количестве,
сколько было индексов.
Смотрите,
это функция, у которой
сигнатура следующая.
Она принимает несколько раз
Void звездочку
в таком количестве, сколько индексов было
в пакете параметров.
Вот это распаковка пакета.
Дальше T звездочка.
А дальше T звездочка, и дальше
что угодно.
И вернет она T.
Поэтому, как мы ей воспользуемся,
мы спросим, а какой тип
вернуться бы, если бы мы
у AdHelper с параметром
MakeIndexSequence
от нашего индекса
вызвали данные
от всех наших типов,
от указателей на все на все наше
добро по одному.
За счет того,
что их ровно столько,
за счет того, что у нас индекс
именно такой,
то именно на таком месте будет T звездочка
и именно такой возвращение тип будет
у этой функции Dummy.
Я ничего не понял.
Нет, вообще ничего не понял.
Еще раз, функция Dummy
Ну смотри, функция Dummy, ну давай.
Dummy,
у которой квадриллятор
сам определит тип T,
потому что мы его никуда не передаем никогда.
Которая принимает
зачем-то
сколько-то будет звездочек.
Зачем на них декладать?
Первый аргумент
декладать, чтобы мы могли
сделать
распаковку по количеству.
Что такое
распаковка по количеству?
Зачем она вообще
индексес, если она просто
делает сколько-то подряд?
Это просто нам надо
сделать сколько-то подряд будет звездочек,
чтобы на нужном месте была
та звездочка.
Нужное место, это место с нужным индексом.
Потому что нам нужно, чтобы возвращение
тип этой функции был T, где T
это вот то, что на нужном месте.
И он типа обгадает сам
Откуда возьмутся индексы?
Индексы возьмутся
из того, что сколько индекс-секвенсов.
Индекс-секвенс создает
последовательность из индекс
элементов.
Элемент на позиции I, перед ним стоит
и элемент.
Хорошо.
Мы
создали последовательность
чисел за линию
длины индекс.
Как это будет выглядеть
у этого helper?
Он первый
индекс будет
с любой звездочкой.
А следующий будет
с той звездочкой, где T шаблонный.
И он должен подобрать T, чтобы правильно
принять соответствующий аргумент
из TS.
Как раз тип
с номером индекс.
И он T правильно тогда поделит.
И вернет его нам.
Значит, ну давайте я статик
еще кто-нибудь допишу, сейчас мы проверим,
правильно ли все происходит.
Если я один дабл чарк,
что на втором месте?
Эд с параметром два
с шаблоном параметром два.
Что на втором месте?
Я хочу, чтобы там
было TypeIdentity.
Так, а
у меня нету сравнений для TypeIdentity.
Очень плохо.
Ммм, ну можно взять
кип-депагрете и достать его оттуда
и поставить объект.
Ну да.
Ну а какой параметр?
Везде звездочный.
Ну можно же...
Ну давайте
через DoubleType сделаем.
Мне по-хорошему надо было бы еще
сделать
оператора сравнений для типов,
но уже никак.
Почему мы возвращаем TypeIdentity?
А что?
Раньше мы возвращали...
Потому что объект TypeIdentity
вообще говоря мы не можем создать.
Мы создаем либо TypeList, либо TypeIdentity,
и мы работаем.
А раньше мы создавали...
Да, мы создавали объектив, да, хорошо.
Но только TypeList мы до этого возвращали.
Ну и SameWay от DoubleType
от вот этой штуки.
Да, и SameWay от DoubleType от вот этой штуки.
И запятая Ч.
Да.
Сейчас, наверное, еще не скомпилируется.
Да, не скомпилировалось,
потому что я не подключил
IndexSequence.
IndexSequence у меня в utility.
TypeValue mismatched,
сейчас...
А, SDB IndexSequence
он...
А он вначале принимает такое...
А потом принимает
число.
SizeT и...
Нет, MakeIndexSequence.
Так, сейчас, давайте разберемся.
В 61-й строке
у меня
Expected the concept of type
on the side.
But it's on MakingIndexSequence.
Я специализирую...
А...
А, ну да, мне нужно...
Мне нужно вот здесь
TypeNameT
писать.
Кажется.
Да?
Да.
Потому что
я специализирую шаблон AdHelper
для типа IndexSequence.
А до этого говорилось, что этот шаблон отчислил,
а не от типа.
Поэтому вот у него специализация не подошла
под общую версию.
OK, AdHelper, IndexSequence
от этих индексов.
Ну и на каком месте у меня это звездочка оказывается?
У меня получается
сколько? У меня получается
Ну, я вызвался от двойки, да?
Я сказал, на месте 2.
То есть у меня индексов должно быть
у меня 0, 1, 2 получатся, эти индексы.
То есть мне надо здесь, кажется,
вот здесь
делать, где-то
надо минус 1 делать.
Вот здесь минус 1 надо делать, кажется.
Должна создаться последовательность
из индекса элемента.
Хотя на этапе у вас все нормально.
Это вроде все нормально.
Не надо ничего делать.
У вас же от 0 еще 10 минут.
Поэтому будет элемент, а то есть и минус.
Нет, все как делалось.
И Same Weight не сработало.
Не давало нужной реализации.
Тип не тот, а какой тип?
Вот сейчас ты, Чарль.
Секундочку, а у вас
декл-тайк-то возвращается
или сравниваетесь с Чарльом.
Ну понятно, что мне нужно
сделать декл-тайк.
Это у всего твой .b.type.
Нет, это не надо,
потому что декл-тайк
все работает.
Понятно.
К сожалению,
не успел я вам показать
реверс.
Ну я еще не понял.
Важно, это задание было нельзя догадаться,
потому что реверс
типа чапывает.
Реверс можно сделать
с помощью add.
За линию.
За линию, да.
Ну вам просто надо
там
нет, я
сходу не могу сказать, что надо.
Но, короче, я
сходу не могу сказать, что надо.
Ну, в смысле, чтобы не инстанцировать рекурсивно,
чтобы тебе не приходилось создавать
n типов, у каждого из которых
n шаблонных параметров.
Сортировка.
Там же придется n раз выливать add.
Нет, вот это
смысл, что не надо.
Если ты вызовешь n раз add, то ты обосрался.
Я люблю защитить add в реверс.
Мне все очень нравится, что у нас лист, который в операции
за УАД на минимум.
В бетончик же быстрее.
В бетончик же можно класть
объекты типа тип листы.
Значит,
я напоследок покажу вам
шедевральную совершенно вещь,
в моем взгляду.
А как он ранды берет?
Ты должен висорть.
Комментарии это замечательно.
Значит, это быстрая сортировка
для метод
контейнера.
Ну вот, статик ассерт.
Ну вот тут
значит...
Тут где-то написано...
Как он решил, какие типы меньше, а какие
более?
Вот как он решил.
Смотрите, у меня для начала тест.
Давайте я объявлю структуру их маленькая,
она параметра небольшая.
Вот.
И для нее определю
мне эту функцию less, которая будет
принимать две маленьких их,
у кого из них меньше, у кого индекс меньше.
Вот. Ну очень просто.
Вот берем теперь статик ассерт,
что сортировка
вот такого вот
списка,
это будет type list,
только сортировка, наверное, должна все-таки принимать type list,
а она принимает
последовательность типов, ну,
ничего страшного.
Сортировка
использует его
как...
Ну, для тех типов, для которых мы вызвали,
он определяет.
Короче, мы не можем вызвать ни для чего проект, как вот для этих типов.
Да потому, что нельзя сортировать
производить.
Вау.
Вот.
А, смотрите,
ну давайте быстренько пробежимся,
что здесь происходит.
Вот есть
сайзор.
Ну, во-первых, да, есть type list, уже нам известный,
есть структура less,
в которой мы специализируемся.
Значит, есть partition,
потом поговорим, что это такое.
Значит, есть конкатинация двух type lists,
оператор плюс.
Который возвращает type list,
вот здесь используется type list,
который возвращает type list
от двух
склеенных пакетов.
Почему она
мы все время
сядем через return
Если мы будем ее вызывать,
то она что,
должна иметь тело на смене?
Мы будем
декл-тайп.
Мы будем только декл-тайп.
Да, мы декл-тайп
вот это всего
визал.
А,
значит,
quick sort.
Ну, quick sort это
note type list некоторых типов.
Да, хорошо.
Статик авто.
Что это с выращением вообще?
Это объявление функции.
Статическая функция,
в которой возвращается авто и иконы.
Которая, да.
А, он структ написал, вот он плохой человек.
Вот, а тут
quick sort специализируется
для случая, когда
еще есть пиво.
Кстати,
в каком мире
эта специализация?
Кстати, непонятно, почему сейчас.
Почему
у него это не вызвало ошибку.
Если,
казалось бы, до этого quick sort был только от типов.
А, тип, все нормально.
Pivot это тоже тип.
Значит, теперь
у нас есть pivot.
Ну, правильно, потому что pivot это же элемент
листа.
Не, это плохо.
Ну, хорошо.
Какой-то элемент массив называется pivot.
Вот, теперь смотрите,
что происходит. Result.
Вот, если мы делаем quick sort
с данным пиводом от такого номера типов,
то мы возвращаем result
вот
такой вещи.
Тут fold expression написан,
мы делаем partition под pivot
и дальше
через fold expression
делаем присваивание
до подиады последнего типа
и всего этого join.
Что такое partition?
Что такое точка join?
Давай сначала помечу про partition.
Partition
это такой
опять же, такая метафункция
или структура.
У нее параметр есть pivot
и есть
левый пакет типов,
правый пакет типов.
Она принимает
значит, два type листа
и у нее есть
оператор равно.
Ага.
Ну, вот здесь partition
от pivot
это да, это partition,
которая приняла два пустых листа.
И это все распаковалось,
дальше происходит оператор присваивания
от partition pivot
два пустых листа, partition
pivot
и
значит, первый тип
из списка типов.
Вот. Сконструированный
по умолчанию.
Что будет такое
и сам представлять
значит, это
присваивание. Мы берем
partition, у которого
есть
у которого нет никаких типов
правых пивота и есть какой-то еще тип правых пивота.
Да, здесь
с типу 20 пишем requires.
Вот. Если
у нас тип
u оказался меньше, чем
pivot, то мы попадаем
в эту версию и возвращаем
partition с pivot,
в которую в левой тейп-листе написано u,
а в правой тейп-листе ничего не написано.
Нет, потому что
оператор одного смысла надо подрубаться
с левой направо или с правой?
С левой направо, потому что это fold expression.
Fold expression
А, тоже с лобочек оставлен.
Да, он делает ассоциированный с левой направо.
Вот.
Значит, здесь
мы в зависимости
от того, меньше или больше
этот тип, чем
пивот, либо к левому
тейп-листу дописываем,
либо к правому листу дописываем.
Но здесь мы просто
все допишем к левому тейп-листу, кажется,
при первом проходе.
Да, потому что, что такое join?
Join – это мы сортируем
левый,
а делаем
тейп-лист из одного лишь пивота и сортируем
правый и конкурсируем.
Приколепно.
А почему оператор равно?
Он же как-то, ну, не себя даже
возвращает, что-то странное.
Я не знаю, почему здесь оператором равно.
Ну, типа, надо оператором,
потому что оператор и только оператор
можно через три точки описать.
Да.
Равно – это, типа, знаешь,
как насторонняя стрелочка,
связанная листом.
Я не верю, что это работает займок.
Ну, как себе сказать.
Ну, запусти на тысячи.
Мы же не умеем выбраться.
Мне кажется, работает за квадрату,
честно говоря.
Давайте быстренько на питочке нанерим
большую массив, запекаем текст
и дальше запустим тайм.
Нужно еще помнить, что
типа асинтотика еще должен быть
на большой констант.
Ну, запустим.
Так надо исследовать это.
График функции.
Я сомневаюсь, что этот квит
и сорт ни хрена не будет.
Ну, он быстрее, чем тот,
что стыдно.
Быстрее, чем отсутствие.
Да.
Сейчас, как он выбирает,
как он пивот второй раз выбирает?
Пивот всегда первый элемент.
Пивот всегда первый элемент.
Это же кримич.
Пивот всегда первый элемент.
Пивот всегда первый элемент.
Окей.
Тогда упорядоченный в обратном порядке лист
будет работать.
Да, это жестко.
Ну, мы здесь знаем,
как написать гет.
Да, самописный гет
с самописным рандом лучше работает.
Что такое рандом?
Космекспер-ранд в чем проблема?
В чем проблема?
В чем проблема?
В чем проблема?
Сейчас...
Не, ну, че, идеи наканунеет генератор,
или как он называется.
Просто берешь остатки какого-то большого
простого модуля и...
И каждый запуск он будет генерить.
Смоси, записывай за файл, а потом запускаться.
Космекспер-ранд
это консектуально полная хрень.
Так что если вы скопируете
тот же файл пару раз, то будут разные типы.
Ооо!
Ладно, на этом весело
я предлагаю закончить.
