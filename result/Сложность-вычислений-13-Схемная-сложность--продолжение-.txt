Мы обсуждали быстрые сумматоры и увидели, что если делать всё тривиальным образом,
то будет длинная цепочка, которая будет долго работать.
Но есть вариант подсчитывать быстро.
Дальше начали изучать общую теорию схем.
На схему можно смотреть по-разному. Мы изучили несколько разных взглядов.
Это, может быть, размещенно-ориентированный граф, который похож на реальную микросхему
и вычисляет какую-то буревую функцию.
Это могут быть машины теории, которые получают нефрю подсказку.
Могут быть прямолинейные программы без всяких условных переходов на циклах и так далее.
Мы обсудили, что это всё будет одно и то же.
Дальше обсудили, какие возникают классы. Важный класс возник П-слеш-поле.
П-слеш-поле – это класс языков, которые распространены в сетчатке.
Тут U, Unary, SelfApply. Это множество номеров машин, которые самоприменимы.
Это лежит в фонарьной записи.
Важный класс возник П-слеш-поле.
Это множество номеров машин, которые самоприменимы в фонарьной записи.
Это лежит в П-слеш-поле, но не в П, поэтому у нас есть строгое выложение в П-слеш-поле.
Дальше мы изучали разные вопросы про то, как П-слеш-поле связано с другими классами.
Мы успели доказать терему Карпеллиптона, что если NP вложено в П-слеш-поле,
то тогда полиномиальная иерархия слопается на втором уровне.
То есть pH равняется sigma2 полиномиальному.
Дальше мы анонсировали более сильную терему Меера.
Опубликована она была в той же статье, что терема Карпеллиптона.
Но они там ссылаются, что это Меер доказала, а они только рассказывают.
Соответственно, по сравнению с теремой Карпеллиптона, здесь более сильные условия.
То есть если даже exp вложено в П-слеш-поле, то тем более NP вложено в П-слеш-поле.
Но и более сильные заключения.
Так же ясно, что поскольку pH вложено в exp, то если exp равно sigma2,
то pH тоже равно sigma2, потому что sigma2 всегда вложено в pH,
а pH вложено в exp, если эти штуки равны, то и pH тоже между ними.
Теперь можно начинать доказывать терему Меера.
Ясно, что достаточно доказывать одно вложение.
Ну и техника будет следующей.
Техника будет следующей.
Ясно, что нужно доказать только в одну сторону.
Так, значит, доказательства.
Доказательства заключаются в том, что достаточно доказать,
доказать, что exp вложено в sigma2-пальномиальное.
Потому что в другую сторону вложения уже автоматически есть.
Это делается так. Пусть у нас есть какой-то язык из exp.
Когда для него есть какая-то машина.
Найдется машина М, такая, что, во-первых, у нас х лежит в А тогда и только тогда,
когда М от х равно единице.
И на входах длины N машина М работает не больше, чем какая-то конкретная экспонента.
Не больше, чем 2 в степени C на N степени D шагов.
Какая-то экспоненциальная функция.
Что это значит?
Это значит, что если мы рассмотрим протокол работы машины чуринга,
то это будет таблица вот такого вот размера.
Ну, давайте обозначим E от N.
Это получается таблица размера E от N на E от N.
В этой таблице перечислены последовательно все конфигурации в ходе вычисления.
Так, тогда за экспоненциальное время можно заполнить всю эту таблицу.
И получается в частности выяснить содержимое любой конкретной ячейки.
То есть есть какая-то другая экспоненциальная машина.
То есть существует экспоненциальная машина, какая-то M штрих,
которая по паре IG устанавливает содержимое ячейки с номером IG.
С координатами можно написать IG.
При этом, соответственно, IG лежат в диапароне от 1 до E от N.
То есть записываются по линомерным числам битов.
Поскольку само число имеет бит экспоненту, то число битов – это логарифм, то есть порядка C на N в степени D.
Так, теперь поскольку эксп вложено в P слэш-поле,
то найдется схема полиномерного размера, вычисляющая результат M штрих.
При этом, поскольку аргументы M штрих имеют полиномерную длину,
то и размер схемы.
Давайте как-нибудь обозначим эту схему.
Но надо только явно написать, что она зависит от N, что результат M штрих на входах не длинные.
Поскольку мы считаем, что вот эти IG имеют какую-то фиксированную длину, то есть мы с ведущими нулями их записываем, то есть число битов в них заранее фиксировано.
То есть мы фиксируем длину входа, но сам вход может быть каким угодно такой длинный.
Ну так и IG это у нас индексы, то есть мы все ячейки в таблице вычисляем.
И IG это соответственно координаты ячейки.
Нет, но в плане таблицы же будут разные для разных ходов.
И вот мы считаем, что любой вход такой длинный, и M штрих умеет их считать.
А, ну вообще да.
Вот сейчас знаете, как лучше мы сделаем.
И E от N как летный полинов обозначим, а вот тут, наверное, пшу меньше либо ровно.
То есть это будет значить, что такой таблице точно хватит для того, чтобы все записать.
Вот, поскольку документы M штрих имеют полиномиальный от N длину,
то схема имеет полиномиальный размер не только от своих входов, но и от N.
Потому что полином от полинома это полином.
Ну а дальше происходит что-то вроде теоремку Клевина.
Теперь нужно записать формулу.
Да, как в теореме Клевина, которая будет означать, что Cn вычисляет полиномиальный от N.
Вот, то есть что нужно писать.
Да, можно написать что.
Мы хотим написать, что во-первых, там все начинается как-то.
Cn от 0.0, это значение стояния Q0.
Да, значит, и там Cn от 0.1, это первый бит икса и так далее.
И Cn от 0.0, N равно Xn.
И там Cn от 0.0 и N плюс 1 равняется…
А, это лучше написать так.
И для любого K больше N, Cn от 0.0 и K, это равняется пробелу.
Мне кажется, на этой стадии мы зафиксировали и вход тоже.
То есть схема же для конкретного входа может справиться.
Пока показывали, но мы хотим сводимость строить.
Конечно, конкретная формула в sigma2 будет зависеть от входа.
Так и должно быть.
Но можно здесь приписать, что там корректный протокол на данном входе.
Эта строчка означает, что начальная позиция правильная.
Дальше существует какой-то индекс K.
Такой, что Cn от 0.0 и K равняется QAccept.
Это конечное состояние принимающее.
Ну и, наконец, для любого I, для любого J, Cn от IJ равняется какой-то конкретной функции F.
Там вот Cn, и минус 1, и Cn, и минус 1, и минус 1.
Тут и минус 1J, значит, Cn от i-1J плюс 1, да, и еще Cn от i-1J плюс 2.
Это означает, что каждый шаг корректен.
Ну и тогда получается, что...
Тут правильно вы спрашиваете. Важен порядок кванторов.
Точнее важно сказать, что и так, и так может быть.
В итоге хочу сказать, что X лежит в нашем языке.
Значит, тогда и только тогда, когда существует схема Cn,
значит, такая, что... Тут, в общем, конъюнция трех предыдущих формул.
Конъюнция трех предыдущих формул.
Ну и тогда, если вывести кванторы в правильном порядке...
То есть тут есть вот квантор существования, вот квантор всеобщенности, вот квантор всеобщенности.
Значит, при вынесении кванторов в правильном порядке получим как раз sigma2 формулу.
Вот. Тут как раз за счет стерлинга Клевина мы прям явным образом писали конъюнцию.
И поэтому там нам годились только полинемиальные вычисления.
А здесь мы не пишем явную конъюнцию, а пишем квантор.
И поэтому тут уже переменные под квантором, может быть, полинемиальные длины,
поэтому уже годятся экспоненциальные вычисления.
Вот. Ну вот, а это и значит, поскольку мы получили sigma2 формулу,
соответственно, с параметрами х, то как раз и получим, что как раз параметры...
что как раз вот эти вот биты, которые параметры образуют х из нужного множества,
тогда и только тогда, когда верна такая sigma2 форму.
Вот. Это и означает, что А у нас лежит в sigma2 полинемиальный.
Вот. Получается вот такая вот конструкция.
Так, ну что, нужно ли еще что-нибудь пояснить?
Видим, все понятно. Есть у меня тут одно важное замечание.
Значит, важное соображение.
Важное соображение, что если действительно эксп равно sigma2 полинемиальному,
то тогда P не равно NP.
Потому что при P равно NP верно, и P равно sigma2 полинемиальная.
Вот. Но тогда P равно эксп, что противоречит теореме об иерархии.
Вот. Таким образом, верхнюю оценку в одной модели значит то,
что у нас эксп вложено в P slash поле.
Можно использовать для нижней оценки в другой модели.
То есть P не равно NP.
Ну, это вот такой вот поучительный пример.
Верхняя оценка на сложности.
То есть верхняя оценка означает, что в модели схем, экспедиционное вычисление
можно делать с использованием полинемиального размера схем.
Это верхняя оценка на размер схемы.
А P не равно NP – это нижняя оценка на время работы для NP полных задач.
Ну и вообще получение нижних оценок, каких бы то ни было,
это самая сложная часть в теории сложности вычислений.
Ну, в том числе и P не равно NP тоже никто не умеет показать.
Так.
Хорошо.
Ну и теперь я хотел бы немножко вернуться к быстрым сумматорам.
Давайте вернемся к быстрым сумматорам.
Нет никаких нет вопросов.
А именно поговорим, что помимо размера схемы важный показатель – это ее глубина.
Если схема моделирует какие-то реальные микросхемы, то именно глубина отвечает за быстродействие.
Так же схемы используют для моделирования параллельных вычислений.
Предполагается, что в разных частях схемы у нас будут стоять разные процессоры,
которые будут параллельно какие-то вычисления проводить.
Соответственно, там глубина тоже соответствует времени работы отдельного процессора.
Ну вот, поэтому это нас интересует.
Ну и в частности интересуют схемы с логарифмической глубиной или полилогарифмической.
Значит, тут становится важно, какая входящая степень, какой элементов конъюнса и дезюнса.
Два или произвольная.
Ну, потому что элемент совходящий степень юка можно смоделировать двоичным деревом глубины.
Ну дайте я напишу верхнюю целую часть.
Логарифмука.
Ну это соответственно может, если так на всех уровнях сделать, глубина изменится в соответствующий число раз.
Так,
хорошо, значит, таким образом у нас будут два,
два семидесятоклассов.
У нас будет nc, ncdt.
Значит, это nc или nc, это на самом деле собственное.
Этот класс назвали в честь конкретного человека Николаса Питтинджера, поэтому это называется nx-класс.
Значит, ncdt это класс языков, которые распознаются семействами схем полиномиального размера.
Полиномиального размера и глубины.
Большой логарифм n в тепени D.
И дальше могут накладываться условия равномерности.
То есть, может быть, схема cn может быть вычислена, может быть найдена логаритмически за время полинома от n.
Значит, это называется полиномиальная равномерность.
И также может быть то же самое, только на логарифмической памяти.
Так, значит, тут на памяти, на памяти большое логарифм n.
Это, соответственно, логарифмическая равномерность.
Но может ничего не накладываться, тогда будет неравномерное семейство.
Ну и, соответственно, есть также ac dt.
А тут удивительно образом, это a уже никого конкретно не означает.
Это anyfanin-класс.
То есть с любой входящей степени.
Так.
Да-да-да-да, это надо дописать вот здесь.
Значит, где элементы конъюнция и дизъюнция имеют входящую степень была.
Вот, соответственно, тут то же самое, только элементы уже имеют произвольную степень.
Значит, где элементы имеют произвольную входящую степень.
Ну и также могут накладывать условия равномерности.
Вот, значит, тогда это образует иерархию.
Значит, образуется иерархия.
Это значит nc dt вложено в ac dt.
Это вложено в nc d плюс первое.
Так, ну первое очевидно.
Ну и дальше это может так раскручиваться.
Значит, первое вложение очевидно, потому что 2 – это частный случай произвольной степени.
А второе следует из того, что в схеме полиномиального размера
элемент конъюнция или дизъюнция не может иметь больше полинома входящих рёбов.
Ну и получается, что поскольку нужное дерево имеет глубину порядка логарифма,
логарифма входящей степени,
значит, она будет равна большой от логарифма от полинома от n.
А это будет то же самое, что большая от простого логарифма n.
Ну, что и даст множитель.
Что и даст увеличение степени логарифма на 1.
То есть мы логарифм в DET, умножаем ещё на логарифм, получаем логарифм DET плюс 1, что здесь написано.
Возникает вопрос, а в этой иерархии что со слопыванием?
Будут ли вложения строгими?
Ну и на этот счёт есть некоторый ответ.
Что точно будет, что nc0 не равно ac0.
Дело в том, что 0 означает константную глубину.
Тут будет константная глубина.
А если и входящая степень константна, то функция может зависеть только от константы аргументов.
Можно доказать, что если у нас глубина D и каждый рассветление в два раза, то максимальная зависимость будет 2 в степени D.
Но если D констант, то это будет какая-то констанция, если отец больше, то уже от каких-то бит в зависимости не будет.
При этом сама конъюнция всех аргументов лежит в ac0.
Потому что у нас есть произвольная конъюнция.
И зависит от всех аргументов.
Изменение любого аргумента может повлиять на значение конъюнция.
Вот это известно.
Ну и также известно, что ac0 не равно nc1.
Это уже посложнее теорема.
Но по крайней мере я расскажу, какая тут функция будет лежать в большем, но не в меньшем.
Это будет просто parity, функция четности.
Функция четности.
То есть просто x1, боксоренное со всеми, боксоренное с xn, лежит в nc1.
Потому что можно построить двоичное дерево из ксоров.
А отдельный xor можно выразить формулой, схемой константной глубины.
Но не лежит в ac0.
Я бы назвал это как именноторно-гематологическое доказательство.
Это сложная целая лекция, даже в одном из проектов есть.
Это тема одного из проектов.
Правда, это не самый сложный проект.
Там есть некоторое рассуждение с приближением разного количества членов.
Это я не буду подробно рассказывать.
Ну ладно, есть ли какие-нибудь вопросы?
Там еще есть некоторая связь с классами l и nl.
Это я вкратце тоже напишу.
Если рассматривать логарифмически равномерные схемы,
то получается, что тут будет nc1.
Надо еще сказать, что про все дальнейшие вложения в nc-ерархию ничего не известно.
Даже вроде не умеет доказывать, что np там не лежит.
Оказывается, даже про nc1 не умеет доказывать, что там np не лежит.
Надо уточнить.
Открытый вопрос, равно ли nc1 и np.
Если рассматривать логарифмически равномерные схемы, то для них будет nc1 вложено в l,
это вложено в nl, это вложено в ac1.
В частности, вопрос о равенстве l и nl тоже связан со строкостью вложения на следующем уровне.
Но тут я давайте совсем вкратце отпишу.
Может быть, у нас семинар в каких-то группах будет подробнее.
То, что nc1 вложено в l, нужно аккуратно указывать,
что из-за того, что у нас глубина логарифмическая,
мы можем настроить рекурсию логарифмической глубины и вычислять ответ.
Что именно там вычислять, поскольку у нас схема логарифмически равномерная,
то мы сможем на ходу понимать, какие функции использовать.
Прям такая идея.
А nl вложенного ac1 следует из того, что задача о достижимости в графе будет nl полной,
и она будет решаться в ac1.
Вот у нас была схема для быстрого сумматора.
Дальше можно приделать схему для умножения матриц.
А поиск пути – это более-менее есть умножение матриц,
но только там такое специфическое, так называемое дезюмпное умножение.
В общем, может быть, на некоторых семинарах это будет подробно изучено.
А сейчас, если вопросов не появилось,
то я бы полчаса поговорил про вероятностный алгоритм.
Вот круг некоторых конкретных алгоритмов.
Так, ну что, вопросов нет.
Хорошо, поговорим про вероятностные отчисления.
Основная часть будет в следующий раз.
В следующий раз поговорим про вероятностные классы.
И сегодня поговорим про некоторые конкретные задачи, которые решаются миресным образом.
Ну и там еще есть вопрос, какая у нас модель вычислительная.
Будем считать, что результат работы алгоритма может зависеть от исходов некоторого случайного процесса.
Например, бросание монетки.
В зависимости от исходов, результат, ну как бы ответ, может быть различным.
В зависимости от исходов ответ может быть различным.
И поэтому то есть ответ является случайной величиной.
Ну и соответственно, если ответ бинарный, то могут быть два типа ошибок.
Первого рода и второго рода.
В зависимости от того, что там происходит.
То есть какой настоящий ответ и какой ответ дает машина.
Значит, ошибки первого рода это положительные срабатывания.
Альфа ошибки ниже положительные срабатывания.
Значит, это настоящий ответ нет, а алгоритм отвечает да.
Это ошибки второго рода.
А ниже бета ошибки.
Или ложно-отрицательные срабатывания.
Наоборот, настоящий ответ да, алгоритм отвечает нет.
Значит, если ответ не да или нет, ответ сложный, то получается, что важна вероятность получить правильный ответ.
Ну либо, наоборот, можно очень много разных вариантов рассматривать.
Тут целые матрицы разных ошибок получаются.
Но при этом нужно отличать вероятность.
Вероятность, что ответ машины такой при условии, что настоящий ответ и наоборот.
Вероятность того, что настоящий ответ такой при условии, что ответ машины такой.
Потому что если у вас очень сильно отличаются абсолютно вероятности разных ответов, то тогда и вот эти условные вероятности будут тоже совершенно различные.
Значит, они могут сильно отличаться, если вероятности различных настоящих ответов существенно отличаются.
Ну и в целом различают несколько видов алгоритмов.
Несколько видов вероятностных алгоритмов.
Есть так называемые алгоритмы Монте-Карла.
А алгоритм Монте-Карла это ситуация, когда ответ всегда правильный.
Нет, наоборот, значит ответ всегда выдается быстро, но может быть ошибочным.
Наоборот алгоритмы Лас-Вегаса.
Ответ всегда правильный, но может считаться очень долго, хотя в среднем быстро.
Еще бывает алгоритмы Атлантик-Сити.
То есть на ответ обычно правильный и в среднем считается быстро, но нет гарантий ни того ни другого.
Конечно, алгоритм Атлантик-Сити похуже, но бывает так, что ничего другого нет.
Важная задача, на которой долгие годы развивалась теория и разработка алгоритмов, это проверка простоты.
Задолго до АКС алгоритма были придуманы вероятностные тесты простоты.
Поскольку тогда же в конце 70-х были открыты криптографические протоколы на базе простых чисел,
то оказалось, что поиск простых чисел – это важная область.
Поэтому как раз были разработаны много разных методов.
Простейший тест – это тест фирма.
У нас есть малый теориям фирма.
Малый теориям фирма, что А в степени P-1 сравним с единицей по модулю P.
Тест фирма – выбрать случайный остаток А.
Дальше можно проверить, что наибольший общий делитель А и П равен единице.
Если вдруг не равен, то это точно не простое число, поскольку делитель обнаружился.
Вторая вещь – что А в степени P-1 сравним с единицей.
И тут есть проблема.
Проблема с таким методом заключается в том, что есть числа кармаекла.
Для чисел кармаекла это равенство тоже всегда верно.
Если число не является ни простым, ни числом кармаекла,
то тогда максимум для половины остатков будет верно.
То есть вместо простоты тест распознает простоту или кармаекловость.
Что-то он делает, но не совсем то, что мы хотим.
Дальше я расскажу про некоторую надстройку над этим тестом, который уже работает.
Если А в степени P-1 сравним с единицей, то А в степени P-1 пополам
сравнима с плюс-минус единицей.
При этом, если А в степени P-1 пополам сравнима с единицей,
то А в степени P-1 на 4 сравнима с плюс-минус единицей.
Теорема, которую Миллер и Рабин доказали.
Если А простое, то тогда в ряду А в степени P-1 на 2 в степени K
или так и дойдет до конца этого ряда.
Если же P составное, то это будет верно максимум для 1 четверти.
Вот всех А взаимно простых с P.
Ну и тогда получается тест на базе теоремы.
Тест на базе теоремы выглядит так, что выберем случайное А и проверим это условие.
Проверим указанные условия.
Сначала идут единицы.
А в степени P-1 должно быть равно 1, а не минус 1.
Конечно, начинать нужно с единицей.
В этом заключается теорема.
Если нужно повысить точность, можно брать не одно случайное А, а несколько независимых друг от друга.
Проверяем, что для всех А это условие выполнено.
А получается, что если у нас 1 четверть, то чтобы все тесты пройти, нужно чтобы каждый из 10 попал в 1 четверть.
А это будет 1,4 в десятые, то есть 1 миллионная вероятность.
Что уже достаточно немного.
Хорошо, что тест Миллера Рабина.
Есть также много других разных тестов.
Последнее, что я сегодня расскажу, это задача по проверке многочленов на равенство.
На первый взгляд, в чем задача?
Проверить, что два наночления одинаковые.
Надо просто посмотреть, что коэффициенты одни и те же.
Значит, одинаковые.
Но это так легко сделать, если наночения заданы явно.
Даже если у них перепутаны коэффициенты, то можно отсортировать и тоже сравнить.
Может быть так, что во-первых, там может быть много переменных,
и во-вторых, они могут быть заданы не прямым способом,
то есть не списком своих коэффициентов,
а может быть какое-то сложное выражение со скобками и так далее.
А в общем случае, это даже какая-то архиметическая схема.
Пусть есть два постановка.
Пусть имеются два многочлена, заданных арифметическими схемами.
Это аналоги булевых схем, в которых вместо логических операций
стоят сложение и умножение.
Ну и тогда получается, что входящие вершины помещены переменными.
Ну и соответственно, в результате выполнения всех операций
получится многочлен вот этих переменных.
Ну и соответственно, теперь получается, что просто так раскрыть все скобки
за полиномиальное время не получится.
Ну потому что даже если у меня там произведение n скобок,
там какой-то x1 плюс y1, умножить на и так далее, умножить на xn и плюс yn,
значит это уже получается выражение с два в степенем слагаемыми.
Ну и соответственно, вот эта x и это y, это могут быть не отдельные переменные,
а тоже какие-то там одночлены или что-нибудь.
Уже такая штука будет выражением с два в степенем слагаемыми.
Уже просто так не получится раскрыть.
Вот, ну а кроме того, значит кроме того, за счет...
значит за счет этого итерированного умножения и степень многочлена
может стать экспоненциально большой.
Ну потому что у нас может быть там какое-то выражение.
Вот так будет получаться.
Степень мы взвели в квадрат, а потом еще в квадрат,
значит и так далее.
Значит вот это в квадрате.
Как раз вот такое итерированное воздействие в квадрат можно за счет этой схемы,
вот в этом умножении одно и то же засовывать.
Получается, что это будет равно P в степени 2 в степени n, если это n раз так сделать.
Ну и поэтому даже если у нас там одна переменная,
то просто может очень слишком длинное выражение получиться.
Вот, значит соответственно вот так вот просто раскрыть все скобки нельзя.
Ну и никакого, никакого детерминированного алгоритма.
Алгоритма проверки двух многочленов на равенство неизвестна.
Вот, но есть вероятность алгоритма.
Значит вероятность алгоритма выберем, выберем случайную точку.
Выберем случайную точку и посчитаем в ней значение многочленов.
Если значения не совпали, то многочлены точно разные.
Если совпали, то скорее всего одинаковые.
Вот, но вопрос, где эту точку выбирать?
Смотрите, действительно числами работать не умеем на компьютере.
Случайно натуральное число тоже нельзя взять равномерно.
Если брать случайно в каком-то диапазоне, то за счет этих подстановок у нас очень большое число получится.
Так что мы просто тоже не сможем посчитать.
Поэтому, чтобы процедура была полинамиальной,
нужно брать точку и проводить вычисления в большом конечном поле.
А для этого предыдущая задача.
Тест на простоту.
Размер поля должен быть достаточно большим, чтобы вероятность совпадения была мала.
Но и достаточно маленьким, чтобы можно было проводить в нем вычисления.
Но оказывается, что можно такое взять.
Как раз более экспоненциального размера, существенно большего, чем степень многочленов, подойдет.
Но чтобы тут все сработало, нужна так называемая лемма Шварца-Зиппеля.
Если у нас поле размера P, многочленов 10 переменных, степени D.
Я ее сформулирую и закончу.
Я думаю, доказательство тоже на семинара оставим.
Лемма Шварца-Зиппеля.
Взять в следующем.
Просто многочлен от N переменных, не нулевой многочлен, от N переменных, степени D имеет не больше, чем 1-D делить на P.
1-D делить на P в N корней в поле размера P.
Если N равно 1, то это просто утверждение о том, что степень D не больше, чем доля корней.
Я не то написал. Больше либо равно, а наоборот как бы не корнить.
Это доля.
Имеет долю больше, чем столько точек, в которых он не равен нулю в поле размера P.
Теперь вот правильно.
Ну, корней будет меньше, чем 1 минус вот такая штука.
Если доказать, то это обосновывает, почему такое работает.
Потому что если P достаточно большое по сравнению с D, то есть P должно быть сильно больше, чем D, может, на N, например.
Тогда вот эта штука будет все еще близко к единице.
И, соответственно, вероятность попасть в корень будет маленькой.
Ну, все. На сегодня все.
И у нас останется еще два занятия, на которых мы про вероятность поговорим.
Ну и, может быть, еще там про чуть-чуть связанные вещи.
Так, ну хорошо, есть ли вопросы.
Ладно, на сегодня все. Спасибо за внимание.
До встречи.
