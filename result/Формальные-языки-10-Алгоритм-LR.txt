Всем доброго дня. Сегодня мы продолжаем с вами говорить про алгоритмы. В прошлый раз у нас с вами был алгоритм RL, который мы с вами доказали уже.
Я снимал еще дополнительную лекцию 9,75, в которой я еще более детально пояснил все аспекты доказательства.
Это лекция на YouTube. Я скидывал запись с 40 минут, где-то с чем-то она длится, но я там детальнее именно старался все рассказать.
Сегодня мы с вами поговорим про продвижение этого алгоритма, но немного зайдем с другой стороны и поймем, как алгоритм RL можно оптимизировать, но не для всех громадь, к сожалению.
Я не знаю, сколько у нас получится эта тема. Эта тема, возможно, нам дастся за одну лекцию, но я не уверен, сильно не уверен.
В большей степени я уверен, что она нам дастся за полторы лекции, ну а давайте апприксимативную оценку дам, что мы будем не сидеть две лекции.
Сегодня я дам мотивацию, какие-то базовые примеры, а на следующей лекции мы уже с вами будем продолжать доказательства всех фактов, потому что там есть очень много всяких неприятных вещей, которые по дороге нам придется доказать.
Вот, давайте вспоминать, что мы в прошлых сериях сделали. В прошлых сериях, совсем-совсем давно, мы с вами построили MP-автоматы, и в предыдущих сериях мы с вами рассматривали алгоритм RL.
Сейчас давайте попробуем эти две абстракции немножечко соединить. Да, то есть с MP-автоматом мы возьмем с вами стэк, а с алгоритмом RL мы возьмем понятие ситуации.
И давайте посмотрим в следующем. В чем же у нас состоит проблема алгоритма RL?
Мы тоже в куларах обсуждали, но давайте повторим еще раз.
Из-за чего у нас сложность? Кубическая получается или квадратичная?
Из-за complete?
Да, операция complete на самом деле стоит очень много операции, потому что мы для каждой буквы должны сделать O от длины слова в квадрате действия.
То есть нам нужно для того, чтобы сдвинуть точку, напоминаю, что такое complete, это мы берем снизу дерева разбора, закрываем дерево разбора.
То есть для того, чтобы нам сдвинуть точку вне терминала, нам надо обойти все дерево целиком.
И чтобы эту состыковку сделать, нам нужен квадрат действий. И это только для одного символа.
Хотелось бы идеологически сделать так, чтобы мы эту точку могли просто просвеснуть, пройти и все.
Чтобы у нас это все стало за линейное время работать, пришло бы линейное время в сумме.
А давайте подумаем. Вот наша цель сегодня ответить на вопрос, а можем ли мы это делать прямо сразу.
Оказывается, что да, это можно сделать, но не для всех грамматик.
Сейчас мы с вами будем рассматривать грамматики, которые являются однозначными.
На самом деле из хода будущего алгоритма будет понятно, что все грамматики, которые возможны при рассмотрении алгоритма, которые у нас сегодня будут, они будут однозначными.
Это факт будет доказываться не очень сложным образом.
Итак, давайте мы с вами сейчас в качестве примера разберем вот такую вот грамматику.
Опять же, каждый раз мы с вами добавляем правила в грамматике к алгоритме early, правила s's добавляем.
И давайте сделаем два правила. Первое правило, это из s следует ab, а второе правило, из b следует b.
Понятно, что эта грамматика разбирает только одно слово, и это слово ab.
Давайте мы сделаем следующую вещь. Давайте мы попытаемся эту штуку рассмотреть жадным образом.
Что значит жадным образом? Это значит, как только мы увидели какое-то правило разбора, мы сразу схлапываем вверх, то есть поднимаемся наверх пони терминал.
Вот смотрите, давайте как раз вот пример, который у нас есть. У нас слово v равно ab, и будем хранить стэк.
Специальный стэк, в котором мы потом сможем быстро доставать и заменять правую часть правила грамматики на левую часть правила грамматики.
Вот смотрите, вот у нас слово с вами ab, а грамматика такая, давайте ее перепишу, чтобы она была s's, из s следует ab, а из b следует b.
Давайте мы с вами будем строить дерево, я параллельно тут расскажу тоже. Вот смотрите. И храним стэк.
То есть стэк из текущих символов, которые... А, что такое однозначная грамматика? Напомню определение.
Это грамматика, в которой для любого слова существует ровно одно дерево разбора. То есть никаких других деревьев разбора появиться не может.
Ну и смотрите, давайте анализировать. Как мы будем делать? У нас есть слово... Сначала мы находимся здесь.
Следующий символ a. Давайте анализировать, есть ли у нас с вами правило, у которого правая часть является a. Состоит из одного символа a.
Но кажется, таких нет. Если что, я ожидал вашего ответа. Когда я делаю паузу, желательно отвечать, а не сидеть в экране смотреть просто.
Смотрите, у нас такого правила нету, поэтому мы берем... Что делаем? Мы двигаем букву a на стэк, а точку перемещаем вот сюда.
Следующая буква b. Опять же, смотрите, здесь история такая. На стэке... Смотрим, что на стэке у нас с вами.
Можем ли мы свернуть сейчас то, что находится по стэке, как правое часть правила? Нет. Поэтому мы берем и добавляем b в стэк.
Вот смотрите, а тут, наверное, по карту. Да, вот добавляем b в стэк. Двигаем точку вот сюда.
Давайте посмотрим теперь на стэк. Следующего символа у нас нет. Давайте скажем следующий символ от конца строки.
Скажите, на стэке сейчас есть правая часть какого-то правила?
Да, смотрите, у нас есть sb в b. Давайте сделаем следующее. Мы выкидываем этот b со стэка и добавляем левую часть правила на стэк.
То есть мы заменяем sb с b. И мы делаем настройку с вами по этому правилу грамматики. Точка при этом переезжает сюда.
Да, идея такая. Видим правую часть правила, заменяем на стэке ее левую часть. Вот смотрите, у нас появляется b.
Так, теперь, если у нас на стэке правая часть правила. Да, смотрите, вот у нас ab это правая часть правила.
Поэтому заменяем на стэке левую часть правила s. А здесь у нас получается вот такая штучка.
Точка поднимается сюда. Точка напоминает текущую позицию условия. Вот, получается такая вещь.
И, есть ли еще на стэке правая часть правила?
Ну, есть, конечно же, еще s' в s есть. Ну, смотрите, давайте мы тоже ее выкидываем. И в итоге смотрите, что у нас получается.
У нас на стэке с вами находится s'. Да, и мы дошли до конца слова. Это значит, что мы построили с вами дерево разбора грамматики.
Причем, важно подчеркнуть очень важную вещь. Она заключается в том, что если мы идем слово слева направо, то грамматика разбирается справа налево.
То есть, вывод в грамматике у нас правосторонний.
Потому что мы раскрываем самый правый не терминал. Да, то есть, мы с вами понимаем, что если бы...
Ну, тут надо был бы пример, на самом деле. Давайте абстрактно представим, что у нас было какое-то s, потом было bc.
Там, я не знаю, b раскрывалась в какое-нибудь ab, а c раскрывалась в c маленькое.
Да, давайте поймем, почему у нас в первом раскроется не терминал именно вот этот вот.
Ну, тут, на самом деле, это как можно понять? Мы можем понять, что вот этот не терминал у нас появляется только в самом последнем случае.
То есть, у нас получается ab заменится на b, да, потом c заменится на c, да, эти моменты времени проста.
То есть, это первая замена будет, это вторая замена будет, а вот эта замена будет третья, которая поставит символ s совместно.
Теперь отмотаем моменты времени назад. Да, то есть, это, считайте, у нас временная шкала была снизу вверх, но когда мы пойдем во временную шкалу сверху вниз, то нам эти чиселки надо будет расставить по убыванию.
Нам надо будет эти чиселки расставить по убыванию, поэтому вот эта штучка раскроется первой, потом вот этот не терминал c раскроется вторым, а вот этот не терминал b раскроется третьим.
Поэтому у нас вывод грамматики, который мы будем строить таким жадным образом, он является правосторонним.
Да, с другой стороны в алгоритм нерли мы строили с вами левосторонний вывод грамматики, потому что мы шли сверху вниз.
И тут давайте я введу некоторую классификацию, которую я не ввел на презентации. Есть два типа парсеров.
Есть поп-даун парсеры, которые идут и анализируют дерево разбора сверху вниз.
И к примеру, таких парсеров относятся алгоритм нерли.
Ну, с какой-то степени в кавычках. Есть еще один тип парсеров, мы его не будем рассматривать на лекции, он называется ll парсеры, которые пытаются сделать следующую вещь.
Давайте рекурсивно попытаемся раскрывать дерево разбора.
А в нашем случае мы сегодня рассматриваем bottom-up парсеры, то есть которые идут снизу вверх.
И пример такого парсера это lr алгоритм, но пока что мы находимся в базовом приближении этого алгоритма.
Так, пример понятен, который я вот тут рассказал.
Итак, и теперь смотрите, как мы наш алгоритм можем преобразовать.
Он на самом деле называется алгоритм переноса свертка или shift-reduce.
И мы по сути делаем две вещи. Первый, на вершине стека написана правая часть какого-то правила.
Мы заменяем его на левую часть правила, осуществляем операцию reduce.
Если нет, то мы добавляем символ в стек, то есть мы осуществляем операцию shift с вами.
Вопрос. Какие проблемы у нас могут возникнуть с вами в реализации вот этого алгоритма?
Может же быть такое, что какое-то дерево разбора, оно не является деревом разбора?
Ну да.
У нас не очистится стек и мы ничего не сможем сделать.
Нет, ну тогда можно сказать, ну проиграли. Но это хорошее.
Может он недетерминированный?
Да, во-первых, он сильно недетерминированный. Вот вопрос.
А что делать? Тут есть две проблемы.
Первая проблема, а как понять, какая правая часть правила у нас находится на стеке?
Потому что у нас там по сути нам нужно делать откат на несколько символов назад.
И пытаться как-то эту штуку проанализировать. Это раз?
Подождите, это же решает алгоритм Аха-Карасика?
Ну, это да. Поскольку это первая у нас аппроксимация этого алгоритма, ну решим мы ее Аха-Карасикой, но на самом деле этот алгоритм применим к очень узкому количеству грамматик.
И есть еще одна проблема, которая важная.
А что делать, если вдруг у нас таких правил несколько?
Да, то есть мы дошли до какой-то части стека, и в стеке у нас есть две правых части правил.
Что делать будем?
Ну, непонятно, что делать.
Смотрите, давайте скажем сразу, что с этим мы ничего делать не будем.
Мы просто скажем, что для такой грамматики, к сожалению, наш алгоритм не работает.
И при этом сильно сузим класс, появляющий грамматик.
А вот здесь давайте мы на самом деле проанализируем, в каких ситуациях мы с вами проанализируем.
Итак, давайте переложим эту абстракцию дерева на то, что у нас с вами происходит.
Я попытаюсь нарисовать на том же самом дереве разбора.
Вспоминаем, что такое у нас была ситуация.
Ситуация, это у нас было какое-то правило грамматики из А следует Альфа точка Бета.
И мы ставили точку, вытягивая эту точку.
Итак, ну и давайте теперь посмотрим, в каких ситуациях на самом деле мы с вами были.
В тот момент времени, когда мы стартовали.
Давайте я поставлю таймстемпы.
Давайте я скопирую все-таки эту грамматику, чтобы...
...давайте я поставлю таймстемпы.
Давайте я скопирую все-таки эту грамматику, чтобы деревья вывода, чтобы это у нас с вами не мешало нашей постановке.
Так, давайте вот сюда.
И скопируем вот сюда.
Итак, давайте анализировать.
И скопируем вот сюда.
Итак, давайте анализировать.
В момент времени, который он был в начале, в начальный момент, мы давайте вместо того, чтобы пропихивать точку здесь, давайте посмотрим все ситуации, которые у нас сохраняет эту точку.
Как мы это можем сделать?
Давайте мы сделаем операцию, обратную правилу, предикт.
Напоминаю, что такое правило.
Что у нас делает предикт, мы берем и заглядываем внутрь дерева разбора.
Сейчас давайте гипотетически посмотрим, что произойдет, если мы с вами посмотрим вверх, в дереве разбора.
Смотрите.
Значит, изначально у нас в момент времени ноль.
В момент времени ноль.
У нас точка находилась здесь.
Я сотру точки.
Буду обозначать их с момента времени.
Буду писать момент времени для точки.
Эта точка была у нас в нулевой момент времени.
Эта точка у нас тоже была в нулевой момент времени.
И вот эта точка у нас тоже была в нулевой момент времени.
В итоге в нулевой момент времени у нас правила, которые были, точнее ситуации которые были, это из и STEG стрелочка, вот это.
И еще раз, спускаемся из стрелочка .AB. По сути сделали предикт.
Только заметьте, что здесь у нас нет индексов, которые говорят, где в позиции слова мы находимся.
Как раз, на самом деле, по секрету всему свету скажу, что именно хранение позиции занимало у нас квадрат времени.
Это не очень эффективно.
Теперь смотрите. В первый момент времени что мы можем сделать? Мы можем сдвинуть точку вот сюда.
Раз.
И после А у нас получается вот такая вот вещь, что С, стрелочка, А, точка B.
Давайте я вот тут тоже апоксимативно построю это все. Здесь у нас ситуация тоже будет в первый момент времени.
И после этого мы можем с вами сделать тот же самый предикт и опустить эту точку вниз.
Получаем ситуацию B, стрелочка, точка B.
И теперь во второй раз, когда мы делаем операцию shift, точнее сдвига буквы у нас, это будет второй момент времени.
То есть на самом деле мы находимся в ситуации B, стрелочка, B, точка.
Так, понятно ли по моментам времени, как мы получили эти ситуации?
А может вопрос, почему у нас есть треугольник из единичек?
На самом деле треугольник из единичек почему он возникает?
Потому что если дерево построить не таким образом, а букву А поднять на один уровень, то на самом деле это будет одна и та же точка.
А, да, точно.
Да, я просто показал, что это одна и та же.
И давайте посмотрим, как мы их получили.
И тут самая гениальная идея, которая мы сейчас с вами сделаем продвинутым, наш алгоритм.
Смотрите внимательнее. На самом деле, что такое операция предикт?
Вот это самая нетривальная идея. Это на самом деле переход по Эпсилону.
То есть чтобы раскрыть новые правила грамматики, нам нужно просто сдвинуться, прочитать пустое количество символов.
То есть мы читаем пустое количество символов, переходим к этой точке.
Значит, чтобы перейти, допустим, от ситуации вот этой к ситуации вот этой, нам надо прочитать букву Б.
Да, то есть scan это переход по букве.
А complete, как вы думаете, переход по какой букве?
Не терминал.
Да, это на самом деле будет переход по не терминалу, только он достаточно сложный.
И на самом деле теперь мы с вами над множеством ситуаций можем построить недетерминированный конечный автомат.
У нас все с вами готово.
Итак, идея как раз этого алгоритма заключается в том, чтобы построить детерминированный конечный автомат над множеством ситуаций.
А потом его как-то эффективно обходить.
И смотрите, вот я построил его над множеством ситуаций.
Итак, из С-С мы можем по Эпсилому перейти С с релочка точка АВ, потому что это операция с предиктом.
Потом мы делаем переход по букве А, делаем переход вот таким вот, то есть точку сдвигаем.
Дальше и происходит переход по букве Б.
По не терминалу делаем такую вещь.
Здесь ведет переход по Эпсилому, и здесь идет переход по Б.
Давайте подумаем, как мы его можем детерминировать.
При этом важно, в отличие от детерминирования, от классического автомата, что здесь все состояния необходимо сохранить.
Что нам нужно вообще в классическом алгоритме построения НК сделать, построение ДК сделать?
Можно смотреть два степени количества вершин, провести соответствующие рёбра.
На самом деле ДФС сделать, либо ДФС, либо БФС по множеству состояний.
Прежде чем мы это делаем, что нам надо сделать?
Да, нам надо удалить Эпсилом переходы.
Вспоминаем, как мы удаляем Эпсилом перехода.
Мы берем состояние, этоái типа если мы в классическом
алгоритме удалили Эпсилом переходы, то нам пришлось бы делать next, мы берем переход
Мы берем переход по Epsilon, переход по A, стягиваем сюда переход по A делаем.
Да, то есть строим традиционные замыкания. Здесь мы поступим немножечко иначе.
Давайте для каждого состояния, при этом мы с вами будем, по сути, схлопывать все состояния в одно,
из которого достижим Epsilon перехода. Да, то есть мы сделаем Epsilon замыкание.
Сейчас давайте, чтобы было понятно, я поясню на примере.
Вот смотрите, вот у нас было состояние из штриха .s и был Epsilon переход в s, a, b.
Мы берем и с вами добавляем в это же состояние, состояние вида s, стрелочка .a, b.
Потом из этого общего состояния мы делаем переход по букве A и пытаемся сдвинуть точку во всех переходах.
Получаем s, стрелочка .a, .b. Причем здесь опять же у нас есть Epsilon переход,
поэтому мы берем и притягиваем к себе ситуацию.
Дальше у нас получается здесь есть переход по B, который делает B точка,
а здесь у нас будет переход по B большой, из s выходит AB точка.
Да, то есть вместо того, чтобы пропускать те состояния, которые мы приходили по Epsilon переходу,
мы их наоборот притягиваем к себе. На самом деле притягивание к себе это тот же самый предикт.
Можно вопрос? Вот у нас вкрой прямоугольник.
А потому что мы пришли в это состояние, и потом из этого состояния по Epsilon переходу мы можем дойти сюда.
То есть мы притягиваем все достижимые по Epsilon.
То есть мы смотрим здесь уже для вот этого перехода, нам нужно дойти до этой ситуации,
для этого состояния, ну поэтому давайте притянем их к себе.
То есть по сути мы делаем предикты для всех возможных ситуаций в состоянии и добавляем его в текущее состояние.
Вот такой вот автомат. Давайте разберем слово AB.
Вот, тупик в автомате надо делать reduce, а какой делать бэктрек написано в правиле.
Давайте разберу слово AB наше. Пусть это у нас состояние 0, это состояние 1, это состояние 2, это состояние 3.
И на стеке мы будем хранить с вами путь вместо просто буквы KB, мы еще будем хранить путь в этом автомате.
Давайте начнем. Значит, смотрите, здесь обычно строят такую табличку,
в которой пишутся, какое слово осталось разобрать, какой у нас с вами стек и что мы делаем.
Итак, слово у нас изначально AB.
AB, давайте символ конца слова наберем.
Дальше у нас в стек изначально кладется нулевое состояние.
Смотрите, следующая буква A, поэтому что нам нужно сделать?
Нам нужно сделать переход в состояние 1.
При этом мы считаем, что мы эту букву прочитали с вами, а на стек кладем с вами вот такую вещь.
Букву A и переход. И смотрите, что такое 0, A1, это по сути путь в текущем автомате от стартовой вершины.
Дальше давайте, вот у нас стек 1, а следующая буква B, что мы должны сделать?
Перейти, видимо, в тройку.
Да, перейти в состояние тройку.
Получаем 0, A1, B3, то есть добавляем состояние B, переходим в тройку.
Дальше доллар, следующий символ доллар.
Мы пришли в тупике, в тупик в автомате, но что у нас в этом тупике интересного есть?
У нас на конце есть правило, правая часть правила.
Правая часть правила, смотрите, в тупике всегда написано правая часть правила.
Это мы еще с вами будем доказывать.
Но тогда мы видим, что есть правило B, стрелочка B, значит надо сделать редьюс.
Редьюс по правилам B, стрелочка B.
И теперь смотрите, в чем прикол состоит.
Мы зашли в тупик.
Слышали ли вы про алгоритм бэктрекинга?
То есть мы зашли с вами в тупик, нам что надо сделать?
Нам надо взять, развернуться.
И прежде чем смотреть, на стеке у нас хранится вот это вот B.
Мы берем, возвращаемся наверх.
По сути возвращение наверх, это значит, что мы с вами стираем со стека вот эту вот часть.
И идем в правильное направление, то есть идем по букве B.
В итоге у нас получается 0, 1, A, и B, а тут 2.
То есть мы перестроили с вами путь, мы пошли сюда, пришли сюда.
Дальше что делаем?
А, давайте я тут еще один переход забыл нарисовать, давайте переход по S сделаем.
Вот так вот. Это четвертое состояние.
Так, что мы с вами делаем?
Редюс.
Редьюс при этом до какого состояния мы откатываемся с вами?
Со стека, что мы с вами должны счистить при этом?
A, B?
Да, A, B счищается, а наверх кладется.
Что?
И?
Из 0 по S мы куда переходим?
В 4 состоянии.
Да, в 4 состоянии. То есть видите, мы делаем бэктрек и идем в правильном направлении.
И в итоге мы пришли в конец, потому что мы понимаем, что дальше надо свернуться по правилу S.
Как хотите, тут можно сказать, что мы сразу слово принимаем или не принимаем его сразу.
То есть видите, при помощи автомата на самом деле в стеке мы можем хранить не просто стек из текущих символов,
но еще и текущий путь в автомате, а в каждом автомате в принципе мы уже понимаем какие переходы, куда ходить.
Для каждого состояния, вообще для каждой буквы в детерминированном автомате мы можем просто написать действие, которое мы делаем.
Да, то есть пришли в состояние 3, независимо от того, какой следующий символ у нас будет, мы должны с вами сделать операцию reduce.
Если не получится?
Ну если не получится, значит слово не лежит в языке с даваемой грамматикой.
Все, сразу.
Так, отлично. А теперь смотрите, давайте добавим в эту грамматику правила 1.
Коварные.
Если вот это понятно, то 1.
Что это? 1?
Я что-то не понимаю.
Давайте добавим правило b, стрелочка bc.
Грамантики.
И тут вопрос состоит.
Вот автомат строится точно таким же образом, детерминируется, да, переход по букве b.
Вопрос, следующая буква c, что делать будем?
Двигаться на следующую букву?
Или откатываться по правилам b, стрелочка b.
Откатываться, мы же вроде так в самом начале сказали.
Да, отлично, если слово abc у нас.
То есть у нас проблема в том, что у нас может быть два правила, два слова ab и abc.
Для вот этого правила нам нужно сделать откат,
а для вот этого правила, в этой ситуации нам нужно двинуть, прочитать букву c.
То есть мы будем делать откат, мы не будем в тюрьму.
А вот это правило, мы будем делать откат,
нам нужно сделать откат, а для вот этого правила в этой ситуации нам нужно
прочитать букву С.
А, то есть, чего нам не хватает?
Я не очень понял, в чем вопрос. Ведь, если у нас было слово ABC, и мы пришли вот в красное состояние, то
мы в любом случае можем пройти, попробовать дальше. А если не получится, то мы откатом сможем все восстановить, нет?
Нет, но тут история в том, что откаты у нас удобны, если мы зашли в тупик, и мы знаем, по какому правилу уже откатываться.
А здесь у нас получается разветление алгоритма. То есть, там всегда, замечу, что в том алгоритме мы всегда, как только приходили в точку, у нас есть ровно одно правило.
А если мы заранее, тут история такая, либо мы начнем двигаться сразу, и тогда мы прочитаем что-то лишнее, либо мы сделаем откат.
То есть, у нас появляются две развилки, и на самом деле, количество таких развилок может быть экспоненциально большим.
Из-за этого сложность алгоритма уже будет нелинейной, к которой мы стремимся, а экспоненциальной.
Да, потому что у нас появилась развилка, а мы не хотим делать таких развилок.
Давайте подумаем, что мы не учили вот здесь вот, но что мы уже с вами проговорили при этом.
Нужно детерминировать?
Нет, ну, мы вроде бы детерминировали.
Ну, смотрите, у нас что получается. На самом деле, мы можем сделать if.
If следующая буква C, то, пожалуйста, ее прочти.
Значит, нам нужно сделать переход сюда.
Иначе сделай откат.
То есть, тут главная идея, что если мы в ситуацию зашьем, какая будет следующая буква, то мы сможем разрешить эту проблему.
Поэтому давайте сделаем следующую вещь.
Мы сделаем с вами вот, ведем понятие вот такой ситуации.
А, стрелочка, альфа точка бета, запятая C.
Причем, что эта C нам будет говорить?
Она нам будет говорить, что если мы находимся в состоянии альфа, который вводит альфа точка бета,
то следующий символ, который мы с вами можем вывести, это C.
Первая буква из того, что мы можем вывести дальше.
И тогда, смотрите, у нас вот эта ситуация на самом деле разобьется на две части.
Да, то есть, тут вот ситуация будет конец слова, а здесь ситуация будет немножечко другая.
Ну, давайте сейчас сделаем небольшой перерыв.
Минуток на 5.
А дальше посмотрим, как эту штуку можно конструировать на более продвинутом примере.
Если можно вопрос, если бы мы в красную блок добавили еще из B, следует B точка D,
то мы тогда могли прочитать и букву C, и букву D.
Ну да, там вообще непонятно было, там бы вообще бы развилка.
Либо свернись, либо у тебя буква D, значит ты идешь под букву D, либо у тебя буква C.
Мы для такой штуки две ситуации получается добавляем?
Да, на самом деле мы вот сейчас, давайте как раз после перерыва, перестроим автомат над этим множеством ситуаций
и поймем, что там происходит.
Итак, давайте продолжать, попытаемся разрешить проблему, которая у нас возникла здесь.
Значит, как мы сказали, нам нужно делать просмотр на одну букву вперед.
И на самом деле семейство алгоритмов LR, оно обычно говорится, что это семейство алгоритмов LRK,
где K это количество букв, которые мы будем с вами просматривать вперед.
На самом деле мы сейчас построили с вами алгоритм перенос свертка,
или в другой абстракции он называется LR0 алгоритм, потому что мы не используем информацию для просмотра на 0 букв вперед.
И давайте рассмотрим перенос на одну букву вперед.
И я сейчас немножко вам попытаюсь на примере сначала показать, как преобразуется вот эта вот грамматика.
И дальше мы перейдем с вами к формулировке, к формальным определениям, чтобы у нас с вами все это зафиксировано.
Итак, все начинается с следующего состояния.
Разблокируйся.
Вот с такого.
Значит, опять же, рассматриваем грамматику, мы с вами вот такую.
S-трих.s-s-a-b.
С b может вывести с либо b, либо bc.
Итак, смотрите, давайте поймем, какая буква может вывестись после того, как мы рассмотрели правила из-за штрих следует s.
Вот смотрите, точку ставим сюда.
Вопрос, какое слово может вывести справа после того, как мы рассмотрим правила грамматики s-стрелочка.s?
В смысле справа?
Ну, справа. То есть мы обойдем это дерево разбора, под дерево разбора, и дальше нам надо понять, какое символ мы можем вывести.
Первый пост токов мы обойдем от дерева разбора.
Чтобы посмотреть вперед, а что будет, когда мы вот эту историю пройдем?
C?
Нет.
Нет, мы по сути находимся в корне дерева разбора.
То есть если мы разберем все слово целиком, то что справа останется?
Эпсилон?
Эпсилон, да.
Но смотрите, для того, чтобы у нас все было однозначно и действительно был просмотр на одну букву вперед, давайте каждому слову, которое мы разбираем, добавляем символ конца слова.
То есть у нас слова будут не a-b, а будет слово a-b-dollar.
Не a-b-c, а a-b-c-dollar.
И тогда, по сути, следующий символ, который мы выводим после всего дерева разбора, это будет символ доллара.
То есть мы добавляем с вами ситуацию из штрих-стрелочка-точка-s, запятая доллар, означая, что после того, как мы проведем разбор в этом дереве разбора, следующий символ, который мы можем вывести, это будет доллар.
Ну, точка s, а не s-точка.
Ну, потому что мы начинаем, мы только начинаем дерево разбора проводить. То есть мы с левой части пока находимся.
Потом делаем операцию predict, то есть спусков дерева вниз.
Делаем s-стрелочка-точка-a-b, запятая, а здесь нам нужно понять, какой символ дальше выводится.
Давайте посмотрим. Внимательно, значит, у нас s выводит a-b.
И давайте поймем, какой первый символ у нас выводится после s.
После строк мы разберем это под дерево.
В смысле, после того, как мы сделаем complete из s?
Да, да, да.
При этом, что мы знаем, что у нас есть s-стрих-точка-s, запятая доллар.
То есть первое символ, который мы выводим из родителя, это доллар после родителя.
Доллар получается, нет?
Ну, тоже доллар, конечно же.
То есть, смотрите, если бы здесь был бы какой-нибудь вот тонкий момент,
если бы мы с вами немножко поменяли бы грамматику,
и у нас была бы грамматика такая, из s-стрих-sd и из s-a-b,
тогда давайте из этой ситуации поймем, если бы у нас здесь было бы s-стрих-точка-s-доллар,
то s-стрелочка-a-b здесь бы что стояло?
Вместо доллара?
D.
D, да, здесь бы стояла буква D.
И пересматриваем все возможные варианты, какая первая буква могла быть у нас выведена.
Ну, это такой офф-топик у нас с вами.
Если бы еще был из s-стрих-s, например, c, то мы бы еще одно что-то добавили.
Да, да, да, да.
Начинаем лавливать суть.
Дальше мы делаем переход по букве a.
Мы получаем с вами s-стрелочка-a-точка-b, запятая доллар, да.
И дальше мы спускаемся вниз, получаем b-стрелочка-точка-b,
запятая доллар, потому что, ну, по сути, смотрим, что мы можем вывести после b,
но после b мы можем вывести только то, что было после того, как мы поднимаемся, то есть доллар.
То есть доллар дублируется, если бы у нас справа ничего нет.
И здесь у нас получается с вами переход из b в точка b-c, запятая доллар.
А теперь важная ситуация.
Если мы проходим по b, то у нас получается b-стрелочка-b-точка, запятая доллар,
а здесь b-стрелочка-b-точка-c, запятая доллар.
И дальше мы можем сделать где-то здесь переход по c,
получаем мы с вами b-стрелочка-b-c, точка запятая доллар.
А теперь давайте решать, что мы делаем после сталка, попадаем в эту ситуацию
вот здесь.
Есть ли гипотезы?
Мы смотрим, у нас тут еще символ, и дальше уже принимаем действия какие-то.
Да, смотрите, если следующий символ c, то мы не можем свернуться по вот этому правилу.
Если next равен c, то мы не можем сделать reduce.
Но почему? Потому что если бы мы сделали reduce, мы должны бы гарантировать,
что следующий символ у нас прямо сразу появится.
А у нас следующий символ это доллар, конец слова.
Поэтому мы должны перейти по букве c.
Если бы здесь не было переход по букве c, допустим, если бы next равно a,
то мы бы сказали, что слово не лежит в языке, в грамматике,
потому что мы не можем ни свернуться, ни перейти подальше.
А если next доллар, то мы делаем reduce.
Да, потому что двинуться мы никуда не можем, а вернуться обратно мы можем с вами.
Потому что мы говорим следующий символ доллар, мы можем свернуться.
Понятно, как разрешать конфликт, если мы добавляем переход на следующий символ?
Можете еще раз повторить? У нас после запятой пишутся какие-то символы.
Как мы понимаем, что писать?
Я сейчас дам формальное определение, мы с вами это как раз посмотрим.
Просто там сложно, там нужно еще научиться понимать, что мы можем написать первые буквы.
Это хороший вопрос.
А вопрос, какая проблема может внезапно гиптически возникнуть?
Если бы, допустим, здесь у нас вместо B стрелочка B.$ появился бы запятая C,
и здесь есть переход по C, то что надо сделать?
Посмотреть на вторую букву?
Да, либо посмотреть на вторую букву вперед, либо в классической теории применимости этой штуки делается следующее.
Говорится, ребята, сидите и думайте, какую грамматику вы можете построить вместо текущей.
Потому что это все-таки практическое применение и парсинг текста.
А когда мы парсим текст, мы задаем свою грамматику обычно.
Значит, модифицирую грамматику.
Вот, вот это важно.
Значит, смотрите, теперь, если с этим примером понятно,
да, давайте поговорим над формальными определениями.
Я, как обычно, это, забыл угловые скобки.
Значит, смотрите, для того, чтобы формально определить, какую мы следующую букву пишем, введем множество first.
First от альфа.
Это у нас с вами множество всех таких буквок,
что альфа, из альфа мы можем вывести ау, где у некоторое слово.
Да, плюс добавляем сюда доллар, если альфа-эпсилон порождающий.
То есть из альфа мы можем вывести, ну, мы ничего не можем вывести.
Следующий символ, который мы можем вывести после альфы, это конец слова.
Да, и тогда мы можем определить LR ситуацию, LR1 ситуацию,
как а, стрелочка, альфа.б, а, запятая а, где а принадлежит сигма объединить с долларом,
и а, альфа, бета, это у нас правила грамматики.
То есть у нас с вами получается, что а, альфа.б, а, это LR1 ситуация.
Контрольный вопрос, как мы будем писать с вами LR0 ситуацию?
Вместо а, эпсилон?
Ну, можем вообще не писать, можем просто эпсилон написать, да?
Эпсилон или а, стрелочка, альфа.б.
Хорошо. Теперь еще одно определение, которое нам важно, активный префикс.
Нам нужно теперь перевести вот это неформальное определение работы со стеком в вывод грамматики.
Напоминаю, что мы с вами строим правосторонний вывод в грамматики.
И давайте скажем, что у нас слово, альфа, принадлежащее n объединить сигма со звездой, это активный префикс.
Если выполнена следующая вещь.
Давайте я картинку нарисую.
Значит, из s штрих мы раскрываем эту штуку, как в альфа 1у.
И потом за один вывод в правостороннем правиле грамматики, правостороннем выводе мы берем и делаем следующее.
Раскрываем b1, b2.
И тогда у нас с вами альфа 1, бета 1 равная альфа будет активный префикс.
Давайте я, чтобы это было более понятно, я немножечко по-другому нарисую.
Немножко на другой высоте.
То есть смотрите, у нас было какое-то слово u, которое мы разобрали правосторонним выводом.
Потом у нас было какое-то a, которое мы раскрываем, вот здесь как бета 1, бета 2.
И здесь у нас уже тоже что-то потом будет разобрано, но это будет у нас какой-то не терминал альфа 1.
Поскольку вы в грамматике правосторонний, то прежде чем раскрывать не терминал а, нам нужно раскрыть все, что находится здесь.
Поэтому здесь написано чистое слово.
И если внимательно посмотреть, давайте попробуем посмотреть, что происходит, когда мы анализируем эту штуку алгоритмом.
Значит, берем и движемся.
Вот сюда, вот сюда, вот сюда.
Как только мы дойдем до слова альфа, не терминала а, на самом деле здесь мы уже с вами построим дерево вывода.
И на стеке у нас с вами будет лежать альфа 1.
А потом начнем разбирать следующие символы.
И бета 1 уже тоже будет лежать на том же самом стеке.
Напоминаю алгоритм сначала, когда мы закидывали слова на стек.
И почему этот префикс альфа 1, бета 1 называется активным?
Потому что он находится у нас на стеке.
Потом понятно, когда на стеке появится бета 2, мы сможем раскрыть это правило, заменить то, что лежит на стеке бета 1, бета 2 на а.
И тогда уже альфа 2 а.
Нет, альфа 2 а тоже будет активным префикс.
То есть вот такая вот картинка, это чисто формальное определение вообще того, что может лежать на стеке при разборе нашего слова.
Вот, то есть можете воспринимать неформальное определение.
Да, нам просто нужно будет, для того чтобы состаковать все практические формулировки, нам нужно это будет смысл вами посмотреть.
Можете еще раз повторить смысл?
А смысл, значит альфа 1, бета 1 это то, что может лежать на стеке во время алгоритма переноса свертки.
Ну вот и все.
Вот, теперь смотрите.
Так, сейчас, значит смотрите дальше, что мы делаем.
Давайте теперь определим допустимую ситуацию для активного префикса.
Для альфа 1, бета 1.
Смотрите, что происходит.
Это как раз то, что нам вводит с вами смысл определения.
Смотрите, значит s'.
Дальше мы выводим с вами некоторую альфа ау.
А дальше мы за один раз выводим с вами бета 1, бета 2.
Ставим твку сюда.
Тогда у нас альфа б1 по определению является активным префиксом.
Да.
А при этом у нас получается эта ситуация, которая из a, бета 1.
А бета 2, бета u, бета a.
Она будет допустима.
Давайте вот так напишу.
Такая ситуация.
Почему она допустима?
Потому что a принадлежит first at u.
То есть иначе говоря,
почему ситуация называется допустимой?
Потому что у нас первый символ, который мы можем вывести справа
после того, как мы раскроем это под дерево.
Вот он.
Давайте переформулирую.
То, что мы пишем, что у нас следующая буква,
которая может быть деревью разбора, это буква a.
Вот и все.
Как бы говорим вот такую вот вещь.
Давайте, если что, задавайте вопрос.
Потому что я, может быть, сейчас коряво это все определил.
Ну а смысл ровно такой, что ситуация называется допустимой,
если следующий символ, который может идти,
действительно будет являться первым.
А можно просто мы это определяем по нашей грамматике?
Ну да, по грамматике смотрим.
Хорошо.
Так, теперь дальше давайте.
Сейчас такая трудная формалистическая вещь,
которую нам нужно с вами сделать.
Я потом и с вами это.
Следующая.
Значит, нам нужно с вами теперь определить замыкание.
Идея такая.
Давайте у нас есть какое-то i множество ситуаций.
И мы с вами говорим следующее, что пусть кложе от множества i,
это некоторое множество g.
Такое, что i является под множеством g,
то есть это наименьшее множество, содержащее g.
Такое, что...
Теперь давайте я это на картинке нарисую, чтобы было понятно.
Значит, у нас с вами есть ситуация A,
выводящая α1, бета, а2.
И дальше следующий символ, который мы можем вывести, это символ A.
Давайте я следующий символ буду писать так,
что первый символ, который мы можем вывести здесь, это A.
Потом мы сможем с вами вывести бета,
выводим гамма.
Да, точку мы с вами спускаем.
Так.
Тогда первый символ, который мы можем вывести уже отсюда, вот отсюда,
это будет символ first...
А, first маленькими буквами прозначал.
First от альфа до альфа до альфа.
First от альфа2а.
Да, потому что что мы можем сделать здесь?
Мы здесь либо выводим альфа2, первый символ, если он не эпсилон порождающий,
вытягиваем его сюда.
Если он внезапно эпсилон порождающий, то мы еще и смотрим букву А.
Да, то есть у нас получается с вами бета,
стрелочка, гамма, точка,
C, где C лежит first от альфа2а.
Можно вопрос?
Да, давай.
На слайде слева, там нижняя строчка принадлежит G.
Да.
Не принадлежит G.
Потому что замыкание может быть множественное.
Мы сделали замыкание один раз,
по сути сделали предикт один раз,
потом сделали предикт второй раз,
потом предикт третий раз и так далее.
Эта цепочка идет такая.
По сути, это операция предикт.
Мы с вами еще докажем одну лему,
которая нам нужно будет с вами сделать,
но давайте успеем, успеем, не успеем, не успеем.
И последнее определение, которое нам понадобится,
это операция go2.
По символу лямбона это у нас с вами следующее.
Это будет у нас с вами замыкание
следующего множества.
Так, перенесу его.
По сути, это сдвиг точки.
Сдвиг точки.
А, стрелочка, альфа, один, бета, точка, альфа, два.
Так, стоп.
Багу нашел.
Надо вычитывать лекции.
Лямбда вот тут стоит.
То есть мы сдвигаем лямбду А
при условии того, что А, стрелочка, альфа, один, точка, лямбда,
А, два, А принадлежит множеству ситуаций И.
То есть что мы делаем с вами?
Мы делаем сдвиг точки
и это.
И делаем замыкание.
Хорошо, скажите мне, пожалуйста,
для осознания ситуации.
Скажите, пожалуйста, что такое операция go2
и что такое операция claw?
В тех терминах, которые мы с вами уже показывали.
В терминах картинок.
Да, да, я исправлю баги в презентации.
Давайте начнем с понимания того, что делает операция claw.
Давайте начнем с понимания того, что делает операция claw,
что кодирует операция claw
в наших предыдущих терминах,
которые мы занимали с первой половиной занятий в седешних.
Это не просто множество переходов?
Ну, это множество переходов.
По сути, это то, что мы с вами делали это.
Эпсилон замыкания делали.
Да, вот когда мы взяли...
Сейчас покажу, пытаюсь.
Вот у нас...
Где там был автомат?
Вот у нас был автомат, да.
Вот мы сделали эпсилон-переход.
И что такое замыкание?
Мы просто взяли вот эти два множества, объединили в одно.
Понятно ли это?
Это просто фундаментально важная вещь,
которую нам надо все-таки понять.
Не очень понятно, как это с формальным определением согласуется.
Давайте посмотрим как раз.
Вот, клоши А3, да.
То есть что такое замыкание от вот этой ситуации?
Точнее давайте от ситуации...
Какой у нас был?
От ситуации из S'.
Клоше от ситуации...
Там S'.
Стрелочка, точка S,
доллар.
Да.
Это множество ситуаций таких,
что если у нас
с вами есть...
Начнем с первой штуки.
У нас есть правило
S'.
точка S, да.
При этом первый символ, который мы с вами раскрываем здесь,
является доллар.
Да.
Дальше у нас правила какие были?
У нас было правило SAB.
Дорисовываем с вами правило AB.
Прокидываем сюда точку.
И смотрим, что у нас выводится здесь.
В нашем случае α2 это пустое слово.
Смотрим, что выводится первым символом
first
под epsilon$.
Ну, это доллар будет.
Точнее first от epsilon.
Вот так вот.
А, нет, давайте first от epsilon$.
Это доллар. Вот.
То есть у нас получается, что
из S'
точка S, да,
из S'
точка AB,
есть AB правила,
то мы в это замыкание должны добавить ситуацию.
Во-первых, оно текущее,
потому что оно есть.
И дополнительно мы добавляем
ситуацию S'
точка AB, запятая доллар.
Стало понятнее?
То есть я просто те слова, которые
проговаривал, именно
еще раз это.
То есть мы здесь делаем одно раскрытие,
а потом смотрим, какие
дальше будут
прочитанные буквы, возможно.
Да, да, да. Вот у нас тут просто
как раз вот вопрос, который
как раз задавал.
Он заключался в том, а как мы понимаем,
какие первые буквы мы дописываем, да?
Вот как раз first от alpha2A,
которая вот здесь, то есть
вот как раз first от alpha2A,
которая вот здесь написана. Мы понимаем,
какие буквы могут быть здесь написаны.
Это как раз возвращаться
к тому вопросу, который уже задавался,
на который я говорю, что
я отвечу.
Так, хорошо.
А скажите тогда, если
прокло уже понятно, что делает
операция go2?
В терминах автоматов.
Чему
равняем?
Давайте вот на примерах,
чтобы было понятно, что такое
go2 от
вот этого множества
i,
и штрих, который мы с вами обозначили.
И что такое
go2
от
вот этого множества
i, и штрих, который мы с вами
обозначили.
Множество
i, штрих, и по букве
мы делаем его по букве
по букве
a маленькая.
Смотрите,
что мы делаем. Мы делаем перенос
буквы a.
Это, по сути, будет
замыкание.
Состояние s штрих
стрелочка a, точка b
dollar.
То есть мы сделаем
сдвиг и делаем замыкание.
Да?
Мы теперь смотрим внимательно,
товарищи.
Делаем
сдвиг по букве a, делаем
замыкание.
То есть это переход
в нашем автомате.
Давайте я это
как раз и напишу.
А почему у нас точка переместилась вправо?
Она же только влево перемещается, нет?
Нет, вправо.
Делаем сдвиг, мы читаем буквы a.
Да, тут понятно,
но в go2 непонятно почему.
Ну вот, мы же казали, что
go2 это замыкание от такого ситуации,
где ситуация изначально была такая.
Да, то есть мы точку,
то что было справа, точка слева,
точка слева от лямб дострела, мы двигаемся сюда.
Ага, тут понятно.
Вот, то есть смотрите,
давайте как раз
финализируем. Это go2,
это переход в ДК.
А closure, это
давайте напишу
удаление эпсилон переходов.
Отлично.
Можно вопрос,
а если у нас
go2 вызывается не
от вершины
НК, а например
от нескольких вершин?
Ну,
тогда нужно
взять все ситуации и по сути
от них детерминизировать.
То есть как в обычном ДК
делается, но ровно так же тут и делает.
Ровно такая же операция будет и тут.
А если мы возьмем две различные вершины
ДК, то это будет не переход
в ДК, а
множественный переход?
Да, множественный переход.
Ну, как множество дельта от множества ситуаций
мы определяли это там
в самом начале лекций.
Это пример
грамматики, который я тут готовил, но
мы с вами пример уже посмотрели.
Можете на досуге, кстати, посмотреть пример
Вот этот вот. Нарисовать ним автомат.
Нарисовать примеры go2 и переход.
Итак, смотрите.
Первые леммы. До них мы сегодня не дошли.
Но они достаточно
важны. Может быть одну докажем.
Значит, смотрите. Если множество
ситуаций являются
допустимым,
то его замыкание тоже является
допустимым.
Что это нам позволит?
Это нам позволит на самом деле
избавиться. Вот эта лемма
позволяет избавиться от эпсилон переходов.
Да, формально показать,
почему мы можем избавиться от эпсилон
переходов.
Вторая лемма заключается в следующем.
Что мы
по сути с вами говорим,
что допустимые ситуации,
в допустимых ситуациях можно построить
этот.
Детерминированный автомат.
То есть мы говорим
сейчас,
что мы с вами будем строить
не какое-то
ДКА над множеством ситуаций,
а будем строить ДКА
для допустимых ситуаций, которые являются
корректными в нашем случае.
И вот эта теорема
показывает корректность
построения ДКА.
И давайте вопрос такой.
Что показывает
лемма 2?
Что
замыкание вот этого ситуации
это множество допустимых ситуаций
для слова эпсилон.
Множество конечных состояний
в нашем автомате?
Нет, не конечных только.
Вот эта вот ситуация
у нас где находится?
В нашем автомате.
Стартовая?
Да, стартовая.
То есть что стартовая ситуация
согласуется с тем, что мы
по сути рассмотрели
все ситуации,
в которых мы
говорим, что начало пустое.
То есть мы строим множество ситуаций,
в которых
точка стоит в начале слова.
А дальше мы показываем корректность
всех переходов построения ДКА.
То есть таким образом
вот эти леммы нам позволят показать,
что ДКА, который мы строим,
корректно сформирована
с точки зрения
того, что мы выше говорили.
Я думаю, на сегодня
можно закончить. Давайте задавайте вопросы.
Мне кажется, мы сегодня
продуктивно поговорили. В следующий раз
мы с вами уже будем формально сидеть
и доказывать эти леммы все.
И еще там
посмотрим
один аспект,
который нам тоже нужен будет.
То есть у нас есть
еще один аспект, который
нам тоже нужен будет.
На, баги я пришлю, постараюсь презентацию прислать.
Можете теперь им один еще раз пояснить?
Сейчас поясню.
Она заключается в следующем,
что у нас есть
один аспект,
который нам тоже нужен будет.
Сейчас поясню.
Она заключается в следующем,
что у нас есть
сейчас
покажу.
То есть у нас есть состояние
стартовая ку-ноль.
Вот это вот.
В котором лежит s' .s
за 5$.
Лемма 2
что говорит?
Говорит, что это соответствует
активному префиксу
epsilon.
То есть все ситуации
со стеком apps.
С пустым стеком.
Понятно, что мы когда еще будем
в классическом магарите
перенос свертки, то что этот стек у нас
пустой.
Потом мы говорим, окей, давайте посмотрим
какие-то переходы.
У нас, допустим, тут переход по букве
x был.
Тогда это у нас будет
все ситуации
с активным префиксом
к активным префиксам x.
То есть все ситуации со стеком x.
То есть на самом деле
если классически говорить
да, давайте опять же к нашему примеру
вернемся.
То есть здесь мы
в нашем примере можем сказать, что
здесь у нас будут находиться
все ситуации
если мы
здесь находятся все ситуации
у которых на стеке будет лежать
app.
То есть у нас будут находиться
все ситуации
у которых на стеке будет лежать
ab.
То есть если мы попали в эту ситуацию
то на стеке у нас действительно лежит ab
и поэтому
если у нас следующий символ конец слова
то действительно мы можем свернуться
по символу b
и да, действительно
то что у нас b.
справа в конце находятся.
То есть это поясняет корректность того
что мы можем сделать здесь reduce
операцию.
Понятно?
Хорошо, но мы еще на семинарах это будем
обсуждать все.
Ну и в следующий раз тоже
продолжим это доказывать.
Морально настраивайтесь, что
будет формально и будет
неприятно.
Но все-таки это нам надо будет сделать.
Все тогда всем спасибо, всем не болейте
всем хорошего дня.
