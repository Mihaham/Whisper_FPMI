Какую задачу мы сейчас будем решать?
Ну, будем решать поискать в тексте t много подстрок
сразу.
То есть не одну.
Ну, простая нот, но какая-нибудь простая версия, могла бы
работать, конечно, за сумму длин строк, плюс текст
умножить на их количество, соответственно.
Ну, просто условно говоря, для каждой из них найдем
префикс функции, или z, чего угодно.
Но, на самом деле, нот, прежде чем запускать какого-то
полномасштабного ахакарасика, нужно, конечно, сделать пару
оговорочек.
Каких?
Ну, первое, например, предположим, что все строки у нас имеют
одинаковую длину.
Вот совершенно случайно.
Тогда у нас есть неожиданный лайфхак.
Лайфхак называется, давайте посчитаем, ну, разные методы
могут быть.
Ну, например, можно предподсчитать хэши всех подстрок длины
и лен и сложить их в какой-нибудь там мульти-сет.
И тогда для каждой подстроки мы лезем в мульти-сет, проверяем,
есть ли такие хэши, если да, то где.
Ну, в принципе, логарифом можно даже убить, если мульти-сет
вы замерите на анортерет-сет.
Ну, тупо от него отказываться, если мы все равно понятия
хэши используем.
Ну, пока здесь все просто.
Пока у нас получается, что у нас получается, ОАТ,
плюс СЛОГТ, плюс размер ответа, хотя, нет, это неправда.
Почему неправда, потому что, наверное, все-таки хэши
мы кладем в мульти-сет, все-таки за логариф.
Ну, не суть, суть, в общем-то, одна.
Да, но если использовать хэш-таблицу, то как бы можно
вообще прям идеально за линию все делать, это прям вот
оптимально.
Но возникает маленькая проблема, строки бывают,
к сожалению, разной длины.
Что в этом случае делать?
Ну, тут тоже, на самом деле, возникает такой неожиданный,
но такой классический момент, что часто, когда нам дают
как много строчек, выясняется, что их суммарная длина,
наверное, не очень большая какая-то.
Ну, как-то классика бывает, там нам дают 10 в пятый строчек,
суммарная длина не происходит, там 3 на 10 в пятый, например,
или там 2 на 10 в пятый.
Вот.
Но тут тогда выясняется следующее, оказывается,
что среди этих строчек принципиально различных длин, в общем-то,
не сильно много.
А именно, вот, например, можно так вот написать, не более
чем корень их суммарной длины умножить на 2.
И это оценка я еще не точно написал, это я так для красоты.
На самом деле можно даже более точную оценку написать,
это двойку занести под корень.
Да, корень из двух длин, да.
Вот.
Ну, доказательства, так, ну, по-моему, вот, что-то подобное
мы уже даже обсуждали когда-то, да.
Ну, то есть доказательства базируются на том, что если
у нас, например, там L различных длин, то тогда, то есть,
строчки включаются строчки хотя бы L различных длин,
то есть суммарная длина как минимум 1 плюс 2 плюс и так далее плюс L.
Вот.
Это не превосходит вот суммарной длины, ну, а сумма
этой получается L на L плюс 1 пополам, следовательно, L меньше
чем корень из двух суммарных длин, ну, тут, в общем, все
понятно, думаю, расписывать не надо, да.
Вот.
Тут все понятно.
Вот.
И в результате может получиться уже не самая плохая симпатика.
То есть, идея такая, давайте что-нибудь разделим.
То есть, давайте вот просто тупо возьмем и разделим
действительно у нас, соответственно, строки на...
А, все, можно о хакарасике дальше не рассказывать, да?
Нет, можно другое теперь рассказывать.
Да, все так, убираем это все безобразие.
Но поздно, уже начали, да.
Ладно.
Как говорится, надо же разомнуться на чем-то, почему
мне на хакарасике, да.
Ну, вот.
Но, действительно, тут идея, что получается, уже без
хакарасика можно получить асимптотику вида там n корень
из n.
Ну, что-то в этом роде.
То есть, суммарная длина всех строчек на корень из
суммарной длины там всех s.
Уже, в принципе, неплохо.
Вот.
В чем более того, можно обратить внимание.
Тут мы пишем как корень, но с другой стороны, там,
знаете, вот, например, бывают еще там всякие задачи,
что нужно там просят описать вроде хакарасика, но говорят,
что длины всех этих строчек не превосходят, например,
80.
И тогда, в принципе, это означает, что вы можете
решать задачу за 80 на, соответственно, суммарную длину.
И это, в общем-то, тоже неплохо.
Вот.
То есть, иногда совсем сложных алгоритмов писать не надо.
Вот это вот там.
Да.
Ну, конечно, да, у нас будут алгоритмы и посложнее.
Но нет, ну, как бы, традиционно почему-то хакарасик считается
сложным алгоритмом.
Хотя, с другой стороны, давайте проведем эксперимент.
Да, тут, конечно, уже не самая репрезентативная выборка,
но все-таки.
Ну-ка, кто когда-нибудь писал хакарасик?
Вот.
Ну, вот проблема, да.
Нет, ну, тут парадокс, потому что, по логике, хакарасик
должен быть до суфмассива даже.
Ну вот.
В идеале вроде да, потому что вроде повышаем уровень.
То есть, одну подстроку в одной строке, много подстрок статическим
образом в одной строке или много подстрок в одной строке,
но в онлайне.
Да?
То есть, казалось бы, вот все постепенно так должно расти.
Но просто традиционно оказывается, но просто практически оказывается,
что алгоритм хакарасик оказывается сложнее для понимания,
чем даже алгоритм поиска суфмассива, а Zn log n, который...
Вот.
А кто суфмассив Zn log n когда-нибудь писал?
Вот.
Да, в два раза больше людей.
Да.
Вот, да.
Ну, вот, логично.
Да.
В чем дело?
Там, оказывается, просто.
А если еще вспомнить, что там кто-то прям так и рассказывает,
как его строить, то давайте это Zn log квадрат.
Хешами и бинпоискам.
Просто вот STD-сорт забабахаем, и вот.
Тоже, в принципе, варианты, если ограничения позволяют, конечно.
Вот.
Но, правда, удачи попихать.
Вот.
Поэтому, да.
Поэтому часто алгоритм хакарасик даже опускают.
Ну, там много чего так опускают.
Вот.
И в результате получается, что там куки хорошего не знаем.
Ну, вот.
Но мы его пропускать не будем.
То есть у нас, конечно, все-таки цель, какая у нас цель?
Найти все вхождения всех под строчек S в текст T.
За асимптотику какую?
Суммарная длина всех строчек S плюс длина строки T
плюс суммарный размер ответа.
Вот.
Почему это важно?
Ну, потому что, как мы помним, да, что, может быть,
каждая строчка входит в текст T там от T раз.
Нам же не суммарный размер ответа, видимо.
Ну, в плане количества, а не суммарный.
Нет.
Ну, в нашей постановке задачи мы хотим найти все вхождения.
Да.
То есть у нас будет такая.
Поэтому без суммарного размера ответа не получится.
Да.
Понятно, имеется в виду, что каждое вхождение мы будем
кодировать, конечно, информации в духе, там, какая строчка,
где начинается ее вхождение, естественно.
Да, вот, единицы.
Да.
Вот.
То есть, конечно же, там могут быть более какие-то
постановки задачи, что для каждой строчки посчитаем,
входит ли она вообще просто, да или нет, сколько раз
она входит, где там находится ее там 57-й вхождение,
или что-нибудь еще в этом роде.
Вот.
Нет, 57-й вхождение, это, конечно, сложнее будет.
Вот.
Но не суть.
Итак.
Значит, ну, соответственно, чтобы это делать, то есть
там уже, конечно, не требуется размер ответа, то есть
тогда уже будет там честная линия.
Итак.
Но как же это делать?
Ну, для этого нам нужен борт.
То есть там нужна структура данных.
То есть это такая структура данных, которая позволяет
вам добавлять строку в множество, удалить строку
из множества и проверить, присутствует ли строка
С в множестве.
Что вы понимаете под чистой линией?
У вас же размер ответа никогда не превышает суммарную
длину С.
Нет.
Я имел в виду, что если постановка задачи требует
просто для каждой строки сказать, сколько раз она
входит в текст Т, то как бы уже размер ответа у вас
адекватный.
То есть тебе не требуется прям все вхождение выписывать,
а надо только сказать…
Нет, если выписывать индексы, то это все еще уже суммарная
длина.
Умножить на Т.
Почему?
Только у тебя Т – это все буквы А.
И что?
А каждая С – это одна.
Это входит в суммарную длину строк.
Нет.
В плане, у нас с каждого символа строка Т может начинаться
ровно одним способом.
Либо входить с него, либо не входить с него.
Ну и что?
Значит ответ не больше, чем суммарную длину.
Нет, это означает, что каждая строка входит в текст
Т не более, чем модуль Т раз.
Но проблема в том, что строчек у тебя больше, чем одна.
Так, сейчас.
Вы много строк ищем?
Много строк ищем в одной?
Да.
А, я говорю про одно строк ищем в одной.
О, так, вот просыпаемся.
Мы уже решали эту задачу в прошлый раз.
Это другая задача.
У нас много строчек, мы вон Бор даже вводим зачем-то.
А именно потому, что мы ищем много строчек.
Вот.
Итак, ну что ж такое Бор?
Ну да, редкий случай, когда тут это…
Можно ввести формальное определение, но как-то
очень не хочется.
Не вот.
Ну, тем более, что, собственно, я думаю, как мы уже выясняли,
там многие из вас так знают, что это.
Ну, то есть формальное…
То есть, можно сказать, что это такое подвешенное дерево.
На каждом ребре написана буква.
Там на ребрах и сходящих из вершины все буквы парно различные.
Ну, то есть, можно сказать, что это такой автомат, но
древесного типа.
Вот.
Ну, вот, что уж тут.
Как говорится, вместо тысячи слов.
В общем-то, я думаю, эта картинка как раз дает полное
понимание.
Вот.
Ну, дальше там…
Ну, понятно.
Можно делать там такое.
То есть, в каждой вершине еще можно насчитывать,
сколько слов начинается с такого префекса, например.
Искать какую-нибудь там катую.
Можно еще там искать катую или в психографическом
порядке строчку и так далее и тому подобное.
Ну, и здесь вот и прочая классика такого рода.
Вот.
Ну, здесь, конечно, да, нужно говорить, конечно, два…
Чего?
Мапы.
А что не так?
Ну, я люблю писать с мапом.
Ну, это-то, да, конечно, да.
А что?
Вот.
Нет, ну, в принципе, логично.
На самом деле, если алфавит большой, то на самом деле…
То есть, если алфавит хотя бы 26, то у вас там Бор может
вызвать там проблемы с памяти.
Нет, алфавит больше, чем 26.
Сколько может?
Ну, 50.
Ну, бывает 52.
Бывает там…
Ну, бывает на сотку.
Там все что угодно.
Ну, по-разному бывает.
То есть, там как бы всякое такое.
Просто проблема в том, что, да, то есть, у вас там по
памяти это будет 26 на суммарную длину строчек.
Иногда, если у вас суммарная длина строчек все-таки там
пара миллионов, то там с памятью могут быть проблемы.
Ну, найти задачу, в которой суммарная длина строчек,
миллион и алфавит длины 100 – это все-таки задача,
где нужно прямо… Ну, типа это специальная задача
на упих.
Ну, бывает.
Ну, вся…
Ну, всегда бывает.
Как показывает практика прошлого четверть финала,
задачу на упих по памяти вам подсунуть могут.
То есть, как выясняется, да, оказывается, алгоритм
Хишберга нужен.
Оказывается.
Ну, да, ну вот, да.
Ну, ну, что делать?
Да, кто-то может, конечно, вызапить от этого, но в
конце концов, да, если вы случайно прогуляли соответствующую
лекцию на первом курсе, то это ваши проблемы.
Ну, вот, ну, или там соответственно.
Ну, тем более, что, в общем, это не тот алгоритм, который
прям вообще нигде никто никогда не рассказывает
и не упоминает.
Все-таки да.
Так вот.
Ну, в нашем случае, значит, да, то есть, по памяти
по-разному бывает.
То есть, и, конечно, чаще всего, чаще, конечно, используют
действительно массив детей.
Ну, там вёрток-звёздочка или там, может быть, если
вы храните все вершины в массиве, то там инты можно
писать.
Вот.
Но если вы хотите, чтоб память у вас была не O от M умножить
на размер алфавита, а именно O от N, то вас приветствует
мапчик.
Вот.
Вот.
Ну, при желании там, если не хотите, чтоб был алгоритм
размер алфавита, то, конечно, можно и хэш-мапчик.
Но, по-моему, в данном случае, по-моему, ни по времени,
ни по памяти он, скорее всего, вам погоды не сделает.
Ну вот.
По памяти это не будет алгоритм размер алфавита?
По памяти...
Как это у него?
Киганск.
Когда он маленького...
Кого?
Он говорит, МАП типа работает одинаково по времени почти.
Ну, нет, ну, на мелких, думаю, скорее, да.
На мелких мапчика?
На крупных?
Ну, на крупных, ну, там, да.
Ну ладно.
На мелких не знаю, но на крупных, типа, ну, там, может,
два раза разница.
Ну...
Нет, ну, иногда бывает.
Ну, формально.
Ну, формально говорим.
Но тут говорим так.
На самом деле, мы здесь не хотим использовать unordered
map по одной простой причине.
Мы ставим себе целью решить нашу задачу без всяких
этих хэшей и предположений, что у нас там есть какие-то
коллизии.
Вот.
Или там, вероятности.
Ну, там.
Ну, как всегда, коллизии у нас как.
Либо мы верим, что коллизии нет, а если есть, то, ну
ладно, в этом маловероятном случае мы скажем, что ладно,
нам не повезло.
А можно строить хэш-мапу.
Там, типа, unordered-мапа таким образом, чтобы, там, если
есть коллизия, значит, перестраиваем хэш-мапу.
Вот.
Ну, в принципе, так можно.
Ну, вот.
То есть, ну, просто разные подходы.
Ну, вот.
Ну, они...
Ну, тогда там просто...
Тогда проблема в том, что он теоретически может
по времени долго работать.
Да.
Ну, это уже другой вопрос.
Да, там.
Ну, проблема в том, что...
Даже не столько проблема, что он там дольше, не дольше,
а проблема еще в том, что он может долго работать,
потому что вам не повезло.
Вот.
Ну, понятно, что вероятность, конечно, там крайне мала
и все такое, но...
Ну, если мы хотим перестраивать, если есть хотя бы одна коллизия,
типа, нам нужен квадрат от размера ввода,
и у нас столько времени будет.
Ну, возможно.
Ну, пожалуй, да.
Вот.
Да.
Ну, мы в любом случае хотим таких хэшей избегать,
хотим все надежно, поэтому пишем мап.
Вот.
Ну, мап, конечно, будет проблема, что у вас все операции
с каждой строкой будут работать не за отдлинные строки,
а отдлинные строки на логарифам алфавита,
но логарифам 26 обычно не проблема.
Но, правда, если алфавит у вас большой,
потому что, знаете, вот, до первых парадоксис,
с одной стороны, все наслышаны, что суффиксный массив строится
за линию теоретически, да?
Более того, есть много алгоритмов, которые строят.
Ну, он же за линию алфавита либо за логарифом.
Ну, вот.
Ну, на самом деле, да.
Ну, хотя...
Ну, не совсем так.
Ну, хотя...
А, ну, вот.
Нет, он не за n алфавит.
Не, ну, как это наш алгоритм, он честно n логан,
который мы будем изучать.
Но, на самом деле, там есть алгоритмы, которые будут честно строить за o от n,
но только с оговоркой, что все элементы алфавита – это числа от 1 до n.
Ну, или от 0 до n-1.
Вот.
Потому что, да, если нам в качестве алфавита подсовывают камешки
со сравнениями, то быстрее, чем за n логан,
вы не можете построить суффиксный массив принципиально.
Ну, вот.
Потому что в противном случае, если вы можете
принципиально быстрее построить, тогда у вас появляется
suffix array sort.
То есть как бы, да.
То есть как отсортировать n камешков?
Правильно. Давайте построим суффиксный массив.
Вот вам сортировка. Ура. Да.
Вот.
Вот.
Поэтому тут, конечно, важно иметь в виду
такого рода оговорки.
Вот.
Так что вот, то есть, на самом деле,
по-разному, дальше как всегда.
Тут trade-off именно пожертвовать чуть-чуть временем
или пожертвовать чуть-чуть памятью.
Ну, все зависит, конечно, от размера алфавита.
Потому что там бывают задачи, в которых алфавит – 26,
бывают задачи, в которых алфавит – 10,
бывают задачи, в которых алфавит – 2.
То есть там при двух, ну, уж понятно, что мапчик бессмысленен.
Да.
Так что тут, ну, как бы в конце концов,
ну, потому что задачи на какие-нибудь строчки
из 0 и 1 – это святое дело обычно.
Вот.
Значит, мы, тем не менее, будем считать
размер алфавита константной,
поэтому, как бы, нод,
поэтому, как бы, эта техническая деталь нас парить не будет.
Вот.
Итак.
Ну, давайте смотреть, что мы,
что у нас будет в боре.
Ну, давайте нод.
Ну, то есть, чаще всего, конечно, прям столько не надо,
но давайте вот, например, писать.
Что у нас будет? У нас будут дети.
В виде так и быть мапчика.
У нас будет родитель.
Что у нас еще будет? У нас еще будет
буковка, по которой мы из родителя пришли к нам.
Значит, будет еще там, скажем,
пометочка,
а не конец ли это строки,
ну, и заодно, если это конец строки,
то мы еще и будем хранить
какой.
Ну, будем предполагать, что их нет.
Да.
Ну, как-то туповато предполагать, что они есть.
Ну, вот.
Но, в принципе, этот вопрос, как бы, можно и
порешать.
Потому что когда вы строите борт, вы можете
неожиданно выяснить, что у вас строчек,
что у вас есть несколько одинаковых строчек.
Ну, вот. Ну, а на самом деле, когда встретите
второй одинаковый, так и говорите так. Значит,
у нее ответ такой, как у того
товарища. Все.
Ну, да.
Ну, какая-то просто копипасти в ответ с того товарища
в любом случае.
Ну, вот. Так что, как бы, да.
Ну, или как угодно решать, но это, в общем,
такой технический момент, который мы тоже будем
опускать. Вот.
То есть, да, формально нам отбоя, конечно, могут
задать вопрос, что, как бы, если Вася задумал 10
чисел, то некоторые из них могут быть и одинаковые,
да. Но
не здесь мы будем заниматься.
Вот. Так.
Еще важное понятие, которое мы введем,
это, конечно, путевая метка.
Pest от V. То есть, что это такое?
Это строчка, по которой мы можем дойти
из корня до вершины V.
Ну, вроде, естественная.
Но скорее от корня до этой вершины.
А я что сказал?
Там написано, наоборот просто.
Ой-ой-ой.
Ой-ой-ой.
Каш.
Да. Тогда, ну,
тогда уже формально притеряться.
Тогда и тут, наверное, Pest не ее предка, и ее родитель.
Ой-ой-ой.
Кошмар, за столько лет багу никто не нашел, ничего себе.
Ну, видимо, да.
Ну, все-таки.
Ну, вы же вот нашли.
Так понятно.
Итак, что же мы будем делать?
Ну, как это ни странно, мы говорим, так, у нас есть префикс-функция,
так давайте ее обобщим.
То есть, по большому счету, мы сейчас просто возьмем алгоритм кнута Мориса Пратта
в той версии, когда мы префикс-функцию построили только для строки P,
а потом строку S только по ней ходили, условно,
и будем ее обобщать.
Так, это сейчас понятно, о чем я говорю?
То есть, версия тут такая.
Мы берем строку P, брали строку P, построили для нее префикс-функцию,
а потом идем по этой префикс-функции текстом T.
Ну, или в нашем случае текстом S.
То есть, просто в каждый момент времени мы проходим очередной символ
и как бы знаем максимальную длину строчки заканчивающей в этом символе
совпадающую с префиксом строки P.
То есть, там, ну, запоминать мы ее не будем, потому что нам просто в онлайне
надо понимать, что если это совпало с длиной P, значит, ура, вхождение нашли.
Если нет, то нет.
То есть, в принципе, вот так можно искать под строку в строке,
и вот ровно этот подход мы попробуем обобщить.
Как мы его обобщим?
А практически так же.
То есть, вместо одного шаблона P у нас есть куча строчек S-итых,
мы их будем хранить в боре.
Вот.
И нам будет интересно ровно то же самое.
Мы хотим пройтись по тексту T.
Вот у нас какая идея будет.
Мы хотим пройтись по тексту T.
И в каждый момент времени мы хотим пройти очередной символ
и найти максимальные длины под строку текста T,
который заканчивается в этой позиции
и который является префиксом хоть кого-нибудь из этого бора.
То есть, или что то же самое является префиксом хоть кого-нибудь в боре,
или что то же самое, чтобы эта строчка была представлена в боре,
то есть в какой-то вершины.
Понятно, да?
То есть, короче, мы для строки T,
если мы сейчас находимся в символе I,
мы поддерживаем максимальный суффикс до символа I,
под какого-то.
Такой, что он является префиксом какой-то строки.
Ну да.
Я бы даже сказал так,
что мы находим такую вершину V,
можно сказать V и T.
Такая что?
Значит, pass от V и T,
то есть pass от V и T это строка,
которая совпадает с подстрокой соответствующей длины,
которая заканчивается в этом символе строки T.
Нам тогда еще надо хранить какую-нибудь ДВшку,
видя сколько из наших суффиксных ссылок
является окончанием хотя бы одной из строки.
Для этого надо ввести саму суффиксную ссылку.
Я пока, потому что я еще не все сказал,
потому что первая идея такая,
то есть мы хотим делать точно такой же проход.
Вот.
Мы ищем строки S1 и так далее,
S, N, T, в строке T.
Да.
Мы для каждой строки хотим выписать все ее вхождения.
Короче, запомнить, как работает,
так красить легче, чем запомнить, что он делает.
По-моему, ты сказал сейчас одно и то же.
Как работает алгоритм,
понять легче, запомнить чем.
Вхождение что во что он еще.
Ну да.
Остался кое-что, как использовать их карасик,
если ты не знаешь, что он делает.
Я не очень понимаю, как можно использовать алгоритм,
не зная, что он делает.
Нет, ну в плане, вот если ты вспоминаешь про аккарасик,
ты помнишь, что он исчез в хождение чего-то во что-то.
Ага.
А если не думать себе направленно,
то не можешь вспомнить.
Ну понятно.
Так вот.
Мы говорили, мечту мы себе описали.
Ищем максимальную подстроку,
которая заканчивается в этом символе,
является префиксом кого-то из эссок.
Ищем, причем храним это в виде соответствующей вершины бора.
И мечтаем, чтобы у нас удалось сделать такого рода проход.
Но как нам это сделать?
Давайте вспоминать.
Откуда берется понятие суффиксной ссылки?
Берется оно, можно сказать, вот откуда.
Потому что давайте вспомним, как мы это делали,
когда у нас была префикс-функция.
То есть у нас была идея такая,
что вот у нас был текст t, вот у нас было p.
Вот мы дошли до этого символа и нашли вот эту подстрочку,
которая является префиксом.
Теперь нам для и плюс первого символа надо найти такую строчку.
Что мы делали?
Мы перебирали все, даже начиная с максимальной,
все подстроки заканчиваем в этой позиции
и тут совпадающие с префиксами.
И нам было жутко интересно.
То есть перебирали в порядке убывания,
искали ту из них, за которой
следующий символ совпадает с и плюс первым.
Помните было дело, да?
Или мы как-то по-другому это делали?
Есть кто живой?
Так, подъем, ребят.
Так, ну кто-то из вас был?
Понятно, так, Гриш.
Так, вот давайте вспоминать.
И вы делали как-то иначе?
Нет, мы доказывали двумя указателями,
что это работает за лигию.
Потому что оказывалось, что по большому счету
у нас вот тут это левый указатель так двигается,
а тут правый.
Но это надо было для доказательства того,
что это работает за лигию.
Но идейно мы делали следующее.
Что такое подстрока заканчивающейся в и плюс первом символе
и совпадающая с префиксом?
Это подстрока заканчивающейся в этой позиции
и совпадающейся с префиксом,
префикса идёт символ x. Логично, да? Логично, да. Вот. И ноты. То есть мы
их перебирали. Как мы их перебирали? А ровно для этого мы насчитали префикс
функцию. Что такое префикс функция? Префикс функция нот говорит там, что
для каждого префикса мы находим максимальный суффикс,
собственный, который совпадает с префиксом. То есть заметим, что он зависит в этой
строке только от самой строки P, от текста T он не зависит от слова никак. Вот. И тогда
получалось, что мы его скаканули и получилось. То есть мы там, то есть идея была
такая, что достаточно для каждого префикса просто вот эту вот префикс функцию, то
есть следующий в списке хранить. Потому что, если он нам не подойдет, мы возьмём
префикс функцию от префикс функции, потом префиксу заберём и так далее. То есть вот это
пи от пи от пи, вот это вот. Вот. То есть так мы их будем перебирать и, соответственно,
но пока, когда мы выясним, что после очередной у нас там есть символ х, значит
это оно и есть. Вот. Ровно такой подход мы сейчас применим, когда у нас много
строчек. Разница будет только в том, что, конечно, у нас теперь уже P, у нас
нет одной строки P, а у нас есть целый BOR. Вот. Вот. А тексты тот же. То есть вот у нас есть
какая-то, допустим, строка. Вот. И ей соответствует вот эта вершина. Опа. А.
Чё, думаешь, так лучше, да? Ну, хорошо. Ну, хорошо, хорошо. Ну, валали. Потому что есть то, что там
камера на ночное видение настроена. Вот. Вот. Хорошо. Значит, смотрите. Что у нас сейчас тут будет? Сейчас у нас тут будет красота. Вот. То есть мы говорим, то есть как нам выяснить,
что подходит ли прям, то есть вот эта строка. Ну, то есть что такое, действительно, под строка и плюс один,
которая представлена в BOR-е. Эта подстрока заканчивается в этом символе и представлена в BOR-е, причём из
этой вершины BOR-а можно пройти по символу X. Логично, да? Поэтому проверяем, можно ли из этой вершины пойти по символу X. Ну, там, если выяснилось, что случайно да,
ну, значит, поздравляю. Вот сюда мы переходим и радуемся жизни. Да? Если нет, значит, нам нужно перебрать. Что? Да. Значит, нам нужно перебрать подстроки заканчиваться в этой позиции в порядке убывания,
которые представлены в BOR-е. И из каждой из них, и перебирать их пока не найдём очередную, из которой можно перейти по символу X. Но для этого, для каждой такой вершины надо хранить вот этот переход.
То есть где находится следующая по длине строка, то есть типа суффикс этой, какое у нас следующее по длине суффикс этой строки, который представлен в BOR-е? Именно это мы назовём суффиксной ссылкой.
Просто вот. То есть просто вот, прям вот в явном виде определения. Вот так и пишем, что суффиксная ссылка, это указатель на такую вершину BOR-а U, что P-satu это собственный суффикс, помните, то есть не совпадающий с самой строкой V, да?
Который не меняет ориентацию пространства.
Чего?
Какая ориентация? Какое пространство? Нет, давайте, собственный суффикс, собственный вектор, это разные вещи, да?
Нет, собственный вектор, это другая, это третья вещь. Это которая, который не меняет управление вектором. Действие на которого нашему оператора является растяжением.
О господи. Кошмар. Действие оператора является...
Ну, то есть, короче, тот, у которой, если мы возьмём A, умножить на этот вектор...
Ну, понятно. Так, ладно, давайте математику из соседнего предмета сюда привлекать не будем без необходимости, да?
Если очень хочется линала, можем когда-нибудь в конце обсудить что-нибудь типа галса. Ну, там, я не знаю, но пока в этом необходимости нет.
Что-то просим пиксмена, слушай.
Ой-ой-ой, я тоже.
Вот.
И так, значит, у нас тут всё просто. То есть, собственный, в нашем случае собственный суффикс, это суффикс, не совпадающий с самой строкой.
Вот. Ну и понятно, что из этих собственных суффиксов мы находим максимально. То есть, это корректно определено для всех некорневых вершин. Почему?
Потому что пустая строка и соответствующий ей корень точно подходит.
Вот. Так, ну, говорим, соответственно, прописываю, что для корня суффиксная ссылка, увы, не определена.
Вот.
И тогда оказывается, что такого рода проход, то есть, находить для каждой подстроки такую вершину, теперь мы можем теми же, абсолютно теми же самыми двумя указателями за о от единиц.
Ну, если суффиксная ссылка откуда-то была прислана к нам с небес по факсу, естественно.
Вот просто.
Ну, по какому? По длине как?
Ну, можно поглубнее, лишь тот же самый, да, по длине самой подстроки, да.
Что? Ну, получается...
Ну, да, можно мыслить, что, да, каждый конкретный шаг амортизированный от единицы, а можно просто сказать, что это два указателя, поэтому суммарно проход будет за о от т.
Ну, вот, да, то есть, да, можно насчитать, и это будет автоматах Карасик.
Да, вот, да, где-то там в презентации такое словосочетание тоже прозвучит.
Значит, хорошо.
Ну, вот. Ну, вот, ну, как всегда.
Значит, как вы уж сказали, да, как, во-первых, да, как всегда, как эти суффиксные ссылки вычитают, зачем они нам нужны?
Ну, мы поняли, зачем они нам примерно нужны, да.
Более того, то есть мы поняли, что мы можем проделать такой проход, но сам по себе проход нам как бы еще не поможет, потому что теперь возникает вопрос.
Как находить все вхождения?
Хочется, конечно, вот как вы делали это в преферс-функции?
Мы говорили, что если у нас вот эта подстрока совпала со всей строкой P, значит, поздравляю, мы нашли вхождения.
А если нет, то нет.
Сейчас же мы имеем нод.
Сейчас, конечно, тоже хочется сказать, что если вот в вершине, в которую мы пришли, имеет место, то есть это конец какой-то строки, значит, ура, мы нашли вхождение, записываем.
Но есть одна маленькая подлянка.
То есть мало того, во-первых, мало того, что как бы может так случиться, что вот есть вот это, у нас в списке есть еще строки, которые являются суффиксами этой строки, да, и мы их в этом месте всех тогда должны как-то учесть, правда?
Так еще и может быть подлянка, что сама эта строка не является строкой из нашего списка, а ее суффиксы являются.
То есть, например, там может оказаться там какое-нибудь слово sister и рядом где-то слово ist.
Тогда если у нас окажется, что вот у нас здесь тут какое-нибудь слово там, допустим, sister, то мы говорим, так, sister, значит, такого, так, такого слова у нас нет, значит, продолжаем дальше, а зря, потому что слова sister нет, а слово ist есть.
И мы его должны как-то учесть.
Вот возникает вопрос, как его учесть?
Так, ну как бы в идеале, то есть учесть можно следующим образом.
Каждый раз, когда мы находимся в вершине i, давайте из этой вершины пробежимся по суффиксным ссылкам до корня, пробежимся просто тупо по суффиксным ссылкам до корня, и все вершины, которые помечены как конец, мы, значит, идентифицируем как вхождение.
То есть это нам как минимум даст правильный ответ, правда?
Но маленькая проблема, амортизация вылетает в трубу, правда?
Что же делать?
Вот, значит, что же делать?
Но идея, да, но идея на самом деле такая, тут чуть позже тоже будет, мы введем такое понятие, как длинные суффиксные ссылки.
То есть предположим, что у нас суффиксные ссылки есть, тогда для каждой вершины мы можем предпочитать, что я хочу из этой вершины идти по суффиксным ссылкам до тех пор, пока не наткнусь на какое-то вхождение строки.
А, ну если у нас нужно не количество всех вхождений, то да.
Да, то есть если мы хотим все вхождения, то вот можно так сделать.
Понятно, да?
Ну мы основную задачу это решаем, это будет называться длинные суффиксные ссылки.
То есть если есть суффиксные ссылки, вы такое можете заранее предпочитать легко, правда?
Или даже ленивость сделать, если там.
СНМ какой-то.
Чего?
СНМ какой-то.
Почему СНМ, причем тут?
Ну мы типа так, сжимаем.
Как, куда? Нет.
А, ну СНМ в смысле сжатия, а, эвристика сжатия путей, ну да.
Да, да, да.
Хорошо, да, да.
С сжатия путей можно получить даже алгоритм, когда мы с тобой приблигаемся, только там нож не находит.
Ну там...
Чего?
Ну потому что очевидно нам интересно только самое низкое вхождение с переходом по каждой букве.
Соответственно до следующего вхождения, а, даже не до множества алгорита, плюс алгорита.
Ну короче нам имеет смысл хранить во-первых терминальные вершины в суффиксилтах, а во-вторых те, из которых есть переход по символову, по которому ниже перехода нет.
Соответственно суммарно таких вершин это количество терминальных плюс размер алгорита.
Сейчас, чего, чего, чего, чего?
Ммм, чего, сейчас.
Ну то есть еще раз, если у нас есть вот путь по суффиксилкам, какие вершины нам вообще интересны?
Первый тип вершин это где кончаются слова.
Второй тип вершин это из которых появился переход по какому-то символу, по которому ниже перехода не было.
А, нет, ну это по-моему это...
Нет, ну упради, автомат это уже другой немножко.
Вершин второго типа размер алгорита.
Нет, ну...
Нет, ну по-моему второе сжатие правильно, что ты просто хочешь для каждой вершины говорить, где мы окажемся, если мы находимся в этой вершине следующий символ Х.
Нет, я хочу сжать все вершины, которые не являются вершинами этих двух типов.
Ну сжать, в смысле, в дереве суффиксных ссылок.
Ну да, и после этого просто переходить в такую.
А, ну можно и так, конечно, но тогда уже легче автомат просто построить.
Это правда.
Особенно, потому что если он концент алфаит, то лучше автомат построить.
Ну да, не, ну сжатие путей да, ну тут просто да.
Вот, ну тут не сжатие путей, тут как бы просто...
Тут что-то более конкретное.
Вот, значит, что у нас тут еще?
Значит, с длинными, ну вот, с длинными разобрались.
Вот, то есть получается, то есть тогда получается заметим, что если суффиксные ссылки у нас откуда-то вообще уже взялись,
то тогда мы делаем вот этот проход за ОАТ,
и при этом в каждой позиции еще скачем под длинным суффиксным ссылком и обновляем ответ за О от единицы плюс сколько там реально обхождения было.
Понятно, да?
То есть в принципе вот у нас уже есть вроде даже не сильно сложный алгоритм,
но который просто требует, чтобы мы еще откуда-то,
то есть откуда-то еще, конечно, нашли сами суффиксные ссылки.
Так, тут, конечно, текст немножко другой.
А, ну да, потому что мы тут немножко вперед идем относить на презентации,
потому что тут имеется в виду, собственно, вот этот вот проход.
Видно, да?
Так, то есть это проход по тексту Т и суффиксным ссылкам, которые мы с вами обсуждали.
Вот, то есть это у нас проход.
То есть тут проход, тут, соответственно, там аккуратные леммы, но, думаю, там суть, в общем, понятна, да?
Да, ну, если вы пришли только что, вам сложно, конечно, это понять слету, да?
Да, ну, все понятно.
Да, ну, все, да, но думаете, что все понятно, особенно если с этим алгоритмом сталкивались уже, да?
Вот, то есть проход по строке Т, вот это вот мести...
Вот, опять же, наша любимая can-go и-go, да?
Вот она.
То есть очень простой проход.
Вот.
Вот, и длинные суффиксные ссылки.
Вот, и длинные суффиксные ссылки тут тоже описаны, да, тут, конечно, красота в этом плане.
Так, да, да, да, да, да, да.
В общем, короче говоря, остается только...
Вот, остается только вычислить суффиксные ссылки, которые мы пока не знаем, как вычислять.
А действительно, как вычислить суффиксные ссылки?
Наверное, аналогично полиэндромам.
Да? Это каким образом?
Ну, в полиэндромах не совсем, там все в онлайне было.
Вот. Но суть, на самом деле, примерно та же, даже не в аналогичных полиэндромах, а аналогичной префикс-функции.
То есть давайте вспомним, как мы вычисляли...
То есть, допустим, мы вычислили префикс-функцию тоже для житой позиции в строке P.
Как мы вычисляли префикс-функции в строке P?
Как мы вычисляли префикс-функцию в G плюс первой позиции?
В общем-то, так же, как и вот в тексте T, да?
Потому что мы говорим, что... Что такое подстрока, допустим, что такое вот эта вот подстрока, да?
Которая совпадает с префиксом.
И эта вот подстрока заканчивается в житой позиции, совпадающей с префиксом.
И после которой идет, соответственно, вот этот вот символ.
Ну, то есть мы поддерживаем просто указатель на второе P по длине вхождения?
Да нет. Ну, там мы поддерживаем.
Ну, поддерживали. Причем, более того, это и была как раз определение префикс-функции в строке P.
И в нашем случае суффиксные ссылки, да?
То есть вот здесь мы вот от G скакали по префикс-функциям, пока очередной префикс не продолжается Y.
Соответственно, то есть мы тут скакали, скакали, скакали.
Тут дальше идет символ Y. Ура!
Вот. Ну, заметим, что буквально это же мы можем сделать и в боре.
То есть как посчитать префикс-функцию для вот такой, для этой вершины?
Для этого мы берем, берем, значит, родителя, скачем из него по суффиксной ссылке.
Вот. Начиная с этого момента мы скачем по суффиксной ссылке,
до тех пор, пока из очередной вершины мы не сможем пройти по вот этому символу.
Как только сможем, значит, мы по нему проходим и говорим, что это и есть суффиксная ссылка.
Суффиксная ссылка.
Вроде логично, да?
Вроде логично, да вот.
То есть, по крайней мере, это находит, это находит правильный ответ,
особенно если вы ищете суффиксную ссылку в порядке BFS.
Ну, тут два варианта, как их, как их обычно ищут.
Ну, значит, три варианта есть.
Есть вариант, честно, в порядке BFS, да, тогда, когда вы ищете для очередной вершины суффиксную ссылку,
вы знаете, что вот эти вот все скачки уже определены.
Понятно, да?
Есть другой вариант, есть вариант делать это лениво.
Ну, в том плане, что типа, дай мне суффиксную ссылку, а я еще не насчитал,
ну, так вот, давай рекурсивно насчитай.
Тоже, в принципе, можно будет работать ровно за столько же.
Кстати, пока отдельный, отдельный вопрос за сколько, кстати.
Вот.
Ну, и третий вариант на самом деле надо строить.
Третий вариант был бы надо строить автомат.
Ну, не суффиксный автомат, а автомат.
Ну, мы уже обсуждали, да, что мы для каждой вершины можем предпочитать,
и каждого вершины, и каждого символа можем посчитать,
что если мы находимся в этой вершине, и у нас следующий символ X, то куда мы попадем, да?
То есть как мы это вообще обычно делаем?
Ну, с помощью суффиксных ссылок мы это делали легко.
То есть если у нас из вершины можно пройти по символу X,
значит мы приходим сюда.
Если нет, то мы идем по суффиксной ссылке и спрашиваем,
а если бы к этой вершине пришел символ X, куда бы мы из нее попали?
То есть так по суффиксной ссылке мы бы строили автомат, правда?
Но теперь заметим, что мы можем идти, в принципе, BFS-ом по бору
и строить одновременно и автомат, и суффиксные ссылки.
Почему?
Потому что вот у нас есть вот такой переход.
Тогда утверждается следующее, что для того, чтобы понять,
то есть действительно для того, чтобы понять,
куда у нас ведет суффиксная ссылка отсюда,
мы должны пойти в родителя, пойти по суффиксной ссылке ранее найденной
и спросить, а куда мы из этой вершины перешли бы по символу X?
Понятно, да?
То есть просто вот.
Вот, соответственно, и все.
И получается, что мы прям и суффиксную ссылку, и все переходы
ищем за O от единицы, причем честно.
Нам, короче, нужно сначала попробовать пройти из нашей вершины по символу X.
Если этого перехода нет, тогда уже спрашивайте.
Ну, когда мы насчитываем автомат, да.
То есть скажем, куда из нее пройти по нужному символу?
Да, если можно перейти из нее в BORE, то мы переходим,
если нет, то спрашиваем, куда в нее пойти из суффиксной ссылки.
А суффиксная ссылка ищется вот таким образом.
То есть это самый надежный пока с точки зрения симптотики способ.
Потому что мы тогда и автомат из суффиксной ссылки
насчитываем честно за размер BORE, умноженный на размер алфавита.
И переходы, то есть сами скачки в этом тексте T тоже делаются
теперь за O от единицы честно, а не амортизировано.
Но что делать, если мы согласны на амортизацию, но не согласны
на домножение на алфавит?
Ну, тогда можно, конечно, считать только суффиксные ссылки
и все вот эти переходы делать, вот скакать по суффиксным ссылкам
здесь можно предельно честно.
Ну вот в порядке BFS, да?
Но возникает тогда вопрос, ведь с амортизацией тут напряг,
казалось бы, потому что тут же из каждой вершины мы идем
сюда-сюда-сюда, и получается, что вроде как амортизация
должна вылетать в трубу, правда?
Ну, возникает такое ощущение.
Поэтому как бы да, и действительно, то есть сказать, верно ли
что мы все сделаем за O от размера BORE, мы не можем.
Вы имеете в виду, что у нас может указывать на один
длинный путь без лицов очень много суффиксных ссылок?
Ну да, то есть там можно...
Ну, типа того, да.
Да, потому что была бы это одна строчка, тогда амортизация
на лицо, потому что каждый скачок типа уменьшает нам
соответственно длину, вот, и там это как потенциал.
Но так как у нас здесь есть развилки, то мы так
возрадоваться не можем.
Вот.
Но, на самом деле, мы можем догадать кое-что точнее.
Если мы рассмотрим одну из строчек BORE
и рассмотрим время, которое мы потратили
на то, чтобы таким образом найти
суффиксные ссылки именно для вот вершин
соответствующей ей пути,
тогда я утверждаю, что суммарное время
поиска суффиксных ссылок именно для этого пути
есть.
Вот. Почему?
Ну, просто метод на самом деле тот же, да,
тут можно формально ввести потенциал,
но суть та же, потому что для каждой следующей вершины
мы начинаем как бы искать
суффиксную ссылку примерно там же,
где мы закончили ее искать в прошлый раз.
То есть для родителей.
Как мы ищем для следующей вершины?
Тогда мы с этого момента скачем сколько-то по суффиксным ссылкам,
потом делаем один переход, правда?
Понятна логика, да?
Или нет?
Сейчас, мне что-то не очень нравится.
Так, ну давайте.
Короче говоря, если у нас из родителей была длинная суффиксная ссылка,
то значит сам родитель достаточно глубоко
и значит
каждый раз чтобы воспользоваться,
чтобы пройти по этому пути суффиксным ссылкам,
нужно до этого родителям дойти по новой строчке
и мы собственно длиной это окупаем, да?
Ну, ну сложно сказать.
Я б так не мыслил.
Ну, в плане если картинка представляет в голове,
что типа такой длинный путь,
нет, а это тут ни при чем.
Еще раз, нет, это тут ни при чем.
То есть пока глобальному бору мы еще вывод сделаем.
Пока я просто говорю, что жила была длинная строчка,
которую мы добавили в бор.
Конкретно на этом пути суффиксные ссылки находятся
от его пути.
Вот.
Из той же префикс функции.
Нет, я имею в виду, что если мы проведем бор вместе,
подумаем, что это логично вообще.
То есть у тебя же ровно те же баллы.
Нет, в смысле для каждой отдельной строчки это понятно.
Ну вот.
Но физический смысл этого доказательства тоже
становится неплохо.
Типа, когда у нас может быть плохая ситуация,
когда у нас очень длинный путь,
а потом из нижней вершины куча листов исходит.
Тогда мы с каждым из этих листов будем очень высоко подниматься,
но чтобы дойти до этого листа нам нужно пройти
вот этот длинный путь в начале.
Ну да, причем по другим строчкам, что характерно.
Да, хорошо, можно так срулировать.
Да, то есть смысл такой.
Отсюда же подчеркиваем, что мы работаем не за количество вершин в боре,
потому что количество вершин в боре может быть значительно меньше,
чем суммарная длина строчки.
Потому что у строчек может быть какой-то длинный общий префикс и развилочки.
Но гарантировать, что вот таким образом,
что суммарно вычисляется за от сумму длин, мы можем.
То есть просто подчеркиваю еще раз,
между размером бора и суммарной длиной строчек разница существенная.
Так что вот такая вот не очень хитрая идея.
Вот, ну что?
Так, в принципе тогда это означает, что мы победили тем или иным образом.
Динамический авторатик.
Ну, в смысле, где он динамический?
К сожалению, он не динамический, он статический.
Можете еще раз поговорить, как это следует из предыдущего утверждения?
Ну, в смысле, если, ну как сказать, бор состоит,
что такое бор, как вы составляли бор?
Мы каждую строчку туда аккуратненько добавляли, да?
Мы вот посчитали суффиксные ссылки, да?
Теперь говорим, что бор покрывается, по идее, путями этих строчек.
Ну, каждая вершина покрывается одним или большим числом путей, да?
Но тогда это означает, что каждую...
Но заметим, что если взять путь в соответствующей строке,
то суффиксные ссылки на нем искали за от длины этой строки, да?
Тогда получается, если мы возьмем все строчки,
то есть мы с одной стороны покроем весь бор,
время, не превосходящие суммы длины этих строчек.
А, стоп, я думал, сих бывает размер алфавита.
Не, это сумма.
Размер алфавита у нас alphabet size, напоминаю.
Сейчас сюда сумма длины строк, ну да.
Вот, нет, сумма длины строчек, конечно.
Получается, суффиксные ссылки мы из-за этого времени насчитали,
если давно что-то разбил алфавит, там можно еще автомат построить.
После этого мы ходим по тексту,
значит, делаем проход по тексту t у этого бора,
это делаем за от t, и там еще какие-то дополнения на размер ответа.
Но это если у нас прям такая экзотическая задача,
это если у нас такая вот экзотическая задача,
в которой прям все обхождения надо честно выписать.
Вот давайте, например, подумаем, какие тут еще задачи есть.
А, вот тут еще про автомат сказано,
но про автомат мы уже все поняли,
что это все, да.
Вот, то на самом деле есть еще веселые задачи.
Можно вопрос? Давай.
Давай.
Вот мы выписывали оценку на время работы 1 на единичной сети.
Ну.
Я правильно понимаю, что если нас мент-код запускать в единичной сети,
то работают те же оценки?
Не уверен.
Ну, то есть они не совсем такие же, но...
Нет, ну не уверен.
То есть ты не будешь там искать пути, кратчайшие по количеству ребер?
А, у нас оценка была из того, что мы нашли до корня,
а тут мы не ищем до корня, а просто какие.
Тут просто ищем кратчайшие пути по суммарной длине ребер.
Сколько ребер нас не волнует.
То есть нам такие.
Да, причем тут суффиксные ссылки.
Но теперь давайте тут подумаем.
Прежде чем я открыл другие задачи, давайте еще подумаем.
А если нас действительно попросили
просто для каждой строки из этого списка сказать,
сколько раз она входит в текст Т?
Для каждой строки из списка?
Да. То есть данные строки С1, С2 и так далее СК.
То есть вы видите К чисел, житое из них,
это сколько раз строчка житое входит в текст Т?
Единицу складывать и вершину.
Ну да.
То есть наше решение исходно было бы какое?
То есть мы проходим по текстам Т, по этому Бору
с суффиксными ссылками и когда находим там вершину,
то есть мы должны прибежаться по всем длинным суффиксным ссылкам
и поприбавлять во всех терминальных вершинках единичку.
Так это не очень.
Ну это по крайней мере так было бы правильно, но долго.
Но с другой стороны,
после этого мы просто вспоминаем,
что суффиксные ссылки образуют подвешенное дерево с корнем в корне.
И тогда у нас идея такая,
то есть тогда идея такая,
дано дерево и у нас периодически приходят запросы,
увеличить на единичку весь путь от какой-то вершины до корня.
И потом когда-нибудь в конце сообщи результат.
Как мы это делаем?
Сейчас увеличить на единичку?
Нет, стоп, почему нет?
Не путь от вершины до корня, а наоборот кажется под дерево.
Нет, именно путь.
Потому что мы же говорим,
текст Т привел нас в какую-то вершину,
то есть в этом символе он привел нас в какую-то вершину.
И мы должны прибежаться из нее по суффиксным ссылкам
и всем вершинам, можно только терминальным,
и всем вершинам прибавить по единичке до корня.
А как у нас в подвешенном дереве прибавлять к пути единичку?
Ну да, то есть просто сделать отложенную вершину,
прибавить только к вершине, а потом в конце пробежаться от детей до корня
и все прибавления передать в родителя.
То есть вы пробежитесь по тексту Т,
за ОАТ,
и размер бора в конце протолкнете все эти единички по суффиксным ссылкам.
Размер бора может быть очень большой.
Но учитывая, что вы в самом начале решения тратили время
на то, чтобы его построить, и построить суффиксный ссылк.
У нас же строчки Т могут приходить много раз.
У нас строчка Т может приходить много раз,
и каждый из них мы работаем за ОАТ Т, поэтому все нормально.
А, ну нет, хорошо, тогда да.
То есть модификация да,
и надо для каждого текста Т выводить к отчисел, да?
Хочется тарить.
А, ну я понял, я понял.
Ну хорошо, ну тогда два варианта есть.
Ну нет, самый тупой вариант это давай проталкивать единичку
не по суффиксным ссылкам, а по длинным суффиксным ссылкам.
Тогда вот этот вот проход будет, то есть дерево
на длинных суффиксных ссылках будет размера К.
К – это количество строк?
Да.
Ну мы берем такое сжатое дерево?
Ну по сути, да.
Сейчас,
сейчас,
в плане, у нас есть просто отдельно дерево,
которое построено на терминальных вершинах,
и у него размер К,
и отдельно есть забросы, но забросы почему-то на К,
и у него размер К,
но забросов, очевидно, не больше, чем Т,
и каждый запрос подвешивается к какой-то вершине из этого дерева.
Нет, запросов-то у нас все еще Т.
Другой вопрос, тут понятно, что конкретно эта вершина
не обязана быть терминальной,
но мы говорим, что давайте прибавлять единичку,
если она не терминальная не ей, а ее длинные суффиксные ссылки.
Ну то есть у нас получается как раз К плюс Т?
Ну для каждого конкретного текста получается Т плюс К,
ну не считая исходное построение бора из суффиксных ссылок.
Да, можно так.
Ну или если вы хотите там какие-то онлайновые запросы
в духе там, вот вам текст Т и вас там периодически кого-то спрашивают,
то что в этом случае можно сделать?
Ну в конце концов построите хевилайт
на этом дереве суффиксных ссылок, господи.
Да, о боже, хевилайт на дереве суффиксных ссылок.
Вообще интересно придумать задачу, в которую это надо делать, конечно.
Что-то мне не нравится идея с хевилайтом.
А чего тебе не нравится?
В том, что там у нас мы прибавляли, а потом в конце пробегались и суммировали.
А если у нас онлайн, то мы не можем пробегаться и суммировать.
Да, но хевилайт-то позволяет вам прибавлять единичку на пути.
Нам не нужно прибавлять единичку, нам нужно сразу уговорить.
Ну типа, ну я не очень понимаю какой у нас конкретный запрос.
Ну запрос ты прибыл, да оно дерево отдам, допустим, то ли суффиксных ссылок.
И там тебе дают вершину и говорят прибавь на всем пути от вершины до корня плюс один.
Это какая-то странная задача.
Нормальная задача.
В плане, она уже плохо связывается со строчкой Т.
Нет, почему? Она гениально связывается.
Более того, у тебя вообще дан текст Т и у тебя два типа запросов.
Первый, припиши к тексту Т символ.
И второй тип запроса, дано число жи, скажи, пожалуйста, сколько сейчас вхождений,
житое строчка из того списка имеет в тексте.
То есть с Хэви-Лайтом ты это даже в онлайне делать умеешь.
Сейчас.
Ну то есть нам нужно будет суммировать количество единичку под дерево.
Ну можно и так.
Нет, зачем?
Хэви-Лайт это такая структура данных, которая умеет прибавлять единичку на дерево.
У нас атака-то уже есть.
Да, то есть Хэви-Лайт сам по себе это умеет.
Нет, при желании, да, на самом деле абсолютно правильно.
Можно делать единички под дерево, на самом деле мы это можем делать без Хэви-Лайта,
просто запустив DFS по бору и перенумеровав правильные вершины.
Ну, чтобы ДО-шку построить.
Можно и так.
Да, конечно, не надо писать Хэви-Лайт там, где его не надо писать,
но хотя с точки зрения теории у нас есть Хэви-Лайт, который умеет все делать за логарифом, напоминаю.
То есть не за лог квадрат, а за логарифом, помните?
Ну и другое. Ну, пожалуйста, можно линкат использовать.
Который быстрее работает, да.
Но он работает за логарифом, просто надо писать с плей дерева, все нормально, да.
Я вам сказал, когда тоже работает за логарифом, надо за логарифом дольше, чем лог квадрат.
Да, пробовал.
Мне сказали.
Кто сказал?
Тут всех таких вопросов, да, если это надо, то пробовал.
То есть как бы ты пробовал.
По-моему, ты пробовал.
Айд, ты сказал? А ты пробовал?
А мне кто-то сказал.
А этот кто-то пробовал?
Да, да, да.
Ну да.
Нет, ну там просто, да, знаете как.
То есть когда вы делаете такое утверждение, вас как бы могут неожиданно спросить, про это ты проверял.
То есть знаете, классическая разминка.
Нет, другая ситуация.
В этом смысле большая подстава.
Как-то давным-давно, когда в высшей лиге КВН играли украинские команды.
Да, очень было давно, там год 2010.
Но там, собственно, украинская команда хорошо прикололась на разминке.
Потому что там выходит девушка и задает вопрос.
Звучит он так.
Во время поездки по России премьер-министр посещает не только крупные города, но и трудодоступные деревни.
Пока все нормально.
Но приходит в том, что когда человек выходит отвечать, она ему начинает говорить что-нибудь там.
Премьер-министр посещает не только крупные города, но и трудодоступные деревни.
Ну вот, то есть человек как минимум сбивается.
Чего?
Премьер-министр посещает не только крупные города, но и трудодоступные деревни.
Мило говорит девушка.
А вас ничего не смущает, да?
О, она ошиблась.
Да, но фишка в том, что она делает это несколько раз подряд, причем в разных местах.
То есть приходит там очередной парень и она ему там.
Он посещает не только крупные города, но и трудодоступные деревни.
Вот.
Я не понял, что происходит.
Какие парни приходят?
Так.
Понятно.
Украиновская разминка, знакомое словосочетание вообще?
Так ладно, тогда бесполезно рассказывать.
Ой, кошмар.
Ничего себе, люди уже не знают, что такое КВНовская разминка вообще.
Ну вообще, да.
Но это я не знал, а догадался.
Когда-то было, да.
Не отправляй, что люди уже могут не помнить, что КВН вообще еще существует в природе вообще.
И даже по первому каналу еще показывают.
Я знаю, где надо стихотворение дополнить, причем не смешно, а что бы поверить.
Ой, ой, ой.
В КВН такое, по-моему, в 2005 последний раз практиковалось.
Да.
Нет, таких вопросов там нет.
Не, максимум, что там предлагал, это...
Это вписывается в концепцию.
Не, но там было страшнее.
Когда-то нам на разминке предложили, уважаемые капитаны, за 30 секунд напишите стихотворение,
которое заканчивается строчкой «смотрите на первом канале».
Да, 30 секунд.
Не, но там первый капитан вышел через 15 секунд на самом деле.
И при...
Почему вышел?
Нет, зачем?
Честно вышел и заявил.
Так, тот, кто много где бывал, очень много повидал.
А все, что вы не видали, смотрите на первом канале.
Все.
Но команда чемпиона, кстати, стала.
Вот.
Так что было классно.
Так, ладно.
Понятно.
Все с вами.
Так.
Вот.
Так вот.
Ну вот.
Значит, какие у нас еще есть задачи?
Вот.
Ну, на самом деле, да.
То есть, в принципе, оно есть такие пара классических задач,
что-то из них видели, но они обсудить нельзя.
Значит, вот какие у нас строчки есть?
Есть вот строчки, например, такие.
Вот, например, такая неожиданная задача.
Дана строка «с».
Ну, например, пока еще без...
Ах, карасик.
Спрашивает, а сколько существует строк длины «н» над заданным алфавитом?
Ну, он там двоичный, троичный и так далее, да.
Который содержит ровно «к» в хождении строки «с».
Что значит «содержать в хождении»?
Ну, то и означает.
Входит.
Сколько существует строк, у которых строка «с» входит в эту строку как подстрока?
Причем «к» раз.
Короче, это не как питание регулярно.
Вот.
Ну, правда, в хождении могут пересекаться, естественно, да?
Вот задача.
Как такое решать?
Вот запредлагаемую асимптотику.
Что с... еще асимптотика?
Не, ну асимптотика должна по-моему сразу палить ответ.
Можно «дп» сделать.
Так, какое «дп»?
«Дп» и «жи».
Что?
И «жк».
Что?
Мы сделали строчку длины «и».
Так.
Входит «жи» в строк «с» целиком.
А в конце...
Да.
А в конце префикс-функция «к».
Ну да.
Совершенно верно.
Понятно, о чем речь, да?
Вот.
Ну, классика, на самом деле, потому что в двоичном виде...
А нет.
То есть в принципе заметим, что это решение с префикс-функцией прекрасно обобщается и на борт.
Потому что заметим, что сбором мы делаем буквально то же самое,
только в состоянии динамики у нас ходит уже не...
То есть вместо «жи» получается вершина бора, соответственно.
Вот, понимаете, да?
Ну, самое глубокое имеется в виду, конечно.
Вот.
Так, а вот это уже должно быть что-то знакомое, да?
Да, но это тоже одна из классических задач на «карасик», конечно.
То есть существует ли строка бесконечной длины,
несодержащая в себе запрещённых подстрок?
Да.
За «о» от суммарной длины строчек, пожалуйста, такой на эти.
Вот существует ли она?
Или можно даже еще, если нет, то насколько...
Какой максимальной длины такая строка может быть?
Ну, типа можно банить все вершины, из которых по сути все ссылки достижены концы?
Ну да.
То есть строим борт, строим автомат,
и баним все вершины, из которых по сути ссылка может дойти до терминальных.
И теперь остается в внимание вопрос,
какой максимальный длинный путь вы можете...
Путь, возможно, непростой.
Вы можете забабахать, начиная с корня, по незабаненным вершинам.
В смысле, с переходами, возможно, по суффиксам ссылки или что?
Нет.
Граф, я имею в виду не борт, а автомат.
Паша, карасик.
Ну вот.
То есть можно ли ходить по этому автомату бесконечно,
не заскакивая в запрещённые вершины?
Да или нет?
Но определить это очень просто.
Надо просто понять, доступен ли искорний цикл.
Просто.
Ну вот, да или нет.
Если доступен, значит, вот, пожалуйста, вот вам и бесконечная строка.
Если нет, ну значит, тогда всё, что вам остаётся,
это в этом циклическом графе найти самый длинный путь и сказать вот.
Так что вот такая вот тоже классическая задача.
Вот. Это у нас что касается...
Ну как будет?
Уже некорректно говорить будет, потому что большие задания у вас уже есть.
Так что и вообще, по-моему, я такое ставил.
Ага.
Починились задачи?
Да, ну мы с вами в прошлый раз сидели и чинили.
А, ну да, не с вами, но мы в прошлый раз сидели и чинили, да.
Можно сейчас зачинить, потому что там последние несколько задач не отмечены,
как стринка, просто E и F.
А, ну это мелочи уже.
Некрасиво выглядит.
А, ну в этом плане, но не судим.
Вот. Это уже такое, да.
Так что вот.
Так что это был ХКРСик.
Так, есть ли тут ещё какие-то вопросы?
Нет.
Так, ну ладно.
Ну, значит, ладно.
К суффиксному массиву мы тогда пока переходить не будем.
Значит, вместо этого так.
Пока у нас перерыв, после которого мы перейдём в Галилу Сейфересу.
Кому?
Что сейферес?
Сейферес.
Вот Галил Сейферес.
Это значит, мы будем искать все вхождения под строки в строку.
Одной под строки в одну строку.
Это один человек или два?
Два.
Вхождения одной под строки в одну строку?
Да.
Но за линию. Времени.
И завод единицы дополнительной памяти.
И без хэшей.
Хэшей нужно дополнительной памяти.
Нет, на самом деле нет.
Если ты ищешь под строку в строке с помощью хэшей, доп-память тебе не нужна.
Потому что хэш всей строки P ты можешь найти без доп-памяти, правда?
А в TXT тебе нужно просто взять все под строки P, длины модуль P и найти у них хэши.
Ты их можешь плавающим окном так аккуратненько находить.
Так что в принципе хэшами это без лишней памяти делается при желании.
Но мы это сделаем без хэшей.
А почему хэшами за линию?
Ну, в смысле, вот мы нашли.
Вот мы поняли, что хэши совпадают.
Нет, ну, в смысле, имейте в виду, это, конечно, в предположении, что мы не верим в коллизии хэшей.
Вот так.
Да, если мы, конечно, перепроверяем коллизии, то, конечно, да, у нас проблемы.
Да.
Вот.
Но в любом случае мы порешаем задачу без хэшей.
Ладно, пока перегрев.
Так, значит, давайте сейчас включаемся.
Да, сейчас будет заведомо неизвестный алгоритм.
Возможно, будет также сложно, как от софт-хиппи.
Ну, скажем так, нет, алгоритм, который сейчас будет иметь место, он не вполне тривиален.
Ну, нет, как показала практика в понедельник, там, видимо, софт-хиппи, то тоже не очень сложно алгоритм на самом деле.
Да.
Ну, да, лайфхак стандартный.
Да, если параллельно не сидеть в телефоне, то любой алгоритм, оказывается, не такой сложный.
А как софт-хиппи же в октябре?
У нас был в ноябре.
Ну, видимо.
Мы уже три лекции пропустили.
Ну, видимо, я не знаю.
Нет, ну, не знаю, видимо, мы как-то быстрее идем, я не знаю, или что-то пропустили.
Я случайно забыл, я не знаю.
Но, не знаю.
Пока хорошо идем.
То есть, мы так, вроде, софт-хиппи уложили, там за два занятия прошли, еще и в качестве довеску успели обсудить ОВЛи краснокердые.
Вот.
Ну, видимо, нет.
Ну, вот так же, не знаю.
Ладно, так же, давайте смотреть.
Значит, что мы делаем?
Значит, задача.
Ну, допустим, ищем.
Значит, под строку P, там, видимо, где-то в тексте T.
Ладно, буквы могут меняться, но по умолчанию это P и T.
Мы хотим найти все вхождения P в тексте T, используя от единицы дополнительной памяти.
В чем, имейте в виду, что...
То есть, имейте в виду что-то типа машины тюринга.
То есть, в том плане, когда мы найдем очередное вхождение, мы там соответствующую чиселку отправляем куда-то в ответ.
Прям отправляем и больше и никогда не пользуемся.
То есть, наша цель от N времени от единицы дополнительной памяти.
Как уже было правильно сказано, в принципе, можно найти все вхождения за от единицы дополнительной памяти за квадрат.
Прям в тупую.
Логично, да?
Ну, за Pt.
Ну, в смысле за Pt, да.
В смысле за Pt.
Вот.
Итак, ну, значит, как же мы будем жить?
Ну, давайте так.
Будем сейчас идти просто аккуратненько по статье, поэтому я сейчас дам некоторое обозначение, определение из нее.
А у тебя номер какая?
Чего?
Почему номер?
Причем тут номер?
Нет, там нет номера.
Да, авторы.
То есть, авторы вот такие.
Вот.
А, это такой каламбур, да?
Ну, понятно, да.
Да, да, да.
Вот, значит, Галил Сейферс.
Вот.
Ну, формально получается так, да.
Да.
То есть, ну, авторы статьи вот такие, да.
Итак.
Так.
Ну, во-первых, первое обозначение.
Во.
Что?
Ну, вот у нас будет такая константа K, которая равна 4.
Вот.
Ну.
Не-не-не-не-не.
Обратной функции кермана там не будет никакой.
Ну, вот.
Ну, скажем так.
Просто будет удобно использовать параметр K, ну, потому что
он будет, ну, это делать для того, чтобы было удобно
понимать, о какой конкретно четверке, в каком конкретном
контексте идет речь.
Так, просто сильно удобнее.
Ну, вот.
Сейферас.
Вот как написано.
Да.
Ну, нет, да.
Да, это два парня, если что, так что, как бы, да.
Хотя, я не знаю, там Зви Галил и кто-то там Сейферас,
так что, может, конечно, и девушки, я не знаю, если
честно, да.
А девушку с фамилией Сейферас?
А что не так?
Что?
Нет, я не пойму, а в чем противоречие, честно?
Что бы ты с ней делал?
Да, что тебе дарит?
В чем проблема девушке иметь фамилию Сейферас?
Может, это не проблема?
Ну, не знаю.
О, господи, что-то у тебя странные ассоциации какие-то,
да, ну.
Вот.
А то так помолчание уже начинаешь думать, а если
у девушки там фамилия Саватеева, напрямую, к чему проблема?
Хы-хы.
И что?
Это все проверяет.
И что?
Зато и там, и там первая буква С, и что?
Садовничий тоже, да.
Ну, вот.
Хы-хы.
У кого круче фамилии?
О, господи, нет, я против того, чтобы вычитать это решать.
Если считать хэш, по модулю 179.57.179.57.101.
И что?
И посмотрите, у кого больше хэш, у того и фамилия круче.
Ничего себе.
Ну, так.
Просто скорее дедушка, чем девушка.
Да?
О, господи.
Господи.
Так, ладно.
Ай.
Ну, это...
Так, значит.
Неадекватно.
Значит, мы будем жить в один адоксации.
Так, ну ладно.
Да, под строку они как-то странно вводят.
Это я вводить не буду.
Так.
Значит, еще.
Значит, тоже.
Определение.
Значит, строка Z является периодом строки S.
Если...
Угадайте, что?
Существует такой х, что...
Существует такой х, что...
Нет, нет, нет.
Если...
Срока S...
Это периодично?
Нет.
Нет, смотрите, у нас будет два определения таких.
Если S...
Это префикс...
Z в бесконечной степени.
Во.
То есть, разница в том, что, конечно же, длина Z
не обязана быть делителем S.
Так вы вводили периодично,
с напрошенным нанятием равно даже.
Или периодично, если
S от I равно S от L плюс I?
Ну, вот да.
Ну, значит, это определение сразу стоит.
То есть, вот так, тут я написал одно из определений, которое прям честно авторы так пишут.
Более того, они на самом деле
вводят их просто целых два определения сразу.
Ну, правда, эквивалентные.
Второе определение звучит так.
Значит, Z
период
S
если
S префикс
ZS.
Ну, да, определение.
Еще они два раза определяют.
Вот. Ну, так, просто
видимо, для лучшего понимания, да, то есть
это, заметим, что эти определения эквиваленты.
Ну, на самом-то деле.
Но, правда, здесь
вот маленькая оговорочка,
которую мы в прошлый раз не использовали.
Оговорочка заключается в том, что
Z вообще по длине может оказаться даже
больше S вполне.
Понятно.
Ну, оба этих определения это спокойно кушают.
Да, у нас она периодично
по строке, а там мы определили
периодично по числу.
Ну, да. Вот.
Ну, здесь тоже аналогичное понятие
будет, будет оно называться shift.
Вот. Ну, об этом позже.
Об этом мы тоже, естественно, напишем.
Вот.
Ну, тут можно пример рассмотреть.
То есть, на самом деле, вот если рассмотреть
там строки,
строки, допустим, ab-ab-ab
и ab-ab-ab. Ну, вот. То, значит,
у строки ab-ab-ab какие периоды есть?
Значит, у строки ab-ab-ab есть
период ab
и, соответственно, еще ab-ab.
А еще ab-ab-aba.
Вот.
Вот.
То есть, вот такой еще
момент есть.
Вот.
Значит, далее.
Что, значит, еще какое понятие
есть?
Значит, еще введем такое даже
обозначение.
Для P меньше либо равного
модуле S
мы введем такое понятие
reach с индексом
S от P.
Которое равно...
Ну, напишу формально.
Напишу формально.
Это максимальному
такому Q
меньше либо
равному, видимо, модуль
S
такому, что
значит
S от 1 до P
это период
S,
1,
Q,
4.
Ну-ка, давай.
Нет.
Нужно брать...
Наверное, нужно брать Q
больше, чем P.
Не обязательно.
Потому что Q
нужно максимально,
потому что Q равно P нам по-любому подходит.
То есть, по сути, следующее.
Если P равно, допустим,
5 и оказалось, что строка
S начинается с, допустим,
ABCDE,
то что такое reach?
Reach, это мы идем по строке S
и смотрим. Вот у нас ABCDE.
И дальше смотрим. Вот она идет
сначала по циклу ABCDE,
ABCX.
И это означает, что reach
от 5 находится вот ровно в этом месте.
И он равен 18.
Вот, понятно?
То есть, вот такая вот красота.
Вот.
То есть, на самом деле, я...
В уже имеющейся у нас терминологии,
я бы, конечно, этот reach мог написать
сильно проще.
Вот каким образом.
Ну, это да.
Да, максимальный префикс P периодичный.
Я бы мог написать это гораздо меньше символов.
Я бы написал, что reach от P
это равно P
плюс Z функция
от P плюс 1.
Где коллизия?
Где Z?
Сверху.
А, ну там Z-строчка, а тут Z-Z-функция.
Да, проблема.
Вот.
Да.
Не то чтобы спасать, но...
Не, ну я могу тут, конечно,
игрок написать.
Но это не...
На самом деле, это как бы принципиально
погоды, я думаю, делать не должно.
Бум-бум-бум-бум-бум.
Во.
Вот.
Ну да, тут, конечно, с игроками, да,
идеально было бы P плюс ZP, но у нас
один индексация, напоминаю.
Вот. Так это вот понятно,
откуда я беру, да?
Вот. То есть просто вот идентично.
Так.
Давайте, как еще? Значит, дальше сейчас
начнутся еще веселые определения.
Значит, смотрите внимательно.
Значит, определение.
Просто
выводится куча определений, потом
старый с алгоритмом такой, ну он работает
и докажется.
Если бы.
Нет, ну до него придется еще доходить.
Не будет работать.
Чего это не будет работать?
Ага. Да.
Вот это вот.
Какие вопросы.
Чего это?
Итак. Значит, говорим.
Будем называть строку S, вот сейчас появится не тривиальное определение.
Базовая.
Еще одна база.
Да.
Если
не существует
такой строки, ну хорошо-хорошо,
Y
и такого
числа
к
и больше единицы,
ну да, можно и, у нас тут нет комплексных чисел,
что S
равно Y
записанной и раз.
Что, что такое это звездочка?
Альфа звездочка.
Алфавит.
Это то, что у нас сигназ
ну алфавит у нас
альфа.
Вот давайте тут напишем.
Альфа, алфа.
То есть если просто S, не периодическая.
Нет, нет, нет, это не совсем так.
Вот строка, обратите внимание, строка
АБАБАБА периодическая не является.
Базовой является.
А строка
АБАБАБ базовой не является.
Потому что ее можно распилить на три экземпляра АБАБА.
Не нормальная периодическая.
Ну, так.
Нет, вот так. Вот аккуратно.
Нормально периодическая.
Потому что да.
То есть мы как бы не путать.
То есть строка, то есть у строки
АБАБАБ и АБАБАБА
обе имеют период 2,
ну один из периодов.
Но при этом
АБАБАБ
не является базовой строкой,
а АБАБАБА является. Это для нас будет
принципиально.
Вот.
Так.
Ну, это еще пока смахивает на общее.
Так, вот сейчас будет прям ключевое
определение.
Да, вот вы прям записывайте, потому что мы
потом всеми этими определениями как начнем
пользоваться.
Определение.
Значит,
Т.
Префиксный период С.
Внимание.
Префиксный период С.
Вот это прям
вот определение имеет отношение именно только
к этой статье, конечно.
Потому что все предыдущие, то есть в остальной терминологии
в принципе можно мыслить в целом
в теории строки. Вот префиксный период возникает
именно прям здесь.
Значит, префиксный период С.
Если, внимание.
Т.
Базовая.
Если Т. Базовая.
И.
Т.
В степени К.
Да, вот то само ЕК.
Это не коллизия, а именно вот.
Это префикс С.
Вон то.
Который 4.
Вы-то чего
уже говорили, что мы вводим константу К,
которая у нас будет равна 4.
Там было
чего уровня easy
и чего уровня medium?
Так,
это я
тупнячок.
Я просто начал писать префикс
и не смог остановиться на автомате.
А почему тут слово
период?
Не знаю.
Вот тут я говорю, вот
девушка с дедушкой
сказали, вот мы и думаем.
Они это так назвали, я не знаю.
Я не знаю,
я не знаю,
Питерским гамбургером.
Т. является Питерским гамбургером С.
Или там
четырехслойным
гамбургером С, если
соответственно.
Пожалуйста.
Вот они назвали префиксный период почему-то.
Да, причем обратите внимание
у этого определения важная
приятная вещь, что
периодом всей строки С
Т быть не обязана от слова совсем.
Т в степени какая-то префикс?
Да.
То есть Т не обязана быть
префиксом С, боже упаси.
Т не обязаны быть
префиксом С.
Эквивалентное
определение.
Еще определение
два.
Значит Т
префиксный период Ф.
Хочется написать преф период,
но как бы сейчас
кто-то начнет ругаться словами типа преферанс.
Вы там
в преферансы не играете?
Неским.
Префиксный период С.
Если
ну можно вот еще
вот так написать.
Если reach
с индексом С
от модуль Т
больше либо равно
к модуль Т
ну тут придется еще написать,
что Т базовая
и конечно же Т
префикс С.
Вот так.
Можно еще вот так.
Ну здесь как бы думаю там все
очевидно, то есть так скорее
как бы там
более удобно пользоваться.
Речь от Т?
От модуль Т, да.
Речь.
Стоп.
Мы же
речи
определения для префикса С.
Ну вот я и описываю, что Т префикс С.
Вот именно поэтому
это вот тут и прописывает.
То есть Т префикс С
естественно базовая
и reach от этого префикса оказывается
больше либо равен к К на длину этого префикса.
Вот.
То есть можно говорить,
что даже не Т префиксный период С,
а П префиксный период С, где П это уже чиселка.
А не строка.
В общем суть. То есть возможно нам придется
этот период там шаманивать, но суть
вот такая.
Так что вот на этом понятии префиксного
периода мы тут и будем жить.
Чего?
Да, вот так. А это они говорят, да, вот мы
введем константу К, которая будет равна 4.
Если вам не нравится вводить константу 7,
тоже в принципе будет работать.
В принципе кстати.
Ну как всегда,
тут как в алгоритме
этих вот это,
Блюма, Флойда, Пратта и компании.
То есть тоже мы там делим
строчку на пятерке, хотя в принципе могли бы и на семерке,
и на девятке, и там на
пятидесяти семерке тоже бы работало.
Трой, потому что константа
там не очень тогда будет.
Вот.
Ну да, то есть будет это что-то.
То есть константа не очень.
Как это? Я умею печатать слов там
257 символов в минуту.
Да, да. Ну правда такая безобразная
такая фигня получается.
Вот.
Обыкновение какой-то, правда,
да.
Да, это как искать катовую порядковую
статистику за линию без рандома.
Нет.
Если выбрать константу 7, 9, 11
или больше, то будет нормально.
Если выбрать 3, то получается аналогия.
Ну или, по крайней мере, там
надо сильнее думать, чтобы
доказывать, что это линия.
Потому что это тоже самое рассуждение.
Если брать чисто то же рассуждение,
там можно показать, что у решения этой рекуррента
это аналогия. Так что вот.
Так. Значит, это я все
написал. Это вы все написали.
Это я все стер. Вы, пожалуйста, это
не стирайте.
Вот.
А то да.
Как это когда-то прозвучала бы как смешная шутка,
и у вас есть возможность это все стереть теперь.
Слушайте, я сегодня
такие сложные шутки говорю, да?
Нет, я понимаю, что
на втором курсе все, особенно на втором курсе,
приходят в этот стейк, когда задаешь вопросы,
что?
Я не понял, как это стереть можно.
Что можно стереть?
Дважды два.
Ну мало ли.
Вот. Так вот.
Ну давайте попробуем.
На чисто ответственность.
Так.
Ну, конечно, там одной из простеретических
основ.
Этим алгоритмом является знаменитая
лемма о периодичности.
Значит, я ее буду говорить так.
Если строка S.
Значит, P1 периодично.
И P2 периодично.
Ну, я буду говорить, что строка S
P периодично, если префикс длины P
является периодом строки S.
Так, что? Опять черная магия?
Чего? Что?
Так, что из этого ты где не знаешь?
Нет, есть вероятность такой, что я не просто слышал,
потому что ты ее даже придумывал. Так.
Значит, пусть у нас строка S
периодично, а также
верно еще, что модуль S
больше либо равен, чем P1
плюс P2,
то тогда я утверждаю,
что S
нод P1
P2 периодично.
То есть вот такая вот лемма.
Ну, спрашивается, откуда я ее взял?
Ну, по большому счету,
надо доказать, что вот в этой ситуации
надо просто доказать, что S
модуль P2 минус P1 периодично.
Ну, потому что если мы это докажем, то дальше
в дело тупо вступит алгоритм Евклида.
Но как же доказать, что у нас строка S
P2 минус P1 периодично?
Ну, положим без ограничений обществе, что P2
больше, чем P1.
Ну, что значит у нас строка P2 периодично?
В принципе, это означает, что любые
два символа на расстоянии P2
они равны.
И любые два символа на расстоянии
P1 равны.
Но тогда я утверждаю, отсюда надо просто вывести,
что любые два символа
на расстоянии P2 минус P1
уже равны. Как я это сделаю?
Очень просто. Чтобы скакнуть на P2 минус P1
я должен скакнуть на P2
в одну сторону и потом вернуться
на P1.
Да, мы так можем делать не всегда,
потому что может так случиться,
что справа у меня
нет P2 символов, хотя вот если там
P2 символов есть, то я так скакнуть
могу. Логично, да?
Что я еще могу сделать?
Второй вариант.
Я еще могу скакнуть
на самом деле на P2,
то есть на самом деле на P1
могу скакнуть вот сюда, а потом
на P2 вот сюда. Я еще вот так могу сделать.
То есть если я смогу сделать или так,
то тогда эти два символа очевидно равны.
Возникает естественный вопрос.
Какой?
А что делать, если я
не смогу так сделать
ни туда, ни туда?
Да, но такого у нас
не бывает. Почему? Потому что тогда мы вынуждены
заключить, что здесь
справа от... То есть как бы вот есть
вот этот вот х, вот этот, и тогда получается
здесь меньше, чем
P2 символов, и здесь меньше,
чем P1. И тогда в сумме их
получается меньше, чем P1
там меньше либо равно, чем P1
плюс
P2 минус 1 плюс
1. Понятно, да?
Вот.
То есть получается...
То есть именно поэтому мы тут и требовали,
чтобы у нас длина была такая.
Вот. Соответственно.
Так что получается
так.
Хотя с другой стороны
сейчас тут надо почистаться, потому что
вообще... То есть вообще
при желании как-то выясняется, что
на самом деле, если тут я напишу P1
плюс P2 минус 1, то это утверждение
вроде как тоже работает.
Что?
Кстати, P1 плюс P2 минус 1?
Да.
Ну, в такой формулировке
леммы нет, но просто теперь возникает вопрос,
а нельзя ли ее усилить?
Ну типа, вот у вас снизу
оценка точная.
Да, но это точная оценка. Это P1 плюс P2 минус 1.
И получается... Нет, а как я еще тут
это усилю? То есть я вот... Я вот это
доказательство не могу провернуть, когда у меня
тут меньше, чем P... То есть когда у меня тут
P минус 1 и тут P2
минус 1.
И получается... Ну вот. То есть это означает,
что получается для
P2... То есть получается
следующее, что для строки длины
P1 плюс P2 минус 1, по крайней мере такое доказательство
я провернуть не могу.
Ну да.
Вот. Ну вот, внимание, вопрос.
А почему я не могу? То есть это как бы...
То есть это скажешь так, теперь она действительно не верна?
При такой длине? Или...
Или у меня просто доказательство слабое?
Вот как вы думаете?
Я думаю, что не верна.
Так.
Сейчас, а в чем фокус?
В вернали это ляма,
если заменить P1 плюс P2 на P1 плюс P2
минус 1? Да.
А зачем нам это?
Ну вот, а вот...
Это называется интересно.
Ломается.
То-то и прикол, смотри. Допустим, у меня строка длины
P1 плюс P2 минус 1.
То есть у меня есть вот тут символ X.
И допустим, тут P1 с его участием,
и тут ровно P2 с его участием.
Тогда получается, я ни сюда не могу
скакнуть на P1, ни сюда не могу.
Я не понимаю, в чем проблема. Давайте возьмем строку
ABABAX.
Чего? ABABAX.
Нет, ABABAX.
ABABAX. И что?
Это строка...
Она не четыре периодичные, пять периодичные.
Нет, она не четыре периодичные, ни черта.
Потому что X.
Сейчас у нас один проблемный символ,
с которым мы никуда не можем
скакнуть. Да.
Ни с кем вообще не связан
никакие ограничения?
В ноте он же будет.
Нет, он кое-каким ограничениям он связан.
Потому что смотри.
Потому что мы можем пройти вот так,
пусть P1 меньше,
тогда я могу пройти на P1 вперед,
и у меня тут X будут.
Более того,
я могу
этот X еще
сдвинуть на P2.
Вот. То есть это у меня
P2,
и тогда у меня получается
еще тут X. Но тут
X, он порождает вот тут X и тут
X. Видно, да?
Мы сейчас...
Ну хорошо, идиотский пример. Давайте возьмем
строку ABAXCA.
Что? ABAXCA.
Она шесть периодичная
и пять периодичная.
Да, но у нее длина-то совсем шесть.
А нам бы тогда...
Для нашей теоремы должна была быть длина
десять.
Мы как раз спрашиваем, верно ли,
что если мы уменьшим длину,
теорема останется?
Уменьшим длину хотя бы на один.
Понятно, что если совсем глобально уменьшим,
то теорема не останется.
Да, но ты уменьшил прям совсем жестко.
Да. Уменьшать совсем
под воду не получится, согласен.
Это да.
Ну хорошо, а если мы допишем в конец
ABAXCA, например, еще...
Нет, ну не ABAXCA,
просто A. Ну и что?
Все еще не работает.
Не работает.
Пять-восемь периодично. И вроде
это уже мы достигли. Правда, это строка уже не
шесть периодично.
Она...
Восемь периодично тоже плохо.
Ну да.
Да.
Нет, по один плюс по два минус один
мы уже уже получили, что можно
из доказательств.
Хочется по один плюс по два минус два.
Нет, там не получили мы.
Там почему-то здесь
меньше либо равно
написано со стороны.
Там должно быть...
На плане на доске сейчас написано
доказательство для минус один.
Ну, попытка доказательства.
Пока это еще начало
доказательства.
То есть мы говорим, что вот этот символ
должен был быть каким-то вот таким символом,
и тут еще вот этот, видимо,
последний символ можно на минус два
на P2 перекинуть.
Ну ладно, там есть конечно оговорочка,
хотя...
Ну вот, то есть там...
То есть его там, видимо,
скорее всего он попадет в какой-то
вот такой суффикс,
то есть там он попадет...
То есть он либо попадет в...
Если он попадет в последние
P1 минус один символов,
там P1 минус один символов,
то значит он тогда равен
еще какому-то из этих символов.
Тут тоже его можно так проскакивать,
проскакивать. Ну и так до тех пор,
пока этот х не попадет уже здесь
в P1 с права символ.
Хотя, с другой стороны, тут уже...
Ну да.
Сейчас, ну что мы хотим получить?
Мы хотим получить для семи или для восьми?
Ой, в смысле...
Ну короче говоря, утверждается,
что если поставить P1 плюс P2 минус два,
то уже не работает.
Ну у нас...
Плюс один уже не работает.
На минус один у нас вот доказательство или...
В каком месте это доказательство?
Там...
Пока это еще не доказательство.
Пока это что х кому-то там равен.
Но почему как бы он так...
То есть вот эти вот механизмы
позволят ему пробежать всю строчку,
непонятно.
Так, у нас есть доказательство
для P1 плюс P2?
Да.
Значит, доказательство такое.
Рассмотрим любые два символа
на расстоянии P2 минус P1.
Значит, я утверждаю, что мы...
И вот возьмем этот левый крестер.
Либо влево P2,
либо вправо P2, либо влево P1.
Так.
Вот. Допустим, мы можем пойти вправо P2.
Тогда пойдем вправо P2 и пойдем влево P1.
Получится, что вот этот символ равен этому.
Потому что P2 периодично,
а этот символ равен этому, потому что P1 периодично.
Окей, дальше. Почему мы можем
пойти вправо P2?
Ну либо вправо P2, либо влево P1.
Потому что предположим,
что мы не можем ни пойти вправо,
ни пойти влево.
чем p1 символов, и справа меньше, чем p2 символов.
То есть всего у нас символов не более, чем p1-1, плюс p2-1,
и еще плюс 1 наш.
Это в сумме… там p2 плюс p1 минус 1.
Вот такое у нас было доказательство.
Хорошо.
Вот.
Но при этом у нас еще есть упражнения для p1 плюс p2-2.
Ну вот.
Мы пока думаем хотя бы на p1 плюс p2 минус 1.
Это единственный случай, который остался.
Почему?
Так.
Но на p1 плюс p2 минус 2…
Мы можем взять сначала p1 минус 1 символ A, потом символ B,
а потом снова все символы A.
Так.
И что нам это даст?
Тогда…
А у нас две последние строки, а она будет для них и для
них периодично.
Вот.
Но очевидно…
Сейчас.
Что такое соседний?
Нет.
Смотри.
А что брать?
Сейчас.
Короче, я беру очень много символов A, потом символ
B, а потом снова куча символов A.
Сколько-то?
Столько же или…
На 1 меньше.
И что?
И что это даст?
Даже не на 1 меньше, а да, можно столько же.
Вот.
Если мы берем столько же, тогда у нас есть строка длинной…
А на 5 периодично и 6 периодично?
Ну да.
Вот.
Но не 1 периодично.
Да, но это 9.
Это не 10.
Да.
5 плюс 6 это 11, минус 2 это 9 как раз.
Ну хорошо, да.
Но так опровергается.
Вот.
Ну хотя…
Ну да.
Ну тут…
Это правда для минус…
А для минус 1 это несколько случаев.
А почему?
И почему это правда?
Потому что по индукции.
Короче, доказывают.
По длинней строке.
Да?
Да.
Ух ты.
Это как?
Это как?
Давайте…
Ну для начала вот…
Случей, короче, когда их ГЦД равняется единицам.
Так.
Я утверждаю, что можно из первого чувака прийти во второго.
Так.
Из первого можно прийти во второго.
Так.
То к чему же это можно?
Ну мы поступаем алгоритмом.
Типа добавляем P1 и почитаем P2.
А.
Ну да.
Доказательство очень простое.
Как доказывать, что из первого можно прийти во второго?
Скачем по… Да.
То есть скачем из первого по P1, P1, P1.
Утверждается, что мы проскачем… То есть скачков мы этих сделаем
сколько?
Ровно P2 минус 1 скачок.
Нет?
А нет.
Не настой.
Там же не произведение.
А да, там не произведение.
Хорошо.
И что так?
А откуда тогда мы возьмем, чтобы мы во второй попадем
как-то?
Что мы не доказали?
Что мы не доказали?
Так.
Ну хорошо.
Да.
То есть мы замечаем, что… Да.
Что мы не доказали.
Вообще пока ничего мы не доказали.
Что мы в этом случае еще не доказали.
Так.
Мы можем просто вот для разности доказать, что мы очевидно
из первого чувака можем… Из первого чувака плюс
разность.
Да?
Так.
Ну не совсем.
Так.
Вот мы знаем, что если нот P1, там P2 равно 1, тогда мы
из этого пользуемся тем, что у нас есть какие-то
мексические там K и L.
Нет, ладно.
Там P1L плюс P2M.
То есть P1L минус P2M равно 1.
Где LM положительные числа.
Вот.
И что мы делаем?
Если мы не отобрали P1, то добавляем P1 пока можем.
Как только уперлись в хвост, начинаем вычитать P2.
Очевидно, не может быть такого момента, когда мы
не можем сделать ни первого, ни второго.
И поэтому в конце концов мы придем в нужную нам единичку.
Так.
Нет.
Из каждого элемента, кроме одного вот этого плохого
по центру, мы всегда хоть что-нибудь можем сделать.
Для каждого элемента кроме человека по центру мы
ровно в тем же способом доказали.
Ну да.
Остается только конкретно для него доказать, что вот
так.
Доказать, что он равен следующему через пока 2 минус
P1.
Да, хотелось бы.
Да.
Ну как же это?
Да.
Ну хоть что, только как мы это делаем, пока вообще
непонятно.
И сейчас.
То есть все.
Уже согласны с тем, что вот заветную единицу мы
получили.
Какая заветная?
Ну вот.
Ну в смысле, что вот мы предвзяли, что первый элемент
равен второму.
Пока вообще не согласен.
А что не так в обсуждении?
Ну.
В общем, что-то вообще нечем.
Видимо, да.
Потому что вообще не понятно.
Мы можем как-то применять какой-то жадный алгоритм
утверждать, что он рано или поздно придет во второй
символ.
Почему он туда придет, лично мне непонятно от слова
совсем.
То есть мы говорим следующее.
Либо P1 равно P2, и тогда это верно?
Ну тогда нот у них не равен 1.
Ну я имею в виду в самой лемме.
Либо P1 равно P2, или это верно?
Ну.
Либо P1 не равно P2, тогда у нас P1 меньше, чем P2 без
ограничений в обществе.
И тогда из этого символа мы можем прыгнуть на P1
направо.
Ну из этого?
Ну не обязательно.
Хотя нет, направо мы можем, да.
Так.
Ну нужно из этого что-то вводить, да?
Ну да.
Так.
Ну заметим, да, что...
Хорошо.
Ну давайте так.
Да.
А хотим упрыгнуть на P1 минус P2?
Ну в идеале хотим, да.
На P1 минус.
То есть там нужно прыгнуть...
Стоп.
Сейчас.
На P2 минус P1.
Наоборот.
Нет.
Ну там видимо...
Да.
Так.
Ну там видимо логика такая.
То есть...
Да.
Ну хотя нет.
То есть нет, у нас как бы проблема, что мы вот так
прыгнуть не можем, потому что строчка заканчивается
буквально здесь.
Поэтому...
То есть как бы, да, на P1 мы прыгнуть можем.
То есть как бы вот этот...
То есть мы можем буквально там прыгнуть на P1.
Более того, может быть, даже если P1 сильно меньше,
чем...
Ну в данном случае вот так скорее, да.
Вот на P1 можем так прыгнуть.
Сейчас я, возможно, Жаня как-то плохо сказал.
Вот давайте мы просто разобьем...
Вот все, мы считаем, что n сравняется P1 плюс P2 минус
1.
Да.
Вот у нас есть этот плохой центральный элемент, да?
Так.
Жадник-то такой.
Если мы сейчас находимся левее этого плохого чувака,
то всегда добавляем P1.
А если мы находимся правее, то вы читаем.
Добавляем P1 или P2?
P1.
То нет, я извиняюсь, тогда...
Тогда, извиняюсь, мы вот из этого символа пойдем вот
сюда на P1, вернемся на P1.
То есть они будут...
Да.
Слева направо мы добавляем P1, справа налево мы...
Ты не сможешь почитать...
Ты не сможешь учесть P2, потому что у тебя может быть
2 по 1 меньше, чем по 2.
Да.
Сейчас у нас...
Мы как построили центральный...
Ну это P1.
У нас слева по 1 символ, а справа по 2.
Ой, ну на...
Поэтому да.
На...
Я думал, что слева P2, справа P1.
Нет, чего...
А, ну хорошо, да.
Хорошо, то есть хорошо.
Справа мы идем на P2, влево мы идем всегда на P1.
Хорошо.
Зачем вообще жаль?
Ну...
То есть у меня идея появилась, типа давайте просто рассмотрим
первые P1-1 символы.
И что?
И...
Будем искать из них просто вправо на P2.
И тогда каждый раз мы будем привылять P2 по модулю P1 к нему.
То есть у нас был индекс, мы привыляем к нему P2 по модулю P1.
Вмечаем, что он равен элементу, у которого индекс будет
И плюс P2.
Итак, мы делаем для всех P1-1 первым.
Нет, что...
Что делаем?
Куда делаем?
Ничего не понимаю.
Ну, просто...
Сейчас.
Я предлагаю рассмотреть префикс для P1.
Ну?
Мы хотим доказать, что у него все буквы одинаковые.
Если нот равен 1...
Да, мы сейчас рассматриваем, что нот равен 1.
Если мы от каждой из них будем искать на P2 вправо,
тогда мы приравняем ее к какой-то другой.
Ну, хорошо, да.
Ну, хорошо, этот префикс равен, допустим, суффиксу, и что?
Ну, я утверждаю, что этого должно платить.
Почему?
Потому что мы его сдвигаем на какое-то число,
которое взаимно простое, с P1.
И что?
Нет, ну просто...
Ну и что?
Ну, сдвинулось оно само по себе куда-то еще.
Нет, в смысле, циклическо сдвигаем.
У нас строка, получается, равна, грубо говоря, своему циклическому сдвиганию.
Ну и что?
А, жесть.
Нет, ну да, то есть, в принципе, сейчас...
Нет, или это...
Сейчас P1 сохраняется при циклическом сдвиге?
Ну не понятно. Нет.
Потому что мы сдвигаем на число, которое взаимно простое, с длинной строки.
Да-да-да, она сохраняется при циклическом сдвиге.
Сейчас сдвигаем на что, не понял?
Сдвигаем на P2, судя по всему.
Ну сдвинули, и что?
Нет, ну можно хорошо сказать, что мы можем сдвигать не на P2,
а на P2%P1, да, и что нам это дает?
Ну то есть у нас, допустим, первый элемент сдвинулся на P2...
Стал P2 п...
Нет.
P2 плюс один.
Чего?
А, ну да, и что?
P2 плюс один стал 2P2 плюс один.
2P2 плюс один у нас нет такого.
Ну по-моему, это будет пойти.
Вот, и так далее. Я утверждаю, что это все будут разные индексы.
Но из-за этого еще не следующее пройдут все.
Потому что, может, оно там зациклется.
Почему нельзя использовать линейное представление?
Потому что ты не можешь скакнуть вправо на L, L раз по P1, а потом вправо,
а потом влево там P2 раз, например.
Ну надо.
Ну тут не очень очевидно, почему у тебя там не кончится,
когда надо скакать P1, а тебе не вынудится скакать P1.
Проблема в том, что мы можем в какой-то момент
скакнуть случайно в кресте.
А, нет, стоп, ну с другой стороны,
тогда мы докажем, что первый чувак и певаляется на кресте.
Ну, тут...
Нет.
Ну в принципе, ну и что это даст?
Ну а это не в обмоте, чего у нас не получалось сделать?
У нас не получалось скакнуть от крестика кому-то.
Нет, кому-то мы могли, мы могли в какую-то право.
Нет, ну крестер это символ,
ну как сказать, если мы смотря куда мы скачем.
Чего?
Строка из первых P2 минус одного символа,
конечно, P2 периодично, ну и что?
Э-э-э...
Ща.
Так, щас.
Ну первое, ну ладно,
тут видимо на этом картинке удобнее,
последнее P2 минус один символ, ну конечно.
Так, ну они, да, они видимо P2, да, они конечно P2,
то есть ладно, хорошо,
вот этот, вот этот суффикс,
он точно P2 минус P1 периодично, это да.
Да, почему он P2 минус P1?
Ну, ну здесь суффикс, получи.
Ну, префикс тоже на самом деле не глобально, но вот.
Ну ладно, что важно, что вот мы
получили префикс
длины...
длины P2 минус один.
Так.
И...
теперь у нас есть периодичность P1
и P2 минус P1.
Да, и?
Ну, хочется применить там, сложные бутсы.
Так.
Так, и сказать, ну вот, и сказать, ага.
Ну да.
И сказать, что все эти символы...
Ага.
Так.
Ага, то есть предположение индукции, да.
Ну, значит, хорошо, давайте попробуем, значит.
Суффикс у нас P2 минус P1 периодичен,
так, а также этот суффикс еще и P1
периодичен.
Длина, длина этой...
Ну вот, ну рассмотрим вот строку длины
P1 плюс P2 минус P1, рассмотрим ее суффикс.
Утверждение, этот суффикс
P1 периодичен, ну понятно, да.
А еще утверждает, что он P2 минус P1 периодичен.
Потому что вот это вот рассуждение
для любых двух символов в этой части
прекрасно прокатывает.
Ага.
Ну...
Да.
И префикс тоже по 2 минус 1 периодичен?
Ну префикс там даже уже не принципиальным,
что дальше рассуждение звучит так.
Итак, у нас внутри...
У этой строки есть 2 периода,
тоже HCD их равно 1,
и длина этой строки равна сумме этих периодов минус 1.
Вот, следует, можно предположить,
то есть можно взять некое предположение индукции
и сказать, что из этого следует,
что все эти символы равны.
А дальше все просто,
что если эти все символы равны,
то очевидно, что все вот эти символы
тоже им равны,
просто равны тому же самому символу.
Ну вот.
Ну вот.
Ну да, то есть выводится по сути...
Ладно, давай так не будем бежать, да.
Пока для нода получается доказали.
Ну вот.
Но, соответственно...
А вот даже интересно,
а если у вас известно,
что нод P1 плюс P2 равно 1,
и у вас оказалось все-таки,
что длина строки P1 плюс P2 минус 2?
Ну это...
Что-то мне тут хочется спросить,
можно ли его обобщить,
может это конкретные свойства чисел 5 и 6?
В смысле, дописываете влево буквы,
а вправо буквы А,
а по центру В?
Даже не дописывайте.
Нет, ну хорошо,
а если я возьму не 5 и 6,
я не знаю, 4 и 9,
то что я тогда сделаю?
Зачем брать 4 и 9?
Ну для того, чтобы посмотреть,
существует ли строка длины 4 плюс 9 минус 2,
то есть 11,
которое 4 периодично, 9 периодично,
но состоит не из одного символа.
В плане, вы хотите...
Для любой пары P1, P2.
С таким нодом, да, подумать вообще, да.
Ну нужно просто несколько раз расставить.
Ну, можно проверить.
Нет, ну такой-то, например, уже понятно, не работает.
Нет, но работает, если...
А, размножить букву В.
Да-да-да.
Надо на каждую позицию букву В ставить.
Да, но тогда у нас проблемы.
Нет, тогда все нормально.
Так, хорошо, конкретно здесь проблем нет, согласен.
Мне кажется, вообще не будет,
потому что у нас обязана...
У нас строка кончается после последней буквы В.
Больший строк кончается после последней буквы В.
Ммм...
Вот.
А количество букв А, которые к ней можно написать,
это в точности период минус 1.
Меньший.
Ммм...
Сейчас, погодите.
Так, сейчас вот тут.
Ну точнее, ну я немножко с конца сказал,
ну короче, если мы возьмем период P1,
запишем его несколько раз.
Да, запишем его несколько раз.
Ну ладно, до 4.7 это, наверное, не будет работать.
А ну-ка, давайте смотри.
Ну давайте посмотрим.
Вот P1, P1, P1.
Давайте вот посмотрим.
До 4.7 не будет.
Вот.
Так, до 4.7 не будет?
Не будет.
Да?
А что там будет?
Ну да.
Потому что тут 7 можно вычесть, к сожалению, да.
Ну ладно, тут, видимо, тогда особо не покопаешься.
Ну то есть, на самом деле, просто действительно.
Лемма, конечно, нам потребуется в таком виде.
На самом деле, как уже кто-то заметил, можно ее доказать вот в таком виде.
Почему?
Ну потому что, смотрите, если нот P1, P2 равен 1,
мы это только что сделали.
Вот.
А если нот равен чему-то нетривиальному,
то заметим, что эти периоды говорят нам,
ну допустим, там оба этих периода делятся на 57, да?
Тогда, в принципе, это означает, что строку можно разбить там на блоке по 57
и, по большому счету, сравниваются между собой только символы
с индексами одинаковыми по модулю 57.
И тогда просто по каждому остатку, по большому счету,
мы вытеркиваем соответствующие символы
и сводим задачу к ноду, равному 1.
Так, то есть мы доказали для P1 плюс 2, плюс P2 минус 1?
По сути, да.
Ну короче, нужно будет иметь доказыватель для суммы.
Ну да, тут суть такая, то есть возьмем там,
если они оба делятся там на 57, то как бы давайте найдем там, допустим,
каждый 57 символ, начиная с какого-то,
и по сути нам надо доказать, что теория ему, что если соответствующая строка
там P1 делится 57 периодично,
P2 делится 57 периодично,
то она будет периодично и с периодом P1 делится 57,
плюс P2 делится 57, минус 1.
Вот, но если мы как бы для каждой из 57 строк это аккуратненько доказываем
и в результате у нас получилось хорошо.
На самом деле так.
Вот.
Так что вот такая вот красивая лемма.
Сейчас, а есть лемма, что если еще вычислить, то плохо.
Ну вот, а вот такой леммы вот, да, с лед пока мне доказать не удалось,
у меня в кармане она не лежит.
Потому что как выясняется, да, бывает плохо, бывает нормально,
там видимо всякое бывает.
Хотя вот интересно, да, 47,
то есть 4 там,
нет, ну тут смотрите, на самом деле, то есть для 47 конечно делается так,
по большому счету.
Вот вложили были 9 этих,
а давайте просто соединим ребрами те, кто должен быть равен.
Вот 4, вот эти вот равны.
Вот как-то вот так, да.
И теперь еще давайте ведем 3 семерочки.
Так, ведем 3 семерочки, как мы их ведем?
Значит их ведем мы вот так вот, и вот так вот.
Остается только выяснить, является ли этот жрав связанным.
Ответ, не является. Почему?
Потому что вот эти два символа, к этим двум символам на расстоянии 4,
семерка неприменима от слова никак.
Ну вывод, ну означает, что пример можно привести какой-нибудь вот,
а, а, б, а, а, б, а, а.
Нет, это я написал, но это не имеет длину.
То есть это означает, что это имеет длину 4 плюс 7,
минус 2, 9.
Нет, на самом деле можно действительно задуматься еще,
задуматься еще вот о чем.
Смотрите, знаете, как можно мыслить?
Вот если мыслить вот в этой графовой терминологии.
Так, что? В чем вопрос?
То есть на самом деле, если у вас тут P1 плюс P2,
то на самом деле еще вот вопрос.
Мы можем соединить ребрами два равных символа,
сидит на расстоянии P1 или P2.
Внимание, вопрос.
А сколько ребер мы вообще проведем?
Ну, очевидно.
То есть заметим, что если у нас длина строки равна,
допустим, L, и она больше либо равна подлине,
чем максимум из P1, P2.
Ну, наверное, понятно, что меньшей длины
мы вряд ли будем рассматривать строки.
Тогда сколько ребер мы тогда проведем?
Тогда ребер по P1 мы проведем ровно, получается, L минус P1.
А вторых, ребер мы проведем L минус P2.
Логично, да?
Теперь проверяем.
Пусть у нас...
Итак, смотрите.
И тогда можно было сказать,
пусть у нас L оказалось меньше либо равно...
Ну, вот.
Теперь пусть у нас L меньше либо равно,
чем P1 плюс P2 минус 2.
Тогда у нас получается...
Вот эта вот штука,
тогда получается какая?
Тогда мы тут...
P1 плюс P2 минус 2,
плюс P1 плюс P2 минус 2,
минус P1 минус P2,
шлеп, шлеп, шлеп, шлеп.
И это равно получается P1 плюс P2,
минус даже 4.
То есть это означает, что мы провели
очень мало ребер.
То есть это означает, что
граф заведом...
То есть граф на...
Ну вот.
Нет, ну нам одного ребра...
Чего?
Ну почему?
Ну да, по большому счету да.
То есть если у нас L равно вот этому,
то в принципе да.
Из этого автоматически следует,
что действительно нам получается,
этот граф заведом и не может быть связан,
и это получается, что предъявить строку
и два различных символа
вполне можно всегда.
То есть более того...
Нет, если P1, P2 небольшие,
то вы в явном виде строите граф,
запускаете DFS и все.
То есть более того, знаете там...
То есть там же...
Ну вот.
То есть...
Ну да.
То есть я вам больше скажу,
это на самом деле так можно...
Вот есть задача,
или...
Или...
Или есть... Нет.
Или на самом деле вот знаете,
вот есть классическая задача,
дана Z функция.
Да.
Нет, смотрите.
Ну вот.
Либо дана Z функция, либо дана
префикс функция.
И вам говорят, скажите, пожалуйста,
существует ли строчка,
в которой префикс функция вот такая?
Нет.
Ну, можно ограничить.
Ну, сейчас давайте для простоты
предположим, что неограниченный.
Тогда задача звучит так.
То есть пусть он неограниченный.
Тогда как решается такая задача?
Запускаем для этой виртуальной строки
алгоритм поиска префикс функции.
Для того, чтобы он сработал
ровно в том виде,
чтобы этот алгоритм нашел именно такую
префикс функцию, вы воображаете себе,
что он сравнивает какие-то символы
вот эти, вот такие-то пары символов должны быть равны,
а вот такие-то пары символов должны быть
неравны. Правда?
Вот. И тогда, по сути,
ну вот, то есть вы там получается
строите граф равенств, что в Z функции,
что в префикс функции, и он
тогда говорит, то есть если
тогда сжимаете компоненты связности, выяснилось,
что там два символа из одной компоненты
связности должны быть неравны, значит, поздравляю,
вы пофейлились.
А если нет и размер алфавита у вас
неограниченный, то, собственно,
тогда вы просто там каждую компоненту своим символом
рисуете, и вот он, строчка.
Вот. Понятно, да?
Ну, конечно, если у вас размер алфавита равно 2,
то эта задача становится тоже достаточно простой,
потому что тогда у вас после сжатия
получается граф, и вам нужно просто выяснить,
является ли этот граф двудольным.
Ну, потому что, когда вы сжимаете компоненты
связности по равным символам, остаются
еще требования, что какие-то символы должны быть неравны.
То есть у вас есть требования,
что какие-то компоненты неравны,
и возникает вопрос, можно ли их покрасить в два цвета
так, чтобы любое неравенство соединяло
две разные компоненты.
Ну, таким алгоритмом не умеем,
потому что можно ли покрасить граф
в три цвета, это, к сожалению,
задача непополная.
Да.
Вот.
По-моему, для трех цветов она чуть меньше,
чем непополная.
Нет, по-моему,
в явном виде непополная.
Более того, и два линии через нее
непополнота остальных и доказывается.
Мне казалось, что, типа, если красить
больше, чем в три цвета, то прям непополная.
Нет, нет, нет.
Нет, нет, нет.
Нет, нет, нет.
Не могу сейчас, конечно, перевоспроизвести
все доказательства со всеми определениями,
но как бы классическая непополная задача является
именно задача про
покраску графа в три цвета.
Вот.
То есть, в принципе, построить, скажем, строчку
и префикс функ
вот таким вот образом нехитрым.
Вот.
Соответственно.
Ну вот.
Чего?
Ну вот. Так что вот такая красота.
Значит,
что у нас тогда еще?
Вот. То есть, получается, что
если у нас тут, действительно, P1 плюс P2
и минус 2, то, получается, ребер тупо не хватает,
граф не связан.
А если P1 плюс P2 и минус P1,
тогда граф, как раз, становится
адекватно связан, двойчики добегают.
И после этого, тогда мы выясняем,
что... То есть,
не граф связан, а количество ребер
адекватное.
Потому что, в принципе, может, там просто произошел
какой-то хороший цикл.
Ну, с другой стороны, там, видимо,
возможно, достаточно легко показать, что никакого цикла
там быть не может.
Потому что цикл может состоять только из
P2 ребер длинный P1
и P1 ребер длинный P2, потому что у нас тут вот
диафантовое уравнение.
Но, на самом деле, можно это не обсуждать,
а можно без этого просто аккуратненько доказать,
как мы сделали.
Вот. Так что вот такой вот
интересный момент.
Вот.
Вот. Но, на самом деле, более того,
бывает, на самом деле, еще более
красивый момент, конечно.
Сейчас вот, жалко, мне так с лету
сложно вспомнить задачу на это. Но, на самом деле,
из вот этой леммы,
с нод...
То есть, там, бывает с нод периодичностью.
На самом деле, можно сделать
еще маленький приятный вывод.
То есть, идея такая. Предположим, что у вас есть строчка
и вы скачете по префикс функции.
Спрашивается,
какие числа вы там увидите?
Но они убывают
или возвращаются? Нет, они постоянно
убывают, да. То есть, вы можете из каждой
чиселки скакать, скакать, скакать,
скакать, скакать, скакать. Но фишка
в другом. Я утверждаю, что это не просто
рандомная убывающая последовательность,
а я утверждаю, что это будет
на самом деле последовательность
не более чем логарифма арифметических
прогрессий.
Может быть, кто-нибудь из вас сейчас задачу
вспомнит, но я сейчас сформулирую еще
одну леммочку.
Может, она не сильно нам поможет, конечно, в нашем
алгоритме, но это одна из причин,
в которой я люблю рассказывать этот алгоритм, потому что
попутно вот такие крутые вещи появляются,
которые пригодятся
везде.
Мистическое утверждение такое,
пусть
s равно, допустим,
от 1 до n,
и x равен
ну, допустим,
n минус
префикс функция
от n.
Чего?
Префикс функция.
Ну, стандартное обозначение префикс функции буквой p.
Да, или что
то же самое, кстати, на самом деле
вот это x еще можно заметить, что вот это число
это минимальный период
строки f.
Ну, пока просто
халявные утверждения.
Пусть
значит, x меньше
модуль s.
Тогда, очевидно,
тогда как бы очевидно, что
значит у нас
строка x и x периодично,
тогда и только тогда,
когда s от
x плюс 1 пум-пум n
равно s от
1 пум-пум n минус x.
Вот.
Ну, ничего.
Такие вещи можно еще
приупомянуть.
Так вот.
Но я просто из этого хочу сейчас могу
и хочу немножко другое вывести.
Что такое p от n?
Префикс функция
в n символе.
Вот.
Тогда я утверждаю,
то есть из этого следует, что
минимальное такое число x,
ровно вот этой штуке.
Ну, да.
Логично, да?
Но утверждение мое не в это.
Это просто типа пока вроде должна быть простая вещь.
Так вот.
Мне хочется, конечно, вывести немножко другое.
Ну, короче, да. Три раскраски тоже.
Значит, пусть
тогда я хочу сказать,
пусть x меньше,
чем
то меньше либо равно, чем
нечто. Вот сейчас подумаем,
чего.
Тогда
тогда я утверждаю,
тогда я утверждаю,
что
p от
n
равно
да, вот тут, смотрите,
тут мы можем написать, что
p от n равно n-x.
Да?
Ну, то есть вот это вот и вот это,
это одно и то же, да?
Тогда я утверждаю, что p от p от
это, то есть пока x, если x достаточно
маленькая, то я могу жестко
гарантировать, что p от p равно
n-2x.
Вот такое
я неожиданно утверждаю.
То есть оно тоже,
то есть как бы следующее, то есть в принципе
из этого следует так, что пока
строчка s не станет достаточно маленькой,
это p будет уменьшать
длину на x,
x, x, x, x, x.
Наоборот. Да?
Ну, на x, на x, на x, на x, на x, ну да.
Что такое x? Ой, нет, сейчас,
я имею ввиду.
Ну,
так p это требует
скунуть, а? Да.
Ну, утверждаю.
Ой, сейчас.
У нас есть
есть вот у нас есть
строчка s,
в нем в ней
p от n символов.
Первые совпадают с p от n последнего.
Б-б-б-б-б.
Если x уменьшили одну,
n пополам.
Да. Ну, к сожалению,
на p пополам, там можно,
там не прокатить, может.
Нет, там
нет их смешали бы ровно и пополам это не многовато вот потому что не сейчас
многовато у нас если x меньше чем это пополам то с это хотя бы 3 таких вот x откусим от конца один из них
все еще будет хотя бы 2
сейчас нет ну породите вот тут вот давайте аккуратненько доказывать а ты хорошо допустим
то есть допустим мы пытаемся тут написать n пополам так то есть это означает что у нас
что минус 1 ну пожалуйста хорошо прям что прям строго меньше но хорошо строго
меньше это пополам хорошо так и что это нам дает да кто сказал нет это никто не сказал потому что
может быть что это x x и еще чуть-чуть 3 x никто не обещал
получается так да минимальный да то есть по большому счету вот это утверждение будет
означать следующее что строки длины n-x минимальный период тоже x
чего
но но да но давайте так давайте давайте возьмем x прям очень-очень маленьким давайте вот давайте
убедимся в том что как бы это верно если x прям очень-очень маленький чего да да совсем
на 10 на 100 неважно то есть давайте выяснилось что вот у нас вот этот маленький бедный x и оказалось
что вот это вот равно вот этому вот да видно да но если x прям очень маленький да то есть заметил
что вся эта строка x периодичной как следствие вот эта строка тоже x периодичной то есть это
означает что но вот то есть на но но но теперь вы скажете хорошо x период этой строки давай
сейчас чего где справа слева что слева что какая разница
начала строки у вас слева начала конечно слева но строка x да ну да нет ну как бы и ладно перейдем
ну хорошо там да он конечно не является периодом то есть вот эта строка не является периодом строки
в том смысле в котором мы с вами говорили конечно вначале ну x ну x маленький строка
большая но вот эта строка без x ровно вот этой строке без x я имел ввиду x периодично
слева то есть
а почему x потому что мы все так ну потому что x это число не строка
ну да то есть я как бы могу сказать что как бы раз строка x периодична строка она так вот вот
это с точка такая же тут копии копии копии копии копии тут какой а это уже неважно нет причем
где голем это вот вот это строка x периодично это сомнений не вызывает сейчас потому что любые
два символа на расстоянии x внутри нее совпадают
как у нас вот так
я просто понимаю почему вы с конца то надо выйти но мне так удобно
ну вообще ну вообще говорят да конечно но правда если x достаточно маленький то как бы там скорее
всего это то есть просто это хотя но это да ну то есть да если если рассматривать период как
строчку туда этот суффикс длины x он как скорее циклический сдвиг периода это да но здесь удобно
мыслить что x период это смысле x число так что вот хорошо то есть вот эта строка x периодично
тут вроде сомнений нет все что нам теперь то есть это означает что в ней кандидат на префикс
функцию это то есть раз вот длина вот длина вот этой статьи это вот n-6 тогда получается что
n-2 x это кандидат на ее префикс функции да да именно поэтому да теперь выскакать вопрос
а почему у нее не может быть большей префикс функции а кто сказал что он делится никто это
вообще не сказал n delete x не обязана а какая нам разница но
мы говорим что первые
но если x минимальный период формально говоря то есть я так сказал x это то есть строка x
периодично тогда и только тогда когда n-6 кандидат на префикс функции вот так скажем
но вот и x минимальный минимальный такой что строка x периодично тогда и только
тогда когда n-6 это максимальный среди кандидатов на префикс функции то есть
собственно сама префикс функции так не умирать я не понимаю как все можно осознать все понятно
нету что именно я не знаю ну мы пока мы говорим в процессе но дальше мы говорим так пусть у
нас x прям совсем совсем совсем мало потом наша задача будет подогнать там насколько оно должно
быть мало чтобы наши рассуждения прокатывала но пусть и прям очень мало тогда мы говорим
следующее что строка мы знаем что строка x периодично тогда это означает что вот этот
префикс длины n-6 он тоже x периодичен отсюда следует что n-2 x это кандидат на префикс
функцию вот в точке n-6 логично да то есть следовательно вот в этом месте больше либо равно можно
остается только один вопрос а почему не может быть действительно строго больше почему тут не
может оказаться какой-нибудь там n-6 минус и как почему здесь не может оказаться какого-нибудь
более мелкого периода игрок который меньше икс но вот но сейчас прийдет то есть если у нас
все совсем маленько это тогда заметим следующее что если тут есть какой-то период игрок то
утверждается что это строке игрок период не только вот этого префикса но и всей строки
вот почему потому что как бы игрок это тогда период вот этой строки и вот этой строки а
тогда получается но тут основная идея что так как игрок лежит внутри прям целиком внутри
пересечения то получается что игрок и то тогда получается что вся строка игрок периодично
я не понимаю почему у вас нормально склеиваются если игрок не делит если длина игрок не делит
длину строки ну вот мне очень сложно понять какое вот какая у тебя но какая у тебя идея внутри
прям так упирает тебя в это деление но в плане если y не является делителем длины вот этой длины
n-6 ну и что тогда мы когда пойдем справа отчитываясь не состыкуемся с тем что мы
слева отчитывали что вот что означает словосочетание не состыкуемся с тем что мы отчитывали слева но не
состыкуемся так так бы тут тут как бы да идет идет идет идет идет и да вот тут какая-то
частичка будет да вот здесь пересечения тоже мы знаем что следующий игрок символов строке вот
если мы направо пойдем ну пойдем еще следующий игрок символ нас совпадает потому что у нас
ну и что ну я утверждаю что не совпадают почему потому что раз это строка игр периодично то и
это строка игр периодично потому что они тупо они тупо равны следовательно вот эти игр символов
равны вот этим игр символом вот сейчас но тогда получается сейчас тогда они получаются не
ровные почему или вы утверждаете что если игре чем-нибудь период но да нет просто да да нет
но то уже не причем это уже не важно нет уже не важно вау потому что важно уже на уровне что-то
игр как это период всей строке s а тогда это означает что у нас неправильно посчитан на префикс
функция для всей строки я скажу почему важно у нас у нас первые самые первые вот самые последние
y символов строке x если мы игрек мне если мы вот этот вот остаток длины x если вот это
значит остаток длины x не делится на y то что а то получится что у нас первые игрек символов
вот это вот левые строки на они не совпадают с первыми они не совпадают первыми игрек символов
той же самой строки вот этой двинтой которая правая еще противоречит ну что ну из этого
ну и следователь может следует что там ну может там следует что там еще у них какой-то период
то есть мы на самом деле доказали что что игрек обязан быть ну да не обе нет да господи это уже
все равно уже перемасло масляные уже там есть потому что мы уже сказали что как бы игрек является
периодом всей строки с это уже противоречие с тем что минимальным таким периодом был x все уже
мы пофейли я же правильно понимаю что тогда у нас есть в том числе период который является
делителя который является делителем но там нету можно и так сказать да что если у тебя есть два
периода и они достаточно мелкие например там меньше чем и пополам то как бы есть перед то
тогда у строки есть период который является их нодом да это правда ну вот так теперь
есть какой-то вопрос насколько маленьким должен быть их чтобы это рассуждение про канала
ну что хотя бы это рассуждение про канала может быть есть более сильные я не знаю
ну у нас тонкий тонкий момент был на самом деле как вы доказывали что игрок период не только
вот этой строки но и соответственно вот этой но и всей строке мы этим мы на самом деле если
внимательно посмотреть только а как бы вывели что игрок это период всей строки на самом деле
Мы воспользовались тем, что этот Y целиком попадает в пересечение.
Если вот этот какой-то период Y попадал внутрь пересечения,
тогда мы его как бы влево можем внутри этой строки размножить, то есть раскопировать.
И внутри этой строки раскопировать вправо.
Отсюда исследуют, что строка полностью играет периодично.
А если не впадал, то что?
Ну тогда не очень понятно.
Но тогда может оказаться, что есть какие-то два символа на расстоянии Y.
Один из которых находится здесь, а другой здесь.
И почему они между собой равны?
Непонятно от слова совсем.
Поэтому желательно чтобы игры были здесь, но и желательно чтобы X тоже должен быть здесь.
Поэтому мы здесь для надежности пишем N поделить на 3.
Вот, но в принципе это уже достаточно мощно.
То есть что это в принципе означает?
Это означает, что если вы будете из точки N скакать по префикс-функции,
то вы говорите, что на первом шаге у вас префикс-функция уменьшила N на X.
Тогда утверждается, что у вас будет арифметическая прогрессия шагом X как минимум до тех пор,
пока вы не дойдете до числа меньше чем 3X.
И только там может быть у вас шаг поменьше, там станет поменьше.
Вот такая вот неожиданная идея.
В данном случае это нам нужно было чтобы рассмотреть интересную идею,
которая в некоторых задачах на строчке неожиданно проявляется.
Что когда вы скачете по префикс-функциям, то на самом деле получается выйти с крышки,
а потом вы скачете по префикс-функциям, а потом вы скачете по префикс-функциям.
Неожиданно проявляется, что когда вы скачете по префикс-функциям,
то на самом деле получается выйти с последовательности от N до 0,
можете разбить на несколько арифметических прогрессий.
И даже не просто несколько, а их не более чем O от логарифма.
Каждый следующий делитель X.
Каждый следующий делитель.
Нет, ну если X мелкий, конечно.
Но там...
После первого, например, шага, когда X стал меньше, чем N3.
Нет.
Следующего будет делителем предыдущего, так?
Ты знаешь, нет, это не факт.
Потому что бывает, например, строчка A, A, A, там какая-нибудь, там A, A,
сейчас как-то тут вот можно...
Нет или нет? Нет, ну...
Хотя да, если X в какой-то момент был длиной меньше, хотя нет.
Ну, может это неправда, но откуда тогда берется логарифм?
Логарифм берется оттуда.
Что для того, чтобы X перестал быть меньше либо равно N3,
вы должны поскакать таким образом, чтобы A, у вас длина строки уменьшилась хотя бы в полтора раза.
Нет?
Хотя ладно, ну давай так.
Изначально мог быть очень большой.
Изначально мог быть очень большой.
Сейчас.
Нет, ну как очень большой?
орошо
Да, тогда замечаем, что то к X ты будешь...
ты будешь ну вот но вот тогда сколько ты будешь скакать по иксу но вот ну вот то есть ну то есть
шаг вот то есть пока у нас тут да пока мы тут не дойдем до точки когда он меньше чем 3x то есть
но вот мы ждем когда пока икс меньше чем на 3 но да нет но да сейчас
нет ну типа того да нет ну не совсем нет но там может так случиться что если уже икс стал больше
то есть икс стал больше чем вот это строка на 3 то икс мог уже и поменяться он мог неожиданно
уменьшится сейчас ну давайте допилим да так нет ну просто скажи сейчас скоро но скажем так
сколько то скачков мы сделали да сколько то скачков мы сделали нету если не были прям очень
маленькими то понятно что там видимо длина строки уже во сколько-то раз доуменьшилось
но если икс был ну давай давай ну давай так если смотри давай так если икс было меньше
либо ровно чем n на 6 то тогда получается наши скачки видимо там хотя бы у вас скачки хотя
видимо хотя бы половину строки да съели да да то есть если икс меньше либо ровно
нделит на 6 то значит в два раза уменьшили а если он больше то на каждом шаге мы уменьшаем в 6
пятых раз да так что лога это логарифом получается хоть не потому оснований потому хотелось бы но
суть такая но тем более что как бы это мы еще там то есть может быть на самом деле эту лему как-то
может чуть-чуть усилить вот но такая вот идея есть здесь периодически она нет нет да и проявляется
вот так ну что сколько там времени то вообще ой ой ой так ну хорошо так ну ладно это просто
по времени нам вроде пришло время тоже немножко перерывы сделать или не пришло
а то я нет нет судя по вам пришло так что тогда я конечно не ожидал что это вам на столько взорвет
мозг потому что мне это не казалось прям сложными вещами но но видимо видимо вы с ними там совсем не
сталкивались нет ну мы с ними сталкивались сколько угодно раз но они все равно интенсивно абсолютно
да странно нет страны этом запросто на то что она в сервисе там дают задачи где вам вот это надо
либо знать либо знать либо придумать но на все все бывают задачи на строчке где вот подобные там
ну да ну вы же ну вы же крутой вы же не так есть подозрение что вы вы возможно это не совсем те
люди которые там зацепили последнего призера и ушли но последний повидло до нету обычно это
уже уровень где как бы вроде как бы там уже надо какие-то очень не тривиальные группы уже на
все если надо брать можно брать не тривиальные группы на всех темах которых ты селёшь ну так
смотри какие темы дадут вон на последнем серии был скандал что вам там надо что-то что там
для детей закидали конструктивами чего ну тебе кайфа кому-то вот кто-то наоборот взвыл я целый
день я там многие годы ходил учил там все эти модификации деревья потреска в дикарте к и так
далее она выяснила что я должен знать только дфс и уметь думать про то зачем я учился столк
да нет вот вот поэтому я поржал когда я буквально такой комментарий прочитал на
крутфорсе поиск идеи один раз ну хотя ну я не знаю нет ну как по мне я не знаю то есть
думать когда-то на липяде дают задачи в которые надо думать и придумать что какую-то новую идею не
пользоваться старыми это нормально ну окей так давайте перерыв нет поэтому это с чего мы
начали функция является функцией от же если да можно так сказать что мы с этого вообще начали
да ну ляма периодичности важна дальнейшее утверждение нет это скорее просто ответвление
которое просто хотелось тоже обсудить значит смотрите значит просто из леммы о периодичности
но это просто такое общие там общие такое очень важное утверждение действительно про историю
строк на самом деле из этой леммы есть маленькое приятное следствие значит следствие из леммы
периодичности но вот но вот я его сформулирую так или не сформулирую различные префиксные периоды
строки с различаются не менее чем в к-1 раз да где карта 4 да возвращаемся в этот
сладостный чарующий упоительный мир где кара вну 4 есть понятие префиксный период так что
давайте вспоминаем так что давайте аккуратненько вспоминаем что такое префиксный период так все
сразу все ушел да так давайте так давайте да сначала вспомним еще что такое префиксный
период значит мы говорим что у нас строка что там какая-то строка длины п1 префикс является
префиксным периодом если тут если она тут если у нее строка я начинается с в нашем случае
четырех экземпляров этой строки ну в смысле к и при этом еще важно что этот префикс базовый что
такое базовая строка но напоминаю строка это базовый если ее нельзя распилить на несколько
копий одного и того же причем на этот раз четких копий без там всяких лишних остатков да то есть
мы помним да что для того чтобы строка была п периодично не обязательно чтобы длина делилась
на п то есть она то есть это то есть строка п периодично это означает что строку можно распилить
на кусочек на одинаковые кусочки по п и мелкий кусочек в конце который является префиксом
этого кусочка да вот по большому счету так но мы говорим что строка не является базовой когда
ее можно распилить на кусочки без на одинаковые кусочки без этого лишнего остатка вот ну как бы
если не буду переписывать формальное определение да оно у вас и так записано уже так вот и вот
у нас ключевую роль играет понятие префиксный период и мы говорим что эти префиксные периоды
различаются не менее чем в к-1 раз ну подлине естественно то есть другими словами что если
у вас есть префиксные периоды п-1 и п-2 причем п-1 меньше п-2 то это будет означать что ну вот
то есть это будет означать что п-2 больше либо равно чем п-1 умножить на к-1 это нам будет как-то
помогать но прежде чем нам будет помогать а давайте поймем а почему вообще это так
и казалось бы причем тут лема а периодичность
ну давайте посмотрим допустим значит давайте как всегда как у нас говорят на латыни ато абсурда
значит пусть у нас оказалось что п-1 меньше п-2 но п-2 при этом меньше либо равно чем к-1
п-1 что это означает означает следующее что жил был п-2 вот он маленькую строчку нарисовал
вот но нам там да что там в конце нас вообще не интересует нас интересует вот эти четыре
копии п-2 ну типа предположим что вот так не отрицание хорошо хорошо можно пожалуйста пожалуйста
ага именно так значит смотрите сейчас давайте включаем логику значит предположим выяснилось
что п-2 меньше либо равно чем к-1 п-1 что это в принципе означает то есть значит то есть это
означает в принципе что п-2 но вот что в 3 копии п-1 п-2 точно уложится то есть это вот будет
выглядеть примерно то есть вот п-1 будет выглядеть примерно вот так вот
п-2 укладывается вот такое ну в принципе из этого следует что четыре копии п-1 прекрасно
уложится в две копии п-2 правда что нет да нет у вас могло быть п-2 меньше чем 2 п-1
чего п-2 не могло быть меньше чем п-1 сейчас п-2 меньше чем 2 п-1 а
ну хорошо да это мог так это могло быть так но только только это из цикличи и
шо это нам даст вот нет ну по большому счету нас ну по большому счету ладно для нас это
интересует следующее то есть это то есть там нас это интересует в принципе таким образом то
есть смотрите это 3 давай так три копии п-1 укладываются в две копии п-2 правда
тоже не факт почему что нас по два может быть меньше чем полтора по один
никакого ограничения снизу нет может быть по два это по один плюс один нет так ну хорошо ладно
хорошо ладно п-2 укладывается в три копии п-1 это точно верно да ну вот
отлично но тогда это но вот но тогда можем ли мы из этого сделать вывод можем ли мы из
этого тогда сделать вывод что тогда получается 4 но хотя делаем ли мы из этого вывод так
так сейчас вот как нам ну понятно то есть идея в общем понятно хочется конечно сказать что вот
это вот вся строчка она конечно и п-2 периодичный п-1 периодично ну ну тогда доказательство будет
но тогда будет доказательство работать так же если мы докажем что это строка п-1 периодично то
тогда она получится п-1 периодично п-2 периодично а как следствие она гцд от п-1 и п-2 периодично
причем это гцд меньше чем п-2 и мы как следствие получим противоречие с тем что п-2 базовая
вот то есть вот в чем тут возникнет идея да мы доказываем следствие да мы очень хотим доказать
что действительно из вот энот то есть очень хочется сказать что действительно вот у нас
вся вот эта строка она п-1 периодично ну или хотя бы ну то есть по большому счету нет нам
но нам достаточно доказать на самом деле что префикс длины п-2 плюс п-1 точно п-1 периодический
нам на самом деле этого достаточно доказать спрашивается почему это ну вот ну тут идея
такая 4 п-1 ки они то есть вот это то есть 4 п-1 ки но вот ну тут да тут конечно видимо я
не вот но тут действительно идея такая что п-2 укладывается в 3 п-1 ки да то есть значит вот
это вот строка то есть вот эта строка она как бы получается п-1 периодично и п-2 периодично да
сейчас топ что происходит а мы говорим что у нас префикс п-2 а по два сейчас по два так это
префиксные периоды значит у нас картинка выглядит ровно так ну поводлю того что там
п-1 может конечно быть подлиннее да но вот этот ну вот это вот а теперь припишем вот сюда еще
вот эти п-1 символов заметим что но вот что строка останется п-1 периодичной да то есть да то есть
вот это вот строка она п-1 периодично и п-2 периодично а еще вот это вот длина она больше
либо равна чем п-1 плюс п-2 вывод то есть отсюда следует что вот эта вот строка то есть вот эта
строка она нод п-1 п-2 периодично как мы выяснили да но тогда отсюда следует что вот эта строка вот
она получается нод п-1 п-2 периодично только маленькая проблема внимание то есть у нас
есть строка п-2 и у нее есть период который меньше п-2 меньше ну потому что п-1 меньше
п-2 и этот нод и причем это строка п-2 делится на этот период да следовательно мы получаем
противоречие с тем что п-2 базовая ну да то есть мы то есть мы рассмотрели префикс длины 4 п-1
да мы показали две вещи во-первых это строка п-1 периодично и п-2 периодично но очевидно
потому что это префиксы а во-вторых заметили что 4 к п-1 это ну то есть мы заметили что вот давайте
я допишу к п-1 это больше чем п-1 плюс п-2 больше либо равно почему потому что у нас
п-2 более меньше либо равно как минус 1 п-1 и вот следовательно получается что вся вот эта
строка имеет периоды и п-2 и п-1 и она достаточно длинная тогда получается что вся эта строка
имеет период гцд от п-1 п-2 то есть получается и префикс длины п-2 тоже имеет такой период но
этот период является делителем п-2 и меньше п-2 то есть следовательно этот эту строчку можно
распилить на несколько одинаковых кусочек и чем без остатков то есть кстати обратите внимание мы
здесь даже не пользовались тем что по один на самом деле вообще что вот это вот по один это вообще
базовая строка то есть по большому счету мы утверждения могли сформируют так пусть п-1
меньше п-2 пусть п-2 это префиксный период рич от п-1 там больше либо равно чем там 4 п-1 тогда
п-1 он меньше чем п-2 поделить на там к-1 то есть на самом деле можно было даже в таком
более сильном виде это сформирует вот понятно вот ты прям на языке интегралов от записываешь
о господи о господи ну окей ну нет ну смотри конечно я не особо я не особо верю что это
можно воспринять и там параллельно с дз но а но это да ну хорошо ладно ну в принципе да ладно
если все понял 15 минут назад то окей донесите хорошо классно а ну да да да нету если тебе
поможет потом это сделать то окей конечно да вот так в общем такая такая вот интересная
лемма которая нам будет помогать так у меня еще или мы есть так хорошо по-фиксу и периоды
поняли но как бы значит смотрите сейчас тут будет таки слюшеке другую другую лему сейчас их будет
ну сейчас хуже сейчас еще одно понятие введу значит еще одно понятие было нету как было я по
моему еще не обозвал это шифтом хотя ровно такую вещь мы обсудили да то есть по-форошему я должен
сказать что шифт от ку это минимальное то есть минимальное такое число л что префикс длины
л это период префикса длины ку строки с ну потому что сдвиг типа ну типа если сдвинешь строчку на
ку типа там все совпадает будет вот ну видимо они-то так воспринимают и в принципе кажется
интуитивно это логично так вот значит то есть это такой да то есть можно сказать что шифт от
ку это минимальный период префикса длины ку строки с так вот мистическая лемма возможно тупая
ну потому что по фирмировке она какая-то тупая если шифт с от ку меньше либо равен ку поделить
на к то с от 1 шифт с от ку префиксный период а ну ладно тупая но не совсем вот такая вот
нет ну действительно давайте просто вот тут доказательств по сути следует из картинки да
вот он ку и как бы что значит шифт шифт это означает что вот вот это совпадает с вот этим да то есть
вот сдвиг вот на этот вот шифт но в принципе этот сдвиг означает что вот тут вот вот эти вот
шифт шифт шифт вот столько совпадает вот это неравенство означает что как минимум на четыре
копии мы тут наткнемся да ну в смысле на к копии остается только одно потому что для того чтобы
доказать что это префиксный период нужно еще доказать что это строка не является там случайно
то есть она что она является базовой ну да ну вот ну в принципе да заметим что вот этот вот
шифт он обязан быть базовой строчкой он да он обязан быть базовой почему потому что если
ее можно распилить там скажем на три копии ну потому что мне так удобнее рисовать там если их будет
57 суть будет та же вот то тогда мы заметим что мы шифт могли бы сделать на одну из этих копий
видно да прям явно в виде поэтому да кстати да маленькое приятное свойство как бы эти префикс
длины шифт отку заведомо базовая строка да что не может не радовать нет как то делительку вот
этот вот шифт он конечно не обязан быть никаким делителем ку тогда почему когда мы вот эти
маленькими шашками а потому что что такое базовая строка мы говорим что строка не является базовой
если ее можно распилить на строчке так что вот именно перескока перескока через границу не
будет нет нет я имею в виду вот там в конце вот здесь а так а потому что потому что у нас здесь
есть перескок через границу ведь у нас тут кончик поэтому раз тут как бы распил по
середине то и тут мог быть распил по середине непонно какая разница ну что строка все равно от
этого не перестает быть вот столько периодичный ну конечно вот вот так что вроде да не самая
сложная лемма но чуть-чуть почесаться пришлось так сейчас будет такая лемма немножко странного вида
сейчас будет ну вот да значит так вот если оказалось что s от 1 до l это префиксный период
с при фиксный период с то то что то я то тогда эквивалентные следующие утверждения значит
первое утверждение l равно shift значит и не просто равно этот shift ну то есть для какого-то q
получается утверждается следующее что значит l являет то есть это это этот префиксный период
является для кого-то с двигом и этот и более того еще и с вот таким приятным свойством тогда и
только тогда когда к умножить на l меньше либо равно q меньше либо равно reach вот такой вот красота
но то есть утверждается ну то есть там говорит так пусть у нас s 1 l префиксный период с пусть
у нас есть какой-то q да тогда утверден вот и пусть есть какой-то вот q видимо от одного
до модулес тогда вот эти два утверждения верны тогда и только тогда когда верны вот эти два
утверждения да да видимо правильно писать да ну так-то да ну как сказать на самом деле
можно взять его и маленький потому что для q для слишком маленьких q эти утверждения оба
не верны ровно в силу того что слику слишком маленькая так же я бы наверное вот так
сформулировал а впрочем хотя на самом деле если слишком большое тут уже никаких проблем нет
я вообще вот так может заявить вообще для любого натурального кувер на вот это
так ну давайте разбираться в принципе если видимо если адекватно понять что-то такое то
вроде утверждение должно быть почти очевидно так но опять давайте в эту сторону попробуем
вот вправо жил так ну допустим у нас действительно какой-то есть мелкий l да то есть пусть у нас
l оказался совершенно случайно шифтом от q и более того это тель оказался меньше либо
что это в принципе означает тогда если я вот сейчас нарисую эту строчку то у меня получится
примерно следующее вот то как бы тогда что это означает вот жил был q и в принципе если у
него шифтом оказался вот этот l то в принципе вот это неравенство означает 4 копии тут как-нибудь
найдутся вот но тогда это автоматически означает что рич от l то есть это как бы наскоро то есть
максимальная длина префикса которая имеет период и то есть который или периодично она
распространяется как минимум на как минимум на q но это в общем-то здесь очевидно
да то есть вот я вот уже что вот и то есть из этого вот это прям вот очевидно следует
если вот это если сейчас если м равно шифт а
так у нас есть как копии ну каннельмейшли бравнукует понятно да но теперь давайте
просто возьмем это l и сделаем отсюда рич да но тогда он как бы рич дойдет как минимум до q
потому что ну потому что это l это шифт да ну значит получается что рич это отель как минимум q ура то
есть в общем-то да обычно в ту сторону очень-то совсем очевидно в общем тут ничем и то есть
пока формулировка то есть давайте попробуем в обратную сторону так внимание то есть пробуем
в обратную сторону значит неожиданно выяснилось каннель то есть предположим неожиданно выяснилось
что каннель меньше либо равно q но при этом рич отель дотянулся до q и пошел дальше да ну что
мы из этого можем сделать какой мы из этого вывод можем сделать ну да нам не хватает да
то есть фактически ну нет не совсем так нам нужно теперь доказать что по сути что l равно шифт от q
что нет меньшего периода ну по сути да ну то есть конечно l являет то есть это строка заведома
l периодична это l меньше либо равно q делить на к но высказать вопрос а почему бы у q а почему бы
тут не завести какой-нибудь еще меньше шифт да в принципе q больше либо равно к умножить
л это означает что 4 копии эля тут найдется да нужно по сути доказать что шифт от ку равно
шифт откуда как это доказать ну давайте отред предположим выяснилось что есть шифт поменьше
какой-нибудь вот такой вот этот пункт как всегда л штрих так но если тут период но
заметим что так как l это меньше чем q поделить даже на 4 л штрих еще меньше то тогда получается
есть период длины нод от л штриха и понятно да отсюда тогда но этот нод он как бы делитель
l меньше l то есть и опять получается что вот этот префикс длины l не базовая строчка и как
следствие вот противоречие с исходной то есть вы вот такой вот у нас получается такой очень простой
то есть вот то есть такая в excusе yahoo да то есть вот здесь мы наконец
используем что это грей퍼 этих период с Borlear вот то есть получается что на
самом деле да то есть в принципе что это лемма вообще нам на что это лемма нам намекает что в
принципе под достаточно то есть если мы знаем что у нас есть префикс ты период да какую-то что
что вот элит у нас какой-то префиксный период то при достаточно больших ку при достаточно больших
ку мы в принципе можем там можем уже просто shift себе сразу гарантировать мы продолжаем
идти по статье галилла сейферса которая леммы я оттуда взял их оттуда честно переписал и там
но тут как всегда смотрите мы тут просматривали некоторые факты сейчас из этих фактов мы
неожиданно скомпонуем алгоритм ну скажите как они-то придумали я не знаю нет но на самом деле
когда придумываешь алгоритм так всегда получается на самом деле что тебе там пришла в голову какая-то
идея ты ее как-то там допилила потом тебе ты там понял доказательства для себя а потом начал
писать статью но когда-то я стал писать статью выяснилось что просто вот какие-то то есть ты там
в процессе там доказал подобного рода утверждения да но от линии для тебя были из каких-то интуитивных
там соображений они тебе были понятны но тебе пришлось это сформулировать для статьи вот
но тем более что там половина этих утверждений на самом деле бывает из цикла что все их знают что
типа там научное сообщество их в принципе там более-менее знает но кто думал над строчками в
этом направлении они это все в принципе более-менее понимают вот более-менее вопрос но понятно что
специальная статья на тему этих утверждений никто естественно не писал потому что это не того уровня
достижения но соответственно то есть поэтому так то есть это может быть немножко там то есть поэтому
поэтому тут вот как это придумать вот вопрос такой ашки можете повторить как вот слева направо
доказываем что кумин шли б равно чем рич так в смысле вот как вот картинка как бы строка вот
это строка для префиг зеленый кул он эль периодичен ну все из этого уже следует шури ч то есть как бы
рич от эль значит дойдет хотя бы таку нет потому что эль равно шифта тку вот когда мы слева направо
идем еще вот этим утверждением пользуемся ну и что он разве может скушать до рич ничего не требует
на эту тему то есть фактически это так то есть рич от эль это максимальная длина префикса строки
с которая является эль пере который является эль периодичен то есть там определение было
эль плюс z функция здесь она не обязана заканчиваться какой-то позиции делящейся на
эль вот так что вот такая красота а теперь внимание те рема о декомпозиции да вот сейчас мы вообще
как бы да как бы мистическая те рема о декомпозиции
смотрите абсолютно произвольную строку п можно разбить как хочется в этом смысле поставить
точку но вы значит разбить на короче п равно ув где у в не более одного префиксного периода
префиксного периода а длина у это от длины сейчас упадете не шифт но от
мечта да шифт с индексом в от модуль в ну как сказать ну почему иногда наоборот знаете
иногда там ничего не понятно но по фонда по форме на вот знаете такое не видели мультик с
такой песенкой да именно именно да там тоже у вас первая реакция скорее всего тоже будет
и потом да вот а вот так вот значит что тут написано ага то есть давайте возьмем строчку
в и возьмем ее shift так вот утверждается что длина у маленькая то есть маленькая
смысле о от шифта то есть там какая-то константа то есть там ее длина не превосходит этого шифта
умножить какую-то все это всеобщую константу честно пока не помню какую вот то есть вот
такая вот неожиданная заява так вот да тут в этом месте мы сломая нот мы сделаем слом потому
что как всегда в такое время у нас возникает два вопроса как ее доказывать и какого хрена мы
ее вообще написали еще что она значит ну да это вообще нулевой вопрос что она значит вообще
но зарослишь что такое что она значит она значит вот это а все остальное так вопросу зачем она в
таком виде нам нужна чего ну применима себе ну хорошо там видимо скажешь так авторы не
стали тут убиваться формализм но видимо там можно было сформируйте что модуль у не превосходит там
5 шифтов там ну в общем там ну 5 там 10 я не помню сколько но в общем короче там константа есть вот
вот вот в этом плане да в этом смысле да нет мы сейчас пойдем делать мы сейчас как бы мы
значит закончим тем что докажем эту теорию ждем то есть мы берем мы берем да вот мы берем
минимальный период строке в да откуда-то его предварительно узнав вот ну вот то есть на самом
деле алгоритм то есть на самом деле теорема подразумевает конечно но так как мы алгоритм
ищем теорема будет подозревать следующим это разбиение не просто существует а существует
алгоритм с от единицы дополнительной памяти который найдет вот это разбиение и еще и скажет есть ли
префиксный период если дату сколько сейчас ну вот мы найдем вот такое разбиение вот вот утверждается
что вот сейчас мы как бы вот то есть мы сейчас ответим на просьбу чем теорема нужна теперь вот
потому что мы сейчас делаем так да ладно нормальный алгоритм что за уныние сразу вот
значит смотрите то есть то есть идея будет такая что если мы по заданной строке п найдем ну как
бы не случайно по шпонте мы ищем под строку п строке с да если мы найдем если вы строку
п распилим вот на это вот чего какой пси бонус где пси бонус да боже мой прям принципиально ну и
что я вам больше скажу знаете в прошлом году я вам даже скажу в предыдущем поколении был
студент который получил от этом отл 10 без оси pc бонусов написав на отл вот это
по моему кстати насколько помню у александр хоцко взывали кстати с интересно но вот так
что соответственно если возникает вопрос и вот можете его спрашивать он разобрался может
он конечно уже ничего не помнит конечно но но с формулируем так на самом деле да спе с
первого раза взрыв мозга но на самом деле как бы так как бы эти все равно пока возникает
ощущение что в совокупности софт хипа мозгов взрывательнее но на самом деле да ну правда
такие вопросы вызывает но тут нет но тут вопрос кому как то есть может сейчас еще
напишите вы сидите вечером во вторых как бы традиционно до студенты второго курса более
являются более уставшими чем те же самые студенты но на первом курсе может программу
с конца не пробовал но сформулируем так строчки но я уже рассказывать почему я строчки рассказываю
на втором курсе потому что там автомат то есть можно крыша на это забить да нет нет там нет там
просто две идеи первое хочется строки рассказывать единым блоком а во вторых строках есть автомат
который хочется рассказывать когда вы уже там на формалках его там с ним поработали вот то есть
принципе если забить на то что строки должны идти единым образом то конечно да я могу там
вообще в любом порядке рассказывать да я это все могу вам и там нет этого я тоже не могу но там
совсем так нельзя потому что все-таки как бы я должен ввести вас в амортизационный анализ и
асимпотики я как-то должен то есть после этого в принципе да уже можно там развлекаться уже в
любом порядке это да вот так вот так смотреть сейчас я напишу зелененьким ну давайте зелененьким
напишу алгоритм такие внимание мета алгоритм с помощью которого мы будем искать под строк в
строке возможно он вам даже покажется знакомым да я буду писать на псевдокоде в котором есть
кортежики да это кортежик новый шпитон изучали да ну не совсем ну еще сейчас все увидите то есть
у нас будет я сейчас пишу мета алгоритм да почему мета потому что в нем опять будет какая-то одна
маленькая мелочь которую мы но от которой придется допиливать алгоритм вот нет мета это
приставка в русском языке такая но то что она то что там кто-то там случайно ее запретил по каким-то
причинам вот почему ругательный пристава приставка ругательная ну как-то знаете вот значит
смотрите пока у нас п не превосходит т значит идея у нас такая значит ну смысл на самом деле
очень простой смысл у меня будет такой как бы пара п ку в каждый момент времени означает что
под строка текста т от п плюс один до п плюс ку но тут так удобно мыслить это премьер
нот то есть она равна на самом деле вот так то есть глубокий смысл вот такой
но мы ищем под строку п большое в тексте т так вот у меня будет идея такая то есть как бы
п ку это те самые два указателя по сути то есть п указывает перед началом строки а п плюс ку
наконец но как мы ищем но как мы ищем префир как мы ищем под строк в строке там вот была идея
такая что мы значит начинаем находим тут вот максимальный префикс да потом сдвигаем но потом
переходим ну в префикс функции было так потом сдвигаем значит этот указатель так чтобы это
был префикс и теперь вот этот указатель начинаем двигать это у нас была такая идея мы
его попытаемся обобщить я прям но я сейчас код напишу прям полностью да но суть будет
следующее просто на каждом шаре переходить мы будем как-то вот непонятно как то есть каждое
то есть ну то есть понятно что мы у нас будет п ку то есть вот сейчас первое что я сейчас
делаю это у меня вайликом я буду увеличивать ку пока могу вот прям в тупую вот ты там найду
вот это а потом после этого я п ку куда-то сдвину то есть на п штрих который будет
больше чем п и на какой-то ку штрих ну короче давайте сейчас пишем видимо я уже код напишу и
просто уже понятнее смотрите значит пишем while q меньше модуль п я уж думал миша пошел свет
выключать так меньше либо равно модуль т и что еще п от куплю сойдем п плюс ку плюс
1 плюс плюс вот это мы просто увеличиваем ку так ну естественно если оказалось что ку равно
модуль п то как бы сохранить вхождение и наконец п ку присвоить п штрих ку штрих все
да
ну типа того ну про маленькое про большое да вот давайте ну давайте чтобы это было про
большое вот так вот
ну да то формально бред получается да вот да вот почему это не алгоритм а металгоритм
ну там ну ну сохранить вхождение я имею ввиду давайте в кавычках напишу ну там что-то типа
что значит это означает что мы нашли вхождение который заканчивает который вот тут с п плюс
1 до п плюс к ну его надо как-то обработать ну как либо там напечатать куда-нибудь либо там плюсы
типа сказать что мы нашли плюс 1 вхождение там и так далее ну там вот а вот это именно
главная интрига этого вот главный интриг именно именно благодаря этому это алгоритм мы называем
металгоритм а не алгоритм потому что как искать п штрих ку штрих вот в этом и самый магический
вопрос это какие-то следующие числа желательно чтоб п штрих был больше чем п вот ну то есть ну
точнее так на каждой это рация нам говорят что вот п ку это точно под строка то есть там префикс
то есть теперь дальше мы вайликом увеличиваем куда упора вот но вот а после этого переходим
к какой-то следующей паре значит какие у нас варианты есть тупой вариант тупой значит к
чему равно п штрих ку штрих значит вариант первый п штрих ку штрих равно п плюс 1 0
вот у этого значит у этого алгоритма есть преимущество он работает он точно работает
правда другой вопрос да он в тупую да но это правда как раз тот самый алгоритм поиска под
строк строке за за квадрат просто в явном виде то есть как бы и память хорошая время плохое
давайте вместо один напишем как чего а почему к тогда будет ва вот потому что вот есть другой
способ что его мое тут-то чего его мое
а я знаю что вас смущает на вас вот это смущает вот теперь да вот теперь все понятно
ну как бы шифт у нас все-таки с индексом строчки они числа
так ну как это называется да как это как называется алгоритм который мы ищем под
строку строке с используя вот такие равенства правильно да ну или да алгоритм кнута мориса
праттов явно ведь сейчас мы прибавили длину мобильного периода префикса длины ку строки п да
вот а вот вот а вот в этом и проблема да как искать шесты точнее так как сказать шесты понятно
насчитай префикс функцию для строки п и порадуйся но они потребуют памяти до
проблемы вот но так это заметим что это фактический алгоритм кнута мориса пратта
может сказать почти в первозданном виде ты теперь нам нужно просто научиться
нет мы просто не будем применять не этот метод не этот метод я просто это я просто
предложил вслед за авторами просто такие иллюстрацию того что этот вообще металл
алгоритм означает то есть как бы подставим вот этот метод получится алгоритм который ищет
вхождение вполне себе за линию ну в предположении конечно что эти шифты вам присылаются небес по
факсу конечно вот да оттуда да в 72 году кстати кстати о западе с удовлетворением могу отметить
что запад успешно загнивает но не будем на этом останавливаться это в конце концов их нравы зато
мы здесь на истребла так я это вам помпом я это уже воспроизводил нет ну ладно 72 год да да да
кстати надо еще вспомнить галил сейферас это вообще какого года алгоритм по-моему даже не
72 галил сейферас ну гуглонить там да что-то находится только какой репетиторий на
кит хабе и скины на галил арис к изго два чего так вы господи во-первых сейферас во-вторых
ну вы по-английски то гуглите как вы знаете я думал чего да да да да да господи рекламодателем
до рекламодателем в наших лекциях нет рекламы да вот это лекции дорушает я не знаю что там
это требуется авторские отчисления авторам этой статьи или что я знаю ладно значит смотрите
итак значит мы будем п штриха ку штрих выкапывать немножко по-другому мы будем говорить что у нас
есть вот это наша мистическая строка п и мы напоминаем что строка п у нас равно ув то есть
вот это вот у а это у нас в у которой есть shift то есть вот этот вот shift так сказать shift
в от модуль в вот вот и мы знаем что у она типа относительно этого шифта мелкая и что мы еще
будем делать но вот а еще мы знаем что этой штуки в внезапно есть какой-то префиксный период
какой вот какой-то префиксный период у нее есть а может и нет кстати но тут два варианта он
либо есть он равен п либо его нет и все вот значит давайте начнем с простого попробуем
значит начать с простого случая предположим что выяснилось что этой в нет префиксного периода
да то есть да это будет означать что у нас потом будет алгоритм который значит для строки п за
у от п это сделает вот соответственно так давайте предположим чтоб но вот теперь предположим
что вот нам фантастически повезло и префиксного периода нет и так значит да то есть давайте
такое предположен тогда смотрите давайте так я и буду писать значит первая допусть у вот этой
вот п нет префиксного периода тогда утверждать тогда я утверждаю весьма неожиданную вещь вообще
нет вот это тогда я утверждаю такой даже в отдельную лему это не буду выносить шифт вот
этот вот мистический шифт короче но ладно же неважно шифт от абсолютно произвольного q утверждаю
я больше строго больше даже чем q делить на к нет то там официальная ссылка идет на лему 1 в
которой было что как бы если шифт от q меньше либо равно q делить на к то этот шифт является
префиксным периодом то есть да то есть в общем вывод простой да то есть как бы если префиксное
периода не значит любой шифт больше чем q делить на к и тогда идея и тогда идея очень простая тогда
п штрих ку штрих знаете что должно быть я утверждаю что оно должно быть просто п плюс
q делить на к ноль все
ну что вы так занудствуйте ну вот вам пожалуйста тогда я утверждаю что наш алгоритм ну то есть
наш алгоритм по такому раскладу сработает за там то есть пройдется получается за от
точнее плюс от за от умножить на к но ка у нас константа поэтому соответственно вот догадываетесь
почему да что а потому что важно потому что вот как потому что есть интеллектуальный момент я
забыл сказать прошу прощения да потому что во первых тогда тут надо не упе а ув а в той самой
главной смотрите тут эпическая идея смотрите сейчас будет это эпическая идея мы дело в том
что мы будем искать вхождение не строки п а строки в вот значит мы будем искать да мы будем искать
по факту вхождение строки в и просто если мы найдем какое-нибудь вхождение строки в то мы
просто в этом месте быстрый нот то мы в этом месте тогда проверим а нет ли перед этим вхождением
строки в вхождение строки почему это быстро работает а вот почему смотри дело в том что допустим
везде где у нас должно быть вхождение строки п должно быть вхождение строки в правда а теперь
заметим следующие пусть у нас в строке т вот жила была строка т и мы тут неожиданно нашли вхождение
строки в внимание вопрос где должно быть следующее оно должно быть на каком-то расстоянии больше
либо равном вот этого шифта. Правда? Логично, да? Тогда я утверждаю, что если мы найдем
все вхождения строки V и только для этих вхождений будем проверять вот это вот U,
то в принципе отсюда следует, что вхождений строки V самих по себе вхождений не более,
чем модуль T делить на вот этот вот шифт. И тогда, ну вот самих вхождений вот столько,
и тогда получается, что если мы для каждого вхождения будем работать за U, а U у нас,
в свою очередь, от этого шифта, то тогда получается, что все эти проверки U суммарно
сработают за O от T, и это нас устраивает. То есть вот такая вот неожиданная идея.
Вот. Вот. То есть таким образом получается, что мы, начиная с этого момента, считаем,
что P это на самом деле V. Потому что как бы проверка вот этого префикса U,
это просто получается для нас за бесплатно. Понятно? Так, ну что тут, понятно, да?
Да, и даже все гораздо понятнее стало. Вот. Отлично. Ну вот, поэтому теперь ищем V. Значит,
как мы теперь ищем вхождение V? Ну, вхождение V, если выяснилось, что у V еще нет префиксного
периода, то запускаем вот этот металгоритм на предельного тупничка. Что? Значит, по нот.
Значит, почему? Так, ну давайте, да. Как бы это, как бы это так максимально легко увидеть?
Сейчас еще раз. Чего говоришь? Нет, shift V от Q это период префикса Q. Он, естественно,
меньше либо равен, чем период всей строки. Ну, потому что если у всей строки есть период 57,
то и у префикса есть период 57. То есть, что вот так. То есть, ну меньше либо равна. Чем меньше строчка,
тем меньше у нее период. А, сейчас. Да ладно. Нет, у строки A-A-B период 3. У строки A-A период 1.
То есть, чем меньше строка, тем период меньше. То есть, мы минимальный период берем. Вот.
То есть, короче говоря, если у нас, сейчас, если у нас, ну да, если у нас у строки есть период, то у нас тоже есть, если у нас меньше равен. Ну да, тогда понятно, почему работает.
Да. Так. Ну, почему работает, понятно. Теперь более интересно, почему это работает за адекватное время.
Тоже понятно. У нас просто, ну, потенциал камонеток на каждое увеличение в Q ходит.
Ну, то да. Ну, это не совсем потенциал, потому что мы сначала скачем на Q, а потом продвигаемся вперед. То есть, как бы такие, на самом деле, просто можно обратно во времени сказать.
То есть, ну, можно просто сказать, что на каждом шаге мы увеличиваем P на сколько-то, да, и гарантируем, что Q при этом прошло шаров не более, чем это. Сколько-то умножить на K.
Ну, вот, следовательно, суммарно Q прошло не более, чем для нас строки T умножить на K. Ну, а K у нас константа, поэтому победа. Вот. Понятно, да?
Можно еще раз, что мы сделали? То есть, у нас, ну, вот, находится в этом байле, мы выполнили одну итерацию, а сейчас оставляем PQ, так?
Да. Вот и предлагается это делать вот так.
Да, утверждаем мы. То есть, это означает, что если мы P увеличим на, значит, что-то меньшее, чем Q делить на K, то тогда в этой позиции вхождения точно не будет, это можно пропустить.
Если P увеличить на что-то меньшее?
Да.
Поэтому у меня идея такая, давайте увеличим на Q делить на K, округленный вверх, и будем начинать с этого момента искать вхождение в тупую. То есть, вот Q, видите, я даже сохранять не буду.
Ну, в плане, у нас shift Q больше Q делить на K, shift V больше правильно, чем shift Q, а расстояние между соседними shift V.
Хотя бы shift V. Ну, вот. Ну, хотя бы shift V, а shift V это хотя бы Q делить на K, поэтому давайте просто сдвигаем Q делить на K, и это нам хватит.
То есть, мы не знаем, чему равен shift от Q, естественно, да? Но нас это и не волнует, мы просто берем Q делить на K, и не паримся.
То, что больше, чем Q делить на K, это следствие изменит.
Да. То есть, у нас была Lemma 1, которая заявляла, да, что...
А, мы не знаем, чему равен shift V. Сейчас, стоп, а как мы посчитаем shift V от Q? А, стоп, нам его не нужно считать?
Чего? Shift не нужно. Нам достаточно знать, что он хотя бы вот столько.
Сейчас, но у нас в частности shift Q больше равен, чем V делить на K, да?
Ой, не так. Сейчас. А можно же прибавлять вместо Q делить на K, V делить на K просто?
Нет. Нет-нет-нет. Потому что мы знаем только вот это про V делить на K, а мы ничего не знаем.
Так, стоп. Подождите, что такое Q?
А, мы говорим, что в следующее обхождение... А, мы знаем, что у нас Q входит уже, да?
Да.
Тогда в следующее обхождение Q через shift.
Ну да.
И поэтому можно прибавить...
Да. Ну да, давайте еще раз нарисуем.
Вот жила строка T, вот мы находимся... Тут позиция P, тут позиция... Тут вот набралось Q, да?
И тут мы остановились. Теперь мы хотим перейти.
Но заметим, что нас теперь интересует следующее вхождение вот этой подстроки.
Вот это является префиксом строки V, да?
Вот.
Но тогда утверждается, что следующий...
Так как у строки V нет префиксного периода,
то там по лемме получалось, что следующее вхождение будет хотя бы через Q делить на K.
Стоп, а мы умеем определять, есть QV в префиксном периоде?
Ну вот, да.
То есть, да, в этой теории мы на самом деле найдем...
Даже отличим в случае, есть ли префиксный период.
И Q-not, и not, или нет.
Так что вот такая вот идея.
То есть так как вот этот префикс точно нужен,
но значит нам сдвиг хотя бы Q делить на K.
То есть когда мы дошли до конца цикла,
то Q это такая же позиция, что Q равно...
Ну в смысле, что Q это позиция, где у нас есть вхождение.
Ну Q это не позиция. Q это как бы длина подстроки,
начинающаяся после этой позиции,
которая совпадает с префиксом строки V.
А то есть когда мы дошли до конца цикла,
то мы гарантируем, что у нас есть вхождение?
Нет.
Вот это совпадает с префиксом.
То есть это не вся строка V, но это ее префикс.
Если Q станет длиной модуль V,
то да, мы нашли вхождение строки V.
А все, мы смотрим максимально.
Да, то есть вопрос, насколько мы тут дойдем.
Но оказывается, что следующее будет как бы как минимум
через Q делить на K шаров,
поэтому сдвигаемся на Q делить на K,
и ищем следующее Q уже в ту пую.
Вот.
Так что вот такая радость.
Так что оказывается, что если нет префиксного периода,
то как бы мы победили на халяву.
Вот.
Теперь давайте посмотрим,
что у нас будет второе.
Теперь второй случай.
Пусть у V есть единственный префиксный период.
Период P и равен он P1.
Да, в те время мы его еще и находить будем
в явном виде, если он есть.
Понятно, да?
Тогда,
значит, тот алгоритм пишет вот простую вещь.
Значит, смотрите.
Оказалось, что при K P1 меньше либо равно Q
меньше либо равно rich V от P1.
Вот.
Ну, скажем так, rich V от P1
мы эту чиселку можем заранее предподсчитать, правда?
Ну, если мы знаем V и знаем P1,
то rich мы как чиселку можем один раз
там когда-то посчитать и сохранить, правда?
Да, просто в тупую пробежаться, конечно.
Вот.
Так вот.
Если совершенно случайно окажется,
что Q попало, ну, понятно будет,
что rich V от P1 будет больше либо равно,
чем K P1.
Так вот.
Если Q у вас, оказывается,
попадет в этот подотрезок,
понятно, да?
Ну, при полу может же быть такое,
что Q попало, правда?
Тогда что?
Тогда я утверждаю, что надо сделать P,
значит,
тогда надо просто P' Q'
должно быть равно
P plus P1
соответственно
и Q минус P1
Потому что, по идее,
что это неравенство значит?
Это неравенство значит следующее.
То есть это означает,
что мы тут нашли какой-то Q.
Так, давайте я тут под линией нарисую.
Это означает,
что мы тут
теоретически
оп-оп-оп-оп
Ну, по крайней мере,
у строки V есть вот
оп-оп-оп-оп
длины P1
И может быть еще там
сколько-то вот до какого-то момента,
но хотя бы 4 опа есть.
Видно, да?
Так вот, если неожиданно выяснилось,
что Q у нас оказалось
такой длины,
что вот тут оп-оп-оп-оп
налицо
и более того,
Q еще не достаточно большое,
чтобы за пределы
периодичности P1 мы вышли,
то тогда утверждается,
что редкий случай,
но shift от этого Q мы тупо знаем.
И он равен именно P1.
Ну, потому что тут,
ну, потому что тут, видимо,
надо правильно сослаться
на какую-то лему.
Забыл, на какую.
Но рассуждение такое,
потому что, смотрите,
P1 это кандидат на shift,
правда?
А теперь
предположим,
что здесь есть shift меньше.
Но тогда очевидно,
что...
shift в строке V?
Нет.
Ну, это shift в строке V.
Ну, это шифт в строке V.
Это шифт в строке V.
Это шифт в строке V.
Это шифт в строке V.
Нет.
Ну, это шифт в префиксе
длины Q.
Длины Q.
Строки P, конечно.
Ну, тогда я утверждаю...
Ну, точнее так.
Это не Q.
Это, конечно,
reach с индексом V
от P1, конечно.
Но в этой строке,
если в ней найдется shift от Q
поменьше,
то тогда мы сделаем вывод,
что тогда...
То есть, как бы,
еще меньше период,
чем P1 найдется.
Сд от P1 этого меньше.
И он будет тогда
делителем P1.
Тогда P1...
То есть, вот это вот
это не базовая строка.
Значит, префиксный период.
Я вот просто не помню,
в какой конкретной лемме
мы забабахивали
такие конкретно утверждения.
Может быть, кстати,
лемма 2 и была.
А, ну, смотрите.
Да, у нас же...
Обратите внимание.
Тут у нас прямо в явном виде
лемма 2, да?
То есть, мы говорим,
что если у нас P1
это префиксный период,
то вот это вот
верно тогда
и только тогда,
когда шифтом от Q
является в точности
префиксный период.
То есть, это мы прям
лемма 2.
Тут лемма 1,
а тут прям лемма 2.
Зачем нам были
эти утверждения в явном виде?
Вот, понятно?
Да, нет, наверное.
Ну, типа.
Вот.
Вот.
Вот.
А что мы делаем?
То есть, это вот такой
единственный случай,
когда мы знаем шифт.
Потому что, как вы думаете,
что мы сделаем?
В противном случае...
А, нет.
Так.
То есть, иначе
тогда мы объявим, что...
Давайте P'Q'.
Это максимум
из...
Точнее, так.
Это, значит,
P'Q' максимум
из единицы
и вот этого Q'Q'
в правильную сторону.
Ну, в смысле, вверх.
И ноль.
То есть, просто на Q'Q'.
Вот.
Ну, давайте разбираться.
Что там в округлении стоит?
Q'Q'.
Ну, как и ранее.
Ну, идея очень простая.
Ну, идея такая.
Но, на самом деле, у нас тут
два случая.
Вот, как Q может
не попасть в этот отрезок?
Двумя способами.
Либо Q слишком маленькая,
либо Q слишком большое.
Правда?
Но, заметим, что
если Q слишком большое,
то тогда у этого префикса
длины Q строки V
нет префиксного периода.
Правда?
Но, раз у него нет
префиксного периода,
то вот этот переход валиден.
Сейчас, если у него нет
префиксного периода,
то мы бы сюда не попали.
Чего?
Нет, почему?
Попали.
Потому что, я говорю,
Q просто оказалось
меньше, чем K'1.
Поэтому P'1 не является
префиксным периодом
префикса маленькой длины V.
То есть, чтобы он
являлся префиксным,
нужно, чтобы Q
было хотя бы 4P'1.
То есть, поэтому если оно...
Да, то есть, смотрите,
если оно...
То есть, что получается?
Если оно мелкое,
то все в порядке, да?
Сейчас, если мелкое,
то у Q вообще
нет префиксных периодов, так?
Да.
Поэтому, да.
Поэтому, на самом деле,
вот...
Поэтому переход...
Поэтому переход
просто происходит
абсолютно такой же, как здесь.
Так что это, если Q
было мелкое.
А теперь, внимание,
вопрос, что же делать,
если Q оказалось большое?
Что тогда?
Стоп, еще раз.
Если Q мелкое,
то у префикса длины Q
строки V
нет префиксного периода.
Ну ладно, да.
И это означает,
что можно сделать
переход на Q
делить на K.
А теперь, внимание,
вопрос.
Ой, нет, не туда.
А теперь, внимание,
вопрос.
Вот так надо.
Вот.
Вот.
Значит, что теперь?
Ну вот так.
А что делать,
если Q
наоборот оказалось
прям очень-очень-очень-очень
большое?
Прям больше,
чем этого рычага.
Ну вот.
Верно ли,
что в этом случае
мы тоже можем
заявлять,
что, на самом деле,
с шифтом
тут все в порядке?
То есть, шифт,
как минимум,
Q делить на K.
Ну вот.
Вот.
Ну вот.
Ну вот.
Ну вот.
Ну вот.
Ну вот.
Ну вот.
Ну вот.
Ну вот.
Ну вот.
Ну я не знаю.
Можно ли
тут сослаться
прям на четкую лему?
Или там
лема 2
тоже имела
в виду
на зад Warning
чуть другое.
Но глубокий смысл,
на самом деле,
остается неизменным.
А именно?
Ну вот.
Чего мы?
А, ну понятно.
Ну вот.
Потому что
мы уже вышли,
если
оно меньше
рычага,
если шифт меньше,
по чем мы будем
это делать?
Ну вот.
А если
этоín меньше,
Если шифт меньше, чем кудрить на к, то у нас в поле есть какой-то шифт, но этот шифт не совпадает с П1, потому что мы уже вышли из пределов его влияния.
Да, он не совпадает. Причем более этот шифт, чем четыре этого шифта, тоже является префиксным переводом, что важно.
Ну да.
Ну хотя да, ну вот. А, ну да. А, да-да, все, рассуждение очень простое. Есть шифт, то есть к чему равен шифт? Если шифт меньше либо равно кудрить на к, то он обязан быть префиксным периодом.
Префиксный период у нас только один, это П1. Но на П1 мы сдвинуться не можем, потому что у нас ку слишком большое. Вывод. Значит шифт не может быть кудрить на к.
Сейчас, откуда мы получили, что если шифт меньше либо равно, чем кудрить на к, тогда мы сказали, что у нас...
Тогда я утверждаю, что это префиксный период. Почему? Потому что, во-первых, как бы взятый карас этот шифт, это есть префикс строки, это мы понимаем, да?
А во-вторых, мы понимаем, что строка шифт базовая.
Да, базовая.
Потому что если бы она была не базовая, то там, очевидно, еще более мелкий период бы нашелся.
Взятый карас...
То есть просто лучший шифт.
Нет, стоп. Взятый карас уже за нас перевалит.
Чего?
А, стоп. Мы говорим, что к... Сейчас. Мы говорим, что если шифт меньше либо равно, чем кудрить...
Да.
То есть значит, у нас тут как бы есть период-период, значит и тут 4 экземпляра хотя бы, да?
Тогда пусть шифт меньше.
Тогда шифт, этот меньше шифт, тоже префиксный период.
Понятно, да?
Почему?
Ну, нет, то есть утверждение такое, шифт, это тогда будет префиксный период, если там меньше кудрить, делить на к, почему?
Потому что столько экземпляров есть, и этот шифт еще и базовый.
Почему он базовый?
Потому что, если я тут еще, у меня есть период, допустим, P1, и я распилю его еще на 3 части, ну или там, насколько там, по 5, одинаково от частей, то тогда получается, что это тоже будет период.
И это...
Ну, значит так, если есть меньше какой-то период, то тогда есть период, который является делителем P1, потому что у нас там ХЦДшка.
Вот.
Поэтому получается так.
Ну, просто конкретно в нашем случае получается, что, то есть как бы шифт должен быть префиксным периодом, префиксный период у нас у строки только один, и это P1.
То есть получается, нам надо проверить, P1 подходит или нет.
Мы убеждаемся, что вот P1, вот если этот случай верен, то P1 подходит, а вот этот случай говорит нам, что не подходит.
То есть если P1 не подходит, значит получается меньше, чем QdLT на K, меньше либо равно, чем QdLT на K, у нас периодов нету.
То есть шифтов нет.
Может есть и больше, но мы уже не заморачиваемся, просто перескакиваем на QdLT на K и радуемся жизни.
Хочу меч, чтобы он не порвался.
А зачем там МАКС? У нас не может быть округления.
Ну, вдруг Q равно нулю.
Так-то да, так-то да.
Но Q бывает нулю равно, иногда.
Так случается.
Поэтому-то такую аккуратность пишут.
Так что получается, если у нас вот эта мистическая теорема декомпозиции, откуда-то верна,
каким-то вот мистическим образом она верна, мы откуда-то эти УИВ выкопали,
то тогда после этого мы за ОАТ легко побеждаем.
Ну здесь, я думаю, понятно, что тут тем более ОАТ.
Нам, наверное, еще нужен алгоритм, как это построить.
Как нам вот это построить, да.
Совершенно верно.
Ну тут у нас как бы два варианта.
Мы как бы сидим здесь еще до полвосьмого.
У нас есть вариант, что 8 парам.
У кого? У вас?
У всех.
А что?
Что?
Да.
Чего?
Да, кстати.
Чего?
У нас препод заболел.
Так.
У нас препод заболел и перенес пару в онлайн.
А, ну понятно.
Нет, ну как сказать.
Нет, ну как хотите.
Нет, смотрите, можно сделать и так и так.
Можно в принципе сейчас остановиться и как бы эту теорию доказать в следующий раз.
Давайте я остановлюсь.
Мы все понятно.
Мы выяснили, зачем она нужна.
Да.
То есть мы выяснили, что по модуле эти теории мы бы победили вообще, да.
Мы выяснили, зачем она нужна, а как это доказывать, это уже не так важно.
Ну, точнее, как ее строить.
Потому что это тоже часть алгоритма, извините.
Вот этот раз спил найти.
Так что, да.
Вот, потом выяснится, да.
Я сейчас, конечно, не готов это сказать.
Я сейчас как высушу это 5 минут делов.
Ну ладно, вряд ли, если честно.
Там содержательная часть алгоритма.
Ну ладно.
Значит, тогда остановимся.
