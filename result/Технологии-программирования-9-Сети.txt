Мы с вами продолжаем наш курс занятий и наконец-таки,
я не знаю, может быть для вас это будет радостная
новость, но мы переходим именно к такой полупрактической
теме, которая очень важно посмотреть вообще для того,
чтобы понимать как современные сервисы работают и вообще
как работает вся инфраструктура больших приложений.
Возможно, что где-то вам это уже на курсе по Пайтону
немного рассказывали, мы попытаемся эти знания
углубить и рассмотреть то, как это работает на самом
деле.
Мы с вами начинаем говорить про сети Voicetag, в том числе
мы сначала немного поговорим про низкоуровневую часть,
а потом мы уже перейдем более к высокоуровневую
части, я дополнил наши лекции по сравнению с прошлыми
годами некоторыми примерами для того, чтобы вы могли
понимать.
И последняя лекция, по большей части, это будет
затравка на будущие курсы, в которые вы можете в целом
ходить.
Да, потому что есть тот же самый курс по многопоточности,
есть курс по написанию веб-сервисов, есть курс по сетям отдельной.
То есть сегодня у нас такая именно вводная лекция,
на которой мы с вами посмотрим именно как это устроено
на самом базовом уровне, а дальше мы можем это дело
углублять.
Итак, мы с вами сначала займемся сетевой инфраструктурой,
при этом мы уже перейдем на, так сказать, более высокий
уровень, именно на уровень написания сервиса.
Хорошо, давайте первый вопрос, который вам зададут
на собеседование по сетевой инфраструктуре, как вы
думаете, какой?
Нет, на самом деле нет.
У кого-нибудь есть еще мысли какие, какого?
Интернет выглядит сложным.
Смотрите, вас скорее всего спросят следующий вопрос.
Так, это кажется, вот этот вопрос.
Что происходит при запросе адреса, то есть что происходит,
когда вы в браузере вводите какую-то ссылку и нажимаете
на Enter?
Это первый типичный вопрос, который задают по сетям.
Наша цель сегодня, так или иначе, разобраться, что
происходит при этом вопросе.
Так, ну давайте попробуем понять.
Во-первых, у нас есть с вами сайт MipTru, например, и на
самом деле давайте посмотрим, что же происходит в этот
момент времени.
То есть мы заходим с вами на MipTru, и у нас открывается
страница.
Да, кажется, что у нас страница открывается быстро и у
нас открывается веб-сайт.
Но на самом деле в зависимости от региона сайт будет открываться
по-разному.
То есть в какой-то момент времени он открывается
быстро, в какой-то момент времени он открывается
медленно.
Более того, здесь очень важный момент состоит в том,
что если немножко пошаманить, то можно сделать очень
хитрую вещь.
Называется, если сюда поставить вместо MipTru Old MipTru, то мы
внезапно проваливаемся на вот этот сайт.
Это старая версия сайта Фистеха.
Не знаю, мне она визуально больше нравится.
Есть такие, кто считает, что старая версия сейха
была лучше.
Сайта.
Ну, да.
Иногда перенос интерфейса с сетевого всего этого
дела происходит таким образом.
Более того, знаете, что я могу сказать, я могу отправить
запрос на сайт MipTru, при этом кое-что сделать и получить
старую версию сайта.
То есть существуют такие моменты, когда мы это можем
сделать.
И как это происходит, на самом деле, нам нужно
разобраться.
Значит, давайте начнем со следующего момента.
Я, опять же, быстро пробегусь по основным моментам, потому
что сейчас я этим грузить не хочу.
То есть это все будет на курсе по сетям.
Значит, в чем состоит суть?
У нас на самом деле, когда мы с вами общаемся, у нас
есть два процесса.
То есть у нас есть процесс A, и есть некоторый процесс
B.
Только учтите, что если раньше мы запускали с вами простые
программы, и, допустим, у нас процесс A и процесс
B каким-то образом обменивался, зачастую они обмениваются
через какой-то общий файл.
То есть у них есть какой-то файл, в котором они делают
запрос.
Кто-то из вас сейчас делает проект по базам данных.
Соответственно, процессы A и B могут обмениваться не
только через файл, но и через базу данных.
А хотелось бы, чтобы они общались между собой напрямую.
Кто-нибудь, возможно, с тем темом семинаров уже
знает, как можно общаться, как два процесса могут общаться
между собой.
Через порт это как раз то, к чему я подвожу.
Так, хорошо, давайте я подскажу.
Кто помнит, что делает команда вот эта?
Ls, палка, wc-l, количество файлов в директории подсчитывают.
То есть смотрите, что у нас получается.
У нас есть один процесс A, который является ls, есть
процесс B, который является wc-l.
И что у нас происходит?
У нас вывод одного процесса перенаправляется на вход
другого процесса.
То есть мы по факту можем сказать, что вот у нас есть
открытый файл, у нас открывается поток estdout, а у B открывается
stdin.
И, собственно, мы перенаправляем процесс из estdout в stdin, то
есть мы отправляем запрос в одну сторону.
Но хотелось бы сделать так, чтобы эти соединения
работали, так сказать, похожим образом, как файлы, но при
этом они находились на более высоком уровне.
И как раз для этого существует способ, который регламентирует
нам процессы взаимодействия файлов.
Значит, есть специальные типы файловых устройств,
они называются сетевыми файлами или называются
сокетами.
И как раз при помощи механизма сокетов можно обеспечить
так, что два процесса между собой при помощи некоторых
протоколов будут взаимодействовать как файловые дескрипторы,
то есть как открытые файлы, но при этом будут взаимодействовать
на более высоком уровне, то есть он позволяет открыть,
в отличие от основных файлов, мы можем привязаться к
сетевой инфраструктуре, к сетевому стеку.
И нам нужно понять, каким образом мы можем привязаться
к сетевому стеку.
Зачастую у нас A и B это у нас либо два компьютера,
либо A это клиент, B это некоторые серверы, либо A и B это отдельные
серверы, в котором просто A выступает как клиент, а
B выступает как сервер, который принимает запрос.
И я делаю подводку специально к следующей вещи, пожалуйста,
сейчас не пугайтесь от большого слайда, есть специальный
международный стандарт, мы с вами обучаемся по международным
стандартам, и этот международный стандарт называется OSI.
Он достаточно страшный, он состоит из семи уровней,
но по факту большую часть из этих уровней нам знать
особо не надо.
Это просто классика, про которую нужно сказать.
Итак, когда у нас есть два процесса A и B, давайте назовем
процесс A источник, процесс B назначение, у нас на самом
деле взаимодействие между этими процессами происходит
на семи уровнях, всегда выделяют обычно семь уровней, но сейчас
есть более простая модификация, в которой находятся на самом
деле не семь уровней, а четыре уровня.
Давайте поговорим про каждый из них понемногу.
На самом деле, когда мы отправляем запрос в браузере, мы с
вами работаем на прикладном уровне, то есть это самый
верхний уровень.
Мы заправляем запрос, и как раз здесь видно по какому
протоколу мы обычно общаемся, это либо HyperText Transfer Protocol,
либо протокол FTP.
Кстати, браузеры позволяют поднимать файловые серверы,
можете попробовать.
Если у вас, можете провести мысленный, даже физический
эксперимент, вы берете в браузере, смотрите есть
ли у, ой, роутер дома, и проверяете есть ли у вашего роутера
USB выход.
Если у вас есть USB выход, значит вы можете поднять
файловый сервер внутри вашей системы.
Более того, на фистехе в бородатые годы, когда
не было еще эпохи интернета, буквально 10 лет назад, была
локальная сеть, которая по факту тоже работала как
файловый сервер.
Если кто-то нас в записи смотрит олды, то Натали
Кампус всегда будет в наших сердцах.
Сеть называлась Натали Кампус, и она была доступна
из фистеха.
Дальше мы спускаемся на более низкий уровень, уровень
представления.
Мы отправляем с вами какие-то сайты, то есть у нас либо
отдается HTML страничка, либо отдаются картинки, либо
отдаются стилевые картинки, либо отдаются скрипты
до исполнения.
Дальше следующий уровень, давайте спустимся ниже,
это сеансовый уровень.
Обычно его практически редко можно увидеть за некоторым
исключением.
Это некоторые исключения, это обычно сервисы из трех
букв, которые мы рассматривали в примере паттерна прокса.
Этими тремя буквами вы зачастую пользуетесь.
На ВП начинается, на ПН заканчивается.
Обычно эти сервисы работают именно в сеансовом уровне.
Когда вы отправляете запрос в браузер, все равно у вас
какая-то информация сохраняется.
Вы задумывались о том, каким образом вы так или иначе
авторизовываетесь в системе.
Что вы авторизовали в системе и почему система о вас знает.
А где?
Не, то, что мы авторизовались в системе.
В принципе, можно и так сказать.
Либо используется токен для авторизации, это специальное
случайное значение, которое может авторизовать вас
по серверу.
Либо все хранится на уровне куков, то есть на уровне
браузера.
Есть специальный механизм куки, расшифровывается
как печеньки, через которые можно отправлять вот эту
информацию и авторизовывать наш запрос.
Это у нас сеансовый уровень, дальше спускаемся ниже.
А вот здесь, ниже, заключается интересный момент, каким
образом мы отправляем с вами сигнал по сети.
То есть мы уже идем на уровень передачи данных.
И здесь на транспортном уровне обычно выделяется
два протокола.
Первый протокол – это TCP, а второй протокол – это
протокол UDP.
Значит, в чем заключается особенность?
Я не буду сейчас детально говорить, собственно, в том,
когда мы подключаемся с вами по протоколу TCP, то
сервер A убеждается, что сервер B подключен, и они
по факту, как сказать, они начинают обмениваться
данными, но они обмениваются данными интересным образом.
То есть они, грубо говоря, должны удостовериться,
что другой клиент находится в сети.
То есть, что A и B наладили связь между собой, и после
этого A и B отправляют сигнал друг к другу.
То есть один может отправить какой-то запрос в пакет
данных, а второй отправляет ответ к нему обратно.
То есть мы с вами убеждаемся в том, что наши данные, грубо
говоря, ни в какой момент времени не произойдет разрыв
связи, и что A не отправит B какие-то данные.
То есть A и B сразу поймут, что что-то идет не так.
Есть другой транспортный уровень, протокол транспортного
уровня, он называется UDP.
В чем особенность UDP?
Это просто направление в одну сторону.
То есть A отправляет информацию B, и дальше, не важно, B в
сети или нет.
Давайте подумаем примеры, когда используется UDP протокол.
В каком случае можно сделать так, чтобы какую-то часть
информации мы могли пропустить?
Видеоконференция, стриминг.
Да, видеоконференция, стриминг.
В принципе, если у нас какие-то кадры пропадут, то в целом
ничего страшного не будет.
На самом деле, если говорить чуть более интересным способом,
то новая версия протокола HTTP работает поверх UDP, но
с некоторой дополнительной проверкой.
Правда, не поверите, наши браузеры используют слишком
устаревшую версию протокола HTTP.
Так сказать, браузеры при взаимодействии с некоторыми
сайтами, то есть зачастую используют протокол HTTP 1.1,
но если говорить более серьезно, то можно переключиться
на протокол HTTP 2, и тогда будет работать все быстрее.
В разы быстрее, потому что это формат данных такой.
Это транспортный уровень, мы определяемся, каким
образом мы отправляем друг к другу сообщения.
Теперь вопрос, а куда именно отправлять наши сообщения.
И здесь мы спускаемся еще на один уровень, это сетевой
уровень.
И здесь обычно выделяют два сетевых протокола.
Первый сетевой протокол это IPv4, и второй протокол
это IPv6.
Зачастую, сейчас, когда мы вводим информацию в браузере,
мы используем протокол IPv4.
То есть, когда вы вводите в браузере что-нибудь вроде...
Так, сейчас попробую 127.0.0.1, да, у меня ничего не открыто.
Давайте я подшаманю немножко.
Немножко подшаманю.
Во.
Во.
Собственно, что мы с вами отправляем?
Мы отправляем с вами магическую комбинацию из четырех.
А ничего не видно, да?
Блин.
Кто-нибудь знает, как увеличить фон браузера.
Так, фонт.
Давай.
А?
А.
Так.
Так.
Скорее всего, где-нибудь здесь.
Скорее всего, где-нибудь здесь.
Короче, ладно.
В общем, смотрите.
Попробую.
Да.
В общем, я ввёл в браузере 127.001,
и дальше я ввёл некоторые двоеточия и 18.888.
Мне придётся написать.
Значит, вот это вот у нас, это IP-адрес.
IP расшифровывается как интернет-протокол.
А вот это порт,
по которому мы подключаемся.
То есть, поверха,
грубо говоря, это у нас получается адрес назначения,
а это по факту можно считать адрес дома,
адрес квартиры, в которую мы отправили.
То есть, если это дом, это номер квартиры.
Дополнительно давайте тогда расскажу,
что в браузерной ссылке есть.
На самом деле здесь у нас вот это всё называется URL,
и здесь у нас первое, что есть, это протокол,
по которому мы отправляем сообщение.
То есть, здесь у нас используется протокол HTTP.
Дальше у нас идёт разделитель,
и дальше вот здесь мы с вами отправляем уже запрос.
То есть, здесь у нас как раз идёт структура директория.
Допустим, я не знаю, три.
Это означает, что нам на сервере нужно отправить запрос в slash3.
То есть, как-то посмотреть в эту директорию, а-ля директорию.
Вот, в принципе, здесь можно менять
очень большое различных вещей.
Допустим, из таких протоколов,
которые браузер поддерживает, это файл.
Это, так сказать, вот это вот у нас, если мы говорим,
то это L7, то есть, прикладной уровень.
Вот это у нас уровень L3 получается.
То есть, когда мы указываем IP-адрес.
Если мы указываем не IP-адрес, а какой-то адрес сервера,
то мы снова переключаемся на L7 протокол.
L7, смотрите, L1, L2, L3, L4, L5, L6, L7 это обозначения,
которые используют для быстрого понимания,
на каком уровне стека ИСОАСИ мы с вами находимся.
Так, вопрос, вот это понятно, что я написал?
Прикладной, самый верхний.
То есть, как раз на уровне L3 у нас с вами возникает IP-адрес.
Значит, есть страшные IP-адреса.
Это IPv6.
Почему их ввели?
Потому что IP-адрес обычно имеет диапазон следующий.
От каждой актет, так сказать.
Почему он актет?
Потому что он выражается восьмью байтами.
Вот.
Как раз на уровне L3 у нас с вами возникает IP-адрес.
Он выражается восьмью байтами.
Ой, восемь бит.
И всего таких актета четыре.
То есть, сколько всего мы бит с вами можем закодировать в IP-адресе?
Ну, четыре раза по восемь.
Сколько 2 в 32-й будет приблизительно?
На 4 миллиарда.
Как вы думаете, компьютеров всего больше или меньше, чем 4 миллиарда?
Ну, вообще любых устройств, которые могут подключаться по сети.
Да, сейчас уже больше.
Соответственно, на всех IP-адресов не хватит.
Вот.
И поэтому, собственно, разработали новую версию протокола IPv6,
при помощи которого можно задавать слишком большое количество диапазонов.
Я не буду говорить, как выглядит IPv6, это IP-адрес,
но, в общем, он выглядит достаточно страшно.
А вы сейчас смотрите.
Это получается у нас с вами протокол третьего уровня.
Дальше, если мы с вами спускаемся, здесь уже начинается физика.
Физика процесса.
Потому что здесь нам уже надо понять,
по какому с вами протоколу мы общаемся,
именно на уровне канала, то есть сеть.
И, наверное, вы заметили, что в некоторых сетях
у нас с вами максимальная скорость доступа в интернет 100 мегабит в секунду.
Мегабит.
А на некоторых сетях максимальная скорость доступа 1000 мегабит в секунду.
Да, то есть это уже зависит от того канала, который мы с вами можем поддерживать.
Какую максимальную скорость вы видели?
Подключение к интернету.
Ну, это, конечно, мощно.
Мегабит?
Ну, нормально, в принципе.
25 мегабит в секунду.
Ну, в принципе, это значит, что есть поддержка гигабитного интернета.
У меня, короче, такая небольшая байка.
У меня дома раньше тоже интернет 500 мегабит в секунду.
И, видимо, когда некоторые злостные товарищи из другого провайдера
пришли и перерезали провода или не из злостного провайдера,
точнее, из домоуправления, сказали провода не проводить,
они провели новый провод.
Только беда оказалась в том, что они провели не гигабитный интернет,
а 100-мегабитный интернет.
Хотя максимальная скорость соединения 500 мегабит.
Ну, вот я до сих пор сижу со 100-мегабитным интернетом,
ну, видимо, надо что-то это делать.
То есть, видите, у нас именно уже на канальном уровне,
то есть мы перешли на физику, на уровень проводов.
Понятно, что нас это особо не интересует, но, в принципе, мы должны понимать,
на каком уровне у нас идёт соединение.
И последнее – это физический уровень.
То есть, грубо говоря, как у нас байты по сети идут.
И здесь, как раз, если мы посмотрим на вот эту версию стандарта 11801,
то, я не знаю, видели вы, наверное, где-нибудь Ethernet кабель?
Значит, вот этот стандарт описывает, как работают жилы этих проводов.
То есть, как именно подавать напряжение на каждую из жил,
чтобы, собственно, шли байты по сети.
Это вот весь стэк.
Понятно, что грузить им особо не надо,
поэтому есть более упрощённая версия этого стэка.
Давайте подумаем, какие, в принципе, из этих уровней можно объединить?
Нижние два точно можно объединить?
Первые три ещё можно объединить.
Пятый, шестой и седьмой. То есть, они работают вместе.
И как раз мы переходим к новой версии протокола,
которая называется TCPIP.
В нём у нас объединяется пятый, шестой и седьмой уровень,
и каналный уровень у нас тоже называется общим.
То есть, это очень важно.
Сейчас это уже не важно,
потому что, так сказать, уже версия интернет-взаимодействия,
так или иначе, устаканилась.
То есть, лет ещё 20 назад,
когда можно было подключаться к интернету разными способами,
не знаю, возможно, вы видели разные мемы с списком модемов.
То есть, раньше реально модемы работали по телефонной сети.
То есть, это начало нулевых, когда вы, грубо говоря,
сидели в интернете по ночам, вы вытаскивали штекер из домашнего телефона
и по этому штекеру подключали его к модему и пользовались интернетом.
Потом никто дозвониться не мог,
потому что вы занимали весь сигнал.
Вот. То есть, вот такой вот способом есть.
Сейчас, конечно же, уже всё устаканилось.
Итак, давайте теперь...
Так, поэтому понятно, что происходит?
Теперь давайте поговорим про канонических представителей
на каждом из уровней TCPIP.
Значит, на каналном уровне у нас с вами есть такое понятие,
как MAC-адрес.
То есть, это как раз идентификатор,
в котором сколько? 4 байта на каждый из объектов.
4 байта, раз, два, три, четыре, пять, шесть.
То есть, 24 байта у нас выдаётся на каждое устройство.
И при помощи него можно задать статический IP-адрес.
То есть, вы можете привязать IP-адрес вашей сети на устройство.
Дальше, на сетовом уровне у нас задаётся IP-адрес.
Вот, например, IP-адреса 192.168.0.123.
На транспортном уровне мы всё оставляем точно так же.
То есть, мы говорим про TCP-протокол.
Значит, это у нас сообщения точно доходят.
По HTTP-протоколу у нас сообщения только отправляются.
Мы не гарантируем доставку этих сообщений.
И на прикладном уровне на самом деле у нас определяется протокол.
Но зачастую есть некоторое соглашение о том,
что когда вы используете тот или иной протокол,
вы привязываетесь к тому или иному порту.
Значит, давайте я здесь тоже скажу, что когда вы используете сетевое устройство alias socket,
вы можете его сохранить на уровне файла.
То есть, он реально у вас создаётся раз.
Но при этом вы можете слушать соединения, которые вам приходят из сети.
То есть, вы можете привязать ваш socket на самом деле к определённому порту,
к определённому сетевому интерфейсу и к определённому порту.
И договариваются, что просто те порты, которые здесь есть, они вот такие заранее обозначены.
То есть, на самом деле, когда вы пишете в браузере что-то alias HTTP MIP-true,
давайте я, наверное, тут даже покажу это всё дело.
Давайте я зайду на простой сайт example.com.
Откроем вкладку Inspect.
Это, кстати, знакомьтесь.
Как её вызвать?
Она вызывается либо F12, либо правой кнопкой мышки Inspect.
И я открою вкладку Сеть.
Для того, чтобы мы посмотрели, какой запрос отправился.
Мы на самом деле отправили запрос на HTTPS протокол,
и вот смотрите, сразу что здесь происходит, там выделяют IP-адрес.
То есть, мы на самом деле делаем запрос по вот одному IP-адресу в 2.443.
То есть, порт, по которому мы с вами отправляем, это порт 443.
Так, я сейчас тему поменяю.
А или она?
Так.
Угу.
Ну, видимо, да.
Она уже зависит от этого темы экрана.
То есть, здесь порт 443.
Теперь смотрите, сделаем одну некоторую махинацию.
Мы заменим HTTPS на HTTP.
И видите, здесь порт по умолчанию ставится 80, а не 443.
То есть, HTTP протокол работает на порту 80,
на HTTPS договаривается работать на порту 443.
Значит, если мы говорим еще про другие сетевые уровни,
то, значит, на 21 порту обычно работает файловый протокол.
Отравка писем происходит на порту 587.
Если это почтовый провайдер типа Gmail,
у Яндекса это работает все на порту 465.
То есть, видите, у нас есть заранее список обозначенных портов.
И когда вы подключаетесь к протоколу SSH, secure shell,
то есть, когда вы подключаетесь к удаленному компьютеру,
то по умолчанию вы подключаетесь к порту 22.
То есть, это защищенный протокол,
который позволяет вам сделать удаленное подключение
к какому-то компьютеру.
То есть, на самом деле, когда мы с вами открываем соединение,
то у нас открывается соединение на порту 22.
Заранее скажу, что привязку к портам меньше, чем 1024
может делать только суперпользователь.
Когда вы не являетесь суперпользователем,
вы можете использовать порты только от 1024.
И, на самом деле, когда клиент отправляет какой-то запрос,
то тоже, на самом деле, у нас отправляет запрос с определенного порта.
Давайте я покажу некоторые примеры,
как можно отлаживать сетевой трафик.
Сетевой трафик можно отлаживать при помощи инструмента под названием Wireshark.
Его можно скачать.
И давайте просто посмотрим, как это происходит.
Мы пропускаем эту версию.
Так, а где он? Открылся, да?
Во! Не знаю, тут ничего не видно, да, наверное?
Так, я сейчас...
Давай, не сломайся.
Так.
Да.
Давайте я послушаю протокол N0.
Не знаю, видно?
Вот.
Здесь мы слушаем на низком уровне,
и видно, что у нас с вами отправляются какие-то сигналы по сети.
То есть у нас есть протокол UDP, есть протокол TCP.
И вот здесь у нас идут IP-адреса.
Значит, вот это мой IP-адрес моего компьютера в сети.
И здесь видно, что у меня как раз отправляются данные на разные-разные системы.
То есть, в принципе, давайте попробуем открыть это все Example.com.
Значит, мне нужно будет сделать следующее.
IPDST.
Отшифровываем наш трафик и проверяем.
Во, видите?
То есть я отправил запрос сначала по протоколу TCP.
Значит, и вот видите, у меня тоже алоцировался определенный порт.
То есть у меня порт 64093.
И здесь как раз можно посмотреть, какие именно пакеты отправляются по протоколу TCP.
То есть вот они здесь у нас как раз есть.
Дальше мы переключились на протокол HTTP.
У меня здесь подключение идет.
А остальные каналы, видите, есть канал SIN, есть канал ACK.
Они как раз и позволяют, вот эти вот пакеты, которые отправляют SIN-ACK,
они позволяют настроить взаимодействие между сервисами A и B.
По протоколу TCP мы такого не получим.
То есть, в принципе, вы можете скачать себе Wireshark и попробовать в нем поэкспериментировать.
Посмотреть, куда у вас данные по сети отправляются.
Вы, наверное, найдете очень много интересных вещей.
Wireshark.
Мне, наверное, нужно будет в чате отправить.
Сетевая кула.
Вот, значит, вот такая вещь.
Тут прямо можно посмотреть пакеты, и она умеет разбирать запросы с определенных протоколов.
То есть мы прям спустились практически на низком уровне.
Так, хорошо, это понятно, да?
Давайте вопросы, если нет, то двинемся дальше.
А теперь вопрос вам.
Я задаю.
Мы же вводим в страницу не IP-адрес,
мы вводим с вами адрес HTTP MIP-TRUE.
Или HTTPS MIP-TRUE.
Что же происходит?
Не-не-не.
Как мы понимаем, по какому IP-адресу нам идти?
Да, тут уже правильно говорят, на самом деле.
У нас есть DNS, Domain Name Server,
которое позволяет понять, по какому IP-адресу располагается тот или иной домен.
Хорошо, давайте рассмотрим, как он работает.
Значит, у нас есть юзер, который, допустим, хочет пойти на страничку Google.com.
Ну, либо на Яндекс.ру, неважно.
Значит, что у нас есть?
У нас на самом деле протокол Domain Name Server работает по сетевому уровню.
Да, тут, кстати, есть кэширование запросов,
поэтому, так сказать, обновление страницы идет не очень быстро.
Итак, мы идем на страницу Google.com.
А дальше, когда мы идем на Google.com,
мы должны понять, по какому уровню,
какого типа запрос мы отправляем.
Обычно, когда мы с вами отправляем запрос на получение IP-адреса,
мы отправляем А-метку.
То есть мы говорим, пожалуйста, дай нам А-запись по такому имени.
И дальше, на самом деле, у нас возникает некоторая табличка,
при помощи которой мы с вами можем это сделать.
Итак, у нас сначала на нашем локальном компьютере есть, на самом деле,
локальный DNS-сервер,
который позволяет нам понять, куда нам направлять наш запрос по нашему адресу.
И интересное здесь особенно стоит в том,
что всегда у нас есть один зарезервированный хост,
одно зарезервированное имя.
И имя это Localhost.
То есть Localhost всегда вас перенаправит на IP-адрес 127.01.
Вот, это такое соглашение.
А дальше мы смотрим.
Если у нас нет локальных записей в нашем DNS-сервере,
то мы идем на следующий DNS-сервер.
Сначала мы идем в корневой DNS-сервер.
В принципе, вы можете поставить даже адрес DNS-сервера в настройках вашей сети.
То есть, куда вы именно обращаетесь.
По умолчанию, названия DNS-серверов,
IP DNS-серверов очень простые.
Это либо 4 единицы, если мы идем в Cloudflare,
либо 4.4, либо 4.8, либо 8.8.4.4.
То есть, IP-адреса у них простые.
А дальше это по факту записная книжка.
Значит, что у нас находится в корневом DNS-е?
Мы пытаемся найти...
Представим себе, что у нас есть сайт google.com.
Вы не поверите, как представляет этот адрес DNS-сервер.
Он берет, его разворачивает,
и на самом деле мы с вами обращаемся к адресу .com.google.
То есть, сначала мы обращаемся к домену первого уровня .com.
То есть, нам нужно найти IP-адрес нашего сервера,
на котором находится книжка домена в первом уровне .com.
Дальше нам нужно идти на книжку второго уровня.
То есть, нам, допустим, говорят,
что доменная запись .com находится по IP-адресу 4.2.
Тогда мы идем и обращаемся с вами на IP-адрес 4.2.
Это доменная локального уровня .com.ru и так далее.
И говорим, пожалуйста, где у тебя находится запись .google.
Мы идем на запись .google.
После этого он говорит, окей, у меня есть такая запись,
пожалуйста, иди по такому IP-адресу.
И после этого мы идем как раз по этому адресу
и отправляем запрос.
Как раз.
Дополнительно мы можем отправить еще на доменную второго уровня,
третьего уровня и так далее.
И, в принципе, вот такая записная книжка у нас с вами есть.
Когда вы будете покупать, допустим, свое доменное имя,
у вас такая книжка откроется.
То есть, вы берете, покупаете себе доменное имя,
и дальше у вас появляется запись вашей книжки.
Такая многоуровневая хэш-таблица.
То есть, у нас есть хэш-таблица первого уровня,
второго уровня, третьего уровня.
Более того, эта хэш-таблица не с уникальными IP-адресами.
На самом деле, может быть несколько IP-адресов
на одно и то же доменное имя,
чтобы распределить нагрузку на сервера.
Каким образом проверить эту вещь?
Есть утилита, на самом деле их две.
Первая утилита это DIC,
а вторая утилита это NSLOOKUP.
И давайте я ее покажу.
Давайте попробуем.
DIC MIFTRUE.
Итак, мы с вами сейчас сделали запрос
на доменный адрес MIFTRUE.
И что мы с вами видим?
Мы с вами видим интересную вещь.
Мы хотим получить запись A.
Нам ответили, что запись A находится
по вот такому IP-адресу.
То есть, 192, 188, 189, 147.
При этом, что мы видим?
Мы при этом видим, что у нас есть еще и дополнительные запросы.
То есть, у нас на самом деле здесь есть два нейм-сервера.
То есть, либо GW.MIFTRUE,
либо NS8L2NICRUE.
И дополнительно у нас есть секции,
где IP-адреса.
То есть, в принципе, у нас два доменных нейм-сервера
могут отвечать на наши страницы.
Давайте попробуем пропинговать
из нашей сети.
Значит, это пинг.
У нас отправляются пакеты отсюда.
Давайте попробуем то же самое сделать
на другом компьютере.
Кто видит разницу?
Еще раз.
Я не знаю, как это сделать аккуратненько.
Вот так вот сделаем.
Кто-нибудь видит разницу в ответах?
Второго IP-шника нет.
То есть, из-за того, что я ловил,
второго IP-шника нет.
То есть, из-за того, что я нахожусь в локальной сети Fistech,
у меня есть еще один внутренний нейм-сервер,
через который мы можем быстрее получить ответ на запрос.
И за счет этого есть интересная возможность
в сети Fistech.
Оно заключается в том, что если даже у вас
нет подключения к интернету,
к внешнему интернету, допустим, у вас доступа к аккаунту нет,
вы все равно на все ресурсы сайта MIFTRUE попадете.
Вот, вы просто пойдете по-другому.
Не по внешнему доменному адресу, а по внутреннему доменному.
Нет, не только MIFTRUE,
но все внутренние сервисы сайтов Fistech вы на них попадете.
Вот такая вот интересная вещь.
Утилита полезная, есть еще утилита NSLOOKUP.
Ну вот здесь видно, что у нас немножко разные ответы,
потому что здесь у меня через роутер все идет,
а здесь у нас идет через локальный сервер.
То есть у нас один из серверов спокойно ответил.
Вот, так, понятно, как работает DNS на первом уровне?
Так, давайте я еще один эксперимент сделаю.
Собственно, как это записная книжка выглядит?
Вы можете купить любое доменное имя, допустим, на сервисе Regru.
Господи.
Это не робот я.
Кота с SMS не показываем обычно.
Так, смотрите, вот они доменные имена,
которые у меня есть.
И, шобственно, что мы можем с вами сделать?
Мы можем с вами настроить доменные адреса, доменные сервера,
и давайте это сделать.
Внутри вот этих доменных имен.
Вот, вот, вот.
доменные адреса, доменные сервера, и давайте покажу
на примере, допустим, на примере AhChek.ru, допустим,
сервисы.
Вот, значит, и вот здесь как раз вот эта вот записная
книжка, она здесь есть.
То есть, видите, я не знаю, видно или нет, то есть на
какие получается у нас A-запись, и она указывает, куда мы
именно нашу страницу перенаправляем, на какой IP-адрес.
Значит, после этого, как вы обновите запись, она,
по идее, должна доехать до всех провайдеров.
Вот, то есть видно, как оно работает.
Звездочка, это означает, что любой символ, кроме
точки до точки, собака здесь тоже есть, кстати, вот,
это, собственно, когда вы вводите адрес AhChek.ru, то
у вас автоматически все перенаправляется на вот
этот IP-адрес, на один IP-адрес определенного сервера.
Вот, то есть и, в принципе, вот здесь вы, когда покупаете
имя, вы можете добавить одну из записей, которая
вам нужна.
A-запись используется для серверов, NS – это name server,
TXT – это метаинформация, и есть еще доменная запись
типа MX.
MX используется для почтовых серверов.
То есть это просто соглашение протокола DNS.
Вот, просто, чтобы вы понимали, откуда это все берется.
Значит, сразу скажу, как только вы обновите эту
запись, информация не сразу будет обновлена.
То есть вам нужно будет обновить все доменные серверы.
Вот, это обычно по соглашениям на это может идти до 24 часов.
Ну, потому что обновится запись.
У меня, кстати, домашний провайдер самый медленный.
Почему-то он обновляет эти записи в течение двух-трех
часов.
Вот, поэтому мне нужно идти в другую сеть для того,
чтобы это все отработало.
Так, вот она книжка.
В принципе, у любой сети, где вы покупаете доменные
имя, такая книжка должна существовать.
Так, ладно.
Мы с вами поняли, как по доменному адресу получить
IP-адрес, по доменному имени получить IP-адрес.
Угу, хорошо.
Теперь, смотрите, мы подключились к нашему адресу по какому-то
сетевому протоколу.
Как понять, куда идти?
Вот, смотрите, мы идем по адресу, допустим, 192.168.04.
Вот мы вводим в браузере адрес, ну, то есть, допустим,
мы поняли, что IP-адрес у нас находится здесь.
Что делать?
Наверное, должен быть какой-то способ, который нам позволит
определить, куда нам именно идти по этому IP-адресу.
Мы с вами сказали, что IP-адресов на все устройства не хватает.
А это значит, что IP-адреса у нас каким-то образом должны
повторяться.
Так вот, здесь у нас возникает понятие сети, в которой
находятся несколько устройств.
И на уровне IP-протокола, когда мы находимся в определенной
сети, каждому компьютеру выдается IP-адрес в этой
сети.
То есть, изначально у нас есть внешняя сеть, во внешней
сети у нас с вами есть разные веб-серверы, которые имеют
IP-адреса.
Вот.
И каким образом понять, как у нас идет перенаправление
запроса?
Здесь нам очень сильно как раз поможет такое понятие
как таблица маршрутизации.
Значит, в чем она заключается?
У нас с вами, представьте себе, есть система, и в таблице
маршрутизации, это, допустим, таблица маршрутизации
моего роутера, указывается, что если вы вводите определенный
IP-адрес, и у вас IP-адрес совпадает с определенной
маской сети, то вы идете по такому-то адресу.
То есть, вы перенаправляете ваш запрос на определенный
IP-адрес.
Соответственно, дальше, когда мы доходим до вот этого
устройства, у нас идет перенаправление дальше.
То есть, у нас по факту это выходной канал нашей сети.
Вот.
И в итоге цепочка перенаправляется по сети.
Сразу я покажу большую картинку.
Вот такая большая картинка.
Значит, это специальная нотация синтаксиса.
Это, к примеру, у нас с вами какая-то интересная сеть.
Да, то есть, у нас с вами, получается, есть два компьютера,
которые находятся, допустим, в сети одного кабинета.
Вот это у нас сеть лаборатории, а вот это у нас выход внешняя
сеть.
Видите?
То есть, на самом деле все намного сложнее.
То есть, когда вы отправляете запрос в интернет, то вы
скорее всего находитесь где-то вот здесь.
Вот у вас определенный компьютер.
Значит, дальше вы отправляете запрос в интернет, и вам
нужно каким-то образом перейти через эти сигналы.
И здесь есть несколько устройств, которые вам помогают.
Значит, устройство вида V1 – это, на самом деле, как
раз шлюз, через который вы отправляете протокол.
И здесь как раз нам нужна таблица маршрутизации.
Значит, в чем она заключается?
Коммутатор, на самом деле, просто перегоняет трафик
из одного места в другое.
То есть, у вас идет переключение между сетями.
А вот в нашем случае R1 и R2 – это как раз так называемые
свечи, которые позволяют вам переключиться на определенную
сеть.
И видно, что оно подключено к разным сетям.
Значит, у, получается, здесь у R1 по протоколу Ethernet1
есть IP-адрес 192.168.1.1.
А в этой сети это IP-адрес 10.10.2.1.
Вот.
И дополнительно мы видим.
Видите, здесь пунктирные стрелочки.
Это выделенная сеть.
То есть, в сети LAN1 у нас с вами выделяется диапазон
IP-адресов.
И этот диапазон IP-адресов 192.168.1.0.
То есть, получается следующее.
У нас с вами два компьютера имеют IP-адрес 192.168.1.10.
То есть, по факту, наше устройство должно выдать
IP-адрес в нашей сети.
То есть, у нас получается два IP-адреса, по которым
можем общаться.
А дальше по маске сети мы можем с вами понять, куда
именно идти.
Так, давайте я спрошу.
В школе, значит, когда сдаете EG по информатике, есть такое
понятие, как IP и маска сети, но обычно про него не понимают,
как это работает.
А, уже убрали?
Ну, хорошо, тогда мне придется вам рассказывать, что это
такое.
Итак, значит, что такое маска сети?
На самом деле, когда мы представляем наш IP-адрес,
то мы можем создать бинарную запись этого всего диапазона
в виде маски.
Значит, что представляет собой маска?
Это, по факту, идентификатор того, в какой именно сети
мы с вами находимся.
Маска сети состоит из некоторого количества единиц, и после
них идут нули.
Количество единиц обычно обозначается через слэш.
Давайте рассмотрим пример.
Вот, допустим, маска сети у нас 24.
Ее можно зашить еще таким образом.
255, 255, 255, 0.
Представим, что IP-адрес нашего компьютера это 192, 168, 1, 110.
Вот.
И дальше мы говорим следующее, что у нас с вами нужно определить,
по какому протоколу мы с вами едем.
То есть, у нас IP-адрес сети, и нам нужно определить, куда
мы едем.
Значит, что мы делаем?
Мы рассмотрим, допустим, мы хотим с вами попасть в
компьютер 190, 20, 168, 1.20.
Нам нужно понять, являются ли эти устройства в одной
сети или нет.
То есть, по какой сети мы едем.
А что мы берем?
Мы берем, значит, вот это у нас SRC, вот это у нас DST.
Значит, мы берем побитовое I, SRC, I-маск, и сравниваем
его с DST-маск.
Вот.
Если они совпадают, то мы находимся в одной сети.
То есть, получается, побитовое I здесь 192, 168, 1, 110.
То есть, получается, побитовое I здесь 0.
Здесь побитовое I тоже 0.
Это означает, что мы, в принципе, можем отправить
сигнал по одной и той же сети.
Вот.
И обычно, если мы, если у нас есть какие-то правила,
то в конце мы ставим следующую сеть.
0, 0, 0, 0, slash 0.
То есть, что это означает?
Это означает, что мы не ставим никакой порог на
IP-адрес.
То есть, мы вводим любой адрес, и именно когда мы
вводим любой адрес, то обычно это перенаправляется
на внешний протокол.
Ну, а давайте в качестве эксперимента рассмотрим,
куда мы едем.
Вот.
Давайте таблицу маршрутизации открою.
То есть, они обычно выглядят вот таким вот, вот таким
способом.
То есть, у нас получается, что, видите, в каждом IP-адресе,
в каждом сетевой маршрутизации у нас есть адрес сети, в
котором мы обращаемся.
То есть, если у нас IP-жник попадает по какой-нибудь
сети, мы идем по определенному выходному адресу и перенаправляем
наш сигнал.
Вот.
Давайте посмотрим, как мы выйдем в интернет в данном
случае.
Вот у нас адрес сети 4.0.
Значит, мы вводим наш IP-адрес.
После этого мы перенаправляемся на адрес шлюза 10.10.2.2, выходной
в интерфейс Ethernet 1.
То есть, смотрите, 10.10.2.2 мы перенаправляем, мы доходим
до вот этого, извините, до вот этого маршрутизатора
и идем в интерфейс Ethernet 2.
То есть, мы выходим в другую сеть.
Дальше, значит, Ethernet 2 устройства нам нужно понять, в какой
коммутатор мы с вами идем.
Значит, здесь у нас тоже есть сетевые протоколы.
Нам нужно понять, в какой IP-адрес куда мы перенаправляем.
Здесь нам поможет как раз адрес шлюза.
То есть, вот он 10.10.2.2.
Соответственно, у вот этого устройства IP-адрес 10.10.2.2.
Вот видите, здесь написано 10.10.2.2.
То есть отсюда нам сразу, как только мы выходим из
коммутатора, мы идем в другую конкретную сеть.
То есть, если бы в IP-адресе было бы написано 10.10.2.3,
то мы бы пошли в устройство вида R3.
Дальше мы доходим до нашего коммутатора R2, на маршетизатор
R2.
И здесь у нас указывают следующее.
IP-адрес, у нас внешняя сеть, поэтому мы идем в IP-адрес
шлюза и выходной интерфейс Ethernet 0.
То есть, мы выходим в выходной интерфейс Ethernet 0 и мы уходим
во внешнюю сеть.
Так, то есть, вот у нас идет маршетизация.
И если мы хотим дойти до третьего компьютера, то
мы с вами, допустим, указываем IP-адрес какой.
Давайте в качестве примера.
Давайте посмотрим на вот этот IP-адрес.
У нас компьютер находится вот здесь.
Так, давайте посмотрим.
Так, хорошо.
Вот мы находим наш компьютер, наш сети.
Куда мы едем?
ISR1.
Давайте поймем.
По какому адресу у нас подходит соединение.
Да, смотрите, 10, 10, 2, 3.
Почему?
Потому что берем битовое и последних 30 значений.
Давайте разложим это.
Вот он наш IP-адрес, соответственно, маска сети у нас здесь
в конце.
Это вот такая маска сети.
Наберем битовое и получаем, сколько?
172, да, здесь у нас будет получается 3.0.
У нас получается 172, 16, 3, 2, то есть они идут по убыванию
приоритета.
Окей, значит, мы идем в 10, 10, 2, 3.
10, 10, 2, 3 – это у нас маршрутизатор R3.
И что у нас здесь, какой адрес у нас здесь подходит?
4,0 на самом деле, он имеет большую дистанцию, поэтому
мы идем по возрастанию дистанции.
Вот, у нас адрес 172, 16, 3, 0 подходит.
Сколько там?
Да, 0,28.
В принципе, маска сети подходит.
Мы идем в интерфейс Ethernet 1.
А где у нас интерфейс Ethernet 1?
Вот он у нас Ethernet 1.
Вот у нас выходной Ethernet S1, и мы попадаем как раз в нашу
сеть, и как раз коммутатор-то знает, где у нас IP-адрес
этого компьютера.
Вот он.
То есть он перенаправит его нам на текущий компьютер.
Вот.
Значит, на самом деле есть утилиты, которые показывают,
каким образом мы с вами можем дойти до той или иной
сети.
То есть показывают таблицу маршрутизации.
Значит, команда называется IPROUGE SHOW, значит, на линуксе
она не поддерживается.
На маке.
Вот.
Видите?
Вот это таблица маршрутизации моего компьютера.
То есть у нас есть сетевые интерфейсы, и нам показывают,
куда мы именно направимся.
Значит, есть сайт по умолчанию, куда мы идем.
Мы идем в адрес LUSA192.168.01.
Это роутер.
А у роутера таблица маршрутизации уже другая.
Вот.
И вы можете пробить сигнал по любому адресу.
Давайте попробуем.
Вот.
Мы видим весь сигнал по сети и по трафику, который
идет.
То есть у нас идет переключение через эти сети.
А потом мы поднимаемся до уровня IP адреса, а на уровне
IP адреса мы идем дальше.
То есть мы спускаемся вниз.
Ну что, давайте проверим.
Так, сейчас заранее предупреждаю, что здесь будут всякие незаконные
организации.
Допустим, вот такие.
Ну, я должен просто по законодательству сказать.
Так.
Кто здесь интересную запись видит?
Да.
То есть видите, нас в какой-то момент времени перенаправило
на RKN-рестр-фильтр.
Вот.
Хотя странно, все равно, кстати, протокол дошел до определенного
адреса, но просто у нас отфильтровалась информация о том, что мы с
вами попали куда-то не туда.
То есть если мы вводим браузер, тут можно указать именно
тип протокола.
То есть смотрите, он фильтр пропускает, да, но страничку
не отгружает.
Значит, возьмем еще какую-нибудь экстремистскую организацию.
Вот, здесь видите трейсраут другой.
И на самом деле, если мы сейчас откроем вот эту вот страницу,
то вы не поверите, что мы получим с вами.
Так.
То есть нас отгрузили на статическую страницу.
Вот.
А?
Это на уровне провайдера, я из домашнего компьютера.
К нам подключаюсь.
То есть смотрите, если в какой-то момент времени у вас сеть
оборвется, то, в принципе, вы знаете, что делать.
Ну, то есть вы можете прогнать утилит от трейсраута и посмотреть,
где у вас все оборвалось.
Вот.
Это бывает полезно, особенно когда у вас большая система
и непонятно, где сигнал пропал.
Так.
Хорошо.
Есть ли вопросы по маршрутизации?
Сразу скажу, во второй контрольной будет номер.
На это посвященный.
Как вы догадываетесь?
То есть там нужно будет нарисовать сеть.
То есть будет набор устройств, нужно будет выделить сети.
Вот.
Как раз определяются границами маршрутизаторов
и настроить трафик.
Куда?
А?
Не, не, не.
Свою сеть создать, это уже к СИС-админам.
Семнолинистратам.
Так.
Можно ли мы двигаться дальше?
Угу.
Хорошо.
Значит, типы подсетей, которые обычно выделяют,
собственно, обычно создается отдельное сетевое устройство
Localhost, у которого маска сети 32.
То есть мы получаем только на свой IP-адрес.
На третьей я хочу обратить внимание,
что когда вы будете делать задания по докеру или так далее,
очень важно обращайтесь, на каком IP-адресе у вас сервер поднят.
Потому что если у вас указана IP-адрес 172001,
то только ваш компьютер может подключиться к этой сети.
То есть именно только конкретные,
локальные соединения принимаются.
То есть любое соединение по сети будет отвергаться.
Значит, у локальной домашней сети обычно IP-адрес 190.2.168.01
с зарезервированными IP-адресами.
Да, то есть есть именно список зарезервированных IP-сетей,
которые можно найти на Википедии.
Значит, дальше 10.4.0.8 это обычно сеть организации,
в которой вы находитесь,
и 4.0.0 это глобальная сеть.
То есть это просто соглашение, которое выработали люди.
В принципе, при желании вы можете даже постучаться к моей сети.
Правда, вам нужно подключиться к одному этому устройству.
И главное, чтобы Firewall не банил.
То есть не было никаких ограничений внутри сети.
Так, это, допустим, внутренняя сеть моего домашнего браузера.
У роутера, в принципе, видно, что IP-адреса подключаются.
Их можно использовать.
И, значит, здесь мы поднимаемся на уровень выше.
То есть, допустим, смотрите, мы с вами поняли,
каким образом мы подключаемся к устройству,
даже нашли IP-адрес нашего устройства,
поняли, как дойти до него.
Что дальше происходит?
Мы дошли до нашего сервера.
И здесь нужно понять, как двигаться дальше.
То есть как это разворачивать дальше.
Соответственно, здесь нам нужно посмотреть,
каким образом процессы между собой взаимодействуют.
И выделяется 4 обычно способа взаимодействия.
То есть у нас есть способ взаимодействия через файл,
через некоторые API,
через некоторые интерфейс,
Application Programming Interface.
Либо у нас два приложения общаются через базу данных.
И есть еще один продвинутый способ
для выполнения отложенных задач.
То есть там отправка писем и так далее.
Это делается через очередь сообщений.
Про очередь сообщений, наверное, не будем сегодня говорить.
Но в целом эти 4 соимодействия есть.
И они позволяют нам решить работу сервисов.
И нам нужно понять, что же собой представляет API.
API расшифровывается как Application Programming Interface.
Это на уровне приложений.
И нам нужно по факту получить договор.
Первое, это какие команды принимает сервис
и в каком формате передаются данные.
И здесь как раз нам нужно будет понять,
как работает первый протокол.
Это протокол HyperText Transfer Protocol, HTTP,
к которому мы и пользуемся.
Здесь есть информация о запросе.
Сейчас давайте рассмотрим ее детальнее.
Когда мы с вами отправляем некоторые HTTP запросы,
то нам нужно указать.
Первое, это метод.
Второе, это адрес.
И третье, это версию протокола, которую мы используем.
Дальше нам нужно будет отправить заголовки к запросу
и отправить тело запроса.
Давайте я покажу, как это можно сделать.
Для этого мы можем использовать очень простую утилиту,
а-ля Telnet.
Давайте я попробую открыть.
Telnet.
Вам нужно отправить запрос.
Давайте я сделаю очень хитрую вещь.
Ah-chek-ru и укажу порт.
То есть 80-й порт открою.
Я буду обращаться.
И сейчас буду по факту...
Не знаю, видели ли вы такое или нет.
Раньше был способ общения по телетексту.
Вы могли включить телевизор, взять настройки
и открыть текстовый протокол,
по которому можно было читать программы.
Да.
Раньше такое было.
Когда телеки не были умными,
а сейчас же телек умный,
в нем еще всякий программ-передача идет и так далее,
раньше был отдельный протокол текстовый,
по которому можно было переключиться
и так далее.
Там было в редком, в небольшом количестве телевизоров
фотостроенная функция.
Но я, честно, достал.
Итак, значит...
Итак, я подсоединился к IP-адресу.
И дальше мы пишем следующее.
Нам нужно указать один из типов запроса.
Значит, get запрос на получение адреса.
Делаем slash и указываем версию протокола.
То есть мы обращаемся по запросу slash.
Вот, по реквесту на slash.
Значит, метод attack get,
версия протокола 1.1.
Есть.
Дальше мы должны отправить один важный заголовок,
по которому все идентифицируется.
Смотрите, хитрая вещь.
Я сначала укажу host.ahchekru.
Дальше больше ничего не буду передавать,
нажму на enter.
А нажатие на enter нам прерывает запрос
и отправляет результат.
Итак, что мы получили с вами?
Мы получили ответ от нашего сервиса.
Значит, нам пришел ответ.
Раз.
Это версия протокола, по которой нам ответили.
Мы могли увеличить версию,
обгрейднуть версию протокола.
С 1.1 на 2.0.
И дальше нам вернулся статус кодовозврата.
301.
И нам говорят, что это move permanently.
То есть наша страница отправляется
на куда?
Location.
Видите, заголовок нам вернулся.
Location.
Куда нас отправили?
А теперь давайте подумаем внимательно.
Мы на самом деле с вами отправили запрос
по http.ahchekru.
Да, то есть нас перекинуло
на https.
То есть это настройка как раз есть.
Хорошо.
А теперь смотрите прикол.
Мы подключаемся к тому же ip-адресу.
Пишем host.
Но я поменяю host.
Ну вот такой поставлю.
А, черт, черт, черт.
Сейчас, сейчас, сейчас.
Так.
Теперь видно, что я написал?
Я написал
gitlab.ahchekru.
Что?
Нет.
Сейчас объясню.
И чудеса кажется, что мы попадаем
с вами на gitlab.
Объясняю.
Значит, здесь работает два механизма.
Первый механизм
заключается в том, что
нам доменное имя
в первом приближении
на уровне протокола DNS
нужно для того, чтобы идентифицировать ip-адрес.
Дальше мы с вами
отправляем запрос
на конкретный ip-адрес.
Но мы с вами отправляем
заголовок host.
Мы отправляем с вами
заголовок типа host куда-то.
Куда мы его отправляем?
И вот здесь нужно понять,
что именно происходит.
Давайте найду как раз этот слайд.
Это метода запроса.
Давайте я тут сразу пролистаю чуть вперед.
А это работает вот так.
Значит, смотрите.
Мы с вами, с клиента,
отправили запрос на некоторую штуку
под названием веб-сервер.
То есть на самом деле, когда у нас
отправляют запрос в интернет, мы отправляем вон
некоторые веб-сервер.
А дальше веб-сервер уже должен
решить по тому запросу,
к которому приходят,
к которому именно перенаправляют запрос.
И как раз по заголовку host
он определяет,
куда ему во внутренней сети
перенаправит запрос.
И как раз, смотрите,
по хосту ach-check-ru он перенаправляет
на сервис ach-check-ru.
А по хосту gitlab ach-check-ru
он перенаправляет
на другой сервер во внутренней сети.
То есть у него как раз есть записи
по тому, куда именно оно
перенаправляется.
Давайте я покажу эти записи.
То есть я открою веб-интерфейс.
Вот.
Черт.
Слушайте, а у вас gitlab нормально?
У вас клонирование по SSH нормально работает?
Я что-то так подумал,
просто посмотрел это.
Ну не, просто я сразу
зашел на веб-сервер и понял,
что что-то с ним не так, что в нем порту 22.
Вот, значит, смотрите.
Опять же, я показываю это пример
сервера. Значит, и здесь видите,
есть некоторые правила.
Давайте попробуем найти
хост gitlab ach-check-ru.
Видите, то есть если у нас
хост это gitlab ach-check-ru
и путь префикс slash,
то мы перенаправляем запрос
на gitlab web-сервис.
То есть это отдельный сервис, который
у нас работает с gitlab.
А если мы с вами пишем
хост ach-check-ru,
то мы перенаправляемся с вами
на другой сервер. То есть у нас есть
таблица маршрутизации
на уровне запросов HTTP-сервера.
То есть мы должны...
Важное соглашение протокола HTTP,
что мы с вами должны
отправить как раз
хост, заголовка хост.
Без заголовка хост у вас HTTP-запрос не отправится.
Кстати, кто здесь замечает
какие моменты?
Так, давайте увеличу.
Видите, back-ach-ru slash static
и back-ach-ru slash
перенаправляются на разные сервисы.
Один отдаёт статику,
другой отдаёт ru. То есть на самом деле
картинки, которые у вас отгружаются
и сам запрос,
они работают по-разному.
Потому что картинка это статическая
информация, которая нам выгружается,
а запрос на сервер
должны обращаться каким-то
хитрым образом. То есть на самом деле
здесь всё намного хитрее.
И вот как раз при помощи заголовка
хост мы с вами можем
и понять каким образом куда у нас
летит запрос.
То есть сначала наша цель понять
до какого IP-адреса мы доходим, а дальше
уже развернуть этот запрос в зависимости от того
редиректа есть. Вот.
И как раз здесь есть два вида
веб-серверов, которые зачастую
используют. Первый называется
NGINX.
Точнее три они есть.
Один из них
уже по факту
считается устаревшим в нашей стране.
Вот.
А давайте я
наверное их
покажу в Google Trends.
Открываем Trends.
Очень
интересные
запросы нам предлагают.
NGINX
значит HTTP
D
HTTP-сервер
и
Envoy.
Нет, давайте
Traffic.
Это вот как раз вы видели
веб-сервер по имени Traffic.
Traffic Proxy.
Здесь надо NGINX
видимо задать.
Вот.
Значит и давайте откроем Trends
за
NGINX.
Вот такие
Trends.
То есть видно, что
раньше в качестве HTTP-серверов
использовали Apache.
Потом
Trends снизились.
И сейчас активно
работает NGINX.
Ну, активно используется NGINX. Кстати
давайте последние
5 лет откроем.
Вот здесь показательнее картинка.
Ну, это аналитика так
замеряется.
Ну, да.
Не-не, что это за дата такая?
А, так это Новый год.
А?
Да, это Новый год.
На праздниках
мировой.
Вот. Кстати, если посмотреть
по другим регионам, то
картинка будет немножко другая.
Вопрос. Как вы думаете, почему
NGINX в России
популярен?
Посравить со всем
миром?
Не-не-не.
Да, не. Просто все намного
проще. Просто
авторы NGINX закончили
МГТУ мини-Баумана.
Вот.
Это, собственно, российские
системы,
российские наработки.
И, в принципе, NGINX так или иначе умеет
делать много разных вещей.
То есть, по всему миру до сих пор видно, что
используется Apache. А вот Trafic тоже
начинает набирать популярность.
И, возможно, он, кстати, очень хорошо
подходит для контейнеризированных приложений.
Как раз его сейчас на семинаре начали
рассматривать тему по Docker.
И вот Trafic как раз с Docker
отлично дружит.
Вот. То есть, смотрите, мы сегодня рассмотрели
такую низкоуровневую часть.
В следующий раз тогда мы продолжим
нашу тему и пойдем на более
высокоуровневую вещь. Посмотрим, как пишутся
сервера, как выглядят запросы HTTP,
чтобы вы уже могли
с этим там
деталями знакомиться и писать сервиса.
Так. Если есть вопросы, то задавайте.
Чего?
Ну, я не знаю. Тут видно.
Ну, давайте это...
Давайте.
Не-не-не. Видно, видно, видно.
Давайте...
Да, блин.
Ладно.
Ну, слушайте, тут экспедиционный тренд может быть
в любой момент времени.
Все тогда. Если вопросов нет, тогда спасибо
всем.
