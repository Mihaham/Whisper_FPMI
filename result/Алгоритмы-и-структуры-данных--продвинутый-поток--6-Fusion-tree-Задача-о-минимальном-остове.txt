Так, ну, во-первых, да, начнем с того, что наша ставка была, да, что мы, что у нас есть n чисел,
x0 меньше, чем x1, давайте так x2, ну, так соберем немножко, что у нас есть xn-1, вот.
И нам очень хочется научиться искать в них там successor, predecessor
за асимптотику log wn. Вот хочется построить мистическую структуру данных.
С помощью там каких-то мистических b деревьев мы свели эту задачу к ситуации, когда n не превосходит w.
И не просто w, а w в степени 1 делить на 5.
Ну, для наших текущих исследований нет смысла повторять, каким конкретным образом мы это свели.
Мы просто уже поверили, что если мы это научимся делать за,
только вот требуется теперь это делать за от единицы, то и общую задачу мы каким-нибудь образом выкрутим.
Вот. Мы обнаружили следующее. Мы обнаружили, что у нас есть интересные биты.
B0, B1, B2 и так далее, там B, r-1, где r меньше либо равно n, которое меньше либо равно w в степени 1,5.
Так что вот такое вот все весело. Вот такая красота.
Что дальше?
Что?
А, ну вообще да.
Но это уже мелочи.
Вот. И мы объявили себе следующую интересную вещь.
То есть мы сказали, что у нас есть мечта по x получить скетч от x, который равен чью-то в битах.
Правильно для этого мы еще и с индексами что-то там подшаманили.
Вот. А помните у нас тут нолики, вот эти вот они сверху были, да?
Да, что-то я не знаю.
Как это давайте...
Предлагаем, что у нас с самого начала уже сейчас ассортированы?
Нет, ну b-шки-то ассортированы. Они нам даже известны.
Не b-шки, а x-ы.
Ну x-ы да.
Ну как бы мы, как вы уже выяснили, за n log w мы ассортировать умеем.
Ну нас интересует в первую очередь этим дотиком запроса.
Там построение, ну там потом может быть как-нибудь.
Вот. Это мне интересно.
Значит далее.
Значит теперь жил-был вот нод.
Итак, как вот строить скетч?
То есть который у нас по определению равен x там b0, x b1, там x b2, x r-1.
Вот.
То есть ну какая у нас мечта?
Как мы в прошлый раз обнаружили?
Не будем сейчас повторять эту всю масочную магию.
Твоя как звучит, конечно.
Вот.
Значит чтобы не повторять эту нод, мы скажем только, что у нас была бы мечта свести поиск лавербаундов, апербаундов в x-ах к поиску лавербаундов, апердаудов по скетчам.
X r-1?
Да.
X r-1.
Да, да, да, да, да, забыл.
B r-1, да, без условий.
Вот.
Вот.
Но очень хочется как-то это искать вот по скетчам.
И действительно мы обнаружили, что скетчи обладают таким приятным свойством, что, ну то есть по определению интересных битов у нас интересное заключается в том, что x-ы сами по себе можно сравнивать чисто по скетчам.
Вот.
Удобно, правда?
Вот.
То есть вот такая нод.
Оказывается вот очень удобно.
Вот.
Но, к сожалению, выясняется, что если в эти x-ы затерзался рандомный не связанный с ними y, то конкретно сравнение по вот этим b-шкам может ничего не дать.
Действительно, есть у нас такая проблема, правда?
Вот.
То есть это с одной стороны.
Ну, вы, кажется, через нас решили.
Нет.
Нет.
Через маски мы решили немножко другое.
Через маски мы решили, мы сказали, мы вообще забили на скетчи.
То есть через маски мы решили следующее.
Мы сказали, что если эти x-ы мелкие, то есть они тоже не происходят, скажем w в степени 1 на 5, то тогда мы действительно там с помощью красивой битовой магии умеем искать лавербаунд и пербаунд за o от единицы.
Вот.
Более того, мы обнаружили, что в принципе, если там длина чисел будет даже w в степени...
Там либо чисел будет там w в степени 4 поделить на 5, либо длина чисел будет w в степени 4 на 5, это нас тоже устроит.
То есть, ну, по большому-то счету.
Главное, чтобы эти блоки в w уместились.
Ну, или в худшем случае в 2 w, в общем, тоже, наверное.
Все числа на всей своей длиной.
Ну да.
Вот это.
Ну, у нас такого нет, потому что у нас, к сожалению, суммарная длина чисел сейчас w на n, поэтому это нас...
Поэтому так на халяву не устроит.
Но вот уже...
Но, по крайней мере, у нас хотя бы чисел мало, поэтому вот есть мечта как-то сравнивать по b-шкам.
Что делать?
Смотрите.
Ну вот.
Ну вот.
Вот это две проблемы.
То есть, во-первых, как с помощью скетчей действительно сравнивать, а во-вторых, как этот скетч вообще вычислять.
Нам же еще скетч надо золотые единицы вычислить, правда?
Просто так его тут вот это вот не выковыряешь.
Вот.
Ну или пока...
Ну, точнее так.
Если наша задача была бы просто справнивать числа по скетчу, то, конечно, можно было забабахать масочку,
где единицы стоят в интересных битах и ноль иначе.
И тогда n с любым x или там игроком это как раз вот там, так сказать, срезка этих интересных бит.
Но тогда у вас маска будет длинная.
Потому что интересные биты, они могут быть сколь угодно близко к началу, и сколь угодно близко к концу.
Вот.
То есть, тут вот.
Поэтому нам...
Ну, но это мы вот в будущем почешемся.
А пока вот, смотри, сейчас будет самое сложное, что тут есть.
Вот сейчас реально магия начнется.
Тут вот...
Сейчас вот тут надо включиться прям вот по максимуму.
Сейчас, потому что возможно сейчас вот там...
То есть, я не знаю.
То есть, честно, что я, по-моему, суммарно вот над дальнейшим думал где-то дня два.
Ну вот.
И возможно сейчас еще один день будем думать вместе с вами.
Нет, я надеюсь, что нет.
Я себе тут...
Вот, кстати, да.
Просто если тут кто-то говорил о том, чтобы сфотографировать мой конспект, ну, можете это сделать.
Вот.
Так что мясо тут сейчас будет то еще.
Ну, значит, смотрите.
Конспект.
Сейчас будем внимательно понимать, что будет.
А именно.
Итак, давайте себе представим.
Найдем лавербаунд по скетчам.
То есть, пусть обнаружилось, что у нас, ну, скажем, давайте, скетч...
Значит, от какого-то экскратова оказался...
Ну, допустим, я не знаю.
Вот.
Ну, давайте, равная отдельно.
Давайте пока для простоты.
Так.
Скетч от х-степеника меньше, чем скетч от х.
Вот.
От игрок, да.
У наших игрок пришел, да.
Вот.
Допустим, скетч от игрок.
И он оказался меньше, чем скетч, значит, от х-степеника плюс один.
Не в степени, а с индексом.
Вот.
Такая вот красота.
Да.
Значит, теперь, ну, идея такая.
Хорошо.
То есть, допустим, эти лавербы...
Там такие кашки нашлись.
Вот, да.
Такие кашки нашлись и, собственно, хорошо.
К чему это нас приводит?
Давайте у этих вот соседей найдем ЛЦП.
А именно, смотрите.
Прямо по классическому...
А, мы не знаем, что такое.
Exactly.
Ну, формально-то мы не знаем об этом, да.
Значит, смотрите.
Сейчас мы введем.
Давайте.
Вот давайте представим.
Давайте пусть у меня это.
Значит, L...
Значит, Lкт, значит...
Да и так, и так.
Lкт это будет равно LЦП.
Вот.
Так.
LЦП чего?
Получается из скатова или...
Ну, вот скетчей.
Ну, допустим, да.
Скетчей.
LЦП, да.
Скетч обязательно, да.
Скетч от икскатова.
Скетч.
Ну, как сказать?
То есть, я бы скорее сказал LЦП непосредственно скатовый.
Нет, ну, найти их LЦП это как бы...
Ну, мы помним.
Это не проблема, потому что берем их к сор и смотрим,
сколько там в начале нулей.
Или что то же самое к те первые единицы.
Вот.
Да, то есть L, напоминаю, я тут...
Ну, не напоминаю, да.
Longest common prefix.
Во.
Lк плюс один будет равно то же самое.
Скетч.
Значит, х в степени ка плюс один.
И, соответственно, скетч.
От икск.
Вот.
Ну, во-первых, что в таком случае можно заметить?
Вот давайте попробуем теперь мысленно нарисовать борь из иксов.
А точнее то место, где там между ними затесался икс.
Борь из иксов.
Да.
Мысленно.
Ну, мысленно, да.
Мы тут думаем, да.
Как-то это сладновато мысленно.
Зачем это вообще нам надо?
Нет.
А надо нам для того, чтобы вообразить, как эти иксы устроены
и как все-таки найти лавербаунт или апербаунт.
То есть в начале у нас такая идея была.
Мы в начале просто имитировали правый блок чисто на иксах.
А сейчас мы хотим, типа, давайте теперь посмотрим на этот блок, да?
Нет.
У нас цель та же.
Нет, мы хотим найти лавербаунт игрока среди иксов.
Мы нашли лавербаунт игрока среди, ну, по скетчам.
И хотим теперь внимательно посмотреть на дерево иксов
и понять, собственно, как и каким образом этот лавербаунт у игроков
или апербаунт, сейчас как получится, надо искать.
Значит, смотрите внимательно.
Значит, напоминаю, да?
То есть скетчи у нас устроены так, что иксы отсортированы не только сами по себе,
то есть по своим значениям, но и по скетчам, помните, да?
А теперь смотрите.
Итак, значит, жил был корень.
Вот он. Видите, да?
Жил был корень.
И шла от него дорожка.
И шли по этой дорожке три брата.
Икс-к, игрок и икс-к плюс эти.
Но в какой-то момент эти дорожки разошлись.
Ну, начнем со следующего.
Во-первых, я утверждаю, что лк...
Значит, когда же они могли разойтись?
Ну, в первую очередь, конечно...
Что-что.
Ну вот, могло.
Хотя заметим, что лк и лк плюс один, действительно, заметим сами по себе еще.
То есть заметим, что пока...
Во-первых, заметим, что пока икс-к и икс-к плюс один не разошлись между собой,
игрок очень хотелось бы сказать, что игрок тоже находится между ними.
Но это не так.
Да.
Действительно.
Или, действительно, можно заметить в себе следующее, что...
Мы просто можем сказать, что у нас есть такое l,
которое равно lcp от скетч, значит, от икс-к и скетч от икс в степени k плюс один.
Да, мы могли бы себе такое заявить.
Ну а что мы видим?
Видим мы следующее.
Значит, хорошо.
Жил был икс.
Вот икс и икс-к, да, они в какой-то момент, конечно, разошлись.
И, да, на этот раз мы его точно знаем.
То есть этот момент произошел на каком уровне?
Уровень мы не скажем, мы скажем на каком ветвении.
Ну, я бы сказал так.
Этот уровень bl плюс один, я бы даже сказал.
Ну да.
Да.
Это вот очень интересно получилось.
Да.
Ну теперь смотрите.
Так мы были положены, что ветвление там произошло?
Ну, по определению.
Подождите секундочку.
Потому что, смотрите, когда идут иксы,
заметим, что только биты скетча определяют, в какой момент они расходятся.
А почему они не могут включаться в дня скетча?
По определению того, что такое скетчевые биты.
Помните, биты, скетчевые биты, помните, это в точности те биты,
в которых вообще какие-то развилки происходят у иксов.
Вот именно у иксов.
Вот.
Так что вот.
То есть что получается?
Что-что?
Нумерация бэшек у нас с нуля идет.
Может, там все-таки л?
Нумерация бэшек?
Каких бэшек?
Ну, которые как-то интересные биты.
Ну, с нуля, да, что?
Может, они совсем не понимают, что там бэш с 1.
Ну, lcp это количество.
Это длина.
А, ну тогда да, согласен.
Все, уговорили, уговорили.
Уговорили, уговорили.
Значит, теперь?
Ну, а теперь возникает вопрос.
Где от этой всей братьи ответвился игрок?
Привет.
Здрасьте.
Добро пожаловать.
Итак, где от этой всей братьи ответвился игрок?
Ну, у нас на самом деле, да, тут есть.
Гарантировать я могу только одно.
Он не ответвился от этой братьи конкретно в этой точке.
Игрок.
Игрок.
Так что вот, действительно, вот такая у нас тут красота получается.
Но теперь мы думаем вот о чем.
Да.
Потому что, да, у нас тут как бы разветвление прям на три различные ветки.
Такого у нас не бывает.
Вот.
То есть она произошла либо где-то выше этой точки, либо где-то ниже.
Ну, мы можем легко вычислить, где это произошло.
Но давайте внимательно думать.
Внимательно думать на тему того, что делать, если вот игрок, например, ответвился вот сюда.
Ну, давайте без особого ограничения общества выяснилось, что он пошел вправо.
Ну, в общем-то, если влево, понятно, что рассуждения будут симметричны.
Тогда смотрите, что произошло.
Мы можем найти LCP не только по скетчам, но и по, так сказать, обычным эксам.
Вот.
Что-что?
В смысле?
Нет, LCP саму по себе мы ищем за лот единицы.
Если задача...
Да, то есть более интересная задача, это как бы если вот у нас тут вот стоят вот эти вот пум-пум-пум-пум-пум.
И прочие пум-пум-пум.
Да?
Вот, пум-пум-пум, да?
Что?
Да, это уровни вот этих интересных битов.
Развилка, да, помните, развилка не обязана быть на интересном бите.
Более того, скорее всего, если она выше, то ее там и не будет.
Вот.
Но тогда к чему это нас приводит?
Итак, вот допустим, у нас тут...
Ну, где-то вот, допустим, нашелся вот этот вот...
То есть более интересно, конечно, может быть, для нас даже найти, а между какими интересными битами эта развилка вообще произошла.
Вот.
Но, как вы уже догадались, там б-шки сами по себе числа маленькие, поэтому бинпоиск по ним мы за вот единицу уже делать умеем.
Что?
А, потому что у нас уже есть...
Сейчас надо вспомнить, что такое б-шки.
Б-шки числа да в.
А, хотя нет. Да-да-да, согласен. Не так, что...
Не донбух в степени в, да в, это неплохо.
Так.
Их длина.
Ну, да. То есть их да в, да в, это не более чем там...
Не, ну, как сказать?
Да, длина их, к сожалению, да, не очень велика.
Но с другой стороны...
Не, хотя...
Нет, хотя, погодите, это вообще легко.
Потому что...
Нет, смотрите, это-то сделать может достаточно легко, потому что вы просто заводите масочку, где единичные биты, они, анолики, все остальные.
Вот.
И, соответственно, если вы хотите там какое-то число да в, действительно найти, где оно между ними, вы там создаете для этого бита масочку, где, начиная с этого места, стоят все единички, и там делаете энд, все.
Ну, просто смотрите, ваша...
Вот давайте, задача. Да, но число ц.
Вы хотите его вставить вот куда-то в этот ряд, да?
Вот, значит, вставили.
Бум, бум, бум, бум.
И хотите вот найти какой-то ц.
Значит, что вы делаете?
Значит, вы создаете масочку.
0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0.
И так далее.
Где вот это вот б0 бит, это б1 бит, б2 б3.
И так далее.
В конце b-1.
Вот, понимаете, да?
Вот.
А с какой-нибудь ц вы теперь делаете все очень просто.
То есть, по ц вы делаете так.
То есть, по ц вы создаете масочку.
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1.
Где вот, начиная с этого бита.
Ну да, но эту масочку-то вы за 1 как-нибудь выковырите.
А там 2 в какой-нибудь степени минус 1.
Так что это мне не очень интересно.
Вот. Ну а теперь вам остается только по
entity эту масочку с этой масочкой.
И найти первую единичку.
Все.
Поздра.
Да.
Ну вот upper bound будет.
Ну вообще lower bound, если быть точнее.
Ну там это уже...
Нет.
Общий префикс тут ни при чем.
Ну нам было интересно,
дано число c,
да w.
И нам интересно, где, и нам его интересно
найти в вот этих вот битах.
Зачем?
А это надо было для того, чтобы понять,
что вот эта развилка, которая lcp,
где она находится. Да вот.
Как бы вот это вот lcp.
Да.
Но это просто не путать.
То есть как бы это я говорю,
что мы тут применяем черный ящик, а тут я рассказываю,
как этот черный ящик работает. Поэтому желательно их не смешивать.
Нет.
И y сам по себе не до w.
Да,
в двух степени w.
Да.
Но как-то вы хотите
сделать число с битом
на где-то примерно
в два степени w.
При этом то, что у вас w и b.
Нет, в смысле 2.
Мы же здесь что говорим, давайте помещем
числу c.
Да, но c это не y.
c это
lcp y и
x вот этих.
Причем lcp как длина,
а не как 2 в степени эта длина.
То есть условно,
если я возьму их к сорс, сколько у меня там в начале
будет общих ноликов.
Поэтому развилка где-то здесь.
Хорошо, нашли.
Но теперь
что нам надо понять?
Теперь надо понять, какие x
у нас теперь меньше y,
точнее с какими скетчами,
а какие больше.
Но теперь
заметим следующее.
Вот давайте я тут еще побольше уровней нарисую.
Но теперь заметим следующее.
Во-первых,
заметим теперь следующее, что
все x, у которых lcp
с вот этими вот x
то есть ответвление идет
хотя бы здесь или ниже,
они все строго меньше y.
Ну конечно, как всегда.
Ну конечно, это естественно
как-то у нас лево-направо все идет.
То есть с одной стороны,
да, то есть когда у нас все lcp
такие, но с другой стороны, если у нас
развилка,
ну вот, но с другой стороны, что у нас еще может быть?
Ну вот.
Так вот, посмотрите.
То есть на самом деле у всех товарищей, которые доходят
до сюда, ну просто у всех, которые
дошли до сюда, они все по-любому меньше игр,
правда?
Вот.
А еще все, кто, ну вот,
а дальше все, кто ответвляется выше,
чем вот это вот место развилки,
все, кто
выше, они, ну тут
как повезет, тут в зависимости от того, куда
они ответвились, либо они ответвились в левые, они
меньше, чем x-каты,
либо они ответвились
вправо, и тогда
они оказались больше, чем игр.
Вот.
Ну вот.
Но нас интересует, да,
самый правый, кто ответвился.
То есть нас интересует, да.
То есть фактически, если мы ищем вот ближайший
снизу, который там, допустим, меньше
нас,
или там меньше нас, то
мы заметим, что нас интересует,
то есть нас интересует в точности
тот, кто ответвится
вот от x-а, ну хотя бы
здесь.
А как это сделать?
А идея очень проста.
Ведь тот, кто ответвится, кто дойдет
с x-ом хотя бы до сюда,
он имеет скетч, который
в точности совпадает с вот
этими вот битами, как мы вот сюда шли-шли-шли,
и вот с этими битами он совпадает.
Да?
А дальше, ну дальше все что угодно.
То есть заметим,
тот, у кого вот этот скетч хотя бы
дошел до сюда,
то есть тот уже по-любому меньше игр.
То есть фактически у нас появилось практически
необходимые достаточные условия.
Вот, понимаете, да?
Ну вот, практически, кто вот
кто, соответственно, до сюда дошел?
Ну почему?
Ну сами по себе хотя бы xk,
txk плюс 1.
Да, вообще в любом месте.
Да, вообще в любом месте, да.
То есть главное вот тут ответвились, тут, может быть
где-то даже тут, там мало ли.
То есть самое
самое главное, что вот на месте этой
развилки они пошли, ну вот,
то есть они как бы пошли не к игроку,
но вот они пошли вместе с x-ами.
То есть они как бы либо пошли с x-ами, либо когда-то раньше
ответвились.
Но тогда идея такая,
тогда я утверждаю, что все, что нам нужно
это, вот смотрите, если вот взять
вот эти вот, тогда надо взять
вот эти биты.
Значит, все остальные биты объявить
1, 1, 1, 1 там, ну и так далее,
в общем один в скетче, да?
И найти максимальный
x, у которого скетч
не превосходит вот этой штуке.
И получится
ровно то, что нам нужно.
То есть как бы нам второй раз придется
запросить там лавербаун и апербаун
там по скетчам,
но это уже вот единицы.
То есть нам потребуется не один запрос, а два.
Ну правда да, конечно вы помните,
что это мы только один случай рассмотрели.
Нет, потому что нет, нет, второй
случай, нет, второй случай, дело
даже не в том, что там игрок идет вот вправо
или влево, ну понятно, что если влево, то да, там
симметрично. Просто тут будет не
1, 1, 1, 1 допустим, а там будет
в какой-то момент 0, 0, 0.
Да, это не очень интересно.
Просто нет,
есть более содержательный случай,
это если игрок оказался где-то здесь.
Вот.
Ну вот, а вот с этим случаем
вроде как все достаточно тривиально.
Вот, есть ли тут какие-то вопросы?
Пока не умеем.
Научимся.
Нет, научимся чуть позже, да.
Вот мы научимся
это делать.
То есть там отдельный замок
будет сразу.
То есть вот.
Значит теперь, значит теперь
второе. Итак,
снова, жили-были три брата.
Да, двое родных.
Три брата.
Да, двое родных, третьи
затесавшиеся. Вот.
Так, вот давайте, значит.
Так, давайте заново.
Как-то обнулим
картинку.
Да, как говорят в юмористических кругах.
Так.
Юмористических.
Вот.
Так, значит
смотрите. Итак, жили-были опять
жили-были опять
жили-были опять три брата.
Значит, xk, yk,
xk плюс один.
И были у них k и k плюс один сверху,
а не снизу.
Вот.
И обнаружили мы, что
до места, где братья xk
и k плюс первый расстались,
игр шел вместе с ними.
И обнаружили, что
если один пошел по короткой дороге,
другой по длинной, то игр по средней
пойти не мог.
И вот там была только бинарная развилка.
Вот.
Поэтому, значит,
поэтому игр куда-то с кем-то
пошел.
А.
Если смотреть на sketch
xk и xk плюс первое,
то у них то это место,
sketch совпадает об этом вместе
развилки, они означают суть.
Ну да.
А у y?
Часто же совпадает, но
не только sketch.
Да, мы же
с отдельной lcp-шкой выясняем,
где тут ответвление.
И вот мы выяснили, что оно где-то ниже.
Погодите.
А, сейчас подумаю.
Сейчас подумаем еще.
Смотрите.
Потому что и пошел у нас x, и пошел у нас,
допустим, туда игр.
Вот.
Вот.
Смотрите, что могло бы...
Это произошло, напоминаю,
на уровне, как вы помните, bl.
Ну вот.
Тут это и тут
xk, допустим, плюс 1.
Вот.
Ну, в принципе, на самом деле,
отсюда можно автоматически выяснить,
что на самом деле вот это число
и вот это число явно совпадают.
А, впрочем, это...
Ладно. Вру-вру-вру, это неправда.
Вот.
Господи, зачем эти числа определили?
Они не нужны нам вообще. Вот.
Ну, потому что дальше...
Теперь смотрите.
Ну, сами по себе вот эти l-ки
может не обязательно.
Видимо, они нужны были только для того,
чтобы ввести log с common prefix и убедиться,
что мы их умеем считать.
Да. А так нужны ли они нам
или какие-то другие lc?
А это уже другой вопрос.
Но, как я уже сказал,
мы не срисовываем заклинания,
мы работаем мозгом.
Вот. Значит, смотрите.
Вот.
Вот, допустим, пока без ограничений обществе
он пошел вместе с xk.
Как всегда, если xk плюс 1, значит, симметрично
обсуждаем потом.
Теперь еще. И пошли мы на
xk.
И ответвились.
Если нам фортануло, и он ответвился
в сторону соседа,
в сторону xk плюс 1,
то что надо в этом случае делать?
Играть.
Да. И меньше, чем
xk плюс 1.
То есть на этом все с вами были, подписывайтесь.
Соответственно.
Да.
Да, можно даже заранее
проверить, что если мы по скейтчу нашли
xk и xk плюс 1, и нам фортануло игр
действительно лежать между ними, то, в общем-то,
больше можно ничего не делать.
Но нам могло не фортануть.
Вот.
Как это?
Как бы это могло произойти?
Вот такая ситуация.
Вот.
Вот.
Вот, собственно,
где-то оно
куда-то
не туда пошло.
Ну, теперь думаем, да, где
это могло произойти?
Это опять произошло,
как это уже у нас неоднократно
бывало, между какими-то
двумя битами.
А может, даже, кстати...
Да, здесь он мог
на какой-нибудь уровень напасть, это да.
Ну, а мы попробуем
как бы
сделать рассуждение.
Мы попробуем сделать рассуждение, которое
нам, в общем-то, с этого
сильно не поможет.
Вот. Ну, теперь думаем.
То есть мы понимаем,
что, нет, пока мы идем здесь,
вправо никто не ответвился.
Ну, пока вы идете здесь.
Вот здесь вот ответвление вправо быть не могло.
Согласны?
Ну, я отвержаю, что пока мы идем здесь,
вот по игроку, вот тут вправо
ответвиться никто не мог. Кроме вот
xk здесь.
Да.
Да, потому что
вообще, на самом деле, от xk тут просто
сюда никто не пойдет.
То есть, заметим маленькую
приятную вещь. Опять.
То есть, мы заметим маленькую приятную вещь,
что все ответвления, которые
попадают вот между y и
xk, они находятся
вот где-то вот
здесь.
А, то есть мы сверху даже
между xk плюс 1 и xk мы даже не могли
влево пойти, ну когда мы отключили?
Нет, вправо-то мы могли пойти, но мы уже не случайно
быстро выяснили, что если мы пошли вправо,
то мы уже победили, значит просто игрок лежит
по значению между xk и xk плюс 1.
Нет, нет, в этой ситуации у нас нет
никаких игроков, которые идут вправо уже, когда мы не
ели xk плюс 1. Конечно.
Это раз, а во-вторых, могут ли они пойти влево
между точкой ответвления y
и верхней точкой ответвления
xk плюс 1? Вот между этими?
Да, да, да. Влево они пойти
конечно будут. Да, вот этого
добра тут, конечно, навалом.
И тут этого добра навалом, и даже вот
вот такой, вот так вот.
Вот перевернутый
елочка.
Знаете, самое грустное в этом конспекте
заключается в том, что там этих картинок не было.
Там
написан какой-то абстрактный
мутный текст.
Поэтому
по этим
по мотивам каких-то обрывков фраз, которые
видел, пришлось что-то подобное придумать.
И то у меня в конспекте
не это написано.
Так что, да.
Ну, не важно.
Тут, как всегда, сам, как вы помните,
самое главное, это все мелочи уметь додумывать.
Вот.
Так вот. Значит, поехали.
Значит, тут всякое могло быть.
Ну, значит, теперь давайте думать.
Кто такие
числа, которые...
Кто такие вообще могут быть числа,
которые больше
y?
Ну, во-первых, те x,
которые больше y,
они явно те, кто должны были
отвитвиться.
Ну, по крайней мере, вот здесь должны
идти либо вместе с y, либо отвитвиться
куда-то вправо. Правда?
Вот.
Нет, когда сверху
вот эти числа, они больше, чем...
Но если они пойдут влево, они меньше.
Вот.
Ну, вот.
Ну, вот.
Вот, либо, значит, если они
доходят до сюда, то скетч вот этот вот.
То, по крайней мере, вот эта часть скетча,
которая на вот этих вот...
Вот так вот.
На вот этих скетчах.
По крайней мере, она должна до сюда
либо совпасть либо стать pug localized. Правда?
А вот если она уже
дошла до сюда, да, то есть понятно,
что есть она дошла до сюда и пошла в нужную
сторону,
то есть вот до сюда, это в смысле первый, кто...
никто находится строго до ответвления игрока, а дальше, да, но с другой стороны
дальше все просто, то есть те кто дошли, они уже по-любому становятся больше
либо равны игрока, и тогда отсюда означает, что нам просто с вами нужно
найти lower bound, то есть опять по скетчам у х, то есть взяв вот это вот за префикс,
то есть вот это вот то, что было за префикс, а дальше тут все забить нулями.
И это получится как раз в точности там минимальный х, который там не меньше игроков.
Нет, то есть он как бы, смотрите, просто х, если он как бы...
Ну если пошли влево, то меньше, если пошли вправо, то больше.
Да, поэтому фактически надо просто, поэтому надо вот этот префикс сохранить,
а тут просто забить нулями и найти lower bound.
По скетчам, обратите внимание. Вот, собственно, ну вот.
То есть вот такая вот технология, то есть не эти LCP надо искать.
Да, на самом деле нам потребуется искать LCP у самих х и игроков, а не скетчей.
Ну вот, и собственно, ну да, то есть по этим, по ним придется вам понимать,
куда вы там между бэшками вставитесь, но как мы уже поняли, это все от единицы
тем или иным способом делается.
Да, то есть это все вот, да, если у нас есть какой-то более-менее адекватный скетч,
то действительно все можно сделать.
Вот, хэш тублицо, да, а ну да, хэш тублицо, да.
А, ну да, самое подлое, что если скетч от х равен скетч игроку,
то тоже нет гарантии, что х равен игроку.
Ну ладно, ну ладно.
Нет, мы поверили.
Да, проделав эту операцию, мы поняли, какой второй вопрос надо сделать в этом,
условно, какую-то структуру с лавербаундом и апербаундом для скетчей,
чтобы действительно у игрока найти лавербаунд и апербаунд уже среди реальных х.
Вот зачем мы все это делали.
Что значит подходили?
Так, Тихон, потише, пожалуйста, я вопросу.
Нет, ну смотрите, ну мы здесь, нет, мы сказали сейчас, я вот не понял вопрос,
вопрос, что мы еще раз сделали.
Мы, значит, мы попробовали найти лавербаунд чисто по скетчам.
Обнаружили, что это не точно.
Но мы внимательно посмотрели, как тут все устроено.
Вот есть xk, xk++1, ответвляющийся от него, и где-то тут игр отверсяю всяких.
Мы можем аккуратно разобрать все случаи, когда там, где игрок ответвляется от кого.
И в зависимости от каждого случая, там сделать не более чем один,
еще один запрос в лавербаунд по скетчам,
который даст нам нот, ответ на который это на самом деле лавербаунд
честного игрока по честному иксам.
Ну, смотрите, на самом деле, с точки зрения того, что мы сейчас делаем,
нам пока не особо принцип нот.
То есть нам желательно самое главное одно, чтобы
это было наибольшим в f4 гаторе.
Ну да, там, ну что такое супер скетч, мы там отдельно поговорим,
но пока вот нам действительно не сильно много от этого скетча надо.
То есть в общем-то заметим, что если мы номера вот этих бит
на самом деле как-то перешаманим так, чтобы у них порядок сохранился,
нас это в общем тоже устроит, правда?
То есть если я там скажем b0 поставлю на место b0 плюс 1,
или b1 на место b1 плюс 2, b2 на место b плюс 3 и так далее,
то это нас тоже устроит.
Ну главное, чтобы типа порядок тот же, и биты те же.
Именно относительный порядок, да, конечно.
То есть это нас тоже устроит, главное, чтобы мы потом знали,
знали кто там куда перешел.
Вот, ну вот.
Потому что, то есть мы этим более того сейчас будем пользоваться.
Сейчас мы этим будем пользоваться.
Сейчас мы, соответственно, да, мы поверили, что видимо по какому-то скетчу
мы значит это можем сделать.
Или в случае чего можем потом еще вторую итерацию сделать,
поняв, что изменилось, но в общем принципиально ничего не поменяется.
Потому что да, у нас конечно проблема, то есть наука сильно сомневается,
что по заданным рандомным b-шкам действительно эти скетчи можно реально вычислять,
как я уже говорил.
Вот, поэтому, значит, теперь наша задача
вот по этим b-шкам построить вот такую скетч.
По b-шкам? Да, по b-шкам.
Скетч. Функцию, да.
Которая заол от единицы потом этот скетч вычислять будет.
Ну нам, значит, в идеале хотелось бы, чтобы этот там...
Ну да, то есть смотрите, да, самый тупой скетч, который мог бы быть, да, вообще,
если предположить, что вот мы там...
То есть если ваша структура хранит скетчи, то она волшебная,
то нам в качестве скетча можно было самое тупое, что можно сделать,
это x and вот эта вот масочка с b-шками.
Заметьте, это бы нам подошло с точки зрения этих целей.
Но она нам не подходит с точки зрения этих целей,
что сами скетчи тогда остаются масками размера w.
Это нас не устраивает.
Поэтому, значит, мы сделаем по-другому.
Мы эти биты чуть-чуть подвинем.
Попихаем.
Попихаем, попихаем, да.
Ой.
Так.
Ликвидируем.
Что?
Ну вот. И, значит, смотрите. Итак, наша задача...
Значит, смотрите, как мы будем делать.
Значит, идея будет такая. Итак, у нас есть эти наши b0,
b1, b2 и так далее.
И br-1.
Вот такая вот диспозиция.
Ну вот. Значит, что мы делаем?
Мы по ним сейчас, на ваших глазах,
построим мистические числа
m0, m1, m2, m.
r-1.
Вот.
Значит, они должны быть, во-первых,
от 0 до w.
Вот.
Это первое.
Ну, на самом деле, первое такое.
Должно быть 0 меньше либо равно b0 плюс m0.
Строго меньше, чем b1 плюс m1.
Меньше, чем b2 плюс m2.
Меньше, чем...
Меньше, чем br-1 плюс mr-1.
И, конечно, это должно быть меньше, чем w.
Вот. То есть мы такие вот мки хотим.
Вот.
Зачем? Ну вот.
И на будущее еще интересный факт.
r-1 плюс mr-1
минус b0 минус m0
равно...
Ну, тут вот так наглую пишут.
4 и 5, да.
Да, пора. Пришло время.
Почему?
Ну да.
Фу ты. Сейчас.
Ну, то есть...
Вот так.
Вот так.
Ладно.
Нет, это не блок.
Значит, смысл в следующем.
Я очень хочу, чтобы у нас появилась функция
supersketch.
Тоже функция.
supersketch от вот этого x.
Который вот. То есть от x.
Или вот еще мы ее будем обозначать ss.
Вот.
Такая вот полезная функция,
которая делает следующее.
Значит supersketch.
Значит, смотрите. Делает она так. Жил-был x.
И было у него w-bit.
И только r-bit
были интересными.
Вот.
Пожалуйста.
Так.
Да, все можно в этом мире.
Так.
Сейчас мы вот так вот делаем.
Вот.
B0, B1, B2, B3.
Пожалуйста.
Речь, речь, речь.
supersketch.
Yeah.
supersketch.
Так вот.
Я очень хочу это все.
Вот эти вот конкретные биты.
Допустим, я их там назову как-нибудь.
Давайте я их тут.
z0, z1, z2 и так далее. Ну их значения конкретные.
3 там, z, r-1.
Так вот.
Я хочу их перегнать вот в такую масочку.
Для начала перегнать в такую же масочку.
Только теперь.
B0.
Это вот B0 плюс M0.
Вот на позиции B0 плюс M0 теперь стоит вот этот вот z0.
На позиции B1 плюс M1 стоит z1.
То есть сильно далеко они на этот раз друг от друга не стоят.
То есть они в угодной ряду.
Причем рандомно там относительно внутри как-то.
Вот и так далее.
Вот z, r-1.
Вот это вот b, r-1 плюс m, r-1.
Так, это двойка, если что.
Вот.
И нам очень хочется при этом.
А тут везде понятно нули.
И самое главное для нас.
Чтобы вот эта вот диспозиция была.
О от w в степени 4d.
Да.
Ну вот. То есть более того супер скетч потом в конце
предложит сделать вот у этого результата.
B0 плюс M0.
Ну просто сдвинуть это все типа влево.
По факту вправо.
Вот этот подотрезок он найдет.
То есть вот эти биты конкретно из маски он возьмет и перетащит
вот на эти позиции. Все остальное занули.
Ну типа да.
Вот.
Ну вот. То есть хочется вот в идеале так.
Значит как же мы это построим?
Что-что?
Ну да.
Сейчас кто?
Ну вот.
Значит смотрите.
Но это на самом деле не все, что потребуется от M.
Ну потому что действительно как.
Действительно вообще можно было бы это вычислить.
Давайте подумаем.
То есть как вообще вот действительно это можно было бы выковырить?
Ну понятно, что вы можете создать вот эту вот великую маску B.
Которая равна.
Вот я даже напишу 2 в степени.
Там какие-нибудь B.
И от 0 до r-1.
Нет.
Ну просто вот эти вот.
Ну короче все вот эти биты просто тут единичками.
Ну да. Даже вот я давайте на картинке нарисую.
Порядкой 2 в степени это немножко раз.
2 в степени это как бы вот в эту сторону.
А у нас как бы биты вот так номируются.
Поэтому чтобы не путаться.
Ну да.
Это старшие биты, это младшие.
Но при этом эти биты у нас с меньшей номерацией.
Баналит младший или старший?
Старший.
Вот туда всегда должен быть внимание.
Потому что в другой интерпретации может быть не так.
То есть вот такое вот маска B.
Теперь у нас мечта.
Значит теперь смотрите.
По х мы можем получить х-штрих.
Который будет равен, понятно, х и маска B.
Ну то есть оставили от масочки только интересные биты.
Понимаете, да?
Теперь их надо перернать вот в эти позиции.
Как это сделать?
Вот.
Но идея такая.
Но идея такая.
Давайте теперь заведем х2-штриха.
Который равен х-штрих умножить умножить.
Обратите внимание.
На маску M.
Ну как вы уже догадываетесь, что такое маска M?
Нет, но это то же самое, что маска B.
Только не для чисел B, а для чисел M.
Ну если нам даны B-шки и даны M-ки,
то я могу и по B-шкам и по M-кам такую маску построить.
Правда?
Ну а мы их уберем.
Ну, а мы их уберем.
Ну, а мы их уберем.
Потому что ретурн.
Ну вот, потому что дальше
мы создадим маск, так сказать,
BN,
которая равна, соответственно, в которой хорошими битами
будут как раз вот B0 плюс M0 там вот,
B1 плюс M1 и так далее.
Да, вот тут совсем не точно получается,
конечно, немножко.
Ну, потому что при вот таком умножении,
проблема, что бит B0, умноженный
на бит M0, он перешел не в бит B0 плюс M0,
а куда-то в другое место.
Да, там по-хорошему получится
N минус B0, там плюс M, это вот да,
поэтому, ай, что ж делать, что ж делать.
Вот.
Нет, хотя делать-то все очень просто. Давайте, ладно,
в данном случае начать, давайте конкретно в этом месте без ограничений
общества считать, что это младшие биты.
Ну да, то есть типа да.
Не, ну почему, конкретно здесь считаем, что это младшие биты.
Во всех остальных местах.
Вот так.
Ну, сейчас буду без башки.
Да, нет?
А снизу нижний маск.
А нет, здесь тогда все нормально,
потому что тогда 2 в степени B0, это как раз вот маска,
у которой на B0 там месте стоит 1 и все.
Поэтому теперь это то, что нам надо.
Ну, опять же, а как мы
вот так возьмем маску,
где B0 плюс M0, B1 плюс M1
и скажем, return X2',
ну, то есть просто return 2', M, маск,
B, все.
Ну, потому что в этом произведении есть,
вот когда вот B0 на M0, тогда вот
отправился в B0 плюс M0, вот B1 на M1,
то есть вот это вот отправилось и так далее, и мы все прорезили.
То есть в этом смысле да.
О, а вот это правильный вопрос.
Ну вот, а вот это да,
а это вопрос, который нам крюшки подрезает.
Да, да, да, да, да.
Нет, я сказал мечту, да, но вот правильно, действительно, что у этой мечты есть такая проблема,
что, к сожалению, если у нас оказалось,
что, скажем, Xit плюс Mjt
равно, да, вот так быть,
какой-нибудь там Mkt плюс Mlt,
вот, то есть там Bkt плюс Mlt,
то у нас проблемы.
Вот, спокойно.
Господи, вот, да.
Вот тут, да, тут я удивился даже, что ты,
я уж думал, ты это подумал, что, а, я это все знаю давно,
это уже я лучше пошел.
Поэтому, да, нам с вами
кое-что действительно потребуется поправить.
То есть, да, эти Bшки должны быть отциктированы.
И, соответственно, для любых
i, j, kl
должно быть, что там Bit
плюс Mjt
не должно быть равно Bkt плюс Mlt.
Вот это уже серьезное условие.
Да. Ну, сейчас вот догадываетесь, да,
откуда у нас тут сейчас возведение в степень зачем-то пошло.
Потому что Bsh кто?
А вот ровно для того, чтобы вот это произведение,
в этом произведении вот на там никого не наложил.
Да.
Нет, там проблема, да,
что тут будет, да, если они тут сложились, и тут получился
1 плюс 1 перенос. Так что давайте перестрахуемся.
Да, ну мало ли.
Не, ну часто, знаете, когда мы тут это
начинаем тут асимптотиками заниматься, часто мы там начинаем перестраховывать,
а потом выясняется, что не было необходимости.
Ну вот, но как бы тут, как всегда,
дайте, тут как всегда есть уровень. Сначала уровень достичь, что это вот,
что да, это возможно и возможно за нужную нам асимптотику.
Там потом уже дальше включаются кодеры и начинают думать,
насколько этот алгоритм актуален для практики.
Вот, ну да.
То есть мы вот идем в сторону математики.
Итак, ну давайте думать.
Что же нам тут бедным надо?
Хотя почему бедным, да?
Что нам тут надо?
Ну, давайте так.
Для начала давайте построим какие-то ноты.
То есть давайте просто подгоним
какие-нибудь числа M0 штрих,
M1 штрих просто от балды.
Про них мы говорим, что они несколько нот.
То есть про них мы говорим, что они мелкие,
во-первых, так мелкие же, да, я сейчас
тут я лучше уточню.
А, то есть они очень интересно, они
до, внимание, r в кубе,
то есть вот w в степени 3 пятых.
Вот, то есть видите, пока мелкие, да?
Тут меньше либо равно, тут строго меньше.
Ну, r это и есть w в степени 1 пятая.
А, ну ладно, хорошо.
Не глобально.
Вот.
И мы говорим, значит, хотим, чтобы вот было,
во-первых, вот так, а во-вторых,
было, мы хотим, чтобы для любых
i j k l было верно,
m i штрих плюс b j
равно m k штрих плюс b l,
тогда и только тогда,
когда, соответственно,
i равно k j равно l.
i равно k j равно l.
Ну, то есть, в переводе говоря, мы можем
по вот этим r-числам и r-числам составить r-квадрат
чисел, и нам даже уйти хочется, чтобы все эти r-квадрат
чисел были попарно различны.
И лежали вот где-нибудь вот, и были, и при этом
вот эти числа были там не более, чем r куб.
Вот, уважаемые знатоки, внимание, вопрос.
Ну вот, как, откуда, в чем заметьте,
на сортированность вот это все, то есть, никакие, я,
вот на эти m 0 штрих, никакой сортированности,
не их самих, не вот, хотя нет, их самих так сортировать можно,
но сортированности вот этой штуки мы не требуем.
Понимаете, да?
Впрашивается. Ну вот, давайте, угадайте,
откуда мы эти m 0 штрих, эти штрихи
вообще возьмем?
Эстадаранта.
Нет, кстати, эстадаранта, интересный вариант, можно было
бы действительно посчитать, с какой вероятностью нам повезет.
Нет, ну да.
Но на самом деле...
А ты начинаешь постоянно
отвечать на вопросы ко мне вместо меня, на хрена?
Да.
Да, но иногда ты ответил вопрос настолько быстро,
что непонятно вообще, даже непонятно, невозможно в принципе понять,
понял я вопрос или нет.
Так вот, значит, давайте дальше.
Значит, смотри, ну вот,
значит, как эти m ки взять?
Так вот, кодовое слово, на этот раз жадность.
Почему жадность?
А очень просто, смотрите.
Потому что, смотрите.
Чего? Причем тут жадность?
Потому что, смотрите, если я, вот допустим,
я вот выбираю какие-то числа, тогда если я выбрал какое-то
число m и t штрих, да,
то тогда, если я его выбрал,
то я замечаю, что m ка штрих
не может быть равно
m и t штрих плюс
b шите минус b лт.
Понятно? То есть это
необходимые условия для будущего ка.
Ну, в общем-то, и достаточно, кстати, что интересно, правда?
То есть если, когда мы будем выбирать ка-то число,
надо, чтобы ни для какого i, ни для какого j, ни для какого l
не было верно вот это, правда?
Не, ну почему?
Не, ну что, куб подогнали нормально.
Не, ну как сказать?
Смотрите, давайте попробуем.
Вот это вот нам надо. Ну там отдельная письма.
Поэтому, значит, подбирать эти штрихи можно,
но замечаем тогда следующее, что каждая m и t
дает нам, получается, сколько?
от t от r квадрат
заблокированных вариантов
для следующих, правда?
Даже не о, а не более, чем r квадрат,
но были заблокированных, правда?
То есть я просто скажу, что вот
допустим, я вот скажу, что m 0 штрих просто
от балды равно нулю,
и тем самым у меня заблокируется там n квадрат
состояние, ну даже меньше, потому что там...
За какую разность?
А, ну да, но в этот раз нам начать,
потому что главное, что мы блокируем новых блокированных вариантов
чем r квадрат. Может быть, меньше.
За счет того, что там разные варианты дают одинаковое число,
хотя такого не должно быть.
А, ну если так, разные,
если разностью больших совпадают, да, может быть, заблокировано одно число.
А может быть, вообще так, что m 0 штрих плюс b j t
минус b l оказалось меньше нуля, поэтому он вообще ничего не блокирует.
Но это нам не важно. Главное, что вот
не более, чем r квадрат вариантов заблокировали.
Ну тогда смотрите, мы заблокировали вот r вариантов,
вот из этих, да, вот,
а тем более, что ладно, на самом деле
даже мы еще себе точнее скажем,
что они не равны по модулю r в кубе.
Ну-ка давайте на всякий случай.
Еще круче.
Подставите, это еще сильнее.
Вот. То есть тогда мы блокируем реально там,
скорее всего, реально r квадрат,
ну и столько там по модлю этих разностей.
Вот. Но заметим, что если
каждый новый m к блокирует нам r квадрат разностей,
то r раз выбрать m штрих жадно, мы всегда можем.
Потому что у нас всего вариантов сколько?
r куб.
Удобно, правда?
Вот так. Вот такая красота.
Вот.
То есть отдельная песня, правда, действительно,
можно ли это сделать быстрее, чем z r куб?
Вот это большая такая проблема.
Ну вот. Но я, но на самом деле,
но я утверждаю, что это
не сильно большая проблема.
Ну, например.
Хотя, на самом деле, в данном случае,
нет, можно еще проще. У нас этих b-шек сколько?
r штук, да?
Ну вот. То есть, на самом деле,
ну, б-шек у нас ровно r штук.
Ну, там то, что r меньше кого-то там и другого просто.
На самом деле, я утверждаю, что
эти m-ки, на самом деле, m штрихи можно и
water построить.
Причина, ну идея такая,
мы же запрещенные вот эти позиции,
мы можем хранить там в масочке из ноликов и единичек, правда?
Вот. То есть, идея такая,
просто нам нужно, если мы построим масочку,
в которой все биты, которые равны b-ж
по модулю r3 будут помечены единичкой, а все остальные ноликами,
то тогда запретить что-то нам будет
без труда, правда?
Это чей побитовый сдвиг?
Там немножко циклический, правда, сдвиг, потому что модулер 3, да?
Но тем не менее, но все равно как бы это
суть сильно не поменяет.
То есть, все, что вам останется, это, то есть,
единственное, что у вас делается дольше, чем за o от r в таком разе,
это, собственно, построение такой масочки,
то есть, построение всех разностей между b-шками.
Что ж там?
Ну вот, то есть, ну тогда идея здесь такая, что
ну вот, ну чтобы у нас тут
в точности все разности горели, да?
Ну тогда идея такая, вы берете просто масочку, вот ту самую,
маска b, из всех бит, да?
И тогда я утверждаю, что вы из нее
за o от единицы можете создать масочку b0-bl,
b1-bl, b2-bl и так далее.
Да не, не надо ни на какую обратную там нажать.
Ну просто смотрите, я могу сделать масочку,
которой все эти биты по модулеркуп сдвинуты
на там какое-нибудь число, правда?
Вот, ну тогда давайте я создам масочку,
которая это все сдвинет на b0, на b1,
на b2, на b3 и так далее.
Да, а потом там останется все это проводить.
То есть, в общем-то, я понимаю, что тут, конечно,
могла возить в той стадии, что тут какая-то фурятина, но
нет.
Нет, так что нет, фурятины не надо.
Ну вот, ну это уже ладно.
Ну это разные варианты, но это уже техника.
Вот. Так что получается, что да, по факту
мы эту жадность можем за o от единицы бахать
и да пребудет нам счастье. Но вопрос не в этом.
Вопрос, что делать дальше.
А дальше, по этим м-штрихам,
как вы уже дорадуетесь, мы создадим
м-ки.
Значит, как мы их создадим?
Да, очень просто.
Значит, смотрите, ну тут.
Ну да. Ну, на самом деле, просто идея такая.
Я на самом деле m-штрих по модулю r в кубе менять и не буду.
То есть, все, что мне нужно теперь, чтобы они не совпадали,
чтобы они по модулю r в кубе не совпадали,
мне нужно их попребавлять к ним всем
по r в кубе умножену морквит-константу.
Так что м и т, это просто,
вот давайте попробуем,
м и т-штрих плюс и r в кубе.
Кстати, интересно, вот это нам не поможет?
Включаем.
Так.
Чего еще раз?
Так, нет, погодите.
Нет, смотрите, тут погодите.
Во-первых, пока, к сожалению, вот этой штукой
мы гарантируем только одно,
что m-ки отсортированы теперь.
m-ки отсортированы, равенств нет.
Но, к сожалению, нам нужно, чтобы они были
отсортированы.
Нет, b-ки отсортированы.
Да, но b-ки плюс m-ки от этого отсортированы,
по-моему, не становятся, нет?
Сейчас.
Так, слушайте, действительно.
Независимо.
Ну, в общем-то,
я не знаю.
Так, слушайте, действительно.
Так, так, так, так, так. Нет, слушайте,
очень интересно.
Неужели это все, что нам нужно?
Так.
Нет, погодите.
Давайте в этом смотреть.
Нет, ну, давайте.
Проблема, которая у нас тут возникает,
следующая, b r-1 плюс m r-1,
если мы это будем оценивать как-то,
b0-m0, да?
То есть это равно чему?
Ну, пока пишем b r-1-b0, да,
плюс m' r-1-m0,
и там плюс, ну, сколько там,
r-1 на r в кубе.
Ну ладно, это r-4 это нас устраивает.
Это r в кубе это нас устраивает, даже это в сумме
не более, чем r-4.
Но возник один маленький проблема.
Маленький проблема теперь заключается в том,
что в разность bшек у нас изначально так и было,
что разницу между bшками никто не отменял.
Она может быть что угодно.
Нет, она всегда равна o от w.
Но самое страшное, что она может быть омега от w.
Да, это важно.
Поэтому придется добавить кое-какое
нормализующее слагаемое.
Вот. Ну а какое?
Ну вот. Ну а каким образом?
Подожди, так как бы теперь,
чтобы эти числа действительно подогнать так, чтобы действительно
вот тут было максимально хорошо.
Но для того, чтобы b и t плюс m и t
было адекватным, да,
мы сделаем вот так. Мы тут добавим действительно
одно нормализующее слагаемое.
Может быть немножко подгоночное.
Но равно оно следующему. Смотрите, мы очень хотим, чтобы не совпадать.
Ну вот.
Смотрите, как мы сделаем. Плюс. Смотрите, сейчас будет такое.
Внимание.
w-bd
округленное
округленное
вниз
до
ближайшего
делящегося
на
кубе числа.
Зачем нам это надо?
Ну вот. Ну во-первых, заметим. Ну зачем деля...
чтобы оно округлялось до ближайшего r в кубе,
делящегося на r в кубе, это понятно. То есть тогда мы гарантируем,
что второе, там первое условие... Нет, с первым условием мы пока не гарантируем,
но третье условие пока живой процветает. Правда?
Красно?
Вот я утверждаю, что с добавлением этого слагаемого
вот это условие продолжает жить и процветать.
Потому что то, что мы добавляем к штрихам, оно продолжает
делиться на r в кубе.
Вот. Теперь давайте смотреть,
что у нас появилось
по вот этому балансу.
Ну вот, значит, смотрите.
Значит, по вот этому балансу получается
то, что мы добавляем в следующее.
То есть теперь давайте его думать.
Теперь к чему будет нот?
Ну вот. Ну во-первых, давайте думать.
Давайте так.
Значит, давайте посмотрим. Во-первых,
b и плюс 1 плюс r и плюс m
и плюс 1 минус bt минус mt.
Мы хотим убедиться, что эта штука
больше либо равна нуля. Даже больше нуля, правда?
Ну ладно, нулю она не равна, это мы уже выяснили.
Но теперь заметим следующее.
Что такое теперь bt плюс 1?
Что такое теперь вот это вот mt?
Что это такое?
То есть на самом деле это теперь равно.
То есть равно
минус bt плюс
plus mit штрих
плюс ir в кубе
плюс, ну можно так сказать,
плюс w минус
нечто от нуля dr в кубе.
Согласны?
Вот, понятна такая запись?
Есть кто живой?
Вот.
Кто тогда есть?
Вот, значит, давай. Значит, смотрим дальше.
Значит, m. Значит, дальше теперь смотрим.
Тогда вот эта вот штука, она равна.
То есть если вот bt прибавить, то там будет шлёп-шлёп.
И тогда останется.
Значит, m и плюс 1 штрих, да?
Плюс ir в кубе.
То есть и плюс 1
r в кубе.
Вот, значит, минус 0
r в кубе.
Минус, теперь смотрите, минус mit штрих
минус ir в кубе
плюс нечто от нуля dr в кубе.
Видите, да?
То есть это равно
практически, это равно
наш железных r в кубе
плюс m штрих
и плюс 1
минус mit штрих
и дальше плюс, я вот так пишу,
плюс нечто от минус r в кубе
до r в кубе.
Интересные числа.
Правда, единственная проблема.
Ну вот.
У меня что-то упало.
Вот.
Так.
Но теперь заметим следующее. В принципе, если гарантировать,
что m штрих у меня отсортированные,
если гарантировать, что они у меня отсортированные,
а в общем-то, если мы в каждый момент времени будем
брать самые минимальные из доступных, то это можно себе гарантировать.
Правда?
Но тогда мы получаем, что вот эта штука заведомо больше нуля.
То есть получается, что, ну вот,
то есть она, ну вот,
даже я более точно напишу.
Ну да. То есть это, то есть они, значит,
соответственно отсортированы. То есть эта штука лежит у нас от нуля
до r в кубе. То есть, ну, по большому счету, то есть эта сумма
получается где-то от нуля до
3 r в кубе.
Видите, да?
Ну да, помните, мы когда жадно брали,
нам никто не мешал их брать прям честно.
Просто берем самые минимальные из доступных,
то есть берем там, смотрим, кто у нас в масочке не занят,
берем первый нолик, ну, а это мы все умеем.
Вот. Но самое приятное,
почему я здесь еще точнее написал?
Потому что с одной стороны разность положительная, с другой стороны
она небольшая, не более чем 3 r в кубе. Видите?
Но тогда, если все эти разности сложить,
то телескопически получится, что разность вот этих вот,
она не превосходит 3 r в четвертый.
Что у меня?
Нет, это не микрофон, это шапочка от микрофона.
Ну да.
А что, он его кепочка шел?
Ну вот.
То есть, таким образом получается, что если так подогнать,
то микрофон опять падает.
Ну да, что-то микрофон устал, да.
Ну не волнуйся ты, ну скоро будем что-то еще рассказывать.
Не волнуйся, мы уже победили на самом деле,
как наиболее внимательно поняли, что мы уже победили
на самом деле давно.
А это невольно.
Ой, знаете, да.
Это уже было... Нет.
Нет, ну это да. Ну в этом алгоритме точно помогает.
Нет, знаете, бывают более сложные алгоритмы,
когда полезно их несколько раз рассказать.
Сейчас, чего? Где, где, где?
Где меньше, чем w?
Где меньше, чем w?
Да, проблема, проблема.
Ну да.
Ну как сказать, с другой стороны,
ладно, как решить эту проблему?
Ответ. Вот так.
Вот давайте дубаем.
А вот действительно, если...
Вот как вы думаете, если у нас виртуально мы тут говорим,
что все эти масочки были размера w, а стали размеры не w,
а ну скажем 5w.
Это там сильно вообще Колинкор поменяло?
Вот мы, если у нас все числа гарантируются,
свято гарантируются, что все числа у нас
по количеству бит не превосходят 5w.
Ну, по количеству бит, конечно.
Возникает вопрос, а нельзя ли утверждать,
что мы все равно можем делать в ними все операции
за o от единицы?
Да, это будет более жирное, но o от единицы.
Как бы все равно b шкимки, у нас все равно все мелкие
от w, да?
Ну хотя, видите, поэтому на самом деле
это не так и глобально.
Вот, на самом деле эти все мелочи.
Вот.
Ну вот, соответственно, к чему это нас приводит.
А приводит нас...
Вот это к тому, что мы, соответственно, тогда
научились тогда считать этот супер скетч.
Единственное, конечно, что в этом супер скетче
нам, конечно, потребуется и b шки, и m шки хорошо,
что нам, конечно, потребуется и b шки, и m шки хорошо знать.
Да?
Да, ну это да.
Но заранее за o от r мы предпочитали и b шки, и m шки.
Нет, то нам просто потребуется в любом случае, когда мы
эти lcp будем искать, потому что потребуется и стоит,
где там, что закончилось, правда?
Вот.
Разберемся, куда же мы денемся.
Ну нет, понятно, что...
То есть просто как-то часто бывает в программировании,
когда это кодится, значит, придется в этом разобраться.
То есть классическая реклама.
Помните, Gen2Linux это операционная система, в которой вы можете
сделать все, и вы будете делать все.
Вот. Ну я это уже говорил, конечно, но,
как говорится, это как бы просто иногда лейтмотив
просто программирования.
Вот. В некоторых случаях, конечно.
В остальных случаях работают там всякие эти правила
в духе, что там это... Чем хороший программист
отличается от обычного? Хороший программист знает, что
все, что можно было написать, уже давно написали.
Чем отличается отличный программист от хорошего?
Отличный знает, где достать.
Удачи.
Гениальный программист, видимо, знает, где достать бесплатно.
Так что вот.
В результате получается, что...
Ну вот. То есть в результате получается,
что у нас теперь есть вот такая штука.
То есть теперь у нас есть Fusion 3, мы сумели тут
оказывается искать всякие
лавербаунды, там опербаунды, правда,
в статической версии, но вот за от единицы
в предположении, что чисел мало.
Вот.
А теперь, соответственно, у нас...
То есть более того окажется, что есть
на самом деле... То есть иногда у нас будет действительно
красивая мечта. Красивая мечта будет заключаться в том,
что пока действительно чисел мало, все-таки хотелось бы уметь
и добавлять элементы.
Да.
И добавлять, удалять и что самое интересное искать минимум.
Потому что на самом деле...
Ну вот. Ну потому что следующее,
да, видимо, полностью, конечно, не сегодня, тем не менее.
Вот. То есть на самом деле у нас будет
действительно штука, которая действительно что-то подобное потребует.
Но если вы для маленьких научитесь сокращать
за логарифом, то дальше все остальное, как ни странно,
магическим образом делается все за о от единицы
с помощью очень хитрой амортизации.
Ну очень хитрой, которая, правда, была
изобретена еще в куче фибонач.
Если и не раньше.
Так что да. И с этой... Ну вот.
И, соответственно, с этой помощью тогда
мы... Называется сумеем. То есть, ну, собственно, основное первое,
что мы сможем, это искать основные деревья за о от е.
Поэтому, да, пожалуй, уже действительно сегодня тяжеловато.
Поэтому действительно сейчас, наверное, пришло время перерыва.
А после этого мы займемся чем-нибудь простеньким.
Значит, короче, да, связанный граф, но он взвешенный.
Ну, мы можем считать, что веса...
Но для нашей задачи нам, кстати, даже все равно
более-менее веса бывают отрицательными или нет.
Вот.
Нарисую сейчас какие-нибудь.
И цель, значит, оставить у этого граф...
Удалить некоторые ребра, оставить такие...
Такие ребра, чтобы граф остался связанным и при этом был деревом.
Это называется остов.
Ну вот. Ну, астовов может быть много у графа,
но нас интересует минимальный.
Ну, минимальный, то есть чтобы суммарный вес
этих выживших ребер был минимальный.
Ну, сразу оговоримся, почему отрицательные ребра нам не важны.
Ну, потому что заметим, что в этом случае,
в отличие от, кстати, поиска расстояния в графе,
если я ко всем ребрам прибавлю единичку,
то сам по себе минимальный остов не поменяется.
Потому что у всех остовов вес измерится
на одну и ту же константу, поэтому...
То есть кто был минимальный, тот минимальным и остался.
Поэтому, в общем-то, без сильного ограничения
общества можно считать, что ребра не отрицательные.
Впрочем, не то чтобы это нам даже сильно будет помогать.
Вот. Вот в двух китайцах нам это периодически даже поможет.
Вот в двух китайцах нам это может даже помочь.
Но...
Вот.
И так, значит, далее.
Так вот.
Значит, как же его искать?
Вот.
Ну да, мало того, что да.
Ладно, значит, смотрите.
Значит, как же нам искать мин остов?
Ну, сразу скажем, что алгоритмы построения этого мин остова,
конечно, разные, но базируются они все
в основном на одном и том же жадном соображении.
А соображение звучит так.
Значит, во-первых, ведем понятие...
Вот сейчас надо очень аккуратно формулировать.
Значит, смотрите.
Жадное соображение.
Значит, ведем понятие разрез.
Разрез С и Т.
Это когда мы множество вершин разбиваем.
Вот тут стандартное обозначение вот такое на два множества.
Что означает вот этот знак?
Он обычно означает, что С пересеченное с Т равно пустому множеству.
То есть они не пересекаются,
но их объединение дает так.
А еще нам, конечно же,
еще это не входит в это обозначение, но мы себе добавим,
что С и Т, конечно же, не равны пустому множеству.
То есть мы хотим реально разбирения,
а не типа там пустота в одну сторону, а остальные в другую.
Вот.
Ну вот.
Вот, значит, соответственно.
И мы, значит, теперь можем объявить...
Значит, это вот такое понятие разреза.
Можем говорить, что ребро, допустим,
Е равно УВВ, будем говорить,
пересекает разрез.
Будем говорить.
Пересекает разрез.
Если, ну вы догадываетесь.
Да?
Если У лежит в С,
к сор В лежит в С.
Ровно одно и то же.
Или что то же самое,
одна из этих вершин лежит в одной доле разреза,
а другая в другой.
Ну тут сформулировать можно десятью способами.
То есть одна лежит в доле С,
другая в доле Т, нам не принципиально кто где,
потому что неориентированный.
Вот, кстати, обратите внимание, именно этим у нас поиск
минус 100 будет отличаться от потока.
В потоках нам будет принципиально кто лежит в доле С, а кто в доле Т.
Значит, вот такое вот ребро.
Так вот.
Мистическая теорема.
Тут вот опасно,
потому что у меня в билетах она называется теорема
о разрезе.
Да.
Некоторые студенты потом после этого в этом месте начинают рассказывать что-то про потоки.
Правда всегда, когда такое происходит,
это почему-то на переиздаче, но это другой вопрос.
Ну, по случайному совпадению, не знаю почему.
Ну вот, но это теорема о разрезе,
она же лемма о безопасном ребре.
Вот звучит, вот сейчас мы ее максимально аккуратно сформулируем.
Поэтому ладно, я ее сформулирую как утверждение.
Она же лемма о безопасном ребре, она же теорема о разрезе.
Значит, смотрите.
Пусть.
Значит, допустим, у нас есть так,
значит, пусть tau, значит, под множество e,
но это не просто под множество e,
а под множество,
под множество rubik,
внимание,
какого-то, я даже капсууму пишу,
какого-то минимального асто.
Одного и того же,
по сравнению с кем.
Ну, под множество rubik, да.
То есть какого-то минус того.
Ну, там отдельная песня у вас, даже в домашнем задании,
будет доказать, что если ребра все по парноразличие,
то минус то в принципе один.
Да, не очень красивый.
Ой, нет, точно надо домашний.
Такой красивый дзз начинается.
Ой, там это красивое.
Ой, слушайте, а какой там дзз на компоненты вершины
двух связностей?
Чего?
Да.
Значит, смотрите, так вот.
Пусть это tal под множество минус 100.
Пусть s и t,
разрез,
ну вот,
разрез,
причем
ни одно,
давайте очень аккуратно формулируем,
ни одно из rubber
tal
этот разрез
не пересекает.
Не пересекает.
Не пересекает.
Не пересекает.
Пересекает.
Вот.
Далее.
Чего на чем такой нот?
Так вот, пусть,
значит,
пусть E
равно u, v, w.
Это минимальное
по весу, конечно же,
ребро
пересекающее
кого-то.
Пересекающее разрез.
Вот.
Да.
Ну, традиционно, start, finish,
wait.
Ну, структурка. Еще бывает id.
А как вы пишете графы?
Ну, а у нас вот так.
Так вот.
А вот тут вот максимально,
тут опасно.
Потому что, как бы, что такое tal plus, тогда E можно
добавить в tal, это потребует уточнения, что это значит.
Хотя очень хочется так сказать.
Вот. И очень легко, поэтому я тут формулирую аккуратно.
Тогда множество tal объединенное
с ребром E
является
под
множеством ребр,
под множеством ребр
внимание, какого-то
минимального
астола.
Какого-то.
То есть, видите, тут вот куча мест,
можно ошибиться в формулировке и получить формальную чушь.
Потому что, возможно,
вот это ребро E вот к этому какому-то
миностову никакого отношения не имеет.
То есть, возможно, дерево поменяет.
Вот.
Но главное, что
до какого-то минимального астола дополнить можно.
То есть, в чем
глубокий смысл этой леммы?
Глубокий смысл леммы заключается в том, что у нас теперь есть такой
мета-жадник. Такой мета-алгоритм.
У меня есть tal изначально пустое, да?
И я в него добавляю ребра по одному. Каждое ребро я добавляю
простым образом. Я нахожу разрез, который
не пересекает ребра tal,
нахожу в нем минимальное ребро и добавляю его в tal.
Такой мета-алгоритм.
Ну, потому что мы никаким образом не сказали, как мы этот разрез
ищем и как этот минимальное ребро в нем выкапываем.
Вот.
Ну, вот, то есть, такой вот мета-жадник получается.
Но для того, чтобы его использовать, давайте его,
чтобы к этому не возвращаться, быстренько его докажем.
В общем-то, да, ну вот.
То есть, доказательство очень простое.
Правда, это тоже потребует определенной аккуратности.
Я помню там вот задачки на подобное дело, я помню там вот у вас
будет домашний узнание, я их принимал, там столько способов ошибить.
Там допустить неаккуратность. То есть, такое решение,
которое кажется правильным, но, на померку,
окажется легко запутаться.
Но, как говорится, то есть, если тут сразу правильные мысли,
то никаких проблем не будет. Знаете, смотрите.
То есть, доказательство такое.
Берем, значит, разрез.
От этого нашего тал, веселого, да,
у нас тут были какие-то частички вот эти все.
То есть, вот это вот что-то было, там вот какое-то такое безобразие.
Ну, то есть, тал, понятно, это лес какой-то.
Под лес мимо стола, да.
Некоторые его компоненты могут вообще из одной вершины состоять.
Как это, например, в алгоритме прима будет.
Ну и так далее.
Вот. Видите, да?
И вот мы провели разрез, который его не пересекает.
И вот, наконец, мы берем то самое
новое минимальное ребро в этом разрезе.
Видите, да?
Предположим, что нам фантастически повезло.
Ну, то есть, если нам фантастически повезло,
и это ребро действительно в этом миностове,
если это ребро в нём не лежит, то всё, мы победили.
Но если вот это вот какой-то миностов, он какой-то другой,
то есть, в смысле, вот это ребро в нём не лежит,
то придется сделать более хитрое рассуждение.
Значит, что это мог быть за миностов?
Ну, заметим, что бы там ни было, а между этими двумя вершинами
существует путь, правда?
Существует?
Ну вот, путь откровенно существует.
И этот путь, внимание, хотя бы один раз пересекает разрез.
Обратите внимание, именно что хотя бы один раз.
Почему хотя бы один раз?
Потому что в принципе вот какую-нибудь там ситуацию в духе,
там какую-нибудь вот такую вот...
Чего? Похоже, похоже.
Не понял.
Это не ребро.
Нет, это я просто нарисовал путь.
Ладно. То есть, дорисовал.
Вот, он может пересечь этот астопон сколько угодно,
раз там туда-сюда, любой зигзаг.
Вот.
Но самое для нас главное, что хотя бы один раз он разрез пересечет, куда он денется.
И тогда, смотрите, рассмотрим какое-нибудь ребро, находящееся на разрезе.
Тогда вот у этого ребра вес W,
а у этого W', что больше либо равно W.
Тогда у нас, тогда идея такая.
Давайте удалим.
Тогда заметим, что так как это ребро, как бы, при добавлении его стянулся цикл,
то мы можем удалить это ребро.
То есть, удалить это ребро и добавить это.
То есть, если вот, видите, делать это аккуратно,
то тогда у нас мы просто превратили один астоп в другой астоп.
Ну, раз один астоп превратился в другой астоп, то, соответственно...
И более того, заметим, что мы заменили ребро на ребро, которое не больше по весу.
То есть, поэтому дальше там можно десятью способами рассуждать.
То есть, теперь отсюда следует, что W' на самом деле равно W,
потому что в противном случае вот этот вот синий астоп был не минимальным, откровенно.
Ну, просто мы тупо минимальнее нашли, правда?
Вот.
Но если они равны, то тогда я просто вместо...
В одном минимальном астове заменил одно ребро на такое же
и получил другой минимальный астоп.
Вот, собственно, и все.
То есть, таким образом, видите, аккуратно, что вот этот вот,
этот вот, это какой-то миностоп может быть не такой же, как вот этот.
Но, тем не менее, подогнать можно.
То есть, вот такая вот у нас простоя левма получилась.
Вот, понимаете?
Да, нет, наверное.
Отлично.
Вот.
Ну и, соответственно, тогда первое ребро, которое у нас тут возникнет,
но первая штука, которая у нас тут возникнет,
это, конечно, алгоритм Прима.
Да, почему именно он, непонятно на самом деле.
Правильнее было бы, конечно, начать с алгоритма Барувки.
Ну, как-никак он все-таки появился за 30 лет до Прима.
Ой, в общем, отдельная песня.
Как говорится, жил был электрик, и поручили ему соединить все города Чехословакии
электрической сетью за минимальное число проводов.
И началось.
Вот.
Ну, значит, смотрите.
Ну, мы начнем с алгоритма Прима, потому что, то есть, на самом деле,
конечно, и Прима, Краскал, и Барувка, это все, на самом деле, алгоритмы,
они крайне важны для теории.
Может быть, Барувка даже, может быть, даже...
Для практики уже, да.
Ну, для практики вопрос.
Ну, как бы для теории, я имею в виду с точной зрения, что там продвинутые алгоритмы,
по-любому, будет, наверное, что-то из них, наверное, как основу использования.
Пример, я так с летом не помню, есть вообще алгоритмы какие-нибудь,
которые вообще ничего из этого не использовали как идеи.
Там в Барувке вообще будет такая красота, как шаг в Барувке.
Там вот вероятность там вот в этом алгоритме там классно будет, ну и так далее.
Но это мы доживем.
Там.
Да.
Вот.
Значит, смотрите, что дальше.
А дальше, следующее.
Итак, как выглядит вообще алгоритм Прима?
Ну, алгоритм Прима, да, в дефолтной версии говорит так.
Вот.
То есть, ну, тут какие-то тут вот...
Это все есть, вот это есть, есть, есть, есть, есть.
Вот.
Вот.
Ну, какая-то вот такая красота даже там, нет смысла до конца дорисовывать.
И мы говорим так.
Пока у нас ребер нет, изначально, то есть у нас в каждый момент времени будет...
То есть мы начнем с какой-то стартовой вершины с 0, первой попавшейся.
И мы в нее будем...
И мы будем...
У нас в каждый момент времени текущее подмножство стола будет некой связанным множеством подсоединенным к вершине с 0.
То есть работать будет так.
Сначала мы скажем, что разрез это вот с 0 и все остальное, выберем минимальное ребро.
На следующем шаге мы скажем, что у нас разрез это вот эти две вершины и все остальное.
Выберем там, скажем, допустим, вот это ребро.
Потом вот эти три...
Ой, вот эти три ребра, давайте вот это ребро выберем.
Потом четыре, ну и так далее. Принцип понятен, да?
Классический алгоритм Прима.
В некоторых случаях его даже написать оптимально именно его.
То есть, например, скорее всего мы сталкивались с такой задачей.
Значит дан граф, там каждая вершина это точка на плоскости, их всего 5 тысяч,
а вес ребра это расстояние между точками, найдите миностов.
Ну-ка, кто писал такую задачу когда-нибудь?
Даны 5 тысяч точек на плоскости.
Мы хотим составить, поставить, построить миностов.
Да, мы хотим построить миностов, где ребра не даны в явном виде,
но между любыми двумя вершинами можно провести ребро и его вес расстояния между точками.
Ну вот, нет, дело не в этом.
Нет, дело это, это просто как бы типичный пример, когда Прим с кучей хуже, чем Прим без кучи.
Ну, помните, как до экстра с кучей не всегда оптимально.
Да, вот, ну вот, да, давайте, то теперь давайте проговорим, как это можно реализовать.
Но если в тупую, вот как я сказал, то возможно у вас получится даже ОАТВ.
Ну потому что каждый раз вы перебираете все ребра, из них выбираете кто, кто пересекает разрез,
и кто из тех, кто пересекает разрез, выбираете минимум и добавляете, да.
Но понятно, что как-то, наверное, как-то, как-то, как-то, как-то, как-то, как-то,
но понятно, что как-то, наверное, как-то, как-то, возможно, не все думали, что так вообще можно написать.
Вот, на самом деле можно написать, но на самом деле, конечно, алгоритм Прима очень похож на алгоритм Dx.
Потому что в некотором смысле, вот, помните, мы же с вами обсуждали об общении алгоритма Dx, да.
Так вот, на самом деле, в данном случае, простите, когда вы тут пишете алгоритм Dx,
то же самое, что, практически, что, соответственно, вы ищете кратчайшие пути до вершины и нот,
только, там, путь до вершины, это что-то типа, там, минимально возможные ребра до нее.
То есть, на самом деле, по большому счету.
Ну, то есть, на самом деле, то есть, идея такая, что вместо того, чтобы писать ve,
то есть, на самом деле, есть напрашивающаяся реализация за v квадрат плюс e.
Где вы заводите, вы говорите, что d от v это минимальное такое v,
что там u, v, w, значит, лежит на ребре e, и, соответственно, u лежит в доле s.
Ну, мы поддерживаем такое d, и, там, изначально, вот, и каждый раз, когда мы добавляем,
то есть, выбираем на каждом шаге минимальную d, да, то есть, вершину, которая не лежит в s с минимальной d,
то есть, получается, вершину, которую можно подцепить к нашей компоненте за минимальное ребро,
говорим, что там u, z от v равно true, и релаксируем.
Так, надо подробнее рассказывать.
Ну да, думаю, не надо.
Да, вот. То есть, вот это вот классика.
Ну, хорошо.
Но тогда, как мы уже с вами догадываемся, этот v квадрат плюс e, если e не очень большое,
то есть, как всегда, если у вас там классические v сто тысяч, e двести тысяч,
то, наверное, можно это реализовать по оптимальне.
А именно, если d хранить, например, не в массиве, а в каком-то сете.
То есть, как бы, то есть, это вот, ну вот, то есть, если мы там добавим set и какой-нибудь hip,
то тогда у вас получается o от e лог v.
Да, здесь v плюс e на лог v писать не надо, потому что e здесь заведомо не меньше, чем v минус 1, кстати.
Да, приятная наука.
Вот.
Но, как бы, непонятно, ну и как, и видим, что да, бывает, что этот алгоритм лучше, если e порядка v квадрата.
Бывает, что этот алгоритм лучше, если e значительно меньше, чем v квадрат.
Внимание, вопрос.
Какая итальянская фамилия упоминалась в прошлый раз, когда у нас возникали такие,
какие-то подобного рода терки?
Да, фибоначи, совершенно верно.
Потому что, если у нас есть куча фибоначи,
то мы обнаруживаем, что в куче фибоначи мы только удаляем минимум за от логарифа,
а все остальное мы делаем за от единицы, понимаете?
И тогда это получается, что там, то есть как бы все, что мы делаем от единицы, включая уменьшение.
То есть, если мы элементы не хотим удалять, но хотим уменьшить, то это тоже делается за от единицы.
Помните, да?
И за счет этого у нас получалось e плюс v лог ве.
Но, в принципе, технологии абсолютно как в dx повторяться смысла нет.
Вот, тут все просто.
Значит, куча фибоначи, e плюс v лог ве.
E плюс v лог ве.
То есть, вот таким вот образом мы можем написать.
Вот.
Но, соответственно, тем не менее, можно попробовать написать еще круче.
Вот.
Значит, смотрите.
Все еще можно сделать.
Да.
Но это я, конечно, сделал обзор, действительно, какие версии алгоритма Приба у нас есть.
Вот.
А сейчас же я расскажу, как говорится, алгоритм за более веселую асимптуль.
То есть, сейчас то, что я расскажу, это будет называться алгоритм Фредмана Тарьяна.
Да, Фредман это вот один из создателей вот там, там всей той теории, которую мы тут изучаем.
Вот.
И так, Фредман Тарьян.
Или Таржан, я уже даже не знаю.
Ну, вот.
Значит, Фредман Тарьян.
Значит, наша ставка будет следующая.
Он будет работать за о от л от е умножить на, чтобы не путать все это.
Бета.
Бета от м от е и в, где бета от е в будет равно, то есть это будет, ну, это будет,
бета от m от e и v, где бета от e v будет равно, то есть это минимальному такому и, что логарифом, логарифом, логарифом и раз.
Ну, я еще не ввел это обозначение, сейчас введу. А так, да, это она и есть. Ну, хотя это не совсем, тут это, значит, лог, лог, лог. Ну, вот, значит, соответственно, m, там v, очень хочется, чтобы было меньше либо равно, е делить на v, если уж брать совсем формально.
То есть минимальное такое и, что если взять там от v и раз логарифом, то получится что-то меньше либо равно, чем е делить на v.
Да. Я вам даже больше скажу. То есть асимпатические, то есть это на самом деле асимпатические, примерно равно, как на самом деле лог звездочка v минус лог звездочка е поделить на v.
Вот так. Более того, на самом деле смотрите, как тут интересно-то на самом деле получается. На самом деле, сейчас, знаете, вот, возможно, вы слышали, я уже упоминал, я упоминал, наверное, в прошлом семестре это заклинание.
Если е больше, допустим, если е больше, чем v, лог, лог, лог, v, то тогда я утверждаю, что этот алгоритм вообще работает за отъяснение.
Да, ну идея очень простая.
Можете, а если е больше, чем v, лог, лог, лог, лог, в, можно не зато в самом деле?
Можно. Тут вот аккуратно так, да, на самом деле можно, тут очень весело на самом деле, да.
Ну, в общем, главное, понятно, даже вот из этого оно уже понятно откуда берется. Да, потому что если е больше, чем v, лог, лог, v, то это как бы меньше либо равно, чем лог звездочка v минус лог звездочка от лог, лог, лог, v.
А лог звездочка лог, лог, лог, v, это как бы лог звездочка v минус 3, правда? По сути.
А почему у меня три лога ставится? Почему у меня один, два, пять?
Отбалдывает. А чтоб красиво было. То есть такое, чтобы уже достижение. Да, я могу, можно пять логов поставить и сказать то же самое. Любую, наперед, заднюю константу, пожалуйста.
Ну просто константа будет более жирная, она как бы просто общий случай не покрывает. То есть мы уже сталкивались с этим случаем, когда для любого епсилом больше нуля мы получили алгоритм, который там это
перевножает длинные, числа разные длинные n за o от n в степени 1 плюс епсилом. Было. Правда, константа была все более и более жирная, но как бы вот можно сгрузить.
То есть здесь я тоже могу сказать, что для любого числа там z. Существует такой алгоритм, что если е больше чем v, а вот z раз лог, лог, лог, лог, v, то тогда у вас алгоритм работает за o от v.
Правда, константа от z зависит, но это уже другой вопрос. То есть, конечно, нельзя заявлять, что этот алгоритм работает за o от e, это не так.
Ну а соответственно, что делать? Вот спрашивается действительно, а что делать? Делать мы будем вот что.
Давайте, смотрите. Сейчас мы будем, значит, как же этой мистической асимптотики достичь.
Этой мистической асимптотики можно достичь к следующему.
Вот, значит, смотрите. Значит, наша цель будет такой. Ну тут разные технологии могут быть, но цель будет такая.
Значит, смотрите. Я буду делать в этом алгоритме несколько шагов. На каждом шаге я зафиксирую некое число k и буду делать следующее.
Возьму первую попавшуюся вершину s0 и буду с помощью прима и кучи фибоначи строить вот такое дерево. Дерево, дерево, дерево строим.
Ну прям вот как в обычном, да? Как обычно. До тех пор, пока у меня размер этого дерева не станет равным k. Или даже больше либо равным k.
Ну тут така. Потому что тут я в этом месте остановлюсь. Тут я в этом месте остановлюсь. Возьму вершину, которая сюда еще не попала и буду делать абсолютно то же самое.
То же самое. И то же, что пока больше либо равным k. Причем. Да, может так случиться, что в какой-то момент очередное ребро, которое мы захотим добавить, заставит нас присоединиться к чему-то уже ранее вот этому взятому, да?
Ну ничего страшного. Тогда мы в этом месте остановимся и эту компоненту просто объединим. Ничего страшного.
И так сделаем, пока у нас все вершины не кончатся. То есть таким образом мы добились того, чтобы у нас все вершины были, чтобы у нас действительно появились все вершины, попали в какой-то под компонент именно 100.
Причем в каждой компоненте лежит хотя бы ковершина. Почему хотя бы? Потому что возможно вот такое объединение.
Внимание, вопрос. То есть за какую асимптотику я могу это проделать?
Так, мы... Нет, зачем же, зачем, зачем же. Ну фактически мы... Ну скорее на самом деле надо. Нам хватает массива юзет на самом деле. То есть s&m тут не надо.
Да, я специально хотел избегать s&m, потому что, во-первых, он тут не нужен, во-вторых, как бы его надо отдельно анализировать. Но алгоритм вот этот на самом деле никакого отношения к s&m не имеет.
Ну, при желании можете его туда запихнуть, но на самом деле это вы... Нет, даже не нужно, потому что он даст вам какую-то лишнюю обратную функцию.
Альфу какую-то мы не знаем, что это, и она больше единицы. Не надо. Практически да.
Ну вот да, потому что совсем в тупую, если это делать, то это работает за e плюс v, правда?
А что?
Совсем в тупую, но это бесполезно.
Ну вот. Да, действительно, получается такое вот e плюс, действительно, v лог v.
Типа при каровной e или...
Но если в тупую с кучей фибоначи, это все делать. То есть прим с кучей фибоначи, которые мы только что обсуждали.
То есть мы на k забиваем вообще, или что?
Ну, по k забиваем... Нет, не забиваем, это просто сигнал, где нам остановиться.
Просто его нет на симпатике?
Да, но хотелось бы, чтобы был.
То есть ты каждый раз смотришь по всем остальным вершинам, чтобы найти следующее?
Ну, типа. Точнее, лезешь в кучу и смотришь.
Но на самом деле, действительно, идея в том, что на самом деле надо, конечно, сделать, чтобы тут было не v, а чтобы тут было k.
Как это сделать?
А сделать это очень просто.
Ну, основная идея заключается в том, что так как наша цель добавить только k элементов,
то заметим, что нам никогда нет смысла на самом деле хранить в куче больше, чем k элементов. Правда?
Что?
Вот.
Чего?
Ну, потому что мы же v вершин достаем из кучи.
В каждом момент времени не больше, чем k.
А вот очень... Вот есть подозрения, что могли бы этого добиться.
Почему мы... Почему у нас есть...
Нет, потому что добиться этого можно так.
То есть подтверждение следующее, что предположим, что у нас есть там, допустим, куча вариантов.
Тысяча вариантов.
А k равно 28.
Ну, вершины вот с этими ребрами, которые мы прямо сейчас можем прицепить.
Тогда у меня есть такое предложение. Есть у меня такое подозрение, что, наверное,
добавлять... То есть, наверное, если у нас пришел вариант, и он больше, чем любой из наших 28,
то, наверное, добавлять его резона нет. Правда?
Ну, есть такое подозрение. Правда?
Ну, когда мы релаксируем из вершины, да, у нас тут релаксируем риобрада и пытаемся их добавить...
Тут релаксировать ответ для какой-то вершины. Понимаете?
Нет, сливать — это если мы добавили ребро в новую вершину, она, возьми, была раньше, оказывается.
Такое тоже может быть.
Ну вот.
Тогда мы в этом месте останавливаемся, объединяем, что эти две компоненты на самом деле одна компонента.
И все.
Ну почему? Ну юзидами же мы помечаем. То есть мы просто останавливаемся в этом месте, берем следующую пустую вершину
и начинаем работать из нее.
Вот. Ну и теперь возникает вопрос.
То есть, поэтому вот эта идея, что, наверное, хранить достаточно только последние 28 минимум.
Ну, в смысле к, да.
И если пришел новый элемент, а он больше, чем все к, то, собственно, зачем нам его хранить?
Правда есть один маленький момент.
Если мы хорошо допустим, у нас есть ограничение, что нам достаточно хранить не более, чем к, действительно, вершины.
Ну возникает такой вопрос.
Да, то есть, возникает вот, а вот пришло ребро, и оно лучше, чем там все, что было.
Возникает такой вопрос.
А не, ну вот, то есть, нам же его тогда придется удалить.
Ну вот, да, текущая худшая надо удалить.
Ну, просто удалить из кучи.
Это, к сожалению, тоже логариф.
Так, запихнем в сет.
Да, ну можно и в сет, а можно и в самой кучи.
Но из сета вы в сете-то искать и удалять, вы тоже за логарифом будете.
Да, но проблема в том, что один раз, к сожалению, если бы говорили,
если бы для каждой вершины мы это говорили, то да.
Но, к сожалению, мы не для каждой вершины это делаем, а для каждого ребра.
Мы же заранее не знаем, потому что каждая вершина может быть там,
то есть, на самом деле, в каждую вершину торчит куча ребер.
И какие-то из них большие, а какие-то маленькие.
Поэтому, может, мы сейчас вершину из кучи выкинули, а потом она будет обратно добавлена, мало ли.
Всякое же бывает.
Ну-ка, вот возникает вопрос.
Что делать?
Вот можно ли тут как-нибудь все-таки допилить, чтобы действительно тут было плохо?
Вот действительно как-нибудь тут аккуратнее.
Так, вот действительно возникает такая идея, что если у нас есть два, да,
что можно, конечно, говорить, а давайте забьем, но если там размер, скажем, 2k,
то давайте просто как-нибудь за o от k, допустим, отпилим сразу целую половину.
Да, вот возникает только вопрос, действительно.
Как это сделать именно вот?
Ну, с кем просто?
С кем?
С кем?
Как это сделать именно вот?
Ну, задача.
Нет, у тебя да.
То есть у тебя лежит куча фибоначий на 2k элементов.
Тебе нужно максимальное k взять и удалить.
То есть, конечно, на прошлый вариант, а давайте по куче фибоначий выпишем все
элементы, которые там лежат, это делается за o от k.
Там найдем идеану за o от k, удалим.
За o от k.
И все, а за остальных за o от k построим новую кучу фибоначий.
Да, только маленькая проблема.
Что там с потенциалом?
А почему, погодите, а почему у нас там был равен потенциал?
Ну, вопрос мог бы быть в том, что а вдруг там потенциал?
Проблема в том, что там же учетная стоимость.
Поэтому вдруг мы там вот этой операции за o от k испортили потенциал, причем испортили его.
Заново посчитали новую кучу.
Старая куча перестала существовать.
Ее потенциал просто не меньше нуля.
А, ну да, старая куча перестала существовать, а у новой стал потенциал равен k.
Ну, как вы видите.
Да.
А, ну да, мы все равно в нее все добавили за o.
А, ну хорошо, да, от этой самой операции потенциал только уменьшился, поэтому все в порядке.
Что мы тогда делали?
Значит, мы сделали себе лог k так.
Мы говорим, что пока у нас размер кучи меньше, чем 2k, нас все устраивает.
Но как только размер кучи становится 2k, мы, значит, мы берем и за o от k эту кучу перестраиваем.
А именно, за o от k выписываем все элементы, там находим медиану и ликвидируем после там максимальные k.
Это можно за o от k сделать, помните?
Это фибоначивая куча?
Нет, уже нет.
Мы уже из этой кучи просто выписали тупо все 2k элементы, которые там есть.
Какая куча? Фибоначивая?
Была фибоначивая куча в рандомном.
Ну как-нибудь вы можете выписать, да?
Ну так, пробежаться по всем деревьям, выписать там все их.
Начали медиану.
Ну вот, да.
Да, оставили вот минимальную половину.
И из этих k оставшихся элементов...
Ну да, которые по факту там будут двусвязанным списочком с минимумом.
Ну это если вы вспомните, как устроена куча фибоначи.
Но это не важно.
Главное, вы помните, что у вас есть пустая куча.
И вы умеете, соответственно...
И вы умеете за o от единицы амортизированных добавлять туда элементы.
В общем, самое смешное, что за...
То есть работает это...
Ну амортизация тут работает.
Ну куча фибоначи с амортизацией вообще никаких проблем нет.
Потому что от того, что вы удалили кучу, потенциал хуже не стал.
То есть как бы потенциал...
Ну вот o от k на самом деле...
Ну он берется тут даже скорее за счет того, что вы делали...
Что условно, когда вы добавили...
Что...
Айтон, ты крашен.
Ну вот.
Что с того момента, как вы в прошлый раз это делали...
Действительно, вы добавили в эту кучу хотя бы k элементов.
Поэтому с каждым лишним элементом вы добавляете монетку и эти монеты.
Вы тратите на то, чтобы сделать эту перестройку.
А на самом деле...
А на самом деле, если вы вспомните...
Потенциал там устроен, по-моему, как...
Количество вершин в куче плюс 2 умножить на количество помеченных.
На самом деле...
Поэтому на самом деле там даже лишних монеток не надо.
По-моему оно само.
Вот, понимаете, да?
Хотя...
Лучше так не делать.
Ладно, не важно.
Значит, вот у нас k и все хорошо.
Так что таким образом...
Ну тут разные варианты были.
То есть вот у нас с вами такой...
В прошлом году у нас прокатывал вариант...
Ладно, давайте не будем цепляться к вершинам.
Будем просто говорить, что
связанных с этой компонентой ребер
должно быть не меньше, чем m.
То есть не меньше, чем k.
Ну просто если в куче оказался размер k,
значит мы тут и останавливаемся.
Еще вот такой вариант есть.
Но там действительно способ есть.
Так что, да, отдельная песня.
Кто из них алгоритм предвануториана?
Как это?
Что-то из этого алгоритм предвануториана,
а что-то я тут придумал, чтобы выкрутиться, да?
Ну хотя все варианты подойдут.
На самом деле, не важно.
Итак, E плюс V log.
За E плюс V log k
мы с вами научились...
Что мы с вами научились делать?
Ну вот.
Мы с вами, соответственно, научились
добиваться того, чтобы у нас
появились компоненты связанности для
мина 100 и в каждой из них хотя бы k вершин.
Ну вот.
Нет, теперь идея такая.
Нет, идея у нас будет, что эти компоненты мы сжимаем
в метовершину.
У нас теперь граф становится в k раз меньше.
По вершинам, по крайней мере, ребер столько же.
И мы повторяем
операцию.
И так делаем до кем-то.
Ну вот.
И мы повторяем операцию.
И так делаем до тех пор пока.
Пока.
Да.
Делаем именно определенно пока.
Да.
Ну так и говорится, да.
Сколько у нас там времени?
А нет, пока, пока.
Пока еще говорить пока не надо.
Спокойной ночи.
Спокойной ночи, малыши.
Значит, смотрите.
Теперь главное у нас
подобрать последовательность
кашек.
Подобрать последовательность кашек, чтобы
было хорошо.
А как подогнать?
А подгонять желательно так, чтобы фаз было
поменьше. И чтобы каждая фаза
работала за O от E.
Ну и тогда хочется добиться того,
чтобы фаз было вот столько.
Значит, первое
k1 будет равно
ну тут почему-то авторы советуют 2E
поделить на V.
Мистическое соображение.
Ну да. А можно 2 в степени
2E поделить на V, и в принципе
этого хватит.
Чтобы вот первая фаза работала за
быстро.
Да любой, господи.
2E поделить на V или 2 в степени 2E поделить на V?
Жестко.
А по барабану знаете почему?
Потому что каждая следующая
это 2 в степени
предыдущей.
Нет, смотрите.
Ну как бы чему равно k? Так вот, на первой фазе
k будет равно ну например 2E поделить на V.
Ну, например.
А на каждой
следующей k будет
как предыдущая, только 2 в его степени.
Вот такая красивая идея.
Ну вот.
Вот теперь возникает вопрос.
Смотрите.
Теперь я утверждаю, что каждая фаза теперь будет
работать за 2E.
Почему?
Ну да, тут даже база
и переход тут чуть разные.
Ну первое очевидно почему.
Ну потому что логарифом этой штуки
наверное меньше, чем сама эта штука, правда?
Ну вот.
Вот я ей говорю.
А тут это пугается.
Разница какая-то есть.
Знаете, бывают на экземпляре такие вопросы,
что как бы с одной стороны
если когда вы, что вы там
задаете какие-нибудь вот такие формалистические вопросы,
но как бы с одной стороны формально вы правы,
но с другой стороны тогда по вам сразу видно,
что вы не шарите. Потому что шарящие люди
таких вопросов задавать не будут.
Просто вот.
Получается такая
интересная заколыка.
Вот. Так вот.
Ну теперь смотрите. И так представим себе.
Прошло и итерация.
Значит.
Значит. И плюс первое.
Будет?
Ну вот.
Значит. ИТ у нас работал
за E плюс
значит
ВИТ.
Там лог.
Ну лог КИТ.
Вот. Понимаете, да?
И допустим это не превосходило
СЕ.
Ну вот.
Мы подогнали какие-то. Ну ВИТ
и понятно, что там количество вершин-то было
меньше, чем В. Правда?
Разно?
Или нет?
Да. Ну тем более, что в каждом
конкретном случае оно конкретно
непонятно. Ну оно разное
может быть. Но просто интересно
что следующее. Что если это было от
Е, то теперь просто добиваем
все успехом и следующим. На И плюс первой
итерации у нас
ВИ плюс первое
оно меньше либо равно, чем ВИТ
поделить на
соответственно КИТ.
Что нет?
Ну давайте вспомним еще раз.
Мы устраиваем так, что у нас в каждой метовершине
лежит хотя бы К вершин предыдущих.
А стало ВИТ поделить
на КИТ вершин.
Да. И тогда у нас
получается, что это
Е плюс ВИ плюс
первое лог К
и плюс первое. Это че такое?
Это меньше либо равно, чем
Е плюс ВИТ поделить
на КИТ
умножить на логарифом
такой замечательной величины, как 2
в степени КИТ.
Ну и дальше выносится.
Ну вот шлеп-шлеп
шлеп-шлеп
ну и короче Е плюс
ВИТ.
Все. Вот Е.
Вот.
То есть поэтому тут даже плевать, что тут какая
санта Ц, тут просто Е плюсы
это меньше либо равно, там условно
там чему-то там 2Е.
Ну ладно.
2Е плюс
1 хорошо.
Нет, ну
мы живем в предположении, что град связан.
Поэтому гарантировать
можно только, что Е
как минимум В
ну то есть что Е это как минимум В
В минус 1.
Нет, почему? Если он чего?
Может, ну просто гарантируйте, что количество вершин
это не более, чем количество ребер плюс 1.
Ну просто смотрите, если
Е больше либо равно, чем В
минус 1, то это эквивалент
потому, что В меньше либо равно, чем
Е плюс 1.
Так что здесь можно так написать.
А можно даже еще вот эту единицу докрутить?
Ну потому, что во-первых
ну просто есть такое
подозрение, что если у вас в какой-то момент
оказалось, что В
что Е реально меньше, чем В, то это означает
что у вас в раффе в принципе остался
100. Понимаете, да?
И тогда уже никакого
и тогда то, что у вас осталось
минус 100 в общем-то можно тут
добавить, а можно не добавлять.
То есть таким образом
мы работаем за
то есть каждая фаза теперь кроме первой
работает за от Е, обратите внимание.
Понимаете, да?
А сколько этих фаз?
Ну да.
То есть тогда получается, что
То есть это получается, да.
То есть получается это количество фаз
не превосходит минимально вот такого
И, что два в степени, два в степени, два в степени
вот эта вот штука
она оказалась более
там больше либо равна
соответственно В.
А это вот
эквивалент на вот этом.
Да, то есть совсем идеально
наверное вот можно двойку нарисовать, но это
как-то неинтересно.
Что-то такое.
Что-то такое, да.
Это
это не очень интересный
констант, да.
Вот, так что получилась
так что получилась вот такая красота.
Не самый сложный алгоритм,
но эффективный
загадок.
