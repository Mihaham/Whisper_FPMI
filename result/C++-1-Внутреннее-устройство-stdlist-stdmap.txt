Ну, раз уж у нас, блин, нет, мне все-таки как-то вот,
вот эта доска больше нравится.
Раз уж у нас разговор про связанные списки идет,
было бы грех не упомянуть пару популярных задач про
связанные списки.
Потому что, насколько я знаю, в курсе алгоритмов вам про
их не рассказывают.
Филипп, во всяком случае, никогда не упоминает.
Полезного.
Полезного.
Что у тебя полезная вероятность алгоритма в процентные числа?
Очень полезно, Старк.
Ну вот и сети там стоят.
Это какая вероятность?
Которая Милера Рабина?
Нет.
Которая Роболла, да.
А-а.
Он вероятностный, разве?
Нет, Роболла, да, это по сути тоже.
Ну, сейчас.
Тоже вероятностный, тоже связан с процентными числами,
поэтому мой мозг сказал мне, что я трак.
Извини.
А, да, точно.
Я забыл, что он вероятностный.
Так, короче, есть такие две очень популярные задачи.
Я не знаю, что делать с этой тряпкой, потому что мне
ее не хватит.
На самом деле, вот это отвратительно.
Вот такие люди, которые рисуют это, маркер же садится
из-за этого.
Вот надо же было столько маркера и стратить вот на
такую ерунду.
Ну безобразно.
Есть такая известная задача, называется найдите цикл
в списке.
Вот, кстати, Ро Поларда алгоритм связан с ней, наверное,
вы знаете.
Да, вот как такое делать?
Да, у вас есть односвязанный список.
Ну, вам дана голова, да, и в нодах хранится int-value
и нод-звездочка next.
Кто знает молчать?
Ну ты знаешь, по всей видимости.
Вот, ну нужно понять, зациклен ли этот список и если зациклен,
то с какого места начинается цикл.
Такая очень известная задача.
Я бы сказал, что ее часто дают на собеседованиях,
но на самом деле даже это неправда, потому что она
настолько известная, что ее даже на собеседованиях
уже не дают.
Ну потому что если ее дать на собеседования, то любой
нормальный человек должен сразу сказать, как она решается.
Ну типа это.
Ну а кто уже знает, как это делать?
Ну без допамяти.
Ну, тогда начинать.
Отъединить цикл.
О, отъединить с допамяти, да.
Понятно проблема, но очевидно, что не хочется там вот,
скажем так, не за квадрат, чтобы было.
И не за n-log.
И не за n-log, да.
Че?
Да.
Ну давайте, кто знает, расскажите, не хочется на этом застревать,
просто чтоб все знали.
В какую?
В начальную, да.
Да, вот.
Ну я…
Чего пройдем n?
Ну количество вообще не дано.
Да.
Да.
Да, значит…
Мы…
Да, мы делаем цикл, другой, сфорк делаем, короче, цикл.
И там каждый шаг, этот задвигаем на один, а этот на два.
И когда мы дойдем до цикла, мы…
Ну либо кто-то из них дойдет до конца,
либо мы…
Давайте рассмотрим момент, когда медленный указатель дойдет до начала цикла.
Рассматриваем.
Рассмотрели.
Нарисовали стрелочку медленного указателя до начала цикла.
Хорошо.
А быстрый указатель где-то на цикле, обязательно.
Да.
Ну значит, еще не более чем задвинут цикл, а быстрый указатель дойдет медленным.
Да.
Ну в какой-то момент они снова встретятся, короче.
Хорошо, но теперь вопрос.
А как найти вершину, в которой цикл начинался?
Собственно.
Задача-то была в этом.
Вроде ставят указатель опять в голову.
И там можно представить, что они встречаются в точке минус r,
где r – это остаток определения длины хвоста на длину цикла.
И по идее, когда мы…
Ну теперь с шагом 1,1 они по идее встретятся когда-то в начале точки.
Оба пройдут остаток r.
По-моему, длины цикла.
Ну кажется, можно два счетчика типа завести на…
Хотя достаточно просто итерации посчитать.
Число итерации и как через родину длину одним-другим вычислить.
Еще раз.
Что?
Поставь какие счетчики.
Ну типа просто давайте заведем счетчика, который считает число итерации, который у нас в участии.
Так.
Да.
Или формально говоря, сколько раз медленный указатель перешел.
Да.
Вот.
И тогда если кажется, что это число, как раз их сразу и будет давать нам длину цикла.
А длина цикла, видать, мы знаем…
Почему он будет давать вообще ничего?
Ну длину требует.
Почему?
Потому что у тебя…
Если у тебя быстро указатель догнал медленный, то он должен был пройти полностью круг цикла.
Это правда?
Ну, наверное, можно пройти до момента, когда они встретятся еще раз.
И так понять длину цикла.
Просто сохранить вершину.
Пройти еще, пока опять не вернемся.
Найти длину цикла без проблем вообще.
Ну, короче, найти длину цикла – это как минимум можно еще раз пройти, пока они снова не встретятся.
Так.
И после этого мы будем знать длину цикла, а также мы будем знать общее количество шагов, которые было проделано.
И…
Вы сказали, что медленный указатель прошел не больше одного цикла.
Нет, я не понял.
А как найти все-таки…
Смотри, если у нас медленный указатель…
Да.
Если мы, то есть, делаем…
Сначала один раз прошли, а потом еще специально, чтобы посчитать длину цикла второе.
Да.
Утверждаешь, что медленный указатель пройдет от силы один цикл.
Что?
Ну, ты можешь найти длину цикла, и ты знаешь, что у тебя медленно прошел всего лишь максимум одну…
Так, а начало-то где?
Как его найти?
Длину мы и так уже нашли.
Ну, так теперь обычный из пути, который медленно прошел.
Так, а медленный мы же не знаем, что в начале он стоит где-то в середине стоит.
Мы не знаем, сколько вы читаете.
А ты чем предлагал?
Математику.
Вроде рабочую.
Ну, да.
Там просто надо считать отстаток.
Ну, мы, короче, сказали, что достаток это делается.
Ну, давай, как?
Потому что я забыл.
Думаю, мы говорим T – это длина вот этого хвостика.
C – это длина цикла.
T – это длина хвоста, C – это длина цикла.
Так.
Делим с остатком T на все.
Получаем какой-то отстаток R.
Допустим, оказывается, что там какой-то то ли в точке R, то ли в точке и минус R.
Они как-то здесь перейдутся.
Если мы пройдем еще раз, то у нас указатель, который мы оставили в вершине, который у него не встретится, пройдет как раз R шагов, покажется, ну, за T операции.
Ну, да, значит, минус R.
Парни встретились в точке и минус R, за T шагов указатель, который остался на цикле, придет к ноль.
А указатель, который мы поставили в голову, тоже будет в начале цикла.
Сейчас, вот у нас здесь, у нас получается в данном случае T – это 2, C – это 5, R – это тоже 2.
T по моделю C, не C по моделю T, а T по моделю C.
Ага, значит, что ты утверждаешь, где они встретятся?
В точке и минус 2.
Минус 2 относительно чего?
То есть вот здесь, вот тут, что ли?
Ага, ну, хорошо, когда медленный здесь, быстрый тут.
Потом…
Сколько шагов надо, чтобы…
А, ну да, собственно, он стоит на 3.
Ага, ему как раз потребуется…
Ну да, кажется, это правда.
То есть они встретятся в точке и минус R от начала цикла.
И после этого мы… Что мы дальше сделаем?
Ставим указатель 1 в начало…
В начало… А, вот в это начало.
И ведем шагом 1.
Так.
Ну, а второй в эту точку минус R, в которой они встретились.
Да, так.
Ну, я не тесть, мы в начале это делаем.
Потому что одному нам пройти… Сколько, чтобы на C плюс R, а второму надо пройти R.
Ну и тоже по циклу еще сколько хочешь намотать?
Что?
Дальше мы просто идем…
А, ну этот, возможно, обойдет цикл сколько-то раз и еще R шагов сделает.
А этот сделает…
Ну, то же самое, да.
Ну, кажется, работает, да.
Кажется, работает.
А что, все поняли?
Нет, из C плюс.
Да, в общем…
Шляпа полная.
Шляпа полная.
Да, в архиве…
А, мы на камеру снимаем, да?
Ну, типа, да.
Тогда я не буду говорить, ладно.
Если камеры выключите, когда я потом…
Не знаю, в перерыве скажу.
Да, но не забудь.
Так, хорошо.
Ну ладно, вот.
Это первая очень боенистая задача про связанные списки.
Ну, которую так сходу-то и…
Разворачивают список?
Разворачивают список – это нулевая задача.
Я это даже не стал упоминать, но потому что это вообще не серьезно.
Односвязный список.
Односвязный, конечно, список.
Да, значит, задача номер ноль – развернуть односвязный список.
Это, не знаю, самая популярная задача.
Вот эта, мне кажется, вторая по популярности.
А почему она вторая по популярности?
Она же нигде больше не применяется.
Как будто остальные задачи собеседования нигде-то применяются.
Не знаю, просто идея даже нигде в этом не применяется.
Идея вот эта вот как раз применяется в твоем любимом алгоритме RO.
Хорошо.
Правда, вот это вот не что иное, как буква RO.
Я знаю.
Да.
Собственно, там происходит примерно то же самое, только там с остатками.
Правда, я уже…
Ну, вот это скорее штука на знание.
Но вот эта вот докрутка, что там, где цикл начинается, это такое…
Ну да.
Не, ну лично я не встречал, чтоб меня спрашивали на собеседовании разом.
Но я знаю, что…
Но я говорю, это, наверное, не спрашивать, потому что это уже настолько баян, что даже и…
Вот развернуть список по-прежнему очень популярно.
Вот.
А другая задача популярная…
Это, которая…
Вот про которую ты тоже говорил, это вот такая.
Вот у тебя есть список опять односвязный.
Ну или двусвязный.
Нет, односвязный, наверное.
И у каждой вершины, помимо указателя на следующего, есть еще рандомный указатель какой-то, который ведет…
Ну, может вести в любое место там.
А может вообще на себя.
И нужно скопировать…
В общем, нужно повторить эту штуку, сделав такую же структуру…
Так, я отсюда еще никого никуда не повел.
Пусть будет этот вот сюда.
Вот.
А знаешь, какой следующий такой рандомный?
Да.
Вот.
Есть next, а есть other.
И вот нужно сделать…
В общем, нужно создать копию такой штуки.
Ну опять вам данный указатель на head.
И…
Вот.
Как сделать?
Ну, кто-то уже точно знает, потому что еще в прошлый раз обсуждали.
Ну, а как ты other инициализировать?
Тебе, чтобы проинциализировать очередной other, может линейное время потребоваться.
Мы это в прошлый раз обсуждали?
Ну, в прошлый раз там вот господин Жильцов подошел и вот спросил, правильно ли его понимание о том, как эту задачу решать.
А блефессом она не решается?
Ну, хочется это все решать.
Ну, я не знаю.
А блефессом она не решается?
Ну, хочется это все сделать за время, типа…
Ну, типа блефесса это будет в выпуске.
Да, я понял, но…
Ну, нормально.
И как?
Если что-то значит, то блефесса не решается, типа как?
Нет, да, что такое, как это?
Ну, в плане типа просто при помощи блефесса копируем.
Создавая новый Жильцам, заполняем массивчик какой-нибудь условный, по которому мы так идем спокойно.
Честно говоря, ничего не понятно.
Что значит оп-оп-оп?
Если создать хашмапу отдельную, да, это можно записать для каждого указателя ее номер от единицы.
Ну, вообще, да, в решении, которое в итоге получится, памяти кроме как на исходный список и на новый список никакой не должно быть.
Ну, от единицы дополнительной.
Вот, ну, ладно, тут я могу рассказать решение, потому что я его не забыл.
Вот, решение такое, что надо просто раздвоить ноды, то есть после каждой сделать ее дубликат.
Между каждыми двумя вставить по одной.
И тогда понятно, как за вот единицы проставить указатели азр.
Ну, понятно, что, например, как проставить азр вот для этой.
Но нужно, нет, кстати, не до конца понятно как, сейчас.
А, нет, все понятно.
Нужно посмотреть на азр для этой и следующий, который за ней, это и будет азр для нашей.
Ну, и так для всех.
Я в каждом, да, я спланировал каждую вершину, вставил между любыми двумя новую.
Вот, и теперь, чтобы понять, как проставить азр для этой вершины,
мне нужно посмотреть, куда вел азр для этой вершины,
и поставить азр на следующего после того, куда он вел, то есть вот сюда.
А потом обратно разъединить, то есть потом расцепить эти два списка.
Это через один, да.
Вот такая штука.
Нет, ну в итоге мы его оставим, как есть, да, ну в смысле,
константный ли он был, ну, видимо, нет, не константный.
Ну да, понятно.
Нет, понятно, ну можно было...
Ну, да, понятно.
Его в итоге не меняем.
Нет, понятно, ну можно было...
Подожди, ты же можешь создать оболочку, которая...
Ну все, понятно, ну короче, вопрос правильный, да, ну да, можно было менять.
Вот, ну вот теперь вы знаете там три самых баянистых задачи на связанной списке.
Ну, еще развернуть список еще. Чего?
Я не шарю.
В смысле не шарю?
Как перевращать список?
Проверять список.
Так подожди, а там же... Там как раз нет ничего алгоритмического, там просто надо это, написать.
Ну развернуть список — это задача на аккуратность.
Ее очень часто спрашивают, чтобы, там, проверить, сколько вам потребуется времени чтобы не запутаться.
Ну, это, как я не знаю, это, как бинг-поиск написать примерно, такого же уровня задача.
Вот, за сколько времени вы можете написать бинг-поиск?
какой он работает будет, а сколько времени в минутах вам надо, чтобы мент-поиск написать.
Ну так же примерно и со списком связанным, что его развернуть.
У него есть копия, чтобы у него, ну, копию перевернуть или исходный список перевернуть?
Нет, исходный список перевернуть.
Может поддерживать один указатель или там дополнительный?
Ну да, надо просто там, в момент, когда вы вот вы тут стрелочки эти разворачиваете,
и вам нужно там дополнительно что-то хранить.
И, ну, я не хочу, я устал уже, я в своей жизни это много раз делал.
Ну, в смысле, мне надоело список переворачивать.
Ну, надо просто там правильно запоминать, хранить чуть-чуть на одну больше,
чтобы вот, ну, вот эту штуку вы заменили вот на эту, это стерлось.
А теперь вам надо еще помнить вот эту, чтобы на нее потом перейти, чтобы у нее тоже...
Ну, типа да.
Ну да, ну, это несложно совершенно, алцилогрепнической точки зрения.
Это именно с точки зрения написания говнокода может там быть проблемно.
Можно просто обвести шляпу, что ей происходит.
Какую шляпу?
Которую вот эта вот...
Вот эта?
Да, с двумя видами.
А ты не понял?
Нет, типа что это вообще за лол?
Ты все еще считаешь, что БФС-ом надо, да?
Я вообще ничего не считаю.
Нет, я просто, просто, возможно, если ты не понял проблему, то ты и решения не понял.
Но проблема, как его скопировать, чтобы это не за квадрат было?
Ну, собственно, с допамятью это будет работать.
Допамять не только на хранении нового, но туда это можно сделать БФС.
Почему это может быть за квадрат?
Ну, если делать совсем в тупую, типа...
Как совсем в тупую делать?
Я пройдусь слева-направо...
Скопирую?
Да, скопирую стрелочки вправо.
А потом?
А потом?
То же самое, то же самое.
Как ты будешь понимать, какую, когда это возьмешь и скажешь, на кого нужно поставить?
Топ-сок.
Ну, вот тебе надо поставить, тебе надо поставить вот в вершине своей копии аналогичную стрелку там, через К.
Ну, просто.
Да.
В смысле, да.
Смотрю куда она смотрит, скопирую.
Что ты скопируешь?
Ты должен взять ее копию.
У тебя ей уже какая-то соответствует.
А, уже в нее перейти.
Можно, наверное, в хэшмапы положить.
Ладно, отлично, памяти много.
Даня.
Ну, с хэшмапой, наверное, да, но это лишняя память, и все, некрасиво вот это.
Вот смотри, чем-то мне не понравилась идея вставить новую вершину посередине между каждыми двумя.
Нормально?
Как минимум, потому что у тебя тогда вершина получится над уменьшим чем надо.
Вставь еще одну после всего списка красного.
Ну, это я забыл сделать, да.
А, то есть в этом была проблема.
Отлично, нормально вставили.
Мы будем добиваться того, чтобы красная вершина, которая идет за какой-то черный, стала, в конце концов, ее копией.
Окей?
Вот в таком графе понятно, как провести аналогичные ребра, чтобы у красных вершин были правильно проставлены, ну, не next, а вот эти вот случайные ребра.
Ну, вот эти вот второе дополнительное ребро.
Ну, в плане, у тебя все, ну, я понял.
Понимаешь, на кого проставить?
Ну, золотой единицы.
Вот мы идем по списку, у нас есть черное и красное, мы переходим по черной, и красный добавляем next от того, куда мы делали.
Дима, ты пиши пока, чтобы в цикле подходить, ну, по одновременно по красной и по черной.
Да, просто, Дима, два подряд.
Все.
После этого нужно разогнить два списка.
Так, ну ладно.
Нам дальше пора переходить к более приземленным вещам, к более прикладным.
Опять эти ваши присутствия?
Да, да, да.
Ну, хорошо.
Я вас, я вам, я вам уже сказал, да, что вот цель этого семестра это вот убедить вас никогда не писать больше на плюсах.
Так.
Да я, честно говоря, не знаю.
На бетончике, на бетончике все будет хорошо.
Да не, на плюсах тоже есть что-то в этом, знаете, я вот писал, мне нравилось.
Так, следующий, о чем нам надо поговорить, следующая вещь, это мэп, как можно было догадаться.
STD-мэп.
Это пункт 8.8, да?
А какая разница?
Ну, я хочу поддерживать все-таки программу курса, значит пункт 8.8 STD-мэп.
В проекте слишком много легозекунд.
Так, ну я уже говорил еще раз скажу, что мне кажется важно какую-то структуру в голове держать.
Какая у нас сейчас тема и какой подраздел ее, потому что иначе потом, когда будете это все ботать, там к экзамену к тому же, вы запутаете будет каша в голове.
Полезно все-таки структуру поддерживать в материале.
Так вот STD-мэп.
Ну что такое мэп, все наверное знают, это красно-черное дерево внутри.
Вот.
Кстати, понятно ли почему красно-черное именно, а почему никакое другое?
Меньше всего памяти дополнительной.
Вот, памяти дополнительной.
Стабильнее.
Меньше всего разворотов.
Да, ну кажется, что поворачивать надо немного.
Больше всего случаев.
Больше всего случаев разбирать, но для разработчиков STL-а, как известно, это никогда их не пугало.
Вот.
Поэтому да.
Хорошо.
Ну окей, STD-мэп.
Ну теперь мы понимаем уже, что там, наверное, внутри.
Мы в принципе по аналогии с листом понимаем, что там есть опять-таки ноут.
Ну вот если взять мэп, там внутри тоже есть ноут.
И в этой ноут есть что?
Ну там, понятно, есть left, right parent, там есть left, левый сын.
Parent-а нет?
А как вы будете ходить по дереву, если нужно обход делать?
Деды, бабушки.
Ну подожди, всегда эффективнее.
Удаляем алгоритм, поэтому всегда можно по ним стэк хранить.
А, то есть помимо всех вершин еще стэк хранить.
Ну этот стэк будет глубины алгоритма не больше, чем глубину алгоритма всегда.
Это прикольнее, по-моему.
Есть некоторая трудность в реализации, которую я сразу вижу.
А как будет память под него выделяться и в какой момент?
А можно выделить заранее?
Заранее насколько?
Ну, на алгоритм от того, сколько у вас вершин, а когда новая вершина добавляется, еще чуть-чуть выделять.
Это в смысле чуть-чуть еще?
Это типа вот...
Массивчик константный можно считать, который всегда размер алгоритма.
Алгоритм от чего? А он же меняется.
Ну вот, алгоритм от текущего.
Вектор просто.
Да, ну то есть просто еще вместе с деревом хранить вектор.
Да, но он всегда очень маленького размера.
Ну что значит маленького? Его же реалацировать все равно придется иногда.
Нет, это все равно лучше, чем ноут звездочка Parent.
Да кто тебе сказал лучше, что это лучше?
Ну по памяти оно точно лучше.
Ну мы же не память экономим все-таки.
Нет, ну мы... Не-не-не, я уверен, что так не сделано, как вы говорите.
Потому что, ну просто это было бы очень странно.
Что?
Короче, Parent...
Все-таки, я думаю, надо хранить.
Вот, ну и там понятно, что есть.
А что еще-то там, кстати, есть? Вот хороший вопрос.
Ну понятно, с этими деревьями.
Ну еще должно быть K и Value.
И это можно хранить где угодно.
Лишний бетон.
Я думаю, они как-то заморочились.
Бетон?
Ну типа, я думаю, один бетон.
Можно запихать в какое-нибудь случайное место.
Что значит случайное место?
А что такое K и Value?
А вот, ну так это же мэп?
Да, мэп из чего-то во что-то.
На самом деле, я только написал, оно не совсем так.
А именно...
Вот сейчас мы как раз поговорим...
Да нет, можно и так. Почему?
Это прилагательное.
Булевский фун, empty, например.
Работает так.
Просто отвечает на вопрос, да или нет.
Ну вот, насчет буля, я не знаю, извратились ли они там, чтобы его одним битом хранить или нет.
Ну, давайте будем считать, что нет.
А как вариант?
Придется к нему обращаться?
Уже как структура, а это уже там опять бай.
Ну да, в общем, мне кажется, что...
Давайте считать, что просто буль хранится и все.
Так, окей, вот такая вот структура node.
А теперь, какие у нас есть методы?
У нас есть...
Сейчас поговорим про то, как работают квадратные скобочки, add, insert, erase и прочее.
Ну давайте начнем, наверное, с...
С чего мы начнем?
Ну мы начнем с...
Ну как квадратные скобочки работают для начала?
Спускаемся по дереву, ищем вершину.
Да, ну понятно, с точки зрения алгоритмов не интересно, как они работают.
Вы и так знаете, что мы пошли из корня.
А, ну да, а в самом классе map хранится указатель на корень.
Вот, и возможно еще какой-то указатель, сейчас мы поймем куда.
Я так думаю, что нужно будет еще какой-нибудь.
Вопрос к занавтокам, потому что я кочей дерева успешно не ботал.
Так.
А ну дерево почему подключу?
Подключу, конечно.
Не подключу.
Да, map это упорядоченный двоечное дерево поиска, подключу, а well это просто значение в соответствующих вершинах.
Вот.
Ну так вот, у нас хранится указатель на root, да, в мэпе там.
И мы спускаемся лево-право, лево-право, идем, ищем место, куда вставить.
Понимаем, куда вставить.
И что дальше?
Ну дальше начинаются вот эти свистопляски с поворотами дерева.
Там вот это вот если дедушка черный, а дядя серый, а этот серый мурмалин.
Ну вот эти все случаи, понятно, что они там, в общем опустим эту часть.
Но что по существу с точки зрения плюсов происходит, когда квадратные скобочки работают?
Квадратные скобочки, они вообще какую сигнатуру имеют?
Оператор квадратной скобочки принимает value, const value.
Ну в квадратной скобочке мы принимаем, ой, ключ.
Да-да, мы принимаем, принимаем мы ключ, сорян.
Да, принимаем мы ключ, конечно, а возвращаем ссылку на value как раз.
Я их перепутал.
Значит, принимаем мы ключ, а возвращаем ссылку на value.
Причем это не константный оператор.
И в константном мэпе нельзя вызвать квадратные скобочки, соответственно.
Вот, квадратные скобочки это не константный оператор.
Если у вас константный мэп, то вы ошибку попробуете квадратными скобочками к нему, это будет CE.
А? CE просто потому что value амперсант не получится сделать из.
Вот, да, ну как я уже сказал, тут это не совсем так там выглядит.
Сейчас вот как работают квадратные скобочки?
Ну, понятно, как они работают, если ключ такой был, а вот если его нет, как они работают?
Ну, мне же надо value амперсант вернуть на что-то.
А, нам нужно, чтобы мы...
Должен ли у нашего типа быть конструктор по умолчанию?
Вот это и вопрос.
Вот да, именно, что если вы квадратными скобочками обратитесь к ключу, которого не было,
то создастся соответствующая вершина под него и value там будет проинциализирована по умолчанию.
То есть value должен иметь конструктор по умолчанию в случае, если вы квадратными скобочками хотите присваивать по нему.
Ну, нет, понятно, если вы обратитесь к квадратным скобочкам, он там был, хорошо, вам повезло.
Но если вы обратитесь к квадратным скобочкам, а его там не было, то он вызовет конструктор по умолчанию.
Да, а стало быть, поскольку это в compile-time все должно происходить,
конструктор по умолчанию должен быть в любом случае, если вы квадратными скобочками пользуетесь.
Ну, не может же от рантайма зависеть.
Случилось ли у вас обращение такое, что ключа не нашлось?
А если им не пользуются, то почему...
Чего?
Если им вообще не пользуются скобочками, то проблема не будет.
Квадратными скобочками, потому что оно может не инстанцироваться, это же шаблонный код.
Кстати, я не знаю, но я не помню, пробовал ли я пользоваться мэпом, у которого value было без конструктора по умолчанию.
Но я не уверен, гарантируется ли, что это скомпилируется, что оно не синстанцируется.
Скорее всего, не синстанцируется, но нафиг его знает.
Вот, но есть... А как, если константный мэп, тогда что делать?
Во-первых, это только для неконстантных мэпов.
Во-вторых, должен быть конструктор по умолчанию value, если им пользоваться этим.
А если не константный... Если константный мэп, то как обращаться?
Там есть... Что?
Да, там есть этот add.
Вот аналог квадратных скобочек мы... Ой, почему оператор?
Ну, как в векторе у нас были квадратные скобочки, а был add.
Также в мэпе у нас есть add, но он тут играет уже другую...
Это более важно, тут у него функция не только в том, чтобы проверять выход за границы.
Вот тут оператор add, как и в векторе, кидает исключение в случае исключения, нашлось.
Но при этом...
Господи, да почему я пишу оператор?
Оператор add.
А возвращает он что? Ну, value амперсант также возвращает.
Но может быть и константным, да.
Если, соответственно, если мэпа константная, то...
Ну, короче, оператор add есть как константная, так и неконстантная версия.
Соответственно, может быть здесь конст.
Что происходит, если вы add, от ключа которого нет вызвали?
Ну, будет исключение, бросится.
Будет стд что-то, не помню, out of range в векторе, а в мэпе не помню что.
Какое-то исключение будет.
Вот, ну хорошо.
Так, хорошо.
Есть еще такая штука, insert, такой метод.
И race есть еще метод.
А что делает insert?
Я не знаю, какой тип данных он принимает, потому что я всегда фигурно скоплю.
Да, он принимает пару ключ значения.
Std pair. Соответственно, на самом деле вот для мэпа еще есть такой вспомогательный тип.
В общем-то он...
Ну, по сути...
Ладно, это слишком громкое заявление, что он ради мэпа был создан.
В общем, есть такой еще тип, std pair, ключ значения.
И вы можете в insert передать...
Std pair, необычный pair, которым мы пользуемся.
Не, ну это обычный тот самый pair, да, std pair.
Почему он вообще может быть создан для мапа?
Ну, кажется, что вот где в STL он нужен, это именно в мэпе впервые.
Ну, что значит впервые, непонятно, но в общем...
Да, insert, и принимает он пару...
Потому что ты так передаешь.
Ну, в смысле, почему так не сделали?
Почему отдельно не принимает ключи отдельно значения?
Конечно, мы подходим к этой поводу, почему структура нода не совсем такая.
Да, вот именно здесь мы к этому и подходим.
Это просто какой-то кондроиндуитивный момент.
Смотри, я хочу принять два аргумента, мне зачем-то надо...
Сейчас расскажу. Наверное, нужно было сначала не про это сказать, а про то, как итераторы устроены.
Давайте подумаем, как итераторы устроены.
Вы же, когда по мэпу ходите...
Да, давайте пока insert отложим.
Вот итератор, это что такое по мэпу?
Вот если вы разыменовываете итератор, вы что получаете?
Вы получаете как раз пару.
То есть вам надо, чтобы, обходя мэп итератором, вы могли, разыменовав его, получить как ключ, так и значение в соответствующей вершине.
А, стало быть, вы не можете хранить отдельно.
Вам нужна структура, чтобы там и ключ и значение лежали рядом одновременно.
Поэтому, на самом деле, в ноде лежит это не так.
В ноде, на самом деле, лежит пара из ключа и значения.
Вот.
И я это сейчас перепишу.
Тут, значит, лежит пара.
Но даже то, что я сейчас напишу, будет не совсем правдой.
Указатели должны быть.
Значит, так, PR key value, а называется она, не знаю как.
Ну, PR, PR.
Не знаю.
Давайте я назову ее V. Нет, value плохо ей называть.
Ну, давайте KV нижнепочетки PR.
KV PR.
Ладно, допустим.
Значит, key value PR.
Давайте просто KV.
Давайте просто KV.
Так.
Но это тоже не совсем правильно.
Потому что вот представьте, вы идете итератором по мэпе.
И говорите for.
Да, ну тут надо написать там.
Ладно, давайте я вот первый последний раз в этой жизни, в этом курсе, точнее, напишу.
Так как уже нормальные люди не пишут.
Значит, я говорю for, auto.
It равно.
Там у меня есть мэп.
Я говорю begin.
It не равно.
m.end.
Нет, я к тому, что обычно range-based for, когда вам мэп надо обойти.
KV, 2.
Мэп и все.
Ага, логично, все хорошо.
Plus plus it.
Ну да, так, наверное, нормальные люди пишут.
Уж точно они не пишут вот так.
STD, мэп.
Можно авто я напишу, ладно?
Мы формально с вами слово авто не проходили, но вы же знаете, как оно работает, правда?
STD, мэп в угловых скобочках KV, 2.
Это читератор.
Теперь представьте, что я такой хулиган, что взял и написал.
Под итератором, как мы знаем, у нас лежит пара.
Например, если я хочу вывести ключ значения, то мне надо сделать it, стрелочка, first.
Это будет ключ.
It, стрелочка, second – это будет значение.
Стиль именования полей, конечно, оставляет желать лучшего.
Поэтому пары не очень любят использовать в продакшн коде.
Пишут обычно какие-нибудь свои структуры.
Очень понятно.
Очень понятно, yes, first и second.
Особенно когда it, first, first, second.
Вот это вообще...
Ну хорошо.
У меня вопрос.
У меня есть итератор, и этот итератор не константный.
Но мэпа не константная.
А могу ли я вот так сделать?
It, стрелочка, second равно что-нибудь другое.
Пяти. Ну мэпа, например, из стринга вы...
Об этом и разговор.
Вот так я сделать должен мощь, если я итератором иду.
Но если я попробую it, стрелочка, first присвоить что-то, это не должно работать.
Понятно почему.
Ну потому что если бы это работало, если бы такое присваивание было разрешено, то...
Вообще все бы сломалось.
То дерево бы сломалось, да.
Нарушила бы структура мэпа.
Это было бы нормально, можно сказать.
Ну сделаем за логарифм.
Проблема в том, что у нас такой цикл не прокатится.
В смысле сделаем за логарифм?
Это key.
Как ты будешь...
Когда ты присваиваешь, делаешь это присваивание, уже никто не знает, что это какой-то элемент дерева.
Вот.
Поэтому на самом деле тут пара не такая, пара исконский в value.
И вот это доставляет особенный бад херд в некоторых ситуациях.
Сейчас я вам покажу ситуацию, когда это доставляет бад херд.
Представьте, что вы решили вот написать такие умные range-based for.
По мэпу.
И такие написали for.
Ну вы же знаете, что в мэпе лежит?
Правильно такие говорите.
For std pair.
Нет, вот представьте, вы умные, но не настолько.
Написали std pair, там key-value.
Причем вы же умные, вы такие понимаете, что вы не хотите копировать.
Написали const std pair, key-value, ampersand.
Кв 2.m.
Ну типа для всех пар в мэпе что-то сделать.
И такие сидите и думаете наивно, что вы такие умные, молодцы.
Избавились от копирования.
Красиво range-based for написали.
Значит const, ampersand поставили.
Вообще все классно.
Но нет, на самом деле.
Здесь вы все равно копируете при каждом заходе в вершину.
Вот если у вас мэп из стринга в int.
И вы здесь напишите вот так.
const std pair st strings int ampersand kv 2.m.
Вы const тут забыли, потому что.
Понятно.
То есть он должен создать константную ссылку на пару из стринга int.
А у него есть пара из const стринга int.
Что ему приходится сделать?
Ему приходится создать временную пару из обычного стринга int.
И вам дать ссылку на нее.
То есть вот если вы при таком цикле напишете здесь без конста.
У вас будет лишний копирование.
Несмотря на то, что казалось бы вы написали и конст, амперсанд здесь.
Вот.
Поэтому мораль писать авто надо.
В таких ситуациях.
Вот.
Это пример из книжки Скотта Мэйерса.
Почему авто обязательно надо писать.
Даже когда вам иногда хочется выпендриться.
И вы думаете, что знаете тип лучше компилятора.
В общем, вы не знаете.
Книга называется «Почему не надо писать на C++».
Чего-чего?
Почему эта книга не называется «Почему не надо писать на C++»?
Ну...
Да, реально.
Книга называется «Эффективный современный C++».
Эффективнее.
Современнее.
Вот. Окей.
Так, ладно.
Мы поняли, что у нас вот такая вот штука здесь лежит.
И еще флажочек буль.
Так вот.
Конечно, конста...
Да, разумеется, если вы пишете авто,
то никто вам...
Никто не избавляет вас от необходимости писать конст
в начале и амперсант в конце.
Если вы просто напишите forAutoKv,
это будет ничем не лучше, что вы будете просто копировать.
Вы можете не писать?
Ну, если вы хотите разрешить себе изменения, то да.
Ну, вы можете писать forAutoAmpersandKv, да.
Но тогда эта пара будет не константной.
И для автоамперсанта он копируется будет или нет?
Нет, конечно, он не будет.
Вы можете писать, потому что по ссылке.
Вот так.
Так вот, возвращаемся к функции insert.
Так вот, insert, соответственно, принимает пару.
Insert принимает const pair
от const k,
запятая value.
Кстати, начиная с 7 плюс плюс 20 можно.
Что?
Что вы не знали об этом?
Здрасьте.
Отдельный уголь музыки.
Да почему?
Это действительно.
Будем считать, что авто-авто-авто-авто.
Так когда выходил C++14,
по-моему, или 17,
по-моему, когда выходил C++14,
уже были мемы о том, что
в C++, не знаю, 40
можно будет писать авто-авто-авто-авто-авто,
и компилятор сам догадается,
что вы хотели
записать.
Ой, а кстати,
как вчера? Вчера же был первый контест
в истории кэфа, в котором участвовал
искусственный интеллект.
Нет? А что они делали?
А, то есть это был такой
clickbait, но...
Ну, потому что, да,
мне надоело писать STD.
Знакомое чувство.
Ну, я же на доске пишу, если бы.
Ну, на самом деле, слушайте,
на самом деле, поскольку
я могу оправдаться тем, что я
пишу код самого мэпа,
а там уж точно STD не написан,
потому что мы унухавнимся уже в пространстве STD,
когда пишем код мэпа.
Поэтому, когда мы
функции мэпа описываем, не надо
STD упоминать.
Вот. Ну, короче, чтобы вот
это все не повторять, у этого есть
специальное название. Это называется value type.
Вот, да.
В мэпе есть
внутренний тип, который называется
value type. И это
как раз вот это.
Это pair из const k,
запятая value. То есть здесь на самом деле
можно написать value type просто.
Ну, вот это не называется
value. Это мы его так называем.
А у них называется...
Ну, слушай, я не знаю,
как оно называется. Ну, это дело
их. Ну, вот это просто
value type.
Value type.
Вообще, если
вы были
внимательными, то
в каждом контейнере есть value type,
и в векторе есть value type, и в листе
есть value type.
Но...
Да, просто
пара, но из const ключа в значении.
Соответственно, здесь можно
тоже написать, что мы принимаем const
value type ampersand.
Вот.
Ну, и что происходит?
Ну, просто
там
спускаемся по дереву до нужного места,
вставляем сразу вот...
Да. Ну, в общем,
вы прекрасно знаете, что происходит.
Вот. С Филиппом обсуждали,
я думаю.
Вот. Что, если уже такой ключ
был? Тогда
вы не... Нет, конечно.
Конечно, нет. Так это не происходит.
Нет.
Если у вас был уже такой ключ, то
ничего не произойдет.
Потому что map хранит
только один ключ с каждым value.
И если вы insert сделали
в мэпе, в котором уже был такой ключ, считается, что
ну, типа, нет.
Значит, не надо вставлять.
Раньше уже было лучше.
Поэтому insert имеет
довольно странный возвращаемый тип.
И опять же, если вы были внимательными...
А, может, я это не упоминал.
Короче,
insert, он же должен вам вернуть
что? Он должен вам одновременно
вернуть информацию о том,
вставил ли, а еще если вставился, то
куда.
Да, он возвращает пару.
Значит, insert он возвращает
по этой причине пару из
буля
и итератора.
То есть, если он вставил,
то там будет true,
по-моему, и итератор будет
показывать на место, куда он вставил.
Утоги.
А? Что?
Для итератора есть end.
Ну, наверное, да.
Можно ли проинцелизировать
итератор на ОПТР? Думаю, нельзя.
Вот, такие дела. Это insert.
Теперь вопрос.
А зачем вообще нужен insert?
Если, казалось бы,
всегда... А, еще есть find.
Вот еще вопрос. Вот еще штука. Есть еще find.
Find
он принимает ключ тоже.
И по ключу
вам возвращает не value,
а итератор.
И если он ничего
не нашел, то он вернет вам end.
Ну, есть еще и raise.
Который тоже принимает
там ключ
по ссылке и возвращает
просто буль, да.
Так вот.
Вопрос. Зачем нужно
find, insert?
Зачем вот это нужно?
Если, казалось бы...
Нет, insert, ладно. Insert, понятно, зачем.
А зачем find?
Можно же просто, там, не знаю,
квадратными скобочками
пользоваться.
А, еще есть метод count.
Еще есть метод count по ключу,
который говорит, сколько
вершин с таким ключом.
Почему он возвращает только либо 0, либо 1?
Почему он называется count?
Да потому что есть еще multimap
с аналогичным абсолютно интерфейсом.
Не, почему? Multimap вполне себе полезно.
Multiset.
А нету там вращения по ключу.
Но есть count.
Ну, как? Нет, есть find.
Который возвращает тебе
первые, там, первые вхождения.
Сейчас про multimap
поговорим. Так вот, короче, есть
count, который, он
так называется, потому что он общий для
мэпа и multimapa, чтобы вам
ну, чтобы интерфейс был одинаковый.
Но в случае мэпа,
в случае мэпа он возвращает только 0, либо 1.
Так вот вопрос, зачем нужен
find в мэпе?
Если, нет, ну, в multimap
ну, вот, для мэпа вообще find.
Хорошо.
А его вообще
надо использовать? Почему нельзя пользоваться
count и квадратными скобочками? Это же проще.
Потому что set реализовывал на мэп.
Чё?
Может count и квадратные скобочки надо проверять?
А?
Значит, правильный ответ, потому что
find эффективнее.
Вот.
Есть просто
такое, не знаю, упражнение.
Можно там где-нибудь,
может где-нибудь встретиться, например, на экзамене.
Такую задачу. Вот у вас будет обход
мэпа, и там будет делаться что-нибудь в таком
духе. Если мэп.count
такой-то ключ, то по этому ключу
что-нибудь изменить.
Нельзя ли это как-то оптимизировать? Ну, можно.
Надо просто find-ом пользоваться вместо
count и квадратными скобочками. Потому что
если вы пользуетесь count-ом,
каждый вызов count-а
это логарифом операции, проход
по дереву. И квадратные скобочки
это ещё один проход по дереву. То есть, если для
того, чтобы положить элемент в мэп,
в зависимости того, лежал ли там элемент,
вы делаете сначала count, потом квадратные
скобочки, вы два раза спускаетесь по
дереву, хотя могли бы всего один раз спускаться
find-ом.
Это лишний проход по дереву просто.
Вот как раз за счёт того, что итератор
это очень такой C++
стайл настоящий. Настоящие плюсовики
они вот, которые топят за
оптимизацию, они вот скорее этим пользуются.
Потому что, ну, понятно.
Вы экономите.
Ну, потому что если ты хочешь
сделать, если у тебя в дереве
лежит эта штука, то там заменить её
на такую-то, а иначе ничего не делать, допустим.
Ты хочешь там,
если у меня в дереве есть ключ 1,
то по ключу 1 сделаю значение 10.
Ну, а если нет, значит ничего
не делать. Вот такое действие
тебе хочется совершить. И мог бы написать
if count 1,
значит, квадратные скобочки по единице
присвоить 10. Но это два прохода
по дереву, потому что и count занимает логарифом,
и квадратные скобочки занимают логарифом.
А find
один раз только прошёл, получил итератор,
посмотрел end ли это,
и если не end, то по нему бы
поменял значение.
Вот, это разговор про эффективность.
Ну, а теперь про...
Да.
Insert.
В смысле, ну он вернёт false
и какой-то итератор.
Да, куда он мог бы вставить. Итератор
уже находящийся в дереве
вершину, скорее всего.
А, типа, почему...
Почему бы не возвращать просто end?
Если что.
Хороший вопрос.
Нет, если нашёл наоборот.
Да, если так, если нашёл...
Видимо, потому что он хочет возвращать...
Вопрос, что он возвращает на самом деле.
Скорее всего, он возвращает итератор
на ту вершину, которую он нашёл с таким же ключом.
Скорее всего, когда писали ключи.
А, ну да.
Наверное, да. Наверное, правильно. Наверное, так и есть.
Логично, что он возвращает
не end, потому что если ты сделал
insert, значит, логично, что хочешь сразу понять,
где оно. Если оно там было, то тебе
на него сразу и покажут.
А bullet, чтобы понять, произошла вставка реально сейчас
или нет. Да, вот поэтому.
Кажется, поэтому.
Так, ну давайте, раз
уже зашёл разговор, сейчас про мульти мы ещё
обсудим, чем он отличается, и
потом...
Неважно, что потом.
В общем, мульти-мэп.
Когда у вас много
вершин с одинаковым ключом, может быть.
А там
отсутствуют квадратные скобки
и add тоже отсутствует,
потому что ссылку не на что возвращать.
А как в мульти-мэпе искать?
Ну вот с помощью файнда, а ещё есть
очень полезные методы, которые
в самом мэпе тоже есть.
Но для мульти-мэпа они гораздо более актуальны.
Где-то lower bound и upper bound.
Lower bound
и upper bound.
Ну да, они полезны, если вам
надо...
Ну понятно, зачем они нужны.
Lower bound возвращает вам
первое из значений с таким ключом,
а upper bound возвращает вам
итератор, да, конечно, на него.
Не само значение.
А upper bound возвращает
вам первое из значений,
в котором ключ больше данного.
Не помню.
Думаю, что
значение он не сортирует,
потому что
компараторы для них
не обязаны существовать.
Я думаю, что рандомно.
Не гарантируется порядок.
Вот.
Еще есть значение,
еще есть функция equal range.
Это
штука
возвращает вам
пару итераторов.
Ну, то есть, если вы хотите lower bound
и upper bound одновременно, может, если это equal range.
Возвращает вам, типа,
начало и конец под диапазоном
мэпа, в котором...
Ну,
думаю, да.
Ну, правильно, потому что когда ты пришел,
ты уже видел, что ключ одинаковый,
ты не будешь спускаться заново сверху с корня,
ты поймешь, что вот тут у тебя уже...
Вот, окей.
Соответственно, с помощью этого по мультимэпу
можно ходить,
мультимэпу пользоваться.
То есть, да, для успешного использования
всей этой машинерии нужно хорошо
понимать, что такое итераторы.
Но давайте еще поговорим теперь про итераторы.
Как работает обход
итератором? Во-первых, какие
итераторы вообще в мэпе?
Веселые.
Веселые, нет таких,
нет такой разной истины итераторов.
Bidirectional итераторы в мэпе, конечно.
Можешь ходить вперед-назад.
В частности,
понимаете ли вы, вот,
не все понимают, ну, из вас может и все,
вы же понимаете, что нельзя написать
вот так, там.
Ну, вообще,
кайф.
СЕ.
СЕ,
СЕ, ошибка в компиляции,
потому что Bidirectional итераторы
нет такого оператора для них.
У кого?
Как это нет?
Он, в частный случай,
рандомакс из итератора.
У Вектора такие итераторы.
Ну, вот.
И еще, например, нельзя написать вот так.
Ну, просто не всем может быть очевидно,
я на всякий случай уточняю.
Это СЕ.
Так вот.
Как работает обход итератором?
Ну, во-первых, с чего начинается?
Вот если вас спросили Begin,
то это как работает?
Возвращаем, сохраняем на ссылку.
Вот поэтому нам, вероятно,
надо еще хранить
указатель на вершину,
которая...
Крайняя левая.
Крайняя левая.
Ну, вот Begin
все-таки хочется, чтобы за единицу
работал, наверное.
Потому что, ну, как-то...
Мы же миллионеры.
Хотя, это память...
Мы же себе позволили три...
Да, мы же позволили себе по три в каждой вершине.
А это одна и все дерево.
Так.
Дальше.
Я написал Beg, чтобы не было коллизий
с словом Begin.
Вот. Хорошо.
Теперь.
Как, значит, работают шаги итератора?
Ну, понятно, что...
Если вам нужно инкрементировать,
вы...
Ну, понятно, что вы делаете.
Вы идете вверх, возможно, какое-то количество времени,
пока вы правый сын.
Нет, вы сначала проверяете, нет ли у вас правого сына.
Если есть правый сын, то вы идете в него.
Да.
Если у вас нет правого сына, то вы идете вверх, пока вы левый сын.
Господи.
Да.
Было бы смешнее, если бы
ты говорила первого лица.
Я иду на левый сын.
Так.
Вопрос.
За сколько работает инкремент
итератора в мэпе?
За амортизированную тени?
Нет.
И это тоже правда?
Нет, это неправда.
Это гораздо более слабое утверждение.
Ну, сейчас.
Если несколько раз подряд прибавить,
то там будет зологариф плюс количество...
Да, это верно, к сожалению.
Хорошо.
Я хотел сказать другое утверждение,
что если вы проходите весь мэп,
то это суммарно работает за вот
количество элементов в мэпе.
Это не то же самое, что
амортизированного от единицы.
Потому что если вы возьмете
подотрезок, то там на подотрезке
на каком-то может быть не так.
Что такое амортизированного от единицы?
По определению, это когда
если сделать каких-то
операций в плюс-плюс н штук,
должно суммарно отработать за вот н.
Ну, я могу привести пример.
Над одним и тем же контейнером?
Да.
Но не обязательно инкремент одного и того же итератора?
А, ну все, тогда понятно.
Просто у меня много итераторов,
и ты будешь один и тот же инкрементировать
многократно.
Да, хорошо, ладно, я понял.
Но
более важно, что
обход всего мэпа работает за вот н,
несмотря на то, что отдельные шаги могут быть
за логорифом. Почему обход
всего мэпа работает за вот н?
Потому что вы каждую
вершину там посещаете в общей
сложности.
Ну, вы в нее один раз войдете, один раз
выйдете по каждому из направлений.
Суммарно у вас будет там, типа,
что-то типа шесть н, что ли,
операции на вершину.
Шесть операций на каждую вершину.
И, то есть, весь обход
работает за количество элементов.
Вот, это
важное замечание. Вот в
onward death map'е
будет интересней с этим.
Ну ладно, теперь вопрос.
Что такое н?
Так просто взяли, создаем
эффективную штуку.
Крайний правый и там какой-нибудь...
А минус?
Да, надо, чтобы минус-минус н давал
крайнего правого... крайнюю правую
вершину в дереве.
Крайнего правого плюс-плюс делаем, и все.
Что получилось?
Мы берем
спускаемся с самого правого сына и делаем
эффективного правого сына у него.
Или на минус-минус, да?
Мы берем дерево, эффективный саб, супербольшой элемент.
Нет, можно просто эффективную вершину создать,
типа, у крайнего правого.
Если ты...
Ну, может, я не знаю.
Если ему идет эффективная вершина...
Это будет наибольшая вершина.
Да, по-моему.
Сейчас, вы хотите сделать
эффективного правого сына у самой правой
вершины?
Так, и минус-минус тогда
от него будет...
Ага.
Что вам надо?
Этим эффективным элементом.
Ну...
Еще раз.
Вам придется и впасть,
все.
Нет, нет, нет.
Подожди.
Я хочу добавить...
Минус-минус, да?
А lower bound ты как будешь делать?
Стой, подожди. Ты хочешь добавить вершину
в дерево прямо?
Ну да.
Я бы помогал подвлечь ее самым правым сыном.
Это совсем бредово.
Ну, окей, есть вариант.
Есть вариант.
Значит, короче, давайте я...
Я, честно признаюсь,
что я не читал кота СТЛя в этом отношении.
Ну...
Не...
Именно по этому поводу
я его не читал. Вообще-то я, конечно, читал.
Вот. Но есть другая идея.
Я читал, что на Stack Overflow про это пишут.
Значит...
Нет. Предлагается сделать
не эффективного правого сына,
а эффективный корень.
Так, чтобы все наше дерево было его левым под деревом.
То есть, на самом деле,
у нас есть root, а у нас есть еще...
Ну, то есть, все наше дерево выглядит вот так.
И вот это настоящий root.
А это end.
А это тоже, как бы,
вершинка node, да?
Да. И тут мы опять приходим к той же
проблеме, а что это за
вершинка? Ну, и опять, видимо, надо
сделать base node. То есть, вот это будет base node,
а это нормальный node.
Не, ну, типа, он будет просто хонить, и когда
он будет запросить, он сразу влево.
А? Что?
Когда он будет запросить, он сразу влево
уходить от нее. Может же, как бы...
Ну, да.
Ну, да.
Ну, вот. Кажется...
Ну, потому что здесь же у тебя...
Какой ты ключ из значения будешь хонить? Опять,
что ты там положишь? Вот.
Причем тут можно игнорировать вообще.
То есть, вот для этой вершины можно
игнорировать, не поддерживать все эти вот
свистопляски с красным-черным,
потому что, ну,
там, неважно, корень должен быть
обязательно там черный, да?
Ну, у нас будет такой, а когда мы будем
провериваться, ну, у нас император,
вот мы, значит, император у нас на корне.
Вопрос, как он дальше там будет делать,
условно, плюс-плюс?
Чего так нормальный? У тебя
бигинт тут, бигинт, ты помнишь,
где, а энд?
Плюс-плюс от энда, то уберем всегда.
Плюс-плюс от корня.
Он пойдет в правое под дерево его.
Просто вопрос, как же у нас указатель в корень?
Ну, не в корень, который... Просто пойдет в правое
под дерево. Который не в это,
который реально в корень дерева.
Это энд, это энд, плюс-плюс от энда?
Это не энд, это тот, который выше него.
Стой, стой, стой, стой.
Ты помнишь, что я там
полторы минуты рассказывал,
как мы делаем плюс-плюс?
Вот, я вершина, как мне сделать
плюс-плюс?
Ну как, спускаешь там...
Я проверяю, есть ли у меня правый сын.
Если у меня есть правый сын, я иду в него
и в его самого левого-левого сына.
У меня есть правый сын?
Окей, с отераторами разобрались.
Теперь компараторы.
У мэпа, помимо
всего прочего, еще есть кастомный
компаратор. Тут, на самом деле, есть третий шаблонный
параметр, над которым вы обычно
не думаете, потому что он
по умолчанию равен...
А чему он, кстати, по умолчанию равен?
СТДЛС от K.
Вот. Значит, компеер
равно СТДЛС от K.
Я думаю, что
есть еще четвертый локатор.
Про локаторы мы пока
не будем говорить.
Про...
Про БДС пошел в чат.
Про локаторы мы поговорим,
я надеюсь, на следующей неделе уже.
Вот.
Ну, про них, конечно, обязательно
поговорим. Так вот, компаратор.
Да, значит, СТДЛС
от ключа.
Хорошо.
Но вы можете, конечно, передать свой.
В частном, например, вы можете
свой функциональный класс написать.
Там...
Ну, или лямбда функции. Ну, давайте пока
говорить про функциональный класс.
Какой-то класс, у которого есть
оператор круглые скобочки
от двух ключей, который возвращает
то, что вы называете
меньшим. То, что вы называете
результат сравнения, который
вы хотите, чтобы работало логично меньше.
Что будет, если сюда
передать
вещь,
которая не удовлетворяет отношению
порядка? Ну, будет УБ.
Ну, как и в случае с сортировкой,
если вы передадите компаратор там, который
на самом деле
не транзитивен. Ну, будет УБ,
а все сломается.
Кто-то, по-моему...
Я помню, кто-то в Яндексе
из народа рассказывал, что он
как-то так развлекался и смотрел, как
все торжественно падает.
Если вместо оператора меньше
передать меньше либо равно,
то там иногда падает сортировка, иногда
не падает, иногда падает мапа, иногда
не падает. Ну,
таки УБ, да.
Вот, хорошо.
Ну, а собственно, что?
Все, в общем-то, про компаратора больше говорить
нечего.
И про что осталось поговорить?
Сейчас я посмотрю, потому что у меня есть список,
про что надо поговорить.
И у нас, кажется, как раз первая пара
закончилась.
И еще сейчас будет вторая.
Да.
Нет, сначала перерыв, потом вторая.
Так.
Я еще
Осталось...
Нет-нет, еще
две вещи скажу, сейчас про мэп
закончим и дальше перерыв сделаем.
Потом оно ордер, мы будем обсуждать.
Две вещи,
которые я хочу сказать. Первая вещь.
Еще
я забыл упомянуть такие методы,
а на мой взгляд важно, вот,
к разговору про итераторы. Есть такой метод
insert,
который принимает еще
итератор, помимо пары.
Нет.
Insert с параметрами
итератор и еще value type.
Да, insert с подсказкой.
Insert с подсказкой.
Знаете ли вы что.
Да.
То есть...
Ну, вы
допустим...
Ну.
Нет, гарантировать ничего
не нужно.
Нет, ты можешь передать любой
какой угодный итератор, просто если он
окажется неподходящим, то он обычно insert
сделает. Insert с
подсказкой он просто...
Он первым делом пытается
посмотреть, ну, грубо говоря,
он обход от этого итератора начинает.
Вот так, я думаю. То есть он пытается
взять место в дереве не от корня
идя, а от того, что ты ему дал.
Потому что, может быть, ты уже и так знаешь,
куда вставить надо это будет.
Вот этого я не знаю.
И мне кажется, этого не написано даже в
стандарте, то есть
компилятор как-то делает.
Компилятор
как хочет
использует информацию, но если уж вы
передадите ему итератор прямо вот на то место,
после которого
я думаю, что он
и в другую сторону попробует.
В общем, я не
могу сказать точно, как именно он
использует эту подсказку, но
в общем, она есть.
Можно использовать
такой метод.
Для мэпа это ускоряет иногда.
Если вы
бьетесь за производительность.
Ну и последняя вещь, про которую надо сказать,
про которую мы забыли
поговорить про лист, но в листе
там особо нечего про это говорить.
Давайте поговорим про
такую вещь, которая называется Exception Safety.
Вы же помните, что в мэпе,
как, впрочем, во всех контейнерах,
методы должны быть строго
безопасны относительно
исключений. Strong Exception
Guarantee.
И давайте
подумаем, какие могут быть проблемы.
Ну, с вектором это понятно, там у нас
был тот еще
геморрой, там перекладывать надо иногда, релоцировать.
С листом
особо нет проблем.
Случилось исключение, ну просто
вершину надо...
Ну, просто у тебя
если там конструктор
ключа или конструктор
Value кинул исключение,
ну надо диалоцировать вершину,
вот эту, которую ты создал.
И все.
А не забыть.
А в мэпе что может не так пойти?
Вот если у меня...
Вот если я, например,
делаю какой-нибудь оператор квадратной скобочки
или add или insert,
и у меня какой-нибудь конструктор
key или value
кидает исключение,
что я тогда делаю?
Ничего страшного, потому что в каком случае это происходит?
Когда мы дошли до низа дерева,
мы еще ничего не переграсили,
ничего не повернули.
Мы просто дошли, вставили вершину,
создали значение помолчания, скажем,
все упало, и мы такие, ну ладно,
не делаем.
Просто мы не...
То есть мы создаем ноду до того,
мы создаем ноду до того,
как начали дерево перестраивать.
Просто так мы ее создали,
и мы такие, окей,
если не получилось создать,
просто диалоцируем,
и дерево не пострадало.
Вопрос. Чего мы забыли учесть?
Что еще может
кинуть исключение?
Вряд ли обращение и сравнение
не может кинуть исключение, или может?
В смысле, вряд ли?
В смысле, с вероятностью
ноль или как?
Что значит вряд ли?
Мало вероятно, давайте считать,
что не кидает.
У нас еще есть такая замечательная вещь,
про которую я вот упоминал, вот это вот.
Вот может не надо.
Что если во время сравнения
ключей вылетело исключение?
Поминки, все.
Мы ключи сравниваем тоже.
Чего?
Ну правильно.
На самом деле, да.
Давайте вспомним,
а как происходит вставка в красно-черный?
Самое время сейчас про это вспомнить.
Когда мы вставляем что-то в красно-черный?
Когда вообще компаратор нужен?
Когда мы идем по дереву, чтобы найти место?
После того, как мы нашли место, куда вставлять,
создали вершину, подцепили ее к этим,
и сейчас будем выяснять,
не нарушился ли баланс и делать
повороты, вот эти, перестраения,
вот эти долбанные.
Мы в этот момент
используем компаратор, когда повороты делаем,
или нет? На самом деле, нет.
Потому что, да, у нас уже
все соблюдено, и нам
надо только смотреть на
ключи в вершинах
и перестраивать в зависимости от них.
Но сам компаратор мы уже не вызываем,
после того, как вставили вершину
и начали делать повороты.
Вот. А когда еще мы...
Когда мы делаем эрейс,
мы тоже...
Вот с эрейсом поаккуратней
надо быть. Когда мы дошли
до места, где лежит вершина,
уничтожили ее, если мы
забудем...
Если мы, короче, сделаем удаление
вершины до того, как поймем,
куда подцепить там,
кого из предков подцепить на ее место
теперь, то это будет фейл.
То есть нам нужно сначала
отцепить вершину
и встроить этих
ребят в дерево.
Только потом удалить. То есть
надо, чтобы ни один вызов компаратора
не случился после того, как мы уже поработали
с этой самой вершиной, чтобы мы ее отцепили
или наоборот прицепили.
Вот. Но да, компаратор может
кинуть исключения, и это тоже
учитывается в реализации мэпа.
Вот.
Такие дела.
Ну, наверное, все, что я хотел сказать
про мэп.
Давайте сделаем перерыв.
