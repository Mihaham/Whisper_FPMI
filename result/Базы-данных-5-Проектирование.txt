Пятая лекция. Немножко некорректная заголовка. Прошу прощения, здесь, конечно, не основа DML.
У нас продолжение темы проектирования. Мы ее сегодня заканчиваем. Рассмотрим
ссылочную целостность и нормализацию. И на следующей лекции по этому напишем соответственно
quiz. Хорошо, проектирование мы, в общем, с вами разбирали на прошлом занятии, в конце. В общем,
мы основные шаги рассмотрели. Сейчас просто быстренько пройдемся, вспомним, как это было.
Проектирование подразделяется у нас на три этапа. На три этапа концептуальная,
аналогическая и физическая по уровню приближения к тому, как наша схема данных, модель данных
будет выглядеть непосредственно в базе данных. С точки зрения языка SQL, конечно же. То есть мы
от более общего опускаемся к более частному. В конечном итоге, на уровне физического
проектирования у нас должен быть готов код DDL, код на языке SQL, соответственно в котором мы
создадим необходимые таблицы и наведем между ними функциональные зависимости. Каждая последующая
стадия проектирования подразумевает усовершенствование модели, полученные на предыдущей стадии.
И на этапе физического проектирования у нас появляются уже конкретные ограничения на данные,
какие-то проверки данных, появляются специфические технические таблицы для связывания между собой
различных отношений по типу «многие ко многим» или «один к одному». С точки зрения революционной
модели такие взаимосвязи не очень хороши, но с точки зрения практики они возникают,
поэтому их надо безусловно отражать. И технически это просто делается через дополнительную
промежуточную таблицу, к которой у нас связи соответственно получаются «один ко многим»
или «многие к одному». Сейчас я покажу уже на примере более конкретно. Концептуально у нас,
если начинать с проектирования концептуального, есть два способа нотации для IR-схемы.
IR-схема — это Entity Relationship-схема, основанная на Entity Relationship Model. На модели сущность-связь
наиболее общий уровень, наиболее общее понятие о предсветной области мы можем таким образом
отразить. Это просто для общей информации, что можно отражать в нотации чена, в нотации воронья
лапка. Мы используем в нотации воронья лапка, конечно. Вот мы с вами рассматривали концептуальную
модель ресторана. В прошлый раз говорили о том, что у нас между сущностями, заключенными графически
в прямоугольнике, наличествуют связи изображенных в виде различных дуг. Различия в дугах
показывают кардинальность той или иной связи. То есть многие к одному, многие к одному или нулю,
или один только один к нулю или ко многим. Круглешок, соответственно, ноль. Две палочки — это один только один.
Выглядит концептуальная модель соответственно так. Логическое проектирование. Спускаемся на
уровень ниже. Можно представить себе логическую схему вашей базы данных. В общем,
логический уровень проектирования можно представить или вернее его результат можно представить,
как показано на картинке на слайде. Соответственно, видите, у нас появляется чуть
более детализированное представление. У нас появляются уже первичные и внешние ключи,
появляются атрибуты на различных отношениях. И конечный уровень. Здесь такой кусок маленький
показан, потому что, честно говоря, не нашел какого-то приемлемого представления. И самостоятельно
ничего такого простого наглядного, наверное, придумать не смог. Ну, не то, что не смог.
Можно, конечно, искусственно сделать две-три таблицы просто здесь. Что интересно,
если вы обратите внимание, у нас есть таблица «Дело – нижнее подчеркивание судья». Это фрагмент
трекера юродепартамента. Ну, таск трекера. Ну, такой, да, очень отдаленный фрагмент от того,
что в принципе там в итоге было. И не финальная стадия. Но, тем не менее, это такая рабочая,
в общем-то, модель. А здесь, почему я заостряю ваше внимание, вот «Дело – судья» – таблица,
и «судия-судия» – суд-судия, соответственно, вот здесь вот и вот здесь. У них связи многие
ко многим как раз. Почему так происходит? Потому что здесь немножко в предметную область придется
погрузиться буквально на пару минут. Проблема в том, что у одного судьи может быть много дел,
и у одного дела могут сменяться судьи, которые его рассматривают. Либо, наоборот, могут быть
коллегиальные составы суда, исходя из специфики данной предметной области, данного таск трекера.
Повторюсь, это кусок, он отдаленный кусок дедра, скажем так, логического, реального. Поэтому у нас
здесь может быть как-то вот не очень понятно, где здесь таски, где здесь вообще департамент,
здесь суд, дело к чему все это, о чем. Но уж на это не обращайте внимание. Здесь самое главное,
вот дело судьи, и суд-судья – многие ко многим связь. Это не классическая релиционно-модельная
связь, это связь, которую нам приходится моделировать через техническую таблицу,
в данном случае две технических таблицы. Ну, такое может быть, такое встречается. Это не то,
чтобы прям нормально, наверное, по классике, но это в целом то, к чему нужно быть готовым. То есть
когда у нас появляется такое соотношение, что у нас и с одной стороны, и с другой стороны,
причем эти технические таблицы, они, как правило, часто состоят просто из двух атрибутов, где один
атрибут из одной таблицы является первичным ключом другой атрибут, первичным ключом для
другой таблицы, и они таким образом как будто бы джойнятся, соединяются. Ну, хорошо. Для чего нам
необходимо вообще проектировать БД? Помимо каких-то общих фраз есть на самом деле теоретически
вполне выверенные, теоретические положения, которые обсуждаются в литературе, по релиционным
базам данных рассматриваются, которые мы должны тоже с вами понимать не просто на уровне,
потому что спроектированная база данных должна работать лучше, а мы должны понимать,
почему конкретно лучше ее владеть паникийным аппаратом. А в данном случае мы проектируем
для того, чтобы исключить избыточность данных и обеспечить поддержку целостности, ну или в
частности ссылочной целостности. Нас интересует в первую очередь, конечно, она, потому что,
в общем-то, избыточность и поддержка целостности, поддержка не ссылочная, просто целостность,
повторюсь, до некоторой степени перекрещивающееся понятие. В общем, нам нужно исключать избыточность
данных, обеспечивать ссылочную целостность. Это важно для поддержания корректности данных
при хранении и обработке. Если пренебречь качественным проектированием, прошу прощения,
то мы можем столкнуться с аномалиями при добавлении, модификации и удалении данных.
Аномалии будут заключаться в том, что вместо локальных действий с отдельными порциями данных нам
придется шерстить всю таблицу, а может быть даже взаимосвязанное, какое-то количество
взаимосвязанных таблиц, чтобы внести связные изменения везде. Сейчас поговорим обо всем этом
подробнее. И для качественного, соответственно, проектирования БД нам необходимо проводить
нормализацию данных, использовать средства поддержания ссылочной целостности. Сразу,
забегая на несколько слайдов вперед, скажу, что часть этих средств поддержания ссылочной
целостности мы на самом деле с вами уже рассматривали и говорили в частности о ограничениях и ключах.
И как мы с вами об этом говорили на второй лекции, мы возвращаемся к этим средствам,
к ключам для рассмотрения их более подробно именно в контексте проектирования сейчас,
на нашей пятой лекции. Что нужно еще знать с точки зрения набора таких общепринятых понятий?
Определение представлено, опять же, на экране. Целостность сущности заключается в чем? Это
требование к тому, что любое отношение у нас должно обладать потенциальным ключом. У нас
должен быть какой-то атрибут или набор атрибутов, которые характеризуются свойствами,
как вы помните, уникальности и несократимости, неизбыточности. То есть мы не можем вынуть из
нашего первичного ключа данные, которые в нем дублируются, потому что таких данных в нем быть
не должно. Если мы говорим о том, что у нас составной потенциальный ключ, то соответственно
мы не можем вынуть ни часть, ни целую запись этого составного потенциального ключа тоже под страхом
того, что мы нарушим требование к неизбыточности. То есть мы не просто сделаем менее избыточным,
а у нас информация будет недоставать. Поддержание целостности осуществляется средствами СУБД,
то есть при добавлении записи в таблицу проверяется уникальность первичных ключей и не допускается
изменения значения атрибутов, входящих в первичный ключ. Ссылочная целостность — это
необходимое качество релиционной базы данных, заключающееся в отсутствии в любом ее отношении
внешних ключей, ссылающихся на несуществующие кортежи. То есть здесь важно, что у нас вот это
наше ограничение, фаруэн кии, какая-то таблица, какое-то поле, какой-то атрибут не ссылается в
пустоту. Это принципиально важная вещь, потому что у нас по сути дела нет каких-то механических
связей между нашими отношениями. У нас сама по себе наша база данных, после того, как мы
внесли в нее нашу схему данных, создали какое-то количество взаимосвязанных таблиц, или просто
для примера возьмем. Она не знает, что с ними делать. Мы должны в явной форме задать зависимости.
Задать мы их можем только посредством первичного и внешнего ключа. И только соблюдая ограничения,
наложенные отношением внешнего и первичного ключа между собой, мы можем гарантировать,
что у нас будет поддерживаться ссылочная целостность. Это необходимое, скажем так,
но этого недостаточно. У нас, конечно, есть еще дополнительные средства, о которых сейчас
тоже поговорим и вспомним. База данных обладает свойством ссылочной целостности, когда для любой
пары связанных внешним ключом отношений вне условия ссылочной целостности выполняется.
То есть когда у нас не пустая ссылка, не битая ссылка. Избыточность данных, это по сути дела,
просто-напросто дублирование данных в базе. Здесь важно только сказать, что под избыточностью
понимается не только дублирование целого кортежа, целой записи, а в том числе дублирование
значения части атрибутов кортежа. Сейчас мы посмотрим на это воочию, когда будем рассматривать
примеры отдельных аномалий. И аномалия – это ситуация в таблице базы данных,
которая приводит к противоречию в базе данных, либо существенно усложняет обработку базы данных.
И причиной аномалии является излишнее дублирование данных в таблице. Излишнее взято в скобке,
потому что на самом деле у нас за недублирование данных отвечает процесс нормализации. Но проблема
в том, что если мы будем нормализовывать наши данные максимально возможным способом, пойдем
не просто до второй, до третьей нормальной формы, пойдем еще ниже нормальной формы бойса кода,
но это еще не самый низ далеко. Шесть нормальных форм выделяют. Классическая литература базы
данных. Если мы пойдем ниже, спускаться все глубже в эту нормализацию, у нас просто получится много
таких малоатрибутивных отношений, по которым нам придется делать запросы, просто постоянно
их соединяя между собой. У нас из-за этого потенциально может сильно увеличиваться время
обработки запроса в чрезвычайно нормализованных ситуациях. На практике на самом деле смотрят
исходя из того, где образуется бутылочная горлышка. Потому что, повторюсь, не всегда
оптимальным является формальная теоретическая нормализация. Однако, тем не менее, в ваших
курсовых проектах и, в принципе, на практике при именно проектировании данных, базы данных,
необходимо отталкиваться с сухой теорией и пытаться нормализовать все. Обычно до третьей
формы нормальные бойса кода нормализуют. И вот стараться на этапе проектирования так
нормализовать. Потом денормализацию провести вы сможете, если провели правильно и корректно
нормализацию. Здесь проблем нет. А вот денормализацию провести вы сможете, и при этом вы будете
ее проводить уже на каких-то реальных статистических данных по тому, как ваша база данных работает в
продакшене. Какие их не запросы, какая статистика, на каких узлах какая нагрузка и так далее и
поэтому проектируем мы всегда вот по по инструкции так сказать до третьей как минимум нормальной формы
обязательно доходим здесь немного дальше просто обзорной информации да вот чтобы все это как-то
еще и графически показать то есть цели проектирования избежать избыточности обеспечить поддержку ну
ссылочной до целостности в первую очередь последствия некачественного проектирования это
аномалия как мы сказали их три штуки это добавление редактирования и удаления как в это все выглядит
опять же повторюсь мы посмотрим сейчас предметные подробно и поддержка корректности данных
обеспечивается чем нормализация средства поддержания со слышной целостности одно из
важнейших средств это повторюсь ключи позволяющие устанавливать зависимости между отношениями по
сути дела у нас нет иных способов установить взаимозависимости между разными отношениями
кроме как через ключи и сейчас у нас будет даже ограничение на действия по модификации данных
вы увидите и там тоже они устанавливаются при наличии именно внешних ключей то есть
ключи внешние ключи до первичный этап связывания отношений в какую-то структуру давайте посмотрим
с вами на аномалии обновления в чем они заключаются вот аномалия добавление что из себя представляет
возникают такие аномалии когда информацию в таблицу нельзя поместить пока она не полная
либо вставка записи требует дополнительного просмотра таблицы о чем идет речь вот у нас
есть некоторое отношение в котором перечислено какие-то поставки при этом у нас помимо собственной
информации о товаре есть еще название поставчика есть адрес поставщиков и у нас эта таблица одна
она ни с чем не связана уже как бы да вы имея определенный практический опыт первого месяца
курса должны я думаю понимать что что-то здесь неправильно что-то не очень хорошо это выглядит
что здесь не очень хорошего вот мы не можем данную таблицу добавить новую запись если не
известно значение первичных ключей например мы заключили контракт с поставщиком 3 и не можем
добавить информацию о нем в таблицу так как еще не было поставок то есть но технически конечно
здесь стоит оговориться что мы бы в принципе могли бы в принципе могли сказать что у нас все
значения будут дефолтными по умолчанию кроме названия поставщика и адреса поставщика и у нас
тогда была бы таблица одна наша по типу экселевской книги с ее листами листом даже одним где у нас
просто в одной из записей вот здесь 6 строк и седьмой строкой была бы там номер поставки причем
первичный причем это первичный ключ до номер поставки у нас бы обработался здесь был бы
уже ну 4 поскольку новый поставщик очевидно название товара у нас было бы возможно здесь тоже
кстати вопрос какое бы название товара в данном случае по дефолту вот нет получается даже мы
не могли бы здесь не могли не могли бы никак дефолтом все это установить у нас все равно была
бы ошибка потому что мы бы не знали что внести на этапе когда у нас появился поставщик но нет
поставки а при этом внести вот в эти поля мы должны были информацию должны были бы быть здесь
был поставщик 3 адрес 3 и обязательно здесь был бы поставка 4 название товара там бумага для
принтера цена ну цена количества кейтом не обязательно а при этом он еще ничего не
поставлял ну проблемы очевидно проблемы это это не здорово но не то что не здорово да это
очевидно не влечет какие-то проблемы связанные с дальнейшей эксплуатации нашей базы мы добавляем
туда лишние данные по сути дела которые ничем не обоснованной и не нужны она в части первичных
ключей я имею ввиду которые обязательно к заполнению давайте посмотрим дальше аномалии редактирования
или модификация такие аномалии проявляются в том что изменение одних данных может повлечь
просмотр всей таблицы и соответствующее изменение некоторых записей таблицы так
вопрос да совершенно верно вопрос в чате но тогда ведь просто нужна отдельная таблица с
поставщиками в чем проблема данной таблицы в том в том и проблема в том и проблема ребят что у нас
по условиям данного примера отдельной таблицы с поставщиками нет именно поэтому это ну да это
это искусственный пример это пример лекционный то есть по идее там в жизни было бы что-то более
более разумные скажем так здесь очевидно напрашивается вывод что вот эти две колонки
они должны быть в отдельной таблице и связь там по через внешний ключ потом майди поставщика
но здесь примере у нас только одна таблица и поэтому как бы это проблема но пример масштабируем
на практике такое возникает сплошь и рядом когда оказывается что в насилие вносили в таблицу вносили
вносили там половина записи ну не обязательных налы праймеры киев они просто если суррогатно
еще куда не шло а если это праймерики да вот не суррогатные естественные то проблемы возникают
чтобы тогда в них заполнить опять же возникают проблемы с тем что даже праймерики ладно бог с
ним цена и количество товара там в реальных каких таблицах не может быть может не быть
установлены дефолтных значений для тех полей которые не являются первичными ключами но
которые все равно таким образом должны были бы быть заполнена реальная информация и что в них
вставлять вообще какие-то филлеры там в цену товара тогда пришлось бы нолик вставлять в
количество тоже нолик ну лишняя строка причем там лишние там понятно это байты какие-то с
точки зрения физического хранения но по факту одна запись другая третья если их десятки тысяч
если это вообще какой-то какая-то таблица связанная не знаю с лагированием с которой
постоянно ежедневно туда-сюда перезаписывается в общем там возникает возникает проблема поэтому
вы сказали вы заметили правильно правильно но повторюсь пример данным случаем несколько
искусственный просто целях упрощения нам с вами и наглядности больше аномалии редактирования
как я уже сказал да проявляются в том что изменение одних данных может повлечь просмотр всей
таблицы и соответствующие изменения некоторых записей в таблице ну вот у нас здесь выделено
до по две строки в чем здесь может быть проблема если мы что-то модифицируем проблема простая если
мы изменяем данные одной записи и хотим изменить адрес поставщика 1 нам придется менять адреса
во всех строках поскольку у нас здесь нет связи по id поставщика с таблицей поставщиков мы вносим
вот этот поставщик один адрес один эти записи везде везде везде где у нас поставщик один реально
что-то поставлял ну и соответственно опять же это у нас здесь только 6 строк в таблице в реальной
таблице это может быть там десятки тысяч строк чтобы причем представляете там город
переименовывается например у нас там целый каскад поставщиков просто в этом городе находящихся
которые по которым надо менять едва ли не всю таблицу но в части конечно но тем не менее там
соответственно блокируются операции какие-то там чтение или записи ну чтение наверное нет в
зависимости там от уровня опять же защищенности ну запись скорее всего заблокировалась бы на
долго аномалии удаления при удалении какого-либо кортежа из таблицы может пропасть информация
которая не связана напрямую с удаляемой записью тоже все в принципе так же тривиально да из-за
счет тривиальности примером мы хотим удалить запись о поставках поставщика 2 но проблема в
том что информация о поставках у нас зашитов первичный ключ и мы не можем оставить пустой
первичный ключ но название поставщика адрес поставщика соответственно у нас удалится вся
информация о поставщике 2 его адресе который у нас хранилась в этой общей нашей единственной
сизой убогой таблички куда мы носили вообще всю информацию которую только могли и соответственно
удаляя только часть по сути ну логически необходимо нам удалить только часть мы удалим
вообще все вот собственно три таких три таких варианта аномалии давайте еще раз аномалия
добавления когда мы пытаемся что-то добавить локально а не можем ставить потому что нужно
нужны дополнительные данные которые у нас требуется по условиям ограничений на нашу
таблицу аномалии редактирования когда мы хотим отредактировать только часть записей только часть
какой-то записи по сути нам надо отредактировать но за счет того что избыточная информация нам
придется менять все записи и аномалии удаления когда мы хотим удалить опять же только часть
данных по какой-то записи но нам придется удалять целиком записи потому что она не может быть
оставлена в таблице опять же исходя из тех ограничений которые для данной таблицы установлен
окей что дальше ссылочная целостности ключи как мы с вами помним со второй лекции и как вы
знаете семинаров у нас есть набор средств по формулированию ограничений при создании таблиц
вот эти средства у нас перечислены на слайде мы с ними знакомы а подробно останавливаться не
будем но да вот то есть мы их рассматривали в контексте как бы базового такого синтаксиса
но вот у них есть еще и такое вот логическое до нас и значение с точки зрения модели религационной
как вспоможение в проектировании базы данных поэтому это не просто синтаксис это важные
важные элементы проектирования которые нужно иметь в виду но помимо перечисленных ограничений
есть еще такое такое средство как задание определенного поведения для вашей суббд при
удалении некоторые строки или изменения некоторого значения во внешней таблице то есть в
таблице на которую у нас ссылается внешний ключ и стекущий при этом если при изменении данных
строка изменена но это изменение не затронула целевые столбцы никакое действие производиться
не будет ну это такая ремарка на полях я здесь скупках привел как бы такая подстрочное
примечание скорее о чем идет речь вот средство поддержание ссылочной ссылочной целостности вот
есть еще и такие они у нас формулируются на этапе формулирование ограничения по внешнему ключу
здесь синтаксис на слайде приведен только один из как вы должны помнить из прошлой лекции ну
со второго по счету дека и знать семинарских занятий и исходя из документации с которой вы
должны очевидно были работать у нас синтаксис задания ограничений довольно богатый он
предполагает несколько он предполагает вариативность формулирования ограничений
данном случае здесь даже нет у нас про инки форейнки ключевых слов да просто
референс из с команды предложение референс из и дальше то на что ссылается собственно
вот это вот референс из ссылка на что она идет и дальше за него то о чем мы сейчас с вами
говорим он delete cascade то есть при удалении либо у нас вариант есть еще он update при удалении в
данном случае ну или при изменении таблицы в данном случае это таблицы кастомерс у нас
каскадно должны были бы удаляться все строки ссылающиеся на удаляемую запись либо должны
были поменяться значения в ссылающихся столбцах на новые значения во внешних столбцах соответствия
с операцией он update но в данном случае работает первая часть утверждения повторюсь поскольку
в примере он delete что мы еще можем сделать мы можем у нас есть еще такие предложения как но
action тогда у нас при удалении или изменении данных во внешней таблице будет система выдавать ошибку и
препятствовать изменению данных в основной таблице restrict у нас также выдает запрещает нам
удалять данные из внешней таблицы cascade удаляет или изменяет каскадно изменяет да в соответствии
с изменяющимися значениями мы также можем установить нал или установить default на
значения во всех ссылающихся столбцах или в указанном под множестве ссылающихся столбцов
как показано на слайде да то есть мы можем задать перечень именно атрибутов которые мы
хотим изменить под множество столбцов при этом можно указать только для действия он delete и
для сет default у нас если значение по умолчанию отличный от нал то во внешней таблице должна
быть строка соответствующей набору этих значений в противном случае с операция завершится ошибкой
так ну в принципе довольно здесь мне кажется все просто там ничего никаких специфических
вещей здесь кажется сказать уже дальше больше и не надо с учетом того чтобы с вами разобрали
ограничение предыдущие хотелось бы еще немножко освежить потенциальные первичные внешние ключи
в вашей памяти да что такое потенциальный ключ это атрибут или под множество атрибутов
которые удовлетворяют требования уникальности и несократимости потенциальный ключ у нас
существует всегда если он включает все атрибуты отношения и это следует у нас из определений
из основных определений определение заданной корреляционной моделью и потенциальных ключей
может быть несколько мы здесь соответственно можем выбирать как между потенциальными ключами
так и можем составные потенциальные ключи составлять если у нас получается что да вот
эти вот там пары тройки и так далее n-ки атрибутов будут уникальны для каждого кортежа в нашем
отношении первичный ключ соответственно как вы должны были помнить это у нас потенциальный
ключ отношения которые выбран в качестве основного и определение внешнего ключа но опять же да вот
повторюсь по сути дела внешний ключ у нас представляет собой не более чем способ задания
ссылки между между способ пересыливания да между одной таблицей другой между таблицей
которая по ограничению фаренки ссылается на какой-то первичный ключ некий в родительского
отношения свойства ключей какое основное свойство ключей с точки зрения реляционной модели это
возможность формировать функциональные зависимости между отношениями что это значит что такое
функциональная зависимость здесь на самом деле все тоже довольно просто это то что мы с вами все
знаем из школьной еще математики то есть когда у нас есть два множества и одно в другое отображается
так что значение из множества у определены за счет значений из множества x и для каждого
кортежа отношения r если два кортежа отношения совпадают по значению x они совпадают по
значению y или что эквивалентно не существует двух разных кортежей которые в атрибуте x
имеют совпадающие значения а в атрибуте y имеют разные значения ну вот буквально
там математическое определение функциональной зависимости когда у нас есть функция f от x
собственно говоря такая же функциональная зависимость по сути своей да вот по логической
структуре какой-то им да по своей структуре возникает между отношениями за счет первичных
и внешних ключей давайте поговорим с вами про нормализацию в данном случае что это такое для
чего нам это нужно казалось бы у нас есть у нас есть способы задания функциональных зависимостей
у нас есть и пилу по сути дела говоря более таким огрубляю что ли да у нас есть способ задания
ссылок между отношениями у нас есть способ способы для того чтобы проверялись вносимые или
изменяемые данные на соответствие каких-то ограничений для чего нам еще нормализация а для
того чтобы мы когда мы проектируем нашу базу данных несмотря на все вот эти замечательные
средства и возможности как сql так и система управления базами данных для того чтобы у нас
после проектирования не было стемантической избыточность избыточности в наших данных причем
повторюсь как я говорил в начале лекции не только избыточности с точки зрения дублирующихся
кортежей которые в принципе у нас запрещена только теории мы можем создать таблицу в нашей
позгресс ql в которой мы будем в которую мы будем вносить абсолютно идентичные записи или
например мы можем по всем нашим полям поставить дефолтные значения и просто вносить default
insert values там да и insert into такой это такая таблица default значение она будет носить
default значение там может быть даже без первичного ключа если мы создали наши отношения даже не
будет никакого авто инкриментирование по полю первичного ключа пожалуйста а
таким образом чтобы у нас не было ни повторяющихся кортежей не кортежи которые частично пересекаются
между собой по содержащимся в себе данным содержащимся в себе элементом вот как мы
видели в аномалиях обновления когда у нас этот перехлёст шел за счет поставщика и адреса
поставщика хотя таблица посвящена в первую очередь исходя из первичного ключа до продуктом
для того чтобы у нас такого перехлёста не было даже частично по отдельным элементам кортежей
придумано определенная логическая получается процедура да а которая позволяет нам постепенно
продвигаясь от первой нормальной формы и далее по списку но обычно повторюсь доходят на третий
или может быть нормальный форма бойса кода нормализовать наши отношения таким образом чтобы
поставщики у нас были в одной таблице товар у нас были в другой таблице или как-то еще больше
дискритизировать дискритизировать наши данные разбив их по более мелким отношениям ну в
области соответственно у нас нормальная форма это свойство отношений в релиционной модели данных
характеризующие его с точки зрения избыточности потенциально приводящий к логически ошибочным
результатам выборки или изменения данных нормальная форма определяется как совокупность
требования которым должно удовлетворять отношения и приведение процесс приведения базы данных
к нормальной форме называется нормализация что еще важно здесь сказать то то что ну я уже в принципе
об этом упоминал но повторюсь у нас каждая последующая нормальная форма каждая последующая
форма включает в себя ограничения всех предшествующих нормализация у нас предназначена
отнюдь не для хотя мы говорим про избыточность да но она предназначена отнюдь не для изменений
как физического объема данных и в принципе у нас наша релиционная модель наша релиционная база
данных она не говорит нам ничего о том что ее конечной целью должна быть их конечными целями
должно быть уменьшение съедаемого дискового пространства нет у нас должна быть минимизация
логической избыточности и уменьшение потенциальной противоречимости и таким образом напрямую
требования по нормализации на производительности на физический объем не влияют но здесь такая
нелинейная зависимость есть как я уже говорил да в принципе если мы очень сильно нормализуем
наши отношения очень их дискретизируем то у нас потенциальные запросы могут выполняться ну
просто ощутимо дольше с другой стороны если мы дискретизируем наши отношения его атрибуты
недостаточно сильно то мы просто будем вынуждены по сути дела гонять все время по одной и той же
таблице все наши запросы что тоже на производительности скажутся не лучшим образом поэтому здесь должна
быть золотая серия середины ну и повторюсь на этапе проектирования максимально стараемся
следовать нормализации вплоть до третьей формы за исключением и и в последующем динормализацию
проводить мы будем только исходя из каких-то реальных полевых так сказать данных данных
полевых испытаний по реальной отзывчивости нашей базы на конкретный запрос пользователей
нормализация нам позволяет некоторые типы избыточности исключить устранение некоторых
аномалий обновления для разработки проекта база данных которая является качественным
представлением реального мира интуитивно понятина легко расширяем в дальнейшем нужно
нормализация и упрощение процедуры применения необходимых ограничений целостности тоже
достигается за счет грамотной ну по крайней мере последовательной до последовательной
нормализации последовательного проведения принципа нормализации в действительности
так
нормализация базы данных производится за счет декомпозиции как я уже говорил да
вернее прошу прощения говорили о денормализации на декомпозиции и у нас здесь появляется
эквивалентность операции у нас правильно проведенные декомпозиции должно быть
эквивалентно ну вернее обратно прошу прощения она должна быть обратной обратной обратимость
операции она должна быть обратно соединению и правильной декомпозиции вернее декомпозиции
называется декомпозиции без потерь или правильной если она обратимо путем соединения всех тех
результирующих отношений которые мы получили используя правила нормальных форм
перечень нормальных форм ну таких в некотором смысле классических да хотя
вот на практике ниже третьей и бойса кода ну можно сказать что особо-то и не опускаются
вопрос даже наоборот вопрос в том что различные решения тех или иных вендеров и даже опенсорс
решения часто могут применяться в одной фирме параллельно разных департаментах все это потом
в итоге сводится в какое-то какое-то хранилище либо вообще в озеро и из этого озеро или хранилище
или там океана данных достается это все в какие-то о лапубы трансформируется то есть все на самом
деле характеризуется скорее хаотичностью причем еще у нас на этапе дата вар хаусс хранилищ
данных есть свои требования по проектированию которые немножко отличаются
классическом подходе скажем так которые заложили кимбал и инман мы об этом с вами поговорим в конце
курса обзор на там есть свои в общем требования и при этом эти требования тоже сами не всегда
соблюдаются поэтому говорить о том что у нас вот прям есть какая-то реальная жизнь для там
что стоит для доменно ключевой нормальной формы в производстве в реальном продакшене за пределами
там теоретических изысканий ну скорее нет скорее нет если только вы там захотите какой-то может
быть pet project сделать где вы будете отвечать за все front-end и the back-end и в том числе за
модель данных вы там можете конечно нормализовывать как вы захотите реальных в реальном реальной
ситуации происходит так что конечно данные не то что тяжело нормализовывать их порой бывает не
просто сводить при большом объеме и разнородности лишь используемых решений для хранения не говоря
уже про то чтобы нормализовывать все вот этого едино а так ну давайте посмотрим по нормальным
что это такое и как так как это применяется применяется ну самое первое нормальное форма
самая простая определение проведено на слайде и переменные отношения находятся в первой нормальной
форме тогда и только тогда когда значение всех атрибутов отношение а там арды то есть отношения
находятся в первом нормальной форме если все его атрибуто являются простые все используемые
Домена содержит только скалярные значения, и выглядит это вот так, вернее, это не выглядит
вот так, потому что в данном случае у нас нарушено условие определения, у нас не все атрибуты
атомарны. И если атрибут-семинарист, несмотря на двусложность, двусловность строки, это все еще
строковый литерал, то атрибут группы это на самом деле не строка, ребята, это отдельные числовые
значения. То есть в первой строчке у нас три разных числа, а не строка с там получается
четырнадцатью символами. Ну и так, соответственно, по каждой строке каждой группы. Первая нормальная
форма у нас таким образом должна, для того чтобы ее, для того чтобы наше отношение вот это вот,
приведенное на данном сладе нормализовать, мы должны вот этот атрибут группы, его значение
развернуть, сделать все это одной большой колонкой, ну вернее колонкой с множеством строк. И таким
образом получается вот такой результат. Смотрите, атрибут-семинарист это строка просто. Это строка.
То есть не смотрите на пробел, он не дает автоматического разделения. Это строка вот Халляпов
от буквы Х до буквы Р. Единая большая строка. А атрибут группы это целочисленные значения,
и в данном случае вот они реально в диапазоне от 911 до 952. И мы развернули массив из целочисленных
элементов, по сути дела. Нет, там вопрос не в типе. Вопрос не в типе, конечно же, данных. Ну смотрите,
да, тип текста, тип блоп, они не будут простыми в таком классическом понимании. Но здесь это
вопрос скорее такой, да, логический что ли, нежели вопрос представления. Понятно, что строка это у нас
массив символов. Массив символов, которые у нас там, не знаю, наверное, мне кажется, не представляю
себе языка программирования, где нельзя было бы обратиться к отдельному символу в строке. Но в
данном случае речь идет не о типах данных, которые у нас напрямую завязаны на аппаратную
составляющую или на реализацию нашего языка программирования, на его виртуальные машины и
так далее, как он взаимодействует с аппаратной составляющей. Нет, здесь вопрос в том, какова
логика того, что мы делаем. И с точки зрения типов данных SQL стандартных, тип строка это атомарный
тип. Тип число, целое число, это тоже атомарный тип, и поскольку, да, ну окей, давайте так
представьте, что у нас в атрибуте семинарист все заключено в одинарной кавычке, а в атрибуте
группы не заключено в одинарной кавычке. То есть, чтобы было еще более явно, семинарист у нас все
строки с точки зрения стандарта SQL, там строка, причем не просто строка, давайте еще и возьмем
какой-нибудь, не знаю, war char конечной длины. Ну тоже, да, я соглашусь, что здесь есть определенная
непоследовательность, может быть, но надо, наверное, здесь отталкиваться не от такого прямого аппарата,
что ли, взгляда и подхода, а от подхода логического. Мы здесь разделяем сущности. Сущность халяпов
Alexander это вид instance, да, экземпляр класса семинарист, условно говоря. Сущность 911,
921, 924 это не экземпляр класса группы, это три экземпляра класса группы, и нам нужно эти
экземпляры разделить между собой, и в этом будет логика, это будет осмысленное действие с точки
зрения нашей модели. Разделение халяпов и Alexander на двух отдельных представителей класса
семинарист смысла будет лишь ино, поэтому это с точки зрения релиционной модели, о которой мы говорим,
потому что нормализация это операция в рамках модели релиционной, а не в рамках системы управления
базой данных. С точки зрения релиционной модели здесь все нормально, нет никакой проблемы с точки
зрения того, что строковый литерал у нас вот такой длитый, хотя можем теоретически поизвращаться и
попридумывать запросы даже из процедурного расширения постгроса каким-нибудь отдельным
символом как-то исхитриться вот этой строки. Вторая нормальная форма, вторая нормальная форма,
и здесь о чем идет речь. Переменные отношения у нас находятся во второй нормальной форме тогда,
и только тогда, когда она находится в первой нормальной форме, и каждый не ключевой атрибут
минимально функционально зависит от потенциального ключа. Давайте разбираться, что это все значит.
Функциональную зависимость мы с вами уже описывали, мы рассматривали ее несколькими
слайдами ранее. Еще раз просто воспроизведу, что между множествами атрибутов x и y функциональная
зависимость и ее наличие означает, что для любого допустимого набора картридж в данном отношении
верно следующее. Если два картриджа совпадают по значению x, то они совпадают по значению y.
При этом минимальная функциональная зависимость означает, что в составе первичного ключа отсутствует
меньшее под множество атрибутов, от которого можно также вывести данную функциональную зависимость.
То есть у нас, условно говоря, из первичного ключа, состоящего из трех атрибутов, нельзя сделать
первичный ключ, состоящий из двух атрибутов, который будет еще и представлять элемент
функциональной зависимости для данного картриджа. Давайте посмотрим на примере.
Вопрос, почему это не следует из определения потенциального ключа.
Из определения потенциального ключа это не следует, потому что потенциальный ключ у нас
говорит о том, что это просто набор атрибутов минимально. Это один атрибут, максимально
теоретически неограниченный, под множество атрибутов конкретного отношения, которые
характеризуются уникальностью и неизбыточностью. У нас определение не говорит о том, что мы можем
добавить в него другие атрибуты, не входящие в потенциальный ключ.
Вопрос, что такое допустимый набор картриджей. Смотрите, у нас закончилась мысль про
функциональную зависимость и нормальную форму. Потенциальный ключ у нас говорит просто о том,
что сами столбцы наши должны минимально один столбец, максимально два-три столбца,
вот каждый либо один элемент отдельно в одном столбце, если мы его берем за ключ,
первичный рассматриваем в качестве кандидатуры первичного ключа, либо картридж из двух атрибутов,
из трех атрибутов, для двух-трех атрибутов рассматриваемых на роль первичного ключа,
они должны быть уникальны и мы не можем сократить наш трех элементный картридж до двух элементного
картриджа. И здесь нет никакой явной связи между выводимостью, а здесь у нас по сути дела речь
идет о том, что мы, если у нас есть x значение и y в двух атрибутах, не обязательно что у нас
y входит в потенциальный ключ, он вообще не должен даже входить, но вот x например входит или вообще
у нас даже может не быть никакого ключа, то есть это про функциональную зависимость как таковой,
и у нас может не быть первичного ключа, но у нас получается, что в одном картридже у нас,
если есть x, то есть y, в другом картридже, если у нас есть x, то есть y, в третьем картридже у нас
есть y, но нету x, получается, что по x у нас совпадает, по y у нас обратной зависимости нет,
то есть это нормально, а это никак не влечет какую-то уникальность, неуникальность с точки
зрения определения потенциального ключа, наверное как-то так. Давайте я подумаю,
как лучше, наверное, на это еще ответить, в принципе, это такой теоретический вопрос.
Ну хорошо, я постараюсь как-то более емко, чтобы это изложить в следующей лекции. В целом,
вопрос слевопытный, да, в области, правда, высокой теории, но тем не менее. Для любого
допустимого набора картриджей имеется в виду, что картридж соответствует условиям, налагаемым
на данное отношение с точки зрения ограничений, с точки зрения, то есть у нас не просто какие-то
атрибуты x и y абстрактно существующие, а в рамках какого-то отношения конкретно вам и у конкретного
отношения конкретные ограничения, поэтому допустимый набор картриджей. Так, хорошо,
давайте посмотрим на табличку, все-таки чтобы было это все на каком-то примере. Любое переменное
отношение, находящееся в первой нормальной форме, но не находящееся во второй нормальной
форме, может быть приведено к набору переменных отношений, находящихся во второй нормальной форме,
а вот такое важное свойство, то есть мы всегда первой формы можем, ну,
окей, там если у нас два атрибута, да, можем там, конечно, по ним разделить, провести искусственное
разделение, сделать срогатные ключи и как-то функциональные зависимости наводить, но, да, там,
понимать вот это условие нужно тоже так немножко широко, что любое переменное отношение как бы
теоретически может быть приведено к набору переменных отношений, находящихся во второй форме,
но это не всегда реально необходимо, что называется, а в результате этой композиции получим набор
проекции исходной переменной отношения, причем обратимый, но это в общем-то по определению
правильной декомпозиции, декомпозиции без потерью. Так, а вторая нормальная форма,
что у нас здесь есть? Вот название, да, табличка с данными по произведениям и альбомам группы
Scorpions. Вот она так выглядит. Ну, что-то здесь, наверное, не так, что-то здесь кажется избыточным,
что-то здесь, да, вот Scorpions Worldwide, Worldwide Life, да, три раза повторяется. Здесь какие-то
повторения, какие-то перекрещивающиеся данные, как будто немножко похожие на нашу табличку с
поставщиками и с адресами, и с их адресами, и с продуктами. А данная таблица находится в первой
нормальной форме. Опять же, да, мы уже, как с вами, просуждали, что строка это нормально,
нормальное табарное значение, но не во второй нормальной форме, так как автор слов и композитор
зависит только от полей названия группы и названия песни. То есть, что это значит? Что у нас, так,
что у нас от того, что песня включена на другой CD-диск, значение этих полей никак не изменяется.
Как мы это видим, да, мы смотрим, ну вот буквально на примере, название группы, название песни совпадают
Scorpions Blackout, Scorpions Blackout, и у нас одинаковые значения по Y. Рудольф Шенкер, Клаус Майне.
А здесь у нас различаются значения, и если мы возьмем вот этот вот картеж целиком из трех
атрибутов состоящий, то, ну, очевидно, да, очевидно, ну, исходя из вот перечисленных всех определений,
что вот это вот у нас нефункциональная зависимость. По сути, здесь у нас X1, это Y, и X2 тоже Y. А у нас
должны совпадать, X1, при этом, должны совпадать с X2 для конституирования функциональной зависимости,
а X1 с X2 не совпадает. Какие здесь еще можно функциональные зависимости попроводить, опять же, да,
например, так, Worldwide Life, Рудольф Шенкер или Scorpions Worldwide Life, Рудольф Шенкер, Клаус Майне.
Тоже функциональная зависимость. Совпадают по X, совпадают по Y. Так, Blackout и Рудольф Шенкер.
Причем здесь у нас не может быть составного первичного ключа, поназвающего D-диск и название песни,
потому что они характеризуются здесь свойством сократимости. У нас, ну, мы можем без потерь выкинуть
название либо одного, либо другого, потому что они идентичны. Что нам нужно в общем сделать для того,
чтобы привести вот это вот отношение, находящееся в первой нормальной форме, в отношение, находящееся во
второй нормальной форме. А, собственно говоря, вот что. Давайте еще раз. Мы здесь название группы,
название D-диска, название песни вынесли отдельно. У нас получается, что при этом название группы и
название песни мы оставили в изначальной таблице. И мы здесь можем посмотреть на
функциональной зависимости. Да вот, ну, здесь, конечно, еще можно нормализовывать еще больше.
Это не предел. Мы здесь взяли только один из возможных вариантов того, что мы здесь видим.
Можем теперь разделить нижнее отношение тоже. Можем верхнее поразделять, поиграться. Но самое
главное, мы вот выявленную проблему, когда у нас Scorpions World White Life Blackout, Scorpions Blackout
не давали функциональную зависимость по автору слов и композитору. То есть вот это вот у нас Y,
это у нас X, это у нас Y. Мы ее разбили. Теперь у нас название слов, название песни, автор слов,
автор-композитора. И всегда функционально зависит вот это вот автор слов, композитора,
название слов, название песни. Ну и, соответственно, здесь тоже это как бы наглядно подчеркивается
тем, что выделяются, собственно говоря, заголовки отношения.
