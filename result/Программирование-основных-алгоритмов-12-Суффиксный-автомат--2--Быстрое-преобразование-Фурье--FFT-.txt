Окей, так у нас, по идее, лекция 12. И мы с вами почти закончили в прошлый раз про суфиксный
астомат, но вы что-то все умерли, вот, поэтому давайте начнем чуть ли не заново, а именно напомним,
что было на последней лекции, на прошлой лекции, чего мы сами добились. Первое, мы сами добились,
что мы будем строить автомат итеративно, то есть, написывая по одной буковке, ну или
инкрементально, как угодно это называете. Второе, мы добились, что при дописывании
одной буквы появляются два новых лонгест. Ну, точнее, один всегда появляется, второй там, как повезет.
Не появится повезет, значит. Примерно такая логика. При дописывании S в SC появляются следующие
классы. Ну, классы, или мы с вами показали, что у нас SBC из классов лонгест, и поэтому,
я буду просто говорить, следующий лонгест. И первое, это соответствующий SC, но он всегда
появляется в силу критерия лонгеста, потому что это префикс. И второе, мы с вами показывали,
что если он появляется, так сказать, тут со знаком вопросик, потому что может не появиться.
T это наибольший суффикс SC, такой, что он является под строкой S.
Вот это у нас было, и еще у нас было следствие из критерия лонгест, что, давайте замечание
это оформим, что был лонгест, следует, что он всегда лонгест. Опять же, следствие из критерия
лонгеста, напомню формулировку, то, что строка является лонгест в своем классе, если она или
префикс, или у нее есть два символа, если есть два символа, альфа и бета, такие, что альфа плюс
лонгест и бета плюс лонгест, это под строки. То есть, мы можем ее два раза продлить влево,
двумя разными способами. Вот. Соответственно, что мы с вами дальше делали? Дальше мы разбирали
с вами алгоритм, точнее, мы там почти час вот это все доказывали, выводили всю теорию. Теперь
нужно сам алгоритм разобрать. По-хорошему, мы разобрали где-то 70 процентов в прошлый раз.
Вот я вчера вел пару, понял, что никто не разобрался, возможно, потому что никто не
смотрел лекцию, но это не точно. Вот. Алгоритм построения и стадия первая, то есть, вот у нас наш
класс С и вот его суффиксный путь. И допустим, что это корень автомата. Вот, что тогда можно сказать.
Я могу сказать следующее, что и вот наш класс С. У нас было с вами утверждение про то, как устроены
ребра, ведущие в одну вершину. Первое, они все ведут по одной букве, второе, они являются суффиксом
путем друг друга. Поэтому здесь мы пишем букву С, но это просто потому, что мы хотим из С получить СС,
это вроде очевидно. Мы сейчас должны несколько подряд выписать по букве С. Почему? Потому что
все суффиксы СС выглядят, по сути, как некоторые суффиксы С, которым приписали букву С. С звучит
максимально логично. Так. Рисунок или надпись? Куда рисунок-то крупнее? Он уже почти на всю доску.
Ну надпись я буду крупнее делать, окей. Так, то есть первая стадия это провести ребра в СС.
А как она выглядит псевдокодом? While tu от P по букве С существует,
давайте напишем это так. Не ведет в какую-то несуществующую ноду, что-нибудь еще. На коде
как угодно выражайте. То есть пока этот переход существует, то есть мы можем из вершины П перейти
по С. Ну берем и говорим, что, наоборот, не существует, конечно же. Пока он не существует,
и этот маркер плох. Так, пока он не существует, мы должны говорить, что tu из вершины П по
букве С равно СС, П равно линк от П. То есть вот мы с вами идем в какой-то момент времени. Мы вот идем,
прыгаем по ним и проводим в СС. И первый случай, собственно, это самый классный случай, который
почти никогда не реализуется, к сожалению, потому что все хорошее в этой жизни дорого и стоит редко,
а это случай, когда П это корень. То есть мы смогли дойти до корня и мы провели из всех вершин по
букве С сюда в СС. Когда это может быть? Это может быть тогда и только тогда, когда у вас буква С вообще
не встречалась раньше в строке С. Согласитесь, это бывает достаточно редко, не больше, чем модуль Сигма раз.
Вот поэтому, типа говорим, все, ретерн напишем. То есть это случай один, и почему всем маркерам так
плохо? Просто ретерн, закончили. Это просто процедура добавления буквы, она вряд ли должна что-то возвращать.
Безумно логично, она просто меняет текущий состояние автомата. Окей, теперь,
допустим, что П не корень. Что это значит? Это значит, что из П есть переход по С. То есть мы
где-то вот пропрыгали, и у нас вот закончилась где-то здесь эпопея П. Из нее есть переход по С,
состояние Q. Скажу сразу, что П может быть корнем. Это не проблема. Так просто, на всякий случай.
Так, здесь мы говорили следующее, что у нас, то есть смотрите, по сути мы провели серебра в СС и
описали класс СС. Вот, а дальше у нас есть какие-то новые суффиксы, и здесь надо понять, что с ними
надо делать. И по-хорошему, здесь не очень много ситуаций, именно в случае вообще два. Именно надо
понять, расщепляет ли вот этот переход, будет ли здесь расщепление Q, грубо говоря. Почему? Потому
что, так давайте здесь нарисуем, вот ваш класс Q, а теперь взяли и провелись переход П по С. И что
это может быть? Может быть у нас сейчас будет сформирован новый лонгест, как раз-таки который
наибольший суффикс СС такой, что он является под строкой С. То есть у нас вот, допустим, вот эта
строчечка могла быть под строкой С. Вот, собственно, она лежит в Q по этому, потому что Q мы заново не
создавали. Это все вот было в строке С, вот это вот лежит в строке С. И здесь вот может возникнуть
такая ситуация, что вот это вот новый лонгест. Когда эта ситуация возникает? Когда у вас вот
взяли вашу строку С, приписали к ней букву С, и появилось новое вхождение Т, которое предваряется
буквой гамма. Тогда как все вхождения Т раньше предварялись какой-нибудь буквой альфа. Тогда вот у вас
новый лонгест по критерии лонгеста, как раз-таки. И вот он может возникнуть посредине класса. И здесь,
как раз-таки, две ситуации. Первая ситуация, вот это вот ребро из П по Q приводит вот сюда,
вот то есть старый лонгест, то что было лонгестом. А вторая ситуация, она приводит куда-то в
середину класса. И тогда нам придется его расщеплять. Как это проверять? Заметим, что Т в нашем
случае это лонгест от П плюс С. То есть вот взяли лонгест из П класса и провели его сюда в переход.
И теперь, если он пришел сюда, это значит, что нам еще делать не нужно. Новый лонгест не
появится, потому что то, что было лонгестом, и останется. То есть, если у вас верно вот такого
вот соотношения, здесь нужно сделать лишь одну операцию. Какую? По сути, нужно взять и сказать,
окей, вот твоя новая суффиксная ссылка, чувак. А, ну еще здесь надо, конечно,
что суффиксная ссылка типа в корень приходит по-хорошему указать. Давайте здесь.
Здесь линк от СС это корень, здесь линк СС это Q и return. И самое интеллектуальное,
это когда появляется новый лонгест. Это значит, что вы должны разбить, то есть это, так сказать,
наш случай 2. Вот это вот случай 2, когда все хорошо. Случай 1. Ну или случай 2.1 в нашей
нотации с прошлой лекции, насколько я помню. Есть случай 2.2. Это когда надо расщеплять. То есть,
у вас происходит разбирание класса Q на 2. Вот так вот. И теперь мы говорим, что вот это вот старый
Q, а вот это мы должны в новый класс выделить, потому что новый лонгест у нас биекция между
лонгестами и классами. Мы возьмем его клон. Почему клон? Сейчас будет пояснение. А именно,
давайте поймем, чем отличаются правые контексты Q и клона. Я отвержаю, что следующее. Верно,
что R от СС от клона это RСС от Q в объединении с Эпсилон. Ну почему это так? Раз-то клон,
точнее не так, раз-то новый лонгест, и он появился именно при создании класса СС,
значит, это штука суффикс СС. Раз-то суффикс СС, значит, у него Эпсилон входит в правый контекст.
С другой стороны, это изначально был один и тот же класс, поэтому все, что было правым контекстом,
ему останется. Поэтому мы должны объединить с этим. И теперь нужно понять, почему это дизюнтное
объединение, то есть почему в Q не было Эпсилона. Ну если в Q был Эпсилон, значит Q было суффиксом,
да, логично, то есть Q было суффиксом S. Ну тогда мы бы не могли бы просто припрыгать в Q по суффиксам
ссылкам. Точнее не так, если бы Q было бы суффиксом S, то мы бы припрыгали в него по суффиксам ссылкам.
Но Q у нас получается как переход из суффиксного пути по букве, то есть он никак не лежит на пути
суффиксных ссылок. Конец. Поэтому дизюнтное объединение. Из этого следует что? Из этого следует,
в частности, что раз правые контексты одинаковы, то ту от клона это ту от Q. То есть мы должны
клонировать все ребра, исходящие из Q, клонировать в исходящие из клона. Это средняя по сложности часть.
Теперь часть чуть попроще. Это про суффиксные ссылки. Как они здесь будут устроены? То есть
давайте я здесь нарисую. Так, теперь здесь поправим картинку и нарисуем продолжение суффиксного пути.
Вот. То есть смотрите, изначально была какая ситуация? Что все вели по букве C здесь в Q. Ну и здесь
вот дальше была вот такая вот суффиксная ссылка. Теперь я сюда буду умещать копию этой картинки.
Так, теперь смотрите, что у нас происходит. Мы сказали, что у нас расщепление на два происходит.
На Q и на клона. Теперь давайте выпишем суффиксные ссылки сначала. То есть вот здесь вот мы определили,
что здесь вот переходы из клона такие же, как из Q куда-то там ведут. Тогда очевидно, что...
Что очевидно? Что-нибудь очевидно вообще? Что раз клон наибольший суффикс СС, который мы можем
прочитать, суффиксная ссылка СС это клон. Что еще нужно сказать? Да, Q у нас изначально указывал
суффиксная ссылка на W. Вот этот элемент. Раз клон это, по сути, в некотором плане замена Q,
то мы должны сказать, что линк от клона это W. И теперь так, как Q. Ну почему это так? Потому
что клон это по сути несколько меньших суффиксов от Q. А значит суффиксная ссылка клона то же самое,
что суффиксная ссылка Q. Потому что у вас вот эта вот W, на которую ссылался Q с суффиксной ссылкой,
указывал наибольший суффикс, который не лежит в Q. Теперь это наибольший суффикс, который не
лежит в клон. Значит, по определению, линк от клона это W, а линк от Q это клон.
Линк от Q это клон. Точно-точно, потому что у вас именно в клоне лежит Epsilon. Именно клон это
суффикс строки, нику. Потому что у вас именно эту строчку можно продолжить пустым словом,
а это суффиксом не является уже. Ну условно это те части, которые все время предварялись вот буквой
альфа. Вот это вот предваряется буквой гамма по этому рисунку. Так, возможно, понять не будет.
В некотором плане я могу вот здесь отсечь и сказать, что вот здесь вот стоит гамма с рисунка,
а здесь альфа везде. То есть вот это вот все изначальные подстроки. И раньше везде входила
альфа, и тут появилось вхождение с гаммой. Поэтому это новый лонгест, поэтому это новый суффикс,
и я должен сказать, что вот он, суффиксная ссылка S это клон. То есть смотрите, что еще важно заметить,
что раньше изначально, когда мы вот без этого случая, у нас по сути все суффиксные пути были
как какой-то бамбук. Теперь это дерево, то есть у нас появляется раздвоение. Вот. У этих суффиксных
ссылок будет, у дерева суффиксные ссылки есть интересное устройство. Они являются суффиксным
деревом для реверсной строки, но это так для тех, кто знает, что такое суффиксное дерево. Скорее всего
почти никто. Окей, последнее. Надо разобраться с тем, как устроены переходы из кув-клона. Что
для этого нужно сделать? Это P, это Q. Для этого по-хорошему мы должны взять и
пропрыгать по суффиксным ссылкам из P и перенаправить некоторые ребра, которые подсошли в кув-клона.
Вроде бы логично. При этом раз мы объявили, что T равновлоги стат-клона, что можно сказать на самом
деле? То мы должны перенаправить из P, из всего суффиксного пути до вот некоторые вершины,
которые ведет уже в W. Все ребра в клоуна на самом деле. Здесь будет вот такая вот конструкция.
Но опять же почему? Потому что у вас по сути логист от клоуна это получение логиста от P,
приписав букву C. Поэтому переход здесь вот такой вот в клоуна ведется, а не в Q. Вы мне скажете,
что Q стала недостижимой вершиной. Я скажу, что она достижима по другим буквам.
Поэтому мы здесь говорим while, tu от P по букве C это Q, мы говорим tu от P, C это клон,
и по по по мы говорим P равно link от P. Все это последний случай. Это вот все.
Случай 3. Все, алгоритм закончен. Мы молодцы, мы справились. Я справился, вы не знаете.
Надеюсь, что справились. Если нет, задавайте вопросы. Потому что по букве C, если она была
достижима только по букве C, значит у вас логист от Q это логист от P плюс 1 просто-напросто по
буквам. По соотношению букв должно быть. То есть у вас выполнится вот это вот равенство.
Оно может не выполнится только если Q достижима по другим буквам в большую сторону. То есть есть
путь длиннее, заканчивается на другую букву. Поэтому если у вас Q была достижима только по
букве C, значит выполнится всегда вот этот вот случай. И поэтому мы здесь не будем ребра удалять
в эту щавку. А в третьем случае мы их перекидываем. Так, теперь нужно про симптотику поговорить.
Теперь я без доказательства. Если длина строки больше либо равна 4, либо 3, я тут, к сожалению,
не помню точную оценку, либо 3, либо 4, то число ребер не превосходит у такой отмечены. Доказывать
не будем. Это сложно доказывается. Я даже нигде не видел нормального доказательства, вот так скажу.
Но скорее всего только в оригинальной статье содержится где-нибудь. Поэтому оставим это так.
И мы с вами доказывали так типа методом уркомаханий. На семинаре вы должны были
по индукции или конструктивно доказать, что если больше равна 2, то число вершин не превосходит
2 модуля с минус 1, причем это оценка точная строка, по которой вы строите автомат. То есть на ребрах
вас не смутило, да? На вершинах смутило, окей. Так, что это значит? Вот давайте из этого утверждения,
из этой теоремы, которую я не доказываю, какие выводы могу сделать. Первое, что вот этот вайл,
первый случай, он порождает только новые ребра. Значит суммарно его число итераций не больше,
чем число ребер. А число ребер линейно по линии строки. Значит эти вайлы исполняются линейно,
суммарно. Это первое. То есть случай 1 суммарно за линию работает. Все возможные ситуации
аналогичны реализации случая 2, потому что они ничего нового не приносят с собой в плане ребер.
Единственное, что приносит... окей, хорошо, что дальше можно сказать? Теперь разбираем
случай 3. Это все от единицы делается, это нам не важно вообще. Вот это вот. Это порождает
новые ребра, а новых ребер суммарно вообще линия. Поэтому это укладывается все еще в симптомику
нашу. Последний вот этот вайл. Потому что он не порождает новых ребер, но меняет только старые.
Это проблема. Почему? Потому что это единственная ситуация, когда мы не можем сказать, что укладывается
вот это вот неравенство 3r с минус 4. И теперь нужно как-то доказать, что суммарно вот этих вот вайлов
тоже линия. Доказывается на самом деле это очень просто. А именно давайте рассмотрим длину
суффиксного пути из вершины соответствующей длине всей строки. Смотрим, как она меняется.
Так, давайте здесь напишем, что в случае 1 и 2 очевидно завод модулес. Все в 3, кроме вайл тоже.
Разбираемся с вайлом. Так, рассмотрим длину суффиксного пути из СИСЦ. Что такое суффиксный
путь? Это цепочка суффиксных ссылок. То есть вот здесь на картинке у нас огромная цепь. Давайте
скажем, что этот блок имеет длину m, этот блок имеет длину k, этот блок имеет длину l. Посмотрим,
как он меняется. То есть давайте скажем, что, ну давайте я их вон на картинке, не буду вводить
текстом, потому что я хочу закончить здесь на этом куске доски. Для С это было m плюс k плюс l.
ДСЦ. Давайте смотреть, как меняются блоки. Так, окей, что происходит?
Линка ТСЦ это клон. Поэтому, то есть по сути, у нас вот эта вот длина, вот этот кусок совпадает
с этим куском. Окей? То есть вот это вот m. Будто бы. Ну да, потому что здесь m. Нет, почему m?
Подождите. Не-не-не, вру. Вот давайте на этой картинке будем смотреть. Здесь вроде понятнее. То есть у нас было m, оно все было в q, и оно
схлопнулось все в 1. Но это не очень важно, что оно схлопнулось в 1. Нам важно вот этот кусок. То есть нам
важно вот этот кусочек, насколько он изменился. Так он тоже стал равен 1, да? Будто бы. Теперь тоже l осталось.
А, ну вот, то есть я схлопнул весь этот кусок в 1.
Вот у меня сейчас. Я хочу найти место, где у меня уменьшается длина суффиксного пути. То есть вот
здесь вот, видите, у меня здесь очень много этих вот прыжочков. А вот здесь вот, когда я перешел в новое
состояние, у меня все эти переходы вели из клона, теперь ведут в w. То есть у меня, если здесь был суффиксный
путь от p до вот этой вот вершины длины k, то теперь путь из ту от p по букве c, из этой вершины по
букве c, имеет длину 1 теперь. Так, давайте я введу вну, введу букву p штрих. Я смотрю длину суффиксного пути
между p и p штрих от первого состояния. На втором состоянии я рассмотрю, сейчас смотрю, от p до p штрих
и от ту от p по букве c до, это не g, от p штрих по букве c. Рассматриваю длину суффиксного пути.
То есть здесь, если у меня длина суффиксного пути это k, вот k прыжков здесь было, то ту от p по букве c это
клон, а ту от p штрих по букве c это w. И здесь длина суффиксного пути 1. То есть я схлопну вот этот кусок в единицу.
Нет, вот этот кусок у вас 1, 2, 3, k. 1. Нет, я рассматриваю новый суффиксный путь от fc.
Еще раз, я рассматриваю суффиксный путь от вершины s сначала и теперь рассматриваю суффиксный путь от вершины sc.
Я утверждаю, что вот этот кусок, сколько реберя перенаправил сюда, вот настолько уменьшилась длина суффиксного пути.
Ну понятно, да, почему? Потому что у вас длина от sc, это вот все, что у вас было вот здесь вот, оно превратилось в кусочки длины 1.
Расстояние от sc до w у нас, по-моему, сократилось.
Расстояние от sc до w, да, но расстояние от s до p штрих, оно было больше?
Нет. Расстояние от s до p штрих, вот оно.
И оно было точно таким же?
Еще раз, я смотрю. Окей, вот у меня в первом состоянии было только s. Я рассматриваю длину суффиксного пути.
Теперь стало sc. Мне пофиг, что здесь происходит. Я смотрю, вот этот вот путь.
Да. Потому что потом я буду к sc приписывать букву. И мне вот этот суффиксный путь вообще не нужен будет для анализа.
Для анализа мне важен суффиксный путь последней самой длинной штуки. Именно поэтому я их сравниваю.
Вот эти вот? Да, но это мне очень важно. Нам важен этот кусок, потому что я утверждаю, что то, сколько мы ребер перенаправили, настолько мы уменьшили длину суффиксного пути.
Поэтому мы уменьшим суммарное число прыжков в следующей итерации. Именно настолько.
Кого? Вот здесь вот? Еще раз.
Коперфильд момент. Я рассматриваю вот этот суффиксный путь и, внимание, сидите за руками, вот этот вот суффиксный путь.
И вот этот кусочек, который был вот этот вот, он внезапно превратился в одно ребро.
Вот это вот, что здесь оказалось, мне вообще не важно. Почему? Потому что когда я буду писать новую букву в конец, я буду рассматривать вот этот вот суффиксный путь.
Я же к СС приписываю в конец букву.
Мы рассматриваем суффиксный путь от всего слова. Да, именно так.
И вот этот вот суффиксный путь у нас будет постоянно уменьшаться.
И он уменьшаться будет как минимум на очло итерации вот того самого циклова. То есть как минимум на единичку он уменьшается при клоне.
Да, короче, как минимум на один он уменьшается.
И при этом он увеличивается не больше, чем на один, когда он увеличивается.
Когда у вас первый или второй случай.
Давайте даже затру эти оценки, это что-то умное.
Давайте просто скажем, что он уменьшается.
Да.
Нам даже не это будет важно.
Нам будет важно, что он уменьшается хотя бы на один.
И каждый раз приписывая новую букву он увеличится не больше, чем на один.
Ну да, да. Ну окей, да, это будет важно.
Хорошо. При клонировании...
...суффиксный путь уменьшается ровно на число итераций цикла while в случае 3.
И увеличивается не более, чем на один.
Откуда следует, что суммарная линия всего итерации while?
Ну почему? Потому что раз у вас увеличивается не более, чем на один,
значит он у вас дорос до какого-то значения, вы его уменьшили, он снова дорос, вы снова уменьшили.
То есть как бы раз у вас увеличивается не более, чем на один, то суммарное уменьшение может быть не более, чем длина строки.
Поэтому суммарное число while не более, чем 2 на длину строки.
То есть линия время. Можно так рассуждать.
Меньше, чем 2 на длину строки.
Все, доказали суммарные линии на время работы.
В частности, из этого следует, что дописывание одной буквы работает в амортизированную единицу.
И на этом мы заканчиваем с автоматом и переходим, казалось бы, к вообще неожиданному, а именно к преобразованию фурья.
Что такое быстрое преобразование фурья?
Это быстрый способ вычислить дискретное преобразование фурья.
Давайте я скажу страшное определение преобразования фурья в мотоне.
Короче, если f очень хорошее, f хорошее, да.
Это не нужно будет нигде знать, это просто к тому, чтобы вы понимали, откуда эта интуиция берется.
Но это слишком хорошее, можно похуже.
То преобразование фурья от функции f, то есть f большое, это некоторый оператор, который берет в себя функцию и возвращает функцию.
Добавляем 1, достаточно сказать.
f от, так сейчас, f от x, вводы x.
Вот такая формула страшная.
Насладились?
Это множество действительных чисел.
Ну, от минус бесконечности до бесконечности интегрировал.
Интеграл в смысле лебего.
Короче, давайте вы будете считать, что вот это очень страшная запись.
Второй курс понимают, первый курс не понимают и верят, что это интеграл Риммана.
Там есть тонкие грани, о которые мы опустим, потому что я уже не вспомню настолько тонких вещей.
Лебегу супер интегрировать всегда.
Но если вы так говорите, у вас смотан плохой.
Вот, соответственно, что дальше можно сказать?
Давайте превратим это в дискретный случай.
Что дальше в дискретный случай?
Пусть f задана спектром значений.
Или мы знаем ее значение в n точках.
Ну, в качестве примера можно взять, что, по сути, мелодия это некоторая сумма гармонических сигналов.
И они непрерывны. Вау.
Вот, соответственно, как вы передаете музыку по телефону?
Она не передается как непрерывная функция, она передается как какой-то дискретный спектр.
И, соответственно, качество или битрейт?
Это вот сколько у вас точек берется, чтобы получить как можно точнее зависимость.
Ну, n точек.
Тогда мы можем определить переобразование феерии дискретное.
Равно...
О, сейчас.
Интеграл превращается внезапно в красивую штучку.
Минус и х жито у.
И это получится с какое-то одно значение.
Что какая-то лажа, чего не должно быть.
А, ну почему у нас... Нет, и это комплексная единица.
От у.
А, ну да, вы можете разные у перекидывать и все.
Все нормально. Построили дискретное преобразование.
Собственно, преобразование фурье, это вот это дискретное преобразование фурье, знакомьтесь.
Оно удобно тем, что у него есть обратное преобразование,
и тем, что оно получается из значения вот этой штуки в у соответствующих.
Вы можете вернуть фиксы просто минус и заменив на и.
Нет, это вам на аутоне должны были доказать.
Так вам это даже знать не надо. Я это так рассказываю.
Так, теперь...
Теперь я возьму следующее, что на самом-то деле, по-хорошему, вообще зачем нам все это надо?
Я хочу передать какую-то непрерывную функцию f, да, по каналу связи.
Но в общем-то я не могу передать какую-то непрерывную функцию f в силу определенных ограничений.
Например, потому что внезапно непрерывную функцию f передать очень сложно.
Потому что у вас сигнал дискретный обычно.
Поэтому есть такая теория о маряде фурье,
что все еще, если функция достаточно хорошая, в частности 2p периодическое.
Ну, вы можете сделать 2p периодическое,
потому что у вас сигнал ограничен по времени,
сожмите его до 2p линейным отображением и дополните до периодичной.
Поэтому любую функцию определенной отрезки можно дополнить до 2p периодичной.
ЦК и КХ.
По-моему, так вот.
Это ряд фурье.
К – это, соответственно, номер.
Он от минуса бесконечности до бесконечности суммируется.
То есть можно сказать, что это просто два ряда.
В одном до плюс бесконечности от 0 до 0 другом.
От минус одного до минус бесконечности.
Вот как-то стоит понимать с точки зрения Маттона.
Конечно.
Ну, окей, если вы не согласны с этим.
До бесконечности ЦК и КХ.
Плюс сумма по К от единички до бесконечности.
Ц-катых е в степени минус и КХ.
Вот как-то стоит понимать с точки зрения Маттона.
Если вам не нравится запись таким.
Все равно на третьем курсе вы будете только так писать.
Там комплексных переменных это будет.
Вот, окей.
Что теперь нужно сказать?
Нужно сказать, что чем больше вот этих вот ц-катых...
А, можно сказать следующее.
Что раз вы можете функцию F разложить в ряд фурье,
то что значит?
Это значит, что вы можете просто передать,
будто бы ц-каты по каналу связи,
и человек сможет установить F.
Логично.
И чем больше вы этих ц-катых передадите,
тем больше точность будет вашего передаванного сигнала.
Собственно, чем больше вы ц-катых передадите, тем лучше.
И внезапно всякий формат качества музыки зависит в том числе от этого.
Вот.
Ну, видео туда же, картинки туда же, все туда же.
Все вот эти вот сигналы продолжительные, это все вот сюда.
Вот.
Окей.
А что мы теперь хотим?
По-хорошему,
что здесь нужно сказать?
Наверное, все, что нужно сказать на самом деле.
А, ну, можно сказать, как ц-каты искать, например.
Ц-каты искать неприятно, сразу вам скажу.
Ц-каты в некотором плане выражаются вот так вот.
С точностью числового коэффициента.
Вот.
Выражается вот так вот.
С точностью числового коэффициента сразу скажу,
потому что я не очень вспомню сейчас.
Это преображение Fourier функции в точке k.
Возможно, там нужно где-то в преображении Fourier численный коэффициент поставить
и по 1 делить на корень из 2p, но я не вспомню сейчас, к сожалению.
Что?
Зависит от того, как вы нормируете преображение Fourier, скажем так.
Здесь я уже с точностью к коэффициенту не вспомню.
И это не очень важно.
Нам важнее другое.
То есть, по сути дела, если мы можем быстро вычислять ц-каты,
значит, мы умеем быстро вычислять f.
И наоборот.
Если мы быстро вычисляем f, мы умеем быстро вычислять ц-каты.
Но операция интегрирования, причем с комплексным экспонентом,
выглядит не очень интересной.
Поэтому человечество придумало чуть более интересное,
поэтому человечество придумало чуть более интеллектуальную схему.
Давайте сделаем следующее.
Если у нас есть непрерывный сигнал f, давайте приблизим его многочленам.
Это же мы можем делать?
Функция f, если она достаточно нормальная, то ее можно приблизить рядом Тейлора.
Это уже первокурсники тоже должны знать.
Вот, молодцы.
Раз вы знаете ряд Тейлора, значит, функция f там многочлен.
Окей.
Многочленам все еще легко передать.
Попробуйте передать коэффициента теперь.
Вот.
Но прикол в том, что сигналы интересны тем, что вы хотите не только получать, как многочлен,
а раз у вас периодичность какая-то, у вас будет гармонический сигнал, сумма синусоид и косинусоид.
Раз вы хотите сумму синусоид и косинусоид, вам нужно что-то интеллектуальнее придумывать,
чем просто многочлен, а именно тригонометрический многочлен.
То есть вот эта вот штука тригонометрический многочлен.
Поэтому давайте не будем тратить время на Тейлора, на самом деле, и точности.
А скажем, что раз это тригонометрический многочлен, то мы можем считать его значение в интересных точках.
И явно их передавать просто-напросто, чтобы можно было обратно его ставить.
Вот.
И теперь мы приходим к тому, что, собственно, наша задача какая?
Мы должны по функции f найти какой-то набор чиселок, значений в каких-то точках интересных.
Передать их, и человек должен с момента их восстановить.
Поэтому быстрое преобразование фурьер, в нашем случае конкретно, оно будет что делать?
Оно будет вычислять интересную штуку.
А именно, то есть быстрое преобразование фурьер, или по-английски fast, фурьер transform.
FFT.
Оно будет брать...
Вообще изначально берет функцию f какую-то, и вычисляет это значение в комплексных корнях из единицы.
Страшно, очень страшно, я учусь и прощу жизнь.
По многочлену P, такому что степень P не превосходит k, ну, минус 1, вычисляет вектор следующего вида.
P от Омега в нулевой, P от Омега в первой, P от Омега к минус первой.
Где Омега?
2еп деленное на k.
Почему это так? Почему такое именно число подбирается?
Ну, потому что Омега вжитый, давайте посмотрим, что это такое.
Ну да, берется обычно примитивный корень, и примитивный, наверное, так выражается.
Чем эта штука классная? Тем, что у нее корни зацикливаются.
Ну, окей, первого курса звыл комплексное число?
Отлично, значит напоминаем второму курсу.
Вот наша комплексная окружность.
Окружность радиуса r, угол phi, тогда z можно так расписать, через формулу Эйлера.
Окей, теперь мы заметим, что у нас Омега здесь радиуса нет, поэтому мы будем считать, что окружность единичная.
Так, дальше что? Что?
Ну да, потому что я сказал, что у нас здесь нет r, поэтому она единичная. Вот, радиус один.
Так, что еще теперь нужно сказать?
А, ну окей, теперь посмотрим, какие выглядят правильные корни катой степени из единицы.
Внезапно единичка входит в это множество, и дальше вы разбиваете свою окружность.
Надеюсь, что у меня получится подгадать.
Будем считать, что да, направленный коугольник.
То есть phi равно 2 pi деленное на k.
То есть вот у вас ваша комплексная корня из единицы расположена на окружности.
Но они и зацикливаются, очевидно.
Собственно, свойства зацикливания нам и будет важно.
Поэтому на самом деле можно брать любую алгебрическую структуру, у которой можно зациклить корень.
В частности, можно взять Zm и первообразный корень по модулем, если он существует.
Так.
Это будет в ходе алгоритма, понятно.
Мы потом придем к месту, где нам это понадобится.
Да.
Сейчас вы должны понять, что FFT берет многочлен, а возвращает вам вектор значений.
Все.
Это все, что надо знать пока что.
Что?
Нет, P это просто многочлен, самый обычный.
Там 2, плюс 3x, плюс 5x квадрат, например.
Что? Нет.
Вы берете многочлен, считаете его значение в омеге, в первой, омега во второй и так далее.
Ну не знаю, так это a0, x0.
То есть вот такой вот набор.
Массив a.
Массив a, да.
То есть по сути, да, на самом деле это крайне важный вопрос, почему.
Потому что, грубо говоря, многочлен это кортеж.
Вау, да. Если что, многочлен формально является как кортеж.
Не как вот сумма мономов.
То есть по сути, в некотором плане вектор.
То есть у вас многочлен это вектор длины k.
И преобразование фурье выплевывает вам вектор длины k.
Как вы думаете, преобразование фурье линейно?
Да, оно линейно.
Поэтому вы можете знать матрицей.
На самом-то деле.
Ну и по сути, преобразование, то есть по сути, преобразование фурье это линейное преобразование на rk.
Ну, на ck точнее, что комплексно можете возвращать.
И в некотором плане можно заявить, что у вас работают там всякие теоремы о собственных значениях, собственных векторах преобразования фурье.
Можно их себе посчитать.
Разложите его в диагональный вид.
Он даже существует там нормальный.
Блочный диагональный, по-моему, там точно существует.
И все вообще красиво.
То есть там вся очень красивая линейная алгебра с этим всем связана.
Но мы это пока что опустим.
И все-таки пора переходить к алгоритму наконец.
Потому что сейчас совсем все плохо.
Но в каждом нужно просто научиться преобразовать многочлены.
Это наша главная цель.
По сути дела, я могу заявить, что преобразование фурье многочлены.
То есть в некотором плане я могу заявить, что у меня было дискретное преобразование фурье.
Игрики могу разные подсовывать.
Ну, давайте я буду читать лев в многочленам.
Тогда преобразование фурье многочлены.
Буду подсовывать в ней разные омеги.
Ну и здесь вот заменю на что-то другое, другую ортогональную систему функций.
Это тоже пентизм, а то на четвертого семестра, первый курс неважно.
Сейчас мы рассуждаем о том, как вот это вот сделать быстро.
Давайте заметим, что запишем просто-напросто связь между векторами a0, a1 и так далее, ak-1 и вот этими вот.
Выписываем p от ω0, это a0, ω в нулевой плюс a1, ω в первой, ой, это ω в нулевой вот так вот, ω в нулевой в первой,
а во второй, ω в нулевой во второй, плюс ak-1, давайте n-1 я буду дальше писать, ω в нулевой, в степени n-1.
Согласны? Ну это вроде просто я поставил вместо xa, ω в нулевой.
Ну да.
Ну понятно, что p от ω в первой я буду везде заменять на ω в первой, по скобкам.
То есть я могу расписать, что p от ω в житой равно a0, ω в житой на 0, с a1, ω в житой на 1, a n, ой, n-1 конечно здесь везде, ω в степени g-1, n-1, согласны?
Тогда давайте я запишу матрицу w, ω в степени i g, где i g в таких пределах ходят. То есть это просто матрица вот этих вот ω.
Тогда что я могу сказать? Я могу расписать вот такую вот матричную постановку задачи.
w от ω в степени n-1, это w умножить на вектор a0, a1, a n-1.
Внимание, это знание нам сейчас не нужно. Мы идем дальше.
То есть я хочу вычислить значение многощина p в степени n-1 в n точках. Вот моя цель. Я могу это сделать за квадрат, просто перемножив патрицу на вектор. Я считаю, что это долго. Нифига, конечно. Долго.
Я хочу быстрее, хочу ZEN-логенто сделать. Для этого я рассмотрю следующий, так сказать, схему кули-чьюки она называется. Ну по фамилиям авторов внезапно.
Нет.
Кули. На букву K.
Чьюки.
На финском, вот куда авторы.
Введу p четное от x, a0, plus a2x, plus a4x2 и так далее. Введу p нечетное от x, это a1, a3x.
Зачем? Теперь внимание, то, что они придумали.
Знаете, почему это сильно? Это сильно, потому что теперь зачем нам нужно было зацыхливание корней?
Потому что если вычисляю эту штуку в корнях омега в нулевой, омега в первой и так далее, в степени n-1 пополам, я вычислю значение p в соответствующих степенях.
Потому что у меня здесь, если я буду вычислять в значениях омега в нулевой, омега в первой и так далее, омега в n-1 у меня зациклится.
И уникальных значений будет только n пополам. Именно поэтому мне нужно было зацикливание.
Поэтому здесь мне достаточно вычислить значение в n пополам точках. И здесь в n пополам точках. И за линию слить результаты.
Поэтому рекуррента тогда получается.
Можно?
То есть что у нас с вами происходит на самом деле?
На самом деле у нас происходит следующее.
То есть в коде это выглядит так. У меня есть массив.
Давайте сразу скажу, что n это степень двойки.
Точнее n коэффициент в этом степень двойки.
Если многочлен у нас не степень двойки, то полноте нулями старший коэффициент до степени двойки.
Все будет хорошо.
Окей, что теперь нужно сказать?
Всего хорошего, всем пока.
Но, к сожалению, нет.
Нет, надо сказать.
Надо сказать, что как это выглядит в коде.
В коде вы передаете ему fft, функции fft.
Вы передаете ему вектор коэффициентов.
Дальше передаете вот эту n.
И передаете комплексный корень.
Дальше вы собираете почетный по нечетный.
Вызываете два раза рекурсивное fft.
В каком плане два раза?
Вызываете его от четного от нечетного.
При этом передаете ему туда соответствующие вектора коэффициентов, четные и нечетные.
Дальше передаете ему вместо n, n пополам.
И последнее.
Вы должны передать туда какой комплексный корень.
Ну, какой комплексный корень?
Ломика квадрата надо передать.
Ну все.
Вот.
Окей.
Поэтому от работы с nLogan мы научились с вами прямое преобразование в Fourier делать.
Ну, в базе рекурсии вектор длины 1, верните a0.
Все, конец.
Окей.
То есть вот этот алгоритм, если что, он входит в топ-3 алгоритма 20 века по полезности.
Потому что он позволяет вам быстро преобразовывать сигнал сворачивать.
Ой, я не вспомню сейчас что.
Там что-то с почмотами связано, по-моему.
Там в целом куча алгоритмов, связанных с вычислениями и приближенными вычислениями.
И моделированием, точнее.
Вот. Окей.
Что теперь?
Теперь я хочу сказать следующее, что...
Какой план по перемножению многочленов у нас с вами?
То есть у нас a.
b.
c.
Здесь m-1, m-1.
k равно 2 в степени, округленный вверх,
двоичный алгоритм от m плюс n минус 2.
То есть это такая степень двойки, в которую заведомо влезет наш результат.
Потому что при перемножении многочленов максимум, что вы можете получить, это сумма крайних степеней.
То есть m плюс n минус 2.
Вот. Окей. Что дальше нужно сказать?
Шаг первый.
Вычисли...
ФФТС, b.
Шаг второй.
Внимание.
Вот я не рассказал вам, что это такое,
но я не знаю, как это сделать.
Но я не знаю, как это сделать.
Я не знаю, как это сделать.
Я не знаю, как это сделать.
Вот я не рассказывал про свертку, про свертку будет чуть-чуть дальше.
Однако есть интересное свойство, что преобразование фурье в свертке это произведение сверток.
Точнее...
Ну да, преобразование фурье в свертке это будет...
Господи...
Неважно, короче, что это будет.
А, преобразование фурье в свертке это произведение преобразования фурье.
В каком-то плане берется поточечное.
То есть вы знаете значение...
Вот это значение a в омегах.
Это значение b в омегах.
То вы берете и вычитаете a на b в омегах.
Поточечное.
То есть здесь вот имеется в виду, что a на b от омега в житой.
От омега в житой равно a от омега в житой.
На b от омега в житой.
Ну да, концепт.
Шаг третий, самый сложный.
Вычисли...
И получал b, соответственно.
Вот это мы с вами умеем делать за o от n log n.
Ну, в нашем случае k.
Это вообще за o от k.
Потому что это просто поточечное преимножение надо сделать.
Теперь как обратное считать.
Тут стрельнет великое ружье Бондарчука.
В виде вот этой постановки.
Что я сделал? Я преимножил матрицу на вектор за n log n.
Что я сделал? Я преимножил матрицу на вектор за n log n.
То есть что я сделал?
Я сделал произведение вот этой матрицы на этот вектор.
За n log n.
С помощью той схемы разделить власту.
Теперь я должен взять и домножить на w в минус 1 слева.
Обе части равенства.
Тогда я получу, наоборот, вектор коэффициентов по этой штуке.
То есть,
Заметьте, умножать на матрицу w на вектор,
причем матрица выливаема специфичная, в ней корни зацикливаются.
Именно поэтому и можно так быстро все сделать.
А не потому что это произвольная матрица.
В общем случае это неверно.
Что можно так быстро все посчитать.
Теперь я хочу найти обратную матрицу.
Матрица w.
Вот такая вот интересная.
Почти.
Там придется чуть-чуть поделить ее еще.
Да, теперь давайте я буду считать w на v и ты житый.
Что это такое?
Сумма по k в минус 1 и k ты житый.
Уберу, просто расписываю запление w.
И запление v, которое вон там вот.
Эта сумма по k от 0 в минус 1.
Омега в степени и к, а омега в степени минус к жи.
Дай минус 1.
Омега в степени к и минус жи.
Согласны?
Так, теперь давайте вахнем.
И равно жи.
Что случается, если и равно жи?
Равно n, если и равно жи.
То есть на диагонаре стоят одинаковые элементы.
Уже классно.
Уже близко к единичной.
И понятно, что надо будет делить.
Осталось показать, что в остальных местах ноль будет.
Ну, здесь давайте считать сумму геометрической прогрессии.
Чему она равна?
Ну ладно, понятно, почему она ноль суммируется.
Потому что это геометрическая сумма корней.
Давайте допишу.
И здесь я могу сказать по геометрическому свойству компонентов.
Ну, это уже ну, это уже ну, так что.
Здесь я могу сказать по геометрическому свойству комплексных корней, это ноль, но давайте выпишу все-таки формулу.
Что-то такое, по-моему, должно быть. То есть вы берете omega v на минус 1 и omega v на минус 1.
Кого? Конечно.
А что вам не нравится?
Почему я вот это вынес?
Так нет. А, или да.
Согласен.
Переиграли.
Давайте, ладно, давайте просто напишем полностью.
Нет. Да нет, ладно, я просто напишу полностью.
Справедливо, здесь вы доплавили меня.
Вот так вот.
Вот это, правда, похоже.
Ну, потому что это номинатель геометрической прогрессии, а это n степень его.
Ну, в любом случае, это равно 1.
Почему? Потому что это omega v, и минус g минус 1 делить на и минус g минус 1.
Вот эта часть не равна нулю, потому что эта часть не равна единице.
Вот эта часть равна единице.
Omega v равен единице.
Еще одно, зачем нам нужно было зацикливать корней?
Равну нулю.
Ну, откуда я получаю, что v, то есть что w в минус 1, это 1 деленное на nv.
Ну, тогда что я сделаю?
Давайте я домножу, сделаю то же самое преобразование в Fourier, абсолютно.
Только передам ему вместо omega привитивного корня, omega в минус 1.
Я получу умножение на v слева этого вектора тогда, потому что я все то же самое абсолютно делаю.
Единственное, что мне останется делать, это поделить на n конечный результат.
Конец. Это обратное преобразование в Fourier.
Поэтому на самом деле все очень просто.
В смысле, что значит округлить?
И что? Они комплексные.
Ну да.
Нет, зачем?
Да, проблема в преобразовании в Fourier в том, что он вычислительно неустойчивый.
Очень сильно.
Потому что у вас все-таки комплексные корни из единицы, они имеют вещественные коэффициенты.
И это очень грустно.
И здесь есть два решения.
Первое решение – это смириться и забить.
Второе решение – если вы имеете право работать в ZP, взять нужный вам ZP.
То есть P, который достаточно большой.
То есть больше, чем вот это вот k.
И что?
И по нему считать уже в нем преобразование в Fourier, зная первообразный корень.
Все выкладки абсолютно будут действовать.
Ну все, конец на этом, в общем-то.
Так, проблема в ZP в Fourier – то, что хотелось рассказать.
Давайте я расскажу быстренько про свертку последовательности тогда.
Потому что мы научились переносить многочисленную. Согласна?
Это с одной стороны – нет, почему-то столько же абсолютно.
Только там не будет даблов, комплексных чисел не будет, там все будет ZP.
Потому что остатки модуля придется брать, да, это правда.
Ну да, ну вы берите не сильно прям большую.
Между P и 2P всегда есть одно простое.
Постулат Бертрана, по-моему, это называется.
Ну в смысле нет, это потому, что между любым числом мы его удвоим, что-то простое.
Ну нет, вы знаете значение максималида, возьмите просто P большой и все.
Например, так.
Зафиксируйте P.
Зафиксируйте P, найдите на бумажке.
Можно так, да.
Так, ладно, все, это не интересно.
Кого вы хотите многочисленную перемножить?
Вы перемножили многочисленную, вы молодец.
Ну смотрите.
Теперь, не, касательно какие задачи могут быть еще решены этой штукой.
Ну, помимо того, чтобы считать сами преобразование Fourier для всяких передач и сигналов,
что еще можно сделать?
Ну, внезапно можно, но сейчас будет, собственно, задачу, которую мы будем разбирать.
Это раз, два, у вас на семерах будут несколько задач.
А теперь задача, я хочу посчитать свертку последовательностей.
То есть свертку двух дискретных сигналов.
Сейчас я напишу определение.
Куда вы торопитесь-то?
Вот, n больше, чем m.
Больше либо равно, точнее.
Тогда c равный a звездочка b,
c и ты, давайте так напишем.
a звездочка b это свертка.
И ты, член свертки, определяешь следующим образом.
a и ты с g, b с g.
А теперь задача 3.
a и ты с g, b с g.
Почему это свертка последовательностей?
Снова страшная для первого курса знакомая второму.
Свертка функций. Помним, как выглядит?
Сделайте замену i плюс g, и вы получите вот это.
Вот что значит, поэтому это свертка в дискретном случае.
Вот это? Это скалярное произведение векторов.
Вот не совсем.
Сейчас мы посмотрим, как это приводится к перемножению многощенов.
В частности, можно вычитать произведение сверток.
Свертка произведения, здесь это верно.
Так, теперь что мы хотим?
Хотим почитать ту штуку.
Давайте рассмотрим многощен a.
И многощен b.
Теперь я сделаю страшные. Я возьму их и перемножу. Прямо на доске.
Что?
Возьму и перемножу их на доске.
Так.
a на b
равно
Ну, a0b0 это понятно.
Плюс a1b0 плюс a0b1x.
То есть, перед x в соответствующей степени у меня будет всегда стоять сумма с соответствующими индексами.
То есть, x первой, значит, здесь будут все суммы, которые набирают единичку.
Ну, давайте рассмотрим.
Айминна.
Давайте посмотрим на сумму коэффициентов здесь.
Да.
Это правда.
Айминна.
Айминна.
Айминна.
Айминна.
Айминна.
Айминна.
Айминна.
Айминна.
Айминна.
Это правда.
Но если я заменю...
Ладно, окей, пока что оставим это так.
Но если бы...
Нет, я не буду спойлерить.
Я лучше распишу что-нибудь при, наверное...
Давайте распишем, что будет происходить при x в степени n-1.
Ой, при m-1, конечно же.
Извините.
Из m-1, m-2, m-3, a-m-1, b-0.
x в степени m-1.
Найдите актера в гриме.
Если актер непонятен, давайте еще следующего выпишу чувака.
Да.
Сейчас. Нет, здесь a-1.
Здесь a-2, здесь a-3.
Плюс a-m-1.
Сейчас. Нет.
Кого я обманываю? Себя.
B-0.
Нет, все-таки здесь a-m просто будет.
Ну плюс и так далее.
Это нам уже не очень важно.
То есть, смотрите.
Здесь постоянно сумма по индексам.
А здесь посмотрим, кто здесь постоянен.
И плюс g, минус g это что?
ВОО.
Давайте я заменю
и буду с вот таким вот сворачивать.
Неважно.
Ну окей, да.
Я к тому, что вот в таком случае сумма была бы постоянной.
Но я лох и довольствуюсь божитым.
Как превратить житы в m-1-житы?
Да.
Давайте возьмем и определим
ref от b.
bm-1 на x0.
Плюс bm-2x.
m-3x2.
Плюс b0.
x в m-1.
Тогда, если я перемножу a на ref от b,
я должен буду...
То есть, если я рассмотрю свертку a и ref от b,
я получу как раз-таки вот эти вот коэффициентики.
Да?
Что мне надо, значит, сделать?
Да, все, конец.
m-1...
Плюс b0-g.
Короче, прием минус 1, m, m плюс 1 и так далее,
пока там сумму будут удовлетворять.
Вот. Это свертка последовательностей, собственно.
То есть, что мы с вами сделали?
По сути, мы с вами научились искать вот такое скалярное произведение
длинной строчки
на маленькую строчку, которую мы прикладываем во всех позициях.
Ну и так далее.
И мы это умеем делать быстро.
То есть, в некотором плане мы сможем считать близость паттерна к строке
очень быстро, близость в плане скалярного произведения.
И теперь у нас остается минус 4 минуты времени,
к сожалению.
Поэтому я не успеваю рассказать то, зачем мы это проходили
с точки зрения строк.
С другой стороны, тогда у нас на следующей лекции это останется.
Там будет задача о K-опечатках.
С помощью свертки мы поймем, как искать вхождение с K-опечатками.
Там будет преобразование фурье K штук надо писать.
Вот это первое.
Второе, что еще будет?
Мы научимся делить многочлены друг на друга.
Не, столбик долгий, займем лукен.
Где-то степень старшего.
Вот план такой у нас на следующую лекцию тогда.
И там, видимо, еще многомерное преобразование фурье будет.
Нет.
Нет.
Там по методу Ньютона с преобразованием фурье внутри.
Нет.
Сейчас говорите по второму закону Ньютона.
