Всем доброго дня! Мы с вами заканчиваем наш курс и сегодня мы с вами поговорим
про такую интересную тему, на самом деле, которая по идее должна была быть где-то
в середине нашего курса, но мы ее по факту проскочили голопу по Европам, задронув в ней буквально
два-три блока, поэтому нужно все-таки эту тему закрыть более детально и нам необходимо
сегодня решить такую тему, как работать с объектно-ориентированными языками, потому что
мы так или иначе уже посмотрели с вами, как работать с функциональными языками, значит,
я сразу скажу, что если вы хотите понять, как работают функциональные языки, мы это детально
разбирали на одном из семинаров, Виталий нам детально рассказывал, Виталий Пребейник нам
детально рассказывал про то, как он пишет интерпретатор функционального языка и как нам все
преобразовывается. Наша цель сегодня будет еще и закрыть тему, связанную с объектно-ориентированным
программированием. Итак, цель наша сегодня будет заключиться в том, чтобы разобрать работу
компиляторов ООП языков и узнать, каким образом транслировать код для ООП языков таким образом,
чтобы он у нас с вами работал, то есть мы с вами сейчас пойдем еще в Godbolt и посмотрим примеры
того, как это работает все в Godbolt. Поехали, значит, давайте подумаем вообще, в чем особенность у
нас с объектно-ориентированных языков.
Да, какие именно ООП приколы?
Да, так давайте.
Так, собственно, у нас что есть?
И тот не ООП, в той части не ООП.
Так, первый это полимаркетинг, второй это последователь.
Ну, видите, именкапсуляция.
Ну, с точки зрения незнакомых, это значит, что у нас у объектов есть методы.
Да, значит, у нас появляется новая сущность, которая называется объектом, у объектов у нас есть методы,
у нас есть у объектов поля, и нам нужно явно образом понять, какие в них есть проблемы и где их можно
решать. Напоминаю, что скорее всего мы все это будем решать. Как вы думаете, на какой этап?
Да, конечно же, это все будет решаться на фронт-энде, потому что смысла нет это все решать на бэк-энде.
Вот, и знаете, что я могу сказать?
Ну, это протягивается на бэк-энде.
Ну да, конечно же, это все протягивается на бэк-энде, и нам нужно правильным образом все реализовывать в промежуточном представлении.
Условно, что даже они меняются по-другому, даже они меняются по-другому по языке, потому что по интернозуся,
Ну да, это да. Вот, и давайте вот как раз поймем, какие концепции нам здесь будут полезны с точки зрения предыдущих блоков.
Давайте сразу подчеркнем, вот давайте подумаем, какие идеи из предыдущих блоков нам помогут реализовать некоторые из пунктов.
Вот, у нас есть...
Да, то есть мы с вами понимаем, скорее всего, что инкапсуляция дает чек.
Да, это новая иерархия символ тейпл. То есть если мы с вами вспомним, как у нас это все работает в классических языках программирования,
то у нас таблица символов была одноуровневая, то есть у нас именно были атрибуты.
Здесь у нас появляется еще второй уровень, это уровень наследования.
Вот, как раз сегодня покажу некоторые примеры, которые нам помогут посмотреть, как работают они по языке.
Итак, план. Надо посмотреть, каким образом можно реализовывать методы, каким образом пишется код методов, каким образом вызываются методы,
и каким образом реализуется наследование. И в полях нам необходимо посмотреть следующее, как их располагать в памяти.
Раз, для того чтобы у нас был плоский лаяут. Дальше, конечно же, мы должны рассмотреть вравнование этих полей.
И третье, это рассмотреть, как работает тоже наследование в этих полях.
Давайте начнем сразу со следующего, чтобы вы понимали, как вы думаете, на какой язык программирования будет больше похож ER для объектно-эритерных языков?
На обычный ER?
Нет, нет, из высокоуровных языков программирования.
Ну, типа Си, на Си?
Ну, во-первых, на Си, а во-вторых, есть более точный ответ на этот вопрос.
Си-90?
Нет.
На Питон?
На Питон, да.
Что у нас в Питоне происходит, когда мы вызываем любой метод класса?
Какая у нас сигматура метода класса?
Как объект?
Нет, нет, как определение этого метода идет?
Оргумент на себя, да.
Собственно, в любом Яре так и происходит.
То есть у нас будет первый аргумент, а вызов у нас может успеть.
Вот там методы тогда делаются тем, что у тебя объект буквально хранит функцию, это не важно.
Ну, это да. Мы с вами говорили в прошлый раз, что функция это...
Там еще известно, что можно сделать метод...
Этот метод на самом деле, это просто другой объект, у которого есть операция по выиску.
То есть метод в Питоне, метод класса, это другой класс, только супер-класс.
А сейчас в Питоне ты можешь в классе свой объект в другой тип, и у него если поменяются все методы.
Ждем Питон 4 с хистической типизацией.
Моджер, да, моджер.
Моджер, да, кстати, по-моему, у них недавно новая версия вышла.
Какая-то ИС.
А, и первая бета Питон 3.13 вышла на нее.
В которой попытаются сломать Global Interpreter Log.
Ладно, давайте посмотрим.
Первое, что нам, кстати, необходимо понять, я это в презентацию не вставил,
что у нас с вами, значит, необходимо каким-то образом транслировать наш код ВИА.
И в данном случае здесь у нас есть две подхода.
Первый подход используется для реализации шаблонных функций, а второй подход используется для ООП.
Значит, подход, который реализуется для шаблонных функций, называется static dispatcher.
То есть, когда мы все методы, все типы определяем, и все касты у нас определяются на этапе компиляции,
понятно, что для как раз темплейтов это сделать достаточно просто.
Мы просто сигнализируем, смотрим на наш код, понимаем, с какими аргументами они называются,
каким методом для этих кодов.
Ну, собственно, static dispatcher это любой язык, который поддерживает парадигму шаблонного программирования.
Но в чем проблема так сделать для объектно-уриентированных языков?
Сразу определить.
Что сразу определить?
Типа, со которыми все вызывается.
Ну, типа у нас может быть шаблонная функция, которая типа неизвестна, пока мы не член объектноцивировали.
А, да-да. Там, условно, имя, имя – это не имя.
У нас непонятно, какое имя является, имя не переменной, а какое имя типа.
Ну, да, тоже имя такое.
И, соответственно, здесь мы на этапе компиляции, ну, как бы, можем не определить, что у нас происходит, да?
Мы можем не отличить метод с переобделенным на другом, кроме стопами, от функции.
Да. Вот, поэтому нам нужен другой механизм.
Этот механизм называется динамит-диспачок, динамической диспетчеризации.
Вот, и для того, чтобы как раз использовать динамит-диспачок, нам нужна одна из важных парадигмных языков, парадигм реализации языков.
Собственно, те, кто так или иначе писал хотя бы раз ткот на C++, знают этот механизм.
Да, понятно, что те, кто не писал ни разу на C++, его не знают.
Ну, вроде, как на нашем факультете всегда начинают писать C++.
Ну, или по C.
Вот, поэтому вы знакомы с ключевым словом virtual.
Вертальные функции.
Вот, собственно, в чем состоит суть?
Значит, у нас с вами, помимо нашего объекта, будут представляться следующие вещи.
У нас с вами будет, напоминаю, что объект типа класса мы определяем в таблице символов.
Представим себе, что у нас есть некоторый объект, который называется 3D.
Я взял некоторые примеры.
Значит, класс PTR.
Значит, это по факту диаграмма класс V.
У него есть метод, представляющий этот класс 3D.
При этом он включает некоторую таблицу диспетчеризации.
То есть у нас с вами по факту будет репрезентация этой штуки.
То есть у нас с вами будет метод getX.
Дальше у него будет лежать метод norm.
После этого у нас будет лежать еще один метод, еще один метод, еще один метод.
То есть у нас получается вот такой набор методов, которые есть.
И дальше они, собственно, ссылаются на некоторый определенный код.
То есть мы можем легко достаточно посчитать offset, если нам нужно для этой таблицы, для того чтобы получить результат.
Единственный момент сразу скажу.
Понятно, что здесь на презентации указано, что у нас будет использоваться код этого метода.
На самом деле у нас будет ссылка на фрейм.
Который мы дальше будем трансформировать.
То есть что такое фрейм?
Это у нас функция, это у нас набор архиментов, которые мы принимаем.
Ну и инструкция.
И по факту, когда мы транслируем наш код в код промышленного представления, мы транслируем его по фрейму.
То есть мы берем функцию, транслируем для.
Берем функцию, транслируем для.
Понятно, что для этого нам нужна таблица символов.
Вот, то есть у нас получается вот такое вот представление нашего класса 3D.
В нашей таблице диспетчеризации.
Значит каким образом это все хранили?
На самом деле здесь представим себе вот у нас вот такой вот класс есть.
То есть у нас с вами есть класс A, у которого есть метод foo, void.
А дальше у нас есть класс B, который расширяет класс A.
И у нас с вами есть методы bar и методы bas.
И дальше класс C, который реализует метод B.
Значит что в нем есть?
У нас с вами есть метод foo, у нас есть метод bas.
И у нас с вами есть метод какой-то еще qx.
Что мы с вами здесь видим интересного на этом слайде?
Каким образом у нас объекты расположены?
Друг за другом.
Друг за другом. То есть то, как они определялись в базовую реализацию.
То есть у нас есть метод foo, у нас есть метод bas.
Ну, это да.
Ну, не, ну ты просто пиши.
Леонидовческий символ table.
Да.
Ты можешь...
Ты так же говоришь.
Ты смотришь как у нас C, идешь в символ table, символ table в свою маку.
Если в своей маке нет, идешь в маку позже.
Да, да, да.
То есть у нас получается еще один символ table.
Так символ table структура.
Да, да.
То есть символ table структура, в котором есть методы.
Понятно, что еще важно будет...
Ну, кстати, для обычных языков программирования.
Сейчас, дайте, конечно.
Наследуемые A, B классы, методы, они должны иметь ту же сигнатуру.
Они должны иметь совместимость.
Ну, в плюсах должны иметь совместимость.
Да.
То есть можно в плюсах extend быть возвращаемым типом.
Если возвращаемым типом, то реально...
Ну, типа...
В базовый класс можно возвращать, типа, кое звездочка.
На следовый класс можно держать drag звездочка.
Ну, можно, типа, вспоминать принципы соли, типа...
Это принцип варбара лесков.
Да.
Принцип варбара лесков.
То есть, если он...
Да, я согласен с этим.
А можно чуть-чуть менять, но...
Должна запорядиться.
Ну, в целом, да.
Хорошо.
Вот.
То есть у нас вот такая вот реализация.
В принципе, таблица диспетчеризации мы можем с вами как раз таким образом исправить.
То есть у нас есть foo.
У нас есть bar.
У нас есть qx.
Отлично.
То есть кажется, с методами мы с вами разобрались.
Да.
Единственное, конечно, в чем есть проблема.
Когда мы вызываем метод, да, то нам нужно будет решить что.
Вот у нас есть какой-то класс C.
Да.
И мы вызываем с вами...
Вот у нас вот такой код.
То есть мы с вами соберем объект класса A.
У нас объект new класс C.
С класс C является наследником класса A.
То есть первое, что нам нужно будет проверить.
Давайте подумаем.
У нас с вами в нашей грамматике появится new...
Знаете, ну...
А?
Оператор new.
Да.
Оператор new.
У него в AST деревню соответствуют некоторые...
Это просто унарный префикс оператора.
Унарный префикс оператора, который возвращает объект определенного типа.
То есть у нас есть оператор на типо металлический объект.
Да.
Ну, собственно, дальше в операторе присваивания нам нужно будет проверять.
Ну, нет.
Просто очередная дайчет-проверка, что у нас тип триггажа приводится.
А в том числе автоматически приводится к нужному.
Да, да, да.
А дальше что-то нужно будет делать, когда мы будем вызывать этот метод foo.
Давайте подумаем.
Пойти в...
Смотреть в таблицу на A и посмотреть, есть ли у него foo.
Да, есть ли у этого штуки метод foo.
А кого будем вызывать?
Мы смотрим на тип нашего объекта A.
Вот это важно, что нам нужно будет посмотреть на конкретный тип.
То есть нам нужно будет фолдить две структуры.
Зачем будет приобретение?
А так, а у A есть вот...
У нас бы таблица на A.
Нет, ну если у нас A вызывает метод foo,
то по идее мы должны вызывать все-таки метод у класса C.
А, это такой виртуальный метод.
Ну, мы просто делаем педагогический код.
Идем из первого поля A, достаем диспочты.
Без диспочтей мы достаем offset и вызываем A.
А, ну да, в принципе, у нас у каждого объекта есть диспочт тейпл.
А там как раз этот метод foo.
Это уже, наверное, не спектруализация, если мы будем заниматься декастингом.
Ну, типатический спектр.
То есть, в принципе, мы видим с вами, что как раз для этого
индексы нашего метода они сохраняются и добавляются.
Это уже можно, короче, даже делать.
Ну, это, в принципе, да.
То есть, у нас получается вот такая абфракция.
В принципе, она достаточно удобна.
В принципе, у нас в методе добавляются чистые вверх.
Так, хорошо.
Дополнительно, кстати, нам нужно будет проверять модификаторы доступа.
Понятно, каким причинам нужно проверять модификаторы доступа.
Ага, конечно.
Мы живем в Питоне. Замечательно.
Ну, хотя по горнику надо будет кидать.
Вот, значит, у нас вызывается метод foo, соответственно.
Нам нужно будет проверить, зайти в публицию диспатченную метода a.
Посмотрите, является ли она private или является protected методом.
Да, типа где он у нас вообще может вызываться.
Ну, это еще одни дополнительные проверки, которые мы можем делать на стадии runtime.
Ой, нет, на стадии преобразования v и r.
Вот, так.
Эта картинка понятна?
Хорошо.
Давайте поговорим про поля.
Ну, на самом деле, с полями все намного проще.
Да, то есть у полей ровно такая же структура.
То есть у нас с вами есть класс 2д точки, который имплементирует объект почт.
И, собственно, у нас, на самом деле, вы не поверите, все реализуется в виде структуры.
Да, то есть у нас есть...
Чудеса.
Чудеса. А структура это на самом деле будет массив.
Ну, которая будет у структуры.
Разнотипизованный массив.
Да, то есть у нас как раз, если мы сейчас...
Чупол.
Времени в структуре только чупол, на самом деле.
Да, да, да.
Ну, мы это сейчас как раз посмотрим.
То есть у нас как раз у нашего объекта будет 2д.x, 2д.y и 3д.z.
То есть у нас получаются дополнительные точки, которые мы с вами как раз будем добавлять в конце.
Вот.
И, собственно, здесь, кстати, нужно будет еще задуматься при еще одной абстракции.
Давайте подумаем при нем про статические методы.
Что такое статические методы?
Ну, типа...
Функция, которая владеет сам тип.
Ну, можно сказать, что...
У изомственничественных функций можно налетать апелляции,
у меня нечетко функцию вызываемой, если мы взяли какой-то тип.
Ну, в целом, да.
Один из вариантов создается функцию глупой, мы ее будем перегрузить.
Ну, да. То есть мы по факту берем и демонтируем наше название.
И их создаем в функцию определенного типа.
Вот. И определенный аргумент.
Главное, чтобы любые другие методы не имели доступ к этой функции.
И к этим переменам.
То есть нам нужно будет с вами декодировать нашу информацию.
Вот. Значит, мы с вами сказали, что на этапе фронт-энда нам необходим страницу
реализовать таблицу символов на несколько уровней.
То есть первая у нас по объектам, вторая у нас по полям.
И для каждого поля объекты необходимо иметь доступ к эротическим узлам.
То есть у нас все должно именно аккуратно все наследоваться.
Вот. Значит, я тут еще взял определенный пример.
Вот. Как это может реализовываться.
Давайте посмотрим на этот пример.
Собственно, что мы здесь видим?
Мы с вами здесь видим, что у нас в...
Это я взял пример, кстати, из книжки инжинирика Капайлер,
в которой, как ни странно, все хорошо написано по этому поводу.
Итак, у нас что говорится?
У нас с вами есть класс.
Значит, это ему название.
Он ссылается на сам себя.
У классов есть методы.
У классов есть ссылка на родительский класс.
Да, потому что мы могли, если что, обратиться к родительскому классу
и вызвать у него метод.
То есть сделать таблицу диспетчеризации.
Вот он, кстати. Вот он на части.
Есть класс метода.
Значит, что такое класс метода?
Это статический метод в данном случае.
Вот. Конечно, их можно преобразовать.
Но, в принципе, в некоторых языках есть статические методы.
Есть класс метода.
Вот. Дальше у нас с вами есть класс метода упойнта.
Это draw и move, допустим.
Вот. И дальше у нас с вами есть ссылка на родительский класс.
То есть у нас получается с вами, что это ссылка на...
саму в сущность вида класса.
Это ссылка на родительский класс.
То есть здесь по факту джавовская реализация,
которая говорит, что у нас тип Object есть.
Ну, в принципе, хороший пример для того,
чтобы там не плодить, допустим, ромбовинного наследования,
когда все есть от Object, то и следующие вещи.
То есть суперкласс.
У нас суперкласс идет вот сюда.
И мы идем на пуэнты.
И у него есть класс метод.
То есть у нас добавляется понятный метод.
Вот. И дальше у нас уже есть наследование.
То есть у нас с вами вот это colorPoint.
У него есть некоторые поля.
И дальше у нас есть реализация.
Есть simplePoint, то есть которая наследуется от простого 포인та.
И у него есть собственные методы draw и move,
в котором есть координаты.
И есть классы под названием leftCorner и rightCorner.
У которых тоже есть свои собственные методы,
которые реализуются от класс-методов.
Вот. И у нас получается вот эти вот Object.
То есть в принципе,
когда нам нужно будет обратиться к какому-то методу move,
и если нам, допустим, вызывается супер,
то есть нам нужно будет добавить новое ключевое слово под именем супер,
что мы делаем?
Мы просто идем по указательам,
обращаемся к родительскому классу.
Да, кстати, в битоне в этом плане очень смешно,
что там же метод супер, он работает,
он может принимать в качестве аргумента класс.
Там что угодно может быть.
А?
Кто-нибудь что угодно там может быть.
Нет, и тогда можно прыгнуть на несколько уровней вверх.
Вот. Более того, я не знаю, мы сталкиваемся с вторым битоном.
С чем?
Со вторым битоном.
Но на каком уровне нет?
Нет, просто в третьем байтоне есть метод супер,
просто, без аргументов.
А в третьем, во втором битоне нужно было явно кастить эти типы.
То есть, если я сейчас открою...
А, кстати, забавная история.
Я вчера собирал из исходников, поэтому 3х8.
Но на старом ноутбуке своем, 14-го или года.
Есть мем с функцией супер.
То есть, если у вас на стеке метода есть функция супер,
то вам в унической направлении накидывается некая локальная переменная.
Кто-то просто заходил.
Во.
Вот так оно развивалось.
Класс B наследуется от класса C, и вам не важно, в общем,
что принимается супер, это была просто built-in переменная.
Built-in функция.
Класс.
Да.
Это built-in переменная, которая...
Вы знали о некотором направлении?
Говорят, что направлении представляется на две дополнительные перемены,
которые в функции супер, но при себя сочетаются с предыдущего проема.
Ну да.
Они запустили это дело.
Да.
В общем, вот такая вот вещь.
То есть, это тоже нужно учитывать.
Итак, значит, это что касается вот этого примера реализации.
Давайте я предлагаю сейчас с вами сделать небольшую практику
по поводу вот этого всего блока.
И посмотреть, каким образом это все транслируется в промежуточное представление.
Давайте для этого мы откроем с вами наш любимый getBolt.
И напишем что-нибудь.
Так.
Давайте как раз возьмем пример вот этого объекта.
У нас получается есть класс A.
VoidFull.
В смысле noisemdegenerated.
Что-то я не то делал.
Почему?
А, минус C, я понял, да?
Не, минус C и мы не получаем.
Ладно, короче, будет быстрее так сделать.
Во.
А.
А, подождите, я понял, паблик.
Не-не-не.
Итак.
Давайте посмотрим, что он сделал.
Значит он, во-первых, нам сгенерировал инструкцию link1 с one definition role.
Да, то есть для метода вот этой штуки.
И дальше он начал принимать аргумент X.
Вот, смотрите.
То есть у него есть аргумент %0.
А подождите, а почему здесь дебаг флаги есть?
А как можно убрать дебаг флаг?
Может тут лишние эти?
Вот эти 21 и 23 строка.
Ладно, пусть останутся.
То есть смотрите, что у нас происходит.
У нас с вами алоцируются.
Вот первое, что мы здесь видим,
это у нас с вами есть некоторые патеры.
Вот этот вот.
No-undef, no-null, assign, differentiable 0.
Чего?
Да, на себя.
Давайте вот так intX равно Y.
Так, давайте посмотрим, что произошло.
4, да.
Говорит, что класс не может 0.0.5.
Да.
То есть на что он делает?
Вот, дальше что у нас происходит.
У нас алоцируются патеры.
Вот это вот, то есть видите.
Первая инструкция, которая у нас здесь автоматически есть,
у нас тег алоцируется вот эта переменная sys.
И у нас копируется вот эта переменная sys в 25 строке.
Почему нельзя это?
А?
Не знаю.
Возможно, что это неоптимизированный код.
Да, скорее всего это неоптимизированный код.
Вот, дальше что у нас происходит.
Видите, мы загружаем данные по указателю %2.
И дальше первое, что мы с вами видим,
у нас есть get элемент ptr-inbounds.
То есть мы берем и берем значение по 0-ому указателю.
Вот, хорошо.
Что, давайте это.
Да.
Вот, да.
Вон, wisp-tr.
А, звездочка.
Так, давайте на 18.
Вот, то есть вот он.
Чего?
А, это main.
Я всегда забываю, что это функция main.
Итак, давайте посмотрим, что у нас с классом B происходит.
Да, которые будут публично наследоваться от класса A.
Есть.
Итак, вот он на реализации.
Кстати, видите, какой у него location.
Итак, давайте мы с вами объявим функцию виртуальной.
Ага.
И что у нас появляется с вами в VR?
Да, у нас появляется vtable.
Собственно, у нас появляется type-info for A.
То есть у нас явно теперь объявляется.
Кстати, смотрите, тип какой у класса A.
Да, да, да.
Вот, и дальше.
Вот, и собственно, что мы здесь видим?
Мы видим, тут сохраняется имя нашей функции.
Так, это что у нас такое?
А, да.
Вот, то есть у нас type-name for A сохраняется.
И дальше у нас есть, кстати, type-info for A.
У нас опять же getElementPatternBounds.
Вот, то есть у нас есть такая вещь.
Так, что теперь?
Давайте попробуем реализовать.
Так получается.
Так, а что?
А, подождите, паблик забыл, как обычно.
Стоп, а что он тупит?
Может я неправильно написал?
А, приватные методы, господи.
Давайте protected сделаем.
Итак, давайте посмотрим, что у нас произошло.
Значит, давайте посмотрим, что у нас произошло.
Значит, давайте здесь мы будем вызывать new-bay теперь.
Вот, и у нас, видите, в чем особенность?
Мы можем прямо явно зашить виртуальную таблицу в RLVM.
То есть, видите, мы прямо ее зашиваем.
Понятно, что ее можно самостоятельно реализовать,
но, видите, оно здесь нам тоже позволяет это сделать.
Кстати, смотрите, как оно реализует новый класс.
То есть, у нас с вами есть выравнивание, да?
А класс B это тип класса A и IN32.
Дополнительный.
А вот, и добавляется у нас класс ABase.
Это PTR и IN32.
IN32 это наша переменная K.
Дополнительно.
Вот, значит, здесь у нас виртуальная таблица идет.
И теперь давайте посмотрим, что у нас происходит.
Какой у нас метод вызывается?
Вот, мы вызываем call void BB.
И, кстати, смотрите, в чем особенность.
Особенность в том, что когда у нас есть PTR,
нам не нужно биткаст сделать.
Потому что если бы он откатился в 12 версии какой-нибудь,
да, видите, то есть нам пришлось бы кастить.
И сначала IN звездочку, да?
Дальше у нас, кстати, замечу, что у нас есть метод Bedset.
Memset.
То есть, что он делает?
Он берет вот этот аргумент, вот этот тип,
и заливает нулями значения в этой всей штуке.
Вот, и дальше нам бы пришлось кастовать.
А, да, и, кстати, смотрите, все равно, когда мы делаем alloc,
нам пришлось бы лоцировать вот это все дело в метод fo.
Значит, и теперь давайте посмотрим, как это все происходит.
То есть мы кастим вот эту всю штуку.
Загружаем переменную.
И дальше смотрите, что у нас происходит.
Давайте я вернусь на новую версию все-таки.
Во.
Обратите внимание, значит, у нас с вами идет,
во-первых, мы с вами загружаем вот эту переменную.
И мы явно здесь не вызываем метод fo.
Обратите внимание, здесь у нас нет нигде вызова метода fo.
Да, да, да, да.
То есть из-за того, что мы с вами зашили vtable вот сюда,
а он вызывает как раз метод из виртуальной функции.
То есть он обращается, смотрите, то есть он обращается к нашему полю,
он обращается к нулевому методу
и делает результат.
А вот они реализации метод.
Господи, тут еще и конструкторы классов какие-то тяжелые.
Да, вы, кстати, конструкторы класса они посмотрели?
А, да, понятно.
Дело в том, что у нас есть vtable,
то надо разгонять конструктор, который будет в первое поле класть vtable.
Да, вот, в первое поле у нас как раз кладется vtable.
Для этой штуки.
Вот, и, собственно, здесь мы видим с вами,
что у нас идет обращение к нашим переменным.
Кстати, обращу внимание, как он генерирует код.
То есть он явно каким-то образом понимает,
что, вот, на стадии front-end,
что нам нужно у класса A вызвать первый аргумент, да,
то есть это Y, и у класса второго вызвать аргумент K.
Ну, аргумент K.
Итак, давайте мы с вами еще вызовем суперметод.
Так, сейчас, секунду.
Как это делается?
А, тут нет, по-моему.
Давайте посмотрим, что он именно генерирует.
Итак.
Вот оно, то есть у нас...
А, да, и, кстати, конструктор класса A у нас тоже вызывается вот здесь, да,
то есть вот у нас класс B паблика,
и здесь как раз мы тоже зашиваем bitable для символов A,
то есть не забываем ту же штуку делать.
А вот как вызывается foo.
Кстати, обратите внимание,
что здесь явно у нас вызывается метод foo.
Кстати.
А, не-не-не.
Блин.
А, понял.
Нет такой штуки.
Я хочу вспомнить,
если метод супер,
если метод супер,
если метод супер,
если метод супер,
метод супер в C++,
по-моему, нет.
Супер, это ты просто делаешь шифт
на гольде.
В C++ здесь статикаст,
отзыск, класс уранитера.
Он делает даже принимать двери, если нужно.
Ну, да.
Ну, там, конечно, это...
Если есть, конечно, тротуарная база,
то табля начинается полная,
что надо посмотреть,
опять же, пойти в битейбл,
и найти базу.
Ну, да.
Кстати, давайте попробуем отключить метод void.
Сейчас виртуальная база,
она прикасит базу...
А, он в битейбле ищет offset на базу.
Во, кстати.
Если мы отключаем виртуальную таблицу,
то все становится намного проще,
но при этом у нас на стадии компиляции...
Кстати, а какой метод тогда он вызывает?
Он вызывает afo.
Да, конечно, он вызывает afo,
а не bffo, потому что он...
Классно.
Да.
Вот, то есть у нас получается вот такая штука.
То есть что нам нужно сделать?
Значит, нам нужно будет с вами
алоцировать таблицу символов
для класса A.
Дальше у нас с вами есть класс B,
собственно, в котором int32.
Давайте intT если мы добавим,
то что у нас происходит?
Видите, у нас добавляется еще один тип.
И в конце у нас идет выравнивание
как раз наших полей.
И, собственно, здесь мы с вами
говорим, что у нас будет
виртуальная таблица,
в которой у нас с вами
будет следующее,
что typeInfo у нас будет здесь,
а дальше у нас будет getElementPatternBounds.
То есть у нас получается второй аргумент
здесь,
и, собственно, у нас получается
есть виртуальная таблица
для afo.
Понятно, что...
Да, вот у нас ее имя.
Понятно, что это можно
писать все руками.
И, допустим, здесь можно
еще, кстати, делать virtual.
И тогда у нас...
Да, the table for where
тоже у нас будет генерироваться.
То есть это метода.
То есть их, в принципе, можно использовать
и использовать по...
так сказать, назначим.
Вот, значит, давайте посмотрим, как это все
компилируется в Assembler.
Так, вот он метод
b.foo.
Да, и видите, здесь явно...
Подождите, а где main?
А, вот они.
Вот они, секция данных у нас
появляется.
То есть у нас появляется
секция данных,
а здесь есть
секция данных,
а здесь есть
секция данных.
То есть у нас появляется секция данных,
в которых есть xword.
То есть специальные символы, которые нам помогают
определить, что это за таблица.
То есть у нас тут есть как раз ASCII символы.
То есть каким образом у нас называется
тип. Вот, и дополнительно
видно, что у нас есть
typeInfo, то есть
объект типа typeInfo.
То есть у нас получается
вот такая.
А где main?
То есть смотрите, мы вызываем
оператор new,
а здесь мы вызываем оператор
b,
и дальше у нас с вами идет
где?
Вот он метод foo,
что такое blr, это у нас
как он
загружает это все?
Да, это col.
Давайте посмотрим, как он реализуется.
То есть у нас здесь ldr есть, loadRegister.
Foo нету.
Давайте, кстати, сделаем их.
Вот,
мы внизу еще
мы их назначаем.
Вот,
вот файлент в вашем документе.
В x8
он достал
просто 3.
Вот так на ZZ
уже можно перейти сам к себе.
Да, да, да, да.
А нет, сейчас мы же
в X0 скорее
сейчас.
Да, в X0 лежит pointer на ZZ
потому что
потом он достает из адреса
на x8, он достал
кусок на
кусок с
дальше он достал
первое поле, это видимо первое поле.
x8, x8.
Да, да, да, да.
Интересно, конечно,
это все описать.
Когда идет трансляция в Assembler
нужно четко прописывать
про логи,
эпилоги
и всякие такие вещи.
Обычно сейчас это доверяют
другим
абстракциям.
То есть видим мы с вами, что
у нас с вами есть такая реализация.
Ну и, собственно, опять же
для проверки здесь можно сделать следующее.
Если мы хотим оверрадить какие-то методы
то
тут
опять же у нас ошибка эмпиляции.
Python в принципе такое позволяет.
Python это Python, как мы с вами сказали сегодня.
И, собственно, мы видим с вами, что
класс это по факту это и есть структура.
Питоник у вас
словарь почему-нибудь
один поле по имени класс
в котором появится указательный объект
класса. Причем указательный объект
класса который словарь
у всех объектов.
И методы определенные для этого
класса это просто поля в
основаре в котором лежат функции.
Ага.
Вот. И видно, что здесь у нас
полное название нашего класса
должно быть для того, чтобы
это все работало.
Вот. Такая вот интересная
магия происходит.
Ну, не то что магия.
Вот.
Но, кстати, смотрите, давайте еще в последний момент
для того, чтобы мы понимали с вами, что
мы можем обращаться именно к структуре.
Я поменял тип.
Да, и
мы с вами видим
куда это все идет.
То есть у нас идет y плюс t.
Это у нас метод foo. Так, стоп.
Вот метод foo.
Ну, метод b, метод foo.
То есть на get элемент patternBound здесь мы обращаемся
уже ко второму полю.
А, не к первому.
Вот.
Вот такая вот интересная вещь.
Так, хорошо.
Значит, давайте
поймем. Это понятно?
Что мы рассмотрели?
А это что писать? Это самостоятельно.
Там некоторое...
А?
Ну, да.
Но понятно, что это можно сделать в простом варианте.
То есть не создавать виртуальные
таблицы, а в базовом варианте их
сразу
написать. Просто, видите,
в LVM есть собственная структура для
поддержки таблиц. Ой, виртуальных
таблиц.
Вот. Значит, куда...
Давайте тогда
подытожим. По блоку объект-ориентированного
программирования мы с вами, в принципе,
поняли, как работают
ВООП языки и как происходит
трансляция ВООП языки.
Но теперь нам нужно понять, куда
мы можем двигаться дальше
по поводу тех
знаний, которые у нас были получены.
Ну, первая, на самом деле, самая
интересная вещь, в которую прибегают
люди, это, конечно же, оптимизация
всякого рода.
Да, тут и сидят коллеги,
которые прямо пошли на кафедру.
Связаны с этим
оптимизацией.
Ну, понятно, что
зачастую, конечно,
если даже компилятор работает, ну,
типа, нам, так или иначе, на практике
сейчас иногда бывает даже
не полезно использовать именно
более оптимизированные компиляторы,
а некоторые люди пытаются просто
написать компилятор
для своих собственных нужд.
То есть, для своих собственных нужд,
для domain-specific language и так далее.
Значит, а что нам нужно,
что нам важно для domain-specific
language обычно?
Вот это domain-specific language.
Ну, кстати, это
язык под свою
кутэ сделан.
Ну, например, это кутэ
и его при процессе.
Угу. Что нам будет
важнее даже для вот этих языков?
Ну,
помимо, конечно, скорости его работы,
ну, это даже может быть...
Возможно, прикручивают ключи.
Возможно, прикручивают ключи.
Возможно, прикручивают ключи.
Раз. Ну ладно, даже если мы
не сможем
прикручивать ключи,
это ладно с ним.
Угу.
Давайте поймем. У нас могут быть
интерпретированные языки, у нас могут быть компилированные языки.
Да, для интерпретированных
языков, в принципе,
ну, чего-то особо не надо.
Понятно, что для компилированных языков у нас
должна быть система сборки
нашего проекта, то есть нам
должна быть система, которая бы смогла
трансформировать это все в объектные файлы,
да, ну, и дальше
линковать эти объектные файлы
с учетом того манглинга, который нам нужен.
Ну, что нам еще нужно?
Вы как на этом языке
собрались писать?
А, ну, нам нужна, получается,
среда разработки, ну, либо
своя, либо создаем,
либо используем существующие.
Нам нужны всякие, допустим,
так сказать,
всякие, ну, типа дебакеры,
линкеры,
форматеры,
там расширение для популярных редакторов,
которые мы делаем.
Вопрос, как вы думаете,
есть ли общий механизм,
который уже это поддерживает?
Ну, есть такая вещь, как СЛАМГД.
Ну, это
вообще так.
Есть такая вещь, как
демон языка,
то есть это сервер, который работает
как акултерик, к которому может
выключаться редактор, СЛАМГД,
как раз отлимитация этого демона
к языку с сейфусбуком.
Да, да, да. А вообще я хочу
показать следующую вещь. Есть
language server protocol, не знаю,
слышали вы или нет про него.
Да.
Собственно,
как раз
специальный
сервер,
который позволяет вам
сделать автокомплет
всяких разных вещей.
У него, значит, есть спецификация этого
языка. Как видно, что он разработан
поддерживается
Микрософтом.
Ну и, собственно, здесь как раз указываются
заголовки. То есть вам, когда
нужно будет отправлять какие-то запросы на сервер,
да, он работает
по RPC протоколу.
Ну и, собственно, здесь
нужно будет указывать
определенные типы.
То есть какие у нас запросы идут.
Да, то есть видно, что здесь у нас
запрос по умолчанию
не базового языка. У нас
точнее запрос не
по простому протоколу HTTP, у нас
по протоколу RPC здесь идет взаимодействие.
Remote процедуру call.
То есть у нас в вами здесь есть
интерфейс, в котором
должны расширить наши сообщения.
Вот, собственно, здесь есть
спецификация
о том, что у нас есть. То есть нам нужно
научиться писать вот такие вот серверы.
Вот, и вот у него есть, допустим,
ошибки. То есть у нас
может быть ошибка парсинга, у нас
может быть invalid request,
у нас может быть метод not found,
invalid params и так далее. То есть видно,
что здесь
есть разные способы. Можно, кстати,
отправлять нотификации.
Вот, и
собственно,
даже для систем сборки, видите,
есть механизм,
который нам позволяет
оповестить о том, насколько мы
сильно обработали наш запрос.
Вот, дальше
здесь рассказывается про URI,
собственно, каким образом он работает.
То есть, в принципе, видите,
вот он URI. То есть это у нас
в каком папке, в каком месте
у нас наш код находится.
Вот, и это чем удобно?
Когда вы отлашиваете код, вот, допустим,
в том же самом Visual Studio код или в любом
сексом редактора, у вас есть внизу
ссылка на файл, на который вы можете
кликнуть и перейти на определенную строку.
Да, это удобно.
То есть, когда у вас ошибки сыпятся,
вы просто CTRL-клик и делаете.
То есть, на самом деле, вы как раз можете
указать, где эти ошибки есть.
В общем, тут
спецификация огромнющая, как видно,
сколько уже пролистал,
чего тут есть.
И, собственно,
есть идентификатор языков,
которые можно использовать.
Вот.
Здесь это можно уже
как раз использовать.
Видно, что прямо это.
Сейчас это прямо расширяется
и все такое. По-моему, кстати, JetBrains
поддерживает LSP.
Должен поддерживать.
Пока знаю,
есть расширение для GIMP
для лампочных протоколов.
Что?
Для GIMP вроде как есть расширение
для лампочных протоколов.
Это, по идее, да.
То есть, в принципе, у нас
поднимается сервер
и при помощи него мы как раз работаем.
То есть, это
еще куда можно развивать
эту всю вещь. Понятно, что
если вы, допустим, работаете
с новой архитектурой,
то понятно, что вам нужно будет
писать лавринг под эту архитектуру.
Т.е. трансформировать ваш код таким образом,
чтобы он работал под письвичную
архитектуру.
Вот. То есть, видно, что...
Люди, которые из ACST,
они и помешали бы
подошел в NPR
Нормально.
Тоже, в принципе, рабочее.
Вот.
Что еще рассказать такого интересного?
Вроде, наверное,
из основных моментов все,
куда это можно копать.
Ну и в целом, понятно, что
пока что
можно это все еще
использовать для разных трансляторов.
В принципе, трансляторов сейчас много.
Возможно, что, кстати,
что-нибудь интересное появится
из мира веба.
Если говорить, то сейчас...
Ну, во-первых, да.
Во-вторых, есть сейчас
вот такая вещь.
Не знаю, слышали или нет.
htmx
О, ну это
обзор с NPR
Угу.
То есть, оно, на самом деле,
немножко транслирует это все
одновременно
код
на фронт-энде плюс код
на джампскрипте.
Вот.
Кстати, возможно, что браузеры в какой-то версии
начнут поддерживать htmx.
Но пока вроде такого не замечено.
Ну а что, если
в чем-то получится?
Ну, как-то так и будет
подойдет. Ну, типа,
я вижу, конечно, код.
Ну, давайте посмотрим,
что у нас происходит. У нас здесь есть скрипт.
Загружается. Ну, специально.
А дальше мы
через отдельные атрибуты делаем следующее.
У нас кнопка. Значит, при нажатии на кнопку
мы отправляем пост-запрос
на кликт.
Вот.
То есть, когда пользователь кликает
на кнопку, у нас идет
отжаг с реквеста на сервер и
дальше replace
entireButton
viss html.Response. То есть,
мы заменяем всю кнопку с
весь атрибут кнопки на вот этот результат.
Ну, то есть, то, что приходит с сервера,
тот шаблон, который рендерится,
мы вставляем его полностью.
Там теперь результат формушки приходит.
То есть, у нас кнопка берет, убирается.
Вместо нее рисуется холм.
Вот. То есть, в принципе,
видно, кто их
поддерживает.
Кто этих ребят поддерживает.
Песель какой-то.
Я цепился, поддерживаю.
Значит, хороший продукт.
Да. Вот.
Собственно, и дополнительный
здесь идет кликин.
И вот пока что это, конечно,
не очень такая
проднутая система. Может быть, на нее перейдут.
Но в целом как бы здесь нам придется
делать трансляцию в два разных языка.
Да.
Да, первое это в HTML, второе это...
Давайте вспомним DLSX, JSX и GD.
Там у кого-то то самое.
Ну, в целом, да. То есть, бывает, что у нас
трансляция идет не в один язык, а в несколько разных языках.
Вот. Ну, в целом,
можете мне поверить, вот этот вот код,
на самом деле, вот этой странички
он превращается где-то в...
Значит, в...
Получается такой же код на HTML,
плюс еще, ну, наверное, где-то строк
30-40 на Javascript.
Вот.
Javascript больше не
язык выхода для компилятора.
А? Javascript больше
не язык написания в программе
язык выхода для компилятора.
Ну, да, да, да. Очень странное
и нежное слово.
Не знаю, что это.
Надо было тогда
просто, чтобы в браузере отражались
какие-то условно новые...
Так это VimAssembly есть.
Это универсальный ассендер.
В него конфиденция
раз, например,
если будет, чтобы раз в браузере работать.
Да.
Ну, и последняя вещь, где это еще может быть
полезно, ну, это, конечно, совсем
веселая вещь, это опускация кода.
Это весело.
Ну, да.
Да.
Проблема в том, что из JSPack
достаточно легко написать
где компилятор.
Ну, типа, по крайней мере, на
компиляторе, который валяется
в открытом доступе, там
где компилятор включится.
Ну, на самом деле, это опускация,
во-первых, для того, чтобы страничка бы быстрее загружалась.
Не, а опускация
занимается закутыванием
кода в общем виде.
А дальше есть разные применения.
Другие применения, это всякие webpack
которые позволяют страничке загружаться быстрее.
Ну, не опускация.
А вторая вещь,
это именно искусственное закутывание
кода внутри бинарявств,
в его независимой версии.
Ну, это опускация именно вторая, первая,
это не опускация, скорее, это оптимизация.
Да, оптимизация.
Да, вид оптимизации, да, просто сжимаешь,
как все пробелы видеть выше, и так далее.
И еще все пайлы инстрируются на один,
чтобы не загрузиться.
То есть, в принципе,
область применения вот этого
всего добра, она есть
в многих языках, то есть, поэтому
у нас тут тоже важно
говорить не только про код, но и
про языки программирования вообще в целом.
Вот, понятно, что это такой
базовый курс, так сказать,
именно введение, да, более продвинутые
вещи, куда-то тут еще можно копать.
Конечно же, если мы говорим
про ER, то это SSA
форма, это
инструкции, детально
рассматриваете, и так далее.
Поэтому, если мы говорим про какие-то другие
парадигмы, то понятно, что
это там трансляция кодов
именно в эту конкретную парадигму, но
все равно мы так или иначе вскатываемся
в императивную сущность.
Ну и в целом
можно, конечно, и
дальше развивать всю эту историю.
Все равно, кстати,
интересным направлением
будет, скорее всего, понимание
того, смогут ли
в какую-нибудь диффузионную,
ой, в какую-нибудь large model
внедрить понимание
не на базовом уровне
языка, а
где-то в промежуточном представлении.
В смысле, если
обучить нас в различных
материалах про ER,
она, наверное, будет его понимать.
Опять же, понимать в смысле машины.
Сразу скажу, что, поскольку
я в этой сфере работаю, на самом деле
вот эти большие языковые модели
работают немножко не по той парадигму,
по которой работают классические нейросети.
У нее, из-за того, что
количество параметров большое, у нее
по факту возникает механизм притинга.
То есть запечатление
информации. То есть она по факту достает
все, что у нее загрузили из памяти и немного
синтезирует. Но уровень этого
синтеза пока не очень высокий.
Это просто, считаю,
на эксклюзивной
уровне будет все.
Использует все, что есть в этом мире.
Да.
Возможно, чуть-чуть преобразовать.
Чуть в смысл понимать.
С этим были
возможные вещи, что
люди же смогли потом
декомпельнуть, так сказать,
эти языковые модели
и начинать подавать
языковые заявления.
Да.
Найти на чем она столбается и начать
в принципе. Ну да.
Хотя это в принципе
с той временной
индигенцией модели, конечно, вопрос
о вопросном правиле.
Кстати.
Потому что
слишком похожи на людей.
Не пользуются уголом.
Да, да, да.
Да, кстати, при процессинг тоже
про грамматику.
Я не знаю, рассказываю
или нет.
Это как бы
все эти дурацкие тесты
очень хорошо углубляются кавычками.
Обычно, когда ученые проверяют,
что тесты не углубляются, они просто вставляют,
ты просто берешь тест
и включаешь кавычки в первую
кавычку.
Да, да, да, да.
Собственно, еще такой важный
момент. Я, по-моему, что-то хотел сказать.
А, да.
Ну, на самом деле,
когда нужны парси
инструкции,
всегда они заточены на тексты,
поэтому нам делают
навертки над всякими
текстами.
То есть там, говорят, промты,
которые сейчас генерироваются, они иногда
очень веселые. То есть там придумали
свою собственную грамматику для того, чтобы
вот это все закидывать.
Там есть типа
самое забавное, что там есть, это круглые скобки.
Выделяете текст в круглые скобки,
это означает,
что нужно вес этого
куска промта множить
на один и один.
Да, да, да.
Я просто сработаю в этой сфере.
Я фото о какой-нибудь beautiful
и beautiful в трех
круглых скобках.
То есть увеличить на 33%.
Ну, где-то так получилось.
В принципе,
так или иначе, ДСЛ языки
жили, жить и будут жить.
Вот, то есть это куда можно двигаться.
Ну, и в целом, я думаю,
что на этом мы, наверное,
наш рассмотр курса
закончим. На самом деле, в этот курс у нас,
в этом году у нас курс какой-то
даже более продвинутый вышел.
Видимо, тут уже собрались просто
плюс-минус специалисты, которые
уже с этим работают.
Так или иначе,
изучают языки, это отлично.
То есть в этот раз уже даже
было две целых новых темы.
Даже несмотря на то, что у нас количество лекций
было чуть меньше.
Мы смотрим на Волг Волшебный
на выходные дни.
Особенно на
Волшебный, значит, 20 апреля,
который был.
20 апреля, значит, Волшебный был,
когда сделали рабочую субботу.
Ветка встанет, что-то такое, когда
встанет.
Ну, наверное,
на этом все тогда.
Если есть вопросы,
задавайте.
Всем, кто внезапно на YouTube
досмотрел
эту штуку в конце, вы большие
молодцы.
