Так, ну ладно, надо начинать, наверное.
Ну, у нас сегодня последняя лекция, и в ней сойдутся
коды корректирующие, о которых я говорил в прошлый
раз, и теории оконечных полей, о которых я рассказывал
полсеместра.
Я напомню, какой класс кодов я в прошлый раз свел,
называется циклические коды, и мы будем сегодня
обсуждать только их.
Я вот на этой доске выпишу то, что было в прошлый раз.
Значит, что такое циклический код?
Мы берем кольцо вычетов многочленов с коэффициентами
по модулю 2, значит, вычеты по модулю идеала хвн-то
и минус один.
Ну, можно было бы написать плюс один, это неважно,
потому что у нас минус единица равняется плюс единице
в поле из двух элементов.
И код называется циклическим, если он идеал в этом кольце.
И в прошлый раз я несколько свойств этих циклических
кодов обсуждал.
Во-первых, в этом кольце все идеалы главные, то есть
каждый циклический код поражен некоторым многочленом.
Более того, можно считать, что этот многочлен является
делителем многочлена хвн-то и минус один.
Необязательно, можно породить и другим, но любой многочлен
отличается от делителя хвн-то и минус один на какой-то
взаимно простой с хвн-то и минус один множитель,
то есть на обратимый элемент.
И размерность кода мы отсюда легко нашли, она равна n-степень
вот этого порождающего многочлена.
Ну и кроме того, мы еще обсудили, что циклические
коды это подпространство, инвариантное относительно
циклического сдвига.
Ну, чтобы говорить о циклическом сдвиге, мне хорошо бы здесь
базис вести.
Базис самый обычный.
Мне же ведь нужны двоичные векторы, и для этого мне
нужен какой-то базис, чтобы координаты в этом базисе
образовывали двоичный вектор.
Вот в качестве базиса я беру степени х от нулевой
до n-1.
Это базис в любом кольце вычитов, если мы берем
вычеты по модулю идеала степени, порожденного в
многочленном степени n, так что тут все как обычно.
А вот эта вот характеризация позволяет нам задавать
циклический код очень коротко, нам достаточно задать
один вектор и сказать, что циклический код получается
так.
Мы берем все циклические сдвиги этого вектора
и их суммы, суммируем по модулю 2.
Вот я написал вектор двоичной длины 15.
Если брать его циклические сдвиги, у нас будут получаться
скажем в начале три нуля, потом две единицы, два нуля
и единица, ну и оставшиеся тоже нули, то есть все такие
циклические сдвиги.
Берем и берем все возможные их суммы по модулю 2.
Вообще говоря, даже не очень понятно, сколько получится
векторов, то есть какова размерность, но это определить
сравнительно легко.
Более интересный вопрос, какое кодовое расстояние
у такого кода?
И вот это сложный вопрос, циклических кодов довольно
много и общего способа определить кодовое расстояние
удобно, вот как у нас допустим есть для размерности.
Размерность мы можем определить так, нам задан какой-то
многочлен, он конечно не обязательно делитель
x-vent и минус один, но давайте возьмем наибольший общий
делитель x-vent и минус один и порождающего многочлена,
это уже будет делитель x-vent и минус один, он будет порождать
тот же самый идеал, поэтому получится, что размерность
вот будет находиться по этой формуле, только здесь
надо уже будет использовать вот этот наибольший общий
делитель.
А с кодовым расстоянием все хуже, сложнее найти
и его в общем случае довольно трудно, но есть много интересных
примеров таких кодов, циклических, этот класс содержит много
интересных примеров, в том числе он содержит все
совершенные коды, я напомню, что совершенные коды, это
такие замечательные коды, которые задают разбиение
булева куба на хэминговые шары радиуса r, то есть они
не просто не пересекаются, а еще и каждая точка принадлежит
ровно одному шару.
Вот оказывается, что все совершенные коды циклические.
Начну я с кода хэминга, который был в прошлый раз, и мы посмотрим,
почему он циклический, так как я его определял в
прошлый раз, это совершенно непонятно.
Ну там мы знаем параметры, я сейчас начну с того, что
построю циклический код с такими же параметрами,
а потом объясню, почему он по сути дела совпадает
с кодом хэминга, с точностью до перестановки, я даже
порождающую матрицу, которая у меня была, все подгоню.
Ну вообще, когда говорят, что совпадает, имеется
в виду, что мы можем переставить строки из столбцы, потому
что это ни на что не влияет, в смысле кодового расстояния,
размерности.
Значит, как строится такой код?
Нам потребуется поле из 2 в степени s элемента.
Нам потребуется порождающие мультипликативные группы.
Тут вот надо вспоминать теорию конечных полей,
одна из самых первых теориям про конечные поля, что мультипликативная
группа циклическая.
Вот я беру порождающий и беру минимальный многочлен
для альфа, то есть это многочлен с коэффициентами в поле
из двух элементов.
По нашему определению, минимальный вам многочлен.
И вот нужный нам код, давайте его сейчас пока обозначу
как-то отлично, от кода Хемминга, чтобы было понятно, он как
раз порожден, аж, прошу прощения, аж, он как раз порожден этим
многочленом.
Ну, чтобы найти размерность, давайте вспомним, что многочлен
х в степени 2 в степени s минус 1 делится на, я напишу
сразу на аж, но что мы знаем про этот многочлен?
Ну, если мы еще домножим на х, мы получим наш стандартный
многочлен х в степени 2 в степени s минус x, и он делится
на все неприводимые многочлены, степень которых является
делителем s.
Ну, если мы на х сократили, то все кроме многочлена
х.
А минимальный многочлен неприводим, какая его степень?
Ну, поскольку мы знаем, что поле порожденное альфа,
а в данном случае, поскольку это порождающая мультипликативная
группа, это все наше поле из 2 степеней с элементов,
у нас есть замечательная лемма, о которой нужно помнить,
что оно изоморфно кольцу вычитов по модулю минимального
многочлена.
Ну, идеала порожденного минимального, значит степень,
мы знаем сколько элементов в кольце вычитов, их 2 в степени
степени многочлена, значит степень многочена обязательно
с.
Поэтому это делитель вот такого многочлена.
Ну и теперь размерность уже мы находим обычным
образом, вот по нашей общей лемме, она такая, как нужно.
Теперь нужно понять, кодовое расстояние, как я уже говорил,
это сложнее, но в данном случае это довольно легко.
Почему?
Посмотрите, пусть у нас есть какой-то элемент нашего
кода, это рассуждение мне понадобится и дальше, это
значит, что он кратная, ну с каким-то коэффициентом
h tilde, кратная нашего многочлена h.
Что это означает в кольце многочленов?
В кольце многочленов, это же равенство класса вычитов,
это значит, что разность этих двух многоченов отличается
на делитель x в степени n, поэтому в кольце многочленов
мы получаем такое равенство, ну плюс какой-то g от x на
x в степени n минус 1.
Что для меня существенно, существенно то, что если
я подставлю альфа в x, получится что?
Получится что h от альфы это 0, поскольку это минимальный
многочлен, но и альфа в степени n минус 1 это 0, потому что
альфа в степени n это единица, n это как раз 2 в степени
с минус 1, и вот из этого соображения, что раз у нас
порождающий идиала имеет корнем альфа, то и любое
кратное тоже будет иметь корнем альфа, для этого
нужно только чтобы альфа само по себе было корнем
вот этого вот многочлена, по которому мы берем вычеты.
Ну давайте смотреть, предположим у нас есть элемент веса 1,
это означает, что у нас есть какой-то вычет, содержащий
просто степень x, но из рассуждения, которое я написал выше,
следует, что тогда альфа в степень a равно 0, это вообще
невозможно, в поле нет делителей нуля, поэтому
никакая степень ненулевого элемента не может равняться
нулю.
Ну надо еще посмотреть на вес 2, то есть многочлен,
у которого две единицы среди коэффициентов, ну из вот
это и несложного утверждения, которое я написал, следует,
что альфа в степени i, плюс альфа в степени j должно
равняться нулю, ну давайте вынесем что-нибудь за скобку,
плюс и минус 1 в данном случае одно и то же, я напоминаю,
у нас характеристика 2, поэтому плюс 1 и минус 1 я
пишу скорее из соображений зрительного удобства.
И мы видим, что поскольку делителей нуля нет, это
не 0, значит вот это 0, то есть мы получаем, что альфа
в степени j минус i должно равняться единице, но это
означает, что j минус i должно быть кратно n, по-другому
не получится, потому что я напоминаю, это порождающая
мультипликативная группа, его порядок краю на n, для
этого мне и нужно было взять порождающий, ну а ij, нас же
интересуют только какие ij, которые не отрицательны
и строго меньше n, потому что у нас вот этот вот базис,
здесь мы берем i как раз от нуля до n, до степени
многощины, степени многощины уже не включаем, строго меньше
чем n, ну значит разность никак не может, если разность
кратна n, то отсюда следует, что i равняется j, именно
j должно равняться нулю, но тогда это просто 0, это
не то, что мы хотели, мы хотели все-таки, чтобы i не равнял
Таким образом, мы видим, что параметры
этого кода в точности такие же, как у кода Хемминга,
теперь я хочу объяснить, почему это на самом деле
код Хемминга и есть, ну это можно доказать более сложными
рассуждениями, что коды с такими параметрами все
вот эквивалентны относительно перестановок строк столцов,
но я этим не буду заниматься, а прямо для конкретного
такого представления объясню, что у нас получается в точности
та же порождающая матрица, что была, значит у нас как
устроен наш код, вот он, порождается он чем, h это делитель х степени
значит g порождается вот такими элементами, берем какую-нибудь
степень х и умножаем на h, и тут тогда g должно меняться
от нуля до ну до n минус степень h, а это я напомню как раз
два степени s минус один минус s, степень h равна s, ну давайте
посмотрим на этот многочлен, будем считать, что у h, ну тут
поскольку поле из двух элементов старше коэффициент райна
единица, давайте запишем вот это вот как я это назову
аж и запишу это так, х в степени s плюс g плюс ну какой-то
остаток, как-нибудь его обозначу, ну ладно пусть будет
ж ж, но смотрите нас же интересуют элементы в кольце класса
вычетов, поэтому ничего не изменится, если я возьму
здесь, ну даже не элементы в кольце класса вычета,
нас интересует кратный h, и вот если я запишу, разделю
вот этот многочлен с остатком на h, ну давайте какой-нибудь
с тильдой на h плюс rgt, то смотрите, если я потом возьму класс вычетов,
ну этот класс вычетов я хочу оставить отдельно, значит давайте
я теперь воспользуюсь магическими свойствами доски и запишу вторую
формулу на месте первой, плюс вот этот вот класс вычета, но
что-то мне не нравится, что у меня получается, секундочку
я хочу представить вот такой вот многочлен
хочу представить такой многочлен, как туму какой-то большой степени и многочлена степени
меньше s, ну для этого да, я должен конечно взять вот так, но что у меня получится,
у меня получится не совсем то, что я хотел, сейчас разберемся, вот это то, что я хотел и
еще у меня есть вот эта вот добавочка, ну да, ну да, значит тут надо как обычно базис поменять,
значит смотрите рассуждение такое, вот это будет точно базис в нашем коде, но я теперь хочу взять
другой базис, вот я взял соответствующий многочлен, представил его в таком виде,
а заметьте, что вот тут вот степень уже меньше, самую старшую степень я выделил, значит здесь
степень меньше, чем j и вот это вот будет представляться, то есть я хочу сказать,
что у меня базисом будет и вот такой набор векторов, когда я вот для многочленов этого
базиса заменяю, оставляю старшую степень, а все остальное беру по модулю h, почему, потому что
смотрите, вот эта вот добавка, она поскольку у нее степень меньше, она будет выражаться через
базисные векторы с меньшими значениями j, то есть матрица перехода от одного базиса к другому,
она будет просто треугольная, то есть начинаю я просто с обычного многочлена h, у него все правильно,
степень s старше, остальное меньше, чем s-1 и дальше, когда я беру следующую степень, у меня получается так,
что вот появляется новый базисный вектор плюс какая-то линейная комбинация предыдущих,
поэтому это тоже базис, степени вот тут существенно, степени вот этих вот многочленов,
они не превосходят s, ну и теперь давайте я этот базис, это базис, поэтому чтобы написать
порождающую матрицу, мне нужно записать коэффициенты многочлена, давайте я сейчас буду их писать вот в
этом направлении, право, нулевая степень и так вот будет увеличиваться, вот здесь будет
s-1 степень, вот тут будет st, ну и так далее. Посмотрите, какой я базис нашел, я нашел базис,
у которого вот эти вот старшие степени, начиная с st, они как раз образуют вот такую вот единичную
матрицу, а что написано здесь, а здесь написаны коэффициенты многочлена r житого от x,
если вот здесь вот s-1, многочлен имеет степень меньше, чем s, потому что я делю с остатком на
многочлен степени s, значит коэффициенты от 0 до s-1 нумируются, и что мы можем сказать,
во-первых, мы можем точно сказать, что они разные, вот представьте, что здесь и здесь написано было
бы одно и то же, тогда сложив эти два элемента кода, я бы получил кодовый вектор, в котором
всего две единицы, все что вот в этой правой части, все бы сократилось, если я беру два одинаковых
вектора, складываю их по модулю 2 и получаю 0, остаются только две единицы, но кодовое расстояние
я уже нашел, оно 3, поэтому такое невозможно, значит тут все разное, и более того, в каждой
такой строчке не меньше двух единиц, почему, ну потому что иначе бы опять у меня просто появилось
строчка где две единицы или меньше, что невозможно, как мы проверили, и мы получаем в точности порождающую
матрицу кода Хэминга, то есть я сейчас доказал, по сути дела, что мой код совпадает с кодом Хэминга,
вот такой вот анализ, вот это вот часть необязательна, можно было бы, код-то все равно получается
совершенный, это отдельная теорема, что все совершенные коды с кодовым расстоянием 3 одинаковые,
ну в смысле с одинаковой длиной, одинаковым кодовым расстоянием 3, и они имеют именно такое значение
параметра, но тем не менее тут можно вот просто и явно показать, видно, что на самом деле на эту
матрицу можно смотреть вот таким вот способом, это один из возможных базисов в нашем коде,
не тот, который у меня был с самого начала, немножко другой, давайте какой-нибудь пример возьмем,
давайте я, наверное, центральную доску сотру, ну вот у меня там вектор длиной 15, поэтому я хочу написать,
что n это 15, то есть 2 в четвертый минус 1, теперь мне нужно найти порождающие мультипликативные
группы поля из 16 элементов, я не помню делал я это или нет, но многочлен х четвертый плюс х плюс
один, это минимальный многочлен, можно взять порождающий с таким минимальным многочленом,
действительно смотрите, раз он минимальный многочлен, значит альфа в четвертой плюс альфа плюс
один равняется нулю, альфа в кубе, я хочу проверить, что порядок альфа 15 мультипликативной группе
этого поля, для этого мне достаточно проверить, что альфа в кубе не равно 1, альфа в пятой не
равно 1, помните вот этот трюк, который я уже несколько раз использовал, когда мы про группы
говорили, я хочу убедиться, что порядок некоторого элемента n, для этого я должен взять простые
делители n, на каждый простой делитель поделить и убедиться, что соответствующая степень не 1, альфа
в кубе не равно 1, просто потому что мы знаем, что все линейные комбинации степеней меньше 4,
все различные, теперь с альфа в пятой, тут конечно сложнее, потому что степень уже больше четырех,
но на самом деле тоже не очень сложно, потому что это альфа умножить на альфа в четвертой,
то есть это альфа в квадрате плюс альфа, потому что альфа в четвертой это альфа плюс один,
я напомню, что плюс и минус один у меня сейчас одинаковые, и это тоже не равно единице,
значит действительно порождающая мультипликативная группа, ну смотрим, что нам еще нужно, все, значит код
порожденный вот таким вот многочленом даст нам код Хэминга длины 15, давай теперь посмотрим на
вот этот магический вектор, который я написал, я внизу припишу степени 0, 1, 2, 3, 4, ну и так далее,
мы видим, что это в точности вектор коэффициентов этого многочлена, поэтому мы знаем, во-первых,
что всего у нас получится 2 в 15 минус 4, то есть 2 в 11 разных сумм циклических сдвигов этого вектора,
и в каждом ни нулевом ни нулевой, хотя бы три единицы, глядя на такой вектор, это не очень легко понять
сходу, ну то есть понятно, что можно взять циклические суммы, найти размерность линейной оболочки,
но дальше надо как-то перебирать, чтобы убедиться, что все единицы такие, но вот поскольку мы взяли этот
вектор совершенно не случайно, вытащили его из конечных полей, то и свойств всей этой конструкции
все сразу следует, ничего проверять не нужно, уже все готово, таким образом мы видим, что код Хэминга
циклический, и более того, вот эта вот конструкция, я напомню, что код Хэминга он исправляет, поскольку
у него кода в расстоянии 3, он исправляет одну ошибку, но хочется исправлять больше ошибок,
при вот таком вот задании кода Хэминга, совершенно непонятно, как это обобщить, чтобы получить код,
который исправляет больше ошибок, а вот эта вот конструкция позволяет построить коды, которые
исправляют R ошибок, и тоже достаточно хороши, вот это следующий шаг, который я хочу сделать,
я буду, поскольку конструкция во многом повторяется, я буду так постепенно стирать,
это называется коды БЧХ, БЧХ по именам Боуз, Чаат Хури и Хокенгима,
обычно ссылаются именно на этих людей, значит, в литературе они первыми записали, мы хотим
исправлять R ошибок, то есть кодовое расстояние мы хотим, чтобы было не меньше, чем 2R плюс 1,
это мы в прошлый раз обсуждали, для исправления R ошибок нам нужно кодовое расстояние не меньше,
какая размерность я пока писать не буду, а длина будет той же, дальше мы делаем вот что,
я по-прежнему беру порождающие мультипликативные группы, но ищу теперь многочлен,
среди корней которого есть не только альфа, но и альфа квадрат, и альфа куб, и так до
все первые 2R степеней, и вот нужный нам код циклический порождается таким значением,
в случае кода хэминга у нас была всего одна, всего одно условие нас интересовал,
ну минимальным на чем нас интересовал, на самом деле вы можете заметить, что в моем доказательстве
минимальность этого многочлена была не так существенна, там в некоторых местах она была нужна,
но ее можно обойти, но чем меньше степень многочлена, тем больше размерность, поэтому
минимальный многочлен мы хотим взять для того, чтобы размерность была как можно больше,
тогда у нас получается совершенный код, но в случае произвольного количества ошибок R
совершенный код уже не получится, мы сейчас посмотрим насколько он хорош, но давайте для
начала поймем, что такое построить можно, это на самом деле не очень сложно, смотрите что я делаю,
я этот многочлен определяю так, я беру минимальный многочлен для альфа, минимальный многочлен для
альфа в кубе и так далее, минимальный многочлен для альфа в степени 2R-1, просто по построению мы видим,
что альфа в нечетной степени вплоть до 2R-1 является корнем этого многочлена, а что делать с альфа в
четной степени, а тут надо вспомнить про ауто-морфизм фробениуса, если у нас альфа в степени 2 и является
корнем этого многочлена, альфа в степени и тоже является корнем, поэтому если я беру какую-то
четную степень, деля показатель степени пополам, я рано или поздно приду к какому-то нечетному числу,
а все нечетные числа уже корни, поэтому это тоже будет корень, то есть вот такая вот конструкция,
она неоднозначно, потому что выбирать эти многочлены можно по-разному, более того,
мы можем немножко улучшать, ведь у нас может так случиться, что в одну орбиту фробениусы попадают
и какие-то нечетные числа, ну это при каких-то РН возможно, ну в общем, такое возможно, то есть
конструкция неоднозначно, но тем не менее, я вот буду это называть кодом БЧХ, их много разных,
но что для меня существенно, что я могу теперь оценить размерность этого кода довольно легко,
почему, потому что степень каждого такого многочлена не превосходит S,
всего я взял R множители, значит, степень F не превосходит R множить на S, ну тогда размерность
по общей лемме, раз степень не превосходит, то размерность не меньше, чем N минус R множить
на S, вот мы получили размерность, ну и теперь самая интересная часть, нужно как-то объяснить,
почему кодовое расстояние достаточно большое.
Вот это утверждение о том, что кодовое расстояние БЧХ кода не меньше, чем 2R плюс 1,
я буду доказывать отпротивно. Я предположу, что у меня есть вектор небольшого веса L,
то есть сумма L мономов, у меня векторы же имеют очень простые координаты 0, 1, это у нас все над
полем из двух элементов, и L не превосходит 2R. Я предполагаю, что такое есть, сейчас я приду к
противоречию. Смотрите, давайте я как-нибудь вот этот многочлен через G обозначу, и вот здесь
напишу выкладку, у которой у меня уже была, я ее стер. Значит, мы знаем, что это вычеты,
содержащие многочлен G, принадлежат нашему коду, наш код это идеал, порожденный многочленом F,
поэтому с точностью до кратного многочлена х в степени n минус 1, мы имеем такое равенство в
кольце многочленов. Вычет кратный вычет у F, а это означает, что разность равна 0 в нашем кольце,
разность равна 0, означает, что кратно значено х в степени n минус 1. Ну и тогда мы видим,
что раз F от альфа в степени равно 0 при i под единицей до 2R, мы видим, что G от альфа в степени
также равно 0 при тех же значениях i. Потому что смотрите, если я подставляю в значенных
степени n минус 1, любая степень альфа, она еще возведется в степень n, это будет на единице,
просто потому что n порядок мультипликативной группы. Здесь точно будет 0, а здесь 0 вот по нашему
строю. Значит, мы получаем такой набор равенств. Это я подставил в многочлен просто в степени
альфа. Дальше я могу подставить квадрат. Дальше я могу подставить какую-то степень G. Ну ладно,
пусть будет i, у меня уже i появилось, пусть будет i. Ну тут много каких-то строчек. Ну и это все
продолжается вплоть до альфа в степени l. Тут у меня равенство выполняется до 2R, но я сейчас
предполагаю, что l не превосходит чем 2R и выпишу только l равенства. Вот это мы из построения кода
получили такие равенства. Ну давайте теперь их изучать. Давайте представим себе такую матрицу,
где-нибудь здесь я ее напишу. Составленную ровно из этих элементов. Здесь у меня будет альфа
в степени i, а в степени aj. Вот такая матрица. Давайте я не знаю, а обозначу, это не очень важно,
как я ее обозначу. Что мне дают вот эти l равенства? Эти l равенства говорят мне, что стумма столбцов
а равна нулю. О, а у меня подошло время перерыва. Ну хорошо, значит, это тоже удачное место, потому что в
этот момент вам все равно надо напрячься, вспомнить линейный алгебр. Если сумма столбцов равна нулю,
то мы что-то можем сказать и про сумму строк, правда? Давайте сейчас сделаем перерыв, после перерыва это
обсудим. Ну давайте, наверное, продолжим. Кто-то, по-моему, еще не вернулся с перерыва, но я начну...
Ну, не то чтобы, а вот я их слышу. Давайте я просто повторю, на чем я остановился. Это очень важный
момент. Вот эти равенства мы получили, фактически, из определения кода БЧХ. Теперь, если смотреть на эту
матрицу, что эти равенства означают? Ну, действительно, если я возьму столбцы этой матрицы и сложу, то первая
сумма – это сумма первых элементов столбца, вторая сумма – сумма вторых элементов столбца. Мы видим, что это все до 0.
Это означает, что матрица вырожденная. У нас есть линейная комбинация столбцов, которая равна нулю.
Нетривиальная линейная комбинация, не все коэффициенты равны нулю. Но вы знаете из линейной алгебры и
доказательства переносятся на векторное пространство над любым полем буквально, теорему о том, что строчный
ранг равен столбцовому. Если у вас есть нетривиальная линейная комбинация столбцов равная нулю, у вас
обязана быть нетривиальная линейная комбинация строк тоже равная нулю. То есть, теперь я уже буду
складывать вот так, выбирая какие-то множители. Ну, давайте мне их сейчас будет удобнее обозначить
лямбда 0, лямбда L-1. Это множители, конечно, из поля из 2 степени S элементов. Эти же равенства в этом
поле написаны. И что будет выполняться? Ну, давайте смотреть. Значит, у меня получится 0. Значит,
если здесь у меня, как я индексировал, ну, это пусть будет G. Да, вот G у меня так и индексировано,
все правильно. То есть, я должен буду сложить, и вот я нумирую от 0 до L-1, мне так удобнее. Я должен
буду сложить, чтобы, если у меня житый столбец, то у меня альфа в степени i плюс 1. Смотрите,
тут же, ведь я начинаю нумерацию с нуля, но у меня степени-то идут от единицы, поэтому тут надо
не забыть вот этот сдвиг на единицу в степени а житое, но с вот этими коэффициентами лямбда иt.
И вот это должно равняться нулю. Пои сумма для любого ж, которая от единицы до L. Но я эту сумму
могу немножко переписать. Смотрите, во-первых, у меня появляется в каждом слагаемом общий
множитель альфа в степени а житое. Я его вынесу за скобку. А в сумме я переставлю. Смотрите,
тут у меня написано, что альфа в степени i, потом еще возводится в степень а житое. Но это то
же самое, что альфа возвести степень i умножить на а житое, что в свою очередь то же самое,
что в начале альфа возвести степень а житое, а потом степень i. То есть получается,
что у нас вот такое выражение равно нулю. А что это вообще за выражение? А это вот что такое. Это
значит, что у нас многочлен. У меня уже для многочленов использованы все буквы,
какие только можно. Ну пусть будет p. p от x, вот такой многочлен, степень его не превосходит l.
l-1, строго меньше l. И вот это равенство означает, что этот многочлен обращается в ноль в каждой
степени а под первой дуэльтой. Вот что означает это равенство. Но смотрите, что у нас получилось.
Мы построили многочлен, исходя из общей теоремы линейной алгебры о том,
что строчность равенства в целом, мы построили многочлен, у которого степень строго меньше l,
но l корней. Так не бывает. Мы знаем, что количество корней у ненулевого многочлена не превосходит
многочлен. Должен быть ненулевой, потому что эти коэффициенты, должна быть нетривиальная
линейная комбинация, обращающаяся в ноль. Ненулевой многочлен имеет корней не больше, чем его степень.
Значит, мы пришли к противоречию. Я напомню, что доказательство противного, то есть я предположил,
что вот такой многочлен входит в наш код. И пришел к противоречию, выяснилось, что это
неминуемое влечество для некоторого многочлена степени не выше, чем l-1, есть l корней, что противоречит
друг другу эти два условия. Вот таким образом доказана вот эта теория. Как видите, здесь анализ
существенно сложнее, чем в случае кода Хемлинга. Нам уже нужна какая-то нетривиальная линейная алгебра,
что-то такое нужно делать. Можно было бы, кстати, по-другому рассуждать. В нашем учебнике так написано
тоже. Посмотреть на эту матрицу, увидеть, что это матрица Вандермонда, записать ее определитель и
свести, по сути дела, вопрос к тому же, что было в случае кода Хемлинга. Там, если вы помните,
как при директоре Вандермонда записываются там разности соответствующих элементов, и у нас
получится, что так же, как в случае кода Хемлинга, какие-то две разности, которые меньше, чем n равны,
это противоречит тому, что альфа порождающий. Вот такое рассуждение. Давайте опять-таки,
вот тут у меня был выписан пример для код Хемлинга. Давайте теперь возьмем r равное 2, n возьмем
то же самое, чтобы почисления были попроще. И попробуем построить код БЧХ. Теперь мне нужно
больше. Мне нужно, я напомню, многочлен, который обращается в ноль в альфа в квадрат, в альфа в
кубе, в альфа в четвертый. Ну, давайте начнем вот с того, что у нас уже есть, и увидим, что три корня
вот этот вот многочлен покрывает. Потому что корнями этого многочлена будут альфа, потом в силу
афтаморфизма, фрабениуса и альфа в квадрат, и альфа в четвертый. Но для альфа в кубе нужен
другой многочлен. Я уже разбирался с тем, какой там должен быть многочлен, сейчас коротко напомню.
Альфа в кубе, возведенный в пятую степень, равен единице, потому что порядок мультипликотинная
группа 15. Поэтому я могу записать это так, как альфа в кубе минус один. Альфа в кубе минус
один не равно нулю, а дальше написать сумму. То есть нам нужен еще вот этот у нас многочлен,
и еще один многочлен, который состоит из, ну, все коэффициенты, который у нас в степени четыре, у
которого все коэффициенты на единиц. Вот теперь мне надо перемножить эти два многочлена. Перемножать
многочлены как-то всегда удобнее, записывая их в другом порядке. Я хочу это умножить на единицу
плюс х плюс х четверть. Ну давайте. Для этого, значит, вот это я умножил на единицу. Если умножу
на х, у меня получится вот такой многочлен. Если умножу на х четвертый, у меня получится такой
многочлен х четвертый плюс х пятый плюс х шестой плюс х седьмой плюс х восьмой. И теперь только
осталось сложить по модулю два эти коэффициенты. Значит, что у меня получится? У меня получится
единица, х плюс х ноль, х квадрат плюс х квадрат ноль, х куб плюс х куб ноль, 3х четвертый даст нам х четвертый,
это нечет. Количество х пятый опять-таки даст ноль, а х шестой, х седьмой, х восьмой останутся. Вот,
то есть нужный нам код порождается классом вычетов, содержащих вот такой многочлен. То есть,
если записывать опять-таки порождающую строчку, она будет выглядеть так. Она будет выглядеть один,
дальше три нуля, первая, вторая, третья степень, дальше четвертая степень единица, пятая степень ноль,
шестая, седьмая и восьмая степень единицы, ну и дальше девятая, десятая, одиннадцатая,
двенадцатая, тринадцатая, четырнадцатая, пятьнадцатая. Вот если я возьму такую строчку,
ну в ней уже, как вы видите, пять единиц. Если я возьму суммы циклических сдвигов этой строчки,
то у меня получится сколько? Два в пятнадцатой минус степень многочлена в восемь, то есть два в
седьмой, то двадцать восемь разных векторов. То есть, вот, заметьте, здесь гораздо больше,
здесь уже существенно меньше. Но зато каждый из этих ста двадцати семи векторов, кроме нулевого,
имеет не меньше пяти единиц. Ну, вот выдумать такую строчку из головы достаточно сложно. Я не знаю,
достигал ли кто-то такого по степени просветления. Иногда на занятиях у меня студенты находят
неожиданные решения алгебрических значений, то есть, действительно догадываются до каких-то очень
нетривиальных равенств. Но вот это я даже никогда не пробовал. Ну, понятно, что это в рамках
семинара и невозможно, но так, чтобы человек просто посидел, подумал и придумал, какими циклическими
сдвигами получить код с кодовым расстоянием 5, я не знаю. Вы тоже теперь испорчены, потому что я вам
рассказал науку, как получается такая строка. То есть, это надо взять человека девственного,
который вот, ну, что-то про линейный алгебр, хотя бы знать, чтобы было понятно, что такое сумма по
модулю два этих векторов, что такое циклические сдвиги, но который вот не изучал конечные поля.
Это не так легко таких людей найти. Но, в общем, я не знаю и думаю, что это действительно очень
трудно, потому что догадаться, ну, как, ну, посмотрите, какая-то совершенно идиотская, никакой особой
симметрии в этом нет. Наверное, у кода БЧХ есть более симметричные порождающие. Я сейчас чуть-чуть
это прокомментирую про другой код, но не очень понятно, как их искать. Но, тем не менее, вот такой
вот пример есть. То есть, мы получаем один из кодов БЧХ. Теперь следующий вопрос, который я
хотел бы обсудить, это насколько вообще коды БЧХ хорошие? Что я имею в виду? Ну, мы знаем две
оценки. Верхняя оценка Хэминга, вот код Хэминга вообще замечательный, он просто сажается на верхнюю
оценку, он совершенный. А что с кодами БЧХ? Давайте я для простоты записи на доске пропускал индексы,
давайте я теперь напишу у меня два параметра, которые задают этот код. Ну, длина, это 2 в степени
s-1 и r количество ошибок. Вот я написал s и r. Мы знаем, что в коде не меньше векторов, чем 2 в степени
размерности. И мы знаем, что не больше, чем 2 в степени n поделить на объем хэмингового шара
равномерного радиуса r. Это граница Хэминга, больше не бывает. Вот давайте сравним, то есть по
спасуте дела, насколько код БЧХ хорош. Это определяется отношением двух величин. Почему? Вот тут
давайте вспомним, нас интересует передача информации. Если у нас 2 в степени k кодовых слов,
мы можем передавать k битов. Поэтому резонно считать все-таки не размер кода, а логарифм
размера кода. Как бы будет количество битов, сколько мы теряем в передаче информации. Поэтому
нужно взять просто отношение этих двух оценок, ну и взять его логарифм. Отношение этих оценок
какое? Смотрите, 2 в степени n, 2 в степени n сократится. Останется, если я поделю вот это вот на это,
получится 2 в степени rс поделить вот на объем шара. 2 в степени s это n плюс 1 в степени r. А объем
шара, вот давайте посмотрим вот в такой симпатической постановке. Длина кода стремится к бесконечности,
а количество ошибок просто фиксировано, какая-то константа. Тогда как у нас будет
определяться объем мерного шара? Ну на самом деле с точностью до, ну он асимпатически должен
быть вот таким. Почему? Потому что сумма биномиальных коэффициентов, это самый большой биномиальный
коэффициент. Самая большая степень n, которая может быть в биномиальном коэффициенте. У нас биномиальные
коэффициенты берутся из n по i, где i до r. То есть в биномиальном коэффициенте из n по r у нас будет
степень n степени r, ну делить на, ну там не n, прям буквально степени r, поэтому я тут пишу не строгое
равенство некоторую асимптотику, но асимптотически это вот примерно столько же. Значит тут получится n
степени r, а тут еще получится r factorial. И что мы видим? Что это, если r константа, это очень
хорошая вещь. Это o от единицы. То есть мы теряем, по сравнению с идеальной ситуацией, мы теряем
константу битов. Нам же нужно взять потом логарифм этой величины, это и будет количество лишних битов,
по сравнению с оценкой Хэминга, которую мы используем в коде BCH. Ну и если r константа, то вообще все
замечательно. Мы теряем некоторую константу битов. Такие коды называются квазисовершенными,
насколько я знаю их классификация как раз полностью неизвестна. Ну и тут определение уже более
сложное. Мы должны брать серии кодов, когда для нас стремится к бесконечности. В общем, это такое менее
формализуемое понятие, но слово такое используется. И это объясняет, почему коды BCH, их изобрели
практически сразу, как возникли задачи теории кодирования, вот исправление ошибок. Их изобрели
очень быстро, потому что инженеры нашли правильных математиков, которые вот все это знали и сделали
соответствующие выводы. Для тогдашней математики, кстати, нельзя сказать, что это была очень модная
тематика, конечные поля и все такое. То есть сама теория уже была, но она скорее была в стороне. Она
стала очень популярной с развитием теоретической информатики. А до этого, ну да, вот были, да не
только с развитием теоретической информатики, с тем, что в конце 50-х годов был такой великий
математик Гротендик, он поставил перед математиками еще амбициозную цель – объединить анализ и
арифметику. То есть развить все теоремы, которые есть в теории чисел, все теоремы в анализе,
чтобы это были частные случаи некоторых общих теорем. Поэтому математики стали очень интересоваться
конечной характеристикой. Она, естественно, связана с теорией чисел. Ну, мы уже видели много связей.
И вот с этого момента конечная характеристика стала очень важна. А коды появились раньше. Ну, я точно
историю математики не знаю, может быть, уже к этому времени многие понимали, что конечная
характеристика важна. Так статей было не очень много, по крайней мере. Ну, и это, конечно,
инженеров очень устраивало, потому что я про это говорить уже точно не буду, но для кодов БЧХ есть
и хорошие алгоритмы декодирования. Кодировать циклический код вообще инженерам было довольно
легко, потому что в сущности вот эти вот циклические сдвиги — это довольно простая
электрическая схема, которая их осуществляет. И сложение по модулю 2 достаточно легко
реализуется. Поэтому инженеры были страшно счастливы, что есть такие хорошие коды.
Составляются таблицы оптимальных кодов при конкретных значениях длин кодовых расстояний
и размерности. И коды БЧХ в некоторых случаях просто оптимальные. Лучше не бывает. Но таких
случаев мало. И где коды БЧХ совсем плохи — это в том случае, когда мы хотим исправлять очень много
ошибок. Более естественная ситуация — это же мы блочное кодирование рассматриваем — состоит
в том, что оно вообще очень большое. Это прям все наше сообщение. И у нас есть какая-то фиксированная
доля ошибок. То есть канал, он ошибается в одном проценте случаев или в одном тысячный
проценте случаев с какой-то частотой. И тогда нам нужно исправлять уже ошибок не константное
количество, а пропорциональное длине передаваемого сообщения. И вот тут мы видим, что коды БЧХ
становятся бесконечно плохими, потому что эрофакториал вот этот, он все портит. Тем не менее,
такие, как говорят, асимпатически хорошие коды существуют. Они строятся на основе совсем другой
алгебры. В основном там нужна скорее нетривиальная линейная алгебра и связанные с ней вещи. Но в
некоторых ситуациях бывают нужны действительно и поля. Хотя там конечные поля используются
скорее уже в более экзотических конструкциях. Не напрямую в конструкциях асимпатически
оптимальных кодов, а в более сложных ситуациях. Про которые я говорить не буду. Но ситуации
типовые, о которых я говорил, что мы из вероятностных соображений знаем, что какой-то комбинаторный
объект есть, мы хотим его построить. До сих пор есть такие объекты, про которые мы знаем,
что они существуют, но удобных явных конструкций у нас нет. Но вот близкие к этим конструкциям
рекордные результаты, они тоже получаются с помощью полей. Причем там, вот чего мы здесь не
использовали, это структуры подполей в конечных полях. На самом деле в теоретической информатике
есть и такие задачи, где и это бывает важно. Вот в частности для этих более сложного обобщения
корректирующих кодов, которые называются экстракторы. Это такая неформально очень интересная задача.
У вас есть источник случайных битов, но плохой. Он дает неравномерную случайность, а какую-то
искаженную. А вы хотите сделать следующее. Хотите подлить к нему немного настоящую случайность.
Но совсем мало. У вас где-то есть очень надежный источник действительно равномерных независимых
случайных битов. И вы хотите как можно меньше당 источника использовать. Он дорогой. А вот этот
грязный источник он дешевый. Вот вы хотите смешать немножко чистой случайности с нечистой, с тем,
чтобы результат был очень близок к чистой случайности.
Это называется экстрактор.
И вот для экстракторов там есть разные конструкции.
Те, которые получаются, они конечные поля не используют,
но в некоторых ситуациях там действительно тоже
бывают нужны конечные поля.
В общем, это заведомо я не успею оставшееся время
рассказать.
Ну, так просто, чтобы вы имели в виду.
Что я хотел сказать по поводу конечных полей, что они действительно
используются самыми разными целями.
Много примеров мне привести не удаётся.
Давайте я приведу один пример, который, по-моему,
даже есть в сборнике задач, которые вам выдан.
Я не уверен, но, по-моему, есть.
Он короткий, я его сейчас быстро приведу.
Допустим, мы хотим найти в группе перестановок
9 элементов по группе 72 элементов.
Ну, вот захотелось бы.
Вам, может быть, и не захотелось, но от вас этого требует
задавальник.
Откуда её взять?
Ну, мы помним, там возникают проблемы, одних арифметических
условий недостаточно.
Конечно, 72 это 8 на 9, и это делитель 9 факториалов.
То есть, противоречия стеоремы Л.
Э.
Гранжа нет.
Но мы знаем, что не для любого порядка есть соответствующая
подгруппа.
Откуда взять эту подгруппу?
Заранее непонятно.
Ну, вот смотрите, что я делаю.
Я вижу, что 9 – это степень простого.
То есть, это 3 в квадрате умножить на 3 в квадрате
минус 1.
Ага, говорю я.
Так, может быть, это что-то, связанное с конечным полем
из 9 элементов.
Ну, хорошо.
А что же может быть связано, какая группа может быть
связана с перестановки этого поля из 9 элементов?
Ну, и такое перестановки.
Ну, давайте что-нибудь самое простое сделаем.
Ну, у нас есть самые простые биоктивные преобразования
поля.
Линейные функции.
То есть, я беру не нулевое а, и беру вот такую линейную
функцию.
Она обратима, потому что раз а не равно нулю, мы можем
написать обратную функцию.
Там коэффициент будет единиц на а.
Значит, это и, что существенно, композиции линейных функций,
они тоже линейные.
Если я сюда подставлю линейную функцию, то у меня получится
линейная функция.
Значит, это действительно получается перестановки.
А сколько их будет?
Ну, вот коэффициентов 8, свободных членов 9.
Ну, а можно еще, ну, давайте я не буду, там скажем, группы
перестановок из 10 элементов, можно уж совсем большую под
группу найти, нетривиальную, которую так сразу не построишь.
Но давайте я отвлекаться не буду, потому что я хотел
бы полностью мне это рассказать, все равно я не успеваю, я
уже прикинул.
Но я упоминал, что есть еще один совершенный код, кроме
кодов Хемминга, и он тоже циклический.
То есть не случайно я так переоточился на циклических
кодах, это так называемый код Галлея.
У него параметры такие, длина 23, размерность 12 и кодовое
расстояние 7.
То есть он исправляет три ошибки.
И он совершенный.
То, что он совершенный, это, по сути дела, означает,
вот что, что размерность 12, это значит, что 2 в 12 равно,
ну вот объем у Хемминга, 2 в 11, извините, на границе
Хемминга вот так вот записывается, то есть если я поделю, у меня
2 в 11 равно вот этому вот самому объему шара, то есть единица
плюс биномиальная коэффициента 23 на 1, 23 на 2, плюс 23 на 3.
Ну, это равенство, как вы понимаете, по каким-то
довольно мистическим причинам возникает.
Ну, что это такое?
На самом деле, если чуть-чуть упростить, это получится
1 плюс 23 умножить на 89, и это действительно чудесным
образом ровняется 2048, но никаких внятных причин,
почему такое равенство берется, у нас нет.
Вот просто случайно появилось такое рифметическое равенство.
И на самом деле, то, что совершенных кодов мало,
это как раз из-за того, что для совершенного кода
нам нужно вот такого типа соотношения между параметрами,
чтобы сумма начальных биномиальных коэффициентов
ровнялась к какой-то степени двойки.
Это довольно редкое явление.
То есть у нас есть коды Хэминга, но там понятно, почему,
потому что у нас радиус единицы, вот здесь вот совсем
простое число написано.
Если мы берем уже две ошибки, у нас будет здесь
какой-то нетривиальный биномиальный коэффициент,
и уже подобрать довольно сложно.
Ну, и оказывается, что невозможно.
В общем, это целое дело, я вдаваться в это не буду.
Тем не менее, код Галлея существует.
Как его определить?
Ну, это я точно успею сделать.
Он циклический, поэтому, чтобы его задать, мне нужны
коэффициенты многочлены, я пока напишу показатель
степеней.
Значит, у нас n равно 23, значит, мне нужны вычеты по модулю
х23-1, значит, мне нужны коэффициенты до 22.
Ну, давайте, сейчас я попробую выписать эти коэффициенты.
Ноль, один, один, один, один, один, один, один, кто-нибудь
догадался, в каких местах я ставлю единицы?
Квадраты, да.
Я, на самом деле, отмечаю единицами квадратичные
вычеты по модулю 23.
Ну, теперь, после того, как я признался, и мы видим,
что двойка квадратичный вычет, и она же автоморфизма
Фрабениуса, поэтому дело можно быстрее провести.
Можно просто умножать на двойку, это квадратичный
вычет.
Значит, 1, 4, 8, что мне не хватает?
Тройку надо как-то получить.
А, ну это 13 на 2, это 26, значит, теперь шестерка отсюда
сразу возьмется, 12 отсюда возьмется, 4, 8, 6, 12, 16 на 2,
32, то есть, 9 уже есть, 18 на 2, 36, 13 есть, а сколько
у меня?
4, 7, а, так уже все, смотрите, 4, 7, 10, 11.
Мы знаем, что вычитав и не вычитав поровну, я уже
11 нашел, все, хватит.
То есть, вот появляется такая волшебная строчка, длины
23, и я утверждаю, что если брать циклические сдвиги
этой строчки и их суммы по модулю 2, то у меня получится
4096 различных сумм, и в каждой такой ненулевой сумме будет
хотя бы 7 единиц.
Ну вот, как это понять, непонятно, причем, заметьте, тут уже
ясно, что я в качестве порождающего, давайте этот многочлен
с такими коэффициентами обозначу Q от X, ну, более
обычным способом его можно представить вот так, Q23,
это квадротичные вычеты по модулю 23, ну, M23, давайте
я сразу определю, это квадротичные не вычеты, но вот такой
простой способ, немонический, который позволяет запомнить,
как вообще строить код Галлея, потому что сообразить
про квадротичные вычеты легко, значит, код Галлея
это точности циклический код, порожденный классом
вычетов, содержащих вот этот многочлен Q, но сразу
вычислить размерность трудно, потому что, вот смотрите,
тут нужно быть аккуратным, потому что размерность,
вот эта формула требует, чтобы порождающий многочлен
был делителем X в НТ без единиц, а это, конечно, не так
для этого многочленов, ну, может быть, это не столь
очевидно, но давайте вообще поймем, какие у нас неприводимые
делители у многочлена X23-1, ну, я обсуждал, как с помощью
автоморфизма Фробениуса находить неприводимые делители
у такого многочлена, надо просто построить орбиты
Фробениуса, они будут отвечать корням неприводимых многочленов,
и у нас получается одна орбита отвечает показателю
0, это вот это, а дальше есть орбита длины 11, которая
отвечает квадратичным вычетам, двое как квадратичный
вычет, если я умножаю на два, то я снова получаю квадратичный
вычет, и 2 в 11 равно, раз это квадратичный вычет, то
равно 1 по модулю 23, но 11 простое число, поэтому в меньших
степенях мы будем получать не единицу, значит, у нас
здесь будет орбита длины 11, ну, а не вычетая это все
остальное, ну, скажем, вот с X5 что ли, начиная, я бы
даже начал с X22, которая X-1. Заметьте, что X-1 в нашем
кольце это то же самое, что X22, а минус единица это
квадратичный вычет, потому что минус единица в 11 степени
это минус единица, значит, у нас получается вот такое
разложение на неприводимые множества, и мы знаем, что
наш многочлен, раз он задает какой-то нетривиальный код,
он должен иметь нетривиальный наибольший общий делитель
с этим, ну, с каким? Так заранее не ясно. Тут нужно некоторое
вычисление. Давайте найдем в каком-нибудь поле характеристики
2 корень 23 степени из единиц, то есть такой элемент поля,
который порождает циклическую группу порядка 23. И подставим
в наш многочлен. И даже не просто подставим в наш многочлен,
сразу заведем в квадрат. Смотрите, что я делаю. Я
развожу квадрат, но у меня в полях характеристики
два возведения в квадрат. Это применение автоморфизма
фробениуса, то есть это сумма слагаемых возведенных
квадрат. Но два – квадратичный вычет, поэтому если я и умножаю
на 2, я получаю снова квадратичный вычет. Мы просто такой сдвиг
в подгруппе квадратичных вычетов делаем. Значит,
мы получаем равенство. Q от ω в квадрате равняется
Q от ω. Но отсюда следует, что Q от ω – это элемент
поля из двух элементов. Вспомним, что если какое-то
число x в степени p равняется x, то это означает, что оно
в каком-то конечном поле, это означает характеристики
p. Это означает, что оно просто принадлежит простому
подполю. Значит, Q от ω – это 0 или 1. Теперь я могу проделать
то же самое с ω в минус 1. Тут будет минус 2 и поскольку
у нас минус, то это мы получаем сдвиги вдоль квадратичных
вычетов. В общем, будет вот такое вот разница. А с другой
стороны, вот это равно 0, ω – 1 – 0 не равно, значит,
мы получаем, что сумма вот такой геометрической
прогрессии должна равняться 0. Но из чего она состоит?
Она состоит из единицы плюс значения в ω, плюс значения
в ω минус 1. То есть я беру сумму по квадратичным вычетам
в степени ω и сумму по квадратичным невычетам
в степени ω. То есть мы видим, что не просто что эти два
числа принадлежат полю из двух элементов, а они должны
быть разными. Потому что если мы к ним, к их сумме
еще добавим единицу, мы должны получить 0. Значит,
к их сумме они должны давать единицу. И у нас есть два
выбора – считать, что вот это равно 0, а то равно единице,
или наоборот считать, что это равно единице, а то
равно 0. И, как я уже говорил, тут полная асимметрия. Если
ω заменю на ω минус 1, то у меня все равно будет порождать
ту же самую циклическую группу. Поэтому ничего не изменится.
Поэтому без ограничения общности можно считать,
что q от ω равно 0. Ну и тогда смотрите, q от ω равно 0, и у нас
вот есть два этих множителя. Один из них будет равен
0, другой не будет равен 0.
Потому что q, конечно, не является вот такой суммой гиметрической
праведности. Мы получаем, что тот же самый код Галлея
порождается вот этим вот в многочленом степени 11.
Раз он порождается в многочленом степени 11, его размерность
23 минус 11, как раз 12. Ну и начинается самое интересное.
Но наступает утро, шахеризация прекращает дозволенные
речи. То есть кодовое расстояние. Я не объяснил, почему кодовое
расстояние 7. Это, конечно, самое интересное. Ну вы можете
посмотреть в нашей книжке, лучше в файле, который выложен
на странице кафедры и на странице курса, то, что
называется расширенная версия учебника. Там приводится
достаточно элементарный анализ, который дает вот
это кодовое расстояние 7. Поскольку у меня осталось
буквально минуты, я скажу, что на самом деле правильный
анализ другой. Нужно из этого кода сделать код длины
24 той же самой размерности, но с кодовым расстоянием
8. Это делается очень просто. Нужно добавить к каждой
кодовой нашей строчки еще проверку на четность.
Вот тут у нас 11 единиц, значит, мы должны в дополнительной
позиции, которая бесконечности обычно обозначается, поставить
единицу. А если будет четное число единиц, поставить
0. И получим код, у которого кодовое расстояние в 8. Более
того, там веса всех кодовых слов, они кратны 8, 8, 16 или
0. И это можно доказать гораздо более интересным способом,
чем тот, который я написал, элементарный. Но у нас совершенно
нет времени, там надо и дробно-линейное преобразование
вначале изучить, вообще понять. То есть там действительно
существенно, что у нас есть не просто поле из 23 элементов,
а есть вот поле из 23 элементов плюс бесконечность. И вот
на нем действует дробно-линейное преобразование. Вот этот
код, который я приводил, тут линейное преобразование.
Если написать разность двух линейных функций, то
она, знаменатель может обращаться в ноль, поэтому она может
что-то отправлять в бесконечность, бесконечность куда-то
будет отправлять, то есть она будет переставлять
расширенное поле, где есть еще точка бесконечности.
И вот оказывается, что вот этот вот код, он симметричен
относительно таких преобразований координат. Не только относительно
циклических сдвигов, но относительно всех дробно-линейных
преобразований координат. А оттуда уже можно вывести,
ну тоже немгновенно вывести кодовое расстояние.
В общем, я свое время исчерпал, на этом курс закончен.
Я надеюсь, что какое-то представление о том, как
конечные поля возникают в приложениях у вас возникло.
Ну и надеюсь, что про сами конечные поля вы что-то
запомнили, потому что, конечно, вам они понадобятся.
Ну, сейчас вы будете экзамен сдавать или там получать
оценку на итоговом занятии. Потом, конечно, какое-то
время они вам могут и не встречаться. Но есть надежда,
что даже если через год или два вам понадобятся,
вы все-таки не беспользуясь, вспомните, что я вам тут
рассказывал. Ну, кто знает.
Благодарю за внимание. На этом все.
