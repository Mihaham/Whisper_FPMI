Тема, в принципе, не сложная. Просто здесь скорее понимание. Это последний блок,
который нам будет важен с точки зрения геометрии. Это выпуклость. Мы чаще всего в, действительно,
не знаю там, в современном мире вряд ли вы очень часто встретите какие-нибудь не выпуклые вещи.
С точки зрения того, когда что-то обрабатываете, какой-то массив данных на какой-то карте и так далее,
вы обычно выделяете там какую-нибудь соту, что-нибудь с ней анализируете и смотрите.
И вот очень часто выпуклость здесь может помогать. И выпуклые многоугольники в принципе. Поэтому
существует несколько алгоритмов того, как строить такую выпуклую оболочку. Мы сегодня об этом поговорим.
И вообще, как проверить, что у нас любой многоугольник является выпуклым или нет. И
вообще, что с ним можно делать. Но для начала, что такое выпуклый многоугольник? Выпуклый
многоугольник это просто, на самом деле, определений достаточно много. Можно взять
определение следующее, что если вы возьмете любую сторону и проделите ее до прямой,
то все точки этого многоугольника должны лежать по одну сторону. В этом случае этот
многоугольник считается выпуклым. Можно говорить, что если мы возьмем две любые точки внутри
многоугольника и проведем между ними прямую, то они не должны пересекать ничего. Вот такое
определение тоже существует, но оно очень плохо ложится с точки зрения программирования, потому
что что такое любая точка, когда высок бесконечно, это плохо, это беда. И с ней работать сложно.
Поэтому мы пока что используем это определение. И вот вопрос. У нас есть какой-то многоугольник,
вроде бы все хорошо. А что нам сделать и как нам проверить эту самую выпуклость?
Первым способом, в смысле вот этим. Самое простое и единственное, что у меня написано
сегодня для вас псевдокодом, это вот это. В действительности, что мы говорим про выпуклые
многоугольники, мы говорим следующее, что да, мы с вами можем взять и проверить,
является ли многоугольником выпуклым, мы с вами умеем проверять, лежит ли точка слева,
ну то есть лежит ли точка по какую-то там сторону от нашей прямой. Нам нужно делать это для всех
точек, это по сути от каждой стороны нужно просматривать для всех точек, это будет занимать
N квадрат времени. Неприкольно, но наивно, просто понятно, откуда получилось понятно. Понятно,
почему за N квадрат? Всем понятно? Или прям нужно очень строгое доказательство? Хорошо. Здесь
меня чуть-чуть съехало, ну ладно, извините. Продолжение про выпуклые многоугольники. Смотрите,
вроде бы можно делать за N квадрат, но хочется быстрее, потому что N квадрат, ну как бы мы еще
по сортировкам знаем, что это не самое прикольное, что у нас есть, это я наверное чуть-чуть потом
подправлю, картиночка слишком большая. Для этого, для того чтобы ускорить процесс, мы просто сделаем
следующее. Воспользуемся утверждением таким, что у нас многоугольник является строго выпуклым,
а если все внутренние углы у нас меньше 180 градусов. Но это все тоже понятно, откуда берется,
я думаю вы представляете. То есть вот это утверждение, что тогда и только тогда,
позволяет нам сделать следующее. Когда у нас есть какой-то многоугольник,
и вот мы смотрим на те углы поворота, которые у нас есть, мы просто будем
последовательно рассматривать, а насколько мы поворачиваемся. Когда мы поворачиваемся там
против часовой стрелки, мы должны повернуться на сколько и более чем на сколько, как вы думаете.
Вот мы вот все это векторочками таким смотрим. Не больше, чем на 180 градусов. Именно поэтому в
этом случае мы скажем, что у нас все будет хорошо. Мы смотрим именно ориентированные эти углы. А что
это означает для нас с точки зрения программира? Как понять, поворачиваемся мы на 180 или больше
или меньше? Еще раз? Кто-то сказал какое произведение? Какое нам нужно сделать? Векторное
или скалярное? Ладно, векторное. Да, в действительности нам здесь поможет векторное произведение. Причем нам
не нужно вычислять угол. Пожалуйста, вот уберите у себя из головы паттерн, а поведение,
что везде нужно считать угол, и тогда будет понятно, на какой угол мы поворачиваемся. Нет,
вам нужно от этого уходить, потому что арксинус и арккосинус и так далее. Это, во-первых, очень
долгая операция, очень неточная операция будет для вас. И в некоторых моментах она, наоборот,
будет мешаться. Поэтому здесь все, что вам нужно, просто посмотреть на последовательность векторочков
между собой и посчитать между ними то самое векторное произведение. Если у вас все углы будут одного
и того же знака. Обычно многоугольник задается все-таки последовательностью какой-то. Если у вас
будут все углы одного и того же знака, причем он может как в одну сторону идти, то есть слева-направо,
почасовой, может быть и противчасовой. Поэтому у вас все векторные произведения должны быть
просто одного знака. Вы считаете все их, смотрите, что там происходит. Если они все одного знака,
то все хорошо, если нет, то все грустно. Работает это все чудо за тет-а-тен. Все достаточно просто,
потому что у вас сколько будет векторных произведений? Ладно, оставлю этот вам вопрос на
экзамен. Посидите, посчитайте. Хорошо, предположим. Но в действительности как бы так или иначе это все
уходит около n. Это все работает за тет-а-тен, потому что вы умеете считать векторное произведение за
за единицу. Помните как, я надеюсь, правда? Отлично. Вот вы умеете считать все это за единицу,
поэтому все векторные произведения вы просто смотрите, заводите какую-нибудь более
вопеременную. Все у вас все получилось, все хорошо, вы молодцы. Так можно проверять выпуклые
многоугольники. И это нам позволяет как раз таки все это рассматривать и смотреть. Есть ли тут
вопросы? Нет тут вопросов. А теперь давайте вернемся с вами к интересному моменту. Когда
мы говорили с вами про принадлежность точки, это было две недели назад, я надеюсь вы это помните,
вот еще. У нас была принадлежность точки внутренности нашего какого-то многоугольника. Давайте
будем рассматривать именно выпуклые многоугольники. Я хочу попробовать сделать это быстрее, чем мы с
вами делали или просто не лучом. Потому что проверять, пересекает ли луч все подряд стороны,
тоже не самое прикольное занятие. Какая есть здесь идея? Идея начальная следующая. Давайте рассмотрим,
ну возьмем какую-то точку и рассмотрим все вектора до остальных вершин, которые у нас есть
многоугольники. Что мы можем сказать про эти вектора? Вот так последовательно, если смотреть.
Что происходит с углами у этой последовательности векторов?
Она возрастает, то есть у нас углы поворота вот от самой, ну от оси у х можно сказать,
можно просто сказать там от нижнего вектора, как удобнее. Она возрастает. То есть это возрастающая
последовательность вот уголков будет, правда? А теперь следующий вопрос. Когда у нас, ну то есть
это грубо говоря, вот эта последовательность, она отсортирована. А мы можем ее воспринимать так.
Что мы умеем делать в отсортированных массивах? Бинпоиск умеем. А зачем нам будет нужен бинпоиск,
как ты думаешь? Да, то есть смотрите, что я хочу сделать? Я хочу сделать примерно следующее. Вот у
меня есть вот эта последовательность векторов. Я знаю, на какие углы они грубо говоря повернуты
между собой. Ну какими-то значениями я их буду сравнивать. Это чудесно. Я хочу понять, где,
между какими векторочками лежит моя p' или p2', здесь в зависимости от того, какую точку выберете.
Ну, предположим, что p'. Что мне это даст? Ну, в действительности здесь несколько будет вариантов.
Можно посмотреть, является ли точка внутри треугольника, если она внутри него. Можно посмотреть,
пересекаются ли отрезки. Можно посмотреть, является ли p' и p0 по одну сторону относительно там. Ну,
здесь p4 по 3, грубо говоря. Вот. Такие варианты есть. То есть, первое, что мы делаем, у нас они
расположены в порядке возрастания. Печатал и ошибся. Ну ладно, извините. Вот. Рассмотрим,
точку p' проводим этот вектор, смотрим, между какими оно лежит. Это чудесно. Мы с помощью бинарного
поиска, так как у нас все отсортировано, находим залогариф. Дальше проверяем, пересекается,
не пересекается, ну или лежит по одну сторону, не лежит и так далее. За o от единички получается,
за сколько работает алгоритм? Я либо слишком... У вас всегда многоугольник задан о конкретной
последовательности, соединяющей друг к дружку. Ну, то есть, грубо говоря, вот у вас есть вот такая,
вот такая вещь. Если вдруг вам дадут вот эту точку, ну типа, вот у вас есть p0, а p1 скажут,
что вот это, а вот это будет p2, тогда у вас будет вот так соединяться. Вот. Многоугольник всегда
дан последовательностью такой, которую мы можем соединить подряд. Вот. Если мы заходим все
залогариф, то залогариф. Либо сейчас половина не понимает, что происходит, либо вы сонны,
либо вы делаете что-нибудь другое. Это просто слишком... Хорошо, значит скоро мы дойдем до сложных. Вот.
А у меня вопрос, а как сравнивать углы между собой? То есть вы так согласились, что все отсортировано,
все классно, все хорошо. А как сравнивать вот углы между собой? То есть нам нужно же попасть все
равно по штриху как-то. Посмотреть p1 и p2, что посмотреть? Направление ориентированного угла. Да.
Суть своей это правда. То есть нам достаточно здесь посмотреть p0, ну то есть, просто скалярное
произведение p0, ой, господи, векторное произведение, p0 по штриху и p0 по it. То есть мы поймем,
какой у нас угол поворота. Согласны? Вот мы и сравнили наши углы. И все, что вам нужно
делать в компараторе, вот в таких задачках, все, что вам нужно сделать, это взять просто,
он меньше 0, больше 0. И это будет вашим компаратором. То есть, грубо говоря, именно сама суть
компаратора, что она делает? Она возвращает этот левее находится или это правее находится? Меньше,
больше. Вот это и будет меньше, больше. Понятно? Не нужно придумывать косинусы, пожалуйста,
уходим, уходим от этой концепции в этом мире, в мире алгоритмов. Поверьте, считать их неприкольно,
даже если вы думаете, что это просто. Вот. Принято, принято. Я что-то прямо это, чтобы вы понимали,
половина презентации закончила. Я понял, я опаздывал, сейчас могу очень спешить. Пожалуйста,
если что, останавливайте, приостанавливайте, спрашивайте. Теперь переходим к основной части,
на самом деле, того, что у нас есть. Называется эта штука выпуклой оболочкой. Выпуклая оболочка,
множество каких-то точек S. Называется минимальная по включению выпуклая множество. То есть,
по факту, это множество. Важно здесь помнить следующее, что если вдруг у вас есть множество,
ну какая-то пара точек, вы их соединяете, у вас все хорошо, но на ней лежит еще какая-то точка,
то вот она не будет входить в выпуклую оболочку. Выпуклая оболочка — это минимальная такая часть,
которая вас покрывает все остальные точки. Можете воспринимать это именно так. Что важно
осознавать с точки зрения математики? Количество точек может быть какое?
Ну бесконечное почти никогда не бывает, вам все-таки задают их чиселками. Какое?
Счетное количество точек. Вот когда у вас находится счетное число точек,
а в действительности вам там нужно будет исхитряться, ну вообще такое вы не зададите просто
в программировании, либо у вас будет бесконечное, потому что у вас будет действительное число,
либо у вас будет конечное число. Но для счетного числа это будет такой небольшой кружочек по факту,
потому что ну там рациональными чиселками вы можете вот это все добить. Вот, а если же мы с вами
говорим про, не обязательно прям кружочек, хорошо, типа, ты осмутила это. Счет на это бесконечно,
я не отрицаю. Я имею ввиду количество вещественных чисел типа все-таки больше,
вот. Либо мы уходим вещественные числа, ну да, был у вас все-таки вещественные числа пытается
покрыть, а либо мы работаем с целыми числами, вот, одно из двух. Но мы будем рассматривать вообще в
курсе, ну и в принципе вы в жизни скорее столкнетесь с несчетным количеством, тем более с...
Прошу прощения, не сильно, еще быстрее, видимо. В общем-то мы будем сталкиваться с конечным
числом точек, почти всегда, но все-таки считать-то вам их как-то надо, что будет
означать следующее. Если у вас конечное число точек, то у вас выпуклая оболочка это всегда
многоугольник выпуклый. Просто некоторый многоугольник, который у вас будет,
и с ним необходимо работать. И вот вопрос самый главный с выпуклыми оболочками, а как это делать?
Смотрите, про выпуклые оболочки. Чего есть интересного? Есть интересного,
стоят два алгоритма, которые мы с вами сегодня пройдем. Это алгоритм Джарвиса,
алгоритм Грехома. Может быть, кто-то из вас что-то такое слышал, может быть, нет.
Вот. Дальше, если кого-то очень сильно увлечет эта тема, вы можете подумать на тему того,
а как строить выпуклую оболочку в 3D. У вас такой задачи не будет. Раньше, по-моему,
сейчас ее убрали даже из программы и основного потока. Возможно, продвинутым она осталась.
Вот. Там забавно. Я просто помню, как у меня сосед делал эту 3D оболочку. Ушло у него две с
половиной недели, наверное, потому что тот white paper, который был и по которому можно было бы все
сделать, там был написан неправильный алгоритм. За это вы дебажите еще больше. Но здесь все будет
написано правильно, но никакого псевдокода и кода тем более. Начнем мы с алгоритма Джарвиса на самом
деле и поймем, что вообще с ним можно делать. Смотрите, алгоритм Джарвиса очень часто называют
еще заворачивание подарка. Почему? Потому что, предположим, то у меня есть какой-то набор точек.
Вот. А что делается в алгоритме Джарвиса? Фиксируется сначала самая нижняя левая точка,
потому что она 100% лежит в нашей выпуклой оболочке. Можно зафиксировать самую правую
верхнюю точку, но просто так повело, что фиксирует самую левую. Ну она точно будет,
почему? Ну нам нужно же покрыть все множество, ниже нее ничего не бывает и левее ее ничего не
бывает. Поэтому она точно входит. Окей? Вот. И что подразумевается, как родился вообще этот алгоритм?
Смотрите, мы представим, что у вас есть какая-нибудь огромная нитка, а вот эти все точки – это гвоздики.
Как вам с помощью этой ниточки построить эту выпуклую оболочку? Просто завернуть ее. Ну то есть
вы просто вот так вот пойдете по кругу и попытаетесь все завернуть. И благодаря этому у вас
появится та самая выпуклая оболочка. Поэтому этот алгоритм иногда называют алгоритмом
заворачивания подарка. Давайте все-таки отдавать дань тому, кто это придумал. Это был Джарвис.
Вот. Поэтому в действительности алгоритм звучит очень просто. Смотрите, мы берем точку P0,
которую у нас здесь есть. Дальше выбираем точку P1. Как мы выбираем? Как вы думаете?
Да, чтобы у нас просто был минимальный угол сам по себе. С осью X. А после этого в действительности
мы с вами пытаемся найти еще одну точку, которая будет образовывать с нашим новым
каким-то векторочком. В этом случае это вот этот векторочек. Минимальный угол поворота. То есть
вот мы рассматриваем все возможные такие вот лучи, смотрим где у нас минимальная и добавляем
эту точку. Минимальная будет вот здесь. Поэтому добавляем эту точку. Потом от нее опять же смотрим
на все остальные точки. И так мы просто по чуть-чуть идем. То есть мы смотрим минимальный угол этого
поворота, который у нас есть. Звучит просто. Что, как вы думаете, здесь сложно? Минимальный угол
каждый раз искать. Сколько это стоит, как вы думаете? А? Ага. N квадрат, N квадрат. За сколько
работает алгоритм? Давайте, хорошо. Остальные, как вы думаете, за сколько работает алгоритм? N квадрат.
Хорошо. Вопрос следующий. Все ли точки входят в вашу выпуклую оболочку? Не обязательно. Поэтому
не работает он за N квадрат. Что еще раз? Да не работает он за N квадрат. Ну хорошо. Тогда он из
того от N куп работает. Давайте, если вы уж в такие дебри пошли. Знаете, в действительности у нас все
зависит от того, сколько точек в нашей выпуклой оболочке. Именно в зависимости от этого мы и смотрим,
что у нас происходит. И для каждой этой точки мы ищем минимальный угол. По минимальному углу мы
уже поняли, как это найти. Это все очень просто и очень быстро. Поэтому, да, для каждой точки это
за O от единички всего точек N, за O от N. Поэтому у нас будет O от N действий на каждую из, ну там,
H из нашей выпуклой оболочки. То есть это работает за O от N H. А в каком случае алгоритм Джарвиса
хороший? Ну смотрите, возможно, у вас будет условие какое-нибудь такое, что у вас будет обязательно
покрываться это треугольником. Может быть такое? Может быть такое. Тогда в этом случае это будет
работать за O от N. А может быть такое, что все точки будут лежать в вашей выпуклой оболочке. В этом
случае это будет работать за N квадрат. Еще раз. Еще раз. Давайте так. Мы отказываемся от концепции
углов. Хорошо? А как мы считаем эти величины? Как мы сравниваем между собой углы? Давайте еще
раз я напомню это. Мы сравниваем между собой углы просто по векторному произведению. У нас
один вектор есть. То есть мы же рассматриваем относительно вот этого вектора, какой у нас
есть поворот. Давайте относительно него и рассматриваем все, что у нас есть. Мы только что сравнивали.
Мы только что говорили, что можем сделать за O от логарифма бинпоиск, потому что мы
легко умеем подряд это сделать. Сейчас, смотрите. Смотрите, давайте еще раз. Концепция следующая.
Вот скажите мне. Вот у меня есть вот этот векторочек. Я относительно него смотрю все повороты,
которые у меня есть. Как я могу сравнить, типа, у меня поворот корректен или некорректен? Ну,
типа, подходит к ней или нет? Буду ли я считать прям... Что там? Косинус, синус, угла. Что хотите?
Косинус хотите. Очень хочется. Только есть... А, нет, нет проблемы. Ладно, хорошо. Здесь не будет
проблем. Давайте. У нас есть векторное произведение, у нас есть скалярное произведение. Скалярным
произведением не часто вы можете работать. Здесь скорее векторное произведение. Можем ли мы между
собой сравнить, насколько мы повернемся вот к этой точке, грубо говоря, и вот к этой точке?
Между собой мы можем сравнить? Можем сравнить. Отлично. Мы сравнили. Мы такие, ага. Вот давайте так,
не так. Вот эту точку у меня есть. Теперь давайте следующую возьму. Вот эту точку. Могу ли я сказать,
что в этом случае... Вот раз и вот два. Могу ли я сказать, что вот в этом случае у меня поворот
меньше, просто сравнив их? Могу. То есть, я говорю, вот эта точка минимальна. Я прохожусь по всем
точкам и смотрю. Вот все, что ниже нее, оно минимально. Оно меньше него. Давайте выше смотреть. Я не
смотрю на сам угол. Я смотрю на это векторное произведение. Куда я поворачиваюсь? Влево поворачиваюсь.
Классно. Право поворачиваюсь. Значит, вот эта точка, в которой она находится меньше. Понятно,
что я делаю? То есть, я еще раз. Я не смотрю на сам угол. Я не смотрю на синус. Я просто умею
сравнивать между собой уголочки, а значит, я между собой могу сравнивать и углы. Я между собой
сравниваю вот эти вектора, как у меня поворот выглядит, и так сравниваю углы. То есть, я не
отталкиваюсь от синусов и косинусов. Я отталкиваюсь от того, у меня будет левый или правый поворот. Ага. Вот.
Окей. Про сложность. Понятно, что за NH. Не говорите никому, что за N квадрат. И за N тоже не говорите.
Вот это совсем будет беда. Хорошо? За N dash. Кайф. А теперь, смотрите, интересный факт. Как вы думаете,
какое минимальное время, за которое, в общем случае, можно найти выпуклую оболочку? N. Log N. N log N.
Порядочим по какой-то координате. N квадрат. N log N. Давайте голосование. Мне очень нравится вот это.
У нас есть кандидаты N. N log N. N квадрат. За сколько минимальное время работы, в общем случае, ниже
которого невозможно быстрее сделать, грубо говоря. Давайте, типа, кто за O от N. Мне просто интересно.
Дальше человек, который был за нее, отказался. Кто за N log N? А кто за N квадрат? А как в это сделать?
Грустная история. Вот здесь у нас получается максимум. А почему? Да. N совсем мало так. А в
действительности, смотрите. Но нужно это очень хорошо доказать, в общем-то, в случае. И мы с вами
сейчас этим займемся. Там есть отдельный слайд, но там прям все написано, поэтому вернемся к нему,
когда мы уже все это сделаем. А на что похоже N. Log N? Где еще минимальную оценку встречали N. Log N?
Тортировках. Помните, мы говорили о том, что невозможно ниже, чем N. Log N. Этот нижний барьер
преодолеть на сортировке сравнению. Давайте попробуем свести задачу с выпуклой оболочкой
к задаче сортировки. Вы на меня так смотрите? Лучше всегда все сводить к чему-то известному,
потому что тогда вы получите какой-нибудь факт. Предположим, что у меня есть точки.
В том порядке, в котором они идут, иначе это бессмысленно. Вот так у нас получится.
Иначе это очень странная гипотеза. Называю это так. Вот у нас есть такие точки. Давайте, давайте.
Что будем? Ну нет, это ужасно. Давайте возьмем следующие. Возьмем точку x0 в квадрате, x1 в квадрате
и так далее. Что у нас тут получается? Ну хорошо, да, действительно не гипер было, все-таки пора было.
Вот у нас получается такой вот некоторый график. Восточно с мотоном, с линавом все хорошо, да?
Хорошо. Ладно, ну как бы у нас есть вот эти вот отсортированные точки. Ну я их здесь укажу,
как уже отсортированные. В действительности мы просто смотрим, что у нас здесь есть какие-то
точки. И у нас будет действительно такая вот какая-то параболка. А точки как-то хаотично,
но все равно они образуют вот такую параболу. Скажите, все ли точки будут лежать в выпуклой оболочке?
Ну у нас прямых линий все-таки тут не предвидится, правда? И они будут всегда идти поверх. Ну то есть
у нас выпуклая оболочка будет какая-то вот такая. Там я утрированно рисую, ну вы поняли. То есть
будет такая. И вот она замкнется как-то вот так. То есть у нас появится вот такая вот выпуклая
оболочка сама по себе. Смотрите, я упорядочил эти числа между собой. Согласны? Ну я точки в
нужном порядке расставил. Даже если я начну с P0, который на нуле находится, я пойму,
когда я туда уже пришел. Согласны? А теперь смотрите, могу ли я сделать быстрее, чем Зейн Луген?
Сортировку чисел. А ровно так же выпуклая оболочка я не смогу сделать Зейн Луген быстрее. Х0 это
число, которое у тебя было дано здесь. Х0 в квадрате это по Y. Сейчас подождите. Мы отталкиваемся от
другого случая. Я пытаюсь свести задачу к тому, что у нас должна быть сортировка чисел, грубо
говоря. У меня даны какие-то числа на вход, я должен получить их на выход. Я могу отсортировать
с помощью выпуклой оболочки. Ну вот я тебе привел пример, как я могу это сделать. Да? У нас было
с вами утверждение про вот этот минимальный барьер, что нельзя сделать это быстрее, чем Зейн Луген.
Значит, здесь мы не можем сделать быстрее, чем Зейн Луген. Поэтому в действительности нельзя
сделать выпуклую оболочку быстрее, чем Зейн Луген. Окей? Механизм принятия решений понятен?
Вот. Поэтому да, никакую выпуклую оболочку нельзя сделать быстрее. То есть у вас есть ограничение
снизу. Это омега большой, это Н Луген. Поэтому мы должны подумать, существует ли такой алгоритм.
И вот там назвали один такой алгоритм. В действительности это алгоритм Грехема. Давайте с ним разбираться.
По чуть-чуть. Алгоритм Грехема первоначально будет очень похож на алгоритм Джарвиса. И там,
и там в начале выбирается самая точка, которая обязательно лежит в вашей выпуклой оболочке.
Я беру также самую левую и нижнюю. Вот. А дальше делают следующее. Вот здесь, кстати,
у меня Н потерялось. Ну ладно. А дальше делают следующее. Давайте отсортируем все точки по
величине угла относительно там P0, P1. Ну то есть все также возьмем там первую точку. Первую точку легко
найти там за УАТ. А дальше отсортируем все точки относительно вот этого вектора. Мы сортируем.
Если вдруг у точек одинаковый одинаковый угол, то нужно смотреть по величине вектора. Но это
связано с тем, что точки, лежащие на одной и той же прямой, должны вот вы должны брать дальнюю самую.
Окей? Окей. Я отсортировал. Что делаю дальше? Да, я говорю Н потерял. За N лог N. Смотрите,
я сортирую все точки относительно вектора P0, P1. То есть какой они образуются с ними угол.
Берем минимальную. Так. Минимальная точно лежит. Хорошо, а что дальше? Повторяем сортировку. Звучит
грустно. Берем следующую и смотрим, куда она поворачивает. Так. Убираем P2, предлагаем P3. Да.
С помощью чего это лучше реализовывать? Так, все правильно. Объясните мне,
вам на семинаре что-нибудь рассказывали? Все, я понял. Все от этого достаточно просто и стало.
Да, смотрите, мы с вами, когда отсортировали все точки, мы будем перебирать точки по возрастанию.
Если вдруг у нас объявляется тот самый правый поворот, а не левый поворот, то мы начинаем
выкидывать точки сами по себе из нашего стека. А зачем мы это делаем? А мы делаем это затем,
чтобы у нас образовался именно правый поворот. Потому что левый поворот, sorry. Левый поворот
для того, чтобы у нас с вами как раз таки было вот то, то мы с вами вот таким вот образом будем
ходить везде. Грубо говоря, если мы с вами рассматриваем все точки, то в этом случае мы с
вами говорим о том, что мы просто ходим. Давайте я где-нибудь это порисую, чуть понятнее может
будет. Хотя, видимо, вам там все и так понятно. Ну что же, в субботу я нагоню, а дальше вам
будет уже не так все просто. Я надеюсь. Хотя, если вам все просто, то жизнь удалась, я считаю.
Ну в общем-то, смотрите, предположим, что у меня уже есть какая-то там выпуклая оболочка, а дальше
пусть будет вот так и вот так. Так лучше. Вот так просто сделаем. Мы уберемся с одну просто точку.
Такое может быть. Отлично. Да, мы это делаем постоянно. Вот мы видим такое, видим, что у нас
здесь уже вот сюда вектор есть. Здесь слишком большой поворот. Тогда в этом случае мы просто
баним ту точку, которая у меня есть. Она находится в стеке на самом верху, поэтому выкинуть из стека
нам достаточно просто. А дальше мы соединяем со следующим и смотрим, у меня будет здесь необходимый
мне поворот или нет. Но причем, заметьте, стект хорошо, но вам нужно хранить не только верхнюю вершину,
иметь доступ к ней, но еще и к предыдущей. Как так можно сделать? Весь в этом. В стеке два значения.
Смотрите. У вас в стеке лежат точки P0, P1, P2, P3. Выкину я P3, хорошо, предположим. Я смотрю на точку P2,
а я не знаю точки P1. Вот вы в стеке умеете обращаться к предыдущему элементу? Так, хорошо.
Проходили ли вы контейнеры? Нет, контейнеры, значит, все не проходили. Викторан? Пока что да. Ну,
значит, будете, если что, делать просто вам динамический массив на максимальное количество вершин,
дальше добавлять, ну, убавлять сайс, увеличивать сайс, и все равно по индексу вы можете ходить.
Вот. Это то же самое. Виктора просто умеют менять размер вашего массива. Двухсвязный
список получается. Потому что, потому что. Не, ну, в действительности вы можете это сделать. Но
только в этом случае это уже не стек, а все-таки, ну, просто такой обрезанный дек, я бы сказал. Вот. А? Ну,
лист, да. Просто используйте лист. Но, а в общем случае это звучит именно как стек. То есть,
предложение первое, которое вводилось в данный алгоритм, это было со стеком. Теперь давайте
рассмотрим с вами, за сколько будет работать данный алгоритм. Я специально не писал сегодня вам
типа код, еще что-то. Не прикольно. Вам нужно самим. Я думаю, вы на семинарах это, видимо, уже сделали.
Да? Да. Почему n log n? Сортировка за n log n. Дальше. Почему обход за n? Да. А каждую точку мы либо
один раз добавим, либо один раз удалим. Из-за этого всего у нас происходит это именно таким вот образом,
что у нас работает это за у от n. Потому что не больше, чем два n действия мы сделаем. Удивительно
рядом, из-за того, что вы все знаете. Блин, аж сложно. Но да, мы сегодня с вами закончили с алгоритмом
Грехема тоже. Совсем, что у нас есть. Что у нас будет дальше? Давайте порассказываю чуть-чуть такого
интересного. Смотрите, следующее, что у нас будет, это хэш функции. Дальше у вас будет еще всякие потом
хэштаблички, вы тоже с ними познакомитесь и так далее, что с ними делается, что такое коллизии,
как с ними вообще работают и так далее. После хэш функции у нас будет, скорее всего, амортизационный
анализ еще раз. И на экзамене он будет у вас еще раз. Потому что ко мне пришел следующий фидбек.
Судя по экзамену, вы не знаете амортизационный анализ. Цитата. Еще одна лекция будет просто не
с теми структурами данных, которые были там. Она будет немного связана с плюсами, с динамически
расширяющимся массивом, с вектором по факту. Мы будем его оценивать, будем смотреть, что там
происходит. Вернемся к этому опять. Потому что, видимо, вы на экзаменах представляете, что алгоритмы
это только алгоритмы и забываете о такой важной вещи, как анализ алгоритмов, что грустно. Кроме
того, у нас будет еще, возможно, здесь я на сто процентов вам не скажу, я думаю об этом, как раз
таки та теоретическая лекция, которая должна была быть на прошлом семестре. Про всякие фибоначевые
кучи, что это такое, как с этим работать. Ну а дальше графы. Много-много графов. Окей.
На этом, в принципе, сегодня все. Предлагаю сделать все-таки фотку и отправить ее в чат.
Ничего не знаю, потому что что это такое. Поэтому давайте сделаем селфи и
на сегодня закончим. И хорошего вам вечера. Сразу пожелаю.
