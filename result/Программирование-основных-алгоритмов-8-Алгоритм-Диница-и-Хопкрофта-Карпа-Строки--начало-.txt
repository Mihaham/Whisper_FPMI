Так, такая у нас лекция по счету, по-моему, восьмая. Сегодня мы продолжим изучать потоки,
ну поиск, алгоритм поиска потока и, надеюсь, закончим на этом на сегодня.
Вот, ну окей, у нас с вами была схема Форд-Авкерсона, напомню.
Которая заключалась в следующем, что шаг нулевой у вас fthds равен нулю. И что вы делали дальше? Вы
берете, находите путь P, шаг второй, давайте в nf, шаг второй пропускаете
вдоль P поток f', шаг третий, вы говорите, что f равно f плюс f', и четвертая, это
перестроите nf, потому что у вас поток изменился, перестраивайте остаточную сеть. Это схема
Форд-Авкерсона, ну или Фалкерсона. Вот, там разные варианты, как находить тот путь, либо
DFS ему получить алгоритм Форд-Авкерсона, либо BFS ему получить алгоритм Адманса Карпа,
здесь все присоединяется к остальному, одинаково. Вот, в этот раз нам предстоит
познакомиться с новой схемой. Схема Диница, так называемая. Нам понадобится несколько определений,
и определение первое. Пусть это сеть, тогда
слоистой сетью nl, l от слова layer. Обзовем следующую штуку.
AGL, VEL, TL, ST. То есть, у нас вершины не меняются, ST не меняются, меняются рёбра, меняются
capacity. В чем суть? Где EL равно множеству UV таких, что UV лежит в Е, и dist от S до U, это dist
от S до V, minus 1. То есть, вы оставляете только рёбра, которые ведут в следующий слой. Картинка
сейчас будет, не расстраивайтесь. И есть CL. Это CL от UV обозначен. UV, если UV лежит
0 иначе равно. То есть, у нас есть наша точка S, вершинка S. У нас есть какие-то слои, здесь там T.
И вы оставляете только рёбра из S в первый слой, из первого слоя только во второй слой.
Такое. Ну, соответственно, здесь тоже как-нибудь так вот. То есть, вы оставляете только те рёбра,
у которых расстояние проходит между седними слоями. Вот. Какие рёбра еще могут быть?
Ну, могут быть рёбра, которые внутри слоя. Мы их не рассматриваем как раз-таки. Рёбра,
которые ведут назад, тоже могут быть. Мы их тоже не рассматриваем. Соответственно,
как построить слоистую сеть? Вау, надо запустить BFS. Все рёбра, которые BFS просмотрит и явно пройдет
по ним, они как раз-таки будут в слоистой сети лежать. То есть, это те рёбра, которые ведут еще
в неизведанную вершину, скажем так. Не то что в неизведанную, а вершину,
которая еще не помечена раскрытой. Вот так вот. Ну, цель понятна, это просто сужение нашей
капасти на эти рёбра. И давайте еще одно определение. Пусть F – это поток ВМ. Тогда F блокирующий
А если F нельзя увеличить? Нельзя увеличить, не строя NF. То есть, не строя остаточной сети.
То есть, чем у нас была хороша наша остаточная сеть? Тем, что она обратными рёбрами позволяла
отменять единицу потока, текущую через рёбро. Здесь мы себе это краски запрещаем.
Ну, давайте сначала пример для блокирующего потока.
Один из одного, один из одного, один из одного, здесь один. Вот пример блокирующего потока,
потому что вы его явно никак увеличить не можете, не вводя обратные рёбра. То есть,
как мы выискали максимальный поток? Мы ввели здесь обратное рёбро с способностью единицы,
потом построили бы этот путь, который был бы то же самое, что мы отменяем вот эту единицу потока
и проводим еще здесь по единице потока. Вот, в блокирующем потоке мы не строим остаточную сеть,
поэтому у нас, собственно, этот поток блокирующий. Ну, это пример, когда блокирующий поток не
является максимальным, в общем-то. Ну вот, окей. Собственно, давайте схему единицы напишем.
Да, сразу скажу, что у диница фамилия Динец, вот, это автор, уважаемый советский ученый Ефим
Динец, поэтому ставьте родительный падеж через нужную форму, то есть не динецы, а динеца. Вот,
когда говорят алгоритм динецы, где-то рядом плачет один Ефим Динец. Вот, окей. Схема такая. Ну,
нулевой шаг понятно, F тож, ясно, равны нулю. Шаг первый это, давайте так, строим NF. Шаг
второй. Строим NFL, строим слоистую сеть по остаточной сети. Уже достоин, да, двойный индекс.
Шаг третий. Находим блокирующий поток F' в NFL. Шаг четвертый. F' равно F'. Все. Соответственно,
заканчивается алгоритм, когда вы не смогли найти блокирующий поток. То есть, как бы,
смогли найти поток величины ноль. Это значит, что из-за недостижимоты в остаточной сети,
потеряем форда Фоккерсон, вы нашли максимальный поток. Поэтому корректность очень тривиальная у
этой схемы. Теперь нужно оценить время работы. Ну, давайте подумаем, где тут такие шаги. Ну,
это очевидно от V plus E. Почему? Потому что на остаточной сеть построить легко. Грубо говоря,
вы должны пробежаться по всем ребрам, которых у вас... Ну, и построить там обратные ребра,
пересчитать их там. Поток через них и остаточная вместимость через ребро обратное и прямое. Это
тоже от V plus E. Это запуск VFS. Это проход по всем ребрам. Так. Ну, это тоже очевидно. Это проход по
ребрам. И остаются два момента. Первый момент – это сколько итераций. Второй момент – как
сказать блокирующий поток. Первый F также сноровный нулю. Ну, инициация алгоритма у нас F тоже сноровенный
нулю. Поэтому F от N не отличается здесь. Ну, давайте здесь напишу. Говорю, шаг 4F тоже сноровенный нулю.
Вот. Окей. Что тогда теперь? Нам нужно оценить число итераций. Давайте оценим число итераций.
Так. Утверждение. После итерации схемы динеца
DIST от S до T увеличивается. Вы не разлили на меня вопрос, что такое DIST от S до T в данном контексте.
Это имеется в виду число ребер. Вот. То есть у нас нет никаких весов. Имеется в виду
реберное расстояние или то, что все веса равны единице. Так. Я утверждаю, что после итерации,
после каждой итерации расстояние только увеличивается. Ну, доказательствую,
что тут будет методом рукомахания и рисования картинок. Надеюсь, вы не разочарованы в этом.
А как у нас устроен наш алгоритм? Вот он нашел какой-то блокирующий поток слейсты сети.
Так, давайте побольше ребер нарисуем. Что мы с вами сделали? Мы строили с вами
и мы нашли блокирующий поток f' . Что происходит при добавлении потока f' ? Как меняется? Давайте
посмотрим так. Как меняется nf plus f'l относительно nfl? То есть когда вы увеличили поток, что у вас
может измениться? Ну, утверждается, что что может произойти? Первое, что может произойти,
это у вас добавятся обратные ребра новые. Обратные ребра. Ну, которые вот ведут,
например, мы это ребро насытили, значит оно развернется. Второе, что может случиться, это
если мы насытили ребро, значит у нас активируется ребро вот такой вот внутри слоя. Ну, мы же с вами
перестроили по новому потоку. Мы с вами построили новый поток, построили новую остаточную сеть,
которая могла уже добавиться, которой это ребро существовало. Потом сделали слоистую, так у вас
это насыщенное ребро, у вас его нет, у вас там могло вот так вот произойти. Добавились ребра внутри
слоя. Ну и шаг третий, это у вас, собственно, могли удалиться ребра слева направо. Назовем эти
ребра прямые. Ну окей, тогда что можно сказать? Что, по сути дела, у меня путь от СДТ не может
уменьшиться. Почему? Ну окей, давайте допустим, что у меня здесь был какой-то путь от СДТ,
который я не насытил. Да, то есть если у меня существовал путь от СДТ, даже не так, вот так,
вот так вот сделаем, что если я на пути из С в Т, здесь Т находится, пустил поток, но при этом найдется
путь из СДТ, который не насыщен, то поток не блокирующий. Ну потому что есть просто путь от
СДТ, вдоль которого можно пустить единичку потока. Значит, что я все пути от СДТ заблокировал,
то есть у меня из СТ недостижимо, ну иначе просто поток не блокирующий был бы. А если из СТ теперь
недостижимо, а в новой сети у меня появляются либо ребра вот такие вот, либо ребра внутри одного
слоя и удаляются еще вот такие вот ребра, то могло и расстояние уменьшиться. Ну очевидно,
нет. То есть у меня расстояние могут добавлять только вот эти вот ребра внутри слоя, но они
увеличивают, они отдаляют от нас. Ну исходя из этого у вас расстояние только увеличивается. Ну и все.
Окей? Что новых путей хотя бы той же длины?
Нет. Так как они заблокированы. Ну все, тогда это мы доказали. А раз мы это доказали,
то тогда очевидно сколько итераций максимум можно сделать. Вот В-1 это правильный ответ.
Число ребра это много, потому что у вас путь не может быть длиннее, чем число вершин. У вас
в каждом слое должна хотя бы одна вершинка находиться. А тогда число итераций не превосходит.
В-1 мы будем говорить, что от В просто-напросто равно от В. Окей. Так, с этим разобрались. Теперь
нужно разобраться с тем, как искать блокирующий поток. И тут есть куча вариантов. Мы рассмотрим самый
простой. Да? Нет, мы рассмотрим самый наивный, а потом чуть менее наивный. Самый наивный он
такой. Ну давайте запустим DFS. Если пути заспыта нашли, протухнем сквозь его поток. Запустим
еще раз DFS. Все. Пока можем пропустить поток, запускаем DFS. Так как каждый такой DFS насыщает
хотя бы одно ребро в сети, значит у вас максимум от запуска DFS будет. Если у вас от E запуска DFS,
значит у вас от E квадрат время работы поиска блокирующего потока в таком случае. А если так,
то асимпточка в E квадрат. И зачем мы это придумали, если Advanced Carb работает за такое время?
Давайте чуть быстрее что-нибудь придумаем. А именно удаляющий обход. Мы будем искать сейчас
блокирующий поток за VE, так сказать. А в чем глубинная суть этого метода? Она в том, что мы
будем также запускать кучу раз DFS. Единственное, что мы будем для каждой вершины поддерживать
индекс первого ребра, который мы еще не удалили из рассмотрения. Для каждой вершины
поддерживаем индекс ребра,
которая актуальна. Но ребро актуально, если оно еще не насыщено, и при этом из него можно дойти,
из его конца можно дойти до ГРШДТ. Смотрите, у нас есть наша вершина какая-то, здесь множество ребер.
Первое ребро, второе, третье, четвертое. Вот допустим из этого ребра нельзя дойти до Т.
Ну тогда очевидно, что и в последующих запусках DFS нельзя будет пройти до Т из него,
потому что мы там не умеем отменять потоки и вообще сеть не перестраиваем. А второй случай
это, что мы можем дойти до Т, но ребро насыщено. Давайте это скажем, что ребро насыщено.
Ну точнее не так, мы оставляем только ребра не насыщено, если ребро насыщено, мы его скипаем.
А третий случай, может быть вообще, что ребро не из слоистой сети, мы же явно не будем все это
перестраивать и строить новую сеть. Мы там будем помещать условно булями, и лежит ли ребро в
слоистой сети или для каждой вершины хранить там дистанцию от S до нее. Поэтому может быть ребро
не в слоистой сети, не в NFL. Вот это вот не актуальные ребра. И вот это ребро, из него мы можем
дойти до Т, оно не насыщено, и оно в слоистой сети, и оно актуально тогда. Понятно, да, что мы
хотим сделать. И сквозь него, и теперь мы будем пытаться понять. Вот допустим, нам пришел сюда
какой-то поток F. Мы хотим понять, можно ли как-то его раскидать. Но очевидно, что сквозь это ребро
сколько потока можно пропустить? Минимум из вот этого потока и остаточной вместимости. Больше
пропустить нельзя. Ну минимум из потока берется, потому что больше чем этот поток пропустить не
можете просто через это ребро. Мы считаем, что только вот это вот входит сюда. Ну или F-то суммарный
поток со всех. Вот, ну так как нас-то будет DFS по сути, таким интеллектуальным, мы считаем,
что вот весь поток через одно ребро идет. Пытаемся его пропустить сюда. Ну и аналогично,
мы не можем больше чем CF пропустить сквозь это ребро, поэтому минимум из CF еще берется. Ну и все.
Давайте подумаем с вами о том, за сколько работает это все дело, а именно поймем,
за сколько у нас в частности работает одна итерация такого алгоритма. То есть смотрите,
что мы делаем. Такая еще графическая интерпретацию можно предложить. Что вот если есть S, есть T,
и вы нашли какой-то путь, то это значит, что все ребра выше вы уже просмотрели на текущий момент.
Они либо из них нельзя дойти до T, либо они не в слоистой сети, либо оно насыщено. То есть вот
есть какие-то ваши DFS пощадь какие-то ребра, ну и где-то они тут останавливаются. То есть не дойти
до T там не могут или насыщенно. То есть ваш DFS где-то закончился. То есть все ребра выше этого
пути вы уже рассмотрели. Но если выше, ввести в порядке того, что у вас сверху лежат номера с
меньшим номером, а снизу с большим. Вот и поэтому дальше вы будете рассматривать только все,
что ниже находится этого пути. Вот такая совсем неформальная интерпретация того,
что происходит, вдруг вам так будет понятнее. Окей, так. Пусть K это количество сдвигов индексов.
Что это значит? Вот мы же храним для каждой вершины индекс ребра, которая актуальна. Очевидно,
что если ребро не актуально, мы делаем, мы просто прибавляем плюс один к индексу и делаем дальше.
Вот. И вот краски вот этот вот сдвиг индексов имеется в виду, что вы делаете этот плюс-плюс индекс
от вершинки. Вот. То есть это по сути, идейно, это количество ребер, которые вы рассмотрели сверху
за одну интерацию. То есть те ребра, которые там у вас были, что нельзя дойти до T или там они
неслывистой сетели, они уже насыщены. Вот. А как раз таки вот эта вот длина в пути от S до T,
она не превосходит V. Поэтому время работы вот такого вот типа DFS, время работы одного запуска,
от V плюс-K. А что дальше делают? Ну окей, мы нашли путь, но это же не блокирующий поток.
Собственно, чтобы дойти до блокирующего потока, у вас вызывает вот эту вот процедуру, пока у вас
поток вообще находится. Здесь пока у вас есть путь от S до T. Вот. Когда у вас нет пути из S
до T, автоматически получается, что у вас поток уже блокирующий. Вот. Соответственно,
по сути, будет код-код функции вот этой вот и будет внешний там while true, допустим,
который в цикле пытается найти поток новый. Если у него получается, то он его находит. Вот. Ну,
псевдокод еще напишем, не волнуйтесь, чтобы вам было проще жить. Ну попробуй написать,
может не получится. Так. И теперь давайте оценим вообще количество запусков всех вот этих вот. То
есть сколько раз мы можем найти вот такой вот путь из S в T? Ну, на самом деле, не очень много.
Почему? Потому что каждый раз вы насыщаете хотя бы одно ребро. Если вы не насытили ни одного ребра
на пути из S до T, значит, вы можете пропустить больший поток. А вы почему-то этого не сделаете.
Вот все. Поэтому у вас каждый раз насыщает хотя бы одно ребро, всего ребра E, поэтому всего запусков
всего запусков вот E. Так, ну что теперь нужно сделать? Давайте еще посчитаем,
чему равна сумма по запускам каитов? По всем запускам. То есть сколько всего вообще можно
сделать двигов за все запуски суммарно? Ну от E штука на самом деле. Потому что вы,
если один раз уже забыли ребро, удалили, так сказать, но их явно не удаляете, вы вот
этой вот штукой делаете. То есть двигаете индекс. Это значит, что если вы явно уже
удалили ребро, то вы к нему больше никогда не вернетесь. Значит, всего сдвигов может быть не
больше, чем E. Поэтому итоговое время работы. Ну, то есть если мы это суммируем и получаем от
модуль V на модуль E, плюс модуль E, очевидно это вот VE. То есть смотрите, в чем отличие от наивного
подхода, когда вы просто кучу раз запускали DFS? А тем, что вы каждый раз делали фор по всем соседям
вершины, а здесь вы отсекаете вершины, с которых начинаете террироваться просто не надо. То есть
у вас меньше соседей у каждой вершины получается каждую следующую итерацию. Поэтому и время
улучшается с E2 до VE. Вот. Так, надо ли привести какой-то псевдокод? Попробовать. Или так понятно,
плюс-минус, что происходит. Так, ну давайте быстренько время обоснуем, тогда работаем. Я напишу
псевдокод. И что на самом получается? Мы с вами выяснили, что это от VE это удаляющий обход,
а всего это от V. Откуда время работы? V2E. То есть мы квадрат с вами перекинули с E на V. Вот у нас
был VE2, а здесь станет V2E. Грубо говоря, если оценивать осимпточку потоковых алгоритмов в степенях V,
где E у вас порядка V2, в худшем случае, то у вас получается, что было V5, ну такое V5, а здесь V4.
То есть вы на одну степень V понизили время алгоритма. Вот. Так, ну давайте псевдокод привести,
наверное. У вас на семинарах уже должны были быть задачи, где там форт Фалкерсон работает очень
быстро, потому что максимальный поток ограничен очень маленьким числом. В частности, у вас есть
задача про минотавра в листочках. Про минотавра. Там минотавр из лабиринта пытается выбраться,
а вы хотите его замуровать в нем. Вот. И выясняется, что там поток максимально не больше четырех,
и вообще там за линейно от размеров графа время все работает. Вот. Здесь так не получится,
потому что здесь не используется максимальный поток явного оценки. Но опять же, здесь нужно
заметить, что эта оценка сугубо теоретическая, и во всяких других сетях специфичных она может
быть улучшена. Вот. Ну пока что мы это оставим. Это будет чуть попозже. Так, ну давайте будет функция
IntAugment. Augment, дополняющий по-английски. Которая будет, по сути, вот выполнять один
запуск вот этого вот DFS удаляющего. F это поток, который приходит в вершину В текущей. Так,
ну что можно здесь сказать? Что, ну очевидно, что если у вас вершина уже посещена, то там
return ноль какой-нибудь. Да, возвращать мы будем количество потока, которое можно протолкнуть в
итоге. Устат В равно true. Так, дальше что? Наверное, хочется рассмотреть случай, можно ли дойти до T.
Что это значит? Давайте посмотрим, что происходит, что если V это T, то что тогда?
Наверное, нужно просто сделать, верни поток, который пришел. Все. Окей. Так, теперь V неравно T.
Значит, давайте, что сделаем с вами? Что если ребро не в слоистой сети, то мы тоже не идем.
Я напишу это так, что if. А, ну все, теперь нужно, собственно говоря, пробегаться по
соседней вершинке и разбирать случаи. Так, int to int i. Вот, idx это краски массив наших индексов будет.
G от V это список соседей нашей вершины. Ну, я для краткости здесь пишу, понятно, что в общем случае
вам придется код, он будет немножко более громоздкий, но не сильно. Вот так, окей, теперь мы перебегаем
по соседней, и здесь важно, что idx от V. Так, смотрим. Первый случай, что ребро не в слоистой сети.
Давайте сразу напишем, что to равно jet V it. То есть это то, куда у нас ведет ребро. То есть это у нас V, а это to.
Так, if V to не лежит в NFL, то что тогда? Мы говорим plus plus idx от V, ну и заканчиваем эту
итерацию для конкретно вот этой вот вершинки. Вот для idx, для вот этого to мы закончили все. И plus
sum index, потому что мы ее игнорируем теперь. Окей, так мы разобрали, что ребро не в слоистой сети. Так,
теперь давайте разберем, что ребро насыщено. Что если V to насыщено, абсолютно аналогично делаем.
Так, ну и третий случай, это либо мы можем дойти до t, либо нельзя дойти до t. Чем он отличается
тем, какой поток мы сможем пропустить? Логично? Вроде бы логично. Поэтому говорим, что int augment
равен чему? Он нашей функции augment равен от вершинки to и, как я говорил, минимум из двух вещей.
Первое это cf от V to, то есть с остаточной вместимости, и f. То есть это сколько я потока
дополнительно могу пропустить. Ну и говорю return augment, то есть это вот сколько я смог вернуть из
вершинки. То есть я смог найти первую вершину на своем пути, через которую я смог протолкнуть
поток, то есть смог дойти до t. И значит, что это ребро мне интересует, потому что оно может быть
ненасыщенным дальше. Если оно окажется насыщенным, ну как бы все, типа мы его тут вот скипнем.
Допустим, что у нас нет больше ребер, которые нам актуальны. В смысле вы вернулись один раз,
все. Ой, да, да, да, да, да, да, конечно, sorry, я не рассмотрел этот случай, что если augment равен нулю,
то что это значит? Это значит, что вы не смогли достичь t. Если вы не смогли достичь t, то все,
тогда происходит, что plus, plus и dx от v, continue. И если у вас augment не равен нулю,
значит вы можете его вернуть. Здесь говорят, что неприятно писать return из цикла. Ну почему?
Вы нашли в цикле подходящую вас штуку. Значит, просто сразу сделайте return, да и все. Чего мучиться?
Ну и последний случай, это когда у вас здесь отработал целиком фору, у вас ничего не return.
И здесь не return, и здесь не return. Какой тогда return? 0. Это значит, что вы не смогли дойти до t,
грубо говоря. То есть вы не смогли дойти до t, это не интересный случай, можно даже use на самом деле
не рассматривать, потому что у вас сеть слоистая. Поэтому даже можно use убрать по-хорошему. Давайте
его уберем как бесполезный атовизм в ремеграфовых обходах. И для упрощенного анализа получается,
что мы либо возвращаем поток, либо возвращаем augment, но поток мы возвращаем только в том случае,
когда мы дошли до t. Если мы не вернулись отсюда, и augment равен нулю, то есть мы нигде не смогли
вернуть нормальный augment, то тогда получается, что мы должны просто вернуть 0. Мы не смогли дойти до t.
Так здесь return 0. Ну вот такая вот функция. Вот это функция поиска одной итерации. Соответственно,
внутри мэйна у вас будет… Ой, давайте я немножко накринжу и напишу «дувайл».
Давно не видели такого покемона, да? Так, dual f плюс равно dfs… Господи,
это augment у нас функция. Augment от s до s бесконечности. То есть вы считаете,
что вы можете пропустить бесконечное число потока, а потом вас обрадуют, что это неправда.
Вот. Так. Ну и здесь будто бы надо написать, что вы должны перестроить сеть. Я это напишу,
что вы должны, по сути, пропустить поток f. Пропустить поток f. В nfl, да. Наверное,
все. Давайте не так скажем, что f' равно… Пропустить поток f' в nfl. Ну, плюс-минус сойдет,
я думаю, понятно, что имеется в виду while, пока f' не ноль. Ну, примерно так. То есть пока вы
можете найти дополнящий поток, вы его находите. Потом, когда вы не смогли,
значит вы нашли блокирующий поток, и ваш while закончился. Один из немногих примеров,
где нужен while. Потому что можно написать while true, если f' равен нулю, то break. Но это
же неприятно. Так гораздо элегантнее. Ну да, в основном код ревью уроют, скорее всего,
потому что эта конструкция какая-то очень странная. Это, знаете, как говорить с слишком
высоким стилем на русском языке. Вот примерно такая же конструкция while. Давайте подпишем,
что лучше в Augment. Лучше внутри Augment. Соответственно, вот это вот у вас будет функция поиска
блокирующего потока. Да, то есть в итоге у вас алгоритм поиска максимального потока выглядит
как. Он делает вот столько итераций, ну, точнее он вот делает эту схему, по сути, строит nf,
строит nfl, потом вызывает блокирующий поток и делает это. Вот снова do while будет. Do while
блокирующий поток не ноль. Внутри будет вызываться вот этот do while, который вызывает внутри
себя вот этот Augment. Вот такая примерно схема кода будет. Так, ну, про потоки осталось немножко
совсем. А это именно есть две классные теоремы. Товарища Корзанова, тоже советский ученый,
к сожалению, не помню его имени и отчества. Вот у него есть две теоремы про схему Динеца,
а я вам расскажу только одну. Ну, как расскажу? Я расскажу определение, которое нужно, чтобы
сформулировать. Потом сформулирую и не докажу. Вот. А вторую теорему даже формулировать не буду.
Ну, потому что там доказывать очень неприятно. Сразу скажу. Ну, когда я сформулировал Леню,
вы поймете. Давайте так, то есть раздел теоремы Корзанова, определение, назовем c плюс от v
c плюс это максимальная входящая Capacity, c минус от v, соответственно, максимальная исходящая Capacity.
C, v, u. Максимальная входящая C, это максимальная исходящая C. Вот. Окей, тогда сейчас.
И от v, насколько мне не изменяет память, это вот такая вот штука. То есть потенциал вершины в
сети мы обзовем вот такую вот штуку. Потенциал вершины в сети. Дальше что? Ну, уже прикольно, да?
Ну, это вроде еще плюс-минус что-то естественное. Это какой максимальный поток можно пропустить
за одну икарацию, грубо говоря. А теперь вводят потенциал сети. Это вот такая вот странная штука.
То есть по всем вершинам без стока и истока. И от v. То есть это суммарно потенциал сети,
всех вершин, кроме истока истока. Жесть, да? Ну и первая теория Макарзанова состоит в том,
что первая теория Макарзанова. Число итераций в схеме Динеца составляет, вы не поверите,
сколько от Корнеес фиатен. Я думаю, вы не хотите слышать доказательства этого факта. Ладно,
фиатен, но тут еще и корень совсем доставляет неудобств. Ну там, скорее всего, будет везде
заходить, потому что у вас есть оценка v2e. То есть в общем случае у вас оценка будет v Корнеес
фиатен, потому что у вас число итераций вот такое вот. Ну и в худшем случае получается,
что это v. Вот так вот получается. Есть такая оценка, есть еще оценка другая,
которая есть во второй теории Макарзанова. Она про то, что там есть связь неравенства на
следующие величины. Длина максимального пути из СДТ в ребрах, максимальная capacity по всем
ребрам и максимальный поток. Причем очень не очень очевидно, поэтому давайте мы оставим
все это без доказательства и кому захочет, тот почитает подробнее про это все. Ну давайте
рассмотрим, где вот эта оценочка наша применяется прекрасная. Давайте первый пункт единичные сети.
Единичные сети. Это такие сети, в которых C тождественно равно единичке. То есть на всех
ребрах, на которые есть сети, оно равно единице на тех ребрах, которые нет, понятное дело ноль.
Я-то думаю, что не так. Мутные сомнения. Здесь не максимум, а сумма берется. А я думаю,
где я вас обману. Тогда что можно сказать, что потенциал сети ограничен числом ребер.
Можно прямо сходу заявить. Но это вроде тривиальная оценка, потому что у вас фи от в это минимум
с ц плюс ц минус, а сумма по всем входящим и сумма по всем исходящим это краски от я. Фи от м
равен вот е. Но откуда следует, что у вас корень из е итерации. Хорошо, это уже первая радость.
То есть у вас если было от в это, то здесь лучше от корней из е итерации. А вторая радость,
она такая, что давайте рассмотрим удаляющий обход в единичной сети. В чем была проблема
удаляющего обхода, почему он работал за е в? Потому что у нас каждое ребро могло быть
рассмотрено несколько раз. То есть у нас на этом пути далеко не все ребра насыщены,
а только одно. Поэтому все остальные могут быть рассмотрены еще много-много раз. Но что происходит
в единичных сетях? Вы насыщаете сразу весь путь. Поэтому у вас каждое ребро просматривается
суммарно не более одного раза. Ну насыщается, точнее через него протихает поток ровно один раз.
То есть оно либо удаляется, либо через него прозвукнули поток на текущей итерации. А если это так,
то значит мы все ребра посмотрим ровно по одному разу, а значит время работы удаляющего обхода от е.
Каждое ребро насыщается сразу же при пропускании потока.
Из этого следует, что если ребро насыщается, то просматривается ребро один раз. А раз оно
просматривается один раз. Из этого следует, что время работы от е. Складываем 1 и 2,
получаем 3, а еще что время работы единица на единичных сетях от е корней из е. Ну то есть
если у нас е порядка в квадрат, мы получаем уже в f3. Там было в f4. То есть уже мы еще на одну
степень вы понизили оценку. Ну теперь самая мякотка. Это третья часть, которую мы хотим.
Так называемый алгоритм Хобкрофта-Карпа. Ге корней из е. Потому что у вас потенциал е,
она интерация е. Извините, корни из е. Алгоритм Хобкрофта-Карпа. В чем заключается алгоритм
Хобкрофта-Карпа? У вас уже у всех был семинар по потокам и у всех был семинар про просочетание.
Соответственно там вы уже строили сеть про то, как искать максимальное просочетание методом
потоков. Если этого не было, то вы не были на семинаре. Вот где такая. Кратко напомню,
что у нас есть двудольный граф. Просочетание это какое-то множество ребер, у которых нет
концов общих. То есть, например, раз-два. Это не просочетание, потому что у них есть общий конец вот
это вот. И мы хотим в таком графе найти максимальный просочетание. Что мы с вами делали? Кто знает
алгоритм Куна, тот молодец. Кто не знает, тот строил потоки. Эйм настроил сеть, брал исток,
проводил ребра. Сеть ребра ориентировал слева направо. Я не буду, потому что мне лень.
Проводил сюда и везде писал единичные емкости. Ну и дальше максимальный поток в такой сети вам
давал максимальное просочетание. Почему? Потому что утверждается, что в единичной сети у вас
поток разбивается на реберно-непересекающиеся пути. Вот реберно-непересекающиеся пути краски
вам дадут число звеньев в просочетании и все эти пути вам дадут сами ребра. Окей. Так,
давайте оценивать потенциал этой сети. Давайте сразу лучше феатвы оценивать. Так будет проще жить.
По сути у нас капасти равни единицы везде. По сути, мы можем отождествить вот это вот. Все с
числом входящих ребер, число исходящих ребер. Мы всегда берем минимум из числа входящих и
исходящих ребер. Если темы не учитываем в рассмотрение, рассматриваем только основные вершинки.
Так, у этой всегда есть минимум, что одно входящее. У всех вершин левой доли одно входящее, у всех
вершин правой доли одно исходящее. Поэтому потенциал вершины он меньше либо равни единички.
Откуда следует, что потенциал сети непревосходит В? Откуда следует, что время работы?
От Е, корни из В, конец. Ну это все на потоке, что хотелось бы сказать. Там еще очень много
чего есть. Сразу скажу, что для особо интересующихся, как искать поток не за В квадрат Е, а за В куб,
есть метод, как за В куб искать. Есть два варианта. Первый вариант — это там поиск блокирующего
потока методом Малхотра, Кумара, Макешвари. Это три индуса таких есть. Это первый вариант.
Второй вариант — вам придется ознакомиться с техникой проталкивания предпотока. То есть,
вот смотрите, здесь мы что сами делали. Здесь вы сами везде строили остаточные сети и что-то
с ними делали. Это первый подход. Есть второй подход, кардинально и деянно отличающийся — это
проталкивание предпотока. Там будет функция предпотока, у которой там почти поток,
только одно свойство отменяется, ослабляется, точнее, что входит больше либо равно, чем выходит.
Вот вы проталкиваете предпоток, ну и потом вы балансируете, получается поток. Очень краткое
описание того, что там происходит. Пуш префлоу по-английски. И есть еще дополнительно к нему
ивристика, так называемая relabel to front. Она позволяет искать чисто за вакуум максимальный поток.
То есть, еще одну степень вы скинули. Быстрее вакуума, я не помню алгоритмов, возможно, они есть.
Они какие-то, скорее всего, крайне экзотические. На семинаре у вас будет классная штука под
названием масштабирование потока. Как сказать, анонс семинара. Там вы будете применять техника
масштабирования в том, что вы сначала рассматриваете ребра, в которых очень огромный capacity,
потом capacity поменьше, потом совсем маленький capacity, потом жесть, какой маленький capacity.
Вот. И получается, что у вас, если c — это максимальный capacity по всем ребрам, то у вас всего
логарифм c будет итерацией в этом алгоритме масштабирования. И выяснится, что у вас время
ve log c вообще. То есть, если у вас capacity максимальная маленькая, то это еще быстрее вообще будет работать.
Но это будет на семинаре, я это вот краски оставлю, потому что мне лень-то на лекции рассказывать,
уж тем более доказывать. Давайте строки. Тогда все, про потоки закончили. Теперь мы переходим
к последней части лекции, самой большой. Это будут строки. Это будет пятый контест. Это будет
жуть-жуткая. Собственно, на строке, да, у нас будет посвящено много лекций. Почему? Потому что там
будет очень много разных подходов, включая то, что мы изучим немножко математики для строк. Ну,
первый курс может радоваться то, что он таких слов не знает. Второй курс может грустить, что у них
это на сессии еще сдавать. Именно преобразование, фурье и всякое такое дело. Третий курс может
радоваться, что они уже это сдали. Вот, ну их еще ждет гос, поэтому они еще не до конца сдали.
У нас будет с вами конкретная задача, одна по сути. Поиск паттерна в тексте. То есть,
мы хотим с вами искать в тексте какое-то слово. Ну, ctrl-f ваш любимый по презентажкам,
когда вы пишете контрольные. Вот. Как раз-таки он там устроен, вот мы сейчас будем писать ctrl-f с
вами. Ну как, мы писать его не будем, мы напишем алгоритмическую часть. То есть первая задача,
первое лекция у нас будет посвящена задача, это поиск точного вхождения одного паттерна в текст.
Так, окей, это будет первая лекция, у нас будет с вами на лекции скорее всего два метода разобрана,
а третья я оставлю на семинары, потому что мне он не нравится. Вот. Вторая задача у нас будет
уже более интеллектуальная, а именно мы будем искать много паттернов в тексте.
Поиск точного вхождения множество паттернов в текст.
Собственно, под это определение, кстати, прекрасно подходит то, что вы пытаетесь
найти текст по регулярке. Потому что в суть регулярка это множество паттернов,
поэтому когда вы пишете в консоли греб что-то там, вот это вы решаете эту задачу по сути.
Ну и мы рассмотрим алгоритм, который реализован внутри греба. Они решают абсолютно разные
задачи. Лер Парсер разбирает слово бобдивое в грамматике, тогда как у вас здесь будет максимум
что-то регулярное, причем простенькое. То есть у вас мало того, что регулярные языки они как бы
заведомо уже чем контекстно свободные языки. Так еще у вас будет под множество регулярных языков
здесь. То есть совсем все грустно. Лер Парсер пройдет, но по времени он вряд ли зайдет туда.
Окей, так третья. Вот наша такая линейка. Потом третье у нас будет сразу две лекции. Они вот
освещены всяким штукам типа операции с подстроками, назовем это так. Ну из таких примеров найти строку,
которая входит к раз не пересекаясь. То есть найти подстроку, которая входит к раз без сам пересечений.
За линию длинной строки, конечно же. Вот. Собственно, вот эти все штуки нужны в биоинформатике,
когда у вас там геномы всякие разбираются. Потому что у вас там поиск всяких подпоследовательностей,
подозрительных паттернов и так далее и так далее. Вот собственно это вот сюда.
В этом посвящено две лекции, ну полторы. Мы там будем суффиксно автомат устроить. Будем,
точнее, лекцию вводить в теорию и пол лекции строить. Примерно так. И четвертая часть,
она будет посвящена задаче. Вообще у нас будет там две задачи. Это поиск с опечатками. У нас
с опечатками бывают двух типов. Первый тип, это когда мы вместо одной буквы написали другую,
явно, да. Например, не знаю там, без слова текст написали слова. Ну нет, здесь как-то сложно
опечататься в одной букве, потому что все тут явно. Ну не знаю. Ну это сложно. Блин,
здесь все слова, которые очень легко пишутся. Ну не знаю, вместо под строка написать под строка,
например. Вот, ну не знаю, случайно опечатались. Вот, вы будете хотите искать в строке,
есть ли у вас вхождение с опечатками. Вот. То есть, так сказать, вхождение с опечатками,
это первая метрика. Она называется расстояние хемминга. Ей будет посвящено, чтобы ее решать,
мы будем пройдем преобразование фурье как раз таки. То есть, здесь будут два, две метрики. Первая
это будет хемминг. Это преобразование фурье. Фаст фурье трансформ по-русски. Вот. Соответственно,
и вторая метрика, это ревенштейн. Это когда мы разрешаем себе не только опечатки, но еще разрешаем
себе писать меньше символов или больше символов. То есть, например, мы случайно написали слово и
пропустили букву. Мы хотим понять, есть ли слово с пропущенной буквой или с добавленной буквой,
ведь может с к добавленными или пропущенными буквами. Вот. И здесь у нас будет решение это
так называемый алгоритм Ландау Вишкина. Это не тот Ландау, я вам скажу. И давайте я это поставлю
под звездочкой, потому что я еще не уверен, хочу ли это рассказывать. Можно-то не рассказывать,
я согласен. Потому что один алгоритм легкий, там нужно искать кратчайшие пути в графе динамики,
а другой алгоритм нужно строить суффиксные деревья и на них искать кратчайшие пути всякие. Вот.
Соответственно, что еще? Ну и пятое. Это тоже со звездочкой, что хочется. Оно как-то как-то
относится. Но все-таки это всякие свертки, многомерные фурьи. В частности, сюда
рассмотрим, как устроены сверточные нейросети, как эффективно считаются свертки в них. Ну да,
учитывая то, что сначала введет куча математики туда. Ну я уверен, что все умеют брать вот такой
вот интеграл. Ну да, это преобразование в фурьи от функции. Ну вот, и мы будем выводить,
что можно многомерные фурьи расписать как кратный интеграл, что фурье свертки это
произведение фурье. Из этого будем выводить всякие приколы. Ладно, доказывать мы это не будем,
потому что у вас для этого есть мата. Вот. Но я это, так сказать, поясню, когда придется.
То есть вот такой вот план у нас на оставшийся семестр. Соответственно, в контесте будет
это-это-это, вот это FFT будет. Ну в принципе все, в контесте больше ничего не будет,
поэтому контест будет, скажем так, он будет до конца семестры идти,
однако последние лекции будут не в контесте, а так чисто научпоповский материал. Конечно.
Так, ну все, тогда я вас, пожалуй, отпущу, потому что за пять минут мне Лень что-то рассказывает.
