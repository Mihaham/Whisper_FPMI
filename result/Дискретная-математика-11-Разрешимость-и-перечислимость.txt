Сейчас вот как раз мы начнём теорию алгоритмов. Что нужно сказать, какой базовый объект тут
изучается? Базовый объект у нас называется частичной функцией. Смотрите, функция f,
обозначение вот такое, буква p над стрелкой пишется, называется частичной функцией.
Если f у нас, отношение f, f это множество пар, как вы понимаете, отношение f,
функционально, но не обязательно тотально. Ну то есть почему оно частичное? Тотальности,
просто функциональное требование. Функция обычно, как понимается, тотально-функциональное
отношение. Здесь просто функциональное отношение. То есть у нас есть область определения. Почему мы,
кстати, в теории алгоритмов будем рассматривать функции строго всегда? Либо из n в n, либо из n
квадрат в n, либо из n в куб в n, либо из n в степени k в n. То есть мы такие объекты будем рассматривать.
Например, это вот такой стандартный вопрос с троечником на экзамене. Они очень часто это
забывают говорить. Сейчас мы определим, что такое вычислимая функция. Откуда может быть определена,
где может быть определена вычислимая функция. Например, на r может быть определена стандартный
вопрос с троечником. Некоторые говорят, что может. Почему никогда в теории алгоритмов
действительно значные функции не рассматриваются? Догадайтесь. Если мы говорим про математику,
они какие-нибудь там компьютерные, ну вот практически компьютерные науки, в которых в памяти
компьютера фактически задаются именно рациональные числа. Там действительных чисел нет. Действительные
числа, чтобы записать действительное число в памяти компьютера, нужно затратить бесконечно
много места. У нас такого диска не существует, на который вы бы смогли записать одно действительное
число. Потому что это бесконечная последовательность из нулей единиц, например. А соответственно,
для хранения бесконечной последовательности из нулей единиц нужна бесконечно большая память. То
есть вы даже вычисления не начнете. Вы просто записать это число в алгоритме не сможете.
То, что в практических приложениях это округление, рациональное округление действительных
чисел. Действительные числа компьютер запихать невозможно. Вот. Поэтому вот в практических
алгоритмах, опять же, нельзя даже сказать, что мы можем вычислять значение функций от рациональных
аргументов. Потому что может быть, это может быть задано слишком длинной дроби. Ну слишком
длинной период у этой дроби может оказаться правильно. И мы, опять же, не сможем это сохранить.
Вот. То есть вопрос в объеме памяти, доступной нам для хранения. Опять же, то есть в компьютере
хранится не все рациональные числа, только рациональные числа с довольно коротким периодом.
С большим периодом, опять же, точности мы сохранить не можем. Математика, она не про
приближение и не про округление, а про точные значения. А соответственно, точные значения
недействительного числа, ни вообще плохого рационального числа вы записать не сможете просто.
Вот. Поэтому берутся то, чего мы действительно можем записать, то, чего мы можем сохранить,
то, чего можем обработать. Натуральное число. Вот. Либо пару натуральных чисел, либо тройки
натуральных чисел. Это тоже хорошо хранится. Либо там четверки и так далее. То есть вот вычислимые
функции и все функции, которые в теории алгоритмов рассматриваются, они определены только вот на
таких множествах, которые можно записать в памяти. Машина тюринга, например. Машина тюринга тоже,
ну в принципе потенциально машина тюринга может сохранить действительно одно действительное число,
но есть беда. Есть требования, что в каждый конечный момент времени на ленте только конечная
область занята должна быть во время вычислений. Для действительных чисел это невыполнимо. Вот.
Ну что ж. Смотрите. То есть понятно, да, что такое частичная функция. Во-первых,
буду писать из n в n, но потом у нас появятся функции из n квадрат в n, из n куб в n. То есть
в принципе можно чуть больше такие множества рассматривать. Вот. Но давайте просто, чтобы
немножко, ну просто чуть-чуть упростить. Вот из n в n, скажем, частичная функция. Значит,
определение f из np, а вы букву p понимаете почему? partial, partial, от слова partial частичная. Вот.
Вот. Значит, частичная функция f вычислена, если
существует машина тьюринга, которая по номеру, по числу n налетит, ну по аргументу n налетит,
которая по аргументу n налетит, либо вычислит f от n, либо вычислит f от n за конечное число шагов
Но это в этом случае, если f от n определено. Как вы понимаете, функция частичная, поэтому в некоторых
точках она может быть просто неопределена. То есть f от n символ на самом деле плохой,
неплохо было бы записать что-нибудь вот такое, как я писал там в логике. Здесь это все-таки f от n
понимается, что здесь есть значение, есть значение, это не придумано для частичных функций. Вот такое
обозначение, это пустое множество там, если здесь не определено и значение, если определено. Вот.
Но давайте уже традиционно использовать. Вот. Если f от n определено, или никогда не закончит
вычисление, то есть она зациклется и никогда не закончит вычисление, если f от n не определено,
или не остановится никогда, если f от n не определено.
Не определено. То есть вычислимая функция, что значит, если неформально, то это функция,
для которой есть машина тюринга, которая эту функцию вычисляет, но из натуральных натуральный.
Вот. А что значит машина тюринга вычисляет? Если функция определена, то она вычислит
законечное число шагов и остановится, если не определена, то никогда ничего не выведет,
а зациклится. Вот. В этом, кстати, в определении такой вот хитрость хранится. Короче говоря,
идея в чем в том, что алгоритмически законечное число шагов мы не сможем определить,
остановится когда-либо или нет. То есть как бы определенность вычислить нельзя алгоритмически
задать. Определенность функции, алгоритм просто данный алгоритм, считающий данную частичную
функцию. Определена эта частичная функция на n, по алгоритму понять алгоритмически g нельзя,
анализируя сей алгоритм. Это мы докажем. То есть вопрос остановки, то есть когда-либо
вот оно остановится, вот в законечное время понять это нельзя. Вот. Значит, смотрите,
а с этим связано, собственно, понятие разрешимое перечислим множество. Смотрите. Определение
под множество, а под множество n называется разрешимым, если существует, если функция
вот такая х, х, х, х, х, который равна единице, если х принадлежит и ноль, если х не принадлежит.
Вот эта функция разрешима, вычислима. В частности, она тотальная. То есть в данном случае
В любом случае, получается, она иногда, можно сказать, тотально вычислима,
чтобы отметить, что она ещё и определена всюду,
а можно просто сказать, вычислима достаточно будет.
То есть, характеристическая функция вычислима,
то есть мы можем при помощи машины чьюринга по данному числу выяснить,
принадлежит это число множеству или не принадлежит при помощи алгоритма.
Вот. Это называется разрешимое множество.
Перечислимое это вот что.
Под множество называется перечислимым
Я пишу немножко упрощённо, а под множество n.
Вообще говоря, мы можем рассматривать разрешимые перечислимые под множество вн, декарта вн.
Вн, декарта вн, декарта вн.
Вот, короче, вот эти конечных декартовых степенях натурального числа
тоже есть разрешимые перечислимые под множество.
Ну вот, просто поймите.
Ну вот, например, вн это уже нельзя рассматривать.
Понимаете, да, потому что там алгоритмы нельзя задать.
Вот.
Значит, перечислимым, если существует перечислитель.
Перечислитель, что такое перечислитель?
Машина тьюринга, которая без входа в любом порядке...
Вот так, да, в любом порядке на ленте выводит все элементы.
Важно, чтобы было видно все элементы.
Не требуется, чтобы они, например, не повторялись.
Оно может повторять их сколько угодно раз.
Вот.
И второе условие для перечислителя, то есть это машина тьюринга,
которая на ленте в каком-то порядке можно с повторениями выводить элементы А.
И работает бесконечно долго.
Ну, то есть она бесконечно долго работает и за это время должна вывести...
Какое главное требование, что за конечное время должен появиться любой элемент А,
если он присутствует в перечислимом множестве?
Там еще нет входа.
А?
Значит, без входа.
Ну...
У нее нет там на ленте в начале ничего написанного.
Она пишет...
У нее нет данных для обработки.
Она просто начинает работать и выписывать элементы А.
Все.
Поэтому называется перечислитель.
Она просто начинает работать и выписывать элементы А.
Все.
Поэтому называется перечислитель.
Понятно, что это вообще соответствует только счетным множествам.
То есть совсем.
Для несчетных это вообще бред такое понятие.
Вот.
Ну, и вообще я вам пояснил, почему ВЭР это плохо вообще определять.
Ну, вот.
Значит...
Конечно.
Ну, да, собственно...
Ну, какие...
Давайте примеры какие-нибудь приведем.
Примеры.
Примеры.
Любое...
Давайте...
Любое конечное множество разрешимо.
Любое конечное множество разрешимо.
Ну, естественно, опять я это пропускаю, но мы все под множество опять предполагаем под множествами N.
Это, кстати, вот...
Знаете, почему?
Видимо, вот в тех конспектах, на которые я ссылаюсь, там вот это в начале такой вот строкой написано.
Все множества под множество N.
Ну, вот.
Там вот это в начале такой вот строкой написано.
Все множества под множество N.
Больше мы про это не упоминаем.
И дальше в определениях про это не говорится.
И потом, как в какой-нибудь переиздаче, спрашиваешь вот...
Конечное множество там разрешимо.
Оно конечное множество чего?
Какой там универсум?
Или это множество под множество всех множеств?
Не знаю.
Вот.
И начинаются очень интересные варианты.
Никто почему-то вот N не говорит.
Почему-то все мыслят более широкими рамками.
Не понимаю почему.
Вот.
Вот.
Значит...
Любое, конечно, множество разрешимо.
Но почему?
Ну, собственно, здесь можно даже программу...
Вообще говоря, есть...
Вот это не математическое утверждение от слова «совсем»,
потому что математическое утверждение так не формулируется.
Но это называется тезис...
Блин.
Чёрти росы.
Вот.
Чёрти росы.
Распомнил.
Вот тезис...
Он говорит, что любая интуитивная модель алгоритма
может быть задана машиной тьюринга.
Почему не математическое утверждение?
Потому что непонятно, что такое интуитивная модель алгоритма.
Вот.
И формально это не задать.
Вот.
Но, то есть, можно просто переписать алгоритм,
который вычисляет, руками.
Типа вот, если x равно a1, то 1 выводим.
Если x равно a2, то a2 выводим.
И так далее.
Если x равно an, an выводим.
Иначе выводим 0.
Всё.
Вот просто алгоритм пишется для конечного множества.
Эти все элементы множества хранятся в этом алгоритме.
И, собственно, сравнивается данное число с этими элементами.
Но в машине тьюринга это можно хранить в виде состояния, например.
Но, опять же, вы видите, в данной теории мы описываем алгоритм вот так, руками, махая.
Почему?
Потому что, на самом деле, если мы нормально систематически эту всю теорию здесь будем задавать.
Например, писать машины тьюринга вот здесь.
Нормально программировать машины тьюринга вот тут.
Есть такие книжки, но они очень тяжело читаемые.
Там ужасно.
Ну вот базовые вещи, которые мы докажем чуть позже.
Условно докажем.
Я не скажу, что я приведу вам доказательства.
Потому что настоящее доказательство – это целая книжка.
Ну там реально человек действительно заморочился и написал машину тьюринга,
которая вычисляет так называемую универсальную вычислимую функцию.
Он разбирал классы вычислимой функции.
Там целая теория была из-за этого построена.
Мы же скажем просто, что она, грубо говоря, существует.
Потому что оно безумно.
Если в конкретной модели начнем еще алгоритмы,
еще пытаться эту теорию построить в конкретной модели,
скажем, только машиной тьюринга,
тогда тут вообще начнется…
Мы будем вынуждены на каждый чих машины тьюринга писать,
и это будет очень сложно и долго, и мы сильно не продвинемся.
То есть поэтому тут много таких неформальных мест,
где мы говорим, что есть алгоритм,
и мы задаем каким-нибудь удобным для нас способом его.
Это сам алгоритм.
Скажем, какой еще пример?
Ну, например, 1, 3, 5, 7.
Оно разрешимо.
Как алгоритм примерно писать?
По данному числу выясняет, принадлежит ли,
четное ли число или нет.
Ну, например, да, когда машиной тьюринга там двоечное в виде.
Да, элементарно, двоечное в виде.
То есть любые числа, которые отличаются друг от друга,
любая арифметическая прогрессия,
даже бесконечная вы можете записать,
она тоже будет разрешима.
Но, ребята, то есть множество,
которое вы начнете сейчас придумывать,
они все, как ни странно, оказываются разрешимыми.
Просто мозг так и работает.
На самом деле не все множества разрешимы
и не все множества перечислимы.
Сейчас два вот этих понятия,
как они взаимоотносятся,
давайте сейчас как раз и будем изучать.
Смотрите, ЛМ-1.
Если А под множество разрешимо,
то А перечислимо.
То есть любой разрешимый множество перечислимо.
Давайте докажем.
Ну вот, по предположению,
по нашему предположению,
хиата,
предположение,
хиата,
тот х,
вычислимо.
Больше того, давайте сразу отметим,
тотально вычислимо.
То есть за конечное,
неважно какое число тот х будет подано,
за конечное число шагов
мы выясним, принадлежит ли это число
множество или не принадлежит.
Тотально вычислимо.
Как мы построим перечислитель
нашего А?
Перечислитель работает так.
Значит, он в бесконечном цикле берет все натуральные числа.
Перебирает все натуральные числа.
В бесконечном цикле.
Перебираем все натуральные числа.
Все натуральные числа.
И проверяем,
принадлежат ли они множество
или не принадлежат.
И вычисляем
хиаатен.
Если хиаатен
равно единице, то он печатаем.
Если нет, то нет.
Поняли, да?
То
n печатается.
Иначе нет.
Поэтому иногда, кстати,
перечислитель определяет,
как машина чьюринга с двумя лентами.
Одна, грубо говоря, для вычислений
промежуточных, а другая
для вывода итога.
Так проще даже представить.
Но, в принципе, двухлетночную
можно заменить одноленточной.
Правда, там будет
в какой-то отдаленной области
вычисление производить.
Понимаете, да?
Ну вот.
Смотрите, в чем
собственно утверждение
доказано.
В чем хитрость. Главное
это тоже интересный вопрос все время
на экзамене спрашиваю.
Вот, например,
выяснили, а разрешима?
Да, конечно, а разрешима.
В том числе, кстати, пустое
множество разрешима.
Ну, программа,
которая выдает все до ноль,
легко написать программу.
Значит, отсюда по нашей теории
выходит
любое конечное множество,
в том числе пустое, перечислимо.
Я все время спрашиваю,
а как будет работать перечислитель,
который перечисляет конечное множество?
Ну вот, если
просто по доказательству
теории мы пройдемся,
что он сделает?
Он будет проверять
в бесконечном цикле,
принадлежит ли
элемент множеству.
Значит,
понятное дело,
что на каком-то конечном шаге
он выведет все элементы.
А что после этого будет?
Он будет ничего не писать.
Он будет ничего не писать,
но бесконечно долго работать.
Понимаете, в чем дело?
Поэтому я здесь
обязательно приписал,
работает бесконечно долго.
Даже для конечных множеств он работает
бесконечно долго.
Даже если нужно вывести, перечислить,
грубо говоря, пустое множество,
то что он будет делать?
Он просто зациклится, но он никогда
не напишет, но он будет бесконечно
долго работать.
Опять же,
почему вот здесь
по-другому никак нельзя?
Потому что у нас
мы на самом деле алгоритмически
не сможем выяснить
хиата.
Нам дан алгоритм для хиата,
вот мы больше ничего не знаем.
Нам вот этот алгоритм
только известен.
Мы не сможем выяснить
хиата.
Остановит конечное множество
за этот алгоритм или нет.
Поэтому мы вынуждены перебирать
именно все натуральные числа.
И поэтому
здесь никак по-другому не можем.
Ну что ж,
что еще?
Давайте
докажем, что есть
неразрешимое множество.
Каких?
Неперечислимых.
Давайте неразрешимое
приведем, а то оно же будет
неперечислимым.
Привести я его не смогу,
как ни странно.
Я грубо говоря
мощностными аргументами покажу,
что оно есть.
А вот пример неразрешимого
или неперечисленного множества
я дам позже, конструктивные примеры есть
сразу говорю.
Пока что это статистический аргумент,
грубо говоря.
Просто статистический аргумент
работает следующим образом.
Разрешимых множеств
счет намного на самом деле,
потому что каждому разрешимому множеству
соответствует алгоритм.
Алгоритм счет намного.
Алгоритм это конечный последствий
каких-то четко заданных команд.
Таких конечных последовательностей
счетно.
А под множество натуральных чисел,
континум,
поэтому конечно же найдется
среди континума
только разрешимых
и перечислимых,
перечислим тоже соответственно алгоритм.
Их счетно много,
а значит есть
неразрешимые и не перечислимые,
но значит и не перечислимые
множества.
Их тоже континум, их очень много.
Ну вот написать
конструкт,
прям вот явно привести пример
неразрешимого множества
можно, но это будет позже.
Потому что для этого
нужно некую теорию
развить с вами.
Так называемых универсальных вычислимых функций.
То есть пока что я просто
статистически,
мы просто выяснили мощность
множества разрешимых и перечислимых
множеств их счетно
и мощность всего
под множество, континум.
Значит есть и не перечислимые
и не разрешимые
их тоже континум.
Так.
То есть смотрите,
но понятное дело,
что они есть
и они как минимум бесконечны.
То есть поэтому например
на доске их выписать не смогу.
Вот.
То есть неразрешимые
множества есть
и не перечислимые есть.
Больше того, смотрите в обратную сторону
любой перечислимая разрешимка
тоже это неверное утверждение.
И есть перечислимые,
но неразрешимые множества.
Но опять же
конструктивный пример
такого дела
я дам позже,
когда мы будем изучать с вами опять
универсальные вычислимые функции.
Пока что на базовой теории
лучше
мы не сможем это сейчас
произвести такой пример,
построить. Он будет, он позже будет.
Вот.
Значит ну давайте
следующую гемму.
Но это про операции,
которые сохраняют перечислимость
и разрешимость.
Операции, сохраняющие
перечислимость
и разрешимость.
Смотрите,
первая
если
A-B
разрешимый,
то
A объединенное
B,
A пересечь
B,
A дикартово-B.
Опять вот я говорил,
мы можем с вами
собственно говорить про разрешимые
перечислимые подмножества
в N дикарта ВН.
Вот это одно из подмножеств
N дикарта ВН.
Вот.
A дикартово-B,
A дополнительное,
тоже разрешимое.
Но еще можно дописать вот такой
объект проекции A.
Что такое проекция A?
Это проекция
подмножества N дикарта ВН
с координат.
Понятно, да?
Сейчас напишу.
A подмножество N квадрат
в данном случае.
Ну или N степеника.
A опять же
разрешима.
Вот это преамбула для всех остается
с одноэтажа.
А N степеника это те
N, что
существует
N1,
N2,
Nk-1,
Nk-1.
Ой-ой-ой.
Ng.
Проекция g.
Nk такое что?
N1,
Ng,
минус 1 на
здесь, вот тут N.
Вот тут Ng плюс 1
Nk
принадлежат
Понятно, да?
Ну то есть мы, что такое?
У нас вот множество натуральных чисел,
вот такое последовательство.
Мы собираем только одну компоненту.
То есть убираем все остальные
компоненты, берем все
элементы нашего множества,
берем только одну компоненту.
Собираем все эти компоненты множества,
это получится проекция.
Значит разрешима.
Подождите.
Подождите, про проекцию
может быть Махо дал, может быть
это неверно, подождите.
Для разрешимости конкретно,
для перечисления, да,
это перечислимая проекция, простите.
Проекция это не здесь
должна быть.
То есть проекция разрешима множество,
вообще говоря, перечислима.
Вот это можно точно сказать,
но не факт, что она разрешима.
Вот так.
Ну и вторая часть
нашего утверждения, AB,
если AB
перечислимы,
то
A объединить B,
A пересечь B,
A Декартова B.
Вот о дополнительной
нельзя сказать, кстати.
Если A перечислима, то
о дополнительной, вообще говоря,
не обязательно перечислима.
И примеры у нас будут,
когда A перечислима,
а дополнительной нет.
Но они тоже даются
при помощи универсальной вычислимой функции.
Ну и проекция.
То есть A под множество Н-степеника,
проекция это те
НСН,
для которых существует
Н1, существует Н2,
существует Nj-1,
существует Nj-1,
существует Nk,
такое, что N1,
Nj-1, N,
Nj-1,
Nk
из A.
Вот эти множества перечислимы.
Вы говорили о дополнительной.
О дополнительной.
Это чуть позже.
Вот следующий.
Я сейчас скажу, это интересный момент.
Я скажу,
потому что у нас будет следующая
теория, и вы поймете, почему.
Вот. Пока...
Пока.
Как я сказал,
почему не обязательно, если A перечислимо,
а дополнительно не перечислимо,
это будет из следующей лему, видно.
А вот конструктивный,
конкретный пример,
когда вот именно так происходит,
это когда мы уже будем универсально вычислимую функцию изучать.
Так.
Следующая теорема,
это так называемые критерии Поста.
Да, вы его знаете, нет?
Но это не для булевых функций,
а да.
В теории алгоритмов есть тоже критерии Поста.
Он звучит так.
A разрешима
тогда и только тогда, когда
A и A дополнительные перечислимы.
Одновременно.
Вот.
Это вот критерии разрешимости множества.
Реказательство вот этого.
Сначала давайте вот это докажем,
потом вот критерии Поста.
Ну, давайте.
Вот A, B разрешимы.
Как разрешить A объединить B?
Ну да, да, да.
Запускаем алгоритм
вычисляющий хиасы,
вычисляющий хиата
и вычисляющий хиат B.
Если один из ответов,
который хотя бы один из алгоритмов
выдал единица, то
тоже и выдаем единицу, иначе ноль.
Так?
Как перечислить,
разрешить A пересечь B?
Опять запускаем
алгоритм вычисляющий хиата,
хиат B, если обе единицы,
то
печатаем единицу, иначе ноль.
Так?
А дикартово B.
Хиата, хиат B.
Если обе единицы, то пара
принадлежит
А дикартово B.
Ну нет, ну у нас A, B
разные же. То есть у нас хиата,
да там две программы соответственно.
Можем их как-то параллельно
запускать, но вот как-то вот.
То есть у нас две программы,
запускаем по очереди. Вот.
Как разрешить дополнительное?
Да. Вычисляем
хиата, хиат X.
Если
единица, то выводим ноль,
если ноль, то выводим
единицу, инвертируем
ответ. Это будет
вычисление характеристическая
функция, а дополнительная. Вот.
Теперь. Перечислитель.
Вот есть перечислитель A,
перечислитель B.
Как перечислить A
объединить B?
Перечислять по варианту.
Да, да, да, правильно, правильно.
Можно даже там, знаете,
как Мусатов любит рассказывать,
он
говорит, ну можем по очереди шаги
алгоритмов перечисления A,
перечисления B делать. Сначала один, потом
второй. Когда какой-то алгоритм решит
напечатать что-то,
печатаем. Вот. Потом запуск
по очереди опять продолжаем.
И так далее. То есть шаги
не обязательно же приводят к тому, что
что-то вводится, он просто может быть
посередине какого-то вычисления.
Вот. Когда алгоритм
решит что-то напечатать, вот, печатаем
это. Вот. То есть мы
по очереди запускаем два алгоритма
и печатаем оба вывода
этих самых алгоритмов.
Так перечислим A,
как перечисить A пересечь B?
Да. То есть мы должны
отсортировать вывод, так сказать.
То есть что у нас будет? Мы
должны вывод алгоритма
A, вывод алгоритма B
сравнивать
постоянно и
выводить только общие элементы.
Да?
То есть выведенные элементы
A, выведенные элементы B
сравнивайте те, которые
появились на той и на той линте,
вводить в общий вывод.
Так?
Почему?
А какие выводы должны быть?
А когда проверяешь, что
что-то вывели или
что-то сравнивали?
Если какой-то алгоритм есть,
этот алгоритм
безусловно будет работать
очень долго.
Вопросов нет.
Тем не менее.
А вот как перечислять A
дикарту B?
Ну тут еще длиннее.
Смотрите алгоритм. Перечисляем
элементы A,
перечисляем элементы B.
На самом деле делаем вот так.
Делаем шаг алгоритма перечислителя,
шаг алгоритма перечислителя B.
Когда что-то новое
будет выведено на каждом шаге,
берем все элементы,
которые на линте для A выведены
и выводим пары
этого нового B
со всеми перечисленными
элементами A.
Так?
Если появилось что-то новое
на перечислителе A,
то выводим все пары
нового элемента со всеми
перечисленными элементами B.
Только так. По-другому никак нельзя.
Ну и вот так
по очереди действуем.
То есть нам нужно обрабатывать весь выход
с самого начала.
Конечно, бесконечно долго.
Конечно долго, но очень долго
это все будет работать.
Значит, проекцию
как перечислить?
Перечисляем вот эти
кортежи
по алгоритму.
И выпечатаем только
нужную позицию.
Согласны?
Это все.
Так. Ну ладно.
Видите,
если я сейчас начну это записывать,
долго будет. Давайте.
Вот, чтобы быстрее. Следующий LEMO.
LEMO 3.
Критерии поста.
A под множество N.
Разрешено.
Тогда и только тогда, когда
A и A дополнительно перечислим.
Давайте доказать.
Смотрите, ну пускай вот в эту сторону.
Пускай A разрешено.
Как перечислить
A дополнительно?
Ну да, следует перечислить.
Все правильно. А почему следует перечислить
A дополнительно?
Ну да, в принципе,
все правильно.
То есть A разрешимо.
Давайте вот в этом.
Значит, A дополнительно разрешимо.
Значит, A дополнительно перечислим.
По LEMO 1.
А это по LEMO 2.
Все.
В обратную сторону.
Вот теперь мы знаем, что A
дополнительно перечислим.
Почему
тогда разрешимо?
Ну как разрешить A?
Вот так.
Вот тут очень
такой неэффективный алгоритм
сразу говорю.
Но какой есть?
Значит, по
числу
X
и Z
запускаем
перечислитель A
дополнительно.
Запускаем перечислитель A.
И собственно,
если X появится
на перечислителе,
на выводе перечислителя A,
то выводим один,
если X
появится
на выводе
перечислителя A,
то выводим один,
если X
появится
Если на выводе перечислителя
а дополнительное, то выводим 0.
Ну, собственно, либо там, либо там он появится, да? Ну и всё, так мы вычисляем характеристическую
функцию. Ну вот, вот, собственно, критерии. Вот почему, так, косвенно, почему из-за того,
что а перечислимо, не следует, что дополнительно перечислимо. Потому что, если это одновременно
происходит, то разрешимо, но не всякое перечислимое множество разрешимо. То есть, если множество
перечислимо, но неразрешимо, то само собой дополнение к нему уже перечислимо не будет,
потому что иначе по критерии пост оно было бы разрешимо. А вот конструктивный пример
перечислимого, но неразрешимого множества я приведу, мы построим, ну, позже. Вот.
Вот теперь довольно сложная часть сейчас пойдёт. По крайней мере, почему-то на экзамене студенты,
не только трошники, кстати, довольно сильные студенты, почему-то тут путаются и всякие глупости
говорят. То есть, как бы я даже стал считать, что она для отличников, что ли. Вот. Такая типа сложная,
потому что немногие в ней разбираются. Значит, смотрите. Ну, как мы выяснили, по критерии пост,
даже разрешимость можно проверять через перечислимость. То есть, нужно какие-то признаки
перечислимости. Как проверить перечислимость множества. И тут вот у нас вот такая теория.
Давайте даже циркулируем. Пусть А под множество N перечислим. Тогда. Следующие. Пусть А под
множество N. Вот просто. Вот так. Вот так. А под множество N. Тогда следующее утверждение эквивалентное.
Первое. А перечислимо. Первое. Второе.
Существует частичная функция из N в N. Такая, что область значений функции равна вычислимою.
Я забыл отметить. Вычислимо. То есть, область определения вычислимой функции перечислима.
Опять же, вообще говоря, нет. Не является разрешимой. Только перечислима. Третье.
Существует частичная функция из N в N. Вычислимо. Такая, что range f равна. И так.
Четвертое. Волшебный критерий. Значит, перечислимость звучит следующим образом.
Существует тотально вычислимая функция из N в N. Тотально вычислимая. Такая, что
range f равна. Ну, чаще всего, вот в эту сторону мы будем использовать. Если а перечислимо,
то есть тотально вычислимая функция, область значений которой равна. Это нам очень часто будет
удобно использовать. Ну и пятое. Значит, сейчас я, чтобы не запутаться, подсмотрю. Существует разрешимое
N. B под множество N квадрат. Такое, что проекция на первую координату A равно
проекция на первую координату B. Вот она. Зачем? Ну, удивительно, что они эквивалентны. Мы на самом
деле как-то вот примерно так и будем доказывать на самом деле. Оно более сильное, безусловно,
но все-таки иногда и это пригождается. А то удивительный факт заключает в том,
что они эквивалентны, понимаете? Один действительно выглядит более сильным, но они одинаково на самом деле.
А на сколько времени осталось? В 19.10 же, да? Просто довольно длинная теорема. Ну давайте.
Значит, ну давайте один эквивалент на два. Сначала. Если A перечислимо,
то как найти такую функцию, у которой область определения совпадает с A? А перечислимо.
А тогда вот такая функция, я определю ее из чертой. Это не характеристическая, это так
называема полухарактеристическая функция. Она выглядит следующим образом. Это единица,
если x принадлежит A, и не определена, если x не принадлежит A. Полухарактеристическая функция
называется. Она вычислима. Почему? Как вычислить, какой алгоритм вычисляет эту функцию? Значит,
смотрим на вывод перечислителя. Если там появился x, то пишем единицу. Ну короче,
ждем, пока появится x. Если x не принадлежит A, то он никогда на ленте не появится. Но за
конечное время выяснить не сможем. Поэтому это неопределенное значение. То есть там никогда
машина зациклится, будет бесконечно ждать, пока появится не принадлежащий множество A, а элемент,
и поэтому здесь неопределенное значение. Поняли, да? То есть по сути, алгоритм заключается в том,
что мы выводим все все перечисляем все элементы A и ждем, пока нужны нам появиться. Если появится,
пишем один, если не появится, ничего не делаем. Все. Вот. Она вычислима. Кстати, отсюда же,
почему я так акцентирую внимание на вычислимость каких-то функций? Потому что давайте тот же самый
статистический аргумент применим. Сколько у нас алгоритмов? Счетно много, да? Потому что
характеристи... вычислимым функциям соответствует алгоритм. А сколько у нас всего функций из N в N?
Континум. Поэтому, опять же, вычислимых функций их мало, вот. И поэтому каждую нужно доказывать,
что она вычислима. Вот. Значит, ну, в обратную сторону, если существует вычислимая F из N,
частичная функция из N в N, такое, что domain F равна... Пускай мы знаем, что существует. Почему?
Почему тогда перечислима? Как перечислить область определения функций? Как вы думаете? Как я вам
уже говорил, вы за конечное время не выясните, закончится ли вычисление или нет. То есть понять,
как бы, алгоритмически конкретная точка, что конкретная... Почему я ваше обращаю внимание?
Я сейчас пытаюсь построить не перечислитель, а разрешитель этого множества. То есть алгоритм,
который по точке выясняет, принадлежит или нет этому множеству. Это нельзя сделать. Разрешитель,
вообще говоря, построить. Перечислитель можно. Сейчас я расскажу. Значит... Да, нам нужно
перечислитель, поэтому сейчас его построим. Значит, смотрите. Что мы можем сделать? Вот тут
нужно определить вот такую штуку. Такие скобочки будут обозначать тотально вычислимую нумерацию пар
натуральных чисел. Это вот такая штука. Сейчас я перепишу вам формулу. Вот это тотально вычислимая
биекция из n² в n. Тотально вычислимая, потому что вот формула. Тотально вычислимая биекция
из n² в n. Вот. Как мы здесь будем работать? Смотрите. По паре. Значит, смотрите,
что делаем. Берем элемент, собственно говоря, к натуральный и... А, да, забыл сказать. Прошу прощения.
Смотрите. Вот. Поскольку биекция, то вот для каждого натурального можно представить единственное
k такое, что k это номер пары m, n, да? Так, ребят? Отсюда есть обратная функция. Она тоже вычислимая.
Это n, это p1 от k, а m это p2 от k. Вот эти обозначения потом понадобятся дальше. Мы это тоже будем
использовать. То есть, это p как бы обозначает проектор, но этот проектор странный. Обратите
внимание. Проектор обычно функции из, там, не знаю, из a², да? Ну, из lz, из a². В данном случае этот
проектор из n-ven. Он по номеру пары выясняет какая пара и выдает нужную компоненту этой пары. То есть,
это функция из n-ven, тотально вычислимая. Как выяснить по номеру пары, какова пара имеет данный
номер? Ну, можно тупо перечислять эти пары, считать их номера, сравнивать и потом найти, да?
Но по-другому вроде даже непонятно, как еще это делать. В натуральных числах? Не знаю,
честно говоря. Я не вижу, как их решать в натуральных числах, честно говоря. Ну, это же,
нет, то, что это биекция, это легко проверить, на самом деле. Я не хочу просто сейчас проверять,
но это довольно легко проверять, что биекция. Как проверить, что это биекция, что у любого
натурального… Ну, сюррективность надо показать, что у нас тут, собственно говоря,
все натуральные числа встречаются. И инъективность. Инъективность там проверяется довольно просто.
Ну, сюррективность… Я уже забыл, знаете, как мы делаем, мы просто в первом семестре даем вот
такую задачку, там студенты нам решают ее. А во следующем мы просто используем этот факт. Я
сейчас забыл, как… Но студенты обычно быстро догадываются, как тут сюррективность показать,
что существует такое натуральное, что существует пара с таким номером. Ну вот, то есть условный
проектор работает следующим образом. Он пока вычисляет пару с номером таким, а потом выдает
компоненты этой самой пары. Это тотальная отчисленная функция из n-th. Это тоже тотальная
отчисленная функция из n-th. Вот. Значит… Ну вот теперь. Вот теперь. В бесконечном цикле
перечисляем k, kaizen. Находим пары с номером k. Находим пары.
Mn из n-квадрат. Пару. Mn из n-квадрат. Такое, что… Нет, вот так обозначим xk. Такое,
что xk… Номер xk равен x… Нет, x… Нет, k использовано. Но давайте l. l, l, l. xk равен l.
А потом делаем вот какое действие. Затем… Затем. Значит, запускаем алгоритм вычисляющие и делаем
k шагов этого алгоритма. Почему именно пара понадобилась? Вообще говоря, по входу вы не
сможете понять, закончится ли этот алгоритм. Но k шагов проделать этого алгоритма и выяснить,
что он там выдал или не выдал, вы сможете. Правильно? Так, ребят. Запускаем алгоритм.
Алгоритм. Вычисление f от x и делаем k его шагов.
К первых его шагов. Если алгоритм за k шагов либо раньше остановился, либо за k шагов вывел ответ,
если алгоритм на входе x за меньше либо равно чем k шагов вывел ответ, то, собственно,
нам нужно перечислить domain, перечисляем x, печатаем x, то печатаем x. Иначе переходим
к следующему числу, к следующему, к l плюс один. Понимаете, да? Иначе переходим к следующему l.
Всё. Вот перечислитель области определения. Понятно, да? Также можно, кстати, перечислить
вычислимые функции. Вы не сможете, собственно, если функция x не определена в какой-то точке,
выяснить это за конечное число шагов. Но, опять же, вот таким же образом вы перечисляете область значений
функции. То есть, если алгоритм на входе x за k шагов вывел ответ, то этот ответ, собственно,
перечисляется. Правильно? Иначе следующий. Итак, мы перебираем все пары натуральных чисел. Поняли?
Ну, берем l плюс один, опять вычисляем пару с номером l плюс один.
Новый x, новый k. Ну да, но там же другая пара будет. Вот точно другая будет. Ищем пару с
номером l плюс один. Опять запускаем на входе с первой компоненты, а вторая компонент — количество
шагов алгоритма, который мы делаем. Опять, если выход есть, то печатается, собственно, x, а иначе
ничего не делает следующая l плюс два и так далее. Ну как? Мы же просто перечисляем все входы,
по сути, и все длительности алгоритмов. Так? Ну да. Ну да, да, да. То есть, мы все входы перечисляем и
все количество шагов возможные, которые можно сделать. Если к пределу перейти. Но алгоритм,
как вы понимаете, к пределу за конечное время перейти не сможет. Вот. Да, и все входы перебрали.
Ничего не выйдет, да. Если и на точке x не определено, то какое k бы там не ставим,
мы ничего не напечатаем. Поэтому мы, собственно, в домейн это и не запишем. Вот. А если это принадлежит
домейна, то за конечное число шагов x принадлежит домейна, за конечное k мы это выведем и, соответственно,
так или иначе рано или поздно это будет напечатано. Поэтому это действительно перечислитель. Вот.
Понятно, да? Хорошо. Это один эквивалент на два. Один эквивалент на три. Ну так оно вот почему-то и
доказывается, собственно говоря, что все сравнивается с вот этими состояниями. Вот.
Ну, если A перечислимо, то существует вычислимая функция f, у которой range равна.
Как это сделать? Ублазначение. Ублазначение. Да, в принципе, правильно.
Собственно, грубо говоря, идея, да, такое у нас получается. То есть вот такая f от x равна x,
если x принадлежит, и не определена иначе, если x не принадлежит. Будет вычислимая функция. Почему?
Вычислима. Почему? Опять? Я вот как с полухарактеристической функцией. Аналогично, да, рассуждение.
То есть если ждём x, вот у нас на входе x, ждём x на перечислитель. Если x появился,
печатаем его. Ну, то есть выдаём ответ x. Если не появился, то мы ждём бесконечно долго,
и, соответственно, вычисление выцикливается. Поняли? Вот. Ну, если существует f из n в n частично
вычислимое, такая что range f равна в обратную сторону, то почему a перечислимо? На самом деле
аналогичное доказательство, то есть перечислитель строится так же. То есть перечисляем в бесконечном
цикле вот эти номера l. Poel восстанавливаем в пару с таким номером. А потом делаем на входе x
первые ка шагов, и если ответ выведен, то этот ответ, собственно, и перечисляем. То есть единственная
разница с предыдущим доказательством. Там мы перечисляли тот x, на котором ответ был выведен,
а там ответ, который мы получили, был перечислять. Поняли? Он выведет же f от x, значит мы перечислим.
Вот так. Вам непонятно, да? Вам пояснить? Ну, это же тоже самое же. Ну, смотрите. То же самое. То есть и потом
восстанавливаем пару poel, так? Потом на входе x делаем ка шагов алгоритма. Если за ка шагов
на входе x ответ выведен, то печатаем этот ответ. Ну, выводим на перечислитель этот самый ответ.
Если не выведен, ничего не делаем. Следующее натуральное число смотрим. Так далее. Если f от x
не определено в какой-то точке, то мы ничего не выведем ни за какое натуральное количество шагов.
Правильно? Если оно определено, то за конечное количество шагов оно будет выведено, соответственно,
f от x будет напечатан, поэтому это перечисляет все значения области значения f от x. Все числа
области значения f от x. Вот. Аналогично. Два следует один. Хорошо. Так. Опа. Опа. Сколько у нас
время? Четыре минуты. Блин. Так. Ну ладно. Ну, один, четыре, четыре, один, наверное, все-таки.
Блин, не хочу торопиться. Так, ребята, давайте вот как сделаем. Один эквивалент на один,
эквивалент на четыре, четыре, эквивалент на один. В одну сторону, надеюсь, вам понятно,
ребята, смотрите. Если есть тотально вычислимая функция, для которой range f равно a,
а перечислимая — это понятно, почему. Но мы уже доказали, что область значений вычислимой
функции перечислима, и область определений вычислимой функции перечислима. Поэтому,
собственно, если есть такая функция, для которой range f равно a, то а точно перечислимое множество.
А вот в прямую сторону, то есть, если перечислимая, то есть, тотально вычислимая функция. Вот это
интересная часть. И здесь я не хочу торопиться. Давайте вот 1,5, 5,1. Там закончу в следующий раз.
Вот так. Один эквивалент на пять. Пусть а перечислимо.
Как найти разрешимое множество пар натуральных чисел, для которых а будет проекция? Ну давайте.
Что мы сделаем? Ну, на самом деле, да. То есть, в данном случае, какое разрешимое множество пар?
B это xk. Это множество пар из натуральных чисел. Такое, что перечислитель
собственно, именно разрешимое же нужно множество пар. Перечислитель для а выведет x за меньше
либо равно, чем k шагов. Ну давайте даже за равно, чем k шагов. Чтобы немножко так. Можно так, можно так.
В любом случае разрешимое свойство, правда? Мы можем проделать k шагов перечислителя и бы посмотреть
вывел ли x. Если x вывелось, то это единичка. Характеристическая функция будет равна единичке.
Мы это вычислим. А если нет, то ноль. Вот это разрешимое множество пар натуральных чисел.
Проекция B это наша А.
Оно всё. То есть, если А перечислим, то она является проекцией на первую координату какого-то разрешимого множества.
В обратную сторону проекция множества разрешима. Как перечислить проекцию?
Да, B разрешима. Да, всё правильно. То есть алгоритм работает так. Перечисляем циклы по всем натуральным L.
Значит, Poil восстанавливаем пару с таким номером, а потом проверяем B разрешима. Принадлежит ли эта пара B?
А, ребят, алгоритм на то есть. Значит, если принадлежит, то выводим первую компоненту. Если не принадлежит, ничего не делаем.
Переходим к следующей паре. Итак, мы перебираем все пар натуральных чисел. Поняли? И перечислим первые компоненты.
А, ребят? Всё, поняли? Ладно, блин. Давайте тогда, раз вы не успеваете это понимать, давайте я повторю это 1-5-5-1 и 1-4-4-1. Это в следующий раз повторю. Всё.
