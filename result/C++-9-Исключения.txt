так мы остановились на тихо давайте тихо все мы остановились на шаблонах с
переменным количеством аргументов я показал вам функцию принт а что еще
например можно продемонстрировать тут ну давайте например
какую-нибудь еще функцию реализуем на шаблоне с переменом количеством
аргументов вот что еще можно сделать например с шаблоном с переменным количеством аргументов
ну скажем ну да можно например сумму сделать вот ну как это будет выглядеть
там опять стимплейт ну мне опять надо будет
когда ты передаешь пакет то он распаковывается в head и в tail
ну вот когда передаю пакет то его первый первый аргумент автоматически становится первым
типом вы можете не разговаривать слух там сейчас очень мне тяжело это перекликивать вот
ну здесь я могу написать что-нибудь там ну я не знаю ну авто могу написать ладно допустим
ну я буду возвращать там сумму да я буду говорить head плюс сумма от хвоста вот и опять-таки нужна
специализация которая говорит там t сумма от одного аргумента даже от нуля правда непонятно
что она возвращает поэтому уж лучше от одного какого типа какая надо складывать а ты это что
такое если сумма без аргумента то непонятно что возвращать вот если так вот ну тут я написал
авто типа так можно писать начиная с 11 если получается общий тип для них вывести то он
выведет вот но если не получается конечно то будет ce вот да в принципе кажется все что я
хотел сказать по этому поводу есть еще правда одна маленькая деталь ка это
сайзов с многоточим да что что еще раз
ну потому что возвращает потому что там я и так знаю какой тип там будет
а тут я не знаю какой будет тип я сложу все эти штуки да но он является перегрузкой да
формально ну вот это не очень ну да да да вызовется версия от нуля аргументов
какая ссылка ну у вас пакете будет 0 аргументов это значит что ну как просто будет вот этот принт он
от одного аргумента будет что сделать мы в прошлый раз уже видели что он смог так тут нет
никакой специализации тут одна версия шаблонная и одна версия где ты видишь специализации никакой
специализации нет ну компилятор понимает по числу аргументов какую версию вызывать потому что от
любого количества аргументов больше нуля у него есть версия шаблонная от нуля аргументов у него
есть не шаблонная версия все в чем проблема генерируется ровно n плюс 1 версия функций принт в
реальности вы передали принт от н аргументов компилятор сгенерирует n плюс 1 версию функций
принт в рантайме будет реальная n плюс 1 реальная там разная функция принт да почему что не
компилирует все компилируется так ну авто мы с вами формально не проходили смотрите еще
одна вещь которую надо здесь сказать это вот какая это оператор сайзов многоточие есть такой
способ узнать сколько элементов в пакете встроенный язык способ для этого существует оператор сайзов
многоточие который в компилтайме работает вот вот он так записывается значит сайзов многоточие это
отдельный оператор вот сейчас он выведет мне количество аргументов в хвосте ну соответственно
да он будет выводить ну сейчас понятно он увидит там один а в хвосте три аргумента потом два хвосте
два аргумента потом овц в хвосте один аргумент потом три в хвосте ноль аргументов а потом принт
пустой уже то есть сайзов многоточие говорит сколько аргументов в пакете в компилтайме он
работает ну в компилтайме эта штука подставляется число в виде числа я могу например сказать следующее
как я могу использовать оператор избавиться от принта от пустого принт я могу сказать и в
конст экспор потому что это же в компилтайме работающая штука если сайзов многоточие tail больше
нуля то принт от tail правильно а если убрать конст экспорт то это уже не скомпилируется
если конст экспорт что да
вызываться не будет да потому что конст экспорт значит не в конст экспорт означает что проверка
должна быть выполнена в компилтайме как ты в рамптайме будешь генерирует ее функции
потому что без слова конст экспорт я заставляю компилятор скомпилировать тело этой функции в
любом случае со словом конст экспорт компилятор просто не компилирует вот эту строчку пропускает ее
у меня нету функции от нуля аргументов и поэтому я с ней не пишу конст экспорт то он не может
скомпилировать эту строчку а если я пишу конст экспорт то он ее не пытается компилировать
нету функции принта от нуля аргументов я убрал функцию принта от нуля аргументов
теперь он не может ее скомпилировать но если написать конст экспорта будет работать напоминаю
что и в конст экспорт работает только начиная си плюс плюс 17 вот но вам пользоваться им
будет нельзя наверное наверное я подумаю может быть и в конст экспорт все-таки можно я еще подумал
ой слушайте я забыл сказать еще одну очень важную вещь а вот блин чуть не забыл я уже вот сколько раз
я ловлю что надо не забыть рассказать я и забываю это на самом деле нужно было рассказать в предыдущем
пункте который простейшие метафункции еще не в 6 8 а в 6 7 да как сгенерировать ошибку
компиляции если какой-то компел тайм условия нарушена вот например я хочу убедиться что ну
я не знаю ну давайте вот я здесь генерирую ошибку компиляции если
а борд конст экспорт не знаю вот давайте я сгенерирую ошибку компиляции тут если что-нибудь
но там если какой-нибудь условия не выполнено например если что не знаю ну чушь какой-нибудь
там если это не и вот просто так вот значит я генерирую ошибку компиляции что кокнуло
проектор это как я ничего не писал пока для того чтобы генерировать ошибки в рантайме есть
функция ассерт как вы наверное знаете ассерт какое-то выражение вот и что и если оно лоша
в этом месте то будет ре будет рантаймер ассерт фейл отгадайте как выглядит что надо
написать чтобы это была компайл там ошибка статик ассерт статик ассерт это ключевое это ключевое
слово начиная c++ 11 статик ассерт как видите это вообще зарезервированное слово начиная c++ 11
есть такой способ ну до c++ 11 тоже можно было но это был уродский абсолютно то есть нужно было
там искусственно заставлять инстанцировать шаблон в котором что-то там отсутствует какой-то
тип вот статик ассерт это штука которая генерирует вам ошибку компиляции если нарушено какой-то
компайл там условия ну например если тип хэд это не инд давайте сгенерируем ошибку компиляции
значит как это написать что тип хэд это не инд type id не верно type id работает в рантайме мы не
можем в компайл тайме проверить вызвать оператор type id как в компайл тайме проверить что тип хэд
это не инд что хэд большой или хэд маленькая операторы можно вызывать только над значениями как
ты проверяешь тип как ты сравниваешь типа с помощью оператора не равно третья попытка как проверить в
компайл тайме что тип хэд это не инд нет я хочу вот здесь написать там можно я хочу статик
ассертом проверить некоторые условия что ты говоришь есть какой-нибудь есть какой же как же он
называется мы его в прошлый раз даже реализовывали прикиньте как вам такая новость я кстати забыл
сказать у нас осталось всего две недели не считая этой а это значит что нам нужно с вами зачет
провести а нам же надо с вами два зачета провести один по материалу семинаров а другой по материалу
лекции этого семестра а значит вероятно а значит вероятно ну по материалам что федя рассказывал и
по материалам что я рассказывал значит вероятно на на следующей неделе у вас будет зачет по что
раньше вы хотите потому что я рассказывал и потому что федя рассказывает мне самому
наверное хочется по фединому материалу потому что его меньше было я сегодня вам еще до расскажу
еще за еще в следующий раз расскажу что-нибудь и 19 устрою вам зачет зачет по крайней мере по моей
части будет письменной скорее всего то есть на всю первую пару на полтора часа вам выдам
листочки задачем нет листочки где писать сами возьмите ну хотя не знаю 19 мы на семирязевской здесь
а что почему нет а что вас удивляет а ты на что рассчитывал а у нас зачет недели есть
чонбы зачет недели есть инфа за что неделя прошла
19-я это еще зачет на недели вот 19 декабря зачет на неделя длиться ровно неделю как не странно
начинается во вторник и 시작ени surtout по недельник по поводу или в среду начинается
верх написать во вторник 19 декабря понедельник зачет на неделе вас как обычно tell и вы приезжаете
сюда и мы устраиваем здесь зачет хотя можно устроить в принципе оба зачета 2019
ну короче имейте в виду вот то что вы тут это как проверить что это не и есть метафункция и сейм
реализовывали да и сейм в причем потому что мы вл я от нее берем хед стаинт вот статя
вот такой что хэд это не инт и сейм в это буль значит я проверяю что ой наоборот я хочу
проверить что это инт поэтому я пишу стд сейм в инт соответственно теперь я пытаюсь сделать
сумм ну давайте стд сяут сумма 1 2 3 4 вот и будет значит 10 а цеда вот здесь тут надо констекс
провернуть ну вот 10 выводится если я здесь например передам ансайн тинт то все будет
статик ассершен фейлт ансайн тинт это уже не инт поэтому ци и сейм и проверяет что
типы точно совпадет точно равны сайн инт это то же самое что инт просто
да я даже могу написать юзинг май кул тайп равно инт и здесь сказать май тайп
передать по умолчанию без параметров вот это будет нормально потому что это в точности
инт это не новый тип а это тот же самый тип это инт юзинг не создает новых типов он просто
дает другие названия старым типом поэтому май кул тайп это равно инт а сайн не равно
да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да
не выражение времени компиляции
ну во первых тут наверное надо вот так сделать
ну потому что мне type-id от expression нужно а не от типа
ну нет вроде можно type-id от типа но это не важно
это CE потому что статик ассерт не то что неверен его невозможно выполнить
статик ассерт
может вызываться только от константных выражений
а это не константное выражение
non-constant condition статик ассерт
типа type-id non-constant export function
констант известен в компайл тайме
это должно быть какое-то выражение
константное значение которого известна в компайл тайме конечно
тогда от него статик ассерт можно делать
статик ассерт вам очень активно пригодится в задачи про матрицу
потому что вам нужно будет собственно генерироваться ошибки компиляции в случае когда n не простое
там в функции сумм короче у меня проблемы что типа когда он вызывает от одного аргумента
он вызывает не верхнюю а вот это все еще и потом он хочет от нуля его
это кто это так делает?
компилятор
какой компилятор я понимаю что не
что не
и g++ и сланк почему-то оба
сам x++
сам x++
сланк
ну не знаю
я сейчас не готов смотреть на твой код
подойди покажи мне потом
так окей все я рассказал все что хотел в этом пункте
идем дальше
и еще одна замечательная вещь чтобы вас добить
это 6,9
да
fold expressions
выражение свертки
по русски
говоря
свертки
ну по русски они так называются
а по английски fold expressions
кто знает что это такое?
фича
начиная с c++17 но
в сердечке
очень классно
будем активно пользоваться во втором семестре
а сейчас только продемонстрирую вам
как это круто
начиная с c++17
можно
писать
вещи типа
функции сам
короче
а именно
вот как давайте я
еще раз реализую функцию сам
template type name
head type name
многоточие tail
э
ну давайте
будет все еще авто
сумма
const head&head
const tail&
многоточие tail
и вот тут
я сейчас
напишу интересную вещь
return
скобочка открывается
head
плюс
э
мне не нужна
head даже
я вообще уберу head здесь
будет вот как
нет tail
плюс многоточие и все
вот что
ладно мы так делали
в принципе раньше
что ты хочешь
может ты так и делал
ну
давайте для начала
проверим что я вас не обманула
что это работает
сумма от
1,2,3,4
а скобочки обязательно
это тот самый пример
нет это не тот
пример
это работает
черт это работает
но только начиная
c++17 вот если я это уберу
то скорее всего он что-нибудь скажет что
warning all expressions
почему
черт
не знаю
кому-то не нравится мне так нравится
мне надо работать
с капетами
да
c++17
добавил еще одну
операцию над пакетом
значит можно
тут у меня нет доски
точнее доска есть
маркеров нет
а подождите
маркеры есть
так маркеров нет
вот 22 штуки
о
следующий шаг
дай первую
теперь точно
давай
а почему
и там
а
блин ладно мне тогда
жалко как-то их тратить
нет давайте поступим
иначе
я их просто заберу и не ударю
Блин, как бы нам поступить-то.
Мне, ну давайте я, значит, временно выключу экран.
Сейчас я вам открою cpp-референс.
Да, Господи, что происходит.
Смотрите, что позволяет fold expression.
Во-первых, они обязательно должны в скобочках писаться.
Значит, это просто требование такое, иначе бы компилятор не мог распарсить синтаксис.
Нужно обязательно в круглых скобочках писать.
И как это пишется? Вы говорите пакет, дальше некоторая бинарная операция, дальше многоточие, ну и всё.
Значит, либо многоточие, бинарная операция и пакет.
И всё это в скобочках.
То есть вы должны бинарным оператором соединить пакет и многоточие.
И в скобке это взять.
Тогда у вас получится...
Третью, четвёртую версию мы потом рассмотрим.
Вот смотрите, как...
Explanation, кто хотел объяснений?
Смотрите объяснение.
Вот тебе объяснение.
Значит, что происходит?
Во что компилятор это превращает?
Инстанцирование fold expression, ну то есть шаблонная подстановка, превращает это в следующую вещь.
Если у вас вот так написано, то есть если написано пакет оператор многоточие, то вот это превращается вот в это.
Ну, вот пакет разворачивается на E1 и так далее, E1 и...
Получается правоассоциативное вот такое вычисление этого оператора бинарного над всем пакетом.
Left fold, значит, превращается в левоассоциативное вот такое выражение.
Теперь дальше интересней.
Можно сделать вот такую штуку.
Можно сделать пакет...
Вот сейчас я функцию print напишу с помощью fold expression.
Simplate type name многоточие.
Ну, мне здесь не надо называть его tail, потому что у меня всего, значит...
Я вот так напишу, да, types просто.
Нет, головы.
Types.
Значит, что сделать?
Ну, void print от const types много...
Ampersand многоточие types.
И тут я пишу std seout многоточие пакет.
И все это в скобочках обязательно.
Вот.
Ну, сейчас, правда, они без пробелов будут напечатаны.
Значит, std seout...
Тут не надо уже std seout.
Print 1, 2, 3, 4.
А это я закомментирую.
Давайте посмотрим, что получится.
А получится...
Ну, надо std plus 17 добавить.
Ну, вот напечаталось 1, 2, 3, 4.
Как это сработало?
А это я применил третью...
Это я применил третью...
Виноват.
Четвертую версию fold expression.
Инициализатор, оператор многоточия, оператор пакет.
То есть я могу в скобочках написать...
Вот такое.
Я могу не просто пакет с бинарным оператором соединить с многоточием,
а я могу многоточие соединить бинарными операторами с двух сторон.
С одной стороны с пакетом, а с другой стороны с каким-то начальным значением.
И получится, что у меня это развернется вот в такое.
Ну, в моем случае это развернулось вот в такое.
То есть левая ассоциативность произошла.
У меня, поскольку инциализатор слева, то это разворачивается вот в такое.
Скобки сначала вот вокруг этого.
То есть t-out, первый элемент пакета.
Потом снова двойной, значит, побитый сдвиг.
Второй элемент пакета и так далее.
Таким образом это все превратилось в std c-out.
И один там, и так далее.
Они должны быть одинаковыми, да.
Чего ты так говоришь?
Человек руку поднимал, и вот вы его перебивает.
Не ретерна, просто вывести, и там пробел, вот стрелочка, и так далее.
То есть это как текст разворачивается, или как что-то более существенное?
Нет, это разворачивается, ну как, это expression.
Вы должны, это превратится в некоторые expression в compile-time.
Это шаблон expression, можно сказать.
Хорошо, вопрос такой.
Сработает ли следующая конструкция?
Если мы напишем t-out, дальше две скобочки, в таком скобочке скобочки открываются,
дальше внутри фолдер спрашивает следующего вида.
Пробельный символ, вывод, мы готовы.
Давай просто напишем что-то.
Можно t-out за скобки вынести, заменив его на пробел.
У нас же сейчас пробелов нет.
Не понимаю, скажи мне буквально, что написать надо?
С t-d-c-out, так.
Дальше, дальше скобочка, фолд экспреш.
Так.
Тут пробел.
Дальше...
Тогда он у тебя будет визит раздвигать чару.
Ча, подожди, ну пробел, что дальше?
Ну он же будет понять, что, ну и дальше все то же самое.
Он тебе будет прибавить пробел, а я бы...
А, ну правильно, у тебя будет побитовый сдвиг применяться к чару и к...
Ну к фолд экспрешу, ну хорошо, если это все.
Смотрите, фолд экспреш на чате.
Если еще раз t-out, эту штуку в скобку взять.
Черт возьми.
Нужно вводить пробел.
У тебя вот есть фолд экспреш, который...
Хорошо, есть у нас их два, то как бы, ну...
Беремся, как бы сделать битвный сдвиг.
Как сделать пробел, проще сказать.
Так, хорошо, пробел.
Как, как вывести их через пробел?
Возможно никак.
Есть мою камеру.
Для таких вещей, ну, ну, а вот придумайте как.
Вот, вот у вас есть формальный синтаксис.
Вот вам сказано, какие операторы разрешены.
Можно писать свой бинарный...
In a binary fold both ops must be the same.
Свой оператор выводы.
А, вот такие операторы разрешены использовать.
Кстати, точку со звездочкой и стрелочку со звездочкой можно.
Очень полезно.
А можно в деле что-то создать строку, там, чтобы...
Нет, с плюс равно многоточие и с плюс равно types и вывести вот это.
А...
С плюс равно многоточие, плюс равно...
И что?
А как пробел ты добавишь?
А пробел как...
Вопрос в том, как добавить пробелы в эту конструкцию.
Ну, чтобы добавить пробелы, пробелы добавить можно.
Смотрите.
У меня есть замечательный оператор.
Мой любимый оператор.
Кто знает мой любимый оператор?
Давайте, к концу семестра надо знать.
Оператор запятая, правильно.
Вот ты хорошо лекции слушал.
Знаешь, любимый оператор электрона.
Вот, смотри.
Используем любимый оператор.
Значит, любимый оператор или мщельная.
Запятая.
Что мы делаем?
Мы говорим...
Значит...
Я говорю...
Сейчас.
Ну да.
Я говорю вот так.
И многоточие.
Чего?
Сейчас.
По-моему, вот так я должен просто сказать.
Давайте проверим, что я правильно.
Да, значит, бинарное выражение не работает.
Сейчас, подождите, дайте.
А может запятую в крылые скобки взять?
Нет, ну правильно, да.
Сейчас, сейчас, сейчас.
Мне надо, чтобы...
Что было?
Мне надо, чтобы эта штука...
Развернулась в...
Бинарное...
Что может быть пакетом?
Вот здесь написано.
Что подразумевается под словом pack?
Это выражение, которое содержит неразвернутый пакет
и не содержит оператора с приоритетом ниже, чем каст.
На верхнем уровне.
Ага.
То есть...
То есть, то есть, то есть...
Возможно мне поможет...
Так, а если я еще вот это в скобке возьму?
Что мне не поможет?
Мне это случайно.
А у каста может что?
Вот теперь помогло, да.
Да, вот теперь работает.
Что делать, если я уже не хочу знать почему?
Да, ну смотрите.
Я могу в качестве пакета подставлять
не обязательно просто пакет сам по себе,
а некоторые выражения, содержащие пакет.
Да, да, да.
Но, да, я подставляю выражение, содержащие пакет.
Правда, здесь есть формальное ограничение.
Вот не знаю, из-за чего оно такое.
Надо, чтобы в этом выражении на верхнем уровне...
На верхнем уровне не было оператора с приоритетом ниже, чем каст.
Ну, что такое оператор с приоритетом ниже, чем каст?
Ну, это значит...
Все вот эти операторы.
На верхнем уровне у меня был вот такой оператор,
побитый в издвиг, он его не устраивал.
Но, взятие выражения в скобке поднимает ему приоритет
до уровня каста, поэтому все нормально становится.
А вот это, по-моему, он и есть.
Ну, короче, когда я беру выражение в скобке,
то это сразу считается, что это выражение
формально становится как бы каст-экспрешен, по-моему.
Ну, не систейл, оно называется каст-экспрешен,
но по стандарту выражение в скобках...
Ну, по стандарту, когда компилятор парсит выражение,
у него...
Как приоритет операторов вообще в стандарте прописан?
Он просто разбивает выражение на подтипы,
и как синтоксическое дерево строится, как выражение.
Это вот такое выражение, бинарный оператор нижнего уровня,
это выражение второго уровня.
Вот мне надо, чтобы выражение было выражением вот этого уровня не ниже.
Но я просто взял скобки дополнительные поставил, и все получилось.
Короче, компилятору надо, чтобы левым аргументом,
чтобы бинарный оператор связывал, скажем так, унарное выражение
содержащие пакет и многоточие с другой стороны.
И эта штука распаковывается в следующую штуку.
Стд си аут тайп 1, типа пробел,
через запятую перечисляются стд си аут, вот эта штука, пробел.
И это, значит, ему говорят, повтори через запятую вот эту конструкцию.
Но он ставит ограничение, что он может только унарную конструкцию повторять через запятую.
Если здесь какая-то штука, какой-то оператор используется с приоритетом ниже, чем вот это,
то он отказывается это разворачивать, он говорит, я не понимаю.
И поэтому ему надо, чтобы здесь были скобки дополнительные,
чтобы он считал это как бы унарным выражением с одним аргументом.
И он через запятую повторяет это выражение для всех types.
Вот, давайте я здесь, вот.
Просто генерал-оператор пытается возвращать то, что стоит справа.
То, что стоит справа, да.
То есть у нас сейчас си век с первого типа.
У нас сейчас что?
А, у нас сейчас, да, у нас сейчас, да, первого типа.
Fold expression.
Вот, смотрите, вот давайте я здесь в этой сумме поставлю результатом int
и потребую, чтобы все эти штуки были типа int.
Вот, еще одно упражнение.
На фолду экспрессии у нас переглянцы.
Все эти штуки были типа int.
Вот, еще одно упражнение на понимание fold expression.
Я хочу написать static assert на то, что все типы равны int.
Нет, здесь не нужно будет оператор запятая.
Оператор можно из самим и через двойной, ну, два имперсанта в логической эдитер.
Да, fold expression с логической мы.
Смотрите, static assert, std is, ну, конечно, я выражение пишу, std is same way,
types запятая int и многоточие.
Что?
Ну, у тебя будет is same way type 1 int и is same way, а все это compile time вычтемые штуки.
Я, правда, возможно, здесь нужны внутренние скобки.
Сейчас.
Ну, два имперсанта.
Теперь работает.
Потому что нужны внутренние скобки, потому что fold expression сам по себе должен в скобках быть.
Обязательно.
Static assert, одни скобки от static assert, а внутренние скобки от fold expression.
Поэтому двойные скобки здесь должны быть, тогда работают.
А как вызвать для всех функцию, которые вращаются тогда?
Если я сейчас вот здесь делаю unsigned какой-нибудь из аргументов.
Ой, здесь-то как раз нормально.
Вот если я здесь делаю, допустим, std seout вот так, один unsigned, то будет ce,
со словами static assertion вот этот вот failed.
Что, как сделать?
Подожди.
Функцию, которая вызывает void, возвращает void для всех этих типов.
Значит void для всех этих типов.
Как вызвать для всего этого пакета, для каждого его элемента, функцию, которая возвращает void?
Так через запятую, вот, пожалуйста.
А void может принимать void?
Запятая вообще без разницы, что принимать ей.
Запятая просто вычисляет выражение по порядку.
Чего ты, Горик, хотел?
Это, конечно, мало имеет смысла.
Кажется, штука работает за квадратом.
В каждом экземпляре функ.sum будет вызывать статик assertProject.
Правда или нет?
Кажется, он не будет вызывать.
Да, здесь ему не придется генерировать много версий функции.
Да, потому что я здесь не использую рекурсивные вызовы с меньшим количеством аргументов.
Здесь, по факту, ему удастся обойтись лишь одной версией sum.
То есть, по поводу спрашивания, не генерировать рекурсивные вызовы в елице?
Да, мы просто обходимся одной.
Стоп, мы же больше нигде не подписали sum.
Так я нигде не вызываю sum от меньшего числа аргументов.
Я вызываю sum только от такого числа аргументов.
В каком месте ему потребуется sum от меньшего числа аргументов?
В каком месте можно аргументом принимать динарную операцию?
Чего? Чего еще раз?
Он принимает аргументом динарную операцию.
Что?
Fold expression?
Кто? Ничего не понимаю.
Fold expression это вот такая синтоксическая конструкция.
Еще раз.
Бинарный оператор, от которого с одной стороны стоит ноготочие, а слева унарное некоторое выражение содержащий пакет.
Они все 32 случая ручками прописали.
Они сделали функцию, которая принимает динарную операцию.
Они это делали на ассемблере, как что-то важное?
Нет, они это делали не на ассемблере, а на языке внутреннего представления компилятора.
Слушай, ну когда...
А вообще у тебя не возникает вопрос, как компилятор парсит выражение?
Они что, все операторы ручками прописали, что такой оператор надо парсить так, а такой так?
Ну да.
Что тебя в этом смущает? А как?
По-твоему, компилятор есть интуиция.
А, это бинарный оператор, его надо парсить так.
Ты стандарт видел? Открой стандарт к главу expressions.
Ты увидишь, как компилятор парсит выражение.
А бинарный оператор нельзя принимать просто так вообще?
Я не понимаю, что значит принимать бинарный оператор.
Есть просто вот такой синтакс, и все.
Так, наверное, это все, что я хотел сказать по этому поводу.
А, ну не совсем. Вот еще знаете что?
Давайте еще вот такую штуку вам покажу.
Вы же понимаете, что можно...
Значит, например, сделать что-нибудь такое.
Инт.
Не знаю. Чек.
Вот. И, ну, например, написать статик, ассерт.
Значит, numbers многоточие.
Значит, numbers плюс многоточие, там, равно 10.
Не знаю, я какую фигню написал.
Ну, даже не, даже не знаю.
Ну, даже не знаю.
Ну, даже не знаю.
Ну, даже не знаю.
Не знаю, я какую фигню написал.
Ну, даже не, даже не int.check.
О, смотрите, struct.check.
Я могу статик ассерт писать в любых местах,
не обязательно в функциях.
Я могу статик ассерт внутри структуры написать.
Вот, смотрите, я написал внутри структуры,
у которой имеют переменное количество шаблонных
аргументов int, статик ассерт, что сумма этих int равна 10.
Теперь могу дописать.
Check, 1, 2, 3, 4.
Вот.
Вот.
И это будет просто compile-time-проверка,
что сумма вот этих вот чисел равна 10.
Ну, вот эта compile-time-проверка не прошла, да.
Что?
Нет, потому что в этот раз у меня нет рекурсивных вызовов.
Там раньше у меня был head, и потом я вызывал,
у меня head-ом ставилась следующая штука,
а тут у меня нет рекурсивных вызовов,
все types нужно сразу проверить, что они intы.
Сразу несколько типов выходят.
Ну да.
Types это пакет.
Зачем ему вообще type тогда?
Чего? Кому?
Ну, пакету.
Что значит зачем type пакету?
Зачем стол мухи?
Я не понимаю, какая это вообще...
Мы писали type-name-types.
Ну?
И мы давали пакету какой-то type.
Что значит давать?
Мы не давали пакету type.
Пакет – это сущность, это не тип.
Пакет – это другой вид сущности.
Types – это не тип, Types – это пакет.
Сейчас Types с большой буквы – это пакет типов,
а Types с маленькой буквы – это пакет аргументов.
У пакета нету никакого типа.
Вот когда вы его распаковали,
тогда можно...
У...
Распакован...
Ну, про распакованные элементы пакета имеет смысл
спрашивать, какой у них тип.
Мы с ней...
Да, но мы над ней можем выполнять
только операции compile-time,
выполнимые над пакетами.
В данном случае мы над ней применяем...
Мы к ней применяем fold expression.
Мы над ней можем делать распаковку,
то есть просто многоточие.
Можем делать сайзов многоточие от нее,
а можем делать fold expression еще над ней.
Она разворачивается в список нормальных аргументов,
и вот про них, про каждую уже отдельно,
имеет смысл какую-то другую операцию сделать.
А с пакетом все, что можно делать,
только распаковывать разными способами,
вот, например, таким.
Хорошо.
Types большое – это...
Сейчас.
Почему нам нельзя фориком пробежаться
по элементу пакета?
Синтаксически так решил...
Ну, так решил комитет.
Я не знаю, в чем смысл такого допера.
Непонятно, как это...
В разной типу можно...
Как это вообще ты представляешь себе?
Что значит фориком прибежаться?
Как это синтаксически должно записываться?
For out of queue – это вообще пакет.
А, for для каждого элемента...
Хорошо, это будет копирование или что?
Ну, видимо, если не ссылка,
то копирование, да?
Да, если ссылка, то не копирование.
Констакт с фор какой-нибудь...
Ну, не добавили,
не ввели такого, да,
не знаю почему.
То есть, вот эта же операция – это, по идее,
форик по элементам пакета?
Ну, в каком-то смысле да.
Блин, а вот прикол,
если сейчас оно скомпилируется,
если я так напишу.
Что, что нельзя?
Фор по пакету нельзя делать.
А for after – нет?
Мы про это и говорим. Нет, нельзя так делать.
Я не убрал лимит на размер функции,
он у вас 30 до 40 изменил.
Сможете поделиться?
Ну, надо поговорить.
Я не знаю, там какие-то...
Надо посмотреть, что там за ограничения.
Может быть...
Так, давайте последнее,
что там вы хотели спросить,
и идем дальше.
Да.
Подождите, потом обсудите.
Параметр пак с конкретным типом – нет.
Почему? Шаблон может быть,
хоть, пожалуйста, функция с таким же...
Да.
Конечно, конечно.
Ну.
C, E – это не константное выражение.
Но ведь тип X константный.
Так, и same ты чем...
Так, подожди.
И same ты от чего вызываешь?
От XA и NTA.
X – это не тип.
И same можно сравнивать типы, а не переменные.
Вы же вызывали от type A.
Нет, я вызывал от типа.
И same – это шаблон, у которого
шаблонный аргумент является типы.
Ты должен типы передать в шаблон.
Ну.
Это пакет типов.
Да, здесь можно использовать как
пакет типов, так и пакет аргументов.
Да, пакет типов разворачивается
через амперсант.
Получается...
Пакет можем использовать в нипсе и same way.
Это же пакет, а не
какой-то фиксированный.
Потому что это fold expression.
Потому же, почему я могу
вот здесь использовать пакет.
Это же пакет, а не фиксированный тип.
Потому что это fold expression.
Компилятор видит, что это fold expression
и разворачивает его, пока компилирует.
Вот. Если я здесь делаю
1, 2, 3, 3, то будет
CE со словами static assertion
fail сумма не 10.
Вот этот static assertion fail теперь.
То есть вот эта
compile time проверка, что сумма этих чисел
равна 10. Все понятно, да?
Отлично.
Ну все.
Значит, вот вам
А как
внутри чека вообще
это вызываем функцию?
Статик Assert
можно писать
это, я формально не знаю
чем это является, но в общем
это штука, которую можно писать в любом
месте кода, хоть в
Class Scope, хоть в Global Scope, хоть
в
Local Scope. То есть static assert
ее смысл просто
дойдя до сюда, сгенеряя ошибку
компиляции, если условие нарушено.
А если хорошо, то просто
пропустить и идти дальше.
Если хорошо, да, просто иди дальше.
То есть можно писать
A plus static assert B
Нет, static assert
это не expression, его нельзя
подставлять. Результатом static assert
ничего не вызвать.
Что еще раз?
Да нельзя static assert
подставлять выражение,
он ничего не возвращает.
Я про то, что
если static assert будет хорошо,
то просто уберется A plus B.
Нельзя static assert
подставлять в expression,
static assert это конструкция
отдельно, самостоятельно.
Нет, static assert
можно писать только отдельно
инструкцией, нельзя plus static assert
делать, нельзя с результатом
static assert делать ничего.
В общем, если
ленивая операция, например,
он хочет ленивый плюс делать,
не сладвал, если там произойдет ошибка
в компиляции.
Да, но если static assert выполнится, то он
заменится на пустоту A plus B.
Я не понял, давай
ты потом подойдешь, скажешь
про это.
Все, господа,
мы закончили главу шестую
и пора начинать главу седьмую.
Да, да, да.
Мне шестой хватило.
Нам надо с вами успеть
пройти главу седьмую.
Глава седьмая будет коротенькая и проста,
и она будет последняя, которая войдет в зачет.
Глава седьмая называется
exceptions,
исключения.
Но тут я мог бы
начать рисовать на доске,
а у нас точно
есть маркеры?
Просто если есть, то я, наверное, лучше на доске
порисую, тут мне особо писать ничего
не надо, код показывать особо не надо.
Че, вам не жалко маркеров
или жалко? Ну если жалко, то я буду
код писать, а если...
Ну я не знаю, просто
мне кажется, что здесь можно на доске
Нормально?
Ну давайте тогда на доске
подпишу.
Исключения.
exceptions
Сейчас напишу.
Значит, глава
седьмая исключения, параграф 7.1
как обычно
базовые идеи, базовые примеры.
Но
традиционно начну
со слов, вы наверняка все знаете,
что это такое, поэтому че вам рассказывать?
Ну кто умеет исключения
пользоваться? На каком уровне?
Ну кто умеет сделать
dry catch,
что-нибудь кинуть
и поймать?
Половина умеет.
Да, не ловит.
Значит, надо понимать,
как работает исключение.
Вот мы сейчас про это поговорим.
Ну давайте для начала, совсем
на примитивном уровне, что такое
исключение. Тут есть
за этим стоит такая длинная
философия. Вот если вы
откроете книжку сраустру
создателя, то есть
про C++, и там
в главе про исключение, там примерно две
страницы текста, где он
рассуждает, как же так вышло, почему
мы добавили исключение язык, в чем
плюсы и минусы. Я вам сейчас
примерно расскажу,
в чем плюсы. Зачем вообще
нужна эта штука?
Почему нас не устраивал
старый способ обработки ошибок?
Ну исключение такой, новый механизм обработки
ошибок. Какой старый
способ обработки ошибок? Если у вас
какая-нибудь функция,
ну вот в ней произошла какая-то
операция,
ну что-то пошло не так. Вы вызвали какую-то
функцию, она вызвала еще какую-то
функцию, она вызвала еще какую-то функцию,
и в очередной функции что-то пошло не так.
Как вы из вызывающего
вашего кода узнаете, что что-то
пошло не так? Допустим, ваша функция
вот та, которую вы вызвали, возвращает
int, она должна вам
вернуть int в нормальной ситуации,
но в ней что-то пошло не так
и по какой-то причине
она не может вам вернуть int. Ну, не получилось, допустим, она должна была прочитать что-нибудь с файла и вернуть вам это число, или с клавиатуры, и выровнять вам это число.
И вот что-то пошло не так, файл, например, открыть не удалось. И она не может вам вернуть ничего, потому что любой int, который она вам вернет, будет означать, ну, вы будете интерпретировать как какой-то валидный результат.
То есть может быть любой int, в принципе.
Зарезервировать один родной int?
Да, значит, вариант первый. Зарезервировать одно специальное значение под что-то пошло не так. Вот типа можно любое значение вернуть, но вот это значение будем читать как что-то пошло не так.
Мы будем вызвали эту функцию писать. If, значит, вызвали эту функцию. Если вот результат и функция равен magic number, значит, ну, делаем действие на случай, если что-то пошло не так, выводим сообщение, ошибка, а иначе работаем обычным образом дальше.
Еще можно глобальную переменную flag.
Вот, по сути это, да, еще можно глобальную переменную flag поставить, да. По сути эта идея называется коды ошибок.
Ну, какие есть альтернативы? Вот альтернативы, да, альтернативы исключением. Альтернативы исключением.
Еще можно по сути передавать силы.
Да, значит, ну, по сути их две. Значит, это коды ошибок. То есть, ну, так, идейно две есть альтернативы. То есть возвращать код ошибки, говорить, что у нас будет специальное обозначение на случай если что-то пошло не так.
Вот, например, когда мы вызываем из консоли какую-нибудь программу, она может вернуть ноль, и это значит, что все пошло так. А может вернуть не ноль, и это означает, что что-то пошло не так.
И вот что именно пошло не так, это надо по коду ошибки смотреть.
Сто тридцать четыре. Ага, ну, если сто тридцать четыре, это значит всех фоллт, допустим. 200 и 5. Ага, ну, если 200 и 5, это значит там что-то еще произошло.
И вот ваш код выглядит таким образом. Вы вызываете функцию, а дальше пишете. Если результат означает функции такой-то, то значит выведет такое сообщение об ошибке.
Иначе, если он такое-то число, выведет такое сообщение об ошибке. Ну, и там, перебирайте эти коды ошибок. Эти коды ошибок у вас где-то выход кожаны. Вы там завели какие-то константы под эти коды ошибок.
Но так было в языке СИП. В принципе, ничего. Да, так люди жили. Вот, проверяли коды ошибок постоянно, когда вызывали какую-то функцию.
Другой вариант – это дополнительно передавать функцию, то есть заставить функцию возвращать какое-то специальное число или глобальное состояние менять, говорящее о том, что ошибка произошла.
Например, кстати, вот у вас в потоках в Eostream есть глобальная система. Я забыл, какой метод проверяет в нормальном ли состоянии поток.
Типа, Eostream, CIN. Забыл, что? Например, EOV. Ну, например, EOV, да, достигнули конец файла. Ну, по сути, то же самое.
Но там есть еще какая-то функция, которая проверяет, все ли нормально. Это вот глобальное состояние.
А другой вариант – это передавать каждый раз функцию дополнительным аргументом число, ну или буль, который будет записываться true или false, и вместо этого все ли окей.
И проверять его. То есть у вас функция, допустим, принимает IN и возвращает IN. И вы хотите как-то узнавать, все ли нормально пошло или нет.
Тогда вы заводите ей дополнительный аргумент Bool. Передаете его по ссылке. Ну, все не было ссылок, поэтому приходилось передавать по указателю.
И, значит, в этот Bool эта функция записывает true или false, смотря, пошло у нее все хорошо или нет.
И если все пошло плохо, то вы должны сначала проверить, прежде чем использовать результат этой функции, вы должны проверить этот Bool.
И если только с ней все хорошо, то тогда вы дальше код выполняете. А иначе, значит, какое-то сообщение в ошибке.
Почему функция не может возвращать значение и потом открыть, да, типа ошибки?
И потом?
Потому что не было пафоса.
И потом?
Пафоса тоже не было. Вот так и делали.
Ну, не было. Ну как? Структуры были. Вы что, под каждую функцию свою структуру будете заводить или что?
Что было?
Ну, сначала было слово.
Ну, много чего было.
Можно было одну структуру int or error.
Нет, были указатели, были expression, были функции, были структуры, только там не было этих конструкторов и прочего.
Структура это просто был набор, то, что мы называли, там, агрегатной инициализации, оно там было, кажется.
Так вот, доп-аргумент.
Ну, типа bool-ok.
Вот, булевская переменная, в которой записывается ok или не ok выполнение функции.
И каждый раз после вызова функции нужно проверять, все ли нормально.
Вот, в Си есть, как в Си, например, правильно делать выделение памяти?
Как правильно в Си делать выделение памяти?
Это наша операционная система.
Нет, подожди, операционная система в конечном итоге делает.
Вот, допустим, ты пишешь ход на Си, тебе нужно запросить динамическую память, как это делается?
У тебя есть функция malloc, правильно?
Ну, в Си у тебя есть функция malloc, в которой ты говоришь, там, сколько byte, там, сколько-то, m.
Вот.
Допустим, она решилась неудачно, у нее не получилось выделить, сколько ты попросил.
Как ты об этом узнаешь?
Сегфолт.
Нет, если бы.
Нет, если бы секфолт, это как-то совсем плохо, потому что, а как обрабатывать этот случай?
Ну вот, как в Си узнать, что выделение памяти завершилось неудачно?
Есть функция malloc сейчас какая-нибудь?
Такая, чтобы просто донуть?
Да.
Просто malloc возвращает NullPTR, если не удалось выделить.
То есть, как правильно пользоваться malloc?
Вам надо проверять, вернулся ли NullPTR.
Если вы написали malloc, вы написали, там, byte звездочка P равно malloc N.
А дальше вам нужно проверить.
Если не P, то что-то сделать, потому что вдруг там не получилось выделить, и тогда надо обработать этот случай отдельно.
Вот.
Но вы никак не узнаете иначе, что не удалось выделить.
Вы дальше можете начать работать с этим указателем, как будто это нормальный указатель.
И потом в разыменовании будет UB.
Ну, на практике это, конечно, будет сикфолд, скорее всего, но...
Мне кажется, если мы попытаемся разыменовывать NullPTR, то нас сразу убивает прям без вопросов.
Ну да, это, скорее всего, будет сикфолд, но, ну да, на практике будет сикфолд.
Но, тем не менее, вот, как вы поймете, что именно произошло, вот, когда у вас malloc не сработал,
но вам как отличить случай, что malloc не сработал от случай, что malloc правильно сработал?
Вам нужно if писать после malloc.
И, на самом деле, так со всеми функциями сишными.
Вот, например, как перевести строку в число?
Там std, там a, то и и.
Опять же, у вас нужно проверить, что вернулось.
То есть, там она...
Ну, я не помню, там, какой конкретно, там, что она...
Она возвращает OK или не OK, или, наоборот, она принимает этим аргументом.
Ну, короче, вы должны проверять результат, прежде чем пойдете дальше.
То есть, вы вызвали функцию, проверили, все ли OK, и только потом пользуетесь результатом этой функции.
Это очень неудобно.
Это раздувает код очень сильно, потому что вам каждый раз, когда вы делаете любую...
Ну, то есть, представьте, у вас код, ну как, вы вызываете...
Код, по сути, состоит из вызова функций.
И вот каждый раз, когда вы вызываете какую-то функцию, которая теоретически может завершиться неудачно,
вам нужно писать if дополнительный.
Что, если она завершилась неудачно?
Вот, неудобно очень.
Да.
Да.
Вот.
Какая альтернатива?
Давайте придумаем механизм исключений.
Другая философия обработки ошибок.
Мы...
Да, причем, что еще неудобно, это самое главное.
Вот, вы, допустим, поняли, что здесь что-то пошло не так.
Вот, не удалось выделить.
Но вы ничего не можете здесь с этим поделать.
Это, в свою очередь, означает для вас, что ваша функция должна завершиться неудачно.
И вам нужно как-то наверх сообщить вызывающему код о том, что вы тоже завершились неудачно.
А у вас, как якунце, может быть, стекль из 10 вызовов.
То есть вам везде нужно писать if и куда-то наверх возвращать тоже сообщение о том, что вы неудачно завершились.
И та функция, получив от вас это сообщение, сама должна будет написать аналогичный if
и еще наверх отдать, что вы неудачно завершились.
И так там в десять уровней вверх.
И только на самом верхнем уровне может быть кто-то что-то придумает, что с ним сделать.
Альтернатива. Давайте введем новый оператор, который называется throw. Бросить, значит. Я могу
написать throw
что-нибудь. Ну, на самом деле можно бросать что угодно.
В C++ бросать можно любые объекты.
Вот, я могу бросить, ну, какой-нибудь объект.
Ну, брошу-ка я int.
Ну, так не надо делать никогда. Это, значит, это учебник. Примерно. Практически бросать int стоит.
Вот, бросаться int не нужно.
Можно бросить тухлое яйцо.
Кстати, не знаю, как будет тухлое.
Вот, я пишу, допустим, у меня что-то не получилось сделать, и я говорю throw какой-нибудь объект.
Что делает функция throw? Ну, это не функция, это оператор.
Ну, с точки зрения
компилятора это в итоге функция все равно, потому что
она компилируется в некоторых функциях, но это такой оператор для нас. Что он делает? Он берет.
Вот у вас есть спек вызовов.
Вот вы тут вызвали, значит, какую-то F, значит, адрес возврата.
Потом какие-то локальные переменные, потом еще какой-то там адрес.
Не знаю, адрес первый, там адрес второй, еще какая-то переменная. И вот тут вы написали throw.
Вам нужно
откатиться по стеку наверх, значит, когда вы пишете throw, происходит что называется stack unwinding.
Разматывание стека.
То есть
все локальные переменные текущего блока
уничтожаются, снимаются со стека, и
вы выскакиваете наружу. Ну, если вы оказываетесь нам на уровне функции
локально, то вы выскакиваете из этой функции.
Уничтожаются все локальные переменные этой функции, которые были созданы, разумеется, в порядке обратном тому, в котором они были созданы, не уничтожаются.
И вы выскакиваете наружу из функции. То есть, как бы со стека снимаются все эти штуки.
Вы
по адресу возврата возвращаетесь в функцию
наверх. И дальше там тоже вы выскакиваете туда, откуда пришли.
Опять там уничтожаются все локальные переменные. Вы выскакиваете еще наверх и так далее.
Пока вы не окажетесь в блоке, где написано try.
Вот.
Когда заканчивается этот полет, это то, что называется летит исключение.
Вы
написав throw, начинаете выскакивать всех блоков.
Уничтожаются все локальные переменные. Вы выскакиваете из этого блока.
Оказываетесь более внешними блоками. Уничтожаются все локальные переменные. В этого блока вы выскакиваете из этого блока.
Если это просто и姐 функции, то вы просто выходите из функции, уничтожаете cheap allocation.
Выскакиваете туда, откуда были вызваны. Опять оказываются блоки и так далее, пока вы либо не окажетесь в мейне.
либо не окажетесь внутри блока try. Вот если вы окажетесь внутри блока try, то
дальше после try должен стоять, значит, секция заглавленная catch. Вот try это
блок, внутри которого может вылететь исключение, так скажем. А дальше должно
быть обязательно написано catch, и вот после catch может быть написано что-то
конкретное, catch какой-то тип. Вот, после catch может быть либо написан конкретный
тип, либо написано многоточие. Многоточие здесь это не... Нет, здесь многоточие это не
пакет, и это не моё авторское... Это прямо в коде так писать можно, то есть это
часть синтакса. Можно писать catch многоточие, это значит, что вы ловите всё, что угодно.
Любое исключение вы ловите. Не любое, а любое исключение. Вот, а может быть здесь
поймано что-то конкретное. Вот, здесь можно написать catch, допустим, in x. Это будет
означать, что вы... Это будет означать, что если вот пока выполнялся этот код,
где-то в нём или там функция, которую он вызвал, вылетел int, то вот здесь он будет
пойман и будет выполнен код с этим, то что тут написано. А дальше, как ни в чём не
бывало, вы пойдёте работать дальше. Если вылетел не int, то значит в этот catch вы не
попадёте. Ну, там есть некоторые правила приведения, что можно ловить по каким
правилам, но это попозже. В общем, если вылетел не int, считайте, что вы сюда не
попадёте. У вас есть вариант написать несколько catch под одним try. Вот вы можете
написать catch многоточие, тогда вы сюда попадёте уже в любом случае, если вылетел
что угодно. Это значит, вы написали throw и какой-то int. Вы его и поймаете в x. Нет,
нельзя. Только по типу можно ловить. Можно писать catch такой, а потом catch
следующий, и так далее. А это вылет уже в тот же try, вы просто ловите разные
варианты ошибок. А если мы ни в один из catch не попали, то мы продолжаем дальше?
Если вы не попали ни в один из catch, то да, вы понимаете, что здесь нас не поймали,
летим дальше, продолжаем вверх размахиваться. А можем ловить ошибки в catch? Что? В смысле
ловить в catch? Можем делать throw в самом catch? Да, конечно. Но это не ловить ошибки,
бросать в catch вы можете. Конечно можете. Если он что, в catch не попал, ну да, если он
увидел, что внутри блока try подходящего catch нету, то окей, значит, выскакиваем
еще выше и продолжаем дальше. Это вычислительно не очень сложно. Это что? Вычислительно не очень медленно.
Вычислительно это, ну как вам сказать, это некоторые накладные расходы. Так, вот, в этом идее,
собственно. В общем-то, в этом идее исполнения тихо опять что-то расшумелись. Вот. Почему это во многих
случаях удобнее, чем старый стиль обработки ошибок? Да потому, что вам теперь можно не
париться, ну вот, как побеждать ситуацию. Допустим, у вас на десятом уровне вложенности какая-то
функция неудачно завершилась. Тогда она не говорит, я возвращаю какое-то значение, и вам нужно вручную
самому через все уровни вызову проталкивать это значение. То есть, окей, тогда я из своей функции
верну назад тоже какой-то вот ошибки. И моя и та функция, и так, 10 уровней наверх, и только на
десятом уровне сверху от меня кто-то проверит наконец-то это вот ошибки и фом, и увидит,
что он такой, а это означает то-то. Теперь это работает не так. Теперь вы пишете throw что-то,
throw какой-то тип ошибки. А прикол в том, что вы просто для разных видов ошибок свои типы заводите.
У вас есть стандартная иерархия исключений, у вас есть стандартный тип std exception, от которого много
чего наследовано. Ну, там есть наследники std runtime error, например, std logic error. Там, ну, разные есть.
Вот вы можете открыть, я их не помню все, но я не помню какая у них иерархия. В общем, вы можете там
открыть разные, вы можете открыть себе переференс, увидеть там иерархию исключений. Вот, там еще много
подвидов. Ну, например, вот если кто-то в векторе обращается за пределы, ну, по индексу выходящему
за пределы, вы можете бросить ошибку std out of range. Вот есть такой тип std out of range. Он говорит
вызывающему коду, что произошла ошибка, выход за границей. Вы можете там, если кто-то у вас там
что-то произошло и понятно стало, что выход за границей, вот такие throw std out of range, а в скобочках
с каким текстом? std out of range и можно передать сообщение какое-то. Вот, когда вы это поймаете, вот здесь,
например, я говорю catch, а тут я ловлю std out of range, не знаю там, ex. Ex от слова exception. И тут я могу
сказать, cout, ex, у всех стандартных исключений есть метод вот, который говорит что произошло.
Вот, у стандартных всех исключений вот у exception есть метод вот, который выводит строку вот
эту, которую передали, возвращает строку. Вот, и здесь можно писать вот. Ну и что-нибудь еще сделать.
Вы можете унаследовать свой собственный класс std exception и добавить ему какие-нибудь свои методы.
То есть, если вы поймаете этот вид исключения, вы что-то будете уметь с ним делать, вы там сможете
у него что-нибудь вызвать и понять там, что конкретно произошло, например, где. Вот.
Вот, теперь, теперь, да, самое, что я забыл сказать. Что, если так трай не будет. Вот мы летели,
летели, долетели до мейна. То есть, мы поняли, что мы выскочили в мейн, а трая все еще нет. И вот все мы уже в самой верхней области.
Все работает формально, как я сказал. То есть, мы находимся в блоке. Трай, если кэнч подошел,
окей. Если нет, выскакиваем в блок выше и так далее. Блока может быть и трай. Трай это ключевое
слово. Это управляющая конструкция. Такая же, как if, for и так далее. Вот, последняя из управляющей
конструкции. Вот. Так вот, если мы долетели до мейна, а кэнча так и нет соответствующего. Что
тогда происходит? Если исключение долетело до мейна и так и не нашелся подходящий трай,
то вызывается стандартная функция std terminate. Вот. Что делает функция terminate?
Да ты заходи. Да я сейчас все закончу. Да. Что делает функция std terminate? Ну, она, по сути,
делает то, что стоило бы сделать, значит, вам поймать. Она просто пишет в консоль сообщение,
что terminate call after throwing an instance of и пишет название типа того, чтобы были цела.
А дальше вызываю C-шную функцию abort. C-шная функция abort просто делает, ну, она вызывает некоторые
уже системную функцию, которая говорит убей меня с вердиктом abort for down. Ну, то есть,
C-шная функция abort у операционной системы запрашивает как бы убей меня, пожалуйста,
по причине, значит, я, значит, ну abort, вызвала abort. Ну вот, когда вы падаете из-за необработанного
исключения, вы в консоли видите terminate call after throwing an instance of написано что, а дальше abort
abort after down. Так вот, вот это вот terminate call after throwing an instance, это вот функция terminate
пишет в консоль, а дальше она вызывает abort, которая вызывает уже системный вызов, который ее
убивает. Вот. Да, что? Как мы можем дойти до мэйна, не поймав исключения? Я знаю, что мы нигде не написали
try catch. Вот ты просто в мэйне напиши throw 1. Вот ты дойдешь до мэйна, не поймав исключения. Ну, то есть, мы нигде не писали try catch.
Ты мог писать try catch просто не тех типов, которых надо. А мы могли бы писать catch без try? Нет. И try без catch не
могли. Только try, а потом catch. А это уже циан. Да, да. Такая конструкция закончена. Вот. Последнее,
что я скажу, видимо, бывает terminate call и не по причине, что исключения. Вот у нас с вами был, давайте,
опять проверочки на то, насколько вы внимательно слышите. У нас с вами был пример уже, когда у нас было terminate
call without an active exception. Это что, например? Это что было? Да, pure virtual function call. Вот. Это было terminate call
without an active exception. Когда мы попадали в pure virtual функцию, вот когда у нас pure virtual функция
вызывалась, мы попадали в некоторый код специально с билер-купилятором, который вызывал функцию. Ну, там
вызывается функция terminate, но функция terminate в себе, ну, некоторым механизмом проверяет, почему она
вызвалась. И она видит, что это не потому, что исключения летит, а потому, по какой-то любой причине. И, значит,
функция terminate пишет в консоли terminate call without an active exception, ну, а дальше опять abort, abort
когда? А если мы написали три точки, то мы уже не можем понять, какие сообщения там были. Если мы написали три точки, то понять, что именно
летит, мы, кажется, уже не можем. Ну, по крайней мере, стандартных доказательств. Летит и летит. Ну, ладно,
давайте на этом приостановимся, так сказать. Вот. Ладно. Так, мы остановились на разговоре о том,
что такое std terminate. Вот. std terminate это функция, которая автоматически вызывается в случае, если у вас исключение
долетело до мейна и так и не было обработано. Функция std terminate занимается тем, что пишет в консоль то, что
знает о произошедшем, а дальше вызывает сишную функцию abort. Сишная функция abort, в свою очередь, вызывает
некоторую другую уже системную функцию, которая, значит, приводит к тому, что операционная система
завершает вашу программу, ну, то есть убивает вашу программу со словами abort. Иногда операционная
система убивает вашу программу со словами segmentation fold, как вы знаете. Вот. А abort это такая ре, которая,
которую можно попросить, чтобы, грубо говоря, есть функция, которая делает вызов операционной системы и
говорит убей меня. Вот. И тогда операционная система как бы убивает вас по вашей просьбе. Это называется abort.
Вот. Это тоже вас убили, но это потому что вы сами попросили. Таким образом, вот в отличие от всех
предыдущих случаев ре, которые мы изучали, ре из-за выброшенного исключения, это прям ре, это не уб,
а гарантированная ре. То есть вот если, у вас может быть такой вопрос. Напишите самую короткую
программу, которая гарантированно приводит к ре. Ответ вот такой. Вот. Просто вот так вот. Значит,
это гарантированная ре. Это не уб, а это ре. Прям, ну. То есть программа будет завершена. Ну да,
да. Программа будет завершена с вердиктом, ну как. Там будет сделан abort. Ну можно и ну. Я просто
единицу больше люблю. Можно что угодно, Фроу. Кстати, вот что будет, если просто Фроу без
аргументов написать. Ну сейчас, сейчас обсудим. Да, ну это уже похитрее, а вот Фроу это прям,
ну для того, чтобы вызвать terminate, нужно что-то include, а тут ничего не надо. Вот. Функцию terminate
можно переопределить. Для того, чтобы переопределить функцию terminate, есть функция set terminate. То есть
вы можете вызвать функцию std set terminate и в нее передать указатель на функцию, которую вы хотите,
чтобы вызывалось вместо terminate. Вот. Значит std set terminate. Ну это редкий, редкий случай, но вот
можете на cpp-reference, значит, вызвать, значит, функция set terminate, она определена в заголовочном файле exception.
Как в общем-то, по-моему, и само, ну нет, насчет самой terminate не помню, где она определена. Вот set terminate,
вы в нее туда передаете адрес функции, которую вы хотите, чтобы вместо terminate была. Вот. А можете
еще есть симметричная функция get terminate, узнать, какая сейчас функция играет роль terminate. Вот. Это std
get terminate. Ну это не факт, что вам пригодится, просто вот можно в этом месте тоже настроить, ну например,
ну если у вас необработанное исключение долетело до мейна, вы хотите, чтобы не стандартное поведение
было, типа abort at core dumped и сообщение terminate cold, бла-бла-бла, а какое-то свое поведение вы можете
сделать в этой ситуации. Но это будет последнее, что вызовется, что вызовет ваша программа. По идее,
если вы там сделаете, кстати, вот я не знаю, если там сделать что-то, что не завершает программу,
что будет. Ну кто делает? Кто делает? Функция set terminate, еще раз, вы можете вместо terminate
передать свою версию, что делать. Наверное, программа после этого будет все равно завершена,
честно говоря, я даже не знаю, вы можете там файл открыть и что-нибудь написать туда,
например. Например, для этого, чтобы произошло необработанное исключение. Вот, ну вообще,
конечно, исключение лучше ловить, но если уж не удалось поймать, то можно вот так сделать.
Ну, возможно. Ну, возможно. Не знаю,
не могу сказать, как лучше. Так, теперь, какие есть стандартные операторы и функции,
которые могут кинуть исключение? Вот мы с вами, ну, наверное, давайте это будет уже параграф 7.2. Вот
в 7.1, значит, я рассказал все, что, ну, базовые сценарии, как использовать try-catch, значит,
что есть оператор throw, есть управляющая конструкция try-catch, что можно что-нибудь кинуть,
оно полетит-полетит, значит, если поймается хорошо, если не поймается, будет terminate.
Вот, теперь, вот, следующий пункт, он, я бы сказал, ключевой для понимания того,
что такое исключение в плюсах, вот, и он, значит, называется так, разница между исключениями
и run-time-error-ами. Ну, RES, я так сокращен. Значит, разница между исключениями и RES-ками. Вот,
самое главное, что надо запомнить, я не знаю, это надо вот просто в рамку написать и обвести,
вот, я не знаю, сейчас я прямо так и сделаю, значит, не всякое REE является исключением. Ну,
извините, что я по-английски как-то, я уж привык. Вот, это прям, вот, надо, вот,
вот этот девиз сегодняшнего вечера будет, прям вот так вот, короче. Главный факт,
который вы должны знать про исключение, не всякое REE исключение, вот, вы можете начать,
не всякое исключение приводит к REE, это правда, и не всякое исключение даже
ради REE заводится, но самое главное, это то, что не всякое REE это исключение в плюсах,
по крайней мере. Ну, я бы уточнил, не всякое исключение это C++, не всякое REE это C++ exception.
Ну, вот, смотрите, самый популярный вопрос, который люди задают про исключение и самый
популярный фейл, который люди, значит, самое популярное заблуждение, которое у людей существует
относительно исключений, это, что ты спрашивал? Да, вот, это оно, ну, это частный случай его,
а общее выглядит так, ну, я вот, что-то там сделал, оно не поймалось, почему? Вот, я вот поделил на ноль,
а ничего не поймалось, несмотря на то, что от Рай написал, я вот секфолд получил, и ничего не
поймалось. Да, потому что опять в очередной раз мы вспоминаем, что мы не на питоне пишем,
и в плюсах исключениями является только то, что вы сделаете исключениями сами, вот то, что вы,
то, что вы бросите, то и будет исключением, а все остальное это никакой не исключение,
это просто вас операционная система убивает, вот, значит, секфолд это не исключение, ну,
то есть не C++ исключение, я сейчас поясню, почему я уточняю. Дальше, деление на ноль, тоже,
это не C++ исключение, а что еще бывает? Ну, потому что это какие-то обращения к системе,
да, там какие еще бывают причины? Да вы больше вроде и не знаете, у нас, в общем-то,
три вида рее, в общем-то, и было, секфолд, деление на ноль и абортат, вот, ну, абортат это тоже не
исключение. Чего? Double free or corruption это причина, по которой вызывается функция аборт. Если у
вас происходит double free or corruption, то следующее, что происходит, абортат, опять-таки, если вы
вспомните. Когда у вас, когда вы делаете free, ну, то есть, когда вы делаете освобождение памяти по
неправильному указателю, вы на самом деле обращаетесь к функции free сишной, которая в себе тоже содержит
некоторую логику, это не просто тупая функция, которая напрямую обращается к операционке,
она еще внутри себя содержит некоторую логику и она умеет проверять некоторые ситуации, что вы
сделали double free и вот сама функция, сишная либа, сишная библиотека, вот, siesta delib, которая занимается,
там, ну, некоторая обертка над системными вызовами освобождения памяти, вот, она сама вызывает аборт,
но уже, да, что? Нет, если вы в тупую делаете delete, то delete, ну, сейчас мы, нет, нет, нет,
он проходит через много слоев, но мы сейчас рискуем это застрять на этой теме, это мы в втором
смеси будем обсуждать. Когда вы вызываете delete, вы все равно в конечном счете упираетесь, не в
конечном счете, вы упираетесь в сишную библиотеку, из которой вызывается функция free, ну, потому что
new и delete опираются на сишные функции, malloc и free, а функции malloc и free они тоже не сразу
напрямую лезут в операционную систему, они еще некоторую логику сами в себе содержат, и вот
они иногда могут вызвать аборт, если видят, что вы не там вызвались, поэтому double free or
corruption это тоже одна из причин, по которой может вызваться аборт, а вот аборт это уже функция,
которая непосредственно просит операционную систему убить вас, да, ну, собственно, функция аборт это
это и есть, аборт это убийство, вот, pure virtual function call это тоже не исключение, pure virtual function call конечно
не исключение, ну, когда происходит pure virtual function call, там написано terminate call without
an active exception, еще раз, pure virtual function call это когда вы ткнули вызов какой-то виртуальной
функции, попали в таблице виртуальных функций, написано иди туда, а там такая заглушка, которая
приводит вас в код, вызывающий terminate, вот, и у вас вызывается функция terminate, и функция terminate
видит, что нет никакого исключения, а вызвалась terminate, значит она пишет нету исключения,
но вызвалась terminate и делает аборт, все равно, вот, ну, мы с вами других видов, почему может
быть программа убита вроде как и не знаем, пока только два знаем, но путаница добавляет тот факт,
что вот деление на ноль, вот если поделить на ноль, то что будет написано в консоли, как звучит эта
ошибка, вот если поделить на ноль, то там что в скобочках core dumped, ну там segmentation faults в скобочках
core dumped, а деление на ноль, это как какое там сообщение об ошибке возникает в консоли, когда поделили ноль,
там появится, там floating point exception, да, floating point exception, так вот floating point exception
is not an exception, да, дело в том, что понятие исключения, оно существует на уровне процессора тоже,
вот, и то, что в процессоре называется floating point exception, не является исключением исключения
плюсов, то есть исключительные ситуации бывают на разных уровнях, вот есть то, что является
sim++ exception, sim++ exception это то, что throw кидается, но такие вещи, как segfault и как деление на ноль,
они, конечно же, никаким кетчем не ловятся, потому что кетчем можно поймать только то, что на этом
же уровне брошено, ну как, кетч — это средство отловить ошибку, которая бросила какая-то другая
часть вашей программы, но segfault и деление на ноль — это ошибки вообще вне вашего контроля,
если вы наступили там в операционной системе на запрещенный участок памяти, то вы не контролируете,
значит, механизм trycatch, конечно, не поможет вам спастись от того, что вас убьют за это, вот,
поймать можно только то, что брошено, собственно, из кода c++, а не то, что там процессор понял,
что память вам там или деление на ноль случилось, и он такой все, операционная система завершает эту
лавочку, закрывай, вот, поэтому вот это главное, надо понимать, что то, что вы кидаете,
короче, trycatch можно поймать далеко не все, вот segfault нельзя, с другой стороны, не всякое
исключение, это runtime error, иногда исключение используют не для того, чтобы ошибку сгенерировать,
а для каких-то странных сценариев, например, выйти из глубокого цикла можно с помощью
exception, вот, но это такое извращение немножко, не советую вам так делать, покот стайлу, наверное,
не стоит, даже не знаю, что лучше, честно говоря, но говорят лучше go to, я не знаю,
что из этого больше зло, не знаешь и хорошо, лучше не выходить из глубокого цикла вообще,
значит, внезапно, ну, короче, спорный вопрос, дискуссионный, помните, я вам говорил, что в
стандартной библиотеке есть в заголочном файле exception иерархии исключений, и там есть такой класс
std runtime error, вот, он еще сильнее запутывает дело, потому что вот этот класс std runtime error,
он, ну, это некоторый подвид exception, но, как вы теперь понимаете, это лишь абстракция уровня
языка c++, и это далеко не все возможные runtime error, т.е. segfold и division-based это, конечно,
не какой-нибудь std runtime error, это исключение с точки зрения операционной системы и процессора,
но не с точки зрения c++, а класс std runtime error нужен лишь для того, чтобы удобно представлять
некоторые подвиды runtime error, которые вы бросаете сами, вот, тем не менее, есть некоторые функции,
стандартные, операторы, встроенные в язык, в языке c++, которые такие бросают исключения,
именно в терминах c++ исключения, что это за, ну, таких операторов два, вот, какие это операторы,
мы уже, да, какие, да, new, во-первых, оператор new, значит, нет, delete исключений не бросает,
delete может только double free or corruption произойти из-за него, но исключений у delete повода не
бросать, значит, оператор new, почему он бросает исключения, да, если операционная система не дала
памяти, сколько вы попросили, то что делать оператору new в такой ситуации, ну, он теоретически
мог бы вернуть nullptr, но это как-то на C становится похоже, зачем нам так делать, если мы только что
тут разговаривали, что, в общем-то, мы пытались уйти от этого, то есть, представьте, вам каждый
раз после вызова new надо было проверять if не nullptr, то там что-то там дальше идет, вот, но это
C-шный подход, то есть, если вы пишете на C, то это нормальный подход, а когда вы пишете на плюсах,
вот весь этот механизм исключений придуман для того, чтобы вам так не делать, вот, и поэтому оператор
new, поэтому вам не надо проверять возвращаемое значение оператора new, если у вас так вышло,
что операционная система не дала выделить память, то у вас вылетит исключение, и если вы хотите,
вы можете его где-то там обработать на верхнем уровне вашей программы, но в подавляющем большинстве
случаев, если у вас вылетело это исключение, то вы уже ничего не можете сделать, ну, у вас память
закончилась, что тут сделаешь, вы падаете, вот, но зато вам не надо проверять на nullptr каждый раз,
представьте, каждый раз после new надо было бы ефать, чтобы код был безопасным, но это не очень,
поэтому new по умолчанию кидает исключение, если не удалось выделить память, оно кидает
исключение, которое имеет тип std bad alloc, ага, у кого-то начинает происходить паззл складываться,
катарсис в голове случается, мини катарсис, да, я вот, поэтому я тогда и удивился, у вас у кого-то
нет, а то и это вообще стишная функция, какое там может быть исключение, я имею в виду исключение
в операторах, это stoi, это библиотечная функция, понятно, что многие библиотечные функции кидают
исключение, ну да, stoi тоже кидает исключение, оно кидает исключение, кстати, я не помню какого
типа, да, stoi, если у нее не получилось перевести строку в число, то какое-то исключение кидается,
но я не помню какой тип у него, ну да, stoi кидает исключение, вот a to i не кидает исключение,
потому что стишная функция, там нужно ефать, получилось ли привести, а stoi просто кинет
исключение, если не получилось, вот, какой второй оператор, динамик каст, да, ну на самом деле
три оператора кидают исключение, третий оператор это throw, да, но про него и так, да, вот, динамик
каст еще кидает исключение, если вы делаете динамик каст к ссылке, то ему ничего, а каст неудачный,
то ему ничего не остается, как бросить exception, ну потому что вернуть-то он ничего не может вам,
он должен вернуть ссылку на derived, а оказался, что он не derived, что делать динамик каст, ну вариант
один только, кинуть исключение, так вот, динамик каст в таких ситуациях кидает исключение std badcast,
динамик каст к указателю вернет на lptr, если ты, да, если ты не хочешь, ну с динамик кастом у тебя
есть выбор, ты либо хочешь связываться с исключением, либо нет, если ты хочешь использовать почему-то
стишный подход и чтобы в твоей программе не было исключений вообще, то делай динамик каст к
pointer и fi, если ты используешь исключение нормально, то делай к ссылке, на самом деле и у new есть
способ сделать так, чтобы new не кидало исключение, есть такой так называемый no throw new, для этого
надо написать new в скобочках std no throw, а дальше все как обычно new std no throw t от чего-то там,
у new тоже есть не бросающая версия, оно все так же делает как обычный new, но просто в случае
отказа памяти возвращать на lptr, ничего не кидает, не std new, оно все делает так же как и этот new,
просто единственная разница, что не кидает исключение в случае отказа, возвращает на lptr,
много в чем, например, в том, что возвращаемый тип это t звездочка, а не void звездочка, в том,
что std new не вызывает никаких конструкторов, а этот вызывает, в том, что этот new использует
new handler, если не получилось выделить память, там еще есть функция new handler,
которую он может вызывать в случае нехватки памяти, короче много в чем, std new не умеет
0 байт выделять, а этот new умеет, динамик к указателю возвращает на lptr, если не удалось,
что кстати такое std no throw, это такой объект типа std no throw t, no throw t это такая пустая
структура, у которой есть один глобальный объект, std no throw, и вот когда вы вызываете new от такого
параметра, такого типа, то он понимает, что это не бросающий new и нужно другую версию, да, что?
что значит выделить 0 байт? ну у new там есть такая особенность, что если просишь выделить 0 байт,
он все равно выделяет 1, по-моему, ну если ты попросишь new типа, ну забейте, ну короче здесь,
да, поэтому, да, ладно, так не получится 0 байт выделить, да, вот можно, есть еще треть,
есть еще другой синтаксис, но забейте, это сложно слишком, потом как-нибудь, пока хватит этого,
чего ты говоришь, ну вот если ты например напишешь new int в квадратных скобочках 0, то, по-моему,
выделится, да, 1 int все равно, вот я не помню, потому что корректный вызов, он должен вернуть что-то,
что-то легальное, ну а, ну вот, да, поэтому, ну вот, например, да, наверное, поэтому еще и да,
потому что ему как минимум нужно сохранить число, где размер будет лежать, он же выделяет, да,
он выделяет чуть больше, чем вы запросили элементов, давайте забьем, это несущественные детали,
главное отличие в том, что он конструкторы вызывает от того, что вы выделили new, а сишный не вызывает,
и еще его звездочку возвращает, ему нужно в байтах передавать, а new нужно передавать в штуках,
и кастовать от молока нужно возвращаем и тип указательного то, что надо, вот это,
все давайте дальше, я не готов, это у нас целая, мы сейчас очень глубоко залезем,
к поинтеру кастовать просто, да,
ну в этом и смысл try, что если в нем происходит throw, то ты попадаешь в catch, ближайший, если ты
не уверен, что в try у тебя все будет хорошо, то ты, для этого try существует, что если в нем throw
произошел, ты в catch попал, а не упал, а какие есть библиотечные функции, которые кидают
исключения, ну вот вы знаете, например, да, что квадратные скобочки, обращение квадратными
скобочками, что к строке, что к вектору исключения не кидает, зато есть метод add, вот у всех контейнеров
вы могли видеть есть метод add, который отличается от квадратных скобочек тем, что он проверяет,
не вышли ли вы за границу, если вышли, то кидает стд out of range, вопрос зачем нужно и то и другое
одновременно, да, да, значит, если вы по какой-то причине не уверены, что у вас нет выхода за
границу и вы хотите, чтобы у вас дополнительная проверка здесь случилась, то вызывайте add,
тогда у вас будет, ну вот как, например, проверить, вот у вас падает что-то с segfault, в RE у вас
получается происходит segfault, просто замените в своем коде все вызовы квадратных скобочек на
вызовы add, и тогда вы, ну если вы векторами пользуетесь, если вы используете контейнеры,
и вы, значит, у вас что-то падает, вот, и вы хотите понять это segfault из-за чего, вот можете
заменить в своей программе все вызовы квадратных скобочек на add, и тогда у вас вердикт изменится,
у вас не segfault будет выведено, а будет написано terminate after fraud instance of std out of range,
и вы такие, ага, понятно, значит это я вышел за границу, вот поэтому у меня segfault, вот поэтому
я упал, вот, да. А будет написано строка? Нет, это слишком много. В C++23 собираются добавить,
или уже вроде как решили добавить стандартную функцию std stack trace, чтобы вы могли из кетча
увидеть из какой функции вы сюда попали, вот, значит наш коллега Антон Полухин из Яндекса вот
написал, реализовал этот механизм, по-моему это он его реализовал по большей части, и вот вроде
как его одобрили стандарт включить, но я не уверен, что они в 23 его включат, вроде как частично
собираются включить стд stack trace в 23 стандарт, но если не успеют, то в 26 включат, вот, чтобы можно
было там в определенном формате видеть, как вы сюда попали, грубо говоря. Так, конечно можем,
иначе какой смысл кидания, я об этом рассказываю, что вот эти операторы кидают исключения, разумеется.
Разумеется, да. Terminate called after fraud instance of int, aborted core dumped.
Ладно, давайте дальше. А вот дальше я перейду на проектор.
В смысле какого числа или что? Ой, ну я не помню. Ну, там, ну ты, это зависит от того,
насколько они быстро все успевают делать. Сначала происходит feature freeze, так называемый,
потом они активно работают на тем, чтобы стандарт официальный записать, а потом еще пару лет
после этого компиляторы мучаются с тем, чтобы это поддержать. Вот, на самом деле в комитете сидят
основные разработчики компиляторов, то есть там люди, которые там ключевую роль играют в разработке
G++ и в разработке Selengo, да и MSWC тоже, наверное, они сидят в комитете, то есть они, скажем так,
иногда они блокируют принятие каких-то решений, потому что они говорят, пацаны, нет, вы с ума сошли,
это нереально поддержать, вот, и по этой причине там некоторые вещи не добавляются, допустим. Так,
ну что ж. Ой. А, наверное, все, микрофон можно снимать мне. Мне кажется,
что я уже... А, кстати, я вас, кажется, обманул, точнее, не обманул, а немножко не договорил,
потому что еще оператор TypeID может кидать исключение. Dynamic Cast и TypeID может кидать
исключение. По-моему. Вот. Если выражение, которое, да, значит, если вы взяли TypeID,
от разыменования какого-то поинтера, а поинтер был null-поинтером, то тогда будет исключение типа
std badtypeid до C++14, а начиная C++14 type matching handlers of type std badtypeid. Ну, исключение типа не
в точности std badtypeid, а какого-то, возможно, наследника от него, но такое, что его можно поймать
по std badtypeid. Будет брошено. Что-то сказано. Зачем это так написали, не знаю, не спрашивайте. Ну,
короче, еще есть один оператор, это TypeID, который может кидать исключение. Ну ладно, давайте теперь
поговорим кое о чем. Уже на практике что-нибудь посмотрим. Вот. Параграф 7.3, давайте я назову его,
ну как по-русски я его называю, более подробная, более подробный разговор о механизме бросания
исключений. Ну давайте я напишу going deeper into exceptions throwing mechanism. Вот у меня есть какая-то функция,
которая бросает исключение. Ну я тут какой-нибудь завожу x, не знаю, там что-нибудь ввожу с
клавиатуры. Вот. И если, допустим, x там, не знаю, делится на два, то я решаю бросить что-нибудь. Ну,
например, давайте я брошу какой-нибудь свой собственный тип. Вот у меня будет структура s,
и она будет выводить разные сообщения, когда она создается. Значит, когда она создается,
она будет писать кредат. Когда она копируется, она будет писать, что она скопировалась.
Да, хорошо, ну давайте, я понял. Здесь-то пофигу. Нет, здесь тоже не пофигу, ну ладно. Здесь пофигу.
Осуждаю. Ну нам не это читать, нам читать, что оно выводит. Это и так понятно. Ну и давайте,
когда будет структура, будет выводиться, что... Да. Ну да, тут есть к чему придраться,
с точки зрения кодстайла. Сейчас придет Федор. Не, сейчас вроде все-таки не придет. Если придет,
я удивлюсь. Вот, значит, давайте я создам новую s, и тут буду ее ловить. Я напишу try,
f, и вот здесь буду ловить s. Какой вопрос у вас сразу должен возникнуть? Проверка на то,
насколько вы c++ программист. Что здесь первым делом нужно понять? Кэйч скопка открывается.
Я собираюсь s поймать. s или s&% или const s&%? Это важный вопрос. Но мне ловить,
здесь сюда принимать s по значению или по ссылке надо? Кэйч. Ну, наверное, по ссылке,
потому что мы же не хотим лишнее копирование, правда? Если у нас уже сроу, то лишнее копирование
текста нам не страшно. Ну это вот я бы вам так не сказал. Там еще раз выведется создан и будет
отличный вопрос. Я сейчас собираюсь это выяснять. Вот давайте сейчас попробуем понять. Для начала
просто посмотрим, что происходит, когда я его бросаю. Exception. Что мне там надо ввести? Один,
да? Ага. Ну вот оно создалось, поймалось и уничтожилось. И все, ничего не произошло,
интересно. А если бы я его по значению принял? Ну, как нетрудно догадаться, создалась бы копия
локальная на время того кэйча. Потом бы уничтожилась копия, потом бы уничтожилась
исходная. Вот. То есть на самом деле важно, вы ловите по значению или по ссылке. И понятно,
что если я поймал по значению, то модификация вот этого того, что я поймал, не будет влиять на
исходное. А если я поймал по ссылке, ну, например, если я поймал по обычной ссылке, то я отсюда
могу поменять это S, и оно поменяет вот то самое исключение, которое летит там. Вот.
Более подробно о механизме бросания исключений.
Зачем, может быть, нужно принимать, ловить по значению, а не по ссылке? Не знаю. Ну, теоретически
можно что делать. Допустим, у вас исключение хранит какую-то информацию. Допустим, у вас какая-то
очень сложная ошибка, которую нужно частично обработать на одном уровне, частично обработать на
другом уровне. Допустим, вы ее на каком-то уровне частично обработали и дальше бросили. А на более
высоком уровне вы что-то еще доделали с ней. Вот. Тут самое время сказать о том, что значит дальше
бросили. Дело в том, что то, что я поймал, я же могу дальше кинуть. Вот, смотрите, когда я нахожусь в
кетче, у меня есть вариант снова написать throw, и если я поймал по ссылке, это будет означать,
что я дальше кину ту же самую штуковину, которую я вот сейчас поймал. А если я поймал по значению,
это будет означать, что я теперь решил кинуть уже новую штуку, которую я, ну вот свою копию
локальную я кидаю, а та должна уничтожиться, соответственно. У меня летело одно исключение. Дальше
я его поймал по значению, то есть скопировал, пока когда ловил, и написал throw s. Это значит,
что я теперь хочу, чтобы дальше летело вот то, что я поймал, копия, а то, соответственно,
должно быть уничтожено. Ну конечно. Вот. Я могу это все снова обернуть в трай. Вот это я могу обернуть
в трай. И тут еще раз поймать. Ну уничтожиться исходное. Ну давайте вот этой структуры будет
еще какое-нибудь поле int x равно нулю. Вот. И я изначально здесь сделаю s. Нет, нельзя,
потому что конструкторы кастомные. Ну вот так сделаю. Но тут я напишу cre этот и еще какой x.
Вот. А так, тут мне тогда надо тоже x проинцелизировать тем. Вот. Ну и давайте,
когда я здесь буду бросать, я вот этому s что-нибудь поменяю. s.x будет равно двойке,
а тут s от единицы сконструирую. Вот. И тут я выведу, вот тут я выведу, что поймалось,
код значит s.x. И тут я снова выведу, что поймалось. И в деструктуре я еще буду писать,
что уничтожилось сейчас. Вот. Ну сейчас мы увидим с вами, в общем-то, тут ничего особенного,
неожиданного мы не увидим. Ну что сейчас произойдет? Значит, создалось первое. Что? Так, подождите. Так,
нет, что-то я не понял. Сейчас, подождите. Так, что пошло не так? Чего? Как у нас, как у нас
сначала уничтожилось, а потом поймалось? Это не важно. Да-да-да, вот это меня что-то как-то очень
уничтожилось. Уничтожилась структура с таким полем, а не сама. Это логично. Нет. Может быть,
переходе копируется? Да, нет, все нормально. Да, смотрите, смотрите, смотрите, да, все, я что-то
затупил. Все правильно, он просто копируется, когда кидается. Смотрите, что происходит. Ну давайте
разберемся. Сначала создалось первое. Ну понятно, вот здесь создалось. Мы прилетели сюда, и когда мы
его поймали, оно скопировалось. Скопировалось. Дальше. Вывелось, что поймалось первое, вот один. А
дальше снова скопировалось. А почему снова скопировалось? Да потому, что вот это исключение,
которое мы сейчас кидаем, оно лежит на стеке, которое мы сейчас поймали, оно на стеке лежит, мы же в кетче создали локальную копию, а то, что мы кидаем, оно же не на стеке должно лежать, а где-то в другом месте, потому что мы, ну, со стек сейчас всё снимется, поэтому мы должны его ещё раз скопировать и положить куда-то в другое место памяти, где будет оно храниться, пока мы дальше летим.
Поэтому происходит копия, вот, а уничтожается наша локальная переменная, которую мы только что поймали, после чего уничтожается исходное исключение, потому что мы его обработали, и остаётся существовать то второе, которое мы создали.
И вот, наконец, уже когда мы его поймали тут, оно поймано и потом уничтожено. Вот такой сценарий.
Ты сказал, локально уничтожается?
Да, конечно, мне нужно уничтожить локальную копию, прежде чем я брошу, ну, мне нужно скопировать её куда-то, где хранятся исключения.
Вот, мы приходим к вопросу, а где они хранятся? Вот есть у меня есть локальная переменная, которую я бросаю, она не в чистом виде бросается, она копируется, кладётся в какое-то специальное место памяти и бросается оттуда.
Ну, и как бы вот это называется, она брошена.
Почему нельзя просто бросить вот локальную переменную?
На самом деле, если я вот здесь вот напишу s, там s от единицы, и здесь напишу throw s, мы увидим, что сейчас ещё одна копия создаётся.
Смотрите, что происходит. Я вот создал локальную s и бросил её. И когда я пришёл вот сюда, она дважды скопировалась уже к этому моменту.
Первый раз она скопировалась со стека в специальной области памяти, где хранятся исключения, чтобы быть брошенной.
Второй раз она скопировалась из той области памяти на стек вот сюда, чтобы быть пойманной.
Если бы здесь стояла ссылка, то второго копирования бы не было.
А в какой момент умрёт которая была брожена?
Когда закроется вот этот кетч?
Да, когда мы выходим из кетч, по общему правилу, сначала уничтожается вся локальная переменная, потом уничтожается собственно исключение, которое мы обрабатывали только что.
А вообще, имеет смысл принимать что-то по мне, по ссылке, если оно всё время копируется?
Ну, не знаю.
Видимо нет, потому что так или иначе может быть лишний копирование сделать непонятно ради чего.
Может быть. Я не знаю, может такие случаи бывают, но вот работает так.
Хочется тебе говорить, если R-логики работают, то может быть это полезно.
Что?
Что если мы Константу примем по ссылке?
Константу?
Да.
Ну, как всегда, что если ты Константу функцию передашь по ссылке?
Точно то же самое.
Что?
Какой УБ?
Константу ты можешь...
Функцию передашь Константу, ты можешь принять её по Константной ссылке.
Нет, если я приму не по Константной ссылке.
ЦЕ, нельзя кастовать С к См персанду.
Ну, как?
Что если ты Константу дашь функцию по не Константной ссылке?
Конечно же ЦЕ.
Может ему просто прошло и сказал, этот кетч мы не работаем, мы работаем на следующем.
Кстати...
Кстати, да, это просто было бы...
Ну, оно бы просто не подошло сюда.
Здесь бы не было ЦЕ, это я неправильно сказал, потому что...
Просто он бы увидел, ну давайте...
Давайте я так сделаю тогда.
Оно бы просто не подошло по типу, поэтому он бы ничего не поймал.
Правильно?
Логично?
Сейчас точно что-то пойдёт.
Может скопируется?
Нет.
Что?
У нас сейчас будет terminate?
Или у нас...
У нас не будет кодку.
Тут обычная штука, у второго нет.
Да, нас убьёт из мэна.
Да, нас убьёт из мэна.
Мать его.
Чего?
Вот, кстати, не очевидно, что сейчас будет, да.
Зря я...
Вопрос-то интересный, на самом деле.
Зря я, значит, фейспаунд делал.
Да, вопрос-то интересный.
Давай запустим.
Кажется, он что поймает, потому что когда он скопировал, он же...
Убил Константность?
Да, вот, исчезла ли Константность?
То есть при любом втором...
Ну, при кодировании должна исчезла.
Ну, чем он Константность?
По приколу.
Потому что в АТ был такой исчез.
Думаю, что...
Ну, не знаю, я ставлю на то, что не поймает.
Давайте проверим.
Какой отбивал?
Мне кажется, поймал.
Нет, поймал.
Ну, значит, Константность уничтожается, когда он скопировал, да.
А ты думаешь, и terminate поймали, и Cine не поймали?
Нет, всё мы поймали.
Просто он создал копию.
И эта копия уже лежит не являющейся Константой.
И мы её ловим по неконстантной ссылке.
А вот если я так сделаю...
Ща, подожди.
Эм...
Консткаст.
А, он снимает.
Статиккаст.
Нет, мне кажется, так я не смогу сделать.
Потому что он всё равно скопирует.
В общем, не получится.
Короче, Константность снимается.
Что вы говорили?
Ну, когда мы просто кодируем язык единицы.
Он же, по сути, локально должен был создать язык единицы.
Потом его, получается, скопирует в это место, где...
Да.
Ну, тогда там ещё должна была быть ещё одна копия,
когда он просто S от единицы писал.
Почему её не было?
Где?
Ничего не понял.
Вот здесь.
Если мы сделаем throw S от единицы,
он же не будет создавать копию?
Не будет.
Почему?
Он сразу может это создать не на стеке,
а в той области, которая...
Нужна.
А, то есть это...
Он не заводит эту переменную на стеке просто.
Он сразу её кладёт куда надо,
если я не завожу локальную переменную с таким названием.
Это называется RVO.
Return value optimization.
Это то же самое, что у вас в BigInteger было у некоторых.
И в строке.
Лишнюю копию он в этом случае не делает.
А вот в этом случае он уже обязан сделать копию,
потому что вы завели локальную S,
а потом...
Ну, скопировали её.
Вопрос!
А где же она хранится-то?
Ну, не на стеке, а где?
В динамической памяти?
Если указатель вывести, то там какой-то...
Давайте попробуем вывести...
Вот здесь вот...
Адрес...
S.
И тут вывести адрес S.
Вот, ну, вы можете заметить, что...
Адрес начинается с пятёрки.
Внимательные слушатели могли запомнить,
что у меня адреса в динамической памяти начинаются с пятёрки обычно.
То есть, смотрите,
если я ловлю по ссылке,
то у меня адрес, это 0x500,
то у меня адрес, это 0x5 что-то там,
а если я ловлю по значению,
то у меня сейчас адрес будет уже 0x7 сколько-то.
Ну вот, на моей системе адреса локальных переменных,
как мы с вами уже неоднократно видели,
они начинаются с 0x7f и так далее,
а адреса в динамической памяти начинаются с 0x56 и так далее.
Причём, смотрите, они вообще очень близкие.
0x56, 0x14, 0x...
Ну, то есть они...
Начало вообще одинаковое,
ab5800,
а тут ab4eb0,
то есть, на самом деле,
реально, вот что этот new,
что этот int,
который я в динамической памяти выделил,
что вот это исключение, они лежат рядом,
то есть, они реально лежат в динамической памяти.
То есть, на самом деле,
когда исключение кидается,
есть какая-то локация в динамической памяти,
получается, под него.
Так.
Ты только что говорил о том,
что семёрка там была,
если я заменить посылки и на...
Ну вот, я сейчас...
Сначала я вывожу адрес
указателей из динамической памяти.
0x56 там получается.
Потом я вот этого s увожу адрес.
А потом вот этого s увожу адрес.
Да, ну у второго s 0.7.
Да, а у третьего снова 0x5 сколько-то.
Да, а второй s где лежит?
На стеке.
Я же локально...
Я же по значению его принял,
поэтому на стеке создалась копия.
Вот этот s лежит на стеке,
потому что он по значению принят.
А вот этот s,
это тот самый s из динамической памяти.
Вот.
А...
Какой вопрос
логично должен возникнуть следующим?
Хорошо.
Значит, исключения лежат в динамической памяти.
Никакого у вас не возникает
диссонанса от этого факта.
Когда она освобождается?
Типа кто их удаляет?
Нет, удалять-то понятно,
но когда исключение обрабатывается,
тогда и освобождается динамическая память.
А...
Ничего вас, да, не смущает?
Хорошо, напомните мне еще раз,
кто кидает исключения, в каких случаях?
А если у нас получился exception,
за новоделение есть U?
Молодец.
Да, да.
Вот именно этот вопрос я и ожидал.
А если у нас B долог,
то он где хранится?
А...
То есть, что происходит,
если U не смогло выделить память?
Он должен создать исключение B долог,
на минуточку.
А памяти-то нет.
Памяти-то же...
Памяти нет.
Ну даже не через U.
Можно у него всегда есть память
под одному из B долога.
Точно.
Дорогая система,
слезно прошу,
выдели 16 баксов.
Нет.
Мне не подобно,
честное слово.
Вот примерно так.
А можно эту память дать Сейки
самому занятию?
Нет.
На самом деле,
просто под B долог
отдельно у компилятора
есть так называемый emergency buffer.
Значит, уфер для экстренных ситуаций,
когда надо что-то куда-то положить,
но некуда.
Вот.
И вот B долог обычно кладется туда.
То есть если происходит B долог,
то он создается вот в этом месте.
Я не уверен,
что я смогу вам продемонстрировать B долог,
потому что...
Я не хочу положить комп свой.
Я просто не знаю.
У меня много оперативки,
если я запрошу сейчас 4 гигабайта.
Запроси 40.
Чего ты?
Дайте ему 100 гигабайтов.
А?
Можно уже 100 гигабайт запросить.
Да, но просто 100 гигабайт в Сайс Т не влезет.
В смысле?
Сайс Т же вы снимаете.
Тогда может быть максимальный Сайс Т сделаем?
Ладно, давайте...
Мне сегодня кстати сон приснился...
Почему в Сайс Т не влезет?
Мне кстати сегодня сон приснился,
что у меня ноут сломался.
Ну давайте, значит, это был знак.
Давайте я попробую.
Ну короче, сейчас...
Ну просто сейчас я,
если его 100 раз попрошу по гигабайту выделить,
то мы можем...
У нас может все повиснуть.
Ну давайте попробуем.
Значит, int p...
Значит, сколько мне надо?
100...
Ну давайте 50 гигабайт попрошу.
Ньюинт...
А, стоп, почему я здесь напишу?
Да, мне надо...
Просто int звездочка p...
равно ньюинт...
Так, минуточку, минуточку.
Зачем 50?
Если я хочу 100 гигабайт,
то мне надо 25 миллиардов фунтов попросить.
Вот, давайте я попробую вот так сделать.
Ну если что, у меня доска есть.
Ну что, не сделаешь рамку?
Ну что не сделаешь ради науки?
Значит, давайте, значит...
Ну я поймаю просто std exception.
И здесь выведу адрес.
И здесь выведу, значит,
ну адрес этого exception.
Да, все стандартные exception являются частными случаями std exception.
Вот, ну давайте я попробую так сделать.
Да, ну и вот здесь я еще сделаю return сразу.
Чтобы дальше не продолжать уже эту деятельность.
А, я же из мейна возвращаюсь,
значит, мне уже return ноль.
Что нормально было?
Что?
Снизу.
Не хочешь?
Ну давайте попробуем.
О, видите, все нормально,
никто не умер.
Вот.
Система предотвратила.
0x55a1.
Ну вот, короче,
оно лежит вроде не на стеке,
но где-то в каком-то специальном месте.
То есть, динамической памяти он не смог выделить,
тем не менее, вот его куда-то в специальное место положил.
Ну вот, значит,
ну это то, что обычно у компиляторов называется emergency buffer,
то есть,
некоторое специальное место, где лежит вот этот вот B-даллог.
Вот.
Можно на stackoverflow, кстати, найти ответ,
где подробно расскажется про этот механизм,
как он кладет, куда он кладет B-даллог.
Вот.
Окей.
Ну хорошо.
Так.
Дальше.
Следующая история.
Смотрите.
Вот я здесь поймал std-exception,
а брошен был std-b-dallog.
То есть, это значит, что я поймал не совсем тот тип, который кинул.
То есть, при кетче иногда бывают приведения типов.
Но правила совсем другие, нежели приведения типов и перегрузки.
Например, если я брошу int, то char я не поймаю,
и double я не поймаю,
и даже unsigned int я не поймаю.
Вот давайте я попробую так сделать.
Try.
Throw 1.
Да что ж такое.
Catch int.
Stash out 1.
Вот если я здесь, допустим, напишу double,
то я не поймаю сейчас ничего.
Я упаду.
Если бы я написал int, то, конечно же, я бы поймал.
Но double я не поймаю.
И даже unsigned int я не поймаю.
Потому что после этого он пошел сюда,
и дальше b-dallog стал заниматься.
Но чтобы дальше не шел, давайте так сделаем.
Вот, я сейчас кинул int.
Поймаю ли я unsigned int? Нет.
То есть даже приведения от int-a, unsigned int в кетче не делаются.
У вас какая-то другая ошибка была.
B-dallog.
Нет.
Я не поймал int, потому что я ловил unsigned int,
а брошен был int.
Это разные типы, и он не поймался.
Тем не менее, если у меня был бы класс derived и base наследник derived,
а я бы бросил derived, то по ссылке на base я бы поймал derived.
Это просто не считается там кастом?
Нет, это считается кастом, и это закастылина просто.
Значит, в кетче не делаются касты, кроме
каста от неконстанта к константе,
а также каста от наследника к родителю.
Можно вопрос чисто по идеологии.
Насколько нормально в функции,
которая какой-то базовый класс должна возвращать,
писать просто return и class от наследника?
Особенно если там поля просто совпадают.
Чего return каст класс от наследника?
В смысле, у нас вот есть два класса, base и derived.
Есть функция, которая должна вернуть base.
Она возвращает derived.
Такое нормально писать или плохо?
Зачем? Ну, бывает.
Ну, потому что мне вот, например, в геоме иногда удобно вместо точки дектора.
Давай потом, а?
Вот сейчас давай про исключение.
Давай про исключение, сейчас лучше говорить.
Вот я сделал структуру base, а структуру derived наследницу base.
Вот теперь я давайте создам,
я давайте кину derived,
а буду ловить base.
Причем не важно, по значению я ловлю или по ссылке,
я его поймаю.
Вот каст от родителя к наследнику,
от наследника к родителю работает в кетче,
а другие касты не работают.
Я также по константной ссылке могу поймать,
то есть от неконстанты к константе тоже сработает каст,
но другие касты не сработают.
Вопрос на...
Вопрос в телеси плюс-плюс.
А если так, то что будет?
Ну, я приватное наследование сделал.
Поймаю или не поймаю?
Наверное, не поймаю.
Сейчас это ошибка.
А потом, видимо, будет сообщение, что приватное наследование.
Подожди, подожди.
Давайте подумаем логикой.
У нас private влияет только на CE.
Да, потом это... когда потом получим?
Мы в runtime-е ловим, уже там ничего нет.
То есть вариантов на самом деле два.
Либо мы просто не поймаем,
либо будет сразу CE.
Логично, чтобы не поймали.
CE, по идее, не будет.
Не, стоп, если она скомпилировалась,
то у нас ведь правда, что дирают,
это наследник BA.
Почему правда?
Он просто... почему?
Ничего не понимаю.
Я пока не компилировал.
Вариантов два, либо будет CE, либо не поймается.
В runtime-е у нас уже нет наследования
и два независимых фаса.
В runtime-е вообще нет типов.
Да.
В runtime-е есть только...
В runtime-е есть как минимум cast динамик
между типами.
В runtime-е нет типов.
Есть только числа,
на которые процессор смотрит,
и указатели, по которым он прыгает.
И в зависимости от этого предпринимает какие-то другие действия над числами.
Dynamic cast — это просто прыжок по указателю,
на котором написан ИВчик,
сравнение несколько байтиков.
Значит, если они такие,
то, по идее, вот эти байтики перезапиши,
иначе другие байтики перезапиши и прыгни в другое место.
Что?
Ну, давайте. Кто считает, что будет CE?
Давайте, давайте.
А почему не может?
Если у нас не поймают,
то у нас не будет указатель
из-за того, чтобы приватное наследование
перебить такое.
Так, кто считает?
Твоя версия что будет?
Что не поймает просто.
А еще какие версии?
Почему не может скомпилиться и поймать?
Потому что тогда это нарушало бы
идеологию приватного наследования.
Я не должен
извне класса derived
знать, что Base — наследник derived.
Когда я кидаю derived,
я не ожидаю, что поймается Base.
Я не должен знать, что Base — это родитель derived
из Main.
Вот.
Ну, я
кстати сам не уверен, но я думаю, что просто
не поймается и все.
Ну все, да, не поймалось.
Ну, вроде логично.
Ну да, это наиболее логично.
Просто чисто логикой кажется, что нужно быть.
Так это
приватное наследование.
Приватное наследование. Какой каст может быть
если наследование приватное?
Да, в этом весь вопрос, что наследование приватное.
Ладно.
Ну, следующий вопрос.
Если у нас
короче, может ли
найти
горизонтальный каст?
Горизонтальный каст даже static
кастом нельзя сделать.
Какой горизонтальный каст
может быть
в compile-time?
В compile-time никакого.
Почему
в compile-time?
Потому что в какой кэч ты должен попасть,
а этот компилятор должен в compile-time сгенерировать.
Ну, потому что когда этот код транслируется
в процессорной
инструкции, компилятор уже в compile-time
должен
во что превращается throw?
Оно превращается в
если ты создай там
вот эту штуку, а дальше начинаешь
идти по стеку и смотреть
дойти до сюда, и вот отсюда
значит
начни кэч делать.
В compile-time ты должен
уже знать, попадешь ты,
можешь ли ты попасть сюда, если было брошено то
или не можешь.
Да не в этом дело, а в том,
что ты заранее должен
нагенерировать, будучи компилятором,
ты должен заранее нагенерировать инструкции
о том, в какой кэч ты теоретически
можешь попасть, выпрыгнув отсюда.
Мы могли бы их просто перебирать
и для каждого проверять
попадаем ли, но это будет просто долго.
Ну да,
с точки зрения реализации мы могли бы
вызывать TypeID и сверять их.
Нет, такого не будет.
Просто потому что у нас может быть миллиард наследников
и всех проверять долго.
Причем даже не будет
каста вниз, то есть каст вверх бывает,
а каст вниз не бывает, конечно.
Даже каст вниз не будет делаться,
а вы говорите про каст вбок.
Каст вниз...
Господи, вот если здесь бейс,
то вниз не будет ничего скастовано.
А ты что хотел?
А у нас тогда не произошло CE,
потому что мы не довышали право доступа,
мы ни к чему не обращались?
Ну да, мы просто не поймали...
Ну как, блин, вот окей.
Вот ты используешь какой-нибудь контейнер
из стандартной библиотеки,
и решаешь, значит,
делать try,
какие-нибудь операции над этим контейнером,
и в случае неудачи, например,
бросаешь std string
и ловишь разные типы.
И вдруг чудесным образом,
бросив std string, ты поймал std
некоторую другую штуку,
от которой наследуется std string
приватно, просто был не в курсе.
Это довольно странно.
Вот, ты не должен был знать,
что она наследник этой штуке.
Вот, поэтому
логично, что так.
На самом деле,
как мы выясним во втором смеси,
std string, как std vector,
они все наследники некоторой другой.
Интересные вещи,
но знать об этом,
но ловя ее,
мы не должны ловить их.
Так,
меня
другой вопрос больше интересует.
Знаете, какой?
Смотрите, вот у меня есть такая штука,
еще есть такая штука,
а еще есть...
Да...
Ну, есть еще...
сын...
Да, они, конечно, не приватные,
вот эти все штуки.
А еще есть сын,
который наследник их обоих.
И вот я... Вы догадываетесь,
что я сейчас делаю?
Конечно.
Что будет?
Что будет?
Какой из двух
гренни?
Их же два?
Ну, у гренни
есть поля.
Так, стоп, еще раз.
Ну, вот.
Ну, и что?
Кажется, что всех должны ловить.
Какую гренни я должен поймать,
если так напишу? Их там две.
Возможно, вообще любую.
Ну, первую, наверное.
Кажется, что это будет
какой-нибудь УБ.
Нет, ну, УБ было бы странно, если...
Ну, почему? Мы поймали рандомную бабушку.
Нет, ну, тогда уж unspecified
behavior, не совсем же УБ.
Ну, хорошо, unspecified.
Ну, в смысле, я ставлю на то, что мы в зависимости
компилятора ловим одну из двух бабушек.
Я, если честно, не знаю, что будет.
Я никогда не пробовал.
Я просто...
Мне самому сейчас стало интересно. Давайте.
Ну, давайте.
Ну, оно скомпилирует.
Ну, уже все, да.
Нет, ну, я склоняюсь...
Я склоняюсь
в мысль, что мы ничего не поймаем.
Ну, смотрите, опять-таки, я как пользователь.
Вот, смотрите, вот у вас, например, есть...
Да нет.
Я как пользователь этой штуки
не должен...
Если я кидаю что-то,
а потом ловлю в
сковородню родителя,
я не должен ловить СЕ из-за того, что родителей
было несколько, и непонятно, кого поймать.
Ну, это было бы странно.
Я ставлю на то, что ничего не поймается.
На самом деле.
Ничего не поймалось.
Ну, потому что не понятно,
какую из двух ловить. Так же не буду ловить.
Давай ловить!
Я могу выбрать
на сковородню или
макароны, поэтому я пойду голодную.
А, ну у нас действительно просто
нет функции, которая
выбирает определенную бабушку.
Она просто пролетела.
Ну, каст...
Ну, давайте так. Каст от сына к бабушке...
Слушайте, ну, че так громко
голдешь какой-то? Давайте тихо.
У меня, кстати, каст
от сына к бабушке формально не
чувствим, потому что непонятно, к чему
кастовать. Ну, он просто когда делает кэч
от грейни амперсанта, он такой, понятно, но этот грейн
не подходит, потому что каст не определен
от сына к грейни. Ну, все, я вообще не ловлю.
То есть, он типа каст сам оборачивает
внутри себя в тройке?
Подожди, что ты говоришь?
Если мы от отца
приватно наследуемся?
Приватность ни на что не влияет, конечно же.
Все равно
каст не определен от сына к грейне.
Я просто понимал, что
он не должен видеть, что он
сын бейза,
наследник бейза.
Точно каст не определен?
Каст не определен.
Каст все равно остается не определен
от сына к бабушке.
Но я все равно уверен,
что ничего не поймается. Нет, ничего не поймалось.
Но все равно не определен каст
от сына к грейне.
Мы же ловили приватный бейс?
Приватный бейс мы не ловили.
Нет, когда
мы наследовались приватно
от бейс. Нет, мы не ловили
приватный бейс. Это было бы очень странно, если
мы его ловили. Пролетели.
Так.
Что там в случае сначала проверяется,
что у нас... Да ничего
не проверяется. Просто нельзя ловить
приватное наследование, нельзя ловить неоднозначное
наследование. Можно только касты вверх.
Все. При публичном наследовании
при чем? И однозначной. Все.
Я тебе сказал, можно
ловить только каст от
наследника к родителю, если
он публичный и однозначный. Точка.
Никаких больше проверок. Все.
Ничего не проверяется.
Просто вот только это можно ловить и все.
Это все не ловится.
Еще можно ловить приведение
от неконстанты к константе.
От неконстантной ссылки можно поймать неконстантный объект.
Ну ничего страшного.
Теперь дальше. Вот смотрите.
Давайте такой просмотрим
пример. Вот у меня есть
опять сын.
И я поймал сначала
маму.
Ну да, давайте. Вот у меня был сын,
я поймал маму. Смотрите,
какая еще есть вещь.
Вот сейчас, окей,
сейчас всякие
странные примеры
закончились, сейчас будет реально полезное знание.
Вот.
Я могу сделать фроу того же
самого, что уже летит, не пересоздавая
его.
Вот если я нахожусь в кетче, мне может быть
нужно бросить то, что уже летит
дальше вверх, не пересоздавая.
Для этого я могу написать
фроу без параметров.
Вот
фроу без параметров
означает просто
брось дальше то, что ты
только что поймал. Не
создавай новое, а брось
вот что летит, не уничтожай
его, а пусть оно летит
дальше.
А до этого бы оно его уничтожило?
Мы же по ссылке передавали.
Если я напишу фроу что-то новое,
то старое, то что летело, уничтожится.
Новое, то что я
написал, будет скопировано
и брошено туда. А если я
напишу просто фроу, то ничего не будет
нового создано, а просто то,
что там уже летело, будет дальше лететь.
То есть это способ не копировать?
Это способ сказать, что я
частично обработал эту ошибку,
а теперь пусть дальше я на следующем
уровне обрабатываю. Передать дальше?
Да, ничего не копирую.
Ничего нового не создавать.
Ты можешь обернуть этот трай
в еще один трай и тоже
принять по ссылке?
Ну, будет то же самое исключение.
Я не буду этого делать, чтобы
время не тратить, но будет то же самое.
Что?
Да, мы же видели здесь, что если я пишу фроу s,
то создается новый объект s,
а старый уничтожается.
А если я бы написал просто фроу,
то ничего бы нового не создалось.
А если я
в методе s
вызову
фроу s, но нормально будет.
Что в методе s? Вызовешь фроу s?
Фроу this.
В методе s вызовешь
фроу this?
Ну, конечно же, я напишу это.
Ну, создастся новый объект
из твоего текущего с помощью конструктора
копирования. И вот
тот, который создастся, будет исключением
летящим.
Об этом сейчас будет следующий
пункт.
Если ты напишешь
фроу без параметров, то
дальше будет лететь то, что уже
летело. Вот этот локальный объект уничтожится,
а то, что летело, будет продолжать
лететь.
Вот. Если ты напишешь
фроу без параметров не в кетче,
а где-то в другом месте,
то будет run time error.
Давайте проверим.
Вот я просто написал фроу. Ну, возможно,
мне сейчас просто не даст компилировать это. Нет,
дал.
Да, будет вот такой, тот же самый run time error,
когда у нас terminate cold,
а исключения не было.
Вот. Это еще один пример, когда
если я фроу без параметров, то есть фроу
формально не требует операнда себе.
Он может быть вызван без параметров.
Но если я сделал фроу не в кетче, то есть
фроу сделал тогда, когда ничего
не лежало в том месте, где
хранятся исключения, а летящие, то значит
просто terminate без исключения.
Мы можем в кетче просто
не принимать параметры, а принять
фроу без параметра?
Что в кетче сделать? В кетче
сделать ноль параметров. Ну не принимать параметров в кетче
и поймать фроу без параметров?
Мы можем в кетче многоточие
написать. Нет, просто в кетче вообще
ничё не делаешь. Нет, в кетче
нужно что-то написать здесь, либо многоточие,
тогда вы поймете что угодно, либо
какой-то тип. Если вы сделали
кетч многоточие, то вы можете сделать фроу
без параметров и будете лететь дальше то, что вы поймал,
то, что летело. Чего?
Если я написал
фроу без параметров внутри
трея, а кетч
внутри фроу. Он его поймает,
в первый раз
нет
ну как
у вас
в смысле
если вы
блин ну вы конечно извращенцы
не знаю никогда так не пробовал ну давайте
проверим
ну все давайте просто вот так сделаем
проверим ладно
нет ничего если throw без параметров
когда нет исключения то сразу terminate
видимо он его нигде не сможет
пробовать
сейчас
так
блин у меня время закончилось уже
ну мы блин опять начали позже
на 15 минут
у нас есть terminate в любом потому что у нас уже
от следующего try terminate
хватало
кстати
если у меня
try catch
и я выбросился
один из второго catch
так
вот как раз на этот вопрос я сейчас отвечу
так все давайте
последнее что я скажу в этом пункте
так смотрите
последнее что я
собираюсь сказать по поводу механизма
try catch
что если я делаю
бросаю какой-то
объект и у меня несколько
catch есть сначала есть catch
что-то одно
а потом catch что-то более хорошо подходящее
например вот так
вот
что поймает вообще поймается
или что-то и что
вот
правильный ответ что выведется один
и все
catch работают не по принципу
перегрузки функций они работают по принципу
первого подходящего
catch перебираются подряд и как только
какой-то catch подошел
он и выбирается и он не смотрит
следующие catch не лучше ли они подходят
выбирается первый подходящий
и мне даже warning вывелся
потому что на самом деле вот этот
код никогда сюда невозможно
попасть просто
вот этот catch никогда не будет выбран
потому что все что ловится им
ловится и этим
то есть просто вот сюда я никак
не попаду никогда
нет нет всякий раз когда
при такой иерархии классов
компилятор живит мою иерархию
если у меня есть ссылка на сына и ссылка на маму
то ссылка на маму всегда
словит то что могла бы словить
ну да ну
понятно что при другой но при другой
warning наверное не было бы
да что
если мы напишем просто ничего в try
напишем просто throw
если мы напишем просто throw там где не было
исключения будет re со словами
without an active exception мы это только что проверяли
если в try мы это пишем
мы это в try и писали
да
нет мы в try это писали
мы пытались
поймать многоточие мы это
и ничего не ловилось
ну да
нет ну как нельзя если что-то
летит уже в этот момент то оно просто прокинет дальше
вот теперь дальше смотрите
дальше
если я поймал что-то
и снова написал throw попаду ли я
сюда
нет не попаду
да нет до этого throw не
было
вот
нет не попаду если я уже
значит считается следующее если я
попал в один из обработчиков
то все на этом уровне я больше обработчики не
рассматриваю вот эти кэтчи
уже не будут выбраны
я полечу выше
ну в данном случае
я просто re схвачу
ну если я в одном из обработчиков писал throw
то следующие обработчики я не попаду
благодаря этому throw я только
на уровень выше попаду
не попаду я вот сюда
но я только что продемонстрировал
почему
у меня летел сын и дальше продолжает лететь сын
я поймал его по ссылке
на маму но от этого он не перестал быть сыном
летит объект сына
то есть просто throw летит сыном
да
так ну что ж
блин
ну конечно грустно что мы не успели
опять до конца ну пофиг ладно
у нас в принципе в следующий раз
будет еще
можно
можно в следующий раз раз Филиппа не будет
надо будет воспользоваться
