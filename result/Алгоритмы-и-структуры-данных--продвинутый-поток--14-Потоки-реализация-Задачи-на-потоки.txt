Так как мы попробуем написать немножко промышленного
кода, поэтому вот от этого фраза нас начинает тоже
вздрагивать.
Так, а что нам надо?
Потоки будем писать.
Для начала мы напишем сеть.
Смотрите, хорошо нам для этого надо, но можем написать
namespace даже по приколу.
Ну да, n, network, там n, flows, ну вот, на всякий случай
вот этот скобчик всегда лишний, поэтому тут вот
полезно написать, мне кажется, вот такое.
Вот так просто, чтобы сразу.
Значит, то давайте думать, как же нам это писать?
Ну в идеале, конечно, раз уж мы запускаем BFS, неплохо
было бы хранить ребра в виде поиска ширину, правда?
Вот.
Да, но для этого, во-первых, нам, конечно, не помешают
сами ребра.
Ну сами по себе ребра мы можем хранить, ну здесь
вот по разному можно хранить, знаете, я вот даже тут попробую
ввести вот такую штуку, как template, так, ну вы уже знакомы
с такой штукой, да?
Ну вот, да, но по-хорошему, да, еще надо быть TAVERT, так
чтобы не путаться.
Тьфу, да, ой, да, ну да, да, да, я вот, ой, как давно
я не писал шаблоны.
Ну ладно.
Так, значит, смотрите, TAVERT, значит, start и finish, ну и что
нам не помешает хранить в ребрах?
Ну в ребрах, во-первых, не помешает, конечно, хранить,
значит, пропускную способность или емкость, потому что
по-английски, кстати, это называется capacity, ну и, конечно
же, не помешает еще хранить сам поток.
Вот, ну здесь, да вот, значит, далее у нас получается
примерно следующая штука, значит, смотрите, итак,
значит, ну network, значит, теперь попробуем реализовать
следующим образом, смотрите, что нам, а теперь давайте
подумаем, кстати, вот внимательно, на уровне концепции, что
нам нужно от сети?
Вот что нам нужно от сети?
Ну, нам, наверное, хочется иметь какой-то доступ к
ребрам, да, хочется их как-то поток по ним модифицировать,
может быть, добавлять ребра, но при этом как-то делать
это достаточно безопасно, вот, поэтому, на самом деле,
ну вот, но при этом, смотрите, значит, что мы будем хранить
в сети?
Как мы уже понимаем, нам очень удобно было бы хранить
остаточную сеть, правда?
Вот, поэтому, на уровне идеи мы можем сразу сказать,
что вот network и подразумеваем, что она на самом деле остаточная,
но тогда это будет нам подразумевать сразу следующее, что когда
мы будем добавлять ребра, вот сразу вот там, ну будет
у нас какой-то там конструктор, там, скажем, какой, и когда
у нас возникнет какой-нибудь insert edge, допустим, t-vertex,
скажем, start, t-vertex, finish и, собственно, capacity, там,
t-flow, capacity, то сразу, как бы, логично было бы…
— А мы не хотим просто стоять, чтобы не давать?
— Чего?
— Да, можно.
— Ну, смотрите, дело в том, что, ну, на самом деле,
вот этот struct edge, можно, конечно, и вот так писать,
но с удовольствием, во-первых, там могут храниться еще
какие-нибудь вещи и так далее, поэтому, может быть,
и, на самом деле, это будет наше достаточно внутреннее
структура.
То есть, пока мы пишем именно под capacity, вот, то есть,
нет смысла.
Тут, видите, тут, кстати, ну, и тем более, что возможно
потенциальному пользователю будет так удобнее.
Да, напоминаю, что мы пишем, когда мы пишем подобные
вещи, мы помним, что мы пишем на это, чтобы пользовались
не только мы, но и кто-нибудь еще, поэтому, чем более…
То есть, наша цель — разработать такой интерфейс, чтобы
он был, с одной стороны, безопасный, но, с другой
стороны, позволя максимально удобно алгоритмы реализовывать.
Вот.
Но, правда, здесь, конечно, есть не без ограничений,
потому что t-vertex, ну, конечно, мы тут только для аккуратности
пишем, хотя, на самом деле, по умолчанию t-vertex, наверное,
почти всегда будет unsigned and tom, ну, или size-t, но, скорее,
unsigned and tom, потому что, наверное, больше, чем два миллиарда
вершин у вас вряд ли будет, что-то мне подсказывает.
Ну, всякое, конечно, бывает.
Ну, вот, insert edge local, соответственно, start, finish, соответственно,
capacity.
И, конечно же, insert edge local, так, и finish, start, и вот тут,
конечно, стоит написать, может быть, t-flow от нуля.
Ну, это, на всякий случай, вдруг вы там в качестве t-flow
подсунете там, я не знаю, рациональные числа, вот
Ваши с прошлого семестра, не было такого, а то, мало
ли, там, какая-нибудь длинная рифметика там, вот это все.
Это, с одной стороны, но это мы вот себе на уровне
идеи прописываем.
Значит, что мы еще хотим?
Еще мы, наверное, хотим уметь как-то пробегаться по рёбрам,
правда?
Хотим?
Или не хотим?
А как мы будем пробегаться по рёбрам?
Ну да.
То есть, желательно просто, чтобы мы тут ничего не портили,
потому что, если нам выдадут, то есть, храним тут вектор
рёбер, и мы тут просто в них влезаем, и все старты
финиша переделываем, то это будет не очень безопасно.
Почему не очень безопасно?
Потому что, ну, потому что у каждого ребра есть напарник,
и, как бы, если пользователь тогда должен принимать
на себя обязательство, что он, если испортил ребро,
то должен как-то испортить и обратное.
Есть такое, да?
Вот.
Поэтому, как бы, желательно, чтобы он все рёбра, в том
числе и обратные, мог перебрать, мог, наверное, по ним даже
пустить поток, но самое интересное, что, ведь, обратите
внимание, когда он будет пускать поток, надо что-то
и по обратным рёбрам сделать.
И вот здесь, кстати, вот будет очень интересный,
кстати, еще финт ушами, на самом деле, нас ждать.
Потому что мы сейчас пойдем, вот мы говорили, что мы храним
в остаточной сети по каждому ребру обратные, и у них есть
какие-то профессиональные способности, да?
Так вот, мы здесь, в данном случае, мы пойдем, на самом
деле, немножко по-другому.
Мы, на самом деле, будем поддерживать нод, поддерживать
инвариант на тему того, что у вас есть прямое ребро
и обратное ребро, и сумма потоков по ним равна нулю.
Вот, ну в этом месте, пожалуй, так, выключу-ка я пока телевизор,
потому что в этом месте нам, как раз, я думаю, пришло
время немножко поговорить о второй концепции, определении.
Вот у нас была наша, вот такая, логично такая, псевдопрограммистская
концепция, ну вот, как выяснилось, да, это будет близко к тому,
как мы будем писать, но не то.
Значит, смотрите.
А на самом деле, определение в каком-нибудь кормане будет
написано следующее.
То есть, определение.
То есть, смотрите, тут мы пишем так.
Значит, смотрите.
Сеть в данном случае G задается так, смотрите.
V, C, S, T.
Да, C, значит, это VXV в R.
Больше либо равно нуля.
С способность S, ну понятно, и stock, тут все то же самое,
T, тоже stock, вот.
Тут все в порядке, тут все хорошо.
Вот, понимаете, да?
И кем у нас это приводит?
Ну вот, теперь, а что такое поток?
То есть, ну здесь чем отличается?
То есть, мы как бы на самом деле говорим, что...
Ну вот, значит, смотрите, V квадрат.
Что такое V квадрат?
Ну вот.
Вот, да.
То есть, если раньше мы использовали список смежности
и говорили, что пропускная способность 0, то то же самое,
что ребра нет.
То есть, здесь мы пойдем по-другому.
Теперь мы говорим, что наоборот, между любыми двумя ребрами
в вершинами есть ребро.
Просто оно иногда пропускной способности 0.
Ну, то есть, условно там, скажем так,
на самом деле, действительно, от Питера до Новосибирска
на самом деле есть прямая дорога.
Просто абсолютно прямая дорога.
Просто по ней не может поехать больше нуля машин.
Ну вот.
А еще мы говорим, что...
Да, вы говорите мне, что между Москвой и Питером
есть две дороги.
Одна бесплатная, другая платная.
Так вот, с нашей точки зрения, это одна дорога.
Просто если по одной едет 57 машин, на другой 179,
вы говорите, что на самом деле это одна дорога,
по которой едут 236 машин.
Ну, с нашей точки зрения, пока задача о потоке нам по барабану.
Вот технически, конечно, у нас будут проблемы.
Потому что, например, у вас первая же задача в домашнем задании
будет задача, найдите поток и, пожалуйста, по каждому ребру
напишите, сколько там течет.
Поэтому если вам там подсунут кратные ребра,
то в такую интерпретацию у вас проблемы.
Вот, понимаете, да?
Но...
Да.
Да, то есть понятно, что вы можете просуммировать,
потом распределить этот поток как угодно,
но как бы это...
Это понятно, что это техническая проблема,
но просто как часто говорят в программировании,
вам придется с этим работать.
Да, проблема в том, что придется работать,
а не с тем, что это там принципиально сложно.
Просто надо помнить об этой гадости.
Ну, то есть всякое там бывает.
Ну, что делать, да, это программирование.
Ну, как бы, как Gen2Linux.
Gen2Linux, операционная система,
в которой вы можете сделать все,
и вы будете делать все.
Да.
Вот, так вот.
Что такое поток?
И вот сейчас будет внезапность.
Как вот я специально не начинал,
вот я обычно начинаю с этого определения,
но я сейчас не начинал, потому что оно сейчас будет
выглядеть весьма неожиданно.
Определение, поток f в этой сети,
это внезапно
функция.
Да, пока все сходится, да.
Невероятно.
Тоже от vxv
itr.
Так, что, не видно ничего, да?
Так, сейчас.
Сейчас, погодите, сейчас все будет спокойно.
Сейчас вы увидите
лучшее в мире.
Да.
Посмотрим, что. Смотрите.
Такая, что.
Значит, первая.
Значит.
Смотрите, первое свойство.
Ну, первое свойство пока
напишем такое же.
Ну, вот. Давайте так,
что для любых, на этот раз пишется,
для любой пары вершин,
вот f от uv меньше либо равно
cv.
Но на этот раз, обратите внимание, я 0 не пишу.
Обратите внимание.
И не случайно.
Потому, что
еще будет важное условие.
Для любых uv
верно следующее.
f от uv
равно
минус f от v.
Вот.
Нет, видите. Но тут даже еще круче.
На самом деле, как бы.
Нет, ну тут...
А теперь их нет.
А сейчас посмотрим.
Нет, просто.
Нет, на самом деле это удобно так мыслить.
Потому, что раньше нам говорилось, что там, скажем,
что-то втекает, что-то вытекает.
А теперь мы примоем это к единообразию.
Теперь она говорит, в нас въехало,
как бы, к нам приехало пять машин,
в нас въехало.
Это тоже самое, что из нас
выехало минус пять машин.
Да. Круто.
Из нас, да. Что случилось? Из нас выехали машины.
Ну, больше кислорода. Сколько выехало?
Минус пять. Ага, прям
в стенку, ну да.
Вот.
Ну вот в 0,8 раз.
Да, именно, именно.
Ну да, очень удобно, да.
И
уже сразу в третьем
аксиоме, на самом деле, сразу
начинает быть видно, как это
приятно, на самом деле, с этим работать.
Потому, что математически все эти утверждения, которые
мы доказали, сейчас мы даже чуть-чуть поиграемся в это,
доказываются сильно проще.
Ну, в принципе, писать меньше.
Хотя, вот, смысл, конечно, немножко
завуалирован.
Вот. Ну и теперь
третья аксиома, вот это сохранение, да,
что, типа, сколько втекает, сколько вытекает.
Теперь она звучит так, что
для любой вершины, ну, допустим,
не исток и несток,
верно что?
Что
сумма, просто теперь
всего вытекает, то есть из нее суммарно
вытекает ноль
единиц потока. Все.
То есть вспомни, где я еще такую конструкцию
имею.
Не знаю.
Ну вот.
То есть вот такая вот удобство.
Красивая. Вот. То есть, видите, то есть теперь
не надо писать это сумма входящих, суммы
исходящих. Тут вот уже по умолчанию учтено,
что входящие учтены там, условно,
со знаком минуса и исходящие со знаком плюс.
Поэтому вот. Получилось то,
что...
как следствие.
Да, ну это просто прямое следствие
вот этого условия.
То есть как бы f от vv равно
минус f от vv. Следовательно,
f от vv равно нулю автоматически.
Вот. Ну вот давайте можем
как бы...
Чем это становится еще удобнее?
Ну, как вы думаете,
к чему равно
теперь равна величина потока?
Да, то есть теперь она тоже
равна вполне себе короткой вещи.
f от
f от sv.
Все.
А модуль ft
он теперь равен
f от vt.
Красота, правда?
Маленькую писать.
Не здесь.
А, ну, пожалуйста.
Это важно.
Ой. В каком месте важно?
Как только мы докажем, что это одно и то же
называется модуль f, это уже неважно.
Ну ладно. Давайте вот
попробуем сейчас еще раз доказать,
что модуль
fs равно
модуль ft.
Так что смотрите. Звучит это примерно
так.
То есть смотрите.
То есть давайте
просуммируем f по всем ребрам.
То есть 0
равен, сумма
по всем
uv,
f от uv.
Здесь я пишу
второе условие.
По второму условию это верно, потому что каждое ребро
как бы взаимоуничтожается само собой.
Понимаете, да?
Это
то же самое, да?
Но теперь замечаем, что это то же самое,
что как бы пробежаться по всем вершинам u
и для
каждой вершины u пробежаться по
всем вершинам v.
Это я просто вот
переписал. Чуть прогруппировал.
Теперь по условию
номер 3.
Как бы у нас
я тут убил все, кроме
тех же сумм.
То есть сумма f от sv
плюс
суммы f от
tv.
Вот.
То есть vv
и vv.
Но это автоматически понятно равно
модуль fs
минус модуль ft.
Все, доказательство окончено.
То есть в общем-то
сделали мы в общем-то то же самое
абсолютно, да?
Только вместо
расписи входящих и исходящих
мы их просто вот тут зашили вот сюда
сразу. Вот в это вот условие.
Понимаете, да?
Вот.
Более того, кстати, обратите внимание
вот на какой интересный факт еще
связанный. Потому что видим, что
здесь потоки задаются матрицей смежности
просто иногда нулей, да?
Вот почему нам было в первом определении
так важно было, помните я даже сначала
хотел там писать отрицательные потоки,
но потом почему-то отказался, да?
Ну вот.
Ну почему, ну вот.
Ну да.
Нет, то я бы говорил, что
там может быть поток, может быть отрицательный.
Да, физически непонятно, что это.
В данном случае теперь заметим следующее.
Что если у вас в сети
есть ребро от u dv
с пропускной способностью, например там
5, а обратно
ребра нет, ну это не остаточная
сеть, да?
То обратите внимание, то автоматически
будет соблюдаться условие,
что здесь будет нечто больше
либо равно нуля.
Автоматически? Да.
Причина очень
проста. То, что вот этого
ребра нет, то есть как вы сказали,
на самом деле ребро есть.
Просто у него
пропускная способность равна нулю.
Это означает,
что здесь должно стоять число меньше
либо равно нуля.
Но так как тут стоит минус вот это,
значит тут всегда больше либо равно нуля.
Вот такое удобство.
Понимаете, да?
Поэтому будет автоматически.
Вот кстати,
если говорить об остаточной сети,
то остаточная сеть формируется
еще проще.
То есть остаточная сеть здесь
формируется вообще так.
То есть остаточная сеть, вот так вот определение
в этой технологии.
Остаточная сеть
это
что такое?
Это WCFST.
Где я просто...
Пишем вот тупо.
CF от UV это просто равно
C от
UV
минус F от UV.
То есть формально говоря в этом месте
желательно формально доказать, что это
сеть.
То есть знаете как-то
для следующего фокуса
мне понадобится
моя ображительная улыбка
ловкость рук и называется
10 стальных кольев.
Я назвал этот фокус
колья.
Ну вот здесь примерно то же самое.
Вот.
Нет ну CF
очаровательный человек на самом деле.
Вот.
Значит получается
примерно...
Там на самом деле было бы чуть сложнее
может быть так, но здесь еще проще, потому что
здесь все что надо доказать это то, что вот это вот больше либо
равно нуля.
Но то, что это больше либо равно нуля следует
из вот этого условия.
Понимаете, да?
Вот.
Но при этом значит...
Но как ее хранить?
Формально говоря если у вас по ребру
величина 5 течет
допустим 2
2 единицы потока, то здесь течет
минус 2. То есть в остаточной сети
формально говоря
мы бы писали тут ребро прописной способности
2, чтобы тут было.
Тут было бы 3, тут было бы
2, правда?
Вот.
Но конечно гораздо удобнее
было бы, чтобы ребра не трогать
обычно просто писать, что как бы прописная
способность 0, а течет тут минус 2.
Вот.
То есть как бы, то есть мы говорим, что
если прописная способность 0, это не значит, что тут
ничего течет не будет.
Ну вот. То есть бывает
такое, то есть знаете это как
классическая ситуация, то есть типа
лекция, на лекции 3 человека.
Вот.
Внезапно 5 встают
и уходят.
Да, вот. Вот лектор тоже грустно
думает. Ну да, вот сейчас еще двое придут
вообще никого не будет.
Да.
Такая вот ситуация. Да.
Вот. То есть здесь вот тоже нормально.
Да. То есть как бы ой, сейчас тут две машины приедут
и тут пустота будет.
Вот. Такая вот удобно.
Причем, кстати, обратите внимание
еще на маленькую приятную вещь. Вот мы
говорим об ориентированном графе.
Да.
Иногда сеть бывает не ориентированная.
То есть мы же чаще, как вообще даже сложно
себе вообразить ориентированную
трубу.
Ну, если только не предполагать,
что там вода понятие течет там
под действием силы тяжести, конечно.
Да, но обычно
как бы наоборот. То есть обычно просто
труба есть, у нее есть радиус, но вода может
течет туда и туда.
Это решается
очень просто. Смотрите.
То есть на самом деле, да. Ну, в данном
определении это решается очень просто. Просто это означает,
что там С от УВ и С от ВУ
будут равны пяти.
То есть обычно в ориентированной сети
тут иногда в формане вообще возникает
даже техническое условие, что
для любых двух вершин там ребро идет
не более чем в одну сторону.
Ну, чтобы типа вот обратно это
легче было прописывать. Но на самом деле необходимости
в этом нет. Просто мы говорим, что если
есть два вот таких ребра, то они автоматически
обратны друг к другу.
То есть если у нас будет какая-нибудь
неориентированная сеть, то как бы ничего страшного.
То есть там, допустим, жило было какое-нибудь
ребро, семь. И говорим, что
вода может течет туда и туда, главное
чтобы не больше семи.
Для нас это оказывается там
в какой-нибудь сети.
То есть просто говорим, что давайте в эту сторону семь
и в эту сторону семь, и они обратные.
То есть обязательно, что тут должно быть
х-х.
Вот. То есть с этой точки зрения
так.
Ну вот, с точки зрения, так сказать,
классического определения, да.
Там могут быть просто проблемы, что нам
сначала придется определить ребро.
Точнее, вот эти два ориентированных
ребра.
А потом...
А потом еще и...
А потом еще и каждому из них
вводить обратно. И тогда ребро может быть учителено.
Вот. А вот я про это и говорю.
На самом деле, конечно, в этом
нет необходимости. Тем более, что если учителить,
то у вас был бы риск, что вы и туда
воду пропустите, и сюда воду пропустите,
и у вас тут будет циркуляция такая.
То есть будет такие две машинки, которые будут
гонять туда-сюда.
Вот. То есть понятно, что в реальности
вы это все просуммируете, конечно,
но... А будете потом отчитывать,
что куча машин бегает.
В одну сторону пять.
Ну тогда ничего страшного в этом нет.
Тогда это означает, что мы просто нарисуем
вот так. В одну пять,
в другую три. Или сколько там у вас?
И вот, пожалуйста. И тогда все равно
оказывается удобно. Потому что если у вас по этому
ребру потекчет, скажем, 4 единицы
потока, а по этой один,
да, то по большому
счету это то же самое,
что тут потекчет 3 единицы потока, а тут
ноль.
Да, это
в старом понятии
нам аппарате.
В смысле?
А в текущем, на самом деле,
то есть как бы, просто если сюда течет
4 оттуда-ти, вот вы в идее, то это то же самое,
что просто туда течет 3 и все.
Ну в нашем понятии это будет
конечно вот так. Минус 3 из 3.
А при желании может быть
минус 5 из 3.
То есть как бы, если вы хотите
чтобы поток тем в ту сторону,
вы сначала вот эти три отменить,
а потом уже допихивайте дальше.
То есть в результате
получится,
в остаточной
сети получится
на самом деле, что тут пропускная способность
будет 6, а тут пропускная способность
2.
Вот скорее так.
Но это если в матрице смешность.
Вот на самом деле мы совместим
на самом деле лучшее
из обоих подходов.
Ну лучшее в чем?
Потому что мы совместим, что в первом подходе нам нравится,
что нам надо хранить не матрицу смешности, а список
список смешности.
Но с другой стороны, наша цель
будет, что давайте у каждого
ребра будет обратная, то есть
они будут разделены на пары, и в каждом
из них мы будем хранить пропускную, вот
пропускная способность меняться не будет,
но будут меняться потоки.
Понимаете, да?
То есть мы не будем хранить в остаточной сети пропускную
способность 2, мы будем хранить пропускную способность
0 и поток минус 2.
И говорить, что
остаточная пропускная способность это
пропускная способность минус поток.
Прям честно по этому
определению.
Ну да, вот так вот будем, да.
Вот, видите.
То есть это возможно.
То есть возможно, что
будут у нас два парных, два
взаимообратных ребра, и у каждого из них
пропускная способность будет больше 0, это нормально.
Просто мы иногда
так, ну просто это будет зависеть
от того, ориентированная у нас сеть или
не ориентированная.
Вот так вот.
Вот.
В результате.
Тогда мы налагаем на себя условия,
что когда вы пропускаете поток по одному ребру,
по другому, этот же поток
должен быть вычтен.
И мы должны за этим следить, но желательно,
но следить за этим должны мы, то есть мы должны
следить, чтобы
пользователь мог этим воспользоваться, но не мог
ничего напортить. Итак.
Значит, как же нам ходить по ребрам?
Ну, как это положено в C++,
у нас, конечно, наверное может быть
какой-нибудь итератор.
Вот. Смотрите.
Вот, давайте его
ведем.
Так, где он у нас там водится?
Нет, в какой части паблика изомневился?
В сверху, снизу писать?
Ну, зависит.
Нам не говорили, кажется. Не говорили?
Не, нам говорили, что
как хотите. Как хотите.
Пишите везде одинаковые.
Пожалуйста.
Да.
Значит, смотрите.
Значит, стракт, но, допустим,
edge иterator.
Значит,
ну, и так, здесь мы тоже немножко
будет
немножко оригинально, значит, смотрите, как мы
сделаем.
Значит, у него
его интерфейс будет следующий.
Можно даже на уровне интерфейса этот прописать,
но этот супер абстрактный класс
вот этот, но мы не будем этого делать.
Значит, смотрите. Просто идея
у него будет такая.
Значит, на самом деле
такой популярный вариант
итератора для того, чтобы перебирать ребра,
было бы for edge
иterator
it
допустим, равно
там network
.begin
от v, мы ж от вершины должны
перебирать, да?
И дальше it.
valid
it.next.
То есть, на самом деле, ну, скажем так,
это, конечно, больше Java иterator,
чем C, конечно,
потому что вся в этом месте обычно пишут
begin, end и plus plus, да?
Можем.
Но, на самом деле, честно говоря,
технология, по-моему, впервые видела даже
не на джаве, а, собственно, реально в яндексе.
Вот. Да, на C++.
Че?
Да, действительно, безобразие какое.
Ну, он все-таки, ну, он же не класс,
он все-таки структурка.
Только поэтому. А так, да.
Вот.
Ну, значит, смотрите, что нам тут
потребуется?
Вот.
То есть, хочется так перебирать.
Ну, нам потребуется тут, конечно, какой-нибудь
конструктор, да?
t vertex.
Допустим, v.
Да, explicit, конечно.
Ну, вот, конечно, bool
valid. Желательно
const.
Хотя const необязательно, наверное.
И, конечно,
void next.
Да, пока мы не забыли, значит, тут надо
написать бла-бла-бла.
Ну, по камере.
Ну, в реальной жизни не знаю, но я часто люблю написать
бла-бла-бла, что, как бы, если я забыл это реализовать,
то, как бы, компилятор мне тыкнет носом.
Вот.
Ну, бла-бла-бла.
Точное написание необязательно.
Главное, чтобы не компилилось.
Так что можете изобрести свое заклинание.
Вот.
То есть, вот очень бы хотелось.
Но что нам еще? Ну, нам кое-что еще
требуется от итератора.
Ведь просто бегать
по итератору в вакууме нам неинтересно.
Нам, наверное, интересно ребро, которое за ним стоит.
Не правда ли?
Ну, вот.
Как же это сделать?
Точнее, давайте на уровне интерфейса
попытаемся понять, о чем мы хотим вообще.
Ну, ребра перебирать понятно, да, мы хотим.
Но, наверное, еще мы хотим
на них хотя бы смотреть.
А еще, наверное,
мы хотим пустить по ним поток.
Да, мы, конечно, могли бы
да, мы бы, конечно, могли
что-нибудь сделать в духе там, скажем,
edge там, t-vertex,
там t-vertex, t-flow
могли бы сделать, да.
Ну, вот.
Да, оператор звездочка.
Да, оператор звездочка.
Но
я бы не рекомендовал так делать.
Потому что это то самое
небезопасное.
Когда просто вы получили указатель на
ребро, и я могу там просто взять
и просто переписать, скажем, начало или конец.
Или копать.
Чего?
А, ну, хорошо.
Да.
Но это redonly.
В этом случае тогда
более правильно, конечно, в этом случае возвращать
константную ссылку на ребро.
То есть то же самое, но без копирования.
Это удобно.
Но это само по себе,
так сказать, redonly.
А нам же хочется как-то еще
поток менять.
Для этого называется
хотие. Ну, вот.
С этой точки зрения, на самом деле, так как вот edge это
что-то внутреннее, непонятно, как вы храните,
то я бы предлагал, на самом деле, просто
прописать вместо этого честно.
bool get start.
Ну, вот там, допустим, get start.
Там, допустим,
bool get finish.
Тут вообще много чего.
А почему bool-то?
там t-vertex.
Вот тут, может быть, даже однострочное
не помешает, тут как ассет красиво будет.
там t-vertex.
get finish, вот это вот.
Что там еще?
t-flow
get capacity.
Там вот что-нибудь такое.
Что там нам еще потребуется?
t-flow get residual capacity.
А, ну, конечно,
get flow.
Но это все
Getter.
Может быть, где-то даже
не помешает написать const.
Ну, просто.
И, конечно,
его величество
push flow.
Даже не
void push flow.
Ну.
А это нет?
Почему не пустые?
Мы их объявляем?
Да.
Ну, мы ж пока не знаем.
Да, я тут могу тоже блаблабла написать.
Давайте напишу, чтобы было понятно.
В смысле, мы их потом напишем?
Да.
Остаточное.
Вот у меня там было написано
residual network.
Это называется остаточная сеть.
Да.
То есть по факту, да, здесь можно уже сказать.
Вот можно прям сразу тут так
написать на самом деле.
Потому что
это абстрактные интерфейсы.
Вдруг вы захотите пользоваться не таким
ребром.
А в этом ребре будете еще что-нибудь хранить, мало ли.
Хотя, конечно...
Ну, кстати, это внутреннее дело сети.
Можете, конечно, раз и навсегда прописать, что ребро будет
ровно таким или каким-нибудь иначе.
В принципе, наверное, даже можно.
Но это не очень удобно.
Как по мне, лучше
просто метод, и тогда
никто не думает, в какой там структуре.
На самом деле, некоторые олимпиагики
вообще не любят писать структуры,
потому что там просто будут эти start-finish-capacity
писать просто вот в четырех векторах.
Или даже в четырех массивах,
особенно вот если на паскали.
Кстати, об этом вот.
Так, ну что нам потребуется?
Ну, так как...
Ну, единственное, что нам потребуется, это, конечно...
Конечно, объявить, что
это наш друг.
Ну, потому что
понятно, что
у него как раз будет какой-то
мистический доступ к сети, правда?
Видите, да?
А, и, конечно же,
у network будет
begin.
Вот inset-edge, и, конечно,
edge-network-work,
хресь-хресь, ой,
а должен я тут это писать, или я могу просто
edge-interator написать?
Ну, давайте лучше так напишу, чтобы было понятно.
Begin.
Ну вот, t-vertex.
Ну, и тут какой-то сейчас
какая-то блаблаблашка будет.
А, вот, кстати, еще один
блаблаблаш.
Так тоже работает.
Ну, что-то значит,
но не в этом контексте.
Ну, что-то значит, но не в этом контексте.
Вот, пожалуйста.
Ну, это да.
Это контекст, это та вещь,
когда вы это, приходите на работу,
вам весь мусс и все уши прожужжали,
что копипастить нельзя,
поэтому вы максимально
избавлялись копипасты
и вам отдавали по рукам.
Ну вот, что-то.
Потом выяснилось, что как раз там, что
как говорится, функции может и одинаковые,
но контексты настолько принципиально разные,
что лучше их, лучше копипастить.
Вот, эти и другие советы.
Кишка 99 советов для программистов.
Где?
Ну, вот, я не знаю. Ну, просто можно
Нетворк убрать, вот, наверное, вот так.
Ну, мало ли.
Ну, чтобы было прямо, откуда я
ее взял, вот отсюда, да.
Ну, по ситуации.
Не могу сказать, что сильно хочу к этому ввязаться.
Ну, мало ли.
Ну, мало ли, откуда мы этот шитератор взяли, знаете.
Как бы, с нами, локально, да.
Теперь представьте, что кто-то,
может, и вы будете это читать.
Впервые в жизни.
Ну, вот. Да, знаете, ситуация.
Вы это написали, а потом через полгода
в первой жизни будете это читать.
Это реально, это реальная ситуация,
на самом деле.
Вот, поэтому вы сами будете искать, это шитератор
это где вообще?
Ну, вот, поэтому тут сразу указывают, что это здесь.
Вот, поэтому, знаешь, можно
не полениться, лучше написать несколько символов, так,
чтобы потом не путься. Кстати, полгода может наступить
на самом деле завтра ночью,
перед дедлайном.
Не, я не к тому, что после завтра,
то завтра ночью будет дедлайн, конечно, нет.
Вот. Значит, смотрите.
Теперь давайте вот думать.
Ну, сразу уже на уровне идеи, кстати,
все, что нам потребуется, это еще, что
нам потребуется ссылка на сеть.
Потому что, к сожалению, сам в себе
итератор внутри себя все равно
ничего про себя не знает.
То есть,
у итератора
внутри себя
ему нужно указать
какая-то указательная
ссылка на то, с какой сетью он вообще работает.
Давайте. Ну, так
по умолчанию было, но согласен.
Хорошо. Так что вот
network не помешает. И, конечно же,
значит, network
network
ссылка network
и, как бы, да,
первое, что тут обязательно надо сделать сразу,
это network от network.
Это уже чисто интерфейсная
вещь. То есть, я еще не знаю, как я буду хранить
сеть, но вот, тем не менее.
Да, для, ну, чтобы
сразу расписаться для себя в том,
что итератор не создает и не удаляет
никакие
сети.
То есть, ссылка это означает, что все, я с тобой работаю,
но я тебя, как бы, не удаляю, не создаю,
не предподключаюсь к другим сетям
у тебя за спиной,
ну и так далее.
Поэтому, как бы, ссылка вот,
если есть указатель, значит, как бы, будьте
готовы, что он может меняться. Ссылка вот
не меняется. Вот.
Ну, а теперь дальше все будет, конечно, зависеть от того,
как у нас хранится сеть.
Там очень разные варианты могут быть.
Вот сейчас я предложу, может быть, ну да,
вы как-то, наверное, перейдете там. Ну понятно, что да.
Ладно, кто когда-нибудь писал что-то, связанное с потоками
в жизни, кстати? Что-то я забыл
спросить.
Ага, логично. Ну да, больше 100
писал. Ну ничего, ладно.
Ну вот, поэтому, но тем не менее,
сейчас я тогда покажу такую немножко
неклассическую вещь.
А кто-нибудь писал когда-нибудь потоки на языке
паскаль? Ну вот, просто чем
отличается паскаль от сей? Паскаль отличается,
ну он там синтоксически очень похож,
но разница в том, что там нет вектора.
Вот. То есть, поэтому никаких вот этих
вот ваших список спрежности типа вектор-векторов
там нет.
И у вас возникает маленький
технический вопрос.
А что делать?
Так вот, смотрите.
Так вот, вы знаете,
появляется очаровательная технология,
которую вот в потоках я очень
люблю.
Ну по сути, на самом деле, сейчас список
смежности у меня будет реально
списком смежности.
Ну вот, да, указатели
при желании в паскале есть, но пользоваться
ими не хочется.
Не, ну не скажите. Паскаль очаровательный язык.
Поэтому делать
мы будем следующим.
Да нормальный паскальчик.
Что кто писал, где писал?
Я писал.
Ну вот.
Вот Данил.
Ну вот.
Нет, ну тут по ситуации.
Тут как бы все сложнее, потому что как бы понятно,
чем дальше, тем меньше, наверное, там в школах
будут вообще вспоминать этот язык.
Нет, оно конечно понятно, что да, преподаватели
чаще всего уже на чем привыкли,
на том как бы учительствовом примере в ней будут,
но как бы... Но в Олимпиадах его уже
даже в школе, по-моему, паскаль отменили
на всеросе, так что...
Нет, ассемблер
будет. Ну вот, например,
смотри.
Да.
Ну не знаю.
Жизнь коротка, да, но
Геннадий Короткевич выиграл межнарый на паскале,
если что, так что, как я уже
говорил.
Ну вот, значит,
смотрите. Вот давайте рассмотрим вот такую
какую-нибудь сеть от балды,
пропускные способности будут какие-нибудь вот такие,
но числа тоже совершенно от балды,
они там сейчас вообще не принципиальные.
Так, 8.
Ну я не знаю, давайте еще
6 тут будет, 3,
2, 1.
Ну, допустим, 5.
700.
Не, ну многовато.
Вот.
Но еще нам, конечно, потребуется перенумерать вершины.
Ну там где-то тут
СТ, это мы понимаем.
Ну давайте перенумируем эти вершины,
перенумируем мы их во что. Ну, например,
для удобства
0, 1, 2.
Ну, как вы помните, СТ не обязательно
0 и минус 1, да.
Но обычно они у нас нумируются, видимо,
может быть, даже зашить в интерфейс.
Вот так вот.
Значит, 7 вершин.
Значит...
Абсолютно.
Ну я просто перенумирал вершины.
Как-то рандомно.
Ну сейчас это будет массив,
поэтому числами вообще там какой-нибудь,
в другой ситуации я мог бы их перенумировать буквами.
Значит, смотрите, работать будем так.
Векторов у нас нет,
но есть,
но будут три массива.
Значит, массив ЕДЖЕС,
массив НЕКСТ
и массив...
Да, обычно я его называю А.
Но мы его будем называть БЕГИН.
Значит, что это такое?
Значит, суть заключается в следующем.
Бегин я даже
буду красить зеленым, знак того,
что его размер фиксирован и равен количеству вершин.
Изначально
минус 1, минус 1, минус 1, минус 1,
минус 1, минус 1.
Так называется?
ЕДЖЕС.
Ну да.
Вот.
Ну вот.
В этом массиве нам понадобится
ребра, с которыми будем работать.
Поэтому я назвал его
ребра.
Вот.
Так вот.
Будем позже брэкить.
Будем добавлять какое-нибудь ребро.
Ну какое ребро мы хотим добавить?
Ну, допустим, вот это.
Какое? 422, да?
Вот добавляем ребро 422.
Нет, мы будем так.
Значит, начнем с того,
значит, пишем ребро 422,
ну и, соответственно, 0.
Вот flow, помните, да?
Это ребро ведет нас из
вершины 4.
Значит, смотрите, теперь тут фишка такая.
В next мы напишем,
мы поэтому посмотрим на
были ли у нас еще
ребра из четверки.
Увидим, что нет,
поэтому тут в качестве next с чистой совестью
пишем минус 1.
Ну, я говорю next, но по факту, конечно,
тут правильно previous было написано.
Потому что смысл next будет очень простой.
Для каждого ребра я буду говорить,
а были ли слева вообще ребра из четверки,
если да, то где предыдущие?
Вот, а сюда я, соответственно, напишу
0.
Почему я напишу 0? Потому что это ребро номер
0.
Но в нашем случае это
еще не все, потому что в реальности нам
надо еще добавить ребро
2.4.0.
Поехали, добавляем 2.4.0.0.
Ну, у нас ориентированная сеть, поэтому добавляем.
Четыре размахнутся.
Давайте-ка я
поуже чуть-чуть напишу это все.
Так, давайте
совсем поуже.
4.2.0.
2.4.0.
И вот тут минус 1.
Вот.
Вот так получше будет.
Идем дальше.
Какое ребро дальше мы хотим добавить?
Ну, просто когда дают список ребр,
в каком порядке дают, в который мы добавляем.
Поэтому абсолютно с небес по факсу.
Так, ну и что?
Какое следующее ребро посунули?
6.4.
Пишем
6.4.3.
Ну и соответственно
4.6.0.
Да, вот этот напарник это я сейчас добавил,
но если вы работаете реально со списком смежности,
то естественно вы второе ребро не добавляете.
А, кстати, погодите,
я поторопился.
Да, второе ребро, да, здесь
важно, тут минус 1, а на самом деле здесь
тоже надо написать минус 1.
И теперь мы здесь пишем 1.
Совсем забыл, да.
Почему 1?
Потому что последнее ребро,
торчащее с двойки,
находится здесь.
Вот, сейчас мы добавим второе ребро
и думаю, что картина прояснится.
Итак, 6.4.3.
Технология звучит так.
Мы добавим 6.4.3.0.
Так, здесь мы пишем
минус 1, а здесь
пишем 2.
А вот здесь начинается интересность.
4.6.0.0
Нет, это список
смежности такой.
Start,
Finish, Capacity, Flow.
Да,
то есть это
реальные ребра.
Вот, и так смотрим.
А были у нас раньше ребра, торчащие
с четверки?
Были. А где у нас
предыдущие находятся?
А, ну где у нас там последние находятся?
В нолике. Поэтому смотрите, мы сюда
пишем нолик.
А сюда пишем номер этого.
То есть смотрите, как теперь понять, что
у нас тут два ребра есть с четверки?
Где последнее ребро? На третьем месте, вот оно.
Так, а предыдущие где?
В нолике. А, вот оно.
А предыдущие есть? Нет, значит
они закончились.
Вот, оказывается очень удобно.
Вот давайте, например, для интересу
добавим еще какое-нибудь ребро.
Что нам там еще добавить-то надо?
Давайте 4.0 вот это вот добавим.
4.0.5
И соответственно 0.4.0
Значит, поехали. Добавляем.
Значит, что там?
4.0.5
4.0.5
И 0, конечно.
Так, мы говорим...
Предыдущие ребра
торчащие с той же вершины.
Ага, окей.
Вот.
Более того, если вам захочется уметь перебирать
скажем, ребра, которые входят в вершину
то вы можете параллельно
сделать для входящих ребер.
Кстати, если интересно.
Значит, смотрите, 4.0.5.0
Значит, были ли у нас ребра
торчащие в треке? Да, где было последнее
в треке. Значит, вот эту тройку мы сюда
и переписываем.
Да, совершенно верно.
Вот.
А 0.4.0.0
Так, были ли у нас ребра
торчащие с нуля?
Не было.
Потому что последнее было минус 1.
То есть мы переписываем минус 1.
А сюда
записываем.
Да.
А с точки зрения списка ребер
получается вот, типа, begin
первое ребро, а там следующее. То есть, по-хорошему
да, это надо назвать end и previous
конечно, да, чтобы от конца
к началу перебираем.
Но это на ваше усмотрение.
Ну, я тут писал вообще
а.
Ну, может быть, у нас не nex, а parent.
Ну, это не parent.
Это ж не деревья все-таки.
А может, мы будем построить бамбук?
Реально?
Ну, ну...
Не, ну, это да, скорее
набор бамбуков будет, но я бы тут
сущность не плодил.
Зачем, зачем нам это делать?
Вот так, да.
Ну, понятно все.
Ну, вот. Ну, в принципе, дам.
Так, ну, да, так. Ладно, дальше.
Так, иметь смысл еще
ребра какие-то рассмотреть?
Я думаю, нет.
Кажется, типа, механизм понятен.
Если с ребром добавляется еще и номер,
куда он приедет. Ну, да.
То есть, ну, просто в begin принесу.
Ну, и это тоже. Не, ну, не совсем.
Тут мы много вариантов.
Смотрите.
Нет, уверены ли мы следующие?
Основное, что главное надо
зачем следить, то, чтобы интерфейс был
отделен от внутренней реализации, чтобы она была безопасной.
И самое главное,
что многие, когда начинают писать код,
они обычно начинают писать network,
а потом поиск потока начинают реализовывать как метод
network'а. Так вот, так делать
не надо. То есть, ваш алгоритм
к network'у привязан быть
должен не.
У меня есть внешний метод
найти потом...
Вот.
Ну, вот. Значит, смотрите.
В результате,
то есть, нет, просто в реальном коде,
как бы в результате, на самом деле, вот смотрите,
я вам тут же и покажу, да.
То есть, на самом деле, как бы в этом
списке, то ребра перебираются
так. For там, там
допустим int, int равно
значит там
network там условно
begin от v,
int больше либо равно
0, int равно...
А я вспомню, знаете, как я это назвал?
Ука.
Указатель.
Указатель где-то.
От русского слова указатель, да.
Это лучший друг
кола, да.
Кол. Ну, примерно от русского
слова количество.
То есть, это вот мой код. Ука,
кол, вот это все, да.
Кол. Вчера у меня было
к-к-кол.
Там, скажем, и так далее.
То есть, на олипиаде я вот так писал.
Обычно пишу. Ну, вот, в нашем с вами случае
это будет скорее next, ну или там
pref.
Ну, вот. То есть,
вот. Ну, и здесь
вы там, соответственно, вот здесь
понятно, что вы пишете
там edge,
e равно edges от, допустим,
int. Ну, и начинаете с этой
ешкой работать.
Но самое для нас приятное,
то есть, это вот в обычном паскале.
Но самое для нас приятное вот, что
когда вы пихаете поток,
вы говорите, что измениться должно не само
ребро, но еще и его обратное.
А теперь внимание, вопрос.
Как вот по... Вот у вас есть
ребро номер int. Вот вы уже догадываетесь, что
в итераторе, наверное, мы будем хранить
вот этот int, да?
Да.
Нет. Номер ребра.
Ну, вот здесь вообще все просто.
Вот valid int больше либо
равно нуля.
Там, скажем, int равно
там network.next
от int.
Ну, и так далее.
Вот.
Вот видите, все очень просто.
Ну, и здесь все тоже
очень просто. И тогда return
edges от int.
start.
Здесь тоже
то есть, видите, это будут
простейшие геттеры.
Так.
А, get flow я забыл
нарисовать, да?
Вот.
Нет, тут был push flow.
А, этот?
Лучше, конечно, вот так.
Да, да, да.
А, ну, по этой локии int надо с нижним подчеркивать.
Ой.
А, как в таких случаях делают?
А, черт.
Кошмар, тут контролаж не работает,
безобразие.
Автозамена.
А, вот.
Автозамена.
Так вот.
Ну, вот. Ну, соответственно, да, в сети
вот все будет. Ну, вот.
Ну, теперь вот возникает вопрос. Да, ну, в сети
понятно, мы эти все векторы допишем, конечно,
чуть позже. А пока вот возникает
вопрос. Вот, хорошо, есть ребро int,
да? То есть понятно, что мы тут
должны написать?
То есть мы должны тут сказать
edges от int
.flow
плюс равно flow, но это будет безопасно,
да? И edges
какой-то там
там какой-нибудь напарник,
как там этот напарник
по-английски будет?
Не так, боюсь.
Там не edges, а
не edges. Боюсь, что не так.
Да.
Другой mate, нет.
Партнер, компаньон,
там buddy.
А что звучит интересно?
Buddy.
Hey, buddy.
Hey, buddy.
Hey, buddy.
В общем, тот самый напарник,
у которого, ну, помните, у нас есть пара, есть
прямая, либо есть обратная.
А где мы его взяли?
Вот.
Вот теперь вопрос, откуда его взять?
Как функция выглядит?
Ну, а что давайте, мы это уже делаем.
По факту, да,
заметим, что мы парные ребра добавляем
сначала на позицию 0,1,
потом 2,3,
потом 4,5,
потом 6,7.
Почему? Знаем.
Четная прямая, а не
четная обратная.
Так что
в результате,
ну, можно, конечно, писать эту функцию,
просто написать как функцию, если
четная плюс один, если не четная минус один.
Но, на самом деле, Боже упроси так писать.
Потому что, на самом деле,
есть гораздо более изящный,
приятный способ это написать.
Ага, вот.
Вот.
Так что, да. Вот они возникают.
Поэтому я этот способ люблю писать даже на сях.
В общем, на сях часто пишут и половинчатые,
то есть все ребра пишут
в списке, но при этом вектор
векторов сохраняется, просто вектор векторов
хранятся номера ребра.
Это вот, оказывается, удобно.
Но это удобнее, чем там писать, что
там на паре, там ребро 2,5,
так, значит, на паре
находятся векторы номер 5, его номер
там 38.
Вот, или там, кто-то еще
пытается даже указатели на него указывать,
а потом эти указатели падают, потому что вектор
это, называется, реалацируется,
ну и так далее.
А так, на самом деле, очень
удобно.
Потому что у этого способа еще есть всякие
приятные примочки в духе.
Вот, предположим, вам захотелось перебрать все
ребра исходной сети, не обратной, да?
Не остаточной.
Мы можем для каждого ребра выписать, сколько там
реально воды течет.
Как это сделать?
Да.
Ну да, то есть, на самом деле, если мы перебираем
номер 0, 2, 4, 6, 8 и так далее,
то мы перебираем в точности те ребра, которые
в сеть были добавлены.
Да.
Да-да-да-да-да-да.
А мы индекс 3 проинциализировали?
Кто проинциализировали?
Индекс наш.
Какой индекс?
Индекс нижнего чека.
Еще нет.
Но это легко.
Ну, и здесь просто.
Ну да, int
network.
точка
точка, нет, не
start, а begin от V.
Хотя, вот, что-то, хотя
мне кажется, что вот это лучше написать.
Что-то мне кажется, почему-то, думаю, программисты скажут,
что лучше, конечно, вот так написать.
Ну, это
потому что это сложное,
ну, точнее, чуть более сложное, чем нетривиальное
какое-то действие, которое может вызвать
runtime.
В вершин V вы там нету передадите,
вот это все, да?
Почему size-t не визуально?
Size-t?
Да.
Потому что int бывает минус единицей.
Size-t, да?
Вот. Но это, да, это лично
наше техническое это. Мы, конечно, можем сделать
его инф и там сравнивать с инфом все время,
но мне кажется, это не то.
Ну, вот.
Ну, теперь остается только реализовать с этой точки зрения
сам network.
Вот, значит, в network у нас будут
vector, значит, что у нас будет?
Vector edge, edges.
Vector,
значит, int
begin
и
next.
А еще
не помешают, конечно, такие
то есть вот какой-нибудь
size-t n.
Хотя лучше, видимо, возможно.
Хотя вот, да, вот.
Ну, давайте так, size-t n.
Ну, это размер.
Мы можем так и написать
честно vertices number.
И, конечно,
t-vertex, значит,
source и sync.
Которые нам
торжественно вручают.
Ну, вот. Которые нам торжественно
вручают в конструкторе.
Нет, не в конструкторе
итератора, конечно.
Чего?
Edge.
Ой-ой-ой.
Как все сложно.
Ой.
Хотя очень хочется написать
type-def,
edge.
Точнее, наоборот.
Что происходит?
Ой-ой-ой. Давайте без type-def.
А что не так?
Type-def одна из наших у нас
не принято.
Там надо type-edge
туда, ближе туда.
Type-edge равно.
Type-def это опасная ситуация.
Да?
Ну окей.
Подержи, чтобы
было не стесняться. Удобно.
Ну, в данном случае
t-vertex у нас конкретные
в сети, так что.
Поэтому
тут писать не будем.
Usings написали, но условно.
Так, ну он же надеюсь только внутри
будет использоваться.
Вот так написать.
Чтобы совсем хорошо было.
Теперь далее.
Так, что мы там заказываем?
Конструктор.
Ну, я
пишу с нижним подчеркиваем все, что
не для внешнего глаза.
Ну, мне кажется это логично.
То есть это я сигнализирую, что как бы я
не хочу, чтобы это пошло вовне.
То есть это
мой личный t-edge.
От конкретных codestyles зависит.
Ну, то есть я пишу так. Вы можете
всегда как бы. Главное чтобы одинаково.
Если вы пишите с другой стороны, то пожалуйста.
Ну, где как?
Ну, где как?
Лично у меня вот так.
Ну, вот все.
А так да.
А так в каждой конкретной компании там уже вам
подробно настучат по
башке, как надо писать.
Хотя на самом деле
не настучат.
Ну, потому что обычно вы сами будете читать код
и просто автоматически впитывать, как там
подобные вещи пишутся.
Так что этой проблемой не будет.
Нет, иногда конечно там будут, потому что там в правилах
код стайла там в Конкиндексе там вообще первая фраза такая.
Помните, все
написанные правила вам могут произвести вредованы, но
написаны они кровью разработчиков,
которые читали код до вас.
Вот.
Там вот что-то такое. Поэтому
нужно там соблюдать обязательно.
Вот.
Поэтому да. Значит, смотрите.
В сети я, пожалуй, имеет смысл даже
не писать пустой конструктор, а сразу
себе прописать.
Сколько будет вершин?
Vertices number.
Значит, t vertex.
Соответственно, source.
Уберу запятую сейчас. И sync.
Ну,
можно тут сразу написать.
Vertices
number.
Vertices
number.
Далее.
Source от source.
Sync
от sync.
Begin.
Begin от
Vertices number
минус один.
Ну, вообще, конечно, нехорошо так
писать. Помните, принято же писать, на самом деле,
в том порядке, в котором там
реально это задается. Поэтому
edges.
Ну да, потому что по факту-то он
так или иначе это будет делать. Поэтому там
если бы я тут начал бы пользоваться
source ниже подчеркивания, было бы больно.
Вы сказали недавно анекдот
тоже.
Раньше вообще так было, что на оптимизации
он мог вот этот вот список
разбить.
А нет, про вызов функций был.
Он же мог разбить аргументы функций и
непоследовательно их вычислять.
И фита какая-то там такая.
Next.
Next тоже
видим. Тут неинтересно.
И теперь вот.
Вот такой конструктор мы написали.
Да, он больше ничего не делает.
Видите, да?
Значит, добавить
ребра. Здесь очень хочется добавить.
Ну понятно, вы там можете, если вы хотите добавить целый
вектор каких-то ребер, то в каких-то форматах
вы там можете еще адаптеры тут
написать, это не проблема.
Но самое главное
insert edge local, как будет
добавить одно ребро.
Start the vertex.
Start the vertex.
Нет, тут по-хорошему еще конечно
неплохо было бы там написать какую-нибудь проверочку
в духе там.
Вот это вот.
Assert, допустим, source.
Извиняюсь.
Меньше vertices number.
И sync.
Теперь begin.
Что такое begin?
Ну, begin все просто.
Нет,
от, во-первых,
this.
Помните, мы
ж ему ссылочку
на себя любимого доставали.
Поэтому
всегда помним.
Поэтому указатель
на себя любимого это важно.
Так что вот такой вот красота.
Не знаю. Честно говоря, я не знаю.
Я не умею compilite в этом code blocks.
Нет, там build.
Вот build.
А что такое build?
Потому что он вреден.
Нет.
Мы сейчас открыли code blocks в качестве блокнота?
Да.
Могу перевести на code forces.
Можем просто
консоль рейсоваться.
Ага, у меня винда.
Нет,
если я очень хочу это скомпилить, конечно,
у меня есть вот тут рядом рабочая визуалка, но...
Но зачем?
Вот, как это закон, да.
Как это закон этого кода.
Если вы пишите,
там полконтеста, пишите какую-то корневуху,
значит, на самом деле в задаче было решение
за ILOG квадрат.
Ой, это ladder это композиция, что ли?
Не, боже мой.
Ледер там был?
Нет, ледер, но там нет.
Нет, вчера на opencap
была задача, в которой вот там понятие
лесенка возникало, но в совершенно другом контексте.
Потому что задача была, задача даже графами
никак не связана.
Так что можете посмотреть, там веселая задача была.
И вообще это...
Пишите opencap, это просто весело.
Две.
Ну, нормально, я не знаю.
Но это все равно весело, значит, как-то да.
Как-то да.
Ой.
Как-то главное весело.
Теперь надо заниматься, потому что это весело.
Вот.
Значит, вот, смотрите, вот такой вот
network, то есть заметим, что network теперь
самодостаточен. Ну, там можно написать еще
какие-нибудь методы, но, по крайней мере, теперь,
если я захочу написать какой-нибудь алгоритм,
то этот алгоритм у меня, соответственно,
может с этим network работать
как что-то внешнее,
правда?
То есть, я вот с этим вот, я могу
практически, то есть, практически все остальные
функции просто реализовать внешним,
обратить внимание образам.
Потому что, ну, а первое,
я могу, конечно, вот эту, то есть, заметим,
что тут немножко небезопасно, то есть, я гарантирую,
что у меня ребра взаимообратные,
но я не гарантирую, что у меня в каждый момент
времени в сети реально
поток.
Логично, да?
Вот.
Поэтому
поэтому тут получаются всякие,
поэтому можно написать, первое, что можно
попробовать, это писать функцию
там, я не знаю,
называется
is flow
correct?
No.
Там, допустим,
какой-нибудь
network.
Network.
Ну, вот.
Тут лучше по константной ссылке, ладно, не скомпилиться,
конечно, но все-таки. А, хотя
нет, бегинчик-то.
Ну, да.
Ну, ладно, давайте так вот.
Я тут напишу конс бедин, так того, что это
по-хорошему понятно, что там итераторы, дальше там
начинается вот это все, конст, итераторы,
эти все, и так далее.
Ну, это если очень большое желание есть, да?
Ну, вот. Ну, на самом деле,
ну, на самом деле, тут можно так
перебирать. А, ну,
во-первых, давайте думать, что нам надо от сети вообще?
Ну, во-первых, не помешали бы
всякие гетеры в духе, а сколько там
у тебя вершин?
Так.
Ну, вот.
А, ну, ладно, вот давайте я тут напишу еще
assert start меньше
number.
Вот, ну,
здесь-то точно надо.
А,
а еще не помешало бы
по ассерти для надежности, смотрите, какую
штуку, capacity меньше,
чем больше
либо равно, чем tflow
от нуля.
Вот.
Что еще надо?
Ну, еще там
да, можно написать всякие
гетеры. Там, допустим,
size t
get vertices number.
Ну, понятно, да?
Вот. Ну, там всякие еще пару гетеров
можно написать вот эти вот get source,
get sync, да? А, ой!
Мы ж совсем забыли, ой, ой, ой!
Еще важная вещь.
То есть, как бы еще надо проверить,
что
ой, это ж важно, правда.
Аж принципиально,
что исток, исток и совпадают.
Вот, теперь.
Ну, или ответственно.
Ну, вот.
Ну.
That's this number.
Хотя лучше
да, как это, дайте, для краткости.
Что?
Ой!
Ай-яй-яй!
Ай-яй-яй!
Ай-яй-яй!
Ай-яй-яй!
Еще копипаста какая-то, ай-яй-яй!
Ай-яй-яй!
Ай-яй-яй!
Ай-яй-яй!
Ай-яй-яй!
Ай-яй-яй!
Ну, ладно, дайте, как это называется,
главная суть, думаю, вы поняли,
так что остальное.
Так.
Я скомпилил.
Ага, не скомпилил.
Как это скомпилил?
А почему тут network без шаблона?
Где?
Вот здесь.
Ай-яй-яй!
А, ну...
Ну...
Ты...
Тэфлоу,
что там у нас еще было?
А, тэвертакс у нас сначала, да?
Да, не перепутайте.
Ай-яй-яй!
Ага, согласен, ну что делать?
Как бы красота
требует жертв.
Или в программистском случае
человеку часов.
И слоу крэкс?
Вот там тэфлоу.
Где тэфлоу?
Там тэвертакс...
А, да, да, да.
Так, ну да, network,
тэвертакс, тэфлоу.
Значит, поехали,
n достали,
v, значит...
Ну, тут давайте,
тэвертакс... Ну, тут ладно,
тут уже можно написать,
network.getsource.
И, конечно,
то же самое с sync.
А впрочем, на самом деле,
ну вот,
да, если v не равно
source, and then v
не равно sync,
ну вот, ну и дальше
можно написать is, что ли, ну вот.
if.
Значит,
ну вот, дальше вот тут можно написать
что-нибудь другим, я сейчас не буду писать,
getoutside.
getoutflow
от v равно
getinflow, ну, например.
Ну, просто out это сколько реально
исходит, а тут сколько реально входит.
В том плане, чтобы минусы не считать.
Понимаете, да?
Ну, эти функции
можно отдельно написать.
Ну вот, и тут можно написать там
что-нибудь типа
return false.
Чего?
Чего потом может быть некорректным
в плане, когда не собирается первая храбрость?
Все суммируем.
Но, смотрите,
дальше все будет зависеть
от того, как вы функции напишете.
У нас сейчас речь договорится о понятийном аппарате,
а не о том, как
это реализовать, что реализовать можно и так, и так.
Но обычно, как бы, можно
считать, что outflow у меня как-то вот
кажется, что скорее это то, что вытекает,
а inflow то, что втекает.
Можно
как бы написать обобщенный out.
То есть действительно просуммировать, сколько вытекает,
считая, что как бы отрицательное
нас тоже устраивает.
То есть обобщенный,
то есть можно написать так написать, а можно
написать вот действительно там какую-нибудь функцию
if generalized out.
От v равно 0.
То есть и не равно 0.
Нет, вот
а вот философский вопрос. На самом деле
уже нет необходимости.
Потому что при очень
большом желании я могу
на самом деле это сделать как
вот, например, пожалуйста.
В качестве примера я сейчас реализую функцию
get outflow
от
t-vertex v.
Ну, поехали.
Значит, for
допустим, авто.
Ну, авто не очень люблю, конечно, авто.
А, network я забыл
перегнать. Network
t-vertex
t-flow
t-vertex
for значит
network
так
да
мало кто знает, что у команды
плюс семь есть и второе название
плюс семь
девятьсот двадцать шесть
пятьсот тридцать пять
сорок четыре
двадцать восемь
триста пятьдесят два
а
исток
t-vertex
t-vertex
t-vertex
ну да
и вот команда kvn
плюс семь девятьсот шестнадцать
пятьсот тридцать пять
сорок четыре
двадцать восемь
триста пятьдесят два
и
репом
мы
слушно писано
буквально по всем векшинам
а дитал флоу
это вот твест
а ты сейчас пишешь и сфолкаре
ну да
можем конечно и поуважать
но
история зевлона
да и вот get
как бы я пишу t-flow
я вот говорю
и говорю примерно следующее
но чтобы я там
t-flow
f равно
it.getflow
просто вот read
getflow
if f больше ноля ans plus равно f
return ans
вот
просто тупо
так ты указываешь на ребро
а какой у тебя там поток
все
если я хочу inflow
сколько в меня
потому что
я хочу посмотреть сколько
из фолка
из фолка
потому что
я хочу посмотреть сколько
из фолка
потому что я хочу посмотреть сколько
из меня вытекает
то есть вот
например
верно мне что все ребра
из нас вытекают
да
в меня же может течь
отрицательное ребро
не может
хотя
ну давайте так
я подразумевал что-то отрицательное
то есть вот ориентированное
поэтому там получается
что по прямым ребрам
потоки по любому не отрицательны
а это пользователи пишут
ну то есть я ему конечно
могу прописать такие функции он может воспользоваться
а outflow это типа сколько вытекает
то есть сеть ориентированная
нет бывает не ориентированная
не ориентированная сеть от ориентированной
вот можно тоже
она просто отличается тем
что вы вот здесь будете передавать не tflow
а тоже копасть
так что при желании вы тут можете еще четвертое поле
добавить для удобства
вот
ну как
даже буль
типа ребро ориентированное или не ориентированное
вот
но так мне
удобно считать что по ребру
вода бывает либо она вытекает либо
втекает в любом случае
вот
сейчас у меня поток устроен так что
в явном виде написано сколько
по этому ребру течет
то есть на отрицательное число значит течет в глаз
а если положительное
то как бы из нас
поэтому я суммирую все положительные
то есть отличие будет только в том что
вот я перебираю
то есть по большому счету
я вот входящие
сколько в меня
втекает
отличие будет очень простое
то есть да тут
я вот на этом уровне могу if там
way меньше нуля
но я могу взять парное
ребро и посмотреть что оно больше нуля
но как бы это то же самое что
посмотреть что я меньше нуля и тогда тут написать
минус равно пожалуйста
то есть можно копипасту можете это обобщить
ну там
сделать какую-то общую функцию которая там третий
передает какой-то f и потом тут лямбда функцию
писать
да а то же знаете на review у нас это копипасту не любят
еще не любят
не удаляющиеся диалога
кстати
она вам в контесте обязательно
писать в таком стиле
ну а как же
классы отправляй
ну в review да
а в первом семействе
будете на это
попался
попался
нет вот сам нет
самое веселое будет это когда речь дойдет
до ревьюшки с задачей
продэкспер мутейшн
так ну вот будет тест
на то насколько хорошо написал
или уже легче переписать
да
ну посмотрим
что я не знаю
я вначале жестко подумал
надо ли писать мне на эти ноды которые
через new делаются
надо было
вот значит
далее
ну вот
мы ее уже написали вот она
а где
вот
найдите 10 отличий
подсказка их 3
еще раз
два
три
смотрим исходящие
и все
ну смотрите
тут фишка такая как перебрать входящие
ребра
надо перебрать все исходящие
и рассмотреть парты
правда
ну когда мы
перебираем Stevens
не только настоящие ребра
а которые chlorine
то Gulf
а все иму сума
Да, мы их тоже перебираем.
Но почему ребра это пары?
Ну потому что устроено.
Потому что у нас сеть так устроена, помните?
Сеть перебирает всё, что из нас таксит.
Добавляем ребро, добавляем обнимое, как оно есть, и обратное.
Но мы и обнимое добавляем к одной вершине, обратное к другой.
Правильно, поэтому может так случиться, что есть входящее ребро,
его мы добавим как исходящее к той вершине, а обратное добавим уже к нам.
И мы его тоже будем перебирать.
Ну неплохо, а просто надо проверить.
Давайте добавим только одно ребро, между вершинами 1 и 2.
И пустим там поток 1.
Туда 1 из одного, обратно минус 1 из нуля.
Совершенно верно.
Get out flow вернёт нам единичку.
Get out flow от чего?
От первой вершины вернёт единичку.
А get inflow от первой вершины вернёт 0.
Ну если там течёт такой поток, то да.
Ну это хорошо.
Ну да, с этой точки зрения.
Так что если мы хотим что-то обобщать, то можно просто написать вот эту функцию generalized out.
Ну вот это generalized out.
Хотя по-хорошему она называется excess.
Вот в теории Голдберга она называется excess из быта.
Потому что мы там ведём понятие предпоток, в котором откажемся от требований,
что там в каждую сколько втекает, столько вытекает.
Мы будем допускать, что вытекает больше, чем втекает.
Или наоборот, мы допустим, что втекает больше, чем вытекает.
Слышу я про машину.
Не, машина там ни при чём.
Вот.
Не, ну наверное она, да.
Ну вот.
Здесь, а здесь просто и фани будет.
Здесь вообще всё просто.
Generalized out должен быть мод для всех, кроме SP?
Да.
Более того, если вы очень хотите узнать величину потока,
то есть если вы гарантируете, что это поток,
ещё там можно узнать что-нибудь в духе tflow.get.
Господи, как там по-английски величина потока-то вообще?
Ну вот это всё равно что-то вот, что-то не то.
Ну-ка.
Ладно, как в таких случаях?
В таких случаях нас часто выручает английская википедия.
Так, ну-ка давайте-ка.
Так.
Так, ладно.
Так, достаём интернет.
Вот.
Вот.
Вот.
Вот.
Так, достаём интернет.
Так, интернет.
Нет, всё заглючил.
Нет, просто я...
Нет, можно подключиться к Wi-Fi, но просто,
когда я могу просто воткнуть вот эту штуку.
Нет, просто это очень удобно.
Да, как это да?
Как говорится, да, жизнь.
Нет, это жизнь в Хлебниково.
Минус, там нет проводового интернета.
Просто как класс отсутствует.
Ну потому что там видимо малое количество домов,
которые в длинном отдалении лежат.
Ой, ой.
Так, давайте-ка.
Ладно.
Ладно, телефона, ты там зарядился.
Культура, искусство.
Бэбэбэм.
Да.
И всё надо подождать.
Да, придаю.
Но зато преимущество теперь у вас есть интернет не только в Хлебникове,
а и везде, где есть.
Да.
Правда, как вы можете заметить,
лекция через этот интернет
может подтормаживать.
Потому что это
не ваша любимая 100 мегабит в секунду.
40?
Да ладно.
Да ладно.
Всё, мне казалось, там как раз помощнее.
Нет, просто где-то 30-40
это вот-вот-вот у меня вот-вот-вот.
Так, ладно.
Так, ладно,
это неинтересно.
Ладно, что мы там ищем?
Так, Википедия.
Ладно, Википедия.
Flows.
Ну вот.
Flow psychology.
Так, ладно.
Вот так надёжнее.
Вот.
Вот это прям вот про это.
Так, so greedy algorithm
that controls the maximum flow
and flow network.
Maximum flow problems.
Окей, вот-вот-вот-вот-вот.
Ага.
The maximum flow problem.
Так, definition.
Define the capacity.
A flow is a map.
Oh, the value of flow.
Yeah.
Окей.
Let it be.
Да.
Get flow value.
Как это назвать?
Вот так.
Или вот такие часы.
Сейчас я их пишу.
Точнее, я писал, когда готовился.
Сейчас об этом буду.
Ну вот, по факту так.
Вот это вот всё.
Я буду писать.
Вот.
Ну это вот как примеры действительно,
как можно хоть какую-то базовую работу делать.
Я ещё, конечно, не показал,
где нужно делать push flow.
Но я думаю, вы этого уже понимаете.
Да, вам придётся сохранять, правда,
копипастить себе эти итераторы.
То есть, дайте это.
То есть, вы когда-нибудь это писали,
такой BFS, в котором в качестве
прешек от вершины сохраняли итератор.
Вот в этом алгоритме будет.
Ну так, можете потренироваться.
Хотя нет.
Я указатель хранил.
А, ну.
Ну да.
Так, ну вот.
Так что вот.
BFS, соответственно,
могла бы быть написана вот таким вот образом.
В принципе.
Ну да.
В этом смысле вообще в итераторах
тогда начинается быть всякими полезными
ещё всякие пара методов.
Я не знаю.
Вот residual capacity.
И, конечно, его любимый
напарник был isSaturated.
Ну типа насыщенный ли ребро.
Ну вот это вот.
Ну вот.
Ну вот, как-то приблизительно показали.
Не знаю. Что, имеет смысл писать тут
форда, фолкер, этого, Эдмонса Карпа?
Ну да, всё ладно.
Судя по тому, что все уже в телефониках, смысла уже не имеет.
Ладно.
Тогда, я думаю, пришло время сделать перерывчик.
Теперь немножко о задачах на потоке.
Значит, смотрите.
Сразу скажем маленькую техническую вещь.
Значит, сейчас мы немножко абстрадируемся,
потому что крайне редко
нужно именно прям в этом месте
глубоко знать, что в этих потоках написано.
То есть нужно для этого знать только для того, чтобы
оценить, за сколько вы этот поток найдёте.
Потому что, но в остальном
в общем-то нам достаточно знать чёрный ящик.
И, на самом деле, задачи на потоке
бывают двух типов.
Первое, в котором нужно найти поток
из него, построить какую-то
задачу, какую-то сеть, найти в ней
поток и по этому потоку что-то восстановить.
И задача номер два. И тип номер два.
Найти, построить какую-нибудь сеть,
найти в ней минимальный разрез
и по ней что-нибудь восстановить.
Вот будут оба типа, вот сегодня мы рассмотрим.
Ну, вот, например.
Самая классическая задача такого первого
типа, это, конечно,
поиск парасочетания.
Вот задача.
Правда, именно в двудольном графе,
потому что в обычном графе, к сожалению, поток вам не поможет.
А теперь вот, парасочетание в двудольном графе.
Какова постановка задачи?
Постановка задачи очень проста.
Вот, мы, у нас есть
двудольный граф.
Вот, представим себе
вот такое счастье.
У нас есть...
Смотрите.
Так, вот.
Нет, давайте это.
Наверное, когда будет минкост.
Ну, я не знаю.
Судя по количеству пар, которые у нас умещаются,
я думаю, в ближайшие две недели будут.
Ну да.
Нет, самое смешное, что венгекский алгоритм
как дерево отрезков.
Идей на нет необходимости, потому что классический
минкост работает за ту же асимптутику.
Классический минкост, в смысле?
Ну, прям он.
Ну, можно реализовать
минкост пакс флоу, вот этот вот жаггик
с дэйкстр, с потенциалами, тоже за куб.
В этой задачи.
И это мы тоже увидим.
Не волнуйтесь.
Ну, венгек... Нет, венгекка понятно.
С этим, с...
с пфа и...
с...
с...
Ну, там же типа как это...
Чего?
Ну, там по сути Форд Фалкерсон
просто играется и...
Ну, понятно. Окей. Так вот, ребят,
ребят, ребят, давайте вылезаем.
Мы засидели с перерывом, времени мало.
Времени надо, а задачи рассказать много надо, так что.
Давайте, смотрите, сейчас будет...
Значит, пара сочетаний.
Ну, здесь у нас
что требуется?
Ну, требуется обычно найти какое-нибудь ребро.
То есть, требуется найти...
Что называется набор ребер?
Такие, что ни у каких двух из них нет общего конца.
Не инцидент.
Да, никакие два не инцидента.
Там какое-нибудь одно и то же.
И хочется найти, чтобы про сочетание было
как можно больше.
Количество ребов.
Да, причина...
Что это за количество ребов?
Как найти... Причем тут казалось бы поток?
Да, все очень просто.
Да, идея очень простая.
Во-первых, ориентируем
в серебра.
И делаем единичку.
Мы предполагаем, что у нас
просто будет задан граф, нам это гарантирует,
что он двудолен.
Нет, именно задан двудольный граф.
Прям двудольный.
Да, прям двудольный, борько он нам даже две доли задан.
Они заданы автоматом.
Тебе не говорят кто из них тонного?
Не-не-не, обычно говорят.
Кстати, даже.
Можете нам запустить DFS и...
Из левой всегда это только вправо-влево.
Ну да.
Да, вот мы делаем так, что из левой вправо.
Это мы ориентируем, обратите внимание.
В нам дан граф, мы строим сеть.
Это еще не вся сеть.
Мы сказали, что у нас в серебра
пропускной способности один,
ориентированный слева направо.
Еще у нас слева есть
и сток.
Да, мы создаем новую вершину.
И делаем вот такую штуку.
Да, но это классика.
И тоже один.
И, конечно,
сток.
Вот так вот.
Вот так вот.
Один, один, один, один.
Один.
Видите, да? Да.
И тогда, смотрите.
Ну и, как вы уже догадались,
В таких случаях USS trailer стоит проговаривать,
как по потоку восстанавливать parachutania?
Но, при этом, здесь просто видно,
что любому потоку соответствует parachutania,
любому parachutania соответствует поток.
Почему любому потоку соответствует parachutania,
здесь очень важно обратить внимание,
что единички...
Что здесь единички.
Это для того, чтобы в каждую вершину входило не более
чем одна единица потока.
И на выход тоже.
Таким образом, у нас только одно ребро может быть задействовано
когда мы занимаемся вершинкой.
Ну да.
Да, именно.
То есть, видите, не может отсюда выйти две единицы
потока.
Ну, то есть, конечно, формально скажешь, что тут, а вдруг
тут какой-нибудь тут 0.57, тут 0.43, но мы будем искать
поток в ссылочисленном виде, у нас все алгоритмы
будут это делать.
Но алгоритмы почти всегда устроены так, что если сеть
ссылочисленная, то они искать будут поток в ссылочисленном
виде.
Так что теоретически могло быть тут 0.57, 0.43, но этого
не будет.
Так вот, с просочетанием, так что просочетание легко
найти.
Но, правда, бывает, иногда, на самом деле, можно очень
хорошо пооптимизировать.
Потому что есть, так сказать, еще классическая задачка.
Называется кубики.
Ну, знакомая, наверное, задача, потому что, ну вот, ситуация
такая.
Там мальчик какой-нибудь, ладно, пусть сегодня Вася.
Вот.
Он хочет собрать, вот ему дали какое-то мистическое
слово, я не знаю там.
Ну, как всегда, бацаба какая-нибудь.
Да, это уже следующая задача, да.
У нас вроде с кубиков.
Ну, вот.
Аба, цаба, а...
Абра какая-нибудь.
Ну, неважно.
Ну, чтоб поменьше было.
Сейчас увидите почему.
Вот.
Ну, хотя неважно там.
Ну, вот.
Так вот, смотрите.
И у него есть кубики.
То есть кубик, это понятно, это что такое, это ровносторонние
прямоугольные параллельки, верно.
Да.
Ну, да.
Вот.
Значит.
Ну, тут, конечно, на каждой стороне буквы, иногда они
не совпадают.
А иногда совпадают гады такие, ну, неважно.
Вот.
А, б.
Значит, вот это вот.
Тут вообще такой бебешный кубик.
Вот.
Ну, и так далее.
Иногда там вместо кубиков могут быть карточки там
или что-нибудь еще в этом роде.
Далее.
Что еще?
Что-то еще.
На кубиках, если на жарную луку могут быть, да.
А могут, ну, это очень.
Ну, вот.
Ну, вот.
И вот хочется, ну, кубиков много, естественно, даже
больше, чем это.
И очень хочется, для каждого кубика, ну, вот, хочется
поставить кубики так, чтобы они образовали вот заданное
слово.
Ну, естественно, каждый кубик может показывать
только одну.
Ну, как это сделать?
Ну, самый тупой вариант это свести даже не к потоку,
а просто к просочетанию, просто соединить каждую
букву с позиции, значит, на какую он может встать.
То есть, скажем, если тут вот есть буква АБР, то вот
честно так вот все соединяем, да.
Вот.
Видите, да?
Вот.
Если тут только буква Б, ну, значит, соединяем только
вот так.
Видите?
Если буква С, то вот давайте вот так.
Ну, в общем, вот по такому принципу.
В принципе, так можно делать, пока кубик и длина слова
не превосходят 50.
Да, но бывает побольше, где-то даже оба раза по тысячу.
Что делать?
Ну, да.
Ну, диница по-любому придется писать в какой-то момент.
Но, тем не менее, на самом деле, заметим, что конкретно,
когда вы решаете потоком, это все можно, на самом
деле, там сеть можно уменьшить.
Ведь, смотрите, ведь у нас же тут в итоге сеть там
будет вот эта вот 1, 1, 1, правда?
Вот это все 1, 1, 1, 1, да?
Но, с другой стороны, заметим, если кубике написана буква
С, то нам, в общем-то, по барабану, собственно, куда
он конкретно встанет.
Поэтому вместо этого, на самом деле, имеет смысл
сделать примерно следующее.
То есть составить только буквы, которые есть A, B, C, R.
И здесь сделать пропускную способность на этот раз
не 1, а вот сколько букв A, B, C и так далее.
То есть 1, 2, 3, 4, 5, 6, 7.
Там B, соответственно, 1, 2, 3.
Там C, соответственно, 1.
R, соответственно, 1.
То же самое, только вот здесь 7 символизирует, что
как бы 7 кубиков могут стать буквой A.
Вот, понимаете, да?
Вот, понимаете?
Ну вот, пока действительно все просто.
То есть вот такие сокращения тут на этот раз вполне могут быть.
А, фига, ну то есть все слово сжали, да?
Да.
Ну да.
Но в данном случае, опять же, на этот раз единицы потока,
если их декомпозировать, то есть они будут тут
с этим ребром совпадать, но это уже ничего страшного.
Но все равно, каждая единица потока, отдельная единица,
символизирует, что конкретный кубик там взял, там поставился
на какую-то заданную букву.
А у кубиков все равно рыбы и соединечки.
Ну да.
То есть, кстати, если карточки, то на самом деле тут тоже
можно сжимать, потому что заметим, что карточек вообще всего 676.
Ну, представь себе, что это не кубики, а карточки.
Там типа две буковки.
Ну вот.
Если у кубиков их всего 676, тогда сжатие можно сделать здесь.
Тогда эту задачу решают, даже когда там карточек 100 тысяч,
и слово 100 тысяч.
У карточек две буковки.
Ага.
Да.
И нам все еще нужно слово составить.
Да.
Но оба раза 100 тысяч.
И мы сжимаем уже карточки.
Да.
Может их...
676.
Пополам даже.
Что это за числа?
26 продрать.
А, хорошо.
Вот.
Как сейчас мы карточки сжимаем?
Ну просто заметим, что различных типов пар буков у нас всего 676.
А, понял.
Все.
А на самом деле пополам можно.
Потому что карточка AB и карточка BA это одно и то же.
Так что там...
Так что там на самом деле будет что-то типа 338 плюс 13, да.
351.
Сжимаем.
Вот.
Но, конечно, говоря об этом, на самом деле нельзя не поговорить еще.
На самом деле замечаем...
Можно заметить, что на самом деле теория потоков на самом деле позволяет на самом деле доказывать
даже результаты, казалось бы, экологически чистой математики.
Как-то сегодня все очень интересно.
Ну вот.
А вот смотрите.
Потому что вот теперь сейчас будет задача...
Да.
Сейчас будет задача по математике.
Вот сейчас поговорим про такую замечательную вещь, как Лемма Холла.
Она же...
Она же теория Махолла.
А это не о свадьбах?
А, ну...
О свадьбах, о свадьбах.
Нет, нет, о свадьбах.
Ну, тут обычно...
Ну, можно и о свадьбах, конечно.
Нет, о свадьбах обычно там это...
Там есть такой этот эпический механизм, да.
Но это...
Да.
Будет время тоже расскажу.
Это очень смешно.
Вот.
Но в данном случае нет.
Содача звучит так.
У нас есть N мальчиков и M девочек.
Вот.
Вот.
Каждый мальчик хочет подружиться с девочкой.
Вот.
Ну, маленькая проблема, что одна девочка подружиться
может только с одним мальчиком почему-то.
Там, по-моему, обычно день рождения, там что-то балл, там...
Или так.
Ну, разные.
Какая разница?
Ну, разная.
Это классическое.
Ну да.
Ну, мы вообще можем перевести это на язык рэдер.
Сколько можно перевести в способ?
Нет.
Нет вопрос.
А можно ли сделать так, чтобы там...
Можно ли каждому мальчику подружить...
Ну, конечно, есть у каждого мальчика, но здесь простая
бинарная модель.
Ему как бы девочка...
Либо нравится, либо нет.
Все.
То есть там без каких-то там...
Ну вот примеси.
Внимание, вопрос.
Можно ли там действительно...
Мог ли они договориться, что каждый мальчик подружится
со своей...
Сокрытой своей девочкой.
Вот.
У нас N мальчиков и M, да?
Ну, например.
Ну, иногда рассматривают N мальчиков и N девочек,
чтобы было совсем хорошо.
Да, тогда это как бы просочетание, покрывающее все вершины,
называется совершенным.
Ну, в нашем случае даже просочетание будет
просоченным, если просто в нем участвуют все мальчики.
Вот.
Ну, там это на 10 девчонок, там по статистике вот это все.
Вот.
Не надо.
Что не надо?
Ой.
Не надо?
Ну, не знаю.
Как-то надо.
Я понимаю, это физическая ситуация, конечно, мягко
говоря, обратно.
Ну да, чисто вот возьмем эту аудиторию.
Тут у нас тут...
Да, куда в Аню дели?
Вот.
Кошмар.
Кошмар.
Почему у вас Аня болеет?
Безобразие.
Вот.
Дайте смотреть.
Итак.
Ну, вот возникает такая ситуация.
Ну, давайте, ладно.
Так, ладно.
Давайте расслушаем.
Мальчики у нас будут зеленые.
Девочки красные.
Вот.
Теперь смотрите.
Значит, теперь математическое утверждение звучит так,
смотрите.
Вот раз у нас есть мальчики, назовем их L, а девочек назовем
R.
Ну, мальчики налево, девочки...
Понятно.
Вот.
И, соответственно, и теперь, значит, ну, соответственно,
посоединяем, кто там с кем может там это подружиться
и так далее.
У нас есть антисемплярность.
То есть, если она человек девочек, то девочка разума.
Ну, да.
Все-таки считаем, что да.
Ну, и считаем, что да, да.
Тут как-то вот.
Ну, как всегда.
То есть, может состояться пара или нет.
Вот так.
Значит, далее.
Значит, смотрите.
Так, значит, смотрите.
Ребят, ребят, ребят.
Значит, смотрите.
Теперь заметим, что у каждого подмножества мальчиков...
Вот, допустим, вот у нас есть подмножество мальчиков.
Есть такое...
Можно определить нота.
То есть, количество девочек, которые нравятся хотя бы
кому-нибудь из них.
Ну, это же не отображение.
Так что так себе, с образом.
Что решаем?
Лему-колло?
Доказываем.
Ну, сейчас мы ее формулируем для начала.
И это тоже.
А, мы пока еще формулируем.
Это не соответствует.
Это не соответствует.
А, подмножество.
Это не соответствует.
Это не соответствует.
Так, ну, вот ребра.
Это вот просто ребра, как ребра.
И для каждого подмножества можно найти множество девочек, которые нравятся хотя бы кому-нибудь из них.
Именно из них.
Видите, да?
Это определение.
Ну, а теперь вообще заметим, что если существует множество мальчиков, которым нравится меньше девочек,
чем самих этих мальчиков, то у нас будут проблемы.
Ну, если к ним-то пяти мальчикам нравится всего четыре девочки, то в совокупности.
То, кто-то точно останется без девочки.
Вот.
То есть, поэтому, да, если мы хотим, чтобы совершенно...
Чтобы было совершенное просочетание, по крайней мере, с точки зрения мальчиков,
то нужно, чтобы у каждого подмножества размер вот n от a был не меньше, чем размер a, правда?
Но это было бы тривиальное утверждение.
Так вот, Леммахолло утверждает, что это условие не только необходимое, но и достаточно.
Скажем так, значит, формулируем.
Леммахолло.
Она же теория Махолло.
То есть, существует просочетание размера a...
...размера a...
...тогда...
Ну, модулили, конечно.
Тогда и только тогда, когда для любого a подмножества l верно, что модуль n от a...
...больше либо равен модуля a.
Вот такая Лемма.
Да.
Ну да.
То в n от a лежат все напарники множества a.
Хотя бы.
Так что, необходимость в эту сторону очевидна.
То есть, так и напишем.
Пум, очевидно.
А вот в эту сторону...
...при чем тут потоки, да?
А потоки вот причем.
Смотрите.
Ведь существует...
Вот мы должны показать, что пусть это верно, тогда существует просочетание размера l, правда?
Но тогда это то же самое, что сказать, что вот в этой сети существует поток размера l, правда?
Что такое размер потока?
Ну, величина поток.
Вот, что существует поток вот величины l?
Ну, потому что поток просочетания это одно и то же.
А l это что?
Левая доля.
А, левая доля.
Все ясно.
Это вершина левой доли.
Да.
Это l.
Левая доля.
Левая доля.
Левая доля.
Левая доля.
Левая доля.
Все ясно.
Это вершина левой доли.
Да.
Это l, это l.
И справа следует, что существует поток величины l?
Мы хотим показать это.
Хорошо.
Потому что из этого будет следовать, что существует просочетание.
Ну, кажется, да.
Но!
У нас есть теория мафорда Фолкерсона.
Которая говорит нам что?
Максимальный срез.
Которая говорит, что максимальный поток равен минимальному разрезу.
Значит нам надо показать, что минимальный, даже нам достаточно показать, что минимальный разрез в этой сети не меньше, чем l.
Ну ладно.
Ну ладно.
Правда, заметим, что величина l всегда найдется, вот такой разрез хотя бы, да?
Вот он имеет ровно l, да?
Но нам надо доказать, что он минимален.
То есть в переводе говоря, надо просто показать, что любой разрез в этой сети имеет пропускную способность не меньше, чем l.
И этого будет достаточно.
Значит, поехали.
Ну что ж, давайте проведем разрез.
Вот так вот мы его проведем.
И теперь смотрите.
Давайте назовем, значит смотрите, давайте может быть, для красоты назовем это ls.
Это lt.
Ну и здесь соответственно rt и rs вот тут.
rt.
Вот.
А теперь, значит, вот такой вот разрез.
Это вот s, это t.
Значит, поехали.
Значит, пропускная способность.
Значит, давайте теперь думать.
Чему равна пропускная способность?
C от st.
Чего?
lt, ls.
ls.
Сейчас, да, да, да, правильно, правильно.
Ну, значит, смотрите, сейчас напишем.
Пишем, ой, не туда.
Значит, смотрите, сейчас все уби.
Нет, смотрите.
Пропускная способность этого разреза.
То есть сумма, в нашем случае это тупо количество, ну как бы, тупо количество ребер, ведущих отсюда туда.
Это просто определение.
Ну у нас тут все ребра единичные, поэтому тупо суммируем количество ребер.
Значит, поехали.
Да, давайте вот сейчас пропишем аккуратненько.
Во-первых, ребра у нас будет трех типов.
Из s в l, из l в l и из r в t.
Сколько ребер из s в l у нас пересекают этот разрез?
lt, rs.
Да, в точности lt, совершенно верно.
Значит, второго типа тоже вот.
Из r в t тут, очевидно, модуль rs.
Плюс, ну давайте аккуратненько запишем.
Значит, c.
Ну давайте так запишем.
c из ls в rt, вот так напишем.
А как вы прям равенство замените?
Это, по-моему, неправда.
Почему?
Потому что у нас есть вершины, которые меняются.
Ну потому что в rs, ну как бы как минимум, потому что не все вершины, не во все вершины из rs ведут ребровый лес.
Ну тогда больше и не ровно.
Вот.
Но теперь заметим, я теперь утверждаю следующее.
Я утверждаю, что c от ls мы можем оценить снизу.
Следующим образом.
Смотрите.
Ведь мы, смотрите, заметим, что из ls ведут ребра как минимум в модуль ls вершин, правда?
Сейчас.
Ну, смотрите, существует как минимум модуль ls вершин.
Вот я тут даже начну писать.
Модуль ls вершин.
Существует как минимум модуль ls вершин, в которые из этих вершин ведут ребра, правда?
Нет.
Что?
Соседи, потому что.
А, если вот это.
Да, мы же напоминаем.
Мы доказываем, что если вот это, то вот это.
Мы же не абстрактно доказываем, что дан двудольный граф докажет, что там существует совершенно предсочинание.
Это просто неправда.
Вот.
Но, нет, ну, это не правда.
Я еще не дописал.
Скажем так, это была бы правда, если бы я написал вот так.
Вот это правда?
Да.
Но, конечно же, c.
А теперь, заметим, вот, если просто и c из ls.
Вот сколько ребер соединяет ls с r?
Как минимум ls.
А можно уточнить?
Заметим, что c от ls в rt.
Это что такое?
Это c от ls в rt.
Да?
Значит, просто в r.
Минус c от ls rs.
Теперь давайте оценивать снизу.
Это, как минимум, ls.
А этот минус?
Ну, как, ну, вот.
Ну, его надо, тут наоборот, c от ls rs надо оценить сверху.
Ну, это сложно, потому что непонятно, сколько между ними ребер.
Ну, это не совсем, да.
Когда ls может быть маленьким, тогда нас это может не устроить.
Да, но само по себе это, да, само по себе это не поможет.
Но, тем не менее, я утверждаю следующее.
Что у нас, у нас даже более важно, мы даже не на языке c,
а просто мы замечаем, что в хотя бы ls вершин у нас ведут ребра.
Правда?
Да.
Мы замечаем, что в хотя бы ls вершин у нас ведут ребра.
Правда?
Ну, раз хотя бы в ls вершин справа у нас ведут ребра,
то это означает, что в доле rt находится хотя бы ls минус rs.
Туда, туда.
Нет, это я, к сожалению, оценить сверху, как вот это не могу.
А именно в ls в r или в rt?
Вот, нет, именно вот так, да.
Да, пардон, пардон, пардон.
Значит, вот такое мистическое утверждение.
Значит, еще раз, почему так?
Потому что, смотрите, давайте я картинку нарисую.
Вот, значит, картинка такая.
Ну, давайте я вот тут локально нарисую.
Вот у вас вот разрез, да?
И вот вы знаете, что вот у вас есть множество ls, да?
Видите, да?
Мы знаем, что из него торчат ребра.
Какие-то вот, может быть, много, но торчат.
В какое-то, может быть, много, но торчат.
В какое-то множество вот этого.
Оно называется ntls.
Вот видите, да?
В нем его размер больше, чем ls.
Да, вот, но это в сумме, да?
Но заметим следующее, что какие-то вершины находятся вдоль t, какие-то вдоль f.
Но вдоль s находятся не более, чем ntls.
Вот столько вершин.
Да, но это и есть просто вот, не более, чем вот столько вершин, правда?
А это и есть rs.
То есть, следовательно, вот здесь, вот в этой доле не меньше, чем вот ls-rs.
И в каждой из них идет хотя бы одно ребро.
Может и больше, но оценивает снизу, поэтому нас устраивает.
Поэтому все, что нам остается, это писать
модуль lt плюс модуль rs плюс модуль ls минус модуль rs.
Шлеп-шлеп.
Да.
Все.
Лемма доказывает.
Как бы, узрите силу теремы форда Фолкерсона.
Да.
Да, вы, конечно, могли там доказывать, типа там эта удлиняющая цепь там какая-то существует.
Запустим tfs, но по факту на самом деле то, что вы делаете,
уже давно сделал за вас теремы форда Фолкерсона в доказательстве.
То есть, если вы там думаете, что там удлиняющая цепь,
запустим куда-то там что-то, ориентируем какие-то там ребра,
куда-то там как в куне, то заметим, что...
Ну вот, то на самом деле, как бы это все, скорее всего,
была часть доказательства теремы форда Фолкерсона в той части,
когда вы там искали максимальный поток и минимальный разрез.
А кто раньше придумал теремы форда Фолкерсона?
Ох ты, хороший вопрос.
Боюсь, что был.
Есть такое подозрение.
Ну давайте.
Вы сказали, что tst больше равно, чем a.
Так, сейчас.
А, 3, так.
Не, ну да, Лемма.
Нет, смотрите, Лемма ходит.
Tst больше равно, чем a.
Зачем это делать?
Ну, поскольку у тебя мощность любого,
и, как можно сказать, способность любого разреза больше,
чем мощность l,
то максимальный поток форда Фолкерсона,
у тебя максимальный поток тоже больше либо равен,
чем модуль a.
Значит, существует про сочетание хотя бы l размера.
О, классно.
Да, забавно, википедию, открываю википедию.
Ой, ладно, давайте так.
Ну, да, там всякое что-то есть.
Ну да, потому что там можно показать, что докажем,
что есть удлиняющие цепи, бла-бла-бла.
Нет, ну мы это все будем обсуждать в про сочетаниях,
но на самом деле просто я отвержаю,
что все эти понятия удлиняющие цепи,
это просто следствие вот этой теории.
На самом деле все.
Да, я не так говорю.
Да, я не так говорю.
Ну, все так говорят.
Тут вообще забавно, потому что я вам сейчас википедию
покажу, вы удивитесь.
О, видите там?
Ну ладно, давайте уже.
О, видали?
Значит, смотрите.
Ну вот, то есть забавно.
Начало доказано в 35-м году, да?
Да.
Но при этом первое.
Одно из доказательств страливает немедленно
из венгерского алгоритма для поиска максимального
просочетания в графе.
А также является следствием мистерима
Форда Фулкер Сода о разрезаниях.
Вот.
Для случая регулярных графов в степени 2 в степени
N тиремма легко выводится в существовании Эллерово
цикла.
Что такое регулярные графы?
А это когда у каждой вершины степень одинаковая.
Кстати, у вас в домашней задании будет такая задачка.
Решить были?
Ну вот.
Вот схема та же, реально.
Надо доказать, типа?
Ну там фактически будет дан-дан-дерегулярный граф.
То есть вдольный граф, у которого все степени
вершины равны D.
Ну, во-первых, такая задача A.
Докажите, что существует совершенное просочетание.
И B.
Докажите, что, на самом деле, ребра можно разбить
на D просочетаний.
Совершенно.
Что такое совершенное?
Которое покрывает все вершины.
Ну понятно, что одно, на самом деле, эти два вершины
не эквиваленты, по сути.
Ну вот.
А доказательства там вот, ну как хотите, можно, конечно,
через удлиняющую цепь, но на самом деле вот.
Вот так, по мне, так даже рассуждение сильно проще.
А, ну вот, пожалуйста, идти.
Тут считается немедленно.
Вот.
Ну, туда, ой, теория макеонига.
Так что-то, казалось, что-то умное, теория макеонига
будет, да.
Ой, ладно, теория макеонига, это будет умнее.
Ага.
Так.
Ой.
Так, вот интрига.
Что такое, в данном случае, венгерский алгоритм?
Нет, просто вообще, по умолчанию, венгерский алгоритм
это поиск именкоста.
Когда там дан двудольный крафт только взвешенный,
найдите совершенно просочетание, но минимального веса.
Вообще, это называется венгерский алгоритм.
Но что-то у русской википедии, видимо, другое мнение
по данному вопросу.
А назначение?
Ну, да, да.
Задача о назначении.
Ну, да, да, да.
Задача о назначении.
Ну, да, да, вот странно.
Так, вот.
А, нет.
Нет, правда, заметим, что венгерский алгоритм, да,
он тоже, видите.
То есть, как-то, заметим, что, собственно, товарищ Кун
в этом тоже участвовал.
Да, Кун это венгер, как легко видно из фамилии, да.
Так он, по идее, есть алгоритм Кун, да?
Нет, но там другой алгоритм.
Ну, да, в смысле, что изначально же он придумал.
Нет, но там не совсем так.
Понимаете, почему он венгерский?
Потому что, но я не знаю, странно, что Джеймс,
ну, да.
Хотя странно, он венгерский.
Потому что у меня было сведение, что там жили были два венгра
и решили эту задачу за Энк четвертый.
Потом пришли еще два венгра и сказали, что можно закупы-то пилить.
Ну, вот, Википедия говорит то же самое, но что-то,
но утверждает, что вторых венгров звали Эдмонс и Карп.
А первые вообще Кун и Манкросс.
И такой, да, с таким, таким, да, типичным венгерским именем Джеймс.
Да.
Ну, вот.
Ой, да, да, да, ой, классно, да.
Тот самый Якови, который там что-то для матрицы придумал метод.
Ох ты, да какая-то, ой.
А, оказалось это, ой, да, ой, да, на латыни мало нет, да.
Интересно, а, ну, тогда, может, и читали, когда долгое время, по-моему.
Ну, хотя вот в это время, ну, хотя я не знаю, в каком году,
на каком языке тогда общались.
Нет, я помню, что долгое время международным языком общение было латинский, собственно, да.
И на языком науки тоже, но не до такой же степени.
Господи, форты, фалкиксы, ну, что-то странное, в общем, окей.
А еще и незадатые медзалы, независимо они.
Вот это, давайте опубликуйте алгоритм, потом вас уедят, называется.
Поэтому иногда страшно опубликовать, да.
А то опубликуешь там это ено обратную функцию кирмана,
потом говорят, что его допилят за латки, на самом деле.
Или за корень из обратной функции кирмана.
Корень из обратной функции кирмана.
В целом, о таких амсимптутиках я не слышал.
А вот почему, смотрите, кунг 55-й год,
и он говорит, что метод венгерский алгоритм основан на более ранних работах
двух венгерских патематиков, вот Кёнига и Герлари.
Ну ладно, до этого мы дойдем.
Вот.
А, мы еще хотели...
Да.
Так, а мы еще хотели выяснить про тиримфорда Фолкерсона, про ее, когда она...
Ой, теряем момент герау.
Да.
Да.
Сечение, ой-ой-ой, историю можно?
А, но история, впрочем, лечится очень просто.
Definition statement.
Так, ну ладно, если вам тут, если это не рассказывают,
то как бы, тогда это делается так.
Вот можно...
Ага.
Тогда, в случае чего, вот просто есть вот, когда были работы,
ну видимо, вот видите, как бы, скорее всего, 56-й.
Так что там, товарищи, видимо, плюс-минус в одну сторону думали тогда.
Вот. Так что несу.
Ладно.
Так.
Так, что там у нас есть еще?
Так, сколько у нас там еще времени?
Сейчас 35 минут.
Так, 10 минут, да.
Так.
Ну, знаю, где будет параметр.
Вот так.
Да.
О.
Так.
Ладно, ну вот, ну с просочетаниями, ладно.
С просочетаниями пока все.
Я думаю, пока, наверное, Куна выводить не будем.
Ну, потому что там, если уж это выводить,
то там надо будет отдельно вот эти все теоремы и кео, там кеонега доказывать.
Которые, по сути, там, превершенные покрытия, вот это все.
Это называется теорема кеонега.
Вот.
Ну вот.
Ну, а пока же, ладно, значит, тогда.
Ну вот.
А пока же можно рассмотреть, значит, пример.
Как, вот, какой-нибудь еще такой пример задачки.
Ну, такой, сейчас я вот расскажу такой пример еще веселой задачки.
Значит, такой, по крайней мере, базовой.
И уже рекомендую вам тогда попробовать, собственно, там, домашние задания порешать.
Думаю, честно, вот, честно скажу на этот раз.
Если вы попробуете сами, ну, там, уже не ваше там ревью, не ревью, а покодить.
Там, покодить вот эти там задачи.
То, соответственно, тогда и там, доходите к следующему разу,
то тогда происходящее, тогда, на следующем, на следующем семинаре,
как бы, до следующей лекции для вас будет сильно проще.
А про что в следующей лекции?
Ну.
Ну, во-первых, блокирующий поток единиц.
Да, предупреждаю, да.
Если что, может так случайно получиться, что у вас это, форкполки, это тэдбонскак не зайдет.
Ну, это, ну, маловероятно такое может быть.
В случае чего, не пугайтесь, значит, есть более быстрый алгоритм.
Ну, а как бы, если вы там напишите и получите ТЛ сколько-нибудь.
Не, ну, там так, если вы получите там ТЛ сколько-нибудь, значит, уже хорошо.
Скорее всего.
Чего?
Чего?
Да, там пока сломано.
Нажимаешь на эту новую задачу, а меня отравляют в старые задачи.
А, ой-ой-ой, да, поправим, поправим, поправим.
Какое безобразие.
Так, ладно, решим.
Ну, вот, а пока, ну, соответственно, вам придется еще решать какие-то задачи.
Значит, вот сейчас рассмотрим такой первый пример, наверное, не последний.
Пример из задачек на минимальный разрез.
Ну, такой, достаточно типичным таким примером является такая классическая задача.
Я не помню, что мы это определяли.
Мы доказывали это.
Мы определяли, что такое разрез.
Мы определяли, что у разреза есть пропускная способность.
Мы сравнивали разрезы по простой способности.
Находили минимальную.
Это и есть минимальный разрез.
Так вот, задача – ярость и команда.
Ну, представьте, что у вас есть стартап.
Вот вы оставали компанию, и вы там что-то программируете.
Изначально у вас там мало людей.
Ну, там два, три, там пять.
Ну, потом не, пока два, три, пять.
Но команда все равно, скорее всего, работает все вместе.
Часто просто в одном помещении.
Все все кодят и радуются.
Да, пишут всякую игру на кодинге.
Ну, вот, но самое главное, что все все вместе там обсуждают.
Этого явных распределений обязанности особо нет.
Имитации будем имитировать?
Нет, почему имитации? Нет, активно пишете.
Но стартап, как это бывает, оказался успешным.
Как это не было?
Ну, как сказать, да, понятно, что изначально было нас двое.
Как говорится, да, называется, Марк писал код, я выкапывал сервера под Linux.
Называется, да, такая нота.
И потом, собственно, появился Facebook.
Но стартапчик развивался.
Так, развивался, развивался.
Количество людей увеличилось.
Пять, десять, двадцать, пятьдесят.
И в какой-то момент вы поняли, что находиться в одной комнате,
чтобы все все обсуждали и все со всеми были в курсе.
Это уже сложно.
Поэтому вы поняли, что пришло время разделять компанию на подотделы.
Ну, в качестве примера вы решили поделить задачу, скажем, на...
Ну, там, потому что тем более люди разные.
То есть поэтому, давайте, ладно, давайте вот.
Программирование, написание документации.
Ну, давайте, ладно, я обычно говорил программисты и тестировщики.
Тестировщики...
Но ладно, давайте так.
Б, программисты...
Да, а давайте, программисты и тестировщики.
Ну, можно программисты и менеджеры, если хотите.
Но это не разделить.
Лучше тестировщики, потому сткм менеджеры,
каждый менеджер, он командует все-таки программистами.
А тут, разделение на два раздела.
Значит, нужны тоже будут программисты.
Значит, там, соответственно, понятно программисты и тестировщики.
тестировщины. Как разделить людей? Ну, если у вас N человек, то разделить, конечно, можно
два степени N способа. Вот, типа берем и разделяем. Но как же конкретно разделить? Ну, как сказать,
как это часто бывает в маленьких стартапах, процветает демократия. Поэтому вы решили спросить,
о чем по поводу разделения думают сами люди. Вот кто-то, наверное, больше хочет быть программистом,
кто-то хочет быть тестировщиком. И, значит, вы привелись в этот вопрос и выяснили интересное
свете. Оказывается, некоторые люди... Нет, вот даже не так сделаем. Давайте тестировщики будут
красненькими. Значит, вот смотрите, оказывается, есть некоторые товарищи, которые очень хотят быть
программистами. Что значит очень хотят? Это означает, что, если вы их сделаете тестировщиками,
они будут плакать. Нет, может, не уволятся. Нет, пока не уволятся, но они будут плакать. В общем,
короче, плакать и, называется, уровень ярости, уровень, так сказать, недовольства, уровень плача.
Тогда если их сделать тестировщиками, увеличится на А. Больше нуля. Нет, пока еще не надо. А есть
люди, которые, наоборот, хотят быть тестировщиками. Наоборот, если вы вот какого-то товарища сделаете
программистом, он тоже будет плакать. Его уровень слез БВ. У кого как? Что кто-то поплачет,
но по мелочи, а кто-то будет прям, вот я не знаю, просто разнесет офис. Ну да, в таких случаях мы
пишем плюс бесконечность. Да, кстати, хороший прием в сетях, когда вы строите поток. Если вам
нужно запретить что-то, то обычно в этом появляется ребропус, то есть способности плюс бесконечность.
Ну сейчас мы увидим. Ну ладно, в таком виде задачу было бы просто решать. То есть как бы давайте
программистов сделаем программистами, тестировщиков тестировщиками и не паримся. Но выяснилось еще
такие интересные вещи. Оказывается, некоторые люди дружат. Вот так дружат в смысле хотят работать
вместе. И с этой точки зрения, если окажется, что они разойдутся по разным командам, то они тоже
начнут плакать. Органь плакать. Вот, что еще бывает? Так какие еще буквы есть? А есть еще всякие
конфликты. Я не хочу, чтобы он тестил мой код. Или наоборот, я не хочу тестить его код. Вот поэтому
если я стану программистом, а он тестировщиком, то я буду очень сильно возмущаться. Вот если я
программист, а он тестировщик, то не Т, как какую-то букву З. Ну пока они счастливо избегали этой
ситуации. Да. Нет, наоборот, они хотят либо быть оба программистом, либо оба тестировщиками. Что
о противнике? А вот такого нет. Вот да, если мы хотим решать задачу по токам, то нам принципиально,
к сожалению. Эта задача не очень такая. А этот мне хочет, чтобы я был программистом. То есть меня
устроит, если я буду его тестировать, меня устроит, если мы будем оба программировать,
если я буду программировать, а он будет меня тестировать, то бэ-бэ-бэ-бэ-бэ-бэ-бэ-бэ-бэ-бэ-бэ-бэ-бэ-бэ-бэ-бэ-бэ-бэ-бэ-бэ-бэ-бэ-бэ-бэ-бэ-бэ-бэ-бэ-бэ-бэ-бэ-бэ-бэ-бэ-бэ-бэ-бэ-бэ-бэ-бэ-бэ-бэ-бэ-бэ-бэ-бэ-бэ-бэ-бэ-бэ-бэ-бэ-бэ-бэ-бэ-бэ-бэ-бэ-бэ-бэ-бэ-бэ-бэ-бэ-бэ-бэ-бэ-бэ-бэ
вот такое тоже бывает
вот собрали мы такие сведения
и теперь думаем, как бы их разделить так, чтобы суммарного плача было как можно меньше
что пас? вот у и в это
грешинка у хочет быть программистом
то есть у нее условия только на одном
если она будет в t
ну не совсем, на самом деле у каждой вершины может быть несколько условий
то есть у каждой вершины свое ау т, свое бу т
б в это может быть, ну у некоторых ноль конечно
microphones
и они бывают связаны вот некоторыми дружественными
я mogą
да
я не не не наоборот
он не хочет, что бы я был programmer, а он тестировщик
а не�igen
digo
то есть, что бы я был programmer, и он Hoyt
Сколько-то программистов, сколько-то тестировщиков?
Ну да, все, кто у нас есть, мы делим на программистов и тестировщиков.
Хорошо.
Вот так жестко.
Решаем?
Да.
И вот, при чем тут? Ну, не решаем-то себе, сводим.
А чем тогда дружба отличается от вражды?
Отличается тем, что здесь нас устраивает...
То есть здесь нас не устраивает, когда там, скажем, X-тестировщик, а Y-программист.
А здесь нас устраивает, когда W-тестировщик, а Z-программист.
А, то есть нас наоборот устраивает?
Поэтому я вот рисую. Вот так.
То есть когда они оба одинаковые, их это не устраивает?
Нет, их это устраивает.
Где?
И тут, и тут, если они в одном отделе, их это устраивает.
Снизу плохо только если первый программист, второй тестировщик, а сверху плохо, если они в разных отделах.
А что такое дело?
Либо первый программист, второй тестировщик...
У нас два дела. Программисты, тестировщики.
То есть когда они вместе...
Так, они не вместе. А что вторые так делают? W и Z?
Это когда W-программист, а Z-программист.
Когда они в разных отделах?
Нет, прям ровно так. W-программист, Z-программист. Все плохо.
А, все понятно.
Ну вот, начинайте.
А теперь...
Уже нету.
Но решение такое...
Сейчас мы сведем задачу.
Сейчас мы сведем...
Мы построим сеть.
Такую, что пропускная способность любого разреза будет соответствовать...
Соответствовать какому-то плачу соответствующего разбиения на программистов и тестировщиков.
Вот если мы построим такую сеть, то останется в ней только найти минимальный разрез и сказать что угодно.
Как мы это будем делать?
Ну, давайте вообразим себе...
Этот уже мысленно разрез.
Значит, да, у нас будет и сток.
Это будет новая эффективная вершина.
И будет сток.
То есть у нас будет только и сток, сток, и все вершины соответствующих сотрудников.
Больше у нас ничего не будет.
Итак, смотрите.
Как нам сделать...
Как нам теперь разобраться, чтобы...
Программист. Если он будет тестировщиком, то АУ.
Тогда мы поступим с вершиной У следующим образом.
Мы соединим и сток с этой вершиной У ребром пропускной способности АУ.
Тогда если в разбиении он окажется в тестировщика, то в пропускной способности появится пропускная способность АУ вот этого ребра.
А если он окажется в С, то не появится.
Обратите внимание, это ребро ничего не пересечет.
Давай туда добавим БВ.
Да, БВ.
Совершенно верно.
То есть хотим привязка...
Если идет привязка к тестировщикам, то, пожалуйста, то же самое сток.
Видите, да?
То есть это вершина В, а пропускная способность будет БВ.
А с какой стороны программист, а с какой?
Это будет программист, это тестировщики.
Ну видите, зеленые, красные.
И, соответственно, тут тестировщики.
Вот.
Ну как это говорят?
Это буква Л.
Это оно ведет для того, чтобы если вершина У окажется в доле Т, то тогда это ребро будет участвовать в разрезе с пропускной способностью АУ.
Это я просто, потому что я от балды сейчас так рисую.
То есть разреза этого-то реально нет.
Он подберет разрез, чтобы там сумма блока была меньше.
Но мы главное знаем, что в пропустой способности любого разреза вот это ребро поучаствует, если У пойдет не туда, и не поучаствует, если У пойдет туда.
Что делать с Х-игроком?
Ну вот я на самом деле, вот я как тут нарисовал на самом деле, что с ними надо делать.
Потому что Х-игрок надо просто соединить вот, можно сказать, двумя ориентированными ребрами с пропускной способностью ЦХ.
Тогда, если они окажутся в разных отделах, то сыграет ровно одно из этих ребр.
Обратите внимание, вот это сыграет, а это нет, если вот Х-игрок реально вот так.
То есть важно, вот видите, почему я вот именно настаиваю.
Вот теперь я хочу, чтобы не было так, чтобы W программиста Z тестировщик.
Тогда, на этот раз я добавлю только ребро в одну сторону.
Тогда обратите внимание, если W программиста Z тестировщик, то это ребро сыграет.
Но если ребро, например, вот такое, то это ребро не сыграет.
Потому что, напоминаю, в разрезе участвует в пропустой способности только ребра, идущие строго из доли С, строго в долю Т.
Наоборот, нам не интересно.
Когда мы пропустную способность ищем, помните, да?
То есть, да, в чистом потоке мы эти ребра тоже учитывали и вычитали, но в пропустной способности мы этого не учитывали.
То есть, вот такая красота.
То есть, вот общая суть, вот как раз заключается в том,
вот как раз она заключается именно в том, что на самом деле вот, то есть теперь, что каждому разрезу будет соответствовать четкая пропускная способность.
То есть, всегда, когда у вас есть задача разбить какой-нибудь граф на какие-нибудь две доли, то зачастую ее можно свести к задаче о поиске мин разреза вот в какого-то подобного рода сети.
То есть, там максимальный поток?
Да.
Ну, там максимальный поток плюс ДФС за ООО отъесом разреза.
А можно придумать так, чтобы у нас два сотрудника не могли оказаться в одном отеле?
Вот пока это таким методом, честно, я не знаю.
Как мы учитываем условия У и БВ, когда они у нас разрезают?
А очень просто, смотрите. Вопрос как бы, вот если У оказался среди тестировщиков, а хотел быть программистом, то тогда вот это вот ребро из стока У пропускной способности АУ, оно войдет в разрез и увеличит его пропускную способность на АУ.
А если у нас вершина окажется наоборот, как она и хотела программистам, то соответствующее ребро не войдет в разрез и учтено не будет.
Наверное стоит сказать, что для каждой вершины мы приведем свое АУ и свое БУ.
Ну, чаще всего будет 0, да.
И дополнительно вот так?
Ну да. Да, там понятно, теоретически может быть, что вершина там и зеленая и красная, конечно, может быть, да.
Но это не глобально.
Но я подозреваю, что у каждой вершины все-таки хочет быть либо программистом, либо тестировщиком.
Нет, можно предположить, что кто-то очень не хочет просто против разделения.
Если вы меня сделаете программистом, я буду плакать, а если сделаете тестировщиком, я все равно буду плакать.
Но тогда с этой точки зрения ладно, он все равно будет плакать, потому что ничего не попишешь.
Нет, ну дайте денег.
Ну, что сразу деньги? Стартап успешный, так что с деньгами ни у кого проблем нет.
Но это другой вопрос.
Вот.
Мы уже решаем задачи предположений, да.
Так что вот такая задача.
То есть вот много еще таких задач, вот у вас там...
То есть вот сейчас я на самом деле добавил еще не все задачи, которые у вас на ваших заданиях будут.
Но я утверждаю, что все задачи, которые у вас есть, вот вы уже можете решить, ну по модулю может быть алгоритма Деница.
Но, то есть уже попробовать можно.
То есть в первую очередь как вообще сеть строить.
Так что вот рекомендую попробовать.
Тем более, что у вас есть задача Мотан, она будет ревьюшной.
У Мотана есть?
А что Мотан?
Там есть задача Мотан.
Ну почитайте в условии.
Там идея очень такая.
Ну, что красивая, так как?
Я только не помню, она говорит, я помню, что она красивая.
Ну я бы сказал так, она вот такая же на самом деле.
Ну там что-то такое же.
Вот идентичная, просто вот в эту сторону подумайте и будет с вами счастье.
