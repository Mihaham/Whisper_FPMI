Так, сегодня последняя лекция семестра, одна очень крутая фича RASTA, даже не фича RASTA, а синхронные модели RASTA.
Мы уже знаем о параллельных вычислениях в RASTA, теперь осталось узнать, что же там с синхронными вычислениями.
Как вы знаете, с курса Concurrency нам нужна некоторая поддержка со стороны языка, чтобы нам было удобно писать синхронный код.
Вот она в RASTA есть, мы будем смотреть вглубь, как она устроена.
Во-первых, в этой лекции мы посмотрим сначала на то, что такое генератор.
Вы знаете, что такое генераторы, в принципе, спитона, например.
Но нам это важно посмотреть конкретно в RASTA, потому что оно будет похоже на то, как мы дальше будем устраивать нашу future.
Потом будет такой концепт, называемый pinning, который предназначен для Self-referential структурок.
Потом мы посмотрим на упрощенный вариант future, чтобы понять, какая основная идея.
И затем на sync и await ключевое слово, которое предназначено для того, чтобы генерировать стейт машины.
Ну и наконец, только в этот момент мы сможем понять, а как сверху устроена синхронность в RASTA.
Посмотрим прямо на модель.
Затем вернемся к реальному trait of future, добавим в нее очень важную вещь, контекст.
Ну и напишем какой-то очень-очень простенький синхронный runtime.
С огромным количеством недостатков, но тем не менее работающим.
Так, генераторы. Вы должны быть с ними уже прекрасно знакомы.
Вот такой вот код вы можете увидеть себе в Python.
Это такой способ превратить функцию во что-то вроде итератора.
Например, такая вот функция последовательно будет выдавать 1, 2, 3.
Ну и потом будет в случае Python exception, что это end of iteration.
В общем, конец генератора. Точно не помню, какое будет сообщение.
В RASTA у нас тоже есть генераторы.
Генератор – это такой объект, который представляет из себя какую-то рутину,
какое-то вычисление, которое можно резюить.
Ну и, соответственно, у нас есть таких генераторов очень много,
поэтому это trait, чтобы их обобщить между собой.
Trait у нас предназначается, как мы помним, для того чтобы какие-то общие вещи
между объектами выделять.
Ну и вот у нас trait обобщает генераторы.
Конкретно в RASTA все, что мы будем говорить дальше, кроме генераторов,
оно стабилизировано, а у генератора не стабилизировано.
Мы будем говорить о нестабильной фиче RASTA.
Но, тем не менее, она нам будет очень полезна.
Давайте посмотрим на некоторый упрощенный вариант генератора,
который, наверное, переделают в будущем.
Это чуть-чуть упрощенная, без одного аргумента в резюме,
версия генератора, которая есть в unstable RASTA.
У нас есть какой-то state, ну и сам trait – генератор.
Когда вы вызываете генератор, до тех пор, пока у вас yield происходит,
вы возвращаете какое-то одно возвращаемое значение.
Ну и потом у вас в конце происходит return.
Тогда вы знаете, что у вас закончилась итерация по генератору.
Ну и, соответственно, yield и return имеют разные типы.
Вы можете даже возвращать yield одно, а return другое.
Вот. Ну и, видите, тут meet self.
Возвращаем что-то одно из этого.
Давайте посмотрим на какой-то примерчик, чтобы было чуть-чуть понятнее, что происходит.
Вот какое-то чиселко взяли, замували его внутрь.
Сначала выводим hello сообщение,
потом возвращаем из нашего генератора восьмерку и выводим world.
Ну, соответственно, тут будет у нас вывод.
Какой, кстати, будет вывод у этого кода?
Очевидный.
Ну давай очевидный, проговори его.
Hello, got value, world, finished.
Got value, 8, да, и finished.
Абсолютно такая простая штука.
Интересно, как же у нас работает yield все-таки?
Работать yield будет у нас таким образом.
Это же из себя представляет какую-то state-машину.
У нас в Rust есть прекрасные enum, которые могут показывать state текущей вычислений.
Давайте у нас до того, как мы запустили хотя бы раз наш генератор,
у нас будет какой-то enter, например, значению enum.
Потом yield, потом, в общем, что вышли?
Значение enum.
Ну и, соответственно, при создании мы просто enter с нужным числом создаем.
Вот такая вот closure, которая на самом деле себя представляет enum.
С имплементированным trait-ом генератор.
Вот как он, кстати, имплементируется.
Примерно вот так.
Вот у нас резюм.
Мы смотрим на то, какое у нас текущее состояние.
Мы сейчас поговорим, что там внутри написано.
Причем, если мы уже закончили нашу итерацию, то запаникуем.
Ну и вот так вот примерно выглядят стейты.
Переходы между стейтами.
Посмотрите на них, понятно ли все.
Ну вроде несложно.
Эту всю штуку генерирует за нас компилятор на самом деле.
То есть мы написали, конечно, руками, для примера.
Но вот эту штуку будет генерирует за нас компилятор
и бить функцию нашего начальства каким-то образом.
И запускать.
Ну и вот так вот.
Теперь мы приходим к самой важной главе, наверное, нашей лекции.
Которая займет примерно половину лекции.
Это пи-нинг.
Это очень сложная штука.
Но, тем не менее, надеюсь, мы с ней разберемся.
Давайте посмотрим вот на такой примерчик.
В нем есть проблема.
Видите ли вы эту проблему?
В ней есть проблема.
В ней есть проблема.
В ней есть проблема.
В нем есть проблема.
Видите ли вы эту проблему?
Ну давайте тогда я вам подскажу, наверное.
Ну да, действительно, тут есть проблемы со ссылочкой.
Но ты неправильно сказал, в чем проблема.
С этой ссылочкой.
Ну да, тут проблема, конечно, в ссылочке.
Если вы попробуете это обессахарить,
то вы заметите то, что это структура,
которая сама на себя ссылается.
У вас внутри будет строчка, и вы будете на нее ссылаться внутри.
Вы уже, наверное, пробовали вот такой вот код,
как минимум, в ReepGzip'е, например, сделать где-то.
Сделать какую-то ссылочку на объект,
который у вас внутри находится, текущая структура.
Такое небезопасно.
Потому что если вы будете моивать объект,
то тогда эта ссылка инвалидируется внутри.
Поэтому у вас нет такого понятия, например,
как lifetime self.
Иначе мы могли бы писать такие штуки
и получать undefinedBehaviourForFree.
Окей. Ну ладно.
Есть проблема с ссылочкой.
Давайте попробуем зафигачить сюда указатель.
Проблемы, конечно, уже никуда не ушли.
Проблема, она уехала в runtime.
Да, она уехала в runtime из CompileTime.
И получается, что компилятор нам бы
генерировал какой-то некорректный код.
Он будет разминовать этот указатель.
Этот указатель не факт, что верен.
Нам нужно дать какие-то гарантии.
Нам нужно как-то убедиться в том,
что пользователь не мувал структурку.
Такую структурку нельзя мувать.
Вот это конкретный пример.
То, как это можно сломать.
Делаем такую вот штуку.
Например, делаем резюм,
потом муваем наш генератор
и еще раз делаем резюм.
Вот у нас произошел мем-копия,
у нас уже другой адрес,
а вот у нас findBehaviour в коде.
Поэтому на самом деле тот генератор,
который я вам показал, он потому и упрощенный,
потому что он не поддерживает никаких
self-referential структурок.
То есть не всякую функцию он может
превратить в генератор.
Ну что ж, нам нужно придумать
какой-то способ как это решить в языке.
Во-первых, мы можем попробовать
создать бокс с нашей структуркой.
Бокс – это аллокация на хиппи.
Если аллокация на хиппи,
но муваем бокс, казалось бы, все хорошо.
Есть ли в этом
проблема какая-то?
Так, на аллокации конечно проблема,
а есть ли еще какая-нибудь проблема
в таком решении?
Я подскажу STDmem.
Подумайте, что STDmem есть.
Так, что с ним можно сделать?
Ну можно на самом деле
любую из функций, которые ты сказал,
просто заиспользовать.
Ну swap – это самое простое.
И просто то,
на что указывает бокс, свопнуть.
И соответственно у вас получится,
что инвалидируется то,
что вы забрали из бокса.
Ну смотри, давай я
такой примерчик покажу.
У нас есть такая
self-referential структурка.
Мы делаем бокс на нее.
Потом мы, ну тут
еще две строчки, мы просто
инициализируем это каким-то указателем.
А после этого, смотри, я могу сделать
STDmem.replace.
Я делаю STDmem.replace,
у меня в этот момент то, что
hip-value, там уже некорректный указатель.
Ну точнее, не где hip-value,
а где stack-value,
там уже некорректный указатель.
Stack-value сейчас находится
self-referential с указателем, который показывает
куда-то на hip.
Ну проблема в том,
что у тебя инвалидировался указатель
тем, что ты сделал STDmem.replace.
Ты ему внул структурку,
она опять сломалась.
У нас в Replace у него в итоге
его дженерик параметра
выводится как
как self-referential.
Ну смотри, hip-value, когда-то, ну да-да,
вот эта вот, эта мюта, ссылка
на self-referential на hip.
Ты уменяешь с каким-то, ну,
каким-то просто, которым ты сделал.
Теперь тебе на stack-value
какой-то self-referential.
Внутри какой указатель содержится?
Тот же указатель, который на hip.
То есть он указывает не сам на себя,
а на стеке, а где-то на hip,
в другую сторону. То есть не то, что мы ожидаем.
Да, а именно
это find.
А именно в это место мы записали
новый self-referential.
Ну в старое место написали
новый self-referential, и
в текущем нашем месте написан
на стеке
какой-то уже старый инвалидированный
self-referential. Он должен был указывать
сам на себя, а теперь уже не указывает.
То есть проблема в том, что
мы разломали структурку,
ну, self-referential структурку
тем, что мы ее move-нули.
Не, сейчас погоди.
То есть что получается?
Не, формально
это указатель все еще валиден,
потому что он указывает не на саму себя,
а на какую-то другую структурку.
Ну, ты же наверное понимаешь,
что я могу написать какой-нибудь очень
страшный код, который
в итоге сделает так, что я пройду
к некорректному указателю.
Ну это указывает.
Мне хочется, чтобы указатель был корректен,
но указывал куда-то внутрь себя.
А он не указывает.
Вот вариант наш разломался.
Мы не хотим, чтобы так ломался,
мы хотим дать какие-то гарантии
по поводу self-referential нашей структурки,
чтобы пользователь не мог ее просто так разломать.
Мы можем
пойти по какому-то плюсовому пути.
В плюсах можно, например, CD-move
запретить.
Вот разве вы думали
ввести такой вот move-trade,
но, как говорят
люди, которые с ним поработали,
то, что он просто загрязняет весь код
вокруг себя. То есть он появляется
даже там, где он абсолютно никому не нужен.
Там появляется
в ненужных местах, например, вопросик
move, где вам не обязательно,
чтобы структура была movable,
но вам почему-то об этом нужно думать.
И получается, что у вас
такой,
как говорится, super normal trade.
Это уже
такое понятие Растова.
Вопрос сайза, вопрос move.
Ну, сайз-то это нормальная штука.
Ну, ты бы не захотел писать
move везде подряд.
А здесь его придется
писать, он просто
будет появляться везде.
У нас в Расте
мы не хотим, чтобы у нас был такой код.
Раст еще
хочет к тому же, чтобы у нас все структуры
mov-ались. Мы просто были как
meme-копии и все mov-алось. Поэтому у нас
такого понятия в Расте как
movable-types нет
вообще.
И Раст считает,
что move это всегда безопасно и хорошо.
Что же тогда сделать?
Как-то несложно догадаться,
скорее всего, нам нужно сейчас
затребовать какой-то контракт с пользователем.
Нужно договориться с ним,
что он что-то сейчас
не будет делать, конкретно не будет делать move.
И вот здесь такое вот решение приходит.
У нас появляется структурка
pin и trade on pin.
Смотрите, конкретно в данном случае
я написал, что self у меня теперь
это pin на mute self.
Заметьте, mute self это какой-то
указатель, точнее
это ссылка на self.
Мы запинили ссылку
на себя.
То есть когда вы пишете
pin mute self это означает,
что вы запинили
адрес памяти, на котором вы находитесь сейчас.
Ну и текущий
вид
нашего трейда говорит так.
Если вы будете читать,
для того чтобы зарезюмить
ваш генератор,
вам нужно пообещать, что вы никогда
не будете больше mute self.
То есть это
примерно так должно считаться.
Итак, давайте мы
чуть-чуть конкретнее поймем, что такое
pin. Пока что не очень понятно.
Не со стороны...
Вообще да.
Частично.
С pin есть еще проблема,
что он появился, он нужен
в основном для асинхронности, появился гораздо
позже, чем был Rast 1.0.
Поэтому
pin, он немножечко выглядит вычурно
в языке. В принципе нормально,
потому что он редко нужен, очень
редко, когда пишете низкоуровневый
асинхронный код преимущественно.
Или вот, например, если вы захотите написать
всякие двусвязанные интрузивные списки
в сейв коде, то скорее всего тоже захотите
pin сделать.
В общем,
это такой немножечко костыль для того,
чтобы какой-то контракт с пользователем
объявить.
И в общем-то, как этот контракт выглядит.
Когда вы создаете pin,
вот вы создаете pin на какой-то
ссылке.
Это вам говорит, что
в момент создания pin
вы гарантируете, я никогда
не буду больше после этого момента
move-ать эту структурку.
А pin...
параметром pin может быть только ссылка.
Ссылка,
указатель,
box может быть тоже, будем говорить.
В общем, любой тип, который
имплементирует дерево.
То есть, вы хотите запинить адрес
вот в этом идее, и поэтому
вот так вот это примерно работает.
Unpin означает,
то есть, если ваш тип
имплементирует unpin, это означает,
что ему, он не self-referential,
не по барабану, что вы будете мне
пинить, что он пинит, вы можете мне move-ать
только захотите.
Поэтому это и авто-трейд,
потому что примерно любая структурка
у вас в Rust, она имплементирует unpin.
Сейчас посмотрим на это.
Для того, чтобы сделать это
не pin, в будущем
в Rust появится
негатив трейдс, вы сможете написать
импл not unpin for структура,
но сейчас пока что нужно в структурку добавить
phantom pinned, примерно как
phantom...
Что сейчас?
Да.
А вот phantom pinned
тоже как-то хитит компилятор,
чтобы он не...
Нет, это просто тип, который не имплементирует pin,
ну такой, zero-size тип, который не имплементирует pin,
а... А это сделано,
через компилятор это сделано?
Таким средствами языка
в данный момент не выражается? Выражается.
Ну вот здесь есть авто,
как я говорил, авто пока что
для пользовательских типов не работает,
скоро он должен появиться,
но пока что его не для пользовательских типов,
он есть только для всяких компиляторных.
Ну и работает в том случае, если у вас все
объекты в структурке,
все типы, они тоже что-то имплементируют.
То есть unpin будет
ваша структурка автоматически в том случае,
если у вас все unpin в структуре.
Я бы... Как там
файлы в стандартной биотеке?
Что phantom pinned не unpin?
Там написано, скорее всего, что это
langitem и все.
И там появляются автоматические свойства.
Ну вот на этом, да,
вот phantom pinned пока что
хинтенк компилятора, но потом появится
нагдефтрейтс, можно просто написать, что
я имплементирую на тампин и все.
Вот мы что-то здесь сиделись на этом.
Вот.
Смотрите, первая важная структурка, о которой
мы хотим поговорить, это new.
Она создает новый pin
вокруг какого-то указателя.
Ну, ссылки, указатели.
Вот.
Ну, вот примерно
так вот он выглядит.
Обратите, пожалуйста, внимание, здесь
target, к которому мы dereferимся,
это unpin, обязательно.
Это очень важно.
Потому что new — это save
функция. А как я сказал,
если вы запинили какой-то объект,
то в таком случае вы
говорите, у вас контракт
появляется, что вы никогда
этот объект не будете move.
Но в том случае, если объект имплементирует
ampin,
то ему становится без разницы с когда и как
вы move'ите, хоть пиньте, хоть ampinьте
этот объект, ему без разницы.
И поэтому функция new безопасна.
Потому что можно безопасно
запинить объект и потом точно также его
заanpin'ить. Сейчас дальше еще
посмотрим. Там есть его unsaved
вариант.
Вот. Например, U32 —
ampin. Ну, по понятной причине, это просто
какое-то чиселка.
Вот. И ему без разницы
абсолютно, что вы его как-то move'ите.
В том числе, вот, видите, я сделал
replace
и не value
не сломал, ничего не сломал.
Value у меня сейчас написано будет троечка,
и так как у нас U32 — это не
у нас referential структурка, у нас ничего не сломается.
Какие-то такие дела.
А как вы думаете,
box.t имплементирует ampin?
Нет, на самом деле
оно вполне безопасно.
Причем для любого t вообще.
Даже если это t не имплементирует ampin.
Ну, в общем,
я думаю, что
у нас есть
один вариант.
Вот.
Вот.
Вот.
Вот.
Вот.
То, что там находится,
оно находится на хипе.
Соответственно,
мы можем безопасно box
запинить,
а потом заampinить.
То есть,
ну, мы дали обещание,
что мы не будем move'ать то,
что находится за t,
и мы, соответственно, это не move'аем,
как и обещали.
Потому что оно находится на хипе.
Это, кстати, очень важная вещь,
когда мы будем говорить
еще дальше про
асинхронную страсть.
Потому что box
достаточно часто используется для того,
чтобы поместить какой-то объект,
который pin на хипу.
В таком случае
вы делаете, конечно,
локацию, но тем не менее у вас
объект никуда не двигается.
Соответственно, у вас все безопасно.
В том числе есть у box
другая штука, которая называется
есть box.new, например, а есть box.pin.
Она делает то же самое,
но возвращает не просто box на объект,
она возвращает pin на box на объект.
В любом случае в том,
что box.ampin, поэтому им без разницы.
Это безопасная функция,
которая делает pin.box, а не просто box.
Такая штука.
Более того,
если у нас то,
на что указывает наш p
в таком случае
мы еще и dref.mute получим
бесплатно.
Это была очень важная вещь,
надо было сказать это еще в прошлом слайде.
То, что ты вспоминал,
ты правильно вспоминал про
реплейс, например.
Но ты не сможешь сделать реплейс
в тот момент, когда у тебя нет dref.mute.
То есть ты не сможешь
получить просто мутабельный указатель.
Ты сможешь просто почитать что-то.
Поэтому когда у тебя
объект, на который
у тебя pin есть,
не имплементирует,
то в таком случае
тогда и только тогда мы будем dref.mute
имплементировать.
И вопрос такой,
на который я уже частично ответил.
Представьте, что мы все-таки имплементируем.
Почему же это будет невезопасно?
Ну, видимо, Данбик,
ты как его реплейсишь?
Да, просто
делаем какой-то реплейс.
Но, смотрите, self-referential.
Я зафигачил phantom pin,
то оно unpin.
Ну, действительно, unpin же структура
self-referential.
Если мы ее запинили, мы больше не можем
ее умывать.
Мы пообещали, что я умывать не буду.
Но если мы ее запинили,
мы больше не можем ее умывать.
Мы пообещали, что я умывать не буду.
Надо обратить внимание, что я
default какой-то сделал,
неважно, что делает default,
возвращает какую-то структуру.
Здесь у меня есть фул какой-то,
который принимает на вход
pin self-referential.
Я просто делаю
реплейс.
И получается, что я разломал
все наши гарантии.
Я поломал то, что находилось
за pin.
В первую очередь даже не то,
что находилось за pin,
а то, что я получил из std-memo,
оно некорректно.
Теперь
все становится еще более
интересно. Появляется функция
unchecked.
Не unchecked она делает pin для
любого объекта, даже если он un-pin.
Не un-pin.
И вот ее особенность в том,
что если до этого
она была, ну new ее вариант,
вариант new pin
был безопасен,
потому что мы имплеметировали
un-pin, и это было нормально вполне, pin-ить и un-pin-ить.
У нас структурки было без разницы.
Да, unsafe, потому что у нас
контракт.
Да, мы сделали этот pin,
и соответственно у нас контракт, что мы не будем
мувать этот pin, то, что за pin.
Поэтому мы явным образом писали
unsafe. Здесь вот пользователь,
ты должен проследить за тем,
что ты дальше не будешь мувать эту структурку
после того, как ты создал pin.
Ну вот, смотрите.
На этот раз я создаю pin unchecked,
например.
Точно так же там инициализирую что-то.
Ну и обратите внимание,
что вот это на этот раз не будет
компилироваться, потому что у нас
не будет имплементирован direct-mute.
Мы не сможем просто
из hit-value на этот раз получить
просто так мутабельную ссылку,
иначе мы могли сразу же разломать
наше сейфти. Могли бы просто
написать memory-place,
вот как я это сделал, и тогда бы у нас просто
поломал все наше сейфти.
А так,
если вы захотите все-таки сделать
такой replace, то вам нужно будет написать еще
одну unsafe-функцию, в которой, соответственно,
будет контракт, что вы
не ломайте никаких
указателей на себя внутри.
До этого мы сейчас дойдем.
Вот, ну это как раз
упражнение. Да, как раз
вопрос, на который мы ответили.
Какой контракт? Ну контракт, что мы
если создаем pin, то в таком случае
мы никогда ни в каком случае не будем ломать
нашу
не сломаем нашу структурку.
Мы никогда не будем двигать то,
что находится за ссылкой.
Если мы разломаем
это, разломаем наше обещание,
не выполним это обещание, то в таком случае мы
очень легко можем получить антенсейфти.
Ну вот, смотрите.
Давайте посмотрим на наш пример с генератором.
Ну, насколько вы должны помнить, у нас
генераторе теперь не просто muteSelf, а
pin от muteSelf.
И обратить внимание,
этот код, конечно, компилируется.
Но мы написали дважды unsafe.
И более того, мы, когда
сделали move снизу, мы нарушили наш контракт,
который мы написали сверху.
Вот здесь вот. То есть в первой строчке,
когда мы пишем unsafe,
мы делаем pin,
обещаем, что мы не будем ничего
ломать, и после этого все ломаем.
И соответственно, следующий unsafe
там будет резюм на генераторе,
который разломан.
Там будет ссылочка куда-то,
которая находится в другом месте на стеке.
Получается, таким образом мы явно указали
какой-то контракт и возложили
на пользователя обязанности ему следовать.
Ну, в общем-то,
я думаю, что это правильно
более чем какой-нибудь straight move,
потому что все-таки эти структурки редко возникают,
pin.
И поэтому очень, наверное, правильно
все-таки приложить на пользователя
то, чтобы он
занимался
тем, чтобы
корректное состояние поддерживал
своей
self-referential структурке.
Ну, есть еще две важные функции.
GetMute и GetUncheckedMute.
Ну, как вы можете заметить,
GetMute безопасен,
но он требует onPin типа.
Если мы без разницы, ну, выдаем GetMute
и там хоть Replace,
хоть что меняете, без разницы.
Ну, здесь понятно,
почему GetMute реализован
для onPin.
Да, так, и
GetUncheckedMute.
Ну, вот если вы onPin не имплементируете,
то в таком случае, если вы возьмете
ссылку на объект, который находится
за pin, то в таком случае вы бы
могли все разломать, поэтому
сейф функция и контракт у нее,
что вы, получив эту ссылочку,
не разломайте ничего внутри.
Вот. Ну, когда вы
как раз-то же сказал,
когда вы используете GetUncheckedMute, вы должны
пообещать, что вы не будете ломать никакие
self-references,
то есть ссылки указательные на себе.
Ну, и более того,
тут есть некоторая сложность
в том, что
DREF нашего указателя,
который мы будем использовать, и DREFMute
не должны
в общем, ломать нам self.
Насколько вы помните, у нас
trait.dref и dref.mute это какие-то произвольные
штуки, о которых пишутся пользователи.
А внутри бы мы могли написать в таком случае
просто из TD Replace какой-нибудь, да?
Ну, по-моему, у меня дальше должен быть примерчик.
Да. Ну, вот, смотрите.
Есть какой-то evil pointer,
который принимает на ход наш self-referential
турку,
и мы сделали, ну, DREF работает как надо,
а вот DREFMute у нас
такой негодяй внутри делает Replace.
И все ломает.
Ну, и тем самым получается,
что когда мы пишем
вот этот вот unsave,
мы не выполняем наш контракт, что у нас
корректная имплементация
от DREFMute,
которая нам
MemReplace,
ну, в общем, MemReplace нам
ломает этот контракт внутри.
Смотри, просто когда ты будешь делать...
Ну, смотри, когда ты просто создаешь PIN,
здесь проблем не будет.
Просто создаешь... Ну, вот если ты дальше там будешь
делать что-нибудь по Mute указать,
просто сделаешь getUncheckedMute,
то в таком случае
у тебя же для того, чтобы получить
эту Mute ссылочку, тебе нужно сделать DREFMute.
Все, у тебя здесь разломалась,
ты разломал структуру.
Поэтому ты должен дать гарантию насчет своей имплементации.
Ну, есть еще
последнее место, где мы можем что-то разломать.
Это drop.
Drop это, как обычно, такая штука, которая
что-то может в последний момент
испортить.
Ну, вот когда у нас
drop вызывается, он получает
mutable ссылочку на self, насколько вы
помните. Но дело в том, что
он вызывается даже тогда, когда у вас
тип был запинан до этого.
А это означает то, что
внутри dropа может
какой-то некорректный код сидеть,
который вам что-то разломает.
Ну, вот опять же, я зафигачил здесь memReplace
и вот у меня drop,
который нарушит
контракт PIN-а.
Явно.
Стоп.
Ну,
по-моему,
когда у нас drop происходит,
то, скорее всего, PIN умирает
вместе со самой ссылкой с самим объектом.
Там нужно просто найти такой момент.
Дело в том, что drop...
После dropа ты, на самом деле, сразу же диалогацию
не делаешь. Ты сначала drop
и делаешь у всех объектов,
у самой структурки, у всех
ее полей,
а потом уже ты вызываешь диалогацию.
И вот тут у тебя может быть такое,
что у тебя drop в структурке,
что-то соседнее, например,
будет полагаться на то, что у тебя
корректная структура внутри.
То есть там будет внутри
где-нибудь PIN у тебя внутри своей структурки
на эту ерунду,
и drop у тебя будет некорректный,
и в итоге какой-то
сосед у тебя обратится
в некорректную структурку.
Сейчас, ну да, если мы drop'ем
этот объект, то это действительно может нам все разломать.
Просто если у нас
такой dropающийся объект
это complete object, то кажется,
ничего страшного уже не будет.
Ну,
здесь можно легко напортачить.
Если его сцинкер скидать,
то, скорее всего, все должно вернуться,
поэтому проще попросить, чтобы drop
никого не ломал.
Тут есть, кстати, предложение такое,
только предлагает решить раз.
Здесь это я должен признать, опять же.
Опять же, PIN появился значительно позже,
чем
появилась синхронность,
точнее, чем стабилизировался raster,
соответственно, drop.
И получается, что в drop'е
было бы хорошо принимать PIN на mute self.
То есть было бы максимально правильно,
здесь это WFM drop, вместо mute self
принимать PIN mute self.
Это было бы правильно и корректно.
Но так как PINов те времена не было,
нам
у нас есть то, что есть.
И теперь, если у вас структурка
где-нибудь использует PIN,
то в таком случае вам нужно подумать,
а может мой drop что-то может разломать
и написать такой код.
Явно запинить вот здесь тот объект,
который мы вам передали.
И дальше писать код, исходя из того,
что вам выдали PIN.
Но это просто для того,
чтобы как-то самому себе отметить,
вот я вот здесь должен соблюдать
этот контракт.
То есть чтобы не писать код,
который не исстреляет в ноги,
нам надо взять unsaved.
Не приятно.
Смотри, ты же unsaved может
где-то внешне заюзать,
вне dropа.
И вот если ты не можешь его заюзать,
ну там допустим у тебя объект self
unpin, то в таком случае тебя об этом
беспокойте не надо.
А если он not unpin, то в таком случае
для тебя это уже очень важно.
Особенно тогда, когда ты начинаешь уже
посоветствовать где-то PIN.
В таком случае тебе нужно об этом думать.
Да, да.
Поэтому вот это вот просто
для того, чтобы явно
себе обозначить контракт
свой же в дропе.
По факту можете это не делать,
а просто так учитывать, но это не очень
красиво как-то будет.
Это идея прикольная.
Ну вот да, я как раз
только написал, что на самом деле
в идеальном мире мы бы хотели, чтобы drop
принимал PIN на mute self, но к сожалению
уже слишком поздно.
Возможно кто-нибудь сделает 1.2.0, и там будет
сразу же PIN mute self на drop.
Пока что то, что есть.
Ну не знаю.
Плюс ко всему ты все-таки drop пишешь
очень редко для PIN типов.
Ну вообще сами по себе
PIN типы редкие, тем более редкие
dropы на PIN типы.
Поэтому
получается такая ерунда,
что тебе просто
наверное не хочется даже это, возможно, язык
добавлять, потому что придется слишком
сложно пользователям, которые вообще
ничего не знают, им придется про это знать
и что-то учить.
Ну смотрите, на восьмой лекции узнал.
Ты узнал на восьмой лекции про это.
Проблема.
Так.
Хорошо.
Есть еще одна такая штука.
Задумались ли вы, пока сидели на лекции,
почему он PIN вообще безопасно
для имплементации? У нас был например
send и sync, которые были unsaved для имплементации.
Которым нужно было что-то гарантировать.
А почему он PIN безопасно
имплементировать?
Причем всегда.
Он же может нам что-то
похерить в коде вокруг.
Более того,
здесь есть такой
код, на который вы можете посмотреть.
Здесь я
сделал какую-то структурку readyT,
в которую у меня внутри value есть.
Ну и все, что я делаю в генераторе,
это просто говорю, ну, я закончил
итерацию, вот,
take значение и возвращаю
его.
Почему это безопасно?
Я же что-то умываю внутри.
При том, что я пообещал, что ничего умывать не буду
здесь вот в PIN.
Ну, так это вроде
как бы сам
ну, запиненный объект,
ты опшен по нему не умываешь,
ты умываешь только какой-то содержимое
опшен.
Ну, как бы совсем, ну, через несколько слоев
пролезаем, чтобы что-то умудрить, и кажется,
что это не очень страшно.
Если ты все предпочел, то конечно уже
веселее начинается.
Ну, вот, хорошо, смотри.
Короткий ответ, потому что
у нас мы не давали
никаких гарантий насчет T.
Мы и запинили self, но мы не пинили
никакого T. Мы же не гарантировали, что
T мы не будем умывать.
Все, все хорошо.
Весь этот
код безопасен.
И с ним все хорошо.
Он же никогда не сломается, он максимум
запаникует, если вы дважды резюм сделаете
на ready, и внутри значения
не будет.
Ну, он же безопасен абсолютно.
Ну, в общем,
PIN имеет значение только тогда,
когда его вы создаете.
То есть вы когда создаете структуру с PIN,
то вы даете обещание,
и вот только тогда уже PIN начинает иметь значение.
До этого момента на PIN
вам все равно.
А что насчет такого вот кода?
Теперь у нас в readyT
внутри сидит генератор.
T это генератор.
И здесь внутри у меня unsaved
код. То есть я делаю unsaved
PIN для того, чтобы вызвать резюм
на своем value, который
сидит внутри.
Ну, смотрите,
на этот раз я уже дал какое-то обещание.
Написал unsaved, написал PIN,
new, unchecked. Я дал только что
обещание, и я не буду этому быть.
Вот это вот обещание,
оно некорректное,
потому что у меня
Myself это onPIN.
Ну,
вот это вот обещание,
оно некорректное,
потому что у меня
это onPIN.
Ну, если он onPIN,
то в таком случае, что он не мешает
помыть sel, да.
И все разломалось.
Если он onPIN, то в таком случае
вот это вот не имеет никакого значения.
Оказывается.
И этот код,
если бы вот это onPIN не было,
тогда мы могли его сделать
вот так вот, потому что я пообещал,
что я не буду этому быть. Этот код был
некорректен, потому что
я бы moval объект, который
внутри запиненного находится, и все
было бы хорошо.
А вот если бы я,
ну, когда я написал onPIN,
то в таком случае мне ничего не мешает
помыть текущий объект, ну, то есть запинить, заонпинить его,
то есть это никакого значения опять же
теперь не имеет.
И вот этот вот unsafe, он некорректен.
Абсолютно.
То есть pin new, unchecked, ну, просто не в состоянии
помыть это обещание, на самом деле.
То есть по-хорошему нам бы
законстроение, что new unchecked только для тех,
кто не реализует onPIN?
Нет, это что-то уже
сверху, понимаешь, получается.
То есть ты начинаешь что-то родителям
говорить, ну, что-то не очень.
Ну, слушай, почему бы не сказать, что мы не можем
делать new unchecked для тех, кто...
Что-то мне подсказывает, потому что
есть очень много примеров, когда и можно,
и нельзя, поэтому...
А вдруг вот этот вот те, который...
А, нет, тогда бы нам unsafe здесь не понадобился,
если бы внутри был pin.
Ну, короче, мне кажется, что
такое невозможно, потому что
просто код легко придумать, в котором...
Должно быть легко придумать, в котором
это принесет
проблемы, а не
удобства.
Поэтому onPIN сам по себе здесь
был безопасен, а вот этот вот unsafe
просто не выполнил контракт,
когда мы его написали.
Вот, и мы не знаем,
имплементируют ли те onPIN.
Если бы мы написали, что те onPIN, то в таком случае
действительно мы создали pin.
Более того, он бы был safe, там pin new,
и все было бы хорошо. А так получается,
что просто можем
умолвить наш текущий объект.
Соответственно, у нас имплементация
onPIN, она абсолютно безопасна,
но она может резонировать с тем кодом,
который находится вокруг.
Ведь это вот пример нелокальности
unsafe.
В прошлой лекции я вам не показывал таких примеров,
но это вот такой пример,
когда вы пишете unsafe в одном месте,
а стреляет он из-за кода
совершенно в другом месте.
То есть, писать unsafe очень сложно.
Когда вы пишете unsafe, то вы должны гарантировать
в любой момент времени, что у вас что-то вокруг
хорошо, что вы выполняете
какие-то контракты, которые вам сказал unsafe.
Иначе может быть такое, что вы
написали, например, точно так же
для генератора такой вот код,
потом в какой-то момент пришел другой человек,
написал onPIN, вы это не заметили,
у вас ралмонался unsafe внутри.
Потому что он перестал
выполняться контракт какой-то.
Давайте перейдем еще одной функцией.
Называется map unchecked new.
Это такая функция, которая нам
позволяет запустить какой-то клоуже,
внутри которой нам будет доступно
мьют, ссылочка на T.
Возвращается на будет PIN
на какой-то другой тип.
Вот это вот map.
В общем, map это наш
текущий тип в какой-то другой.
И внутри клоуже нам доступна
мьют, ссылочка на текущий тип.
Внутри мы, естественно, должны гарантировать,
что в map unchecked
мы не ломаем никаких инвариантов.
Мы там делаем
replace, например.
И когда это бывает полезно?
Например, тогда, когда вы хотите
получить доступ
к какому-то полю
исходной структурки.
Давайте посмотрим какой-нибудь пример.
Смотрите, у меня есть мой
generator,
внутри которого сидит какой-то другой генератор.
Гай-генератор,
и я пишу какой-то
map unchecked mute для того,
чтобы вызвать резюм.
Безопасен ли этот код?
Ну как будто бы никто нигде не умывается
вот с этим часом генератор
и вот-вот генератор.
Ну да, здесь получается,
что действительно
безопасный код.
А вот здесь
ну, если бы мы не делали
как-то такой
субботик,
то бы он не он не был
в текущей структуре.
А если бы мы не делали
как-то такой
Действительно безопасный код
MyGenerator вот мы дали по поводу
генератора какой-то promise
что он не мувается
и потом внутри мы на него полагаемся
вот здесь вот
ну раз что он не двигается, значит что поля не двигаются
все хорошо
делаем unsave, который коллекцион
достает нам pin на mute this j
ну и резюмим генератор
вот, ну здесь конкретная причина
во-первых нам юзер пообещал
что он не будет мувать селфи
и мы внутри map unchecked mute
этот promise выполняем
мы внутри не делаем никаких replace
ну и более того
мы пообещали не мувать this j
ну мы же создали pin
соответственно мы должны ответить за этот pin
соответственно мы не двигаем
то что находится за pin
как и обещали
вот, обратите внимание
что
вот сейчас
мы это смогли сделать
только потому что нам юзер дал
pin на mute self
если бы он не смог
ну не было здесь вот этот pin mute self
то в том случае этот код не был бы коррекцией
да
мы бы тогда не смогли просто выполнить наш контракт
который мы
гарантировали что выполняется
а теперь
давайте чуть-чуть поменяем
примерчик
здесь
безопасен ли этот код
похоже кстати на прошлый пример
поздно
ну да
этот код небезопасен
потому что у нас
он pin соответственно
на этот pin полагаться не можем
потому что юзер у нас может дальше
он pin безопасно
и замувать
соответственно наш unsaved
внутри опять же не коллекцион
и
и
и
и
и
ok давайте перейдем
дальше
примерно чуть-чуть интереснее
а теперь давай
вот этот код я сказал
небезопасен
на этот раз мы убрали
pin раз уж он некорректен
и пробуем добавить
такой код импл
generate уже
и выдаем mute self
просто ссылочку где-то внутри
Теперь генератор умеет давать мью целочку на генератор внутри.
Будет ли в таком случае вот этот вот код безопасен?
При условии, что у вас рядом стоит вот такой вот.
Просто умеете мьюджи брать.
По-моему, да.
Потому что мы вроде как...
Ну, внешний жамбург нигде не убиваем.
Вот.
Но внутренний жамбург, пока никаких требований на код.
Ну, в общем-то, в общем-то, в общем-то, в общем-то, в общем-то, в общем-то, в общем-то, в общем-то, в общем-то, в общем-то, в общем-то, в общем-то, в общем-то, в общем-то.
Ну, а внутренний жамбург, пока никаких требований на код.
На самом деле, у тебя есть ансаунд-код.
И на этот раз уже неправ.
Смотри, а что мне мешало, например, написать вот так.
Здесь, конечно, pin нужно учесть, что он берется по селфу.
Соответственно, он будет муваться.
Здесь вот уже гений будет существовать после g-резюм.
Смотрите, вот сделал g-резюм.
Соответственно, после этого я делаю какой-то Memoreplace.
У меня ломаются ссылки.
Потому что, ну, смотрите, я просто получил мотабельную ссылочку безопасным образом.
И потом он адапт-женерейтер запихнул какой-то.
И опять написал резюм.
У меня опять все разломалось.
Тем, что ты не выполнил контракт пина.
Ты пообещал, что ты не будешь вот это вот мувать.
Ну, хорошо, здесь все хорошо.
А потом ты делаешь replace внутри.
Ты делаешь внутри replace, и все разломалось.
И вот этот вот unsafe, который внутри там находится резюм, он уже некорректен.
Что-то, блин, я уже не умываю, что здесь происходит.
Ну, здесь вот replace.
Ну, внутреннюю жежку можно ли?
Ну, раз мы договорились, что не имеем права мувать ее.
Мы как бы внешне же не муваем, а внутренне.
Ну, в этом смысле ты прав.
Ты можешь мувать внутреннюю жежку.
Но вот этот вот unsafe код, который ты написал внутри резюм здесь, уже некорректный.
Потому что ты пообещал, что ты запинил self.
А теперь ты во второй раз вызовешься на другом генераторе.
Все, соответственно, ты его мувнул.
Ну, ты его мувнул, засунул какой-то другой генератор.
А, внутренний пин сломался. Все, понял.
То есть внешний пин все еще нормально, а внутренний уже не.
Ну, точнее внешний коррекцион, вот этот внутренний, который мы здесь делаем,
он уже не выполняет наши варианты.
То есть из-за того, что мы добавили вот эту вот возможность получить ньют ссылочку.
Нос-н-саунд абстракция. Все.
То есть очень такая сложная штука пин здесь.
Она стреляет в самые разные способы.
То, о чем мы только что говорили, называется structural pin.
То есть мы получили из нашей структурки какое-то поле,
пин на какое-то наше внутреннее поле.
Иногда это бывает нужно.
Ну, и, соответственно, если наше поле зависит от пина нашей структуры в целом,
то мы structural по нашему полю.
Вот так вот. Ну, точнее пиннинг и наш structural по field.
Вот так вот.
Самое главное, что вам стоит запомнить,
что вам больше часть времени все-таки не хочется ничего пинить.
То есть, в том числе, у нас был Get Unchecked PIN до этого функции.
Постарайтесь в большую часть времени никогда не создавать пина.
Если вы создаете PIN, то вы даете какую-то гарантию,
ее приходится выполнять.
Соответственно, код вокруг можно случайно как-то сломать,
если вы PIN создаете.
А если вы не даете никаких обещаний, ну все хорошо.
Поэтому лучше получать при возможности просто ньют ссылку.
Это может быть не очевидно.
Ну, типа лучше ждать более сильной гарантии.
Но, оказывается, мы тогда даем какое-то обещание.
Обещание мы не хотим просто так выполнить.
Мы хотим, чтобы обещаний давали меньше.
Вот.
Ну, поговорим про пиннинг.
Так, очень-очень важно понимать, что такое пиннинг.
Можете ли вы повторить просто, что значит создать?
Какой контракт происходит, когда мы создаем PIN, например?
Мы не мываем то, что находится по ссылке,
которое мы передали в PIN.
Ну, янпин соответственно, что значит?
То, что нам по барабану.
На эту гарантию.
А можно еще объяснить, что такое structural pinning?
Structural pinning – это смотри, вот у тебя в этом случае
у тебя внутри структурка есть,
ну, у тебя внутри глобального генератора есть внутри генератор.
И, соответственно, structural pinning – это тогда, когда у тебя есть какое-то поле,
которое зависит от пиннинга исходной структуры.
Вот у тебя как раз вот этот PIN зависит от этого PIN.
Это structural pinning просто называется.
Вот.
Есть какие-нибудь еще вопросы?
Ну, тогда, может, давайте фьючем перейдем.
Будем смотреть пока что только на простую фьючу.
Для того, чтобы сразу же не испугаться,
а то, если я вам выкачу сразу же, как она выглядит,
возможно, вы ничего не поймете.
Вот.
Когда вы смотрите на фьючу, сразу же думаете, что это, наверное,
concurrency, вот это вот фьюч, вот эти вот комбинаторы,
future promise, парочка, shared state – и понеслась.
На самом деле это не так.
Фьюч – это какая-то рутина, которая представляет из себя какое-то вычисление.
Эту рутину можно полить.
Заполить рутину означает попробовать совершить какой-то прогресс.
Ну, там, не знаю, например, try read сделать внутри, да?
Давайте для примера пока что такое простой пример.
Try read внутри пола, который пытается что-то прочитать.
Ну, тут тоже есть какая-то структурка пол,
которая говорит, что либо вычисление готово,
вот, пожалуйста, тебе результат T,
либо что мы продолжаем ждать.
Результаты этого вычисления.
Окей.
Это ведь у нас есть какой-то примерчик с async file read.
Это структурка, у которой есть выдуманный мной файл handle.
Если что, его нигде нет.
Просто такой примерчик чистый.
Вот, и что я делаю в поле – это если у моего файла есть возможность,
ну, если я из своего файла могу что-то прочитать,
окей, я читаю в буфер и возвращаю в буфер.
Все.
Иначе я говорю, ну, мне ничего не получилось прочитать,
пока что файл не готов к чтению opening.
Все.
Все.
Вот такая вот штука, которая пытается совершить какой-то прогресс.
Выглядит пока что просто, да?
Только непонятно какая здесь синхронность получается.
Что-то пытаемся полить.
Ничего непонятно.
Так что вся синхронность при этом на поле нигде пишется?
Ну, это потому что слова одинаковые, думаю,
пока что поэтому так думаешь.
Да, типа епол вспоминаешь.
Ну да, вот ты думаешь просто епол,
но пока что непонятно, где здесь должен быть епол, да?
Ну, такое вопросное.
Да, вот пока что...
Мы пишем этот реактор и полим.
Так, реактор, да.
Ну, скоро дойдем до такого понятия.
Окей.
То, что могли обратить внимание,
это то, что future это инертное.
Инертное такое, инертный объект.
Для того, чтобы они совершали прогресс,
их нужно активно полить.
То есть нужно говорить, соверши прогресс,
соверши прогресс.
Это...
Team Fortress.
Team Fortress, да.
Заставлять ее что-то сделать.
Да.
Во-вторых, вам нужно узнать, что...
Нужно знать, что если вы делаете пол,
после того, как вернулся пол ready,
то в таком случае, раз, он говорит,
что поведение будет безопасное,
но не определенным стандартом.
То есть потому, что это просто определяется тем,
как имплементирует future user.
То есть у вас может...
Ну, самый дефолтный случай,
это запаникует просто программа,
потому что у вас запаялся фьюч.
Просто учитывайте, что если у вас пол ready,
в таком случае фьючу дальше не нужно полить.
Не логично звучит.
Просто что...
Знайте, что это...
Так работает.
Так, вот это вот...
Да, вот третий пункт, вы пока что не поймете,
он, видимо, одна ошибочка закралась.
Сейчас дойдем до AsyncAwait
и поймем, что значит третий пункт.
Я вам его скажу.
Блин, блин, что-то...
Как будто, например, непонятно,
о чем он должен существовать.
Совсем внезапно появляется,
но а так это маленький рандомный факт,
и нормально окринкается.
Что-то хорошо было бы у нас
сфотографировали фьюч и другие прочие программы.
Так, теперь подумайте,
как мы можем имплементировать end-end
на двух фьючах.
На двух?
Да, ну вот есть две фьючи.
Вот я утверждаю, что у меня есть такой интерфейс,
я уже могу какой-то end-end сделать у них.
Значит, вы увидите какие-то упражнения,
отлогуете по этим машинам,
и на всех их числящих множеств
вы напишите вот это.
Вот то, что...
Так, в общем, мы делаем end-end.
Если первое ready,
нарезал так,
если первый сам,
то вообще второй.
Иначе он...
Что-то такое.
Значит, что...
Вообще, что означает, что сначала
на двух фьючах одну исполняем,
потом другую после этого.
Вот это вот менее очевидно.
Подожди, end-end даже у курса Леповского есть.
Пока не понятно, кого мы исполняем,
что он...
Ну вот полить...
Так я же тебе объяснил, смотри.
Пол — это попробовать
совершить прогресс.
Ну, например, там tri-read, как я тебе сказал.
Все, я утверждаю, что тебе достаточно этой информации,
чтобы пробовать сделать end-end.
Окей, что должен end-end понимать
Ну, он пытается сначала исполнить одну фьючу,
потом, когда она исполнилась,
вторую фьючу пытается исполнить.
В принципе, он даже решение только что сказал.
Просто, ну давайте...
С таким интерфейсом,
с таким trait-ом фьюча откроем,
мы не сразу понятны, что хотим этот end-end.
Ну, мне, например, не очевидно,
что это означает полить там порядки,
в котором мы расформили.
Ну, смотрите, просто первая фьюча у нас будет
фьюча A, а вторая — это фьюча B.
Ну, у нас простейшее такое будет end-end.
Он просто будет возвращаться
с успехом
только тогда, когда у него
получилось заполнить обе фьючи.
Ну, в таком случае,
когда нас будут конструировать, мы будем получать
две фьючи на ход.
Соответственно, у нас здесь будет сам фьюча A
и какая-то фьюча B.
Мы то, что будем делать
в поле — это смотреть на
первую фьючу, если она
еще у нас есть, то есть мы еще не закончили
ее исполнять,
то пытаемся ее заполить.
Если ready, то в таком случае
мы take-ом текущую фьючу
и переходим ко второй. Иначе
мы возвращаем пол pending, и когда
нам в следующий раз придут, мы пробуем опять
первую фьючу заполить. То есть
что-то такое достаточно вроде бы простое.
Просто полим первую фьючу, пока она не закончится,
потом мы ее выкидываем, полим вторую.
Вообще тоже будет понятно, что мы требуем вообще
говоря, ну, а вот
вот это было непонятно.
А, ну, output, да. Я, конечно,
про простейший mdent здесь говорил.
Ну непонятно, типа, просто ты не сказал
вот это ограничение, зайду эти патчи.
Ну, окей, да, хорошо. Потом допишу.
Так, ну, утверждается,
что вроде бы вы должны понимать дальше, ну,
как все комбинаторы примерно делают. Ну, если
там все, ну, там типа all, ну, давайте
все по полям, до тех пор, пока они не закончатся.
Ну, first-off поинтересен, конечно.
Ну,
ну, first-off, ну, хорошо,
да. Мы не можем
полить все подряд, а хотя можем
полить все подряд просто.
Напомню, first-off возвращает же ошибку,
либо первую ошибку, либо все результаты.
Ну, может это all.
All подручает вот либо все результаты, либо
первую ошибку, а first-off либо
либо первые результаты, либо
последние ошибки.
Ну, наверное, пытаемся все
заполить.
Да, и просто до тех пор,
пока у нас не появится
результат номер один, либо
ну, то есть префикс у нас должен заполниться
до какого-то результата, либо все ошибки.
И так правильно понять?
Не, ну, я подумал так, что мы ходим по кругу
по future, ну, типа находим какое-то состояние
нашего future, которое мы хотим заполить
в следующий раз. И так просто по кругу,
пока какая-нибудь не закончится.
В общем, вроде понятно, даже нашли здесь комбинаторы
этих наших future,
которых, кстати говоря, еще нет
даже примерно ничего, но мы уже
нашли здесь комбинаты.
Ага, все, сейчас.
Async and wait.
Не, не, сейчас они
пока что нам пригодятся.
Так, хорошо, мы вынимаем
в простых терминах,
что значит
rastovaya future.
Ну, подождите, мы хотим писать
код что-то вроде такого.
Да, вот здесь,
кстати говоря,
наверное, я
сделаю так.
Я просто...
До этого был план другой.
Чуть-чуть.
Но я его поменяю прямо по ходу дела.
Давайте мы посмотрим
на один примерчик.
Вам не видно?
Хорошо, сейчас.
И еще.
Еще, пожалуйста.
Еще.
Так, сейчас.
Ну, вот
примерно так.
Смотрите, давайте мы посмотрим даже
на такой примерчик. Всем знаком
эхо-сервер. Он написан на токе.
Я просто хочу вам показать, как это выглядит.
По идее, это мы должны посмотреть через пару
десятков слайдов, но мы посмотрим сейчас.
Для того, чтобы чуть-чуть
больше проникнуться. Вы же помните
файберное эхо?
У Дюповского.
Ну, вот то-то и оно.
Вообще, токел — это прям планировщик
ГО, файберы как в ГО.
Это ГО.
Вы можете просто взять и в сейф-расте
пользоваться ГОшкой.
Нет файберного эхо?
Да, в результате
переделывания курса, задачи временно
потерялись.
Ну, жалко. Такая хорошая задача, моя любимая.
Ну, она скучная
из одной по точности.
Не знаю, зато она прекрасно
показывает, как все работает.
Давайте посмотрим. Это как раз то,
что вы писали в файберном эхо.
По крайней мере, в прошлом году должны были, да?
Сейчас мы какой-то
нагрузки наблюдаем.
Окей, ну вот у нас
создается какой-то
лисенер, которому мы биндимся.
Делаем эвейт на нем.
Эвейт можно вспомнить
из каких-нибудь
более таких
висковых языков программирования.
Вы знаете какой-нибудь язык
программирования, в котором есть асимка
эвейт? Котлин, например.
Сиша.
Ну и JavaScript
сойдет, в принципе.
Эвейт мы что-то
асинхронно ждем.
Мы ждем, пока у нас что-то забиндется.
Потом мы в цикле accept
асинхронно ждем всех лисенеров.
Здесь Tokyo Spawn это означает
создать какую-то
какой-то файбер,
к которому мы будем вот такие вот штуки делать дальше.
У нас здесь
создается буфер.
Потом мы в цикле читаем асинхронно.
Асинхронно пишем.
Очень просто выйдет код.
И в каждой точке эвейт
на самом деле наш код
начинает асинхронно
ждать, пока он что-то
начинает делать.
В принципе, если вы были на курсе
конкуренции Рома Липовского и писали эхо,
то в таком случае там, по сути,
итоговый эхо сервер, который вы писали,
выглядел абсолютно точно так же.
То есть
за исключением того, что вы писали
на C++, что там эвейт, не было
ничего слова.
Я бы сказал, что да,
он все-таки выглядел не так же,
и он сейчас больше похож на крутимный,
да-да-да.
У нас тоже будут
почти карутины,
скопчика-генераторы,
семикарутины.
Вот так вот это все выглядит.
Понятно ли примерно,
чего мы хотим добиться в идеальном мире,
чтобы так вот мы писали?
Вся остальная часть лекции
мы будем разбираться, а как это внутри устроено?
А, и у нас ключевое слово
асинх есть посреди?
Да, асинх, кстати говоря,
нужно, конечно, выбрать ключевое слово асинх.
Компилятор бы сам просто уводил,
что это функция асинхронная.
Но мы же хотим, чтобы
вот color is your function, есть, например, статья,
мы хотим отмечать функции красного цвета,
которые асинхронные.
Ну и вот
в расти асинх существует для того, чтобы
отмечать синхронные блоки,
соответственно, синхронные
асинхронные блоки,
в первую очередь.
Вот.
Ну давайте посмотрим
такой примерчик.
Ну как мы будем писать вот такой вот код
в таких вот фьючах, которые я вам выдал?
Что за ерунда?
Ну полить, конечно, полить,
но утверждается.
Во-первых, async await
это синтастический сахар для компилятора,
который генерирует какой-то стейт машины.
Во-первых, когда вы пишете async fn
и какой-то возвращаемый тип,
компилятор на самом деле это превращает
вот в это.
То есть, на самом деле он превращает
это в синхронную функцию,
которая возвращает какую-то стейт машину.
Какую-то фьючу.
Ну, как плюсов там
сложно сказать, потому что плюсов
настолько много,
большой зоопарк,
всякие возможности.
Ну, я не знаю, давайте так, как
и Рома Юлиповского.
Придем к единому знаменателю.
Ну, async read file
напоминаю,
это какая-то у нас фьюча, которая возвращала
стринг в качестве результата пола.
Так?
На самом деле это превращается
в что-то такое. Там внутри фьюча
сидит, импл фьюча.
То есть, async read file
это импл фьюча, где output это
на самом деле.
А во-вторых,
наверное, так будет даже понятней, чем на
прошлом слайде.
Внутри
находится асинхронный блок.
Это какой-то лишний слайд.
Точнее, не лишний, он должен
просто позже находиться.
Это то, что происходит
на самом деле.
Async слова убирается,
вместо этого появляется
импл фьюча.
Внутри фигачится асинхронный блок,
и внутри него помещается
то, что внутри функции находилось.
А это первый шаг,
который делает компилятор.
Второй, он строит стейт-машину
внутри, по которой он
ходит.
Во-первых, у нас есть start state. Это означает то,
что мы еще не начали исполняться вообще.
Мы ни разу не вызвали функцию.
Ни разу не вызвали фьючу,
которая вернула эту функцию.
Это start state.
Обратите внимание,
что мы сделаем в этой функции.
Мы пытаемся прочитать из foo.
Потом, если у нас длина
недостаточная, мы читаем еще из
бара и консоциируем что-то.
Когда мы вызываем экземпл,
то нам возвращается
стейт-машина в состоянии start state
и никакая строча кода тут
еще не выполнилась.
Когда возвращается какая-то фьюча,
она исключительно лэйзи, она ничего не делает.
Для того, чтобы она полилась,
тебе нужен экзекют. Мы до этого еще дойдем.
Создается вот такая
стейт-машинка.
Во-первых, у нас есть start.
После того, как мы пройдем start,
у нас будет какой-то
синхронный код, контент.
Мы создадим какую-то фьючу.
Потом мы пойдем какую-то фьючу исполнять.
У нас есть weighting on foo.txt.
Внутри будет такая структурка,
которая означает ждать на foo.
Потом то же самое.
Либо мы переходим к end state,
либо мы зайдем в bar.
В таком случае у нас следующий идет
стейт. Нужно было рядом, наверное,
поместить кусочки кода.
Примерно так выглядят эти структурки.
Внутри start state он сделал
просто аргумент входной функции,
которая меняет.
Внутри weighting on foo.txt
находится только то, что важно
между start state и weighting on foo.txt.
Это min.len и foo.txt.
Фьючу, которую мы полили.
И bar.state
это контент,
который мы получили от foo.txt.
И future.bar.txt.
Вот как будет выглядеть наша
страндишина.
Обратите внимание на loop.
Я сейчас объясню, зачем он нужен.
Он нужен для того, чтобы
если вы успешно
заполили с первого раза фьючу,
чтобы вы сразу перешли дальше
в синхронную подделку.
Вы можете его не писать,
хуже от этого не станет,
но полм больше раз придется вызвать.
В таком случае.
Вот.
Потом вы можете self.
Ну и в зависимости от того,
какой у вас self, вы выполняете
соответствующий кусочек кода.
Вот как эти кусочки кода выглядят.
Во-первых, есть start.
Start, как вы видите, создает какую-то фьючу.
Нашу потом
weighting on foo.txt state
создает собственную структурку
и обновляет нас таким вот state.
Все. То есть мы просто создали фьючу.
Здесь вот.
И self у нас обновился.
Вот в текущем состоянии,
что он нас ждет foo.txt.
И внутри состояния
сидит minlan и, собственно, сама foo.txt.
Потом есть weighting on foo.txt
state. Здесь интересно.
У нас же фьюча. Мы сейчас ждем на фьюча.
Поэтому когда нам говорят,
что наши верхние уровни, вот этот фьюч,
который мы сейчас пытаемся сделать,
она сейчас пытается
заполить наш foo.txt.
Если не получилось,
то она говорит, все, у меня ничего не получилось.
Если получилось, в таком случае
она совершает прогресс дальше,
говорит, что она переходит weighting on bar.txt
либо в self.end.
Ну, в зависимости от того, как получится дальше.
И возвращает либо
poll ready, либо пытается еще заполить
on bar.
И затем еще есть
пендинг
weighting on foo.txt.
Но это уже просто.
Если пендинг, то пендинг, иначе мы
переходим в end state и после этого
poll ready. Возвращаем.
Ну и в end просто паникуем.
То есть идея в том, что
мы разбиваем нашу функцию на кусочки,
где у нас
каждая точка это либо
начало функции, либо конец функции,
либо фьюча, о которой мы ждем.
И когда нас полят, то мы пытаемся
заполить текущую фьючу,
на которую мы ждем.
Либо совершить прогресс, начиная
со старта функции.
То есть это просто способ создать
state машину.
В плюсах тоже, когда вы смотрели
на картины в плюсах, по сути там точно так же
устроена какая-то структурка,
которая содержит
текущее состояние
стека.
Да, только это
конкретно.
Да, поэтому это по сути то же самое.
Вот. Поэтому после того, как мы
все это сгеировали, тада,
вот так вот это примерно будет выглядеть.
Функция example теперь будет не asyncfnExample,
которая возвращает string.
На самом деле это будет какая-то синхронная
функция example, которая возвращает
state машину, которая является
фьючей, собственно. Ее можно полить.
Все. То есть она на самом деле
такая, но быстренькая. Просто
создает фьючу и закончилось все.
Спасибо компиратору за то, что сгенерировал
за нас весь этот код.
В общем, если вы создаете какую-то синхронную
функцию и даже там сделаете let
не знаю, x равняется
значению синхронной функции
без await,
в таком случае у вас x без это имеется какой-то
тип какой-то фьючей.
Вот.
Ну теперь давайте
вот это вот очень важный такой
checkpoint. Вы понимаете,
что значит тут разбить
функцию на state машину и создать
из функции синхронной фьючу другую.
Здесь еще важный концепт.
Вот те фьючи, которые мы будем писать,
ну, все синхронные
функции, они представляют в себя
функции, которые собирают
другие фьючи. Просто полят
другие фьючи. Но есть же какие-то самые
низкоуровневые фьючи,
которые дальше разбивать нельзя.
Например, те не из сокета.
А вот их уже предоставляет run time,
который вы напишете.
Мы о нем чуть-чуть дальше поговорим.
То есть это лиффьючи, вы их пишете
руками или вы пользуетесь готовыми
run time-ами вроде Tokyo.
И в итоге они там
работают с вашим async'ом.
Кстати, еще тоже пока вспомнил,
async await чем прекрасен,
он же
в Rust вы размазили,
он был предназначен
для написания браузерного движка
преимущественно.
И дело в том, что там все
однопоточное внутри браузера.
Ну, я имею в виду не
прям все, а вкладки.
И внутри вкладок вам хочется
тоже асинхронность, но вы же
однопоточные. И тут
появляется какое-то желание
воспользоваться асинхронностью.
Это как раз преимущество
асинхронности Rust, за счет того,
что он выросло в таком браузерном мире,
в том числе, оно
работает даже в новости D.
То есть вы можете на Embedded запускать
асинхронный код.
Ну, оно даже понятно почему, потому что у вас
это просто какая-то стоит машина,
которая генерируется компилятором.
И вот тоже тут
могу сказать небольшую историю
такого появления фьюч.
Там были в самом начале фьючи 01, потом 02,
потом 03. Не будем
людям подробно о лекции говорить об этом.
Были какие-то недостатки,
которые люди
исправляли постепенно.
Ну и вот
в чем
прикол в том,
что те, кто занимались
тем, что опруили,
просматривали просто пропозалы, как
асинхронность устроить в Rust,
там же приходили люди, свои предложения
показывали всякие.
Вот как раз те люди, которые
приходили и писали что-то,
те люди, которые проверяли
то, что писали другие люди,
у них была прям засорена там почта,
прям сотни тысячи писем
и это была головная боль
для того, чтобы как-то все это
просмотреть и
дать на все фидбэк
и подумать, как это все нужно устроить.
Но в итоге асинхронная страсти
устроена хорошо достаточно.
Мы сможем написать в ней
примерно все, что захотим.
Асинхронная.
Ладно, это был такой экскурс
вперед немножко.
Ну давайте
большой шаг
сделаем к нашей настоящей фьюче.
Видите ли вы
какую-нибудь проблему в этом
примере?
Насладеется ответного
вопроса.
Да, там сверху написано
пининг, ну наверное
pin strikes back
и естественно
мы зафигачиваем simple future здесь
не просто mute self, а pin mute self.
Потому что мы делаем, стоит машина,
в которой тоже могут быть self-referential структурки
и мы должны дать какие-то гарантии.
Еще, кстати, если бы
вы сделали non-movable структурки в расте,
то, например, вы же когда
возвращаете фьючу из функции,
вы же хотите, чтобы в тот момент она мувалась,
а когда начинает исполняться, она уже не мувается.
Поэтому pin еще чем хорош,
тем, что вы пините
объект, который
в тот момент,
когда он начинает исполняться,
он начинает иметь значение.
Теперь нужно поговорить о небольших
идейках синхронности
в расте.
Можем чуть-чуть отдохнуть, я думаю, дальше
будет не очень сложно.
Если вы хотите отдыхать, конечно.
Давайте поговорим
о том, как устроена
синхронность в расте.
До этого мы посмотрели на фьючу,
посмотрели на генераторы.
Кстати, заметно, понятно
то, как связаны генераторы и фьюч.
И то, и то стоит машина,
только если генератор всегда делает прогресс,
то фьюч пытается.
Давайте поговорим о том,
какими моделями
concurrency мы уже знакомы.
Модели как устроить
параллельные вычисления,
синхронные, куриентные.
Как их выразить.
Давай
самого простого.
Усложнил.
Ну хорошо, эхо-сервер.
Ты, даме студент, хочешь написать
эхо-сервер, который беспараллельно...
Да, 3D.
Это вообще самое простое.
Вытесняющая многозадачность.
Недостатки к 3D вам известно.
Поэтому не буду рассказывать.
Callback.
Давай до callback еще дойдем.
Я просто хочу, чтобы мы
попытались пройтись в том списке,
который написал.
Так, пойдем.
Да, файберы, которые кооперативные.
Да, есть файберы. Это Stackful Coroutine
называется. Ну там много названий.
Многолики они. Green Tracks,
Fiber, Scrutin, то же самое.
Ну или просто говоря, NxM Trading.
Подписал бы, что кооперативные
многозадачные. Да, но дело в том,
что кооперативные многозадачности
дальше примерно все.
Это все, кроме людей.
Поэтому
пошли дальше.
В том есть Stackless Coroutine.
Ну или Generator.
Только что с ним познакомились.
В плюсах мы тоже с ним знакомы.
Прекрасно.
В том есть комбинаторы.
Ну или то, как можно назвать Promises,
Futures, Callbacks.
Так, окей, что же ты называешь
Callback? Это самое...
Когда ты просто
пытаешься какую-то функцию передать,
и она становится Callback.
Ну, не знаю.
Это такое ощущение, что это просто
то, как оно устроено, скажем так,
на железном уровне. Все остальные
способы устроить синхронность.
Да, и актер, конечно.
Актеры никто здесь не знает.
Если только они работали
с ними на работе, например.
Рома Липовски про них не рассказывает.
Ну, в общем-то, это просто такой способ,
скажу для тех, кто не знает.
Есть объекты, которые
общаются между собой посредством
сообщений. Вот эти объекты называются
актеры. Ну, они посылают какие-то
сообщения друг к другу, и
актеры однопоточные. Они
обрабатывают те сообщения, которые им приходят.
Соответственно, актеры чем хороши?
Они хороши в всяких распределенных системах,
например, когда вам хочется
распределить
какие-то вычисления.
То есть, если до этого вам нужно было
в любой другой модели
явно думать про то, что у вас
объекты находятся на одном компьютере
или нет, то в актерах все равно.
Здесь
вас за это решает
ронтайм, все.
Есть подозрение, что тогда актеры
это только файберы с каналами.
Ну, почти.
В принципе, да.
Это такая вот штука.
Файберы с каналами, но только
ронтайм посложнее, конечно,
чем просто файберы.
Вот.
Ну, кажется, что с актерами понятно,
с таквулкарутинами, в принципе,
тоже пресс-минус понятно.
Ну, в общем, утверждается, что в Расте
мы можем все из этого построить.
Вот. Очень важно.
В Расте эта модель, которую мы устроим,
она называется
синхронная, не блокирующая.
Ну, что-то по-английски у полинга, да,
синхронная она называется.
Ну, полинг там
на самом деле асинхронность, просто мы пока что
до нее не дошли.
Сейчас посмотрим.
Это синхронная, не блокирующая модель.
Понимаете ли вы, что это значит?
Ну, я понимаю, типа так, что
у нас отдельное поняние операции,
отдельное ожидание результатов,
и ожидание у нас активное,
а операция, ну, когда-нибудь может быть.
Ну, я, конечно, хотел бы сказать это так.
Я бы хотел сказать, что
синхронная либо асинхронная означает то,
как у вас код выглядит.
Например, когда вы пишете
в каком-нибудь джаваскрипте,
с Node.js,
то у вас в таком случае
всякие околбекки, вы там явно пишете
.dn, .dn, .dn,
это все
выглядит как какой-то
асинхронный код. То есть он выглядит как что-то,
что должно выполняться асинхронно.
А блокирующий или не блокирующий, то,
как он на самом деле исполняется.
Ну, понятное дело, что
синхронный блокирующий
это вообще простейший код,
а асинхронный блокирующий не имеет
никакого смысла. Зачем нам писать код, который выглядит
асинхронным? На самом деле он блокирующий.
Вообще не приносит
никакого смысла. А вот, например, в Гошке
у нас синхронный не блокирующий
runtime. Прямо как в Rasta.
То есть вы пишете код, который выглядит
как какой-то асинхронный,
он достаточно простой,
последовательный,
но при этом он не блокирующий.
А асинхронный не блокирующий,
но, опять же, как node.js,
явно пишете какие-то
callbacks, и вы понимаете, что они там
где-то по очереди
будут как-то исполняться в runtime.
Ну, а что у Fiber получается,
когда так и дают
синхронные интерфейсы?
Такс.
Ну, здесь в этот момент
мы должны были бы посадить, как вы видите,
а сервер на Tokio, но, кажется, мы это уже сделали.
Мы же, в принципе,
примерно, понимаем, что хотим получить.
Смотрите.
Вот теперь пришел момент истины.
Мы посмотрели на нашу
SimpleFuture, и сейчас выглядит как-то так
наша моделька.
Смотрите, у нас есть асинхронная функция foo.
Пусть у нас есть
какой-то executor. Что у нас сейчас
делает executor? Сейчас executor
просто все foo.future, которые ему дали,
просто пытается заполить.
Беспрерывно. Вот у него есть taskFullQueue,
и он внутри него просто
полит фьючу.
А сама фьюча
ну, сама фьюча просто
говорит, что либо у него получилось что-то сделать,
либо не получилось.
Это как-то неэффективно, да?
Мы постоянно полим фьючу.
Мы не стоим на месте, мы не ждем.
У нас
очень много бесполезной работы. Давайте мы ее
как-то как-нибудь уберем.
Ну, как уберем, давайте сделаем так.
Теперь, когда мы будем вызывать пол,
ну, для простоты, если что, я здесь убрал специально
пин.
Наверное, в этом месте даже не нужно было делать,
но как факт,
здесь пина нет. На самом деле он нужен,
просто что я его убрал для простоты.
Мы будем придавать еще wake.
Wake — это такая функция,
которую
мы шедулим как наш callback.
То есть,
если у нас
фьюча
выдает ради, то в таком случае она ради.
Если она выдает pending,
то в таком случае мы говорим,
что
наш runtime как-то так должен быть устроен,
что мы где-то шедулим,
что в случае, когда у нас эта фьюча
будет готова совершать прогресс,
будет вызвана эта функция wake.
Ну, он эту функцию wake
запустит.
Ну, и вот, например, наш asyncFileRead,
на котором мы смотрели в самом первом,
будет выглядеть в таком случае примерно так.
Добавилась только одна строчка.
Это FileHandleSetReadableCallback.
Просто, когда он станет readable,
оп, wake вызвался, и наша фьюча такая
yes, я готова исполняться.
Экзекутер ее
в полем q засунул
и все, и начал исполнить.
До этого он ее даже не трогал.
Ну, и таким образом наша модель
становится примерно такой.
Понятно ли примерно, как она устроена?
То есть, фьюча, она там где-то,
если у нее не получилось исполниться
в шедуле wake,
эта штука будет называться Reactor,
которая у нас будет реагировать
на события,
которые, ну,
будет реагировать на события,
что фьюча завершилась.
И в этот момент наша фьюча
завершилась.
И в тот момент, когда он словит
сообщение о том, что эта фьюча
готова исполняться, он ее
передвинет в TaskPortQueue и снова
пробует заполнить.
И так до тех пор, пока фьюча не закончится.
Вот такой вот примерно цикл получается.
Теперь нужно понять,
как на самом деле устроена фьюча.
Ну, как она устроена?
Ну, как она устроена?
Ну, как она устроена?
Как на самом деле устроена фьюча?
Мы могли
обратить внимание, что мы
даем только fn какой-то pointer.
Дело в том, что fn нет аргументов.
Это просто какая-то глобальная функция.
Что если, ну, просто даже самый
простой пример,
что если наша фьюча
это нечто, что
в общем, она
выполняется на экзекутере не одна.
В таком случае нужно сказать, что именно ее нужно
разбудить. Им нужен какой-то контекст
исполнения. То есть сказать, что именно ее нужно
разбудить, а не все фьючи, например.
Вот. Ну, пришло время
для того, чтобы
наконец усложнить до самой
настоящей фьючи, взрослой фьючи.
У нее, во-первых, есть pin, во-вторых,
у нее есть такая штука, называется context.
Context — это, собственно,
то же самое, что у нас
наш callback, но только на стероидах.
С некоторыми изменениями.
Сейчас посмотрим.
Так, ну, тут идея понятна.
В это
же время, вот, на данный момент
context — это просто что-то,
что оборачивает тип waker.
Сейчас, если что, будет матрешка.
Приготовьте, здесь будет четыре
типа прямо подряд матрешечка.
Context
на данный момент — это просто что-то,
что оборачивает waker.
Waker, опять же, это тоже
callback.
Context, я так понял,
существует для того, чтобы, во-первых,
был lifetime какой-то.
Во-вторых, для того, чтобы можно было,
если захочется, в будущем, раз еще что-нибудь
дописать.
То есть, в плане
не ломая то, как уже устроены
фьючи,
добавить какие-то дополнительные возможности.
То есть, context — это такое промежуточное
звено, которое, скорее всего,
именно поэтому так и устроено.
В крайней мере, в библиотеке
стандартно так и написано, что на данный момент
оно существует только для того, чтобы
оборачивать тип waker.
Вот.
Соответственно, там внутри просто сидит какой-то waker.
Ссылочка, точнее,
даже на waker.
Ну, и вы можете либо создаться из waker,
либо waker вызвать.
Опять же, waker — это callback.
Что такое waker? Это что-то, что
инкапсулирует raw waker.
Пошли
еще глубже.
Нет, даже 5 будет сейчас.
Вот.
Эта штука имплементирует clone-send-desync.
Так.
Самые важные функции — это, во-первых,
wake, собственно. На waker вы можете
вызвать wake
и тем самым разбудить
future, который ему соответствует.
И потом есть, собственно, еще from-raw.
Здесь есть raw-waker.
Она unsafe, потому что
в raw-waker внутри
вы создаете vtable,
о котором мы сейчас посмотрим.
И вы должны гарантировать то, что этот
vtable-correction, что он очищает
все ресурсы, которые
future
алоцировала.
Нужно эти какие-то
гарантии дать.
В общем, это создано для того,
чтобы вы явным образом
контракт
прописали у себя где-то в коде,
когда вы будете создавать raw-waker.
Вот.
Вот raw-waker — это уже такая штука,
которая, во-первых...
Ну, вот она уже первая, наверное,
осмысленная, а не просто какой-то врагер.
Это такая штука, которая...
Ну ладно,
контекст был не очень осмыслен,
waker для того, чтобы
контракт явным образом объявить,
а raw-waker — это уже штука, которая, во-первых,
содержит указательно какие-то
данные, которые нужны future
для того, чтобы разбудиться.
А vtable — это функция, которую нужно будет вызывать.
Единственное тут важное для нас
на данную функцию — это
конструктор, который принимает
указательные данные и
статическую ссылку на raw-waker
vtable.
Итак, самый важный raw-waker vtable.
В ней внутри четыре функции —
clone, wake, wake-brf и drop.
Wake-brf нам сейчас
не очень важен.
Он используется для оптимизации всяких,
для того, чтобы waker не...
Ну, в общем,
не идеалацировать waker, не съедать его, скажем так,
посылки разбудить.
Потому что у нас waker,
он передается
future...
Ну, в общем, мы не хотим
его идеалацировать,
поэтому иногда хочется
wake-brf использовать.
Мы не будем на него подробно смотреть.
Это такая вещь, которая для оптимизации предназначена.
Суть она не меняет.
Но есть clone, wake,
clone, wake и drop —
важная функция.
Как видите, это какие-то функции, которые
принимают на вход данные.
Собственно,
туда будет передаваться указатель на data.
И в случае clone
мы будем возвращать raw-waker.
Потому что мы будем клонировать наш
текущий waker.
Функция clone
будет вызываться тогда,
когда мы будем пытаться склонировать
raw-waker.
То есть, если вы будете еще где-то выше
клонировать waker, то в одном случае
он будет клонировать свой raw-waker и вызывать эту функцию.
Соответственно.
Функция wake
будет вызываться на...
Ну, собственно, вызываться waker,
когда вы будете вызывать на нем wake
для того, чтобы future разбудить.
Ну и drop тогда
будет вызываться drop.
То есть, это тот же самый wake,
который мы посмотрели с самого
начала, который мы добавили, просто fn-поинтер.
Но на стероидах. У нас теперь есть
какие-то данные, теперь мы умеем клонировать
и дропаться еще.
Еще есть указатель
wake-by-ref, который
предназначен для оптимизации.
Так.
Ну, вот это вот я сказал,
давайте вы тоже поговорите.
Ну, мы ведем в том, что да,
мы хотим, чтобы
еще нет, он raw-waker,
мы хотели, чтобы...
Вообще, верно, что сам raw-waker
получается своим retable никак
не пользуется, и он нужен только для того,
чтобы дать его waker.
Да, да, да. Тогда мы хотим, чтобы
этот retable дало тот контракт
этого waker. Да, мы хотим, чтобы
мы очищали все ресурсы, мы хотим, чтобы у нас
retable был корректным, поэтому
у нас он unsafe.
Нет никакой проблемы создать некорректный raw-waker,
плохо тогда, когда мы его засунем
в наш
save-waker, который будет
ему уже пользоваться. В таком случае у нас что-то может
разломаться в runtime.
Поэтому мы явно
этот контракт создаем.
Так, еще более интересно, как
нам cancellation в такой модельке создать?
Это, наверное, очень простой вопрос.
В такой модели
это можно сделать достаточно
несложно.
Смотри, чтобы у future
делал прогресс, тебе нужно
полить.
Cancellation это означает, что
future тебе нужно перестать полить.
Логично.
То есть тебе нужно просто брохнуть future.
То есть, когда нам говорят,
что вот этот future cancelled,
в таком случае это такое,
ну, значит, я выкидываю ее из очереди,
где он там есть, либо
пол-Q, либо wake-Q,
и все.
Просто перестал его полить.
То есть, идея на это примерно так просто.
А как на практике
пишется, ну, посложнее.
Давайте еще посмотрим такой пример
raw-waker, который не делает ничего.
Дами raw-waker.
Здесь мы
имеем три функции, которые
просто ничего абсолютно
не делают. Клоун возвращает
тот же самый dummy raw-waker.
Vtable у нас
состоит из клоуна
нескольких no-op.
Raw-waker new это
no-pointer на данное, и vtable.
Все.
Пока что еще ничего не понятно, да?
Нам, наверное, нужно посмотреть на примерчик
сейчас, как это все связать
между собой.
Text.
Ну что ж, самая важная,
наверное, глава, на которой мы сейчас
разберемся, как это устроено.
Давайте построим небольшой
простенький такой асинхронный рейн-тайм.
В нем будет одна ли фьюча.
Ну, как я говорил, у нас есть
фьюча, которую мы пишем,
которую проводим в наш рейн-тайм.
Одна из таких фьюч может быть
таймер фьюча. Мы ее как раз построим.
Она у нас будет безумно простая.
Мы просто будем создавать thread,
который будет спать
до тех пор, пока...
Короче, будет спать, а потом
он будет нашу фьючу будить, когда проснется.
И все.
Ну, в реальном
мире вы, конечно, так не захотите,
но в нашем рейн-тайме
это будет вполне нормально,
потому что мы ее только учимся.
Еще, когда вы будете писать,
что это более сложный рейн-тайм,
скорее всего, заходите в всякие
отчетения и соки 3D и TAP.
В следующем году, наверное,
это будет домашки, но не в этом.
Так.
Более того, нам сейчас
понадобится какой-то экзекютер.
Мы его тоже напишем.
Вот.
Как вам должно быть известно,
наша
non-only-future...
Ну, то есть у нас есть не фьючи, которые
делают реальный прогресс, и non-only-future,
которые представляют у себя сверху просто
стоит машина над этими фьючами.
Они просто вызывают полно всех тех фьючих.
Вот.
Ну и мы будем передавать им какой-то
вейкер для того, чтобы нас разбудили.
Ух, так.
И для того, чтобы
когда мы пишем ли-фьюч, нам нужно
как-то гарантировать то,
что мы будем как-то
сообщать о том, что мы готовы
совершать прогресс.
Ну, то есть в случае нашей таймер-фьюч
нам нужно как-то послать сообщение,
что у нас пора уже как-то достать
из очереди вспоминания.
Ну, это, как я и говорил,
есть несколько
несколько синхронных рантаймов в Rust.
Они представляют
предоставляют некоторые
ли-фьючи сами. Ну, то есть, например,
если вы хотите откуда-то синхронно почитать,
то, скорее всего, уже из-за вас написано
ли-фьюча, и вам ничего делать не нужно.
И она уже соответственно прикручена
к вашему рантайму, с учетом того,
на какой вы операционной системе,
там, ну, там E-Poll,
CastElector, как она там в маке называется,
и так далее.
Ну, в общем-то, вам это
на практике, скорее всего, не понадобится.
Это просто в образовательных целях
мы так глубоко это все
рассматриваем.
На практике, конечно, вы будете просто писать
sync-await на каком-то готовом рантайме.
Вот.
Так мы изучаем hardcore.rust.
Давайте построим свой рантайм.
Для начала.
Наш таймер-фьюча будет себе представлять
какой-то shared state,
который будет показывать,
готова мы или нет,
и в том числе там внутри будет сидеть какой-то
вейкер, который будет
вызываться тогда, когда мы,
ну, будет вейк вызываться тогда,
когда мы уже будем готовы к
исполнению.
Так, ну тут вроде бы просто
shared state и все.
Этот shared state будет делиться
между нашей фьючей и между тем
тридом, который, собственно, спит.
Ну, соответственно, для того, чтобы
заполиться, нам нужно просто посмотреть
закончили ли
мы исполнение.
То есть мы делаем лог
на время всего пола.
Если мы готовы, ну окей, вернем
ready.
Иначе мы будем
склонируем наш текущий вейкер.
Обратите внимание, пожалуйста, что
вейкер клонировать здесь, это,
естественно, какая-то аллокация.
Это неэффективно.
Это на практике лучше
не делать, но мы это сделаем
в случае нашего простенького варантайма.
Просто вейкер наш запихнем в
timer.future и скажем,
что мы pending на этот раз.
Понимаете ли вы, почему нам вообще нужно
клонировать наш вейкер
каждый раз?
Вообще, просто говоря,
потому что мы не знаем,
у нас может поменяться
рантайм, под которым мы находимся,
например, или что-нибудь такое.
Поэтому нам нужно учитывать то, что у нас
и вейкер может поменяться, соответственно,
даже в рамках одного рантайма.
Ну, как я говорил, обратите внимание
на эту аллокацию, которую мы не хотим делать,
этот клон.
Теперь нам хочется
настоящий конструктор
фьючи написать.
А, еще, кстати говоря,
если вы не хотите просто так делать
клоун на вейкер, то еще есть такая функция
вейкер и willWake называется.
Она проверяет, что
эти два вейкера,
которые вы передадите, они действительно
будут одну и ту же фьючу.
Потому что может такое получиться,
что поменялось фьюч,
и в таком случае вам действительно
нужна какая-то новая информация о вейкере.
А если нет, то в таком случае
мы можем дропнуть наш текущий новый вейкер,
потому что он точно такой же,
как и был. Он будет ту же самую фьючу.
У нас здесь таймер фьюча.
Когда мы ее создаем,
ну, что делаем? Создаем, собственно, sharedState,
создаем клон,
который threadState,
спауним
thread, и внутри него просто
спим какое-то время, и потом пишем
такие встает, ну, все.
Я закончился, и буди.
Я готов совершать прогресс.
Ну, и все.
И таймер фьюч готов.
Окей, давайте.
Мы построили нашу фьючу,
а теперь давайте еще построим экзекьютор,
на котором наши фьючи будут исполняться.
Так, ну, у нас есть экзекьютор, собственно,
с очередью
готовых задач
к исполнению.
Ну, он будет из себя представлять
какой-то ресивер,
из которого он будет просто задача
брать. Вот.
И спаунер, в котором мы можем запихнуть
новую задачу на исполнение.
Еще я объявил
такой новый тип boxFuech, называется, который
из себя представляет просто pinBox.
Pin, но для того, чтобы нам было удобно
сделать, собственно, пол.
И box, ну, да, это
локация, опять же, но нам было
барабанно. Мы пишем простой рентайм.
У нас здесь
будет просто фьюча в боксе.
Итак, задача из себя представляет
какой-то muteX
на, собственно, фьючу нашу и сендер.
То есть task
это обертка нашей фьючи,
которую мы исполняем. Она
нужна для нашего рентайма таска.
Таска.
Наш простенький рентайм.
Итак.
Здесь
вы можете увидеть такую штуку, называется
ArcWake.
Она для вас новенькая.
Она находится в крейте,
который называется
future. Он предназначен
для того, чтобы сделать жизнь тех,
кто пишет синхронный рентайм, для расто
удобнее.
Этот трейд
предназначен для того, чтобы
делать простенький
wake на арке.
То есть, как вы видите, wake by ref
у нас в таком случае будет работать таким
образом. Наверное, достаточно wake by ref.
В данном случае, поэтому мы заимплементим
его.
Просто будем делать так. Если
wake происходит,
в таком случае мы берем task sender
и посылаем
просто в наш текущий рентайм
нашу задачу.
И все.
Все, что нужно задачи,
это просто посылать себе в рентайм.
В следующем году,
я думаю,
мне вот эта часть не нравится,
я хочу здесь написать так, чтобы вы увидели
здесь витейблы.
Это не совсем понятно,
где эти витейблы сидят, но там
на самом деле они появляются
здесь,
на следующем сладе.
New Executor и Spawner
понятны, просто какие-то два канала
и после этого Executor это очередь
готова к исполнению задач, а Spawner это
task sender.
Просто какой-то канал
неограничен.
Потом у нас есть Spawner.
Spawner
делает так.
Он просто берет наш текущий future,
делает
pinbox
и после этого ее отправляет на исполнение.
И мы оперируем опять же task.
Так, мне кажется,
что Андрей даже запутался.
Очень много кодок,
которые требуют постоянно ссылаться назад,
чтобы
играть в полной категории.
Тут примерно понятно,
как работает Spawner.
Здесь очередь задач
и он отправляет в нее задачу.
Executor и Spawner это просто
какой-то Executor, который
представляет каналчик.
Executor, когда мы
делаем на нем точечку ран,
он пытается просто ранить задачу.
До тех пор, пока у нас канал не станет
disconnected.
Помните в лекции про CROSSBIM?
Мы говорили про то, что
канал может стать disconnected,
когда у него закончились все сендеры.
До тех пор, пока сендеры не закончились,
мы пытаемся задачку достать.
Если у нас получилось ее достать,
то в таком случае мы...
Так, сейчас
сам припомни, как тут работает.
Текст.
Мы создаем Waker.
Мы пытаемся
создать Waker заранее.
А потом мы создаем, соответственно,
from Waker контекст.
Контекст, как говорила, такая штука,
которая нужна для того, чтобы
заврапить Waker.
И после этого мы
пытаемся заполить фьючу
с этим контекстом.
Если у него все получится,
то есть мы делаем пол,
а потом она говорит, что она
допустим pending.
Если она ready, то нам все равно,
потому что мы все равно
простенький, ему без разницы,
он принимает на вход
салфпутом,
который просто unity.
Он просто забивает, если у нас
фьюча закончилась.
А если не закончилась, то в таком случае
мы пытаемся просто фьюча-слот,
это сам фьюч.
То есть где-то просто фьючу откладываем
и ждем, пока
нельзя будет ее заполнить.
На самом деле у нас
этот экземпьютер совсем
плохой.
Во-первых, он однопоточный.
Во-вторых,
у него нет
трушных
вейпи
sleeping queue.
Точнее,
ready и sleeping queue.
Поэтому получается, что он
не очень эффективный.
Но тем не менее, он работает.
И вы можете даже пробовать его запустить
таким вот образом.
Кстати говоря, вот пример
из Токио и вот этот весь код,
он будет в двух разных проектах,
когда я выложу эту лекцию.
Потом вы сможете еще раз пересмотреть
это все и потыкаться.
Обратите внимание,
что спаунер мы запихиваем
фьючу, который non-live.
То есть у нас есть какой-то синхронный блок,
он возвращает
фьючу какую-то новую,
которая из себя представляет какую-то
штуку с тремя стейтами получается.
end state,
waiting on timer фьюча
собственно начало, enter.
Ну и timer фьюча
в нашем случае это уже live фьюча.
Потом мы можем спаунер наш
дропнуть для того, чтобы наш
экзекутер перешел в disconnected state
и он
корректно
завершил свою работу,
а не ждал бесконечную сдачу.
Все.
Так.
Я надеюсь, примерно понятно,
как и должен работать в runtime
врасте. Ну просто есть две очереди.
А ну прям в конкурс
будет. Сейчас я обсудим потихонечку.
Есть какие-то
вопросы, потому что сейчас был мысль.
Что-то с экзекутером я не понял.
Вот мы там, если
фьюч в случае pending, мы пишем обратно
в фьюч слот.
И что дальше с этим слотом
происходит?
Мы ж типа из канала забрали.
Нам, наверное, по-хорошему уже обратно
в канал кинуть.
Да. Ну это не идеальный просто.
Не идеальный экзекутер.
Поэтому ты можешь
ты не идеальность, которую видел, просто
смириться с ней, а потом
писать сам что-то получше.
То есть у нас
даже таймер фьюча не работает.
Таймер фьюча работает.
Она идет именно с канала.
По-моему две фьючи уже работать не будут.
Да, но это, конечно, почему работает.
Мы достаем фьюч, она все еще не pending,
потому что мы в время еще
едят.
Так, ну пошли давайте конклужину, чтобы
вот это все проговорить еще раз.
У нас
асинхронная рентайма, вроде же, работает
вокруг фьюча.
То есть у нас все устроено вокруг фьюча.
Как какое-то вычисление, которое вы можете
попробовать совершить какой-то прогресс.
Заполить его.
Вот.
То есть фьюча это что-то, что вы пытаетесь
полить беспрерывно.
Есть два типа фьюча. Это лиффьюча,
которая рентайм проводится,
и нонлиффьюча, которые создаются
асинком и эвейтом.
Стоит машина, которая
лепит друг с другом фьючи для того,
чтобы получилась какая-то фьюча побольше.
Кстати, тоже интересный факт.
Когда фьючи были еще найтли,
на них же пытались что-то писать.
Вот Фуксия, всем известная
официальная система на Rust
и Гугловская,
когда писали какие-то тесты,
у них создавались фьючи.
Просто они были не оптимизированы тогда дико
и создавались какие-то ужасные стейт-машины.
Там создалась фьюча, которая была размером
400 килобайт.
Это очень много.
То есть почти мегабайт, представьте себе.
Фьюча.
Это какие-то дикие размеры для стейт-машины.
Сейчас они уже очень хорошо оптимизированы.
И вот
то, что я хотел проговорить,
это то, что у нас
вот эта вот машина,
стейт-машина, которую мы создаем,
у нее каждый шаг,
ну это же енумы, поэтому у нас
енум будет иметь размер наибольшего
из стейтов. Соответственно,
у нас оптимальный размер
для этой стейт-машины.
Async, как я говорил, это способ
такой покрасить функцию для того, чтобы мы
видели, что она синхронна.
I await это штука,
которая предназначена для того, чтобы
стейт, очередной
стейт-машины объявить.
То есть что мы ждем на этой фьюче.
Эта фьюча дальше уже пойдет, там ждать
другие фьючи, либо она ли фьюча и будет пытаться
выполнить себя.
Вот. Потом у нас есть
ну I await это
может создать self-referential
структурку, и поэтому, чтобы
структурку обозначить
self-referential и нормально с ними работать,
у нас есть pin.
Вот. Когда вы конструируете
pin, то в таком случае обещайте, что
объект, который находится по ссылке
на pin, никогда
не будет move-аться после этого момента.
Если ваш unpin объект
то в таком случае вам
без разницы
на промес, который вы даете
создавая pin.
Это обещание без разницы.
Когда есть такая возможность
не пишите pin.
Не пользуйтесь pin, потому что
это лишний промес, и вам придется
следить за тем, что вы действительно
корректно его используете.
Если у вас есть такая возможность,
не давайте
такую гарантию, что вы что-то
не будете двигать.
OK.
С pin мы разобрались.
Когда вы пытаетесь заранить future,
то в первую очередь пытаетесь ее заполить.
Если она
не получилась
сделав прогресс и она закончилась,
то все хорошо, иначе она говорит
у меня прогресс не получилось до конца
свой довести.
И в таком случае вместо
полинга предлагается
пользоваться callback,
который нужен
runtime, чтобы сообщить
о том, что мы
готовы совершать прогресс.
В получении
мы находимся в COMTA waiting queue,
а потом мы хотим
передвинуться в
polling queue.
Так.
Затем мы хотим,
как я сказал,
мы ждем, пока
вейкер нам пошлет сигнал,
что
наша очередь,
что мы готовы
совершать прогресс.
Люди
не нужен вейкер.
Если вы будете писать на Rast,
скорее всего вам не нужно будет
знать настолько глубоко, как устроен runtime.
Это нужно тем, кто пишет
runtime, собственно, асинхронно.
Таким, как Рома Липовский.
Если вам это нравится,
то в таком случае вам нужно хорошо с этим разобраться.
Асинхронность Rast
устроена хорошо и красиво.
Так, есть ли
общий вопрос про асинхронность?
В таком случае получается
все.
Это была наша последняя лекция
по языку Rast,
и мы теперь Растасина.
Если вы все поняли с лекцией,
то вам остается только
это все отработать,
тогда вы точно Растасин.
Так, может, есть какие-то вопросы,
пожелания, предложения по курсу,
все, что угодно, любые мысли.
Да, все, что я планировал,
можно разобраться.
Но если вы все поняли с лекцией,
то вам остается только это все отработать,
тогда вы точно Растасин.
Так, может, есть какие-то вопросы,
пожелания, предложения по курсу,
все, что угодно, любые мысли.
Ну, видите, в силу базы.
Это предложения положена
до следующего года,
тогда будет первая полноценная версия.
Ну, ты можешь сказать предложение сейчас,
если тебе интересно.
Сложновато, возможно, я не знаю.
Я старался
понятнее рассказывать,
мне не получилось везде
рассказать LEGITparallel,
или не везде просто,
Но тем не менее, не все вещи просты, но для синхронизм без Рома Липовского я вообще не представляю, как вам рассказывать.
Там пришлось бы очень много видений делать. Очень большое.
Ну, в общем-то, да, просто на предложение в лэшет таракура мы не читаем.
Иначе конец хвоста живых нет.
Ладно.
