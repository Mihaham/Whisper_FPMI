Я начну. Первое, с чего хотелось бы начать это объявление. Все видели, что сегодня вам
стало доступно первое домашнее задание. Я повторяю, оно стало доступно. Домашнее задание
состоит из двух контестов. Первый контест — это примерно такой же контест, к которому вы привыкли,
то есть вы отправляете файлик с кодом, с решением, и в общем, ваше решение проверяется на закрытых
тестах. Вторая часть — это задачи, так называемые задачи из GitLab или задачи с юнит-тестированием.
В этих задачах вам нужно писать некоторый класс. Что такое класс и как их писать, мы поговорим
сегодня. Вы пишете некоторые классы, и дальше его функциональность проверяется на публичных тестах.
Все публичные тесты можно найти непосредственно в GitLab. У нас есть GitLab, на котором есть условия
всех задач, на которых есть некоторые заготовки решений при необходимости, и также есть открытые
тесты. У большинства задач тесты все открытые, поэтому, в общем-то, я думаю, что нет причин как-то
посылать все в контест и получать неправильные ответы. Весь тот код, на котором будет тестироваться
ваше решение, он доступен. Ну и за исключением буквально пара задач, на которых тесты тоже будут
закрыты. Ну и вообще, в нашем курсе большинство задач будут с публичными тестами. Вот так у нас
принято. На семинарах все успели познакомиться со способом задачи в Яндекс.контест? Все сдавали
задачи на семинарах? Нет? Кто нет? Как так? Первые две недели. Молодец. В общем, смотрите,
вся процедура того, как устроено тестирование, как будут тестироваться ваши решения и так далее,
они, в принципе, на GitLab описаны. То есть, весь процесс того, как будет происходить решение,
то есть, от проверки стиля до запуска тестов, там все указано. Поэтому, если вы все настроите у
себя на локальных компьютерах, то, в принципе, весь тот pipeline, который будет проходить ваше
решение, вы, собственно, сделаете. Понятное дело, что вы можете этому ничего не следовать,
просто посылать в контест, получать ваши ошибки, ошибки компириации и так далее. Но,
если это будет много, то в какой-то момент мы просто сделаем ограничение числового попыток. Поэтому,
в общем, локально все тестируете, тем более все открыто и доступно. Если в процессе возникнут
какие-то сложности с отправкой, непонятно, как все посылать, непонятно, как формировать файл,
который нужно отсылать, непонятно, как тестировать локально и так далее, в общем,
вы пишите там либо мне, либо Роману, ассистенту курса, либо вашим семинаристам. В крайнем случае,
если будут какие-то прям нерешаемые проблемы, мы можем устроить дополнительный семинар по тому,
как, собственно, сдавать задачи. Поэтому, если у вас есть какой-то дискомфорт, вы об этом пишите.
Мы постарались сделать максимально удобную систему, особенно по сравнению с прошлым годом и так далее.
Да, ну и дедлайн по первому заданию три недели, то есть до 3 марта можно задавать задания. Ну и,
в принципе, у нас так будут устроены задания, что каждые 3-4 недели мы будем выдавать вам новое
задание на тоже 3-4 недели. Всего будет 4 домашних задания. Вопросы есть? Отлично, тогда давайте
начнем. Ну и, наконец, приступим к теме, главной теме этого семестра. Объектно-ориентированную
программированию. Напомню, все лекции в PDF доступны, можете параллельно следить. Итак,
с чего начнем? Давайте начнем с того, что определимся с тем, что такое парадигма
программирования. Значит, смотрите, вообще есть несколько подходов к программированию. То есть,
когда у вас есть некоторая задача, то есть вам поставлена задача написать какую-то функцию,
реализовать какой-то алгоритм. Вы можете решать эту задачу несколькими способами. Можете решать,
как условно первокурсник, который только пришел на первый семинар и пишет программу в мейне. То
есть у вас есть задача, вы написали все в мейне, считали все с консоли, вывели все в консоль,
послали в контест, ок, все замечательно. Есть более продвинутый уровень, который вы изучали в
прошлом семестре, это все-таки разбивать код на функции. Зачем вообще нужно разбивать код на
функции? Смотрите, есть первый студент, который пишет все в мейне и отсылает, у него все работает.
Есть второй студент, который все разбивает на функции и посылает, у него тоже все работает.
В чем разница этих двух подходов? Зачем декомпозировать вообще на функции? В чем смысл?
Так, отлично, хорошо. Ну ок, если там что-то, если какой-то кусок кода изменился, то можно все
изменить в функции и весь остальной код будет работать. Но в мейне как будто бы тоже можно
что-то изменить и все будет работать. Читаемость. А что с читаемостью? Ну в некотором смысле да. Ну в
общем, все это верно. Ну действительно, смотрите, что такое парадигмопрограммирование? В самом коротком
варианте парадигмопрограммирование просто способ написания программ. Способ мышления, способ того,
как вы строите архитектуру вашей программы. Действительно, разбивание на функции помогает
улучшить читаемость кода, ну потому что вы по сути мейн можете описать в виде каких-то некоторых
законченных инструкций. Например, считать вот, отсортировать, вывести на экран. Вот, если весь
код считывания, сортировки, вывод на экран вы пишете в мейне, то в общем-то сложно разобраться,
а что к чему относится. Тем более, если у вас программа очень большая. Вот. И действительно плюс
гибкость. Если вам нужно изменить какой-то кусок кода, то есть вам нужно изменить, например,
алгоритм сортировки, то вам необходимо просто залезть в функцию, которая собственно эту
сортировку выполняет и изменить там необходимый код, необходимую строку и так далее. Вот. А если вы
пишете все в мейне, то есть, грубо говоря, в императивном подходе, то у вас получается так,
что вы допустим, вы функцию сортировки вызываете несколько раз. То есть, вам нужно отсортировать
несколько массивов. Но тогда вам нужно просто в нескольких местах, то есть, найти все местах,
где вы осуществляете сортировку и везде эту строку поменять. Согласитесь, это бред. Ну то есть,
зачем следить за кодом, все читать и как бы исправлять везде, если можно завести одну функцию,
в которой исправить какую-то ошибку и так далее. И тогда это исправление потянется во все остальные
сущности, в которых вы эту сортировку используете. Да? Согласны? Вот. Ну и соответственно у нас есть
три основные парадигмы программирования. Первая парадигма — это императивное
программирование. То есть, это, грубо говоря, программирование путем просто программирования
некоторых команд. То есть, вы просто пишете вашу программу как последовательность различных
инструкций. Ну, различные языки поддерживают императивное программирование. И так далее.
Вот. Дальше программирование, которое вы изучали в прошлом семестве, это было структурное
программирование, то есть, программирование с использованием некоторых независимых,
логически независимых кусков, то есть, функций. То есть, вы разбиваете вашу программу на функции,
некоторые законченные действия, скажем, отсортировать то есть, найти с помощью бинарного поиска, сделать
что-то еще, вывести, считать и так далее. И дальше вы, собственно, собираете вашу программу из вот этих
вот самых логически независимых кусков, да. В этом смеси будем изучать другой подход,
который называется объектно-ориентированным программированием. Смотрите, в чем отличие,
ну так на пальцы, в чем отличие объектно-ориентированного подхода от структурного подхода.
Когда вы программируете с помощью функций, вы, грубо говоря, программируете действия.
То есть, грубо говоря, если вам нужно, не знаю, давайте опишем какое-то действие. Ну, например,
ручка лежит на столе. Если вы хотите запрограммировать действие, чтобы ручка лежала
на столе, вы пишете «лежать, ручка стол». То есть, есть действие «лежать», которое выполняется над
ручкой столом. Но согласитесь, что в повседневной жизни мы рассуждаем не так. Когда мы строим
предложения, у нас есть всегда некоторый актор, то есть, некоторый объект, который совершает действие,
и есть некоторый объект, над которым он совершает действие. То есть, ручка, что делает, лежит на столе.
Если вы программируете какую-то игру, вам очень удобно рассуждать в терминах каких-то абстрактных
сущностей. Например, персонаж. Персонаж должен пойти из одной деревни в другую деревню, персонаж
должен там что-то сделать и так далее. То есть, есть персонаж, который совершает некоторый набор действий.
То есть, вы, например, сидите на лекции. Есть актор, то есть, абсубъект, который совершает действие,
вы сидите на лекции. То есть вас никто не сидит на лекции. То есть я вас не стижу на лекции, я не заставляю вас переходить на лекции.
Так? Так? Все, отлично. Вот. Ну и основные принципы, на которых строится объектно-ориентируемое
программирование, это абстракция, инкапсуляция, полиморфизм и наследование. В общем-то, абстракция
это про что? Абстракция это про то, что мы выделяем некоторые объекты из реального мира, то есть
выделяем некоторые сущности или концепты и оформляем их в виде некоторого, ну, условного
структура или классов, про которые мы сейчас поговорим. То есть мы вычленяем некоторые
объекты из реального мира и программируем их в виде некоторых сущностей. При этом оставляют
только значимые для нас характеристики. Ну, например, если вы хотите запрограммировать
студента, то, наверное, не стоит программировать весь его код ДНК, весь его полвозраст, его
родословную и так далее. То есть если вы программируете студента для какой-то базы данных, вам достаточно знать,
на каком курсе он учится и какие предметы изучает. В общем-то, мы выделили основные сущности и используем
этот объект. Дальше, инкапсуляция. Инкапсуляция — это про то, что на самом деле объекты обладают не
только некоторыми свойствами или характеристиками. Вот давайте вернемся, скажем, в прошлость
месяца, когда вы программируете структуру. Вот когда вы программируете структуру, вы, на самом
деле объединяли между собой только данные. То есть, грубо говоря, у вас была у структуры, не знаю,
что вы писали, стэк писали на связанном списке. Вот, значит, стэк что объединяет? Он связанный
список. Точнее, узел связанного списка. Это некоторые данные, например, целое число, и плюс
указатель на следующий узел. То есть мы объединили данные. Но при этом мы
понимаем, что, например, stack — это не только как бы вот некоторая связка данных,
ну и плюс действия, на которые можно с ними совершать. То есть объект обладает
не только какими-то атрибутами или характеристиками, но и плюс может совершать
какие-то действия. То есть мы конкретному объекту приписываем
конкретные действия. Вот это про инкапсуляцию.
Полиморфизм. Ну полиморфизм — это, если совсем коротко, то это один интерфейс
много реализаций. Ну с полиморфизмом мы на самом деле уже знакомы, были знакомы
еще в прошлом семестре, когда вы изучали, скажем, перегрузку функций. То есть
перегрузка функций — это как раз с помощью одного интерфейса вы можете вызывать
несколько реализаций. Ну, например, у вас есть функция с одним именем, но при этом
можете принимать различное число аргументов. То есть вы по одному именю
можете вызывать различные функции. Ну или шаблоны. Это тоже яркий пример полиморфизма.
То есть вы используете общий интерфейс, и при этом вам не важно, как это все
внутри реализовано. Самое главное, что это работает так, как вы ожидаете.
Ну и наконец наследование. Ну про наследование мы подробно поговорим на
отдельной лекции. То есть можно пока записать просто такое определение. Это просто
некоторая свойство, которая позволяет создавать новые типы на основе уже
созданных. То есть если вы знаете, то есть если у вас уже создан какой-то тип,
который вы написали, вот, и вам хочется написать другой тип, который по свойствам
очень близок к этому, то чтобы избирать там дублирование кода или как-то указать
родственность этих двух типов, вы можете один наследовать от другого.
Но об этом поговорим чуть позже. Вот. Ну и давайте поговорим про то, что такое
класс. Класс – это тоже основная концепция объектно-ориентированного
программирования. Значит, класс – это описание некоторого концепта из предметной
области в виде набора полей и методов для работы с ними. Ну, грубо говоря, класс – это
описание нового типа. То есть когда вы программируете, когда вы пишете код, вы
хотите ввести в код какой-то новый тип. Вот. И описать какие действия над ним
можно совершать, какие у него есть характеристики, атрибуты и так далее.
Ну вот самый, например, давайте рассмотрим тот же самый пример со стеком. То есть
здесь мы ввели на самом деле два класса. Первый класс – нод, то есть узел. Узел
имеет две характеристики. Значение, которое он хранит, и указатель на следующий
узел. И также мы ввели новый тип, стек, в виде структуры. Что мы здесь делали? Мы
сказали, что стек состоит из указателя на вершину стека, то есть на самый верхний
узел. И плюс, внимание, мы задали действие, которое можно совершать над стеком. Ну, я так
понимаю, в прошлый раз вы не обсуждали, что внутри структуры можно писать какие-то
функции. Так вот, я говорю, что на самом деле внутри структуры можно писать
функции, которые описывают, ну, собственно, действия, которые можно ним совершать.
Но, в частности, я говорю, что в стек можно добавить элемент pushIntValue. Из стека можно
удалять элемент с помощью метода pop. Из стека можно взять верхний элемент с помощью метода
top. Из стека можно очистить с помощью метода clear. И вот эти вот методы, на самом деле на
ровне с полями структуры классов, можно вызывать с помощью точки. То есть, скажем,
если у вас есть стек, то вы можете через точку вызвать top. Что это будет означать?
Это будет означать, что у данного стека нужно взять вершину. Или если вы напишете
stack.push единица, то это значит, что в данный стек нужно вставить единицу. То есть, вот ровно
про то, что я говорил. То есть, у нас есть некоторый объект, и мы над этим объектом
можем совершать конкретные действия. Мы говорим, стек запушь в себя единицу. Понятно?
Ну и здесь, да, собственно, тот пример, который я сказал. Ну и еще одно определение. Объект
— это экземпляр класса. То есть, грубо говоря, если класс — это тип, то объект — это, ну,
собственно, экземпляр типа. То есть, переменная, которую вы создаете с данным типом. То есть,
есть класс и есть объект. Так, надо следить за памятью. Еще что?
Вот, давайте сейчас скажу. Действительно, у нас, смотрите, стек, он по сути разделен. То есть,
у вас есть отдельная переменная, которая хранит буфер, и отдельная переменная хранит size. Чем
это плохо? Ну, это плохо тем, что вам необходимо контролировать, какие две переменные связаны
между собой. То есть, вам нужно следить за тем, что в push всегда приходил буфер и size от одного и
того же стека. То есть, ничто вас не защитит от того, что вы подсунете ему size от совершенно
другого стека или вообще подсунете ему совершенно другую перемену, которая с size не имеет
никакого отношения. Еще. Ну, это правда, да, но это тоже алгоритмическая проблема. То есть,
на чем стек реализовывать на списке или на массиве, это алгоритмическая часть. Меня больше интересует
архитектурная. Ну, действительно. То есть, нужно постоянно таскать за собой указатель. Нужно
постоянно за собой таскать размер. Нужно самостоятельно работать с памятью. То есть,
выделять память и очищать память. Плюс необходимо самостоятельно имитализировать размер. То есть,
что делать, если у вас пустой стек, а вы указали изначально размер равным 10? Ну, тоже ошибка. И при
этом за этим никто не следит. И при этом в любой момент, самое главное, вы имеете несанкционированный
доступ к данным. Вот, смотрите, давайте посмотрим на main. Что мне должно мешать, кроме совести,
обратиться к элементу stackBuffer. Ничего мне не мешает. Я просто могу взять и скажем, ну, несмотря на
то, что у меня стек, я могу обратиться куда-то в середину, куда-то в конец, в начало и изменить
совершенно свободные свои элементы. Согласны? Хотя, на самом деле, стек не предполагает такого
функционала. Вот. И плюс философский вопрос. А что такое вообще stack? Где в данной программе stack?
Вот такой сущности как stack в данной программе в принципе не существует. То есть, нельзя сказать,
вот где stack? Ну, можно сказать, что это вот и указатель и size, но при этом вот такой вот
единой сущности закончено, ее нет. То есть, непонятно, что такое stack. Либо это сам буфер,
либо и размер массива, либо вот сами функции push, pop и т.д. Вообще ничего непонятно. Вообще
непонятно, существует ли stack в вашей программе или нет. Теперь давайте посмотрим, как бы то же
самое можно было реализовать с помощью объектно-ориентированного подхода. С помощью объектно-ориентированного
подхода, еще раз повторюсь, это программирование типов. То есть, вы программируете новый тип. Вот
давайте заведем новый тип stack. Значит, что такое stack? То есть, если мы реализуем stack на массиве,
что он должен хранить внутри себя? Ну, понятное дело, он должен хранить сам массив, то есть,
указатель на массив буфер. Дальше он должен хранить размер. И дальше мы указываем набор операций,
которые допустимы над stack'ом. То есть, опять же напомню, вот эти функции, которые мы пишем
внутри структуры, называются методами. Смотрите, мы заводим отдельный метод init, который просто берет
вот эти вот поля нашей структуры, инициализирует с помощью выделения памяти, и size инициализирует
нулем. Нам теперь не нужно думать о том, чтобы самостоятельно как-то отдельно инициализировать
буфер и size. Все инициализируется в одной отдельной функции. Дальше есть отдельный метод finalize,
который делает необходимые действия по очищению stack'а. В частности, просто удаляет буфер. Ну и дальше
есть методы push, которые добавляют элементы в наш массив, в наш stack. Pop, которые удаляют верхний
элемент из нашего stack'а, и top, который берет верхний элемент. И дальше давайте посмотрим на main.
Как выглядит main? В main выглядит чисто и аккуратно. Мы создали переменную stack, дальше что сделали?
Пронициализировали его, запушили туда единицу, получили верхний элемент, удалили верхний элемент
и очистили наш массив. Все просто и понятно. То есть, нам теперь не нужно следить за тем, что мы правильно
передаем нужные указатели, правильно передаем нужный размер и так далее и так далее. Все делается за
нас. То есть, все скрытое, грубо говоря, внутри реализации. Вот то, про что мы говорили. Инкапсуляция.
То есть, мы объединили данные и методы для работы с ними и, грубо говоря, не видим реализации. То есть,
мы видим чистый код и понятный. Мы, по сути, решили большинство проблем и осталась единственная
проблема. И это мы, на самом деле, в любой момент все еще имеем несанкционированный доступ к данным.
Согласны? Ну почему? Потому что ничто мне не мешает все еще сделать, например, вот такую штуку stack.size
равно миллион. Но если у нас структура, то мы в свободном можем обращаться к полям. И никто
мне этого не запретит. Нужна некоторая защита от дурака. Наверное, хотелось бы, чтобы такое тоже
было запрещено. То есть, если я указал действия, которые необходимы, которые можно совершать над
stack, то есть push, pop и top, наверное, хочется, чтобы пользователь совершал только эти действия и
ничего другого он сделать не мог. Естественное желание? Ну давайте об этом поговорим. Следующая
тема это модификаторы доступа. Значит, классам и структурам можно писать модификаторы доступа.
Самые главные модификаторы доступа, на которые стоит обратить внимание, это public и private.
Но если совсем коротко, то public разрешает доступ вообще всем, то есть все могут обращаться к данным
полям и методам. А private всем запрещает. Теперь подробнее. Да, ну давайте про синдексис поговорим.
Значит, когда вы пишете структуру, вы в какой-то момент можете написать модификатор доступа. Ну,
грубо говоря, public или private. И вот начиная с этого момента, вот весь код, который написан здесь,
он, грубо говоря, становится публичным. Все могут обращаться к данным полям и методам. В какой-то
момент вы можете захотеть поменять. Точнее, тут был приватный, то есть вы запретили всем, когда вы
пишете приватную область, вы запрещаете всем обращаться к данным полям и методам. Теперь эта область
никому не доступна, кроме самой структуры. Потом в какой-то момент вы можете поменять свое желание,
вы можете сказать, что нет. Теперь вот, начиная с этого момента, все остальное должно быть публичным.
Теперь вот это вот все приватное, а вот это все публичное. Если совсем коротко. Что? Вот, да, то, что
сверху. Об этом поговорим чуть позже, но давайте я сразу скажу, что тут по умолчанию все публичное.
Ну, об этом можно было догадаться, то есть вы раньше писали структуру, ничего не писали,
поэтому по умолчанию в структурах все публичное. Так, какие вообще можно писать модификаторы доступа?
На самом деле их всего три. Ну, первое публичное, самое простое. Всем все можно, то есть можно
обращаться к полям, к методам и вообще всему, что написано там внутри. Приватное. Доступ имеет
только поля и методы самого класса, а также дружественные функции класса. Вот про дружбу мы
поговорим чуть позже, но пока можно запомнить то, что, в общем, если вы объявили область приватной,
то туда никто не имеет права обращаться, то есть никто не имеет права даже знать, что там что-то
находится. То есть вы, грубо говоря, закрыли ровно то, чего мы и хотели до этого. Ну, есть Protected,
пока давайте считать, что Protected то же самое, что и Private. На самом деле, Protected действует
чуть иначе, когда речь идет про наследование, но про наследование мы поговорим примерно через
две лекции, поэтому давайте пока считать, что Protected то же самое, что и Private. Ну, и два правила,
располагать модификаторы доступа можно в любом порядке, в любом количестве, то есть вы можете
написать, не знаю, public, потом внезапно сразу еще раз написать public, потом снова написать public,
потом поменять на private, потом снова поменять на public и так далее. То есть между собой вы можете
менять как угодно. Главное, что вот между вот этими объявлениями, то есть между вот этими словами
у вас либо публичная, либо приватная область, точнее так, которая написана выше. Ну, и модификатор
действует с точки объявления до следующего модификатора, то есть от public до public, от public
до private и от private до public. Ну и, соответственно, либо до конца класса, то есть после последнего
public, все до конца класса или структура будет публичным. Это понятно, да? Ну и давайте упражнения,
посмотрим на то, как это работает. Значит, у меня есть структура S, у меня там есть поле
int x и есть еще два int поля y и z, которые объявлены в приватной области. Есть приватная функция f,
точнее метод f, который внутри себя устанавливает x равным 0 и y равным 0. И есть публичный метод g,
который внутри себя x устанавливает равным 0 и z устанавливает равным 1. Значит, вопрос,
есть ли тут ошибки импиляции? Все ли строки хорошо сработают? Так, здесь не будет работать?
Что еще не будет работать? Так, давайте разберемся z. Кто считает, что z не будет работать?
В общем, вы не правы, z будет работать. Смотрите, на самом деле, это пример как раз про то,
что внутри структуры паблик и private не имеют никакого значения. Ну сама структура естественным
образом имеет доступ ко всему, вообще ко всему. Обычные переменные? В структурах по умолчанию все
публичное. Если у вас ничего сверху не написано, то это публичное в структурах. То есть мораль тут
такая, что модификаторы доступа внутри структуры, грубо говоря, не действуют. Понятно дело, что структура
s сама себя реализует, она имеет свои характеристики, она реализует свое метод. Естественно, она должна
иметь доступ ко всему. То есть как-то странно, что вы внутри структуры объявили что-то приватным,
и сама эта структура не имеет права к этому обращаться. Вопрос, кто имеет вообще права к
этому обращаться? Зачем тогда вообще задавали эту переменную? Публичные приватные модификаторы
доступа имеют смысл только для внешнего кода. То есть вы выставляете, грубо говоря, требования на
внешний код. То есть внешний код имеет право к этому обращаться, а к этому не имеет права. Но при этом,
так как структура всем этим владеет, она, собственно, имеет право с этим обращаться как угодно. И неважно
в каком это методе, в публичном или приватном. То есть поэтому во всех этих трех, точнее во всех
этих четырех строках, все работает как надо. То есть функция f устанавливает x и y в ноль,
и функция g устанавливает x и z в ноль. Все понятно. А теперь пример со внешним кодом. Значит,
рассмотрим структуру s. У нее есть публичное поле x, ну так у нас сверху ничего не написано, и публичные
методы g и h. h принимает int, g ничего не принимает. Есть приватная область, в которой объявлено
поле y и два метода f и h, который принимает double. Давайте по порядку. Могу ли я из main обратиться к
полю x? Да, поле x публичное, поэтому тут мне все разрешено. Могу ли я обратиться к полю y? Нет,
а вот тут не могу. И вот это, собственно, главное значение private. Если вы считаете, что данное поле
является частью реализации, ее никто не должен трогать. То есть вы считаете, что если это поле
кто-то исправит, как-то изменит, и это нарушит работу вашего класса или структуры, то вы
должны объявить это поле приватным. Соответственно, здесь так и сделано. Мы объявили поле y приватным,
и к нему никто не имеет права обращаться, кроме самого самой структуры. Дальше. Имеем ли право
вызывать метод f? Нет. Метод f тоже приватный, то есть он является частью реализации, он не является
частью публичного интерфейса. То есть, грубо говоря, не знаю, как телефон. Вот есть публичный
интерфейс, там в нем есть камеры, есть, условно, сенсоры, которые позволяют. Еще у него внутри
есть процессор, но непосредственно к процессору я обратиться не могу. То есть он там есть, но это
часть реализации, это грубая приватная область. Понятно? Вот. Могу ли обращаться к g? К g могу,
это публичный метод. Могу ли я вызывать h от нуля? Да, это h от int могу обращаться. Могу ли
вызывать h от 0.0? Но у меня же есть публичный h от int. Вот главный вопрос, будет ли тут
переобразование или нет? Вот на самом деле нет. Вот на это прошу обратить внимание. На последнюю
строку прошу обратить внимание. Этот пример показывает следующее. Как вообще принимается
решение, что публичное, что приватное? Смотрите, сначала компилятор выбирает функцию, которую вы
вызвали. То есть она определяется с функцией, то есть выбирает перегрузку. То есть в данном случае
метод h перегружен. То есть есть метод, который вызывается от int, есть метод, который вызывается
от дабла. В данном случае вы h вызвались от дабла. Соответственно сначала компилятор понимает,
что вы хотите на самом деле вот этот вот метод. То есть между h от int и h от double, h от double
обладает точным соответствием, поэтому выбирается он. А уже потом компилятор начинает думать,
а вообще может ли пользователь вызывать этот метод или нет. В данный момент оказывается,
что не может, и он выдает ошибку компиляции. То есть порядок следующий. Сначала выбирается
перегрузка, а только потом проверяются доступы. Понятно? Объявить функции вы можете внутри
структуры. А вот про определение мы сейчас поговорим. Определить можно и вне структуры.
Не-не-не. Вот перескальки он не будет. Он выберет h от double, и в этот момент у него будет паника,
потому что вы лезете туда, куда вам не нужно. То есть он выдаст ошибку, что-то типа h от double,
ну короче из private, in this context. Ну что-то наподобие такого он напишет. Впрочем он просто
скажет, что метод приватный, вы не имеете права к нему обращаться. То есть h от int он не будет,
то есть он будет его рассматривать на этапе выбора перегрузки, но по итогу выберите h от double,
и вот в этот момент будет ошибка доступа. При этом h от int можно спокойно выбирать,
почему? Потому что h от double тоже будет рассматриваться, то есть он будет видеть,
что у вас есть h от int, и у вас есть h от double. Но по итогу будет выбран h от int, потому что вы
вызываетесь от int. А h от int можно спокойно вызывать так, как он публичный. То есть выбор
перегрузки, а потом только проверка доступа. Именно в таком порядке.
Если был h от float, все равно вызывался бы h от double, потому что 0.0 это литерал типа double.
Ну и возвращаемся к тому примеру, который мы писали до этого, то есть stack на массиве.
То есть теперь как выглядит примерно правильная реализация stack? То есть мы определяем методы
в публичной области. То есть мы говорим, что со stack нужно обращаться так. Можно вызывать
метод int, можно вызывать метод finalize, можно что-то добавлять stack, можно из него что-то удалять,
можно получать верхний элемент, и можно спрашивать его размер. А к чему нельзя обращаться?
А нельзя обращаться к буферу и к size. Это детали реализации, тебе это не надо. И если вы из
main попробуете обращиться к size, даже обратиться, то есть не просто как-то изменить, а просто считать
его, у вас ничего не получится. То есть у вас правил этот запрет не только на модификацию,
но вообще в принципе на доступ, на чтение. То есть если вы обратитесь непосредственно к size,
то у вас возникнет вот такая ошибка. Исправить within this context.
Ну и до этого я часто говорил слово class, структуру и так далее. Ну в общем, смотрите,
class это концепция объектно-ориентированного программирования. То есть объектно-ориентированное
программирование просто такая теоретическая штука, которая описывает, ну собственно,
парадигму программирования. Ну и там принято такая формировка как class. На самом деле структуры,
с точки зрения теории ООП, тоже являются классами. И не стоит путать его с ключевым словом class,
которое есть в языке C++. В языке C++ есть ключевое слово class, которое обозначает буквально то же
самое, что и структура. То есть слова struct и class взаимозаменяемые. Но у них есть два отличия.
Первое отличие заключается в том, что, как мы говорили до этого, в структурах по умолчанию
всё публичное. А вот в классах по умолчанию всё приватное. Вот это первое и самое главное отличие.
В структурах всё публичное по умолчанию, в классах по умолчанию всё приватное. То есть если вы не
писали никакого модификатора доступа, то в классах у вас всё будет приватным. Ну и второе правило,
тоже оно связано с наследованием, ну в общем об этом отдельно поговори, ну давайте.
Ну смотрите, структ пришёл нам из языка C. В языке C не было никаких модификаторов доступа.
А class это концепцию OP, поэтому в языке C++ было добавлено ещё слово class. Ну чтобы было
понятней, что мы действительно объявляем class как концепцию объектной ретиропрограммирования.
Ну собственно, да, про второй пункт. Классы наследуют по умолчанию приватным образом,
а структуры публичным. Что бы это не значило? Об этом поговорим потом. Ну и на самом деле,
как правило, если вы пишете именно class, то есть как набор методов, полей и методов для работы с
ними, то есть вот так как мы писали stack, обычно пишут class. То есть если вы пишете class, пишите
class. Структуры используют в том понимании, в котором вы их использовали в предыдущем
семестре. То есть если вам нужна структура просто чтобы объединить какие-то данные,
ну просто объединить какие-то данные, то есть допустим у вас функция должна возвращать,
не знаю, bool и int. Тогда вы просто объединяете их в структуру и возвращаете совместно. Если вы
хотите описать именно новый тип, как набор действий и так далее, то вы пишете class,
но это просто некоторые соглашения. Поэтому вот с этого момента мы будем писать только class.
Да, то есть если, ну смотрите, вот если вы написали stack таким образом и не написали ни public,
ни private, ничего, то внутри stack вы вообще никак не можете обратиться. То есть такой
класс, к которому вообще нельзя обращаться. В смысле его можно создать, но при этом внутри
него ни к чему нельзя обратиться. Поэтому для класса нужно обязательно в какой-то момент
прописать public, если вы хотите его использовать. Теперь вот про то, что вы говорили, про определение
вне классов. Ну как и обычные функции, методы можно сначала объявить, то есть методы это те
функции, которые мы пишем внутри структуры или класса. Значит, методы можно сначала объявить,
а реализацию написать где-нибудь еще. Ну, грубо говоря, в отдельном файле. Вот на семинаре вы
должны были изучать, как разделять вашу программу на заголовочные файлы, на файлы реализации.
Можно структуру класса писать так. Сначала писать все объявления в заголовочном файле,
а все определения писать в CPU файле. Как это делается? Вот мы записали структуру S. Это объявление
структуры. То есть мы объявили структуру и объявили метод, который есть внутри него. В данном случае
этот метод F. Теперь этот метод F мы можем определить. Мы можем его определить непосредственно
внутри структуры, то есть написав здесь фигурные скобки и дальше написав, что мы хотим делать. А можно
написать вне структуры или вне класса. Делается таким образом. Вы пишете, собственно, прототип
данной функции, то что она возвращает void, то что она ничего не принимает. С единственным отличием вы
пишете полное имя, так называемое полное имя вашей функции. А полное имя вашей функции состоит из имени
класса, двоеточие, двоеточие и дальше имя метода. То есть вы говорите, что вы определяете функцию F,
которая объявлена внутри класса. Дальше вы пишете саму реализацию. Все как обычно. Альтернативно
вы можете сделать определение непосредственно внутри структуры. В чем отличие определение внутри
структуры или определение вне структуры? Отличие одно. Если вы пишете определение внутри структуры или
класса, то эти функции не явно определяются как inline. Все помните, что такое inline? Inline так
называемые встраиваемые функции. В общем, раньше смысл встраиваемых функций был такой, что их код
просто берется, непосредственно поставляется вместо вызова, то есть не происходит переключение
контекста и так далее. Сейчас inline используют для того, чтобы нарушать правила одного определения.
То есть вы знаете, что функции в программе могут существовать только в единственном экземпляре,
то есть допускается только одно определение функции на всю программу. Но если вы для функции пишете
inline, то это правило можно обойти. Inline говорит, что определение этой функции несколько
определений, но при этом важно понимать, что у этой функции все определения должны быть одинаковые.
В стандарте написано с точностью до токенов. Это такое специальное слово, которое говорит
о том, что я хочу так. Это может быть полезно, если вы, например, пишете какую-нибудь короткую
функцию, для которой вам не хочется отдельно писать объявление, для которой вам не хочется
отдельно писать определение, то есть не хочется разделять ее на h и cpp файл. Вы можете написать
определение функции в cpp файле и пометь ее как inline. И тогда эта функция будет присутствовать во
многих экземплярах в различных cpp файлах, но при этом так и на inline все будет нормально.
Впервые поступил интересный вопрос. Смотрите, все время до этого мы как-то ограничивали доступы,
то есть ограничивали с помощью паблика и правила, и вот поступил вопрос, а можно ли,
грубо говоря, запретить запись, но разрешить чтение, то есть я хочу создать поле, которое можно
читать, но при этом перезаписывать нельзя. Вот напрямую так сделать невозможно, но есть такой
специальный паттерн, называется Getter и Setter, то есть вы заводите некоторые специальные методы,
которые позволяют либо устанавливать значение, закрытое поле в нужном вам значении, либо его
читать. Вот, например, если у вас есть какой-то класс, и у него есть закрытое поле x, которое вы
запретили изменять, то есть которое вы хотите запретить изменять, то при этом которое вы хотите
разрешить читать. Вот, для этого вы в публичной области заводите специальный метод, условно
называете его GetX, то есть получить x, и из него вы возвращаете x. Вот, и тогда с помощью этого метода
вы в любой момент можете, то есть внешний код может в любой момент получить значение этого самого
поля, но при этом на запись это поле, естественно, недоступно. Понятно? Ну, такой вот паттерн. Так,
теперь давайте пойдем дальше. Поговорим про константность. Значит, константные поля. Ну,
собственно, как и любые другие обычные переменные, поля можно объявлять константными. То есть у вас
может быть поле x, которое неконстантное, может быть поле y, которое является константным n-том.
Понятно дело, что как и любые другие константы, константные поля нужно инициализировать сразу
при создании объекта. Как это делать правильно, мы поговорим уже на следующей неделе, когда будем
говорить про конструкторы. Но пока на текущий момент правильный способ инициализировать
константы, это просто непосредственно при объявлении структуры прописать его дефолтные
значения. Ну, сейчас я хочу, чтобы у меня было константное поле, которое равно 9. Естественно,
такие поля изменить нельзя. То есть, если это поле констант, его изменить нельзя. Вообще никак. Вот
эту мысль запомните, она важная. В константной поля никак изменить нельзя. Вот вообще. Даже с
помощью того, что мы будем рассматривать дальше. Вопрос? Кост-каст. Ну, кост-каст это запрещенный
способ. Вы что, рот смылом-то помойте. Зачем? Нет, короче, нельзя. Ну, короче, если вы объели
константы, значит нельзя. В принципе, нельзя. Окей. Ну и простое упражнение. Смотрите, у меня
есть структура S, у которой есть публичное поле X и публичное константное поле ID. Которое просто,
при создании нового объекта, оно получает некоторый новый уникальный номер. Ну, уникальный номер
пусть хранится в глобальной, какой-то глобальной области. То есть, у меня есть N. И при каждом
создании объекта у меня N записывается в константное поле ID и увеличивается на единицу. Вот. И у меня
есть метод F, который пытается увеличить X на единицу и пытается увеличить ID на единицу. Что здесь
не так? Да, ID изменить нельзя. ID это константное поле, поэтому его никто никогда изменить не может.
Даже внутри метода. Так, теперь посмотрим на внешний код. Вот когда я объявил S от A, у меня у A ID
стал равным нулю. Когда я объявил B, точнее, определил B, у меня ID стал равным единице. При этом я не
изменял ID, я их проинициализировал. Понятно? То есть, при создании объекта у меня отработал вот этот
код и ID проинициализировался. Все. Могу ли я обратиться к A.X и B.X? Почему нет? Или почему да?
Может быть, я там не могу этого? Да, во-первых, потому что x публичная. А во-вторых, потому что x не константная.
Точнее так. Я обратится, как Normally parfois могу, потому что он публичный. А изменить его
могу, потому что он не константный. А к ID я могу обратиться таким образом? Да, снова, ID публичный,
поэтому обратиться-то я могу. Но то есть 對, прочитать его я могу. Но, при этом присвоить ему
какое-то значение, или его как-то изменить не могу, поэтому да, здесь ничего не работает.
Понятно? Ну, с константными полями все просто. В общем, они ведут себя так же, как и обычные
константные. Вот теперь новая сущность, константные методы. Короче, методы или функции,
которые написаны внутри классов, на самом деле тоже можно объявить константными. Какой в этом
смысл? Смотрите. Давайте вспомним класс stack, который мы буквально недавно написали, ну и посмотрим
на реализацию метода size. Что делает метод size у stack? Он просто возвращает размер stack. Согласно,
да? То есть size это приватный член, но чтобы получить к нему доступ на члене, я его возвращаю
из специального метода size. Окей? Вот. Ну и теперь давайте посмотрим такой момент. Смотрите,
я build stack. Ну как-то с ним поработал, что-то в него запушил, там как-то провел над ним необходимые
действия. А потом, допустим, создал на него константную ссылку. Ну, что такое константные ссылки, думаю,
помните, да? Просто создал ссылку на S. И даже через эту константную ссылку попытался узнать,
какой размер у меня у stack S. И внезапно получил довольно странную ошибку. Что-то там passing,
какой-то констек, что-то там this и дискарс какие-то qualifiers. Ничего не понятно. Ну, так или иначе,
видимо, проблема в том, что у меня, ну то есть, судя по ошибке, проблема в том, что у меня с ref
это константная ссылка, и у константной ссылки я попытался что-то сделать. Так это что получается,
если у меня объект константный, то я у него не могу вызвать никакие методы? В чем проблема, как вы думаете?
Ну, а какая разница? Ну, хорошо, не сказали. Ну, как бы компилятор, он же, ну, смотрите,
у нас есть метод size, он ничего не изменяет, на констанцию это не влияет. В чем может быть проблема?
Да, отлично. Действительно, методы, в общем случае, могут что-то изменить. То есть, компилятор,
смотрите, как действует компилятор. Вот компилятор, когда читает ваш код, он же, на самом деле,
вот когда вы вызываете функцию, он же не лезет в ее определение, не смотрит, а что вы там делаете,
интересно, давайте я посмотрю, что он там замышляет, этот пользователь. Нет, он просто
видит метод на точку вызова, вот, с ref.size и смотрит, можно ли вызывать size с помощью пустых круглоскобок,
ну, кажется, да, можно. Что возвращает size? int. Ну, как бы, пользователь не сохранит это, ну ладно,
бог с ним. Но при этом он не будет лезть во внутрь этого метода и интересоваться, а меняет ли что-то
этот метод или нет. То есть, у компилятора всегда паника в этот момент. Вы у константного метода
вызываете метод, метод может что-то изменить, все, нельзя. То есть, проблема в том, что методы могут
что-то изменить. Поэтому у константных объектов просто так методы вызывать нельзя. А как это
их можно вызывать? Точнее, какие методы можно вызывать? А можно вызывать константные методы.
Смотрите, если вы хотите, компилятору, сказать, что этот метод, ну то есть, вы хотите поклястся
к компилятору, что вот этот метод точно ничего не будет менять. Все будет нормально. В общем, вызывая
этот метод у константных метод, у константных объектов спокойно, вы должны написать ключевое
слово const. После прототипа функции. То есть, вы пишете название метода и дальше приписываете
И вот это слово const является такой успокоительной таблеткой для компилятора.
То есть вы говорите, что этот метод спокойно можно вызывать у константных объектов.
Он ничего менять не будет. И вот теперь предыдущий пример будет спокойно работать.
То есть компилятор увидит метод size, поймет, что этот метод size вы вызываете от константного объекта,
увидит, что этот метод сам константный, то есть вы поклеились ничего не менять, и все будет нормально.
Предвосхищаю вас в вопрос, а можно ли на самом деле что-то там изменить?
Ответ – нет, нельзя. Константные методы работают таким образом, что они не только успокаивают компилятор,
но они контролируют ваши действия за тем, что вы ничего не изменили.
То есть если вы поклеились, что ваш метод ничего не меняет, то считаете, что это кряд вы кровью.
В общем, вы ничего менять не должны. Если вы попытаетесь что-то изменить внутри константного метода,
то у вас будет ошибка компилации. То есть когда вы зашли внутрь константного метода,
у вас все поля автоматически стали
константными, ну грубо говоря,
поэтому мораль. Если ваш метод,
то есть если у вас метод на самом деле
ничего не меняет, то нужно помечать его
const, для чего? Чтобы его можно вызывать
с помощью, ну, через константные объекты
или через константные ссылки.
Ну и плюс, если по логике, по логике вещей,
по логике данного метода, этот метод
ничего не должен менять, то тоже пишите const,
потому что он контролирует вас и
избавляет вас от ошибок непреднамеренно.
То есть если вы случайно в этом методе
что-то измените, то вам компилятор подскажет,
что у вас метод константный, а вы что-то поменяли.
Понятно? Окей.
Ну и наконец, естественно,
в константных методах можно вызывать
только константные методы.
То есть, смотрите, если у вас есть метод size,
и вы внутри него вызываете pop, то такого делать
естественно нельзя, ну, по понятным причинам.
Вы находитесь внутри константного метода
и вызываете неконстантный метод.
То есть pop по логике не является константным.
И по логике, и по сути не является константным.
Поэтому его вызывать нельзя.
То есть компилятор внутри константных методов
проверяет, действительно ли вы вызываете
только константные методы.
А здесь
внутри top можно...
Смотрите, я завел...
У меня есть метод top, который
возвращает верхний элемент
стека. Вот в нем я могу спокойно
обращаться к методу size. Почему?
Потому что и метод top у меня константный,
и метод size у меня тоже константный.
Константные методы внутри константных методов
я вызывать могу спокойно.
Ну, мне кажется, это очевидно.
Все.
Ну, и наконец,
еще одно важное правило.
Константность является
частью сигнатуры метода.
Поэтому по константности
можно перегружать методы.
То есть у вас могут быть два метода
с одинаковыми именами и с одинаковыми
аргументами, которые отличаются только
константностью.
Понятно? То есть у вас может быть один метод
константным, а другой метод неконстантным.
Для чего это может быть нужно?
Ну, смотрите.
Давайте на примере метода top.
Ну, метод top у меня возвращает
верхний элемент стека.
Понятное дело, что я метод top могу вызывать
от константного стека, но просто хочу посмотреть
на верхний элемент. Это логично.
Поэтому я завожу метод top, который константный,
так же возвращает int.
А теперь я хочу задать поведение метода top,
который будет работать с неконстантным
стаком. Вот для неконстантного
стека я хочу, чтобы он возвращал не просто
верхний элемент, а ссылку
на верхний элемент.
Ну для чего я это могу захотеть делать?
Ну, например, чтобы работал вот следующий код.
Например, я хочу чтобы
я мог просто взять и изменить верхний
элемент. Ну, чтобы не делать там
pop и push. blow.
То есть представь себе, что у меня есть стity, я хочу просто изменить верхний элемент.
Согласитесь, сначала сделать pop, а потом push долго.
Я хочу, чтобы у меня работал следующий синтаксис.
a.top равно единице. То есть просто взять верхний элемент и его изменить.
Вот чтобы такое работало, я из неконстантного метода top возвращаю ссылку.
И теперь это работает.
А если я тоже самое попытаюсь сделать для константного стека,
то у меня будет ошибка компиляции. Почему?
Потому что константный стек возвращает мне не ссылку, а временное значение.
А временное значение, естественно, ничего нельзя присвоить.
Пример понятен? Почему это может быть нужно?
Что?
Почему не перегрузка? Перегрузка.
Так перегрузка, еще раз, что такое перегрузка?
Перегрузка – это когда у вас есть две функции с одинаковым именем.
Здесь все понятно, да?
Окей.
Теперь поговорим про статические поля метода.
Не, константность определяется тем, какой объект у вас стоит.
Константность у вас определяется тем, какой объект у вас стоит здесь.
Можно считать так, что у вас у любых методов в качестве первого аргумента всегда стоит ваш объект.
Например, если вы вызываетесь от обычного стека, то у вас в первом аргументном стоит ссылка на обычный стек.
Если вы вызываете от константного стека, то у вас стоит константная ссылка на стек.
То есть можно, грубо говоря, считать так.
То, чего вы вызываете, это первый аргумент.
А второй аргумент он понимает, что вызывает – константный или неконстантный.
Естественный этап компиляции компилятора понимает, объект A – он константный или нет,
CRF – это константный объект или нет.
И в зависимости от этого вызывает нужный метод.
Еще важный момент.
Не знаю, говорил я или нет, но и понятно или нет.
Представь себе, что у вас вот этого метода нет.
Но я думаю понятно, что вот эта строка не в таком виде,
а вот в таком виде,
по-прежнему будет работать.
То есть естественно, если у вас объект неконстантный, то у него일 константные методы тоже можно вызывать.
Понятно?
То есть если у вас объект неконстантный, то это не значит, что вы его должны постоянно изменять.
То есть если у вас объект неконстантный, то вполне возможно, что вы его вызываетете и методы, которые его не меняют.
Это очевидно, но давайте проговорим.
Так, смотрите, выбор перегрузки же происходит только по сигнатуре.
То есть компилятор не будет смотреть, что у вас методы абсолютно одинаковые,
он не будет вам говорить, что а что это ты написал одинаковые методы.
Ему вообще все равно, что написали.
То есть вы вполне можете написать, ну давайте, если вы не писали тут апперсант,
вы могли бы написать и так. Компилятор не будет проверять,
что вы написали одинаковый код или не одинаковый.
То есть тут важное отличие, что будет вызываться в каком случае.
Константный метод будет вызываться для константных объектов,
не константный или не константный.
То есть не обязательно писать разные реализации.
Дальше идем?
Так, статические поля и методы.
Ну, снова, мы знаем ключевое слово static,
то есть у него есть очень много различных смыслов в языке C++,
то есть статические переменные внутри функций, статические функции,
статические константы и так далее, и так далее.
Еще есть смысл статических полей класса и статические методы.
Значит, когда вы объявляете поле статическим или метод статическим,
это означает буквально следующее.
Вы говорите, что это поле или этот метод принадлежит не конкретному объекту,
а принадлежит классу в целом.
Что здесь имеется в виду?
Вот смотрите, когда мы работали со стеком,
у нас вот этот буфер и вот этот size,
к какому объекту они относятся?
Они относятся к конкретному объекту, относительно которого мы вызываем метод.
Согласны?
Вот у меня есть, допустим, стек S1 и есть стек S2.
Я вызываю S1.top и вызываю S2.top.
Вот top, который вызывается от S1, и top, который вызывается от S2,
обращаются к совсем разным данным.
Понятно, да?
То есть у S1 и S2 у них разные и буфер, и size.
Абсолютно разные.
А когда вы объявляете статическое поле или метод,
вы говорите, что это поле принадлежит сразу всем объектам.
То есть такое вот общее место.
И вот к этому полю конкретному могут обращаться все объекты.
И если какой-то объект изменил это поле,
то все остальные объекты это изменение тоже увидят.
Понятно?
То же самое касается статических методов.
Значит, статический метод – это метод,
который работает не с конкретными полями конкретного объекта,
а работает в целом для всего класса.
Понятно или?
Ну давайте сейчас перейдем к примерам.
Давайте пока правила.
Ну да.
Поляменты принадлежат не конкретному объекту, а классу в целом.
Так как они принадлежат не конкретному объекту, а классу в целом,
к ним можно обращаться не через объект.
То есть вы можете вообще не…
Так как они принадлежат к классу, вы не можете не создавать объект, чтобы обратиться к ним.
Например, к полю у вы можете обратиться через двоеточие.
Вот так.
Можно, вы можете объедить S какой-то объект, и S.45.
То есть так тоже можно.
Но согласитесь, странно –
ерг hayırя, еще, наверное, для всех объектов странно как-то создавать объекты classes
специально чтобы обратиться к некоторому общем.
Чтобы обратиться к общему, вы можете написать вот такой код.
К общей функции, к статическому методу вы можете написать вот так.
Просто через оператор разрешения области видимости вы можете обратиться к статическому полю
или к статическому методу.
Это не важно. Смотрите еще раз, давайте повторим, что было в прошлом семестре.
Статические переменные в какой области памяти находятся? В глобальной.
То есть они создаются в момент, когда у вас инитилизируется программа, когда у вас еще никаких объектов не создано.
То есть у вас программа работает, никаких объектов S нет, но статические поля, они уже созданы, так они находятся в глобальной области.
То есть вы можете не создавать ни одного объекта, но статические поля у вас уже будут. Вот как здесь.
То есть мы здесь, допустим, не объявили никакого объекта, но при этом к S от Y можно спокойно использовать.
Ну ровно как и S.G. Что еще раз? Мы про конструкцию еще не говорили, но статические поля создаются не в конструкторах, сразу скажу.
Ну естественно, если вы объявите поле константным, то вот так изменить его нельзя будет.
То есть вы можете создавать константные статические поля.
Да, ну и последнее правило, статические методы могут работать только со статическими полями.
Ну я думаю это понятно почему, потому что давайте попробуем написать реализацию функции G.
И я тут делаю, например, какой-нибудь плюс-плюс X. В чем проблема, понятно?
G принадлежит классу в целом, а не конкретному объекту.
Когда вы делаете плюс-плюс X, непонятно, какой конкретно X вы хотите изменить.
То есть один раз на экзамене мне сказали, что когда я делаю вот так, то у меня изменяются сразу все X во всех объектах.
Ну естественно это не так, это не работает.
Когда вы вызываете S, вы метод G вызываете не от объекта.
Поэтому G не понимает, какой X ему нужно изменить.
И это будет ошибка в компиляции, понятно?
А вот так я могу сделать. Почему?
Да, потому что Y общий на всех, он глобальный.
К какому Y обращаться понятно. То есть Y он единственный на всех.
То есть он единственный, и поэтому тут никакого...
Как это на русском слово?
Короче, никакого конфуза не происходит.
Ну и классический пример.
Есть у меня структура, для простоты тут все публичное.
Ну, кстати, давайте в качестве замечания тоже скажу, что статические поля и статические методы
можно объявлять либо в публичную, либо в приватную области.
Если вы объявили в приватную область, то теперь обращаться к ним вам запрещено.
Если вы объявили в публичную область, как здесь, то можете спокойно к ним обращаться.
Понятно, да?
Ну вот у меня есть структура S.
В ней у меня есть int поле X, статическое поле, и Y.
И есть два метода, есть метод F и есть метод G.
F не статический, G статический.
Давайте посмотрим на метод F.
Могу ли я сделать X плюс равно 1?
Ну, естественно, я могу.
То есть метод спокойно может изменить поля.
А могу ли я из метода F изменить Y?
Ну тоже да.
Мы это не обсуждали, но это логично, что можно.
Потому что тоже нет никакой, в общем, нет ниоднозначности.
Понятно, к кому Y вы обращаетесь.
Теперь рассмотрим метод G, который статический.
Могу ли я сделать X плюс равно 1?
Нет, это обсуждали.
То есть к X обратиться нельзя.
Потому что непонятно, какую X вы имеете в виду.
А Y можно изменить?
Да, можно.
Y существует в единственном экземпляре на все классы.
Поэтому все нормально.
Ну и такой пример.
Левая часть у нас рабочая.
То есть мы поняли, что внутри метода G нельзя изменить X.
Поэтому из него X плюс равно 1 выпили.
Теперь давайте посмотрим на Main.
Допустим, Main у меня выглядит следующим образом.
В Main я создаю две переменные, A и B, которые имеют тип S.
Дальше говорю, A точка X равно 0, B точка X равно 0.
Ну понятно, что X стал равным 0, B точка X стал равным единице.
Я делаю A точка Y равно 0, B точка Y равно единице.
Чему у меня равно A точка Y?
Единице.
Да, почему?
Потому что сначала я изменил Y на 0,
а потом с помощью B я изменил Y на единицу.
Ну естественно, Y у меня один и общий,
поэтому в нем хранится последнее изменение.
Ну и B точка Y тоже естественно единица.
Теперь я делаю S 2.2.X равно 10.
Что происходит?
Ошибка.
X не статическое поле.
X принадлежит каждому объекту в отдельности.
Когда вы делаете вот так...
Во-первых, X не глобальный,
поэтому непонятно, к кому X вы в принципе обращаетесь.
Но во-вторых, в общем, это тупо не работает.
Тут будет ошибка компиляции.
Когда я делаю S 2.2.Y равно 11,
чему мне равно A точка Y и B точка Y?
11. У меня изменился один общий Y,
поэтому неважно, к какому Y через A или через B вы обращаетесь.
Так, я вызываю A точка F и B точка F.
Да, здесь единица, здесь двойка.
А Y к чему равен? Давайте пропишем.
13, да. То есть мы до этого изменили его на 11,
а потом мы два раза увеличили на единицу.
Так, и мы два раза вызвали F.
Ну и теперь я два раза вызываю G.
Да, ну то есть здесь 15, здесь 15.
Точнее, один общий Y стал равным 15.
Я вызываю S 2.2.F.
Ну, нельзя, да, снова.
F это нестатический метод, поэтому так нельзя.
Возвываю S 2.2.G, так можно.
Но в итоге у меня Y стал равен 16.
Ну вот.
Все понятно, нужно что-то повторить.
Ну смотрите, что мы делаем вот в этой строке?
Мы Y присваиваем 0,
а потом Y присваиваем единицы.
Так как Y статическое поле,
и A, и B обращаются к одному и тому же Y.
Поэтому, ну, собственно, вот последние изменения,
оно и отражается в A.
Так, еще.
Ну, вот.
Окей.
Вот.
Ну и такой сложный момент про статические поля,
который нужно проговорить.
Смотрите.
Статические поля, на самом деле, не так просто проинциализировать.
Вот они в этом смысле очень хитрые ребята.
Вот если я сделаю вот так,
ну, то есть просто напишу структуру S
и объюлю в ней статическое поле int X,
то я получу ошибку линковки.
Ну, я надеюсь, что вы, в общем,
рассматриваете, что такое линковка.
В общем, произойдет ошибка.
Почему?
Ну, смотрите, вообще глобальные переменные,
они по умолчанию унициализируются нулем,
поэтому все нормально.
С статическими полями класса такое не работает.
Статические поля класса
всегда нужно как-то инициализировать.
То есть статические поля класса,
ровно как и константные поля,
нужно всегда чем-то проинциализировать.
Ну, вот.
Если вы попытаетесь проинциализировать,
то вы тоже получите ошибку компиляции,
которая уже будет звучать следующим образом,
что вот компетент по статистизации языка C++,
блабла, короче, запрещает
инициализировать неконстантные
статические члены.
Короче, получается парадокс.
Инициализировать нельзя,
неинциализировать тоже нельзя.
На самом деле парадокса никого нет.
Тут проблема заключается в том,
ну, то есть тут проблема, как раз заключается в том,
что у вас есть один парадокс,
то есть тут проблема заключается в
правиле одного определения,
про которое мы говорили.
Значит, по поводу глобальных переменных,
правил одного определения говорит следующую вещь,
что все глобальные переменные должны быть определены
только один раз, только в одной единице трансляции.
Ну, короче,
только в одном CPP файле.
Вот так. Окей?
Ну, окей.
А в чем может быть проблема,
если я внутри структуры объявил статическое поле X
и сразу проинциализировал его нулем?
Какая проблема?
Нет, нет,
с объектом это не связано.
Это связано непосредственно с определением S.
Ну, короче говоря, у вас может быть так,
ну, короче, у вас может случиться так,
что вы структуру S написали,
ну, короче, правила одного определения
для структуры и для класса говорит следующую вещь,
что у вас класс и структура может быть объявлен
только один раз в одной единице трансляции.
Ну, или в одном CPP файле.
То есть тут возникает такое несоответствие.
Переменные должны быть объявлены один раз
на всю программу,
а класс должен быть объявлен один раз
на один файл, грубо говоря.
И вот смотрите, что у вас получается.
Представьте себе, что вы одну и ту же структуру S
определили в
нескольких файлах.
Ну, вроде бы все окей.
То есть вы класс определили в нескольких файлах,
и
ну, компилятор на это не жалуется.
Но если вы внутри класса объявили статическую
переменную или статическое поле,
то у вас возникает парадоксальная ситуация,
что вы класс объявили несколько раз, и все нормально,
но при этом глобальная переменная X объявлена
несколько раз уже в одной программе.
Что запрещено?
Ну, просто проблема понятна?
На интуитивном уровне.
Вот.
Как эту проблему обойти? Как ее решить?
А решение очень простое.
Статический поля нужно инициализировать вне класса.
И только один раз.
Делайте это следующим образом.
Вот так.
То есть
где-нибудь вне класса,
в одном файле, ровно в одном файле,
вы должны написать следующую вещь.
Ну, собственно, вы должны написать объявление
переменной
с полным ее именем s2.x
и написать, чему она должна быть равна.
Все.
Таким образом вы вынесли определение
из класса, из структуры,
то есть если вы сделали такое
определение только в одном файле,
то это работает нормально.
У вас статическая переменная, то есть глобальная переменная
определенна только в одном файле,
но при этом структура может быть определенна в нескольких файлах.
Поэтому нет никаких проблем.
То есть это окоперение s2 может быть очень удобной?
Да.
Да, да.
Вот.
Ну, единственное исключение, единственное...
Ну, досье плюс 18
кажется точно единственное,
заключается в том, что в качестве статических
что статические поля можно объявлять
внутри классов, но только если они
константные и целые.
Вот если у вас статическое поле объявлено
как константное, и при этом это константно целое,
то есть int, long или что-то еще,
то ее можно определять
внутри класса. Вот это единственное исключение.
Во всех остальных ситуациях статические
поля должны быть инициализированы вне
класса. Вот таким образом.
Да, тоже вне класса.
То есть если здесь статик,
если тут написано
статик
const
float y,
то вы должны писать
вот так.
const float y
равно, ну, там, скажем, 0.
Ну, короче, мораль, вот самая главная
из того, что нужно вынести из вот этого
пятиминутного спича,
статические
поля нужно инициализировать вне класса.
Вот синтаксис.
Пользуйтесь.
Ну, это связано с тем, что
в C++ есть правила одного определения.
Так, ну и константные статические
методы. Значит, очень короткий пункт.
Константных статических методов не существует.
Ну, короче, у нас есть
константные методы, есть статические методы.
Объединять их нельзя.
Ну, действительно, мне как бы непонятно, в чем смысл.
То есть, константные методы говорят о том,
что этот метод ничего не меняет.
Константные статические методы
должны говорить о том, что они,
короче,
короче, даже если бы они существовали,
то непонятно, как определить,
что вы хотите вызвать. То есть, представьте себе,
что вы, допустим,
мы разрешаем константные статические методы.
Скажем,
static void
g, и у нас есть
static void
g и const.
Я вызываю s
2.2.g.
Вот уже здесь непонятно, что я хочу.
Константный или неконстантный g.
Поэтому
константных статических методов
не существует.
Да, ну еще одно замечание,
которое навеяно, собственно,
разговором на экзаменах.
Константные методы не могут
изменять константные поля.
Это не знаю, запишите отдельно.
Константные поля никто не может изменять,
константные поля вообще нельзя менять.
В константных методах нельзя изменить константные поля.
Смысл константных методов не в этом.
А в чем смысл константных методов?
Да, константные методы ничего не изменяют,
вот они об этом говорят, все.
Ну и, видимо,
последний пункт.
ключевое слово this.
Значит, есть ключевое слово this,
которое говорит следующее,
короче, которое означает следующее.
This возвращает вам указатель
на текущий объект.
This возвращает вам указатель
на объект, над которым вы сейчас работаете.
Ну, то есть,
допустим, вы находитесь в структуре s,
и вы хотите написать метод,
который возвращает адрес
текущего объекта.
Тогда вы можете сделать следующую вещь.
Вы можете просто сказать return this.
This возвращает вам адрес
объекта, над которым вы сейчас работаете.
Что еще можно сделать?
Ну, например, вы можете, если вы хотите
обратиться к кому-то полю,
вы можете написать this и дальше
через стрелочку x.
Понятно, почему через стрелочку, да?
Потому что если у вас есть указательную
структуру, то к его полям вы можете
обратиться через стрелочку.
Вот.
Вот сейчас я про это скажу.
Значит, это будет абсолютный
эквалент на следующему коду.
То есть, на самом деле, можно сказать, что когда вы пишете вот так
x равно value, у вас компилятор
подставляет вот такой код.
То есть, как компилятор понимает, к кому x вы обращаетесь,
он просто-напросто берет и подставляет
this стрелочка x. То есть, вы должны обратиться
к x, который расположен по такому-то адресу.
Окей?
Вот, когда вы...
Вот здесь то же самое.
Вот.
Чтобы понять, к кому x вы обращаетесь,
компилятор подставляет сюда this.
И он говорит буквально о следующем.
Вы переходите по указателю this и смотрите,
к кому x там лежит. И вот его возвращаете.
Теперь про то, имеет смысл это или нет.
Ответ нет.
Короче,
писать вот так...
Короче, пока вы маленький,
на текущем уровне нашего размещения,
стрелочка x писать не нужно. Вот вообще не нужно.
Есть ситуации, при которых
это необходимо.
Но о них мы
либо поговорим, либо не поговорим позже.
Вот.
В общем, это сложная ситуация, которая связана
с шаблонами, с...
Я вижу вас с шаблонами, с наследованием,
с зависимыми именами. В общем,
все мутно. В общем, но ситуация,
когда это нужно есть. Вот.
Пока вам это не нужно.
Вы молодые, шутливые...
Да.
Там тоже можно
использовать this спокойно.
Сейчас, подождите. Если вы...
Нет, давайте так.
Вопрос, видимо, такой был.
Если я хочу написать реализацию какого-то метода
вне структуры. То есть, хотя я хочу написать что-то наподобие такого.
Get x.
Return x.
Вот здесь в написании this тоже нет
необходимости. Почему?
Потому что здесь вы
говорите компилятору, что я хочу реализовать
метод get
у класса s.
Но так как это метод,
он работает с конкретным объектом, поэтому вот тут
он тоже сам, самостоятельно, без вашей помощи
подставит this
стрелочка x.
Есть одна ситуация,
при которой...
Такая абстрактная ситуация, при которой
this вам может помочь. Ну, например,
представьте себе вот здесь.
Допустим, я такой нехороший
и поступил таким образом.
Взял и сказал set x int x.
То есть, у меня
аргумент метода совпадает с полем класса.
Такое может быть.
Тогда, когда вы напишете вот так,
возникнет ошибка.
То есть, непонятно,
что такое x слева, что такое x справа.
Да?
Чтобы, в общем...
Короче, чтобы убрать вот такие неоднозначности,
вы можете использовать this.
Но как бы...
Это единственный способ,
единственное место, в котором вам
нужно использовать this сейчас.
А во-вторых, оно легко фиксится тем, что называете аргументы нормально,
а не так, чтобы они совпадали с полями.
Короче, в написании this стрелочка x
нет никакой необходимости.
Точнее, она есть, но вам рано о ней знать еще.
Еще вопросы?
Так, ну и про это я, конечно,
сказал. Да, обращение к полям методам
не явно происходит через this.
Да, и еще важный момент. Какой тип имеет this?
This имеет тип либо указатель на класс,
либо указатель на константный класс.
Вот.
То есть, если вы вызываете...
Точнее, если вы обращаетесь к this
вне константном методе,
то this у вас, естественно, имеет тип указатель
на объект.
Если вы обращаетесь к this
в константном методе, то this у вас имеет
тип указатель на константу.
Но, собственно, по этой причине
вам нельзя
изменять поля класса.
Почему? Потому что, когда вы пишете
вот так, компилятор это читает дословно
таким образом.
Но так как this это указатель на константу,
то есть то, что лежит
под указатель на константу, изменить нельзя.
Поэтому вам компилятор говорит, что вот такое запрещено.
Ну, собственно, вот поэтому это работает.
Понятно?
Ну и давайте подведем
промежуточный итог
тому, что мы сделали за эту лекцию.
Мы познакомились
с понятием объектно-ориентированного
программирования и, по большому счету,
написали, там, путем
склеивания нескольких пунктов в сегодняшней лекции,
смогли написать вот такой класс стека.
Что мы делаем?
Мы описываем некоторый новый тип, который
называем stack. Что мы говорим?
Давайте рассмотрим публичную часть. Мы говорим, что с моим stack
можно делать следующие вещи. Его можно пронициализировать.
Значит, функция init, она создает
делать необходимые действия для того, чтобы stack
работал. Создаёт нужный буфер
и инициализирует размер stack
нулём.
Дальше свели метод finalize,
который мы должны вызвать
по завершению работы со stack,
который просто очищает память. То есть, над тем, чтобы
выделять память и очищать память, нам задумываться
не нужно, все необходимые действия делаются
в этих методах. Дальше мы говорим,
что в мой stack можно добавлять элемент,
из моего stack можно удалять элемент
с помощью pop и можно получать верхний
элемент. При этом верхний элемент
будет возвращаться по ссылке.
Ну, для того, чтобы я мог его
очень просто изменить.
Ну и дальше я завёл несколько константных методов,
например, метод top,
чтобы я мог узнавать
вершину stack для константного stack,
метод size, который возвращает мне размер
константного stack и метод empty,
который возвращает мне пуст мой stack или нет.
Дальше детали
реализации. В деталях реализации
я описывал, что у меня stack на самом деле состоит
из указательного массива,
из размера и плюс я завёл статическую
константу, которая говорит мне вместимость моего stack.
Вместимость stack равна сотне
в данной реализации.
Я завёл статический
метод capacity, который просто
берёт и возвращает какая вместимость у меня stack,
чтобы пользователь мог узнавать, сколько максимум элементов
он может добавить в мой stack.
Вот и всё.
Теперь stack я могу пользоваться с помощью вот этих
методов и при этом я вообще совершенно не задумываюсь
о том, как у меня stack реализован.
Смотрите, если закрыть правую часть этих методов,
скрыть всё, что написано в фигурных скобках,
можете ли вы в принципе как догадаться,
на чём реализован мой stack, на массиве
или на списке?
Ну нет, то есть нам не важно, нам важно, что stack
умеет добавлять себе элементы, умеет удалять
верхний элемент и умеет получать верхний элемент.
Всё. То есть мы полностью описали stack,
при этом совершенно абстрагируясь от
деталей реализации.
Понятно?
Вот в этом преимущество объекто-ориентированного подхода.
То есть мы вообще никак не вникаем в детали реализации, всё описано...
То есть мы описали айтип
в замкнутом виде с помощью
специальных действий, которые можно над ним совершать.
Ну и вот небольшое резюме.
Объектно-ориентированная парадигма
объектно-ориентированного программирования — это подход к
разработке программ, который позволяет описывать
вычисления в виде набора объектов
и их взаимодействий.
Ласса и структура отвечаются плюс-плюс за объектно-ориентированное
программирование.
Модификаторы доступа private и public позволяют вам
осуществить
сокрытие данных
и сокрытие деталей реализации.
Статические методы и константные методы тоже
обсудили.
Ну, на этом всё.
Продолжим после перерыва.
Небольшой дополнительный пункт,
который касается
классов, константности
и тому подобное,
связан с обсуждением
логической и физической константности.
Это вообще про что?
Давайте будем говорить следующую вещь.
Объект логически константный,
если с точки зрения пользователя
объект не меняет своё состояние.
Если пользователь вообще
никак не может понять, Сейчас
как-то объект или нет.
Если пользователь вызывает метод
top, ему возвращается единица,
а потом он ещё раз вызывает метод top,
он возвращается к методу 2,
то в этот момент объект не был
логически константным.
Потому что объект изменил своё состояние внутреннее.
Если я вызываю метод
top и его возвращает мне единицу,
ещё раз вызываю top и его возвращает мне единицу,
потом size тоже
то есть с моей точки зрения в стеке, допустим, все объекты те же самые, что и были, скажем, до этого.
В этот момент объект является логически константным. Но при этом в то же время объект может не быть физически константным.
Физическая константность — это более сильное требование, которое говорит о том, что внутри объекта вообще ни одна убитая информация не изменилась.
До этого мы рассматривали только логическую... Нет, до этого мы рассматривали физическую константность.
Какой может быть пример? Представьте себе, у вас есть класс, который работает с сетью активно, что-то скачивает с интернета
или посылает какую-то информацию по сети какому-то другому пользователю и так далее.
И при этом он параллельно внутрь себя записывает какую-то информацию, то есть совершает логирование.
Что столько-то байт было отправлено, они успешно дошли, столько-то байт было принято, они успешно прочитано и так далее.
И вот вы пользуетесь таким классом, который посылает какую-то информацию и эту информацию принимает.
С вашей точки зрения вам вообще не нужно знать про эту логику логирования, то, что он там периодически что-то пишет.
В течение последнего часа ничего не было принято. Ваш интерес заключается только в том, что вы какие-то байты принимаете, какие-то байты отправляете.
А то, что там у него какая-то внутренняя, допустим, строка изменяется за счет того, что он там что-то пишет, вас не интересует.
Это ровно про то, что ваш объект логически константен. То есть те атрибуты, которыми вы обращаетесь, которыми вы работаете, они для вас неизменны.
Но при этом внутри себя объект как-то меняется. И давайте попробуем как-то научиться эти 7 моментов разделять.
Давайте еще один пример. Допустим у вас есть класс C, у которого есть какой-то внутренний счетчик, который просто берет и считает количество раз, которые вы вызвали, определенный метод, например, Get 0.
Ну, ну просто для отладки. Вы просто считаете, сколько раз каждый метод был вызван. И потом смотрите что этот метод был вызван столько-то раз, этот метод был вызван сколько-то раз,
и допустим вы понимаете, что этот метод вызывается много раз, поэтому нужно его оптимизировать. Этот метод почти не вызывается, поэтому можно пока начинать его забить.
С точки зрения пользователя он объявляет константный объект c и пытается вызвать get 0,
при этом он получает ошибку компиляции, ведь get 0 не объявлен как константный,
при этом он не может быть константным. Потому что он что-то изменяет.
Но пользователю в принципе всё равно, что он что-то изменяет.
Со его точки зрения объект константный он считает it не то, rainbow и всё, что находится константным объектом,
это получить 0.
что если от объекта просто хотите получить 0,
он не сохраняет свою константность.
Согласитесь, странно.
Логика с физикой тут не сходится.
Как сказать компилятору, что данный объект
является логически константным?
И что на самом деле этот метод можно вызывать
для константных объектов?
Для этого есть специальное ключевое слово,
ключевое слово mutable.
Вот mutable дословно говорит следующее,
что данное поле
можно изменять
в константных методах.
Грубо говоря, вы говорите,
что данное поле не влияет
на логическую константность объектов.
То есть то, что это поле изменяется,
вообще никак не влияет на то, что объект константный,
с логической точки зрения.
Теперь вы можете сделать следующую вещь.
Вы объявили поле Counter константным,
и теперь вы можете сделать
GetZero тоже константным.
И теперь даже несмотря на то,
что это поле,
из-за того, что это поле объявлено как mutable,
его изменять можно.
Теперь я могу GetZero вызывать
для константных объектов,
даже несмотря на то, что какое-то поле там меняется.
В данном случае,
когда я написал ключевое слово mutable,
у меня объект перешел в состояние физически константин
в состояние логически константин.
То есть с точки зрения логики он константный.
С точки зрения внутреннего устройства
он константный свой не сохраняет.
Ну и давайте рассмотрим
небольшой пример,
как работают
mutable, константные поля
и константные методы.
Вот у меня есть структура,
у которой есть публичное поле x,
публичное константо y
и публичное mutable поле z.
Ну и есть, собственно, метод f,
который пытается изменить x, y и z.
И есть константный метод g,
который пытается изменить x, y и z.
В методе f
все ли будет корректно работать?
Все ли три строки будут
корректно работать?
Какие строки не будут работать?
Да, y менять нельзя.
Почему?
Потому что y, да, это константа.
Константа менять нельзя.
x, естественно, менять можно, z менять можно.
Теперь у меня g константный.
Какие строки у меня запрещены?
Ну, понятное дело, y, как и раньше,
запрещен, так как это константа.
x нельзя.
А z можно менять?
z можно, да.
Я написал специальное слово.
Я подписал специальное разрешение
у компилятора, что данное поле
менять можно. Называется mutable.
Mutable поля в константных моментах
изменить можно.
Соответственно, тут единственная строка,
которая работает, это последняя z равно 2.
Так, ну и
давайте посмотрим направо.
Я создал
константный объект s и пытаюсь
изменить x, y и z.
Ну, давайте сразу скажем, что y нельзя,
потому что y это константное поле.
Могу ли я изменить x?
Могу я изменить x?
У меня объект sc это константный объект.
Да, поэтому x менять нельзя.
То есть не потому что x константный,
а потому что сам объект, в котором принадлежит x,
он константный. Могу ли я менять z?
z могу менять,
потому что z объявлено
как mutable. Mutable это специальное поле,
которое для константных объектов менять можно.
То есть из константных методов и для константных
объектов такие поля менять можно.
Могу ли я вызвать
функцию f?
Вот здесь.
Да, f не объявлено как
константное. То есть у константных
объектов можно
вызывать только константные методы.
Поэтому тут нельзя.
Могу ли я вызвать метод g?
Да.
Да, почему?
Потому что у меня есть
константный метод g.
Ну, и если я вызваю для не константного объекта fiy g,
это будет работать?
и мне с refers, чтобы не о fertility х работать, потому что f
у меня не объявлен как constante, я вызываю его от неконстантного объекта.
Вот, ну и g тоже вызывается, ну вызывается при этом неконстантная версия.
Ну то же по понятным причинам.
S у меня не константный объект и при этом у меня есть перегрузка,
у меня есть g как для константного метода, как и для неконстантного метода.
В данном случае вызывается неконстантный, потому что я вызываю его
для неконстантных объектов.
пример. Так, ну все, на этом закончим с первой презентацией и перейдем к следующей теме,
которая называется шаблоны классов. Мы на самом базовом уровне, на первой половине,
познакомились с классами, как с ними работать и так далее. И на прошлой лекции, неделю назад,
мы говорили про шаблонные функции. И вот, собственно, для классов тоже существуют шаблоны, то есть
классы тоже можно делать шаблонами. Ну и смысл, я думаю, тоже понятен. Вот, смотрите, вот мы
буквально недавно написали stack, который работал с int. Но согласитесь, что stack может работать не
только с int, но и вообще, в принципе, с любыми данными. То есть, может создать stack, который хранит
даблы, может создать stack, который хранит були и так далее. Если вы хотите создать stack, который
на текущем уровне развития, если мы хотим создать stack, который работает только с int,
мы можем написать stack int. Если нам в какое-нибудь время понадобится stack, который работает с даблами,
ну мы пишем отдельный класс, который работает, stack, который работает с даблами, ну и так далее.
Ну и проблема, я думаю, уже понятна. Да? То есть, ну какой смысл писать для каждого отдельного
типа свой stack, если реализации, ну по большому счету, отличаться не будут. Поэтому работает
практически такой шаблонный синтаксис, как и для шаблонов функций. Что мы делаем? Ну, как и раньше,
мы пишем преамбулу template класс T, то есть мы говорим, что теперь, что вот с данной строчки сейчас будет
идти шаблон template. И дальше в треугольных скопах мы указываем, каким типом мы параметризуем наш
класс. В данном случае мы говорим, что будет, что наш класс параметризован одним типом шаблоном,
и это тип T. Мы так называем его. И дальше мы пишем обычную реализацию класса, но просто вместо
конкретных типов мы подставляем тип T. Ну, помните, да? То есть, то же самое, что и для функций.
То есть, теперь нам нужно создать не массив интов, а массив элементов T. У нас push теперь принимает
не int, а принимает произвольное значение T и так далее. Ну, при этом size, то есть вне зависимости
какие элементы содержатся в стэке, у меня size всегда возвращают либо int, либо size t.
Ну, и теперь я могу создавать стэки, которые содержат различные элементы. Например, могу
вот так создать стек, который содержит int. Вот так могу создать стек, который содержит phenix.
Соответственно, могу сделать push в стэке, который содержит int. Вот так могу сделать push в стек,
который содержит даблы. Ну и при этом, так как у меня push объявлен как метод, который принимает тип t,
ну здесь у меня реально будет добавлен элемент единица, тут у меня реально будет добавлен элемент 1.0.
Ну, литерал типа double. Что тут важно понимать? Точно так же, как и для шаблонов функций,
когда мы говорили, что у нас один шаблон функции инстанцирован int, а другой инстанцирован
с помощью дабла, мы говорили, что это абсолютно разные функции, так как внутри них, по сути,
описан различный код. Вот для шаблонных классов тоже самое. Stack int и stack double это абсолютно разные
типы, которые никак не связаны. Понятно? То есть можно считать, что вы написали вот такой код,
вы отдельно создали stack int и отдельно создали stack double. Просто это сделали не вы, а за вас это
сделан компилятор. То есть компилятор отдельно поставил для вас int и отдельно поставил для вас
double. То есть грубо говоря, нельзя сделать stack int равно stack double, то есть нельзя один stack
присвоить другому. Просто потому, что это несовместимые типы, они абсолютно разные.
С точки зрения компилятора они вообще никак не связаны. Это как если бы вы объявили два разных
класса. Отлично. В отличие от обычных классов, их можно объявлять только в области видимости
пространства имен либо внутри другого класса. То есть мы помним, что структуры на самом деле можно
объявлять внутри других функций. То есть вы внутри функций можете написать структ и
объявить структуру. Тоже самое для классов- вы можете взять класс и написать его внутри
функций в локальной области видимости. Шаблоны классов можно объявлять только в глобальной
области видимости, либо в пространстве видимости-какого-то пространства имен. Внутри
функций шаблоны классов объявлять нельзя. Дальше тип шаблонового параметра в отличии от функций
нужно указывать явно, то есть мы помним, что если у нас была какая-то шаблонная функция,
то у меня тип T выводится автоматически. То есть компилятор видит, что 0 имеет тип int,
и поэтому вместо типа T подставляется нужный мне тип, то есть int.
В случае шаблонов классов, у меня нет никакой возможности,
то есть, в принципе, у меня нет никакой возможности выводить тип int.
В случае шаблонов классов у меня нет никакой возможности,
то есть, у компилятора нет возможности вывести нужный вам тип,
потому что это не функция, у классов нет аргументов, грубо говоря.
Вы создаете класс и дальше пользуетесь его методами.
Но при этом понять, какой шаблонный тип нужно подставлять,
компилятор должен именно в момент создания объекта вашего класса.
Поэтому здесь нужно указывать явно тип, который вам нужен.
Правда, это было верно до C++17. В C++17 про конструктор мы поговорим в следующий раз уже.
Но если по конструктору теоретически возможно вывести ваши типы,
то необходимый тип будет выведен.
Давайте в общем случае считать, что тип для классов нужно всегда указывать,
и нет никаких исключений.
Еще важный момент, шаблоны классов, как и любые другие шаблоны, инстанцируются лениво.
Что это значит? Это значит, что если вы этот шаблон никак не используете,
то это значит, что у вас ни одного класса в итоге создана не будет.
В данном случае у вас есть структура S, и вы создали структуру S только от int.
То есть вы инстанцировали только ее int.
Никаких других структур S у вас в программе в принципе не существует.
Понятно, да? То есть у вас S double, S float и так далее не создаются.
Более того, методы шаблонного класса тоже инстанцируются лениво.
То есть если вы создали объект шаблонного класса от int
и вызвали метод f, и ни разу не вызывали метод g,
то можно считать, что метода g в вашем классе не существует.
Он просто-напросто не будет инстанцироваться.
То есть кода для функции g, для метода g сгенерирована не будет.
То есть сами классы инстанцируются лениво, и плюс их методы тоже инстанцируются лениво.
Если вы ни один из методов не вызвали, то ни одного метода вашего класса просто-напросто нет.
Ну и тоже понятно, это сделано для того, чтобы рационально использовать ваше время компиляцию.
То есть согласитесь, если у вас есть класс, который шаблонный,
и вы создаете такой шаблонный класс, во-первых, с кучей параметров,
и для каждого из этих параметров нужно создать все методы, но это долго.
Поэтому компилятор поступает в следующем образом.
Он смотрит, во-первых, с какими типами вы создаете ваши классы,
и какие методы там вызываете. Вот только эти методы он создает.
Все, остальные просто-напросто игнорируются.
Да.
Ну, смотрите, очень просто.
Тут очень просто. Если вы не хотите, чтобы инстанцировал G, вы просто-напросто не вызываете G.
То есть если вы хотите, чтобы для дабла не инстанцировался G,
то вы делаете дабл и вызываете SG. Все очень просто.
Тут есть другой вопрос.
А что, если вы хотите, чтобы, скажем, S от int и S от дабла работало разным образом, например?
То есть вы хотите, чтобы, например, функция f для int выводила котики,
функция f для дабла выводила собачки, ну вот как-то так.
Такое можно сделать. И это называется специализация шаблонов.
Ровно так, как у нас было для шаблонов функций,
мы помним, что шаблоны функций можно специализировать.
То есть помните, мы для комплексного числа писали специализацию функции abs.
То есть взятие модуля для обычного числа это просто сравнение с нулем, плюс вывод x или минус x.
А специализация для комплексного числа, она выводила корень квадратный из суммы квадратов действительно имнимой частей.
Вот шаблоны классов тоже можно специализировать.
Но, на самом деле, для шаблонов классов это имеет гораздо больший смысл.
Ну, смотрите, например, какой.
Вот представьте себе, что я хочу написать класс, который выдает мне ответ.
Является ли тип, который я передал int или нет.
Я тогда могу написать следующим образом.
Я пишу общий шаблон вот таким образом.
То есть я говорю, что template класс T, структура из int и создаю там статическое константное polyvalue, которое false.
Ну, понятно дело.
В общем случае, тип T у меня не является int.
А теперь я пишу специализацию.
Полная специализация, вы помните, пишется вот так.
Template и дальше пустые треугольные скобки.
Если я писал template и пустые треугольные скобки, значит сейчас идет специализация.
Дальше я пишу структ из int и дальше указываю тип, который я специализирую.
То есть в данном случае я говорю, что структура из int, точнее шаблонная структура из int,
для int должна вести себя другим образом.
Каким? А вот таким.
Собственно, у нее value в статическом поле должно быть равно true.
И теперь, если я сделаю следующую вещь.
Если я спрошу из int, скажем, double и спрошу value, то мне вернется false.
Точнее value будет иметь значение false.
Если я спрошу из int value, то у меня будет true.
Такие примеры на самом деле не интересны.
У вас наверное возникают вопросы, зачем это нужно.
Казалось бы, если я тут указываю тип, я понимаю, что у меня int, а что у меня не int.
Давайте я приведу пример, когда вы не понимаете, int у вас или не int.
Значит, пример такой.
Давайте я заведу шаблонную функцию.
Template, class t, void f, tx.
Тип t, это int или не int?
Вот вы и попали.
В шаблонной функции непонятно, тип t является int или нет.
Когда вы пишете шаблонную функцию, вы не знаете ничего конкретного об этом типе.
А что если я хочу, в зависимости от того, что мне передали int или не int,
я хочу вывести то или иное сообщение.
Как это теперь можно сделать?
С помощью данного класса можно поступить следующим образом.
Я пишу, если из int t value, то cout int.
Ну а иначе cout not int.
Ну, понятно, делать пример игрушечный, но, в принципе, на практике возникает ситуация,
в которой вам нужна зависимость от того, какой тип вам передали, действовать так или иначе.
Понятно, да?
Нет, проблема в том, что если вы пишете специализацию, то нужно все писать полностью.
Здесь это указано, что на самом деле шаблоны специализации никак не связаны.
Если вы пишете специализацию, то вы обязаны написать класс заново.
Вы сдаете специальное поведение, и при этом из общего шаблона ничего браться не будет.
Например, вы можете написать абсолютно другую реализацию из int для константного указателя на bool.
Не знаю почему, но вот решили так.
Вы написали структуру из int, специализацию, которая действует следующим образом.
Если она инстанцирована с помощью константного указателя на bool,
у нее нет статического поля value, но при этом есть метод print, который печатает no.
Еще раз не понял.
Для шаблонов тоже можно так сделать.
Давайте в общем случае напишу, как у вас есть шаблонная структура,
template class t.
У вас есть структура s, внутри которой есть метод f.
Как написать реализацию метода f вне класса?
Делается следующим образом.
Вы также пишете template class t.
Ну и дальше, как обычно, пишете void s от t, 2.2.f.
И дальше пишете реализацию.
Просто полное имя функции.
Теперь вам нужно написать preamble template, чтобы можно было ввести такое имя как t.
Чтобы комплятор понимал, что t – это имя шаблонного параметра.
Дальше вы пишете полное имя функции.
Это s с параметром t, 2.2.f.
Здесь уже понятно, что вы хотите.
Вы хотите реализовать функцию f, которая находится в специализации или не в специализации.
Потому что когда подставляется тип t, то уже понятно, что вы делаете.
Для специализации или не для специализации.
Вернемся к этому примеру.
В общем, заметьте, что у меня есть общий шаблон, который работает для всех типов.
Есть специализация для int, есть специализация для константов и указателей на bool.
И при этом заметьте, что последняя специализация кардинально отличается от первых двух.
В ней нет статического поля value, и в ней есть метод print, которого нет в других методах.
То есть специализация может кардинально отличаться от общего шаблона.
То есть нет никакого правила языка, который бы вас заставлял писать специализацию точно такой же, как и общий шаблон.
Специализация отдельно, общий шаблон отдельно.
Вот классический пример использования.
Я написал здесь, чтобы проверить какие-то свойства типов.
Давайте еще. Нет, не еще, а вот еще важный момент.
Для шаблонных классов, помимо полной специализации, существует понятие частичной специализации.
Что такое частичная специализация?
Частичная специализация позволяет вам указать специальное поведение не для конкретного типа.
Вот как здесь, мы указали, как должен вести себя общий шаблон
и как должна себя вести структура из int в случае int.
То есть мы указали конкретный тип int и указали, как ему нужно действовать в этом случае.
В случае частичной специализации мы указываем не конкретные тип или не конкретные типы,
а указываем некоторое семейство типов.
Вот, например, еще одно классическое использование специализации шаблонов классов.
То есть мы хотим понять, является ли переданный тип указателем или нет.
Как мы это делаем? Мы пишем общий шаблон.
template class t struct is pointer.
Дальше мы заводим статическую констант node bool, которая равна false.
В общем случае у меня t не является указателем.
В общем случае не является указателем.
Ну и для примера я еще завел статическую функцию из endpoint,
который возвращает, является ли t указателем на int.
Естественно, не является.
А теперь я завожу специализацию, которая работает для всех указателей.
Я это делаю следующим образом.
Смотрите, во-первых, я пишу class t.
Что уже говорит, что это не полная специализация.
В случае полной специализации у меня треугольные скобки пустые.
И дальше я указываю вот здесь уточненный тип.
Понятно?
То есть я указываю, что данная специализация должна работать для всех типов,
которые представимы в виде t звездочка.
То есть для всех указателей.
Ну и дальше, что я говорю.
Если мне передали указатель, то я должен вернуть true и isn't pointer в случае false.
То есть если мне передали указатель, то в общем случае он не является указателем на int.
Я написал частичную специализацию.
Вот здесь?
Потому что class t именует тип.
А здесь я его уточняю.
То есть я не могу здесь написать t звездочка.
Тут у меня должно быть имя.
Имя не может содержать звездочку.
На самом деле тут есть проблема небольшая в данной реализации.
Может кто-нибудь понимает какая проблема?
Почему это на самом деле неправильная реализация?
Почему на самом деле...
Ну так конечно можно проверять на указатель,
но вот для некоторых указателей вот эта штука работать не будет.
Для каких?
Что?
Совсем не совсем понятно.
Указательный констант или константный указатель?
Короче, если вы в isIntPointer
передадите int звездочка конст,
то выберется какой шаблон?
Вот этот шаблон общий.
Понятно почему?
Потому что вот этот тип int звездочка конст
непредставим в виде t звездочка.
Что мне нужно поставить вместо t,
чтобы t звездочка был равен int звездочка конст?
Решите ребус.
Нет, вместо... вот смотрите, вот ребус вам.
Уравнение на языке C++.
t звездочка равно int звездочка конст.
Найти t.
Ответ.
Короче, нет такого t,
который бы давал int звездочка конст.
Поэтому тут еще нужно дополнительно
прописать специализацию,
которая принимает константные указатели.
Это детали уже.
А если я передам, скажем,
вот такой пример, если я передам конст
int звездочка,
что у меня выберется?
Общий шаблон или специализация?
Нет, давайте про третий,
пока забуду. Нет, третьим выбран не будет.
Почему второе?
Да, потому что если я вместо t
подставлю конст int,
то у меня частичная специализация,
вот эта вторая, будет подходить лучше,
чем первая.
Опять же, по принципу, наименьше подстановки.
В первом случае мне нужно подставить
констант звездочка целиком,
а в втором случае только конст инт.
Такой незначительный момент,
хорошо обсудили.
Это полная специализация.
Помимо частичной специализации
я могу одновременно написать и полную специализацию.
То есть я могу писать как частичные,
так и полную специализацию.
Но в данном случае я написал полную специализацию
для int звездочки, и тогда,
понятно дело, что статическое поле
у меня должно содержать true,
и статический метод должен возвращать true,
потому что int звездочка — это указатель на int.
Ну и область применения
примерно такая же, как и здесь.
То есть как было указано вот здесь.
То есть если я работаю внутри
шаблонной функции, я не понимаю,
то есть я хочу понять что-то про тип,
то я могу вот использовать этот isPointer
и понять, что мне передали указатель или не указатель.
Ну и в зависимости от этого использовать там
разные реализации.
Ну и пример как это все работает.
Если я инстанцирую isPointer от int,
то у меня value — это false,
и isIntPointer тоже false.
Ну понятно, потому что вызывается
общий шаблон.
Если вызываю isIntPointer от char звездочка,
то у меня value равно 1,
то есть char звездочка — это указатель.
А если я спрашиваю верно ли,
что это указатель на int, то возвращается 0.
Ну и в последнем случае
у меня работает полная специализация,
то есть для value возвращается true,
для isIntPointer возвращается тоже true.
Все нормально.
С этим разбрались?
Понятно, как работает частичная специализация?
И чем она отличается от полной?
Частичная специализация уточняет
для некоторого множества типов,
а полная специализация уточняет только для конкретного типа.
Ну и еще один пример.
На самом деле тип можно уточнять...
Короче, вот эта штука
тоже является частичной специализацией.
Почему? Потому что я указал...
Если у меня есть шаблон, который принимает
два аргумента, и я уточнил только один из них,
то это тоже частичная специализация.
Полная специализация была бы,
если бы я уточнил и первый тип,
и второй тип.
Окей?
Вот.
Так, ну и давайте попробуем...
Вот эта пусть единица, это два, это три.
Вот. Скажем...
Давайте для каждой строки, вот здесь,
поймем, какой шаблон
используется, общий,
второй или третий.
Вот для первой строки, если я создаю s
с параметрами bool и bool.
Да, общий шаблон, потому что
ни второй, ни третий не подходят.
То есть у меня второй аргумент не int, первый аргумент не float.
Если я вызываю bool int,
что у меня?
Да, второй, потому что второй лучше всего
подходит.
Понятно, что подходит и первый, но по принципу
наименьшего действия мы выбираем только
второй.
В третьем...
В третьем вызывается
третий, а в четвертом...
Уже обсуждение какое-то пошло.
Кто за второй вариант?
Кто за третий?
А кто за ошибка
эмпиляции?
Победа.
Действительно, будет ошибка эмпиляции. Почему?
Ну, просто потому, что
эмпилятор... ну, смотрите,
и вот этот тип, и вот этот тип они одинаково точные.
Ну, то есть
когда выбирается частичная
специализация, происходит так называемая
частичное упорядочение специализаций.
То есть, эмпилилатор смотрит
ну, грубо говоря, верно лишь,
что
параметры одного шаблона
включены в параметру другого шаблона,
то есть, просто есть множество параметров для первого
шаблона, есть множство параметров для второго шаблона.
И если
множество этих параметров включено
в множество параметров второго шаблона,вот эта
штука считается более точной специализацией, чем вторая.
Да?
А здесь нельзя сказать, что
Набор параметров tint вложен в множество параметров float t.
Ну и наоборот, тоже неверно.
В смысле вот эту специализацию?
Да, в этом случае вам достучаться ни до какой специализации невозможно.
К сожалению. Что?
А если вы вызовете sint float, то будут первые шаблоны, потому что ни второй ни треть не подходят.
Окей, да, вот это не работает.
Ну и поговорим коротко про частичную специализацию шаблонов функций.
Частичной специализации шаблонов функций не существует.
Поэтому про частичную специализацию мы говорим сегодня, а не на прошлой лекции.
Шаблоны функций можно специализировать только полностью.
Частично нельзя.
Еще поговорим про шаблоны.
Шаблонный параметр шаблонов.
Что мы знаем про шаблонные параметры?
На самом деле мы знаем две вещи.
Первая, мы знаем, что в качестве шаблонных параметров может выступать какой-то тип.
Мы можем параметризовать наши шаблонные классы или шаблонные функции каким-то типом.
Ну, например, sint, sdouble.
Ну и в прошлый раз мы говорили, что там можно писать также целые числа.
Ну, если мы тут в качестве template указали, например, int x.
Что еще?
Еще в качестве шаблонных параметров могут выступать внезапно другие шаблоны.
Той есть.
Я пишу класс stack шаблонный, который параметризован типом t.
Ну смотрите, класс stack может быть реализован как минимум двумя способами.
Первый с помощью связанного списка, а второй способ с помощью массива.
Ну и мне как-то лень, ну скажем, если я написал реализацию stack на массиве,
мне как-то лень ее перебисывать на реализацию на списке.
Я хочу, чтобы это все происходило как-то автоматически.
И вот чтобы это работало, я делаю следующий трюк.
Я говорю, что stack у меня параметризован двумя шаблонными параметрами.
Первый параметр — это тип.
То есть тип, который хранится внутри stack.
А второй параметр — это шаблон.
То есть шаблонный параметр шаблона пишется следующим образом.
Ну пишется, во-первых, template.
Дальше пишется, собственно, параметр шаблона шаблона.
Ну собственно, вот тот шаблонный класс, который я буду всегда подставлять,
сколько параметров он имеет.
Окей?
Вот здесь давайте посмотрим, например.
Я хочу, например, в качестве второго аргумента, я хочу передать array.
Сколько шаблонных параметров имеет array?
Ну один, вот он.
Поэтому здесь я указываю один шаблонный параметр.
Если было два, то я должен был написать следующую вещь.
template.class.class
И дальше там class.container.
Все, то есть я объявляю, что следующий шаблонный параметр у меня сам по себе является шаблоном,
который принимает один тип.
И дальше пишу, собственно, как-то его называю.
class.container.
То есть, грубо говоря, для stack что я говорю?
Я говорю, что stack содержит элементы типа T и реализован с помощью контейнера.
Да, контейнер.
Контейнер имеет следующий вид.
Контейнер является шаблоном, который принимает один аргумент.
Контейнер является шаблоном template, который принимает один аргумент.
Вот он в треугольной скобке указан, класс.
Нет, в том-то и дело, что нет.
Array сам по себе, само имя array, это и есть шаблон.
Да, вот это важный момент.
Смотрите, если бы я сделал вот таким образом stack int и скажем array от int,
вот это бы не скомпилировалось.
Почему?
Потому что array от int – это не шаблон.
Array от int – это уже конкретный тип.
Чтобы работало так, мне нужно было здесь в качестве параметра указать как обычно class.container.
Чем мне не нравится этот подход?
Кстати, этот подход реализован в стандартной библиотеке.
В стандартной библиотеке есть stack, который можно параметризовать типом
и стандартной библиотеке, который можно параметризовать контейнером.
Но об этом мы говорим ближе к концу курса.
То есть там реализовано вот так.
Но это на самом деле неудобно.
Почему?
Потому что вам нужно как минимум два раза указать тип.
И здесь, и здесь.
Но чтобы так не делать, я предлагаю ввести шаблоны параметром шаблона.
То есть сказать, что stack у меня параметризован int типом хранимых элементов
и плюс другой шаблон – array.
И как теперь этим добром пользоваться?
Это очень просто.
Я просто беру и говорю, что буфер у меня является контейнером от t.
То есть элементы хранятся в буфере, а сам буфер является контейнером от типа t.
То есть на самом деле вот здесь вместо контейнера подставляется array от t.
Все.
Если я хочу использовать stack на связанном списке, я просто пишу stack int list.
stack list.
Ну при этом понятно, что я должен шаблонный класс list тоже как-то реализовать связанный список.
Ну это просто пример применения.
На самом деле шаблонные параметры шаблонов используются крайне редко.
Это просто как бы демонстрация, что вот так можно делать, если вдруг вам нужно.
Окей?
Так, ну все.
Давайте сделаем перерыв и потом продолжим.
Вообще в прошлом году до этого момента мы не доходили.
В этом году мы идем прям очень быстро.
Вам как? Комфортно? Нормально? Успеваете? Все?
Окей.
Ну давайте чтобы...
Что сейчас будет происходить?
Ну чтобы наш разговор про шаблоны был более-менее полным, давайте поговорим, что еще может быть шаблонным.
И на этом закончим.
На самом деле тема шаблонов, она очень большая.
То есть то, что мы с вами проговорили, это буквально вершина айсберга.
На самом деле шаблоны это вот прям язык в языке.
То есть на шаблонах можно сделать кучу всего, кучу всякой магии и так далее.
Но в силу нехватку времени мы, возможно, этим займемся только ближе к концу курса или вообще нет.
Но в качестве дополнительной литературы, если прям совсем интересный, я рекомендую книгу...
Как называется?
Темплотс.
Вот так называется и автор, если я правильно напишу, то Вандервурд.
Эту книгу стоит скачать, просмотреть хотя бы для того, чтобы ужаснуться, какого она размера.
То есть сколько всего можно про шаблоны написать и описать.
Но несмотря на то, что она толстая, там она устроена очень...
То есть она мне очень нравится тем, что она устроена в двух частях.
То есть у нее есть первая часть, буквально 10% в которой описываются все основные концепции с примерами и так далее.
То есть грубо говоря, просто базовая часть, которую мы изучаем здесь и даже чуть больше.
Остальная часть посвящена всей этой магии, как все устроено, как все работает и так далее.
В общем, уже продвинутая часть.
В качестве справки можно использовать эту книгу тоже, что касается шаблона.
Давайте пойдем дальше.
Что мы рассмотрели к текущему моменту?
Мы рассмотрели шаблоны функций и рассмотрели шаблоны классов.
Что еще может быть шаблоном?
Шаблоны могут быть переменные, начиная с C++14.
Какую проблему решают шаблоны переменных?
Вообще говоря, если вам нужно какое-то значение, то есть шаблонное, которое зависит от параметра шаблона.
Раньше C++14 использовались функцией.
И на прошлой лекции мы тоже использовали функцию для получения какого-то значения определенного типа.
Например, getZero.
GetZero у нас была функция шаблонная, которая возвращала 0 определенного типа.
GetZero от int возвращает нам int.
GetZero от obla возвращает нам double.
Мы написали специализацию для комплексного числа, которое возвращает комплексное число, которое является нулем.
Согласитесь, странно использовать функцию для получения какого-то значения.
Соответственно, в C++14 для удобства интерфейса ввели шаблонные переменные.
Синтаксис абсолютно такой же, как и для шаблонов классов и для шаблонов функций.
Вы пишете preamble и template класс T и дальше описываете объявление вашей переменной.
То есть вы говорите, что ваша переменная должна иметь тип T и иметь такое значение.
В частности, getZero это переменная, грубо говоря, шаблонная переменная, которая означает 0 для любого типа.
Шаблоны переменных можно специализировать как частично, так и полностью.
В частности, для комплексного числа 0 выглядит следующим образом.
Так как комплексное число это структура, которая состоит из двух полей.
Действительно не моя часть. Таким образом 0 нельзя определить.
При этом я пишу специализацию для комплексного числа, которая инициализирует его двумя нулями.
Теперь я ее переменную могу спокойно использовать в любых контекстах.
Например, могу ее вывести, cout, k, 0, например, от флота.
А могу присвоить ее в другие перемены, например, в x, в y и в z.
При этом в последней строке будет использована специализация, а не общий шаблон.
Ну и немного правил по работе шаблона переменных.
Шаблонная переменная может быть объявлена только в глобальной области видимости
или в области видимости пространства имен, на самом деле как и любой другой шаблон.
Правда это или нет? Нет, не совсем правда, шаблонные функции могут быть объявлены внутри классов.
В общем, шаблоны могут быть объявлены только в глобальной области видимости
или в некотором пространстве MIM. Внутри функций они объявлены быть не могут,
как и любые другие шаблоны. Шаблонная переменная, думаю, это понятно,
должна быть сразу определена, потому что во время инстанцирования
компилятор должен понимать, какое значение она имеет.
Шаблоны переменных, как и любые другие шаблоны, инстанцируются лениво,
то есть если вы не создали ни одной переменной с определенным типом,
то этих переменных нет. Вот сейчас вот здесь k0. Вы выявили k0 от int,
от doubly, от комплексного числа. Ну и еще от плата мы тут написали.
То есть k0 от bool, от int указателей и так далее, их нет. То есть вот есть
четыре вот этих переменных. Да, ну и шаблоны переменных могут быть
полностью или частично специализированы. По сути все. Есть вопросы?
В смысле вы хотите, грубо говоря, k0 от int указатель?
Ну вполне возможно. То есть вы можете частично специализировать
следующим образом. Давайте пропишем частичную специализацию для этих,
для всех указателей. Вы пишете const t указатель k0 равно...
Так, нет, это видимо не так пишется сейчас. Скорее всего вот так.
Т-звездочка, вот. То есть вот тут явно указываете уточненный тип.
И дальше равно nullptr.
Ну давайте еще раз в время есть, скажу какое основное применение
шаблонов переменных, ну по крайней мере в стандартной библиотеке.
Ну вот помните, мы писали из int, структуру из int шаблонную,
которая проверяет, является ли тип int или не является.
Ну согласитесь, вот писать вот так, из int, int, value, это долго.
Так вот, шаблоны переменных призваны вот это все сократить.
В стандартной библиотеке есть, грубо говоря, если мы писали шаблоны переменных
для этой штуки, мы написали следующим образом. Из int v от int. И все.
То есть мы бы написали просто шаблонную переменную, и тогда нам не нужно было
с этими, со статическими полями и так далее. То есть мы бы написали просто,
ну давайте напишем, ладно.
Template class t const bool из int равно false.
Ну в общем случае переменная из int равна false.
Теперь пишем специализацию полную.
Template, пустые треугольные скобки, const bool.
И дальше пишем из int специально для int.
И тут пишем равно true.
Все, теперь когда вы просите из int от int, это true.
Если вы просите из int от ланга какого-нибудь, то у вас false.
Более лаконичный синтаксис.
Это основное применение.
Ну и что еще может быть шаблоном?
Шаблоны могут быть псевдонимы типов.
Тут, кстати, можно подробно поговорить, потому что это важно.
На самом деле, вот этими четырьмя вариантами шаблоны ограничиваются.
Шаблоны функций, шаблоны классов, шаблоны переменных и шаблоны и псевдонимы типов.
Это про что? Ну давайте издалека начнем.
Про type-def, я думаю, вы знаете, да?
С помощью type-def можно создать псевдоним типа.
Ну скажем, писать long-long – это долго.
Ну и на самом деле неправильно, у нас с кодстайлом запрещен long-long.
Ну допустим, вам нужен long-long, и вам лень его постоянно писать таким длинным.
Тогда вы можете просто-напросто взять и объявить псевдоним для long-long l-l.
Пишете следующим образом. Вы пишете type-def.
Дальше пишете тип, который вам нужно зап псевдонимизировать.
И дальше пишете непосредственно имя псевдонима.
А это пишется внутри?
Это пишется, это может писать и внутри, это может писать везде.
И вне мейна, и в глобальном области видимости, и внутри класса, и так далее.
Наверное, до первого использования.
Ну как и любая другая сущность, до первого использования она должна быть объявлена.
Вот, тогда если вы объявите long-long x, то переменная x будет иметь тип long-long.
Вы можете объять переменную y типа long-long, но уже с помощью псевдонима l-l.
То есть l-l – абсолютный эквивалент long-long.
С помощью псевдонима.
Что?
Ну естественно, да, потому что выбили какое-то имя.
Это может быть использовано только для одной сущности.
Что?
Нет, нет, нет.
Если вы назвали, как-то обозвали l-l чем-то, то вот.
Короче, нельзя, нельзя.
Ну да, у нас код style запрещается сполить long-long.
Короче, используйте типы сфиксированного код стайла.
Ну да, у нас код стайла запрещается сполить long-long.
Короче, используйте типы сфиксированной точностью.
Но это в Google код стайле даже прописано.
То есть int32t, int64t и так далее.
То есть если вам нужен какой-то конкретный тип конкретной ширины,
то прописывайте, сколько bit вам нужно.
Значит, небольшой интересный факт, про который, возможно, вы не знали,
но type-def можно писать где угодно до имени псевдонима.
То есть представьте себе, что я хочу затайп-дефать unsigned long-long.
То есть unsigned long-long писать долго, я хочу, чтобы это было ull.
Так вот, type-def можно писать не только в начале, но и здесь, и здесь, и здесь.
То есть в любом месте до ull вы можете писать type-def.
И это будет работать абсолютно эквивалентно.
Ну а type-def писать в конце нельзя.
Единственное место, где нельзя написать type-def, это в конце.
Да-да-да.
Во всех четырех случаях unsigned long-long.
Так, можно потише, пожалуйста?
Окей.
Ну и я потихоньку подбираюсь к тому, что type-def он не очень удобный.
Ну, во-первых, по этой причине.
Потому что type-def может находиться вообще в произвольном месте.
И понятно, что вряд ли вы ожидаете type-def где-то посередине между unsigned long-long.
То есть если вы прочитали unsigned long и там, короче, есть какой-то мем в сети,
что, типа, если у вас первая буква стоит в последнем нужном месте,
и вы как-то буквы перемешаете, то все равно можно прочитать текст.
Но тут то же самое. Вы как бы читаете, видите, что написана какая-то длинная хрень.
Вначале unsigned, в конце long. Наверное, unsigned long-long.
Type-def вы явно пропустите.
А на самом деле там кто-то имел в виду, что это псевдоним типа, а не переменная.
Вот это первая проблема.
Вторая проблема с тем, как type-def работает.
Вот смотрите, если я хочу объявить псевдоним для указателя,
то это выглядит следующим образом.
Вроде как терпимо. Я пишу type-def int указатель и пишу type.
Если я хочу написать type-def для массива, то все выглядит уже немного страннее.
Я пишу type-def int, и дальше после имени псевдонима я пишу размер массива.
Грубо говоря, я пишу так, как если бы я объявил переменную, но просто вначале пишу type-def.
Странно. То есть снова нужно искать, а где у меня находится имя типа.
Дальше. Если я хочу объявить псевдоним функции, ну псевдоним типа функции,
то снова я должен написать в функциональном стиле.
Я должен написать, что у меня функция возвращает.
Потом нужно написать имя псевдонима и что она принимает.
Еще не забыть вначале type-def написать.
Более того, type-def, то есть я могу написать несколько псевдонимов в одну строку.
Например, вот так. type-def int, int t, int ptr t, int 10 t и так далее.
То есть int t, нижнее подчеркнение t, это псевдоним для int.
Понятно? Вот этот.
Вот это, это псевдоним для указателя.
Почему? А потому что перед ним звездочка написана. Ну, круто.
А вот это, это псевдоним для массива интов размера 10.
Почему? Потому что где-то там вначале написан int, а вот здесь написан в квадратных скобках и 10.
А вот это внезапно, это псевдоним функции, которая принимает int и возвращает int.
Класс? Конечно нет, ну вообще ерунда какая-то.
Ну ладно.
Ну и да, в общем важный момент. type-def не создает нового типа,
а просто является псевдонимом для существующих.
То есть важно понимать, что type-def не является созданием нового типа.
То есть когда мы пишем структ или когда мы пишем класс, мы реально создаем новый тип.
type-def нового типа не создает, он просто делает некоторый псевдоним.
То есть грубо говоря компилятор во время припроцессинга просто все ваши type-def'ы берет,
ну короче он просто выкидывает и везде, где вы используете псевдонимы,
подставляет там int или что вы там хотели.
Внутри структуры тоже можно написать type-def. Да, мы об этом сейчас поговорим.
Ну и про что был вопрос несколько минут назад.
type-def, то есть если вы объявили псевдоним какого-то типа,
то он должен принадлежать только одному типу и только ему.
То есть нельзя написать, что int-t это int и int-t это long. Вот так нельзя.
Но при этом вы можете написать несколько type-def, которые не противоречат друг другу.
Например первые и вторые они не противоречат друг другу, поэтому вы можете написать их подряд.
Не знаю зачем вам это нужно, но вот вы можете.
Вы также нельзя писать вот так. То есть вы не можете переопределять уже существующие типы.
Вы не можете сказать, что float это теперь double.
Ну вот хотя бы тут разумно все.
Мы разобрались с тем, что type-def на самом деле не так хорош, как вы, возможно, о нем думали.
type-def на самом деле плохой вариант, если вы хотите завести псевдоним типа.
А какой вариант хороший? А хороший вариант завезли в C++11.
Это объявление с помощью using.
Если вы хотите объявить псевдоним какого-то типа, то вы должны писать следующее.
using имя псевдонима равно и тот тип, который вы хотите запсевдонимить.
Согласитесь, что этот синтактис гораздо более понятен.
Тут гораздо более явно видно, где псевдоним, а где тип, на который ссылается псевдоним.
Вы грубо говоря int t присваиваете int.
Здесь вы говорите, что псевдоним для int указателя – это int ptr t.
Псевдоним для массива – это int 10 at.
Псевдоним для функции – это func int to int.
Слева стоит имя псевдонима, а справа целиком пишется тип.
Без всяких приколов типа этого.
И что самое главное, синтактис для using задан более жестко.
TypeDef вы можете поставить где угодно.
Using вы можете поставить только в начале.
И при этом только одно объявление на строку.
На самом деле это ограничение, но это благо.
Теперь про то, про что вы спрашивали. Можно ли TypeDef и псевдоним изводить внутри структуры?
Там можно.
Например, я могу внутри структуры объявить псевдоним для int.
Я могу внутри структуры объявить псевдоним для lang.
И вот эти псевдонимы распространяются только на саму эту структуру.
Но что самое главное, эти типы члены теперь становятся доступны с помощью оператора разрешения области видимости.
Вот так.
Какое этому применение есть?
Давайте вернемся к стэку.
У вас есть стэк класс.
Есть философский вопрос. В чем нужно измерять size?
Как вы думаете, в чем нужно измерять размер стэка?
В int, в unsigned int, в long long, unsigned long long и так далее.
В принципе, все эти варианты более-менее разумны.
Можно использовать что угодно.
Но при этом пользователь не знает, когда вы пишете метод size,
пользователь не знает, что у вас возвращает size.
И чтобы сказать пользователю, в чем у вас измеряется size, обычно делают следующую вещь.
Обычно пишут using size type равно ну и допустим int.
То есть таким образом вы говорите, что у вас размер всегда измеряется в int.
Ну и теперь пользователь всегда может понять, а в чем измеряется у вас размер стэка.
Ну каким образом, например, он может взять и сказать stack 2.2.size type.
И объявить свою переменную вот таким образом.
То есть, грубо говоря, пользователь может захотеть создать переменную,
которая имеет такой же тип, которая возвращает метод size.
И вот таким образом он это может получить.
Более того, на псевдонимы внутри структуры классов распространяются модификаторы доступа.
То есть, смотрите, тут на самом деле это написано.
Смотрите, у меня псевдоним для ланга определен в приватной области.
И вот по этой причине последняя строка будет вызывать ошибку компиляции.
Почему? Потому что она находится в приватной области.
Вам запрещено получать доступ к этому псевдониму.
То есть, что бы не было написано в приватной области, вам к этому получать доступ просто нам запрещено.
И псевдонимов это тоже касается.
Ну и на самом деле самое главное преимущество использования псевдонимов в стиле using,
то есть не в стиле typedef, а в стиле using, заключается в том, что псевдонимы могут быть шаблонные.
Что это значит? Ну, смотрите, вот у меня есть шаблонный класс.
И я могу создать альтернативное имя для стека.
Ну, например, вот так.
То есть я пишу template класс T, и дальше пишу using.
Using stack alias равно stack T.
Это означает, что я сделал псевдоним шаблона для шаблона stack.
Теперь я могу создать stack либо обычным образом, то есть stack от nta,
а могу создать stack с помощью его псевдонима stack alias и дальше в треугольных скобках int.
То есть вот эти два объявления, они абсолютно эквивалентны.
То есть я просто завел альтернативное имя для шаблона.
Ну, опять же, ключевой вопрос, а зачем это надо?
Зачем мне, например, stack переименовывать?
Stack переименовывать, наверное, не имеет смысла.
Но это бывает полезно для каких-то длинных типов.
Ну, вот смотрите, самый классический пример.
Вот представьте, что вам нужен тройной stack, который содержит stack, который содержит stack, который содержит int.
Ну, для stack опять же это не имеет смысла.
Например, вы хотите трехмерный массив.
Ну что такое трехмерный массив?
Это массив, который содержит массивы, который содержит массивы.
Вот чтобы написать такой тип, вам нужно написать вот такую длинную штуку.
stack от stack'a от stack'a от t.
Вы можете поступить хитрее.
Вы можете создать псевдоним, создать stack3d,
и сказать, что stack 3D – это то же самое, что stack от stack'a от stack'a, и от типа t.
типа T. И теперь, чтобы создать вот этот трехмерный stack, вам достаточно просто
использовать этот псевдоним stack3d от int. И вот вместо stack3d будет
подставлен вот этот вот stack, stack, stack, и внутри вместо T поставится int, который
подставлен там. Понятно?
То есть шаблоны псевдонима здесь в следующем образом. Вы пишете, вот, какой
тип, чем вы параметризуете stack, точнее, чем вы параметризуете ваш псевдоним. И
дальше в правой части пишете, что нужно подставить вместо этого псевдонима, когда
будет подставлен конкретный T. В данном случае, я говорю, что у меня stack3d это
шаблонная штука, и когда я вместо, и когда я внутрь нее подставляю конкретный
тип T, это должно раскрываться вот в такое объявление, окей?
Ну вот.
Да, ну и, собственно, как я сказал, важное отличие using вот type-def
стоит в том, что using позволяет вам писать шаблонные псевдонимы, а type-def
не поддерживает такого синтаксис. То есть с помощью type-def шаблонные псевдонимы
вы никогда не создадите. Ну, по крайней мере, ну, никогда, ну, пока. Пока в стандарте такого нет.
Окей? Ну и последний момент. Шаблоны псевдонимов нельзя полностью или частично
специализировать. Ну, просто нельзя. На этом все. Вопросы?
Это, это выход, да. То есть можно создать класс, написать в нем полную или частичную
специализацию, а потом создать псевдоним на этот класс. Да, это выход. Ну, собственно,
это одна из причин, почему так не делают. Почему шаблоны псевдонимов не поддерживают
такую штуку. Еще вопросы? Тогда спасибо. До встречи на следующей неделе.
