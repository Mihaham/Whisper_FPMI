Отлично. Значит, начинаем лекцию и сегодня и на следующей неделе мы будем говорить про библиотеку
STL или про стандартную библиотеку C++, стандартную библиотеку шаблонов. Поговорим о том, что в ней
есть, для чего это можно применять, как это применять наиболее эффективно. Ну и рассмотрим
некоторые там особые приемы, которые связаны с использованием стандартной библиотеки. Значит,
ну понятно, что эту лекцию, например, можно было, наверное, привести там условно за полчаса. То есть
сказать, что вот, ну хорошо, вот есть контейнеры, есть условный вектор, есть рэй, есть мап, который
там представляет из себя бинарное дерево поиска, есть условно там unordered set, который представляет
из себя хэш таблиц. Ну вот так вот в обзорном ключе быстренько по всему пройтись и на этом
закончить. Но, к сожалению, так не получится. И вот по следующей причине. Ну, во-первых,
ну я приведу там пример небольшой из жизни. В общем, я пытался однажды это писать на некотором
другом языке программирования и обратился к своему знакому, который является там разработчиком на
этом языке. Вот и я как-то там у него потенциировался, как средствами этого языка, как средствами там
стандартной библиотеки этого языка можно сделать там ту или иную вещь наиболее эффективно. Вот, то
есть хотелось бы, чтобы там был как можно более эффективный код. Вот на что я получил ответ, что,
ну как бы, ну я не знаю, он говорит, я пользуюсь этим вот и как бы это делает то, что мне нужно. Вот.
В C++ такой подход он не особо принят. То есть если что-то, какой-то алгоритм или какой-то контейнер
делает то, что вам нужно, это на самом деле не значит, что это происходит наиболее эффективно.
Все-таки если вы пользуетесь C++, если вы все-таки пишете на C++ и так далее, то вопрос эффективности у
вас, ну скорее всего, стоят, наверное, в первую очередь. Потому что язык C++ в первую очередь
используется в тех местах, где критична какая-то производительность, там критично, ну да,
производительность, время работы и тому подобное. Вот. Поэтому важно знать не только там, что делают
те или иные контейнеры, те или иные алгоритмы, но и то, как они устроены, за какое время работают. Ну и
собственно, да, понимание внутреннего устройства на самом деле очень сильно помогает при разработке
программ. Ну, потому что если вы понимаете, когда все устроено внутри, то вы можете выбирать те
или иные стратегии использования того или иного контейнера, алгоритма и тому подобное. Вот. Поэтому
разговор будет, ну, понятное дело, мы поговорим там про саму библиотеку, про то, что в ней есть,
как она устроена и так далее, но и отдельное внимание также уделим внутреннему устройству и наиболее
эффективную использованию тех или иных контейнеров и алгоритмов. Вот. Ну, это такая вот небольшая
преампула. Теперь непосредственно про стандартную библиотеку шаблонов, про STL. Вообще говоря,
STL, это стандартная библиотека шаблонов, это не только набор тех контейнеров и тех алгоритмов,
которые в ней есть. На самом деле, STL это нечто большее. В общем, это выходит за рамки просто
некоторого набора классов и функций. Это на самом деле некоторое соглашение или некоторая философия
программирования на C++. Дело в том, что если вы придете, например, в какую-нибудь другую компанию,
особенно если это какая-то крупная компания, то скорее всего вам не придется работать именно
STL с этими контейнерами и алгоритмами, потому что, как правило, в достаточно крупных компаниях
написаны свои реализации стандартной библиотек, написаны свои реализации контейнеров и тому
подобное. Это происходит по нескольким причинам. Во-первых, код style, который принят
непосредственно в стандартной библиотеке C++, может отличаться от код style, который принят в вашей
компании. Вы наверняка с этим столкнулись. У нас на курсе код style несколько отличается от того,
который есть в STL. У нас там именование функций идет в camel case, в стандартной библиотеке C++,
в snake case и так далее. Но это, естественно, не главная проблема. Главная проблема заключается в том,
что если компания разрабатывает какой-то продукт, то для этого продукта необходимо, условно,
какая-то конкретная реализация определенного контейнера. Если мы возьмем какой-нибудь
контейнер set, забегая вперед скажу, что STL C++ есть такой шаблонный класс как set,
который представляет из себя, условно, интерфейс множества, но реализован в виде красно-черного
дерева. Как правило, он реализован в виде красно-черного дерева. В прошлом семестре вы
изучали, скажем, AVL дерево. И вот AVL дерево имеет несколько преимуществ перед, скажем,
красно-черным деревом. В частности, операция поиска работает быстрее, чем красно-черное дерево.
Красно-черное дерево наоборот. Операции вставки и удаления работают чуть быстрее, чем в AVL,
как правило, в среднем. Если, скажем, в вашем продукте очень критичен быстрый поиск,
то есть у вас вставки и удаления происходят не очень часто, а вот поиск осуществляется довольно
быстро, то заменив красно-черное дерево на AVL дерево, вы получаете больше перфоманс в вашем
продукте. Поэтому в вашей компании условно сет может быть реализован в виде AVL дерева,
например. Поэтому мы изучаем STL не для того, чтобы научиться пользоваться конкретными контейнерами,
а чтобы изучить на примере, как устроена договоренность между разработчиками на C++,
как должны выглядеть те или иные контейнеры. То есть условно контейнеры должны содержать такие
методы, контейнеры должны работать за какое-то время, или условно алгоритмы должны удовлетворять
следующему интерфейсу. То есть разговор в качестве одной из запасательных разговоров мы будем
говорить про интерфейсы, то есть что гарантируют контейнеры, как они взаимодействуют с пользователем
и так далее. STL это больше не про сами контейнеры и их устройства, а про условно договоренность или
интерфейс. В общем, длинное опрямование в итоге получилось, давайте перейдем непосредственно к теме.
Сегодня мы говорим про последовательные контейнеры. Что такое контейнер? Тут небольшие
формализации. Контейнер это некоторый тип данных, который обеспечивает хранение объектов других
типов, а также интерфейс для доступа к ним. То есть если вам нужно сохранить какие-то данные, то
как правило вы используете некоторые контейнеры. То есть вам приходит что-то со входа, вам нужно
эти данные сохранить, и вы как правило их сохраняете в некотором контейнере. Среди всех контейнеров
выделяются последовательные контейнеры, ассоциативные контейнеры. Последовательный контейнер
это такой контейнер, который обеспечивает у порядочный способ хранения элементов, который
зависит от времени и места их добавления, но не зависит от их значений. Что это значит? Это
значит, что вы в каждый момент времени можете условно понять или даже управлять тем, куда будет
вставлен тот или иной объект. Если у вас есть последовательность из трех элементов, вы можете
что теперь на второй позиции должен стоять элемент x, или вы хотите добавить очередные элементы, скажем, 5 элементов, и добавляете их в конец.
И вы можете быть уверены, что эти 5 элементов обязательно станут в конец. В общем случае это не так.
Понятное дело, там есть ассоциативные контейнеры, например, бинарное деревье поиска.
Порядок элементов в бинарном дереве поиска определяется непосредственно построением дерева.
То есть вы не можете сказать, что вот этот элемент должен обязательно стоять в корне дерева,
или этот элемент обязательно должен стоять в качестве самого левого объекта дерева,
потому что дерево хранит свойственный порядок.
В последовательном контейнере вы можете сами контролировать, в каком порядке идут те или иные элементы.
И первый контейнер, про который мы сегодня поговорим, это контейнер std array.
С std array, я думаю, многие уже знакомы, то есть его нужно было реализовывать в первом задании.
Просто проговорим несколько важных вещей.
std array – это шаблонный класс, который представляет себя аналог C style массива,
то есть обычный C-шный массив, которого вы выделяете на стеке.
Так как мы помним, что, так как C-шные массивы имеют фиксированный размер,
то в качестве дополнительного шаблонного параметра, помимо типа хранимых элементов,
мы его параметризуем количеством хранимых элементов.
И вот std array tn, по сути, эквивалентен использованию C-style массива из пяти элементов на стеке.
То есть вот эти две записи, они в некотором смысле эквивалентны.
И первая строка… Да, кстати, мышку уже видно, да? Все нормально?
Все видно.
Да, отлично.
То есть вот если вы используете обычный C-шный массив, то по сути это то же самое,
как если бы вы использовали std array из стандартной библиотеки C++.
Потому что и тот, и тот, они выделяют память на стеке и пользуются ей.
Ну и скажем, здесь в первом примере я создал C-шный массив из пяти элементов,
заполнил его значением 1, 2, 3, все остальные два элемента заполнились нулями.
В случае std array абсолютно точно так же.
Ну и, собственно, ровно здесь все указано, если вы создаете std array из примитивных типов,
то он, как и в языке C, как и при создании обычных C-шных массивов,
он заполняется, как говорят обычно, мусором, но вообще говоря он ничем не инициализирован,
и обращение к этим элементам это undefinedBehaviour.
То есть если вы читаете эти данные, прежде чем туда что-то записать.
В случае, если вы используете не примитивные типы, а типы класса,
то это работает немного иначе.
Мы знаем, что если вы написали свой класс, то у классов, в отличие от примитивных типов,
всегда есть, ну не всегда хорошо, но, как правило, есть там дефолтный конструктор.
И если вы создаете пять элементов из какого-то класса,
то у вас выделяется на стеге память достаточное для хранения этих пяти элементов,
и для каждого из этих элементов вызывается конструктор по умолчанию.
Поэтому обращение к этим элементам все нормально.
Важно понимать, что если вы создаете просто массивные инициализации для примитивных типов,
то он заполняется мусором.
То есть при обращении к этим элементам у вас, при чтении этих элементов,
происходит undefinedBehaviour.
Если вы создаете std array из пяти элементов, которые имеют тип некоторого класса,
то они заполняются дефолтным конструктором.
Если такое есть.
Естественно, если у вас нет в классе дефолтного конструктора,
то создать std array таким образом у вас не получится.
Потому что компилятор попытается вызвать дефолтный конструктор,
у вас ничего не выйдет.
Нужно будет использовать вот эту обычную классическую инициализацию с помощью фигурных скобок.
Ну и, собственно, мы поговорили, в чем похожа обычная инициализация std array,
но также, понятное дело, у них есть ряд отличий.
Ну вот, в частности, мы с вами на первой лекции говорили о том, что
стишный массив нельзя скопировать.
То есть если вы хотите, например, создать копию обычного стишного массива,
то вот с помощью такого синтаксиса в первой строчке,
у вас не получится это сделать, потому что так нельзя.
Но при этом, если у вас есть некоторая структура или класс,
у которой в качестве поля выступает обычный стишный массив,
то внезапно такое копирование начинает работать.
Это тоже мы обсуждали на первой лекции,
потому что копирование для std arrays работает так, как вы ожидаете.
То есть просто возьмется ваш array и скопируется в новое место.
То есть у вас есть cpp-style array, то есть std array,
и вы его скопировали в новый массив.
То есть произойдет обычное копирование.
Второе отличие, ну второе важное отличие опять же заключается в том,
что если вы попытаетесь принять стишный массив по значению,
то у вас ничего не получится, потому что даже если вы тут написали
как бы синтаксис объявления переменной, то компилятору на это плевать.
Он просто скажет, что мы тут будем принимать массив по указателю,
точнее просто будем принимать указатель на первый элемент.
И соответственно внутри функции getCRA нет никакой возможности
узнать размер массива и так далее.
И более того, компилятор вообще не будет проверять,
верно ли, что вы передали массив из пяти элементов,
или вы передали массив кого-то другого размера.
То есть никаких проверок не происходит, потому что по факту
компилятор принимает это все как указатель.
Вот в случае STDRA это не так, STDRA это конкретный тип,
ну то есть это прям тип, это класс.
А что это у вас в линутации нету?
Прошу прощения.
Сейчас исправим.
Готово?
Да, все пофиксилось.
Отлично.
Я остановился на том, что если вы функцию принимаете STDRA,
то STDRA это обычный тип, тип класса, который имеет тип,
в данном случае int 5.
И поэтому в эту функцию вы можете передать только массив из пяти элементов.
При этом при передаче массива сюда у вас массив будет скопирован.
То есть обычная темантика копирования,
как это устроено для любых других типов.
Ну и соответственно, если вы хотите передать массив в функцию,
точнее STDRA в функцию, и при этом хотите избежать копирования,
то вы можете передать его по ссылке или по константной ссылке,
как любую другую переменную.
Вот в последнем боксе это указано.
Ну и соответственно, что еще?
Какие еще есть правила использования STDRA?
Смотрите, у C++ наследство языка AC досталось очень много функций,
которые работают с обычным C-шным массивом.
Но обычные C-шные массивы – это не что иное,
как правило, просто указатель и его размер.
Допустим, вам необходимо использовать вот такого рода функцию.
То есть функцию, которая принимает на вход какой-то указатель на массив
и принимает его размер.
А у вас на руках только STDRA.
Так как вы разрабатываете код на C++,
то вы пользуетесь стандартными безопасными обертками.
Что в этом случае делать?
На этот счет у STDRA есть специальный метод дата,
который просто-напросто берет и возвращает указатель на первый элемент.
То есть, на самом деле, вы бы могли,
аналогично вместо дата, вы могли бы использовать, скажем,
амперсант A0, рэй.
И по сути, это бы означало то же самое.
Когда вы пишете ra.data,
это более наглядно показывает ваше намерение.
То есть, вы хотите указатель на первый элемент,
то есть указатель на обычный массив,
вот он вам тут и возвращается.
И, соответственно, с помощью метода size вы возвращаете размер массива.
Еще одно преимущество использования STDRA перед обычными C++ массивами –
STDRA всегда знает свой собственный размер.
Чтобы получить размер C++ массива,
вам нужно поиграться с size и так далее.
Какие еще есть методы для доступа данным?
Понятное дело, есть методы квадратной скопки,
есть методы front,
есть методы back.
Я думаю, по логике понятно, что они делают.
Back берет последний элемент, front берет первый элемент.
И есть специальный метод add,
который работает точно так же, как квадратные скопки.
Но в случае выхода за границем массива
он дополнительно проверяет,achtenly,
вышли вы за границем массива или нет.
И если вышли, то бросают исключение.
Квадратные скопки не бросают исключение,
они не проверяют выход за границем массива.
И, как вы понимаете, квадратные скопки работают чуть эффективней,
чем add, потому что они не используют некоторого, они не используют, собственно, проверок.
Поэтому если вам, скажем, нужен безопасный код, то вы пишете add, если вам нужен быстрый код, то вы используете квадратные скобки.
Опять же, это самая вилка или выбор между безопасным кодом и эффективным кодом.
Ну, понятно, есть методы emptySize, которые говорят, пусть ли массив и возвращает его размер.
При этом массив считается empty только если у него n равно 0.
То есть если вы инстанцировали, скажем, std array int и 0, то empty возвращает true только для такого массива.
Для любых других std arrays empty всегда возвращает true.
Ну и также есть методы fill и swap.
Ну, значит, с методом fill, думаю, все понятно.
Fill принимает некоторый объект и заполняет этим объектом все элементы вашего массива.
Ну а метод swap он просто берет и обменивает содержимое всех массивов.
При этом этот swap, важно отметить, работает за o от n.
То есть он работает за линейное время от размера массива.
Почему так?
То есть мы вроде как говорили, что у нас есть муфсемантика отличная,
и когда мы делаем swap, мы там меняем, грубо говоря, указатели и так далее,
и все работает быстро за o от единицы.
Вот почему у нас, скажем, swap работал быстро для стека.
То есть когда у нас был стек, то есть стек это что?
Это просто указатель на динамически элоцированную память,
ну и другой стек это тоже указатель на динамически элоцированную память.
И вот чтобы их обменять, нам достаточно было просто обменять два указателя.
И, соответственно, все это работает за o от единицы.
В случае с std array не так.
То есть std array на самом деле в памяти он, то есть вот это все находится на стеке,
вот это находится в динамической области памяти.
В случае std array сам массив, он хранится на стеке.
То есть сами данные массива, они хранятся на стеке.
То есть std array хранит не указатель, а именно сам массив целиком, как переменную.
Поэтому если вам нужно обменять содержимое двух ячеек памяти,
а в этих ячейках памяти, собственно, хранятся сами эти объекты,
то есть не указатель, а сами объекты.
Так вот, чтобы обменять содержимое этих двух ячеек памяти,
вам нужно за линейное время пройтись и по очереди обменять каждый из этих элементов.
Поэтому swap для std array работает за линейное время.
Ну как раз-таки это следствие того, что std array хранит свои данные на стеке, а не в куче.
Если он хранил свои данные в куче, то достаточно было обменять два указателя,
указатели, которые ведут в кучу.
Ну и std array, как и на самом деле любые другие контейнеры,
их можно сравнивать между собой на больше-меньше равенства-неравенства,
и сравнение происходит в лексикографическом порядке.
То есть сначала сравним с первыми элементами,
с вторыми элементами, ну и так далее.
На этом, кажется, все.
Есть вопросы?
Std array.
Видимо, нет. Окей.
Тогда переходим, наверное, к наиболее интересному контейнеру,
про который мы поговорим больше всего.
Это контейнер std vector.
Тут будет достаточно длинный и обстоятельный разговор.
Смотрите.
Ну, во-первых, что такое std vector?
Это, опять же, шаблонный класс, который представляет из себя
динамически расширяющийся массив элементов типа T.
То есть это шаблонный класс, он параметризуется типом хранимых элементов
и, соответственно, представляет из себя массив.
В чем его, то есть как бы std array-массив и std vector-массив?
В чем их отличие?
Их главный отличие заключается в том, что std vector хранит свои данные в куче.
Это первое.
А во-вторых, std vector умеет расширять свой размер.
То есть его размер не является фиксированным, а может постепенно расширяться.
Вот у std array размер фиксирован и известен заранее.
Вы его указываете заранее в треугольных скобках в качестве параметра шаблона.
std vector не так.
Он может в какой-то момент быть нулевым, в какой-то момент стать равным 10,
потом миллион и так далее.
То есть если бы мы приводили некоторую аналогию вектора
с какими-то другими известными вам штуками,
это, наверное, массив, который вы делаете в куче.
Скажем, вам приходится входа с консоли число n,
и вы можете создать свой массив размера n с помощью операции new.
Аналогичного можно достичь, если вы создаете вектор
и передаете ему в качестве параметра конструктора n.
То есть и cstyle, и cppstyle хранят свои данные в куче.
Но важный момент заключается в том, что вектор,
во-первых, в отличие от cstyle, он знает свой размер.
Вот у этого cstyle это просто указатель.
У указателя вы не можете спросить,
а какого размера данные ты указываешь.
То есть вам нужно обязательно хранить некоторую отдельную переменду.
Во-вторых, для cstyle вам нужно обязательно помнить о том,
что нужно вызвать для него delete.
Для std vector, естественно, этого не нужно.
Потому что у std vector есть деструктор,
который эту память вовремя очистит.
Ну и плюс вот этот cstyle массив,
он не умеет самостоятельно расширяться.
То есть если в какой-то момент вы поняли,
что вам n элементов недостаточно,
вам придется вручную снова выделить память,
потом скопировать все элементы
и дальше пользоваться новым массивом.
С вектором это не так.
С вектором вы можете спокойно добавлять элементы
и можете даже не задумываться о том,
в какой момент происходит расширение и так далее.
Просто вектор подстраивается под нужный вам размер.
Ну и забегая вперед,
или не забегая вперед, а просто скажу,
что расширение, естественно, происходит по мультипликативной схеме,
той, которую вы обсуждали в прошлом семестре.
Потому что, скажем, вектор имеет изначально размер n.
Потом, если ему нужно расшириться,
то расширяется до 2n, дальше до 3n и так далее.
Для чего это нужно?
Это обеспечивает амортизационную константу при добавлении элементов.
То есть если вы добавляете не мультипликативно,
а, скажем, аддитивно,
то там уже возникает квадратичная сложность от числа элементов.
Как можно создать вектор?
Вектор можно создать многими разными способами,
и некоторые из них перечислены здесь.
Ну, самые основные, наверное.
Во-первых, можно создать пустой вектор или пустой массив.
Пустой массив просто эквалентен нулевому указателю или nullptr.
То есть у него нулевой размер, он ничего не хранит.
Ну, в общем, банальный пустой массив.
Если вы хотите создать массив из n элементов,
и при этом каждый из этих элементов прорендеризировать по умолчанию,
вы можете воспользоваться вот таким конструктором.
То есть передать просто количество элементов.
В этот момент создастся вектор в куче,
выделен для n элементов.
И каждый из этих элементов будет создан с помощью дефолтного конструктора.
Если вы хотите все эти элементы заполнить не дефолтным образом,
а к каким-то определенным значениям,
вы можете воспользоваться вот такой формой конструктора.
То есть передать размер и передать значение,
которым нужно заполнить все элементы вектора.
Дальше есть списочная инициализация массива.
То есть если вы хотите заполнить его конкретными значениями,
вы можете их написать в фигурных скопках.
В данном случае вектор D является массивом из трех элементов,
который заполнен значениями 1, 2, 3.
Ну и естественно для векторов существуют операции копирования,
конструктор копирования, которые работают напрямую.
Ну и существует конструктор перемещения,
который перемещает содержимое за ход единицы.
Ну понятно, почему перемещение работает за ход единицы,
потому что перемещение это, по сути, просто,
ну мы это с вами обсуждали...
Просто достаточно просто взять и украсть указатель
у того объекта, который мы перемещаем.
То есть перемещение указателя или просто присваивание указатель
Константное время.
У вектора есть те же самые операции для доступа к элементам, которые мы обсуждали до этого.
Это методы квадратной скобки, add, front, back, data.
То есть тут все то же самое, что мы говорили про std array.
Также есть методы empty и size.
empty возвращает, если у вас в векторе на самом деле ничего не хранится.
Если что-то хранится, то он возвращает true.
Также есть метод fill, который заполняет все элементы вектора определенным значением.
И есть метод swap, который теперь уже работает за от единицы.
И за от единицы он работает по тем же самым причинам, почему у вас перемещение работ за от единицы.
То есть теперь вы можете спокойно просто обменять указатели вектора и на этом все.
На этом обмен содержимым вектора заканчивается.
копировать, точнее копировать содержимые векторов целиком, вам достаточно просто обменять указатели.
Теперь, вот все, что мы обсуждали до этого, это то, чем вектор похож на STD array.
Как я сказал, в отличие от STD array, STD вектор умеет динамически расширяться, он умеет добавлять
внутри себя элементы или удалять элементы. Основными методами вставки удаления являются
методы pushback и popback. То есть, если вы хотите добавить элемент в конец вектора, то вы используете pushback,
если вы хотите удалить элемент с конца из вектора, то вы используете popback. И pushback и popback
работают за единицу. При этом pushback работает амортизированно за единицу,
popback работает за единицу в худшем случае. Чтобы сделать popback, вам достаточно просто удалить
элемент с конца, то есть, двинуть size, удалить элементы и так далее. Если вы хотите вставить
элемент в середину или в начало, или, скажем, удалить элемент из середины из начала, то тут вам
помогут методы insert и erase. Значит, insert и erase принимают довольно интересные вещи, про которые мы
поговорим на второй части лекции, но, забегая вперед, скажу, что в качестве первого аргумента
insert принимает итератор или просто некоторую, так скажем, позицию, куда нужно вставить элемент.
В данном случае я сказал, что я хочу вставить элемент в первую позицию, то есть, я говорю, что я
беру начало вектора и сдвигаюсь на одну единицу вправо. То есть, в данном случае я говорю, что я
должен осуществить ставку на первую позицию моего вектора. Ну и в данном случае действительно я вижу,
что у меня был вектор 1, 2, 3, и в первую позицию у меня оказался элемент 0. Значит, здесь я сказал
следующую вещь. Да, есть insert, который принимает три аргумента, здесь я сказал следующее. Я хочу
в третью позицию вектора, то есть, вектор позиции номер 3, то есть, которая от начала расположена на
три шага вправо, я хочу там расположить 2 минус единицы. В этом случае у меня вот, начиная со
второй позиции, точнее, начиная с третьей позиции, 0, 1, 2, 3, третья позиция, там расположились 2 минус
единицы. Ну и при этом, естественно, как вы понимаете, это все работает за линейное время в худшем
случае. Ну почему? Потому что как вставить элемент в середину массива? То есть, ну, это не список,
там нельзя просто провязать указатели. Нужно, во-первых, сдвинуть элементы вправо, то есть,
освободить место для новых элементов и только потом вставить. Ну, собственно, вот этот сдвиг,
он занимает линейное время. Ну и аналогично с Erase, Erase тоже принимает указатель или итератор на
позицию, из которой нужно удалить элемент. В данном случае, я говорю, что я из первой позиции хочу
удалить элемент, то есть, выбегин плюс 1, и в итоге у меня из вектора удалился 0, который находился в
первой позиции. Дальше я говорю, что, дальше вторая форма Erase, я говорю, что мне нужно удалить все
элементы со второго по четвертой, то есть, начиная со второго по четвертой, я хочу удалить там все
элементы. Ну, при этом, как и любой другой алгоритм, здесь имеется в виду полуоткрытый интервал, то
есть, начало включительно, конец не включительно. Ну, то есть, полуоткрытый интервал. Соответственно,
второй элемент это минус единица, четвертый элемент это тройка. Ну, по тройку не включительно,
я удалил все минус единицы и в итоге вернулся в исходное состояние 1, 2, 3. Есть вопросы тут?
Хорошо. Еще один способ вставить или удалить элементы, это использовать методы Resize и Clear.
Ну скажем, если вы хотите принудительно увеличить размер вектора на какое-то число, ну или вставить
сразу несколько элементов в конец вектора, вы можете воспользоваться Resize. Значит, вот пример
такой. У меня есть вектор, изначально у него размер два элемента. Я делаю Resize 4, и он
увеличивает свой размер до четырех. Так как я использую int, то, собственно, вот эти дополнительные
два элемента, которые у меня были добавлены в конец, они проинциализированы мусором. То есть,
там пока ничего не хранится, ну, то есть, просто неинциализированная память. Дальше я могу
воспользоваться другой формой Resize, то есть, передать размер, до которого я хочу увеличить свой
массив, и передать ему дополнительный параметр value, то есть, какими значениями я хочу заполнить.
То есть, если в первой форме я сказал, что мне не важно, чем ты там заполнишь, то есть, он
заполнит это все по умолчанию. Ну, то есть, для базовых типов ничего не сделает, для примитивных
типов ничего не сделает, а для типов классов он вызовет конструктора по умолчанию. Здесь я же
говорю, что дополнительные элементы я хочу заполнить значением минус один. Ну и, действительно,
у меня размер увеличился на единицу, то есть, до пяти, и все дополнительные значения заполнились
минус единицей. Ну и также, в любой момент, я могу уменьшить размер вектора, сказать Resize2,
то есть, уменьшить размер до двух. Все. То есть, в итоге у меня осталось два элемента, а все остальные
элементы, они забылись, то есть, их теперь в моем векторе, по сути, нет. Вот. Ну и есть метод Clear,
который позволяет очистить содержимое вектора. То есть, если у меня был вектор из двух элементов,
то я вызвал Clear. В общем, теперь, после этого, размер вектора стал равным нулю. Ну здесь, как бы,
кажется, что методы сами говорят сами за себя, тут должно быть понятно. Вот. Ну и теперь нужно
чуть подробнее остановиться, ну, на самом деле, даже не чуть, а достаточно подробно остановиться на том,
как устроен вектор, что он, на самом деле, хранит и так далее. Вот. Все это время мы говорили про такую
характеристику как Size, то есть, про размер вектора. Так вот, под Size или под размером вектора
поюнимается реально хранимое количество реально хранимые объекты в векторе. То есть, если у вас Size
равен 4, то это значит, что реально в векторе хранится 4 элемента. Ну, помимо характеристики Size или
размер, у вектора есть такая характеристика как Capacity или вместимость вектора. Ну, для чего она
нужна? Ну, я думаю, вы понимаете, что если вы будете, ну, скажем, вот, постоянно поддерживать Size,
нужного вам размера, скажем, вот, у вас 4 объекта, вот, и вам нужно вставить там два элемента
дополнительно. Ну, чтобы вставить два элемента, вам нужно выделить массив большего размера, и вот вы его
выделяете на два больше. В какой-то момент вам нужно вставить еще один элемент. Вы берете там,
перевыделяете память и вставляете вот этот дополнительный элемент. Ну, как вы понимаете,
это неэффективно. Почему? Ну, потому что на каждую вставку вам, по сути, нужно скопировать
весь предыдущий вектор целиком. Вот. Поэтому вектор, как правило, хранит памяти больше, чем вам
нужно. Ну, с этой техникой вы уже с прошлого семестра знакомы, да, это вот как раз таки динамический
массив. То есть, чтобы вставка осуществлялась быстро, амортизирована за единицу, вы, как бы,
выделяете всегда чуть больше, чем вам нужно. Ну, в частности, там, как правило, в два раза больше,
чем вам нужно. И тогда вот вставка дополнительных элементов будет осуществляться довольно быстро.
И количество реаллокации, количество перевыделения памяти будет довольно редким. Вот. Ну, и будет
казаться, что вы работаете всегда, ну, то есть, что суммарно вы работаете за линейное время.
Ну, и в связи с этим у вектора есть две характеристики. Есть характеристика size и есть
характеристика capacity. Size говорит о том, сколько элементов у вас реально задействовано в векторе,
а capacity говорит о том, сколько элементов ваш вектор может вместить без реаллокации. То есть,
если вы заполнили capacity элементов и даже вставляете еще один, то у вас происходит реаллокация,
то есть выделяется массив большего размера. Вот. Если у вас размер меньше, чем capacity,
то вы сможете спокойно вставлять туда дополнительные элементы без реаллокации.
Ну, вот здесь у меня есть небольшая демка. Давайте ее посмотрим. Давайте так. Видно, да?
Да. Так, вот. Ну, просто небольшая демонстрация. У меня есть вектор,
и есть функция, которая просто принимает вектор и выводит его размер, и выводит его capacity,
то есть выводит его размер и выводит его вместимость. Ну, и дальше я просто в цикле
последовательно добавляю элементы и вывожу размер и вместимость вектора. Вот. Ну,
и давайте посмотрим, как это работает, что будет выведено на экран. Ну, вот. Собственно,
я добавляю 8 элементов, и что я вижу? Изначально у меня вектор хранит 0 элементов, естественно,
и его вместимость равна 0, то есть никакого буфера, никакого массива внутри себя не хранит. Я добавил
один элемент, size стало равным единице, вместимость стала равной единицей. Я добавил
второй элемент, у меня произошло перевыделение памяти, то есть вектор увеличился в два раза.
То есть и в первом случае, и в втором случае произошло перевыделение. Теперь дальше я добавляю
третий элемент, старой вместимости мне не хватало, поэтому мне пришлось перевыделить массив,
и я выделяю массив большего размера. Теперь он стал равным 4. Я добавляю четвертый элемент,
size стал равным 4, но при этом capacity не изменился. То есть я добавил элемент, ну,
старый массив, который у меня был выделен до этого. Я добавляю пятый элемент, вместимости не
хватает, поэтому я увеличиваю вместимость в два раза. Следующие элементы 6, 7, 8 я могу
вставлять спокойно без перевыделения памяти и без лишних копирований. Вот классическая схема
увеличения динамического массива, которая в частности реализована в библиотеке GCC.
Как управлять размером? Мы разобрались, мы до этого обсуждали, что есть всякие
пушбэки, есть попбэки, есть ресайзы, есть инсерт и так далее. Возникает вопрос, а можно ли
управлять самим хранилищем? То есть можно ли управлять непосредственно вот вместимостью
вектора? То есть скажем, у меня размер вектора равен 4, а я, допустим, понимаю, что мне нужно
дополнительно будет вставить еще 100 элементов. И как бы зачем мне выполнять много реалокаций,
если я могу там, скажем, заранее выделить память для хранения 100 элементов? Могу ли я так сделать?
Ответ – да, можете. И это на самом деле довольно часто используется. Ну, например, у вас есть вектор из
5 элементов. И, собственно, если вы создали вектор из 5 элементов, то у вас size вектор равен 5,
а capacity больше либо равен 5. То есть по стандарту вам гарантировано, что, естественно, у вас
вместимость больше либо равна, чем то количество элементов, которые вы храните. И, допустим,
в какой-то момент вы понимаете, что вам понадобится 10 элементов. Вы можете вручную, не отдавая
всю налодку вектор, вы можете вручную выделить память нужного размера. Для этого вызываете
просто v.reserve и нужное количество памяти. Как работает Reserve? Reserve принимает собственное значение,
которое вы ему передали, и выделяет столько памяти, сколько было бы достаточно для хранения такого
количества элементов. При этом минимум. Он выделяет минимум столько памяти, сколько было бы
достаточно для хранения элементов. Ну, например, если вы просили v.reserve10, то вектор, в принципе,
может теоретически выделить вам и 20, и 15, но как минимум 10 он вам гарантирует. Ну, как правило,
компиляторы, как правило, современные реализации, они всё-таки выделяют ровно столько,
сколько вы просили, но по стандарту стандарт-хайлиотека может выделить вам и больше, чем вы
попросили. Поэтому после вызова этого резерва у вас size осталось ровно 5, а capacity увеличился минимум
до 10. Теперь, что произойдёт, если вы попытаетесь зарезервировать количество памяти меньше, чем
у вас реально сейчас есть? В этом случае, на самом деле, по стандарту просто ничего не произойдёт.
То есть, если вы попросили, что вектору нужно хранить как минимум два элемента, то есть нужно
выделить память для хранения как минимум двух элементов. Ну, а вектор уже содержит у вас 10
элементов, поэтому он ничего делать не будет, он просто, ну, посмотрит, сравнит то, что вы попросили
с тем, что у него реально есть, поймёт, что до того количества памяти, которое вы просили, уже
достаточно, вот, и ничего не произойдёт. То есть, уменьшение capacity не произойдёт. Таким образом,
уменьшить вместимость у вас не получится. А с помощью чего можно уменьшить вместимость? С помощью
метода, который называется shrink-to-fit. Вот метод shrink-to-fit уменьшает capacity до size. Ну,
как это работает? Вот, допустим, вы создали вектор из тысячи элементов, вот как-то с ним поработали,
и даже в какой-то момент поняли, что, ну, всё, остальных тысячи элементов вам не достаточно,
вам теперь достаточно работать с первым десятью или только с первым элементом. Вот, вы делаете
resize, и таким образом говорите, что теперь у вас размер вектора равен единице, то есть вы имеете
право использовать только первый элемент, но при этом resize, он не влияет на вместимость. То есть,
у вас вместимость как была тысяча, так и осталась. Ну, и как-то возникает не очень
приятная ситуация, что вы пользуетесь реально одним объектом, а в память у вас, ну, собственно,
в память у вас выделено для тысячи объектов. Так вот, чтобы этого избежать, вы можете взять и
принудительно уменьшить capacity или вместимость вектора до размера с помощью метода shrink-to-fit. Вот,
когда вы вызвали shrink-to-fit, у вас capacity принудительно уменьшился до реального количества
элементов. Вот. Ну, и более того, shrink-to-fit — это, вообще говоря, единственный метод, который может
уменьшить capacity. Все остальные методы типа resize и reserve уменьшить capacity не могут. Могут
только увеличить. Поэтому, если вы в какой-то момент понимаете, что в памяти у вас вектор жирет
слишком много, ну, по сравнению с тем, сколько вам реально нужно, вы можете вызвать метод shrink-to-fit.
Вот. Так, ну, перерывы мы будем делать. До перерыва осталось три минуты. Вот, давайте до перерыва
попробуем разобраться с некоторыми проблемами или с некоторыми загадками C++, которые в связи с
этим возникают. Ну, вот, смотрите. Да. Ну, смотрите. Допустим, у меня есть вектор, который хранит другие
вектора. Вектор векторов. Ну, или, на самом деле, вектор, который хранит любые другие тяжелые объекты.
Ну, вектор — это все-таки достаточно тяжелый объект, если он хранит много элементов. Но в данном случае
я задаю вектор, который хранит 100 других векторов, каждый из которых имеет размер миллион. То есть,
по сути, двумерный массив. Здесь 100 элементов. И каждый из них хранит вектор, который хранит
10 шестой элементов. Ну, и в какой-либо момент вы поняли, что там все 100 векторов размера миллион
вам не нужно, вам нужно только первые 10. То есть, вы делаете resize до 10, но в итоге у вас
capacity остался равным сотня. Или хуже того, вы понимаете, что вектор вам больше не нужен,
вам такой вектор не нужен, вы делаете clear. То есть, его очищаете. И тут возникает вопрос, а что
произойдет с этими векторами? Ну, то есть, если вы реализовывали свой string в первом задании, то,
ну, давайте так, я спрошу кого-нибудь. Кто реализовал string? Как был устроен resize и как
был устроен clear? Что вы делали? В общем, заключается resize до меньшего размера или clear. Да, просто
меняли size. Ну, смотрите, тут возникает такой вопрос. Ну, хорошо, если в векторе clear просто меняет
size, ну, скажем, clear просто устанавливает size равным нулю, да, resize просто устанавливает size
равным 10. Что происходит с памятью? То есть, вы понимаете, что если вы просто изменяете размер, то у
вас вот оставшаяся часть, вот, если вы уменьшили размер вот до сих, то вот вся вот эта память, она у вас
висит. То есть, она все еще висит в системе, вы как бы эти векторы реально не удалили, да, то есть,
они реально есть. И, соответственно, они жрут там вашу память. Ну, как вы понимаете, там 100 векторов
по миллиону элементов, это достаточно много. Вот, есть какая-то вопроса, хотим ли мы этого? Хотим ли мы,
чтобы действительно при resize до меньшего размера или при clear, да, который просто устанавливает
size равным нулю, у нас все эти векторы реально висели в памяти? Ну, или теоретически эти тяжелые
объекты висели в памяти? Ну, скорее всего, нет. Другая проблема. У меня есть вектор, и я делаю
reserve 100, и этот вектор хранит элементы типа A. Что делает reserve? Ну, как мы сейчас понимаем,
reserve, скорее всего, он выделяет память, да, то есть, он вызывает что-то типа new A 100, ну, и сохраняет в буфер.
То есть, на текущем уровне понимания мы думаем, что он выступает вот таким образом. Но это
неизбежно приводит к проблеме. Смотрите, что делает new? Ну, new с квадратными скобками. Он выделяет
память и вызывает конструкторы, да, то есть мы знаем, что new — когда вы вызываете new, он выделяет память,
и плюс вызывает конструкторы для каждого объекта, которые вы создали. Вопрос. Значит,
какой конструктор тут будет вызван? Ну, так как это массив, так как это new с квадратными скобками,
каждый элемент этого массива будет создан с помощью конструктора по умолчанию. Ну, или компилятор
попытается все создать с помощью конструктора по умолчанию. Ну, а что если у объекта A нет
конструктора по умолчанию в принципе. То есть получается, что вы, то есть смотрите, с одной
стороны, с точки зрения логики, с точки зрения логики вы в векторе еще не храните ни одного объекта a.
То есть у вас size равен нулю. То есть формально вы сказали, что вектор a ничего не хранит, я просто
зарезервировал память под 100 элементов. Но реально при такой реализации у вас возникнет ошибка
компиляции, на том, что компилятор скажет, что у объекта a нет конструктора по умолчанию,
ну а вы как бы никаких конструкторов вроде как сами не вызывали. То есть получается, что при такой
реализации у вас вектор не может хранить и не имеет права хранить элементы, у которых нет конструктора
по умолчанию. Ну это довольно сильное ограничение на самом деле. Ну мало ли почему вы не хотите
использовать конструктор по умолчанию. Беда. Более того, давайте вот пару слайдов закончим,
мы и на перерыв пойдем. С этим возникает еще три вопроса. Первый. За сколько работает метод clear?
Ну вот как мы с вами обсудили, при реализации стринга достаточно было просто взять и выставить size
равным нулю. Казалось бы, метод clear работает за ездицу. То есть выставить size равным нулю
это довольно быстро. Следующий вопрос. Сколько работает resize при уменьшении размера? Ну тоже,
кажется, что понятно, что если у вас был какой-то size до этого s и вы уменьшили размер до s-стрих,
то достаточно просто сделать size равно new size и все. То есть это тоже занимает от единицы.
Скорее всего от единицы, скорее всего от единицы. Ну и сколько работает метод reserve при
увеличении вместимости? Ну тут кажется, все работает так. Значит у вас была память, скажем, n,
вы увеличили до n-стрих. Ну n это вместимость, ну давайте c. c вместимости, тут c-стрих
вместимость. Что делает reserve при увеличении памяти? Ну он вызывает new для c-стрих элементов,
и для каждого из этих c-стрих элементов вызывается конструктор по умолчанию. Поэтому, ну кажется,
что он работает за c-стрих плюс c. Ну потому что старые c-элементов нужно скопировать новый
буфер. Давайте посмотрим на то, как устроена реальность. Сейчас давайте просто-напросто
заглянем в справку по вектору и узнаем сколько реально работают все эти методы.
Нам нужны reserve, clear и resize. Ну например, посмотрим на clear. Мы думаем, ну наше понимание устроено
так, что clear работает за единицу, потому что он просто уменьшает размер до единицы.
Но если мы посмотрим вратил complexity, то мы видим, что оказывается clear работает за
линейное время от размера контейнера внезапно. То есть внезапно он выполняет какую-то работу,
которая требует ему линейных затрат памяти, линейных затрат по времени для линейных от
размера контейнера время. Затрат по времени. Странно. Окей, смотрим дальше. Значит есть метод
reserve. И тут внезапно написано, что reserve работает максимум за size от размера контейнера. То есть
у вас есть контейнер, у него size. Вы увеличивали вместимость. И казалось бы, что нужно сделать?
Нужно создать этот массив новый, то есть потратить как минимум capacity времени и плюс скопировать все
старые элементы в новый вектор. То есть как минимум capacity времени вам, наверное, нужно было
потратить. Но при этом как бы справка утверждает, что он работает максимум за size, а не за capacity.
Ну окей, давайте посмотрим на resize. Что мы ожидаем от resize? От resize мы ожидаем, что если он будет
уменьшать свой размер, то он будет работать, скажем, за единицу. Потому что мы уменьшаем размер,
достаточно просто изменить size на новый size и все. Но при этом, если мы посмотрим на complexity,
то увидим, что он всегда работает за линейное время от разницы между начальным size и конечным
size. То есть даже если вы уменьшаете размер вектора, даже если вы уменьшаете размер вектора вот здесь,
с s большого до s-трих, который меньше, чем s большое, вы все равно тратите какое-то время,
которое пропорционально вот этой самой разнице. Вот. Беда. Ну и вот, собственно, с тем,
почему это работает именно так и почему это должно работать так, мы разберемся после перерыва.
Ну и, собственно, давайте перейдем к объяснению того, почему это работает именно так и как,
вообще, это работает. Ну, снова, наверное, демонстрация.
Значит, демонстрация выглядит следующим образом. Вот у меня есть некоторая структура s,
которая просто в какой-то момент говорит, если мы ее создали с помощью default-конструирования,
мы говорим, что создался объект этого типа. Ну и в случае вызова деструктора,
эта структура пишет, что она была разрушена. Вот. Ну и дальше я создаю вектор из этих объектов,
ну из объектов типа s и вывожу на экран, что я с этим всем делаю. В частности, я сначала
вызываю резерв, то есть я резервирую место для 100 элементов типа s. Вот. Дальше вызываю resize,
то есть увеличиваю размер моего вектора до 5, потом, говорю, делаю resize до 2, то есть уменьшаю
размер моего вектора до 2. Ну и дальше вызываю clear, то есть полностью очищаю мой вектор. Давайте
посмотрим, что на это будет говорить s. Ну да, что будет на это говорить s, то есть в какой момент
какие конструкторы у меня вызываются. Вот. Для этого соберем этот код и запустим. И что мы видим?
Смотрите, сначала у меня вызывается резерв 100, то есть в программе у меня вызывается резерв 100
для вектора, я резервирую место для хранения 100 элементов массива. Вот. При этом, заметьте,
что ни одного конструктора реально у меня вызвано не было. То есть реально ни одного вызова
дефолтного конструктора у меня не было. То есть вектор сказал «хорошо, я выделил память,
но при этом вроде как ничего не произошло». Окей. Когда я сделал resize 5, вот в этот момент у меня
создалось 5 элементов. То есть когда я реально попросил, чтобы у меня размер вектора увеличился,
то есть изначально размер вектора был 0, я сказал увеличить его до 5. И вот именно в этот момент
у меня появились новые 5 элементов, вот как следует из вывода программы. Дальше интереснее,
я вызываю resize2, то есть я говорю, нужно уменьшить размер вектора с 5 до 2, ну казалось бы, да, то есть
мы обсуждали до этого, казалось бы, достаточно просто сказать size равен 2 и все. Но мы видим, что в
этот момент вызвалось 3 деструктора, то есть вот эти лишние 3 элементы реально были уничтожены,
то есть они там не то что как бы просто лежат в памяти или как-то охранят, они были реально
уничтожены, то есть для них был вызван деструктор. Ну и после того, как я вызвал clear, у меня
уничтожились оставшиеся два объекта. И это на самом деле не приводит нас к пониманию, как это устроено,
да, и почему это работает именно так, но это хотя бы приводит нас к некоторой идее, почему clear
работает за линейное время, почему resize работает всегда за, ну минимум, за size-count времени,
почему reserve работает за size. Ну понятно, почему clear работает за size, потому что, ну как мы
увидели до этого, clear, помимо того, что уменьшает size до нуля, он еще почему-то вызывает деструкторы
для всех элементов, которые были заполнены до этого. Плюс resize, когда даже если вы уменьшаете size
до какого-то размера, то resize вызывает деструкторы для каждого из лишних элементов. И это наталкивает
нас на мысль, что скорее всего, вектор реально не обладает той проблемой, которую мы описали
здесь. То есть здесь реально, когда вы вызываете resize, у вас не хранится 100 векторов размера миллион,
а для каждого из этих лишних векторов, то есть для каждого из этих лишних 90 векторов, у вас будет
вызван деструктор, то есть память будет очищена. И более того, когда вы вызываете clear, у вас size
станет равен нулю, и все остальные оставшиеся вектора размера миллион тоже уничтожатся.
Значит, понятно идейно, что здесь происходит?
Да. Отлично. Теперь осталось разобраться, а как это все устроено. То есть мы же вроде
как знаем, что… Смотрите, как мы выделяем память? Память мы выделяем с помощью new. Если мы
выделяем с помощью new n элементов, то мы знаем, что первое, выделяется память,
и второе, мы все это время говорили, что вызываются n конструкторов. Хотя мы до этого видели, что
резерв, который априори должен выделять какую-то память, он никаких конструкторов не вызывал. Как
так? Более того, мы знаем, что если мы хотим очистить память, то у нас сначала вызываются
деструкторы, а потом память освобождается. Но при этом в то же время мы видели, что у нас
элементы уничтожались просто так, сами по себе. То есть память не освобождалась, потому что мы
просто уменьшили, а та память, которая была, должна была остаться. То есть мы просто сумели
вызвать деструктор без уничтожения памяти как таковой. И, собственно, сейчас пойдет довольно
длинный разговор про new, про delete, как это все устроено, и как это вообще в принципе устроено
он-директор, как он достигает таких успехов, скажем. Здесь три вопроса. Есть три строчки и вопрос,
что делает первая строка. Давайте так. Что происходит, когда вы вызываете new t? Ну, желательно
полностью пошагово. Ну, допустим, t это некоторый тип, который имеет там конструктор. Этот тип
это некоторый глаз. Как вы себе представляете, что делает new? Он создает под него память в куче и
запускает конструктор. Да, отлично. Ну, какой конструктор. По умолчанию. Да, конструктор по
умолчанию, действительно. То есть когда мы вызываем new, мы говорим, что нужно выделить
элементы в кучи. То есть нужно выделить память достаточно для хранения элемента typeT и вызвать
конструктор. В данном случае конструктор по умолчанию. В второй строчке происходит то же самое.
Мы тоже выделяем память достаточно для хранения объекта typeT, но уже вызываем конструктор,
конкретный конструктор с параметрами x и y. В третьей строчке происходит ровно то же самое,
мы выделяем память уже достаточную для хранения n элементов типа t, и каждый из этих элементов мы
заполняем по умолчанию. То есть вот все то, что я описал, описано здесь. То есть каждый из этих
трех вызовов операции new, он выделяет памяти достаточную для хранения того, что стоит справа.
И плюс вызывает какие-то конструкторы. То есть при вызове new неизбежно происходят две вещи.
Первое, это выделение памяти, второе вызов конструктора. Когда вы вызываете операцию new,
у вас происходят две вещи. Выделение памяти, вызов конструктора. Ну и тут встает резонный вопрос.
Ну смотрите, new выполняет по сути две вещи, то есть по сути два действия. А можно ли эти два действия
как-то разделить во времени? То есть можно ли как-то, допустим, просто выделить память без создания
элемента? То есть просто выделить сырую память, в которой ничего не лежит. Можно ли сделать так? Это
первый вопрос. А второй вопрос, а можно ли, вот допустим, у вас откуда-то, ну непонятно откуда, но есть
память. Вот вам откуда-то сверху вот спустили, вот у вас есть память, в ней вы можете расположить
что угодно. Можете ли вы в этой памяти создать какой-то объект? То есть просто вызвать конструктора
и сказать, что вот этот конструктор должен создать элемент здесь. И вот на эти вопросы мы сейчас
попытаемся ответить. Значит, ответим на первый вопрос. Как выделить сырую память? Ну тут есть несколько
вариантов. Первый вариант — это воспользоваться обычной C-шной функцией malloc. То есть в наследство
языка C нам досталась стандартная функция malloc, которая принимает количество байт,
которые мне нужно выделить, и возвращает void указатель. Ну количество байт, понятно, это сколько
байт, сколько памяти в байтах мне нужно выделить. А почему она возвращает void указатель? Ну потому
что как раз-таки она возвращает ту самую сырую память, то есть нетипизированную память. То есть там
на самом деле ничего не лежит, это просто вот вам память и делайте с ней что хотите. И при этом нам
гарантировано, что malloc не будет вызывать конструкторов никаких. Почему? Ну как минимум потому,
что malloc пришел нам EC, а в языке EC никаких конструкторов нет. Ну это во-первых. Ну во-вторых,
еще раз повторюсь, malloc возвращает void со свездочкой, но это значит, что там никакого типа
реально не содержится. Если вы хотите выделить память достаточно для хранения объекта типа T,
вы вызываете sd malloc size of T. Или если вы хотите выделить память достаточно для хранения n
элементов типа D, то вы вызываете sd malloc size of T умножить на n. То есть на размер в байтах объекта
типа D и умножить на n. Ну и память, выделенную с помощью malloc, нужно освобождать с помощью free.
Ну естественно free тоже не вызывает никаких конструкторов, никаких деструкторов. Ну как и malloc
не вызывает конструкторов. Но это все как бы, это все C-шный стайл в языке C. Какие у нас есть
альтернативы в языке C++? В C++ вы можете сделать следующую вещь. Вы можете выделить массив чаров.
Ну почему массив чаров? Ну смотрите, чар в памяти занимает всегда один байт. То есть если вам нужно
выделить определенное количество байт, то вы можете воспользоваться new char и в квадратных
скобках передать сколько байт вам нужно. Соответственно new char выделит вам массив размера
size of t. Ну и так мы хотим сырую память, то есть мы хотим работать с этой памятью сырой, а не как с
char-указателем. Мы приводим ее к void-звездочке и сохраняем в single. Но то же самое, если мы хотим
выделить память, достаточно для хранения n элементов типа t. Делаем то же самое. То есть
выделяем просто нужное нам количество байт. Но у этого подхода есть проблема, которая связана с
тем, что память выделенную с помощью new нужно очищать с помощью оператора delete, ну операции
delete. А операция delete на вход, точнее в качестве своего параметра, ожидает типизированный указатель. То
есть если вы выделяли с помощью new объекты типа char, то удалять вы должны объекты типа char. Ну или скажем так,
если вы писали new t, то при вызове delete ptr, вот тип ptr должен быть как раз-таки типом t. Ну
или типом t-указатель, ну или он должен быть там, ну короче, если у вас есть наследование, то он
должен быть там базовым классом, то он должен быть базовым классом там того объекта, который вы
реально выделяли. Ну давайте так, в общем случае, если вы удаляете указатель, то тип этого указателя
должен совпадать ровно с тем типом, который вы выделяли с помощью new. Иначе это приводит к undefined
behavior. То есть если вы вызываете delete для, скажем, какого-то u-указателя, который даже если он
указывает на ту же самую область памяти, то это undefined behavior. То есть если вы выделяли объекты типа t,
то и удалять вы должны указатель на t. Поэтому перед тем, как выполнить удаление, мы все приводим
обратно к char звездочки. Это неудобно, это проблема. То есть мало того, что нужно помнить, что нужно
вызывать delete с кваратными скопками, так еще нужно помнить, что нужно обязательно удалить этот
указатель как указатель на char, а не как указатель на void или на какой-то другой объект. Вот. Ну,
так или иначе, в C++ есть более правильный способ выделения сырой памяти, ну и более современный
по сравнению с C. И это, ну сейчас будет немного шизы, но в общем выделение сырой памяти производится
с помощью функции оператор new. Вот. Оператор new — это вот прям функция. То есть в языке C++ есть
функция под названием оператор new. И это функция. Да, не путать с операцией new. То есть вот new,
который мы вызывали до этого в такой форме, я буду называть операцией. Вот. Это операция new. Если
я говорю оператор new, я буду иметь в виду вот конкретно функцию. Ну или иначе вот эту вот штуку я
буду называть еще, возможно, иногда выражением new. То есть, да, выражение new. То есть это выражение,
ну или expression. Вот. Ну или операция. А это функция оператора new, которая, ну по большому счету,
отношения к операции не имеет, но на самом деле, ну в общем, на самом деле имеет, но как бы это две
разные сущности. Так вот, возвращаемся. Значит, есть функция оператор new, да, которая так и пишется.
Вот два слова. Оператор new. И которая принимает, ну собственно, количество байт, которое нужно
выделить. И работает она, по сути, точно так же, как и sttmalloc. То есть тоже выделяет нужное вам
количество байт, возвращает void-указатель. Вот если вам нужно выделить память, достаточно для
хранения массива, вы вызываете sizeof t умножить на n и передаете это значение в оператор new. И он
тоже выделяет вам сырую память. То есть там никаких объектов не задается, возвращается просто void-указатель.
Вот. Ну ключевое отличие, наверное, оператор new от sttmalloc заключается в том, что оператор new в
случае, если ему не хватает памяти, он бросает исключение sttmalloc. А sttmalloc в случае, если ему не
хватает памяти, то он возвращает, ну возвращал просто nullptr. Ну вот это, наверное, самое главное
отличие этих двух операций, операторов. Ну и также память выделена с помощью оператора new, с помощью
функции оператора new нужно освободить с помощью функции оператор delete. Ну снова, значит, не путать
с операцией delete, которая... Вот. Это операция delete, вот, которая приводит к очищению памяти и вызову
деструктора. Ну, наоборот, вызову деструктора очищению памяти. А есть функция оператор delete,
которая просто очищает память, предварительно выделенную с помощью оператора new. Вот. И теперь
становится немного понятнее, как устроена операция new, вот, вот эта штука, и как устроена операция
delete. Вот дело в том, что, ну вот мы говорили, что к чему приводит new, как работает new. New обязательно,
первое, выделяет память, и второе, new обязательно вызывает конструктор. Так вот, выделение памяти
происходит с помощью функции оператора new. То есть new работает в два шага. Первое, это вызов
функции оператора new, второе вызов конструктора. И вот с первым шагом мы уже разобрались. То есть мы
понимаем, что new в самом начале вызывает оператор new, то есть выделяет просто сырую память. Вот. Как
действует delete? Как действует delete? Delete действует следующим образом. Он сначала вызывает деструктор,
а потом зовет оператор delete по тому указателю, который вы туда передали. Вот. Собственно,
возврат ресурсов в систему осуществляется с помощью функции оператора delete. Пока все ясно.
Есть вопросы? Наверное, должны быть. Или все ок. Отлично. Идем дальше. Ну, также существует,
помимо функции оператора new и оператора delete, существует функции оператора new с квадратными
скопками и оператора delete с квадратными скопками. Они ничем не отличаются от обычных. Единственное
отличие заключается в том, что оператор new с квадратными скопками вызывается, когда вы используете
оператор new с квадратными скопками, и оператор delete с квадратными скопками вызывается, когда вы
используете операцию delete с квадратными скопками. А вообще их внутреннее устройство абсолютно
точно такое же. То есть они тоже выделяют количество памяти то, которое попросили. Просто на вход
оператора new, в данном случае, на вход оператора new приходит size of t умножить на n. Вот и все. То есть,
по сути, их реализации ничем не отличаются. Тогда возникает вопрос, зачем нам два оператора,
то есть оператор new с квадратными скопками и оператор new без квадратных скопок, если они
делают, по сути, то же самое. Ну вот это все связано с тем, что есть некоторые детали реализации,
которые есть некоторые детали реализации, которые необходимо поддерживать. Но в частности,
вот давайте посмотрим на последнюю строчку здесь. Когда вы вызываете delete с квадратными скопками,
операции delete нужно каким-то образом понять, сколько деструкторов нужно вызвать. И вот как-то
просто извлечь эту информацию из указателя delete не очень удается. Вот поэтому оператор new с
квадратными скопками он действует немного хитрее. Ну это правда, вот то, что я сейчас рассказываю,
это просто внутреннее устройство конкретного компилятора, например, JCC. Вот JCC делает
следующим образом. Когда вызывается оператор new с квадратными скопками, он, на самом деле,
выделяет не столько памяти, сколько попросили, то есть он реально выделяет не вот столько памяти,
а выделяет столько памяти плюс 8 байт. На что уходит это 8 байт? Эти дополнительные 8 байт он
выделяет для того, чтобы сохранить дополнительную информацию о том, сколько элементов нужно было
создать. В частности, вот это число n, он сохраняет в эту дополнительную ячейку. И delete,
когда вызываете операцию delete, delete просто смотрит в эту ячейку и понимает, ага, там хранится
условно 10 элементов, значит нужно вызвать 10 деструкторов. Ну это просто внутренняя деталь
реализации, которая поддерживается с помощью оператора new с квадратными скопками и оператора delete
с квадратными скопками. Ну здесь тоже есть небольшая демонстрация, давайте тоже на ней, наверное, остановимся.
Как она называется? new delete. Ну вот, значит, у меня есть некоторая структура, у которой есть,
так скажем, нетривиальный деструктор. Ну почему нетривиальный? Потому что если бы деструктур
был тривиальным, то есть как у обычных примитивных типов, то на самом деле вот эта информация о
деструктурах не сохраняется. Вот для того, чтобы компилятор сохранил информацию о деструктуре,
я как бы притворился, что у меня деструктур какой-то особенный, он делает какое-то важное дело.
Ну так или иначе, что я делаю? Я выделяю память для хранения 1213 объектов A, вот, и дальше выполняю
некоторую страшную магию, которую делать нельзя, но я ее делаю просто чтобы показать, как устроен
конкретно мой компилятор. Вообще говоря, это не является нормативным способом, то есть так реально,
в общем случае, делать нельзя. Тут дисклеймер по этому поводу написан. Ну что я делаю? Смотрите,
я беру мой указатель, привожу его к указателю на sizeT и шагаю на один шаг влево. То есть я беру
мой указатель и говорю, что на sizeT шагов, то есть на 8 байт, нужно отойти влево. Вот отхожу влево
на 8 байт и читаю данные оттуда. Формально так делать нельзя, как вы понимаете, то есть то,
что находится в левее вашего массива, это не принадлежит вам, но я так все равно сделаю,
вам так делать нельзя. Давайте посмотрим, что произойдет.
И запущу. Вот. И на экране я вижу вот эти самые 1213, то есть ровно то число,
которое я указывал здесь. Ну, чтобы меня не заподозрили в том, что я специально подобрал
число, может кто-нибудь в чате написать свое число, мы проверим, кто первый. Давайте другое.
Я понял. Поколение мемов. Ладно. Компилируем, запускаем 6,9, 6,9. Вот. Нет, такое число я не буду
вводить. У нас трансляция упадет. Ну вот, в общем, мораль в том, что когда вызываете
ньюскворатными скопками, то есть компилятор предпринимает дополнительные действия. Он
выделяет то есть нужное количество памяти и плюс дополнительно выделяет 8 байт слева для того,
чтобы дилит мог понять, сколько деструкторов ему нужно вызвать. Вот. И эту информацию, собственно,
эту информацию даже мы можем прочитать. Но опять же, вот на конкретной системе, в конкретном
компиляторе. В других компиляторах может устроено по-другому, в других компиляторах может вот
эти вот лишние 8 байта никогда не выделяются. Вот. Окей. Продолжим. Ну, еще давайте чуть-чуть поговорим
про функции оператора new. Значит, у функции оператора new на самом деле есть несколько форм. То есть,
не только та форма, которую я показал. То есть, не только, скажем, можно не только передать там
количество байтов, которые нужно выделить, но можно передать какую-то дополнительную информацию.
Ну, в частности, вот есть первая форма, про которую мы поговорили. Вы просто передаете количество
байтов, которые нужно выделить, и к вам возвращается сырой указатель на эту память. Вот. Вы можете
передать в качестве оргумента std nothrow. Ну, специальную переменную, которая облина в сценарии
библиотеки. И эта перемена имеет тип std nothrow t. Так вот, если вы в оператора new, помимо размера,
передадите вот эту вот самую переменную, которая имеет этот тип, то будет выбрана, естественно,
эта перегрузка. И эта перегрузка просто делает то же самое, что и обычный оператор new. Просто она не
бросает исключений. То есть, вместо того, чтобы бросить исключения, она ведет себя как malloc. То есть,
она просто возвращает нулевой указатель в случае, если памяти недостаточно. Вот. И ровно вот этот
оператор new и вызывается, когда вы используете new std nothrow t. Ну, помните, когда мы обсуждали
исключения, мы говорили, что если вы new в круглых скобках передадите std nothrow, то это означает,
что new не должен бросать исключений. И вот он не бросает исключений ровно вот по этой причине, что вот
эта оператор ниу вызывает.. Точнее, вот эта операция new вызывает функцию оператора new, которая в качестве
второго аргумента принимает nothrow. Вот поэтому он не бросает исключений. Вот. И есть еще некоторая
особенная операция, ну, то есть, некоторая особенная функция оператора new, которая, в качестве второго
аргумента принимает указатель на указатель на память и вот это довольно интересная
функция оператор new потому что она реально не выделяет память вот прям вот не выделяет
память то есть если вы вызовите эту функцию не знаю оператор new 10 и передать и передать
какой-нибудь указатель ptr то никакого выделения памяти происходить не будет а вернет это функция
оператор new ровно тот же самый указатель что вы передали то есть эта функция ничего не
делает а просто возвращает ваш второй аргумент ну может показаться что это какая-то бесполезная
оператор new то есть она ни зачем не нужна и так далее на самом деле это очень важная это очень
важная функция оператор new и мы к ней обязательно вернемся вот она нам поможет решить что-то нам
поможет решить в общем это вот среди этих трех на сегодняшней лекции вот третья это самое
полезное в общем запомните ее вот ну и в общем случае в общем случае то есть понятное дело есть
много других функций оператора new более того на следующем слайде я покажу вы можете определять
свои собственные функции оператор new то есть вы можете перегружать оператор new вот и вызываются
они с помощью вот и вызываются они тогда когда вы зовете операцию new с вот таким синтаксисом то
есть если пишете операцию new и даже в круглых скобках указываете что-то то есть какие-то
аргументы то первым делом вас вызывается функция оператора new ну понятное дело в качестве
первой аргумента передается количество байт которые нужно выделить ну в данном случае сайзов
t вот а в качестве следующих аргументов передается именно то что вы попросили вот ну это я уже
говорил когда мы обсуждали вот как работает new с sd not role то есть операции new вы можете
передать какие-то аргументы вот это ну это вот новая вещь которую мы сегодня должны понять что
операции new вы можете передать какие-то аргументы и эти аргументы в итоге попадут в специальную
функцию которая называется оператор и вот и все здесь есть вопросы
тогда бежим дальше ну да как я анонсировал значит ну например вы можете переопределить
перегрузить операцию new да вы можете да вы можете перегрузить вы можете ввести свои собственные
операции new и более того вы можете переопределить встро reducing new ну например вот я переопределил
стоянную операции new вот таким образом то есть моя операция new она тоже принимает count ну и
она просто на самом деле вы говорит что ну я вот хочу выделить count byte то есть понятное
дело что обычная эта цель ничего не уводит но я хочу чтобы выводила ну и выделяю память
с помощью std-malloc. Ну вот, понятное дело, что так делать не стоит, потому что если вы
переопределяете операцию new стандартную, то она переопределяется на всю программу целиком.
Ну и если вы пишете какой-то файл и внутри своего файла переопределяете операцию new,
то есть какой-то другой разработчик, который пишет свою часть кода, то он будет крайне
удивлен, когда увидит, что операция new работает не так, как стандартная. Возможно, он этого не
хотел. Поэтому, естественно, переопределение глобальной операции new является плохим тоном,
так делать не стоит, но просто есть такая возможность. Скажем, если вы работаете над
каким-то небольшим проектом, вы понимаете, что вам нужна какая-то особая логика операции new,
и вы как бы всей командой договорились, что вам нужна такая особая логика, то, наверное,
это имеет смысл, но в общем случае нет. Вы можете определить свою собственную перегрузку операции new,
ну, например, написать свою перегрузку операции new, которая будет принимать в качестве дополнительного
параметра, буллевский флаг, нужно ли бросать исключение или не нужно, точнее, нужно ли всегда
бросать исключение или не нужно. Ну, например, если вы передали сюда true, то у вас new всегда будет
приводить к выбросу исключения BDLog. Если передали false, то он будет приводить к исключению BDLog,
только если у вас реально не хватает памяти. То есть, если вы вызываете new true, скажем,
t, то у вас всегда будет бросаться исключение. Если вы вызываете new false, t, то исключение будет бросаться
не всегда, только при необходимости. Ну, игрушечный пример, просто так можно делать. Кроме того,
операции new можно переопределять, и вот это, на самом деле, уже более-менее осмысленное
применение, вы можете переопределять или перегружать операции new для своих собственных структур или классов.
Ну вот, в частности, вы можете написать, если вы пишете функции оператора new внутри структуры или
внутри класса, то считается, что вот эта функция оператора new или оператор new с квадратными
скобками будет вызываться, ну, когда вы попытаетесь с помощью new выделить этот класс. То есть,
когда вы будете вызывать new a, будет вызываться вот эта штука. Когда вы вызываете new a с квадратными
скобками, будет вызываться вот эта штука. Ну, и вы можете написать какую-то свою логику,
ну, в общем, как угодно. Но самое главное, ну, то есть, одно из, наверное, главных применений, хотя не
очень часто используемых, точнее, крайне редко используемых, это ситуация, если вы вдруг по какой-то
причине хотите запретить выделять ваши элементы на стэке, ой, в куче. Допустим, у вас есть класс,
вы хотите просто запретить выделять его в куче по каким-то, не знаю, религиозным или каким-то другим
причинам, не хотите, чтобы эти объекты выделялись в куче. Тогда вы просто можете определить оператор new
и определить их как delete. Тогда объект и структуру a нельзя выделять в куче. Ну, никак. Все. Ну, вообще никак.
Ну, точнее, c++ язык возможностей, наверное, как-то можно это обойти, но вот нормативным способом не
получится. Вот, наверное, такой забавный факт. Вот. Да, ну, еще что-то стоит сказать. Значит, если вы
переоперили свою операцию new, то для них обязательно нужно написать свои версии delete. Вот это обязательно,
иначе у вас, ну, иначе undefinedBehaviour просто. Короче, если вы определили свой new по какой-то причине,
то нужно обязательно определить свой delete. Вот. Ну, здесь это написано. Ну, это скорее, ну, это не совсем
относится к тому, что я хочу рассказать, просто вот такой забавный факт. Можно операцию new
переопределять, тогда new будет вести себя по-другому. Давайте к более реальным вещам. Значит,
с функцией оператор new разобрались. Остались у кого-то какие-то вопросы? Сейчас пойдем дальше просто.
Окей, вопросов нет. Значит, теперь мы поняли, как выделять сырую память. То есть, если нам
нужна сырая память, мы поняли, что нужно воспользоваться функцией оператор new. Окей, но у нас
есть еще вторая эпостазь, которую мы не обсудили. Это, а как создать объект? Ну, хорошо, мы умеем
выделять сырую память. А вот, допустим, вот в этой сырой памяти я хочу создать объект. Как мне это
сделать? Какой у меня вообще есть способ создать объект или какой у меня вообще есть способ
вызвать конструктор? Ну, у меня есть способ вызвать операцию new. Но при этом я знаю, что операция new
у меня всегда вызывает функцию оператора new. То есть, она выделяет память и, во-вторых, она создает
объект. Так вот, смотрите, мне нужно как-то вызвать new new t. Но мне нужно сделать как-то так, чтобы new
не выделял память, а воспользовался памятью, которую хочу я. То есть, я хочу ему
предоставить какую-то память, ну, как-то передать в new какой-то указатель и сделать так, чтобы он
воспользовался этим указателем, чтобы создать там объект. Вопрос. Понимаете ли вы, как это сделать?
Смотрите, мы знаем, что операцией new можно передавать информацию. То есть, мы с этим
разобрались. То есть, мы знаем, что new можно передать какие-то аргументы. То есть, мы хотим new как-то
сообщить о том, что тебе не нужно выделять память, тебе нужно просто взять наш указатель и воспользоваться
им. Ничего не напоминает.
Третий вариант, оператор new.
Во, отлично. Да, давайте откатимся назад и посмотрим вот сюда. Я говорил, что это нам пригодится, и вот этот
момент настал. Да, у нас есть, условно, третья форма оператора new, которая принимает указатель. И вот эта
форма, она с этим указателем ничего не делает, то есть, она ничего не делает, ничего не взяет, она просто
берет указатель и возвращает его же. То есть, по сути, это оператор new подменяет выделение памяти
просто тем указателем, который вы ей передали. И все. Все. Вот это ровно то, что нам нужно.
Ну и вопрос, как мне заставить, ну то есть, ну и теперь понятно, что если я хочу, скажем, у меня есть
какой-то указатель ptr, ну не знаю, откуда-то мне его дали, и я хочу вот по этому указателю вот в этом
месте создать объекти pt. Мне достаточно просто вызвать new в скобках ptr t, ну и возможно какие-то
аргументы, возможно какие-то аргументы конструктора передать, там x и y. Что теперь тут произойдет? Вот
эта операция new, она вызовет функцию оператора new вот эту, и в качестве второго аргумента ей
передаст вот этот ptr. Эта функция оператора new выделять память не будет, а просто вернет нужный
указатель. Все. New, вот операция new примет этот указатель, и внутри этого указателя, то есть,
по этому месту памяти создаст нужный нам объект. Все. То есть, по сути, вот эта версия new, то есть,
вызывая new вот так, мы говорим, что нужно создать объект вот конкретно в этом месте в памяти. И
таким образом мы решили вторую проблему. Все. То есть, теперь мы умеем первое, выделять вторую
память с помощью функции оператора new, а во-вторых, умеем просто вызывать конструктор в нужном месте
в памяти. И делается это вот таким образом. Как это можно применять? Данная форма new,
которая не выделяет память, а просто создает объект в нужном месте, называется placement new.
Вообще формально placement new называется любая форма new, которая принимает аргументы. Но,
как правило, принято называть placement new именно вот такую форму, которая принимает указатель.
Какие приколы я теперь могу вытворять? Ну, например, я могу взять массив чаров на стэке. То есть,
могу взять просто массив byte на стэке и внутри этого массива создать объект. Объект типа T.
То есть, теперь есть у меня массив чаров, но внутри этого массива чаров реально расположен
объект типа T. Если я проинтерпретирую биты вот этого массива чаров как T,
то там будет реальный объект, к которому можно пользоваться и так далее. И пользоваться этими
объектами я могу, например, с помощью указателя ptr, который мне вернет new. Ну, undue вернет мне
собственно адрес объекта. Поэтому можно воспользоваться как объектом, так и ptr.
Ну и плюс я могу вручную создавать элементы в куче. Ну, как я это делаю? Я могу вызвать оператор
new. То есть, выделить нужное количество памяти для хранения объекта типа T. То есть,
сохранить указатель ptr и дальше по этому указателю создать объект. Вот это вот ровно всё,
вот это вот всё, эквивалентно, ну, по сути, в некотором смысле эквивалентно, просто вызову new T.
Вот это ровно то, что делает new T. Выделяет вторую память и дальше создает объект. Вот ровно
вот эти два действия мы сделали сейчас вручную. И мы умеем так делать. Окей, ну и тут возникает два
вопроса. Ну, смотрите, вот здесь у меня объект хранится на стеке. Что я знаю про объекты на стеке?
Про объекты на стеке я знаю, что для них автоматически вызывается деструктор. Но здесь я как бы вызвал
конструктор не совсем нормативным способом. То есть, я тут создал объект типа T в каком-то месте,
который на самом деле зарезервирован под какую-то другую переменную. Возникает вопрос, будет ли
вызван деструктор для этого объекта, который я создал с помощью new. Ну и второй момент, вот как во
втором случае мне корректно очистить память и вызвать деструкторы. Так вот, ответы следующие. В первой
ситуации компилятор, естественно, не догадается вызвать деструктор. Ну, потому что тут, по сути,
вы компилятор, ну, немного обманываете. Потому что вы говорите, что, ага, вот есть место в памяти, область
памяти, которая занимает объект. И это область памяти, это массив чаров. А дальше вы просто берете и
говорите, что, ну вот, на этом месте массива чаров вы создаете объект. Ну, естественно, когда вы
выходите из скобка, то есть, когда вы выходите из области действия, то есть, когда закрывается
фигурная скобка, компилятор смотрит на все ваши переменные и смотрит, ага, значит, вот есть
переменная там такая-то, нужно вызвать для нее деструктор. Дальше он смотрит сюда и видит, ага, есть
переменная типа char, типа массив чаров, и он уничтожит этот объект, точнее, уничтожит эту память
как массив чаров, а не как объект типа T. Потому что компилятор, в принципе, ну как ему понять, что вот
в этом месте, которое называется массив чаров, ну как он может догадаться, что там реально хранится
объект типа T. Ну, это же маразм, поэтому он так не делает. Поэтому, если вы создали объект вручную,
то есть вот вручное управление временем жизни, то есть, если вы вручную создали объект с помощью new,
то простите, но вы обязаны вручную его уничтожить, то есть вызвать деструктор вручную. И это, на самом
деле, вот первый способ, ну вот первые случаи в нашем курсе, когда вызов вручную деструктора имеет
смысл. Во всех остальных случаях нет. Вот если вы вручную создали объект сами с помощью placement
new, то вы обязаны его вручную удалить. Ну и во втором случае то же самое, так как вы вручную
создавали объект, то будьте добры вручную его уничтожить. То есть вы вручную должны сначала вызвать
деструктор для этого объекта, а потом вызвать оператор delete, то есть вернуть сурую память. На
самом деле вот эти две строчки можно заменить на deleteptr, ну как можно. Нельзя формально,
формально это define behavior, но скорее всего это будет работать. Я пробовать не советую,
просто такая информация. Ну просто delete можно вызвать только на те указатели, которые были
выделены с помощью операции new. А вы вызвали не операцию new, а вы как бы вручную все делали,
поэтому вручную нужно все удалять. Так, короче, вопрос есть? Вот что происходит здесь и что
происходит здесь? Понятно ли, почему я должен вручную вызвать деструктор и почему я должен
во втором случае тоже вручную вызвать деструктор и вручную вызвать оператор delete?
Окей, видимо вопросов нет. Ну хорошо, давайте вернемся. Теперь я утверждаю, что мы понимаем,
как устроен внутри себя stvector. Вот stvector устроен хитро, то есть он не просто вызывает
операцию new и операцию delete, он на самом деле вот так вот вручную на низком уровне управляет
памятью и управляет временем жизни объектов. Ну то есть формально, если вам нужен массив,
в котором size элементов и память выделена под capacity элементов, реально происходит следующая
вещь. Выделяется буфер размера size of tail умножить на capacity byte, то есть вот выделяется
большой буфер и дальше в цикле для каждой ячейки памяти от 0 до size вы создаете объект. То есть вы
создали объект здесь, вы создали объект здесь, создали объект здесь, создали объект здесь и все,
остановились. Теперь у вас вот эта часть, это size, а все остальное это capacity. И при этом вот эта
часть является непроинитерализированной, то есть там реально объектов нет. Поэтому вектор всегда
стремится к тому и достигает того, что у вас реально в каждый момент хранится size объектов.
Вся остальная память, она не проинитерализирована никак, то есть там объектов реально не хранится.
И это хорошо. Ну и как устроен destructor вектора? Ну, например, возможная реализация. Ну,
мы должны просто в цикле пройтись и уничтожить каждый элемент size, то есть уничтожить этот элемент,
этот элемент, этот элемент, этот элемент, ну и дальше освободить, вернуть память системе,
то есть вызвать функцию оператор delete. Таким образом, clear не просто восстанавливает size равным
нулю, но и вызывает destructor для size объектов, поэтому он работает за size, за o от size. Resize не
просто обновляет size, но и при необходимости вызывает destructor для лишних объектов и вызывает
constructor для дополнительных объектов, которые вы создали. Ну и также resize. Resize не только выделяет
память для capacity, но еще и переносит size элементов в нужные места. А остальные там лишние элементы,
то есть лишняя память, он никак не заполняет, поэтому на это время не уходит. Ну и, видимо,
пора сделать перерыв. Давайте 10 минут отдохнем и продолжим говорить про контейнеры. Так, давайте
сначала так. Есть вопросы? Если есть вопросы, давайте сначала разберемся, потом отдохнем.
Зачем нам может понадобиться самим вот вручную по конкретному указателю сначала выделить
струю памяти, а потом сделать там конкретный объект? Конкретно вам, наверное, не зачем. Если вы
пользуетесь стандартными классами типа vector, если вы пользуетесь стандартными классами, то вам
это не зачем делать, это все происходит за вас автоматически. То есть вот этот весь разговор про
operator new, про ручное создание объектов, ручное удаление объектов, это про то, ну это для того,
что вы понимали, как внутри устроен vector на самом деле. Возвращаясь к преамбуле,
которую я говорил в начале, если вы понимаете, что устроен vector внутри, то, ну я надеюсь,
что это там добавило вам знаний и небольшого понимания того, как это устроено, и вы можете
там vector пользоваться более эффективно. Реально вам лично, наверное, это не нужно. То есть самим
вручную вызвать operator new и так далее. Все это сделает за вас vector и любые другие классы.
Ну или ну такой более прагматичный ответ, зачем это вам нужно. У вас есть задание, задание vector.
В этом задании есть дополнительная часть. Вот если вы собираетесь ее решать, то вот вам
понадобится использовать это. И продолжим. Значит тут поступил вопрос, ну насколько я понял, да,
можно ли, скажем, вызвать условно, давайте тут. Ну опять же, если вопрос был не такой, то поправьте.
Ну типа можно ли делать вот так, можно ли вызвать ну обычный new, потом вручную вызвать
destructor, а потом operator delete. Ну скажем так, здесь так нельзя как минимум по двум причинам.
Ну первая причина, потому что если вы вызывали с помощью new, то нужно вызывать delete с квадратным
скобками. Это первое. А второе, скорее всего, если вы тут позовете квадратные скобки, то опять же
скорее всего это заработает, но формально с точки зрения языка это undefined behavior. Почему? Потому что
в стандарте жестко прописано, что если вы уже вызываете new вот таким образом, то и вот этот вот
указатель вы тоже должны для него вызывать delete с квадратными скобками. То есть логика такая,
если вы управляете памятью вручную, то вы как бы должны делать все вручную. То есть вручную вызывать
operator delete и destructor. Если вы делаете это не вручную, то с помощью операции new и операции delete,
то это надо делать с помощью операции new и delete. Еще до перерыва был вопрос, зачем нам это нужно.
Я подумал, то есть, возможно, человек-миловедующий другую интерпретацию этот вопрос. Давайте я на другую
интерпретацию вопроса отвечу. То есть не для чего это конкретно нужно нам вручную, а для чего это
вообще пригождается. Ну вернемся и к начальной проблеме, которую мы поставили до того, как это
обсуждать вот сюда. Мы говорили о том, что, смотрите, если бы это не было так, то есть если мы не
могли вручную это делать, то есть если бы не было такой возможности, то здесь при выполнении resize и
clear нам бы приходилось держать в памяти целую кучу, в частности 90 лишних лекторов, которые
имеют размер миллион. То, что мы умеем вручную управлять память, то есть вручную управлять
в временном жизни объекты, это на самом деле классно. Почему? Потому что мы можем, не уменьшая сам
буфер, не уменьшая сам буфер вот это capacity, мы можем уничтожить вот эти вот объекты, чтобы они
там не занимали лишние ресурсы. Ну а как вы понимаете, если у меня там хранятся вектора размера миллион, то
они жрут много памяти. Ну или в принципе другие объекты. Это вот одно объяснение. Второе объяснение
здесь. Я теперь могу в векторе по сути хранить элементы, которые не имеют конструктора по умолчанию.
Почему? Потому что при вызове резерв мне теперь не нужно конструктора по умолчанию. Резерв
мне лишь выделяет сырую память. Сырая память ничего про объекты не знает. Теперь я могу
собственно делать pushback и делать pushback нужных мне объектов без вызова конструктора по умолчанию и
так далее. Вот и второй момент. Ну и третий момент. Представьте себе такую ситуацию, что вам
что-то приходит с консоль, то есть вам приходит какой-то вход, и в зависимости от входа, типа если х,
то нужно там сказать, ну не знаю, у вас есть там, ну какая-то переменная а, и в зависимости
того, если он пришел х, то вам нужно в а что-то записать, а иначе в а ничего не нужно записывать.
Но при этом, чтобы сохранить что-то в переменную а, вам эту перемену нужно создать. То есть вам
нужно создать эту переменную. Эта переменная должна создаться там с помощью конструктора по умолчанию,
ну или с помощью какого-то другого конструктора, ну и дальше вы там ее держите в памяти. Ну а теперь
снова представьте, что это какой-то тяжелый объект. И чтобы как бы что-то ему присвоить,
вам нужно как бы создать этот объект. А этот объект тяжелый, то есть его долго создавать.
Поэтому, чтобы этого не происходило, в standard-ability.x++ есть такой класс std-optional.
Вот этот и класс std-optional, он параметризуется типом t, и вот std-optional он хорош тем, что он не
создает объект до тех пор, пока вы не попросили его создать. Вот если вы объявили переменную типа
std-optional, которую вы, кстати, будете обсуждать на семинарах, вот на семинарах вы на примере
класса std-optional попробуете все эти трюки поделать. Так вот, если вы объявите переменную типа std-optional,
то std-optional просто-напросто выделяет память под вашу переменную, но при этом объекта
само не создает. То есть никаких дополнительных сложностей на создание объекта вам тратить не нужно.
Ну и даже уже в зависимости того, нужен вам будет впоследствии от объекта или нет,
вы можете там что-то создать или не создавать. Опять же, повышение эффективности программ
за счет того, что вы избегаете лишних созданий, лишних вызовов конструкторов, если они вам реально не нужны.
Окей, это было продолжение секции с вопросами. Теперь давайте пробуем быстро закончить с
вектором и пойти дальше. Значит, помимо того, что у вектора есть методы insert и pushback, у вектора есть
еще размещающие методы, это emplace и emplaceback. В общем, их ключевое отличие заключается в том,
ну давайте для начала с проблемой определимся. Ну вот снова, у меня есть вектор векторов, то есть
ну или вектор каких-то тяжелых объектов. Когда я вызываю вектор, ну когда я вызываю vw.pushback и
там pushback какой-то вектор, потенциально большой, точнее, я понимаю, что мне нужно внутрь вектора
спихнуть еще один вектор размера 10 или какого-то другого размера. Что мне нужно сделать?
Мне нужно написать вызов конструктора этого вектора и передать в pushback. То есть что у меня
происходит? Создается временный объект, а дальше этот временный объект перемещается внутрь вектора.
Ну и то же самое происходит с insert. Если мне нужно в середину вектора заинсертить какой-то
третий вектор, то снова мне нужно создать временный вектор, и потом этот вектор будет
перемещен в нужное место. То есть тут как бы тратится лишнее время, лишнее время на то,
чтобы переместить этот вектор и так далее. Тут появляюсь вопрос, а что если у меня как бы
для какого-то класса нет перемещения условно. Или нет копирования. Ну допустим, нет перемещения.
Вот копирование есть, а перемещения нет. Копирование при этом дорогое. И тогда,
что будет происходить? У меня создается объект и дальше он будет копироваться в нужное место.
То есть, опять же, допустим, копия дорогая.
Что делать?
Так вот, методы emplace и emplaceback позволяют вам
разместить сразу объект в нужном месте.
То есть, что вы делаете? Вы теперь не создаете объект заранее,
а вы просто передаете параметры конструктора.
То есть, вы передаете параметры конструктора, скажем, 10 и 1, и 5 и минус 1.
Что это означает? Это означает, что этот метод возьмет эти аргументы
и непосредственно в нужном месте сразу же создаст объект с этими параметрами.
Без лишних копий, без лишних перемещений.
Короче говоря, мораль, как правило,
использование emplaceback и emplace гораздо эффективнее,
ну или не гораздо, ну просто эффективнее,
чем использование обычных pushback и insert,
потому что это позволяет вам сэкономить на копированиях и перемещениях.
Ну и как бы, да, мы где-то уже видели такое,
что мы передаем не сами объекты,
а параметры конструктора или что-то еще.
Ну, в частности, когда мы обсуждали MakeUnique и MakeSharad.
Ну и здесь, собственно, все это выглядит ровно так, как было раньше.
То есть, вы принимаете универсальную ссылку,
дальше все параметры конструктора форвардите в конструктор объекта T.
То есть, сразу же в нужной позиции
создаете объект с нужными параметрами конструктора.
Вот это, ну, так это и работает.
То есть, теперь с помощью синтактиса,
размещающего и new, мы можем сразу создать объект
с нужными параметрами конструктора в нужном месте.
Ну и давайте перейдем к нескольким полезным советам
по работе с std-вектор.
Ну, короче, просто некоторые трюки,
которые позволят более эффективно пользоваться вектором и так далее.
Первый, возможно, банальный совет – это использовать резерв.
Классический подход к решению задач,
которые у нас есть в контесте,
ну, или, в принципе, любых задач из жизни,
это примерно такой.
Вам откуда-то приходит информация о том,
сколько элементов вам нужно хранить,
и все эти элементы, естественно, вы будете хранить в классе вектор.
Ну и дальше вы последовательно считываете все эти n элементы,
и добавляете в конец вектор V.
В чем здесь неэффективность?
А неэффективность здесь заключается в том,
что вы создали изначально пустой вектор,
и потом, ну, добавляете все элементы в конец.
А при добавлении в конец вектор иногда перевыделяет память.
У вас вектор расширился до определенного момента,
�а перевыделил память.
Вот почему оно передвеляет память?
Ну, потому что вы вектору не сообщили,
вообще заранее не сообщили,
сколько элементов он должен хранить.
хранить. Так вот, чтобы не выполнять лишнее переводеление памяти, вам нужно перед тем,
как что-то запихивает вектор, вызывать резерв. Ну как это работает? Вот вы считали, сколько данных
вам понадобится, ну или как-то поняли, сколько данных вам понадобится, создали вектор, сразу
зарезервировали нужное количество памяти, и уже дальше делаете pushback. И вот тут уже никаких
перелокаций не происходит. Почему? Потому что вы заранее выделили нужное количество памяти и уже
потом просто-напросто заполняете эти все эти все ячейки. И все. У меня, по-моему, есть по этому поводу
какая-то демонстрация. Что здесь происходит? У меня есть два теста. Тест no-reserve, то есть,
ну вот, собственно, тот самый код без резерва, и есть код с резервом. И, собственно, все что здесь
происходит, я просто измеряю время, за сколько работает тот или иной код. Но давайте посмотрим
на разницу во времени работы тест с резервом и тест без резерва. Что мы сделаем?
Резерв трикнули. Давайте сразу включим оптимизации компилятора, чтобы сравнить реальное время.
Запускаем. Вот, и видим следующую вещь. То есть там, по-моему, 500 тысяч элементов. Да, я заполняю 500
тысяч элементов. И что я вижу? Если я выполняю резерв заранее, то там все работает в две тысячи
секунды. Если я делаю все без резерва, то все выполняется в четыре тысячи секунды. То есть,
в два раза, то есть, без резерва и с резервом, отличие в два раза. Ну и, на самом деле, понятно, откуда берется
это в два раза. Это все истюарь исследует, на самом деле. Если вы помните амортиционный анализ,
как работает динамический массив, то там возникает такой коэффициент, как k на k-1, где k – это коэффициент
решения. Вот, то есть, если вы вектор увеличиваете каждый раз в два раза, то, то есть, k равно 2, то у
вас количество лишнего, то есть в общее количество действий равно 2n. Вот, если вектор увеличивается в
три раза, то общее количество действий у вас равно 3 second n. Ну и так далее. Ну и, собственно,
мы здесь, на практике, вот это вот самое в два раза. Ну есть еще один забавный пример, по-моему. Да,
Это реальный код, который я видел два года назад, в общем, как делать не стоит.
Даже если вы используете резервы, если вы пользуетесь векторами, это все равно не спасает вас выстрела себе в ногу и всяких неэффективностей.
Вот, например, один из студентов делает следующую вещь.
Вот у вас есть вектор V, и он понимает, что ему нужно вставить один дополнительный элемент каждый раз.
И вот чтобы вставить один дополнительный элемент, естественно, нужно зарезвировать память.
Подает один элемент.
То есть, у меня есть size, мне нужно добавить один элемент.
Значит, мне нужно обеспечить то, чтобы как бы вектора хватило, чтобы добавить этот дополнительный элемент.
Ну и соответственно, в цикле я каждый раз вызываю резерв на один больше.
Ну и я думаю, я надеюсь, вы понимаете, почему это приведет так.
Значит, надо выключить LOL.
Вот, запускаем.
Ну и уже, в общем, понятна мораль.
Да, тут немного время изменилось, но все, собственно, в сети же в два раза, все тоже в два раза отличия.
Когда-нибудь остановится.
Ну, в общем, а, все, вот, 18 секунд.
Понятно, что произошло или объяснить?
Ладно, давайте объясним, в общем, на всякий случай.
Как работает резерв?
Значит, изначально у меня вектор имеет нулевой размер и нулевой capacity.
Я здесь говорю, что мне нужно зарядировать память под один элемент.
Хорошо, я создаю массив из одного элемента, добавляю его туда.
На следующей тр Professional мне резерву говорит, нужно зарядить память по два элемента.
Хорошо, я перевыделяю память на два элементы, добавляю элементы.
А дальше мне говорит, перевыделить память по три элемента.
Перевыделяю память по три элемента и так далее.
То есть я каждый раз перевыделяю память и увеличиваю массив на единицу.
Понятно, почему это плохо?
То есть в итоге у нас все вылилось в квадратичную сложность этого цикла.
нужно сделать один резерв заранее, а не много резервов. Мораль понятна, да? Можем идти дальше.
С советом первым разобрались? Все разумно? Хорошо, значит, второй совет. Смотрите, мы знаем,
что удаление из середины массива, оно достаточно долгое. То есть, если вы делаете eRace и удаляете
элементы откуда-то из середины, то потенциально это работает за линейное время. Ну понятно,
нужно удалить элемент и дальше все элементы сдвинуть на один влево. То есть, если удаляете,
допустим, из начала, то это может привести к линейной сложности от размера всего массива.
Так вот, есть трюк, который позволяет удалять вам элементы из массива, из вектора,
ну и вообще из любого другого контейнера за единицу. Но, правда, при одном условии,
что если вам действительно не важен порядок исследования элементов в векторе, то есть,
если вам в векторе не важно, в каком порядке идут элементы, то вы можете это сделать за единицу.
И трюк, на самом деле, очень простой. А у нас должна отображаться презентация?
По идее, да. Давайте вернемся. Отлично. Ну в общем, да, вот то, что я говорил. Нам
нужно удалить все элементы из середины вектора. Соответственно, это можно сделать за единицу,
если вам не важен порядок исследования элементов. То есть, если вам не важно,
то есть, если вам реально порядок элементов не важен, то есть, если у вас массив не отсортирован,
или вы не требуете, чтобы этот элемент обязательно стоял на третьей позиции,
этот элемент обязательно стоял на четвертой позиции, вы можете удалять элементы за единицу.
Как это происходит? Ну, допустим, вам нужно удалить элемент х, вот этот элемент. Что вы делаете?
Что мы знаем вообще про вектор? Мы знаем, что удалять из вектора эффективно можно только из конца.
Поэтому давайте просто возьмем элемент у, который находится в конце, и переместим его на место х.
То есть, выполним следующую строчку. В той позиции, где находится х, туда мувнем элемент с конца.
То есть, теперь вот тут, после этой операции, на месте х у меня расположен у. Ну а на месте бывшего у
теперь расположен какой-то пустой объект условно. И теперь этот пустой объект я могу спокойно удалить
за единицу с помощью popback. Таким образом, получилось так, что я элемент из середины,
то есть элемент х, удалил за от единицы. И при этом все остальные элементы у меня остались в векторе.
Трюк понятен?
Да.
То есть, на практике довольно часто испортится, но опять же повторюсь еще раз, что если вам не
важен порядок элементов в векторе, если у вас вектор отсортирован, естественно, это не работает.
То есть, после этого у вас вектор не будет отсортирован. Я думаю, это понятно.
Ну и еще одна очень популярная идеома или очень популярный прием, это erase-remove-идеома.
Задача такая. Представьте себе, что вам нужно из вектора удалить все элементы, которые
удовлетворяют определенному критерию. Ну, допустим, все четные элементы, все нечетные, или все
элементы равные нулю. Но в данном случае я удаляю все элементы, которые равны нулю.
Как можно сделать, не зная эту erase-remove-идеома?
Можно сделать так. Мы просто проходится по массиву, и если я встречаю ноль, то вызывать erase.
Если я встречал ноль, то я вызываю erase, если я встречал мне ноль, то я просто увеличиваю счетчик на единицу,
перехожу к следующему элементу и так далее. Естественно, это работает в худшем случае за n квадрат.
Почему? Ну, потому что вы там проходите по всем элементам, и для каждого элемента потенциально
вызываете erase, а erase работает за линейное время. Поэтому идея заключается в следующем.
Идея заключается в том, чтобы использовать последовательность из двух алгоритмов.
Первый алгоритм — это remove, а второй — это erase. Что делает remove?
Вот, допустим, у вас есть вот такой массив. Значит, если вы вызвали remove 0, то есть если вы говорите
убрать все нули из этого вектора, то на самом деле std remove, вот эта вот функция, она не удаляет их,
она просто переупорядочивает ваш массив так, чтобы все нули или все те объекты, которые вы
просили, чтобы они оказались в конце. То есть после вызова remove у вас получится вот такой массив —
1,24, 0,0,0. При этом remove работает за линейное время, ну и это, на самом деле, наверное, неплохое
упражнение. То есть попробуйте самостоятельно резать remove, то есть вот такой вот remove,
который принимает значение, и переупорядочивает элементы так, чтобы все остались в конце,
а относительный порядок всех остальных элементов, то есть 1,24, например, остался таким же. То есть не
просто поставить все элементы в конец, а те, которые не равны 0, поставить в начало, а переставить именно так,
чтобы относительный порядок элементов сохранился, но при этом все нули остались в конце. Этим занимается
remove, и remove умеет это делать за линейное время. И теперь смотрите, теперь у меня все нужные мне
элементы, то есть те элементы, которые нужно удалить, они оказались в конце. Ну а с конца я умею
удалить эффективно, причем я могу их удалить, да и с конца я могу удалить довольно эффективно,
за линейное время. То есть я вызываю erase и говорю, что мне нужно удалить все элементы от begin,
то есть вот этого элемента, до конца массива, то есть до end. Это zeros, begin, а это end. Да, ну тут
надо сказать о том, что такое zeros, begin, но дело в том, что функция stay-remove, она возвращает указатель
вот zeros, begin, она возвращает указатель на первый, то есть на первый удаленный элемент, точнее на
первый элемент, который там был перемещен вправо, ну точнее на начало вот этой самой концевой
последовательности. Вот и дальше вы, начиная с этого элемента и до конца, удаляете все элементы.
Естественно, это тоже происходит за линейное время. Все, то есть мы таким образом улучшили
сложность нашего алгоритма, удаление всех элементов, всех элементов, которые удовлетворяют
некоторому критерию, с квадратичной до линейной. Здесь тоже все понятно, да?
Да. Ну отлично. Так, ну на этом, видимо, с вектором все. Давайте идти к следующим контейнерам. Ну и
следующий контейнер на очереди это std-deck. std-deck представляет из себя шаблонный класс в двунаправленной
очереди, и вообще говоря, std-deck ведет себя ровно так же, как std-vector, то есть с деком можно делать
то же самое, что и с вектором, то есть добавлять элементы в конец, там обращаться к элементам по индексу
за вот единицы, там узнавать его размер, ну и так далее, и так далее. В общем, дек это, по сути,
обычный вектор, но с парой изменений. Дек, помимо того, что позволяет эффективно добавлять
элементы в конец, он еще позволяет добавлять элементы в начало за вот единицы, то есть вектор,
естественно, такого делать не может, потому что это обычный массив, а в дек, в направленную очередь,
вы можете добавлять элементы и в начало, и ударять из начала за от единицы. Ну и так же у него,
в отличие от вектора, нет методов reserve и capacity, но при этом есть shrink to fit. Ну, просто дело в том,
что дек устроен несколько иначе, чем вектор, об этом мы еще поговорим. Значит, еще одна ипостаси дека,
в чем дек, скажем так, лучше, чем вектор. Давайте посмотрим на следующий пример. Вот у меня есть
вектор, и я в какой-то момент сохранил ссылку на пятый элемент вектора. То есть у меня есть
int % x, я сохранил ссылку на пятый элемент. Дальше я вызываю pushback и говорю x равно нулю. Что здесь
может пойти не так? Как вы думаете? У нас вектор перекопировался в другое место, и x уже указывает
на не ту область памяти, которая нам нужна. Да, смотрите, что происходит. То есть у вас есть
массив, вы взяли там пятый элемент и сохранили ссылку x вот сюда. Дальше вы выполнили pushback,
и так могло получиться, что pushback просто взял и расширил ваш массив. А что такое расширение
массива? Расширение массива — это удаление старого и создание нового. И теперь у вас x ссылается или
указывает на элемент, который, по сути, уже удален, то есть который вам вообще не принадлежит. И вот
такая ситуация называется инвалидация ссылок. То есть если вы в какой-то момент сохранили указатель или
ссылку в середину массива, в какой-то элемент массива, то в определенный момент, даже если вы этот
элемент никак не удаляли, то есть никак его не изменяли, он может просто-напросто инвалидироваться.
То есть вот так, короче говоря, этой ссылкой указателем нельзя больше пользоваться в какой-то
момент. Потому что у вас вектор периодически расширяется или уменьшает свой размер, а это
происходит при этом при этом происходит перевыделение памяти, и теперь ваш x или ваш
указатель ссылается на область памяти, которая, вообще говоря, не принадлежит вам. Это, естественно,
defined behavior и все плохо. Так вот, дек таким такой проблемой не обладает. Тоже самое
может произойти с указателем, вот здесь все показано. Так вот, дек таким проблем не
обладает. То есть дек, даже несмотря на то, что дек действительно, то есть дек тоже, как и вектор,
он расширяется. Дек тоже может там динамически измерять свой размер и так далее, но при этом дек
всегда позволяет вам обращаться по указателю, по ссылке к тем элементам, которые вы не трогали.
То есть если вы элемент никак не удаляли, не удаляли элементы перед ним и так далее, то есть
вообще никак не двигали, то ссылки и указатели, они всегда валидные. Даже если вы выполнили pushback
и теоретически pushback привел к увеличению памяти, все остается нормально. То есть дек не
инвалидирует ссылки и указатели. Вот еще один момент. То есть дек, в отличие от вектора, умеет
эффективно добавлять в начало и удалять из начала. Второе, дек умеет, ну дек не инвалидирует ссылки
и указатели. Соответственно, вроде как получается, что дек это некоторая такая улучшенная версия вектора,
и зачем нам вообще вектор, если есть такой замечательный дек. Ну, как вы понимаете,
собственно, бесплатных обедов не бывает, но фриланч. То есть за все приходится платить. Но, естественно,
дек, несмотря на то, что он такой крутой, естественно, на это все, на поддержание вот этих свойств приходится
тратить какие-то ресурсы. Какие-то ресурсы по памяти, какие-то ресурсы по времени. И вот тут нужно
коротко поговорить про то, как устроен дек. Значит, я не буду подробно на этом останавливаться. В общем,
совсем коротко это выглядит так. Давайте, главная проблема, как мне поддержать возможность
эффективного добавления в начало, добавление в конец и не инвалидации ссылок и указателей.
Все устроено следующим образом. Представь себе, что у меня есть такой дек. Ну, сейчас я нарисую и
поясню, что я имею ввиду. Значит, дек устроен примерно вот таким образом. Это front, это back. Значит,
как устроен дек? Дек на самом деле хранит внутри себя массив, массив указателей на динамические
массивы. То есть дек – это массив указателей на динамические массивы. То есть каждый вот это динамический
массив, он хранит внутри себя данные. При этом, как все устроено. То есть, данные расположены
последовательно. Последовotechnology друг за другом. То есть, это нулевой элемент, это первый,
Это будет 3, первый, второй, второй, это второй, 3, 4, 5, и так далее.
То есть, вы идёте по одному динамическому массиву.
However, once the dynamic mass is finished,
вы переходите к следующему динамическому массиву
и начинаете проходить по нему.
Все динамические массивы расположены друг при другу,
но их указатели расположены друг за другом.
Поэтому, вы понимаете, какой массив за каким следует,
что происходит при добавлении элемента, скажем, в начало, вот здесь.
Допустим, я добавил кучу элементов начала. Что у меня произошло? Давайте посмотрим.
Значит, если я надобавлял кучу элементов начала, то у меня центральный массив целиком заполнился.
Соответственно, так у меня центральный массив целиком заполнился, и мне больше некуда добавлять элементов начала,
я перехожу на ступень выше, то есть вот в эту ячейку, и там создаю, ну скажем, новый дополнительный динамический массив.
И начинаю заполнять его. Теперь это фронт. Но тут back остаётся на месте. Вот так.
То есть таким образом я поддерживаю операцию добавления за единицу. То есть я либо за единицу добавляю элементы в нужный мне массивчик,
либо если у меня места не хватает, я просто выделяю дополнительную память, то есть сохраняю вот сюда новый указатель на буфер,
и начинаю заполнять его. То же всё происходит за единицу. Что если у меня вот этот вот внешний массив,
что если у меня у внешнего массива закончилась память? Ну я могу сделать, например, следующую вещь.
Я могу сам внешний массив расширить. Вот эти у меня три массива, которые у меня были до этого.
И просто перенести указатели вот сюда. Ну точнее, давайте более корректно нарисуем.
Вот я расширил внешний массив и просто перекинул указатели на старые массивчики, которые у меня были до этого.
Ну а это, естественно, удалился. И таким образом становится понятно, почему у меня не инвалидируются ссылки указателя.
Потому что у меня, если у меня есть какая-то ссылка X, которая ведет вот сюда, то даже при приведении памяти она останется на месте.
Потому что сами вот эти массивы, я никуда не... ну то есть я с ними ничего не делаю. Я их не удаляю, я их не расширяю.
Расширяется у меня лишь внешний массив, который хранит указатели. Ну и теперь, соответственно, если мне нужно добавить элементы какие-то в конец,
и вот этот массив у меня допустим заполнен, то я расширил массив указателей, и дальше в этот массив добавляю очередной внутренний массив.
И теперь вот это back. Понятно? То есть у меня ссылки и указатели не инвалидируются,
потому что сами вот эти массивы, где хранятся элементы, с ними ничего не происходит. То есть я их не перевыделяю, они просто как были выделены в памяти, так они и остаются.
То есть единственное, что меня перевыделяется, это вот этот самый внешний массив, который содержит указатели.
Ну а когда я выделяю новый массив с указателями, мне достаточно просто эти указатели скопировать быстро, и все.
То есть перенос старых данных в новые происходит просто переносом указателей, и все. При этом сами массивы, которые хранят данные, они остаются на месте.
Ну и понятно, что в такой парадигме можно реализовать и доступ по индексу за единицу, и в общем доступ по индексу тоже можно определить за единицу.
То есть если вы находитесь в начале здесь, то я думаю понятно, как определить, где находится n-тый элемент.
То есть вы просто смотрите, сколько элементов здесь, ну и даже смотрите просто количество заполненных массивов здесь.
То есть просто за несколько операций деления понимаете, в какой массив вам нужно прийти, и в какой ячейке этого массива находится нужный вам элемент.
Все понятно.
Ну и естественно за это удовольствие приходится платить, в частности. В чем тут неэффективность?
Ну я думаю понятно, что доступ к элементу по индексу происходит гораздо дольше, чем в случае вектора.
То есть в векторе вам нужно просто выполнить адресную арифметику. То есть взять начало и отступить, там нужно количество шагов вправо.
В случае с тдек вам нужно выполнять деление, вычислить, в каком массивчике у вас хранится элемент, дальше внутри этого массива понять, в какой ячейке у вас находится элемент.
В общем доступ по индексу у вас происходит дольше. Плюс тдек хранит свои данные не непрерывно.
То есть если вектор хранит свои данные непрерывно в памяти, то тдек хранит свои данные в несколько разрозненном виде.
То есть этот массив может находиться в одном месте в памяти, этот массив может находиться в другом месте памяти, третий массив вообще в третьем месте в памяти.
Но естественно вот такие вот прыжки по памяти они тоже ни к чему хорошему не приводят.
А вектор позволяет довольно эффективно, когда вы сгружаете данные из вектора, то есть вам можно загрузить целую область памяти целиком,
и дальше она в кэше процессора быстро обрабатывается, и все работает гораздо быстрее.
Ну в общем мораль, используйте старый добрый принцип C++, не плати за то, что не используешь.
То есть если вам реально не нужны вставки в начало, если вам реально не нужно использовать инвалидацию ссылок или указателей, то вам дек на самом деле не нужен.
Как правило в 95% случаев вам нужен вектор, и вектор работает быстро, эффективно, и все. Вот такая мораль.
Ну и дальше давайте коротко пройдемся по спискам, потом сделаем перерыв.
В качестве списочного контейнера в языке C++ есть такой класс, как std-list.
std-list – это шаблонный класс двухсвязанного списка.
Ну понятно, какие у него методы есть. У него есть методы pushback, pushfront, emplacement, emplacement.
Ну в общем все то же самое, что есть у дека или у вектора.
Понятно, что в связной списке вы можете добавлять элементы как конец, так и в начало, причем все зовут единицы.
Вы можете обратиться к первому элементу списка, к последнему элементу списка с помощью метода front и back.
А вот к остальным элементам списка обратиться довольно сложно.
Дело в том, что у листа нет квадратных скобок и нет методы add.
Ну понятно почему, потому что вы обратитесь к третьему элементу листа, вы не можете просто воспользоваться квадратными скобками.
То есть вы не можете просто сказать, что давайте от первого элемента возьмем плюс три и сразу прыгнем туда.
Все-таки лист – это связанная списка, и чтобы получить третий элемент, вам нужно последовательно пройтись по трем элементам.
И чтобы это сделать, вам нужно использовать такую штуку как итератор.
Которую я планировал рассказать сегодня, но посмотрим как получится, возможно в следующий раз.
Ну так или иначе, доступ к элементам листа осуществляется с помощью итератора.
Ну и так как лист устроен как двухсвязанный список, вставка и удаление в любое место списка осуществляется за единицу.
Ну я думаю понятно, что если вам нужно вставить элемент в какую-то позицию, то как это происходит?
Ну вы просто перевешиваете указатель сюда, вы сюда, и вот так.
То есть вы просто провязываете четыре указателя, и все работает быстро за единицу.
Ну и понятно, что в отличие от вектора, он не инвалидирует ссылки указателей на элементы.
То есть если у вас есть этот элемент, то неважно, вставили ли вы элементы после него, вставили ли вы элементы до него.
Ссылка на этот элемент всегда будет жить, то есть она всегда будет корректной.
Потому что сама ячейка, сам узел, он остается в памяти всегда.
Не важно, вставили в начало, вставили в конец.
Про список, что самое главное, наверное, нужно знать, это про методы splice.
То есть это, наверное, та операция, которая позволит вам довольно эффективно пользоваться стелестом.
Ну смотрите, допустим, у вас есть два списка, там ваш список и какой-то другой список.
И вам нужно быстро перенести элементы из одного списка в другой список.
Естественно, вы можете воспользоваться методами insert и erase.
То есть вы можете сделать insert well, то есть вызвать insert, и дальше вызвать erase у other.
То есть вставить элемент в well и удалить у other.
И тут есть небольшая неэффективность, которая заключается в том, что при вставке элемента в well,
то у вас, естественно, создается некоторый новый узел.
То есть условно создается новая нода.
То есть это не то, как устроено C++, ну просто как бы в алгоритмическом смысле.
На вас есть указатель на prev, у вас есть указатель на next, и у вас есть сам элемент value.
Так вот, когда вы вызываете insert, у вас создается новая вершина.
То есть вы создаете новую вершину, и только потом ее вставляете в список.
А дальше берете другой вектор и оттуда удаляете старую вершину.
Так вот, смотрите, если у вас в другом списке, вот здесь какой-то другой список.
Вот если у вас есть, если у вас в другом списке, если вы хотите взять этот элемент и перенести его в новый список,
вы же можете просто взять и этот узел, без создания, просто взять и украсть к себе.
Да, то есть это гораздо эффективнее.
И ровно этим и занимается splice.
Вот, то есть как работает splice.
Значит, у splice есть три формы.
Первая форма это, когда вы задаете конкретную позицию, скажем, вот у вас есть ваш список,
и есть какой-то другой список, давайте я его так изображу.
И допустим, вы хотите вставить элемент вот на эту позицию.
То есть вы хотите, чтобы в этой позиции теперь стояли все элементы другого списка.
Ну тогда вы вызываете splice, и у вас происходит следующая картина.
Давайте, один, два, три, четыре.
Теперь тут становится элемент один.
Дальше, после элемента один, в позиции один встал другой список.
То есть вы просто взяли и все узлы перенесли туда.
То есть просто перенесли ссылки.
И заполнили дальше элементами 3 и 4.
Вот это первая форма splice.
Вторая форма splice позволяет перенести вам не все элементы другого списка сразу,
а только один элемент.
Ну, я думаю, тоже понятно.
Вот у вас есть один список, вот у вас есть другой список.
Вы хотите вот этот элемент перенести вот на эту позицию.
При этом на этот элемент у вас есть итератор elm.
Но опять же, что-то по итераторам поговорим в следующий раз.
Просто можно считать, что это некоторый указатель на элемент.
У вас есть указатель elm на этот элемент.
У вас есть позиция pos, в которую нужно вставить этот элемент.
И вы делаете splice.
И splice устроен в следующем образом.
Вы просто берете и провязываете указатели с этим списком.
А эту связь разрываете.
Все, то есть никаких затрат на создание нового узла у вас не уходит.
То есть вы просто как бы меняете указатели списка друг другу, и все.
Ну и есть третья форма splice, которая позволяет, скажем, ну опять же, давайте нарисуем.
Вот у вас есть такой список, и у вас есть вот такой другой список.
И вы хотите перенести, скажем, не один элемент из другого списка и не весь список целиком.
А вы хотите перенести конкретные элементы, скажем, вот отсюда до сюда.
Ну, естественно, полуинтервал, то есть по последним не включите.
То есть, по сути, вы хотите взять вот эти элементы и перенести их вот в эту позицию.
Вот взять вот эти элементы и перенести их в позицию номер один.
И тут возникает интересный вопрос, а за сколько работает вообще вот этот splice?
И в догонку новый вопрос, а за сколько работает метод size внезапно?
Так вот, ответ заключается в следующем.
Дело в том, что вот этот splice, ну несмотря на то, что его можно реализовать за единицу, как вы понимаете,
то есть тоже можно просто взять вот этот указатель, провязать сюда,
взять этот указатель, провязать сюда.
То есть тоже поменять значение четырех указателей, и по сути, вы получите то же самое.
Но проблема заключается в том, что если бы это можно было делать за единицу,
то если бы это реально было реализовано так, то нельзя было реализовать size за единицу.
Понимаете почему?
Понимаете почему, вот если бы splice работал за единицу, то size обязан было бы работать за o от n.
Понимаете ли вы почему так?
Ну хорошо, объясню. Да-да, слушаю.
Ну, при вставке за единицу мы просто привязываем начало и конец,
и мы не знаем, сколько элементов было между ними.
Да, отлично.
То есть нам нужно пройти и посчитать их.
Да, правильно. Смотрите, если у меня splice выполнен за единицу,
ну смотрите, вот в данной версии splice я не знаю, сколько.
Сколько элементов я переставил из одного списка в другой?
Смотрите, если я переставляю элементы одного списка в другой список,
то мне нужно как-то обновить l.size и надо как-то обновить other.size.
Но я не знаю, сколько элементов.
Чтобы мне посчитать количество элементов между первым элементом списка и вторым элементом списка,
мне нужно их как-то посчитать.
Если я не хочу их считать, то тогда я должен как бы смириться с тем, что size обновить я не смогу.
И поэтому size я обязан всегда считать за o от n.
Ну как происходит подсчет элементов в списке?
Ну просто прохожусь от начала до конца, и сколько элементов встретил, столько такой у меня размер.
Либо наоборот.
Либо я должен выполнять splice за o от n.
Ну в смысле, мой splice должен честно считать, сколько элементов он переносит из одного списка в другой.
Ну тогда в этом случае я могу обеспечить size за единицу.
То есть возникает чуть ли не моральный выбор, что я хочу.
Я хочу эффективно выполнять splice, или я хочу всегда эффективно выполнять size.
И вот в этом смысле комитет по стандартизации C++ принял решение,
что лучше size за o от единицы, чем splice в такой форме за o от единицы.
Поэтому splice в такой форме у вас работает за линейное время.
То есть даже несмотря на то, что чисто алгоритмически это можно сделать за единицу,
в списке Vistadlist это происходит за линейное время.
Но зато у вас в списке Vistadlist size работает за единицу,
и вы всегда за единицу можете узнать, какой размер вашего списка.
Вопросы?
Хорошо.
Ну и наконец forward list.
Там был вопрос в чате.
Да, так я чат не включил.
Что будет, если вызвать splice, то есть beginn поменять местами,
просто не скомплируйтесь за заключение какой-то или что-то еще.
А, да, еще важный момент, который не сказал про splice.
Посмотрите, если у вас adder совпадает с l,
ну, то есть если вы вызываете l.splice, там что-то, что-то, l и так далее.
То есть если вы переносите элементы внутри одного и того же списка,
то это работает за от единицы.
Понятное дело, что если вы переносите элементы из списка в сам себя,
то у вас размер не меняется.
Поэтому в этом случае можно гарантировать splice за единицу.
И это так работает.
Теперь вопрос. Что будет, если begin и end поменять местами?
UndefinedBehaviour.
Ожидается, что если вы передали begin и end,
то у вас begin находится слева, а end находится справа.
Если вы сделали по-другому, то есть если вы сказали, что это begin, а это end,
то что будет происходить?
Ну, он будет просто идти с...
А, сейчас.
А это интересный вопрос.
Ну, вообще, давайте так.
Наверное, с точки зрения стандарта, формально, это undefinedBehaviour,
потому что все-таки std list ожидает, что у вас begin находится левее, чем end.
Но что произойдет на практике?
Наверное, произойдет довольно интересный эффект.
У вас вот этот элемент...
Условно, этот элемент пойдет вот сюда.
Нет, я все-таки думаю, ничего хорошего не будет,
потому что ничего хорошего не будет.
То есть вы говорите begin и end, что они идут слева направо,
они на самом деле идут справа налево,
поэтому там многое испортится.
Потому что begin, например, ожидает, что next у него будет там,
а next у него на самом деле там.
Ну, в общем, беда будет, так нельзя.
То есть begin обязательно должен стоять левее end.
Ну, точнее, не правее end.
Ну, ошибки эмпиляции, естественно, не будет.
То есть компилятор не умеет проверять, где у вас там begin, где у вас там end.
Это полностью на вашей совести.
Скорее всего, будет там какая-то runtime ошибка.
Что он попытается пойти вправо, а справа ничего нет,
ну и, соответственно, все сломается.
Так, значит, forward list.
Ну, с forward list все понятно, это тоже самый список,
но просто одно направление.
То есть он просто хранит ссылки на следующий элемент вправо.
И все.
Ну и, соответственно, в отличие от sdlist,
у него есть все те же самые методы, точнее, не так.
Он ведет себя точно так же, как и обычный список,
но у него нет возможности добавления в конец.
То есть, естественно, если у вас есть односвязанный список,
и вы храните, скажем, указатель только на начало,
то у вас есть возможность добавлять только вот в начало.
То есть только делать push front и pop front.
Ну, сразу скажу, забегая вперед, что указатель на back, указатель на конец,
значит forward list не хранит.
То есть forward list хранит указатель только на начало.
Все.
То есть вы можете, поэтому вы можете добавлять элементы только в начало,
в конец не можете.
Есть еще ограничения, тоже алгоритмические.
Значит, смотрите, вот в обычном двухсвязном списке,
ну мы это уже как-то обсуждали, когда обсуждали эти хэштаблицы.
Давайте обсудим еще раз.
Вот, допустим, я хочу удалить вот этот элемент.
Если я ударяю его в двухсвязном списке, то все ок.
То есть мне достаточно его удалить,
и дальше я просто указатели провязываю там друг с другом
у предыдущего и следующего элемента.
Ну, потому что у меня через вот этот элемент
есть доступ как к предыдущему, так и к следующему элементу.
Поэтому я могу спокойно удалять.
А в случае forward списка не так.
Вот, если у меня есть forward список,
я хочу удалить вот этот элемент,
то есть если у меня есть указатель на этот элемент,
то просто вызвать erase я не могу.
Почему?
Потому что если я его удалю,
то мне нужно вот этот вот указатель провязать сюда.
А доступ к этому элементу я получить не могу.
Потому что у меня у вот этого элемента нет обратной ссылки.
То есть он не может получить своего левого соседа.
И поэтому операций insert и erase в forward листе нет.
Но есть методы insertActor и eraseActor.
Ну как это работает?
У вас есть одна направленный список,
и у вас есть указатель на какой-то элемент списка.
Вот сам этот элемент x вы удалить не можете.
Но вы можете удалить,
простите, вы можете удалить элемент y,
просто позвав eraseActor.
То есть вы говорите удалить не этот элемент,
а удалить элемент, который стоит после него.
Всё, таким образом вы удаляете элемент y
и просто-напросто провязываете ссылку на следующий элемент.
И никаких проблем нет.
Ну с insert тоже самое.
Вы не можете вставить элемент на текущую позицию,
вы можете вставить элемент только после этого элемента.
Потому что чтобы вставить элемент в текущую позицию,
вам надо знать предыдущего соседа,
а его вы знать не можете.
Аналогично, вместо привычных методов splice в списке,
у вас в односвязанном списке есть метод spliceActor.
Ну и работают они точно так же,
но просто вставляют элементы после того,
на который вы указываете.
Да, ещё забавный факт, у std forward лист нет size.
Ну, короче, size выпадывать не можете,
то есть вы обязаны самостоятельно его как-то хранить.
Вот.
Вопросы есть?
Так, продолжим.
Постараемся в течение 15 минут закончить с контейнерами
и коротко поговорить про итераторы,
чтобы мы могли уже как-то ими пользоваться.
Ну, ещё пару слов про std forward лист.
Значит, снова возникает естественный вопрос.
Ну вот у нас есть список,
которым можно пользоваться.
Ну, если вы хотите,
вы можете пользоваться стд forward лист,
но снова возникает естественный вопрос.
Ну вот у нас есть список,
в котором использоваться удобно.
У него есть insert и erase, и так далее, и так далее.
А есть std forward лист,
который односвязанный,
и в принципе не очень удобно пользоваться.
То есть всякий insertActor, raceActor,
плюс ещё size нельзя узнать и так далее.
В чём преимущество forward лист?
Ну, снова, здесь опять же классический принцип.
Не плати за то, что не используешь.
То есть если вам реально по факту нужно
только вставлять элементы, скажем, в начало,
или удалять элементы откуда-то,
и середина эффективна,
и при этом вам не нужно бегать по списку туда-обратно,
то стоит рассмотреть возможность
использования std forward листа. Почему?
Потому что, так как у него нет size,
то у него нет дополнительных лишних overhead'ов
на то, чтобы обеспечивать вам size за единицу
и вообще как-то поддерживать размер.
Это первое.
Второе, он не тратит все узлы,
ни один из узлов не тратит лишнюю память,
ссылку назад.
Вы понимаете, что если вы храните список интов,
помимо того что вы храните int,
вы ещё храните условно 2 указателя,
указатель 1 и указатель 2 указательно supers coincide
на следующий элемент. В итоге вместо того,
чтобы хранить один элемент на 4 байта,
вместо того чтобы хранить на один узел 4 байта,
то есть, по сути, на 1 intimate envelope,
вы храните 20 байт.
То есть вы в 5 раз тратите больше памяти,
чем на самом деле нужно для хранения элементов.
У форерд-листа с этим получше, потому что он хранит только одну ссылку,
поэтому затрата памяти поменьше.
Мораль в том, что контейнеры нужно выбирать под задачу,
соответственно, если вам не нужны возможности двунаправленного списка,
то рассмотрите возможность односвязанного списка.
Даже несмотря на то, что им возможно как-то неудобно исполнить,
хотя к этому можно быстро привыкнуть.
Ну и последний пункт контейнеров – это типы члены.
Смотрите, внутри класса, вы понимаете, что внутри класса можно объявить свои собственные типы,
например, создать свою собственную структуру или завести некоторый псевдоним,
например, using type равно int.
И этим типом вы можете пользоваться вне этой структуры,
например, вы хотите узнать, вы можете написать a.type и завести переменную x этого типа.
Грубо говоря, структурой класса они задают некоторую область видимости,
в которую вы можете объявлять свои собственные классы,
вы можете объявлять свои собственные псевдонимы типов и ими пользоваться снаружи,
с помощью операции разрешения области видимости.
И вот в частности для стандартных контейнеров есть следующие типы,
которые в них обязаны быть.
Это тип value type.
То есть вы можете у вектора спросить std.2.2.vector, например int,
и дальше написать 2.2.value type.
Value type хранит тип элемента, который он хранит.
В частности, value type является псевдонимом типа int.
Дальше есть тип size type, который говорит о том, в чем измеряется размер вектора.
Грубо говоря, что вектор ожидает от вас на вход в операциях resize и reserve,
и что он возвращает в качестве ответа на size.
То есть если вы хотите понять, какой тип вам нужно передать в resize или reserve,
то эта информация хранится в типе членей size type.
Есть difference type, это в чем измеряется расстояние между элементами.
То есть когда вы берете разность двух указателей или разность двух итераторов,
то бегай вперед.
Есть типы reference, constreference, pointer.
И const pointer – это какой тип имеет ссылка на элемент,
или какой тип имеет указательный элемент.
Для чего это все нужно?
То есть казалось бы, ну смотрите, у меня же есть вектор int.
Ну что, я дурак, я что-ли не понимаю, что у меня там value type – это int.
Что у меня ссылка на int – это ссылка на int.
Что у меня константная ссылка на int – это константная ссылка на int и так далее.
Но на самом деле вы не всегда этого понимаете.
Особенно если вы пишете шаблонный код.
Значит пример.
Ну вот представьте себе, опять же игрушечный пример,
но он там демонстрирует необходимость этих всех типов.
Ну представьте себе, что у меня есть функция, точнее я хочу написать функцию,
которая мне принимает произвольный контейнер
и возвращает динамический массив, который содержит элементы этого контейнера.
Вот функция toSistaLRA, которая выделяет память,
заполняет его как-то элементами контейнера
и дальше возвращает указатель на этот самый массив.
И тут возникает сразу куча проблем.
Ну смотрите, я принимаю произвольный контейнер.
Вопрос – какие элементы хранит этот контейнер?
Ну непонятно.
Ну тогда если я не понимаю, какой тип хранит этот контейнер,
то я в общем случае не понимаю, что мне нужно вернуть.
Указатель на какой тип мне нужно вернуть?
Какой указатель мне нужно тут создать? И так далее.
Ну то есть понимаете, да?
То есть я не понимаю, что находится внутри контейнера банально,
потому что у меня контейнер – это шаблонный тип.
И мне нужно из него как-то извлечь, а что там лежит.
Так вот, это можно сделать с помощью вот этих самых типов членов.
То есть мне достаточно написать.
Давайте отсюда начнём.
Чтобы создать массив из нужных мне элементов,
я могу обратиться к контейнеру 2.2.2.type.
И так как внутри каждого контейнера C++ есть определённо псевдоним
для того типа, который он хранит,
то с помощью вот этого 2.2.2.type вы можете получить тип,
который хранит контейнер.
Это первый момент.
Второй момент, ну окей, вот здесь можно написать авто.
Здесь в качестве возвращаемого значения вы можете указать pointer.
То есть контейнер 2.2.2.pointer.
То есть ваша функция tu-c style array возвращает указатель
на элементы, которые хранит контейнер.
Таким образом, вы можете расставить типы, даже если они вам явно не подаются на вход.
Мотивация понятна, да?
Ну, видимо, да.
Тут есть небольшой тонкий момент.
Тут написаны слова typeName и typeName.
Я, к сожалению, сейчас нет времени подробно объяснять,
почему тут нужно писать typeName.
Либо запомните, что в таких ситуациях нужно писать typeName.
Либо компилятор сам подскажет.
В этом смысле компилятор добрый.
У вас возникает ошибка компиляции, в которой будет написано,
что добавьте здесь typeName, и все заработает.
Если коротко, то typeName здесь нужно, чтобы компилятор понял,
что вот это value type – это на самом деле действительно тип,
то есть это действительно typeName, а не статическое поле.
Потому что представьте, что если у вас в контейнере есть статическое поле,
то к нему вы тоже можете обратиться вот так.
То есть компилятор паникует, он не понимает, что это.
Он не понимает, это статическое поле или это тип.
Но чтобы сказать ему, что это тип, и не беспокойся,
то нужно писать typeName.
Возможно, как-то позже об этом поговорим.
Все, отлично.
Значит, с контейнерами все.
Давайте вопросы минута и коротко поговорим про итераторы.
Все, отлично. Вопросов нет.
Переходим к итераторам.
Сразу вместо «в карьер» проблема.
Во-первых, мы знаем, когда мы обсуждали контейнеры,
у нас уже возникла проблема с тем,
что мы не можем обратиться к элементам списка.
Мы можем обратиться к первому элементу списка,
можем обратиться к последнему элементу списка,
а куда-то в середину непонятно,
непонятно получить центральный элемент списка, например.
Или вот еще одна проблема.
Представьте, что вы пишете функцию,
которая просто печатает содержимое контейнера на экран.
Вы принимаете произвольный контейнер,
естественно, функция шаблонная,
потому что она принимает произвольный контейнер,
контейнеры могут содержать произвольные типы и так далее.
Вы проходите по этому контейнеру,
допустим, с помощью счетчика И,
то есть от нуля до размера контейнера,
то есть от нуля до размера контейнера
вы выводите содержимое контейнера И.
И сразу возникает проблема,
потому что, вообще говоря,
не все контейнеры позволяют индексировать себя.
Например, deck может, stray может, vector может,
а односвязанный списк и односвязанный списк они не могут.
То есть возникает проблема.
То есть как мне написать функцию,
которая может просто взять и вывести содержимое произвольного контейнера?
Например, для связанного списка вы могли написать какой-то такой код,
если вы знали внутреннее устройство листа,
если вы знали, какой тип имеет узел,
что он внутри себя хранит,
то вы могли пройти как-то так.
Но этого не можете сделать.
Это первое.
А второе.
Тогда вам придется для каждого контейнера писать свою версию print,
что, естественно, неудобно.
То есть для каждого контейнера вам, по сути,
нужно написать свой алгоритм.
Вы можете отсортировать вектор.
Хорошо, вы его сортируете одним способом.
Теперь вам нужно отсортировать, не знаю, stray,
и вам нужно для него писать другой алгоритм, видимо.
Ну, подождите, да?
У меня же и вектор, и array, они, по сути, представляют в себе массив.
То есть, наверное, их можно обрабатывать каким-то единым образом.
То же самое deck.
Deck, несмотря на то, что у него память расположения непрерывно,
вы можете к нему обращаться по индексу.
Поэтому, наверное, его тоже можно отсортировать эффективно.
То есть возникает проблема.
Как написать обобщенные алгоритмы,
которые бы работали вообще с произвольным контейнером,
и неважно, как бы они внутри были устроены.
И вот ровно эту проблему нам помогают побороть итераторы.
Да, хочется иметь унифицированный способ обхода контейнеров
и обращения к их элементам.
Ну, или, на самом деле, не просто обходы контейнеров вообще.
Хочется писать алгоритмы, которые бы не зависели от типа контейнера.
И это можно сделать с помощью так называемых итераторов.
Так вот, что такое итератор?
То есть про итератор можно думать в следующем ключе.
Итератор — это просто особенный указатель.
Итератор — это просто указатель, который знает информацию про свой контейнер.
Ну, в частности, если у вас есть массив,
и у вас есть указатель p,
то вы можете спокойно с помощью этого указателя
получить указатель на следующий элемент,
то есть получив plus-plus-p.
Или по этому указателю вы можете спокойно получить значение
того элемента, на который вы указываете. А что если речь идет про список? Так вот, если вы
используете итераторы, то в случае списков вы можете использовать точно такой же интерфейс для
указателей, как и для массивов. То есть у вас есть некоторый итератор, давайте я его назову it,
который в некотором смысле указывает на какой-то элемент списка, и дальше вызываете у него
plus plus it. И вот когда вы вызываете plus plus it у итератора, итератор на самом деле не делает вот
plus plus в смысле адреса в памяти, а plus plus it просто понимает, ага, я указываю на контейнер типа
list, то есть я итератор листа, поэтому мне нужно там, скажем, посмотреть на next, то есть на указатель
next, и в итоге он оказывается здесь. То есть итератор знает про внутреннее устройство контейнера,
и собственно реализует операции там plus plus, minus minus или разыминование с учетом этих знаний.
Понятно, то есть теперь вы можете пользоваться итераторами просто как обычными указателями,
и при этом не задумываться о том, как внутри устроены контейнеры. Ну вот, например,
вот пример функции print. Как можно было написать функцию print, работая с итераторами? Очень просто,
мы принимаем произвольный контейнер и мы проходим все итератором от начала до конца.
Как получить итератор на начало? Очень просто. У каждого контейнера, у любого контейнера,
есть метод begin. Вот metod begin это значит получить указатель начала, ну или получить итератор
на начало. Правильно говорите, итератор. Вот вы получаете итератор на первый элемент. Дальше,
как получить итератор на последний элемент? То есть как понять в какой момент нужно остановиться?
Очень просто тоже. Нужно вызвать метод end. Вот метод end возвращает вам
итератор на, на самом деле не на последний элемент, а на элемент следующий за последним.
То есть снова begin и end, ну как и все в стандартной библиотеке C++. Опять же возвращаемся к вопросу
о соглашениях. Вот в стандартной библиотеке C++, ну и в принципе C++ принято, что у вас все интервалы
полуоткрытые. То есть начало включается, а конец не включается. Вот поэтому container end
на самом деле указывает на элемент, который находится за последним. Ну и в списке тоже самое.
Тут есть какой-то фиктивный элемент, который является end. То есть вы получили итератор
сначала, итератор на конец, то есть на конец последовательности. Ну и дальше вы делаете
следующую вещь. Пока у вас итератор не дошел до конца, пока у вас итератор не равен end, вы
увеличиваете итератор. Все. А чтобы получить элемент или чтобы увести его на экран, вы просто
разыминовываете итератор. То есть теперь давайте вот просто мысленно забудем про слово
итератор и посмотрим на этот код. Вот так как будто бы it это был указатель. Согласитесь,
ровно так себе ведет указатель. Указатель можно ингриментировать, указатель можно сравнивать
на равенство не равенство, указатель можно разыминовать. Итератор – это по сути ну опять же
указатель на максималках. То есть указатель может указывать только скажем на массив,
а итератор может указывать в произвольный контейнер и при этом у этого контейнера,
Понимая его внутреннюю структуру, идти определенным образом вправо или влево.
Идея основная понятна?
Или есть вопросы?
Понятно.
Супер.
Для чего нужны итераторы?
Итераторы нужны, чтобы абстрагироваться от конкретного контейнера.
Снова возвращаемся к вопросу о сортировке.
Мы понимаем, что сортировать можно не только вектором.
Сортировать можно array, сортировать можно deck.
Потому что они позволяют в произвольное место эффективно получать доступ.
Если вы понимаете, как устроена быстрая сортировка,
то быстро сортировки нужно в его момент быстро получать элемент по нужному индексу.
И, соответственно, stdsort, встроенный алгоритм сценария библиотеки sort, он так и устроен.
Он принимает не контейнер, который вам нужно отсортировать.
Он принимает не контейнер и ничего другое, а он принимает именно пару итераторов.
Какую последовательность вам нужно отсортировать?
Begin, end.
Чтобы отсортировать вектор, я должен передать vBegin, vEnd.
Теперь он с этой последовательностью будет работать через итераторы.
Он просто будет у итератора звать plus, plus, или plus равно, или квадратные скобки.
Потому что у указателя можно брать квадратные скобки.
Также у итератора вектора можно брать квадратные скобки.
Точно так же можно отсортировать, например, deck.
То есть вы можете назвать dBegin или dEnd.
Кроме того, чем еще хорошие итераторы?
Чем еще хороший этот способ с применением алгоритмов над итераторами, а не над контейнерами?
Представьте, что у вас есть массив, или любой другой контейнер,
и вам хочется отсортировать элементы с третьего по десятой, не включительно.
Как бы мы это сделали, если бы sort принимал контейнер?
Нужно было сделать две вещи.
Нужно было взять все эти элементы.
Скопировать какой-то новый массив.
Потом этот массив передать обратно в сортировку.
Сортировка бы этот массив отсортировал.
И нам нужно было взять этот массив и скопировать все обратно сюда.
То есть если бы сортировка работала с контейнерами,
то нужно было создавать временный контейнер,
передавать его в сортировку,
потом из этого временного контейра еще копировать обратно. Но это неэффективно. А здесь, если вам нужно
отсортировать, скажем, все элементы с третьего по десятой, то достаточно просто позвать std sort
скажем v.Begin плюс 3, запятая v.Begin плюс 10. Все, и теперь эта сортировка будет работать с
элементами с третьего по десятой. Вот и все. То есть сортировка будет думать, что это начало
массива, а это конец массива, и вся сортировка будет осуществляться только здесь и только здесь.
На этом, я думаю, закончим. Время вышло. Давайте еще раз спрошу, есть ли у вас вопросы по тому,
что на текущий момент было рассказано. А в следующий раз продолжим обсудить
итераторы и другие контейнеры.
