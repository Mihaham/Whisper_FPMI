На самом деле, даже вам в каком-то смысле повезло, что именно эта фара попадет под
запись, потому что именно здесь и в этот и в следующий раз я буду рассказывать
наиболее важные вещи для того, чтобы первые две большие задачи сдать получилось. Так что,
возможно, вы еще потом будете это пересматривать. В поводу добавления в контест я не буду добавлять
по одному, но у вас таких, кто не смог добавиться в контест, человек, не знаю, 50 может быть. Вот я в
какой-то момент зайду еще раз таблицу, еще раз копипащу все логини, кто повторно туда
писал и добавлю в контест. Я, наверное, сделаю это сегодня после пары. Писать мне в личку по одному,
добавь меня в контест, не надо, пожалуйста. Я же не могу каждый раз открываться и по одному
вас добавлять. Добавлю всех разом. Так, мы продолжаем ООП. В прошлый раз мы начали тему третью,
которая называется «Ведение в ООП» и разобрали первые два пункта из нее. Вот, а сегодня
мы переходим к следующему, и пункт называется «Конструкторы и деструкторы».
Возможно, надо светлую тему сделать или не надо, и так нормально.
Если темная тема плохо, то можно светлую сделать. Ну ладно, никто не жалуется, поэтому оставлю так.
Ну так вот, напомню, можно объявлять свои классы. Ну, я давайте, чтобы не париться с приватностью,
я буду объявлять структуру вместо классов пока что, чтобы не писать паблик постоянно. Вот,
такая структура. Ну, если в ней есть какие-то поля, да и даже если нет никаких полей,
я могу просто объявить, проинциализировать по умолчанию. При таком сознании создается объект
данной структуры, у которого все поля проинциализированы по умолчанию. Что значит
«проинциализированы по умолчанию»? Это значит, как если бы они локально были объявлены, вот так,
как написано, так и проинциализированы, в данном случае в X будет рандомное значение. А если бы
тут было написано вот так, то это бы означало, что X по умолчанию, в случае, когда структура
следуется по умолчанию, это поле равно нулю. Кстати, такой синтаксис только c++11 появился,
как-то странно. Поля по умолчанию имциализированы с значениями. Вот, но тем не менее, если я хочу
явно указать, чему равны поля, это я все напоминаю, то я могу использовать вот такой синтаксис. Я
могу написать там 1, запытаю 2.0, скажем, в фигурных скобках. Порядку перечислю. Тогда каждое поле
проинциализируется соответствующим значениям. Вот, но если у меня это уже класс, а не структура,
то такое дело не сработает. Вот. Почему это не сработало? Ну, то есть пока это было структурой,
так можно делать было, а когда стало классом, нельзя. Ну, вы скажете, ну как же так, я же говорил,
что класс и структура ничем друг от друга не отличаются. Да, это правда. Ничем не отличаются.
Дело в том, что здесь причина в том, что это приватные поля. Вот приватные поля инициализировать
таким способом нельзя. Это, я напомню, называется агрегатная инициализация. И если поля публичные
были бы все. И структура, вот это называется plane. Ну, есть такое формальное определение.
Plane. Plane old data что ли. Ну, короче, структура, в которой просто данные лежат какие-то,
и можно напрямую к ним обращаться. Я не помню формальных определений этих всех,
как и при каких условиях можно агрегатно инициализацию делать. Но если вкратце,
то когда все поля публичные и нет каких-то непривиальных методов, нет всяких наследований
непонятных виртуальных и прочего, тогда можно. Если это класс, то так его пронициализировать не
получится. В смысле, с приватными полями как минимум. И нам нужно какой-то другой синтаксис для
того, чтобы создавать объект класса от данных параметров. Вот, допустим, я хочу создать объект.
Я хочу уметь создавать объекты этого класса с какими-то изначальными параметрами. Не просто
по умолчанию, а с какими-то параметрами. Ну, типичный пример. Давайте я напишу класс
комплексных чисел. Ну и у него будут приватные поля. Какие у него будут приватные поля?
Вещественная часть, минимая часть. Вот, и я хочу научиться создавать объекты этого класса от
разных параметров. Например, я могу хотеть создавать комплексные числа просто от одного дабла.
Тогда вещественная часть должна быть равна этому даблу, а комплексная нуню. Вот. Могу хотеть
создавать от двух даблов. Тогда, соответственно, будет вещественная и минимая часть. А могу по
умолчанию. Тогда, чтобы все нуню стало равно. Вот. Такую вещь хочу сделать. Вот, чтобы объяснить
компилятору, как должен создаваться объект класса от данных параметров, что должно происходить,
как должны иницивизироваться поля и, возможно, что-то еще должно происходить. Когда вы объект
класса пытаетесь иницивизировать такими-то параметрами, вот. Для этого используется
конструктор. Конструктор — это специальный метод, смысл которого в том, что он описывает,
как создается объект от данных параметров. Конструкторы. Это пишут следующим образом.
Давайте, например, напишу, как мне создать объект класса комплекса от двух даблов. Я пишу
прям внутри класса метод с названием, как у этого класса, комплекс. Если метод в классе называется
в точности так же, так и сам класс, то этот метод является конструктором. Ну, я пока напишу
его с плохим очень кодстайлом, потом постепенно я буду шаг за шагом делать лучше. Ну вот, я написал
конструктор, и в этом теле конструктора я напоминаю, что это сейчас очень плохой кодстайл. Вот. Ну,
я могу написать что? Я могу сказать, значит, что мой Re — это тот Re, который мне дали, и мой Im — это
тот Im, который мне дали. Вот. Я объявил конструктор от двух параметров. Правда, он приватный, вот его
надо сделать публичным. А теперь я могу из FunctionMain создавать комплекс от двух даблов, например,
1.0, 2.0. Вот. Теперь у меня комплексы умеют создаваться от двух даблов. Ну, я могу вывести,
в принципе, на экран поля, сделать их публичными, проверить, что он создался. Ну, может, мне поверить,
все корректно. Вот. Неважно, поля были бы публичными или приватными. Вот. На самом деле,
конструктор можно определять у структур, конечно, и даже если у них все поля публичные,
тоже можно определить конструкторы. Вот. И если вы хоть один конструктор определили,
то агрегатная идентилизация, по-моему, тоже перестанет работать. То есть, вот если я сейчас
сделаю все поля публичными, то, по идее, должна работать агрегатная идентилизация. Ну, у меня же
все поля публичные, все просто... Нет, агрегатная идентилизация все еще работает. То есть, у меня
получается поля вот так идентилизируются, несмотря на то, что конструктор есть. Но если я вот так пишу,
это значит, я вызываю свой конструктор. Так. Ну, хорошо. Как только я определил хотя бы один
конструктор, у меня уже пропадает возможность создавать комплекс по умолчанию. Вот. Агрегатные,
ну, фигурные скобочки не пропадают возможность использовать, но если есть хоть один конструктор,
который я сам написал, то вот такое уже не будет работать. Сейчас будет CE. Почему так? Ну, потому
что компилятор считает, что если вы сами решили определять способы создания вашего класса от
параметров, то уже способ по умолчанию он не будет вам за вас создавать. Вот. Ну, значит, вот это
ошибка компиляции. Можно, конечно, делать перегрузку конструкторов. То есть, написать несколько
конструкторов от разных параметров. Например, вот будет конструктор, который принимает только один
дабл. И будет он делать вот это. Вот. Теперь я могу создавать конструкторы, ой, создавать комплексные
числа от одних только даблов. Да, но мне нужно здесь сказать, что им я проинцелизирую нулем. Вот. Теперь,
если я создаюсь от одного числа, то это получается, что вещественная часть равна не этому числу,
а мнимой нулю. Вот. Это была эта перегружка конструктора. Вот. Значит, люблю вареные яйца,
спрашивают, обязательно ли писать здесь стрелочка Ре или можно просто писать Ре. Ну,
здесь я пишу здесь стрелочка Ре, потому что у меня вот это имя локальное, оно запмевает поле.
Если бы меня было, да, то есть, если бы параметр назывался иначе, то я бы мог без звезд к нему
обращаться. Поэтому я говорю, что у меня плохой подстайл, я сейчас это поправлю, я сейчас скажу,
как правильно писать. Вот. Чтобы таких коллизий не возникало, даже если у вас параметр запмевает
поле. Вот. Это была перегрузка конструктора. Вот. Но я могу и конструктор без параметров
захотеть определить сам, как я это буду делать. Ну, логично, что вот так. Вот. Ну, тут я могу написать,
значит, вис стрелочка Ре равно нулю и вис стрелочки просто Ре равно нулю, им равно нулю. Но я могу
сделать и проще. Я могу просто здесь по умолчанию проставить эти значения, и тогда мне не придется
проставлять, чему они равны, в случае, когда я не написал, чему они равны. Вот. Если у меня здесь
проставлено значение по умолчанию, то когда вызывается конструктор, они по умолчанию этим
инициализируются. И дальше, если я что-то им присваиваю, то за значение заменяется на это. Вот.
Но чтобы мне не писать присваивание нуля каждый раз каждому конструктору, я просто могу по
умолчанию сделать его полям. Как бы считать, что если ничем не фринциализируем, то инициализирую
этим. Вот. И вот теперь я снова смогу создавать комплекс без параметров. Впрочем, если я так
напишу, это будет некорректно, потому что это с точки зрения синтаксиса объявление функции
с возвращаемым типом комплекс именем C3 без параметров. Вот. Чтобы создать комплекс без параметров,
надо просто вот так написать. Вот это я сейчас объявил. Комплекс без параметров. Если бы я вот
этого не написал, то это была бы ошибка компиляции, я напоминаю, потому что после того, как вы хотя
бы один свой конструктор определили, компилятор перестает за вас определять... компилятор перестает
генерировать за вас конструктор без параметра. Вот этот конструктор, который называется... который
без параметров, он называется default constructor. Ну, default constructor. Конструктор по умолчанию по-русски
переводится. Вот. Конструктор по умолчанию, он, значит, это тот самый конструктор, который вызывается,
когда вы вот так вот свой объект создаете. И он по умолчанию существует и без вас, если вы ничего
не напишете, никаких конструкторов. Компилятор генерирует конструктор по умолчанию сам, даже
если вы сами не объявили конструктор. Но если вы объявили конструкторы хоть какие-то, то конструктор
по умолчанию будете добры тоже сами написать, потому что компилятор за вас там даже не будет ничего
додумывать. Что делает конструктор по умолчанию, который генерирует компилятор? Он просто все
поля нициализирует значениями по умолчанию. В частности, если поля это тоже объектically классов,
то у них будут вызваны конструкторы по умолчанию. А... вопрос. Ад двигательная нициализация от 2 параметров
как и раньше, или вызывает конструктор? Вот да, это хороший вопрос на самом деле, я и сам не знаю,
давайте проверим, потому что вопрос на самом деле интересный. Давайте я вот так вот сделаю, чтобы
проверить. Да, то есть смотрите, вот я сейчас создал комплекс от двух чисел и посмотрел,
что создалось. Ну, конструктор у меня переставил местами поля, а если я фигурную скобкин напишу,
знаете, мне кажется может, что и конструктор вызовется. Да, спасибо за вопрос, на самом деле да,
когда у вас определен конструктор, все-таки это неправда, что агрегатная инициализация продолжает
работать, даже если вы будете фигурную скобкин ставить, это будет конструктор вызываться. Да,
вот так это работает на самом деле. То есть, когда вы определили конструктор, а уже агрегатной
инициализации, вы пользоваться не можете. Ну, то есть вы можете фигурную скобкун инициализировать,
но это будет все равно, как будто конструктор вызывается, и соответственно поля будут в обратном
порядке. Ну, я проверил это. Вот, ну хорошо, вот у меня есть несколько конструкторов.
Теперь поговорим вот о чем. Я вам сказал, что когда компилятор, ну, когда не написано,
чем инициализировать ваши поля, они инициализированы значением по умолчанию. Но дело в том,
что когда вы входите в тело конструктора, вот здесь, к этому моменту поля уже должны быть чем-то
инициализированы. Вот. Перед входом в тело конструктора, поля уже должны быть
инициализированы, потому что они входят в область видимости, ну, как бы, сейчас
уже начатая область видимости, когда вы в тело конструктора войдете. А раз начатая область
видимости, они должны быть как-то инициализированы. Они будут инициализированы рандомным
значением, а можно быть чем-то, что вы написали. Если эти поля сами являются объектами, например string.
то она тоже должна быть проницелизирована чем-то, то есть она должна быть создана,
сам должен быть создан этот объект, потому что здесь вы уже имеете полное право к нему обращаться,
что-нибудь у него спрашивать. Отсюда вывод. Когда вы заходите в тело конструктора,
перед тем как вы заходите в тело конструктора, вызывают, что сначала конструкторы всех ваших
полей, если это объекты, а если это обычные переменные, то происходит их вентилизация чем написано.
А дальше, когда вы уже в теле конструктора вот этим вот занимаетесь, вы на самом деле делаете
присваивание. То есть вы не создаете изначально поле с таким параметром, а вы присваиваете ему
новое значение. Так я вдруг понял, что я говорю в микрофон, который у меня болтается с другого
уха, а теперь меня наверное стало громче слышно гораздо, да? Ага, ну тогда я сейчас убавлю громкость
микрофона и будет как раньше. А вот так нормально? Все, хорошо. Так вот, возвращаясь к конструкторам.
Вот когда я в теле конструктора что-то присваиваю... А, вот оно что. Все, понятно. Ну хорошо. А изначально
перед тем, как я уже в тело конструктора, поля уже проенциализированы, а если они сами объекты,
вызывают все их конструкторы до этого. И когда я из тела конструктора начинаю делать присваивание,
я на самом деле делаю лишнее действие. То есть я бы мог сразу... Ну, я вообще-то хочу сразу,
чтобы мое поле вот это вот было проенциализировано нужным мне значением. А то, что я сейчас делаю,
это примерно следующее. Я сначала инициализирую его нулем, а потом присваиваю ему новое значение.
Ну, в случае дабла это пофигу, к тому же компилятор скорее всего соптимизирует. Если там какой-нибудь
класс в качестве поля, ну какой-нибудь объект в качестве поля лежит, например, вектор, и у него
создание вектора по умолчанию это не тривиальная какая-то операция, то на самом деле, когда вы
будете поля вот так вот присваивать в теле уже конструктора, это неэффективно. Эффективнее
сразу проенциализировать поля, чем надо, перед тем, как в тело войти. Вот для этого существуют
так называемые списки инициализации. Вот, не путайте их с другими списками инициализации,
которые в C++11 появились. Значит, к сожалению, есть некоторая амонемия в терминологии. Есть
списки инициализации конструкторов. Да, они называются constructor initializer lists. Короче,
ну списки инициализации в конструкторах. А есть еще так называемые brace and close initializer
lists. Это другие initializer lists. Не путайте с ними, про них я скажу попозже. Как пишутся списки
инициализации в конструкторах? Вот так я пишу. Вот здесь я пишу имя своего поля, а здесь, чем его
проенциализировать. И теперь мне вот это можно убрать. То есть, смотрите, я написал, а после
закрывающей круглоскопки я пишу двоеточие, если это конструктор, и дальше идет список инициализации.
В списке инициализации я перечисляю, какое поле, чем проенциализировать, прежде чем в тело
конструктора войти. И вот здесь мне уже не нужно писать list.re, потому что здесь однозначно партится
эта конструкция. Вот это re берется из полей, а вот это re берется уже из параметров. А если
цикл появится при вызове конструктора? Если цикл появится при вызове... Вы так не сделаете.
Вы не сможете добиться такого. Не, ну если, например, у нас у класса А есть поле объектов класса
В и наоборот. Вы не можете создавать... Вам нужно чтобы класс использовать как поле в другом классе,
не только объявить, но и определить класс до этого. Вот, и поэтому так сделать просто не получится.
А, то есть тут как с функциями уже нельзя, да? Нет, нельзя. Ну, вы можете... Вот что сделать. Вы
можете... Ну, давайте немножечко про это расскажу. Есть такое понятие не полный тип, incomplete type.
Ну, значит, такое формальное понятие. К нему относятся типы классов... Ну, это тип void,
а еще там некоторые типы, и тип класса, который объявлен, но не определен. Вот, да, указатели
друг на друга могут быть, но вот как поле, один класс внутри другого, а другой внутри первого,
вы просто физически не сможете добиться, потому что если вы объявляете какой-то класс,
то чтобы его использовать как поле в другом классе, вы должны его определить. Вот,
если я попробую вот так сделать... Сейчас у меня будет CE со словами field has incomplete type. Нельзя
объявлять переменные неполных типов, то есть таких типов, которые еще не определено, что за тип.
По этой причине такая конструкция не выйдет. Но указатель на A вы можете объявить, это правда.
Вот, чтобы объявить указатель или ссылку на A, вам не нужно определение класса A иметь выше себя.
Вот. Это, кстати, довольно, да, интересный феномен, но мы с таким еще, я думаю, столкнемся. Вот,
чтобы объявить указатель на A, вам нужно только лишь объявление класса A выше иметь, а чтобы
сам объект A, вам нужно и определение иметь уже. Вот. Вынужденная мера. Какая вынужденная мера?
Не понимаю. В смысле, что указатели можно друг на друга объявлять? Ну да, это... Ну как,
указатели разрешено делать. Вот. А вот так... Ну, в общем, ладно, давайте дальше. Так вот,
списки инициализации. И здесь уже не возникает конфликта имен. Точно так же здесь я пишу
ре-ре и не пишу, чем пронициализировать им. Я не написал, чем пронициализировать, это значит,
пронициализируется. Вот. Если у меня поля это сами по себе какие-то объекты, то здесь в скобочках
я просто им передаю параметры их конструкторов. Вот. И есть еще такой момент. Тонкий. Вот. Если
я здесь попробую в другом порядке перечислить, то будет warning. Нет, не будет warning.
Вот теперь будет. Значит, warning со словами «такое-то поле will be initialized after – w reorder».
Вот. В чем прикол? Дело в том, что поля всегда инициализируются всегда в том порядке,
в каком они объявлены, а не в том, в каком вы их перечисли в конструкторе или в инициализаторах.
Вот. И когда вы в списке инициализации перечисляете поля в неправильном порядке,
вы тем самым самого себя обманываете на самом деле. Вы пишете «так», но на самом деле сначала
будет ре-пронициализировано, потом им. Если у вас инициализация одних полей зависит от других,
это может привести к проблеме. То есть вам, может быть, обязательно нужно сначала пронициализировать
одно поле, чтобы потом результатом каким-то его инициализации пронициализировать другое. И вот
если у вас поля в неправильном порядке перечислены, вы этого не сможете добиться. Вам нужно объявлять
поля в правильном порядке, а списк инициализации нужно писать в порядке согласованном с порядком
объявления полей. Вот компилятор выдает такой warning, потому что, ну, это может вести в заблуждение,
когда вы в списке инициализации перечисляете не в том порядке, в каком нереально будут
пронициализированы. Вот. Соответственно, вот в этой ситуации компилятор, ну, сначала будет
пронициализировано тем, что вы дали, потом им будет пронициализировано нулем. Использовать
списки инициализации настоятельно рекомендуется. Если вы будете присваивать, значит, это одна из
самых частых ошибок на review, за которую просто мы всех хейтим, и я буду вас сильно хейтить,
и проверяющие вас будут сильно хейтить. Вот, когда вы будете писать свою первую задачу, да и вторую, да и все
остальные, вот, мы будем хейтить вас вплоть до самого конца года. В конце года, если вы до сих пор так
будете писать, вы можете сильно хейтить. Так, у нас Zoom бесплатный, поэтому нам придется через 10 минут
выходить и новую встречу создавать. Значит, обязательно используйте списки инициализации,
а не присваивайте полям значения в телеконструкторе. Это и по код-стайлу правильнее, и эффективнее,
и еще и безопаснее в некоторых ситуациях. Вот, хорошо. Еще один пример разберу. Вот, смотрите,
допустим, у меня класс, в котором есть в полях ссылка или константа. Ну вот, я не буду тут
выдумывать. Вот такой класс я заведу. Ну, не класс, а структуру, чтобы не возиться с приватностью.
В чем особенность ссылок и константов? В том, что их обязательно нужно пронициализировать при
создании. Вот. Вот я объявил класс с такими полями, ну и все пока хорошо, но если я попытаюсь создать
объект такого класса, то будет CE, потому что компилятор не в состоянии сгенерировать для него
конструктор по умолчанию. Конструктор по умолчанию может быть сгенерирован компилятором автоматически
только для тех классов, для которых понятно, что из себя представляют инициализации по умолчанию
для каждого поля. Но если там в полях какие-то типы, которые не допускают сами свое конструирование
по умолчанию или ссылки или константы, которым обязательно нужно что-то при создании сразу
присвоить, ну типа пронициализировать, то это будет еще компиляция. Вот. И я, конечно, могу
написать здесь по умолчанию что-то, и это будет работать. Но что, если я конструктор для такого
класса определяю? Вот я, допустим, говорю, вот я определяю конструктор, и мне дали, значит,
ссылку на Y и какой-то другой double. И мне надо ссылку мою на X пронициализировать этим Y,
а мой D пронициализировать этим DD. Вот здесь просто физически не получится вот так написать.
То есть присваивание полям просто не сработает. В случае со ссылкой оно скомпилируется,
но будет делать не то. Что такое присваивание полям? Допустим, у меня здесь бы был какой-то
глобальный R, и по умолчанию бы вот эта X указывала на R. Тогда что бы произошло,
когда я так написал? Ну, здесь произошло следующее. У меня X пронициализировался бы R,
и теперь X — это то же самое, что R. И когда я так пишу, я R присваиваю Y, а вовсе не
инициализирую поле X с ссылкой на Y. Вот. И поэтому здесь существенно и очень принципиально,
чтобы было написано именно так. Вот написать вот так — это совсем другое. Это означает,
что вот это будет проигнорировано, а X будет сразу проинциализирован Y. Вот. А это просто
не скомпилируется, потому что в константе по-прежнему ничего не присвоено. Ну, если я
здесь напишу вот так, допустим, то ошибка компиляции из-за того, что не пронициализировано, исчезнет,
но присваивание все равно делать нельзя константе. Поэтому для константа тоже принципиально,
чтобы вы использовали именно списки инициализации, а не присваивание полям делали. Вот это пример класса,
которому необходимы списки инициализации. Без них он просто работать не будет.
Списк инициализации в конструкторах. Да, у меня все еще ошибка компиляции,
потому что нет конструктора по умолчанию для такого класса. Ну и боксинг. Вот. Ну хорошо.
Еще одна ситуация интересная, про которую хочу рассказать. Вот какая. Представьте,
что у вас в полях есть константная ссылка. И здесь вы говорите. Ну, вы, я надеюсь,
помните, что константные ссылки можно инициализировать R-value значениями. Вот.
И допустим, я решил эту константную ссылку проинциализировать R-value значениям. Да,
то есть что я написал? Я написал конструктор по умолчанию инициализирует x0 и double, чем написано
там. Вот вопрос. Дальше, в дальнейшем, использовать этот x это корректно или нет? То есть,
нормальный ли это код? Вот. Ответ нет. Это будет ube, хотя компилятор мне об этом и не сообщает.
А, нет. Сообщает. Вот смотрите. Видите, я добавил minus и extra. И компилятор мне таки сообщил этот
warning, что временная связь сx поддерживается только пока конструктор выполняется. То есть,
вот это вот временное значение 0, оно не считается, ну, его время жизни заканчивается,
когда заканчивается код конструктора, а не все время, что существует x. Ну, чтобы это было
понятнее, проще, наверное, STD-стринги объяснить. Вот у меня, значит, вот если я вот так напишу,
то потом из какого-нибудь метода s обращаться к x, это будет ube, потому что временная строка,
к которой привязывается вот эта константная ссылка, она не живет до конца жизни объекта
класса. Она живет лишь до конца выполнения вот этого тела конструктора. Вот. Не x,
вот until the constructor exits. То есть, пока мы, когда мы выйдем из конструктора, эта временная
связь уничтожится. Константные ссылки продлевают жизнь объектам, которым они привязаны и временным,
но только в случае, если это локальные переменные, если это поля классов, то это не сработает и будет
ube. Поэтому аккуратнее со ссылками полями класса, в качестве полей класса. Так, у нас еще...
А, тут еще кто-то вопрос задал, я не заметил. Агрегатная интеллизация будет работать при
отсутствии значений по умолчанию? Будет, конечно. Почему нет?
А, про ссылки и константы не помню. Вероятно, нет. Вот, вероятно, со ссылками и константами
агрегатная интеллизация не работает. Но я не уверен. Попробуйте. Не хочу тратить время тестировать
это. Ну, вообще, это плохой код-стайл, довольно так писать. То есть, так, ну, не надо так делать.
Класс со ссылками и константами, это не такой класс, который обычно агрегатная интеллизация
и интеллизирует. Если там что-то такое в полях, то, скорее всего, нужно конструктор полноценный писать.
Вот. Так, ну ладно, такие у нас... Ну ладно, давайте все-таки продолжать пока. Выкинет,
так выкинет. Значит, дальше... Дальше вот что. Ну вот, как вы могли заметить, все вот эти конструкторы,
которые до сих пор написал, они пустое тело имеют на самом деле. То есть, по сути, все, что делают
конструкторы, это поля инициализируют меня. Вот. А тело конструктора тогда зачем? То есть, что такое
в теле конструктора может происходить, что мне надо, я не знаю, значит, какой-то нетривиальный код
писать конструкторами. Вот. Что это может быть такое? Вот. Сейчас мы разберем пример класса,
в котором конструктор выполняет какие-то содержательные действия, а не просто служит
для инициализации полей. И пример такого класса, это, конечно же, вектор, ну или стринг. Это, по сути,
очень близкие по смыслу вещи. Вот. Как выглядит класс... Ну, давайте я буду на примере класса стринг
показывать. Вот. Как выглядит класс стринг, который вам, кстати, предстоит писать скоро. Вот. Прямо
уже на этой неделе. Прям, вот, возможно, даже сегодня или завтра задача появится. Значит,
там есть поля. Какие там поля? Там указатель на вот этот массив символов, а также два числа.
Размер, как мы уже обсуждали, и capacity. Так, давайте двигаться вперед, потому что мы в прошлый раз
не закончили говорить о конструкторах, на самом деле, даже. Вот. И сегодня надо уж точно закончить.
Значит, ну я почти все рассказал. И закончили мы на том, что есть, значит, слова default и delete,
насколько я помню. Про них я тоже все, что хотел, сказал. Вот. Осталось две вещи, которые я не сказал
в этом пункте. Первый пункт, значит, первая из этих двух вещей, это так называемые initializer
листы. Я вам говорил, что есть списки инициализации, так называемые, member initializer lists. Вот они. Но
это другое. А есть еще, скажем так, амонемичный термин initializer листы C++, он появился,
начиная с C++11. Это когда вы делаете конструктор от чего-то, списка чего-то в фигурных скобках.
Ну, например, когда вы говорите vector int v равно, а дальше пишете 1, 2, 3, 4, 5, то как это работает?
Это же, ну это что такое? Это конструктор от чего по-вашему здесь вызывается? Вот это и есть так
называемые initializer lists. То есть, начиная с C++11, классы можно создавать от списков каких-то
штук в фигурных скобочках. Вот. И это вносит дополнительную путаницу, потому что еще есть
агрегатная инициализация, как вы помните, в фигурных скобочках. Вот. Но фигурные скобочки
могут означать не обязательно агрегатную инициализацию. Да, ну, во-первых, как мы с вами уже выяснили,
если у вас есть свой собственный конструктор, и вы фигурные скобочки пишете, то все равно вызывается
он, а не происходит агрегатная инициализация. А хуже того, еще может быть специальный конструктор
от initializer-листа, и тогда, если вы напишете фигурные скобочки, он будет пытаться вызвать его
обязательно. Ну, давайте, например, я реализую конструктор. Ну, я не знаю, на примере чего тут
можно реализовать этот конструктор. Ну, на примере строки это довольно странно. Ну, давайте
на примере строки покажу. Представим, что я хочу строку уметь создавать от списка
символов фигурных скобочков. Ну, в принципе, вполне допустимое желание. Я могу захотеть
написать вот так, то есть свою строку, уметь создавать следующим образом. String s от... ну,
либо я так пишу, либо я пишу равно, а дальше пишу там a, b, c, d, e. Вот. Как тогда это будет выглядеть?
Значит, принимаемый тип должен быть std initializer-лист. От чего? От char. Давайте я назову его lst.
И, соответственно, что я могу с initializer-листом делать? Ну, initializer-лист, он чем-то похож на...
на вектор по своему функционалу. А именно у него можно спрашивать, ну, как бы указатель на начало,
указатель на конец. Вот. Размер. Вот. Но обращаться с квадратными скобочками, по-моему, нельзя. Вот.
Но это нам и не понадобится, на самом деле, потому что есть же range-based for. Ну, смотрите,
как это можно было бы сделать. То есть, я сначала хочу выделить, сколько мне надо памяти. Сколько...
как мне узнать, сколько мне надо? Ну, lst.size я могу спросить. Это сколько в нем элементов?
Сейчас я вас на всякий случай проверю, что не обманываю, что все правильно. Что size...
А почему просто вектором его было не сделать?
Вот. Почему вектором не сделать? Ну, потому что вектор сам по себе,
он динамическую память выделяет. А Neuralizer List — это как бы такая встроенная в язык штука.
То есть, на самом деле, все эти A, B, C, D, E — они нигде ни в какой памяти не выделяют. Они, ну,
как бы на стэке, может быть, выделяются, но точно не в динамической памяти. То есть Neuralizer List — это
такой очень хитрый тип. Это как бы не... это не контейнер. Это нечто такое, что реализовать самим
не получится, скорее всего. То есть, это какая-то штука, которую компилятор как-то реализовывает
внутри себя очень хитрым образом, так что на самом деле никакой динамической памяти не выделяется.
Ну, то есть, оно вот как бы хранится вот у него где-то там, прям вот, не знаю, в недрах. Я не знаю,
на самом деле, как компилятор хранит Neuralizer List. Можно погуглить, наверное, покопаться в этом.
Но вот я глупо не разбирался. Но смысл в том, что это всё не занимает выделение никакой памяти в
runtime, не создается никакой полноценный объект, чтобы там из него что-то доставать. Никакого
конструктора там специального не вызывается. Просто это вот такая как бы обёрточка, что по факту
у вас есть пять этих самых чаров. Вот. А оно так обёрнуто, как будто это вот типа контейнер, хотя на
самом деле никого контейнера не создалось. Вот. Чтобы можно было в фигурных скобках писать.
Вот. И, соответственно, когда я спрашиваю у него size, компилятор как-то это внутри реализовывает
сам, что вот он отвечает, сколько их было штук в этом списке. Вот. Причём это всё известно в
Compile Time это число. То есть, size – это число, которое Neuralizer List понятно ещё в момент
компиляции. Вот. Соответственно, я нитилизирую массив таким образом. Вот. Ну, значит, СЗ, ну то
же самое я делаю. Значит, да, кстати, вот смотрите, у меня какая ситуация возникла. Я вот начинаю
писать список инициализации, который не Neuralizer List, а Member Neuralizer List. У меня слишком
длинная строка кода получается. Как мне правильно перенос сделать? А вот как. Я возьму и перенесу на
следующую строку с двойным отступом. Вот. Есть такое правило CodeStyle, удобное на мой взгляд,
и я вас буду просить его придерживаться. Когда вы хотите перенести что-то на другую строку,
потому что у вас не влезает длинная строка, то вы делаете двойной отступ и потом продолжаете
сединарным отступом. Таким образом не путается продолжение кода с продолжением вашей строки.
Вот. А ещё есть хитрость. Когда вы так пишете, вы запятую оставляете в начале следующей строки,
а не в конце предыдущей. Это и удобно читаемость даёт, и удобство добавлять новые элементы в это
перечисление. Вот. Значит, CZ я тоже инициализирую вот этим, и Capacity я тоже инициализирую вот этим
же. Всё. После этого фигурная скобка открывается, и тут я пишу код конструктора. Ну, фигурную скобку
я вот здесь уже открою, чтобы она видна была. Вот. Если строка слишком длинная, то её надо
переносить. Не лучше, а надо. По код стайлу обычно там, ну, кто какие требования устанавливает,
кто 80, но это слишком жёстко. Ну, обычно там 100 символов ограничений на длину строки такое. Ну,
100, может быть 120, но 120 многовато. Вот у меня здесь стоит, кажется, 80. Да, вот эта черта.
Вертикальная полоска в селайне это 100-160 или сколько? 160 многовато. Ну, обычно 100,
мне кажется, разумно. Ну, или 120. 100-120. Короче, на код review будем разворачивать,
если у вас супер длинные строки. Селайне по умолчанию 120. Ну, вот, значит, 120 считайте и надо. Вот.
Ну, докладно. Хорошо, я вот это проинициализировал, а теперь что я делаю? А теперь я просто, ну, я могу,
как бы, сказать for. Ну, у меня есть, у листа есть begin и end. Ну, то есть, это как контейнер. Если вы
умеете итераторами пользоваться, я забегаю вперед, да, вы знаете, что у контейнера можно
вызвать begin и end, и это будет как бы указатели на начало и на конец. Ну, не указатели, а итератор,
на самом деле. Их можно разыменовывать под ним и брать элементы, их можно инкрементировать.
Ну, можно писать и так. Можно писать range-based-for так называемый. Вы, возможно, тоже им умеете
пользоваться, хотя я вам про for не рассказывал. Range-based-for, он как работает? Он для всех контейнеров
работает. Я говорю for элемент, где в контейнере, ну, длиннейшая лазер листов тоже работает. Да, и что я
делаю? Типа, ну, мне тут надо, правда, завести счетчик, там, неприятность. То есть, я буду заполнять,
как бы, значит, вот этот вот R по индексу E++ равно C. Вот типа такая у меня будет конструкция.
Да, ну, вот я заполнил, в общем-то, строкулу элементами этого листа. Но можно было сделать
еще лучше. Можно было использовать алгоритм std-copy. У вас же есть такой алгоритм, который берет
сначала куда, по-моему, потом откуда, значит, я куда, я начало и конец диапазона ему передаю,
потом откуда, а откуда это я передаю вот начало этого диапазона. И что происходит? У меня, значит,
элементы второго диапазона копируются в первый диапазон по элементам.
Работает эффективно и универсально. Нет, я все-таки перепутал. Надо написать сначала откуда, потом куда.
Значит, вот начало конец диапазона, а это начало диапазона куда копировать. Соответственно,
он по элементам скопирует все значения из диапазона вот в другой диапазон. Ну,
это указатель, как бы, на начало второго диапазона.
А еще вопрос. Вот это двоеточие после… Ну, стринг, скобочки, после него двоеточие.
Она под код style должна быть типа вплотную, да? Еще раз я прослушал, что вплотную. После вот стринг,
скобочки, после него двоеточие, дальше лист. Да, по нашему код style оно должно быть вплотную или
через пробел. Мы не ставим пробел. Вот как я пишу, так и надо. Мы не ставим пробел между открывающей
скобкой и содержимым. Сработает ли здесь Memcpi? Меня в чате кто-то спрашивает. Я не знаю. По-моему,
я не уверен, короче. Я не знаю, как хранится внутри initializer-лист. Кажется, что не должен,
потому что динамическая память… Ты делаешь там никакой динамической памяти? Нет. Какой динамической
памяти? В смысле? Memcpi с динамической памятью работает. В смысле? Memcpi вообще без разницы,
какая там память. Он просто принимает пару указателей и еще указателей, копирует диапазоны
из одного в другой. Точно так же. Просто Memcpi надо, чтобы элементы подряд в памяти лежали. Он
как бы блок памяти копирует. Какая-то память ему совершенно без разницы. Он чисто с указателями
работает. Вот. Это что касается initializer-листов. Тут есть разные интересные нюансы, связанные
с этими initializer-листами. Например, когда у вас появились initializer-листы, у вас начинают
возникать вопросы такого характера. Вот, допустим, вы говорите, вот вы решили создать вектор 10.1. Что
это такое? Как вы думаете? Если бы я так написал, понятно, что это значит. Это я решил вызвать
конструктор вектора с двумя параметрами 10n равно 10 и значение 1. А если я написал фигурные скобки,
что это будет означать? Ну вот правило таковы, что initializer-лист приоритетнее, чем обычный
конструктор. То есть, если у вас конструктор initializer-листа, то предпочитается по правилам
перегрузки on. То есть, если вы решите вот такой вектор создать, то у вас получится вектор из двух
int, первый из которых равен 10, а второй 1. Еще веселее, это работает вот когда. Вот представьте,
что вы создали такой вектор, у вас есть, значит, вектор из 10 int, каждый из которых равен 1. А потом
вы решили создать еще один вектор. Ну, вектор, как, впрочем, из строку, можно создавать тоже из
диапазона. То есть, вы можете написать начало и конец диапазона, и он скопирует все элементы в
этом диапазоне. То есть, сейчас я, по сути, создал второй вектор копию исходного вектора.
Но если бы я написал здесь фигурные скобки, то это получился бы вектор не int of. Это бы получился
вектор из двух элементов, но это было бы CE, потому что здесь вектор int написан. На самом деле,
я вектор не из int of создал. Это был бы вектор из двух элементов, являющихся итераторами на другой
вектор. Первый из которых это тот begin, а второй это тот end. Если бы здесь не написал тип, то это
оказался бы вектор из двух элементов вот с такими значениями. Короче, initializer листы добавили
много путаницы. Начиная с C++20. История такая. Начиная с C++11 все... Было модно использовать
фигурные скобки при инициализации, потому что все говорили, смотрите, это initializer листы,
это новомодно, круто. Они у вас будут вызывать нужный вам конструктор, если вам хочется конструктор.
А если есть initializer лист, то вызовут initializer лист. Пишите всегда фигурные скобки вместо круглых,
будет вам счастье. Но в C++17 там следующее произошло. Начиная с C++17 ввели автоматический вывод
параметров класса вот этих вот. То есть вы начиная с C++17 можете не уточнять от чего вектор. Он сам
догадается, исходя из того, от чего вы его создаете, если это однозначный выбор. Когда это
появилось, уже в C++20 люди поняли, что с initializer листами это сочетается весьма плохо, потому что
если раньше вы по крайней мере явно писали от чего вектор, у вас таких проблем не возникало. Но
когда вам можно не писать от чего вектор, а вы продолжаете пользоваться фигурными скобками,
как раньше, у вас возникает внезапность, типа той, что я сейчас описал. И поэтому,
начиная с C++20, мода поменялась. И теперь современные самые лидеры мнений в комитете по
стандартизации C++ говорят, что наоборот, фигурные скобки лучше не использовать, а использовать круглые,
а фигурное использование, когда вы явно хотите initializer лист. Потому что иначе может произойти
вот такой конфуз. Я был однажды на лекции действующего члена комитета по стандартизации,
не российского причем, и вот он сформулировал такое правило, что сейчас стало не модно.
Начиная с 2020 года считается, что фигурные скобки стоит все-таки не предпочитать круглые,
из-за таких проблем. Вот, но по крайней мере вы теперь знаете, что есть initializer листы и как они
себя ведут. Так, это была первая вещь из двух, которые я хотел сказать. Напомню, теперь вторая.
Вторая вещь – это делегирующие конструкторы. Смотрите, вам зачастую бывает нужно, чтобы из
одного конструктора вызвать другой. Ну, например, вот, допустим, у меня есть вот такой конструктор.
Значит, конструктор, который просто отчисла. Что он делает? Он говорит…
Ну, конструктор просто отчисла, он, конечно…
Ну, нет, это плохой пример, потому что конструктор просто отчисла, он заполнит нулями. Давайте я другой
пример покажу. Вот, смотрите, у меня есть конструктор копирования. По сути, этот конструктор,
но он в каком-то смысле выполняет… У меня здесь есть повторение кода небольшое, то есть я опять
выделяю вот это все, а потом делаю мем-копию. Я мог бы теоретически захотеть сделать следующее,
типа давайте вместо того, чтобы сделать, повторять вот это все, вот эти все действия,
я сначала вызову вот этот конструктор, а потом доделаю за него оставшуюся работу. То есть,
я могу захотеть написать как бы, чтобы сконструировать стринга другого стринга.
Сначала нужно вызвать конструктор с этого стринга от его размера и, допустим, символа 0,
а потом сделать только мем-копию. Это называется делегирующий конструктор и это тоже фича начиная
C++11. То есть, раньше вам приходилось, если у вас много конструкторов имеет общий код,
это вам приходилось в общую функцию выносить. А сейчас, если у вас… Ну, стринг — это не очень
хороший пример, потому что тут я бы так не стал писать, неэффективно. Но на будущее,
если вам нужно будет один конструктор выражать через другой, а вам нужно будет, это пишется так.
Вы говорите, когда вам нужен стринг, когда вам нужно сначала вызвать один конструктор,
вы говорите, давайте я сделаю вот так, а вот это удалю все, а потом просто доделаю вот это. То есть,
я сократил код таким образом. Вместо того, чтобы повторять все эти действия, я написал,
что стринг от другого стринга — это как стринг вот от этого создать, но потом еще дополнительно
сделать вот это. При этом, инициализацию полей тут никакую уже писать я не имею права. Инициализация
полей должна только один раз произойти вот в том самом конструкторе, который вот в итоге и вызовется.
Вот. Но это не очень кажется эффективно, потому что тут придется заполнить это нулями, а потом
заполнить еще в дважды, короче, пробежаться. Сначала нулями будет заполнение memset, а потом
memcopy. То есть, это лишний вызов, поэтому я бы так не стал делать. Но в каких-то других ситуациях это
вполне себе правильный выход — выразить один конструктор через другой, чтобы не повторять логику.
Это называется delegating constructors. Делегирующие конструктора. Начиная с C++11. Распространенная
ошибка у людей, которые не понимают C++, — это написать что-нибудь в таком духе.
Типа, ну давайте вот так этот конструктор вызовем. Я надеюсь, вы не будете так писать. Вот. Ну,
возможно, на зачете или на экзамене какой-нибудь из задач у вас будет каверзный вопрос, что будет,
если так написать. Вот. Ну, те, кто так пишут, это значит, они не понимают вообще, как работает язык,
потому что, конечно же, никакой конструктор... Ну, то есть, это будет вызов конструктора,
только это не то, что вы хотите. Это будет вызов... Это будет создание новой строки вот от таких
параметров на стеке временно и сразу же ее уничтожение. Эта строка ничего общего с вашей текущей
строкой иметь не будет. Это ни в коем случае не вызов конструктора для вашей строки. Вообще,
вызвать конструктор явно для текущего объекта нельзя, потому что, если вы находитесь в теле
конструктора, это значит, что у вас уже поля проницелизированы, и вы не можете второй раз,
как бы, это сделать. Вы уже в теле, и все, что может делать, такое выражение. Ну, то есть,
присваивать им что-то. Вот. А это будет просто создание новой временной строки. И это хоть
скомпилируется, но будет делать совсем не то, что надо. Вот. И вот так вы написать, конечно,
тоже не можете. Значит, вызывать конструктор у себя явно нельзя. Это будет просто ошибка
компиляции. Вот. Нельзя так вызывать конструктор. Ну вот. Кажется, теперь это все уж теперь точно,
что я хотел вам рассказать о конструкторах. Вот. И мы переходим к следующему параграфу,
который называется оператор присваивания и правила 3. Мы с вами обсудили, как определять
конструкторы и деструкторы. Теперь пора поговорить о том, как определять для своего класса еще один
очень важный метод, называемым оператором присваивания. Значит, параграф 3.4 AssignmentOperator
and the rule of 3. Правило трех, так называемое. Вот. Ну, лишнее я удалю, пожалуй. Оставлю только стрим.
Вот. Это я тоже удалю. Ну, на самом деле, мне вот, собственно, этих двух вещей будет
достаточно. Будут рассматривать только вот класс стрим, который вам реализовывать уже на этой
неделе надо будет. Уже в контесте появится задача завтра, я думаю. Это будет ваша первая
задача по опе реализовать стринг полноценный. Ну, почти полноценный, конечно, урезанный в версии
очень, но какую бы то ни было имеющую право нажить. Вот. Ну, когда мы пишем вот так, значит, стринг
s, а потом стринг ms2 равно s, вызывается конструктор копирования, как вы уже должны знать. Несмотря на
то, что написано равно, это не оператор присваивания. Но если я решу написать вот так,
то это уже оператор присваивания. И оператор присваивания, как и конструктор копирования,
как и деструктор, он генерирует с компилятором автоматически по умолчанию. Так, надо бы мне,
значит, здесь это написать, а то у меня код не правильно будет работать. Он генерирует с
компилятором автоматически. То есть я его не определил для своего класса, но тем не менее
он будет в нем присутствовать. Давайте я это продемонстрирую. Так, ну, у меня нет конструктора
по умолчанию. Давайте он будет вот таким. И у меня, говорит он, все штуки приватные. Ну,
давайте я их сделаю публичными. Логично, я их все... я не написал слово паблик. Вот, это компилируется,
то есть конструктор этот есть, этот конструктор монореализован, деструктор монореализован,
оператор присваиваемый, но не реализован, но он тем не менее срабатывает, потому что компилятор
вот тоже генерирует автоматически. Что же будет, если это запустить? И опаньки, опять РЕ. Почему так?
Да потому что оператор присваивания, который генерируется по умолчанию, он тоже тупой,
как и конструктор копирования по умолчанию. Оператор присваивания по умолчанию копирует все
поля. Ну, он просто берет, присваивает по элементам все поля. В моем случае это значит,
что он присваивает этому указателю тот указатель, этому размеру тот размер, этой capacity, ту capacity.
Получается, что у меня опять две стринг, но каждый из них указатель на одно и то же. И когда мейн
заканчивается, у обоих вызывается деструктор, у той и у другой, и первый раз дилит нормально,
а второй раз double free detected aborted core dumped. Поэтому мне нужно определить оператор присваивания
для строк, свой собственный, чтобы он не по элементу копировал поля, а делал так называемое
глубокое копирование, полноценно перевделял память. Опять обращу ваше внимание, что если у меня класс
ну типа комплексные числа, вот которые я удалил, в котором поля это даблы просто, то ему не надо
писать свой оператор присваивания, потому что там и дефолтный будет нормально работать. Но ему и свой
конструктор копирования было писать не надо, и свой деструктор писать не надо, там дефолтный
будет нормально работать, потому что там нету никакой нетривиальной логики в этих действиях,
оператор присваивания, значит конструктор копирования деструктора делают триреальные вещи,
копируют все поля там, а деструктор просто ничего не делает, просто потом всё со стэка снимается.
Если у вас класс таков, что в нём либо конструктор копирования, либо деструктор, либо оператор
присваивания делает нетривиальную логику, это значит, что вам нужно явно реализовывать все три,
остальные сгенерированные компиляторы вам не подойдут. Вот это и называется правило трёх. Это
евристическое правило, оно не задокументировано в стандарте, вот насколько я знаю, это просто
правило не то что хорошего кода, это правило как не убить себя, пока вы пишете на C++, если еще раз,
если у вас в классе хоть одно из этих трёх вещей, конструктор копирования, или деструктор,
или оператор присваивания нетривиальные, то есть вы сами вынуждены их реализовать,
потому что дефолтный по умолчанию вам не подойдёт, значит вам нужно все три реализовать,
остальные вам тоже не подойдут с вероятностью 99%. Вот сейчас я продемонстрирую, как реализовывать
оператор присваивания для строк, ну я демонстрирую на примере строк, потому что,
как я уже сказал, комплексных чисел нечего демонстрировать, там как бы все тривиальное,
дефолт не просто подойдёт. Давайте какой-нибудь не тривиальный оператор присваивать реализуем,
например для строк. Ну хорошо, тут мы приходим к разговору о том, а что вообще значит реализовать
для своего класса какой-то оператор. C++ поддерживается, то что называется, перегрузка операторов,
operators overloading. В отличие от, например, джавы, в которой нельзя переопределять операции плюс,
минус, для своих классов, в плюсах можно, то есть я могу для своего класса, для своего типа,
по-своему определить действие оператора равно, ну и любого на самом деле оператора, кроме некоторых,
это мы в следующем пункте обсудим. Но сейчас обсудим, как определить своего класса действие
оператора равно. Я сделаю его членом класса, то есть объявлю и определю прямо в телекласс.
По сути, оператор это такая же функция, просто у неё имя особенное, а в общем-то она ничем не
отличается, просто такая функция со странным названием. А работает также, как перегрузка функции,
нельзя перегрузить точку, ну да, точку нельзя перегрузить, еще нельзя перегрузить знак вопроса
двоеточия, еще нельзя перегрузить точку со звездочкой, еще нельзя перегрузить двойной двоеточия
и еще какие-то вещи, возможно, которые я сходу не вспомнил. Ну в общем, почти все остальное можно.
перегрузить можно, и это даже нам в какой-то момент предстоит сделать.
Так, ну все, сейчас люди начали соревноваться, кто больше знает, молодцы, это мы все обсудим в
следующем пункте. Правда, нельзя поменять приоритет операции. Значит, что мне надо написать? Ну,
мне надо написать сначала возвращаемый тип, как обычно, но я на его месте три знака вопроса
поставлю, мы потом подумка возвращаемый тип. Дальше название метода, но вот, собственно,
здесь единственная особенность, надо просто написать слово оператор, а дальше какой,
равно в моем случае. Ну, по код-стайлу, кто-то ставит пробел между вот этим словом, кто-то
не ставит. Я, наверное, предпочитаю ставить, хотя, по-моему, нет строгих требований,
давайте не буду ставить. И дальше, что он принимает? Надо понимать, что мы, поскольку в телекласс его
реализуем, то у него левый оперант, левый аргумент, то есть это мы сами. Мы реализуем для своего класса
оператор равно от какого-то правого аргумента. Левым аргументом является this для него. Вот,
и мы должны принять правый аргумент. А что правым аргументом мы будем принимать? Ну,
другую строку. Как мы ее будем принимать? Ну, конечно же, по константной ссылке,
потому что по значению это будет означать, что она будет лишний раз копироваться, по неконстантной
ссылке будет означать, что мы не сможем присваивать себе константные строки, поэтому по константной
ссылке. Ну, хорошо, тело функции. Вот здесь уже никаких списков инициализации быть не может,
потому что это не конструктор, это метод обычный, это оператор присваивания. Никаких списков
инициализации нет. У нас уже все поля проницилизированы и у нас уже все поля
какое-то осмысленное значение имеют. Что должен сделать наш оператор присваивания? Он должен
сначала освободить память, занимаемую нашей текущей строкой, затем перевыделить памяти
столько, сколько нужно под новую строку и, значит, переприсвоить. Ну, это не самое оптимальное.
О, люди задают вопросы, почему должна быть ссылка. Так, вот, началось. Ну, давайте еще раз, почему
ссылка? Я говорил, что ссылки это будут преследовать вас надолго. Еще раз, почему по ссылке? Потому что
есть три способа принять. По значению, по неконстантной ссылке и по константной ссылке.
По значению, мы не хотим, потому что тогда при передаче сюда будет создаваться копия второй
строки. Лишняя копия. Зачем нам это нужно? Нам не нужна лишняя копия перед тем,
как ее присвоить. Если мы примем неконстантную ссылку, это значит, что мы не сможем присваивать
себя к константной строке. Но мы хотим и к константной строке тоже присваивать. Поэтому
мы принимаем константную ссылку, как и принято в большинстве ситуаций делается, плюсов.
Ссылка нужна не только там, я пока не понял, о чем вы, ну ладно, но ссылка нужна много где,
да. Сейчас увидим. Так, что я делаю сначала? Сначала я освобождаю память, которая занимает
моя текущая строка. Я сразу предупреждаю, что это пока не лучшая реализация, я пока делаю
наивную реализацию, что называется. Сейчас мы постепенно ее превратим в хорошую. Я освобождаю
память, которая занимает мою предыдущую строку. Дальше я переведеляю память столько,
сколько нужно, чтобы хранить ту строку. Как я это делаю? Ну теперь я говорю заново. R это new
char размера s.cz. После этого я говорю cz равно s.cz cap равно, ой, что же я пишу, s.cap. Я
переведеляю памяти не как размер той строки, а как количество выделенной памяти у той строки.
Cz равно s.cz cap равно s.cap. А дальше делаю memcpi. Сначала куда, потом откуда и потом сколько.
Вот memcpi обратный порядок, это неприятно. Значит, куда var, откуда s.ar и сколько cz.
Ну вот, как будто бы и все.
Чего не хватает? Ну мы, во-первых, не поняли, какой должен быть возвращаемый тип. Ну,
хочется наивно написать, что void, но это неправильно. Ну то есть можно написать void,
оно так будет работать, но это не канонично, я бы сказал. Оно будет работать не всегда,
когда хотелось бы. В некоторых ситуациях это будет работать не так, как ожидается.
Дело в том, что стандартная семантика оператора присваивания позволяет вызывать
его в цепочку, я напомню. То есть для стандартных типов оператор присваивания позволяет себя
вызывать вот так вот, раз за разом, друг за другом. И даже делать вот так. Если у нас
возвращаемый тип будет void, то такие схемы не будут работать. Потому что понятно почему.
Вот. Почему нельзя выделить только s.cz? А почему вот некий Федор телефон мне почему-то
все время в direct message пишет? Может паблик надо писать? Я не знаю.
Почему нельзя выделить только s.cz? Наверное, можно, но я хочу полноценную копию строки
создать, то есть в точности копию той строки. Как она была со всеми аналогичными характеристиками,
в том числе с кпейстом такой. Поэтому я и выделю столько, сколько у нее выделено.
Cap – это то, сколько выделено. У нас динамически расширяющаяся штука.
Вы понимаете, что у нас cap – это зарезервированное количество, а s.cz – это реально занятое символ.
Так вот. Поэтому мы хотим, чтобы возвращался не void, а строка. Но опять же, если мы напишем просто
string в возвращаемом типе, это будет означать, что при возврате создается копия нашей строки. То
есть мы возвращаем не нас самих, а копию себя. То есть при выходе отсюда должен будет еще раз
вызваться конструктор копирования нашей строки, чтобы вот ту копию вернуть наружу и уже ее отдать
в то выражение. Ну и при этом не будет работать вот такая вот схема, потому что это будет означать,
что мы не себе, после того как присвоили s2, присвоили s3, а копию себя присвоили s3, то есть
это будет работать, не так, как ожидали. Ну либо вообще не будет компилириваться, либо будет работать
не так, как мы хотим. То есть не не себе будет присваиваться s3, а копию себя. Поэтому мы не
хотим возвращать копию. Мы опять хотим возвращать ссылку. Мы хотим возвращать ссылку на строку,
и вот мы будем возвращать себя. То есть мы будем возвращать наружу из оператора присваивания ссылку
на себя самого. Это позволит извне этот оператор присваивания считать, что он возвращает строку,
но этой же строке можно присваивать, и от этого сама она поменяется. Соответственно, что я должен
написать после return? Я должен написать return, напоминаю vis это указатель на себя, нам нужна ссылка
на себя, поэтому я разминовываю vis. Вот, теперь это более-менее нормальный оператор присваивания уже
куда не шло, так скажем. Впрочем, тут есть еще некоторые проблемы. Ну, он не очень оптимальный,
его можно было бы сделать оптимальнее. Каким образом? Если бы я заметил, что у СЗ, что у той строки,
короче, что памяти, которая у меня сейчас выделена, хватает, чтобы ту строку вместить,
то я мог бы соптимизировать и не делать delete и снова new. Я напоминаю, что вызвать delete и new
это очень дорогие операции, они там примерно порядка сто раз дороже, чем обычные операции над
числами. Вот, то есть вот эти операции мы хотим минимизировать их количество в нашем коде. Вот,
и можно было бы, значит, от них избавиться, если у нас проверить, что тот размер, он меньше, чем наш,
только paste меньше немножко. Но это ладно. Есть еще один такой интересный случай, когда вот такая
вещь написана. Вот что, если я попытаюсь строку присвоить самой себе? Ну, ничто не запрещает
мне такое написать в коде в мейне пользователям моего класса. Причем он может не осознать написать,
то есть тут может быть какое-то выражение, которое там что-то там вычисляет и либо равно
одному, либо другому, то есть строке я присваиваю либо ее саму, либо другую какую-то строку. Вот такая
конструкция. И вот, допустим, у меня в какой-то момент в коде возникло выражение присваивания
строки самой себе. Что тогда будет делать так реализованный оператор присваивания? Ну, получится,
что сначала я удаляю свой собственный массив, потом выделяю новый массив такого же размера,
как был, переприсваиваю себе старые же значения, а потом начинаю копировать из старого массива,
ну, а потом начинаю, значит, из R в SR копировать. Но, минуточку, R и SR это у меня уже новый массив,
а не старый. То есть это один и тот же массив новый. Получается, что после такого присваивания
самому себе у меня будут некорректные поведения, у меня в строке начнут лежать рандомные символы,
потому что я скопировал их же на них же самих. Вот. А, кстати, еще и Memcpi у меня тут, тут у меня
еще проблема с тем, что это пересекающиеся диапазоны. Вот. И Memcpi, я не уверен, даже будет ли
корректно работать при таком, при пересекающих диапазонах. Вот. Ну, короче, в любом случае я не
получу корректное поведение, в лучшем случае я получу рандомные символы вместо того, что в строке
лежало раньше. Вот, понятно. Ну, если не понятно, внимательно проследите, что происходит, осознайте
еще раз, и поймите. Вот. Поэтому мне можно исключить изменение под константной ссылкой. Это
что значит изменение? Что значит под ссылкой? Я не понимаю, что значит под ссылкой. Вы, если можете,
голосом вопрос задавайте. Да, если у меня был элемент X, я создал на него касанную ссылку и
изменил X. На кого? На X? Ну нет, в смысле изменил значение X. Ну да, у меня был X, я создал константную
ссылку на X и изменил значение X. Если у тебя был какой-то объект X, ты создал константную ссылку
на X и изменил X. Так что ли? Да. Ну все окей, по Y ты будешь видеть новое значение и по X новое
значение. Вот плюс плюс Y, видимо, не получится. Плюс плюс Y не получится, да. Хорошо, спасибо. Так,
ну вот вы уже начали задавать вопросы, которые мы подробно разбирали на прошлых парах. Вот,
я, конечно, могу на такие вопросы отвечать, но если таких вопросов будет много, то я буду
говорить, идите пересматривайте или... ахаха, у вас лекции не... а лекции все еще не выложены. Вот,
да. Ну короче, да, если вы будете много вопросов задавать, что было раньше, то мне придется вам в
какой-то момент начинать отвечать, идите пересматривайте лекцию такую. Вот, а то мы...
Все еще не будет, скорее всего. Чего? Которой в записи, скорее всего, не будет, потому что вас
как-то очень странно выкладывают. В смысле, их так и не выложат? Ну есть шанс, что многие лекции
будут выкладываться задержкой просто месяц-два, такими темпами. А, понятно. Ну, идите пересматривайте
лекции прошлого года, что могу вам сказать в том плейлисте, который я скинул. Ну там не настолько
подробно было, как мы с вами разбирали. Мы с вами подробнее разбирали, чем я в прошлом году рассказывал,
но хотя бы эти случаи были там разобраны, конечно. Вот, окей. Ладно. Так вот, я хочу исключить случай
присваивания самому себе. Для этого я просто в начале допишу костыль. Если я обнаружил, что я
присваиваюсь самому себе, то сразу возвращаю, выхожу, ничего не делая. Как мне это проверить? Как
проверить, что я присваиваюсь самому себе? Это вопрос в зал. Чего надо написать?
z и с равно, видимо, ссылка от s. Не ссылка, а адрес. Давайте не называть оператор ссылкой. Значит да,
мне нужно проверить, что this равен адресу s. Ну, я могу написать сразу return звездочка this.
Да, if и однострочники короткие у нас разрешены, если что. Вот. Такое можно делать иногда. Вот. То
есть, я исключил этот случай, потом сделал все, как полагается. У вас, правда, мог возникнуть вопрос,
а почему мы, когда писали конструктор копирования, не предусмотрели копирование
от самого себя? Вот что, если я так напишу? Ну, или вот так. Ну, так это же неопределенного мы себя
еще не создали. Как вы думаете, что будет, если так написать? Ну, c и v, видимо. Ну,
либо r e. Бесконечная рекурсия. Да, ну, будет бред какой-то. c и e не будет. Ну, дело в том,
что... А почему c и e не будут? Это ж вроде можно отловить в compile time. Можно, но по правилам языка
это не ошибка. Если вы припомните, вот когда мы разбирали... Опять-таки, я возвращаюсь к тому,
что мы уже обсуждали. Когда вы пишете вот так, я, если вы вспомните, мы такое разбирали. Область
действия x начинается сразу же после знака равно, поэтому этот x здесь уже действует. Когда вы пишете
int x равно x, считается, что вы... Это все равно, что написать просто int x. Ну, такие правила. Поэтому,
когда вы написали string s равно s, это значит, что вы вызвали конструктор копирования от
себя самого, но вы сами при этом еще не созданы. То есть, у вас в полях лежит мусор, но вы скопировали
мусор. То есть, у вас будет... У вас действительно вызовется вот этот конструктор, но в полях мусор,
поэтому вы вызоветесь... То есть, будет ub, фактически. Вы вызоветесь, вы сделаете new char от
рандомного числа, и дальше будет бред полный. Это почти гарантированная реакция. Но можно попробовать
посмотреть, что будет. Да, кто понимает, что произошло? Что означает эта ошибка? Мы попытались
селлоцировать непонятную память, получили палкой в лог. Нет, мы попытались селлоцировать слишком
много. Или отрицательное число. Или отрицательное число, может быть, да. То есть, bdelog — это ошибка,
которая кидается оператором new в случае, когда запросили либо слишком много, так что операционная
система отказала в выделении памяти, либо запросили, да, отрицательное число. Вот. Я не уверен,
кстати, отрицательное число там, по-моему, sizeT принимается в качестве параметра, но, возможно,
оно переконвертировалось в int. Оказалось, что там запрошено сколько-то гигабайт, много миллиардов байт,
и всё. Bdelog. Эта ошибка означает, что... Ну вот, это, по сути, и произошло. Я вот здесь, вот в этом
месте просто в качестве CZ подставилось рандомное число, которое там лежало в этот момент, и произошла
вот эта вот ошибка. Вот. Сейчас, то есть, после того, как мы написали string s, у нас в s уже
пронициализированы все значения? Нет. В том-то и дело, что в s здесь не пронициализированы все
значения. s сейчас объект, у которого не пронициализированы по s, фактически конструктор ещё не отработал
никакой. Паля еще не пронициализированы, но я вызываю конструктор копирования от этого, аж. Я
правильно понимаю, что у нас фактически упало на строчке error в no new char s? Да-да, вот в этом месте.
А если в полях есть ссылка? Ну, будет рандомным значением пронициализировано также. Давайте
проверим. Сейчас только. У нас фактически работает инициализатор, а не оператор.
Какой инициализатор? Конструктор работает. Это я уже повторял несколько раз, что если вы пишете
string s равно что-то, то это не оператор присваивания, это конструктор. Потому что это declaration,
а не expression. Ну, если в полях будет ссылка, это ничего не изменит. У вас будет
не пронициализированный объект. Ну, короче, просто так писать не надо и всё. Как он поймет,
от какого конструктора вызывается? От какого пора? Ну, как? Справа же string. Да. С какой?
String. Значит, мы создаем string от string. Значит, нужно идти в конструктор копирования.
Вот после string s у нас все поля заполнены мусором или их вообще ещё нет? Что значит после string s?
Ну, вот у нас string s, вот по символе string s и вот до равно. Нет, у вас точка запятой является границей
команды. Вот когда что-то происходит, это точка запятой. Вот после string s точка запятой я могу
сказать, что у вас конструктор по умолчанию отрабатывает. После string s перед равно ничего
не происходит, происходит продолжение синтоксического парсинга предложения. Когда компилятор распаршивает
его до конца, до точки запятой, он понимает, что здесь сказано сделать и делает это. Здесь сказано
создать s от s. Вторая s справа, это вот она сама. Ну, у неё ещё ничего не принадлежит. Ну, пофиг. Мы
вызываем конструктор копирования от неё же. А если мы запретили у s конструктор, то когда мы так
напишем? Какой конструктор? Обычный, дефолтный? Ну да. Параметров? Нет, ничего. Мы же не вызываем
дефолтный конструктор. Мы вызываем конструктор. Мы в операторе конструктора же. Что такое оператор
конструктора? Мы здесь не вызываем дефолlene конструктор. Мы внутри оператора копирования вызываем
мы вызываем только конструкторы. Внутри конструктора копирования мы... Нет, мы не вызываем дефолтный
конструктор. Мы вызываем вот этот конструктор. Вот этот конструктор мы не вызываем. Его и нет,
он не сгенерирован, его фактически и нет. А то, что я напишу string-crowed-delete, ничего не поменяется,
потому что его и так нет, если вы про этот конструктор. Я правильно понимаю, что если мы
зашли в оператор копирования... Мы не зашли в какой оператор, мы не зашли. Но не оператор,
в копирование. Конструкторы мы зашли, заходим только. Так, конструктор копирования. У нас есть
const-3-comper-sant-s. Да. Оно еще не пронициализировано. Ну, ссылка пронициализирована, а то,
что под ней нет, не пронициализировано. Окей. А если мы обращаемся к аргументу, то оно
пронициализируется. С.сз это какое-то рандомное число, туда еще ничего не написано. Там рандомное
число лежит. А, это вообще... А, ладно. То есть оно пронициализировано, рандомное число? Нет,
оно ничем не пронициализировано. Там просто лежит последовательство с byte, которое мы прочитаем
как число, так? Да. Ну, пронициализировано. Есть понятие default initialization, а есть как бы
никакая неинциализация. Одно дело, когда у вас написано int x, вы как бы считаете, что вы создали
x, но просто оно пронициализировано. Но, значит, вот эта default-инциализация для int работает,
как там рандомное число лежит. А тут никакой инициализации не было. Вы просто взяли память,
которая лежит под string, у вас формально ни один конструктор еще не вызвался для этого объекта,
поэтому никакое поле не пронициализировано. И там лежат рандомные числа по его полям,
но формально и даже default-нинициализации не произошло. Вот.
Ну, как не произошло, если у нас ws.soz лежит случайное число?
Нет, не произошло, потому что инициализация полей происходит тогда, когда вызывается конструктор.
Там лежит случайная память. Мы не вызвали конструктор string. Чтобы пронициализировать поля,
должен отработать какой-то конструктор. Перед входом в конструктор происходит инициализация
полей. Пока нет вызова конструктора, никакой инициализации полей не происходит.
Короче, там лежит случайная память, которая как бы нам была выделена, но мы вообще никак с ней
не взаимодействовали, так? Да. Ну, формально это убе, потому что время жизни cz еще не началось.
Вот я даже так скажу. Я могу это скомпилировать с санитайзерами, и он мне должен сказать это,
по идее. Ну, это он мне сказал, что я запросил слишком много, а если я попрошу его undefined...
Нет, не говорит. Может, Seleng скажет. Ну, Seleng мне говорит warning еще до...
Seleng без всяких санитайзеров мне warning кидает. Я мог бы, кстати, наверное, из JCC warning попросить
включить, и он мне тоже сказал, что это убе, так писать. Нет, не сказал. Тоже собака не сказал.
Ну, короче, GCC не говорит, а Seleng говорит, вот это убе я то, что здесь делаю. Я использую
неинициализированную переменную в конструкторе. Обращаюсь к полю s.sz, время жизни,
которого еще не началось, потому что для него не вызвана инициализация никакая,
потому что конструктор не начал отрабатывать для него. Я обращаюсь к полю объекта, у которого
не был вызван конструктор, а значит, поле не проинициализировано. Так, ну ладно, долго мы
сидим на этом примере, давайте дальше. Ну, не надо так писать, короче. Вот, что теперь про этот
оператор присваивания еще можно сказать. Ну, он реализован не очень умно, потому что можно было
бы покороче. Давайте я научу вас реализовывать оператор присваивания покороче. Ну, во-первых,
вот что хочу сказать. Вот кто-то мог бы сказать, зачем нам здесь писать delete r,
можно просто деструктор вызвать. Это то же самое. Ну, для стринг, кажется, это без разницы,
там всего одна строчка в теле деструктора. Но если это было бы что-то более сложное, чем стринг,
например, это было бы какое-нибудь, ну, я не знаю, у вас дерево, и в нем было бы много указателей,
которые каждый нужно было бы дилитнуть, когда вы уничтожаете старое дерево. Вам бы не хотелось
писать много раз delete, delete, delete, у вас в деструкторе это и так написано. Вот, поэтому
можно захотеться здесь написать просто деструктор, а дальше уже вот это. Это неправильно, так нельзя.
Почему так нельзя? Кто знает? Кто смотрел лекции наперед? Я смотрел лекции, которые вы нам скинули.
Нельзя два раза уничтожать у одного объекта. Значит, по стандарту, если у одного и того же
объекта два раза вызывается деструктор, это уб. Вот, поэтому, когда вы так написали, если вы
скомпилируете с оптимизацией, компилятор имеет право после того, как вы деструктор первый раз
вызвали, вообще игнорировать все дальнейшие действия над полями, потому что компилятор считает,
что после того, как деструктор хоть один раз вызван, больше обращений к полям объекта не будет
никогда. И, де-факто, если GCC с оптимизацией скомпилировать вот такое, то вы с удивлением
обнаружите, что вот эти поля, вот эти инструкции просто проигнорированы. Ничего не делается,
полям ничего не присваивается, потому что компилятор считает, уже деструктор отработал,
нет смысла что-то полям присваивать. Уже объект умер, только деструктор отработал. Поэтому так писать
нельзя. Вот, а как можно написать? Есть такой хитрый способ реализовать оператор присваивания,
который называется copy and swap. Сейчас я о нем расскажу. Смотрите, я это все удалю, короче,
и напишу вот что. Давайте я создам копию текущей строки и назову ее copy.
Вот. Дальше я сделаю следующую интересную вещь. Я сделаю swap с этой копией. Что такое swap?
Это у меня еще не было написано, но я поясню. Swap это просто swap всех полей. Вот если мне дали
какую-то строку swap, то я сделал, я могу вызвать std swap. Значит, r s.r std swap cz s.cz и std swap
cap s.cap. Ну, метод swap, он есть на самом деле у всех стандартных контейнеров, включая строки,
и он именно так работает. Он просто берет и свопает все поля. Вы меня спрашивали, как swap работает
с векторами в завод единицы. Вот так и работает. Как вектор свопнуть с другим вектором завода единицы.
Ну, например, так он просто указатель переставляет и размеры переставляет, соответственно. Так и swap
строк работает. То есть этот метод, он в любом случае полезен. Так вот, я взял, вызвал swap от этой
копии и все. Дальше написал return this. Вот вам и весь оператор присваивания. Извините, а мы почему-то в
операторе присваивания с вообще не используем. Мы не должны стринг-копию с бано-звездочкой сделать?
А, равно с, наверное, а не vis. Ну да. Давайте посмотрим. Да, это странно, конечно. Не vis, а с.
Я затутнился сомневаться. Что произошло? Ну, я создал копию той строки, которую мне дали.
Конструктором копирования. Потом завод единицы поменял свое текущее значение, текущую строку с
этой копией. Теперь моя строка стала тем, чем раньше была копия, а то, что раньше было моей строкой,
теперь называется копия. Но поскольку копия локальный объект, он уничтожается, когда эта функция
заканчивается. Вот и получается, что у меня как бы то, что копия, то есть строки продолжают жить во мне,
а я, будучи свопнутый с копией, уничтожаюсь, когда выхожу из этой функции, потому что деструктор
копии вызывается. Это называется копиен своп. И это хитрый такой способ реализовать оператор
присваивания коротко и красиво. И заметьте, что здесь мне не нужно даже делать проверку на то,
равно ли с. Короче, присваивание самому себе тоже работает корректно теперь. Потому что присваивание
самому себе, это означает, что я просто создаю копию себя же и свопу у себя же с собой же, но это
корректно. То есть просто, ну это лишнее действие, я мог бы его не делать, но оно корректно. Я просто
создал копию того, чем был я. У меня две эквивалентных копии себя, но я переставил указатель,
одну удалил, другую оставил. Это все еще корректно работает. Вот и в такой ситуации я могу еще сократить
код и сюда принять стринг вообще по значению, а не по константной ссылке. Зачем мне создавать
копию отдельной строкой в коде, если я могу сразу принять s по значению, и копия уже будет
создана за меня. То есть я взял копию, принял сразу той строки, которую хочу присвоить, свопнулся с
ней и все. Вот весь оператор присваивания. Вот. Понятно. Вот это красивая реализация оператора
присваивания. Вот. Такие дела.
Ну, наверное, это все, что я хочу сказать про оператор присваивания. Сейчас я про правила
трех. Еще момент, который я хочу здесь упомянуть, это что вообще-то, что в случае оператора присваивания,
что в случае конструктора копирования, у вас имеют право одновременно существовать и такой
конструктор, и такой конструктор. Ну, если у вас есть вот такой, то компилятор этот уже не будет
сгенерировать. Но вообще-то вы можете явно попросить сгенерировать компилятор вот такой конструктор,
и тогда конструктор от неконстантной ссылки будет работать так как по умолчанию работает. То есть
неправильно. Вот, но иногда, очень редко, но иногда бывает нужно, чтобы конструктор, там, от
неконстантной ссылки, от неконстантного стринга работали иначе, чем конструктора константного
стринга. Их можно перегружать. Аналогично, если у вас есть конструктор от неконстантной ссылки на
стринг, то компилятор не будет уже генерировать вам конструктор от const-string-compersand, если вы
явно не попросите. То же самое с оператором присваивания. Если вы сделали оператор от
string-compersand, то от const-string-compersand уже не будет генерироваться. Вот. И оператор присваивания
тоже относится к функциям, которые компилятору можно явно попросить за вас сгенерировать,
то есть написать равно default. Если по какой-то причине компилятор не сгенерирует их сам,
если почему-то вам нужен оператор присваивания с генерированным компилятором, можно написать
равно default и компилятор сгенерирует, если, конечно, ему что-нибудь не будет запрещать это сделать. А
что ему может запрещать это сделать? Вот если вы попросите равно default у класса, у которого полями
являются ссылки или константы, то компилятор вам откажет. Он не сможет ничего сгенерировать.
То есть оператор присваивания не получится сгенерировать, даже если вы явно попросили,
у класса, у которого в полях есть ссылки или константы. Потому что непонятно, как их присвоить.
Он не может по-члену присвоить. Ну, ссылку он как бы может, но это будет не то, что ожидается,
скорее всего. А константу, в принципе, присвоить нельзя. Поэтому он просто откажется генерировать
этот оператор. Так, ну всё. Это всё, что я хотел рассказать пока про оператор присваивания.
Про вот это вот, кто там сильно наперёд, я не буду сейчас говорить там про LVLU и RLU,
значит, квалификаторы не будем пока. Это ещё успеем обсудить. Пока и так хватит вам
у головы чем заморочить. Хорошо, давайте пойдём дальше. У нас ещё 15 минут. И давайте следующий
пункт. Ну, собственно, следующий пункт, он про перегрузку остальных операторов.
Значит, перегрузка прочих операторов.
Так, у меня уже есть какой-то файлик. Ну, давайте я его, да, удалю это в чёртом матери,
сделаю новый файлик. Ну, теперь я уже буду, значит, на примере какого-нибудь другого класса
показывать перегрузку. Мне кажется, что как раз можно показывать перегрузку, либо на примере
класса комплекс, либо на примере следующего класса, в котором предстоит реализовывать класс
длинных чисел Big Integer. Ну, давайте я буду показывать на примере класса длинных чисел. Ну,
вы все, наверное, в своей жизни писали длинную арифметику хоть раз. Overloading, да, я пропустил
буквой R, не знаю почему. Overloading. Да, все вы наверняка знаете, что такое длинная арифметика.
Вот, и питоня у вас длинная арифметика встроенная, там сколько угодно длинные числа могут быть,
а в плюсах нет, и вам надо её реализовывать самим. И вот, значит, вторая задача, которая у вас будет
после стринг, это написать Big Integer, то есть класс длинных чисел, который будет поддерживать там
все операции плюс-минус, может разделить, быстро умножить, быстро разделить, там и так далее. Вот,
и с правильной семантикой, с присваиванием составным, и так далее. Вот, сейчас мы еще раз вкратце
обсудим все, значит, основные операторы, которые мы обсуждали так упорно в пункте 1.4, но теперь мы
уже на новом уровне их обсудим, а именно как их сами реализовывать, и как правильно, что из них
должен кто возвращать, чтобы вся семантика сохранялась корректно, чтобы виды value были
правильными, и так далее. Ну вот, если говорить про класс длинной арифметики, что в нем в качестве
полей можно хранить? Ну можно хранить вектор чисел, да, не знаю, назовем его digits. Ну там, я не буду
сейчас писать прям, как полагается, ну вот, допустим, я реализовываю длинную арифметику, там у меня
наверное еще какие-то поля надо будет, но это мы потом сами догадаетесь. Вот, у меня сейчас интересно,
допустим, конструкторы все уже написаны, там система числения, все с ней понятно, вот, мне
интересно, как реализовать именно операторы? Вот как правильно реализовать плюс, например?
Да, ну, во-первых, как реализовать оператор присваиванием? Оператор присваивания, тут
дофолт не подойдет, потому что у меня в полях вектор. Вектор сам корректно умеет присваиваться,
поэтому мне присваивать ничего по-умному не надо, у меня поля, и так ими умеют присваивать друг
друга корректно. Давайте обсудим, как, например, плюс реализовать. Ну как реализовать плюс? Ну,
арифметических операторов. Я сейчас напишу комментарий, арифметические операторы, но понятно,
что в своем коде не надо писать, конечно, такие комментарии – это глупости, это тавтология, это видно
и так, что они арифметические, это просто я, чтобы разделить, так сказать, в учебных целях. Как
перегрузить оператор плюс от двух bigintegers? Ну, что должен возвращать плюс? Плюс должен возвращать
новый biginteger. Не ссылку на старый biginteger, а именно новый biginteger, потому что плюс,
он возвращает новое временное значение по семантике. Когда вы написали a плюс b,
вы создали новый объект, вы не какому-то из a и b присвоили эту сумму, а вы создали новый объект,
являющийся суммой этих двух, его вернули. Не ссылку на него, а копию. Потому что у вас объект
временный, вы его только что создали, и вот он в воздухе подвешен. А ссылаться не на что,
у вас нет той переменной, на что вернуть ссылку. Понимаете, вам нужно создать новое нечто,
и вот его вернуть. Поэтому, когда мы реализовываем операторы бинарные арифметические типа плюс,
мы возвращаем копию, ну то есть значение. Принимают они, конечно, аргументы по
константной ссылке. Опять же, почему? Потому что копию мы не хотим лишнюю создавать,
когда второй аргумент прибавляем к себе, и не константную ссылку тоже плохо,
потому что константные тоже должны уметь. Вот, и здесь пишем соответственно код сложения. Ну,
у вас будет код выглядеть примерно так. Вы тут создаете big integer, не знаю,
c, ну или сумма. Тут делаете собственно сложение и возвращаете эту сумму.
Ну, аналогично вы реализуете минус, там умножить, разделить. Вот.
Тут есть несколько тонкостей. Первая тонкость такая. Как правильно выразить составные
присваивания? Мне нужно, например, еще выразить плюс равно. Что должен возвращать плюс равно? А вот
плюс равно должен возвращать ссылку, как и любое присваивание, потому что плюс равно дает мне
ссылку на то, что получилось, и ему я снова могу присваивать. А void ему не по госту делать, да? Да.
Оператор плюс равно от const big integer another. А что я тут делаю? А тут я делаю сумму,
ну и пишу return with, потому что я вот здесь как раз проявляется разница между плюс равно
себе, это вам в строках тоже надо будет делать, и плюс. А плюс равно эффективней, чем плюс должен
быть. Почему? Потому что я себе, ну я в себе же что-то меняю и возвращаю ссылку на себя.
Но тут, как вы можете догадаться, будет один и тот же код. Вот здесь вот будет код, ну это ладно
еще, сложение, там один цикл. А если умножение, там фурьешка будет у вас, допустим, или какой-нибудь
там, ну хоть даже обычное умножение в столбика, но там два цикла уже. Ну короче, тут много кода.
И вот тут и вот тут он одинаковый. Понятно, что мы не хотим дублирования кода, поэтому один из
операторов плюс и плюс равно нужно через другое выразить. Вопрос важный на понимание, какой из
операторов плюс и плюс равно нужно реализовать, скажем так, в каком из этих операторов нужно
написать код самого сложения, а какой оператор нужно выразить через второй? Ну очевидно,
если мы будем выражать плюс равно через плюс, то мы потеряем все ускорения. Да, именно. Вот,
ну если вам это очевидно, то хорошо. Да, замечательно, если вам это очевидно, то хорошо,
а если не очевидно, то плохо. Вот, но многим не очевидно, я уверен. Поэтому объясняю, если вы,
интуитивно первое, что хочется сделать, первое наивное желание, это выражать плюс равно через
плюс, потому что кажется, что плюс это что-то фундаментальное, а плюс равно это присваивание
с плюсом дополнительным. Если вы, не дай бог, выразите присваивание как А равно А плюс Б,
то вы создадите лишнюю копию еще, возможно, дважды, потому что у вас будет сначала А плюс Б
лишняя копия, потом еще лишнее присваивание, это копирование. То есть у вас будет О от Н,
причем не то, что у нас будет двукратное О от Н, сначала создание копии, когда вы сделали плюс,
а потом присваивание этой копии себе по элементу. Вот, поэтому, конечно же, нужно плюс выражать
через плюс равно. Поэтому вот здесь вот реально код сложения, а оператор плюс, он буквально
выражается вот так в три строчки. Сум плюс равно another, то есть я изначально сумму делаю равной себе,
потом плюс равно и делаю второй аргумент и возвращаю ее, то что получилось. Фактически
реализация оператора плюс вот так и должна выглядеть. Как и всех бинарных обычных операторов,
минус умножить разделить вот так же. А вот плюс равно, тут уже логика какая-то содержится.
Но это не все проблемы. Есть еще такая проблема. Вот вы заметили, что я пока все операторы делаю
членами класса. Но вообще-то операторы могут и не быть членами класса и понимать, когда операторы
должны быть, а когда нет членами класса, это тоже нужно. Вот на что это влияет? Ну, например,
вот я пишу, ну, у меня есть конструктор, ну, должен быть конструктор, big integer от обычного
импа. Я же могу создать big integer от каким-то интовым значением. Я могу сказать big integer,
там bi равно 5. Вот. Потом могу сказать big integer, не знаю, ci равно bi плюс 5. Вот. И здесь у меня
будет вызван оператор плюс. Но как он будет вызван? Да, у меня оператор плюс, у него левый оператор
bi. То есть big integer правый оперант int. И тут начнет происходить неявное приведение типов. Если у меня,
у big integer есть конструктор от int, то это значит, что он позволяет неявный каст из int в big integer.
Это значит, что, когда я так пишу, вызывается оператор плюс от двух big integers, от левого
аргумента big integer и правого аргумента big integer. Вот. И он, значит,
делает неявный каст пятерки к big integer, а потом выполняет вот этот код. Но такое может сработать,
только если левый аргумент это big integer. Если левый аргумент это int, а правый аргумент big
integer, то такое не сработает. Потому что вот этот оператор, он всегда подразумевает, что левый
аргумент, то есть первый оперант, это this. И неявный каст левого операнда не рассматривается.
Рассматривается только неявный каст правого операнда. Если я напишу вот здесь вот не bi плюс 5,
а 5 плюс bi, это не будет работать. Это не скомпилируется, потому что нет у int операции
сложений с big integer. А с кастить int к big integer сейчас нельзя, потому что оператор плюс — это
член класса big integer. А если он член класса big integer, то у него всегда первый аргумент — это big
integer должен быть, чтобы он попал в рассмотрение. Поэтому, если вы хотите, чтобы ваш оператор
работал симметрично для левого операнда и для правого операнда, вам нужно этот оператор делать
не членом класса, а внешней функции. И вот именно таким должен быть оператор плюс. Я его отсюда
убираю, а вставляю сюда. Как он должен работать? У него должно быть два аргумента теперь уже,
потому что он не член класса. И вот когда оператор не является членом класса, у него нет неявного
первого операнда viz. У него все операнды нужно явно указать. Поэтому у него сейчас у меня два
аргумента уже. Я могу сказать a и b. И могу сказать, что здесь сумма равна a, потом сумма плюс равно b,
и вернуть сумму. Но я могу это сделать похитрее. Я могу опять избежать, чуть сэкономить и сказать,
что сразу я просто принимаю по значению вот этот вот левый оперант и просто возвращаю то,
что получилось. Но только имена a и b, наверное, не очень хорошо писать. First, second лучше,
потому что однобуквенно имена это плохо. Вот так выглядит оператор плюс в двух видах. Тоже
самое с оператором минус и так далее. Со всеми симметричный оператор. Оператор присваивания я
уже не могу сделать не членом, потому что мне для оператора присваивания нужно, чтобы обязательно
был viz. Если я нахожусь не в классе, то viz не имеет смысла. Только вам нужно в паблик вынести
плюс равно. Понятно, что это все должно быть паблик. Я не пишу паблик, потому что забываю
про него. Понятно, что я подразумеваю, что операторы у меня публичные. Можно писать
стракт вместо класс. Вот так вот выражаются правильно бинарные операторы. Во-первых,
бинарные операторы не являются членом класса, присваивания являются членом класса, а операторы
выражаются через присваивания, а не наоборот. Есть еще унарный плюс, унарный минус. Я напомню. Вот
и эти операторы они... Ну вот, например, что такое унарный минус? Он возвращает новый big integer,
и у него нету параметров. Ну, если его делать членом класса, то у него нет параметров,
потому что у унарных операторов первый аргумент. Итак, не явно this, а правого нет,
второго нет. Если я бы написал второй параметр здесь, то это был бы бинарный минус. А я не
написал параметров и сделал членом класса. Поэтому это получился унарный минус. И что должен делать
этот минус? Я могу выразить его через бинарный минус. Например, я могу сказать return 0 minus this.
Это будет, значит, ну, как бы бинарный минус. Ну или могу скорее тут правильнее сделать не так,
а у меня еще должно быть поле sign, которое отвечает за знак, и я его поменяю на противоположное и верну
копию того, что получилось. Варианты разные, но смысл в том, что вот этот унарный минус,
если он член класса, то у него нет параметров. А если вы унарный оператор делаете не членом
класса, то тогда у него надо явно прописывать параметр. Вот этот единственный параметр и
будет вашим единственным параметром, от которого оператор называется. Ну, давайте последнее,
что я за сегодня расскажу, это как перегружать инкременты. А где предпочтительнее писать
вне класса или внутри? Я же вам сказал, это зависит от того, какой оператор вы реализовываете.
Ну понятно, но если типа при прочих равных. Ну, я не знаю, что значит прочие равные. Если ваш
оператор должен симметрично себя вести по отношению к левому и правому операторам, значит вне класса.
Если у вам принципиально, чтобы левым аргументом был именно объект вашего класса, то есть как бы они
неравноправны в вашем операторе. То есть вам нужно, чтобы левым оператором был именно настоящий
объект, как присваивание. Тогда вам надо, чтобы это был член класса. Я не знаю, что прочие равные.
Либо у вас такая ситуация, либо другая. Либо вам принципиально, чтобы одним из аргументов был вис,
либо нет. Ну как реализовать инкременты, давайте обсудим. Ну вот с инкрементами,
например, что делать? Инкрементов два. Бывают префиксные инкременты и постфиксные инкременты.
Давайте сначала обсудим, как реализовать префиксный инкремент. Что должен возвращать
префиксный инкремент? Я напоминаю, что префиксный инкремент, его результат это lvalue. И вы снова
можете присваивать ему. То есть вы возвращаете себя самого, а не копию себя. Значит вы возвращаете
срочку. Да. Оператор плюс-плюс. И у вас нет аргументов больше, потому что вы унарный оператор.
Что вы делаете? Вы просто добавляете к себе единицу и возвращаете же себя. То есть вы можете
по сути написать так. А можете написать еще короче. Потому что результат этого же и так
ссылка на себя. Вы можете прям так написать. Вот. Никакой копии при этом не создается. И вы
вызываете именно плюс-равно. А плюс-равно тоже эффективно работает. Если вам всю единичку
добавить, то вы за единицу это делаете в среднем. Что такое постфиксный инкремент? С постфиксным
инкрементом весело. Дело в том, что постфиксный инкремент у него также нет больше оперантов,
кроме как вы сами. И он тоже унарный. Но как же его отличать от префиксного тогда? Если я напишу
снова оператор плюс-плюс без рубля, это будет считаться префиксным инкрементом. Тут просто
создатель пошел на беспрецедентный шаг. То есть нужно было придумать какой-то костыль, как в
сигнатуре оператора отличать постфиксный инкремент от префиксного. То же самое с декрементом.
Ну, значит, создатель наш принял гениальное решение. Давайте постфиксным инкрементом добавить
эффективный аргумент int. Можно смеяться. Закадровый смех. А плакать. Да, вот если бы мы очень сейчас
сидели, то сейчас должен был быть закадровый смех в зале. Ну, короче, как объявить постфиксный
инкремент? Надо объявить инкремент с аргументом int. И это будет постфиксный инкремент тогда. Вот
постфиксный инкремент в отличие от префиксного копию возвращает. И что он делает? Ну, вы говорите,
big integer copy равно this, plus plus this, а вернуть копию. И теперь вы понимаете, почему постфиксный
инкремент работает за линию в отличие от префиксного. И теперь вы понимаете, почему постфиксный
инкремент менее предпочтительно, чем префиксный. В случае обычных int это без разницы, но в случае
длинных каких-то больших объектов, инкремент префиксный — это очень быстрая операция, а постфикс
инкремент — это линейное время, занимающее операцию. Потому что в постфиксном инкременте вам
обязательно нужно создать копию старого значения, прежде чем вы сможете увеличить,
ну вам надо старое значение увеличить, а вернуть то, что было. Поэтому вам приходится
создавать копию старого и ее возвращать, а старое вот this — инкрементировать.
То есть вот это int — это как бы абсолютный костыль. Это просто костыль, да, это просто тупой костыль,
просто способ максимально тупой, как отличить префиксный от постфиксного по сигнатуре — фиктивный
int. Давайте на сегодня все, потому что мне уже пора заканчивать. Ну и встретимся,
мы, видимо, в понедельник. Ну а до этого времени вы уже можете начинать, будете кодить стринг.
Вот нам в понедельник мы уже, я думаю, ну в понедельник у нас будет две пары,
получается, с вами опять и утренняя и вечерняя, и значит мы там продвигемся еще достаточно
существенно вперед. Ну все, на сегодня.
