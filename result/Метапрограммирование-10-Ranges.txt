значит начнем мы с твитера Зверовича, потому что очень интересная новость. в ситлес плюс 23
добавили принт, представляете? и суммарно теперь hello world на плюсах выглядит читаемо,
и человек, пришедший из другого языка, теперь не будет шокирован тем, что вообще происходит
с этими саутами, стрелками и хэштег инклюдами. ну и да, мы достигли уровня читаемости, который был
у сии 30 лет назад. ладно, не 30-60. но тем не менее, и этот принт, собственно, поддерживает такое же
форматирование, если суффикс f дописать как принт f сей, только типа безопасно и ближе к питону.
если вы про формат слышали, оно поддерживается. вот так что благие вести, товарищи. года через
два мы все так будем писать. а сегодня мы будем говорить про ranges. это такая новая классная
библиотека, можно сказать, которая теперь включена в стандартную. и стандартную библиотеку
ranges пытаются подружить, еще долго будут пытаться, но идти она все будет очень тяжело, потому что
legacy. а цель всего этого предприятия это писать на плюсах код примерно как на питоне, хаскеле,
скале или f шарпе. собственно, еще можно сравнить со стримапи в джаве или с теми же стримами на си шарпе.
ну, практика показала, что всякие простые задачи гораздо приятнее решать писа как там, а не вот как
у нас в плюсах принято повсюду кидать какие-то лютые итераторы, типа даже std sort, там два итератора,
их нужно сохранить, их нужно передать. если мы там делаем какую-нибудь remove if, то нам еще
один итератор вернут и с ним тоже что-то надо делать. очень сложно, для обобщенного кода подходит,
когда на практике нужно просто взять и решить простую задачу, ну просто отвратительно. и
ranges это проблемы решают, поэтому мы хотим их изучить, это а. а b это то, что ranges это очень
мощное с точки зрения метапрограммирования библиотека. собственно, почему оно в этот курс хорошо
вписывается? ну, мы уже много раз упоминали, мне кажется, ranges, да, и когда про неблоиды говорили
и прочие штуки. собственно, автор вот этой штуки, он написал Unifex, который я уже упоминал, и вся эта
движуха, она так попахивает postmodern c++, когда уже просто сдались и начали пытаться выжить
производительность вот просто всеми инструментами c++, не страшаясь сложного кода, каких-то шаблонов
диких, язык abused просто по максимуму. как-то так. ну, давайте для начала вспомним. так, давайте
я только чатик открою на втором экране. конечно, да, Ниблер не один писал. и Unifex, и ranges, это все,
конечно, комьюнити-эфорт, но он такой евангелист что ли. когда речь идет о этих библиотеках,
я почему-то только о нем думаю, а все остальные постольку поскольку. да, вспоминаем, когда мы
про концепты говорили еще в самом начале в стандартной библиотеке, мы вот такие вот штуки видели
movable, copyable, semi-regular, regular. про них мы не забываем, они повсюду используются, конечно,
во всех других концептах, которых в ренджах полно. movable, все, что похоже на Unique PTR. а,
вопрос, видите ли вы мой курсор? да. о, кайф. copyable, ну, что-то, что можно и мувать, и копировать,
но обычно вот только copyable классов особо не встречается. они обычно semi-regular все-таки,
это значит, что можно еще по дефолту конструировать. и самый приятный тип,
или это категория типов, это regular, который copyable, movable, можно сравнивать и можно
по дефолту конструировать. то есть ведут себя по сути как встроенные типы, и среди них такой
самый явный представитель это shared pointer. окей, ranges. ну, на самом деле не ranges, а для начала
итераторы. все строится очень постепенно из кучи этажей, такая лютая башня. и начнем с самого
фундамента. вот концепт wickly incrementable. да, итераторы теперь тоже все об концептчины,
мы про это чуть-чуть говорили. я, если честно, забыл сколько и насколько глубоко, поэтому повторим
на всякий случай. вот тут не требуется заметь и regular, но все равно требуется дефолтное
конструирование и movable. но то есть на unique ptr похоже. требуется некоторый тип difference tag,
который вычисляется, конечно же, по еще одной сложной схеме через итератор traits и прочие
штуки. хотя на самом деле это не совсем правда, но об этом попозже. да, и требуется чтобы этот
тип был каким-то знаковым числом, и это не только встроенные знаковые числа на самом деле. сейчас
про это скажу. или прямо сейчас. а, да, я забыл, как у меня устроены слайды. классно. так, ладно.
вот, подробнее про то, как это difference tag все-таки устроено внутри. таких helper-типов в библиотеке
много, поэтому хоть про один из них проговорим, как оно устроено. оно использует два разных трейта.
во-первых, итератор traits, во-вторых, incrementable traits, потому что это более слабое понятие,
нежели итератор. заметьте, тут нигде разыминований не требуется. соответственно,
вот все такие шаблоны, итер дифференс т, для incrementable traits это все, а вот для самих
итератор traits там есть еще value type, reference type, pointer type и прочие штуки. они все идут
очень хитрым путем. сначала пытаются в самом типе итератора найти type def или using,
нет, наоборот. сначала пытаются внутри самого трейта найти, если есть специализация, потом
внутри типа, и наконец просто взять и вычислить, прям выражение бахнуть, какое мы хотим в итоге
иметь, и посмотреть, какой тип получится. ну вот почему-то они решили добавлять знаковость,
а не требовать ее изначально. ну ничего. signed integral like это все встроенные типы,
знаковые, и внезапно расширение системы. вот такую штуку, возможно, на каком-нибудь
окосе видели. это расширение компиляторов на армах и интелах присутствует для 128-битной
целочисленной арифметики. и вот теоретически разность итераторов может быть м 128 и. тому
это нужно я честно не знаю, но решили для общности вот так сделать. вот и наконец так назад или не
назад. да, конечно, если он incrementable, то можно его incrementить в две стороны, но заметьте,
что префиксный increment требует, чтобы получилась ссылка на собственный итератор в результате,
а вот от постфиксного increment ничего не требует. я предполагаю, что вы помните,
чем префиксный и постфиксный increment отличаются. ну и конечно есть некоторые
семантические требования для моделирования, что они всегда префиксный и постфиксный одинаково
определены, то есть либо оба определены для конкретного значения итератора, либо оба не
определены. оба advance i, но что это значит, это, конечно, вопрос. скорее всего, в дебриах стандарт
есть определение. ну и что после префиксного increment нам возвращают не копию, а именно тот
же объект. то есть это прям зашито в требования строго. вот почему weakly incrementable, а не просто
incrementable? тут как раз подчеркнуто, выделено, то почему. именно потому, что мы не требуем,
чтобы постфиксный increment хоть что-то вообще возвращал, а также еще не требуется equality
preservation, я надеюсь вы помните, что это, сохранение равенства при использовании функции. кто может
предположить, зачем вообще такой концепт может быть нужен? почему для некоторых типов итераторов
у нас может не быть возможности постфиксный increment реализовать? типа того, а куда делось,
ладно, кажется я потерял слайд. ну ладно. да, input итераторы и прочие штуки, которые читают из
ниоткуда. примеров еще, наверное, можно придумать, но вот раз уж я не выписывал, я из головы со вчерашнего
дня уже не вспомню. ну ладно. ну раз есть weakly, значит есть и просто incrementable. и вот тут уже
требуется регулярность внезапно. то есть weakly incrementable даже не требует, чтобы можно было их
сравнивать. и для input итераторов это вполне естественно, потому что, ну как вы сравните input
итератор, который просто читает из какого-нибудь потока данные, их нельзя сравнить. как только вы
с него что-то прочитали, все, те старые данные пропали из потока, новые как бы вам прислали. ну и
копировать тоже немного странно, потому что скопировав вы, возможно, ожидаете, что они будут
одинаковые данные вам отдавать. это вполне естественное ожидание. но это, скорее всего, не так будет
для итератора, который читает из потока. имея две копии, вы, скорее всего, будете прочитав из одного,
просто читать из этого потока натурально. и как бы последовательность значений, задаваемых этими
итераторами, она будет разная в зависимости от того, в каком порядке вы из них читаете. но это,
конечно, странно, поэтому копируемость не требуется. вот и еще добавляется, собственно, вот эта
вот штука, что все-таки постфиксный работает, как мы привыкли, и возвращает старое значение. ну и
возвращается quality preservation. опять же, почему и quality preservation не требовался? ну, во-первых,
даже знака равенства нет. соответственно, какой quality preservation? но если слово equality
воспринимать, как мы в прошлый раз обсуждали, неотличимое, то это вполне будет нарушаться,
потому что имея два итератора на input stream, один из них увеличив, потом второй из них увеличив,
они как бы в разном состоянии технически будут. и вообще непонятно даже, что такое состояние,
это состояние потока или чего. так что, чтобы от таких вопросов не думать,
quality preservation выпилен для вывекли, здесь он впилен. вот, ну, я думаю, уже чувствуется,
насколько тут все глубоко и насколько много мелких деталей, кубиков, из которых все в итоге строится,
но это только начало. насчет моделирования wikli-incrementable. вот, насчет вопроса,
ну типа, что такое advance. обратим внимание на то, что у нас здесь требование на i посильнее,
здесь требуется не wikli-incrementable, а сразу incrementable. это хорошее замечание. в каком-то смысле
у нас и после того выражения, и после того, как бы и у нас куда-то сдвинут дальше. потому что по
дефолту это делает, видимо, только первое выражение, а с incrementable еще и второе. по-моему так.
сейчас я пытаюсь сообразить, почему они именно так сформулировали, но очень странная формулировка,
но поверим умным вядям, что они перебрали много контрпримеров и решили, что вот именно так лучше
всего. к сожалению, эти контрпримеры очень тяжело гуглиться. я на многие вопросы, которые у меня самого
собственно с прошлого раза, когда я работал в RNG остались, ответы такие нашел на всяких stack
workflow, но как бы вопросы неисчерпываемы здесь. сначала и до конца изучить, почему этот дизайн
вот такой, это сложно. на практике надо поиспользовать, возможно в итоге будет понятно.
то есть как бы библиотека молодая, мало использования, ну и мы в итоге увидим, почему даже несмотря на
добавление в C++20 использования RNG пока мало, но в будущем их будет больше, материалов будет больше,
я думаю мы как бы поймем всю мудрость древних постепенно, либо всю глупость и потом будем
менять стандарт. ну тут уж как пойдет. да, а семантические требования на incrementable вот такие,
ну то есть тут буквально говорят, что a++ постфиксный, он должен вернуть такую же штуку,
как и была a, да, то есть не такую же в смысле адреса, как было вот здесь для префиксного,
а такую же в смысле равенства. ну это тоже достаточно странное условие, как бы очевидно,
что для всех хороших итераторов оно выполняется, потому что что мы здесь делали, мы увеличили
a, а потом все эти скобочки, благодаря оператору запятая, превращаются в просто a, но вот с другой
стороны мы сделали plus plus b, то есть как бы имеется в виду, что то, что вернулось до постфиксного
increment, оно равно b, а то, что после получилось, оно равно следующему за b. вот, но очень хитрые
детали, непонятно почему именно так и думаю никогда не поймем. ну ладно. вот, наконец-то самое
главное, что здесь вообще есть, это input or output итератор. заметьте, он именно weakly incrementable,
и его можно разыменовать. и тут опять используются вот эти наши любимые костыли, когда в стандарте
пишут не концепт новый, а просто пишут комментарий exposition only, и такой концепт есть, но как бы его
нету, то есть концепт, который не обязательно предоставлять стандартной библиотеке пользователю,
но в побочных концептах он встречается, поэтому он как бы вот есть. и да, теперь вот этот концепт
input or output итератора, вот он называется итератором. все, что его удовлетворяет итератор, все, что не
удовлетворяет не итератор. и собственно, как эта штука реализована, ну вот как-то так,
можно навесить имперсант. заметьте, что просто t-амперсант вписать вот сюда в концепт,
то есть написать type name t-амперсант нельзя, потому что так парсер работает, из-за этого вот такой вот
костыль. назовите хотя бы один тип, для которого вот это вот не скомпилируется.
void? void, а еще я придумать не смог. там возможно функции? нет, по-моему нет, потому что понятие
ссылка на функцию в стандарте есть. там ссылка. да, именно не указатель на функцию, а ссылка на
функцию. и добавление ссылок к ссылкам не приводит к никакому новому результату. возможно. нет,
с массивами это работает. ну вот непонятно, зачем так сделано, но будем считать, что это просто от
void предостережения. и тут дальше сразу появляется такое семейство концептов, которые из префиксы
indirectly начинаются. вот тут я два привел, которые нам понадобятся сразу дальше, но на самом деле их
там миллион. и все эти концепты обобщают указатели в каком-то смысле. вот примерно в том же смысле,
как итераторы обобщают указатели. ну итератор у какого-нибудь вектора, он умеет массу всего.
и существенно то, что он имеет, когда мы, например, имеем дело с итератором на вектор
булов. мы помним, что он возвращает в раппер. и в коде обобщенным хотелось бы уметь делать
std swap от разыменования двух итераторов на вектор була. и прочие хитрые вещи. читать результат,
писать результат. и очень многие вещи, которые мы после разыменования итераторов делаем,
они могут работать нетривиально, потому что разыменование может возвращать в раппер.
поэтому напихали вот таких indirectly концептов. indirectly readable говорит о том, что для какого-то
t, вот этот итератор и, его тип похож на t звездочка тем, что из него можно читать. то есть вы можете
присвоить переменные и результат разыменования, грубо говоря. а writable наоборот, что вот тут уже
для какого-то конкретного t, который нужно указать в шаблоне, и похож на т звездочка тем, что у него
можно писать. то есть написать звездочка итератор равно и какое-то значение типа t.
почему я не привел код? потому что он какой-то настолько дикий, что даже я сдался. вот если
интересно, почитайте сами. да, и это дебри. но, к сожалению, в обобщенном коде без этого никак.
да, и раз есть input or output, то должны быть input и output итераторы. и input итератор
это input or output итератор, который indirectly readable, у которого есть вот такая странная штука,
о которой собственно сейчас поговорим прямо сразу. что это за итер концепт? но это опять
exposition only. и он идет по вот такой сложной цепочке определения, откуда взять этот тип.
во-первых, из трейтов категория, нет, итератор концепт пытается достать, потом итератор категория,
ну и в процессе, как и для любых других вещей, доставаемых из итератор trades, идет сам класс.
и если все не получилось, то он говорит random access iterator, random access iterator tag.
соответственно, про итератор теги, возможно, вы уже слышали, если нет, сейчас услышите,
это такие пометочки, кто каким итератором является. и почему так сложно, почему есть концепт, есть
категория, я не нашел здравого объяснения, но, насколько я понял, это такой хитрый костыль для
миграции legacy, потому что то, как работают вот эти теги, оно чуть-чуть поменялось в c++20,
и поэтому нужна возможность зауверрайдить старые итератор трейтсы. ну, например,
вы используете библиотеку, написанную на c++17, там куча итераторов, просто масса,
авторы библиотеки долго и упорно будут переписывать на c++20, но как бы это время,
а вам нужно использовать уже сейчас. и вот чтобы у вас не возникло лютых проблем с использованием
стандартных алгоритмов, вы можете сами как-то перекостылять итератор концепт, не трогая итератора
категории, и оно как бы возьмет приоритет над старым итератор тегом, который использовался,
вот, и соответственно, тут требуется, чтобы этот итератор тег можно было достать, да, то есть,
вообще говоря, это итератор теги, но в новом стандарте решили их называть итератор концепты,
чтобы отличить от старой системы тегов, потому что они чуть-чуть отличаются вот совсем на писечку,
и да, это очень смущает, потому что вот у нас вот это концепт для итератора, это итератор концепт,
просто медаль за нейминг, и соответственно требуют, чтобы этот тег, который мы получили каким-то
образом, наследовался от итератор тега. Так, соответственно, итератор теги, как они устроены?
Их много, и они делают иерархию, соответственно, разбираясь с пользуем, в этой иерархии должно
быть наследование, а input-output ничего не наследует, то есть, для простого итератора нет никакого тега,
input-output, но мы сейчас увидим почему. forward-iterator-tag наследует только input-iterator-tag внезапно,
а bidirectional-iterator-tag, forward, random access bidirectional, ну, в общем, стандартная.
мы должны были уже все это видеть, если писали что-нибудь на estay или более-менее крупное,
а новое здесь contiguous-iterator-tag. Теперь можно помечать, что итератор указывает на память,
лежащую подряд, ну, то есть, из стд-вектора, стд-рэй и прочие вещи. Это нужно, чтобы отличать,
например, дек от вектора, потому что дек, формально говоря, тоже random access, но не за от единицы,
ну, или просто может быть какая-нибудь хитрая структура данных, которая у вас как бы random access,
какой пример, декортово дерево по неявному ключу, вот, но в памяти элементы лежат непоследовательно,
и для некоторых алгоритмов важно это знать, соответственно, новый тег. Вот, и теперь посмотрим
на output. Output это input or output, indirectly writable, все ожидаемо, ну, и какое-то условие на то,
что можно действительно записать со знаком равенства, а притратор теги ничего, то есть,
здесь мы требовали, чтобы через itr-концепт можно было достать тег, и он наследовал input
iterator тег в input iterator, а в output iterator ничего не требуем. Внезапно, да, и обоснование тому,
почему оно так работает, да, оно хитрое, тут все упирается в то, как работают алгоритмы, в то,
как мы их хотим писать. В ходе выполнения алгоритма какого-то мы часто хотим попробовать
запгрейдить итератор, то есть, например, sort, мы можем сортировать любые контейнеры,
предоставляющие bidirectional-утератор на самом деле, да, не zyne-login, но можем. Вопрос,
почему библиотеки бы не предоставлять такую возможность? Тогда нам нужна кастомизация этого
алгоритма, которое смотрит, ну да, сам алгоритм как бы принимает по bidirectional концепту,
да, для них, конечно, тоже есть концепт, и нам внутри алгоритма нужно посмотреть,
является ли этот итератор на самом деле random access или даже contiguous. Если является,
то более эффективную реализацию zyne-login запустить, если нет, то как бы за квадрат. И все это в
compile-time, конечно. И вот вся эта система тегов, она с единственной целью задумана вот с этой,
в алгоритме, понимать, насколько силен итератор. И по дефолту мы считаем, что итератор у нас
random access tag. Это подвязывается с тем, что вот тот хитрый концепт по дефолту возвращает random
access. А дальше теги делятся как бы на несколько типов. Вот input forward и bidirectional теги,
это такая отписка от функционала. То есть мы явно говорим компилятору, что этот итератор не
настолько крутой, как ты по дефолту думал. Он не умеет random access, он там только bidirectional,
или вообще только input. И зачем нужны, собственно, эти теги? Затем, что по синтаксису, то есть как-то
концептами это прописать и задетекстить невозможно. Мы не можем понять, умеет ли итератор в random
access чисто вот какими-то синтаксическими выражениями. Не можем понять, имеет ли он bidirectional.
Ну то есть попытаться-то можно, но выйдет плохо. Поэтому сделана такая система, где вы явно
указываете, что нет, этот итератор в random access не умеет. Contiguous итератор — это наоборот
подписка на дополнительный функционал. И вот ее мы вообще совершенно точно никак по синтаксису не
можем понять. Невозможно отличить чисто синтаксически contiguous от random access итератора.
Зато семантика отличается. Можно как-то ускорять, можно как-то optimize, какие-нибудь
хитрости использовать. Поэтому есть тег, который вы можете явно в своем итераторе указать,
и возможно получать более эффективную имплементацию алгоритмов от компилятора.
Например, есть output итератор tag, и он не нужен по двум причинам. Первая причина — что output
итератора можно детектить по синтаксису весьма успешно. Вот этой конструкции, которая здесь requires,
что увеличенный там разыминованный указатель, в него можно записать t. И на практике, как оказалось,
не бывает таких алгоритмов, которые хотят взять output итератор, а потом посмотреть,
он является ли он более сильным. Это вообще очень редкая ситуация, чтобы у вас output итератор
являлся random access или еще чем-то другим. Фактически нонсенс. Я даже не могу придумать примера,
когда output итератор является чем-то кроме output итератора. Вся его идея — это в том,
что в него можно только записать и увеличить. Все, больше ничего. Это чем-то даже поток напоминает,
больше, чем итератор. Поэтому нужды всей этой системе для него нет, для консистентности тег,
конечно, добавили, но по факту он не используется. Так что вот так. Возможно,
скоро задеприкейтит и отпилит этот тег, но посмотрим. Дальше новый кусочек. Давайте поймем,
все ли понятно на данный момент. Или нам нужно что-то обсудить.
Прошу прощения. Думаю, в микрофон очень сильно отдаются звуки телефона.
Видимо, вопросов нет. Андрей скинул что-то. О, интересно. Тут показано на трейдах,
но я в качестве эксперимента написал трейд со слайда addRFT, поставил туда
квалифайд функцию, и да, оно не собралось. Я просто набрал там c++ examples of non-referenceable
types и вторая ссылка это вот это. Но я это предположил, что это они, когда решил трейд почитать,
соответствующий addRValueReference, addRValueReference. Там вот как раз указаны вот такие веселые типы,
что кажется для них это нормально не работает. Ну да, это закономерно. Я просто пытался по своему
концепту гуглить где-то объяснение, мотивировки его всего, а не по кусочкам. Наверное, в этом моя
ошибка, поэтому я ничего не нашел. Но да, весьма закономерно, что такие штуки не могут быть еще и
со ссылкой. Ну вообще, тут встает огромный вопрос, а что это вообще такое за тип и зачем он нужен?
Но об этом мы в следующий раз с вами поговорим. Ну да, забавно. Ну вот опять же, как бы сложности в
стандарт это привнесло, вот это хитрое требование. А на деле защитило нас от чего? От того, чтобы мы
такие типы не возвращали из функций. Извините, а где мы вообще их возьмем, инстанция таких типов?
Это вообще как? Ну то есть какая-то война с мельницами, если честно, в некоторых местах, в ranges,
но в целом достаточно бодро. Так, вернемся и продолжим к следующей штуке новой. Помимо итераторов
у нас теперь есть сентинелы. Они похожи на итераторы, но они не то же самое, что итераторы. И сентинелы
у нас определяются для конкретных типов итераторов. То есть концепт этот от двух штук,
S это сам сентинел, а E это соответствующий ему итератор. Все сентинелы обязаны быть сами
регулярными, обязаны как бы быть, да, наоборот, соответствующий им итератор обязан быть input
or output итератором. То есть максимально слабое требование, что еще может быть. И вот такой хитрый
концепт Weakly, Quality Comparable With, который просто значит, что эти два товарища можно сравнивать,
и equality preservation не требуется. Да, черт, я зря нажил стрелочку. Я хотел у вас спросить, как вы
думаете, зачем это нужно? Что-то, что не является итератором, очень близко к ним и можно сравнивать
с итераторами. Ну вот да, это как бы обобщение идеи, а когда надо остановиться. Да, это обобщение идеи
того, что End возвращает итератор. Теперь End у нас возвращает не итератор, в общем случае. Begin
все еще итератор, End сентинел. И нужно это вот зачем, собственно. Представьте input stream. Мы
хотим его представить как range. Ну мы пока еще не говорили, что такое range, но просто логично,
даже вот просто сев подумав, логично предположить, что это пара итератор на начало, итератор на конец.
Но в таком случае, как мы последовательность чисел, введенных с input stream, пока получается,
обозначим за range. У нас же не может быть итератора на конец input stream. Ну точнее может быть,
именно в случае input stream, но тут стоит упомянуть еще другую штуку. Вот те из вас, кто решал вторую
домашку, возможно, прочувствовали, как прикольно уметь работать с бесконечными последовательностями.
И range, они таки поддерживают бесконечные последовательности. И в том числе для этого
конец range может быть вообще какого-то другого типа, не итератора. Есть просто тип, который в
стандарте обозначает как бы недостижимый сентинел. И ровно этот тип используется для бесконечных
ранжей. Например, может быть range на все натуральные числа. Вот, то есть теперь range это не пара двух
итераторов, а пара все-таки итератора и сентинела, будем считать. Но об всем этом будет еще подробнее
дальше. А пока просто запомнили, что сентинела есть, на них требования весьма естественные,
можно сравнивать с итераторами. Дальше нам нужно ввести странное определение. Оно в стандарте
называется range, но это не тот же range, про который говорят, когда называют само это библиотеку ranges.
Это некоторый более математический термин в стандарте, используемый как вспомогательный.
Давайте его, по примеру, прошлого года называть диапазоном, а вот настоящий range уже range.
И диапазон это пара из итератора и сентинела, для которых, если они не равны, то обязательно
итератор валидный, то есть его можно разменовать. И увеличив этот итератор, мы вновь получим range,
то есть диапазон, прошу прощения. То есть такое рекурсивное определение. Тоже вполне естественно
уже начинает попахивать математической логикой и прочими штуками, или даже какой-то алгеброй,
но вот так. И дальше есть уточнение этого понятия, валидный диапазон, ну просто конечный. То есть
делая оператор плюс плюс, мы за конечное количество шагов дойдем до конца. Да, я тут не посмотрел,
но кажется, что вот этот и в начале, ну да, это input-output, ослабить это нельзя, input-output-
итератор. Вот, как-то так. И все, мы готовы более полезные итераторы определять. Forward
итератор. Ну для каких структур данных forward итератор используется, кто напомнит?
Односвязный список. Да, односвязный список. Ну и многие его расширения. Могут быть какие-нибудь
конечные автоматы, по которым вы можете по ссылкам ходить вперед, а назад не можете. Да,
если кто-нибудь суф-автомат писал, думаю, представляет примерно о чем я. Ну или там суфиксное
дерево даже. Там тоже есть эти ссылки forward. Вот, соответственно, конечно forward итератор это
тоже input итератор. Читать мы из него можем. Тег мы требуем. Уже обсудили, что необходимо уметь
детектить, возможно ли расширить input до forward в алгоритмах. И тут наконец-то появляется
incrementable, про который мы в самом начале сказали. То есть, что input, что input-output,
они все были weakly incrementable. Да, теперь уже нормально incrementable. И более того,
мы сразу требуем, чтобы он был с Sentinel-ом сам для себя. Ну а почему с Sentinel-ом сам для
себя этого точно сказать нельзя, так не задумавшись, не приходит в голову причин, почему нельзя было
расширить понятие Sentinel и на forward итератора. Но вот это как бы намекает на то, что они живут
только как бы в мире input и output итератора. Да, но на самом деле Sentinel-4 вот в данном случае,
если внимательно посмотреть на определение, фактически схлопывается в regular i из-за того,
что мы двои указали. И то, что здесь именно Sentinel-4 указали, а не regular,
это скорее про семантические требования, а не про то, что в концепте на самом деле написано.
Ну и да, имея хоть какой-то простецкий... ладно, не имея. Порядок слайдов немножко не лучший.
Определим range наконец-то. Range это пара. Ну, вернее нет, но да, но сам концепт выглядит как
требование, чтобы ranges begin и ranges end компилировались для l-value ссылок на этот тип.
Более того, equality preservation здесь требуется только для итераторов хотя бы настолько
сильных, насколько forward итератор. То есть input и output итераторы не обязаны equality
preservation делать. И вот то, в каком смысле range это пара итераторов, это мы увидим дальше.
Бла-бла-бла-бла-бла. Range begin, range end, первый bullet point, это диапазон, то есть вот то
математическое определение, которое мы раньше давали. А также второй bullet point. Begin-end
амортизировано за от единицы вычисляются, что нам позволяет грубо говоря говорить о том,
что сам тип удовлетворяющий концепту range внутри себя как бы хранит эти begin-end итераторы,
но нам их не дает, пока мы не попросим. Вот в таком смысле оно как бы является парой итераторов
на начало и конец. Но заметьте, что end возвращает все-таки sentinel, потому что мы в определении
диапазона говорили про sentinel. Амортизация это тут на самом деле очень важный момент,
без него бы ничего не работало, на удивление, и чуть попозже мы про это увидим. Да, и собственно
вот требования на equality preservation, про которые я уже сказал. Причем оно только на begin,
что если честно немного странно. Ну да ладно. Да, заметьте, begin-end должны не модифицировать тип,
ну объект, у которого мы вызываем. Почему здесь именно не модифицировать сказали, а не то,
что они const, потому что, как мы знаем, стандартные библиотеки begin-end бывают
константные и неконстантные, бывают константные и неконстантные итераторы. И тут имеется в виду,
что они именно с точки зрения внешнего мира наш контейнер никак не поменяли. А что означает,
что какой-то cache mutable внутри контейнера, они вполне себе могут обновлять до тех пор,
пока этот cache никак не виден изнутри. А как-то так. И собственно, когда... не так. Что вообще значит
ranges begin? Ну это не bloid опять, на самом-то деле. Точка кастомизации не bloid, как угодно можно
называть. И в каком порядке оно пытается найти дефолтные какие-то реализации? Во-первых,
вот такое выражение. Это для каких типов нужно? Кто-нибудь? Массивы? Да, сишные массивы именно,
то есть не стдр, а просто какая-нибудь у квадратные скобочки. Okay, forward. Ну это на самом деле,
мне кажется, надо было бы выпилить со слайдов, чтобы не так подробно было. Ну в общем,
member begin. То есть на экземпляре t можно вызвать begin, и он вернет input-output и тератор. Тогда
его и будут использовать. И ADL, свободная функция begin глобального namespace. Ну собственно,
не bloid, про них мы уже говорили достаточно. И тоже input-output обязаны вернуть.
Okay, end тоже самое, но вместо прибавления нуля, чтобы как бы... Да, насчет этого прибавления нуля
вот никто не переспросил, почему так надо, а не просто t использовать. А надо так вот почему. У
квадратные скобки это как бы не тератор. Вот у звездочка это и тератор. И когда мы к у квадратной
скобке прибавим 0 или int, мы как раз получим у звездочка, то есть указательное начало массива.
Очень тонкая разница, но вот в legacy приходится с ним мириться. Вот, а в случае end нам нужно
прибавить размер t, и вот это вот такая сложная штука, которая умеет в compile-time
определять размеры C-шных массивов, если они фиксированного размера. Вы, наверное,
знаете, что в аргументы функции можно принимать у и в квадратных скобках указывать размер. А вы
знаете, что это делает на самом деле? Какой на самом деле будет как бы тип у этой переменной
с точки зрения всего кода? Если вы вот здесь в аргументе, вместо t напишите u в
квадратных скобках в скобках 32 или 42. Дикей t, нет? У массива известного размера это разве дикей?
Да, массивы и без размера и с указанным размером, когда находятся в аргументах, они в итоге дикеются
в указателях и ведут себя абсолютно так же, как указатели. Ну а тут ссылка, да, поэтому...
Ну это... И поэтому это все читает и фиксит. Это вроде да, это фиксит. А так да, согласен,
если по значению указывать, то действительно все дикеются. Да, но даже если бы оно было не по
ссылке, несмотря на то, что сама t, когда мы ее будем использовать, будет выглядеть как
указатель. Если бы мы вот в качестве типа указали явно массив с фиксированным размером с помощью
хитрой шаблонной магии, которую вы все должны уметь писать уже, мы можем таки вычислить размер
этого массива, то есть узнать, что в квадратных скобках было написано. А так как тут по ссылке
принимается, у нас после вывода типов все еще останется число в квадратных скобках. И вот
собственно с помощью этого шаблончика мы узнаем, какой размер там был указан. Вот,
и вторая разница это что требуется, чтобы возвращал Sentinel for итератор. Да, итератор t соответственно
вам возвращает то, что вернул Бобедин. Ну наверное чуть более хитрее, но в целом так. Ну и да,
это тоже не Bloit, тоже ADL, тоже можно кастомизировать через всяких friend'ов или глобальные функции. Вот,
но в придачу к ренджам идет такое понятие как Vue и очень долгое время шли споры о том,
что такое Rends, что такое Vue. В итоге еще третью сущность придумали и четвертую, про которую
у нас под конец будет. Но мотивировка станет скоро понятна. Vue это тоже Rends, movable. Давайте вернемся
на слайд с ренджем и вспомним, что там никаких вообще требований на копируемость, movability нету.
То есть какой-нибудь контейнер, который содержит в себе стдр и мютекс, это вполне нормальный рендж.
То есть они могут быть даже в памяти запиненными. А в Vue уже movable, default initializable и вот есть
такой некий шаблон enable Vue. Ну можно догадаться, что это механизм наподобие итераторов, который
просит явно подписываться, наподобие итератор тегов, который просит явно подписываться на то,
что да, я являюсь Vue. Пожалуйста, считай меня Vue. Иначе у нас Vue станет очень-очень много чего и кажется,
мы этого не хотим. Вот, из семантических требований. Все зовут единица. И, соответственно,
да, просто все зовут единица. Да, все эти сложные слова просто говорят, если определено,
то зовут единица. Да, и собственно про enable Vue. Есть такая штука Vue Base и enable Vue требует,
чтобы мы либо отнаследовались от нее, либо отнаследовались от хитрых штуки,
называемые Vue интерфейсом. Но нам с нашей высокой башней должно быть уже легко и просто понять,
что это. Это CRTP родитель для удобства. Мы для итераторов такое вроде смотрели,
а теперь есть такое для Vue. Он требует определить begin-end и предоставляет кучу всяких полезных штук,
но, конечно, в зависимости от того, удовлетворены ли соответствующие концепты для итератора,
который вернул begin-end. Ну, предположите, какой концепт требуется выполнять,
чтобы empty и делающий то же самое оператор был был определен.
Ни у кого нет предположений. Еще раз, какой концепт нужно? Да, вот Vue interface этот CRTP
родитель для Vue. В нем написаны вот эти методы, которые выражены через begin-end.
А, ну тогда кажется, нам просто ренджа хватает? Нет. RendsH только предоставляет вам begin-end.
Ну а если, естественно, begin-end и итератор, а end-end это sentinel для него, тогда...
Да, и требования нам нужно именно на эти типы наложить.
А концепт RendsH это не требует? Да, концепт RendsH, давай еще раз посмотрим на него,
чтобы точно понять. Концепт RendsH это вас требует только двух вещей,
чтобы begin-end компилировались. А begin-end компилируется в случае,
если они не удовлетворяют требованиям на итератора sentinel?
Сейчас, где это у нас было, input-output-iterator и sentinel-for, да? Вот.
Позволяет ли нам понять empty или не empty вот эти две штуки?
Да, позволяет. Давай продолжим бегать по презентации, чтобы мы явно поняли.
Хорошо. Вот.
Winkly-incrementable. Winkly-incrementable оператор равно не предоставляет.
Как мы сравним begin-end? Хорошо, пойдем посмотрим на sentinel.
Ну, sentinel, sentinel, да. Типа, какой же он тогда sentinel для него,
если он не сравнивается с ним? Так, а где же, где же, где же?
Ладно, да, sentinel действительно определяет, да, что его может сравнивать с итератором.
Что-то я не вижу пока ограничений. Ладно, я сейчас сам тогда гляну.
Давай глянем вместе. Хорошо.
New interface. Я решил не выписывать, потому что их там много, но на всякий случай давайте
посмотрим, потому что мне казалось, что я запомнил. Да, внезапно требуется forward range.
Наверное, потому что иначе дёргать empty как-то страшно.
Ну да, это в каком-то смысле не имеет смысла, да, потому что у нас бывают бесконечные ренджи
и проверять, что nemt или nemt, это с одной стороны странно, с другой стороны, а чего бы нет.
В Haskell так делают и никто не страдает. Так, бесконечность или дело? Да.
Сейчас, ещё раз, ты хочешь сказать, что forward range требует валид range для моделинга?
Вообще не должен, конечно. Что-то вот как-то.
У forward range не обязан быть итератором. Для этого есть отдельный концепт.
Давай посмотрим.
Но при этом никто не говорит, что sentinel у forward range может быть какой угодно,
если он является sentinel для этого итератора.
Ещё раз, тут говорилось forward range, а не forward iterator.
Forward range. Что такое forward range?
Получается range, у которого итератор литовыряет forward iterator.
Ого, такой концепт есть. Прикольно.
Ну, там вообще у нас все виды концепта есть.
Ну, вообще да, их там настолько много, что все их вообще никак не как-то подпихнуть.
Ну да, окей.
Но тем не менее, кто ж гарантирует, что...
Вернее, наоборот.
Ну, forward range требует, чтобы forward iterator.
Forward iterator требует, чтобы sentinel...
Чтобы он сам себе был sentinel, да.
А, хотя это не требует, чтобы end возвращал i.
Да, именно. Я об этом.
Блин, патологический случай какой-то. Это точно так задумано?
Ну, по-моему, нормальный случай.
Например, раньше возвращающие все натуральные числа,
а он вообще отсветлене random access, но он еще и бесконечный.
Да.
Так что тут на самом деле можно так хорошо подумать.
Зачем мы тогда требуем, чтобы он был sentinel самому себе?
Для сравнивания...
Мы требуем, видимо, чтобы у нас поддиапазоны были нормальные какие-то.
Чтобы они вообще были и были какие-то адекватные.
Поддиапазон должен быть range.
Кстати, хорошая идея.
Потому что на input range поддиапазон нельзя строить.
Это вообще бред полный.
А вот на forward вообще на кофе.
Это очень хорошая мысль.
Вероятно, именно в этом дело еще бы они в стандарте писали эти мотивировки.
Ну, вот это хорошая мысль, чтобы они это писали.
Да, но кажется, они боятся вносить ненормативные заметки.
Ну, вот я их за это немножко хейчу, если честно.
Пусть тогда сделают приложение к стандарту и туда впишут вообще сколько могут.
Это хорошая мысль, только приложение к стандарту уже четыре.
Пятая.
Отлично.
Ну, во всяком случае есть на самом деле...
Хотя ладно, нет.
Всю эту мотивировку, скорее всего, можно найти только в mailing-листах и на GitHub.
Нет.
Так что, да, беда.
Окей, а с чего мы начали?
Начали мы с обсуждения того...
Да, почему не имеет смысл empty для не forward?
Ну, непонятно, если честно.
Ну да, что-то как-то...
И мне показалось, что это очевидно.
Но если задуматься, это действительно вообще непонятно, почему мы не можем проверить...
Хотя, что значит input?
Вот range, который из input-атератора читает, что для него значит быть пустым?
Мы не можем проверить, пустой ли он, пока его не увеличим.
Правда ведь?
То есть, несмотря на то, что мы сравним...
Вот, кажется, в чем дело.
Оператор равенства для Sentinel-ов не обязан вообще говорить true когда-либо.
Даже если...
Вернее, так.
Кстати, вот ты, кажется, верно, мы сейчас сказали, что, возможно, если у нас range не является forward range,
как, например, там представление стрима, то...
Ну да, действительно, попытки проинкрементировать мы ничего особо сказать не можем, поэтому...
Да, пока мы не заинкрементироваем...
То есть, это проверка, она не может нам сказать ничего полезного, в общем-то.
Да, если она говорит false, то это ничего не означает.
Да, он может быть true, да.
Поэтому, видимо, такое требование.
Вот, ну ладно, давайте уже дальше чуть побыстрее побежим, чтобы не умереть.
Data, contiguous.
Да, мы ожидаем увидеть точка data, которая возвращает указатель на начало последовательной памяти у...
Ну, контейнеров с последовательной памятью, да.
Vector, array и прочие штуки, похожие на них.
Size требует, скорее всего, forward.
Но это не точно.
Вернемся сюда.
Да, он действительно требует forward.
Потому что в forward мы таки можем взять, поинкрементить.
Ну, для начала скопировать, потом поинкрементить, дойти...
Ну вот, там еще одно требование.
Где?
Принять, пожалуйста.
Да.
Это очень важно, иначе size не константная, а это, ну, какая-то плохая вьюха.
Да, тут есть еще вот такой механизм, но...
Мы и так очень глубоко сейчас углубимся, если мы вот еще сюда полезем, то это будет больно.
Но тут что тут предлагают?
Тут предлагают почитать, и есть возможность явно запретить это дело.
Хм...
Ну, окей.
То есть, кажется, даже для forward-детераторов мы все равно должны уметь за вот единицы все это делать, да.
То есть, наличие вот этого точка size в вьюхе, оно как бы подразумевает, что это такой size, который вот за вот единицы взяли и получили.
А не сложный алгоритм, который посчитает, пошагает и что-то поделает.
Ну, окей.
Да, front и back это, скорее всего, random access.
Нет, bidirectional.
Потому что нам для back-а нужно шагнуть назад от sentinel.
Ну вот да, а для front-а кажется не важно.
Да, именно так.
Да, для front-а действительно не важно forward.
Ну и квадратные скобки random access.
Окей.
А, там вот про back как раз в требовании на back упоминается вот common range, как раз без которого, в принципе, на самом деле почти ничего нельзя сделать.
Какой ужас.
А, про то, что они совпадают, да?
Да, я об этом.
Окей, окей.
Ну, я в других местах это не особо видел, так что про заявление, что почти ничего нельзя сделать, кажется оно сейчас опровергнется в походу дела лекции.
Так, когда мы будем делать перерыв?
Да, сейчас закончим про view here и, наверное, будет перерыв.
Так вот, вопрос. Из всего вышесказанного, как вы считаете, где здесь view, а где здесь не view?
Было бы круто, если бы кто-нибудь, кроме Андрея, ответил, потому что он точно знает.
Никто не хочет отвечать. Так, почему у меня А? Вот так вот. Окей.
Я могу тыкнуть пальцем в небо.
Тыкай.
Вот. Span, string view.
Именно так. И именно на них построена вся идея view. Все view и чем-то похожи на них.
Это не владеющие ссылки на range, по сути.
Так же, как у вас есть unique pointer и есть просто указатель.
Unique pointer владеет памятью, а указатель не владеет, он только указывает.
Так же и в ranges. Range владеет памятью, а view только указывает на память некоторого диапазона.
И так как, когда речь идет о парах итераторов, гораздо сложнее вообще определить, что значит владеть, а что значит не владеть,
приходится вот такие танцы с бубном и сложную архитектуру строить.
Ну, по-другому никак.
Да, если про Span кто не знает, это самая простая view.
Вот это уже точно пара, указатель на начало и размер.
Очень удобно, чтобы описывать под массивы.
То есть, или даже больше, принимать какой-то список или массив в какую-либо функцию.
Вот если вы в своем коде, когда вам нужно там список имен каких-нибудь получить, например,
используете vector std string, то вы крайне неправы.
Потому что надо вам использовать span из string view или char звездочка в зависимости от ситуации и того, что вы дальше собрались делать.
В идеале, конечно, span от string view.
span может иметь статический размер, что примечательно, то есть как std array указанный в compile time, а может динамический.
Там, соответственно, две специализации.
И в чем профит, собственно, именно принимать span от string view, ну или вообще в чем сам span?
В том, что вы тогда туда можете засунуть и vector, и array, и вообще любой другой контейнер, который последовательно хранит данные,
который вам, возможно, прислала какая-то сишная библиотека, и не придется лишние выделения делать памяти.
Зачем нам лишний раз выделять память, если она уже есть?
Передача каких-нибудь векторов по ссылке, именно это подразумевает, что если у вас какой-то другой контейнер, извините, вам придется выделять лишнюю память.
Так что эту штуку рекомендую.
Используйте.
Сейчас, насчет спана, насчет сравнения, ну там vector string против span string view, но, по-моему, они ж так просто, один на другой так просто не заменяется.
Да, один на другой просто не заменяется.
Но тут, да, более все сложно.
Я объединил две мысли в одну.
Да, и стало грустно.
Мысли отдельные.
Вектор по ссылке не передавайте, используйте span.
И другая мысль.
Стринги по ссылке не передавайте, используйте string view.
Его просто копировать нужно.
Это очень маленький тип.
span вообще 4 байта может быть.
Ну, в худшем случае 16.
string view примерно так же.
Вот, и да, почему забиндить vector string off на span string view не получится?
Ну, вот так работают плюсы, к сожалению.
То есть, вероятно, если у вас как бы подразумевается, что вы передаете именно стринги внутрь,
то вам нужен span string off, скорее всего.
Ну, вот мне при работе с Vulkan часто были нужны spans на char const звездочка const.
То есть, spans из константных указателей на константные чары.
Вот так вот.
Это сишная API Vulkan, поэтому там приходится как бы с такими вещами сталкиваться.
И когда хочешь все это как-то более-менее обернуть в плюсовый код, span очень помогает.
Как-то так.
Дальше у нас, собственно, как работать с этими концептами.
Откуда вообще экземпляры, даже не так, откуда хотя бы типы удовлетворяющие им получить какие-нибудь интересные.
Отчего можно добиться всем этим?
Но перед этим мы делаем перерыв до 18.25.
Прежде чем мы уйдем на перерыв, вот ты упомянул уже что-то там про common range.
Я сказал, что без common range там особо ничего сделать не получится, в случае с back'ом.
Там прикол с тем, что оказывается в определении bidirectional range вообще никак не констраинится с sentinel.
То есть там опять же констраинится только итератор, что он должен быть bidirectional.
Поэтому чтобы из-за константа делать back, нам нужно чтобы у нас sentinel был этим же итератором.
Иначе, кажется, мы ничего не можем сделать.
Закономерно.
Какой-то интересный прикол, что нереально sentinel не констраинит, и надо каждый раз самому разбираться.
Нет, не нужно каждый раз самому разбираться.
У тебя почти во всех вещах, которые мы дальше будем обсуждать, там нет нужды с back'ом ничего делать, то есть send'ом.
Там это тоже хватает.
То есть не нужно зазря больше требований, чем по факту нужно требовать.
Да, это верно.
Единственное, что я могу упомянуть тут, это reverse.
Да, если вы хотите зареверсить range, то, конечно, вам придется как бы менять местами, грубо говоря, begin и end.
И это потребует все-таки вот этого common.
И bidirectional, соответственно.
И bidirectional, да.
Все остальное вполне без этого живет, все эти концепции.
Но там не упоминается просто этот шаблон, так что я даже так краем глазом его видел и особо не смотрел, что там.
Ну ладно, разобрались. Теперь точно вернемся.
Перерыв.
Впереди самая сладкая, если мы более-менее поняли и переварили весь этот зоопарк концептов.
Да, концепты для random access, bidirectional и прочих мы не смотрели, но они достаточно ожидаемы.
То есть если мы все-таки посмотрим, несмотря на то, что их не вставил.
Выглядят они ровно так, как вы бы и ожидали.
Всякие увеличения, сравнения и прочие штуки.
Можете почитать сами более внимательно, но если мы туда закопаемся, то мы вообще ничего не успеем.
Поэтому идем дальше.
Factory для ренджей.
Это такой набор функций, классов и прочих штук, которые призваны доставать откуда-то вам ренджи, а если быть точнее, вьюхи.
И первое factory это mtview.
Да, дальше везде на слайдере мы увидим ренджеры.
Если вы не знали, так можно на плюсах писать.
То есть это как using, только для namespace.
Очень удобно.
Прямо как в Python, импорт нампай snp можно так же теперь.
Я не помню, когда это добавили, но это очень удобно.
Так вот, mtview.
Ну, не о чем говорить.
Это вьюха, которая просто empty.
Так же, как и пустое множество, ровно одно и никакими свойствами оно не обладает.
Или наоборот, всеми свойствами обладает.
mtview, вот он можно использовать, если вдруг где-то нужно.
SingleView – это вьюха на один элемент, который этот элемент в себе хранит.
Конечно, там этот элемент должен всем требованиям, что вью – сам.
А вью – это вью, который в себе хранит.
А вью – это вью, который в себе хранит.
Это вью, который в себе хранит.
Конечно, там этот элемент должен всем требованиям, что вью – сам.
Удовлетворять.
То есть movable быть, default initializable, скорее всего.
Ну и да, он, возможно, будет копироваться.
Так что на сильно жирные объекты лучше не создавать SingleView.
Ну и почему все требования на вьюху?
Все операции заод единиц.
Копирование, move, деструкторы, конструкторы.
Потому что n считается именно размер вью.
Несмотря на то, что в общем случае для вью нельзя определить понятие размер.
Классно, да?
Ну, наверное, как-то можно математически извернуться, и в стандарте это делается.
Но понятно, что имеется в виду, так что не будем формализма даряться.
Элемент 1, соответственно, все зовут единицы.
И тут хочу упомянуть такую штуку, как inplace.
Inplace не помню, когда добавили, но тоже очень полезная вещь.
Встречается редко, а странно.
Это такой тег, который позволяет выбрать один из конструкторов какого-то класса с конкретным смыслом.
Со смыслом сконструируй именно там, где ты собираешься хранить.
Где это может быть полезно?
Например, у вас есть optional, и вы хотите optional mutex.
Вы не можете mutex не мувать, не копировать, и по ссылке на mutex конструировать optional от mutex не получится.
Соответственно, вам нужно как-то...
Ну, у mutex нет параметров конструктора.
Это, конечно, плохой пример.
Какой-нибудь atomic.
Хочется конкретное значение проинцидизировать его.
И вот тут inplace пригождается.
Он говорит, что single view выберет тот конструктор, который к std string передаст следующий аргумент.
И это есть очень у многих классов теперь.
Возможно, вас когда-нибудь это спасет, когда вы будете биться головой об стенку,
пытаясь понять, как этот чертов конструктор сконструировать, контейнер сконструировать.
Вот, ну, как-то так.
Yota.
Насчет того, как это произносить, русский вариант это все-таки yota, потому что имеется в виду греческая буква алфавита.
По-английски ayota.
Ай читается именно как ay.
И выдает она то же самое, что range в питоне.
Вот функция именно range.
Или x-range, если у вас старый питон.
То есть интервал отчисел, но не включая последнее, что более математично и логично.
И почему вообще эта штука называется yota?
Был когда-то такой язык APL.
Может вы о нем слышали, может нет.
И в те времена, когда его разрабатывали, компьютер это был mainframe,
а терминал это был такой стол с печатной машинкой электронной, встроенной в него.
И скорость передачи от mainframe к терминалу информации была очень низкой.
Поэтому важно было как-то сэкономить на количество символов,
которые используются, на количество текста, который программа занимает.
Наоборот, из-за скорости, на количество текста было важно сэкономить.
А из-за того, что печатные машинки, вот эти все-таки, ну они механические были, они на бумаге вам код печатали.
Представляете?
Нужно было экономить количество печатающих головок.
Поэтому язык APL использовал лютый набор символов.
И у них кода тогда не было, но вот они там были, греческие буквы разные, хитрые закорючки, квадратики, кружочки.
В общем, код на APL выглядит просто бомбезно.
И именно оттуда пошла вот эта традиция обозначать range из последовательно идущих чиселок целых греческой буквы йота.
Там прям была реальная буква йота, которая прям печаталась на бумаге.
Так что да, the more you know.
И, как уже обещалось, он может быть бесконечным.
Это view на все натуральные числа.
И тут как раз играет вот это вот вся, все эти требования на асимптотику от единицы.
Несмотря на то, что это view как бы смотрит на бесконечное количество данных,
она ленивая.
Так же, как у вас во второй домашке все было ленивое.
Только во второй домашке все делалось через списки, а здесь через итераторы.
И просто begin от йоты будет вам последовательно выдавать целые числа,
помня внутри, на каком он по номеру сейчас числе.
Это чем-то напоминает генераторы из питона в том числе.
Да, соответственно вопрос, что такое end?
Ну, это какой-то sentinel.
Как уже было анонсировано, это специальный тип или специальное значение из стандарта.
Unreachable sentinel.
Его можно и нужно использовать для бесконечных ранжей.
Так, да, я что-то забыл.
У нас есть человек, который хочет рассказать доклад.
Я думаю, да. Думаю, мы сейчас ускоримся и под конец можем прослушать докладик.
Вот, unreachable sentinel.
Ну и если посмотреть на там требования к этой йоте,
от того, что мы будем, собственно, выдавать из нее,
как раз внезапно требуется weekly incrementable.
То есть это не только числа.
Там может быть вообще что угодно, в том числе другие итераторы.
И тут у вас сразу должно заиграть воображение о том,
как можно функцию emits или tails из первой домашки реализовать.
Ну ладно.
Ну и можно свой на самом деле sentinel указать в шаблонном параметре, если вам так хочется.
Ну и тут немножко странно все это сделано.
То есть sentinel указывается для самого типа, который эта йота будет выдавать, то есть для int.
И unreachable sentinel выдает при сравнении false вообще для любого типа, поэтому оно все работает.
То есть формально int это как бы не особый итератор, но он таки weekly incrementable,
а unreachable sentinel таки sentinel.
Но вот потребовать sentinel for вот здесь мы как бы не можем и не хотим.
Вам может показаться, что этот дизайн странный.
Мне тоже так кажется.
Но в этом определенно есть смысл.
И, наверное, в будущем мы увидим хитрые извращения с йотой и поймем, зачем так сделано.
Да.
IStreamView. Вот оно.
Как уже много раз упоминалось, это вьюха на последовательность объектов какого-то типа,
которые надо явно указать, читаемых из стандартного потока ввода или другого какого-то потока.
И вот здесь пример того, насколько все это кайфово может выглядеть.
Делается IStreamStream.
Туда записаны флоты.
То есть это просто поток, который выдает данные из строки.
Флоты записаны здесь через разные символы пробела.
И мы делаем IStreamView.
И внутри он, собственно, читает эти флоты через обычный оператор с двигом влево или вправо, наоборот, вправо.
А дальше можно завязать вот такую смешную функцию,
которая все данные из этого ренджа откопирует в какой-то другой итератор.
Я думаю, в стандартной библиотеке эту функцию уже видели.
И таким образом в три строчки мы, если не хотели вот это создавать и просто читать из CIN,
то вообще в две, а не в три,
считали данные, разделили их и вывели через другой сепаратор.
По-моему, это достаточно красиво.
Но едем дальше.
Помимо factory, которые вам делают вьюхи откуда-то,
есть так называемые адаптеры, которые одну вьюху превращают в другую.
Вот это основной костяк того, что вообще есть в ренджерс и почему ренджерс это круто.
Даже по названию вы можете, я думаю, уже догадаться, что все они делают.
И важный момент, что все они это делают лениво.
То есть все эти вещи все еще работают на бесконечных списках.
Но помимо...
Ну вот все вот эти штуки они лежат в ренджерс или в поднаймспейсе.
Сейчас точно не скажу.
Но это все классы.
То есть это классы, которые вы можете сконструировать в другой вьюхе.
И это будет как бы оберточка.
Да, если да ренджерс вьюс все-таки лежит.
Да, правильно.
Но их использовать не рекомендуется.
К каждому такому...
Да, к каждому такому типу прилагается еще несколько очень похожих штук.
Назовем их так.
Вот здесь, кажется, Ви должно быть.
Да, потому что... Нет, не Ви. Да.
Вьюс должно вот здесь быть вписано.
Ну да ладно. Возможно, оно и через просто ренджерс работает.
Кажется, это inline namespace.
А, вот так. Окей.
Да, соответственно, должно и так работать. Окей.
Так вот, на примере фильтра.
Фильтр вью классу.
Прилагается неблоид фильтр.
Который работает точно так же.
Но сейчас увидим в чем хитрость.
Другая штука, которая вот сложно сказать, что это, скорее всего, просто функция.
Фильтр, которая коррирует все эти штуки, если вы такое слово знаете из функционального программирования.
Но попросту говоря, вместо того, чтобы все аргументы принимать через запятую,
вот эти штуки принимают по одному аргументу и возвращают другую функцию, которая принимает следующий аргумент.
То есть синтаксис вызова вот такой.
В отдельных скобочках каждый раз новый аргумент указывать.
А нужно это все затем, чтобы уметь делать вот так.
Если вы программируете на Fsharp или Haskell или Scully тоже, вам сейчас должно быть очень радостно.
Вот это, ну, собственно, из Bash вам это, скорее всего, будет знакомо.
Вот Bash точно все должны знать.
Это pipe.
Он данные, которые написаны слева,
пайпает в программу, которая лежит справа, грубо говоря.
То есть вместо того, чтобы писать вот так, вы можете написать range, pipe, filter predicate.
А потом опять pipe что-то.
И еще pipe что-то.
И таким образом делать цепочки.
Вот.
Но вот эта штука по науке на самом деле называется range adapter object.
Даже не customization point object, а именно range adapter object.
Они не все предоставляют возможности, как у customization point object.
То есть не все их можно кастомизировать.
Но по большей части можно, потому что некоторые ренджи, некоторые бьюхи
можно более оптимально фильтровать или какие-то другие действия с ними делать.
Вот.
А нижние штуки называются range adapter closure.
Как-то так.
Вот.
И утверждается, что в целом и общем все вот эти вот действия, они будут эквивалентны.
Которые вы можете сделать.
На самом деле эквивалентны с какой точки зрения?
С точки зрения результата.
Потому что если вы напрямую сконструируете класс соответствующего адаптера,
то вот эти кастомизации через Nebloid, просто фильтр,
эти кастомизации не будут сделаны.
Соответственно у вас может производительность снизиться
из-за того, чтобы более специализированные алгоритмы не использовались.
Ну, в идеале, конечно, пайпы.
Пайпы это теперь мечта.
Мы все теперь используем пайпы.
Да, так что напрямую класс не конструируйте.
Используйте свободные функции.
Окей.
Пример с этими пайпами.
Взяли все числа от 0 до бесконечности.
Пофильтровали по модулю 3, чтобы был не 0.
А дальше взяли и возвели в квадрат.
А потом дропнули префикс, который меньше 20.
То есть пока числа меньше 20, выкидываем их из префикса.
И выводим результат.
Ну, вернее, не весь.
Если бы мы здесь убрали вот эту штучку,
то мы бы тут в вечном цикле застряли.
А так мы взяли только первые пять.
И получили ровно то, что ожидали.
Можно сказать, что это прекрасно.
Погоду портит только одно.
Вот буквы, начиная отсюда и заканчивая вот сюда,
они не имеют отношения к делу.
Это тупой boilerplate.
Копипаста на трех строчках абсолютно одинаковая.
Ну, сделать с этим, кроме как macros, ничего нельзя.
Ждем, пока кто-нибудь сильные стойки
и протолкнет через комитет стандартизации
какой-нибудь краткий синтаксис.
Потому что, если вы в Haskell посмотрите,
там это выглядит просто как
backslash x, стрелочка и вот это.
То есть гораздо меньше символов.
А в случае возведения в квадрат еще лучше.
В круглых скобках звездочка, звездочка, два.
Все.
И это сразу работает как функция
возведения в квадрат.
Тоже самое с меньше 20.
В круглых скобках меньше 20.
И, конечно, без такого сахара
все еще не очень удобно пользоваться
вот этой мишенерией.
Очень ждем сахара, чтоб код был маленьким,
понятным и не стеной.
Вот.
Да, взяв побольше, получим побольше.
При этом все вычисления, они будут откладываться
до момента, когда вот этот цикл for
соберется инкрементить итератор,
который внутри него сидит.
Вот когда мы инкрементим, вот тогда
начнет вся эта цепочка срабатывать.
Filter, transform, drop while.
Да.
И кажется более того, в юхе почти, наверное,
кэшируют результаты, поэтому когда мы
опять запустимся, оно будет работать
чуть быстрее, скорее всего.
Это зависит от имплементации.
Но, кажется, в стандарте ничего не запрещает
это кэшировать.
А некоторые кэширования...
Кажется, там есть некоторые запреты,
поскольку в юхе, вроде, должны быть там
за константу копируемыми.
Можно дропать кэш?
Копировать, да.
То есть это никто не запрещает.
Ну да, мысль про дроп кэша, конечно, интересная,
но надо читать тогда какой-нибудь Lipsy++.
Там кэшей не так много.
Мы сейчас увидим еще про кэши,
это тема бодрая.
А, собственно, кажется...
Нет, не прямо сейчас, чуть попозже.
Так, что мы здесь делаем?
Мы берем вектор, мы его фильтруем
по нечетным и проверяем, range ли это.
Собственно, пока мы проверяем сам вектор.
Вектор от range.
Вопрос.
Ну, вроде, да.
Да.
А в юхе?
Кажется, нет.
Нет.
Вопрос, почему?
Ну, он за константу не копируется.
Ну, это да.
Почему его не сделали в юхе?
Но с точки зрения концепта,
почему вот концепт вью провалился?
Потому что мы помним,
что на вьюху нужно явно подписаться.
То есть явно сказать,
я хочу быть вьюхой.
Отнаследовавшись от интерфейса
либо от viewbase.
Вот, вектор этого не делает.
Почему он этого не делает?
Потому что не за константу
и не за копирование и прочей штуки.
Хотя нет.
Ну, вот, конечно, за константу.
А вот копирование уже нет.
Да, копирование не за константу
и деструктор
не за константу.
Нет, деструктор за константу.
Да, не за константу.
Да.
Да.
Ой.
а odd это range, да, а view, по-моему да, ну конечно, мы же говорили, что полное название класса,
который вернется отсюда, это фильтр подчеркивания view, то есть все эти адаптеры, они являются вьюхами,
вообще говоря. Вдезапный флешбек к какой по номеру домашки, четвертой, наверное, да, четвертой,
этот код распечатает нам название типа, если вы решали домашку, вы понимаете как, если нет,
pretty function подробно выведет название текущей функции, когда мы вызовем эту функцию от
какого-то значения, в тип a выведется тип этого значения, и при полном выведении типа текущей
функции, название текущей функции, шаблонные аргументы тоже полностью выведутся, поэтому,
если мы вырежем какой-то префикс и какой-то конец из того, что pretty function вернул,
мы получим только название типа a, текстовое. Конечно, оно зависит от платформы, но это хоть
что-то, вот, хин для тех, кто еще не начал четвертую домашку делать, хотя пора уже. Вот, и теперь мы
с помощью этой функции посмотрим на odd, какой у него тип, а вот такой, filter view от ref view от
вектора, ну и лямбды, которую мы использовали для того, чтобы фильтровать, то есть, заметьте,
все в compile-time хранится, все типы сохранены, никакого op, никакого type-raiser, ничего, все
очень строго, и это общий подход всей библиотеки ranges. Если вам нужно type-raiser, явно скажите об этом,
и вообще вот такой весь подход postmodern C++, не важно, что у вас три-охотажные шаблонные ошибки,
не важно, что там типы такие, что просто сердечный приступ схватит, главное, что это работает
оптимально по памяти и времени, если вы хотите забить и сделать медленней, пожалуйста, anyunique мы
долго и упорно пытались разобрать, возможно, не поняли в итоге, но для view, как вы понимаете,
тоже можно написать аналог anyunique, anyview в стандарте пока его нет, и что-то не торопится
добавлять, что самое странное, но когда-нибудь, когда-нибудь, возможно, просто будет anyunique,
на который сделают alias для view, возможно, из-за того, что одно другое дублирует, решили как бы не
добавлять вперед паровозом, вот, но тут есть странная штука refview, которую мы пока не видели,
которая нам пока не понятна, да, ну, скоро еще посмотрим на нее, пока придемся к этому примеру и
чуть его поменяем, мы добавили const перед вектором, вопрос, будет ли он range и view или view?
на range все еще будет, куда он денется? а view? кажется, все еще нет, конечно, ничего не изменилось,
он все еще не подписывался на быть view, не наследует ни viewbase, ни view interface, ну,
а в константной range это вполне обыденное, ничего плохого, а вот теперь вот так вот,
теперь константным стало view, причем вот это вот filter view, а вектор теперь обычный,
вопрос, будет ли эта штука range и будет ли view?
range она, наверное, все еще будет, так,
да, наверное, и view и будет, просто не мутаблюем, ну, это вообще-то, интересно, а почему?
ага, и тут мы подходим к вопросу cache, помните требование на симпнотику begin?
я обратил внимание, что там амортизированная от единицы, а теперь представьте, мы потеряли
амортизацию на первом? если вы хотите отформировать все натуральные числа, делится на миллион,
первое число, которое делится на миллион, оно не очень близко, ну ладно, не очень хороший пример,
наверное, более, просто хотим отфильтровать какие-то числа по делящимся на два,
что будет begin у такого фильтра view? первое число, делящееся на два, но это первое число,
делящееся на два, может быть в любой позиции в массиве, как в самом начале, так и в самом конце,
если оно в самом конце, то увеличивая размер массива, а симптотика begin очевидно становится от n,
беда, но нам позволено амортизировать, поэтому мы можем сохранить, закышировать эту начальную
позицию первое число, удовлетворяющую предикату, скорее всего, оно будет закышировано в момент
первого запуска begin, но может и в конструкторе, я не знаю детали имплементации, но тем не менее,
как только мы его уже закышировали, мы вот эти n монет и тратили, а дальше мы только по одной
монете будем тратить, то есть за счет амортизации как раз и получается, что ура от единицы,
только первая операция будет занимать от n, последующие сколько угодно операции от единицы,
честно, ну и да, мутабельным этот фильтр не пометили, поэтому как только мы помещаем фильтр view
как const, мы не можем в этот кэш писать и читать, и мы проиграли, почему его не пометили мутабельным,
я не знаю, вероятно, тоже какие-то проблемы вылезают, надо почитать код библиотека,
да, если чуть подробнее разбираться, мы хотим, чтобы были begin end, а у фильтра view begin end
константных нет, то есть вот именно эта ошибка компиляции у нас будет на деле, вот и помимо
фильтра view есть еще несколько таких штук, кто-нибудь сможет объяснить, почему они тоже, вернее так,
давайте почему drop while может такую же проблему испытывать? ну drop while очень похож на фильтр,
ну да, нам нужно первый элемент как-то найти, мы собрались из начала выкидывать,
пока предикат верен, та же ситуация, что в фильтре, а вот drop view со звездочкой,
в каких случаях const drop view не view?
наверное, это зависит от итераторов, вернее, их категорий, у того, что откуда мы drop-ы,
давайте подумаем, можем ли мы от единицы легко и просто drop-нуть первые десять элементов,
вернее, не так, первые n пополам элементов, вот тогда точно все строго, конечно, не можем,
да, n зависит от n, соответственно, если мы собрались drop-ать первые n пополам элементов,
то мы проиграли, это делается за от n, и нам нужно кашировать, но если у нас random access
итератор, то мы можем его взять и сдвинуть, наверное, пополам за от единицы, да, то есть тут не
нужно просматривать каждый элемент, чтобы понять, можем ли ему drop-нуть или нет, когда у нас слабый
итератор, мы обязаны по одному разу incrementить, incrementить, incrementить, когда random access взяли
хоп и дошли, как-то так, теперь небольшой сюрприз о том, как это работает в итоге, что выведется,
предположение,
если это конкурится, то кажется, первый элемент вектор будет перезаписан, а нет, сейчас,
еще не первый, а второй тогда, нет, ну что мы тут делаем, мы взяли вектор с вот таким
контентом, мы отфильтровали только те элементы, которые нечетные, и уже после того, как создали
вьюху, а вот это собственно и дает ответ на вопрос, а в какой момент каширование происходит,
ну да, каширование происходит все-таки в момент первого бигина, возможно это implementation
defined, а возможно нет, тут немножко все, что произошло, ну смотри, при создании фильтр вью,
ничего не произошло, вообще ничего, ну понятно, а при первом вызове бигина, оно нашло первый
нечетный в векторе, фильтр вью по ссылке вектора хранит, да, это вью, соответственно,
изменив этот вектор, результат вьюхи тоже изменился, да, а если вот так, выведется ли пятерка в самом
начале или нет, не выведется, потому что каширование произошло теперь вот здесь,
где первый раз бигин вызвался, то есть тени вьюхи это side-effect, как с этим мирить,
звучит как волатайл, да, немножечко, как с этим мириться и как с этим жить, я не уверен, я не знаю,
хорошо ли это или плохо или норма это, но непонятно, как изменить дизайн библиотеки,
чтобы стало лучше, так что да, запомните, что лучше не мутировать ваш контейнер, пока у вас
хотя бы одна вьюха на него есть, потому что вообще говоря, есть такое понятие, как инвалидация
из итераторов, да, помним о нем, если мы вектор что-то запушбечим, итераторы могут инвалидироваться,
если он увеличил свой размер, вьюхи состоят из итераторов, вьюхи тоже инвалидируются,
но когда мы пишем именно что-то в контейнер, они добавляем, то есть как бы мы содержимое
контейнера меняем, а не его самого, вроде как ничего не инвалидируется, но при этом результат
начинает меняться, и вот это как бы так типа, ну странно немножко, ну ладно, view, take view,
я забыл, что я на этом моменте хотел сказать, давайте просто посмотрим, как работают вообще
эти классы в вьюхи, адаптеры, шаблонный аргумент view наследует view interface по CRTP,
и да, ну имеет какой-то конструктор от того, что им требуется, а, нет, я все еще не вспомнил,
что хотел сказать, да, я хотел вернуться к, помните, у нас там некоторый ref view был,
когда мы выводили тип того, что получилось при фильтрации вектора, там был не просто filter view
от вектора, а filter view от reference view, или что-то такое ref view, от вектора, вот откуда взялся этот
промежуточный ref view, если во всех этих вьюхах, да, take пример, ну в фильтре так же, во всех
из них принимаются именно вьюха, а мы передали вектор, и с одной стороны, как-то кажется,
что должна была быть ошибка, вектор же не является вьюхой, но с другой стороны,
там волшебным образом получился ref view, как это могло произойти?
ну кто-то за нас сделал вьюху. ну как она могла здесь появиться сама?
какая-то новая языковая фишка 17-х плюсов помогла. а, понятно, дедакшн гайды. да,
именно так, да, сейчас, что, да, а, тут все это дальше показывается, я что-то сбил все совсем,
да, собственно, вызвали take view, посмотрели что внутри, а там ref view, и да, ответ дедакшн гайды,
написано такое дедакшн гайд, если нам на обход пришел range, то считаем, что наш шаблонный аргумент
это некоторый alt, то есть еще не ref view внезапно. вопрос, а вот так она сработает тогда, по логике,
пока мы не узнали, как это работает внутри вот этот alt, мы можем пока только догадки строить,
должно ли вообще такое компилиться? используйте здравый смысл.
это будет view, которая будет неволидна уже после создания своего, или что?
ну, если бы это компилировалось, то да, но, конечно, это не должно компилироваться,
мы не хотим такие ошибки глупые, мы хотим вообще это запретить на уровне вот в момент
компиляции, проверить и не дать выстрелить себе в ногу, это тоже один из девизов postmodern c++,
что все проверить на этапе компиляции и чтобы никаких сегментейшн фолтов желательно хотелось бы.
вот, ну и создав временный вектор и записав его в вьюху, или создав вьюху на него,
что вообще могло получиться? вьюха не владеет памятью, а вектор временный, и он удалится,
кто будет владеть памятью? непонятно. соответственно, это не должно компилироваться,
но здесь, заметьте, универсальная ссылка. то бишь, сорвали это, все еще будет нормально работать,
и в alt передастся rvalue. и, ну, вот в таком случае ситуация точно такая же.
окей, а как это вообще работает с alt? alt это alias, оно принимает некоторый range,
но не просто, а viewable range. то есть, далеко не для всех ранжей это пройдет.
сейчас увидим почему. ну и да, оно вызывает функцию all, но эта функция не настоящая,
она как бы опять волшебная, если мне память не изменяет. она опять работает вот по вот этим
приоритетам. пытаемся, то не получилось, все не получилось, третье. если нам уже вьюху прислали,
то ничего делать не надо, просто берем эту вьюху и используем. ну, убрав с нее всякие ссылки и прочую
фигню. а если же прислали что-то другое, то мы сначала попробуем сконструировать refview,
тот самый, для векторов он получился, помните? а если и это не вышло, то subrange. и тут придется
еще накидать концептов. да, меня самого смущает эта обилие. очень мало примеров,
где вот эта вот тонкая кастомизация действительно нужна. слишком мало. но да ладно. borrowed range
это range, который либо lvalue-reference, то есть какая-нибудь lvalue-ссылка на вектор вполне
подходит. либо должна быть пометка enable borrowed range. но эта пометка уже делается не
через наследование, через специализацию гуля. почему? ну потому. консистентность это не одна
из ярких сторон стандартной библиотеки. ну да ладно. и viewable range, который мы видели,
вот этот all t, он хочет viewable range. и viewable range это range, который либо borrowed range,
который мы только что увидели, либо view. да, то есть непонятно зачем еще раз требовать,
что это range, но видимо это чтобы ошибки концептов были более понятны. ну в случае с view и все
понятно, надо только понять, зачем еще приносить вот этот странный borrowed range. какие вообще use
кейсы? ну use case вполне понятен. мы его уже видели для lvalue-reference, по крайней мере. да, и в итоге
оно все получается так. и когда мы просто создали переменную вектора vv и передали ее в фильтр,
вот эта vv, это lvalue ссылка на вектор. она подходит под borrowed range, потому что является lvalue
ссылкой на range. и все попадает в wall и все нормально. но дальше оно почему-то попадает в reference view и
надо для этого посмотреть, чтобы понять почему на сам класс. выглядит страшно? знаю. давайте по
порядку. сверху вниз, во-первых, оно принимает range и требует, чтобы это был некоторый объектный
тип. ну это так уже, типа проверка на адекватность происходящего. самое главное в конструкторе,
а не в самом классе. здесь требуется different from refview t, то есть t, который не является другим
refview. ну это такая защита от клупа и рекурсии. и чтобы конструктор копирования все-таки именно
он вызывался, а не вот эта штука. а требуется convertible2 для r, который у нас основной. то есть
если там t это lvalue ссылка на вектор, как у нас было, то таки да, convertible2 t r% будет работать,
потому что t это вектор m%, r будет вектор, ну и мы один и тот же тип подставили. а дальше
странный костылек. есть такая функция fun, которая принимает только lvalue ссылку и требуется,
чтобы ее можно было вызвать от t. то есть чтобы t было некоторым подобием lvalue ссылки, в каком-то
смысле. в более каком-то широком, чем convertible2 или более узком. похоже на референс врата.
возможно речь идет о нем, возможно речь идет о каких-нибудь более сложных умных указателях,
но так конечно не догадаешься без объяснений. но суть всего происходящего в том, что это
reference, lvalue reference на range, reference view, ссылка на range. и фактически единственный такой нормальный
use case для этого, это когда у вас есть range, он не вьюха, и вы lvalue ссылку на него передали
в какой-нибудь адаптер или еще куда-нибудь. тогда у вас волшебным образом возникнет вот
эта прослойчка для того, чтобы адаптеры можно было писать однородно, всегда зная, что в них
приходит вьюха, не задумываясь о том, что может прийти вьюха, а может не вьюха, и тогда там чуть
по-другому придется специализировать. и это упрощает код. это удобно. это вот одна из таких
дизайнерских решений в этой библиотеке, которая мне кажется прям вот отличная. без него пришлось
быть тяжко. вот как-то так. но есть еще subrange, и это какой-то костыль, если честно. ну давайте
посмотрим. у самого класса subrange есть два шаблонных параметра сверху. на самом деле еще больше,
но там дебри, лютые дебри. это итератор и сентинел. вроде все просто. и первый из двух конструкторов
он как раз от этого итератора конструируется, и от сентинела. но там немножко хитрый концепт
есть, который там что-то подменит. ну в общем, вот где-то и точа, туда лучше не лезть. и
зачем этот первый конструктор нужен? вот для этой штуки. кажется, что только для нее. когда-нибудь
использовали такую функцию. а, то multimap. да, здесь должен был быть multimap. ну какие-нибудь задачки
олимпиадные решали? решали же олимпиадные задачки какие-нибудь там equal range? нет? по-быстренькому
залогорифм что-нибудь найти? кажется, что дальше в overbound редко что нужно. ну бывало, мне кажется,
у меня такое. странно, что вас нет. ну ладно. мне кажется, один из немногих, кто на олимпиадах
hostile активно, очень активно пользовал. я пытался. это мне не помогло, но... я вроде тоже пробовал. мне
это правда в итоге тоже не очень помогло. я так и не понял, почему. грустная судьба наша. но да,
он возвращает пару итераторов multimap, который указывает на начало отрезка, где начинаются
элементы с равными ключами и его конец. и как бы как это запихнуть в какую-то view? какое это вообще
будет view? вот решили, что вот этот. subrange. то есть как бы референс view не особо подходит,
а вот subrange как раз. std-span, если вы его помните, он тоже не подходит. std-span для последовательных,
последовательной памяти. а вот это как бы обобщение std-span для каких-то непоследовательных штук,
для каких-то деревьев, грубо говоря. но вот второй конструктор нам более интересен,
потому что, как мы видели, all функция именно его использует. именно второй конструктор.
и получается такая ситуация, что мы какой-то адаптер делаем от expression. и expression как бы
там не subrange, если subrange это тривиально, а в итоге все равно получился subrange внутри view,
а не ref view. вот вопрос, когда такое еще может происходить? кто-нибудь догадается, какие есть
кейсы, когда мы как бы хотим какой-то контейнер засунуть в адаптеры, но при этом нам не хватает вот
этой штуки? я думаю, вы не догадаетесь, потому что это вообще типа ужас. это допоминалка. в последнюю
очередь subrange. соответственно нам нужно, чтобы это была не view и все, что в ref view нарушалось.
то есть это было как бы не lvalue, не lvalue ссылка на контейнер. и внезапно, что хотел сказать,
я забыл, что я хотел сказать на этом слайде, если честно.
давайте просто на него посмотрим. такой код. попытались взять begin от rvalue ссылки на какой-то
вектор. и про требования к begin. все очень запутано. мы возвращаемся к вопросу про enable borrow
range. и вот и вообще borrow range, что это и зачем это? вот если штука не помечена явно как borrow
range, то rvalue ссылки что-то в begin к last нельзя. соответственно подразумевается, что если мы
что-то пометим как borrow range, то можно. кстати, для std begin и std end это не так, так что теперь
нужно использовать range с begin, если вы хотите, чтобы ваш код нормально работает, обобщенный.
вот и собственно не буду томить, я не знаю, как к этому нормально подвести, я просто типа
нагуглил и понял, что это что-то жесть. мне на borrow range кажется идея на это же range такой,
что он пробрасывает lifetime дальше. сейчас скажу да про borrow range, ну в принципе так,
но конкретные примеры. да, наверное слайды чуть не в том порядке поставил, черт, ладно.
короче, можно сделать такую штуку, сделать вектор, который не вектор, а внутри себя хранит shared
указатель на вектор. то есть такой shared вектор. в чем его проблема? почему он не вью?
со сколько у него работает деструктор? вот если у нас уже остался последний такой
shared вектор и мы его удаляем, кажется за ootn, правда ведь? нам же нужно удалить как бы то,
что по shared pointer лежит. вот так что да, ootn соответственно не вью, а range он как бы спокойно
является. и более того, мы этот range можем спокойно копировать. то есть копируя его,
мы как бы не копируем содержимое. такая странная ситуация. и мы спокойно можем взять и мувнуть его
в std begin или мувнуть его в какой-нибудь адаптер. и это ничего нам не сломает. и вот именно для
такого случая, кажется, будут subrange. другой пример это span, у которого статический размер. у него
что с ним не так?
помогите мне, почему span от in42 не будет вью?
стоп, а span без фиксированного размера был вью? да. вот кстати это не было уточнено,
там над давним давно на слайде. окей, сейчас подумаем. а окей, ладно, да span просто без фиксированного
размера это таки вью. то есть с этим все нормально. как только вы статический размер оббиваете,
почему-то все ломается.
ну, казалось бы, что в себе span статического размера хранит.
указатель и все. да, соответственно, копировать, сравнивать, все вообще прекрасно можно.
ну, конечно, да. ну, знаете, что у меня очень плохая память, так что мы откроем все-таки
concept view, потому что вдруг что-то не так скажу или не так вспомню. movable, movable-leon, да, movable,
range-leon. ну, вроде range, а не contiguous. но в goodbolt я это вбивал, а это не работало.
ну, вот это уже тонкий аргумент. да, нет, давайте так. ты же с транка собирал? да, с транк.
покажи ниже, там были какие-то... да, вьюховано.
да, как так? с утра не было, с вечера стало. что это такое?
так, проверяем.
ага. а, я все попутал, кажется. что? что происходит?
нет, да, он действительно вьюха. ух, нормально выпиливается. да, странно, слушайте, странно, нет, еще раз, что?
очень странно. я отчетливо помню, как я с утра это перепроверял. ладно, окей, в общем, да, кажется,
единственное наше, наш контрпример, это вот такая фига тени и какой-нибудь экзотический вью, у которого нет какого-нибудь
оператора присваивания или чего-нибудь такого. но это, конечно, дичь. вряд ли такое часто в природе
встречается. так, нам осталось совсем чуть-чуть, и скоро мы перейдем к докладу. да, но мораль вот в чем,
что BORUT RANGE это как бы range на итераторы, которого можно оставлять ссылки даже когда он удален.
ну, судя сами, итераторы себе оставлять. да, и сами итераторы, я что-то не то сказал. то есть как бы сами
итераторы не протухают, когда BORUT RANGE умер. то есть это похоже на вьюху тем, что оно как бы не
владеет, а только ссылается на кого-то другого. но при этом всех остальных требований о вьюхах нету.
то есть это может быть очень жирная штука внутри. и там асимптотики вообще любые, кажется. и каких-то
там операций даже может не быть. да, копирование, мува, прочих вещей. то есть для вьюх все эти
операции хочется иметь, чтобы с ними работать регулярно как-то, да, в обобщенном коде. соответственно,
такие вот экзотические кейсы, которые все же могут быть, они оформлены вот сюда отдельно. BORUT RANGE.
вот. ну, как-то так. последний пунктик. это новое алгоритмы классное. наверное сейчас без
прерыва уже придется, так что держимся. в стд с незапамятных времен есть алгоритмы. они обычно
выглядят вот так. если там еще второй какой-нибудь интервал принимается, то еще два итератора. но это
конечно дичь. надо вот так. и теперь так можно. более того, некоторые алгоритмы за стд RANGE
прокачали. например, рассмотрим вот такой вектор из пар. в каком-то смысле flatmap очень кэшлокальный,
очень классный. а мы хотим отсортировать его по value. хотя, конечно, было бы логичнее поиди,
но ладно. и внезапно это можно сделать вот так. поменитируем немножко над этим. мы просто вкинули
вектор в sort. второй аргумент – это компаратор. мы его по дефолту оставили, не поменяли. а теперь
есть какой-то третий аргумент, в который мы передали ссылку на val. что мы там просили передать?
указатель на член класса. я заговариваюсь под вечер. а теперь таким образом это проектор?
именно так. и напечатает это то, что мы ожидаем. foreach тоже есть, кстати. это чуть более удобно,
чем begin и end писать. если поиди, то будет отсорчено поиди. я думаю, ничего удивительного. да,
это действительно проектор. по умолчанию onIdentity, а компаратор у нас по умолчанию less. соответственно,
std less или std identity. я думаю, про std less вы слышали, а std identity – это функция, которая возвращает
свой аргумент без изменений. и тут, конечно же, есть концепт, который проверяет, что сортировочка
сработает в compile time. но смысл проекции в том, что мы с компаратором будем сравнивать не сами
элементы, а какие-то их части. и проектор, вообще говоря, это, наверное, какая-нибудь функция будет
или что-нибудь вроде того. но внезапно можно и ссылку в указатель на член класса передать.
и почему так можно и как это вообще работает чуть более подробно в концепте sortable указано.
и сюда мы что вкидываем? итератор нашего range, компаратор и проекцию. здесь есть некоторый
permutable и это требование на итератор. и вот там появляется этот зоопарк из indirectly,
что-то там. я не помню, я вставил с этим слайд? да, я вставил. просто чтобы этот зоопарк вам
показать хоть раз. почти на любое действие, которое вы можете совершить с результатом,
полученным из итератора, есть концепт indirectly. то есть концепт swapable есть, есть indirectly
swapable. концепт movable есть, есть indirectly movable, но еще там storable. то есть да,
это немножко дичь. в общем, это минимальные необходимые требования, чтобы хотя бы за
квадрат сортировку можно было сделать. и вот он здесь как раз forward iterator. теперь про indirect
streak week order. это мы, кажется, в прошлый раз обсуждали, да? ну, по крайней мере, streak week,
нет, или когда-то совсем давно. но имеется в виду, короче, что сравнивать можно. причем,
про что мы говорим сравнивать можно? можно с помощью R сравнивать классы, которые получаются
в результате projected IP. ну и indirect, опять этот зоопарк, имеется в виду, что через итератор не
напрямую. то есть операции R можно сравнивать то, что вернут итераторы из второго аргумента. и вот
projected нам тоже как бы итератор вернет. а какой вот такой... да, это, короче, структурка, которая
вообще нигде в коде не используется, а только вот в этом концепте. и у нее оператор заменования
возвращает indirect result t. ну, вторая штука, это неинтересно. а вот этот indirect result t это
то же самое, что result t, то есть результат применения функции, функции prodge, к итератору,
ну или к значению, но так как indirect к итератору. да, заметьте, выше есть indirectly readable,
indirectly regular, unary, invocable, то есть вообще жуть. все indirectly. вот, ну и в итоге внутри этого
indirectly result t мы делаем invoke result t от itr-reference, то есть в ev засовываем результат. а в std-invoke
появилась новая строчка, которая говорит, что на ссылке на структурку, ссылку на ее член класса
можно использовать как функцию и возвращать ссылку на сам этот член. прикольно, да? сколько
слоев нужно пройти, чтобы докопаться до истины. вот, но все эти... это было из 17-х плюсов изначально,
то есть, возможно, это была заготовка или так решили, что почему... это заготовка была, да,
потому что это не использовалось, насколько я помню, в библиотеке. понятно. вот, ну вообще все эти
мысли про indirectly то, indirectly все наталкивают на то, что нам бы хотелось бы уметь в концепты
принимать другие концепты, чтобы indirectly это был такой описательный концепт, внутри которого
любой другой концепт можно засунуть. но, к сожалению, мы живем в несовершенном мире, и это появится
не раньше, чем через 10 лет. вот, напоследок, что будет дальше? ну, то есть, с плюс 23. добавят
то, чего очень сильно не хватает, если честно. зипы, денумирейты, грубай, флатмэп, который другой
флатмэп, который монодический флатмэп, по сути, это concatenate для большинства структур. да, но не
суть важна. нет, это не просто concatenate, это map и потом concatenate или transform, а потом concatenate.
chunk, slide, stride – это штуки, которые позволяют бегущим окном идти, разбить на куски фиксированного
размера. chunk – это куски фиксированного размера, slide – это бегущее окно, и stride – это пропускать
некоторые элементы. то есть, там каждый пятый элемент взять. Cartesian product – это декартовое
произведение. тоже пока нет, тоже хочется. ну, фолды, сканы вы писали даже сами, думаю, понимаете,
о чем речь. вот. и все это очень хочется, но, к сожалению, это не успели в 20-е пропихнуть,
поэтому в 23-е сейчас активно пропихивают. прям каждый день приходит письма, что то пропихнулось,
все пропихнулось. ну, я не особо точно слежу, кто конкретно, просто вижу письмо, что пропихнули
очередную функцию с хаскеля, и прям сердечко радуется. вот. так что, да, когда-нибудь писать
на ренджах, будет вообще супер-кайф, и уже сейчас можно писать на них достаточно приятно,
но не до конца. и, ну, небольшой пример кода. если вы не знаете, есть такое мероприятие Advent of Code.
это такая традиция, то ли перед рождеством, то ли перед новым годом на западе каждый день делают
что-то. там отрывают из календаря что-то, листочек, или там открывают какую-нибудь коробку с игрушкой,
а вот программисты придумали каждый день решать олимпиадную задачу, но они рассчитаны
типа совсем на несоображающих ребят, но по сложности возрастают со временем, так что бывает
что-то интересное под конец. но тут задача первая нас интересует. да, это не то, это не то,
это первое, вот первое. совсем простая задача. дана последовательность чисел, нужно посчитать,
сколько раз следующее число увеличилось по сравнению с предыдущим. да, то есть там 199,
предыдущего вообще нет, 200 увеличилось, 8 увеличилось, 10 увеличилось, 200 уменьшилось,
не считаем. ну и ответ 7. как это на рейнджах написать? ну сделаем вектор, чтобы в нем данные
хранить, потому что если мы этого не сделаем, у нас будут те самые проблемы с тем, что айстрим вью
и вообще эти импл-утераторы работают немножко больно. их там нельзя копировать, нельзя два
раза читать, будет что-то странное. поэтому вот так, через алгоритм копия, backinserter запихнули
все в input. потом надо решить задачу. возьмем input и возьмем input с дропнутым первым элементом.
сделаем операцию zip with. это такой zip, который не просто зипает, а еще и применяет некоторую
функцию к каждой паре. и вот эта функция в нашем случае это оператор less. стд less, то есть оператор
меньше. таким образом получается на выходе вот этого всего у нас последовательность булей. true там,
где следующий элемент был сейчас, вот это less than вот это, то есть предыдущий элемент был меньше
следующего. то есть true ровно на тех позициях, где мы увеличились. и размер этого массива,
грубо говоря, range, он будет n-1 по сравнению с n, потому что я дропнул здесь один, и у последнего
элемента вот этого аргумента не будет пары, и zip просто его отбросит. ну и дальше используется
алгоритм count, который подсчитывает количество true. наверное, это можно было сделать проще,
но мне почему-то первое, что в голову пришло и скомпилировалось, это count. и это таки действительно
работает. я вбил пример оттуда тестовой, удалим там последнее число, оно полагает и изменится на 6.
вот я думал с вами порешать еще немножко этих задачек, но мы тогда не успеем послушать
доклад, поэтому передаю слово Денису. я могу в принципе не очень долго рассказывать.
у тебя 20 минут, так что да. у меня нельзя демонстрацию включить. сейчас, секундочку,
я отмечу галочкой. вот, можешь запускать.
окей, какая вообще тема? мы посмотрим на обработку, ну короче, на ошибки, на то,
как создаются и обрабатываются ошибки в MongoDB. вот, и почему это вообще может быть нам интересно
с точки зрения в принципе метапрограммирования. в общем, MongoDB это такая база данных на SQL,
довольно популярная, и она написана на плюсах. соответственно, можно посмотреть код и можно
посмотреть на интересующие нас вещи в плане метапроги. в общем, тут на самом деле в широком
смысле метапроги, тут довольно еще много всяких прикольных вещей. нас, видимо, подразумевалось,
что я расскажу конкретно про одну вещь, сейчас ее тогда покажу сразу. в общем, внутри базы данных
есть некоторые исключения, которые там кидаются при разных ошибках. у этих исключений бывает что?
вот какой-то пример, наследуется исключение от std-exception, также переопределяется там вот,
который есть у std-exception, там получается какая-то причина, мы получаем ее некоторую, и в общем-то
выводим. вот, это как бы то, что мы наследуем отсюда. и дальше добавляются еще некоторые вещи,
которые тоже могут быть интересны нам, например, там стерилизация какая-то, типа получить код
ошибки, который мы уже получаем из внутренней структурки статуса. в общем-то, добавить какой-то
контекст, добавить еще какую-то стрингу, которая дополнительное описание какое-то нам дает.
еще вот тут интересно есть, мы как-то, видимо, хотим брать и присваивать наши exception, как бы
разбивать их на какие-то категории exception. вот, и вот эта штука, она наталкивает на мысль то,
что мы так можем делать, потому что мы можем проверить, как бы, подходит ли нам, ну короче,
являемся ли мы какой-то какой-то категории. вот, как-то так. ну еще здесь есть некоторые вещи
связанные с тем, что мы дополнительно какую-то информацию можем передавать. в принципе,
я потом про это могу что-то сказать тоже. вот, значит, есть получается exception, какая-то их,
видимо, иерархия будет, потому что это подразумеваться будет каким-то базовым классом. а дальше еще они
разбиваются на некоторые категории. окей, смотрим дальше. есть самая базовая вещь, просто
assertion exception, которая, вот, мы там можем, получается, в exception это передать, как бы,
какую-то строку, какую-то даже дополнительную информацию, какой-то код ошибки. вот, ну как бы,
вообще обычно для каких-то таких обыденных целей нам это и нужно, больше, в принципе, ничего и не
нужно. если мы хотим еще на категории разбивать, то дальше начинается какая-то работа. пока что
просто assertion exception, кажется, ничего особенного. а теперь уже начинаются некоторые exception для
категорий, и сейчас будет происходить что-то похожее на генерацию иерархий, которая была на третьей
лекции, если я ошибаюсь. вот, третья лекция. давайте посмотрим на код, что там примерно было. напомню,
там основная идея была в том, что вот у нас есть какой-то event set, и мы делаем множество
наследования от абстрактных хендлеров. каждая у нас такая структурка, она шаблонная, и здесь у нас
внутри лежит виртуальная функция, и вот мы, значит, хотим так взять и сделать такой интерфейс.
проблема была в том, что мы решали, что у нас там виртуальная функция не может быть шаблонной. вот,
дальше мы еще каким-то образом брали и через intermediate, если кто помнит, делали конкретные event
set. здесь это даже не понадобится, то есть здесь сделано немножко проще. вот, окей, что дальше
происходит у нас? возвращаемся сюда. значит, есть db exception, есть assertion exception. от них виртуально
наследуется exception для конкретной категории шаблонной. вот, пока что ладно, пока что просто
виртуально наследуется, ничего особенного, потом будет понятно, зачем виртуален. и дальше
начинается nmspace, в котором происходит метапрограммирование. давайте я, наверное, просто покажу,
чего мы хотим достичь, чтобы потом было понятно. ну, в общем, мы просто хотим брать и иметь такой
exception for для некоторого error-кода, который дальше сможет
создаваться от некоторых разных каких-то категорий. наверное, звучит не очень убедительно. я покажу
тогда сразу dispatcher, который здесь вызывается. вот его объявление. в чем смысл? нам передается код
и дальше передается какое-то переменное количество категорий. на самом деле, вот здесь
передается нам, получается, некоторый type-list на самом деле. сейчас я покажу, где он. может
встречаться нам. ну, чтобы вы поверили, что это type-list. там чуть пониже в специализации был категории
list. мне кажется, тебе он нужен. если ты вернешься к dispatcher, да, вот ты указываешь на default
сейчас. это default. да, ты вот про это всё понял, да. да, вот. в таком файле со странным разрешением,
странным кодом с процентами, с этими долларами находится... так, а ты не разобрал, почему доллары
и такие странные штуки? не-не-не. ну, в смысле, это дальше код-генерация там просто. а, окей, хорошо.
вот. в общем, получается, что здесь объявляется list из категорий и в дальнейшем сюда будут
подставляться некоторые типы через код-генерацию. в общем-то, вот. то есть, это, короче, считается,
что просто type-list из категорий. вот. теперь, что происходит в этом dispatcher? то есть, нам
передают какой-то код, нам передают какие-то категории. если никаких категорий нам не передали,
то мы говорим ok через conditional. значит, мы просто exception for implementation, код ошибки и мы assertion
exception. что это значит? ну ладно, окей. если нам передали какие-то категории, то вот здесь
получается у нас такой же как бы exception for нескольких категорий. вот этот. который
абстракт, там виртуально наследовался от... получается assertion exception. вот. окей. давайте
посмотрим тогда на что такое вот эта штука. вот она здесь написана. и это получается event set,
если смотреть на предыдущий код, который был на семинале. абстракт event set. вот. в чем заключается
идея здесь? в том, что мы также просто берем публично наследуемся от переменного количества
bases, которые являются сами exception for категории от какой-то категории. можно я тебя немного
перебью? ты сказал, что это абстракт set. это скорее concrete set, чтобы людей не запутать. то есть в качестве
абстракт set у нас служит assertion exception. то есть assertion exception это такая базовая штука,
которая одна. и она определяет какие-то виртуальные функции. а вот это exception for
impulse оно несколькими образом эти функции переопределяет. я имел в виду в плане схемы
наследования похожим. да, тут скорее так. у нас получается, что assertion exception нам дает...
да, что-то зуму плохо. ладно, я хотел сказать, что эта схема очень похожа на то, что мы с
Intermediate делали. и мы даже в конце чуть про это говорили, но так уже вскользь. и потом Андрей
вроде скинул работающее решение. вместо вот этих интермидиатов действительно можно виртуальное
наследование использовать, чтобы несколько переопределяющих классов подпихнуть в иерархию.
ее можно раскрутить, а можно горизонтально сделать через виртуальное. окей, да, кажется в записи это
просто нет. а, беда, ладно. что вы именно, про замену линейной иерархии на скеттер? да, потому что я
рабочий код скинул уже там после семинары. да, мы там совсем вскользь упоминали, а потом...
окей, получается просто такая схема, что вот мы взяли, наследовались от dbException, и у нас
получился AssertionException. а дальше у нас через виртуальное наследование конкретная категория
наследуется от AssertionException. и здесь exception for implementation он принимает в себя, получается,
список basis, то есть список категорий, которым соответствует этот код. и, в общем-то, от них
наследуется. вот, от вот таких вещей там с конкретной категорией. в чем большой смысл всего этого?
у нас же здесь вроде как не фабрика там, все такое. мы хотим просто ловить по, как бы, ну, конкретно
писать кэтчи по, получается, категории. то есть в этой ветке кэтча мы хотим ловить конкретную
категорию ошибки. вот, и таким образом у нас это получится сделать. ну, как-то так. то есть вот это
как бы мотивация того вообще, зачем мы этим занимаемся. и, в общем-то, такая вот реализация,
которая очень похожа на то, что было на семинаре. ну, получается, даже совсем похожа по схеме
наследования на исправленный код. отмечу, что человек, который... да, мне кажется Zoom глушит
меня, когда ты говоришь, так что да. отмечу, что человек, который, собственно, написал этот код,
сам это называет генерацией иерархии, как в Александреску, так что да, это ровно оно.
ладно, вот это, что касается этих иерархий, теперь, не знаю, вот, как бы, если есть, что добавить,
Ром, добавь, потому что конкретно дальше про иерархии я не знаю, что сказать. то есть какие-то
применения может, не знаю, как бы, если ты знаешь. то есть в этом файлике, как бы, вот,
определяется такая вещь, понятно, зачем нужна, дальше есть какие-то еще более тонкие вещи внутри.
как бы, можно, в принципе, ну, я могу что-то сказать, могу, в принципе, остановиться. ну, в принципе,
10 минут у тебя еще есть, так что ты можешь продолжить про что-то интересное, но основной
поинт, да, что мы хотим в кетче уметь конкретную категорию просто указать и по ней отловить,
но иногда в коде все равно приходится ловить любой exception, и из-за этого и приходится такую вот
diamond наследование делать, да, ромбовидное, а генерация иерархии сюда приплывает немножко из
другой мотивации на самом деле, да, казалось бы, зачем все эти тайп-листы и хитрости? за тем,
что база данных штука очень сложная и категории ошибок может быть много, они могут появляться,
исчезать, и хочется все это как-то автоматизировано делать, а не руками подкостыливать новые наследники
в эту иерархию, ну или новые промежуточные классы для категорий, поэтому они, ну как бы
взвесив свои требования, видимо бизнес даже требования, поняли, что они хотят уметь в файлике
буквально указывать список категорий, и даже по-моему сами exception, вот эти input тоже вроде
как код генится, это то, что в этот курс не влезло, но когда-нибудь обязательно влезет,
когда остальный материал начнет читаться более-более хорошо, тоже считается метапрогой,
генерация кода на C++ как текста из-за ну просто каких-то конфигов, это часто применяется
на практике, как бы не казалось, что ну это какое-то типа пошлое на уровне макросов,
код ген, но тем не менее на практике это реально часто используется, и они генерят по конфигу
категории в этом type list, они генерят по конфигу сами exception или state, и для них скорее что-нибудь такое,
и таким образом могут очень легко жонглировать этими штуками, когда нужно что-то изменить,
и код на плюсах вообще не трогают, что приятно. Ну да, в общем-то вот я открыл, если там видно,
получается на демонстрации, тот файлик, который содержит в себе error categories,
for impulse, ну в общем type list тот самый, он на самом деле генерируется, там код генерации есть,
на типа вот это вот разрешение, точнее TPL, это какой-то пич, пишенный, я так понял, парсер,
который может взять, ну там какой-то есть синдекс для того, для установки этих вещей,
вот, на какие-нибудь места вот по типу вот таких, вот, и здесь написаны какие-то ifs и даже fors,
вот, то есть, например, for, error code для кодов, а эти коды, я так понимаю, берутся вот отсюда,
вот, где есть получается имя кода и его номер, в общем-то, то есть, он такой,
довольно большой файлик, чтобы все ручками писать, вот, а есть еще категории, ошибок,
тоже написаны в этой штуке, потому что, опять же, мы берем и делаем код генерацию здесь,
вот, как-то так, еще не знаю, что упомянуть, но вот иногда, наверное, хочется брать и добавлять
к ошибкам какие-то джейсоны, для этого есть тоже внутри там получается, есть класт статус,
в котором внутри есть какие-то вещи, связанные типа с этими штуками, потому что здесь вот какие-то
так, ладно, тут точно где-то было, что принимается себе парсер, который, по сути,
является, вот, принимает себя, получается, бинарный, ну, я не знаю, как это читается,
короче, бинарный джейсон, скажем так, вот, то есть, к ошибкам еще можно какие-то такие штуки
прилеплять, есть внутри каждого exception статус, статус это такая вот штука, которая там может
быть окей, может быть не окей, здесь, наверное, ничего особенного не происходит, просто какие-то
в плане интересного, потому что здесь просто создается террор кода и от причины, в общем-то,
этот статус, который там вот здесь может быть создаваться от какой-то штуки reason, шаблонный,
главное, чтобы она, типа, была constructable, ну, точнее, string был constructable от этого reason,
вот, тогда все будет хорошо у нас, вот, довольно гибкая система в этом плане, и вот сюда можно
прилеплять какие-то контексты, которые, типа, дают просто, на самом деле, позволяют, типа, вот,
какие-то штуки делать cost-buy, то есть, цепочку делать даже из причин, типа, того, почему мы,
собственно говоря, упали, вот, ну, тут тоже код генерации, вот, есть код генерации часть на
питоне, написано, просто я обнаружил, в принципе, есть еще куча макросов, какие-то макросы используют
тоже, опять же, для код генерации, то есть, здесь прямо вообще набор, типа, код генерации разными
способами используется, вот, и, наверное, примерно все, то есть, тут как-то нет такой штуки, как вот
обсуждалось на семинаре, что, возможно, нужно какие-то концепты, которые проверяют то, что у нас там
фабрика чему-то удовлетворяет конкретно, вот, здесь единственное, что я, как бы, искал и нашел,
это то, что они тут зачем-то, ну, не зачем-то, а, короче, берут свой шерп ПТР, пишут, и вот им нужны
какие-то концепты тоже, здесь интересные, которые вот как-то так реализуются по странам, ну,
видимо, потому что тогда еще на тот момент не было концептов, вот, ну, в принципе, у меня все.
Ну, насчет концептов рискну предположить, что у них в зависимости от флагов компиляторы либо
используются нормальные концепты, либо макросами подкостыливаются какие-нибудь enable issues, такое
встречается в Unifex. Так, что-то еще хотел сказать, вот, про концепты для factory, про то, что она
адекватно конструируется, ну, да, на практике нет сильных причин очень сильно констраинить
какие-то внутренние инфраструктурные вещи, потому что ошибки компиляции в них происходят редко,
и от того, что мы потратим время на добавление концептов, мы ничего не выиграем, когда мы что-нибудь
сломаем, да, ну, потому что мы никогда не ломаем, и эти концепты нам не помогут дебажить какую-то
лютую ошибку компиляции, вот, ну, и этот код, кажется, не очень часто у них меняется, опять же, да, он
инфраструктурный, он уже написан, и вряд ли кто-то осмелится лезть в такие дебри. Ну, да, в общем-то,
специально написан такой код, чтобы туда как раз не лезть. Да, именно так, так что да, насчет того,
где писать концепты, а где не писать, это всегда вопрос, мы на этом курсе писали их гораздо больше,
чем, вообще говоря, может на практике понадобится, чтобы как-то привыкнуть в любой ситуации,
придумать, как всё-таки это нормально законстрейнить. То есть, бывают какие-то ситуации,
где так сходу и не поймёшь, нужна какая-то практика. Но окей, если ни у кого никаких вопросов нет,
то мы можем заканчивать и расходиться.
