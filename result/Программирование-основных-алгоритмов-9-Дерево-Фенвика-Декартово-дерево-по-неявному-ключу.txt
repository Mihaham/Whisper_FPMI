Так, ну ладно, окей, давайте продолжим. У нас сегодня с вами планы более чем наполеоновские,
я бы сказал. Хочется разобрать целых две структуры данных, успеть за одну лекцию.
Вот если мы успеем, то сегодня мы закончим тогда обработку запросов на отрезках и
пойдем дальше в какую-нибудь степь, скорее всего будет хэштаблица. Так, лекция девять.
Дерево Фенлика.
Собственно, вот это последняя структура, ну предпоследняя. И что мы от нее хотим?
Пусть F. Давайте даже F. Какая она у нас будет? Ну ассоциативная.
Чем еще от нее будем хотеть? Ну мы будем хотеть не обратимости.
Ассоциативная обратимая имеет не тройный элемент, кому-то активность, это стандартные
требования. Вот это вот два главных. Вот тогда назовем деревом Фенлика массив 3,
который по определению имеет вот такой вот вид. Вот видите, F большую мы еще не вводили,
это она вот с этой никак не связана. Так, сейчас. Сумма, то есть у нас F это сумма, а иначе мы будем
делать вот так вот. Вот это у нас вот F от А, F от И, А, F от И, А, И, Т. И, Т. Элемент дерева Фенлика.
Деревом Фенлика будем называть сам массив 3. Теперь, чтобы окончательно вас обескуражить,
я скажу, что такое F от И, F большая. Это вот такая вот странная закорючка, где берут И и плюс 1,
делают побитого И между ними. Ну, давайте я приведу пример. Давайте здесь напишем. Например,
И равно АИТ. Так, например, И равно, давайте какое-нибудь такое число выберем в двоичной
системе счисления. Вот. Ну, что это такое? 0, 1, 2, 3, 4, 5, 32 плюс 7, 39. Тогда И плюс 1,
это будет вот такая вот крокозябра какая-то. 40. Давайте возьмем побитого И. 0, 0, 0, 0, 0, 1, 32.
Так, ладно. Какая-то интересная вещь. Зачем нам нужна обратимость операции? Что, обратимость?
Не так. Давайте я напишу заново определение обратимости. Ну, у нас было на первой лекции.
Будем называть F обратимой, если для любых Х, З существует единственный Y, такой, что F от Х,
Y равно Z. Ну, в частности, для сложения, то есть у вас Х плюс Y равно Z, вы можете написать,
что у вас есть обратная операция, что Y это Z минус X. То есть вы можете однозначно найти,
то есть если вы знаете один аргумент и ответ, вы однозначно можете восстанавливать второй
аргумент. Ну, вот пример необратимых операций. Это минимум. Минимум из 3 и X равен 3. У
СХ может быть любое число, превосходящее 3. Ну или тройка тоже. Вот. Окей, тогда как мы будем
считать F от АЛ того, АР того? Это массивчик наш исходный. Но у нас был какой-то исходный массив,
мы все время хотим отвечать на запросы на подотрески. У нас вот все вот эти лекции,
значит, так стоит. Вот есть массив А, хотим отвечать на подотрески. Вот. F от АЛ, АР. Как-то
понимать можно. Это можно понимать так, что это будто бы какая-то F минус первая, то есть обратная
операция. F от А1, АР, F от А1, АЛ минус 1. Сложно понимаю. Если F это сумма, то сумма от АЛ
до АР, это А1 плюс тра-та-та плюс АР минус А1 плюс тра-та-та АЛ минус 1. Мы вспоминаем префиксные
суммы с первой лекции. Только это они записаны в страшном видео. Вот для этого нам нужна обратимость,
чтобы умели делать вот так вот. Давайте в частности напишем, что сумма пожи от L до R, а житых это
пожи от 1 до R, а житых минус до L минус 1, а житых. Вот. Окей. Оказалось бы, все круто, да?
L минус 1, да. Где L? Это R.
Нет. F минус 1 со двух аргументов. Раз аргумент, два аргумент.
Вот. Окей. То есть получается, что у нас с вами есть. У нас есть с вами это, у нас есть с вами что-то вот
такое вот страшное. Давайте поймем тогда, как считать будто бы код запроса на отрезке.
Давайте сначала научимся считать вот F от тра-та-та. То есть у нас здесь будет
существовать класс Henvick 3. Мы его сегодня будем сами в лекцию писать и дописывать постепенно.
У которого будут какие-то паблик штуки.
Наверное, здесь позволят только объявления. Я буду считать его только для субма.
И мы будем возвращать следующее.
Метод будет константным у нас. Префикс sum от R. Префикс sum от L минус 1.
Вот. Это выражение dF минус 1. Теперь для самой F будем считать.
Давайте сразу напишем функцию update просто.
Напишу объявление, потому что реализация сюда не влезет. Мы сейчас будем приватную часть класса писать.
Где-нибудь потом допишем update потом.
Первым у нас будет вот это вот префикс sum.
Собственно, она будет делать, теперь будет for и больше нуля.
И равно f от i минус 1.
ans 3 it.
Дальше будет return ans.
Вот пока что такой вот код.
Смотрите, что мы делаем.
Вот наш массивчик есть.
Вот есть какой-то индекс i.
Допустим, что f от i где-то здесь.
Но я думаю, не трудно догадаться, что f от i строго меньше i.
Вот это достаточно очевидное неравенство, меньше либо равно.
Чуть позже мы его объясним. Пока что просто уверуем в это.
Тогда дальше вот эта вот часть. Это f от i минус 1. То есть у вас теперь новый индекс.
Вы получаете новое значение f от f от i минус 1.
Отнимаете снова 1, снова прыгаете назад. И рано или поздно вы допрыгаете до нуля.
Таким образом, вот это вот получение префиксной суммы просто очень-очень странным образом.
Ну тогда ответ получается как разность префиксных сумм.
В общем случае, вы здесь просто пишете не плюс равно, а ans равно f от ans запитает 3i.
Если у вас шаблон на f туда передается.
Ну и здесь применяйте f минус 1.
Хорошо. Давайте разберемся с тем, что делает f большая.
Будут идеи у кого, что делает f большая с числом?
Если у вас число заканчивается на ноль, что делает f большая?
Если i делится на 2, то f от i равно i.
Но почему это так?
Потому что у вас i тогда равно 0 в двуичной системе и плюс 1 равно 1 в двуичной системе.
Но берем побитого i, получаем тоже самое, потому что здесь все одинаковое, а здесь 0.
Хорошо. Пускай, пусть i, это будет что-то что-то 0, 1, 1.
Здесь все единицы будут.
То есть это какая-то штука, которая как-то начинается, дальше идет 0 и дальше блок из единиц.
Тогда как выглядит i плюс 1?
Просыпаемся.
Тра-та-та, 1, 0, 0.
Берем побитого i, получаем.
Итого f от i зануляет правый блок из единиц.
Откуда вас следует?
Что у вас при каждом запуске f от i число единичек падает, хорошо, до каждой 2 запуска f от i.
На каждый день даже запуска f от i у вас хотя бы на единицу падает число единицы в двуичной записи числа i.
Возвращаемся к коду запроса.
То есть у вас каждой 2 таких запуска уменьшается хотя бы на единицу число единиц в двуичной записи изначального i.
Откуда вас следует, что этот код работает за логарифом как максимум.
Но на самом деле он пропорционален числу единиц в двуичной записи вашего числа.
Точнее, там немножко другая зависимость.
Но я думаю, идея есть сна.
То есть у вас зависимость не просто от n, а от двуичной записи числа i.
То есть на более точное, более тонкое.
И в среднем гораздо быстрее, чем в дереве отрезков.
Константа у вас будет.
Поэтому если вы интересовались до сих пор вопросом, зачем мы это делаем все,
есть у нас тут и ассоциативность, и обратимость.
А дерево отрезков умеет без обратимости работать.
Во-первых, мы стремимся к тому, что это будет быстро работать.
Быстрее, чем дерево отрезков.
Это первое.
Что?
Ну, конечно, иначе нельзя это применять.
Второе.
Как вы помните, если я подам дереву отрезков массив длиной 2 в степени k плюс 1,
что я должен буду сделать?
Я должен буду его выделить.
То есть как у меня будет эволюционировать размер дерева?
Вот я ему подал вот такое вот для дерева отрезков.
Вы должны будете выделить, дополнить нейтральными, до вот такого вот размера.
Согласны?
А дальше мы это еще с вами превращали в вот такую вот штуку.
Чтобы верхушку дерева написать в массив.
То есть, и того 4 в степени k.
Ой, Господи.
Два степени k плюс два приблизительно.
А вот здесь два степени k.
То есть, приблизительно в 4 раза вы здесь увеличиваете память.
А здесь вам дали ваш массив и вы записали,
можете хоть поверх него вот это дерево написать, массив 3.
Можете отдельно записать.
Он все равно длины n.
То есть, памяти в константу раз меньше.
Это два.
Три.
Ну, давайте посмотрим, сколько строчек у нас заняло код запроса.
Раз, два, три.
Давайте содержательно.
Хорошо, без объявлений.
Раз, два, три, четыре, пять.
Шесть.
Все.
Если вы писали дерево отрезков на семинаре или еще где-то,
вы могли видеть, что там внезапно в 4 раза больше строк.
То есть, пишется это гораздо быстрее.
Вот.
Ладно.
Хорошо.
В итоге умеем.
На текущий момент мы умеем с вами брать стумму на подотрезке.
Ну, какую-то обратимую ассоциативную операцию.
Хорошо, на подотрезке.
Мы не умеем обновлять элементы.
Мы умеем брать эту операцию от логарифма.
Круто.
Мы пришли к успеху.
У нас перфиксная сумма умеет все то же самое,
только за единицу брать результат операции на подотрезке.
Поэтому давайте учиться обновлять элементы.
Вот.
Какую доску можно стереть?
Наверное, эту.
Так.
Давайте я здесь напишу, чтобы мы не забывали с вами,
что f от i.
Вот такая вот.
Теперь страшная.
Я введу функцию g от i.
Обитывая i или i плюс 1.
Зачем нам нужна g?
Мы с вами еще выясним.
Пока что.
До новых встреч.
Давайте я сформулирую страшное утверждение.
Ну и может это сформулировать теоремой.
Теорема.
Даже не так.
Зафиксируем i.
Зафиксируем какое-то число i.
Тогда
все такие
g
что
f от g
вот так вот
то есть что у вас i попадет в этот подотрезок
лежат в множестве
i
g от i
g от g от i
g от g от i
более того
в этом множестве
нет других
элементов.
То есть я утверждаю
что если я буду брать
i
затем от этого числа возьму функцию g
от этого числа снова возьму функцию g
и так далее
то я таким образом переберу все возможные g
для которых выполнено вот это неравенство.
Зачем нам это нужна эта теорема?
А затем что
если мы ее докажем
то как понимать какие у нас
элементы дерева
нашего массива затронулись?
То есть у нас по идее
это была вот такая вот штука
давайте f
f
вот a
f от i
а i
вот
и теперь нам нужно найти
если мы хотим новить элемент
то понятное дело что один элемент
по одному индексу он попадет в несколько таких отрезков
и мы хотим найти все такие
отрезки и поменять
окей?
а вот как их искать
непонятно, вообще не очевидно
какие i у вас попадет
если вы обновите седьмой элемент
они говорят обновите седьмой элемент
тогда какие 3 i
мне придется поменять
вот согласно этой теореме
что это седьмерка, j от семерки
j от j от семерки и так далее
ну здесь пока что
он не определен, в общем случае
мы будем делать пока вот это число не превзойдет
размера массива
вот
ну давайте доказывать теорему
давайте докажем первую часть
что
если
число удовлетворяет такому неравенству
j, то оно лежит
здесь
хорошо
первая часть
ну очевидно
что
очевидно
и подходит
f от i
меньше либо равно i
меньше либо равно i
но это тривиально
ну вот это вот
просто тождественно верно
равенство здесь, а здесь
потому что у вас либо число не меняется
либо у него зануляется блок из единиц
поэтому оно только уменьшаться может
теперь давайте докажем следующее
что
я возьму следующее число
f от
j от i
рассмотрю его
и
рассмотрю его с j от i
вот если это
верно
значит я докажу, что вся вот эта вот огромная цепочка
удовлетворяет неравенству
то есть это как бы база, а это переход
давайте доказывать
и меньше либо равно j от i
ну почему это так?
давайте подумаем, что я делаю от фами j
ну это понятно, что это по битве или
давайте поймем глубинный смысл j от i
ну для этой части это не нужно
для этой части очевидно, что если вы делаете или
с большим числом, то вы не можете себя уменьшить
потому что все что было единицами
у вас останется единицами
а то что было нулями может стать единицами
поэтому это неравенство очевидно
это очевидно, плюс-минус
это очевидно
вот второе
вот эта вот часть, она вообще не очевидная
давайте поймем, что я делаю от j от i
пусть i равно
что-то, что-то, что-то, ноль, что-то, что-то, что-то
а, ну здесь куча единиц
то есть это что-то начинающееся
затем ноль, затем куча единиц
тогда i плюс один
плюс один как устроено?
да
тогда берем побитого или
что я сам получу?
блок из единиц
что?
да
то есть что у меня получилось?
я беру самую правую единицу
самую правую ноль
превращаю его в единицу
то есть у меня i перешел в j от i
то есть что делает функция j?
она берет самое маленькое число
ну самый правый ноль
и превращает его в единицу, все
j от i
превращает
младший ноль
в единицу
я проверял в начале лекции
все были рабочими
но они почему-то умирают, видимо коллективно
как-то
вот
окей
ну давайте тогда поймем, почему это неравенство верное
а случай первый i четная
то есть i заканчивается на ноль
тогда j от i
превратит последний ноль в единицу
согласны?
тогда f от j от i
хотя бы эту единицу в ноль точно превратит
и дальше единицы, которые могли стоять
она тоже могла занудить, если такие были
то есть поэтому f от j от i
если i четная
оно здесь верно
давайте сейчас это напишу на доске
это вот рассуждение
так
рассмотрим i
давайте рассматривать
это что-то что-то что-то
имеющее вид
там допустим
1 ноль заканчивается
тогда j от i
это вот что-то что-то
1 1
f от j от i
заведомо здесь 0 0
вот здесь может быть уже
неравные
но
f от j от i
будет меньше, чем j от i
в любом случае
потому что когда они могут быть неравными
когда у вас здесь была единица
и здесь единица
тогда у вас f от j от i еще и ее съест
то есть мы получили с вами
что если у нас на 1 ноль заканчивается, то все
но аналогично, если мы заканчиваемся
давайте
f от j
да, да, да
правда
хорошо
второй случай
заканчивается на 0 0
двуечной записи
f от j от i
0 1
f от j от i
0 0
что равно i
окей
следующий случай
i равно
0 1
не 0 там
просто что-то что-то
да, j от i
равно
1 0
f от j от i
ой, 1 1, извините
мы правой ноль заменяем
0 0
как видите
f от j от i заведомо меньше, чем i
и все еще будет здесь
здесь ситуация та же самая
что если у вас здесь были единицы
то f от j от i еще и ее съест сверху
третий случай
когда вы на 1 1 заканчиваетесь
его понятно как анализировать
его анализировать надо так
когда вы заканчиваетесь на блок из единиц
в частности 1 1 сюда подойдет
когда j от i
это
а f от j от i
это
это
это
это
это
а f от j от i
вы просто
убиваете младший блок из единиц вообще целиком
ну понятно
что это вообще строго меньше, чем i
ну все, мы распространили все возможности в лучшем, доказали
доказали
что
f от
j от i
не превосходит i
не превосходит j от i
ну все
победа
эта часть мы доказали
что все такие
j от множества
то есть
все
такие j
что
f от j
и меньше, чем j
и не так
мы доказали с вами, что
все элементы множества
удовлетворяют нашему
так
что
j лежит
в множестве
j от i
tra ta ta
что
удовлетворяют
f от
j
меньше его равно i
меньше его, чем j
вот это мы сами доказали
то есть мы доказали, что
если я возьму элементы отсюда
то он под неравенство подойдет
теперь я хочу доказать обратную сторону
что если я возьму элементы не отсюда
то он под неравенство не подойдет
тогда я докажу, что эти множества совпадают
ой, ну как доказывать обратную сторону
здесь я воспользуюсь
немножко записями
чтобы было проще
докажем
что
если
j
не лежит в этом множестве
то
неверно
что
f от
j
докажем
что это неравенство неверно
хорошо
пусть
k не принадлежит
этому множеству
но при этом
f от k
меньше либо равно k
предположим, что
у нас нашлось такое k
что оно действительно не из этого множества
и для него верно неравенство
в частности, из вот этой вот части
из вот второй
и меньше либо равно k
следует, что
что мы можем записать их
следующим образом
ну очень хорошо
случай первый
и равно k
понятное дело, что мы его рассмотрели
поэтому такого быть не может
и равно k
противоречие
назовем так
значит и меньше k
тогда вот такой формат
у нас есть
то есть есть какой-то разряд
где здесь написано 0, здесь написано 1
хорошо
возьмем и штрих
то есть мы отсекаем
вот этот вот префикс
этот префикс, этот первый многоточий
мы его отсекаем
но что мы с вами видим
мы утверждаем, что k
не лежит в этом множестве
а что у нас с вами делала
функция g
она берет 0 и постепенно превращает в единицы
начиная с самого правого
согласны?
но функция g
делает
0
единицу
тогда
как должны быть устроены и штрих, и k-штрих
а k-штрих
здесь 1
здесь 0
если бы это было не так
то есть у нас не существовала бы позиции
где здесь 1, а где здесь 0
это значит, что
какие у нас переходы может быть g
вот в конкретном разряде g что может сделать
она может 0 в 1
1 в 1
ну и там 0 не трогать, например
мы убрали вот префикс этот
первый многоточий убрали
и все, получили такие части
будто бы взяли по модулю
или сдвинули
здесь?
смотрите
еще раз
если к
не могло быть получено
вот таким вот образом
мы должны тогда понять, что у нас должно быть
и та к единица
которая в к на соответствующем месте дает 0
тогда к не может быть получено
из и такой операции
иначе, как бы вы не пытались
вы можете получить k
ну почему?
потому что если у вас 0
0
это окей
типа если у вас здесь 0 и здесь 0
то окей, без проблем
хорошо, если у вас здесь 1 и здесь 1
то тоже без проблем
1 в 1 перейдет под действием g
и все будет нормально
дальше
0 в 1
ну да, вы следовательно применяя
функцию jack и превратите
0 в единичку на этой позиции
но вот единичку в 0
вы никогда не превратите с помощью функции g
то есть применяя функцию g к числу вот здесь
у вас никогда
0 не встанет на этой позиции
как бы вы же не применяли
потому что g уважает единицу
у вас была единица, она останется единицей
был 0, он станет единицей
но единица 0 никогда не станет
окей, тогда мы получаем, что у нас
вот такой вид
но осталась последняя
рассмотрим f от k'
как вы думаете, чему равно f от k'?
f от k'
не
занулит
левую
единицу
то есть f от k'
не может никак в эту единицу
превратить в 0
согласны?
потому что у вас здесь банально есть 0
она бы с этим бы нулем сначала разбиралась
но из этого следует
что f от k'
строго больше
чем и штрих
потому что
если вы f от k' применять
у вас здесь все равно останется 1, а здесь все равно 0
а из этого следует
что f от k'
больше
чем и
противоречие
доказали
что если число
не было получено
таким вот применением g
то оно не будет подходить
под вот это неравенство
тирем доказано
тезис
на что именно?
мы доказали
что
в чем была глубинная идея
и с чем мы вообще хотим добиться
мы с вами говорили, что
мы умеем с вами брать get some
но мы не умеем делать update
потому что непонятно
что если я скажу поменяй мне
житый элемент на такой-то
какие 3 it
будут таковы, что
они будут лежать внутри этого множества
не очевидно
то есть нам непонятно
какие g нам надо будет поменять в случае апдейта
этого элемента
это все такие g
что выполнено вот это неравенство
если мы меняем it
и теперь мы доказываем
что все такие g получаются
последовательным применением кучи раз функций g
и доказываем, что других быть не может
тогда update ведется к тому
что мы просто будем брать g
поменять индексы, менять элемент
это все, что мы будем делать
ну и дальше что мы делаем
мы доказываем две части
первая часть, что
эти числа отсюда
удовлетворяет это неравенство
доказали каким образом
посмотрели, что для i подходит
применили переход функций g
то есть база i подошла
переход функций g подошло, все
доказываем в обратную сторону
что никаких других чисел быть не может
удовлетворяющих нашему двойному неравенству
действуем от противного
предполагаем, что такое возможно
то есть найдется такой g
не лежащий в этом множестве
такой каточнее
но при этом верно такое неравенство
ну и теперь мы просто рассмотрели конструктивно
и пришли к подтвердить, что такого быть не может
просто играли с двуичной записью
ну по приколу, чтобы не мучиться
с этими префиксами
можно без них побойтись
ну просто как-то
писать многоточие здесь еще несколько раз
было бы неприятно
возможно еще раз
когда мы говорим, что g у нас
ну короче, g не сделает левишки и кастрюли
все просто по-всему
почему у нас это не сделает
если у нас была куча нулей
ну типа
тогда они не различаются вообще
в этой позиции
мы должны рассматривать позиции, где они разные
если у вас 0 в 1
легко перейдет, а вот 1 в 0 никогда
а если у вас одинаковые
на этой позиции были, то че их рассматривать
там не интересно
если они не найдутся
да
ну это правда
на самом деле, да
кастрих нуля достаточно
ну да, действительно
да, вам достаточно, чтобы в кастрих
нашелся 0
чтобы вы не могли
из иштрих, как бы вы не пытались
да, действительно, здесь вы правы
здесь можно любое число поставить
главное, чтобы в кастрих 0 нашелся
тогда вы
не превратите
последовательно при мне иштрих
в 0 ничего
в ноль
иштрих
последовательно применяя иштрих
в ноль ничего не превратите
применяя ж иштрих кучу раз
у вас здесь станет единица рано или поздно
а здесь у вас ноль
да, спасибо
ну доказали, в общем-то
ну если его нет
если здесь все единица
из такой позиции нет
если применяю функцию ж, вы здесь все в единицу превратите
и значит вы станете равным
кастрих
а вы хотите доказать, что такого быть не может
потому что у вас кастрих заведомо
берется такое, что оно не может быть
таким образом получено
потому что у вас ка не лежит в этом множестве
просто
ладно, давайте
сделаем проще, избавимся от иштрих кастрих
и штрих
я понял
и равно
ноль, ка равно
один
все
f от k не нулит левую единицу
f от k больше и
ну
избавились от лишних сущностей
так понятно
почему здесь не может быть единицу
ну примените f от k хорошо
f от k
если у вас вы находите
на ноль
смотри, f от k, оно что делает
то у вас блок из единицы только здесь может быть
у вас ноль
у вас ноль ограждает специально
для этого он нам нужен
то он вообще ничего не сделает
с числом
мы здесь специально поставили ноль
чтобы оградить эту единицу
если вы в шахматы играли
чтобы спасти короля
вы ставите фигурку между нападающей фигурой
и королем
вы ставите ноль специально
как защиту
от действия функциев
что?
не понял
справа от нуля
не обязательно
мы просто сказали, что должен быть какой-то ноль
для определенности
это самый правый ноль
и здесь действительно блок из единиц
но это не принципиально, вам главное чтобы какой-то ноль нашелся
окей
давайте так скажем для определенности
если у вас здесь все единицы
то у вас f от k
превращает эту штуку в нули
это плохо
нет, смотрите еще раз
у вас не может быть здесь все единицы
просто по определению
того, что k
не лежит в этом множестве
потому что если бы здесь
были бы все единицы, то k могло бы быть получено
из и такими операциями
такими операциями
что?
такими операциями
так
давайте мы закончим код наконец-то
раз мы доказали теорему
мы можем дерево дописать
а именно мы сделаем следующее
вызовем функцию
update
delta от
по индексу
и
сейчас
val
minus aity
то есть это delta, на который вам надо
увеличить значение все
то есть у вас был aity
стал value
то есть вы берете их разность, это значит вашу delta
на которую надо ее изменить
говорите, что aity равно
val
и код закончен в общем-то
осталось update delta
она будет написана на той доске
что будет делать update delta
она будет делать следующее
for
i
меньше n
i равно
g большая от i
и
и
3
и ты
плюс равно delta
поймаю шок
если что классно писан
закончили
гробовая тишина
update delta
смотрите
что значит обновить сумму
на подотрезке
вы уберете эту сумму
и прибавляете к ней разность
между тем элементом, который был
и который стал
получается да
храним массив i и храним массив 3
и
и
и
и
и
ты хочешь обновить дерево
обновляй
на такую delta
и дальше скажи, что aity
равно val
а вот это мы сейчас еще обсудим
это один из вариантов
но мы посмотрим быстрее
ой ну да
да да да
индекс да
индекс да
не в update delta, я здесь i принимаю
я
себя жить проще сделал
да да да да
а здесь
все
ну
надо было просто int и
оставить и все
смотрите
я написал там int и dx в аргументах
а здесь int и
а потом везде написал
здесь и и там и
мне сказали, что я максимально некорректен
и вообще нарушаю все заповеди
потому что у меня здесь были
и здесь и
и компилятор не скомпилировал в голове у зрителей
вот поэтому пришлось и dx везде
дописать, чтобы скомпилировалось
наконец
обратную функцию берете
у нас была f попротива
минус это обратная для плюса
как будто бы
бинго
мы об этом говорили минут 40 назад
с этим мы разобрались
теперь время осознать почему это дерево
да
дельта
переменная дельта
ок
смотрите
честно не очень хочу вам раскрывать эту тайну
это хорошо просто на экзамен
в общем это дерево
давайте рассмотрим массивы
моментов
давайте пока из восьми
посмотрим что будет
f от нуля чему равно?
ноль
f от единицы чему равно?
ноль
f от двойки чему равно?
ноль
f от тройки чему равно?
ноль
f от четырки
это четверка
f от пятерки
четверка
f от шестерки
f от шестерки
шесть
f от семерки
ноль
то есть здесь длина
два в нулевой
два в первой
два во второй, два в третий
в третьей
когда вы спрашиваете в семерке
у вас ответ это вот такой отрезок
и у вас есть деление пополам
от тройки
на этом под отрезке есть деление
пополам
и на этом под отрезке пополам есть
вот этот
это дерево отрезков
без правого сына
в каждом узле
То есть если вы рассматриваете, будто бы, это узел и контролируем его под отрезок, то это будто бы у вас только левая часть дерева отрезков есть.
Поэтому это дерево.
Потому что это дерево отрезков без правого сына.
Смотрите, у вас будто бы действительно есть везде деление пополам, как было в дереве отрезков.
Дерево отрезков убрали огромной массив, делили его пополам и рекурсивно строили вашу структуру.
Здесь же вы делите пополам, но рекурсивно строите будто бы только для левой половины.
Это отрезочки от F от И до И.
Это краски-отрезочки, которые три с И контролируют.
Дерево отрезков у вас была структура такая, что есть один массив, есть две половинки, дальше, не знаю, как там дальше у счет древних русов идет, потом однушки, у вас их 8 штук.
Вот это дерево отрезков.
А теперь вы сделали все то же самое, только у всех узлов уничтожили правого сына.
То есть у этого теперь нет правого сына, у этого нет правого сына, у этого нет правого сына, у этого вообще нет, потому что он правый сын этого, которого нет.
Но этой информации достаточно, чтобы отвечать на запросах на префиксах.
Ну смотри, я брал И, я считал F от И, а дальше брал и отрезочки рисовал.
Вот отрезочек длины 1, 2 в 1 СО на 0 уровень, отрезочек длины 2, 2 в 1 СО на 2 уровень и так далее.
Лучилось такое дерево холостное.
Ручками.
Ну в плане, ну есть два варианта построения, сейчас мы до этого доберемся.
Огрессивно построение.
Так, ну первый способ, он максимально наивный.
Давайте, построение.
А, ну да, я надеюсь понятно теперь, почему апдейты и запросы работают за O от log M.
Ну да, потому что длина двуечной записи это логарифм.
А теперь, построение.
За O от log M.
За O от log M.
M раз апдейт.
Легендарное построение.
Второе, за O от M.
Нейтрально.
Мы же сговорились с вами на прошлой лекции, что, что они нейтральны, это такое странное требование, что можно просто создать костыль в виде опшенного, что если нет значения, пиши туда просто число.
Ну все, поэтому мы как бы не требуем будто бы.
Ну потому что чисто алгебраически иногда надо просто сказать и все, чтобы формально было все соблюдено.
Мы договорились в прошлый раз, что не надо.
За O от M.
Строим массив префиксных сумм.
Далее по определению.
Все.
Ну или же преф, и ты минус преф.
Все.
Это построение феновика за линию.
Да.
Да, это да.
Окей.
Окей, мы с вами обсудили, что у нас памяти в два раза меньше и во времени быстрее.
В среднем два раза запросы будут делаться.
Но мы с вами не обсудили главное, зачем мы это сидели.
А именно такая классная вещь, как...
Она будет вот так вот.
Да.
Да.
Да.
Да.
Да.
Да.
Да.
Да.
Да.
Да.
Два-три-дерево.
Что?
Нет.
Есть такое интересное утверждение, что K-мерное дерево феновика пишется в K плюс 1 строку.
Вот.
Мы сейчас поймем, что это значит.
Ведем такую, что 3 с и 3...
Или 3 у нас было 3, просто.
по u f от i до i, по v f от j до j, а u ты в этой, тогда как считать сумму на подпрямоугольнике каком-то?
Мы умеем считать сами сумму на префиксных прямоугольниках на самом деле.
То есть мы с вами умеем спрашивать сумму от прямоугольников, в которых вот один угол включен вот так вот.
То есть для каких мы умеем узнавать ответ?
Да, формула включения и исключения называется.
То есть вы умеете отвечать для префиксов аналогично. Как написать в двумерном случае?
Делается следующее.
Все, это апдейт.
Я же сказал, камерное дерево Хенрика пишется в каплю с одну строчку.
Каплю с одну, только если вы фигурные скобочки не ставите, пишете как олимпиадники,
типа у вас будет фор без фигурных скобочек, фор, фор, фор и выражение.
Здесь также фор j больше 0, j равно f от j минус 1, 3 и ты, j ты, конец.
А теперь представьте, что такое двумерное дерево отрезков.
Это дерево отрезков, деревьев отрезков.
В прошлом году я пытался это объяснять, было очень плохо.
В этом году мы не будем это пытаться делать.
Единственная проблема в этом все, это то, что у вас здесь будет, все-таки префикс сам-то двумерный,
поэтому давайте его обозначу как L1, R1, L2, R2, то есть первое измерение, второе измерение, лево-право, лево-право.
Тогда анс у вас будет выражаться так, преф от R2, L2 минус преф от R1, L2 минус преф от...
Что я делаю вообще? L2, R2, L1, R2, L2, R1 плюс преф от L1, R1.
Да, это будет домашкой на ревью требования, написать шаблон новокомерного Фенрика.
У вас же есть плюсы, шаблон уже прошли на плюсах, да? Это обман, я знаю, что прошли.
Ладно, шучу, это не будет в требованиях, но будет классно, если кто-то все-таки напишет такую штуку.
В контесте будет трехмерный Фенрик. Нет, надо будет написать просто трехмерного Фенрика.
Ну да, действительно, надо еще две прибавить в каждое место.
Самое сложное в трехмерном Фенрике это написать формулу включения-всключения, как я выяснил, по опыту.
Ой, я вас обманул. Знаете, почему я вас обманул?
Думаю, что у вас здесь минус один, должно быть.
Вот, теперь верно.
То есть какое здесь правило?
Что вы берете самое большее, затем выписываете с минусом все те, у которых один из индексов становится на единичку меньше.
То есть у вас было бы два-два, здесь у вас всего лишь один из индексов стал на единичку меньше, поэтому вы их с минусом выписываете.
А здесь у вас изменилось два, поэтому с плюсом.
Там, где единички теперь у вас стоят, там вы должны минус один везде делать, чтобы они были не включительны.
Если вы это напишете, вот сюда вот, вместо этого.
Здесь вот мы дописали фор новый, и там дописали фор второй. Все, это двумерный фенвик.
Трехмерный фенвик это написать в два раза большую формулу здесь, написать еще по одному фору здесь и там, и победить.
Окей, кто-то тебе вдруг захочет считать сумму на подматрицу.
Камерное зачем, я не знаю. Вдруг тебе кто-то захочет сумму на подматрицах считать?
Мы этим занимаемся всю лекцию.
Это разрывный, конечно, вопрос.
Ладно, давайте подумаем про сложность. Память, понятно, до памяти от mm у вас требуется, если здесь m, здесь m.
Время работы, log m, log m.
Так, кстати, вопрос со звездочкой, за сколько работает GetSum и XLSK мер на дерево фенвика, и все измерения равны m.
Ну подумайте. Это такой вопрос такой хитрый, он сравнивается с подвохом.
Ладно, про дерево фенвика закончили. Поехали последнее, можно сделать.
Последняя структура это декартово дерево по неявному ключу.
Дерево по неявному ключу.
Идея следующая.
Помните, у нас когда-то было давным-давно декартово дерево?
И как мы сами выяснили, что если выписать в порядке обхода декартового дерева, то у вас по ключам будет отсортированный массив.
Ну inorder обход, получается отсортированный массив.
Идея следующая.
Давайте хранить вместо ключей индексы от 0 до n-1.
Храним вместо ключей индексы n-1.
Будем хранить также элемент и приоритет.
То есть надо будет хранить себе ключ в виде индекса, сам элемент аиты и приоритет для балансировки дерева.
Что теперь давайте осознаем?
Осознаем, что по сути мы получили с вами массив в форме дерева.
Пока не понятно вообще, зачем нам это надо, но потихонечку мы к этому придем.
Тогда вопрос, что такое сплит в таком массиве?
Сплит у нас был раньше по ключу, да?
Давайте теперь делать сплит по ключу, действительно, ind key.
В смысле? Нет, сплит у вас делил дерево на два.
В одном все ключи меньше, в другом все ключи больше.
Теперь вы можете это...
То есть будто бы вы умеете делать сплит по индексам, на самом деле.
То есть вы говорите, у вас был массив, вы взяли и рассекли пополам,
получили разделение массива где-то посредине за логарифом.
Ну уже неплохо.
Следующая идея. Что делал мерч?
Ладно, пока что не будем про мерч.
В чем проблема?
Казалось бы, все круто, да? В чем проблема?
Нет, не проблема, это потом спускаемся по дереву и побеждаем.
Это вообще не проблема. Проблема в следующем, что...
Если вы считали массив ваш, вот ваши ключи,
то будто бы это два независимых массива теперь.
Здесь были индексы 0, и...
Ну ладно, здесь и-1.
Давайте ключ К, К-1.
То есть здесь у вас индексация будто бы хранится такая,
а здесь у вас К, Н-1.
Ну раз это два независимых массива, наверное я хочу здесь индексацию сделать.
Согласны?
Окей. Ну тогда же мне придется за линию пройтись по дереву и переписать индексы.
Нет.
Вспомним, как мы искали кату порядковую статистику.
Мы смотрели, сколько элементов влево под дереве.
Если меньше, то шли в него, если равно, то останавливались.
Если больше, то шли вправо.
То есть нам достаточно было размера левого под дерево.
А катая порядка в этом массиве таком, это что?
Это катый элемент массива.
Ну тогда давайте хранить неявный ключ.
Неявный ключ – это размер левого под дерево.
Тогда с помощью него я могу четко получать элемент по индексу.
Действовать будто бы это катая порядковая.
А если я храню только это, то есть я не храню только это.
А если я храню только это, то есть я не храню индекс теперь.
Все, он мне не нужен.
При необходимости я смогу восстановить индекс с помощью этой информации.
То есть по индексу я смогу найти элемент.
С помощью этой информации, не храня явно индексы вообще.
Ну тогда если я не храню явно индексы, у меня нет этой явной индексации.
И у меня эта проблема исчезает сама собой, что мне нужно здесь переиндексировать.
Я вообще не храню индексы.
Не вообще по барабану, что там происходит. Ребят, вы поймите это.
Я просто знаю, что у меня в левом по дереве столько-то элементов. Все.
Вообще все.
Что там в правом цене происходит вообще не волнует.
В каждом узле размер левого по дереву – все.
Мы умеем четко понимать тогда, нужно ли нам, если я хочу этот элемент по индексу получить, идти ли мне влево или вправо.
То есть смотрите, что я научился делать.
Я научился с вами делать сплит.
То есть разбивать массив на два.
Дологарифум, не сбивая индексации.
Просто потому что ее нет.
Грустные ситуации.
Этот И равносильно ИТ порядковое.
Сплит.
Разделение посередине.
Теперь время мерджа.
Что делал мердж? Как он работал?
Вы ему подавали два дерева.
В Т1 ключи были строго меньше, чем ключи в Т2.
Помните такое?
И дальше сравнивал только по приоритетам.
Я ключа вообще никак не дозрадил в мерджу.
Я делал, что если у меня приоритет корня левого дерева меньше, чем второго, то тогда этот корень будет корнем итогового дерева.
И дальше мердж снова вызывал.
Все, это все, что я делал.
А теперь...
Смотрите, у нас нет ключей.
Мы код мерджа не меняем.
Он как верил, что ключи были поданы ему в соотношении одни меньше второго,
в соотношении одни меньше второго.
Так и будет верить.
Но у нас вообще нет ключей.
Мердж смотрит только на приоритеты и все.
То есть он берет два массива,
А, Б,
и превратит его вам в конкатинацию двух массивов.
И будто бы, у нас действительно, будто бы здесь есть индексация какая-то,
но ее здесь нет.
И мердж работает.
Здесь такая вот неявная идея,
просто два дерева с мерджа без ключей
превращают в конкатинацию массивов.
Масивов.
Вспомните, что мы с вами в дикартом дереве делали с помощью сприта и мерджа?
Инсерт и рейс.
То есть мы с вами научились взять и вставку в середину массива делать за логарифум,
удаление из середины массива за логарифум.
Пожертвовал в тока одной операции.
Гет.
То есть теперь у вас АИ, ты квадратные скобочки,
за логарифм лишь работает, все.
Но зато вы избавились от линейной вставки,
линейного удаления,
чего-то там еще.
Нет никаких амортизированных оценок
для вставки в конец.
Все за логарифм.
Жизнь прекрасна.
Теперь pushback это просто
сделать мердж с новым чуваком в конце.
Popback это просто отсеки
по размеру массива минус один.
Вообще.
Гениальная вещь.
Получи по индексу это,
верни и ту порядку в этом дереве.
Конечно.
Мы же хотим глубину поддерживать плюс-минус логарифм.
Окей.
Нет.
Мердж как раз такой приоритет и смотрит.
И по ним делает дерево.
Нет.
Это под ключи было.
Мердж смотрит какой приоритет
и, соответственно, то дерево,
корень того дерева будет корнем итогового дерева.
Все.
Вообще.
Нет. У нас нет ключа.
У нас вместо ключа хранится неявный ключ.
Размер левого под дерево. Все.
Это информационным более чем достаточно.
Нет.
Вы ему даете индекс, по которому я хочу засплитить.
Разбить на два.
Вот у меня есть массив.
1, 2, 3, 4, 5.
Я говорю по сплит по третьему индексу.
Он такой окей.
Левый массив 1, 2, 3, правый массив 4, 5. Все.
Хорошо. В массиве 6, 7, 8, 9, 10.
Я говорю по тройке засплит.
6, 7, 8 это одно.
9, 10 это другое.
Окей.
Абсолютно так же.
Только вы смотрите, правда ли, что
в левом под дерево меньше к или больше к.
Все.
Это будет на семинаре вы напишете код подробнее.
Зачем? Вам достаточно знать размер
под дерево левого.
Тогда вы будете понимать, нужно ли вам идти влево
или вправо. Все.
Каминус размер левого под дерево,
если вправо пойдете.
По размеру левого под дерево поймешь.
Это как в кат и порядковый.
Ты в кат и порядковый?
Ты в кат и порядковый?
Тебе вообще не важно, что происходит в правом под дереве.
К передаешь.
Число элементов, сколько у тебя
будет в левом массиве.
Хорошо. Окей. Что я еще умею делать?
Ну, с помощью сплитов
я умею посплитить
и перенести тут сюда.
То есть делать циклический сдвиг
на к вообще могу.
Просто так за логарифом.
Давайте больше трюков.
Так, у нас с вами 20 минут еще
до конца перерыва.
Подождите, мы еще не закончили магию.
Мы только начали.
Нет, это халява.
Давайте вспомним,
что дерево отрезков
у нас хранило результат
операции в под дерево.
А здесь мы можем будто бы
и мы там должны были хранить
для запроса на подотрески
индексы, в которых мы находимся.
Тогда правда ли,
что размера левого под дерево
мне более чем достаточно,
чтобы понимать, какие
индексы у меня здесь, а какие здесь
при рекурсивных вызовах?
Тогда я же могу
реализовать логику дерева отрезков.
То есть для хранить результат
операции на подотреске.
То есть я получил быстрый массив, который
умеет делать вставки в середину, удаления в середину.
И он умеет теперь делать все то же самое,
что умело делать
дерево отрезков.
То есть я умею
брать операции,
уровня, сделать
циклический сдвиг нога, посчитать
сумму на подотреске.
Вот, это краски квинтэссенции
того, что мы с вами делали
половину семестра.
Ну треть семестра, хорошо.
Мы изучали вот эти вот структуры для работы
на сотресками и изучали деревья поиска.
Окей, зачем нужно было
делать сплит дерева?
Оно тоже умеет делать сплит мерш
и тоже за логарифом.
И, возможно, вам
понравится более сплит дерева по неявному ключу,
чем декартовое дерево по неявному ключу.
Ведь, по сути, что мы хотим
уметь делать? Мы лишь хотим
уметь делать, чтобы наше дерево делало сплит и мерш.
Это все, что требуется нам.
Потому что мы с вами доказали, что через сплит и мерш
можно выразить все остальные операции.
То есть инсерт и рейс и так далее.
И здесь, по сути, мы только ими и пользуемся.
Так же сплит дерева,
только через сплит вы можете вообще
все это выразить.
Это достаточно одной операции сплит,
чтобы за логарифом делать кучу этих запросов.
Просто подумайте, насколько это концептуально вообще.
Окей.
Ну, что можно здесь сказать на этом?
Ну, на этом еще можно сказать следующее.
Тут вот с первых рядов заявляли про переворот под отрезка.
Разворот под отрезка.
Я сказал, что мы можем реализовывать всю логику дерева отрезка,
включая массовые операции, проталкивания и так далее.
Для разворота под отрезка можно придумать
проталкивания.
Почему вы на меня так смотрите?
Вот у вас есть отрезок.
Вам сказали, я хочу этот под отрезок развернуть
в цель по Р.
Я знаю, что у меня в текущем узле
он бьется на под отрезки
LM и MR.
Окей.
Как тогда развернуть LR?
LR.
Шаг первый.
Развернуть
LM.
Шаг второй.
Развернуть
MR.
Шаг третий.
Поменять
детей местами.
Все.
Я теперь
проталкиваю флаг.
Операция push состоит
из проталкивания флага.
Через XOR равно,
потому что у меня на бок уже стоит флаг,
что нужно развернуть под отрезок.
И дальше просто свапнуть детей местами
в конце push.
Я с вами научился за логарифом переворачивать под отрезок.
А теперь тогда несложно понять,
как делать операцию
next permutation на под отрезке.
То есть построить следующую дексографическую
перестановку на под отрезке.
С помощью этих двух операций,
с помощью циклического сдвига на K,
с помощью разворота на под отрезке,
ее можно организовать.
Но это у вас звездочка в терках.
Это вот вершина
вообще всего всей этой науки.
Вот. Такая вот классная идея.
И мы закончили на этом лекцию.
