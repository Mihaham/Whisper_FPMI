Так, давайте начинать. Мы сегодня поговорим про просочетание, в частности, в
двудольных графах. Давайте сразу начинать. Во-первых, что такое двудольный граф?
Интуитивно это такой неориентированный граф, в котором все вершины можно разбить на две группы,
левую и правую, таким образом, что ребра будут только между группами. Внутри группы ребра не
может быть, а могут быть только между группами. То есть все вершины можно разбить на два множества.
Такие, что ребра у меня находятся только вот между группами. Не может быть ребер внутри R,
не может быть ребер внутри L, могут быть только между ними. Ну, значит, двудольный граф это такой
граф, на что существует какие-то множества LR, такие, что V представляется в виде дезинктного
объединения LR, да, ну и, соответственно, каждое ребро одним из концов лежит в L, другим лежит в R.
Один из концов, концов E в L, другой в R. Вот. Ну, альтернативно, да, альтернативно можно было
бы сказать, что двудольный граф это то же самое, что граф с хроматическим числом не больше, чем два.
Ну, потому что как раз хроматическое число не больше, чем два, значит, можно весь граф разбить
на не более, чем два независимых множества. На вот как раз L это независимое множество и R это
независимое множество. Так что ребра только между ними, но не внутри самих этих множеств.
Да, понятно? Вот. Ну, сегодня мы будем работать в основном только с двудольными,
но вообще говоря, понятие по рассчитанию определяется в произвольном графе. Значит,
определение пусть G это какой-то граф, пусть M это какое-то подношство его ребер,
значит, тогда M называется по рассочетаниям. Я, возможно, для краткости буду говорить или
писать по рассочам, чтобы меньше букв писать. По рассочетаниям, если, если ребра из M попарно
дезюмпны, то есть любые два ребра не имеют общих концов, то есть не бывает вот таких вот картинок,
когда когда два ребра имеют зацеплены по вершине, любые два ребра, они именно что вообще не
пересекаются, у них нет общих концов. Значит, если, напишу так, никакие два ребра из M не имеют
общих концов. Да, ну то есть скажем вот такой вот набор ребер, это просочетания, вот ребро,
вот ребро и вот ребро, они хоть они на рисунке пересекаются, но по концам они не пересекаются,
у них нет общих концов. Значит, это просочь, а например, что-нибудь вот такое, это уже не просочь,
потому что вот эти два ребра пересекаются по вершинке, это уже не просочетание. Ну и задача,
которую мы будем решать, следующая, надо найти просочетание максимального размера в вдольном
графе. Задача найти просочетание максимального размера, то есть с наибольшим количеством
ребер в вдвудольном графе. Вот, значит, повторюсь, вообще говоря, эту задачу можно также за
полидональное время решать и в обычном, в произвольном, неориентированном графе,
не обязательно вдвудольном, но там более сложный алгоритм, мы, наверное, его не будем рассматривать,
ну может быть, но не факт. Вот, мы концентрируемся на специфическом случае, когда граф,
который мы рассматриваем вдвудольный, вот именно в вдвудольном нам надо найти максимальное
просочетание. Вот, ну зачем это может быть нужно? Самый такой фольклорный пример, это вот представьте,
у вас есть такой вдвудольный граф, есть так называемая задача на значениях. Значит,
представьте, что у вас есть n человек и n каких-нибудь, ну там, заданий, и вам нужно
распределить, какой человек делает какое задание, так чтобы каждое задание кем-то делалось,
но при этом, ну как бы, никакой человек не делал два задания. То есть в этом смысле вам нужно как
раз найти перестановку, ну биекцию, по факту, между людьми и заданиями, это в точности по
просочетанию. То есть вы говорите, что этот человек делает это задание, этот вот это,
а этот вот этот и так далее. То есть это взаимнооднозначное соответствие между вершинами
левой и правой долей, то есть это как раз просочетание, что никакие два ребра не пересекаются,
они зацеплены. Ну вот. Ну вот, что-то такое нам надо сделать. В термах этой задачи, там некоторые
люди умеют делать некоторые задания, надо выбрать какое-то просочетание, так чтобы как можно
больше заданий было выполнено. То есть как раз парсуще максимального размера.
Вот. Так, ну хорошо. Значит, у нас, на самом деле, алгоритм, который будет искать
максимальное просочетание, он будет такой очень жадный, ну и довольно наивный. Он
будет делать примерно следующее. Вот он имеет какой-то двудольный граф, в нём уже
построено какое-то просочетание, ну найдено там несколько образующих
просочетания. Он будет пытаться это просочетание увеличивать итеративно, будет
пытаться добавлять к нему какое-нибудь новое ребро. Ну, например, представьте, что
у вас есть какое-нибудь вот такое просочетание. Давайте сплошными ребрами я
сейчас изображаю ребра просочетания, а пунктирными я изображу просто ребра,
которые ещё, в принципе, есть в графе.
Сплошные ребра это ребра парсоча, пунктирные это как бы не использованные
ребра, которые есть в графе, но не использованы в парсочи. Вот. Тогда, ну видно, что,
вот, например, вдоль вот этого пути, который чередуется как раз пунктирные
сплошные ребра, можно выполнить чередование. То есть можно, наоборот, взять в
парсочи все неиспользованные ребра на этом пути и удалить все использованные.
То есть я просто давайте поменяю типы ребер на всем этом пути. У меня тогда вот это
ребро попадет в парсочетание, это будет из него удалено, но останется в графе.
Дальше я беру вот это ребро, удаляю вот это, беру вот это. Ну, собственно, я произвел
чередование на чередование. Ну и видно, что размер парсочи не увеличился. У меня
было два ребра в парсочи, стало три. Ну и давайте вот так вот и будем делать. То
есть у нас будет более-менее одна простая операция увеличения парсочетания. Это
выбор какого-то вот такого вот пути, на котором типы ребер чередуются, ну и
собственно, чередование вдоль него. Тогда у меня как раз, ну вот в этом случае у меня
два ребра удаляется из парсочи, а три добавляется, соответственно, размер
увеличивается на единичку. Вот. Но это будет наша элементарная операция, с
помощью которой мы и будем искать максимальное парсочетание. Давайте я
формально определю, что мне нужно от этой картинки, чтобы можно было
осуществлять чередование. Так, для этого еще одно вспомогательное пределение в
виду. Значит, пусть M это парсочетание.
Значит, тогда у меня все вершины поделятся на два типа, насыщенные и
не насыщенные. Насыщенные это те, которые являются концами хотя бы одного из
ребер. То есть, вот эти вот вершинки будут насыщенные, а все остальные не
насыщенные. Ну, интуитивно, очень просто. Как бы насыщенный парсочетанием
используется лифт парсочетания данной вершины.
Значит, тогда вершина V называется насыщенной, если она является концом одного
из ребер про сочетания.
Но в противном случае вершина называется ненасыщенной, если она ни в каком
ребере не задействована, как вот эти вершинки, которые никак в парсочи не
участвуют. Они, соответственно, не насыщенные. Так, хорошо. Ну и теперь, наконец, я
могу определить, что такое величающий путь. Опять-таки, пусть M это какое-то
парсочетание. Пусть P это какой-то путь в графе G.
Значит, тогда P называется увеличивающим относительно M, если выполнено сразу
следующие все условия. Значит, во-первых, путь достаточно длинный, а именно в нем
есть хотя бы одно ребро. Ну я напишу это так, что длина P хотя бы один. И
подразумеваю, что длину пути я измеряю в количестве ребер. Во-вторых, смотрите,
что мне вот здесь было важно? Мне важно, чтобы концы пути были ненасыщенные. Мне
важно, чтобы первые и последние вершины пути были именно, что вообще никак не
задействованы в парсочетании, чтобы я имел возможность к ним вот эти вот ребра
подсоединить. Вот это ребро и вот это ребро. Чтобы их можно было добавить в
парсоч, мне нужно, чтобы крайние вершины были изначально ненасыщенные. Ну
соответственно, второе требование, концы P ненасыщены относительно пространя M.
И третье, это собственно то, что вдоль пути можно сделать чередование,
то есть что типа ребра чередуются. А именно, что первое ребро на пути не лежит в M,
второе лежит в M, третье не лежит в M, четвертое лежит в M и так далее. То есть типа ребер
в P чередуются. Сначала ребро, не лежащее в M, потом лежащее в M, потом не лежащее в M,
ну и так далее по очереди. Еще раз? Ну что такое путь? Путь это формальная
последовательность вершин просто. Раз, два, три, четыре, пять, шесть. Концы соответственно первые
и последние вершины на пути. Так, нормально? Ну вот, тогда я утверждаю, что если есть увеличивающий
путь относительно данного просчитания, то вдоль него можно выполнить вот такое вот чередование и
размер парсоч увеличится. Ну понятно, я могу это сделать как раз за счет того, что у меня концы
не насыщенные, значит я вот эти вот ребра могу добавить в парсоч. Потом я меняю здесь вот,
я чередую здесь везде типы ребер, то есть те, которые были, я удаляю, те, которых не было,
добавляю. Ну и тогда понятно как раз, что у меня добавится больше, чем удалится. За счет того,
что у меня концы вне M, а по пути все чередуется, то у меня обязательно как бы на один больше будет
тех ребер, которые не в M по сравнению с теми, которые были в M. Значит размер обязательно увеличится.
Ну вот. И на самом деле верно следующее. Верна следующая теорема, теорема Бержа. Она утверждает
следующее, что M максимальное парсочетание, то есть просчитание максимального размера,
если и только если относительно него вот таких вот путей нету. То есть мне достаточно избавиться,
выполнить чередование вдоль всех увеличивающих путей, и тогда сразу автоматически парсочетание
максимально. Парсочетание M максимально, ну то есть имеет максимальный размер,
если и только если относительно него нет увеличивающих путей.
В одну сторону мы вроде уже доказали. Скажите в какую?
Слева направо вроде бы. Потому что если M максимально, но при этом относительно него
есть увеличивающие пути, то можно выполнить чередование и парсочи еще увеличить.
Значит если есть увеличивающий путь, то можно выполнить чередование и увеличить парсочи.
Так, хорошо, теперь обратно. В обратную сторону, конечно, более содержательное утверждение. То есть
смотрите, что мы сделали. Мы сказали, что чтобы найти парсоч, мы будем просто многократно искать
увеличивающий путь и выполнять чередование вдоль собственного увеличивающего пути. И больше
ничего делать не будем. Никаких других преобразований делать не будем. Вот оказывается, что этого достаточно.
Достаточно прочередовать вдоль всех увеличивающих путей, тогда парсочи автоматически максимальны.
Ну давайте доказывать. Для этого я веду какие-нибудь обозначения. Пусть M это вот то самое, давайте пойдем
от противного. Значит пусть M не максимально, но относительно него нет увеличивающих путей.
Не максимально, но относительно M нет увеличивающих путей. Вот, и давайте скажем,
пусть M это настоящее максимальное просчитание. Ну то есть M это наше, а M настоящее максимальное.
Тогда давайте я рассмотрю следующий граф. Я рассмотрю граф, в котором оставлю только ребра,
принадлежащие асимметричной разности множеств M и M'. Ну напоминаю, M и M' это формальное множество
ребер. Асимметричная разность этих множеств это только те ребра, которые лежат ровно в одном из них.
То есть либо в M, либо в M', но не в обоих одновременно. Давайте рассмотрим пока что такой граф. Я утверждаю,
что в нем каждая вершина имеет степень не больше, чем два. Ну вроде понятно. Давайте возьмем какую-нибудь
вершинку. Если внезапно у нее степень хотя бы три, то есть по крайней мере три ребра, лежат в этом
множестве. Тогда понятно, что хотя бы какие-то два из них пришли из одного множества, скажем вот из M
и из M'. Но тогда получается, что M это не про сочетание, потому что вот два ребра имеющие общий конец.
Значит три больше ребра сходить из вершинки не может, поэтому их не больше, чем два. Понятно?
Ну хорошо. В этом графе степень всех вершин не больше, чем два. Давайте докажем такую вспоминательную
лимку, которая говорит нам вообще про устройство таких графов, в которых все вершины имеют степень
не больше, чем два. Значит пусть H это граф с этим свойством, граф, в котором все степени не
происходят двойки. Тогда я утверждаю, что он представляется в следующем виде. Ну вот если
я рассмотрю компоненты связанности в H, то каждая компонент это либо простой путь, либо цикл. Больше
ничего в нем быть не может. Тогда каждая компонента связанности H – путь или цикл.
Так, ну вообще говоря, должно быть более-менее очевидно, почему это так.
Ну вот давайте, например, рассмотрим, ну понятно, давайте сначала отбросим все вершины степени 0,
потому что если вершина имеет степень 0, то она изолированная, она сама по себе является
отдельной компонентой связанности. Дальше, если я вижу какую-то вершину степени 1, то значит да,
из нее исходит ровно одно ребро. Ну давайте посмотрим на это ребро, оно куда-то ведет. Если оно
ведет в вершину степени 1, то это ребро – это отдельная компонент связанности, больше ребер,
как бы, исходящих из них нет. Если здесь степень 2, то значит есть еще одно какое-то, ровно одно
ребро, еще неиспользованное ребро, ведущее из этой вершинки, вот куда-то сюда оно ведет. Опять,
если здесь степень 1, то значит компонента закончилась, иначе здесь степень 2. Значит,
опять есть какое-то новое ребро, ведущее в какую-то новую вершинку. Ну и так далее. Вот, значит,
ребра ведущего назад быть не может, потому что, ну как бы, для всех предыдущих вершинок мы уже все
ребра рассмотрели. Мы как бы идем слева направо, и каждый, когда мы рассматриваем очередную вершину,
мы видим, что в нее пришло одно ребро, выходит одно ребро, значит больше никаких здесь быть не
может. Поэтому рано или поздно мы обязаны завершиться в какой-то очередной вершине степени 1. Мы так идем
слева направо. Вот, назад идти не можем, рано или поздно закончимся. Закончиться мы можем только
вершины степени 1. Значит, вот, пожалуйста, отдельная компонента связанности, никаких других
ребер сюда не входит. Понятно? Вот, то есть еще раз, если у нас есть вершина степени 1, то мы можем
просто идти по ребрам, как бы, ну по ребрам вдоль вот этой пути идти, и поймем, что мы обойдем
целиком компоненту связанности. Т.е. тем самым мы избавились от всех вершин степени 1. Вот мы их
давайте выкинули, остались только вершины степени 2. Ну давайте рассмотрим вершину степени 2.
Тогда, у него есть где-то два соседа. Давайте пойдем... Не, давайте я также буду рисовать. Вот 여기 есть
вершина степени 2. У нее есть там какое-то ребро, и вот давайте выберем одного из соседей этой
вершинки. Пойдем сюда. Все вершины имеют теперь степень 2. Но опять одно ребро уже нарисовано.
Осталось какое-то второе неиспользовано. Здесь одно ребро нарисовано, осталось какое-то
одно неиспользовано. Ну и так далее. Мы рано или поздно должны зациклиться. Потому что
потому что у нас каждая вершина добавляет новое ребро,
бесконечно долго ходить мы не можем,
значит, мы рано или поздно должны зациклиться вот по этой цепочке.
Но зациклиться вот сюда мы не можем,
потому что здесь вершина степени 2,
у нее и так уже оба ребра просмотрены.
Мы можем зациклиться только в самое начало,
как раз задействовав то самое ребро,
которое мы здесь не использовали.
Ну, значит, вся компонента
это вот такую простую циклу.
Понятно?
Так.
Можно считать, что Лемма доказана?
Хорошо.
Ну все, тогда давайте возвращаться вот сюда вот.
Давайте в резку мы сделали, доказали.
Теперь давайте возвращаться к графу H,
который у нас получен как симметрическая разность
ММ-штрих.
Вот, давайте посмотрим на компонент связности.
В H.
В H могут быть такие компоненты связности.
Давайте я разбью циклы
и пути вот здесь
по чётности их длины,
чётные и нечётные.
В H могут быть следующие компоненты.
Во-первых, чётные пути,
во-вторых, чётные циклы.
Чётная в плане количества ребер на них.
То есть, чётное количество ребер в пути,
чётное количество ребер в цикле,
Нечетное количество ребер в пути и то же самое нечетное количество ребер в цикле.
Я понимаю, что каждый компонент это либо путь, либо цикл.
Давайте их подразобьем по четности количества ребер в них.
Я утверждаю, что вот такого не бывает.
В графяш не может быть нечетных циклов.
Скажите, почему?
Давайте какой-нибудь примерчик нарисую.
Вот, например, цикл длины 5.
Почему в графяш не может быть цикл из 5 ребер?
Важно, что каждое ребро в графяш пришло либо из M, либо из M'.
При этом два соседних ребра не могли прийти из одного просочетания,
потому что ее так устроено.
Нельзя было, чтобы два рубра инцидентные пришли из одного просочетания.
Скажем, если это пришло из M, то это пришло из М'.
Это пришло из M, это пришло из M'.
Опять пришло из M.
В противоречии у меня все равно два ребра обязательно из одного просочу.
Ну и так будет с каждым циклом нечетной длины, что нельзя чередоваться так, чтобы любые два
соседа были различные при нечетной длине. Поэтому такого не бывает, у меня есть либо вот это,
либо вот это, ну либо еще нечетные пути. При этом, смотрите, что еще надо заметить,
вот в этом графе количество ребер, пришедших из m' обязательно строго больше, чем число
ребер, пришедших из m. Ну потому что вообще говоря, да, изначально я вот это предполагал,
изначально я знаю, что m' больше, чем m, потому что это максимально, это не максимально,
по предположению. А дальше, смотрите, в этом графе по факту что я сделал, я объединил эти два
множества и выкинул их пересечения, выкинул те ребра, которые были и там, и там. Поэтому здесь
у меня разность между ними сохранилась, потому что я из обоих множеств выкинул ребра,
присутствующие и там, и там, значит у меня разность сохранилась. Поэтому у меня обязательно должно
быть такое, что в этом графе ребер из m' больше, чем ребер из m. Но это автоматически значит,
что должен быть хотя бы один нечетный путь, на котором ребер из m' больше, чем ребер из m. То есть
у меня должен быть обязательно вот такой вот путь, такой, что на нем типы ребер чередуются,
и ребер из m' больше, чем ребер из m. Вот как, например, здесь. Потому что на четных путях и
четных циклах там чередование, там поровну ребер обоих типов, из m и из m'. То есть вот эти
привносят поровну ребер из двух просочетаний. Нечетный путь на одно больше приносит одного
образца, чем другого. Значит, должен быть хотя бы один такой нечетный путь. Давайте это напишем.
В h число ребер из m' должно быть больше числа ребер из m. Значит, обязательно существует вот
такой нечетный путь, на котором типы ребер чередуются, и на нем m' больше, чем m. Значит,
есть такой путь. Значит, есть такой нечетный путь. Вот такой вот. Так, хорошо.
Вот, но я утверждаю, что этот путь будет как раз увеличивающим для m'.
Потому что для него все выполнено. Во-первых, здесь типы ребер реально чередуются. Каждое
четное ребро из m, каждое нечетное, наоборот, из m' значит не из m. Потому что здесь как раз я
взял симметрическую разность. Значит, если ребро пришло из m', то оно точно не из m'. Поэтому
типы ребер действительно чередуются. Дальше. Длина этого пути хотя бы один, ну потому что на
нем ребер одного типа больше, чем другого, значит путь точно не из одной вершины состоит. Здесь есть
хотя бы одно ребро. Ну и наконец надо показать, что концы этого пути не насыщены для m'. Вот,
ну как-то сделать. Но будь они насыщены, что это значит? Значит, что вот здесь вот есть какое-то
ребро из m'. Но тогда это не компонента связанности. Тогда эту компоненту связанности нужно было бы
продлить на это ребро. А я предполагаю, что этот путь это как раз компонента. Противоречие. Ну вот,
значит противоречие и с исходным предположением, что относительно m нет увеличивших путей. Давайте
запишем тогда этот путь и будет увеличившим путем относительно m. Да, значит, почему его длина
больше и равно одного? Потому что есть хотя бы одно ребро в нем. Типы ребер чередуются.
Ну и наконец концы не насыщены относительно m. Потому что иначе, если бы было какое-то
ребро, то значит это не компонента связанности, ее можно продлить какой-то каким-то другим ребром.
Концы не насыщены относительно m. Иначе путь не является компонентом связанности.
Ну все, противоречие. Ну еще раз, смотрите, вот пусть эта вершина насыщена. Это что значит?
Значит из нее торчит ребро m. Какое-то вот такое. Но тогда это же ребро лежит ваше. А значит,
путь должен быть покой как минимум. Нет, смотрите, если это ребро, исходящее отсюда,
которое лежит в m, если оно не совпадает с этим, то оно гарантированно лежит ваше, потому что вот
это лежит ваше, но вообще это должно лежать ваше. То есть это не может быть в m'. Если же это ребро
m совпадает вот с этим, тогда это ребро не должно быть ваше. Ну тогда, опять же, тогда вообще этого
ребра нету ваше. Ну как-то так. Ну да, да, да. Так, вроде доказал. Вопросы? Хорошо. Все, получается,
мы доказали теорему Бержа, которая как раз говорит нам, что достаточно всего лишь прочередовать
вдоль всех увеличивающих путей. Ну, собственно, мы так и будем делать. Причем, заметьте,
эта теорема, вообще говоря, верна для произвольного графа. Я здесь нигде не
пользовался двудольностью g. То есть, вообще говоря, все это рассуждение верно и для
произвольного графа. Вот. Но алгоритм, нормальный, ну как бы, простой алгоритм получается только для
двудольного графа. В общем случае, тоже есть, но более сложный. Так, хорошо. Значит, теперь как мы
будем это делать? На самом деле, чтобы вот визуализировать, как мы будем находить увеличивающие
пути, давайте я сделаю следующее. Давайте я в нашем исходном графе все ребра про сочетание ориентирую
справа налево, а все остальные ориентирую слева направо. То есть, вот, там есть двудольный граф.
Давайте все ребра про сочи я ориентирую справа налево, да, ну а все остальные слева направо.
Тогда, что по факту я хочу найти? Что такое увеличивающий путь вот в этих терминах? По факту
мне нужно просто найти какой-то путь из левой доли вправую, который начинается и заканчивается в
ненасыщенной вершине. Вот если это ненасыщенная и это ненасыщенная, то любой путь в таком ориентированном
графе отсюда-сюда, это как раз увеличивающий путь. Потому что начинается и заканчивается в
ненасыщенной, длина больше либо равна одного, потому что это путь между разными долями,
хотя бы одно ребро я использую. Ну и дальше, почему чередование выполняется. Я буду ходить
слева направо, справа налево, и так далее, вот так вот прыгать между долями. Понятно, что первое
ребро оно не из m, потому что слева направо. Второе из m потому что справа налево, потом опять не из
m потому что слева направо. Ну и так далее... Я как раз буду чередоваться, чередуется направление,
значит чередуется тип ребра из m, не из m. Поэтому, в таких терминах, вот после ориентации по
В суть я просто буду искать путь.
Мне в таком ориентированном графе надо найти какой-нибудь путь из ненасыщенной в ненасыщенную.
Но это мы умеем делать с помощью DFS.
Чтобы проверить, есть ли какой-то путь, можно пустить DFS
и проверить, достижим ли какая-нибудь ненасыщенная правая доля из какой-то вершины левой доли.
Вот так и будем делать.
Для этого давайте я напишу что-то типа кода.
Давайте я для каждой вершины правой доли буду хранить ту вершину, с которой она в парсочи.
А если такая есть? Давайте назову match.
match от u.
Это для каждой вершины правой доли мы поддерживаем, с кем она соединена в парсочи слева.
Давайте напишу так.
Либо это минус один, либо v такая что v у это ребро взятое в m.
Я храню того соседа, с кем она соединена в парсочи.
Либо минус один, если такого соседа нет, если она не взята в парсочи.
Давайте я заведу граф g, который как раз хранит все ребра слева направо.
Как обычно у меня будет вектор векторов, который для каждой вершины левой доли хранит всех ее соседей справа.
g для каждой вершины v.
Если v у меня где-то слева, то g у v это список всех соседей справа.
Список всех соседей справа.
Всех соседей вершины v в правой доле.
Еще мне нужен будет массив used.
В DFS у меня есть какие-то пометочки использованности вершин.
У меня в ориентированном случае был color, но не важно.
Я заведу пометочки used, которые для каждой вершины левой доли говорят, был я там уже или нет.
Если был, то нет смысла запускаться еще раз.
Да.
Давайте считать, что это список в исходном графе.
И тех, и тех.
Все неориентированные ребра, которые торчат, все эти концы я буду там хранить.
В конце концов у меня может быть только одно плохое ребро, но я его всегда смогу отловить по этому условию.
Если match от уровна v, то значит ребро ориентировано справа налево.
Еще раз.
У меня есть какая-то v.
В исходном графе из нее исходило сколько-то ребер.
Все эти концы добавляю в G от v.
Что происходит?
Почти все из них ориентированы слева направо.
Может быть только максимум одно ориентировано справа налево, если это ребро взятое в просочетании.
Если мы хотим его игнорировать, то надо будет проверить, не правда ли что match от этого равно этому.
Если равно, то это ребро ориентировано справа налево, его можно игнорировать.
Match только для вершин правой доли.
Я как бы мог бы для обеих долей хранить, но мне только для правой достаточно.
Match только для правой доли.
Match для правой, G для левой.
Ну и just.
Да, это просто какой-то булливский флаг для всех вершин левой доли.
Булливский флаг посещенности.
Для вершин левой доли.
Ну хорошо, давайте на эту процедурку.
Процедура будет у меня называться augment.
Увеличение.
Давайте я напишу вершину V.
Это какая-то вершина левой доли, из которой я буду пытаться найти путь до ненасыщенной вершины правой доли.
Во-первых, если я здесь уже был и не преуспел, то можно завершиться.
Если я здесь уже был, эту вершину пометил использованной.
Грубо говоря, уже пытался найти путь из этой вершинки.
То заново делать это не нужно.
Я говорю, чтоб увеличить не получилось.
Return false.
Иначе сразу же помечаю ее использованной, чтобы в будущем не проходить несколько раз.
И вот, если я уже был и не преуспел, то можно завершиться.
И сразу же помечаю ее использованной, чтобы в будущем не проходить несколько раз.
Теперь перебираю все ребра, исходящие из V.
Как раз я перебираю какое-нибудь ребро из V в ту.
Идеальный случай, это если бы вершина ту была ненасыщенной, и тогда у меня бы уже путь нашелся.
Как раз я ищу путь до ненасыщенной правой доли.
Если ту ненасыщен, то есть если match от ту равно минус один, то я уже нашел такой путь.
Либо же, второй случай, это что я иду вдоль какого-то ребра.
Так, давайте кончим.
Вот у меня есть V, вот у меня есть ребро в ту.
И это еще не конец, это только начало, грубо говоря, начало моего увеличивающего пути.
Но если я взял ребро слева направо, то дальше, чтобы продолжить путь, мне обязательно нужно идти справа налево.
И это ребро у меня только одно, это ребро в match от тус.
Вот здесь лежит match от ту.
Ну и тогда я просто возьму и запущусь DFS отсюда.
Ну не DFS, а вот этим моим augment.
То есть я, чтобы найти путь отсюда, я пытаюсь найти путь отсюда.
Если получилось, то значит я его вот так вот доклеиваю, и получается как раз увеличивающий путь из V.
Ну значит я просто пишу, или при рекруссивном запуске augment от match от ту у меня случился успех.
То есть либо я сразу это ребро мог добавить в путь, либо мог взять его, прыгнуть справа налево,
и потом дойти из этой вершинки с помощью augment до какой-то ненасыщенной вершины правой доли.
Вот в любом из этих двух случаев получается, что я нашел увеличивающий путь.
То есть либо сразу вот это ребро, либо через такое начало, и потом еще где-то рекурсивно он там нашелся.
В любом из этих двух случаев я нашел увеличивающий путь.
Мне нужно будет вернуть true, то есть у меня успех произошел.
Ну и давайте считать, что у меня не только булистский флаг возвращается, нашелся путь или нет,
но еще и сразу давайте выполним чередование, потому что мне же нет смысла просто пути находить,
мне нужно найти и сразу сделать чередование вдоль него, чтобы парсочи увеличить.
Ну тогда если я увеличиваю парсочи вдоль вот этого пути, то что происходит?
По факту у меня просто вот этот матч сдвигается отсюда вот сюда вот.
То есть у меня новым матчем для вершинки true становится v.
Потому что это было ребром простания, а это не было.
У меня наоборот все меняется, у меня это становится ребром простания, а это как бы пропадает.
Значит мне можно просто переприсвоить матч от уровну v,
а там рекурсивно все это тоже прочередуется.
Поэтому если я здесь просто напишу матч от уровну v,
я как раз выполню вот здесь вот чередование,
ну а дальше все рекурсивно тоже почередуется.
Так, ну все.
Вот это я сделал для всех ребер.
Если ни для одного не получилось, то return false.
Вот такой агмент.
Так, вопросы по коду есть?
Смотрите, этого можно не делать.
Я мог бы это сюда вписать для какого-то более адекватного разбора,
но на самом деле можно этого не делать.
Потому что если вот, смотрите, до конца,
когда я делаю код, я делаю код, я делаю код,
я делаю код, я делаю код.
Или можно этого и не делать.
Когда я перебираю, скажем, пусть это ребро ориентировано справа налево.
Вы про этот случай, да?
Но даже если оно такое, то что происходит?
Это значит, что агмент запускается опять от v,
то есть это неверно, запустится агмент от v,
но вершина v уже помещена useDom, поэтому она автоматически будет false,
и это tu просто проигнорируется.
Поэтому от того, что tu лежит у меня в списке,
у меня ни на что не влияет.
Ну вот.
Еще раз?
Зачем?
Вы про то, что не можем ли мы два ребра вот таких взять в порсоч?
Ну да, да, да.
Ну еще раз, если мы взяли просто первый ребро,
то у меня граф сейчас вот такой.
Так, что потом происходит?
От этой же?
Да.
Вот.
Про то, что не может ли два ребра быть взяты одновременно?
Но на самом деле нет,
потому что тут надо, я как бы этого еще не говорил,
надо еще проговорить, как мы этот агмент запускаем.
То есть то, что вы говорите,
это то, что нельзя запускать агмент от уже насыщенной вершины.
Нет, а если она не насыщенная,
как раз все хорошо, потому что что такое агмент?
Что по факту делает эта штука?
Если мы ее запустим вот не насыщенной,
она что делает? Она как раз ходит по ребрам нашего графа.
И завершается успехом только если она нашла вершинку
с 매ча tu равно минус один.
То есть как раз если она дошла до не насыщенной.
И потом чередует вдоль пути.
Ну конечно, но это же парсочетание.
Все нормально, нет, все хорошо.
Еще раз, мораль агмента такая,
если агмент запустить от не насыщенной вершины левой доли,
то он завершится успехом, то есть он вернет true,
если и только если он дойдет до какой-то не насыщенной вершины правой доли,
и выпустит агмент.
То есть если у вас нет агмента,
то вы можете запустить агмент,
если он дойдет до какой-то не насыщенной вершины правой доли,
и выполнить чередование вдоль этого пути.
То есть как раз true, если получился увеличивший путь,
false, если не получился.
Так, давайте тогда перерыв небольшой.
Так, давайте продолжать.
Смотрите, augment, это такая просто процедурка,
которая по сути ищет путь из данной вершины
до какой-нибудь не насыщенной вершины правой доли.
Агаритм куна,
непосредственно уже алгоритм поиска максимального просчитания.
Если мы написали augment,
то алгоритм очень короткий.
Ну, во-первых, я used заполняю false.
Так, давайте вот так напишу,
массив, состоящий из false.
То есть изначально все вершины не посещены.
Дальше я перебираю все вершины левой доли,
давайте я вот так напишу, v от 0 до n-1.
Если v от вершины левой доли,
они там пронумерованы, 0, 1, 2 и так далее,
просто иду в этом порядке.
Запускаю augment от v.
Если он успешен,
значит алгоритм смог найти какой-то
увеличивший путь, начинающийся в v.
И более того, он выполнил чередовать
в доле этого пути.
То есть там он какой-то путь нашел,
сделал чередование, парсоль увеличился.
Но давайте тогда в этот момент,
поскольку у меня изменился весь граф,
у меня сменилась ориентация ребер некоторых.
У меня поменялось направление у тех ребер,
которые прочередовались.
Поэтому у меня граф,
и значит есть смысл сбросить опять все метки юст,
потому что у меня граф перестроился,
и новый DFS уже будет обработан на новом графе,
поэтому мне нужно стереть все вот эти метки.
А если бы он завершился безуспешно,
значит мы что-то попытались найти,
искали какой-то путь, не нашли, но при этом граф остался тем же самым.
Тогда эти юзды можно было бы не стирать,
но можно было бы эту информацию использовать дальше.
То есть если я уже из каких-то вершин пытался найти путь,
не нашел и пытаюсь еще раз от других,
то возвращаться туда, где я уже был, можно не возвращаться.
Вот, ну все, конец, алгоритм Куна.
Это правильный вопрос.
Сейчас я буду доказывать корректность этого алгоритма.
Но...
Так, хорошо.
Раз вопрос есть, давайте я сформулирую такое утверждение.
И, наверное, вместе с ним корректность этого алгоритма
у нас будет как-то так,
как-то так, как-то так,
как-то так, как-то так, как-то так,
и, наверное, вместе с ним корректность алгоритма будет ясна.
Надеюсь.
Отверждение.
Пусть m' получено из m
чередованием вдоль увеличивающего пути.
Пусть v
такова,
что из v
нет, как бы...
Давайте напишем, что так.
Не было увеличивающего пути относительно m.
Тогда из v нет увеличивающего пути относительно m'.
Так.
Так, если я докажу это утверждение,
это ответит на ваш вопрос?
Супер.
Значит, по модулю этого утверждения что происходит?
Здесь весь мой граф двудольный.
Что делает алгоритм Куна?
Он просто идет вот в этом порядке по всем вершинам левой доли
и пытается запускать augment.
Значит, наблюдение первое.
Augment запускается только от ненасыщенной вершины левой доли.
Ну, потому что даже когда я позапускал
уже несколько augment здесь,
у меня насыщенными могут быть только вот эти вершинки.
Потому что я до этого момента рассматривал только их.
И если у меня augments были только отсюда,
то эти вершины я еще вообще как бы не видел.
Потому что до них я никак не мог дойти.
В них не идет вот таких вот ребер.
Ну, потому что они еще не рассмотрены, таких ребер не добавлено.
Значит, они не будут рассмотрены до момента,
пока у меня вот этот форик до сюда не дойдет.
Поэтому augment у меня запускается только вот вообще не рассмотренных еще вершин.
Порсочи изначально.
Изначально порсочи пустой.
Это, наверное, можно было бы прописать.
Изначально match я заполняю минусоединечками.
Давайте вот это тоже здесь впишу.
Значит, изначально match это массив, состоящий из минусоединиц.
Это значит, что изначально никакое ребро не взято в просочитание.
Все ребра ориентированы слева направо.
Соответственно, никто ни с кем не соединен в порсочи.
Вот. Ну, хорошо.
Значит, augment у меня запускается только от ненасыщенных вершин.
Если augment завершился как бы плохо, с false,
то значит, он попытался что-то найти, но не смог.
Ну, тогда понятно, что граф не перестроился.
Граф остался таким же, как был.
Ориентация всех ребер сохранилась.
И юзды можно было бы не сбрасывать.
Если не augment от v, тогда юзды можно не сбрасывать,
А вопрос, мне кажется, он запускается от очевидной вершины.
Да.
Вниз мы можем залезть еще раз.
Ну, наверх залезть можем, конечно, да.
А вот вниз не можем.
Потому что, ну, еще раз, смотрите, как мы можем попасть в какую-то долю?
Мы можем попасть в левую долю только с помощью ребра справа налево.
Но если эти вершины я еще вообще ни разу не трогал,
то в них не может входить никакого ребро справа налево.
Потому что ребро входит, то есть, смотрите, match,
когда у меня вообще в какую-то вершину слева появляется ребро,
только в этой строчке.
Ну, а значит, у меня augment от вершины уже запущен.
Хорошо, давайте другими словами скажу.
Значит, изначально граф у меня такой.
Изначально все ребра только слева направо.
Согласны? Потому что match пустой.
Дальше я запускаю augment от нулевой вершинки.
Что может произойти?
Может найти какой-то увеличивающий путь.
А, можно еще, вот что можно сказать.
Как работает увеличивающий путь?
Он начинается слева в ненасыщенной,
ходит по насыщенным и заканчивается справа в ненасыщенной.
Поэтому все вот эти промежуточные уже тоже насыщенные,
а значит, как бы уже рассмотрены ранее.
Вот эти все, то есть, на самом деле любой augment работает как-то так.
Он, наоборот, как бы наверх идет.
То есть, вот эти вершины должны быть насыщенными.
Что у меня происходит?
Какое-то ребро могло быть ориентировано справа налево в нулевую вершинку.
Дальше я запускаю augment от одного.
Он опять как-то ходит, и все, что он может сделать,
это ориентировать какое-то ребро.
Вот сюда попасть ниже он не может,
потому что туда нет никаких ребер справа налево.
Единственное, что он может сделать, это какое-то ребро перенаправить в единицу.
Все вершинки с большими номерами будут по-прежнему неиспользованы.
Мы от них даже не запустимся.
То есть, получается, что...
Вернусь, где я был.
Я пытаюсь найти увеличущий путь.
Если получилось, то я перестраиваю граф и сбрасываю все метки,
потому что, возможно, появились какие-то новые пути.
Если не получилось, то значит как раз я запустил сотни насыщенной.
Она не дала никакого успеха, она не дала никакого пути.
Значит, по этому утверждению,
как бы у меня ни менялось впоследствии парасочетания,
это V уже бесполезно.
Я из нее больше ничего не найду,
и можно заново от нее не запускаться.
Можно ее игнорировать, как будто бы нет.
В графе она ничего не дает.
Можно просто в этом порядке пройти сверху вниз
и запускаться только в этом порядке по вершинам.
Вопросы, может быть.
Хорошо.
Сейчас я докажу это утверждение,
только асимптотику скажу сначала.
Асимптотика алгоритма Куна будет такая.
Я напишу ее как E умножить на ответ.
Я, как обычно, предполагаю, что E больше, чем V,
потому что иначе можно в каждой компанией связанность решать независимо.
E откуда?
Это по факту просто DFS по графу нашему.
ans – это размер максимального просочетания.
Почему E на ans?
Потому что количество сбрасываний меток юст
примерно равно ans.
И между двумя последователями сбрасываний у меня граф фиксирован.
Метки юст никуда не исчезают.
Значит, суммарное количество обхода всех вершин и всех ребер
примерно E плюс V.
Я юзды сбрасываю только между успешными агментами.
Соответственно, между успешными агментами граф фиксирован.
Юзды я не сбрасываю.
Я запускаю агменты просто каких-то вершин.
Если там был юст, то я ее просто игнорирую.
Если не юст, то обхожу и два раза ничего не обхожу.
Поэтому суммарно у меня столько раз запускается DFS.
Понятно, что это не больше, чем просто E умножить на V,
потому что ребер в парсочи максимум V.
Потому что каждая вершина левой доли дает максимум одну ребро.
Теперь осталось вот это утверждение доказать.
Отверждение.
Давайте скажем следующее.
Пусть m штрих, полученный из m,
чередованием вдоль какого-нибудь пути x, y.
Что это значит?
У меня был вот такой путь, в котором тип и ребер чередуются.
m штрих m, m штрих m, m штрих.
И при этом крайние вершины были не насыщены относительно m.
Тогда как раз я могу выполнить чередование и получить больше и больше парсочек.
Теперь вот вершина V.
Пусть вершина V такова, что из V не было увеличивающей пути относительно m.
Тогда понятно, что V отлична от x и y, потому что из x есть путь и из y есть путь.
Более того, я буду считать, что V не насыщена относительно m.
Потому что если она насыщена относительно m, то из нее вообще никакого увеличивающей пути быть не может, потому что она насыщена.
V не насыщена, поэтому она обязательно лежит не на этом пути, потому что здесь все насыщены.
Вот V где-то здесь.
V не насыщены вершины, лежащие вне этого пути.
И давайте пойдем от противного. Пусть есть какой-то увеличивающий путь из V относительно m штрих.
Ну какой-то такой путь.
Тогда утверждаю, что он обязательно пересекается вот с этим путем.
Но потому что если внезапно этот путь никак не пересекается с этим путем,
то то, что здесь было чередованием относительно m штрих, будет также чередованием относительно m.
Потому что у меня m и m штрих отличаются только вдоль этого пути, значит то, что здесь увеличивает относительно m штрих, то же самое относительно m.
Раз я вообще вот эти ребер никак не задеваю, то вне этого пути m и m штриха одно и то же.
Поэтому если это увеличивающий путь относительно m штрих, то и относительно m это тоже увеличивающий путь.
обязательно пересекается вот с этим вот путем.
Ну и давайте рассмотрим первый момент такого пересечения.
Что-нибудь такое я нарисую, да.
Ну как-нибудь так.
Вот, да.
Ну еще раз, если есть какой-то путь вне этого пути, увеличивший
относительно m штрих, то он же будет увеличившим относительно
m, потому что с точки зрения всего, кроме этого пути,
вот этого вот x и y, у меня m и m штрих это одно и то же,
потому что чередование только вдоль него произошло.
Значит у меня это было бы увеличившим путем м, противоречие.
Так, значит еще раз, вот есть какой-то путь вот такой.
И дальше он куда-то ведет, я рассматриваю первую вершину
на этом пути, которая попала на путь x и y, пусть это вершинка
u.
Вот, раз это увеличивший путь относительно m штрих,
то ребра чередуются.
Это не из m штрих, как бы не m штрих, это m штрих, это
не m штрих, это m штрих.
Вот.
Ну конкретно такой картинке быть не может, потому что
еще раз, вне вот этого пути m штрих и m это одно и то же,
значит получается у вершинки u два соседа одновременно
лежали в m, да, два инцидента ребра лежат в m.
Поэтому такого быть не может, и получается, что последнее
ребро вот на этом пути обязательно наоборот не из m штрих.
Так, значит такого не бывает, да, вот такого не бывает.
Значит последнее ребро вот это тоже пунктированное
должно быть, не из m штрих.
Ну вот как-то так.
Вот.
Ну тогда я утверждаю, что здесь очень легко заметить
путь, увеличивший относительно m.
Можно просто вот так вот, например, пойти, и это
будет путь, увеличивший относительно m.
Да, потому что как раз у меня будет чередовый путь,
и это будет путь, увеличивший относительно m.
Да, потому что как раз у меня будет чередование,
вот здесь m и m штриха одно и то же, поэтому здесь
как раз не из m, из m, не из m, из m, не из m.
Путь, чередование ребер есть, концы не насыщенные,
ну и длина его больше одном, потому что v вне этого
пути, значит хотя бы одно ребро мне понадобилось.
Значит вот этот путь, увеличивающий относительно m.
Она увеличивающий относительно m.
Ну противоречие.
Так, что-то понятно?
Да.
Ну это не то, что я предполагаю.
Я говорю, что можно считать что?
Потому что если v насыщенная, то значит очевидно из
нее нет увеличившей пути, потому что из насыщенных
не бывает.
Дальше, если она лежит на пути, то она либо x, либо
y, но тогда вот это неверно, потому что из x и из y есть
увеличивший путь.
Поэтому можно считать, что v не насыщенная, не
лежащая на этом пути.
Так, вопрос есть по доказательству?
Окей, мораль.
Еще раз утверждение по модулю технического разбора
случаев.
Утверждение говорит в следующее, что если вершина
один раз бесполезна, если мы один раз из нее не смогли
найти увеличивший путь, то дальше пытаться из нее
еще раз искать увеличивший путь бессмысленно.
Вот, там какое-то доказательство.
Но смысл такой, что вот если я один раз запустил
с аугментом от v и как бы провалился, то нет смысла
делать это еще раз.
Ну все, поэтому как раз достаточно просто один
раз перебрать вершину в этом порядке.
И нет смысла заново кучу раз запускать здесь аугмент,
потому что если один раз не получилось, то больше
никогда не получится.
Ну все.
Так, тогда вроде бы кун закончился.
Дальше едем?
Ладно.
Так теперь, значит, смотрите, я хочу еще...
В общем, вот в доводовольных графах какие-то задачи решаются
проще, чем в произвольных.
Например, парсо чищеца не заново не будет.
но в дудольных графах какие-то задачи решаются проще, чем в произвольных.
Например, парсочи ищется относительно несложно.
То есть по модуле вот этих утверждений код очень простой.
Агмент был на доску, и там сам кун несколько строчек общий.
Более того, оказывается, что в дудольных графах можно искать
не только парсочи эффективно, но и, например, максимальное независимое множество.
Если помните, где-то в начале семестра мы разбирали алгоритм,
который находит максимальную клику в графе за два в степени напополам.
Можно показать, что в произвольном графе эта задача реально сложная,
и пока что никто не умеет ее решать быстрее, чем за какой-то экспонент.
А в дудольном случае это можно делать довольно быстро.
Давайте я быстренько веду пару определений на всякий случай.
Во-первых, пусть g это граф.
Тогда под множеством множества вершин называется независимым множеством.
Наверное, здесь сразу уже определял, но ну и ладно.
Независимым множеством, если никакие две вершины из I не соединены ребром.
Для любых u, v из I, u, v это не ребро.
Далее, c как под множество v называется вершинным покрытием.
Если любое ребро хотя бы одним из своих концов лежит в c.
То есть если любое ребро нашего графа хотя бы u или v лежит в c.
То есть хотя бы одна из вершин u, v лежит в c.
Это такое множество вершин, что любое ребро либо вообще целиком здесь внутри c лежит.
То есть оба конца могут быть внутри c.
Либо один конец в c, а другой вне c.
И других ребр нет.
Значит, простое замечание, что I это независимое множество,
если и только если дополнение к нему на v-I. Это вершинное покрытие.
Ну вроде понятно. Вот как раз давайте вот на этой картинке посмотрим.
Что такое вершинное покрытие?
Это такое множество, что любое ребро либо внутри целиком, либо одним концом внутри, а другим вне.
Значит все остальные вершинки, v без c, это как раз независимое множество,
потому что здесь ребра быть не может.
Будь здесь ребро, это противоречило бы определению вершинного покрытия.
Ну и наоборот, если вот это независимое, значит все ребра максимум одним концом лежат здесь.
Ну как раз дополнение это вершинное покрытие.
Получается у нас есть такая двойственность между независимым множеством вершинным покрытиями.
Значит в частности, если бы я хотел найти максимальное независимое,
то дополнение к нему это всегда минимальное вершинное покрытие.
Если они друг другу соответствуют, то максимизирую одно, я минимизирую другое.
Ну не буду это писать.
Если мне хочется найти максимальное независимое,
то это тоже самое, что найти минимальное вершинное покрытие и взять дополнение.
Ну и теперь давайте научимся в вдвольном графе находить максимальное независимое и минимальное вершинное покрытие.
Напоминаю, что в произвольном случае, в случае произвольного графа,
вот эта вот задача NP-трудная, то есть пока что никто не умеет решать быстрее, чем закрыть экспонент.
И поскольку между ними есть такое простое соответствие,
то значит и минимальное вершинное покрытие тоже никто не умеет быстро решать,
потому что они друг через друга выражаются.
А в вдвольном случае это делается довольно просто.
Теорема Кёнига.
В вдвольном графе размер минимального вершинного покрытия равен размеру максимального просчитания.
То есть сколько ребер в парсочи, столько вершин в покрытии.
И тем самым, если мы найдем максимальное просчитание, то мы найдем, собственно, минимальное вершинное покрытие.
Так, ну доказательства.
Давайте я сначала построю конструктивный алгоритм для поиска вот этого самого минимального вершинного покрытия.
Алгоритм.
Во-первых, ну собственно, найдем максимальное просчитание.
Пусть М это максимальное просчитание.
Во-вторых, так же как и раньше, я ориентирую все ребра нашего графа так, что ребра из парсочи торчат справа налево, все остальные слева направо.
Ориентируем ребра так же как раньше.
То есть справа налево те, которые были в М, слева направо те, которые не были в М.
Так же как раньше.
Третье.
Давайте запустим какой-нибудь обход DFS, BFS, не важно, какой-нибудь обход графа из всех ненасыщенных вершин левой доли.
Запустим, давайте скажем, DFS из всех ненасыщенных вершин левой доли.
Значит, тогда весь граф у меня разобьется на четыре вот таких облачка.
L плюс, L минус, R плюс, R минус.
Это, соответственно, посещенные слева, непосещенные слева, посещенные справа, непосещенные справа.
Вот после вот этого обхода.
То есть у меня в левой доле есть несколько ненасыщенных вершин.
Я просто запускаю из них из всех DFS.
Все, что посетилось, это L плюс, R плюс.
То, что не посетилось, это L минус, R минус.
Значит, тогда утверждается, что L плюс в объединении с R минус это максимально независимое множество.
Ну а дополнение, то есть все остальное, получается L минус в объединении с R плюс, это минимальное вершины покрытия.
Сейчас это докажем.
Так, ну картинка.
Значит, это вот разбиение всех вершин на четыре категории.
Я утверждаю, что в этом графе, я напоминаю, сейчас граф ориентированный,
вот на втором шаге я все ребра ориентировал в одну из двух сторон,
давайте докажем, что каких-то ребер в этом графе нет.
Ну например, вот таких вот ребер.
И вот таких вот ребер я буду есть.
Вот здесь тоже сейчас всё утверждаю, что 여기 есть ребра,
и теперь я собираю больше ребра.
Ну, например, вот таких вот ребер и вот таких вот ребер в нашем графе тривиальным образом быть не
может. Почему? Ну да, потому что если есть ребро из плюсов в минус, значит DFS, находясь вот здесь,
должен был бы пройти по этому ребру и посетить эту вершину тоже. То же самое здесь. Если бы он
был здесь, то он обязан был бы быть здесь. Значит, ребер из плюсов в минус не бывает,
потому что так работает DFS. Ну и еще я утверждаю, что не бывает вот таких вот ребер из R минуса в L
плюс. Почему не бывает ребер из R минуса в L плюс? Ну пусть есть. Да, пусть есть какое-то вот такое
ребро из R минуса в L плюс. Ну что это значит? Это ребро справа налево, значит это ребро
про сочетание. Значит, эта вершина насыщенная. Значит, из нее непосредственно DFS не запускался.
DFS мог только в нее каким-то образом прийти из ненасыщенной. То есть DFS должен был бы как-то
начаться в ненасыщенной, как-то походить по графу и сюда прийти. Но никаким другим образом,
кроме как с помощью этого ребра, мы прийти в эту вершину не можем. Потому что в нее никаких
других входящих ребер нет. Значит, эту вершину мы просто не могли бы посетить. Поэтому в этой
вершине не может быть L плюс. Да, давайте пару слов напишу здесь. Нет ребер из R минуса в L плюс,
но так как, давайте это назову V, так как никаким другим способом V попасть нельзя. Никаким другим
способом, кроме как с помощью этого ребра попасть в V нельзя. А если я попадаю сюда с помощью этого
ребра и эта посещена, значит, эта тоже должна была быть посещена, чтобы я по этому ребру мог
пройти. Ну вот, значит, у меня уже получилось, что вот это вот это независимое множество. Как раз L
плюс в объединении с R минусом это независимое множество. Потому что нет ребер внутри вот этих
ходоболочков и нет ребер между ними. И автоматически значит, что дополнение это вершины покрытия. Теперь
надо показать, что это соответственно экстремальные в своем классе. То есть, что L плюс и R минус это
максимально независимое множество. Или что то, что R плюс в объединении с L минус это минимальное
вершины покрытия. Докажем, что вот это вот, это минимальное вершины покрытия. То есть мы доказали,
То есть это просто вершинное покрытие, но я утверждаю, что оно еще и минимально, то есть нет никакого другого меньшего размера.
Так. Ну, замечание первое. Вот здесь вот лежат только насыщенные вершины.
А вот в этих вот множествах могут быть только насыщенные вершинки.
Ну понятно, в L- понятно только насыщенные, потому что из ненасыщенных мы запустили DFS, и все ненасыщенные автоматически здесь.
Поэтому здесь могут быть только ненасыщенные в L-.
Почему в R-плюс только, извините, здесь только насыщенные?
Потому что все ненасыщенные здесь, значит насыщенные могут быть только здесь.
Почему здесь все насыщенные?
И что?
Насыщенные те, которые в парсоте участвуют.
Ну, если они находятся в середине парсотча... А, сейчас.
А почему это не может быть последнее ребро вот в этом пути?
То есть, например, я начал в ненасыщенной, шел-шел по ребрам и закончил тоже в ненасыщенной.
Если это последнее ребро.
А если это последнее ребро?
Потому что, когда я иначе, это был бы увеличивающий путь просто.
То есть если бы здесь была какая-то ненасыщенная, и она лежит в R-плюсе,
что значит она лежит в R-плюсе?
Значит, я до нее дошел из какой-то ненасыщенной вершины левой доли.
А все еще plankton здесь, эти ненасыщенные, эти не насыщенные, которые находятся в R-плюсе.
Что значит не насыщенные?
что значит, что она лежит в r-плюсе,
я до нее дошел из какой-то ненасыщенной вершины левой доли.
То есть есть какой-то путь отсюда до сюда,
как раз чередующие типы с лево-направо-справо,
с лево-направо-справо, с лево-направо-справо,
и так далее, начинающий и заканчивающий в ненасыщенной.
Значит, исход на m не максимальный,
а я взял максимальное прочитание.
Поэтому в r-плюсе тоже могут быть только насыщенные.
В r-плюс и l-минус лежат только насыщенные вершинки.
При этом мы с вами доказали,
что ребер из r-плюса в l-минус не бывает,
таких вот ребер быть не может.
Значит, ни для какого ребра парасочетания
оба его конца не могут лежать одновременно вот здесь и вот здесь.
Потому что как раз такое ребро означало бы,
что это ребро из r-плюса в l-минус.
Это значит, что любое ребро парасочетания
максимум только одним своим концом лежит вот в этом множестве.
Второе наблюдение, что любое ребро парасочетания,
любое ребро m,
только одним своим концом
может лежать в этом вот нашем r-плюс в объединении с l-минус.
Потому что если оба конца, то значит,
это вот такое ребро справа налево,
а мы докажем, что их не бывает.
Но отсюда автоматически следует,
что размер этого множества не больше,
чем всего ребер в парасочетании.
Раз каждый ребро парасочетания максимум одну вершинку добавляет,
значит, суммарный размер этой штуки не больше, чем m.
А потому что ребра из парасочетания справа налево всегда.
Единственная шанса быть вот так вот,
а таких ребер мы знаем, что нет.
Еще раз.
Смотрите, в этот момент у меня уже никаких чередований нет.
Это просто тот граф, который получим после всех агментов.
И там автоматически все ребра из парасочетания справа налево,
все ребра не из парасочетания слева направо.
Поэтому такое значит автоматически из парасочетания.
Ну все, получается, что мы построили вершинное покрытие,
размер которого не больше, чем m.
С другой стороны, я утверждаю,
что размер любого вершинного покрытия всегда больше и равен, чем m.
Размер любого вершинного покрытия всегда больше и равен, чем m,
потому что что такое m?
Это несколько дизъюнктных ребер.
Чтобы их покрыть, понятное дело, что мне, по факту,
обязательно нужно выбрать хотя бы один из двух концов каждого ребра.
Вершинное покрытие такое множество, что у каждого ребра
хотя бы один из концов выбран.
Я должен из этих двух концов выбрать хотя бы один, скажем вот это.
Из этих двух хотя бы один, из этих двух хотя бы один,
из этих двух хотя бы один.
Как ни старайся, чтобы покрыть все ребра парасоча,
нужно выбрать вершин хотя бы столько, сколько в нем ребер.
Ну а здесь нераняс Angels в обратную сторону,
Значит, автоматически получу, что r±l± — это в точности m.
И это минимально возможное вершинное покрытие,
потому что любое покрытие имеет размер хотя бы m.
А мы получили равно m.
Мы получили равенство и доказали теорему,
что существует вершинное покрытие размера, равное m,
и оно минимальное, потому что любое вершинное покрытие
имеет размер хотя бы m, а это минимально.
То есть получается, что если мы нашли максимальное
просчитание в этом графе,
то дальше дело техники, нужно просто все ребра ориентировать,
правильным образом запустить DFS,
разбить все на четыре категории,
и дальше объединение такое или такое —
это будет, соответственно, вершинное покрытие минимальное
или максимальное здесь множество.
Все, спасибо.
