Но прежде чем мы к этому разговору перейдем, как
обычно, по традиции, давайте я вас о задачу или поднимем
некоторую проблему, которую, к сожалению, вот теми средствами
все еще, все еще теми средствами, которые мы с вами изучаем-изучаем,
а у нас решить не получается.
Значит, проблема следующая, давайте вспомним ваше текущее
домашнее задание, в котором вам нужно реализовать
класс String.
Вот класс String реализован с помощью динамически расширяющегося
массива.
Соответственно, давайте я напомню, к чему идея.
Идея в том, что у нас есть некоторый выделенный кусок
памяти, который имеет, который занимает capacity-byte в памяти,
но при этом реально в памяти хранится, но при этом реально
в памяти, ну точнее в качестве полезных элементов строки
хранится всего сайз элементов, да, вот последний, но завершающий
нулевой символ.
Ну для чего это делается?
Для того, чтобы при расширении строки, при добавлении символа
в конец или просто-напросто при конконтинации двух строк
нам не пришлось заново перевыделять память, да, то
есть мы вот этот вот самый гэп между capacity и size, то
есть вот это вот дополнительное пространство можем заполнять
бесплатно, да, просто-напросто добавляя очередные элементы.
Вот.
Ну и, собственно, давайте рассмотрим какой-нибудь
из методов стринга, ну, например, метод resize.
Как реализовать метод resize для стринги?
Ну давайте для простоты предполагать, что resize не
выходит, то есть при изменении размера строки мы не будем
выходить за границы capacity, да, мы не будем выходить за
размеры реально выделенной памяти.
Ну, соответственно, смотрите, что нужно сделатьЧтобы
уменьшить размер до двух?
Ну кажется что нужно сделать всего два действия, да?
Во-первых, нужно size уменьшить до двух, то есть просто
сказать, что теперь мы храним всего два элемента.
И плюс еще какое действие?
Ну да, записать вот здесь вот качество последнего
символа нулевой символ, сказать что вот строка заканчивается
здесь.
knocked по сути всего, да, по сути за два действия
мы уменьшили размер строки.
Окей.
Что нужно сделать чтобы увеличить размер строки?
Ну, соответственно, то же самое, да, то есть грубо
мы говорим, что size теперь у нас вот такой, ну и в конце
мы добавляем нулевой символ.
То есть кажется, что изменение размера в рамках capacity занимает
константное время.
Ну почему?
Потому что достаточно всего лишь изменить значение
poli-size и выставить нулевой символ туда, куда надо.
Хорошо, давайте теперь рассмотрим класс std-вектор.
По сути std-вектор это есть не что иное, как динамический
массив, который тоже может там динамически расширяться,
в котором можно добавлять элементы, ну и так далее
и так далее.
Ну и в целом как бы вектор реализован точно так же
как и string, то есть по сути у него тоже есть выделенная
память размера capacity и есть такая характеристика
как size, то есть сколько элементов массива реально используется,
сколько объектами реально заполнен мой массив.
Ну и кажется, что история тут точно такая же, как
в случае string.
То есть если я вызываю метод resize, то к чему должен приводить
resize.
Но если мы уменьшаем размер, то я просто-напросто меняю
значение poli-size на нужное мне, при этом так как в векторе
нет никакого нулевого символа, ну нулевого символа заполнять
не нужно.
И то же самое происходит при расширении вектора.
Скажем, если мне нужно увеличить вектор до какой-то
величины, я просто-напросто беру size, увеличу вот такой
до нужной позиции и все.
В чем проблема?
Почему на самом деле вектор вот таким вот образом реализовывает
не так эффективно, как string?
В чем у вектора может быть проблема?
Проблема может быть в следующем.
Смотрите, давайте я скажу, что это вектор не просто
вектор, а это вектор строк.
Вектор ваших string-ов.
Что пройдет тогда?
Вот представьте себе, что у меня изначально вот такой
размер, и я уменьшаю размер там допустим до двух.
Ну по сути, по сути, что я делаю, по сути я говорю
что.
В чем потенциальная проблема такого подхода?
Да, представьте себе, что у меня на самом деле изначально
размер, изначально размер size был равен ну не знаю там
тысяче.
Да?
И при этом каждая строка содержала ну не знаю там
порядка там десятки, ну там десятки или сотни тысяч
символов.
Окей?
Вот.
Что произошло, когда вы сделали size равным думам?
Ну когда вы сделали size равным думам, вы предполагаете
что, ну хорошо, вот я забуду про остальные там 998 строк,
да, и буду пользоваться только первыми двумя.
Но при этом реально в памяти что происходит?
Ну реально-то в памяти все эти строки, они остались,
да?
То есть реально в памяти эти строки хранят свою память,
реально эти строки указывают на свою динамическую память,
да?
То есть реально эти строки занимают большое количество
ресурсов на вашей системе.
Понятно?
Поэтому чего бы на самом деле хотелось в отличие от
стринок?
Почему у стринка нет такой проблемы?
Ну у стринка нет такой проблемы потому что стринг
خранит массив символов, там на каждый символ там
тратится буквально один байт, поэтому ничего страшного
нет.
Ну как бы, если я выделал память в капologue, то меньше
чем в капальцете памяти, то не потрачу, вот.
Тут же есть проблема в том, что каждый из этих объектов
потенциально может быть очень большим, да, и он может занимать свои ресурсы в
памяти. Поэтому чего бы хотелось? Ну, скорее всего, хотелось бы следующего
поведения, что когда я уменьшаю размер вектора, я бы хотел, чтобы реально все эти
объекты были уничтожены. Ну, допустим, для каждого из этих элементов был вызов
метод clear. То есть, представьте, что если для каждой строки я вызову метод clear, то тогда
если эти строки были большие, то тогда, соответственно, большого объема памяти у меня
тратиться теперь не будет. Согласны? Вот. Возникает вопрос, а можно ли сделать так,
чтобы, допустим, вот, смотрите, у меня выделен какой-то динамический массив, можно ли
сделать так, чтобы были уничтожены только вот эти объекты, а нужны мне объекты,
остались в памяти. Вот. Можно так сделать или нет, мы пока не знаем. Ну, я надеюсь,
сегодня с этим разберемся. В общем, это первая проблема. Понятно, да? Вторая
проблема. Давайте вернемся к тому, что обсуждали последние два занятия, именно
к методу emplaceback. Я напомню, что у вектора есть метод emplaceback, который принимает
параметры конструктора, с которым нужно создать новый элемент внутри вектора. И
давайте подумаем, как его можно реализовать. То есть, смотрите, что мы поняли? Мы, на самом
деле, поняли, что emplaceback может принимать произвольное количество параметров, потому что
мы заранее не знаем, сколько параметров конструктора, какими параметрами конструктора
мы должны создать объект внутри вектора. Мы поняли, что аргумент Aloj нужно передать по
универсальной ссылке, потому что какие-то аргументы мы хотим передать по ссылке.
И аргументы мы хотим передать по правой ссылке. И универс분сет dragging позволяет нам
добиться целого. Давайте подумаем, что нужно сделать. Давайте я опущу момент с
реаллокации. Понятно, что вот, при необходимости...
происходит какая-то реаллокация. Если вдруг мне памяти не хватает,
не хватает. Я должен выделить кусок большего размера и, соответственно, работать уже с ним.
Давайте с момента опустим. Давайте перейдем к моменту вставки элемента в массив.
Как отсчетить вставку элемента в массив с вот такими параметрами конструктора?
Давайте я предложу свое решение. Вот у меня есть некоторый массив,
буфер. И я в ячейку size записываю вот такую величину.
Ну и тут еще делаю плюс-плюс.
Как вам такое решение? Ну, смотрите, если у меня изначально размер вектора был
равен size, то при добавлении нового элемента я добавляю в ячейку под номером size новый объект.
То есть вот я тут создаю объект, записываю его вот сюда, ну и затем увеличиваю размер вектора на
единицу. Что не так в предложенном решении?
Да, смотрите, первая проблема в чем? Чего мы хотели? В чем смысл emplaceback?
Смысл emplaceback? Создать объект сразу же в нужном месте в памяти, так?
А что тут за операция используется? Да, это присваивание, согласны? Это не конструктор, это
присваивание. То есть я сначала создаю объект, а потом вызываю присваивание вот в эту ячейку в памяти.
Понятно? От проблемы я не избавился. То есть я напомню, что emplaceback нужен был для того,
чтобы мы могли избавиться от лишнего перемещения и лишнего копирования. Вот тут от лишнего
перемещения и копирования мы не избавляемся. Да, почему? Потому что тут мы создаем временный
объект, а потом его либо копируем, либо перемещаем в эту ячейку. Ну, зависит от того,
есть ли у меня у класса T перемещающий присваивание или нет. Согласны? Вот, то есть я не решил ту
проблему, которую ставил изначально. Я бы хотел, чтобы этот объект сразу же оказался в этой ячейке,
а не посредством присваивания какого-то. Понятно? То есть вот смотрите, вот тут чего бы я хотел. Я бы
хотел каждую отдельную ячейку удалять по отдельности. А вот тут я бы хотел каждую отдельную ячейку
создавать тоже по отдельности. Понятно? Но пока такого я делать не могу. Хорошо. На самом деле,
это не все проблемы. Какая-то еще проблема есть. Да. В каком плане уничтожение мусора?
Понятное дело, если есть такая ячейка, то предполагаю, что там хранится какой-то
корректный объект. Но тут другой вопрос, что у элемента может не быть конструктор по умолчанию,
поэтому непонятно, как мы изначально вообще этот объект создали. Давайте предположим,
что там конструктор по умолчанию есть, и присваивание тоже работает корректно,
то есть присваивание все очищает. Давайте вспомним прошлое занятие. Что тут не хватает?
СТД forward. Смотрите, у меня вот этот конструктор T, вот когда я ему передаю ARX. ARX это переменные.
Когда я передаю переменные, что я передаю? Я всегда передаю lvalue. Чего бы я хотел? Я бы хотел,
чтобы если меня в качестве какого-то аргумента передали lvalue, я хотел бы и дальше передать
lvalue. А если меня в качестве какого-то аргумента передали rvalue, я бы хотел и дальше передать
rvalue. То есть, точнее, STD move вот этого аргумента. Как мне этого достичь? Используйте STD forward.
То есть, так как я принял тут все по универсальной ссылке, то и дальше я должен передавать с помощью
STD forward, чтобы сохранить категорию значения, которое передавалось мне сюда. ARX, в круглых скобках,
ARX и многоточие. Проблема обрисована. Непонятно, как удалять отдельные ячейки массива не удаляя
весь массив целиком. И непонятно, как создать элемент в ячейке массива, не создавая там массив
целиком. Понятно? То есть, можно ли работать с отдельными ячейками массива и создавать и удалять
объекты посредством конструкторов и деструкторов. Давайте пойдем к достижению этого
результата. Для начала давайте посмотрим на несколько демонстраций, просто чтобы понять,
как удосовериться, что все понимают, как работает vector. Первая демонстрация очень
простая. Тут просто нам демонстрируется какая-то самая разница между size и capacity. Не знаю,
стоит на ней долго задерживаться или нет, но давайте. Да, давайте. Нормально? Ну, окей.
Так, запустим программу. Видим, что вместимость и размер вектора не одно и то же. То есть,
когда я добавляю элементы в вектор, у меня размер всегда увеличивается на единицу. То есть,
я добавляю новый элемент, новый элемент, новый элемент. Но при этом вместимость в вектор растет
нелинейным образом. Вместимость всегда больше равна, чем размер вектора. Мы видим,
что тут на 8 вставок всего 4 переведеления памяти. Как правило, вместимость вектора
увеличивается в полтора-два раза, чтобы прошло достаточное время между двумя последовательными
переведелениями памяти. Следующая демонстрация про резеров, про разницу между resize и резер.
Напомню, что resize меняет сам размер вектора. Размер вектора именно в том смысле,
количество элементов, в котором в нем реально хранится. Я хочу сказать, что в векторе теперь
хранится 100 элементов или векторе хранится 5 элементов. А резерв управляет непосредственно
хранилищем вектора. То есть, сколько элементов потенциально может вместить вектор без переведеления
памяти. Трюк заключается в том, чтобы, если вдруг вам заранее известно количество элементов,
которое будет храниться в векторе. Классическая история, когда вы создаете пустой вектор,
а потом просто в цикле заполняете его с помощью pushback. Понятное дело, что pushback в амортизованном
смысле работает за отъязнице. Этот цикл отработает за линейное время, все хорошо. Но если вы заранее
знаете, что у вас в векторе будет храниться n элементов, возникает вопрос, зачем вам лишнее
переведеление памяти. Мы уже с вами понимаем, что если мы добавляем элементы в вектор, то в какой-то
момент вектор переполнится, и он перевыделит память, и будет дальше стрелять элементы.
Чтобы не происходило лишних переведелений памяти, мы можем с их экономить с помощью операции
резеров. Мы говорим, давайте сначала зарезервируем память под хранение n элементов, а уже потом будем
эти самые элементы вставлять в вектор. Тут демонстрация, которая проверяет время работы
двух функций. Первая функция работает без использования резерва, вторая функция вставляет
n элементов с использованием резерва. Сначала я делаю резерв, а потом же вставляю n элементов.
Давайте посмотрим, к чему это приведет.
Видно, что в целом с резервом программа работает примерно в полтора-два раза быстрее, чем без использования резерва.
Резерв на самом деле в полтора-два раза увеличивает скорость программы, потому что при переведении
памяти вектору необходимо брать все элементы и перекопировать их в новый буфер. Но это требует
примерно в два раза больше времени, чем без использования перелокации памяти. Поэтому стоит
активно пользоваться резервом, это ваш друг. Традиционно я показываю некоторый анекдот,
который я видел достаточно давно. Когда-то давно, когда мне еще было время смотреть на
работы студентов, я заметил одну вещь. Вот такая реализация вставки элементов вектор. Что тут
происходит? Содается пустой вектор, а дальше в цикле резервируется память под vsize плюс один
элемент, и дальше вставляется элемент один. Что этим кодом хотел сказать студент? Перед тем,
как вставить элемент, мне нужно гарантировать, что перед вставкой нового элемента мне будет
достаточно памяти, чтобы его вставлять. Поэтому строчка v.reserve vsize плюс один выглядит довольно
таки разумно. Давайте я скажу вектор сначала убедить, что тебе хватит памяти для хранения
size плюс одного элемента, а потом этот элемент вставь. Но в чем тут проблема?
Да, проблема в том, что если изначально у вектора была вместимость 0, путем вызова
reserve 0 плюс 1, он выделил память для одного элемента. Потом при вставке второго элемента выделил
память для двух элементов, дальше для трех, для четырех, для пяти и так далее. То есть на самом
ли вместо ускорения получается значительная просадка. Давайте уменьшим количество данных,
и запустим. В общем видно, что с резервом и без резервов все отработал, например,
за 100 тысячные доли секунды. Слабая реализация отработала за 10 тысячные доли, но если увеличить
данные, то разница будет еще более заметна. Тоже какие-то доли секунды по сравнению с уже сотыми
долями секунды. Необходимо понимать, как устроена динамическая реаллокация, как устроен
резерв, чтобы не выпускать таких проблем. В общем, если вы не знаете, как пользоваться резервом,
то лучше довериться вектору, и он самостоятельно все сделает. Ну и наконец последний пункт, который уже
непосредственно связан с тем, что мы только что обсуждали. Как раз какие-то самые разницы между
резервом и resize. Напомню про что мы говорили. На самом деле resize вектора устроен не совсем так,
точнее совсем не так, как resize для строки. Для resize строки вам достаточно всего лишь поменять
значение поля в строке. То есть сказать, что size равен сотне или там size равен двум, и так далее.
Для вектор это не так, потому что потенциально, если вы будете поступать таким образом, у вас
потенциально в памяти будут висеть какие-то большие куски памяти, большие объекты, которые будут
занимать большое место и тратить ресурсы вашей системы. Поэтому на самом деле resize выполняет
не тривиальную работу. Давайте на нее посмотрим. В чем состоит демонстрация? У меня есть
некоторая структура или класс, которая умеет сообщать о том, когда он создается и когда он
удаляется. То есть при вызове конструктора по умолчанию вызывается, ну печатается на экран
конструктора, при вызове деструктора печатается на экран destroy. То есть при создании объекта,
то есть объекты сообщают о том, когда они созданы, когда они были созданы, когда они были уничтожены.
Дальше у меня есть вектор, и соответственно с вектором я совершаю буквально четыре операции.
Первая операция – это операция reserve. То есть я говорю вектор и зарядирую память под хранение 100
элементов. Дальше скажу вектору сделай resize на 5 элементов, то есть добавь 5 элементов вектор,
потом скажу вектору избавься от последних трех элементов, ну и в конце скажу вектор очистить свою
память. Давайте посмотрим, к чему это все привело. Давайте наблюдать забавные вещи. Смотрите,
когда я сделал reserve 100, что произошло? После вызова reserve 100 реально не было создано ни одного
объекта типа S. Понятно? То есть я вызвал reserve 100, но при этом реально было создано 0 объектов. То есть
что произошло? Память была выделена, но объектов никаких в векторе создана не было. То есть reserve
реально управляет только памятью, но не созданием самих объектов. Поэтому когда вы делаете reserve,
создание никаких объектов на самом деле не происходит. Reserve выделяет просто-напросто память,
ну вот просто-напросто нужное количество байт, чтобы можно было сохранить нужные элементы.
Что происходит дальше? Дальше вызываю resize от 5. После вызова resize от 5, вот только после этого,
как я сказал, что вектор должен хранить 5 реальных объектов, начинаются создаваться те самые объекты
на нужных участках памяти. Вот сейчас все были вызваны 5 конструкторов по умолчанию. Вот что
произошло после того, как вызвали resize 2? Смотрите, опять же, я напоминаю, что если бы мы работали
в парадигме строки, то нам было достаточно просто-напросто ставить равно 0 и все. И здесь же,
помимо того, что size выставляется в значении равном 2, вызываются 3 деструктора. То есть
ненужные элементы удаляются. Этот элемент удалился, этот и этот. То есть в векторе реально хранится
ровно два объекта. Ну и, понятное дело, после вызова метода clear остальные элементы тоже
уничтожаются. Ну и собственно наша цель на сегодня научиться этим самым трюкам, научиться делать так,
чтобы в той памяти, которую вы выделили, можно было отдельно удалять элементы, отдельно создавать
элементы. В общем, вручную управлять временем жизни объектов. Есть ли вопросы по демонстрациям?
Окей, тогда давайте начнем. Первый вопрос на ваших экранах. Вам представлены три операции или три
выражения? newt, newt.xy, newt.n. Кто делает эти три операции? Давайте начнем с первой. Вот я вызываю newt.
Что при этом происходит в вашей программе? Так, создается объект. А где он создается? Так, ну смотрите,
чтобы у меня была динамическая память, нужно, чтобы ее мне кто-то отдал. Да? Откуда она у меня
берется? Ну, то есть смотрите, что на самом деле делает newt? newt делает две вещи. Первое,
запрашивает операционную систему и динамическую память, так? То есть выделяем память. Все.
Операционная система или мой менеджер памяти мне выдал size of tab by памяти. То есть он сказал,
вот это моя память, но в ней пока ничего не лежит. Просто в ней заполнен какой-то мусор. Хорошо,
что происходит дальше? Да, дальше создается t по умолчанию. То есть тут создается объект
с пустыми круглыми скобками. Вот. Окей. Теперь вторая строчка отличается от первой.
New t xy делает ровно то же самое, но только во втором пункте создается t с параметром x и y.
Согласны? То есть разница между первой и второй строчки заключается всего лишь в том, что в первом
случае создается t по умолчанию, во втором случае создается t с параметром x и y. При этом первый
пункт остается неизменным. То есть программе обязательно нужно выделить память для хранения
вот этого самого объекта. Так, ну и наконец третий пункт. Так. Да. То есть выделяется память для
хранения n элементов типа t. Вот size of t x n. Затем вызывается n конструкторов по умолчанию. Вот. То
есть вызов выражения new неизбежно приводит всегда к двум вещам. Первое это выделение памяти,
второе это вызов конструкторов. Окей? Так. Тут может возникнуть следующий вопрос. Смотрите,
когда я делаю резер, вот я делаю v точка. Резер 100. Ну смотрите, вектор же тоже выделяет память,
так? Но при этом помните прошлую демонстрацию. Что мы видели? Мы видели, что при вызове резер
ни одного конструктора вызова не было. То есть как будто второй пункт пропускается. Как так? В общем,
как непонятно. Ну будем разбираться. В общем, вызов стандартного выражения new приводит к тому,
что у вас выделяется память, а потом по этой памяти создается объект, ну или несколько объектов,
в зависимости от того, какую версию new с квадратными скобками или без квадратных скобок вы вызываете.
Вот. Соответственно, тут возникают два вопроса. То есть так как new обязательно приводит к вот этим
двум пунктам, собственно, вопросы следующие. А можно ли выполнить только первый пункт без второго?
Можно ли как вектор просто выделить память, но при этом не создавать там никаких объектов? Ну и наконец
второй вопрос. А вот допустим, у меня откуда-то память есть. Ну вот откуда-то. Просто спустилось
небес. Можно ли вот в этой памяти создать какой-то объект t? Какой я хочу? Так. Собственно, давайте
разбираться с этими вопросами и ответим на первый из них. Можно ли выделить память,
не создавая там никакого объекта? Ответ да, но с некоторыми нюансами. Давайте пойдем в
хронологическом порядке. Значит, давайте вспомним язык c. Вот. Точнее сделаем небольшой обзор язык
c. Вот. Понимаете, в языке c нет никаких операций new и delete. Вот. В языке c для выделения памяти
используется функция, которая называется stdmalloc. А для очищения памяти используется функция stdfree.
Вот. В чем особенность этих функций? Особенность функции stdmalloc заключается в том, что эта
функция тупо выделяет память в том объеме, который вам нужно. То есть stdmalloc это функция,
которая принимает на вход количество байт, которое нужно выделить в памяти. Вот. При этом эта
память просто, при этом эта память, ну, собственно, является просто, например, с некоторым набором байт,
которая ничем изначально не заполнена. Вот. То есть stdmalloc, на самом деле, абсолютно ничего не знает
про типы, которые вы будете хранить по этому месту в памяти. Вот. Поэтому ответ на вопрос, можно ли
просто-напросто выделить память, не создавая никаких объектов, ответ на этот вопрос утвердительный.
Ну, например, про использование функции stdmalloc. Вот. Ну и, соответственно, есть функция stdfree,
которая вызывается по указателю, для которого вы изначально вызывали malloc. Ну и, соответственно,
он ощущает, ощущает эту самую память. Вот. У malloc есть проблема. Ну и, собственно, одна из, одна из
проблем, как раз таки, заключается в том, что stdmalloc ничего не знает про типы данных. Да, вообще,
то есть, когда вы говорите, что нужно выделить какую-то память, stdmalloc возвращает вам указатель
на бой. Ну потому что он не знает, что вы там будете хранить. Поэтому, если вдруг, там, вы по этому
адмису памяти захотите хранить int, то прежде чем использовать эту память, вам нужно сделать,
грубо говоря, static cast вот этой самой памяти к int указателю. Вот. Ну и плюс, на самом деле, malloc
очень хорошо дружатся new и derit, но можно считать, что они просто-напросто используют, в общем,
они используют разные стратегии выделения памяти, и поэтому смешивать их там с C++ стилем
выделения памяти не стоит. Это вот чистый экскурсс историю. Значит, вопрос следующий. Можно ли добиться
примерно того же, что и malloc и free в языке C++? То есть используя чистый инструмент C++. Значит, ответ
тоже да. Значит, можно сделать следующим образом. Ну, смотрите, что мы знаем? Мы знаем, что когда я
выделяю память с помощью new, у меня выделяется память и создается объект по умолчанию. Вот. Ну,
собственно, вопрос, можно ли просто выделить память, не создавая никакого объекта? Ну, давайте применим
следующий трюк. Давайте просто-напросто выделим память и будем выделять ее не как память для
конкретного объекта, а будем выделять память, допустим, для char. Ну, char не занимает один byte,
поэтому сколько чаров я выделю, столько byte там будет храниться вот в этом месте памяти. Или,
собственно, в языке, ну, в стандарте языка C++17 появился такой тип, как std byte. Ну, std byte,
на самом деле, это просто-напросто, по-моему, псевдоним для char или unsan char. Ну, в общем,
так или иначе, std byte хранит в себе всего лишь один byte, поэтому, если я выделяю массив из size2t
byte, то как раз-таки у меня выделится память для хранения одного элемента типа T. Ну, или если
я выделю память для хранения size2t умножить на n byte, у меня будет достаточно памяти для хранения n
элементов типа T. Ну, в общем, так или иначе, трюк заключается в следующем. Давайте я просто-напросто
выделю массив из char или массив из byte, и вот этот массив byte буду использовать в дальнейшем как
там массив для хранения объектов типа T. Понятно? То есть, если я выделю память для хранения массива
byte или для хранения массива char, то я всего лишь выделю память, а потом уже в дальнейшем по этому
месту в памяти могу создать какой-нибудь объект. Окей? Вот. В чем проблема такого подхода? Ну,
проблема такого подхода масса, и на самом деле такой подход на практике не используется. Почему?
Потому что, по следующим причинам, когда вы вызываете new std byte от чего-то, а понятное дело,
что new возвращает вам указатель на, собственно, std byte или new возвращает указатель на char. Вот.
Чтобы получить из этого указателя указатель на нужный вам тип, ну, в частности, тут приводится
все указатель на void, вы должны применить к нему статикаст или какой-нибудь другой каст,
который вам нужен. Вот. Это первая проблема. Вторая же проблема заключается в следующем. Смотрите,
мы с вами говорили о том, что для любой памяти, которая выделена с помощью new, нужно вызвать
соответствующий delete. Вот. Поэтому, если вы выделяли память с помощью new std byte и так далее,
то вам нужно очистить память тоже с помощью delete. Вот. Но проблема тут заключается в следующем.
В delete вы обязаны подать указатель именно того типа, который выделяли с помощью new. Ну,
пример. Вот. Допустим, вы выделили память new a. Но при этом сохранили указатель на a. Давайте тут
какой-нибудь статикаст. Я скастовал это все, допустим, к моему указателю. Вот. А потом пишу
delete p. В чем тут проблема? Проблема в том, что new на самом деле выделал память для хранения
элементов типа a. Вот. И new ему как-то сохранить эту информацию для того, что, например, потом delete
было понятно, а сколько byte нужно удалять, что какой объект нужно удалять и так далее. Ну,
а если вы в delete подойдите к указателю p, который на самом деле имеет тип 8 с звездой, то у delete
будет практически ноль шансов понять, что на самом деле по этому указателю лежит объект a. Понятно?
То есть delete на самом деле опирается на тип самого указателя, которого вы удаляете. Если delete
видит перед собой указатель на a, тогда он будет удалять этот объект как объект типа a. Если он
перед собой видит указатель на b, тогда он будет удалять этот указатель как объект типа b и так
далее. Вот. Поэтому если вы изначально выделяете память с помощью new std byte и так далее, то и удаляете
указатель вам тоже нужно как указатель на std byte. Вот. Поэтому перед тем, как делать delete, вам
необходимо будет сделать кстати cast std byte со звездой от там single или от array. Понятно? Вот. То есть
один из входных путей, один из входных путей, то есть как выделить память, но не создавать при этом
объекта, это использовать new от там стимульного типа, то есть char или new от std byte. Но при
этом у этого есть много недостатков и на самом деле такой подход тоже никак не используется. Вот.
Какой подход используется на самом деле? Давайте познакомимся с функцией оператор new. Значит,
в gt++ есть функция, которая называется оператор new. Вот именно оператор new в два слова. Вот.
Что это за функция? Оператор new ведет себя похожим образом, как и домолог. Оператор new в качестве
своего аргумента принимает количество byte, которое нужно выделить и по которому нужно получить
указатель. Окей? То есть если мне нужно выделить память достаточную для хранения size of t byte,
то я вызываю оператор new от size of t. Если мне нужно выделить количество byte достаточно для
хранения n элементов типа t, то я вызываю оператор new с size of t умножить на n. Вот. При этом оператор
new возвращает void со звездой, принимает size of t и количество byte, которое нужно выделить. Вот.
Окей. Значит, у оператора new есть антипод, который называется оператор delete. Это тоже функция. Эта
функция является в некотором смысле аналоговым функциям SD-free. Оператор delete принимает указатель,
ранее выделенный с помощью оператора new, ну и выполняет очищение памяти. Вот. В чем особенность
этих функций? В чем особенность функции оператор new и оператор delete? В чем преимущество перед
stmolok и stfree? Несмотря на то, что они по синтаксису очень сильно похожи, то есть stmolok и std и
оператор new принимают количество byte, которое нужно выделить, stdfree и оператор delete принимают
указатель, который нужно очистить. Вот. Оператор new и оператор delete максимально согласованы с
обычными выражениями new и delete, которые приняты в UTS++. Они настолько согласованы, что на самом деле,
когда вы вызываете new, когда вы вызываете new от t, выделение памяти, вот этот самый первый шаг,
происходит как раз таки с помощью вот этой самой функции оператор new. Вот. То есть на самом деле,
на самом деле, давайте еще раз повторю, когда вы вызываете new t, ну там допустим какие-то параметры x и y,
первым делом компилятор вызывает вот эту функцию. Первым делом компилятор вызывает функцию оператор
new, которая выделяет столько byte сколько вам нужно и возвращает указатель на эту самую динамическую
память. Окей? Вот. То есть мораль. Выделение памяти происходит с помощью специальной функции,
которая называется оператор new. Вот. Поэтому если вам необходимо выделить память, не создавая объект,
то вы можете вызвать функцию оператор new и вы получите тот эффект, который вы хотите. То есть
без создания какого-либо объекта, просто нам выделится нужное количество byte. Вот. Окей. Так.
Кажется, мы не поговорили про delete. Давайте исправимся. Про него тоже скажем несколько слов.
Что происходит, когда я вызываю delete p? Да. Первым шагом вызывается инструктор,
а вторым шагом освобождается память. Ну и давайте ли полноты пропишем, что происходит,
когда я вызываю delete с квадратными скобками. Ну, на первом шаге вызывается n деструкторов,
и во втором шаге освобождается память. Так вот освобождение памяти происходит с помощью функции
оператор delete. Вот. То есть на самом деле под капотом, когда вы вызываете выражение new,
первым делом вызывается функция оператор new. Когда вы вызываете delete, первым делом вызывается
деструктор, а потом вызывается функция оператор delete. Понятно? Вот. Если вам не нужно вызова
конструктора или если вам не нужно вызова деструктора, вы можете просто вызывать оператор delete или
оператор new. Окей? Сам по себе оператор delete просто-напросто освобождает память. Ну, когда вы
вызываете new, вам операционная система выделяет память искучен, то есть как, скажем, свободную
память, которая есть в системе. Вот. А оператор delete эту память возвращает обратно. Говорит,
что все, эта память ей не нужна. Окей? Так. Есть ли вопросы? Окей. Так. Ну, собственно, да. По аналогии
с функциями оператор new и оператор delete, есть также функция оператор new с квадратными скобками и
оператор delete с квадратными скобками. Ну, я надеюсь, вы понимаете, что соответствующие функции вызывают,
когда вы вызываете new с квадратными скобками, когда вызываете new takes p от n,
и когда вызываете delete с квадратными скобками nodep. Вот. То есть, когда вызываете u без
квадратных скобок, то вызывается функция оператора new без квадратных скобок, а когда вызываете
u с квадратными скобками, вызывается функция оператора new с gelatinous скобками. Ну, и
Та же самая социальность с оператором delete.
Тут может быть один вопрос, а зачем вообще нужны две версии функции?
Зачем нужна версия оператора new с квадратными скобками, зачем нужна версия new без квадратных скобок?
Идея заключается в том, что вот этому delete, когда он будет вызван,
ему нужна какая-то информация о том, а сколько элементов на самом деле там хранится под указателем,
то есть сколько деструкторов ему вызывать.
И на самом деле оператор new с квадратными скобками выделяет не ровно n byte,
а выделяет чуть больше памяти для того, чтобы оператору delete было понятно,
сколько потом деструкторов нужно будет вызывать.
Но это чисто деталь реализации, это деталь компиляторов,
которая зависит от конкретной реализации, то есть не документирована стандартом.
В общем, важно понимать то, что при вызове обычного new вызывается функция оператора new
без квадратных скобок, а при вызове new с квадратными скобками вызывается new с квадратными скобками.
Та же самая история с delete.
Окей?
Да.
Нет, у меня кажется, да, тут есть демонстрация, давайте посмотрим.
Так.
Вот, смотрите, тут демонстрация, я выделяю память с помощью new,
вот, и дальше делаю вещь, которую на самом деле с C++ делать нельзя,
ну в смысле по стандарту, вот, но я рискнул, вот, и все получилось.
В общем, в некоторых реализациях, то есть большинство реализаций компиляторов с C++,
они хранят вот эту самую информацию о том, сколько элементов было выделено с помощью new
в ячейке, которая находится позади от массива.
То есть, например, когда вы вызываете new t от n,
а что при этом происходит?
Выделяется память для хранения n элементов, но на самом деле, на самом деле выделяется не...
Ну на самом деле выделяется не только эта память,
на самом деле выделяется памяти на 8 байт больше, чем вам нужно, вот,
а что хранится вот в этих дополнительных 8 байтах?
Вот в этих дополнительных 8 байтах кратк pays хранится информация о том,
колька элементов у вас было выделено.
То есть, тут на самом деле хранится вот это самое число n, вот,
new возвращает вам указатель вот на эту ячейку памяти, то есть new с квадратными скобками
выделяет вам памяти на 8 и больше, возвращает указатель вот на начало вот этого куска кода,
а потом когда вы вызываете delete, delete уже смотрит вот сюда, понимая сколько элементов тут на самом
деле находится и для всех них вызывает деструктор, вот дальше эта память само ощущает, окей, ну давайте
заглянем, посмотрим так ли это, ну вот я собственно выделяю память с помощью new с квадратными скобками,
вот 6969 элементов, вот и соответственно затем кастует указатель к sizeT и говорю, что считай, что этот
массив содержит sizeT, содержит элементы типа sizeT и посмотри на один шаг назад, какой там
элемент хранится, это new delete, вот, ну собственно вот то самое число, если я это число буду менять,
ну там назовите кое-нибудь, чтобы не было 37, спасибо пацанной человек, так, значит g++,
ну вот собственно 37, то есть на самом деле new с квадратными скобками сохраняет дополнительную
информацию, вот именно поэтому оператор new и оператор delete имеет две формы, то есть обычный
оператор new, он эту информацию не сохраняет, оператор new с квадратными скобками, он там еще
дополнительно сохраняет информацию о том, сколько элементов потом нужно будет удалить, ну это просто
для функционирования там корректного удаления с помощью delete, окей, так, давайте пойдем дальше,
теперь несколько откровений, на самом деле c++ существует не одна функция оператора new,
на самом деле их несколько, вот, значит вот это самая стандартная форма выражения new, ну вы
просто пишете new, дальше справа указываете объект, который нужно создать и он выделяется
памяти, он создается, вот, но на самом деле new можно вызвать кучей разных способов, ну и соответственно
для каждого new есть соответствующая функция оператор new, в частности, ну вот, собственно первая,
самая первая версия оператора new, это там стандартная классическая форма new, которая, ну
которая вызывается, когда вы используете обычный new стипом, да, то есть он просто принимает количество
байт, которое нужно выделить, вот, ну и выделяет ровно такое же количество байт, вот, вторая форма
оператора new принимает дополнительный параметр std off-road t, что это за параметр? Это параметр,
который говорит просто наоборот о том, что данная операция new не должна бросать исключений,
ну, строго говоря, про бросание исключений мы с вами не говорили, но наверняка вы, может, не сталкивались,
но по крайней мере слышали, что произойдет, если вы попытаетесь выделить памяти больше, чем есть
у вас в системе. То есть, когда, допустим, вы выделяете new t от, ну там, не знаю, и куча куча куча нулей, вот,
ну возникает вопрос, что должно происходить, если new не может выделить нужное количество памяти.
Ну, в этом случае ваши программы, скорее всего, падали, и там на экране вы видели что-то типа std
battle log, вот, значит, это называется исключением, про исключение мы еще в рамках нашего курса поговорим,
вот. Что означает этот параметр std null throw? std null throw говорит о том, что если вдруг у вас память,
если вдруг операция new завершится неуспешно, то есть, если вдруг new не сможет выделить столько
памяти, сколько вы попросили, вот этот new не должен бросить исключения, а он должен вернуть null ptr, понятно?
Вот, то есть, если я вызываю то же самое, но вот в таком формате new std null throw, вот, то в случае,
то в случае, если вам, если у вас на системе не хватит памяти, в общем, у вас программа не будет
памяти, она просто будет возвращать нулевой указатель, вот, но тогда вам просто достаточно будет
проверить, если p null ptr, то значит, не хватило памяти, и так далее, вот. Теперь смотрите, что это такое,
что это такой синтаксис? new, дальше круглые скобки и так далее, посмотрите, в общем случае история такая,
если я пишу new a, b, c, потом t, x, y, z, это означает следующее, первый шаг, вызвать пункцию оператор new
с параметрами size of t, a, b, c. В общем, история следующая, на самом деле new может принимать дополнительные
параметры, вот, и эти дополнительные параметры как раз такие будут переданы функцию оператор new,
понятно? То есть, например, вот самая первая версия функции оператор new, она не принимает никаких
параметров, но это, собственно, наша самая старая классическая форма вызова new, вот, то есть вызова
new без параметров вызывается первая версия функции оператор new, которая просто принимает размер
памяти, которую нужно выделить, вот. Вторая версия оператор new принимает один дополнительный
параметр, вот он std not throw, да, вот то, что написано на самом верху, вот на той доске, я передаю параметр
std not throw, и, собственно, этот параметр передается вот вторым аргументом в оператор new, вот. И,
наконец, третья версия оператора, на самом деле, очень много, в общем, самый популярный из них мы
перечисли здесь, третья версия, которая перечислена, она имеет такую форму. Она нам еще сегодня
понадобится. Смотрите, если я напишу вот так, new, какой-то указатель ptr tx y, то вот эта версия
new вызовет первая функцию оператор new от size of t и r, ну а второе, как мы с вами знаем, вызовет
конструктор tx y. Так вот, в чем особенность вот этой самой операции new, которая принимает указатель.
Ее особенность заключается в том, что она не выделяет память. Вот эта версия функции оператора new
не выделяет память. Еще раз, вот первая версия оператора new выделяет count by памяти. Вторая версия
оператора new выделяет count by памяти. Третья версия операции new не выделяет память. Все, что она делает,
это возвращает второй указатель в качестве ответа. То есть, по сути, когда я пишу вот так, я говорю,
не выделяй память, а просто в качестве результатов верни вот этот указатель.
Понятно? Может показаться странным, зачем вообще такая штука нужна, но на самом деле она нам
очень сильно понадобится буквально через несколько минут, окей? Вот, давайте
резюмируем. Операцию new, точнее выражение new на самом деле можно вызывать с
параметрами в круглоскопках. И вот эти параметры в круглоскопке, они будут
передаваться в соответствующую функцию оператора new, в которую в качестве первого
аргумента передается размер вот этого типа t, а в качестве остальных
параметров передаются те параметры, которые передали вот сюда, окей. Нет, ну
смотрите, как происходит, когда вы вызываете new от ABC,
компилятор просто-напросто это переводит в следующий код. Он вызывает оператор new и
дальше передает в качестве первого параметра size of t, а в качестве следующего
параметра вот эти параметры. А дальше происходит обычный выбор
перегрузки функции. То есть можно сказать, что вот эти вот функции оператора new, они
перегружены. То есть в C++ существует много-много-много версий вот этой
функции оператора new. И происходит обычный выбор
перегрузки.
Он скастуется, любой указатель может быть, короче, есть, короче,
любой указатель не явно приводится к указателю вот этой звездой.
А, то есть, получается, у нас будет вот ABC, где-то у нас получается какой-то доказатель,
он сразу скастуется без указатель. Нет-нет-нет. Нет. Ну, смотрите, скорее всего, если вы
передаете просто произвольный набор параметров, то у вас будет ошибка
компилятора, потому что компилятор скажет, что, ну, я не знаю, потому что у меня нет
такой версии оператора new, которая бы принимала эти три аргумента. Тут важно,
чтобы существовала версия функции оператора new, которая
может принимать эти три аргумента. Еще раз, у вас в стандартной библиотеке есть
некоторый набор вот таких вот функций, которые принимает просто count, которые принимает
count.unlpro, которые принимает count.ptr, которые принимает count.
и размер выравнивания, и так далее, и так далее. И вот, в зависимости от того, что вы
передали сюда, будет выбираться следующая версия функции оператора new. Если то, что вы
передали сюда не матчится ни с одним оператором new, то он скажет, что, ну, я
такого new не знаю. Вот. Сейчас. Вопрос. Какой из? Вот этот? Смотрите, вот этот оператор new
это функция. Вот функция, которая называется оператор new. Вот. Вот это new. Это выражение new.
Да, это выражение new, которое использует ключевое слово new. Вот. И, собственно, вот это выражение new, оно
приводит к тому, что вызывается функция оператора new и вызывается конструктор. То есть, функция оператора
new является частью выражения new. Да, выражение new возвращает указатель на t. Оператор new
возвращает указатель. Да. Нет, оператор delete. В оператор delete вы не можете передать количество
байт, ну, сейчас, точнее так. На самом деле, оператор delete, ну, есть версия оператора delete, которая
принимает количество байт, но скорее, ну, стандартный оператор delete, вашу просьбу скорее всего
проигнорирует. Вот. Потому что, если память была выделена куском размером n byte, то именно
куском размера n byte она и будет удалена. То есть, частично освободить память нельзя. Вот. Если вы
выделите память, вот этот ptr, это просто, короче, вот эту версию вы говорите следующее, что давай-ка
всех обманем и выделять память на самом деле не будем, но вместо выделенной памяти вернем ptr. Вот. То
есть, вот эта версия new памяти не выделяет. Она лишь возвращает вот этот указатель, который был
переносит сюда. Точнее, вот эта версия оператора new, она памяти не выделяет, лишь возвращает нужный
указатель. Так. Да. Сейчас еще раз. Какой сценарий давайте установим? Типа, я пишу new tn,
так? Ну, в смысле вы про то, что если вот эта вот память, в которой хранится вот эта штука,
если ее изменить, то все будет плохо. Нет, нет, естественно ошибки не будут. То, что я показал,
то, что у вас там выделяется память, но на самом деле там за этой памятью там находится что-то,
это на самом деле я рассказал по секрету и вы этого знать не должны. То есть, эту информацию на
практике использовать никак нельзя. Это просто я показал прикольчик такой. Вот. В общем, вот так
реализовано. Вот так получилось. На самом деле с точки зрения C++ то, что вам вернул new, ровно
этот указатель, ровно эту память, вы имеете право использовать. Если вы пойдете куда-то назад,
undefinedBehaviour. Если вы идете куда-то за границу массива, тоже undefinedBehaviour. Все,
что можете делать, это пользоваться только вот этой вот памятью. Вот. Окей? Ну и изменять,
естественно, тоже нельзя. Ну то есть, скорее всего, у вас получится, но на практике скорее всего это
приведет к тому, что действительно у вас там вызовутся не все деструкторы. Вот. Но вообще это
неопределенное поведение, то есть произойти может вообще все что угодно. В том числе и,
ну, кстати, ошибка меряется тоже вполне может быть, хотя очень маловероятно. Так. Есть еще вопросы?
Да. Так нет. Так какая разница? Язык C++, ну, как бы, смотрите, вот, опять же, константы существуют
только в вашем воображении и в воображении языка C++. Вот. В самой памяти, в самой памяти как таковых
констант нет. Ну, в смысле, понятное дело, есть там отдельные секции, но вот если вы, если вы
работаете просто над сырой памятью, то там констант нет. Вот. То, что мы называем константными
переменными, это, на самом деле, константы с точки зрения самого языка. То есть, сам язык запрещает
вам их изменять. Вот. Но если вдруг у вас каким-то образом получилось скастовать, ну, у нас, например,
есть такая операция, как ConstCast. Вот. ConstCast говорит, сними константность с этого указателя.
Вот. Если вы, например, сделаете ConstCast, то вполне себе вы можете эту память изменять, и все. Как бы,
эта память выделена вашей программой, и вы, в принципе, вольны с ней делать все что угодно.
Идем дальше. Так. Давайте пару слайдов пропустим, оставим наконец. Давайте перейдем к сути. Смотрите,
что мы научились. Давайте небольшое резюме первой части. Значит, что мы поняли? Мы поняли,
что когда мы называем... Вот таким образом, у меня происходит две вещи. Давайте даже... Ну, ладно,
пусть так. А у меня происходит две вещи. Первое. Вызывается функция operator.mu от size of t. Давайте
с size of t. Что делает функция operator.new? Просто выделяет память. Просто выделяет
память достаточно для хранения вот этого объекта. Что происходит дальше? Вот по этому месту памяти,
которая была выделена, вот в том месте памяти, создается объект txy. Понятно, да? Обычный вызов
new приводит к вызову функоператор.new и вызову деструктора вот именно в том месте
памяти, который был выделен до этого. Почему приводит deleteptr? Первое. Deleteptr приводит к вызову
деструктора t. Да? Сначала удаляется объект t, который находится вот по этому указателю,
а потом вызывается функция operator.delete. И вот эта функция operator.delete просто-напросто
очищает память, которая была там. Ну, очищает в том смысле, что возвращает память, возвращает
ресурсы обратно на персонной системе. Хорошо. Давайте вспомним, ну, вообще говоря, чего мы хотели.
Смотрите, когда я вызываю new, у меня происходит выделение памяти и вызов конструктора. Когда
вызывают delete, у меня происходит вызов деструктора и очищение памяти. А к чему я на самом деле
стремился изначально? Изначально я стремился к тому, чтобы вот эти вот действия, вот эти действия,
делать отдельно друг от друга. То есть я не хочу одновременно и выделять память и создавать
объект. Я хочу просто либо выделить память, либо просто потом когда-нибудь создать объект.
Вот. Как это можно сделать? Ну, смотрите, на самом деле на первый вопрос мы с вами опетили. Что нужно
сделать, если я хочу просто-напросто выделить память без создания какого-то объекта? Просто вызвать
operator.new. Да? operator.new. Вот. Если я хочу просто выделить память, я использую функцию operator.new.
Хорошо. Теперь второй вопрос. Допустим, у меня уже есть какая-то память. Вот.
Вот. Откуда-то мне известно, что есть указатель на память, которая может в себя вместить объект
типа T. Вопрос. Как вот конкретно вот в этом месте, вот конкретно вот в этой памяти создать объект?
Неправильный ответ. Вопрос. Почему ответ неправильный? Да, потому что тут создание объекта,
а потом созданный объект временный либо копируется, либо перемещается сюда. Да? Это первая
причина. Вторая причина состоит в следующем. А кто вообще говоря сказал, что раздоминованный
патериал это корректный объект? А что если там хранится просто какой-то мусор? Тогда вы просто
кому-то мусору применяете операцию присваивания. Это неопределенное поведение. Понятно? Мне хочется
сказать, создай объект не временный, а создай объект вот именно тут. То есть вот-вот-вот у меня есть
место. Вот именно тут сделай мне объект. Вопрос. Как это сделать? Что-то типа статик-каст, элемент.
Ну нет, статик-каст там использоваться не будет. Давайте я переформулирую задачу. В общем, изначально
задача была такая. У меня есть указатель на какую-то память, и мне нужно просто в этом месте память
создать какой-то объект. Вот. Задача такая. Вопрос. Как мне создать объект в памяти, но при этом
не выделять под этот объект память? Вот. Помните, я говорил, что вот эта версия оператора new нам
пригодится? Вот она нам пригодилась. Напомню, эта версия функции оператора new, она уже принимает
готовый указатель и не выделяет никакой памяти. Она просто говорит, хорошо, я возьму этот указатель и
буду считать, что вот этот указатель именно я и выделила. То есть, если у меня есть указатель на
какую-то память, в которую я хочу создать объект, мне достаточно вызвать вот такую операцию new ptr txy.
Почему это сработает? Давайте так. Это чисто выделение памяти, это чисто создание объекта.
Вопрос, почему это сработает так, как надо. Давайте по шагам разберемся. С чего приводит вызов
выражение new? Вызов выражения new всегда приводит к вот этим двум вещам. Давайте посмотрим.
Первое, что будет вызвано, будет вызвано оператор new с параметрами size of t и вторым
аргументом ptr. Так, а что это такая за функция? А вот она. Эта функция оператора new принимает
первым аргументом размер, а вторым аргументом указатель, который нужно подсунуть вместо
выделения памяти. То есть, вот эта версия оператора new, она как реализована? Она просто реализована
как return ptr. Все. То есть, она притворила, что что-то выделила и вернула мне вот этот ptr,
который я ей сам и передал. Вот, окей? И что происходит дальше? А дальше по этому
вместо памяти вызывается конструктор txy. Но так как первый пункт ничего не делает, по сути,
то у меня остается просто создание конструктора, вызов конструктора. Понятно? Есть ли вопрос?
Давайте резюмируем совсем коротко. Вот, если нужно просто выделить память без создания объекта,
я использую оператор new. Если мне нужно просто создать объект в нужном месте в памяти, вот я
хочу сказать, что вот-вот тут, вот именно тут, создай объект. Я использую такую версию выражения
new. Окей? Теперь давайте то же самое, но с delete. Да, давайте то же самое, но с delete. Что нужно
сделать, чтобы просто очистить? Вот, допустим, у меня есть указатель на какую-то память, вот,
динамическую. Что мне нужно сделать, чтобы просто ее очистить, но без вызова деструктора? Допустим,
деструктор там уже был вызван. Как просто очистить кусок памяти, на который указывает ptr? Да,
просто вызываю функцию оператор delete от ptr. Хорошо, теперь, допустим, у меня есть указатель ptr,
который указывает на какой-то объекте pt. Как мне вызвать деструктор без очищения памяти? То
есть сказать, что все, вот уничтожь там объект, но при этом память оставь за мной. Нет, если я
сделаю delete ptr, то он и вызывает деструктор, и очистит память, а я хочу просто вызвать
деструктор. Как мне просто вызвать деструктор? Ответ – просто вызвать деструктор. ptr, стрелочка,
вот. Ну деструктор – это же метод, я же могу его вызвать. Вот. Вот это, собственно, тот самый
единственный случай, про который мы говорили, когда вызывать деструктор вручную осмысленно.
Вот. То есть, если у вас есть указатель динамическую память, и вы хотите этот элемент удалить,
но при этом память не освобождать, вот, только в этом случае можно вручную вызвать деструктор. Вот.
Ну, смотрите, если этот объект указывает на какую-то другую динамическую память, то да,
эта динамическая память освободится, но при этом та память, в которой лежит сам объект t, не удалится.
А, ну, в общем, нет, если t – это какой-то int, то, естественно, деструктору у int нет. То есть,
написать int вот так нельзя. Вот. То есть, естественно, предполагается, что t – это какой-то класс. Вот. Да,
еще один момент. Из этого правила есть исключение. Если у вас функция шаблонная, то есть, если это t –
параметр шаблона, то вот так тоже делать можно. То есть, когда вы будете вызывать, то есть,
когда вместо параметра t будет подставляться int, там, чарн или какой-то примитивный тип,
то ошибка эмпляться не будет. Окей? Вот. Смотрите, в чем была, в чем проблема. Вот,
допустим, у меня хранится в памяти int. Да. Вот. Написать вот так ptr-стрелочка int. Я не могу. Ну,
потому что у int нет деструктора. Это не класс. Да. Вот. Ну, поэтому для примитивных типов вызывать
деструктор не имеет смысла. Ну, у примитивных типов нет деструктора. То есть, эта память либо
просто освобождается, либо просто выделяется. Вот. Но что может произойти? Представить себе
такую ситуацию. Вот я пишу шаблонную функцию destroy. Вот. Я пишу шаблонную функцию destroy,
куда просто вызывает деструктор. p-стрелочка tilde t. Вот. Что произойдет, если я в эту функцию
destroy передам int? Понимаете, если я в нее передам int, то вроде как возникнет p tilde int. То есть,
я как бы вызову деструктор у int. Вот. Но вот для шаблонов есть исключение. Вот в шаблонах так
делать можно. Потому что если при постановке шаблонов, то есть если при постановке t равной int,
компилятор заметит, что тут вызывается деструктор line down, он просто эту строчку выкинет.
Вот. Окей? То есть, вот тут ошибки не будет. Но вот просто так, вот просто без шаблона написать
вот так, нельзя. Если вот эта штука вызывает, если вот эта штука возникает при постановке
шаблонов, то окей, компилятор с этим справится. Так, есть ли еще вопрос? Хорошо. Да, естественно. Вот.
Да, вот если вы либо после этого, либо после этого еще напишете delete ptr, то вы проиграли. Вот.
Потому что delete ptr снова вызовет вот эти две штуки. Ну, смотрите, если вы сначала
сделаете оператор delete, а потом вызовете delete ptr, тогда у вас будет double free. Ну, типа вы будете
вызывать очистку памяти по памяти, которая уже очищена. Вот. Или если вы вызовете delete ptr после
того, как вызвали деструктор, то delete ptr снова попытается вызвать деструктора, это уже будет
второй вызов деструктора по ударенному объекту. Ну, что тоже неопределенное поведение. Вот. Поэтому,
если вы управляете памятью и временем жизни объекта вручную, то обычный delete new использовать
уже нельзя. Да. Да. Да, более того, delete. Можно вызывать только по тому указателю,
который ранее был получен с помощью вызова new. И оператор delete тоже можно вызывать только по тому
указателю, который был получен ранее с помощью оператора new. Вот. А еще такой момент. Ну, он на
слайде, по-моему, есть, но давайте я явно пропишу. Смотрите, вот. Если вы, допустим, написали вот так.
Ну, как-то after p равно оператор new от, ну давайте size of t. А потом написали new p. Кстати,
можно написать вот так. А потом написали delete от p. Вот так делать нельзя, потому что формально вы
выделяли память и уничтожаете ее разными способами. Окей? То есть delete вот такой. Можно вызвать только
для указателя, который был выделен с помощью такого new. И оператор delete вот этот можно вызвать
только для указателя, который был выделен с помощью оператора new вот так. Окей? То есть тут
соответствие должно сохраняться тоже. Понятно? Да. Не, это неопределенное поведение. Так. Да,
собственно, я не сказал, но вот эта форма new, вот эта форма new, которая только создает объект,
но не выделяет память, называется placement new. Ну, placement – размещение, да, то есть размещающая
форма new. Ну, почему размещающая? Потому что она просто берет объект и размещает его в нужном месте
памяти. Ну, на самом деле, placement new называют вообще все версии new, которые не стандартные, но, в общем,
как правило, placement new называет вот только такую версию. Так, давайте вопросы на понимание. Вот,
смотрите, у меня есть два примера. Первый пример такой. Я выделяю обычный массив на стеке, обычный
массив byte размера size of t, и дальше по этому месту памяти вызываю new. То есть просто в этом
массиве располагаю объект типа t. Вот. И второй пример. Я выделяю память с помощью функции оператора
new и по этому месту памяти создаю объект типа t. Вопрос следующий. Ну, про второй случай мы уже
поговорили. Если вы создали объект с помощью оператора new и размещающей формы new, то очищаем
память с помощью деструктора и оператора delete. Вот. Меня больше интересует первый вопрос. Вот, смотрите,
у меня объект располагается на стеке. То есть вот у меня массив создан на стеке. Вот. И я в этом
массиве задаю объект. Вопрос. Нужен ли как-то особенному образом сожрать этот объект, или так,
он хранится на стеке, все для него вызовется корректно? Как вы думаете? Почему? Да, смотрите,
в чем тут проблема? Несмотря на то, что массив object выделен на стеке, если массив выделен на стеке,
то вроде как delete для него вызывать не надо. Тут возникает следующая проблема. То есть сам массив
действительно выделен на стеке. Но компилятор-то думает, что внутри него хранится массив byte,
и поэтому уничтожать он его будет именно как массив byte. То есть как бы, представьте, что вам
дан массив размера 16 байт, и вы говорите, что вот этот массив хранится 16 чаров. А потом вы выходите
из мейна и говорите, ой, а там же хранится мой класс, который занимает 16 байт на самом деле. Ну,
естественно компилятор такой подставы не ожидает. Вот. Поэтому если вы что-то вручную создали, если вы
вручную создали что-то с помощью new, вот такого, то вы должны это что-то вручную тоже удалить с
помощью вот такого деструктора. Окей? Да. Нет, а по дочисткой памяти я понимаю, вот память,
которую выделила мне операционная система после new. Я эту же память иду и возвращаю ей. Вот.
Там вызываем деструктор, просто уничтожается объект. Нет, если этот объект хранил указательно
какую-то выделенную память, то он эту память освободит. Но сама память, в которой находится сам объект,
она не удалится. Вот. Вот. Поэтому, ну, как я уже сказал, в первом случае достаточно просто вызвать
деструктор. Ну, то есть вы вызовете деструктор, то есть удалится объект, который лежал вот в этом
месте в памяти, а сама память освободится автоматически так, как она хранится на стеке. Вот. А тут,
так как мы птр выделяли с помощью функции оператора new, то мы должны ее освободить с
помощью функции оператора delete. Но, правда, перед этим, понятное дело, нужно вызвать деструктор.
Нужно вызвать деструктор. Окей? То есть, вот по сути, вот то, что написано здесь, это то,
что происходит под капотом при вызове вот такого new и при вызове вот такого delete. Просто я это
сейчас делал вручную, и в целом я могу эти два процесса, ну, вот эти два процесса и вот эти два
процесса развести по времени. В один момент времени я могу выделить память, а потом через какое-то
время могу заходить создать объект. И потом я могу в какой-то момент времени удалить объект, и потом
там через какое-то количество операций освободить память. Окей? New и delete это делает одновременно,
то есть, ну, атомарно одной операцией. Окей? Нормально? Да. Ну, нет, атомарно имеет в виду, что мы как,
собственно, вот наш последовательный код туда вмешаться не может. Вот, ну, есть там несколько потоков,
то, естественно, может. Окей. Так, ну и теперь давайте поближе к практике. Собственно, вернемся к
проблеме, которую обсуждали в том начале. Вот у нас есть вектор. Как мы с вами увидели, у вектора есть
несколько приколов. Первый прикол связан с тем, что когда я вызываю v.reserve от сотни, у меня не
вызывает ни одного конструктора. Что при этом происходит внутри вектора? Как у вектора получается
выделить память, но при этом не создавать никаких объектов? Да, вызвать оператор, вызвать функцию оператор
new. То есть он выделяет оператор new от size of t умножить на 100. Вот. Теперь я после вызвания этого
резерв... Говорю, допустим, v.resize3. Что происходит векторе? Как вектор удается вот по этой памяти,
которая у него, которая у него уже ранее была выделена, как ему удается вот в этих чейках
памяти создать три объекта? С помощью placement new. Да, то есть по сути там написано следующее for
int i равно 0, i меньше 3, плюс-плюс i. И дальше я говорю new buffer plus i, ну и создаю t по умолчанию.
Вот. То есть я говорю, что в ячейке памяти buffer plus i, ну буфер это начало массива,
плюс и это и та ячейка массива, вот в этой ячейке памяти нужно создать t по умолчанию. Вот ровно то,
что написано сверху. То есть как выделить, то есть вопрос, как выделить капасити памяти,
но при этом создать size объектов? Вот как. Я создаю буфер с помощью оператора new, а потом в цикле
просто создаю нужное количество объектов. Вот. И получается, что память у меня выделена
под капасити объектов, но при этом количество реально созданных объектов равно size. Вот. Но
и аналогично при удалении. Что делать, если у меня в массиве реально создана size объектов,
но при этом память выделена под капасити? Ну, собственно, я вот в цикле удаляю эти самые
size объектов, то есть для каждого элемента вызываю деструктор. Вот. А потом просто вызываю оператор
delete и очищаю ту самую память, на которую указывает буфер. Вот. Окей? Да.
Ну, чтобы выделить память, нам же нужно выделить память для хранения капасити элементов. Ну, тут
скорее вопрос про то, как сделать так, чтобы у меня было выделено памяти для хранения капасити
объектов, но при этом реально было заполнено только size из них? Если я сделаю вот так,
если делаю new t от capacity, то у меня будет выделена память под капасити элементов,
но при этом каждый элемент будет создан с помощью конструктора по умолчанию. А я хочу, чтобы были
созданы не все элементы, а только size из них первые. Так, а разница большая, потому что сам
элемент типа t, но представьте себе, что каждый элемент типа t хранит указатель еще на какую-то
выделенную память. Ну или так. Представьте себе, что создание элемента t занимает очень много
времени. Но тогда я не хочу тратить лишнее время на создание объектов, которые мне пока не нужны.
Вот. На самом деле, тут есть еще другой момент. Смотрите. Представьте себе, что у типа t
нет конструктора по умолчанию. Что тогда? Что произойдет, если у меня у t не будет конструктора
по умолчанию? Тогда я просто не смогу выделять вот такую память. Вот вы не задумывались, что для тех
классов, вот вы написали класс, и у класса нет конструктора по умолчанию. Вопрос. Как создать
массив из элементов этого типа? Ну кажется, что никак. Почему? Потому что если вы вызываете вот
такой вот new, то этот new, еще раз напомню, он приводит к тому, что выделяется память, а потом
вызывается конструктор по умолчанию. Вот если у t нет конструктора по умолчанию, то у вас в принципе
не получится выделить массив из этих элементов. Вот. Но с помощью вот этого разделения мы можем
это устроить. Как? Я могу сначала создать эту память. Оператор new, ну опять же, size of t умножить на n,
а потом в цикле for int i равно нулю, и меньше n, плюс плюс i, и допустим каждый элемент
написать new p, ну и создать его с помощью какого-то параметра, например t от i. То есть допустим,
у меня нет конструктора по умолчанию, но есть конструктор целого числа. Вот. Таким образом,
я смогу создать, так только p плюс i. Таким образом, я могу создать каждый элемент, не имея на руках
конструктора по умолчанию. Вот. Так, еще вопросы. Что произошло? Закончилась лекция, а тут, смотрите,
у нас у t нет конструктора по умолчанию. Что произойдет, если я попытаюсь создать массив
элементов, у которого нет конструктора по умолчанию? Ну, ошибка эмпиляции, потому что при вызове такой
операции new выделяется память, и плюс каждый элемент создается по умолчанию. То есть я утверждаю,
что если у вас нет конструкции по умолчанию, то вы не сможете создать массив из этих элементов. Вот
так. Но что я могу сделать? Я могу сначала выделить память, но выделение памяти не вызывает
конструктора. А потом каждый элемент создать так, как мне нужно. Ну, в частности, например,
создать элемент с помощью конструктора одного аргумента. А вектор, ну, смотри, у вектора есть,
напомню, два конструктора. У вектора есть конструктора, который принимает n, который работает так,
как написано слева. А есть конструктор, который принимает n, ну, и какое-то начальное значение,
например, t в единицах. Вот. И вот в этом случае вектор просто-напросто вызовет вторую версию. И
создает все элементы не по умолчанию. Пока нет. Нет, да, на самом деле там естественно есть обработка
исключений, но resize он не noexcept, pushback тоже не noexcept, но они обладают некоторой гарантией
безопасности. Да, ну, собственно, вот последний слайд. Мы пытались реализовать emplaceback. Напомню,
как мы это с вами пытались сделать. Мы с вами написали что-то наподобие такого.
Booper от i равно t от std forward arcs. Вот. Мы сказали, что так делать нельзя,
что так делать нельзя, потому что тут используется создание объекта и плюс присваивание. Вопрос,
как реализовать emplaceback так, чтобы элемент с этими параметрами конструктов был создан в
нужном месте? Очень просто. Используем вот эту версию операции new. Напишем new
booper plus i. То есть я говорю, что на i-те ячейки массива, на которой указывает booper,
нужно создать вот такой объект. t, ну и дальше-дальше и так далее. Вот то, что написано здесь.
Окей? Всё, вот таким образом я за одну операцию, я в одну операцию сразу же
создаю объект в нужном месте памяти, а именно на i-те ячейки.
Окей? Всё, тогда на сегодня закончили. Всем спасибо.
