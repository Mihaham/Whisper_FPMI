Вот такая лекция будет сегодня про не особо связанные вещи, но вот первая из них нам нужна
к лекции, которая будет через два раза, а вторая из них это просто традиционная тема,
которая там современно Александреску тащится, она прикольная и даже на практике немного полезная,
только не в том виде, в котором, конечно, ее Александреску показывал. А вы же Тюпл писали,
да? Тогда будет много дежавю сегодня, ну вот во второй части, ну или развитие идеи Тюпла.
Отлично, если люди, которые не писали, будем развлекаться, но сначала нам надо поговорить про
Неблоиды. Вот Неблоиды это про убийство АДЛ, ну непонятно пока, о чем речь, вот у нас был АДЛ,
не-не-не-не, не надо гадать, затравочка, чтобы привлечь внимание. АДЛ, у нас был АДЛ, что такое АДЛ?
Каких? Что ищем в каких namespace? Ну расшифруйте это кто-нибудь. Да, типа того.
Да, не только, если ничего не получилось, но в принципе, что когда функцию вызываете,
причем вызываете неквалифицированно, то есть просто фу, без двух двоеточий,
без указания namespace, он квалифает лукап. Вы идете, помимо обычного лукапа, еще и во все namespace,
которые хоть как-то относятся к типу аргументов. Ну как бы да, но это интуитивно понятно. Тот namespace,
в котором лежит этот тип, все namespace, которые в типах аргументов шаблону помянут, и родительских
типах, ну вообще все, короче. Андрей, как умное слово, ассоциированный, вот, ассоциированный
namespace это называется. Мы там что-то посмотрели, ну сейчас еще посмотрим. Вот, и ну техника, зачем это
в принципе как бы нужно изначально, ну окей, изначально это нужно было, чтобы hello world работал,
да, это помним. Вы пишете cout, стрелка, стрелка, hello world, откуда находится оператор стрелка,
стрелка, стрелка в namespace std из EDL. Потом внезапно обнаружили, что с помощью этого можно
кастомизировать всякие функции типа swap, да. Вот идея какая, мы берем и перестаем звать просто
std swap, мы делаем using там, std, да, давайте по порядку. Если вот так делаем, то у нас вот тут как бы
кастомный какой-то swap есть для нашего типа статический, и он типа более эффективный, чем два
move, ну как-то там сделали. Вот так вот вызывая, мы просто дефолтную реализацию дернем, вместо
кастомной неприятно, хорошо бы уметь кастомную именно вызывать, поэтому предлагается такая схема.
Вместо того, чтобы это статический метод был, да, он будет random, причем не friend declaration,
а friend definition. Это вот делает, определяет новую функцию в как бы родительском namespace для
этой структуры, но находится эта функция только через ADL, и когда вы делаете вот так, у вас либо
через ADL найдется такая штука и вызовется, либо стандартный swap будет использован, если ADL ничего
не нашел. Вот такая технология была. Вспомнили, вспомнили. Если что-то непонятно, пропустили,
прослушали, переспросите, что дальше все будет бессмысленно, если вы не поняли вот эту технику.
Там такой порядок при выборе перегрузки, такой порядок. Там надо, конечно, стандарт открыть и
прочитать. Я наизусть это, даже если в какой-то момент запоминаю, потом быстро забываю, но вот как
факт, когда вы пишете такую конструкцию, у вас приоритет берет то, что находит ADL. ADL никогда
ничего не находится, делается, а там с хитрыми приоритетами. Мы можем, наверное, так и сказать, что мы
делаем юзиную декларацию для cd swap, мы, грубо говоря, его помещаем в namespace, в котором мы
написали эту юзиную декларацию, а class это более вложенный scope, поэтому он идет первым по порядку.
То есть, когда мы пишем friend, мы смотрим на friend функцию, как на member функцию, при его капе,
и поэтому... Ну это... Не-не-не, вот это не member функция. Да, ну, мне кажется, это бесполезно пытаться
вот какую-то такую интуицию набросать. Нет, она буквально там в стандарте написана, что friend
declare functions. А, ну, если ты прям помнишь, что так написано, то окей, да, что там у нас member функции
какой-то приоритет берут. Ну, в общем и целом, вот это тупо надо запомнить, что вот так работает.
Когда вы делаете так, вызовется кастомизация.
Область видимости структура в отдельный namespace. Нет, как бы...
Область видимости это четкое понятие в языке. Любой namespace это область видимости,
и любая структура область видимости.
Да, структура, она так и так область видимости.
ты в структуре можешь статическую функцию, как на прошлом слайде, определить,
ее можно позвать, ну как, только foo2.swap, да?
То есть вот структура, она так и так.
А тут формально, когда мы говорим friend и пишем определение функции прямо в классе,
не объявление, если бы там фигурных скобок не было, это было бы объявление,
и тогда мы говорим, где-то там есть какая-то другая функция swap,
которую мы говорим, что она нам friend.
Ну, ее там пойдет искать компилятор, где она есть.
Если не найдется, то будет ошибка.
А здесь мы говорим, мы создаем новую функцию.
В какой области видимости?
Ну, на самом деле в родительской области видимости по отношению к этой структуре,
но по факту, если вы попытаетесь вызвать полностью квалифицированный вот этот swap,
ничего не выйдет.
Прям в стандарте так захардкожено.
Его можно вызвать только через ADL.
То есть вот такая конструкция, она специально сделана для ADL,
и без нее смысла не имеет.
То есть вот, механически так происходит,
и вот тут, когда так пишем, ADL берет приоритет.
А если бы я написал не SDSwap, а, не знаю, какой-нибудь namespace,
был бы уже вот peterswap, это сработало бы?
Про что я речь?
Недостатки этого подхода,
оно вообще никак не работает с namespaces.
То есть мы не можем сделать какую-нибудь другую функцию
с названием swap, которая что-нибудь другое делает.
Ну, вдруг в нашей предметной области слово swap,
оно имеет какое-то специфичное значение,
и мы хотим использовать это слово с этим значением.
Не можем.
Для чего swap, он как бы вот этот вот кастомизируемый вызов,
он зарезервирован глобально.
То есть нигде вы никогда уже не можете swap использовать
для своих каких-то целей как функцию,
иначе будете ловить всякие конфликты и проблемы.
Это плохо, потому что мы на уровне библиотеки
вносим как будто бы новые ключевые слова.
То есть берем и резервируем ключевые слова,
не меняя язык, это странно.
Колдунские заклинания.
Вот это вот, признайтесь, хоть раз вы писали,
или до этого курса видели?
Да, мне Мещерин говорил, что не надо их писать.
То есть ты так написал, а Мещерин сказал не надо?
Да.
Ну, я пишу на первый курс, уже слишком...
Нет, нет, нет, почему ты так писал?
Почему ты так оставался?
Ну, я думаю...
Слишком темное заклинание.
Да, да.
Ну, Мещерин прав.
Это слишком темное заклинание,
и авторам стандарта это тоже было очевидно,
что вот так никто код не пишет.
Пойдите, найдите хоть где-то в проде вот эти вот заклинания.
Да нету их, никто так не делает.
Скажите, вы специсты, да?
Вроде как не уверен.
Не уверен.
Попробуй.
Ну, вот, собственно, причин для своба стандарта есть
кастынь, что его можно специализировать.
Был.
Ну, давай не будем про это, пожалуйста, Андрей.
Ну, потому что именно из-за этого этот кастынь был,
потому что интернет пишет как надо.
Ну, да.
Окей, историческая справка.
Вот так вот слишком сложно, поэтому в какой-то момент
в C++ можно было писать
свою явную специализацию
шаблона swap namespace-std.
Вы такое делали уже,
правда ведь, специализировали
шаблоны из namespace-std в своем коде.
Какие?
Hash.
Всем известно, хотите в unordered map
положить, специализируйте hash.
Ну, со swap, оказывается, так тоже можно было,
но, по-моему, уже запретили.
Не уверен.
По крайней мере, пользоваться этим уже точно
не надо, сейчас мы дойдем до конца
сегодня и поймем почему.
Да,
еще есть такой моментик
случайная ADL.
Вот я тут так рекламирую вам ADL, что круто,
кастомизация, ну, там есть какие-то недостатки,
но можно же этим пожертвовать, чтобы
у нас там
зирокост кастомизации
без всяких трейтов, без всего
магически работать.
Ну, вот сейчас будет мотивирующий пример
про то, о чем я говорю.
Что такое случайная ADL?
Знакома ли вам эта функция?
Этот шаблон функции?
О копе, да,
это итальянская версия функции
копе или
французская? Не уверен.
Итальянская, итальянская.
Что она делает?
Помним?
Кто-нибудь?
Копируем.
Что, куда?
Так, все от first
to last, где first to last, это вот
в какой-то контейнер,
а да, оно берет
и шагает от first to last,
и копирует это все дело
в result, где в result
уже заранее должна быть память под это выделена,
то есть оно просто как бы
result разаменовывает, присваивает, двигает вперед,
разаменовывает, присваивает, двигает вперед.
Что оно возвращает?
Да, result после всех
присваиваний.
Что вам может не нравиться
в этой функции?
Почему он тебе не нравится?
Зачем он возвращает?
Посылки нормальные.
Почему?
Это странно.
Кажется, ты получаешь при передаче
посылки, мы получаем interaction
и на уровне EBI это могут быть проблемы,
что ты уже не оптимизируешь.
Ну, вообще, про EBI, неоптимальности
и итераторы, это совсем отдельный
разговор, там все плохо.
Вам кажется, что все нормально, вы
привыкли передавать итераторы по значению, на самом деле
все очень плохо. Ну ладно, это отдельный разговор.
Нет, это не проблема,
это наоборот очень круто, потому что вы
взяли какой-то там вот этот
итератор на начало, куда
вы копируете, передали вы сюда
копий, вам вернули
наконец. Вот вы их вычли,
изначальный result, который вы передали, и то,
что вам вернули, вычли, получили сколько
перекопировано было.
Тип итератора.
Аутпут итератора.
Ну да,
это аутпут итератора, это инпут,
я решил опустить все эти концепты.
Почему?
Ну, например, я хочу какой-нибудь...
Ну, короче,
у меня нет понимания,
когда файл заканчивается,
когда я не смог почитать, а когда заканчивается.
Прекрасно.
Ну, ты явно знал.
Нет, я просто про рендж
рассказывал пару лет назад.
Это ровно то, что мы хотим.
Но только у меня пример более
простой, чем файлы.
Сестроки.
Вот у сестрок есть только указатель на
начало. Указатель на конец
получить, это линия, это
типа долго.
Зато, зато у нас есть
четкий критерий, понимание, когда мы
дошли до конца. Вот этому алгоритму
зачем ему вообще
итератор на конец?
Только сравнивать
с текущим ферстом.
Единственное, зачем он нужен, это понять, когда мы
дошли до конца. В сестроке мы
по-другому понимаем, как мы дошли до конца.
Поэтому идея. Давайте
усовершенствуем стандартную библиотеку.
Добавим сюда
другого типа last, так, чтобы можно было
какое-то волшебное значение
подпихнуть, которое можно сравнивать с
консчар звездочка.
И при сравнении
нам бы просто говорили, дошли ли мы до
нулевого символа в конце сестроки
или нет. Понятная идея.
Это вот прям реальная штука из
ranges. Такое теперь есть.
Да,
но тут еще есть проблема. Вы не успели
прочитать или успели?
Не успели. Хорошо.
Да, тут еще есть недослаточек.
Ну, про размер сестроки.
Очевидно кому-нибудь,
что это значит?
Что?
Размер в смысле байтов
или в смысле сестрочных символов?
Про кодировки не думаем.
Char это char, это символ,
это...
Ну, неважно.
Просто хотели получить размер.
Вот когда такая ситуация, у нас разные
какие-то значения сюда переданы,
вот эта штука с последней, кстати, буквы s,
это sentinel.
Вы когда какие-нибудь деревья писали
или связанные списки, да?
А чем еще я не рассказывал про сентинел?
Ну,
да,
ну просто когда связанный список у вас есть,
очень часто пустой список
представляют не отсутствием нод,
а
сентинелом, фейковой нодой.
И вот это фейковая нода,
к ней уже настоящие цепляются,
и она всегда пропускается при террировании.
Вот просто деталь имплементации.
Вот это вот как бы сентинел,
что-то фейковое,
что охраняет границы,
как сентинел вообще-то, по-моему,
как раз типа пограничника слова.
Интуитивно я понимаю,
что оно значит на английском переводе,
не помню. Ну ладно.
Значит,
у вас есть сентинел, запустили алгоритм,
внутри под капотом вы прошли
отсюда до конца.
Ну и куда-то
перекопировали. Причем вот это вот output
итератор, он же на самом деле мог быть
не какая-то другая строка, а вообще
output итератор на консоль.
Просто там,
знаете же, этот OStream
итератор, который
просто берет и пишет все, что в него записали
на консоль.
Бэкинсертер какой-нибудь, ну с бэкинсертером
получится, а вот с OStream итератором
не получится.
Констчр звездочка, сентинел,
OStream итератор. Внутри этого алгоритма
была посчитана на самом деле длина
строки, правда? Вы же дошли
от начала до конца.
На выход вам вернули какой-то другой OStream итератор
и вычитать их друг из друга нельзя,
дистанцию находить нельзя,
то, что вы сюда передали, оно уже неволидное.
То есть вы как бы потеряли вот эту информацию,
которую могли бы вообще бесплатно получить.
Ну если вам кажется, что это
я какие-то бритни рассказываю, то
если вам нужно выжать
миллисекунды, нанесекунды
из вашего алгоритма, то это делается вот так.
Минимизировать количество раз, которые вы проходитесь
по строке.
Надо поменять тип.
Да, просто взять
и вернуть
вот этот вот first после
всех инкрементов.
Нет, короче,
вот такая сигнатура хорошая.
Почему? Потому что она всю информацию,
которую внутри себя вычислила по ходу дела,
вернула.
Ну слушай, да, ты прав.
Я не знаю, что комитет
на этот счет может сказать.
Ну да, там скорее всего
в библиотеке RNG есть какой-нибудь раппер.
Мне правда так и не довелось
библиотеку RNG погонять
прямо плотно, потому что все
все проекты, где я работаю, там они
либо не нужны, либо их не получится
затащить пока.
Ну вот чего не такое.
Короче, можно выкрутиться, но да.
Вот так решили. Это короче из стандарта.
Еще раз хочу уточить.
Мы передали Sentinel
несколько интеракторов на конец строки.
И Sentinel на самом деле
будет штука, которая
при сравнении с собой будет чекать
на то, что... Не с собой.
У которой есть оператор сравнения,
когда сравниваем конц, чар, звездочку и Sentinel,
происходит return
звездочка, первый аргумент.
равно равно там нуль
ноль, да? То есть
просто оператор сравнения
для вот конц, чар, звездочки и
Sentinel выдаст вам
лежит ли под
оператором нулевой чар или не лежит.
То есть у нас Sentinel
получился пустым. Sentinel это
пустая структура, да, в ней вообще ничего нет.
Мы этого набивались?
Sentinel здесь просто нужен, чтобы
вообще с всеи строками можно было работать.
Не находя заранее их длину.
Хочется за один проход,
чтобы все работало.
Минимизировать количество проходов по длинной строке
в памяти, потому что доступ в память это
дорого. Про это уже вроде
обгнил что-то.
Так, ну вот, такую функцию добавили в стандарт
вместе с двадцатыми плюсами.
Сейчас.
Да, ну вот такую на самом деле.
Ну немножко
посложнее стало, да?
Ну что здесь написано?
Во-первых, вместо пары мы
используем какие-то дурацкие структурки
с именами, чтобы было понятнее.
Там какой-то in-out result есть,
copy result,
тыры-пыры, copy result,
та же самая копия.
Ну и концепты навесили.
Что?
Input Adapter, Sentinel-4.
Такой концепт тоже есть. Давайте пока
не думать, что там написано. Ну вы догадаться
наверное можете, если так прикинуть.
И Weakly Incrementable-O.
Который вот где-то в Require.se скрыт.
Я решил это опустить, это нам не так важно.
Теперь надо следить за руками.
Мы написали
вот такой код.
Почему написали using namespace
std ranges? Ну потому что тут было
очень много кода. Большой алгоритм,
где там как-то данные гоняются,
перекладываются, что-то вот алгоритмическое
происходит. Ну надоело
нам писать std ranges копии.
Да, я не сказал, вернее
я показал, это в namespace и ranges
живет, вот этот новый копий. То есть
std copy старый остался, как мы
начально смотрели. Теперь std ranges
копии.
Много кода, где-то
зовем копии. И вот вопрос.
Что в такой ситуации вызвется?
В каком
namespace? В своем
кастомном namespace Keck.
А может быть Sentinel
с итератором?
Да, конечно. Любой
тип итератора сам
для себя является Sentinel, кроме
каких-то там кейсов,
когда input итератора, по-моему.
А есть юзмут для std или нет?
Вот здесь нет.
Вот ровно так.
Ну как бы хочется
сказать, что ты прав, но на самом деле
нет. Давай дальше смотреть.
Sentinel.
Я надеялся, что у меня этот
слайд раньше был, но он только здесь.
Вот const char звездочка и какой-то
magic Sentinel, для которого там оператор
сравнение определен с const char звездочка.
Вот так зовем. Что
тут вызовется?
Теперь точно можно сказать.
Варианта два,
либо std copy, либо std
ranges copy.
Может ли вызваться std copy?
Почему?
Это неважно.
Мы же знаем, что есть всякие хитрые-хитрые
как-то притащить,
отоели всякие, еще что-то там.
Тут явно не может быть вызвана std
копия.
Да, разные типы.
First и last не одного типа, а тут разных.
Ну конечно, std копия вызвать быть не может.
Никак.
Тут прям std ranges
copy строго.
Что здесь вызовется?
Почему?
Ну,
как бы тебе сказать.
Продолжай мысль.
Андрей молчит, потому что
он на все эти вопросы может ответить.
Аркадий, рассказывай.
Сейчас.
У нас, наверное, должен сработать
ADL. У нас здесь
не квалифицирован...
не квалифицирован name.
Поэтому
мы
идем, у нас
ассоциированный класс
будет
set int
специализированный
set лежит
в std, поэтому у нас
будет ассоциированность
в множество, это
сначала внутри set,
затем в std,
потом
уже в global
namespace вытащенное
определение.
Как бы
в целом, ты правильно мыслишь,
но просто
можно менее детально сказать, что
ADL действительно найдет
std копия, потому что
аргумент в namespace std лежит,
ассоциированный namespace, очевидно.
Найдем std копии, включим в множество
перегрузок, среди которого нужно
найти лучшее.
Мы найдем
ranges, потому что они как будто
в global namespace.
Нет, у нас же тут using namespace
просто, оно найдется.
И ranges копии тоже будет включен.
А, ну и там best
что будет лучше мэтчиться, нужно посмотреть.
Да.
Я не помню уже
стд копии имеет
одинаковые, вот ключевое.
Поэтому там
bestmatch?
Нет, он может быть specialized.
С другой стороны
range копии, он more constrained
по всем аргументам?
Ну, ответ
на этот вопрос взят из бумаг, которые
там
есть constraint у ranges копии,
а у std копии нет.
А суть констраинта
это как бы
излез констраинт, чем донитие констраинта?
Да, ребят, тут есть небольшая деталь,
что с одной стороны
у std копии одинаковые
типы, у первых двух аргументов,
к которым он лучше подходит.
А у ranges копии разные.
С другой стороны у ranges копии есть еще
констраинты, концепты какие-то навешаны.
И оно как бы тоже кажется, что как-то влияет,
но бумаги
по std ranges в момент,
когда их разрабатывали, вот я их откопал,
открыл, прочитал, утверждается, что все-таки std копии
будет вызван здесь в такой ситуации.
А почему не кидать от видео стол?
Так плюсы работают.
Когда можно разрешить хоть как-то
да.
Такие правила.
Надо выкуривать стандарт.
Сейчас, по-моему, там просто
дело в том, что
вот этот огромный
относительный порядок
в overload resolution сначала проверяет
специализацию, только потом
мороконстраинт. То есть он на констраинты смотрит.
После того...
То есть, естественно, он убедился, что
типа all above включая
вот, опять
вот, нашли 5-6.
А, ну вот.
Значит, строго написано в стандарте,
что сначала мы смотрим, что
аргументы, типы аргументов
более как бы подходят.
Вот это more specialize, что std ranges
одинаковые, и у нас тут одинаковые,
а у ranges копии разные.
Это берет приоритет над всем,
на констраинты не смотрим. Во,
вызвали std копия.
Да? Ну, уже как-то неловко становится,
да? Вот так пишем
ranges копии, вот так пишем копии.
Не надо просто никогда
писательство не квалифицировать.
Ну,
понимаешь,
как бы
тебе сейчас понятно, что никогда
он квалификает вызовы, вообще не нужно писать. И там
мне понятно, и многим тут понятно, возможно.
Не уверен. Ну, на работе, по крайней мере,
всегда все полностью квалифицирую.
А, ну вот.
У людей был как бы опыт
печальный. Ну, не стажер случайно
написал? Нет. Сеньор?
Или просто чувак?
Не, ну просто компилятор обновили,
он в вождь не кидал.
Ой.
Ой.
Ой. Ну, вот такое
значит бывает.
Вот бывает такое,
бывает, что вы разработчики
какой-нибудь стандартной
библиотеки или буста, и вам
там, у вас там
тоже много всего, и там такие
проблемы тоже бывают.
Ты хочешь, наверное, перегружать
оператор битого воздвига?
Не, давайте
так, серьезно.
А бывает...
Это сейчас не шутка была.
Так, и что с этой перегрузкой?
Ну, тут да, тут вот это вот все.
Ну, не будет же никто писать, типа
namespace 2.2.оператор
битшифта 2?
Ну, да. Ну, ты обычно через EDL находишь
свой оператор битшифта, если не находишь
что-то. Левого аргумента есть.
И вот правого аргумента есть.
Да, тогда уже вот что-то такое придется,
и могут быть проблемы.
В общем, самый частый кейс, когда проблемы будут,
это когда вы в школе ECM пишете.
Вот, вы такую фигню
бахнули, и
у вас все сломалось, и
сидишь на Олимпиаде и думаешь, что произошло?
Вы не забывайте, что C++
это язык, которому еще
кого-то обучать надо, да?
Ребят, потише, пожалуйста.
Вот как бы очень здорово,
когда там много лет опыт на плюсах есть,
и ты уже advanced темы понимаешь,
но вот эта вот вся шняга должна работать,
даже когда школьник Олимпиадки решает в 8 классе.
Понимаете?
И вот если вот такой
using namespace это абсолютно, типа,
всегда встречается, то
вот это может привести к такому бубуху,
что беда.
Вот, соответственно, это так жить невозможно.
А бывает еще хуже.
Вот это вот самое убойное.
Что вызовется?
Предыдущий
был set,
а теперь
вектор. Что поменялось?
Неужели у вектора
есть какой-нибудь там фрэнк?
Не-не-не.
А что такое
итератор?
Да, а что такое итератор у вектора?
Ну вот, смотря кого вы спросите.
Если вы спросите там всякие стандартные
библиотеки, типа, EASTL,
или, типа,
кого-нибудь там, типа,
кто-то еще
так делал, когда...
Ну, когда
какой-нибудь O3
и выключены все проверки выхода за границы,
и вам нужно супер оптимайжена,
вот этот тип
это будет просто ин звездочка.
А если нет,
то вот у вас другой кейс,
то есть, там, MSWC библиотек
или проверка у итераторов
на выход за границу включен, то, конечно,
это будет ин звездочка.
Как вы проверку на выход за границу будете делать с ин звездочкой?
Никак.
И это будет уже что-то в namespace STD.
Соответственно,
если вам повезло, это лежит на namespace STD
и ADL найдет
STD копия,
а если это ин звездочка,
то нету никакого ADL,
и вы найдете ranges копии,
потому что вот.
Implementation defined.
Нормально? Вообще класс.
Когда сразу получается
забавный момент,
если в одном кодике сначала vector.int,
потом vector.bool,
то какую бы мы имплементацию не зафиксировали,
и вызывать разные перегрузки.
Да, если вы пишете шаблонный код,
где vector от чего-то произвольного,
то с vector.bool вы так
накушаетесь вообще.
А еще раз, я не понимаю, почему
ваше STD-вектор
и тератор это
ин звездочка? Да, смотри,
стандарт не запрещает что так, что так делать.
Вот стандартная библиотека,
которая подходит под
стандарт,
она имеет право написать
итератор для вектора как полноценный класс
со всякими операторами,
присвоения и прочим-прочим.
Так и имеет право сделать
итератор у вектора просто указателем.
Вы, span, решали,
что делать итератором? Указатель.
К чему была подводка?
То есть это в принципе стандартом разрешено,
и у span, и у вектора может быть
и вообще у любого contiguous range,
итератор его может быть просто т звездочка.
Ну и вот в таком случае,
как бы вы на венде компилируете
у вас одно поведение, на линуксе другое.
И что?
И как жить?
Ну, типы разные.
А мы только что поняли, что если
first и last лежат на эмспейсе STD,
то будет вызвана STD-копия,
а если нет, то STD-Ranges-копия.
Разные функции с разной сигнатурой
и разным возвращаемым типом.
У нас тогда получается, можно еще отметить,
что алиасы,
они учитываются
как типы, которые они алиасят,
а не как они сами.
Да, там какой-то такой еще прикол есть.
Нет, ну это буквально
вот тут как раз и скрывается.
Если бы алиас
считался отдельной сущностью,
а не заменялся
на тип конкретный,
то тогда всегда вызывался бы STD-копия.
Как же ты в корень зришь?
Я даже не задумывался об этом.
Ну, интересно вообще.
Алиасы можно шаблонизировать
отдельно от того, кого они алиасы.
Да, интересно, что будет, если шаблонные
алиасы. Вообще
хороший вопрос. А как взаимодействуют
ЭДЛ и алиасы? Ответа на него у меня
сейчас нет.
Потому что такого я не пробовал делать.
Сейчас, насколько я
помню приколы 23-х плюсов,
там уже отдельно что-то фиксили
по этому поводу. Не на мой больший уровень,
но уровня, кстати, длиннее был.
Все-таки алиас сначала вскрывается
и потом стараться
сценировать их уже по ним.
И нестинность этих прикол
учитывается уже в концерте.
То есть то, где
определен вот этот алиас-этератор, оно не
играет роли, правда? Не играет.
Да, ну все.
То есть все здесь правильно. Действительно
на ровном месте вы получаете
не кроссплатформенность.
Прекрасно.
Нам это надо фиксить.
Согласны?
Почему нет?
Мы дадим школьникам
код писать.
Кто придет
нам на смену, чтобы кодить
на C++?
Вы уже на должном уровне знаете,
чтобы задуматься о таких вопросах, правда?
Да.
Здесь мы, получается, игнорируем
возвращаемое значение, если не будем игнорировать
и явно напишем 5.
Ну,
не будет компилироваться,
но...
Ну что? Не факт!
А что?
А это есть
такое вроде?
Ну, еще
внимание, прикол.
Это может скомпилироваться как, если вам здесь
вернули вот эту вот пару,
так и если
у вас итераторы, какой-то странной
структуры, это...
Какой-то структуры данных странные. Это просто
структурки из двух элементов.
Ну, бывает такое, что...
Структуры из двух элементов стараются получиться,
но можно реализовывать эту подготовку?
Нет. Чтобы структуры, чтобы структуры-биндинги
работали для структур, ничего делать не надо.
Они автоматом работают.
Более того, для структуры из трех или четырех
или пяти элементов это тоже сработает.
То есть, если у вас внезапно итератор,
а эта структура, а не класс
инкапсулированный, ну, вдруг какая-то
библиотека вам прилетела, гадостная,
и в ней вот так вот заведено,
то у вас здесь все скомпилируется в этой строчке,
только ИИО это будет вообще
непонятно что. Какие-то кишки
одного итератора, аутпут, который
вернул вам СТД-копия.
И дальше вы пойдете с ними что-то делать и словите
такую ошибку о компиляции,
что мама не горюй.
Это все теория, конечно. Не уверен, что
кому-то на практике приходилось с таким сталкиваться.
Я сталкивался с тем, что я добавил
Define Glipstakes и ExitDebug
педалью.
Компилировал, и оно не компилировалось,
потому что там, типа...
А, то есть, вот как раз поменялся...
...на какой-то другой итератор, да, и
что-то не то запомнилось. Да, вот
это правильное
замечание, я так вскользь сказал, что
вот есть обычно у стандартных библиотек
режимы дебага итераторов, да.
Как ты сказал этот?
Вот, Glipstakes
debugpedantic. Вот оно, кажется, включает,
что там итераторы становятся другими и очень
много всяких ассертов и дебага делают.
У
Microsoft такая же штука есть. Да, в принципе, у
всех оно должно быть, кто у себя вообще хоть
как-то уважает, потому что без дебага итераторов
многие вещи отловить невозможно.
А то, что этот дебаг итераторов начинает
менять поведение нашего кода, это просто
пху!
Да,
потому что там
другая реализация,
которая с дебагом.
Без дебага, с дебагом, они там
разных лежат, и все ломается.
Окей. Как чинить будем?
Давайте придумывать.
Это
здорово!
Вот ключевая аудитория
этого фикса, это вот
люди, которые
этого фикса. Это вот люди, которые только начали изучать
плюсы и которым плюсы нужны.
RNG равно std ranges.
Можно так, но ты все равно не приучишь школьников
писать так, все равно будет вот это. Вот нужно, чтобы
вот ты так написал, так написал, и это нормально работало.
Фикс не здесь.
Можно зафиксировать naming-cap и писать...
Нет, нет. Смотри, вот этот код зафиксирован просто
цементно. Его менять нельзя.
Раз не компилирует этот код.
Но правильно в том, что на плюсах написано.
На плюсах он должен начать работать нормально. Придумайте
фикс. Ну не очевидно, понимаю.
Выключить.
Выключить EDL, ну, были предложения, но невозможно, потому что
тогда у тебя Hello World не будет работать.
А так, ну, у нас тоже Hello World, из импорта стд, стд принт.
Ну как бы, да.
Это повод для того, чтобы написать проползл в стандарт,
давайте выпилим EDL, но этого не будет. Как жить?
А жить вот так. Что вас здесь может заинтересовать?
Функция внутри функции.
Почему? Ну что вы... Функции внутри функции, это когда
вы прямо внутри функции пишете декларацию, другое
Мы только что договорились, что этот код зафиксирован
цементом. Вот здесь декларацию какую-то написать нельзя.
Не очевидно, да? Давайте еще подсказку.
Вот когда вот такое выражение видите, что это может быть?
Вот это вот копия, это может быть конструктор, это может
быть, ну, вызов функции, как мы и раньше думали, а еще...
Какого?
Какой метод? Какого класса?
Нет, а если мы внутри класса находимся, то это может
быть метод текущего класса.
Окей, еще.
Сейчас вот, что?
Да, это может быть вызов оператора круглые скобки
на объекте копия.
А объявление не функции, то есть объекта с названием
копия, выключает EDL.
Вот оно.
То есть что мы делаем? Мы делаем копию FN структуру.
У нее делаем оператора круглые скобки.
Теперь вот здесь находится код нашего копия алгоритма.
Вот сигнатура точно такая же, как у копия была у этого
оператора круглые скобки.
Да?
Помните?
Окей.
И делаем inline constexpr копии FN копии фигурной скобки.
Глобальный constexpr объект.
Вот этого типа.
Данных в нем нет.
Есть только оператор круглые скобки.
ADL не включится, потому что мы в namespace STD range
сразу найдем копия и все.
Ни ADL ничего не будет.
Мы нашли не функцию, поэтому...
Вот такой прикол.
И вот этот вот объект называется nebloid.
То есть мораль nebloid, это вот такая конструкция,
которая подавляет ADL.
Ничего не понятно.
Что?
Ну сейчас мы в какой-то момент откроем кланговскую STD
либу и увидим там вот примерно такое.
Нет, смотри, если ты...
Ребят, потише, пожалуйста.
Если ты пишешь свою стандартную библиотеку и ты в ней хочешь
иметь функцию копия.
И причем у тебя была старая функция копия.
Вот мы же только кейс рассматривали, только что, да?
Жуткий.
Вот если ты попал в такую ситуацию, как авторы стандартной
библиотеки, где есть старая копия, новая копия,
ну а такое в жизни может быть, когда у тебя очень
большой проект, там есть всякая legacy,
и там некоторые штуки одинаково называются, но делают немножко
разное.
Вот в такой ситуации тебе стоит сделать вот так
и подавить ADL, чтобы никогда не было случайного вызова
не того, что ты ожидаешь.
Вот.
Но в принципе, вот от тебя вот это вот писать в жизни
потребуется примерно никогда, если только ты не станешь
разработчиком стандартной библиотеки,
либо Boosta, либо QT.
Ну какие еще варианты?
В принципе все.
Ну Upsell тоже считается стандартная библиотека.
То есть вот этим ребятам, которые пишут огромные,
жуткие, шаблонизированные библиотеки, вот это вот
очень нужно и полезно.
Чтобы там дружить с предыдущими версиями и спокойно
мигрировать, а также не конфликтовать с другими
библиотеками.
Ну если у вас несколько библиотек, и в них разные
копии, в разных namespace тоже проблемы.
Можно еще объяснить?
Да.
У нас есть копия френд структуры.
Да.
Не перебружен оператор круглый с кодом.
Да.
Не обязательно...
Он именно просто объявлен?
Ну там код написан.
Я просто его здесь опустил.
Там прям реализация написана, да.
А дальше мы делаем онлайн констексов копии fn-копии.
Это что мы сделаем?
Переменная.
Это переменная типа копии fn.
С названием копия.
Глобальная переменная.
А почему она констэкспор?
Ну потому что зачем нам в ронтайме с ней что-то делать?
Она один раз.
Она нам нужна только чтобы у нее оператор круглый
с копии был.
Навешиваем констэкспор.
Почему она онлайн?
А проверка на вшивость.
Зачем она онлайн?
Чтобы не ругался линкер.
Чтобы не ругался линкер.
Верно.
Потому что это все в хедере написано.
Это все шаблоны.
В хедере все переменные должны быть помечены онлайн.
Ну там вроде констэкспор по дефолту онлайн.
Я тоже думал, что констэкспор по дефолту онлайн.
На счет переменных это неправда.
Нет, не по дефолту онлайн.
Просто когда ты пишешь в классе статик онлайн...
Если ты не пишешь онлайн, тебе ругается, что нарушен definition rules и прочее.
Констэкспорт это статик конст.
Мембр и для него компилятор автоматически оптимизирует.
Что такое двайк для переменных?
То же самое, что и для функций.
Когда ты в хедере реализовал функцию,
и ты этот хедр в два разных cpp-шника включил,
у тебя будет multiple definitions, конфликт.
Нарушение one definition rule.
Потому что код функции просто из хедра подтянут в один cpp-шник, в другой.
Там скомпилировали функцию здесь.
Итог у тебя в двух объектных файлах одинаковая функция с одинаковым всем.
Нарушение odr.
Чтобы этого не было, мы помечаем функцию inline.
Что это значит?
Компилятор, забей на то, что там два definition,
я обещаю, что они одинаковые.
То же самое для переменных.
У тебя каждая глобальная переменная,
это будет некоторое выделенное количество байтиков в объектном файле.
Зарезервированных глобальных байтиков.
Которые потом попадут в какую-нибудь pro-дату в xz-шнике или еще куда-нибудь.
Ну и вот вопрос.
Вот у тебя в одном объектном файле есть переменная,
и в другом объектном файле переменная абсолютно одинаковая.
Вот ты имел в виду, что это одна и та же переменная,
и у них общая память должна быть в итоговом xz-шнике.
Или это две разных, и у них разная память должна быть.
Вот чтобы было две разных, нужно написать static.
Чтобы была одна и та же память, нужно написать inline.
Если ничего не написать, будет как бы нарушение odr.
Быстрый рекап первых двух лекций.
А как вы там проявляете constexpr?
Ну чтобы ты не мог написать какую-нибудь фигню,
типа copy равно там,
copy fn фигурной скобки, ну присвоить.
Сейчас ни в каком случае у нас не будет конфликта с каким-то,
то есть с std-шным копией,
и у нас при этом он не будет судать на аргументы и...
Да.
Мы полностью подавили адель, ничего не будет.
Как бы теперь, когда мы...
А, да, еще есть вот такой вариант.
Потом будет вроде пример.
Да.
Ну если вам нужен объект, у которого оператор круглые скобки определен.
Как такой объект получить?
Лямбда.
А вот то же самое.
Просто тут синтаксис уже такой,
типа интересный что-то, квадратные скобки, потом треугольные,
потом requires, еще и еще.
Да.
То есть тут авто пришлось написать.
Ну это там, может, некоторые проблемы возникнуть, но...
А лямбда разве можно явно чтобы на параметрах указать?
Да.
С двадцатых плюсов можно.
Если вы не знали, знакомьтесь.
С двадцатых плюсов в лямбдах есть еще и треугольные скобки.
Не-не-не, я вам указываю, при вызове.
При вызове нельзя.
И это нормально.
И это нормально.
И всем без разницы.
Нет, нормально, но если я...
А, ну я же все равно не могу, скобки тоже.
Так, что-то мы...
Сколько же времени-то?
А, мы час.
У нас еще полчаса, чтобы добить часть пронеблойды.
Идем нормально.
Даже раньше, надеюсь, успеем закончить.
Окей.
Можно так, можно так.
Я дальше буду всегда лямбду писать.
Неблойд — это функтор, который включает объекты.
Да, это глобальный объект.
Ну сейчас там будет мораль в каком-то месте прям четко выписанная,
но в целом неблойд — это глобальный объект, который выключает ADL.
Который можно вызвать.
Глобальный колобл-объект, выключающий ADL.
Да.
У нас же получается...
Мы написали копию с круглыми скобками.
И он пойдет искать, что это за копия такая.
Он найдет наш неблойд.
А если это он может найти при этом?
Чего?
Если честно, я не помню деталей процедуры.
Я решил вас не перегружать этим.
В целом тут очень много деталей опущено.
Потому что всякие там еще noexcept нужно написать на копии.
Куча концептов всяких навесить.
Еще там всякие inline namespaces.
Ну в общем...
Кстати, вот эта копия Fn очень похожа на лямбду.
Это просто классик с единственным убиратором круглые скобки.
Ну да, да.
Поэтому и можно лямбду изменить с одной оговоркой,
которая будет потом, а может и не будет.
Просто мы назвали точно так, как называется функция.
Да, и насколько я помню,
всегда, если у вас есть выбор между функцией и объектом,
выбирается объект.
Просто всегда, по-моему, так.
Поправьте мне, если кто-то знает точнее.
Андрей, всегда ли при конфликте имени между функцией и объектом
выбирается объект?
Сейчас.
Просто там так вроде говоришь, что ADL...
Вот ты сказал, что ADL отключается,
если при рукаве будет найдено хотя бы что-то из этого...
Да, но в целом, если без ADL смотреть,
когда у нас...
А, без ADL так не пол...
Ну вот у нас там...
Мы идем по родительским namespace в поисках имени.
Если мы найдем хотя бы одного из запретного списка,
то ADL...
А, окей.
Короче, такой ситуации вообще не может же возникнуть,
если мы про ADL не говорим.
Что у тебя и функция в кандидатах, и объект.
Вот, типа если мы говорим про ADL,
значит мы объекты уже не нашли,
потому что ADL начинается в том, как объекта нет.
Да, но, короче, в одном namespace нельзя определить
и функцию объекта с одинаковым именем.
Правда? Правда.
Когда мы в разных родительских namespace'ах
объявляли одинаковые имена функции объектов,
то мы просто до первого имени дойдем,
неважно, функция ты или объект, ты его выберем.
То есть тут просто такой ситуации без ADL,
чтобы был выбор объектов или функций,
его, кажется, не бывает.
Поэтому все нормально.
Вот, ну вот мы добились чего хотели.
У нас и так вызовется оператор круглой скобки, и так.
И хоть тушкой, хоть чучелом,
всегда будет то, что надо вызываться.
Оператор круглой скобки у нашего копии fn,
где нормальная реализация нашего нового классного копии
с дополнительным функционалом.
Окей.
Кажется, мы узнали, что такое случайный ADL,
что он таки бывает в жизни иногда,
и как его подавлять и чинить.
По существованию ADL мы имели в виду,
что под оператором можно кастоваться как структура.
Очень сложно предсказать, что найдет ADL.
То есть первый раз с ним встречаешься,
кажется, что он всегда найдет то, что нужно.
По факту ADL может найти какую-то лютую фигню,
причем в разных ситуациях разную,
и вот все как-то вот...
В общем, незащищенный ADL это опасно.
Есть еще две проблемы,
которые были с swap'ом.
Вот я сейчас про копии тут рассказывал,
и вот там был случайный ADL.
Копии – это не кастомизируемая штука.
Вот копии, как и другие там всякие transform
и прочие алгоритмы в ranges,
их нельзя кастомизировать, потому что а вам зачем?
Пусть вендоры библиотек кастомизируют,
основываясь на концептах.
То есть копии для contiguous контейнеров,
вам понятно, что можно быстрее написать,
чем понятно.
Вот, нам говорят нельзя,
а вендорам говорят можно.
Ну вот есть swap.
Это кастомизируемая штука,
и мы научились как бы чинить случайный ADL,
который со swap'ом тоже может быть, в принципе.
Но еще надо избавиться от кладунских заклинаний.
Поехали.
Swap будет выглядеть как-то так.
Тут какой-то код.
Ну мы что хотим?
Вот чтобы, наверное, вот это кладунское заклинание с ADL'ем,
using std swap и swap unqualified,
просто его сюда вписать.
Как вам идея?
Давайте так и сделаем.
Да, внимание, все в namespace ranges происходит.
То есть это не старый swap чинят,
старый swap останется сломанным,
а добавляют новый swap.
Вот.
Что это за концепт?
Ну в нем написана ровно вот эта строчка.
Вот swap fst с nd.
То есть это просто концепт, который проверяет,
что unqualified lookup
находит какой-то swap
для наших аргументов типа t.
Вот все.
Ну то есть как бы по сути здесь написано,
если вот этот код компилируется,
вот этот код используй.
Иначе используй std swap.
Все.
То есть теперь колоннуство с using std swap.
Не нужно.
Делаешь std ranges swap и все работает.
Не понятно, как бы воспользоваться.
Да, оно просто затолкано под ковер,
но под ковром все еще гниль,
и какие-то вот кишки тут лютые.
Понятно, зачем ranges.
Что?
Если я использую swap, не понятно, зачем ranges.
Если я два in task swap.
Ну если ты два in task swap,
то тебе, да, ничего не нужно.
Вся эта колдунская магия нужна,
когда мы пишем обобщенный код.
Когда вы пишете, например,
свой другой алгоритм для ranges.
Вот новый алгоритм какой-то решили
разработать на основе ranges.
И вам там посвопать что-то понадобилось.
Будьте добры, используйте ranges swap,
чтобы все кастомизации работали
и все у вас было хорошо.
Да.
То, что реально будет еще такое написано
в стандартной библиотеке,
это стандартно гарантируется?
Да.
Странными словами, но гарантируется.
Ну мы сейчас посмотрим, я надеюсь,
на код стандартной библиотеки.
Потому что открыть,
CTRL-кликнуть по STD ranges swap,
вы все можете.
То, что вы там увидите, понять
с первого раза невозможно.
Нужно идти читать сопровождающие бумаги,
где написано, почему так,
как я этитирую более-менее.
Надеюсь, после этой лекции вы сможете CTRL-кликнуть
по функциям из ranges и понимать,
что происходит там в целом.
Окей.
Ну то есть это в принципе все,
на самом-то деле.
Есть один нюанс и одна историческая справка,
которая нам необходима.
Если вы сами так напишете,
как я сейчас тут упрощенным бахнул,
будут проблемы.
Нужно еще чуть-чуть подкрутить.
Вот это чуть-чуть, оно такое нудно и скучно,
но мне кажется...
Куда? Куда battery low?
Так, это опасно, если...
Я, кажется, только что оглушил
всех, кто слушал на ютубе.
Это допустимые потери.
Ну да, что они нам?
Ладно, давайте добьем до конца.
Тут чуть-чуть осталось про неблоида
и прочее.
И тогда уже буду пытаться зарядку сделать,
чтобы работало.
Должно хватить пока.
Итак, есть, как говорится,
один нюанс.
Чуть более полная версия
вот этой вот штуки.
А, вот эта штука называется
точка кастомизации, кстати.
Та самая, которая там уже упоминала
несколько раз.
Вот неблоид он только подавлял ADL,
а точка кастомизации
она еще и
в своих корыстных целях под капотом
использует ADL, чтобы пользователь мог
кастомизировать.
Ну, почему точка кастомизации обязана быть
неблоидом? Кажется, вам должно быть
очевидно.
Надо сначала побороть ADL, чтобы потом
его использовать в своих целях, и без этого
не работает, в общем.
Там очень одновременно все придумали,
поэтому нету какой-то строгой линии подводки,
как они иначе.
Тут есть проблема.
Не очевидная.
Если вы внимательно следили
за слайдами, вы ее можете сразу увидеть.
Но это невозможно, в принципе.
Тут я добавил
std ranges, раньше просто namespace ranges
писал, теперь std ranges.
Вписал явно, что тут есть
requires ADL find swap.
Ну, или,
внимание, или,
работает просто std swap.
Ну, что это значит, что там
move assignable и
move в констракте был?
Никак, там нету
семантических требований.
Это не стандартный концепт,
его стандарт не требует,
стандарт другим языком это описывает.
Тихо, тихо.
Концепт swap был, понятно,
что есть, дойдем до него, не рассказывай,
что с ним.
Тихо.
Нет, никаких там семантических требований нет.
Вот в этом ADL find swap просто написано,
requires вот такой код,
все, ничего сложного,
я там даже на какой-то слайд вставил его.
Где бага?
Вот в этом коде.
Вот в этом коде.
Где она?
Какие-то тут рассуждения умные,
а вот самое очевидное,
тут не пофикшено.
Совсем очевидно.
Рекурсии...
Какой-нибудь ADL find swap
он находит вот этот swap, который он ставит справа.
Кажется,
кажется, не должно быть.
Вообще,
по этим соображениям, кстати,
вот так в стандартной библиотеке не написано.
Написана отдельно структура,
отдельно под структурой
объект. Я здесь
для краткости так написал. Давайте представим,
что вот этот swap точно не найдется.
А может какой-то другой
найти?
Где?
Где найдется
STD swap?
Последняя строча?
Последняя? Ну вот явно его написали.
Может не
найти?
Стд swap полностью.
Может
найти в первом? Да.
Возможно, это была просто
тык в пальцем небом, но
почему?
Почему просто он квалифает...
Да, мы вложены в STD.
Поэтому вот эта штука, в принципе, всегда найдет
кандидата
STD swap.
Окей.
То есть что это значит?
Внутри
концепта ADL find swap
у нас всегда...
Внутри концепта
ADL find swap мы всегда
на самом деле найдем, вот в
таком же коде, найдем
STD swap. А STD swap
до
какой-то версии плюсов не был
constrained. Что мне дальше...
Так, ладно.
Чуть-чуть не в том порядке.
Он до сих пор не constrained, только
там только mandate, по-моему, к нему написано.
Ой.
По-моему...
Давайте еще одну.
Проблема может вот так STD swap
найти. Как ее пофиксить?
Просто
это странно, да? Пока вот без мотивации
странно, что у нас ADL find swap
и вот здесь может найти не ADL
swap, а STD swap. Как это тупо пофиксить?
Вот максимально тупо.
Создать отдельные
сферы, которые не можем... Да.
Да.
Вот, вот. Все правильно ответ.
Берем и делаем, и это все фиксит.
Еще одна проблема,
которая уже совсем не очевидная.
Ну, может, ладно.
Сейчас много раз про это все проговаривала, оно все
однообразное достаточно.
Опять подсказка. В этом месте проблема.
Что еще может здесь
найти? Вот если мы все это в другой name space
передвинули, совсем отдельный,
и там
в родительском swap нет, может
что-то...
Что?
Нет, видно.
Тут квалифует, полностью квалифует.
Да, квалифует.
Сейчас, а как мы побороли предыдущую проблему?
Да, там не видно STD swap. Это совсем другой name space,
не вложенный в STD. Два нижних подчеркивания
STD. Может, что-то еще может быть
написано в этом отдельном name space,
в котором вы видели? Или там вот буквально
открыт name space, в нем написано...
Да, давай вот так.
Просто буквально открыт, и больше ничего.
Если face space
SD, у нас
в STD лежат.
Вот.
ADL может найти STD swap
внезапно.
Да, вот здесь. Мы ожидаем,
что у нас STD swap только тут вызовется.
А он на самом деле и в первой ветке может вызваться,
и главное вот в этом концепте
для любого класса
из STD, мы найдем
STD swap. По ADL.
Чего мы и хотели, в принципе.
Почему это плохо?
Вот, понятный слайд.
Docity++17 было вот так.
Просто понятный обычный swap.
После
C++17 стало так.
Но requires добавился,
видите, да? То есть теперь, если у вас
мува какого-то не хватает,
попытка вызвать
такой swap, она там выдаст вам
ошибку. Причем свиная
как бы ошибку, да?
А вот такая как бы вызовет ошибку,
выведет ошибку только когда вы уже
в тело функции пойдете, и в теле функции
обнаружите, что, ой, все сломано.
Внутри
этого концепта у нас
написан вот такой код.
Если он нашел STD swap
до 17-х плюсов,
он unconstrained.
Вот этого
requires нету.
А это значит что?
Что концепт всегда скажет true.
Потому что просто вызов
скомпилируется, да.
Это правда.
Это правда.
Ну, RNG изначально планировали
и раньше 20-х плюсов добавить,
и, в принципе, первоначальные
пропозалы базировались на
C++14,
где вот этого не было.
Ну, то есть
в C++17 добавили словами требования,
с C++20 оно там как бы как requires
появилось нормально, вроде как.
То есть,
то есть,
вот этот вот
requires весь, он бы говорил true
на любые вещи из STD.
Вам не кажется это странным?
Ну, вы поняли,
почему это происходит, да?
По ADL нашли, либо в родительском
namespace нашли. Ну, родительские по фикселя,
а по ADL все равно найдем.
Найдем, будет true.
И мы пойдем компилировать
код. Сюда пойдем, куда-нибудь внутрь,
провалимся в какую-нибудь
имплементацию, и там
вылетит ошибка. Нельзя
присвоить авто
два нижних подчеркивания,
tmp02.
Ну, вот это вот.
Ну, очередная ошибка сразу в конец
будет проблемой.
Ну, это как бы то, что концепты
призваны были полечить, правда ведь?
Да, что у вас ошибки
не читаемые, где-то там в кишках стандартной
библиотеки, сквозь 10 вызовов функций,
unable to move assign,
что-то там, что-то там.
Здесь все равно же будет такая ошибка,
но вот у нас, ну, допустим,
зачем-то для stdm-butex
одно вызвание, да?
Да.
А, сейчас, стоп.
Тебе напишут.
Да, тебе напишут,
во-первых, ADL я не нашел,
во-вторых, move
move, да.
Да.
Ну, более того,
тут нужно еще сказать про вот это.
Потому что концепт
стопобалон вот ровно так
определен.
В libc++.
То есть, это концепт
для всех вещей из std
либо будет true.
Это сломанный концепт.
Ага.
То есть, вот такая маленькая проблемка,
она такие последствия имеет жуткие.
Ну, в общем-то ужасно.
Сплошные проблемы.
Поэтому есть всякие пропузлы там,
поменять, заменить,
но это бред.
Такого не должно быть явно.
Я не фикс.
Самому додуматься до этого фикса невозможно.
Решительно.
Я думаю, что многие из вас не знали,
что такой конструкции в языке можно пользоваться.
Вот я точно не знал, пока на всю эту тему не наткнулся.
Видите,
что мы делаем?
Мы объявляем
какую-то функцию swap
с сигнатурой
один в один какой std swap.
И говорим, что
определение
для этого объявления удалено.
Да, мы будем его находить
и в этот момент получать ошибку.
Тут подробно расписано.
Во-первых, в родительском
namespace мы не найдем
std swap, потому что вот эта функция
его зашедует.
Мы идем вверх по namespace вложенным,
пока не найдем первое имя, которое в О.
Вот оно первое имя.
Все. Родительский std swap
выше не найдется.
Есть namespace,
в котором мы сейчас, это ranges.
Есть родительский namespace std.
Еще раз.
Unqualify lookup.
Это объявление
функции.
А это определение.
Вот это определение
до равно.
Это определение функции.
А равно delete
это ее определение.
Да.
Это определение ничем.
Оказывается C++
любую функцию...
Да, определение тем,
что у меня нет тела, меня нельзя вызвать.
Вообще можно
delete definition в cpp-шнике.
Ладно.
Первый пункт мы поняли.
Зашедовали имя
из верхнего namespace, теперь оно не найдется.
Второй пункт про ADL.
При нахождении через ADL
внезапно возникнет ambiguous call.
И там
все будет нормально.
Цитата из бумаги, которая
это предложила.
Я тоже.
Нет, мы не будем разбираться.
Это констатируется как факт.
Вот эта вот шняга, она запрещает
ADL вызывать std swap
с вот такой вот
сигнатурой.
Да, который без requires.
Ну, современный
swap, в нем уже requires есть.
Поэтому оно никак здесь не играет.
Сейчас, то есть, swap с requires
мы не аделить.
Мы его можем вызвать.
Да, его ADL может
найти.
Короче, вот этот костыль изначально нужен был
в момент, когда грезили ranges
протолкнуть и концепты в 17-е плюсы.
Были пока 14-е плюсы.
То есть std swap не было констрейнтов,
были проблемы. Придумали все эти
решения. Но в современном мире
единственная польза от вот этой штуки,
она есть до сих пор в стандартных библиотеках
и даже стандартам требуется, чтобы
точка
кастомизации,
swap,
она делает
argument-dependent lookup для unqualified,
имени swap в контексте, в котором
определено вот такая вот штука и удалена.
Там не argument-dependent говорит, там говорит
просто unqualified в контексте,
в котором есть вот эта вот штука.
Поэтому это еще работает, но это уже не сказано.
Так что если работает, вы догадаетесь сами.
Да, ну вот
в общем современном, вот тут я много текста
написал с объяснением истории, а в современном
стандартной библиотеке
все нужно с одной целью
зашедовать std swap.
По-моему
это зашедует любой.
Вот это зашедует
любой std swap,
но
не подавит
ADL для свопа
с другой сигнатурой, по-моему, вот так.
То есть сейчас если мы напишем
space std ranges,
он вызовет
anyway
вызовет
swap не std-шнум
или как это работает?
Я не понимаю сейчас.
Смотри, вот это нужно
в этом концепте только,
в том месте, где мы ADL find swap,
пишем requires, вот такой своп.
Вот эта вот штука влияет
только на это.
А мы делитим
не swap с requires,
потому что мы находим сейчас
на namespace std ranges
и это не делитит какую-то другую
функцию, это создает
новую функцию, которая удалена.
Да,
это новое объявление
новой функции в namespace
std ranges.
Нет.
Нет.
Нет.
Нет.
Я не понимаю.
И не нужно, мне кажется.
Перевернули.
Попытаться.
Мы объявили
вот такую функцию
с еще интервендацией delete
в своем namespace.
Да, в namespace std ranges.
Мы это сделали для того, чтобы
зашедуить.
ADL пойдет, найдет
этот своп delete и не пойдет дальше.
А
конечная цель всего
этого
вот этот ADL find
своп, он отрабатывает,
когда найдет своп где?
Он вернет true, когда просто
он квалифает lookup,
в текущем контексте найдет своп.
Так он же его найдет
потом.
Этот он найдет, если ничего лучше нету.
Там вот такая логика.
Что?
Что?
Что?
Да.
И поэтому
ADL, по-моему,
отключится,
потому что он отключается,
когда ambiguous call.
Там какая-то жесть, если честно.
В общем и целом
вы очень вряд ли
когда-то с такой ситуацией
столкнетесь.
Все это изначально было задумано
с одной лишь целью.
Полечить вот эту проблему, что у нас своп
без констрейнтов, где у меня слайд.
Вот эту проблему полечить.
В современных стандартных библиотеках
это осталось с одной единственной целью
shadow it. Вам не нужно думать
про вот эту проблему legacy, где у вас есть
старая функция в плохом
namespace,
которая unconстрейнт,
а есть новая функция в хорошем
namespace, у которой там и констрейнты,
и кастомизация, и вам нужно
как-то организовать вот это вот, чтобы
одно-другое... Это невозможно.
Вы в своей практике на такое не натолкнетесь.
Но, если вы ctrl-кликните
по какому-нибудь std-swap,
std-range swap, то вы вот это увидите.
Вот чтобы вас
это не шокировало, я рассказал
примерно откуда это взялось и зачем это нужно.
Теперь мы сможем
вызвать своп
с такой сигнатуры,
в принципе, если на всю
namespace std-range swap.
Да, лукавство
здесь есть. На самом деле
вот эта пара вот этих штук, она заталкнута
еще в более вложенный namespace, чтобы никуда
наружу не торчать.
Давайте скажем, что мы...
Давайте подведем итоги и вот
пойдем посмотрим имплементацию в libc++,
чтобы вот прям четко было.
Так, думаю, будет лучше, чем по этим
слайдам. Тут упрощений очень много.
Итак,
колонутские заклинания мы пофиксили.
Возникли некоторые проблемы.
Не у нас, правда, а у авторов стандартной библиотеки.
Они их там как-то закостыляли и со стандартом
покопировались, все здорово.
Единственная оставшаяся проблема, это то, что
до сих пор мы имена глобально резервируем,
потому что ходим через ADL.
Вот это он квалифает
имя swap в ADL, мы зарезервировали.
В одной из следующих серий
мы попробуем научиться пофиксить ей эту проблему.
Сейчас, то есть мы
можем сделать
условно говоря глобальный объект
как с копия.
Так есть глобальный объект swap.
С этого
началось все.
Точка кастомизации
это всегда не bloat теперь.
Вот если на cpp-референс
увидите написано cpo или
customization point object, это
не bloat.
Swap в range
это переменная.
Это переменная.
Так.
Когда-нибудь мы это возможно
попробуем и учиться фиксить, но не в этот раз.
Давайте подведем
итоги маленькие.
Почему не bloat? Потому что
вот этого парня зовут Эрик Нибблер.
Душераздирающий взгляд.
Почему его
флажки
с титрами поставлены
справа?
Это мода, понимаешь?
Есть такие вещи,
которые люди делают, абсолютно не задумываясь
какой под ними смысл,
просто потому что так принято у всех вокруг.
Давайте не будем осуждать людей за следование
о толпе, потому что все мы тоже так
делаем каждый день.
Честно говоря.
Неважно.
Итак.
Итак, не bloat.
Это
callable constexpr constructable object.
То есть объект
constexpr constructable
чтобы там все работало нормально,
которое можно вызвать.
И по сути это подавлялка ADL.
Customization point object.
Cpo.
Это тоже самое callable constexpr constructable,
customizable
и concept constrained object.
Это цитаты.
Блин, я ссылку не вставил на то, откуда
это цитаты. Ну ладно.
Возможно.
Да, это вот
CCCCCC.
То есть отличие
неблоида Cpo в том,
что
Cpo можно кастомизировать
и еще ожидается, что вы все-таки какие-то
концепты туда нависите.
Потому что иначе там смысла никакого не будет.
В
ranges библиотеке
все алгоритмы это неблоиды.
Там их много.
Референс можете посмотреть.
Либо дождитесь там после следующего раза.
SwapBeginEnd. Стандартные
Cpo. По-моему, еще какие-то
цепости стандартные. Я не помню.
А в
предложении STD execution,
где у нас наконец-то
concurrency появится в плюсах,
этих Cpo вот такая вот гора.
Скоро.
Надо только подождать.
Ну и вот.
Надеюсь, по каким-то осадочным знаниям
вам станет проще жить в мире
Modern C++.
Дальше нас ждет вот это.
Давайте лучше посмотрим
стандартную имплементацию.
Буквально 5 минуточек
перед тем, как пойти на перерыв.
Да, камеру надо чуть-чуть как-то это.
Туда-сюда.
Тыры-пыры.
Мне кланк больше по душе.
Внимание! STD
range swap в
libc++ 12, кажется.
Это
libc++?
Это не libc++.
Это libstd c++.
Ну ладно, а мне и без разницы.
Ну.
Я просто это
разбирал, да. Как же я
напоролся. Ну давайте смотреть.
Тут насколько хорошо вам видно?
Мне кажется, так получше, да?
Ну все, это сразу видно.
Так.
Что?
Где удивление?
Это персанты такие.
Вот это? Да.
Тебе еще кажется,
в тапе этого размера не нравится,
что у тебя...
В libc++ они мешают
в тапе проделы,
и в тапе у них это 8 проделов.
Если у них больше 8...
Тут, я думаю, читать невозможно
код. Ну...
Сейчас, подождите.
Меня одна вещь смущает.
У тебя, по-моему,
с них справа есть
таблиц код.
Кто-нибудь помнит, как называется опция
VS-код, которая вот здесь сверху показывает
заголовочки того,
где я нахожусь?
Мне это сейчас очень нужно будет.
Вот тут где-то это было...
Нет.
Просто сейчас мы запутаемся,
в каком мы нам эспейсе без этого.
Я что-то удивлен, что у меня...
Вот я хочу не вот это вот,
тут тяжело,
а чтобы он на строчках показывал.
Сейчас.
Никто такую фичу не видел, да?
Не помнит?
Очень-очень плохо.
Это, по-моему, стандартная была фича,
и я просто не помню, как она
на строчках показывала.
А вот, вот.
Вот, вот.
Вот, вот.
Вот, вот.
Вот, вот.
Стандартная была фича,
и я просто не помню, как она...
Ладно, будем так.
Будем страдать. Итак,
где находится вот этот вот объект,
к которому мы прилетели,
буквально control-клику
на std ranges swap?
std ranges cast.
Внимание.
Cast — это inline namespace.
Да, вы видели когда-нибудь
что-то?
Ну, вот я их тоже вижу
каждый год, как впервые.
Они не особо важны,
и тут вроде ничего не влияют,
поэтому давайте
откроем на cpp-референс про них.
Inline namespace.
Суть их в том, что просто как будто их нету.
То есть все, что в них, подмешивается наверх.
А что только за их?
Просто эти оформления кожи?
As if they are members
of the enclosing namespace
in many situations.
Но они во всех.
То есть в каких-то ситуациях они считаются,
что лежат в родительском namespace,
и в некоторых — не считаются.
Ну, это от нас независимо.
Ну, вот тут написано.
Это как inline для функции рекомендации?
Еще раз.
Нет, тут
в некоторых
кейсах в языке прямо прописано,
в каких ситуациях, если мы
пытаемся найти имя, мы его найдем,
даже если оно объявлено не в namespace
ranges, а в namespace вложенном.
Ну, вот тут это abusing.
Зачем это вот такие лютые детали,
что просто беда?
Хотите заморочиться и прочитать это?
Я вот не очень.
Нет?
Ну, давайте тогда
и не будем.
В целом считаем, что этого как будто нет.
Почему?
Ну, потому что
неинтересно, скучно,
и я забыл, что там конкретно происходит.
Не особо важно понимать механики
самих inline namespace?
Просто
вот эта вот штука, она как будто
на namespace выше.
Вообще inline namespace используют для
версионирования обычно.
То есть в библиотеке ranges
было inline namespace
v1.
Когда что-то
меняют и обратную совместимость,
там ломают, меняют там на v2,
и те, кому нужно старое, они
явно дописывают v1, v2.
Вот.
Итак.
Из какого-то другого
namespace cast swap, который, кстати, рядом
используется, тип
swap для этого.
Где же, где же, где же
тип swap? Давайте control-кликнем.
Вот он.
Ну, это, конечно, невозможно смотреть, да?
Гады они, конечно.
Это ж просто невозможно читать.
Так.
OK.
Swap.
Что внутри есть?
Это что-то неважное.
Есть главный оператор
круглой скобки, который
void принимает
два аргумента. Деталь, которую я
опустил, аргументы разные.
Ну, и по универсальным ссылкам.
Там, да, это тоже, по-моему, я забил
на это.
А вот тут концепты
про то, что
я говорил. ADL-swap
или
будет работать STD-swap.
Как
оно называется?
О.
Сейчас.
Там online-show,
non-spaces.
Там много шоу.
Не взяли, что поиски
написать outline, а дел show non-spaces.
А это, скорее
всего...
Так. Ну, тогда
надо искать оба слова, я outline,
non-spaces.
В общем-то, это происходит.
Одно же или другое?
Видимо, он сдался от того, насколько
большой файл.
Это explorer, да?
Features, explorer.
Кажется, это не то.
Ладно, неважно.
Здесь он работает.
Ну, тоже не работает. Значит, не outline.
Значит, как-то по-другому.
Знакомый код, правда?
Вот это вот ровно то, что мы смотрели.
ADL-swappable
или работает STD-swap.
И в constexpr ADL-swap нашел,
делается, вы не поверите,
swap с помощью ADL-а.
Кто знает, что это такое?
Зачем здесь какой-то статик cast?
Да.
Это имплементация STD-форварда.
Написанная здесь ручками, потому что
ну, а почему нет?
Настоящие программисты на C++
не используют.
Все переписывают с нуля.
Про noexcept
тоже. Noexcept надо
писать.
И вот эта вспомогательная функция там
просто определяет, нормально ли все будет
с noexcept-ами работать.
Ну, давайте концепт ADL-swap посмотрим.
А?
Это реализация STD-swap.
Руками написанная.
Не знаю, может они решили не include
header-util в header-concept.
Скорее всего, это так.
Тут еще какая-то мелкая
гадость есть?
Кто-нибудь понимает, что это такое?
Это STD-swap, у него же есть две стд-swap
для C-шных массивов отдельно.
Да, есть отдельный STD-swap для
C-шных массивов. Это еще один
оператор круглые скобки же у нас, да?
Да, это еще один оператор круглые скобки для C-шных массивов.
А где вот эта вот строчка-то
проделит?
Сейчас будет. Она же относится
к концепту ADL-swap.
Поэтому, когда мы пройдем по концепту ADL-swap,
мы ее увидим.
И все это
в name-спейсе cast-swap, чтобы ничего наружу не
торчало, да?
Который не inline.
И вот здесь мы
подавили как бы нахождение STD-swap,
если вдруг он там за inclusion,
подавили еще что-то.
Да, могли и написать.
Они, смотри, они не
хотят в header-concepts, это все в
header-concepts, include-ить header-util,
в котором объявлен STD-swap.
Да? Зато
ты в своем коде можешь сначала за include-ить
header-util, потом header-concepts.
И как бы тут все будет находиться.
А если в обратном порядке?
Тоже не важно.
Окей, концепт более-менее
понятный, но тут правда просит
какую-то странную штуку, что это типа
класс или инам, да? То есть там
видимо
отсекают массивы,
указатели на функции,
еще не понятно.
Но главное вот,
это такой визуальный шум, который надо
привыкнуть игнорировать, когда вы читаете код
стандартных библиотек. Вот это здесь суть.
Вот ровно как я показываю.
Визуальный шум вот.
А важная информация вот, не путайте.
И вот, собственно, наш
дилит прекрасный, который удаляет стандартный
swap с вот такой сигнатурой.
Что Unqualified Lookup
найдет через STD
какой-то swap?
Не STD,
потому что здесь вот это есть.
Ну, то есть если мы...
Да, если из STD какие-то
вектора, еще что-нибудь,
то STD здесь по идее должен найти STD
вектор.
Да, потому что STD
swap, сейчас будет смешно, если он
констраин здесь.
О, смотрите, сколько он...
Вэни, Вэрей,
тут он определен. Где
что-нибудь нормальное?
Почему он определен во всех хедерах,
кроме утил, где он должен быть на самом деле?
Погоди, а он, скорее всего,
в BitSmoove.
Определение своего STD слов — это BitSmoove,
который в утиле находится.
А, ну вот он.
Так.
О, видите, как тут
красиво.
Что-то типа...
Если у вас слишком длинные часы,
то концерты... Ну, как-то
типа...
И в C++ меньше
11,
то какая-то
костылина внутри.
Если C++...
Сейчас, да.
О, о, о!
Если C++ больше,
то...
Да, по SFI вместо
Requires.
Ну, читать тяжело,
но, короче, здесь есть вот это вот отсечение
прекрасное.
А, да, а еще свои трейдеры, вместо стандартных.
Ну, в общем,
все прекрасно.
Если Adel найдет
STD move, но при этом
класс не move-assignable
и move-constructable,
то
нам нормально концепт скажет
false. Не будет ложно-положительных
срабатываний концепта.
Вот это главное. Итак,
в целом, все от этой имплементации,
вот cast-swap, здесь вот это смешной
PoisonPill так называемый, я не сказал
это слово, кажется, вот это называется
PoisonPill. Концепт
находит ли Adel что-то, для которого
этот PoisonPill сделан.
Структурка, у которой, ну, какой-то костыль,
чтобы noexcept проверять, не так важно.
Оператор круглой
скобки нормальный, ровно как я показал,
за исключением визуального шума
со всякой мелочью.
И вот этот вот для
массивов неважно.
Дальше inline namespace cast,
в котором мы просто
делаем этот самый объект, и у нас
все работает.
А в родительском namespace ranges
мы берем и делаем концепт
swapable, как просто rangeswap
компилируется.
Во! То есть компилируется,
здесь значит, что концепты удовлетворены
на операторе круглой скобки,
который мы починили через PoisonPill.
Все!
Вот теперь все.
Домашнее задание — полазить по объявлениям
ваших любимых алгоритмов из ranges,
если у вас такого есть, и посмотреть,
что там написано. Наверное,
даже лучше не в lib std c++,
а lib c++.
Прекрасный.
Очень много нижних подчеркан...
Где угодно можно. Можно даже
MSWC STL, он тоже не такой плохой.
На этой прекрасной ноте мы уходим
на перерыв, перед тем, как отправиться
в путешествие опять в пучиную историю.
