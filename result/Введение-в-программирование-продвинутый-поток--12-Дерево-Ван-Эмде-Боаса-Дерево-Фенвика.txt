Итак, все третье. Итак, как я уже сказал, мы снова попытаемся вернуться в сладостный,
чарующий и упадительный мир целых неотрицательных чисел. И попытаемся сегодня решить какую-нибудь
веселую задачу с ними. Ну какие мы задачи решаем? Ну у нас с вами тут все как всегда. У нас есть
черный ящик, в нем хранится сет каких-то объектов. И мы с ними в первую очередь хотим разобрать
вот какие-нибудь веселые вещи. Типа там, ну как всегда там insert, erase. Ну и конечно святое дело
search. Вот. Ну совсем в идеале неплохо было бы. Еще там ну минимум максимум, это так по мелочи.
Хотя вообще одно из самых интересных, что нас совсем-совсем отвлекает от кучи,
это конечно, это конечно аксессор-предсессор. Вот. Хотя вообще говоря не помешала бы еще нам такая
функция как empty. Ну типа пустая структура нет. Да, понятно, что тут конечно в идеале, конечно на самом
деле если есть size, то можно как всегда, там empty равно нулю, но как я уже говорил, empty желательно
иметь отдельно и желательно как-то по оптимальнее. Потому что, ну это я уже приводил пример. Или не было?
Ну это да, было. Ну это дан х, найди минимальный элемент, который строго больше х или строго меньше х.
Не совсем. С аксессор это апербаунд, а предсессор это тоже апербаунд, то в другую сторону.
Да, то есть если их развернуть, если их давно на минус единицу, то да, можно так сказать. Ну да,
то есть в принципе да. Все вот это вот мы умеем делать с вами в двоичном дереве поиска от высоты
дерева, а добиться того, чтобы высота дерева была логарифмической, мы уже там, с какими способами уже научились?
Ну пятью, да. АВЛ, красно-черное, Дикартово, сплей, Б, пять. Вот, но это были, то есть они все там работали
с логарифом. Ну избавиться, ну там теоретически можно попытаться избавиться от логарифа там,
наверное, почти во всем вот этом вот. Ну там минимум максимум там, скажем, мэпти-сайс можно
за от единицы делать, потому что можно во всех остальных операциях тупо пересчитывать, правда?
Это в общем да. Ну вот дальше, ну там, ну вот research. Ну да, можно там делать амортизацию, но совсем от
логарифма мы не избавимся. То есть более того, да, то есть обязательно там, более того, даже в инсорте и с аксессорой
обязательно у нас где-то там логарифм да выплывет. Вот, потому что если в инсорте и с аксессором не выплывет,
то как бы тогда у нас ассортировочка получится. Потому что как бы альтернативной версии ассортировки
сделаем n инсортов, потом n саксессоров или там предиссессоров. Так что как-то вот надо выкручиваться.
Да, просто тупо да или нет. Вот, но давайте думать вообще. А теперь у нас такая вещь, теперь у нас обнаруживается, что
черный ящик это целые неотрицательные числа от нуля до у. Вот так вот, целые неотрицательные.
Ну а теперь давайте думать, что с этим можно сделать. Ну, можно разомнуться, например, и сказать, что у какое-нибудь очень мелкое.
Вот совсем мелкое, например, 10. Ну тогда заметим, что самое тупое, что мы можем сделать, это тупо там завести такой массивчик
на 10 элементов и честно, ну просто типа массив юзит, и честно хранить, кто есть, кто нет, правда? Ну вот, один из вариантов такой.
Вот, тогда часть из этих, ну тогда, тогда insert array search будут за o от единицы работать, empty size, ну если поддерживать, то за o от единицы там.
Ну вот, а вот эти все, правда, будут за o от, за o от u работать, да?
Да, ой ли, вот будешь ты делать array с минимумом, так что. Ну если, нет, ну как сказать, тоже можно выкрутиться на самом деле, если, то есть если там, если эти элементы хранить не только в массиве юзит, но и в двухсвязном списке еще, тогда тоже можно.
И минимум, максимум, заодно и там, нет, successor to predecessor не получится. Ну, точнее так, для каждого конкретного элемента следующий будет за o от единицы находиться, но если элемент не лежит в множестве, то увы.
Ну вот, да, ну и кстати эта вставочка тоже за o от единицы так не сделается, кстати, по той же причине.
Вот, но здорово с ним думаем, если u стало побольше, ну, например, там, я не знаю, сто тысяч, что можно тогда сделать?
Вот. Ну, можно в принципе сделать дерево отрезков. Ну, черните, ну вот. Ну, если там, если построить на этом всем прям вот красивое дерево отрезков, ладно, это некрасивое, ну ладно, так, то тогда там все операции будут условно там за log u работать, да?
Ну, зато все. Значит, что же нам можно попробовать сделать? Потому что у нас ставки были быстрее. Ну, в принципе, заметим, что можно, в принципе, если у нас o от u прям не устраивает, ну там сто тысяч, то в принципе нас могло бы устроить o от корня из u.
Ну, это, конечно, можно сделать. Да, то есть смотрите. Ну, да, то есть, нет, ну на самом деле так, это структура, из которой на самом деле дерево отрезков и вырастает, да?
Ну, в каком смысле? Ну, как бы у нас просто возникла идея, вот мы храним тут массив u и хотим делать операции какие-то, да?
И теперь у нас возникает такая идея. Давайте разобьем этот массив на там, скажем, корень, на корень из u блоков по корень из u элементов. Вот.
И для каждого вот этого блока будем хранить там, я не знаю, минимальный, максимальный, сколько их тут, ну и так далее, да?
Вот. Тогда заметим, что, скажем, например, ну insert и raise тут будут достаточно там, так что смотрите, insert и raise будут теперь работать за корень из u, да?
То есть вот insert, конечно, раньше работал за o от единицы, теперь вот, ну теперь будет за корень из u.
Сейчас он тоже работает за o от единицы?
Ну, не совсем, а, ну да, минимум максимум, да, согласен, согласен.
То есть минимум максимум работает за корень из u?
Да, да, да, да, согласен. Ну, согласен, insert за o от единицы, но вот с raise напряг, потому что минимум максимум придется пересчитывать.
Да.
Но минимум максимум будет все равно за корень из u. Вот. Ну, и successor. Ну, самое сложное с successor, как определить successor?
Да очень просто. Смотрим, вот элемент находится в каком-то блоке.
Если максимум этого блока больше, чем этот элемент, значит в этом блоке мы за корень из u честно найдем successor.
Если нет, то значит мы тогда перебираем следующие блоки и вот находим первый непустой блок и в нем берем минимум.
Все. И это блоков у нас тоже корень из u. Вот.
Ну, то есть заметим, да, что почему, почему в некоторых случаях мы убили логорифом.
В некоторых случаях мы убили логорифом, потому что у нас количество уровней стало константным.
Понимаете, да?
Ну, вот. В принципе, в принципе, да, то есть как бы если мы разрешим себе чуть большую константу, то на самом деле мы достаточно легко могли бы сделать уровень еще повыше.
Смотрите. То есть на самом деле хорошо. Нет, тут-то все по коре низу, коре низу, коре низу. Допустим, все нормально, да?
А теперь давайте над этой штукой еще сделаем надстройку.
А от меня нет.
От чего нет?
Пока что ничего не даст. Там корень кубический должен быть или что-то такое.
Ну, вот. Нет, ну проверь, проверь. Сейчас дойдем.
Хорошо.
Ну, потому что да. То есть, конечно, если совсем в тупую, то согласен, да.
Хотя, нет, вот сейчас подумаем. Ну, хотя, да, если прям в тупую пересчитывать, то согласен. Не покатит.
Вот. Ну, в принципе, да, если сделать было три уровня, да, то тут можно было бы сделать блоки по корень кубический и зу.
И тут тоже блоков корень кубический.
И тогда получится просто три уровня, и там все запросы будут работать за корень кубический.
В принципе, я так могу сделать корень с абсолютно любой степени.
Правда, эту любую степень придется считать как константу.
Вот. Но тем не менее.
Вот. Но вообще, конечно, была бы такая мечта.
То есть, на самом деле, была бы такая мечта, чтобы вот все-таки, то есть дерево андеболоса у нас будет мечтать.
Оно у нас о чем будет мечтать?
Оно у нас все-таки будет мечтать.
Вот. О том, что у нас все-таки дальше мы хотим все-таки пытаться делить это на блоки все-таки поширше.
То есть, тут, ну вот. И даже не мечтать, оно пойдет даже немножко по-другому.
Смотрите.
Смотрите, какая у нас возникает идея.
Вот у нас есть множество.
Вот теперь давай, ну вот.
У нас есть множество, и тут могут храниться все числа от нуля до у минуса 1.
Так вот, идея такая.
А давайте-ка мы с вами разобьем этот массив на корень блоков.
Вот теперь сверху.
И вот заведем, соответственно, корень изу детей.
Где здесь мы будем хранить все числа от нуля до корень изу минус 1.
Здесь от корня изу до 2 корня изу у минус 1, естественно.
Ну и так далее.
В самом конце там у минус 1, и тут там условно у минус корень изу.
Ну понятно, плюс-минус.
Вот.
То есть, вот такая вот условная идея получится.
Далее, что мы делаем?
А теперь идея такая, что и каждую структуру мы устроим рекурсивно.
Да, напоминаю, нам временно это...
То есть, напоминаю, у нас типа это называется наглое трансдихотомиал модел, соответственно.
Поэтому мы там, в некотором смысле, на память плюю.
Поэтому в итоге для самых больших у у нас все равно памяти будет у, а ту я вам сразу предупрежу.
Ну что теперь?
Но каждую структуру мы попытаемся теперь устроить рекурсивно.
Что значит рекурсивно?
Ну то есть, это значит, 고т тут мы тоже будем делить на корень блоков.
Здесь их размер уже корень изу, а корень корня изу...
— Это что такое? — Это корень четвертой степени.
Корень четвертой степени совершенно верно.
То есть, поэтому тут блок уже будет у до корен четвертой степени изу, минус 1, корень четвертой степени изу и так далее.
В чем более-то, вот тут тоже будет размер уже корень восьмой степени, корень шестнадцатой и так далее.
То есть как будет їх треск вeminум модель не на п магазн, а на корень?
Ну вот, ну и так, немножко по-другому, да, в чём сгенерировало оно не снизу вверх, а как бы вот реально сверху вниз.
Ну всё-таки так, ну как сказать просто, да, кажется, что похоже, но не совсем.
То есть вот такая вот у нас попытается быть структура.
Ну во-первых, что в ней приятно, сколько в ней уровней?
Мало.
Да, ну заметим, что мы, ну вот, ну то есть заметим, что мы, да, тут пытаемся извлекать какой-то корень,
но извлекаем до тех пор, пока у нас там размер чисел, которые тут могут быть, он не ограничится отрезком длины 2.
Ну а действительно, а сколько раз вот так вот нужно извлекать из числа корень, чтоб там стало 2?
Да, совершенно верно.
Вот, совершенно верно.
Потому что действительно, если мы хотим извлечь корень степени там 2 в степени k и было меньше либо равно 2,
ну вот, то это эквивалентно тому, что u должно быть меньше либо равно 2 в степени 2 в степени k,
это эквивалентно тому, что там k должно быть там больше либо равно, действительно, log2, log2u, да.
Вот, обратите внимание.
То есть вот такие у нас веселые ноты.
То есть вот такая веселая ситуация у нас.
Вот.
Ну в принципе, конечно, неплохо.
Осталось только нот.
Но правда, как это часто бывает, вот как мы уже в next permutation выделили, да, все красиво и хорошо,
особенно пока мы не начинаем задумываться, как мы будем это кодить.
Ну вот.
Ну с одной стороны, да, но с другой стороны, на уровне идеи, вот особенно когда мы начинаем думать про search,
ну все становится халявно, да, вот.
Ну потому что как должен быть устроен search?
Мы берем число, смотрим в какой корзине он должен лежать, да.
Мы это легко выясняем.
Там просто делим на корень внизу и выясняем там, скорее всего, на самом деле там,
если u это степень двойки, а чаще всего, то у нас это степень 2,
делим на корень внизу и выясняем там, скорее всего, на самом деле там,
если u это степень двойки, а чаще всего так оно и есть,
то мы там просто должны взять просто сколько-то старших бит.
Вот.
Взяли, там взяли соответствующую штуку и пошли в нее.
Значит, там, ну понятно, причем искать, причем на самом деле, смотрите, об этим внимание, что да,
мысленно мы говорим, что тут числа типа большие, но на самом деле, конечно,
мы можем в этой структуре хранить числа от нуля до корень низу минус один,
мысленно потом прибавляя то, что надо, правда?
Так это понятно, что я сказал, да?
Ну то есть смотрите, у нас будет структура,
ну то есть у нас фактически, в образите, будет такая структура
с шаблонным параметром, там я не знаю,
структура с шаблонным параметром u.
Вот.
И она будет хранить себе, делать сет из чисел от нуля до u-1.
Ну да.
У нас, собственно, в этом и суть.
То есть мы делаем вот типа сет.
Только продвинутый.
Но мы его делаем специально для целых,
не отрицать перчитил, потому что у нас жуткое обдозрение,
что в этом случае можно быстрее.
Там чем прям принципиально этот log n.
Вот.
Значит, к чему это нас приводит.
Очень хочется, чтобы каждый из этих детей был просто деревом
с шаблонным параметром корень низу, правда?
Ну, как бы, у каждого дерева у нас есть шаблонный параметр.
Так вот, в этих деревьях он должен быть равен корень низу.
Что делает твое дерево?
Хранит числа от нуля до x.
Какое x?
Вот.
Ну вот.
Ну, заметим, что как бы мы хотели, чтобы дерево...
У нас есть дерево, которое хранит от нуля до x.
А если тут, там скажем, от, я не знаю, y, да, y плюс x,
то как бы мы не очень хочется из-за y писать прям принципиально другое дерево, правда?
Вот.
Но заметим, что как бы это сделать дерево для элементов от y до y плюс x
это то же самое, что сделать от нуля до x,
а в том случае, чем мысленно прибавлять y, правда?
Ну, в чем в нашем случае, как бы, если у нас номер этой корзины,
это старшая какая-то часть bit,
то то, что мы тут храним, это будет младшие bit, правда?
Поэтому по факту вот можно будет их хранить.
На этом мы вот мысленно скажем сразу.
Вот.
Но тогда мы, соответственно, переходим на этот уровень,
потом еще на более низкий.
Так доходим до уровня, когда тут остается два элемента.
Ну, когда тут осталось сет на два элемента, вы уж как-нибудь напишете, правда?
Ну, типа да.
То есть задача написать сет вот со всеми этими операциями
гарантируется, что все элементы либо 0, либо 1.
Вот.
Ну, я верю в вас, да.
Это больше задача по C++, чем по математике, конечно.
Вот.
Потому что на самом деле может быть не такая, потому что потрудиться придется,
но это работа техническая.
Вот.
Но таким образом, смотрите, с сетчем у нас будет все, в принципе, красиво, да?
То есть просто прогулялись, дошли и возрадовались.
Ну, правда, если даже пока временно забить на вот эти все операции,
то есть давайте вот представим, как у нас инсерт будет выглядеть.
Ну, инсерт, да.
Сам по себе инсерт, если мы в дереве ничего не храним больше, да,
то есть просто вот это такая древесная структура и спускаемся,
то инсерт мы тоже делаем залог лог у тем же самым списком.
Да, в общем-то, да и рейс тоже по большому счету, правда?
Но, с другой стороны, заметим, что если бы у нас были только инсерт, рейс и сетч,
то можно было оставить только вот самый низкий уровень в лице,
который был бы неотличим от массива юзет, правда?
И тогда все было вообще за от единицы и вообще без лишних заморочек.
Логично, да?
Вот.
А вот, например, если мы хотим искать какого-нибудь
Ну, да ладно, вот если empty size мы еще, допустим, способны поддерживать легко, да?
Ну вот, там просто в каждой вершине ничего не хранить,
то вот с минимум максимум уже напряг.
Почему?
Ну, потому что заметим, что нам как минимум на верхнем уровне,
если ничего не хранить,
то мы можем хранить как минимум на верхнем уровне,
если мы не храним.
Нам как минимум на верхнем уровне, если ничего не хранить,
кроме вот этих сайзов, ладно, так и быть, мы уже их храним.
Да, но как бы на верхнем уровне вам придется просто честно ходить
по этим корзинам и искать первую непустую корзину.
Это уже корень внизу.
Вот, ну вот, да, вот тут вот идея дерева возникает в том,
что на каждом уровне на самом деле мы храним не только сами корзины,
но и так сказать сет номеров непустых корзин.
Да, именно, именно, да.
Вот, то есть это будет называться так, как это, ладно,
ладно, это мы называли корзины,
ну ладно, давайте для единобразия с литературой,
на самом деле это называется не корзина, а кластер.
Вот это кластер, кластер вот это вот, да.
Кластер.
И у каждого этой штуки еще будет такая ссылка на summary.
То есть summary он будет хранить в себе не пустые, то есть номера не пустых корзин.
Ключей кластеров.
Кластеров.
Кластеров.
Вот, тоже в рекурсивно та же самая структура,
только от нуля до, ну условно тоже, коорганизу минус 1.
Ну да, возможно вы сразу заметили, что у вообще-то не обязано быть квадратом.
Все более того, если мы хотим, чтобы квадрат корень извлекался всегда,
мы вообще должны ввести достаточно жесткое предположение,
что уравно прям 2 в степени 2 в степени k.
А в отличие от предыдущих случаев мы, кстати, так обнаглеть не можем.
Ну потому что, если раньше мы там в кольт-мэш-сорте могли там сказать,
давайте будем считать, что количество чисел, которые мы сливаем,
всегда там сортируем, всегда степень двойки.
Ну если нет, там добьем какой-нибудь, какой-нибудь хренью до ближайшей степени двойки,
а симпатически ничего это не испортим.
Ну у нас же тоже синтетически ничего не испортим, потому что у нас log-log n плюс 1.
Ну log-log n-то может и да, но в данном случае проблема в том,
что если количество элементов у нас назначально увеличивалось не более чем в два раза,
то здесь количество элементов может и в квадрат раз увеличиться.
Ну отлично, но у нас в точку это не влияет.
Ну да, правда на память влияет.
Какой память?
Ну да, мы...
Ну знаете, если ум прям совсем большой, то да.
Хотя у нас есть теоретические потом мечты как-нибудь все-таки это победить
с какими-нибудь хэштаблицами.
Да, но это пока слово ругательное.
Ну а в общем случае, конечно, если вы n говорите, давайте заменим n на ближайшую вот такую степень,
то все-таки это наглежь.
То есть это само по себе увеличивает n, возводит ее в квадрат.
Но тем не менее, пока понаглеем, чуть позже мы от этого избавимся.
Там в общем-то несложно будет.
Пока мы вот храним, то есть получается ссылки на корень внизу и, собственно, одно дерево.
Ну а первых давайте поймем, во сколько памяти это жрет?
Вот поехали, давайте думать.
Значит m от u у нас равно...
корень из u плюс 1, m от корень из u, ну и плюс, ну я не знаю там, ну допустим какой-нибудь вот единиц.
Ну эти сайзы там, эти минимумы, максимумы, вот это вот все, да.
Откуда плюс единицы?
Из самори.
Вот этих вот корень из u, ну вот, а тут прям вот плюс один пришлось брать.
Вот спрашивается, чему равно m от u?
Чего? А v это что?
Это не точно.
А при чем тут? На самом деле нет.
Ну как сказать, заметим, что если бы вот этого самори не было, это достаточно очевидно было бы, что память у нас u от u.
Почему это достаточно очевидно?
Очевидно, ну потому что у нас было бы подвешенное дерево с u листьями и у всех остальных вершин хотя бы два потомка.
Там два ребенка есть.
А отсюда уже легко доказывается, что там количество вершин не более чем 2 u.
А, у вас дискрана не было, да, у вас таких очевидных утверждений там вы еще не доказывали.
Ну и ничего, можете доказать по индукции.
Ну так, просто неформально это можно определить так, что представьте себе, что у вас есть только листы и у всех остальных вершин степень хотя бы два.
Тогда давайте идем таким вот сканлайном снизу вверх.
Сначала у нас есть n листов и типа вот n линий, которые идут вверх.
Потом в какой-то момент две линии сходятся в одну вершину или больше даже.
Тогда начиная с этого момента у нас n-1 линий идет вверх.
Ну вот, ну там несколько, если слопываются больше двух, значит меньше линии остается.
И в итоге это заканчивается тем, что в конце у нас остается одна линия.
Но эти схлопывания, очевидно, было не более чем n-1.
Ну тогда отсюда следует, что и лишних вершин тогда, по крайней мере вершин, на которых происходят развилки, их не более чем n-1.
То есть по факту количество вершин в подвешенном дереве это 2 умножить на количество листов минус 1
плюс количество вершин, у которых ровно один ребенок.
Вот, можно это так сформулировать.
Но в данном случае, да, единственная проблема, что тут помимо этого еще какие-то деревья возникли.
Но тем не менее, я утверждаю, что m от u все равно будет.
На самом деле от u.
Это может быть уже не так очевидно, но по индукции, как всегда, доказывается.
По индукции, да, тут уже, как говорится, оставим в качестве упражнения.
Ничего изобретать вам там не придется.
С кверх того, что мы уже делали.
Вот, поэтому не будем тратить время.
Вместо этого давайте попытаемся понять.
Хорошо, по памяти допустим.
И давайте тогда попытаемся понять.
Что же нам тут требуется делать?
Что нам требуется делать?
Вот.
Так, ну и что нам требуется вообще хранить?
Вот.
Ну, для того, чтобы это лучше понять, давайте хотя бы попробуем понять, значит, как у нас шаблонная структура устроена.
Ну, может быть, код не обязательно писать, но давайте смотреть.
Такая называется, то есть, вот, так сказать, ноде с шаблонным параметром u.
Как она будет выглядеть?
Выглядеть она будет примерно следующим образом.
Значит, смотрите.
То есть, мы будем хранить такой массив кластер размера к внизу.
Каждая ячейка которого – это указатель.
Указатель на структуру вида, там скажем, ноде уровня корни и зуб.
Вот, понятно, да?
И все они такими будут.
Да, тут будет ноде там от корни и зуб, тут и так далее.
Вот.
Также еще нам важно, чтобы у нас был size.
For, не size, а summary.
То есть, это вот эти вот не пустые товарищи.
Понимаете, да?
Вот, это тоже ноде от корни и зуб, условно.
Вот.
Ну, я здесь понятно, что если ноде от двух, ну, там какой-нибудь массив из двух булечек вы сделаете, правда?
То есть, самое веселое, что там могло бы быть – это прописывать там вот все эти методы, их частичную реализацию.
Но у нас сейчас все-таки лекция не по C++, поэтому, думаю, нет смысла.
Хотя, конечно, красивая реализация этого на шаблонах C++ – это, в принципе, интересно.
Чего?
Ну, как вам сказать?
Почему?
Ну, как сказать?
Чего?
Ну, а в чем проблема?
И что?
Нет, на самом деле, если вы как шаблонный параметр записываете вот эту константу, то почему бы нет?
Тогда она просто уже в compile time это все сгенерит.
Ну, вот.
То есть, не реально там во время работы вы будете всякие ньюшки вызывать, а так она уже внутри себя будет все эти кластеры зашивать.
Вот, тут тоже такая рекурсия получится.
Ну, философс. Ну, не знаю.
Ну, как бы, что быстрее, в compile time, чтобы там вся память была так плотненькая и не где-то там в куче?
Нет, но это всегда так или иначе произойдет?
Почему?
Потому что огромный кусок памяти будет мало.
Ну, если совсем лениво, да.
Но там всегда начинаются оговорки в духе, что если он будет выделять память лениво, то как бы все равно, когда вы выделяете вот эту память, вам придется ее зачистить.
Вообще, да.
Другой вопрос. Ну, там понятно, можно там всегда что-нибудь считать.
Поэтому, хотя, конечно, да.
То есть, может быть, если это делать лениво, то да, но мы пока не рассчитываем на ленивость.
Так что, может быть, красиво именно на темплейтах, может, это и неплохо делать.
И иногда там показывал, как это, как написали, как сгенерировать дерево отрезков тоже в compile time.
То есть, что такое дерево отрезков на n элементах?
Это два дерева на n пополам элементов, у которых еще там какая-то типа их общая сумма хранится.
Так что, собственно, почему бы и нет?
Ну, если в глубинарной рекурсии, конечно, в компиляции, по-моему, часто ограничено.
Там какой-то чем-то не сильно большим.
Поэтому это, конечно, не так часто работает.
Но, с другой стороны, иногда почему бы и нет.
Хотя бы на уровне это поржать.
Вот.
Дальше.
Здесь у нас есть это так.
Что мы еще хотим-то вообще?
Так. Ну, мы...
Ну, наверное, неплохо бы хранить, конечно, минимум-максимум.
То есть, вот эти вот, min, max.
Прямо хранить.
Ну, а что бы и нет? А, ну и size, конечно, не помешал бы.
Не, ну а что делать?
Как бы, мы же... Хотя, ну вот...
Не, ага. Не, ну просто, как бы...
Ну вот.
Нет, ну можно, хотя, да, можно, да, пожалуй, можно и не хранить, конечно.
Тупо вызов на summary делать.
Ну, как вам сказать?
Чего?
Тупо вызов на summary?
Понимаете, если вы будете минимум искать, вам нужно сделать min вызов на summary.
Один рекурсивный.
А потом запросить. А в прочем, давайте...
А в прочем, тут как раз, давайте это попишем, чтоб понять, какие у нас еще проблемы есть.
Ладно, давайте дальше развлечемся и без min, max попробуем войтись.
Не, ну size-то нужен.
Size-то нужен, наверное, да.
Min, max не храним?
Ну, пока не храним.
А как мы будем искать?
А, на самом деле, так же, как и всякие инсекты, мы будем это делать.
Нет, друзья, на фига он самый, если мы еще не собираемся min, max сказать.
Собираемся, мы его просто не храним.
Ну, так и я о том же.
В смысле, если у тебя фига не хранит min, max, если ты можешь на самом деле его сделать...
Правда, помимо того, как ты вызвал summary, тебе придется полезть в кластер с номером, который тебе дал summary, и полезть еще туда min достать.
Ну, жаль, достанем.
Да, но это два рекурсивных вызова просто.
Ну...
Нет, смотри, давайте...
Вот давай считать время.
t от u у тебя равно 2t от корня из u плюс o от единицы.
Вот именно, вот если мы и без min, max не будем хранить, то min мы будем считать ровно за такое 7 точек.
Правда?
То есть, там полезли в summary, достали минимальную непустую корзину, а потом полезли в ней и достали ежнюю min.
То есть, два рекурсивных вызова.
Почему два не больше? У нас же глубина не два.
2t от корня из u.
То есть, из одной вершины я делаю два рекурсивных вызова в summary и в кластер.
То есть, на этом уровне два.
То есть, в каждой из них будет больше, конечно.
Так что получается такая рекуррента.
И как она решается?
Ну, как всегда.
Да, давайте, как всегда.
Да, ну давайте пока так скажем, да.
Если u это два в степени k, то тогда мы понимаем, что там.
Условно, да.
Ну да, s от k равно 2s от k пополам плюс o от единиц.
Так, уважаемые избатоки, к чему равно s от k?
Конечно.
Нет, вот если бы тут было o от k, тогда бы это было k.
Ну, меньше 40 было бы, да?
Ну, да, совершенно верно.
Получается t от u, это у нас s от k, s от k у нас это значит o от k.
Ну и соответственно, значит получается o от log u.
Вот, вот, log u.
А хочется log-log.
А пока log.
Вот.
Так что получается, да, минимум, максимум хранить бы хотелось.
Ну вот, ну хорошо.
Давайте их, давайте их мы похороним.
Ну вот.
Тогда, по крайней мере сами минимум максимум будем искать z от единицы.
Ну поможет ли это нам?
Ну а давайте аккуратненько, значит.
Ну понятно, с searching проблем как не было, так и нет.
Вот.
С searching какие проблемы.
Ну вот, с insert.
Почему?
Да.
Ну давайте подумать, как делать insert.
Ну, по-моему, дальше по уровню мы будем подниматься.
И высадовать ноду.
Чего?
Ну, в них спустились, с самого правого режима добрали.
Потом вверх поднимете и мы можем текущий нод подписать,
дописываем, если не можем, то могут садим ноду.
И так далее.
Ну, вести.
Ну не знаю.
По-моему, мы уже все ноды создали, я не знаю.
так давайте лучше это аккуратно не путься я просто я могу проинтертируй так
видимо вы уже слышали это дерево md boss в какой-то другой интерпретации
причем поэтому мы с вами немножко сейчас на разных языках начинаем
разговаривать нет нет ну не знаю потому что потому что я не знаю откуда вы взяли
потому что мы сейчас не занимаемся никакими там генерациями каких-то там не
созданных ранее вершин я не знаю вот нет найти x да а мы его вставить хотим да
все все что никаких проблем нет да да ставляем в выходе назад если у нас можно
легко проверить да вот да да да да да это проблема проблема заключается в том что
да если он оказался пусто до то есть мы если он оказался пустым видите да то
значит да то вы туда добавили этот элемент да теперь вам придется еще и в
саморе соответствующую корзину добавить у нас получается опять два рекурсивных
вызова в общем не буду переписывать то что тут было вот то есть еще страшнее на
самом деле вы рэйзе потому что как будет работать и рэйс но это пол беды еще потому
мало того что как вы хорошо вы там это удалили элемент допустим полезли в саморе
и тогда вы не съем там как корзина оказался пустой полезли в саморе тоже и
удалили да допустим окей только есть одна маленькая проблема мы же все тут
подписались на минимум максимум да а теперь проблема у нас минимум максимум
могут быть буквально чуть-чуть измениться очень сильно ну да в том числе и на
нашем и теперь давайте думать как теперь найти минимум как бы если оказалось что
он удален но тогда придет но вот как это сделать вообще ну да но заметим да
после того как мы удалили лишнюю корзину и саморе допустим ну да вот то
теперь можем найти до минимальную пустую корзину саморе допустим да это мы за
вот единицы делаем вот ну а соответствующий кореа потом залезли в
соответствующую корзину кластера этот минимум вычислить и его сохранить так
что слава богу ладно ладно ладно лишь вот то есть в рэйзе тоже придется два
рекурсивных вызова и от единицы времени слава богу хорошо ладно а с аксессор
проговорили там проговорили что надо отставить в кластер и если нужно саморе
того два рекурсивных да и да и мы согласились тем что это проблема но как
бы у нас цель такая петь и мы как бы делаем как бы и там несколько в
несколько ипераций подходы которые нас приближают к цели
ну конечно на всех потому что мы потому что мы обсуждаем что происходит
конкретно уровни в терминах рекурсии поэтому нас тут будет т от у равно там
2 т от корней зуб плюс от единицы вот значит что еще давайте до хорошо минимум
максимум учились mt size ok но они тоже там легко пересчитываются везде это не
проблема ладно с аксессор предиссессор вот давайте думать но они у нас
симметричные по такому раскладу поэтому как сказать так с аксессор на
максимум ну в принципе да то есть как искать как вы ищем с аксессора но сначала
берем число их смотрим в какую корзину должен попасть и смотрим есть ли лежит
ли этот с аксессор в этой корзине тогда что у нас получается если с аксессора
если там максимальный элемент ну как вы просто берем максимальный элемент в
этой корзине если оказалось что он больше икса то значит с аксессор лежит где-то
тут и надо просто один один раз обратите внимание вызваться рекурсивно от этой
штукенции один раз вызваться вот но но но но но а что делать если этот если там
этого с аксессора нет да совершенно совершенно верно тогда надо просто
найти следующую корзину то есть следующую не пустую корзину и в ней
выбрать минимум согласны но тогда смотрите как приятно так как минимум мы уже научились
делать за у от единицы то получается вот с аксессор делается с одним
рекурсивным вызовом и как следствие он работает за лог лог у неплохо так
правда ну и предсессор автоматически тоже симметрия да слушайте как приятно то
есть получается то есть у нас пока только в инсерте и рази проблема то есть как бы
если бы у нас было дерево статическое но вот если у нас дерево было какой-нибудь
вот такой статическая то вот но только эти операции то есть там мы там один раз
там дали множество мы все честно сгенерили то в принципе мы теперь на
таком дереве действительно все операции делаем за лог лог вообще неплохо правда осталось только
понять а как бы действительно так сделать чтобы инсерта и рейс все таки
вызов делались не то есть делали нам не два рекурсивных запуска как же это
сделать но в этом случае садите мы тут мы задумываемся вот на чем смотрите ведь
у нас два рекурсии вот теперь вот вы инсерта смотрим да вот заметим что когда
мы делаем инсерты мы иногда делаем два рекурсивных вызова но когда мы делаем
два рекурсивных вызова да то есть у нас три варианта либо структуры либо структуры
либо один элемент либо много ну от двух и выше главное можно и так но вот но давайте все-таки не будем
отклоняться от структуры тем более что в общем идея недалеко ушла значит но на самом деле то что
я сейчас скажу это на самом деле та же можно сказать принтерпит даже самая идея но немножко
другая формулировка формулировка такая а давайте просто вот в этих всех кластерах и саморях не
хранить минимум и максимум ну то есть идея в следующем да что раньше у нас то есть этот
элемент вот когда он минимум да то есть мы его должны как бы правда идти здесь и добавить куда-то
сюда да а теперь у нас возникает идея что если у нас скажем в этой структуре хранятся числа какие 2
5 7 8 11 13 то тогда мы говорим что минимум равен 2 максимум равен 13 а вот в этих вот кластерах
где-то там вот хранятся 5 7 8 11 то есть кластеры самори про 2 и 13 ничего не знают вот понятная
идея на самом деле то есть по большому счету это как раз тоже самое на самом деле но потому что
да мы могли бы сказать что если у нас один класть то есть у нас какой-нибудь один то есть если у
нас был там какой-нибудь один элемент то он так оно и будет смотрите что кластеры самори будут
просто пусты а в минимум максимум будет записан собственно сам этот элемент то есть более
того мы пошли даже чуть дальше если у нас два элемента мы тоже на самом деле ничего дальше не
храним но это такой интерпретации то есть на самом деле если открыть кормановскую интерпретацию там
сказано так минимум в кластерах не лежит а максимум лежит то есть на самом деле до этого хватает
правда с аксессор и предиссессор превращаются в немножко несимметричные вещи но как говорится
мы с вами тут все симметризуем поэтому давайте все-таки минимум максимум оба будут не лежать где
надо вот то есть тогда смотрите как это как такая ну во первых понятно новая интерпретация да и так
минимум максимум мы кластерах не храним то есть вот очень удобно тогда смотрите к чему нас это
приводит с точки зрения инсерта с точки зрения инсерта но нам это говорит так ну вот то есть мы
говорим вот нам приходит нам сказали вставь пожалуйста элемент x но мы думаем тогда мы заметим что
если там если в клае если тут пусто вообще да то вставка будет выполнена за от единицы согласны
вот ну потому что тогда нам просто будет то есть если там пусто то мы просто тут везде
икс сюда записываем икс сюда записываем сюда записываем единичку и до свидания более того
если тут один элемент а это мы выясняем когда минимум равен максимум а ну или
я как бы меня три случая когда когда вот когда это это все изначально пусто когда в нем один
элемент когда остальное потому что раз 4 если оказалось что тупо минимум там size равен 1 или
там минимум равен максимуму да то тогда мы просто говорим что там либо минимум либо максимум
обновляем и в общем-то все больше нам ничего не надо делать тоже за вот единицы то есть самое
интересное начинается то есть самое интересное начинается когда сайс становится больше чем 2
это означает что какой-то рекурсивный вызов не избежит и в общем-то избегать рекурсивного вызова
в кластер нам мы не сможем единственная только оговорка заметим что нет гарантии что мы в
кластер будем вставлять именно элемент x почему ну потому что вот если элемент x допустим
оказался 9 то да мы эту девятку в кластере отправим правда но если он окажется 19 то тогда он
должен оказаться на месте максимума но тогда понятно что тогда мы его запишем сюда а в кластера
отправится число 13 то есть таким образом если сайс как бы был перед инсертом больше либо равен
двух инсерты реальной то нам придется какой-то элемент кластера добавлять не обязательно тот же
самый что если x был больше максимум или меньше минимуму значит придется что-то другое добавлять
но что-то придется а вот теперь думаем и так у нас есть какой-то элемент давайте вот поэтому
исходя из этих причин назовем его x штрих который мы хотим добавить именно в кластера значит мы
говорим как-то работает это работает так мы говорим достать добавляем там типа добавляем
элемент в кластер соответствующий там добавляем элемент кластер если оказалось что у окажется
пред добавлением этот кластер был пустым то мы добавляем саморе казалось бы два рекурсивных
вызов но на самом деле нет почему потому что если кластер был пустым то мы в этом случае вставили
элемент за от единицы, как вы, собственно, и хотели изначать. И таким образом, как бы,
один из вызовов, собственно, сработал за от единицы просто
за мгновенно, поэтому реальных, таких нетривиальных вызовов, получился один, и
таким образом это работает в лог-логу. Вот, понятно? Вот. Что еще теперь?
Не, размечтался. И рейс там еще нужен, но давайте думать с дилитом, но давайте
думать, как тут что-то удалять. Ну, во-первых, значит, смотрите, ну, во-первых,
заметим, что если мы удаляем последний элемент из структуры,
то тогда мы это делаем за от единицы. Согласны? Ну, кстати, если этих элементов два,
то мы тоже это делаем за от единицы. Ну, потому что если это пластера пустые,
то только эти два элемента, значит, мы там либо минимум, либо говорим, что минимум больше нет,
он равен максимуму, либо, наоборот, максимум равен минимуму. Понимаете, да? Ну, по сути,
вот, соответственно. А вот если size больше двух, то у нас проблемы. Потому что что-то из
кластеров придется доставать. Ну, понятно, что если х не совпал ни с минимумом, ни с максимумом,
вот как раз, там оказался 9, и при элементах от 2 до 19, то мы тогда, нам придется удалять этот
элемент из кластера рекурсивно, правда? Ну, кстати, давайте попробуем. Что мы делаем? Ну, мы говорим,
что мы удаляем этот элемент рекурсивно из соответствующего кластера, и если оказалось,
что соответствующий кластер опустел внезапно, да, после этого, то тогда мы лезем в summary и
рекурсивно все очищаем. Точнее, рекурсивно удаляем этот кластер. Но, как мы уже сказали, если после того,
как мы удалили элемент из структуры, она опустела, значит, мы это сделали за от единицы, правда?
Скучно, все уже заснули, да? Ну, да, да, да, что-то как-то халява какая-то пошла. Вот. Ну, вот. Ну,
вот, дальше давайте смотреть. Ну, вот. Ну, тогда получается, что реальный рекурсивный вызов,
то есть такой, не разворачиваем его от единицы, он один, и опять все залог лог у. Правда,
с оговоркой, что как бы это нам повезло, и мы удаляем не минимум и не максимум. Понимаете, да? А что
делать, если мы удаляем, вот давайте ради разнообразия нам пришлось минимум удалить. Ну,
тогда, значит, мы знаем, что где-то в кластерах у нас находится элемент, который должен теперь
стоять здесь. И из кластеров мы его тоже должны удалить, правда? Ну, правда, для этого его надо
найти. А чему равен минимальный элемент из тех, которые лежат в кластерах? Ну, как всегда, да. То есть
как найти минимальный? Находим минимальную непустую корзину. Это вот у нас в саморе такой есть
за от единицы, да? И после этого тогда мы в соответствующем кластере достаем оттуда минимум,
все. То есть получается, то, что тут должно быть написано, мы нашли, осталось только его рекурсивно
удалить. То есть предварительно записавшим мы тут пишем 5, и эту пятерку придется потом отсюда
удалить. Ну, удаляем абсолютно так же, там теми же двумя, в смысле одним рекурсивным вызовом.
Секундочку. Мы удалили минимум. Удалили минимум. После этого мы взяли и сделали рекурсивный вызов
саморе. Или нет? А, нет, саморе хранит свое минимум. Да, саморе хранит. Она же вот ведь не случайно мы тут себе
рекурсию поставили. Вот. Хорошо. Хорошо. Инсерт мы убили, эрейс мы убили. Вот. Классно, классно. Так, хорошо.
Ну, минимум, максимум, все понятно. Осталось только, ну вот. Ну, с другой стороны, что теперь? Осталось только
сексессора найти. Ну, не совсем, у нас все-таки модификация произошла. Ну, с другой стороны, да,
заметим, что с сексессором у нас действительно все просто. То есть мы берем элемент, ну, как всегда. То есть,
как бы предыдущий механизм модифицировал столько тем, что надо отдельно разобрать случаи, когда там
эти сексессоры могли оказаться минимум и максимум. Ну, идем так, возрастающие. Если ваш х оказался меньше
минимума, значит вы тупо его выводите за вот единиц. Если он оказался, там, ну, больше либо равно максимума,
можете сразу там плюс бесконечность выводить. Правильно, вот. Но если он оказался больше либо равно минимума,
но меньше максимума, значит, пытаемся найти ответ в кластерах. Ну, как мы его находим? Лезем в соответствующий
кластер. Если за от единицы там мы выяснили, что там сексессора нету, а мы за от единицы выяснили, то значит
мы находим, вызываем сексессора от summary в соответствующей корзине и в этой корзине находим минимум.
Правда, может быть, оговорка, что и в summary не оказалась в следующей корзине. В этом случае в качестве сексессора
придется вывести максимум. То есть вот только такое добавление вот таких случаев, но, естественно,
она асимптосикой это не влияет от слова никак. Вот. То есть, конечно, бустоконстант останется чуть более жирный, но не более того.
Вот. Ну, в принципе, да, можно было, наверное, сразу проинтерпретировать и в терминах. Давайте, если один элемент,
то мы его храним, если два, то там начинаем развлекаться. Вот. Но на самом деле суть одна.
Да, можно было развлекаться даже на уровне, что давайте так, даже не минимум максимум мы храним отдельно.
А, точнее, минимум максимум мы храним, а так помимо кластеров у нас есть один элемент, который мы тут специально храним отдельно.
То есть, я думаю, даже этому бы хватило, просто в данном случае мы это изящно объединили. Вот.
Ну вот, поэтому сексессор, предиссессор тут становится чемпионами, ну чем что приятно, да, empty size.
Ну вот. То есть более того, там на самом деле в оригинале предлагается, что если нам, что мы можем даже size не хранить
и empty все равно себе поддерживать. Ну, потому что нам достаточно знать, что, скажем, если оказалось, что там, скажем,
минимум максимум равны какой-нибудь минус бесконечности или просто минимум больше максимума, значит, у нас пусто.
А в противном случае там что-то есть. И этого нам достаточно. Ну вот. Так что вот таким образом оказывается,
что если действительно так не заморачиваться и код не писать, по крайней мере, то, в общем-то, структурка оказалась достаточно простой.
Так, ну что, есть ли тут какие-то вопросы?
Да, то есть все операции теперь работают за log log u. Ну ладно, не все, некоторые за log единицы.
Ну, минимум максимум понятно мы тут раз уж храним, что бы их за log единицы не делали. Все остальные, да, вот оказалось, что мы делаем за log log u.
Ну, единственная оговорка, что, по-хорошему, надо еще оговориться, а что делать, если у нас корень езу не существует?
Ну, типа да. Ну, на самом деле, да. То есть там в оригинале предлагается так, что, предлагается на самом деле более такой штука, что на самом деле
у пусть это будет действительно буквально степень двойки. Вот, понимаете, да? Ну вот, а вместо корней, значит, тут водится что-нибудь в духе.
Смотрите, то есть, то есть, водятся такие понятия, как корень вниз и корень вверх. То есть, что это такое?
Что это такое? Это два, то есть, если u это два в степени k, то, значит, это будет равно два в степени k пополам округленное вверх,
а это, соответственно, два в степени k пополам округленное вниз. То есть, обратите внимание, то есть, это оказывается очень удобно, значит,
потому что тогда у нас действительно все структуры хранят в себе тоже, действительно, элементы степень двойки, то есть, какие-то там сколько-то битные числа, да?
И тогда, например, если у вас есть, соответственно, k-битное число, то на самом деле вот у вас есть, то есть, вот эти биты, оказывается, это номер кластера.
Вот номер кластера. А это называется само число в этом кластере.
Вот. Ну, то есть, просто получается что-то один там, допустим, какое-нибудь вот такое число. То есть, как бы, то есть, в кластере номер 1 0 1 0 0 1 вы будете в реальности искать там число 0 1 1 1 0, а не вот это вот все.
То есть, поэтому, как бы, размер этого кластера, видите, это теперь, то есть, если это у, то есть, кластеров у нас будет, допустим, у вот это округленный, то есть, верхний корень, то значит, здесь он будет нижний, но здесь, правда, с оговоркой, что он будет, что тут, конечно, округлять придется вверх.
Вот. Ну, потому что сколько у нас корзин, понимаете, да? Вот. Ну, понятно, что там все сильно принципиально, а на симптотику это не повлияет. Да и не принципиально тоже.
Вот. Но зато будет действительно очень красиво на самом деле сделано. Так что вот такая вот штукенция у нас получается.
Так. Ну что? Есть ли тут какие-то вопросы?
Ну, с хэшмапой, ну, на самом деле, да. Вот давайте подумаем. Мы себе вот, как бы, тут тоже попытаемся максимально абстрагироваться. Давайте себе представим, что у нас есть какая-то, какой-то мистический черный ящик, именуемый там, именуемый хэшмапа,
который умеет для наших целых чисел делать тупо insert, erase и там условный search. Ну, search такой условный search. Почему? Потому что там скорее всего будет же, то есть хочется, чтобы это было именно не хэш сета, а хэшмапа.
Ну, в том плане, что понятно, что, как бы, по каждому элементу, еще рядом с каждым элементом хранится какой-нибудь указатель или конечную структуру.
Ну вот, предположим, что такой черный ящик у нас откуда-то взялся и все эти операции работают за внезапно от единицы. В каком-то подходящем смысле. Ну, честно скажем, скорее всего вероятностным.
Вот. То есть там будет такая, то есть в принципе есть такая структура, которая будет действительно работать за там, то есть учетным от ожидания от единицы.
В чем более-то, ну там отдельная песня, потому что там начало с того, что можно вообще изобрести такое хэширование, чтобы, вот представьте себе, что у вас такая сначала халявная задача такая типа.
У вас просто есть n произвольных целых не отрицательных чисел. Вот. Статическая множество. А вам тупо хочется придумать структуру, которая за у от единицы берет какое-нибудь произвольное число х и говорит, оно в этом множестве есть или нет?
Вот тупо, да или нет? Ну, желательно, если да, то что. Так вот. Тогда, смотрите, тут прикол в том, что существует такая структура, которая предподсчет делает за мот ожидания у от н.
А потом после этого на все search отвечает за у от единицы уже, причем не в среднем, а в честную.
В чем предельно честно, без этих там оговорок, что там с вероятностью 1 делить на миллиард, она ошибется. Нет никаких ошибок.
Ну, у от н. Нет, н это количество элементов, а не максимальный из этих элементов.
Нет, там красивая структура, что мы там действительно изобретаем какие-то универсальные семейства хэшей, то есть там какие-то с остатком н мы генерируем эти хэши случайно.
Все отправляем по корзинам, доказываем, что сумма квадратов размеров этих корзин в среднем будет у от н.
А на самом деле просто ситуация, что предположим, основная идея заключается в том, что предположим, что у вас есть l элементов и вам разрешается пожрать l квадрат памяти.
Допустим такое, да? Тогда утверждается, что тогда это можно сделать вообще в тупую. То есть мы там генерием правильным образом хэши,
просто берем хэши н. То есть какую-то хэш функцию генерируем и утверждается, что с вероятностью где-то хотя бы одна вторая на самом деле вы сгенерите хэш функцию так, что для этих элементов.
То есть хэш функцию генерируем по модулю l квадрат и окажется, что просто эта хэш функция просто не даст вам коллезий.
Ну там просто условно, смотрите, но там будет какая-то хэш функция по модулю l квадрат и вероятность того, что у двух различных ключей будет коллезия, она будет генериться так, что вероятность этого будет 1 делить на l квадрат.
Но тогда мат ожидания количества проблемных пар, это что будет? Это получится l на l минус 1 пополам и поделить еще на l квадрат. То есть это меньше 1 и 2.
То есть неформально говоря, это означает, что если вы будете много-много раз генерировать эту функцию, то среднее число коллезий у вас будет меньше 1 и 2.
То есть отдельный вопрос верно ли, что там именно с одной стороны вы будете на что-то натыкаться, но там же включаются какие-нибудь простые вещи типа неравенства Маркова, которые вам скажут, что вероятность того, что вы превысите мат ожидания в два раза не превосходит 1 и 2.
Ну там, а если 3, то в 3, то 1 3 и так далее. Ну там вот я напишу заклинание.
В предположении, что если ваша случайная величина генерит неотрицательные числа, то и у нее есть мат ожидания, то верно вот это утверждение.
То есть нет, если понять, что оно значит, доказывается вообще тривиально на самом деле, но это если раскопает, вы точно знаете, что такое мат ожидания, но вот как это, вот я, честно говоря, не хочу в этом смысле дублировать работу собственно курса Тервера.
Поэтому хочется это рассмотреть на втором курсе. То есть вот это неравенство Маркова, это вообще тривиально. То есть там неравенство Чебушова будет интереснее.
Ну там тоже самое, только с дисперсией и квадратами.
Да, не сталкивались? Я бы сказал, что более обычно для меня е, но вообще да, и так, и так есть. Да, согласен.
Ладно, ну вот, так вот, мы к чему, так вот, предположим, что каким-то мистическим образом, все более того там утверждается, что статик точно можно, ну вот, ну и динамик можно докидывать.
Ну там динамик работает, там предлагается по принципу вектора как-то делать, то есть в том плане, что генерируем эти хорошие хэш функции, потом добавляем элементы, если их стало слишком много, просто тупо перегенерируем всю хэштаблицу.
Ну как векторы помните, да? То есть слишком много генерируем, слишком мало тоже перегенерируем в сумме, там генерируем за средним УАТН, поэтому получается хорошо.
Вот. Ну а так вот, предположим, откуда-то этот черный ящик вот с небес по факсу нам прислали.
Вот. Вот. Соответственно. Что мы тогда делаем? Как это тогда нам вообще может помочь? Как нам это поможет?
Вот. Ну. Ну да. Ну не совсем так. Ну я бы сказал так, на самом деле и кластер, и summary вы можете тупо заменить на...
Ну хотя нет...
Summary не можем.
Ладно, summary не можем. Нет, ну как сказать, ну половину работы summary, если бы не минимум, максимум и вариант на них, то вы могли бы заменить.
Потому что по большому счёту кластер нам надо заменить теперь на хэшмапу, правда? А так, в принципе, если у нас задача там...
Если от summary нам нужно только проверить, есть ли такой элемент там, ну тогда, извините, мы и в кластере, скорее всего, там просто тем же сёрк, чем и скажемся.
Есть такой элемент, да или нет? Вот. Вот, на самом деле. То есть, конечно, нет. Ну вот.
Ну, то есть, конечно, единственное, у нас, конечно, есть вот этот минимум и максимум, который нам в summary тоже нужно хранить.
Поэтому мы в summary, пожалуй, будем хранить это отдельно. Ну а теперь единственное оговор, а сколько памяти это будет жрать?
Если предполагать, что там память, допустим, кластера, хранящего n элементов, это от n.
Я не понял. Мы summary заменили на что-то или оставили его деревом?
Нет, summary мы оставили. Summary это честное дерево.
Что мы вообще заменили на хэшмапу?
Кластер.
Кластер за...
То есть у нас теперь кластер. Это не корень внизу деревьев, а хэшмапа, где по каждому непустому номеру корзины у нас появляется ссылка на реально существующее дерево.
Но делаем мы это только для непустых. То есть, пустые мы тут тупо не храним.
То есть, как вот заказывали изначально. То есть, если дерево пустое, мы его тупо там не создаём. Как только оно стало пустым, мы его вообще тупо удаляем.
И пустоту мы теперь меряем по принципу указатель пустой. Да, я пошёл. Указатель не пустой, значит там что-то есть.
Так, ну давайте думать. И сколько же памяти это у нас в таком виде пожрёт?
Хуже, лог-лог-у тогда.
Да, потому что если элемент существует, то, казалось бы, он должен там досуществовать, прям вот генерить, генерить, генерить, генерить, генерить.
И идти просто на все лог-лог-у уровни. То есть, поэтому у нас, казалось бы, должны быть n лог-лог-у листов.
С точностью до минимума, минимума и максимума.
Но на самом деле, да. Но на самом деле, я утверждаю, что минимум и максимум нам тоже здесь прекрасно выручит.
Потому что утверждение такое, потому что если в структуре хранится один элемент, то тогда, извините, у нас и кластеры самые пустые, правда?
Более того, мы себе даже два элемента тоже за вот единицы памяти храним.
Но тогда получается, смотрите, но тогда получается интересный момент.
То есть, я утверждаю, что если в вершине есть не пустые дети, то тогда не может быть такой ситуации, что у вершины есть ребенок, который хранит себе все, правда?
То есть, условно говоря, чтобы правильно сделать, смотрите, можно было бы временно там, допустим, забьем на кластера.
Представим себе забьем на кластера, то есть на саморе.
И тогда вообразим себе, что тут указатель не только на кластер, но еще на минимум и максимум тоже есть указатель, допустим.
Тогда у нас получается, что каждая вершина в дереве, кроме листа, это вершина, которая объединяет в себе две какие-то различные ветки, правда?
Ну давайте представим себе, что минимум и максимум мы храним тоже специально ради него, можно сказать, создаем специальное дерево, в котором храним только этот элемент.
Тогда получается, что каждая вершина не лист, она объединяет в себе два листов, но так как листов у нас теперь получается ровно n, то получается тогда и вершинок у нас n.
Сказали бы мы, если бы у нас не было саморе. У нас же еще и саморе есть, правда?
Спрашивается, вот возникает вопрос, как говорится, не использует ли нам жизнь саморе?
Где тут? Мы это, к сожалению, считали в предположении, что у нас как бы есть n листов, то есть n листов считает, что каждому листу содержится какой-то элемент.
Но это верно только без саморе, потому что конкретно в саморе мы еще вот эти корзины храним, и с этими корзинами тоже, к сожалению, надо что-то делать.
Поэтому действительно может возникнуть проблема. Вот там жутко интересно, возникает ли она.
Если у нас тут действительно о от непустых корзин.
Ну а давайте попробуем честно написать. В данном случае m от, допустим, n, то есть m от n и, допустим, u, можно вот так сказать.
То есть оно на самом деле равно от единицы, ну на сети вот минимум, максимум и сайза, плюс сумма, ну давайте переберем все непустые кластера.
Ну вот и получится там, скажем, n и t, то есть там в непустом кластере номер и у нас будет m, n, и t корень и u, ну там пока не будем заморачиваться, там где вот количество непустых, пусть у нас количество непустых кластеров равно вот k.
И плюс соответственно, что там еще, плюс m от k корень и u.
Причем мы знаем, что сумма всех n и t на самом деле равна, ну условно говоря там, я так скажу, максимум из нуля и n-2, если совсем формально писать.
Ну тогда как у нас с линейностью, тогда получается, что если мы все это просуммируем аккуратно, то есть как всегда мы предполагаем, что m от n и, допустим, u не превосходит cn, мы предполагаем, да?
Вот. Так, да, кстати, не совсем так, сама по себе хэш-мапа, она все-таки не u от единицы жрет, правда? Она на самом, то есть хэш-мапа все-таки жрет u от k, вот, понимаете, да?
Поэтому u от k. Но тогда, если у нас тут не происходит cn, это мы предполагаем по индукции, да? То есть здесь мы это расписываем как? То есть тогда мы пишем, что это равно, там, меньше либо равно, чем?
Ну что у нас тут получается? ak плюс, значит, сумма по таким штукам, как, значит, значит, cnt плюс ck. Но сумма nth равно, там, n-2, условно, да?
Вот. Но тогда получается, что, там, для достаточно больших n, там, больше двух, мы получаем, что это ak плюс c на n-2, сейчас, так, что-то не хватает. Ну вот, а, ну да, и плюс ck. Так.
А как мы это получили? Откуда мы взяли, ну, ak, это понятно, плюс сумма cn.
Ну, плюс чего?
Сумма c, может, на...
Вот, например, положили, что m от mu это cn.
Да.
А, окей.
Вот.
Ну, пока ничего не получили, да, видите, опять у нас проблема, что вот, то есть тут, конечно, минус два, какая-то перспективная минус два есть, но мы ее не убили.
Вот. Ну, что в этом случае делать? Ну, давайте, как всегда, предположим, что у нас все меньше либо равно не cn, а cn минус d.
Вот. Ну, тогда тут видим, действительно, ak, но тогда эта сумма получается, что тогда, если тут мы по всем соберем d, то у нас на самом деле тут получается минус, да, тут получается минус dk приходится делать, и тогда здесь добавляется минус dk, и тогда это минус dk прекрасно убивает и ak, и ck, если правильно.
У нас же еще последняя сумма.
Чего еще раз?
У нас вот есть тут кальция m и еще одна емка в конце.
А, вот эта?
Да.
А, так, смотрите, мы эту оценили как a, а эта оценилась как c.
Так, ну, так и кальция m надо писать.
А. Ну, хорошо. Ну, это... ну и хорошо. Значит, как раз эта дешка останется и будет жива.
Потому что, когда эта дешка убьет вот эти a и c, да, то есть, если d будет больше либо равно, чем c, то это меньше либо равно, чем cn минус 2 будет минус d.
Получается кайф.
То есть, там, условно, там, меньше либо равно при d больше либо равном, чем c, там, плюс a.
Значит, получается, это меньше либо равно, чем... значит, c на n минус 2 минус d.
Ну, это меньше либо равно, чем cn минус d. Ура.
То есть, даже не при... ну вот.
То есть, обратите внимание.
Понимаете, вот киркпаттер в сорке нам пришлось для того, чтобы симптомика сошлась, делать специальные читы, как бы из корзины специально доставать максимум.
Помните?
Да.
Но здесь это уже автоматически сделано, поэтому этот эффект сработал сразу.
Да. Именно. Именно. Именно.
Так что вот.
Так что получается, да, здесь память тоже чуть-чуть побольше, но тоже линейно.
Так что получается, да, такая вот красивая вещь с хэшмапами и операциями за log-log-u на самом деле вполне себе работает.
Ну, правда, там, кто-то писал, жаловался, что константа у нее, конечно, так себе.
Вот.
Но с другой стороны.
Ну, как бы, получается, так что если у вас сет чисел на 10-18, то в принципе, получается, саксессор-предесессор, можете попытаться развлечься и делать это за log-log-10-18.
А сколько... а чему у нас карер, кстати, log-log-10-18?
А, вот такой, да.
На 10-18 это примерно и лонг-лонг.
Да, log, ну да, получается, 5-6 где-то.
Нет, ну, как бы, да, не log-звездочка, конечно, тем более, но все-таки, да.
Так что вот такая красота.
Так, ну ладно, как раз пришло время перерыва.
Ладно, после перерыва тогда, значит, придет заняться чем-то еще.
