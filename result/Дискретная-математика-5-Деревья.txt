ладно начнем смотрите какую часть определение я не успел дать это понятие простой цепи простого
цикла простой цепью простой цепью называется маршрут маршрут помните определение маршрута
это последовательность ребер вершина ребро вершина ребра вершина ребра помните да
цепь маршрут я говорил это это цепь путь маршрут это на одной тоже там просто разные литературе
немножко по-разному называются но это можно использовать как синонима вот кому как удобно
маршрут цепь путь вот называется маршрут в котором все вершины ребра попарно различные вот так
видимо только последнюю часть как раз лица и за и посмотрел потому что мне там нужно было
высмотреть где я закончил вот ну и куда что понять что вписать в программу я как говорил я
составляю ее прям по ходу прочел лекцию вписал то что прочел в программу ссылки
себе сразу сделал чтобы в конце в конце этим не заниматься уже вот ну и простой цикл это вот что
простым циклом циклом называется просто цикл цикл в котором все ребра попарно различные помните
что такое цикл это замкнутая цепь да то есть цепь в котором первые последние вершины одинаковые
вот все ребра попарно различные должны быть простой цикле и все вершины кроме первой
последней тоже попарно различные все вершины кроме первой последний попарно различные
ну что же вот две вещи еще которые нам понадобятся дальше это так в смысле вершины
кроме последний первый последний попарно различный тоже вот понимаете в чем разница
между простым циклом и циклом который простым не является понимаете нет ну цикл который простым
не является может выглядеть например вот так ну то есть мы вот так двигаемся например
вот цикл который простым не является например цикл простой если у него все вершины разные
кроме первой последней и все ребра поняли да да хорошо значит смотрите теперь дерево деревья
это такой подраздел которым в котором мы докажем того но смотрите давайте я вот буду
подсказать подсказать подглядывать потому что у меня во первых определений дерево 6 я хочу
эквивалентность их 6 доказать для этого их нужно выстроить в правильной последовательности значит
смотреть теорема это как раз 6 эквалентных определений дерева
то есть как раз сразу докажем эквивалентность их смотрите первое определение смотрите теорема
для графа же который в ие эквивалентно следующие эквивалентные следующие утверждения
первое утверждение заключается том что же связано циклический граф что такое циклический
граф грамбес циклов вот ну или давайте связанный граф без простых циклов так вот напишем
пожалуйста
так
сложный цикл в любом графе может быть пожалуйста вам приведу пример раз раз
вот сложный цикл вам пожалуйста
у всех графов есть сложные циклы пожалуйста вот если хоть одно ребро есть раз раз вот вам
сложный цикл все это у любого графа есть такое ну нет циклов да вообще здесь связанный связанный
кстати что такое связанный забыл я давал это определение вот надо дать сейчас напишу определение
граф же
называется связанным связанным если между любыми двумя вершинами любыми двумя
вершинами есть есть путь их соединяющие
вот ну то есть связанный граф это граф в котором между любыми двумя вершинами если они даже если
они не бы если они соединили бром то это есть путь а если они не соединили бром то можно построить
путь который соединяет поняли не связанный граф собственно распадается так называемые компоненты
связанности пример не связанного графа вот такого например вот что-нибудь такое вот вот
между вот этими компонентами связанности между вершинами этих компонент связанности пути нет
вот в данном случае связанный граф написан поэтому ребра там точно есть потому что гроба
1 раз уж что и одна вершинка подходит там ребер нету так где вот тут так ok это первая
часть вторая часть второе утверждение эквивалентный связанный граф в котором же связанный граф
в котором при удалении любого ребра который который при удалении любого ребра при удалении
любого ребра любого ребра становится не становится не терять связанности
это второго определение дерева третье определение дерева значит граф без циклов
в котором при добавлении любого ребра появляется цикл же граф без простых циклов
в котором при добавлении любого ребра
появляется простой цикл
так четвертая связанный граф же связанный граф
в котором количество вершин количество ребер равно количество вершин минус один вот так вот
без затей вот тут то есть наставил на самом деле красота в чем с чем с чем и элегантность
подтверждение в том что на самом деле все это по порогу все все это все все тиши штук и
эквивалентно между собой вот 5 ж граф в котором между любыми двумя вершинами
двумя вершинами есть простой путь есть единственный простой путь вот так
ну и шестое граф без циклов же граф без циклов
в котором число вершин число ребер равно число вершин минус один вот 6 штук нет вот здесь
здесь граф без циклов это разные вещи вот на самом деле крат видите в чем дело то есть можно одно из
двух тут связанный граф без циклов дерево базовое определение это связанный граф без циклов да
без простых циклов но вот тут на самом деле видите если у вас есть такое условие что мы знаем
количество вер количество ребер то можно только одну из них оставить а второй будет следовать
вот ну давайте доказывать ну я и так так так так мы 12 20 до 10 10 12 10 смотреть но вообще это по
идее дать аремов всю лекцию потому что тут эквивалентности много переходов много не все
не простые но сначала из 1 1 2 же связанный граф без простых циклов вот мы знаем же связанный
граф без простых циклов нужно доказать что же связанный граф в котором при удалении любого
ребра терять связанность но связанная связанность у нас так уже дана она известна а нужно доказать
что если нет простых циклов то при удалении любого любого ребра мы потеряем связанность смотрите
ну если уже при удалении ребра е
которая ув связанность не потерялась не потерялась
то смотрите что это значит это значит что между ув в частности вот было ребро я его удалили
связанность не потерялась при этом значит между ув есть еще один какой-то простой
если какой-то путь который соединяет так теперь возвращаем ув мы получаем цикл поняли
ув ув соединены путем соединены уже путем возвращая и возвращая и мы получаем
цикл вместе с этим путем получаем цикл получим цикл
вот
ну давайте 1 в 2 в 2 из 2 в 3
2
в 3 но смотрите мы знаем что же связанный граф в котором при удалении любого ребра пропадает
связанность же связанный граф в котором при удалении любого ребра
пропадает связанность тогда нужно доказать что же граф без простых циклов в котором при
добавлении любого ребра появляется простой цикл ну да правильно правильно то есть вот что нам
дано при удалении любого ребра пропадает связанность да я теперь пусть пусть сначала
нужно доказать что граф не имеет простых циклов докажем сначала что же не имеет простых циклов
что же тут два утверждения получается потому что ни одного из этих утверждений в трех нет ну
в предпосылке не присутствует докажем что же не содержит простых циклов
ну смотрите если если не так если не так то смотрите вот возьмем это самый простой цикл
заметьте что при удалении любого ребра простого цикла связанность не теряется потому что у нас
есть альтернативный маршрут между теми вершинами которые были связаны ребром раньше так то есть
что мы потеряли мы мы мы потеряли у нас если есть если пути соединяли через вот это ребро то
мы можем обойти по циклу это ребро правильно если между самими этими вершинами просто тоже опять
же в другую сторону по циклу обойти то есть если не так и уже есть простой цикл то при удалении
любого ребра простого цикла связанность не теряется любого ребра простого цикла
не теряется противоречие с предпосылкой который говорит что при удалении любого
ребра связанность как раз теряется вот то есть циклов простых тут нету значит граф ациклический
в котором при добавлении любую давайте докажем что при добавлении любого ребра цикл как раз
явится ну скажем смотрите пусть вершина ув в нашем графеже ребром не были соединены а мы это
ребро туда добавили но смотрите а почему цикл появится до граф был связан значит
ув были соединены ребром до ой и цепь путем путем ув были соединены ребром добавили еще
одно ребро появился цикл все так как же связан то между ув между ув есть путь
тогда добавление добавление ребра ув создаст цикл создаст цикл
все
давайте следующий переход это простые переходы были теперь давайте переход из 3 стройчик в
пятерочку сделаем то есть граф без простых циклов в котором при добавлении более любого
ребра простой цикл мы это знаем докажем что это что граф в котором между любыми двумя вершинами
есть и доказом что граф и же граф который между двумя вершинами есть простой путь есть единственный
простой путь вот смотрите наверное вот это стереть придется
3 следует 5 5 5 ну немножко не подряд наверное нужно их было переставить чтобы так красиво что
было но почему-то я я просто короче проворонил этот момент ну по идее их нужно перестать так
чтобы совсем красиво было шел вот прям подряд шли но удобнее доказывать не подряд в данный если
их так расположить в таком порядке вот что за что достаточно
ну да он но да этот деревья это сайт в некотором смысле это минимум в прямом смысле это самый
минимальный связный граф понимаете минимальный даже по количеству ребер вот меньше ребер
связанном графе быть не может поэтому собственно он такой преудаление он сразу перестает быть
связанного что-то как минимум количество ребер уменьшается вот при добавлении появляется цикл но
это очень хороший очень интересный граф когда вы знаете что будет если вы дерево добавить ребро
появится граф который называется унициклическим графом это граф в котором единственный простой цикл вот
можно в принципе про него тоже очень интересная наука там кое кое что тоже можно доказать но у нас
я не помню хватало ли времени это рассказ мне все когда-нибудь когда-либо сейчас посмотрим посмотрю
можно любой использовать это же они же квалентны можно всем можно всем конечно да мне кажется этих
этих у достаточно вот они в основном-то используется но вот иногда люди проверяют что же граф связи на
количество ребер например нужное этого достаточно чтобы сказать что граф дерева вот потому что вот
вот нас есть такая теорема то есть в целом то в таку в том или ином виде это наиболее часто
используемое определение дерево это частый объект он везде появляется вот и вот но это наиболее
часто используемые часто используемые способы проверки на то что граф дерева вот так вот 6
различных тестов так сказать на дерево вот значит на третьей же граф без простых циклов
без простых циклов
в которых в котором
при добавлении любого ребра
появится цикл
появляется смотрим что нужно доказать что граф же граф который между любыми двумя вершинами есть
единственный путь проходящие но единственный путь проще ну смотрите это же просто смотрите
вот есть вершина у пускай вершина в и пускай между вершинами между вершинами у и в два различных
простых путей что у нас получится но не совсем простой там не какие-то ребра придется убрать то
есть в принципе да они могут совпадать на некоторых участках но в целом цикл там пополучится
потому что разные ребра там есть он просто понятие не с такой как может быть цикл нет
не соединяющий у его непосредственно а посередине что-нибудь вот такое получится вот но цикл там
расхождения будет и цикл из них создастся поймите понимаете да вот если между
у и в есть два простых путей два различных простых путей
то уже есть простой цикл
ну собственно три валечия
вот этой части вот эти переходы простые теперь
нет вот тут ну если то что он существует
что существует давайте так ну давайте если да вспомнил действительно правда право-право если
же не связан не связан то добавление ребра между компонентами связанности не создаст не
создаст цикла понимаете ну возьмите любые две компоненты связан соедините любые две вершины
между разными компонентами связанности цикл не появится так то добавление ребра
между любыми двумя вершинами между любыми двумя вершинами из разных компонент связанности
из разных компонент связанности цикла не создаст
тоже противоречия
которая показывает вот здесь что гроза стоит путь а тот что он единственный вот так
следующий переход из пятерочки давайте так из 1 в 2 2 в 3 3 в 5 из пятерочки надо на
садили в любую из этих двух можно но давайте в четверочку перейдем тут уже вот это сложный
переход давайте его докажем так значит то есть у нас мы знаем что в g это граф который между
любыми двумя вершинами есть единственный путь простой путь нужно доказать что граф ну граф связан
это понятно да уже уже повторяем повторим просто предыдущая в котором она вот про
количество ребер утверждение давайте докажем сейчас смотрите пусть же а стоп а зачем связанность
доказывать между любыми двумя есть путь все чего там доказывать да уже граф в котором
между любыми двумя вершинами есть простой путь
единственный простой вот как связанность понятно тогда потому что просто есть путь
между любыми двумя как доказать что количество вершин количество реберов на количество вершин
не сойдет давайте индукция обозначим обозначим количество вершин буковка и давайте докажем
утверждение индукция пэн индукция пэн
смотрите база выглядит следующим образом сейчас давайте я на следующей доске уже напишу
да но там придет ну давайте проверим сейчас напишу я так для подстраховки базу проверял
2 1 2 вершины деревья база значит n равно единицы тогда у нас граф так называемая ну не знаю не
официальный термин райгородский называют это семечком ну одна вершинка семечка это дерево вот
а значит количество ребер равно 0 количество вершин равно единицы поэтому количество
ребер равно качество вершин минус 1 равно 2 связанный граф который между любыми двумя вершинами
есть единственный простой путь в данном случае с двух вершин вот только такой да поэтому в нем
одно ребро 2 вершины а ну наверное так для потра подстраховки все-таки делаем скорее
просто продемонстрировать так скорее сюда да не надо переход но это тоже простое
смотрите пусть утверждение доказано пусть что мы доказываем что количество ребер пусть утверждать
пусть для любых же удовлетворяющих 5 и хочу переписывать это эту формулировку что между
любыми двумя вершинами есть единственный простой путь давайте напишем удовлетворяющих 5 доказано
с количеством вершин равным n доказано что количество ребер в них всегда равно
количество вершин минус 1 докажем рассмотрим любой граф удовлетворяющих 5 рассмотрим любой
граф же удовлетворяющий 5 в котором количество вершин равно n плюс 1 значит смотрите что это что
я тогда хочу доказать я хочу доказать что любого что у такого граф тогда обязательно найдется то
что называется лист что такой лист до вершины степени 1 листом называется вершина степени а
вершина степени 2 называется проходной вершины стандартной терминологии вот нет узлы это это не
что больше так ну давайте это не что другое значит смотрите узлы значит смотрите узбился сбили
давайте докажем что уже есть докажем что уже есть вершина степени 1
давайте мы предположим что все вершины степени 2 или больше пусть
уже не вершин больше ли бы рано чем два тогда вот что мы с вами сможем сделать
стартуем из любой вершины у нее степень хотя бы 2 поэтому мы можем из нее прийти
какой-то следующую вершину до по ребро у нее степень 2 поэтому мы можем из нее уйти в
какой-то следующий вершины причем не совпадающий с предыдущими правильно так у нее тоже степень 2
единственный вопрос почему мы можем дальше уйти так чтобы вершины не повторялись у нас
появится простой цикл и два простых пути между между некоторыми двумя вершинами у нас же вот
есть только вот это утверждение что уже есть а что в жем между любыми двумя вершинами единственный
простой путь смотрите если мы мы можем уйти но есть такой нюанс нюанс заключается в том что мы
возможно сможем уйти скажем в у но если мы сможем в уйти то между у и у 2 есть два простых пути
противоречия с условием правильно значит мы сможем уйти ту вершину в которой еще не было
правильно из у 3 мы тоже сможем и она степень у нее степень хотя бы 2 значит сможем уйти и
опять же из ту же вершину в другую вершину которая еще не было потому что иначе опять у нас
получается два простых пути между некоторыми вершины так ребят эта процедура можно продолжать
бесконечно что невозможно потому что граф конечна но это значит что мы повторимся мы в каком-то
в какой-то момент обязаны будем вернуться в ту вершину в которые уже прошли а это значит что
у нас не дерево поняли в речи них не буду это записывать давайте просто вот так я словами
некоторые тут длинное просто рассуждение вот то мы сможем построить бесконечно простой цепь
противоречия
ну значит в деле в таком графе есть степершина степень который называть будем удаляем этот
лист значит есть вершина степени 1 есть вершина степени вершина у степени 1
в степени 1 смотреть удаляем этот лист тогда количество вершины количество ребер уменьшится
на единичку и полученному графу мы можем уже предположение индукции применить который говорит
что количество ребер в нем в графе в котором удален лист количество ребер равно вершин минус
один потом добавляем обратно этот самый лист и это раньше сохранится поняли но на самом деле
если не формально рассуждать то по сути вот именно так это и доказывается здесь произвольном
как бы дерево строится из листов каждый раз к вот этому вот ребру добавляется лист потом еще
раз лист еще раз лист еще раз лист и каждый раз вот это раз сохраняется поняли но это вот вот
это слишком неформально не то чтобы на экзамен я приветствовал такое рассуждение понимаете
в чем проблема с таким рассуждением почему она не индукция ребят иногда просто студенты пытаются
строить до вот как что такое индукция вот пускай для н доказано рассмотрим любую конфигурации
н плюс 1 используя предположение индукции докажем для нее это индукция а вот если мы берете предыдущие
достраивайте это предыдущие до следующего да это достройка не индукция или не полная индукция
потому что вы по идее если вы такую достройку делаете должны доказать что при помощи достройки
вы получите все конфигурации следующего уровня понимаете для следующего значения параметра без
этого это не работает мы просто студентов по одному курсу дрессировали заставляя решать задачи
что-то и на индукцию вот чтобы чтобы студенты не путали достройку или не полную индукцию с
настоящай индукции настоящей индукция предполагает рассмотрены любой конфигурация размер а versus 1 и
сведение эта конфигурация к размеруを но не наоборот если вы рассматриваете любую конфигурация
размера нэ достраивайте ее до конфигурации размеров плюс один это вот тогда еще надо доказывать
что вы там всю, во все раз все конфигурации размера n плюс 1 получите еще в добавок.
Вот. А что еще раз? Узел это сейчас. Я не помню в какой теории это появляется,
это терминология, но это просто вот в том, в той части науки, которую мы будем изучать,
там термин такой не используется. Это вот какая-то прикладной термин, что ли. В той литературе,
которую я читал по графам, нет термина узел вообще. Я помню, он появлялся вот в той самой книжке,
упомянутой Еблонского, где изучалась информатика, часто и чаще информатические приложения в
информатике. Там любят именно такие термины, но информатики это используют как синоним вершины,
по идее. Просто им вот нравится такое слово, я не знаю. Если так разобраться, вот книжка Еблонского,
который вы выложил, можете посмотреть там дальше, что он там пишет, о чем он там пишет. Он пишет про
теоретическую информатику, то, что называется сейчас в западном мире компьютерсайенс. Не знаю,
как нормально перевести сей термин, поэтому чаще всего говорят просто англоязычный термин. Наука
о компьютерах я не знаю, хотя там чаще всего объект, главное изучение от алгоритмы. И там вот
эта вот терминология как раз и развивается. Им приятнее почему-то так называть.
Так, ну хорошо, давайте, как я здесь запишу. Удаляя вершину В из графа G
и применяя к полученному графу предположение индукции,
полученному графу предположение индукции,
получаем, что количество ребер Е штрих равно количество ребер вершин В штрих,
но это граф, который получился после удаления. Уже штрих это Е штрих В штрих граф, получившийся
после удаления листа.
Возвращаем лист, возвращаем В.
Получим, получим. Количество ребер равно количество вершин минус один. Переход доказан.
Поняли, да? Ребят, хорошо. Так, сейчас посмотрю. Мы доказывали переход из 5 в 4. Теперь из 4 в 6. Я напомню,
что там я раз мы стерли все эти формулировки. То есть у нас дано G связанный граф, в котором
количество ребер равно количество вершин минус один, а это четверочка, а шестерочка G это
ациклический граф, граф без простых циклов, в котором количество ребер равно количество вершин
минус один. Ну то есть про количество ребер мы доказывать не можем, не нужно нам ничего доказывать,
правильно? Оно повторяется, но нужно вывести, что и связанности, и вот этого утверждения следует,
что нет простых циклов. Как это сделать? Ну можно так в принципе, но вообще давайте более формально
и опять по индукции. Давайте докажем. Индукция PN, пусть N это количество вершин, индукция PN
опять база. То есть в чем утверждение, какое утверждение мы по индукции доказываем? То,
что в любом графе, который связан, в котором количество ребер равно количество вершин минус
один, нет простых циклов. Смотрите, ну если N равно один, то у нас количество ребер равно
количество вершин минус один, да и только один граф вот такой, да, он связан. Вот N, ой, простите,
господи, связан, без простых циклов. Вот N равно два графа, в котором количество вершин,
количество ребер равно количество вершин минус один и связан, он один, он вот такой, тоже без
простых циклов. Итак, на самом деле чисто для подстраховки, на самом деле лишь это не нужно.
Давайте для N равно трём проверим. Какой граф, связанный, в котором количество ребер равно
количество вершин минус один? Количество вершин три, ребер соответственно два. Связанный граф,
в котором два ребра. Какой граф? Цепочка. Он тоже без простых циклов. Он единственный такой, да.
Давайте переход доказывать.
Пусть для любого графа,
для любого связанного графа,
с которым количество ребер равно количество вершин минус один, доказывает и такого,
что количество вершин равное, значит доказано, что он не содержит простых циклов.
Давайте смотреть. Рассмотрим любой связанный граф.
Ж такое, что количество вершин равно N плюс один, а количество ребер равно N.
Давайте докажем, что в нём нет простых циклов. Что нужно сделать? Нужно сделать,
доказать, что в таком графе с такими параметрами обязательно есть лист. Как это доказать?
Вот здесь мы в рассуждении использовали некоторые другие данные. У нас данные,
предпосылка другая была. Это рассуждение, к сожалению, здесь не работает. Нам дано только,
лишь он связан, что количество вершин известны, количество ребер известны. Как доказать,
что тут есть лист? Если для любой вершины В из В большой, степень её больше либо равна двух,
то смотрите, сумма степеней вершин больше либо равна чем два N плюс один, правильно?
Но по теореме рукопожатия это удвоенное количество ребер. То есть степень вершин
должна быть равна двоим. Сумма степеней вершин должна быть равна двоим по теореме рукопожатия.
Ну, противоречие. Значит, тогда существует В такой, что степень В равна единице. Ну,
тогда мы её удаляем. Удаляем В. Ну, естественно, вместе с ребром, который из неё исходит. Тогда
в получившемся графе же штрих, который во штрихе штрих, количество вершин равна N,
а количество ребер равна N минус один. По предположению индукции там нет простых циклов.
Так, ребят, возвращаем лист, но простой цикл не появляется. Поняли? По предположению индукции.
Уже штрих. Нет простых циклов. Добавление листа не создаёт простых циклов. Не добавит
простых циклов. Ну что ж,
смотрите. У нас 6 утверждений было. Какие мы переходы с вами обосновали? 1, 2, 2, 3, 3, 5, 5,
4, 4, 6. Остался переход 6, 1, чтобы почку замкнули. 6, 1. Давайте замкнём. Что нам нужно? Что из чего и
что нужно вывести? Да. Значит, g без простых циклов. 6, g без простых циклов и с количеством
ребер равным количеству вершин минус один. Один это g без простых циклов связанный. Да,
нужно обосновать. Можно показать, что из вот этих посылок, что число без простых циклов и
количества ребер это количество вершин минус один. В нём нет простых циклов, что нужно обосновать,
что из этого следует что же связь. Ну давайте. Как доказать, ребята? Как в прошлый раз. Тут по
сути повторение, только с небольшой модификацией. Ещё раз. Не выполняется,
что количество ребер. Но это в принципе можно, кстати. Только там счёт какой-то нужен всё-таки.
Количество считать количество ребер в лесу, так называемый, граф, просто граф без связанности,
называется лесом. Количество ребер в лесе можно посчитать. Оно зависит от количества компонент
связанности. В принципе тут легко доказывается также. То есть индукция по количеству вершин,
база n равно единиц непосредственно проверяем, что у нас тут вот такие графы. Пожалуйста,
они все связаны. Переход. Вот у нас эти данные имеются. И мы знаем, что количество ребер равно
количество вершин минус один. Значит есть вершина степени один. Мы просто повторяем рассуждение
вот здесь. Вот здесь вот это рассуждение. Что лист есть. Удаляем лист. Из предположений индукции
следует, что без листа получившийся граф связан. Добавляем лист, он остаётся связанным. Всё.
Поняли, ребята? Ух ты. Ну вот. Видите? Шесть вот этих определений. Они все эквивалентные. Вот такая
теория. Теперь давайте считать деревья. То, что я сегодня успею рассказать, это формулировки по
сути. Доказательства все будут уже на следующей неделе. Это тоже я всё обосную. Это вот эта штука,
которая в литературе почти не доказывается. И поэтому мне просто как челлендж захотелось
это взять и доказать. Потому что, ну что это такое? Это безобразие. И вторую вещь,
которую я сейчас буду рассказывать про кодирование приухера и про подсчет количества
деревьев. Это тоже вещи, которые формулируются, не доказываются. А там, ну вот здесь, сейчас,
когда второй раз это рассказываю, это все переходы, доказательства, мне это не кажется
уже сложным. А в той там теориям такие довольно существенные, нужно сказать, по сложности. Вот.
И догадаться до них довольно трудно. Ну что ж, подсчет деревьев. Количество деревьев.
Смотрите. В данном случае лучше нужно определиться с терминологией. Смотрите.
Фух. Есть термин помеченное дерево. Я вообще лучше, наверное, его сейчас не использовать. Потому
что на самом деле помеченное дерево. Что такое помеченное дерево? Это, грубо говоря, если не
формально, то это дерево, в котором вершины помечены цифрами. Ну так. Цифрами. Цифрами.
Помечены цифрами. Причем, смотрите, деревья считаются различными, если они различны. Ну,
смотрите. Формально это что такое? Это граф, в котором множество вершин. Это 1, 2, 3, 4. Так.
А множество ребер. В данном случае это пара 1, 2, 2, 3, 2, 4. Да. А вот у такого дерева,
например, список ребер тот же самый, список вершин тот же самый. Значит, они как теоретика,
как просто множественный объект. Они совпадают. То есть это одинаковый граф. Да, ребят? То есть
вот это дерево такое же, как такое. То есть они совпадают просто как графы. А вот такое дерево
уже не совпадает с вот этим. Оно как граф различается. Правильно? Ну вот. При этом эти деревья
изоморфны, если вы можете понять. Правильно, ребят? Изоморфизм, например, вот такой. Вот такой
изоморфизм. Переводят одно дерево в другое. Это разные деревья, но они изоморфны. Вот.
Кодирую. Вот то, что я сейчас вам напишу. Давайте. Это так называемая формула Келли. Теория Маккелли.
Вот. Она считает количество деревьев. Количество деревьев без учёта изоморфизма. То есть изоморфные,
но различные деревья считаются разными. Понимаете, да? Почему я так обращаю ваше внимание на это?
Потому что есть разные способы подсчёта количества деревьев. И вот другие методы подсчёта.
Дают совершенно другие цифры, но они считают на самом деле количество деревьев с учётом того,
что изоморфные деревья считаются одинаковыми. То есть склеивается все изоморфные деревья в один
класс эквалентности и считается количество получившихся классов эквалентности. Неформально
делается что? Стираются вот эти пометки, получаются просто дерево, и вот количество различных вот
таких деревьев считается. Это сложнее, на порядок сложнее, чем посчитать с учётом пометок. Понимаете,
да? Ну давайте. С учётом пометок подсчёт есть, всё это считается. Получается прям конкретная формула
для количества графов с учётом изоморфизмов. То есть когда графы изоморфные считаются одинаковыми,
нет точного ответа. Там есть асимпточки, там есть оценки верхние и нижние, но прям
замкнутой красивой формулы нету. Вот так. Чарема Келли.
Так, число деревьев, число попарно различных деревьев
на множестве вершин. 1, 2 и так далее. Просто видите, обращаю внимание, попарно различных,
а во-вторых, в других формулировках, может быть, мы почитаем, оценим количество деревьев с учётом
изоморфизма. То есть когда мы считаем изоморфные деревья одинаковыми, там будут несколько другие
цифры. Не столько деревьев будет равно. Н в степени минус 2. Вот. Ладно, специально прям здесь подпишу.
Изоморфные деревья считаются разными.
Вот. Как доказывается чарема Келли. 10 минут, да? Или сколько у нас осталось? Для этого нужно
описать кодирование прюфера. Кодирование заключается вот в чем. Пускай у нас есть
дерево, в котором на вершинах из множества 1 и так далее. В этом дереве, как мы доказали раньше,
имеется лист. Просто я сейчас пример какой-нибудь на вам приведу, потом опишу алгоритм.
Смотрите. На каждом шаге отрезается лист с наименьшим номером. Давайте ищем лист с наименьшим
номером. Здесь 6. И пишется вершина. Пятёрка, прости, пятёрка. Спасибо. И пишется вершина,
с которой лист был соединён. На следующем шаге делается то же самое. То есть в новом дереве
опять отрезается лист с наименьшим номером и пишется вершина, с которой лист был соединён.
Так значит здесь дальше четвёрка. Дальше тройка срезается. Получается двойка. Так пишется двойка.
Следующее 7. Пишем 1. 8. Пишем 1. 1 срезаем, пишем 2. Последнее ребро осталось. С ним ничего не
делаем. Просто не пишем никуда это ребро. Получается дерево на N вершинах записывается
к длине N-2. Правильно, ребята? Алгоритм понятен? То есть каждый шаг кромсаем листы с наименьшим
номером. Записываем вершину, с которой лист был соединён. С новым деревом,
которое осталось. Продолжаем то же самое. До тех пор, пока не останется одно ребро,
его никуда не пишем. Вот. Декодирование. Как вы думаете, как работает декодирование?
То есть вот у нас есть код, как по коду восстановить дерево.
Сейчас я опишу этот алгоритм. Придется видимо повторять на следующей лекции,
потому что я хочу доказать свойства этого кодирования, которые нам нужны. Смотрите,
ребята. Предположим, что мы доказали следующее утверждение. Например, что каждому коду
соответствует единственное дерево. То есть нет двух деревьев с одинаковым кодом. Предположим,
мы доказали, что каждый код восстанавливает по многому декодирование. Сейчас я опишу,
что процедура декодирования создаст, кажется, именно дерево. Процедура декодирования работает
следующим образом. Давайте нужно всё-таки описать, а потом рассказать набор утверждений,
которые мы должны доказать, чтобы всё работало. Смотрите, пускай наш код 3 4 3 2 1 1 2. Внизу приписываем
цифры подряд идущие 1 2 3 4 5 6 7 8 9 на две больше. Теперь алгоритм работает следующим образом. Ищем
внизу числа, чиселок здесь на две больше, чем тут. Значит, очевидно есть чиселки, которые не
встречаются вверху. Ищем наименьшее по номеру число, которое отсутствует вверху. Смотрите,
какое здесь наименьшее по номеру, которое отсутствует 5. И вот так вычёркиваем 5, вычёркиваем 3. Записываем
ребро 5 3 и продолжаем для нового набора то же самое. Ищем число, которое есть внизу, но отсутствует
вверху. Вот 6. Записываем ребро 6 4. Вычёркиваем дальше. Ищем так 1 2 3 здесь 4, да, если не ошибаюсь.
4 3. Теперь 3 2. 7 1. 8 1.
7 1 вроде всё. Ну, давайте 3 2.
Теперь 1 2 есть. Значит, минимальное, которое отсутствует, это 7. 7 1 вроде всё правильно. Потом
опять 1 2 всё ещё есть. Их использовать нельзя. 8 1. А теперь минимальное, которое отсутствует, это единица.
И осталось последние две цифры. Это последнее ребро, которое мы никуда не вписали. Его отдельно
выписываем. Эта процедура декодирована. То есть кодирование. Каждое из дерева каждый раз ищем
лист с наименьшим номером. Удаляем. Продолжаем до тех пор, пока не останется на ребро, которое
никуда не пишется. Декодирование. Записываем код внизу. Записываем подряд идущие числа в
количестве n минус 2. n плюс 2 штук, где n длина кода. И на каждом шаге ищем наименьшее число внизу,
которое отсутствует вверху. Соединяем в ребро эти найденные числа. Удаляем их и продолжаем до тех
пор, пока не останется два последних числа внизу. Их отдельное ребро пишем. А потом можем нарисовать
дерево, когда все ребра выписаны. Что нужно доказать про эти две процедуры? Что нет двух деревьев с
одинаковым кодом. Что любой код декодируется именно в дерево. Вообще-то не очевидно. Смотрите,
вот код, вот какой-то описанный алгоритм. Почему он построит дерево? Вдруг он чуть
не связанный построит? Это же последовательность ребра какая-то. Что любой код декодируется
именно в дерево. И что не бывает два кода, которые кодируют одно и то же дерево. Тогда у нас
получится биекция между набором кодов и набором множества деревьев и множества кодов. Коды
считаются легко. Их n как раз n в степени n-2, потому что длина кода n-2. А на каждой позиции
здесь может стоять любое отсесло от 1 до n. То есть если мы вот эти три утверждения докажем,
а декодирование именно декодирует дерево, что нет двух деревьев с одинаковым кодом и что нет
двух кодов с одинаковым деревом, то мы докажем однозначность кодирования декодирования и
корректность его. Ну и соответственно докажем, что это биекция. Поняли? Ну всё.
