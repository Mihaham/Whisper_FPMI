Так, всем доброго времени суток. Это запись пропущенной последней лекции курса по алгоритмам,
ну и, соответственно, курса по C++, на которых, собственно, мы подведем небольшой итог,
потому что мы изучили в течение семестра, ну и, соответственно, закончим те темы,
которые начинали в прошлые разы. Ну и начнем, собственно, мы с алгоритмов. Напомню,
что мы в прошлый раз начали заниматься такой темой, как потоки. Грубо говоря,
у нас есть некоторая транспортная сеть. Есть некоторая транспортная сеть,
ну или там граф, у которого на каждом ребре написана некоторая пропускная способность,
есть, соответственно, две выделенные вершины. Одна называется источником,
другая называется стоком. Соответственно, из источника продуцируется какое-то количество
жижи, которая, собственно, должна в итоге целиком прибыть в сток. Задача заключается в том,
чтобы назначить такое количество жижи, которая протекает по ребрам, соединяющим вершины,
так чтобы, во-первых, у нас не было такого, что количество потока, которое протекает по ребру,
превосходило пропускной способности ребра. У нас, собственно, второй условие заключается в том,
что у нас в форме жижечных вершин поток не накапливается. Сколько потока пришло в эту вершину,
столько из него и вышло. Ну и также мы с вами ввели такое понятие, как симметризованный поток.
То есть, по сути, ввели ту же самую функцию, те же самые ограничения, только сказали,
что у нас поток обладает свойством ате симметричности. То есть, мы говорим,
что если в одну сторону протекает х-поток, то в обратную сторону протекает минус х-потока.
Но в остальном всё, в принципе, то же самое. Мы также требуем, чтобы поток не превосходил
пропускной способности данного ребра. При этом мы ещё считаем, что если между вершинами ребра нет,
соответственно, пропускная способность данного ребра, отсутствующего, равна нулю.
Соответственно, потока ни в коей вершине накапливается. Мы с вами рассмотрели алгоритм Форда Фалкерсона,
который основан на теории Форда Фалкерсона, которая говорит о том, что мы можем брать симметризованный,
можем брать обычную транспортную сеть, симметризовать поток и, соответственно,
добавлять поток по ручьям. То есть, просто добавляем какое-то количество единиц потока.
И так делаем до тех пор, пока мы можем его добавить. Как только мы ничего не можем добавить,
как только мы не можем найти пути из источника в сток, который бы проходил по рёбрам с положительной пропускной способностью,
мы говорим, что в этот момент мы нашли оптимальный поток.
Теория Мэйфорда Фалкерса как раз подтверждает, что, действительно, если у нас такая ситуация возникла, то поток оптимален.
Ну и, соответственно, из этой теории легко выводится простейший алгоритм.
Мы просто-напросто инсталлюзируем поток нулём.
Дальше пускаем какой-то поток из источника в сток, например, с помощью алгоритма DFS.
И, соответственно, обновляем поток вдоль этого пути.
Ну и продолжаем до тех пор, пока, соответственно, мы находим такие пути.
Дальше мы с вами рассмотрели алгоритм Эдмонт Скарпа, который, по сути, является модификацией алгоритма Форда Фалкерса.
Ну и, соответственно, мы в прошлый раз показали, что это, на самом деле, приводит к тому, что алгоритм становится, ну, скажем так, время работы алгоритма перестаёт зависеть от итогового ответа, да, и обладает, соответственно, полиномиальной сложностью, а именно VE квадрат.
Вот это то, что было в прошлый раз.
Ну и сегодня давайте рассмотрим ещё парочку алгоритмов.
Ну, один алгоритм, ну да, смотри.
Так, ну вот, соответственно, у нас есть алгоритм Эдмонт Скарпа.
И что мы делаем, да, то есть, вообще говоря, алгоритм Эдмонт Скарпа итеративный, он на каждой итерации, он на каждой итерации, он на каждой итерации, он на каждой итерации, он на каждой итерации, он на каждой итерации, он на каждой итерации, он на каждой итерации, он на каждой итерации, он на каждой итерации, он на каждой итерации, он на каждой итерации, он на каждой итерации, он на каждой итерации, он на каждой итерации, он на каждой итерации, он на каждой итерации.
Так, ну вот, соответственно, у нас есть алгоритм Эдмонт Скарпа, и что мы делаем, да, то есть, вообще говоря, алгоритм Эдмонт Скарпа итеративный, он на каждой итерации запускает БФС, и с помощью БФС мы находим, соответственно, кратчайший путь, кратчайший путь из источника в сток, ну, грубо говоря, да, вот у нас есть источник, есть сток, мы, соответственно, находим кратчайший реберный путь, реберный путь до вершины Т.
Вот, соответственно, после того, как мы нашли этот реберный путь, мы вдоль не опустили поток, дальше снова ищем кратчайший путь, и так далее и е.
В чем заключается неэффективность алгоритма Эдмонт Скарпа, на чем мы бы могли сильно сэкономить.
Ну, смотрите, на самом деле кажется, что запускать кучу раз БФС особо не имеет смысла. Почему?
Потому что ведь алгоритм, на самом деле, алгоритм БФС, он находит не единственный кратчайший путь.
То есть представь себе, что у меня есть несколько, несколько реберных путей длины 4, ну, например, вот так, или вообще есть какой-то вот отдельный путь, который не пересекается сходным, или есть какой-то вот такой путь, и так далее и е.
Ну, короче говоря, алгоритм БФС, он на самом деле строит такие вот множества, да, то есть, словно строит такие слои, то есть, слои вершин, до которых расстояние 1, слои вершин, до которых расстояние 2, слои вершин, до которых расстояние 3.
Ну и соответственно, вот есть слои вершин, до которых расстояние, реберные расстояния 4. Вот.
И что мы на самом деле делаем, да, что нам на самом деле предлагает алгоритм AdamScarpe?
Алгоритм AdamScarpe предлагает нам следующее. Давайте возьмем какой-нибудь путь, ну, например, вот, вот этот.
И вдоль него пустим поток. Ну а дальше, соответственно, вот мы пустим поню понок, а дальше, соответственно, заново построим, заново запустим алгоритм БФС, заново идем в какой-то кратчайший путь, и соответственно, пустим по нему поток.
И возникает, естественно, вопрос, а зачем? Зачем мы кучу раз выполняем алгоритм БФС, если, в принципе, если, в принципе, мы сразу, ну, если мы сразу по одному запуску БФС можем найти сразу несколько кратчайших путей из СТ?
Ну, допустим, вот я по красному пути пустил поток. Да, этот поток мне насытил вот это ребро. То есть вот это ребро стало насыщенным, ну, в том смысле, что его пропускная способность сравнялась с, точнее, его поток, да, поток, который проходит по этому ребру, сравнялся с его пропускной способностью.
Но при этом мы видим, что в нашем, ну, собственно, в нашем, ну, в нашем, так скажем, графе, да, который построил БФС, в нем еще много кратчайших путей, да, которые мы тоже нашли на самом деле.
Например, вот это вот верхний путь. Вот такой путь. Мы его тоже нашли. Потом вот такой путь. Он тоже был найден нашим алгоритмом. И вот такой путь.
То есть на самом деле БФС находит не один кратчайший путь, да, как мы привыкли, а на самом деле можно считать, что БФС находит сразу же все пути, все кратчайшие реберные пути, которые приведут меня из СТ.
То есть что мне достаточно сделать? Мне достаточно взять вершину С и найти какое-то ребро, которое ведет в вершину с расстоянием 1.
Дальше взять вот эту самую вершину с расстоянием 1, найти какую-то вершину, которая ведет ребро с расстоянием 2 и так далее.
И для этого мне не приходится, соответственно, перестраивать, то есть постоянно вызывать заново алгоритм БФС.
То есть на самом деле я могу какие-то запуски БФС переиспользовать несколько раз.
И вот как только я переиспользую, грубо говоря, забью все допустимые пути, только в этот момент я могу сказать, ага, ну вот все, все пути размера 4 я уже рассмотрел.
Их больше у меня в графе не осталось, поэтому я могу заново запустить БФС и найти какой-нибудь новый кратчайший реберный путь, который будет иметь длину 5.
В общем, идея вот такая. Зачем мне несколько раз вызывать алгоритм БФС, если можно запустить один раз и сразу же в нем найти все возможные пути данного размера?
Ну, соответственно, все, вся идея изображена здесь.
И действительно, мы можем сказать о том, что алгоритм БФС строит так называемую слоистую сеть.
Что такое слоистая сеть? Слоистая сеть – это, грубо говоря, граф, у которого все вершины разделены по слоям.
То есть условно есть... у нас есть слой, расстояние до которого один из источника.
И слой, расстояние до которого из источника равно 2, и расстояние... соответственно, вершины, расстояние до которых источник, равно 3.
Соответственно, строит слоистая сеть и плюс я отдельно выделяю рёбра, которые ведут из одного слоя в другой, то есть из первого слоя во второй, из второго в третий и так далее.
Вот, соответственно, алгоритм BFS, грубо говоря, строит мне вот такую слоистую сеть.
То есть он, во-первых, находит рёбра, которые ведут из...
Во-первых, он разделяет вершины по слоям, там на первом, втором, третьем и так далее.
И, во-вторых, находят все ребра, которые ведут из одного слоя во второй.
И, соответственно, с помощью алгоритма BFS я построил слоистую сеть. А что дальше?
Ну а дальше я могу работать с этой слоистой сетью.
То есть теперь я могу с этой слоистой сетью,
то есть я теперь могу не постоянно вызывать алгоритм BFS,
а найти какой-то путь в этой слоистой сети.
Надо найти вот такой путь сначала.
Потом я нашел какой-то вот такой путь.
Ну и так далее, пока вот в этой слоистой сети я смогу найти путь из СТ,
пока я не забью все ребра до конца.
То есть кажется, это довольно-таки разумно, довольно-таки логично.
Давайте, собственно, посмотрим, как, за сколько это может...
Да, и при этом заметьте, что, опять же, я не обращаю внимания,
скажем, я не провожу дополнительный анализ того,
корректно ли работает алгоритм Динница и так далее,
потому что он полностью основан на теории Ford-Fulkerson.
То есть заметьте, что тут у меня история точно такая же.
То есть я, соответственно, строю какую-то вспомогательную слоистую сеть,
а дальше в этой слоистой сети ищу пути
и дополняю эти пути, соответственно, новым потоком.
Нас, соответственно, просто на каждой итерации добавляю по новому потоку.
Ну а теория Ford-Fulkerson нам говорит, что так можно делать.
Во-первых, Лемма об арифметике потоков нам говорит,
что действительно потоки можно складывать.
Ну а теория Ford-Fulkerson говорит,
что если я буду так делать и в какой-то момент я ничего не найду,
то, соответственно, я уже нашел максимальный поток.
Да, ну, соответственно, алгоритм такой.
Изначально у нас поток рулевой.
Дальше с помощью BFS строим слоистую сеть.
То есть просто-напросто запускаем алгоритм BFS.
Вот.
И для каждой вершины находим тот уровень, на котором она находится.
То есть тот слой, на котором она находится.
Дальше, соответственно, берем эту самую слоистую сеть
и находим все пути из SFT вот вдоль этой слоистой сети.
То есть по тем ребрам, которые проходят из одного слоя во второй.
Как только все эти пути у меня закончились,
как только я насытил все ребра, ну не все ребра,
например, вот эти три ребра я насытил,
то есть теперь у меня по этой слоистой сети невозможно добраться из вершины S в вершину T.
Ну и значит, что всю эту слоистую сеть я полностью, так скажем, заиспользовал.
Ну и, соответственно, теперь я могу вернуться к пункту 1,
то есть заново запустить BFS, найти какую-то другую слоистую сеть, более широкую.
Ну и, соответственно, продолжать работать.
Продолжать работать в ней.
Ну и, соответственно, возникает тоже логичный вопрос.
Ну хорошо, у нас работает такой алгоритм,
ну вообще говоря, почему он может работать быстрее, чем Эдман Скарпа?
То есть, окей, в Эдман Скарпа мы очень много раз вызываем алгоритм BFS,
но с другой стороны алгоритм единицы мы же много раз будем искать пути.
То есть, окей, слоистую сеть мы построили, грубо говоря,
ну не так часто мы строим слоистую сеть, то есть не так часто вызываем алгоритм BFS,
но все равно на каждой итерации, то есть вот пункт 2, да, мы ищем дополняющие пути,
то есть мы находим дополняющий путь первый, потом второй, потом третий и так далее,
пока соответственно у нас ищутся пути.
То есть, казалось бы, чем поиск вот такого пути отличается от вызова BFS?
Ну давайте, собственно, ответим на три вопроса,
и таким образом мы поймем, почему алгоритм единицы работает на порядок быстрее,
чем алгоритм Эдман Скарпа.
Значит, ну первый вопрос, сколько раз нужно перестраивать слоистую сеть?
Сколько раз нужно перестраивать слоистую сеть?
Ну смотрите, ответ на вопрос на самом деле довольно-таки простой.
Вот, допустим, я построил какую-то слоистую сеть, вот изображена здесь,
и соответственно расстояние от SDT у меня равно 4.
Что означает, что в этой слоистой сети я дальше продолжаю,
дальше я начинаю не искать какие-то пути, и в какой-то момент пути найти не могу.
Что это означает?
Значит, смотрите, если, отвечаю на первый вопрос, да,
если слоистой сети нет путей из SFT, то это значит, что все пути длины как?
Ну вот, в данном случае, кару на 4, все пути длины к уже рассмотрены.
То есть, грубо говоря, слоистая сеть, она, грубо говоря, содержит все возможные пути длины 4.
Если посмотреть на картинку, то слоистая сеть содержит все пути длины 4.
Соответственно, если в какой-то момент я в этой слоистой сети не могу найти новый путь,
в смысле, вот эти ребра мне уже недопустимы, то есть, по этим ребрам я уже пройти не могу, так они уже заполнены.
Соответственно, это означает, что в графе у меня уже нет путей, которые идут из SFT длины 4.
И более того, у меня нет путей более коротких. Почему?
Потому что мы в прошлый раз с вами доказывали для Edmund Scarpa, что при добавлении новых потоков
у меня кратчайшее расстояние от SDT может только увеличиваться, но никак не уменьшаться.
Ну а раз я рассмотрел все возможные пути длины 4 и больше их не осталось, то, соответственно,
у меня длина кратчайшего пути от SDT могла только увеличиться, то есть реберный путь от SDT только увеличился.
Ну а сколько раз я могу увеличить путь от SDT?
Ну, понятное дело, что не более в раз.
Меньше ребра равно, чем в.
Вот так как длина пути из SFT не больше, чем в-1.
Давайте так еще раз. Какой ответ на первый путь?
Сколько раз нужно перестраивать свои сети?
Грубо говоря, сколько раз мне нужно выдавать алгоритм BFS?
Я запустил первый раз алгоритм BFS.
Он нашел какой-то путь длины K из SFT.
Все эти пути я уже рассмотрел, больше таких пути нет.
Дальше снова запускаю алгоритм BFS, и так как пути и длины K у меня больше нет,
путь может только увеличиваться, то следующий алгоритм BFS найдет мне кратчайший путь,
ну, больше либо равный, чем K плюс 1.
Следующий путь будет больше либо равный, чем K плюс 2.
Ну и так далее.
Последний путь, естественно, будет иметь длину в-1.
Соответственно, количество таких перестроений у меня не больше, чем в-1.
На самом деле тут написал меньше, чем в, а это неважно, она с этим точкой не повлияет.
С этим разобрались.
Следующий пункт. Сколько времени занимает поиск пути в слоистой сети?
После того, как я построил слоистую сеть, я в ней начинаю искать пути.
Так вот сколько времени занимает поиск пути в слоистой сети?
На самом деле поиск пути в слоистой сети занимает...
Давайте с этим разберемся.
На самом деле я утверждаю, что поиск пути в слоистой сети занимает очень небольшое время.
А именно я не более чем в смогу найти этот самый путь.
Почему?
Допустим, я нахожусь в какой-то вершине.
Что мне нужно сделать, чтобы найти следующую вершину на пути от S до T?
Мне нужно просто взять и выбрать какой-то из этих ребр, которые у меня остались в слоистой сети.
То есть у меня есть слоистая сеть, я знаю все ребра, которые ведут из одного слоя во второй слой.
Соответственно, что я делаю?
Просто выбираю произвольное ребро и иду вот сюда.
Дальше нахожусь в этой вершине, выбираю произвольное ребро.
Вот это.
Оно единственное.
Прохожу вот сюда.
Беру произвольное ребро.
Прохожу и сюда.
То есть на самом деле я всегда могу продвигаться за единицу слоистой сети на один шаг вперед.
Соответственно, поиск пути в слоистой сети занимает тоже не больше чем в шагов.
я нахожусь в вершине S, выбираю произвольное ребро и слои Cт идут в tab,
выбираю произвольное ребро и gaveo, выбираю произвольное и above.
Ну и соответственно, сколько всего путей можно найти слои Cт?
Вопрос довольно простой. Сколько всего путей можно найти слои Cт?
Давайте просто построим просто и beispielsweise к каждому п 1919-го года
Поставим в соответствие каждому ребру в слоистой сети, поставим в соответствие некоторой путь.
Вот смотрите, вот я нашел какой-то путь в слоистой сети. Давайте его обозначим так.
И что я могу сказать? Что я могу сказать про этот путь?
Я точно знаю, что на этом пути хотя бы одно ребро станет критическим.
Что такое критическое ребро? Критическое ребро – это то ребро, которое насытилось.
То есть то ребро, по которому я опустил поток максимально возможной величины.
Пусть у меня тут пропускная способность была 5, тут 3, тут 2, тут 4.
Соответственно вдоль вот этого пути, который я нашел, я могу пустить поток равный 2.
Ну и соответственно я опускаю поток равный 2. То есть тут опускаю 2 единиц потока, тут 2 единицы, тут 2 единицы, и тут 2 единицы.
И соответственно вот я вижу, что вот это ребро пропускной способности 2, оно насытилось.
То есть в следующий раз я его использовать не смогу.
То есть оно на самом деле уходит из моей слоистой сети.
То есть каждый путь уменьшает количество ребер в слоистой сети, ну и в графе получается в целом, на единицу.
Как минимум на единицу.
Ну и соответственно это означает, что общее количество пустей в слоистой сети не больше, чем е. Не более, чем е.
Потому что каждый путь убирает хотя бы одно ребро.
То есть в худшем случае, если у меня каждый путь будет убирать всего лишь одно ребро,
то соответственно в любом случае я получу, что количество пустей у меня будет не больше, чем е.
Потому что я не могу убрать из графа больше ребер, чем у него было изначально.
Ну вот кажется все. Кажется мы поняли, что асимптотику алгоритма 1.
То есть нужно взять вот эти три чиселки и просто просто перемножить. Почему?
Потому что мы в раз перестраиваем слоистую сеть.
Потому что после каждой перестройки такой мы е раз ищем путь в слоистой сети.
А каждый поиск в пути занимает в.
То есть получается в умножить на е умножить на в.
Ну собственно е в а квадрат.
Вот.
Да, то есть сколько раз нужно перестраивать слоистую сеть не больше, чем в.
Так после каждой транса расстояние теста до этого увеличивается.
Сколько раз времени занимает поиск в пути слоистой сети меньше ребра, чем в.
Потому что просто переходим от одного слоя ко второму.
То есть не нужно перебирать всевозможные пути.
Мы просто-напросто выбираем произвольное ребро и идем от одного слоя ко второму.
Скоро всего в пути можно найти слоистой сети не больше, чем е.
Каждый путь находит хотя бы одно критическое ребро.
Ну и поэтому перемножая все эти числа, получаем, что сложить алгоритмы не более чем в.
А квадрат умножить на е.
Вот.
Ну там плюс да.
Ну и тут написано еще плюс от е, но это на всякие дополнительные технические детали.
Типа того, что если у нас критическое ребро, то его нужно удалить из графа и так далее.
Ну это мелочи все.
Вот.
Такие дела.
Вот такой алгоритм 1.
Ну и соответственно, какие еще алгоритмы поиска потока максимальной величины существуют.
Ну в общем, если говорить про.
Ну вот мы сейчас рассмотрели теорию Форда Фалкерсона.
В прошлый раз рассмотрели теорию Форда Фалкерсона.
И соответственно, рассмотрели три алгоритма, которые на ней основаны.
Первый алгоритм Форда Фалкерсона непосредственно.
С помощью алгоритма DFS.
Дальше мы собственно поняли, что если вместо DFS использовать BFS, то мы получаем, во-первых, алгоритмы Адмедскарпа.
Во-вторых, получаем более хорошую, скажем так, более оптимистичную асимптотику, которая не зависит от ответа.
Ну и соответственно, после того, как мы поняли, что на самом деле не нужно на каждой итерации постоянно вызывать алгоритм BFS.
Можно воспользоваться, соответственно, построенной слоистой сетью.
Мы, соответственно, построили алгоритм Динеца, который, давайте напомню все сложности алгоритмов.
Есть Форт Фалкерсон, который работает за O'e умножить на мощную, на величину оптимального потока.
Значит был Адмедскарп, его сложность от V на E квадрат.
И есть Динец, сложность которого E на V квадрат.
Значит, можно ли лучше? Ответ да.
И есть такой алгоритм, трех ИДУСов.
Алгоритм Алхотра и Кумара Махешвари, который работает за O от V куб.
Мы с вами понимаем даже, что алгоритм Динец, если граф плотный, то он работает за V в четвертой степени.
Если граф разрежен, то он работает за V куб.
Вот алгоритм Алхотра и Кумар Махешвари, он работает за V куб в любом случае.
Я думаю, мы его бегло сейчас рассмотрим.
Если возникает вопрос, а какой алгоритм в принципе существует наиболее оптимальный, то из того, что мне удалось найти,
есть алгоритм Орлинг, который основан не на теориями Форда Фалкерсона и работает за O от V.
Если говорить про алгоритм, который основан на теориями Форда Фалкерсона, то отоптимальный это алгоритм Алхотра и Кумар Махешвари.
Есть много других алгоритмов поиска потоков.
В случае интереса можете рассмотреть самостоятельно на всякие push relabel схемы и так далее.
По-моему, Орлинг как раз основан на методе push relabel.
Он работает за O V E.
Асимптотика, которая в некоторых ситуациях лучше, чем V куб.
При этом он основан не на теориями Форда Фалкерсона.
Сейчас я предлагаю рассмотреть алгоритм Алхотра и Кумар Махешвари.
В чем его идея? Почему он позволяет улучшить асимптотику до V куба?
Почему он позволяет уменьшить множитель E до V?
В чем его особенность?
Давайте посмотрим.
Я предлагаю просто открыть статью Алхотра, Кумар Махешвари и посмотреть, что они пишут.
Это статья 1978 года.
И можно промешаться по алгоритму, который они предлагают.
Во-первых, тут сразу видно, что у нас есть знакомое обозначение, что у нас действительно есть поток F, есть соответственно плюсовая способность C,
есть условия на то, что у нас поток нигде не накапливается, кроме вершин S и T и так далее.
Тут ссылка на алгоритм Диница, который работает за VE-итерацией.
Что предлагается? На самом деле алгоритм довольно-таки идейно прост.
Вот смотрите, что мы делали в алгоритме Диница.
Ну и вообще в алгоритме Эдмана Скарпа и Форда Фалкерсона.
Мы, собственно, пускали поток по ребрам.
Давайте вернем все сюда.
В чем была идея?
Вот у нас был S, был T, и мы, соответственно, искали путь из S до T.
И, соответственно, тут, допустим, C1, C2, C3, C4.
И на этом пути искали, соответственно, ребро с минимальной пропускной способностью, например, C2.
Искали ребро с минимальной пропускной способностью C2 и, соответственно, пускали вдоль этого пути поток размера C2.
Потому что это максимальный поток, который мы можем пустить вдоль этого пути.
А вот алгоритм алкоголя Трукумер Мэшшфарь предлагает сделать другую вещь, предлагает сделать нечто более интересное.
А именно, давайте посмотрим на все вершины слоей сети.
И введем такое понятие, как потенциал вершины.
Что такое потенциал вершины?
Потенциал вершины – это, собственно, то количество потока, которое может протечь через данную вершину.
Как его можно понять?
Ну, понять его довольно просто.
Давайте снова вернемся сюда и посмотрим, как можно оценить количество поток, которое может протечь через вершину.
Во-первых, из вершины есть исходящие ребра.
Во-вторых, в вершине есть входящие ребра.
Допустим, тут пропускная способность α1, α2, а3, вот бета1, бета2, бета3.
Так вот, пропускная способность вершины х, ну или потенциал вершины х, это не что иное,
как просто-напросто минимум из бета1 плюс бета2 плюс бета3 и а1 плюс а2 плюс а3.
То есть, сколько потока может протечь через вершину.
Но это минимум из того, сколько может втечь, и минимум из того, сколько может вытечь.
Скажем, если вершину может суммарно прийти не более 10 единиц потока,
а выйти может 12 единиц потока, то понятное дело, что больше 10 потока я через вершину никак не протащу,
потому что больше десяти в нее никак не придет.
Вот такая идея.
То есть, для каждой вершины я храню так называемый потенс chemicals.
Вот, так определяется, сколько потоку может прийти вершин, и сколько потоку может выйти из вершины.
Точнее, наоборот, сколько может выйти из вершины, и сколько может войти в вершину.
А дальше соответственно мы делаем следующую вещь. Давайте возьмем вершину с наименьшей пропускной способностью, с наименьшим потенциалом.
Чем хороша эта вершина? А вершина хороша тем, что если эта вершина обладает наименьшим потенциалом, то я гарантированно смогу пустить поток вот такой величины через эту вершину.
Давайте снова порисуем.
Ну вот, допустим, у меня есть какая-то слоистая сеть.
Вот такие ребра.
Вот, ну и допустим, у меня есть вершина с наименьшей пропускной способностью.
А у всех остальных вершин пропускная способность больше.
Ну, значит, отсюда, то есть очевидно, что если вот эта вершина обладает наименьшей пропускной способностью,
например, альфа, то это значит, что я смогу пропустить ровно альфа потока.
Вопрос, почему? Откуда это следует?
Ну, все довольно просто.
Ну, смотрите, вот здесь я пускаю какой-то альфа-штрих потока, то здесь пускаю альфа-два-штрихо потока.
Ну, смотрите, вот у этой вершины пропускная способность явно, ну, speechless,
у ее entertained способность от этой вершины больше leadership than alpha.
Ну, соответственно, альфа-штрих� потока, она явно может вместить.
У этой вершины тоже пропускная способность больше leadership than alpha,
поэтому alpha-два-штрихо поток она точно может впростую себя пропустить.
Для вот этих вершин то же самое.
Допустим, тут бета-штрих, тут бета-два-штриха.
Соответственно, понятное дело, что эта вершина может
отпустить себя больше, чем альфа, и больше равно, чем альфа.
И понятное дело, что альфа больше равно, чем бета-штрих
и больше равно, чем бета-два-штриха.
Расс Underground вот таким образом я прихожу к тому,
что на самом деле из вот этой вершины я могу
пустить поток любой величины в любую другую вершину.
Ну и абсолютно аналогично вот из этих вершин я тоже
могу пустить произвольное количество потоков как
в обратном направлении.
Вот.
Окей.
Ну вот, соответственно,
можно сказать, что буквально сейчас
доказал Лему, что если
есть вершина с минимальной
пропускной способностью, в данной статье
называется ReferenceNode,
то, соответственно, я смогу
пустить через мою транспортную сеть
ровно такое количество потока.
Ну, действительно, довольно просто.
Если вершина обладает
перед нами максимальной пропускной способностью,
то понятно дело, что я могу...
что из нее я могу пустить столько же потока
во все остальные вершины,
так как у них пропускной способности больше,
то я точно через них могу только протащить.
Ну и плюс, соответственно
и наоборот.
Я могу в этот вершину
в пустить столько единиц потока.
Потому что из ее соседей,
соседей они тоже больше, чем у самой эта
вершина, конечно. Ну, вот, соответственно, алгоритм довольно простой. Давайте, собственно, строить вот эти
самые транспортные сети, искать вершину с наименьшей
способностью и пускать максимальный поток через эту вершину.ائ
Каким образом? то есть берем эту вершину
и протаскиваем его сейчас Leoni Saya,
и протаскиваем вот такое количество потока через, ну, количество потока альфа
через эту вершину прямого направления и, ну, грубо говоря, в обратном направлении.
То есть из этой вершины в t и из этой вершины в s.
Что мы получаем таким образом? Ну, таким образом мы получаем следующую вещь,
что на каждой итерации, давайте вспомним алгоритм Деница,
что утверждалось в алгоритме Деница? В алгоритме Деница утверждалось,
что и на каждой итерации в слоистой сети ищем количество путей,
которым находим в слоистой сети не превосходит e.
Почему? Потому что на каждой итерации мы удаляем одно ребро,
так на каждой итерации мы удаляем одно ребро, ну, как минимум одно ребро,
а то, соответственно, в худшем случае у нас e-итераций.
А что происходит здесь? Вот в этой алгоритме, в этом алгоритме на каждой итерации мы удаляем одну вершину.
Все, то есть если мы через вершину пустили максимальное количество потока,
то все, эту вершину больше использовать в будущем не сможем.
так как мы на каждой итерации, то есть у нас была оценка v умножить на e умножить на v,
а тут мы изменили оценку до v умножить на v умножить на v, да, то есть вот.
То есть раньше у нас каждый новый поток убирал одно ребро, то есть одно ребро становилось критическим,
то тут в этом алгоритме у нас вершина, каждая вершина становится критической не более одного раза.
Да, ну все, соответственно, здесь оценка умножить или меняется на v,
соответственно, в итоге получаем у большой от v в кубе.
Вот, соответственно, вот такая вот, вот такая вот идея.
Ну и на этом, в принципе, статья заканчивается.
Вот такой вот алгоритм, который основан, ну, с одной стороны, основан на идее алгоритма Диннице,
но с другой стороны использует в полной мере теорему Форда Фалкерсона.
То есть как он использует теорему Форда Фалкерсона, очень просто.
То есть мы тоже, то есть тоже у нас есть некоторый поток, то есть некоторая транспортная сеть,
в которой мы, в которой у нас есть текущий поток.
Да, мы в ней пытаемся как-то найти дополнительный поток,
но в данном случае мы ищем дополнительный поток через, который проходит через конкретную вершину, вот.
Ну и, соответственно, ну и, соответственно, добавляем этот поток,
ну этот, ну этот ручеек, да, к нашему, к нашему потоку, вот.
Ну, соответственно, вот, наверное, вот полный обзор, полный обзор методов
для работы с, для работы с потоками в рамках теоремы Форда Фалкерсона.
Так, ну и на этом с потоками мы закончили, ну и, в принципе, наверное,
с модулем, посвященным графам в этом семестре мы тоже закончили.
Вот единственное, что у меня осталось, это небольшой разговор про,
небольшой дополнительный разговор про кратчайшие, покрытые потоки,
и про некоторый алгоритм, который пригодится вам, ну, в одной задаче из задания,
ну, в последней, в последней задаче.
Да, ну вот, я думаю, что это, наверное, всё, что мы делали,
в том числе и в этом числе и в этом числе,
Смотрите, что мы с вами обсуждали, когда говорили про алгоритм поиска кратчайшего пути.
На самом деле мы рассматривали две постановки задачи. Первая задача это single source.
У нас есть одна выделенная вершина, и нам нужно идти пути во все остальные.
Была задача all pairs, то есть у нас был граф, и нужно было найти кратчайшее расстояние между всеми парами вершин.
Но при этом должен был возникнуть естественный вопрос.
Вот смотрите, что мы делаем. Мы берем одну вершину, находим пути до всех остальных.
Или мы берем все вершины, находим расстояние между всеми парами вершин.
А что если у меня есть конкретная вершина, ну пункт A условно, есть конкретная вторая вершина, пункт B,
и я хочу найти кратчайший путь конкретно между вершинами A и B, то есть, грубо говоря, single pair задачи.
Ну и согласитесь, что на практике, наверное, эта задача встречается гораздо более часто, чем эти предыдущие две.
Условно, вы забиваете какой-нибудь маршрут в навигаторе, то есть берете начальную точку, берете конечную точку,
и, соответственно, ищете по какому минимальному маршруту я могу добраться из точки A до точки B.
Согласитесь, это более, наверное, практически применимые задачи и более часто встречающие задачи.
Собственно, можно ли рассмотреть эту задачу и можно ли ее решить как-то быстрее, чем вот, например, single source задачу, задачу из нового источника.
И вот, на самом деле, печальное утверждение заключается в том, что на самом деле single pair задачи является,
ну скажем так, в большинстве ситуаций является ничем не проще, то есть не является более простой, чем задача single source.
И это довольно понятно, ну и довольно понятно почему, да, потому что, условно, если вам нужно найти кратчайший путь из точки A в точку B,
то ваш алгоритм, грубо говоря, должен каким-то образом уметь доказывать, должен уметь доказывать, что этот путь действительно является кратчайшим.
То есть условно, мы нашли путь размера 10, и, в общем, вашему алгоритму нужно каким-то образом доказать, что путь, проходящий через точку C,
допустим, до точки C, мне расстояние 5, то каким-то образом алгоритм должен уметь доказывать, что путь, который проходит через точку C,
он никак не короче, чем вот тот путь, который мы нашли.
нашли. Но соответственно, каким образом мне нужно доказать, что расстояние от, что расстояние,
что точнее путь, который походит через c, у меня никак не короче, чем вот нужный путь. Ну,
по сути, ничего не остается, кроме как найти реальное расстояние от a до c, или расстояние от c
до b, и, соответственно, показать, что действительно этот путь длиннее, чем это путь длиннее, чем до b.
То есть, грубо говоря, вам в любом случае приходится находить какие-то кратчайшие пути до
остальных вершин. То, есть как минимум на всех, для всех вершин, которые находятся на
промежуimateг этапах, вам необходимо найти кратчайший путь. И, более того, скорее всего,
вам придется найти кратчайший путь до многих других вершин. Но просто, Pyając, что ваш алгоритм
был уверен, чтобы ваш алгоритм был уверен, что вы действительно до b нашли кратчайший путь.
Ну, по сути так поступает алгоритм DXRE, да?, алгоритм DXRE так и поступает. То есть он,
то есть у него есть множество S, то я напоминаю, что в алгоритме Dx у нас есть некоторое множество S,
вершины, до которых мы нашли верное кратчайшее расстояние.
И по сути мы вершину S, мы это множество S постоянно расширяем, постоянно дополняем.
Ну и соответственно, после того, как в нашем множестве S оказалась нужная нам вершина B,
мы по сути на этом можем завершить алгоритм.
Но даже при этом алгоритм Dx находит кратчайшие пути до многих, скажем так, лишних, до многих лишних вершин.
Просто нам для того, чтобы было доказуемо, доказуемо известно, что более короткого расстояния до вершины B мы не найдем.
Вот. Поэтому, в общем, мораль заключается в том, что single pair задач, как правило, решаются с помощью single source алгоритмов.
Ну, например, с помощью алгоритма Dx, то есть опять же, как выглядит обычный алгоритм поиска кратчайшего
расстояния от вершины A до вершины B, до конкретной вершины B.
Да, вы запускаете алгоритм Dx, как только у вас вершина B, как только у вас алгоритм Dx дошел до вершины B, вы алгоритм останавливаете.
То есть вы не нашли расстояние до всех вершин, но вы нашли расстояние до каких-то вершин, среди которых есть вершина B.
Вот. И единственное, что мы тут можем обсуждать, это то, а можем ли мы как-то этот процесс ускорить.
Да, ну окей. То есть мы находим кратчайшее расстояние до каких-то лишних вершин.
То есть в целом у нас задача single-pair, она в худшем случае никак не быстрее,
то есть решение для single-pair задачи никак не может быть быстрее, чем для single-source задачи.
Но можем ли мы все-таки как-то ускорить?
И ответ – да, можем, воспользовавшись какими-то идеями, какими-то юристиками.
Ну, давайте, собственно, одну из них обсудим.
Ну, есть довольно-таки понятная идея, которая заключается в том, что очень часто,
ну, то есть не имеет смысла искать расстояние из тех вершин, из которых мы, скорее всего, кратчайший путь не найдем.
Ну, про что я? Давайте, ну, давайте, давайте обсудим вот такую идею.
Вот, допустим, я нахожусь, не знаю, где.
Ну, допустим, есть там город. Есть город Казань.
И я хочу, соответственно, найти кратчайший маршрут до города Москва.
Вот. Что произойдет, если я запущу алгоритм Dijkstra
вот, ну, на такой маршрут, да, то есть, условно, я могу взять карту, представить ее в виде графа,
соответственно, ребра – это, соответственно, дороги.
Ну, длина ребра – это, соответственно, длина дороги.
Ну, и, соответственно, каким-то образом хочу построить кратчайший путь.
Запущу алгоритм Dijkstra. Что мне сделать алгоритм Dijkstra?
Ну, алгоритм Dijkstra сначала найдет, грубо говоря, да, все.
Ну, расстояние до всех городов, расстояние до которых меньше, там, условно, ну, 100 километров, давайте так скажем.
Вот потом найдет расстояние до всех городов, расстояние, до которых, там, меньше 200 километров.
То есть, вот, алгоритм Dijkstra, он находит расстояние по порядку.
mashedثر – это, то есть, сначала он находит, там, до одних, то есть, до одного места, потом до второго, потом до третьего и так далее.
Ну и так далее.
И вот, допустим, мы нашли множество городов, расстояние до которых меньше обрано 500 километров.
Да, то есть, вот, мы, вот нашли алгоритм Dijkstra, поиск кратчайшей пути из Казани в Москву.
нашел все кратчайшие пузи из Казани до городов, расстояние которых меньше 500 километров.
Ну и скажем, тут есть какой-то город, Екатеринбург,
который находится, грубо говоря, на нашей вымышленной карте,
на другом конце Москвы.
То есть, грубо говоря, тут Екатеринбург, тут Москва.
Ну и соответственно, находится какой-то город Н.
Вопрос.
Есть такая конфигурация, вот так работает алгоритм до экстры.
Возникает естественный вопрос.
А вообще говоря, имеет ли смысл, что лучше, что выгоднее, что эффективнее?
Продолжать искать пути из города Н или из более, скажем, западных городов?
Или все-таки стоит рассматривать еще пути из Екатеринбурга и вот всех остальных более восточных городов?
Ну интуиция, кажется, нам подсказывает, что искать равномерным образом, искать пути,
скажем, из Екатеринбурга и, скажем, из Нижнего-Нового города, условно, это путь в никуда.
Почему?
Потому что вряд ли, раз до Екатеринбурга расстояние 500, вряд ли из Екатеринбурга мы доберемся до Москвы быстрее,
чем, скажем, из какого-нибудь Нижнего-Нового города, из какого-нибудь более близкого к Москве города.
То есть интуиция нам подсказывает, что если, в принципе, мы понимаем, что какие-то города могут находиться ближе к Москве,
какие-то города могут находиться дальше от Москвы, мы с вами понимаем, что в целом, наверное, гораздо эффективнее
рассматривать кратчайшие пути из тех городов, которые, соответственно, находятся к цели ближе, чем, соответственно, другие,
которые находятся, чем те, которые находятся дальше.
И, собственно, то есть, грубо говоря, картинка должна быть не такая, а скорее вот такая.
Давайте перерисуем.
Да, то есть скорее я бы хотел не такую картинку, а хотел какую-то вот такую картинку.
Вот так, так, так, вот так.
То есть неравномерные окружности, неравномерные круги, а такие вот вытянутые.
То есть я бы хотел, грубо говоря, чтобы города, которые потенциально находятся к Москве ближе,
рассматривались чаще, рассматривались раньше, чем те города, которые находятся дальше.
То есть, окей, вот эти города теоретически можно рассматривать, но, соответственно,
из них я с меньшей вероятностью доберусь до цели быстрее.
То есть хотелось бы отдавать приоритет больше к тем городам или больше тем точкам,
которые находятся к цели ближе, чем, соответственно, чем остальные.
И, собственно, в этом заключается идея алгоритма A star или A звезда.
В чем идея этого алгоритма?
А идея этого алгоритма простая.
Начну от того, я много говорил про DX3, и, собственно, что мы использовали в DX3.
В DX3 мы с вами в качестве функции приоритета использовали расстояние от S до V.
И, соответственно, был приоритет в DX3.
Ну и, собственно, проблема этого приоритета довольно понятна.
То есть он рассматривает, грубо говоря, Нижний Новый город и Екатеринбург
как одинаковые города при поиске пути исказаний до Москвы.
Хотя мы понимаем, что, наверное, Нижний Новый город, он как-то более хорош,
чем расстояние до Москвы, чем, скажем, то же самое Екатеринбург.
Что предлагает A star?
Он предлагает использовать другой приоритет,
а именно расстояние от, ну, давайте так напишу,
оценка расстояния, да?
Тут же D. D от V. D от V.
Плюс некоторое H от V.
Где H от V?
Это оценка расстояния от V до цели T.
Вот, давайте тут напишу, что мы осуществляем поиск пути,
кратчайшего пути, из S в T.
Вот.
Оценка расстояния от, от чего я написал?
От V до цели T.
Вот.
Ну и, соответственно, то есть, если у нас, то есть, оценка, то есть, понятно дело,
что мы истинного расстояния, там, скажем, от точки N до Москвы, мы его не знаем, да?
То есть, мы его только ищем.
Но при этом мы можем его как-то оценить.
Ну, давайте приведем какие-нибудь примеры Ашке.
Что же может являться примером для H?
Ну, например, если мы говорим про карту,
то мы можем просто-напросто в качестве оценки расстояния от города N до Москвы
взять просто-напросто расстояние между ними в километрах, да?
То есть, не по дорогам, да?
Просто вот взять чисто географическое расстояние, да?
Там вот по глобусу, да?
И, соответственно, сказать, что вот такое расстояние.
Ну, или даже там по хорде, да? По хорде земного шара.
Ну, неважно. Вот.
Ну, вот какая оценка.
Да? Или скажем, если у нас есть, ну, опять же, да.
Не знаю, ну возьмем какой-нибудь робот-пылесос, да?
Вот есть робот-пылесос.
Соответственно, вот вот есть у нас квартира
в которой, соответственно, есть какие-то там преграды и так далее.
И вот, соответственно, роботу нужно браться из�로 expansive,
вот, из точки X с точки Y.
Да? Понятно дело, что вот он не знает крочейший путь.
Тогда что может являться...
Что может...
Вот, есть такая точка, вот.
Что может являться оценкой расстояния от этой точки до Y?
Ну, оценка расстояния этой точки до Y может быть тоже,
собственно, вот это самое непосредственно расстояние.
расстояние по прямой, грубо говоря. Вот если бы у нас не было никаких преград, вот по прямой мы добрались за такое-то время, за такое расстояние.
Ну или если мы говорим про какую-нибудь сетку,
не знаю, там шахматная доска,
соответственно, нужно добраться из точки x до точки y, при этом тут есть какие-то там запрещенные клетки или препятствия, то соответственно,
ну или там, ну, допустим, x это шахматный король. Тогда что может являться?
Оценка расстояния от x до y при условии, что мы не знаем, какие там преграды у нас есть на пути. Но это просто-напросто
грубо говоря,
расстояние по вертикали дельта x и расстояние по горизонтали дельта y.
h от x
есть дельта x плюс дельта y. Ну так называемое Манхэттеновское расстояние, то есть расстояние по вертикали и по горизонтали суммы.
Ну вот.
То есть на самом деле, если у вас есть какая-то конкретная задача, да, там неважная географическая задача, есть одна задача на доске кое-то и так далее, у вас, как правило, есть
Есть некоторые представления о том, как может выглядеть оценка расстояния до цели.
И в случае, если у вас есть такая оценка, то, соответственно, вы можете воспользоваться алгоритмом A star
и, соответственно, использовать вот такие приоритеты.
В остальном алгоритм практически не отличается от алгоритма Dexter.
То есть мы работаем точно также, тоже достаем вершины в порядке приоритета.
Но уже в качестве приоритета используем не оценку расстояния массива D,
а используем вот такую-то оценку, то есть найденное расстояние плюс, соответственно,
оценка расстояния от текущей точки до цели.
Возникает вопрос, ну, хорошо, что если у меня оценка плохая?
Что если я выбрал плохую оценку?
Ну, допустим, у меня оценка вообще не точная.
То есть верный решитель алгоритм будет работать корректно.
Ну, ответа, естественно, нет.
Дело в том, что вот эту самую оценку, оценку h,
ну, выбирать абы какой нельзя.
И существует теорема, которая у нас будет без доказательства.
Теорема без доказательств, которая утверждает следующее, что...
Давай для начала определение ведем.
Оценка h является допустимой,
а если h от v меньше броно, чем wt.
То есть h,
а если h от v меньше броно, чем wt.
То есть,
h нижняя оценка
на расстояние
до t.
То есть, ну, еще называют ее, еще иногда называют оптимистичная,
оптимистичная оценка, или h оптимистичная оценка.
Так вот, если вы выбрали такую h, что она не, скажем так,
не переоценивает расстояние до цели,
вот всегда эта оценка строго меньше, чем истинное расстояние,
то тогда эта оценка называется допустимой.
И если вы посмотрите на те примеры, которые я приводил,
на самом деле все эти примеры являются примерами как раз допустимых оценок.
Потому что чисто географическое расстояние, то есть просто-напросто вот по карте.
Понятное дело, что это оптимистичная оценка, потому что быстрее,
то есть короче пути, чем вот просто-напросто вот по прямой,
без учета всяких дорог, населенных пунктов и так далее, вы придумать не можете.
То же самое касается вот Манхеновской метрики, если мы говорим про какую-нибудь шахматную доску.
Понятное дело, что быстрее, чем разница по x и разница по y,
ну, за такое количество шагов, если мы говорим про шахматного короля,
вы не доберетесь.
Ну, опять же, если мы запрещаем еще походить в диагонали и так далее.
Да, то есть если можно ходить вверх-вниз, влево-право.
Ну, или если мы говорим про навигацию в комнате.
То есть опять же, если мы идем по прямой, то есть если мы учтем состояние только по прямой,
без учета всяких переград, то понятное дело, что это тоже оптимистичная оценка.
Так вот, соответственно, теорема.
Если h допустимо.
То а стар оптимален.
То есть алгоритм находит оптимальное решение задач.
То есть он находит реальный кратчайший путь из конкретной вершины s до конкретной вершины t.
Ну, собственно, поэтому...
Да, ну и понятное дело, что в рамках этого алгоритма существует много всяких...
На самом деле не так, чтобы много, потому что алгоритм эвристический.
То есть я не сказал, что алгоритм является эвристическим.
Потому что понятное дело, что для него сложно придумать какие-нибудь гарантии, которые работают всегда.
Потому что алгоритм, время работы алгоритма, его эффективность и так далее,
они очень сильно зависят от того, какую оценку h вы используете, от того, какую задачу вы решаете.
То есть не важно на какой-нибудь географической местности и так далее.
Все очень сильно зависит от выбора функции h.
Но в целом существует ряд утверждений, которые говорят о том, что чем ближе h к истине, тем быстрее работает алгоритм.
То есть тем быстрее он находит правильный ответ.
То есть рецепт на самом деле такой.
То есть если вам нужно как можно быстрее найти кратчайшее расстояние между заданной парой точек,
то вы используете алгоритм a star, придумываете какую-нибудь эвристическую функцию h,
которая умеет довольно-таки точно оценивать расстояние между точкой x и точкой y.
И при этом так, чтобы она не переоценивала это расстояние.
Чтобы эта оценка обязательно была оценкой снизу.
В этом случае вам будет гарантирована, во-первых, что алгоритм найдет правильное решение.
Во-вторых, если ваша оценка достаточно точна, то решение будет найдено несколько быстрее,
чем обычный алгоритм dx или любые другие алгоритмы поиска кратчайших путей.
Вот такое замечание, такое отступление, которое я хотел сделать по поводу поиска кратчайших путей.
То есть задача поиска кратчайших путей между конкретной парой вершин не может быть проще,
чем задача поиска путей из одной вершины до всех остальных.
Но в некоторых ситуациях, если мы знаем конкретную задачу, если мы знаем конкретный домен,
на котором она выполняется, то алгоритма star иногда позволяет добиться более быстрых решений.
Ну и, как я уже сказал, у вас есть задача последняя, в которой алгоритма star может пригодиться,
в которую она может дать более эффективное решение.
Ну, на этом, собственно, вся, наверное, алгоритмическая часть нашего курса подошла к концу.
То есть, в целом, все, что было запланировано в этом семестре, я рассказал.
Ну, я, наверное, для себя сейчас сделаю 5 минут перерыв.
Ну и после перерыва перейду к последней лекции по плюсам.
Вот.
