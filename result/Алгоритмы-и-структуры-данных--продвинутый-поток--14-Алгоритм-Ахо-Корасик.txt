Ну, до сего момента мы говорили о уровне изи – поиска подспечной строки.
Дана одна строка, один шаблон, один текст. Найдите все картинки шаблонов текста.
Сейчас мы попытаемся повысить планочку.
Теперь мы представим, что у нас этих шаблонов много.
А именно, к штуку.
И один текст D.
Вот строчки тут самые разные.
Нам очень хочется найти...
Ну, например, давайте будем решать задачу в такой постановке.
Все обхождения всех этих строчек в тексте.
Ну, давайте подумаем, за какую идеальную асимптотику можно было бы это сделать.
Ну, идеальная асимптотика, конечно, трачет.
Ну, конечно, в идеале было бы, что сумма всех асимптов плюс модуль T.
В идеале.
Но это исключительно в идеале.
Потому что, заметим, иногда это невозможно в принципе.
Почему?
Потому что, возможно, у нас в хождении этих строчек будет больше.
Ну, например, если строчки будут там одинаковые, например.
Или даже, если не одинаковые, но, например, если это будут строчки A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A.
И текст T такой, состоит естественно из ничь той перезбуковой A.
Тогда и хождение тут дошешать даже больше.
Поэтому да, то есть это их всегда достижило, но можно сделать так, можно сделать так, написать такую идеальную ассимпточку, размер ответа.
Ну, например, мы говорим, что размер ответа может быть сильно большой, поэтому мы говорим, что идеально, но меньше, что мы точно не сможем обойти.
Это точно нам потребуется от стока времени, чтобы хотя бы считать данные, и от ответа для того, чтобы их хотя бы куда-то там написать или вернуть.
Ну, дальше, конечно, это может зависеть от формата ответа, потому что иногда, на самом деле, размер ответа можно ограничить.
В худшем случае размер ответа это, конечно, t умножить на k, правда? Но это в совсем худшем случае, это когда все строчки из одной буквы состоят, а тут тексты из этой буквы тоже состоят, правда?
Вот. А теперь давайте себе представим. Ну, то есть, на самом деле, без ограничения особого общности, но с большим приятностью мы будем считать, что все эти строчки попарно, допустим, различны.
Ну, действительно, если там выяснилось, если там, например, в процессе выяснилось, что какие-то строчки две там совпадают, то для них вхождения будут одни и те же, тогда мы можем сказать, что когда будем выводить ответ, что для вот этой, вот этой, вот этой они одинаковы, поэтому вхождения для них вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-вот-
оказывается, что, на самом деле, с помощью этого, на самом деле, можно лучше оценить, на самом деле, даже ответ, то есть ответ уже даже не совсем t умножить на k, хотя, конечно, ну, то есть, те теоретически может быть, что тут все эти строчки с одной буквы только теперь разные, а в t там поровну всех примеров, как керс писается, но правда, тогда это будет означать, что суммарное число вхождений всех строчек не более чем t, правда?
Это может быть t плюс, ну, типа t плюс t, 72 плюс t, да, и плюс t минус k плюс 1.
Ну, можно.
Ну, если это a, a, a, a, a, a, ну, в общем, то призашек все разные.
Да, может, может. Но тут, да.
И это все равно t от...
Да, то есть t у нас на k все еще может быть, но, тем не менее, с другой стороны, тогда мы обнаружим, что при этом k не может быть сильно большим.
Потому что, например, если мы 100 тысяч таких строчек, мы сделать не можем, потому что тогда у нас количество символов будет там 100 тысяч в квадрате, ладно, пополам, но все равно многовато.
Но, на самом деле, оказывается, количество вхождений можно оценить и лучшим способом.
Смотрите.
Давайте начнем с того, что давайте рассмотрим случаи, когда длины всех s и t одинаковые и равны a.
Вот давайте себе представим, что у нас все эти строчки абсолютно одинаковые длины и при этом поопарно различны.
Что тогда?
Тогда ответ не больше, чем длина t.
Тогда заметим, что вхождений не более, чем даже...
То есть размер ответа не более, чем, я бы даже сказал, длина t минус l плюс 1, даже, если уж совсем дирократизироваться.
Потому что любая у нас ровно столько вхождений, то есть ровно столько подстрок длины l, и каждая из них может совпадать не более, чем с одной из них.
Понимаете, да?
Понимаете?
Вот, понимаете?
Вот.
И тогда получается, да, то есть если бы у нас был этот черный ящик, который для любых подстрок, любых заданных строк говорил, нам совпадают эти подстроки или нет, то мы, в принципе, за линию бы все и нашли, правда?
То есть вычислили бы, то есть запихнули бы эти строки в какой-нибудь там, их хэши, например, в анорберет мап какой-нибудь.
И, соответственно, в том, для каждой подстроки вычитали бы хэш, лазили бы в анорберет мап, мы, условно, как-то так бы делали.
Да, вот, мы не знаем, что такое хэши, но виктуально, как-то есть у нас это мистическое число.
Вот, но получается, да, если все строки одинаковые, то вхождений от t.
Вхождений действительно, то размер ответа не более чем t минус l плюс 1.
Но отсюда, на самом деле, возникает естественный момент.
Смотрите, если у нас все строки разные, то давайте сделаем вот что.
Давайте эти строки разделим на блоки, состоящие из строчек одинаковой длины.
l1, l2 и так далее.
Ну, допустим, l, и тут вот какой-нибудь там.
То есть тут длина, ладно, тут будет l1 длина, тут будет l2 длина, вот так вообще.
И тут будет длина lb.
Чуть не написал Бубин, но не важно.
Да, Бубин не надо, мы его предъявлять сейчас не будем, поэтому лучше b.
Вправивается.
То есть, заметим, что для каждого блока у нас размер ответа не превосходит t.
Следовательно, размер ответа суммальный не превосходит t на количество блоков.
То есть, сколько различных длин среди этого множества строк s может быть?
Ну, конечно, теоретически их сколько различных длин может быть?
До вплоть до k, логично, да?
Но есть еще один важный параметр.
Давайте введем такой параметр, как len.
Давайте так, даже sum len.
Это будет просто сумма длин всех строк.
И тогда возникает мистическая утверждение,
что количество различных длин вот этих вот строчек не превосходит...
чего?
Вот как можно было бы количество блоков оценить, исходя из суммлена?
Словно корень.
Но у нас, если у нас b разных длин, то сумма хотя бы b на b кустынь пополам.
Ну, на самом деле, да.
Здесь как урагин из двух суммлен.
Да, то есть, на самом деле, действительно, просто доказательства.
То есть, sum len, оно равно, оно больше либо равно l1 плюс l2 плюс и так далее, плюс lb.
Ну, я просто, давайте предположим, что есть каждого блока, только одну строчку оставлю, да?
Это больше либо равно, если мы, например, скажем, что l1 меньше, l2 меньше, l3 меньше и так далее,
то тогда это, можно сказать, что это больше либо равно, чем 1 плюс 2 плюс 3 плюс и так далее, плюс b.
Это равно, как известно, b на b плюс 1 пополам.
И это даже добьем больше либо равно b квадрата.
Поэтому здесь я могу даже практически точную оценку написать.
b меньше либо равно корень из 2 умножить на суммлен.
Вообще говоря, это уже неплохие новости.
Потому что ведь у нас же всегда в задачах в важном ограничении объявляется не только, что строчек может быть много,
но мы знаем, что их суммарная длина не сильно большая.
У нас не просто строчек не больше миллиона, но и суммарная длина не превосходится даже миллиона, а то и меньше бывает.
А теперь у нас получается гарантия, что на самом деле количество блоков у нас не превосходит, оказывается, корни из этого миллиона.
Ну ладно, корни из двух миллионов.
И размер ответа получается, то есть из этого следует автоматически.
То есть размер ответа получается не превосходит модуль t на корень из суммлен, из этой суммарной длины.
Между прочим, если ваша задача найти все обхождения всех строчек и там ограничения какие-то поменьше, по 100 тысяч,
то, между прочим, у вас теперь получается хешами Anode Red Map.
Нет, на полном серьезе.
Более того, то есть на самом деле часто бывают там задачи, где требуется найти всех обхождений всех строк, а потом там подвянка.
Более того, еще бывает подвянка, даже дело не в кое-как.
Просто длинны всех строк s не превосходят 80 или даже хуже 30.
И тогда оказывается, что никаких умных алгоритмов писать не надо.
А надо просто 30 раз побегать с Anode Red Map, ну в общем-то все.
Вы знаете, что самое смешное? Если строки Биларды, то это решение будет еще и точным.
Ну, в том плане, что хеши будут однозначно определять строчку.
Вот, это самое смешное.
Да, 26-30 уже там, наверное, в лог-в-лог не влезет, поэтому там уже будет хеши.
Но там уже фар-фар-фар.
Вот.
Ну, тем не менее, вы знаете, что количество обхождений в целом не такое большое, как казалось бы,
но, конечно, хотелось бы как-то его успешно искать.
Как же это дело?
Но для того, чтобы сделать что-то продвинутое и все-таки от хешей избавиться,
нам потребуется умная структура данных BOR.
Что такое BOR? Ну, как я уже сказал.
Значит, BOR, то есть вот так и будем писать.
BOR от строчек S1, S2, и так далее, SK.
Ну, или по-английски она вот так вот называется.
Вы спрашиваете, почему?
Вот.
Что это такое?
Ну, я мог бы тут написать формальный текст, что BOR от CUT строчек
это минимальный по количеству вершин детерминированный конечный автомат,
в каждую вершину которого входит ровно одно ребро.
Ну, вот ровно одно ребро, а в стартовую вершину не входит никто.
И который принимает эти строки по парик.
Вот. Я мог бы сказать такое формальное определение, но я не буду этого делать.
Потому что вместо этого я просто продемонстрирую, что это такое, как с этим работать.
Вот, например, допустим, у меня строчки там A-A-A, A-B-A, B, B-B-B-B, A-B.
Ну, можно еще.
А в ад какой-нибудь.
Ну, ладно. Если еще будут строки, потом придумаем.
Значит, идея будет такая.
Мы добавляем эти строчки в BOR по очереди.
BOR это будет такое дерево, вот у него есть стартовая вершина.
Чтобы добавить в строчку A-A-A, все, что мы сделаем,
это вот построим три таких новых вершины и на каждом ребре напишем по букве A.
Да, BOR это у нас автомат.
И тут, конечно, поставим крестик вздав того, что да, вершины терминальные.
Что еще можно сделать?
Если мы говорим A-B-A,
тогда замечаем следующее. Мы пытаемся также добавить, но видим, что по первой букве мы проходимся.
А вот по букве B перехода нет, поэтому мы его дополнительно строим.
И тут уже тоже достраиваем.
Да, теперь если мы хотим добавить строку B-B-B-B,
допустим, вот B-B-B-B, давайте вот эту добавили,
давайте теперь вот эту вот будем, с этой начнем.
Тогда действительно мы тут просто ответляемся, строим вот так, вот так, вот так.
А если мы хотим добавить строку B, то мы пытаемся пройти по символу B.
Видим, что, ой, он уже был, и крестик.
То есть видим так, что крестик не обязан быть листом,
ну и как бы у нас есть крестик, который является листом, тогда и только тогда,
когда какая-то из строк является префиксом какой-то быстрый писем.
Ну и если мы хотим добавить A-B, то получается, видим,
по букве A есть проход, по букве B есть проход,
тут по букве B нет прохода, поэтому A ответ линейцы.
А если мы хотим A-B-B-A, то A-B-B-A по букве T нет прохода,
добавляем и ставим крестик.
Вот что такое B.
Понятная технология.
Ну и здесь отметим, то есть реализовать это несложно,
но единственное, оговоримся, что в зависимости от ситуации применяются две разные статистики.
То есть есть одна вот маленькая деталь в реализации,
которая может в зависимости от алфавита быть по-разному.
Потому что как хранить вершины перехода?
Ну и как вы вставаете, собственно, как хранить переходы?
Ну точнее мапы либо массивы.
Да, то есть вы можете хранить либо, то есть как бы переходы вы храните,
то есть либо в мапе, тогда время работы называется будет O от логарифа,
собственно, количество переходов, да?
То есть каждый переход вы будете искать за логарифом.
То есть каждый переход вы будете искать за логарифом.
Ну по памяти, там память, получается, что в каждой вершине на этих переходах
они памяти O от, собственно, этого размера, ну O до плюса B.
Ну потому что если это будет пустота, то память на то, что типа этот мап вообще есть, вам придется хранить.
Вот, но это если вы переходы храните в мапе.
Можно их хранить в массивчике.
Какая-то странная оценка, в смысле, вот, то, что мы сейчас сказали.
Мне кажется, полезно сказать, что тогда суммарная память это O от сумма длинн строк,
а время работы можно оценить как логариф сигма.
Ну, можно, но мы сейчас точно, мы сейчас тут как бы точность напишем,
а потом скажем, почему это равно в сумме.
Значит, для массива тогда в каждой вершине придется время работы с каждым переходом честно O от 1,
но зато памяти нам потребуется в точности O от размера алфавита,
потому что для каждого флита нам придется хранить в объятном виде ячейку памяти,
который будет хранить, куда ведет переход или там прикрестик, если это у перехода нет.
Вот, ну, что, значит, что тут приоритетнее?
То есть выбор на самом деле неоднозначен. Почему?
Потому что, с одной стороны, здесь вы будете с каждым переходом работать O от 1,
извините, но зато по памяти вам придется в каждой вершине хранить O от альфа-памяти.
И при инициализации, кстати, вам придется O от альфа-времени тратить на то, чтобы там весь массив заполнить, чем надо.
Вот.
Вот. Но к чему это нас приводит? Приводит нас это вот к чему.
Но с другой стороны, если мы будем использовать мапчик,
то тогда суммарный размер памяти, который у нас будет,
он будет в точности O от количества вершин плюс количество переходов между ими.
А количество переходов, кстати, равно количеству вершин минус 1.
То есть получится, что по памяти вот в такой версии она от алфавита зависеть не будет.
Но за то, когда в каждой вершине искать переход, вы будете за логарифом реально сколько там любит.
То есть поэтому тут надо всегда выбирать.
То есть, конечно же, если алфавит мелкий, у вас там, скажем, 2, 4, 5, ну 2 там бинарные алфавиты или что-нибудь еще в этом роде,
то, конечно, вот это однозначно лучше становится.
Но если у вас строчки тоже там состоят из чисел на 10 в 9, то, конечно, придется делать мапчик тут уже без вариантов.
Ну а если а равно 26, ну на самом деле там по ситуации.
И так и так бывает, это будет там плюс-минус одинаково работать.
Ну дальше, конечно, от того, что вы конкретно делаете с этим двором.
То есть, да, есть вот такая маленькая действительно деталь.
Ну в целом, я думаю, как это реализовывать, думаю, вопросов не вызывает.
Ну можете реализовать там.
Ну тоже, как всегда, там есть деталь.
Вы там залодите массив вершин или там новую вершину через new указатель вызываете.
Ну, скорее всего, да, правильный вариант.
Это называется, да, вы делаете, вызываете через указатель new,
ну можете подсовывать свой аллокатор, в котором этот огромный буфер вы там себе заранее прописали, да.
Ну, такие же детали мы прописывать не будем, они тут слишком просты.
Вот.
Значит, значит, действительно, мы очень легко за линейное время можем действительно из строчек S такой бор составить.
Как же мы теперь с помощью этого бора будем искать подстроки стратегии?
Как же мы это будем делать?
А вот как же.
Но дело в том, что то, что я сейчас опишу, это на самом деле будет обобщение алгоритма кнута-мориса-правда.
То есть на самом деле, да, по большому счету мы сейчас возьмем алгоритм кнута-мориса-правда,
чипу из префикс-функции, просто обобщим его навод.
Казалось бы, как?
А вот не случайно мы пытались, мы в прошлый раз, в прошлый раз.
В позапрошлый момент.
Сейчас, стоп.
А, в позапрошлый, потому что мы в позапрошлый раз префикс-функцию обсуждали в конце, после последней геометрической темы.
В позапрошлый раз.
Значит, мы с вами обсуждали префикс-функцию и пытались избегать этого понятия, что давайте P$T и посчитаем префикс-функцию.
Мы вместо этого говорили другое. Давайте я кратко напомню, что конкретно.
А мы, собственно, сегодня эту схему, собственно, упоминали.
Значит, смотрите.
То есть жила была строка P.
И мы пытаемся с помощью ее пройти по тексту T.
Как мы это делаем?
Как мы это делаем?
Делаем это вот как.
Мы пытаемся, смотрите, что мы делаем.
Мы пытаемся сначала, начать сначала P, T и пройти.
Так, давайте я, опять, коричневый маркер возьму и скажу.
Я пытаюсь тут найти какой-то вот префикс, который совпадает с префиксом строки P.
Искали, искали, искали.
Опа, остановились.
Ну, в идеале, потому что строка P закончилась, но чаще всего скорее потому, что у нас тут.
Чим было не совпадает.
Что мы в этом случае делаем?
Мы пытаемся найти максимальный, так мы и собственный суффикс у этой строки, который также является еще префиксом строки P.
Понимаете, да?
Вот, находим его и пытаемся тоже его продлять, продлять, продлять, продлять.
Вот, может быть, нам даже и повезло.
Здесь мы тоже его берем и так пытаемся продлять.
То есть вот так был устроен у нас алгоритм, помните, да?
Все для того, чтобы определить, насколько конкретно тут, как тут вот этот суффикс заберем-заберем, мы фактически применяли примерно то же самое, только там P, так сказать, против самого себя.
Это у нас называлась префикс-функция, помните, да?
Было дело.
Было дело.
Так вот, мы попытаемся, попытаемся проделать абсолютно ту же самую процедуру.
Только разница будет в том, что у нас теперь не одна строка P, обратите внимание, а несколько строк P.
У нас теперь несколько строк.
Вот у нас есть P1, есть, допустим, P2, есть, как они еще, P3, короче.
Есть вообще супер длинное P4, что-нибудь средненькое P5, ну и так далее.
И нам сейчас будет интересно вот что.
Мы будем на уровне прохода, смотрите, пытаться сделать следующее.
Смотрите, уровень идеи.
Я хочу идти-идти-идти-идти и искать максимальный префикс строки T, который по совместительству является префиксом хотя бы одной из строчек.
Понимаете, да?
Хотя бы одной.
Легче всего, конечно, это делать, вот сам по себе этот первый проход делать, конечно же вборе из этих строчек.
Потому что нам не нужно теперь перебирать все строчки, а просто, когда у нас почти все строки есть, то мы их будем вбирать.
Конечно же вборе из этих строчек.
Потому что нам не нужно теперь перебирать все строчки, а просто, когда у нас идем по буквам и каждый момент времени проверяем, мы из очередной вершины можем по этой букве пройти?
И типа если да, то вот типа проходим.
Каждое время находимся в какой-то вершине вбора.
Ну, кстати, заметим, что вбор еще на самом деле можно неофициально называть префиксное дерево.
Или дерево префиксов.
Ибо по большому счету, да, легко заметить, что здесь каждая вершина в точности соответствует префикс какой-нибудь строте, который является префиксом хотя бы кого-нибудь из них.
Может даже нескольких.
Вот.
То есть с помощью бора это было бы действительно такой проход легко делать.
Ну вот мы остановились.
Что дальше делать?
Ну дальше технология у нас могла бы звучать так.
Ну то есть теперь нам хочется найти минимальный собственный суффикс, вообще максимальный собственный суффикс, который все еще является чьим-то префиксом.
Может уже другой строки, правда.
Или несколько.
И пытаемся его произвести.
То есть вот такой вот процесс.
То есть пока, да, немножко абстрактный процесс.
То есть мы пытаемся находить в некотором роде такие вот самые длинные вхождения.
То есть в переводе бора получается так.
Мы для каждой позиции T, вот другая интерпретация.
Смотрите, мы для каждой позиции T пытаемся найти самую длинную подстроку, которая заканчивается в этой позиции и которая совпадает с префиксом хоть кого-нибудь.
Понятно, да?
То есть заметим, что вот этот процесс на самом деле именно этим по большому счету и занимается, правда?
Потому что...
Ну потому что заметим, что тут достаточно очевидно, что...
Ну да, тут...
Достаточно очевидно, что когда мы впервые достигли позиции И, то, собственно, то, с чем мы ее достигли, собственно, вот этим вот максимально возможным префиксом, который в этой позиции заканчивается, и является. Согласны?
Да нет, наверное.
Понятно, о чем я говорю.
Хорошо.
Вот, отлично.
Как же это реализовать?
Как минимум сам проход.
Но я утверждаю, что, если мы опять верим в хэшмапы, то я утверждаю, что мы это легко сделаем за... ну, сначала за построение хэшмапов за отсумвлена, а потом вот этим проходом за отты.
Почему так?
Потому что давайте построим массив из... называется сумлен хэшмапов.
Ну вот.
Прямо так и пишем.
Прямо так и пишем.
Так сказать, из хэша в вершину.
Я даже так неформально допишу.
Ладно, тут даже не сумлен уже, а максимально.
Где в maps.it для хэша...
Да ладно, я что-то незаметно предположил, что все верят, все знают, что такое хэш.
Ну да, пусть знают.
Ну ладно, чем их оттаить? Большинство слушателей, видимо, это знают.
А если не знаете, то просто поверим, что мы можем по каждой страте и по каждому ее префиксованию, по каждой пазике вычислять какое-то мистическое число, про которое верить, что для двух строк числа совпадает тогда и только тогда, когда у них сами числа совпадают.
Ну почти так оно и есть, да.
Дальше начинается вероятность на анализ, поэтому ровно поэтому мы конкретное обсуждение этого откладываем на потом.
Ну вот, для хэша, для хэшей префиксов строк, там, s1, s2 и так далее, sk длины и...
...сохраним соответствующие вершины в Боре.
Ну, например, можно хранить вершину в Боре, можно хранить, конечно, там координату, то есть типа из какой строки это взялось, ну вот это все, пожалуйста, на ваш...
Ну там, из какой строки тут сложно, там надо выбирать, потому что, скорее всего, как несложно видеть из сбора, там, например, конфетный префикс, там может оказаться префиксом нескольких строчек, и какую из них выбирать не всегда понятно.
Ну, дальше ладно, это уже технический вопрос, на самом деле, в зависимости от того, что вам там конфетного алгоритма надо. Ну, например, вот мы будем говорить про вершину в Боре.
Вот. И тогда идея эта окажется очень проста. То есть как этот алгоритм забабахает? Ну, очень просто. Сначала мы смотрим вот этот префикс и говорим, что вот максимальный префикс.
Тогда мы знаем, что ответы, то есть вот эти суффиксы тут мы нашли. Дальше не получается. Тогда получается, раз правый указатель сдвинуть нельзя, надо сдвинуть левой.
Мы проверяем. Вот эта строчка является чьим-нибудь префиксом. Если да, то именно ее мы и пытаемся продолжать. Если нет, то, собственно, бесполезно.
Проверяем, проверяем, то есть двигаем этот указатель, и получается, что давайте нашли максимальный, максимальный собственный суффикс, который еще чьим-то префиксом является, и пытаемся двигать этот указатель.
Да, может не получиться. Тогда мы продолжаем двигать левый указатель, и так двигаем до тех пор, пока, наконец, не получится.
И тогда, когда у нас получится, мы двигаем, двигаем, двигаем. Вот. И тогда для каждого из этого блока мы тоже нашли вот этот вот максимальную подстройку заражения этой позиции, имеющую чьим-то префикс.
То есть сам по себе этот проход, очевидно, работает за О от модуль Т, потому что два указатель, правда? Понимаете, да?
Ну и, конечно же, построение вот этих мапов будет работать за О от суммеля.
Вот. Ну, как вы можете заметить, пока этот проход является, конечно же, абстрактным, просто сферическим проходом вакуума.
Потому что, да, мы это сделали, мы это сделали за линию. Зачем? Пока непонятно.
Ну, давайте попробуем. Опять же, зачем? Потому что мы это придумали из префикс-функции.
Потому что, когда... Вы что, смотрите, мы изначально, когда искали подстройку П в скротете АБДУ, мы делали ровно то же самое. Почему?
Потому что мы надеялись на то, что если в какой-то позиции вот эта строка софтует, то это будет работать, то это будет работать.
Ну вот, при этом более того, там оказывалось очень круто, что если мы нашли тут, если это строка П в скротете АБДУ, мы делали ровно то же самое.
Почему? Потому что мы надеялись на то, что если в какой-то позиции вот эта строка совпала прям со всей строкой П, то это означает, что ура, мы нашли вхождение строки П, правда?
Вот, согласны? Вот прям взяли и нашли прям всю строку П.
Потому что вот там оказывалось очень круто, что если мы нашли тут, если эта строка совпала с строкой П, значит это и есть вхождение, а если тут нашлось не... П не нашлось, значит тут вхождение не заканчивается.
И это давало нам возможность найти все вхождения. Было дело.
Но в чем тут тогда? Тогда, раз вы знаете, тогда скажите мне, в чем проблема?
Ведь казалось бы, а что нам сейчас мешает просто сказать, что если мы нашли вот префикс, который совпадает со строчкой, то мы тогда торжественно заявляем, что мы в этом месте нашли вхождение, нашли вхождение, короче, этой строке.
А если это не какая-то строчка, ну и не судьба. Ну, значит мы не нашли тут никакого вхождения.
И тогда получается, вот мы, по крайней мере хоть с мапчиками, но нашли прям за линиями, прям за линию, все хорошо.
Вот что нам мешает тогда вместо того, чтобы там эти какие-то там суффиксные ссылки изобретать, там какие-то, какой-то мексис, вот эту всю, вместо этого так честно и сказать, что вот давайте вот лучше хлешами сделаем вот такой очень простой проход и найдем все вхождение. Что нам мешает?
Значит мы не найдем все вхождение. А чего?
Может бы попустить просто вхождение какой-то мелкой строки.
Ну, понятно, а вот пусть Александр скажет.
Александр скажет.
Когда мы возвращаемся к второму вхождению, вот мы нашли, получается, ну, все-все?
Да.
И дальше мы двигаемся вновь вправо, поэтому у нас были какие-то до него...
Нет.
Но если мы тут двигали левым указателем и нашли какую-то строчку, которая являлась чьим-то, то есть которая совпадала с одной из строчек, то мы бы тут остановились.
То есть мы бы тут остановились и увидели бы, что в вхождении есть.
Здравствуйте. Мы же в втором указателе двигаемся тоже вновь вправо.
Двигаемся. Но у нас же был момент, когда эти два указателя вот тут стояли.
У нас был внутричный вовсю строчный путь.
Внутри. Что значит внутричный?
То есть на пути в Вольне от начала, ну, было несколько моментов.
Да.
Да, действительно.
Условно говоря, может произойти ситуация, когда строчка, которая здесь в воле находится как ABB, но по факту мы заметим, что мы говорим ABB и ничего не произошло.
Она даже в этом воле.
Мы заметим, что в этот момент у нас есть вхождение строки B, который заканчивается, а мы его пропустили.
Да, вот такая подлянка, оказывается.
То есть заключается она в том, что, оказывается, что да, раньше мы могли утверждать, что либо у нас префикс длины P, и тогда он совпадается с такой претехождением, а если он меньше, значит тут никаких вхождений нет.
А тут, оказывается, что мы гарантировать пока можем только одно, что у нас в этой позиции не заканчиваются вхождения строчек, у которых длина больше, чем вот это.
А вот может ли быть, что она меньше?
Ну, вполне может.
Да.
Но есть и небольшие хорошие новости.
Хорошие новости заключаются в том, что, на самом деле, заметим, что это не во всех случаях происходит.
А есть на самом деле один широкий такой случай, когда мы ищем подстройки в строке, когда на самом деле вот такого не бывает.
Этот случай очень простой.
Когда никакое P i не под строка P j.
Вот, заметим следующее.
То есть, если мы хотим, чтобы никакая подстрока не была собственным суффиксом какого-то префикса какой-то другой строки,
то по большому счету мы практически требуем, чтобы никакая строка не была под строкой P j.
Ну ладно, здесь, конечно, мы еще, чтобы вот этого избежать, мы, конечно, еще требуем, чтобы она была не просто под строкой, а там еще, чтобы она была под строкой, но не префиксом.
Но это уже, до таких деталей мы копать не будем.
Пока заметим следующее, что если ни одна строка P не является под строкой чего-нибудь еще, то вот этот алгоритм прекрасно работает.
То есть, если у вас там откуда-то взялась гарантия, что никто ни чьи под строкой не является, то поздравляю вот весь алгоритм.
Кстати, с попутным доказательством того, что если ни одна строка не является под строкой другой, то суммарное количество обхождений у вас не более чем P.
Обратите внимание.
То есть маленькая приятная лена, то есть доказательство практически следует из вот этого алгоритма.
Понятно, да?
Вот так вот, очень приятно получается.
Вот.
Но что же все-таки делать?
Вот как вы думаете, что же нам все-таки делать, если все-таки это условие не выполняется?
Обхождение хочется находить все еще все.
Ну, хотелось бы, чтобы для каждого префикса какой-то строк мы могли понять, какие строки заканчиваются.
Ну, и версию шубка сами.
Ну да.
Ну, идея действительно очень проста.
Ну, во-первых, да, просто хочется для каждого префикса каждой строки, или что-то то же самое для каждой вершины в горе, хочется просто понимать.
Как бы, какие суффиксы этой строки являются еще и какими-то P-шками.
Понятная идея, да?
То есть давайте введем мистическую функцию.
Так, господа, сейчас я введу мистическую функцию.
Мистическая функция.
Так, как бы ее назвать, пока ее лог-суф не назвал?
Я слышал супер-суф, но я не знаю нормально.
Да нет, но у нас же пока нет понятия суффиксы этой строки.
Так, смотри, задача, у нас есть функция, которая по каждому префиксу, ну или по каждой вершине города, если хотите, ставит нам в соответствии, ну, субтитры.
По каждому префиксу, ну или по каждой вершине города, если хотите, ставит нам в соответствии максимальный суффикс этого префикса, который является строкой.
Ну, в лице номера, например, этой строки.
Так и назовется.
Макс.
Макс-суффикс.
Ин-пэ.
Будет у нас такая функция из множества вершин в горе в числа от одного дока.
Ну, во-первых, смотрите, ладно, давайте, во-первых, давайте пришло время, наверное, ввести так в горе, даже в горе.
Значит, давайте введем понятие пэс.
От в и, соответственно, там альфа звездочка.
Это будет так, это строчка, это будет называться путевая метка.
Да, это не определение, это название.
А определение следующее.
То есть, по какой строке мы должны пойти с горе, чтобы перейти в вершину.
Ну, то есть, например, путевая метка этой вершины пустая, путевая метка этой вершины а, путевая метка этой вершины аб, путевая метка этой вершины Kentucky, у этой a, у этой ab.
Давайте будем называть это путевой меткой, то есть при dioxide ,we ghost-б 녘ат值.
Давайте будем называть это путевой меткой, но это достаточно стандартное определение.
А вот нам еще и в суффиксных деревьях тоже предъявится. Давайте называть это путевой
меткой и будем называть это PS от V. Так вот. Так вот. Максимальный суффикс...
PS, так вот, значит, максимальный суффикс PS от V. Это, смотрите, это такое число и...
Смотрите, что, значит, пишем. На этот раз к черным пишем. PIT, суффикс, не собственный, а просто, значит...
Ну вот. Соответственно, суффикс PS от V. Понятно, да?
То есть, суффикс PS от V, и при этом, ну, варианта, что может быть есть, как-то правильно.
И модуль PIT равен максимум. То есть, как можно больше.
У нас же строки были S и T, кажется. Когда они стали PIT?
Ну да. Классика. Ну да, правильно. Это называется, ты приходишь, ты написал детективный роман,
приходишь давать издательство, и на редакторе тебе говорят, у вас как главного героя зовут?
Герои?
О чем в середине романовой нюры откликается?
Ну вот. Ладно, давайте тут тоже.
Хорошо. Вот. Ладно. Ну тут, на самом деле, еще сюда придется прибавить.
Ну вот. Или, ну, допустим, я не знаю, ну там, либо 0, либо минус 1, давайте. Есть ли такого ангела?
Ну, потому что может же так случиться, что у претикса нету суффиксов, которые совпадают со всей строкой, правда?
Так, хотя, хотя не знаю, может сейчас, да, просто кажется, что еще много работы,
а может сейчас такими вот мотивациями сейчас раз-раз и неожиданно победим.
Потому что, что нам надо? Предположим, мы вот с небес по факсу откуда-то это выкопали.
Я не знаю, с небес по факсу.
Тогда чего нам не хватает до полного счастья?
Тогда, получается, в каждой позиции мы, ну, тогда мы, конечно, у нас получится лучше в том плане,
что в каждой позиции мы с помощью этой функции получим возможность находить, вот это вот теперь синеньким будем назначать,
еще самую дно, получается самую длинную строчку, которая заканчивается в этой позиции и является, и совпадает с какой-то строчкой.
И прыгая по таким исходкам?
По каким? Куда прыгать?
Обратите внимание, нам пока не по чему прыгать. Вот чем проблема.
Видите, мы пока эту функцию так определили, что пока не по чему прыгать.
Неприятно, конечно.
То есть, но, конечно, заметим, что все следующие строки по длине 2, 3, 4, 5, они зависят только от самой первой, правда?
Понимаете, да?
Поэтому здесь можно ввести другую функцию.
Здесь можно ввести функцию max another.
P
S
суффикс
Max another.
Суффикс от чего?
От эсфитова.
Эта функция у нас будет уже от 1, 2 и так далее к.
Вот здесь нам придется еще минус 1 добавить.
А лучше дайте, раз уж мы так пишем, лучше еще будет у нас слово out.
И тут тоже будет.
Out и 1, 2, 3, 4.
Значит так, начало-то нормальное, то есть каждое это сопоставляем либо out, либо 1, 2 и так далее.
Понятно, да?
И тогда определение из него будет такое.
Ну вот.
Даже правильный на самом деле, max правильный на самом деле черный мы будем вводить, потому что это чисто черная функция на самом деле.
Да, правильно вот так писать.
Так.
И это такое.
J
что, ну соответственно.
Значит QJ
собственный.
Так, слово собственный не пугает.
Ну да, согласен, согласен.
Ой, тогда тут надо S ставить.
И тут, кстати.
Господи.
Ну п же, ну паттерны же мы ищем.
Господи, ну ладно.
Ой, вот так вот пик кто-то ввел, а теперь везде двойки.
Ну вот тут тоже самое.
Ладно, слово собственный это пугает?
Нет?
На всякий случай, собственный это означает не совпадать с самой строкой.
И соответственно, модуль без житого, конечно, должен быть максимальным.
Ну или, или alt.
Ну понятно, если там бла-бла-бла, я уже допишу это не буду.
Так, заметим следующее.
Что если у нас помимо вот этих мапчиков, если мы верим в эти мапчики и у нас откуда-то взялись вот эти строки.
Откуда-то.
То что мы делаем?
То что мы делаем?
То тогда получается, что мы, я тогда утверждаю, что мы умеем решать задачу за о от сумлен плюс т плюс размер ответа.
Потому что мы теперь умеем, получается самую, в каждой позиции мы теперь по префиксу вот этому умеем найти самую длинную строчку, самую длинную эску, которая тут заканчивается.
По ней найти самую длинную вторую, по второй самую длинную третью, четвертую, пятую и так далее.
Просто уже прибираемся в айли компаунт, max, another, s, a supers.
И вот этот перебор делается за суммарно о от ans, так сказать, it.
То есть сколько, от размера, количества вхождений, которые заканчиваются в it позиции.
Вот, но для этого, правда, нам нужна маленькая вещь.
Нам нужна, чтобы эти функции у нас откуда-то здесь.
Откуда нам их взять?
Ну давайте, ну откуда нам их взять?
Не считай себя.
Ну, на все, ладно, начнем с халявы.
На самом деле, вот эту функцию очень легко посчитать, причем вообще без хешей.
Ну, ее, собственно, через max suffix можно считать, если найти, какову позицию ворзера,
строка a, s.
Не совсем, понимаете, тут не совсем.
Тут есть реальность, через max suffix ее посчитать нельзя,
потому что, если вы будете вызывать max suffix, а для шины, которые соответствуют всей строке,
то max suffix перелет саму себя.
Так что нет, если у вас тут можно было сказать, что давайте напишем max second suffix ns,
тогда пожалуйста.
Поэтому пока здесь, то на самом деле, заметим, что эту функцию вообще легко считать.
Знаете почему?
Потому что, на самом деле, очень легко, во-первых, тут построить борт на развернутой строчке.
Потому что, если мы развернем строчку, то, как бы, то, кто был с суффиксом, станет префиксом.
Поэтому, по большому счету, вы развернете строчки,
и для каждой строки вам нужно будет найти там самую длинную строчку,
то есть самый глубокий, самый близкий к концу, но не совпадающий с ним крестик, по большому счету.
Не сильно страшно будет, правда?
Или страшно будет.
Так что получается, max ns suffix вы, конечно, найдете.
А вот max suffix ns, вот тут уже сложнее.
Но с другой стороны, на самом деле, но на самом деле, это не все функции, которые нам потребуются.
Потому что у нас параллель, да, возникнет.
Ну, хотя вот можно подумать.
Хотя нет, давайте подумаем.
Если мы верим в хэши.
Вот.
Вот.
Если мы верим в хэши.
Как вы думаете, нельзя ли с помощью ситровых хэшей насчитать вот эту функцию?
Ну, сходу непонятно, почему можно.
А на самом деле, аналогичный притикс функции.
Смотрите, ведь идея такая.
Вбор можно покрыть практически к путями.
Согласны?
Давайте рассмотрим в каждой из этих путей.
В каждой из этих путей.
В каждой из этих путей.
Давайте рассмотрим в каждой из этих путей.
Пусть вот этот путь соответствует строке print.
Тогда я утверждаю, как мы тогда будем искать.
Ну вот.
Вот.
Казалось бы, как мы хотели бы искать все...
Вот для каждого префикса у нее мы хотим найти как бы в каждой позиции как бы самую длинную заканчивающуюся, да?
Как нам это сделать?
А сделать?
Ну там же.
Давайте просто, опять же, идти и набирать префикс, префикс, префикс, префикс.
Вот.
Потом там двумя указателями с помощью хэшей понимать, находить префикс, который можно продлить, ну и так далее, и так далее.
Ну, ту же самую схему предъявлять.
Помните, мы в префикс пункции то же самое делали, когда вместо текста подставляли там саму же самую строчку и то же самое делали.
Что нам помешает?
Вот просто аккуратно так проделать и для каждой позиции в каждой строке P прям честно все вхождения других строк и найти.
Что нам помешает?
Так у нас же каждый раз, собственно, ну в общем, левая касса будет нулем, потому что вот на этой путь есть строка одна из эссетов.
Или мы типа без нее как бы рассматриваем.
Без чего?
Ну у нас же путь в боре это строка одна из эссетов.
Да.
А мы как бы говорили, что мы ищем в ней все остальные, кроме нее.
Ну это не важно, потому что мы ее саму только в самом конце найдем, это не проблема.
Так что мы тут автоматически ищем другие строки.
Но у нас все равно может быть проблема, что мы сейчас сняли префикс какой-то, который является префисом другой строки, но за этим у него будет еще одна строка.
Да, да, да. Действительно.
Да, самый длинный префикс, который является, то есть самую длинную подстроку, которая является префисом другой строки мы найти можем.
Но опять же, саму по себе это нам не помогает.
Но с другой стороны заметим, что приятно, заметим, что тогда получается, когда мы проверяем вот этот префикс, мы замечаем, что этот префикс короче.
Поэтому оказывается неожиданная читерская идея.
Давайте это делать все-таки не для каждой строки s отдельно, а давайте пытаться насчитывать этот max-суффикс в порядке bfs.
Вот. То есть смотрите, давайте насчитывать max-суффикс в порядке bfs. То есть сначала здесь, потом здесь, потом здесь, потом здесь, потом здесь, потом здесь, ну и так далее.
Просто bfs, bfs, bfs.
И тогда получается примерно следующая идея. Предположим, мы дошли до какой-то вершины. Мы дошли до какой-то вершины.
Она является, и эта вершина является префиксом какой-то вот строки s. Я тут ее даже вот напишу. Вот.
Вот допустим, вот в этой вершине.
Тогда как мы будем искать самый длинный суффикс?
Как мы будем искать самый длинный суффикс?
Но для этого у нас идея такая. Мы как будто у нас два указателя закончились здесь.
Вот допустим, мы тут самый длинный суффикс вот такой вот нашли. Ну допустим.
То есть самый длинный суффикс, который является еще как бы...
Ну хотя как бы чем он является?
Да, на самом деле да, искать самый длинный префикс, который является префиксом хоть кого-то, нас действительно тут не устраивает.
То есть нам действительно было бы, да, нам было бы интересно немножко другое.
То есть в идеале бы конечно хотелось бы по каждой строке s. и т. прогуливаться и как бы игнорировать и префиксы там соответственно игнорировать другие строки.
Ну вот.
Но конечно получится.
Получится.
Придется официально суффиксные ссылки выводить.
Ну ладно. Жалко.
Нет, это все-таки получится.
Ну ладно, в общем короче говоря, ладно, придется на это все действительно забить, а вместо этого на самом деле пойти, имея в виду все это, вспомнить, что нам для того, чтобы бегать по тексту t, нам потребуется еще кое-что.
А потребуется нам еще вот что.
Когда мы тут бегаем двумя указателями, у нас как бы два варианта. Мы либо правые указатели сдвигаем сюда, либо мы левые указатели куда-то сдвигаем, правда?
А как мы его сдвигаем? Сдвигаем мы его так. То есть вот у нас есть префикс и мы хотим найти следующий, то есть как бы собственный суффикс этого префикса, который тоже каким-то суффиксом является, правда?
И поэтому предлагается собственно честные ввести. То есть на самом деле вместо синих функций мы введем одну красивую рыжую. Мы введем понятие суфф отвалили.
И будем называть это суффиксные ссылки.
Так хотелось так выжить.
И получается тогда следующее. Суфф от v.
Значит да, v не равно root, я сразу скажу.
Это такая вершина u, тоже вершина, такая что ps от u это собственный суффикс, собственный суффикс ps от v.
И соответственно модуль ps от u максимально возможен.
Сразу обращаем внимание на маленькую приятную вещь.
Почему я тут написал, что v не равно root? Потому что для любой вершины эта суффиксная ссылка определена абсолютно корректно.
Как минимум потому что у нас всегда есть корень, потому что пустая строка является собственным суффиксом чьего угодно.
Осторожно.
И тогда получается следующее, что если мы эти собственные ноты, то есть предположим что у нас вот эти суффиксные ссылки в море откуда-то с небес по факсу нам пришли.
Тогда, ну во-первых, вот этот вот процесс, вот этот вот выставказатель, тогда прекрасно делается без мапов.
Но при этом, что нам еще надо? Нам еще нужно max another s суффикс и max, самое главное, max суффикс nss.
Но что такое max суффикс nss по большому счету? Что нам позволяет сделать суффиксная ссылка? Каждому потенциальному префиксу вот этому, да?
Какой-нибудь строки s, то есть что такое суффиксная ссылка? То есть как бы если этот префикс соответствует вершине v, то как бы вот, то тогда второй подлине суффикс в этой позиции, он у нас будет тогда суфот v.
Как найти третье подлине?
Ну да, если мы в этой позиции хотим не тот самый длинный суффикс, который префиксом является, но все.
То есть второй тогда находится как суфф от него, третий как суфф от суфф от него, ну и так далее.
То есть, соответственно, третий мы находим как суфф от суфф и так далее.
И так далее. То есть получается, то есть в море на самом деле тут поиграть вот даже тут можно. Вот например давайте, а вот из вот этой строки ABBA куда у нас отправится суффиксная ссылка? Вот давайте примерно смотрим.
Ну да, потому что смотрите ABBA, BBA в море не представлено, там собственно BA в море не представлено, A в море представлено, ну значит тут суффиксная ссылка вот сюда и отправляется.
А у ABBA куда ссылка проявляется?
Веселее всех у BBA, потому что тут суффиксные ссылки вообще вот так вот все красивенько идут.
Но вообще говоря, легко заметить, что суффиксные ссылки образуют соответственно дерево.
Ну такое дерево суффиксных ссылок с корнем стартовой вершины бора.
Отсюда суффиксная ссылка куда идет?
И что приятно, то есть получается если вы нашли самый длинный, как я сказал, префикс, то вы прогуливаетесь по этому пути в дереве, по предочкам деревя и находите собственно все вершины.
Если у вас этот дерево вам с небес по факсу прислали, то на самом деле max-suffix-nss после этого насчитать становится очень просто.
Ну потому что по большому счету вам вы просто должны скакать по суффиксным ссылкам до тех пор, пока не упретесь в крестик.
А когда вы упретесь в крестик, ну вы сможете просто простой динамик признания посчитать.
Ну просто если у вас суффиксные ссылки есть, то вот это вы теперь тоже за линию от размера бора посчитаете.
Ну да.
Ну что такое max-suffix-nss? То есть вы идете из вершины В по суффиксным ссылкам до тех пор, пока не упретесь либо в корень, либо в крестик, правда?
Остается только насчитать, где этот крестик будет.
Ну тогда у вас два варианта. Либо у вас вершина уже сама крестик, и тогда max-suffix-nss равно V, правда?
Либо она не крестик, тогда вы скачете по суффиксным ссылкам и берете значение уже от нее, правда?
То есть получается такая линиевая динамика, с помощью которой вы для каждой вершины бора, собственно, легко насчитаете max-suffix-ns.
То есть вы по сути продумали рекурсивную формулу для max-suffix-ns?
По сути, да.
То есть давайте я ее даже в этом видео напишу, что max-suffix-nss от V равно, ну, во-первых, alt, если V равно root.
Понятно, да?
Ну, соответственно, сама по всей вершине V, если так сказать, из n от V равно root.
Ну, из n, то есть там понятно, в каждой вершине флажок, типа, да, является ли это, то есть это концом прям целой строки, да или нет?
И max-suffix-nss от, соответственно, теперь suff от V.
Если там V равно root и из n равно false.
То есть намекаем, что, как я сказал, если суффиксные ссылки вам прислали с небес по факсу, то, в общем-то, max-suffix-nss вы теперь элементарно насчитываете, правда?
Ну, а теперь самое интересное. Ну вот.
Ну и более того, на самом деле, практически, после этого вы практически бесплатно вычисляете вот эту черную функцию.
Потому что max-another, вот как теперь по строке, по крестику, посчитать следующий крестик на суффиксном пути, да, по большому счету?
s-suffix
от, допустим, какого-нибудь i равно.
Ну, элементарно. Вы должны взять вершину.
Ну, на самом деле, я вот, сейчас я вот магическую форму достаточно напишу.
То есть она равна, это max-suffix-ns от suffix от V. Ну да.
Да, тут даже случаев нет.
max-suffix-nss от V, так сказать, от s-i.
Где V от s-i это вершина соответствующая этой строке Вора.
Ну ладно, это не совсем правда.
Вот так напишу num-s от этого, потому что вот эта вот вершина, она нам нужен много.
Это есть так, формально придраться.
А, ой, еще наврал. Нам не просто надо эту вершину взять, а еще суффиксную ссылку эти.
Совсем заклинание.
Вот, приятен, в принципе.
Так, я понимаю, это понятно, что это откуда мы это заклинание берем.
Ну, у нас какие-то обозначения вот такие взяли, что...
Ну, тут самое главное, чтобы понимать, откуда они берутся.
Если вы понимаете, откуда они берутся, то там это не проблема.
Вы еще сами ориентируйтесь, что я еще тут забыл.
Ну, то есть, по большому счету, я беру строку s-i-t, я беру, в какой вершине Вора она заканчивается.
Я хочу найти собственный суффикс ее, который тоже какая-то строка.
Что я для этого делаю?
Я беру самый большой собственный суффикс, который является хоть кем-то этой вот по суффиксной ссылке.
То есть, вот это вот V от s-i.
Я прогуливаюсь по суффиксной ссылке.
А потом теперь у нее надо найти ближайший крестик.
Ближайший крестик.
То есть, я иду, иду.
То есть, вот картинка такая.
Иду, иду, вот насажу крестик.
И вот эта вот ссылка maxsuffixnss.
Это она и есть.
Вот ближайший крестик.
Вот.
И, соответственно, потом после этого я беру numessage.
Почему я беру numessage?
Потому что это вершина.
От этой вершины надо понять, какая строка в ней заканчивается.
То есть, таким образом все.
То есть, на самом деле краеугольным камнем теперь становится вопрос, как насчитать суффиксные ссылки.
То есть, если мы научимся насчитывать суффиксные ссылки, то все остальное мы насчитываем практически бесплатно.
Понятно?
Вот.
То есть, насчитываем бесплатно, и там все, собственно, все подходы делаем.
Так.
Вычеркиваем.
Ну, в принципе, у вас есть теоретический выбор.
Как говорится, добьем этот алгоритм и оставим на следующий раз.
Ну, в принципе да.
В общем-то, на самом деле да.
На самом деле к концу мы близки как никогда.
Так.
Ладно, до этого момента вопросы есть?
То есть, я, потому что я сейчас хочу это все стереть и сказать, у меня есть блог, я хочу, наверное, насчитать суффиксные ссылки и все, что я хочу сделать.
Да.
Да.
Ну, ответ простой.
Мы в каждый момент времени говорим, если мы можем сдвинуть правый, мы его двигаем.
В чем не только двигаем, но в этот момент у нас, как бы, получается новая граница, и мы здесь перебираем, собственно, все эти строчки, которые тут нашлись.
Как только мы сдвинули правый указатель, мы тут же по этой позиции перебираем.
Ну, правый указатель у нас по одной позиции.
Как только мы его сдвинули...
Ну, левый... Смотрите, в каждый момент времени у нас происходит следующее.
Ну, смотрите, изначально было так.
То есть у нас изначально, допустим, было так, что вот у нас этот правый указатель стоял здесь, а левый указатель стоял так, что они задавали самый длинный префикс, который оканчивается в этой позиции.
В этот момент мы у этого префикса перебрали все суффиксы и нашли среди них все подстроки.
Теперь мы пытаемся двигать указатели.
Теперь мы говорим, верно ли, что вот этот суффикс можно прямо вот и продлить?
Если можно, то мы бы его и продляли, это был бы самый длинный суффикс, очевидно.
Если нет, значит придется продлить какой-то меньший суффикс.
Берем второй, то есть вот суффиксный суффикс, да?
Можно ли его продлить? Нельзя.
Берем следующий, следующий, до тех пор пока очередной не продлится.
И как только продлится, значит мы нашли самый длинный суффикс, заканчивается здесь, и уже у него мы уже перебираем вот это все.
Вот так это работает.
Причем заметим, что сами все два указателя работают все еще за ОАТ, и, соответственно, а вот эти переборы мы делаем за ОАТАНС, потому что у нас есть уже более продвинутая относительность суффиксов.
Так что все у нас уперлось в то, чтобы надо теперь вместо вот этих мапов, убить эти мапы, и надо теперь по вот этим строчкам для каждой вершины найти ее суффиксную ссылку и сделать это за, ну, хотя бы, ну, тут разные вещи.
Либо за размер бора, либо за суммар длинных строчек.
Дайте мне одно и то же.
Сидел?
Как же это делать?
Так, вот до этого момента вопрос есть, могу стирать?
Хорошо.
И теперь финалочка.
Итак, насчитываем суффиксную ссылку.
Кстати, о тексте Т мы в этом месте вообще забыли.
Итак, как же это делать?
Ну, идея, на самом деле, была, как я уже сказал.
То есть рассмотрим строчку СИ.
Вот нам, например, очень хочется насчитать суффиксные ссылки для всех вершин, которые соответствуют ей.
Понятно, да?
Ну, здесь идея-то будет та же самая.
И получается примерно следующее.
Вот давайте перебирать все эти вершины, и будем их рассмотреть.
Вот давайте перебирать все эти вершины, и в их порядке суффиксную ссылку находить.
То есть находить вот самые длинные.
Вот, допустим, мы для этой вершины нашли самый длинный суффикс.
Собственный суффикс, который является еще и чьим-то префиксом.
Дальше...
Ну, логика-то, в общем-то, дальше тоже те самые два указателя.
То есть мы пытаемся сдвинуть этот указатель и говорить, так, вот это является чьим-то префиксом.
Ну, мы помним, что длиннее тут не будет.
Потому что если у нас вот тут какой-то был суффикс, то и тут был бы суффикс.
Это невозможно, правда?
Поэтому, значит, пытаемся тут, как всегда, двигать указатель.
Если, ну, допустим, пока с помощью хэшей.
Ладно, так и быть, поверим хэши еще пока.
Если у нас есть хэши сообщать, что такого префикса нет, значит, мы сдвигаем этот указатель.
Если такого префикса нет, то сдвигаем.
Сдвигаем.
Ну и так, пока очередной префикс не найдется.
Как только найдется, вот он, суффиксную ссылку есть.
Обратите внимание.
Кстати, с помощью...
Если бы мы еще верили в хэши, то эту суффиксную ссылку получается для каждой стротии сытая.
Мы бы легко за О от ее ины насчитали сбой.
Согласны?
То есть просто по каждой независимой два указателя прибежали и получили себе сбой.
Почему хэши еще раз?
Пока...
Ну, потому что классические два указателя говорят, что мы говорим, так, вот этого префикса нет.
Выпиливаем один символ.
Вот этот префикс есть.
А потом вот этот, вот этот и вот этот.
А теперь...
А теперь стандарт.
Чтобы удалить хэши, мы говорим, что для того, чтобы...
То есть, как всегда, для того, чтобы...
Заметим, что если от этого суффикса отпилить вот этот символ, то получится один из суффиксов, который был в этой позиции.
Правда?
Поэтому получается, что надо перебрать, по большому счету, опять.
Взять не самый длинный, не только самый длинный суффикс в этой вершине, а еще и вот...
Все вот эти вот и перебрать их просто в порядке убывания до тех пор, пока и не найдется один...
Герой, которого можно на этот символ продать.
А как их перебрать?
Суффиксами?
Конечно.
То есть, вместо того, чтобы перебрать лапчиком, мы берем...
Говорим, так, если этот можно продлить на этот символ, значит его и продлеваем.
Если нет, скачем из него, из его вершины по суффиксной ссылке.
Примеряем, можно ли там ее предложить.
Это в более делается.
Итак, скачем, скачем, скачем, ну и так далее.
И тогда получается, ну правда, для этого получается нужно, чтобы мы уже насчитали суффиксные ссылки для всех вот этих вот вершин.
Но заметим, что вот проблема тут маленькая техническая заключается в том, что вот эти вот строки, если брать их как префиксы в поре,
то они не обязательно являются префиксами строки СИТ.
Понимаете, да?
Понимаете?
Понятно, Александр?
Поэтому, то есть, нужно, чтобы они были насчитаны.
Поэтому идея такая.
Вот тут-то мы включаем идею, что, а давайте для всех вершин прям в поре насчитывать суффиксную ссылку, честно, в порядке BFS.
Тогда, конечно, не очень слету понятно, почему это работает за линию, да.
Бывает тогда ошибка, что это работает от размера поры.
Я бы был бы аккуратен.
Я не уверен, что это так.
Потому что я и не уверен, что этот алгоритм реально работает за О от количества вершин в поре.
Но то, что я могу гарантировать, так это то, что этот алгоритм работает за О от суммы всех исследований.
Потому что я могу просто вот этим вот методом просто продемонстрировать, что этот, если рассмотреть прям путь строки СИ,
то тогда она будет обработана за О от длины этой строки.
Но О от размера поры это, кстати, неправда.
Потому что размер поры может быть синтетически меньше, чем все-таки сумма всех строчек,
потому что у них там префиксы могут сильно накладываться.
Понятная идея, да?
Особенно, если там была куча строчек, играются префиксами друг друга.
Хотя, на другой стороне, если одна строка является префиксом другой, то, в общем-то, она тут в этой синтотике ее можно не учитывать.
Потому что она считала для одной строки, и мы, собственно, даем ее префиксам.
Ну, все равно мы же делали, что никакая не будет являться по строкой никакой, но все равно там будет...
У них будет больше-больше общий префикс, из которого они все так же...
Ну да, да, да. И то, правда. Поэтому лучше не надо.
Вот. Но здесь два варианта у нас.
Но здесь, на самом деле, тоже есть два варианта, как реализовывать.
Смотрите.
Вот если реализовать вот так в порядке BFS,
то смотрите, что у вас получится.
С одной стороны, у вас получится все красиво за сумму S,
но недостаток алгоритма будет в том, что когда вы все-таки вспомните про текст T и будете по нему ходить,
у вас, при добавлении каждого символа, что получится?
Получится от единицы амортизированной, правда?
Потому что вам придется по этим суффиксным ссылкам реально скакать, правда?
Но заметим, что и там вам придется скакать по суффиксным ссылкам,
и тут вам, по сути, придется скакать по суффиксным ссылкам, да?
А ведь по большому счету...
Я просто почему не иду?
То есть по большому счету и в этом проходе, и в том проходе у вас опять возникает функция go от vchar,
аналогичная префиксия.
Помните?
Которая говорит, что вы находитесь в вершине и пытаетесь пройти по символу ch.
И вы говорите там, пишем, while v не равно root, да?
While там v не равно root.
Ну, давайте end-end не can go vch,
то, собственно, v равно суфф от v.
И говорим, что, значит, если can go,
то, собственно, vturn go vch,
lza.
Ладно, только аккуратно, тут не go, а go and work, конечно.
И тут, конечно, can go, имеется в виду and work.
Да, надо было и правильно писать, а то...
Ну, это физтех, как у нас говорят, if you want to be ok,
вот аимби шевридей, соответственно, да?
Так известно.
Вот, да, у нас тут немножко и на этом цикле получилось, но что делать?
Ну, иначе можно создать v, на самом деле можно написать...
Вот, то есть, по большому счету, через go можно и вычисления суффиксных ссылок забавахать,
и потом проход по тексту t.
Но по большому счету заметим, что аналогично префикс функции,
это можно привести просто в go от vch.
Правда?
И получится, я сейчас не буду расписывать, но получается...
То есть, здесь вводится то, что я называю автомат аха караси,
по аналогии с автоматом префикс функции.
То есть, у вас будет два варианта.
Если у вас алфавит маленький, то вы можете на самом деле суффиксные ссылки насчитывать тоже,
насчитать их прям как в виде автомата,
и после этого по тексту t хотите, чтобы каждый новый символ будет обрабатываться прям жестко,
прям жестко за о от единицы, ну плюс сколько вхождения вы там даете.
Ну, честно скажем, дальше все зависит от того, какие у вас задачи.
Потому что, например, самое...
Да, у нас получается, что алкаритм работает за линию ввода плюс о от ответа,
но дальше все зависит от того, какие задачи мы решаем.
Ну, например, вот самая тупая задача, например, как тут можно привести,
а давайте мы не будем требовать, например, всех вхождений,
а вместо этого просто вам попроще сказать,
есть ли у вас девочка s, вы сходите, входит ли она в текст t как под строка.
Да или нет?
Вот давайте, вот вам задача.
Ну, можно такое сделать, мы проходим все по строке t, да,
и запоминаем все, в которых мы побывали.
И тогда нужно для каждой s и t проверить, что хотя бы одна вершина ее по дереве была посещена.
Ну, привет, да.
Ну, там, ее по дереве, по суффиксным ссылкам.
Ну, можно так проверить, можно по-другому,
потому что по большому счету мы говорим, что мы как бы,
по идее, для каждой вершины, когда мы прогуливаемся в тексте t,
должны были прогуляться по вот этим вот синим ссылкам,
которые max.suffix.ns, да?
Ну, например.
Или просто прогуляться по всем суффиксным ссылкам и пометить там все крестики, правда?
Так давайте это делать, ну, в конце.
То есть для начала пометим все вершины, в которых мы вообще были,
а потом от листьев коги пойдем, что если мы были в вершине, значит,
и мы в ее родители тоже выйдем, например.
Можно так, можно там про по дереве что-то говорить, в суть одна.
Ну, просто не очень удобно реально строить дерево
и потом тут dfs запускать под дерево.
Но как бы для каждой вершины говорить, что в ней есть пометка,
значит, в родителя тоже есть пометка.
И честно так проходимся, и все помещенные крестики, соответственно,
говорим, что ура, такое вхождение.
Если нет, то...
Ну вот.
То есть и здесь уже никакого от ответа нет.
Все честно за нее.
Но напоследок, последняя,
вот одна из самых красивых задач на это дело,
на самом деле, знаете какая?
Дано множество строк s.
Мы их называем запрещенными.
Вот мы хотим создать великую строчку,
у которой ни одна из этих...
Ну, точнее так, у нас только это ограниченная алфавит сразу скажем, да?
И мы хотим создать великую строчку,
у которой ни одна из этих строк не является подсказанной.
Внимание, вопрос.
Какой максимальной длины она может быть?
Может быть бесконечной.
Ну, мы просто проходимся по нашему бору,
и это такая динамика получается.
Если, например, из рута есть ассоцииус символ,
то, ну, бесконечно.
Если нет, то динамику от каждой вершины...
Ну, можно динамику,
а можно на самом деле так сделать.
Рассмотрим.
Ну, во-первых, заметим, что когда мы ходим по любой строке,
мы ходим по бору, да?
И, конечно, по вот этим вот, можно сказать, по автомату, да?
Но заметим, что некоторые вершины в этом боре
из серийской автоматы являются запрещенными.
Потому что в крестике нам ходить нельзя,
более того, нам нельзя даже ходить в вершины,
потому что по суффиксным ссылкам можно попасть в крестик, правда?
То есть, ну, мы заранее из этого автомата можем посчитать,
найти все запрещенные вершины и их удалить, правда?
Ну, можно просто записать ДФС.
Как бы, когда мы доходим к запрещенной вершине,
мы возвращаем ноль.
И возвращаем максимум из вершинок.
Ну, по-разному.
Ну, можно так...
Ну, я просто сказал, что после того, как мы удалим,
можно сказать, что мы мысленно удалим все запрещенные,
и тогда после этого из корня у нас, значит, есть какой-то доступный крафт, да?
И получается вопрос только,
какое количество шагов мы можем по нему сделать?
И тут у вас два варианта.
Либо вы уситритесь наткнуться на какой-то цикл,
и тогда это будет означать, что вы тут можете по нему ходить бесконечно.
Ответ плюс бесконечность, такое бывает.
Либо доступная часть графа...
Либо выяснится, что да, доступная часть графа у вас на самом деле
является ациклическим графом.
Да, кстати,
ну так, кстати, вполне вероятно, что вот таким образом это будет, да?
То есть не путать автомат с городом, да?
То есть может быть.
Ациклическим графом, и вам там остается только динамичкой
действительно найти самый длинный путь, который вы тут можете.
То есть, как, например, как правильно сказала Антон,
просто запустить там, скажем, запустить DFS и честно вычислять эту функцию.
При этом DFS, если я попал в вершину, которая у меня сейчас еще в стеке,
то я рад с тобой возвращаюсь, плюс бесконечности радуюсь.
То есть начинаю просто выбрасываться с криком, плюс бесконечности.
Вот, как мы всегда делаем.
Да, то есть это вот действительно такая очень красивая монахия.
Вот, собственно, это все, что я хотел сказать про алгоритм Ахакараси.
Ну, значит, в следующий раз будем просматривать что-нибудь более веселое,
например, Патриархович.
Ну ладно, предварительно, как бы, я думаю, тема следующей лекции такая.
На первой пале мы рассмотрим алгоритм монахера и дерева календронов,
а на второй, в третьих бухпарах мы рассмотрим, видимо, алгоритм монахера.
Да, пожалуй, даже раньше суперстол массива.
