Так, ну, значит, у нас про логографическую память осталась теорема, значит, теорема
обычно называется иммерманно-слабчение. Вот, заключается в том, что NL равняется
NL. Давайте я напомню, что такое NL. Значит, NL означает, что есть недоторминированная
машина, которая распознает данный язык и использует логографическую память. То есть
это что означает? Это означает, что если ответ «да», то тогда одна из ветвей приводит ответ «да»,
и при этом каждая ветвь занимает логографическую память. Вот, если ответ «нет», то все ветви
дают ответ «нет», но и тоже каждый ветвь занимает логографическую память. Значит,
CoNL это то же самое, только наоборот. Значит, CoNL, ну, можно сказать наоборот, что, значит,
если ответ «нет», то тогда какая-то ветка приходит к ответу «нет», а если ответ «да»,
то все ветки приводят к ответу «да». Вот, то есть если в NL мы брали дизюнцию всех ветвей,
это давало ответ, то в CoNL мы берем конъюнцию всех ветвей, это дает ответ. Ну, либо можно
определять через дополнение, что, как всегда, Co класс — это класс дополнений к языкам из основного
класса. Ну и, соответственно, первоначально была некоторая интуиция, что, на самом деле,
это должно быть неравно и обосновывалось примерно так же, как для NP и CoNP. Ну, типа того, что вот,
ну, вообще не очень понятно, как там от дизюнции к конъюнцию перейти. Ну, или еще есть другой
подход, который мы будем использовать, который мы в конце прошлого раза изучали, это сертификатный
подход, что есть сертификат, который читается один раз лево-направо. Вот, и, соответственно,
должен существовать статистикат паридональной длины, который приводит к ответу «1», если на самом
деле ответ «1», а если ответ «0», то любой сертификат приводит к ответу «0». Ну вот, и тут, казалось бы,
та же самая интуиция работает, что и с NP. То есть, если мы можем предъявить короткий паридональный
длинный сертификат, который проверяется на логографической памяти, читается лево-направо и
удовтворяет ответ «да», то совершенно неясно, почему такой же сертификат будет для ответа «нет».
Ну вот, Эмерман и Сэл Лэпченни в конце 80-х годов объяснили, почему это будет так. Таким образом,
интуиция, которая берется от времени, здесь не работает. Ну, собственно, это у нас уже и раньше,
да, мы говорили про PSPACE и NP-SPACE, что с полимональной памятью недотаминированной машины ничего
дополнительно не дают. Но с логарифмической, они, может, и дают, но не дает вот этот переход
к КО-классу. Так, хорошо. Значит, как же это доказывается? Ну, доказательство будет стать
следующим. Значит, мы докажем, будем доказывать, что, значит, будем доказывать, что дополнение к
языку ПФ лежит в НЛ. Значит, почему этого достаточно? Ну, потому что ПФ, значит, ПФ НЛ полный, значит, раз ПФ является НЛ полным,
то, соответственно, ПФ с чертой, то есть дополнение к ПФ, является КО-НЛ полным. Ну, и тогда получается,
что если ПФ с чертой лежит в НЛ, то из этого следует, что для любого А из КО-НЛ, значит,
мы получаем, что А сводится к ПФ, к ПФ с чертой, значит, А из КО-НЛ, А сводится к ПФ с чертой, и тогда, значит, тогда получаем,
что А лежит в НЛ. Ну, как обычно, что если какой-то язык логарифмически сводится к языку из НЛ, значит, он сам в НЛ.
Вот. Ну, отсюда получается, отсюда получается, что КО-НЛ вложено в НЛ. Вот. Ну, и в другую сторону,
на самом деле, аналогично. Да, значит, в... Можно привести аналогичное рассуждение, а можно просто сказать,
что если А лежит в НЛ, то тогда А с чертой лежит в КО-НЛ, тогда, поскольку КО-НЛ вложено в НЛ,
получаем, что А с чертой лежит в НЛ, и тогда А лежит в КО-НЛ. Соответственно, получается, что НЛ вложено в КО-НЛ.
Вот. Ну, раз НЛ вложено туда и сюда, значит, они равны. Так, хорошо. Как же мы будем доказывать, что ПФ с чертой лежит в НЛ?
Да, ну, вообще, ПФ... Что такое ПФ? Это множество троек из графа двух вершин, таких, что и с первыми вершинами во вторую идет ориентированный путь.
Вот. Ну, дополнение, с одной стороны, формально можно сказать, что дополнение это любые объекты, не являющиеся такими тройками.
Но поскольку по объекту можно понять, он вообще кодирует тройку из графа двух вершин или не кодирует.
Для любой договоренности о кодировке это можно понять. Ну, для любой естественной договоренности можно понять, является ли данная запись кодом такой тройки или не является.
Итак, можно считать, что ПФ с чертой – это множество троек, таких, что из вершины С и вершины Т нет пути.
Вот. Дайте это я в новую уровню запишу.
ПФ с чертой – это множество троек G, С, Т, таких, что в ориентированном графе G нет пути, нет пути из С в Т.
Вот. Ну и нам нужно каким-то образом построить сертификат, который будет это доказывать.
Нужно построить сертификат, который доказывает, что тройка G, С, Т лежит в ПФ с чертой.
Вот. Ну и, соответственно, этот сертификат нужно построить, нужно делать так, чтобы он был полиномерной длины и чтобы он считался слева направо.
Так. Ну, значит, если понятно, зачем нам нужно это делать, то тогда давайте начнем, собственно, этот сертификат строить.
Значит, строить его будем постепенно. Значит, сначала такая идея. Ну, во-первых, если в вершину есть путь, то это мы уж можем доказать.
И, в принципе, во все вершины, которые есть путь, мы можем доказать, что он есть.
Ну, а теперь давайте представим, давайте представим, что у нас, откуда-то мы знаем, сколько всего вершин достижимые из С.
Да, вот. Ну, мы потом получим эту информацию, вычислим, но пока что представим, что у нас эту информацию уже есть, мы ей можем доверять.
Ну, значит, пусть известно, сколько всего вершин достижимо из С.
Ну, это там какое-то число. Так, давайте я это напишу СН.
Это число СН. Почему Н? Потому что дальше СИТ это будет число, достижимое путями длины не больше И.
Ну, а если какой-то путь есть, то есть путь длины не больше Н. Ну, значит, вот поэтому СН.
Вот, это число СН. Тогда нужно просто, чтобы доказать, чтобы доказать, что нет пути в Т,
нет пути в Т, нужно предъявить, значит, нужно предъявить вот такое число вершин.
Значит, СН вершин достижимых, значит, СН достижимых из С вершин, среди которых нет Т.
Вот, а как мы это предъявим? Ну, если она достижима, если она достижима, то мы можем путь предъявлять.
Ну, и то, что там они не совпадают с Т, мы тоже можем легко проверить. Мы же там обсуждали сравнение.
А тут у нас даже сравнение маленьких чисел. Вот, но надо еще проверить, что это все разные вершины.
Вот, а чтобы удостоверить, что это разные вершины, нужно их перечислять в порядке возрастания.
Значит, чтобы, потому что мы не можем их все хранить и сравнивать новую со всеми старыми.
Значит, чтобы проверить, что все вершины разные, чтобы проверить, что все вершины разные,
нужно перечислить их в порядке возрастания. То есть у них там есть какие-то номера.
Ну, тут можно считать, что просто номера от 1 до n. Вот, и тогда вот такой сертификат уже получается можно проверять.
Получается, что он будет выглядеть примерно так.
Вот такая длинная лента. Значит, как она выглядит. В1, потом тут есть путь из С в В1.
Значит, потом В2. Ну, значит, потом путь из С в В2. Потом В3, ну и так далее.
И потом В, так, давайте я двойной имекс не буду писать, ВСТ. Значит, ВСТ и, соответственно, путь из С в ВСТ.
И вот такой сертификат можно действительно читать слева-направо, имея константу счетчиков.
Ну, а какие у нас есть счетчики? Ну, во-первых, у нас изначально задан граф и две вершины, это вообще не в счет.
Ну, дальше у нас должен быть счетчик для текущей вершины.
Вот мы прочли текущую вершину В, ну и там, как нам договориться, как этот разделитель понимать, это, в общем, технические детали.
А вот мы прочли вершину. Вот. После этого что означает путь?
Ну, это тоже последовательность вершин, где первая вершина С, последняя вершина В1, а каждая следующая соединяется ребром с предыдущей.
Вот. Соответственно, что мы тут делаем? Ну, смотрим на первую, проверяем, что она равна С.
Значит, потом запоминаем первую, читаем вторую.
Проверяем по графу, что есть ребро из первую и вторую.
Потом первую забываем, на ее место записываем вторую и читаем третью, проверяем, что есть ребро из второй и третьей.
И так далее, и так доходим до конца, и в конце смотрим, что то, что у нас было, это В1.
Вот. Так мы проверили этот путь. После этого мы читаем В2, а В1 еще помним.
И проверяем, что В2 больше, чем В1, строго больше, что это действительно в порядке возрастания.
Вот. Если какая-то проверка на каком-то этапе не выполнена, тогда нужно сразу отвергать, говорить нет.
Вот. Значит, проверяем, что В2 больше В1 и теперь записываем В2 на место В1.
Дальше точно так же проверяем вот этот путь. Дальше В3 примерно, что больше В2 и так далее.
И на самом деле нужно еще один счетчик. Нужен еще счетчик, сколько мы собственные решения проверили,
чтобы в самом конце, если действительно... Да, еще каждый раз мы проверяем, что данная решения не Т.
Что В1 не равно Т, В2 не равно Т и так далее.
Соответственно, мы каждый раз проверяем, что новая вершина больше старой, новая вершина не равно Т,
что путь, который идет дальше, правильный, и увеличиваем на единицу счетчик уже обработанных вершин.
И в самом конце проверяем, что счетчик дошел до того значения С, которое должно быть, которое ценное.
Ну и что все проверки, соответственно, ни разу не обманулись, что все условия ни разу не нарушились.
Если это все так, то тогда прочитая этот сертификат, мы выдаем да.
Вот, а действительно, если мы заранее уверены, что значение С правильное,
то такая штука действительно докажет, что Т нету.
Потому что если всего С вершин достижимо, то мы не можем предъявить столько же достижимых, среди которых нет С.
Нет Т, если Т достижимо.
А если Т недостижимо, то мы их возьмем предъявляем.
Сn я сказал, n это число вершин в графе, а вообще потом CiT будет число вершин,
вершин достижимых путем длины не больше i.
А Cn, потому что если есть какой-то, то есть по длину не больше m.
Ну там даже m-1 не сопаревываемо считать, но это, в общем, неважно.
Хорошо, значит, если мы знаем общее число достижимых, то тогда вот все получается.
Дальше возникает вопрос, откуда взять C?
Откуда взять C, который есть Cn?
Ну ответ по индукции.
Значит, по индукции.
Как именно? Ну мы определим, вот CiT.
Значит, CiT это число, значит, число вершин
достижимых, достижимых путем длины не больше i.
Вот, значит, CiT это число вершин, достижимых путем длины не больше i.
Тогда у нас есть база индукции, мы знаем, чему равно C0.
Значит, C0 равно 1.
Это мы знаем.
Значит, база, что C0 равно 1.
Путь длины 0, это одна вершина, и это как раз она и будет достижена.
Вот. Ну а переход...
Да, значит, переход, соответственно, каким-то образом нам нужно перейти вот CiT к Ci плюс 1.
Да, то есть...
Но иметь в виду, что вот это будет некоторым участком сертификата, так что к началу
чтения этого участка мы уверены в значении CiT, а в конце мы будем уверены в значении Ci плюс 1.
Вот. Но тогда, проведя n шагов, мы придем к Cn, и дальше добавив вот это, мы узнаем, что T недостижимо.
Так, вот такой вот план.
Так, ну что, есть какие-нибудь вопросы по общему плану?
Длину давайте по ребрам считать.
Да, тогда в принципе можно не Cn на Cn минус 1 взять, но, в общем-то, не важно.
С Cn хуже не будет.
Ну, длина пути, это число ребер, которые...
То есть, на 1 с меньше, чем число вершин, которые в него входят.
Так.
Ну, значит, смотрите, вот в этом переходе, значит, переход будет выглядеть так.
Во-первых, ну, очевидно, что если вершин достижимо путем длины не больше, чем и плюс 1,
то для этого сертификат есть.
Да, значит, есть сертификат достижимости.
Значит, сертификат достижимости вершины путем длины не больше, чем и плюс 1.
И это сам этот путь.
Да, значит, это сам этот путь.
Вот, а еще, может быть, сертификат недостижимости...
Значит, сертификат недостижимости...
Сертификат недостижимости...
Ну, то же самое, вершины путем длины не больше, чем и плюс 1, при известном...
При известном ЦИТ.
Ну, в общем, он выглядит почти точно так же, как здесь.
То есть, вообще, на самом деле, сам сертификат точно так же выглядит, но проверяется по-другому.
Да, соответственно, сертификат выглядит так же, но только уже для C равного ЦИТ.
Значит, для C равного ЦИТ.
Но вместо...
Значит, если мы анализируем вершину W, чтоб не путать с T, которая у нас конечная, во всей задаче.
Вместо проверки того, что ВИТ не равно W, мы делаем проверку, что там нет ребра.
Значит, ВИТ не W.
Точнее, это даже не вместо, а вместе, наоборот.
Значит, вместе с проверкой, что ВИТ не равно W.
Потому что если ВИТ равно W, то она уже достижима путем длины и меньше, чем и плюс 1.
А еще может быть, что какая-то решина ВИТ достижима путем длины и.
И еще есть одно ребро в W.
Тогда W была бы достижима путем длины и плюс 1.
Ну вот.
То есть нам предъявляют, да, мы знаем, что C-вершин достижимы путем небольшой E.
Нам эти C-вершин предъявляют.
И мы про каждую из них проверяем, что, во-первых, она сама не совпадает с W.
И, во-вторых, из нее не идет путь W. Не путь, в смысле, а ребро.
То есть нельзя этот путь длины и нарастить еще на одно ребро так, чтобы он пришел в W.
Так. Ну ничего, понятно?
В общем, у нас есть сертификат достижимости, есть сертификат недостижимости.
Ну а дальше, как нам теперь посчитать C и плюс 1?
Ну нам просто нужно для каждой вершины дать либо сертификат достижимости, либо сертификат недостижимости.
То есть теперь сертификат...
Так, дайте я вот так вот.
Значит, сертификат как C и T в C и плюс 1.
Значит, он тоже похожим образом...
Выглядит...
Ну тут уже все вершины по порядку идут.
Там будет вершина 1.
А тут, соответственно...
Так, ну давайте я напишу для конкретного случая.
Значит, если 1, то тут путь из S в 1 длины меньше на тему плюс 1.
Да, а потом, например, 2.
А тут будет сертификат недостижимости 2.
Да, там 3, ну и так далее.
Ну в общем, тут мы перебираем все вершины,
и для каждой из них предъявляем либо сертификат достижимости, либо сертификат недостижимости, в зависимости от того, что именно верно.
То есть тут для каждой вершины предъявляется сертификат достижимости или недостижимости.
Ну и понятно, как проверяется.
Ну можно сюда еще один бит записывать, каково видно сертификат.
А можно пытаться это понять по самому сертификату.
Проще, конечно, что записать, какой ответ.
То есть вот у нас очередной номер, там 1.
В принципе, можно даже имена ранее писать, их вычислять.
Там будет просто очередной разделитель, бит ответа и сертификат.
Но проще, когда будет номер, потом бит да или нет.
Если да, то путь, если нет, то, соответственно, сертификат недостижимости.
Ну и верификатор идет.
Читает очередной номер вершины.
Проверяет, что он на единицу больше того, что там было до этого.
Дальше проверяет этот сертификат.
После этого там читает новый номер, читает новый бит.
Проверяет, что у нас на единицу больше.
Перезаписывает там то, что было.
Проверяется, соответственно, сертификат.
Ну и так далее.
Ну и после этого получается, что весь сертификат,
значит, весь сертификат уже для П с чертой
будет выглядеть так.
На, тут как бы будет, там,
c0 в c1,
потом c1 в c2,
там, и так далее.
На, там, cn-1 в cn.
Вот, и потом
сертификат недостижимости
при известном,
при известном cn.
Вот.
Вот так это все должно выглядеть.
Ну, действительно, длина будет полинамиальной.
Знаете, почему?
Ну, потому что, смотрите, у нас тут будет n,
ну, n плюс 1, значит, n плюс 1 кусок, да, потому что вот,
ну, это, собственно, выглядит точно так же, как вот это вот.
Значит, ну, основная вот эта вот будет часть.
Значит, будет n участков.
Значит, каждый участок состоит еще вот из n тоже сертификатов.
Вот. А эти сертификаты, значит, вот эти вот длины там не больше n,
а вот эти, они, на самом деле, тоже выглядят так, да, они тоже из,
ну, если не, может быть, меньше, чем из n, да,
но тоже из какого-то линейного числа достижимых.
И каждый, и каждый из этих путей тоже длинный.
Ну, в общем, n с четвертой получается.
Да, длина сертификата n с четвертой.
Да, потому что n этапов, значит, каждый этап тоже из n частей.
Вот. И эти части есть длинные, да, значит, которые тоже из,
ну, может, не n, но n пополам там, или сколько-нибудь вершины,
для каждой из них еще путь тоже.
Ну, путь-то длины i, ну, i тоже может быть порядка n пополам,
там где-то в середине.
В общем, общая длина порядка n с четвертой.
Ну, это нас устраивает, да, это полином.
Значит, это полином.
Соответственно, для проверки нужно там какое-то не очень большое
константное число счетчиков.
Ну, может, если не экономить там, ну, штук 15 точно хватит.
Вот. Ну вот и действительно все корректно проверяется.
Так, есть какие-нибудь вопросы по поводу этой конструкции?
Нужно ли что-нибудь разъяснить подробнее?
Повторите еще раз.
Вот. Ну, действительно, она не очень тривиальная.
Да, то есть это неудивительно, что это не сразу придумали.
Вот. Ну, на самом деле, да, значит, вот этого получается достаточно
для доказательств того, что nl равно qnl.
Вот. Ну, это позволяет сразу много других задач классифицировать там в qnl,
да, в qnl полное.
Вот. Например, задачу выполнимость 2knf.
Да, вот мы как-то обсуждали, значит, 2sat.
2sat это выполнимость 2knf.
Значит, ну что phi?
Таких, что phi это выполнимое 2knf.
Мы, кажется, обсуждали, почему она лежит в p,
но на самом деле она лежит не только в p, но и в nl.
Значит, она лежит не только в p, но и в nl,
но и будет там nl полный.
Так. Ну, я думаю, что я после перерыва это расскажу тогда,
почему это будет так,
что если вопросов по основной теории нет,
тогда сейчас через полминут будет звонок.
Через 6 минут продолжим.
Продолжим.
Да, давайте я напомню, что такое 2sat.
Ну, у нас такие скобочки,
в которых дизъюнкция какого-то вот такого вот вида.
Да, дизъюнкция двух литералов.
Вот, и они все должны быть выполнены.
Значит, я напомню, что мы строили граф.
Мы строили граф, где для каждой переменной заводили две вершины,
соответствующие ей ее отрицания.
Вот, и рисовали стрелочки.
Значит, для каждой скобки рисовали две стрелочки,
которые на самом деле получались импликациями,
которые из этой скобки получались.
То есть p или не q.
Значит, из q следует p.
Ну, или контрпозиция, что из не p следует не q.
Так, p или r.
Это, соответственно, из не p следует r.
Значит, из не r следует p.
Так, значит, не q или не r.
Так, сейчас, что-то я какой-то не очень хороший пример делаю.
Ну ладно, не важно.
Значит, из q следует не r.
Из r следует не q.
В общем, они такими парами, получается, идут.
Вот, ну и на самом деле, значит, в данном случае получилось,
что вот эта вот скобочка, она на самом деле из этих двух просто следует.
Потому что если мы...
Вот это означает, что из q следует не r.
А вот это означает, что из не r следует p.
Поэтому из q следует p.
То есть тут несколько избыточные, значит...
Избыточные числа условий.
Вот, ну вот, так или иначе, мы обсуждали следующее.
Что формула выполнима...
Формула выполнима тогда и только тогда,
когда ни для одной переменной,
ни для какой переменной
нет одновременно
пути...
или там, путей.
Значит, путей из p в не p
и из не p в p.
Вот.
Ну, теперь мы знаем.
Теперь мы знаем, что нет путей,
можно проверять налогографической памяти.
Но при этом и граф соответствующий
тоже можно изготавливать в налогографической памяти.
Вот, можно вообще граф не изготавливать,
а на лету по формуле понимать, есть там ребро или нет.
Да, просто перебирая все скобочки.
Вот.
И это пока что лезет в NL.
Да, потому что нам нужно сделать цикл
по всем переменам.
И это нам даст еще один счетчик.
Вот, и соответственно
проверять для каждой перемены,
что нет одновременно пути
из p в не p и из не p в p.
Вот.
Да, давайте я тут допишу.
Значит, вот это вот
проверяется
в NL.
Так.
Ну, ничего, понятно?
Вот.
Хорошо, ну теперь давайте еще
я расскажу, почему
2сад это NL полная задача.
Значит, 2сад
2сад это NL полная
задача.
Ну, для этого нужно просто
к ней свести
p в
Так, ну точнее лучше, наверное,
к ней свести
p в
Так, ну точнее лучше, наверное,
p с чертой
p с чертой
логрифически сводится
к 2сад.
Так, ну идея сводимости такая,
что вот у нас есть
некоторый граф.
Значит, есть некоторый граф.
В нем есть s, есть t.
И мы
хотим делать следующее.
Мы хотим для каждой вершины
придумать
какое-то логическое значение.
Значит, так, чтобы
в s
значит, в s была бы
единица, в t был бы
ноль, ну
и соответственно, значит,
все, что достижимо
значит, вот здесь была бы единица
всюду, значит, во всех вершин,
которые достижимы из s.
И наоборот,
значит, во всех вершинах, из которых
достижимо t,
чтобы был бы ноль.
Ну, ясно, что такое можно делать, если пути нету.
Если пути нету,
то нет ни одной вершины, которая
одновременно была бы достижимой из s
и такой, что из нее
достижимо t.
Да, можно этим дать единицу, этим дать ноль.
А, соответственно, если
путь есть, то так нельзя сделать.
Ну, вот получается, что отсутствие
пути и равносение выполнимости этой формы.
Ну, в общем, получается, что у нас
переменная,
одна переменная
для каждой вершины
Да, значит, есть одна переменная
для каждой вершины.
Вот, соответственно,
ну, будешь считать, что она так
же и обозначается, как сама вершина.
Соответственно,
одна у нас
одного слоя будет просто s,
значит,
другой слою будет
отрицание t.
Ну, и для ребра
значит,
для ребра
x и y
мы вводим два условия.
Нужно, чтобы у них было одинаковое значение.
Одинаковое значение будет
так, x или не y
и y или не x.
Ну, то есть они равносимны.
Вот.
Ну, вот, если мы все эти условия
напишем
и возьмем комьюнцию,
значит,
все условия одновременно
все условия одновременно
выполнены
тогда и только тогда,
когда пути
из s в t нет.
Ну, да.
Ну, мы так хотим.
Ну, что?
Если из x идет ребро в y,
то у них одинаковое значение.
Нет.
Нет.
Значит, мы хотим, чтобы
истинными были те вершины, которые достижимы из s,
а лозными были те вершины, из которых
достижимы t.
А, ну, это вы, конечно, правильно говорите,
но такие можно, наверное, просто исключить.
А.
А, то есть вы хотите сказать, что это не нужно,
не нужна равносильность, да?
Да.
Да, пожалуй, вы правы.
А это значит,
это значит,
только вот эту штуку надо оставить, да?
Да.
Да, пожалуй, вы правы.
Так, надо сделать.
finished, да?
Да, тогда просто,
да, тогда просто единица распространяется поребрям, да,
но не распространяется обратно.
А ноль наоборот, ноль распространяется обратно,
но не распространяется поребрям.
Да.
Да, пожалуй, вы правы.
Спасибо за исправление.
Да, теперь правильно. Теперь правильно, да, значит, что
действительно, s должно быть равно единице,
если из s куда-то идёт, тогда то, куда идёт, тоже равно единице,
да, значит, и по ребрам это всё распространится.
Да, значит,
действительно, да, значит, нам нужно, чтобы
вот такое вот ребро допустимо,
раньше такое ребро допустимо, и тут как раз вот нуля единицы может быть.
Так, да, ну ладно,
ладно, действительно, было неправильно вначале.
Так, какие-то ещё вопросы?
Так, ну в общем, про логическую память, это более-менее всё, что я хотел сказать.
Значит, есть ещё одна тема, которая тоже связана с этим,
но вообще с другой стороны стоит вообще немножко сомнительнее,
то есть, в общем-то,
в общем-то, есть ещё одна тема, которая тоже связана с этим,
но вообще с другой стороны стоит вообще немножко с огняком,
значит, эта тема, эта тема
из логических элементов, да,
или из функциональных элементов, или их называют контактные релейнами.
Во, значит, это такое,
в принципе, такая схема, это вообще альтернативная модель вычисления,
которая, в принципе, по-другому устроена.
Но она тоже имеет некоторые корни в реальности,
значит, а именно
реальные электронные микросхемы, они прямо так и устроены.
Схема
из функциональных элементов.
Значит, функциональными элементами
называются такие вот
буквы, например,
комьюнция, комьюнция
и отрицание.
На них смотреть, как действительно такие там релеи,
действительно, элементы микросхемы,
у них есть какие-то там проводки, которые поступают на вход,
и, соответственно, проводок или нет проводков, которые выходят
наружу. И, соответственно, там в каждом проводке
может быть какой-то бит, то есть либо есть ток, либо нет тока.
А этот элемент преобразует входные сигналы так, чтобы
на выходе получился сигнал
сообразно-логической функции, которая на элементе написана.
Ну, вот, реально, там, процессоры примерно
из таких мелких транзисторов и паяют.
Ну, и сейчас, конечно, там не паяют, как по-другому делают, да, но, в общем,
изготавливают действительно платы с очень-очень мелкими
вот такими вот элементами. Нет, это не такие, да, но какие-то.
Ну, вот.
Ну, известно, да, что вот через
действительно дезъюнцию, конъюнцию и отрицание можно
определить любую функцию. Соответственно, если у вас есть
неограниченный запас таких элементов, то из них можно спаять
тему, которая вычисляет любую функцию, но
с предписанным числом входов. Ну, например, может быть,
такая схема, да, значит, на входе есть х, есть у.
Значит, а дальше, например, я
делаю отрицание.
Теперь у меня есть не х, не у,
в дополнение к эту у. Значит, дальше
я беру, например,
конъюнцию здесь
и конъюнцию
так, нет, а, ну, можно
да, можно вот так вот.
Конъюнцию здесь, конъюнцию здесь, да, значит, а здесь беру дезъюнцию.
И вот это как бы отправил
на выход. Вот, значит, тут смотрите,
что происходит. Думаю, что мы сигнал еще можем
как бы размножать. Да, то есть, можно
считать, что это просто два разных проводка, на выходе получает один тот же ответ.
Можно представить, что здесь еще там стоит элемент, там,
удвоитель, который на вход получает какой-то сигнал
и его по двум выходам отправляет.
Вот. Ну вот, скорее всего, если на все это вместе
посмотреть, да, можно все это вместе посмотреть, как на черный ящик,
у которого вот есть два обхода и один выход.
Тогда что это за элемент получается?
Так, только я что-то не то вообще не представлял.
Так, опять, извините, я написал, что у меня дублируется
то же самое, а я хотел, нет, я хотел вот так их нарисовать.
Да, вот теперь это,
ну, теперь что-то осмысленное.
Это раньше я дублировал, а теперь не дублирую.
Да, это не XOR, а наоборот, эквивалент.
Да, то есть вот это все вместе, это, значит,
эквивалент.
Вот.
Вот.
Вот.
Вот.
А, значит, эквивалент.
А чтобы XOR нужно переключить, да, чтобы в XOR
нужно, наоборот, вот это переключить сюда,
а вот это переключить сюда.
Вот. Ну, соответственно, вот
такими штуками можно набирать
какие-то сложные схемы, которые можно себе представлять,
ну, вот так вот, да, что есть такой черный ящик,
у которого много проводков на входе, один, ну, что если это
булева функция, то один проводок на выходе, а может быть и больше проводков на выходе,
если это какая-то вообще искрепная функция. Вот. Ну, а внутри
черный ящик, который выглядит как каким-то вот таким образом.
Вот.
Ну, значит, особо глубоко
в теорию я не хочу вдаваться, да, потому что тут
ну, нужно какое-то формальное определение, что это такое, формально
это будет, например, направленный граф с отметками,
да, то есть
ну, с отметками на вершинах, да, то есть отметка на вершине
говорит какого типа этот элемент, да, или это вход,
или это выход, или это какой-то преобразователь.
Ну, и важно, чтобы этот граф был ориентированным без циклов,
да, потому что если он будет циклами, то это
ну, может, конечно, не такую спаять схему, но что там будет происходить, не очень понятно.
Вот. Если он без циклов, тогда понятно, мы идем как бы
сверху вниз, да, и вычисляем.
Вот. Есть такая теорема от топологической сортировки, да, что если у вас есть граф
ориентированным без циклов, то можно сортировать его вершина,
да, сортировать его вершина так, чтобы ребра шли из вершины с меньшими номерами
вершины с большими номерами. Ну, и тогда в соответствии
с этими номерами можно вычислить те результаты.
Да, идя просто вдоль этих номеров.
Ну, чего, прямо понятно?
Так, теперь только остаются сложности.
Значит, тут есть два параметра.
Два параметра у схемы,
которые нас интересуют. Значит, это размер
и глубина. Ну, размер это просто
число вершин и число элементов.
Ну, а глубина это
максимальная длина цепочки от входной до выходной.
Вершина.
Ну, там опять же возможны вариации,
типа считаем ли мы сами входную или выходную вершину,
или не считаем. В общем, это будет там плюс-минус
два. Это всё не очень важно.
Вот.
Значит, вот получается две характеристики.
Две характеристики это
размер
и глубина.
Вот. Ну, а при этом у нас
число входов у схемы фиксировано.
Значит,
число входов
фиксировано.
Поэтому в контексте распознавания языков говорят не об одной схеме,
а о семейской схеме. Значит,
поэтому
применительно
к сложности задача
говорить
говорят
не об одной схеме,
а о семейской схеме.
Осьмейской схеме.
Да, кстати, схема здесь по-английски
это не skim, как можно подумать, а circuit.
То есть
схема называется circuit.
Вот. Boolean схемы это ещё называется.
Boolean circuits обычно говорят по-английски.
Вот. Ну, в общем, cn имеет ввиду, что для каждой длины входа
есть своя схема. И нас интересуется этим точка.
Значит, насколько растёт размер и глубина.
Вот. На самом деле, значит,
в принципе нас ещё может интересовать
можно ли вычислить, зная n, можно ли вычислить cn и насколько эффективно.
Вот. Если мы вообще никаких ограничений не делаем,
то есть у нас и размер какой угодно, и глубина какая угодно,
и вычислять не обязательно,
тогда вообще любая функция,
любой язык будет распознаваться в семейском схеме
экспедиенциального размера.
Значит, любой,
совершенно любой язык,
любой язык распознаётся
в семейском схеме
в семейском схеме
экспедиенциального размера.
Вот. Ну, это классическая теория.
Да, значит, если мы в качестве экспедиенциального размера
возьмём вот такой вот
порядка n на 2 степени n,
то это просто обычное там dnf или knf.
Значит, dnf или knf
стандартным образом строящиеся они вот такого размера будут.
Так. Ну, этого, я думаю, вы изучали.
Ну, значит, есть более хитрый способ, который позволяет
за это какие-то похожие вещи находить
и переиспользовать, значит, который получается порядка
2 в степени андилитно, а n он не умножит.
Значит, это уже хитрый способ. Называется керема Лупанова.
Вот. Тоже классический результат из 1958 года.
Вот. Но уже такой технически сложный.
Вот. Существенно меньше сделать нельзя
из соображений типа принципа Дерехле.
Да, то есть, поскольку всех функций там от n переменных будет 2 в степени 2 в степени n,
если аккуратно посчитать, сколько будет графов там меньшего размера,
то их просто меньше будет. Вот. Поэтому это
довольно точная граница. Ну, с точностью до того, какая здесь константа.
В нижней оценке и в кереме Лупановой
немножко разные константы, но порядок просто один и тот же.
Вот. Но поэтому, раз экспедиционного размера
значит, раз экспедиционного размера
годится всегда,
то возникает вопрос, а можно меньшего размера?
Ну и об чем нас вообще это интересует? Ну, смотрите, если мы это
паяем как микросхему,
значит, если мы паяем как микросхему, то размер, это
грубо говоря, стоимость этой микросхемы. То есть, сколько там релея
нам нужно купить, чтобы паять с этой микросхемой.
Вот. А вот глубина отвечает за быстродействие.
Потому что если сигнал там по каждому проводку
там проходит за один такт, то как раз какая-то глубина будет,
за столько такта все это и будет вычисляться.
Ой, ну, в общем-то, просто размерские слова там,
size и depth используют.
Ну вот.
Да, я, кстати, что-то не написал, давайте я напису
в доске, что размер, значит, размер
число вершин, размер число вершин,
значит, глубина
это кратчайший путь,
кратчайший путь от
входа к выходу. Ой, не кратчайший,
а наоборот длиннейший.
Длиннейший путь
кратчайший путь от входа к выходу.
Вот. Ну и, соответственно,
дальше начинаются
сложностные классы. Значит, вот p, такое
обозначение, p slash poly.
p slash poly, значит, это языки
распознаваемые
имейством с тем
размера
полинома t.
Вот.
Ну и там, например,
можно заметить,
на самом деле, любой
любой полиномиальный язык будет
в t slash poly тоже.
Да, значит.
Да, значит.
Значит, ну вот, можно сказать,
теорема 100p трога вложена
с p slash poly. Значит, тут еще может быть
вопрос, что такое странное обозначение на какое-то p slash poly.
Ну, на самом деле, это связано с другим определением
того, что это за класса. Можно себе представлять, что
есть как бы интерпретатор схемы,
и он сам по себе, если у него схема уже есть, он ее может вычислять
быстро за полином. И поэтому p.
А вот это вот poly, это значит, что сама схема полинованного размера.
Вот. Да, и вот видите, тут
это значение означает, что вложено и не равно.
То есть, с одной стороны вложено, но с другой стороны есть языки
с p slash poly, которые не лежат.
Ну а если по крайней мере идейно обсудим,
доказательства.
Ну, идейно, что вложено,
это более-менее аналогично теремику Клевина.
Аналогично
теремику Клевина.
Ну, что означает, что машина работает
в полиномальное время, значит, у нее каждая конфигурация
полиномального размера, их полиномальное количество.
У нее есть некоторый протокол,
протокол, который как-то вот так вот выглядит.
Ну и тут, соответственно, тут, на самом деле, каждая клетка
значит, каждая клетка является функцией
от небольшого числа клеток на дни.
И можно просто вот это вот как бы выразить
какой-то функции, эту функцию
как-то выразить соответственно схемой. Ну и просто после этого ее как бы
все эти функции запаять в количестве t в квадрате раз.
Ну t это полином, поэтому t в квадрате тоже полином, поэтому мы так все возьмем, вычислим
и будет единица.
А входа мне, ну а как вход, вот там в первой ячейке
нужно записать бита х.
Тут у нас уже нет никакого y в отличие от телемку Клевина.
Да, есть только начальница стояния, соответственно, бита х,
ну и дополнительные клетки.
Ну а их как бы константы нужно инициализировать.
Ну константу можно получить, либо можно считать, что она прям дана,
либо можно вычислить, как там p или не p,
как единица, и p или не p, как ноль.
Да, то есть константа, так или иначе, можно
как-то приготовить и, соответственно, сюда падает.
Вот.
Значит, это вот поэтому вложено.
Ну а не равно,
потому что может быть даже вообще невычислимая зависимость.
То есть идея в том, что может быть вообще
невычислимая,
невычислимая зависимость
на там схемы ценные от n.
Ну, например, можно взять какую-то вообще неразрешимую задачу,
например, к проблему там остановки.
И, соответственно, рассмотреть
вот такой язык, унарный,
значит, один степень n имеет в виду, что это n единиц подряд.
То есть слово из n единиц
таких, что n лежит
в языке halt.
То есть n кодирует там машину тюринга и вход, на котором она останавливается.
Ну, каким-то образом мы договорились, как кодировать
пары из машины кода. Ну, может
считать, что это проблема самопременимости, то есть n является номером машины,
которая останавливается на собственном номере.
В принципе, совершенно неважно, здесь можно любой язык
неразрешимую взять, и конструкция будет одинаковой.
Тогда получается, что смотрите, что у нас для фиксированного n, у нас получается, что
либо слово из всех единиц входит, а остальные не входят.
И тогда эта схема, это просто конъюнция всех кодов.
Либо вообще ни одно слово не входит.
То есть для фиксированной длины у нас либо нет ни одного слова, либо есть ровно одно из всех единиц.
И, соответственно, если нет ни одного слова,
это просто ажестно ложная функция, а если
все единицы входят, тогда конъюнция всех кодов.
Ну, конъюнция всех кодов, она, понятно, полиминального будет размера.
И там, и там будет схема полиминального размера, и даже довольно простая, но мы не знаем,
где какая.
Вот, поэтому размер полиминальный,
но вычислить при этом не можем, потому что нам, чтобы вычислить,
нам нужно бесконечное число схем по одной или каждого размера.
Вот, с другой стороны, если мы потребуем, чтобы вот эта зависимость была
тоже полиминально вычислимой, тогда это будет просто то же самое.
Ну да. То есть, если p слежь в поле, и при этом схема
для размера n вычисляется за время полиминального от n, то это будет то же самое, что p.
Ну да, ее сначала вычисляем, потом применяем.
Так. Ну, все, понятно.
Так, ну хорошо, значит, соответственно,
так, минутка у нас остается, значит,
небольшой анонс, что мы, по крайней мере, в начале следующего раза будем
изучать, это
говорим про глубину, значит, и вот если раньше мы изучали
логеретмическую память, то теперь у нас будут схемы
логеретмической глубины,
и это как раз будет отвечать теперь за быстродействие.
В случае со схемами, глубина это быстродействие, поэтому логеретмическая глубина
отвечает за быстродействие, в частности
для
сложения. Да, давайте я все-таки
доскажу, это важная идея.
Смотрите, если мы складываем двоичные числа просто в столбик,
как мы изучали на логеретмической памяти, то мы вообще проходим,
чтобы вычислить предпоследний бит, нам нужно сначала
сложить последний понятие, если стан перенос, чтобы вычислить второй,
с конца нам нужно предпоследний вычислить и так далее, и тогда если все раскрутить,
там будет глубина линейная от числа знаков.
И если бы процессор делал так, значит, если процессор
скуминировал просто в столбик, то он бы очень медленно работал,
поэтому процессор использует быстрый сумматор, который
позволяет не каким-то образом параллельно вычислять перенос,
и потом сразу получить себе ответ. Но про этот быстрый сумматор
я хочу рассказать в следующий раз, в начале,
а дальше посмотрим.
Куда дальше идти.
Все, спасибо.
