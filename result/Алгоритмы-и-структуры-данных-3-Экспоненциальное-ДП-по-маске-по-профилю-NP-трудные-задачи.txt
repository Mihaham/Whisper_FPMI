Всем здрасте, давайте стартовать. Сегодня заканчиваем говорить про динамику. Сегодня у
нас последняя тема здесь. Это динамика по маскам или по подможествам.
Идея такая, смотрите, пусть у нас есть какое-нибудь множество не очень большое. Давайте я его назову А. Оно состоит из
тех целых неотрицательных чисел вплоть до н-с одного. Мы хотим как-нибудь, как можно
более эффективно представлять подмножество этого А в памяти. Ну понятно, любое множество
просто можно представлять перечислением его элементов, но мы сделаем немножко по-другому.
Мы будем, во-первых, считать, что n не шибко большое, типа там 30, например, 20, 30, где-то так, ну может
быть там 60. И будем каждое подмножество этого множества представлять в виде числа. Следующим
простым образом, мы просто, если у нас есть какое-то подмножество, то мы давайте напишем битовую
строчку длины n, где единичка будет означать, что число взято множество, нолик значит не взято.
Например, если я напишу такую строчку, это означает, что у меня множество взято только единичка и двойка.
Просто я для каждого числа говорю, беру я его подмножество или нет, соответственно,
единицу или нолик пишу, и тем самым я однозначно кодирую все подмножества вот этого А с помощью
битовых строк длины n. Давайте зафиксируем, что подмножество А
тривиальным образом однозначно соответствует битовым строкам длины n.
Ну и такие битовые строки можно хранить в виде просто числа какого-нибудь целого,
например, int. Если у нас n действительно такое небольшое, то просто можно рассматривать вот
это вот как представление числа в двуичной системе числения и говорить, что, ну окей,
вот такую строчку будем хранить просто одним int, одним числом. Если там, скажем, n будет порядка
60, то тогда вместо int нам нужен будет какой-нибудь long-long. Тем самым мы можем очень приятно,
очень эффективно кодировать подмножество А просто числами. Например, в этом случае я рассматриваю
вот эту вот строчку как двуичное представление какого-то числа. Давайте считаем, что у меня биты
здесь написаны от меньших к большим, то есть это младший бит, это старший, как бы постарше,
это еще старше, это самый старший. Тогда вот это вот множество будет просто соответствовать числу
2 в первый плюс 2 во второй. Что это такое? Ну, видимо, видимо 5, 6, сори, 6. Вы знаете, тем самым мы
закодировали все подмножества. Это понятно? Вот, ну используя такое представление множеств,
мы будем решать всякие задачи на ДП. Но сначала нам надо будет с ними еще поподробнее познакомиться,
значит, как мы вот так закодировали, теперь нам нужно научиться делать всякие операции.
Первая операция, которая нам нужна, давайте напишем, что это операция над масками. Собственно,
маски это вот как раз те самые численные представления всех подмножеств. Во-первых,
нам нужна будет процедура извлечения бита. То есть это проверка того, есть ли какой-то
элемент в нашем множестве. То есть вы рассматриваете какое-то подмножество А, вот это вот,
какое-то подмножество А, и вы хотите как-то быстро определить, лежит ли в этом подмножество,
не знаю, единица или там другое какое-то число К. То есть это проверка наличия какого-то
элемента в множестве. Реализуется достаточно просто. Давайте это напишем прям кодом. Я это
привык называть функцией bit, извлечение бита. Принимает два аргумента. Принимает маску,
которая, собственно, и кодирует то множество, из которого надо извлечь этот бит, и принимает
позицию числа, которой, собственно, надо проверить на принадлежность множеству. А то есть маска это,
по сути, битовая строка длины n из нулей единиц. А поз — это то число, которое мы хотим проверить
на принадлежности этой маски. То есть правда ли, что на позе позиции у меня стоит единичка?
Правда ли, что на позе позиции единичка? Вот, ну и здесь давайте я перейду, что я буду все-таки
записывать числа не слева направо в порядке возрастания битов, а, ну как, в общем, это обычно
происходит, справа должны быть младшие биты. Когда мы пишем десятичное число, у нас справа
единицы, потом десятки и так далее, то есть права будут младше. Так же будет и здесь. Ну,
напишем следующее. Return маск больше-больше поз. Ant 1. Конец. Давайте Ant по-человечески напишем.
Что такое значит больше-больше? Ну, это сдвиг на поз позиции вправо. Как он работает? Вот была у
вас маска какая-то, число в двуичной записи. Вот здесь был его конец. Вы берете, сдвигаете его на
поз позиции вправо. Вот представьте, да, просто это число подвинули на поз позиции вправо. Вот что-то
такое. Соответственно, здесь вылезет поз последних бит. И когда вы делаете такой сдвиг, на самом деле,
поскольку у вас, ну там, место в регистре, оно ограничено физически каким-то окончанием, то на
самом деле просто все вот эти биты затираются. Вы как бы сдвинули, и все, что вылезло за пределы
того, что у вас хранится, за нуляете, ну просто отбрасываете. И тогда ваше новое число, вот это
вот маска больше-больше поз, это то, что останется, то, что останется слева от вот этого вот ограничителя.
Ну и тогда понятно, что когда вы берете в конце ampersand с единичкой, то есть логическое и с единичкой,
вы просто извлекаете вот этот вот последний бит. Сдвинули, осталась какая-то маска, и вы из нее
извлекли последний бит. Потому что ans1 это как раз, ну вот представьте, да, у вас есть вот
этого число, и вы ее andите с вот таким числом. Ну понятно, что вы просто тогда извлекаете последний
бит. Потому что ans0 это 0, ans1 это то, что здесь было написано. Ну, собственно, а это ровно тот бит,
который нам нужно было извлечь. Если здесь справа поз позиции, то в нольнэксации как раз вот этот
бит имеет номер поз. В исходной маске он имел номер поз. Вот это ровно то, что мы хотели извлечь.
Согласны? Хорошо. Вот это работает очень быстро, потому что здесь все операции булевские, ну битовые.
Сдвиг на поз позиции вправо, это очень простая операция, явно это попроще, чем умножить,
скажем, два числа. То есть мы понимаем, что числа хранятся там в регистрах, как какие-то
последствия на ноль единиц. Понятно, что сдвинуть число на поз вправо и отбросить вот этот мусор,
это сильно легче, чем, скажем, перемножить два числа. Ну мы считаем, конечно, что и то и то
работает за вот эти единицы, но с точки зрения константы, вот эта вещь, конечно, гораздо более
простая, чем умножение, деление и все такое. Ну и это ans1 тоже очень быстро работает, просто
извлечение последнего бита, это прям супер быстро. Хорошо. Дальше нам нужны будут всякие операции
над множествами, здесь все будет просто. Во-первых, это объединение множеств. Ну вот скажите мне,
пожалуйста, есть у меня два множества, а и б, каждая какой-то маски соответствует, маск а,
маск b. Я хочу построить новое множество, равное объединению двух старых, и, соответственно,
написать здесь маску, которая соответствует этому множеству. Что я должен сделать? Конечно. Маск a
or маск b. Побитого ели, действительно, ну потому что, что такое объединение? Это такая строка,
что такое маска для объединения? Такая строка, где единица стоит, если только, если была единица
в этом разряде хотя бы в одном из двух множеств, этим или том. Поэтому нужно просто взять побитого
ели, в плюсах это вот такая вертикальная одна палочка. Ну это, наверное, вы и без меня знаете.
Значит, третье пересечение. Здесь все то же самое, не буду это переписывать. Чтобы получить
пересечение, нужно, ясное дело, взять, наоборот, конъюнкцию побитого. Маск а, конъюнкция, маск b.
Давайте последнее нам, наверное, больше не понадобится. Разность множеств. Разность
множеств. То есть было a, было b. Мы хотим построить a-b. Обычная теоретика множественного
вычитания множеств. Вот, ну здесь есть много способов, конечно. Я привык к такому. Давайте
я его напишу. Здесь маск a, маск b. Я сделаю следующее. Я сначала возьму дизюнкцию, а потом
про ксориус b. Результат у меня будет такой. Маск а, ор, маск b, ксор, маск b. Вот так в плюсах
пишется. Работает это вот почему. Есть у вас два множества, a и b. Сначала я получаю их объединение,
то есть все, что вот здесь вот есть. А потом с помощью ксора, что такое ксор из одном на что другое. Ну,
это симметрическая разность множеств. Но если, ну мы же понимаем, что вот это вот, это под множество
вот этой штуки. Множество b целиком вложено в объединение a и b. Значит, когда я беру ксор,
я просто исключаю из этого объединения целиком b вот этот вот, я выкидываю. То есть это выкидываю,
и останется как раз разность a-b. Согласны? Вот, ну можно, конечно, по-другому. Можно было бы вот
здесь как-нибудь в этой маске все биты инвертировать, построить множество,
являющееся дополнением к маске b. Через тильду, например, да, есть оператор тильды, который
инвертирует все биты. И потом взять пересечение. Потому что разность — это пересечение множества
с дополнением к другому множеству. Согласны? Хорошо, ну еще раз подчеркну, что все операции
здесь работают за вот единицы. И более того, они все ну прям супер быстрые. Быстрее, чем битовые
вот эти вот операции or, xor и так далее. Никаких других там арифметических операций нет.
Хорошо, теперь вооружившись с этим арсеналом, давайте решим следующую задачу. Пусть будет один.
Дан полный взвешенный граф. Ну то есть n каких-то вершинок. И между каждой парой вершин есть стоимость
ребра. Сколько стоит денег добраться из одной вершины в другую? И так для каждой парой вершин
есть стоимость пути. Например, это там какая-нибудь карта страны, точка, вершина — это какой-нибудь
аэропорт. И вес ребра из одного аэропорта в другой — это сколько стоит денег там перелететь
из одного в другой. Куча всяких таких транспортных задач, они моделируются как раз таки взвешенными
графами. Вот, значит есть такой граф, полный значит, что между любыми двумя есть ребро. Какое-то
взвешенное с весом, то есть. Нужно найти самый дешевый гаметланов путь. Гаметланов путь, то есть такой путь,
который где-то начинается и проходит все вершины ровно по одному разу. Все вершины посетить ровно по
одному разу. Вот такая задачка. Есть граф, вам нужно, давайте какой-нибудь пример нарисую. Скажем,
вот граф на четырех вершинах. Вам нужно найти какой-то путь, который все вершинки посещает и
ровно по одному разу при этом. Например, что-нибудь вот такое подойдет. Такое ребро, потом такое,
потом такое. Пожалуйста, на путь все вершины ровно один раз посещены. И среди всех таких путей я хочу
найти самый дешевый. То есть, не знаю, я турист, хочу посетить все города, при этом мне очень не
нравится, когда я дважды бываю в одном и том же городе. При этом, понятно, я хочу сэкономить
либо деньги, либо время. Поэтому мне нужно найти минимальный по весу гаметланов цикл. Значит,
эта задача в такой постановке NP трудная. В том же смысле, в котором NP трудный был рюкзак у нас.
Я говорил, что задача в рюкзаке не решается пока что, пока никто не умеет решать задачу в рюкзаке
за время полиномиальный от размера входа. То есть, у нас там был псевдополиномиальный алгоритм за n
на w. Но, напоминаю, поскольку w это не полином от длины, вот количество битов во входе, это
не полиномиальный алгоритм. То же самое здесь. Пока никому на планете не известно, как решать эту
задачу за полином от числа вершин. То есть, ни за n в квадрате, ни за n в пятой, ни за n в десятой,
никто это решать пока не умеет. Ну или, по крайней мере, нам не признается в этом. Вот. Ну, для нас
как бы вот это словосочетание NP трудное, значит как раз, что пока нет надежды решать за полином.
Поэтому будем решать за экспоненту. И здесь нам будут нужны маски. Давайте у меня будет такой
вопрос. Вот смотрите, пусть мы как-то начали наш путь, какие-то вершинки посетили, где-то
закончились. Есть начало, есть какой-то путь, есть конец. Теперь вопрос. Чтобы продолжить наш путь,
чтобы продолжить этот путь, какой информации о вот этом вот начале, об этом префиксе пути
мне достаточно? Что достаточно хранить, чтобы однозначно понимать, куда я могу пойти дальше?
Все посещенные, да, и про вершину сказали. Ну да, на самом деле, действительно, все, что мне нужно
хранить, это номер последней вершины и множество посещенных. Давайте напишу так. Состояние, состояние
характеризуется номером последней вершины и множеством посещенных. Множеством посещенных.
Зная это, я понимаю, что отсюда я могу пойти в любую другую, которая еще не было в этом множестве.
Ну и, соответственно, пересчитать наш путь. Так вот, давайте заведем такую динамику. Пусть динамика
от последней вершины и маски, это минимальная возможная стоимость пути, которая где-то начинается,
проходит все вершины этой маски ровно по одному разу и заканчивается в V. То есть вот фиксируем
эти параметры и найдем минимальную длину такого пути. Нам же нужно самый дешевый путь. Вот давайте
с такими параметрами найдем самый дешевый путь. И как раз за счет того, что мы ввели в соответствие
между множествами и числами, мы сейчас будем это очень легко хранить. То есть вот это множество,
вот этот множество вершин, мы не будем хранить там, как, не знаю, перечисление элементов, мы будем
хранить одним числом, просто маской, и затем с ними работать вот так, как у нас было вот эти вот
всякие анды, булевые сдвиги и так далее, битовые сдвиги и так далее. Пусть dp в это маске это минимальный
вес гаметлиного пути, sorry, просто пути, который заканчивается в V и посещается до шины из маска
ровно по одному разу. Так, ну все, свели такую динамику, дальше пересчет здесь довольно тривиален.
Начинаем с базы. База, это когда у нас есть пути с одной вершинки, то есть мы куда-то встали,
из нее начинаем, и пока никуда не пошли. Тогда база будет такая, значит dp Vt 2 в степени V это 0,
потому что мы можем начать в любой вершинке V, давайте подпишем что-то, любой V, можем в ней начать,
тогда множество посещенных, это просто сама эта вершинка V, и это соответствует маске 2 в степени V.
Мы знаем, что если мы какую-то множество посетили, то чтобы понять, какой маска 4000FA
соответствует множеству. Нужно просто сложить соответствующей степени 2.
Если мы посетили вершинки V1, V2, etc. и Vk, нужно сложить два в степени V1
плюс secondly два в степени Vk. Соответственно, эта маска соответствующая в точности множеству
из одной вершинки. Это понятно? Просто в двоечной записи у нас есть bit только на V этой позиции,
это как раз вот эта вот 2 в степени V. Соответственно, мы не знаем,
начало, это может быть любая вершинка v. Вот, а дальше переход такой. Переход, давайте у меня
будет dp вперед. Есть dk вперед, а у нас dp вперед. Значит, пусть мы фиксировали v, и пусть мы
фиксировали много что вершин, которые мы посетили, маск. Много что посещенных маск. Попытаемся
продолжить этот путь одним ребром. Ну, просто тогда переберем, какие здесь исходящие ребра.
Скажем, в u мы попытаемся попасть. Тогда как меняется наша dp? Ну, понятно, последняя вершинка
раньше была v, теперь станет u, потому что мы сделали один шаг, путь продлился, последняя вершинка станет
u. А маска посещенных тоже, очевидно, как поменялась, в нее просто добавляется это u. Вот была старая
маска, мы посетили одну новую, поэтому здесь будет маск в объединении с множеством из одного вот
этого элемента u. Ну, тогда переход будет такой. Вот если у меня фиксирована v и маска, я просто
перебираю все возможные продолжения пути, то есть я перебираю все вершинки от 0 до 0,1. Дальше,
если я могу сделать такой переход, то есть если u не лежало в маске, потому что если u лежало в
маске, то я не могу вернуться, мне нельзя посещать то же самое два раза. Значит, если неверно,
что bit маск u, тогда мы сделаем следующее. Так, я, к сожалению, вот туда перейду, не умещаюсь.
Что? Ну, давайте. Если тут буду писать видо всем, давайте попробуем. Значит, если u не лежало в
маске, тогда давайте заведем новую маску newMask. Это вот как раз дополнение маски новой вершинкой
u. То есть маск or 1 меньше-менше u. Ну, понятно, вот эта вот штука, это как раз маска, отвечающая
только вершинкой u, и мы их поорили, то есть получили объединение. Ну и теперь мне нужно обновить
dp u newMask minimum из того, что там уже лежало. И, соответственно, стоимостью того пути,
который я только что построил, это dp vtMask плюс стоимость ребра из v в u. Давайте напишу
плюс кост из v в u. Я считаю, что есть какой-то массив, который для каждой пары вершин говорит
стоимость ребра между ними. Значит, я сначала добрался до v, посетив маску, и потом вот это
последнее ребро приклеил. Понятное дело, что стоимость стала ровно вот такой. Кажется,
все. Вот такая формула пересчета. Согласны? Ну, то есть просто если у меня фиксировано множество
посещенных и последнее, то я перебираю, какая будет следующая, не лежащая в маске обязательно.
Неверно, что в маске этот бит включен. Ну и дальше просто вот доклеиваю одно последнее ребро из v в u.
Так, форма пересчета есть. Теперь порядок. Начну с порядком. Здесь все тоже несложно. Смотрите,
мы понимаем, что нам как бы нужно перебирать маски в порядке включения, что ли. То есть вот если
я нахожусь в маске, то из нее я делаю ходы только в ее надмножество. Вот была маска раньше, а теперь
я новую вершинку вставил, то есть попадаю в маску, которая является ее надмножеством,
которая ее содержит. И поэтому вот здесь, когда я вот здесь пишу цикл for-mask, for-v,
мне как бы их нужно перебирать в порядке включения. На самом деле для этого достаточно
просто их перебирать в порядке возрастания. Маск от 0 до 2v на минус 1, v от 0 до n минус 1.
И потом вот это вот то, что у меня здесь написано. Ну действительно, почему достаточно такой порядок,
почему достаточно перебирать маски в порядке возрастания. Единственное, что мне нужно в такой
динамике вперед, это что когда я дохожу до какой-то маски, то есть когда я дохожу вот
здесь вот до этого цикла с параметрами mask и v, мне нужно, чтобы dp mask v было корректно
определено, потому что я через него насчитываю какие-то большие маски. Но чтобы оно было
корректно определено, единственное, что мне нужно, чтобы все меньшие маски были рассмотрены до нее,
точнее все подмножество ее. Потому что я делаю переход из маски в new mask расширением по
какому-то биту. Значит, чтобы mask, dp в этой маске было корректно насчитано, мне нужно, чтобы все
подмножества были перебраны. Ну понятно, что они будут перебраны, потому что подмножество маски
это число меньшее, чем маска. Вот есть маска какая-то, битовое число из 0 единиц. Подмножество
это когда вы какие-то единички заменяете на нули в двуечной записи. Берете подмножество, соответственно
какие-то элементы выкидываете, у вас получается битовая строка, в которой какие-то единички заменины на нули.
Ну значит, это просто меньшее число. Просто по значению вот этой битовой строки это меньшее число.
Значит, действительно, вот такая форма, такой порядок пересчета будет корректен опять из-за того,
что все меньшее, как бы все подмножество маски к моменту рассмотрения маски уже будут перебраны.
Они будут меньше по значению, значит уже перебраны. Понятно? Еще раз?
Ну можно соединиться, действительно. Пустой маски у нас никогда не будет. Давайте соединиться.
То есть это скорее неважно. Давайте вставим, что изначально мы считаем, что dp любое-любое
это плюс бесконечность. Считаем, что изначально нет ни одного пути, который бы заканчивался в какой-либо
вершине и поищал бы какую-либо маску. То есть изначально все плюс бесконечность, потом заполняем
нулями вот эти вот пути длиной 1, а дальше, ну вот здесь вот в этом форе вложенном тройной фор у меня будет
маска v и потом u. Ну вот здесь скажем, если вот эта штука бесконечность плюс бесконечность, то здесь
ничего не произойдет. Поэтому, как бы в принципе, если мы попадаем в что-то неволидное, например, когда здесь
маска нулевая, такого не может быть, или, например, v не лежит в маске, такого тоже не может быть,
тогда просто вот это значение плюс бесконечность и никаких дополнительных случаев не возникает.
Мы просто пытаемся какое число релаксировать плюс бесконечностью. Ну, это ничего не сделает просто,
ничего плохого в этом нет. Вопросы? Не обязательно, потому что, смотрите, если я изначально всю ДПшку
заполню плюс бесконечностями, то тогда, если вы не в маске, то там по-прежнему будет плюс бесконечность,
потому что такое невозможно получить вот такими переходами. А значит, еще раз, вот это просто плюс
бесконечность, и что бы я ни делал, вот эти строчки по сути эффективны, они ничего не сделают,
ну, в частности, ничего плохого. Поэтому можно это явно не проверять. Но если там хотите чуть-чуть
улучшить, то действительно можно вставить проверку, если не бит маск v, тогда continue. Это можно вставить,
это будет чуть быстрее работать, ну а симпатичное улучшение не получите.
Дальше идем? Давайте померим асимптотику здесь. Считается очень просто. У нас 3 вложенных цикла,
первый по 2 в степени n, второй по n, третий по n, и внутри пересчет за вот единицы, потому что все вот
эти вот штуки, взятие ора, взятие минимум, взятие суммы, это работает за вот единицы. Поэтому асимптотика,
конечно же, 2 в n на n квадрат времени, ну если интересно, то 2 в n на n памяти. Вот такой очень,
казалось бы, неэффективный алгоритм с точки зрения того, что там все, что у нас было до этого,
было все-таки скорее полиномиальным, по n, по числу вершин, по длине массива, были какие-то
полиномы или даже логарифмы. А здесь вот возникает экспонент, 2 в степени n. Ну это еще раз из-за того,
что пока никто не умеет решать это сильно лучше, чем экспоненты. То есть там за какие-нибудь,
не знаю, n в степени log n, возможно, кто-то и умеет, но даже это не полином. За полином пока никто не умеет.
Окей. Так, ну это значит, мы нашли самый дешевый гамметлинов путь. А, да, давайте ответ еще напишем.
Мы написали все, что нужно, кроме того, где лежит ответ. Ну, ответ, понятно, какой. Значит, что такое
ответ? Это гамметлинов путь, то есть он должен постить все вершинки. Ну, значит, маска это все
единички, да, маска это все единички, но последняя вершина может быть какая угодно. Поэтому давайте
возьмем минимум по всем возможным последним вершинам dp vt. А вот здесь мне нужно написать условия того,
что все вершины посещены. То есть это двоичное число, состоящее из всех единичек, но это просто 2 в степени n-1.
Вот эта штука в двоичном представлении, это просто 1, 1, 1, 1, 1, n раз. Поэтому, не зная последнюю
вершинку, мне нужно ее просто перебрать, а маска всегда должна быть ровно такая. И это будет как раз таки
самый дешевый гамметлинов путь. Хорошо. Ну, еще на семинаре будет упражнение. Граф невзвешенный,
и нужно просто найти, значит, надо проверить, существует ли хотя бы один гамметлинов путь.
Гамметлинов путь. То есть уже не гарантируется, что граф полный. Граф не обязательно полный,
потому что если он полный, то понятное дело, в нем есть гамметлинов путь. Нужно из первой пяти во
второй, из второй в третью, и так далее в n. А если граф не обязательно полный, то задача
обнаружения в нем, ну или проверка существования в нем гамметлиного пути, это тоже сложная задача.
Вот. И здесь получится, ну то есть это тоже непотрудная задача, ее никто не умеет
решать за полином. Вот. И здесь можно решить за чуть лучшую асимптотику 2v на n. И вот часто,
да, когда мы решаем что-нибудь с помощью такой динамики по маскам, динамики по подмножествам,
даже вот это вот улучшение от n квадрата к n может нам, ну как бы чуть-чуть нас продвинуть. То есть
понятно, что основной множитель это, конечно, 2v, он сохраняется, никуда не девается здесь,
к сожалению. Вот. Но вот дополнительный множитель этот можно чуть уменьшить. Было n квадрат,
стало n, ну задача чуть упростилась. Ну то есть тут надо было самый дешевый из большого множества,
здесь нужно просто узнать, есть ли хотя бы один. В каком-то смысле задача стала проще, поэтому
асимптотика стала чуть меньше. Вот. Ну такое как бы может быть полезно, уменьшение вот степени
при n-ке может быть выгодно там, не знаю. Если раньше вы умели решать задачу для n там не больше
20, то теперь для n не больше 23 можете решить, например. Что имеем? Так, окей, тогда едем дальше.
Ко второй задаче переходим. Это будет задача о максимальной клике. Опять у нас есть граф,
уже не обязательно полный, веса нам не нужны, ну то есть просто вот какая-то картинка, что между
какими-то вершинами есть ребра. В данном графе нам нужно найти в нем максимальную клику. Клика
это множество вершин, которые попарно соединены между собой, которые попарно смежны. Например,
вот клика размера 3, треугольник, вот клика размера 4, вот клика размера 5, ну и так далее. То есть
это несколько вершин в графе, которые попарно соединены ребрами вот в исходном графе, которые
попарно имеют между собой ребро. И нам нужно найти максимальную клику, ну то есть клику максимального
размера. Максимальное количество вершин. Ну с точки зрения каких-то приложений можно сказать,
что клика это когда у вас есть у вас какие-нибудь друзья, вершинки это люди, ребро это отношение
дружбы, вы хотите на вечеринку позвать какого-то множества людей, чтобы все были со всеми знакомы и
дружили, чтобы никому не было грустно. Вот тогда вам нужна клика на самом деле, что все друг друга
знают, попарно и всем весело. Окей, значит это тоже НП трудная задача. И здесь надеяться на что-то
дополнительное не получится. То есть хоть у меня там N вершин, но ни за N в квадрате, ни за N в сотой,
за N в степени константа никто пока решать не умеет. Как обычно с этими задачами. Поэтому имеет
смысл рассматривать какие-то экспоненциальные алгоритмы, перебирать под множество и соответственно
использовать ДП по маскам. Начну здесь давайте разберем несколько решений. Решение первое. Самое
тупое решение, пожалуйста, предложите мне. Полный перебор. За сколько это работает? Ну N факториал
это слишком, но 2 в степени N на N квадрат действительно то, что нам нужно. На самом деле факториала
нет, потому что нам не важен порядок, нам важно только множество элементов. Факториал это когда у
вас порядок важен, когда вы все пересновки рассматриваете. Значит это просто полный перебор.
Полный перебор всех под множество. Всех под множество. Ну 2 в степени N как раз таки возникает от
перебора. Мы знаем, что вот если мы, значит, у нас есть соответствие между множествами и числами,
между масками, да, мы просто перебиваем все возможные маски. Каждая маска соответствует
кому-то множеству. Ну и дальше внутри этой маски проверяем за квадрат от ее размера то, что это
действительно клика, что все вершины внутри этой маски попарны средней ребрами. Ну то есть это перебор
маски, это проверка того, что это клика. За квадрат просто всех перебираем, проверяем, что есть ребро.
Окей? Второе решение. Пока что никакой динамики даже нет. Второе решение. Давайте мы ведем динамику
буллевскую. Она для каждой маски хранит флаг true или false в зависимости от того, является ли эта
маска кликой. Это true, если маска это клика и false иначе. Тогда как эту динамику можно насчитывать?
Вот рассмотрим какую-то маску, какое-то множество, какое-то множество вершин. Я хочу понять, правда ли,
что между всеми парами вершин в этом множестве есть ребро. Это можно сделать, например, так. Давайте
мы какую-то вершинку исключим из этого множества, ну просто назначим ее особенной. Тогда чтобы все
было кликой, мне нужно, чтобы во-первых, V была соединена со всеми из остатка, во-вторых, остаток был
кликой. Это необходимое достаточное условие. Что вот здесь, во-первых, клика, то есть что не все между
собой соединены, а также что V с ними со всеми соединена. Ну давайте это напишем, что пусть V это
произвольная вершина из маски. Я вот так немножко вольно пишу, что V принадлежит маске, ну по сути это
число, но мы знаем, что числа и множество, когда мы говорим про маски, мы понимаем, что это по сути
множество, поэтому я позволю себе такую запись, что число лежит в маске в множестве. Вот тогда dp
маск равно true, если только если. Во-первых, dp маск XOR2 в степени V это true, то есть маска после
выкидывания вершинки V является кликой. Это как раз маск XOR2 в степени V. И во-вторых, V соединена со
всеми из вот этой вот маски. V соединена со всеми из вот этой вот маски. Маск XOR2 в степени V. Давайте.
Давайте подумаем. То есть мы проявляем, что вот эта клика, потом проявляем, что вот эта вот клика,
и это в частности, ой, это интересная идея, да, я о таком не думал. Сейчас, момент. Ну похоже на
правду, да, кстати, действительно. То есть смотрите, если мы вместо вот этой одной вершины будем пытаться
откусывать две и проверим, что значит вот эта вот клика, то есть все без V это клика, потом все без
U это клика, то единственное ребро, которое мы не проверим, это то, что это ребро между U и V.
Тогда давайте его проверим, еще завод единицы, будет переход, получается, завод единицы. Да,
действительно работает. Согласен. Давайте я это добью, ладно. Действительно, тогда это
будет за два степени N решение. Вы правы. Тут чуть больше надо думать. Тут чуть меньше.
Да, собственно, а что тут осталось-то сказать? Ну осталось понять, что вот это вот условие можно
проверить за U от N. Потому что смотрите, что мне нужно, мне нужно в маске найти какой-то бит,
какую-то вершинку, лежащую в этом множестве. Проверить вот этот за вот единицы, и потом проверить,
что V соединяется всеми из этого множества. Но это еще и линия. У меня есть вершина,
у меня есть какое-то множество вершин, мне нужно проверить, что есть ребра отсюда во все вот эти.
Но это линейное время, потому что размер вот этой маски линейен.
Я просто для каждого элемента отсюда проверяю, что есть ребровая.
Это линейный проход. Получилось у меня решение за 2n на n квадрат.
Сорри, на n, на n, конечно.
2n и на n.
Потому что всего 2n масок, и у каждой вот этот флажок
выставляется за линейное время от ее размера, от n в худшем случае.
Третье решение.
Наверное, достаточно было бы написать то, что вы предложили,
что можно откусывать ни одну вершинку, а две сразу.
И проверить, что получаются клики оба раза, и что есть ребро между U и V.
Давайте я немножко другой подход расскажу, там будет полезная идея.
Даже две полезных идеи.
Давайте, во-первых, считать, что V это старший бит в маске.
Старший бит в маске.
Мы же сказали, что нам неважно, какую вершину откусывать.
Можно любую отбросить и проверить те условия.
Давайте считать, что это старший бит.
Просто самая левая, самая значящая единица, у которой степень двойки наибольшая.
Тогда вот этот V можно насчитывать следующим образом.
Давайте я заведу переменную oldis, которая равна номеру старшего бита в текущей маске.
Если я буду приводить маски в порядке возрастания, то вопрос, когда у меня меняется старший бит.
Когда я просто к маске приворачиваю единичку, у меня старший бит обычно не меняется,
он меняется только, если вот эта вот старшая единичка перекидывается в старший разряд.
Но это может быть только, если все правей нее были единицами.
То есть на самом деле oldis увеличивается, только если мы пришли в новую степень двойки.
Это как проверить, что число является степень двойки, мы с вами уже когда-то делали.
Если не маск, и маск минус один, тогда плюс-плюс oldis.
Эта штука всегда, после этого if, значение в oldis равно индексу самого старшего бита в маске.
Почему? Изначально у меня минус единичка, затем я попадаю в маск равно единице.
Маск равно один, я понимаю, что это степень двойки.
Например, я андио единицу и ноль, получаю ноль, поэтому это условие выполняется.
Я oldis увеличиваю, будет oldis равно нулю.
То есть как раз когда маск равно единице, у меня oldis показывает на единственный включенный старший бит.
На два в нулевой. У меня будет oldis равно нулю.
Ну и потом, когда я дальше иду по этому циклу, у меня маск, точнее oldis увеличивается,
как только маск становится степенью двойки.
Вот это условие, которое у нас было, когда мы спаррстейбл писали.
Мы, кажется, там ровно так и делали.
Нам нужно было в спаррстейбле для каждого k знать максимальную степень двойки,
которая его не превосходит, и там делается ровно то же самое.
Нам нужно, по сути, хранить старший бит.
Это делается так.
Тогда будем использовать oldis вместо v.
Поскольку нам достаточно использовать любой бит, давайте использовать старший.
Нам не важно какой, но для удовольствия будем использовать старший.
У нас есть вот это v за вот единицы.
Для каждой маски мы знаем вот этот вот v, точнее oldis, за вот единицы.
Нам не нужно проходить по маске искать какой-то бит, нам он уже известен.
У нас он лежит в перемене oldis.
Что осталось? Осталось понять вот это второе условие.
Правда лист этот oldis соединен со всеми вершин веського там множества.
Для этого сделаем следующее.
Для каждой вершины мы изначально предпочитаем маску всех ее соседей.
Изначально найдем маску всех ее соседей.
Пусть это будет массив neighbor от u.
Это те, кто с ней соединили ребром.
Те, в которые есть ребро из u.
Тогда, чтобы проверить, что какая-то вершинка v соединена со всеми из какого-то множества,
вот то условие давайте перепишем.
v соединена со всеми из какого-то множества маск.
Давайте я маск-штрих это назову.
Это то же самое, что маск-штрих вложено в это множество.
Маск-штрих вложено в neighbor от v.
Вроде очевидно.
Если это множество всех соседей, то есть множество всех вершин, связанных с v,
мне нужно проверить, что v соединена со всеми отсюда.
Они все должны быть соседями.
В них во все должно быть ребро.
Поэтому должно выполняться такое включение.
Это должно быть под множеством этого.
Теперь вопрос, как проверить, что одна маска является под множеством другой.
За от и днице.
Да, можно так, действительно.
Тут опять можно действовать как угодно.
Давайте напишем то, что предложили.
Это то же самое, что маск-штрих минус neighbor от v, пусто.
Я напишу равно нулю, как число.
Ноль – это пустая маска.
Действительно, одно это под множеством другого,
если после вычитания из этого и этого никого не остается.
Иначе есть кто-то, соответственно, первое не под множеством второго.
Можно так, можно любым другим способом, как вам удобно, так и напишите.
Главное, что это работает за от и днице,
потому что все битовские операции, разности много, что мы уже писали.
Хорошо.
И значит, вот эту проверку мы теперь умеем делать за от и днице.
У нас есть v равное oldest, у меня есть вот эта вот маска,
и у меня есть уже насчитанная маска соседей neighbor от oldest.
Я просто за от и днице проверяю это условие,
и тем самым я понимаю, правда ли, что oldest связана со всеми из вот этого остатка.
Зная это, я знаю, правда ли, что маска – это от и днице.
Я понимаю, что это от и днице,
и из вот этого остатка.
Зная это, я знаю, правда ли, что маска – это клика.
Получится решение за 2 в степени n, чистое, без всяких множителей,
потому что я просто перебираю все маски.
Для каждой маски у меня известен oldest, за от и днице,
и потом еще за от и днице я проверяю, что вот это вот второе условие,
тоже за от и днице, потому что это проверка, что одно множество вложено в другое.
Профит. Получили ту же асимптотику, что вы предлагали,
но чуть по-другому.
Но здесь две приятные идеи.
Во-первых, oldest мы научились считать, то есть какой-то конкретный бит в маске.
А во-вторых, в каком-то смысле научились проверять,
что v связана со всеми из-под множества.
На что? Множество вложено в множество ее соседей.
Вопросы?
Окей.
Что значит значение?
Нет, смотрите, нам не обязательно.
Нам в качестве oldest на самом деле сгодился бы любой бит, который лежит в маске.
Здесь?
Нет, нет, это не идея, это прям решение.
То есть смотрите еще раз.
Здесь, в том решении, которое я только что стер,
мне нужно было вместо oldest использовать произвольную вершину,
которая есть в маске, и для нее проверять, что после ее отбрасывания есть клика,
и она со всеми соединена.
Но смотрите, я там сказал, что вместо v, то есть в качестве v,
можно брать любую вершину из маски.
И чтобы ее хранить, чтобы ее находить за вот однице,
можно в качестве v использовать просто oldest.
Да-да-да, это поиск какого-то бита из маски. Все верно.
Как вы думаете?
Ну, z², на самом деле.
Потому что, ну давайте заведем массив вот этот neighbor,
заполним его изначально нулями.
Потом пройдемся по всем ребрам u и v,
и скажем, что в neighbor от u надо включить v,
а в neighbor от v включить u.
Это делается за вот однице.
То есть, каждое ребро зовут однице,
и расширяет нам вот эти два множества
для каждого из концов этого ребра.
Ну и тем самым мы просто все ребра проходим
и neighbor от всех машин насчитываем.
Похоже на правду?
Окей.
Ну, поэтому, да, поэтому это
пренебрежимая маленькая вещь по сравнению с основной 8-м точкой,
2v, поэтому мы здесь пишем только 2v,
пренебрегая временем на предподсчет.
Квадрат меньше, чем 2v,
для всех, ну там, сильно меньше,
чем 2v, для всех, начиная с некоторого.
Окей.
Так, тогда следующее решение
еще круче.
У нас получится за 2 в степени
пополам на n.
Раньше у меня было все время 2 в степени n,
а теперь будет 2 в степени всего лишь n пополам.
Это очень
хорошее улучшение,
потому что, ну, например,
вот здесь, когда у меня было n равно 20, у меня здесь
было 2 в 20, это там, ну, миллион операций,
примерно. А здесь при n равно 20
будет всего 2 в 10, это тысяча операций
всего лишь.
Ну и, соответственно, там, не знаю, для n равно
30-и, 40-ка, уже только это решение
будет укладываться в секунды,
в единицы секунды в смысле, то уже будет работать,
не знаю, десятки, сотни секунд, наверное.
Ну и вообще, давайте такой вопрос,
совсем простой.
Я могу сказать,
что 2 в n пополам на n
есть... Ой, наоборот,
ну, нет, ладно, нормально.
Есть т,
а 2 в n на n.
Ну, потому что, как мы любили говорить,
мы говорили, что если есть какая-то константа
мультипликативная, то ее
можно убрать, это не влияет на порядок роста.
Вот. Ну, а здесь константы
как бы в показательной степени.
Можно так сказать?
Ну, нельзя, конечно.
Потому что вот это и вот это
разные по скорости роста функции,
потому что вот это, это, по сути,
корень из 2 степени n, можно так записать.
Корень из 2 степени n.
А это, ну, 2 в n-й.
Ну, понятно, что это растет сильно быстрее, чем это.
Если хотим формально доказать,
то можно рассмотреть их отношения,
получится корень из 2 в n-й, отношение
получается к нулю, ну, или там, к бесконечности.
То есть, если мы поделим вот это на это,
получим бесконечно большую функцию, значит,
ну, точно не может быть, что ни одного роста.
Не может быть у них одинаковый порядок роста, это растет быстрее, чем это.
Вот. Ну, это такое
воспоминание
Маттана.
Значит, мы сделаем следующее.
Мы разобьем
нашу множество вершин исходной на 2 множества
размером пополам.
Давайте я для удовольствия считаю, что n-четная.
Разобьем исходное множество
на 2 множества размера n пополам.
Тогда, как устроена любая
клика в исходном графе?
Значит, это какой-то кусочек
здесь, какой-то
кусочек здесь. Давайте их
назову u и v. Ну и какие
на них требования? Во-первых, оба множества
сами по себе являются кликами.
То есть, все, между всеми парами
вершин вот здесь вот есть ребро,
между всеми парами вершин вот здесь вот есть ребро,
ну, а еще есть ребро из любой вершинки u в
любую вишенку v. Значит, клика, давайте напишем три условия, что, во-первых, u – это клика, во-вторых, v – это
клика, в-третьих, для любого u из u, для любого v из v есть ребровая ве, у и v с одни ребром.
Вот, собственно, критерии того, что этабенение является кликой. Хорошо.
Так, да, давайте сделаем следующее. Давайте мы для каждого множества вершин слева, для каждого
подмножия вершин слева, вот пусть это какое-то u, переберем u. Во-первых, мы понимаем, что u должно
быть кликой, поэтому слева достаточно перебирать только клики. Во-вторых, мы понимаем, что в качестве
v, в качестве дополнения к клике вот этого множества, можно взять только некоторые вершины отсюда,
а именно те, которые соединились со всеми из u. Вот какое-то есть такое большое множество, это кандидат
на v. Это те вершины, которые соединились со всеми отсюда. Ну и тогда, если мы обеспечили, получается,
первое и третье условия, нам достаточно будет из этого множества взять максимальную клику. Потому
что, еще раз, мы обеспечили, что это клика, мы обеспечили, что каждая вершина отсюда соединяется
с каждой из u, поэтому последнее, что осталось сделать, это выделить здесь под клику. Первое и третье
условия же выполнено, осталось здесь найти максимальную клику, чтобы сумма размеров u и v была
максимально возможна. Поэтому, значит, нам нужны три вещи. Во-первых, для каждого множества слева
понять, клик это или нет, ну это просто мы это уже делали, да, там какой-нибудь динамикой за два
в степени размера этого множества. Значит, для каждого u определяем, клик это или нет. Затем,
для каждого u мне надо понять вот это множество, вершин справа, которые соединились со всеми из u.
Давайте я это назову какой-нибудь там dp штрих от u. Это множество, маска, точнее, маска вершин
правой доли, каждая из которых соединена со всеми вершинами u, со всеми вершинами из u. Вот,
значит, мне нужна такая динамика, чтобы находить вот это вот облачко. И дальше внутри этого облачка
мне нужно выбрать максимальную клику. То есть мне нужна еще третья такая динамика, которая для
каждого вот этого множества справа сообщает мне размер максимальной под клики, ну или там саму
эту клику, да, как множество вершин. Давайте еще скажем, что dp какой-нибудь там два штриха w это
размер максимальной под клики в маске w. Размер максимальной под клики в маске w. Это речь идет
про правую долю, правая доля. Вот, если мы все это насчитаем, то еще раз, я просто перебираю за два
в степени пополам клику здесь, фиксирую какую-то клику u здесь. Затем с помощью dp штрих я знаю,
кого можно добавить к ней, чтобы получилось клика во всем графе. dp штрих от u насчитываю. Дальше
внутри этого dp штрих от u мне нужно еще dp два штриха навесить, чтобы узнать размер вот этот
максимальные клики внутри этого множества. Тогда как раз получится то, что нам нужно. Для этого u мы
нашли максимальное по размеру v, которое дополняет его до клики. Вопросы? Хорошо. Давайте я скажу,
что вот этот подход, который мы сделали, разделить пополам и что там сделать, называется meet in the middle.
То есть поделить пополам, решить там как-то на половинках и потом склеить ответ из двух половинок.
Итак, нам нужно насчитать вот эти две динамики dp два штриха.
Здесь все несложно. Давайте мы скажем изначально, что dp... Давайте скажем следующее, что пусть слева
n вершин. В левой доле n вершин, а справа m. И внутри каждой доли вершины занумерованы от 0 до размера
минус 1. То есть слева вершинки 0 и так далее и минус 1, справа 0 и так далее m минус 1. То есть у нас
как бы такая повторяющая нумерация. Слева от 0 до m минус 1 и справа от 0 до m минус 1. Ну что
такое dp штрих, скажем, от 0, от пустой маски? Вот есть у меня пустая маска, пустое множество u,
какое там множество слева? Вопрос, как выглядит маска вершин правой доли, каждая из которых
соединяется всеми вершинами из u, где u пустое множество? Конечно, да, это просто 2 в степени m
минус 1. Все вершины справа соединены со всеми вершинами с пустого множества. Ну это просто
предикат, который всегда верный, поэтому любая вершинка здесь подойдет. Значит, мы в качестве
dp штриха от 0 храним просто все правое множество, всю вот эту правую долю. Хорошо, ну тогда давайте
считать, что... ну как найти какой-нибудь dp штрих от маски какой-нибудь? Вот есть маска у меня здесь
в левой доле. Надо понять, с кем она... точнее, каково множество вершин справа, которые со всеми
отсюда соединены. Ну давайте поступим так, как мы уже делали. Давайте мы откусим какой-то бит
из этой маски, пусть это будет oldest. Неважно какой, вот пусть для удобства oldest, потому что его
легче всего насчитывать. Давайте этот oldest откусим из нашей маски. Тогда как поменяется множество?
Вот если, скажем, я знаю ответ для маски без oldest, это какое-то надмножество, понятное дело. Потому
что, вот если я, скажем, из маски здесь слева удалю вот этот бит единственный, oldest, тогда множество
вершин справа, которые соединиться всеми вот отсюда, оно может, понятное дело, только увеличится.
Потому что здесь как бы новое условие добавляется, что мне нужно еще, чтобы все они были соединились
с oldest. Поэтому я могу сделать следующее. Я могу отбросить oldest, найти dp штука для маски без oldest
и потом еще наложить новое требование, что они все должны быть соединились с oldest. Это делается так.
Значит, это просто-напросто dp штрих от маск без oldest, 2 в степени oldest, вот, and множество тех справа,
которые соединились с oldest слева. Ну, по сути, это просто neighbor от oldest. Нам не нужно вот
это множество сузить на множество тех, которые соединились с oldest. Ну, пусть это будет neighbor
от oldest. Вот это вот эта маска соседей oldest правой долю. Согласны?
Окей. Тогда эта форма пересчета зовут единицы. А для каждой маски мы знаем oldest, потому что мы
его насчитываем, так как было раньше. Значит, мы знаем oldest, и мне нужно просто взять старое
значение dp шки и поandить его с чем-то уже тоже насчитано. Ну, вот этот предпочет в самом начале делается
за квадрат. Просто для каждой пары вершин добавляем какую-то единичку в зависимость
запись этого neighbor. Все, это пока что за 2 в степени n пополам работает, потому что масок в левой
доле, ну, вот их примерно столько. Если размер это n пополам, n маленький пополам, тогда всего масок
вот столько. Каждый завод единицы считается, поэтому пока что время работы вот такой, 2 n пополам.
Так, ну, теперь осталась последняя часть. dp 2 штриха нужно насчитать.
Нет, мы именно что пересекаем, потому что, смотрите, вот у меня было старое множество,
вот это вот большое. Они были соединили со всеми вот из этого множества. А теперь мне нужно добавить
новое условие, то есть в дополнение к тому, что уже было, нужно добавить новое условие, что они
должны быть соединили вот с этой вершинкой. То есть мне нужно взять такое подножество вот того
большого, которое еще и вот с этим соединили, поэтому только and. Так, ну все, dp 2 штриха тогда,
да. Давайте я перепишу нашу постановку. dp 2 штриха от, давайте маски. Это следующее,
это размер максимальной подклики, который является под множеством маски. Максимальная
мощность множества, давайте я назову сабмаск, такое, что сабмаск это клика и сабмаск это
под множество маски. Сабмаск образует клику в правой доле, а еще сабмаск это под множество
маски. Вот так переписал. То есть из всех из тех под множеств мне нужно выбрать максимальный
размер так, чтобы это была клика. Хорошо, давайте тогда я еще немножко переформулирую эту задачу.
Давайте я для каждой маски ввезу следующую функцию. Значит, это ноль, если маска это не клика,
и мощность этого множества мощность маски, то есть по сути число единичек в этой маске,
если маска это клика. Иначе. Тогда вот этот dp 2 штриха я могу переформулировать в терминах
а чуть проще. Это просто максимальное значение а по всем подмаскам. Это максимум а от сабмаск,
где сабмаск, это под множество маски.
Я понял, сейчас, момент, момент, момент. Видимо действительно можем. Я опять рассказываю, что это
слишком сложно. Похоже на правду. Давайте я запишу то, что мне предлагается. То есть пока про это
давайте забудем. Но это опять скорее, скорее я просто свожу задачу к какой-то более общей,
более общую решаю, чтобы как бы мы научились решать более общие задачи на вот этих частных
примерах. Давайте напишем то, что вы сказали, тоже вроде работает. Значит, смотрите, как выглядит
вот эта вот подмаска, на которой достигается максимальный размер. Давайте посмотрим,
входит туда oldest или не входит, oldest исходной маски. Если не входит, то понятно, что нужно
просто взять dp 2-out маски без oldest. Давайте так и напишем dp 2-out маски. Это максимум из, во-первых,
dp 2-out маски без oldest. 2 в степени oldest. Либо мы его включаем в клику, но тогда мне нужно,
тогда будет взять под клику из множества его соседей. И еще нужно будет добавить 1 из-за
oldest. То есть будет, видимо, 1 плюс dp 2-о маск and neighbor от oldest. Правильно вас понял? Ну да,
можно. Действительно, мы просто рассматриваем два случая, входит ли этот oldest в нашу подмаску.
Если не входит, то задача сводится к более простой, когда этого oldest просто нет. Если входит,
то мы его насильно добавляем, и осталось нам найти максимальную под клику среди всех соседей
oldest. Ну вот, пожалуйста, по такой формуле это насчитывается, потому что это меньшая маска,
для нее уже dp 2-о насчитано, и это есть ответ. Окей, да, согласен, можно сделать так. Сейчас.
Вау, тогда мы получили решение, на самом деле, за 2 в n просто. Да, да, да, конечно. Прикольно,
я не знал, спасибо. Действительно, получится когда решение общей задачи за 2 в степени пополам.
Это 2 в степени пополам, это перебор под клик слева действительно такой. Согласен, хорошо. Но все-таки
я еще расскажу этот кусок про сведение к общей задачи, решение общей задачи. Собственно,
здесь у меня будет похуже асимптатика, но зато мы решим, какую задачу побольше,
которая тоже сама по себе интересна. Так, вернемся сюда. Что здесь я сделал, почему это верная формула?
Ну, потому что, когда я беру dp 2-о отмазки, по сути, что вот тут написано? Когда я беру все
под множество, у меня либо это не клика, тогда a это ноль, и она как бы на максимум не влияет,
либо это клика, с обмазкой это клика, тогда h от нее, это просто ее размер. Действительно,
здесь я как раз-таки выбираю максимальный размер под множество, который является кликой.
Вот, ну давайте тогда сделаем следующее. Так, кончились названия для dp-шки, пусть будет b.
b, kt, mask-t. Значит, это следующая вещь. Это опять-таки максимальное значение по всем подмазкам,
где с обмазкой это под множество маски. Но при этом это не просто под множество,
а такое под множество, которое гарантированно совпадает в первых k-битах. С обмазк и маск
совпадают в старших k-битах, в старших k-разрядах. Вот, значит, мы свели задачу к более общей,
и сейчас эту более общую решим с помощью такой динамики. То есть, мы когда фиксируем k-шку,
мы перебиваем не все под множество, а только те, у которых первый k-бит фиксирован. То есть,
если бы у меня была произвольная маска, я хочу перебрать все ее под множество, то здесь я
вот этот вот как бы заморозил, префикс длиныка заморозил, и перебираю только под маски,
которые вот здесь могут что-то менять. То есть, это у меня фиксировано, а здесь может что-то
быть поменено. Так, ну хорошо. Че нужно сделать? Да, ну, во-первых, база здесь будет вот такая,
видимо, m-1. Вот маски. Это просто out маски. Просто m, sorry, просто m. Напоминаю, m – это число
вершин справа. Значит, если я фиксировал все m-бит, то как бы, ну, единственная подмаска этой
маски, в которой все биты фиксированы, это, собственно, сама маска. Поэтому здесь нет
никаких случаев. Сабмаск просто равно маске обязательно, потому что у них совпадают все биты.
Значит, это просто out маски. Это будет такая база. Вот, а дальше будет переход, пересчет.
Значит, дальше будет пересчет. Следующий. Смотрите, давайте мы от k научимся пересчитать k-1.
Вот пусть у меня написано, пусть у меня насчитано bkt для всех масок, я хочу насчитать bk-1 для
всех масок. Изначально у меня k равно m. Смотрите, что такое? Вот пусть у меня есть какая-то маска,
и у меня фиксированы первые ее k-1 бит. Дальше у меня получается, по сравнению со случаем,
когда заморожены первые k-бит, у меня, по сути, возникает, ну, как бы, только одна степень
свободы – это то, брать вот этот бит или нет, в подмаску брать его или нет. Значит, ну, в случае,
когда здесь нолик стоит, когда вот этот cut и слева бит равен нулю, тогда, на самом деле,
никакой свободы не появилось, потому что если здесь ноль, то подмаска тоже вынуждена здесь
иметь ноль. Нельзя быть под множеством, поменяв здесь нолик на единицу, это будет как бы,
ну, расширение, да, какой-то новый элемент появится. Поэтому, если здесь стоял нолик, то на самом деле
можно считать не просто k-1 бит заморожено, а все k, потому что это нельзя менять. Давайте напишем,
какой номер у этого товарища? Всего их m, нулевой и так далее, m-1, тогда какой номер у вот этого вот?
Да, похоже, что этот бит имеет вот такой номер. Ну, если ты справа, да, мы номируем,
как всегда справа, тогда номер этого бита вроде как m-k, потому что, например, когда k равно 2,
у меня заморожен первый бит, я хочу взять второй, это как раз m-2, да, вроде верно. Ну вот,
значит, напишем следующее, что если неверно, что в этой маске включен этот бит m-k, тогда динамика
очень простая. Не динамика, а массив b. У меня b-k-1 mask t равно просто b-k mask t, потому что если
первый k-1 бит фиксированный, то следующий тоже фиксированный, он равен нулю. Иначе, если здесь
стоит единичка, то я могу его проварьировать. Могу поставить как нолик, так и единицу. Давайте
его переберу. Давайте насильно здесь поставлю ноль. Тогда, если я поставлю здесь насильно ноль,
то можно считать, что у меня замороженный первый k-bit, но маска стала маской без этого бита.
Если я ставлю здесь единицу, то можно считать, что у меня замороженный k-bit,
а маска осталась такой, какая была. Поэтому иначе я напишу следующее, значит b-k-1 mask
равно максимум из b-k-t mask, то есть это у меня остается. Это случай, когда я не меняю вот этот
вот бит. Кат и слева бит я не меняю. Могу считать, что он тоже замороженный, тогда у меня
получается вот dp отсюда. И второе, это когда я его меняю с единицы на ноль, маска тогда у меня
поменяется, станет маской без этого бита, mask xor 2 в степени минус k. Соответственно, я поменял
единицу на ноль и считаю, что опять первый k-bit заморожен. То есть я поставил здесь насильно
нолик, тогда первый k-bit как бы замороженный, я просто беру вот dp с k замороженными битами,
которые уже я посчитал. Вот вроде все. Ну и тогда ответ, это просто ответ,
dp 2 штриха для каждой маски, это просто-напросто b-нулевое маск. Потому что мне нужно по всем
подножиям взять максимум, и значение здесь ноль, значит, что у меня никакие биты не заморожены.
Я могу любые биты менять, тем самым я как раз таки возьму максимум по всем возможным подножиям,
у которых все биты какие угодно, главное, что это подножие маски. Вопросы?
Ну и вот собственно отсюда и берется 2 в степени m на m, потому что у меня вот эта динамика имеет
размерность 2 в степени m на m, а пересчет за единицу, потому что это либо просто какое число,
либо максимум из двух чисел. Поэтому вот эта вещь насчитывается у меня за 2 в м на m, но поскольку
я вспоминаю, m это размер правой доли, то это по сути просто 2 в н пополамтый на n. Ну на н пополам,
но половинку можно стереть. Получилось решение сложнее и медленнее, чем то, что вы предложили,
но зато мы как бы решили еще попутно более общую задачу, вот такую. То есть у вас есть просто
произвольный какой-то набор чисел, для каждой маски принадлежит своя ашка. И мы научились
считать максимум ашек по всем подножествам. Но это в принципе довольно интересно само по себе.
Так, есть какие-нибудь вопросы?
Не уверен, что сработает. Давайте немножко порисуем. Давайте на 3 хотя бы попробуем,
мне кажется уже с 3 будут беды какие-то. Вот есть 3 множества. Тогда мне кажется,
что чтобы все однозначно задать, вам нужно перебрать под множество здесь и под множество
здесь. Только зная и то и то, вы знаете, кого можно взять отсюда, чтобы они были со
всеми соедены и здесь нужно выбрать максимальную подклику. А если вы фиксируете, скажем,
только одно, вот это вот множество, только одно, тогда здесь в зависимости от того что будет здесь,
у вас это влияет на вот это. Поэтому не перебирать вот это не понятно как. То есть это возможно как-то
и доводится, и на самом деле что-то похоже, там еще чуть-чуть лучше можно симпатику улучшить,
в смысле уменьшить, но вот по крайней мере так с ходу непонятно, как это делать.
Так, ладно. Тогда давайте последние 10 минут обсудим немножечко динамику по профилю.
Так, не шибко подробно. ДП по профилю.
Ну давайте мы решим такую задачу. Есть у меня вот такая вот табличка n на m. Клеточная табличка
n на m. У меня есть доминожки 2 на 1. Могу их класть вертикально или горизонтально. Моя задача
это найти количество возможных замощений вот этой таблички, вот этой полоски такими доминожками.
Доминожками 2 на 1.
Вот замощение значит, что вы можете класть доминожки так, чтобы они не пересекались,
при этом каждая клетка была покрыта ровно одной доминожкой.
Вот. Это уже не n потрудная задача, но мы ее решим за, в общем, экспоненту от n. То есть на самом
деле там есть какая-то явная формула. Если у вас n фиксировано, то у вас есть формула явная для
ответа в зависимости от m, но мы с помощью динамики по профилю поймем, по крайней мере, как это считать
для каких-то маленьких значений. Итак, смотрите, вот давайте мы будем как-то заполнять нашу табличку
слева направо. Давайте считать, что у нас какой-то префикс уже заполнен, то есть скажем вот это вот
все уже покрыто доминожками как нужно. Но я не могу просто так провести вот такой вертикальный разрез,
потому что бывают горизонтальные доминожки, которые через него как бы за него выступают. То есть не
только у меня покрыто все левее этого разреза, но еще и какие-то точки справа. Так вот, давайте тогда
мы в состоянии динамики запомним следующее. В каких строчках происходит такое вылезание, то есть
в каких строчках находится горизонтальная доминожка, которая вылезает за нашу линию разреза. Ну и
соответственно номер столбца. Нам будет этого достаточно. Динамика будет такая, dp от номера
столбца и от маски. Давайте я не буду это писать словами. Вот что это значит. Это значит,
что мы рассматриваем только первый g столбцов нашей таблички. Только первый g столбцов. И они
целиком покрыты. То есть все, что вот эти вот первые g, они целиком покрыты. Но при этом могут какие-то
доминожки, лежащие вот в этом вот начале, вытарчиваться вправо. Это обязательно такие горизонтальные
доминожки. И мы считаем, что множество строк, в которых лежат вот такие доминожки, которые нам
как бы торчат вправо, заметают множество масок. Соответственно множество вот по вот этой вот,
ну множество строк. Множество по вот этому вертикальному измерению. Тогда если у меня фиксирована
какая-то маска. Давайте еще раз картинку нарисуем. Вот у меня фиксирован столбец. Фиксировано,
где происходит вот это вот торчание. Тогда вопрос, как я могу продолжить мою картинку так,
чтобы вот этот следующий столбец g плюс первый стал целиком покрыт, а дальше опять может быть
какое-то вытарчивание. То есть моя задача такая. Если у меня фиксирована g, то это значит, что у меня
первый g столбцов точно покрыты. А первый g точно покрыты. А в следующий g плюс первый может что-то
торчать вот, ну точнее торчит что-то из множества маски. Тогда, когда я расширяюсь жишкой,
перехожу на 1 вперед, мне нужно целиком покрыть вот этот появивший новый столбец. То есть тут уже
что-то покрыто за счет вытарчивания, но оставшие клетки тоже нужно покрыть. Вот. И опять могут
появиться какие-то новые торчащие клетки уже в следующем g плюс втором столбце. Поэтому мы будем
действовать как-то так. Мы фиксируем g и маску. Затем мы фиксируем множество, скажем, вот этих
доминошек, где будет происходить торчание в следующий столбец, а оставшиеся мне нужно тогда
покрыть вертикальными доминошками. Давайте это запишем. Давайте я хочу из состояния g,
маск 1, перейти в состояние g плюс 1, маск 2. То есть у меня в коде будет следующее. В цикле по g,
в цикле по маск 1, в цикле по маск 2. Я пытаюсь из этого состояния перейти сюда. Что это значит?
Давайте еще раз нарисуем. Вот есть g плюс столбец. Дальше множество строк, в которых происходит
торчание в следующий g плюс первый, это маск 1. Вот здесь у меня или там что-то лежит, вот здесь,
и вот здесь. Это множество, это маск 1. Дальше. Я хочу покрыть целиком вот это вот следующий столбец
g плюс 1 и при этом еще сделать так, чтобы в следующий торчало что-то из множества маск 2. То есть я
хочу положить горизонтальные доминошки, которые начинаются вот здесь и торчат сюда, в множестве
строк маск 2. Вот это вот будет маск 2. Я тем самым перебираю и маск 1, и маск 2. Тогда если у меня
это фиксировано, то есть у меня фиксирован множество доминошек, которые торчат из g в g плюс 1,
из g плюс 1 в g плюс 2, тогда на самом деле все, что мне остается, чтобы доза мастить в g плюс
первый столбец, мне остается здесь класть только вертикальные доминошки. Никакая горизонтальная
уже не валидна, потому что если горизонтальная вот такая, то она должна была быть в маск 1,
она не лежит. То есть если эта клетка не лежит в маск 1, то она не лежит в маск 1,
ну значит нельзя положить такую доминошку. Здесь уже все покрыто, мы не можем еще одну добавить.
То же самое мы не можем ее положить вот так, потому что иначе бы она была в маск 2. В маск 2 мы считаем,
что ее уже нет. Поэтому все оставшиеся клетки, не лежащие ни в маск 1, ни в маск 2, нужно покрыть
обязательно вертикальными доминошками. Оставшиеся свободные клетки нужно покрыть
вертикальными доминошками. И тогда понятно, что такое покрытие,
оно либо одно, либо их нет вообще. То есть представьте, у вас есть столбец G плюс первый,
у вас что-то в нем уже покрыто, уже что-то занято, вам нужно все оставшиеся свободные
покрыть вертикальными доминошками 2 на 1. Ну понятно, это можно сделать тогда и только тогда,
когда все вот эти вот промежуточки, все блоки свободных клеток имеют четную длину. Потому что
если есть там три подряд непокрытые клетки, то вы никак их вертикальными доминошками 2 на 1
не покроете. Но если четная длина, то такой переход будет ровно 1. Поэтому если мы напишем
какую-то процедуру, которая по двум маскам, маск 1 и маск 2, проверяет как раз такие условия,
что можно вот здесь все покрыть вертикальными доминошками, то мы тем самым получим, можно ли
вообще сделать такой переход из G, маск 1 в G плюс 1, маск 2. Причем такой переход будет ровно 1.
То есть либо такой переход вообще нельзя построить, то есть никак нельзя здесь замастить все
свободные клетки. Либо он будет ровно 1, когда все вот эти дырочки четной длины, и тогда, соответственно,
такое покрытие единственное. Такое доза мощения единственное. Значит у меня будет в зависимости
того, есть ли такой переход, то есть можно ли так делать, у меня будет просто прибавление ДПшки.
Вот это вот плюс равно ДП житая маска 1, если вот это вот возможно. Я знаю вот это торчание,
знаю это торчание, потом понимаю, что если можно вот здесь дозамастить все вертикальными,
то это можно сделать единственным образом. И поэтому количество способов нужно просто
увеличить на вот это вот ДП житая маска 1. То есть вот я ни на что не умножаю, потому что если бы,
скажем, если бы у меня было несколько способов положить здесь вертикальные доминошки для
дозамастения, тогда нужно было бы умножить на это количество, но оно всегда не больше чем 1,
поэтому умножения никаких нет. Вот такая формула пересчета. Давайте базу и ответ мы пропустим.
Базу и ответ мы пропустим, оставим упражнением. А сим-точку посчитаем.
На самом деле можно понять, что она будет вот такая.
Она будет вот такая. Вот почему. Потому что смотрите, у меня состояние динамики m на 2 венной,
для каждого столбца и для каждой маски у меня есть свое состояние динамики, а дальше я перебираю
2 венной маск 2. То есть если у меня фиксировано g маск 1, то я перебираю маск 2. У меня будет
3 вложенных цикла g, маск 1, маск 2. Суммарно это будет как раз 4 венны на m. Но еще нужно будет
как-то изначально предпочитать для каждой пары масок маск 1 и маск 2, можно ли дозамастить все
вот в этом новом столбце. То есть мне нужно исходно для каждой пары, давайте я там какую-нибудь
процедуру OK напишу. OK маск 1, маск 2. Это как бы флаг, можно ли сделать переход из маска 1 в маск 2.
Можно ли сделать переход. Как раз в этом смысле, что если я их вот так вот накладываю, с лева маска 1,
с права маск 2, то все вертикальные свободные окошки имеют четную длину, то есть их можно
покрыть вертикальными доминожками. И это как раз работает за 4 венны на n, потому что я для каждой
пары масок смотрю на то, где они не пересекаются, ну точнее, те свободные клетки, которые остаются
непокрытыми, и проверяю, что все блоки имеют там четную длину, чтобы их можно было покрыть
вертикальными доминожками. Это будет вот эта вот асимптотика. Ну и все, в сумме получается 4 венны на n,
на n плюс m. Ок? Вот, ну это, конечно, убийственная асимптотика, да, но если n там какой-нибудь,
не знаю, 5, 6, 7, то в принципе ничего страшного в этом нет. То есть если n, скажем, 6, а m, что-то
порядка тысячи, то в принципе вот мы решили задачу. Вот, ну тогда все, спасибо.
