Лекция 14. Надеюсь, что это последняя лекция. У нас сегодня планируются три сюжета из
зависимости того, как быстро мы пройдем первые два, будет зависеть строгость третьего, уровень
доказательств. Вот. Считаю, идеальная trade-off. Так, первый сюжет. Это пара, ну давайте ближайших
точек. То есть, постановка задачи даны n точек. Давайте считать, что они все различные, иначе у
вас расстояние между ближайшими нолей, все очень просто. Именно даны p1, tra-ta-ta, pn различные точки
на плоскости. Найти и неравные g такие, что расстояние от p и до pg минимально. Ну, то есть,
вы перебираете все возможные пары и считаете расстояние и убираете минимум. Ну, наивное решение
за квадрат вроде очевидно. Перебрать все пары точек, посчитать расстояние. Давайте все-таки
перейдем чуть-чуть быстрее. А именно, у нас есть много способов решения этой задачи, но мы решим
всего лишь одним из них. А именно, у нас будет идея разделяй властвой. В суть таких алгоритмов,
ну каноничным представителем такой парадигм является маршорт. То есть, вы что-то били пополам,
что-то там делали рекурсивно, потом сливали ответы. Здесь мы будем делать абсолютно так же.
А именно, давайте нарисуем наше множество точек. Ну и как легко побить плюс-минус пополам? Наверное,
как-то взять и провести вертикальную разграничивающую прямую и отнести все,
что слева от нее в одном множестве, все, что справит ее в другое множество. Вот, ну тогда понятно,
что допустим, вы здесь как-то рекурсивно нашли ответ. И здесь как-то рекурсивно нашли ответ.
Единственный вопрос в том, как ответы сливать. Вот об этом останется поговорить нам. Ну давайте подумать,
как сливать. Вначале, чтобы бить множество эффективно пополам рекурсивно, нам нужно
что-то делать правильно, отсортировать точки. Поэтому шаг первый. Отсортируем точки
ОХ. Окей, когда вы отсортируете, теперь вы можете рекурсивно вызываться от подножия.
Рекурсивный вызов от левой и правой половины.
Ну база здесь индукции вроде плюс-минус понятна. Если у вас остаются две точки или одна точка,
значит, что вы должны что сделать. Ну правильно. Давайте даже базы ставим там две-три точки. Если у
вас три точки, то просто перебрать там те возможные попары. Если две точки, то просто вывести длину отрезка.
Вот окей. Теперь допустим, что мы знаем здесь ответ, знаем здесь ответ. Как их сливать?
Шаг 3. Слияние ответов.
Так, ну допустим, что отсюда нам вернулся какой-то ans1, минимальное расстояние в левой половине, а здесь ans2.
То есть слева ans1 и ans2. Обозначим за D. Это будет минимум из ans1 и ans2. Ну то есть, как бы, по идее,
если бы у нас не было бы стадии слияния ответов, то мы бы вернули бы эту штуку. Что значит стадия
слияния? Здесь нужно заметить, что у вас существуют все-таки, все-таки у вас могут быть точки,
которые лежат по левую, ну по разные стороны, и при этом быть ближайшими друг к другу. Потому что мы
рассмотрели все, которые вот здесь вот, и все, которые вот здесь вот. Но то, что между ними,
мы связи никак не рассматривали. Давайте это сделаем. Очевидно следующее, что раз расстояние
между ними должно быть не превосходить D, значит нам достаточно рассмотреть полосу вертикальная.
Здесь D, здесь D. Почему это так? Потому что все точки вне полосы, если вы будете рассматривать
пары точек вне этой полосы, у вас расстояние будет между ними больше чем D, даже больше чем 2D.
Вот, то есть рассматриваем такую полосу, дальше внутри нее заведем интересную такую штуку.
Давайте здесь напишем, что C от PIT это таких множество G, что PGT.Y по модулю минус PIT.Y не превосходит D.
Вот, то есть в некотором плане это у нас будет такое, давайте даже не этот, без знака, без модуля.
То есть, что это точки, которые лежат, что у нас получается, чтобы это было положительно при этом?
Нуля, то есть у нас PIT.Y меньше либо равен, чем PGT.Y, нет, здесь еще поменяем, здесь PIT и здесь PGT будет.
Вот, то есть я хочу посмотреть следующее, то есть вот у меня точка PIT какая-то, да? Тогда что такое C от PIT?
Я беру вот этот уровень и отступаю от него еще на D по вертикали, причем вниз специально.
Вот, тогда я утверждаю, что если я буду для каждой точки PIT из этой полосы рассматривать вот такие вот полосочки высоты D, причем идущие именно вниз,
то я обязательно найду, ну если я найду такую пару, то обязательно найду ответ при слиянии.
А в текущий момент понятно, что мы очень делаем?
Зал, прием.
Окей.
Хорошо, я утверждаю следующее. У меня будет несколько утверждений. Первое утверждение, что C от PIT это от единицы.
Давайте его докажем.
C от PIT по модулю от единицы.
Ну как это доказывать? То есть что у нас с вами происходит? У нас есть какой-то с вами прямоугольник D на 2D и здесь какая-то точка PIT.
Окей. Что тогда можно сказать?
Давайте его разделим пополам сначала. То есть здесь D и здесь D.
Окей, почему здесь много и не может быть точек в каждом из этих квадратов, как вы думаете?
Может ли их быть много?
Нет, может ли много точек вообще здесь? Почему?
Ну вот именно, да, потому что у вас здесь на самом деле не может быть очень много точек, потому что у вас здесь ответ D.
Ну здесь все точки в расстоянии между любой парой точек с левой стороны, оно у вас больше либо равно, чем D.
Из этого следует, что у вас, ну давайте еще круче сделаем. Давайте еще поделим каждый из них на четыре штучки.
То есть по D пополам.
Я получу квадратики D пополам на D пополам. Я утверждаю, что в каждом из них может быть не больше, чем одна точка.
Ну допустим, если в одном из них лежит две точки, да?
Ну действительно, допустим, нашелся квадратик, в котором две точки. Что тогда?
Из этого следует, что он относится к одной из половин, либо к левой, либо к правой целиком.
А давайте оценим, какое максимальное расстояние может быть внутри этого квадратика.
D пополам на D пополам.
Какое максимальное расстояние может быть внутри этого квадратика?
D пополам на корень из двух. Это длина диагонали квадрата.
То есть, что равно D делить на корень из двух, что строго меньше D.
То есть, если у меня нашлись две точки внутри такого квадратика, значит, что у меня нашлась пара точек на расстоянии меньше, чем D, причем в одной из половин.
Но такого быть не может. У меня D это по определению минимальное расстояние.
Ну все, значит, у меня не может быть двух точек в одном квадратике.
То есть, не может быть двух точек в одном квадратике.
Из этого следует, что всего ЦПИТа не превосходит в восьми.
То есть, вот единица.
Отлично. Тогда что можно сказать?
Можно сказать следующее, что будто бы я могу для каждой точки...
То есть, давайте опишем слияние подробнее.
Шаг первый. Найти все такие ПИТа.
Ну и давайте обозначим эту разбивающую штучку как ХМ. Ну, Х с серединкой.
Найти все такие ПИТа, что модуль ПИТ.Х-ХМТ не превосходит D.
Это будет делать за ОТМ.
Дальше шаг второй.
Шаг второй.
Для каждой ПИТы из один построить ЦПИТа.
И вот здесь важно понимать, как это делать.
Потому что по-хорошему вам нужно просто взять и найти все такие точки из пункта 1,
но они лежат не ниже чем на D от Y ПИТы.
Ну и, казалось бы, можно для каждой из ПИТых делать это перебором, за линию искать.
Но не зря мы изучали с вами структуру данных.
Давайте пока что предложим такую структуру, которая позволяет отвечать быстро на запрос, количество чисел в отрезке.
То есть у вас есть какое-то множество чисел, вы хотите уметь отвечать на запросы,
типа сколько у меня чисел, чье значение лежит от LDR.
Чего нет?
Какое дерево отрезков? Вам нужно найти число таких Х, что Х лежит в отрезке.
Нет.
У вас отсортированный массив?
Где?
Я по Y смотрю.
Вот, можно его отсортировать, именно.
Но я вообще намекал на дерево поиска, вы просто сложитесь в дерево поиска и спрашивайте про каждое.
Но я понял, что вы не сдадите алгоритмы.
Ну потому что.
У кого как, у кого-то осталось меньше месяца.
Мне лень будет принимать перезну.
Как можно построить сет пыта?
Давайте перечислим варианты.
Первый вариант – наивный.
Мне его настолько лень оценивать, что я скажу, что это вот N квадрат.
То есть вы просто для каждой точки перебираете все возможные точки.
Второй вариант – сортировка.
Плюс bin поиск.
Я буду писать специально время на каждую стадию, потом поймете почему.
Ну и следующий шаг – это сортировка плюс два указателя.
В каком плане два указателя?
Вы заводите указатель на самую верхнюю точку, сдвигаете второй указатель вниз, пока еще можно.
То есть пока выполняется вот это вот требование.
Окей, зафиксировали, там обработали этот сет пыта.
Дальше сдвинули эту на один.
Двигайте второй указатель, пока можно.
И так далее.
Схема понятна или нарисовать подробнее?
Нет, зачем?
Мы же рассматриваем пыта в отсортированном порядке.
То есть вы рассмотрели до каждой точки пыта.
То есть у вас вариант такой, что вы для пыта рассмотрели уже все, что сверху.
Вот.
Третий вариант – это сортировка плюс два указателя.
Это от n log n плюс от n.
Построили сет пыта.
Ну и шаг третий – внутри цейтых поискать ответ.
Тет пыта.
Из два попытаться обновить ответ.
То есть такой алгоритм – итоговое время работы.
Давайте выпущем рекурренту.
Т от n – это что такое?
Мы делим на две части.
Каждая из них по n пополам.
Плюс время наслияния от n log n.
Ну, не думая слишком много, получим вот такую вот штуку.
N log квадрат n.
Казалось бы классно, да?
Ну, гораздо круче, чем n квадрат.
Но не достаточно хорошо.
Хочется от квадрата алгоритма избавиться.
Хочется здесь вместо двойки ничего не писать.
Ну, или единицу.
Давайте избавляться от лишнего алгоритма.
Откуда он берется?
Ну, как видим, эту штуку мы менять не можем в нашей парадигме.
Можем менять только эту.
Окей.
Смотрим внимательно.
Нас устраивает этот чувак.
Но здесь что-то надо много менять.
Тем более бинг-пост.
Там вообще сложно менять.
Сортировка плюсного указателя звучит более приятно.
Почему?
Потому что здесь уже отn стоит.
То есть, если бы могли бы заменить сортировку чем-то,
то тогда…
Ну, чем-то здесь линейным.
Сортировка подсчета не в счет.
Сразу скажу.
Вот.
Если могли бы заменить ее чем-то линейным, то все.
Здесь был бы отn.
Значит, сумма отn.
Ну, давайте что-нибудь сделаем.
По Y?
Кого?
Так нет, вы сначала по X сортировали.
А как вы собираетесь контролировать?
Вы должны пробросить их, чтобы они вместе одинаково были.
Но это не очевидно как это делать.
Вам нужно какие-то индексы с собой таскать?
Вроде как можно, да.
Но давайте предложу вам более изящное решение вместо того, чтобы снять какие-то индексы.
Смотрите.
У кого такая же рекурrenция, только здесь отn?
Да.
И мы делаем все абсолютно то же самое.
Мы бьем множество на бинг-пост.
И мы делаем все абсолютно то же самое.
И мы делаем все абсолютно то же самое.
Мы бьем множество на две части.
Направо, налево.
Здесь сортируем, здесь сортируем.
Потом делаем мерч за линию.
Ну, давайте мы будем еще здесь вставить стадию сортировки по Y.
В половинке именно этой штуки.
То есть давайте мы будем отсортировать по X.
Рекурсивный вызов.
И на момент, когда мы сделали мерч, вот этот вот интересный,
мы после него будем вызывать сортировку по Y.
А что значит сортировку по Y?
Если у вас два массива точек отсортированы уже по Y, то что тогда?
Можно сделать их просто слияние.
И вы вернете, то есть вы можете слить вот эти вот отсортированные по Y, вот эти вот отсортированные по Y.
Сделать мерч за линию и вернуть его наверх.
И вместо вот этой сортировки у вас здесь будет стоять мерч.
На самом деле.
Потому что мерч-сорт, как вы можете догадаться, он нигде не сортирует.
Он нигде не вызывает какую-то функцию сортировки, кроме там, ну, для двух элементов.
Когда там по каждому массиве по одному элементу и то, там можно даже на таком этапе вызвать мерч.
И он все равно отработает, просто будет тип как смоп.
То есть на самом деле здесь четвертый шаг.
Мерч по Y.
Половин.
Это O от N.
Откуда T от N?
Это 2 T от N пополам плюс O от N.
То есть T от N.
O от N.
Лог N, конечно же.
Вот, так сказать, задача со звездочкой.
Я не знаю даже верно это утверждение будет или нет.
Так сказать, что лучше нельзя.
Ну, в парадигме, что умеете только сравнивать, попытаться как-нибудь.
Потому что, возможно, это может привести к задаче сортировки.
Так, окей.
Это наш первый сюжет.
Давайте, наверное, второй сюжет разберем.
Какое у нас время?
Нормально.
Еще успеваем.
Собственно, раз была пара ближайших точек,
наверное, надо разобрать с пару самых удаленных точек.
Но здесь придется пользоваться уже материалом прошлой лекции,
а именно выпеклыми оболочками.
Вроде как логично, что если вы построите выпеклую оболочку множеству,
то че-то красиво выглядит.
perfection.
НоRAY2 поднимается, потому что мы уже новости не Thomson Dreative�זה,
может получиться. В частности, наверное, будто бы хочется утверждать, что если вы переберете все
пары точек выпуклой оболочки, то ответ это что-то максимум из этих будет. Но пока что это такие
абстрактные рассуждения, давайте будем потихонечку идти и доказывать. Определение.
Прямая L опорная для выпуклого многоугольника. Если L содержит хотя бы одну точку,
для многоугольника A хотя бы одну точку A и A целиком в одной полуплоскости относительно
L. Пример такой. Но здесь может выпуклую фигуру, то есть немногоугольник, это может какой-то
эллипс и так далее нас не особо интересует. Вот например, что такое опорная прямая. Это A,
это L. Она проходит через одну его точку, ну хотя бы одну, и при этом он есть целиком лежит в одной из
полуплоскостей. Ну и будто бы хочется сказать, что диаметр множества, это вот если зажать выпуклую
оболочку, каким-то таким вот в тиски ее будто бы засунуть. Размерить все возможные варианты этих
тисков, то это будет победой. Ну давайте доказывать это. Что докажем для начала? Наверное для
начала докажем, что утверждение. Пусть L1 и L2 пара параллельных опорных прямых
для многоугольника M. Многоугольник звучит классно. AIT равно LIT пересечь с M. Давайте AIT,
это какой-то элемент, потому что вдруг мы там пересекаем по стороне. То есть вы берете в
многоугольник M какой-то, то есть в нашем случае это был бы M, это был бы L1. Ну не параллельно получилось,
сейчас попробуем параллельно. Это L2. Это A1, соответственно, это A2. Давайте уберу наружу.
Тогда что я утверждаю? Что, как бы так сказать, что A1 и A2 являются самыми удаленными точками
друг от друга. Две самые удаленные точки, если A1 и A2 перпендикулярен LIT.
Ну, LIT и параллельно, поэтому можно любые из них взять. То есть я утверждаю, что если это две самые удаленные точки,
не так, что если... Пойдем в какую сторону будем доказывать. Да-да-да-да-да, не в ту сторону.
Что если это, то вот это, вот в эту сторону, это верно. Давайте доказывать. Что если A1 и A2
это самые удаленные точки, то A1 и A2 артегональны L1, ну, LIT. Давайте от противного закажем.
Что если A1 и A2 не артегональные LIT, значит, это не самые удаленные точки.
Противного. Ну, в смысле, ну да, да. Ну, короче говоря, что найдутся такие, можно так сказать.
Типа того, да, что найдутся параллельные прямые, такие что... Сейчас давайте я нарисую чуть другой пример.
Ну, будто бы да, да, формально так сформулировать можно. Сейчас давайте как-нибудь вот так вот
нарисую, наверное. Во! Ужасные маркеры, их невозможно стирать пальцами. Так, здесь еще поострее нарисую угол.
Вот такого вот. Нет, мне нужна такая прямая, то есть более пологая будет наоборот.
Так вот, L2. Это A1, это A2. Вот, ну окей.
Что тогда? Ну, тогда я могу рассмотреть расстояние.
Это достаточно перпендикулярно? Так, ну если это перпендикулярно, то что тогда я могу сказать?
Давайте так. Давайте доказывать, то существует L1 и L2 такие, что A1 и A2 артагонален L1. Предлагаете такое доказывать?
Да, так. Так, давайте построим. Построим L и T. Артагональны A1 и A2.
L1 штрих, L2 штрих какие-то. Построили их. Хорошо, если мы их построили, то что из этого? Из этого следует, что вдруг они неопорные.
Если они неопорные. А, ну и мы построили элиты, так что какая-то из них неопорная при этом.
Неопорные. Что мы делаем тогда? Это наш перпендикуляр A1 и A2. И что мы имеем вообще?
Раз она неопорная, то будто бы L1 получилась неопорной. У нее есть точка в другой полуплоскости.
Я могу рассмотреть точку пересечения вторую, то L1, без ограничения общности это будет L1, пусть L1 штрих пересечь с M равно какой-то B.
То есть это будет точка B. Вот тогда будто бы что я могу сделать. Очевидно, что A2B длиннее, чем A1A2.
Ну просто потому, что A2B это гипотенузов в треугольнике, а A1B-A2.
Окей, что теперь я хочу сделать. Раз у меня эта штука неопорная, значит у меня есть две точки в разных полуплоскостях.
Давайте я рассмотрю точку C в полуплоскости, противоположной A2.
Да?
C в вершина многоугольника.
Противоположной полуплоскости относительно L1 штрих.
Все, да, сейчас мы докажем нормально.
Так, то есть C это у нас вершина противоположной полуплоскости относительно L1 штрих от A2, а это точка C.
Давайте рассмотрим A2C.
И что я утверждаю?
Что если я проведу прямую через C параллельную L1 штрих, L1-2 штриха, пусть L1-2 штриха параллельно L1 штрих и C принадлежит L1-2 штриха.
А 1A2 пересечь с L1-2 штриха, это будет L1-3 штриха, это будет C штриха.
Я утверждаю, что A2C штрих будет больше, чем по модулю A2A1, потому что мы просто построили C штрих за нее.
Но при этом A2C это гипотенуза в прямоугольном треугольнике A2C штрих C, но A2C больше, чем A2C штрих, потому что это гипотенуза, это катет.
Откуда у вас следует, что A2C штрих больше, чем A2A1?
Противоречие, то есть B нам не нужна даже.
Я почему-то думал, что нам это понадобится, но нет.
Здесь даже это не нужно.
То есть какой план? Давайте еще раз нарисую картинку.
Так, будто бы вот это вот будет две удаленные самые.
То есть если 1A2 самые удаленные точки, то они существуют.
Как мы это доказывали?
Мы доказывали, что предположим, что таких прямых нет, опорных, ортогональных L1 и L2.
А, все окей, здесь нужно просто другую пару точек взять, не ближайшую.
Не самые удаленные.
Кажется, что вот для этой, что вот для этих все будет очень плохо.
Давайте еще специально постругу побольше.
Во.
Тогда если я построю перпендикулярные прямые к ним, то одна из них не будет опорной.
И я пытаюсь доказать, что вот эти две не самые удаленные.
Как я это делаю?
Хорошо.
Если это две не самые удаленные, значит существует какая-то точка.
Точнее так, если одна из них не опорная, я рассмотрю, которая не опорная.
Вот это вот.
Это наш L1-штрих по совместительству L1, который мы попытались построить.
Дальше что мы делаем?
Мы такие, окей, хорошо.
Рассматриваем точку C, которая лежит в другой полуплоскости.
Относительно A2.
Рассматриваем отрезок A2C.
И пересекая с этой штукой, с L1, получаем точку C-штрих.
Вот.
У меня модуль A2C-штрих больше, чем...
А, нет.
Сорри, не так можно.
Не так мы C-штрих получали.
Но можно и так было получить.
Это не очень очевидно, будем честны.
Можно, да.
Можно.
Ну, ладно, давайте так оставим.
Вот.
Мы построили C-штрих, как на продолжении.
A2A1 за A1.
Такое, чтобы она пересекалась с прямой параллельной L1-штрих, проходящейся точку C.
L1-2-штриха.
Вот.
Ну, тогда у нас A2C, очевидно, больше, чем A2C-штрих.
A2C-штрих больше, чем A2A1.
Значит, A1 и A2 не самые удаленные точки.
Окей. Ладно, это мы доказали.
Теперь я утверждаю следующее, что...
Давайте не так. Сначала определение сделаем.
Две точки противоположны.
Если
Существуют
L1 и L2,
проходящие через них.
Давайте две точки A1A2.
Тут L1 и L2, проходящие через них, такие, что
L1 параллельно L2
и Lit
артагонально A1A2.
Вот.
То есть две точки противоположны,
если можно построить такие
и L и T
опорные.
При этом. То есть если я могу построить
две опорные,
то, в частности, эти две точки не противоположны.
Например, вот эти вот будут
противоположными. У них найдется такая пара.
Ну и вроде как для выпуклого многогольника,
верно, что для любой точки есть и противоположная.
Ну, собственно, утверждение,
которое нам остается доказать,
и дело почти в шляпе,
это то, что
максимальное расстояние
достигается
как максимум
среди
удаленных
точек.
То есть если вы рассмотрите все пары точек
и возьмете из них удаленные
самые,
то ответ будет как максимум достигаться.
Но как это доказывать?
Ну, рассмотрим просто
нашу конструкцию.
Наш L1,
вот наш L2,
вот у нас здесь есть какое-то выпуклое тело.
T1 и T2.
Ой, среди противоположных,
противоположных, конечно же,
у ложных точек.
Не то чтобы корректно их изобразил,
давайте подвинем A1,
чтобы они были друг над другом,
потому что мне прямая лень перерисовывать совсем.
Я утверждаю, что
что лучшей варианта нет,
если я рассмотрю максимум.
Усть
A1 и A2
противоположные точки
такие, что
A1 и A2
максимален среди всех пар
противоположных точек.
Давайте возьмем
две произвольные точки
и докажем, что для них расстояние будет
меньше, чем A1 и A2.
Скажите честно, из картинки очевидно?
Что именно очевидно?
Оно не очевидное.
Ну, по сути, да, мы доказали.
Ну да,
это очевиднейшее утверждение на самом деле.
Ну, типа,
здесь можно доказать,
что мы нашли точки, которые более удаленные,
МН,
не знаю.
Окей.
Если они более удаленные,
значит,
рассматриваем между ними расстояние,
проведем опорные прямые
в их направлении,
точнее,
прямые перпендикулярные.
Вот, они будут,
либо они будут не опорными,
либо расстояние будет как между опорными
меньше, чем из тех максимумов, что мы выбрали.
Ну и все.
Все, доказательства как бы сходятся.
Можете здесь написать конец
и типа все.
Ну окей, ладно.
Рассмотрим
произвольный МН.
Проведем
прямые
L1-
L2-
такие, что
L1- параллельно
L2-
МН
протагонален L и T-
и что еще мы хотели?
А вообще,
это все, что мы хотели.
Если
у нас есть
если
L и T не опорные,
то по утверждению
выше
МН
не самоудаленные.
Удаленные.
Если же
L и T
опорные,
то
МН
противоположные,
и модуль МН
больше, чем
A1-A2 по предположению.
Но этого быть не может, потому что A1-A2 мы выбирали
как самые далекие противоположные точки.
Все, доказали.
Противоречие.
Ну все, остался последний,
как
алгоритм.
Алгоритм
будет очень простой.
Вы возьмете ваше тело,
приведете через
крайнюю левую,
через крайнюю правую
вертикальные прямые.
Дальше вы будете их синхронно вращать,
а потом
вы будете вращать
вверх и вверх.
Дальше вы будете их синхронно вращать,
чтобы они все время оставались
параллельными друг к другу.
Ну и так
мы с вами доказали, что
а, ну еще можно доказать, что
а, ладно, это неважно.
Просто так оставим.
Вот вы вращаете, вращаете, вращаете,
и просто-напросто
вы перебираете все пары
противоположных точек путем такого вращения.
Потому что если вы здесь повернули на угол phi,
здесь вы не сильно больше, чем на угол phi можете повернуть,
чтобы у вас была противоположность.
Вот.
Ну и все, тогда вы можете их все за линию
просто перебрать путем таких поворотов.
И выбрав максимум, это будет победой.
Поэтому алгоритм называется
он называется
вращающиеся калиперы.
По-моему, в английский вот так вот.
Ретейтинг калиперы.
Может быть там одна L,
я не помню точно.
В чем суть? Первый шаг это
построить
выпуклую оболочку.
Ну в тиски мы просто зажимаем,
в чем тиски?
Ну выпуклую оболочку понятно, что
если вы утверждаете, что
очевидно, что ответ лежит
между двумя вершинами выпуклой оболочки.
Если это не так, вотяните две произвольные вершины внутри,
протяните прямую,
посмотрите, что у вас
все будет сильно хуже.
Вообще не так, что если вы рассматриваете точки перещения прямой
через эти две точки
с выпуклой оболочкой,
то у вас будут точки очевидно дальше друг от друга.
Шаг второй.
Допустим ПЛ
имеет
минимальный Х,
ПР
максимальный Х.
То есть вот наш ПЛ-ПР.
Вот наши калиперы начинают
вращаться.
И теперь вы рассматриваете
допустим против часовой стрелки.
Ну и записали, что расстояние между ПЛ-ПР
и АНС в ответ.
АНС равно
ПЛ-ПР.
Теперь вы делаете следующее.
Вы рассматриваете угол
между ПР
а, против числа это в эту сторону,
все, сорян.
Это у нас будет ПР плюс один,
это будет ПЛ плюс один.
Ну естественно все по модулю берется,
здесь я плюс и минус и так далее.
Угол вот такой вот
и угол вот такой вот.
Давайте обозначим это
ФЕЛ, это ФЕР.
Пусть
ФЕЛ
угол между
ПЛ минус один ПЛ
ПЛ ПЛ плюс один.
ФЕР аналогично.
Это угол между
ПР ПР
Р минус один ПР
ПР ПР плюс один.
Ну пускай ФЕЛ меньше.
Вроде на рисунке ФЕЛ меньше.
Тогда возьмем и сделаем проворот
до нового положения прямых.
Обману, ФЕР меньше.
Сорян.
Вот.
То есть я проворачиваю так, что у меня здесь вот
ну я почти смог.
Это угол
между текущим
состоянием Элитой.
Ну Эль. Это вот Эль
один. Это Эль два.
Вы сейчас и будете просто синхронно
вот так вот вращать.
Да, соря.
Я позволю себе коллизию индекс
Эль-Эль. И здесь Эль-Эль Р.
Типа это будет
прямая левая, прямая
через правую точку подходящая.
Вот. Тогда у меня получилось здесь вот
что-то вот такое вот.
Не получилось параллельными. Это грустно.
Надо избавиться
от этого прикола.
Ща.
Все. Этой точки не существует.
Вот. Теперь я могу провести новый
калипер. Вот так вот.
И я такой окей. Хорошо.
Здесь вот эта точка и вот эта точка.
Здесь Пл. Я перебираю между
этой и этой. Ну здесь, понятно, ответ
такой будет.
Дальше снова проворачиваю. Смотрю
только угол этот.
И вот такой вот.
Новое положение будет вот таким вот.
Раз.
Два. Смотрю противоположные точки. Это вот эти две.
Вот.
Ну в общем-то я утверждаю, что так мы переберем все
возможные пары противоположных точек.
На самом деле.
Ну, провернув полностью, сделав
поворот на 180 градусов,
я посмотрю все пары точек
противоположных. Ну почему так?
Потому что на самом деле каждый раз я беру
и так как я держу прямые параллельными
и убираю минимальный угол,
я каждый раз беру и смотрю пару
противоположных точек. На самом деле.
Вот.
Тогда
повернем
лл
лр
на минимум
из фиэльфер.
Обновить ответ.
Повторить.
Как это делать?
На самом деле очень удобно это делать просто
помощью двух указателей опять же.
Вот у вас раз индекс, два индекса.
Вы смотрите до кого поворот короче. До этой или до этой?
Ну до этой отлично. Сдвигайте этот указатель
сюда. И проводите.
Не, до этой было полменьше.
Да. Сдвигайте этот указатель
сюда. Смотрите
длину. Окей.
Теперь эту надо поворачивать. Вот
этот сюда сдвинули.
Мы вот так вот постепенно ходя друг по другу,
удерживая параллельными при этом.
Ну и при этом
заметите, что, ну да, все окей.
Вот. Они все время будут опорными.
Все будет хорошо.
Вот.
Ну короче, вы двумя указателями просто найдете
ответ в конце концов.
Ну да, вы сдвигайте один
из указателей. Причем сдвигайте
л.
Если у вас фиэльты это минимум
из фиэльфер. И на
паттерт вы сдвигаете на единичку.
Все.
Вы сдвигаете один из указателей.
Каждый шаг. Да. Все.
Повороты есть. Это три указателя на единицу на самом деле.
Визуально это выглядит, как вы вращаете
прямые, но по факту вы просто
перескакиваете либо одну точку,
либо другую точку двигаете на единицу.
Тогда таким образом
у вас каждую точку постят максимум два раза,
каждый указатель по одному разу.
Поэтому суммарно этот шаг за линию отработает.
Ну или можно сказать от
поворотов.
Каждый
за от единицы.
Ну и на этом все.
Поэтому этот шаг
отn
это отn логн.
Соответственно.
Ну и все. Победа.
Последний сюжет
это
я специально оставил сладкой
напоследок.
Сумма Минковского.
Как раз эти точки вам последней не хватает,
что есть в контесте, что есть в теорках.
Кстати, в теорках есть на пару самых удаленных
точек задач.
Если что.
По-моему. По-моему я добавил в итоге.
Там про то, чтобы построить
прямоугольник
минимального, минимальной площади
содержащей все
точки.
Сумма Минковского.
У нас 25 минут.
Сумма Минковского.
Я думаю уже благодаря многочисленным сообщениям
в чате.
Большинство людей уже
узнало, что это такое.
Но
я только что напишу определение.
Что?
И в эвке.
Пусть A, B
под множество
R2 в нашем случае.
В общем случае это
определенно для линейных нормированных пространств.
Мы будем считать, что мы живем в R2.
В силу того, что
земля плоская.
Будем называть A плюс B.
То есть сумма Минковской краски.
Сейчас поймете, почему
плюсик круглый.
Ну, те, кто второй курс, те поймут.
Первый еще не поймет.
Но это сумма линейных пространств
просто-напросто.
То есть, по идее, если у вас A и B это
конечные штуки, то вы можете
просто взять, перебрать все пары
и построить.
Но в нашем случае A и B это многоугольники.
Более того, мы будем рассматривать только
для выпуклых многоугольников.
Утверждение, пусть
A, B
это выпуклые многоугольники.
Тогда
давайте здесь напишем
A плюс B
это
и здесь
будет три части утверждения.
Первое,
это выпуклое множество.
Второе,
это многоугольник.
И третье утверждение,
что
число сторон
в этом многоугольнике
не превосходит суммы числа сторон
в A и B.
Такие вот три части утверждения.
Вот я посмотрел, как я в том году доказывал.
Мне в целом все понравилось.
Вот, но я уверен,
что меня забулят.
Потому что недостаточно строго.
Я бы не сказал, что это радикально,
поэтому я позволю себе
свое прошлогоднее доказательство,
которое совсем такое
на уровне
красотарук и никакой магии.
Но давайте я докажу строго хотя бы
первую часть утверждения.
Напомню в определении выпуклости,
что множество выпукло только тогда,
когда для любых двух точек
из-за того множества весь отрезок
целиком содержится в нем.
То есть у нас будет выпукло
для произвольных выпуклых ножств,
а что их сумма будет выпукла.
Ой, так, пусть.
P1, P2 принадлежат A.
Q1, Q2 принадлежат A.
Q1, Q2 это нерациональные числа.
Принадлежат B.
Тогда я утверждаю, что
отрезок полученный,
то есть у вас был вот какой-то отрезок.
Вот у вас A, P1, P2.
Внутри будет какое-то B множество.
Q1, Q2.
Тогда утверждаю, что если я
посмотрю
A плюс B,
то весь объект
вот этот вот целиком,
который прямая сумма
P1, P2 и Q1 куда,
будет лежать целиком внутри.
Как это доказывать?
Параметризуем отрезки.
Как радиус фактора.
Вот я параметризовал отрезки произвольным образом.
То есть у меня здесь
произвольная точка P,
произвольная точка Q.
Я хочу доказать, что P плюс Q
обязательно попадет
в сумму A и B.
Рассмотрю P плюс Q.
Плюс Q,
плюс Q,
плюс Q,
плюс Q,
плюс Q,
плюс Q,
рассмотрю P плюс Q.
Но вообще,
если надо рассматривать для произвольных
T1 и T2 хорошему,
я бы сказал,
что мне лень, но ладно, я рассмотрю.
P1 плюс
P2 минус P1
на T1
плюс Q1 плюс
Q2
минус Q1
на T2.
То есть я хочу показать,
что вот эта вот штука
предстоит как где какие-то точки,
что P плюс Q
просто-напросто,
что она лежит в сумме Минковского.
Значит, найдутся какие-то
T1 и T2,
где T1 из A, T2 из B.
Такие, что у нас
T1 плюс T2, это вот это P плюс Q.
Очевидно, что вместо T1 и T2
можно взять по ИКУ просто-напросто.
То есть вроде бы просто по определению
эта штука лежит в A плюс B.
Лежит в A.
Вот это вот.
Лежит в B.
С этого следует, что
лежит
в A плюс B.
Что?
Да просто так.
Ну чтобы вести действительно произвольные точки.
Потому что нам нужно
все-таки показать произвольные точки, что это верно.
Но я написал
достаточно формально.
Да, это из B, все.
Вот.
То есть как бы МГУ рассмотреть одинаковые Т,
там совсем все будет очевидно.
Но вроде это не нужно нам.
То есть я показал, что для произвольного
T1 и T2 эта штука лежит в A плюс B.
Но раз у меня
для любых двух точек.
А, сейчас.
Сейчас-сейчас-сейчас.
Что я доказал-то?
Давайте лучше докажу,
что
для произвольного T и для любой точки
с Q1 и Q2 будет лежать целиком.
Но это тоже вроде очевидно плюс-минус.
Что если я рассмотрю здесь, оставлю P,
а здесь зафиксирую Q1 или Q2,
то для любой P,
P плюс Q1 или P плюс Q2 будет лежать в сумме.
То есть короче, это очевидно.
Очевидно это же, на самом деле,
что если у вас изначальные отрезки лежали,
то будет целиком лежать.
Вот.
Нормально, потому что вы можете...
Ну, как доказать, что...
Что такое прямая сумма двух отрезков?
Это параллелограмм.
Вот.
Как он устроен?
Ну, ты берешь вот так вот.
И здесь замыкаешь. Все.
И я могу доказать, что любая его внутренность
будет тоже лежать.
Любая точка внутренности будет лежать.
Ну, просто ее как-то разложив
через P1 и Q1, P2 и Q2.
Вот. Поэтому здесь излишний формализм,
наверное.
Ну, посмотрели только работу с
сыпковыми штуками, как отрезки параметризовывать.
Пока не понятно,
что мы делаем.
Пока что мы доказываем
сверхочевидное утверждение.
Ну, а что такое P1, P2, P1, P2?
Ну, смотри. Вот я хочу тогда доказать,
что если это A плюс B,
то будто бы,
если я рассмотрю
вот эта вот штука будет
P1, P2.
Да.
Ну вот. Я хочу будто бы доказать,
что в этом параллелограмме любая точка лежит
внутри A плюс B,
если я его построю.
Как сумма двух отрезков прямая.
Наслужу какую-то точку.
Наслужу какую-то точку.
Окей. Что я с ней могу сделать?
Ну, знаете, что я сделаю? Я просто возьму вот так вот.
И все. Приведу параллельные отрезки
по параллельной сторонам.
И найду
это,
найду из кома P и Q.
Ну, это и наоборот Q у нас, потому что
горизонтальная. Q и P. Проекция.
Ну и все.
Q и P очевидно образованы
как параметризация.
Поэтому я доказал, что любая внутренность параллелограммы лежит внутри.
Мы доказываем, что для произвольных
P1, P2, Q1, Q2
их прямая сумма лежит
целиком в сумме Минковского.
Нет.
У нас A и B выпуклые.
Нам даны отрезки выпуклых в множествах.
Нет. Мы построили прямую сумму A и B.
Это параллелограмм.
В смысле какой-то?
Он достаточно определенный.
В смысле нет. Зачем вы рассматриваете?
Вы берете произвольные P1, P2
из A. Произвольные Q1, Q2
из B.
Складываете их. Получаете параллелограмм.
П1 плюс Q1,
P1 плюс Q2, P2 плюс Q1,
P2 плюс Q2.
Если вы четко рассматриваете их,
это будет параллелограмм.
Я, пожалуй, оставлю без доказательств, что это параллелограмм.
Почему?
Потому что если я к P2 прибавлю отрезок Q1, Q2,
я получу вот эту сторону.
Аналогично, если я к P1 прибавлю отрезок Q1, Q2,
я получу вот эту сторону.
Также строятся эти.
Я доказываю, что любая точка внутри лежит
2 плюс B.
Я беру и строю проекции
на эти стороны.
Это будут вот такие вот штуки.
Одна из A, другая из B.
Вот множество A плюс B
содержит вот такую вот штуку.
И больше ничего.
Не больше и не меньше.
Геометрически оно выглядит
очень странно. Я вам сразу скажу.
Позвольте еще раз, что
вливая внутреннюю сторону параллелограмма лежит от QB?
Ну я взял, построил точки Q
и точки P, просто проецировав параллельно
стороны параллелограмма.
Ну и все.
Я знаю, что этот отрезок
у меня получается как Q1
плюс P1 P2.
Это какая-то точка
на P1 и P2.
Я просто параметризовал.
Я могу просто отношение длин посмотреть.
Я найду T из него.
Ну и все.
Абсолютно так же я могу любую точку.
Координата Q определяется.
И аналогично я могу построить
любую точку из внутренности.
Ну это смерть.
Ладно, давайте доказывать максимально
неформально на пальцах.
И то, что вас никто не примет на экзамене.
Что это многоугольник и что у него
число сторон маленькое.
Так вы не сдаете.
Ну второй курс не сдает.
Второй курс не жалко.
Окей.
Ладно, давайте рассмотрим
рассмотрим
давайте определение.
Точка P
крайняя
в направлении
D если
ориентированная
проекция
P на D
вектор
максимально
перевожу на русский.
Вот у вас есть ваше тело.
Вот есть ваш вектор D.
То вы берете
будто бы рассматриваете
прямые ортогональные D
и выбрать ту, которая наиболее дальняя.
Потому что этой точке радиус вектора
если это сначала координат
то
проекция радиус вектора
получается какая?
А, ну она минимальная.
Не, наоборот
вру. Проекция радиус вектора
на вектор D максимальная.
Потому что она просто с ним совпадает.
Вот, если мы рассматривали
какую-то другую множество
то вот ваша точка
которая крайняя в направлении
вроде бы
нет, вот эта будет крайней в направлении
потому что у нее будет проекция большая
на вектор D.
Вот.
Здесь проекция
здесь важно то, что у вас
ориентированность проекции, то, что сюда
это будет с минусом проекции.
Вот.
Вот, это что-то как крайняя точка.
Можно я скажу, что утверждение о том,
что сумма крайних точек крайняя в сумме Минковского
это очевидно.
В смысле, в программе
прописано, доказатель, доказатель
это утверждение.
Я сочувствую вам.
Упражнение для читателей.
Если точка A крайняя
в одном направлении,
если вы зафиксируете направление
и рассматриваете две крайние точки
в этом направлении, то сложив их
вы получите крайнюю точку в заднем направлении
в сумме Минковского. Почему так?
Допустим, она не крайняя.
Значит, есть точка, куда более далекая в этом направлении.
Окей.
Как мы ее могли получить?
Как сумма каких-то из этих двух.
Но мы здесь уже взяли максимальный.
Значит, больше максимум получить просто нельзя.
Все. Утверждение уровня 8 класса.
Окей.
Давай, серьезно.
Господи. Мы отсюда не уйдем
до начала следующей пары.
Сумма крайних точек крайняя?
Окей.
Хорошо. Как это будем делать?
Пусть
П
это крайняя точка
А
Q
крайняя точка
B
в направлении D.
То есть вот какие-то у вас тут есть
А
B
направление легендарным образом
вот таким вот это будет D.
Тогда я рассматриваю
будто бы все сечения прямыми
артагональными D
и выбираю крайние точки в этом направлении.
Это здесь будет?
Потому что ее радиус вектора
наибольшая проекция на вектор D.
Логично здесь будет. Вот она.
Вот я утверждаю, что
сумма крайних крайняя.
Вау.
Ну то есть потому что
у вас большую проекцию просто
выбрать нельзя.
Можно это сотруть с доски?
Этот позор. Спасибо.
Крайняя в сумме
это крайняя точка в сумме. Именно так.
Сумма крайних точек
является крайней точкой в сумме.
Отлично.
Ну раз мы знаем, что сумма крайних
точек крайняя, а что такое?
Окей.
А теперь если у вас рассмотрим
вектор D, артагональный какой-то
из сторон
ваших ногогольников.
Ну это типа вертикальный.
То у вас на самом деле
что такое сумма точки и отрезка?
Ну что у вас отрезок крайних точек?
Что такое сумма точки и отрезка?
Это отрезок.
Потому что вы берете просто каждые
точки этого, прибавляете эту точку.
Все.
И утверждаюсь, что эта сторона будет крайней
в направлении D на самом деле.
Это вроде очевидно, потому что у вас
отрезок просто построился и все.
Тогда вы можете сказать, что
просто-напросто
если вы переберете все возможные
направления D, у вас будут пары
крайняя точка,
крайняя сторона.
И при этом у вас относительно вот этих
вот крайних сторон будто бы будут все
время лежать в одной полуплоскости.
То есть вы построили пару
для этой и для этой.
Давайте я их обозначу буквами.
То есть вы построили сторону
A2, крайнюю для двойки
и для A.
Так как она крайняя, значит у вас
здесь ничего не может быть.
Аналогично вы строите для A и для
3.
Что-нибудь типа такого будет.
Ну, отрезок только.
Поэтому он здесь будет поменьше.
То есть у вас вот здесь запрещенная область,
так называемая.
Здесь ничего лежать не может.
Да и в целом ничего не может лежать
левее на самом деле в этом направлении.
Ладно, дальше. Строите для всех
вот это A3.
И так далее. Для всех построили такие области.
Но это очень похоже на какие-то
полуплоскости на самом деле.
Потому что у вас вот здесь ничего быть
не может уже.
Вот здесь вот ничего быть не может.
Ну дальше потом построится.
Если вы их все построите вот так, то у вас
есть области.
И вы их отделяете вот такими прямыми
от какой-то коробки
всеобъемлющей.
Всеобъемлющая коробка определяется как крайняя
в вертикальных и в горизонтальных направлениях.
То есть какая-то всеобъемлющая коробка
внутри которой лежат все.
И вы из нее высекаете какие-то вот такие
вот множества прямоугольнички.
Потому что каждая
сумма точки и отрезка высекает
вам прямоугольник вот такой вот.
В каком-то направлении.
И потом вот высекает вам.
А раз вы отсекали от
многоугольника
отрезками, куски, значит у вас в конце
получится снова многоугольник. У вас ничего другого
получить не может.
А мы при этом доказали, что он выпуклый.
Поэтому сумма является выпуклым многоугольником.
Ой, тут много строить, не лень.
Я построю сумму потом,
когда мы придем к алгоритму.
Ну,
от четыре сторон тогда, думаю, понятно как рассуждать.
Абсолютно так же.
Что у вас на самом деле
итоговый вклад внесет
не очень много сторон.
Более того, можно сказать, что для каждой вершины
будут носить вклад только на две стороны.
Ну или три от силы.
Это будет
крайняя сторона, и вот эти вот две.
И все, для этой вершины эти уже вклад
носить не будут, потому что для нее есть более
крайние в том направлении.
Давайте третью часть
сотрем.
Она будет вытекать из алгоритма.
Чего корректности я сейчас буду доказывать.
Вот так.
Давайте здесь напишем что-нибудь на ташке.
Что крайняя.
Сумма крайних крайняя.
Сумма крайних крайняя.
Вот этого следует, что
если рассматривать
все возможные D
получим
что
от многоугольника
даже от
всеобъемлющего
прямоугольника
отсекали
области
отрезками.
За этого следует, что получена фигура многоугольника.
Ну, вам придется потерпеть.
Оставшиеся минут еще 10, наверное, задержимся,
к сожалению.
Окей.
Сам алгоритм.
Из него будет вытекать число сторон
и доказывать корректность алгоритма.
Мы тоже будем.
Но постараемся доказать.
То есть пока что мы доказали,
что это глубокий многоугольник.
Вот. Мы не доказали в нем сколько сторон.
Это будет вытекать из построения.
То есть нам надо написать
построение и доказать корректность.
И курс лекции окончен на этом.
Так, алгоритм. Первый шаг.
P0
P0 это крайняя
P0 это самая нижняя точка.
Из самых нижних точек самая левая точка
в A.
Самая
нижняя
точка A.
Q0,
бла-бла-бла, точка B.
То есть
вот давайте.
Самая левая
Да, вы должны взять одинаковую там и там.
Ну, это любимый прием наш.
Потому что делается за линию.
Все любимые приемы делаются за линию.
Ладно, окей.
Так.
Это Q0.
Это P0.
Ну, следственно, сделаем ротейт
так, чтобы у нас отчет от многогоника начался именно отсюда.
То есть, это было бы P1, P2, P3.
Кодинг кудалку 3.
Мы с вами уже говорили,
что в этом случае
мы будем делать
кодинг кудалку 3.
Кодинг кудалку 3.
Мы с вами уже говорили, что в этом случае
если вы рассмотрите диагонали
и полярные углы
между, ну, от P0
до каждой из сторон, последовательно,
то эти массивы будут сортированы.
Вот.
Ну, короче, алгоритм
будет просто смерживать эти два массива
и дальше откладывать точки последовательно.
Два массива векторов.
Теперь рисую картинку.
Что делать будем?
Если мы выбрали самую нижнюю
из них самую левую точку,
то очевидно, что у нас нет
никого ниже нас.
Поэтому мы выбрали две точки
две крайние точки в вертикальном направлении.
Так, давайте я нарисую картинку
побольше.
Разлину ее.
Так, к сожалению, сумма Минковского
требует больших картинок.
Окей.
Давайте я нарисую две фигурки.
Одна из них будет
лексовый квадратик.
Красивый квадратик.
Другая будет
классный тренировок.
П.
Ку-ноль, П-ноль.
Пускай так будет.
Сначала строим П-ноль плюс Ку-ноль.
Строим ее внезапно по определению.
Это вот здесь.
У вас один-один?
Нет.
Я обманул вас, да.
Вот.
Вот.
Вот.
Я обманул вас, да.
Это здесь.
Да, это ноль плюс Ку-ноль.
Это стартовая точка,
от которой мы будем строить сумму Минковского.
Нижнее ничего нет.
Все, это нижний уровень.
Это ниже некуда просто
опускаться в вашу сумму Минковского.
Что мы дальше делаем?
Мы берем, рассматриваем.
Мы начнем вращать наш вектор
наше направление
против часовой стрелки.
И будем выбирать вектора
в стороны крайние
в соответствующих направлениях.
То есть вот у нас вектора
раз, два, три.
Раз, два, три, четыре.
Сначала будет вот этот вектор
на самом деле отложен.
Вот сюда.
Потому что он горизонтальный.
Дальше у вас будет откладываться
Вот вы чуть-чуть повернули
ваше направление.
И у вас крайней точкой
стало здесь это,
а крайней стороной вот это.
Поэтому откладывайте сумму этой точки
и этой стороны.
Дальше проворачивайте направление.
Оно стало у вас вот таким вот
горизонтальным.
Крайняя точка у вас эта,
крайняя сторона вот эта.
Поэтому откладывайте их в сумму.
Так, это мы уже заняли.
Это и это заняли.
Сейчас, подождите.
Да, я не оттуда.
Отсюда надо откладывать. Вот так вот.
Вот, да.
Так, дальше следующее.
Следующее направление становится
Нет, нет, нет. Почему?
У нас следующая крайняя сторона есть горизонтальная.
Туда и туда.
То есть я откладываю следующее направление.
У меня становится крайними точками.
Откладываю сумму этого и вот этого вот.
Да, если у нас коллинеарные,
то мы вынуждены оба отложить просто коллинеарных.
И все.
Коллинеарные отложили.
Дальше будет следующим.
Это крайняя точка в этом.
Вот в таком направлении будет.
То есть вот раз вектор
и два точки.
Три точки.
И три последние вектора завершающие.
Вот такая вот фигура у вас будет страшная,
на самом деле, с Унинковского.
Интуитивно это так делается.
Алгоритмически это будет по-другому совсем делаться.
Сейчас объясню, как это делается алгоритмически.
Шаг второй.
Назовем вектором поитом.
Куитом это будет вектор
p0 поиты.
Куиты это будет q0
куиты.
По векторам.
Мы с вами говорили, что
поиты и куиты отсортированы по полярному углу тогда.
Если мы выбрали p0 и q0
таким образом.
Давайте сделаем мерж.
Тогда у меня будут вектора
соответствующие этим сторонам.
Так я закручивал их все против часовой.
У меня вектора будут откладываться как последовательные.
Ой, что я несу?
Что за поиты?
Сейчас.
Ой, это будет p и-1
пои.
Ку-1 пои.
Ку-1 пои.
Ку-1 пои.
Ку-1 пои.
Ку-1 пои.
Ку-1 пои.
Вот.
Вот.
Вот такие вектора они будут тоже отсортированы
по полярному углу на самом-то деле.
Это тоже можно показать, что у вас постоянный угол
только будет расти.
Вот.
Вот так.
p, i, t, q, i, t
отсортированы
по полярному углу.
p, i, t, q, i, t
отсортированы по полярному углу. Отлично.
Значит, мы можем сделать их merge.
И мы получим массив
отсортированный векторов.
И шаг третий.
Получим массив r, давайте.
Шаг третий такой, что
a плюс b
нулевое равно p0
плюс q0.
a плюс b
a плюс b
и t
это будет
p0 плюс q0
от g, от единички до
и r житых.
Вот так вот будет.
Так, у нас мы взяли p0
плюс q0, стартовую точку.
Дальше от нее мы начинаем откладывать вектора
последовательно.
Это крайние. Они будут так вот заворачиваться
со временем. Поэтому
формально они будут определяться вот так вот.
Фактически уберите точку, откладывайте
тетню.
Давайте я здесь нарисую.
Ой, так.
По полярному углу и этот отсортированный
в массивках merge будет равно r.
Вот это вот будет переходить в r.
Извините.
Давайте посмотрим
все вектора сторон.
И отложим их
от одной точки. Будто бы такое будет.
Сейчас флекс.
Отложим их отсюда. Раз.
Два. Три.
Четыре.
Это вот вектора вот этих вот сторон.
Если мы взяли их
против числовой стрелки.
Обычно вот здесь вот построим такие вот вектора.
X2.
Один.
Вот.
Теперь если мы будем вращать
крайние направления
вдоль которого мы строим
крайние точки.
Мы со временем пройдем все вот эти вот вектора.
И мы будем
берем стартовую точку и откладываем от нее вот этот вектор.
От нее этот.
X2.
Вот этот.
Алгоритм именно что такой.
Очень простой алгоритм.
Работает за линию.
За сумму длин.
То есть вот смотрите. Я здесь беру P0 плюс Q0.
Дальше смотрю какой у меня вектор
минимальный в массиве r.
Это вот этот вот. Откладываю его.
Иду в этом направлении.
Дальше. Это следующий этот вектор.
Откладываю его.
Этот вектор.
Откладываю его.
Этот вектор. X2.
Откладываю X2.
Кто?
У нас они отсортированы в популярном углу
изначально. Вы сделали мерж.
Но у вас вот эти вот вектора
они отсортированы в популярном углу.
Поэтому вы сделали массив r в виде мержа.
Массива поитых и куитых.
Вроде бы и не нужно.
Вам достаточно сравнивать
синусы двух углов.
Потому что вы выбрали специально
самую нижнюю точку.
Чтобы у вас были только синусы.
Синусы явно не считают.
Но чтобы сравнить что один угол больше
другого, вы можете синусы это явно не считать.
Ой, косинус наоборот.
Косинусы явно вы можете их не считать.
Нет, достаточно.
Вы живете в верхнем полуплоскости.
Потому что вы выбрали самую нижнюю точку.
А, но здесь вектора.
Ну а здесь все вектора.
Ну да, придется косинусы и синусы посчитать.
Как обидно.
Ну естественно, вы можете даблы не сравнивать.
Вы можете сравнивать
на синусах и на косинусах.
Просто не считать их напрямую.
Корректность алгоритма
исходит из следующего утверждения.
Что если у вас была
какая-то такая
ситуация.
Давайте здесь по
положению нарисую.
Это P,
это Q,
это R.
Здесь будет S1 и здесь будет S2.
Вы рассматриваете P плюс Q точку.
И вот будто бы у вас
сумминговская вот так вот идет.
Но вопрос, почему она не может идти сюда
острее заворачивать.
То есть быть более такой пологой.
Ну не важно особо.
Почему она не может быть вот такой вот какой-то.
Доказывается тем,
что вы берете.
То есть предположим, что если это возможно,
то это точка S1 плюс S2.
Дальше вот этот вектор V
это
S1 плюс S2
минус P плюс Q.
Я ставлю только набросы доказательства, к сожалению.
Не могу.
Вот.
Это вот такие вот вектора интересные.
То есть это
вектор PS1 на самом деле
плюс QS2.
Я знаю, что у этого чувака
это я брал
сейчас, это будет P плюс R
вектор.
Я знаю, что у этой точки
это вектор U.
Я знаю, что у этого
что PS1
идет
против часовой
стрелки здесь.
Если я здесь рассмотрю вектор U,
то QS2 тоже будет идти против часовой стрелки.
Тогда как здесь B,
как их сумма
вот этих вот двух чуваков
идет наоборот против.
Ну идет по часовой кратчайший
поворот.
Но вы можете доказать вот такой вот
интересный факт,
A плюс BC
AC плюс
BC.
У вас эта штука больше 0,
эта штука больше 0,
эта штука меньше 0.
Все, невозможно.
Да, поэтому
нельзя построить ничего,
что выходит за такой вот угол.
Все.
Ну схема такая, из этого утекает корректность алгоритма.
