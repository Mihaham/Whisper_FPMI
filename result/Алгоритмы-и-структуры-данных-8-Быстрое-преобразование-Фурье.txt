Первое, что я хочу сказать, это следующее. Смотрите, вот в прошлый раз мы за интересное
время, а Н в степени алгорифм 7 по основанию 2, кажется, построили алгоритм Штрассена,
который перемножает матрицы быстрее, чем наивный куб, когда мы просто построчно
по столкцам умножаем. Так вот упражнения. Есть такой алгоритм Корацубы, который действует,
в общем-то, аналогично, только перемножает многочлены. Здесь у вас два многочлена,
тоже считаем, что длины, либо просто одинаковые длины N, либо одинаковые длины 2 в степени N,
если удобно. И вот примерно так же мы поступаем. Мы сначала бьем оба многочлена пополам. Здесь
младшая коэффициента, здесь старшая, здесь младшая, здесь старшая. И потом как-то с помощью
трех умножений вот этих более коротких многочленов сводим задачу перемножения двух исходных к трём
умножениям более коротких. И тогда симптотика будет, видимо, вот такая. Плюс, ну видимо,
что-то линейное, потому что нам нужно просто складывать какие-то многочлены внутри. И решением
такой рекурренты будет N в степени алгоритма тройки по основанию 2. Вот этого большого это
примерно N в степени 59. В смысле 1 в степени 59. Ну и соответственно в качестве упражнения
надо подобрать, вот представьте, что у вас вы первый многочлен разбили на многочлены a1, a2,
второй на многочлены b1, b2. Нужно тоже как-то построить какие-то линейные комбинации,
как-то их перемножить, свести, то есть перемножить какие-то три линейные комбинации здесь, так что в
конце результат a умножить на b должен представляться в виде там опять линейной комбинации вот этих вот
трех результатов перемножений. То есть нужно сделать три перемножения многочленов с длины N
пополам. Вот это получится алгоритм коротцуба. Я его не разбираю, оставляю в качестве упражнения,
потому что, во-первых, все необходимые техники у нас уже есть. У нас есть мастер теорема,
которая немедленно позволяет от этой строчки прийти к этой. А также у нас есть описание алгоритма
Штрассена, который еще более сложный, потому что там нужно, ну не три умножения сделать, а семь,
и там формы гораздо более громоздкие, поэтому это можете сами придумать. Вторая причина,
по которой мы не будем это полностью разбирать, потому что сегодня мы построим еще более эффективный
алгоритм, который нам вот здесь будет не N в степени, полтора примерно, а N log N. N log N
это вот то, к чему мы сейчас переходим. Быстрое преобразование фурья. Так, давайте я где-нибудь
здесь напишу все-таки, что это многочлена, потому что как-то это слово надо зафиксировать все-таки.
Есть два многочлена, ищем произведение. Вот. И такую же задачу мы будем решать с помощью
быстрого преобразования фурья. Быстрое преобразование фурья. Так, смотрите. Значит,
сначала давайте вспомним следующий факт. Если у вас есть какая-то многочлен п от х, равный,
скажем, а0 плюс а1х плюс и так далее, плюс а N-1 х в N-1, то есть многочлен в степени N-1,
у которого N коэффициентов, то он однозначно восстанавливается по значениям в произвольных
N различных точках. П однозначно восстанавливается по своим значениям в произвольных N попарно
различных точках. Попарно различных точек. То есть, если вы задаете себе систему уравнений вот
таких вот, что P от х1 равно какой-нибудь у1 и так далее, P от хN равно уN, и вам известны все х и все у,
и вы ищете многочлен P в степени меньше, чем N, то есть максимум с N коэффициентами,
тогда такое многочлен единственно определен. Так, ну, наверное, это знакомый факт какой-то. Кому он
знаком? Поднимите, пожалуйста, руки. Так, мало кому. Хорошо, не всем, по крайней мере. Ну, можно сказать так,
что такое вот эта система? Это на самом деле какая-то система линейных уравнений на ашке,
потому что здесь мне что нужно найти? Мне нужно восстановить набор ашек, а0, а1, и так далее, а1-1.
И я подставляю туда степени х, то есть я подставляю сюда х1 в нулевой, х1 в первой, х1 в квадрате,
и так далее. То же самое с х2, и так далее. То есть на самом деле у меня получается такая система
уравнений, которую можно записать в виде матрицы. Здесь будут ашки, а0, и так далее, а1-1. Здесь будут
значения, все у. А здесь будет просто матрица Вандермонда степеней хов всех. х1 в нулевой,
х1 в первой, и так далее, х1 в н-1, х2 в нулевой, х2 в первой, и так далее, х2 в н-1, и так
сводь до х. Ну и известный факт из линейной алгебры, что вот эта вот матрица, если у вас все х попарно
различны, все х не равны х, для любых неравных и ижи, тогда эта матрица просто обратима, она не
выражена, у нее не нулевой детерминат, поэтому ее можно обратить, тем самым у вас вот этот столбец
однозначно выражается через столбец у. Ну вот, например, так это можно объяснить. Ну хорошо,
то есть в принципе есть у нас какой-то метод обращения матрицы, чтобы найти столбец
коэффициентов, но это слишком долго, неэффективно, и нам это и будет и не нужно. Нам важно просто факт,
что многочлен однозначно восстанавливается по коэффициентам. Если вы возьмете точек на
одну большую степень, вот здесь точек n, а степень n-1, если точек на одну большую степень,
тогда многочлен однозначно восстанавливается. Вот что нам будет нужно. Ну и тогда смотрите,
наш алгоритм перемножения многочленов будет выглядеть как-то так. Пусть наша цель это
перемножить по IQ, дай получить многочлен r. Нам известно по IQ, нам нужно получить r.
Алгоритм перемножения будет выглядеть так. Давайте мы сначала многочлены P и Q найдем в каких-то n
точках, n различных точках, как-нибудь посчитаем. Первый шаг. Найдем P от x1 и так далее, P от xn,
Q от x1 и так далее, Q от xn. В каких-то местических точках x1 и так далее xn. В каких-то точках x1 и так далее xn.
На втором шаге мы их поточечно перемножим, потому что если я знаю значение P в точке x1 и значение Q
в точке x1, то значение r тривиально восстанавливается. Это просто произведение. На r и x это P и x это
умножено Q и x это. Ну просто из определения r. Просто поточечно перемножили эти два набора
значений. Ну и третье. Восстановим r по этому набору значений в этих точках. Восстановим r по его
значениям в точках x1 и так далее x. На высоком уровне это описание того, что мы будем делать.
Взяли какие-то точки, пришли мы смотреть. Вот эти x мы вольны выбирать сами. Какие хотим,
такие поставим. Нам не важно, какие они. Главное, чтобы их было достаточно много, чтобы их было
больше, чем степень r. Чтобы точек было большим степень результата. Чтобы можно было восстановить.
Но все остальное какие-то простые шаги. То есть нам нужно учиться как-то вот это быстро делать,
находить значение многочленов во многих точках и обратную задачу по значениям в точках найти
многочлен. Восстановить многочлен. Вот, но этим мы будем заниматься.
Так, давай там еще тоже фиксируем. Что чтобы все это работало, мне нужно, чтобы n было больше,
чем степень r. Чтобы однозначно можно было восстановить, количество точек должно быть больше,
чем степень r. Ну то есть n, ну а дек r это дек p плюс дек q. При перемножении многочленов степени
складываются. Вообще это не обязательно так. Если мы работаем в каком-нибудь там, в общем,
не в поле, тогда у нас старшие коэффициенты могут перемножиться и стать делителем нуля, в общем,
обнулиться. Но давайте считать, что у нас такого не происходит. Мы работаем всегда в поле,
поэтому степень r равна сумме степеней по иq. Ну значит просто достаточно взять в качестве n
хотя бы сумму степеней плюс один. Дек p плюс дек q плюс один. Вот, и значит наш алгоритм будет
основаться на том, что в качестве х мы возьмем все корни из единицы, все комплексные корни из
единицы. Значит в качестве х мы возьмем комплексные корни из единицы степени n, степени n.
Напомню, как это выглядит. Значит есть у меня комплексная плоскость, вещественная, компоненты
имнимы. Мы рисуем единичную окружность, вот такую вот, рисуем единичную окружность и спрашиваем
себя, значит какие точки в n степени дают единицу. Ну это понятное дело единица, а также все ее
повороты на угол 2p делить на n. Ну да, да, да, правильный n угольник, одна вершина в единичке,
ну и с центром вот здесь вот, то есть вписано в эту окружность. Иными словами, мы можем повернуть
вот этот вектор длины 1 на угол 2p делить на n, то есть как бы ну разбиваем всю окружность на n
равных таких секторов, поворачиваем, получаем очередной очередной корень каждый раз. Значит
повернули, получили, повернули, получили, повернули, получили, так несимметрично. В общем, как-то так
получим. Очень часто минус 1 будет корнем, если n четно, то минус 1 будет корнем, вот. Тут уже
моя художественная полномочия все. Ну в общем, какая-то такая картинка. И давайте мы вот эту
штучку обозначим за омегу. Примитивный корень из единицы, на самом деле не важно, что именно
обозначать за омегу, можно обозначить любой примитивный корень, то есть такой корень,
степени которого порождают всю группу корней. Ну вот нам важно будет, что омега это такое число,
что все возможные корни за единицы это степени омеги. То есть вот здесь у меня написано омега в
нулевой, здесь у меня омега в первой, здесь омега во второй и так далее и так далее. Последний чувак
будет омега в n-1. То есть все корни за единицы это степени какого-то одного числа омега. Ну и
понятно, что это за число, это е в степени и 2p делить на n. Вот такое число. Так, хорошо,
никто не испугался комплексных чисел? Отлично. Так, ну тогда смотрите, значит, тогда наша задача
следующая. Нам нужно вот взять омегу и в ее степенях посчитать значение многочлена, ну там двух
многоченов p и q. p во всех вот этих точках, q во всех этих точках как-нибудь быстро. Потом перемножить по
точечной это ревиально, ну просто знаем результат тут, знаем результат тут для p и для q, перемножаем,
получаем результат для r. А потом нужно опять, для многочлена r уже, у меня есть его значение в этих
точках, у меня есть значение r в этих точках и мне нужно его восстановить. Ну и оба этих шага мы
будем делать за n log n. За n log n, где n это вот как раз степень степени омеги, чтобы вернуться в единицы.
Так, хорошо, ну давайте начнем тогда с первого шага, с нахождения значений многочлена вот в этих
вот n точках. Да, мы будем с комплексами активно работать. Ну на самом деле он есть в плюсах,
есть в плюсах вот такой комплекс от, ну а здесь там double или long double вы пишете, вот и в общем-то
делать вам особо ничего не нужно, поэтому не проблема это. Итак, значит первый шаг,
вычисления, вычисления p во всех степенях омеги. p от омега в нулевой, p от омега в первой и так
далее, p от омега в степени n минус 1 во всех степенях омеги. Да, ну давайте напишем еще разочек,
что такое p. Пусть p от x расписывается вот так, a0 плюс a1x плюс так далее, плюс an минус 1,
xn минус 1. Вот, напоминаю, да, мне нужно взять такую омегу, что у нее степеней больше играно,
чем степень p плюс степень q плюс 1, да, вот это условие должно быть. То есть омега это корень из
единицы хотя бы вот такой степени. То есть на самом деле у меня вот этот многочлен p, у него вот здесь
куча нулей, вот этих вот последних, куча последних коэффициентов нули, но просто для удобства я
давайте буду считать, что размер этого многочлена и степень омеги до того, чтобы ее получать единичка,
это одно и то же. Просто если это не так, то я могу это многочлен добить нулями до n минус 1 степени.
Вот, мне так будет удобно. То есть здесь на самом деле куча нулей, но это не важно. Вот, давайте сделаем
следующее странное преобразование. Мы разобьем наш многочлен на два кусочка по четным коэффициентам
и по нечетным. Значит будет а0, а2х, а4 х квадрат, а6 х куб, ну и так далее. То есть мы оставляем
только четные коэффициенты, при этом степени х обычные, да, 0, 1, 2, 3 и так далее. И аналогично
с нечетными а1 плюс а3х, а5 х квадрат, а7 х куб и так далее. Вновь оставляем нечетные коэффициенты,
а набор степеней обычных х0, х1 и так далее. Тогда выполняем следующее замечательное
тождество, что p от x это p0 от x квадрате плюс x на p1 от x квадрате. Вот, ну плюс-минус очевидно,
потому что если вы вот сюда вот, всюду вместо x поставьте x квадрате, то у вас как раз получится
слагаемый с четными номерами. Если вы здесь поставите вместо x и x квадрате, то у вас получится
то, что нужно, только вот как раз без недостающего x. Ну давайте на него и домножим, получим то,
что нужно. Это вот прям совсем простое тождество. Ну зато смотрите, что это нам позволяет сделать.
Давайте считаем что N четно. Смотрите какая прелесть. Чтобы найти значение p во всех
степенях ω, мне достаточно найти значения p0 и p1 во всех четных степенях ω. Потому
потому что если здесь стоит какой-то омега вжитый,
то здесь будет омега в степени 2ж,
и здесь тоже будет омега в степени 2ж.
И если у меня n четно, то как у меня выглядит
в четной степени омеги?
Давайте я их нарисую.
Так, у меня вообще как это было?
0, 1, 2, 3, 4, 5, 6, 7, 8, 9.
Все нормально должно быть.
Вот так, да.
Значит, если у меня n четное,
то у меня четных степеней омеги ровно половина.
Мы не видели вроде.
Я тут ничего не вижу.
Ничего.
Итак, если n четно,
то четные степени омеги
это половина точек.
Омега в нулевой, омега в второй, в четвертой,
в шестой и так далее.
Вплоть до n-2 получится.
Чтобы нам победить задачу для исходного p,
мне достаточно посчитать p0 и p1
в двое меньшем числе точек.
Давайте это напишем.
Достаточно найти значение
p0 и p1 в точках
омега 0, омега 2, омега 4 и так далее,
омега в степени n-2.
И здесь точек будет вдвое меньше.
Ну и потом, соответственно,
если мы знаем значение p0 и p1
в этом наборе точек,
то чтобы получить набор значений p
во всех обычных степенях омеги,
то нужно просто пройтись по этому набору
и там с какими-то коэффициентами их сложить.
Здесь бы как раз омега в степени g вылезать.
Ну и все.
На самом деле мы свели исходную задачу
вычисления значений p в n-точках
к двум задачам вычисления значений
p0 и p1 в n-пополам точках.
Поэтому если t от n это время работы
нашего алгоритма на исходном массиве,
то t от n это 2t от t от n-пополам
плюс o от n
плюс t от n.
Потому что еще раз,
я вычислил два многочлена,
мне достаточно найти их значение
в n-пополам точках,
я делал это рекурсивно с помощью
этой же процедуры.
Посчитал их значение в этих точках
и потом за линейное время,
то есть за количество корней,
за количество степеней омеги
склеил эти два вектора
в вектор значений p по вот этой форме.
Понятно?
Ну и все, получается у меня симптотика заявленная.
В идеале, конечно, считать n в степенье двойки,
потому что если я здесь на каждом шаге
предполагаю, что он четно,
то лучше в самом начале ее сделать в степенье двойки.
Но опять, если n это не степень двойки,
то давайте добьем нулями
столько, сколько нужно здесь
до ближайшей степени двойки.
Ну и заодно мы увеличим
показатель n-ки,
то есть мы посчитаем многочлены
в большем числе точек,
чем больше точек,
тем как бы проще
находить многочлены по этим точкам.
Поэтому ничего страшного не произойдет.
Ну, кажется, с первым шагом мы справились.
Мы вот так вот можем рекурсивно
найти значения в наших n-корнях
раз за единицей.
Так, хорошо.
Давайте я это оставлю
пока что.
Второй шаг тривиален.
Если мне известны значения p
во всех степенях омеги,
то у меня есть значение
п,
и значение q
во всех степенях омеги,
то значение r-ки получается тривиально.
Это нужно просто перемножить соответствующие числа.
Вот это на это, вот это на это,
вот это на это и так далее.
Прямо как там написано.
r от омега вжитой равно p от омега вжитой
умножить на q от омега вжитой.
И этот шаг,
второй шаг нашего алгоритма
работает очевидно за
линейное время.
Просто нужно поточечно
перемножить два массива.
Так, ну хорошо.
Давайте тогда я это убью.
Теперь осталось нам
обратное преобразование сделать
по набору значений в омегах,
в степенях омеги.
Нужно наоборот найти многочлен.
Для этого давайте посмотрим внимательно,
что мы вот здесь сделали.
Давайте еще раз напишем это на языке матриц.
Вот есть у меня многочлен какой-то p,
не буду переписывать, с коэффициентами h-ки.
И мы находили его значение
в степенях омеги.
То есть по сути мы написали следующее,
мы вычислили следующее преобразование.
Мы нашли значение p-шки
в степенях омеги.
Путем домножения столбца коэффициентов
слева на какую-то матрицу.
Ну это вот ровно то самое,
что у меня было написано здесь когда-то.
Что такое
вычисление многочленов
в каких-то точках.
Это мы берем столбец коэффициентов и умножаем его
на матрицу Вандермонда, где построчно
стоят степени точек, в которые мы
считаем значение.
Ну соответственно здесь будет то же самое.
Здесь будет омега в степени 0 умножить на 0,
омега 0 на 1 и так далее,
омега 0 на n-1.
Здесь будут степени кратные единицы,
то есть 1 на 0,
1 на 1,
1 на n-1.
Последние строчки будут в степени кратной n-1.
n-1 на 0,
n-1 на 1
и так далее, n-1 на n-1.
Просто мы написали матрицу Вандермонда
для набора точек, в которых мы считаем
наш многочлен.
И посмотрите, что мы сделали.
Нашим вот этим алгоритмом
за n лог n мы
умножили
столбец размера n
на матрицу n на n.
Мы знали вот это,
мы знаем вот это.
У нас не знает матрица в явном виде,
как матрица размера n в квадрате,
но мы знаем, как каждый ее элемент задается.
Каждый элемент это просто ω в степени i умножить на j.
ω в степени умножить на j.
И вот мы за n лог n
можем перемножить эту матрицу на этот столбец,
получить столбец значений.
Вот по сути, что мы сделали с помощью
вот того первого пункта.
Умножили какой-то столбец на набор
на матрицу из степени ω.
Теперь наша задача становится обратной.
Вот я это сделал,
теперь у меня есть наоборот набор значений
многочлена r в этих точках,
и мне нужно восстановить набор его коэффициентов.
Мы уже говорили достаточно,
просто умножить на обратную матрицу.
Давайте я напишу следующее.
Давайте мы скажем, что r от x
это c0 плюс c1x плюс так далее,
плюс cn-1xv-1.
Тогда у меня выполняется следующее.
Столбец коэффициентов,
результирующего многочлена,
получается из столбца значений
этого многочлена
в наших корнях из 1.
Путем домножения
на матрицу обратную вот к этой.
Давайте я здесь напишу вот это жирное w
в степень минус 1,
где w это вот эта матрица,
матрица степени ω.
То есть еще раз, чтобы получить
столбец коэффициентов из столбца значений,
мне нужно просто вот этот столбец
домножить слева на матрицу обратную вот к этой,
обратную к матрице w. Понятно?
На самом деле можно очень легко понять,
как выглядит эта матрица.
А у нас как бы нижний это верхний?
У нас x и t это ω в степени i.
Вот.
Но смотрите, я утверждаю следующее,
что есть у меня исходная матрица,
у которой в этой житой клетке
стоит ω в степени ij.
Тогда давайте рассмотрим матрицу
вот такую, давайте я обозначу v,
где в этой житой клетке будет
ω в степени ij.
Вот.
Вот.
Где в этой житой клетке
будет стоять ω в минус
первой степени ij.
То есть мы один раз нашли обратное к ω
и возводим в ту же степень.
Тогда я утверждаю, что
эти матрицы почти что обратные.
А именно их произведение
в n раз больше, чем
единичная матрица.
Единичная матрица.
То есть, ну,
а если нам известно это,
то нам известно, как выглядит обратное
к ω, ну, к матрице w.
Это просто 1nnv.
Так.
Ну, наверное, вот это надо доказать.
Еще раз, да,
у меня есть матрица w,
у которой строки столбцы
занумерованы от 0 до n-1,
и на перечене этой строки житого столбца
ω в степени ij.
Я рассматриваю аналогичную матрицу w и j,
только там не степени ω, а степени ω в минус
первой, но в те же самых степенях и умножить
ij. Тогда оказывается, что если их просто
перемножу по обычному умножению матрицы,
то получится единичная матрица, умноженная
на n.
Вот. Ну, чего, давайте, наверное,
ну, если не докажем,
то хотя бы набросаем доказательства.
Вот я перемножаю w и хочу сказать,
что у меня получается вот такая матрица,
в главной диагонали стоят n-ки,
а в основных местах 0, то есть
единичная умноженная на n.
Вопрос, да?
Как это доказать?
Ну, смотрите, давайте мы перемножим, скажем,
и ту строчку
и и ты столбец.
И ту строчку и и ты столбец.
Мы хотим показать, что должно получиться n.
Окей.
Что находится в клетке ij вот здесь?
Значит, берем какую-то житую
столбец здесь и, соответственно, житую строчку здесь.
Что находится здесь
в клетке ij?
Ну, ω в минус 1
в степени i умножить на j.
Здесь будет ω
обычная в степени j умножить на i.
ω обычная в степени j умножить на i.
Ну, это единица, да, просто?
Потому что здесь написано ω в степени
минус ij, здесь написано ω в степени ji.
Поэтому это единица.
Ну, а нам нужно скалярно умножить
эту строчку на этот столбец,
сначала перемножили вот эти, получили единичку,
вот эти получили единичку и так далее и так далее.
У меня все эти произведения равны единице.
Потом мы их складываем, получаем n по количеству слагаемых.
Поэтому действительно
перемножение iй строки и iй столбца
дает мне n в клетке ii.
То есть на главной диагонали точно n.
Теперь, что происходит с недиагональными элементами?
Так, что происходит с недиагональными элементами?
Ну, давайте посмотрим. Давайте мы перемножим
i ту строчку опять-таки
на какой-нибудь столбец k,
накатый столбец,
где k не равно i.
Тогда мне нужна следующая сумма.
Мне нужна найти сумму
по j от 0 до n-1.
Ну, я не знаю, как это делать.
Я не знаю, как это делать.
Я не знаю, как это делать.
Я не знаю, как это делать.
Я не знаю, как это делать.
Нужно найти сумму по j от 0 до n-1,
слева остается ω в минус
первой степени ij,
а справа будет
zad salah Argentine раздав derivative
шаблон тебя
и g, здесь степень g умножить на k. Давайте я g вынесу и
будет у меня и-k. Так? Или иными словами, это вот такая
сумма, и-kg. Да, спасибо, спасибо. Это я поторопился,
к минусы, конечно. Ну а это уже просто геометрическая
прогрессия, у которой отношение не единице. Из-за того, что
k не равно i, у меня получается, что вот это не ноль, значит
у меня как бы шаг прогрессии не единица. Ну в смысле
отношение, вот это q в прогрессии не единица. Ну а мы знаем,
как считать сумму геометрической прогрессии, наверное. Короче,
давайте я напису ноль и скажу, что это сумма геометрической
прогрессии. Я эту формулу никогда не могу запомнить.
Если она бесконечная, то я знаю, если она конечная,
нет. Пытайте меня, но я не скажу эту формулу. Сумма
геометрической прогрессии. Типа вот есть у вас 1 плюс
q в степени n минус 1. Что это? Ну это видимо что-то в стиле
1 минус qn на 1 минус q. Похоже, да. Ну вот здесь q это как
раз ω в степени k минус i, и вы вот это вот складываете
в несколько первых степеней. Получится как раз у вас вот
здесь 1 минус q в степени n, где q это ω в степени k минус
i. Ну понятно, что если ω в степени n это единица, то
ω в степени k минус i умножить на n это тоже единица. Ну
значит у вас числитель просто нулевой, и все. Так, окей?
Вот. Ну эта арифметическая выкладка нам нужна для
того, чтобы понять, как выглядит обратная матрица к матрице
w. Давайте еще раз это напишем, что обратная к w это просто
одна n в. То есть если я каждую ячейку v поделю на n, то получится
наша хорошая матрица. Ну или там сначала сделаю преобразование
с v, а потом весь результат поделю на n, то тоже будет
обратное преобразование. Ну тогда смысл такой. Смысл
вот этого равенства в следующем. Если мне нужно домножить
вот этот столбец на матрицу обратную к w, то я давайте
поступлю следующим образом. Смотрите, у меня же есть
уже алгоритм, который столбец умножает просто на матрицу
w за n лог n. А теперь давайте я вот здесь всюду подменю
ω на ω в минус 1. Я здесь всюду заменю ω на ω в минус
1. Тогда по сути я умножу вот этот столбец на матрицу
w, потому что это как раз будет матрица w. Ну и в конце
нужно просто будет поделить результат на n из-за этого
коэффициента. То есть, сейчас мы все это напишем. То есть
вот это обратный шаг, обратное преобразование в фурье, оно
не отличается от исходного. Оно отличается от исходного
только тем, что мы вместо ω пишем ω в минус 1, еще в
конце делим на n. Вот и все. Третий шаг реализуется
так. Запускаем первый шаг. С ω равно ω в минус 1. То
есть мы вместо ω всюду пишем ω в минус 1. Считаем результат.
И в конце делим все получившиеся числа на n. Делим все числа
на n. Ну плюс-минус все. Вот это будет обратное преобразование
в фурье. Обратное преобразование в фурье. Ну а соответственно
первый шаг это обычное преобразование в фурье. То есть еще раз. На
первом шаге мы научились, если мы берем произвольную
ω, произвольный примитивный корень за единицей, который
порождает все остальные, мы умеем умножать любой
столбец на матрицу вот таких ω. Тогда если я запущу тот
же алгоритм, просто с другой ω в минус 1, тогда у меня
как раз получится вот это вот практически умножение
на обратную матрицу только с коэффициентом n еще лишним.
Ну давайте я просто в конце вот этот столбец получившийся
поделю просто на n и все. Понятно? Вот здесь есть такая тонкость,
которая может смущать, что раньше мы воспринимали
вот этот столбец как набор коэффициентов многочлена.
Что у меня там было а0 плюс а1х и так далее и так далее.
Я считаю значение этого многочлена в каких-то точках.
Это то же самое, что умножить на матрицу. А здесь, когда
я делал обратное преобразование в фурье, у меня как бы по
сути уже есть значение многочлена, и я делаю наоборот восстанавливаю коэффициенты.
Ну давайте не думать об этом. Давайте считать просто этот столбец чисел
опять коэффициентами какого-то многочлена. Потому что по сути мне нужно
построить вот этот многочлен по вот этим коэффициентам и посчитать его значение
в этих точках, там ω в минус ij. Ну и получится вот это вот.
То есть как ни странно, если воспринимать набор значений
как набор коэффициентов и работать с ним как раньше, как в первом пункте,
тогда мы получим набор коэффициентов.
Окей?
Так, ну отлично.
Отлично. Тогда этот шаг работает тоже за n log n.
И суммарно мы решили задачу за n log n.
Задача.
Это все назовем n log n, где n это...
Ну давайте я напишу так. По порядку это максимальная степень
dq и dq.
То есть нам их там нужно сложить, прибавить единичку, еще добить до
максимальной степени двойки. Ну по порядку это просто максимум.
Окей.
Так. Ну какие тут есть проблемы? Тут, конечно, проблемы большие с точностью,
потому что когда мы считаем корни комплексной заденицы, там, конечно,
возникает куча... Ну вот когда я рисовал окружность, там, конечно,
далеко не целые и даже не рациональные вот эти вот, получается, координаты у них.
И здесь куча всяких умножений. Возведение в степень всякие,
рекурсивные спуски, в которых еще куча умножений и сложений.
Поэтому, на самом деле, ошибка тут копится такая существенная.
Вот. На практике это все работает точно, если выполнять следующее условие.
Значит, если вы перемножаете два целочисленных многочлена,
если перемножаем целочисленные многочлены,
то есть многочлены, у которых коэффициенты это целые числа,
то это все работает точно, если у вас получающиеся коэффициенты,
они по модулю примерно 10 в 11, то погрешность не велика,
если коэффициенты r не превосходят примерно 10 в 11, 10 в 12, что-то такое.
То есть если у вас есть два целочисленных многочлена,
и вы хотите их перемножить точно, то есть понятно, что результат это целочисленный многочлен,
но если вы просто напишете два fft для p, fft для q,
потом поточно перемножите и построите обратный fft,
то, понятное дело, там будет не целые числа,
потому что у вас есть переход в комплексный, понятное дело, куча погрешностей,
все в конце будет не целое.
Но если в конце их округлить просто, если округлить коэффициенты к ближайшему целому,
то это будет правильно работать, если эти числа не очень большие,
не больше 10 в 11, 10 в 12.
Если они сильно больше, то, к сожалению, там возникает погрешность,
и вы получаете коэффициенты с какой-то погрешностью.
Это не то, что нужно, это все довольно было бы глупо.
Есть, конечно, обобщение, которое с этим борется, но мы его не рассматриваем.
Мы считаем, что в наших задачах либо коэффициенты, результирующие реально вот такие...
Еще раз?
Тильда. Ну, как бы, примерно равно.
Если коэффициенты по модулю не больше 10 в 11-10 в 12, тогда все работает точно.
Еще раз, для нас мы можем считать, что либо мы перемножаем такие многочлены,
для которых результирующие коэффициенты вот такие,
то есть мы можем считать как бы без погрешности,
либо чуть позже мы еще рассмотрим, как можно делать преобразование Fourier в ZP,
то есть там у нас будет только целые числа, никакой погрешности не будет.
Вот это чуть позже еще тоже посмотрим.
Вот сейчас мы этим и займемся, да.
Сначала я хочу рассказать о разворачивании рекурсии.
Разворачивание рекурсии.
Так, смотрите, еще раз повторю наш алгоритм.
Чтобы перемножить два многочлена, мне нужно написать, по сути, три FFT.
Одно для P, одно для Q, потом поточно перемножить, потом обратное FFT для R.
Ну а обратное FFT выражается через обычное.
То есть по сути мне нужна одна функция FFT, которая там рекурсивно что-то делает.
К сожалению, если мы напишем ее вот так рекурсивно, то это может работать довольно долго.
То есть, казалось бы, N log N, но это довольно толстый N log N,
потому что очень много, во-первых, очень много сложных вычислений,
ну вот всякие степени Омеги и так далее.
Это не очень простые операции, это не битовые сдвиги и ничего такое.
Это большие сложные операции над длинными, ну дабовскими числами.
Так, а во-вторых, здесь большие беды с памятью,
потому что когда мы вспоминаем, есть у меня массив длины N коэффициентов,
я четные сдвигаю влево, нечетные сдвигаю вправо,
и потом как-то между ними вот так прыгаю, соединяю Омега в степени 2G,
склеиваю как-то и ставлю в другую ячейку.
То есть на самом деле у меня будут большие-большие скачки по памяти,
это тоже влияет на время работы.
Поэтому рекурсивный алгоритм довольно медленный.
Давайте мы сейчас рекурсию развернем так, что у нас будет нерекурсивная реализация.
Итак, давайте посмотрим, как работает FFT, скажем, на массиве длины 8.
FFT принимает массив значений и воспринимает этот массив как набор коэффициентов коэффициентов многочлена.
Затем происходит следующее.
Мы четные индексы перемещаем как бы влево, это будет наш левый ветвый рекурсий.
У нас будет многочлен с коэффициентами a0, a2, a4, a6.
А вправое ветвье все нечетные, a1, a3, a5, a7.
Ну и соответственно здесь опять на каждом шаге мы строим вот такой многочлен,
a0 плюс a2x плюс a4x квадрат плюс a6x куб, то есть просто по этому набору коэффициентов строим многочлен.
И рекурсивно находим его значения во всех точках, во всех корнях из единицы.
Здесь в степени 4, тут в степени 8, ниже будет степень 2 и так далее.
Давайте дорисуем это дерево до конца, посмотрим, что будет в самом низу.
Здесь опять выписываем четное, то есть нелевое, и второй, a0, a4.
Здесь нечетное, то есть a2 и a6.
Здесь тоже четное, то есть a1 и a5.
Нечетное, а3 и a7.
То есть когда мы два раза спустимся в рекурсии, у меня уже будет многочлен всего с двумя коэффициентами в стиле a0 плюс a4x.
И наконец последний шаг, это просто разбиение первых коэффициентов и вторых коэффициентов.
Это будет наш последний уровень рекурсии.
A1, a5, a3, a7.
И еще раз, это мы нарисовали дерево рекурсии.
И на каждом слое, в каждой вершине этого дерева алгоритм fft получает многочлен с n коэффициентами.
Вот пусть здесь n равно 4.
И находит значение этого многочлена во всех корнях за 1 степени n.
То есть здесь во всех корнях четвертой степени, здесь во всех корнях восьмой степени.
Здесь во всех корнях второй степени, здесь во всех корнях первой степени.
Скажите, пожалуйста, чему равно значение вот такого многочлена в единственном корне за 1 степени 1?
Что?
А warum не institutions?
Да, просто это число, конечно.
Потому что на этом нижнем уровне у меня многочлен
состоит из одного коэффициента, ну и этого свободного члена,
тогда значение этого многочлена в любой точке
– это оно само.
Этот самый коэффициент.
На нижнем уровне мы знаем, что сразу не только М spielt
sweeping, но и значение multiplying в любой точке.
Хорошо, теперь давайте посмотрим вот здесь.
Тут у меня написан по сути многочлен а0 плюс а4х, а0 плюс а4х, и я хочу
найти его значение в корнях из одни со степени 2, то есть в 1 и в минус
1. Есть всего два корня степени 2, это 1 и минус 1, 1 и минус 1, но то есть понятно,
как это сделать. Нужно писать а0 плюс а4 и а0 минус а4, теперь вместо вот
этого вот массива я должен буду писать а0 плюс а4 и а0 минус а4. Я заменяю
массив коэффициентов на массив значений вот в этих вот корнях из
единиц. То, что там будет здесь, да, вот эти два числа поменяются на их сумму и
разность. Вот, и мне хочется как-то вот сделать так, развернуть всю эту рекурсию
снизу вверх, чтобы нашла, то есть на нижнем шаге у меня в каком-то порядке
стоят коэффициенты, затем мне нужно, скажем, вот по парам их так склеить,
написать сумму и разность. Здесь тоже сумма-разность, сумма-разность. Потом мне
нужно вот эти две пары склеить в одну четверку, тоже как-то понять, с какими
коэффициентными. Вот, и тем самым, как бы я не буду запускать рекурсию, я просто
промоделирую ее в вычислении снизу вверх. Вот.
Так, ну давайте, давайте смотреть. Во-первых, мне нужно понять, давайте сначала
поймем, в каком порядке вот эти коэффициенты здесь написаны. То есть почему вдруг так
случилось, что у меня на втором месте стоит А4, тут где-то А6, тут там А5 и так далее.
Ну, это очень просто. Давайте считать, что у меня исходная длина массива N равна
два в степенька, там на степени двойки. Тогда вот на этом нижнем уровне элементы
будут написаны в порядке увеличения развернутой битовой записи. То есть у меня
на самом деле будет написано следующее. Вот на этом нижнем уровне будет всегда
написано А с индексом рев от нуля, А с индексом рев от единицы, и так далее, и так
далее, А с индексом рев от N-1. Где рев — это просто разворачивание битовой
записи или там вращение ее слева-направо. Как работают ревоты. Мы выписываем I как
число в двоичной системе числения с K-знаками. То есть если она маленькая,
то добиваем слева ведущими нулями. А затем просто разворачиваем эту
запись слева-направо. Точнее справа-налево лучше сказать. Читаем справа-налево. На нашем
конкретном примере в этом легко убедиться. Что такое у меня K? K это у меня тройка. То есть я
все числа представляю как числа трехбитовая. Тогда что такое 0? 0 это то же самое, что 0,0,0,
поэтому рев от него это тоже 0. И вначале у меня стоит А с индексом рев от нуля. Все верно. Дальше
у меня идет единица. Я ее представляю как 001. Затем пишу реверс, разворачиваю строчку, читаю
справа-налево. Будет 1,00. Ну это как раз 4. В двоичной записи это четверка. Поэтому здесь как раз стоит
четверка. Давайте с двойкой то же самое еще сделаем. Двойка имеет запись 1,01, ее реверс такой же.
В смысле 0,1,0 будет двойка. Дальше, если я тройку разверну, то у меня будет 1,1,0. То есть как раз
шестерка, что и стоит на третьем месте, ну и так далее. На нашем частном примере в этом легко
убедиться. А в общем случае это легко доказать, потому что смотрите, какие коэффициенты идут в
левое поддерево? Те у которых младше бит 0. А 0, а 2, а 4 и так далее. Те у которых младше бит 0. Те,
которые четные. Соответственно здесь все нечетные. Поэтому в терминах развернутой записи, если у них
0 был последним, то здесь у них, наоборот, у меня вот это вот дерево бьется пополам, нижний слой
делится пополам. И здесь идут все коэффициенты, меньше чем половинка, то есть у которых старше
бит 0. А здесь идут те, у которых старше коэффициент 1. Больше половинки. Ну соответственно в реверсном
порядке это как раз 0 в конце или 1 в конце. Можно за n. Ну давай чуть позже. Значит дальше
спускаемся. Вот у меня есть а0, а2, а4, а6. Какие идут влево, какие идут вправо? Ну по сути что мы
сделали? Раз мы налево положили все коэффициенты четные, а0, а2, а4, а6 и так далее. И тогда мы по
сути у каждого числа, его номер в этом массиве поделили на два. То есть если мы половину элементов
удалили, то скажем вот а4 встает на место, ну на второе место, а6 встанет на третье место. То есть
каждый индекс поделится на два. Дальше то же самое. Мы смотрим на последний бит в записи. Вот это
уже 0, 1, 2, 3. И последний бит становится как бы самым решающим. Те у которых последний бит 0 идут
влево, те у которых последний бит 1 идут вправо. А в терминах вот этого как раз обратного порядка,
это значит что второй, ну здесь же по, значит здесь второй с конца бит мы рассматривали. Здесь
мы, наоборот, второй сначала бит рассматриваем. И здесь как раз, да, сначала идут те числа,
у которых 0, 0, в тычной записи, потом 0, 1, потом 1, 0, потом 1, 1. В терминах, в терминах реверса,
это как раз то, что нужно. Сначала те, у которых младший бит 0, потом те, у которых как бы
предмладший бит 0, потом предмладший бит 1, ну и так далее. То есть это можно доказать, ну собственно,
я и ПСАК как это доказывается, просто на каждом шаге у меня по сути смотрится там it и с конца бит.
Если это it и слой рекурсии, то я смотрю на it и с конца бит и по его значению распределяю либо влево,
либо вправо. Поэтому на it позиции вот в этом результившем массиве, вот в этом, будет стоять
as индексом ревоты. Вот такой список у меня получается. Окей, вопросы? Хорошо. Так, ну как считать эти
реверсы? Как считать эти реверсы? Ну как угодно на самом деле. Конечно, можно эти реверсы посчитать
в самом начале за n log n, потому что, ну или там за два в степняка множество на k, потому что
мне нужно посчитать реверсы для всех чисел от 0 до 2 в степняка минус 1, то есть для всех битовых
чисел длины k. Можно просто честно для каждого числа написать эти k bit, прочитать справа налево и
воспринимать как двоичное число. То есть каждое число я обработаю за его длину, и понятное дело,
что это можно сделать за n log n просто. Все эти реверсы можно посчитать за n log n. Либо можно сделать
это за линейное время. Давайте тоже такую оптимизацию напишем. Не то, что это сильно
повлияет на время работы, потому что основная сложность все равно не в этом. Основная сложность
в обращении к памяти и в сложных вычислениях. Ну если можно, то почему бы не сделать?
Так, с реверсами можно поступать следующим образом. Давайте мы посмотрим на старший бит числа.
Давайте будем смотреть на старший бит числа. И смотрите, вот если я знаю какой-нибудь здесь
старший бит, старший бит нашего числа, тогда как выглядит у меня реверс? Мне нужно написать
сначала вот этот кружочек реверснутый. Давайте я его назову S. Я сначала пишу S реверснутая,
потом 1, потом вот это вот. Ну а здесь будет просто куча нулей. Если это старшие дницы,
то здесь будет просто куча нулей. И если я знаю, что вот это текущий мой старший бит, то понятно,
да? То есть я знаю вот это число текущее, у него старший бит стоит вот здесь. То если я его вычту,
то я получу как бы число меньшее, для которого я уже знаю реверс. Если я напишу вот здесь вот
нулик вместо единицы, то вот это число, которое просто заканчивается на S, равно S. Для него
реверс я уже как бы знаю. Я знаю рев от S, потому что это меньшее число, до которого я уже как бы
все посчитал. Так я мне нужно просто написать будет рев от S и прибавить к нему единицу на там нужной
позиции. На позиции типа K минус и минус 1, если это и эта позиция. Ну а кон будет примерно такой.
Рев от 0 равно 0. Дальше oldest равно минус 1. Когда-то мы уже находили старший бит в каждой маске. Теперь
давайте перебираем маски от 1 до 2 степенька. Перебираем все маски в проект возрастания.
Проверяем увеличится ли старший бит. Это мы тоже помним как делать. Старший бит у меня переключается,
когда у меня число маски становится новой степенью двойки. Старший бит сначала не меняется,
потом стал степенью двойки. Старший бит перешел в более старший разряд, а здесь все занулилось.
Здесь мы пишем, если маска является степенью двойки, если маск и маск минус 1 равно 0, тогда oldest
плюс-плюс. А дальше я могу, как я здесь говорил, я могу эту единичку исключить, могу выкинуть эту
единицу. Я знаю, чему будет равен реверс для результата, и потом мне нужно будет просто эту единицу
вставить в нужное место. Видимо, надо написать что-то типа такого. Реверс от маски равно реверс от маск
XOR 1 меньше-менше oldest. Это я выкинул старший бит, посчитал реверс до вот этой оставшейся строки.
Это я написал вот это, а еще мне нужно вставить эту единичку. И мне нужно еще вставить эту единичку.
Ее можно вставить так. 1 меньше-менше k-oldest-1. Потому что после реверса вот эта позиция oldest
встанет на место k-oldest-1. Ну вот вам подсчет реверсов за отn. Потому что у меня есть цикл по n
числам, ну и внутри все за от1 считается, то есть мы обращаемся к какому-то уже посчитанному числу,
а дальше какие-то битовые просто сдвиги к XOR и так далее. Так, окей? Хорошо. Все, мы разобрались с тем,
как выглядит этот последний уровень. И давайте прям так и сделаем. Вот был у меня исходный массив А,
вот этот А0, А1 и так далее А7. Давайте я сначала посчитаю все реверсы, заведу новый массив там,
не знаю, какой-нибудь B и сейчас. Нет-нет-нет, новый массив мне даже не нужен. Секунду.
Я забыл. То есть на самом деле еще одна прелесть FFT, что его можно вот прям на том же массиве писать,
что исходной. То есть вам выдали массив длины n и вот прям на том же месте, без привлечения до
памяти. Считайте все вот это вот дерево. И вот сейчас мне нужно каким-то образом переставить
эти элементы так, чтобы они шли вот в этом порядке. Так, что-то я не помню как делается.
Ну это слишком сложно. Ладно, в общем, давайте тогда на это забьем. Да, давайте скажем,
что просто вот был у меня исходный массив А, А0, А1 и так далее, Аn-1. Я создаю новый массив,
в котором располагаю А в этом порядке. То есть А с индексом ревод 0, А с индексом ревод 1 и так
далее, А с индексом ревод n-1. Вот, в качестве упражнения можете подумать, как это сделать без
привлечения вот этого массива. То есть как переставить вот эти элементы здесь так, чтобы они
шли ровно в нужном порядке. Как их здесь переставить, чтобы они шли ровно в этом порядке. Без там,
без до памяти, без копирований. Ну хорошо, неважно. Мы можем там в два раза себя расширить память,
не страшно. Есть у меня теперь такой массив. То есть у меня по сути есть целиком информация о том,
что будет в этом нашем дереве на нижнем уровне. Теперь давайте научимся подниматься снизу вверх.
Вот есть у меня информация про нижний уровень, я хочу посчитать информацию на предыдущем уровне.
Потом на этом, потом на этом. Давайте сразу скажем, что пусть у меня есть информация там на каком-нибудь
и там с конца уровня. Значит пусть мы знаем состояние массива на житом снизу уровня,
житом снизу уровня. Ну и в массиве лежат просто числа a0, a1 и так далее an-1. То есть еще раз,
даже если делать все на одной памяти, то есть у меня как-то там переставляется числа, ну или там
можно сказать, что я вот этот массив завел сюда, сюда их поставил в нужном порядке, потом просто
перезаписал на место первого. То есть я первый массив теряю, у меня уже нет информации про исходный
набор коэффициентов a0 и так далее an-1, мне он будет не нужен. У меня сейчас вот есть текущая
информация, я считаю, что набор вот этих ашек это вот эта вот перестановка, вот в самом конце.
Потом я поднялся как-то, посчитал набор вот здесь, вот здесь и так далее и так далее,
поднимаюсь снизу вверх. И пусть у меня в какой-то момент написано вот такой вот массив ашек.
Тогда, ну давайте считаем, что здесь на этом уровне у меня ж равно нулю будет, здесь будет
ж1, здесь ж2, здесь ж3, ж снизу. Тогда смотрите, чтобы перейти к ж плюс первому уровню снизу,
мне нужно разбить все мои ашки на куски по 2 в степени ж и объединить их в большой кусок длины
2 в степени ж плюс 1. У меня корзинка какая-то такая, вот есть мой большой массив, я его разбиваю на
блоке длины 2 в степени ж, 2 в степени ж, 2 в степени ж и так далее. И потом парами их объединяю
в длинный блок длины 2 в степени ж плюс 1. Вот это будет блок длины 2 в степени ж плюс 1, вот это,
ну и так далее. И что это значит? Это значит, что вот был у меня какой-то массив коэффициентов
на этом шаге, да. Вот эти два кружочка переходят в этот прямоугольник, вот так. Был у меня какой-то
массив коэффициентов, я разбил и чётный коэффициент отправил сюда, а не чётный отправил сюда,
затем рекурсивно нашел значение вот этого многош painters во всех нужных точках и вот этого
многошmakerperson тоже во всех нужных точках я нашел значение. Теперь мне нужно найти значение вот
этого многошмином во всех точках. Нет-нет, рекурсию мы разворачиваем. От вас у нас будет
просто цикл пожи сейчас. То есть мы сначала развернули вот эти все нижние
индексы, и теперь у меня будет цикл пожи от нуля до там логарифма, до подъема в корень.
Так, давайте попишем формулу. Вот есть у меня какой-то массив коэффициентов, он
развивается на 2, и здесь я все знаю. Давайте я назову это многочленом t, и
соответственно он выглядит как-то так. Это там какой-то a и t, плюс a и плюс первое x,
плюс так далее. Плюс а с индексом и, плюс 2 в степени g, плюс 1, минус 1, x в степени 2 в степени g,
плюс 1, минус 1. Что-то такое страшное. Короче, я понимаю, что длина этого многочлена у меня 2 в
степени g, 2 в степени g плюс 1, 2 в степени g плюс 1 коэффициент у него. Соответственно,
максимальная степень здесь будет 2 в степени g плюс 1, минус 1. Ну и h здесь
соответствующим индексам. То есть это какой-то кусок, скажем, вот этот кусочек,
или вот этот. Это а1, а3, а5, а7. Так, сейчас. Х в степени 2 в степени g плюс 1,
минус 1. Так, секунду. Да, хорошо. Вот. Тогда, соответственно, я отправляю аi, аi плюс 2 и так
далее сюда, сюда аi плюс 1, аi плюс 3 и так далее вот сюда. Хорошо. И причем я знаю, давайте тоже
напишем, что t от x это то, что мы отправляем налево, t0 от x в квадрате плюс x на то, что мы
отправляем направо, t1 от x в квадрате. Здесь будет t0, здесь будет t1, а здесь нагрешен t. То есть я просто
любой нагрешен всегда в рекурсе разбиваю на 2 почетным индексом и понечетным. Так, теперь смотрите,
вот здесь вот я знаю значение во всех нужных точках, и здесь тоже хранятся значения во всех
нужных точках. Теперь давайте попробуем понять. Значит, пусть ω это корень из единицы в степени
2g плюс 1, тогда я ищу значение t во всех корнях омеги этой степени, то есть во всех степенях омеги.
Ищем t от омега в нулевой, t от омега в первой, и так далее, t от омега. Давайте вот это как-нибудь
обозначу за g большое, допустим, g минус 1. Так, ну хорошо, давайте поймем. Здесь у меня где-то будет
серединка. Для левых чисел у меня будет простое выражение. Например, там что такое t от омега в
степени g? Нет, g плохо, g у меня уже занято. И gk, пусть будет s, омега в степени s. Вот если я просто
сюда подставлю, это что такое? Это t нулевое от омега 2s плюс омега в степени s, t1 омега 2s. Вот, это
если у меня s меньше чем половинка. А если у меня, ну а для больших у меня будет следующее выполняться,
у меня будет 1 вторая g плюс s равно t0. А здесь смотрите, здесь проблема следующая, что когда я
умножаю вот этот вот показатель в два раза, умножаю на 2, у меня s переходит как бы в 2s. И если у меня s
близко к g, то у меня как бы происходит перехлёс вот на окружности. У меня была такая окружность, у меня
омега в степени s была где-то здесь. То есть оно вот так прошло, и еще степень умножается в два раза.
То есть по сути я как бы два раза прохожу этот круг, и там где-то останавливаюсь, омега в степени 2s.
Вот, и для этого, чтобы не было вот этого перехода за, ну лишнего перехода за единицу, я вычленяю
отдельно вот этот вот слагаемый 1 вторая 1 вторая g. И у меня тогда что будет здесь? У меня будет
ну формально тоже омега в степени 2s плюс g, но мы знаем что омега в степени g это единица. Омега
в степени g это единица, потому что омега это корень за единицей степени g большой. Поэтому
здесь на самом деле вот это вот 1 вторая g не влияет на аргумент. Здесь остается омега в степени 2s,
здесь будет что? Здесь будет плюс омега в степени 1 вторая g плюс s. Но понятно
что омега в степени 1 вторая g это просто минус 1. Потому что если омега в g это единица,
то омега в степении 1 вторая g это минус 1. Ну и мы считаем, что g четное, g это степень
Поэтому вот здесь вот будет написано минус омега в эстой на то же t1 от омега в степени 2s.
Так, давайте еще раз повторю. Мы взяли омегу как корень степени g большой из 1.
Омега в g это равно единице, омега в степени g большой равно единице.
Тогда у меня есть много точек, в которых я хочу посчитать значение t.
Вот этого исхода многошлина t. У меня есть омега в нулевой, омега в первой и так далее и так далее, вплоть до омега в степени g минус 1.
Хорошо, что такое t от омега в степени s? Если s достаточно маленькая, если s это меньше, чем 1 вторая g, то это просто я поставил вот в эту формулу омега в степени s.
Здесь будет t0 от омега в 2s, t1 от омега в 2s с каким-то коэффициентом.
Дальше, если омега хотя бы 1 вторая g, то степень больше равна, чем половина от всех коэффициентов, от всех вот этих вот корней,
тогда смотрите, когда она удваивается, то здесь мне нужно написать формуль 2s плюс g, потому что вот это множество на 2 будет g.
Но омега в g это единица, поэтому она не влияет на результат.
Здесь я могу написать плюс g, плюс g вот здесь в показателе, но это не повлияет на результат, я могу это стереть, потому что омега в g это единица.
То же самое здесь, я пишу просто омега в степени 2s.
Но вот этот вот коэффициент перед вторым слагаемым был раньше плюс омега в s, а теперь это омега в s, омега в степени s,
еще плюс 1 вторая g в степени. Но омега в степени 1 вторая g это минус единица.
Омега в степени 1 вторая g это минус единица, ну потому что если у меня g большой в отчетности, g большой это степень двойки,
то тогда омега в степени 1 вторая g это как раз минус 1, противоположный к единице корень.
Значит здесь просто можно поменять плюс на минус.
Итого, смотрите, что получилось. Если я возьму какие-то два соответствующие корни c0 и t1,
два какие-то значения, вот там st значение здесь и s значение здесь,
то тогда с помощью их линейной комбинации с коэффициентами омега в s или минус омега в s,
я могу посчитать вот здесь вот st член, а также коэффициент с номером s плюс 1 вторая g.
То есть еще раз, у меня st и s плюс 1 вторая gt, вот эти вот значения, они зависят от двух чисел,
t0 от омега в степени 2s и t1 от омега в степени 2s.
То есть по сути я просто беру вот эти вот числа, которые здесь у меня уже посчитаны,
и с помощью какого-то преобразования получаю значение вот здесь и вот здесь.
Причем эти ячейки, даже можно получше нарисовать, эти ячейки лежат прямо над ними,
то есть вот здесь же, в этой позиции, это лежит вот здесь же, в позиции s плюс 1 вторая g.
Смысл такой.
В итоге мы получаем следующий алгоритм.
Считаем, что у меня на нижнем уровне все посчитано, вот эти вот реверснутые ашки уже написаны.
Теперь давайте перебирать g от нуля до k, видимо.
То есть будет переход от житого слоя к g плюс 1.
Так, сейчас. Что-что?
Ну вроде нет, потому что у меня в примере было k равно тройке,
и я переходил от нуля к первому, от первого к второму, от центрового к третьему.
То есть вроде заканчивается на камен с первым шагом.
Четыре уровня внутри перехода.
Так, и меньше, чем n.
Так, сейчас надо будет внимательно быть, сейчас я напишу.
Видимо, 2 в степени g плюс 1, да?
Так, ну здесь я вольно напишу 2 в степени g плюс 1.
Понятно, что в плюсах это 1 меньше, меньше g плюс 1.
Степени-то? Нет, степени не надо предпочитывать, сдвиг работает моментально.
Сдвиг работает быстрее, чем вращение в память.
Поэтому лучше это не делать.
Итак, смотрите, вот это вот моя текущая позиция, куда я буду складывать ответ.
И у меня сначала вот здесь, я колею какие-то два результата, потом и будет вот здесь, и так далее.
И теперь смотрите, что мне нужно.
Мне нужно перебрать s-ку от нуля до половинки g, то есть до 2 в степени g.
Так?
Пишем, давайте следующее.
x равно, давайте напишу array, вот то, что у меня хранится в массиве, я буду называть array.
array от i плюс s, y равно array от i плюс s плюс 2 в степени g.
То есть в этой формуле я взял вот это вот за x, первое слагаемое x, второе слагаемое без коэффициента за y.
То есть вот эти вот два числа, из которых я сейчас буду все склеивать.
Вот это и вот это, это x и y.
Соответственно, это лежит в позиции i плюс s, это в позиции i плюс s плюс 2 в степени g.
Так?
И мне нужно просто на те же самые позиции i плюс s и i плюс s плюс 2 в степени g в этом массиве перезаписать их вот такую вот комбинацию.
Ну давайте так и напишем.
То есть array i плюс s равно x плюс омега, сейчас, сейчас, омега вестой, да, омега вестой y.
И array i плюс s плюс 2 в степени g равно x минус омега вестой умножить на y.
Вот, кажется, это все. Скопка, скопка, скопка.
Так.
Ну и по сути мы как раз развернули рекурсию, мы смогли от предыдущего слоя как бы перейти к следующему, ну то есть следующему вверх.
Давайте повторю еще раз концепцию, что здесь произошло.
Смотрите, мы считаем, что вот в этот момент времени, после входа в очередную трассу цикла по g, у меня есть какое-то состояние массива array.
Там лежат какими-то блоками длины 2 в степени, ну 2 в какой-то степени, 2 в степени g, лежат значения каких-то многочленов в каких-то корнях за единицей.
Вот такие значения вот здесь, да? Это корню многочлена в каких-то корнях из единицы, это корни другого, извините, а не корня, а значения.
Значения многочлена в каких-то корнях из единицы. Тут значения другого многочлена, тут другого и тут другого.
Моя цель их разбить по парам, и из вот этих вот значений и вот этих получить значение большего многочлена в большем числе корня из единиц.
То есть вот эти два склеить сюда. Эти два, опять, это какие-то значения двух многочленов, мне нужно из них получить значение большего многочлена.
Значит, это я здесь и делаю. Я перебираю в качестве i вот этот вот стартовый индекс блока, где
будет лирать значение большего многочлена, то есть вот это вот, мне нужно перебирать вот это,
вот это и так далее. Это как раз будет i с шагом 2 в степени g плюс 1, потому что получается у меня
больше многочлена размера 2 в степени g плюс 1. Ну а дальше делаю то магическое преобразование,
которое там написано. Я пробегаюсь по всем этим элементам, индексом s параллельно вот так вот,
s вот так бежит. Ну потом как-то мы там доказали формулой, что если я возьму соответствующие
элементы s ты здесь и s ты здесь, то их можно с помощью какой-то линейной комбинации перезаписать
в s ты сюда и в s ты сюда, то есть в s ты и s плюс 2 в степени g индекса. Вот это делается таким
вот преобразованием. И здесь как раз еще профит, что мне не нужно на каждом шаге заводить новый
массив. То есть я взял вот эти два числа x и y с каких-то двух позиций, их нужным образом сложил и
записал прямо на те же позиции, где они лежали, на те же самые позиции и plus s и plus s плюс 2 в
степени g. То есть я не привлекаю новой памяти, мне не нужен новый массив, чтобы все это пересчитать,
я прям делаю на месте, прям там же, где были все эти исходные числа. Мне не нужно будет дергать
всякие new, создавать новые векторы и так далее. Я прям все делаю там же, где числа лежат. Так,
ну здесь еще нужны какие-то оптимизации, типа как считать омегу в s, как считать все эти корни.
Так, ну давайте поймем, как это сделать. Ну можно вот здесь вот сказать, что омега это корень нужной
степени. Так, только видимо не s, а 2s. Нет, омега это корень из 1 степени 2 в степени g
плюс 1. Вот здесь я сначала начитал омегу, как-нибудь там написал, что просто написал
честные координаты, что это cos 2p делить на n и sin 2p делить на n, где n это вот это вот.
Ну можно так, но это неважно, потому что у нас все равно итерация логарифом, можно пересчитывать,
можно там ее изначально где-нибудь завести, потом степень его завести. Можно так.
Да, на самом деле это не обязательно. Если у меня есть омега, то здесь я перебираю степень
омега в порядке возрастания. Поэтому на самом деле я могу хранить просто текущую степень омега и
умножать ее на омегу каждый раз. Я вас понял. Действительно, наверное, так лучше сделать,
что вот здесь мы посчитали омегу, а также давайте в этом же месте посчитаем все ее степени. Просто
заведем массивчик степеней, где сохраним омегу в нулевой, омега в первой и так далее, омега в
степени, ну вот там максимум 2 в степени g плюс 1. Даже если можно, да, кажется можно, потому что
все независимо. Действительно кажется, что можно, но здесь я думаю, что это будет хуже, потому что вы
больше скачете по памяти. То есть вы смотрите, вы посчитали вот это, потом вот это, потом вот это,
потом вот это, вот это, вот это. Вы очень много скачете по памяти. А у меня чуть более локальные
вычисления, то есть я сначала здесь все посчитал, потом вот здесь, потом вот здесь. Согласны? Скорее
всего так можно, да, но будет больше прыжков. То есть даже если так удобнее, то скорее всего это
будет менее эффективно. Ну вот, то есть я предпочитал все степени омега, а дальше вот здесь я не буду
уже там омега бинарного степени s или что-нибудь такое. Я просто возьму из этого массива, который
я предпочитал. Вот, а все остальные операции, они у меня уже там просто сложение. Еще смотрите,
можно немножко оптимизировать. Можно вот здесь написать умножить на омега в степени s, а здесь
стереть вот эти коэффициенты. Чтобы не умножать два раза, а только один, можно изначально предпочитать
и сделать вот так. х плюс у, х минус у. Чтобы просто там еще чуть-чуть ускорить. Потому что,
ну на самом деле здесь все довольно жестоко все обычно с тайм-лимитом в этих задачах на FFT,
потому что много всяких вычислений, много скачков по памяти. В общем, здесь иногда придется
поупихивать. Еще особенно с точностью, если это, ну это ладно.
Типа, чтобы сумму, в смысле не складывать и плюс с, а обращаться к какой-то ячейке.
А как одна переменная, типа плюс-плюс делать? И потом делать плюс-плюс? А вы про то,
чтобы два раза не складывать, а просто завести в одну переменную? Да бог его знает, мне кажется,
не особо уже. Так, ну это я уже не знаю, что там оптимизирует компилятор или нет. Ну в общем,
да, то есть здесь как бы, ну вообще на самом деле этого кода скорее всего хватит, да, но если вам
надо еще поупихивать, то какие-нибудь такие, да, можно вот это вот объявить отдельной переменной
и не считать ее два раза. То же самое вот с этой. Как-то можно, да, но это уже такое, совсем какая-то
жесть. Так, последний сюжет, который я хочу рассказать, это отказ от комплексных чисел.
Отказ от комплексных чисел и переход в ZP. Переход в ZP. Значит, смотрите, предположим,
что у вас задача такая, что вам нужно не просто, ну то есть вам не нужно перемножить многочлены
прям точно, вам нужно их перемножить в ZP, то есть найти все коэффициенты по модулю P. Тогда работает
следующий интересный факт, что если P имеет вот такой вот вид 2 в степенька на R плюс 1, то есть ну понятно,
что если P достаточно большое, то оно нечетное, мы вычисляем енишку и вычисляем максимальную
степень двойки из результатов. То есть P равно 2 в степенька умножить на R, где R нечетно. То
оказывается, в ZP есть такое число, что все его степени, нулевая, первая, вторая, третья и так далее,
вплоть до 2 в степени катой, все различны. То существует такой элемент из ZP, что омега в нулевой,
омега в первой и так далее и так далее, омега в степени 2 в степенька минус 1, попарно различны.
И по сути нам ровно это и нужно было от поликомплексных чисел. Нам нужно было
уметь из единицы извлечь кучу корней. Кучу корней, ну там 2 в степеньках корней. Оказывается,
что в ZP, если вот это вот K достаточно большое, то в ZP мы можем тоже такое же делать. То есть
есть такая омега, что все ее степени различны, но при этом это корень из единицы в степени 2 в
степенька. То есть в некоторых ZP, точнее, если P вот такое хорошее и K достаточно большое,
то мы можем найти омегу со всеми нужными свойствами. То есть мне от комплексных чисел
нужно было только, что есть корень из единицы вот такой степени, что все его вот эти вот степени
различны. Больше мне ничего от комплексных по сути не нужно было. Ну, значит, если у меня P
достаточно хорошее, то есть такое, что K достаточно большое, и я могу извлекать корни
достаточно больших степеней, то у меня просто все вычисления из C можно отнаследовать в ZP,
и уже не будет никаких пробен с точностью. Вот классический пример P вот такой. 9,9,8,
3,5,3, очень часто, ну то есть. Я хотел сказать на практике, но это, конечно, нет, но там на всяких
контестах на codeforces, если нужные FFT и авторы не хотят считать в комплексных, то они просто пишут
вот такое P. Оно хорошо в следующем, что у него действительно большое K. Оно раскладывается вот
Вот так вот. Здесь х23. То есть по сути, мы тогда умеем перемножать все многочлены,
у которых результирующая степень произведения меньше, чем 2 в степени 23.
Но это большое число, поэтому почти любые многочлены можем перемножить.
Ну и здесь подойдет, например, омега равная 31.
Если вы честно напишите программу, которая перебирает все степени омега
от 0 до 2 в степени 23 минус 1, вы можете убедиться, что все они попарно различны.
И при этом омега в степени 2 в степени 23 – это единица.
То есть как раз вот это число является тем самым примитивным корнем из единицы.
Там любой степень, какой вам нужно.
И замечательно тем, что не нужно никаких комплексных чисел,
нет никаких погрешностей и так далее.
Ну да, тоже правда, считается быстрее.
Но если вы там 10 раз это напишете, то да.
Вы про вот эти числа?
Вот, еще смотрите, как найти вот эту омегу.
То есть если у вас в задаче написано P какой-нибудь,
и вам нужно сделать преобразование флея по модулю ZP,
то найти омегу в принципе можно простым перебором.
Давайте запустим цикл. То есть понятно, что омегу достаточно найти один раз,
и потом ее просто много раз переиспользовать.
Давайте напишем цикл перебора омеги 2, 3, 4, 5 и так далее,
и проверяем, что все степени различны, и омегов 2 вкат – это единица.
Ну и вот утверждается, что вы там найдете подходящую омегу довольно скоро,
потому что вот этих вот таких корней их на самом деле много.
То есть он далеко не один такой,
и очень часто вы найдете там коинь, ну не знаю,
в районе вроде сотни или даже меньше.
То есть корней таких много, вы можете их легко находить просто каким-нибудь предпочетом.
Сначала нашли, потом используете.
Вот. А еще, зачем это может быть нужно? Зачем вычислять zp?
Ну, смотрите, пусть у вас есть все-таки два многочлена, которые нужно перемножить.
И вы знаете, что их коэффициенты в результате сильно больше 10 в 11 и 10 в 12.
Ну, например, у вас есть два многочлена степени 10 в 5,
у которых все коэффициенты по модулю 10 в 5.
Тогда при произведении у вас будут коэффициенты до 10 в 15.
Коэффициент умноженной коэффициентой и так один раз. Максимум 10 в 15.
Ну, давайте тогда сделаем следующее. Мы не будем считать комплексных.
Мы посчитаем их произведение в zp1 и zp2.
Ну, где p1, p2 какие-то достаточно большие простые.
То есть я буду знать значение каждого коэффициента по модулю p1 и по модулю p2.
Ну, а дальше просто китайская терминка об остатках.
Если мы знаем значение коэффициента a i t по модулю p1, там какой-нибудь x,
и знаем его значение по модулю p2, то значение по модулю произведения вычитается однозначно.
Значит, если нам точно понятно, что коэффициенты все не больше 10 в 15,
а скажем p1, p2 это чисто порядка 10 в 9,
то, значит, из этих двух сравнений мы можем однозначно найти a i t.
a i t однозначно находится.
Значит, a i t однозначно находится, если оно меньше, чем p1, p2.
Ну, значит, если мы найдем достаточно большие p1, p2 вот с тем хорошим свойством,
что у них вот эта вот степень двойки достаточно большая,
и сможем сделать преобразование Fourier над этими двумя полями,
тогда мы сможем найти a i t точно.
Вот еще зачем-то может быть нужно.
Так, ну, на этом все. Спасибо.
