Так, всем здрасте, давайте начинать.
У нас сегодня последняя встреча, я в пользу случаем
порекламирую московский четвертьфинал ACPC, те, кто
хотят, могут собрать команду из трех человек, я уже писал
в канале об этом, сейчас скажу тоже, можно собрать
команду из трех человек и поучаствовать, предварительно
это будет 19 декабря, правда там у всех будет, наверное,
зачет на неделе, всем будет не до этого, ну короче,
если хотите, то вот 19 декабря можно поучаствовать в четвертьфинале,
и если это будет действительно в эту дату, то в зависимости
от количества задач, которые вы решите на этой олимпиадке,
будут бонусы и их зачет только экзамена, а если
это будет позже, то, соответственно, зачетную ведомость уже
придется создать, будет бонус только экзамена, если
он будет до экзамена, но тем не менее, всех приглашаю,
может быть довольно весело.
Вот, хорошо, значит, мы давайте начинать, и мы заканчиваем
Давайте я начну с того, что, напомню, определение графа
деланное.
Нет, давайте начнем сначала с диаграммы Воронова, вот
у нас есть диаграмма Воронова для набора сайтов, давайте
мы скажем, что две ячейки диаграммы Воронова соседние,
если они разделяют кусок границы положительной длины.
Будем говорить, что две ячейки VOTPi и VOTPj соседние в диаграмме
Воронова, если, ну, можно писать, что мера границы
положительна, в том смысле, что мера их пересечения
противоположительна, ну, потому что их пересечение
это какое-то одномерное множество, это либо отрезок, либо лучки
бесконечная прямая, вот, но мера в смысле R1, то есть
не площадь, а именно длина.
если они пересекаются по куску границы положительной
длины.
Вот, ну и при таком допущении, мы будем говорить, что
графт LNE устроен следующим образом, у него V множество
вершин.
Это просто все сайты, P1 и так далее, PN, все наши сайты
по которым устроен диаграмм Воронова, а ребра это просто
пары сайв, для которых соответствующие ячейки
соседние.
Соответственно, E это множество неориентированных пар,
ну, неупорядоченных пар P и Pj, таких, что VOTPi и VOTPj
соседние.
Вот, ну и что ж такое графт делано.
Давайте я скопирую какую-нибудь картинку с примером того,
как этот графт может выглядеть.
Так, ну вот, например, что-то такое, значит, смотрите,
здесь жирными точки отмечены сайты, жирные точки, это
наши сайты, P1 и так далее, PN, пунктирными линиями
обозначены ребра диаграммы Воронова, а сплошными линиями
обозначены, ну, вот, дуги между, ну, как бы, ребра
между соседними сайтами, да, то есть, вот, например,
вот эта вот дуга означает, что вот эти вот два сайта
соответствуют ячейкам, у которых вот есть этот
общий кусок границ.
А, например, вот эта вот дуга.
Вот эта дуга – это как раз, опять-таки, вот эти вот
две ячейки соседние, значит, мы проводим ребро между
сайтами.
Вот так выглядит гравт деланый, то есть, мы проводим
просто такое ребро между двумя соседними ячейками,
между, как бы, центрами ячейк.
На самом деле можно проводить не такую кривую линию, да,
не кривую между вершинами, а на самом деле можно проводить
просто прямой линией отрезок, и получится плоский
граф, который мы сейчас с вами докажем.
Если я.
на том же рисунке вместо кривых буду рисовать просто отрезки, то получится плоский граф, то есть
без сам пересечений. Мне кажется, что будет такая. Вот, соответственно, говорим следующее, что если
ребра рисовать отрезками, то будет плоский граф. Ну плоские, то есть ребра не пересекаются, кроме
так по вершину. Так, давайте попробуем доказать. Ну, пусть это не так, пусть не так. И пусть
ПИПЖ и ПКПЛ это пересекающиеся ребра нашего графа. Вот давайте мы нарисуем ребро ПИПЖ, вспомним,
что означает, что между ними проводим ребро. Мы проводим ребро в графе Делане, если только
если ячейки им соответствующие имеют какой-то общий кусок границы положительной длины, то есть
между ними есть кусок серпера, кусок середины перпендикуляра в диаграмме Воронова. Ну мы знаем,
что такое есть ребро в диаграмме Воронова. У нас был критерий в прошлый раз, что если есть какой-то
кусок середины перпендикуляра, то это означает, что есть какой-то круг, центр которого лежит как
раз таки на этом середине перпендикуляря, так вот, что этот круг пустой по отношению к П, и при этом
на его границе лежат только ПИПЖ. Вот я как-то так его нарисую. Раз это ребро треангуляции Делана,
значит между ними есть часть середины перпендикуляра, является частью какого-то ребра в диаграмме Воронова,
значит есть вот такой круг, это критерий с прошлого раза. Давайте точку я назову ХИЖ, этот круг
назову, значит этот круг я назову СИЖ, этот треугольник я назову ТИЖ. Значит так, поскольку ПИПЖ это
ребро, то существует круг с центром в какой-то точке ХИЖ такой, что внутри него, на границе лежат
только ПИПЖ, на границе лежат ПИПЖ, и больше никого нет ни внутри ни на границе, больше никого ни внутри
ни на границе. Это у нас было свойство диаграмма Воронова. Хорошо, значит есть вот такой треугольник,
давайте этот треугольник называть ТИЖ, давайте построим точно такой же треугольник ТКЛ, то есть
есть у меня второе вот это вот ребро ПКЛ, это тоже ребро тренгуляции ДЛН, значит кусок серпера присутствует
в диаграмме Воронова, значит можно опять-таки построить такой треугольник. И смотрите, что у меня есть, у меня есть два треугольника,
причем можно еще заметить, что отрезок, давайте назовем интервал, интервал, скажем, от ХИЖ до ПИ, он лежит
строго внутри ИТ-ячейки диаграмма Воронова, потому что, что значит, что за интервал от ХИЖ до ПИ?
Это какое-то множество точек, и понятно, что ближайшее к ним ко всем это ПИ, ну потому что ближайшее к ХИЖ
это ПИПЖ, значит здесь мы только приближаемся к ПИ, соответственно удаляемся от ПИПЖ, поэтому все вот эти
вот точки на этом интервале лежат строго внутри вот этой вот ячейки, ИТ-ячейки диаграмма Воронова,
поэтому в частности это означает, что на этом отрезке, ну не совсем, да, я говорил, что вот даже вот этот кусок
лежит строго в ИТ ячейки, а этот кусок лежит строго в Ж, это в частности значит, что вот тот
наш второй треугольник ТКЛ, который пересекает, то есть мы знаем, что ребро ККЛ, пересекает ребро
наших ИЖ, вот это означает, что остальные все его вершины не могут лежать внутри этого треугольника,
из-за вот этого свойства, что у меня, по сути, мой треугольник t и g расположен частично внутри
и t-ячейки, частично внутри житой. Это означает, что вот тот второй треугольник, он с ним,
как бы, ни одна вершина не лежит внутри треугольника t и g. Ни одна вершина треугольника t и g не лежит
внутри t и g. Потому что иначе, если какая-то такая картинка была бы, то есть мы предполагаем,
что они пересекаются, и какая-нибудь картинка вот такая. Здесь, например, там pk. Но это тогда
значит, что к точке x и g ближайшая точка это pk, а не p и pg. Противоречие. Но, соответственно,
все остальные случаи точно так же разбираются, то есть такого не бывает. Ну и симметрично тоже это
верно. Наоборот, ни одна вершина t и g не лежит внутри tkl. Значит, картинка будет какая-то такая.
Вот есть треугольник t и g. Есть треугольник t и g. И есть второй треугольник tkl. Он будет выглядеть как-то вот так.
Раз у них есть пересекающий вот этот ребро, мы предполагаем, что p и pg и pk и p и p пересекаются.
И при этом ни одна вершина одного не принадлежит другому, то тогда они вот как-то так выглядят.
Значит, в этом случае я утверждаю, что, давайте, давайте напишу, что я хочу сказать. Значит, тогда
один из отрезков p и xg и pg и xg пересекает один из отрезков pk xkl и pl xkl.
То есть у них там есть много пересечений. То есть если есть одно пересечение по pg pk p и при этом ни одна вершина никакого не лежит в другом, то тогда у них на самом деле много пересечений.
И вот обязательно хотя бы один из этих двух отрезков пересекается с одним из этих двух отрезков. Там просто порисовать и понять, что картинка обязательно такая.
Ну а чем это плохо? Давайте предположим, что какая-нибудь там p и xg пересекается с pk xkl.
Ну, мы с вами поняли, что вот этот интервал он целиком лежит в этой ячейке, а вот этот интервал целиком лежит в скатой ячейке.
Значит, у меня как бы внутренности ячейки пересекаются в какой-то точке, а такого не бывает. Противоречие.
Значит, это означает, что две ячейки диаграммы Воронова пересекаются по внутренности.
Ну, это противоречие, потому что мы знаем, что пересекаться не могут только по границе.
То есть если какие-то точки равно удалены от нескольких, то они лежат в нескольких ячейках, а по внутренности, понятное дело, пересекаться наши ячейки не могут.
Здесь для того, чтобы целиком убедиться, что это доказательство работает, нужно просто аккуратно порисовать там случай, как эти треугольники могут взаимно располагаться,
и понять, что обязательно будет какое-то пересечение, которое приводит нас к противоречию с определенным диаграммом Воронова.
Значит, действительно тот наш граф деланный плоский. Если просто соединять отрезком два сайта, у которых соответствующие им ячейки соседние,
тогда у нас получится обязательно плоский граф без сам пересечений.
Вот, хорошо. Можно также сформулировать такой критерий о том, что является гранью графа деланой, что является ребром графа деланой.
Это будет очень похоже на критерии для ребер и для вершин в диаграмме Воронова.
Давайте сформулируем такую теорему. Во-первых, сайты PI, PG, PK являются вершинами одной ограниченной гранью графа деланой.
Если и только если, существует такая точка Q, что пустой круг относительно этого множества точек P содержит на границе в точности PI, PG, PK,
Существует такая точка, что Q относительно нашего множества сайтов P содержит на границе PI, PG, PK.
У нас было критерий того, что точка является вершиной диаграммы Воронова.
Там ровно это и было, что если мы описываем максимальный пустой круг с центром в какой-то точке Q, то внутри него никого нет, а на границе хотя бы три точки.
Тоже самое здесь. Три точки образуют гранью, точнее, являются вершинами какой-то гранью.
Только если есть какая-то вершина диаграммы Воронова, такая, что она от них от тех равно удалена.
Внутри никого нет, а на границе круга есть хотя бы три точки.
Ну и второе, значит, отрезок.
Сейчас можно вопрос?
Да, давайте.
Вы сказали, что Q это вершина диаграммы Воронова именно, или это просто точка?
Нет, ну смотрите, если вот это выполняется, то это обязательно вершина диаграммы Воронова, потому что...
А, ну да, это мы доказали.
Да, да, это мы доказали.
И никаких других внутри, правда, Эд?
Это просто по поводу записи, что нас содержит на границе.
По определению пустой круг, это вот СQ, оно никого внутри не содержит, просто по определению.
Да, понял. Спасибо.
Вот.
Второе.
Отрезок P и Pg является ребром триангуляции Делане.
Ребром триангуляции Делане.
Если, только если...
Так, сейчас, секунду.
Что у нас там было? У нас там существует какое-то...
Ну да, существует Q.
Так, на самом деле можно просто считать, что существует такое, что CQP содержит на границе P и Pg, и больше никого.
И больше никого.
Вот, это тоже очень похоже на критерии того, что между двумя точками есть часть середины прегуляра в диаграмме Воронова.
Мы там утверждали, что наличие серпера в диаграмме Воронова равностельно тому, что на нём есть какая-то точка, такая, что пустой круг с центром в ней содержит эти две и больше никого.
Ну вот здесь тоже самое, только я ещё опустил требование того, что Q лежит на середине прегуляря.
На самом деле оно там и так не явно подразумевается.
Вот здесь можно подписать, что Q лежит на середине прегуляря P и Pg.
То есть это можно требовать, можно не требовать, оно на самом деле автоматически...
Если у нас на границе круга лежат P и Pg, то автоматически точка Q лежит на середине прегуляря P и Pg, потому что она от них равномудрена.
Поэтому это можно даже не требовать, это автоматически вытекает из вот этого требования.
А там точно ребро треангуляции главное?
В треангуляции мы можем выбирать против большиннего смысла.
Виноват графа, да, спасибо, извините, это я уже тратлюсь. Да, графа, конечно, графа.
Да, мы пока что только про графа говорим.
И доказывается, собственно, ровно точно так же, как мы доказывали все про диаграмм Воронова,
потому что здесь есть максимальная двойственность, что просто один граф это двойственный к другому.
Мы грани считаем за вершины, соединяем ребрами смежные грани, вот, собственно, просто обычная двойственность.
Поэтому все сразу переносится.
Ну и отсюда сразу следует следующее.
Значит, любая ограниченная грань графа Дилане выглядит как, как это называется,
вписанный в выпуклонный угольник, вписанный в какую-то окружность, вписанный в окружность, выпуклонный угольник.
Ну это тривиально, потому что, что значит, что у меня какие-то, например, есть какая-то грань,
в которой больше чем три вершины, 4-5, любые три из них являются вершинами одной и той же грани.
Значит, по вот этому первому свойству есть какая-то точка, такая, что они все лежат на, они все равно длины от этой точки.
Ну, в общем, понятно, что тогда эта точка должна совпадать для любой тройки, это несложно вывести.
Значит, это тогда точка должна совпадать для любой тройки вершин этого нагугольника.
Ну и значит, фигурка обязательно такая.
Есть общий центр, точка Ку, которая является на самом деле вершиной диаграмма Воронова.
Вот, и нагугольник выглядит как-то так.
То есть ну вот, вот что-то такое.
Он может как содержать ту же Ку внутри, так и может не содержать, например, что-нибудь вот такое тоже вполне себе может быть.
И вот это, вот это вершинки, которые соответствуют вершинам, которые соединены в диаграмме, в триангуляции Д'Оннельева.
Ну и соответственно тогда отсюда раз каждая грань, которая еще не треугольника, она является выпуклана нагугольником,
тогда можно на самом деле ее как угодно дотреангулировать, например, вот так вот.
Как-нибудь вот так.
И здесь тоже как-нибудь вот так.
И тогда получится триангуляция Д'Оннельева.
У нас тогда тоже определение.
Любая триангуляция графа Д'Оннельева.
Это триангуляция Д'Оннельева.
Вот, и здесь в частности легко заметить, что если у меня каждая грань,
которую мы в принципе должны триангулировать, это выпуклый вписанный нагугольник,
то вне зависимости от того, как мы ее триангулируем, у нас минимальный угол будет один и тот же.
И он будет опираться на самый маленький издук.
То есть у меня все вписано в окружность.
У меня есть эти вот куски.
У меня естьdoogie окружности.
На каждую из них после триангуляции должен опираться хоть какой-то угол,
ну, и соответственно минимальный из них должен опираться на минимальную дугу.
Поэтому не важно, как мы триангулируем.
Минимальный угол всегда будет один и тот же.
Давайте здесь напишем замечание.
Вне зависимости от способа триангуляции, вне зависимости от триангуляции…
минимальный угол один тот же. Ну а про минимальный угол почему мы говорим? Ну потому что мы как бы
мотивируемся тем, что нам нужно построить такую треангуляцию, у которой минимальный угол как
можно больше. Ну а если у нас минимальный угол не изменяется при переходе между разными
треангуляциями внутри нашего вот многоугольника, то тогда неважно как именно треангулирует,
давайте считать, что они все хорошие, они все максимизируют минимальный угол, потому что он у них
одинаковые, просто будут у всех, вне зависимости от выбора треангуляции. Вот это треангуляция деланная.
Хорошо, значит давайте так, нам все-таки наша основная цель это разработить какой-то алгоритм,
поэтому я сейчас сформулирую тезисно некоторые критерии, некоторые свойства, которые нам будут
важны для построения алгоритма, мы их видимо уже не успеваем доказать, ну значит они будут без
доказательств, но они помогают понять вообще как связано то, что мы сделали, с тем как будет
строена алгоритм. Значит теорема, давайте нашу первые критерии, первые критерии. Значит пусть есть
произвольная треангуляция данного множества точек, данного множества сайтов, тогда я утверждаю,
что она является треангуляцией деланной, вот в том смысле как мы только что определили, то есть
что она является подразбиением графа деланной до треугольников, если и только если, когда вы
описываете круг вокруг любого треугольника этой треангуляции, внутри него не будет никаких других
точек. Напишем это, треангуляция Т является треангуляцией деланной, если и только если верно следующее,
круг, описанный вокруг любого треугольника Т, не содержит внутри себя других вершин треангуляции,
других вершин треангуляции. Вот такое интересное свойство. Ну и оно собственно следует из того,
как мы строим треангуляцию деланной, значит мы взяли все вот эти вот окружности, описанные вокруг
граней, и их как-то посекли, так разбили на треугольнике, так что все равно вокруг каждого треугольника
окружность не изменилась, соответственно внутри этой окружности не будет других точек. Это перекликается
и с вот этим нашим утверждением про то, когда какие-то три вершины лежат в одной грани, когда они
являются вершинами грани, ну вот когда пустой круг какой-то есть, который никого внутри не
содержит, а содержит их на границе, ну и там возможно кого-то еще. И соответственно это можно
перенести на такое утверждение, что чтобы найти треангуляцию деланной, нам достаточно найти
какую-то треангуляцию, такую, что круг, описанный вокруг каждого треугольника, больше никого не
содержит, не содержит никаких других вершин треангуляций. Ну соответственно это как бы без
доказательств, но доказательства как бы я идейно проговорил, что вот у нас есть утверждение,
показывающее как собственно устроен граф деланной, что там когда три точки лежат в одной грани,
ну соответственно здесь нужно, и как бы мы понимаем, откуда берутся окружности, вот это вот пустые круги,
нужно просто наложить одно на другое и собственно все получится, но за нехваткой времени мы это
доказательства пропустим. Вот, значит это первый критерий, таким образом как бы мы что хотим, да, то есть в принципе
можно было бы делать так, вот есть у нас какой-то алгоритм сложно выритом Форчуна, который строит
диаграмму Воронова, и потом по ним можно построить треангуляцию деланной. Да, это можно, но тот
алгоритм довольно громоздкий, тот, который мы построим, мне кажется чуть проще, поэтому собственно я
я к нему и подвожу. То есть в принципе можно было бы треангуляцию деланной просто строить из диаграмм
Воронова, построить диаграмм Воронова, потом построить треангуляцию деланной. Вот, но чтобы это делать
по другому, чтобы напрямую строить треангуляцию деланной, нам нужно сначала понять, какие-то ее
свойства, и вот, например, здесь с помощью этого критерии мы понимаем, что достаточно найти не
треангуляцию деланной, а просто какую-то треангуляцию такую, что круг описан вокруг장 любогоижу
вокруг любого треугольника больше никого не содержит, просто переформулировка того,
что мы ищем. Хорошо, но это еще не все, нам будет нужна вторая переформулировка.
Нам нужно будет такое определение. Пусть в триангуляции T есть два треугольника
PIPGPK и PIPGPR. Причем они в объединении дают выпуклонного угольника.
Их объединение выпуклонного четырехугольника.
Картинка какая-то такая. Вот есть такой треугольник и вот такой треугольник.
Тогда операция edge flip устроена так. Она берет общий ребро наших двух треугольников и меняет
его на противоположное ребро PQP. То есть была такая картинка, а после edge flip будет
такая картинка. У нас было два треугольника смежных по ребру. Я хочу это ребро
общее удалить и вставить в противоположное ребро, так чтобы опять получились два треугольника
смежных по ребру, только по другому ребру. И вот такую операцию мы будем называть edge flip.
По-русски это перебрасывание ребра. Мы взяли одно ребро и перебросили его на противоположное,
но короче, более емко будет говорить flip. Мы так по-русски будем тоже говорить, что это flip-ребро.
Дальше мы будем говорить, что ребро нелегальное. Определение ребро PIPG нелегальное. Если после
совершения flip-ребра PIPG минимальный углов увеличится, то есть смотрите, вот здесь у меня было
6 углов, альфа-1, альфа-2, альфа-3, альфа-4, альфа-5, альфа-6. Дальше я сделал flip и у меня
стало 6 новых углов. Давайте альфа-1 штрих, альфа-2, альфа-1 штрих, альфа-2 штрих, альфа-3 штрих,
ну и так далее. Так вот, ребро нелегальное, если после flip-а минимальный из углов увеличился,
если после flip-а ребра PIPG, ну я напишу так, минимальное из альфа-и, т-штрих по всем и больше,
чем минимальное, так и плохо, и уже занято, давайте какую-нибудь другую перемену назовем,
пусть будет t, больше, чем минимум альфа, т, т, по всем t. То есть ребро нелегальное, если можно его
как бы исправить, его можно перебросить, его можно flip-нуть, так что нам станет лучше, мы наш
минимальный угол увеличим. Напоминаю, наша глобальная цель — это попытаться максимизировать
минимальный угол. Но тогда, извините, если можно просто между двумя соседними треугольниками flip-нуть
ребро и при этом увеличить минимальный угол, то понятное дело лучше так сделать. Мы так как бы, ну
возможно не увеличим минимальный угол во всей треангуляции, но по крайней мере локально сделаем
себя лучше. Этот рисунок скорее не очень хороший, здесь как бы в обратную сторону приятно было
бы делать, но давайте это сразу подчеркнем, что на этой картинке скорее вот так вот нужно делать flip,
соответственно, ребро pkpl нелегально, в том смысле, что если его flip-нуть, то получится ребро ppg и
минимальный угол, понятное дело, вырастет. Здесь минимальный угол был где-нибудь вот здесь вот,
там альфа 3 штрих, а здесь минимальный угол, ну он вот здесь, и он понятное дело больше. То есть
нелегальное ребро — это когда мы делаем flip и как бы локально увеличиваем минимальный угол.
Вот что такое нелегальное ребро. Ну и, значит, простое утверждение критерий легальности.
Критерий легальности. Пусть vt есть два треугольника, ну вот те самые,
ppgpl и ppgpl, тогда ребро ppg нелегально, если только если круг, описанный вокруг ppgpl,
содержит pl строго внутри себя. Содержит pl внутри, строго внутри, в смысле, не на границе,
а строго внутри. Вот, то есть, картинка какая-то такая, есть круг, есть вот один треугольник,
и вот есть какой-то другой треугольник ppgpl. Тогда если точка pl попала внутрь этого круга,
тогда выгоднее сделать flip и минимальный угол увеличится. Ну, как бы, на картинке это более
или менее понятно, да, то есть, если бы pl лежала на той же, как бы, на границе окружности,
то у меня получился бы вписанный четырехугольник, а тогда мы знаем, что вне зависимости от того,
как именно мы его тренируем, у нас минимальный угол останется неизменным. Вот, а если точка
внутри, то этот угол, как бы, будет сильно больше, чем угол ppgpl, значит, можно flip
на ребро и минимальный угол увеличить. Доказательства, давайте я скажу, что, то есть,
это будет без доказательств, но такой набросок я тоже скажу. Доказательства используют теремон
фалеса в такой ее постановке. Теремон такая, что если у вас есть какая-то окружность,
две точки на ней, скажем, не знаю, там a и b, есть точка, ну, а дальше есть несколько точек,
лежащих по одну сторону от a, b, значит, c лежит внутри окружности, d и e лежат на границе
окружности, точка f лежит вне окружности. Тогда вот если мы померяем все вот эти углы, там a, c, b,
a, d, b, a, d, e и a, f, d, тогда выполняется следующее, что угол a, c, b самый большой, он будет больше,
чем угол a, d, b, который равен углу a, e, b, это там, да, вписаны углы, опирающиеся на дугу,
значит, они равны, и это будет больше, чем угол, когда f за границей, больше, чем угол a, f, b, вот так.
Это там то, что называть теремфалесом, можно так сказать. Вот, ну, соответственно, используя это,
мы просто можем показать, что то, что написано выше, это критерий легальности, ну, или формально,
критерий, скорее, нелегальности, да, потому что мы написали, когда ребро является нелегальным.
Вот, хорошо. И еще здесь, значит, есть такой приятный способ понять верно это или нет,
как проверить, что какая-то точка лежит внутри окружности, построенная на трех других.
Давайте тоже утверждение без разрезательства. Пусть PQR это вершина треугольника, заданная по
часовой стрелке, заданная при обходе по часовой стрелке. Когда точка S лежит внутри круга,
внутри круга, описанного вокруг этого треугольника, если только, если выполняется
следующее, значит, можно посчитать определитель, а прежде, чтобы он больше нуля.
Вот, значит, зачем вообще это? Ну, как бы понятно, что если у меня все точки исходной целочисленности,
ну, или там произвольные, то вообще говоря, можно просто явно построить окружность, проходящую через PQR,
как-то, например, сделать, ну, можно там построить серийный перпендикуляр к двум сторонам, пересечь,
посчитать расстояние, и вот будет наша окружность, да, то есть мы знаем центр и радиус.
И потом проверить, что этот центр удален от S меньше, чем на радиус. Так можно сделать, но это переход к
даблам и, видимо, даже, ну, в смысле, к рациональным и, видимо, даже к даблам, если вы извлекаете корень при подсчете расстояния.
Вот, а если у вас все исходные точки целые, то с точки зрения, как бы, вычислительной надежности, да,
с точки зрения избежания погрешности, лучше использовать вот такой целочисленный критерий, то есть вы просто считаете определитель,
здесь все числа целые, определитель целый, да, вам не нужно будет переходить ни в какие там даблы и так далее.
Единственное, эти числа могут быть довольно большие, потому что здесь есть квадраты,
и они еще все перемножаются, в общем, числа могут быть большие, но все равно целые.
Вот, и, соответственно, просто считаете определитель, первое, что он больше нуэ.
То есть тоже можно в этом убедиться, что это, собственно, критерий того, что точка S лежит внутри круга.
Вот, хорошо, значит, есть такой у нас критерий, да, и, собственно, мы понимаем, что это, собственно, критерий того,
что точка S плохая относительно треугольника PQR, и нужно сделать флип, наша ребра была нелегальна.
Вот, дальше определение. Треангуляция T называется легальной, если в ней нет нелегальных ребер.
В ней нет нелегальных ребер.
Ну и отсюда появляется очень простой алгоритм того, как сделать любую треангуляцию легальной.
Значит, есть у вас какая-то треангуляция, в ней есть какие-то нелегальные ребра.
Давайте их просто флипать до тех пор, пока нелегальные ребра не пропадут.
То есть мы их вот так флипаем флипом, да, то есть нашли нелегальные ребра, делали флип, нашли нелегальность, делали флип, и так далее.
То есть я вот вержаю, что этот алгоритм обязательно закончится, и мы придем в...
Легальную треангуляцию.
Значит, утверждение, которое здесь можно сформулировать, такое, что из любой треангуляции можно построить легальную
за конечное количество х-флипов, за конечное число флипов
peut вы мне пор vers noite почему это будет конечное количество, то есть slut.
Может ли вы мне пояснить, почему это будет конечное количество?
То есть алгоритм очень простой. Мы просто берем и флипаем ребра пока можно, пока они нелегальны.
Вот вопрос к вам. Можете ли вы объяснить, почему такой алгоритм обязательно конечен?
Почему мы придем в конечную, в легальную триангуляцию?
Ну потому что если у нас есть нелегальная, если у нас есть нелегальная ребра, то мы его можем флипнуть,
значит мы еще не закончились. А при этом всего ребр...
Сейчас, хотя не... Ну в общем-то алгоритм остановится, потому что у нас конечное количество вариантов.
Мы можем сказать, что мы уменьшим, увеличиваем что-нибудь каждый раз.
Да-да-да, так и есть. Все верно, говорите. Мы доказываем только конечность алгоритма.
Можно для доказательства рассмотреть вектор всех углов.
Мы знаем, что в любой триангуляции фиксировано количество треугольников, пусть в триангуляции 5 треугольников,
тогда мы составим вектор углов всех треугольников, альфа-1, альфа-2 и так далее, альфа-3d в порядке возрастания.
Список углов в порядке возрастания.
Ну и тогда легко заметить, что каждый edge flip этот вектор увеличивает.
Каждый flip-ребра увеличивает этот список.
Ну, в смысле, лексикографически.
Этот список лексикографически.
Потому что он увеличивает минимально из углов.
Значит, первое отличие это обязательно увеличение углов.
Мы обязательно увеличим наш вектор углов.
Дальше треангуляции, понятное дело, конечное количество.
Там, кстати, на семинаре была задача, что показать, что треангуляция не больше 2 в степени C2.
Их в любом случае очевидно конечное количество, потому что каждое ребро либо включено, либо нет.
Их там 2 в степени C2 максимум.
И на каждом шаге мы увеличим список ребер, значит, суммарное количество итераций конечное, хоть и возможно экспоненциально.
Вот такая процедура легализации.
Значит, мы поняли, что любую треангуляцию можно легализовать путем многократных флипов ребер.
Ну и, наконец, теорема.
Второй критерий.
Второй критерий треангуляции делана.
Следующий.
Легальность равносильна тому, что мы получили треангуляцию делана.
Треангуляция T.
Легально.
Если и только если, то это треангуляция делана.
Значит, опять-таки без доказательств.
Доказательств здесь просто активно используют первый критерий.
Первый критерий я напомню, это когда мы показали, что быть с треангуляцией делана это то же самое,
что иметь окружность вокруг каждого треугольника, не содержащий внутри остальных вершин треангуляции.
Вот здесь, раз мы дали определение того, что такая легальная треангуляция,
поняли, что это на самом деле просто нужно будет для каждой пары соединенных треугольников проверить,
что одна вершина не лежит в окружности, описанная друг другу.
Это почти одинаковые условия.
Одно из них только более сильное, потому что здесь, когда мы проверяем легальность,
мы описываем окружность вокруг треугольника, потому что одна точка не лежит внутри этого круга.
А когда мы говорим в первом критерии, у нас в этой окружности нет никого вообще, нет никакой другой точки.
Соответственно, там надо проверить, что достаточно проверять только вторую вершину,
точнее вершину треугольника с между вот этому, по которому построили окружность,
и тогда получится такая тоже эквивалентность.
Этот критерий говорит нам, что на самом деле достаточно построить просто какую-нибудь легальную треангуляцию,
но мы в частности ее построили.
Какая-то легальная треангуляция, да, задолго, возможно, за экспоненту,
но гарантирую, что получится треангуляция деланная.
Ну и последняя теорема, которая нам нужна, которую мы, наверное, просто докажем,
что треангуляция деланная максимизирует минимальный угол.
Ну давайте это докажем. Пусть не так. Пусть эта треангуляция деланная с минимальным углом альфа.
Есть какая-то другая треангуляция Т4 с минимальным углом Б, которая больше чем альфа.
Т4 с другая треангуляция.
Т3 с другая треангуляция.
Есть какая-то другая треангуляция Т4 с минимальным углом Б, которая больше чем альфа.
Т4 с другая треангуляция.
С минимальным углом Б, которая больше чем альфа.
Тогда мы сделаем следующее. Мы сначала Т3 легализуем.
Легализуем.
Т3. Получим какую-то новую треангуляцию Т2, то есть наши процедуры, которые легализуют любую треангуляцию.
Можем просто пофлипать сколько-то ребер. Нелегальные ребра флипаем.
Пока все ребра легальные, то есть пока не получим легальную треангуляцию.
Получили Т2, и у нее минимальный угол мог только вырасти.
Раз каждый флип нам увеличивает минимальный угол локально, то значит глобально он тоже не может убывать.
Значит, минимальный угол в этой новой легальной треангуляции больше равен чем Б.
Хорошо. Но тогда что получается?
У меня есть треангуляция деланная Т с минимальным углом альфа.
И есть какая-то легальная треангуляция Т2-3 сейчас с углом гамма, которая больше чем альфа.
Но извините, мы же знаем, что Т2-3 тоже треангуляция деланная.
Вот по этому второму критерию, мы знаем, что Т2-3 раз это легальная треангуляция, то это действительно треангуляция деланная.
Т2-3 тоже треангуляция деланная.
Ну это, получается, противоречия, потому что у меня получились 2 треангуляции деланной, у которых equipped with different minimum angles.
Здесь альфа, здесь гамма, больше чем А.
Мы с вами строго не доказали, но проговорили, что если есть две треангуляции Дилане, то минимальный угол в них одинаковый, потому что каждая треангуляция получается под разбиением выпуклых грани графа Дилане треугольниками, и там минимальный угол будет один и тоже, он просто опирается на минимальный угол.
Итак, по всем многовольникам берем самый маленький угол, получается минимальный угол. Чтобы завершить доказательство, нужно написать, что у треангуляции Дилане одинаковый минимальный угол.
Итого, большой пласт теории, который нам говорит на самом деле следующий. Треангуляцию Дилане можно искать как какую-то легальную треангуляцию, и в ней тот самый минимальный угол будет максимально возможным.
То есть алгоритм будет такой, который мы сейчас будем строить. Мы просто будем поддерживать легальную треангуляцию, и собственно она и будет нам давать максимально возможный минимальный угол по всем треугольникам.
То есть наша задача просто найти легальную треангуляцию, и она вот по всему этому пласту теории и будет нашей искомой, которая максимизирует минимальный угол.
Ура! Вроде с теорией мы разделались. Давайте переходить к алгоритму.
Алгоритм. Он будет следующим. Он будет итеративным и рандомизированным.
Смотрите. Давайте мы сначала возьмем точку, которая находится, ну короче, самую высокую точку в нашем множестве сайтов возьмем.
Так, сейчас на секунду.
Да, ну в общем, давайте возьмем точку, которая находится в нашем множестве сайтов.
Да, ну в общем, давайте возьмем точку P0. Выберем среди сайтов точку P0.
Это точка с максимальным Y. Среди таких с максимальным сейчас или с минимальным.
Неважно. Давайте возьмем с минимальным.
А нет, нам этого не хватит. С максимальным X. Хорошо.
Возьмем точку самую высокую среди таких самых правых. Вот какая точка P0. Самая высокая, самая правая точка.
Дальше. Вот все остальные где-то там слева снизу от меня расположены.
Давайте дальше возьмем точку фиктивную P-1, где-то бесконечно далеко справа внизу.
И точку P с индексом минус два, где-то бесконечно далеко слева вверху.
А именно возьмем их так, чтобы, так ее чуть левее еще нарисуем.
То есть мы введем фиктивные точки, которые нам будут очень удобны для нашего алгоритма.
Возьмем их так, чтобы треугольник с вершинами P-2, P0 и P-1 целиком содержал внутри себя все точки нашего множества.
Все наши сайты. Так, на меня не получилось.
Вот как-то так это будет выглядеть. Соответственно, вот здесь там P1.
Короче, взяли такие достаточно далекие точки, чтобы внутри этого треугольника были все наши исходные точки, исходные сайты.
А дальше будем делать следующее. Мы случайным образом перемешаем все вот эти вот вершины.
Просто построим на них случайную перестановку.
Среди всех перестановок возьмем равновероятно случайно.
То есть все перестановки будут равновероятны.
И будем делать следующее. В каждый момент времени поддерживать триангуляцию делана, то есть произвольную легальную триангуляцию, для текущего множества точек.
Вот исходно у меня есть один треугольник P-2, P0, P-1.
И для него единственная триангуляция просто ОМСА.
А дальше будем добавлять постепенно вершины, то есть наши сайты.
Будем добавлять вершины нашего множества.
И как бы дотреангулировать так, чтобы опять получилась легальная триангуляция.
Значит, скорее всего будет происходить что-то следующее.
Вот была какая-то триангуляция на предыдущем шаге.
Не знаю, что-то такое было.
Пришла какая-то новая точка, случайная из оставшихся.
И она, скажем, попала в какой-то треугольник.
Не знаю, пришла точка P-R и попала в треугольник.
Тогда мы давайте просто проведем вот такие вот три ребра.
Дотреангулируем тот треугольник, в который она попала.
Так, чтобы опять получилась триангуляция.
А дальше просто вызовемся какими-то процедурами, которые будут пытаться вот эти ребра легализовать.
Точнее, вот эти вот ребра будут пытаться легализовать.
То есть какая могла быть проблема, да, возникнуть?
Может быть такое, что вот это ребро, да, если...
Вот это вот синее ребро.
Вот это синее ребро.
Оно раньше могло быть легальным, да, потому что, скажем, вот такой вот круг больше никого не содержал.
Не содержал никаких других решений.
А теперь он начал содержать точку P-R.
И, соответственно, надо флипнуть это ребро и его поменять вот на такое.
И тогда, соответственно, все коллизии, которые возникают, все нелегальности, которые возникли, они только связаны с новой добавленной точкой P-R.
Соответственно, давайте тогда просто вот так рекурсивно запустимся обходом по всем этим ребрам, которые потенциально могли стать нелегальными.
И флипнем их, если нужно.
И, соответственно, запустимся дальше вот...
То есть, про сути, у меня поменялся один из треугольников.
То есть у меня вот это вот большой синий треугольник поменялся на вот такой, да, как инцидентим вот этим ребру.
Тогда давайте для этого ребра проверю, не стало ли оно вдруг нелегальным.
Если стало, то его флипну и дальше проверю для всех остальных ребер.
То есть не стало ли вот это ребро нелегальным и вот это ребро нелегальным.
И так далее.
То есть у меня будет такой расходящий алгоритм, который флипает ребра до тех пор, пока не становится легErible.
Все.
Всё, это акциони алгоритмы. Давайте я его запишу. Мы случайно перемешиваем точки P1, P2 и так далее, P, ну n-1, да, все остальные точки случайно перемешал.
Дальше поддерживаем легальную триангуляцию для множества точек P-2, P-1 и так далее, P, r-1.
Потом, соответственно, вставляем новую точку P-r, в цикле по всем r, от 1 до n-1, мы вставляем эту точку в нашу триангуляцию.
Дальше подразбиваем нужный треугольник, подразбиваем треугольник, в который попала P-r.
Дальше просто запускаемся рекурсивно вот этим обходом, который флипает ребра, пока не получит, что все ребра легальны.
Запускаем флипы, пока не восстановим легальность.
Я считаю, что, по крайней мере, с точки зрения описания идеи, это алгоритм проще, чем алгоритм Форчуна,
потому что тут, как минимум, нет никаких парабол, нет никаких событий, которые там то появляются, то удаляются.
Короче, по крайней мере, с точки зрения концепции, мне кажется, что это проще.
Вот такой будет алгоритм. Здесь, конечно, много всяких тонких мест, в частности, как понять, какой треугольник надо подразбить.
У меня есть какая-то триангуляция текущая, дальше где-то внутри нее возникает точка, и мне нужно понять, внутри какого треугольника эта точка лежит.
Мне нужно как-то быстро, достаточно эффективно локализовать точку множества треугольников.
Это мы скажем как делать. Есть такой тонкий момент, что среди большого числа треугольников, которые уже построены,
нужно как-то понять, где лежит наша новая точка. Это один тонкий момент.
Второй тонкий момент. Что-то надо сделать с точками P-1, P-2, надо сказать, как их выбрать,
и на самом деле мы не будем им явно задавать координаты, мы будем их всегда с ними работать чисто символически,
то есть считать, что это не какая-то реальная точка, достаточно далекая, а просто точка с номером P-1 или P-2,
и соответственно во всех случаях мы будем аккуратно ифать, что если хотя бы одна из точек, с которыми мы работаем,
имеет отрицательный индекс, то значит с ней нужно как-то аккуратно по-своему работать, не как с обычными,
то есть мы не можем построить окружность, проходящую через P-1, потому что она супер далеко, эта окружность будет какая-то супер гигантская,
будет куча погрешностей, будет что-то неадекватное и так далее, поэтому мы с вершинами P-1, P-2 будем всегда очень аккуратно работать,
не задавая явный им координат. Вот такие есть тонкости.
Ну а пока мы просто отметим, что этот алгоритм конечный, замечание, этот алгоритм конечный,
ну собственно это очевидно, потому что что мы делаем? Мы просто на каждом шаге поняли, где лежит точка, подразбили треугольник,
а дальше запускаем флипы, исправляя все нелегальности. Мы с вами знаем, что если просто путем флипов, делать флипы, флипы,
до тех пор, пока это возможно, то в конце мы обязательно за конечные шагов пойдем к легальной треангуляции.
Мы так просто N раз, то есть по сумме мы просто N раз легализуем треангуляцию.
Ну мы знаем, что каждый такой шаг, он занимает конечное количество действий, а потому что мы доказали, что легализация всегда конечная.
Вот, ну более того, этот алгоритм работает в среднем за НЛГН.
В ожидании времени работы, в ожидании времени работы есть от НЛГН, при этом количество флипнутых ребер, количество флипов ребер в среднем есть от НЛГН.
Вот, мы тоже не будем доказывать это, еще более громоздко, но смотрите, за счет того, что мы случайно эти точки вставляем,
есть какая-то надежда на то, что в среднем нужно будет делать мало флипов, потому что вообще, когда возникает подрядность делать флип,
когда новодобавленная точка попала в какой-то из кругов, описанный вокруг какого-то треугольника,
ну понятно, что если у нас все случайно, то эта точка будет там лежать довольно редко.
Это совсем неформальное описание, но по крайней мере на это можно надеяться, что такое происходит довольно редко.
В общем, это и происходит, можно доказать, что в среднем количество флипов, которые мы запускаем суммарно по нашему алгоритму,
будет линейным за все наши итерации.
Ну а время работы НЛУГН, оно получается за счет как раз, то есть здесь основное время – это локализация.
Значит, основная сложность – это локализация, то есть как понять, в каком треугольнике лежит точка, то есть определение,
в каком треугольнике лежит ПР. То есть флипы суммарно занимают только линию, а самая сложная, основная часть по времени работы –
это локализация, то есть нахождение точки нашей большой треуголяции, которая была построена в предыдущем шаге.
Так, хорошо, давай тогда напишем такой псевдокод. Псевдокод – наша процедура построения треуголяции делана.
Ну, там с П0, П-1, П-2 мы разобрались. Значит, дальше я запускаю рандом шафл на П1, П2 и так далее, П-1.
Затем по всем R от одного. Я просто хочу записать, от каких именно ребра мы запускаем процедуру вот этой вот легализации.
По всем R от одного до N-1. Значит, да, здесь еще есть момент, что точка ПР могла попасть либо в внутренность какого-то треугольника,
либо между какими-то двумя треугольниками на границу. И тогда, соответственно, нужно нам немножко по-другому действовать.
Ну вот, пусть ПР внутри треугольника ПИПЖПК. Значит, картинка такая, да, был какой-то треугольник ПИПЖПК, внутрь попала точка ПР.
Внутрь попала точка ПР. Вот эти три ребра мы проводим, соответственно, старый треугольник мы разрушаем, заводим три новых.
И нам нужно будет проверить на легальность вот эти вот три ребра. Если они нелегальны, то их флипнуть и, собственно, запустить рекурсивно вот тех ребер опять, которые поменяются.
Пусть вот это верно. Тогда удалить треугольник ПИПЖПК, добавить треугольники. Давайте напишу все формально.
ПИПКПР, ПИПЖПР и ПЖПКПР.
А, ну да, кстати, мы же с вами хотим, чтобы каждый треугольник задавался по часовой стрелке, чтобы вот тот наш критерий был удобно проверять.
Поэтому здесь давайте я еще так индексы переставлю, чтобы вершины всегда шли в порядке по часовой стрелке.
Тогда оно будет приятно и не нужно будет каждый раз в словном определителе. Мы свели задачу определения, что есть ли точка внутри окружности, внутри круга, к подсчету определителя.
Вот там нужно, чтобы все треугольники были по часовой стрелке. ПИПЖПК был по часовой.
Тогда нужно добавить треугольник ПИПКПР. Значит, здесь неверно. Давайте я перепишу, чтобы это было ПИПРПК.
Мы там на второй строчке снова ПИПЖПК добавляем.
Еще раз повторить, пожалуйста.
На самой нижней строчке в начале снова ПИПЖПК.
Сейчас все исправлю. Спасибо. Получился вот этот вроде по часовой.
Здесь вообще я написал какой-то бред. Давайте я это удалю.
Здесь я хотел ПИПЖПР сделать. Это опять по часовой стрелке.
И здесь ПЖПКПР тоже по часовой. Все хорошо. Добавили треугольник, который обходится тоже по часовой стрелке.
Запущу еще процедуру. LegalizeEdge.
Легализовать ребро с вершинкой PR и ребро, которое я легализую, это будет ПИПЖ.
Дальше LegalizeEdge.
Новая вставленная вершинка это PR, а легализовать я пытаюсь ПЖПК.
LegalizeEdge.
ПКПИ.
Это значит, что мы попали вовнутрь треугольника.
Иначе пусть PR на границе треугольников ПИПЖПК и ПИПЖПЛ.
Тогда картинка следующая. Вот есть два треугольника наши.
ПИ.
Чего по часовой? Чтобы это было ПИПЖПК.
А здесь у него будет что-то в стиле...
Тут надо будет по-другому написать.
ПЖПИПР.
Чтобы было по часовой, будет такой получается треугольник.
Понятно. Вот наша новая точка.
Красненькая PR.
Мы удаляем наши старые два треугольника.
И добавляем вот такие четыре новых.
Давайте я не буду писать, какие мы добавляем.
Я напишу, что удалить два старых, добавить четыре новых.
Удалить два старых, добавить четыре новых.
И, соответственно, опять-таки мне нужно запуститься с процедурой Legalize
от этих четырех крайних ребер, которые могли стать нелегальными.
LegalizeEdge.
От PR запятая PIPL.
PLPJ.
PGPK.
И PKPEI.
Соответственно, здесь будет уже...
Здесь будет уже 4 LegalizeEdge.
С одной и той же вершинкой PR, новодобавленной.
И теперь ребро, которое я проверяю на легальность,
это будут те старые четыре ребра наших треугольников.
Это как только работает наша внешняя процедура,
которая поддерживает корректную легальную triangуляцию.
Что мне осталось делать?
Мне осталось понять, как локализовать.
Как понять, где лежит наша точка.
Дальше понять, как работает LegalizeEdge.
И что делать с точками P-1, P-2.
Как их корректно обрабатывать.
Давайте, наверное, начнем с простого.
Давайте начнем с Legalize.
Как работает LegalizeEdge?
LegalizeEdge.
Можно секунду вернуть на предыдущий?
Давайте сейчас.
Спасибо.
Итак, мы начнем с разбора того, как работает LegalizeEdge.
Напоминаю эту ситуацию.
Есть у меня вершина PR.
Она является вершиной треугольника PR, PIPG.
И мы пытаемся это ребро Legalize.
Это ребро может быть нелегальным.
Только когда я описываю окружность вокруг этой штуки,
сюда попадает вершина другого треугольника,
которая натянута на ребро PIPG.
Здесь есть какая-то точка.
Что я здесь делаю?
Пусть, пока это вершина второго треугольника.
Что мне нужно хранить?
Мне нужно для каждого ребра хранить две ссылки
на первый треугольник и на второй треугольник.
Это ребро how commentaires
будет ссылаться на первый треугольник и на второй треугольник,
чтобы быстро у얼ить между ними переходить
чтобы быстро понимать каким треугольником соответствует данный конкретный ребро PIPG.
Так вот, значит, есть два треугольника, один из них это PRPIPG, другой это какой-то PIPKPG.
Ну и дальше, если ребро нелегальное, если ПК внутри круга, то есть я просто напишу,
что если PIPG нелегально, что мы определяем с помощью определителя,
чтобы не переходить к сложным вычислениям, мы лучше посчитаем все в наших целых числах с помощью определителя,
то нужно, ну как всегда, нужно это ребро флипнуть, удалить старые два треугольника,
добавить новые два и запуститься рекурсивно от ребра PGPK и PKPI.
Значит, то, что нужно сделать, удалить два старых треугольника,
добавить два новых и запуститься рекурсивно процедурой legalize edge
от PG, от PR, простите, и здесь какие теперь ребра могли стать нелегальными?
Вот это вот PIPK и его сосед, PKPG.
То есть смотрите, еще раз, вот был у меня какой-то треугольник, сейчас его нарисую, вот этот вот.
Я понял, что в нем вот эта вот сторона плохая, нужно ее флипнуть, соответственно, это сторона удаляется,
это сторонодобавляется, тогда что по сути поменялось, у меня вот эти два отрезка, как были, так и остаются,
соответственно, единственное по нелегальности может быть в этом ребре, я, собственно, рекурсивно запускаюсь проверяю легально оно или нет?
Тоже самое для этого треугольника, здесь это рябро было, это рябро я добавил,
соответственно, нужно просто проверить, является ли легальное вот это рябро PIPK или нет.
нужно опять его пофлипал, запустился регустрирование
двух соседей, если нужно их флипают и так далее,
и так далее. То есть такое просто расхождение такое
вокруг ПР, мы флипаем те ребра, пока у меня не восстановится
вся легальность. Хорошо. Ну и здесь же можно показать,
что это все будет корректно, то есть мы действительно
все наши ребра, которые потенциально могут быть нелегальными,
проверим. Для этого утверждение, после завершения всех
legalize, после завершения всех legalize edge, получим
легальную треангуляцию. Это следует из того,
что добавляемые ребра, мы какие-то ребра удаляем нелегальные
и вставляем их, антиподы они уже обязательно будут
легальными. Это следует из того, что добавляемые ребра
одной из вершин содержат ПР. То есть вот тут всегда,
когда я ребро удаляю, я обязательно добавляю ребро,
которое ему противоположно, и вершина этого ребра обязательно
будет ПР. Ну то есть легко прослеживать наш legalize edge
именно такой. Он удаляет какое-то ребро, не содержащий
ПР, и вставляет ребро, содержащий ПР, как один
из концов. А такие ребра обязательно лежат в графе
деланы. То есть смотрите, что происходит. Мы вставили
какую-то точку, дальше провели три ребра. Давайте в случае,
когда исходная точка, которую мы вставляем ПР, она
лежала внутри треугольника, мы провели три ребра. Дальше
что? Я утверждаю, что эти ребра уже обязательно будут
легальными, потому что они лежат в графе деланы, значит
их уже точно не надо будет трогать. Соответственно,
единственная нелегальность может быть для вот этих
трех ребр. Но для них я запускаю процедуру legalize edge,
и если надо, флипают. Вот это ребро было нелегально,
я его удалил. Я его удалил, добавил в такое ребро. Теперь
это ребро легальное. Эта легальность, соответственно,
нелегальность могут быть только на концах вот этих
треугольников. А для них я запускаю все рекоменсивно,
и если нужно, их флипают. То есть, смотрите, если доказать
вот это утверждение, что те ребра, которые я добавляю,
обязательно лежат в графе деланы, а значит они автоматически
нужны, нам их не нужно флипать. Тогда все потенциальные
нелегальности я исправлю, потому что я поставил точку,
она образовала какие-то нелегальности, и все ребра
которые потенциально могли стать нелегальными, я до них
даю вот этим вот расходящимся обходом.
Единственное, осталось доказать, что те ребра, которые я
добавляю, они обязательно будут легальными, то есть они
обязательно лежат в графе деланы.
Так, давайте немножко это осветим.
Такое полудоказательство, давайте это утверждение
нужно сделать без доказательства к экзамену, а так я
опять-таки немножко осущу, почему-то верно. То есть,
почему все ребра, которые одним из концов содержат
новые ПР, обязательно легальны, обязательно вводы и
инкуляции деланы в графе деланы.
Ну, смотрите, давайте посмотрим на самое начало.
Когда мы нашу точку ПР вставили в какой-то треугольник.
Что это означало? Раньше у меня была легальная
треугуляция, то есть была какая-то треугуляция делана.
Это в частности означало, что вот в этом вот круге
никого больше нет, то есть во внутренности этого
круга нет никаких других сайтов.
И единственная новая точка, которая лежит в этом круге,
это точка ПР.
Хорошо, тогда давайте возьмем какую-то вершинку
ПИ. И давайте наш круг, вот этот большой круг так
сузим, чтобы он по-прежнему содержал ПИ и содержал
ПР на границе, а точки ПЖ и ПК уже не содержал.
То есть, ну вот круг будет какой-то такой.
То есть был какой-то круг С, значит, его можно сузить
до круга С штрих, который вложен в круг С.
Так что С штрих содержит ПИ и ПР на границе.
И больше никого. На границе. Больше никого.
Больше никого. Ну извините, а это у нас критерий того,
что отрезок между двумя сайтами является ребром
треугуляции деланной, что есть какой-то круг, проходящий,
то есть пустой круг, внутри которого нет вершин,
и на границе которого есть в точности вот эти наши две точки ПИ и ПР.
Я просто так сузил исходный большой круг до круга поменьше,
то есть была какая-то точка внутри него, я сузил так круг,
чтобы точку ПИ оставался сдержать.
Теперь начнем содержать ПР на границе.
Значит, это как раз таки критерий того, что ребро ПИ и ПР
лежит у нас в графе деланной.
Это у нас был такой критерий, что если есть такой круг,
то обязательно ПИ и ПР это ребро.
Ну, соответственно, точно так же можно было бы сдуть этот круг
до такого, до такого, до такого.
Тем самым вот эти три ребра точно лежат в графе деланной.
Просто по нашему критерию того, что является ребром графа деланной.
Ну а дальше, то есть это что происходит, когда мы вставляем ребро,
нужно еще рассмотреть случай, когда мы флипаем ребро,
но там точно так же, там у нас был какой-то круг,
внутри которого никого не было,
то есть исходно же была легальная треангуляция,
то есть внутри круга никого не было.
Дальше встала новая точка ПР,
ну и мы также можем сузить круг,
чтобы он содержал только вот эти две точки на границе,
значит, это обязательно будет ребро графа деланной.
То есть в итоге мы поняли,
что наш алгоритм действительно в конце
получит нам легальную треангуляцию за конечный счет шагов,
то есть больше никаких нелегальностей быть не могло.
Вот, начнется первый шаг,
это был шаг с легальной ассетии как работа.
Значит, второй шаг, это мы хотим научиться
решать задачу локализации.
Задача локализации.
То есть как понять, где лежит,
в каком треугольнике лежит новодобавляемая точка ПР.
В каком или в каких
треугольнике лежит точка ПР.
То есть да, напоминаю,
первый шаг, который нам нужно сделать,
это понять в каком треугольнике
или в каких двух треугольниках лежит точка ПР,
и дальше как его подразбить и запустить иголай скетч.
Значит, вот как это делать.
Мы сделаем следующее.
Мы будем в каком-то смысле хранить историю
всей нашей треангуляции
в виде ориентированного циклического графа.
Храним
историю
треангуляции
в виде дак
directed
cyclic
graph
ориентированного циклического графа.
Графo
ориентированного циклического графа.
Значит, каждая вершינה
это треугольник.
Вершина
это треугольник, но возможно
и не треугольник текущей треангуляции,
а треугольник, который когда-либо был,
треугольник, который когда-либо
существовал,
который когда-то
существовал.
То есть на самом начале,
треугольнику p-2, p0, p-1. Вот есть такой один треугольник. Дальше. Какие у меня бывают
процедуры? У меня есть процедура подразбить один треугольник на 2 или на 3, в зависимости от того,
куда попала точка на границу или в обновленность. И есть еще процедура флипа. Вот давайте с ними
помнём, как работать, и помнём, как меняется наш дак. Значит, первая процедура — это когда один
треугольник разбивается на 2. Ну или на 3. Разбивается на 3. Здесь всё очень просто. Картинка
такая. Был какой-то треугольник p и pgpk. Пришла новая точка p и, соответственно, старый треугольник
распался, а вместо него появилось треног. Но давайте тогда из вершины, которая отвечает треугольнику
p и pgpk проведём ребра в три новые вершины, которые отвечают новым трём добавленных треугольников.
То есть будет вершина, отвечающая треугольнику pk, p и pr. Будет вершина, отвечающая треугольнику p и pgpk.
Ну и будет вершина, отвечающая треугольнику pg и pkpk. Мы знали, что исходно был такой треугольник,
и мы знаем, что с ним происходит на данной итерации. Он просто распадается на 3.
Соответственно, давайте просто проведём 3 ребра вот этих треногов в треугольник. Если же была
картинка вот такая, что было два треугольника с межных по ребру, и пришло pr вот сюда,
пришло pr вот сюда, тогда что происходит? Мне нужно вот этот первый треугольник разбить на два вот таких,
то есть просто из треугольника p и pgpk провести. Давайте не буду писать, слишком много букв.
Короче, если точка pr попала на границу двух треугольников, тогда нужно просто разбить на два
первый треугольник и разбить на 2 второй треугольник. То есть здесь будет не 3 дочерних узла,
а всего 2. То есть ситуация по сути такая же. Это что происходит с подразбиением. Теперь что
происходит с флипами? Эдж флип. Эдж флип мы будем обрывать так. Вот было у меня, получается,
два треугольника какие-то, и я вместо вот этого ребра строю вот такое ребро. Пусть там было
pi, pg, pk, pl. Соответственно, было в моей истории, были две вершинки, которые соответствуют этим
треугольникам. Pg, pi, pg, pk и треугольник pi, pg, pl. Тогда давайте я просто заведу две вершины
соответственно нашим треугольником. Это что будет? pi, pk, pl и pk, pg, pl. Ну и просто проведу ребра вот
такие. Соответственно, был вот этот старый треугольник. Он так подразбился, он точнее
флипнулся с другим, так что теперь они вместе, вот эти два треугольника, пришли вот в эти два.
Тогда давайте просто перекрёстим все эти 4 ребра проведу. Это как бы означает, что вот этот наш
треугольник как-то так изменился, что теперь он находится частично здесь, частично здесь. То
есть он так подразбился, так флипнулся, что он как бы вот так на два разделился. И с этим тоже
он был один треугольник, а теперь он частично находится здесь, частично здесь. В чем смысл? Смысл в том,
что когда мы спускаемся вниз по какому-то ребру, мы по сути переходим в меньше треугольник. И тогда
как решать задачу локализации? Мы встаем в корень нашего дага, встаем в вершину, которая
отвечает треугольнику p-2, p0, p-1 и дальше смотрим, ага, ну понятно дело, что новая давальная точка pr
заведомо лежит в этом треугольнике, то есть точка, которую мы пытаемся локализовать, точно
лежит в этом корневом треугольнике. Дальше из него есть несколько ребер, 2 или 3, вопрос в каком из них
лежит наша точка? Ну хорошо, вот есть у меня три опции, есть три треугольника, давайте просто
вспомним, в каком из них мы лежим, спустимся туда. Потом опять, это какой-то треугольник, который
когда-то существовал. Дальше он как-то подразбился или как-то виды изменился, либо он подразбился
там два или три треугольника вот здесь, либо он флипнулся с другим, и соответственно он лежит
либо здесь, либо здесь. Ну тогда давайте просто опять, у меня есть там две или три опции, я просто
спускаю 100 из двух-трех треугольников, в котором лежит наша новая точка p. Итак, в итоге я дойду
до листовой вершинки, а листья это как раз будут текущие треугольники нашей треангуляции. И
собственно там и будет лежать наша вершина. В итоге локализация работает так. Локализация.
Встать в корень сначала. Дальше мы делаем спуск в такой дочерний треугольник,
дочерний треугольник, где лежит, ну как бы, та точка p, которую мы пытаемся локализовать.
Завершаемся в листе. А лист — это и есть треугольник текущей треангуляции. Ну потому что
что такое нелестовые вершины. Нелестовые — это те, которые изменились, которые когда-то
существовали, дальше их как-то изменил, либо подразвел, либо флипнул, то есть они перестали
существовать, и теперь их более свежая версия вот такая. Соответственно лист — это треугольник,
который больше не менялся, то есть он когда-то создался и больше не изменялся, то есть как раз
лист — это вот какой-то треугольник треангуляции. Ну и все, получается вот такой даг, внутри которого
мы можем локализовать нашу точку p-r. И за счет случайного перемешивания и за счет того,
что суммарно будет всего линейное количество флипов, можем доказать, что глубина этого дага
будет логерифмическая. Ну, в смысле, от ожидания будет логерифмическая. За счет случайного
порядка p1 и так далее, pn-1, граф будет иметь в среднем логерифмическую глубину. Вот тем самым
Хорошо. Ну, соответственно, последняя тонкость, с которой нужно разобраться — это как обрабатывать
точки p-1, p-2. Как обрабатывать точки p-1, p-2? Давайте так. Давайте мы скажем, что пусть... Ну, не так.
Будем говорить, что точка p выше точки q, если либо у нее больше y,
либо у них одинаковый y, но x меньше. Вот. И тогда мы скажем формально, значит, формально p-1 — это
точка, которая располагается ниже всех точек из исхода, ну, что p. Точка ниже всех точек p. Такая,
что из нее все точки в порядке по часовой стрелке видны в порядке возрастания отношения выше,
в порядке высоты я напишу. В порядке высоты. Вот картинка такая. Значит, есть какие-то наши точки,
вот какие-то такие точки исходного множества. Дальше я беру эту точку настолько далеко,
настолько справа, что значит, что я смотрю на все эти точки в порядке по часовой стрелке. То есть я
провожу все вот эти векторочки, сортирую их по углу в порядке по часовой стрелке, и тогда понятно,
что минимальной будет такой чувак, у которого y минимальная возможность. То есть если эта
точка достаточно далеко справа, то влияет больше всего именно y составляющая. То есть давайте
вот здесь на всю точку. Она будет как бы самой первой часовой стрелке. Дальше будет вот это по
y, дальше будет вот это, вот это. Ну, короче, они будут видны в порядке по часовой стрелке в том же
порядке, как они видны в порядке вот это вот отношение выше. В порядке высоты они будут видны
в таком же порядке. Вот, и при этом, да, нужно еще сказать, что p-1 так далеко,
что не лежит ни в одном круге, построенном по трем точкам xp. Ну, то есть так, чтобы она не
попадала ни в одну окружность, мы ее просто довольно далеко возьмем. Значит, дальше формально мы
говорим, что p-2 выше всех точек p, выше всех точек p, и при этом из нее в порядке против часовой
стрелки, опять-таки все вершины видны в порядке возрастания высоты. Все
точки из p объедините p-1, видны в порядке возрастания высоты. Ну, опять, да, вот есть эти наши точки
нормальные, обычные, есть где-то там справа внизу точка p-1, значит, мы берем точку p-2 где-то слева
вверху, так что опять здесь уже направление на них на всех, справа вниз, соответственно, будет
такой порядок. Мы, соответственно, так сейчас, вот, соответственно, самая низкая точка, это,
конечно, будет p-1, дальше будет точка с минимальным y, дальше будет точка там со следующим по минимальным
с y, ну и так далее, и они будут видны в порядке против часовой стрелки. Вот так мы определили p-2,
ну и также p-2 достаточно далеко, так что она не лежит ни в одном круге, образованном тремя точками
из p или p-1, вне любого круга, проходящего через три точки из p в объединении с p-1,
то есть мы там строим любые вот такие три круга, любой круг по другим точкам и p-2 так далеко,
чтобы этого не происходило. Вот, хорошо, давайте тогда напишем, что значит ребро легальное.
Да, проверка легальности p и pg, да, другие вершины это pkp, другие вершины это pkp, то есть есть
какое-то ребро p и pg, мы его тестируем на легальность, зная, что два треугольника,
которые этому ребро ицинентны, это pk и pg. Значит, случай первый, если p и pg это ребро треугольника
p-2, p0, p-1, то p и pg легально. Ну, легко заметить, что вот этот наш внешний треугольник p0, p-1, p-2,
он настолько большой, что он, короче, он все равно будет легальный, потому что нет никакой другой
окружности, которая бы содержала p-1 или p-2 внутри себя, то есть все остальные окружности супермаленькие
по сравнению с этим большим треугольником, значит этот треугольник будет обязательно легальный.
Второе, если ijkl больше на нуля, то мы делаем обычную проверку через определитель, то делаем
обычную проверку через определитель. То есть, если у меня все точки нормальные,
не содержат там бесконечных больших координат, то работает наш обычный
определитель для определения легальности. И наконец последнее, иначе, если есть минимальное,
то я утверждаю, что ребро p и pg легально, если и только если минимум из kl меньше, чем минимум из ij.
Чтобы это понять, мы сначала замечаем, что из индексов ij не больше одного отрицательного,
не больше одного отрицательного, потому что если не оба отрицательны, то это ребро треугольника вот
этого, значит мы его уже разобрали, это notecase, то есть мы уже должны были бы разобрать. Ну и дальше
понятно, что kl, хотя бы одна из них, это точка pr, хотя бы одна, это pr, потому что мы legalize
запускаем только когда одна из вершин токплеера, значит тоже не больше одного отрицательного,
не больше одного отрицательного. Вот, ну и дальше, значит, если надо разобрать случай, если среди
этих четырех чисел есть всего один отрицательный, то что может быть? Либо вот здесь вот отрицательное
число, ну значит понятное дело тогда, что это означает, что это какие-то, допустим, нормальные
вершинки, а это супердалекая вершина, там p-1 или p-2, ну тогда понятно, что ребро p и p же
легальное, потому что внутри этого треугольника пк точно не содержится, то есть в этом случае все
хорошо. Дальше, если вот это вот минус один, то получается, что это супербольшой треугольник,
это какие-то нормальные точки, тогда, сейчас, секунду, а, ну да, тогда это ребро, конечно,
нелегально, то есть если среди чисел i, j, k ровно одно отрицательное, и это i или j,
тогда вот это ребро нелегальное, потому что это супербольшой треугольник, понятное дело,
что окружность, проходящая через p и pg, она содержит там вообще все на свете, в частности,
конечно, pk. Значит, ребро нелегальное, и мы и получаем, что он нелегальный, вот это не
раз не выполняется. Ну и то же самое нужно проверить, что если ровно одно из них отрицательное,
ровно одно из них отрицательное, тогда в зависимости от того, кто из них минус 1,
а кто из них минус 2, вот это не раз, опять-таки, проверяет, что ребро легальное или нет.
Короче, много случаев, аккуратно нужно понять, почему это все верно, но код сравнительно простой,
то есть даже не нужно переходить к бессмертичным большим координатам, нужно просто вот эти
проверки написать, что если это ребро исходного большого треугольника, то ребро по умышлению
легально, если это все нормальные вершины без бесконечно больших координатов, то мы делаем
обычную проверку, иначе мы просто смотрим на номера, и вот такая проверка оказывается,
равносильная легальность, то есть в случае, когда у нас есть какие-то плохие вершины,
минус 1 или минус 2, нам на самом деле не нужно там явно строить сети окружности,
считать определительные, достаточно будет просто посмотреть вот на это неравенство и его выполнение
равносильной, потому что ребро легает. Вот все, тогда на этом мы заканчиваем, треугольницу мы
построили, соответственно это логично, треугольницу делаем. Все, всем спасибо и до встречи на экзамене.
Спасибо, до свидания. До свидания.
