Сегодня последняя короткая лекция. Большого счета аппендикса предыдущей. Мы на предыдущей
лекции с вами обсудили тему NoSQL в общих чертах. Тема, в принципе, большая. Там много всяких
нюансов, связанных с конкретными видами нерелиционных баз данных. Мы прошлись по самым верхам.
Посмотрели на самый-самый верхний срез того, что есть. Какие есть решения, в связи с чем они
сформировались. Обсудили коротко теорему PEP и base подход. Теорему PEP, теорему Brewer и подход
base к проектированию систем управления даже базами данных, нежели самих баз данных. Сейчас с вами
посмотрим еще на три популярных решения для работы в формате NoSQL, которые массово используются
на настоящий момент. Как вы помните, Redis и MongoDB это лидеры в своих категориях. Категория
хранилищ ключи значения и документов баз данных. ClickHouse это решение Яндекса для колончатых,
ну или как они себя называют столкцовых баз данных. Немножко пару слов о Neo4j. В прошлый раз у нас
возник вопрос по поводу того, как отличать узлы одни от других. По большому счету никак.
Здесь, как я говорил на прошлой лекции, вы можете сделать просто листинг всех узлов,
посмотреть какие есть в вашем графе, ну или в графе, с которым вы работаете, и добавлять
данные туда. Но на самом деле надо оговориться вот о чем, о том, что у нас, если мы пытаемся
перевести данные из релиционной базы в графовую базу вида Neo4j, то рациональным
использованием структуры графовой будет добавление каждой новой записи в виде таблицы,
в виде отдельного узла. Отдельный узел при этом будет содержать в себе имя таблицы,
имя отношения, а запретов на дублирование такого рода узлов у нас, по большому счету, нет.
Поэтому вопрос о том, если мы хотим добавить данные в один и тот же свойство, в один и тот же узел,
как нам его найти? Ну, в принципе, с точки зрения парадигма графа, графовая база данных,
подходы Neo4j по большому счету никак. Можно просто создать новый узел, но здесь главное,
чтобы у нас теги, лейблы, заголовки узла совпадали, чтобы мы по поиску заголовка одноименного искали
именно подходящие отношения, ну или в данном случае, наверное, удобнее говорить класс, сущность,
искали подходящую сущность, чтобы у нас был лейбл, был заголовок Person, но не было заголовка Human,
например, чтобы мы не попадали в проблемы, связанные с таким вот семантической двуйственностью
названия узловерния. Подробнее можно посмотреть, ссылка приведена на документацию Neo4j и пример
на слайде показан, где, как вы видите, у нас в принципе нет, опять же, пример из документации,
здесь нет какого-то принципиального запрета на то, чтобы у нас Person был только одним узлом,
и вот у нас здесь есть узлы Person, которые обозначают тех или иных актеров, и они соответственно
для каждого актера представлены своим узлом, и более того, для каждого фильма еще у нас есть
отдельные узлы и также там для режиссера. Хорошо, давайте поговорим еще вот о чем,
немаловажный, наверное, составляющий при работе с нерелационными базами данных, а не поскольку у
нас, как опять же вы, наверное, помните из нашей глобальной таблицы, стоит DB Engines все-таки не такие
распространенные, как SQL решения, то есть SQL просто по умолчанию больше и выбора больше и
популярного выбора, причем из Open Source сегмента тоже больше, чем вариантов NoSQL решений,
и поэтому у нас в NoSQL встает вопрос лицензирования, особенно на настоящий момент. К сожалению,
не все у нас доступно, а то, что доступно, не все доступно для коммерческого использования,
поэтому нужно смотреть, если вы что-то собираетесь самостоятельно разрабатывать и принимать
самостоятельные решения о том, продукции какого вендера пользоваться, обязательно посмотрите
на раздел License, на GitHub, если это Open Source проект, либо на сайте поищите. Самый простой
способ это просто открыть англоязычную статью википедии по тому или иному продукту, посмотреть,
там всегда пишется лицензия, по некоторым продуктам лицензии, они как бы необычные,
Open Source лицензии и не просто праприетарные, а как бы такие, вроде бы Open Source,
но со своими особенностями, скажем так, и здесь, конечно, нужно читать, но по умолчанию,
для проектов, для чего-то некоммерческого вполне себе большую часть решений можно использовать,
скажем так, ну или также нужно смотреть на среду, в которой планируется развертывание сервисов,
вот для Яндекса у нас, например, есть поддержка, вернее, от Яндекса, от Яндекса облака есть
поддержка кластеров MongoDB, но, правда, несколько более старых версий, пятый и шестой, сейчас
версия седьмая, выпущена пятая и шестая, шестая, по-моему, если я не ошибаюсь,
21-го года выпуска, версия шесть, и то есть, в принципе, пользоваться можно и, да,
MongoDB предоставляет свои облачные решения, и это входит как раз в один из платных планов,
там есть Mongo Atlas, облако, где развертываются сервера Mongo с MongoDB, соответственно,
Яндекс предоставляет сейчас такую замену такого рода сервису, но, опять же, да, вот с уговоркой,
что чуть более ранние версии Mongo используются, но по большому счету, да, для каких-то,
с глобальной точки зрения и так тоже неплохо, это не версия десятилетней давности, в принципе,
довольно актуальные версии, вполне используемые в широком продакшене, скажем так, так что обращайте
на это внимание. Ну а пэд-проекты, да, или что-то некоммерческое на одного человека, или, может быть,
на какую-то небольшую команду некоммерческую можно устанавливать практически вполне без боязни.
Так, хорошо, давайте пройдемся буквально кратенько в двух словах, чтобы уже, да, не перегружать,
сразу оговорюсь у нас тоже, да, оговорюсь, что у нас по этой лекции не будет никаких неформ отчетности,
ничего, просто введем вас в курс дела того, что происходит с теми или иными решениями.
А Redis, вот первый будет на слайде, соответственно, то, откуда взялась, по сути дела, аббревиатура,
то есть название аббревиатура от словосочетания remote dictionary server и хранилище ключезначения,
которое в оперативной памяти функционирует, можно его сохранять на диск, возможна репликация
по схеме master-slave, поддерживается также событийный механизм по схеме подписки,
работает на UNIX, в Windows, если захотите установить, то нужно WSL, то есть Windows Subsystem for Linux
и открытый исходный код есть на GitHub, они, кстати, вот Redis буквально 20 марта перешли на более
жесткую свою новую лицензию, она все равно как бы считается еще такой, не совсем, не до конца
праприетарной, но уже стала более закрытой, там более агрессивной с точки зрения того,
если вы хотите использовать Redis, то там нужно делать в плане того, что открытый исходный код вашего
приложения, но подробнее, если вам будет интересно в таких аспектах разобраться,
отсылаю вас к GitHub'у Redis к пайлу лицензирования, но для каких-то ПЭД-проектов вполне
Redis можно использовать пока что безбоясно, что называется, не считаясь наружителем авторских
прав. Архитектурный Redis представляет два процесса собой, серверный процесс, который,
собственно говоря, слушает порты, отвечает за хранение и обработку данных, и Redis клеит,
если хотите работать с командной строкой с терминалом, либо есть, конечно же, куча
всевозможных пакетов для различных языков программирования, наиболее распространенных,
можно работать из-под рентайма вашего языка, назовем это так. Некоторые команды основные,
это подключение к базе данных из командной строки, добавление приведено максимально,
здесь просто, set, get, добавление и чтение данных. bike 2.1 это ключ, несмотря на наличие 2.1. После
пробелы идет значение. Команда hset позволяет нам добавлять словарь, здесь у нас первое значение
идет, первая запись идет после hget, идет ключ такой головной, назовем это так, ключ записи,
а дальше внутри записи есть поля, по которым мы можем получить доступ к информации по тому
или иному полю. Это такие прям верхнеуровневые команды, что называются самые простые,
можно сканить записи, есть вариант сканирования даже не записи, а ключей, можно делать индексы,
сознательно здесь не привожу всю полноту, уже не имеет большого смысла сейчас в это погружаться,
потому что это с одной стороны тема на отдельную лекцию, с другой стороны повторюсь, у нас
такой момент, но как вы видите здесь принципиально то, что у нас с точки зрения структуры данных,
которые хранятся, это либо запись, либо словарь, вот собственно и все, и то и другое доступно по ключу,
что мы можем делать с записями, есть некоторое количество операций, можно, повторюсь,
завод сканирования, можно ключ, если это числовое значение, инкрементировать,
декрементировать можно, ну понятно, удаление записи тоже там возможно по ключу, отдельно
записи или записи с ключом и так далее и тому подобное, все, что вы делаете, ну условно говоря,
там со словариком на питоне доступно, грубо говоря, тоже в Redis, и зачем это все нам в принципе нужно,
Redis удобен для каширования и для каширования данных для нескольких процессов тех или иных
приложений, соответственно, вы можете подключить несколько своих приложений к общему кэшу или
несколько процессов одного приложения к общему кэшу и удобно таким образом пользоваться вот этой
общей памятью, за что будет отвечать у вас Redis, возможно также масштабировать систему тоже за
счет в принципе этого свойства, вступление Redis в качестве кэша, в общем-то, наверное,
все должно быть понятно, словарик, хранящийся в оперативной памяти, и который также как словарь
можно использовать, что нам удобствует в первую очередь в том, что мы не работаем, условно говоря,
с прямой адресацией памяти или с адресацией памяти из приложения, не пытаемся, не знаю,
на C или C++ делать аллокацию памяти, запускать в каком-то общем процессе делать какие-то,
как-то его сложно использовать, у нас есть интерфейс, мы с ним работаем, все довольно очевидно,
скажем так, ну понятно, да, есть дополнительное осветление по репликации, по шардированию того,
как это делается в Redis, своя специфика, но мы подробно об этом с вами в принципе не говорили,
поэтому тоже не будем сейчас с вами на этом останавливаться, просто есть тоже свои определенные
особенности, за ними целая у вас, они технического плана, они такие неконцептуальные, целая у вас
документация, ребята. ClickHouse, Vendor Yandex, наш такой вот отечественный, что называется,
решение столбцовое, как я и говорил, система управления базами данных для OLAP-запросов,
как сами разработчики пишут, это по-настоящему столбцовый СУБД, то есть у нас действительно
все, они этим прямо заморочились максимально в том плане, что у нас файлы физические,
на диске хранятся именно в виде, ну не в виде, конечно, а в файлах хранятся записи именно о
столбцах без какой-то эмуляции каких-то сложных структур, последовательное хранение записи в
рамках колонки, ну оптимальное сжатие данных, хранение на диске, параллельная обработка
запросов на многих процессорных ядрах, то есть в принципе на это ClickHouse затачивался, поддержка,
и вот о чем мы тоже с вами оговаривались, поддержка SQL, то есть мы можем безбоязненно
использовать ClickHouse, зная то, что мы знаем о SQL-синдексе, и таким образом здесь
порог входа после релиционных баз данных минимален, ну и в принципе ClickHouse, как мы с вами и говорили,
да, у нас колончатый и уайт колонн базы данных, они в отличие от остальных решений наиболее близки
вот такой релиционной что ли парадигме, потому что у нас здесь принципиально только момент
с физическим хранением данных, нежели с тем, как эти данные переносятся в схему данных, как из данных
формируется схема, какие там ограничения, какие условия на типы данных и так далее, это все берем
из курса про релиционный, да, из теории релиционных баз данных, просто особенности физического хранения
позволяют удобнее работать с аналитическим запросами, то есть запросами на массовое чтение данных
в больших столбцах, в длинных таких столбцах, а какие потенциальные недостатки, на это, собственно,
опять же сами разработчики явно указывают при описании своего продукта, то есть здесь нет
полноценных транзакций, да, то есть вот эти вот наши ACID-принципы не гарантируются в данном случае,
но это обусловлено, опять же, тем, что мы здесь click-aus не работаем с данными в режиме OLTP,
то есть он онлайн транзакцион процессы, нам не важно в данном случае записать данные и
обеспечить конкурентный доступ к данным во время записи и вместе с тем там сохранить данные
непротиворечивыми и так далее, и так далее, у нас выгрузка в click-aus происходит реже,
но более массово, скажем так, да, и наоборот, у нас операция чтения, как я уже сказал,
происходит чаще, чем операция записи, значительно чаще, и поэтому нам в первую очередь важно
обеспечить оптимальное чтение больших массивов данных, которые мы пытаемся анализировать. Есть
особенности по изменению удалению ранее записанных данных сниз, ранее записанных данных,
то есть здесь не гарантируется быстрота таких операций и массовое удаление изменения данных
привычными средствами SQL здесь не поддерживается в прямом виде, есть специфические средства массового
удаления, просто по операции delete заблюрить, так сказать, строки, убрать их из явной выдачи,
а потом сделать вакуум или анализ и подтянуть статистику, удалив все помеченные в рамках
операции delete данные, здесь такого нет, все это работает несколько иначе и не так эффективно,
как в нашем позгрессе, который мы с вами изучали, есть также разряженный индекс,
и здесь не очень удобно за счет него читать одиночные строки по ключам, ну и в принципе,
опять же, мы с вами тоже оговаривали, что в колончатых и вайт-колонн базах данных чтение строк
это не оптимальная операция именно в связи с особенностями физического хранения, именно в связи
с тем, что мы нацелены на аналитику, то есть аналитика подразумевает агрегацию, абстрагирование
от конкретного значения и формулирование выводов на основании каких-то таких собирательных,
с какой-то собирательной информации о предметной области. Некоторые команды здесь,
кроме вот подключения и каких-то специфических команд tutelite для терминала, о которых мы не
будем отдельно гонхлеть, опять же, по большому счету их и нет, вот создание и наполнение таблицы,
приведенные в примере. Как вы видите, здесь минимальное различие здесь появляется спецификом
в виде engine, вот в конце команды create, merge tree, order by, id, специфика создания таблицы,
как это все будет храниться на диске и учитываться при операциях order by, но по большому счету,
не вникая в подробности, такого рода, если уж не создание, то наполнение точно ничем не
отличается принципиально от команды наполнения, команды insert, inter в нашем посгрысе,
в обычном SQL характерном для посгрыса. Как уже говорилось, здание не поддерживает традиционное
удаление строк с помощью delete click house, но вместо этого можно делать всяческие лайфхаки,
не очень сложные, но опять же, это будет просто неэффективно. Сразу можно оговориться, опять же,
в силу, повторюсь, особенностей, в силу специфики хранения данных и alter table мы можем изменить
с помощью этой команды какую-то таблицу, сделав удавление по условию, но так, пожалуй, делать без
крайней необходимости не надо, операция, повторюсь, не оптимальная. MongoDB, последний наш кандидат на такой
краткий сравнительный обзор. Да, вот с Redis-ом говорили, что они 20 марта буквально изменили
лицензию, ужесточили ее. MongoDB у нас, в принципе, отключили поддержку своего облачного сервиса еще два
года назад, но и Redis и MongoDB их доступны на GitHub, то есть, по большому счету, если сильно захотеть,
можно сделать форк при необходимой правовой экспертизе добиться изменения, достаточного
изменения исходного кода, чтобы считать это новым продуктом. Это такой фантазийный немножко
сценарий, но, тем не менее, изменив минимальным необходимым образом исходный код Mongo,
можно какую-то свою документную базу данных сформировать, но, ладно, хватит фантазии,
что называется, давайте к сухим фактам. Mongo, повторюсь, поддерживается у нас в частности в облаке
Яндекса, так что тоже вполне себе рабочий вариант для предприятий, для издания community, в принципе,
можно все это установить на свой сервер, на свою машину и пользоваться. Так, вопрос.
Лицензия там SSPL, и это лицензия, которая ограничена, такой, как бы, промежуточный вариант,
промежуточный вариант между open-source лицензиями и между proprietary, скажем так. Там, если кратко,
то ситуация, похожая с Redis, нужно открывать весь исходный код, если вы работаете с базовой
версией MongoDB, и, наверное, такое первое и принципиальное ограничение нельзя, если я не ошибаюсь,
менять не как Mongo, исходный код Mongo, и за остальным, да, я вас все-таки отошлю к документации Гитхаба,
потому что есть. Давайте так, да, вот сейчас на практике некоторое количество времени используется
решение иностранных вендоров или поддерживаемые иностранными вендорами, скажем так, с некоторыми
оговорками с точки зрения правового режима. Поэтому, если вы хотите разворачивать какой-то
коммерческий проект и для этого ищете подходящее решение, то лучше всего возможно обратиться на
прямую к юристам и потратить на это какое-то количество денег, либо потратить какое-то количество
своего времени, чтобы вчитаться в лицензионное соглашение, которое висит в Гитхабе, и четко понять,
вообще, какие права и обязанности у вас могут возникнуть при использовании. Если же вы делаете
просто какой-то крайне коммерческий проект, все это у вас лежит на Гитхабе и Гитлабе в открытом
доступе, все рассмотренное сейчас и рассмотренное в прошлом, до прошлой лекции, они пригодны для
такого использования. То есть, не знаю, делайте какой-нибудь сервис, собирайте какую-то статистику,
ну что там сейчас актуально, какой-нибудь криптовалюта, DeFi-приложение, делайте форк сайта
DeFiLab, не знаю вообще, он в открытом доступе или нет, ну вот так, да, пофантазируем, что это такое,
можете посмотреть в интернете, это вообще отдельно, это совсем другая тема, не будем углубляться,
и делайте форк какого-нибудь сайта, начинаете агрегировать данные, используете один из
вариантов того, что мы с вами оговорили, и если вы не получаете доходы от рекламы, если у вас
открытый исходный под и вы явно говорите, что вы используете, у вас никаких проблем не будет,
если вы собираетесь работать в коммерции у крупных коммерческих фирм, есть свои политики
современные по использованию такого рода приложений, вам просто не нужно будет по этому
поводу париться, если вы именно собираетесь делать какой-то свой маленький подряд, уходить
в какой-то свой маленький консалтинг, тогда проанализируйте, здесь я не специалист в
лицензировании ПО, поэтому это не моя епархия, я просто опозначаю вам риски, говорю о полюсах,
то есть один полюс это, да, о краях спектра, один полюс это полностью некоммерческое,
полностью открытое использование, у вас полностью открытый проект, здесь все нормально,
никаких проблем не будет, или вы сотрудник в какой-то крупной компании, где свои политики,
где там свои департаменты занимаются тем, чтобы исключить всевозможные риски и так далее,
здесь проблема, наверное, где-то посередине между этими диапазонами, ну посередине, повторюсь,
либо читать самостоятельно и тратить время, либо попытаться обратиться за квалифицированной
помощью, в принципе, я думаю, такую можно найти, это, кажется, насущный вопрос в современных
условиях, ну понятно, стоимость проекта, может быть, это удорожит на каком-то этапе, вот так
угодно, правовая экспертиза, но тем не менее, лучше за ней обратиться, так что вот так,
резюмируя ответ на ваш вопрос, лицензия у MongoDB пограничная, но для pet проекта подойдет.
Так, хорошо, вернемся к MongoDB, данные хранятся в формате, похожем на JSON, по сути дела, у нас и
доступ идет к данным, вот такого рода нотация, которая к нам из C пришла через точку, когда мы
к полям структуры обращались через точку, по-моему, C едва ли не первый был язык,
предложившись такой синтаксизм, но во всяком случае, Керниган и Ричи, кажется, говорили об этом как,
не то, что новации, но если я не ошибаюсь, попрошу заранее меня извинить, но, кажется,
они говорили об этом как такой синтаксический, что ли, фичи языка C на тот момент. Хорошо,
про то, что сейчас покажу несколько команд, оптимальная поддержка горизонтального
масштабирования, и sharding в частности поддерживается, когда у нас данные разнесены по нескольким
серверам, не просто реплицированы, когда у нас полная копия на двух-трех серверах стоит,
спереди идет балансировка через какой-нибудь nginx, и все это раскидывается по загруженности серверов,
одни запросы, которые потенциально могут к одним и тем же данным обращаться, раскидываются на
разные сервера, нет, у нас, именно, возможно, оптимальное распределение данных по различным
узлам нашей какой-то внутренней сети, все это потому, что у нас Монга яркий представитель,
как раз, нашей base парадигмы, о которой мы говорили, то есть базовая доступность и
согласованность в конечном итоге. В конечном итоге согласованность будет, но здесь, возможно,
возможно проблемы с тем, как пропагация, как распространение по узлам информации будет
происходить. Ну или статистическая, по крайней мере, информация, раз уж мы говорим, что
шардирование это разнесение порции данных, то нам нужна, по крайней мере, какая-то статистика,
где у нас какие данные хранятся. Понятно, что мы не будем записывать все данные, переписывать
с одного узла на другой в случае с шардированием. Так, доступна поддержка транзакции, начиная с
версии, да, Монга также, в принципе, мы можем ужесточить внутренние политики, так сказать,
назовем это так, Монга, и заставить его исполнять ACID-транзакции, если мы захотим, но это уже такие,
да, навороты в сторону реверанса, в сторону ACID, в сторону какой-то не то чтобы релиционности,
но вот жесткости и возможности поддержания непротиворечивости, характерной для релиционных
СОБД. Примеры команд, ну, здесь, да, опять же, вот просто, то ли немножко так посмотреть,
как это выглядит, потому что, безусловно, палитра команд, их сильно больше, возможностей у Монга
довольно много, штука удобная, если вы, конечно, да, не, если вы понимаете, зачем вы это используете,
и понимаете, что на каком-то этапе развития вашего сервиса вы перейдете на релиционную модель,
потому что сделать просто вот какое-то невразумительное хранилище вообще никак не
соответствующими друг другу документами, из Монга можно довольно просто привести это потом в вид,
который будет удобно поддерживать, то есть, что-то похожее на релиционную модель, довольно
проблематично с точки зрения ресурсов, по крайней мере, точно, то есть, затрата будут довольно
большими, а поэтому лучше, ну, это такая заметка на полях, это не то что прям жесткая установка,
но рекомендация такая, что Монг, конечно, лучше использовать все-таки, наверное, на проектах
небольшого или среднего объема, потому что он удобен для быстроты разработки, но для того,
чтобы обеспечивать непротиворечимость данных, их неизбыточность, чтобы мы были уверены,
что мы добавляем новую записи, она у нас правильно распределится в нашей базе данных, аккуратно
все ляжет, не создаст никаких коллизий, не будет никаких проблем с точки зрения там чтения записи,
что у нас не будет противоречивых данных внутри самой базы, вот с этим Монг ГДБ справляется не
очень хорошо, ну, не то что не очень хорошо, он не заточен изначально на то, чтобы с этим
расправляться, поэтому мы теоретически из Монга ДБ можем сделать просто месиво из данных,
что, конечно, очень неудобно при росте их объема. Ладно, long story short, собственно,
подключению к процессу просто команды Монга из терминала, дальше переключаем контекст на базу
данных конкретную, и вот подразумевая, что DB это имя нашей базы, мы соответственно дальше,
в коллекцию users мы можем добавлять поля, можем удалять поля, можем искать все документы или
один документ со соответствующими полями, можем создавать индекс по полям, ну, по полю,
да, можем делать запросы на агрегацию данных, как показано в последнем буллите, то есть,
в принципе, то, что мы базово делали в реалиционной СОБД-Позгресс, мы теоретически можем делать в
Монга DB, но никаких ограничений на то, чтобы мы создали два абсолютно одинаковых, скажем так,
как бы это лучше сформулировать, даже не то чтобы одинаковых, да, никаких ограничений на то,
чтобы мы создали две противоречивые записи, например, о человеке по имени Джон в возрасте
30 лет и с имейлом john-example.com у нас нет, мы можем создавать такие записи, ну, здесь,
понятно, скорее всего будет по имейлу, что называется, идентификация, вот если имейл будет одинаков,
а разные будут набирать телефонов, вон, где тебе будут проблемы, в принципе, и в Позгрессе можем
такое месиво создавать, да, благо у нас есть возможность создания сорокатных ключей и,
пожалуйста, инкриментируем на единичку и с каждой новой записью у нас об одном и том же дне идет
новая информация, но разные телефоны, но все-таки все-таки базовая реализационная модель больше
подходит для хранения однотипных данных, там больше возможностей из коробки, что называется,
ну, и с точки зрения теории для того, чтобы избежать дублирования. Так, хорошо, это получается
последний слайд, на этом мы с вами, в принципе, базово, ну, вот так, по верхам, да, повторюсь,
такой аппендикс небольшой к нашей предыдущей лекции про NoSQL, базово по верхам мы посмотрели,
а наиболее, наверное, интересное, ну, с моей точки зрения, я бы сказал, все-таки Neo4j,
я никого не призываю, да, безусловно, здесь вопрос в том, что вы хотите сделать,
MongoDB очень хорош на начальных этапах, например, какой-то вашего стартапа, поэтому Neo4j,
наверное, использовать не стоит, лучше сделать MongoDB и туда вот скидывать какие-то данные в
надежде, что потом, там, когда вы MVP сделаете, покажете, потом будет время и инвестиции,
чтобы сделать какую-то, какую-то революционную базу данных или, да, не знаю, более что-то
сделать, основанное на какой-то более жесткой схеме, там, те же графовые базы данных,
а для начала MongoDB вполне себе хорошо, а Redis это каширование, каширование каких-нибудь чатов,
сообщений, в этом смысле хорошая штука, в принципе, по большому счету, когда-то это
использовалось и для формирования очередей задач, но это уже такая, ну, не то что использовалось,
да, были варианты такого использования, но это уже, конечно, совсем другая история, сейчас есть
профильные решения, и Redis так, конечно, лучше не использовать. Так, ну, ClickHouse, это скорее решение
для DWH структур, для хранилищ данных, причем, опять же, да, вспоминая вот наш слайд со схемой того,
что такое DWH, как вот слева на слайде, помните, у нас там были операционные приложения, потом через
ETL-процесс данные загружались на DWH-сервер, и из DWH у нас в OLAP-приложение в какие-то
аналитические отчеты данные поступали, вот ClickHouse, это что-то вроде, либо как довесок к DWH
на сервере, там условно говоря, да, или в структуре серверов хранилища данных, он будет стоять либо
у вас где-то уже ближе к виталином данных, то есть это решение, пожалуй, не для работы, может быть,
с чем-то, в рамках каких-то небольших проектов, а решение скорее для, ну, такого, да,
Enterprise уровня предприятия, но, в принципе, популярное решение, решающая возложные на него задачи.
Наверное, на этом мы, пожалуй, закончим, курс наш подошел к концу, мы основные вещи с
вами затруднули, посмотрели, надеюсь, было в каких-то вещах все-таки интересно, ну, понятно,
что какие-то вещи, они такие тривиальные, повторяли либо семинарские занятия, либо,
наоборот, семинарские занятия дублировали то, что мы здесь с вами рассказывали, либо, в принципе,
синдексис, например, SQL, вещь, не имеющая какой-то теоретической подоплеки, по сути, делает просто
список команд и правила их использования. Ну, вещь такая, да, не очень, наверное, интересная,
но с которой нужно все равно было познакомиться, сделать какой-то минимальный обзор,
и которую, ну, да, после этого можно уже осваивать путем практического применения.
