0-knowledge proofs
так ну а что вам рассказали может делать выжимку что может рассказать что и что вы из этого
поняли значит сейчас историю про бабу вам рассказывали с пещерой да хорошо а про графы
из морфизма так да это мне виталий писал что он там запутался и вы как-то не возвращались потом
вам рассказывали так ну ладно что она наверное начнем значит на самом деле это вот это нулевое
разглашение такой зонтичный термин да то есть есть несколько разных моделей которые называются
как раз доказательства с нулевым разглашением и возможно загвоздка стояла в том что из морфизм
графов и судовку относятся к разным понятиям и возможно была проблема в том что одно понятие
пытались применить в другой ситуации да и она там не работала вот значит соответственно есть значит
минимум три значит три варианта значит одно называется совершенно нулевое разглашение
perfect 0-knowledge совершенно нулевое разглашение perfect 0-knowledge значит второй вариант называется
статистически нулевое разглашение соответственно statistical 0-knowledge
сзк и третий вариант это вычислитель нулевое разглашение
это сзк значит computational 0-knowledge вот ну и мог быть еще всякие мелкие вариации но вот это
три основных на самом деле прям основные это верхняя и нижняя вот а статистическая да с ним
есть определение но так как-то про него мало чего известно что нет просто статистикал мало чего
известно c это computational 0-knowledge соответственно из морфизм графов или например квадратичный
вычет лежат верхней части в пзк вот а всякие нп полные задачи лежат в нижней части сзк ну и на
самом деле там даже все и пи лежит вот но это уже не очень простая теорема вот с нп полными попроще
вот хорошо значит чём идея в чём ваше парадигме нулевого разглашения как бы что означает что
как бы собеседник ничего не узнал ну что hassle ничего ещё и узнал нечуновую не узнал а что значит
что ничо нового не узнал чтобы все что узнал он и так знал но все-таки что это точно значат
Да, кажется, что это некоторое противоречие с тем, что все-таки задача решена.
Но он, как минимум, узнал, что мы че-то знаем.
Ну да, значит, конечно, решение задачи он должен узнать.
То есть если он раньше не знал, там, из-за мощного графа или нет, то теперь, соответственно, он это как бы должен узнать.
На самом деле мы вообще вот это вот требование неразглашения будем накладывать только на тот случай, когда прувер честный и утверждение верное.
Ну и при условии, что утверждение верное, информация о том, что оно верное, ничего не дает.
Соответственно, в чем как бы загвоздка?
Что нужно убедиться, что прувер знает доказательства, но при этом как-то не понять ничего про само доказательство.
Да, и вот это вот некоторые противоречивые требования, которые как раз приводят к тому, что эта теория нетривиальная.
При этом это вполне прикладной вопрос применительно к крипто-графическим задачам, например, к задачам аутентификации.
Когда есть логин-пароль, и нужно как бы доказать, что знаешь пароль, но так, чтобы он не утек к кому-то еще.
Ну и вот если система построена на нулевом разглашении, то он как бы не должен утечь математически.
Есть такая фишинговая атака, что жертвы присылают ссылку на мошеннический сайт, который притворяется настоящим.
И, соответственно, жертвы на этом мошенническом сайте вводят свои логин-пароль, и те, кто этот сайт сделал или узнают эти логин-пароль,
потом идут на настоящий сайт, и там крадут деньги или узнают личную переписку.
Если логин устроен на базе нулевого разглашения, то она в принципе невозможна.
То есть жертва может зайти на этот сайт и даже введет там логин-пароль, но при этом хозяева сайта не узнают эти логин-пароль.
То есть хозяева даже смогут проверить, что жертва знает логин-пароль, но сами узнать не смогут.
Ну, конечно, есть какая-то вопроса, почему, собственно, все логины так не делают.
Но там есть некоторые технические проблемы, связанные со скоростью работы и так далее.
То есть теоретически это все хорошо работает за поллиминальное время, но фактически это поллиминальное время,
это какие-нибудь секунды, получается, как минимум. Логин за 10 секунд, это уже не очень хорошо.
Желательно, чтобы было за полсекунды максимум.
Ну и, возможно, опять же какие-то аппаратные требования на клиентской стороне,
потому что тут клиент в роли прувера выступает, поэтому нагруженные вычисления на стороне клиента получаются.
Вот.
Ну да, а как бы вообще, как бы один из, одна из современных пародий, чтобы все нагружные вычисления
нужно, наоборот, на серфи приносить, там будет, ну, какой-нибудь облака, пластырь и так далее.
Клиентский устройство прийти не очень сложно.
Вот.
Поэтому это такое, более-менее нишеное решение получается,
что там, где клиент может быть высоко нагруженным, и там, где не важно задержать 10 секунд,
там можно делать логин или разглашение.
Вот, так.
Хорошо.
Значит, теперь определение.
Ну, давайте, там, рисуем картинку, ну, верификатор.
Значит, вот они как-то так друг с другом общаются.
И в итоге, во-первых, верификатор должен сказать правильно.
Да, на самом деле, я вот говорил, что нагруженные вычисления, на самом деле,
часто все-таки это не очень сложные вычисления, не нужно, там, господи, слово, задачи решать,
а нужно просто дать секрет, и над этим секретом какие-то вычисления очень сложно проживать.
Вот.
Хорошо.
Соответственно, что знает верификатор?
Ну, как бы, как нужно определить, что знает верификатор?
Во-первых, он знает себя исключительно или так?
Вот.
Ну, и во-вторых, он знает все сообщения, которые он прислал целым.
И, значит, соответственно, в данном случае может иметь смысл говорить про веря
Верификатор тоже может использовать случайные биты, и у верификатора вот так вверх тоже случайно.
Совершенно получается, ну, некоторое, такая большая случайная величина,
которая стоит из вот этого вверх и всех, соответственно, вот этих сообщений.
И, получается, верификатор как бы узнала одну реализацию этой случайной величины.
То есть верификатор не прямо какое-то знание получил,
а получил какое-то сообщение, которое является одной реализацией случайной величины, ну, с каким-то распределением.
Что это значит?
Да?
В каком смысле реализация?
Ну, чтобы реализация случайной величины.
Ну, просто какая-то строка, которая случайно с таким распределилась.
Случайная величина – это ее сно.
Нет, случайная величина – это не ее сно.
А это все, что верификатор знал.
То есть его собственное случение.
Биты, которые равномерно распределены.
И плюс еще все сообщения откроют.
Ну, и совпадные иски еще.
Да?
То есть совпадные дамы.
Соответственно, ну, можно сказать, что для разных исков разное случение величины.
Ну, это для разных сообщений тоже.
Еще?
Ну, там же сообщения тоже будут разные при разных.
Ну, в смысле, М1.
Нет, сообщения – это часть уже, часть реализации случайной величины.
А вот X можно считать параметром.
А случайная величина – это сам делу?
Как?
Ну, значит, смотрите.
Еще раз.
У нас есть...
Да.
Данные, пишущие в педали.
Значит, это...
Это понятительный спаст данный.
И пианский флешбеки.
Значит, это ве и пе.
Это, значит, то, что верификатор видит в ходе общения с кодом.
Ну, значит, можно...
А, ну, это все же включено.
Значит, это X входный данный.
То есть как узнает.
Это, например, это его случайные пинты.
Да, значит, которые...
Ну, в принципе, в предписном смысле определены.
Вот.
И это...
Так, дайте я слова ему напишу.
Значит, сообщение кодом.
Сообщение кодом.
Сообщение кодом.
Значит, которые, конечно...
Сообщения кодом определяются,
во-первых, и к сону,
которую кто же получает.
Во-вторых, теми сообщениями,
которые ему верификатор посылает
и который свою очередь заедет в этот цирк
и предыдущих сообщений.
И потенциально еще
случайными пинтами,
которые сам Крувер использует.
Ну, вот как с формальной точки зрения
мы нормально задаем, ну, протокол
общениями?
Не, ну, протокол как раньше,
да, что...
Ну, если он не сказал, что
от Крувер первым посылает,
то у Крувера есть какое-то сообщение
от X и его, ну, может быть, его секрет
и его случайные пинты.
Нет, ну, в смысле, это функция от протокола.
Ну, от вью
ВП. Как бы, а протокол
это что-то, что тоже зависит.
Так, значит, смотрите.
Когда у нас был просто ай-пинит,
то протокол определялся самим
верификатором. То есть можно было
сказать, что протокол — это функция,
которая переводит предыдущий диалог
в сообщение
в новом сообщении верификатора.
Вот. Здесь уже
важно
здесь уже важны обе стороны.
То есть, тут есть
предписанное поведение Крувера
предписанное поведение верификатора.
То есть, здесь мы протокол
будем называть ПАМ
из алгоритма
для Крувера и алгоритма
для верификатора. То есть, мы подозреваем,
что у нас есть, грубо говоря, набор функций для каждой
итерации, в смысле, для каждого.
Ну, конечно, да. Можешь сказать, что это одна функция
и получает весь предыдущий диалог и возвращает
новое сообщение. И еще иметь доступ
в случайный вид. Ну, по сути, две функции
ВП и В.
Что? Верификатор и
Крувера. Ну, типа того, да.
Весь протокол это
ПАМ
грубо говоря, верификатор.
То есть, еще раз, верификатор получает весь предыдущий
диалог. Вход
X и свои случайные биты.
А просьба получает весь предыдущий
диалог. Вход X, секрет
свой.
Возможно.
И еще свои случайные биты.
А секрет это что?
Ну, секрет это, может быть,
что, например,
X это
какое-нибудь уравнение, а секрет это его решение.
Не там X это хэрс значение,
а секрет это
прообраз этого хэрс значения.
И там X это пары графов,
а секрет это измахлость
назначение.
И как формально сфонолировать
то, что у нас не произошло разложение?
Что не произошло?
А, нет, это сейчас.
Окей, да.
Вот как раз к этому подход.
Wait.
Так, давайте вот
что. Тут еще, как
аргумент, я напишу X.
Да, мы постараемся, но ничего страшного.
Вот. Значит, продигма
такая, что
которая для всех трех вариантов
годится,
что верификатор
может
сгенерировать
случайную величину, которая
похожа на...
А, сейчас, давайте
вспомните, еще
одна важная вариация, это
как бы с честным верификатором
или с нечестным верификатором.
Ну, не может быть отношения для честных
верификаторов.
Не может быть отношения
для
верификаторов.
А если верификатор несчастный, он сам ничего не знает,
как он может с каторой пройтись?
Не, не, сейчас. Смотрите.
Я сглашу, и должен пройтись.
Разглашает он не сглашает
пройтись. Что такое нечестный верификатор?
Ну, сейчас это скажу.
Это
то, что вы отмечаете.
Значит, смотрите.
Идея с этим сайтом,
с фальшивым сайтом,
который для фельдшнеговой атаки сделана.
Этот фальшивый логин может быть
сделан как обычный логин,
с тем самым алгоритмом.
Но, в принципе, он может
что-то другое делать.
То есть, вот этот логин может быть
ко мне
каким-то взаимодействием
последователенным.
Что какие-то там челленджи
задают клиенту, он их как-то
отличает, но так.
Значит, он честный верификатор.
Это что сайт нечестный, но
ведет себя
так же, как настоящий сайт.
Тот же самый алгоритм выполняет.
А мошеннический сайт,
он еще алгоритм может уменять.
Ну, что?
Понятно, да?
То есть, прувер должен понять,
что из него все-таки пытаются что-то
выключить? Ну, должен, не должен,
это так непонятно. Ну, какие-то сообщения
приходят, могли бы и настоящий сайт тоже
прийти.
В том, как
эти сообщения
получаются.
Значит, нуль может быть честно,
верификатор.
И это вот что,
ну,
существует
алгоритм
вероятно
вероятно
с предназначением
м
значит, так,
что м от х
похоже
на
соответственно,
вот. И вот эти три
три пыта
различаются тем, что означает
вот это похоже.
Вот это похоже, можно разные способы
определять, вот три пыта.
Я не очень понимаю, так обобщить,
ну, в смысле, как
сформулировать понятие честности адекватно.
Вот, что здесь ве.
То, что здесь ве,
это означает честно, что
сообщение верификатора
вычисляется ровно по тем алгоритмам,
как ее предписывают.
А прувер знает функцию
верификатора?
Ну, протокол знает, конечно.
То есть, короче, прувер знает,
по какому алгоритму действует верификатор.
Да, по какому алгоритму должен действовать верификатор.
Если верификатор нарушает свой алгоритм,
то как бы он не честен становится.
Но прувер это может не понять,
но он как бы...
Да, но он не честен.
То есть, типа, не зная секрет,
можно проимулировать тот же самый диалог.
Вот в этом смысле.
Ну, ну, тип того, да.
В смысле?
Это является семинаром,
который я тоже не понял.
Ну, сейчас разберемся.
Сейчас разберемся.
Есть еще, значит, воля сильная
для производа верификатора.
Для производа машины...
Для производа верификатора.
То есть, это означает, что
в любом воздушном
существует время созрения
верификатора.
Значит, такое, что я взял здесь 5х,
похоже
на А, вот, С, на В.
Здесь тоже самое П, а здесь и на С.
То есть, что не только диалог честных верификаторов
можно смоделировать,
симулировать,
но и вообще и много.
Конечно, здесь он не совсем любой,
да, любые, там, премиады, вероятности,
да, ну, и я в задержке что-то нанесу.
Сейчас, честность это свойство верификатора?
В данном случае, да.
Ага, это то, что он не отклоняется
от какого-то фиксированного заранее протокола,
как в там, какая-то функция, которая там в какой-то язык задает?
Ну, да.
Сейчас, а возведочка здесь честная,
или вот, ну, по-принему?
Ну, честная-то вот.
А высотодочка любой поединяет.
Ну, то есть, у нас, по сути, просто два типа
нулевых разношений.
Ну, да. Вот, для честных вообще универсальный.
Да, то есть, какой-то, значит,
какой-то протокол может соответствовать
верхнему требованию, но не соответствовать нижнему.
Ясно, что наоборот очевиден.
Верно даже есть, что
для любого высотодочка в том числе
высотодочка равномерная.
Так, хорошо.
Ну, вот, давайте разбираться,
что, значит, похоже.
Сейчас, а M, это вот
в аналоге с этим, это что?
Что еще раз? M, ну,
вероятно, если M, это
ну, MXX, да.
Просто, просто какой-то алгоритм.
Ну, что
все, что
увидел верификатор в ходе
общения, он мог
возгенерировать сам, запустив
вот этот симулятор.
В смысле, имея секрет
или не имея? У него есть
вот эта функция
прувера, у верификатора
в свою очередь есть функция прувера.
И он может как бы использовать
эту функцию. Нет, конечно,
такое может как по программу здесь
использоваться, но это не секрет.
Да, то есть он как
и он может сгенерировать с помощью этой функции,
точнее, он может сгенерировать такое
взаимодействие, что там выполняется,
что корректно действует и функция
верификатора и функция прувера каждый раз,
как бы, да?
Ну, грубо говоря, да.
Функция прувера зависит от секрета.
Ну, вот он как бы может
сгенерировать, видимо, такой диалог,
где функция прувера
будет давать...
Конечно, если он генерировал все
сообщения прувера, то свои он тоже может
генерировать, потому что
автоматически определяется
случайный вид и не сообщение прувера.
Сейчас, M это просто протокол
в нашем факте.
M это алгоритм даже.
Ну, алгоритм, который эмулирует протоколом,
типа для payback.
Ну, можно так сказать, да.
Но только при данном секрете.
Да, F знает секрет, а M не знает секрет.
Ну, ему он передается как параметр, разве нет?
Нет, только X передается.
А X это...
Ну, грубо говоря, он знает, конечно, значение,
но не знает, от какой строки
это, конечно, значение, а кувер знает.
А что в нашем случае
в нашем случае X это просто
что-то, что надо...
Сейчас, давайте теперь на графов.
X это параграфов, а секрет прувера
это изомофизм между ними.
И тогда, в случае, что он
не знает изомофизма, можно
сгенерировать диалог,
который будет похож на настоящий, который
ввелся с прувером, который знает
изомофизм.
Ну, просто не до конца понятно,
что мы подразумеваем
под секретом. Ну, как бы...
Не очень понятно, что мы подразумеваем под секретом
и что мы здесь, как бы, скрываем, и в какой функции
это лежит условно.
Сейчас, давайте, смотрите. На самом деле, вот это
определение, оно вообще
не зависит от того, что мы называем секретом.
Да, как бы, в чем бы не замечался
секрет,
если
как бы все, что узнали,
общаясь,
у которого есть секрет,
можно, не зная секретов,
не разглашать.
Если можно сгенерировать...
Что значит сгенерировать?
Ну, вот это, видимо, и значит m от x.
Вот x и x
это общий вход.
У прувера может какой-то свой вход, который я
называю секретом.
Ну, в смысле, не очень понятно, в чем разница
между функцией, которые знаете,
между той, которой...
Мы хотим убедиться, что прувер умеет вычислять некоторую функцию,
какую-то неизвестную.
Верификатору, наверное, известную,
но...
Нет, сейчас. Какую функцию?
Которую его сообщение вычисляет?
Которая уточняет,
принадлежит там что-то в языку или не принадлежит.
Ну, в смысле.
Пароль верный, либо...
Сейчас.
Не очень понятно, что такое m,
вообще, глобально, по идее.
Это алгоритм, который создан для того, чтобы
уметь вычислять правду,
что то, что нам вернул p, это верное значение.
Ну, смотрите, пусть это
один пароль,
x это х-начение от пароля,
а b и свой пароль.
Вот, значит,
смотрите, если...
Сейчас.
Значит, чтобы назначать, что...
Ну, например,
что такое там простая атака?
Простая атака, это, например, чтобы
угнали х-начение
и анализируя саму х-начение,
смогли как-то залогиваться.
Если такая атака успешна,
то значит, что х-функция плохая,
там в графике ровно m и b.
И поэтому, соответственно, ничего не получится.
Ну, и что это в терминах наших,
ну, в терминах m?
Не, подождите, это вообще парольный стиль.
Хорошо.
То есть идея такая, что
если только на базе х-начения
можно взломать
логин, то это значит,
что система плохая, независимо от
разглашения, а просто на самом себе плохая,
что там секрет на самом деле нет.
Вот, теперь, соответственно,
пусть у нас
теперь мошенник смог
пообщаться
с клиентом, у которого есть
пароль, и
после этого смог залогиваться назад.
Но тогда
он мог бы, значит,
пообщавшись с клиентом, он узнал
это въем.
Вот. Но если есть
вот такой вот термин,
то вместо того, чтобы делать вообще
общаться с клиентом, он мог бы запустить этот термин.
И используя ту же самую информацию
тоже залогивится сайта.
Но это бы и получилось,
что зная только х-начения, он смог
залогиваться назад.
Ну тогда, окей,
я, наверное, более меняю. То есть, грубо говоря,
тогда, видимо, нулевое разглашение
такого, что такого m не осуществует.
Нет, наоборот.
Наоборот, такое не осуществует.
Все, что можно узнать, общаясь
с тем, кто знает секрет,
можно узнать
вообще, можно знать и не зная секрета,
а просто зная x.
Вот. И если тогда
свободу взломать, значит вообще система плохая.
Не то, что там разглашение, а то, что она надежная.
Так. Да.
Я правильно понимаю, что нулевое разглашение
это свойство протокола.
Ну, например, если у нас в протоколе
у функции верификатора есть
вопрос сообщения it и bit ответа,
то он уже точно
не может никогда ставить
нулевым разглашением, например.
Ну, типа, если, да,
да, да, да, то есть даже если один символ
пароля разглашается, то это уже не...
Да, то есть я про то, что
ну, короче, верификатор
тоже должен выбирать какую-то функцию
специальную, иначе
для этой функции для любого прувера
может не существовать не нулевого
разглашения.
Короче, не для любой
функции верификатора есть прувер,
который делает не нулевое разглашение,
а нулевое разглашение.
Даже что
вы знаете о функции верификатора?
Ну, у нас есть алгоритм, по которому
действует верификатор.
Например, допустим, в этом алгоритме есть
вопрос сообщения it и bit ответа.
Да.
Тогда утвердается, что
что бы ни делал прувер, у нас уже точно
не будет нулевой разглашением.
Не, ну даже типа его не обязано,
но это вопрос вообще честно.
Не, ну
при представстве, что
угадать логите, вам говорят, скажите
первый символ вашего пароля.
Ну слушай, ну это же изначально
в протоколе.
Ну если еще верификатор говорит,
что если ему ответили на этот вопрос
неправильно, то он говорит что false,
тогда поедень не будет.
Что?
Сейчас, ну не знаю.
Ну ладно.
В смысле, это вызывает трудности
из-за того, что у нас есть
какой-то протокол, и мы
по протоколу хотим уметь что-то восстанавливать,
грубо говоря.
Что восстанавливать?
Ну, как раз то, что мы еще не обсудили,
mAx похоже на view.
Давайте mAx похоже на view,
а он похоже на секрет.
Ну, да.
Бывает нечестный прувер,
потому что не хотим.
Нет, значит, сейчас
смотрите, что это
какие-то определения.
Что такое?
Значит, это план
языков,
план языков,
ады которых
существует пара p-r-r,
значит, такая, что
первое,
первое, если x лежит в влаге,
то
значит, это будет view, а есть еще
ответ верификатора.
То есть, если x лежит в влаге, то
вероятность того, что
верификатор, общаясь именно
с этим прувером на ходе x,
выдаст
yes,
это будет больше, чем
верить.
Что, собственно,
доказывается, что если лежит в влаге,
то прувер так же.
Значит, второе,
что если не лежит в влаге,
то не только этот прувер,
а какой-то другой прувер,
значит, для любого пациента,
вероятность того,
что верификатор, честный верификатор,
общаясь нечестным прувером
на ходе x,
выдаст ответ
yes, это будет меньше, чем
верить.
Вот, и третье, собственно,
любое разглашение. Давайте я
теперь за информатами тебе похоже
распишу точно, что это означает
этот тип. Но
в втором варианте, да, сразу для
производства верификатора.
Так, значит, это
во-первых, только для того, чтобы
когда x лежит в ваге, то есть
нас отрезует на тебе только честный
верификат. Правильно нужно это
доказывать, да?
Нам не нужно случайно любитую функцию m
еще засунуть, как вот?
Ну, это же, опять же,
так и вначале не есть.
В смысле, те же самые имеют следы,
которые были на протоколе.
Ну, это уж он сам разберет,
просто использовать.
Да, прувер уже не знает случайно
любитый верификат.
Так, значит, третья верификатор
лежит в ваге.
Ну, тогда, значит, смотрите,
то, что точно плевишь, значит, я думаю, что
в КПФ они похожи.
Значит, у любого
в это звездочкой
существует m со звездочкой,
значит,
а m со звездочкой,
значит, отображает
м со звездочкой
в
м со звездочкой
еще вместе с любым машинником.
Да, то есть есть
возможность
выдать ошибку,
что там не получилось.
Да, не получилось
иммунитировать.
Вот.
Значит, с двумя условиями
первое условие
вероятность
того, что
m отыскывал ошибку
будет не больше
одной в каждой.
Да, то есть в звездочке
связь с 50% или больше
что-то удалось генерируется.
Вот.
А второе условное
распределение
условное
распределение
ой, m со звездочкой.
Да.
Значит, условное
распределение
m со звездочкой
м со звездочкой от х
условно на то, что
учились об этом.
Значит, вот это условное распределение
ровно такое же.
Значит, такое же
как
и распределение
m
отыск acquaint
Можете 1981 разобрать
пример, почему, вот, если мы сообщаем
первую букву пароля в прыгере, ну,
в каком-то протоколе, то
эта штука будет
не удовлетворять б�� updating.
Ну, тогда
В этом хилу в том числе будет первая буква породы.
Соответственно, вот этот М со звездочкой должен получить хэш значения и из этого хэш значения выудить первую букву породы.
Но если хэш функция плохая, то это предположительно сложная задача и, соответственно, грядский алгоритм не решается.
В смысле выудить по хэшу первую букву породы? В смысле...
Сейчас М должен выудить по хэшу первую букву породы.
Ну хэш значения. Да.
Нет, это положение, что хэш значения называется надежной, если по хэш значению нельзя конкретный вид агумента рассчитать.
Ну да.
Соответственно, если эта хэш функция надежная, то тогда этот М со звездочкой не сможет первый вид угадать.
А если в протоколе он запрашивается, то в объем он будет.
Нам нужно куда-то зашить еще сам секрет.
В плане, мы пока можем выдавать произвольную букву вместо первой буквы пароля.
И пока нас не проверяют на то, что эта буква совпадает с первой буквой секрета, проблем нет, кажется.
Нет, а что значит не проверяют?
Вот данный вопрос.
Это как-то все зашитывает скорее в определение b, что вот этот хим он должен быть связан с х.
То есть в случае, если хэш функция надежная, то эта штука все еще с нулевым разглашением.
А если хэш функция надежная при вычислении?
Нет, у нас просто М не вычислим.
М такой не будет, если хэш функция.
Слушайте, давайте может для графов разберемся.
А П это у нас вообще что угодно.
Вообще говоря, что угодно.
Ну и поэтому он знаете.
Да, то есть П может быть даже не вычисленным функцией.
Но, как правило, П будет наоборот поднимен алгоритмом, который получает дополнительно какой-то секрет, который связан с х.
Тут в определении нет никаких химных окончаний.
Сейчас, здесь мы подразумеваем, что В это минимальный алгоритм, и со звездочек тоже.
Восемьдесят сеточек.
Уже любое?
А какое со звездочек любое вообще?
Ну как бы не ехать в жизнь.
Да, да, да.
Не со звездочек.
Не с каким ресурсом, не надежным способом докидать неверное движение.
Так, давайте играть.
Майма.
Сезонограда.
Да.
Так, значит, с изомофизмом графом получается что?
Что есть два графа.
Уже один.
Они изомофизмные.
И Прувер знает изомофизм.
Верификатор не знает.
И при этом Прувер должен доказать, что соответственно он знает изомофизм.
Что знает изомофизм, или что они изомофизм?
Ну, значит, там у нас есть еще подобность, которая называется Zerinov's proof of knowledge.
И там как-то они что означают, что он знает изомофизм?
Ну, там как раз какие-то ограничения.
То есть это фактическая верификаторная аллария, на которой дополнительный вход.
Получается, это как-то связано с общим входом.
Вот это вот и все.
Вот, в этом нам не будет есть.
Так, значит, что тут получается?
X.
Значит, X это пара из Zerinov's proof of knowledge.
Значит, это соответственно есть phi.
Ну, вот я так напишу.
Который же ноль переводит G1 это изомофизм.
Вот, значит, соответственно, значит, есть Прувер, есть верификатор.
Значит, X получает они оба, а дополнительно Прувер еще phi получает.
Вот.
Верификатор случайно обитая.
Ну, и Прувер тоже в своей случае обитает, получается.
Так, хорошо, значит, теперь как?
Как это устроено?
Значит, Прувер выбирает случайную перестановку.
Да, конечно, уже Mg1 одинаково число вершин, значит, это неинтересно.
Значит, у них поем вершин.
Дальше Прувер выбирает случайную перестановку sigma.
И вычисляет аш, который будет в sigma от g1.
И эта аша продает верификату.
Значит, после этого верификат выбирает случайное b.
Да, случайное bx, b и отправляет его в Прувер.
Вот, значит, после этого Прувер вычисляет переставку tau,
значит, которая будет равна sigma, если b равен x,
или sigma в пополице spi, если b равен u.
И, соответственно, вот эту tau отравляет верификатор.
Значит, после этого верификатор возвращает ответ,
значит, если tau от json b равен x,
ну и, соответственно, no иначе.
Вот так только таково.
Так, давайте про 1 и 2 поговорим.
1 и 2 легко обсудить.
Хотя там есть один тонкий вопрос.
Сейчас, слева у вас Прувер, справа верификат.
Да, слева у вас Прувер, справа верификат.
Случайно перестановку.
И у того и другого есть случайное?
Сейчас, а мы доказываем не изоморфизм?
Изоморфизм доказываем.
А, да, да, да, не, я просто подумал, что, ну да, да, да.
Да, значит, изоморфизм, чтобы РП было, да, точно,
было считать, что Прувер ограничен.
Так, хорошо.
Значит, первое свойство, что если они изоморфинальные,
и на самом деле у другого есть изоморфизм,
то ну просто все пройдет, да.
А что такое tau?
Tau перестановка, которая, как бы,
правильного Прувера должна вот так начисляться.
А вообще она может быть другой перестановкой.
Или даже с его сообщением, да,
но нужно как-то любое сообщение
поддержать перестановку.
И пусть, конечно, не декодируется перестановка,
то, значит, сразу нет.
Хорошо, значит, пока Прувер, если Прувер честный,
то ну просто будет либо sigma g1,
который будет равняться h,
либо sigma от phi от g0,
поскольку phi от g0 это g1,
от sigma от g1 это h,
то тоже это будет Прувер честный,
то это РП точно будет.
Так, теперь, если на самом деле они не изоморфинальные...
Сейчас это равенство как равенство графов?
Равенство графов, да.
Равенство графов поэкадексированных, да?
Поэкадексированных, окей.
Ну что, просто...
Ну, если походу там не надо вычислять изоморфизм...
Не надо вычислять изоморфизм, да,
равенство графов как равенство, понимаешь?
Те же самые хорошие насыденные...
Ну вот, значит, если на самом деле изоморфизма нету,
и нет никакого phi у P со слёдочкой,
а просто он пытается обмануть филификатора,
то дело в следующем вот.
Каким образом не вычислялась вот этаж,
то максимум для одного вито
будет перестановка, для которого это трудно.
Вот, может быть, вообще не для одного,
может быть, только для одного.
Для этого сразу не может быть тогда не быть поизоморфин.
Ну, в связи со слёдочкой доктора или ревинкратор
запросит как раз тот граф,
у которого перестановки нет.
И тогда, чтобы здесь не прислал пуэр,
это будет опровергано.
Ну, соответственно, получается,
что сразу одна-вторая, это будет отвергаться.
А тонкий момент, который я анонсировал,
это, что здесь у меня одна-треть,
да, а получается одна-вторая.
Соответственно, нужна где-то партификация,
и при этом нужно, чтобы у тебя осталось третье свойство,
но вообще ещё не обсуждать.
Ну, вот это давайте оставим как тонкий момент.
Какое? Третье?
Нет, не третье свойство, а то, что
на третье можно понизить
и не потерять при этом третье свойство.
Там есть свои тонкости.
Но, на самом деле, сейчас тонкости там такие,
что если повторять последовательно,
ну, если повторять последовательно,
то будет у вас всё то же самое.
Обычная партификация, да,
что можно повторить два раза подряд.
Вот, но это увеличивает шалуранку.
Ну, два раза.
Вот, если третью два раза,
если там одна отдельная власть абонента,
вен раз.
Ну, это поленок.
Вот.
А ещё есть теорема,
потому что параллельное повторение
тоже не улучшает,
ну, не нарушает его улучшение.
Это сложная теорема.
Простая интуиция не работает.
И там даже больше, что раз повторять,
потому что вы получите то же самое снижение.
А статьи на эту тему пишутся формально
или не очень?
Хорошо.
Вот, так, хорошо.
Значит, ну теперь давайте от этого
облашения.
Значит, смотрите, что, собственно,
видят линфикаты.
Да, значит, цена Х,
он видит
свои случайные биты,
он видит граф, который я ему прислал,
и он видит так.
Так, давайте, наверное, всё-таки
Х не буду дублировать.
Да, значит, вот это зимой.
Значит, ВС с бёдрышкой,
вообще, из куера,
на ТХ.
А где ещё раз тут фигурирует сам
сертификат?
Вот ФИ.
Ну, не сертификат, а...
Нет, это ФИ.
Нет, тактику П.
Шиф, тактику П.
Ну, куер использует ФИ
и вычисляет таз.
Значит, это будет случайная битая,
или битая...
А, сейчас, то есть вот там
мы выбираем не только М, а на самом деле
мы ещё ФИ выбираем какое-то, или нет?
В смысле, где мы выбираем?
Вот тогда мы говорим, что
в милевое разрушение существует М звёздочка,
правда ли, что мы там же выбираем ещё
какой-то ФИ?
Где? Нет.
Ну, значит, откуда мы берём ФИ?
Подождите, ФИ я откуда не берём?
Тут вовремя нет ФИ.
Нужно ТАУ.
А, ну для П нужно.
А, П тут вообще нету.
В смысле, ФИ у нас вшитов в ТАУ всё.
Мы его используем.
Но это оно в честном приколе вшитов в ТАУ.
А в нечестном его вообще нету.
Так, хорошо.
Значит, смотрите, во-первых, давайте
для честного индификатора
Дальше для честного индификатора.
Значит, честный индификатор
делает следующее.
Значит, он
да, то есть
что делает МНХ?
Значит, он выбирает
один из двух графов случайно.
Значит, играет
случайно
гид С.
Значит, который
0,1.
И, так,
вот, давайте я
там Ц,
то есть либо ТАУ, либо ТАУ-1,
который зафиксирует приставку.
Зафиксирует приставку.
Вот.
Соответственно, вычисляет
ПАШ.
ПАШ, который будет
значит, Ц,
Ж, Ц.
Вот.
Значит, вверх он и так
случайно выбирает.
Значит,
например, случайно намерно.
Вот.
Значит, ну и дальше
значит, дальше теперь В берется,
ну, может быть, чтобы просто один из этих битов.
Вот. И если оказалось, что
В равно Ц,
значит, если В равно Ц,
то он возвращает
коберостройку
из В, А,
и ТАУ.
Вот. А если бы
не ровно Ц,
то больше не получилось.
Знаете, не получилась симуляция
и возвращает
АШ.
А, ну с Б остается ПАШ,
поэтому мы его не можем заранее угадать, да?
Ну, да.
Нет, ну в данном случае
А, для честного, может быть,
может даже вообще 100%, но
да, если верификатор честный,
то можно прямо взять
В из Р, и именно для этого
так даже ключ получается.
Не получится просто Р
Мы Аш генерируем по
Б, что ли.
В смысле, мы
в АПЦ, если его заменить на Б,
то мы поэтому Б сгенерируем АШ,
а потом нам нужно как бы по вот этому
АШ сгенерируем. И это уже
для нечестного верификатора.
Ну, вон там у нас
А, в смысле у нас, а, в нашем верификаторе
у нас Б не зависит от АШ, да?
У честного да.
А у нечестного может зависеть.
Да, то есть вот
значит тем со звездочкой
АПЦ, да,
что получается анонично,
вот.
Но теперь Б
да,
анонично, но
Б это будет как бы
В со звездочкой, вот и
АПЦ.
Да, то есть Б
не случайно зависит, а
АПЦ зависит.
Вот.
Ну, а дальше точно так же.
Дальше аналогично.
Ну,
значит, смотрите, теперь тут что нужно
доказывать?
Ну, нужно доказывать, что тут
В со звездочке
ничего не сможет
сделать.
Ну и тут мы опять углубляемся
в действии
группы на множестве.
Да, то есть тут
значит история такая,
что поскольку вообще действуют
в положении, что они заморфаны,
да, то значит
группа
не группа, в смысле
семейство телеграфка, которая заморфана, же ноль,
и семейство телеграфка, которая заморфана, же один,
это одно и то же семейство.
И, соответственно, если мы берем
вот,
здесь, значит, если мы берем
С равным внуку, то аж распространено равномерно
среди этого семейства. Если берем С
равномерно ниже, то аж распространено
равномерно для этого семейства.
Вот, а после
этого,
то есть условно на то, что аж
получился таким,
что С равномерно более 1,
а В
получается каким-то конкретным
для этого аж.
Ну, то есть когда случается, если
С равномерно на 2 и В совпадется,
то С равномерно на 3 и В совпадется.
А В как раз получается на 2
или получается на 2?
Понял вопрос.
Как-то странно получается, что
если мы там 1-2, у нас 2-3 заменим,
у нас как будто нет,
то это критически меняется.
Сейчас, какое это такое?
Вот вероятность того, что
мы все-таки нашли,
что симуляция получилась,
ну, не на 1-3, а на 2-3 заменим,
например.
А, нет, симу...
А, вот сейчас, вот это
вот вторая. Да, вот ее,
если мы на 2-3 заменим, то вот это
алгоритм уже не работает? Да нет,
тут как раз простая партификация. Или а,
а она подкручивается, да? Да,
то есть если можно просто
то же самое воспустить в новый раз
и взять первую успешную,
первую успешную генерацию,
как раз эта 1-2 в Prabhupati
очень легко
делается.
Нужно спустить в новый раз, взять
первую успешную
симуляцию.
Тогда бы то же самое
распределение.
Потому что надо сказать, что такой второй распределение,
потом еще на 1-4, точно такое же распределение.
Да, в смысле, когда бэннер на C, мы не обязаны что-то сразу возвращать.
Да, да, да. Когда бэннер на C, мы можем еще раз все то же самое запустить.
Видимо, интуитивный смысл M такой, что это какой-то обманщик, который позволяет обмануть мошенника в том плане, чтобы предъявить такое же...
Ну, в смысле, грубо говоря, если у нас есть какой-то верификат, который ведет себя по-другому,
мы для него умеем предъявлять некоторый прудер, условно, который, на самом деле, сгенерирует те же самые данные по слитичным свойствам, что и что он увидит для какого-нибудь адекватного хода.
Ну, более-менее, да, но только отличие в том, что, в отличие от круглого, этот симулятор, наверное, обращает ошибку.
Ну, да. Если бы он никогда не возвращался, он сам бы пройти.
Так, вуа.
Значит, смотрите, если вообще отказаться по родной ошибке, то, вроде, нет никаких примеров, только такой.
Сейчас, а можно пока третий доску не стирать?
Да.
А четвертый?
Можно.
Как шахмак.
Ну, четвертый пример, а на третий академик.
Я пишу.
Так, значит, дальше, уже мало времени остается, да, значит, дальше вот остаются другие два варианта, S и ZK, и CZK.
Значит, дальше, сначала вот к S разберемся.
Так, значит, есть такое понятие, техническое расстояние.
В неркотичайном смысле.
Так, оно является так.
Расстояние между RL и DL.
Значит, на самом деле это не случайно величины, а то, что называется вариантовые ансамбли.
То есть набор случайных величин, парадоксированные разными названиями числами.
Да, вообще английский язык известен тем, что там группы животных называются разными странными словами.
Да, эти всякие вот там, там, бунт, стадо, и так далее.
Там для каждого вида есть какие-то странные слова, которые...
Ну, у нас тоже.
Это бунт, стадо, стая.
Не, ну стадо, стая, это все-таки у них нет своего значения.
А там что-то парладно там кого-то.
Ансамбль-кандидат.
Вот, и вот это немножко перешло.
То есть вот здесь называется ансамбль, а еще бывает там батарея тестов.
Ну, вот так вот.
На борт этот ученый называется батареей.
Альгалатская вторая разница.
Вот.
Там хотя бы в средние века просто кто-то пошутил, и как-то это помялося.
Вот, хорошо.
Стадо стояния.
Вот есть там, есть ансамбль случайных величин.
Значит, это вот что такое.
Значит, это случайные величины.
То есть тут именинское то, что все слова длины N получают какую-то вероятность,
так что они всю выдают единицу, и каждую не отрезают.
То есть это фактически стахотический яд в длину 2 степени N.
Но дальше у каждого отдельного элемента, то есть событий, есть вероятность.
И у каждого событий, то есть множество тоже есть вероятность.
Соответственно, вот это расстояние, это максимум по всем событиям,
модуля радности, вероятность того, что N попало в N,
и вероятность того, что B N попало в С.
То есть это как бы максимальное различие между тем, как эти распределения оценивают вероятность этого события.
Теория, что это, на самом деле, одна-вторая, вот там вот стояние.
То есть это одна-вторая, сумма просто пошла так сам.
А тут будет модуль радости, вероятность того, что N попало в N,
и минус вероятность того, что B N попало в N.
Так, ну это я, наверное, заходю как задачу, чтобы это попало в N.
По всем самодлижающим S?
Нет, значит, это FN или BN, N, C, Z.
А ИГО?
Сумма по всем самодлижающим S или нет?
Нет, ну даже нет.
Это связано примерно.
Ну хорошо.
А ИГО?
А X?
Это ИГО.
А, что?
Да ладно.
BN это событие, а X это элементарное событие в теории вероятности.
Так, ладно, это я не даю сейчас прокусить, почему это равняется.
Да, это вообще не по сложности задачи, да.
Кому-то какой-то объясню еще сегодня.
Или теорируем.
Так, хорошо.
Знать не дается на пределение.
Это FN и BN статистически другие.
А вот это уже поделительная сложность.
Синтетическое определение.
Значит, если для любого пленного существует какой-то индекс,
что для любого созданного индекса,
значит, вот это расстояние от AFN до BFN
будет меньше всего выхода в плену.
Вот, здесь уже получается важно, что это не одна лично,
не одна пара личных, а два отца плен.
И, соответственно, для любого пленника стремиться к нулю
быстрее любого обратно в плену.
Так.
Понятно?
Понятно.
То есть они как бы не одинаковые.
Чем больше, тем они ближе друг другу.
Вот.
Ну и тогда, соответственно, SZK,
вот это вот третье свойство
заменяется на то,
что просто МСЗО очень рядных,
статистически без кок, вот это вот.
И мы запрещаем неправильный ответ,
что они симулируют плен.
Да, то есть мы запрещаем ответ,
что не получилось, но разрешаем неправильный ответ
с большой вероятностью.
Значит, SZK, начиная с любого отца плен,
существует так собранный плен.
Такой, что им создаст реакцию.
SZK,
и
с большой вероятностью P,
SZK,
статистически близко.
А тут вместо M, код X, а это?
Вместо M, надинается.
Вот.
Нет, конечно, тут в правильном порядке СЕКВАТ
предоставить только в отдельную задачу.
Э-э-э...
Э-э-э...
Ну, чатки.
Годикатера на меня, да, значит.
Вот этот B-созвездочек работает с сексами убойтленные,
M-созвездочек работает с сексами убойтленные.
И соответственно для всех,
значит, для всех лицов получаются две вот обзорвенеченные.
И это должно быть так.
А, ну тут как бы добавлять еще один квантор, да,
для любого лица,
у которого глина M,
да, для любого лица, у которого глина M,
будет вот это расстояние меньше,
чем этот обладный квантор.
Вот.
Значит, утверждение,
что PZK можно в SZK
Почему?
Ну, потому что как раз
можно N раз повторить вот это вот,
взять первое попавшееся,
не первое попавшееся,
первое сработавшееся.
Соответственно будет специально управлять,
что N раз у нас работает.
Но в этом случае мы вернемся только по умолчанию.
И это как раз, да,
статустоимие нуля в одной из моментов.
Понятная идея?
Да.
Еще раз.
Значит еще раз.
Вот смотрите, сначала
распускай в первый раз,
у нас половина распространства
про Houston распределения
на половине ничего.
А то он опускаем еще раз.
Первый раз еще на половине оттавшегося,
тоже про Houston распределение,
а на половине ничего.
Так делаем N раз,
и оттас Diaz специально маленький
оттас в 비 Effects пространство,
где ничего
и все остальное,
где про Houston распределение.
И теперь мы вместо ничего
возвращаем что попало,
Возвращаем, что попало, и это чуть-чуть сдвигает распределение, так что расстояние как раз этими специальными моментами получается.
Хорошо, помахаем.
Вот. Так, хорошо.
Так, что, первый или третий?
Первый, да?
Первый, да?
Хорошо.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Значит, дальше есть понятие,
кроме статистической близости,
еще есть
вещественные отличия,
тоже Депрегнан Канханович.
Просто вещественные отличия.
Вот. На самом деле, значит, смотрите,
вот это вот,
вот это вот свойство,
значит, события,
можно переформировать по-другому.
Значит, переформировка
переформировка
переформировка
статистической близости.
Значит,
для любой функции,
ну, значит, для любого семейства функций,
значит, ТМ,
значит, ТМ подражает
0.1 степени,
0.1, 0.1.
Значит, дальше получается
и так же для любого
атоминома, существует
генбольской, для любого генбольского
атоминома,
значит, ну, разности, вероятность
того, что
ТН, а вот АТ,
1,
минус, вероятность того,
что ТН, АТ,
1,
это будет меньше, чем 1,5.
И это, в отличие, тоже самое,
но я как бы перешел от
множества его характерических функций.
То есть, вот этот
ТН, это будет
характерическая функция, да, УС,
которая это, вот, АТ,
от слова тест, как раз, как раз у батареи тестов.
Да, вот тут
мы берем в качестве батареи, мы берем все тесты
вообще, все, все
продикаты.
Вот, значит
на этом может оказаться так,
что этот тест, он пытается сказать,
вы дали ему Альфа,
ли дали ему Бету.
Да, и, например, то, что он сказал, Енису,
то что он шл Ladadie, мы интерпретируем как то,
что он сказал, что мы懍iet.
Ну вот, и получается, что то, что
на Айте сказал, что мы risk Allest
и то что он на Бете сказал, что мы н Messiah,
примерно не имеет этой.
Вот, так вот, puzzите меня,
отличительupa в том, что мы…
Тесты вообще берем, а только предымянные.
Значит, нашлительная отличенность полностью аналогична.
Но стандартный подход, что ТН лежит в СЛДШ-поле.
Тесты задаются схемой терминального развития.
Можно еще ограничить и рассмотреть только алгоритмы, но прям детерминированные.
Потому что...
Странно, что, говорят, тест...
Тест случайности, чтобы он сам появлялся, это было бы странно.
Потому что нужно дать себе случайности, чтобы не сорвать фильм.
Вот.
Хорошо, в общем, будем вот такое вот.
Да, вот такое вот.
Вот такое поделение использовать, чтобы тест сдается схемой терминального развития.
Вот.
Ну и СЗК тоже будет аналогично, только учителем не отличилось место статистической выставки.
Значит, СЗК...
Да, аналог.
СЗК для вычислительной отличимости...
Место...
По статистическому.
Так.
Ну вот такое определение...
Ну, может быть, оно не совсем понятое.
То есть, смотрите, что на них получается.
Почему это вообще либо хорошо...
Ну, смотрите, пусть у нас взломщик может сгенерировать что-то вычислительно неотличимое
к тому, что он узнает ходе общения с честным другом.
И потом это смог как-то использовать.
Но, смотрите, то, как использует этот взломщик, это по нашему предложению как раз будет пыленомиальным алгоритмом.
Да, потому что взломщик не специально и все сможет заломать.
Мы защищаемся только от пыленомиального взломщика.
Но, возможно, именно вот такого СПСД шпуля,
это иммунилирует то, что он может спаять конкретную схему для конкретных длинных ключах.
Поэтому это может быть не неравномерным алгоритмом.
Соответственно, если это взломщик привел к какому-то успеху,
то тогда саму эту схему можно считать тестом.
Ну и тогда даже и наоборот.
Если взломщик пообщался с честным клиентом и после этого смог взломать,
то точно так же он мог пообщаться с этим симулятором.
И поскольку симулятор неотличим,
то вот эта простая процедура, которую использует взломщик,
должна с той же вероятностью взломать схему,
но и значит по схему не надежная.
Так, ну теперь как это еще связано с судок и всем тут еще?
Значит, здесь ключович, который мы будем на крипто-карте покорить,
это для такого приятного.
Это для такого приятного.
Значит, тут есть...
Значит, нет, кажется...
Перезагрузка 1.
И по нему делается...
Значит, величину.
C это...
Значит, C это слово commitment.
Привязка...
Ага, это такой...
Значит, какие здесь требования?
Ну, первая вероятность, что все будет предъявлено.
Значит, дальше...
Значит, первая...
А, ну первая, это как бы корректность.
Сейчас, ну дальше есть как бы процедура раскрытия.
Значит, корректность.
Давайте я эту опенку напишу, как бы открыли шкатулку.
Но, значит, open от C от B и K от B нам дает уже...
Да, будет именно...
Именно то, что было изначально.
Так, значит, второй неположенец.
Сейчас, это вообще что?
Что?
Open это...
Ну, как есть и вкусы.
Одна из запечатываний, это как бы звание B,
в пару, вероятность.
Это либо вероятностный алгоритм,
либо даже интерактивный протокол.
В общем, по итогу получается C и K.
А open это витаминировано уже в цели.
И еще, у нас сейчас глобальная концепция такая.
Мы хотим...
Я обидел, что это был предъявлено.
Значит, вот следы двух частей.
Первая часть – это генерация привязки ключа.
А вторая часть – это открытие.
Ну, окей.
Да.
Как бы вот эта C – это такая закрытая шкатулка,
в которой лежит вит.
А K – это ключ.
Соответственно, нужно, чтобы, когда правильный ключ
в шкатулке приложили,
то, соответственно,
тот вит, который там есть, и возник.
То есть существует такой open, что...
Ну, это все вместе, да?
Это все часть протокола.
Часть протокола.
Значит, непрозрачность как раз связана
с этой самой...
с неотвечимостью.
Значит, C от 0
вышли неотвечимо.
Вот C от 1.
Вот. И третья – неподменяемость.
Неподменяемость.
Неподменяемость
значит, не существует
таких
C
ко 0, ко 1.
Значит, таких, что...
Да, open может не быть 0,
1 или аж...
Да, что вручники дашут.
Не существует C ко 0, ко 1.
Таких, что
open
от C ко 0
равно 0 и, соответственно,
open
от C ко 1
равно 0.
Вот.
Значит, дальше получается, что вот эти протоколы
они позволяют... Ну, это как бы для одного витра
написано.
Можно как бы каждый витр по отдельности упаковать вот так вот.
Вот. Ну, дальше...
Сейчас. На судоку немножко сложнее.
Что такое ко 0, ко 1?
Скробки какие?
В плане...
Ключи.
В плане...
Не существует C ко 0, ко 0,
ко 1, ко 1. То есть мы говорим, что для каждого
комплектного C... Не может быть такой шкатулки,
что и есть два ключа,
и если есть один ключ, то будет 0, а с другой
будет один. Ну да, то есть...
Да, что либо ключ там лежит, либо ключ
там лежит.
Жесть.
Шкатулка, это, видимо,
какой-то кодированный.
Что? Шкатулка, это просто какой-то кодированный.
Мы как-то закодировали наш бит,
так что его можно открыть, видимо, только...
Ну, тех того, да.
Сейчас...
А, почему...
Почему
мы не можем просто сказать, что ко 0, ко 1? Это просто наши ключи.
Может, надо сказать, что ко 0, ко 1
не равно
Сейчас что?
Не, не, сейчас, если
если такая B, то будет
именно B.
А, может, чтобы другое значение нельзя.
В плане мы говорим, что для данной привязки
нету какого-то... для любого
ключа выдаст либо
тоже B, либо ошибку. Да-да-да.
А для каких-то других привязок
мы говорим, что...
Это вообще для любой привязки.
Ну...
Ну, да.
То есть тут, значит, опять потом
используется, да, значит, что
прувер, он, например,
ну, дай себе
три раскраски. Так, я, наверное, уже
не буду рисовать, уже вообще время закончилось, но вкратце
я расскажу. Три раскраски — это
проще, чем судорогу, но это тоже другая задача.
Значит, значит, прувер
знает три раскраски.
Дальше
он случайным образом
представляет цвета.
Да, получается, он представляет три раскраски.
Вот.
И дальше на каждый цвет нам два бита,
и с каждым битом он вот это вот поделывает.
То есть он сам, значит,
знаете, он сам запускает
генерацию привязки
и ключа.
И все привязки, но без ключей,
да, все привязки
посылает верификатом.
То есть, смотрите, что, что это, наверное, произошло?
В этот момент произошло
из-за непрозрачности
верификатор ничего не знает, что там в привязке
лежит.
А другое, что из-за непобменяемости,
уже на следующих этапах
прувер либо посылает
ключ подходящий, там уже он
то, к чему он привязался, ну, либо
он посылает ключ неподходящий, и тогда
верификатор не принял.
То есть, вот,
вот, хорошо, значит,
после этого
верификатор просит раскрыть,
выпирает случайное вебро,
и просит раскрыть привязки
к цветам концов
этого вебра.
И только для них
прувер посылает ключи.
Вот эти вот.
Ну, вот,
вот,
вот,
вот,
вот эти вот.
Да, то есть, как
там две вершины, по два бита,
четыре ключа посылают.
Вот, верификатор раскрывает
и проверяет, что там цвета корректная.
Прикольно.
Вот, а что получается?
Слушайте, а мы пользуемся тем, что такая функция есть, да?
Ну, это предположение,
там дальше есть, это
на квитографию будем изучать.
Ну, реально, если есть одностронняя функция,
то есть и вот такое.
И это прям, почти теорема.
Ну, это теорема, которую мы почти докажем.
В курсе квитографии.
Вот.
А безнутроей функции вообще
квитографии нету.
Вот.
Смотрите, если
раскраска правильная,
то там все будет нормально, все пройдет.
Если
раскраски нету,
то к чему бы пружину привязался,
где-то какая-то ошибка будет.
Либо там негрехный цвет, либо два одинаковых.
Да, в общем, хотя бы на том рябле будет ошибка.
Какую-то вероятность.
Есть вероятность, что один липучной ребер
нарисовка твёрдой этой ребро запустит.
Ну и после этого
либо круг пришёт в честные ключи
и, соответственно, нарисовка
сменит ошибку, либо круг пришёт в неподходящие ключи
и, соответственно,
пускать хорошее истошит.
Вот, вот получается разрыв,
между единицей и единицей мимо за ним
будет ключной ребер, который потом можно
наносить.
Вот.
Откуда нулевое разглашение?
А как раз от перекраски.
Да, от того, что мы случайно образно перекрасили
и тогда у нас ребро
имело два разных цвета
при случайной перекраске
это просто случайная пара различных цветов.
Понятно. Шесть перестанововых цветов
и, соответственно, шесть вариантов
разных цветов
у конца ребра
и как раз разделяет на одно FD будет.
Вот.
Ну и интуитивно
всё, что узнал эфикатор
это он узнал случайную перекраску одного ребра
который разноцветный
но это он и сам может его выкручивать.
Вот такая FD, а дальше там
формально нужно доказывать
как бы сопрягать вот это вот с тем определением
и ещё доказывать
что в повторении тоже ничего не испортится.
Вот.
Ничего.
Да. Но нам ровно этого не хватало
в суть.
В смысле на семинаре нам не хватало
как раз гарантии, что он не под...
Ну то есть мы предложили поставить стол
и положить карточки
в рубашки вверх.
Потом он идёт и потом ему просят
типа открыть карточки.
Вот.
Да, но важна ещё случайная
пристановка.
Ну да, ну в плане, короче, что он видит
что между процессом он не подменяет
никак карточки.
Но так бы нам нужно было это смоделировать
по сети условно.
А тут это оно есть.
Да, да, это вот оно есть.
Так, ну всё, видимо.
Спасибо.
Всё, спасибо.
Что хотите.
Так, а что у вас остается экзамен?
Есть.
До следующего года.
