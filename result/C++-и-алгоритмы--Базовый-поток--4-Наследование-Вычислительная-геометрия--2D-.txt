Сегодня у нас новый раздел ООП, который называется наследование. Про наследование мы будем
говорить много. В общем, это довольно объемная часть и существенная часть языка C++. Сегодня мы
что-то из этого рассмотрим, остальное в следующих лекциях. Формально наследование это свойство,
которое позволяет создавать новый тип данных на основе уже существующего или на основе уже
существующих, при этом с полным или частичным взаимствованием функционала. Как вы помните,
когда мы обсуждали ООП, мы говорили про четыре основных концепции, на которых здесь ждется ООП.
Это абстракция, инкапсуляция, наследование, полиморфизм. Наследование — это последний
раздел, который мы говорим. Он буквально про следующее. Если у вас есть какой-то тип,
то есть вы написали свой класс, свою структуру данных, то вы на ее основе можете порождать
новые, при этом заимствовать ее функционал, частично или полностью. В качестве примера можно
привести такую. С одной стороны искусственность, с другой стороны вполне себе реальную задачу.
Представьте, что вы проектируете какую-то компьютерную игру. У вас есть какие-то
персонажи. Персонажи могут что-то делать, собирать какие-то ресурсы и что-то такое.
Вам нужно создать иерархию классов. Допустим, у вас есть класс эльфы, класс гномы и так далее.
Что еще раз? Это расы, окей. Послышалось. У каждого персонажа в компьютерной игре есть свой
набор действий, которые они могут совершать. Некоторые общий набор действий. Например,
у каждого персонажа есть сила, есть показатель здоровья, есть показатель опыта, который он
получает в течение своей жизни. Естественно, по мере роста вашей программы, по мере того,
как вы вводите новые сущности в вашу программу, у вас соответственно возникает, естественно,
образом дублирования кода, потому что вы составите нового персонажа с некоторой новой способностью,
при этом старые свойства у него должны остаться. У него тоже есть показатель здоровья, у него тоже
есть показатель сила и тому подобное. Возникает, во-первых, естественным образом дублирование кода.
А во-вторых, давайте подумаем. Допустим, есть какой-то игрок, и игрок пытается создать
свой набор юнитов, который у него есть, свой набор персонажей, которыми он управляет. Естественным
образом хочется, наверное, сохранить их в одном массиве. Хочется сохранить их в одном массиве и
как-то ими управлять единым образом, то есть заставить всех пойти в одно место, заставить их все выполнить
какое-то определенное действие и тому подобное. При этом, если мы действуем таким образом,
то есть мы для каждого персонажа, для каждой расы, чтобы это ни было, в общем, вы создаете свой класс,
естественным образом вы не можете в одном массиве сохранить их все, потому что массив,
собственно, у нас C++, может хранить только объекта одного типа. Поэтому возникает две проблемы.
Первое, хотелось бы, наверное, избавиться от дублирования кода, то есть указать, что у вас есть класс,
который очень похож на какой-то другой класс, и при этом не дублировать код, а создать примерно
такое же, но с какими-то, может быть, дополнительными свойствами. А во-вторых, каким-то явным образом
задать родство между этими классами, то есть сказать, что вот эти классы явно связаны друг с другом,
то есть один тип, например, может приводиться к другому, вместо одного типа можно везде использовать
другой тип и так далее. Соответственно, наследование про все это. И вот чтобы так поступить,
мы можем воспользоваться следующим синтаксисом. Допустим, у вас есть некоторый базовый класс,
персонаж, в данном случае StructHero, и вы хотите, то есть это некоторый базовый класс,
который представляет себе какие-то общие характеристики каждого персонажа вашей компьютерной
игры. Ну а теперь вы хотите на его основе уметь создавать каких-то конкретных персонажей,
какие-то конкретные расы и тому подобное. Тогда для этого вы делаете следующую вещь. Вы пишете
класс или структ, дальше пишете имя структуры или класса, и дальше через двоеточие указываете
класс, на основании которого этот класс должен создаться. В данном случае я говорю, что структура
лучника у меня создается на основе класса персонаж. Что это означает? Про это слово пока можно
забыть, пока для нас оно ничего не означает. То есть просто пишем двоеточие и можно написать имя
класса или какой-то другой структуры. И что это означает? Это означает, что все те поля и все те
методы, которые были в базовом классе, теперь будут полями и методами в классе Archer. Понятно? То есть
мне не нужно дублировать показатели сил, здоровья, опыта, метод лечения и так далее. То есть это у
меня все уже автоматически присутствует в классе Archer. В этом суть, в общем, такой простой
синтаксис. Почти то, к чему мы стремились, то, чего мы хотели. Тут пример, который демонстрирует,
что теперь все поля и методы Hero являются также полями и методами класса Archer. То есть у HeroArcher
есть поле HP, есть метод heal, и еще дополнительно мы здесь видим, что в классе Archer мы добавили
метод shoot, которого нет в методе Hero. Соответственно, понятное дело, что у объекта типа Hero вы вызывать
метод shoot не можете, так как там его нет, а у Archer метод shoot вызывать можете, так как мы туда его
привнесли. Все понятно. Теперь давайте поговорим про важный момент, про то, как работают модификаторы
доступа при наследовании. Модификаторы доступа, которые мы сейчас знаем, это public и private.
С ними на самом деле все просто. Смотрите, если у меня есть какой-то базовый класс Hero, и у него есть
публичные методы и приватные методы, то соответственно общие правила они сохраняются. Мы помним,
что означает приватность. Приватность означает, что мы запрещаем всем, кроме друзей, пользоваться
этим методами. И вот тут возникает такая ситуация, что наследники на самом деле не друзья. Если вы
наследовались от этого класса, то вы не имеете права все равно использовать приватные методы. Но это
логично. Представьте, что у вас есть некоторые классы. Допустим, в стандартной библиотеке есть
какой-то класс. Понятное дело, что у них есть какие-то приватные методы. Как получить к ним доступ?
Ну никак. Но при этом мог бы существовать лайфхак, при котором вы просто наследовались от этого класса
и могли спокойно получить доступ к этим полям. Но, естественно, так делать нельзя.
Если публичные методы используют приватные поля, и мы наследуем вот эти публичные методы, то эти методы используют приватные поля, а это не работает правильно?
Естественно, они работают. Вот здесь пример. Естественно публичные поля могут спокойно использовать
приватные как поля, так и методы, вот как и здесь. Соответственно, если я буду вызывать метод Heal через
объект типа Archer, то все будет нормально. Я же на самом деле зову публичный метод, а он мне доступен.
Ну вот, все понятно. Да, если вы на своего наследника объявите другом, то ему можно будет обращаться и к приватным методам.
Вот здесь вот тогда такой пример. Есть структура Hero. У него есть публичный метод Heal и приватный метод UpdateHP.
Тогда Archer в своих методах может вызывать Heal. То есть Heal это его метод.
То есть он может вызывать свой метод. Потому что мы у наследовались от Hero, и теперь это его метод, он спокойно его может вызывать.
Но при этом, несмотря на то, что UpdateHP тоже является его методом, но он как бы находится в закрытой части.
То есть в закрытой части даже для самого класса Archer. Поэтому он его вызывать не имеет права.
То есть он как бы есть, но он находится в закрытой части и к нему обращаться нельзя. Понятно?
С наследованием паблик и приват могут приобретать некоторый иной смысл. В частности, я думаю, вы заметили, что у меня слово паблик написано вот здесь.
То есть модификаторы доступа я также могу написать перед классом, который я наследую.
То есть, например, здесь я могу написать паблик Hero или private Hero.
Что это означает для класса Archer? Вот здесь важный момент. Для класса Archer это не означает буквально ничего.
То есть на доступ внутри класса Archer это никак не влияет.
То есть Archer по-прежнему может пользоваться публичными методами класса Hero, а приватными не может.
То есть вот эти слова в данном контексте ни на что не влияют.
Если я вот тут заменю паблик на private, то все будет то же самое. Понятно?
А на что же все-таки влияют эти слова? Они влияют на то, как внешний код относится к классу Archer.
Здесь все то же самое, что и с модификаторами доступа.
Если вы говорите, что вы публично унаследовались Hero, то это означает, что вы всем говорите, что это мой батя и все имеют право использовать эту информацию.
Что значит имеют право использовать эту информацию?
Это означает, что они имеют право использовать методы.
Если я создал класс Archer, то я имею право говорить, что Archer.Hill.
Потому что у меня в структуре Hero есть метод Hill, а я Archer публичным образом унаследовал от Hero.
То есть я всем говорю, что я унаследован от Hero, поэтому у меня есть все методы, которые есть и в классе Hero. Понятно?
А если вы говорите private, а не паблик, то вот такая штука у вас не скомпилируется. Почему?
Потому что вы говорите private, вы говорите, что это только для служебного пользования.
Только класс Archer имеет право знать, что он унаследован от Hero.
Никто другой не имеет права знать о том, что он унаследован от Hero.
Соответственно, использовать методы Hero даже открытые, никто не имеет права. Понятно?
Внешний код.
Ещё один момент, кроме друзей.
Но друзья все-таки могут использовать тот факт, что что-то приватное и так далее.
Этот момент понятен?
Ещё раз, вот это слово, которое написано здесь,
оно имеет значение только для внешнего кода.
Внутри класса Archer вы по-прежнему можете использовать публичные поля Hero, а приватные не можете.
А вот это паблик и private относятся только к тому, как внешний код воспринимает Archer.
В данном случае, если мы приватным образом унаследовались от Hero,
то метод Heal мы не можем вызывать у Archer.
Потому что метод Heal определен в Hero.
А мы не имеем права знать, что мы унаследованы от Hero.
Ну и давайте немного поупражняемся в этом всём.
Что у меня тут за пример?
У меня есть класс A, у него есть публичное поле X и приватный метод F.
От этого класса я унаследовал структуру B публичным образом,
и структуру C, но приватным образом.
Давайте попробуем ответить на вопрос,
имели ли я право в методе H структура B изменять поле X?
Да, потому что X, по какой причине?
Потому что паблик внутри A и потому что паблик внутри B.
Да, потому что паблик у меня находится вот здесь.
То есть класс A разрешил всем использовать это поле.
Поэтому структура B тоже имеет право это использовать.
Теперь то же самое, но в структуре C.
Точный такой же метод H может ли он изменять поле X?
Да, может, потому что снова возвращаемся.
Вот это вот слово в данном контексте ни на что не влияет.
То есть не важно, как я унаследовался.
Вот эти слова паблик и private говорят лишь о том,
что разрешаю ли я другим знать о том,
что я унаследовался от кого-то или нет.
При этом сама структура B и структура C, естественно,
она знает, что она от кого-то унаследовалась.
Ну а к X я могу обратиться,
потому что, во-первых, C знает о том, что она унаследовалась от A,
а во-вторых, потому что A разрешила всем использовать поле X.
Оно в публичной области.
Ну а метод F можно ли использовать в структуре B?
Нет, нельзя. Почему?
Да, потому что структура A вообще всем запретила использовать это поле.
И структура B и структура C не являются друзьями.
Поэтому и здесь, и здесь использовать нельзя.
Теперь давайте перейдем на правую сторону.
Значит, я создал объект типа A
и пытаюсь обратиться к X и к F.
Получится у меня это сделать или нет?
Да, к X, да, к F нет.
Ну тут как бы наследования никого нет.
Просто работают модикатры доступа public и private.
Теперь рассматриваем структуру B.
Могу ли я у структуры B обратиться к полю X?
Да.
Почему?
Ну, потому что, во-первых, да,
потому что мы публично наследовали от A.
То есть мы имеем право знать о том,
что у меня в классе B тоже есть поле X.
Ну, а во-вторых, сам A тоже разрешает доступ к X.
Поэтому все нормально.
Могу ли я вызывать B.F?
А почему нет?
Да, потому что даже несмотря на то,
что у меня структура B говорит,
что я публично наследован от A,
то есть казалось бы, все имеют право знать о том,
что я наследован от A,
то есть не разрешает использовать метод F.
То есть наследники никак не могут разрешить
использовать эти методы.
То есть если предок запретил,
то, соответственно, наследники
открыть доступ не могут.
Ну, точнее, могут при переопределении,
но об этом позже поговорим.
Так, а в структуре C?
Да, ни то, ни другое нельзя,
потому что поле X и метод F
это поля и методы,
которые принадлежат классу A.
А класс A у нас следован приватным образом.
То есть мы не имеем права использовать тот факт,
что мы как-то у наследованного от A.
Все понятно?
Отлично.
Да, ну вот ответы.
Теперь познакомимся
с новым модификатором доступа.
Вот.
И он носит название Protected.
Про Protected мы говорили,
но до этого мы говорили,
что Protected работает точно так же, как и Private.
Но Protected работает немного иначе,
значит, Protected действительно запрещает
всем использовать
эти поля и методы.
То есть, грубо говоря, Protected действительно работает
как и Private, но
он разрешает доступ наследникам.
То есть, если Private запрещает доступ наследникам,
то Protected
разрешает доступ наследникам
и друзьям. Понятно?
То есть, вот назначение
ключевого слова Protected.
Соответственно, если в структуре A
объявил два поля, а они оба Protected,
то внутри структуры B
я могу использовать и X, и F.
Спокойно.
То есть, я могу спокойно обращаться к X,
могу спокойно обращаться к F. Почему?
Потому что структура A разрешила наследникам использовать эти поля.
То есть, их вызывать, их как-то изменять и так далее.
Но при этом,
если я у объекта типа A
попытаюсь через точку
позвать X, F,
то у меня возникнет ошибка компиляции.
Потому что Protected разрешает доступ только наследникам.
Внешнему коду использовать
B.X и B.F вызывать нельзя.
То есть, работает как private.
Ну и то же самое касается B.
B.X и B.F вызывать нельзя.
Почему? Потому что
внутри структуры A они объявлены как Protected.
А Protected разрешает только наследникам.
То есть, разрешает использовать только B.
Внешнему коду A не давал никакого разрешения.
Поэтому B.X и B.F
тоже под запретом.
Хорошо.
Ну и Protected, как из
public и private,
можно использовать
для изменения режима наследования.
То есть, Protected можно писать
перед именем класса, при наследовании.
Ну и, собственно, это будет означать
то же самое, что и модификатор доступа.
То есть, мы запрещаем кому-либо знать о том,
что мы у наследованного от A,
кроме наследников.
Ну вот здесь пример. У меня есть структура A.
Структура B Protected образом
унаследовала A.
И дальше у меня структура C, которая унаследовала B.
То есть, вот картина такая. Есть A.
Есть B.
Вот есть C.
При этом, вот эту вот связь
имеют право знать только наследники.
То есть, только C, B имеют право знать,
что вот есть такая связь.
Поэтому, естественно, C
имеет право обращаться к X и имеет
это право обращаться к F.
Потому что B разрешило своим наследникам
знать о том, что B от чего-то унаследовано.
Ну, соответственно, C знает,
что B унаследовано от A.
И поэтому C спокойно может обращаться к полям X и F.
Но при этом обращаться
к полям X и F через B,
ну а тем более через C.
A.X и A.
Ой. C.X
и C.F.
Это запрещено.
Окей?
Вопрос какой-то?
Вот.
Ну и
еще одно упражнение.
Значит,
есть структура A,
теперь у него три поля,
теперь у него три модификатора
доступа внутри есть публичное поле X,
есть приватный метод F,
есть protected метод G.
Я структуру B
protected образом наследую от A.
А структуру C публичным образом
наследую от B.
Вопрос внутри H.
Могу ли я обращаться к X?
Да, потому что почему?
Во-первых,
потому что я бы
унаследовал от A, во-вторых,
потому что в A это поле публичное.
Так, могу ли я обращаться к F?
Нет, у A это поле
приватное, поэтому к нему я
обращаться не могу. Могу ли я обращаться к G?
Да, почему?
Да, потому что это поле
protected, то есть структура A
разрешает использовать
этот метод.
Ну и на правую сторону перейдем.
Можно ли вызывать A.G?
Нельзя, это protected поле.
Protected поле для внешнего кода работает
как private.
Могу ли я обращаться к B.X?
Почему?
Да, потому что я
от A унаследован
protected образом.
А вот это наследование говорит о том,
что никто не имеет права, кроме наследников,
знать о том, что я от чего-то унаследован.
Поэтому здесь нет, ну и давайте сразу скажем,
что здесь везде нет.
H можно, потому что H это публичное поле
внутри самой структуры B.
Почему
B.X, B.F, B.G нельзя вызывать?
Понятно, да?
Эти все методы, они принадлежат
классу A, а класс A у меня
у наследован, а структура B
у меня protected образом наследована от A.
Поэтому вот внутри,
в этом внешнем коде я не имею права использовать
тот факт, что я как-то унаследован от A.
Так, ну и теперь
на C посмотрим, могу ли я обращаться
к C.X?
Почему?
Кто считает, что можно?
А кто считает, что нельзя?
Ну, с победой, да.
В общем, к X
обращаться
действительно нельзя. Почему?
Потому что X, ну смотрите,
что у меня тут происходит. У меня есть
структура C,
а внутри структуры C лежит
некоторая часть,
которая относится к B.
А внутри B относится
какой-то кусок, который относится к A.
И вот B говорит о том,
что вот
тот факт, что в B есть какие-то
поля или методы от A,
внешний код
не имеет никакого права.
А что происходит здесь, когда я вызываю
C.X?
Ну откуда у меня пришло поле X?
Ну поле X, во-первых, у меня пришло
из B, то есть так у меня C унаследован от B,
у меня X перешло по наследству
в класс C. А B
разрешает использовать X?
Нет, B не разрешает использовать
X. Почему? Потому что
это значит, что внешнему коду использовать знание о том,
что B унаследован от A нельзя.
Соответственно, классу C
тоже нельзя использовать.
Внешнему коду нельзя использовать информацию о том,
что C унаследован от A.
Понятно?
Поэтому здесь, конечно, нет.
Дальше. Можно ли вызывать F?
Ну, F, понятное дело, нельзя,
потому что это приватное поле вообще в A.
G можно вызывать или нет?
Нет, это Protected поле, а H
могу вызывать?
Да, могу, потому что у меня, во-первых,
у меня C разрешает знать о том,
что я унаследован от B,
а во-вторых, сам B разрешает
использовать H.
Вопросы?
Хорошо.
Ну да.
Ну и в общем,
когда мы говорим про
вот эти самые режимы наследования,
Public, Private, Protected,
можно пользоваться
следующей семантикой.
Когда вы публичным образом
наследуете от чего-то,
вы заявляете, что
тот класс, который вы сейчас
создаете, является
и тем классом, от которого вы унаследованы.
То есть, грубо говоря, когда вы наследуете
структуру B публичным образом от A,
то вы объясните, что
B, на самом деле, является A.
Понятно почему.
Потому что всё то, что верно
для A, верно и для B.
То есть, если у A можно вызывать какие-то поля,
то те же самые поля можно вызывать и у B.
Если для A можно вызовать какие-то
методы, то те же поля можно вызывать
и у B. Поэтому везде, где
по смыслу можно подставить A...
Это у меня от вас есть F от A!
...туда же и по смыслу можно
Понятно? Семантика такая. Это не только семантика, не только такой амниманический правил, но и реальный действующий правил.
Везде, где по смыслу, по контексту вы можете подставить класс A, вы можете подставить и класс B.
Это называется принцип установки Барбар и Лисков. Вот эта семантика является. Понятно?
То есть если вы хотите сказать, что какой-то класс является тем же самым, что и другой класс,
можно с некоторыми уточнениями, то используйте публичное наследование.
А какую семантику реализует Private и Protected?
Естественно, Private и Protected не могут использовать семантику «является»,
потому что если у A можно вызывать метод F, то у B метод F вызывать нельзя.
Мы это проговорили несколько минут назад.
Private и Protected реализуют семантику «содержат».
То есть если структура B Protected или Private образом наследована от A,
то мы можем говорить о том, что B содержит A.
То есть B, как деталь реализации внутри себя, содержит A.
Ну и в большинстве ситуаций, так как Private и Protected реализуют семантику «содержать»,
вообще говоря, Private и Protected наследования используются очень редко.
Почему? Потому что семантику «содержать» можно реализовать и с помощью простой композиции.
То есть вместо того, чтобы наследовать структуру B от класса A,
вы спокойно можете просто-напросто создать поле типа A и использовать его.
Понятно, почему это эквивалентно?
Потому что по-прежнему вот и здесь, и здесь, то есть классы B и C могут использовать спокойные методы A,
могут использовать спокойно поля A, и при этом никто внешне об этом ничего не знает.
Поэтому очень часто, но почти всегда Private и Protected наследования можно избежать
и ввести просто композицию, то есть ввести просто поле в Private или Protected область.
Но есть небольшое отличие, когда на самом деле используется Private или Protected наследование.
Самый частый кейс – это так называемая empty-base-optimization.
История такая. Известно, что для любого объекта C++ размер байтов должен быть как минимум 1 байт.
Даже если вы создали пустую структуру или пустой класс, то размер одного объекта такого класса или структуры – это 1 байт.
Для чего это нужно? Просто стандарт говорит о том, что если у вас есть два различных объекта,
то их адреса физически должны отличаться.
Понятное дело, что если у вас объект занимает 0 байт, то у вас нет никакой возможности
отличить один объект от другого по адресу.
Поэтому каждый объект C++ имеет размер как минимум 1 байт.
И это может вызывать проблемы.
Допустим, у меня есть структура C, у которой есть свое какое-то поле X,
и при этом она сама по себе унаследована в качестве деталей реализации.
Ей необходимо использовать класс, у которого нет никаких полей.
Это может пока показаться странным, но вообще такие классы можно придумать.
Мы писали такие классы. Может, кто-нибудь вспомнит, какой класс у нас был, когда про шаблоны говорили.
Например, мы писали класс IsInt.
Класс, который проверял, является ли тип Int или нет.
Но этот класс естественным образом не содержал никаких полей,
кроме статического поля, а статического поля в самом объекте не содержится.
Соответственно, такие объекты, которые не содержат в себе стейтлесс объекта,
которые не содержат в себе никакого состояния, являются пустыми.
Тем не менее, если я заведу этот объект в качестве поля некоторые структуры,
то размер самой структуры C у меня будет больше, чем размер Int.
Ну, ровно по той причине, про которую я говорил.
Каждый объект памяти должен занимать хотя бы один байт.
Что, наверное, как-то накладно.
То есть мы хотели как бы завести всего лишь одно поле Int,
всего лишь одно интовое поле, и завести какое-нибудь поле,
которое вообще не имеет внутри себя никаких других полей.
Конечно, мы ожидаем, что это все будет как-то эффективно по памяти храниться и так далее,
но этого не происходит.
Так вот, в C++ есть MTBaseOptimization, которая говорит о следующем,
что если вы наследуетесь от объекта, от пустого объекта,
то есть от объекта, у которого нет своих собственных полей,
то, в общем, размер этой базы составляет 0 байт.
Короче, сама часть, которая относится к базовому классу,
то есть как это расположено в памяти.
Если у вас есть какой-то класс B, то в нем сначала в памяти располагается какая-то часть,
которая относится к A, а затем, соответственно,
относятся все те части, которые являются с полями.
Так вот, если у вас базовый класс пустой, то есть у него у самого нет полей,
то происходит оптимизация, и, в общем, базовый класс в памяти B занимает ровно 0 байт.
Опять же, как я сказал, я привел примеры для класса изInt.
То есть у вас в принципе могут защищать классы, у которых нет никаких полей.
ИзInt, и в принципе в стандартной библиотеке их много.
ИзInt, изPointer, и так далее, и так далее.
Зачем можно было захотеть их наследовать?
Ну вот, представьте себе, что вы...
Давайте продолжим изInt.
Смотрите, у вас есть структура изInt,
которая проверяет, грубо говоря, является шаблонной, естественно.
Которая проверяет, является ли шаблонный тип, который вы туда передали, Int.
А теперь представьте себе, что вы хотите завести класс,
который не просто проверяет, является ли переданный тип Int,
а хотите проверять, действительно ли он является в принципе целочисленным типом.
Тогда что вы можете сделать? Вы можете написать структ из Integral,
то есть является ли тип целочисленным,
ну и прописать там какую-то реализацию.
Но при этом снова возникает проблема дублирования кода, согласны?
Понятное дело, что у меня есть классы изInt, у меня есть класс изChar, и так далее, и так далее.
Соответственно, мне нужно просто все эти проверки внести внутрь моего класса.
Если я этого делать не хочу, я просто, например, наследуюсь от класса изInt.
И теперь из Integral у меня автоматически будет равен true, если там, грубо говоря...
Если мне передали тип Int, то у меня автоматически будет подставлен true.
Нет, у вас все работает так.
Я рисовал картинку, давайте еще раз.
Если я хочу создать объект типа B, то что у меня происходит?
У меня в начале объекта B находится все то, что относится к наследнику.
То есть если у меня у наследника есть поля X, Y и Z, то все эти поля располагаются строго в объекте B.
А дальше идут свои собственные поля, там это T, U, V и так далее.
То есть B это на самом деле самостоятельный тип.
Просто мы говорим, что он создан вот так.
То есть он содержит все те же поля, что и A, и все те же методы, что и A.
Каждый класс должен самостоятельно проговорить, кто и чьим другом является.
То есть если кто-то является другом для A, то он не будет являться другом для B.
Наоборот тоже нет.
Нет, это все на этапе компиляции, естественно, происходит.
То есть компилятор видит, как объявлен и определен класс структуры B.
Структура B это то же самое, что структура A плюс еще что-то.
Тут нет никаких проблем.
То есть размер структуры B и все то, что содержится внутри структуры B,
известно на этапе компиляции.
То есть уже при чтении вашей программы все понятно.
То есть тут на этап линковки, на этап рантайма ничего не оставляется.
Еще вопросы?
То есть если у нас есть компиляция B, то это будет класс A.
Если у класса B сделано компиляция, какой-то другой класс,
он не сможет являться к элементам класса A.
Сможет. Нет, так сможет.
Давайте про это тоже поговорим.
Ну, допустим, у меня в структуре A есть поле, давайте int y заведем.
Если я внутри B скажу, что у меня там, не знаю, friend void f,
и вот я начну писать реализацию метода f,
то B.y я делать могу.
Если y protected, то...
Так, давайте разбираться.
Нет, я думаю нет.
Потому что protected...
Короче, поле y защищено самим A, а не B.
То есть B не имеет права разрешать доступ к полям A.
То есть если A сам запретил, то B не может открыть доступ.
Да, вот это понятно, почему если я сделаю поле y protected,
то даже если у меня f друг, тут будет ошибка компиляции.
Давайте так, по порядку, как это работает.
Вот я обращаюсь B.y.
Сначала происходит проверка имен.
То есть сначала компилятор проверяет,
существует ли такое имя y внутри B.
Ну вот он смотрит.
Внутри структуры B такого поля нет.
Может оно есть у наследников.
Компилятор сам себя спрашивает, а могу ли я обращаться к наследникам?
Ну, естественно, в данном случае могу, потому что f друг.
Даже несмотря на то, что я унаследовал A приватным образом,
я могу обращаться к A.
Все, дальше я попадаю в A и смотрю, да, там есть y.
Я захожу в y, но потом понимаю, что y это protected.
То есть сам A запрещает, то есть B разрешает использовать A,
но при этом A запрещает обращаться к своим приватным и protected областям, естественно.
Вот чтобы я мог обращаться к y, мне нужно еще внутри A дополнительно объявить,
то есть сам A еще должен объявить функцию f своим другом.
Все ясно?
В каком случае, например, структура C не может обращаться к A?
Вот здесь A.y?
Нет, нет, естественно, структура C же не унаследована от A.
То есть protected разрешает доступ только к наследникам.
В данном случае C от A не унаследован.
C просто завел поле типа A.
Еще вопросы?
Давайте тогда дальше пойдем.
В конце замечаний, бывает полезно, если класс реализован с помощью другого класса,
которого нет, не статически.
Но это вот про пример из int.
То есть если я хочу унаследовать свойства из int,
то есть если я хочу, чтобы у меня класс дополнительно мог проверять свойства,
является там что-то int или нет, то я могу делать так.
А ваш вопрос подробный в чем стоял еще?
Вот, да, это интересный вопрос.
Слушайте, каждый год возникает такой вопрос, я это постоянно проверяю,
но я могу соврать, но вообще работает так.
Сейчас я поясню вопрос.
Вопрос состоит в следующем.
У меня статическое поле X.
Я структуру A унаследовал в класс B.
То есть теперь у меня как будто бы есть класс A,
у которого есть общий X, как это статический.
И с другой стороны вроде как есть класс B,
который унаследован от A,
соответственно у него тоже есть какой-то статическое поле X.
И вот вопрос, вот это поле X, оно общее для A и B или разное?
И вот насколько я помню, оно все-таки разное.
То есть B и A в этом смысле независимо.
То есть если вы статическое поле меняете у A,
то у B оно не изменится.
Если у кого-то есть нож, можете сейчас проверить и искать.
Это хороший вопрос, но я точно не помню.
Но вообще, как правило, когда мы говорим про статические поля,
они как правило все константные.
То есть когда мы говорим про излинт и так далее,
в случае константных полей, естественно, такого вопроса не возникает.
Но вообще, по-моему, у A и B все-таки разные поля.
Если что, в перерыве я посмотрю, если сейчас никто не проверит.
Так, еще интересные вопросы будут.
Хорошо.
Когда мы говорили про классы и структуры,
то есть я думаю, вы уже привыкли,
что я взаимозаменяемо называю классы структурами, структуры классами.
Потому что с точки зрения теории ООП и структуры класса это то же самое.
Просто у одних все поля открыты, у других все поля закрыты.
Но это можно изменить с помощью public, private и protected слов.
И вот до этого мы говорили, что это единственное отличие классов от структур.
Вот есть, на самом деле, второе и последнее.
То есть отличие классов от структур всего два.
Первое, про то, что мы говорили,
что в классах все по умолчанию приватное, а в структурах все по умолчанию публичное.
И второе отличие связано с наследованием.
То есть для структур, если вы вот тут не пишете никакого слова,
то есть не указываете конкретно, каким образом вы наследуете класс,
то тут ставится public.
То есть по умолчанию вы наследуете публичное.
А если вы пишете класс, то по умолчанию вы наследуете приватное.
То есть по сути то же самое.
То есть правило общее остается.
В классах все приватное, в структурах все публичное.
Если не сказано иное.
Отличие классов от структур всего два, и вот мы все их обсудили.
Больше никаких отличий структур от классов нет.
Они абсолютно взаимозаменяемые.
И формальной, и какой-то синтетической тоже разницы нет.
То есть отличие только в модификаторах доступа по умолчанию.
Хорошо.
Теперь поговорим про основные моменты, которые связаны с наследованием.
Мы поговорили.
Мы теперь можем наследовать один класс от другого,
использовать свойства одного типа в другом типе,
использовать их взаимозаменяемые и так далее.
Ну и теперь давайте поговорим про некоторые технические детали.
В частности, про то, в каком порядке вызывают конструкторы и деструкторы.
И вообще, в принципе, как вызвать деструктор базового класса.
Потому что мы говорили, что если у вас есть класс B,
то у него есть часть, которая относится к A,
и у него могут быть свои поля типа X, Y и Z.
Ну и естественный вопрос возникающий.
Понятное дело, как мне проницилизировать X, Y и Z,
а как мне проницилизировать часть, которая относится к A?
Нужно ли мне все это заново делать вручную или нет?
Ну вот про это, видимо, поговорим после перерыва.
Так, продолжим.
Ну вот перед перерывом я уже задал некоторую задачу,
то есть задал некоторую проблему.
Напомню, давайте более конкретно.
Вот у нас есть класс Stack.
Представьте себе, что я хочу написать класс StackMax и StackMin.
Ну, собственно, классы, которые поддерживают,
ну, помимо того, что являются стэками,
так еще и поддерживают максимум и минимум.
То есть в любой момент времени я могу спросить,
какой у меня сейчас максимум хранится в стэке
и какой у меня сейчас минимум.
Ну, классическая задача, ну, помните, так решается.
Просто мы храним два стэка,
в одном стэке храним текущий максимум,
в другом стэке храним сами значения.
Ну, естественно, чтобы не дублировать код,
я хочу, например, унаследовать StackMax
или Stack публичным образом.
Ну, почему я публичным образом?
Потому что у меня выполняется принцип установки лисков.
То есть у меня StackMax, он, по сути,
сам является по себе stack'ом.
Так как у меня отношение между Stack и StackMax
отношение является,
то это значит я делаю публичное наследование.
Ну и дополнительно в StackMax я завожу
буфер, которым буду хранить текущий максимум.
Вот.
Ну и аналогично завожу класс StackMin.
И вот представь себе, делаю, ну,
делаю следующие вещи.
Значит, здесь, что я делаю?
Здесь я просто беру, говорю, что,
ну, внутри StackMax мне нужен
конструктор копирования.
И я его пишу, ну, следующим образом.
Я говорю, что у меня есть,
я принимаю объект adder
и внутри него как-то инициализирую
Max буфер на основе adder.
Вот.
И есть другой класс,
который я просто объявляю как дефолт.
Вот.
Может кто-то понимает, почему.
То есть, соответственно, тут стоит вопрос,
как StackMax и StackMin будут проинициализированы части,
которые относятся к Stack?
Вот кто как думает?
Вот смотрите, у меня есть,
давайте рассмотрим StackMax.
У меня есть StackMax, я там пытаюсь
реализовать конструктор копирования.
Ну, что делает конструктор?
Конструктор, естественно, нужно
проинициализировать все поля.
Ну, какие поля? То есть, это поля,
это Max буфер.
Вот Max буфер, я вроде как
с ним что-то делаю.
Тут написано, что я выполню какие-то действия.
Как проинициализируется у меня Stack?
И будет ли оно вообще проинициализирован?
Так, вызовет свой конструктор копирование.
А еще какие варианты?
Кто считает, что вообще хоть какой-то конструктор
вызовется?
Кто считает, что никакого конструктора
для Stack вызвано не будет?
Ну, на самом деле, смотрите,
весь прикол конструктора заключается в том,
что они не могут быть
не вызваны.
В общем, если у вас для класса есть конструктор,
то у вас нет никакого другого способа
создать объект, кроме как вызов конструктора.
Поэтому, так как у меня внутри StackMax
есть какой-то поле Stack,
то в любом случае для него хоть какой-то конструктор
обязан быть вызван.
И он произойдет по вашему желанию
или без вашего желания.
Другой вопрос какой?
На самом деле, здесь будет вызван обычный
конструктор по умолчанию.
Stack будет создан по умолчанию, никого копирования
не произойдет. Ну, и это на самом деле согласуется
с тем, что мы обсуждали до этого.
Помните, когда мы обсуждали списки инициализации?
Что мы говорили, когда у нас списка инициализации нет?
Если мы не пишем список инициализации,
то что происходит?
Что происходит, если мы не пишем список инициализации?
Все поля инициализируются по умолчанию.
Если вы не пишете список инициализации,
то все равно надо все проинициализировать,
прежде чем вы войдете в тело конструктора,
вам нужно все проинициализировать.
Я предвидел это.
И, соответственно,
базовые классы тоже, естественно,
нужно проинициализировать.
Точнее, часть, которая относится к базовым классам,
тоже нужно проинициализировать.
А как ее проинициализировать? Тут есть только один вариант
вызвать конструктор по умолчанию.
А что произойдет здесь, если я попытаюсь
сделать дефолт?
Во-первых,
наверное, должно быть понятно,
что
MaxG bin Romania
не будет проинициализирован,
точнее, будет проинициализирован, но бусером.
Неправда, тебе это Lynnd simplified Shamrock сказал.
Как будет проинициализструктор MaxG buf?
Вот у меня есть Stackmin,
в нем есть часть, которая относится к dollar,
и这 часть, которая относится к MaxG buf.
Как будет проинициализовано часть, которая относится к MaxG buf?
Не probability.
Да, она будет просто побитово скопирована.
Дефолт означает, что конструктор копирования должен быть реализован как не побитого, а просто вызван для всего копирования.
То есть, maxboot будет скопирован из другого, то есть из adder.
А как будет проницелизированная часть, которая относится к стеку?
Да, правильно. Вот тут уже будет вызван конструктор копирования.
Тут будет вызвано копирование для этой штуки и копирование для этой штуки.
Но при этом здесь это OK, а здесь это не OK.
А то, что написано сверху, здесь вот такой стек нас не устраивает.
То есть, мы вряд ли хотим создавать копирование стек по дефолту.
А вот здесь нас устраивает. То есть, мы что-то сделали для maxboot.
Понятно проблема?
В первом случае в стек ничего не копируется.
То есть, сама часть, которая относится к стеку, она не будет скопирована, она будет просто создана по умолчанию.
В втором случае стек скопируется, но часть, которая относится к стеку, интеллизируется по умолчанию.
То есть, сам буфер, который должен хранить минимум, будет скопирован неправильно.
Он просто скопируется.
Как решить эту проблему?
Как написать конструктор так, чтобы все было нормально?
Допустим, вы пишете свой конструктор, допустим, для stackmax.
И вы знаете, что stackmax унаследован как-то от стека.
Вот как правильно прониетализировать базовый класс?
На самом деле, все очень просто. Достаточно воспользоваться списком интеллизации.
В списке интеллизации вы через двоеточие просто-напросто указываете, какой конструктор базового класса нужно вызвать.
И вот вся базовая часть, точнее, все поля, которые относятся к базовой части, они будут прониетализированы с помощью вот этого конструктора, который вы здесь указали.
То есть, можно считать в некотором смысле, опять же, как можно думать про наследование.
Про наследование можно думать так, что у вас есть просто какое-то неявное поле.
То есть, раньше у вас были поля явные, вы создавали поля, давали им имена.
И здесь можно сказать, что у вас появилось некоторое безымянное поле, к которому просто можно обращаться через имя класса.
Но в данном случае мы знаем, что stackmax у наследован от стека.
То есть, в нем содержится целый кусок, который относится к стеку.
И есть поле maxBuffer. И вот здесь я, соответственно, инициализирую stack с помощью копирования от adder.
И maxBuffer, соответственно, выделяю там память.
Ну и дальше, собственно, в цикле копирую все, что мне нужно.
Окей?
Во, да, это хороший вопрос.
Предполагается, что у меня в стеке, естественно, есть конструктор копирования.
Как выглядит конструктор копирования в стеке?
Ну, он выглядит таким образом.
const stack по ссылке.
Да, и тут возникает логичный вопрос.
Это ссылка на stackmax.
Но при этом я ее передаю в функцию, которая ожидает ссылку на stack.
Как это работает?
Ну, на самом деле это работает.
Работает это по той причине, что публичное наследование у меня реализует семантику является.
Даже не так. Нет, это неправда.
Не по этой причине.
Это верно, потому что у меня stackmax сам по себе имеет право использовать...
Stackmax имеет право использовать тот факт, что он наследован от stack.
То есть stackmax имеет право использовать тот факт, что внутри stackmax есть часть, которая относится к stack.
И, соответственно, когда у вас происходит такое присваивание, у вас что происходит?
У вас есть stack, у вас есть какая-то часть, которая относится к stackmax.
Это все stackmax.
Когда вы передаете ссылку на такой объект в функцию, которая ожидает ссылку на stack,
то она просто связывается с этим начальным куском.
То есть, грубо говоря, stackmax – это то же самое, что и stack, но что-то еще.
Но когда вы связываете ссылку на производный класс с ссылкой на базовый класс,
то вот это вот что-то еще, оно как бы игнорируется просто-напросто.
Понятно?
То есть мы со stackmaxом можем работать точно так же, как и с обычным stack'ом.
То есть мы stackmax можем передавать во все функции, которые там ожидают stack и так далее.
Нет, естественно, нет.
То есть если у вас есть какая-то функция, которая ожидает на вход stackmax,
то передать ей внутрь stack нельзя.
Это тоже понятно, потому что если вы передаете stackmax туда, где ожидается stack,
то вы как-то подужать до stack'а можете.
А если вы передаете stack там, где ожидается stackmax, то расширить вы не можете.
Точнее, мы об этом поговорим, на самом деле можете, но нужно написать отдельный конструктор.
То есть если вы написали отдельный конструктор,
который позволяет вам из меньшего типа сделать больший тип, то да, так нет.
Этот пример понятен?
Ну то есть мораль такая, если вам нужно как-то особый образом создать базовую часть,
точнее часть, которая относится к базовому классу,
то вы должны вызвать его конструктор и синтаксис такой.
Через твои точки вы в списке индивидуализации пишете,
какой конструктор для базовой класса нужно вызвать,
именно он будет работать, точнее базовую часть создаст он.
Ну да, какой у нас порядок?
То есть мы говорили, что то, что вы написали в списке индивидуализации,
Порядок создания списка инициализации по сути игнорируется.
Порядок создания полей определяется порядком их перечистления,
а не порядком их упоминания в списке инициализации.
В случае с базовыми классами все то же самое.
Как это работает? У вас есть структура B,
у вас есть часть, которая относится к A,
у вас есть класс A, в нем есть X и Y,
все это остальное, все это большое, это B,
и в нем есть дополнительное поле Z.
Значит, инициализируется все по порядку.
Сначала инициализируется все то, что относится к A.
Если ваш класс следует от какого-то другого класса,
то сначала будет инициализироваться базовый класс,
по понятным причинам.
Сначала инициализируется база,
а только потом инициализируется все остальное,
которое относится к B, и при этом строго в том порядке,
в котором все перечислено.
Если у вас тут есть int, то после Z будет инициализирован t.
Теперь давайте посмотрим, каким образом...
Вот у меня есть структура A,
в нем есть два поля X и Y,
и в этой структуре есть два конструктора.
Есть конструктор, который принимает 1 int,
есть конструктор, который принимает 2 int.
Не важно, что они делают,
допустим, предположим, что они просто инициализируют X и Y.
Что у меня произойдет, если я просто-напросто возьму
и попытаюсь создать конструктор по умолчанию B вот таким образом?
Здесь у меня произойдет ошибка эмпиляции.
Понятно, почему?
Кто понимает, почему в такой строке у меня будет ошибка эмпиляции?
А почему тут вызывается конструктор по умолчанию?
Я же его не вызываю.
Здесь я пытался написать конструктор по умолчанию,
который ничего не принимает
и который, по сути, ничего не делает.
На самом деле мы знаем,
что сейчас какая-то инициализация должна происходить.
В частности, я еще раз повторяю,
что если вы написали списки инициализации,
они в любом случае выполняются.
В данном случае компилятор просто попытался все проинциализировать по умолчанию.
То есть сначала он попытался проинциализировать базу A,
то есть базовый класс A, по умолчанию.
Но у класса A конструктор по умолчанию нет.
И вот, собственно, в этот же момент, в самый первый момент он зафейлился.
Что происходит далее?
Дальше я пишу конструктор, который принимает один int.
Он принимает один int и далее перенаправляет его в конструктор A.
То есть в итоге что у меня происходит?
У меня класс A, точнее часть класса B, которая относится к A,
проинциализирована одним int,
а Z проинциализирован нулем,
потому что у меня написано это здесь.
Можно вопрос?
Да.
А если бы у нас не было ни одного конструктора по умолчанию,
то для вас это будет сначала строить свободу на самwife local?
Да.
По правилам создание конструктора.
Если у вас в классе нет ни одного конструктора,
то комператор за вас создает конструктор по умолчанию.
То есть если внутри структура они написали неодного конструктора,
то это на самом деле значит, что у вас в структуре A есть конструктор
и конструктор по умолчанию.
Вот.
Ну то же самое для конструктора с двумя аргументами.
То есть у меня B принимает X, Y.
И я их могу спокойно перенаправить в A.
Ну и третий пример.
У меня конструктор B может принимать три аргумента,
и тогда первые два аргумента я передаю to.
А последним аргументом инестализирую set.
Вот, соответственно, пример, как использовать конструктор базового класса.
В данном случае я использовал конструктор, который принимает один аргумент,
и конструктор, который принимает два аргумента.
В зависимости от ситуации я пользуюсь тем или иным конструктором.
Теперь у меня вопрос к вам. А есть ли что-то, что вас, так скажем, смущает в этих примерах?
Не кажется ли, например, вам, что вот эти два конструктора, они в некотором смысле, если код не дублируют, то по крайней мере его как-то сильно увеличивают?
Что я по сути тут говорю? Я по сути говорю то, что класс B я могу создать точно так же, как и класс A. То есть я могу создать его с помощью одного аргумента, могу создать его с помощью двух аргументов.
И все, что я делаю, это я просто перенаправляю эти аргументы к конструктору A. Согласитесь как-то накладно.
Представьте, что у меня в конструкторе A есть какой-то большой список конструкторов, который принимает один аргумент, два, три, четыре и так далее.
И я хочу, чтобы наследник я мог создавать точно таким же образом. То есть передавать один, два, три и так далее аргументов.
Но тогда мне просто придется все вот эти конструкторы продублировать. Проблема.
Чтобы такой проблемы избежать, если вы хотите сказать, что в классе наследники можно использовать те же самые конструкторы, что и в A, вам достаточно писать следующую конструкцию.
Using A 2.2.A. То есть это просто нам означает, что у меня класс B использует те же самые конструкторы, что и A.
То есть в данном случае у меня структура B может принимать те же самые аргументы конструктора, что и A, и при этом все эти параметры будут автоматически перенаправлены в класс A.
Ну если вам нужен конструктор от трех аргументов, то тут уже ничего не поделаешь.
А нет конструктора от трех аргументов, поэтому здесь мы принимаем три аргумента, первые два передаем в A, остальные оставляем в B.
Нет, с деструктурами мы отдельно поговорим, но с деструктурами все гораздо проще, с деструктурами все нормально.
Деструкторы базовых классов тоже вызываются автоматически, но так как деструктор не имеет аргументов, то там такой проблемы в принципе не возникает.
Еще важный момент. Вы не можете проинициализировать базовый класс частично.
То есть вы инициализируете базовый класс либо полностью, либо полностью, в общем других вариантов нет.
То есть вы не можете сказать, что у меня есть конструктор B, который принимает три аргумента, x, y и z.
И отдельно проинициализировать x, отдельно проинициализировать y, и отдельно проинициализировать z.
Х и y это не независимые сущности. Х и y они приходят вам в пакет.
Т.е. х и y они приходят вместе, вместе с классом А. Они неразрывно с классом A связаны, поэтому отдельно их проинициализировать вы не можете.
только класс A целиком, соответственно, вот эта штука не работает.
То есть единственный возможный способ проницилизировать поля базового класса
это явно вызвать конструктор базового класса. По отдельности поля инициализировать нельзя.
Пример ясен? Хорошо.
Ну и про деструктор. С деструктором всё на самом деле очень просто.
Всё то же самое, про что мы говорили ранее. Если у меня есть класс B, у него есть поля X, Y, Z и T,
если они создаются в прямом порядке, то уничтожаются они в обратном порядке.
Ну и то же самое касается базовых классов. У вас B в данном примере выглядит на самом деле следующим образом.
У вас есть B, в нём находится какая-то часть, которая относится к A, и есть S1 и S2.
Когда у вас вызывается конструктор для B, сначала создаётся A, а потом создаются S1 и S2.
А когда у вас вызывается деструктор, то у вас автоматически вызывается деструктор для S2,
вызывается деструктор для S1 и автоматически вызывается деструктор для базового класса.
То есть, если вы написали деструкт어를 для базового класса, то дублировать его в наследники не нужно.
не нужно. В этом и кайф конструкторов и деструкторов. Он состоит в том, что где бы не
находился этот объект, то есть как наследованная часть или там как часть
какой-то функции, у вас всегда в начале жизни этого объекта будет вызываться
конструктор, а в позвершении будет вызываться деструктор.
Мораль понятна?
Ну и поговорим про срезку. Привет, последний пункт. Это про что?
Это как раз про то, что мы сейчас на самом деле вот все это время до этого
говорили про такое поставить наследование, как отсутствие дублирования кода.
То есть по большому счету мы почти никак не использовали родство между классами,
мы просто говорили, что а у наследовали от а, и теперь у меня внутри
б находятся те же самые поля и меды, которые находятся и в а. То есть просто
избавился себя от дублирования кода. Ну и деструктор у меня тоже для базового
класса вызывается автоматически. Воззывать там ничего не нужно, тоже избавилось
от дублирования кода. Конструкторы тоже автоматически, мне писать не нужно, все они
могут быть унаследованы. А теперь давайте поговорим про второй пункт, который мы
задавали в самом начале. Это про использование информации о том, что
что какие-то классы являются родственниками друг к другу. И вот первый пункт – это срезка.
Смотрите, у меня есть структура A, есть структура B, которая публичным образом наследована от A.
Еще раз повторюсь, что публичное наследование, оно, по сути, говорит о том, что B является A.
Ну, естественно, не наоборот. То есть если стол является мебелью, то не любая мебель является столом.
Ну и, соответственно, что это означает? Что нам дает на практике, вот это вот отношение является.
Дает нам следующее. Я теперь могу создавать объекты типа B, во второй строке.
Я могу выставлять объекты типа B и присваивать их объектам типа A.
Ну и то же самое в третьей строке. Почему это работает?
Ну, ровно потому, что B является A. Если B является A, то во всех контекстах,
где у меня ожидается тип A, я могу подставлять и тип B.
То есть везде, куда я могу подставить A, я могу подставить и B, потому что B является A.
И что? Ну, наоборот, естественно, неверно.
Это логично, что я не могу проинтересовать объект типа B, а объектом типа A,
потому что A это более узкий объект, чем B. B более широкий.
Что здесь происходит? Что такое срезка? Что здесь происходит с логической точки зрения?
Здесь на самом деле создается отдельный объект A.
То есть у вас есть какой-то объект B, и вы хотите с помощью него создать объект A.
И в этом случае происходит, так скажем, копирование.
Копирование части, которая относится к A в объект, который вы что-то присваиваете.
То есть просто часть, которая относится к A, она копируется в другую часть.
Ну, либо с помощью конструктора копирования, если такой в классе A задан, либо просто-напросто побитого.
Вот эта штука называется срезкой.
То есть у вас был какой-то исходный большой объект, и вы его обрезали до более узкого, который потребовался.
То есть создалась отдельная копия, копия объекта базового класса,
но при этом которая создана с помощью объекта производного класса.
Есть вопросы по этому? Что происходит? Все понятно?
Да, соответственно данная возможность называется срезкой.
При присваивании используется только часть класса, относящаяся к базовому классу.
Соответственно здесь в правой части стоит объект типа B, в левой части стоит объект типа A.
Ну и соответственно в объект типа A копируется только часть, которая относится к A.
Наоборот, естественно нельзя, потому что непонятно, как пронизируются элементы B, которых нет в A.
Ну и при срезке будут использованы именно копирующий или перемещающий конструктор, если они есть.
То есть в данном случае будет вызван вот здесь конструктор копирования A.
Почему он может быть корректно вызван? Мы уже говорили, да?
Потому что в объекте типа B есть целый кусок, который относится к A.
И вот соответственно когда я создаю ссылку или константную ссылку вот на этот объект,
у меня ссылка она ссылается только вот на эту часть.
То есть все остальное игнорируется.
На самом деле то же самое, на самом деле срезка может быть использована и при приватном и протекторном следовании.
Но единственное отличие, посмотрите, почему срезка у меня была возможна здесь?
Потому что внешний код имеет право знать о том, что я унаследован от A, точнее B унаследовано от A.
То есть внешний код имеет право знать о том, что A унаследовано от B, B унаследовано от A,
и поэтому я объектом типа A могу присваивать объект типа B.
Если я использую протектор для приватного наследования, естественно я так делать не могу.
Если я здесь заменю public на private, например, то вот этот код перестанет работать по понятным причинам.
То есть я теперь не могу использовать тот факт, что у меня B является A.
То есть я вместо B могу подставлять A.
Но при этом внутри класса B я по-прежнему могу использовать срезку.
Почему? Потому что если я унаследовался от A, если я унаследовался от A протектор образом,
то это говорит о том, что я внешнему коду запретил использовать информацию о том, что я унаследован от A.
Но при этом внутри структуры B или внутри класса B эту информацию я могу спокойно использовать.
Поэтому здесь срезка внутри работает.
Если я попробую то же самое сделать снаружи класса, то уже будет ошибка эмпиляции.
Соответственно, внутри класса наследник я так могу делать.
Ну и понятно делать, что если у меня есть какие-то друзья, то внутри друзей я тоже могу использовать факт наследования.
Ну и теперь еще один пример.
Что если мне не нравится, как мне работает срезка?
Что если я хочу, чтобы у меня вот такая штука работала, но при этом я хочу, чтобы у меня копировалась не просто часть, которая относится к, а выполняют какие-то другие действия?
Ну вот есть такое желание.
То есть я хочу, чтобы у меня не тупо происходило копирование, а писала какая-то дополнительная информация на выход или что-то еще.
Ну вот здесь такой пример.
Ну смотрите, у меня есть поле name в классе A.
И естественно, если я наследую B от A, то у меня в классе B тоже есть поле name.
Но при этом я в классе A говорю, что name у меня равен A, потому что имя класса A это A.
А в классе B говорю, что имя B это B.
Нормально? Ну, кажется, нормально.
Ну и теперь, когда я создаю объект типа A, у меня A.name выдает A.
Если я создаю объект типа B, то B.name выдает B.
Но теперь, если я попытаюсь создать объект типа A с помощью объекта типа B, то у меня произойдет срезка.
То есть произойдет копирование, как здесь это выглядит.
У меня есть класс B, в нем есть часть, которая относится к A, и в нем есть поле name.
И есть просто класс A.
Как происходит срезка? Ну просто вот эта часть берет и копируется вот сюда.
Соответственно, в классе B у меня хранится информация о том, что имя это B.
Когда я делаю срезку, то есть когда я копирую в A, у меня это имя тоже напросто целиком копируется.
Понятно?
Ну и теперь у меня класс A говорит, что у него имя это B.
Но, наверное, хотелось бы, чтобы и в этом случае тоже класс A не отказывался от своей идентичности и тоже говорил, что у него имя это A.
Как этого добиться? Ну очень просто.
Вам достаточно просто взять и сказать, что вам достаточно просто создать конструктор от наследника.
То есть вы в структуре A говорите, что вот если я пытаюсь создаться от наследника, в данном случае от класса B,
то у меня должно быть какое-то особое поведение.
Ну, например, в частности, я тут должен написать, что у меня name это A.
Все, и теперь, когда я вызываю срезку, то есть когда я пытаюсь объект типа A создать с помощью объекта типа B,
у меня вызывается не конструктор копирования.
Смотрите, в чем идея.
Теперь у меня внутри класса A есть конструктор копирования, естественным образом.
const A&.
И есть конструктор, который принимает B. A const B&.
То есть раньше, когда у меня вот этого конструктора не было, у меня вызывался верхний конструктор, то есть просто конструктор копирования A. Понятно?
Но теперь, когда я создал конструктор от наследника, то есть специальный конструктор, который принимает B, именно он будет выигрывать перегрузку.
И вот теперь вот в этой строке, когда я попытаюсь выполнить срезку, то есть создать объект типа A с помощью объекта типа B,
у меня будет вызываться именно вот этот конструктор.
Соответственно, имя объекта A будет A, собственно, как я указывал в этом конструкторе.
Все ясно?
Да, ну и соответственно, аналогичным образом вы можете запретить срезку.
Допустим, вам не нравится, что у вас происходят вот такие вот вещи, что у вас объекты производного класса могут приводиться к объектам базового класса.
Ну, вообще говоря, непонятно, зачем вам это нужно, то есть если вы хотите это запретить, то просто используйте Protect или править наследование.
Ну, допустим, вы хотите вот именно такое запретить, то есть именно создавать копии базового класса на основе производного вы не хотите.
Но в этом случае вы тоже создаете там вот этот вот конструктор, который принимает объект типа B и пишете равно delete.
Обычный трюк с удалением перегрузки функции.
Так, еще один интересный пункт связан с затенением или замещением методов базового класса.
В чем идея?
Смотрите, есть класс A. Этот класс я унаследовал в классе B.
И представьте себе, что у меня внутри структуры A или внутри класса A есть метод F, который принимает int.
Ну и внутри класса B я тоже создал метод F, который принимает int.
Соответственно, тот метод, который объявлен в базовом классе, печатает, что вызван метод A, а внутри класса B печатает, что вызван метод B.
Теперь, если я создам объект типа B и попытаюсь вызвать B.F, то конфликта не будет. Это нормальная ситуация.
То есть наследники вполне себе могут переопределать методы базового класса. Ну в данном случае это не переопределение, а замещение.
То есть методы производного класса могут замещать метод базового класса.
Все это нормально.
Ну вот вопрос. Вроде, как тогда мы говорили про наследование, мы говорили следующую вещь.
Если я что-то унаследовал от базового класса, то все это и все методы, все поля находятся в моем классе.
что на самом деле внутри класса B вот этот метод тоже есть. Тоже там присутствует. Точнее компилятор понимает, что через класс B вот этот метод, который находится в A, тоже могу вызывать.
Вопрос, как его вызвать? Ответ убил. Вот таким образом. То есть мне нужно использовать так называемое qualified ID или полное квалифицированное имя метода.
То есть я пишу B. и дальше пишу, что мне нужен именно тот F, который находится в A и никакой иной. И вот теперь, если вызываю просто B.F, то вызывается F, который находится внутри B.
Не, вот модификаторы доступа и перегрузка это вообще разные вещи. То есть модификаторы доступа и перегрузки не имеют никакого отношения.
То есть если вы тут написали private, то при вызове первой строки у вас бы все равно вызывался метод B. Но так его вызвать нельзя, то у вас бы тут была ошибка в компиляции.
То есть приватность публичность на перегрузку никак не влияет. То есть теперь, когда вы просто вызываете через точку F, то у вас вызывается тот метод, который находится в B.
Потому что этот метод заместил метод, который находится в базовом классе. Но это более-менее кажется естественным, потому что если вы в производном классе как-то указали какое-то другое поведение, то наверное нужно использовать его более конкретное.
Но если вы все-таки хотите использовать метод, который находится в базовом классе, то придется помучиться и использовать прям полное имя. То есть сказать B. и дальше то, что находится в классе A, и вызвать метод F.
Второй пример, более странный. Если тут было более-менее все логично, то смотрите, у меня в базовом классе есть F от int, в производном классе есть F от int, ну и если я вызываю F от int, то вызывается метод производного класса.
Просто произошло замещение, кажется все нормально. Странный пример вот такой. Есть у меня класс A, в нем есть метод F, который не принимает аргументов.
Не принимает аргументов. Есть класс B, который унаследован от A и имеет свой метод F, который принимает один аргумент.
Казалось бы, конфликта вообще никого нет. То есть есть метод F, не принимает аргументов, есть метод F, но он принимает аргументы.
Но при этом возникает странная ситуация. Если я попытаюсь вызвать метод F от 0, то все нормально. В классе B действительно есть такой метод, все хорошо.
А если я попытаюсь вызвать метод B.F, то возникнет внезапно какой-то ошибка компиляции.
И мне компилятор скажет, что внутри класса B нет метода F. Что произошло?
Мы же буквально, если отмотать все слайды в самое начало, мы же спокойно вызывали методы базовых классов, они все работали и так далее.
А здесь все перестало работать. Почему?
Потому что по правилам C++ замещение работает довольно странным образом.
Считается, что когда вы объявляете метод с каким-то именем, то все остальные методы с таким же именем в базовом классе не просто-напросто вымещаются.
Если у вас есть в классе A F с пустыми скобками, F от NTA, F от Boolean, а в классе B есть только метод F от NTA, то считается, что все эти методы полностью замещаются вот этим методом.
Что?
Да, похоже на конструкторы.
Тем не менее, не совсем.
Неважно, написали вы в базовом классе конструктор или нет, у вас все равно конструкторы базовых классов не вызываются просто так. Вам нужно писать using и так далее.
А здесь у вас такая проблема возникает, если вы написали внутри B функцию с тем же именем, что и в базовом классе.
Это можно обосновать примерно следующим образом.
Если вы в классе B задали какое-то действие F, то, наверное, вы хотите, чтобы для производного класса выполнялось только это действие, и никаких других.
Скажем, для класса A можно выполнять действие F без аргументов, можно выполнять с одним аргументом, можно выполнять с другим аргументом.
А если вы для производного класса задали такое же действие, но с каким-то другим аргументом, то разработчики языка предполагают, что вы хотите использовать только это действие, никаких других.
Проблема ясна? Хорошо.
Как ее побороть? Проблема называется shadowing, затенение методов.
Если вы ввели какой-то метод с таким же именем, что и в базовом классе, то все методы, которые есть в базовом классе, они игнорируются.
Логично ли это? Я сам проговорил. С одной стороны кажется, что это какая-то ерунда, с другой стороны, наверное, какая-то логика в этом все-таки есть.
Но при этом вы по-прежнему можете вызывать методы A, даже если они затенены, вы их можете вызывать с помощью полного квалифицированного имени.
Как бороться с этой проблемой? Есть несколько вариантов. Первый вариант – просто нам смириться и ничего с этим не делать.
Есть второй вариант – заставлять пользователя всегда вызывать полное имя метода.
Если какие-то методы затенены, то вызывайте его через полное имя.
Есть третий вариант. Если вы все-таки хотите, чтобы методы вышли из сумрака, вы можете использовать директиву using.
В данном случае это работает так. У меня в структуре A есть метод f, который принимает ничего, есть метод f, который принимает double,
и внутри B у меня есть метод, который принимает int. Этот метод затеняет все остальные, то есть все остальные просто так вызваны не будут.
Но если вы написали директиву using, using a.f, то это говорит о том, что все методы, которые есть внутри класса A, должны быть включены и в класс B, то есть они не должны быть затенены.
Да, была бы CE. То есть вы пытаетесь в класс B внести функцию с такой же сигнатурой, что и в B.
Вопрос был в том, что если тут f от int, то тут было бы CE. Если у вас есть функция f с таким же прототипом, то это не работает.
Важный момент, что по отдельности функции вносить нельзя. То есть вы вносите либо все, либо вообще никакие.
Вот. Не получится.
Что еще раз? А, ну а тут, кстати, имеет значение, где писать using, то есть в публичной или приватной области.
То есть если вы хотите, чтобы эти затененные методы стали публичными, вы их пишете в публичной области. Если нет, то в приватной.
Нет, нет, нет. Тут такое правило действует. То есть когда вы написали вот так, вы просто говорите, что класс B может использовать...
Ну, кстати, по поводу правила public, может я наврал. То есть я не уверен. Короче говоря, приватные поля таким образом публичными стать не могут.
То есть вы просто говорите, что... таким образом вы просто говорите, что вы избавляетесь от, как это называется, от недопонимания.
То есть вы просто говорите, что если какой-то метод затенен, то нужно еще принимать во внимание методы, которые объявлены в A, и все.
Поэтому тут спокойно вы можете вызвать f от нуля, f с пустыми скопами, f от добла. Все нормально.
Так, есть вопросы? Все, давайте последний пункт. Работа с производным классом через указатель или ссылку на базу.
Ну, это мы частично уже проговорили. Давайте еще раз уже конкретно проговорим, что если у вас есть класс B, который наследован от A публичным образом,
то теперь вы помимо того, что можете осуществлять срезку, так еще и можете создавать указатели или ссылки на базовый класс, но при этом связываться с производным классом.
То есть в данном случае у меня есть объект типа B, и я могу создать указатель, который является... тип которого это указатель на A, но при этом на самом деле он будет указывать на B.
То есть почему это возможно? Ну, снова, надо вспоминать вот такую картинку. У меня есть класс B, у меня есть часть, которая относится к A. Вот, есть что-то еще.
И у меня класс A, точнее часть, которая находится к классу A, находится в самом начале объекта типа B.
И поэтому если я создаю указатель, точнее беру адрес B, то на самом деле вот этот указатель он будет указывать как на начало B, так и начало A внутри класса B.
То же самое касается и ссылок. То есть я могу спокойно оставать ссылку на базовый класс и при этом связывать ее с производным классом.
Наоборот, естественно, нельзя... вот такое запрещено. Естественно, я не могу указывать на производный класс, но при этом притворяться, что я на самом деле указываю на базовый класс.
В чем отличие срезки и указателей и ссылок? В случае срезки мы получаем, когда мы делаем срезку, мы получаем полностью независимую копию того же самого объекта,
точнее той части объекта, которая находится в классе B. То есть мы на самом деле создаем объект типа A, ну и просто копируем часть, которая относится к A из класса B.
Когда мы работаем через указатели или ссылку, то мы получаем полностью независимую копию того же самого объекта, точнее той части объекта, которая находится в классе B.
Когда мы работаем через указатели или ссылку, ну вот здесь, прямо через ссылку, то есть мы создаем ссылку на A, но при этом инициализируем ее ссылкой на B.
Здесь мы на самом деле работаем именно с объектом типа B.
То есть вот у меня снова есть объект B, есть часть, которая относится к A, и я создаю ссылку как будто бы вот на эту часть.
Вот эта ссылка ссылается вот именно на эту область. И когда я работаю через эту ссылку, я на самом деле работаю вот с конкретной внутренней частью объекта B.
Никакой копии у меня не создается. Понятно?
Окей. Ну и, соответственно, вопрос такой, смотрите.
Точнее не вопрос, а замечание просто такое, что несмотря на то, что у меня есть указатель, точнее ссылка на класс B, я через эту ссылку не могу обращаться к полям или методам производного класса.
То есть, смотрите, у меня есть ссылка BREF. Давайте ее назовем BREF.
Вот в данном примере у меня есть ссылка BREF, которую я проинициализировал объектом B.
Но при этом еще раз повторю, что я на самом деле ссылаюсь только на какую-то часть объекта B, то есть вот на конкретную внутреннюю часть.
И поэтому естественным образом обращаться к полям самого класса B, но вот сейчас вот тут играет, вот к этому полю, через вот эту ссылку я обращаться не могу.
И дело даже не в том, что я ссылаюсь в какую-то маленькую область памяти. Тут проблема на самом деле в том, что компилятор этого сам никак не может проверить.
Но представьте себе, что компилятор встречает вот эту строку. BREF.Y. Какой тип у BREF? У BREF тип ссылка на A.
А какие методы и поля я могу вызывать у A? Все они перечислены вот здесь. Никакого Y там нет. Поэтому к нему я обращаться, естественно, не могу.
Понятно? Несмотря на то, что я могу создавать ссылки на базовый класс и инициализировать их производным классом,
использовать поля и методы производного класса я таким образом никак не могу. Потому что это проверяется все на этапе компиляции.
На этапе компиляции компилятор видит, что это ссылка на базовый класс, и поэтому я могу обращаться только к полям и методам базового класса.
То есть только к вот этой части. Все понятно?
Ну и последний пример. Такая небольшая затравка на следующую неделю, на следующую лекцию.
В общем, смотрите. Представьте себе, что у меня и в структуре A, и в структуре B есть метод F.
То есть в структуре A я объявляю метод F каким-то таким образом, то есть он просто уводит A.F.
А внутри структура B я объявляю точно такой же метод, который уводит B.F.
И при этом я создаю объект типа B и создаю указатель на A, но на самом деле он указывает на объект типа B.
И через стрелку вызываю B.F. Вот в этом случае у меня тоже будет вызываться метод, который относится к A.
И никаких проблем с затенением и так далее не будет. Понятно почему?
Ну снова, что здесь происходит? Давайте отдельно рассмотрим вот эту строку. Bptr, стрелка F.
Компилятор чисто формально смотрит на следующую вещь. Какой тип имеет Bptr?
Bptr имеет тип A со звездой. То есть для компилятора этот указатель указывает на A.
Ну все, и дальше он вызывается через стрелку F.
Есть ли у меня метод F в классе A? Смотрит. Да, он есть.
Ну и соответственно именно этот метод и вызывается. Понятно?
Ну вот на самом деле такого поведения хочется не всегда.
Ну все-таки, наверное, хотелось бы делать следующую вещь.
Что если у вас есть указатель A со звездой, который указывает на самом деле на объект типа B,
возможно хотелось бы, чтобы метод F вызывался именно на объекта типа B, а не типа A.
Ну естественное желание. Ну я же на самом деле указываю на B, а не на A.
Поэтому, наверное, хочется вызывать метод именно для B.
И вот именно этим мы займемся на следующей неделе.
А пока вот проблема, которую мы подвесили в воздухе.
Хорошо? В следующий раз мы с этим разберемся.
Ну и соответственно на этом первая часть пронаследования подошла к концу.
Соответственно, да, мы поговорили, что наследование позволяет задавать связь между классами
и способствует постороннему использованию кода, то есть мы избавляемся от дублирования кода.
Значит, паблик реализует отношения, является, проекты и private содержат.
Имена в производном классе могут затенять соответствующие имена в базовом классе.
Ну это затенение, которое мы говорили, что если вы заводите метод с таким же именем,
что и в базовом классе, то у вас методы базового класса могут быть вызваны с трудом.
Вот. Значит, поговорили про срезку, ну и поговорили про то,
как работать с производными классами через ссылку или указатель на базовый класс.
Ну пока правило очень простое. Если у вас есть ссылка или указатель на базовый класс,
который на самом деле указывает или ссылается на производный класс,
то вы имеете право вызывать только методы и поля базового класса.
Производного класса вам недоступны.
Но в следующий раз мы попробуем немного побороть эту проблему и попробуем понять,
как через ссылку или указатель вызывать именно методы того класса, который там лежит.
Так, на этом наследование все.
И предлагаю перейти к первой лекции по алгоритмам,
а именно вычислительной геометрии на плоскости.
Ну почему именно она?
Потому что, во-первых, тут существует довольно естественная, скажем,
естественная связь с наследованием, и вы ее прочувствуете, когда будете решать второе здание.
В общем, там вполне естественно возникает некоторая иерархия фигур.
То есть можно создавать базовый класс фигуры и от него наследовать другие и так далее.
Но во-вторых, довольно часто в приложениях возникают всякие задачи,
которые связаны с геометрией, причем это даже не связано с какой-то компьютерной графикой и так далее.
Но довольно часто вам приходится моделировать какие-то пространственные объекты,
и было бы неплохо научиться этим всем пользоваться.
Естественно, можно использовать аналитический аппарат, который вы наверняка проходите
на курсе линейной алгебры или аналитической геометрии.
Но проблема в том, что этот аппарат, который вы используете, он использует, скажем,
действительные числа, то есть некоторую непрерывность.
А в компьютерах у нас все представляется все-таки в виде некоторых дискретных структур и так далее.
Но в частности, нельзя точно задать длину окружности.
То есть у вас все равно, если вы хотите, например, определить, пересекаются две прямые или нет,
то в зависимости от того, насколько точную арифметику вы используете,
насколько у вас велика погрешность или нет, у вас могут получиться абсолютно два разных ответа,
причем для параллельных прямых.
Погрешность, она им играет роль, например, в частности определения пересекаются две прямые или нет.
То есть они могут лежать под таким небольшим углом,
что, скажем, точность компьютера может не позволить это сделать.
Поэтому будем рассматривать так называемую точную арифметику,
а именно попробуем понять, какие алгоритмы существуют в ситуации,
когда все точки у нас задаются целочислыми координатами.
Вот оказывается, если у вас есть, оказывается, что если вы работаете с геометрией,
в которой все точки, там, точки, вершины, вершины многоугольников,
концы, отрезков и так далее, представляют у себя целые числа,
то в этом случае оказывается, что возможно построить точные алгоритмы,
которые со 100% точки стоят вам ответ, пересекаются прямые или нет, пересекаются отрезки или нет.
И вот давайте про них поговорим.
Простые примитивы, которые будем использовать, это примитив-точка,
которая будет представлять у себя координаты целочисленные.
Ну и второй примитив, это естественный вектор,
который тоже представляет у себя набор из двух целочисленных координат.
Ну, соответственно, вот таким образом.
Ну и здесь надо вспомнить немного фактов про вектора, которые нам понадобятся.
Ну вот, в частности, давайте введем понятие ориентированного угла
между векторами A и B.
Ну, ориентированным углом между векторами A и B называется угол,
величина которого совпадает, собственно, с величиной угла, образованной этими двумя векторами.
И мы считаем, что phi положителен, если поворот от A к B осуществляется
против часовой стрелки и отрицательным, если по часовой.
То есть, в данном случае у меня есть вектор,
то есть в данном случае у меня величина угла между A и B больше нуля,
а величина угла между A и B, ой, наоборот, между B и A меньше нуля.
То есть, есть разница, угол между каким, то есть,
играет роль порядок векторов, когда я ее считаю, вычисляю угол, то есть A к B или B к A.
Ну, для чего нужны ориентированные углы, чем они помогают, почему нельзя просто использовать модуль и так далее.
Ну, во-первых, в большинстве приложений, как мы увидим, нам будет важно, по какую сторону, например,
от вектора A находится вектор B или, наоборот, от вектора A относительно вектора B и так далее.
Ну, во-вторых, в качестве небольшого применения давайте я расскажу вот такую штуку.
Вот представьте себе, что вам даны какие-то произвольные три вектора A, B, C.
И вам даны величины углов между A и B, и B и C.
Вопрос, как найти величину угла между векторами A и C?
Ну, вообще говоря, если бы мы не использовали понятие ориентированного угла,
то тут бы нужно было рассматривать кучу вариантов.
То есть, как у меня расположены вектора A, B, C между собой?
Возможно, такая ситуация. Тогда мне нужно просто-напросто A, B и C сложить.
Возможно, такая ситуация.
Тогда что мне надо было сделать?
Мне нужно было взять вектор A, B и вычесть из него вектор C, B и так далее.
Вот рассматривать в случае мне очень не хочется.
Вот в этом смысле мне очень помогают ориентированные углы.
Потому что в случае использования ориентированных углов
мне достаточно написать следующую вещь.
Угол между A и C – это просто угол между A и B плюс угол B и C.
Ну, почему это так?
Ну, потому что... Снова давайте...
Вот тут A, C, B.
Если я хочу найти угол между A и C, вот такой, то что у меня получается?
Я смотрю, какой у меня угол между A и B. Вот он.
И потом прибавляю угол B и C. Вот он.
Так у меня углы ориентированы, то есть вот этот угол будет идти с отрицательным знаком,
а этот угол – с положительным знаком,
то в итоге я получу величину угла между A и C, при этом тоже со знаком.
Тоже он будет отрицательным.
Единственный момент, который тут не учитывается этим сложением,
что на самом деле у вас может быть такая ситуация,
углы могут быть достаточно большими.
Скажем, угол A, B может быть таким,
и угол между B и C тоже может быть достаточно большим.
В этом случае, когда вы складываете большие углы,
у вас происходит такой вот, грубо говоря, переход через угол π,
поэтому тут дополнительно еще нужно добавить плюс-минус 2π.
Ну, в зависимости от того, пересекли ли вы черту в π или минус π.
Окей? Вот это первое применение.
Теперь давайте вспомним про такие вещи, как скалярные векторные произведения.
Коротко. Надеюсь, все помнят.
Все помнят вот такую вещь.
Значит, для чего нам будет интересно скалярное произведение?
Скалярное произведение, как правило, позволяет узнать...
Здесь, во-первых, мы видим, что с ориентированным углом все нормально.
То есть неважно, вы считаете в положительном направлении, в витератлом направлении,
у нас с Косинус функция четная, поэтому Косинус у вас всегда будет нормально.
Ну, значит, Косинус, как правило, используется для выяснения,
находятся ли, так скажем, концы векторов A и B
в одной полуплоскости относительно некоторой пербитикулярной или нет.
В данном случае у вас скалярное произведение меньше нуля.
Понятно?
В случае, если они у вас...
Давайте условно будем говорить, что если они сонаправлены,
то есть грубо говоря, смотрят в одну и ту же плоскость относительно некоторой прямой,
то будем говорить, что скалярное произведение положительное.
Но это просто следует и свойств.
И причем, заметьте, сразу же замечаю, что у нас координаты все целочисленные,
то и скалярное произведение тоже вычисляется абсолютно точно.
Скалярное произведение двух векторов,
которые имеют целочислые координаты,
Поэтому скалярное произведение мы можем высчитать абсолютно точно.
Ну и еще одно произведение, это векторное произведение A и B.
Ну вот смотрите, как мы знаем, векторное произведение двух векторов это что?
Это тоже вектор, причем который лежит в каком-то дополнительном измерении.
То есть на плоскости этот результат произведения двух векторов не укладывается.
Поэтому будем говорить, что нас будет интересовать не именно векторное произведение,
а его проекция на некоторую мнимую ось Z, которая у нас не явно присутствует.
Ну грубо говоря, просто будем интересоваться величиной этого самого векторного произведения,
ну или проекции на ось Z.
Начну, напомню, способ вычисления.
Вот, если мы возьмем проекцию на ось Z, то мы получим следующую величину.
AX BY минус AY BX.
Снова, векторное произведение это тоже целое число.
Мы все вычисляем, то есть у нас все координаты целые,
и векторное произведение, ровно как и скалярное произведение, у нас представляет в себе целое число.
Ну, актернативно, запись представляет в себе следующую вещь.
Модуль A, модуль B на синус phi.
И вот отсюда уже на самом деле видно применение векторного произведения.
Смотрите, мы говорили про ориентированный угол.
И вот я уже подрисовала, в каком порядке у нас следующие два вектора.
Либо от а к b, либо от b к a.
В одном случае у нас угол положительный, в другом – отрицательный.
И вот здесь мы можем спокойно проверить,
какой угол между двумя векторами у нас есть, положительный или отрицательный.
В случае, если угол между векторами a и bi положительный, то векторное произведение больше 0.
Если угол отрицательный, то, естественно,
Поэтому основное применение вектором произведения это как раз-таки понять величину угла, то есть положительная или отрицательная.
Грубо говоря, правый поворот вас образует, а вас образуют эти два вектора, или отрицательный поворот, то есть левый поворот.
Окей?
Так, ну давайте, значит, сложение ориентированных углов, это у нас была первая задача.
Ну и давайте перейдем ко второй задаче, которую можно решать абсолютно точно.
Значит, внезапно эта задача – поиск площади двухугольника.
Значит, давайте завязываем следующую вещь, точнее, ведем такое понятие, как ориентированная площадь.
Значит, ориентированная площадь параллелограмма.
Значит, пусть у меня есть два вектора, ну я дострою на этих сторонах, то есть я буду использовать эти векторы как стороны для некоторого параллелограмма.
Видно, что ориентированную площадь параллелограмма можно вычислить просто как векторное произведение векторов A и B.
Ну, собственно, это и есть определение, что параллелограмм, построенный на векторах A и B, его ориентированную площадью будем называть величину векторного произведения.
То есть, грубо говоря, если у меня вектор A и вектор B будут образовывать правый поворот, то величина площади положительна.
Если левый поворот, то величина площади отрицательна.
Как нам поможет при вычислении площади произвольного многоугольника?
Ну, смотрите, идея такая. На самом деле, идея очень похожа на вычисление угла между двумя векторами.
Пусть мне дан абсолютно произвольный многоугольник.
Опять же, есть специальные алгоритмы, которые работают для выпуклых многоугольников, ну там, примерно все просто и так далее.
Вот мы работаем вообще в произвольном случае, мне дан вообще произвольный многоугольник, не важно выпуклый, не выпуклый, выраженный, не выраженный.
Давайте как-нибудь, давайте побольше.
Абсолютно произвольный многоугольник.
Как вычислить его площадь?
Значит, делается это следующим образом.
Ну, один из возможных вариантов.
Давайте возьму произвольную точку.
Ну, допустим, это будет точка 0,0.
И из этой точки я проведу векторы.
Я проведу векторы в вершины моего многоугольника.
Что я буду делать?
Давайте я буду последовательно проходить, ну пусть это вектор P1, точнее P0, P1, это P2 и так далее.
Ну, в общем, занумеру их в порядке следования вдоль многоугольника.
Ну и давайте я просто-напросто возьму и сделаю следующую вещь.
Я посчитаю площади всех треугольников, которые образованы последовательными векторами.
То есть в частности я сделаю следующую вещь.
Я посчитаю векторное произведение P0 на P1.
P1 на P2 и так далее.
Pn-2, точнее так Pn-1, P0.
И пополам.
Ну понятно, да?
То есть когда я беру векторное произведение двух векторов, я вычисляю площадь параллограмма.
Чтобы получить площадь треугольника, я делю на 2.
Вот.
И делю пополам.
И в итоге я утверждаю, что я в итоге получу площадь моего многоугольника.
Ну почему это так?
Значит, история такая.
Ну видно, что когда я беру...
Да, видно, что когда я беру произведение от P0 на P1, дальше от P0 на P2, от P2 до P3 и так далее, я вычисляю...
Давайте.
Какой у меня многоугольник?
Я вычисляю площадь, и она у меня идёт, с каким знаком?
Ну с отрицательным знаком, да?
То есть я беру площади и их складываю.
То есть когда я иду в прямом направлении, у меня площади идут с отрицательным знаком.
То есть я их просто складываю.
Но при этом, когда я буду идти в обратном направлении, вот, например, вот, от этой вершины до этой вершины,
что мне произойдёт?
Я уже буду перемножать вектор на вот этот вектор, на вот этот вектор.
Какой угол? Положительный, угол с другим знаком.
Соответственно, вот эта часть у меня просто-напросто будет вычтена.
Ровно как и вот эта часть.
И в итоге, ну давайте какую-нибудь отдельную картинку изображу.
В общем, есть какая-то произвольная фигура.
То когда я иду вдоль вот такого направления по внешнему контуру,
я беру все с одним знаком.
Когда я буду идти в обратном направлении,
то вдоль внутреннего контура я буду брать все с отрицательным знаком.
И в итоге вот это все у меня вылется в ноль.
А вот здесь будет плюс или минус С.
Ровно то, что мне нужно.
Соответственно, просто мы берем два последних вектора по порядку
и перемножаем их векторами друг на друга.
Дальше делим пополам.
И в итоге мы получаем ориентированную площадь.
Ну то есть площадь, которая нам нужна либо с положительным, либо с отрицательным знаком.
Ну вот вопрос такой.
Смотрите, вроде как я не прошло и получаться, как я не сдержал свое обещание.
То есть вроде как я говорил, что у нас будет абсолютно точная арифметика и так далее.
Но вот кажется, что если я вычисляю площадь...
Кажется, что вычление площади наугольника,
это довольно такая дробно-рациональная вещь.
Поэтому, короче, я не могу ее вычислить с абсолютной точностью.
Так это или нет.
То есть может ли у меня, например, получиться так, что у меня площадь наугольника будет равна 4,3,
что, скорее всего, на компьютере у меня будет отображено как 2,9,9 и так далее.
Вот возможны ли такие проблемы с точностью?
Супер.
Да, на самом деле площадь произволенного наугольника я могу вычислить абсолютно точно.
И вот почему.
Действительно, когда я беру векторные произведения,
все векторные произведения вычисляются у меня в целых числах.
То есть в числителе у меня стоит целое число.
И все, что я делаю с этим целым числом, в конце я просто беру и делю на два.
И в итоге площадь многоугольника у меня всегда...
Давайте пропишем.
Площадь многоугольника это либо целое, либо полуцелое число.
Все, других вариантов нет.
То есть я всегда с абсолютной точностью могу вычислить площадь любого многоугольника.
Ну, естественно, с целочислыми координатами.
Все ясно?
��요.
И с этой точностью могу вычислить площадь любого многоугольника
Естественно, со целочислыми координатами
Все ясно
Давайте теперь поговорим про другие фигуры
Разобрались, для чего нам нужны векторы
Векторы позволяют вычислять векторное произведение
Векторное произведение позволяет вам, во-первых, узнавать величину угла
Ну и во-вторых, вы научились читать площадь абсолютно произвольного многоугольника
с абсолютной точностью
Многоугольника с целыми координатами, так говорится
Следующий примитив, про который мы поговорим
Будет линия
Давайте я сразу скажу, что линию я буду задавать
Уравнением прямой
Вот таким образом
Сейчас о нем отдельно поговорим
И соответственно
Любая линия представляется тройкой
Целых чисел
Что можно сказать про это уравнение прямое?
Откуда оно берется?
Давайте сделаем следующую вещь
Рассмотрим произвольную линию
Во-первых, зададим вектор нормали
И зададим некоторую точку на ней
То есть любую линию можно задать
И плюс вектор нормали
Тогда линия будет проходить через эту точку
И плюс прямобедикулярно вот этому вектору нормали
Как из этого представления получить такое представление?
Ну очень просто
К какому условию у меня удовлетворяет произвольная точка
Которая лежит на этой линии?
Вот как связать произвольную точку
Точку, которая лежит гарантированно на этой линии
И n
P-P0
на n
равно 0
Ну действительно это так
Потому что если мы возьмем точку P, которая лежит на прямой
И возьмем разность ее с конкретной точкой P0
То понятное дело, что так у меня нормаль
Это перпендикуляр к линии
То вот этот вектор получен
Он будет перпендикулярен вектору нормали
Вот такое уравнение мне задает уравнение прямой
Ну отсюда можно спокойно раскрыть
Что раскрыть?
Раскрыть скобки
Например, скажем, что у меня P это есть x, y
А P0
Это x0, y0
Тогда отсюда что следует?
Да, и n
Пусть у меня будет вектором AB
Если я раскрою, то у меня получится следующая вещь
Ax
Плюс Ay
Минус
Минус By
Минус
Ax0
Ax0 равно 0
Ну и отсюда понятно, откуда берется это уравнение
То есть если я положу вот эту штуку
равной c
То будет ровно то, что я заявлял
То есть отсюда следует, что
Вектор нормали
Точнее перпендикуляр к моей линии найти очень просто
Достаточно просто взять первые коэффициенты
A и B
А как найти вектор, который
Ну так скажем, направляющий вектор
Мой прямой
То есть вектор, который лежит вдоль направления
Мой прямой
Ну да, ну то есть
Мне интересует больше алгоритм, как это получить
В общем
Мы знаем, что направляющий вектор
Перпендикулярен вектору n
Давайте просто составим какой-то вектор
Который перпендикулярен вектору n
Ну
Например вот так
Понятно, что при скалярном произведении
A на B идет с плюсом
B и минус A идет с минусом
Соответственно получаем скалярное произведение 0
Вот
Такие дела
Значит
Ну третья
Не совсем задача
Такая постановка
Вот
Допустим, у меня дана линия
И я хочу понять
Ну, у меня дана линия l
И две точки
Допустим, по 1 и по 2
Я хочу понять, эта точка находится
По одну сторону, прямой или нет
Как это можно сделать?
Да, на самом деле очень просто
Смотрите
Вот дело в том, что если я
Подставлю в уравнение прямой
Py
1 плюс c
Вот давайте f
P1
То
Вот такая величина у меня будет равна
То есть она будет больше 0
Для одной полуплоскости
И меньше 0
Для другой
Ну, это, наверное, понятно, почему
Потому что, если я рассмотрю
Смотрите, если я рассматриваю
Рассматриваю
Рассматриваю
Если я рассматриваю точку P0
И произвольную точку P, которая лежит у меня
На этой прямой
То вот такое произведение
У меня равно 0
Согласны?
А произвольную точку P1 или P2
Я могу представить в виде, ну, такой
Delta1 и Delta2
Соответственно, у меня n
Будет P
Плюс Delta1
Минус P0
Вот
Ну, и, соответственно, n на P и P0
У меня сокращается и в итоге останется просто
N умноженное на Delta1
Ну, а вектор нормальный
Умноженный на вектор Delta1
Будет идти с положительным знаком
Так как они, про что мы говорили, находятся, грубо говоря
Смотрят в одну полуплоскость
А векторы N и Delta2
В одной полуплоскости
Поэтому будут идти с другим знаком
Понятно?
Поэтому для проверки того, что две точки лежат
В одной полуплоскости или нет
Достаточно просто взять уравнение прямое
Подставить в него точку 1 или точку 2
И
Если f от P1
И f от P2
Имеют
Разные
Знаки
То
То в разных
Полуплоскостях
Окей?
Не знаю
Расстояние между прямой точкой
Расстояние между двумя прямыми я думаю говорить не будем
Аналитические формулы
Я думаю, вы в любом учебнике можете посмотреть
Поэтому это не особо интересно
Вот последний пункт, который рассмотрим про линию
Четвертый
Знаете так, проверка параллельности прямых
То есть есть прямая
A1х плюс B1y
Плюс C
1 равно 0
И есть прямая A2х
Плюс B2y
Плюс C2 равно 0
Вот
Как понять параллельные эти прямые
Параллельные эти прямые или нет
Желательно наиболее простым способом
Ну да
Самый простой способ это
Если не совпадают
Ну в зависимости от задачи
Если у вас задачи спрашиваются
Если параллельные прямые пересекаются или совпадают
То три варианта
Если параллельные или
Вобще пересекаются, наверное
Но опять же это от условия задачи зависит
В общем, так или иначе
Действительно
Прямые параллельные тогда и только тогда
Когда их перпестигляры тоже параллельны
Ну это я думаю понятно
Ну как проверить, что вектора
Во-первых, как понять
Чему равен вектор n1 чему равен вектор n2
что n1 это просто a1 и b1, а n2 это просто a2 и b2. Но как понять, что два вектора параллельно?
Да, просто нужно смотреть на эффектное произведение. В этом случае произведение n1 на n2 должно быть
равным 0. Ну и снова заметьте, что так как я работаю в целочисленных координатах, и все координаты,
и все значения коэффициентов у меня целые, то я абсолютно точно, без каких-либо приближений,
и так далее, могу вычислить параллельность прямых. То есть я могу понять параллельно мои прямые или
нет. Не привлекая при этом никакую арифметику вычисления, не знаю, кто-то предлагал через
детерминат и так далее. Но вот если вычислять детерминат или определять точку пересечения,
то там естественным образом возникает деление. То есть при вычислении детермината там, конечно,
будет целые числа, но если вы хотите вычислить, например, точку пересечения, то все будет плохо.
Вопрос уже был, ну смотрите, можно рассмотреть и случаи совпадения. То есть вы можете проверить,
что эти две прямые на самом деле совпадают. Ну что для этого нужно сделать? Нужно просто привести
к общим коэффициентам и так далее. Здесь уже зависимость от задачи. То есть вы читаете условия,
и если вас просят отдельно проверить случаи совпадения, то проверяйте. Если нет, то вот.
На этом, наверное, с прямой закончим. Перейдем к чуть более интересным вещам. Следующий пункт – это луч.
Луч удобнее всего задавать точкой начала и направляющим вектором v.
Какие вопросы может задать луч? Давайте пятым пунктом проверим.
Принадлежность точки P лучу OV. Ну вот есть луч. Есть некоторая точка P. П1 и пусть точка P2.
Как проверить? Опять же, не прибегая никаким делениям, вычислениям расстояний и так далее.
Абсолютно точно проверить, лежит ли у меня точка с целыми координатами на луче.
Тоже с целыми координатами точки и с целыми координатами направляющим вектора.
В целом, да. Давайте рассмотрим вектор OP2 и вектор V.
В чем отличие синего вектора от такого? Первый из них сонаправлен с вектором V, а второй нет.
Поэтому возникает, наверное, естественное желание сказать, что если у меня вектор OP2 и вектор V
грубо говоря параллельны, так линярны, то значит у меня точка P лежит на луче.
Давайте как это проверить? Как уже сказали, параллельность векторов мы проверяем с помощью векторного произведения.
Если векторное произведение V и OP равно 0, то лежит. Так или нет?
Что еще надо?
Вот это не совсем правда, потому что эта штука проверяет лишь половину того, что нужно.
Потому что если у вас есть какая-то точка P3, которая лежит на продолжении луча сюда, то у вас проблема.
Векторное произведение действительно равно 0, так как эти вектора направлены в разные стороны.
Но при этом точка P3 не лежит на луче.
Что нужно дополнительно сделать?
Мало того, что нам нужно проверить, что два вектора параллельны, нам нужно проверить, что они сонаправлены.
Поэтому здесь мы дополняем вот таким условием.
Вот теперь все.
И вот эти два условия образуют следующее понятие, что векторы V и OP сонаправлены.
Так, ну и второй и последний пункт, что касается луча.
Он не совсем вписывается в нашу концепцию, что мы хотим делать все абсолютно точно, но вот ничего не поделаешь.
Вот что есть у нас попросили? Расстояние.
Вот точка P3.
Понятно дело, что расстояние такая сущность, которую в принципе абсолютно точно нельзя посчитать.
То есть так или иначе будут возникать всякие корни и так далее.
Ну давайте хотя бы как-то в раунде.
В раунде, в раунде, в раунде, в раунде, в раунде, в раунде, в раунде, в раунде.
Ну давайте хотя бы как-то попробуем посчитать расстояние от точки до луча.
Через какую площадь?
Ну один из вариантов, да, наверное, да, можно найти площадь в такого перлограмма.
Дальше, ну давайте как. Найдем площадь перлограмма, образованного векторами в AOP.
Вот. И дальше что нужно сделать?
Ну как вы считаете, площадь перлограмма кто помнит?
Надо вот эту высоту умножить на что?
Ну то есть вот так.
Вот.
Ну в целом норм. Можно и так.
Что?
В чем проблема вектор В?
Да, есть проблема, вот такая.
Вот если...
Ну, тут плохой пример.
А, нет, нормальный пример. Хороший.
Ну вот представьте себе, что у вас луч вот такой.
Луч направлен сюда, а точка P находится здесь.
Тогда вот этот луч не подходит, согласны?
Потому что кратчайшее расстояние от точки P до луча это какое?
Это как раз вот эта точка.
Вот поэтому...
Мы вычисляем расстояние либо так,
либо так. То есть, модуль вектора OP.
А в зависимости от каких условий?
Что отличает вот это случая от вот этого случая?
Вот этот случай.
Вот этот случай.
Что отличает вот этого случая?
Да, вновь, скалярное произведение вектора В и вектора OP.
То есть снова мы хотим понять, в какой полуплоскости мы находимся, в левой или в правый.
Ну и здесь тоже. В левой или в правый.
Соответственно, здесь, если у нас OP, скалярное произведение на В,
больше либо равно нуля,
то мы используем вот такой способ.
Ну, меньше нуля пусть будет.
То есть, используем вот такую штуку.
Окей.
Что еще раз?
Ну, без разницы.
То есть, тут тоже самое будет.
Ну, хорошо. Давайте так.
Так нормально?
Так.
Самая интересная фигура, ну как фигура.
Короче, отрезок.
Нет, просто отрезок.
Ну, отрезок просто представляем в виде
пары точек.
Знаете, PQ.
Пойнт P.
Пойнт Q.
Мы хотели узнать про отрезок.
Ну, первый пункт давайте сразу
найдем, точнее, определим.
Принадлежность точки
P'
отрезку PQ.
Давайте О, чтоб.
А, все.
Ну чего, как будем проверять?
Что с фильтрами?
Ну да, кажется, этого достаточно.
Всем понятна идея?
Если у вас точка A лежит вне отрезка,
то у вас вектора P'A и PQ,
но они, во-первых, не параллельны, а во-вторых, не сонаправлены.
Если точка A лежит на отрезке,
то P'A и PQ, они у вас сонаправлены.
Более того, если у вас точка лежит где-то на продолжении отрезка,
то тут этот критерий тоже работает,
потому что у вас в этом случае P'A и PQ будут противоложно направлены.
Поэтому, да, критерий простой,
и он звучит следующим. Во-первых, у вас
вектор P'A должен быть параллелен вектору PQ.
Давайте просто напишем то, что мы там писали.
Сонаправленность векторов P'A и PQ.
Ну, опять же, расстояние плохо.
Да, возьмем две очень удаленные друг от друга точки,
и тут находится точка на расстоянии 1.
Тогда у вас может быть ошибка с точностью.
А здесь все точно. То есть у нас сонаправленность векторов проверяется с помощью
векторно-висколярного произведения, которые вычисляются в целых числах, и все нормально.
Вот. Хорошо.
Восьмой пункт.
Ну, расстояние от точки до отрезка.
Может, сразу скажете,
как вычислить расстояние от точки до отрезка.
Так, что аналогично?
Ну, короче говоря, видимо,
в случае отрезка нужно рассмотреть три случая.
Находимся ли мы здесь?
Находимся мы здесь?
Или находимся мы здесь?
Ну, как проверять, в каком случае мы находимся, будем обсуждать?
Или понятно?
Ну, аналогично лучшую, да. То есть вы просто смотрите на вектор ПQ и смотрите на вектор ПА.
Вот. Если они сонаправлены, то точно не здесь.
Аналогично рассмотреть вектор QP и вектор QA.
Если их скалярное произведение больше 0, то точно не здесь.
Ну и соответственно по этим двум критериям вы можете спокойно определить,
какого части вы находитесь.
Ну и теперь давайте, если я нахожусь в первой области, то чему равно расстояние?
Чему равно расстояние от точки A до точки P?
Да, просто расстояние от A до P в случае 3.
Да, от точки A до точки Q.
В втором случае...
Да, ну просто расстояние от точки A до прямой PQ.
Прямая или луч, как вам удобнее.
Прямая, луч.
Все.
Пересечение с линией.
Ну данный отрезок, данная линия, нужно понять,
пересекаются ли отрезок и линия или нет.
Ну и...
Ну и...
Короче, хочется сказать, что эту задачу мы уже решали.
Какой пункт у нас был?
Ну номер пункта, чтобы сослаться.
1, 2, 3.
Давайте просто напишем, смотри, пункт 3.
Ну действительно, если у вас...
В каком случае у нас отрезок пересекает линию?
Если две точки находятся по одну сторону от прямой,
то в общем все плохо.
Отдельно надо сказать про случай, когда у вас точка лежит на прямой.
По умолчанию считаем, что если хотя бы одна из точек лежит на прямой,
то пересечение есть.
Плюс отдельно
случай
П принадлежит L
или Q принадлежит L.
Ну как проверяем принадлежность точки прямой? Говорили, да, просто подставляем в уравнении прямой и все.
Вот. Соответственно, снова пересечение прямой и отрезка
абсолютно точно у нас вычисляется. Без применения каких-то там
делений, вычислений корня и так далее и так далее.
Ну я напомню, что мы принадлежность точки в полуплоскости проверяли
с помощью обычного скалярного произведения.
Поэтому тут тоже все со стопроцентной точностью.
Так, давайте здесь же напишу.
Значит, теперь мы пересекаем отрезок
и луч.
Ну вот тут, к сожалению,
так просто не получится ничего сделать.
И вот по какой причине?
Ну вот смотри.
Вот здесь вот мы пересекаем отрезок.
И вот здесь вот мы пересекаем отрезок.
Ну вот смотрите. Вот есть точка P здесь.
А есть точка P здесь.
Одна из них пересекает луч, другая не пересекает луч.
Ну казалось бы, они более-менее одинаковые, да,
то есть лежат в одной полуплоскости слева
от вектора V сверху и так далее и так далее.
Но при этом одна прямая пересекает, другая не пересекает.
Здесь я, в общем,
тут можно помахать руками и посчитать через углы,
через повороты и так далее, но, в общем,
я надеюсь, вы меня простите, но мне больше нравится
аналитический подход к этому всему делу.
Давайте попробуем вывести некоторые критерии,
например, прежнодержность точки прямой или лучу.
Значит, смотрите, как задается произвольная точка на луче?
Ну ее можно задать очень просто.
Согласны?
Положение произвольной точки на луче задается как?
Положение точки O плюс двиг на какой-то вектор в направлении V.
Как задается произвольная точка на отрезке по Q?
Я так напишу Q минус P.
Причем здесь T больше либо равно нуля,
а альфа принадлежит нуля до единицы.
Теперь смотрите.
Давайте пункт А алгоритма.
Первым пунктом давайте сразу проверим, что у меня
в принципе отрезок PQ пересекает линию, на которой лежит луч.
Потому что если отрезок не пересекает линию, на которой лежит луч, то о чем вообще говорить?
Давайте просто проверяем
пересечение PQ
и линии OV.
Вот смотрите.
Если отрезок PQ пересекает линию OV,
то у меня гарантированно в этом уравнении в качестве альфы решение будет 0.1.
Согласны?
То есть гарантируем
альфа принадлежит от нуля до единицы.
Ну то есть T может быть отрицательной в принципе,
но альфа точно принадлежит от нуля до единицы.
Понятно, да, решение?
Ну и пункт В, давайте что сделаем?
Давайте перенесем в левую часть. Что у меня получится?
Вектор O-вектор P что мне даст?
Вектор PO кажется, да?
Вектор O-P равно PO.
Из этого следует, что O равно P плюс PO.
Кажется, все верно.
Дальше. Плюс VT
равно... Давайте вот эту штуку оставим.
Альфа на... А Q-P это что?
Это PQ, да?
Вот.
Ну и теперь мне надо как-то понять, при каком условии у меня T больше нуля.
Но вот меня смущает, что тут есть еще параметр альфа и T.
Вот давайте я как-то от альфа пытаюсь избавиться. Вот предложите какой-нибудь способ, как мне избавиться от альфа.
Вот как занулить правую часть. Умножать на 0 не вариант.
Давайте векторно только. Векторно на что умножить?
Давайте я векторно умножу на PQ.
Но если я векторно умножу PQ на PQ, то получится 0.
Все. То есть в итоге у меня получается следующая вещь. Вектор PO векторно на PQ
плюс
V векторно на PQ
T равно нулю.
При каком условии у меня есть... Ну теперь надо проверить при каком условии у меня есть корень,
который больше либо равен нуля.
Ну T больше либо равен нуля.
Задачи с параметром не решали.
Давайте вот это A, вот это B. Или у меня A занято? Нет.
Ну тогда и только тогда, когда A и B
разных знаков.
Ну давайте вот так скажем. Что T больше нуля, тогда и только тогда,
когда A и B разных знаков.
Здесь еще один случай.
Не знаю, нужно ли его проверить отдельно или нет.
Вот если O принадлежит
O принадлежит PQ.
Вот если O принадлежит PQ, то все OK.
Ну давайте это нулевым пунктом отдельно проверим.
Если точка O лежит на отрезке PQ,
то пересечение есть.
Все, ну а дальше собственно проверяем, действительно ли у меня PQ пересекает прямую.
В этом случае я гарантирую, что у меня решение для альфы лежит в отрезке 0,1.
Ну и дальше мне осталось проверить, что решение для T у меня больше нуля.
А это я проверяю вот таким образом. Просто смотрю на скалярные произведения
по O и PQ,
и в и PQ.
Если они разных знаков, то все OK.
Вот у этого всего есть геометрический смысл.
В общем, вы можете покрутить и посмотреть, что вот...
Ну короче, если там что-то типа...
Если поворот, то есть поворот угла от V до P
и V до Q там что-то типа имеет одинаковый знак, то вот все плохо.
В общем, посмотрите,
я обычно все вывожу, а не геометрирую.
Вот решение, пользуйтесь.
Так, ну и последний пункт, который касается отрезка.
Мы пересекали отрезок с прямой, пересекали отрезок с лучом.
Да, с самим отрезком.
Итак, пересечение AB и CD.
Ну, отрезок AB и отрезок CD.
Ну вот, даны два отрезка.
Ну или вот так.
Нужно проверить, пересекаются они или нет.
Что делать?
Ну, я предлагаю попроще.
Давайте проверим, что отрезок... ну, смотрите, давайте воспользуемся тем, что мы уже делали.
Давайте попробуем пересечь отрезок CD и прямую AB.
И наоборот, прямую CD с отрезком AB.
Вот.
Если отрезок AB пересекает
прямую CD и отрезок CD
пересекает
прямую AB.
Разумно?
Вот, этот критерий работает почти всегда.
В каком случае он не работает?
Совпадают.
Совпадают. Нет, если совпадают, то все нормально.
При совпадении отрезок пересекает прямую CD и наоборот.
А вот если прямые совпадают...
Ну вот такой пример. Согласны?
AB пересекает прямую CD, CD тоже пересекает прямую AB.
Но при этом сами отрезки не пересекаются.
Что делать?
Но в этом случае надо дополнительно проверить.
Давайте тут напишу. Плюс
проверить пересечение
проекции
проекции
AB и CD.
То есть...
Мы смотрим на проекции отрезка AB
и проекции отрезка CD.
Ну и в этом случае их проекции не совпадают.
Поэтому, естественно, никого пересечения у них самих нет.
Но при этом, если их проекции пересекаются...
Ну, то есть...
Ну как проверить пересечение проекций?
Ну или наоборот?
Ну, в общем, нужно аккуратно проверить...
Ну, еще какие-то условия. Нужно аккуратно проверить
пересечение проекции.
Ну, в общем, нужно аккуратно проверить
prü
То есть я привел пример, когда первую условия
недостаточно, да. То есть проверить еще вторую.
Можете привести пример, что teaspoon
не достаточно тоже. Нужно проверять еще пересечение прямых.
В этом случае они по y не пересекаются.
Вот так.
Они и по x пересекаются, и по y пересекаются.
Но при этом сами отрезки не пересекаются.
То есть отрезка B не пересекает линию CD.
Ну и, видимо, последний пункт на сегодня.
Многоугольники.
Многоугольник будем представлять в виде упорядочного набора вершин.
Ну то есть многоугольник это просто массив, который состоит из его вершин.
Поэтому упорядочное в каком-то порядке.
По часовой стрелке или про часовой стрелке неважно.
Ну и пункт 7.
Какой у нас пункт был?
Почему тут 8?
Ну короче, пункт плюс-плюс и.
Значит, мы должны проверить.
Хочется проверить, лежит ли точка.
Лежит точка внутри многоугольника или нет.
Произвольно, абсолютно.
То есть не выпуклого и так далее.
В общем, хочется уметь отличать вот такую ситуацию от вот такой ситуации.
Ну и пункт 9.
Ну и пункт 10.
Ну и пункт 11.
Ну и пункт 12.
Теперь я хочу уметь отличать вот такую ситуацию от вот такой ситуации.
Здесь предлагается использовать следующий метод.
Давайте рассмотрим произвольную фигуру.
Замкнутую ноту.
Такая фигура.
фигура и я хочу проверить действительно у меня точка лежит внутри или нет вот
давайте я опущу произвольный луч ну допустим горизонтально направлении
пускай луч горизонтально направлении я получаю какое-то количество пересечений
что можно сказать про их количество
ну да ну из чего да из чего это следует смотрите вот когда я пересекаю когда
пересекаю стороны что у меня происходит вот когда пересекаю первый раз у меня
луч выходит из этой фигуры да когда я захожу во второй раз он обратно входит в эту фигуру
выходит-входит-входит и вот если количество выходов у меня больше чем количество вхождений
то значит у меня луч в конце концов покинул фигуру но в каком случае у меня луч может
покинуть фигуру только в случае если у меня изначально точка находилась внутри согласны
а где здесь вершина ну про это мы отдельно поговорим да это вы в общем правильное
замечание делать очень действительно если меня там проходит через касательную то да ну в
принципе как бы касса ну не знаю там с логической точки зрения наверное касание не читается входом
или выходом поэтому все-таки будем считать что вход или выход как пересечение ну то есть заход
именно внутрь фигуры в общем примерные критерии такое если число пересечения чётно то снаружи
иначе иначе внутри первое приближение теперь проблемы вот одну проблему действительно уже
вскрыли конкретно в случае многоугольника что если у меня вот такая ситуация дайте вот такой
многоугольник рисуем и точка здесь вот если я многоугольник пересекаю здесь то что у меня
получается ну мы можем смотреть такую точку можем считать действительно за две но потому что
с одной стороны мы пересекли вот такую вершину и вот такую вершину да то есть в итоге у нас
три пересечения и что точка внутри контрпример сколько пересечений ну два и при этом точка внутри
тоже поэтому когда я встречаю вершину на своем пути мне плохо что делать есть два трюка и
первый заключается следующим смотрите вот давайте я буду поступать следующим образом
ну примерно только мы луч вообще смотреть не будем будем просто смотреть на то короче
будем смотреть вот эта точка находится выше или ниже чем вторая вторая короче сейчас объясню
смотрите вот если я вот смотрите когда я когда то есть как я проверяю пересечение луча с моим
многоугольником я просто последовательно прохожу по всем сторонам и проверяю вот этот отрезок
пересекается случом или нет отрезок пересекается случаемumber нет и так далее andy и вот допустим я в
какой-то момент понял что какой-то момент понял что мой луч пересекают вот эту сторону вот эту
сторону при этом он проходит через одну из вершин ну конкретно через точку и давайте сделаем
такой трюк если мой луч проходит через верхнюю точку стороны то я буду добавлять к счетчику
плюс один. Я иду по всем сторонам и считаю количество пересечений.
Вот если я встретил верхнюю точку прямой, точнее верхнюю точку стороны, то я даю
плюс один. Вот здесь то же самое. Когда я прохожу через вот эту сторону и
прохожу через верхнюю точку вот этой прямой, я делаю плюс один. А если я
прохожу через нижнюю точку, ну вот здесь.
Смотрите, я второй раз прохожу через эту вершину, но при этом вот эта точка
является нижней точкой относительно всей стороны. Понятно? То есть у нее меньше
y координата. Это вообще отдельная история. Пока вот такой пример понятен.
Вот если мы проходим через нижнюю точку стороны, то даем плюс ноль. И в этом
случае какой у меня суммарный баланс? Ну плюс один. А в этом случае что у меня
получается? И эту сторону, и эту сторону я пересекаю по верхней точке, поэтому я и там
и там даю плюс один. Поэтому суммарно получается плюс два. То есть, что у меня
получается? Значит какие варианты возможны? Ну вот есть луч, он может
пересечь вот таким образом, может пересечь вот таким образом, может пересечь вот
таким образом. Тогда здесь насколько у меня изменится счетчик? На ноль. Не пугайтесь, на ноль.
Меня это устраивает? Ну да, устраивает. Почему? Потому что у меня, то вышел я или
вошел в фигуру, зависит только от чётности. В этом случае чётность не поменялась,
собственно, как и нужно. Здесь насколько у меня щечка изменится? На плюс два, потому что обе вершины
верхние, и в этом случае тоже четность не меняется. И только здесь щечка изменится на один, но это
ровно то, чего я хочу. То есть я как бы вышел или вошел в фигуру, все нормально. Ну давайте этот
способ А. Как справляться с подобными коллизиями. Есть альтернативный способ Б. Он может быть даже
несколько проще. Он скорее всего проще. Извлечается он в следующем. Вот смотрите, вот допустим,
у меня есть снова точка, я хочу понять, нахожусь ли я внутри многоугольника,
или нет. Предлагаю сделать следующий вид. Давайте я возьму точку, которая расположена очень-очень
далеко от моей, вот прямо по х, почти на бесконечности. Но при этом с единственным отличием. Вот у этой
точке координаты x и y, у этой точке координаты бесконечность y плюс 1. Ну зачем мне нужно x на
бесконечности? Ну чтобы гарантированно эта точка была за моим многоугольником. Для чего я делаю y
плюс 1? Кто мне ответит? Да, смотрите, теперь если у меня тут y, а тут y плюс 1, то у меня вот эта
прямая, точнее вот этот отрез, гарантированно не пересекает никакую вершину. Потому что у меня
все дискретно, и поэтому промахнулся. Поэтому в этой области ширины 1, у меня точно нет ни одной целой
точки. Поэтому эта проблема вообще выходит с повестки. Единственная проблема, которая тут есть,
это вот эта бесконечность. Ну то есть непонятно, какую ее назначать, и во-вторых, если ее назначать
слишком большой, то у вас может возникнуть ошибка переполнения, что естественно неприятно.
Поэтому выбирайте способ. Ну и вот последний случай, который мы не разобрали, это вот, а что если
у меня вот этот луч, который, ну неважно, там вот таким способом я построил, или вот таким способом,
что если он проходит через сторону? Ну кажется, в этом случае понятно, что делать. Если у меня луч
параллельно стороне, то просто мы ее игнорируем. Ну кажется, и в том, ну неважно, какой у меня случай,
то есть если я прохожу в сторону, мне достаточно ее просто проигнорировать и все. Ну вот. Ну на этом
сегодня все. В следующий раз закончим про наследование и поговорим про выпуклую оболочку.
