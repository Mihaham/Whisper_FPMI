Так, ну что, у нас все еще потоки.
Давайте пример задачки рассмотрим.
На самом деле это просто поиск максимального прочесания
в вдвудольном графе.
Как можно ее решать с помощью потока?
Это было у всех на семинарах или нет?
Хорошо.
Значит,
делаем следующее. Ну вот есть у нас
стандартный вдвудольный граф.
Два множества вершин LR.
Давайте я сделаю следующее. Я веду
фиктивные новые вершинки S и T,
не принадлежащие ни одной из долей.
Проведу из S
ребра единичной пропускной способности
во все вершины левой доли,
и наоборот из всех вершин правой доли
проведу единичные ребра в T.
А ребра между долями я ориентирую
слева направо и тоже сделаю единичные
копасти. То есть все ребра графа
вдвудольного, которые у нас здесь были,
я просто ориентирую слева направо так же,
как они были раньше,
и назначаю им копасти 1.
То есть здесь все такие же ребра,
какие были в исходном графе.
И вот я утверждаю, что поток в такой сети
в точности по размеру равен максимальному
просочетанию.
Более того, любой поток здесь
и любое просочетание в исходном
графе, они в каком-то смысле друг другу
соответствуют.
Значит, любое просочетание
соответствует какому-то потоку.
Значит, максимальное просочетание будет
соответствовать максимальному потоку.
Соответственно, очень простое.
Смотрите, как вообще здесь устроен
поток в этой сети.
Поскольку у меня граф на самом деле
ациклический,
ориентированный ациклический граф,
якобы все ребра слева направо,
поэтому
поток он всегда распадается на
несколько путей, вот таких вот из S в L,
потом в R, потом в T. То есть любой путь,
который задействуется в потоке, он какой-то такой.
То есть дошли до сюда,
потом взяли ребро
исходного графа, поместились сюда,
и дальше уже в T
потекла т-нечка потока.
Ну и при этом, понятное дело, что все вот эти
вот пути из трех ребер, они не пересекаются
вообще, ну кроме S и T,
потому что вот этих вот ребер копасть
единичка. То есть мы не можем как-нибудь
попасть вот сюда вот два раза в одну
ту же вершину,
или как-нибудь вот сюда вот мы не можем попасть,
потому что отсюда мы никак не можем
уйти, кроме как используя это ребро.
Поэтому все вершины, которые мы используем,
за исключением крайних S и T,
они у нас используют по одному разу.
Но поэтому используемые вот здесь
вот по центру ребра, это по рассочетанию обязательно.
Потому что те ребра, которые я задействую,
по которым я пускаю поток,
они все попарно имеют различные концы.
То есть скажем вот такой путь.
Ну и еще какой-нибудь. Они все имеют попарно
различные концы.
Значит поток имеет всегда размер
такой же, как по рассочетанию,
которое он образует вот здесь вот между дарами.
Ну, поэтому максимальный поток – это просто максимальное просчитание в этом графе.
Окей?
Ну и тогда, если мы применим к этой сети какой-нибудь хороший алгоритм,
например, алгоритм Динница, и как-нибудь хорошо его оценим,
то мы получим крутую симптотику на то, за сколько можно находить максимальное просчитание.
Ну вот давайте показаново просто оцениваем, давайте почитаем потенциал в этой сети.
Значит, у СТ потенциал нулевой, потому что в С ничего не входит, в Т ничего не выходит,
а у всех этих вершин потенциал единичка на самом деле,
потому что здесь у этих вершин входящая капасти 1, а у этих вершин исходящая
Итерацией, мы знаем по первой теории Микарзановой,
итерацией в алгоритме единица будет от корни из В.
Но поскольку сеть еще единичная, а мы в прошлый раз замечали,
что на единичной сети одна итерация работает за от
Е.
Следовательно, каждая итерация работает за от Е.
Мы все перемножаем, получаем асимптотику е корни из В.
За столько мы умеем находить Макс парсуэль в индуарном
графе.
Это называется алгоритм Хобкрафта Карпа.
Собственно, алгоритм просто построить такую сеть, запустить
на ней алгоритм единица.
Очень просто.
Здесь не единица.
Если аккуратно оценить, то получается вот такая
асимптотика.
Это, как всегда, оценка сверху.
Возможно, он еще быстрее что-нибудь найдет.
Ну хорошо, тогда идем дальше.
Следующий сюжет – это глобальный минимальный разрез и алгоритм
Шторвагнера.
Это поиск минимального глобального разреза.
Шторвагнера.
Ну это фамилия.
А, предыдущий.
А, предыдущий.
Хобкрафт Карп.
Карп.
Карп.
Карп.
Карп.
Такой же, как Эдманс Карп.
Только Хобкрафт Карп.
Вот.
Следующий алгоритм – это поиск минимального глобального
разреза в неориентированном графе.
Ну неориентированном на самом деле для удобства.
Там вроде не сильно важно, что он ориентированный
или нет.
Ну давайте я для простоты считаю, что он неориентированный.
Вот.
Чуть как минимальный глобальный разрез.
Смотрите, у нас раньше тоже были разрезы, но они были
в каком-то смысле чуть-чуть зафиксированными.
У нас всегда были выделены S маленькая и T маленькая.
Я всегда говорю, что разрез – это такое разбиение всех
вышин на два множества, что S маленько в S большом,
а T маленько в T большом.
Да, значит, напоминаю, разрез в обычном понимании – это
когда у меня фиксированы какие-то вершинки, и дизинктное
объединение наших множеств – это все вершины.
Вот.
Значит, когда я говорю глобальный разрез, я отказываюсь вот
от этих двух требований.
То есть я отказываюсь от того, что какие-то вершины
где-то фиксированы.
Мне нужно просто среди всех возможных разбиений V на
два множества.
Ну, видимо, надо потребовать не пустоту, да, потому что
если возьму все вершины, то это будет неинтересно.
Мне нужно просто сказать, что они не пустые.
Вот.
Чтобы хоть какие-то вершины в них лежали.
И, как всегда, мне нужно посчитать сумму capacity всех
ребер между долями, то есть из S в T, и в данном случае
минимизировать ее.
Да.
Не ориентированным графе.
Не ориентированным графе, да.
Вот.
Значит, ну понятно, да, вот этот, собственно, глобальный
разрез.
Глобальный разрез.
Вот.
И давайте я еще для удобства введу такое обозначение,
которое я уже когда-то использовал, ну еще раз могу написать.
Значит, если A и B это произвольное подношение множество вершин,
то через C от A в B я буду обозначать сумму capacity текущих
из A в B.
Потому что это я говорил, что в обычном разрезе у меня
фиксированы какие-то старты конец.
А здесь я отказываюсь от этого требования, перехожу
к глобальному разрезу, у меня нет фиксированных
вершин.
Вершина S маленькая, t маленькая.
Значит, что такое C от A в B, это просто сумма по всем
возможным парам у из A в из B, capacity у в.
Ну, то есть, в нашем случае вот здесь вот все вот эти
ребра, да, это как раз ребра пересекающий разрез, и
мне нужно минимизировать вот в таких вот условиях
CST.
Значит, предложите мне, пожалуйста, какой-нибудь алгоритм решения
такой задачи.
Вы умеете, не позволяйтесь.
Какое угодно.
Хорошо, полинамиальный.
Да, конечно.
Я вот единственное, что мне мешает, то что я не знаю,
между какими вершинами это разрез.
Между каким S маленькая, t маленькая, это разрез.
Давайте их все переберем.
Давайте насильно скажем, что S маленькая в S большом,
t маленькая в T большом.
Какую-то пару переберу.
А дальше мы уже умеем искать минимальный разрез между
парой вершин.
Мы знаем, что минимальный разрез – это всегда максимальный
поток.
Теорема Форда Фалкерсона говорит, что min-cut – это всегда
max-flow.
Давайте просто переберем вот эти две вершины С и Т,
и там найдем максимальный поток.
Благо максимальный поток мы умеем искать достаточно
быстро.
Ну и перебирая все С и Т, мы найдем минимальный разрез
в частности.
Можно делать так, но это будет, конечно, дольше, чем
Шторвагнер.
Давайте опишем алгоритм.
Что он делает?
Он делает следующее.
Он хочет занумерать все вершины в каком-то порядке.
Это будет у меня нумерация вершин.
Ну и для удобства я ввожу обозначение, что а большое
итое – это множество всех вершин с первой по итою.
Так вот, как работает алгоритм?
Он в качестве а1 выбирает произвольную вершину.
Ну, например, давайте я скажу, что просто первая
вершина.
На самом деле произвольная.
Произвольная вершина.
А дальше, на каждом следующем шаге, на каждом шаге и,
начиная со второго, аитое – это такая вершина, которая
со всеми предыдущими наиболее связана.
То есть сумма всех ребер, исходящих из аи и ведущих
в предыдущие построенные вершины, то есть а1 и так
далее, аи-1.
Максимально возможно.
То есть я складываю все вот эти вот capacity и выбираю
такой аи, чтобы сумма всех этих capacity была максимальна.
Это множество, это все предыдущие выбранные вершины, то есть
на самом деле просто а и-1, а там как раз содержатся
все первые и-1 вершин.
Ну а условие того, что мне нужна максимальная capacity
суммарной вот здесь, я могу написать так.
Формально аи – это argmaximum по всем вершинам v, не лежащим
в аи-1, величина, ну я не буду говорить разрез, я скажу,
что просто величина вот такой вот пары, где v отдельно
и аи-1 во второй доле лежит.
То есть у меня v – это вот та самая вершина аи, то есть
я перебираю все v, ищу максимально возможное значение вот этой
вот величины в одной доле v, вот она, а в другой доле
все множество аи-1.
Я считаю суммарную capacity всех этих ребер, как раз
c от пары – это вот в точности сумма всех таких capacity, и
мне нужен максимум по всем возможным вершинкам, не
лежащим в множестве уже взятых.
Вот, и так делаю для любого и.
Вот.
Начну делаю, ну пока что-то сделал, вроде какой-то простой
рифметическая операция.
Ну вот, оказывается, что, давайте так напишем, а
оказывается, что c между an и an-1 равно, ну давайте
я вот так вольно достаточно напишу, словами расшифрую
что я имею в виду, равно mincut между an-1 и an.
Значит, что такое mincut между двумя вершинами?
Это вот в точности величина минимального разреза, такого
что одна вершина в одной доле, другая вершина в другой
доле, или иными сторонами, ну это максимальный поток
между вершинами.
Мы знаем, что mincut – это всегда maxflow, поэтому я могу
здесь переписать это как maxflow между an-1 и an, ну это
мне соображение не нужно, просто переформулировка
более удобная.
Вот.
Значит, я утверждаю, что если таким образом выбирать
вершины, каждый раз вершины максимально связаны со
всем предыдущими, то вот последние две вершины,
которые я рассмотрю, которые я добавлю в нашем порядке,
an-1 и an, на самом деле я найду минимальный разрез между
ними в виде, когда у меня an отдельно, а все другие
во второй доле.
Ну, соответственно, здесь в частности будет лежать
вот это вот an-1.
Вот.
Это мы докажем чуть позже.
Давайте пока об это поверим.
Значит, ну смотрите, если это верно, то получается,
мы за один проход нашего алгоритма нашли минимальный
разрез между какими-то двумя вершинами.
Ну вот там, какими-то конкретными.
На самом деле мы не можем сказать, какие, видимо, это
вершины, но вот какими-то, главное, что это какие-то
вершины.
А теперь смотрите, а как выглядит настоящий минимальный
глобальный разрез?
Вот mincut во всем графе.
Понятно, что он либо разделяет эти две вершины в разные
доли, либо они в одной доле.
Смотрите, но если он разделяет их, то это и есть минимальный
разрез, потому что если настоящий mincut их разделяет
в разные доли, вот если настоящий mincut так выглядит,
то вот это и есть настоящий mincut, глобальный mincut.
Ну, потому что мы и так знаем, что они в разных долях.
Собственно, мы как раз минимизируем разрез между ними.
Вот, значит, либо это уже минимальный разрез, либо
нужно рассмотреть случаи, когда они лежат в одной
доле.
То есть в настоящем разрезе минимальном an и an-1 находятся
в одной доле.
И есть какая-то еще другая доля, которая их не содержит.
Вот, но если так, то смотрите, мне осталось разобрать
случаи, когда они в одной доле.
Давайте тогда их склею и буду считать за одну
вершину, потому что если я заведомо знаю, что они
в одной доле, я могу на самом деле считать, что
это просто одна вершина, и все ребра, которые из них
исходили, ну, поместить как бы, как бы их склеить,
все равно ребро между ними все равно в разрезе не участвует,
я могу их склеить и все вот эти вот ребра тоже склеить.
Например, если у меня было какое-нибудь ребро, давайте
нарисую что-нибудь.
Если у меня были вот такие вот ребра, ведущие в одну
и ту же вершину, то после склейки у меня будет ребро
с капастью x плюс y, ну, буквально склеиваю
все ребра просто, да, суммируя капасть.
Вот.
Поэтому, да, еще раз, смотрите, либо мы уже поняли, что
это мы и так нашли минимальный разрез глобальный, либо
мне нужно склеить наши две вершины и заново запустить
на самом деле Шторвагнера.
То есть мы либо нашли какой-то менткат, на самом деле глобальный
менткат, либо мы точно знаем, что в глобальном менткате
эти две вершины склеены.
Ну, давайте их склеим и запустим все то же самое.
То есть последний шаг, это мы склеиваем, склеиваем
AN и AN-1, ну и, соответственно, рекурсивно запускаем алгоритм.
На последнем шаге, скажем, когда останется всего две
вершины, мы точно знаем, как выглядит глобальный
минимальный разрез, потому что когда две вершины, у
нас всего один разрез, одна в одной доле, другая в другой.
Да, значит, выход из рекурсии, когда осталось две вершины,
тогда уже понятно, что величина разреза – это просто
капасти этого ребра.
Так, понятно, что произошло.
Ну окей, значит, смотрите, давайте сначала я про симптотику
скажу, а симптотика, я тоже, здесь будет просто кубическая,
а симптотика будет N-куб.
Суммарно всего этого безобразия будет N-куб.
Ну потому что, смотрите, вот здесь вот, когда на каждом
шаге я выбираю вершину максимально связанную
с предыдущими, это что-то очень похоже на dx или на
prima.
На каждом шаге мы выбираем вершину наиболее, ну там
было наименее, с наименьшим весом, тут с наибольшим
суммарным весом до всех остальных вершин, которые
выбраны.
Ну, собственно, по тем же причинам это все можно
за квадрат написать.
Я могу просто для каждой вершины V хранить вот эту
величину, то есть сумму capacity в уже рассмотренные
вершины.
Когда очередная вершина рассматривается, добавляется
в нашу нумерацию.
Я просто рассматриваю все исходящие из нее ребра
и увеличиваю величину для всех, ну, короче, для всех
соседей.
Вот.
Поэтому, суммарно, вот одна итерация, вот это вот
все, вот этот вот цикл, на вот этот вот цикл, его
можно реализовать за квадрат, потому что по факту это
что-то очень похоже на dx-ру.
Вот.
То есть, если постараться, можно было бы, наверное,
за m log n это сделать, но обычно штурвагнер на полных,
ну, там, на близких полных графах используется, поэтому
здесь лучше квадрат обычно.
Вот.
Ну и так n раз, потому что у меня рекурсия, на рекурсированном
шаге у меня две вершины склеиваются, значит у меня глубина рекурсии
будет n.
Отсюда n куб.
Так, значит, теперь, чтобы совсем победить, осталось
доказать вот то утверждение, что разрез, находимый между
последними двумя вершинами, равен разрезу в случае,
а а n отдельно, а все остальные в другой доль.
Вот.
Ну, давайте это будем доказывать.
Для этого давайте рассмотрим какой-то конкретный разрез.
Рассмотрим, ну, точнее, произвольный, да, ну, какой-то зафиксированный
произвольный разрез st между а n и а n-1.
И мы хотим доказать, что его величина больше равна
чем то, что мы нашли.
То есть я утверждаю, что вот это вот, это минимальный
разрез между двумя вершинами, я говорю, чтобы это доказать,
давайте рассмотрим произвольный разрез между ними и докажу,
что его капасти больше равна, чем то, что я пытаюсь
доказать, что это минимум.
Это как раз значит, что это, это минимальный разрез.
Так, хорошо, значит, для этого мне нужно будет сделать
следующее.
Лемма.
Вот разрез st у меня зафиксирован, какой-то конкретный разрез
я хочу доказать.
Лемма.
Значит, будем называть вершину i, точнее a i, вершину a i активной,
если, если она и предыдущая к ней, то есть a i и a i-1, лежат
в разных долях st, то есть одна в s, другая в t.
Я не умею записывать лучше, чем вот так, если a i в s а
а i-1 в t или a i в t а i-1 в s, то есть она активна, если
она другая по сравнению с предыдущей, вот если по
сравнению с предыдущей, они в разных долях, либо
st, либо t s.
Так вот тогда, утверждает Лемма, ну, собственно, вот
похоже здесь неравенство будет, сейчас я его зафиксирую,
значит, c a i, a i-1 меньше либо равно, чем сужение разреза
st на множество a i.
Так, пока вроде не обманываю.
Зачем это надо, давайте потом, давайте докажем сначала.
Доказательство, доказательство я буду проводить индукцией
по активным вершинам.
Индукция по активным вершинам.
Ну, давайте рассмотрим первую активную вершину.
Что значит, там что-нибудь ажи, пусть ажи это первая
активная, пусть ажи это первая активная.
Что значит первая активная, значит все предыдущие скажем
в s, а она в t, то есть она отличается от всех остальных.
Вот первые переключения из одной доли в другую
происходят в точке ажи.
Что значит, что все предыдущие в одной доле, а ажи в другой.
Ну, то есть, например, это выглядит как-то так, а1
и так далее, а, ж-1, все лежали в s, а ажи лежит в t.
Ну, или наоборот, но это неважно, у меня ас и т всегда
взаимозаменяемым, потому что граф неориентированной
капасти, от этого не меняется, поэтому давайте я так нарисую.
Вот, давайте попытаемся понять, что здесь написано.
Значит, я вместо аи подставляю ажи, и на самом деле в обоих
частях этого неравенства написана просто величина
этого разреза, потому что у меня справа лежит только
ажи, а слева все остальные, поэтому то, что написано
здесь, это сумма всех робер пересекающих разрез.
Да, у меня ажи здесь, а большое, ж-1, это все вот здесь, поэтому
слева написана величина этого разреза, ну и справа
то же самое, потому что когда я сужаю s до ажи, то есть пересекаю
s с ажи, получается как раз вот эти вершины, когда я пересекаю
t с ажи, получается только одна вершина ажи, значит здесь
тоже написана величина этого же разреза, поэтому в базе
у меня даже получается равенство, не неравенство, а даже равенство.
Ну переход, давайте рассмотрим две последовательно активные
вершины, скажем ау это активная, потом несколько ау плюс
1, ау плюс 2 и так далее не активная, а следующая активная
это ав, пусть ау, ав две последовательные активные
вершины, между ними активных нет. Так, картинка, давайте
я опять буду считать, что ау лежит в с большом, ав лежит
в т большом, значит я нарисую такую картинку, двухступенчатую,
это у меня будет с пересечь с ав, это t пересечь с ав,
это с пересечь с ау, это t пересечь с ау. Так вот,
я говорю, что ау лежит вот здесь вот, дальше, поскольку
у меня промежуточные между ними, ау плюс 1, ау плюс
2 и так далее, не активные, то получается, что по сравнению
с предыдущей не происходит переключение в другую долю,
значит они все вот здесь же, но поскольку они уже
вылезают за ау, то они вот здесь находятся, ау плюс
1 и так далее, ав минус 1, вот они все вот здесь, в той
же доле, что и ау, потому что они не активные, а ав
активная, значит она в другой доле, она вот здесь вот,
можно нарисовать такую картинку еще раз в предположении,
что ау маленькое лежит в с большом. Так, ну и давайте
попробуем написать, что такое, вот то, что меня там пытаются
попросить оценить, с между ав и ав минус 1. Я разобью
сейчас второе множество на два подмножества. Так,
чтобы не ошибиться, я спешу. Да, ау минус 1, хорошо.
Значит, равенство тривиально, оно просто, ну из определения
следует, что я могу второе множество разбить на два
подмножества, ау минус 1 и дополнение до него, то
ау минус 1 без ау минус 1. Понятно тогда, что при суммировании
у меня в точности получится вот эта вот ночь, потому
что я в серебре учту как раз. Так, ну и давайте теперь
с этим возиться. Вот первая слагаемая довольно простая.
Я утверждаю, что эта штука не больше, чем вот такая
штука. Скажите мне, почему? Что ав, ну капасити между
а маленьким в и вот этим множеством не превосходит
не больше, чем увеличена между ау и этим множеством.
Для этого надо вспомнить, в каком порядке мы вершины
выбираем. Ну конечно, да, да, просто по определению.
Мы вот на этом шаге, на утром шаге, мы выбрали эту вершину
так, чтобы эта штука была максимально среди всех
возможных вершин вот здесь вот. Поэтому если я заменю
это на что-то другое, то я могу только ухудшить вот
эту суммарную величину этого разреза, просто по определению.
По выбору, напишу так, по выбору ау. Вот, это, наверное,
простое. Но более того, я могу сказать, что по индукции,
по предположению индукции, давайте я вот здесь лучше
подпишу, да, по выбору ау, но еще по предположению
индукции, поскольку ау у меня же активная, да, а я знаю,
как можно оценить c между ау и ау-1. Это сужение разреза
st на ау. Поэтому здесь я могу оценить сверху, как cs пересечь
с ау, t пересечь с ау. Вот, это просто предположение
индукции. По предположению индукции, потому что ау
активная, значит, я могу это написать неравенственно,
по предположению. Вот. Ну а что здесь? Нужна доска.
Значит, здесь я уже второе слагаемое, можно оценить
сверху так. Ау? Что-что? Ладно. Смотрите, мы уже почти
получили то, что нужно в правой части, только здесь
должно быть ав вместо ау. Но давайте покажем, что
эта штука меньше равна, чем s пересечь с ав, t пересечь
с ав, минус c, s пересечь с ау, t пересечь с ау. Если
я это покажу, то я победил, потому что у меня вот эти
штуки сократятся друг с дружкой. Получится, что
то, что мне нужно, меньше равно, чем то, что мне нужно.
Почему вот это верно? Почему вот эта штука меньше
равна такой разности? Ну, тут нужна картинка и фантазия.
Значит, давайте я перепишу вот этот неравенственный,
который последний хочу доказать. Давайте я перепишу,
перенеся вот эту штуку налево. Так. То есть я хочу
показать следующее. Хочу, что c, s суженное на ау, t суженное
на ау, плюс какая-то странная шняга между одной вершинкой
и ав-1 без ау-1, меньше либо равна, чем весь разрез
на ав. Вот. Хочу такое доказать. Ну, давайте просто посмотрим
на картинку, поймем, что это очевидно. Смотрите, что
такое вот это вот слагаемое? Это все вот это вот в точности.
Это ребра между ав и всеми вершинками, которые лежат
вот здесь вот. То есть в большом облочке, но не в маленьком.
Потому что вот оно ав, вот они все в точности, а
большой в а-1 без ау-1. А, пардон, еще вот такое ребро, да?
Да, потому что там без ау-1, значит это тоже учитывается.
Вот. Хорошо. Значит второе слагаемое. Первое слагаемое
это суммарное capacity между вот этим маленьким кружечком
и этим маленьким кружечком. Давайте другой цвет. Это все
вот это вот. Ну понятно, что сумма это не больше, чем
настоящий разрез между сав, ну точнее вот этим вот
с пересечь сав и т пересечь сав. Потому что еще
кейма и ребра, например, не учли. Ну, например, вот
такие и вот такие. Поскольку у меня все не отрицательно.
Да, я забыл сказать, что ну как бы в графах всегда
подразумевается, что сто capacity не отрицательные.
И поскольку я здесь какие-то capacity только не доучел,
то значит, понятное дело, я получил в сумме не больше,
чем величина разреза, потому что просто какие-то ребра
не учил. Все, очевидно. Значит, повторю. Если у меня вот
то доказано, а мы только что это на картинке доказали,
то у меня есть вот это неравенство просто перенесением там
и новослагаемое направо. Дальше вот эти два сократятся.
И у меня получится требуемое неравенство, что разрез
между активной вершиной и всеми предыдущими не превосходит
сужение нашего разреза на АВ. Вот, немедленно получается отсюда.
Вот, значит, лему мы доказали. Для всех активных вершин мы такое
неравенство можем написать. Ну а теперь смотрите, на самом деле
понятно, что АН всегда активная. Значит, лему мы доказали.
Продолжаем. АН всегда активная. Ну почему? Потому что мы знаем,
что АН и АН-1 в разных долях. Просто потому что С и Т это
разрез между ними. Значит, они обязаны быть в разных долях.
Потому что у меня АН, скажем, в Т, а АН-1 в С. Значит, эта
штука активная. Поэтому я могу для вершины АН написать условия
моей леммы, точнее утверждение леммы. Ну давайте его и напишем.
По лемме. Ну извините, это просто ЦСТ. Потому что АН-то все вершины.
Ну, еще раз, там неважно. То есть либо так, либо, как обычно, в С.
Это неважно. Ну вообще я могу потребовать, чтобы вот эта
штука лежала в Т, а эта в С. Но неважно. Для этого констатства
неважно. То есть я знаю, что у меня С и Т это разрез между
ними. А какой разрез между ними? Значит, они в разных
долях. Поэтому либо это, либо это. Значит, она активная
просто по определению. Ну вот, вроде все доказали. Вопросики?
Здесь, как это часто бывает, доказательства сложнее гораздо алгоритма.
Алгоритм очень простой. Там написано что-то типа DX.
Порядок выбора всех вершин. И оказывается, что на последнем шаге,
вот по вот этому, то, что мы сейчас делали, да, по лемме,
на последнем шаге мы находим MENCAT между двумя вершинами.
Между последней и предпоследней. И тогда либо это MENCAT настоящий
глобальный, либо их можно склеить и искать MENCAT в новом графе,
когда они уже склеены и находятся в одной доле. Вот смысл такой.
Так, хорошо, хорошо. Значит, тогда с такими потоками мы
разобрались. Давайте перейдем к потокам минимальной стоимости.
Потоки минимальной стоимости.
Задача. Получается, на самом деле, естественным обобщением
обычная задача про потоки, когда мы добавляем какой-то штраф,
какую-то уплату, какую-то стоимость за то, чтобы передать
сколько потока по ребру. Вот если у меня раньше на ребре
было написано только CAPACITY C, на сколько максимум поток
я могу протолкнуть, то теперь появляется новая характеристика
COST. Это стоимость протолкивания единицы потока. Сколько стоит
протолкнуть единицу потоку по этому ребру. Ну там, например,
если у вас есть какая-то сеть нефтепроводов, то это стоимость
какой-нибудь налог, налог за то, что вы передаете сколько-то
водички по трубе. И если вы пускаете здесь, давайте напишем,
что это пропускная способность, это стоимость ребра. Вот если
вы пускаете здесь поток f, то, соответственно, суммарный
штраф равен, ну по этому ребру, это f на COST. То есть сколько
единиц потока вы пустили умножить на стоимость за единицу
потока. Собственно, стоимость за единицу потока. И ваша цель
это минимизировать просто по всем ребрам f на COST. То есть если
мы пустили какой-то конкретный поток, его стоимость это просто
сумма по всем ребрам f на COST. Вот. И мы хотим, чтобы на благо
можно меньше. Понятно, что естественно требовать, чтобы
стоимость была поменьше. Ну и, соответственно, здесь есть две
задачи практически идентичные. Min-Cost-Caflow. Это когда мы хотим
найти поток величины ровно k, и при этом его сделать
минимальной стоимости. То есть мы хотим, чтобы величина
потока была в точности k, и при этом нужно минимизировать
стоимость. При этом минимизировать стоимость. Либо просто
Min-Cost-Max-Flow. Это когда величина потока максимальна. Давайте
напишу так. Величина потока максимальна, и при этом условие
минимальная стоимость имеет. При этом минимальная стоимость.
То есть среди всех потоков вот такой величины максимальной
или вот такой величины в точности k, мне нужно выбрать поток,
который имеет минимальную стоимость. Скажем, вот, столько
это потока я хочу передать. Вопрос, сколько мне придется
потратить денег, чтобы это сделать? Какую минимальную
стоимость мне нужно потратить, чтобы это сделать? Давайте
перерыв чуть пораньше сделаем, потом продолжим. Давайте
дальше. Смотрите, вот мы сформулировали две задачки.
Главное, это то, как считается величина потока. Очень
просто. За каждую единицу потока мы платим какой-то штраф.
Теперь, смотрите, так же, как в обычных алгоритмах для
поиска просто максимального потока мне понадобится
ввести обратные ребра, чтобы в каком-то смысле уметь
отменять поток текущий по ребру. То есть если у
меня есть какое-то прямое ребро с данными характеристиками
C и Kost, то я сразу к нему в пару добавляю обратное.
С какими характеристиками? Ну, в капальстве такой же будет
ноль, как обычно. По обратному ребру как бы не должно
утечь потока. Но кост здесь будет отрицательный,
минус кост. Ну, точнее, противоположный по знаку,
минус кост. Это вот как раз тот же самый смысл, что я
отменяю единицу потока текущую по ребру. Потому что
если раньше у меня здесь текла единица, я платил за нее
кост, а после этого я опускаю единицу по обратному ребру,
как бы отменяя ее, и добавляю к ответу минус кост. Это
как раз то самое. Я отменяю тот кост, тот штраф, который
я заплатил за проход по этому ребру, потому что этот
поток отменился по обратному. Поэтому как раз
введение обратного ребра с противоположной стоимостью
делает ровно то, что мы хотим, позволяет нам отменять
поток текущий по ребру. И, соответственно, возвращать
тот штраф, который мы уплатили за вот эту единицу
потока. Ну вот. Все, значит, сеть построена, обратные
ребра у меня появились, и на самом деле алгоритм тогда
будет вот такой вот. Давайте вот эту штуку я нарисую.
Как работает алгоритм поиска минимального потока
величины k. Очень просто. Я буду каждый раз в
остаточной сети искать просто кратчайший путь из
s в t. Ну, поскольку у меня здесь есть отрицательные
ребра, то форд Белманом. Я буду искать кратчайший
путь из s в t и пускать по нему единицу потока. Итак,
k раз. Потому что если здесь было
капасти c, то здесь капасти 0. Я не хочу, чтобы какой-то
содержательный поток тек по обратному ребру. Итак,
k раз. Я как-нибудь, например, с помощью форда Белмана
нахожу кратчайший путь в остаточной сети. Найти
кратчайший путь в gf. Ну и проталкиваю по нему единицу
потока. Протолкнуть по нему единицу потока. Все, вот
такой-то по алгоритму. Ну, собственно, это практически
то же самое, что, например, Эдман Скарп. Потому что
Эдман Скарп просто многократно находит кратчайший путь
в остаточной сети и пускает по нему поток, какой может.
Ну, здесь единственное, как бы, мне нужно искать кратчайший
путь не по, ну не как bfs в неориентированном графе, а
как форт Белман, потому что в графе у меня, сори, в
невзвешенном графе, извините, я говорился. Эдман Скарп
работает как в невзвешенном графе, там bfs, а здесь, поскольку
у меня ребра взвешенные, то мне нужен форт Белман. Ну
или там что-нибудь типа того. Но смысл основной вот
ровно такой. Да. Может, да. В смысле, по два ребра
взвешенные в каждую. Ну, вот такое может быть. Да,
это не страшно. Да, это не страшно. Это, конечно, может
быть такое. То есть у нас может быть, что из u вв есть
несколько ребр, из v ву есть несколько ребр, и каждому
строится обратно, и, короче, число ребра 2, то есть там
их может быть много, но это ничему нам, короче, не
мешает никак. Вот. Значит, давайте попытаемся доказать,
что это корректно. Для этого опять нужна лемма. Лемма.
Значит, пусть две леммы мне нужно. Давайте первая
лемма о декомпозиции потока. В этот раз мне придется
сформулировать. Пусть f это поток в сетеже, значит,
тогда его можно представить как сумму путей из s в t и
сумму нескольких циклов. Давайте я полностью напишу
g s t k, g s t c. Можно представить как сумму путей из s в t и
циклов. Вот. Ну, что это значит? Это значит, что любой
путь, любой поток на самом деле, это совокупность
нескольких путей и, возможно, нескольких висящих в воздухе
циклов. Ну, с путями все понятно, собственно, то как у
меня водичка течет из s в t, а циклы возникают, ну,
потому что они могут быть. Например, смотрите, если
я опускаю по вот такому циклическому маршруту единичку
потока, то, в принципе, это ничему не противоречит.
У меня вода здесь нигде не накапливается, она постоянно
течет, то есть у меня вполне, скажем, третье свойство
потока, что втекает столько же, сколько вытекает. Если
здесь везде капаси хотя бы один, то, значит, поток не
происходит в капасите, но антисимметричность, понятно,
что там, ну, просто по-противоложному, течет минус
один. Поэтому, в принципе, циклы возможны, и вот это
надо проговорить, что в разбиении, в декомпозиции
потока на пути, возможно, еще появляются циклы, но они
вот такие вот, как бы, просто там циркуляция какая-то,
она ничего не добавляет содержательного к потоку
из С в Т, но она вот возможна, какие-то такие циклы могут
появляться. Так, ну, доказательства давайте очень кратенько
что-нибудь скажу. Вот давайте посмотрим, существует
ли из С какое-то исходящее ребро с положительным потоком?
Правда ли, что здесь F больше нуля? Но если больше нуля,
вот давайте возьмем какое-то такое ребро, давайте единицу
здесь пропустим, вот здесь течет единица. Дальше встанем
сюда. По закону сохранения потока, у меня эта единица
потока должна откуда-то вытечь, то есть не может быть
такого, что здесь нет ни одного исходящего ребра с
положительным потоком, да, потому что иначе у меня было,
ну, как бы, что-то входит, но ничего не выходит. Значит,
куда-то это опять ведет, опять можно найти ребро хотя
бы с единичным потоком. Дальше делаем то же самое, тогда
мы рано или поздно придем в Т, и вот, пожалуйста, мы
нашли какой-то путь. Либо рано или поздно мы зациклимся,
значит, мы нашли, например, вот такой вот цикл. Вот.
Ну и так просто делаем, пока есть хотя бы одно ребро
с положительным потоком. Вот. То есть я просто встал
в С, иду-иду-иду по ребрам с положительным потоком,
рано или поздно, либо пришел в Т, тогда я отчленил
какой-то путь. Да, либо рано или поздно я зациклился,
значит, я нашел цикл, и вот здесь вот опять-таки могу
здесь делать минус один и решать задачу уже для как бы
меньшего суммарно текущего потока. Вот. Значит,
это мы разобрались с С, мы так исчерпали все исходящие
ребра из С с положительным потоком. Если остальские
другие вершины с положительным потоком, то, ну, опять, если
я нахожу что-то положительное, то я пускаю дничку, и так
рано или поздно я обязательно зациклюсь. Ну и, собственно,
вот я очередной цикл отрезал. Ну, короче, просто встали
и идем, просто смотрим, куда идет поток, мы рано или поздно
либо из Т вытечем, либо зациклимся. Поэтому все у нас
либо пути, либо циклы. Профит. Окей? Это вроде вот совсем
на пальцах можно понять. Теперь вторая, собственно,
лемма, которая нам нужна для доказательств корректности,
такая. Пусть f это некий поток величины k в g. Некий поток
величины k в сети g. Тогда f является минкосткофло, если
и только если в остаточной сети gf нет циклов отрицательного
веса. Нет циклов? Ну, давайте нанесем отрицательные
стоимости. То есть по факту мы можем доказать критерии
того, что поток является минимальным. Поток является
минимальным потоком вот той самой величины k. Поток
является минимальным потоком величины k, если и только
если в остаточной сети gf нет циклов отрицательного
веса, нет циклов отрицательных стоимости. Пока я ничего
не говорю про это. Без относительно исходного графа вот это
всегда верно. Доказательства. Ну, в одну сторону вроде
понятно. Слева направо уже понятно. Потому что если
вдруг f это минимальный поток, но в остаточности есть цикл
отрицательной стоимости, давайте я по этому циклу пущу
днику потока, стоимость уменьшится. А потому что
величина потока не изменилась, потому что у меня циркуляция
всего лишь, само k не изменилось, и при этом добавилась
отрицательная стоимость. Значит поток уменьшился по
стоимости. Так как можно добавить поток по циклу?
А это неважно. У нас в определении нигде не написано, и собственно
вот здесь в виде композиции потока нам никто не запрещает
иметь вот такие странные просто кружочки где-то в воздухе
витающее. Такое вполне валидно по определению.
Так, обратно чуть похитрее.
Давайте обратно от противного. От противного.
Значит пусть в gf нет отрицательных циклов, но при этом f не
минимальный. Пусть в gf нет отрицательных циклов, но f не
минимальный. Не минимальный.
Давайте тогда рассмотрим настоящий минимальный поток
в величины k. Пусть f звездочка это тот самый минкост
ковлоу. То есть пусть f не настоящий, а в величины
k настоящий. На поток минимальной стоимости в величины
k. Дальше рассмотрим следующую странную штуку. Мы введем
поток равный разности потоков f звездочка минус f.
То есть просто на каждом ребре я посчитаю, вот если у меня
f звездочка тек такой-то поток, f тек такой-то поток, я их вычитаю
и говорю, что теперь по этому ребру течет просто их разность.
Ещё раз? А что значит ребра нет? У нас сеть-то одинаковая.
f звездочка на каждом ребре определён. У нас определение
потока, что это функция из множества ребер, в целое число.
Поэтому это для каждой ребре определено. Возможно она 0,
просто не течёт потока, но тогда здесь 0 написано.
Я утверждаю, что это поток в сети gf.
Почему? Давайте докажем. Давайте просто по определению
покажем, что этот поток, давайте уточним, что здесь просто
порёберно я беру и вычитаю. На каждом ребре у меня величина
потока равна разности вот этих двух штук для любого ребра E.
Я утверждаю, что такая штука это поток в gf.
Почему? Давайте вспомним определение потока и все
тарисовости проверим. Во-первых, мне нужно, чтобы поток не
происходил к апассити. Что такое E? Давайте перепишу, что
f звездочка от E минус f от E. Дальше, поскольку f звездочка
это поток в исходной сети, то f звездочка ограничена
капасситию, а минус f от E я так и перепишу. На раз
звездочка потока, то звездочка ограничена капасситию.
Но это в точности остаточная capacity ребра E. То есть это
capacity ребра E в сети gf. То, что мы хотим.
Второе, антисимметричность. Ну, вроде совсем тривиально.
Если я рассмотрю g на ребре УВ... Ой, даже писать лень.
Ну давайте уж напишем. Вот. Поскольку f и f звездочка это
потоки, то они антисимметричны, поэтому после свопа
аргументов у меня минус вылезет за скобку.
Но это просто по определению минус g от ВЛ.
Поэтому антисимметричность тоже есть. g от УВ равно минус g от ВУ.
Ну и третье, сохранение потока. Ну тоже, наверное, очевидно.
Я не буду это расписывать. Если я рассмотрю произвольную вершину
отличную от старта и финиша, то что такое сохранение потока?
Давайте на пальцах я это покажу. Сохранение потока это когда втекает
столько, сколько вытекает. Ну смотрите, понятно, что если в В
с помощью потока f звездочка втекло сколько-то и вытекло сколько-то,
то суммарный баланс звездочки это 0. То же самое относительно f.
Сколько-то втекло, сколько-то вытекло, суммарный баланс 0.
Но теперь если я вычту 0 из 0, получится 0. Потому что у меня
на каждом ребре будет написана какая-то разность, но если я должен
просуммировать буду, когда я суммирую вот эти вот жешки, я суммирую f-ки
и вычитаю сумму вот этих f-ок. Но если это 0 и это 0, то получается, что сумма
тоже будет нулевая. Поэтому сохранение потока тоже будет.
Нормально расписать, просто по определению, что такое поток, как бы
вот сумма вот этих штук, расписать, что g это f, f звездочка минус f,
но каждый из них распадается в 0 и получается 0-0.
Вот, поэтому реально поток.
Зачем это нам нужно?
А какой величины этот поток?
Загадка.
Было два потока величины k, мы их вычули, что получилось.
Какой величины, какой поток мы получили?
Наверное, 0 раз k минус k.
Значит, более того, это не просто какой-то поток, но поток величины 0.
Потому что величина потока
это сумма f-ок, исходящих из старта.
Вот у меня есть старт, мне нужно просуммировать все потоки, выходящие отсюда.
Но смотрите, если я знаю, что сумма f звездочек это k,
вот на этих ребрах сумма звездочка это k, потому что f звездочка – это поток величины k.
Я знаю, что сумма f-ок это k, потому что f – это тоже поток величины k.
Теперь, если я их все вычту, из каждой f звездочки вычту f,
ших равна нулю. Суммарно известно, ничего не вытекает. Поэтому это не просто какой-то
поток, это поток величины ноль. А значит, по леммио декомпозиции потока, g на самом
деле просто представляет собой объединение нескольких циклов. Потому что раз это поток
величины ноль, то путей в нем нет. Наличие пути означало бы, что по нему течет
единичка потока, значит там хотя бы единица величина будет. Значит, по леммио
предыдущей g это так называемая циркуляция. Значит, раз g поток
величины ноль, то g это циркуляция. То есть, распадается в сумму циклов.
И это, напоминаю, все происходит в остаточной сети gf. Не в исходной сети, а вот в остаточной, в gf.
Потому что вот здесь вот я когда доказывал, что поток не больше чем capacity, вот это g не
больше чем c, cf. Здесь важно, что именно остаточная capacity, потому что с обычной
capacity я бы такого не мог доказать. То есть, я не всегда верно, что уже меньше чем c,
если вычесть f, которое могло быть отрицательным, то получится как раз верное уже неравенство.
Так, ну и чего? И мы же знаем на самом деле, что стоимость f звездочки, давайте я обозначу
кост от потока, это его суммарная стоимость, суммарная стоимость потока.
Тогда мы знаем, что кост от f больше, чем кост от f звездочка. Мы знаем по линейности, что кост от g
это кост от f звездочка минус кост от f, значит это меньше нуля. То есть, мы получили циркуляцию
отрицательной стоимости, а циркуляция это набор нескольких циклов. А раз набор нескольких циклов
суммарно имеет отрицательную стоимость, то по крайней мере один цикл там отрицательный.
Значит, по крайней мере один отрицательный цикл есть в gf, есть противоречие, мы предположим, что их нету.
Ну как?
Так, вроде доказали. Мы доказали критерий минимальной стоимости конкретного потока.
Поток является потоком минимальной стоимости, если в осадочной сети относительно него нету отрицательных циклов.
Тогда. Значит, тогда, тогда, тогда. Что мы теперь можем сказать?
Давайте утверждение. Пусть в исходной сети g нет циклов отрицательного веса.
Нет циклов отрицательного веса. И давайте мы запустим вот тот наш алгоритм тупой,
который просто многократно находит кратчайший путь, и пускает там в единичку потока.
Вот давайте мы его запустим на несколько терраций. Давайте на одну.
Давайте на одну. Пусть p это кратчайший путь в g, ну естественно, из s в t.
Ну и соответственно поток f пускает по нему единицу потока.
f поток величины 1 вдоль этого пути, величины 1 вдоль этого пути.
Тогда утверждается в gf тоже нет отрицательных циклов.
Тоже нет отрицательных циклов. А значит, полемия f это минимальный поток величины 1.
Итак, еще раз утверждение. Предположим, что изначально в самой сети g,
которая нам на вход подается, вот пусть в ней изначально нет циклов отрицательного веса.
И давайте мы найдем кратчайший путь из s в t, пусть это путь p. Мы по нему проталкиваем единицу потока,
то есть f это просто единица потока вдоль этого пути p. Тогда оказывается, что если я построю
остаточную сеть gf, то в ней тоже отрицательных циклов не будет. И если мы это докажем,
то получается, что проталкивание единицы потока по кратчайшему пути нам не порождает отрицательных
циклов. То есть если я пустил единицу, циклов нет отрицательных, опять пустил единицу,
опять циклов нет отрицательных, по этому утверждению. И так многократно повторяя,
у меня на каждом шаге получается, что в остаточной сети не будет циклов отрицательного веса.
Ну а раз их нет, то по олемме мы каждый раз будем получать минимальный поток,
минимальный стоимость, поток минимальной стоимости данной величины. Вот доказательства.
Ну, наверное, от противного опять. Пусть они появились, пусть в gf появился какой-то
отрицательный цикл. Отрицательный цикл с. Так.
Давайте я тогда нарисую, что происходило. Вот смотрите, у меня был какой-то кратчайший
путь из s в t, это был путь p. После перехода к остаточной сети, после перехода к gf,
что происходит? Ну, возможно, появляются какие-то отрицательные ребра. Сорри,
обратные ребра. Да, появляются обратные ребра. Ну, то есть они как бы и так были,
но в остаточной сети они появляются в том смысле, чтобы по ним положительная
копасть остается. Потому что я считаю, что ребра нулевой копасти я игнорирую, не учитываю
во всех этих обсуждениях как бы нет нулевых копасти. Так вот, и здесь появился отрицательный
цикл. Ну, видимо, он тогда вынужден хотя бы одной из этих ребр задействовать, потому что
иначе он был бы и в исходном графе, получили бы противоречие. Ну, давайте как-нибудь я его
нарисую. Что-нибудь. Он на самом деле довольно мерзко может выглядеть. Давайте я что-нибудь
достаточно мерзко нарисую. Вот так вот. Нет, ладно, мне лень. Какой такой цикл? Пусть будет такой цикл.
Это цикл с отрицательным весом. Тогда давайте рассмотрим поток P плюс C. Вот на этой картинке
что такое P плюс C? Это вот здесь нужно единичку отменить, а вот здесь единичку пропустить.
Получается, что P плюс C это вот такой вот какой-то путь из С в Т. То есть, если я складываю
единицу потока здесь и единицу потока текущую по этому циклу, то у меня на общих ребрах поток
отменяется как бы, зато вот эти вот ребра включаются в наш путь. Что получается? Получается,
что вот этот поток P плюс C это на самом деле поток величины 1 в исходной сети. Поток величины 1 в G.
Ну, понятное дело, что его величина не изменилась, потому что это поток величины 1, а это поток
величины 0. В сумме идет 1. Ну и почему это поток в сети G? Ну, потому что как раз вот эти вот обратные
ребра, если тут и появлялись, то они сократились, потому что тут один и здесь один. Поэтому обратные
ребра как бы как раз исчезли. Вот. Хорошо, но мы знаем, что по лемме декомпозиции потока поток
величины 1 это путь плюс, возможно, несколько циклов. То есть, на самом деле, P плюс C у меня картинка
такая хорошая получилась, что у меня просто путь. Но в общем случае, это путь какой-то там кривой и,
возможно, несколько циклов. То есть, если здесь C как-нибудь более мерзко бы выглядел, у меня,
возможно, было бы такое, что после суммирования с П-шкой какие-то ребра аннигилируют и у меня,
соответственно, могли бы возникнуть какие-то такие циклы в висящем воздухе. Но зато, смотрите,
я знаю, что поскольку все происходит в сети G в изначальной сети, я знаю, что в ней отрицательных
циклов нету, поэтому стоимости всех вот этих товарищей не отрицательны. А здесь стоимость этой
штуки хотя бы такая же, как стоимость у P. Ну просто потому, что P это был кратчайший путь из С в Т в
исходном графе. А это какой-то путь из С в Т в исходном графе. Значит, его стоимость может быть только
больше равна, чем стоимость P, так как P кратчайший. Ну и значит, мы получили, что суммарная стоимость
нашего потока P плюс С больше или равна стоимости P, потому что все циклы у меня не отрицательные,
а этот путь имеет вес хотя бы такой же, как у P. Поэтому мы получили такое неравенство. Но это
противоречит тому, что кост С отрицательна. Потому что стоимость у меня, понятное дело,
линейная по потоку, а суммирование потоков должно дать сумму стоимости. Противоречие.
Вот. Ну все, мы доказали, что отрицательных циклов не возникают. То есть, если их не было изначально,
то их никогда и не возникнет. Поэтому корректно работает наш алгоритм, который я в самом начале
заявил. Если в исходной сети нет отрицательных циклов, я просто многократно нахожу в остаточной
сети кратчайший путь с помощью Форда Белманна, например, пропускаю по нему единицу потока и
перестраиваю остаточную сеть. Отрицательных циклов никогда не появляется, поэтому Фор Белманн
всегда за 1-1 итерацию найдет нормальный кратчайший путь, и по нему можно будет пускать потоки. Все будет
хорошо. Вот. Давайте зафиксируем, что асимптотика у меня будет, видимо, к на ve, потому что я вот столько
раз запускаю Форда Белманна. Просто Фор Белманн. Вот. Ну а корректность следует из-за того, что вот мы
сейчас все доказали. Так, в принципе, это уже достаточно хорошо. К раз пустить Фор Белманна,
это уже достаточно хорошо. Но, на самом деле, можно эту штуку ускорить. Можно использовать так
называемые потенциалы Джонсона. И вместо Фор Белманна пускать дэйкстру, которая работает быстрее.
Так, сейчас будет магия арифметическая. Смотрите, в чем проблема дэйкстры по сравнению с Фор Белманном?
В том, что она не умеет работать с отрезательными ребрами. В каком смысле проблема и у Фор Белманна,
и у дэйкстра. Но мы сказали, что их нет. Мы считаем, что их в исходности нет. Они не появляются,
поэтому отрезательных циклов нет. Давайте забыли про них. Понятное дело, что бывают отрезательные
ребра. Когда я ввожу у каждого ребра обратное, у него будет противоположная стоимость, поэтому там
явно одно из них отрицательно. Вот. Дэйкстр с ними не умеет работать. Так вот, давайте сделаем что-нибудь,
какую-нибудь магию, чтобы все веса стали не отрицательными. И тогда уже можно будет пускать дэйкстру.
Для этого мы хотим придумать какую-нибудь такую функцию, которая каждой вершине сопоставляет число.
И тогда стоимость каждого ребра у В преобразуется в стоимость потенциала Фи, с учетом потенциала
Фи следующим образом. Значит, это будет кост плюс потенциал начала минус потенциал конца. Вот просто
если было ребро, то давайте мы добавим к его стоимости Фи от начала минус Фи от конца. Это будет у
меня новая весовая функция, новая функция стоимости. Чем хорошо такое преобразование? Оно хорошо тем,
что оно сохраняет кратчайшие пути. Потому что, смотри, давайте я рассмотрю произвольный путь. Вот
какой-то путь. Давайте из х в у. Что меняется с его стоимостью после перехода к вот этим вот новым
стоимостим? От коста к кост Фи. Ну понятно, смотрите, у меня стоимость этого ребра меняется на Фи от х
минус Фи от вот этой вершинки, там не знаю, z. Стоимость этого ребра меняется на плюс Фи от z,
минус Фи вот этой вот A. Потом будет плюс Фи от A минус Фи от B минус Фи от B плюс Фи от C. Ну и так
далее, получается, что все вот эти промежу 중요ны потенциалы умрут. И останется только плюс Фи
от x минус Фи от y. То есть новая потенциальная стоимость пути p, это его изначальная стоимость
в исходном графе. Плюс потенциал начала пути минус потенциал конца пути Фи от x минус Фи
Ну а поскольку у меня x и y так фиксированы, если я ищу пути из x в y, то у меня эта штука какая-то константа,
а значит у меня все пути предсказуемо изменили свою стоимость. Каждый путь изменил стоимость на константу,
которая не зависит от самого пути, а зависит только от начала и конца, но они у меня считаются фиксированы.
Пути у меня между одной и другой вершиной.
Значит в частности сохранятся кратчайшие пути, но раз сохранятся кратчайшие пути, то значит Dextra
сможет находить кратчайшие пути в том графе, потому что Dextra ищет кратчайшие пути,
значит это будет кратчайшие пути и в обычной вот этой вот стоимостьной функции кост.
Мне осталось потребовать, чтобы эта штука была не отрицательна, и тогда я смогу применять Dextra.
Добьемся мы этого очень простым трюком. Мы потребуем, чтобы потенциал каждой вершины в точности совпадал с расстоянием от s до нее.
Потенциал равен расстоянию. Почему тогда будет верно, что все косты не отрицательны?
Вот эти вот новые, почему кост Фи для ОВ больше равно нуля?
Ну на самом деле просто по неравенству треугольника.
Потому что что такое кост Фи? Это кост ребра плюс начало, минус конец.
Потенциал это расстояние от s до них.
Смотрите, вот здесь вот написано расстояние от s до u плюс стоимость этого ребра.
А там написано минус расстояние от s до v.
Понятное дело, что расстояние от s до v не больше, чем вот эта вот сумма.
Давайте напишем, что расстояние от s до v не больше, чем дист su плюс кост v.
Ну значит вот эта вот слагаемая, точнее вычитаемое не больше, чем уменьшаемое.
Поэтому это больше сумма. Профит. Просто не нравится треугольника.
Ну давайте пытаться поддерживать. Если у меня это выполняется, то можно пускать dx у Ранифорд Белмана.
Потому что у меня все косты стали не отрицательными.
Хорошо.
Давайте поймем, что происходит, если опускаю dx тогда.
Ну хорошо. Тогда как у меня будет выглядеть алгоритм на самом деле?
Понятное дело, что мне нужно вначале хотя бы один раз Форд Белмана пустить.
Потому что мне же нужно откуда-то дисты взять. Для потенциала мне нужны дисты.
Но в исходной сети есть отрицательные ребра.
И ничего лучше, чем Форд Белмана, вот здесь пока не получится.
То есть один раз его нужно запустить.
То есть один раз я запускаю Форд Белмана.
Один раз.
Чтобы посчитать дисты, а значит потенциалы изначальные.
Потом дальше. Смотрите.
Вот если я один раз его пустил, пересчитал потенциал и пересчитал косты все.
Кост с индексом Фи стали.
Тогда вот в этой новой стоимостьной функции кост Фи,
если я рассмотрю кратчайший путь из S в T,
он на самом деле имеет нулевой вес.
Все вот эти косты будут нулевые.
В кост Фи, в новой стоимостьной функции.
Ну потому что все эти ребра лежат на кратчайшем пути из S в T.
А значит вот здесь вот неравенство треугольника, везде строгое равенство будет.
Раз это кратчайший путь, то все эти ребра лежат на кратчайшем пути.
А значит здесь не такая картинка, а вот такая.
Сначала вот S до U, потом с помощью ребра до V.
Поэтому здесь на самом деле все будут равенства.
И кратчайший путь будет иметь вес с точностью 0.
То есть я буду пускать поток по пути стоимости 0.
Но когда я пускаю здесь поток величины 1,
у меня возникают обратные ребра.
Но они сейчас тоже имеют нулевой вес.
Потому что стоимости обратных ребров обратно.
И это сохраняется даже после навешивания потенциала,
потому что здесь они поменяются местами, поменяются знаками,
и как раз все сохранится, останутся нули.
То есть при введении обратных ребров они тоже будут иметь нулевой вес.
А значит отрицательных стоимости не появятся.
Единственное, что может сломаться, это вот это вот может нарушиться.
Потому что у меня появляются какие-то ребра,
какие-то возможно исчезают, если ребро насыщается.
Значит вот это вот уже меняется.
Давайте их пересчитаем просто.
Благо отрицательных ребров не появился, а значит можно пускать dx.
Еще раз, да?
Какая тогда схема?
Я один раз пересчитал потенциал в самом начале с помощью Форд Белмана.
Затем, чтобы найти кратчайший путь,
мне нужно просто найти путь по ребрам нулевого веса из ft.
Я пускаю здесь единицу потока, у меня появляются обратные ребра,
а здесь пускаю dx и пересчитываю потенциал.
Потому что здесь уже можно пускать dx,
потому что нету отрицательных ребер.
Но потенциал придется изменить, потому что у меня изменился граф.
А значит вот эти вот штуки могли измениться.
Ну а потенциал можно изменить просто зная вот эти дисты.
Я их знаю с помощью dx и просто пересчитываю потенциал.
Вот.
Все, значит алгоритм будет такой.
Давайте я такой супер псевдокод напишу.
Мне нужна процедура применить потенциал фи.
Это вот как раз вот это преобразование, переход от кост к кост фи.
Для любого ребра я его стоимость изменяю на фи от у минус фи от в.
Меняю стоимость вот как раз так, как потенциал предписывает.
Дальше.
Изначально я говорю, что пусть фи это Форд Белман
в нашем графе и применяю этот потенциал.
Затем карас.
Нахожу кратчайший путь, пуская по нему единицу потока.
Найти и пустить единицу потока по кратчайшему пути.
Затем считаю dx.
Потому что все веса не отрицательны.
Я могу пустить dx и опять применяю потенциал.
Потому что я хочу, чтобы у меня выполнялось вот это вот соотношение.
Если я просто его прибавлю, если я потенциал пси прибавлю к изначальному потенциалу фи,
то у меня перестроится граф, перестроятся все стоимости, но опять сохранится вот это вот свойство.
Потому что если в этой сети все выполнялось, то мне нужно просто применить новый потенциал пси,
чтобы опять все стало выполняться в новом графе после пускания единицы потока.
Ну и тогда асимптотика будет уже что? Уже будет v на e,
плюс карас dx, ну dx там e лог v, например.
Вот. Уже поприятнее.
Все, спасибо.
