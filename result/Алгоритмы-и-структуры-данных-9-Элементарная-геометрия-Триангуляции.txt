Хорошо, давайте тогда начинать. Давайте начинать. Девятая лекция у нас и 28 октября.
Значит, мы плюс-минус разобрали все, что я хотел рассказать про теорию чисел в
там всякая математика, комбинаторика, что-то такое. И сейчас переходим к блоку про геометрию.
Посмотрим тоже, что успеем, что будет интересно нам разбирать. Сегодня такая вступительная,
довольно простая, надеюсь, лекция. Это элементарная геометрия и триангуляции.
Сначала поговорим про то, что, я надеюсь, всем из вас известны из курсов либо линейная алгебра,
либо алгебра геометрии. Как вообще можно задавать точку на плоскости? Мы пока что
будем жить в R2, то есть на обычной плитке плоскости, в пространство там где-нибудь.
Чуть позже выйдем в R3. Как хранить точки, что с ними можно делать, всякие скалярные векторные
произведения, как пересекать прямые, как находить расстояние от точки до прямой. Вероятно,
вы все эти формулы уже знаете, поэтому мы по ним быстро пройдем. Возможно, что доказывать не
будем, но просто чтобы повторить, осуществляйте в памяти, потому что когда-нибудь это все точно
будет, все эти формулы будут нужны. Так, ну поехали. Значит, сначала точки, векторы, как мы их
представляем, что мы от них хотим? Предлагается, что мы живем в R2 на обычной плоскости. Ну тогда
все, что у меня есть, это две координатные оси X и Y. Если, соответственно, каждая точка задается
своей проекцией на оси абсцисс и на оси ординат. То есть мы сейчас будем говорить по модуле
программирования только о полярных и ордонормированных декартовых координатах, да? Так, что такое полярные,
я не очень понял. Ну, когда точка задается радиусом и углом от абсцисс. Ну, я бы сказал, что мы будем
говорить только обычными координатами X и Y, то, что вы называли ордонормированными. Там, где нам
нужны будут всякие углы, мы это будем высчитывать исходя из этих координат. То есть у нас основная
форма представления — это вот в ордономерном базисе, с каким коэффициентом нужно взять два
базистных вектора, чтобы получить наш вектор. Вот, и при необходимости мы будем переходить в ту форму,
которая будет удобнее. То есть, когда мы будем говорить про повороты, мы там будем считать угол,
но это вот базируется все на одном нашем. То есть, даже полярных не будет, не то, что этих самых
наклонных осей, да, на финнах? Ну, видимо, не будет, да. Ну, ладно, хорошо. Ну, то есть, кажется,
все, что нам нужно, оно выражается через X и Y, и поэтому без этого сможем бойтись. Итак,
любая точка, она сдается своими двумя координатами A и B, проекция на OX, проекция на OEDIC. Вот,
и здесь же мы говорим, что, в общем-то, каждая точка, она однозначно соответствует вектору,
такому радиус-вектору из точки 0 в нее же, в точку B. Тем самым у меня, как бы, точки и векторы,
такие радиус-векторы из начала координат в эту точку, они друг другу соответствуют и имеют
одни и те же координаты. Потому что, если точка P имеет координату AB, то, собственно, векторы из 0,
в эту точку имеют те же самые координаты AB. Поэтому мы структуру точку и структуру вектора будем
хранить в одной большой структуре, которую, ну, я обычно называю point. Потому что, ну,
скорее главное, что нам нужно, это, что это точка, потому что любой вектор, он как бы сдается своим
концом, когда мы знаем вначале, что это 0, 0. Вот какая структура point. Ну и, соответственно,
здесь основные поля, это A и B. Давайте, скажем, пока считать, что у меня все координаты целочисленные,
насчет меня будет два поля, давайте не A и B, я назову координаты, соответственно, OBC. Вот,
ну что, например, если у меня есть теперь две точки какие-нибудь на плоскости P и Q, то чтобы
посчитать вектор между ними, чтобы задать вектор с координатами равными вектору из P в Q,
то мне нужно написать что-то примерно такое, мне нужно написать Q.X-P.X, Q.Y-P.Y. Мне нужно просто
посчитать разность по X, разность по Y, и это будет наш задержавший вектор, давайте я назову V со
стрелочкой, V со стрелочкой. Это такой вектор из P в Q, да, конец, значит, координаты конца,
минус координаты начала из P в Q. Ну и, соответственно, здесь тогда можно написать оператор минус на
наших точках, чтобы он по двум точкам строил векторы из одной в другую, ну или просто как бы по
компонентных вычитал. Вот здесь внутри можно написать что-то в стиле point оператор минус,
принимая там какую-то другую точку по константной ссылке. Я не знаю, как вы здесь привыкли писать,
я обычно пишу здесь other, передаю как бы другую точку еще в конце const, чтобы ничего не менять,
ну и return, соответственно, точку с координатами X минус other X, Y минус other Y.
Вот подразумеваю, что у меня есть конструктор по двум координатам, просто конструктор точки по
координате X и в координате Y. Все, тогда мы можем очень легко считать вектор между двумя точками.
Ну и то же самое можно определять там, сложение точек как сложение векторов, если есть два вектора,
там у и в какие-то, у и в, то мы можем определить их сложение, как вот диагональ параллограмма
натянутого на эти два вектора, вектор вот такой вот у плюс в, ну и соответственно его координаты это
просто покомпонентное сложение уX плюс вX и уY плюс вY, я даже писать не буду, это опять
покомпонентная просто операция сложений. Можно также что сделать, можно увеличить вектор в какой-то
константу раз, можно имея вектор у, значит давайте здесь подпишем, что это мы подразумеваем оператор
плюс, оператор плюс сложение двух векторов, здесь по вектору у я тоже могу построить какой-нибудь
вектор кау, взять этот вектор, отложить несколько раз, то есть умножить на к, тогда это реализуется
с помощью оператора умножить на какое-то там целое число к, пока что если мы считаем, что все координаты
целые, да и что у меня это всегда выполняется, то как будто бы я всегда беру только целое число раз
этот вектор откладок, тогда к как будто бы целый. Ну вот такие базовые операции очень легко пишутся
с помощью нашего конструктора по двум координатам по х и по у, и очень удобно с ними работать,
если вы напишите именно это как оператор, то вы в общем-то в прям в коде можете работать с этими
объектами как на бумаге, то есть пишите на бумаге там не знаю, вектор у минус вектор в, и точно то же
самое у вас будет в коде, просто у минус в, вот прям тот же самый минус, который вы пишете на бумаге,
это также у вас будет в коде, вот это довольно удобно, чтобы там не писать всякие функции типа
там subtract вектора, писать один оператор и работать так же, как вы пишите на бумаге.
Следующий примитив, который нам нужен, это прямая struct line, ну и соответственно мы хотим от нее,
чтобы она как-то, чтобы эта структура однозначно создавала какую-то прямую на плотности.
Структура прямая должна как-то, вот нам нужно как-то создавать прямую на плотности.
Даже не знаю, вы наверное и так все знаете, но все равно проговорю, что обычно прямые удобно,
ну или по крайней мере принято представлять в виде х равно кх плюс b, и тогда можно было бы сказать,
что прямую мы будем хранить как-то эти два коэффициента кайбы. Это как бы в принципе валидно,
но к сожалению в таком виде задаются не все прямые, а именно они задаются вертикально прямые,
то есть такие прямые, у которых х не меняется, у них какой-то х фиксированный, а y любой,
и тогда вот такое уравнение здесь не подойдет, не подходит, и значит наша форма, представление
прямой в виде кх плюс b, она ну как бы исключает из рассмотрения вертикальной прямой. В принципе с этим
можно было бы и пожить, сказать, что перед тем как обрабатывать все что нужно, перед тем как решать
задачу, мы повернем всю картинку на какой-нибудь случайный угол альфа, где альфа там ну равномерно
выбирается из интервала 0.2b, и тогда скажем, что тогда с вероятностью 1 у меня не будет
никаких вертикальных прямых, и соответственно таких крайних случаев не возникнет. Это валидный
подход, но здесь когда мы переходим к поворотам, когда мы сначала всю картинку поворачиваем на
альфа, у меня конечно, во-первых, сразу точно у меня не получится работать в целых числах,
потому что поворот на альфа это точно всякие косинусы, синусы, умножения всякие, это точно
переход к даблам или лонг даблам, короче к числу с плавающей точкой. Да? Да, ну на самом деле, если мы
работаем в двумерном варианте, то возможно можем обойтись без синусов косинусов, использовав
комплексные числа и умножение на комплексную экспоненту. Ну хорошо, в каком виде вы храните
комплексные числа? Ну да, а там тоже с даблами все, не спорю, но как бы, что вообще лучше,
кстати, будет, косинусы, синусы или комплексные экспоненты? Это одно и то же. Комплексная экспонента,
она, ну по крайней мере, насколько я знаю, есть этот класс комплекс C++, и он как хранится? Он
хранится к веществной части и мимо части. Ну да. Поэтому нет разницы, поэтому мимо экспонента это
косинус альфа запитая и синус альфа. А, то есть он не хранит это? Ладно, я понял. Да, но как бы,
он же не может себе написать, что там z равно e в степени и альфа, он же, ну как бы, ему нужно знать,
ну короче нет, все равно там нужны обе координаты. В итоге, в этом подходе, если переходить
к повороту, то возникает много всяких поворотов, возникает много неточностей, и мы будем иногда
стараться следить за тем, чтобы не переходить к веществным числам, когда это не нужно. Вот и здесь,
если у меня исходные числа были целые, то, в принципе, можно без этого обойтись. А именно,
мы будем хранить прямую в виде трех координат, не как здесь было две координаты k и b, у меня
будут три координата a, b, c. Соответственно, прямая у нас представляется в виде ax plus by plus c
равно 0. Ax plus by plus c равно 0. Вот в таком виде уже задается любая прямая, и строго вертикальная,
и строго горизонтальная, и любая другая наклонная. Единственный, ну такой, возможно, минус этого
подхода в том, что прямая тогда задается неоднозначно, потому что, если вы умножите все
три коэффициента a, b, c на какую-то общую константу, скажем, лямбда, тогда у вас, ну не нулевую,
понятное дело, тогда у вас уравнение не изменится, потому что если вы левую часть умножите на лямбду,
правую на лямбду, то у вас ничего не поменялось. То есть как бы у уравнения прямой есть несколько
одинаковых записей, когда у вас все константы отличаются в лямбду раз. Ну, бог с ним. Нам
главное, чтобы была хоть какая-то запись, чтобы было хоть какое-то представление для прямой.
Можно построить конструктор прямой по двум точкам. Самый простой способ построения прямой,
ну или даже, возможно, не самый простой, а самый частый, частый нам нужный, это прямая по двум
точкам. Значит, пишем конструктор по каким-то двум точкам. Const point p, const point q. Есть у нас два
объектика. Мы хотим, точнее есть две точки, мы хотим по ним построить прямую. То есть найти такие
ABC, что точки по IQ на них лежат. Так, значит, давайте я оставлю место под код, а внизу напишу следующую
форму. Если у меня есть точка p с координатами x1 и y1 и точка q с координатами x2 и y2, мы строим
вот такую прямую. Тогда нам на роль ABC подойдут следующие, следующие штуки. Значит, на роль p
можно взять, на роль a, извините, y1-y2, на роль b можно взять x2-x1, на роль c x1-y2-x2-y1.
Вот, значит, я утверждаю, что если взять такие ABC, то они нам подойдут. То есть, если рассмотреть
потом прямую ax плюс bq плюс c равно 0, то у них будут лежать точки по IQ. Если предположить, что
точки по IQ изначально различные, то есть прямая однозначно восстанавливается, то вот ее можно
сохранить в таком виде a такое, b такое. По формализму это докажем. Чтобы нам доказать,
нужно просто подставить точки по IQ в нашу уравнение прямой, в ax плюс bq плюс c, и проверить,
что на обеих точках достигается равенство 0. Сделаем это для точки по a на x плюс b на y плюс c.
Я подставил точку по в уравнении прямой. Раскрываем скобки. Даже, наверное, не буду
раскрывать, просто давайте посмотрим, что здесь сокращается. Вот есть x1-y1,
которое здесь сократится, да, слева с плюсиком, справа с минусиком. Дальше есть минус x1-y2 плюс
x1-y2. Есть x2-y1 минус x2-y1. Получился 0. То же самое можно проделать для P. Если я подставлю координат
x2 и y2, то, понятно, получится тоже самое, но давайте тоже проверим. x2-y1 минус x2-y1,
минус x2-y2 плюс x2-y2, минус x1-y2 плюс x1-y2. Тоже получился 0. Ну все, значит, мы действительно,
если мы задаем просто ABC вот так, вот так, то получаем прямую, на которой лежат обе наши точки,
собственно, что нам нужно. Нам нужно было построить такую прямую, на которой лежали все, что нужно
лежит, точнее, наши две точки лежат. Вот мы ее получили. Повторюсь, их там несколько. Если я умножу
ABC на одно и другое число лямбда, не нулевое, то получится тоже корректное уравнение нашей прямой.
Но нам не нужно хранить все, нам достаточно кого-то одного, нам достаточно какого-то одного
представления нашей прямой. И здесь тоже очень приятно, что корректные координаты x и y были целыми,
то ABC тоже останется целыми, потому что здесь разность и произведение. Все точки будут целыми.
Вот, а если бы, например, делали бы в виде y равно kx плюс b, там, ну там не явно, ну даже явно,
да, зашитка в центре наклона k, и там явно будет нужна какая-то дробь. k там точно будет какой-то
нецелое обязательно. И, то есть, тут у нас даже как бы два выигрыша. Во-первых, мы не переходим к
доблам, там где-то можно избежать, там где-то можно избежать. И во-вторых, мы можем представлять все прямые.
В итоге код такой. Ну, здесь я напишу, что если точки p и q одинаковые, то там нужно, вот это вы
лучше меня знаете, что есть там какой-то сроу написать, какой-нибудь exception. В общем, как-то дать
понять пользователю, что он делает какую-то дичь, что нельзя построить точку по двум прямям. В нормальном случае,
если точки p и q различны, значит, нужно сделать понятно, что. Просто то, что написано ниже. Значит,
а это py-qy, b это qx-px, c это px на qy-py на qx. Потом, пожалуйста, конструктор прямой по двум точкам.
Прямая по двум точкам. Да, хорошо. Хорошо. Давайте еще поговорим про прямую, про всякие ее параметры.
Если есть какая-то прямая с уравнением ax plus b equals 0, то с ней связаны два следующих векторов.
Во-первых, есть вектор нормаля. Вектор нормаля n, у которого координаты a, z, z, b. И здесь направляющий вектор.
Направляющий вектор. Его обычно называют a, конечно, но давайте я его назову vector l. И здесь у него есть два представления.
Либо это b-a, либо b-a. Во-первых, h и b поменяли местами, во-вторых, любая из них взята с минусом.
Одна с плюсом, другая с минусом. Можно взять и так, и так. Понятно, что от изменения знака обеих координат,
то есть когда мы переходим отсюда-сюда, мы меняем знак обеих координат, это на самом деле просто будет противоположный вектор.
То есть один из них смотрит направо, другой налево. Вот если мы берем b-а, он смотрит куда-то, а минус b-а смотрит в другую сторону.
Как-нибудь надо это, наверное, понять. Давайте сначала поймем, что l это действительно направляющий вектор, вот этот вот синенький направляющий вектор.
Это легко понять. Пусть есть какая-то точка x, y, лежащая на прямой. Соответственно, тогда для нее выполняется вот это уравнение прямой.
А х плюс b как равно нулю. Тогда давайте мы отложим точку, точнее отложим вектора l, направляющий вектор нашей прямой.
Ну, потенциально, который мы проверяем на то, что он направляющий. Мы отложим от точки x, y. Соответственно, получим точку какую-то новую с координатами x плюс b.
Что эта точка тоже лежит на прямой, то есть удовлетворяет уравнению прямой.
Тогда мы получим, что действительно l это направляющий вектор. Потому что, по сути, это это разница между какими-то двумя точками на прямой.
Ну, значит, это по определению практически вравляющий вектор.
Значит, подставляем x, вот это новое, х плюс b, y минус а в нашем уравнении прямой. Получаем а на х плюс b, плюс b на y минус а, плюс c.
Ну, здесь все отлично. Здесь у меня вылазит из скобок ab и минус ab. Они сократятся, останется исходно а х плюс y, плюс c.
И это равно 0 по предположению, потому что точка x, y лежала на прямой.
Ну, все, значит, l действительно это направляющий вектор. То есть вектор, который как бы параллели нашей прямой.
Вот, теперь, чтобы понять, что n это вектор нормали, достаточно проверить, что векторы l и n артегональны.
Ну, а артегональность векторов мы знаем, как проверять. Это равенство нулю эксталлярного произведения.
Опять-таки там из какого-нибудь линала. Мы знаем, что артегональность векторов это то же самое, что равенство нулю эксталлярного произведения.
Ну, давайте перемножим. Да, то есть поточечно перемножим и сложим.
Что у меня будет? У меня будет b умножить на а, минус а умножить на b. То есть как раз 0.
Вот. Ну, хорошо. Такие два важных вектора прямой, вектор нормали, вектор направляющий, нам будет удобно с ними работать, ну, особенно с нормали.
Так, если есть какие-нибудь вопросы, то, пожалуйста, прерывайте, я отвечу.
Да, ну, тут еще можно такое заметить, что довольно часто вектор нормали удобно представлять единичным вектором.
То есть, когда у него длина единичная. Если это нужно сделать, то мы, конечно же, можем вот этот вектор обычным вектором.
Поэтому, если у нас есть какие-нибудь вопросы, то, пожалуйста, прерывайте, я отвечу.
Ну, я не знаю, что ещё можно заметить.
единичным вектором, то есть когда у него длина единичная.
Если это нужно сделать, то мы, конечно же, можем вот этот вектор, там, n, поделить обе его координаты
на длину вектора, то есть на корень из a2 тус b2. Мы можем, конечно, этот вектор сжать так, что он будет единичной длины, если это прям нужно.
Да, но тогда мы, скорее всего,
ну там, почти всегда, мы уйдем от целочисленности. Поэтому, как бы, формально вектор n, это не то, что вектор нормальный, да, не то, что и вектор единичный нормальный,
что там обычно строится во всяком атоме, когда мы берем там производную кривую или что-то такое и нормируем, это просто какой-то вектор перпендикулярной прямой.
И нам это нужно учитывать, что это не единичный вектор, а вектор какой-то произвольной длины, и потом, если что, нужно будет делить на как раз таки этот корень из суммы квадратов a и b.
Так.
Окей, давайте тогда, здесь же, раз мы про это говорим, мы вспомним, как считать расстояние от точки до прямой.
Расстояние от точки до прямой.
Есть какая-то прямая, сдаваемая уравнение вот таким вот, и точка с координатами.
Ну, давайте скажем, что это точка с координатами px, py.
Мне нужно найти вот это вот расстояние, то есть, что будет, если я опущу перпендикулирую,
какая бы длина этого нет.
Я утверждаю, что достаточно просто подставить точку p в уравнении прямой, то есть, здесь вот вместо xiy написать px, py,
взять модуль у этой величины и нормировать на корень из суммы квадратов a и b.
Так.
Да, тут я понял, что это не очевидно, но давайте поровну как-нибудь быстро доказать.
Я утверждаю, что расстояние равно следующей величине.
Ну, я для удобства это переобозначу, давайте это будет у меня x0, y0, вот так, тогда расстояние будет равно следующей величине a x0 плюс b y0
плюс c делить на корень из суммы квадратов a и b.
Так, ну, чтобы это доказать, давайте мы опустим перпендикуляр на нашу прямую, это будет какая точка q.
И тогда мне что нужно написать, чтобы q было действительно перпендикулярно, в смысле, оставание перпендикулярно, то есть, проекция q на нашу прямую,
мне нужно написать, чтобы q, во-первых, лежит на прямой, во-вторых, что вектор pq коллиниарен нормали, вектор pq нормален.
Ну или иными словами, я могу написать следующее, что q это какой-то p плюс n умножено лямбду, то есть, я понимаю, что чтобы по точке добраться до прямой,
мне нужно двигаться в направлении параллельного нормали.
Если у меня есть вектор нормали, то есть, вектор a b, то мне нужно будет его умножить на q, это лямбда, чтобы опуститься на прямую.
То есть q это p плюс n лямбда, и при этом q лежит на прямой.
Ну и, соответственно, это будет уравнение на лямбду.
Давайте посмотрим, q имеет какие координаты.
Давайте я напишу в виде столбика из двух чисел.
x0 плюс a лямбда, iq0 плюс b лямбда.
Теперь мне нужно написать уравнение на лямбда, которое бы означало, что точка q лежит на прямой.
Соответственно, я подставляю вот эти вот координаты в уравнении прямой,
получаю следующее, a на x0 плюс a лямбда,
плюс b на y0 плюс b лямбда,
плюс c должно быть равно 0.
Это выражение для лямбда, чтобы точка q лежала на прямой.
Так, разрешаем его относительно неизвестного.
Направо переносим все остальное.
Перенесли и получили, что лямбда это минус
подстановка точки p в уравнении прямой
делить на a квадрате.
Делить на a квадрат плюс b квадрат.
Соответственно, мы получили лямбда,
мы получили то, сколько раз нужно приложить вектор нормальный к точке p,
чтобы опуститься на прямую.
Ну, значит, ответ...
Давайте напишем, что distance от p до l,
расстояние от p до прямой,
это что такое? Это длина вектора лямбда n.
Потому что мне нужно к точке p лямбда раз приложить вектор n,
чтобы опуститься на прямую.
То есть как раз длина вектора есть наш ответ.
Модуль лямбда мы знаем.
Это модуль лямбда на длину вектора n.
Модуль лямбда это как раз таки модуль a x0 plus b y0 plus c
деленный на a квадрат плюс b квадрат.
А вектор нормальный, как я уже говорил выше,
у него длина имеет...
Потому что его координат это просто a b.
Ну и получили, собственно, искомую формулу,
когда мы здесь вот сократим сумму квадратов
и корень из суммы квадратов,
у меня получится искомая формула,
что когда мы просто подставили p в ранении прямой,
поделили на корень из суммы квадратов,
и это есть расстояние от точки до прямой.
Ну и заодно мы нашли не только расстояние от точки до прямой,
но и по сути нашли проекцию,
потому что если мы знаем, чему равно лямбда,
то есть сколько раз нужно приложить вектор нормальный к точке p,
тогда мы просто прибавляем это самое лямбда n к p
и получаем проекцию.
То есть мы знаем не только расстояние до прямой,
но и проекцию точки напрямую.
И здесь уже, скорее всего, нам придется отказываться от целочисленности,
потому что здесь, когда мы опускаем нормально прямую,
во-первых, расстояние, там явно уже какие-то корни возникают,
во-вторых, чтобы посчитать вектор лямбда n,
мне нужно поделить там что-то,
ну даже целочисленное,
на что-то целочисленное, что потенциально не делится,
что может не делиться,
поэтому точка q имеет уже, вероятно, рациональные координаты,
и, значит, нам нужно переходить к доблу.
То есть в момент, когда нам нужно опускать вермедикуляры,
то есть опускать проекции напрямую из точки,
уже, к сожалению, в НТАВ все еще что-то не получится,
даже если исходные координаты все целочисленные,
здесь уже придется переходить к либо доблам,
числом с половочей точкой,
либо заводить свой класс rational
и хранить эти точки в виде числитель, запятая знаменатель.
Если мы хотим считать все точно,
и вот у нас прям какие-то большие проблемы с точностью,
может быть, очень много операций,
тогда, возможно, еще может быть такое нужно делать,
что считать нужно все в рациональных,
то есть считать, что у каждой точки,
каждая точка теперь не насточисленная,
а рациональная, у нее есть координата,
у нее есть числики по х, числитель знаменатель по у,
и, соответственно, все вот это то, что было выше,
нужно переписать на...
То есть, если вы заведете свой класс rational,
класс рациональных чисел как числитель знаменатель,
то тогда вот это все, что выше,
надо будет переписать для рациональных чисел.
Если пока что, то есть пока что можно считать,
что все в рациональных, дальше будет так,
что уже рациональных не хватает,
не хватает, и придется переходить к обычным веществам. Там лучше, чем double, ничего не сделать.
Окей, мы опустили пермитигуляр напрямую. Дальше простой примитив – это пересечение прямых.
Пересечение прямых. Здесь решается просто методом грамма. Значит, смотрите, есть у вас две прямые,
одна имеет вот такой вид, другая вот такой вид. И вам нужно найти точку их пересечения. Ну,
или сказать, что прямые параллельные, то есть, имеют ноль точек пересечения, или прямые
совпадают, то есть, имеют бесконечно много точек пересечения. Так, ну давайте как-нибудь это поймем.
Давайте я не буду писать какую-то функцию, потому что непонятно, что она должна возвращать. Да,
она должна возвращать сообщение какое-то, типа, как эти прямые относительно друг и расположены,
и при этом, если они пересекаются по одной точке, то эту точку, давайте не будем писать возвращаемый
тип. Давайте просто напишем уравнение, ну, систему уравнений, которую мы решаем. По сути,
мы просто решаем вот такую систему. Система линейных уравнений относительно двух переменных,
х и у. Вот у нас есть замечательный способ это решать. Это метод граммера, он работает следующим
образом. Значит, мы считаем определитель нашей, давайте я перепишу это в терминах матрицы.
В терминах матрицы это работает вот так. Ну и здесь, значит, граммер работает следующим образом.
Мы считаем сначала определитель вот этой исходной матрицы, которая стоит слева. Это, соответственно,
а1b2-a2b1. Затем мы подставляем вместо первого столбца вот этот результирующий столбец,
который стоит справа. Тем самым мы как бы забываем про ашки и ставим на их места
минус c1-c2. И опять считаем определитель. Получится, ну давайте я напишу, что это будет минус c1b2 плюс c2b1.
То же самое delta2, это когда мы вместо b ставим наш столбец минус c. То есть вместо b1b2 ставим
минус c1-c2. Будет у меня видимо минус a1c2 плюс a2c1. Для тех, кто вдруг не знаком с методом граммера,
давайте просто я скажу следующее. Вот посчитаем delta1 delta2, sorry delta1 delta2 по таким формам.
Тогда верно следующее. Если delta равно нулю, то что такое delta? Delta это определитель нашей
исходной матрицы, вот этой матрицы 2 на 2. И понятно, что если delta равно нулю, то значит
матрица выражена. И поэтому система, она либо несовместна, либо имеет бесконечную много решений.
То прямые, значит параллель, потому что если наша, если наша, если наша матрица вырожденная,
да тогда это значит, что в терминах, не знаю там, в терминах направляющих векторов это можно,
скажем, переформулировать. Значит можно написать, можно написать вот здесь вот направляющий вектор,
там b1-a1, и вот здесь это b2-a2. И написать условия на то, что эти векторы коллинеарны,
то есть там пропорциональны с точностью какой-то констант мультипликативно. То есть скажем,
что один вектор это другой умножить на лямбду, другой умножить на лямбду. И тогда как раз вот
это вот выражение 1b2-a2b1 будет равно нулю, ровно в том случае, когда ваши векторы,
ну пропорциональны, что один включается другого на константу, извините, в константу раз.
Получается, что как раз равенство нулю нашего определителя означает, что направляющие векторы
наших прямых параллельны. Значит они, ну точно, значит и прямые параллельны, поэтому они либо
просто параллельные не пересекаются, либо они совпадают. Вот две такие прямые в одном месте.
Прямые параллельны или даже совпадают. Ну хорошо, это в случае, когда дельта равно нулю. В
случае, когда дельта не равно нулю, если дельта не равно нулю, то из-за этого грамера нам известно,
что единственное решение этого уравнения это следующие две дроби. Вместо х нужно написать
дельта 1 делить на дельта, вместо у дельта 2 делить на дельта. Вот, это просто метод грамера.
Если он вам не знаком, то просто в качестве уражения докажите, что действительно в этом
случае, когда дельта не равно нулю, то есть когда можно делить и когда наши прямые не параллельны,
точка пересечения задается вот такими вот уравнениями, вот такими вот координатами.
Можно просто подставить вот эти вот оба числа уравнения прямых обеих, проверить, что в эти
точки зануляется оба уравнения. То есть получается, что эта точка лежит на обеих прямых, что и
требовалось. Мы нашли такую точку, которая лежит там и там. Ну хорошо, мы поняли, как различить два
случая параллельности или пересекаемости, и в случае, когда они пересекаются, мы нашли их общую
точку через метод грамера. Теперь, как различить два случая, когда прямые параллельные или когда
они совпадают? Как-нибудь можно это различить? У вас есть коэффициент версии?
Если они совпадают, то у них коэффициенты пропорциональны.
Если они совпадают, то коэффициенты пропорциональны. Да, можно так сказать.
Действительно, они совпадают. Давайте пропишем, они совпадают.
Давайте ка, напишу лям, мы уже переиспользовали, что там а1 это ка2,
б1 это ка2, ц1 это ка2. Да, это верно. И соответственно, можно, например,
рассуждать так. Чтобы проверить, что они совпадают при условии, что они параллельны,
давайте мы скажем, что ка равно а1 делить на а2 и проверим выполнение вот этих двух уравнений.
Но, к сожалению, это не работает, если а2 равно нулю. Поэтому так можно делать только,
если а2 не равно нулю. Значит, в общем случае, такой подход, мне кажется,
работал бы так. Мы находим из трех координат a, b, c, там a2, b22, какую-то не нулевую, скажем там b,
не нулевая. Тогда пишем, что k равно b1 делить на b2 коэффициент пропорциональности. Да, и сравним,
что там для остальных двух координат a и c выполняется такая же пропорциональность с тем
же самым коэффициентом. Да, можно так. У меня есть другое предложение, можно еще проверить,
можно сделать следующее. Взять, найти какую-нибудь точку на одну из прямых и
проверить, лежит ли она на другой прямых. Соответственно, если она лежит, то получается,
что у точек есть общая, у прямых есть общая точка, значит, они обязательно совпадают,
там просто все точки общие. Вот вопрос, можно ли как-нибудь найти какую-нибудь точку на прямой
a и c плюс b, плюс c равно 0. Можно найти какую-нибудь точку.
Так, ну здесь, видимо, те же самые проблемы. Давайте скажем следующее, что в обычном случае,
когда у меня прямая не вертикальная и не горизонтальная, можно, ну там точно есть точка
с координатой y равно 1. Точно есть точка с координатой y равно 1. Да, тогда надо просто посчитать,
чему равно x. Тогда x это минус b, минус c, делить на a. Значит, в случае, когда a не равно 0, у меня
на прямой обязательно лежит вот такая точка, минус b, минус c, делить на a за 2 единицы. Так,
добился ли я чего-нибудь полезного от этого? Кажется, нет, потому что я хотел сделать как-нибудь
это без делений, потому что вот здесь вот так. Не очень хорошо, что мы, если в тупую это реализовывать,
то мы по сути написали деление двух чисел. И если до этого все было целочисленное, да, и скажем,
мне нужно просто проверить, прямые совпадают или нет, то хотелось бы это все тоже сделать в целых числах
без делений. Ну, понятно, что этот способ, который выше, вот этот вот, его, конечно, можно сделать в целых
числах, просто сохранить вот это отношение a1 делить на a2 как, ну, числитель-знаменатель,
да, без деления явного. И тогда подставляя его сюда, просто проверять, что b1 равно a1 b2 делить на a2,
и просто это a2 перенести сюда, и будет все хорошо. То есть понятно, что это можно сделать в целом. Вот здесь
я хотел придумать какую-нибудь такую точку, которая заведомо целочисленная, но что-то как-то
не зашло, не зашло. Ну и, видимо, в общем случае я не верю, что это делается, потому что если мы
фиксируем какую-то из переменных x и y, тогда мне нужно будет поделить, скажем, когда мы фиксировали
y, мне нужно будет вот это поделить на a и добиться того, чтобы это делилось на a нацело. Не очень понятно,
как, потому что у меня есть слагаемая c, да, и непонятно, как не возбавляться. Поэтому предлагаю
предзабить. И действительно, чтобы проверить, что не совпадает, надо просто проверить пропорциональность
коэффициентов. Да, ваш метод рабочий. Хорошо, хорошо это сделали. Давайте еще одну штучку,
здесь же про пересечение. Это пересечение окружности и прямой. Пересечение окружности и прямой.
Ну, сначала, как можно хранить окружность? Окружность можно хранить центром, вот этой
вот точкой p, которая является центром окружности, а также ее радиусом, радиусом r. Соответственно,
там для удобства можно написать какую-нибудь структуру, которая хранит точку p и одно число r,
одно число r-радиус. Вот и вопрос, как решить. Какую задачу погнать и вот эти точки пересечения
прямой ax plus bk plus c равно нулю и окружности центров p радиуса r? Так, сейчас, секунду. Да. Ну,
у нас интересует просто, чтобы расстояние от p до прямой было меньше или равно радиусу. Да,
это мы проверяем наличие пересечения. Пересечение вообще есть? Пересечение есть. Если только,
если distance от p до l, давайте опять прямой назову l-кой, меньше либо равно радиусу.
Мы можем сейчас, кстати, разделить отдельное на случае меньше и равно, потому что в случае
равенства будет касание. Да, все верно. В случае, в случае равенства действительно,
когда расстояние от p до l равно r, это значит, что у меня картина какая-то вот такая. Да,
и прямая у меня пересекает окружность в одной точке. Это случай distance равно r. Ну, соответственно,
когда distance меньше, чем r, то у меня происходит пересечение в двух точках, вот этих вот двух.
И смотрите, здесь можно было бы действовать совершенно наивно, сказать, что по сути мы
решаем вот такую систему уравнений. То есть при вот этом условии, когда мы поняли, скажем,
что пересечения в принципе существуют, иначе нужно сказать, что их нету. При этом условии мы
решаем такую систему уравнений. Значит, уравнений прямой, а также уравнений окружности. Уравнений
окружности можно писать так. Давайте опять скажем, что у p картината x0, y0. Тогда уравнение окружности
задается вот в таком вот виде. Это уравнение просто говорит, что расстояние до точки x0, y0 равно r. Ну,
или точнее, квадрат расстояния равен r в квадрате. Это вот то, что написано в этой строчке. Можно
дальше просто сказать, что ага, у меня есть две переменные x и y. Какой-то из коэффициентов a или b
не равен нулю. Если а не равно нулю, тогда давайте разрешим уровень относительно x. Выразим x через y.
Выразим x через y. Подставим его вот сюда, решим квадратно уравнение, найдем y, и по формуле выражения
x через y найдем x. Валидный способ. Так можно сделать, но какие тут есть проблемы? Во-первых,
ну ладно, наверное одна проблема. Я вижу одну проблему в таком методе. Проблема в том,
что когда не понятно, кто равен нулю, что делать, короче, если a или b равно нулю. То есть хорошо
общий код работает, если а не равно нулю. Какое выражение работает? Выражение x через y,
и потом подстановка и подсчет x в конце. А если a равно нулю, то нужно, наоборот,
y выражать через x, потому что то, что было выше, не работает. Поэтому нам нужно оба
случая обработать, когда a равно нулю нужно y выражать, когда b равно нулю, то надо x выражать.
И то это надо делать, поэтому нужно оба случая разбирать. Метод, который, мне кажется,
чуть более экономен с точки зрения количества кода следующий. Давайте мы опустим перпендикуляр
из центра окружности на нашу прямую. Лага перпендикуляра мы уже опускать умеем,
то есть мы по сути найдем проекцию центра на нашу прямую. И у нас уже выше есть написанная процедура,
то есть я ее там явно не прописывал, но понятно, что это можно сделать по точке и прямой, найти
проекцию. А дальше, что дальше мне нужно от нее отступить, понятное дело, на одинаковое расстояние
в обе стороны по этой прямой. Вот сюда на какое-то расстояние, сюда на то же самое расстояние,
на то же самое, потому что картинка симметрична относительно вот такой вот оси.
Значит, что нам теперь нужно будет сделать? Нам нужно будет найти направляющий вектор этой прямой,
а это мы уже тоже знаем, как его находить через уравнение прямой. И останется найти длину
вот этого вектора, и потом нам нужно будет просто от Q в обе стороны прибавить этот
направляющий вектором ножом на эту длину. То есть направляющий вектор мы нормируем,
чтобы он был длиной 1, и откладываем его влево, то есть с плюсиком на какую-то длину k,
и вправо, то есть с минусиком, на ту же самую длину k. Вопрос только, какова это длина? Какова
это длина k? Ну, она понятна какая. Это корень из 1 в квадрате минус расстояние от Q до Q,
distance от Q до Q в квадрате. Потому что просто ремни фагора. У нас есть расстояние от Q до Q,
у нас есть гипотенузы нашего катета, это радиус просто окружности. Значит,
второй катет k – это вот такой корень. Корень из 1 в квадрате минус расстояние от Q до Q.
Ну а расстояние от Q до Q тоже давайте напишем. Расстояние между точками – это
px – qx в квадрате плюс px – y – qx в квадрате есть всего этого корня. Расстояние между точками,
соответственно, здесь даже как бы не нужно вот этот корень извлекать. Если мы борцали
за точность, то вот этот корень здесь не нужен, потому что по сути мы ищем только квадрат
расстояния. И там нужна как функция считающих квадрат расстояния, т.е. не извлекающий корень.
Вот потом соответственно мы посчитали это k путем однократного извлечения корня. Ну и в качестве
этого мы разрешаем точки Q плюс kV и Q минус kV, если V – это направляющий вектор прямой единичной
длины. Направляющий вектор l – единичной длины. Ну а в случае равенства, в случае, когда расстояние
от p до l равно в точность r, тогда вот эти две точки будут одинаковые, там k будет равно 0. И,
ну по сути, если не париться и написать просто то же самое, то вы вернуете две одинаковые точки,
потому что когда вы так непрерывно сдвигаете вашу прямую вдоль точки касания, у вас точки
прещения движутся на встречу друг к другу, и вот эта вот экстремальная ситуация, когда у вас
прямая переходит в касательную, у вас точки склеиваются, образуется одна точка. Но здесь уже
как бы зависит от деталей того, как вам нужно все обрабатывать. Если вам нужно прям конкретно
вывести на множество точек, то нужно тогда отдельно случай за f и вернуть одну точку,
просто q, просто основание перпендикулярно из p на l. Иначе, если точки прещения 2,
то вот нужно плюс-минус kv добавить к q. Вот, у этого метода преимущество в том,
что нам не нужно ждать два случая f, не нужно понимать, выражать x через y или y через x,
а также мы существенно задействуем уже то, что написано выше. Чего у нас есть?
Нам самое важное это найти проекцию точки напрямую, q найти, а дальше умножение числа на вектор,
сложение двух векторов, вычитание двух векторов. Это у нас тоже уже все написано. Здесь как будто
мы с нулям все делаем, да, не имея никаких уже написанных функций, поэтому это получили.
Так, ну и последнее пересечение, это пересечение двух окружностей. Есть две окружности, соответственно,
задаваемые своими центрами x1 и y1, x2 и y2 и радиусами r1 и r2. Наша задача понять их
точки пересечения и пересекаются ли они вообще. Вот здесь можно написать кучу всего,
можно развивать кучу случаев, решать систему квадратных управлений, все это можно делать,
но все это на самом деле излишне и очень-очень громоздко, потому что здесь куча всяких неприятных
случаев, типа, например, вот такого, когда одна окружность лежит внутри другой, соответственно,
предельно случаи, когда они касаются по внутренности, предельно случаи, когда они,
наоборот, ну там, сейчас, ну, касаются так вот по внешности. В общем, куча всяких неприятных случаев
может быть их взаимного расположения. И, соответственно, как-то все это в нашем
уровне, их квадратных управлений мы будем решать. Надо будет учитывать там какие-то, чтобы делить,
оно же будет проверить, что там что-то не равно нулю и так далее и так далее. В общем, это все довольно
неприятно. Гораздо проще сделать следующее. Давайте мы, ну, по сути, мы все также решаем вот
такую систему уравнений, что мы ищем такие точки, которые находятся на расстоянии от первого центра
на расстоянии r1 и на расстоянии второго центра равным r2. То есть, по сути, мы решаем ту же самую
систему уравнений, только мы будем решать ее не как систему квадратных уравнений, а давайте
вычтем из одного уравнений в другое. То есть, мы вычтем из одного ровнений в другое, то у меня
как раз таки, ну, там, скажем, я первое, первое оставляю и записываю второе уравнение минус
первое. Тогда, у меня вот в этом вот уравнении в втором, когда мы вычитаем первое и второе у меня
сократятся все квадраты, потому что у меня здесь было x квадрат y квадрат и здесь тоже x квадрат y
квадрат. И когда я их вычту, у меня все квадраты сократятся и будет просто такое линейное уравнение.
ровнение. Эта штука это уже линейная относительно х и у. Линейная уравнение относительно х и у.
То есть на самом деле, когда мы вычитаем из одного уровня другое, мы получаем уравнение вида ax
плюс dy плюс c равно 0. То есть на самом деле мы получаем уравнение прямой, а дальше нам достаточно
теперь решить такую систему уравнений. Первое уравнение и вот эта прямая, которая получается
как разность наших двух окружностей. И вот это кажется как раз будет та самая прямая,
которая через эти точки и проходит. Да-да-да-да-да-да-да. Да, конечно, потому что это такая прямая,
на которой лежат точки причины наших окружностей. Ну, значит как раз вот эта самая прямая.
Здесь я неявно подразумеваю, что вот эти вот две системы эквивалентны. Что множество решений
системы 1 и 2 эквивалентно, ну точнее равно просто множество решений системы 1 и 2 минус 1.
Тут, кстати, небольшая аналогия с алгоритмом Евклида, потому что как у нас было в алгоритме
Евклида, что гцд двух вот таких вот чисел, правень гцд двух вот таких вот чисел,
мы считаем из одного другое. То же самое, что если что-то и там какая-то точка x и y является
решением левой системы, то она является решением и правой системы. И наоборот,
если есть решение правой системы, то есть решение левой системы. Но неважно, шаг в сторону.
Ну все, а пересекать окружность с прямой мы уже умеем. Это вот было выше. Если мы напишем процедуру,
которая нам по окружности прямой находит их все пересечения или сообщает, что их нет,
тогда нам нужно просто будет дернуть эту функцию, один раз просто вызвать функцию с
нужными коэффициентами, и будет нам победа. Мы тоже найдем сервишкой пересечений.
Вот здесь вот, когда мы говорим уже про пересечение, там сложных фигур, типа прямой
окружности прямой и двух окружностей, здесь уже, видимо, никак не обойтись без перехода к доблам.
Потому что, когда мы пересекали прямую окружность, нам нужно опустить проекцию,
допустим, периметигулярно прямую, и потом от вектора отступить в обе стороны что-то. И понятно,
что вот эти отступы, они там нужно извлекать в кучу корней, и тогда эти координаты на желудочных
они уже совсем не обязательно рациональны, уже, возможно, произвольные вещественные,
когда мы извлекаем корень, часто могут стать вещественными, а не рациональными.
Но то же самое здесь, если мы пересечения окружности с великоперечения окружности прямой,
то тоже мы здесь в рациональных уже не всегда сможем обойтись. Придется использовать плавающую
точку и, соответственно, как-то накапливать ошибку, потому что если мы переходим к вещественным
числам, к даблам, то, конечно, максимально точно мы их хранить не можем, там будет какая-то погрешность,
всегда в наших вычислениях какая-то маленькая нок-нок будет. Кстати, а вообще, если у нас
контест будет, то его можно будет залить на рейшналах или всё-таки слишком долго будет?
Нет, ну обычно это не очень долго, обычно это не очень долго, ну, то есть, но для этого задача
должна быть такой специфической, что в ней не нужно находить вот этих вот точек, да, то есть,
там в частности нельзя будет пересекать прямые окружности, но если в прямой задаче этого не нужно,
то, ну, там с широтностью 1 можно будет написать в рейшналах, но, скорее всего, можно будет и без
этого написать, можно написать в даблах, как обычно, да, и просто там равенство проверить
с помощью epsilon, чтобы проверить, что две точки одинаковые, вы проверяете, что у них разность по
иксам не больше, и разность по иксам не больше. Скорее всего, можно будет так и так. Так, хорошо,
давайте тогда последний примитив, который мы уже неярно пользовались, это скалярное векторное
произведение. Скалярное, и, ну, вот это называется векторное, да, давайте мы называем его псевдовекторное,
всё-таки псевдовекторное произведение. Векторное произведение это строгое, это в трёхмерном
пространстве строгое определение, там, когда мы умножаем, в общем, когда мы считаем какой-то
определитель, там всё хорошо определено, у нас такое кривое векторное произведение. Ну, скалярное
произведение мы знаем, что такое, если у меня есть два вектора x1 и x2, то их скалярное произведение это
по компонентной просто произведение и сумма. Это скалярное произведение. По-английски это называется dot
product, произведение как бы через точку, вот, ну и я обычно пишу, если мне нужно скалярное произведение
считать, то я пишу функцию dot, которая принимает две точки и соответственно возвращает их dot product, их скалярное произведение.
Значит, если у меня есть два вектора u и v с вот этим координатом x1, y1, x2, y2, то можно также показать,
что это скалярное произведение равно следующей величине u на v на косину с угла между ними, косину с этого
угла phi. Это тоже скалярное произведение. Вот, ну давайте это там без заказательства, да, скорее всего это было в каком-нибудь
опять линале, и это работает в любом пространстве любой размерности, если у вас есть два вектора, вы их вот так
по компоненту перемножите и все сложите, то вы получите произведение их длины, умноженное на косину с угла между ними,
причем косину с угла определен в любом пространстве, угол определен в любом пространстве, косину тоже можно
посчитать. Вот это скалярное произведение, оно нам позволяет сделать, например, следующее, оно позволяет понять, какой
угол между двумя векторами, потому что если угол между ними, скажем, острый, тогда это значит, что косинус phi больше
0, если угол острый, значит скалярное произведение будет положительным, потому что произведение двух лин на косину с
угла, который положительный, т.е. скалярное произведение будет положительным, если угол прямой между ними,
то косинус Phi равно 0 и значит скалярное произведение тоже равно 0, раз у нас есть нулевой множитель,
то значит все произведение равно 0, этим и пользовались, когда проверяли артагонали из двух векторов,
что векторы антагональны, если их скалярное произведение равно 0.
Последний случай, скажем, вот такой, когда между ними угол тупой.
Угол тупой, соответственно, cos phi меньше 0, cos phi меньше 0.
И значит, скалярное произведение отрицательное.
То есть, по сути, знак скалярного произведения больше 0 равно 0 или меньше 0
сообщает о типе угла между двумя векторами.
Тупой он, острый или прямой.
Три возможности, три возможных знака для скалярного произведения.
Ну и отсюда же можно не просто узнать тип угла, но и найти значение угла.
Достаточно просто взять cos от нужной штуки.
Давайте скажем, пусть у меня есть скалярное произведение u и v.
Я его так обозначу.
Через скобки скалярное произведение.
Тогда понятно, что cos phi это скалярное произведение.
Делить на произведение длин.
Делить на длину u умножить на длину v.
Значит phi это просто arcosinus.
phi равно, в плюсах это arcos.
Не arc, а просто arcos.
Вот уже две штуки.
Ну и это наш угол phi.
Причем, насколько я знаю,
эта штука принимает значение от 0 до pi.
От 0 до pi не включительно.
Сейчас, секунду.
Или включительно.
Так.
Наверное, включительно.
Потому что если векторы вот так вот противоположны,
то угол между ними равен pi.
Мы можем также найти и угол между двумя прямыми,
но уже с помощью такой еще более сложной тригонометрической функции.
И на самом деле вообще во всей этой геометрии есть
как минимум три класса функций.
Первый – это всякие простые сложения, деления, умножения.
Ну и то там лучше без деления, бойтесь.
Это прямо наши любимые функции, которые в идеале вообще
позволяют нам не переходить к веществным числам.
Это сложение, умножение, на крайний случай деление.
Потом есть всякие извлечения корней.
Когда нам нужно там опускать периметикуляры,
пересекать ровно степрему и так далее.
Это вот всякие извлечения корней.
Ну, собственно, там основная процедура – это извлечение корней.
И третий тип функций – это всякие тригонометрические.
Косинусы, синусы, арк-косинусы, арк-синусы.
Это еще более неточные функции.
И поэтому я рекомендую их избегать,
только если нет явной необходимости.
Понятно, что если вам нужно посчитать вектор между…
В условиях, грубо говоря, написано,
что нужно найти вектор между двумя отрезками,
между двумя векторами,
то, понятно дело, вам нужно вызвать арк-косинус.
Понятно, что без этого никак.
Но если вам это не нужно,
если вам, скажем, нужно только вывести тупой угол,
острый или прямой,
то вы считаете скалярное произведение.
Причем, возможно, вам для этого хватит интов,
ну, или там, лонг-лонгов.
Вы считаете скалярное произведение
и по знаку определяете тип угла.
То есть не нужно его сам находить
и потом там сравнивать спип пополам,
чтобы понять, тупой он или острый.
Чтобы понять его тип,
можно просто посмотреть на знак скалярного произведения.
Поэтому, как говорится,
I cannot stress this enough.
Невозможно это переоценить.
Старайтесь использовать как можно более простые функции.
Если можно обойтись без тригонометрии,
то обходитесь.
Если можно обойтись без извлечения корней,
обходитесь.
Старайтесь как бы использовать умножение,
где-то можно, вычитание, где можно.
Потом, если этого не хватает,
то извлечение корней.
И потом только в самом крайнем случае
это вообще косинусы, синусы, тангенсы
и все такое прочее.
Потому что эти функции сильно менее точны.
Да, у нас
ну, вполне бывает такое, что
из-за точности,
из-за того, что у нас накапливается погрешность,
когда мы делаем много-много-много вычислений,
у меня погрешность накапливается
и, возможно, там
результат мы бы считаем слишком плохой,
не достаточно точно.
Ну вот, что я хотел сказать.
Так, есть ли вопросы какие-нибудь сейчас?
Если нет, тогда давайте перейдем к триангуляции.
Триангуляции многоугольников.
Триангуляции многоугольников.
Значит, здесь задача такая.
Есть у вас какой-то многоугольник,
а именно
что такое многоугольник?
Это какая-то замкнутая, не самая пересекающая, сломанная.
Вот я что-то такое нарисовал.
И нам нужно его триангулировать.
То есть провести там несколько
отрезков между вершинами,
так чтобы все разбилось на треугольнике.
Давайте нарисуем какую-нибудь триангуляцию.
Так, вроде нарисовал.
Значит, мне нужно провести какие-то отрезки
между вершинами, так чтобы все разбилось
на треугольнике, ну и причем вот эти вот отрезки,
которые я провожу, они лежали с рук
внутри нашего многоугольника.
То есть, понятное дело, что вот такой, скажем,
отрезок, он бессмысленный,
он не отсекает никого треугольника.
Он плохой, его нельзя рисовать.
Вот эти отрезки мы будем называть диагональными.
Диагонали.
То есть диагонали это,
это просто какие-то отрезки, которые
целиком лежат внутри многугольника.
Точнее, это отрезки между вершинами,
отрезки
между
не соседними вершинами,
не соседними вершинами,
целиком лежащие
внутри многугольника.
Даже я скажу, во внутренности.
То есть,
вот эти отрезки,
даже я скажу, во внутренности.
Во внутренности
многугольника.
Вот, про эту триангуляцию есть
ну, такой а-ля
практический повод это вообще изучать.
Это примерно следующее. Вот представьте,
у вас есть какая-нибудь музейная галерея,
в которой хранятся какие-то картины
или что угодно.
И вот вся галерея задается таким вот,
каким-то странным многугольником.
Бог знает, почему-то архитектор
выдел вам вот такое помещение
очень странное, с кучей углов.
Вы поставили картины,
и вам нужно поставить несколько камер
или поставить несколько
вахтёрж, которые будут сидеть на своих
стульчиках и смотреть, что вокруг них,
всё, что они видят, всё хорошо.
И это не получается украсть,
или там что камеры видят, что вокруг них
никто не пытается там нарисовать что-нибудь плохое
на картине.
Тогда задача сводится к тому,
чтобы поставить какие-то точки
внутри нашего многугольника,
так чтобы всё, ну,
из каждой точки
был виден
какой-то кусок вашего многугольника,
и при этом объединение этих кусков было
равно всему вашему многугольнику.
Вот, например, если я поставлю точку где-нибудь
здесь, вот, то я
не буду видеть, не знаю, там, что-нибудь вот здесь,
потому что вот этот отрезок,
он проходит, как бы, частично
через границу нашего прямоугольника, и даже
где-то вне, поэтому из-за вот этой вот
стенки я что-то видеть не буду.
Вот эту точку я видеть не буду.
Ну, а там кажется, что если поставить
точку где-то вот здесь, то, видимо,
из неё вообще всё видно. Ну, если
вот этот угол, он там, то есть
если его так усилить, то он будет не видно.
Вот, если он такой, как на картинке,
то всё видно.
Вот, ну, в общем случае
можно действовать так. То есть это наш
хороший случай, когда там вообще одна точка всё покрывается.
В общем случае, это не обязательно так.
Вот, и, соответственно,
задача такая. Сколько нужно
поместить, или там, сколько достаточно
поместить вахтёрш, чтобы они всё видели.
Простой решение такое. Давайте мы
построим треангуляцию нашего
многугольника вот такими вот диагональками,
и в каждом треугольнике просто назначим
бабушку, которая там будет сидеть и совсем наблюдать.
Тогда получается, что нам нужно
бабушек ровно столько, сколько треугольников.
Да, сколько, сколько треугольников.
Ну и вот, понятное дело,
просто
упражнение, что
треугольников в треангуляции
всегда равна
n-2.
Треугольников всегда
ровно
n-2, где
n – это число в вершин высходном многугольнике.
Число вершин в многугольнике.
Ну, потому что
если у вас есть один, если у вас
n равно тройке, то у вас
просто
индукция, если n равно тройке,
то у вас есть один треугольник всего,
он сам по себе равен
тому, чему нужно. Если там
для n это верно, и вы
находите для большего n, то вы порвете
одну диагональ, разбиваете ваш
треугольник на два куска, там
левый и правый, здесь там k-2
треугольника, здесь m-2, и в сумме
там k плюс m
равно
n плюс 2, потому что вот эти две точки
на пересечении многугольников, они учатся
два раза. Вот так вот я
коротко доказал.
Ну вот, значит, в итоге всегда обязательно
хватит n-2 фактёрж,
но можно даже делать лучше.
Давайте тоже упражнение, которое я, наверное,
в итоге в семинар вставлю, что из этой
конструкции можно показать, что
всегда достаточно...
Так, сколько их?
Ну, видимо, n делит на 3
фактёрж,
чтобы обозреть весь
многугольник.
Обозреть весь
многугольник.
То есть достаточно поставить
не в каждом треугольнике, но, грубо говоря,
не в каждом треугольнике,
а в каждом третьем треугольнике,
тогда тоже всё можно будет увидеть.
А точно вниз?
Да, да,
да.
Вот. Ну, на семинаре
надеюсь разберём ещё.
Разберёте.
Так, для нас,
ну и ещё здесь же упражнение,
причём бывают многугольники, для которых
нельзя обойтись меньшим числом фактёрж.
Бывают многугольники.
Многугольники,
для которых
необходимо...
Ну, я здесь не уверен, что n на 3,
но там точно n делит на 3
минус константа.
Необходимо n делить на 3
минус константа
фактёрж.
То есть, по порядку
у нас будет правильная
оценка.
То есть, что n на 3
иногда достигается, и всегда достаточно
n на 3.
Ну, а мы,
мотивировавшись как бы этим примером
про музей, построим алгоритм
реангуляции произвольного многугольника
за n в квадрате.
Реангуляция.
Реангуляция
за...
За...
Ещё первый случай, который
так просто обсудим, что если
многугольник выпуклый,
то это можно сделать просто за от и
потому что
выпуклый многугольник и всё
отлично. Мы, скажем, можем взять просто одну вершину,
провести из неё все диагоны
и тогда автоматически всё разобьётся
на треугольнике. И из-за выпуклости
у меня не будет таких проблем, что там какая-то
диагональ как-то пересекает вдруг
или что-то такое, в выпуклом случае все прям идеально, мы просто проводим вот эти отрезки,
и это будет наша реангуляция. Здесь все шикарно, просто, и думать ни на чем не нужно. Поэтому считаем,
что наш нагугольник не выпуклый, и соответственно тогда задача интересная, потому что провести
отрезок не всегда понятно, можно ли его провести или нет. Иногда там он может пересекаться в другие
стороны, или там в каком-то треугольнике могут держать другие точки, вот это все нужно отслеживать.
Ну хорошо, давай тогда докажем следующее утверждение. Сначала определение. Ухом в нагугольнике
называется
треугольник
в и-1, в и, в и плюс один, то есть образованы тремя последовательными вершинами, которые целиком
лежит в нагугольнике, и при этом внутри этого треугольника нет других вершин.
То есть ухо, это как раз то, что мы будем отрезать. Вот такой треугольник торчащий где-то,
который можно отрезать, который можно сгладить, оставить одним треугольником и
треангулировать все остальное. Ну картинки какие-нибудь здесь такие можно нарисовать.
В хорошем случае, когда есть какой-то такой нагугольник, у меня вот это вот является хорошим
ухом. То есть это такой треугольник из трех подряд задушек вершин, где внутри ничего нет другого.
Это хороший случай. Плохой случай, например, вот такой, когда угол при вершине больше чем 180
градусов, то есть как бы угол вот такой вот лежащий во внутренности, и мы как будто бы смотрим на вот
такой вот треугольник, построенный по вот этим трёх сторонам, и это по трём вершинам. Это плохой
треугольник, потому что он не лежит во внутренности, он лежит где-то там вовне. Ещё плохой пример это,
когда ну просто что-нибудь вот такое происходит, когда вы проводите тогда отрезок между вашими
вершинками и минус первый и плюс первый, у вас внутри может лежать какая-то другая вершина,
и соответственно тогда у вас автоматически это не ухо, вы не можете его отрезать, перейдя к другому на
другому. А у нас такое может быть вообще? Потому что у нас же тогда следующая вершина просто будет другой.
Ну смотрите, следующее у нас идёт в понимании просто звеньев ломаных. У нас вершины задаются так,
там не знаю, первая, вторая, третья, четвёртая, пятая, шестая и так далее. Как мы тогда соединили третью с первой,
если после неё есть ещё какое-то количество? Нет, ну смотрите, мы её соединяем, вот это красное ребро,
это как бы попытка провести, сейчас, возможно здесь чёрное, это я плохо нарисовал. Сейчас, сейчас, одну секунду.
Нет, я имею в виду мы же соединяем как бы, берём треугольник на трёх подряд идущих вершинах, а здесь
не подряд идут. Нет, так вот же три подряд, вот эта первая, вот эта вторая, следующая за ней, вот эта третья, следующая за
второй. Ой, да, да, извините. Окей, окей. Вот, и последний пример я нарисую, близкий к предыдущему, это вот такой пример.
И вот здесь какое-то такое касание происходит. То есть почти всё, почти всё идеально, только на вот
этой вот стороне лежит какая-то другая вершина. Это тоже плохо, мы такого будем избегать, потому что
после этого наш треугольник распределяется на два несвязанных, и это плохо, мы такого не хотим. Вот что такое ухо,
это вот треугольник из трёх подряд ищущих вершин, который можно отрезать. Утверждение, в любом
многогольнике, ну давайте мы напишем в любом простом многогольнике. Простой это значит, что его
стороны попарно не пересекаются, то есть у него нет самоперещений, то есть без самоперещений.
То есть его граница, это одна замкнутая ломанная без самоперещений, какая-то такая штука, а не вот
такая какая-то, которая пересекает сама себя много раз. В любом простом многогольнике,
хотя бы четыре, есть хотя бы два не пересекающихся уха, есть хотя бы два не пересекающихся по
внутренности. Доказательства индукции по построению, индукция палин, индукция
ПП. База N-4 у нас есть всего два, ну два типа многогольников на N-4. Это как для N-3 у нас
есть всего один треугольник, так для N-4 у нас есть выпуклый четырёхугольник, вот такой вот, и не
выпуклый, такая вот галочка вложенная, такая вот галочка. Ну понятно, что у них у обоих есть два уха,
первое и второе, здесь тоже первое и второе. Причем, если в выпуклом случае мы можем так,
ну найти такие два уха без самоперещений двумя способами, то есть можно провести вот эту красную
диагональ, можно провести вот такую зеленую противоположную, и будет другое разгонение
на два уха. Ну не важно, главное, что оно какое-то есть. В не выпуклом случае тоже оно есть, причем
оно обязательно только одно, только одно только разгонение на два уха. Теперь переход. Давайте
мы посмотрим на какую-то вершину произвольную, которая выпуклая. Выпуклая вершина. Что это значит?
Произвольная выпуклая вершина. Ну это значит как раз, что угол при ней меньше чем 180 градусов,
вот такой был меньше, чем P. Выше я рисовал картинку, где угол при вершине был больше 180
градусов, давайте его установлю. Вот какая такая, если картинка, да, то есть когда вы идете от
одной стороны к другой, когда вы делаете такой поворот, вы поворачиваетесь на 270 градусов,
например, когда у вас во в нужности лежит большой угол. Это плохо, это тогда не выпуклая вершина,
а выпуклая вершина, это когда у вас этот угол при ней меньше чем P. Обычно нормальный угол
поворота. Какая-то такая картина. Итак, рассматриваем произвольную выпуклую вершину WE и двух ее соседей,
WE плюс один, WE минус один. Давайте проведем вот такой отрезочек между ними, поймем, правда ли,
что это ухо или нет. В идеале, если это ухо, если как раз на вершине WE мы получили здесь ухо,
то давайте мы просто отрежем, перейдем к меньшему многоугольнику, у которого уже на одну вершинку
меньше. В нем по предложению индукции будет хотя бы два непредсекращихся уха, и значит,
одно из них я могу объединить или их просто оставить, и у меня будут уже два уха. То есть,
на самом деле у меня уже получится три уха, но это не важно, главное, что есть хотя бы два. В хорошем
случае, когда мы нашли вершинку, в которой уже торчит ухо, мы просто отрезаем, и по предложению
индукции в этом меньшее прямоугольнике есть хотя бы два уха. Извините, не прямоугольники, а многоугольники.
Это хороший случай, когда мы можем отрезать эту прямую, то есть, когда вот здесь нет точек,
нет точек, и эта вершина выпукла. Это критерий того, что эта диагональ нам отрезает ухо.
Значит, плохой случай, это когда у меня в этом треугольнике нашлись какие-то другие вершины.
Я провожу этот отрезок. И там нашлись какие-то другие вершины. То есть, картинка какая-то вот такая,
ну что-то такое. Тогда давайте сделаем следующее. Давайте мы среди всех вершин, которые попали
внутрь этого треугольника, точнее, внутрь или на его границу, мы найдем такую, которая ближе всех
находится к точке ВИ. То есть, из всех этих, в нашем случае, трех вершин, которые попали
во внутренность нашего треугольника, мы найдем самую близкую к ВИ. Вот это будет точка КУ.
Самая близкая к ВИ среди точек внутри треугольника. Внутри или на границе треугольника.
Тогда я утверждаю, что ВИ-КУ это диагональ. Это практически очевидно, потому что, смотрите,
когда я провожу вот этот отрезок из ВИ до КУ, на нем точно нет никаких других точек. Потому что
мы взяли КУ такую, что она самая близкая к ВИ внутри треугольника. Ну а этот отрезок, он понятно,
он тоже лежит внутри треугольника, значит, на нем нет никаких других точек и, соответственно,
никакие другие стороны его не пересекают. Вот, поэтому это опять-таки диагональ. И мы наш
многоугольник тогда можем разбить на два. Мы можем разбить его на вот этот многоугольник. Давайте
красным вытерем, который лежит выше, чем наш диагональ, и ниже. Второй. Ну и, собственно, победа,
да. Ну, то есть, тут надо аккуратно посмотреть за количеством вершин, но понятно, что в обеих
частях будет хотя бы по три вершины. Здесь хотя бы три, здесь хотя бы три. Значит, в каждой части
есть хотя бы одно ухо, то есть там либо ровно три вершины осталось тогда, просто это один треугольник
уха, либо это там хотя бы четыре, и по предложению дукса там хотя бы их два. Значит, обязательно есть
и там, и там по уху, ну вот, суммарно их будет опять-таки хотя бы два. Вот вроде победа. Мы нашли такую
диагональку за счет того, что взяли самую близкую точку внутри треугольника к ВИ и, соответственно,
ее больше никто не будет пересекать, потому что иначе, а там, если бы ее кто-то другой пересекал,
там что-то такое, если бы ее пересекал кто-то, то за счет того, что мы как бы должны как-то
выйти сюда, зайти сюда и выйти, то обязательно здесь там должна быть какая-то более близкая точка.
Вот. Хорошо, значит, мы доказали, что всегда есть хотя бы два уха. Ну тогда алгоритм строится
алгоритм триангуляции. Алгоритм триангуляции. Мы поддерживаем на треугольник, поддерживаем,
точнее, вершинам на треугольника, например, в связанном списке. То есть у меня каждая
вершина ставится на следующую и на предыдущую. Тогда алгоритм такой. Значит, на первом шаге мы
найдем и отрежем либо одно ухо, либо найдем диагональ. У меня будет такая процедура,
которая находит одно ухо в наугольнике. Find ear. Найти ухо в наугольнике. Что она делает?
Она берет, проходит по всем вершинкам и находит произвольную выпуклую. Выпуклая вершина. Затем
строить треугольник. проводит такой отрезок и смотрит, проводит такой отрезок и смотрит.
Если внутри этого треугольника ничего больше не попало, то это ухо и мы его сразу нашли.
Соответственно, его можно отрезать, изъять из нашего списка вот эту вершинку,
соответственно, перенаправить стрелочки вот здесь, вот из двух соседей друг в друга и решить
задачу на меньшее наугольник. Это хорошо. В случае же, когда это не ухо, мы сделаем следующее.
Мы найдем, как бы, почему-то не ухо, то есть найдем такие точки, которые лежат внутри треугольника,
возьмем из них самую близкую КВИ и проведем такую диагональ. Соответственно, как вышел,
у меня наугольник развелся на два кусочка. Там один и другой. И тогда я обсуждаю, что в каком-то
из них точек не больше, чем n пополам. Точно, n пополам плюс один или плюс два. Потому что понятно,
что сумма арта в них в вершинах на два больше, чем в исходном chilli dåику, потому
что в Vater и Cup считалось в一些 два раза, значит в каком-то из них точек не больше
marrow пополам плюс один. Скажем, здесь точёк не большеиля взaced further, н minus five also 1
1 и давайте я запарусь рекурсивно от того наугольника в плульсках уха то это какой-то
под наугольник. Я в нём найду ухо рекурсивно и его отрежу.
И потом опять буду решать задачу на исходе многогонника, от которого откусно ухо.
Тогда время работы будет примерно таким. Это какое-то линейное время, чтобы, во-первых,
найти произвольную выпуклую вершину и проверить, что мы отрезаем ухо.
Если мы отрезали не ухо, то значит, мы нашли Q, и наш многогонник сократился в два раза.
Тетан пополам, тогда тетан это тетата.
Еще раз, мы проверяем какой-то треугольник на то, ухо это или нет. Если ухо, то отрезаем,
и получается, мы за линейное время прохода по всему многогоннику, мы отрезали какое-то ухо,
теперь решаем задачу на меньшем многогоннике, опять, там n плюс m minus 1 и так далее, будет
квадратичное время. Если же это не ухо, и, соответственно, здесь лежат какие-то другие точки,
то давайте возьмем самую близкую Q, и, соответственно, многогонник разбесован на два кусочка,
легко это переписать в серверах double linked list, то есть в связанном списке есть одна половинка
и другая, в одном из них в каком-то вершине меньше, чем в другом, меньше половину. Вот я от него
запускаюсь и крусивно, там делаю тоже самое, нахожу какое-то ухо, отрезаю, и получается,
что я за вот такое время могу найти ухо, ну, одну из ушей в нашем многоугоннике, отрезаю и решаю
задачу на меньшем многоугоннике, тогда весь алгоритм для ангуляции работает за квадрат.
Вот, если нет вопросов, то спасибо, на этом мы заканчиваем,
отмечу только лишь в конце, что существует алгоритм за НЛГ, мы его, наверное, не будем рассматривать.
Он сильно сложный или нет? Ну, не особо. Хорошо, ладно, до свидания. Вот, да, спасибо, до свидания.
