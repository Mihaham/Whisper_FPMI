Да, ну начнём мы с того, что, наверное, добьём тему двоичных
деревьев поиска.
Ну добьём в каком плане, потому что остались, конечно,
одни очень популярные деревья, которые мы с вами так не
обсудили.
Как вы думаете, что за деревья?
Конечно, да.
Вот, ну не то чтобы мы будем сильно много времени на
них тратить, потому что, думаю, там вам, наверное,
не надо рассказывать, что такое эти карты и деревья,
как делать всякие разворотно-подотрески и так далее.
Или надо?
Нет, ну, думаю, вам не надо.
Тем более, мы уже выяснили, что идей на в общем-то необходимости
в них никакой нет, потому что овель дерева умеет всё
то же самое, только за честный логориф.
Вот, но кратенько всё-таки вынуждены чуть-чуть напомнить.
Действительно.
Ну зачем вообще нужны дикартовые деревья?
Ну дикарты деревья нужны как минимум для того, чтобы
код вписался чуть-чуть попроще.
Вот, ну потому что мы видели, что там, скажем, овель и красно-чёрная
там, вот это всё, там писать все эти, прописывать все
эти повороты, это немножко больно.
А вот тут появляется такая вероятность той структуры
данных, которая говорит там о том, как балансировать.
Да очень просто.
Давайте-ка скажем, что у нас есть ключи, по которым
у нас есть двоичное дерево поиска.
А теперь мы говорим, а давайте в каждой вершине мы сгенерируем
ещё какое-нибудь рандомное число.
И будем говорить, что, вот, что по, вот это число мы
назовём приоритет, и по этим приоритетам у нас там
дерево должно образовывать кучу на минимум.
Вот.
Соответственно.
И тогда, вот, и после этого тогда у нас появляются
действительно какие-то достаточно простые сплиты
и мержи.
Вот, которые там, которые действительно, скажем, мерж
базируются на том, что если нам нужно слить два дерева,
а напоминаю, что пока, пока, подчёркиваю, мы сливаем
два дерева, в котором там, здесь находятся ключи
меньше либо равные х, а здесь находятся ключи больше
чем х.
И тогда слияние происходит действительно простым
естественным образом.
Рассмотрим два корня и выберем у кого приоритет меньше,
тот и есть корень.
Если у нас слева, если у нас тут приоритет оказался
меньше, то тут мы, соответственно, берем лево, берем право и,
то есть тут уже рекурсивно объединяем и просто подвешиваем.
То есть инвариант соблюдается, собственно, нас устраивает.
То есть дальше балансировка у нас гарантируется за
счет того, что мы верим в это, верим в то, что вероятность
того, что здесь там высота дерева будет какая-то
нелагеритмическая крайне мала.
Вот.
Осталось только это доказать, но мы этого сейчас делать
не будем.
Вот.
Да, но тут, в общем-то, да, действительно, ну, это
нечего тут особо рассказывать.
Действительно такое, ну, по крайней мере, рассказывать
можно, конечно, бесконечно долго, но вероятность того,
что вы ничего из этого не знаете, мы не будем.
Поэтому надо, конечно, называть это сейчас не обсуждать
подробно дикартовые деревья, а рассказать что-нибудь
более, действительно, что-нибудь такое более интересное.
Например, дерево отрезков.
Вот, вы не знаете, да, называется, может показаться, да, казалось
бы, да.
Ну, казалось бы, что там, казалось бы, что там может
быть проще.
Но вот, тем не менее, оказывается, что кое-что там есть, ну,
мы даже пойдем сейчас не в дерево отрезков, а все-таки
копнем даже немножко в большую базу, потому что везде на
самом деле какие-то мелочи есть.
Но, правда, есть вот маленькие оговорчики.
Да, то есть, конечно, то есть обычно в таких лекциях
говорят, что вот там есть задача R S Q, есть задача R M Q.
Да, вот давайте вспомним, что такое задача R S Q.
Да, это означает, что у вас есть массив, там, ну, там,
например, элементы от одного до N, допустим, или от нуля
до N минус один, как договоримся.
И нам очень хочется решать такую задачу, то есть, в идеале
нам хочется решать задачу найти сумму на подотреске
с L по R и изменять элемент.
Ну, например, пока в простой версии изменять один элемент
там в одной позиции.
Вот такова у нас задача R S Q.
Но есть, конечно, классическая задача R M Q, где то же самое,
только на ототреске нужно искать какое-нибудь минивум.
Вот, так, тоже с каким-нибудь прессами, тут по умолчанию
в точке.
Вот, но мы это, ну, вот, то есть мы эти задачи попробуем
обобщить.
Мы будем решать задачу R Q, где операция Y это какая-то
абстрактная операция.
Вот, но, но как повезет в зависимости от чего.
Вот, потому что, ну, здесь можно рассматривать обычно
два случая.
Первый случай, когда операция Y, то есть Y оказывается ассоциативна.
Ну, вот давайте так скажем, коммутативна и обратима.
Вот так скажем.
Вот, но на самом деле обратимость уже сама по себе подразумевает,
ну, нулевой, точнее, единичный элемент есть.
Куда же деваться.
Вот.
Ну, если у нас операция Y устроена действительно вот
таким вот образом, то тогда в некоторых случаях у нас
решение становится халявное.
Какие случаи, какие случаи я имею в виду?
Ну, первое, что хочется рассмотреть – это конечно
задачу статик R Q.
Что означает статик?
это означает что массив не меняется вообще в принципе уже мы себе тут
облегчили жизнь таким образом что что в этот массив не вставляются никакие
элементы не удаляются некие элементы вот значит как-то она вот а тут
предлагается что давайте совсем облегчим себе жизнь то есть условно
говоря от нас требуется только один запрос быть на подотрезке от эль-дайер
ну что делать если у нас операция обладает аж до такими свойствами да ну
конечно за этот метод называется префиксный быть логично да то есть если
вот массив называется а то мы можем назвать то мы можем объявить что
допустим па там и ты присвоить себе там просто а первая быть а второе быть и так
далее быть а это вот но ассоциативность позволяет нам как минимум не писать
скобочки но как во всем позволяет насчитать такие префиксные уйти за
линию что что ну пока не пользуемся но да по большому счету да коммутативность
там в общем-то тут не особо нужда нам надо на самом деле хватает обратимости
хватает обратимости сказать что уйти от эля это на самом деле равно чему там
па значит отель минус 1 в минус первой быть вот как да да вот конкретно здесь
вот в таком написании не пользуюсь так но на чем с того что вот нет давайте
парализируй смотрите смотрите раз зашла и что вот это такое я утверждаю что это
равно а л-1 в минус первой быть а л-2 в минус первой быть и так далее быть так
у нас там один индоксация до быть а первое в минус первый дальше мы пишем
вот по эра начинаем писать значит а первая быть а второе быть и так далее быть ар
но вот да и начинаем видеть что тут вот у нас шлёп шлёп ну вот соответственно потом тут у
нас появляется там шлёп шлёп ну и так далее в общем тут все шлёп шлёп шлёп шлёп и получается
ровно то что нам надо поэтому коммутативность тут оказывается даже особо и не нужна то есть в
общем-то обратимость и нам вот так хватает поэтому можно тут ее даже вот так закрепить
да это такой вот самый простой вариант называется да то есть обычно чаще всего
кашь применяется когда это просто обычная сумма там каких-нибудь чисел мы там любых
обычно целых чисел там рациональных действительно каких углов комплексных даже можно в принципе
пожалуйста дойдем дойдем как бы сейчас все дойдем все поговорим тем более что там как бы есть
просто интересные мелочи ответвления вот потому что действительно следующий шаг говорит а что
делать вот у нас случай номер два если уить оказалось необратимо вот так вот повысим себе
планочку быть оказалось просто ассоциативно может быть даже нет никакой гарантии на коммутативность
но самое главное нет гарантии на обратимость ну какие какой пример идти мы можем вот с вами
уже взрослые люди с вами можно разговаривать да да да да ну самый простой пример это
произведение по непростому модулю там по модулю там вот нет но оно коммутативно хорошо но можно
привести примеры каких-нибудь чего чего-то это не коммутативно что ли а ну в этом смысле
а это да но это операции не ассоции не ассоциативно я боюсь не но не сдано я бы тут у нас сразу
честно скажем что есть у нас операция не ассоциативно то наши все подходы тут конечно все да потому
что у нас все подходы базируется на том что мы там какие-то подотрески уже заранее предпочитали
и все остальные комбинируем из них тут в общем-то без этого как-то и не очень вот
вот нету на самом деле нет нет вы читание тоже так себе коммутативно да вот ассоциативно
вот а вот если брать хотя бы произведение матриц 2 на 2 не гарантированно вы не гарантированно
вот вам и пожалуйста да вот поэтому я и говорил да вот вы взрослые люди с вами можно разговаривать
на таком языке вот а то обычно там придет что в 8 вот обычно это рассказывает где-нибудь там
всем там в восьмом классе в девятом да и там уже называется матрицами лучше не пугать никого вот
но не важно но вот но мы теперь но ты так у нас операция ассоциативно что можно сделать ну пока
вы находитесь в восьмом девятом классе вам все-таки дают все-таки какое-то облегчение облегчение
говорят но там но облегчение может сказать что у нас это минимум например но что но вот что вот
если это минимум стита каких-то чисел как тогда решать задачу но выясняется что можно завести
конечно знаменитый спар стейбл что означает спар стейбл ну спар стейбл по сути означает что
мы находим минимум на всех подотресках длины степень двойки то есть мы там заводим там так
и пишем ст и т л т присвоить там допустим в данном случае минимум на минимум значит от а и
пум-пум и плюс два степень или минус один вот я вот подотрески массива буду так писать вот
ну думаю достаточно очевидно что это то есть размер этой таблицы какой до н лог насчитать
ее тоже можно легко за н лог потому что любой подотрезок длины два степеней легко там минимум
на нем легко насчитывается как минимум из двух отрезков длины два степень или минус один думаю
очевидно да но а после этого говорится следующее заметим что любой подотрезок длины там просто
абсолютно любой подотрезок от любого l до любого r так ну давайте тут вот лен давайте все-таки
хранить чтобы лена и не путать оказывается он покрывается двумя отрезками длины два в одинаковой
степени вот чему это нас приводит то есть оказывается давайте просто возьмем минимум на этом
отрезке возьмем минимум на этом отрезке и поздравляю но ты собственно минимум из них это минимум на
всем отрезке ура логично да так вот первое сказать вопрос начинает у нас если уйти минимум а теперь
искать вопрос какими конкретно свойствами минимуму мы воспользовались чтобы написать
такую крутую структуру да то есть действительно начитут если в скобчиках написать то во первых
мы замечаем что уйти у нас коммутативно
ну хотя вот ну хотя да коммутативность тут действительно в яхте в смысле важна но тут
конечно ключевым является даже немножко другое свойство да то есть знаменитая и
демпутентность не самое популярное слово но тем не менее вот что это означает это означает что
уйти от xx равно x в смысле отрете чего-чего-чего и что тогда я сказал надо просто отрезки находить
минимум в конце будем нажать на 2 но вот обычно то есть первая идея конечно что-то идем по
тетость для того чтобы то есть как бы если мы в минимум подсунули два одинаковых элемента то
ответ от этого не поменялся но конечно важна коммутативность чтобы те два элемента могли
схлопнуться да потому что если я просто запишу там вот это это на это на это на это на это на это
на это на это на это на это на это на это на это на это на это на это на это на это на это на это на это
то рядом одинаковых элементов нет никто не схлопнулся да поэтому коммутативность нам здесь
все-таки нужна да вот то есть это обычно но обычно вот так классический пример минимум
в общем практически не для чего обычно спортсы и не пишут да да да да да да да да да да да да
действительно действительно а теперь заметим сюда коммутативность нам на самом деле не нужна
потому что мы можем сказать что этот отрезок это вот этот отрезок на вот этот отрезок а вот
этот отрезок это вот этот отрезок на вот этот отрезок и получается средний все равно схлопнется
утверждение на самом деле до коммутативность нам не нужна почему она не нужна потому что вот
рассмотрим вот эти два отрезка заметьте что они пересекаются да давайте представим себе что вот
вот скажем что тогда в силу ассоциативности оказывается что вот этот отрезок это вот этот
отрезок умножить на вот этот отрезок а вот этот отрезок заметьте мы это вот этот отрезок на
вот этот отрезок тогда кажется если мы перемножим вот этот отрезок на этот отрезок на этот отрезок
на этот отрезок то эти два отрезка по диппатентности схлопнутся
а мы из отдела следующем но на языке минимума мы эти все элементы заменили на минимум между ними
вот вот то есть как бы тут тут один элемент и тут один элемент поэтому как потом мы берем
минимум типа между ними оказывается что это что так как это одинаковый элемент а то мы их и пишем
так что действительно да оказывается да от коммута там коммутативность действительно
побеждается в общем-то нам достаточно и диппатентности вот что делать если диппатентности нет вот подсунуть
нам произведение матриц 2 на 2 но вот но тут выясняется действительно что у спортстейбла есть на
самом деле маленькая красивая модификация называется диз джойн спортстейбл так а ну как кто сталкивался
с такой штукой популярно окей вот но про но тем не менее уже половина не всем но давайте разбираться
да как же нам что же нам сделать если уить у нас не но вот если действительно у нас оказывается
быть остается только и диппатентный то есть давайте пишем 2 б только ассоциативность
тогда оказывается то есть можно изобрести действительно диз джойн спортстейбл вот
вот ну тут идея такая чтобы все то есть хочется все-таки да построить какой-то спортстейбл но так
чтобы то есть каждый отрезок появлялся в виде объединения двух каких-то отрезков но так чтобы
они уже не накладывались друг на друга но как же это сделать но идея возникает такая но то есть
идея возникает такой неожиданный разделяй властвуй потому что вот рассмотрим массив если мы
рассмотрим массив то этого массива есть вот да вот давайте даже сейчас для просто скажем так
на будущее что у нас все-таки все от нуля до n-1 и тогда идея такая давайте можно разделить
массив примерно напополам и сказать что отрезки бы под отрезки бывают трех типов каких да они
говорят те кто слева те кто справа и те кто пересекаются как бы проходит через вот эту
границу тогда идея такая значит мы сейчас на ваших глазах за линейное время научимся
считать ответ для всех под отрезков которые пересекают эту границу вот звучит пафосно может
даже магически пока вы чуть-чуть не включили мозг как только включили мозг вы обнаружили
что ничего сложного в этом нет потому что что нужно чтобы за линию научиться насчитывать все
под ответы для всех под отрезков которые пересекают эту границу но очевидно надо
насчитать ответы на всех префиксах правого массива и на всех суффиксах левого массива
это делается в общем-то не сильно сложно понимаете да вот ну а что мы но а что делать вот для этих
отрезков но для этих отрезков мы будем работать рекурсивно то есть по сути мы получается построим
значит возьмем такой значит вот эту вот границу насчитаем на не ответ тут и вот тут почему нас
вот на этом уровне будет прямо действительно ровно n элементов то есть все кто правее границы для
них будет насчитаны префиксные идти а для всех кто слева будет написано суффиксные выйти вот
та переча но вот ну и идем рекурсивно теперь у нас тут получается две половинки массива в
каждой из них тоже есть теперь своя середина и мы на ней тоже насчитаем эти так и эти так вот
вот ну и так далее вот
что вопрос вопрос какие-то или что да да ну здесь уже где неправильно что неправильно да вот сейчас
правильно вот так вот вот так вот вот так вот ну и так далее в общем так вот
вот ну дальше рисовать не буду думаю хотя ладно нет давайте вот все-таки дорисуем
предположим что у нас 16 элементов вот ну и тогда там в каждом вот это в каждом этом префиксе
суффиксе тут будет уже где-то по одному элементу все закончится вот и вот казалось бы действительно
то есть теперь идея очень простая то есть для любого подотрезка теперь можно найти такой отрез
то есть то есть для любого теперь вот отрезка или который бы тут не был на массиве можно найти в
этом спортстейбле подотрезок такой что во первых вот наши исходный отрезок лежит внутри там
какого-то подотрезка таблицы и при этом пересекает его середину логично да как его найти но если он
пересекает глобально середину массива то это вот самый первый отрезок и есть в противном случае
он находится либо слева либо справа вот допустим там оказался справа тогда мы идем сюда если он
пересекает вот эту границу то вот он и лежит в противном случае мы идем тоже влево и вправо и
так его находим вот смотрите тут такой момент пока такой алгоритм работает залог это да но
опять не но ты да но ладно есть до мелко оговорка что есть отрезок для меня 1 но правда отрезок
для меня 1 можно считать что пересекает границу из себя любимого да но такой поддав ну понятно
да что да если у нас отрезок длины 1 то скорее всего мы и там умеем его искать и так тем более
что мы же говорим о статике то есть это означает что если вас запросили отрезок длины 1 вы просто
достаете нужные элементы его выдают вот но здесь смотрите то есть отличие от называть от как мы
скажем будущим дерево отрезков но собственно это уже про очень похоже на дерево отрезков хотя
больше похоже на полный протокол какого-нибудь там какой-нибудь там сортировки слиянием да когда
вы там в каждой вершине храните там там линии там не от единицы информации олинию точно здесь
уже преимущество заключается в том что да то есть залогари вам придется искать конечно может
быть саму вершину но зато операцию идь вам придется сделать от единиц уж как только вы найдете что
там у вас отрезок вот какой-то вот такой то выберете суффикс или там суффикс здесь делаете
с префиксом здесь и получаете ответ на задачу то есть получается уже от единицы идти и от
логарифма вот таких спусков это уже неплохо вот да да да это следа да это следующий это следующий
шаг но пока почеку что как бы то что я сказал это уже может быть неплохо да то есть мы сейчас конечно
от этого логарифма тоже избавимся но на самом деле эти бывают на самом деле очень жирные там
особенно если выяснить что эти такого и там запрос какой-нибудь вы там в какой-нибудь базе
данных про интернету то на самом деле может оказаться что-то там вам в общем-то на этот
�убе рифму уже и наплевать потому что он там но потому что он там будет занимать
мизерную часть от этого запроса по интернету вот а с точки зрения конечно там более абстрактно
и там какой-то абстрактной математике конечно это все равно остается ловили там логарифм есть
логарифом. И теперь есть какая-то вопрос, а можно ли действительно этот подотрезок
действительно найти как-то, как-то действительно за вот единицы. Оказывается, можно. И технология,
оказывается, вот, оказывается такой. То есть, во-первых, нам придется предположить,
что наш размер нашего массива это степень двойки. Вот ровно степень двойки.
Вот, ну понятно, что ничего страшного в общем-то там не асимпатически не дает,
потому что, ну там, если n не степень двойки, ну там добьем массив какой-нибудь бякой лишней
и не будем париться. Вот. Ну тогда, значит, давайте теперь нод. Тогда, смотри, тогда мы
можем заметить, нод, ну что мы здесь можем заметить? Тогда мы можем заметить, что вот эта
граница, это у нас два в степени k-1. Да? Здесь граница два в степени k-2 и три на два в степени
k-2. Вот дальше тут у нас граница получается два в степени k-3, тут получается три на два в степени
k-3, значит тут получается там пять на два в степени k-3, тут получается семь на два в степени k-3.
Чего? Что тебя смущает? Нет, это не отрезок, это позиция в массиве глобально. Вот. Так,
то есть на самом деле тут, то есть что тут можно заметить, да? То есть можно заметить следующее,
что это вообще за числа? Вот. Ну, чего? То есть заметим, что если мы рассматриваем натуральные
числа меньше, чем два в степени k-1, то мы видим, что вот это число это единственное число, которое
делится на два в степени k-1. Эти два числа, что это за числа? Это такие числа, которые делятся
на два в степени k-2, но не делятся на два в степени k-1. Вот. То есть вот эти числа – это
числа, которые делятся на два в степени k-3, но не делятся на там большей степени двойки.
То есть, по идее, про каждое число можно сказать, на каком уровне оно окажется разделителем,
то есть что? То есть чтобы определить этот уровень, надо просто определить,
на какую максимальную степень двойки это число делится понятно да вот приятно вот то есть это
вот с одной стороны но с другой стороны теперь в нашей теке когда нам дается число lr нам нужно
что когда нам нужно такое вот число l not lr вот допустим мы ищем что нот ну что мы ищем но
но допустим и вот под нот ну да то есть допустим мы вот ищем подотрезок и лер то есть вот тогда
что нам нужно нам на этом подотрезке нужно найти вот получается вот какой-то разделитель то есть
по сути задача будет такая надо найти какое-то число x такое что l меньше либо равно x меньше
либо равно x делится на 2 в степени лен лен максимально возможно понятно да и тогда и тогда
если мы найдем хотя бы но вот но да но то есть ну в принципе да то есть наша цель найти такой
лен вот но заметим что если мы уж какой-нибудь лен такой найдем то в общем-то но то в общем-то
все остальное мы уже по лену восстановим правда то есть как бы если мы знаем лен то x восстановить
тоже достаточно просто да то есть понятно что при известном лене получится что x равно по сути
r минус там r процент там 2 степени лен логично да вот ну потому что это ближайшее к эру
метам меньшее число ну или точнее не больше которое делится на 2 степени лен и оно как бы либо
подходит нам либо нет понимаете да вот но теперь вот внимание вопрос да как же такое такой x вот как
же такое найти но вот ну давайте дать да действительно давайте разбираться да потому
что раз степень двойки значит наверно какие-то биты надо надо писать да но спорить породить
сейчас вот давайте разбираться постепенно все сюда и так рассмотрим числа или рассмотрим их
битовое представление но заметим следующее что некогда мы идем слева направо lr но про
lr мы знаем что l меньше либо равно r и мы знаем что они совпадают совпадают там с какого-то
момента начинаются единички там потом опять нолики но пока мы знаем что x в общем-то обязан
будет совпадать с ними правда тот получится 1 1 и то тот бабах но если l равно это это
случай нам особо не интересен да вот но если l меньше чем вот бабах произошла первая ситуация
когда в эле находится нулевой бит а в эле единичной вот и что-то теперь происходит вот такое вот то
есть тут какой-то вот то есть там какой-то безобразие тут какое-то безобразие но впрочем
на самом деле тут теперь два варианта вот то есть принципе есть два варианта первый вариант
либо ну если так формально рассуждать либо кажется что то есть вполне может на самом деле
оказаться вот кстати тут давайте я даже для простых даже еще тут напишу вот допустим тут 1 1
а тут 0 0 0 0 ну во первых действительно может оказаться так что у эля здесь все числа нулевые
ну может такое быть правда тогда я думаю становится достаточно очевидно что лен что
такой максимальный лен это вот это количество нулей то есть тогда вот тогда получается вот
само по себе число l в общем-то нам и подходит понимаете да вот ну кстати да надеюсь да я
думаю достаточно очевидно что для каждого числа от 1 до n вот это вот предпочитать эту
максимальную степень двойки можно за линию правда вот но вот но замечаем да что если тут вот после
этого но после этого момента действительно у нас тут нолики там только нолики то и льдам и
подходит вот но в противном же случае что можно сказать если тут хоть где-нибудь хоть какая-нибудь
единица донашлась но тогда ответ очевиден тогда икса канут тогда икс оказывается нужен 1 1 0 1 0 0 1 и
0 0 0 0 то есть надо вот после этой единицы запихнуть нули вот ну потому что действительно заметим
что между л и р очевидно то есть очевидно уж теперь то есть больше чем вот столько нулей в
начале там в конце идти не будет видно да но чтобы шло больше тут уже 0 и чтоб тут пошло дальше вот
а ровно столько будет идти ровно в этом числе но в общем-то кстати можно заметить что и только в нём
остается только понять как же это найти но очень просто потому что вообще во-первых то есть надо
понять а как этот бит вообще найти где они вот первые начинают различаться ну вот то есть
до самом деле заметим что это действительно что вот это вот это действительно старший бы но то
есть это вот действительно старший бит старший бит в такой штуке как альк сор э вот то есть
Если мы возьмем LXORR, то все вот эти биты обнулятся, а этот будет единичным.
Ну, то есть там, конечно, для того, чтобы его найти, видимо, придется тоже делать какие-то предподсчеты.
То есть там для всех чисел от 0 до 2 в степеника придется предподсчитать, кто у него старший бит.
Но это тоже за там, за линию делается не проблема.
А можно даже и за N log N, в общем-то, потому что у нас все равно таблица за N log N.
Вот.
То есть отдельная песня, есть там какие-то специальные битовые операции, которые позволяют делать.
Но если честно, я слета таких не помню.
Чего?
32 минус...
А, беда. Ну, осталось только выяснить, за сколько этот built-in CLZ еще работает.
Да, ойли.
Точно?
А то всякое там бывает, а то полностью pop count работает все-таки за реальное количество единичных бит.
Хоть там константа, конечно, сильно меньше.
Ну окей, неважно.
Последнее рассуждение было не рассуждение, а тем, как это технически вычислять этот старший бит.
Да.
А иначе оказывает...
А иначе мы говорим так, нот.
Но а иначе оказывается, что...
Ну, что такое вот этот вот максимальный лен?
Это максимальное количество нулей, которые могут тут подряд в конце идти, правда?
Так вот, я утверждаю, что это максимальное количество будет вот ровно вот в таком числе.
То есть, когда мы вот в этом... Здесь вот префикс сохраняется, ну тут без вариантов, да?
Тут мы ставим единичку, а после этого пишем все нули.
Да, а про что вы там написали LXORR?
Это... Ну, как вычис...
Ну, тут вопрос. Даны LR, а как вычислить вот этот вот самый старший бит, в котором они различаются?
То есть, надо просто взять LXORR и там любыми средствами, с помощью битовых операций,
или с помощью их чего-то найти там старший бит.
Вот. То есть там предподсчет какой-то сделан.
Вот.
Так что тут действительно по-разному можно делать.
То есть обычно на практике, конечно, вот этот случай с L, который тут на эти нули делится,
на самом деле даже тоже не рассматривают.
Потому что, хотя в принципе, можно было не заморачиваться.
Потому что в принципе можно было, можно в любом случае, даже если тут везде нолики,
можно все равно вот там, допустим, вот это число, вот этот X рассмотреть,
рассмотреть соответствующий уровень лен, и в нем соответствующие префиксные суммы найти суфиксные.
Разница будет только в том, что просто там...
Так, если у нас L прям вот тут такое с ноликами, это означает, что в соответствующем подотрезке
вам на префиксе просто придется взять весь подотрезок.
Ну, в общем-то, ничего страшного в этом нет.
Вот.
Но тем не менее.
Вот.
Так что вот такая вот штука оказывается, что если у нас есть только ассоциативность,
то, в общем-то, аналог спортсов даже не сильно сложнее, но такие существуют.
Так, есть ли тут какие-то вопросы?
Да, нет, наверное, есть кто живой.
Вот.
Хорошо.
Да.
Ну, вот.
Ну, нет, на самом деле вопросы там...
Нет, вопрос есть.
То есть, в идее, как бы, наука начинает спрашивать, да, но вы делаете предпочтение за НЛОГМ?
А нельзя случайно сделать за Алинию?
Кстати, отдельная песня, так слету даже...
Нет, я так слету даже не отвечу, если честно.
Хотя тут нам вообще надо задуматься, если так вообще-то уже...
А нельзя ли в общем случае доказать, что нельзя?
Кринут.
Может выяснится, что если вам там подсовывают камешки, и на камешках есть каритмическая операция,
по которой мы только знаем, что она ассоциативна,
то выяснится, что на самом деле быстрее, чем за НЛОГМ нельзя в принципе, потому что бла-бла-бла.
Вот.
Может даже и нот.
Ну, в принципе, тут на самом деле, даже если вы хотя бы для минимума ищете,
там уже не самый тривиальный вопрос, можно ли вообще сделать предпочтение за Линию,
так чтобы за УАД единицы отвечать потом на запрос.
Нет, методология, конечно, есть, и мы в свое время будем ее изучать.
Ну, как в свое время?
Есть подозрения, что либо сегодня, либо в следующий раз, на самом деле.
Ну, вот, ну, просто я...
Ну, максимум через две недели.
Вот.
Да, соответственно, это была нот.
Ну, пока мы на этом остановимся.
Вот.
Но это у нас были статические случаи.
Это были статические случаи.
Да, то есть когда у нас операция только ассоциативна, но у нас...
Только ассоциативная, и массив при этом не меняется.
А что делать, если массив меняется?
Что в таком случае делать?
Ну, в принципе, да.
На самом деле...
Да, вот действительно.
Да-да-да.
Вот давайте так и посмотрим.
Какая первая идея возникает?
Вот теперь представим себе, что у нас есть действительно уже более классическая задача.
В которой надо делать ыть на отрезке.
И, соответственно, изменять один элемент.
То есть что-то переприсваивать.
Ну, самое тупое, что можно сделать, это, конечно...
Ну, там есть такие два крайних случая.
На самом деле, каждый из которых может вам неожиданно помочь.
Крайний случай номер раз.
Ну, вот, допустим, да.
А вот, опять же, давайте пока скажем, что ыть ассоциативно и все.
Вот ассоциативно.
Тогда, конечно, первая идея, которая возникает, вот самое тупое, что можно написать, и это иногда помогает.
А давайте просто не заморачиваться.
То есть делаем вот эту штуку в тупую и вот эту штуку прям в тупую, прям фориком.
И иногда это помогает.
Потому что, то есть, тут надо внимательно смотреть.
Потому что, давайте, вот вам дана задача.
Там, допустим, находить ыть на отрезке и изменять элемент.
Как бы вы можете там забабахать.
Кто-то может там забабахать.
Так, ой, мы же на прошлом лекции изучили овл.
Давайте писать овл.
Ой, мы же изучили красно-черное дерево.
Ну, круче.
Давайте писать красно-черное дерево.
Ну, пока вы его пишете, придут какие-нибудь маленькие восьмиклассники, которые не изучали красно-черное дерево.
И вообще ничего не изучали.
Поэтому, что как они будут решать задачу?
Они внимательно прочитают задачу, посмотрят на ограничения.
О влечениях написано.
Гарантируется, что вот эта операция происходит не более чем пять раз.
Что они тогда скажут?
А давайте делаем префиксный ыть.
Ну вот, скажут восьмиклассники, потому что префиксные суммы уж как-то, наверное, не изучали.
Или додумаются сами.
Чего?
А если ыть не обратима?
Если ыть не обратима.
Ну вот.
Ну ладно.
Так, проблема.
Хорошо.
Ну они набирают...
Ладно, они набирают 55 баллов, потому что там в первых трех группах гарантируется, что операция обратима.
Вот.
Ну ладно, да.
Хорошо, да.
Ну ладно, согласен.
Согласен, да.
Налоги тут не совсем уместны.
Да, не совсем точно получилось, но не суть.
Ну суть действительно в том, что если оказывается, что у вас массив меняется не сильно много раз,
то оказывается выгодно насчитывать частичные суммы.
Если там префиксный сумм или какой-нибудь spark stable.
А если, допустим, а если массив элемент изменился, значит мы тогда ее просто пересчитываем в тупую.
И это оказывается оптимальнее, чем любое там дерево отрезков, которое вы тут можете написать.
Вот.
Но бывает, конечно, другой крайний случай, когда у вас, наоборот, массив меняется часто, а вот этих ИТ мало.
Ну тогда наоборот.
Тогда выгодно вообще ничего не делать, просто делать все в тупую.
Тогда ИТ вычитать чисто за линию, это тоже оптимально, оказывается.
Вот.
Но, конечно же, бывает, чаще все-таки встречаются задачи, когда и то, и то встречается достаточно часто.
Там примерно одинаково часто.
То есть, что же тогда делать?
Какая первая идея может возникнуть?
Ну первая идея, действительно, может возникнуть.
Действительно.
Ну да, наверное, надо как-то все...
Хочется хранить какие-то префиксные суммы или суффиксные суммы.
Но делить как-то подотрески надо.
Ну да.
Вот такой совсем spark stable, конечно, похоронить не удастся.
Потому что если один элемент поменялся, то вам придется тут целый логариф массивов поменять и в каждом массиве менять за линию.
Вот. Это не очень хорошо.
Ну это, конечно, 8 точки не n log n, но как бы 8.n на запрос, это как бы могли быть честные там префиксные суммы насчитать или даже...
Соответственно.
Вот. Это нас не очень устраивает.
Да, нас устраивает следующее.
А давайте-ка поделим подотрезок.
Подотрезок.
Вот тут возникает какая-то такая неожиданная идея.
А давайте поделим отрезок на подотрезки длины.
Да. Действительно.
А давайте потом подумаем, какой пока бубен.
Вот.
То есть такая вот классика жанга.
Бубен.
Да, как-то зафиксируем константу, которую потом подгоним позже.
Такой стандартный метод.
И будем говорить.
Так. А давайте на каждом из этих подотрезков насчитаем...
Ну, например, насчитаем там префиксные и суффиксные.
Вот.
Тогда как мы будем искать сумму?
Ну, сумму будем искать так.
Ну, во-первых, если подотрезок целиком попал внутрь одного блока, то, соответственно, мы его будем...
Ладно, так и быть искать в тупую.
А в противном случае мы что будем делать?
Да, тогда мы...
Ну, вот тогда у нас отрезок делится на, значит, соответственно, целые блоки, куда попали.
Вот этот вот суффикс и вот этот вот префикс.
Ну, на суффиксе и на префиксе мы умеем отвечать на запрос за вот единицы.
Ну, в данном варианте.
В данном варианте, да.
Вот. В каждом блоке мы тоже умеем за вот единицы, то есть, получается, ответ находится.
Ну, вот.
Ну, не за о, а от ить.
Ну, ить у нас за вот единицы работает.
Поэтому получается, что ить от лр у вас может работать за сколько?
Может работать за бубен.
Вот в этом случае.
А может работать за n поделить на бубен.
Ну, скажем так.
Давайте так.
Ладно, будем говорить аккуратно.
То есть, когда я здесь пишу, мы будем говорить бубен или n делить на бубен итий.
Вот так.
Да, итий могут быть жирные.
Да.
А.
Потому что у нас блока, в которые мы тут прибираем вот в случае большого запроса,
не более чем n поделить.
Да.
Но мы ж тут заявили, что мы в каждом блоке пересчитываем итий на префиксах итина.
Так что мы тут еще и обнаглели.
Пока мы не получили n поделить на бубен и бубен.
бубен плюс бубен, но у нас есть проблема, что ассайен при вот такой интерпретации
будет работать за сколько? Да, за бубен. То есть, на самом деле, суть, в общем, особо не
поменялась. То есть, каждая операция может работать как за эндилит на бубен, так и
бубен. Вот. Так что, в результате тогда, что тогда? Есть альтернативная версия.
Альтернативная версия называется, давайте в каждом блоке, то есть, никакие
префиксы и суффиксы не храним. А все, что мы делаем, это для каждой штуки
пересчитываем сумму. То есть, пересчитываем только сумму на всем бубне. Но правда,
замечаем, что у ассайна от этого бубен никуда не денется. Потому что, если поменялся
элемент, придется вот перебегать. Даже наоборот, если бы префиксы и суффиксы хранили, то наоборот,
у нас там был шанс пересчитать хотя бы сумму за побыстрее. Правда, префиксы и суффиксы
все равно придется досчитывать. Да, если бы хранили сумму на отрезке, то, конечно,
мы могли бы за 1 пересчитывать. Это да. Но в общем случае все равно получается,
что на запрос мы тратим то ли бубен, то ли n делить на бубен, то ли сумму. То есть,
ассимптотика пока получается все равно q на максимум из бубен и n делить на бубен.
Остается только подогнать какой-нибудь хороший бубен для того, чтобы эта ассимптотика была как
можно лучше. Да-да-да. Почему 300? 324 тогда уже. Впрочем, там от констанции зависит на самом деле.
Да, с точки зрения абстрактной математики, конечно, мы говорим, что, то есть, заметь,
чтобы максимизировать нот, чтобы минимизировать максимум, то есть, что нужно, одна функция у
нас возрастает под бубен, другая функция убывает, и тогда надо найти просто место,
где они начинают пересекаться. Почему оффлайн? Нет, мы не знаем. В данном случае мы говорим,
что мы не знаем сколько кого. Да, если бы точно знали, то тогда у нас получалось бы что-то типа
q1 на бубен, там плюс q2, там n делить на бубен. И тогда оптимальный бубен, тогда у нас оказывается,
ну то есть, все равно надо их приравнять, и получается, что оптимальный бубен равно что-то типа там
корень из n умножить на корень из q2 делить на q1. Ну то есть, если, ну понятно, если q равны,
то оптимальный бубен корень из n, если там кого-то больше, то, соответственно, тогда у нас,
тогда происходит какой-то какая-то балансировка в нужную сторону. То есть, скажем, если, то есть,
если q1 больше, значит мы бубен сделаем поменьше, если q2 больше, значит мы бубен тоже сделаем побольше,
чтобы тут знаменатель был, чтобы тут вот эта droid была поменьше. Вот, то есть, да, ну в реально,
да, в реальности на практике тут еще и не только q1, q2, еще и константы могут вывести там конкретно,
то есть конкретные константы, с которыми вы делаете вот эту операцию, эту операцию, да, поэтому там,
ну вот, нет, подгонка. Нет, там подгонка где-то 300, где-то 400, то есть, там начинается, то есть,
как бы два места в олимпиаде программировали, где происходит там, на самом деле, магическая
подгонка. Это, собственно, в корневухе и в геометрии. Нет, ну мало ли еще, ну вот, ну соответственно,
да, то есть, знаете, тут у нас это, то есть, на самом деле, владеющие этой магии, то есть,
на самом деле, хорошо владеющие этой магии, особенно в последних минутах контеста, может чемпионом
мира стать, на самом деле. То есть, мы уже помним, то есть, у нас это одна, одна команда фистеха уже
так, называется там, лишилась чемпионства, потому что буквально там, называется, рядом с ней там сидела
команда, которая за три минуты до конца там угадала епсилон. Вот, нет, история реальная. Вот,
соответственно, да, был приятный, да, был веселый прецедент. Вот, в принципе, да, уже неплохо. То
есть, по большому счету, то есть, первая идея у нас какая возникла? То есть, уже, в принципе,
получается, что мы оба запроса можем делать за колень. То есть, в принципе, так уже неплохо. Вот,
ну, какие тут еще могут возникнуть варианты? Ну, на самом деле, следующий вариант возникает такой.
Так, а давайте делать это разбедение двухуровневым. То есть, идея на самом деле такая.
Чего? Ну, вот, чего эскортили? Ну, вот. Ну, нет. Ну, скажи так, с таким названием не знаю.
Ну, возможно. Ну, вот. Ладно, сделаем то, что делалось явно, что идея была явно раньше. То есть,
давайте делаем, то есть, давайте так, поделим на, так сказать, тут какой-нибудь бубен B1. Вот,
но при этом блоки по B1 у нас, может быть, будет где-то поменьше, но зато блоки мы еще сгруппируем
в блоке какой-нибудь там, допустим, какой-нибудь B2, который равен B1 умножить на что-то. Вот, то есть,
какой-нибудь такой. Ну, ладно, или лучше легче сказать, что B2 просто делится на B1. Чего? Что,
чего нет? Ну, мы же бубны выбираем. Нет, ну, понятно, мы сейчас не оговариваем, конечно,
что мы там делаем с хвостом, но понятно, что с хвостом, в общем, ничего страшного не происходит.
Вот. Ну, тогда, ВТК, действительно, какая у нас идея? Ну, вот, тогда, то есть, идея такая. То есть,
давайте вот храним такое, давайте в каждом блоке тоже, то есть, там, в каждом маленьком блоке храним
все суффиксы при, там, суммы на всех префиксах и на всех суффиксах. Вот. Но, ну, вот, вот, на более
высоком уровне делаем хитрее. Мы тоже храним там все префиксы, все суффиксы, но с оговорочкой.
Потому что мы здесь считаем, что у нас всего вот это, то есть, на этом уровне мы храним только B1
элементов. То есть, идея такая, то есть, я беру ИТ на каждом из этих подотресков, записываю куда-то
сюда и его в явном виде храню. Ну, вот. Ну, да, B2 поделить на B1 элементов. Ну, то есть, идея, ну,
идея такая, то есть, вот у нас есть какие-то вот N поделить на B1 отрезков. На каждом из них мы
насчитали ИТ, записали эти, значит, эти ИТ на подотресках в массив отдельный. И на этом массив тоже,
в свою очередь, поделили на, там, блоки по B2 поделить на B1, условно. Ну, вот. Ну, типа-то, ну,
можно так сказать, да. А можно сказать, что мы поделили на блоки по B2 и внутри каждого из них
забабахали, так сказать, корневуху в кавычках по B1. Можно, ну, по-разному можно это претировать,
но суть такая. Вот. И тогда теперь смотрите, тогда у нас это будет работать. Если мы хотим
поменять элемент, то есть, вот этот ассайн, то это будет работать, то есть, там, какой-то
элемент поменять, то это будет работать за сколько? За пересчет вот этих сумм внутри этого блока,
это будет B1. Ну, вот. И за пересчет элементов здесь. Это будет B2 поделить на B1. Это у нас ассайн.
За сколько будет работать ИТ от ЭЛЕР? Ну, ИТ от ЭЛЕР в такой интерпретации будет работать
за сколько? Вот. Ну, во-первых, мы замечаем, что у нас в ответ входит какое-то количество блоков
на вот этом уровне. А этих блоков у нас, ну, вот. А этих блоков у нас не более чем N поделить на B2.
Плюс что еще можно сделать? Ну, плюс еще надо найти ответы на суффиксах и префиксах. Ну,
суффиксы и префиксы, это значит, мы отправляемся вот в какой-то набор вот этих блоков. То есть,
сколько-то блоков тут и еще там какой-то суффикс. Вот. То есть, это уже, тут их уже получается,
там, блоков получается B2 делить на B1. Чего? Ну да. Нет. Ну, почему? Если мы суффиксы и префиксы
на блоках насчитываем, то единица. Вот. Но где-то там, правда, возникнет все равно B1,
потому что все равно может выясниться, что у нас ответ попал внутрь. Вот такой суммы. Да. Более
того, есть еще промежуточный вариант, когда нам придется, называется тут, за B2 работать. То есть,
там B2 плюс B2 делить на B1. Там что-то такое. Вот. То есть, разные вот такие варианты. Вот. Ну,
и опуская там все анализы, действительно уже очевидно, что на самом деле оптимально здесь
взять, то есть сказать, что B1 и B2 равно тоже корень из N, но на этот раз кубический.
Ну, давайте. Ну, хорошо, хорошо. Ну, господи, да, хорошо. B1 и B2 поделить на B1 должно быть корень
кубический. Вот так. Вот. Ну, вот. Ну, кстати, да, если бы это была, то есть,
здесь была структура данных для суммы, то есть, для обратимой операции и коммутативной еще сверху,
это важно. То, что бы у нас произошло, то тогда мы вообще, тогда, конечно, изменение одного элемента
мы вообще за единицу делали, кстати. Ну, да, не обязательно. Согласен. Да. Хорошо. Вот. То есть,
вот. То есть, в принципе, да, то есть получается, в принципе, что можно сказать, что для любой
константы C можно достичь все-таки корень с этой степени из N на операцию. Хотя, если C не считать
константы, то мы, конечно, обнаружим, что там больше похоже на C умножить на корень с этой степени
из N. Вот. Но если С считает константы, то, в принципе, можно сказать так. То есть, получается,
для людей, знаете, это уже теорема, с которой, да, мы уже, нет, это не вот единица. Нет,
а если, то есть, можно сказать так, для любого епсилон больше нуля найдется алгоритм,
который тратит на каждый из этих запросов от N в степени 1 плюс епсилон. Да. Чего? Ну,
я имею в виду, на каждый, на каждый из запросов он тратит повод столько времени. Ну, суммарно,
да, он тратит Q на вот это, да. Чего? А, даже Q. Да, да, да. Вот. Хорошо. Да. Нет. Тут важно для
любого епсилон больше нуля. Но, к сожалению, тут у нас восьминтотики непрерывность так не
работает. Но вот, ну, жизнь так устроена, что, то есть, оказывается, то есть отсюда не следует,
что существует алгоритм, который работает за линию. Вот типичный пример сортировка. Потому что
утверждение, для любого епсилон больше нуля существует алгоритм сортировки за N в степени
епсилон. Ну вот. Ой-ой-ой-ой-ой-ой, как всё грустно-то. Ну хорошо. Да, ладно.
ну вот и хорошо да да но хорошо ладно да для сортировки не совсем так для сортировки
теория обозвучала так да то же самое но для n степени 1 плюс айпсел то есть для любого
айпсел больше нуля то есть найдется алгоритм который сортирует за такое симптом это при
любой межсорт нам подойдет но к сожалению из этого не следует что у нас существует алгоритм
который сортирует за нинью да к сожалению вот тут вот то есть более того да вот мы еще по идее мы
впервые должны были с этим столкнуться как с фурятиной на самом деле потому что фурятине там
это можно без всякой фурятины доказать сериям о том что можно переножать длинные числа вот за
столько ну вот но это мы но это это отдельная песня это мы там собственно видимо все видимо
будем в следующем семестре активно разбираться как это делать вот но соответственно здесь вот то
же то есть принципе можно для любого то есть n в любой положительной степени но как бы до
единицы скорее всего это не дойдет но тем более что на самом деле тем более что заметим что мы
в общем-то чтобы делать произвольную константу c нужно уметь сделать произвольное количество
уровней правда но с другой стороны есть подозрение что для фиксированного n есть на
самом деле какая-то граница сколько уровней мы можем сделать ну потому что заметил что уровни
наверное вряд ли целесообразно делать если у вас там внутри блока меньше чем хотя бы два элемента
правда и вот действительно тогда вытекает действительно идея что вот у вас есть какие-то
элементы и тогда давайте вот допустим делить делим их на блоке по два элемента то есть вот
то есть принципе и для каждом блоке храним скажем сумму этих двух элементов но больше
ничего хранить не надо особо вот после этого тогда оказывается что вот то есть эти блоки мы
тоже там делим на блоке то есть тут уже каждый блок отвечает уже за по четыре элемента тут уже
по 8 и 16 то есть в принципе вот и получается классическое дерево отрезков чего работает
да но нет нету непрерывность не сработала потому что как вы все сами хорошо знаем
операции в дереве отрезков работают все-таки не за единицу а за логом да но что приятно да
то есть это алгоритм конечно до бьет все эти степени да то есть нету такого что там существует
какой-то теоретический то есть для любого наш алгоритм который можем написать существует
теоретический алгоритм который работает быстрее но правда на практике он особо
неприменимы за огромные константы но в нашем случае нет у нас есть вот дерево отрезков и
мы радуемся то есть видим до что дерево отрезков это просто такая корневуха на максималках
зачем а зачем нам нужен нулевой элемент как бы дерево отрезков говорит так что оно как бы
что существует что у каждой вершины есть подотрезок за который она отвечает и на котором
она хранит но ей это для пересчета ты не надо потому что ей ну в идеале если мы например если
у нас массив как всегда степень двойки то тогда как мы пересчитываем ответ мы его пересчитываем
за то есть просто за единицу через детей вот нет туда да ну свея да отдельный еще вопрос
сверху или снизу но то да да но тут надо добежать да потому что тут так ну-ка на всякий случай
соцопроса а кто умеет делать операции в дереве отрезков снизу точно а нет ну почти все ладно
но все спасибо не но тот вот грустный момент да потому что тут это пошли тут это модные
тенденции педагогики виды да зачем рассказывать снизу все равно никому не надо на будущее
вообще сверху сразу надо потому что мы отложены операции
что пересчитывать нет но нет в чем проблема вот давайте напишем и снизу для вот такого
дерева нет нет на самом деле нет я утверждаю что нужна только ассоциативность значит
значит требовать будем так во первых давайте поговорим о том как хранить адекватно дерево
отрезка давайте вот на всякий случай да то есть во первых скажем что у нас массив степень
двойки да и боем массив у нас будет с нуля то есть тут n-1 и n равно степень двойки просто
почему нам это удобно но вот на само дерево отрезков мы будем хранить так то есть то есть
ячейки мы здесь будем хранить начиная с единицы зачем но тогда просто действительно оказывается
что вот имеет место та же приятность что и в двоичной куче то есть именно что для каждой
вершины легко найти детей как просто два на нее и два на нее плюс один и родителя как просто
поделить на два вот то есть тут оказывается очень удобно 14 15 и тут вот 16 17 и так далее да то есть
при какой предподсчете вот это вот то есть n у нас это на два степени к вот и соответственно
но мы соответственно вот у нас тут такая каждая ячейка отвечает в каждой ячейке хранится
соответствующих элементов вот ну и тогда оказывается что как найти действительно
скажем как тогда найти значит пишем значит код тогда может прозвучать так так скажем
таки но это не ключ конечно ладно ну ладно давайте t-element хорошо значит t-element
как будет уйти по-английски
нет это уйду не а года а еще идти написать то получится не надо не надо
нет ну ладно быть ну ладно быть так это быть так ладно давайте быть он сегмент
ну уйти что нет у нас операция уйти не операция и все-таки да
так значит как вообще это все будет работать работать это будет примерно так да вот давайте
как как мы тут будем искать сумму сумму будем искать примерно следующим образом вот допустим
нам нужно найти вот такую штук тогда мы замечаем следующее что внутри этого подотрезка все
элементы можно разбить на дваamation на паре причем паре сумма которых уже представлена в
дереве отрезков кроме может быть левого элемента и может быть правой но как определить как как
определить вот у этого левого элемента его напарник внутри отрезка или вне да то есть
едим а прав abrirти 너무 как отличить мой правый сын или левый то есть если мы antibiotics
оказывается правый сын это такой сын который не делится на два а левый сын тот который делится
на два очень удобно мы здесь на вот то есть получается здесь правого сына там то есть правого
сына быстренько обчитываем значит левого сына тут если он есть тоже обчитываем после этого
переходим на следующий уровень где делаем буквально то же самое логично там то есть тоже
право сына общита но тут право сына обчитали левого сына тут нету но поэтому идем сюда так ну
здесь вот этого правого сына обчитываем левого сына обчитываем и выясняется дальше大家 и monk
что пустил поздравляю мы бы поздравляю и доехали вот но как их правильно насчитывать то есть
насчитывать получится так что надо соответственно просто то есть вот это вот этих товарищей значит
то есть на этих товарищей искать какую-то сумму там какой-то и слева и тут искать какой-то буквально
справа значит мы поэтому значит пишем значит значит инициализируем ну начнем
с того что l у нас к l прибавим n и к r прибавим n да и дальше пишем t элемент
значит преф равно вот так скажем empty segment даже знаете вот скорее всего это
будет даже звучать как там t элемент двоеточие двоеточие empty segment
ну смотрите да то есть по-хорошему да я мог бы написать нейтральный элемент но
как мы с вами договорились нейтрального элемента может и не быть вот но мы специально заведемся
что у нас есть такой специальный элемент который сигнализирует о том что мы храним там
идь там пустого префикса то есть какой-то пустого подотреска и тогда когда мы его будем
домножать на что угодно получится это самое что угодно ну то есть условно говоря мы искусств
то есть как бы если у этой операции идти у этого множества нет единицы мы ее искусственно вводим
то есть мы не требуем никакой обратимости но просто мы вот эту единицу искусственно вводим вот
вот но ты элемент сув соответственно тоже пишем равно t элемент двоеточие двоеточие тоже empty
segment вот можно но так все-таки но так все-таки правильнее а то как-то ощущение что суф это
такой но то есть как-то ощущение что преф как-то первичнее суфа хотя на самом деле они одинаковые
поэтому логичнее все-таки так написать вот но в общем на вкус и цвет как говорится фломастеры
вот и так значит пишем while l меньше либо равно r дальше говорим мы начну и дальше
код там работает так значит если оказалось что l не делится на два то тогда что мы делаем
вот тогда но сначала мы говорим что преф равно преф быть значит там три значит от
l и после этого мы говорим плюс плюс и но я мог бы конечно тут l плюс плюс написать но я не буду
делать чтобы понять не было вот независимо пишем что если оказалось что если не r and 1 то тогда
мы пишем суф равно и вот здесь очень важно 3 от r быть суф минус минус r но дальше пишем
l делим на два r делим на два чем ну кого ну он по разному на самом деле на вкус и цвет на вкус
но вот ну и ретурн получается надо все что в конце надо писать это преф быть
то есть вот так на самом деле штуку можно писать если у вас операция абстрактная то есть надо
обратить внимание что важно здесь вот паря если у вас операция некоммутативная то вот порядок
здесь важно не перепутать видно да но вот но в тите в качестве упражнения стоит доказать что да
то есть действительно это то есть вот всякие границы там с граничными случаем каких там проблем
не возникнет то есть остановится этот вайл тогда когда нужен но в принципе да то есть если не
вот это вот полезно знать на самом деле ну как минимум потому что это дается понимание того
как встроено дерево отрезков это раса вторых все-таки при прочих равных не рекурсивный
код будет все-таки работать быстрее чем рекурсивный вот но да и в общем-то пишет да и пишется мне
кажется да и как-то вот этот код по моему как-то пишется даже попроще чем рекурсивного по час
что что вы имеете в виду вот тут л-л плюс плюс написать или шо
не оправдываться хорошо если мы будем писать на полу интервала хочу по моему код будет
буквально такой же только вот тут четкости будут немного другие да и да вот это и вот это
убивается еще да ну хорошо
но я честно скажу по моему по моему это не по моему это не называется проще по моему уже
нету быстрее и проще это разная вещь то есть да потому что да потому что кстати проще бывает
разное можно там можно попытаться загнать этот код сделать так чтобы написать поменьше символов
это да можно загнать действительно что есть идеи на проще как правило скажем можно вообще как
в него уху написать нет нет ну да ну да ну да да да да в том знаете вот там это надо
вы даете контест надо его разобрать вы открываете авторское решение там вот это ну да ну вот ну не
важно нет ну ладно так что тут уже конечно действительно до вкуса цвета там но сейчас не
об этом так то сейчас вот действительно есть вот на самом деле есть разные варианты потому что
сегодня нам еще предстоит еще выяснить что помимо этого можно вообще дерево фенвик написать и это
уже но вот ну почему но смотря что спуск по федрику нет ну как сказать по большому
счет я не знаю первое то есть возможно я не знаю что имеется в виду конкретно сейчас пошел но спуск
но тут дай что да потому что да потому что заметил что встречный федрик это такое дерево
отрезка в котором элементы по-другому записаны по обычному ну как-то ну нету почему нет нету
почему нет нет не общета в принципе да нет а в принципе можно то что выясняется что по тем
элементам которым вы идете там просто они в нужной половине дерево отрезков представлены
ладно да хорошо обсудим этот момент вот так что я надеюсь так сколько сейчас время это так
ладно так ну хорошо так но вот сейчас но есть правда нет при но есть правда еще маленькая
оговорчика хорошо мы написали как искать сумму на отрезке по хорошему чтобы добить дерево
отрезков мы должны конечно еще понять как изменять элемент но здесь понятно тут уже код ищется
достать тут уже пишется достаточно тривиально да как он пишется то есть void вот этот вот ассайн
от int pos int x t элемент точнее x как его написать значит там получается pos
плюс равно n да пишем 3 посовая тупо равно x но дальше так ладно для тех кто не любит
while давайте так и пишем for постом делить равно 2 pos значит pos делить равно 2 пишем тогда значит
3 но вот 3 от pos умножить на 2 3 от pos умножить на 2 плюс 1 ой а я уже все написал
но понятно да тут я думаю нет особых вопросов что я сделал да я просто прошелся снизу просто
то есть когда изменил элемент я пробежался по всем его предкам в каждом предке просто тупо
пересчитал видите да то есть вот пересчитал и то есть вот таким вот например образом то есть
можно вот написать вот такого объема в принципе код вот но оказывается если операция не только
ассоциативно ну и коммутативно и обратимо то можно написать кода оказывается и поменьше и
сделать более того заметим что смотрите сколько памяти требует дерево отрезков да но требует
памяти она требует памяти до двое но на самом деле да да то есть то есть вплоть до четырех да то
есть там на часто на практике да берите ваши 100 тысячи домножайте на четыре ну или там находите
степень двойки там ближайшую и следующую за ней да вот но для но просто но как сказать у нас
пока весь вот этот код работал в предположении что над степенью нет вот это вот вот эти вот
штуки тут просто скажи так операции сверху нет ну как сказать а нет ну как сказать особенно
если операции сверху то им там можно как-то реализовать но правда если операции сверху
можно вообще резать динамическое дерево отрезков снизу ну нет ну сложно сказать нет то в любом
случае на самом деле скажем что можно конечно в этом смысле думать но на самом деле ну в принципе
можно заметить что существует на самом деле дерево федрика который потребует в общем случае
ровно двоян операции ровно двое а в случае коммунативной операции и обратимый на самом
деле потребует просто то есть по памяти потребуется даже не двоян а просто хотя как мы потом выясним
на самом деле идеи в общем-то отсюда недалеко ушли то есть по камере не сильно ближе чем кажется
но и кода получится меньше и памяти получится меньше но как это произойдет мы обсудим после
перерыва таким же образом можно решать но каким же образом можно решать нашу мистическую задачу
какой-нибудь эритку за адекват за чуть более адекватную память чем это умножить в худшем
случае на 4 но как разобрали я лично я не разобрал но да но да
но там-то сложен вот но справляем так охотно верю но с другой стороны кажется как бы феновик
в любом случае надо обсудить потому что крутая это вы же как минимум крутая вещь
а нет как дать знаете есть какое-то видео в котором там рассказывайте мистику потом говорят об том
говорит как это устроено никто не знает а я знаю и конечно с удовольствием расскажу и дальше там
рассказывается каким образом там что-то брожение присутствует какой-то мухой который какой-то
добра но доображение да то есть просто все очень любят устроена это пить пива да никто не но как
она как оно варится никто не знает а я знаю и конечно с удовольствием расскажу там на самом деле
да на хмель там что-то налетают бухи значит они садятся помещают там какие-то свои вещества эти
вещества там реагируют но вот то есть начинается но-то но-то скажи так суть рассказа примерно вот
такая детали могу путать но вот там какой-то градус абсурдизма примерно такой вот да хотя
да вот как устроен феновик действительно нету феновик в общем-то действительно устроен достаточно
мистично потому что действительно потому что если мы хотим потому что допустим что у нас
операция идь допустим ассоциативно коммутативно обратимо ну в общем-то коммутативно даже ставим
скобочках они не ставим не ставим вот и допустим мы хотим действительно делать операцию rsq там
видео значит найти найти идь допустим на отрезке и так сказать add pos x но раз она коммутативно то есть
ну по сути мы хотим чтобы а по самому там скажем было плюс равно то есть идь вот идь
равно x вот так да у нас так оператор идь равно хотя знаете это как-то но вот хотя если честно
действительно как там часто вот не хватает все-таки вот это да когда у нас вот операции мин равно нету
нет мы-то пишем апд это да нет нет ввести новый оператор мы не можем да ну нет ну как
плохо знаешь это надо как бы нет ну как сказать нет ну нет не совсем так на define и могут нам
помочь в принципе но развлечение но развлечение будет нет ну что-то наверное не могут там со
ну хотя ладно ну понятно понятно да да хоть да переда как это как и хватает это да да да
нет обычно да нет обычно приходится писать оп там апд и так далее ладно так вот значит
идея такая вот допустим я опоссовая и допустим массив а у меня тоже идет от нуля до n-1 вот
но на самом деле что нужно чтобы писать дерево фенвика но оказывается да для этого нужно просто
завести массив тф на 1 м и написать буквально следующие заклинания мы изначально мы считаем
что оба массива нули там просто нулевые и дальше как у нас будет как у нас будет
выглядеть функции ну функция это да будет выглядеть примерно так там то есть void допустим это да там
int pos t-element x так ну поехали как это как тогда это будет выглядеть for плюс плюс pos pos меньше
либо равно n pos равно там pos или pos минус 1 плюс 1 может я наврал в моей интерпретации
минус потому что в моей интерпретации vt и tf у меня от 1 до n но там потому что или и потом
еще плюс один ко всему этому надо там это минус 1 вот то есть tf от pos быть равно x вот все так дальше
если я хочу найти какой-то элемент t-element то есть хочу найти и так сказать быть он сегмент
от int l int r то что я говорю но вот то я говорил ретурн быть преф но я так
напишу давайте так l минус 1 в минус первой быть преф от вот так видимо я тут должен
взять какую-то функцию инф конечно но думаю и так понятно о чем речь вот и конечно его величество
быть преф значит быть преф от int r но то мы говорим да там t-element там ans равно как всегда t-element
на mt-сегмент вот ну и тут мы пишем понятно for плюс плюс r r больше нуля r and равно r минус
1 там ans равно соответственно ну давайте чтоб тут было понятнее tf от r быть ans
да в чем заключается магия магия заключается в том что это все буквально
практически буквально вот собственно весь код я написал то есть памяти требуется то есть
помимо самого массива а требуется буквально n на этот раз но остается только действительно
выяснить это но вот а почему это все вообще работает чего нужна ой нужна вот вот вот чтобы
такой вот это наглый делать ой как нужна потому что если вы прибавляете элемент где-то в середине
подотрезочка то нужна поэтому да на этот раз коммутативность это прям святое вот но нам
конечно а при цену остается только выяснить а почему это вообще работает так а кто кстати вообще
но я догадываю что дерево фенвика наверно вы собственно хоть раз в жизни написали наверно
да хотя давайте кто хотя бы раз в жизни писал дерево фенвика ну логично да вот
да ну к ну копипастил переписал дан в случае одно и то же так хорошо а кто понимает почему
это вообще работает да да ладно даже интересная версия но вот
но тем не менее почему-то известно как дерево фенвика все равно до binary индексе 3
называется ну а автор статьи что оказывается можно еще делать вот так да отдельная песня почему
это называется дерево но у него там какие-то картинки есть что действительно что он это как-то как
я так слета не могу сказать почему вот но давайте разбираться почему же собственно это все работает
но идея на самом деле такая вот то есть на самом деле вот эта штука то есть давайте так сейчас
мы введем две функции красную и синю вот вот эта функция будет красная то есть вот на самом деле
вот это вот будет называться у нас f от поз или красную зеленую лучше точно давайте зеленую вот
это вот будет называться нет ой черт это цвета у я молодец я цвета перепутал ну ладно да не будет
не будет мне немножко непривычно но на самом деле не принципиально а это будет f от так вот цель
на самом деле была но вот ну то есть идея такая хочется но то есть на самом деле если бы я сейчас
кода не писал просто идея была бы такая я хочу ввести массив тф и ну вот и сказать что тф что
на самом деле тф и т это уить на полу интервале от f от и до и вот тут я полу интервалы ввиду
неожиданно но обратите внимание что если мы верим что тф и это вот такая вот штука то
тогда отсюда автоматически следует что этот код по крайней мере работает ну я не знаю за
какой симпатику но работает логично да вот вот но соответственно но но единственная только
проблема что как бы полу интервала надо подбирать не просто так каким образом их надо подбирать их
надо подбирать таким образом что если придет время измени вот что нужно если мы там захотели
к постовому элементу прибавить x нужно найти в тф все полу интервалов содержащие пост и ко
всем им прибавить x правда остается только понять как же их найти так вот тут ну видимо методом
там методом каких-то вот проп и ошибок или глядя на дерево отрезков какой-нибудь придумалось
неожиданное определение то есть определение звучит так то есть f от и это число и у которого
обнулен младший единичный бит
вот что это сочетание означает то есть означает что есть у нас было какое-то число и то есть
там был там 00 это 1100 там рандом рандом 1100 там 1100 вот то тогда f от и говорит
такое следующее что оно все абсолютно такое же такое же такое же копипаста копипаста копипаста
только в общем единственное только что вот где вот последний единичка находится у нас находится 0
вот то есть вот такая неожиданная идея ну легко показать что то есть легко показать что на самом
деле то есть дальше уже вытекает такое утверждение да то есть утверждение f от и равно и и минус 1
вот понятно и действительно не сложно будет что потому что и минус один это что такое это вот
этот единичный бит мы обнуляем а вот эти объединичиваем наоборот а когда делаем
энд то получается что и тут 0 и там 0 остается вот то есть можно это вот воспринимать вот таким
вот нехитрым способом но теперь вытекает вопрос а как же найти теперь все полу интервалы в которых
чисто какое-нибудь число поз лежит ну значит тут технология такая то есть на то есть то есть
то есть значит дано число поз надо найти все такие и что f от и меньше либо равно поз строго
меньше и логично да ну поехали как же это сделать тогда вот допустим у меня число поз оно какое а
оно у меня какие-то 0 0 0 1 1 1 1 1 там 0 0 1 0 1 1 1 1 0 0 0 1 1 1 1 0 0 0 так теперь давайте
думать как устроено число и число и это какое-то число которое больше поза это означает что до
какого-то момента они совпадают а то в какой-то момент бабах и неожиданно тут все-таки образовалась
единица и начиная с этого вот тут образовалась единица а дальше идет что угодно понимаем да
но теперь начинаем думать но как устроена f от и так ну f от и очевидно до этого момента
точно ничего не поменяется 0 0 1 1 1 1 0 0 1 0 1 1 1 0 0 так а вот теперь интрига теперь у нас
два случая если после этой единички в и есть еще какие-то единички да то тогда мы вынуждены
заключить что и здесь будет написано единица правда но тогда оказывается что f от и тоже
строго больше поза понимаете да это невозможно следовательно тут написан 0 и отсюда тогда
возникает ощущение что тогда после вот этой единицки железобетонно находится только 0 мы тут
в общем-то тоже ну просто тут как бы ну потому что и f от и отличаются в одном бите можно вот
рассуждать еще по-другому тут единичка и тут стало строго больше но так как здесь f от и меньше
либо равно поза до этого момента было совпадение то тогда и здесь мы вынуждены писать 0 следовательно
вот он этот бит в котором различия но это может быть только в том случае если дальше
идут только 0 это младший день так то есть в переводе говоря мы то есть получается должны
перебрать все такие и которые вот на самом деле которые как бы как поз только какой-то
ноль экзаменен на единичку а дальше все обнулено вот видите да но давайте попробуем взять число
поз и тупо перебрать и просто тупо посмотреть как такие числа выглядят но давайте я поз поменьше
себе возьму на этот раз поз там 0 0 0 там допустим 1 1 1 1 1 0 0 1 1 1 там 0 0 0 0 там 1 1 0 0 0 значит поехали
значит но соответственно где же этот нолик менять на единичку очевидно чем как бы более старше
нолик мы заменим на единичку чем больше получится число правда вот но поехали но самое младше это
конечно когда мы самый первый нолик заменим на единичку то есть это вот мы вот тут возьмем
единичку а тут соответственно 0 0 0 1 1 1 1 0 0 1 1 1 1 0 0 0 1 1 0 дальше если мы возьмете второй
нолик получится тут 0 1 0 ну и дальше тоже копипаста 0 0 0 1 1 1 1 0 0 1 1 1 0 0 0 так потом
берем вот этот то есть следующие значит вот тут единичка 0 0 0 там копипаста бла бла бла вот так
1 1 1 1 так вот дальше интересно давите после этого нолика следующим идет вот этот поэтому
тут получается 1 0 0 ну и дальше тут копипаст опять но потом идет вот тут 1 0 0 0 0 потом тут вот
тут вот так вот один вот так сделаем потом один потом один тогда но заметить можно следующее то
есть первое что тут в этой картинке нужно заметить так это то что каждое следующее число на самом
деле зависит только от предыдущего каким образом да очень просто устроено оно так мы берем последний
блок единичек вот последний единичек последний блок единичек перед ним ставим единицу а сам блок
зонуляем понимаете да вот ну и легко на самом деле вывести то есть получается то есть что на
самом деле здесь получается вот первое число это конечно же пос плюс один а дальше у нас
идут числа же от пос плюс один же от же от пос плюс один там же от же от же от пос плюс один и
тогда ли где функция же вот получается так и определена то есть я так ненот то есть можно
так и прописывать и действительно прямо писать что g и там значит оба нот обнуляет
то есть так на вот так находит скажем так младший блок из единичек из единичек
ставит один перед ним вот а сам блок обнуляет
вот ну и легко коня нот то есть это вот это я говорю определение функции же ну и конечно же
утверждение автоматически возникает что ж ты равно на самом деле и или и минус 1 то есть что
теперь делает или минус один берет последние нолики но перед младшей единичкой и их
объединить вы понимаете да а потом то есть тут получается 1 1 1 а потом чтобы это обнулить и
тут единичку поставить надо просто один прибавить вот поэтому здесь надо и или и минус 1 и все это
вот ну в принципе на самом деле вот мы уже и практически разобрались действительно то есть
почему этот код вообще работает вот вот это ну значит но так а потому что смотрим значит
после меня какое-нибудь число и равно там бла бла бла там 0 0 0 1 1 0 0 0 там 0 1 1 1 1 1 1 и 0 0 0 тогда
замечаем что и минус 1 это что такое это абсолютно то же самое только последний единичка обнулена
а перед ней а после нее все нолики объединить когда я делаю и или и минус 1 то получается
значит вот до этого момента копипаста прям честная 1 1 1 1 да 0 0 0 0 0 1 1 вот а здесь везде
написано единиц но вот но теперь получается если я к этому прибавлю один то получается как раз
вот что как бы весь этот блок получается вот обнуляется тут ставится единичка тут ставится
везде нолики ну и все 1 1 0 0 0 и все вот и все доказательства вот то есть принципе да то
есть на самом деле тут часто бывает идея что такие сами формулы даже на памяти обычно не помню то
есть я помню примерно я помню что они значит а тогда если вы уже помните то обычно вы уже
достаточно быстро там конкретные там md or и вы уже можете вывести вот так что можно но в принципе
вот смотрите так но тем более как бы достаточно очевидно что каждый из этих фориков очевидно
работает за логарифом правда ну точнее даже не за логарифом а вот там преб вот этот будет
работать за количество единичных бит в числе 1 ну вот ну пост конечно тут работает за что-то
менее там за что-то менее тривиальное он будет работать за там за сколько он там будет работать
но так ну так количество нулей да да кроме да если отсечь лидирующие только там теми которые в
которых укладывается да да еще не учитывать вот эти нули в конце но вот но суть одна это как
бы логарифом но при этом логарифом такой с очень быстрой константой по факту чего
но потому что как бы если вы пост там ну скажем так если бы если у вас пост плюс один окажется
в два раза больше то работать оно будет примерно столько потому что нет просто нули в конце никогда
не обрезается то есть у вас все потому что код работает за сколько то есть фактически за то есть
как бы смотрите то есть вы там берем последний блок берем вот этот нолик да вот по сайте вот
начало по сути начинает с этого момента сколько тут ноликов встретится пока он не превосходит
за столько он и будет работать поэтому вот эти нолики не принципиально вот то есть там условно
но так же получается вот такая красота то есть если так вот код фантастически минималистичен
единственное только что тут написано какая-то магия но то магию можно либо выучить либо что
еще лучше запомнить откуда наберется вот но впрочем на самом деле эту магию можно применять и
дальше потому что так мы написали код заявив что значит у нас операция коммутативно и обратимо
вот понятно да вот но на самом деле можно что что
нет коммутативности мы пользовались вот здесь то есть еще раз подчеркиваем здесь это коммутативность
принципиально почему потому что мы пользуемся мы здесь говорим так что допустим у нас там есть
какой-нибудь полу интервал от я знаю там 64 до там до 115 вот в нем по полкам 79 элемент которому
надо прибавить 5 тогда мы пользуемся тем что тогда если мы прибавили к 79 элементу 5 то вот
эта сумма 64 по 115 тоже увеличится на 5 причем абсолютно неважно то есть можно и там в самом
конце это 5 добавить то есть ровно в этом месте мы пользуемся коммутативностью то есть как только
операция перестанет быть коммутативной вот уже эта функция начинает соответственно ее полномочия
ну короче все вот поэтому приходит но поэтому и так то есть если прямо точь хочет то есть поэтому
если мы убираем коммутативности обратимость то по идее вот весь этот код хоть он конечно и
фантастически хорош приходится его убирать
вот да значит тут у нас место тысячи но определение f и g я никуда девать не буду
вот значит тут вот так а ну давайте вот это я все тоже все это доказательство я уберу
и вот вместо этого вот f и g я оставлю f и g я оставлю вот но оказывается что если я очень
хочу чтобы у меня операция была ассоциативно а писать я хочу все равно что-то подобное то
оказывается я неожиданно введу себе просто скажу что мне просто нужно вместо одного массива ввести
два то есть я сохраню себе массив тф от одного до n где у меня нот инвариант у меня будет
абсолютно тот же то есть вот f а еще я введу tg коммутативность и обратимость мы теперь что
говорим что пусть у нас операция только ассоциативно как бы есть подозрение что
если у нас операция не ассоциативно то вообще честно говоря непонятно а что с ней можно делать
ну да да вот да в тупую слева направо а можно ли с ней делать что-то в тупую это надо тоже
еще какие-то свойства знать понимаете какое мо я мо что это что делает мо мо значит говорить
что вот у вас есть подотрезок и вы умеете там допустим сдвинуть указатель туда-сюда и что-то
дополнить да но обычно это уже операция требует от вас ассоциативности это каким образом это
типа предпочитывать прям явно медиатрески что ли а ну откатываем и мой но может быть ну ладно там
можно отдельно покопать вот там всякое такое можно делать но но в нашем случае значит будем
делать так мы введем тф то есть введем тф с тем же определением и введем еще тж тж и т на
этот раз будет равно быть на полу интервале от а до и бум бум же от и вот такую штуку я введу
вот ну там отдельные но вот но то что у нас как всегда в ассистент два момента во-первых
если у нас изменится вот или элемент вот например хотя бы вот таким образом хотя это неважно как то
во-первых как теперь обновлять тф и тж а во-вторых и чем нам это поможет в нашей великой миссии поиска
ну не суммой а ну идти но на самом деле вот как же нам это поможет но на самом деле магия тут
будет очень простая то есть то есть начнем с того как искать сумму там давайте как всегда пишем
быть он сегмент там и ты интер вот значит моя 5 t элемент начит преф равно там ты элемент
пум пум пум пум empty segment
но вот t элемент сув тоже равно t элемент
значит empty segment
значит смотрите и будет у меня работать так for так хотя я так скажу ладно для красоты и
лучшего там может быть адекватного понимания что происходит значит суффикс я буду называть
зелененьким а префикс красненьким ну да начнем да начнем зелененького
я буду писать f от
а по но вот то есть что я делаю то есть когда мне приходит какой-то подотрезок
вот мне вот допустим подотрезок или то я делаю так то есть я тут нахожу какие-то полы там то есть
я нахожу тут условно полу интервалы по f вот некие там полу интервалы и для них беру ответ но
в какой-то момент обнаруживается что мне очередной полу интервал заходит за пределы
видно да то есть мне остался вот этот префикс как я его насчитываю предельно тупо
вот то есть просто идея такая я начинаю с этого или просто беру и беру вот этими
иду полу интервалчиками пока не дойду до вот этого места стыка все то есть получается
на префиксе насчитано и получается мне остается только написать там префикс по идти с суффиксом
вот то есть вот такой не сильно сложный код
но возникает вопрос какой нет почему-то нет почему тф и тж мы в явном виде определили
нет функция ф и ж абсолютно те же что были раньше вот да то есть конечно конечно это
функция работает в одном жестком предположении что когда мы тут пошли отель попа вот же то есть
и же отыжатый то утверждает что мы обязательно в какой-то момент уткнемся именно в то место
где мы остановились в эрке ну точнее так если эрка остановилась в эрке то в общем-то все
очевидно правда вот если она остановилась потом то есть где-то раньше тот утверждает
что когда мы скачем из эльпожи то мы уткнемся ровно в нее чего с ипожи
чего не обратная но вот но вот нам почему-то так захотелось определение такое вот ну как
вы чего с обратной функции сложно потому что по f отывы и однозначно не восстановить нет есть нет
чего если оно сойдется и у вас массивы корректно определены ровно вот так то тогда сумма очевидна
почему потому что как бы нет это очевидно вопрос как бы почему оно схлопнется вот
да может и может и сразу перепрыгнуть пожалуйста но тогда утверждает что если вот мы увеличим
р на 1 ну потому что подотрезок превратили в полу интервал если после этого выяснилось что там f от
r меньше чем a то значит в последовательности lg от lg от g это ли встретится это число и да то есть
вот такое вот такое я утверждаю почему я это утверждаю а потому что я утверждаю что никакие
два из этих отрезков не пересекаются ну полу интервалов а вот этих вот смотрите вот у нас
тут 2 и минус один отрезок какой-то да так вот я утверждаю что любые два из этих отрезков либо
не пересекаются то есть просто вообще нет общих элементов либо один из них вложен в другой
почему я это утверждаю можно рассмотреть это двумя способами но во первых заметим
ночью потому что на самом деле это мягко говоря не совсем произвольного вида отрезки потому что
на самом деле я утверждаю что это отрезки каждый из этих отрезков что зеленый что красный устроен
так вы берете какое-то число битовое точнее берете какой-то префикс битового числа вот и
начиная с какого-то момента говорите что вот вот эти биты можно заполнять как угодно так вот
я утверждаю что все полу интервалы выглядит именно так ну что я имею в виду вот действительно
давайте допустим вот про атеф разберемся да то есть есть у меня и равно допустим там 0 0 0 1 1 1 0 там
0 0 0 там 1 1 1 1 1 0 0 да тогда кто лежит в полу интервале f от и до и кто там лежит там лежат
все числа у которых префикс 0 0 0 1 1 1 0 0 0 1 1 1 1 и тут 0 а вот тут что угодно вот прям в
точности эти числа правда вот а теперь как устроенные а теперь давайте как устроен полу
интервал а ци да же но здесь на самом деле тоже самое только граница вот здесь но то есть я так
вот ну да то есть здесь на самом деле мы видим что здесь числа 1 1 1 0 0 0 0 1 1 1 1 1 только на этот
раз тут один а тут вопросики ну потому что следующие за этим блоком это как раз вот число
один и тут 0 0 0 это есть же правда то есть видите то есть для каждого числа и получается есть вот
полу интервал где то есть как бы допустим есть число и который делится на 8 но не делится на 16
наном случае да то можно заметить что полу интервал то у нее слева полу интервал который
который длины 8 да и справа то есть полу интервал который начинается и который тоже длины 8 то
есть такая симметрия получается да вот понимаете да вот да нет наверное вот кстати отдельная
песня так как делать спуск подъем дерева фенрика если вы не понимаете как дерево фенрика устроен да
придется понимать вот но тогда но думаю достаточно очевидно да что любые два подобного
рода отрезка они либо не пересекаются либо вложены правда то есть чтобы потому что чтобы
отрезки пересекались нужно чтобы там как бы один из префиксов был префиксом другого префикса
правда вот и тогда это вложенность вот в принципе да уже из этого следует что вот это вот штука он
сегмент уже работает но остается только один маленький вопрос а как собственно а если вот
у нас элемент изменился то как tf и tg обновлять но на самом деле да вот эти редкие случаи когда
я тут мог вам показать презентацию но не буду этого делать потому что презентация бы на
самом деле из этого вывела как ну потому что презентация было бы написано так что ну заметим
да что эту задачу что теперь вот там найти пересчитать все эти суммы можно за нет хотя нет
начать нужно с другого надо начать с того что ну во первых надо научиться как-то в tg искать
все или имеют там все полу интервалы которые этот пост задействует как это сделать вот ну
но на самом деле там можно так по секрету скажу да можно показать что для того чтобы вот
понятия вот в tf чтобы найти все полу интервала надо было начиная с пост плюс один скакать
жешками да ну в tg на самом деле тоже надо начинать способ на самом деле просто скакать
то есть можно показать что это работает да но надо и так и там и тут скакать и тут скакать да
вот нету я скажу так тупая то значит опять тупая идея номер раз если вы нашли все
полу интервалы на которые тут надо все менять и мы еще и видим что этих полу интервалов там
от логарифма то тогда эту операцию можно выполнить за лог квадрат но потому что каждый полу интервалы
просто можем в тупую пересчитать то есть если мы там поменяли элементы значит считаем от считаем
то что справа вот с помощью этой функции считаем то что слева с помощью этой функции понимаете
да и получается лог квадрат все уже магия пошла начать и первая идея вот задача найти все полу
интервалы в тф и в теже которые содержат заданное число поз в тф уже научились таки искать да но
вот значит поверим теперь в магию поверим в то что в теже не ищутся как что числа нужны и равный
поз f от поса f от поса так далее ну давайте так в качестве упражнения там просто буквально так
же рассуждать я просто не хочу время на это тратить а так просто вот но вот то есть просто
поверьте что вот так и так получается что мы нашли логарифм отрезков здесь логарифм отрезков
здесь которые нужно поправить да тогда идея такая а давайте каждый из этих отрезков поправим
ну потому что жил был какой-нибудь вот этот вот подотрезок несчастный там допустим и же от
и в котором он случайно выпал поз который поменялся но тогда идея такая давайте вот у него есть в
этом полу интервале есть то что слева от поса есть то что справа так вот давайте в ту пулю вычислим
сумму здесь и здесь она будет вычисляться с помощью полу интервалов который пост не задели поэтому
как бы там все корректно и тогда получается мы научились делать это за лог квадрат но
ты это же поменяли но это вот понятно да нет пост нет туда пост не попадает как раз потому
что мы в явном виде находим все такие и у которых вот в этот отрезок пост попадает
мы это делаем что и равно пост f от пост f от f от пост и так далее да мы пока оставили
без доказательства тот факт что это так но вот просто предлагается в качестве упражнений убедиться
что это так вот вот и тогда предлагается просто то есть все такие подотрезки мы в явном виде
нашли и тогда на каждом подотрезке предлагается за логарифм сумму обновить вот таким образом то
есть вычислить то что слева от поса вычислить то что справа от поса и перемножить но через
вот этот вот новый x вот понятно да ну потому что мы знаем что мы не более чем за логарифм
отн операции вот в этой последствии наткнемся на 0 вот то есть получается в теже мы все поменяли
за логарифм в тф мы делаем тоже самое потому что в тф мы перебираем там и равно там пост плюс
один там же от пост плюс один же от пост плюс один и так далее там их тоже логарифм понятно да так
вот этот момент сейчас понятен да но вот а дальше вы хорошо а можно ли этот лог квадрат заменить
на лог то есть можно не то что у нас чтобы то есть как-то все-таки все эти отрезки все-таки
за суммар на лог пересчитывать и не за каждый залог по отдельности но идея на самом деле предельно
тупая конечно можно потому что дело в том что заметим следующий шут рассмотрим вот эти красные
отрезки которые мы обновляем да тогда дело в том что каждый следующий является над интервалом
предыдущего правда они же нас помните либо не пересекаются либо один вложен в другой правда
они все пересекаются по посту значит вложены но тогда идея такая я утверждаю что если полу один
полу интервал вложен в другой то тогда можно то тогда на самом деле вот от этой границы можно
вот если это граница l то тут можно вот идти то есть последуясь вот это вот f отель f от f отель
и тогда мы рано или поздно обязательно наткнемся на вот эту границу почему потому что если мы ее
проскочим то тогда это будет означать что вот эти полу интервалы пересеклись пересеклись но не
вложились а такого не бывает понимаете да так что-то уже мертвые какие-то после где где я
начал черную магию рассказывать или да или просто это называется да наступил снег приближается
но я бы все мертвые там и так далее я просто если я бы может я может мне надо чуть поподробнее
рассказывать я там это слишком преувеличивает то что вы все знаете там нет смотрите а я пока еще не
договорил я пока только сказал идею что вот у меня есть вот этот отрезок есть следующий да тогда
утверждаю что если я вот из левой границы вот этого отрезка поскочу по f ком то я наткнусь на
вот эту границу почему потому что если я проскочу мимо то будут пересекающиеся отрезок но более
того заметим что я и здесь могу на самом деле вот скакать вот если это у меня то я могу здесь
скакать тоже буду скакать пожежком на самом деле жет там же джетер и так далее и тогда я нот
и тогда и тогда на пусть тоже провода по той же причине наткнуть на эту границу то есть получается
чтобы найти сумму следующего отрезка, я должен взять сумму предыдущего отрезка и тут подомножать
ее слева на какие-то скачки и справа на какие-то скачки. Но у меня суммарно здесь скачков будет
логорифом и здесь суммарно скачков логорифом. Поэтому в сумме поймем, по волочи, что логориф.
Потому что тогда будут, вот допустим, мы вот здесь неожиданно взяли и перепрыгнули,
тогда вот этот полуинтервал и этот полуинтервал пересекаются, но не вложены.
А как мы уже убедились ранее, такого не бывает. Ну, предположили, что мы начали
где-то внутри полуинтервала, скакнули на g, а g оказалась вне полуинтервала.
Но это и есть как раз пересечение, но не вложенность. Ну, по сути, да. То есть
пересчитывать так, что вот таким единым образом. Вот. Можно. Но я так скажу. Ну вот,
на самом деле, нет, я вам так скажу. Нет, я мог бы вам сейчас открыть презентацию,
показать, какой там код получается. Ну, приличный такой. Ну, по объему уж точно не меньше
деревоотреск, а то и больше дальше. Вот. Но на самом деле, но вот, но это надо мне сейчас
экран доставать там и так далее. А во-вторых, на самом деле, если вглядеться в это дерево
более внимательно, то можно писать сильно более простой код. То есть давайте на эти интервалы
вглядимся еще более внимательно. Что такое более внимательно? А давайте их тупо нарисуем. Смотрите.
Потому что на самом деле, да, видите, мы тут не случайно заметили, что видите, и то есть как бы
длинные полуинтервалов от f от i до i и от i до g от i, они почему-то вообще одинаковые, да? И равны
они максимальной степени двойки, на которую делится и правда. А давайте сейчас я вот так вот
сейчас я предположу, что n равно 16 и тупо их нарисую. Да даже не перевернута. Нет, я буду рисовать
так, что даже не перевернута. Смотрите. Вот я тут не случайно ввел зеленые красные цвета. Смотрите.
То есть давайте начнем с полуинтервала в длины... Все полуинтервалы у нас степень двойки, но давайте
начнем с полуинтервала в длины один. Что это за полуинтервалы? Это, конечно, полуинтервалы,
когда берутся из и нечетных, правда. И получается примерно так, смотрите. То есть получается 0,1
значит там, но я потом красненьким нарисую. Значит 2,3, ну, зелененькие интервалы. Это, конечно, те,
которые у меня из ТГ взялись, красеньким я буду рисовать то, что взялось из ТГ.
4, 5, 6, 7, значит 8, 9, 10, 11, 12, 13, 14, 15. Вот, то есть длины 1 из f берутся вот
такие, а кто берется из жешек? Из жешек на самом деле берутся 1, 2, 3, 4, 5, 6, 7, 8, 9,
10, 11, 12, 13, 14, 15, 16. Вот, это были полуинтервалы длины 1. Да, то есть я их просто так
нарисовал, но потому что мне это интересно графически их так нарисовать. Как выглядят
полуинтервалы длины 2? Они берутся из тех и, что которые делятся на 2, но не делятся на 4,
правда? И получается следующее, то есть 0, 2, ой, так тут мимо, 2, 3, 3, 0, 2, 4, 6, 8, 10,
у нас еще 12, 14. Так, ну и красненькие соответственно 2, 4, 6, 8, 10, 12 и вот тут еще 4, 16.
Вот, значит, тут получается 0, 4, дальше для отрезков длины 4 они получаются 0,
4, 8, 12 и получается 4, 8, 12, 16. Вот, ну здесь сверху окажется уже просто 8, 16,
ну вот и зелененький, конечно, 0, 8 и, конечно же, здесь 0, 16. Так, ну оказывается, если n
степень двойки, то оказывается у нас тут в этих двух массивах хранится просто дерево отрезка в
явном виде. Вот видно, да? Ну вот, то есть более того, кстати, есть еще и альтернативное
определение функции f и g, кстати, которые тоже иногда полезно знать, потому что вот я вот написал
такой код, но часто его пишут через какую-то тильду. Да, кто пишет дерево отрезков через тильду? Твой,
дерево Фенрика. Да, ну вот, да, не все. Просто идея такая, просто можно на самом деле ввести такое
определение. Можно ввести функцию h, где сказать, что h от i — это такое максимальное, значит,
2 в степени лен, такое, что i делится на 2 в степени лен. То есть максимальная степень двойки,
на которой i делится. Тогда автоматически возникает утверждение, что на самом деле f от i — это всего
и минус h от i. Вот, а g от i — это равно и плюс h от i. Вот, кстати, да, полуинтервальная логика,
кстати, имеет преимущество именно такое, что в этом случае тогда имеется иду симметрия.
Ну, несложно в этом убедиться, я думаю, по определению, правда? То есть можно про f и g,
ввести те определения, а можно сразу сказать вот эти, просто из деревоотресков. По факту,
на самом деле, да, то есть там дерево Фенрика говорит нам, что если операция коммутативная
ассоциативно, то нам на самом деле от деревоотресков нужны только вот эти зеленые половинки.
Вот, или вот, если у вас там была бы задача, например, вот классическая задача, вот тут
произносится словосочетание «магическая спуск по дереву Фенрика», то давайте вспомним,
да, вот классику деревоотресков, потому что где-то примерно второй или третий
задачей на деревоотресков обычно рассматривается какая задача? Да, каты, да, каты, там, каты нолик,
или лучше, каты единичка нам удобнее будет. То есть представьте себе, то есть у нас есть
массивчик из нулей единиц. Нам нужно уметь, во-первых, там заменять там нолик на единичку,
единичку на нолик, а также дано число k, найдите k-ту единичку. Как мы эту задачу решаем? Ну,
во-первых, мы сначала идем вот в этот элемент и говорим, так, если там меньше, написано «меньше
чем k», значит, говорим ответ там просто –1, там low solution, в общем, ругаемся там так, как нам
описано в условии. Но если тут k хотя бы единиц есть, но мы думаем, а эти k единиц есть в левой
половинке, как мы это выясняем? Мы выясняем просто идем вот сюда. Если у нас k единичек есть,
то есть если тут число больше либо равно k, значит, остаемся в этой половине. Если их меньше k,
то мы это число из k вычитаем и в этой половине ищем вот эту, это вот k минус вот эта вот единичку.
Понятно, да? Так, воспомнили немножко, да? Или не воспомнили? Вот. Ну вот. Но просто тут фишка,
здесь тоже проверяем, как бы укладывается нужная единичка здесь, если да, то идем куда-то сюда,
если нет, то там вычитаем, идем сюда. Но замечаем, что для этого нам оказывается нужны только вот эти
зеленые полуинтервалы. Вот так получается. Потому что, ну скажем, да, то есть утверждение мы будем
попадать только в зеленые полуинтервалы. Доказательства. Вот пусть мы живем в очередном
зеленом полуинтервале. Теперь, чтобы перейти на нижний уровень, мы должны отправиться в
левую половинку и спросить. Ладно, то есть мы знаем, что ответ находится в каком-то
полуинтервале. Ну, что зеленом, что красном. Но даже если красном. Потому что проблема в том,
что мы теперь должны понять, теперь ответ находится в его левой половинке или в его правой половинке.
Значит, мы отправляемся в левую половинку, то есть заведомо в зеленый полуинтервал и выясняем,
туда надо идти или не туда. Но заметим, что вот это число нам знать даже не обязательно. Нам
достаточно знать только зеленые. То есть отсюда следует, что этот спуск можно реально делать,
только чисто в дереве, чисто в дереве фенгера, просто обращаясь к правильным ТФ. Я вам даже,
даже можно сказать каким. У вас в каждый момент времени у вас полуинтервал LR есть, да? То есть там
полуинтервал LR и на самом деле в каждом момент времени вам нужно брать просто L плюс R пополам и
смотреть в ТФ от этого L плюс R пополам. Вот, понятно, да? Вот, единственная только оговорка,
что N у вас должно быть все-таки степенью двойки. Но это не сильно большая проблема, потому что,
очевидно, если там катаэлемент у вас, то есть если вы там, то есть вам заведомо изначально
придется узнать, если у вас там катаэединичка, а если она есть, то в общем-то N вы там забабахиваете
на степень двойки, но вам гарантируется, что там, скорее всего, там может быть, ну либо в какие-то
неправильные, ну неверно, что вы в какие-то там неправильные ТФ не войдете, да? Потому что может
так случиться, что там у вас будет какой-нибудь полуинтервал со степенью двойки из середины,
ну а тебе вам придется все-таки там, серединка тоже уйдет за N. Но вы просто будете говорить,
что если серединка уходит у вас за пределы N, то вы просто заведомо говорите, что там нужная вам
катаэединичка заведомо есть. Вот такая идея. Так же получается, действительно, то есть это имел
в виду под спуском по дереву Фенвика, да? Ну вот. Но правда тут, конечно, просто надо понимать,
что дерево Фенвика это, то есть, то есть на самом деле такое дерево отрезков, которое просто чуть
по-другому написали. То есть может быть его даже, может его придумали так, это глядя на это и
заметив, что вот в половине случаев вам нужны только вот эти подотрески, их можно отдельно
хранить. Потому что заметно, потому что еще можно заметить, что в каждой позиции заканчивается не
более чем один зеленый отрез. Вот. Это была H. Это была FG. Ну вот. Так, это нот. Так что нот. Это
было у нас такое дерево. Вот. Но правда, если у нас операция некоммутативно, то есть некоммутативно
обратимо, то, конечно, вот эти TF, TG-шки надо обменивать. Надо менять. Но как их менять?
Ну, очевидно, на самом деле, что вот просто вот такая структура вам просто очень красиво
показывает, что конкретно надо менять. То есть надо просто поменять конкретный отрезок, а дальше
прогуляться по родителям. Единственное только проблема, что раньше мы эти их хранили там как-то
в явном виде, что мы знали, что у вершины номер В родители-то В пополам. Вот. Ну и здесь, конечно,
у нас все немножко нот. То есть немножко как-то по-другому. Вот. Ну, для нот. Но,
тем не менее, суть, на самом деле, можно написать абсолютно такую же. Каким образом можно это сделать?
Вот. То есть можно это сделать так. Вот. Ну, то есть вот давайте. Вот вы говорили про код. Вот сейчас
мы этот код и напишем. Ну, на самом деле, как можно видеть, код будет практически идентичен дереву отрезков.
Вот.
Вот. Значит, то есть. Значит, итак. Давайте только напишем это не как add, а собственно assign. Значит,
пишем. Значит int, как всегда pos. И это element x. Вот. Значит, ну, можно здесь теперь сделать так.
Введем int l равно pos, а r равно pos plus 1. То есть я буду поддерживать инвариант, что я сейчас
нахожусь в полуинтервале lr, и у меня сейчас уже для него все предпочитано. Вот. Понятно, да? Вот.
Значит, ну, начнем с того, что я, давайте, на самом нижнем уровне попытаюсь пересчитать. Но как мне
пересчитать? Для этого мне нужно понять, вот, под полуинтервал lr, он зеленый или красный? Как меня
отличить, кстати, зеленый полуинтервал от красного? Наоборот, заканчивается на нечетный. Да, ну,
пока, да, пока полуинтервалы, да, заметим так, пока полуинтервалы, полуинтервал у нас длины 1,
то надо просто проверить, кто у него нечетный, начало или конец. Поэтому пишем, поэтому можно,
сейчас я тут напишу экзотическую вещь, то есть, значит, пишем r and 1, вопросик, значит, tf от r,
твое точье tg от l равно x. Да, мало кто знает, но тардарный оператор можно и слева от знака
присваивать. Вот, нет, ну, почему? Нет, ну, а нет, читать так надо куда-то присвоить x, куда? Ну,
если нечетная, то вот сюда, иначе вот сюда, логично. Нет, я понимаю, да, что, скажем так, это как бы кажется
нечитаемым, потому что это как бы не самая привычная вам конструкция. Вот, но так, в общем-то,
ничего супер нечитаемого такого нет. Так, ну, поехали. А дальше, что мы теперь говорим? Ну,
дальше мы говорим while, там, видимо, r-l меньше n. Так, ну, во-первых, теперь мы говорим так,
надо теперь l-r сдвинуть, правда? Вот, ну, как сдвинуть? Ну, как теперь? Вот нам дан рандомный
подотрезок l-r, как понять, как быть это l-r он зеленый или красный? Ох, поделить, то есть на
времени тратить, да? Ну, что, оба, оба делятся. Ну, на самом деле, да, заметим, теперь вспомним,
что зеленый полуинтервал это всегда полуинтервал вида там f от r, правда? А красный полуинтервал
это полуинтервал вида l g от l. Но мы же легко можем проверить для полуинтервала l-r, если мы
точно знаем, что он хороший, какому из этих видов он принадлежит, правда? Поэтому можно так
сказать, начнем с зелененького случая. Если оказалось, что l равно f от r, то в этом зелененьком
случае что мы тогда делаем? Ну вот, но тогда оказывается, что надо r сдвинуть на g, правда?
Ну, соответственно сдвигаем. Ну, можно написать так, int значит nr, новый r равно g от r, да? Вот,
ну и теперь надо, ну вот, ну теперь мы знаем, как вычислить сумму. Значит, сумму вычислить
можно, как теперь получается tf от r и tg от r, правда? Но записывать теперь надо в полуинтервал вот
этот вот l nr. Как его записать? Ну, я сейчас напишу не самый оптимальный там, конечно, код, но написать
его можно так. То есть можно его написать l равно равно f от nr, если да, то tf от nr, если нет, то tg от l.
Ну мы и про... Где писать? Вот здесь? Вот это? Так мы так и делали. А, ну да, в принципе, да. Ну,
просто в данном случае мы еще и точно знаем. Вот, значит, тут получается вот так, ну а в противном
случае получается какой-то симметричный код. Сразу пишем тут int. Там nl равно f от l, естественно.
Вот, и там получается pum pum. Ну да, допустим, nl равно равно f от r, тогда tf от r до точки tg от nl.
Равно tf от l и tg от l. Вот. Вот. Ну и, конечно, не забыть l равно nl.
Чего? Ну tf слева, tg слева. Нет, тут как раз все нормально. У нас tf зеленое, tg красное.
Так что вот такой, в общем-то, код получается. Ну ладно, вот такой. А, еще вот такой. Ну, на самом деле,
да, деревоотреска, в общем-то, не сильно ушли. То есть по коду, в общем-то, получилось примерно
то же самое. Только код получился даже чуть более магически. Нет, ну в принципе, да, то есть,
ну вот. Нет, то единственное только что, как бы, тут надо внимательно посмотреть, как бы,
насколько код, насколько такой код работает. Нет, кстати, нет, давайте внимательно. Сейчас,
давайте, подождите, давайте подумаем. Нет, как бы, этот код гарантированно работает если
n степень двойки. А теперь давайте подумаем, а насколько он адекватно работает, если n это не
степень двойки. Но не совсем так работает. Потому что давайте, давайте предположим сейчас,
давайте предположим, что n равно 11. И там полуинтервал у вас какой-нибудь там, вы меняете
какой-нибудь там восьмой или восьмой элемент. Тогда вы поменяете 8,9, вы поменяете 8,10,
потом попытаетесь поменять 8,12, но у вас этого полуинтервала нет. Ну вот такой вайл у нас не
брейкается. Вот. Но на самом деле, да, можно тут, то есть допилить его можно так. То есть,
ну на самом деле, да, как только у вас r вот в этом месте выйдет за пределы n, на самом деле вы можете
сказать, что значит остальные полуинтервалы вас не интересуют, мы их не храним. Поэтому в принципе
можно обнаглеть и сказать так, смотрите. Вайл труп. Нет. И тут обнаглеть заявить, что если оказалось,
что n больше n, то вот тут бряк. Вот. Вот. Ну как бы знаете, да, любимый оператор этого, одного
долговязого мышонка, да, знаете. Нет. Ну у него был такой мелкий такой друг,
который пытался захватить мир. Да. Ну вот. Извали их Pinky Brain, если что. Вот. Так вот он, да. Так вот
это долговязый там, толковязый видимо постоянно, когда ему там говорили что-то умное, он еще любил
использовать этот оператор. Соответственно. Ну не важно. Ладно. Ладно, если вы не знаете,
не заморачивайтесь. Не важно. Вот. Так что вот. Так что вот в принципе можно так написать и в
принципе вот у вас и получается примерно дерево, на самом деле такое дерево отрезков, в котором вы
храните 2n-1 элемент, а не, а не. Нет. А FL у вас как бы, а потому что при FL вот этот полуинтервал,
скажем так, по большому счету, что такое дерево отрезок, то есть мы тут пытаемся хранить на n. То
есть это когда мы n как бы мысленно дополнили до степени двойки, но полуинтервалы, которые требуют
хранить не чего-то там n или больших элементов, мы просто не храним. Потому что они нам типа не
нужны. Вот. Но очевидно, что вот. То есть здесь мы исследуем ровно те полуинтервалы, которые как бы
нам нужны, и поэтому если у них там все индексы не больше n, значит они существуют. Поэтому здесь как
бы FL никуда не выходит, FL не выходит за пределы нуля.
Почему как бы, как бы сформулируем так. Это может быть написано не самым оптимальным образом,
хотя нет. Но с другой стороны, как бы, смотрите, рекалки абсолютно такие же. Вот. С двиги, но на
самом деле, ну почти такие же. То есть там как бы было, ну там было немножко так, то есть там
был, правда был, нет, ну да. Но там было, да, там было, конечно, там, конечно, сильно проще находили
родители, там одно деление на два, а тут как бы какие-то вот такие битвы, операции. Ну да. Так
что да, пожалуй, тут может работать, конечно, чуть дольше. Вот. Ну и за эту память чуть-чуть
экономии. Почему? Почти в два раза, между прочим. Если у вас реально n равно 2 в степени
плюс 57, то вы сэкономили почти в два раза. Ну да, но это, видимо, придется по-другому писать,
возможно. Чтобы не менять то же самое, у вас так не получится, потому что, как бы, допустим,
у вас n это 2 в степени плюс 57. Тогда если вы напишете так же, но обрежете до n, то, извиняюсь,
у вас там все верхние уровни будут как будто под большую степень двойки писали, а на нижнем
уровне останется всего 57. А листья на разных уровнях. Ну это, в принципе, ладно. Ну хорошо,
да, это еще можно. Допустим, да. Нет, листья надо, да. Листья, листья надо.
Нет, ну как нет, просто в дереве отрезка говорится так, что, допустим, у нас n не 16,
а там, допустим, 17. Нет, 17 как-то нет, не вместится. Нет, ну я не знаю, я бы сказал,
что давайте 11. Так, ну давайте смотреть. Значит, как предлагается хранить тогда на 11?
Ну да, нет, да, ну просто, видимо, на 11 просто, ну то есть, видимо, как-то на 11 предлагается
идея такая. То есть, давайте выкинем все вот эти элементы, да, да. Понятно, ну вот. То есть,
выкинем вот эти элементы и вот эти элементы. А так будем хранить вот нот. А вот эти 11
элементов будем хранить вот примерно вот в таком массивчике. Так, так я вас понял примерно.
А, ну нет, ну может это, а ну что прям в явном виде так хранить? Там же решила простой реализация
неко. Нет, ну правда, нет, там просто имейте в виду, что вместо вот этого элемента на 10-12,
то есть как бы они просто будут отвечать не за элемент 8-10, а они будут отличать за как бы
полуинтервал 8-9, 9-10 и 10-11. Вот, а дальше тут вот объединение нот, а вот эти вот верхние
там все объединения, да, вот этот элемент мы тоже не храним в итоге, да. Ну хотя...
Так, сейчас подряд запишем, что? То есть, да, но тогда, видимо, придется записать,
что запишем? Сначала вот эти элементы, потом эти или что? Ну да.
Нет, просто тогда у нас под отрезок будет не очень удобно его распиливать, придется.
Нет, ну то есть придется учитывать, где суффикс и где префикс.
Ну это да, ну не знаю. Нет, вот это и магия, что получение, что там какие-то ИФы надо вставлять.
Нет, ну хотя нет, тут вопрос, какие операции? Если операции сверху снизу, то как бы еще одно дело.
Нет, ну там не совсем так, там, ну вопе, нет, там, во-первых, как бы ПЛР еще МИДы надо искать.
Нет, абсолютно так же нет, тогда тут будет 0.1, там какой-нибудь отрезок будет 0.10, у него МИД
будет там что-то делить напополам и непонятно. Так что, видимо, у нас с вами разные делаются так же.
Так что я не знаю, что такое такое. Похоже, код видимо у меня какой-то другой, что снизу, что сверху.
Ладно, неважно. Так, сколько сейчас времени?
Ну понятно, понятно, так сколько времени?
Ну понятно, окей, хорошо. Ну ладно, значит тогда, понятно, что там МИДы.
Ну снизу, нет, ну как сказать, прикольно, скажешь так, прикольно, что так тоже можно, да.
Не, ну почему? Ну знаете, фенвик тоже будет выглядеть как отхог какой-то, знаете.
Не, ну как сказать, ну я не знаю, что тут придумалось раньше, но...
Ну, типа оно возникает вследствие логичных каких-то вещей, здесь мы немножечко, вот функции будут такие, и типа...
Нет, дерево-тешка снизу, как бы стандартная реализация, тоже понятно.
Не, ну я боюсь, там просто, боюсь это реально работает по принципу, да, там, то есть давайте дерево-отресков храним не два в степени там элементов минус один, а только вот там...
Ну, не обязательно даже, ну не обязательно даже китаец, но просто кто-то случайно заметил, что так работает, да.
Да, нет, у Спарсты, конечно, более логично в том плане, что если мы хотим быстрее искать какой-нибудь минимум на отрезке, то понятно, что нам на каких-то отрезках минимум придется предподсчитать.
Да, ну вот, поэтому там скорее всего до степени двойки видео в какой-то момент додумаетесь, потому что там получается асимптотика НЛОГН, как бы получается единица, все нормально, да, тут, ну дизджойнт из этого там допиливается, ну допиливается, короче.
Дизджойнт это хорошее, как выглядит ЭЛБИТ, мы разделяем власту, мы типа накажем.
Да, да, да, да, да.
Ну да.
Просто ее запихали всю груда.
Ну да, нет, ну да, одна и та же, да, совершенно верно, да.
Массив, там можно все время массив.
Нет, ну везде тут можно заметить, что, ну ладно, ладно, давайте так, совсем прокапывать не будем, потому что на самом деле про Фенвика есть еще что рассказать, как-то не странно.
Да, это еще, это еще.
А, прибавление на отрезки типа?
Ну, ну как сказать, у меня классика такая, Фенвик с прибавлением на отрезки, значит это, конечно, Фенвик Фенвиков, да, будет еще свинод, может быть даже КД-деревом у нас сейчас возникнет даже.
Ну и конечно его величество казарский, Фенвик.
А в том прикол, что задача, которая, ну, значит легенда, значит легенда такая, давным-давно в 2012 году, по-моему, плюс-минус, плюс-минус один, мы давали контест Петрозаводск.
Значит, контест оказался неожиданно гробовой.
Ну, чтобы вы понимали, в контесте было 9 задач, чемпион решил 4.
Ну как чемпион, там две команды решили 4 задачи, а остальные 3 и менее.
Более того, одна команда стала из двух действующих чемпионов мира, другая команда там через два года стала чемпионом мира.
Ну, мы сильно удивились, на самом деле, потому что мы еще объясняем, что это был контест в первый день, то есть, знаете, когда с утра, в 8 утра вы вышли из поезда, в 2 часа вы уже контест пишете.
Ну вот, потому что сейчас там современные команды, там более современные, вроде там и по 6 закрывали, и по 8 там уже нормально.
Может, конечно, задачи уже бояными стали, но тем не менее.
Ну вот, и там была одна веселая задача, там структура данных.
Мы призывали, что это такая относительно сложная структура, что-то там на дикартовые деревья.
Ну, по камере в авторском, что-то там дикартовые деревья писались.
Но решила ее только одна команда, Казахстанско-Британского технического университета.
Нет, университета в Алмате такой реально существует.
И более того, мы открыли решение, ничего, кроме мапчиков и фенвичков, там не было.
Вот, вот что с задачей.
Ну, я могу сразу условия рассказать, и вы можете пока подумать.
Но более того, пока скажу просто на уровне легенды.
Потом прошло несколько лет, где-то в 2015 году я, собственно, съездил в этот вуз, провел там сборы.
Казахстанско-Британский?
Да. Нет, ну, в смысле, нормально там эти команды.
Кстати, более того, я там уже в 2019 году, в принципе, то есть потом ездил на финал и встретил там, собственно, знакомые лица.
Вот.
Так что, ну вот, встретил, и там одной из занятий у меня было по дикартовому дереву.
Но я там дал 9 задач на дикартовые деревья, на разборе они мне подробно объяснили,
что мне реально нужны дикартовые деревья.
А все остальные прекрасно решаются там, ну, не сложнее, чем деревьями отрезков.
Там у них лог квадратный, да, симпатикой?
Нет, причем с нормальными асимптотиками, да.
Не, просто у дикартовых деревьев, нет, у дикартовых деревьев есть недостаток.
В терминах дикартовых деревьев очень удобно мыслить.
Потому что, да, то есть можно забить на дерево отрезков,
что дикартовое дерево как бы, оно умеет делать то же самое, что дерево отрезков.
За тот же логарифм. Правда, более жирный.
Но тут выясняется, что конкретно нет.
Ну, вот, что там есть конкретика,
что можно чаще всего дикарточку не писать.
Вот. А в данном случае, ну, вот.
В данном случае пришлось.
А задача такая, значит, смотрите, вот, видимо мы ее,
значит, видимо после перерыва разберем,
пока можете подумать. Задача такая.
Значит, там Саша,
да, на этот раз Саша, да, редкий случай,
вот, но на этот раз Саша,
вот, соответственно, собирает вещи.
Вещи у него лежат,
ну, вещи он собирает в энчима,
ну, вещи он собирает в энчимаданов,
ну, эн до 100 тысяч, естественно,
как всегда.
Значит, есть 100 тысяч чемоданов.
Каждый чемодан, ну, такой,
в каждом чемодане лежат такой
столбик вещей.
Так вот, запросы у него такие, ну, вот,
причем более того, вещи тоже бывают
одного из двухсот тысяч типов.
Ну, там красные, зеленые, там, короче,
200 тысяч цветов.
Так вот.
Значит, запросы там такие.
Ну, да, сейчас какие там
запросы сделать?
Ну, по-моему, там запросы были примерно такие.
Во-первых, первый запрос. Скажите, пожалуйста,
сколько запросов, сколько вещей
такого-то типа лежит сейчас в чемодане
таком-то?
Это первое.
И второе.
А, ну, вот.
Нет.
Нет, второй тип запроса,
перекладывание. Ну, вам изначально сказано,
какие вещи в каких чемоданах лежат, естественно,
да? Так вот. А потом второй
запрос. Значит,
возьмите чемодан номер
X,
возьмите в нем
там верхний игрок
вещей,
возьмите среди них все вещи
типа С,
и переложите их в чемодан
типа номер X3
наверх. Положите наверх, да.
Да, вот такая вот вещь.
Да, вот такая веселая.
Да, там ограничение типа все по 100 тысяч.
Ну, адекватный какой-то, две секунды, по-моему.
Ну, насколько я помню, там, по-моему,
вроде ни у кого проблем, кто
сдавал, вы там, проблемы были не с ТЛ.
То есть у этой команды никаких
проблем с ТЛ не было. Но правда,
там и все сдавалось, как выяснилось.
А почему
из этого ВУЗа придумал такие решения?
Не знаю, вот я не знаю,
поэтому вот у меня ощущение, что
в Казахстане есть суровые казахские
технологии, как избегать декартячих.
Нет, нет, как сказать,
придумали. Это какая-то сложная структура,
которую надо, то есть она сложно,
ее как-то надо писать и так далее, а на самом
деле ее писать не надо.
То есть да, как бы напрашиваюсь,
ну да, в принципе, тут отдельная песня,
как тут декартячих вообще придумать
то есть какой конкретный декартяч писать
и шоу от него надо.
Но окажется, вот утверждается,
что вот казахи умеют это делать то же самое
в терминах Мапов и Федвиков.
Вот, но как они это делают,
мы узнаем после перерыва.
Так, но давайте разбираться,
как это называется, да, кто-то, возможно, даже успел
подумать над задачей,
но поэтому, как говорят в одном блоге, да,
ну а теперь, когда каждый из вас составил
свое мнение об этой задаче, мы разберем
авторское решение.
Вот.
Ну ладно, не то чтобы авторское,
не знаю, может быть авторское было не совсем
такое, но с другой стороны, какие тут идеи вообще
возникают?
Можешь хранить какую-то пару, типа значение, количество.
Ну вот, так, но да,
но первая идея, конечно, заключается в том,
что вещи одинакового
типа имеет смысл хранить
в блоках.
Да, то есть на самом деле,
то есть первая идея, давайте в каждой
ящик храним в виде, ну я не знаю,
дикартового дерева, какого-нибудь,
то есть какого-нибудь вот
там,
дикартового дерева,
в котором храним последовательность блоков.
В каждом блоке пишем, там, какой
тип, и там, какой тип вещей,
и сколько этих вещей.
Вот.
Ну вот.
Это во-первых.
С начала в начало, ну из начала в конец.
Ну я бы сказал, что,
ну да, я бы сказал, что ящик
будет скорее вот такой какой-то, да,
но это не так принципиально.
Ну что нам бы еще было
было бы желательно? Ну как минимум было бы желательно
ну, во-первых,
как бы уметь пробегаться по вещам
одного типа.
Как это можно сделать?
Ну, например, то есть там для
каждой вершины хранить ссылку на
предыдущую вершину такого же
типа.
Вот.
Мы же блоки уже храним.
Да, ну на предыдущий блок
такого же типа. То есть на предыдущий.
Ну, в смысле, да, но просто мы же
блоки храним из подряд идущих вещей одного
типа. Ну вот.
Поэтому вот. Но теперь вот идея, что
и... То есть при этом показать, на самом деле,
ну, типа, просто на два назад. Почему на два?
Потому что предыдущий блок ну кого типа?
Нет. А у предыдущих много типов.
Да, типа типов у нас 100 000,
к сожалению. А то и 200 000, так что увы.
Вот. То есть тут храним, как бы тут
все адекватненько в этом плане. Ну вот.
Ну а указатель... Ну вот. Ну единственное только,
что для каждого ящика придется хранить указатель
на, видимо, последний
блок такого типа.
Но это... Чего?
Так.
Ну давайте подумаем. Может показаться, что много.
Но на самом деле суммарно это не много.
Потому что на самом деле
заметим, что вещей-то у нас всего тоже там,
сколько там? 100-200 000, да?
Ну вот. Поэтому суммарный размер
всех мапов там будет на самом деле тоже
не более чем 200 000.
Да, то есть анод.
То есть в каком-нибудь мапе,
то есть в каком-нибудь вот действительно мапе храним
указатель, что где у нас вот такая вещь,
где у нас там вот такая вещь, может быть там,
ну и так далее.
Вот.
Ну вот.
Ну вот. И какие тут идеи
возникают. Ну вот.
То есть идея... Ну вот.
Ну вот. Ну а также с помощью
этого же мапчика на самом деле еще мы поддерживаем
информацию о том, сколько вещей такого типа
у нас в этом ящике хранится.
Вот.
Ну потому что давайте вот предположим,
что нам, ну то есть предположим,
что нам сделали запрос
перетащить там какие-то вещи.
Ну во-первых, когда вы кладете эти вещи,
вы их кладете как новый единый блок, правда?
Ну вы за логарифом значит просто
пушбекаете, значит, эту вещь.
То есть эти вещи находите там предыдущий
указатель, собственно, в мапчик
перевешиваете.
Да, то есть там...
Да, то есть наоборот, значит, мапчик вот
теперь там перевешиваете и заодно там
к соответствующему количеству вещей
прибавляете вот это, да?
Вот. Ну что вы еще молили? Ну вот.
Но теперь остается только самое интересное. Это вы как
положить вы поняли, а как достать?
Ну достать предельно тупо.
То есть на самом деле там взять
соответствующий ящик, там
допустим, ну вот
посплитить, ну
отсплитить, собственно, там нужное
последнее количество вещей.
Причем заметим, что при этом вот эти вот ссылочки
на предыдущий блок вообще трогать не надо,
потому что при сплетах и мержах относительный
порядок не меняется.
Ну вот. Ну и все,
что вам тогда остается, это только
пробежаться по вот этому односвязанному
списку нужных вам блоков
и соответственно их всех просто повыдирать.
Остановиться надо только на
как бы том блоке, которое
уже в отсплитченной части не лежит.
То есть вот в принципе, ну вот, то есть
за сколько это будет работать? То есть это будет конечно работать
за логарифом на сколько блоков
вы достанете. Да,
но суммарно это кулоген, почему?
Потому что амортизировано, потому что
вы достали там допустим к блоков,
но при этом схлопнули их
в один. Да, ну
и ладно, есть еще одна мелкая оговорка,
может быть еще так, что вам какой-то блок
придется распилить на два, кстати.
Да, то есть это тоже такая техническая
гадость, которую придется учесть.
Вот, но тем не менее,
вот амортизировано, получился решение за кулоген
с дикартячкой, вот примерно такую гадость
вот. Ну вот, но как-то почему-то
да, в Петрозаводске такую гадость что-то никто
не написал.
А вместо этого выяснилось, что оказывается
в этой гадости дикартового дерева писать
вообще не надо.
В смысле не надо, в смысле можно написать.
Чего?
В смысле не надо, в смысле можно не писать.
Ну вот,
потому что оказывается,
что вместо
этого идея оказывается такая,
а давайте-ка вот эти вот блоки
вместо дикартового дерева будем хранить
фенвички.
То есть заведем просто честный вектор,
будем в нем хранить сколько там, то есть
будем хранить тип вещей, сколько их,
а на вот там сколько их заведем
фенвичка.
Ну начнем с того, кстати, что фенвичек
обладает,
то есть обладает
поддерживать такую мистическую
технологию как pushback
за логарифом.
Ну то есть понятно, что если вы тут
впрекете один элемент, он конечно повлияет на несколько сумм,
но он повлияет только на логарифом сумму,
вы собственно стандартным образом высчитываете.
А можно в принципе заранее, там запросы
никто не анализировал, слава богу, поэтому
в принципе вы можете заранее подсчитать
сколько теоретических блоков у вас там
в этом ящике потребуется.
Ну понятно,
суммарных будет там, понятно,
сколько было изначально,
сколько было изначально, плюс
ку еще.
И тогда идея такая,
то есть давайте делаем абсолютно
то же самое, но только храним
вот это все в фенвичке.
И дальше тогда идея вот такая,
что мы конечно
в фенвичке еще проще можем
пробежаться по вот этому списку.
Да, один на чемодан.
Но теперь идея такая, то есть когда вы прогуливаетесь
вот только по списку, да, ну вы сначала
вы находите, до как, там
где вот эти вот первые там самые верхние
ка элементов лежат. Как вы делаете?
Можно даже, ну можно сделать тупо бинпоиском
на самом деле.
Я думаю залог квадрат там зайдет.
Но как мы уже сегодня убедились, можно аккуратненьким
спуском тоже делать в принципе.
Вот.
Но так или иначе вы нашли, где эти вот
верхние ка значит
заканчиваются, да?
Вот. И тогда идея такая, значит
тогда все, что вам нужно, эти вот эти блоки выпилить.
Как эти блоки выпилить?
Да очень просто, написать, что там
ноль.
Вот.
Ну написать, во-первых, что там ноль, и во-вторых
конечно записать, что там
в этот вот исходный мапчик, что
последний блок такого типа теперь вон там.
Но если какой-то блок надо распилить
на два, то понимаете, да, по факту это произойдет
только если у нас тут там
179 вещей, а из них надо забрать
всего лишь 57, да?
Поэтому в этом смысле вы просто в этом блоке
пишете 122 и не паритесь.
Вот.
Ну вот собственно и все. То есть получается,
то есть идея оказалась в том, что просто храним все
в фенвирчике, просто идея в том, что мы разрешаем
в себе какие-то дыры.
И с этого сильно не
страдаем.
А мы для каждого цвета храним
фенвир? Нет.
Нет, почему? Для каждого чемодана храним фенвир.
В шагах мы удаляем блоки нужного цвета.
Ну а дальше
все так же. То есть для каждого блока
соответствующего цвета мы храним
предыдущий. Вот.
Предыдущий заодно еще храним там сколько таких
вещей, чтоб на запрос потом второй отвечать.
Ну вот и так далее.
Так что мы уже делаем общий спуск.
Мы можем также просто двигаться, пока
не найдем. И это будет опять
примортизированное, чтобы... Ааа.
Здесь крас не будет, потому что у тебя 0 возможно.
А я буду двигаться такой по 0.
Да. То есть заметьте, вот этот
досвязный список мы поддерживаем так, что 0 мы там
не храним. Да.
А тогда, в принципе, да, заметим,
что действительно амортизация тут гарантирует
так, что когда вы пришли в блок, вы можете
просто выяснить, сколько перед ним элементов за
один фенвир.
Потому что все равно, что вы будете его там либо обнулять,
либо в этом месте остановитесь.
А когда раз обнуляете за логарифом, почему
вам не потратить логарифом на то, чтобы
тут еще и сумму найти?
Да. Так что вот
оказывается, да, тут оказывается, еще никаких
спусков по дереву нет.
Вот. То есть вот получается,
что никаких декартовых деревьев здесь
не надо.
Ну вот. Ну вот, чаще всего
да. Не, ну чаще всего на самом деле да.
То есть обычно оно не нужно,
но тут вот выясняем. Но тут это просто вот потрясающий
пример, действительно, технологии, как без декартики
можно прекрасно обойтись.
Ну вот. Ну вот просто там.
Ну как бы напоминаю, да, что как бы...
Идея может выглядеть простенько, но
в тот момент там только одна команда
решила задачу, напоминаю.
Вот.
Ну и там в авторском решении тоже были декартики.
То есть мы так
были так сильно удивлены.
Ну вот.
Ну вот, оказывается, так можно.
Ну, собственно, это нормально, да.
Да, ведь контест в Петразаводске
будет только к тому, что вам на разборе расскажут, как
на самом деле задача решалась.
Или, корректно говоря,
была бы решаться.
Вот.
Ну, вот бывает.
Вот.
То есть ну вот. Ну такое бывает, собственно, за этим
в общем-то сборе в Петразаводске и делается.
Вот.
Значит, это был казахский Федор.
Чего?
Что его придумали казахи.
Чего?
Ну да, ну скажем так,
я, то есть, ну, не, ну, то есть подобная технология,
что вот можно оказывается там какие-то вот
какие-то, то есть какие-то вещи
без декартики реально вот иногда хранить
фенвиками и удалять вот методом
записи нуля, и этого хватает.
Вот.
Ну, то есть я не знаю, просто меня это надо. То есть меня эта идея настолько
впечатлила, что я ее с тех пор всем рассказываю.
Вот. Но идея действительно
крутая. Вот. Я ее
называю казахский фенвик. То есть нельзя сказать,
что она там супер, там официально, конечно,
название, но тем не менее.
Так, ну, что у нас еще есть?
Вот.
Нет, у меня нету.
Нет, нет.
Да, да, там
суммарно, да, по памяти там
Н.
Ну, да.
Но более жирная, да.
Так, что да.
Так, ну, что, идем дальше тогда.
Так, ладно, сейчас нас
неожиданно поприветствует фенвик фенвиков.
Сейчас у нас будет задача, которую
за всю нашу сознательную жизнь мы
так или иначе решим двумя способами,
возможно, даже сегодня.
Нет.
Двумерное немножко другое.
Нет, как бы не путать двумерный фенвик и фенвик
фенвиков. Это разные вещи.
Не надо падать со стула.
Это не самое страшное, да, не волнуйтесь.
Значит, идея у нас будет такая.
Значит, идея такая.
Хотя как бы идея будет похожа на
двумерную риску, но немного другая.
Значит, дано N.
Ну, там N, как всегда, там приблизительно 10 в 5.
Вот.
Нет, какие звезды?
Звезды – это трехмерный фенвик, просто
напишите и не парьтесь. А тут задача такая.
Даны какие-то N. Множество точек
не меняется.
Смотрите, ребята, множество точек не меняется.
На каждой
точке написаны какие-то числа.
И вот они, кстати, вполне себе меняются.
Ну, по большому счету, запросы такие.
То есть у вас бывают запросы
added.
Значит, там posX, там posD.
То есть это означает, возьми точку
номер pos и прибавь
к ее числу D.
И второй тип запроса
сумма.
То есть просто дан какой-то вот
под прямоугольник, в сторону которого
параллельно осям координат, и нам говорят,
пожалуйста, найдите сумму
чисел на всех точках,
которые в этот прямоугольник попали.
Ну да.
Практически жирно.
Самое тупое, что можно делать,
особенно если выяснить, что координаты
от 0 до 10 в 9.
Да.
Ну да, самое тупое, что можно делать.
Давайте там xy до
хотя бы от 0 до 10 в 9.
Ну действительно, давайте заведем
неявного фенлика на 10 в 9.
Да.
Ну сейчас погодите.
Самое тупое, что можно сделать. Давайте заведем неявного фенлика
на 10 в 9.
Ну хранить там ячейки будем в анортерет
мапе и там лишнее не создавать.
Тогда все запросы
у нас будут за лог 10 в 9,
на лог 10 в 9 кайф.
Казалось бы.
Да.
Но
скажем так, да, оказывается,
да, то есть как
часто бывает, в том числе и в корнячках,
как говорится, да, то есть асимпатически
формально вроде нормально, но реально не заходит.
Ну извините, у авторов решение в три раза быстрее работает.
Мы ничего не можем сделать.
Всякое бывает.
В контесте на физтехе
в другом контесте вообще была задача,
в которой у нас
было два решения за асимпатическую
логен, но одно работало в 10 раз дольше
другого.
Нет, там запросов не было.
А вот это
ну
ну вообще оффлайн.
Да, ну вот
действительно, да, потому что как можно сделать
побыстрее? Да, во-первых, начнем с того, что можно
пожать координаты. Действительно.
Да.
Так, правда, отдельное,
кстати, отдельный вопрос.
Кстати, как пожать координаты?
Рисайз юник.
Так, надеюсь, все пишут рисайз юник?
А то там кто-то мапы какие-то
там пишет или там что?
Давайте я на всякий случай
напишу, потому что это чтобы
чтобы было, потому что я понимаю,
что многие, скорее всего, правильный код знают.
Допустим, у нас ситуация такая,
допустим, у меня есть
там вектор point
там PS какой-нибудь от n, в который
записали точки, я хочу сжать
иксы. Так вот.
Значит, как сжимать иксы?
Что значит сжать координаты?
Я хочу, по идее, взять
все эти иксы и заменить каждый
икс на его порядковый номер с сортированным
R7 иксов, правда?
Поэтому делаю я это
так.
Смотрите, вектор
там int, ну допустим int
x
да, значит пишем
point
там point PS
значит
xs.pushback
от p.x, да, но если хочется
сразу пооптимизировать, тут еще можно
амперсентик написать.
Ну это не
хорошо.
Ну не важно, ладно.
Главная идея такая,
дальше пишем, значит
сортируем иксы.
Значит, да,
сортируем иксы.
Значит, дальше
делаем самую магическую строчку
в этом месте.
Но я люблю так писать,
xs.resize
значит
resize
от unic
от
xs.begin
xs.end
минус
xs.begin
Вот.
Ну и в конце
for
point
амперсант
PS
p.x
равно lower bound.
Не надо.
Но lower bound
как-то на массиве будет быстрее работать, чем какой-то
мап, очевидно.
Вот.
Вот.
То есть вот такие вот образы
без всяких созданий мапов это можно
написать.
Так.
Вот.
Так, ладно, надо кому-то рассказать, что
делает алгоритмы sort, lower bound и
unic.
Нет, sort абсолютно
обычный.
Преимущество тут заключается
в том, что sort, unic и lower bound это
стандартные алгоритмы STL.
Ну sort, ну понятно,
что делает.
А unic делает следующее.
Unic, он пробегается
по массиву и
избавляется от идущих подряд
одинаковых элементов.
То есть, ну пример такой.
Значит, смотрите, что делает
уник. Предположим, что унику передали
с помощью двух итераторов.
Значит, массив, в котором
написано 5, 5, 4,
4, 4, 8, 8,
8, 8, 2, 5,
5, 4, 4, 3,
2, 2, 2,
2, 1, 1, 3,
3, 3,
3,
5.
Да.
Ну, тут
да, конечно.
Эпично, да.
Так вот, предположим, что вам
унику передали на вход
вот это. То есть, передали вот типа
begin вот сюда,
end вот сюда. Заметим, что
алгоритм, которому передали
два итератора, он как бы сам
вектор пресайзить не может, естественно.
Более того, это не обязан быть вектор,
вы могли туда и указатели на массив подсунуть.
Вот.
Я рассказываю, как работает
оператор функции уник.
Она работает, да.
Она не завязана на том, что там
элементы отсортированы.
Она просто идет слева
направо и как бы в тот же самый
массив записывает.
То есть, она вот просто берет
вот слева направо идет и тупо
записывает все элементы, но при этом
игнорируя,
но при этом игнорирую дубликаты.
То есть вот дальше вот, например, идет пятёрка,
значит, мы её не записываем. Вот дальше
идёт четвёрка, мы её записываем.
Дальше. То есть вот так вот. Идём,
идем, не записываем,
идём, не записываем.
Значит, идём, ой,
нерав championships, мы пишем восьмёрку.
Значит, идем не записываем,
идём не записываем, идём не записываем.
Значит, двойку записываем,
пятёрку записываем.
Это не записываем.
наоборот это это это мы не зачеркиваем сейчас вот скажу почему значит 5 значит 4 вот так вот
значит это мы да что ж такое зачем я ее зачеркиваю все время нет это мы типа не пишем вот так это
записываем ну короче говоря вы уж дорадуетесь да давали сюда что там что будет 2 1 3 5 короче
вот но юник кое-что вернет вот эти элементы смотрите вот почему это зачеркиваю потому что
идея в том что как бы понятно он новую память юник не создает естественно он просто вот
перезаписывает в начало массива вот эти элементы и более того возвращает итератор вот сюда то есть
то есть типа что я закончил здесь так вот вот эти элементы он не трогает то есть они останутся в
первозданном виде вот то есть вот что по официальному вообще определению делает
собственно алгоритм юник нет почему делает предельно в тупую бежит
да совершенно нет почему нет у него задача сжать идущий подряд дубликаты все это все что он
делает то есть никто не сказал что он удаляет дубликаты все вообще он удаляет подряд идущие
да он делает это салей нет нет вот начиная с этого момента элементы останутся теми же
какими были раньше я их поэтому не зачеркивать то есть там вот то есть массив будет до этого
момента вот такой а вот начиная с этого момента прям вот что было раньше да можете считать по
сути это мусор вот еще вот этот итератор вернется поэтому для того чтобы этот мусор убить я тут
пишу resize от вот этого то что вернул юник минус беги то есть это столько элементов осталось можно
да ну скажем так просто я честно я пишу я пишу так не так привычнее кто-то пишет
res от юника да так тоже можно ну там есть там видимо от юника и эндон а да так-то так тоже
можно это на ваше усмотрение вот но для меня как бы суть одна в результате этих двух операций
это что я сделал я взял массив xs а цартировал там все элементы удалил дубликаты теперь после
этого мне каждый x нужно заменить на его номер в отсортированном массиве как найти номер
отсортированном массиве правильно бен поиском но бен поиск у нас устояли реализуются помчу
алгоритма подчеркиваю алгоритма лавербаунд да не вот эти не путать дальше есть там у сетов есть
метод лавербаунд но если вы напишите лавербаунд от там икса там от с точка бегины там сет точка
то работать он будет не залогарив да вы очень сильно удивитесь почему они ну нет при этом подлянка
такая он попытается к этому бегину прибавлять какие-то какие-то штуки к сожалению по к
сожалению но там есть проблема с этого митератором можно прибавлять там 5 7 10 другой вопрос что по
факту они будут работать через 10 раз плюс плюс ну вот и вас поэтому ждет небольшой сюрприз
вот поэтому как бы аккуратнее поэтому не пишите поэтому пишите метод лавербаунд нет там есть
подлянка что действительно больше есть там метод одно там вы скажете что надо плюс плюс не работает
но там есть функция advance которая получает на вход икса и какой-то число и прибавляет к нему это
число но там по умолчанию там реализация шаблонная по умолчанию там реально по умолчанию там
реализация сделает там нужное число раз плюс плюс или минус минус вот но для некоторых итераций
там advance перегружен в соответствии с тем там соответствии с адекватностью ну понятно там
для скажем для вектор или там для массива естественно там плюс равно работает и так вот есть такой
спецэффект вот так поэтому пишем значит тут лавербаунд да вот странно что никого тут не
смутило что тут надо помимо беги на энд и еще кое-что передать а именно собственно п точка икс да
а вот энд всех смутил но да да да компилятор конечно вот да да вот да компилятор тут конечно
вы запишите вы что-то ему не передали да как это я не знаю как работает ваш лавербаунд но
но мой лавербаунд получает три аргумента они два а вы а ну да так что но то хорошо ладно значит
значит такое лирическое отступление сделали значит на всякий случай вот умелись как пишется
вот сжатия координат так что не знаю я бы не советовал там использовать мапочки вот а то
заводить мапчик что-то совать их куда-то там бла бла бла это ну вот то есть не знаю хотя
опять же формально конечно надо просто там сесть и потестировать там вот еще быстрее
работает понятно что относительно в масштабах основного решения скорее всего это будет там
там разница будет пренебрежимым а у вас скорее всего да окей все ладно все значит все говорим
ладно как говорится некогда да да так и скажем значит практики утверждают что да да возможно
правда будут другие практики а у меня наоборот с мапом зашло вот это нет но я тоже ну да ну вообще
да ну хорошо ладно значит вот так поговорили немножко о коде вернемся к делу вот хорошо ладно
начиная с этого момента мы в общем-то без особого ограничения обществе можем считать что все
координаты тоже для 10 в пятый чем это нам да чем это нам помогает да теперь да теперь все будет
работать залог квадрат не 10 в 9 10 в пятый но все-таки 30 квадрате 20 квадрате что круче да а в нашем
случае ты еще и 18 в квадрате ну вот да ну как бы полтора раза вообще получилось тогда а когда
еще и квадрат это уже даже в два точка двадцать пять раз а то и в два с половиной чем может быть
кайфец но правда есть подозрение что памяти да единственная проблема что там будет не не только
по времени лог квадрат а скорее всего еще и по памяти лог квадрат а это не очень хорошо потому
что она вот то есть лог квадрат памяти то есть 10 в пятый налог квадрат 10 восьмой памяти это
может быть и memory limit да автори задачи делать круглый звук извините у меня решение 64 мегабайта
укладывается как бы то что вы так будете писать но я не задал такого извините вот то есть ну как
тогда нет ну как извините он скажет нет извините да нет знаете у меня решение укладывается называется
как говорится оно простое так что как бы если вы как-то не так думаете это ваши проблемы вот как
тут предлагают думать думать думать некоторые авторы но на самом деле да то есть один из вариантов
такой сейчас мы с вами сделаем фенвика фенвиков то есть потому что до что мы обычно халим фенвика
сумму на подотрезке а теперь где такая давайте сделаем фенвика по иксу то есть вот то есть
давайте вот этот вот эту вот это и за бабахиям фенвика то есть ну ну как храним какие-то вот
Вот эти вот все наши любимые зеленые полуинтервалы, вот эти все, да?
Да, вот будем.
Ну да, но в этих полуинтервалах мы храним не сумму.
Мы храним множество точек.
То есть мы себе заявляем, что tf от x0, ну где у нас x0,
как всегда, от 1 до 10 в пятый плюс 1, как всегда,
это множество таких точек, которые нам изначально заданы,
таких, что p точка х лежит в полуинтервале от f от x0 до x0.
Вот воспользуемся тем, что сами по себе точки,
как физические объекты, не меняются.
Так, ну давайте заведем такой вектор векторов просто, да?
Спрашивается, вот внимание, вопрос.
Каков суммарный размер этого вектора векторов будет?
Ну а n лог, да, 10, ну да.
А, ну, кстати, да, кстати, жатия, конечно, можно уж тут честно написать,
что даже не 10 в пятый, а реально n.
Даже минус, ну будем честны, даже минус 1, в общем-то.
Вот, тогда замечаем, что каждая точка попадет не более,
чем в, соответственно, n отрезочков.
То есть не более, чем логарифом n отрезочков,
в общем, даже не от логарифма, а буквально логарифом.
Как мы помним, да?
Поэтому получается, что суммарно получается этих отрезочков,
то есть суммарная длина всех массивов n лог n.
То есть какие-то массивы большие, какие-то маленькие,
но суммарная длина n лог n.
Удобно, да?
Вот.
Вот.
Но теперь просто идея, просто какая будет?
То есть, но идея у нас будет просто такая,
что когда нам придет какой-нибудь запрос по прямоугольнике,
ну, во-первых, заметим, что мы с помощью классической там
формулы включения и исключения можем свести задачу
к поиску ответов на прямоугольниках с углом в точке 0,0, правда?
Ну, помним, вот это, там минус вот это, минус вот это,
плюс вот это, ну классика, да?
Ну, то есть такие двумерные префиксные суммы, да?
Вот.
Но тогда идея теперь такая.
Заметим, что вот этот вот подотрезок,
мы теперь, мы умеем разбить на логарифм фенвиковых полуинтервалов, да?
Ну, теперь идея такая, в каждом из этих полуинтервалов, да,
лежат какие-то, то есть по x лежат какие-то точки.
Надо взять, в каждом полуинтервале надо взять сумму каких-то точек,
но не всех, а каких?
А только тех, у которых y лежат в заданном подотрезке, правда?
Но при этом заметим, что внутри каждого множества
нас интересуют только точки, то есть хорошие для нас точки,
которые попадают в задний диапазон по y и плохие все остальные.
Поэтому идея оказывается следующей.
А давайте внутри каждого этого tf эти точки отсортируем по y.
И более того, не просто точки отсортируем по y,
а на получившемся массиве размера, то сколько там точек получилось,
забабахаем еще одного Федрика.
Ну вот, тогда, то есть единственная только разница будет,
что какие там бывают y, и это вам придется, то есть там,
в каждом фенвике, перед запуском фенвика, еще и бинпоиском искать.
Чего?
Ну, то есть у вас там есть все точки отсортированные по y.
То есть вы находитесь в каком диапазоне находится интересующая вас точка
и ищите сумму на этом отрезке с помощью уже внутреннего фенвика.
Ну, по сути, да.
Ну, то есть в переводе говорят, да.
То есть скажешь так, внутри каждого ttf вы храните отсортированный массив
по y и фенвик на этих чиселках на нем.
Нет, нам нужна не количество точек, а сумма чиселок.
Да, если было количество точек, то да.
Но нам нужна сумма чиселок.
И более того, чиселки иногда еще и меняются.
Нет, игроки не меняются, меняются чиселки.
Но чтобы поменять чиселку понятно, надо полезть во все tf-ки
и внутри каждой tf-ки сделать изменение в точке в дереве фенвика.
То есть вот такая, то есть заметим, что такое решение тоже работает
за лог квадрат n.
Ну, памяти она требует n-лог n и, конечно, по Константе значительно проще.
На самом деле, у этого решения Константа уже порядка восьми,
на самом деле, семьдесяти вообще, потому что мы делаем четыре разбиения.
В разбиении мы заходим в лог фенвиков.
Вон, в фенвиков мы делаем бабин поиска.
Да, но при этом...
Но это компенсируется тем, что во многих этапах, в половине из этих фенвиков
очень мало точек.
Поэтому вы и тут будете далеко не всегда скакать за логорифом,
и внутри каждого фенвика будете не за реально логорифом n-скакать.
Да, если еще это...
Можно, но нет, можно, кстати, да.
Ну да, ну да, так что, в принципе, это в принципе рекомендует
даже просто уже Сергей Капелевич.
Внутри деревоотресков деревоотрески.
Да, ну единственная проблема, что мы тут этого не делаем.
Да, но...
Ну хорошо, да.
Нет, это правда, да, можно было, конечно, тут это, действительно,
отсортировать все точки по игроку и делать полный протокол, действительно, да,
и было бы примерно то же самое.
Но как бы по фенвику, наверное, памяти все-таки будет жраться чуть меньше.
Можно делать просто фенвик.
Можно, а можно сделать просто фенвик, фенвик, да.
Но в принципе, начиная с этого момента, мы тут обсуждаем технологии,
которые, в общем-то, в которых, конечно, фенвик прекрасно заменяется
на деревоотресков с операциями снизу, на самом деле.
Но разница будет только в том, что деревоотресков будет жрать
в два раза больше памяти.
Или, ну или, да.
Ну или да, но тогда, ну вот.
Ну вот, но это уже, ну, смотри.
Так, сколько у нас времени?
Так, значит, смотрите.
Так, ну это ладно.
Значит, так что такая вот, ну вот, то есть такое вот решение из
залог квадрат, такой вот фенвик, фенвик, такая вот полезная технология.
Ну вот, но есть и другая технология, которая работает, когда обвалится это.
А это обвалится, если, например, вы захотите, ну скажем, присваивать на прямоугольнике.
Да, мало кто знает, но в деревеотресках иногда требует присваивать не один
элемент, а прям несколько подряд идущих скопов.
Ну я думаю, не надо сейчас вам рассказывать технологию отложенных операций, естественно, да?
Вот, ну как-то да.
То есть скорее всего, я думаю, еще на уровне тестирования в продвинутый поток проверялась,
что вы как бы этой технологией так или иначе владеете, да.
Ну вот, ну скажем так, я все-таки поверю, что технологию отложенных операций вам на презентации показывать не надо.
Хотя, Кириль, да.
Да.
Если хотим за n лог квадрат.
А вот смотрите, а вот, нет, ну на самом деле сейчас посмотрим, но на самом деле тут технология
оказывается весьма неожиданной.
Но на самом деле она очень похожа на деревоотреска.
Что говорит деревоотреска? У нас есть массив.
Так, ну во-первых, давайте у нас будет ячейка, которая отвечает за весь массив, храним в нем сумму
и какие-нибудь отложенные операции на весь массив, да.
А потом дальше массив делим на две половинки, в каждом из них типа делаем то же самое рекурсивно.
Правда?
Вот.
И теперь, а теперь предлагается другая версия.
Значит, да, то есть теперь задача, да.
То есть делаем тоже задачу, то есть надо искать сумму на прямоугольники и скажем присваивание на прямоугольники.
Ну или там, я не знаю, прибавление еще на прямоугольники может там.
Все что угодно.
И тут смотрите.
И так, значит, тут возникает такая неожиданная идея.
Значит, тоже мы сейчас построим веселое дерево.
Вот.
Значит, смотрите, идея такая.
Значит, тоже массив мы делили пополам, ну или примерно пополам.
Так вот, здесь мы точки тоже поделим по х примерно пополам.
Но пополам не по х, не в смысле х пополам возьмем.
А чтобы у нас слева и справа точечек было примерно по н пополам.
Ну плюс-минус один.
Вот.
И отправим нот.
И скажем, что у нас есть вот такие ноты.
Вот такие ноты.
Ну вот и скажем, что это вот это был корень.
Это будут дети корня.
В каждом из детей корня.
Да, прям звучит как какой-то пафосный голливудский сериал.
Дети, корня, там, я не знаю.
Вот.
Хотя это просто будет какой-то, да, дети, корня, корень, криминальный авторитет.
Да, корень.
Да, он же там Вася Корнев.
Там родился с 1979 года рождения, да.
Да, какой-то.
Не, ну неважно.
Ладно, так вот.
Значит, в каждой у детей корня мы тоже делим точки пополам.
Но на это прям по игроку.
Во.
Чего?
Тут четыре точки, тут четыре точки.
По количеству точек.
Да, это важно, что тут, конечно, конкретные границы могли пойти по-разному.
Так, что тут мы делаем?
Так, ну тут в каждой, в каждом внуке, естественно, мы тоже делим точки, но уже по иксу.
То есть мы каждый раз меняем координату.
Во.
Вот так вот.
Ну и так вот идем до тех пор, пока в какой-то вершине не останется.
То есть там, если в вершине осталась одна точка, то, в общем-то, рекульсия на этом заканчивается.
Вот, примерно вот так это будет.
Вот так.
Этым построение делаем.
Да, это мы так построили.
Ну, построение такое можно, естественно, сделать в зерлогране, потому что конкретную медиану там по иксу и по игроку можно найти за линию.
Ну или там более простая технология, конечно, отсортировать сначала там.
То есть, допустим, отсортировать, ну хотя, да, можно отсортировать точки по иксу и там в каждой подмассив дополнительно еще и по игроку отсортировать.
Хотя, ну вот.
Ну и там как-то адекватно пилить.
Ну, неважно.
В общем, так или иначе, собственно, делается.
А теперь идея такая.
А теперь, ну вот, а теперь, предположим, приходит к вам запрос.
Вот давайте вспомним, как у нас работают технологии отложенных операций в деревеотресках.
То есть обычно одна из стандартных технологий звучит так.
Вот, допустим, мы себе, мы тут себе захотели, вот давайте я тут деревоотресков нарисую.
Вот на каком-нибудь вот подобного рода подотрески я тут неожиданно захотел что-то сделать.
Вот там присвоить.
Что я тогда буду делать?
Я пойду в эту вершину и скажу, так, эта вершина пересекается с моим запросом, но целиком в него не вложена.
Поэтому я пойду сюда-сюда.
Так, эта вершина пересекается с моим запросом, но не вложена в него, поэтому пойду сюда-сюда.
Так, эта пересекается, еще пойду сюда-сюда.
Эта вершина не пересекается с моим запросом, поэтому, собственно, я из нее не пойду.
А вот эта вершина в него целиком вложена, поэтому я, вот эта вложена, эта вложена,
поэтому я здесь храню какую-то отложенную операцию, которая будет нам говорить, что мы сюда,
на всем этом подотреске присваиваем наш новый элемент, но дети до поры до времени этого не знают.
Ну вот, помните, да?
Вот, потом, значит, вернулись, значит, здесь, соответственно, тоже там сходили куда-то сюда-сюда,
но здесь мы сразу присвоили, а здесь мы сразу выбросились.
Ну а дальше потом говорилось, что если мы хотим, то есть если нам после этого пришла информация о том,
что давайте теперь еще вот на каком-нибудь вот этом подотреске присвоим еще что-нибудь, то что мы делаем?
Мы просто пишем, что вот здесь присваиваем и здесь присваиваем, по сути, да?
То есть тогда оказывается, что эти элементы, ой, я двоечка, я троечка, на самом деле вы галочка,
но я вам пока об этом не скажу, а потом дедушка сверху, да, да, да, да.
Вот, ну потому что если, например, потребуется узнать, кто вот этот элемент, то как произойдет?
Мы пойдем, так, мне нужно узнать, кто вот этот элемент, хорошо, спрашиваем, так, надо узнать, кто этот элемент,
сейчас одну минуточку, так, дорогие дети, у меня тут для вас важные сведения, вы нолики,
так в смысле, вы же сказали галочки, а ты что, детям передал? Нет, вот слава богу, и не надо, это галочки,
ну вот, это нолик, отлично, ну все, передали, пошли, так, кто у тебя ребенок?
Так, сейчас мне им нужно передать важную информацию, передаем, проходим, поздравляю, я нолик.
Вот, ну вот так выглядит классическая технология отложенных операций, да, я думаю там ничего нового там,
там ничего фантастически нового я сейчас для вас не рассказал, вот, вот тут я ничего нового,
ну вот, так вот, идея такая, а давайте-ка то же самое сделаем вот в этом вот,
то есть, предположим, что нам тут неожиданно пришел запрос, найдите какую-нибудь сумму на вот таком прямоугольнике,
так, смотрите, тогда говорим, так, значит, мы, значит, наш запрос как бы пересекается, видимо, с корнем,
но как бы не, но наш корень в него не вложен, поэтому мы идем влево, идем вправо, да, так, смотрим,
вот этот вот как бы левая вершина отвечает за прямоугольник вот такой, ну ладно, там на самом деле можно
конкретные лавербаунды, оперебаунды поставить, естественно, да, так, пересечение есть, но вложенности нет,
поэтому тоже, значит, идем там куда-то влево-вправо, вот, то есть, вот эти все ячеечки тоже обрабатываются,
вот это ячейко тут сразу как бы мы ее берем целиком потому что она в нас целиком, а, хотя нет,
сначала делим вот так, потом делим сюда, но это мы обрабатываем целиком потому что оно целиком вложено,
нам, так, тут точка тоже целиком вложена, поэтому входим, хотя на самом деле вот здесь нам бы
наверное узе могли сказать, что тут на самом деле прямоугольник уже вот такой, он не пересекается с нашем,
с нашим, поэтому мы можем уже на уровне вот этой ячейки выброситься. Ну и так далее. То есть заметим,
что с помощью такой технологии в принципе можно делать и сумму искать и какие-нибудь отложенные
присваивания тоже пожалуйста. А какие проблемы? Нет, а что с пушами, а что такое? У каждой вершины
там два ребенка, значит мы им передаем. То есть с точки зрения суммы как бы никаких проблем,
потому что сумма, то есть если вы на всем прямоугольнике что-то присвоили, значит сумма
будет это сколько точек в прямоугольнике умножить на что вы присвоили. Да, вот возникает основной
вопрос. То есть как бы технология, то есть понятно, что это будет работать в плане находить
правильный ответ. Но теперь самый интересный вопрос, а за какую асимптотику это будет работать?
Так, 4 лог квадрат. Умножить на лог, я надеюсь, хотя бы. Ух ты, корень из лог умножить на лог.
Так, да, сколько вариантов-то, да? Так, ну вот да, ну на самом деле,
действительно, что гадать, давайте попробуем записать. Но сейчас у нас, но сразу предупреждаю,
по крайней мере, в той технологии, которая есть у меня тэшек будет долго. Тэшек. Значит поехали.
Значит работать будем так. Значит внимание. Но на самом деле, давайте будем говорить так. В
каждый момент времени будем считать, что зеленый прямоугольник, он на самом деле внутри синего
прямоугольника ячеечки. Ну потому что в каждый момент времени можно от зеленого
прямоугольника оставлять только его пересечение с синем, правда? Но теперь возникает, но самое,
начнем вот с чего. То есть будем т с индексом вот таким вот.
От n. Значит предположим, что нам, мы хотим вычислить ответ, где у нас n точек, ну вот,
и зелененький прямоугольник как-то внутри этого синего расположен, мы вообще не знаем как.
Тогда какие у нас два варианта бывают? У нас на самом деле может быть два варианта,
потому что вот этот вот, потому что мы тут по х распиливаем, да? И тут два варианта. Этот распил,
распилил зеленый прямоугольник или не распилил? Если он его не распилил, то это получается от
единицы плюс т с абсолютно тем же индексом, но от n пополам. А если распилил, то смотри,
а если распил произошел, то что тогда происходит? Ну тогда заметим следующее, что мы точно знаем,
что наш зеленый запрос прижатка к вертикальной границе, правда? Но теперь заметим, что дальше
мы будем как бы уже делить не по иксу, а по игроку, да? Поэтому логично запрос так мысленно,
ну во-первых, повернуть на 90 градусов, а во-вторых, еще заметить, что как бы прижат,
и тогда он будет прижат снизу, но прижат снизу и прижат сверху, это для нас одно и тоже будет
более-менее, да? Но это означает, что гарантируется, что запрос будет выглядеть примерно вот так.
Вот так. Вот. Ну тоже плюс 100 единиц. Вот. Ну и так у нас появилась новая рекуррента. Ну ничего
страшного. Как боится, глаза боятся, руки делают. Говорим в этом месте мы. Начали говорим,
что t от этого n равно чему? Ну два варианта тут. Распил по иксу, он как бы этот зубчик заденет
или не заденет? Какие у нас варианты? Если он не заденет, то получится 2t от n пополам. Нет,
вру. Да, если не заденет, то наоборот. Один там плюс от единицы, но тут тогда будет зубчик уже,
правда, и для нас это будет принципиально уже вот такого вида. Чего? Нет, потому что здесь как бы
да там будет произойдет, что распил не распилил зеленый отрезок, поэтому получится, что там в
нижней два. Да-да-да, два нужна, поэтому я тут ее так приписал, да. А для удобства, потому что мы
сейчас предполагаем, что мы сначала будем делить по иксу, потом в детях по игроку, во внуках по иксу
и так далее. Но когда мы переходим на уровень ниже, логично повернутый 90 градусов, что там тоже
типа сначала по иксу, потом по игроку и так далее. Вот такая какая-то идея. Вот, ну значит зубчик у нас
либо оказался просто такой же, но горизонтальный, либо он поделился, но тогда у нас оказывается такой
более продвинутый случай. Это называется прижатый к углу, в чем, кстати, абсолютно неважно какому из
четырех. Так, ну что, идем дальше. Так, значит поехали. Так, ну в порядке БФС у нас появился горизонтальный зубчик,
но тем, что, как бы, ну, Вертика, просто этот мы, потому что мы и тот, и тот будем по иксу распиливать.
Поэтому, когда вы тут распиливаете по иксу, у вас тут может образоваться два вот таких зубчика,
а там образуются не вот такие, то есть не такие уголки, а образуются там может быть один зубчик и
один там еще. Такая веселая вещь. Поэтому, значит пишем, значит смотрите, вот тот важный момент. Тут
нам либо повезет, либо не повезет. То есть нам повезет, если я распил, не задел зубчик, да? Тогда
получится T от, значит, этой же штуки от N пополам плюс O от единиц. Ну да. Вот. Точно, да, на этот раз
повернутый, то есть мы вот свели задачу к уже известной рекурренте. Но может так получиться,
что распил произойдет. Но что тогда произойдет? Тогда, на самом деле, тут будет T от N пополам,
плюс T от N пополам, плюс O от единиц. Где, смотрите, тут T, значит тут будет прям тот же самый зубчик,
а тут будет уже вот наша полосочка. Так, ну вообще сразу можно, наверное, заметить, что вот этот
вот случай можно выкинуть, потому что он маржагируется вот этим случаем, правда? Вот.
Вот так.
Ну нормально, Павел. Идем дальше. Так, кто у нас там в порядке? БФС идет следующий. Так,
уголочек. Поехали. Уголочек от N равно. Так, ну уголочек. Поехали. Уголочек. Так,
ну на самом деле аналогично. Тут есть какой-то вот этот вот как бы как бы либо распил произойдет,
либо распил не произойдет. Но уголочек так и так останется. Поэтому я как бы один случай тут
даже писать не буду. А просто, то есть так поменьше, что он типа есть, то на самом деле он нас не
интересует. Получится опять T от N пополам, плюс T от N пополам, плюс O от единиц. Где уголочек
будет? Ну где опять тут будет уголочек? А тут будет, соответственно, да, вот такой вот. Не,
ну что ее и префикс это уже хорошо. Так, хорошо, давайте, кто там у нас следующий? Так, этого
нарисовали уголочек. Ну да, в порядке БФС дальше идет вот это вот. Да, небо в клетку, друзья,
в полосочку. Так, ну сейчас, как пойдет, погодите. Тут как бы, на этот раз тут как повезет. Может
быть распил как бы и состоится, а может не состоится. И на этот раз это два содержательных
случая. Потому что если распил не состоится, то получится горизонтальная полосочка. Вот, то есть
либо произойдет горизонтальная полосочка, либо распил произойдет. Но тогда получится, по сути,
2t от, не, префикса повернутого, такого префикса снизу. Так, значит идем дальше. Так, значит хорошо.
Так, вертикальный зубчик так распилили. Что там у нас дальше появилось? А дальше у нас появился
префикс. Так, вроде я пока ничего не забываю. Префикс. Ну, префикс от n равен. Ну понятно,
что тут есть как бы случайно повезло. Если распил не произошел, то понятно. Если распил произошел,
то тоже понятно. Потому что, смотрите, если распила не произошло, то получается повернутый
префикс. А если распил произошел, то опять получится повернутый префикс и тоже ячейка,
обработанная за O от единицы. Только на этот раз не в том, что она не пересеклась, а наоборот,
что она прям хорошо пересеклась. Поэтому здесь оказывается очень удобно. Здесь оказывается,
что это просто равно t от n пополам плюс O от единицы. И здесь это вот такой горизонтальный
префикс. Вот. Так, кто там у нас дальше? Так, вот этого мы взяли. Так, это мы нарисовали. Так,
теперь у нас. Так, теперь у нас вот эта штука. Ну, вот это, в смысле, вот это, да. Но здесь все
просто. Тут любой распил приведет к тому, что тут будет 2t от вертикальной полосы, правда?
N пополам и плюс O от единицы. Вот. Так, что еще? Нет, сейчас, нет, вертикальный префикс мы уже
сделали. Вот этот надо сделать. Да. Так, ну сейчас, эту вертикальную полосу мы уже сделали. Так,
теперь вот эта горизонтальная полоса теперь осталась. Вот это, но это не полоса, в смысле,
да, вот эта штука. Так, от n она равна 2, ну, по сути, два префикса, да. Так. Так, ну что ж,
так вроде система, так вроде все. Да, правда, что меньше. Так, вы вроде написали замкнутую
систему тэшек, да? Нет, ну, я не знаю, вроде нет ли какой-то тэшки, которую мы тут, которую мы
не расписали. То есть, как бы замкнутая система. Так, ну поехали, хорошо. Ну, значит, как получить,
значит, ну, значит, как получить результат? Ну, на самом деле, заметим следующее. Давайте заметим,
что вот если я вот тут вот эту штуку раскрою, вот, то у меня неожиданно, вот, то в принципе у меня
автоматически получится, что это равно 2t от n делить на 4 плюс от единицы, да, где t, ну, в
соответствии с вот этим, это 2t на префиксе. Так, и вот смотрите, какая прикольная рекуррента
получилась t на префиксе от n равно 2t на префиксе от n делить на 4 плюс от единицы. Внимание, вопрос,
чему равно t на префиксе? Да, логарифом. По какому основанию и от чего? Давайте вспоминаем мастер
терему. Да, логарифом двойки по основанию 4.
Да, поэтому да, но логарифом двойки по основанию 4 это 1 вторая, поэтому мы получаем, что это равно
просто n в степени 1 вторая, ну, более именуемое среди мирного населения корень из n. Так,
то раз это корень из n, то мы автоматически, конечно, выводим, что это тоже корень из n,
да. Так, ну, что у нас там дальше? Так, дальше мы замечаем, что вот t, так. Чего? Где коэффициент
2? Вот здесь? Ну, потому что когда, а откуда 2? Ну да, но только на какие две части? Если мы
эту зеленую префикс на две части разделили, то одна из этих частей она покрыла прям весь
прямоугольник. Вот, и так получается, значит, тут корень. Теперь давайте вот про эту штуку скажем.
Значит, эта штука у нас равна либо ко вот отсюда прям сразу видим, что два корня, ну, то есть
просто корень, да, либо эта штука равна горизонтальной полосе, которая там, которая на самом деле равна
вертикальной полосе. Да, либо она вот равна двум вертикальным полосам. Да, то есть, ну, тут может
быть, да, либо два корня сразу, либо вот тут вот n делить на 4 плюс 100 единиц. Вот, значит,
соответственно, ну, то есть получается, да, тогда получается так, да, тогда легко по индукции
доказать, что это тоже, что это так или иначе корень. Ну, потому что, смотрите, то есть, по сути,
по сути, у нас так, мы несколько раз берем это n делим на 4, потом в корпент останавливаемся,
берем корень, а потом возвращаемся. Причем, когда возвращаемся, говорю, что каждый раз,
когда делили до 4, домножаем на 2. Получается буквально корень, правда? Вот. То есть получается,
что это равно автоматический корень, но и это равно автоматический корень. Вот. Так, ну, что дальше?
Так, что такое уголочек? Уголочек по этой логике получается это корень и z, плюс я же,
плюс он же на n пополам. То есть, получится корень и z, плюс корень и z пополам, плюс корень и z на 4,
плюс корень и z на 8 и так далее, да? Ну, очевидно, это геометрическая прогрессия,
которая тоже схлопнется в корень. Там с какой-то более жирной константой.
Там два плюс два корня из двух. Там какая-то константа, потому что там геометрическая
прогрессия не штаром два, а шаром корень из двух. Вот. Вот. Ну, да. То есть, да, два плюс корень из
двух. Там как-то это, но все равно корень из двух. Значит, тут корень из двух. Так. Так, ну, поехали.
Кому мы тут уже, так сказать, привязали к корню? Так. Тут корень, тут корень. А, ну, то есть,
что мы видим? А, ну, заметим, что вот от этой штуки мы можем избавиться, потому что мы эту вот
мажорирующуюся штуку можем подставить сразу сюда. То есть, это равно от корня из n, прям единицу мы
тоже туда вписываем. Плюс получается там t от себя любимого. Плюс t от там n делит на 4.
Не, ну, просто от этих вот. Ну, я просто вместо вот этого подставляю сразу вот это равенство.
И еще и замечаешь, что тут сразу кой. Поэтому тут получает, то есть, да, то есть t тоже от
себя любимого рекурсивного. Вот с этим вот индексом. И отсюда автоматически получается,
что опять корень из n, но на этот раз уже геометрическая прогрессия с еще лучшим шаром,
который тоже корень из n. Вот. Так. Ну, и отсюда тогда что мы видим? А теперь мы видим, что мы тут
несколько раз делим пополам и в какой-то момент плюнем и заявляем, что дальше корень. Получается,
корень плюс какие-то единички, которых не больше, чем логарифам. Ну, мораль очень простая. Мы
изобрели корневуху. Да. Значит, да. Эта структура данных называется kd дерева. Точнее, конкретно это
называется 2d дерево. Потому что kd дерево то же самое в камерном пространстве. Нет. Смотря какая
цель. Если у тебя задача вывести, скажем, все точки, которые попали в прямоугольник, то это
будет работать за о от корня из n плюс, там, скорее всего, плюс, собственно, все точки. Вот так скажем.
Нет. За о от n тут еще вопрос, какие запросы ищешь. Потому что часто к 2d дереву пытаются применить,
потому что 2d дерева пытаются, то есть это какие запросы. Мы тут сейчас пользуемся тем,
что у нас точки фиксированы, и мы делили прям вот так вот жестко. Потому что на самом деле
на практике это дерево любят использовать еще, когда точки еще добавляются и исчезают.
То есть там точки добавляются и исчезают. Если они как-то добавляются рандомно, то и тут и
работает. Дерево будет более-менее адекватно. Или часто, например, или еще там бывает такой
запрос. Найдите, пожалуйста, а сколько у меня находится точек, которые лежат не в заднем
прямоугольнике, а в заданной окружности? Ну вот, или еще. И в окружности тоже там надежда,
что давайте делать тоже абсолютно тем же методом, как и в любом дереве отрезков. То есть если мы
попали в прямоугольник, который в окружности даже не пересекается, то мы выбрасываемся. В
адекватно каких-то рандомно распределенных точек нормально, но контртест подсунуть можно.
Мы пока решаем задачу вида, что все запросы делаются на прямоугольниках со сторонами
параллельными, а всем координат. Здесь мы просто говорим, что это сумма и прибавления или
присваивание, потому что когда мы говорим про что-то двумерное, на самом деле уже сложно что-то
говорить. Почему? Будет. Дать правду другая технология, мы ее тоже обсудим. Нет, по-разному,
но это если прибавление, потому что вот эта технология кушает и присваивание. То есть это
да. Правда, она работает за корень. 2D дерево работает за корень, но в принципе еще есть
просто сведения из науки, что есть вот камерное дерево, оно отличается тем, что мы делим на х,
потом на y, потом на z, потом на x, потом на y, потом на z, очень по кругу бежим. Так вот,
там асимптотика оказывается n в степени 1 минус 1 делить на d. Ну, в смысле на k, да? Вот.
Ну да, при k равно 1,2 получился наш корень. Вот. Так что вот такая вот красота получается,
маленькая, приятная. Вот. То есть до этого я скорее всего, до доказательства этого скорее
всего мы не доживем, потому что нам уже двумерного случая вон так хватило, но там нет, но там,
честно скажем, там надо отдельно думать на тему того, то есть нельзя ли эти конкуренты в общем
случае как-то все-таки схлопнуть по случаям или как-то вот более общим образом рассматривать,
ну или может быть там у каких-то авторов есть более продвинутые доказательства.
Чего? Нет, пишутся они как в дереве отрезков. Ты приходишь в вершину, значит,
смотришь, у него такой прямоугольник. Да, только, ну разве что, да. Но это обычно не проблема, да.
Нет, там еще в каждой вершине надо хранить, почему конкретно вы попилили или в каждой вершине в
явном виде хранить свой прямоугольник. Ну не знаю, по-моему, но по-моему наоборот,
что неприятного, практически подвешенное дерево отрезков классическое. Ну скажем так,
будет вот задача, как я писал, правда вы можете написать там Федрика Федриков. Вот это,
нет, прибавление по прямоугольнике, наверное, будет немножко другая задача, но в принципе
интересно, да. Ну посмотрим, но в принципе вот. Так, сколько у нас времени-то? Так, 39.40,
так 39.40, это нам типа там 5 минут осталось. Нет, экономистов нет, экономистов выгонять не надо,
да, они как бы да. Нет, на самом деле официальное окончание занятия у нас в 13.45, потом по идее 10
минут перемены и в 13.55 начинается другое занятие. Ну вот, в этом смысле да, но я не знаю,
просто смотрите. Дальше план такой, по идее как бы к этому обязательно надо рассказать,
как с помощью дерева Федриков делать прибавление на отрезки. Вот, но правда фишка еще в том,
что, а потом рассказ как это делать в двумерном случае. Нет, все в этом мире можно. Ну ладно,
нет, то я не знаю, ладно, давайте. Нет, разобраться можно, но лучше да, особенно в двумерном,
я бы, честно говоря, это просто за, там типа давайте вот так-так-так и все понятно, я бы не делал,
потому что нет, по идее как бы да, нет, ну как сказать, потому что дерево отрезков на этом по-любому не
заканчивается, как минимум сливаемое ДО никто не отменял. Значит утверждение, да, мало кто знает,
ОДО можно сплитить и мерзить. Ну и пост тоже, ну как бы вещь важную упомянуть стоит, конечно.
Не, ну как сказать, да, это класс, так конечно говорить, так на кэфе был пост,
поэтому мы это не обсуждаем, да, об этом спрашиваем на экзамене, да, но тогда вы знаете,
если вы там почитать статьи, статьи Адаманта там на этом кодфорсе, знаете там сколько всего,
что знать придется. Так что поаккуратнее, но сливаемое ДО по-любому идет, потому что знаете,
потому что оказался, потому что когда возникают уже просто задачи вида дан массив и выполните
на нем 100 тысяч запросов вида, возьмите подотрезок и отсортируйте его. Нет, ну вот оказывается,
то есть оказывается, что это можно сделать, то есть оказывается, что это можно сделать правильными
там деревьями отрезков, причем на запрос за логарифм. Нет, амортизировано будет за логарифм,
декартовыми можно, но там как бы скажем так, как бы там тоже авторитетные источники, то ли квадрат,
то ли куб там получится, если декартизация писать. Ну вот, а везде амортизация. В декартахе
тоже амортизация, если что? Нет. А, ну в смысле? Ну я боюсь там и то, и то будет. Да, потому что
когда вас там придет информация, там давайте, то есть речь будет идти о том, чтобы сливать два
дерева, у которых не верно, что ключи одного меньше, чем ключи второго, но теоретически можно,
и там даже какая-то симптотика, то ли лог квадрат, то ли лог куб даже возникает, но скорее всего нет,
потому что есть дерево отрезков, которое делает это загарантированный лог. И вот, кстати, это
второй случай, когда дерево отрезков все-таки обыгрывает декартовый дерево. Нет, ну не всегда,
так оно обыгрывает, что я умею тоже самое из-за тот же лог, а тут выясняется, что дерево отрезков
делает это асимпатически лучше.
