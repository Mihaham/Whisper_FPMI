Сегодня рассматриваем еще одну структуру данных
деревоотресков.
Немножко похоже на то, что было в конце прошлой лекции
на Спарстейбл, отличается тем, что мы умеем обрабатывать
запросы на изменения.
Если вы помните, Спарстейбл работал так, что у нас есть
статический массив неизменяемый, и мы на отрезках хотели
находить минимумы.
Так вот здесь мы, во-первых, позволим себе обрабатывать
запросы изменения, то есть массив будет не статическим,
а будет как-то изменяться.
Ну и мы можем искать, опять же, мы будем в основном все
искать на отрезках, но мы можем искать не только
минимум, но и всякие другие гораздо более сложные функции.
Но мы посмотрим на простеньких примерах, начнем с суммы.
Давайте посмотрим такую задачу классическую.
Ставьте, что у вас есть массив чисел, и к нему поступает
два типа запросов.
Первый – это обновление в точке, давайте его напишу
сначала формально, update pos и какой-нибудь x, это, ну
я для простоты себе сделаю следующее, это увеличение
апостова на x, причем x может быть отрицательной.
Ну то есть это любое число, плюс равно, что прибавить
x к тому числу, которое там было.
Если запрос изменения – это просто присвоение в точке,
если мы хотим не заменять, то есть не увеличивать на
какое-то x, не прибавлять x, а просто класть какое-то
новое значение, ну понятно, новые запросы спокойно
выражаются через старое, потому что если мы хотим
положить новое число, то это то же самое, что прибавить
разность нового и старого, тогда как раз старое станет
новым, ну в общем, я себе особенно этим условиям руки
не связываю никак, но мне удобнее будет реализовывать
в таком вот предположении.
Значит, обновление в точке давайте назову, обновление
в точке.
Ну и второй тип запросов – это сумма на отрезке, значит
как-нибудь я ее назову, типа get sum lr, это мне нужно просто
найти сумму элементов с l telpa r, найти a l plus a l plus 1,
плюс так далее вплоть до a r, значит это сумма на отрезке.
Так, задача понятна?
Ну вот, мы научимся сейчас на каждый запрос отвечать
за логарифмическое время, завод логарифм.
Значит, давайте посмотрим какой-нибудь пример, для
небольшого n я нарисую картинку, давайте для n равно 8, мы
будем, ну раз это дерево отрезков, мы будем строить
дерево, причем дерево будет бинарным, так же как у нас
было в бинарной куче.
Значит, как это будет выглядеть?
Вот, значит я сейчас построю полно-бинарное дерево с
восьмию листьями, и листья у меня будут как раз отвечать
элементам массива, значит это будет а нулевое, а первое,
а второе, третье, четвертое, пятое, шестое, седьмое.
Вот, все восемь элементов будут отвечать листьям
нашего дерева.
Дальше они объединяются парами и подвешиваются
до одной и той же общей вершины.
Значит, эти два будут сыновьями этой вершины, эти два сыновьями
этой, эти два соединились, эти два соединились.
На следующем уровне то же самое.
Значит вот эти два объединяются в общего родителя, эти два
объединяются в общего родителя и самая верхняя вершина
корнем дерева будет выступать вершина такая, что внизу
от нее все листья находятся, то есть под ней..
Скажу так, от нее, идя по ребрам вниз, можно дойти
до любого листа.
Вот, значит, будет такая картинка, давай здесь не пшу, а 0, а 1, и так далее, а 7.
Вот, мы будем строить такое дерево.
Значит, давайте я сразу скажу, что каждая вершина на такой картинке
контролирует некоторые подотрезок элементов нашего массива.
Например, вот эта вершина контролирует подотрезок с нулевого по первому элементу.
Здесь отрезок 0, 1. Здесь будет отрезок 2, 3,
потому что здесь элементы А2, А3. Здесь, соответственно, 4, 5.
Здесь 6, 7.
Ну, соответственно, здесь их объединение, то есть с нулевого по третьей.
Здесь с четвертого по седьмой.
Ну и здесь весь отрезок, весь массив с нулевого по седьмой элемента.
Вот, значит, тем самым каждая вершина некий отрезок нашего массива контролирует.
И поэтому у нас дерево отрезков, потому что каждая вершина нашего дерева
она отвечает за некоторый подотрезок исходного массива.
Например, это подотрезок с нулевого по третьей элемента.
Вот это вот все, это все, что находится в поддереве данной вершины.
Да.
Нет, нет, нет, это у меня везде квадратные скобки.
У меня сегодня все на отрезках.
Вот.
Хорошо. Ну и давайте сделаем следующее.
Давайте мы в каждую вершину положим сумму с контролируемым подотрезком.
То есть вот здесь в листиках будут лежать сами элементы массива
A0, A1, A2 и так далее.
Здесь будет лежать сумма A0 плюс A1.
Здесь будет лежать сумма A2 плюс A3.
А, например, вот здесь будет лежать сумма всех элементов A0, A1, A2, A3.
Ну и так далее.
То есть вот если вершина какой-то подотрезок контролирует,
то давайте мы в нее запишем значение суммы на этом отрезке.
То есть скажем, здесь будет сумма A0 плюс и так далее плюс A3.
Здесь сумма с четвертого по седьмой.
Значит, на этих не буду писать.
В корне будет сумма всех элементов с нулевого по седьмой.
Просто когда вершина отвечает за некий подотрезок,
когда вершина контролирует некоторый подотрезок,
мы в вершине храним сумму на этом подотрезке.
Сумму элементов с этого подотрезка.
Ну, тут зависит от реализации.
Давайте я скажу, что мы в вершине это явным образом не храним,
но всегда сможем хранить все элементы.
То есть если надо, я легко смогу в вершине понять,
что за отрезок она контролирует.
Но явные поля внутри вот этой вот вершинки я хранить не буду.
Здесь будет только сумма храниться, и все.
Мне больше ничего не надо.
Ну хорошо, давайте представим, что у нас такая структура есть.
Давайте вообразим себе, как можно было бы отвечать на запросы,
которые нам поступают.
Давайте с апдейта начнем.
Представьте, есть такое большое дерево, все в нем хранится,
что происходит, когда меняется значение какого-то элемента апостола.
Ну да, нам нужно обновить все суммы, которые это самое апостое содержали.
То есть если скажем, вот апостое было, вот это вот А4,
то какие суммы меняются?
Ну понятно, вот это вот поменялось, потому что здесь на х увеличилось,
эта сумма изменилась на х.
Это изменилось, потому что это совершенно контролировало этот,
эта высота суммы изменился на х.
Это изменилось, потому что эта вершина контролировала этот элемент.
Дальше тут надо поменять и здесь надо поменять.
Понятно. В этих, во всех вот вершинах, которые получается по факту
подъемом от листа к корню во всех вершинах надо сделать плюс х,
потому что только здесь сумма изменилась.
Да? И вот здесь делаю плюс х, здесь плюс х, здесь плюс х,
и здесь плюс х. Согласны?
Вот, больше никакие другие вершины эту вершину не контролируют,
Значит, в других вершинах ничего не поменялось.
Ну вот, и вроде все, мы перестроили правильным образом наше дерево.
То есть, если мы хотим обновить в точке, то мне нужно, в зависимости от реализации,
либо сверху вниз, от корня до этого листа пройти и увеличить все вот эти вот суммы на х,
либо, наоборот, от листа дойти до корня и во всех этих вершинах поставить плюс х.
Мы будем сверху идти, от корня до этого листа, то есть мы изначально встаем в корень.
Дальше мы знаем, куда нам нужно прийти эта вершина, которая соответствует листу АПОС.
И дальше просто правильным образом спускаемся.
Каждый раз мне нужно понимать, куда идти вправо или влево.
Ну и вот во всех посещенных вершинках я увеличу сумму на х.
Понятно, что время работы будет логарифмическим, потому что это полное бинарное дерево.
У него, очевидно, логарифмическая глубина.
На первом уровне одна вершина, потом две, потом четыре, потом восемь и так далее.
Значит, не может быть больше, чем логарифм уровней.
Ну и мы это делаем, понятное дело, просто за время пропорционально глубине дерева.
Мы просто спускаемся сверху вниз, время работы, очевидно, равно глубине дерева в худшем случае.
Так проще реализовывать.
Если мы идем сверху вниз, это легко обобщается на всякие разные другие задачи.
Помимо вот этой самой стандартной, она легко обобщается на другие задачи,
типа отложенных операций у нас будет чуть позже.
Ну в общем, так я бы сказал, более общо, если сверху вниз идти.
Мы так просто большую задачу сможем решать.
А снизу вверх тоже можно, но там некоторые ограничения возникают, я туда не полезу.
Ну вот, понятная идея.
Вроде все довольно элементарно.
Теперь давайте с суммой разберемся, значит, что делать, как отвечать на запрос суммы.
Ну, мы на самом деле будем идти довольно наивным образом,
и просто будем идти туда, куда есть смысл.
Вот давайте какой-нибудь пример посмотрим, пусть Элер, у меня это отрезок.
Так, сейчас что-нибудь интеллектуальное возьму.
Давайте 1,7 я возьму.
Вот такой отрезок 1,7.
Мы опять-таки, так, у меня все скобки сегодня квадратные,
если я не четко пишу, это квадратная скобка.
Мы давайте встанем изначально в корень.
Встали в корень.
И мы понимаем, что корень соответствует под отрезку 0,7.
Нам нужна сумма с под отрезка 1,7.
Если бы было 0,7, мы бы могли сразу завершиться,
потому что мы знаем сумму отрезка 0,7.
Мы бы сразу вывели ответ и бы закончились.
Но беда. У меня этот отрезок и этот не совпадают.
Хорошо, давайте не будем особ Emma думать.
И давайте пойдем налево, если нужно,
направо, если нужно.
Если хотя бы какая-то часть отрезка,
с которой нужна сумма,
если хотя бы какая-то часть лежит слева,
давайте пойдем налево.
Если хотя бы какая-то часть справа,
то пойдем направо.
И так будем делать, пока это имеет смысл. Вот, например, был у меня отрезок 1,7. Ну понятно,
что какие-то элементы из этого отрезка лежат слева, какие-то — справа. Мы знаем, что здесь все
элементы с нулевого по третий, значит сюда есть смысл идти, какие-то элементы мне нужны. Вот эти
вот элементы мне нужно просуммировать. Поэтому налево есть смысл идти. И то же самое — направо.
Справа у меня элементы с четвертого по седьмой, все эти элементы мне тоже нужно просуммировать,
значит идти направо есть смысл. Ну, давайте в обе эти вершины спустимся. То есть мы пойдем и сюда, и сюда.
Дальше, например, смотрите, в правой ветке, вот здесь вот, идти ниже уже нет никакого смысла,
потому что меня интересует сумма со всех вот этих вот вершин. То есть отрезок, который меня здесь интересует,
совпадает с тем, который я контролирую. Я знаю в этой вершине сумму элементов с четвертого по седьмой.
Мне все эти элементы нужно взять в сумму, я их просто давайте добавлю к ответу и вниз не пойду,
потому что внизу уже никакой новой информации я не получу. Я знаю сумму со всех этих четырех вершин,
она здесь хранится. Вниз идти нет смысла. Согласны?
Значит, просто это добавляю к ответу и все, вниз не иду. Вот здесь вот у меня проход вниз завершается.
Я ниже не иду. Теперь что происходит в левой ветке? Значит, смотрите, здесь опять у меня отрезок контролируемой 0.3,
а мне нужно пересечь его с отрезком 1.7. То есть мне нужно взять сумму этих трех элементов.
Есть ли смысл идти влево? Понятно, есть, потому что здесь есть какой-то элемент.
Мы пойдем влево, и вправо тоже есть смысл идти, потому что здесь тоже есть какие-то элементы.
Мы опять-таки спустимся в обе веточки. Но вновь получается, что в правой ветке вниз идти нет смысла,
потому что мы и так находимся в вершине такой, что контролируемый ею под отрезок целиком вложен в то,
что нам нужно. То есть все эти элементы мне нужно добавить к ответу. Так вот давайте я ее добавлю к ответу,
а вниз не пойду. То есть здесь опять-таки мой спуск вниз прекратится. Мы уже добавили вот это и вот это.
Теперь осталась последняя вершина, вот это вот. Здесь действие точно так же. Есть ли смысл спускаться вправо и влево?
Понятно, вправо есть, потому что здесь есть какой-то элемент, а влево смысла идти уже нет,
потому что здесь только нулевой элемент. Нулевой элемент в наш отрезок не входит.
Значит, я сюда не иду, иду только сюда. Ну и просто в конце добавляю вот эту вот вершину к ответу.
Точнее сумму, которая там написана.
Вот я говорю, можно, но мы так не будем делать. Мы будем именно вот так вот спускаться сверху вниз,
потому что вы предлагаете, но оно не особенно обобщается. То есть это можно заевать, конечно,
что если бла-бла-бла, если отрезок это все без одного элемента, то вот вычесть один.
Но в общем случае мы будем действовать именно вот так вот сверху вниз, наивным образом,
идя в обе ветки, если нужно, а если не нужно, то обрубаться.
Можете более нормально проговорить?
Я же с код напишу просто.
Вот. Ну, идейна понятно, наверное. Хорошо.
Так, ну теперь давайте как-нибудь это реализуем.
Давайте мне нужно будет вести нумерацию на вершинах.
Давайте я сделаю так же, как у нас было в бинарной куче.
Давайте я скажу, что у меня корень это вершина номер один,
и у каждой вершины v есть два сына 2v и 2v плюс один.
Значит, у каждой вершины есть сын 2v, есть сын 2v плюс один.
Значит, это первая договоренность, вторая, что если здесь,
давайте перерисую, если в вершине v у меня контролировался подотрезок
с tl по tr, я вот так вот двумя буквами назову сейчас подотрезок,
tltr это вот тот самый контролируемый подотрезок.
Так вот, влево и вправо у меня уйдут такие отрезки.
Я посчитаю полусумму tl и tr, округленную вниз,
деление целочисленное с отбрасыванием на дробную часть.
Я взял их полусумму и сказал, что в левую вершину,
то есть вершина номер 2v, идет подотрезок с tl по tm,
а вправую с tm плюс 1 по tr.
Ну такая договоренность. Понятно, что у меня если корневая вершина
контролирует некоторый подотрезок, то дети примерно пополам его делят.
Ну вот я ровно это и сделал. Я взял их полусумму,
если элементов у меня нечетное было количество, то, хочешь не хочешь,
здесь будет родное количество элементов контролируемых.
Давайте скажем, что там, в каком-то из них элементов больше.
Я беру просто полусумму, говорю, что tm это граница разделения,
и соответственно все элементы с tl по tm отправляю влево,
а с tm плюс 1 по tr отправляю вправо.
Ну хорошо, давайте простое утверждение,
которое я не буду доказывать, потому что мне лень,
заключается в следующем, что нам хватит 4n вершин.
Значит, будет достаточно, скажу так, что все вершины
имеют номера от 1 до, ну 4n не включительно, скажу так, не включительно.
Ну вот на нашем примере, если n равно 8, то смотрите,
у меня корень это единичка, дальше здесь 2, 3, тут 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15.
То есть здесь вообще мне хватило аж 15 вершин,
это всего лишь в два раза больше, чем число элементов в массиве.
Если n же не степень двойки, то там будет чуть более скошенное дерево,
но и утверждается, что 4m всегда с запасом хватает.
То есть если n была, как в этом случае, степень двойки,
то вообще хватает 2n, как видим на этом примере.
Если же это не степень двойки, то там будет небольшой перекос,
и из-за этого, грубо говоря, в правой ветке может быть больше вершин,
и у них будут больше номера, ну вот 4n утверждается всегда хватит.
О, я не знаю. Может хватит, но мне кажется, что нет.
Ну типа 4n минус константа уже не хватит, если большая константа.
Окей, так, что хотел сказать дальше?
Да, теперь давайте предположим, что вот так у меня дерево хранится.
Давайте я скажу, что у меня есть некоторый массив t
с индексацией одного до 4n,
и я говорю, что t от v это как раз сумма вершин v.
Сумма хранящейся вершин v.
Ау? Ну да.
Хранящаяся вершин v.
Ну и давайте теперь напишем, как можно было бы сделать апдейт.
Значит вот процедура апдейт.
Я буду идти от корня к листьям, значит я начинаюсь в корне,
и хочу спуститься до того самого листа, в котором происходят изменения.
Значит, синдексис я обычно ввожу такой.
Смотрите, у меня будет приниматься в качестве параметров вершина v,
где я сейчас нахожусь, изначально корень.
Дальше, контролируемый ею под отрезок вот эти самые границы TLTR.
А потом уже параметры запросов, в какой точке и насколько я делаю изменения.
Ну я хочу в точке pos прибавить x.
Вот такой у меня будет синдексис.
То есть как раз меня спрашивали, храним ли мы границы контролируемой под отрезкой в вершине,
вот нет, не храним, я их каждый раз просто в рекурсию явным образом буду передавать.
Можно было бы хранить, это особо ни на что не влияет, просто так меньше памяти будет.
А если мы будем каждый раз по этой формуле просто высчитывать новые границы для любого из сыновей,
то можно будет не хранить эти границы, а просто явным образом их всегда пересчитывать.
Вот.
Значит, что здесь будет написано?
Ну, во-первых, давайте пропишем условия выхода из рекурсии.
Мы выходим из рекурсии, когда мы дошли до листа.
Лист – это вершина, которая отвечает контролируемому под отрезку размера 1.
То есть лист – это вершина, которая контролирует только саму себя.
И соответственно в ней можно сделать проверку TL равно TR.
Вот если TL равно TR, то это в точности означает, что мы дошли до листа.
Потому что у всех остальных вершин контролируемый под отрезок он какой-то большой.
Там есть несколько сыновей в под дереве, несколько листьев в под дереве.
Лист – это когда он один только у себя и больше никого нет.
Значит, если мы дошли до листа, то есть если TL равно TR,
ну тогда, видимо, нужно T в это увеличить на х.
Давайте я вот так напишу компактно.
T в это увеличиваю на х.
Ретёрн.
Сойдёт.
То есть я дошёл до листа, всё, мне больше делать ничего не нужно, я выхожу из рекурсии.
Иначе, если я не в листе, то мне нужно всё равно сделать эту строчку T в это плюс равно х.
Наверное, оптимальное было бы её вынести в самое начало и не писать два раза.
Но это опять-таки не принципиально.
Я в любом случае в вершине увеличиваю сумму на х, потому что в ней сумма увеличилась.
И мне нужно понять, куда мне дальше пойти влево или вправо.
Вот как на этой картинке.
Что мне нужно было из корны пойти направо, а здесь нужно было пойти налево.
Но я же знаю, какие отрезки контролируются у меня детьми – левым, правым сыном.
То есть я могу высчитать эти координаты, понять, куда попала позиция pos.
А понятное дело, что pos попадёт ровно в один из них.
Ну и вот пойти туда, куда она попала.
Давайте мы посчитаем, что tm – это их полусумма, границы наших tl и tr.
И если pos попадает в левый отрезок, то есть вот сюда вот,
то есть если pos попала влево, то есть не превосходит наши границы,
тогда можно просто запуститься рекурсивным апдейтом для левого сына.
Ну а с левым сыном мы уже всё знаем, какие у него параметры.
Это вершина номер 2v.
И контролируемый ею под отрезок имеет координаты tl и tm.
pos x составляю без изменений.
Это спуск в левого сына.
Иначе, если pos уже больше, чем tm, значит мне нужно пойти направо.
То есть pos здесь не лежит, лежит вот здесь вот.
Мне нужно пойти направо и обновляться в правом сыне.
Там прочитано, что pos не больше четвертая.
Ну типа того, да.
Значит нужно пойти направо.
Значит идём в правого сына.
У него такой номер.
Он контролирует такой под отрезок.
Ну и pos x я оставляю без изменений.
Кажется всё.
Нет, x это вот то самое, на что происходит обновление.
Давайте.
Если что?
Ну вот оно будет выглядеть в соответствии вот с этим вот правилом.
Давайте нарисуем, если хочется.
Ещё раз?
Почему у нас либо один, либо другой обновление?
А потому что не бывает такого, смотрите.
Потому что у меня дети дизюктные.
Левый стель по tm, правый стель плюс один по tr.
Они не пересекаются.
Не может быть такого, что pos попал одновременно и туда, и туда.
А мы сказали, что достаточно обновить только те вершины, которые контролируют pos.
Вот не может быть такого, что оба сына pos контролируют.
Потому что не пересекаются просто.
Понятно?
Нет, pos это элемент.
Это обновление в точке у меня.
Так, n равно 5 меня просили нарисовать.
Давайте нарисуем просто, как это будет выглядеть.
У меня будет корень, который контролирует 0,4.
Я просто по форму буду считать.
Смотрите, 0,4 полусумма будет 2.
Поэтому слева 0,2, справа 3,4.
Здесь 0,2 полусумма 1, здесь 0,1, здесь 2,2.
Здесь просто 3,3 и 4,4.
И вот эта вершинка еще на 2 подразбивается.
8,9, 0,0, 1,1.
Но она будет такой немножко скошенная влево.
И соответственно листья – это вот эти вот вершины.
Вот это будет нулевая, первая, вторая, третья, четвертая вершина, соответствующая элементам массива.
Просто по правилам, не думая.
Так. Нормально?
А будет ли лучше просто сделать дерево, чтобы у него была степень двойки вершин,
но остальные по 0?
Можно и так, да, можно и так. Как ходить, так и делайте.
Можно все, можно любой из этого реализовать.
Я думаю, что мы всегда, когда так будет называться реку,
не попадем в клубы с массива T, которые не отмечают наши вершины,
а просто мы с излишком выдали вот в этом излишком.
Нет, ничего плохого не произойдет, потому что у меня всегда спуски корректные.
Я всегда, смотрите, я всегда проверяю, вот у меня вершина V,
она либо лист, тогда я сразу завершаю рекурсию,
либо у него, у него есть два сына, ну потому что как раз у вершины V,
если этот отрезок нетривиальный, то у него не пустой этот, не пустой этот.
Значит у меня есть два сына.
Но я просто понимаю, в каком из них лежит поз, и туда и иду.
Я никогда не делаю чего-то запрещенного, я всегда спускаюсь только туда,
только в такие отрезки, которые контролирует поз.
Поэтому, поэтому это все всегда корректно.
Вот, значит мы такой код написали, так, у меня скобка не закрылась здесь,
ну где-то вот здесь она заканчивается.
Вот, если мы хотим отвечать на запрос типа обновления в точке,
я должен буду из, ну там, основного кода программы вызвать апдейт от корня.
Да, я же говорю, что мы начинаем в корне, вот давайте напишем параметры корня.
Значит апдейт единица, потому что это номер корня 1,
контролируемый корнем под отрезок это 0, n-1.
Вот, ну и поз х это параметры запроса, они остаются прямо как мы считали из инпута.
Вот, то есть этот апдейт работает следующим образом,
чтобы его запустить при обработке запроса надо написать такую строчку.
Потому что мы начинаемся в корне, контролируемый корнем под отрезок это 0, n-1,
поз х то, что мы считали.
Окей? Кайф.
Так, давайте я это оставлю, вот это вот сотру.
Теперь давайте перейдем к гетсаму.
Как сказать сумму на отрезке?
Ну, гетсам.
Значит, синтаксис очень похожий.
Мы стоим в какой-то вершине,
и у нас есть некий отрезок, с которым мы хотели бы посчитать сумму.
Lr. Мы хотим найти эту сумму.
Опять-таки из мейна я потом буду запускаться от корня,
то есть у меня будет изначально v1, tl0, tr, n-1,
то есть я стою в корне и хочу найти сумму на отрезке Lr.
Вот, ну первая проверка такая,
что если я попал в вершину,
которая целиком соответствует нашему отрезку,
тогда я могу просто вернуть то, что написано в этой вершине.
То есть если я попал в вершину,
которая прям абсолютно такая же,
то есть она контролирует такой же подотрезок,
с которым нужно найти сумму.
Ну, значит мы просто знаем на нем сумму,
ее можно просто вернуть и вниз не идти.
Это вот случай обрубания, что вниз нет смысла идти,
потому что и так отрезок, который мне нужен,
совпадает с тем, что я храню.
Ну, дальше давайте что-нибудь напишем,
давайте я напишу какой-нибудь int.
Давайте скажем, что сумма равна нулю,
изначально найденная нами.
Посчитаем границу разделения сыновей,
tr плюс tr пополам, как обычно.
И дальше та самая логика, есть ли смысл идти влево,
есть ли смысл идти влево, есть ли смысл идти вправо.
Обе эти проверки сделаем, если нужно запустимся вот лево-право сына.
Значит как проверить, что есть смысл идти влево?
Смотрите, вот у меня был большой отрезок stl по tr,
в нем как-то был вложен отрезок lr.
Я делю большой отрезок на 2,
stl по tm и stm плюс 1 по tr.
Вот вопрос, мой отрезок lr, он когда задевает левого сына?
Когда есть смысл идти влево?
Когда есть лево.
До l слева еще раз.
Да, когда левая граница не больше, чем правая граница вот этого вот левого сына.
То есть если l меньше либо равно tm,
это в точности условия пересекаемости интересующего отрезка
и вот этого подрезка левого сына.
Что левая граница его не правее, чем tm.
В этом случае мне есть смысл идти влево.
Ну и давайте я напишу такую штуку.
Я к ответу прибавлю get some.
Так я скорее всего не влезу, ну ладно.
Параметры левого сына мы знаем.
Это 2v, tl, tm.
Это мы написали.
Теперь смотрите, я мог бы оставить lr,
но я обычно пишу так, я пересеку отрезок lr с левым сыном,
чтобы у меня не было такого, что интересующий меня под отрезок какой-то слишком большой
и лежит где-то вне моего отрезка.
Чтобы не оставалось вот так вот, чтобы вот такая картинка не оставалась,
я ограничу lr на внутренность отрезка tl, tm.
То есть я оставлю l на месте, а вместо r напишу минимум из r и tm.
Ну потому что понятно, если у меня был такой отрезок lr,
с которого нужно было найти сумму,
а я спускаюсь только в левого сына,
то мне нужно этот отрезок сузить на область определения,
только вот на внутренность этого отрезка.
Поэтому левая граница остается на месте,
а вот правая, если нужно, двигается на tm.
То есть если r было и так внутри,
то есть если у меня была картинка вот такая,
то здесь минимум будет просто r,
а если он вот так именно пересекал,
то я r будет больше, чем tm,
и она сдвинется вот сюда, и я буду искать сумму уже вот на таком отрезке.
От l до tm.
Ну все, теперь то же самое с правым сыном.
Давайте.
Сейчас еще раз. Вот здесь вот?
Так, что здесь должно быть?
Нет, вот я так не хочу делать,
потому что вы всегда говорите, что отрезок lr вложен в контролируемый мой подотрезок.
Именно поэтому я здесь чем-то занимаюсь таким,
что я сдвигаю правую границу, если нужно, направо.
То есть у меня всегда lr, это всегда под отрезок tltr.
То есть у меня будет всегда верно такое,
что отрезок lr – это подмножество под отрезка tltr.
В этом случае достаточно равенства проверять.
Но зато здесь нужно будет тогда пересекать отрезок lr
с областью определения любого сыновей.
Так.
Ну все, теперь правый сын.
То же самое, надо проверить, пересекается ли отрезок lr с правым сыном.
Это можно сделать так, если r больше, чем tm.
Потому что надо проверить, что правая граница лежит в правом сыне.
Это значит, что r больше, чем tm, то есть больше, чем tm плюс один.
В этом случае я опять-таки к ответу прибавляю get sum от правого сына.
dwv плюс один, tm плюс один, tr.
Ну и теперь опять мне нужно сузить lr на область определения правого сына.
В этом случае мне придется написать максимум из l и tm плюс один, и r.
Потому что у меня был отрезок lr,
правая граница r и так попадает в правый сын.
Это мы проверили, r менять не нужно.
Но если что, мне нужно ограничить левую границу на tm плюс один.
Если l вылезала сюда, то мне нужно l обновить
и сказать, что вместо нее будет tm плюс один.
То есть я буду искать сумму на вот этом отрезке.
Ну все, это мы сделали.
И в конце концов делаем ретюрнанс.
То есть мы, если нужно, нашли сумму с левого сына,
с правого сына, сложили их вместе
и вернули в качестве ответа.
Если мы хотим это вызвать из мейна,
то мне нужно будет написать get sum
опять-таки от корня.
1, 0, n, минус 1.
Ну и на том отрезке, который меня интересует lr.
Вопросы?
Почему вы номируете вершины с единички?
Хочу.
Так, хорошо.
Давайте теперь о программе работы поговорим.
Понятно, что update тривиальным образом работает за логарифм.
Я это уже сказал, потому что мы просто за глубину дерева это делаем.
Теперь давайте докажем, что get sum
даже несмотря на свою такую кажущуюся наивность,
он тоже работает за логарифмическое время.
Давайте покажем утверждение, что get sum работает
за от логарифма n.
Ну давайте доказывать.
Давайте промоделируем поведение нашего get sum.
Что происходит?
Смотрите, мы встаем в корень,
и у нас есть некоторый интересующий нас подрезок lr.
Давайте я скажу не умоляю общности, что происходит примерно следующее.
Сначала, в течение нескольких итераций,
мы идем только в одного из сыновей.
Например, если наш отрезок lr достаточно маленький,
то скорее всего несколько первых итераций я не буду раздваиваться
и идти влево и вправо сына.
Я сначала скорее всего пойду просто по какой-то одной ветке.
Давайте скажем, что мы сначала идем по какой-то ветке,
скажем влево, вправо, в общем, как-то ходим, не раздваиваясь.
Вот давайте я скажу, что на всех этих вот спусках
у меня из двух сыновей запускался только один.
Ну как видите, у меня есть раздвоение влево сына, вправо сына.
Вот давайте несколько первых шагов мы не раздваивались.
Ну понятно, сколько таких шагов было?
Дальше вот рассмотрим первую вершину, в которой мы сделали раздвоение.
Ну, если таких не было, то понятно ответ уже логарифм,
время точнее уже логарифм, потому что мы просто спускались по одной ветке, без разделения.
Вот пусть это первая вершина, где мы произошли, где у нас было разделение.
Так, ну первое замечание, что вот это вот по-прежнему не больше логарифма.
Что количество итераций от корня до этой вершины максимум логарифм, потому что мы просто спускались как-то.
Теперь что происходит здесь?
Вот пусть мы здесь впервые раздвоились.
Значит давайте картинка какая-нибудь.
Что это значит? Это значит, что если эта вершина В контролировала вот такой вот подотрезок,
соответственно ее дети разбивали большой подотрезок на два.
Вот это левый, вот это правый.
Значит интересующий мне отрезок LR, он был какой-то вот такой вот.
Ну раз я пошел и влево и вправо, значит мой LR пересекал границу, пересекал середину.
У меня что-то здесь лежит, что-то здесь лежит.
Вот, хорошо.
Ну тогда я утверждаю следующее, что во всей левой ветке у меня никогда не будет содержательных разветвлений.
То есть смотрите, вот есть левая ветка, скажем, я спустился в левого сына.
Давайте представим себе, что в этой вершине я опять иду влево и вправо.
И влево и вправо.
То есть у меня рекурсия вызывает и левого сына, и правого сына.
Ну смотрите, в этом случае понятно, что в правом сыне я вниз уже никуда не пойду.
Потому что если я запустился здесь и влево и вправо, значит контролируемый подотрезок детьми разбивается так,
что у меня правый сын полностью вложен в мой отрезок LR, и еще что-то остается слева.
То есть еще какие-то элементы отрезка LR уходят в левого сына.
Ну то есть именно за счет того, что LR пересек вот эту вот границу когда-то единожды, значит все вот эти вот элементы точно нужно взять в ответ.
И если я из какой-то вершины иду направо здесь, то ниже из нее я уже не спускаюсь.
Потому что она полностью вложена в отрезок LR.
Значит мне не нужно идти вниз от этой вершины, в ней так уже хранится полностью блок, который мне нужен.
А почему она просто вложена в отрезок LR, который вообще не вложен, а равностью проверяет, почему он вызывает?
Ну потому что мы уже пересечем, у нас был LR, когда я спускаюсь в левого сына, у меня LR становится вот таким вот.
Потому что я R, там написано, что я вместо R передаю минимум из R и TM.
То есть на самом деле при спуске влево у меня LR станет вот таким.
Дальше я здесь опять раздваиваюсь, влево передаю вот эту штуку, а вправо вот эту.
Но она в точности совпадает с контрольным подотрезком.
Значит ниже отсюда я уже не спускаюсь.
И то же самое верно для всех вершин вот этой вот левой цепочки.
То есть если я внезапно как-то хожу, если я в какой-то вершине опять раздваиваюсь, то правая вершина целиком вложена в отрезок LR.
Ну потому что какие-то интересующие у меня есть слева, раз я налево пошел.
А справа я знаю, что все вот эти вот элементы интересуют меня.
Значит направо, если я пошел, то дальше вниз я уже не раздваиваюсь.
Потому что весь отрезок интересующий меня содержит...
Ну в общем, все, что я контролирую, меня интересует. Я это добавляю к ответу сразу.
Это значит, что по существу я здесь просто иду по левой ветке.
То есть даже если я где-то раздваиваюсь, то в правом сыне я вниз уже рекурсов не запускаю.
Поэтому суммарно вот здесь я перегружу максимум два логен вершин.
То есть я зайду максимум в два логен вершин, потому что если я раздваиваюсь, то вправо не иду.
То есть если я раздвоился, то правый сын сразу обрубаю.
Поэтому не может быть такого, что я там длинно-длинно рекурсивно обхожу все дерево, грубо говоря.
У меня вот эта правая ветка всегда тривиальна.
Ну и симметрично работает то же самое вот здесь.
Если я внезапно в какой-то момент времени раздвоился и пошел и налево, и направо,
то это значит, что какие-то интересующие элементы были вот здесь вот.
Значит все вот эти вот элементы были вот здесь вот.
То есть все, что контролировался этой вершиной, целиком вложено в интересующий мне отрезок LR.
Значит здесь я не буду спускаться рекурсивно.
Короче, то же самое, только зеркально отраженное.
Если я спускаюсь и влево, и вправо, то из левого сына я вниз не иду.
Потому что он полностью вложен в LR.
Значит здесь опять-таки тоже максимум 2 log N вершин.
Ну все, суммарно получилось, что я обошел 5 log N вершин.
Наверное эту константу как-нибудь можно уменьшить.
Типа там кажется вообще на самом деле максимум 2 logarithm N.
Ну неважно, нам на константу обычно пофигу.
Ну вот, все.
Значит я в процессе моего вот этого getSum'а обхожу максимум от log N вершин.
А понятно, что время работает пропорционально на числу вершин, которые я обхожу.
Ну все, значит суммарно это логарифма.
Ну смотрите, не совсем, потому что раздвоения бывают довольно часто.
Но если я и раздваиваюсь, то я не иду дальше вот здесь вот от левого сына.
То есть смотрите, картинка может быть такой, что я раздвоился вот здесь,
дальше постоянно раздваиваюсь вот так вот,
но просто отсюда я ниже не иду, то есть картинка может быть такая.
То есть раздвоений может быть много, если там отрезок какой-то вот такой вот.
То есть я и здесь раздвоился, и здесь мне нужно пойти и направо, и налево.
И здесь я просто не спускаюсь вниз.
Тут раздвоился, здесь не спускаюсь.
Существенно FitO해� is 1.
Да, существенно 1, правильно.
одно, а все остальные сразу обрубаются.
Это правда.
Откуда взялось число 2 лога?
Откуда взялось число 2 лога? Ну, смотрите,
глубина вот этого дерева максимум логарифом,
на каждом шаге я в худшем случае
как бы спускаюсь в двух детей,
то есть на каждом слой я максимум две
вершины посмотрю. Вот так можно сказать.
Что на каждом уровне у меня
максимум две вершины обработаются, левая и
правая, потому что если у меня есть, скажем,
две вершины, то дальше вниз я отсюда
не пойду, у меня остается только вот эта одна.
Дальше она может дать две вершины на следующем уровне,
отсюда дальше не пойду,
это даст две вершины на следующем уровне и так далее.
Поэтому двойки на каждом уровне,
значит 2 лога.
Ну вот, как-то так.
Все, победа.
Да.
Ну, вот, сейчас,
видишь, одна ситуация,
когда мы репульсивно спускаемся
из какой-то вершины,
и при этом от обоих ее детей
делаем еще какие-то репульсивные...
Все верно, все верно, все верно, да.
Доказали, да, да.
Значит, суммарно логарифм.
Да.
Вот, хорошо.
Ну, смотрите, пафос в том, что мы действуем
как бы довольно жадно, довольно наивно,
и это все равно будет быстро.
Вот как хорошо.
Окей, значит, давайте двигаться дальше,
давайте посмотрим еще какие-то задачи,
которые можно было бы решать с помощью деревоотресков.
Вот, поймем, что можно вообще,
можно им делать.
Так.
Значит, ну, задача.
Давайте я такую сделаю,
для примера.
Представьте, есть массив чисел.
Давайте скажем, что они все не отрицательные всегда.
Поступают запросы двух типов.
Во-первых, это опять апдейт в точке.
Значит, давайте обновление в точке.
То есть там конкретное апостоле
заменить на х.
И второй, давайте я пишу такой.
Значит,
мне дают,
мне дают два числа, l и x.
Мне нужно найти самый короткий отрезок,
начинающийся в позиции l,
на котором сумма была бы хотя бы x.
Значит, картинка вот такая.
Вот есть у меня весь массив от 0 до и на минус 1.
Мне дают левую границу,
и говорят мне,
набери сумму хотя бы x.
То есть ты можешь идти направо,
чтобы сумма была хотя бы x.
Так вот, насколько шагов,
то есть сколько элементов, начиная с l, нужно взять,
чтобы впервые сумма стала хотя бы x.
То есть формально
это нужно найти
минимальная r.
Такое, что сумма элементов с a, l по a, r
больше равна x.
Все то же самое, а на это как отвечать?
Аналогично.
Мы спускаемся, и когда мы спускаемся
вправо, мы спускаемся,
пока мы больше не равны x.
Потому что если на следующем спуске мы меньше равны x,
тогда все плохо, мы не спускаемся.
Ну вот не очень понятно.
Мне нет.
Ау?
Ну бинарный спуск, да, на самом деле.
А нельзя начать путь
с вершины a, l, которые вы знаете,
и подниматься, пока мы заберем
достаточную сумму.
Так, а потом
спускаться в другую ветку,
пока мы не урежем достаточно.
Ну можно так, да,
можно так тоже.
Вот на самом деле много подходов,
я согласен. Давайте расскажу
тот, который мне кажется наиболее
обобщающимся на всякие другие случаи.
Ну понятно, первую штуку
мы уже обрабатывать умеем.
Давайте сразу скажу, что в дереве отрезков
я опять в каждой вершине буду просто хранить сумму
Значит, тогда первую мы уже обрабатывать умеем,
это уже написали такой код.
Теперь давайте поймем, что происходит вот здесь.
Что происходит вот здесь.
Окей.
Давайте я виртуально в голове вызову getSum
для, ну l равно l
и r равно n-1.
Давайте так я сделаю.
Ну, потому что понятно,
скажем, если у меня сумма на этом отрезке
меньше, чем x, то ответ не существует.
Ну что, нет никакого r, чтобы сумма была хотя бы x.
Поэтому в каком-то смысле мне
эту сумму все равно найти придется,
вот давайте я ее типа найду.
Значит, что произошло?
Мы понимаем, что getSum он лениво просто встает
в корень и дальше идет туда,
куда имеет смысл.
И заканчивается в тех вершинах,
из которых вниз уже спускаться не нужно.
Так вот, это получается, что весь мой отрезок
с l по n-1
в процессе вот этого рекурсивного getSum'а
он по факту разбивается
на какие-то подотрески,
контролируемые конкретными вершинами.
Вот этот getSum' он как заканчивает
работу? Он находит какую-то вершину, контролирующую
такой подотрезок, какую-то вершину,
контролирующую
такой, и что-то здесь там, как-то еще
подразбивает. То есть по факту мы разбили
наш отрезок интересующий outer
на какие-то подотрески,
которые явным образом контролируются
вершинами, да, и мы знаем сумму здесь, сумму здесь,
сумму здесь, сумму здесь. Значит мы можем
всех сложить, будет ответ на сумму.
Причем мы знаем, что таких отрезков логарифмическое количество от
логарифма. Ну вот дальше я предлагаю сделать
следующим образом. Вот у меня есть мой отрезок lr, то есть l-n-1,
разбився на небольшое количество подотресков, я знаю сумму на каждом, и мне
нужно найти, когда впервые сумма слева направо превысит x.
Ну давайте пойдем по этим вершинам слева направо. Считаем сумму здесь, сумму
здесь, сумму здесь, сумму здесь. Вот давайте ее наращивать, то есть прибавлять
каждый раз сумму в текущей вершине, и дождемся, когда она впервые превысит x.
То есть если, скажем, сумма здесь плюс сумма здесь меньше, чем x, значит мне нужно
все еще идти направо. Вот пусть впервые сумма превышает x в этой точке.
Ну там больше права на x в этой точке. Что это значит? Давайте картинку перерисую.
У меня был длинный подотрезок, я его разбил на некоторое количество отрезков
поменьше. Знаю сумму здесь, сумму здесь, сумму здесь. И, например, я понял, что сумма
это плюс это меньше, чем x. А вот здесь уже сумма больше, чем x. Если я все вот это
вот сложу, то сумма будет больше на x. Тогда давайте мы встанем в эту вершину.
Так. Да. И из нее эту задачу уже решать проще. Смотрите, я могу встать в эту вершину,
мне нужно найти такой элемент, вот здесь, в этом контролируемом ею подотрезке,
что вот здесь вот сумма, ну вот здесь вот общая сумма будет хотя бы x. И дальше уже работает
та же самая жадная идея, потому что я стою в каком-то смысле в корне, ну там в корне
своего поддерева. Здесь я могу пойти влево, могу пойти вправо. Есть ли смысл идти влево?
Но если здесь вот сумма хотя бы x, то есть если вот эта вот сумма, плюс все вот это
вот хотя бы x, то ответ точно в левой ветке. То есть если все что я уже посчитал, плюс то,
что мне предлагается в левом сыне, хотя бы x, значит ответ точно где-то здесь, то
есть граница проходит где-то здесь. Если же я сумму таким образом не набираю,
то есть если у меня левый сын, плюс все что было слева, меньше, чем x, значит�도 вот это
в правом сыне. И он точно в правом, потому что я знаю, что граница где-то вот в этом отрезке.
Значит, мне нужно всегда либо налево пойти, если граница слева, либо направо, если граница справа.
Да, да. То есть, еще раз, смотрите, у меня решение распалось на два шага. Во-первых,
я сначала разбил интересующий мне отрезок на логарифмическое количество вершин в ДО,
в дереве отрезков. Вот у меня были какие-то вершины. Дальше я иду по ним слева направо,
насчитываю сумму, дожидаюсь, когда впервые сумма превысила x, стала хотя бы x. Это значит,
что ответ, точнее, вот эта вот граница разделения, вот эта вот граница, она где-то внутри вот эта
вот контролируемая под отрезка, где-то вот здесь. Значит, здесь его искать бессмысленно,
а мне нужно искать его где-то здесь. И тогда дальше я просто запущу отдельную процедуру,
которая встает в корень вот этого поддерева. Значит, я знаю эту вершину. И дальше он рекурсивно
будет идти влево или вправо в поисках этой границы. Проверка очень простая. Есть ли смысл идти влево?
То есть, правда ли, что граница находится в левом сыне? Это проверить легко. Надо узнать,
что сумма здесь плюс то, что было слева, хотя бы x. Если это так, то значит, граница там. Если же нет,
то граница точно справа, и мне нужно идти вправо сына.
Почему вы считаете, что справа идти оптимальнее? Может быть, по-среднему оптимальнее?
Не понял. Возможно, по бокам там сумма очень маленькая, а по среднему вся сумма.
Во-первых, у меня все элементы не отрицательные. Во-вторых, у меня сумма такая нарастающая. То есть,
я зафиксировал левую границу, я перебираю все вот такие вот суммы и дождаюсь, когда впервые x.
Вот такая вот идея. Мы поделили так же, как на той доске написано, жадным алгоритмом GetSum.
То есть, вот те вот спуски, которые опять спускаются туда, куда надо, они по факту,
вот когда вот это вот условие срабатывает, вот это вот, вот такие все вершины будут контролирующими.
Вот то, что здесь нарисовано, это вот как раз те вершины, откуда рекурс и вниз не идет.
Их будет логарифм, мы знаем, что логарифм здесь всегда, всего логарифм. Вот их как раз логарифмическое
количество. И дальше по ним идем слева-направо и выбираем ту первую, где сумма превысила x,
там уже рекурсивно запускаемся. Да. А чем тогда вот алгоритм, который я уже говорил, здесь типа спускаться влево, пока типа ну это хорошо?
Ну мы в каком смысле то же самое делаем, только ну мы не можем, как бы тут не понятно, что такое спускаться влево.
Потому что если мы встанем в корень и пойдем налево, то нам нужно сначала понять сумму,
которая является пересечением левого сына, и отрезка начинается с позиции L. Нам надо сначала найти эту сумму,
потом если что пойти вправо или пойти влево. То есть мы как бы две задачи одновременно решаем.
Так можно сделать, в данном конкретном случае это можно сделать, но в общем случае я бы сказал так,
вот методологически проще рассматривать именно как бы, это как две отдельные задачи. Что мы сначала
интересующий отрезок разбиваем на маленькое количество подотресков, и дальше понимаем, где проходит граница,
и дальше уже в вершине, где находится граница, вот здесь вот внутри, дальше уже запускаем такой простой спуск.
То есть здесь я пользуюсь тем, что у меня вот, то есть я делаю то, что вы говорите, для вершины, у которой контролируемый подотрезок
полностью входит в область определения. То есть потому что у вас, если мы идем влево, а L это не ноль,
то мне нужно, ну то есть как бы, у меня было бы что-то вот такое, да? Я контролирую вот это, а L где-то вот здесь вот начинается.
Ну и вот непонятно, как найти здесь сумму элементов вот с этого по там, по что-то. Ну типа если бы было вот здесь, было бы круто.
Вот я ровно это и добиваюсь. А вам нужно еще как-то думать, как искать вот эту вот сумму, как вот это отбросить, ну вот не хочу об этом думать.
Да?
А как на два?
А как на два-то?
Мы не умеем на два разбивать. Если бы на два разбивали, у нас бы тогда где-то сам за единицу работал. Ну то есть можно было бы за единицу написать.
Нет, посмотрите, потому что на самом деле у меня в дереве отрезков каждый отрезок может покрыться, ну в худшем случае, логарифмическим количеством вершин.
Более того, бывают такие, где именно логарифму придется. Потому что, например, если у вас, ну смотрите, если у вас общий отрезок это 0, n-1, а вам нужна сумма с единицы до n-2, тогда у вас будет примерно что-то вот такое.
Вот это будет вот сюда контролировать, это сюда, это сюда, это сюда, ну и так далее. Типа в общем случае у вас не получится двумя.
Я утверждаю, что, ну там, короче, если вы остановите картинку, рассмотрели отрезок с первого по предпоследней, то вы его просто двумя вершинами не накроете.
У вас нет таких двух вершин, которые бы в сумме покрывали весь отрезок. Вот, в худшем случае их будет логарифм, и где-то сам говорит, что это за логарифм вершин.
Вот те вершины, где рекурсия вниз не идет, те самые вершины.
Ага, секунду.
Последствия действий. Ну, это понятно? Вот этот запрос. Это точно так же, как раньше. Значит, здесь запрос такого типа.
Два шага. Во-первых, мы сначала представляем отрезок с l по n-1, мы, точнее, его покрываем логарифмическим числом вершин DO.
Для этого просто запускаем алгоритм аналогичный GetSum и записываем все вершины, из которых он ниже не спускается. То есть мы запоминаем все вот эти вершины.
Непонятно. Плохо.
Так, давайте GetSum тогда вспомним. Смотрите, вот, что он делает?
Он идет вниз и завершает рекурсию, то есть выполняется вот это условие, когда контролируемый отрезок полностью вложен в LER.
Как это работает на картинке? Вот было у меня большое дерево какое-то, большое дерево отрезков.
Мне нужна была сумма вот здесь.
Как я хожу? Я как-то там спускаюсь, где-то там раздваиваюсь, что-то делаю, и в каких-то местах у меня появляются вершины, где вот это условие срабатывает.
То есть это такие вершины, что сумма в этой вершине меня полностью интересует.
Значит, вот здесь вот, вот здесь вот я посчитал, и вот здесь вот посчитал.
То есть в каком-то смысле GetSum делает следующее. Он просто разбивает отрезок LER на несколько подотресков, каждый из которых соответствует вершине DO.
Это вот как раз такие вершины, из которых рекурсов вниз не спускается.
Ну как бы мы понимаем, что у меня вернется правильная сумма, то есть в каком-то смысле я просто вот это вот разбил на меньшие подотрески, каждый из которых это вершина DO.
Отлично.
Так вот ровно это мы и сделаем. Мы сначала наш большой отрезок LER разобьем на несколько вершинок, то есть покроем вершинами деревоотресков.
То есть я запускаю ту же самую процедуру и сохраняю все вершины, для которых произошло вот это вот условие.
А мы вызываем A, B, N и O?
Да, да. Ну то есть как бы понятно, в худшем случае у меня граница где-то вот здесь вот.
Вот я давайте полностью весь этот отрезок разобью на подотрески.
Значит это был первый шаг.
Второй шаг, смотрите, вот у меня есть список вершин. Первая, вторая, третья, четвертая.
Они у меня слева-направо легко упорядочены.
Давайте пойдем по этим вершинам, будем считать сумму, которая написана в них.
Вот это, плюс вот это, плюс вот это, плюс вот это.
Посмотрим, когда впервые текущая набранная сумма будет больше она, чем x.
То есть скажем, ну там не знаю, здесь 5, здесь 7, здесь 10 и x у меня было, скажем, 15.
Значит здесь еще не хватает 5, 5 плюс 7, 12 тоже не хватает, значит мне нужно где-то справа искать.
А 5 плюс 7 плюс 10 уже больше, чем 15, поэтому граница где-то вот здесь проходит.
То есть впервые 15 достигается где-то на таком отрезке и граница находится внутри вот этого отрезка.
Хорошо, значит мы знаем, что границу нужно искать только внутри вот этой штуки.
И дальше будем ее искать, дальше вот второй шаг, ну или там третий можно сказать.
Что мы встаем в эту вершину и дальше будем идти, ну дальше запускаем аналогичный рекурсивный спуск.
Что мы идем либо влево, либо вправо в поисках того момента, когда впервые сумма будет хотя бы 15.
То есть смотрите, здесь мы знаем, сумма уже 12.
Значит мне нужно найти, когда здесь сумма будет хотя бы 3.
Ну 15 минус 12.
Смотрите, если здесь сумма, скажем, хотя бы 3, то граница точно слева.
Граница прещения точно слева.
А если она меньше 3, то точно здесь.
Ну и значит мы знаем просто куда идти.
Что мы спускаемся либо влево, либо вправо, если здесь недостаточная сумма.
Ну и так мы найдем долиста, где как раз после которой происходит сечение по х.
Проблема, что наши искомые границы точно совпадают с самой начальной границей последнего отрезка.
То есть после доволения которого станет больше.
Вот здесь.
Левая граница третьего отрезка.
Вот это.
Ну смотрите, это тогда было бы означало, что х равно 12, значит я бы закончился вот здесь.
Ну еще раз.
Что значит, что граница здесь?
Это значит, что сумма на этих двух хотя бы х.
Нет, граница в смысле до которой включительно придется суммировать.
То есть сумма на этих двух меньше.
То есть надо взять первый элемент отсюда.
Ну а в чем проблема?
Я спускаюсь каждый раз влево дальше, ну вот у меня был такой отрезок.
Это всему соответствовало, это как-то вот так, это как-то вот так.
И вот этот левый элемент здесь, это второй элемент здесь.
Ну смотрите, я в этой вершине понимаю, что влево есть смысл пойти.
Ну и после него у меня будет как раз граница.
То есть я спускаюсь до какого-то листа и говорю, что после него граница.
Так же здесь, я дохожу до такого листа.
То есть я дохожу до последнего листа.
Сейчас.
Да вот даже не нужна дополнительная проверка.
Короче, я утверждаю, что мы таким образом как раз дойдем до листа
такого, что до него границу поставить нельзя.
То есть до него сумма меньше, чем х, а после уже больше.
Поэтому граница всегда будет после того листа, до которого я спустился.
Если у нас все числа неоткрытые,
можно просто посчитать сумму на 0 до 8 и также искать?
Тоже можно, да, это правда.
Можно было бы посчитать сумму от 0 до или минус 1,
и потом запуститься просто от 0 с суммой х плюс то, что вы сказали.
Да, так тоже можно, тоже годится.
Но опять же, в общем случае вы не можете,
если задача более сложная, то вы не можете учесть отрезок 0 до или минус 1,
но в этом случае можно, да, это правда.
Ну смотрите, предложение было такое,
что вот эту задачу можно сделать по-другому.
Можно сначала к х прибавить вот эту вот сумму
и сказать, что или равно 0.
Вот, и дальше не нужно было бы развивать,
можно было бы вот этот алгоритм просто запустить сразу.
Так, окей.
Так, давайте дальше, давайте следующая задача.
Значит, это будет провод ложной операции.
Ну что, давайте так.
Опять у нас есть массив,
опять есть два типа запросов,
только теперь обновление уже будет не в точке, а на отрезке.
Мне дают координаты отрезка L, R
и дают число х.
Я хочу на отрезке с L по R все числа увеличить на х.
То есть я хочу AL-ты увеличить на х,
а L плюс 1 увеличить на х
и так далее вплоть до Айротова.
Вот такая штука.
Ну и давайте оставим сумму на отрезке.
Вот, то есть по сравнению с первой задачей
у меня обновление не в точке, а на отрезке.
Не в точке, а на отрезке.
Так, хорошо.
Значит, как я это буду тогда делать?
Смотрите, идея следующая.
Давайте мы ведем отложенные операции
и в каждое решение помимо суммы с подотрезком
будем также хранить информацию вот о том самом х,
который нужно ко всем элементам прибавить.
То есть помимо суммы, которая у меня будет в t лежать,
я буду хранить еще х.
Тот самый х, который нужно прибавить ко всем элементам
в т.е. вершина чему-то соответствует к какому-то подотрезку.
Вот х значит, что всем этим элементам надо сделать плюс х.
Вместо того, чтобы явным образом по ним по всем проходиться
и каждому в отдельности присваивать плюс х,
я просто положу сюда х и скажу, ну, потом когда-нибудь это учту.
Если мне нужно будет, я этот х протолкну в детей.
То есть я откладываю на будущее себе выполнение этой операции
в каком-то смысле
и просто сохраняю, что вот здесь, вот в этой вершинке
надо не забыть, что все на самом деле элементы
в этом подделе увеличиваются на х.
Идея такая.
Как мы ее будем реализовывать?
Надо договориться.
Я буду поддерживать такой вариант.
Следующее условие будет всегда справедливо.
Что если я дохожу от корня, то есть от вершины номер 1
до какой-то вершины с номером v,
спускаюсь рекурсивно сверху вниз,
так что мне надо сделать?
Сейчас, одну секунду, я скажу.
В общем, я хочу сказать следующее,
что когда я прохожу вдоль какого-то пути,
когда я спускаюсь от первой до в этой вершины,
я всю информацию, которая здесь была отложена,
то есть вот в этих вершинах были какие-то отложенные х,
я всю эту информацию проталкиваю.
То есть я выполняю то, что я себе когда-то в прошлом
пообещал сделать, если у меня здесь лежал какой-то х,
давайте картинка, вот у меня была вершина,
здесь лежал какой-то х нетривиальный,
и мне нужно, скажем, пойти направо.
Так вот перед этим давайте я этот х спущу и влево и вправо,
то есть я этот х сотру, а здесь поставлю х и х.
Тем самым я как раз информацию протолкнул в обоих сыновей.
Ну и понятно, что я ничего не потерял,
потому что прибавить х на всем этом под деревя,
то же самое, что прибавить х здесь и здесь независимо,
потому что это объединение двух деревьев.
А прибавляем к тому х, который там уже был.
Во-первых, во-вторых, мы увеличиваем сумму на х
умножено размер под дерева.
Потому что когда у меня в под дереве происходит обновление
на плюс х, то мне нужно еще и сумму обновить.
Если все элементы увеличились на х,
то сумма увеличилась на х умноженное количество элементов под дереве.
Такой вариант, что когда я иду вдоль пути,
я вот эту отложенную информацию проталкиваю вниз.
То есть вместо того, чтобы ее сразу в листья проставлять,
мне нужно, если я хочу пойти вниз,
я ее протолкну в детей.
Давайте напишем вот эту процедуру.
Эта процедура типа push,
проталкивая информации из вершин в детей.
Давайте вот так вот ее сделаем.
Как протолкнуть информацию,
находящуюся в вершине В?
Давайте просто сделаем так.
Если здесь был какой-то х,
значит, что все нужно здесь увеличить на х.
То есть я х с номером 2v увеличиваю на х от v.
Х с номером 2v плюс 1,
то есть для правого сына тоже увеличиваю на х от v.
То есть я этот х передал в детей.
И дальше мне нужно еще сумму в них обновить,
потому что пришло обновление на плюс х,
в них соответственно нужно еще сумму обновить,
потому что все вот эти элементы увеличились на х.
Вот здесь хранилась правильная сумма.
Но давайте это сделаем.
Давайте еще раз посчитаем границу разделения детей.
Ну и мне нужно в этой вершине сумму увеличить
на х умноженное количество детей.
И здесь х умноженное количество детей.
Это пишется так.
t от левого сына плюс равно x умножить на сколько детей слева,
ну точнее сколько элементов слева.
И в конце еще сделаю х от левого сына плюс 1.
Ну и аналогично для правого сына t от 2v плюс 1
плюс равно х от v
умножить на размер правого под дерево.
То есть tr минус tm.
И в конце еще сделаю х от v равно 0.
Чтобы...
Да, да.
Да, да, да.
В этом смысле, что если я дошел до вершины,
то в ней уже правильная информация.
Если я от корня дошел до кудота, то в этом кудота уже правильная информация.
Вот.
Значит еще раз, что делает push?
Смотрите, у меня была здесь отложенная операция.
Тут было написано, что все элементы в под дереве надо увеличить на х.
Окей, и я хочу при этом там пойти куда-то влево или вправо.
УFO, просто вот эту информацию передам в детей.
Потому, что понятно, что если все вот здесь вот элементы увеличится на х,
это то же самое, что если просто этот х передать сюда и сюда,
и все элементы здесь увеличится на х, и здесь увеличится на х.
Но это одно и то же просто.
Увеличить на х все под дерево, или сначала левая, а потом правая.
Так вот, давайте я этот х теперь протолкну в детей.
Для этого я увеличиваю х-ы слева и справа на тот самый х от v.
То есть я передаю информацию об этой отложенной операции в детей.
И также мне нужно обновить суммы в них,
что в них пришла новая информация, они узнали, что теперь все их элементы в поддереве увеличились на x,
значит мне нужно у них суммы обновить. Сумма увеличивается на значение x, умноженное количество
элементов в поддереве. То есть вот здесь вот это будет количество элементов с tl по tm, их вот столько, tm-tl+.
Здесь это все элементы с tm+, tr, их вот столько, tr-tm. Я протолкну информацию в детей, они поняли,
что пришло новое обновление, плюс x. Правильным образом пересчитали свои суммы. Ну и теперь этот x я
могу смело забыть, потому что эту информацию я уже передал. Ее не нужно будет еще раз потом в
будущем учитывать, потому что она и так уже передана в детей. Да, если я здесь оставлю x, то это как
будто бы значит, что я сначала здесь делаю плюс x, потом здесь, потом во всем еще делаю плюс x. Это
неправильно. Мне нужно только здесь и здесь. Если я передал в детей, то здесь нужно занулить. Вот здесь
вот уже не нужно прибавлять плюс x, потому что уже передано все. Еще раз? А так у меня просто есть
перемены x в каждой вершине. Если она нулевая, то делать ничего не нужно. Ну то есть как бы можно
это сделать, но ничего не произойдет. Вот, поэтому я даже не писал никакого wi-fi отдельного. Ну вот и
все. Дальше, чтобы обрабатывать все запросы, я буду действовать так же, как всегда. То есть идти
вниз и там как-то жадно, наивным образом идти в обе стороны, если есть смысл. Только перед этим,
перед тем как спускаться в детей, я сначала запущу push. То есть я передам отложенную информацию
вершине в ее детей. Тем самым я как раз все, что когда-то в прошлом себе пообещал сделать,
выполню в этот момент. То есть, точнее, передам опять-таки, передам это поручение детям. Скажу,
что ты, пожалуйста, всех увеличь на x, и ты, пожалуйста, увеличь на x. И если это дойдут до тебя,
то ты уже потом опять-таки сам будешь это все протоковывать в детей. Вот в момент, когда я
иду из вершины v куда-то, я только вершину v избавляю от ответственности. Я говорю,
что вот она сейчас передает, и дальше дети, если надо, опять эту информацию правильно передадут.
Ну вот как-то так. А в остальном здесь все, здесь обновления и запрос суммы такие же,
как были раньше. Например, как работает GetSum и Ler. Ну мы просто идем сверху вниз,
видим вершину, проталкиваем ее с помощью push. И опять-таки идем влево и вправо, если нужно.
За счет нашего инварианта, за счет того, что всегда, если я попал в вершину из корня,
то в ней правильная информация хранится. Я всегда, когда иду сверху вниз, я информацию проталкиваю,
то есть в вершине всегда правильная информация. Если я до нее дошел из корня, то в ней правильный
ответ. Ну и тогда, если я просто в GetSum напишу то же, что и раньше, то просто всегда, когда дохожу
до вершины, там уже правильный ответ, его можно прибавить к ответу просто. Да. Ну да, да. Работает
так же, как и GetSum, он спускается снизу вверх. Когда дошел до вершины, где нужно делать плюс х,
он просто в ней делает плюс х вот здесь вот. И сумму тоже правильно увеличивает. Ну t увеличивает
на х на размер. Вот. Да, да. Да, да, в ТВ всегда, если мы, как бы если мы от корня дошли до в,
то в ТВ правильная сумма, а х — это то, что нужно еще передать детей. То есть дети еще не знают об
Но когда надо, они об этом узнают, когда я сделаю push от v, они эту информацию получат.
Такое бывает часто нужно, когда у меня запросы, когда все запросы на отрезках,
то есть как мы видим, здесь у меня сумма на отрезке интересует, и здесь мне нужно обновлять тоже
плюс равно на отрезке, увеличивать на отрезке. Если первая задача у нас была плюс в точке и
сумма на отрезке, то здесь и то и то на отрезке, скорее всего, нужны отложенные операции.
Если вы видите, что у вас оба типа запросов про отрезки, то скорее всего нужны отложенные операции.
Так, хорошо, значит, ну тогда последний сюжет остался.
Да, да, да, здесь всегда логарифмы пока что будут, да.
Так, ну хорошо, давайте последний сюжет.
Опять-таки есть массив.
Давайте к нему поступает следующий запрос.
Просто один тип запросов без изменений.
Запрос такой, lrx, значит, это нужно сообщить, сколько элементов с l по r больше или равной чем x.
Значит, сколько элементов из a l, a l плюс 1 и так далее, a r, больше или равной x.
Сейчас, а или меньше я хочу сделать.
Давайте меньше это равно, мне будет удобнее так, это неважно.
Вот, то есть массив у меня не изменяется, запросов изменений нет, есть только запросы
нахождения какого-то количества. Сколько элементов на отрезке не превосходит какой-то границе, не
превосходит x. Так, может есть какие-то мысли сразу как делать?
Ну нет, а x может быть разным, он может от запроса к запросу меняться.
Ну, просто максимум вроде не хватит.
Во, да, ровно так мы и сделаем.
Значит, смотрите, вы в правильную сторону думаете, что можно в вершине хранить не только сумму.
До этого момента у нас в вершине была всегда только сумма, понятно, что можно хранить всякие разные другие вещи.
Давайте мы в вершине будем хранить в отсортированном виде все контролируемые значения.
То есть, скажем, если у меня вершина v отвечает какому-то отрезку массива с tl по tr,
давайте вот здесь будет храниться отсортированный список всех вот этих чисел.
В вершине хранится, так и напишем, в вершине v хранится отсортированный список контролируемых значений.
А вот не страшно на самом деле по памяти будет.
То есть, да, вот в вершине v все вот эти вот числа, все листья, которые в этом поддереве лежат,
я их все сюда складываю и сортирую, и это будет вот то, что хранится в вершине v.
Значит, я утверждаю, что это по памяти всего будет n лог n суммарно, по всем вершинам это будет всего n лог n памяти.
Ну почему? Потому что просто каждый элемент участвует в логарифмическом числе вершин.
Вот если у вас есть какой-то x, то в каких вершинах он лежит?
В себе, в родители, в дедушке, в прадедушке и так далее. Их логарифм всего.
Значит, суммарно, каждое число лежит всего лишь в логарифмическом количестве списков,
значит, суммарно памяти у нас n лог n. Это не очень страшно.
Все классно?
Дальше. За сколько это можно построить? Скажите, пожалуйста.
Потому что каждый элемент x лежит всего лишь в логарифмическом количестве списков,
потому что если у меня есть некий x, где он лежит, он лежит только там, в тех вершинах, которые его контролируют.
А это путь до корня, а их логарифм.
Поэтому каждое число лежит в логарифмическом количестве списков, значит, суммарный размер всех списков это n лог n.
У меня n элементов в каждом логарифме списка, всего n лог n.
Как?
Да.
Да, да, да.
Значит, более того, это не только n лог n память, но еще и можно построить за n лог n времени.
Потому что, как правильно сказали, что если у нас есть список для левого сына и для правого сына,
то для родителя можно эти списки за линейное время смёрживать,
потому что у нас здесь отсортированный список и здесь отсортированный список.
Мы их можем за линейное время склеить и ответ положить сюда, то есть merge, как у нас было в merge-сорте.
То же самое, по факту, я просто два списка отсортированных склею в один отсортированный и кладу его вот сюда.
Это делается за линейное время от размеров списков.
Поэтому сколько памяти столько времени.
По факту я напишу так, что на самом деле то, что мы сделали, это в каком-то смысле дерево merge-сорт.
Дерево-рекурс и merge-сорт.
Потому что в корне у меня будет весь отсортированный массив, в левом сыне корня будет левая часть массива отсортированная, в правом правая.
Ну и так дальше, если вы отвечаете какому-то куску массива, то слева его левая отсортированная версия, справа правая.
Но это в точности merge-сорт, он ровно так работает.
Весь массив бьёт на две части, сортирует лево, сортирует правую и потом их за линейное время склеивает.
То же самое мы и сделали здесь.
Поэтому время построения тоже N log N.
Ну а теперь ответ на запрос остался.
Я утверждаю, что здесь в худшем случае ответ на запрос будет log2.
Потому что опять можно как себе это представить.
Смотрите, нам пришёл отрезок LR.
Мы сначала его покрыли логарифмическим числом вершин WDO.
Мы помним, что каждый отрезок разбивается на логарифмическом количестве вершинок.
И дальше в каждой вершине мы можем с помощью bin поиска найти количество элементов не больше, чем x.
Поэтому log2.
Сейчас картинка будет.
А ещё раз, вот здесь у меня отрезок LR.
Мы знаем, что если запустить наш обычный обход, который идёт туда, куда имеет смысл,
он разобьёт весь наш массив на какие-то подотрезки.
Такие, что каждый подотрезок – это на самом деле просто вершины в дереве отрезков.
Их будет логарифмическое количество.
И дальше в каждом из них, в каждой вершине, у нас на самом деле хранится отсортированная версия вот этого куска массива.
То есть у меня есть посорченный этот список, посорченный этот, этот и этот.
Значит, в каждом из них, если я просто запущу bin поиск, я узнаю, сколько элементов не больше, чем x.
Значит, здесь bin поиск, здесь bin поиск, здесь bin поиск и здесь bin поиск.
В каждом из них я узнаю, сколько элементов не больше, чем x.
Всё, складываю, получаю ответ.
Значит, по бинарному поиску в каждой вершине.
Значит, получается как раз log2.
Да, потому что логарифм – вершина, и в каждой ещё bin поиск, который ещё за логарифм работает.
Согласны?
Ну, отлично.
Не-не, у нас как раз, мы храним отсортированные версии.
У нас в каждой вершине хранится отсортированная версия вот этого отрезка.
Мы так делаем. Вы же сами говорите, что мы делаем мерч с детей.
То есть у меня в каждой вершине хранится массив, равный вот этому после сортировки.
То есть у меня есть вот это после сортировки.
То есть вот здесь хранится массив чисел, равный вот этому после сортировки.
Да, то есть мы ниже этих машин не идём, и в каждом из них…
То есть у меня здесь какой-то список чисел,
который равен вот этому после сортировки.
Здесь bin поиск, то есть ниже я не спускаюсь.
Здесь bin поиск, и здесь, и здесь.
Ниже я не спускаюсь.
Так, ну давайте за 5 минут ещё одну идею скажу.
Как можно здесь скостить лог квадрата до логарифма?
Давайте на примере это сделаем.
На примере это сделаем.
На примере это сделаем.
На примере это сделаем.
Это тоже называется fractional cascading.
Это следующая идея, смотрите.
Вот здесь вот мы действуем в каком-то смысле неоптимально.
Мы в каждом месте запускаем бинарный поиск.
Давайте мы вместо этого сделаем следующее.
Мы будем хранить доп информацию.
Значит, а именно, давайте на примере каком-нибудь.
Представьте, что у меня были два массива,
которые я склеивал с помощью мерча в один большой.
1, 2, 3, 4, 5, 6, 7, 8.
Давайте мы для каждого числа,
в каждом векторе, который мы вот строили,
то есть у меня в каждой вышине хранится список чисел,
давайте вектор я его назову.
Для каждого вектора,
давайте я буду хранить в обоих списках,
то есть в обоих сыновьях,
в каждом векторе,
в каждом векторе,
то есть в обоих списках,
то есть в обоих сыновьях,
наибольший элемент, меньше либо равный, соответствующий ему.
То есть вот у меня есть большой список,
1, 2 и так далее 8.
Давайте для каждого числа будем хранить стрелочку,
точнее две стрелочки,
в левого и в правого сына,
на наибольшего, меньше либо равного,
чем мы.
То есть 1 будет ссылаться здесь,
сюда и сюда,
потому что здесь нет ни одного меньше либо равного единицы,
мы будем указывать сюда.
2 указывает на единицу и на 2.
3 на 3 и опять-таки на 2.
Ну и так далее.
То есть вот если я для каждого элемента храню две стрелочки,
на самый большой, меньше либо равный,
слева и справа,
как вот здесь, давайте продолжим.
4 ссылается на 4 и опять на 2.
5 на 4 и на 5.
Ну и так далее.
То есть еще раз, х ссылается на наибольший,
меньше либо равный х.
В обоих сыновьях,
здесь и здесь.
Наибольший, меньше либо равный х.
Это легко сделать в то же время,
что вы делаете мердж.
Потому что что такое мердж?
Он у вас имеет два ассоциированных списка,
хранит по указателю здесь и здесь,
выбирает каждый момент меньшее из чисел,
записывает его сюда,
и сдвигает указатель туда.
И вот в тот момент, когда вы одно число переносите в большой список,
вы как раз эти стрелки можете спокойно поставить.
Одна стрелка это тот самый элемент, который у вас только что пришел,
ну а другая это стрелка на предыдущий элемент,
потому что здесь содержится что-то большее,
вам нужно предыдущее.
То есть просто когда вы их склеиваете,
вы эти стрелки автоматически узнаете.
Вы знаете, скажем, вот здесь было 4 и 5,
вы перенесли сюда 4, значит четверка сама себя меньше либо равна,
а здесь, ну пятерка уже больше,
поэтому стрелка нужна на предыдущий элемент.
Ну зафайте.
Вот.
Понятная идея?
Мы вот храним такие стрелочки.
Значит в каждом векторе у меня будут стрелочки влево и вправо,
влево и вправо сына для каждого элемента.
И тогда,
вместо того, чтобы упускать бинпоиски
независимо в каждом из детей,
я мог в то же время,
когда я шел от корня до них, до всех,
поддерживать, то есть я мог на самом деле
один раз запустить вот здесь вот, я могу найти
элемент меньше равный х,
самый большой элемент меньше равный х,
и дальше просто по стрелочкам идти.
То есть дальше я всегда, когда спускаюсь в сына,
я знаю,
наибольший элемент меньше равный х.
Здесь пятерка перенесла в четверку, здесь в пятерку.
Потом опять перехожу в сына,
я знаю,
какой элемент наибольший меньше равный х.
И вот во время, пока я спускаюсь
от корня до всех этих вершин,
из которых регура себя ниже не идет,
я могу поддерживать сразу же указательно
наибольшее число меньше равный х.
И дальше стрелка мне говорит, куда идти.
Если идешь влево, иди сюда,
если направо, иди сюда.
И тогда мне даже не нужно будет пускать бинпоиск
в каждой из этих вершин. У меня уже
сразу будет храниться указатель, то есть я
буду поддерживать указатель на то место,
на тот элемент, который наибольший меньше
равный при этом х.
Значит мне нужно всего лишь
один раз запустить бинпоиск в корня,
бинпоиск в корня,
а потом вниз идти по этим
стрелочкам, которые у меня все
хранены.
На наибольшее число, не больше х.
Все, спасибо.
