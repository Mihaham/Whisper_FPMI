что мы сегодня будем обсуждать, да, вот мы сегодня будем обсуждать эмоциональный
анализ, то есть у нас еще одно такое занятие будет на не столько алгоритмы, хотя надеюсь
сегодня ближе к концу у нас будет сегодня такой алгоритм, где мозг придется немножко повзрывать,
вот, но сейчас немножко фундамента, потому что вот вы уже упоминали кучу фибоначи,
а на самом деле там изучать кучу фибоначи без четкого знания того, что такое эмоциональный
анализ, к сожалению, невозможно, вот, ну потому что о чем вообще речь, вот, но речь идет о
следующем, вот почти наверное вы все сталкивались с такой реализацией очереди, как очередь на двух
стэках сталкивались даже на 6 стэках сталкивались. Так, а ну-ка, кто сталкивался с очередью на
двух стэках, кто сталкивался с очередью на шести стэках? А кто писал очередь до шести стэках,
ух ты, здорово! Очередь на декартовых деревьях. Заметит, понятно, хорошо, ладно, значит,
вам сегодня будет немножко скучно в какой-то момент. Ну что делать? Смотрите, как же у нас
устроено, давайте вспомним, очередь на двух стеках. Устроено это примерно следующим образом. То есть у
нас есть два стека. То есть в один мы кладем элементы, в другой из другого мы достаем
элементы. То есть у нас вот в каждый момент времени типа сколько-то элементов тут,
сколько-то элементов тут. Если приходит запрос положить элемент, положить в очередь,
прошу прощения, то мы кладем в этот стек. Если пришел запрос вынуть элементы,
достаем из этого стек. Но важный момент. Что делать, если оказалось, что этот стек оказался
пустым, а вы из него хотите что-то достать. И при этом выяснилось, что в стеке И что-то так и есть.
Что делать? Ну тогда в этот момент мы быстренько, насколько можем, перекладываем все элементы из
этого стека сюда. Вот, то есть слету технология может показаться не тривиальной, но вот, хотя,
как показывает Амаяк, Акапьян, Спокойной ночи, малыши, на самом деле просто стеки надо класть
немножко по-другому. То есть на самом деле стек нужно вот стек ин класть вот так, а вот класть
вот так. И еще вот тут покрасть. Тогда вот оказывается максимально наглядно, тогда видно,
почему действительно эта реализация действительно реализует очередь. Вот, то есть единственная
проблема, что тут где-то в очереди у нас такая дыхка и приходится искусственно перекладывать эти
элементы отсюда-сюда. Да нет? То-то и прикол, что нет. Смотрите, что... Нет, нет, смотрите внимательно.
Ну потому что, смотрите, стек, видите, дно стека у ин находится вот здесь, а у аута находится здесь.
Поэтому выглядит так. То есть если тут стек стал пустым, а тут лежат элементы, допустим, там,
я не знаю, один, два, три, четыре, пять, семь. Вот. То в принципе, чтобы очередь сохранялась, нам
нужно положить их так, чтобы они тут тоже были справа, там, слева направо. Один, два, три, четыре,
пять, семь. Что для этого мы делаем? Достаем элемент семь и кладем его сюда. Потом берем
элемент пять и кладем его сюда. Вот ведь просто часто достали из стека, положили в стек и так далее.
Все, так что тут получается без вопросов. Один, два, три, четыре, ура. Так что с порядком тут прям все так,
как как раз нужно. Да, ну в общем, действительно, достаточно простой такой веселый алгоритм,
вот. Но у него есть маленький недостаток с точки зрения анализа. Вот. То есть если мы, например,
хотим сказать, за какую асимптотику работают его операции. Да, вот мы как раз в прошлый раз
изучали, что такое асимптотика, да. Вот. И вот спрашивается, за какое время мы можем положить
элемент в такую очередь? Казалось бы, да. Да, за от единицы, действительно, без вопросов. Да,
четенько, за от единицы. Вот. А за какое время мы можем достать элементы из такой очереди?
А вот. Ну вот. Ну вот. То есть формально на текущий момент можно сказать, что точное время там
действительно от, там условно, там один плюс количество элементов в ине, если не повезет. Ну,
так, да. Ну вот, а в худшем случае мы такое можем оценить только как у отн. Потому что может
так случиться, что вы реально будете n элементов перегонять из стека им в стека, и ничего не
поделать. Но тогда еще у нас верхняя оценка на операцию поп у отн. Тогда получается, что n
операции с такой очередью мы делаем за отн квадрат. Вот из такого простого анализа получается
н квадрат. Зачем нам такая очередь? Неужели мы лучше не можем реализовать? Вот. Но оказывается,
что действительно, да, как иногда модно говорить, не все так однозначно. Что тут неоднозначно? Ну вот,
потому что кто-то заметит, что на самом деле в некотором смысле суммарно это будет работать за
линию. Или, как еще говорят, иногда в среднем это работает за 1. Тут разные словосочетания
применяются. Ну, что имеется в виду? А имеется в виду следующее, заметим шо. Заметим шо, да,
мы перекидываем какие-то элементы, но с другой стороны заметим, что с каждым конкретным добавленным
в эту очередь элементом мы делаем О от единицы операции. Даже не от единицы, а просто 3. Ну там
не более трех. А именно мы кладем этот элемент в stack in, перекладываем его из stack in в stack out
и достаем из stack out. Ну, в других редакциях можно считать, что там, конечно, мы за две операции
его достаем из иной и кладем в out, но это уже мелочи технически. То есть с каждым конкретным
элементом мы делаем О от единицы действий и тогда получается, что если мы дам дана пустая очередь и мы
делаем н операции, то суммарно они могут быть сделаны за О от н. То есть выполнены за О от н. То есть
стандарты. То есть что получается? То есть получается, да, одна конкретная какая-то операция может
работать долго, но суммарно они работают быстро. Вот такая вот интересная диспозиция. И замечаем,
что стандартным анализом, когда мы просто оцениваем каждую операцию сверху, мы такое
адекватно исследовать не можем, потому что тогда мы вот такие возможности упускаем. То есть да,
это, конечно, не идеальность, действительно определенная там определенного рода. То есть
в некоторых местах такие алгоритмы запрещены, потому что в некоторых местах иногда там
разрабатывается какой-нибудь там процессор совсем, там какие-нибудь базы, там мелкие какие-то вещи,
там зашиваются только алгоритмы, которые работают железо-бетона. Потому что там вот принципиально,
чтобы там каждая конкретная операция делалась вот зафиксирована, за там какую-то фиксированную
долю секунды. Но чтобы не было такого, что раз миллион операций она зависнет. Не потому,
что она поломалась, а потому что там вот это, но потому что тут кто-то там вот перекладывал
какие-то элементы. Но тем не менее такие приемы иногда имеют смысл. То есть иногда они сильно
расширяют возможности, поэтому нам потребуется в частности куча фибоначий. На самом деле будет
хорошим примером именно такой вот амортизации. Поэтому что мы будем делать? Вот поэтому нам
придется вести некоторую теоретическую базу под это, то есть такой некий инструментарий.
Итак, амортизационная, как же мы это будем делать? Ну вот на самом деле на примере очереди
двух стеков мы будем это демонстрировать, как мы будем мыслить. Ну точнее терминологию,
то есть рассказать как конкретно вы будете мыслить мне, конечно, сложно. То есть каждый все-таки по
своему будет мыслить. Вот у кого-то конечно есть мечта, чтобы все вышли и мыслили одинаково,
но как бы сомнительно. И так, чего, что значит? Ничего не значит. Понятно. Значит смотрите,
и так амортизационный анализ. Но как можно решить такую ситуацию, анализировать? Но анализировать
на самом деле можно по-разному. Смотрите. То есть в принципе, да, ну обычно считается,
что давайте вот вообразим себе, что вот у нас есть там выполнена N операции и каждая работает
за какое-то время. Ну и там может быть оценка. Вот так сказать, вот допустим, оно там С2, С3,
С4, С5 и так далее. Вот. Да. Ну и тихо плана. Пока не поздно могу на Т поменять, надо. Давайте
это хорошо. Ну так ладно. В каких-то стандартных книжках на самом деле может быть С. Да, в роли
стандартной книжки. Книжка Бобенко-Левин. Там алгоритмы и структуры данных. Да, кстати,
давайте на всякие штуки сразу напишу, потому что какие-то там книжка, к сожалению, не самая
толстая, но какие-то интересные алгоритмы, причем с четким математическим анализом там есть.
Так что вот здесь могу очень. Ну вот. Вот. Какой из? Не-не-не-не-не-не. Нет. Нет, это не тот,
который теряем у Кука Левина там и так далее. Нет, там просто это. Это сильно более молодое,
это чуть более молодое поколение, конечно. Вот. Вот. А вот Максим Бобенко, да, тот самый. Вот.
Так. Так значит. И так. Вот, допустим, у нас какие-то времена, мы их будем звать реальное время.
Вот. Но нам, значит, ну, то есть наша цель на самом деле будет иногда, значит, найти такое более
экзотическую вещь. Мы это будем рисовать как там ТРИТЭ с крышечкой. Да, вот такой крышечкой.
Вот. Знаете, кто-то считает, что крышечка это такой польский режиссер. Ну, вот. Но у нас крышечка
будет вот такая. Не-не-не. Именно вот. Нет, там польский там какой-то. Там это Гжегж крышечка,
что-то в этом роде. Не, ну ладно, это я от балды сказал, конечно. Ну ладно. Так. Ну вот. Вот.
Значит. Но зачем он нам понадобился? Вот. Такие крышки. Значит. Что это такое вообще? Что это за
Т с крышечкой? Вот. Это вот что. То есть это у нас некоторое ученое. То есть это так называемое учетное
время. Значит. То есть это тоже как бы время. То есть мы будем говорить, что у нас как бы
там время работы, там третья операция была вот такое. Но, конечно, с реальностью оно может
сильно расходиться. Но с реальностью оно может очень сильно расходиться. Но, на самом деле,
причем в разные стороны. Оно может быть меньше реального, а может быть и сильно больше. Но,
на самом деле, конечно, чтобы... Ну какие-то, что мы тут можем нарисовать? В принципе, мы эти Т с
крышечкой можем нарисовать какие угодно вообще. Можно просто заявить, что там дикартовые деревья
работают в завод единицы. Или там, что еще там бывает? Фу, я тоже самый завод единицы
работает, вы знали? Вот. То есть просто. То есть это из цикла сказать можно все что угодно. Можно
там сказать, что время бывает отрицательным, там что-нибудь еще и так далее. Ну вот. Ну и сказать,
что оно. А время работы деревоотресков зависит от фазы луны. Там, например. А дикартового дерева
нет. Вот. Можно. Поэтому отрицательный вопрос. То есть нужны какие-то естественные ограничения,
потому что это же должно быть как-то связано вообще с жизнью и нам как-то полезно. Поэтому в идеале нам
бы хотелось, конечно, то есть на это учетное время поставить следующее ограничение. Что хочется,
чтобы для любого и было верно, чтобы сумма t житых с g равно от единицы до и не превосходила t с
крышечкой. Вот. То есть так. То есть видите, мы здесь, конечно, не требуем, чтобы каждая конкретная
крышечка была больше своего бескрышечного собрата. Но мы хотим, чтобы сумма на префиксах
учетного времени оценивала сверху реальное время. Вот что нам, собственно, хочется. То есть какие
возможности это нам дает? То есть в принципе это нам дает возможность на самом деле это время
накапливать. То есть чтобы это работало. Как мы тогда будем действовать? Каким образом можно
эти учетные времена назначать? То есть это наша такая мечта. Но есть три конкретные, ну то есть по
разному можно время назначать. То есть там действительно как-то. Но есть три такие стандартные
технологии или там способа мышления. В данном случае просто такие вот очень известные.
Ну в общем-то да. Более того самое смешное, что иногда крышечкой бывают даже отрицательными. И это
нас даже не сильно пугает. Сейчас вы увидите почему. Ну не сейчас может быть, но в целом. Хотя
если у вас там получится отрицательный, ну господи замените его на единицу и как бы хуже не
станет. Вот. Но иногда вот бывает хорошо. Потому что бывает тут следующее. Значит,
способы анализа тут такие. Так, давайте я это сотру. А то прям большенькие ощущения, что это
способы анализа прям Бобенко-Левин и придумали. Хотя, хотя да, я уже запамятовал на чем я в этом
месте базировался. Но возможно, кстати, на этой книжке и базировался в этом месте. А ну пока и
мере про третий способ, который мы вот до которого мы дойдем. Точно вот на них базируется. Значит,
смотрите. И так значит способ номер раз. Способ номер раз называется анализ в среднем. Вот мы
сегодня уже упоминали это слово сочетание. Но здесь на самом деле сразу предупрежу может быть
маленькая двусмысленность. То есть в нашем курсе на самом деле понятие в среднем может нести два
смысла. Второй из них это в вероятностном смысле. То есть там допустим у вас вероятность алгоритм и в
среднем будет означать, что математическое ожидание времени работы равно там чему-то там. Вот. Но
как бы мы сейчас вообще не говорим, например, о вероятности. Да, то есть у нас алгоритмы
детерминированы абсолютно. Там детерминированная, там на всех случаях непараллельная. Там если что,
ну мало ли. Вот соответственно. И анализ в среднем у нас будет означать следующее. То есть нам на
самом деле мы просто скажем, что t и t с крышечкой это будет равно какая-то оценка на t1 плюс t2 плюс
и так далее. Плюс обратите внимание n поделить на n. То есть тупо говоря, то есть мы говорим,
что, ну то есть это анализ такой, самый такой. Так как мы еще раз. Называется дубаломно-прямолинейный.
Вот вспомнил. А то сразу в голове straight forward. Вот в голове сразу. Вот как вот. Вот это да.
Да, дубаломно-прямолинейный. Вот самый такой. То есть мы говорим, что нам не интересно,
каждая конкретная операция, давайте думать, как они будут работать в сумме. Как это работает в
очереди на двух стеках? В очереди на двух стеках, так как мы говорим, так вот мы сделали n операции.
Значит в очередь было добавлено не более чем n элементов. И с каждым из этих элементов было
проделано не более чем от единицы операции. Там три или там четыре соответственно. Значит,
получается суммарно эти операции были выполнены за отn. А в среднем, в среднем, в среднем каждая
операция делается за от1. То есть вот так вот можно проанализировать в среднем очередь на двух
стеках. Нет, обратите внимание, мы взяли все n, у нас даже и t, вот эта учетная стоимость зависит
от n, видите. То есть обратите внимание, то есть я среднеархметически беру не префикс, а именно
всего. Так, ух ты, подляночка, действительно подляночка. Действительно, то есть в целом это
действительно у нас работает, но вот такому требованию действительно не удовлетворяет.
Хотя парадокс заключается, но вот, хотя просто в этом месте на самом деле просто,
но в этом месте такой формализм не заморачивается. А во-вторых, на самом деле просто есть в тот момент,
когда у вас выполнены и операции, на самом деле учетные стоимости оказываются другими. Потому
что когда вы сделали и операции, тогда у вас как бы n равно и, и у вас среднеархметически берется
вот, то есть как бы они как бы, получается, что они так это модифицируются. Да, но на самом,
но вот, нет, ну в принципе, наверное, да, ну хотя в идеале на самом деле хотелось бы именно такого,
но да, хотя, конечно, да. Хорошо, ладно, давайте, ладно, сделаем так. Хорошо, сильное условие,
давайте сделаем так. То есть давайте, можно ввести так, сильное условие такое, а есть просто
слабое условие. То есть слабое условие будет говорить, что действительно сумма по всем g равно
от 1 до n, g меньше либо равно суммы g равно 1n, tg с режиссером. Вот, и так, хорошо, да,
то есть такому слабому оно действительно удовлетворять будет, хотя, может быть,
в общем случае, может быть, так часто бывает, что этого может оказаться и достаточно, на самом
деле. Потому что, по большому счету, когда вы примете амортизационный анализ, на самом деле,
вам нужно гарантирует, так, ладно, у меня там это, так, массив длины n, там что-то q запросов,
и мне нужно просто выполнить эти q запросов за адекватное время. То есть в принципе вот этого
хватит, то есть вот этого на самом деле вам хватит. Вот, и так, значит, да, но так или иначе,
действительно такой вот анализ среднем, то есть он действительно, то есть он, может быть,
технически самый простой, но с другой стороны, каждую там структуру, на самом деле, такие,
как кучу фибоначили, там сплей дерева тоже самое, то есть, конечно, анализировать в таком виде не
получится. То есть сейчас у нас просто получилось, что мы, у нас очередь на двух стеках достаточно
простая структура данных, на которую мы просто сумели посмотреть просто сверху и там все о ней
понять. Ну вот, во всяких сплейах так, конечно, не получится прямо сверху посмотреть. Вот, значит,
какие тут еще есть вариант. Значит, метод второй. Так, давайте-ка я лучше... Ой, тут я все-таки
стирать буду. Так, потому что тут вы все равно записываете. А, и камера записывает, так что,
неважно. Итак, смотрите, метод второй называется метод бухгалтерского учета.
Вот. Или метод монетки. Вот. Ну, по-разному, на самом деле, на самом деле... Ой, дай бог поймите. Не знаю.
Вот. Ну, на самом деле, да, можно просто так. Метод монетки. Значит, он предлагает... Ну,
честно скажу, на самом деле, в разной литературе будут разные интерпретации, поэтому вот. Вот,
но у меня интерпретация такая. Смотрите, значит, что мы себе добавляем еще одну сущность. Помимо
того, что мы во время работы делаем какие-то действия, у нас появляются монетки. Эти монетки мы
иногда получаем, а иногда тратим. Вот. То есть, такой вот интересный способ нот. Но при этом,
значит, за что мы платим? А платим мы за то, что мы говорим, что некоторые действия... Вот за
некоторые действия мы платим монетку. И что это значит? Это означает, что мы эти действия не считаем.
То есть, вот такой чит. То есть, значит, как это выглядит на очереди из двух стеков? Как это
выглядит? А вот как. Значит, идея такая. Значит, вот у вас стек есть in и есть стек out. Да. Мы
по-прежнему добавляем элементы в стек in, но, внимание, к каждому элементу скотчем
прицепляем монетку. Вот. Какую-то монетку. Идея следующая. Что такое монетка? Монетка
это то, за что можно оплатить, собственно, переезд на другую сторону вот этого вот стикса. Вот. На
этой вот рейке. То есть, мы как бы оплачиваем. То есть, когда мы перетаскиваем элементы и стакаем
стек out. То есть, за перетаскивание каждого элемента мы эту монетку платим. То есть,
когда элемент попадает в стек out, то есть, монетки у него уже нет. Но за то получается,
что мы больше за это, но за то мы как бы эти действия как бы игнорируем. Вот. Но тогда,
если мы игнорируем, тогда получается, что все действия здесь выполняются за от единицы. Вот.
Но оказался конкретно в таком виде, конечно, это может выглядеть подозрительно. Потому что
можно сказать, а почему мы только одну монетку кладем? Давайте там сразу по миллиону долларов
на каждую эту класть и все оплачивать. Все. И тогда все будет бесплатно. Вот. Жалко, да. Да,
это да. Но, к сожалению, да. То есть, ну ладно. Наверное, скорее к счастью, конечно, чем к
сожалению. У нас компьютер в такую коррупцию пока не умеет. Потому что мы не можем просто там,
потому что сам по себе компьютер, там сам по себе компьютеру деньги не нужны. Вот. Да и, в общем-то,
идеальной математике, в общем-то, тоже. Но общий чит здесь заключается в следующем. Да. Он
заключается именно в том, что мы не сильно много монеток вообще получили, не сильно много монеток
получили. То есть, можно, в принципе, свести это сразу к анализу в среднем и сказать, смотрите,
что у нас как бы на каждом шаге от единицы неоплаченных действий. Да. Это значит, то есть,
суммарно у нас получается от неоплаченных действий плюс действия оплаченные монетками. Да. Но здесь
есть два важных момента. Первый. Это вот важный принцип, без которого вообще никуда. Мы никогда
не тратим монеток больше, чем получаем. Да, вот это вот важный принцип. Да, в долг мы не работаем.
Да. Чего нельзя? Нет, крит. Ну, кредит нельзя. Да. Не, ну там, можно там теоретически, наверное,
брать какой-то контролируемый кредит, конечно, но... В каком смысле мы их получаем, если не приклеены к элементам? То есть, мы получаем... Ну, то есть, да. Да, но в каком?
Мы их получаем. То есть, когда мы получаем новый элемент, мы как бы вместе с ним получаем монетку. Ну, это
как когда вы посылаете там, собственно, какое-то письмо в конверте. То есть, вы как бы клеите на него
марку. Это типа... Да, конечно. Ну, и самого элемента еще нет. То есть, условно говоря, нам на почту как бы его
как бы кладут. То есть, тем более, что мы его даже особо не кладем, потому что мы в данном случае это
такой вот черный ящик, в который есть как бы два окошечка. То есть, в одно окошечко нам подсовывают
элемент, который надо добавить, а в одном там это кладут, там жмут кнопочку, и мы должны там
другое окошечко выдать элемент. Вот. То есть, как бы элементы, они как бы даже не берутся от нас.
Как более того, мы даже толком не знаем, какие сами эти элементы. То есть, вы это будете особенно
хорошо понимать, когда будете там на C++ изучать шаблоны. Вот. То есть, видите, нам же не принципиально,
что это такое сами элементы. Инты, даблы, там, поинты какие-нибудь, там еще какое-нибудь
безобразие. То есть, нам не принципиально. Вот. Как бы мы просто сидим, мы сидим в черном ящике и как бы
думаем. Это, кстати, вот очень удобный способ программировать сложные задачи. Вот зачем эта
все опешность нужна. То есть, очень удобно, что ставить свою сложную программу как набор вот таких
черных ящиков. Потому что каждый черный ящик четко себе прописал, что я умею делать вот это,
все больше я ничего не умею. Тогда внутри черного ящика вы думаете, как это обеспечить,
а вне черного ящика вы думаете, как им пользоваться, но вы не думаете о том и о другом единовременно.
Чего можно? Ну, как сказать? Ну, как сказать? Нет, ну, все в этом мире можно использовать. Да,
понятно. Это уже, конечно, что-то из цикла надо уничтожить компьютер, потому что существует там
в котором эти наркотики продаются. Да, ну, мы сейчас изучаем, как строить алгоритмы. Да,
любой инструмент, конечно, понятно. Ну, тут, да, понятно, классический инструмент. Тут, конечно,
как про какой-нибудь хирургический скальпель, которым, в принципе, можно тупо там пырнуть и
убить человека, а можно, в принципе, наоборот, там спасти ему жизнь. Да, ну, или там, понятно,
классические примеры, тут нет смысла остановить. Да, ну, мы сейчас как бы, да, ну, мы сейчас
занимаемся тем, что изучаем инструментарии, значит, поэтому смотрим. Итак, значит, первая, значит,
идея, что с одной стороны, что мы никогда не тратим монет больше, чем получаем, а во-вторых,
оказывается, что мы не так много монеток и получаем, а именно, мы получаем одну монетку
на один добавленный элемент. То есть, за n операции мы получим не более, чем n элементов. И тогда
из этого следует, что суммарные n операции делаются за o от n. То есть, в принципе, на самом деле,
бывает достаточно помыслить это так. А можно поводить и четкие такие учетные времена,
но так, чтобы было совсем красиво. В данном случае, смотрите, то есть, в данном случае мы
будем писать так. Значит, t и t с режиссером равно t и t без режиссера плюс, ладно, не будем заморачиваться,
плюс p и t, минус q и t. Что это такое? Нет, это не потенциал, потому что метод потенциалов это
другой метод. Ну, потому что это не совсем оно, потому что, в принципе, это может так оно и будет,
потенциал это немножко другое. В этой технологии потенциал это, сколько у тебя сейчас денег в
кошельке лежит всего. А это не то немножко, потому что здесь я пишу, что p и t это сколько получили,
именно прямо сейчас. Сколько нам выдали, да. То есть, сколько нам в черный ящик монеток поступило.
И минус q и t это сколько потратили. Что ж там? Почему нет, наоборот. Нет, в этом смысле,
что мы когда тратим монетку, мы как бы не считаем действия. Вот ровно поэтому здесь
минус сик. Это важно. Вот. Ну вот, то есть, здесь тогда, но тогда обратите внимание, то есть,
если у нас поддинот, тогда вот зачем нам нужно вот тогда, что к чему нас приводит вот это
требование, что мы не тратим монеток больше, чем получаем. То есть, в принципе, тогда отсюда следует,
что действительно там действительно сумма этих t житых с режиссером у нас равна чему. То есть,
она равна сумме, значит, вот так вот t и t, там t житых, плюс сумма p житых, минус сумма q житых.
Вот. Получается так. И что мы тогда имеем? Ну вот, но есть, но в принципе, что означает,
что мы никогда не тратим больше, чем получили. Это означает, что на каждом шаге, на этот раз,
на каждом шаге, обратите внимание, у нас тогда вот это вот больше либо равно вот этого. То есть,
отсюда получается, что это больше либо равно сумме, чем g равно 1 и t житых. Вот. То есть,
вот получается на этот раз вот так, даже вот сильное условие выполнилось. Вот. То есть,
вот такой способ оценки. Или на самом деле, в данном случае речь идет даже не столько об оценке,
сколько о перераспределении. То есть, по большому счету, да. То есть, это что означает? То есть,
вот давайте внимательно посмотрим, за что получается выигрыш. То есть, вот, например,
у нас вот операция push в реальности работает за единицу времени. Ну,
вот. А pop у нас работает за 1 плюс. Чего? Ну, не совсем. Ладно. Правильнее. Ладно,
давайте, чтобы не путаться, писать так. Обычный pop работает так, а pop с перетаскиванием,
он работает за время. Ну, давайте, скажем, 1 плюс там 1 плюс к. Ладно,
просто букву напишем. Хотя да, k это размер ина, да. Вот. То есть, в реальности это происходит так.
А теперь давайте посмотрим, значит, каково у нас вот это вот учетное время.
Ну, давайте посмотрим. Тогда каждый push добавляет нам одну монетку. Тогда у нас
получается учетное время работы два. Да. Ну, это работает. Нет. Ну, не идеально. Ну, там,
понятно. В данном случае стараемся поточнее писать. То есть, это просто важно. Понятно,
что это единица, конечно, но вот. Но, как бы, чтобы понимать, откуда у нас что. Значит,
получается поп. Значит, поп за что работает. Но он, на самом деле, просто достает монетки,
не меняет монетки, он не трогает никак. Значит, поп с перекладыванием. Вот это последнее выкладывание
действительно один. Но, в общем-то, и все. Потому что вот эти, значит, мы новых монеток не получаем,
но, наоборот, ка монеток тратим. Поэтому остается вот этот вот один. То есть, видите, да. То есть,
действительно важный момент, что действительно оказалось, что вот учетное время работы здесь
вот у Пуша больше. И это, в принципе, нормально. Потому что, да, может, как бы, эта магия, на самом
деле, не создает никаких новых действий и, наоборот, не уничтожает ничего. То есть, она их,
на самом деле, перекладывает. То есть, по большому счету, этой махинации с деньгами мы сделали очень
простую вещь. То есть, мы, на самом деле, вот эти вот ка действия, которые мы сделали,
они никуда не делись. Мы их просто разложили, на самом деле, по ка Пушам, по большому счету. Вот,
видите, да. То есть, получается, в принципе, это может быть скрыто, потому что, если я напишу
асимпатически, получится, что реальное время работы от единицы, учетное время от единицы. И,
потом, вот единицы, вот единицы. Попс с перекладыванием от 1 плюс ка и тут от единицы. Да, я тут пишу 1
плюс ка, пускай может быть нулем, а от нуля это так себе. Вот. И, как бы, может показаться, что я
просто каким-то там что-то помахал руками и что-то исчезло. То есть, куда оно исчезло? На самом деле,
просто вот эта, то есть, вот эта ошка, она просто более жирная. Да, я ее даже вот так вот нарисовать
могу. Да, вот жирная такая. Вот жирная ошка. Вот. Вот. То есть, на самом деле, это вот один,
ну вот, это такой, может быть, самый удобный метод с точки зрения думания. То есть, потому что вот
очень удобно думать. Видно, так, давайте тут кладем там что-то, какие-нибудь монетки. Может,
иногда там начинаются какие-нибудь махинации в духе, даже что мы монетки иногда не тратим,
а начинаем их куда-нибудь перекладывать даже. Вот. Вот. Соответственно. Все уже сложно пошло, да?
Вот. Вот. То есть, вот тут такая радость получается от единичной радости. Вот. Ну,
то есть, вот это всякое такое. То есть, вот мы действительно в основном, может быть,
этими монетками начнем пользоваться. Вот. Но есть и третий метод. Третий метод. Он у нас,
то есть, это метод, его чаще можно найти в каких-нибудь статьях, потому что он может быть,
как бы, наиболее красиво помогает формализировать анализ. Вот именно, чтобы красиво, формально это
все записать. Потому что, в принципе, можно как бы на монетках там, скажем, в какой-нибудь там
мягкой куче, например, действительно, все там тоже на монетках. Ну,
вот. Нет. Вопрос способа мышления. Да. То есть, идейно-математически суть может одна и та же,
но как бы просто, как удобно мыслить, просто как удобнее мыслить. Вот сейчас давайте я тогда
веду этот третий метод. Смотрите. То есть, как бы, суть сейчас будет очень похожая, но как вы будете,
значит, смотрите. Значит, у нас было вот такое. Значит, третий метод у нас называется метод потенциалов.
Вот. Вот.
Значит, что это такое? Значит, мы здесь начинаем мыслить в следующих терминах. То есть, мы начинаем
мыслить в терминах, что у нас между какими-то, между операциями есть состояние. То есть, какое-то
состояние системы. И это состояние будет характеризоваться мистическим числом фи. Но
обратите внимание, мы начинаем их там нумеровать с нуля. Там фи 4, там фи 5. Там и тут вот фи. Это
значит фи это число, которое мы будем называть потенциал. Вот. Спасибо. То есть, это вот потенциалы.
Вот. Значит, мы будем говорить следующее. Вот. То есть, это может быть вот такой потенциал,
может быть какая-то энергия накапливающаяся. Значит, формально пишется так. Требования к
потенциалу такие. Требуется, чтобы, во-первых, значит, требования, значит, все фи больше
либо равно нуля, для любого и. А вот нам так удобно мыслить. И второй смысл, что фи нулевое,
оно должно быть равно нулю. Вот. То есть, вот такие требования. То есть, чтобы хочется вводить
потенциалы так, чтобы они были вот такие. И тогда, в этом случае, мы начинаем говорить. Мы начинаем
говорить, что у нас TGT. Такие так. TIT с режиссером равно TIT без режиссера плюс потенциал в конце,
минус потенциал в начале. Вот. Потенциал в конце, минус потенциал в начале. Вот. И так. Значит,
что же это такое получается? Вот. Ну, давайте посмотрим, действительно, насколько у нас тут
действительно там выполнены какие-то из этих условий. Вот. Ну, давайте вот проверим сильные
условия. Ну, тогда сильные условия. Получается следующее. Что сумма, значит, всех TG с крышечкой,
G равно от 1 до I. Она равна чему? Я даже вот сейчас сумму писать не буду, даже так проще будет.
Смотрите. T1 плюс phi1 минус phi0. Плюс. Значит, T2 плюс phi2 минус phi1. Плюс T3 плюс phi3 минус phi2.
Плюс и так далее. Плюс. Значит, T там и T получается. Плюс phi и T. Минус phi и минус 1. Вот.
Ну, здесь снова появляется наш любимый классик, который говорит нам шлёп-шлёп. Шлёп-шлёп. Шлёп-шлёп.
Ну, и в конце там вот такой шлёп-шлёп. Вот. Вот такая вот интересная идея. И это получается равно
T1 плюс T2 плюс и так далее. Плюс Ti. Плюс phi и минус phi0. То есть получается, видите, та же самая
суба на самом деле. Только плюс потенциал в конце, минус потенциал в начале. Вот. Ну, в принципе заметим,
что для сильного, ну вот. То есть для сильного условия на самом деле достаточно было бы,
просто что phi0 на самом деле минимальный среди всех потенциалов. Да, но да, потому что в принципе
в принципе, как и физики, в общем-то само значение потенциала нам важно не особо,
но нам на самом деле важна разность потенциалов. Вот. Да. Вот. Получается так.
А количество монет разве не является? Но на самом деле да. При правильном проведённом
методе бухгалтерского учёта количество монет у вас в кошельке суммарной является таким потенциалом.
Ну вот. Ну, обычно просто в таких терминах не очень удобно думать. То есть в данном случае
на самом деле просто вообще можно забыть о всяких монетках. Нет никаких монеток.
Просто вот всё. Никак. Нет никаких монеток. Никаких монеток нет. А вместо этого мы говорим,
что вот в нашем конкретном случае в очереди мы объявляем, что потенциал равен размеру стека
in в момент времени и. Вот так я напишу. Это у нас вот такой потенциал. Аж хочется упрямить
слово сочетание какой-то потенциальная энергия. Ну нет, смысл тот же на самом деле. То есть как бы
то есть мы как бы иногда накапливаем какую-то энергию на будущее. А потом, чтобы потом в нужный
момент стрельнуть. То есть. Ну вот. Ну вот. Вот. И так значит тогда давайте посмотрим как-то
значит получится ли при таком потенциале выжить. Ну давайте смотреть. Так. Значит давайте смотреть.
Получается примерно следующее. Значит учётное время. Значит учётное время. Значит пуш. То что
получается? Получается один, но плюс. Плюс что? Плюс потенциал в конце, минус потенциал в начале.
То есть какое-то если изначально было если в стеке было к элементов, то тогда в конце будет
их ка плюс один и тут минус ка. И получается это равно два. Нет. Один. Потому что в потенциал,
потому что то что мы достаём элементы стека аут никак не влияет на размер стека и. Поэтому
тут получается один плюс ка минус ка и это равно все еще один. Ну в принципе да. Но это нормально.
Сейчас вот давайте это допишу я вам даже больше скажу там господи там вы знали что там это
доставание элементов из двоичной кучи работает за ноль. Вот ровно по этой причине. Вот. Значит попс
перетаскивание. Значит у нас что тогда получается? Значит работает это за один плюс ка. Но. Значит
плюс потенциал в конце будет ноль. А потенциал в начале был ка. То есть опять пошлёп-шлёпали
получается единиц. Вот. Ну да. Тут видите. Очень удобно. Вот. Вот получается что мы так немножко.
То есть там получили там обнаружили возможность немножко поразмазывать операции и получил так.
Ну так то в принципе да. Ну да. Ну к сожалению да. Бывает. Я помню одна группа как-то там это
после. После очередного задания по линалу там просто вывел свое. Самый популярный метод
решения задачи тюрьмы групп. Заметим что. Вот не знаю. Ну не леда. Вот как-то да. То есть к
сожалению для этого приходится иногда отправлять интуицию в полет. Соответственно да. Но увы. Увы. Вот.
Но. Но тем не менее. То есть да. То есть конечно это правильно. То есть что конечно да. Это
конечно инструменты. Инструменты с которыми можно работать. Но конечно идею они не подменят. Да.
Тут ничего не поделаешь. Да. То есть это вот всего лишь терминологи. Вот. Но тем не менее значит
соответственно. Вот. То есть основные такие три. По крайней мере стандартных технологий. Но в
каждой из этих терминов можно мыслить. Потому что можно действительно подгонять потенциал каким-то
образом. Чтобы вот он сходился. Ну вот. Ну вот. Чаще. Вот. То есть можно там иногда посмотреть на
некоторые структуры. Просто сказать что там как бы в среднем все адекватно. Потому что вон там
адекватные элементы перекидываются. Но можно там чаще всего. Конечно бывает что лучше давайте
там класть куда-то монетки. С этими монетками работать. Ну на мой вкус это чаще всего там
оказывается удобно именно мыслить. То есть давайте так. Давайте чтоб это оплатить. Вот
так своего получается монетки. Так тут логарифм-монеток кладём в принципе. Да можно
логарифм-монеток. Клазь в принципе. И в общем-то мы будем этим заниматься на самом деле. Вот.
Вот, значит, соответственно. Вот, то есть это вот у нас такие три метода на простом примере.
Так, есть ли тут какие-то вопросы? Нету. Так, ну хорошо, тогда мы повысим планочку.
Тогда сейчас, ладно, раз уж мы тут написали очередь, а теперь мы изобретем вектор.
Ну, не этот, который есть стрелочка в геометрии, конечно.
А, конечно, имеется в виду структура данных вектов. Вот давайте думать, а что такое вектор вообще?
Да, а вот возникает вопрос. Что мы обычно, обычно хотим от вектора?
Ну, тут разные вещи, на самом деле, от него можно хотеть.
Вот. Более того, сейчас я сразу предупрежу. Да, тут такой парадокс, что мы сейчас захотим от него даже больше, чем от него реально требуют вы стоили.
И это, кстати, большая подлянка.
Да, нет, он там, скажем, ну я не знаю. Кстати, интересно, есть ли там требования по непереводным кусок памяти?
Нет, это, конечно, да.
Да, прям, в смысле, прям такое есть или? Нет, иметь в стандарте C++ такое прописано?
Ну, в принципе, ладно, наша реализация этому будет удовлетворять, потому что хранить их не подряд смысла, на самом деле, нет.
Нет, есть там, типа, чтобы корень из N дополнительной памяти был, а не N?
Ну, это уже, там, следующий вопрос. Ладно, сейчас это, как бы, мы сегодня пока все-таки еще попроще, попроще говорить, да.
Ну, там это корень из N дополнительной памяти, а типа, а типа, создавать только блок?
И прямо ее от единицы прям сходится?
А, ну в принципе, а, ну можно, ладно. Да, наверное, можно, да, хорошо, да, можно об этом думать, действительно.
Ну, значит, предлагается тут у нас следующее. Значит, какая технология? Значит, что нам хочется от вектора?
Значит, от вектора нам хочется, во-первых, операция, в первую очередь, видимо, pushback.
То есть, да, чем он отличается от обычного массива? Да, он отличается тем, что мы умеем пихать элементы в конец.
А еще умеем доставать элементы из конца.
И еще мы. Вот так напишем. В общем, какую-то адресацию.
Ну да, как вы вскоре узнаете, собственно, на парах. То есть, у вектора, на самом деле, вот к этому элементу можно обратиться с помощью квадратных скобочек.
А можно обратиться с помощью метода add. То есть, мы можем писать этот вектор .add и в скобочках и.
Это практически то же самое, но там разница только в том, что это безопасно, а это нет.
То есть, тут он прям в явном виде будет проверять и вообще попало там в размер от нуля до сайза, там минус один или нет.
Ну вот, и если не попало, то возопит. Вот. Ну да, как называется? Возопит будет выбрасываться там, ну и.
Ну terminate, короче. Нет, ну не обязательно. Нет, ну panic это называется там, ладно. Научно это называется кинет исключения.
Ну это, но там конкретные детали на эту тему действительно мы оставим вам на C++, там они будут там очень в серьезных подробностях.
Ну вот мы сейчас изучим математическую суть. Значит, нам хочется реализовать такую структуру данных.
Нам очень хочется, чтобы все это делалось за, ну в идеале вот считается, что вектор работает за от единиц.
Но спрашивается, как это можно было бы сделать, чтобы это работало за от единиц?
На самом деле сделать, конечно, ну какой-нибудь там относительно там начинающих репиагих точно скажут.
Ну и что, так давайте создадим там просто сразу массив там на там, там сколько вы операции хотите в задаче делать?
Миллион. Ну давайте создадим массив на миллион и в общем-то все. В общем-то даже там вот тебе pushback, вот тебе popback.
Вот. Но мы, наверное, хотим конечно структуру посильнее, потому что нам часто, потому что если бы нам, у нас был бы один массив вообще в жизни, то да, вектор создавать может быть даже не выгодно.
Вот может быть. Поэтому она нам хочется таких массивчиков создавать несколько.
Но если мы хотим создать несколько таких массивчиков, то у нас есть какие-то требования.
Требования у нас потому что есть не только по времени, но и по памяти.
Потому что нам бы очень хотелось, чтобы это жрало не очень много памяти.
Потому что если мы на каждый вектор будем класть сразу по миллионам, там выделять память на миллион элементов под каждый из векторов, а векторов у нас будет тоже миллион, то там, называется, мы погорим достаточно быстро.
Поэтому мы себе потребуем, то есть я сейчас веду такое требование, то есть в каждый момент времени у вас должно быть памяти.
О от текущего размера вектора.
Ладно, просто О от СЗ, я так не пишу. Да, не модуль СЗ, конечно, СЗ.
А, ну в данном случае можно просто О от САЙС написать, что я тут СЗ пишу.
А если мы докинули кучу всего, а потом выкинули кучу всего памяти.
Вот, а мы захотим, чтобы шринкнулось. Да, вот абсолютно правильно.
Вектор есть такая проблема, что если вы сделаете миллион пушбеков в том там миллион попбеков, то, к сожалению, память у него будет все еще выделена на миллион.
Все они уже научились?
Вот, я не знаю, в какой-то момент, на момент несколькой летней лекции давности, просто провели эксперимент и измеряли капасти вектора.
Ну сейчас скажу, что это такое.
И выяснилось, что он все плюс-плюс увеличивается, но не уменьшается.
И это подло.
Вот.
Поэтому оказывается, что мы сейчас, конечно, себе возьмем больше.
Но давайте сразу так перейдем к этому. Как же мы вообще действительно вектор строить будем?
Да, тут мы уже начинаем ругаться какими-нибудь словами, кто-то, возможно, их не знает.
Ну, собственно, и не должен знать, потому что, по идее, как раз вот я сейчас должен сказать, что это такое.
Ну, как вообще реализовывать вектор?
Ну, естественно, идея такая, что, да, но первая идея, конечно, говорит о том, что просто реализовать это так, чтобы все это было за вот единицы, это, ну, ладно, скажу аккуратно, науке неизвестно как.
Если мы имеем в виду, если имеем в виду честно, то есть, куда прям доказать? Доказательно невозможно.
Ну, скажем так, значит, не сильно много инструментария доказывает, что что-то невозможно.
Да, ну, скажем так, если пришлешь точную ссылочку, буду очень благодарен.
Ну, скажем так, если есть прям доказательства этого, то доказательства и пришлешь ссылочку, буду благодарен. Да, это очень интересно.
Вот так скажем.
Значит, ну вот, ну так как же нам реализовывать?
Ну, во-первых, конечно, первая идея заключается в том, такая идея номер ноль, что естественно мы говорим о амортизированной стоимости, то есть учетной стоимости.
Тогда какие возможности это нам дает?
Значит, это дает нам возможность следующий такой.
Ну, во-первых, вот это от size нам дает возможность говорить так.
Мы храним вектор в каком-то выделенном в памяти массиве. Это реальный абсолютно сишный массив.
Это выделенный через new.
Ух ты, молодцы, молодцы, да.
Ой, нет, ну это нормально, я сейчас плюс-плюс на продвинутом уровне никогда не изучал.
Ладно, хорошо.
Нет, ну с другой стороны, что делать? Ну хорошо там, хорошо там.
Хотя ладно, ладно, в реальном векте, кстати, вполне вероятно, что они там молок какой-нибудь забабахают.
Хотя нет, все-таки new. Хотя нет, new, потому что там будет стандартный аллокатор, стандартный аллокатор и все через new делается.
Вот, да, вот.
Ну да, то есть вы там, вы, конечно, там можете подсунуть свой, но это ладно, это уже там для, ну это, это будет на основном потоке там, продвинутом, все это будет.
Так что если, так что это если, если, если кто этого не знает, не пугайтесь, все будет.
Хотя с другой стороны, ну как, кто здесь из продвинутого потока по C++?
Да ладно, по C++, не по алгоритмам.
А, понятно, то есть, а, то есть прям корреляция прям такая большая, да.
Ну окей, хорошо. Ладно.
Ладно, ну в суть, в следующем. То есть мы заводим какой-то массив размера capacity.
Ну capacity, да. Ну понятно, capacity, yeah, capacity, yeah.
Вот. Ну по-русски это называется емкость.
Емкость.
Хотя, конечно, часто по-русски называют это capacity.
Вот.
Вот. Ну, что делать.
Да, capacity.
Значит, идея в следующем. То есть, то есть как бы это мы выделили, да, массив естественно называется буфер.
Значит, в начале этого массива хранятся собственно элементы.
И мы еще храним size.
Вот. Ну у нас как бы есть запас.
То есть, в принципе, вот мы в принципе аккуратненько, честно делаем.
То есть, если нам пришел pushback, то мы просто докидываем еще элементы, и как бы size увеличивается на 1.
Если мы захотим сделать pop, мы как бы просто size уменьшаем на 1, по большому счету самым элементом мы ничего не делаем.
То есть, вот до некоторого момента этого нам хватает.
То есть, в общем-то и все. То есть, на самом деле как-то не парадоксально, что вектор занимает всего 12 байт памяти.
Если вы это не верите, вы просто возьмите C++ вектор, вызовите у него size от него. Получите 12.
Ну потому что там в структуре данных всего 3 элемента.
Очень просто.
Значит, потому что в самом классе написано и там условно int, ну там не int.
Ну хорошо, хорошо.
Не указатель, это 8 байт.
Ну хорошо 24, легче стало.
Ну я не знаю, в каких-то версиях компилятора было 12. Мы тоже запускали.
SizeTekCapacity и значит там T, звездочка, буфер.
Все.
То есть, в общем-то по большому счету класс вектор устроен вот так.
Вот все.
То есть, просто size как бы он не будет лазить по указателю и смотреть, что там.
Потому что указатель, ну это, что такое указатель, это такая чиселка тоже.
На самом деле, такая же как sizeTek, просто она обозначает конкретно там ячейку в памяти.
Не более того.
Вот.
Да, вот такой неожиданный прикол.
Вот, но фишка конечно кроется не в самих этих полях, а конечно в методах.
Ой, а вы же на C++ узнали, что такое методы?
Да.
Да, когда вы, ух ты прям успели уже.
Нет.
Чего?
Нет, нет, я говорю не про методы, я говорю по C++.
Нет, ну нет, да-да-да, нет.
На первом занятии по C++ вы должны были там видимо изучать собственно сами там как минимум репетические операции и там что-то еще, да.
А Linux, да.
Да.
Да.
А Linux.
Понятно, ладно.
Ну хорошо, ладно.
Нет, ну ладно, это как бы все вы тоже там в ближайшее время изучите, собственно.
Никуда от этого не деться.
Вот.
Ну это ладно.
Ну интересно, да.
Ну собственно в методах серее, чем в операциях, нам придется кое-что прописать.
Потому что, да, то есть в принципе мы могли бы конечно так и жить, то есть эти pushback просто там двигаем size, popback двигаем size, квадратные скобочки автоматически реализуются, да.
То есть пишем там, то есть к этому указателю применяем квадратные скобки и не паримся, да.
Ну или можно к указателю прибавить нужное число элементов, в общем понятно.
Вот, но есть две маленькие проблемы.
Первая маленькая проблема.
Че делать, если буфер кончился?
То есть вы тут делали тут size, size, size, size, size, size, size.
Пушбек, пушбек, пушбек, пушбек, пушбек, пушбек, пушбек, пушбек.
Буфер аверфло.
Да, когда выслышишь, когда size равно капать, что в этом случае делать?
Нет, ну предлагается.
Вility.
что сразу плохого господи мы уже да но да да ой господи да заклинание значит
смотрите но идея такая есть у нас сайс равно кап значит если мы делаем в пушбеке сайс
равно capacity то есть вот допустим так оказалось то тогда идея такая что мы просто удваиваем
капость что значит удваиваем это означает шум и прям запрашиваем в памяти новый кусок в два
раньше и прям тупо перекопируем туда все имеющиеся элементы а старый буфер уничтожаем прям вот
уничтожаем вот то есть это как бы приводит с точки зрения как бы использование вектора это
приводит к подлянке в подлянке что если вы там завели себе какой-нибудь указатель или ссылку
на какой-то элемент вектора то помните что в любой момент это ссылка может инвалидироваться
то есть поэтому да то есть это особенность которую надо помнить
но пока ты ищешь я еще могу на самом деле писать у меня страшный прецедент на эту
тему был вот знаете я как-то в петерзаводске писал у конина вот и значит там почему-то он
получал хоть там runtime 35 или что-то в этом роде то есть пришлось там полдня если не день вообще
убил на поиске оказано вот причем было но вот причем более того в процессе на тусы начали
фантастическую вещь у меня там была какая-то строчка там значит вида вы и там условно там
там но диете там там но диет ну условно там но диете равно там что там было но но и там какой
какой-то там калк суфикс линкс или что там что-то в этом роде там от и вот так ну допустим вот но
фишка но вот я обнаружу что вот это да вот в этом методе то есть на кроме теста получается у меня
почему-то runtime но действительно я делаю что я делаю я делаю технически какой-то то есть я делаю
какой-то там дебаг там ну как сделать дебаг но вот там но можно можно его сделать там по
принципу там скажем вот можно вместо вот этого написать там скажем но диет этом равно там
еще не будь там принта например ну там принт там ты точку что-нибудь там и так далее и там
сказать там но диета равно ты но почему-то после этого значит выясняется если так же вот что
подобно так вот написать то почему-то бак перестанет бак исчезает по камерам тайма не
происходит а если написать да его действительно оказалась пишка следующая что как бы знаю да
если выставки с алгоритмом укрена то помните что эта функция на самом деле то есть на самом
деле добавляет новые вершины да ноде было вектором и оказывалось что видимо все плюс-плюс делал
следующий он вычислял ссылку на этот элемент перед присваиванием да потом запускал эту функцию
значит эта функция меняла ветра и это ссылка инвалидировалась согласен но материться все
равно не надо хотя вот сутью согласен полностью вот да то есть вот оказалось такое то есть
вот с вектором вот действительно есть такие подлянки действительно вот поэтому как бы надо
просто это иметь в виду вот так она вот только что но ты одна из причин но вот ну в данном случае
датам по бэков там не было поэтому вот но вот такой эффект вот ровно так все плюс-плюс работая там
все плюс-плюс и вектор работает поэтому вот будьте аккуратны там то есть поэтому старайтесь
лучше там не хранить указательный элемент вектора или ссылку но то есть понятно что если вы там
вектор один раз создали он вам больше никогда не нужен то пожалуйста но когда на самом деле лучше
стараться это делать не все-таки вот и так вот в принципе в общем-то на самом деле си плюс-плюс
вектор примерно так и работает в общем-то и все то есть при пушбеке если там куча с
копастью 2 копасти не пасть но дальше по бэк там двигаем влево там понятно квадрат на скобке все
в порядке но возникает маленькая проблема но вот в принципе да можно давайте еще подумаем
ну да ну да здесь мы будем по умолчанию считать что дарю что есть какой-то минимальный размер
копасти нет но на практике все да все что угодно можно там на самом деле там разные варианты есть
ну то есть понятно нет а практике наверное там выгоднее окажется не один элемент а все-таки
там 2 4 или сколько-нибудь что в этом роде на самом деле иметь там по мелочи но понятно не сильно
много конечно чтоб там можно было много векторов создать но понятно нет но в прочем есть разные
варианты потому что есть вариант как бы на самом деле если 0 то реально ничего не храним потому
что все равно все пушбеки по бэки в этом месте завод единицы будут делать как бы мы их не
реализовывали так что математически ничего не изменится вот соответственно вот поэтому
то есть это все на самом деле локальность вообще глобально давайте посмотрим а работает ли это все
завод единицы вот в виде какой-то амортизации но давайте попробуем в этом убедиться всеми
тремя способами покоя вы всеми тремя способами то есть у нас сейчас задали нам сейчас хочется
отработать три способа вот давайте первый способ попробуем значит первый способ говорит нам о том
что мы где нот то есть то есть первое что мы хотим как-то посмотреть на это все среднем то есть
там в общем дай посмотреть сколько суммарной операции было выполнено вот но давайте представим
себе что мы выполнили n операции и capacity у нас стало равно чему ну capacity стало равно c тогда
давайте посмотрим заметим что все операции кроме вот это вот пересоздание буфера да кстати тут есть
на самом деле умное слово реаллокация вот от английского я локation ну ну и между прочим
не лишено между прочим сходство действительно я релак да но это вот тут все-таки пишется
именно так уж там ри элокейшн нот ри элокейшн ри элокейшн да
нет ну что такое имеет смысл
нет нормальный стэкс ну я бы сказал что нормальный стэкс
конечно но там датчик позже мы об этом поговорим кстати там как как реализовывать стэки на самом
деле там там разные спецэффекты тоже могут быть вот ну да а то мало ли тем более нам
персистентные стэки еще понадобится когда-нибудь о персистентный стэк с двуличными подъемами
вот значит ладно значит смотрите давайте вы начать какие операции мы суммарно за вот есть у нас
там было вот был у нас пустой вектор сделали мы с ним эн операции там pushback вот и там вот
эти квадратных скобочек но заметим что все кроме реаллокации мы делаем за от да но теперь давайте
думать за какое время мы делали локацию но последний шаг когда буфер стал реально ц мы сделали
за время ц о ц правда перед этим он соответственно был ц пополам и созда и тогда получается
реаллокацию в него мы тоже наверное делали за ц пополам перед этим было там цена 4 цена 8 и
так далее это не превосходит 2 ц ну короче от ц но это равно отн почему потому что так как
легко заметить у нас в каждый момент времени ну кроме там но то в каждый момент времени реальный
сайта то есть обычно capacity не более чем в два раза больше сайза ну кроме может быть там вот этой
ситуации когда сайс равно нулю вот то есть тогда получается что все реаллокации суммарно выполнены
и но то все остальные операции делаются за единицу но вроде все хорошо вот понятно
да понятно идем дальше вот но вот как но вот но что еще можно делать можно изобрести монетки
спрашивается как нам изобрести монетки да когда как нам почувствует сколько настроения то
вообще нормально спасибо вот так как-то она вот так как там как нам почувствует себя центробанком
да вот но центра да ну ладно мы тут центробанка все они чувствуют что мы как бы деньги из воздуха
не создаем хотя а вы думали в этом смысл нашего предмета да неожиданно вот ну ладно нет я бы
сказал так да мы не задумываемся о том откуда деньги берутся на самом деле да ну нет ну как
да мы считаем что да мы в черном ящике и говорим что давайте с каждым или в этом и
что-нибудь говорим а говорим мы следующее значит медбукал церковь учета будет говорить так так
пожалуйста если вы хотите по пушбэркать элемент дайте его нам пожалуйста вместе с монеткой
о господи в черном ящике находится сергей собягин ухлос пудина и что сразу что да не
но так ладно все это сейчас мы спаковать сейчас подумаем нет ну тут вопрос какая монетка
валюту-то мы можем выбирать но в принципе смотрите давайте подумаем так тихо тихо тихо тихо
но скажем так молок может работать за сколько угодно на самом деле но фишка в том что мы
делаем не только молоко еще и перекопируем но в этом мы верим что все-таки он адекватен нет
понятно что да вот видим ну да ну тогда он не работает нет вот там так я не знаю по-хорошему
нет понятно даша скорее там он может решить алгоритм какой-нибудь работать да но вот но но
я не знаю в этом месте конечно да верно оголок и мы верим что действительно выделить вылить
массив за n можно за там отэн да ладно не скажи извини если мы внутри программы потребовали
выделить новую память то это время нашей программы да так ну а таких деталей я уже
не готов обсуждать ладно ладно значит смотрите в любом случае если n тогда вот идея такая давайте
то есть давайте положим мы будем класть на каждый элемент монетку и тогда к тому моменту да
иногда у нас бывает pushback но ничего страшного значит означает что там монетка куда-то исчезла
вот нам несут и несут несут и несут и в результате когда у нас пришло время делать
новое capacity у нас уже образовалась capacity пополам монетки то есть вот capacity пополам
монетки да тут у нас как бы монеток не было вот и тогда идея что мы вот за эти capacity пополам
монеток должны выполнить получается операцию превративую там удвоить capacity вот ну здесь можно
подумать ну по разному да потому что но нет почему нет ну 6 непонятно почему виды 6 там вот 2 или 4
можно думать но смотрите за capacity то есть у нас сейчас у нас capacity пополам монеток и ну вот а
нужно получить массив размера 2 capacity поэтому с этой точки зрения и там можно по-разному думать
то есть как бы слава богу валюту мы подгоняемся как бы вопрос то есть можно говорить о том скажем
что там какую ценность мы придаем этой монетке то есть условно там это там рубль там допустим или
там доллар или там евро вот то есть другой способ конечно поменять валюту это сказать что ну
мы вместо одной монетке полут действительно давайте две монетки класть вот как нам предлагали
или четыре монетки то есть ничего страшного то есть как бы главное то есть как бы каждая
монетка она должна просто то есть она должна оплачивать фиксированное количество действий но
это фиксированное количество может быть один может быть два может быть три может быть 53 так
что но но это просто главное что это оно как бы не менялось бесконечное число рост процесс and
она всегда фиксировалась вот то есть это как бы но это как бы в любом случае
константа потому что по факту да то есть нас устраивает что у нас есть это от
capacity монеток которые мы за которые мы делаем значит это от capacity операции
как оно-то конкретная константа это уже на самом деле вторичный вопрос если не
третичный вот то есть вот с монетками оказывается очень удобно то есть это вот
то есть это символизирует но чем очень удобно все это то есть конечно важно
прописать себе вариант а что после что важно что важно прописать что после
реаллокации каждый раз у нас сайса то ровно половина capacity но но вот и никаких
монеток у нас нет вот то есть мы этим пользуемся то есть мы знаем что до
следующей реаллокации значит вот как минимум вот тут вот стоит вот столько
операции будет вообще-то монетки так а теперь внимание вопрос теперь а как же
нам это решить если мы хотим это сделать методов потенциал ну-ка давайте
вопрос какой потенциал предложить
ну на самом деле да тогда ну давайте попробуем сейчас ну так но разные
варианты но давайте хорошо фи там фи и ты присвоить значит capacity это
минус айс ну может быть умноженная на константу это мы так пока прописывать
не будем но для но скажем так чтобы это подогнать мы себе
мы себе скажем что если размер 0 то и capacity 0 а если сайс не 0 то capacity там
соответственно то есть если сайс равно 1 то capacity равно 1 но вот ну а если сайс 0 то
capacity 0 а во всех остальных случаях работаем вот по этой схеме вот так вот
значит поехали давайте вот глобальный случай тогда и рассмотрим так что у нас
тогда но что у нас тогда получается так ну давайте значит ну понятно значит
квадратные скоба значит там давайте начнем с простого квадратные скобочки у
нас реальное время то есть там реальное время 1 и учетное время 1 потому что
потенциал не меняется так по бэк а вот здесь интересно потому что заметим что
capacity не меняется а сайс уменьшается на 1 то есть получается смотрите 1 плюс
то есть был то есть потенциал в конце равен c минус там сз плюс 1 вот а потенциал в начале
в начале это с минус сз так ну что мы тут видим мы видим шлёп шлёп минус 1 хорошо вот тут шлёп
шлёп и тут шлёп шлёп так и что получается это равно 2 так но отлично то есть видим
видите то есть видимо по бэк нам действительно сохраняет еще лишнюю монетку это называется
но на самом деле мы ее как бы игнорируем но как будто так ладно давайте смотреть с пушбеком
там пушбек простой пушбек простой но здесь будет то же самое там 1 плюс ц минус значит
на этот раз сз плюс 1 и тут минус ц минус сз это 0 нет учетная стоимость
учетная стоимость получилось 0 вот вот то есть как бы получается до пушбек это то есть пушбек
мы делаем бесплатно если он простой так что же будет если у нас будет пушбек прям классический
с реаллокацией так но давайте смотреть что же у нас получится он будет работать за ночь
реальное время работы у нас сколько ну допустим ц да вот ладно ц плюс 1
значит пота значит потенциал в конце будет 2 ц минус сз плюс 1 потенциал в начале ц минус
так так ну что шлеп шлеп у нас вроде где-то есть да вот ну шлеп шлеп где-то есть я даже
не но я правда давайте для аккуратно я его даже не здесь сделаю а вот здесь так но сз
у нас пошлепалась и получилось у нас осталось сколько у нас осталось 2 ц у нас осталось да у
нас единички тоже пошлеп шлеплись так ну да видишь ну да казалось бы да действительно тут
потенциал не работает и даже да если я тут скажу что он работает не ц плюс 1 времени 4 ц плюс
один цер튜�й не поможет вот да да да там да да очень хотелось чтобы каждыйgardы
пуш увеличивал потенциал действительно они уменьшал поэтому да действительно оказывается
хорошо работает у нас действительно потенциал действительно 2 size минус capacity
ну хорошо да
я хочу сделать сейчас по меньше действий маркера
ну как сказать
нету на самом деле просто да такой потенциал на погребе но нету смотрите давайте думать
но здесь тогда получится так ладно сейчас не буду прописывать но мы видим что потенциал при
аккуратном при полбеке меняется на 1 правда поэтому если потенциал меняется на 1 в ту или
иную сторону неважно да и где и реально в реальное время вот единицы тогда понятно и учетное время
вот единицы не проблема да с пушбеком без релокации тоже то же самое изменение там вот от единицы
реального действия там вот единицы изменения потенциал так а теперь вот это вот а тут вот
это вот именно при реалокации но при реалокации получается следующее давайте вот здесь здесь тогда
получается что 2 size минус то есть реальное время цеплю с 1 значит модуль получается значит
значит потенциал в конце у нас получается какой то есть условно там 2 с плюс 2 минус 2 с
ну заметим что с из-за привод пушбеке на самом деле при реалокации там бывший то есть бывший
это одно и то же поэтому я тут для декатности цепишь и минус потенциал ну какой тут был потенциал
ну да тут было 2 с минус ц значит тут получается шлёп шлёп тут получается шлёп шлёп и тут
получается шлёп шлёп равно 3 давай
сейчас ничего не понял к чему просто не понял то есть смотрите нас учетное время
да 2 цена получил и чего ну нету какие-то выводы сделать можно но просто это как бы
не идеальное использование метода просто то-то просто смотрите просто тут еще как бы то то есть
когда мы с вами допустим разговариваем да при этом вот видя это все аккуратно то да мы
там можем себе позволять полностью потому что мы друг друга поймем но в общем науке обычно там
говорят вот да но структура данных которые делают у которой учетная стоимость вот такая да и понятно
что-то там они там будут вам прочитать то есть это будет означать что там либо у них потенциал
хороший либо у них с монетками все сойдется но вот но как бы обычно учетная стоимость будет тоже
вот там все-таки будет фиксировано что-то все операции учетная стоимость имеет за от единиц
вот так но в данном случае дает релокации видим что такой потенциал действительно релокацию уже
вот единицы отправил ну потому что мы как бы за отце значит сделали релокацию и еще
одну операцию потратили на собственно пушбек да нет можно было даже по-другому проанализировать
можно было сказать что учетная стоимость релокации там например 0 вот тогда бы у нас вот этих
троечек не было то есть у нас то то есть на самом деле можно ответить что там троечка в данном
случае это учетная стоимость самого пушбека вот это ну в принципе это очень удобно когда
оказывается что мы можем что мы когда делаем какую-то операцию она оказывается бесплатной вот
это прям красиво вот мы будем много с таким сталкиваться вот в том числе и вот то есть
просто начинает с той же кучи фибоначи на самом деле вот так что получается такая радость вот ну
в принципе да вот вы стояли это работает так но мы заметим что требования у нас конечно к вектору
сильно больше потому что вот это условие не выполняется потому что мы можем заметить что
если мы сделали как вы уже начали говорили миллион пушбеков и потом сделали там хотя бы там
есть это там почти миллион по бэков но там оставили где-нибудь там 5 элементов то там
память будет остается порядка миллиона и это нас не устраивает поэтому нам придется усилить
век но как-то сделать мы будем обсуждать после перерыва и так что же делать как же нам добиться
того чтобы у нас была какая-нибудь адекватная память нет резервировать-то не обязательно но да
но в принципе да то есть каши классическая идея тут визика и действительно простая что а давайте
вот давайте будем говорить что если у нас совершенно случайно сайс оказался слишком
маленький например капасти поделить на 4 то давайте ка действительно буфер урежем но урежем не в четыре
раза а в два чтоб запас оставался то есть как бы вы поддерживаем ряд что после реаллокации у
нас действительно сайс это половина капасти вот но тогда возникнет вопрос
нет ну скорее четыре нас да ну можно и так ну почему-то по-разному можно то есть но то есть
но то есть целимся так что сайс всегда от capacity поделить на 4 до capacity после реаллокации
сайс ровно capacity пополам но внимание хорошо но если мы так будем делить то есть сокращать
capacity в два раза если сайс это четверть capacity но будет ли это работать за адекватное время ведь
ну давайте но давайте ладно раз уж потенциал давайте начнем с него вот давайте так вот начнем
с него так хорошо потому что но то есть если оставить тот же самый потенциал то в принципе
там скажем так то есть до вот этого момента в общем-то анализ не меняется но что делать если
у нас есть поп back реаллокейша реаллок так что у нас тогда в этом случае вот ну во-первых да была
нот да мы заметим что здесь у нас перед этим попом было получается размер с поделить так 4
плюс один потому что в результате этого попа случилась реаллокация поэтому получается пишем
цей делить на 4 плюс один значит поехали плюс так был у нас capacity так плюс модуль
2 ц поделить на 4 плюс 1 минус с это был нот нет стоп вру вру вру вру это минус это потенциал
это потенциал в начале поэтому его нужно вычитать а какой потенциал стал в конце он стал
модуль 2 ц поделить на 4 минус с пополам так и я что-то забыл что я забыл
да я забыл что при копировании в реальной стоимости тоже должен а нет нет нет я все учел
4 нет я все учел но оно оно как бы тоже вписывается по константе то ли в эту
единицу то ли вот в это цепа делить на 4 ну почему в данном случае free может работать и за
линию это будет нормально ну фрии мы ну если мы ну я не знаю можно написать но пэнтик как бы
проблема такая это как бы как бы константа но потому вот ну потому что почему нет с это как бы
capacity которое было непосредственно перед этим попом но вот сайда сайс перед ним был цепы дитя 4
плюс 1 вот остался поделить на 4 но и capacity стало цепь пола вот но у самого себе в этом
что страшного нету но вот нету можно по разному сказать нету как сказать нету есть но потому
что мы можем сказать что мы действительно работаем за единицу плюс отце поделить на
4 да вроде он вот может что-то я локусь у нас за цепи дитя 4 работает и считаешь что там
далее локация это как бы цены тоже работает за цепь дитя 4 умножить может быть на какой-то
константу например 4 вот так что это все локалишь ну и потом да то есть сразу скажу что мы могли
бы тут вместо цепи дитя 4 написать с и увеличить потенциал в 4 раза ну можно нету бред давайте так
напишем что у нас получит цепи дитя 4 плюс 1 значит что у нас тут так тут у нас получается в
скобочках у нас что получается там плюс точнее так минус в скобочках цепь пополам минус 2 если
правильно понял да я правильно понял а тот будет плюс 0 так и получается очень получается что-то
там отрицательное а именно минус с поделить на 4 минус 1 но то есть да хорошо плюс 3 так плюс 3
вот если цель очень маленькая может быть это выйдет это тройка даже вытащит это в плюс да да
если церковно 4 например или там церковно 8 еще садится нормально да ну в принципе да тут и
очень интересно видите учетная стоимость может оказаться отрицательной да но на самом деле пугать
нас не пугать нас это принципе не должно можно принципе это но то есть как бы вот то есть как
бы главное то есть как бы мы-то точно знаем что у нас все суммарно на самом деле все работает
поэтому ничего страшного ну может и так нету как среду божьей но может так выйти потенциал это
энергия такая да то есть это вот у нас такая такая такая энергия что мы там иногда начина капливаем
энергию на то иногда тратим ее на то чтобы там не страдать на больших операциях вот но в данном
случае оказалось что действительно мы потратили то есть в данном случае видимо
может оказаться что мы потратили может быть даже больше энергии чем на самом деле требовалось но
по большому счету это вот ровно это значит то есть по большому счету да то есть просто у нас вот
там выплеск оказался больше чем чем мог бы быть но обычно тут нет с Això что-то под burg є так
ширисы вот так что получается вот такой вот то есть вектор так и в более идеальном мире мог бы
быть но на самом деле там по-разному конечно можно его делать это можно делать в два раза
если хотите экономить можно это то есть на самом деле в принципе абсолютно там подобный анализ
можно провести если бы компасе увеличилась не в два раза например в полтора то есть в принципе
любая константа больше единицы тут могла бы работать вот аналогичным примерно образом на самом
деле вот так но это был метод потенциал так а где у нас нот а теперь давайте посмотрим как бы
это могло как бы бог выглядит этот анализ в виде монет монетки это же просто производные
нет ну да но как бы тут вопрос в способе мышления да то есть давайте посмотрим как
это выглядело бы если бы тут клали монетки но здесь просто монетки надо класть чуть-чуть
похитрее но чтобы совсем красиво было надо говорить так что если вы делаете pushback
но здесь есть граница то есть у вас такая вот есть вот это вот граница на копастье пополам есть
вот это вот граница на цепы 4 тогда идея такая если вы тогда идея тут такая да то есть то есть
идея такая то есть как бы у нас равновесное состояние когда сайс находится вот в цепы пополам
да и тогда идея такая то есть мы как бы должны накопить энергию накопить вот этих вот монеток
так чтобы вот на операцию их хватило вот тогда идея действительно такая то есть как и ранее то
есть если мы делаем pushback и элемент кладется справа от этой границы мы как бы кладем монетки
там по две монетки например ну и там если шоу вычеркиваем но начитай изначально видим что тут
конечно элементы есть но если мы решили там но если мы начинаем делать по бэки и вычеркивать
здесь элементы мы на каждое вычеркнутое место обретите внимание не на сам элемент она вычеркнутое
место кладем по 4 монетки например вот да а если делаем наоборот pushback значит получается у нас
образовались лишние монетки которые просто выкидываем вот да правда как и наоборот если мы делаем
по бэк отсюда то как бы и монетки которые лежали на элементе мы тоже выкидываем вот то есть как бы
монетки не пригодились это называется но получается действительно что когда мы дойдем
перед этой границы у нас будет получается гарантируется ц лишних монеток которыми мы
оплатим ц шнуре локацию а если мы дойдем до сюда то мы получается у нас здесь будет на пустых
местах лежать ц монеток которая то на которой мы тоже все прекрасно оплатим почему
ой ну это давайте шутку инфляции это до шутка в данном случае пляца компьютер стал медленнее
ну не оно там уже другое там там там уже немножко другие механизмы поэтому там
такой степени аналогии могут не работать вот но так в принципе нету как сжигают но на
самом деле нет монетки как бы да они на самом деле не сжигает это просто символ того то есть это
на самом деле определенный символ перекидывание элемент то есть как бы дал меня если я локация
но я как бы эту локацию могу распределить то есть это что-то типа то есть это что-то
похожее на анализ среднем может быть да потому что можешь карман но если переходить к анализу
среднем то обнаружим что целиком мы на этот раз поглядеть на это все не можем правда то есть
как ранее мы не могли сказать что там суммарно все реалокации работают за какую-то арифметическую
про там геометрическую прогрессию которая там куда-то там сходится увы в данном случае не
получится но примерно в среднем можно было бы говорить так что рассмотрим момент то есть
рассмотрим действия между реалокациями то есть заметим что реалокация то есть если у нас массив
размера с превращается во что-то то мы можем заметить что во первых любая реалокация будет
следующее делаться за за тета от цевремени в чем не оценивать это от цеды а с другой стороны мы
заметим что что что на этот раз важно что до этой реалокации будет будет омега от ц операции
правда на этот раз не тетасе а именно омега цеп потому что их конечно может быть тут сильно
больше вот этих вот тут тудым-сюдым колеблется этих всех вот поэтому поэтому получается поэтому
получается что действительно можно перераспределить эти суммы так что в среднем было вот единицы
Но идеального анализа прям совсем такого, как говорится, дубаломно-приблинейного не получается.
Вот. Так что вот такая вот у нас красота с вектором. Так, ну что, есть ли тут какие-то вопросы?
Нет. Нету? Так, ну хорошо. Так, ну ладно, тогда, видимо.
Господи, слушайте. Слушайте, как здорово, по-моему, это, как говорится,
по-моему, впервые в жизни. По-моему, впервые в жизни вообще какое-то поколение студентов
с нетерпением ждет либо ночевому кучу. Нет, ну нет. Нет, я очень рад, на самом деле,
потому что структура данных действительно очаровательна. Это да. Вряд ли, если честно.
Хотя нет, ладно, нет, у вас проблем, на самом деле, это не вызовет по одной простой причине,
там в кормании есть хоть на псевдокодену реализация. Так что никаких проблем.
Ну как бы, да. Как это названо?
Тебя пустят на открытую Олимпиаду? А сейчас, а сейчас уже нельзя? Офигеть,
ну я знаю. Нет, ну будем честные, знаете, там, ну куча фибоначи, в общем-то, не то, чтобы сильно
используется на практике, на самом деле. Просто, ну там, ну и что, помогает? Тут, как бы,
проблема в том, что у него константа так жигновато немножко, поэтому, да. Ладно. Чего?
Ой, слушайте, аис. Ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, ой, о
чё хотелось так ну ладно
так ну ладно значит смотрите так ладно давайте так так так так так так так
так ну ладно так ладно давайте-ка обсудим быстренько все-таки этот алгоритм
на самом деле чтоб домашнее задание было целостным так нет да не не за задачей
будет сильно более простая называется называется ка партишн
но там это просто первая задача в домашке поэтому значит надо быстренько
обсудить по-хорошему да стоило это дело там в едином занятии про сортировки вот
но я просто не я просто не верю что как бы очень хочется сегодня сейчас перейти
к персидентам структуры там немножко персидентных структурах и поговорить
про эту персидентную очередь но честно скажу я не могу гарантировать что мы как
бы после этого еще что-то успеем обсудить потому что там структура будет
действительно мозгов взрывательная да ну это очередь на шестерке на шести
стэках вот это да нет ну стэк мы тоже обсудим там можно там есть но пока мы
катенька поговорим про задачу ка партишн об чем задача начинать очень
простая да но дан массив из n элемент вот что это за элементы мы не знаем то
есть можно вообще себе воображать что такие камешки и все что мы умеем это
сравнивать их что такое сравнивать это у нас есть супер весы в чем это совершенно
весы мы имеем право класть на каждую чашку весов только по одному камешку значит весы
вообще не двигаются при этом но при этом на экранчике появляется информация о том кто
из них меньше вот ну так и быть напишет а это для того чтобы на глаз не определять это прям
вот чуть-чуть меньше или прям вот ну совсем меньше вот так но по хорошему я конечно должен
был бы сказать что на самом деле это просто у вас есть просто черный ящик который принимает
обход два камешка и говорит верно лишь что первый из них меньше другого да это называется
компаратор кстати одинаковая но будем для простоты считать что нет ну как нет но
пащет не особо принципиально на самом деле ну давайте нет давай давайте так нет я утверждаю
нет смотри ты просто за нет он будет работать если ты нет если брать рандомный алгоритм то он
будет работать если ты просто там когда будешь выбирать ты больше ты не просто будешь говорить
кто меньше кто больше еще и заодно посчитаешь сколько равных вот их там тоже себе возьмешь это
тоже в принципе нормально нет отдельная кстати висеть и просто вести если мы получаем
что равно просто ну можно так да потом нет а там разный прикол нет а сам не дайте в качестве
упражнения на самом деле зайдет на каких-нибудь собеседуе могут дать такую значит отречь вот
кстати лада об этом но нет принципе об этом на самом деле лада раз уж об этом заходит речь то
в принципе на самом деле бывает это там есть задача в украинском флаге украинском ну ладно
ну если хотите можете о польском пожалуйста вот значит смотрите задача такая но то по сути
там задача такая там данные то то есть вам дан массив и да и дан и да но допустим да но
какой-нибудь число икс вам нужно переупорядочить элементы в этом массиве так чтобы слева были
элементы меньше икса справа больше их ну там больше либо равно но важная фишка это нужно
сделать завод единицы памяти дополнительной памяти то есть никто нету никаких считываний если что то
есть да понятно что есть соблазн конечно завести этот массив считывать и записывать куда надо это
да но нет то есть фишка в том что вот представят то есть больше себе представят что вас там есть
То есть фишка в том, что вот представить, то есть можете себе представить, что у вас там есть функция, которая переслала вам по какой-нибудь ссылке, значит, вектор, или даже массив по указателю.
Вот вам нужно, используя от единицы дополнительной памяти, в этом же массиве переставить элементы.
То есть внутри, среди вот этого, как меньше х, это как бы без разницы в каком порядке, с этой стороны тоже без разницы в каком порядке.
Ну, типа просто итеративно начать строить, ну, хранить границу, где у нас уже построена область меньше, где у нас построена область больше или равно х, когда мы видим, ну, мы идем, ну, идти одновременно по праву, область и по слову, ну, как бы.
Да, ну...
Не, ну, просто идем, а на момент, кстати, мы находим оба элемента, которые нет.
Ну, пора, да, так, так, придите, вы уже, да, вы уже говорите о два разных решениях, на самом деле, да, вот.
Ну, то, действительно, пора, да, можно, потому что у меня в голову, потому что есть, конечно, классическое решение, которое обычно пишут, когда кто-то пишет quicksort.
Решение там, там и в результате код, вот сейчас прям, так, попробую паскаль немножко вспомнить.
Давайте.
Господи, ты кудил на паскале?
О, классно.
Нет, нет, ну, как сказать, нет, значит, объясни ситуацию.
Дело в том, что я был, я учился, значит, в такие стародавние времена, когда, значит, паскаль еще был полноценным олимпиадным языком.
Ну, то я просто, у меня год поступлений, год поступлений на пистерии в 2009.
В те времена Геннадий Короткевич там на паскале межнарный выиграл.
Да, господи, сейчас, да, сейчас я современно уже начинаю забывать, кто такой Геннадий Короткевич.
Да, кто такой Петя Митричев уже не знает, видимо, уже вообще никто там.
Кошмар.
Не, ну, понятно, что ладно, там, хотя ладно, человек, хотя нет, просто Петр Митричев, это чемпион в кошмар, там, по-моему, и два линии 2000 нового года.
Да, более того, он был тогда единственный, кто решил там эту эпическую задачу.
Нет, там была, да, в кошпе дали такую просто абсолютно эпическую задачу.
Сейчас, а, симпатичный узор она называлась.
Ну, вот это классическая, то есть, с какими способами можно раскатить табличку N на M так, чтобы в два цвета, так чтобы не было одноцветных квадратиков, два на два.
Походу, да, до того, как это стало мейнстримом.
Ну да, нет, видимо, перед этим, видимо, тогда ее придумали, собственно, составители контеста.
Вот, но это, да, это, конечно, но, как бы, да, сейчас понятно, сейчас это уже классика, которую всем расскажут еще одна, но в 2000 году, в кошпе такое дали, вот он, вот его команда это решила.
Ну, в общем, они тогда, по-моему, в кошпо, они там, по-моему, второе место на две задачи порвали, по-моему.
Ну, правда, чтобы, по-моему, там, времена такие были, что это был счет семь пять, по-моему, а контест был вообще на восьми задач.
Была, была, какая-то была.
Или там скачивали тесты?
Нет, нет, нет, нет, тогда что-то все-таки, по-моему, уже было локально, то есть, нет, когда-то это все-таки, когда-то еще в девяностые, да, на чемпионате мира ICPC, действительно, там люди с дискетами к жюри бегали, это да.
Ну, понятно, что учитывая, что чемпионат ICPC вообще, видимо, там считается начало своей истории семьдесят седьмой год вообще, но, правда, все времена, правда, там не участвовали команды со всего мира, это был все-таки чемпионат Фисте, там все-таки это не все американский.
Да.
Нет, ну, кстати, Фистех, в общем-то, относительно недавно даже в этом все участвовал, потому что там пошло расширение на мир, то есть, там, по-моему, впервые, там где-то в районе девяностого года, там, по-моему, впервые там участвовали представители, собственно, России, там, по-моему, это, по-моему, первыми были, там, ну, первыми вузами были, кто, не помню, не помню, кто из них был конкретно первый, но это были ИТМОС, СПБГУ и МГУ, соответственно.
То есть какие-то, ну, потом пошло, там какие-то медальки были, что-то там пошло, в результате потом, ну, как минимум, можно сказать, что в двухтысячном году там Андрей, там, собственно, Андрей Лопатин, Коля Дуров и там с двумя сакомандниками стали двукратными чемпионами мира.
Нет, во-первых, нет, в те времена уже три, хотя изначально было четыре, кстати.
Нет, ну, история была простая, потому что задача приехали программисты посоревноваться по программированию, но компьютеров тогда было, собственно, небогато, и вот я обнаружил, что их было сильно меньше, ну, ладно, давайте, пусть они поделятся на команду, и вот, собственно, по числу компьютеров, в команде тогда было четыре человека, ну, потом как-то сошлось, что их, все-таки, в команде стало три человека, и вот с тех пор этот чемпионат в этом виде существует, вот, так что, да, весело было.
Вот.
Первая задача с полностью ослабленическим тестированием в девяностом году, что ли, была?
Наверное, да, потому что, ну да, это вот какие-то точно девяностые годы, тем более, что там, да, то есть, это нет, ну, там, межнара, это межнара, это отдельная песня, конечно, да, хотя прикольно было знать, что была вообще сборная Советского Союза, на самом деле, по информатике, кстати, ну, видимо, последние пару лет, но была.
Вот.
Как она выступала?
но вот но как-то вы как-то выступала господи не помню но не помню так настолько
глубоко ладно неважно это все ладно мы так ладно лирическое отступление все но
вот я просто пропускали на самом деле это все про эти рейдеры может и может и был
не знаю ну скажем так ну понятно что там крим за золотым призером и cpc он был
чемпионом мира не гарантирует но помота по моему золотая медаль 96 года cpc не
ошибаюсь может две я не помню вот то есть как это приезжайте на полуфинал вам там
фотки об этом обязательно покажут скорее всего потому что там потому что них он
выигрывал вот это было дело вот ну ладно я просто что пропускать вспомнил да
просто да чем паскаль отличается от всех остальных языков тем что там
устроенной сортировки нет нет хуже ее надо было сказать во время тура вот но
ничего страшного в этом не было потому что в этом месте писался код вот
примерно следующего содержание там вот так давайте л присвоить 0 нет ладно
нет пусть ежи все-таки вот ваил и меньше жи ду паскаль так паскаль беден нет
вот этот язык там в общем-то попаси то что практически идентичен сам по полу по
воду ли там это этого там по модулю какого-нибудь это контралаша вот так
значит что там дальше было значит ваил значит а вот так смотреть сейчас x присвоить а от значит
а и плюс а вот ой ну да если уж кусок писать тогда это вообще было вот так и равно l да
мы сортируем подотрезок от вот вот так это сортировка у нас так ладно что тут
чушь тут греха таить процедуре кусок вот да вот так не правильно еще тут надо писать
вар внутренний бодидаров значит и жи икс лонгинт боже упаси писать интеджер а то как бы
наделся будет работать она при паскали нет вот ну ой вот так да да ну вот да во-первых и в там
l больше либо равно r то exit да ладно вы что это реально записываете что так ну ладно не ну неважно
короче я тут вел переменные и жи икс как-то принято по паскальский написал там какой-то
типа если там l больше либо равно r то выбрасываемся сразу то есть там ничего
содержательного то есть содержательная часть вы видите собственно безмещерина вот
смотрите дальше происходит следующее так ваил получается значит дальше мы говорим
ваил а это но вот а это меньше икс ду инк от и это инкримент ну плюс плюс и короче не как-то
не странно я тут ничего не забыл нет бегин я не забыл что однострочный бегин для однострочного
вайла бегин энки требовался но вот в плюсах это было бы плюс плюс и да а ну
иф зен зен бегин значит ну короче свап а это житого инк и дек жи
энд и тут энд а я смог как там было иф и меньше эр зен зен у сорт от и эр иф а видим вот поэтому
вот этой гадость это не писалось я вспомнил да вот в принципе вот тогда классия классическая
классический кусок обычно пишется вот так вот тогда но единственное там конечно могло быть
отличия как-то раз на зачете в лкш подловили что такой кус что там все-таки подсунули теста на
котором этот кусок получает да потому что формально говоря а всем точка этого алгоритма
квадрат почему потому что вам может постоянно не вести и вы вы вот здесь будете выбирать минимум
есть нет есть именно поэтому как бы это как бы там как бы это тель превратился в окей быстро да
потому что рандом там есть я не помню как он пишется но значит он есть обрабатывает
она нет скажем так я но вот нет она их пока нет чего она прекрасно обрабатывает на самом деле
нет смотрите обратить внимание тут не случайно не строги именно строгие равенства потому что
мы где-то указатель надкнется на и extension тоже остановится так что то есть на самом деле поэтому
там если строить и ижи встретят два одинаковых элемента них тоже как бы посва Por Meter
пойдут дальше если и наткнется на меньше элемент а endure на ть на равный 1 на 그런 passing от
цена больше элемент ажин О종 ногт 임ф тоже по с clapprov Meow Fool дальше да по факту да то есть
То есть как там с равными действительно происходит действительно что-то там рандомное, там это да.
Чего? Вайл с дожи поставить?
Нет, ну смотрите, там логика такая.
Во-первых, начнем с того, что первая итерация вайла за...
У нас есть элемент равный х, поэтому за него нет.
Потому что х это элемент, по которому мы сбиваем массив.
Нет, смотрите, парадокс, но ничего ставить не надо.
Потому что, смотрите, на первой итерации вот этого вайла ничего не произойдет.
Почему? Потому что в этом массиве есть х, и и ж как минимум на нем и становится. Правда?
А после того, как произойдет свап, тогда оно всегда будет гарантироваться, что справа от и есть элемент не меньше х.
И слева от ж есть элемент не больше х.
Поэтому прежде чем они этих элементов достигнут, они как бы обгонят друг друга.
Поэтому выходов не произойдет.
Это действительно парадокс, я просто помню там в группе С ЛКШ, а когда-то давным-давно в ЛКШ была группа С.
Да ладно.
Сейчас стоят чиселки. В те времена были все просто.
Тогда можно было приехать в Д и учиться практически с нуля.
Но не совсем с нуля, то есть там на каком-то уровне язык стать надо было, но не на самом продвижении.
Чего?
Нет, П это промышленное программируемое, это вообще не об этом.
То есть это как бы не из линейки алгоритмического программирования.
Нет, ну была классная вещь, но это просто немножко не об этом.
То есть была и параллель М, где занимались чистой математикой.
Ой, ну ее переименовали, она была Z, она была 0 и так далее.
Ой, там...
Не-не-не, это было типа для межнаров.
То есть чтобы...
Нет, М это для шестиклассих.
Так ладно, я могу вам там отдельно рассказать, но я там эти байки могу рассказывать.
Там просто у нас пара закончится.
Там это просто...
Пуше как бы дай.
По свою бурную молодость я там могу, знаете.
Ой.
Пуше в конце концов, да, как бы это...
Ой, когда...
Да, это помню, еда был, да, я помню, был на всероссе.
Ой, какой там был футбол.
Ну и контест тоже прикольный.
Ладно, значит, смотрите.
Ну вот, ну нет, это вот паскаль, просто я помню, в группе целка шалатка.
Вот.
Нет.
Это мы тут немножко отвлеклись.
Ладно.
И сейчас пока скажу, что кусок.
То есть в принципе, что у нас тут делать?
По большому счету, вот эта функция до рекурсивных вызовов, она вызывает...
Она разделяет массив на две части.
На как бы меньшее кого-то и большее кого-то.
Ну то есть в принципе, почему задача называется...
Задача об украинском флаге.
Допустим, у нас есть нечто, которое берет элемент и говорит, он синий или желтый.
И тогда в принципе можно было...
То есть мы хотим перепорядочить элементы так, чтобы сначала шли все синие, а потом шли все желтые.
Нет, это не из учебника, это у меня из школы.
Когда я учился в школе, было нормально.
Вот, ну и сейчас.
Но на самом деле исхода была...
Но исхода на самом деле задача даже не об украинском флаге, а о голландском.
Нет.
Нет, там фишка в том, что...
Нет, да.
То есть надо их упорядочить так, чтобы были меньше х, равные х и больше.
Их тоже надо завод единицы памяти.
Нет, ну, погодите.
Нет, ну на самом деле, да.
Один из тупых вариантов проделать вот это.
И обнаружить, что у вас там, действительно, от 3 до j будут элементы меньше либо равные, справа-то больше либо равные.
И тогда внутри уже вы их можете перепорядочить на меньшее и равное соответственно.
Вот.
Впрочем, там по-разному.
Можно на самом деле не заморачиваться, потому что есть такой метод.
Теоретически мог бы быть другой метод.
Вы просто тупо идете слева направо.
Допустим, я вот дошел до сюда, и у меня вот где-то вот здесь находятся элементы меньше х, а тут находятся больше.
И тогда, когда я вижу очередной элемент, то как бы у меня два варианта.
Если больше х, то я просто тупо иду дальше.
А если меньше х, то я тупо свапаю вот с этим элементом и двигаю вот этот указатель.
В принципе, тоже можно.
Вот.
Ну, там отдельная задача, как бы это сделать все-таки за условно один проход, а не условно за два.
Но это уже там деталь.
Ну, в принципе, на самом деле задачи такого типа на всяких собеседованиях могут встретиться.
Ну, то есть обычно задачи подобного типа там для продвинутых олимпианников там обычно проблем не вызывают.
Вот.
На соответствии.
Так вот.
Вернемся к...
Ладно, поговорили об этой техке.
Вернемся к К-партишену.
Начну к...
Начну...
Да.
Или даже...
Вот.
Или еще одно название.
Q-order-статистика.
Потому что по-русски эта задача называется задачей о кат- и порядковой статистике.
Значит, а при чем?
Что такое кат- и порядковая статистика массива?
Мы говорим, что какой элемент окажется кат-ым, если мы этот массив ацертируем?
Ну, или там.
То есть в простой постановке говорим так, что пусть у нас равных элементов нет, все элементы попарно различны.
И тогда скажи, найдите, пожалуйста, элемент, который больше, чем ровно K-1 других элементов.
Вот.
Можно еще вот так эту задачу сформулировать.
Вот.
Сформулировать там вот в телефонах.
Просто если никак, лучше тогда их убрать, тогда это бессмысленно просто.
Соответственно.
Ой.
Так вот.
Значит, соответственно.
Итак.
Ну, возникает вопрос.
Как же эту кат-у порядковую статистику искать в предположении, что мы там массив можем...
В массиве элементы переставлять можем.
Есть классический вариант.
Такой рандомный.
Давайте выберем рандомный элемент.
Ну, вот это вот.
Типа так же, но рандомно.
Вот.
Ну да.
И, значит, проделаем ту же операцию.
Ну, вот тогда вызывать рекурсивно будем не...
Вызывать рекурсивно будем не два раза, как в сортировке, а только один в ту сторону, которую нам надо.
Ну, и с правильно подогнанной кашкой.
Там уже детали, я думаю, нет смысла прописать.
Вот.
Ну, кстати, да.
Тогда за сколько это работает?
Ну, если нам будет фантастически не вести, то это будет работать за квадрат.
Ну, ладно.
За...
Это может работать за n умножить на k.
Или это может работать за n умножить на n-минус k.
Ну, потому что, если там в нужную сторону будет не вести.
Вот.
Ну, в принципе, да.
Заметим, что там еще алгоритм может отказывать, потому что если гарантируется, что k не превосходит 10,
то, в принципе, выгодно, наверное, просто запустить 10 итераций пузырька какого-нибудь.
Что я сейчас сказал?
Ну, да.
Ну, или так, да.
Просто 10 раз найти минимум.
Ну, ладно.
Так, ладно.
Давайте поделите, кто знает, что такое сортировка пузырьком.
Нет, все знают.
Но считайте, что в процессе, типа, до каждой итерации там какие-то большие элементы,
типа, да, там пульбулька всплывают, да, вот так как-то.
Но там это отдельно.
Вот.
Ну, хорошо.
Ладно.
Вот.
Так что можно так?
Ну, в худшем случае, если будет не вести, да.
Но с другой стороны, на самом деле, при разумных предположениях о везении, на самом деле алгоритм явно будет работать за какую-то линию.
Ну, например, предположим, мы гарантируем, что на каждом таком шаре будет отсекаться.
Ну, например, где-то хотя бы десятая часть всех элементов.
Ну, нормально такое предложение, да?
Тогда за какое время будет работать алгоритм?
Он тогда будет работать за время.
Первая фаза работает за n.
Вторая за 9 десятых n.
Вторая за 9 десятых в квадрате n.
Ну, вот.
Потом в кубе n.
Ну и так далее.
До конца дописывать не буду.
Ну, не потому, что мне лень, а просто там нет конца.
Вот.
Да.
Ну, а что это такое?
Это равно n на сумму геометрической прогрессии 9 десятых в степени i.
Вот так меньше либо равно.
Вот.
Но заметим, что этот ряд у нас сходится.
И сходится к чему?
Ну, не примерно, а в точности.
Это 10n.
Ну, потому что у нас, да.
То есть, если вы там складывать 1 плюс q, плюс q в квадрат, плюс и так далее.
Там в кубе плюс и так далее.
То это равно 1 делить на 1 минус q.
Ну, просто потому, что если бы, да.
Ну, на всякий случай, да.
То есть, если вы просто складываете там n в степени q,
это будет равно там 1 минус q в степени n поделить на 1 минус q.
Вот.
Ну, если q меньше единицы, понятно, что это стремится к нулю.
Поэтому в пределе будет вот это.
Вот.
Получается 10n.
Получается, что вы где-то не более, чем за 10n элементов.
То есть, 10n всего найдете.
Ну, там думаете, ну, вам иногда будет...
Ну, там примерно раз в 10 итераций вам, конечно, так вести не будет.
Но, возможно, это...
Но где-то это, наверное, вам может компенсироваться тем,
что где-то вам будет отсекаться ни одна десятая побольше.
Ну, по-хорошему, конечно, тут надо уже тягу вверх вводить.
То есть, прокурсор тоже, можно сказать, что вам может фантастически не вести,
и это будет работать за квадрат.
Более того, под каждой...
То есть, в принципе, под практически любую реализацию можно подогнать контратест.
Даже под рандом, потому что рандом, как известно, это псевдорандом.
Поэтому, если вы знаете, как он генерится, то подогнать можно.
А как подогнать, например, зону под твистер?
Под что?
Ну, под...
Как там?
Ну, получается, стоит 600 с чем-то.
Ну да, там, конечно, в этом смысле веселье.
А почему для любой последности рандомов будет тест, на котором все варится?
Упражнения читательные?
Потому что, если ты умеешь...
Ну, там тест будет работать примерно так, что...
То есть, тебе нужно сделать так, чтобы вот этот элемент стал минимумом.
То есть, если ты знаешь ранд, ты предскажешь, где минимум должен оказаться.
И все.
Почему невозможно?
Ну да.
Но если ты заранее...
Нет, просто утверждение такое.
Предположим, что ты заранее знаешь последовательность из N-рандомов, которые тут будет выдана.
Тогда я утверждаю, что можно подогнать последовательство, которое на каждом рандоме
в этом подмассиве будет выдавать тебе минимальный элемент.
Нет, это показывает просто то, что для любого такого, может существовать тест,
который работает за квадрат, не более того.
Понятно, что там...
То есть, в принципе, если анализировать...
Можно анализировать с вероятностью.
Если у вас будет идеальный рандом, то...
Ну, там дальше так.
Простой анализ говорит, что математическое ожидание времени работы этого кусорта будет N-лога.
Но на самом деле там есть более глубокие анализы, которые говорят о том, что вероятность того,
что это по глубине будет глубже, чем 4 логарифмы или 16, вероятность будет крайне мала.
То есть, там оценится, что это совсем-совсем крайне мала.
Понятно, что как сделать этот алгоритм...
Ну, нет, конкретно кусорт вам вряд ли рассказывать о вероятности, конечно,
но в рубрике вероятностных алгоритмов мы, я думаю, это обсудим в той или иной степени.
Ну вот, там же мы обсудим, что вот этот маленький брат, конечно,
по матожеданию работает за линию.
Ну и, конечно, еще отметим, что там, конечно, начинаются разные читы,
то есть, на самом деле, потому что, как бы да, то есть, матожедание N-лога это круто,
но тем не менее это не избавляет вас от вероятности того, что алгоритм будет работать не за N-лога.
Но тут можно по-разному выкручиваться.
То есть, конечно, тупой вариант, конечно, выкручиваться, просто говорим,
так, даем время N-лога, чтобы ты отсортировал, ладно, там, сколько там матожедания?
3 N-лога, ладно, даем тебе время 8 N-лога.
И тогда идея, что если ты за 8 N-лога не завершился, ладно, тогда мы тебя обрубаем и начинаем заново.
И еще раз, и еще раз, и еще раз, пока не успеешь.
Нет, в принципе, это, кстати, не самый плохой вариант,
потому что если у вас матожедание 3 N-лога, а вы ждете 8 N-лога,
тогда вероятность того, что у вас за 8 N-лога не сойдется, она не превосходит 3 восьмых.
Ну да, просто неравенство, это я тупо неравенство Маркова взял.
Нет, там самый простой неравенство, который можно взять, 3 восьмых.
А можно считать 6 N-лога, и тогда вероятность будет одна вторая, и это оценка сверху.
То есть тогда это означает, что в среднем вы будете сходиться за O от единицы, на самом деле, операции.
Но правда, проблема остается, да, согласен.
Да, в принципе, скорее всего, в среднем...
Но на самом деле, как вы стояли, поступают в этом месте по-другому.
Они там просто говорят, что да, вот запускаем вот этот вот кусок, но если мы неожиданно поняли, что глубина рекурсии прям...
Ну там два лайфхака.
Говорят так, что если у вас массив размера не больше, чем, по-моему, 16, то мы его сортируем чем-то там.
Вставками какими-то там, пузырьком или так далее.
Потому что оказывается, что там квадратические сортировки бывают сильно лучше на маленьких массивах,
потому что они в массивах просто по константе выигрывают, чем вот это вот безобразие с рекурсией.
Или там хипы еще какие-то и так далее.
Вот, это один лайфхак.
Но второй лайфхак.
То есть маленький массивчик будет просто быстренько внутри себя посортирован и уйдем.
Но если там выяснится, что вы очень глубоко ушли в рекурсию, очень глубоко, что типа два алгоритма или еще куда-то,
то на этот раз алгоритм останавливается и мы его досортироваем хип-сортом.
Вот.
То есть это реально, что пропагандируется в Estee Lauder.
Вот, ну не знаю, там требуется ли в стандарте, чтобы там в STD-сорте было написано именно это.
Но чаще всего пишут так.
Почему пишут так?
Почему бы, действительно, оказалось бы, если вы хотели...
То есть требуется, конечно, чтобы сортировка железо-бетонно работала за N-логан.
Возникает вопрос, почему не написать какой-нибудь тип-сорт вообще?
Константа огромная.
Да, почему мертв?
Но у мержа есть недостаток.
Он требует дополнительной памяти.
Или очень-очень-очень больших страданий, чтобы ее избежать.
Вот, видимо, возможно, в следующий раз мы еще и обсудим, каких конкретно страданий.
Вот.
В принципе, можно мерш-сорт реализовать за вот единицу допамяти, но это будет больно.
Чего?
Там есть in-place-merge.
Специально, отдельно выделенные, которые работают за вот единицы памяти.
Но помните, он жирнее.
По Константе.
То есть STL предоставляет вам возможность самим выбирать, чем вы готовы пожертвовать.
Памятью или временем.
Вот.
То есть, кстати, ровно по этой причине иногда на самом деле STL не делает всего того, что можно.
Могли, наверное, задуматься на тему того, почему вектора, например, работы с памяти нет.
Почему они только расширяют, но не сужают, например.
Казалось бы, логично.
Но, на самом деле, сложно сказать, почему конкретно в данном случае.
Но суть такая, что во всех случаях там, видимо, комитет сидел, рассматривал плюсы и минусы и выбрал вот такую реализацию.
Вот.
Потому что нет.
Самый эпический пример, на самом деле, с которым, я думаю, от которого страдали многие олимпиадники.
Там отчасти.
В STD-сете нет понятия найти кат-элемент.
То есть, надо писать, либо вписать свой...
Нет.
Свой дикартак, слава богу, писать не обязательно, потому что там в гнусных версиях C++, не гнусных, а гнусных, не путать.
Значит, там так называемое расширение называется Policy Based Data Structures или PBDS.
И в них есть какие-то обертки, какие-то более продвинутые версии сетак, которые можно поднастраивать и отдать в стандартных строек.
Ну, почему?
Выучить или записать в ТИМ ноутбук можно.
Так что, ну да, то есть, конечно, может быть глобально бывает оптимальный дикартак, потому что в дикартаке вы можете буквально сделать все.
Ну, то есть, знаете, это классический анекдот.
Как говорится, это называется в GEN2 Linux, вы можете сделать все своими руками.
Более того, вы будете делать все своими руками.
Но нет, в принципе, свои преимущества это действительно умеет.
Вы можете сделать все, что хотите.
Но правда все это мелочи придется делать самостоятельно.
То есть, понятно, есть другой подход популярный в программировании.
Я помню один из преподавателей там по одному из прибетов говорил вообще, что замечательно.
Чем отличается хороший программист от плохого?
Хороший программист знает в отличие от плохого, что все, что можно было реализовать, уже давно реализовали.
А чем отличается отличный программист от хорошего?
Отличный знает, откуда достать.
Вот.
То есть, в принципе, такой подход, особенно во многих промышленных областях,
в общем, действительно применим.
Потому что это срогие изобретения велосипедов.
Скорее всего там, действительно.
То есть, чаще всего вам...
Потому что, опять же, по причине черной ящиковости.
Потому что это структура данных, которая умеет вот это, это, это.
По-хорошему вам не нужно знать, что это какое-то там дерево.
Дерево какое-то там.
Да?
Да ладно.
По стандарту?
Я думаю, так, по стандарту регламентировано, что там есть требования, что там все должно работать за лжарифом.
И не сильно много жрет до памяти.
Так, ребят, во-первых.
Так, да.
Вот.
Ну, то есть, ну, то есть, далее, нет, ну, далее, отдельная, да.
Да, на всякий случай еще напоминаю, что, собственно, вас снимает эта не особо скрытая камера.
На всякий случай, да.
Вот.
Привет, Ютуб.
Ну, да.
Ну, в принципе, да, да, да.
Подписывайтесь там, да, ставьте лайки.
Да, да, да.
Мы помним.
Там пять просмотров.
Вот.
Мне кажется, после двух с половиной часов...
Ну, после, ну, да.
Ну, знаете, ближе к экзаменам количество просмотров, наверное, увеличится.
Да.
Но это неважно.
Ладно, важно, но важно, на самом деле, другое.
То есть, там, ну, на самом деле, там не совсем все равно.
Потому что там многие деревья, то есть, многие деревья, на самом деле, туда не пойдут.
Скажем, дикартачи, на самом деле, в сплей, то есть, в сет встануть нельзя.
Почему дикартачи?
Потому что дикартачи скотина вероятностная.
Чего?
В принципе, да.
Возможно.
Кстати, возможно.
Зачем ты продолжаешь накидывать идеи?
Да.
Не, ну ладно, это идея, но это идея не новая.
Ладно.
Вот.
Не.
Ну, нет.
Ну, персидент это два-три дерева.
Да, надо.
В сердце как-то в сердце был прикол, что надо было там написать персидент это 2-3 дерева,
чтобы получить 100 баллов.
По-моему, никто это не сделал.
Но это типичный пример хорошей задачи, в которой, как бы, на разборе, там, в том
числе и все, в том числе и лидер узнает там много, там много нового интересного.
Так что нет, это хорошая идея была.
Это они молодцы, что сделали.
Вот.
Да.
Вот.
Но там просто я к тому, что подойдет только, то есть надо там, то есть в СЭТ тогда
ВЛ, то есть подойдет только дерево, у которого логарифм железобетонный.
То есть, скорее всего, даже сплей дерева, я думаю, не подойдет.
Вот.
Да не стоит так, господи.
Так.
О чем мы говорили вообще, да?
Да.
Да.
Давайте.
Нет.
Ну, как сказать это?
Эти вещи тоже, на самом деле, в том или ином виде в какой-то момент придется
все равно обсуждать.
Так что не то, чтобы мы прям принципиально время тратим, на самом деле.
Вот.
То есть, как бы, да, вещи такое.
Значит, смотрите.
Но тут у нас вот теперь задача.
Как избавиться от рандома?
Вот мне хочется найти как-то порядку статистику, но не думать о том, что там с какой-то вероятностью,
что мне может не повести там и, собственно, будет все плохо.
То есть, я хочу, я хочу чего-то железобетонного.
Так вот.
Но тут, правда, да, за это отсутствие рандома мы, конечно, платим приличной константой.
И требованием выучить пять фамилия авторов.
Ибо изучать мы сейчас будем алгоритм Блюма, Флойда, Пратта, Ривиста, Тариана.
Если я никакую фамилию не перепутал.
Да.
Ну, я не знаю.
Вот я не знаю, кто там первым автором стоит, если честно.
Ну да.
Пять.
Да.
Ну, я, ну, Тарья, ну, Тарья у нас в какой-то момент вообще хедлайером станет.
Особенно когда мы там в графы пойдем, там просто без него вообще практически ничего не обойдет.
Ну, Блюм это известный человек, потому что есть такая штука, как фильтр Блюма, на самом деле, кто-то.
То есть фильтр Блюма, это знаете, как быстро, то есть если у вас там иногда задача бывает, как быстро проверить там, если у вас множество какой-то элемента,
это означает, что вы читаете его хэш и в таблице помечаете, что этот хэш есть.
Там в массивчике просто.
И тогда получается очень быстро, что как бы если такого хэша нет, значит элемента нет.
То есть такой быстрый тест.
Понятно, односторонний, но как бы тоже помогает.
То есть есть там несколько уровней фильтра Блюма, когда таких таблиц вы строите несколько с разными хэшами.
То есть если хотя бы одного хэша нет, значит вы вылетели.
То есть в принципе такой бывает удобно.
Ну да, ну Флойда мы тоже знаем по алгоритму Флойда Уотшелла, да, более известного как алгоритм.
Так, да, Пратта, где мы знаем Пратта?
Да, есть алгоритм Кнута Мориса Пратта, да, более известная как поиск префикс функции, это да.
Так, вот тут Ривист, интересно, или кто-то еще?
Да.
Не, у меня первая ассоциация, это один из авторов книжки про Кормана, книжки Кормана.
Не про Кормана, да, Кормана.
Ну и конечно его величество Торьянда, Роберт Эндре Торьянда.
Да, Роберт Эндре Торьянда, как-то самое, да, в чем знаете, в чем действительно, он просто да, очень, да, очень много.
Да, он автор, кстати, Кучи Фибоначи, как следует из названия, да.
Да, нет, он, нет, но также он автор там дерева доминаторов на самом деле.
А, но также он, по-моему, автор первой возможно содержательной статьи про ДФС.
Ну по примеру, которую я знаю, может есть раньше.
Первая линия алгоритма поиска про Эль Геракта.
А, да, ой, этого я уже не знаю, но вот значит вот много чего у него есть, так что такое.
Все в этом случае сада.
Самый, да, самый радостный вопрос на самом деле в этом плане у меня, кстати, в каком году умер Торьян.
Да, вот именно по этому вопросу радости.
Да, он, собственно, жив и работает, да.
То есть понятно ему там, по-моему, 80 лет, по-моему, там уже, но он...
Нет, он постоянно статьи выпускает.
Знаете, забавно там в 2012 году была там у него статья в САВТОКСе.
Видимо, какой-то ученик, который там...
Видимо, статья занималась тем, что куча фибоначи доводилась до, собственно, не амортизированной версии.
По-моему, куча продала...
Нет, не путайся, нет.
Нет, да, потому что, да.
Нет, ну да, нет, куча продала касаки, да, это 96-го года, но это как бы другая структура данных.
Да, а тут как бы, видимо, задача была, чтобы именно кучу фибоначи допилить.
Но куча продала касаки, она же может все тоже самое...
Ну да, ну видимо, да.
Вряд ли.
Нет, ну как сказать, знаете, очень много бы хотелось,
что времени у нас не так много.
На самом деле программа уже, на самом деле, забита очень вообще веселыми вещами,
которые там более надо знать, хотя в принципе...
Нет, в какой-то момент можно развлечь там, знаете, там много какие алгоритмы можно изучать.
Ладно.
Но если мы сейчас будем все это обсуждать, вот именно поэтому времени, в общем-то, и не хватает.
У нас будут типа алгоритмы на выбор.
На чем?
Алгоритмы на выбор реализовать одной из структур.
Возможно.
Вот так вот.
Значит, так алгоритм вот этих вот пяти товарищей.
Значит, да, и собрались эти вот пять, в общем-то,
давайте серьезных имен.
А поэтому там по пять элементов.
Ну, наверное, не поэтому, но давайте, ладно, сейчас для тех, кто не знает, давайте расскажем.
Что имеется в виду?
Мы эти, как вы это все делаете?
Делаем очень просто.
Мы делим массив на блоки по пять элементов.
Ну, если количество элементов не делится на пять,
ну, как бы без потери асимботики, это решается там энцитю способами.
Можно там мысленно последний блок докинуть там, добить до пяти, чтобы там было плюс бесконечность.
Но я бы предпочел, конечно, нет, я бы предпочел другое.
Я бы предпочел просто пробежаться по массиву и найти там нужное количество максимумов там от нуля до четырех.
И после этого спокойно считать, что имеющийся у нас размер массива делится там это число, делящиеся на пять.
Так вот, идея такая.
Пробежимся по всем вот этим вот пятеркам.
Каждую из них отсортируем, например.
Ну, можно вот допустим отсортируем.
И соответственно, это помогает там в каждой пятерке найти медиану.
Ну, в принципе, можно просто сказать, давайте в каждой пятерке найдем медиан.
Это понятно, будет завод единицы, независимо от того, будете ли вы делать это сортировка или там какими-то еще методами.
Итак, у нас тогда появится n поделить на пять медиан.
Ну, давайте будем считать, что неполных блоков нет, потому что неполный блок, то есть если у нас там будет неполный блок размера три, мы от него избавимся, просто пробежавшись три раза по массиву и найти три максимума.
Там поместя их, собственно, в конец массива и все.
Может быть, это с точки зрения какой-то именно технической реализации, может быть, это не самый оптимальный вариант, но как бы математически можно и так.
Вот, ну, математически, правда, можно и суфмассу коненном за линию строить, да, но это уже там.
Так вот, значит, идея такая, у нас теперь есть n поделить на пять медиан.
Так вот, в этом месте мы вызываем этот алгоритм рекурсивно.
Мы пишем, значит, мы хотим, значит, q order statistics, говорим мы, от вот этого вот массива медиан размера n поделить на пять.
И мы хотим в этом массиве найти медиану, то есть, так сказать, медиану медиан.
То есть, выражаясь питоновским языком, k равно n поделить на 10.
На питоне можно так писать, это, конечно, классно.
Это вам не эти ваши ищи, да, с плюсами или без.
Вот, и так у вас нашлась какая-то медиана.
Теперь идея такая, значит, вы нашли этот элемент, он равен x.
Ну, тогда идея такая, ну, тогда утверждайте, что после этого надо просто, значит, вызвать capartition действительно с этим x.
Ну, это да, вот этот вот механизм провернуть.
То есть, разбить элементы на меньше этого элемента и больше этого элемента и от нужной половины сделать второй q order statistics.
Ну, понятно, в нужную сторону, понятно, да?
То есть, вот такой алгоритм.
То есть, алгоритм подозревает два рекурсивных вызова q order statistics.
То есть, первый для поиска медианы, а второй поиск уже с какой-то кашкой или ее модификацией.
Вот, понятно?
Вот.
Но возникает естественный вопрос.
За какую асимптотику это работает?
Мы завершили развивку объяснения?
Да.
Значит, мы делаем медиан и медиан.
Делим массивы, располагаем там, перепорядочиваем массив так, что сначала элементы идут там, значит, там меньше этого x, значит, снова x и тут больше x.
Тоже за линию делаем, да?
И после этого запускаем второй q order statistics уже для нахождения ответа от нужной из частей.
Ну, или если повезет этот алгоритм и этот элемент оказался cut, ну, значит, выбрасываем все с криком ура.
Ну, в смысле с криком x, конечно.
Вот.
Так что вот такая красота. То есть, нам иногда может вести, а может не вести.
Да, это было бы хорошо выйти из-под две камеры. Было, конечно, да.
Но знаете, классик, журналисты это...
Журналисты это люди, которые профессионально делят любую фразу на две части, чтобы вторую часть сказать другую камеру.
Ну, вот эта классика такая, да.
Так, а вот интересный тест. Ну-ка, поднимите руки.
Кто знает, откуда я эту шутку взял?
Ну, да. Да, ну, КВН можно поднимать пальцем тосом, да.
Может более глубокий вопрос. Какая команда это сказала, да?
Не, как есть, не. Не, ну, как есть, это не фистись, это...
Ладно. Нет, ну, если твердая, так.
Я уж забыл, как команда этих девочек называть. А, без баб они называются почему-то.
Хотя я не знаю, почему.
Главное, команда вообще выглядит совершенно не так, как вы сейчас можете вообразить.
Потому что четыре очень, вообще, очень интеллигентные, симпатичные девушки, на самом деле.
Нет, пока, да, пока, к сожалению, не дотянули до высокого уровня, там, но...
Ну, вот, но как бы рекомендую, если что, на самом деле вам понравится.
Мне кажется. Ладно.
Окей.
Ладно.
Ладно, по-настоящему.
Поняли, что значит, ладно.
Значит, окей, КВН никто не смотрит.
Значит, можно использовать шутки.
Ну, или, ну, впрочем, неважно.
Вот. Ладно.
Значит, смотри, значит, соответственно.
Теперь давайте думать, почему этот алгоритм работает за линию.
Да, ну, потому что, в принципе, особенно, если не заморачиваться, то, что мы делаем,
то, что мы делаем, то, что мы делаем, то, что мы делаем, то, что мы делаем, то, что мы делаем.
Да, ну, потому что, в принципе, особенно, если не заморачиваться об прям округлении какие-то, да.
Да, он у нас работает, что время работает, ТАТ.
Получается...
Как он работает? Давайте так.
ТАТ равно Т от N поделить на 5.
Ну, да, можно округлить вниз при желании.
Не то же самое.
Не то же самое.
Тоже.
Ну, давайте оценивать время.
А потом у нас будет это максимальное время работы с массивами от N операции,
независимо от того, какое К берем.
То есть, по всем К тоже максимум выбираем.
Плюс какое-то что-то мы делаем за О от N, вот эти вот партишины, да.
Плюс Т от...
Чего?
А вот тут оказывается интересный момент.
А теперь давайте думать, да.
Просто зачем мы все это делали?
Понятно, что если бы нам будет не вести...
Если будет оказываться N минус 1, то мы так жестко пофейлимся.
Но...
Так, тихо, тихо, тихо.
Так, смотрите.
Оказывается, примеры следующие.
Давайте мысленно эти медианы отсортируем.
Подчеркиваю, мысленно.
То есть, в реальности их, естественно, отсортировать никто не будет.
И тогда вот у нас возник вот этот вот мистический Х.
Тогда, смотрите.
Оказывается, что есть тогда целый вот этот вот блок элементов,
которые меньше либо равны Х.
И сколько в этом блоке элементов?
Ну, примерно.
Ну, примерно там плюс-минус.
Значит, N поделить...
То есть, ну, во-первых, тут массивов тут примерно N поделить на 10.
И в каждом...
И в каждом...
Ну вот, и в каждом по три элемента.
То есть, получается, умножаем на 3.
Получается, 3 десятых N.
То есть, получается, слева как бы...
То есть, тут получается, слева будет как минимум 3 десятых N элементов.
Но по абсолютно аналогичным причинам.
И справа будет хотя бы 3 десятых N элемента.
Тогда это означает, что t здесь смело могу писать 7 десятых N.
То есть, это такая еще верхняя оценка.
То есть, вот так можно.
Вот так, меньше либо равно можно писать.
Да, вот хороший вопрос.
Хотя, конечно, в данном случае, наверное, придется поверить.
Ну вот.
Так.
Но давайте так.
Если мы поверим, что вот этот вот O от N для N будет больше, чем для N-1,
то, в принципе, можно доказать по индукции, наверное.
Хотя...
Ну да.
Заметим, что тут может быть реально максимум.
Тоже можно тесты подгонять.
Ну да.
Но на самом деле неважно.
Пока оцениваем, на самом деле неважно.
Да.
Нет, ну нет.
Правильно было отмечено, что...
Что тут на самом деле правильно писать, что t от N равно
всегда t от N поделить на 5, плюс O от N, плюс t от чего-то
не происходящего 7 десятых N.
Если только внимание вопрос, почему меньше либо равно отсюда,
можно перенести сюда.
Да, правильный вопрос.
Но мы, пожалуй, забьем на него.
Хотя, конечно, формально можно попредираться.
Вот.
Ну то есть другой вопрос.
Ну как-то...
Ну или другой вопрос.
Что, наверное, там...
Ну как бы интуитивно поверим, наверное, в то, что...
Действительно, чем меньше N, тем алгоритм по камере там...
Нет, тем алгоритм все-таки, наверное, будет быстрее работать.
Просто потому, что...
Ну просто потому, что...
Ну просто потому, что для любого N всегда найдется тест,
который здесь сведется...
То есть сведется именно к какому-нибудь максимуму,
поэтому там доказательство будет по индукции.
Вот так скажу.
Или...
Ну ладно, неважно.
Так вот, значит, к чему нас это приводит?
И это нас формально приводит к следующему.
Так, ну теперь мы пытаемся доказать, что это...
Что это O от N.
Как вы это делаете?
Ну в принципе, да, у нас есть как бы...
С прошлого раза у нас есть классический вагер.
Притаемся доказать, что T от N не превосходит C от N.
По индукции, да?
И тогда пишем, что по индукции T от N не превосходит...
Пытаемся написать шаблон C от N поделить на 5,
плюс A от N, плюс 7 десятых C от N.
Вот так.
Но 7 десятых плюс одна пятая, это сколько?
Это 9 десятых C от N, плюс A от N.
Это меньше либо равно действительно C от N,
при этом C больше либо равно, ну скажем, 10A.
Ну видно, да?
То есть здесь получается такое достаточно простое догадательство.
Вот.
Но соответственно, в домашнем задании у вас возникнет вопрос.
А почему делить на 5?
А нельзя ли делить на...
Там по троечкам?
Или по семерочкам?
Или по девяточкам?
Не по N.
Не, ну по N-очкам не по N, это надо по-любому на константу,
но по идее можешь делить на нечётные какие-то константы.
И вот...
Ещё прям быстрее будет?
Не знаю.
Так, заправы.
Значит, это было...
Так, так вот.
Так.
Так, чего там?
Ну вот.
Но в принципе да.
Хотя на самом деле задача...
Нет, хотя...
Итак.
То есть действительно отдельная песня, когда там рекуррента сходиться будет,
а когда не будет.
То есть сразу скажу, будет технический момент,
что в некоторых случаях действительно это не сходится,
но как бы, как вы помните, что если вот это вот не сходится,
это не значит, что рекуррент, что T от N не является тому от N.
Помните, да?
Это будет, конечно, отдельная пида.
Нет, это просто я просто объясняю, что как бы подразумевается в этой задаче.
Нет, ну вот.
Ну в принципе...
Нет, ну ладно, лучше давайте не будем забивать,
потому что всё равно там у вас есть более сложные задачи на эту тему.
Вот.
Ладно.
Ну там, в общем-то, видите, когда тут линия,
когда нет логарифмов корней, там как раз округление у вас проблем не вызвали.
Так что так.
Можете разомнитесь на самом деле перед работой с логарифмами и корнями.
А то там в некоторых задачах такие ответы начинаются.
Ой.
Ладно.
Так, ну что ж.
Это был, значит, такой вот...
Это мы тут неожиданно обсудили кусор три-корда статистики.
Так, ну что?
Ой-ой-ой.
Так.
Спрашивается, да.
Так, не пришло ли время перерыва?
Но нет, пока ещё не пришло вроде.
Или пришло.
Итак.
Поговорим немножко, значит, да.
А так ещё чуть-чуть о stacker deck.
Вот.
Вот.
Но на самом деле, да, раз уж мы сегодня заговорили об этом,
то имеет смысл действительно вспомнить.
Как вообще реализовывать stack?
Ну что такое stack для начала?
Мы всё с нуля изучаем, да.
Ну, по идее, stack – это такая простая структура данных,
у которых...
Хочется сказать соблазном такое сказать.
У stack есть две...
Там такая структура данных, то есть две операции.
Push и pop.
Push кладёт элемент stack, а pop достаёт последний добавленный элемент.
То есть тот элемент из тех, кто сейчас в stack есть,
которые были добавлены позже всего.
Спрашивается, как проще всего реализовать
озвученную мной структуру данных?
Нет.
Нет.
Нет.
Не очень сложно.
Вот именно, именно.
Потому что в том виде, в котором я сказал,
на самом деле есть такая реализация.
Это реализация, в которой вы вызываете операцию,
а структура говорит...
Угу.
Потому что в принципе заметим,
с помощью этого интерфейса вы никак не проверите,
что она ничего не делает.
Угу.
Вот.
То есть всегда...
То есть знаете, простой тест на то,
что всё-всё вы определили.
То есть если структура данных может делать...
Угу.
И всё, значит, соответственно.
Но обычно есть третья операция.
Операция называется top.
И она как раз возвращает вам элемент,
который прямо сейчас на вершине stack находится.
Вот.
Тогда тут уже не обойдёшься.
Вот.
И как это реализовывать,
становится действительно интересно.
Потому что...
Ну вот.
Какие есть подходы.
Но есть два основных подхода.
Первый базируется на массиве.
Вы заводите какой-то большой массив,
и там двигаете какой-то указатель.
Вот.
Ну в принципе хороший подход.
По констанции работает хорошо,
но минус заключается в том,
что непонятно, что делать,
если память бухер закончится.
То есть заморачиваться
и там куда-то что-то перекладывать.
То есть там перекладывать
вот эти вот технологии с буфером
забабахивать там и так далее.
Ну не говоря уже о том минусе,
что в данном случае,
если вы забабахиваете прям очень большой буфер,
тогда у вас будут проблемы с тем,
что если стэк маленький,
что даже маленький стэк будет
жрать очень много памяти.
Поэтому есть...
Да, если вы владеете
мистической технологией указатель,
так вот тут нетривиальный вопрос.
Ну как?
Кто вообще писал когда-нибудь
что-нибудь, связанное с указателями?
Так, а кто когда-нибудь успешно
писал что-нибудь с указателями?
Вот, хорошо.
Нет, я должен был спросить,
потому что не самая тривиальная тема,
и в некоторых там в общем смысле школах
иногда пытаются указатели
просто даже при изучении дикартящик
и правдами и неправдами избежать.
То есть даже говорим, что,
господи, дикартящик, зачем там нужно указатели?
Давайте лучше там заведем общий вектор,
вместо указателей будет там
индексы какие-то писать.
Вот, а кто-нибудь когда-нибудь писал дикартящик
в таком виде?
А, чего?
Четыре байта.
Там даже регулярный был.
Ну окей, да, хорошо, хорошо.
Ладно, понял.
Но тут уже менее поднятые руки, конечно.
Да, так что да.
Нет, ну суфтоват он и по умолчанию на массиве пишет.
Но это не древесная структура данных,
поэтому там указателями баловаться
себе дороже будет.
Да, ссылки.
Ну как мы уже обсуждали, что происходит,
если вы делаете, если вершины
смотрят указателями, а их хранятся
при этом векторе.
Вот мы сегодня уже обсуждали,
каким веселым спецэффектом это приводит.
Поэтому обычно да.
Суффиксное дерево, да, там указатели
как бы более там, там больше подходят.
Вот, ну а почему я заговорил про указатели?
Потому что есть действительно вторая,
потому что есть вторая версия,
как реализовать указатели.
То есть просто реализовать на,
то есть действительно на указателях,
то есть в каждом элементе есть два поля.
То есть, собственно, сама чиселка
и, так сказать, указатель
на предыдущий элемент.
Вот.
Вот.
Ну да.
И последний указатель просто указывает
в никуда, вот я и буду крестиком
помечать никуда.
Вот.
И у нас еще будет у строка указатель топ,
который будет указывать на верхнюю вершину.
То есть, действительно, тогда делать
пушерчик просто.
Вы просто создаете с помощью просто
той же функции new, ну или там мало
какого-нибудь, не знаю, значит,
новую вершину.
Там топ перенаправляете сюда
и этот указатель копируете сюда
и записываете тут этот новый элемент.
Как сделать поп?
Ну, там топ, ну, точнее, функция топ
после этого, там метод будет работать
очень просто.
Ну а поп?
Ну, как бы, да, на Олимпиаде вам хватит
указатель на следующий элемент.
Но, конечно, на C++ вас такое
будет очень больно бить.
Вот поэтому, конечно, прежде чем
перенаправлять указатель, вот эту вершинку
лучше поделить, конечно.
Да, помните, что C++ это такой редкий язык,
где за память отвечаете только вы.
Помните, да, то есть, как бы, если вы
выделили память, но ее не освободили,
то до конца работы программы эта память
вообще-то освобождена не будет.
Можно умные указатели?
Это другой вопрос.
Да, да, есть умные указатели, там,
со своими оверхедами, спецэффектами вы это
тоже будете очень подробно изучать.
Вот там, во всех деталях.
Да, можно так, но в данном случае, как бы,
нет необходимости, потому что, как бы,
все сами контролируете.
Да, можно там использовать умные указатели,
можно использовать что-то еще там, но просто
суть в том, что вы сами контролируете.
Условный джави есть, например, пылесоса.
Ну, ладно.
Да, то есть, там, пылесоса, да, но официальное
название garbage collector, естественно, да.
Ну вот, это пыленод.
Пылесоса периодически включается,
становится программой и пылесосит все,
к чему вы потеряли доступ.
Да, ну, а чем-то в джаве такой,
в питоне такой спецэффект есть,
то есть, в питоне вы тоже не заморачиваетесь
там об память, то есть, там, считаете,
что в амортизированном каком-то виде,
то есть, там, вот именно амортизированным способом,
но в какой-то момент там лишняя память
очистится.
Вот, вы не знаете, в какой, но это уже
там джава-машина сама решает, ну, или там,
этот ваш интерпретат.
В C++ вам придется, в C++ приходится
это отвечать.
Может, благодаря этому на самом деле
как-то вот, да, был вопрос.
Кем отвечает C++ и джава?
C++, как вы пишете, что угодно,
и только вы отвечаете за то,
что это не рванет.
Ну вот, в джаве надо писать четко по правилам,
но зато все будет надежно работать
и не рванет точно.
Вот.
Вот, ну, я вот слышал такое мнение,
как бы не могу там,
поручиться, насколько правда,
видимо, там, насколько это правда скажет
соответственно.
Вот.
То есть, какие преимущества
у такого стека?
Такое у стека преимущество в том,
что в каждый момент времени мы храним
ровно там тета, то есть памяти,
ровно там тета от 1 плюс количество
элементов, которые вы храните.
Логично, да?
Логично, да.
Вот.
Значит, вот это да.
То есть, хранится ровно столько,
сколько надо, никаких пуфер,
но у каждой этой недостатки
у этой реализации есть,
потому что все-таки операция Нью
в любом виде, она все-таки скотина,
во-первых, дорогая,
а во-вторых, на самом деле,
у вас тогда вот эти вершины
в памяти будут расположены
так более достаточно рандомно.
Вот.
Это в некоторых случаях тоже вызывает
пресс-верк, потому что на самом деле,
если вы хотите пробежаться, скажем,
по стеку и пописать элементы,
то если вы будете скакать
особенностей на самом деле
устройства работы в памяти,
это мы тоже в следующий раз
так немножко обсудим.
Вот.
Там вот, кстати, я там вот проматывал,
там тоже слайды есть на эту тему.
Вот.
Поэтому, то есть, это тоже как бы не идеальный вариант.
Поэтому, в принципе, есть гибридная версия,
которую можно чаще использовать.
Гибридная версия заключается в том,
что да, мы храним такую цепочку вершин,
но только в каждой вершине
мы храним не один элемент,
но один элемент.
Вот.
То есть, вот как-то вот так это происходит.
То есть, тогда как бы не U-шек
происходит немножко.
То есть, не U-шек происходит меньше,
там и получается чуть-чуть лучше.
То есть, там отдельно только надо уже.
То есть, дальше, конечно, все зависит от того,
под какие конкретно нужды вам надо,
потому что там и что вам конкретно надо.
Часто бывает, что STL, конечно,
на реальной практике,
теперь STL переписывают.
Иногда.
Ну, скажем, например, в компании Яндекс,
например, в стандартной библиотеке,
которая называется Аркадия,
то есть STL-ем пользоваться нельзя.
Можно пользоваться оберткой,
это яндексовая обертка STL.
Да, ну и сейчас, возможно, уже нет.
Хотя да.
Нет, ну класс строка, да, так и да,
исторически сложилось, что он есть.
Нет, при том, что есть код стайл,
который запрещает использовать русские,
но в данном случае,
это вот такое исключение полуисторическое.
Да, так называется строка.
Ну там,
ну там,
ну я не помню, строка, вытрока,
но есть тест рингвуф там был вообще, помню,
но я не знаю, у меня мог быть устаревшие сведения,
потому что я как бы работал в компании Яндекс,
когда там с,
ну получается, где-то там с сентября 12-го года,
по апрель 15-го, в общем-то,
поэтому с тех пор там могло все поменяться,
я не знаю, то есть там уже,
те, кто там работал или работает,
ну какие-нибудь ваши старшие товарищи там сейчас,
там почти, наверное, в большом количестве стажируются
или работают даже,
они там могут рассказать подробнее.
Вот, но там была фишка такая,
что, скажем, STD сетом пользоваться нельзя.
Ну можно было пользоваться структурой данных Y-сет.
Y-сет.
Это, ну на самом деле,
на самом деле это фактически,
фактически такое,
на самом деле такое фактически обертка сета,
обертка сета, даже наследник его,
но просто с прописанным Яндексом
аллокатором.
Хороший вопрос,
хороший вопрос точно не скажу.
Нет,
нет, ну как сказать,
тут вот проблема,
потому что дело в том,
там он не быстрее,
потому что действительно стек и очередь это такая обертка от дека,
обертка просто,
фактически потому что стек умеет то же самое,
что дек,
просто чуть меньше.
Вот, но подлянка,
поэтому там просто какие-то операции запрещаются,
но подлянка там заключается в том,
что у дека в STD есть операция квадратной скупки.
Да.
Потому что это все становится сильно более сложно.
Вот, у вас домашнее задание будет это,
придумать реализацию такого дека,
чтобы можно было это делать pushback,
pushback, pushfront, pushfront.
Конечно.
Четыре стека будет?
Ну,
ну если придумаете на четыре стека,
то пожалуйста.
Амортизация разрешена,
но ее нужно будет четко проанализировать.
Это я так предупреждаю,
что будет в домашнем задании.
Ну, придумать...
Нет, это...
Нет, это то, что я сказал,
это теоретическая задача.
Возможно, в плюсовом курсе вам придется это реализовать.
Но это, нет, это просто другая задача,
там просто, то есть понятно,
что там идейно там не будет ничего сложного,
но как бы судьба в том,
чтобы это реализовать правильно,
в точке зрения языка C++.
Понятно, да, но это как бы немножко уже другое.
Вот, значится,
значится, да, это у нас стек.
Ну да, вот в рядах там был,
там играх, хэш-сет и так далее.
Вот.
Но если вот, ладно,
если забыть говорить об амортизации,
то есть если вот там говорить об какой-то...
Ну...
Сейчас, что я хотел сказать-то вообще?
Что-то, наверное.
Да, со мной такое бывает, да.
Ну вот.
То есть, ну, в принципе, действительно,
стек можно так реализовать,
но можно в принципе на двусвязном списке
можно реализовать и очередь.
Вы понимаете, кто когда-нибудь реализовывал
вообще хоть какую-нибудь версию списков?
А, вот уже не все, да.
Не все до этого ждали.
Не, не понял.
Ну, по-разному.
Да, это жалко.
По-хорошему, ладно, давайте пробежи.
Ладно, на эту тему пробежимся немножко.
А, ну, в принципе, да,
у меня что-то...
Есть вон.
Все.
Да.
Нет, просто так быстрее будет.
Просто чтобы...
Чтобы потом были уверены,
что все это уже видели,
чтобы не выяснилось, что я для кого-то
тут начал говорить про заклинание.
Но вы тоже на всякий случай спрашивайте.
Потому что бывает две проблемы.
С одной стороны, многие стесняются
задать какой-то вопрос.
Ну вот.
А потом жалуются, что...
В лекциях ничего не понятно.
Там максимум шесть человек вообще хоть что-то понимают.
А!
Вот.
Ну вот.
Понимаете, да.
Нет, ну как сказать?
Понятно, что я не первый год лекции читаю,
поэтому местами могу предсказать,
что я должен на всякий случай проговорить.
Что кажется очевидным,
но для кого-то не очевидно это да.
Но как бы правтыки могут случаться.
То есть правтыки могут случаться.
Поэтому если я в какой-то момент начал
говорить на китайском языке случайно,
то пожалуйста, просьба быстренько меня просто останавливать.
Ну, условно-китайском.
Я не знаю.
Я считаю, что я его не знаю, но может выясниться,
что я на нем неожиданно говорю.
Да, это может оказаться японский язык,
лингонский язык или что-нибудь еще в этом роде,
но соответственно.
То есть я неслучайно тут действительно поддерживаю атмосферу,
что как бы не я.
Не я просто даю знания,
а вы прям молча отомкиваете и там что-то записываете.
Вот я вот специально поддерживаю атмосферу,
что вот хочется, чтобы если возникает вопрос,
его можно сразу задать.
Поэтому активно призываю вас активно участвовать.
Потому что тем более,
если вы так будете засыпать, то знаете,
это тоже еще один классический пример,
который там тоже в КВН очень хорошо еще прорисовали на самом деле.
Что будет, если чуть-чуть проспать?
То есть вот ситуация.
Представьте, человек сходил на первую лекцию по химии,
там все было понятно,
и он там решил, ладно, вторую пропущу,
что там будет.
И там приходит на третью лекцию,
и думает, ну что там непонятно, все понятно.
Приходит, а там называется,
здравствуйте, тема там,
все в очередной лекции плавно вытекает из предыдущих двух,
и так там сублибация сублирагов очень резидентна
по отношению к лекции мобисознательному.
Мы проходим там некоторое, в некотором виде,
предельных углеводородов.
Подождите, а где химия эта наука, вещества?
Там где сера плюс водород равно сера-водород?
Так, конечно, было на первой лекции.
А это третья.
Ну вот и там начинается там всякие вопросы.
Какие-то, да.
Ну-ка, расскажите мне, действительно,
как были формулы оксида Берилия?
Все поднимают руки вон.
Да как так-то!
Ну и тогда, смотрите, поняли, я думаю, о чем речь идет.
Поэтому суть в том, что желательно просто не выпадать.
То есть, если вы поняли, что где-то вот выпадаете
или что-то непонятно, лучше меня тормозить,
я лучше расскажу еще раз, но как бы будет понятно.
А то потом вы там заснете.
То есть, кажется, все будет просто.
Вот сейчас я понимаю, что многим из вас
то, что я рассказываю, достаточно просто.
Но если вы там расслабитесь, то в любой момент,
в какой-то момент вы проснетесь,
и потом будет, действительно, я говорю,
сублимация сублирагов очень резидентна
по отношению к лекции мобисознательному.
И все вокруг вас, да-да-да, конечно, понятно.
Естественно, да.
Вот.
И так далее.
Поэтому, соответственно.
Небольшое такое нужно было сделать.
Значит, смотрите.
Что такое односвязанный список?
По идее, односвязанный список – это фактически структура данных,
на которой мы реализовали стэк.
Сама по себе она значит, что у нас есть
действительно голова этого списка,
и у каждого элемента есть следующий элемент.
Да, вот тут подло еще подляночка.
Это понятие список не имеет никакого отношения
к понятию список в языке питон.
Ну, потому что то, что называется
списком в языке питон, в остальном мире называется массив.
Да.
Но тут, к сожалению, такая вот терминологическая проблема есть.
Поэтому.
Ну да.
Потому что вектор...
Нет, ну как сказать, вектор все-таки еще не во всем.
Ну да, вектор есть геометрический хотя бы, да.
Это да.
Но что делать?
Вот.
Ну какие еще списки бывают?
Ну, бывает, конечно, удобно, когда у вас есть
двусвязанный список.
Что такое двусвязанный список?
Ну, двусвязанный список тактик,
когда у вас есть голова и хвост,
и как бы каждый элемент имеет указатель
и на следующий, и на предыдущий.
Вот.
Но скажем так, это в принципе
очень удобный способ сохранить какие-нибудь элементы,
если вам от них не сильно много что нужно.
Ну, что можно делать теперь с двусвязным списком?
Ну, туда можно достаточно легко добавлять элементы,
а также если у вас есть указатель
и на следующий элемент,
его достаточно легко удалить.
Прям вот за 1 это очень удобно.
Не все структуры данных обладают этим замечательным свойством.
В куче фибоначи она удаляет минимум все равно за логарифом.
Уменьшить по указательам можно за 1.
Чего?
Уменьшить по указательам можно за 1.
Ну, типа да.
Да, это можно.
Но дело уменьшить, дело удалить.
Но в списке вы все это делаете за 1.
Вы можете там каты какой-нибудь.
То есть, к сожалению, есть недостаток.
Кат-элемент вы тут не найдете.
Не по порядку, не просто вот хотя бы это.
То есть, пробегаться надо.
Но, условно говоря, если вам нужно хранить только вот,
что вот есть такой набор элементов,
иногда элементы нужно, скажем, доставать оттуда быстро,
и вы знаете, где находится, то удобно.
В общем, что еще удобнее?
Если у вас есть указательный элемент,
то если вы добавите в список какой-то другой элемент,
то указатель на этот элемент не инвалидируется.
То есть, как бы он все еще есть.
Это очень удобно,
потому что в каком-нибудь там условном сете
или даже векторе оказывается с этим проблемой.
То есть, там какие-то оговорки начинаются.
Вот.
Так что вот такие элементы.
Ну да, вот очень удобно еще,
что такие списки теперь можно объединять.
Ну правда, односвязанные списки, конечно,
объединять не очень удобно,
если только вы, конечно, указатель,
прям хвост, последний элемент не поддерживаете.
Но какой-нибудь двусвязанный список, понятно,
объединяете, просто за 1 очень удобно.
Вот, да, тут.
То есть, вот, в принципе,
какая-нибудь есть простая реализация.
То есть, вот, примерно вот,
да, ну, там стиль такой, не будем сейчас,
наверное, время тратить.
Вот, но, конечно, да.
То есть, список, конечно, не массив,
потому что нет доступа по импексу,
не говоря уже о расходах,
о допамяти в лице тех же самых указателей.
Ну и, конечно же, есть разреженное расположение в памяти.
Это означает, что помимо элементов
вам приходится хранить сами указатели.
Ну, как тебе сказать?
Ну, как тебе сказать?
Если у тебя список интов,
то у тебя рядом с интом хранится нечто,
что весит не меньше самого инта.
А в современных компиляторах,
а в 6-7-битых, видимо, и больше.
То есть, как бы, да, то есть,
понятно, что в процентном соотношении,
чем больше ты хранишь информацию в списке,
тем, конечно, меньше жрет этот указатель.
Но, тем не менее, это такой,
то есть, хранишь ин элементов,
хранишь меньше ин элементов,
получается, тратишь там лишние 4n или 8n байт.
Это не всегда есть хорошо.
Ну, точнее так, такой недостаток есть.
Ну, недостаток или, может быть, спецэффект.
Просто о нем надо помнить, то есть, понятно.
Чаще всего он, как бы, проблем не вызывает,
но иногда по памяти надо приходится оптимизировать.
Но зато, как бы, в списке можно вставлять,
делать быструю вставку, в чем рандомное место достаточно,
и быстро удалять тоже достаточно рандом.
Вот.
Вот.
Так.
Ну, соответственно, мы уже обсудили,
что такое stack.
Единственное, что тут надо объявить,
это что такое у нас ATD.
Абстрактный тип данных?
Да.
Да не что-то типа оточет.
Да, это оно.
Ну, это такое, действительно,
такое математическое понятие,
действительно абстрактный тип данных.
То есть, за которым мы будем подразумевать,
что у нас есть какой-то черный ящик,
на котором мы имеем нотку,
который внутри себя хранит какие-то элементы
и умеет с ними делать вот это.
Ну ладно, еще соговорка и топ.
Ну, хотя есть еще, можно еще сделать то,
что когда вы делаете поп,
вы не просто делаете, а еще и возвращаете элемент,
который и достали.
То есть, он не просто вы его уничтожаете.
Хотя обычно поп и топ это все-таки разные вещи,
ну, как вы стояли, например.
Но обычно вот под абстрактным типом данных,
действительно, подразумевает такой потенциальный черный ящик,
который вот с внешним миром взаимодействует
только через интерфейс.
И кто-то его использует,
а тот, кто его использует, не знает,
что там внутри себя делает стэк.
Вот.
Да, это называется черный ящик.
Вот.
Ну, стэк у нас мы поняли.
Да, мы уже обсудили.
Можно илизовать там с помощью массива.
Вот есть очередь.
Ну ладно, здесь, я думаю, тоже все понятно.
Вот.
Поддержка минимумов, это мы сегодня обсуждали.
Вот.
Да, это.
Вот.
Нет, ну, можем это обсудить,
можем быстро обсудить как двоечную кучу,
чтобы там потом не заморачиваться.
Но, на самом деле, зачем нам нужна очередь из шести стэков,
когда у нас есть очередь из двух стэков?
Ну вот.
Нам иногда хочется,
ну нет, амортизация чаще всего, это круто, конечно,
но иногда она не помогает.
В каких ситуациях она не помогает?
Ну, например, ну, типичная ситуация,
когда она не помогает,
это когда вам хочется делать персистентность.
Ну, что такое персистентность, да?
Ну, так вот персистентность это ка вы не просто реализуетez у Структура данных,
а хотите в некотором смысле хранить все промежуточные версии,
то есть структура, которые имели место.
То есть, например,
то есть, например, вот самое тупое,
то есть персистентный стэк,
то есть, например, вы там делаете какие-то,
там, какие-тоänd finely то операции, например.
то есть например вот предположим что у вас там есть операция допустим push 5 допустим push 7 push
12 поп да значит push 34 push 57 push 179 поп вот вот в принципе вот очень хочется хранить
ну вот то есть очень хочется иногда иметь доступ к не просто тому что получится в конце
а хочется еще но ты мить доступ ко всем версиям то что в процессе на самом деле стэк претерпел 8
изменений и после каждого он был в каком-то состоянии получается даже там 9 даже версии
потому что есть изначально нулевая версия которая была пустая и что же у нас получается то есть нулевая
версия у нас получается это пустой стэк первая версия это вот крестик и соответственно питочок
вот их и вторая таки там вторая версия и так пишу вот давайте вот так 0 1 2 так то есть тут
питочок тут питочок семерочкой значит дальше идет там крестик питочок с 12 это третья версия
четвертая версия на самом деле практически идентична второй версии но и так далее понимаете
да вот ну на самом деле да то есть это то есть например стэк это могло бы выглядеть так то есть
конечно там действительно там можно захотеть делать допустим персистентную очередь персистентное
дерево отрезков там скажем да я думаю многие из вас даже приписали что-нибудь подобное да ну как
кто когда-нибудь писал какую-нибудь персистентную структуру данных хорошо вот да действительно
такое в чем действительно видим что персистентность тут один из тех вопросов где легко ответил
просто зачем это нужно ну потому что как бы персистентность в том или ином виде нужда
просто в любой системе контрольной версии то есть в любом дите там и свои не лишене еще в этом
роде практически да то есть понятно что там если вы там решили поменять на самом деле там одну
строчку в одном файлике то наверно там звать там весь код всей компании наверно менять от этого
не хочется то есть там как отдельно копировать куда-то правда поэтому поэтому хочется конечно
делать как-то более оптимально но тогда возникает действительно интересный вопрос как же это делать
но то есть как же это более оптимально сделать и например стэка в общем-то мы видим что это не
очень сложно делается потому что на самом деле можно просто то есть действительно говорить то
есть хранить вот как и какой-то вот такого рода дерево да то есть если уж кратко говорить там
12 нет вроде 12 здесь вот а здесь ответвление на 34 вот так там 57 179 получается ну можно сколько
угодно ветвиться и на каждый элемент то есть мы элементы как бы не удаляем и можно включать
Gilbert то есть получается там действительно 0 ну оглашение нулевая версия указывает сюда
первая версия указывает сюда вторая версия указывает сюда третья оказывается это четвертая
указывает сюда же значит пятая версия оказывает сюда шестая сюда седьмая сюда и восьмая сюда же
Очередь можно реализовать на двусвязанном списке, да саму по себе очередь, пожалуйста. А вот, а теперь
вопрос, а как реализовать персистентную очередь? Вот персистентный stack реализовать с полпинка,
вот равно как практически любую структуру данных, в которой как бы все подвешено за какой-то корень
и доступ только вот сверху вниз, то есть потом, скажем, деревоотреска персистентируется очень
легко. Само ссылающиеся, то есть, ну, то есть, если они там, если там, да, вот с двусвязанным
списком будут проблемы, да. То есть, можно как бы делать персистентный массив идентичный,
но обычно там первая статуя, что персистентный массив, это что-то типа персистентного
деревоотреска. Ну, там, конечно, по-разному может быть, там все зависит от того,
какую задачу вы решаете, что от вас требуется, да, там по-разному можно, но, да. И так, значит,
это мы все, это у нас все имеем, вот, поэтому с персистентной очередью возникают проблемы,
да. Ну, так и так, можно реализовать как персистентный там какой-нибудь массив,
действительно, да, это не там, но это тогда придет к тому, что операции в очередь будут работать за
логарифом. Вот, но, казалось бы, специально для этого у нас есть очереди из двух стэков,
и каждый стэк может быть, там, можно реализовать персистентно. В общем, даже не каждая просто там
персистентно сделать там в одном месте, просто тут будут там, где-то, где-то здесь будут указатель
там in и указатель out, в чем проблема, да. Но проблема в том, что структура амортизирована. То есть,
то есть, проблема в том, что некоторые операции работают не за О от единицы. И вот тут разница,
да, что если они мы просто делали операции последовательно и не хранили там предыдущие версии,
то да, мы могли говорить, что да, что у нас есть какие-то монетки, что мы там можем говорить,
что да, у нас может так случиться, что операция будет работать там за О от Н, но это означает,
что перед этим у нас было О от Н операции, которые работали за О от единицы, поэтому в среднем
получается нормально, да. Ну, по большому счету, да, можно так говорить. Но в персистентности такое,
персистентность, конечно, такой подход обрубает на корню. Потому что фишка персистентности не
только в том, чтобы хранить, а в том, что иногда может захотеться просто делать операции не с
последней версией стека, а с новыми, со всеми новыми. То есть, просто я скажу, возьми-ка версия,
которая была вот здесь и сделай к ней что-нибудь. Вот, и тогда у меня тут вот к ней еще указатель
прорисуется. Вот, если сделаем очередь на двух таких стеках, то можно на самом деле брать версию,
в которой push приводит к каким-то проблемам и постоянно туда делать push. Вот, и тогда это будет
долго. То есть, как выяснится, что да, как сказал бы Classic, ух ты, я могу заставить того старого
хрюча поковырять в носу еще раз, и еще раз, и еще раз. Вот, да. Ну, как вы помните, так баловался
Ron Weasley с вот этим вот моноклим, с повтором на чемпионате мира по квитичу. Вот, да, потому что
там была функция замедленного повтора, какого-то замедленного повтора. Да, поэтому да, я могу
заставить того хрюча поковырять в носу. Да, вот, вот здесь то же самое. Вот, и тогда получается,
что уже любая абортизация превращается в то, что вы уже реально не можете гарантировать,
что у вас будет работать недолго. Поэтому, как бы, если вы хотите реализовать очередь на стеках,
то нужно реализовать ее таким образом, чтобы все операции работали за от единицы в честную. Вот.
Именно, но попытки это как-то модифицировать, именно приводят к, собственно, очереди на шести
стеках. То есть наша цель реализовать, то есть какая у нас цель теперь, то есть наша цель
реализовать очередь, то есть там как вот на шести таким образом, чтобы как бы каждый пуш и каждый
поп гарантированно делал вот от единицы операции, причем жестко, не в среднем, а именно жестко. Вот.
И это важно. Да, ну сейчас у нас будет такой многоинтерационный подход. То есть как бы это
одна из тех структур данных, когда придется, значит, это обсудить ее, значит, постепенно, значит,
один раз, потом вернуться, обсудить второй, потом третий и так далее. Так что работает она так.
Значит, у нее есть, значит, в очереди есть шесть стек. Значит, ну, по идее, как бы начало вот L&R это те
самые стеки, которые мы рисовали только в другую сторону. То есть как бы по умолчанию сюда
добавляется, отсюда достается. Да, то есть основная идея будет заключать в том, что вот эти все стеки
нужны, чтобы там делать в фоновом режиме перекопировки. Ну да, но если считается,
что новый буфер создается за от единицы, то да. В принципе, да, можно. Вот. Но что у нас для этого
будет? Но для того, чтобы это адекватно делать, у нас есть два режима. Есть режим, когда мы реально
начинаем в фоновом режиме что-то перекопировать. Ну вот. А это, сейчас, давай, не будем одновременно
отвечать на один тот же вопрос. Вот. Идея в фоновом режиме в данном случае означает следующее, что мы
хотим делать операцию за от единицы, но константу мы себе не прописали. Поэтому идея будет такая,
что когда у нас там придет операция, мы сделаем за от единицы операцию, то есть там достанем нужный
элемент или засунем. Но при этом, но также в эту константу мы еще потратим сколько-то времени,
чтобы, скажем, перекопировать сколько-то еще элементов, например, три. Ну у нас тут константа
будет три, ну понятно, может быть там 4, 5, 10, но как бы суть одна. Ну да. Ну то есть один элемент и
еще что-то делать. То есть мы в константу это жрем. То есть как бы, то есть, по сути, да, мы
победим абортизацию с помощью еще более жирной константы. По большому счету, да. Просто,
ну да. То есть это что-то из цикла, что как бы не все, что мы делаем действительно,
товарищ директор, какой-нибудь там пользователь действительно увидит, ему может показаться,
господи, вы просто суете в стерпи, что вы там так тормозите? Отормозите, потому что вы там в тихую
еще там какие-то махинации по манипуляции проводите. Вот. Но проводите вы, то есть и пользователю
об этом знать не обязательно, но если только, конечно, он не сильно нервничает от этого. Вот.
Но он как бы сильно больше будет нервничать, если вы больше операции будете, да, быстро-быстро-быстро-быстро,
а потом придет какой-нибудь вот эта абортизация, и тогда на операцию на миллион вы вообще зависите.
Вот. То есть лучше как бы приучить его к тому, что он будет ждать чуть дольше,
зато железобетона. И так. В нормальном режиме этого не происходит. То есть пока у нас в этом
стеке элементов меньше, чем вот в этом. То есть мы спокойно работаем и не паримся. Более того,
правда, мы еще гарантируем, интересный факт, мы еще гарантируем, что вот это, будьте здоровы,
вот счастье. Эти два стека, на самом деле, в них одни и те же элементы. Зачем нам это нужно? Сразу
скажу. То есть когда включится, когда мы будем заниматься перекопированием, да, то есть что у нас,
когда мы включим режим перекопирования, вот когда в L будет больше элементов, чем в R,
да, то наша цель будет, то тогда произойдет следующее. То есть у нас тут будет какой-то L,
тут будет какой-то R. Наша задача будет добиться того, чтобы эти L и R оказались в одном стеке.
Понимаете, да? Но при этом пока мы это делаем, у нас как бы будут еще какие-то работы, в том числе
с R-кой. И нам нужно хранить как бы какие-то вот эти вот элементы, которые надо доставать из
очереди. Именно для этого мы храним как бы копию. То есть позже эта копия будет там ликвидирована,
соответственно. Но пока мы с ней работаем, а тем самым мы там и будем заниматься тем,
что будем делать какое-то перекопирование. Пока L меньше, нет, пока L меньше, то мы ничего не
делаем. Если L, если нам пришел push, добавляем в L, если пришел pop, удаляем из R и из RC. И еще,
если в RC штрих может так случиться, что у нас тут есть какие-то лишние элементы, давайте пару
тройка элементов еще отсюда зачистим. Если тут еще в RC штрихе, ну как мы позже увидим,
тут могут оказаться еще какие-то лишние, ну в зависимости от реализации. По идее я бы,
конечно, по умолчанию, особенно без презентации, рассказывал бы версию, где в этом режиме тут все,
вот эти стеки пусты, их больше не существует. То есть они не существуют, они просто пустые,
больше ничего делать не надо. Но там как бы по-разному можно реализовывать. Значит, смотрите,
а вот дальше начинается шоу. Давайте разбираться, что тут написано и нарисовано. А нарисовано вот,
что как только L, тут в стеке стало на один элемент больше, чем R, сразу врубается режим
перекопирования. Какова цель этого режима перекопирования? Цель заключается в том,
чтобы все поместить в, чтобы был вот у нас L, R, а надо сделать так, чтобы все эти элементы
в том же порядке оказались вот в этом стеке. Понимаете, да? Ну то есть смотрите. Ну то есть
наша цель такая, давайте я тут, вот тут я, пожалуй, порисую. То есть хочется сделать так,
теоретически, чтобы у нас вот этот стек L, вот у нас R. Вот в какой-то момент, тут оказалось там,
допустим, 9, 7, 2, 5, 8, а тут там 4, 3, 2, 1. Я хочу провернуть какие-то махинации,
чтобы у меня вот этот стек стал типа пустым, по крайней мере без этих элементов, прочего,
ну вот. А тут оказались 9, 7, значит 2, 5, 8, 4, 3, 2, 1. Вот по крайней мере в первом приближении я хочу
вот это. Вот у меня такая идея. То есть смотрите, как это будет работать. То есть когда у меня это
только началось, но по факту это будет работать немножко по-другому. Значит, теперь идея будет
такая. Вот сейчас мы будем раскрывать, зачем мне нужны остальные стеки. Остальные стеки нужны
вот зачем. Значит, жил был L, жил был L'. Помните, который был пустым, да? Так вот, идея такая.
Теперь, то есть я буду делать какие-то махинации по перегонке вот этого всего вот сюда, но мне
нужно делать пуши и мне нужно делать попы тем временем. Значит, пуши я буду делать в стек L'. Вот сюда
я буду делать пуш. Помните, я поддерживал вариант, что у меня есть не только стек R, но и его копия.
Так вот, я буду доставать элементы из него и у меня будет цель, но тогда у меня, значит,
я ставлю цель, что до того, как он опустеет, у меня будет цель, соответственно, завершить
перекопирование. Но что я должен делать для перекопирования? Для перекопирования я буду
делать следующее. Комбинация следующая. Что я хочу сделать? Я хочу, значит, на первом шаге,
как я это перекопирование сделаю? В реальности я его сделаю так. Первое, что я хочу, вот сейчас
я просто тоже на доске сейчас нарисую. Так, доска там, кстати, адекватная, видна? Окей, все хорошо.
Вот, значит, смотрите, то есть реально буду я это делать так. То есть вот это я вот продекларировал,
что я хочу. Значит, первое, что я хочу, значит, я хочу сделать так, чтобы у меня теперь в L было
то же, что было, 9, 7, 2, 5, 8. В R, вот это L, в R у меня должна быть пустота, а все эти элементы
у меня будут находиться в S. Я, честно говоря, не знаю. Ну, не знаю, может его, конечно, надо было
TMP назвать, но не важно. Нет, не скажите, потому что, скажем так, потому что здесь так, смотрите,
но этимология, да, ну LR это просто потому что мы тебе воображаем очередь двух стеков как слева
направо. Значит, RC это значит R копия. RC штрих это запасная копия R. Ну, заранее скажу, так как
мы с RC будем работать, из нее что-то добавлять, то когда мы будем возвращать все элементы в R и
закидывать новые, мы будем добавлять не только в R, но и в RC штрих. И тогда, когда мы все сделаем,
мы просто посвапаем стеки RC и RC штрих. Да, да, ну понятно, да, ну сразу оговоримся, да, посвапать,
например, посвапать два стека, проблем обычно нет, надо просто посвапать указательных вершины,
правда? Вот, да, но на всякий случай, да, из прелевских контейнеров практически все поддерживают метод
swap, который позволяет их свапать за O от единицы. Ну, как вы все любите, векторы тоже очень легко
посвапать за O от единицы, да, потому что что там посвапать? Посвапать сайзы, посвапать
capacity, посвапать указатель на буфер, все, больше ничего не надо. Вот, поэтому это делается за O от
единицы. Ну, там аналогично там делаются всякие сеты, мапы и прочее, но вот поэтому там умеют,
поэтому как бы прикольно иногда писать там какой-нибудь вектор, век.swap. Ну, по-моему, да,
скорее всего, почти, наверное, swap у всех контейнеров перегружен так, что он вызывает именно этот
метод, да, это да, но это уже подробнее на сях. Так вот, значит, это я просто говорил того,
что свапа со стеков, это там техническая, это простая техническая деталь. Теперь, смотрите,
значит, R пустой, значит, из этого и тут мы достали элементы и положили их сюда, как мы их положили,
ну, в этом же порядке получилось и положили, ну, как вот один, потом два, потом три, потом четыре,
получилось вот так. Видите, да? Это первая часть. Это мы делаем какое-то константное число операции
из вот это вот, что мы хотим. Нет, ну, не только, но нам нужна, как бы понятно, нам сделают...
Ну, нам будет полезно представить, что у нас тут x элементов, а тут x плюс один изначально был, да, то есть
нам нужно сделать x перекладывание отсюда-сюда, то есть x попов и x push, да? Ну да, то есть пока Rc, да,
то есть, конечно, Rc опустошится там не раньше, чем через x попов, да, то есть это означает,
что за x попов мы должны проделать вот это перекопирование. Значит, да, сделать мы хотим конкретно
следующее, перегнать x элементов stack s, вот он, да, второе, что мы хотим теперь сделать, перегнать
вот эти элементы из L в R, то есть будет вот примерно так, то есть вот тут 9, 7, 2, 5, 8 будет,
вот, ну вот, и а в S пока сохранятся те же 4, 3, 2, 1 и третья операция вернуть элементы из S в R,
то есть у меня будет пустой L, пустой S, а в R будет все, правда, с маленькой оговоркой, конечно,
еще, правда, с маленькой оговоркой нам придется следить, потому что дело в том, что пока вы это
делаете, какие-то из этих элементов могут быть попопаны, но понятно, это маленькая техническая
деталь, просто когда вы вот на вот этой фазе, когда вы пытаетесь добавить сюда что-то, то вы говорите,
что если уже там произошел, ну здесь вряд ли, да, но вот, но на этом перекладывании, когда там начал
происходить, если приходить добавить элементов, он уже был попопан, ну по количеству определяете,
то значит его туда добавлять не надо уже, ну да, ну да, и чего мы хотим, да, но да, но да,
важный момент, дело в том, что когда мы вот это делаем, мы это делаем, да, то есть мы это делаем
еще с участием rc-штрих, потому что rc-штрих здесь пустой, здесь s изначально пустой, когда вы
перекладывали из r в s, конечно же, rc-штрих у вас все еще пустой, да, далее, перекладываем из l в r,
но при этом каждый раз, когда мы кладем элемент в r, мы кладем его еще и в rc-штрих, то есть rc-штрих
в итоге будет тоже 9, 7, 2, 5, 8, и более того, когда из s в r мы возвращаем элементы, мы тоже говорим,
что вот у меня в rc-штрих тоже будет это вот все, вот, да, то есть rc, да, для этого, да, то есть мы все попы
делаем из rc, пуши делаем в l-штрих, вот, ну да, а теперь смотрите, важный момент, после этого,
ну после того, как только у вас это перекопирование закончится, ну давайте так, вот это перекопирование,
ну сколько нам операции требует? Оно требует, ну как легко убедиться, там сколько? 3x плюс 1 операции,
но я обычно положить элемент в r и rc-штрих, я считаю тут заодно, я именно перегонку считаю,
ну да, чтобы rc выжил, нужно, чтобы там было действительно x элементов, да,
вот, ну даже не x, а x плюс 1, потому что когда вы сделали вот этот пуш,
который привел режим перекопирования, вы уже сразу можете его начать, поэтому оказывается,
что вам в принципе у вас не x шаров на это, а x плюс 1, поэтому оказывается, что в принципе можно
на каждом шаре, вот, то есть при каждом далее следующем пуш и попе вы можете сделать,
на самом деле только достаточно сделать 3 из этих операций, да, так, нет, достаем из rc,
если нам приходит, то есть там говорят, если пришел пуш, мы будем так, кладем в l-штрих и
делаем 3 из этих операций, если нам пришел поп, то мы, говорим, достаем из rc и делаем еще 3 операции,
еще, кстати, как только режим перекопирования делается, мы тоже делаем 3 операции,
так мы его в l-штрих кладем, в режиме перекопирования мы кладем элементы не в l, а в l-штрих,
да, то есть в конце мы, конечно, свапаем, во-первых, rc с rc-штрих, а во-вторых, мы свапаем l с l-штрихом,
это важно, то есть как бы l-штрих будет пустой, s будет пустой, в l-е что-то находится, вот единственная
только оговорочка, что в результате этого свапа может оказаться, что в rc на самом деле есть какое-то
количество элементов, которые, потому что не все попали, то есть именно поэтому на самом деле у нас
тут хранится вот этот вот, то есть вот эти вот x и как, потому что по окончании перекопирования,
да, вот у вас r и rc, это бывший rc-штрих, у них будут одинаковые элементы, тут все актуально и хорошо,
вот тем более, что тут все актуально и хорошо, более того, там еще есть какой-то определенный
запас есть, даже интересно посмотреть, то есть даже сейчас проанализирую, можно проанализировать,
сколько элементов тут, сколько элементов тут, но в rc-штрихе что-то осталось, что мы не попали,
поэтому вам придется, видимо, в фоновом режиме, пока нормальный режим работает,
все-таки тут что-то зачищать. В нормальном режиме удаляем 3 раза, пытаемся сделать pop из rc-штриха,
ну пытаемся в том плане, если пустой, то не делаем, вот так что вот такая вот,
но s он автоматически опустошается, потому что когда вы все передали, видите, вот в этом
месте он как бы в начале перекопирования пустой, в конце пустой, больше мы его не пользуем,
в нормальном режиме s мы не пользуем, так что вот еще раз, так что получается вот такой режим,
то есть режим перекопирования такой. Ну да, мы подразумеваем такое. Да, вот, ну вот,
на самом деле это естественный вопрос, что у нас в нормальном режиме в rc-штрихе что-то
находится и не случится ли так, что прежде чем мы опустошим rc-штрих, окажется, что у нас там на
самом деле включился новый перекопирование. Да, вы правы, можно и так,
но там разные варианты есть. Нет, это шло вот откуда, нам нужно поддерживать одновременно r и rc в
нормальном режиме, это нужно для того, чтобы когда начнется перекопирование, мы как бы с
rc работали, а была надежная копия, с которой мы работаем. Вот, да, поэтому как бы нам нужно,
чтобы когда перекопирование закончится, у нас будут два равных, вот две равных r,
поэтому нам нужен rc-штрих. Нет, нет, нет, мы их свапаем, оно становится rc-штрих, и то,
что отсюда не попопали, значит мы там попаем либо в нормальном режиме, либо это. Ну, мне
показали, что. Ну, да, то, что в принципе, да, то есть заметь, то есть, ну да, то есть,
ну да, давайте, давайте я еще скажу, потому что, да, у меня и микрофон, не в смысле,
что я крутой, а в смысле, что нашим телезрителям будет сложнее услышать ответы из зала, вот,
соответственно, вот, но да, действительно, действительно, есть вот действительно такой
эффект, что находится, что будет находиться по окончании перекопирования в rc-штрих. На самом
деле, какой-то префикс вот этого r, который был на момент начала перекопирования. Да, ну,
просто, ну, на самом деле, там будет сколько-то элементов, то есть те же элементы, но минус,
сколько было по оно. Ну, да, то есть, это означает, да, в принципе, нет, более того,
смотрите, по большому счету можно даже сказать так, я вот даже попробую расписать так, ладно,
сейчас нас, конечно, начнут выгонять, на самом деле. Ну, да, нет, ну, сейчас просто вот, сейчас вот
формальное окончание пара, да, через 10 минут нас точно начнут жестко выгонять, ладно, но сейчас я
думаю, это мы уложим, да. Значит, получается примерно следующее. Внимание, внимание, вот, то есть,
просто, ну, допустим, можно даже проанализировать, смотрите, предположим, что у вас rc-штрих изначально
пустой, а вот тут оказалось, что в l-ке у нас x плюс один элемент, в r-ке оказалось, значит,
x элементов, ну, там понятно, в rc автоматически тоже оказалось x элементов, да. Итак, мы начинаем
перекопирование, которое закончится через x операции, да, и давайте себе представим, что в
этом x-е было, там, допустим, k пушей, вот в этим x-е операции и, соответственно, x минус k попов,
да. Тогда давайте посмотрим, тогда какая у нас будет диспозиция по окончании перекопирования,
то есть, когда мы l и l-штрих местами поменяем, rc, rc-штрих, тогда мы обнаружим, что в l-ке у нас
будет ровно k элементов, логично, да, а в r-ке будет, ну, вот сколько будет элементов в r-ке,
да, 2, совершенно верно, 2x плюс 1 минус x плюс k, то есть, в переводе говоря, x плюс k и еще и плюс
эти, но при этом, значит, это у нас l-ка, это у нас r-ка, да, ну, rc, понятно, копия,
копия, поэтому тут будет x плюс k плюс 1, а сколько будет элементов в rc-штрих?
Ну вот, нет, не скажите, их будет ровно k, потому что это будет ровно те элементы,
то есть, сколько было не попов, а их было ровно k. В режиме перекопирования будет выполнена,
вот если мы будем в режиме перекопирования делать x-операции по 3, то у нас получится,
на перекопирование потребуется потом ровно и, то есть, будет ровно x-операции.
Но оно опустеет ровно через x, то есть, для этого нужно x попов сделать.
Нет, ну тогда по факту перекопирования закончивших мы к этому моменту уже все перегоним.
Мы все перегоним, ну да, ну тогда у нас получается, что, ну а дальше будем просто использовать
h-трих и rc, пока rc не закончится. Надо запомнить, что мы завершили перекопирование и тогда просто
включить нормальный режим. Ну да, но там просто может быть более точная, потому что я вот говорил,
что мы сейчас ничего не включаем и сейчас вот смотрим, что у нас получится, потому что
до момента окончания перекопирования тогда будет ровно вот это, то есть, перекопирование закончится
в том виде, в котором мы писали ровно через x, да, я понял, что могут быть другие версии, да, то есть,
другие версии, может они там кому-то поражут более понятными, да, но просто давайте уже сейчас,
если мы сейчас углубимся просто в обсуждении того, что это разное, то есть, я буду, там кому-то будет
непонятно. Так вот, итак, вот у нас h-трих пустое, s пустое, значит l такое, но тогда смотрите,
получается, значит, здесь у нас находится, то есть здесь у нас находятся элементов,
получается k, здесь, но, здесь находится элементов на x плюс 1 больше. То есть означает, что режим
перекопирования начнется в лучшем случае через x плюс 2 элемент, а x плюс 2 больше,
поэтому в принципе оказывается, что вы там, в фоновом режиме на фоне нормального режима
и живо, можете отсюда выпиливать даже не по три элемента, а по одному даже.
Да, тогда на фазе перекопирования нам РЦ-шрифт тоже будет обрабатывать.
Нет, тогда на фазе перекопирования... Нет, просто к следующему перекопированию РЦ-шрифт уже будет пустым. Гарантированно.
Нет, на фазе перекопирования нам РЦ-шрифт уже будет обрабатывать.
Давайте просто добавим кучу элементов в ВЭЛЬ.
Ну и что? Да, только на каждом добавлении ВЭЛЬ ты выкинешь РЦ-шрифт.
Потому что в данном случае ты там добавишь девятку, выкинули игр, добавили десятку.
А потому что мы себе добавляем, что в нормальном режиме делаем еще допоговорку.
То есть дополнительный оговорок.
Выкинули игры, если у нас элементы иксы, то идут по сути после единицы.
Нет, потому что по факту эти актуальная очередь хранится в ЭЛЕР.
Нет, в ЭЛЕР и в РЦ, потому что мы их посвапали.
Мы посвапали там в конце режима перекопирования и ЦРЦ-шрифт.
Поэтому тут получаются адекватные копии, а тут по факту уже мусор.
Если представить, что вот эта ситуация сразу после завершения режима перекопирования, то у нас х равно 2 и х 0,1.
Ну, кстати, да.
Нет, кстати, нет.
Хотя...
Ну, там неравны именно 2 и 1.
Потому что, по-видимому, режим перекопирования закончился, потому что тут было 5,4,3, тут было 2 и 1.
То есть это уже мусор, потому что копируется как бы.
Нет, это можно сказать, откуда этот мусор взялся.
То есть у нас был вот этот стек РЦ, из которого мы делали поп, пока мы тут делали перекопирование сюда.
То есть он изначально совпадал с Р, но после этого он совпадать с Р перестал, потому что туда добавили элементы из начала.
И с ним мы работали, но какие-то элементы были выкинуты.
Но тогда после того, как обнаружилось в какой-то момент, что перекопирование закончено, Р и РЦ-шрифт совпадают,
поэтому эти два мы тупо свапаем, и получается, что в этом бывшем РЦ теперь сошли храницы уже неважно.
Остается его только аккуратненько зачистить.
Как мы обрабатываем эти вот попы, которые произошли во время перекопирования?
Предельно тупо. Тупо достаем из РЦ и больше ничего не делаем.
Это неправда.
Ну кроме шагов перекопирования, конечно.
Когда мы копируем из СВР обратно, потом мы смотрим.
Когда перекопирование закончится, по идее будут пропавшие элементы?
Будут не существующие элементы.
А, ну да, мы делали эту оговорку, что когда мы пытаемся в конце, когда мы добавляем...
Вот когда мы идем из СВР, то есть когда мы делаем из ЛВР, потом из СВР, мы как бы достаем элементы стека,
но при этом, когда смотрим на Р, говорим, во-первых, что не получилось ли так, что этот элемент уже был попан.
Но если получилось, то выкидываем.
Более того, да, на самом деле, если вы делаете поп из РЦ и оказалось, что этот элемент был добавлен в Р,
значит его оттуда тоже попать надо.
Как это проверять?
Ну по размеру.
По размеру РЦ.
На самом деле, да.
Ну типа того.
Ну тут разные варианты.
То есть конкретно тут в этой презентации есть какой-то вариант, как это вообще выглядит.
То есть утверждается, что это реально сделать и это будет не больно.
Ну да.
Ну нет, тут даже есть вот красивая какая-то реализация.
Вот.
Ну нет.
То есть как бы тут смысл в том, что надо, может быть, по этому алгоритму собраться несколько раз и как бы все это собрать в кучу.
Потому что в принципе понятно, реализация действительно будет не особо сложной.
Это просто обычно реализовали.
Она вообще персистентная.
Ну персистентная очередь.
Ну скажем так.
Там персистентная очередь реализуется понятно.
Это как бы просто персистентные 6 стеков.
Ну и персистентные эти бульды плаги, которые у нас персисуются.
Нет.
Ну зачем?
Нет.
Это ты хранишь просто в каждой версии.
То есть как бы часто чем персистентность отличается от не персистентности?
Тем, что там во-первых, вы возвращаете там на запрос не только ответ, но и как бы новую версию.
То есть как бы новый такой классик.
И в нем какие-то переменные хранить.
То есть да, поэтому понятно.
Персистентная булевая переменная.
Это, конечно, интересно.
Но обычно это решается тем, что вам придется вектор булов хранить.
Ну не вектор булов, ладно.
По факту вы будете хранить вектор структура check.
То есть в каждой из которых хранятся по 6 указателей на соответствующей версии стека.
И какие-то еще дополнительные информации.
Вот типа вот этих флагов.
Так что-то получилось.
Что-то не совсем даже взрыв мозга по ходу.
Вот.
Нет, ну как хотите.
Если будет желание, можем в следующий раз это обсудить еще раз.
Пробежаться.
Ну скажи так, это будет на экзамене.
Рассказывать.
Ага.
Ну да.
Думаешь?
Ну-ну.
Ну а как же?
Ну а что тут верить?
Нет, ну скажем так.
Алгоритм устроен так, что очевидно, что каждый шаг делается за 1 честного.
Да, то есть доказывать надо тут скорее, что тут по переменным все сойдется.
Да, ну там что-то подобные вещи.
Нет, ну так-то да.
Ну типа вот.
Ну как хотите, в общем.
Да, реализация.
Давай.
У нас вообще когда мы встречаемся в режиме прикупирования, это размер L больше размер f.
Но единственное ограничение на это то, что мы прикидываем им по 3 операции,
когда у нас в своем режиме прикупирования делаем 3 операции за 1.
Да.
По идее если мы начинаем прикупирование, когда у нас например L больше чем 2,
нам просто надо будет делать по 6 операции за 1.
Ну в принципе да.
Ну можно, ну в принципе да.
Можно поиграть с косметиками.
но нет можно поиграться и делать просто копирование быстрее да конечно ну
можно и в таком виде на самом деле просто режим при этом вместо трех
операции делать 10 и перекопирование будет быстрее происходить и вот но
просто по троечкам может быть делать лучше потому что тогда пуши и попы то
есть тогда все операции будут там более близки по реальному времени
потому что как бы разница 1-3 и разница 10-1 это разная вещь
