мы сегодня с вами будем говорить про потоки кто как воспринимает потоки что это кого еще в голове
вот вывод водопаде про машины что-нибудь хорошо а перелистывайте смотрите фактически с потоками
мы встречаемся очень часто а грубо говоря если вы будете делать не знаю вот кто-нибудь из вас
захочет побыть все-таки сантехником например нужно вот трубы перекладывать правильно вот и
там есть некоторые там поток воды не знаю может кто-то из вас станет крутым физиком и будет
типа не воду так делать а что-нибудь другое не знаю там электрончики в коллайдере разгонять это
тоже некоторая труба кросс с магнитами для того чтобы они правильно разгонялись вот и в
действительности потоки вы увидите на индекс картах если захотите вот типа как машинки двигаются и
почему сейчас 9 бальные пробки или нет там когда как вот и в действительности вы когда работаете
с потоками вы смотрите ага вот например вы решили не знаю там пойти куда-нибудь вы смотрите я
могу пойти вот так я могу пойти вот так и выбирайте там например кратчайший пути представьте
что вам нужно покрыть все вот вы такие экспериментаторы вы хотите взять и пройтись по максимуму того что
увидеть что-то на улице не знаю вон траву вы разглядывали вот вы захотели увидеть траву вот
во всех местах где она есть к примеру и вы понимаете что вот это вот дорожка сейчас загружена вот это
нет вот это будет столько-то времени идти и так далее в действительности задача связанная с
потоками выглядит скорее здесь нужна ассоциация с какими-нибудь действительно водопроводными
системами когда у вас есть труба поменьше труба побольше пропускается в одной не знаю там три
литра в секунду в другой там типа 10 литров в секунду и так далее вот и вы хотите понять а
сколько вообще вот в этой системе вы можете взять и перевести воду из одной точки в другую
первая точка называется как раз таки источник это считайте что бесконечное количество воды
чего-то еще и есть сток это то что просто всасывает эту воду вот куда-то бы в ней ее испаряет и вам
нужно понимать вообще а сколько максимум воды то я могу передать вот сколько от одной точки в
другую и вот это и есть та самая задача перелистывайте слайдик а смотрите это вот
все что связано здесь потоками с транспортной сетью вот это вот всем очень хорошо формализовать
для того чтобы это как-то использовать какая какое первое приближение такой формализации можно
сделать смотрите как бы транспортной сетью мы зовем некоторые граф вот где у нас будут
определенные вершины и сток и сток буковка с будет исток сток это буковка т вот и ведем
некоторую функцию пропускных способностей причем заметьте это функция пропускных способностей не
от ребер идет от пары вершин то есть сколько я могу не знаю передать какой-то жиджи вот я
думаю вы все играли в minecraft там есть не только вода вы можете там мне передавать там не знать
какие-то соки а есть такое зря так там и лаву можно так передавать все можно делать вот в общем-то
это именно расстояние между парами вершин то есть сколько вы можете передать между парой вершин
какого-то там вот объекта причем если вдруг вашего ребра нету в графе то в этом случае мы
говорим что это просто что вот это пропускная способность между этой парой вершин просто
ноль то есть я не могу ничего передать вот и все как-то так потоком в транспортной сети мы будем
называть некоторую функцию f это функция из двух вершин в какие-то там числа вот а каких двух
вершин до любых на самом деле вот и мы будем смотреть что у нас здесь связано с потоком первое
свойство потока следующее что для любых двух вершин из в принципе у нас поток больше нуля
логично что если мы начали переливать там воду больше либо равно нуля мы передали вот этот поток
между этими вершинами он либо есть либо его нет вы не можете кинуть это в обратную сторону и
естественно он будет меньше либо равен чем пропускная способность потому что если вы
попробуете не знаю какую-нибудь маленькую трубу запихнуть много-много воды но что с ней произойдет
она лопнет я думаю в детстве у всех могло быть такое что вы положили бутылку в морозилку она
чуть-чуть это расширилась вот если стеклянная то она могла разбиться видимо нет это видимо
у меня трудное детство было ладно хорошо пусть будет окей и второе есть свойство
свойство следующее что для любой вершины кроме стока и стока мы говорим что количество входного
потока равно количество выходного потока то есть ни одна из вершин не накапливает вот эту вот то
что вы хотите передать давайте буду так обозначать то есть ни в одной вершине не застаивается потом
и сток и сток он генерирует бесконечное количество какого-то материала сток может
вбирать бесконечное количество материала вот в них оно накапливается само по себе а вот
между ними вот вершины которые мы не можем сказать что у нас там хоть что-то есть определение
понятно она достаточно естественно но оно оказывается неудобным в случае когда мы будем
работать с алгоритмом поэтому будем использовать немного другой но об этом чуть попозже давайте
дальше что еще важно знать из таких вот определений есть величина исходящего потока есть величина
входящего потока оно исходящего это то что выходит из вершины из нашего и стока именно
входящего это то что входит у нас в сток понятно лишь что по числам это одинаковые
чиселки сколько вышло из стока столько должно прийти в сток потому что мы не накапливаем никакие
вершины посерединке все достаточно просто согласны вот чуть-чуть попозже мы докажем это
для другого некоторого определения вот ну грубо говоря на той картинке который вы сейчас видите
между собой вот из стока вышло 2 пошло по пути где 5 максимальная пропускная способность 3 пошло
по пути где было 7 то есть вышло 5 изошло в сток аналогично 5 вот ничего у нас не осталось по
середине окей давайте дальше а что важно здесь понимать важно понимать здесь следующее что мы
исходящий поток и входящий поток сами по себе так они равны будем обозначать просто вот
заметьте модулев не означает что это положительное число будет в дальнейшем мы не будем этого
использовать окей вот это просто вот это обозначение того суммарного потока который у вас будет вот
ну и как бы какая формальная задача формальная задача звучит так для данной транспортной сети
которую мы с вами не знаю там считали что-то с ней сделали и так далее необходимо найти
максимальный такой вот путь для того чтобы был максимальный поток ну вот мы argmax там максим да
да да да то есть как нам нужно это сделать вот и как вообще с этим жить вот такая вот задача какой
первый алгоритм приходит вам в голову или не приходит что-то типа прима по минимальном идти
хорошо а дальше окей а еще есть какие-то дать самое простое что приходит коф
в эф что еще раз перебор кидываем один кидываем два кидываем три и так далее
бинарный поиск по ответу такой понял хорошо а бфс что сделается бф оценку
самое простое действительности самое простое давайте попробуем следующим образом частично
будет связано с бфс но мы дойдем до этого чуть попозже пусть у нас будет некоторые некоторые
наши транспортная сеть и мы найдем какой-то путь вот я нашел в этой транспортной сети какой-то
путь сколько максимум воды могу налить минимальное ребро давайте это и попробуем сделать это будет
жадный такой алгоритм можно перелистывать вот там слово план написано давайте найдем некоторые
вот этот вот произвольный путь из истока в сток и вот бахнем по максимуму сколько можем воды и
будем повторять эти действия пока у нас этот путь будет находиться алгоритм сам понятен что мы
хотим сделать просто выглядит вроде просто кто понимает чем беда вы читаем конечно вы читаем то
есть у нас остается какое-то место мы пытаемся идти ну мы будем все пути проходить
два пути 1 так хорошо и чего
вот тебе два пути
5 3 3 3 3 почему нет смотрите я нашел один путь давайте еще раз закидываю здесь у меня 3 из 5 здесь
3 из 3 здесь 3 из трех я такой ага хорошо а теперь я такой максиме могу вот здесь два осталось здесь
3 здесь три значит я делаю 5 2 2 да да да конечно мы обновляем нашу весовую вот эту функцию там
может еще быть бак кто-нибудь представляет видит абстрактно назовем так нет так нельзя так не
интересно но вот если я буду просто жадно находить вот эти вот пути в чем у нас будет
проблема и будет ли она вообще давайте я нарисую то что вообще сломает систему полностью нам
нужен максимальный поток
пока здесь максимальный поток 2 то есть я вот так должен повести вот так повести вот это
верно теперь смотрите я взял и вот сказал что вот эти вот я же любой путь беру я взял вот этот
путь у меня здесь один есть один есть один могу ли я еще прокинуть вот понимаете в чем беда
здесь жадным алгоритмом можно дальше вот какой изъян в плане а именно вот такие вот плохие какие-то
вещи у нас появляются и хочется сделать что-то с ними таким вот образом чтобы вот это мы могли
как-то отменять потому что я хочу сделать здесь два здесь два логично логично вот что-то с этим
необходимо подумать и придумать поэтому здесь у нас получаются какие-то вот такие вот вещи так
это можно избежать давайте дальше смотрите а давайте ведем более удобное правило более
понятной и нет не более понятная более удобная с точки зрения алгоритма давайте ведем так так
называемый симметризованный поток что это такое смотрите я буду говорить следующее если я пустил
воду в одну сторону то пусть в обратную сторону льется отрицательное число то есть грубо говоря
вот у меня есть обратный какой-то поток у него пропускная способность ноль согласны правда вот
но будет минус один еще то есть если я один сделал по ребру то в этом случае я обратно пускаю отрицательный
поток отрицательный вот эту весовую у меня все выполняется то есть у меня выше чем пропускная
способность ничего не делается и все хорошо чем это полезно ну вот если тут прям дорисовать то
тут будет 0 0 ну и так далее давайте какую-нибудь большую картиночку сделаем чтобы можно было
красиво рисовать
я говорю что у меня здесь один здесь один здесь один здесь один
и вот здесь вот а здесь у меня как бы 0 0 0 0 и 0 все обратную сторону у меня ничего не
происходит и вот здесь я буду сделать следующее что как только я по одному из потоков делаю
что-то то есть пропускаю вот эту воду грубо говоря в один из по одной из по одному из
пути то в этом случае я пускаю грубо говоря обратный поток с отрицательным значением тогда
у меня суммарно оно будет хлопаться грубо говоря поэтому здесь если я сделаю один один и вот
здесь один в этом случае у меня здесь будет минус один а минус один здесь минус один согласны
фактически потоком мы назовем все также функцию из вершин из пар вершин какие-то числа мы говорим
что если у меня есть поток в какую-то одну сторону то в обратную сторону идет отрицательный кроме
того все весь этот поток он всегда не больше чем пропускная способность который у нас есть что
тоже логично минус один меньше нуля один меньше единички меньше либо равен согласны как бы ничего
пока не нарушается вот и последнее я говорю что суммарно вот суммарно если я смотрю поток в
какой-то вершине в конкретной то из нее выходит ноль в ней опять же ничего не застаивается то есть
благодаря вот этой вот симметризованные штуки я получаю вот такую вот вещь чем это полезно как
вы думаете да то есть смотрите в случае если я пойду вот таким вот образом у меня вот
здесь сколько осталось пропускной способности 1 0 минус минус один один то есть смотрите я
могу взять и пойти по вот этому пути согласны потому что вот здесь у меня 0 единички и вот
здесь 0 я могу сделать вот так вот так и вот так и пустить единицу потому что если я прибавлю
единицу то у меня ничего не изменится ну изменить то есть вот здесь будет единица вот здесь будет
ну и с 0 здесь будет единица ага понятно что входит в понятие симметризованного потока и зачем я
это вел вот а фактически отличие от предыдущего определения почти никаких кроме вот этого вот
обратных ребер которые у нас есть принято хорошо тогда если нет вопросов давайте дальше то у нас
здесь будет происходить давайте докажем что у нас величина исходящего потока равна величине
входящего потока а как это сделать ну смотри достаточно просто согласны ли вы с тем что если
я возьму потоки во всех вершинах абсолютно во всех которые у нас есть то в этом случае оно
эта сумма всех потоков равна нулю потому что у нас как бы мы туда смотрим и сюда смотрим
смотрим сколько выходит входит все достаточно просто а и сток со стоком они будут друг друга
заменитажать по факту окей давайте возьмем оттуда отдельно из этой суммы вытащим следующее что мы
возьмем всю сумму от всех стоков и стоков и посмотрим еще и выделим сумму всех и стоков то есть
все что входит то есть я смотрю все что выходит из s и все что входит в те я смотрю сколько максимум
я выливаю воды сколько я вливаю воду и у меня остается еще некоторая сумма сумма сумм по
всем вершинам кроме вот первая сумма у меня идет кроме вершин s и t а теперь смотрите у меня давайте
у меня вот здесь вот кроме вершин там в без ст грубо говоря здесь у меня сумма по всем у из в
ему вот это равно
почему
мы говорили с вами что вершине не должно ничего застаиваться в действительности мы можем с вами
открыть предыдущую предыдущий слайд там третьим свойствам написано что для всех вершин для всех
вершин вот из этого множества мы говорим что вот эта сумма это ноль согласны тогда получается
следующее что сумма потока из вершины s и сумма входящего потока вершину t в сумме они дают 0
хорошо а теперь давайте я хочу понять сколько у меня сумма входящего в s и входящего в t а теперь
я разворачиваю просто у t что у меня теперь не входит а выходит потому что я могу вот это правило
симметричности здесь делать сколько входит столько и выходит ну то есть тут один тут минус один я
меняю знак получаю что у меня сумма по всем f от su минус сумма по всем вершинам из у т по всем у
который у нас есть она равна 0 значит эти потоки равны все достаточно просто есть ли вопросы к этому
доказательству утверждения нет очень сложно без презентации но надеюсь вы все видите теперь давайте
следующий слайд почему вообще симметризация вот это решает проблему того что у нас есть мы
немножко с вами говорили на тему того что у нас происходит можно еще один слайд сделать ну все
очень просто в этой симметризации мы можем исправлять вот те самые плохие ручейки которые
у нас есть вот эти вот плохие вот обходы которые у нас были потому что мы можем ходить теперь
обратно мы можем в одну сторону и в другую ходить и и наши потоки как раз таки делать кстати вот
здесь должно стать 0 я прошу прощения ошибся потому что если мы провели вот так здесь минус
один на ноль пустился значит здесь мы прибавили здесь убавили понятно что еще раз нужно
нужно
теперь когда мы смотрим на этот граф можем ли мы что-нибудь еще пустить мы скажем что не можем
окей вот в общем-то все достаточно просто теперь поехали дальше перейдите там на два слайда вперед
рифметика потоков как это вообще все работает смотрите мы ведем еще одно понятие которое
называется остаточной сетью для графа какого-то же а вот у нас есть граф же остаточной сетью
жи называется вот такая вот тройка е в и цен и поток f вот у нас вот есть некоторые графы на
нем задана вот это вот функция пропускной способности у нас есть некоторые потоки f и вот
остаточной сетью для него называется такая вот тройка f и е ф цф и вот этого тройка она
формирует следующим образом вы еф они фактически такие же будут как и у предыдущего графа с точки
зрения того как они выглядят но единственное что если вдруг у нас есть некоторый поток то в этом
случае мы с вами смотрим вот эту остаточную пропускную способность то есть вот это цф она
равна ц-ф ну давайте какой-нибудь граф нарисуем пустим какой-нибудь поток и вы поймете что я имею
в виду пусть у меня есть вот такой вот какой-то граф диктуйте какие чиселки ваш любимая 3 4 5 6
1 2 на хорошо смотрите предположим что я пустил некоторый поток вот поэтому своему графу пока
вот не смотрю симметризацию ничего а ну что я могу сделать но давайте я предположим сделаю
следующее здесь я пущу один здесь один вот сюда это один беру есть мне будет один а еще я пущу не
знаю здесь я захотел не полностью его пустить например а вот два два два вот так что у меня
будет здесь с точки зрения остаточной сети смотрите статочная сеть будет выглядеть
следующим образом так так так вот смотрите тех предыдущих я во-первых вычитают те потоки
которые уже идут поэтому у меня здесь будет два здесь будет 4 здесь будет 0 и фактически этого
ребра как будто бы нет в моем уже графе здесь будет 1 здесь будет 15 4 2 но кроме того я пускаю
обратные потоки с какими-то конкретными значениями если у меня было в одну сторону один то я пускаю что
у меня в обратную сторону двигается если у меня было вот в ту сторону тоже один я вот в эту сторону
если у меня здесь было два то я в обратную сторону делаю два у меня это выглядит вот так вот и вот это
будет называться как раз той самой остаточной сетью то есть мы с вами просто берем а строим нашу
симметризованный граф и вот когда мы ставили там отрицательные чиселки это как бы одно один
второй вариант давайте строить прямо остаточную сеть и как будто бы можем пускать что-то назад
чем это нам помогает это нам помогает просто работать действительно положительными числами
часть всего они целые потому что с не целыми очень сложно работать spoiler здесь но в тоже
время у нас вот есть этот остаточная сеть где мы можем еще пробовать искать пути вот
будем искать пути будем пробовать что-то переделывать будем запускать новые потоки
и будем опять что-то делать. Вот. Это называется вот той самой остаточной сетью. Понятно?
Следующий слайд. Какие есть две вещи про остаточную сеть и, в принципе,
про транспортную сеть, которая у вас есть? Пусть у нас есть некоторый поток в g, а h – это
некоторый поток в нашей остаточной сети gf. Тогда, если я беру поток с вами из действительности,
из своей транспортной сети, плюс добавляю поток некоторые в остаточной сети, то сумма этих
потоков является потоком в g. Причем сам по себе этот поток, он может разбиваться. То есть,
вот этот вот модуль, грубо говоря, выкидывается. Суммарный поток, он будет равен сумме этих потоков.
Почему так сложно? Почему я не мог, к примеру, сказать следующее? Как вы думаете, почему я не
мог сказать, ну пусть у меня поток f – это в g, пусть у меня h – это поток в g,
почему я не могу сказать, что f плюс h – это поток в g? Ну ладно, почему это не так?
Может. Смотрите, в действительности, как бы не забывается транспортная сеть,
называется просто вот эти числа, поставленные, ну мы ставим их на ребра, они между парами сидят.
Ну, представьте следующий случай. У меня здесь вершина, здесь 1. Согласны, что поток 1 является
здесь нужным мне. Правда? Согласны, что поток 1 является потоком здесь. Но вот поток 2, кажется,
не подходит сюда. Правда? Что-то в этом есть, правда? Какая-то здесь изюминка скрытая. Нужно
подумать, размыслить, вечером выпить чаю и вот пофилософствовать. Но в действительности, как бы,
вот это нам не подходит. Но если мы говорим про остаточную сеть, что у меня h именно в остаточной
сети, тогда в этом случае мы говорим, что вот это уже будет правдой. Как это проверить? Проверить
все достаточно просто. Давайте сложим эти два потока и проверим три свойства, которые у нас
есть. То есть вот определение у нас состоит просто из трех свойств, которые нам необходимы. Первое,
мы говорим, что для любой вершины v и u это должно являться потоком. То есть оно, давайте я буду
чуть-чуть здесь писать, повторять вот то, что там написано. Чтобы вам было проще.
Вот. А что я говорю здесь? Я говорю здесь следующее, что для любой вершины v и u. Как
звучало первое свойство? Кто помнит? Нет, это не первое свойство. Давайте вот отталкиваемся
назад. Вот идем. Там было сказано следующее, что у нас поток из u в v равен минус потоку из v в u.
Но обратная симметрика. Вот в симметризованном потоке. Мы ввели же это понятие, правда? Вот.
Ага. Вот. Тогда, поэтому возвращаемся сюда. То есть мне нужно доказать, что вот это вот есть
обратное. Ну, то есть я должен сказать, что у меня f от v в u плюс, ой, h от v в u. Чему равно?
Вот вы смотрите на презентацию, не понимаете буковки или смыслов. Давайте типа со смыслами
разберемся. Смотрите, согласны, что вот это вот тот самый поток f плюс h, правда? Вместе. Давайте
их рассмотрим раздельно. Ну, как бы скопки-то могу эти глобальные снять, правда? Вот. Получаю это
просто два потока f от v в u плюс h от v в u. Согласны, что вот это является потоком и вот это является
потоком? Логично. Значит, для них работают те самые свойства, которые были. То есть я говорю,
что это минус f от u v минус f, ой, h от u v. Ну, теперь, смотрите, я выношу этот минус и получаю здесь
f от u v плюс h от u v. Вот. То есть, смотрите, вот это равно минус вот это. Потоки, первое
свойство, вот это доказано, которое у нас есть. За вторым свойством нам нужно доказать, что у
нас он не больше, чем пропускная способность. Как это сделать? Почему это не больше, чем пропускная
способность? Так. Ну, вот там вот такая формула. f равно c минус f. Фактически это то, что у меня
написано h от u v, равняется c минус f от u v. Согласны? Вот. Ну, на самом деле, это поток меньше
либо равно. Да, у нас же это поток. Тут если бы c стояло, то да. Поток не больше. Ну, вот. Перенесите
это сюда, получится меньше либо равно c. Работает, работает. Отлично. И последнее, что у нас есть,
что для левых вершин, которые не являются стоком и истоком, мы говорим что? Что сумма всего потока
равна нулю. Ну, давайте эту f плюс h, типа, возьмем какой-то вершины v, как это разбивается? Ну,
мы возьмем поток f, возьмем поток h. Ну, мы говорим, что это и там, и там является потоком, поэтому это
там ноль, и там ноль, сумма нуля и ноль. Понятно? То есть, вот это правда. Вы должны запомнить следующее,
что если вы хотите добавить какой-то поток, то в этом случае вы смотрите на остаточную сеть,
и в этой остаточной сети ищите какой-то путь и добавляете его к первому потоку, который есть. И
тогда у нас все хорошо. Про разность потоков, аналогичная ситуация почти что. Мы говорим,
что если у нас есть два потока v, каких-то, тогда их разность лежит потоком в остаточной сети. То
здесь ситуация чуть-чуть наоборот. Мы должны взять два потока из обычной сети транспортной,
тогда их разность будет лежать в остаточной сети. Окей? Доказывается, полностью аналогично,
ничего не меняется. Давайте дальше. Ну и теперь мы переходим к первому алгоритму. Алгоритм
Фордов-Халкерсона. Он работает вот ровно на тех леммах, которые мы сейчас с вами озвучили.
Пусть у нас в начале поток равен нулю. Ну, то есть у нас просто существует транспортная сеть,
у нас есть остаточная сеть, которая совпадает с транспортной сетью. Согласны? Вот ровно такая же.
Давайте в этой остаточной сети найдем какой-то путь. Любой. Как можно найти путь? Ну DFS вам
в помощь. Давайте DFS, найдем какой-то путь из S в T. Это вот проход. Не знаю, типа вот,
смотрите вы куда-нибудь, типа на какой-нибудь корпус, вы хотите туда дойти, вот вы как будете идти?
Ну вот смотрите, ну как-то вот по дорожкам идете. Вы не думаете про кратчайшие пути, хотя вы думаете
немножко про кратчайшие пути, но все-таки простраиваете маршрут просто по видимым каким-то
элементам. Вряд ли вы пойдете типа вот так вот по диагонали через дорогу, когда едут машины.
Не прикольно будет, правда? Вот. Поэтому здесь в действительности мы с вами находим какой-то
путь. И дальше, так как мы нашли этот путь в нашей остаточной сети, давайте пустим там максимальный
поток по этому пути, то есть минимальное ребро возьмем. И так как это является потоком в остаточной
сети, то я его могу добавить в свой основной поток. Согласны? Ну вот по предыдущей лейме как раз.
Ну и все. После этого давайте повторим еще раз. Мы обновили остаточную сеть, мы получили с вами
новую транспортную сеть и опять повторяем. И повторяем до тех пор, пока мы находим тот самый
путь в нашей остаточной сети. Понятно пока как это выглядит? Хорошо. Вот этот путь сам по себе,
который у нас есть, он является дополняющим путем. Такой вот дополнительный поток, грубо говоря,
который вы ищете. И что есть интересное? Есть проблема с этим алгоритмом следующая, что она
будет зависеть от максимального потока. Потому что здесь, ну как бы как вы ищете вот эти вот пути,
оно может искать как раз таки и проходить через этот максимальный поток. То есть мы каждый раз вот
будем вот впихиваться и делать. Максимум, ну то есть самый худший случай, когда мы по единичке
добавляем какой-то в наш поток. А если вдруг вас кто-нибудь спросит, не знаю, ночи разбудит его и
спросит, а приведите мне контрпример для алгоритма Форда Фалкерсона, когда он работает очень долго,
что вы должны ответить? Мы уже с вами рисовали такой граф.
Представьте, что не знаю, тут 10 шестой, 10 шестой, 10 шестой, 10 шестой, один. Я буду вот так схожу один,
вот так схожу один, вот так схожу один, вот так схожу один. И буду бесконечно это делать,
по сути, ну 10 шестой раз, точнее, 2 на 10 шестой. Потому что я буду выбирать вот, ну как бы не оптимальные
пути. Сначала я пойду вот так, потом у меня в остаточной сети появится ребро обратно один,
согласны? А тут будет ноль. Я пойду в обратную сторону, вот так один. И так я буду повторять,
повторять, повторять, повторять постоянно. И вот это является, по сути, контрпримером
к алгоритму Фалкерсона. В зависимости от того, как вы ищете этим DFS. DFS же в любую сторону
ходит. И для него не важно, мы ищем какой-то путь, и не крочайший, например. Согласны? Вот из-за этого у
нас возникает эта проблема. Поэтому здесь эта работа за O от E умножить на F max. Откуда E получилось?
DFS. Мы DFS запускаем много-много раз. И все. Окей? Тя проблема в том, что это не полимиальный алгоритм
сам по себе. Что это означает? Это означает, что он не зависит от входящих значений, он зависит от
результата. Мы не можем предсказать, сколько это будет работать. Поэтому алгоритм Форда Фалкерсона
как бы не то чтобы самый-самый крутой, но он рабочий. Вот. Перелистывайте дальше. Для того, чтобы
доказать, что алгоритм Форда Фалкерсона работает, сам по себе нам нужна некоторая теорема Форда
Фалкерсона, которая звучит следующим образом. То есть мы должны доказать корректность. Как это
доказать? Ну давайте мы скажем, что наш поток будет максимален тогда и только тогда, когда в
остаточной сети у нас нет дополняющего пути. То есть мы не можем найти путь из S в T. Ну как бы
давайте рассуждать в одну сторону. Пусть у нас есть максимальный поток в нашей транспортной сети.
Вот это F. Хорошо. Допустим, что у нас есть какой-то дополняющий путь в нашей остаточной сети. Вот он
есть и его размер больше нуля, потому что мы его нашли. Отлично. Тогда по лиме потоков я говорю,
что F, который у нас является максимальным плюс H, это поток в G. Мы же доказывали с вами это,
доказывали отдельно. А значит F не был максимальным. Беда. Противоречия, к которым мы пришли. Теперь
в обратную сторону. Пусть у нас есть некоторый максимальный поток. Мы говорим, что в GF нет
дополняющего пути. Вот у нас есть этот максимальный поток. Хорошо. Какой-то, который не равен нашему F.
Тогда в этом случае мы говорим, что Fmax-F, вот максимальный, который существовал в нашем G, пусть он не
такой, то он больше либо равен нуля. И по разности, по лиме разности этих потоков мы говорим,
что они просто сами вычитаются друг из друга, они больше либо равны нуля. То есть Fmax-F больше
либо равен нуля. Это первое мое предположение. Отлично. Но мы с вами знаем, что в GF нету дополняющих
путей. Что это само по себе означает? Это означает следующее, что я не могу провести ни одно h,
которое мне необходимо. И вот в лиме разности путей мы говорили, что разность потоков в нашем
транспортной сети, она создает поток в остаточной сети. Если потока в остаточной сети нет, значит он
равен нулю. Меньше нуля. Ну вообще равен нулю. Значит у нас эти потоки равны. Это алгоритм Эдманса
Карпа. Аналогичен тому, что у нас происходит с алгоритмом Форда Фалкерсона. Кроме одного факта,
какого? У нас вместо DFS становится BFS. Все. Буковку поменяли, создатель поменялся. И как бы алгоритм
сам поменялся, теперь это новый алгоритм. И удивительный факт следующий. Если мы с вами
будем запускать не DFS и искать рандомные пути, а BFS, то в этом случае у нас с вами будет все работать
неплохо в этом случае. И оно будет работать полимиально. Мы будем работать с вами за VE квадрат.
И это мы с вами сейчас будем доказывать. Все, что у нас есть. Я там тоже все чуть-чуть поехал.
Смотрите. Следующий слайдик можно. Лемма звучит следующим образом. После каждой итерации,
то есть шагов 1 и 2, когда мы вот ищем путь и выкидываем его из остаточных путей, длина
кратчайших пути в смысле количество ребер, вот именно количество ребер. Не потому, что мы тут
смотрим какие-то веса, есть ребер, ничего такого нет. Просто именно количество ребер. Оно не убывает.
Все только возрастает. Либо остается таким же. Но как это сделать? Ну смотрите, если у меня было
некоторое ребро в остаточной сети и я нашел поток по нему, вот я нашел вот здесь поток,
что у меня произойдет с транспортной сетью в этот момент? То есть я вот нашел какое-то
ребро, по которому я нахожу этот путь. У меня здесь станет ноль, и я убираю это
ребро, правильно? Какое-то минимальное. И пускаю в обратную сторону. Вот. То есть фактически у меня
два случая возможны. Первое, я беру и убираю ребро. Второе, я добавляю ребро обратное. Согласны?
Вот. Обратное относительно того пути, которое было.
Если мы его убираем, мы обязаны его добавить. А это не совсем всегда правда. Смотрите. Вот у
меня видите, вот здесь ребро ноль, его пока нет. Вот. А представьте следующую картину. Ну вот у меня
вот здесь вот четыре. Вот здесь у меня было ноль. Было бы. У меня не было этого ребра. Вот только я
пустил сюда, у меня добавилось ребро. Вот. То есть оно просто взяло и само добавилось. Не обязательно,
что я должен был убрать ребро. У меня же остаточная сеть, она первоначально равна транспортной сети,
всей которой было. Поэтому максимум можем вот такие вот два случая разобрать. И два случая
смотреть. Поехали дальше. Нам нужно показать, что при удалении или добавлении ребер мы не могли
взять и уменьшить кратчайшие пути. Но как это сделать? Ну если мы удалили ребро, вот мы нашли
какой-то кратчайший путь. Мы же BFS-ом ищем кратчайшие пути. Если мы нашли с помощью этого кратчайшего
пути. Какое-то... Мы нашли какой-то кратчайший путь и удалили ребро из этого кратчайшего пути.
Согласно, что у нас не мог уменьшиться кратчайший путь. Вот у нас он был, там не знаю, из пяти ребер.
Вот я удалил ребро и такой, а я нашел новый кратчайший путь из четырех ребер. Кажется это странно,
потому что до этого я искал тоже кратчайший путь. Поэтому я мог его только увеличить. В случае
добавления ребер, мы можем рассуждать чуть-чуть по-другому. Вот у нас есть некоторый путь.
И так далее. Представьте, что я добавляю новое ребро в обратную сторону. Вот это убираю. Ну или не
убираю, а добавляю просто. Вот. Что у меня происходит? Ну вот у меня когда добавилось какое-то новое
ребро, у меня появилось там, не знаю, новое расстояние вот это РОС от С до В. Вот мы это делали.
Отлично. А у меня была какая-то вершинка У, стал какая-то вершинка В. Вот. А мне нужно прийти
в эту вершину В. Первоначально мы говорили с вами, что мы можем вот это вот ребро убрать,
там добавить какое-то новое. То есть у нас есть предыдущий путь, оно никак не влияет. Согласны?
Вот. Поэтому здесь я могу четко и уверенно себе сказать следующее. Что у меня при добавлении было
так, не знаю, РОС от С до В до У. Штрих. Тут РОС штрих. Плюс один. В чем плюс один? Вот это еще одно
ребро, которое у меня было. Согласны? Вот. Отлично. Вот это получилось. Согласны ли вы,
что при добавлении обратного ребра, вот это РОС от С до У, не могло тоже уменьшиться. Вот. Поэтому
оно из предыдущего, я говорю, что вот это больше либо равно. Тут я так пишу криво, но как есть.
Больше либо равно, чем РОС от С. У плюс один. Вот. Ага. Стриховая, да, это когда, да, РО. Вдруг он есть
вот как-то вот так. У меня же новые кратчайшие пути могли появиться. Я одно ребро убрал,
получил новое. Одно ребро добавил, у меня получился какой-то новый граф, там могло быть другое что-то.
Так вот, вопрос. А, я понял. Вот это правда это или нет? А что там будет?
То есть ты хочешь сказать, что здесь будет больше? Больше. А меньше могло быть хоть раз?
Сейчас спроси. Меньше не могло быть. А больше? Да ладно. Кратчайший путь мог. Или не мог? Да.
Да, здесь смотрите, вот это вот равенство, оно возникает в случае, если мы не убираем это
ребро. Мы говорили только про добавление, добавление может произойти без убирания.
Да. Вот. Поэтому оно так. Окей. В этом случае мы говорим, что ну мы же только это ребро добавили,
правильно? Все остальное не трогали. Поэтому я говорю, что это больше, чем РОС от С. У плюс один. Вот. А почему
это равно РОС от С. В плюс один плюс один? Или точно ли это так? Вот у меня есть РОС от С. У и вот у меня
там написано следующее. РОС от С. В плюс один плюс один. Что вот это вот равно. А? В действительности мы можем
сказать следующее. Смотрите, у нас кратчайший путь, вот когда мы не добавляли никакие ребра,
проходил через У в В. Правильно? Вот последний шаг такой был. Вот это РОС от С. У плюс один. Оно что сделает?
Оно фактически добавляет новое ребро. Ну вот. А действительно следует плюс один? Не надо. Вот.
Просто это будет больше, чем РОС от С. В. То есть мы все равно увеличиваем, не убиваем с точки зрения вот
этого кратчайшего пути. Нам главное следующее, что мы здесь получили. Мы получили с вами следующее,
что РОС от С. В. Оно будет больше либо равно, чем РОС от С. В. Вот РОС, которое новое, здесь старое.
Понятно? Окей. Смотрите. Давайте поймем, за сколько работает алгоритм advanced carp. Как нам это сделать? Ну,
для начала мы введем такое понятие, как критическое ребро. Что такое критическое насыщение? Ну,
представьте, не знаю, что у вас есть некоторые от У до В. Не знаю, там, какой-нибудь пропускной
способностью С. И вы пустили поток С. Вот это называется критическим. Вы же нельзя. Вот. И мы
говорим с вами следующее. Вот в данной теореме Эдмонса Карпа, что в процессе работы алгоритма,
каждое ребро может стать критическим не более чем в пополам раз. Интересный такой вот факт,
замечен был. Что это означает само по себе? Давайте с вами думать. Вы же согласны, что я могу пустить
максимальный поток по ребро, а потом пустить в обратную сторону, потом опять пустить и так далее.
Вот я могу его вот так вот постоянно критически насыщать. Я говорю следующее, что каждое ребро я вот
так вот критически буду насыщать не больше, чем в пополам раз. Почему это так? Ну, смотрите,
пусть у нас некоторое ребро стало критическим, а критическим оно стало в какой-то момент,
когда вот мы нашли вот этот кратчайший путь. И мы говорим, что в этом случае у нас Роатес У
равно Роатес В плюс 1. У нас здесь вот есть некоторая вершинка В, есть У. И мы вот так вот типа
делаем. Вот у нас здесь вот это ребро становится критическим. Мы находим БФС, поэтому находим
вот эти кратчайшие пути. То есть Роатес У равно Роатес В плюс 1. Чудесно. А оно вернется вот данное
ребро в нашу остаточную сеть в каком случае? Только в одном. В случае, если мы с вами... Что сделаем?
Или ничего не сделаем? В случае, если мы направим поток в другую сторону. То есть мы его переноситили,
мы убрали его из остаточной сети. Мы должны сделать поток в остаточной сети теперь в обратную
сторону данного ребра. То есть в случае, когда у нас вот это ребро УВ, не В, а УВ, то есть в обратную
сторону, пойдет в какой-то кратчайший путь. Согласны? Ну потому что я запущу БФС. Правильно? Отлично.
Вот. Ну оно будет лежать на каком-то кратчайшем пути. То есть у нас вот будет вот эта новая
остаточная сеть. Мы делаем этот новый кратчайший путь. Я говорю, что Роатес В...
Почему он равен Роатес У плюс 1? Почему так? Потому что у нас больше нет вот этого критического
ребра, и у нас есть только в другую теперь сторону. Согласны? Отлично. А вот что-то для У поменялось или нет?
Ну максимум, что могло быть при удалении ребра, что увеличится кратчайший путь. Согласны? Поэтому
это больше либо равно, чем Роатес У из предыдущей остаточности. Согласны? Так, а что нам это дает?
Или пока ничего не дает? Понятно ли, откуда вот это хорошее утверждение появилось?
Давайте с вами продолжать. А? Еще раз? Одно действие. Ну, типа того. Ну, вот смотрите, мы с вами
получили следующее. Чили два пункта. Каких мы получили с вами два пункта? Ну, для начала мы с
вами говорим, что Роатес У равно Роатес В один и Роатес Ро штрихатес В, но больше либо равно,
чем Роатес У плюс один. Ага. Согласны? Ну, как бы это то, что мы с вами уже имели. Теперь
смотрите, я, если я пустил что-то обратно, у меня возвращается это ребро. Согласны? Ну, вот это вот
ребро, которое я отменил. Я пустил назад единичку, значит, сюда будет хотя бы единичка. Новое ребро
появится. А в каком случае оно опять станет насыщенным? Критическим. Когда мы опять кинем
типа максимальный поток по этому ребру, правильно? В этом случае я повторю ровно те же действия,
которые делают здесь. Вот ровно те же действия. И что я с вами получу? Я получу следующее, что Ро
два штриха от Су, оно будет больше либо равно, чем Роатес У плюс два. Потому что тут было плюс один,
я сделаю аналогичную ситуацию, получу еще и еще одно плюс один. Ага. Буду так вот увеличиваться.
Вот. Из этих двух пунктов Роатес В, да, но мы ищем до У. То есть мы смотрели до какой-то
конкретной вершинки У. И брали, что перед ней есть вершина В. Вот. Ну как бы в действительности там
нужно применить просто часть СЛЕМ, часть вот этих утверждений, которые у нас здесь есть. Мы получим,
что у нас будет плюс два. Когда она станет плюс два, что это означает? Что у нас между критическим
моментом одним и вторым увеличивается кратчайший путь на два минимум. Согласны? Какой максимальный
путь по длине? Количество ребер может быть. В. Ну В-1, если быть точнее. Ну это когда у нас просто
вот такая вот цепочка. Кратчайшие пути. Роа это же кратчайшие пути? Ну кратчайший путь,
максимальную длину какую имеет? В-1. Ну расстояние между вершинами не может быть больше, чем В. В-1.
Отлично. Ну значит мы делим пополам, потому что у нас плюс два все время делает. Получаем В пополам.
То есть В пополам раз мы делаем каждое ребро критически максимум. Что мы можем делать? Что
нам это даст? Как вы думаете? Ограничение на критическое переполнение. Вот то, что у нас есть. Да,
в действительности у нас после каждой итерации, когда мы будем искать BFS-ом какой-то путь, у нас
каждый раз какое-то ребро становится критическим. Правильно? Вот. Всего ребер у нас Е. Каждый из
них может быть критическим не более, чем В пополам раз. Ну то есть у нас уже Е на В пополам раз
итерации. И в каждую эту итерацию мы запускаем BFS. BFS работает за О от Е. Ну получаем что? Получаем В Е
квадрат. Ага. Есть ли тут вопросы? Нет. Теперь смотрите, у нас с вами осталось 14 минут и у нас с
вами остался алгоритм Диницы. Вот. А, ладно, давайте с вами чуть-чуть поговорим про алгоритм Диницы. Я
попрошу семинаристов с вами ее разобрать, вот это все написать. На самом деле, все алгоритмы пишут
достаточно просто. Там нет никаких проблем в том, чтобы это найти. Смотрите, в чем суть алгоритма
Диницы? Вы там пролесните до алгоритма Диницы, где написано в чем проблема Эдмонса Карп. Смотрите,
мы каждый раз в Эдмонсе Карпе ищем BFS-ом путь, убираем его, потом ищем новый путь. Кажется,
что это не всегда имеет смысл. Почему? Потому что, смотрите, а давайте с вами чуть-чуть по-другому
поступим. Поступим следующим образом. У нас есть некоторая вершина и стока. И что делает BFS?
BFS же находит, по сути, все вершины, которые находятся на расстоянии 1, правда? Потом от них
находят еще на расстоянии 2. И вот он фактически строит вот такие вот слои, которые шаг за шагом,
какое-то там, не знаю, X, они в конце будут все смотреть в наш исток. Согласны? Вот эти слои
будут как-то между собой связаны. Зачем нам выкидывать по одному пути из этого всего,
если я могу найти разные пути между этими слоями? Тут вершинка, не знаю, пойду вот так,
здесь я пойду вот так и так далее. Давайте я сразу буду все пути, которые у меня есть,
переделывать. И в этом случае я возьму и переделаю это, и получу новую статичную сеть,
для которой опять построю свои слои. И это будет делать каждый раз. Смотрите, я буду с самого
начала брать и вот эти вот все пути различные использовать. Можно так делать? Почему нет?
Вот. И вот мы строим эту слоистую сеть, и дальше что мы делаем? Смотрите, ищем все эти дополняющие
пути в нашей слоистой сети из S в T, и обновляем наш поток F. И только после этого, когда мы делаем,
мы обновляем на GF и заново строим вот эту слоистую сеть. То есть мы обновили все слои,
которые у нас есть, и только после этого, когда нет уже нового пути, мы с вами это делаем.
То есть мы будем запускать меньшее количество BFS, чем в Edmund C. Carpe. Но все равно будем
убирать каждый путь по-своему. Окей? Да. А меньше BFS? Нет, нет, нет, нет, нет. У нас есть
некоторые пути вот здесь. Мы с BFS находим эти все пути. Правда? Вот я нашел путь, выкинул его,
нашел путь, выкинул его и так далее. У нас в этой слоистой сети мы можем сказать,
что вот эта вершина с этой, с этой сюда приводит, это с этой, с этой, с этой и так далее. Между 1 и 2
слоистой сети, мне главное найти ребро, и это легко сделать, между 2 и 3, между 3 и 4, между 4 и 5
и так далее. И вот итог будет такой. Подождите, мы же смотрим на конкретную вершину и смотрим на путь от нее
ее в начале в BFS. Нет? Ну вот, не совсем, не совсем. Для того, чтобы найти какой-то
конкретный путь, ты всегда заново запускала BFS в Эдмонсе Карпе и перестраивала свою
остаточную сеть. А здесь ты ее фиксируешь и убираешь путь, фиксируешь,
убираешь путь, фиксируешь, убираешь путь, запоминаешь, ты заново перестраиваешь
остаточную сеть. То есть, ты вот эти слои оставляешь. Ну, фактически, да, только
запоминаем, что мы их убрали, значит, слоистая сеть и новая где-то должна у
вас хранится. И вот пока по этой слоистой сети вы можете идти, все отлично.
Как только нет, заново строите и смотрите. Вот, здесь важные вопросы следующие.
К корректности здесь все просто, оно все работает на тех же теоремах, которые были
до этого. Тут ничего сложного не будет. Вопрос следующий. Сколько раз нужно будет
перестраивать эту слоистую сеть? Сколько времени будет занимать вообще поиск пути
в слоистой сети? То есть, вот то, что ты сейчас задавала, как раз-таки BFS мы будем
опять запускать или нет? И сколько всего путей можно найти в слоистой сети? Ну, как бы,
давайте это все смотреть. На самом деле, сколько раз перестраивать? Не больше, чем
в раз. Сколько времени занимает поиск пути по слоистой сети? Не больше, чем в
а сколько всего путей можно найти в какой-то слоистой сети? Не больше, чем E. Все просто.
Ну, как бы, первое, почему так? Потому что после каждой итерации расстояние от S до T
увеличивает. Согласны? То есть, я выкинул что-то из слоистой сети, вот, и она у меня
перестраивается, у меня путь должен увеличиваться. Значит, у меня максимальное
количество увеличений в пути какое? Ну, это если все вершины выстрою. А по длине?
В смысле или что? Так еще раз, мы же слоистую сеть сначала все обработали, все
выкинули, только потом перестраиваем ее. Мы же не делаем это сразу в моменте. Вот,
поэтому это первый момент, который мы видим. Поэтому здесь не больше, чем V. Второе. Сколько
занимает поиск пути? Ну, мы просто от слоя к слою идем. Это количество слоев не больше,
чем V. Вот, я взял тут вершину, пошел в эту вершину, пошел в эту вершину и так далее. Сколько всего
путей? Ну, не больше, чем E. То есть, между слоем к слою не больше, чем E вершинок. Понятно? Вот.
И тогда в этом случае мы получаем асимптотику V2E. То есть, не V2E, а V2E. Понятно? Вот это и есть
алгоритм Диница. Что у нас есть еще? Давайте там последний слайд, последний слайд. Честно,
не буду рассказывать сильно много про эти алгоритмы. Смотрите, что еще интересно было
по потоку. Ну, существует еще несколько алгоритмов. Есть алгоритм, который работает с
V-куб. И вот в 2013 году появился новый еще алгоритм, который работает с VE. Писать ли мы их будем?
Не будем. Вот. Это такая информация для вас. Интересности всякие. Вот. Но, в принципе,
это на сегодня, скорее всего, все. Всем хорошего дня, вечера, пока-пока.
