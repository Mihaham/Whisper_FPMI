всем доброго дня мы с вами продолжаем изучать наш курс и некоторое добавление мы запустили форму
обратной связи прочитали ее и поэтому некоторые моменты будем внедрять практику значит одним из
требований одной из претензий было того что мы вообще не разбираем примеры кодов паттернов
которые были рассказаны на лекциях наверное те паттерны которые рассказываются на семинарах
вы их смотрите с примерами но вот те паттерны которые рассматриваются на лекции обычно идут
без примеров поэтому давайте исправим этот момент и посмотрим реализацию паттерна состояния мы с
вами в прошлый раз когда говорили про активные классы и диаграмма состояния поняли что у нас
существует такой паттерн как состояние где у нас собственно есть активный объект внутри которого
вот и здесь у нас как раз есть пример значит когда можно понять всю элегантность паттернов
элегантность паттернов можно понять тогда когда вы смотрите мэйн файл который показывает
взаимодействие с этим объектом что мы здесь видим с вами давайте попробуем прокомментировать
этот код да мы видим светофор в котором какие методы что что это светофор делает
да смотрите он меняет цвета и он умеет печатать свое собственное состояние хорошо давайте
посмотрим на реализацию traffic light точнее пойдем на посмотрю реализацию методи change color и что
мы здесь видим мы с вами видим что здесь у нас давайте параллельно буду рисовать диаграмму
traffic light у нас есть метод change color он возвращает void но что у нас есть у этого
светофора у нас у этого светофора есть указатель на так да да да да да тут такое тоже бывает
шофс на что мы получаем вот у нас есть state который указатель на state pointer то есть у нас
вами есть некоторый объект state pointer и у нас он его содержит при этом здесь связь один к
одному значит это у нас вами получается объект вида state я прямо перерисовываю код vml диаграмму
значит в чем реализация заключается метода change color у стейта есть метод switch
который при этом принимает объект вида traffic light вот значит как это возможно давайте
сразу обсудим почему это возможно потому что у нас указатель на this есть и нам не
нужно переоперировать класс то есть получается у нас с вами у state pointer есть реализация метода
switch а теперь давайте посмотрим что это за switch и мы видим с вами поскольку работает здесь
visual studio code то у нас с вами есть три реализации этого метода то есть если мы с вами откроем
наш стейт стейт вот он класс стейт а стейт поинтер это у нас с вами этот указатель на стейт
звездой со звездой давайте покажу вот это уник птр на стейт и смотрите что дальше у нас с
вами происходит у стейта все методы виртуальные то есть по факту может считать что это интерфейс
либо абстрактный класс в зависимости от того это у нас роль либо это у нас объект классической
реализации паттерна у нас идет как раз это абстрактный класс значит и дополнительно здесь
стоят forward declaration чтобы мы с вами могли правильно указывать реализации цветов потому почему
почему важна реализация цветов потому что когда мы с вами запустим реализацию метода
свой метода switch то давайте рассмотрим вот такой метод то есть нам все равно нужно будет с вами
указ создавать объекты классов то есть у нас с вами будет три наследника этого класса это ело
это ред и это грин то есть у нас с вами создаются вот такие объекты значит и у объекта ело есть
метод значит реализация метода switch который делает следующее он берет и устанавливает нашему
светофору который здесь есть состояние на красный то есть получается каждое состояние при
определенном триггере переходит в другое состояние устанавливает светофору это состояние вот мы
вызываем 13 строке конструктор класса а дальше мы устанавливаем это состояние то есть как бы
по факту можно считать что после того как это состояние у нас отработала она у нас уничтожается
да потому что мы работаем с уникптерами после выхода из этого после того как у нас количество
ссылок на объект становится равно нулю у нас объект уничтожается вот и в итоге у нас получается
наша цель будет следующим вызывать метод change color change color у так это класс у нас состояние не
стоит pointer у класса состояния будет вызываться метод switch а метод switch будет переставлять
конкретное состояние вот вот в итоге получается элегантным и давайте как раз его запустим значит
у меня как раз тут есть и мэйк так вопрос разом на семинарах рассмотрелись и мэйк
хорошо все мы компилируем стоит и давайте мы его запустим вот смотрите вот у нас метод
принц стейт он нас выводит просто состояние direction и калор мы начинаем с вами с красного
потом переходим на желтый потом переходим на зеленый и печатаем при этом direction у желтого
цвета значит у когда мы ставим с вами зеленый цвет то у нас direction стоит на красный направление
цвета стоит на красный и мы с вами указываем direction 1 и в итоге мы с вами поменяли код как
раз 10 раз поменяли светофор каким образом можно усложнять эту динамику процессов вы наверное
большое количество раз переходите светофор который из рядом сынка стоит в чем его особенность
смотрите у этого светофора на самом деле было несколько поколений вы не застали когда он по
кнопке активировался раньше он активировался по кнопке то есть был внешний триггер который
давал тайм-аут на то что у вас изменится состояние этого светофора то есть мы можем
ставить триггер по времени ну ладно это еще не пол беды большее количество светофоров сейчас
адаптированы под какой момент времени под какой момент зависит ли время желтого время зеленого
и красного цвета от времени суток да зависит причем на некоторые некоторые светофоры делаются
именно такими для того чтобы оптимизировать трафик допустим если вы посмотрите на светофор
который идет на пересечение как называется институтского переулка и первомайской то в
зависимости от соответственно времени суток он показывает разные интервалы на красный зеленый
цвет нам по моему в какие-то моменты 50 секунд в какие-то моменты это 80 секунд то есть как бы
мы можем менять состояние в зависимости еще от момента времени то есть в принципе можем
передавать момент времени для этого состояния вот то есть вот такая реализация паттерна стоит
просили вы просили реализации паттерна мы с вами их будем смотреть как раз так хорошо давайте
тогда вопросы по этой по этой части понятно ли реализация если непонятно спрос спрашивайте
глупые вопросы тоже можно задавать мы говорили что как раз паттерн состоит в том что мы скрываем
детали перехода из одного состояния в другое то есть у нас получается как раз есть светофор значит
это активный класс внутри него есть набор состояний мы могли бы писать вот эту всю логику так что вот
у нас есть объект типа калор а дальше писать значит если калор красный переходим в желтый
если цвет желтый переходим зеленый а здесь мы по факту логику изменения цветов делегируем
от самого светофора к объекту который отвечает за состояние за состояние и в зависимости от того
объекта состояние которое у нас стоит красный желтый и зеленый сам объект определяет логику куда
ему переходить вот в этом особенность паттерн то есть у нас не получается большое число ифов то есть
если мы перейдем в реализацию красного цвета там все достаточно просто все останавливаем
состояние желтый устанавливаем направление на зеленый цвет то есть именно красный говорит типа
куда желтому двигаться мы допустим можем поставить ограничения в какие состояния не надо переходить
или через какое время переходить так хорошо еще вопросы
состояние стоит мы как раз в прошлый раз говорили про диаграмму состояний
поняли что нам нужно использовать диаграмма состояния тогда когда у нас есть активный класс в
котором должны переключать состояние и вот это реализация того как это можно сделать
так еще вопросы если вопрос нет давайте мы с вами продолжим сейчас мы начнем точнее продолжим
новую тему которая называется тестирование и в прошлый раз мы детально с вами что-то мне
тут кажется проблем с цветпередачей у этого проектора да будут цвета так давайте тогда
вот этот грамм чуть побольше сделаю значит смотрите мы сегодня будем говорить про тестирование по
и большую часть времени мы как раз будем посвящать некоторым практикам тестирование по сразу скажу
что сейчас будут начинать семинары по тестированию параллельно с лекциями но некоторые моменты я
тоже буду рассказывать на лекции чтобы было именно интересно с точки зрения практической
составляющей значит давайте мы с вами в прошлый раз поговорили про объекты тестирования то есть
у нас будет функциональный не функциональный тестирование дальше мы можем с вами сказать
следующую вещь мы можем с вами это виды тестирования по доступности кода какие бывают
первая вид тестирования который на самом деле очень сильно вам знаком это тестирование черного
ящика это означает что у вас есть код какой-то функции выпадает у вас есть какие-то входные
данные вы запускаете функцию получаете результат у вас результат функции сверяйте с готовым
ответом то есть то как обычно происходит тестирование во всяких задачах по алгоритму это
черный ящик. Если мы говорим про тестирование белого ящика, это интересный момент, вы видите
весь код, который у вас есть, у вас есть структура кода, вы прямо смотрите и пытаетесь понять, что в
вашем коде не так. И как раз метод тестирования белого ящика заключается в том, что вы проходите
специальными инструментами, возможно запуская код, возможно не запуская код и смотрите его
качество. Значит, если понятие, которое позволяет нам это сделать, это статический анализатор кода,
они у нас существуют. И давайте я спрошу, знакома ли вам такая аббревиатура, как PEP8?
Наверное, если вы сейчас проходите курс по Python, то вас заставляет все писать по PEP8,
ну по крайней мере должны. Вот, есть инструмент, который называется Flake 8, который позволяет вам
запустить как раз код и проверить его на консистентность. Давайте в качестве эксперимента
мы это с вами попробуем сделать. Так, давайте я какой-нибудь это, возьму какой-нибудь virtual
length, я использую, вот, и прогоним инструмент Flake 8, допустим на... Так, он ничего не вывел,
значит у нас все хорошо. Если бы мы... Давайте сделаем вот так. Вот, он выдает вот такие вот
ошибки, в котором говорят, что код у нас неверный. То есть, смотрите, вот у нас, допустим, есть импорт,
который не используется. То есть, они у нас явно подсвечиваются и это считается не очень хорошим
тоном, потому что это может привнести к какие-то ошибки. Значит, здесь есть фатальные ошибки,
которые говорят, допустим, что у вас код не запустится, потому что у вас есть синтактическая
ошибка. Да, то есть, это в принципе тоже можно проверять. То есть, если мы здесь напишем импорт-тест
внезапно, вот такой модуль, то, видите, у нас эта ошибка, что вот этот объект импорт-тест,
but not used. Если мы запустим, то, скорее всего, у нас даже ничего не запустится. Вот. Еще классическая
вещь есть, если мы говорим про переносы в конце строки. Видите, даже синтактический анализатор
подсветил. Вот. Видите, мне выдает warning. No new at end of the line. То есть, таким образом вы можете явно
предотвратить какой-то не очень хороший код. Допустим, есть переменные, которые не используются.
Есть переменные, если мы говорим про компилируемые языки программирования, у нас может быть
переменная, которая, так сказать, создана, но не идеализирована никаким значением. И это статические
анализаторы кода четко отлаживают. Значит, в качестве инструментов, которые можно использовать,
значит, есть PEP8. Если мы говорим про C++, то это пара C langtide и C langt format. Не знаю, кто-нибудь
пользовался имя. Да, тоже удобная вещь. Если мы, значит, говорим про джаву, то это инструмент чекстайл.
То есть, во всех языках, так или иначе, есть либо внутренние библиотеки, либо сторонние библиотеки,
скорее всего, да, сторонние библиотеки, которые позволяют вам проверять статический анализ кода.
Анализировать ваш код. Значит, это что касается по доступности. Следующий метод серого ящика.
Значит, мы про него тоже будем говорить. Он заключается в том, что как бы вы видите часть
системы, а часть системы у вас закрыта. То есть, допустим, для вас, вот смотрите, YouTube это черный
ящик. Вы что-то заходите, в нем делаете. Но если вы обратитесь в техподдержку, то для техподдержки
YouTube это уже серый ящик. Потому что они видят часть прослойки, но при этом внутренний код могут не
видеть всю реализацию. Тоже про это поговорим. Так, следующий момент по позитивности сценариев.
Иногда делят видотестирование. Есть позитивные сценарии, есть негативные сценарии. Как вы думаете,
какое приблизительное соотношение между позитивными сценариями и негативными сценариями?
Так, 50 на 50, 1 к 99. 30-70. Ну вот, 1 на 99 это слишком экстремально, 50 на 50 на самом деле это не так.
Я бы сказал, от 20 на 80 до 10 на 90. То есть, ваша цель как разработчиков ПО сделает так, чтобы
пользователи не смогли ткнуть не в то место. Чтобы все сломалось. Дальше говорят следующее,
что есть разделение по времени проведения тестирования. И здесь на самом деле на диаграмме
намешана куча мала, но в целом она показывает именно время проведения тестирования. То есть,
у нас есть альфа-тестирование. Что такое альфа-тестирование? Это вид тестирования,
в котором, который проводится внутри компании перед первичной публикацией. Что такое бета-тестирование?
Бета-тестирование – это вид тестирования, когда мы приглашаем либо проведём закрытое
бета-тестирование, то есть мы приглашаем внешних пользователей протестировать наш функционал,
либо открытое бета-тестирование . Когда мы говорим, что вот, пожалуйста, мы
проводим с вами тестирование – пожалуйста, смотрите на наш функциональность,
пишите нам обзывы, мы будем их исправлять. Третий вариант – это дымовое тестирование.
Значит, в чем оно заключается, если здесь тело, у кого есть физика? Хорошо, у вас есть физика.
Представьте себе, что вы клепаете механизм какой-то и запускаете его в какую-нибудь
электрическую схему. Что у вас происходит, если эта схема не будет работать?
Средний случай. В худшем случае сгорит все. Что означает, что сгорит все? Что является предвестником
того, что все сгорит? Дым пойдет. Что означает смог тестирования? Вы запускаете ваш продукт,
начинаете делать основные проверки. Пойдет ли дым или не пойдет. Если дым пройдет, то все грустно.
Значит, если мы когда мы запускаем нашу программу, если у нас идет дым, это означает, что у нас какие-нибудь
ошибки начинают сыпаться или у нас какие-то запросы по сети не проходят, значит наш код не работает.
Все, останавливаем. Это такая вот чистая проверка, которая нам нужна для того, что работает или нет.
Следующий это санити-тестинг. Есть специальные инструменты, которые называются санитайзерами,
которые обеспечивают проверку именно внутреннего функционала. Классический пример санитайзеров,
вы проверяете, что вы не выходите за пределы массивов, у вас память всегда очищается,
потому что в чем проблема того, что вы не очищаете память? Память течет.
Да, то есть у нас в какой-то момент времени количество оперативной памяти,
которая выделяется нашей программой растет, растет, растет, растет, и в какой-то момент времени это достигает
критического эффекта и возникает два варианта. Первый вариант, у вас компьютер зависнет, потому что
количество оперативной памяти слишком большое, либо это в худшем случае. В среднем случае мы можем
сказать следующее, что у нас с вами настроен такой механизм как out of memory killer, что это такое?
В процессе операционной системы вы можете для каждого процесса настроить максимальное количество оперативной памяти,
которое он может использовать. Если у вас количество оперативной памяти превышает
дозволенное, то у вас процесс автоматически останавливается. Следующая вещь, это тестирование
новой функциональности. Для этого вы как раз можете использовать такое понятие как фичу флаги.
Наверное, я сейчас детальнее не буду раскрывать, но вы по факту вводите новую функциональность и
проверяете, работает она или нет, как заложено. Дальше есть такое понятие как регрессионное
тестирование, в чем оно заключается. Представьте себе, что у нас кто-то нашел баг, причем это был
конечный клиент, и ваша цель заключается в том, чтобы проверить, исправили ли вы баг или нет. И в
зависимости от того, насколько вам важно исправление этого бага, вы проверяете допустим,
сломался ли. То есть вы проверяете чисто функциональность того, что новый тест вводит эти баги
или не вводит эти баги. Сейчас еще попробую переформулировать. Новый тест, который у нас появляется,
типа закрывает он эту функциональность или нет. Более того, вы можете распространить это. Допустим,
вы нашли баг в каком-то модуле, в нем есть еще какие-то связанные с ним классы. Проверяете
допустим на тесты те классы, которые связаны именно с текущим. Регрессионное тестирование тоже
закрывать не будем, их всего там 7 типов есть. И последняя вещь, которая здесь есть, сразу скажу,
это приемочное тестирование. Оно называется Acceptance или Certification Test. Прежде чем вы в
реальной жизни попытаетесь сдать какой-то проект, именно реальный проект с заключением договоров,
всяких подобных вещей, то есть серьезный проект, вам придется проверить его на сертификат соответствия.
То есть запускается ли он на определенной операционной системе, запускается ли он с определенными
всеми требованиями, выполнены ли требования по техническому заданию и так далее. Потому что
если это не будет выполнено, то условия договора нарушены и придется платить большие неустойки. Но
сразу скажу, что приемочное тестирование, помимо того, что оно находится здесь, мы его можем еще и
закинуть в уровни тестирования. И вот самое важное на самом деле, если мы говорим в рамках тестирования,
очень хорошо стоит понимать про уровни тестирования. Всего их выделяют четыре. Первое это компонентное
тестирование или unit-тестирование, второе это интеграционное тестирование, третье это системное
тестирование, а четвертое, самое верхнее, это приемочное тестирование. Если вы сейчас не поняли,
что это означает, не бойтесь, про уровни тестирования мы посвятим прямо полулекции.
Вот, и смотрите последний момент. Очень важный, а не последний, господи, почти. Значит последний
из основных именно видов тестирования, категорий видов тестирования, это тестирование по степени
автоматизированности. Вы можете сделать следующее, у вас может быть ручное тестирование, и не поверите,
сфера ручного тестирования до сих пор занимает большую часть в тестировании ПО. То есть это вы,
когда вводите какие-то поля, проверяете результаты, хорошо-нехорошо, значит наша цель будет приблизиться
как раз с точки зрения технологии программирования именно к автоматизированному тестированию.
Для того, чтобы тесты могли запускаться автоматическим образом. Почему, как вы думаете,
лучше автоматизировать тесты? Как вы думаете, какой вид тестирования дольше проводить? Конечно
ручное, потому что нам нужно кнопочки протыкивать, действия проводить и так далее. То есть это очень
неприятно. Но бывают полуавтоматизированные тестирования. То есть образно говоря, такой пример,
вам нужно отправить, зарегистрировать пользователя в системе, и когда вы регистрируете пользователи
в системе, вам нужно активировать письмо на почте. То есть письмо с активацией. Вы получаете ссылку,
вы проверяете, допустим, что письмо у вас пришло на почту, и после того, вводите, там ссылку обычно
приходит, вводите эту ссылку и продолжаете тест именно с этого момента. То есть остальные все
сценарии будут автоматизированы. Вот. И как раз наша цель будет именно тестировать на более
высоком уровне, тестировать как раз те варианты использования, которые мы описываем в наших
проектах. Еще две категории, которые здесь есть, это по степени подготовки. То есть у нас с вами
либо этот тест был заранее задокументирован, либо он появился, так сказать, прямо при
разработке. Это ad hoc тест, ну и по субъекту тестирования. Здесь у нас показывается,
чем отличаются альфа- и бета-тестировщики. То есть альфа-тестировщики это обычно штатные
сотрудники, бета-тестировщики это внешние сотрудники. То есть это конечные пользователи.
Так, это такая большая картина, которую мы с вами должны понимать для того, чтобы с ней не бояться
работать. Так, движемся дальше. Это такая вот самая большая категоризация всего этого. Что есть,
мы конечно не все это будем смотреть. Я предлагаю двигаться дальше и попытаться проверить,
а насколько вы тестировщики. Тест. Значит, тест заключается в следующем. Смотрите, нам надо
протестировать функцию, которая будет проверять следующее. Она принимает на вход числа,
а на выход проверяет, являются ли эти числа сторонами треугольника. То есть у нас есть
какая-нибудь функция из триангл. Пусть она бул возвращает. Вот у нас есть функция, эфемерная
функция. Наша цель будет ее не реализовать, а протестировать ее. То есть вам нужно будет
придумать как можно больше входных и выходных данных, на которых можно проверить результат
работы этой функции. То есть вам нужно сгенерировать входы и вам нужно сгенерировать выходы. Поехали.
В данном случае мы пишем именно тесты, поэтому нам нужно конкретные входные данные и конкретные
выходные данные. Так, хорошо, поехали. Ну давайте одну отрицательную. Минус один, два два. Какой
ответ должен быть? Ну тут говорит следующее, либо false, либо кидаем exception. Что-что-что? Да, можно. Ну да.
3, 4, 5. Да, так это exception. 2, 3, 4 exception. Ну и допустим 1, 2. Еще раз. 6,
ну на самом деле смотрите, сразу скажу, что здесь можно сделать перестановки всех элементов. Ну ладно,
хорошо. Что? Вот это? Ну я конечно понимаю все, но это для математиков возможно прямоугольный
треугольник. Вот для обычных людей это как-то не сильно на треугольник похоже.
Да. Да, давайте нормальный треугольник приведем наконец-таки. Да, это называется метод граничного
тестирования. Так, 5, 8. Это ответ true. Так, хорошо. Что еще? Наверное граничность. Да, номерик лимитс.
Так, еще варианты. На самом деле есть вариант, когда это все в прямую вырождается. Ну да, граничный
элемент. Здесь есть еще некоторые фундаментальные тесты. Максинф-1 можно взять в принципе. Я обозначу
Так, еще. 0, 0, 0. Важный вариант. Почему? Это точка. Если мы говорим про математиков, то это
предельный треугольник, к которому мы можем сместиться. Ну и еще один вариант возникает,
допустим, 0, 2, 2. Так, сколько мы сценариев перечислили? 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12. В принципе
много. А теперь смотрите, есть один тест, который мы с вами упустили. Не-не-не. Реализация такая.
Да, переставлять аргументы тоже надо. Потому что, видите, мы говорим, что сумма любых
тессуаров должна быть больше, чем третья. И тут как раз в тестах, которые я передавал,
эти аргументы, они встают в неверном порядке. В принципе наш тест может легко сломаться на
варианте 8, 5, 3. А ответ должен быть false, несмотря на то, что здесь у нас ответ true.
Хорошо. То есть мы перечисли с вами большое количество примеров, вот, посчитали результаты,
и вот мы с вами достаточно хорошие ребята, потому что классический разработчик покрывает не больше,
чем половину тестов. А мы придумали даже намного большее количество тестов,
которые у нас могут быть. Теперь давайте, наверное, поговорим, прежде чем мы перейдем
с вами к тестированию, каким образом можно проводить тестирование. Вот давайте подумаем,
можем ли мы просто написать ассерты? То есть написать функцию triangle и дальше внутри них
написать ассерты. Давайте какой-нибудь текстовый редактор возьму. Да, мы можем try-catch,
логировать результаты. Нам важно сделать следующее, что если у нас есть какие-то тесты,
нам нужно запускать именно все тесты, а не падать на первом. Поэтому, чтобы не делать лишних
try-catch, для этого как раз существуют специальные фреймворки для тестирования, которые как раз
позволят нам этого избежать. Потому что если мы возьмем с вами какой-нибудь stack trace,
давайте где-нибудь пока напишу примеры. Вот тут есть, о господи, здесь есть таймер. Давайте куда-нибудь
сюда. Тестер. Мы с вами напишем, я буду писать на питоне. Напишем ассерт
так ассерт допустим triangle 5 вот то вот как обработать исключение. Ну да, хочется сказать,
что нам нужен try-catch. И вот что-то нужно генерировать вот такое. Образно говоря,
какое-то исключение, которое называется test failed error. Ну да, желательно еще бы записывать
результаты нашего тестирования. То есть смотрите, main, ну и запускаем. Значит test correct, test not correct.
То есть если мы сейчас с вами запустим это все, то у нас, не поверите, все кажется отработает. А нет,
вы видите, то есть как бы у нас выскачивает исключение. Если мы следующий раз напишем с
вами correct, то будет проблема. Потому что мы не перехватили с вами исключение. Соответственно,
здесь придется делать следующее. For test in test correct. Да, видите, здесь прямо функциональный
стиль нужен будет. Я к чему и веду, что не надо самопальное писать. Ну да, мы приводим к тому,
что нужны фрейворки для тестирования. Чтобы обработать все эти варианты. Вот. Это вот простой
вариант. То есть наша цель, чтобы оно запускалось на всех тестах. О, test failed. Ну и дальше нам нужно
будет с вами допустим обратиться к имени нашего теста. Вот такой самопальный фреймворк мы с вами
написали. Ну и с этим работать очень неудобно. Да, потому что нам приходится делать обвязки.
Как раз за счет этого для нас придумали как раз фреймворки тестирования, которые позволяют обеспечить
этот функционал. Значит как раз про фреймворки тестирования буду говорить на семинарах. Вот.
На лекциях мы все-таки перейдем с вами к часть, так сказать, теоретической составляющей. Так.
Теперь давайте немного про литературу. Значит по теме тестирования на самом деле есть достаточно
большое количество литературы. И я посоветую как раз посмотреть книги, которые очень полезные.
Значит сразу скажу, что это книги можно начинать, если вы хотите прям получить целую фундаментальную
базу по тестированию. Это книга Art of Software Testing, Глен Фортмайерс. У нее есть русскоязычный вариант,
к сожалению я ее с собой не взял. Я могу в принципе на следующую лекцию принести все эти три книги,
которые я посоветую. Значит в нем прямо написано теоретические основы тестирования. Последняя
версия, по-моему, вышла в 2011 году, в которой можно явно прям прочитать, там даже есть адаптация к
мобильному тестированию мобильных приложений. Значит вторая книжка, это Харри Персеваль,
о базе тестинг год. Значит она, не помню как на русский язык, по-моему называется как раз что-то
Test Driven Developed with Python. Она рассказывает про методологию Test Driven Developed. В чем она
заключается? Она заключается в том, что вы сначала пишете тест, потом пишете код. То есть вы пишете
минимальный тест, который не проходит, дальше адаптируете код к тому, чтобы у вас этот тест
проходил. Методика интересная. Причем здесь покрываются все уровни тестирования. И третья
книга, кстати, от авторов экстремального программирования, про который мы с вами в прошлый раз
говорили, про методологию. И ее написал Кен Бэк, один основатель Agila. И в нем как раз рассказывается,
как можно внедрять тоже методологию Test Driven Developed через методологию экстремального программирования.
Почему полезно именно смотреть на Test Driven Developed? Потому что он как раз раскрывает всю суть
тестирования. То есть легче намного писать код тестов не по имеющемуся коду, а как бы делать
заранее заготовки перед тем, как писать тест. Потому что если у вас будет какой-то сложный продукт,
да, вот такие смотрите. Стена, гора. Нам нужно эту гору перейти. Да, непонятно,
как эту гору перейти. Поэтому лучше маленькими шашками приближаться к тому, чтобы проводить
тестирование. Вот. Значит, теперь это чтобы почитать. В следующий раз я попробую принести книги,
чтобы вы могли их изучить. Значит, теперь давайте поговорим про интересный момент. Вообще,
сфера тестирования это отдельная, так сказать, препендикулярная ветка по сравнению с классической
разработкой. То есть здесь нужно мыслить по-другому, и здесь идет спецификация по-другому. И вот как раз
первое, что стоит знать про тестирование, что по тестированию есть международный стандарт и
есть международная сертификация. И как раз этим занимается сервис Aistocube. Значит, у него есть
как раз сайт, в котором можно открыть прямо все силобусы. Что такое силобусы? Это программы курсов,
которые нам нужно пройти для сертификации. Вот. И как раз здесь видно, что на самом деле в сфере
тестирования можно очень сильно развиваться. То есть первый самый уровень это Certified Tester.
Если вы откроете вот это вот силобус, давайте мы его откроем. Тест какой-нибудь. Вот Certified Tester.
Давайте почитаем условия задач, которые предлагаются решить на экзамене. Давайте
поймем, где здесь, есть ли здесь что-то про код. Здесь ничего нету про кодирование. Здесь какие-то
соответствия уровней. Вот. И первое, что здесь есть, это допустим вот у вас есть задача, у вас
есть численные значения, и вам нужно это. Есть тестовый сценарий. Вот. И вы пытаетесь понять,
типа, какой у вас процент покрытия кода теста. То есть какой процент тестовых сценариев вы покрыли.
Вот такие задачи на уровне Certified Tester. Здесь не надо писать код. Здесь нужно больше соображать.
И тестирование это больше про навык критического мышления. Вот еще один. Вот даже есть диаграмма.
Типа, вот у вас есть диаграмма состояний. Какое количество тестовых сценариев необходимо для
того, чтобы проверить все переходы. Ну и понятно, написайте эти тестовые сценарии. Здесь тестовый
вариант. По факту неплохо было бы написать тестовые сценарии. Вот. То есть вот то, что касается
Certified Tester. Если вы, допустим, захотите развиваться в специалистов сферой Quality Assurance,
это сфера, в которой находится тестирование, то есть далеко не все из вас станут разработчиками.
Но я не знаю. Может быть, кто-то пойдет в менеджеры, кому-то нужно будет управлять. Кому-то нужно будет,
кто-то будет писать код. Кто-то будет работать тестировщиком. То есть это вполне возможно.
Тогда вы можете идти в разные сферы. То есть если вы идете по кор ветке, то вы начинаете как раз
быть управленцем в сфере QA. Если вы идете специалистом, вы можете развиться, допустим,
в Automation Testing и в разные индустрии. Как раз вот в правой части Foundation Level'а как раз
особенность стоит в том, что вы под определенную сферу пишете разные тесты. Кстати, к слову,
вопрос. Почему тестирование зависит от сферы? Как вы думаете, каким тестировщикам на свете жить
проще? Android-тестировщиком или iOS-тестировщиком?
Так, хорошо. Давайте проведем соц-сопрос. У кого Android? Называйте марку своего телефона.
Pixel, Xiaomi, Samsung. А что, все остальные с айфонами? Ничего себе. Ну там, там Poco есть еще, Realme.
В общем, количество телефонов на самом деле большое. Вот, и под каждый из телефонов тестировать,
это проблема. Особенно с разными марками. То есть, когда мы, допустим, в компании провели
тестирование, у нас там просто 10 разных телефонов. Лежит просто в разных уровнях мощности. И мы на них
тестируем. С айфонами намного проще. Почему? У вас есть айфон 7, 8, 9, 10, 11, 12, 13, 14, 15. Все.
Девания по безопасности, конечно же, больше, но в целом, как бы, протестировать нужно меньшее
количество версий. Под чем? Нет, а вдруг какие-нибудь конфликты, допустим, у вас есть какие-то
сторонние приложения, которые отжирают какое-то место, графическая оболочка, и так далее. То есть,
здесь тоже можно развиваться на разных уровнях. Вот, если мы говорим про Foundation Level Certified
Tester, то здесь как раз важно говорить про основы тестирования. Во-первых, понять, что такое
тестирование, почему оно необходимо, про 7 принципов обсудить, рассказать, что это за принципы,
и дальше рассказать про психологию тестирования. То есть, что для тестирования нужно перестраивать
психологию. Дальше здесь, как говорится, про тестирование в рамках software development. Здесь
мы можем говорить как раз про уровни тестирования. Вот, и про виды тестирования. Про виды тестирования
мы с вами уже рассмотрели один момент. Да, и, кстати, смотрите, здесь как раз важный момент,
что для того, чтобы сдать экзамен по тестированию, нужно понимать то, какие методологи разработки
существуют. Но мы с вами это как раз уже на предыдущих лекциях рассмотрели. Вот, дальше здесь
есть как раз техники тестирования, то есть тестирование черного ящика, белого ящика.
Experian-based это в какой-то степени тестирование серого ящика. Вот, и уделяется еще очень важный
аспект, посвященный именно статическому тестированию. То есть, тестированию,
которое проводится без запуска кода. Вот, это самом деле очень важный процесс тестирования. Так,
давайте теперь перейдем к задачам тестирования. К задачам тестирования относятся следующие. Это
оценка артефактов нашего продукта. Значит, что может быть в качестве оценки артефактов? Первое,
это user story. То есть, это фича, которую мы с вами внедряем. Новая функциональность. Дальше,
требования к продукту. То есть, насколько наш продукт относится с требованиями,
которые мы прописали. Дальше, оценка дизайна. То есть, вы открываете какой-нибудь сайт в интернет
магазине и понимаете, типа, хороший дизайн или нет. Сразу спрошу, не знаю, сейчас актуально это
или нет. Кто-нибудь заходил на японские сайты? Вот. Для нас это вообще неадекватный дизайн. Для
японцев нормально. То есть, опять же, артефакты могут зависеть от того, в какой реальности мы живем.
Вот. И последнее, это оценка кода. Ну, качество кода. То есть, работает он или не работает.
Либо оцениваем какие-то не функциональные требования. Значит, следующий момент это верификации того,
что требование выполнено. Здесь есть, так сказать, момент, который я хочу обсудить,
что существует два аспекта. Первый называется валидацией, второй верификацией. Смотрите,
как бы отметить отличие. Представьте себе, что вам нужно набрать текст количеством символов
15 тысяч. Вам нужно набрать текст 15 тысяч символов на тему. Что вы можете сделать?
Запросить УГПД. Написать текст на 15 тысяч символов. Можете попробовать сами написать текст на
тему. Ну, у вас есть тема, допустим, тема весна. Ну, хорошо. Что мы делаем? Мы берем и пишем. Сколько
получается? 3000 раз слово весна. Ну, текст на тему весна. То есть, мы с вами провалидировали наш
процесс, что у нас текст на тему весна. А дальше процесс верификации заключается в том, что вы
оцениваете, насколько адекватно вы все это сделали. Понятно, что текст из трех тысяч слов весна,
он вообще неадекватен и, понятно, никуда не пойдет. А вот с точки зрения именно верификации
требований мы читаем этот текст, делаем какие-то правки и говорим, как именно подкорректировать.
В той же степени, если мы говорим про сдачу технических заданий, то валидация – это выполнение
технического задания, заслать его в систему, получить полный балл. Верификация – это пройти
процесс код ревью и пройти процесс устной сдачи. Для того, что мы проверифицировали то, что
вы освоили эту тему. Третье – это избегание сбоев. Здесь важно разграничить, что такое
сбой и что такое дефект. Что такое дефект? Дефект обнаруживается разработчиками. Вы начали
локально тестировать ваш процесс, у вас находятся какие-то ошибки. Если вы находите это в процессе
разработки или в процессе тестирования вашего ОПО, то это дефект. Если конечный пользователь
находят это и сообщает вам, это уже сбой. То есть система работает не так, как предназначено.
И обычно, если мы говорим про англоязычную литературу, то дефект пишется как дефект,
а сбои пишутся как фейла. И важно различать эти вещи. Наша цель – избегать сбоев. Дальше,
естественно, задача тестирования – находить как можно больше сбоев и дефектов. Тестирование как
раз заточено под то, чтобы в первую очередь находить сбои и дефектов. Дополнительно еще нам нужно
давать какие-то степени уверенности о том, что наш продукт будет работать в каком-то проценте
случаев. То есть какие-то рамки выдавать. Предоставлять информацию основателям. Что такое
основатели? Это продукт универа или заказчики, которые мы делали. Что у нас вот такой уровень
тестирования в таком-то проценте случаев? Кстати, важный момент – не называть никогда число.
Число чего? Процент уверенности. Точное число. То есть вы, когда говорите по срокам,
вы никогда не должны называть именно точное число. Почему?
Допустим, он говорит, что проект будет готов через две недели. Почему так не надо делать?
Да, конечно, что-то может пойти не по плану. Соответственно, лучше называть диапазон.
От 2 до 3 недель, от 2 до 4 недель. Понятно, что чем ближе мы к стадии завершения проекта,
тем уже у нас диапазон. То и так же степень уверенности мы говорим от такого-то до такого-то процента.
Потому что иначе потом ожидания могут не совпасть с реальностью. И последнее – это
согласование с утвержденными стандартами качества. Ваш продукт нужно будет сертифицировать в конце
сдачи. Поэтому важно понимать, какие стандарты качества существуют. И здесь мы как раз должны
перейти к тому, какие стандарты качества существуют. Давайте вопросы по задачам тестирования.
Есть ли они? Это основное то, что мы с вами должны зафиксировать. Давайте перейдем к
следующей части. Эта часть посвящена тому, что на самом деле тестирование – это большая отрасль.
И на самом деле тестировщики не любят, когда их называют тестировщиками. Они любят себя
величать QA-инженерами. И это действительно так. Если мы говорим про качество нашего продукта,
то здесь выделяют три основных вещи. Первая – это Quality Assurance. Это QA. Это достаточно большой
процесс. После этого у нас есть QC – Quality Control. Есть тестирование. И они отличаются по целям.
Давайте пройдемся. В качестве тестирования, если мы говорим про тестирование, то наша цель – находить
и решать сбои и дефекты. На чем мы фокусируемся при этом? Мы с вами фокусируемся на нижнем уровне.
Мы фокусируемся с вами на коде. Тестируем больше код. И дизайн нашей системы. Смотрите,
аккуратнее. Дизайн – это не только то, как окна нарисованы, но это еще и архитектурные
какие-то решения. Это называется System Design. Дальше, что тестируем? Что мы делаем? Наша цель – находить
дефекты и сбои. Кто обычно за это отвечает? Обычно за это отвечают тест-инженеры и разработчики.
Их цель – находить как можно больше дефектов и сбоев. А когда проходят? Это происходит на
стадии тестирования, параллельно со стадией разработки. Как раз в металлогии Agile мы как
раз во время спринта в Scrum проводим тестирование. Дальше у нас следующий уровень – Quality Control. В чем
заключается Quality Control? Мы пытаемся убедиться, что наш продукт отвечает всем требованиям и
спецификациям перед тем, как мы его выпускаем. На чем мы фокусируемся? Мы с вами фокусируемся не
только на исходном коде, но на всем проекте целиком, всем продуктам. Потому что у нас может быть
допустим система сопровождения какая-то, у нас может быть какие-то агитационные рекламы и так
далее. При этом именно на стадии Quality Control у нас осуществляется верификация, про которую мы с
вами говорим. Кто ответственен за этот весь процесс контроля за качеством? Вся команда.
Вся команда проекта. Когда это обычно происходит? Обычно все эти стадии осуществляются на уровне
приемочного тестирования либо перед выкаткой новой версии продукта. А дальше у нас есть сам
большой момент – Quality Assurance. То есть нам нужно настроить с вами правильные процессы, указать
стандарты качества для того, чтобы как раз цель того, что если вы правильно настроите ваши
процессы, то скорее всего у вас будет меньше сбоев. Такая причина связи. И здесь как раз мы
фокусируемся на процессах взаимодействия в нашей команде. То есть опять же от методологии разработки
будет сильно зависеть то, какое количество багов у нас будет и какая будет их критичность. Потому
что водопадные модели у нас, если прилетит какой-нибудь баг на стадии тестирования, то это все. Можно
там проект закрывать. То в гибких методологиях можно адаптироваться к этому и двигаться дальше.
Значит цель как раз предотвращение наступления багов. То есть образно говоря, если у нас возникают
какие-то переработки, то понятно люди, допустим, меньше начинают фокусироваться на самом коде и
просто усталый человек может допустить намного больше ошибок. Особенно это критично, если мы
работаем на каком-нибудь драмоопасном или опасном для жизни производстве. Кто за это ответственный?
Ответственный за это вся команда и заказчики. То есть заказчики, именно основные заказчики,
если мы идем продавать это какому-то другому бизнесу. То есть они нам говорят, какие процессы
они могут сделать, какие процессы мы можем сделать. И важно, когда это происходит, это происходит во все
время разработки нашего продукта. То есть это весь цикл софтвердевелопмента, про который мы с вами
говорили. Поэтому все-таки ищут обычно не тестировщиков, а кьюе инженеров для того, чтобы еще и настраивать
качество нашего процесса. Давайте вопросы по этой табличке. Опять же некоторые теоретические
сведения, просто чтобы вы понимали, почему QA это не только про тестирование. И зачастую, если вы...
Давайте я лучше вам вопрос задам. Что из этого можно автоматизировать? Из этих трех столбцов?
Да, только тестинг. Quality Control и Quality Assurance это право взаимодействия. Вот, значит теперь давайте
еще раз проговорим про стандарты качества. Их на самом деле очень много. И есть специальный
стандарт. Это старая версия стандарта. Так, давайте опущу экран, чтобы видно нижнюю часть слайдов.
Это стандарт качества ISO 9126. То есть это сертификация про качество программного продукта. И вот наша
цель в данный аспект рассмотреть как раз особенно связанные с поддерживаемостью программного кода.
То есть что такое поддерживаемость программного кода? То есть вы приходите в компанию, и как вы
думаете, вы каждый раз будете делать кит и нит и писать проект с нуля?
Да, по большей части вам придется в 80 процентов времени читать код и, дай бог, в 20 процентов писать
новый код. То есть вам придется разбираться в старом коде. А для того, чтобы старый код был
удобен, нам нужен как раз поддерживаемость этого кода. Это как раз верхняя ветка, связанная с
им мейнтенабилити. И, собственно, здесь у нас как раз есть некоторые составные части, заключающиеся в
том, что у нас в им мейнтенабилити входят changeability, то есть возможность изменения нашего кода. Про это
как раз мы говорим, что у нас наша архитектура должна быть гибкой. Дальше мы должны уметь
анализировать нашу архитектуру, анализировать наш продукт, то есть считать какие-то метрики
качества. Потому что если вы метрики не можете замерить, увы, сложно куда-то двигаться дальше.
Потому что если у вас какое-то есть число, на которое вы можете опираться, с этим жить намного
проще, а не про какие-то эфемерные знания. Дальше, значит, следующая вещь, тут очень важно,
это аспект, это testability. То есть вы проверяете, насколько ваш код способен к тестированию,
насколько вы его можете протестировать. И последняя вещь, это стабильность, то есть насколько ваш
код ведет себя стабильно от изменения к изменению. Здесь есть еще другие стандарты качества. Я думаю,
мы про них поговорим чуть позже. Наша цель — обратить то, где здесь находится тестируемость,
в какой ветке? На вот этом круге. Давайте даже преувеличу.
Ну да, они немножко съехали. И, собственно, если мы говорим про testability, то он на самом деле
заключает в себе большое количество составных частей. Значит, первое — это testability, возможность
к тестированию кода. Дальше, analyzability, вы можете проанализировать ваш код. И modifability,
то есть насколько ваш код может быть модифицирован. И вот здесь как раз на этой
диаграмме показывается, к чему это скатывается. То есть смотрите, от чего зависит тестированность
кода. Оно зависит от, собственно, устойчивость к сбоям и от сложности. То есть смотрите,
что получается. Если наш код сложный, то его сложно протестировать. А если код сложно
протестировать, то его сложно поддерживать. Поэтому как раз если мы говорим про метрики качества,
то их как раз можно отслеживать. Важная метрика качества — это logical lines of code. То есть сколько
у вас логических операций есть в вашем проекте. То есть вот такая диаграмма. Главный вывод из нее
такой, чтобы код был поддержан, он должен быть тестирован. И в разных сферах на самом деле
тестируемость кода проверяется по-разному. То есть в классической разработке тестировать код достаточно
просто. Если мы переходим там, допустим, в front-end, там тестировать код намного сложнее,
потому что мы поднимаемся на более высокие уровни. Так, хорошо. Есть ли вопросы по этому тезису?
Так что можете открыть какой-нибудь свой код по алгоритмам и попробуйте его протестировать. Не
так, как вы обычно тестируете, а именно выделив функции, и тогда вы поймете, что вы можете
локальные функции тоже протестировать. Так, давайте мы с вами перейдем к семи принципам
тестирования. Они достаточно фундаментальные, и их тоже стоит разобрать. Первый из семи
принципов тестирования заключается в том, что тестирование показывает наличие дефектов,
а не их отсутствие. Значит, есть классический пример. Вы идете к врачу, врач ничего не обнаружит,
говорит, что вы здоровы. А вы чихаете, у вас температура и так далее. Просто врач решил
не смотреть на этот аспект. Бывает. Да, грубо говоря, тестирование именно старается показать
дефекты. Если у вас все тесты прошли, это не значит, что у вас нету сбоя. Они, в принципе,
могут быть. И нужно чаще отслеживать. Второй момент, очень важный, заключается в том,
что избыточное тестирование невозможно. Невозможно протестировать все и все. Классический
пример. Представьте себе, что у вас есть код с 10 ИФами подряд. И ВЗН-ЭЛС. Потом вы выходит,
делаете еще раз ИВЗН-ЭЛС, потом еще раз выходит ИВЗН-ЭЛС. Делаете. Сколько у вас возможных
вариантов действий? 2 в десятый. Здесь 2, здесь 2, здесь 2, здесь 2. Получаем 1024 возможных вариантов.
Если у вас еще десяток ИФов добавится, то сколько возможных вариантов уже будет? Уже много.
Понятно, что все это тестировать это перебор. То есть у нас получается 2 в 20-ый вариант,
2 в 30-ый вариант. А теперь, если вы посмотрите в возможное количество сценарий в реальной
программе, в реальном продукте, их может быть реально большое количество. И понятно,
что все это невозможно протестировать. Поэтому нам нужно будет выделять аспекты,
которые мы с вами будем тестировать. И дальше, из-за того, что избыточное тестирование невозможно,
оно может возникнуть тогда, когда вы неверно определили, что именно тестировать. А когда
мы могли определить неверно, что нам тестировать? Когда мы принялись за это слишком поздно. У нас
сложные продукты, мы не понимаем, что именно тестировать. Поэтому раннее начало тестирования
экономит время и деньги, и даже нервы. В чем это заключается? Вы берете и смотрите, какое количество
времени вы тратите на тестирование в зависимости от запуска вашего продукта. Можете провести
мысленный эксперимент. А даже не мысленный, а практический. Построим график зависимости
количества нервов, которые вы тратите в зависимости от времени, от старта продукта.
Представьте себе, что вы пишете код. Очень просто код. Думаете, 2 плюс 2 написал. Написал какие-то
простые вещи. А потом начинаете писать какие-то сложные вещи, начинаете интегрировать такие,
вы читаете. Этот код невозможно тестировать. У вас зависимость количества потраченных нервов на
единицу времени, в зависимости от времени, будет расти по экспоненте. Сначала код кажется просто,
простым. Потом вы понимаете, что через месяц, через два вы не можете прочитать код, и вы даже
не можете подступиться к нему тестом. У вас есть первые задачи по алгоритмам, которые вы сдавали?
В первом семестре. Причем попробуйте открыть код, который вы писали ближе к началу семестра первого,
и попробуйте его прочитать, его протестировать. Я думаю, что, может быть, вы мало чего поймете.
Да, много изменилось в то время. Но если вы начнете внедрять тестирование раньше,
вы не поверите, у вас произойдет следующий эффект. Знаете, по опыту своего преподавания я скажу,
что люди не любят писать теста. Точнее, не понимают, как к ним приступиться. Поэтому количество нервов,
которое тратится на единицу времени, вначале оно будет какое-то такое. Но потом со временем,
как только вы начинаете осваиваться, либо вы начинаете материть эти тесты, и у вас линия идет
уже по меньшей экспоненте, либо вы, наоборот, свыкаетесь со временем, и у вас эта линия идет вот
таким образом. То есть реально большой проект может быть хорошо протестирован. То есть вы
спускаетесь до какого-то уровня и начинаете комфорт себя чувствовать. В итоге, вместо того,
когда у вас горит дедлайн, вы спокойно спите. Выбор вот такой. Вот. Значит, смотрите,
еще один важный аспект протестирования. Он касается именно классической разработки.
Вот смотрите, давайте представим, что у нас есть график. Количество рублей,
которые мы тратим за единицу времени в зависимости от времени. Значит,
представим себе, что мы тратим количество рублей на разработку. Вот это у нас график разработки.
Как вы думаете, количество денег на тестирование, как будет относиться?
Да, проект должен развиваться, но при этом важно, чтобы он не заходил за разработку. То есть все-таки
наша цель именно двигать наш проект вперед, а не поддерживать текущую статус-кво. Если мы не
начинаем делать раннее тестирование, то у нас, опять же, графика затрата ресурсов на тестирование
будет расти намного больше. Да, но смотрите, все, опять же, зависит от того, какой у нас проект.
Если нам нужно дяде Вася склепать простой магазин, возможно, его и не нужно тестировать. То есть вам
нужно отдать просто проект под заказ, держи, все готово, пожалуйста. Тогда можно еще хоть как-то
избежать тестирования, но если мы дальше развиваем наш продукт, то все-таки лучше закладывать базу
для тестирования. Хорошо, следующий. Правила Парета или правила 80 на 20. В 20 процентах кода
содержится 80 процентов дефектов. То есть обычно дефекты находятся в основной части вашего
программного кода. Допустим, как раз вы не поверите, большая часть багов и дефектов
фахчека находятся вот как раз в ядре этого кода. Вы, наверное, уже могли находить дефекты.
В большом количестве они завязаны как раз под то, что проблемы есть в ядре, которое нужно править.
Допустим, нам приходится снимать посылки. Да, то есть это просто возможность, там условие if стоит,
что если условие такое, то все, мы не позволяем делать проверку. То есть это какая-то или, допустим,
кнопка отправить на ревью, которая, по идее, должна работать только тогда, когда у вас определенные
статусы и там показываются тогда, когда у вас там появляется день до дедлайна. Просто этой логики
еще нету. Вот, это как раз все находится в ядре. Значит, следующий принцип — это парантокс пестицида,
он и называется. Старые тесты не помогают находить новые дефекты. Образно говоря, оно говорит
следующее — не пишите теста, что 2 плюс 2 равно 4. Не проверяйте этого. Лучше ищите новые тесты,
которые будут проверять ваш функциональность. То есть по факту кодовая база тестов развивается
параллельно с кодовой базой вашего продукта. Так, это был пятый принцип. Шестой принцип очень важный,
про него мы тоже сказали. Тестирование зависит от контекста, зависит от методологии разработки и
от сферы разработки. То есть, образно говоря, если мы работаем с вами в сфере мобильной разработки,
мы поняли, что у нас тестирование под Android и под iOS разные. Если мы находимся в игровой сфере,
то у нас появляется альфа- и бета-тестирование, в котором мы собираем огромное количество разных
отзывов. Более того, сейчас в игровой индустрии возник лайфхак под названием Early Access.
Если мы говорим про искусственный интеллект, то нам нужно сферы этического использовать. То есть нам
нужно будет проверять лицензионные требования. И там бывают забавные моменты. Если мы говорим про
современные нерастевые модели, они по факту запоминают тот контекст, который есть. И вы пишете
«хочу сгенерировать картинку по описанию», а дальше у вас в правом нижнем углу выплывает
этот водяной знак какой-нибудь компании. То есть вы использовали для обучения нейросети как раз
картинки из этого сайта, хотя не уведомили о компании. Такие кейсы реально бывают,
и они уже разбираются в судебном порядке. И последний принцип заключается в следующее.
Отсутствие ошибок не панацея. Значит, смотрите, здесь что сказано. Если переводить с английского
языка, это говорит следующее. Error absence is fallacy. То есть неверное рассуждение. Я перевел его по
другому. Отсутствие ошибок – это не панацея от всех болезней. Что это означает? Если у вас код
максимально протестирован, в нем нет ошибок, вам кажется все. То есть вы избрали 99% багов,
но при этом вы так спроектировали ваш проект, что им пользоваться просто невозможно. То есть вы
говорите «все, у нас есть», но при этом кривой графический интерфейс, кривая логика действий,
ничего не работает. То есть чисто над тестировать и чисто на том, затачиваться на основном аспекте,
что тестирование должно ходить как можно больше ошибок, не надо. То есть нужно гарбонично развивать
наш проект. Так, хорошо. Есть ли вопрос по принципам тестирования? Надо закладывать именно
эти принципы в свой аспект. Так, следующий момент. Давайте подумаем, почему Colteo Assurance
инженера и разработчики должны быть разными людьми. Да, абсолютно верно. Разработчики
акцентируют на том, чтобы делать новый продукт, развивать это все. А Colteo Assurance инженеры выступают
некоторыми критиками, которые это делают. И поэтому разработчики считают, что их код работает
корректно. Тут можно вспомнить любой пример, который у вас есть. Вы можете вспомнить школьные
сочинения, можете вспомнить рефераты, которые вы сдавали. Кстати, вы сдавали рефераты?
Не доводилось? Счастливые люди. Поэтому, как бы, вы сдаете, а потом вам кажется, что это шедевр,
вы написали, сдали, все замечательно. Приходите, а там оценка не очень приятная. Поэтому, слушайте,
важный момент. Если мы говорим про стадию тестирования, важно не критиковать друг друга и
понимать, что, зачастую, если вы сами проводите ревью, вам нужно критиковать именно код,
не переходить на личность. И постараться содействовать в нейтральном ключе, потому что процесс
ревью, он достаточно нервный. Очень нервный. Потому что в некоторых моментах читаешь код и
сразу подчеркну, что когда мы читаем код, мы стараемся все-таки проводить именно аспекты,
связанные с тем, как это все написано. Большая часть это именование переменных, выделение функций и так
далее. Ну, читаем мы. Давайте классический пример, который я видел в некоторых аспектах.
Я видел вот такую вот переменную в какой-то момент.
А, давайте где-нибудь это. Давайте я код напишу лучше.
Вот такая переменная у нас появляется в коде.
Ну, это да, про ядро линкса согласен. Я понимаю следующее, что человек, который это писал,
он сказал следующее, что это текущие иксы. Текущие координаты иксов. Возможно. Но возможно,
что это футболка для курицы размером XS. Ну, курица. Ну да, мы можем зайти в какой-нибудь Google
Translate и посмотреть. Ну, маленькая дворняшка. Все. Ну, поэтому нужно, вот. И, собственно,
здесь важно сказать, что, допустим, я не понимаю названия этой переменной. Пожалуйста,
можете использовать более полное название. То есть стараться как раз содействовать в нейтральном
ключе. Я как раз про это и говорю. Так, у нас осталось сколько минут? У нас, кажется, осталось
три минуты, да, где-то. Поэтому давайте я покажу вот эту картинку, и мы с вами, а? Да. Собственно,
познакомимся с вами с пирамидой тестирования. Вот она. Значит, юнит-тестирование, интеграционное
тестирование, системное тестирование и приемочное тестирование. Значит, на нижнем мы тестируем с
вами маленькие модули компонента класса. Интеграционное тестирование как раз позволяет
проводить взаимодействие между несколькими классами. В системном тестировании, смотрите,
мы тестируем всю программу целиком. Но важно, смотрите, важный аспект соиска в том, что в
системном тестировании мы тестируем программу в виде сферический конь в вакууме. Что это означает?
Это означает, что мы не выпускаем в реальную, в реальную систему. К примеру, вы запустили вашу
программу, вы написали ваш проект на линуксе. А запускаться он должен под Windows. Тогда
системное тестирование позволяет в принципе запустить его под линуксом. А вот приемочное
тестирование будет проверять, запускается ли ваш код под Windows. Да, именно точно. Именно так,
что система тестирования просто запускается на Windows, а в приемочном тестировании запускается ли
он на Windows определенной версии с поддержкой вот таких браузеров. И дополнительно как раз мы
будем говорить про эти уровни тестирования и практически посмотрим, как работает с
юнитестированием. На семинарах будут рассказывать, как работает с юнитестированием, с интеграционным
тестированием. Я постараюсь тогда на лекцию принести пример с системным тестированием и покажу,
как можно тестировать приложение в браузере. Что есть эмуляторы браузеров, которые можно
запускать. И проводить антическое тестирование. Так, давайте вопросы по сегодняшнему занятию.
Хорошо, если нет вопросов, тогда всем спасибо за внимание и тогда в следующий раз будем продолжать
тему.
