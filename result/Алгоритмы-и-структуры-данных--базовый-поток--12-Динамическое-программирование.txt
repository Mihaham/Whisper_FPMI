Смотрите, мы с вами по факту закончили все, что касается деревьев в этом семестре. У нас еще
появится фибоначевая куча. Мы посмотрим, что это такое, но это такое теоретическое знание больше.
Сейчас мы переходим к такому достаточно большому блоку, связанному с динамическим
программированием. Те, кто занимался олимпиадами когда-нибудь и что-то встречал из них, подозреваю,
знают, что такое динамическое программирование. Правда? А есть кто встречался? Расскажите. Вот.
Понимаю. И у нас будет три лекции, посвященные динамическому программированию. На первый
сегодняшний. Мы с вами так обобщенно посмотрим, что это такое, какие у нас там есть принципы,
что нам необходимо для динамики. А на второй и третий разберем конкретные задачи, потому что у них
очень много различных применений. Если очень интересно, то следующая лекция будет про НУП,
НВП через одну задачу о рюкзаке. Может быть кому-то что-то это скажет, кому-то может ничего не
скажет. Но в действительности, как бы, это задачи такие на грани с олимпиадами очень часто,
поэтому вы можете сказать, что они сложные и не тривиальные не с точки зрения кода скорее,
а с точки зрения идеи, потому что самое главное в динамике это идея. Если вы придумали, то вы
решили задачу. Если вы не придумали, то вы, к сожалению, проиграли. Вот. И другого исхода скорее здесь нет.
Не совсем. А если мы с вами знаем какой-нибудь овел дерева и работаем с бинарным деревом поиска,
то там достаточно очевидно и понятно, что нам нужно сделать, грубо говоря. Если задача конкретно
на дерево, вы знаете это. Если у вас задача на динамику, то тут начинается слишком много но и
слишком много вопросов. Вот. Мы разберем с этим всем. Но начать сегодняшнюю лекцию я хотел бы с
такой вот фразой, что динамическое программирование это по сути, когда у вас есть задача, которая непонятно
как решать, вы разбиваете ее на более мелкие подзадачи, которые тоже непонятно как решать. Именно
в этом вся суть динамики на самом деле. Именно в этом, может быть, вам покажется, что это такая
странная фраза, но в действительности в ней заключен весь смысл того, что происходит в динамическом
программировании. И мы будем по факту смотреть сегодня на три такие какие-то обобщенные задачки,
четыре, в которых есть какой-то интерес, какой-то какой-то вопрос, который нам нужно будет
ответить. Но для начала, чуть более формально, что такое динамическое программирование? Вообще
динамическое программирование это способ решения каких-то сложных задачек, когда мы пытаемся их
разбивать на более простые подзадачи. И вот собираем то самое итоговое, а нужное нам решение
благодаря результатам из предыдущих. Вот критериям применимости динамического программирования мы
не везде его можем применить. Это важный момент. Но его критериями являются таких два пункта,
про которые вам всегда нужно помнить. Первый пункт — это наличие оптимальной подструктуры,
и без них никак. И второй пункт — это перекрывающиеся подзадачи. Это похожие друг на друга пункты.
Единственное, что вам нужно понять, что оптимальная подструктура, то есть есть какая-то, грубо говоря,
формула, по которой вы из предыдущих результатов что-то получаете. А есть другой вариант
перекрывающейся подзадачи, когда вы можете действительно взять задачу и разбить ее на какие-то
внутренние подзадачки. Кто представляет, что является аналогом в математике динамического
программирования? Ну, почти. Индукция. На самом деле индукция. Вот все, что нужно в динамике — это
какое-то начальное значение, а дальше у нас есть предположение, что мы будем делать вот таким-то
образом и благодаря этому что-то получим. Именно от этого отталкиваясь, мы с вами и получаем что-то.
То есть, когда вы... Все же знакомы с методом математической индукции. Надеюсь,
все в школе выучили, это хорошо. А на матологике она звучит немного по-другому, но, типа,
суть остается та же. У вас есть какая-то база индукции и у вас есть переход индукции.
Вы предполагаете, что это верно для какого-то числа, значит, докажем, что верно для числа
больше на единичку, например. Вот. И с этим мы будем с вами сегодня работать. Если говорить
с практической точки зрения, что вам нужно в динамике для того, чтобы что-то решить. По-хорошему,
при решении каждой задачи динамики вам нужно выделить вот эти пять пунктов, которые перечислены
здесь и их определить. А некоторые из них достаточно просты, некоторые нет. Первый вопрос
состояния динамики. Состояние динамики подразумевается в следующее. Что хранится в данный момент в той или
иной ячейке? Чаще всего вы будете работать с массивами, одномерными, двумерными, но иногда вы
работаете с конкретным одним числом. Вам нужно понять, что в нем хранится и что, на каком шаге,
там будет находиться. В зависимости от этого состояния динамики вы и будете отталкиваться,
потому что вы легко руками можете посчитать для каких-то начальных условий. Вот у вас есть
состояние динамики, которая показывает какой-то ответ на момент, там не знаю, этой вашего цикла.
И вот если вы знаете на момент к этому циклу все до него, попробуйте тогда узнать, что будет на
и плюс первым. Это первый пример. Начание начальных состояний, это чаще всего самый простой пункт,
потому что его действительно очень легко посчитать руками, почти всегда. Бывает исключение, конечно,
но чаще всего очень легко посчитать руками. Дальше идет переход между состояниями. По факту это та
самая идея, которая лежит в той или иной задаче на динамику. Вот без этой формулы пересчета вы не
получите ровным счетом ничего. У вас будут некоторые проблемы с тем, чтобы понять,
а что там происходит. Понятно? Вот надеюсь, что в задачах на динамику вы сможете взять и придумать
везде как, что и почему и откуда, что происходит. В этом случае вы решите абсолютно все задачки.
И на итоговом контесте, скорее всего, у вас тоже будут задачки на динамику. Это важно понимать,
важно всегда думать. И в этот момент можно сказать, что программистам все-таки нужно
знать математику, потому что сегодня будет такая задача, которая очень близка математикам,
но очень не близка программистам. И без какого-то такого, знаете, интересного факта, поднятого из
ниоткуда, вы не сможете решить задачу. Но это как пример будет показан вам для того,
чтобы вы поняли, в чем основная суть здесь. Дальше идет порядок пересчета. Порядок пересчета мы
сейчас остановимся на них поподробнее. Их бывает всего три. И важно вам тоже понимать,
в каком порядке вы хотите считать значение. Я объясню, что это будет значить на каждом из
примеров. Каждую задачу можно свести к любому порядку пересчета. И дальше самый важный момент
положение ответа. Не всегда ответ лежит в конкретной ячейке. Не всегда ответ является вот просто одним
числом, которое вы зафиксировали. Нет, это может быть сумма, это может быть произведение, это может
быть максимум, это может быть все что угодно. И это тоже важно понимать и осознавать здесь. Мы еще
не раз встретимся на самом деле задачами на динамику. Вы можете их скрыто не увидеть, не понять,
что это именно они, но в действительности это будут они самые. Чаще всего какая-то
простая идея, которая лежит в решении задачек, она помогает нам понять, что типа как красиво
решается задача. Но в этот момент вы не представляете, сколько мучений стоит за тем,
сколько раз перепридумывали решение той или иной задачки для того, чтобы красиво ее решить.
Это важный момент. Теперь поговорим про порядок пересчета. Как с этим жить? Встает три порядка
пересчета. Прямой, обратный и ленивая динамика. Прямой порядок это когда вы на основе предыдущих
результатов получаете текущий. Обратный порядок это когда вы находитесь в каком-то состоянии и
знаете, что оно влияет там не знаю на и плюс второе, на и плюс пятое и на и плюс седьмое и
прибавляете или там убавляете или умножаете или что-то делаете это к результату вот тому,
который есть там дальше. Вот есть ленивая динамика, ленивая динамика по сути типа вы
делаете ту же самую рекурсию, потому что вы знаете рекурренту, которая у вас есть зависимости,
делаете эту рекурсию, но с одной большой оговоркой вы не будете позволять разрастаться дереву
рекурсии и если вдруг какой-то результат у вас уже посчитан, то вы его сохраняете куда-нибудь. То
есть вам нужно создать вот эти вот кыши для каждой из задачек. Понятно? Пока все легко или нелегко?
Нормально? Хорошо. Либо вы все очень уставшие, понимая конец семестра. Но ничего, самая
жесть будет в самой последней лекции, обещаю, хотя что-то типа с плыдерева вот такой же характер
будет, только обобщенный теоретически. Про прямой порядок, то есть смотрите вот тут вот
вы можете увидеть там, например, желтенький вопросик и зелененький, а стоят восхитительные
знаки. Восхитительные знаки известные нам результаты, вопросик это то, что нужно найти.
И вот прямой порядок пересчета на примере чисел Фибоначчи. На примере чисел Фибоначчи мы
разберем все эти три порядка и поймем типа просто, не просто, как, что происходит. Вот. Как бы вы
задаете в самом начале те самые начальные значения. Я теперь возвращаюсь к тому псевдокоду,
который писал всегда ранее. Вот. Потому что здесь уже код достаточно простой. А дальше я циклом
просто буду проходиться и использовать предыдущие результаты для того, чтобы получить результат в
иный момент. Просто понятно. Я думаю, вы с этим сталкивались. Это не сложно. Окей, ладно.
Что касается обратного порядка. Вот в обратном порядке здесь, смотрите, уже немного по-другому.
Я говорю о том, что у меня есть одно начальное значение и больше мне особо-то и не надо. Почему
это так? Потому что есть еще нулевой, на самом деле, который тоже ноль, оно там сверху указано. Вот.
А дальше вы, когда находитесь на итом шаге, здесь единственное, что... А, да, все верно. Вы,
когда находитесь на итом шаге, смотрите, вы знаете, что итое число Фибоначчи участвует в результате
и плюс первого и и плюс второго числа. Согласны? Поэтому вы это итое число Фибоначчи прибавляете
и плюс первому и и плюс второму результату. Вы не знаете, что там конкретно лежит, но вы знаете,
что туда нужно прибавить. То есть вот обратный порядок, это когда я вот знаю этот результат и я
знаю, как он влияет на другие и использую его. Так можно делать. Окей? Вопросы?
Получившееся значение используем в зависящих результатах?
Еще раз. А, Фибоначчи от 0 до n плюс 1, это массив от 0 до n плюс 1 и все заполнены нулями. Так
понятнее? Отлично. Вот. Окей. И последнее. Эта ленивая динамика, в действительности,
ленивая динамика выглядит примерно так. Вот если посмотрим какой-нибудь стек рекурсии,
оно будет похоже, когда подальше поучитесь в алгоритмах. Я надеюсь, что многие из вас дойдут
до второго семестра. Вот. В этом случае, грубо говоря, у вас там будет DFS. Вот оно что-то
похоже всегда на самом деле в рекурсии происходит. А здесь вы просто пишете ту самую рекурсивную
функцию. У вас есть условия остановки рекурсии. Это как раз те самые начальные значения. И вы
сохраняете все в какой-то массив. Массив данных. Вот тут у меня числа Фибоначчи сохраняются. И вы
смотрите, что если это число Фибоначчи не было найдено, то я запускаю рекурсию. А если было,
то рекурсию я не запускаю, а просто возвращаю сразу результат. Понятно? Помните, в чем проблема
рекурсивного поиска числа Фибоначчи? В чем? Так, да. Хорошо. Да. Забивается именно память,
стек рекурсии очень сильно растет. Там получается константов степени N. Это константа больше единички,
это, к сожалению, очень быстро растет. Если быть точнее, там, по-моему, снизу ограничено полтора
степени N. Вот. Поэтому здесь очень важно всегда это оценивать и понимать, как с этим работать.
Вот. Это то, что касается порядков пересчета. Все просто. Все просто. Смотрите, как у нас сейчас
будет построена лекция. Может быть, она частично будет похожа на семинар. Но, в принципе, все,
что связано с динамическим программированием, это по факту нарешивание задач. Я вам покажу общие
плюс-минус механизмы того, как рассуждать лучше при решении задач на конкретных задачах. Но это
не будет означать, что я покрою абсолютно все, и вы скажете, что я бог динамического программирования.
Вот. А, к сожалению, никто так сказать не может, потому что это очень нетривиальная вещь. И всегда
нужно думать о том, как и что там сделать. Первая задача, она самая понятная всегда. Это лесенка.
Представьте, что вы можете подниматься на одну или две ступеньки. Сколько у вас возможных путей до
этой ступеньки? Правильно. По факту, по факту здесь это все те же числа Фибоначчи. Но мы сейчас
рассмотрим эту задачу ровно потому, что я вам рассказывал. Определим тебе пять пунктов для того,
чтобы нам было понятнее, что с этим делать. Идея здесь достаточно простая. Как я могу попасть на
Н ту ступеньку, на Иту? Либо с И-1, либо с И-2. И вот сумма вариантов, сколько я попал на ту
или иную ступеньку, будет результатом того, сколько я попал как раз таки на Иту ступеньку. Это идея
решения этой задачи. А дальше от этой идеи мы отталкиваемся и получаем следующее. Что у нас
будет состоянием динамики? Что будет храниться в ДП ИТ? Нет, количество способов добраться до И
этой ступеньки. В ДП ИТ хранится количество способов добраться до этой ступеньки, потому что
от этого мы будем отталкиваться. Какое значение начальных состояний? Вот видите, столько
предположений сразу в такой момент. Я буду считать, что на нулевой ступеньке я могу быть одним
способом, но я там просто стою. И на первой ступеньке я тоже могу оказаться одним способом. Дальше я буду
пересчитывать. Понятно? Можно сказать, что на первую ступеньку я одним способом могу попасть на вторую
двумя и дальше пересчитывать после них. Нет никакой проблем, вы можете делать именно таким образом.
Какая у нас формула пересчета здесь будет? С самых двух предыдущих, все верно. А порядок пересчета
какой вам больше всего нравится? Прямой. Понимаю, я тоже люблю больше всего прямой. А и где будет
храниться результат? На этом месте, нам нужно на эту ступеньку. То есть ступя достаточно просто и
очевидно в этой задачке. Ну и решение этой задачи, аналогичное числом Фибоначчи, как бы все понятно.
Вот оно вот ровно такое же. Ничего здесь не изменилось. Мы с вами получили это решение. Но
дальше начнутся более нетривиальные задачи. Я специально подавал их разного типа для того,
чтобы вы не расслаблялись. Подсчет бита. Смотрите, здесь задача немного другого характера. Вам
необходимо рассмотреть N чиселок от 0 до N, включая, и вернуть массив, где каждый элемент массива это
количество единиц в двоичном представлении числа И. Кто понял условия? А все остальные? Давайте с
вами поймем, что это означает. Например, у меня есть число 5. Мне нужно для нуля 1, 2, 3, 4 и 5 вернуть
количество единиц в двоичной запись числа. В нуле это 0, в единичке это 1, в двойке это 1, в тройке
четверке 1, в пятерке 2. Я такой массив должен вернуть. Что делать? Каждый раз переводить каждое
число в двоичную запись, это смерть. Чтобы перевести число в двоичную запись, нужно там
алгоритм действия. То есть у нас получится N log N.
Так. А как посчитать? Вот представьте, я нахожусь в этом месте. Да? Я знаю результаты,
от нуля там да и минус 1. Как посчитать в этом? Да. Что такое N по модулю 2? Ну давай еще раз,
типа то есть dpi t равно плюс и процент 2. Смотрите, да, это правда. Суть именно в этом. Кто понимает,
почему? А кто вообще не обращает внимания сейчас, что здесь происходит и просто не хочет понимать?
Отлично. Давайте тогда разберемся с этой формулой, почему она работает. Смотрите,
если я запишу число в двоичной записи и вот просто не буду смотреть на последний бит,
к примеру, то что это позволит мне? Вот это число, оно во сколько раз меньше? В два. Причем ну тут
минус один и делить на два. Но когда я делю целочисленное, как бы вот это не считается.
Вот эта половинка мне не нужна. Вот. А вот это число, оно явно меньше, чем и. А если оно явно
меньше, чем и, то оно уже подсчитано само по себе. Осталось понять, у меня в конце стоит единичка или
нолик. Нужно мне прибавить ту самую плюс единичку или нет? И в зависимости от этого я как бы могу это
рассматривать. То есть вот это показывает, что у нас стоит в конце нолик или единица. То есть нужно
увеличить или не нужно увеличить. А вот это показывает, сколько единиц стоит кроме последнего бита.
Но это не самая красивая формулка здесь. Я имею в виду, с точки зрения смысла, это корректно. С точки
зрения плюсов, можно подумать побыстрее. Мы все-таки работаем с битами.
Побитовые сдвиги. Можно сдвинуть здесь на единицу вправо. Вы просто убиваете вот этот последний бит.
Это первое. Второе. Вот это, это то же самое, что и и единица. Почему это лучше?
То же самое. Почему это лучше? Быстрее. Вот это и, амперсант. Одиночное и, это не логическое уже и, а
побитовое и. Ну и как бы типа последний бит единичка или нет. Он выдаст либо 0, либо 1. Все битовые
операции всегда быстрее. Здесь я уже немного ухожу в то, что типа мы все-таки работаем с вами по
программированию, не по математике, поэтому нужно все-таки возвращаться в реальный мир тоже. И это
будет работать чуть быстрее, поэтому это лучше. Если с вами говорить о том, как это выглядит,
ну здесь все достаточно просто. ДПИ это количество единиц в итом, уитого числа в двоечной запися.
Начальное значение, что у нуля это 0, а формула пересчета достаточно простая, что мы просто
смотрим на сдвиг, плюс добавляем вот эту последнюю единицу, если она есть, либо 0, если это 0. Вот прямой
порядок пересчета. Ну и положение ответа, это просто весь массив по факту. Здесь не максимум, ничего, а сам
массив. Нас так просят задачи. И мы можем с вами это получить. Ну и все решение это вот. Ну на плюсах
чуть-чуть побольше может выглядеть. Массив все-таки вывести надо. Но опять же, здесь все решение этой
задачи, к примеру, сводится не к тому, что вам нужно взять и написать какой-то огромный код,
а вам нужно подумать. Как только вы подумали, это становится очень просто. Поехали дальше. Еще
какую-нибудь простенькую задачку посмотрим. Двумерная динамика. С двумерной динамика как-то
задачку только не называют. Это и задачка с черепашкой, еще с чем-нибудь. Но по факту звучит
следующим образом. У нас с вами есть какое-то поле. Вот просто поле N на M. И вам нужно построить
какой-то такой путь из левой верхней ячейки в правую нижнюю. Таким образом, чтобы максимизировать
стуму по этому пути. Потому что в каждой ячейке лежит, не знаю, монетки, деньги, ну как хотите
назовите. Вот, конечно, любому человеку хочется разбогатеть. И в этом случае нужно увеличить
количество монет. Тогда в этом случае мы как бы идем по этому пути. Ну здесь какие-то числа там,
не знаю. Ну и так далее. Не суть важна. Мы можем ходить только вниз и вправо. Благодаря этому условию,
что мы можем ходить только вниз и вправо, мы действительно можем гарантировать, что у нас есть
перекрывающиеся подзадачи, оптимальные подзадачи. Мы можем действительно использовать предыдущие
результаты. Потому что, если мы находимся в какой-то точке здесь, то мы не можем попасть вот
во всю вот эту выделяемую мной область, к примеру. Понятно? Потому что мы не можем ни вверх, ни влево.
А, хорошо. Вот так, давайте. Вот так, вот так, вот так и вот так. Так лучше. Вот. Да,
в действительности это так. И поэтому здесь тоже нужно использовать ту самую динамику. Как я могу
попасть в каждую из ячеек? Ну, я мог прийти либо отсюда, либо отсюда. Как мне выгоднее? Так как это
все уже подсчитано здесь каким-то образом, я не знаю каким, то в этом случае как мне лучше поступить?
Откуда прийти? Сверху или слева? Там, где денег больше. Правильно? Я поздравляю, что на работу вы
можете выбирать в какой-то момент примерно так же. Там, где денег больше, там и лучше. Вот. Но
осторожно, это не всегда правда. Так что всегда думайте об этом. Но если это так, то в этом случае
мы с вами просто будем смотреть каждую из ячеек и смотреть. Мы пришли в нужное время, ой, мы пришли
в эту ячейку из какой? Из левой или справой? И дальше с этим работать. Все достаточно просто.
Если мы опять же пройдемся, ну, это ровно то, что я сейчас рассказывал. Если мы опять же пройдемся
здесь по всему тому, что у нас есть, то состояние динамики это уже двумерный массивчик, где у нас
будет в этой житой ячейке хранится максимальное количество монет, которое можно получить,
если мы пойдем из ячейки 00 и дойдем до этой житой ячейки. А? Да, извините, перепутала. Ну,
видимо, без очков дело. Вот, не увидел. Извините. Да, начальные значения понятны. Начальное значение
это то, что хранится, по сути, вот здесь. Но важный момент здесь, примерно следующий. Смотрите,
вот в эту ячейку я могу прийти сбоку вот в эту? Нет. А вот в эту прийти сверху мог бы? Нет. Поэтому
фактически можно отнести к начальным условиям и вот этот ряд, и вот этот ряд. Как они переподсчитываются?
Да, можно сказать, что вот в этой ячейке у нас хранится сумма, ну, вот это число, которое здесь,
плюс сумма с предыдущего. Здесь сумма с предыдущего, плюс число, которое тут хранится и так далее. То есть
можно таким вот образом сделать первую строчку и первый столбец. И в зависимости от этого это
будет посчитать. То есть это может относиться к тем самым начальным условиям. Ну, порядок пересчета
достаточно прост. Мы смотрим максимальное либо слева, либо сверху. То есть либо и минус первое
вычитаем, либо же и минус первое вычитаем. И прибавляем ту монетку, которая у нас там есть. Ну,
и дальше положение ответа у нас будет храниться вот в этой самой правой ячейке.
Поэтому выглядит все достаточно просто. Ну, как бы решение очень простое. А? Кому не просто?
Нет, хорошо, давайте так. У кого возникают вопросы и сложности к тому, что мы сейчас делаем?
Не возникает. Хорошо, будет так. А, тогда у меня к вам вопрос. А что будет, если я хочу
минимизировать эту сумму? Если максимум поставить с минимумом, этого будет достаточно. А что,
если я захочу здесь восстановить ответ? Восстановить ответ по тому, как я должен пройти. То есть я
должен там вывести, не знаю, не номера ячейка, вот индекс их там. Да, то есть смотрите, мы идем
с конца в начало. Мы будем вот в этой ячейке находиться и смотрим, мы отсюда пришли сверху
или слева. С максимума кто из них больше. И в зависимости от этого оттуда идем. И так мы сзади,
с конца придем к началу. То есть здесь обратный такой порядок будет для восстановления ответа.
Понятно? Отлично. Ну, а теперь последняя задачка на сегодня. Дальше мы поговорим с вами, потому что
очень быстрая лекция у нас получилась. Может, оно и лучше, я хоть не помру к концу. У меня голос
все будет существовать. Смотрите, задача следующая. Требуется найти количество разложений числа n на
различные слагаемые. Что еще раз ты сказал? Это правда. Это правда. Кто знает такие слова,
как диаграмма Юнга? Два человека получили. Вот в этом проблема. А это задача. Смотрите. Задача
звучит следующей. Задача очень простая с точки зрения того, что там происходит. Я имею в виду
ее формулировки. Задача стоит корректно, понятно, всего в одну строчку. Много бы таких задач,
но, к сожалению, это не всегда хорошо. Ну, на примере числа 7 мы можем увидеть, что таких
разбиений 5. Это само число 7. Это 3 плюс 4, 2 плюс 5, 1 плюс 6 и 1 плюс 2 плюс 4. Различных слагаемых.
Да. Каждая слагаемая должна быть различна. И вот здесь нужно как-то нам что-то получить.
Зачем нам искать легкий путь с ней? Вот если вы двое знаете диаграммы Юнга,
чем это здесь может помочь? В принципе, можно. Но вообще из этого всего стоит очень интересный,
там связанный с диаграммами Юнга, отдельный вывод того, что любое число, ну, как бы,
что такое диаграмма Юнга? Я вам покажу сейчас там дальше. По факту это будет выглядеть вот такими
столбиками. Точнее, лесенками я бы сказал. Правду говорю? Вот. А вот каждая такая строчка,
это будет у нас означать число некоторое. Ну, а вся сумма это будет вот само число,
которое здесь есть. Ну, количество вот этих кубиков, по факту. Вот. И все, что можно делать,
это либо сдвинуть все кубики вправо и добавить по факту ко всем 1. Вот так вот. Либо же можно
сдвинуть все кубики и сверху добавить еще один. Предположим, что у нас существует два таких действия.
То есть мы либо все сдвигаем, либо сдвигаем и делаем еще плюс один. Так вот, говорится следующее,
что при помощи этих двух действий единственным способом можно получить каждое число. То есть
можно разбить это на большое количество способов. Но благодаря этим двум простым действиям мы можем
получить все возможные случаи, которые у нас есть. Для конкретной задачи. То есть вот только лишь
вот этим вот сдвигом по факту добавлением единиц ко всему. Либо же сверху надстроить еще кубик.
После добавления единиц. Понятно, что я сейчас сказал? На всякий случай. Нет, ты можешь добавлять кубики,
я говорю. Либо плюс один ко всему, либо плюс один ко всему и сверху еще один. По факту,
что это означает? Если у меня есть число один, то я из единицы что могу получить? Один это просто
вот такой вот кубик. Либо два, либо три. Если это два, тогда у меня получается, что это просто так.
Если это три, тогда я получаю это вот так. Можно, можно. Именно семь так и получится.
Вот эти количество строчек, это и есть количество слагаемых по факту. Из двойки что можно получить?
Из двойки можно получить там ту же тройку, просто сдвинувся. А можно получить четыре,
получив вот таким вот образом. А из троечки здесь можно получить, получается пять. Это когда у вас
будет вот так и вот так. А можно получить вообще шесть. Когда у вас будет вот так, вот так и вот так.
Нет, конечно. Можем получать здесь количество. Вот благодаря тому, что я сказал. Что мы можем
хранить в ДП. Вот это тоже является нужным вариантом. То есть смотрите, вот так вот разбивает
одной единичке, я могу сказать, что тройка раз имеет разложение, два имеет разложение,
других разложений она не имеет. У двойки есть только одно разложение, это два. У четыре вот есть здесь,
на самом деле вот тут еще будет еще одно. Их тоже два. Это отдельная доказывается вещь,
я говорю, поэтому нужна математика. Ну смотрите, я вам говорю, знаете такой забавный факт,
типа друзья, вы можете использовать такой забавный факт. Именно поэтому я говорю,
что математика очень полезна всегда, особенно в динамике. Вы знали об этом факте или нет?
Ну смотрите, очень ли полезно это? Ну такой вопрос. Это прикольная тема, мало ли вы там можете
что-нибудь для себя интересное откроете, грубо говоря. Но из него складывается такая вот вещь. Как
мне это использовать? Идеи-то у меня есть теперь. Как суммы что?
Да неприкольно. Просто количество чего?
Из одного количества в другое ты не получишь нормальный пересчет.
Число клеток влевом тоже не всегда хорошо. Я вам больше скажу, здесь у нас получается уже двумерная
динамика. Для такой простой задачи вы все равно получите ту самую двумерную динамику.
На всякий случай я не перелистываю. Вот диаграммы Юнга, вот они. А? Не, какой хип. Не надо, забудь.
Вот как бы из диаграмм Юнга вы получите именно вот это, то что мы сейчас с вами разобрали.
Смотрите, мы можем сказать следующее. Пусть наша динамика сама по себе
видимо надо было побольше задач к вам добавить. Все понятно. Но считайте, что сегодня я отпускаю
грехи типа за сплей дерева. Потому что там я вас очень сильно задержал. Смотрите, пусть у меня будет
некоторое ДПНКТ. И я скажу, что у меня в ДПНКТ лежит количество разложений на х слагаемых. Ну,
различные. Чем мне это поможет? Н это число. А, количество разложений. Н на х слагаемых.
Как?
Ты хочешь прямой пересчет? Ой, обратный пересчет. А я хочу теперь прямой пересчет. Вы же говорили,
что больше нравится. Я на самом деле... Да, по факту это так. То есть смотрите, мы же сдвигаем
к чисел. Вот тут, если посмотреть на диаграммке, из 5-6 как получается. Мы сдвигаем к чисел,
например. И вот из тройки получается 5. Мы сдвигаем эти два числа. И мы всегда можем сдвинуть
вот все числа, которые у нас есть. Если я сдвигаю все числа на 1, то я прибавляю к. Согласны? То есть
первый вариант это n-k прийти. И на к слагаемых. Правильно? А второй вариант какой?
Все верно. То есть мы можем прийти либо оттуда, либо оттуда. И в зависимости от этого мы с вами
уже что-то получаем. Только там будет dp n-k. k-1. Вот. А? Ну смотрите, давайте еще раз. Я могу
получить, вот исходя из того, что вам тут вот рисовал, из одного числа могу получить что? Могу
просто сдвинуть его и сделать плюс один. Ну плюс вообще k вот этих рядов, сколько у нас есть.
Правильно? А могу сделать плюс k рядов и еще плюс один сверху добавить. Вот. И все. Таким образом.
У нас там k-1 одно слагаемое будет. Вот. Мы уменьшили это слагаемое количество. Вот. Самое
важное здесь, что ответом является сумма вот этого последнего ряда, который у вас есть. Потому
что я могу число n разложить там на 1, на 2, на 3, на сколько хочешь слагаемое. Понятно? А? Еще раз.
Вот. Смотрите, вот это все решение задачки. Но в начале задача казалась странной. Получается
это именно так. Понятно? А важный здесь момент какой? Важный момент здесь с динамикой. Какой связано
на самом деле? Что когда мы с вами говорим про количество слагаемых и так далее,
сколько работает этот алгоритм? Да. Я про это и хотел сейчас рассказать. Да. Смотрите. Вот сейчас
это работает за n квадрат. По факту. Правильно? Мы можем уменьшить это количество. Какое у нас
максимальное количество разложений есть числа и. Максимальное количество слагаемых. И. И то это
все единицы. По факту это корень. Почему? Да. Потому что максимум, как мы можем разложить число,
это 1, плюс 2, плюс 3, плюс 4 и так далее. Согласны? То есть там будет n на n-1,5. Вот. Это первый
нюанс здесь. А тогда вот тут получится там корень из n. Тогда вот этот весь алгоритм можно
чуть-чуть переписать лучше. И он будет работать за n корень из n. Классно. Вот. Таким образом это
одно из самых быстрых решений, которые есть на самом деле с разложением чисел. Стоит решение,
которое типа работает за куб. Еще за что-то. Тут мне очень нравится вот красивая математика. Всегда. Вот.
Теперь смотрите. По факту моя презентация заканчивается, но я еще кое-что порассказываю.
Помните самую первую задачу с лесенками? Представьте, что тот, кто ходит на 1 и 2
ступеньки, ходит на 1 и k ступенек. Как там устраивает пересчет? Да. Сумма от n-1-k. А представьте,
ну не знаю, что вы еще играете типа pool это лава на определенных ступеньках, не можете там ходить.
Да. В них всегда поставить просто ноль. И тогда вы получите нужный вам результат.
Вот. То есть с точки зрения динамики все достаточно нетрудно сводится ко всему остальному,
ко всем задачам по динамике, которые у нас есть. Их существует большое множество. Существует динамика
по профилю, по изломанному профилю. Вы даже можете это посмотреть. Мы, честно, на лекциях этого
почти не коснемся, сразу скажу вам. Вот. Но почитайте очень забавные эти вещи. Они очень
математические по факту подходят к тому, что там необходимо. Так как среди вас есть математики,
я думаю, вам будет весело. Вот на этом блоке, который у нас есть, связанный с динамикой,
вы встретитесь еще не один раз с ней. Мы с вами лишь дадим такой толчок тому, чтобы вы начали
думать в задачках на тему того, что вы делаете. А после этого у вас будут более интересные алгоритмы,
которые тоже используются по сути принцип некоторой динамики. Вот. Ну что ж, давайте тогда
поступим следующим образом. Я вас отпущу, потому что с плей деревья у вас было целых плюс 30 минут.
Вот. Выстановим этот вселенский баланс. Хорошего вам вечера. Не болейте только.
