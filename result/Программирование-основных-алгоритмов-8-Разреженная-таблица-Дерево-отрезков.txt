Ну ладно, давайте начинать тогда потихоньку. У нас восьмая лекция. Сегодня перейдем к экватору
нашего курса. Дальше будет только хуже. И в этот раз мы начинаем с вами новый модуль. Это будет
модуль, посвященный структурам данных для обработки запросов на подотресках.
Нет, у вас третий контест. Третий модуль, то есть деревья поиска. Там потрески по значению,
тут по индексам будет иметь в виду это. Вот, это обработка запросов на подотресках.
Вот, если вы вспомните самую-самую-самую-самую первую лекцию, там было у нас понятие задач
RSCOO, RMCOO, ONLINE, OFFLINE, DYNAMIC, STATIC. Мы будем вести дискуссию об этом в ближайшие несколько
лекций. И первое, что мы научимся делать с вами, это внезапно статика RMCOO.
Ну онлайн. Как у нас задача? Статика это значит, что у нас элементы в массиве не меняются. RMCOO
это значит, что мы хотим минимум на подотреске запросить. То есть у нас есть какой-то массив,
постановка такая. 0, M-1, это массив A. И у нас есть запрос с вида LR,
который мы хотим вот так узнать. Вот минимум на подотреске с LPR. Вот статика это значит,
что мы запрещаем себе изменить массив. Онлайн это значит, что мы только ответив на этот запрос,
получим следующий. RANCH минимум QUARY. Запрос минимум на подотреске. QUARY запрос, RANCH это
диапазон подотрезок. Минимум это ну минимум. Вот. Если помните, у нас была задача в статик RMCOO.
Вот, то есть запрос суммы на подотреске. Мы решали префиксными суммами. Там строили как-то
массивчик префиксов. Мы вычитали одно из другого и побеждали. И мы говорили, что с минимумом так не
получится, потому что он необратим. Вот теперь пришло время немножко приоткрыть завесу тайны и
научиться делать нормально. Именно мы себе позволим следующее. Предподсчет или построение структуры
данных. У нас будет за вот такое время работать. И ответ на запрос. За вот такое время мы хотим.
Как оказалось, предпочет относительно долгий, но как долгий? Он нелинейный. Это уже не самоприятное,
но запрос на то очень быстро. Вот. Как мы это будем делать? Будем делать с помощью разреженной таблицы.
Не которая разряженная, а именно разреженная. Она сама не плотная, не мало значения относительно.
По-английски sparse table. Вот. Что это такое? Это вот такая вот штука. Пусть есть массив А,
что такое вот индексация 0, n-1. И еще в передаче у нас есть и бинарная операция f. То есть мы что хотим?
Мы хотим считать какую-то бинарную операцию от кучи элементов. Вот. Заведомо сразу скажу,
что мы будем накладывать все время. Следующее свойство — это ассоциативность. Кто помнит,
что такое ассоциативность? Нет, коммутативность. Это как скобочки не расставляй, результат одинаковый.
Или алгебрически это можно вот так вот записать. Вот. Мы будем все время это требовать,
поэтому мы умеем с вами вычислять бинарную операцию от кучи аргументов, просто вот так-то
ее расписываем по такому-то правилу. Вот. Окей. Этому задачу поставить, теперь давайте решать.
Введем табличку st. Это двумерный массив. При этом у нас будет, у него вот такое вот
интересное определение, что st и ты житый, это у нас будет управляться следующим образом.
А и ты, это если ж равно нулю, иначе это у нас будет что такое? Это будет f от а и того, а и плюс 1,
а и плюс 2 в степени g минус 1. То есть смотрите, что мы делаем. Вот наш массивчик есть,
мы берем какую-то позицию i, это будет позиция i плюс 2 в степени g минус 1. Длина вот этого
отрезка ровно 2 степени g. То есть мы на каждом следующем уровне, на уровне пожи имеется в виду,
что мы делаем? Мы просто изучим в два раза длину отрезка, на которую мы считаем ответ.
Это определение просто. Дальше мы пишем определение. Степени g минус 1. Ну чтобы у вас длина отрезка,
то есть это и плюс 0, и плюс 1, и плюс 2 в степени g минус 1. Как с этой штукой пользоваться?
Вообще как считать тогда тут табличку? Потому что будет очень грустно,
если вы берете просто и каждый раз считаете ответ на отрезки.
Ну будто бы да. То есть у вас такая горизонтальная табличка, здесь будет n элементов, тут n пополам,
грубо говоря. Нет, вы берете f от вот этой вот кучи. Мы с вами определились, что раз у нас есть
ответативность, можем писать винарную операцию от кучи аргументов, раскрывая вот такой вот,
по-английски это называется fold, по-русски свертка. Вот. Собственно вопрос, если мы будем
наивно пересчитывать за 2 в степени g, ну или просто за длину этого подотреска,
брать функцию f и висовать сюда, это как-то очень долго звучит. Давайте применим адекватный алгоритм
и заметим следующее. Вот ваша позиция и, и вот это вот у вас будет и плюс 2 в степени g минус 1.
Что тогда хочется сказать? Давайте разделим отрезок пополам. Какой у него индекс будет
в серединке? И плюс 2 в степени g минус 1, минус 1. Ну, в плане, ну, окей, хорошо,
но мы уже все-таки не в непрерывной величине, у нас не бывает дробных индексов. Вот ваша граница,
вот вы раз. Давайте, как разбить отрезок длины 4 на 2? Это раз, это два. Вот. То есть на самом деле,
будто бы у вас есть такая штука. Это кто такой? Это будто бы f от st и ты g минус 1. Так,
ну ладно, я немножко неудачно взял измерение, ну что поделать? А, 2 степени g минус 1, g минус 1.
Вот. Просто обычно они наоборот ставятся, что, скажем так, индекс будет вторым, а степень
доки будет первым измерением. Ну ладно, так напишу. Таким образом, у вас от единицы, ну считаем,
что f включается за от единицы от двух элементов, за от единицы умеете заполнять одну ячейку массива.
За от единицы одну ячейку массива. Окей, что дальше? Сколько всего ячейк будет в этой штуке?
Ну, логично, что нам по второму измерению не особо имеет смысл много раз увеличить g.
Ну, типа того-то, где-то либо вниз, либо вверх, как захотите. Ну да, а размеры таблицы,
ну будет что-то порядка лог2н на n. Вот, как-то так. Потому что у вас всего логн уровней,
и здесь там ну pn элементов. Вот. Из-за этого следует, что время построения – это наше заявленное n логн.
Окей, как на запрос отвечать будем?
Так у вас может быть порядка логарифма слагаемых, ну порядка логарифмов оперантов,
которых надо выбрать f. Вот вам произвольный запрос. Ещё нет, мы сейчас напишем как и поймём,
что ещё надо доделать. Ну да, логн на n.
Ну, можно чуть по-другому. Возьмём сделан так, чтобы k максимально и до степени k,
какое было у нас, не превосходило r-l. Из-за этого следует, что k просто равно
округлённый вниз новичный логарифм от r-l. Зачем нам это надо? Тогда утверждается,
что отрезки длины 2 в степени k, они хотя бы по одной клетке пересекутся. То есть вы не сможете
сюда упихать два отрезка длины 2 в степени k, чтобы они при этом не то чтобы не пересеклись,
чтобы у них было ещё что-то посередине. То есть вы захватите и эту часть, и эту часть.
Ну нет, мы сейчас сделаем так, чтобы она не вырезала. Как это сделать? То есть запрос lr,
ну зачем следующее? f от. Так, мы брали первым измерением индекс. OK, l ты, k ты. Ну k ты
посчитывается по этой формуле. Да, заранее сразу скажу, что проще всего предпочитать вот на этом
этапе, здесь, когда вы считаете разреженную таблицу, почитать сразу все логарифмы от 1 до n. Это просто
удобно, чтобы здесь долго логарифм не брать и очень быстро отвечать. И теперь внимание,
вот такая вот штука. Будем брать r минус 2 в k ты. Так, сейчас. Ну да, отрезка у нас так
определяется. И k ты. То есть мы заведомо сразу берем себе, не от этой точки-то мы исчисляем,
l плюс 2 в k ты минус 1. А сразу берем правую границу отрезка, r минус 2 в k ты. Казалось бы,
все круто. В чем подвох? Да, потому что у вас, видите, у вас здесь есть пересечение двух отрезков.
Вы его учитываете два раза на самом деле. Вот в этой формуле, неявно. Для суммы неприменимо,
да. Мы же рмку решаем, а не риску все-таки. Вот, поэтому вводится следующее ограничение,
которое мы запишем. Места мало. Ну ладно, пишем сюда. И демпатентность такое свойство.
О чем оно? Оно гарантирует следующее, что для любого а f от аа равно а.
Не, почему это у вас измерение? Это у вас степень блоки здесь пишется. А здесь пишется индекс
левой границы. То есть с помощью вот этого свойства вы позволяете себе сказать, что хоть у меня
пересечение два раза не считается, оно дает вклад лишь один раз. То есть вы можете за счет
ассоциативности разложить вашу функцию на этом отрезке, как вычисление один раз на этом,
вот на вот этом вот. Дальше два раза на этом и один раз на этом. Но два раза на этом это то
же самое, что один раз на этом за счет вот этого вот свойства. Можно здесь подробно расписать,
но я думаю, что это не нужно. Если нужно, дайте знак, распишем. Ну супер. Окей, тогда с этим
забрались. То есть что мы хотим от операции? Мы хотим ассоциативность, но придумайте не
ассоциативную операцию. Вот вам задачка на подумать. Часов до четырех ночи не уснете. Вот.
И домпатентность. Но здесь гораздо проще не домпатентную операцию придумать. Это сумма банальна
или произведения. Вот. Собственно статик здесь, потому что мы, ну давайте подумаем,
плюс-минус, сколько ячеек затронет обновление одного элемента. Ну будто бы порядка ООТН.
Может у вас будет одна ячейка длины 1, две ячейки длины, ну две ячейки на следующем уровне,
четыре ячейки на следующем уровне. Тра-та-та-та-та. Порядка ООТН ячеек.
Что такое векторное произведение от массива? Это подотреска. Вот как вы можете его определить?
Ну это понятно, ну вы конечно молодцы придумали. Это конечно да, но взять векторное произведение,
давайте что-нибудь в бейсболе такого числа неприменимое что ли. Вот да, это единственная операция,
которая, которая типа башенкой делается, она действительно не ассоциативна, там вообще ничего
непонятно, что с ней происходит. Ну ладно. Вот. Окей. Ну это все конечно круто, но заметьте,
мы с вами говорили, что у нас есть как бы здесь две вариации, здесь две вариации,
здесь две вариации. Ну ладно. Если мы умеем онлайн, то отлайн понятно как делать. Но у нас здесь аж
статик динамика и рамку и раску, то есть аж четыре варианта всего лишь. Статик и раску мы умеем,
но мы ничего про динамик не умеем. Вот пришло время раскрыть великую завесу тайны и решить одной
штукой динамик и раску и динамик и рамку сразу. Ну понятно дело она и статик позволяет. В чем она
будет уметь делать это онлайн, поэтому и офлайн. То есть это такая убер структура данных, которая все
умеет вообще. Ну те кто знают, те знают, те кто не знают, представляю. Дерево отрезков.
Как мы с вами уже привыкли делать с деревьями, у нас что куча была бинарным деревом,
что дерево отрезков будет таким же деревом, что и куча, то есть массиве хранится. Как оно устроено?
Давайте нарисуем массив. Вот у вас 8 элементов. Бывает конечно, но мы будем все время вжить,
что это массивчик. Вот понятно дело, что можно указать как просто дольше будет.
Короче говоря, есть случаи, когда нужно именно на указателях писать, но мы их скорее всего не
будем в курсе разбирать. Персистентное. Персистентное дерево отрезков необходимо
указать. Это которое хранится в своей версии дополнительно. Вот такой у нас массив.
Давайте в качестве операции f возьмем плюсик. Дальше делается следующее. Вот ваше дерево.
Передаваем бинарную кучу в гриме. У нее есть нижний слой, слой чуть повыше, чуть повыше и корень.
Да, мы для суммы конкретно. Давайте скажем так, что f, что это плюсик в нашем случае. Можете
рассматривать нод. Здесь есть числа отрезательности, мне не очень понятно, что делать с нодом. Не знаю,
например, какой-нибудь побитого и. Рассмотрите, оно тоже будет подходить. Как работает построение
этой штуки? Сразу мы будем считать, что длина массива исходного это степень двойки. Если нет,
то добейте нулями до ближайшей степени двойки. Нули для суммы или просто нейтральными элементами.
Вот у нас первое требование – это существование нейтрального. Давайте сюда будем требования
выписывать. Ну первое – это ассоциативность, очевидно. Потому что если у вас нет никакой
ассоциативности, то вы просто не можете раскрывать f от подотреска каким-то образом вообще. Второй
случай – это второе требование – существование нейтрального. Нейтрального. Умные люди говорят,
что это маноид. Называется такая структура с двумя множеством сведенных на миминальной
операции. Доверяющий ассоциативности существования нейтрального – это маноид. Но я этих умных слов
не знаю. Окей, про построение. Длина массива – два степеника, иначе добиваем нейтральными.
Вот, это первое. Что делаем дальше? Массив Т – это массив дерева. Т – длины,
будто бы 2 на 2 степеника минус 1. Потому что нам нужен этот массив длины 2 степеника,
и еще вот здесь сверху степеника минус 1. Поэтому такая вот длина интересная. Ну или 2n-1,
если у вас n была длина. Вот. В какой форме мы будем заполнять? Будем делать следующий.
4i равный. Еще будет сложно. Видимо, n-2. Нет. Мы делим вот это n, а все, что сверху будет n-1,
видимо, длины. Считаем, что у нас массив этот построен уже, и у него в конце записаны эти
элементы во второй половине. То есть у вас будто бы был ваш исходный массивчик длины n,
и ему приписали в начало еще n-1 элемент. Вот. Тогда как заполнить все верхушки дерева?
Вот если у нас есть индекс i, чему его индексы dc равны? В куче были. 2i плюс 1, 2i плюс 2.
Все. f от t, 2i плюс 1, t от 2i плюс 2. Все. Отвергается, что этот алгоритм заполнит вам полностью
все дерево. Ну почему это так? Это построение. У нас есть массив. Нам обладали изначально. Все.
Онлайн запрос в смысле приходит. В этом плане. Но еще будет запрос изменения элементов в массиве.
Вот. Пока что мы гарантируем лишь то к себе то, что у нас длина массива меняться не будет. То есть
мы не умеем просто взять и удалить откуда-то элементы или добавить куда-то элементы. Мы научимся все
это делать, но не сегодня. Через 2 недели. Там мы вспомним декартовое дерево еще заодно.
Клучайно упомянем. Вот это вот работает построение. Как вы можете заценить, оно работает за линию.
То есть потому что у вас здесь есть фор, который докидывает нулями до, ну нейтральными до степени
двойки. Это вот эта вот длина массива. Иначе добавляем нейтральными. Дальше у вас есть
удвоение этой длины. Просто вы делаете новую массив, копируете вот его конец старый. И теперь
дальше оставшийся фор добивает верхушку. Итоговое время построения линейное.
Окей, следующий раз сделайте этот запрос. Давайте я нарисую где-нибудь одно большое дерево,
на котором буду все показывать.
6, минус 7, здесь 8, здесь 9. Вот наш дерево. Ну какие индексы хотите? ЛР назовите, покажу как запрос на них делать.
0, 1, 2, L, 3, 4, 5, 6, R. Не худший выбор. Стоим в корне. Давайте еще для каждой вершины
понимать, за какие отрезки она отвечает. То есть эта вершина, она хренится результатом всего массива,
например. Ну плюс-минус понятно как это делать. Ну, например, вы знаете высоту там и можете
оценить левый индекс, там правый индекс, как-нибудь так. Вот. Ну или вы можете просто передавать
границы массива 0, что это граница запроса функции, что у вас текущий отрезок, который вы контролируете,
это с 0 по n. Вот. Вы стоите и смотрите, у вас 3 случая будет. Случай 1. Давайте запрос LR,
индексы контролируемого под отрезка,
под отрезка. Пара LR. Вот. То есть, например, в нашем случае, когда мы стоим в корне,
это LR. Если мы стоим здесь, то у нас вот под деревья это 1, 2. То есть LR здесь, R здесь.
Что? Нет. У нас бывают 3 случая. Случай 1. Это отрезок LR в пересечении с отрезком запроса.
Это пустое множество. Давайте я буду обзывать нейтральный элемент E. Ну, как обычно это обзывают.
Вот. Тогда мы из этого зала возвращаем нейтральный элемент. Второй случай. Это отрезок LR у нас будет
вложен в отрезок запроса. Например, для данной вершинки, вот для этой вот. Вот здесь вот. Вот она,
по дереву ее. Вот LR будет здесь. Они вложены в маленькие. Что мы должны вернуть?
Значение в узле. И третий случай. Это не то, не все. Вы как бы и пересекаетесь, и не вложены. То есть,
остальное. Да, вы должны. То есть, вот здесь вот. Вот ваш LR. Вы вроде бы и не вложены,
но и пересекаетесь. Значит, вы запрашиваете запросы от детей. Просто-напросто. Верни.
Ну, все равно тут даже на псевдокод и близко не пахнет, поэтому можно и русским языком написать.
То есть, я фод дети, вы вернули отсюда какое-то значение, отсюда какое-то значение и применили
к ним LR. Давайте рассмотрим обработку этого запроса. Вот мы стоим в корне. Вот наш LR,
большой такие. Это 0 и там n-1, допустим. Вы такие смотрите, ага, как проверять,
что отрезки вложены. Но это несложно делается. Вам нужно проверить вот такую цепочку неравенств.
Ну, это гарантировано само собой. То есть, вам нужно проверить вот эти две штучки. Это
равносильно вложенности. Ну, как проверить отсутствие пересечения, думаю, тоже понятно. Это
совокупность того, что либо у вас LR слева целиком от этого, либо справа целиком от этого. Ну,
проверить понятно. Нужно сравнить соответствующие границы. Либо эти, либо вот эти две. Вот. То есть,
когда вы спуститесь сюда, и как разбивать случай, если вы идем вниз? Вы берете просто и вызываете
функцию запрос с индексами левой, серединка, серединка плюс один правый. Вот так вот. Тогда вы
получите то, что вам нужно. То есть, вы будете корректно поддерживать эти вот LR. Ну, ладно.
Вот мы стоим здесь. Ну, и текущим стейк-рекурс у нас этот и этот есть. Смотрим на этого чувака.
У него R вот здесь вот. Отрезки пересекаются, но не вложены. Должно спуститься вниз.
L больше, оказывается, вот тут вот. Как видим, все вложение. Возвращаем от этого чувака вот сюда
вот минус один. Ну, так как мы здесь еще от ребенка запустились секурсивно, раз мы вниз спустились,
да, видим, что здесь пересечение пустое с LR. Отсюда возвращаем нейтральный элемент. Ну,
в нашем случае ноль просто, потому что у нас сумма. Тогда рекурсия выкинет сюда вам минус один.
То есть, это результат суммы на вот этом вот части. Минус один плюс ноль.
Окей, дальше. Вот мы здесь находимся. Смотрим, есть ли пересечения. Я перерисую границы. Теперь они
вот здесь вот. Пересечения есть? Снова никто не вложит. Грустная история. Окей, тогда вызываем
сеть детей. Рассматриваем отдельно для этого. У него L здесь, R здесь. Ну, вложение. Все. Поэтому
отсюда выскочит минус один. И здесь закончилась ветка рекурсии. Вот он выскочил, идем сюда. Здесь
запросы следующие. LR. Пересечения есть по одному элементу? Вложения нет. Что? Да, мы вниз сейчас
пойдем. Вот мы стоим здесь, у нас запрос такой вот. Вот у нас есть пересечение равно по одному элементу,
поэтому мы идем в дети. Да, потому что у нас здесь просто один элемент, мы от него возвращаем восьмерку.
Отсюда мы возвращаем ноль, потому что он не входит в запрос. Поэтому сюда вернется восемь,
тогда отсюда вернется семь. Да, отсюда вам вернется шесть. Давайте посмотрим,
что в итоге это будет. Надо посчитать ответ. Минус один, пять, плюс восемь, тринадцать,
минус семь, шесть. О, мы даже не ошиблись нигде при подсчетах. Вот. Так работает запрос. Но в коде
это тоже очень легко делается на самом деле. То есть вы смотрите, если такой случай, возвращайте
нейтральный. Если такой случай, возвращайте значение в узле. Если такой случай, вызывайте
рекурсивно от детей. Все. Там кода, ну, пятнадцать что ли строчек будет. Нормально там поставился расписок.
Я же сказал, что можно два неравенства проверить. Конечно, у вас же это естественно выполнено. Ну,
если вы совсем не напортачили в коде, то оно выполнено естественно. Поэтому нужно вот эти два
проверить, систему из двух неравенств. Здесь система из двух неравенств, здесь будет совокупность,
если что. Вот. Окей. Что теперь? Сколько это работает? Вопрос зал. Почему за лагеритм? У меня же
может быть много вершин на одном уровне? Видите, у меня же тут много цепочек разных спуска.
Почему это вдруг? Нет, это неправда. Это неправда, мы здесь нигде префиксу не сводили.
Ну, если у меня запрос будет целиком здесь находиться, то у меня не будет никакого разделения
на префиксы. Здесь эта идея не очень работает. Вот. И так анализировать сложно достаточно,
как вы видите. Это спорно, потому что у вас отрезок может быть совсем странным. Например,
это будет вот такой вот подотрезок. Там придется взять отсюда, отсюда, отсюда и отсюда. Все,
тут много разветвлений. Это как раз ревиальный случай, потому что мы просто берем, то есть мы
в девятнадцать разбиваем на два гирна. Потом у строки мы берем лево-с, право-с, пускаемся в право-с или лево-с.
Берем право-с на целиком. И шестнадцать мы берем лево-с на целиком и пускаемся в право-с.
Так их может быть много. Они все маленькие, но их может быть много в этом проблема.
Почему это они золотые единички? Друг там какие-то две, какие-то там три, какие-то четыре,
вообще непонятно. Вот, да-да-да. Давайте докажем это утверждение. Рассмотрим уровни.
Дерево отрезков. Утверждается следующее, что на каждом уровне мы возвращаем из результат
из не больше, чем двух узлов. На каждом уровне результат берется из не более, чем двух узлов.
Нейтрально здесь не подходит. Вы спустились, имеется в виду то, что вы туда вот вернетесь
и отсюда вот выше пойдете. Ну тогда, окей, давайте. Хорошо, окей, не более четырех раз. Вот,
эта оценка верна. Как не считай вот эту фразу. Четырех раз. Хорошо, давайте рассмотрим уровень,
на котором берется более. Предположим противное. От противного рассмотрим уровень с больше либо
равно 5 вершинами, из которых возвращается результат. Тогда я утверждаю, что в эти 5 вершин мы могли
прийти как минимум из трех вершин на уровне выше. Это логично. На уровне выше
рассматривались больше либо равно трех вершин. Очевидно, среди них есть самое левое и самое правое,
что-то посередине. Обзовем их L, M, R. Ну левая, серединка правая. Причем серединка не в смысле
прям всянеархметическая, что-то там где-то между ними. Вот, по-другому пустим ветку. Если L, M, R подряд
идут, вот так скажем, то очевидно, что у хотя бы двух из них общепредок есть. Вот, то есть вы берете
три подряд, хотя бы у двух из них, точнее так ровно у двух из них один отец. Вот, то заменяем
запрос от детей с общим отцом на запрос от отца. Вот, давайте теперь скажем, что они не подряд стоят.
Значит, хотя бы между какими-то из них есть дырка, хотя бы в одну вершинку. Согласны? Допустим,
между L и M, без ограничения общности, утверждается, что у L и M есть общепредок. Вот. И что этим можно
сказать? А, что мы не могли просто так взять? У нас нет такого запроса, который учитывает только
эту вершину и только эту, но не учитывает то, что между ними. А это значит, что мы берем вот эту вот,
соседа его, а значит, что мы бы спросили на уровень выше просто-напросто. Так и есть, это хорошо. Это
значит, что мы не спустимся в M просто-напросто. То есть, нас не может считать среди на запроса. Вот,
что хочу сказать вам на эти сотрустые доски. То есть, первый случай они подряд,
вторых случай не подряд. Вторых случай не подряд. Без ограничения общности между L и M есть
индекс P, хотя бы какой-то. Вот. Тогда что можно сказать следующее? Сейчас. Будем как-то сформулировать
вместе. Вот. Если между ними есть индекс P, то что тогда? Между ними есть индекс P, то либо,
под отрезок PM, под отрезок, то индекс P, он очевидно принадлежит LR.
Вот. Но если мы спустились до L и M, значит, мы исключили из рассмотрения поддрева индекса P,
чего быть не может, нас подряд под отрезок идет. Но тогда мы исключаем поддрева P из рассмотрения.
Из этого следует, что запрос не непрерывный под отрезок.
Вам приходит запрос обновить в индексе E элемент. Давайте постираю всякую эту лажу.
С вами рисовали. Я оставил чистое дерево. Прижем с него лишнее. Это страшное рассуждение.
Вот. Вы находитесь в вершине E. Вам сказали обнови элемент по индексу E. Как получить?
Вот у вас индекс E приходит. Индекс в дерево какой? Н минус 1 плюс E. Все. Окей, хорошо. Вы меняете элемент.
Да, просто вы должны спуститься в дерево вниз. Вот один шаг. У вас же есть индексация.
Окей, хорошо. Допустим, минус 1 хочу на 5 поменять. Вам нужно обновить результат на пути.
Это не очевидно, как по пути их обновлять. Короче, по пути мы будем обновлять по причине следующего раздела.
Так скажем. Вот вы идете здесь. Дальше вы поднимаетесь вверх, пересчитываете результат.
Да, просто F от детей. Дальше F от детей. То есть вы знаете индекс родителя и говорите, что чувак в родителе это F от двух индексов.
Вы говорите, что на каждом этапе здесь уже корехные значения лежат внизу. Все. То есть вот у вас индекс в дереве.
Ну индекс родителя вы помните, да, как определяется. И от этого еще берется все. Минус 1 на 2 округленный вниз. Это родитель.
Второй уровень я не буду писать. Короче, вот вы родитель берете. Снова родитель.
И здесь, здесь это будет просто применение F к детям.
К родителям. От детей. Вот так скажем.
То есть вы один раз поменяли здесь и все. И дальше у вас от родителей вызываете F рекурсивно, пока до корня не добрались.
Ну как в куче было примерно просивания вверх. Здесь тоже только у вас. Вы останавливаетесь только когда до корня дошли и все время F применяете. Все.
Ну здесь очевидно, что логарифмы согласны.
Думаю, что высота дерева логарифм. Отлично. Здесь доказывать ничего не нужно.
Окей, теперь самая пушечка от дерева отрезков.
Это будет...
Вот обновление в точке это конечно классно.
Но давайте сделаем по-другому немножко. Расширим спектр возможностей.
Да.
Обновление на подотрезке.
Пусть G это операция обновления.
Вот.
Нет. Поверь, нет. Мы сейчас сделаем только логарифмы.
Окей, в чем главная суть этой все вещи?
Суть следующая, что мы не будем это делать явно. Будем делать это максимально лениво.
Максимально лениво. Что это значит лениво, я объясню.
Пусть же операция обновления. Например.
Взять и сказать, что все числа на подотрезке равны 3.
Или сказать, что все числа на подотрезке умножаются на минус 37.
Или там, не знаю, у всех чисел на подотрезке берут по битве И с чем-либо.
Вот так и вот операция обновления имеется в виду.
То есть никак бы с каждым элементом отдельно играют.
Свойства операции G.
Какие мы хотим?
Ну, очевидно, G ассоциативно.
Куда ж без этого?
Случай 2.
Существует нейтральный.
Уже.
Вы можете догадаться, что они нейтрального, но никаких ограничений в накладке.
Вы можете довести эффективное значение, которое никогда не встретится, и сказать, что оно нейтральное.
Вот, а случай 3 интересен.
Открывается дистрибутивность по отношению к f.
По отношению к f.
Сейчас я подумал, как это буквками записать.
Сейчас что-то типа G от f от a b.
G равно f от.
Что-то типа такого.
Страшно, очень страшно.
Сейчас посмотрим.
Да, спасибо.
Чтобы вспомнить, как это буквами пишется, я всегда вот так вот делаю.
Вот у меня один аргумент это c на a плюс b.
Это a c плюс b c.
Вот что значит дистрибутивность.
Что вы можете распылять на детей.
С чего это надо будет. Сейчас мы посмотрим, что такое ленивая операция.
Нам потребуется операция проталкивания.
Сейчас мы их все обсудим.
Давайте у нас будет запрос.
Не знаю, запрос суммы и запрос.
В том году я просил умножение на отрезки, и меня забулили.
Поэтому будет запрос прибавления на отрезки.
Вот я предложил студентам называть мне запрос, они мне просили умножить на 30 с чем-то там отрезок.
Я был разочарован этим фактом.
С тех пор я не доверяю людям.
Вот дерево отрезков на сумму.
И в каждом элементе мы еще будем хранить маленькую величину, называемую несогласованностью.
Вот маленькая фасолинка.
Был бы у нас цветной маркер, жизнь была бы ярче.
Я предлагаю вам, зрители, называть запрос.
Хорошо.
Вот так что ли?
Плюс равно два.
Что происходит? Происходит следующее.
Мы делаем все абсолютно ту же логику, что и во взятии запроса.
Потому что мы верим в утверждение, которое я стер, что там все хорошо работает.
Поэтому мы делаем все абсолютно так же.
Спускаемся в детей, смотрим, дети не вложены, хорошо, идем сюда и сюда.
Вот здесь вот два чувака лежат.
Дальше смотрим, есть пересечения?
Поехали.
Пишем сюда два, несогласованность, потом такие, блин, это же лист.
Раз то лист, мы сразу же будем избавляться от этого действия и напрямую прибавлять к листам.
Закончилась здесь рекурсия.
Остались здесь. Теперь мы вложены.
Мы говорим, давайте пока приказ прибавить два, полежит здесь.
Аналогично здесь будет ситуация.
Здесь будет 10 просто.
Давайте еще.
Допрос. Кажется, у нас здесь есть несогласованность.
Мы когда-то потом их передадим детям.
0, 1, 2, 3, 4, плюс 3.
Ну окей.
Идем сюда, пересекаемся, идем сюда, перейдем сюда.
Где?
Вот здесь вот.
А, да, все окей, у нас есть этот трезог.
А здесь мы спустимся до конца, мы обновим это значение.
А, ну да, извините, я конечно обманул вас всех.
Я же когда изменил в листе, я должен подняться обратно вверх и обновить.
Нет, почему?
Так, вот запрос был плюс равно два, да?
Вот, я изменил в этих точках и в этих точках значение.
Причем здесь я уже увеличил. И теперь я должен от них подняться вверх.
Ну от листьев, мы же только листья обновили.
Но у нас же есть спуск рекурсии.
Есть и подъем рекурсии, на каждом из которых мы обновляем значение.
Какая разница?
А тех узлов, с которых вы запрашивали, вы будете запрашивать апдейт у родителя.
То есть вот вы допустим здесь там, да, вы прокинете просто все значения.
Да.
Даже если бы здесь делали, все равно вот сюда спустились рекурсии за логорифом, значит поднялись бы рекурсии за логорифом.
Давайте обновлю значение.
Здесь тоже.
Ну что, все валидно было на подотреске.
Да, давайте я сейчас отру заново дерево и нарисую, потому что мы тут запутались с этим.
А, итак.
Вот все, вот наше исходное дерево, да.
Уже модифицированное чуть-чуть.
Ну что, у нас все в порядке.
Ну что, у нас все в порядке.
Ну что, у нас все в порядке.
Ну что, у нас все в порядке.
Уже модифицированное чуть-чуть, но оно вроде корректное, да.
19, минус 1, 18, 5, 6, 1, 29.
Да, дерево корректное.
Вот нам снова приходит запрос, вот этот плюс два.
Мы говорили, ага, спускаемся вниз рекурсивно
и пишем несогласованности просто везде.
Дальше, когда мы поднимаемся вверх по рекурсии, мы спрашиваем о чистых значениях результата.
То есть вот вы спускаетесь по рекурсии сюда, у вас здесь стала двойка.
Так у вас здесь лист, вы сразу пишете пятерку.
У вас сюда придет несогласованность два,
сюда тоже два, и здесь будет просто плюс два.
А дальше вы делаете уже запросы, когда поднимается вверх по рекурсии,
также ЭП спрашиваете, но уже от элементов, которые записаны в них.
Игнорируй вот эти вот двоечки всякие.
Не игнорируем, мы поэтому правила собираем,
чтобы у нас здесь стояло действительно настоящее значение.
То есть вот здесь вы идете сюда и пишете пять плюс три, это восемь.
Дальше, когда вы пытаетесь сравнивать здесь, что вы говорите?
Ага, у меня здесь восемь, а здесь есть пять плюс несогласованность два.
Несогласованность два, это значит, я должен был бы каждый элемент внизу
себя увеличить на два, но метких элементов два.
Два ребенка просто из отрезка суммарного.
Поэтому два на два, и я должен вернуть сюда девять на самом деле, чтобы быть правдой.
Вот, давайте посмотрим, что на этом отрезке действительно сумма будто бы девять,
если мы здесь бы на два и здесь бы на два увеличили, то было бы два плюс семь.
Сейчас, или я считать не умею.
Да, все нормально.
Аналогично с этим поступаем. Двенадцать плюс девять, это двадцать один.
Дальше двадцать один, и замечаем, что мы взяли бы минус один
плюс два на длину отрезка.
Два на два, это четыре. Если не плюс четыре, то плюс три. На самом деле, мы все обернули бы плюс три и получили бы здесь
двадцать один плюс три, двадцать четыре.
Восемнадцать плюс двадцать четыре, это сколько? Это сорок один вроде бы, да?
Сорок один минус двадцать девять, это двенадцать.
Сорок два, да, совпало все.
Сорок один, да.
Это просто можно больше запроса сейчас понакидать сюда.
Утверждается? Вот, смотрите, сейчас я покажу, как это исправляется.
Я понимаю, да, мы сейчас это исправим.
Предлагаю, что вы можете сделать, я вернусь.
Не, я не вернусь.
Я понимаю, да, да, да, мы сейчас это исправим. Предлагается сделать следующее.
Бахнуть для вот такого вот подотреска плюс равно два.
У меня же здесь есть несогласованность, я должен был от нее как-то избавиться. Вот.
Что я делаю? Я иду-иду-иду, дошел сюда, отсюда вернется типа ноль, потому что это
нейтральный элемент. Вот я пришел в этот узел. Что происходит здесь? Когда я стою в узле,
я выполняю проталкивание, операция проталкивания. Перед разделением на детей всегда делай проталкивание.
Ну или еще называют push. Проталкивание несогласованности. То есть смотрите,
формально это можно представить так. Представим, что это не дерево отрезков,
а тема чиновников. Вот есть федеральный уровень, региональный там, не знаю,
городской и муниципально-районный, например. Что дальше происходит? Вот стоит чувак и говорит,
давай-ка ты дашь приказ вот этим вот чувакам из этих вот всех
фрагментов увеличить на два, не знаю, что-нибудь. Приказ там увеличить на два пенсии, например.
Вот, если ты оказываешься, что? Ну я не знаю, на сколько, там условных единиц. Вот. Если ты
оказался типа в листом в запросе, ты как бы сразу обновляешься. А типа чувак этот, он такой,
блин, ну мне влом совсем сразу думать передавать. Как-то совсем не по-людски что ли. Давайте я
попридержу у себя указ. Вот. А дальше типа потом, когда придут и спросят с меня, я протолкну приказ
вниз и скажу, что взятки гладкие, я чист. Примерно такая здесь работа. То есть как бы вот здесь вот,
вот когда вы зайдете сюда, у вас случится, что ага, у меня есть не согласованность два, блин,
как бы я сейчас приду проверять что-то. А у меня должно быть ноль долгов перед родиной. Поэтому я
что делаю? Я беру и говорю, а я девять. А сюда проталкиваю по двойчике. А все, аж это крыто. Вот.
И говорю себе при этом, что у меня там еще плюс два, она тут спустится еще сюда и сюда. Вот эти вот
плюс равно два, она спустится сюда, не спустится, а сюда спустится. Вот. И у вас еще придет плюс два сверху
от запроса. Поэтому у вас на согласованность будет четыре на самом деле здесь. Потом он скажет такой,
блин, ну я в менсипальном уровне, надо что-то делать в конце концов. До меня еще могут достучаться
избиратели, поэтому я превращаюсь сразу. И мне долгов быть не может. Ну так же как и этот.
Вот. Это предыдущая двойка была разве? Нет, мы ее меняли, мы не можем в листе держать
не согласованность никогда. Да, мы забили на это, да? Короче, ладно, где-то здесь произошел баг? А,
потому что мы сюда двойку сверху скинули, все. Ну здесь мы сразу автоматически трансформируемся,
потому что самый ниже уровень чиновников долгов не имеет никогда. Ну и поднимаемся вверх,
обновляя. Это правда, но эти элементы не знали об этом. До детей не дошел приказ. И вот только
потом мы его скинули. И сказали, у нас здесь все взятки гладкие, все чисто, мы свое учли. И
здесь мы отправили делать дальше. Ну или там, не знаю, окей, ладно, еще другая аналогия там, не знаю,
приказ там починить дороги. Вот. Есть там, типа вот, сказал там мэр, надо починить там дороги,
надо починить там, не знаю, треть транспортной кольцо, там яма. Мэр такой, спускает там районным
своим чувакам. Районные такие. Там, не знаю, еще кому-то там спускают, спускают, спускают,
пока рано или поздно не придется выполнить все свои обещания. Вот обещания выполняются вот
этими вот рядовыми челиками. Вот причем вот этих вот чуваков вообще не волнуют, что происходит
внизу. Они просто прокидывают свои долги вниз на детей эти, посваливают и такие все. Если ко мне
придут спрашивать, то я чистый, у меня долгов нет. Здесь такая идея. Но абсолютно аналогично здесь,
что у вас здесь была несогласованность 2, нам пришел, давайте вот так вот сделаем,
вот, чтобы было интересней чуть-чуть. Пришла несогласованность 2, а он такой, ага. Адиссея не
буду вызываться, значит меня проталкивать не нужно. Ну и плюс равно 2, значит мне несогласованность
здесь 4 вообще становится. Ну и дальше я поднимаюсь вверх следующим образом. Я такой смотрю, ага.
У меня здесь минус 1, плюс 4 умножить на длину отрезка. Да? Да. Минус 1 плюс 4 умножить на длину отрезка
это минус, это 7 просто. Здесь будет 28 на самом деле.
Где? Здесь? Ну извините, это вопрос. У вас может быть запрос суммы, тогда этот
чувак скинет просто на детей. Например, по-разному может быть. Да, ну пуш у вас,
смотрите, то есть всегда, когда к вам приходят, приходят за вами, да, либо вы понимаете,
то есть либо как бы спрашивают целиком с вашего участка, а свои долги вы знаете,
а значит вы можете как бы сказать, что вот мои долги, все прозрачно. А если пойдут еще в детей,
то как бы надо такой, о, так это возможность скинуть, раз идут к детям, скинуть я к детям это все,
а сам себя в нулю. Ну так сказать, да, долги по наследству передаются. И когда все-таки
добираешься до последнего ребенка, который все еще живой, ты такой, ну блин, придется выполнять
долги по наследству. Вот. То есть здесь такая. То есть у вас есть ленивые операции, вы явно
никогда операции не проводите. Вы проводите операции тогда, когда время настанет. Ну или,
например, не знаю, тут можно аналоги с студентом принести, что ему дают долги, дедлайны дают,
дают, дают, дают, дают. И пока вот у него не спросят конкретный дедлайн, он их будет где-то копить.
Когда он спрашивает конкретно, ты такой, ай-яй-яй-яй, быстро раскидываем. Все, эвакуация долгов срочная. Вот,
у него спросят конкретно это, и он такой, ага, так, у меня были долги здесь, перекинуть сюда и сюда,
этого трогать не буду, потому что его же не просит, дедлайн-то не пришел еще, здесь вот. Ага,
спрашивают этот, придется по детям снова раскидать. Вот примерно так. И суммарно это все работает каждый
раз за логарифом, потому что у вас запрос, по сути, такой же, как при запросе этого.
Или запросите на отрезки просто, результаты. Вы делаете все абсолютно то же самое, только у вас
иногда возникает этот пуш. Собственно, пуш он зачем нужен? Он нужен, чтобы сказать,
меня взятки гладкие, и перекинуть детям их обязанность. То есть, получается, будто бы left.
Мы здесь бух не вводили, я уже не буду. Несогласованность плюс равно, давайте,
вот g происходит, равно g от несогласованность, запятая родитель.несогласованность. То есть,
вы как бы аккумулируете свои несогласованности, что у вас было, и с родительской. То есть,
у вас как бы своих долгов хватает, у вас еще родительский. Хочешь жить, уметь вертеться.
Все то же самое. Здесь будет write, несогласованность, родительская несогласованность. Ну и как бы
счастливый момент. Родитель, несогласованность равно нейтральный по g. Теперь смотрите внимательно,
зачем здесь нужна дистрибутивность? Это не проталкивание от детей. Вот эта операция,
то, что вы можете g перекинуть на детей, это и есть эта дистрибутивность, по сути. Здесь требования
дистрибутивности возникают не просто из ниоткуда, а, наоборот, из алгоритма вытекают напрямую. Просто
формализация. Вот. Так, у нас остается две минуты, вроде бы. Три, может. Да, ну любая операция алгоритм.
Потому что мы делаем все так же, как с запросом. Казалось бы, если бы мы не останавливались бы
сразу в вершине, типа вот у нас здесь несогласованность 4, мы пошли бы дальше бы ее протаскивать.
Это понятно, что я работал бы за длину отрезка. Нет, если бы мы дальше выходили вниз проталкивать
все время до конца, то бы обновили, по сути, весь подотрезок. А так мы остановились в какой-то момент.
Нет, нет. Там у нас суммарно почти с не более чем 2n вершин. Нет, если вы явно будете каждый раз
запускать по обновлению одного линтуда, это правда. Да. Вот. Ну короче, вот. Это вот подход
таких ленивых операций. Его называют ленивые операции, отложенные операции. Они краски нужны
для того, чтобы явно все не моделировать. Когда вас спросят, скажут, что а все готово. И неважно,
что внутри происходит. Как мем про Гомера Симпсона, который типа вот такой вот весь красивый-красивый
с одной стороны, с другой стороны, у него там дети в долгах. Вот. Примерно так. Ну короче, да.
Такая вот идея. Вам понятно? Ну кому не понятно, это грустно. Кто-то поймет. Вот. Тогда все, давайте до следующей недели.
