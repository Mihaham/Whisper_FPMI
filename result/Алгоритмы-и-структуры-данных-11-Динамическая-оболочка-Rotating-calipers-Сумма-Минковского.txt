Волочка неинтересна, при положительных B нужна только
верхняя.
Вот при положительных B нужна только верхняя.
Хорошо.
Значит, ну тогда давайте считать, что B положительно
рассматриваем только верхнюю оболочку.
Вот как-то так она выглядит.
И теперь, если я рассмотрю все стороны как векторы,
то мы как бы помним, что они у нас все вот так вот
заворачиваются по часовой стрелке.
Каждый последующий вектор по сравнению с предыдущим
вращается на некоторый отрицательный угол, потому
что направление у нас по часовой стрелке это отрицательно.
Ну и тогда дальше смотрите, если я посчитаю чему равно
скалярным произведением вот этой точки с вектором
A-B, чему равно скалярным произведением этой точки
с вектором A-B и так далее, то у меня отверстие сначала
будет увеличиться, а потом уменьшаться.
Потому что из-за того, что эти векторы у меня как
бы строго упорядочены, они идут в таком порядке
заворачивания, у меня сначала векторы будут как бы
сначала, грубо говоря, сонаправлены с вектором
A-B до какого-то вот этого момента, а дальше каждый
этот вектор будет нас только отдалять от вектора A-B
и будет тем самым нам уменьшать скалярное произведение.
Более формально у меня скалярное произведение
вот этих вот всех векторов сторон с вектором A-B сначала
положительное, потом отрицательно.
Давайте я нарисую, пусть это будет V1, V2 и так далее,
и V1, V2 и так далее, за какой-нибудь K.
Это вектор AB, пусть я его назову U.
Тогда все скалярные произведения вначале положительны, вплоть
до какого-то VI.
А потом начиная с I-1 отрицательно, вплоть до K.
Сначала скалярные произведения возрастают, потому что
значок больше нуля, потом он начинает убывать, потому
что значок будет меньше нуля в скалярном произведении.
Так.
Ну почему это верно?
Потому что если у меня где-то нашелся значок больше нуля,
то значит угол между ними тупой, между этими векторами,
а значит угол между вектором U и следующим еще более тупой,
потому что они все отклоняются друг от друга по часовой
стрелке, поэтому этот угол будет только увеличиваться.
То есть если вот здесь вот у меня уголок острый,
какой-нибудь, вот такой маленький, небольшой, здесь не маленький-маленький,
то если оно с какой-то моментом начинается тупым, то дальше
будет со времен тупой угол.
Поэтому действительно у меня сначала вот эти вот
векторы с вектором U дают положительное в скалярном
произведении, потом отрицательное.
Ну и из-за линейности в скалярном произведении я понимаю,
что при движении по вот этим векторам у меня скалярное
произведение с текущей точкой только увеличивается,
да, то есть у меня было какое-то изначальное скаллярное
произведение в этой точке,
потом я прошелся вдоль вектора, которое мне увеличило
скалярное произведение, значит стало больше, потом
еще больше, еще больше, еще больше и еще больше.
Вот здесь максимум, а дальше она начинает падать,
а поэтому что бы найти вот эту точку, где достигается
максимум мне нужно понять в какой момент у меня
происходит перелом от положительных скалярных
произведений к отрицательным, и это может сделать например
бенпоиск consistency image.
чтобы найти i такое, что v i на u положительно, а следующее уже отрицательно,
можно использовать бинарный поиск.
То есть мы встаем l сюда, r сюда, взяли полусумму и посмотрели на вектор v м-тый. Скалярно его
умножили на u. Если получилось положительно, значит точка перелома где-то правее. Значит
надо взять l равно m. Если отрицательно, то точка перелома где-то левее, r равно m. Ну все,
у нас в конце получится, что в какой-то конкретной точке происходит перелом, а значит ответ
достигается ровно в этой точке. Мы понимаем точку, в которой происходит перелом от положительных
скалярных произведений к отрицателям, в ней и будет максимальная скалярная произведение,
потому что сумма всех этих векторов увеличивает скалярное произведение, а любое другое уменьшает.
Итого, если у нас построена выпуклая оболочка, то для конкретного вектора a-b мы можем найти
ответ за логарифмическое время. Вот луген, если конс в s уже построен.
Ну и то же самое, если b меньше нуля. Если b меньше нуля, то мне нужна, наоборот,
нижняя выпуклая оболочка. Значит, тогда рассматриваем нижнюю выпуклую оболочку.
Там все аналогично. Если здесь мне нужна была верхняя, потому что у меня вектор как бы смотрит
вверх, то теперь нужна нижняя. Ну, собственно, аналогично. И там тоже работает бин поиск,
что сначала у меня скалярное произведение увеличивается, потому что я ищу экстремальную точку
в таком направлении. У меня сначала угол увеличивается, потом начинает уменьшаться,
потому что здесь скалярное произведение больше, а потом меньше. Соответственно,
мне нужна точка, где происходит взлом. Ну, если где-то равенство, то получается у
меня сторона перпендикулярная моему вектору, значит максим достигается вот на этой стороне,
можно в качестве это взять любую из этих двух точек, вот, ну вроде все опять за
логарифом, да, то просто бинпоиск на нижней выпуклоболочке. Значит, если же у меня
множество точек S было динамическим и оно как-то там изменялось, расширялось, то
мы можем хранить отдельно верхнюю, отдельно нижнюю в каких-нибудь структурах,
а мы это с вами уже в прошлый раз делали. Если S динамическая, то верхнюю и нижнюю
выпуклоболочки мы с вами хранили в сытах. Ну вот, значит, можно хранить в каких-то там
деревьях поиска. Мы говорили, как тогда уметь вставлять куда-то выпуклоболочку,
то есть если у меня есть какая-то текущая верхняя выпуклоболочка, пришла новая точка,
мне нужно найти бинпоиском в этом дереве поиска, где она входит, ну и соответственно,
как бы провести вот такие касательные и удалить все точки, которые нарушают выпуклость. Вот, ну и
соответственно, а если у меня моя верхняя выпуклоболочка хранится в каком-нибудь дереве
поиска, то в ней же, в нем же можно использовать вот этот трюк с бинарным поиском. Если у вас все
хранится, ну скажем, в Декартовом дереве каком-нибудь, то вы можете искать в Макисовом склярном
произведении по сути с куском по дереву. То есть если здесь вам нужно был бинарный поиск по массиву,
теперь представьте, что это не массив, а дерево поиска какой-нибудь, там АВЛ, Декартово,
что-нибудь такое. Тогда, ну по сути, вам нужно сделать бинпоиск, но бинпоиск в дереве поиска мы тоже
умеем делать. Для этого надо идти по дереву сверху вниз, брать какие-то два соседние элемента,
сравнивать склярное произведение с данным вектором у с нулем, если больше ноль нужно идти вправо,
если меньше, то влево. Бинарный поиск превращается в спуск по дереву, а симптомика остается
алгоритмическая. Итого задача, которую мы начали решать такая, мы можем поддерживать множество С,
в которые можно вставлять точки, а еще для произвольного вектора АВ, мы умеем находить
максимум склярного произведения по всем точкам из С. И все запросы мы обрабатываем за логарифм.
Ставка за амортизированный логарифм, максимум склярного произведения за чистый логарифм.
Хорошо. Я не умею, по крайней мере. Единственное, что я умею, это свое дерево писать. Я когда-то спрашивал,
можно ли это сделать? Мне говорили, что вроде можно, но это что-то убийство, поэтому я не пытался понять даже.
Так. Хорошо. Идем дальше. Следующая важная задача. Давайте я его назову. Вращающийся
калиппера. Гуглиться по такому запросу. Значит, формулируется очень просто. Дано
конечную множество точек, надо найти в нем диаметр. Найти диаметр конечного множества точек С.
Диаметр это две точки, расстояние между парами максимально возможное.
П и Ку из С. Дистанция между П и Ку. Надо найти диаметр, то есть максимальное расстояние между всеми
парами точек внутри множества. Первое замечание, что П и Ку имеет смысл брать только в качестве
вершин выпуклооболочки. Диаметр достигается на вершинах выпуклооболочки. На вершинах он в С.
Ну опять, здесь не очень хитро все. Почему это верно? Ну пусть где-то диаметр достигается,
пусть есть какой-то там П и Ку. Какое-то максимально возможное расстояние. Ну давайте
этот отрезок продлим. Да, и при этом там П и Ку внутренние точки какие-нибудь. Тогда давайте
этот отрезок просто продлим до пересечения с границей. Тогда мы попали либо на сторону,
либо уже сразу в вершину. Если в вершину, то уже победа. Мы увеличили ответ и встали в вершину,
поэтому как бы там противоречие, грубо говоря. Иначе мы пришли куда-то на сторону, но тогда я
утверждаю, что опять-таки движение в одну из двух сторон обязательно не уменьшает ответ. То есть,
если я буду двигать, то есть если я сдвину Ку вот сюда и буду двигать его вдоль этой стороны,
то по крайней мере одна из этих двух точек даст только лучший ответ. Потому что, значит,
что такое расстояние от точки до отрезка? Как оно выглядит? Вот есть некий отрезок, есть какая-то
точка. Если я пущу перпендикуляр, то расстояние будет минимально, а любое движение в сторону от
перпендикуляра, неважно в какое, дает мне увеличение. Значит, понятно, что одно из этих двух направлений
как раз-таки идет в сторону от перпендикуляра. То есть, если скажем, перпендикуляр это здесь,
то у меня вот это увеличивает. Если перпендикуляр это вот здесь, то в любом случае хотя бы одно из
них строго увеличивает расстояние. Поэтому движение по стороне в одну из двух сторон до вершины
обязательно расстояние только увеличит. Поэтому можно вместо вот этой Ку взять одну из вот этих
и расстояние увеличится. То же самое с П. П можно вот так вот подвинуть, так чтобы он попал в какую-то
вершинку. Значит, в качестве вот этих П и Ку можно брать не все точки, а только вершины выпуклооблочки.
Лемма. Лемма о диаметре. Пусть ПКу это диаметр С,
пусть L1, L2 это прямые перпендикулярные вот этому отрезку ПКу, проходящие через П и через Ку соответственно.
Прямые перпендикулярные отрезку ПКу, проходящие через П и Ку соответственно.
Тогда я утверждаю С целиком лежит в полосе между L1 и L2.
Доказательства. Вот пусть П, вот пусть Ку. Я рисую отрезок перпендикулярной прямые, проходящие через
конце этого отрезка. Хочу сказать, что здесь нет никого и здесь нет никого. Что вне вот этих вот,
вне полосы нет точек многоугольника, нет точек из С. Ну, это очень просто. Если что-то есть,
вот здесь есть какая-то точка, то я симпенду ви что РП Maria больше, чем расстояние от П до Ку,
а потому что ПКу это расстояние от П до этой прямой, а если точка лежит за прямой,
то соответственно расстояние от ее до… от П до нее будет только строго больше. потому что от П
до Ку минимальное расстояние до этой прямой. А от П до нее это расстояние для какой-то другой прямой,
при этом еще не обязательно перпендикулярно. Поэтому наличие точки за пределами прямой� vere
прямой, нарушая то, что ПК — это диаметр, потому что
у нас есть тогда две точки, между которыми расстояние
больше, чем ПК.
То же самое, если есть точка здесь, то расстояние откуда
нее больше, чем расстояние ПК.
Доказательства от противного.
Тогда ПК не может быть диаметром.
Тогда, соответственно, алгоритм.
Давайте мы возьмем две параллельные прямые L1 и L2, между которыми
заключен целиком наш ногоугольник.
То есть понятно, что вначале мы построили выпуклую оболочку,
потому что нет смысла рассматривать внутренние
какие-то точки.
Построили выпуклую оболочку, заключили его между какими-то
двумя прямыми.
А теперь давайте их вот так синхронно вращать одновременно.
То есть у меня есть две вертикальные прямые изначально, и я начинаю
их одновременно вращать так, чтобы они упирались
об наш ногоугольник.
То есть вначале кратенька така, потом немножко будет
вот так вот.
Ну то есть, не знаю, как-нибудь вот так вот я это нарисую.
И потом в какой-то момент происходит переключение
относительно какой точки происходит вращение.
То есть здесь вот у меня вращение относительно вот
этих двух точек.
Потом, когда у меня очередная прямая будет совпадать
по направлению со стороной, у меня поменяется и дальше
вращение будет не вокруг этой, а вокруг этой точки.
Вот.
Ну и тогда, соответственно, я могу полностью проворощать
вот эти вот две прямые ледяные льдва относительно моего
многоугольника.
Полностью замести там весь круг Родианной Миры
2P.
И, по сути, тогда я переберу все возможные вот эти вот
положения для ледяной льдва.
То есть я не знаю, где находится диаметр, но я переберу все
возможные положения вот этой пары параллельных
прямых ледяных льдва, которые ограничивают мой многоугольник.
Вот.
Ну и для всех таких положений я найду расстояние между
этими точками, о которой опирается собственно наша
ледяная льдва, и максимум из них будет диаметром.
То есть я все возможные положения ледяной льдва
разберу.
Одно из них точно будет соответствовать вот этому
случаю, когда это все перпендикулярно диаметру.
Значит, просто если я возьму максимально возможное
расстояние между прямыми во всем моменте времени,
то это будет ответ.
С алгоритмом.
Ну и, собственно, вот эти вот прямые будут называться
калиперами.
Просто как-то так называется.
С алгоритмом пусть L1, L2, начально давайте вот эти вот
вертикальные прямые, вертикальные прямые, прямые, обрамляющие
наш многоугольник, обрамляющие S, вращаем их синхронно.
Ну и, собственно, поддерживаем точки, относительно которых
происходит вращение.
Ну и по всем состояниям берем максимум вот между
этими двумя точками.
Берем максимум расстояния между этими точками.
Так, идея понятна?
Хорошо, значит, теперь как это реализовать?
Ну, начало я уже сказал, да, мы начинаем с вертикального
положения.
Их легко определить, нужно просто взять точку с минимальным
х, с максимальным х, ну или давайте я вот сразу
такую картинку нарисую.
Вот, у меня будет вот это L1, вот это будет L2.
Просто нужны точки с минимальным х и с максимальным х.
Значит, поддерживаем два индекса И и Ж, вокруг каких
точек сейчас будет вращение.
И давайте вращаться против часовой стрелки.
Вот так у нас будет происходить вращение.
Значит, понятно, что если я буду, если я все превращаю
на очень маленький угол, на угол там какой-нибудь
Эпсилон, да, вот так вот сделаю, то у меня понятное
дело, точки, относительно которых происходит вращение,
не поменяются.
Ну а вот я буду так потихонечку вращать, вращать, вращать.
Поменяется что-то только когда направление прямых,
направление вот этих калиперов, обрамляющих наш многоугольник,
совпадет с одной из сторон.
В любом случае, ну давайте я вот так вот нарисую.
Вот в этот момент, когда направление одного из калиперов
совпадет со стороной, в этот момент у меня как
бы будет сейчас опираться целиком на вот эту сторону,
а если я продолжу вращать дальше, у меня вращение
начнется вокруг вот этой точки.
Ну и соответственно тогда мне нужно сделать следующее.
Мне нужно понять, вот у меня есть две стороны, нужно
понять какая из них находится ближе по углу, то есть в
какую мы упремся раньше.
И скажем, если мы понимаем, что это вот эта сторона,
то мне нужно переключить g на единичку, ну на единичку
увеличить.
А если я понимаю, что сначала у меня начинают упираться
вот сюда, то в этот момент времени, когда начнут упираться,
у меня вращение начнет происходить вокруг точки g
плюс один.
Если у меня вот так вот занумерованы в том же порядке,
против часовой, то мне нужно будет сделать g плюс один.
И каждый раз, когда происходит переключение, значит я
рассматриваю как бы новую пару калиперов, новое состояние,
и текущую пару там, то есть и g плюс один, я проверяю
на, ну то есть считаю расстояние и обновляю диаметр через
текущее расстояние.
Значит, ну, старт, давайте пропишем, я уже проговорил,
это вертикальные прямые, вертикальные прямые.
Дальше, вот пусть есть точка i, вокруг которой происходит
вращение, и точка g, вокруг которой происходит вращение.
Во-первых, не забываем сделать, что ans равно максимум из
ans и dist p, i, t, p, g, t, то есть всегда, если i, g это те точки,
вокруг которых сейчас происходит вращение, не забываем, что
это один из кандидат, как бы, это пара, одна из кандидаток
на ответ.
Значит, дальше строим вот эти два вектора, две стороны,
пусть это будет i плюс первая, это g плюс первая точка,
значит, ну и вот надо понять, в какую из них мы раньше упремся,
если я вот так буду продолжать вращаться, в какую из них
я раньше упрусь.
Ну, давайте напишем, значит, если здесь, как обычно,
хватит векторного произведения, давайте попробуем, значит,
то i, i плюс 1 и p, g, p, g плюс 1.
Значит, вот сейчас оно положительно, тогда давайте
будем делать plus plus g, иначе plus plus i.
Ну, потому что, по сути, мне что нужно, мне нужно,
вот как у меня есть предыдущее положение прямых l1, l2,
мне нужно, по сути, померить вот эти вот уголочки и понять,
кто из них меньше.
И кто меньше, там и сделать переход.
Если здесь угол меньше, то нужно сделать plus plus g.
Ну, а если же я их просто приложу к одной точке,
вот этот пусть будет вектор pi, pi плюс 1, вот это вот вектор
p, g, p, g плюс 1.
Ну, видим, что здесь, в этом случае, у меня поворот
идет против всего стрелки положительной, это как-то
значит, что вот этот вот угол маленький, тогда мне
нужно как раз увеличивать g.
А если бы угол был большой, то есть, картинка была какая-нибудь
вот такая, так, сейчас я нарисую, вот что-нибудь
вот такое, тогда вращение было бы вот таким, а значит,
вектор p, g, p, g плюс 1 более крутой, чем вектор p, i, p,
g, p, g плюс 1, а значит, сначала я затрону p, i, p, plus 1,
то есть, нужно увеличить i.
И только потом, уже только после этого, у меня направление
совпадет с вектором p, g, p, g плюс 1.
То есть, я выбираю, какой из векторов менее крутой,
то есть, какое направление ближе к текущему, с помощью
просто векторного произведения.
Если оно больше 0, то значит, соответственно, вот здесь
вот переход, иначе здесь.
Ну и все, я вот так вот делаю, пока не пройду там целиком,
не знаю, пока i не вернется в стартовую точку, то есть,
я вот так вот целиком все обойду,
пока i не вернется в стартовую точку,
я делаю вот это вот свое преобразование.
Переключаю текущую пару точек i, g,
либо i, g плюс 1, либо i, plus 1, g.
И в каждый момент времени я релаксирую ответ
через текущее расстояние, рано или поздно,
и найду максимум диаметра.
А тут надо еще аккуратненько разобраться со случаем,
что бывает, когда у меня нулевое векторное произведение,
то есть, когда у меня переключение одновременно происходит.
Еще раз?
Нет, не поддерживаем, да.
Сами прямые нам не нужны.
Нам нужно только понимать, кто следующая сторона,
а для этого сами прямые не нужны.
Значит, итак, единственное, то есть,
понятно, что я всегда поддерживаю
две точки, находящиеся на наших прямых.
И если эти две точки однозначно определены,
то есть, у меня касание не по сторонам,
а по вершинам, тогда все нормально,
тогда я точно иду максимум.
Единственная небольшая проблема может быть,
если у меня текущая картинка вот такая.
Что на прямых лежат по две точки,
соответственно, непонятно, кто из них диаметр.
На, я проверю.
Ну, я как минимум не все пары здесь переберу.
То есть, если вот это i и plus 1,
g и g plus 1,
то я, скажем, сначала учту пару i и g.
Так, давайте какой-нибудь цвет возьму.
Тут вроде бы бывают м подмилки.
Я учту изначально i и g.
Потом я вижу, что вектор на произведение
вот этих двух векторов...
Так, неплохая, sorry.
Я учту вот это.
Дальше. Я сначала
увеличу g,
соответственно, учту вот этот вот
отрезок, потом
увеличу i, соответственно, учту вот этот отрезок.
Но в частности, не учту вот это.
Из g в i plus 1.
Но вот надо показать, что тогда это точно не может
Значит, для этого
нужна следующая лемма.
Пусть
a, b, c, d
эти четырехугольник
с параллельными основаниями a, b, c, d.
Причем a, b параллельно c, d. То есть, это либо трапец,
либо параллелограмм.
Ну, вот тогда я утверждаю,
что максимум из диагоналей
больше чем максимум из боковых сторон,
а значит, я точно иду диаметр.
То есть, смотрите, вот у меня как бы
считать, что это трапеция, у меня вот
основание, вот основание.
Я точно учел обе диагонали,
но мог не учесть одну из боковых сторон.
Если я покажу, что максимум из диагоналейchu Xia
больше, чем максимум из боковых сторон,
то значит, я ответ translation все равно нашел.
Так вот, тогда максимум из диагоналей, то есть, видимо, АС и БД, больше максимум из боковых сторон.
То есть, БС и АД.
Давайте, трапезу нарисую.
Да, АС и БД это диагонали.
БС и АД это боковые стороны.
Ну, давайте посмотрим на, скажем, боковую сторону АД. Что при ней происходит?
Что при ней происходит? Тут есть два кифта угла.
Которые в сумме дают 180 градусов, потому что это углы между параллельными прямыми.
Вот, значит, один из них точно больше равен 90 градусов. Но давайте скажем тупой. Вот этот угол тупой.
Значит, с треугольники АДС
сторона АС лежит напротив тупого угла, значит, она точно больше, чем АД.
Значит, боковая сторона точно меньше, чем какая-то из диагоналей.
Если бы угол был прямой, то то же самое катит меньше, чем гипотенуз.
Ну, все, значит, боковая сторона меньше, чем одна из диагоналей, которые соответствуют тупому или прямому углу при
одной из вершин концов этой боковой стороны.
Один из углов
при боковой стороне
АД. Тупой или прямой?
Следовательно, напротив него в треугольнике лежит наибольшая сторона.
Ну, следовательно, АД меньше, чем максимальные из диагоналей АС и БД.
Ну, вот, значит, даже вот в этом случае, когда у меня получается трапец или параллелограмм, я все равно,
да, то есть у меня как бы опорные прямые вот эти калипперы L1 и L2 я нашел, я перебираю, достаточно перебирать не все пары точек, а только те, которые переведут наш алгоритм.
Ну, поэтому как бы диаметр все равно всегда найдется. То есть из этих как бы четырех пар и
одна из этих двух, и плюс один, и одна из этих двух, я точно перебираю две, одна из которых точно диаметр.
Поэтому можно не париться и никаких дополнительных проверок не делать. То есть можно было бы написать, что если у меня прямые
стороны параллельные, то давайте там все четыре отрезка переберем. Можно этого не делать, алгоритм оставить как есть, вот прям вот как там написано без изменений,
потому что все равно обе диагонали рассмотрятся, а значит диаметр тоже рассмотрится.
Да, чудесно.
Значит диаметр оно что нашли.
Поедем дальше, давайте нужно будет такое утверждение, давайте даже теоремы сформулирую, нечего делать.
Пусть с конечным множеством, со сетой с точек P1 и так далее Pn.
Тогда выпуклая комбинация этого множество точек, выпуклая комбинация
этого множество точек, это сумма лямбда 1P1 плюс так далее лямбда nPn,
где все лямбды не отрицательные, а их сумма единица.
То есть это линейная комбинация, где все коэффициенты не отрицательные и при этом сумма равна единице. Так вот тогда я утверждаю,
что CONF S, выпуклая блочка множества S, это в точности множество всех возможных выпуклых комбинаций.
CONF ADS это то же самое, что все возможные выпуклые комбинации.
Выпуклые комбинации точек из S.
S конечный множество точек.
Выпуклая комбинация, почему? Ну вот
все.
То есть в каком-то смысле, да, это как бы такая линейная оболочка множества точек, но только с такими хорошими коэффициентами.
Ну доказательства.
Доказательства. Значит в какую-то сторону вроде бы просто.
Вот в такую сторону. Не очень сложно.
Значит давайте мы
это докажем. Давайте рассмотрим какую-то конкретную выпуклую комбинацию и покажем, почему она лежит в CONF ADS.
Значит из этой всей штуки давайте оставим только те, где строго положительные коэффициенты. Те, которые нулевые, все равно не влияют. Давайте их выкинем.
Значит так вот. Рассмотрим
точку какую-нибудь Q
равную
лямбда и1 п и1
плюс и так далее, плюс лямбда ик
п ик. Ну где выполняется, что все лямбды положительные.
Все лямбда больше нуля, сумма как обычный единиц.
Рассматриваем конкретную выпуклую комбинацию, только выбрасываем из нее нулевые слагаемые.
Вот. Ну и давайте индукции пока докажем, то есть индукции по числу слагаемых, докажем, что точка Q лежит в выпуклой оболочке.
Индукции пока докажем, что Q лежит в CONF ADS.
Ну база Q равную единице тривиально.
База
Q равную единице. Значит у меня есть только одно слагаемое и поскольку сумма коэффициентов единица, то значит Q просто равно
P там и какое-то.
P и первое. Это конечно элемент CONF S.
Конечно точка множества это элемент в оболочке, ну лежит там.
Нет, S это просто множество точек. С это какие-то точки.
CONF S это вот это. То есть вот это вот все это CONF S, а S это просто сами точки.
Итак, база у нас есть, теперь переход.
Переход.
Вот рассматриваем какое-то такое Q.
Давайте оставим все слагаемые кроме последнего и нормируем эту точку. Давайте рассмотрим,
давайте я введу какую-нибудь просто лямбду, как сумму первых
k-1 коэффициентов.
Вот введем такую лямбду.
Дальше введем лямбды штрих. Это исходные лямбды, деленные на лямбду.
Ну и давайте точку Q штрих.
Введем как сумма штрихованных лямбд на те же самые P.
Ну то есть по сути я просто отбросил последнее слагаемое, а первое k-1 так нормировал, чтобы сумма стала единицей.
То есть теперь вот эти вот все лямбдочки, они положительны.
Их сумма равна единице из-за нормировки на лямбду. Для лямбды как раз их сумма.
Ну тогда я знаю, что эта точка лежит в CONVAT-S
по предположению индукции, потому что это выпухлая комбинация камень с одной точки. По предположению индукции это лежит в CONVAT-S.
Ну и теперь остается сказать, что Q
это выпухлая комбинация Q штриха и точки P и K-T. Ну причем видимо с понятными коэффициентами.
Сейчас? Нет.
Плюс лямбда и K, P и K.
weise
Потому что я еще могу написать, что лямбда это 1-лямбда и K.
Потому что это сумма всех кроме последнего. Значит лямбда это вот 1- лямбда и K.
Вот. Поэтому то, что здесь написано, это по сути просто лямбда.
И когда я q-шнхq, это по сути я просто вот в этой сумме отброшу все знаменатели. То есть я по сути просто получу сумму первых камень с одного слагаемого.
Ку штрихом нужно 0.0 лямбда, так а минус 1 первая слагаемая.
Ну и добавляю просто последнюю точку, лямбда и ката, и напа и
ката.
Вот.
Ну, смотрите, тогда что у меня есть.
У меня есть выпуклая комбинация, поскольку это неотрясательное
число суммы 1, выпуклая комбинация двух точек, которые лежат
в конватес.
То есть, на самом деле, q это какая-то точка на отрезке
между двумя точками выпуклой оболочки.
Да, но раз эти точки лежат в выпуклой оболочке, то
и отрезок между ними целиком лежит внутри выпуклой оболочки,
поэтому q тоже лежит в выпуклой оболочке.
Давайте напишу, что q штрих запитая по и ката принадлежат
конватес, следовательно, отрезок между ними тоже
лежит в конватес.
Отрезок между ними тоже вложен в конватес.
ну и значит q как как раз их выпукла комбинация то есть как некая точка на
отрезке тоже лежит в конватес потому что конваты выпуклое множество мы с вами
доказывали да что конв как пересечение выпуклых выпукла значит любой отрезок
между точками внутри конватес тоже внутри конватес лежит
по предпочтению индукции потому что q' является выпуклой комбинацией
камень с одной точке исходного множества
единица из-за нормировки мы как раз ввели лямбду равную сумме коэффициентов
предыдущих поделили их все на лямбду тогда автоматически сумма единицы стала
поэтому q' в конватес ok так в одну сторону доказали
теперь обратно
так обратно почему конвес вложено в множество всех возможных выпуклых
комбинаций
ну мы с вами более-менее представляем как выглядит конватес это какой-то
выпуклый многоугольник вершинами в каких-то точках нашего множества
конватес это выпуклый многоугольник выпуклый многоугольник с вершинами в
точках множество s
но такой выпуклый многоугольник мы можем на самом деле триангулировать
триангулировать мы учились две недели назад ну и более того если это выпуклый
многоугольник то у него с триангуляцией вообще все просто можно просто взять
любую точку провести все диагонали из нее это будет
его можно триангулировать
его можно триангулировать ну и тогда соответственно если я возьму любую
точку из конвес она на самом деле лежит в каком то конкретном
треугольнике да вот например она лежит треугольники 아버е она лежит треугольник
абc значит если я покажу что точкаежащая в
треугольнике получается как выпуклая комбинация его концов его вершин точнее
то мы все докажем, потому что любая точка в конвесс лежит автоматически в некотором треугольнике, потому что мы получили
треангуляцию, а если это является выпуклой комбинацией вершин abc, то можно просто всем остальным точкам сдать коэффициентную нури и получится выпуклая комбинация всех точек схода множества s.
Достаточно доказать,
достаточно доказать, что если
p лежит в треугольнике abc,
то, ну существует, давайте напишем, лямбда 1, лямбда 2, лямбда 3,
такие что, это выпуклая комбинация точек abc с такими коэффициентами.
Ну понятно, на лямбды требования, как обычно, что они не отрицательные, сумма равна единице.
Вот. Ну а это уже
можно доказать следующим образом. Значит, пусть с p какая-то точка внутри многоугольника,
давайте, например, проведем прямую
через c и p.
Ну понятно, что если p там, скажем, с c совпадает, то можно просто сказать, что p равно c, а эти коэффициенты нулевые.
Иначе можно провести прямую, она где-то пересечет прямую ab в какой-то точке q.
Дальше понятно, что q представляется как выпуклая комбинация ab, просто потому что это точка на отрезке.
Ну очевидно, что можно просто взять с нужными коэффициентами ah и b, чтобы получить эту точку.
Ну и дальше надо сказать, что q это выпуклая комбинация a и b, и нам нужно еще взять точку p
на отрезке между q и c. Но если это выпуклая комбинация a и b,
то нужно теперь опять с нужными коэффициентами ее взять, и сказать, что п это выпуклая комбинация q и c.
Но, давайте не буду подробно писать, я просто напишу, q это выпуклая комбинация
и b,
а p это выпуклая комбинация
Q и C. Ну значит, если я просто вот здесь, в этом представлении
Q распишу через A и B, то у меня автоматически получится,
что P это выпуклая комбинация A, B и C. Профит.
Ну вот, зашибись. То есть у нас есть еще какая-то новая классификация того,
что такое выпуклая оболочка. Это все выпуклые комбинации. Довольно полезное понимание.
Так, хорошо. Это нам сейчас будет нужно для еще одной задачки. Задача называется
Ну, определение. Пусть у нас A и B. Давайте не A и B, давайте M1, M2. Это два многоугольника вместе
со внутренностями. То есть это не только граница, но и все, что внутри. Два многоугольника
со внутренностями. Значит, тогда их сумма M1 плюс M2, сумма по Минковскому, это просто-напросто
все возможные суммы точек П плюс Ку, где П из М1, Ку из М2. То есть взял точку из одного, взял
точку из другого, по координатной сложил, то есть по Х, по Y и получил очередную точку из суммы М1
плюс М2. То есть, например, если я беру какой-нибудь квадратик и треугольник, складываю, то у меня в
результате будет вот эта точка, ну там, например, кого-нибудь перенос будет вот здесь вот, дальше
там будет вот это вот все. Ну, короче, не буду рисовать, получится там какая-то фигурка. Вот такая,
что, как бы, если я беру любую точку отсюда, любую точку отсюда, то их сумма просто по координатной,
это какая-то точка вот этого итогового многоугольника. Ну, соответственно, задача по выпуклым M1, M2 найти их
сумму. Найти их сумму Минковского.
Так, ну утверждение, что если М1, М2 это выпуклые многоугольники, то эта сумма тоже выпуклые многоугольники.
Утверждение, если М1, М2 это выпуклые многоугольники, то М1 плюс М2 тоже выпуклые многоугольники.
Причем есть более точно даже классификация, фактиризация точнее, это что М1 плюс М2 это выпуклая
оболочка множества сумм всех пар вершин. Значит, я напишу P1 плюс P2, где Pt это вершина
этого многоугольника, Pt это вершина Mi. То есть я беру вершину первого многоугольника P1, вершину
второго многоугольника P2, складываю их по координатной, ну то есть плюс как обычно у нас там есть оператор
плюс, по координатное сложение, все эти точки свалил в кучу множества и взял по этому множеству выпуклая
оболочку. Тогда утверждаем, что это в точности сумма М1 плюс М2. Значит, если мы вот это докажем,
то мы в частности докажем, что М1 плюс М2 это выпуклый многоугольник, потому что здесь написано
выпуклая оболочка конечно множество точек, а выпуклая оболочка конечно множество точек всегда
выпуклый многоугольник. Вот, поэтому нам достаточно доказать только это правенство. Так, ну чего? Будем
доказывать обе стороны, значит доказываем сразу, доказываем сразу, что М1 плюс М2 равно конв от множества
всех пар вершин. Я вот так кратко напишу, да, что все пары вершин складываю и беру вот эту выпуклую оболочку.
Так, вложение вот такое сначала, или нет, сейчас, извините, одну секунду. Сображу,
что хочу сделать сначала. Наверное, сначала мне надо показать просто выпуклость вот этой штуки,
но сначала докажем, что это вот выпукло. Но сначала докажем, что М1 плюс М2 выпукло.
Так, может вы мне здесь поможете как доказать, что сумма выпуклых выпуклая?
Ну да, давайте я что-нибудь напишу. Что это такое? Это сумма каких-то двух точек,
то есть я взял P из М1, Q из М2, беру точку P плюс Q. Сейчас, нет, нет, нет, не совсем, да, не совсем.
Я взял P1 из М1, Q1 из М2, P2 из М1 и Q2 из М2. У меня есть точка P1 плюс Q1, у меня есть точка P2
плюс Q2, и моя цель доказать, что весь отрезок целиком лежит в М1 плюс М2. То есть я взял
конкретные точки, лежащие здесь. Надо показать, что отрезок между ними тоже целиком лежит в М1
плюс М2 на определении выпуклости, что если я беру любые две точки отсюда, то отрезок между
ними тоже лежит здесь. Вот, ну давайте какую-нибудь точку отсюда возьмем. Что значит, что это точка на
отрезке? Это значит, что она является выпуклой комбинацией вот этих двух точек, то есть любая
точка отрезка характеризуется как некая лямбда на P1 плюс Q1 плюс 1 минус лямбда на P2 плюс Q2,
для не отрицательного лямбда, ну для лямбда от 0 до 1. Мне нужно показать, что вот эта точка
лежит в М1 плюс М2. Ну, я точно знаю, что вот такая точка лежит в М1, и вот такая точка лежит в М2.
Значит их сумма лежит в М1 плюс М2, и победа. Вот это вот верно, следовательно вот это лежит в М1
плюс М2. Просто скобки раскрыли и получили то, что надо.
Вопросы есть? Хорошо, тогда продолжаем. Мы доказали, что эта штука выпуклая. Взяли две
произволенные точки, отрезок между ними целиком там же лежит. Окей, значит теперь надо показать,
что вот здесь равенство. Переходим к равенству, доказываем вот такое вложение слева направо,
что любая точка слева лежит справа. Достаточно показать, что любая сумма вершин лежит в М1 плюс М2.
Достаточно показать, что если P1 это вершина М1, а P2 это вершина М2, то P1 P2 лежит в М1 плюс М2.
Во-первых, это очевидно, что если я беру вершину М1 и вершину М2 и их складываю, то это просто по
определению лежит в сумме М1 плюс М2. Это такие точки, что одна из М1, другая из М2, очевидно,
ну то есть и их суммы. А если мы это доказали, то получается, смотрите, все элементы вот этого
множества, до того как я взял конв, все вот эти суммы лежат в М1 плюс М2. Причем эта штука
выпуклая, то есть эта штука это какая-то выпуклая фигура, содержащая все возможные такие суммы.
Ну значит в частности она содержит их выпуклую оболочку, потому что если выпуклая фигура содержит
все какие-то точки из множества, множество S, пусть это множество S, тогда и выпуклая оболочка
она тоже содержит, потому что выпуклая фигура минимальная выпуклая фигура, их все содержащие,
а это какая-то их содержащая, да, поэтому это содержит конв. Окей, давайте тоже пропишу.
Это само по себе очевидно. Отсюда
М1 плюс М2, некая выпуклая фигура, некая выпуклая фигура, содержащая сумму всех вершин, содержащая
ну все множество P1 плюс P2, а конв это минимальная выпуклая фигура, поэтому конв вложена в М1 плюс М2,
а конв минимальная такая выпуклая фигура. Следовательно конв содержится в М1 плюс М2.
Хорошо? Ну в обратную сторону. А почему М1 плюс М2 вложена в окон вот этого безобразия?
Так, ну пусть есть какая-то конкретная точка P плюс Q лежащая в М1 плюс М2. В М1 плюс М2 я хочу доказать,
что P плюс Q лежит в конв какого-то там безобразия. Смотрите, я сразу написал эту точку в виде суммы
двух точек, одна из М1, другая из М2, ну как бы написал ее разбиение в виде суммы, и дальше я
могу опять-таки триангулировать оба моих многоугольника М1 и М2 и локализовать точки
PQ в каких-то конкретных треугольниках. Сразу могу нарисовать, что P это какая-то точка внутри
некоторого многоугольника A1, A2, A3, и это все у меня происходило внутри М1, то есть есть какой-то
конкретный треугольник с вершинами в вершинах М1, содержащий точку P, но есть какой-то другой
многоугольник с вершинами B1, B2, B3, содержащий Q, и все это происходило в М2. То есть есть некий
треугольник с вершинами в вершинах М2, содержащий Q. Дальше я складываю, по плюску складываю.
Ну и вот в частности смотрите, у меня вот здесь вот в правой части в конв от безобразия точно
лежат все возможные вот эти вот суммы A1 плюс B1, A1 плюс B2, A3 плюс B2 и так далее. Поскольку это
были вершины, а в конв как раз лежат всевозможные суммы вершин, суммы паровершин, то здесь точно
лежат, тут лежат A1 плюс B1 и так далее, A3 плюс B3. Все возможные попарные суммы вершина слева,
вершина справа. Потому что там вообще все пары сумм вершин лежат. Мне надо доказать, что если
я складываю два треугольника A1, A2, A3 и B1, B2, B3, так, нет, не так. Я теперь буду показывать,
достаточно показать, достаточно показать, что P плюс Q лежит в конв от вот этого множества.
Ну потому что вот это, это какое-то подмножество вот этого, ясное дело, то есть я здесь оставил
только 9 каких-то точек из всех возможных там NM точек, я оставил только 9 и если я покажу,
что P плюс Q лежит в их выпуклой оболочке, то понятное дело, но и в большей выпуклой оболочке
тоже лежит. Значит вот осталось показать, что P плюс Q лежит вот в такой вот в этой
выпуклой оболочке. Вот, ну а здесь опять вспоминаем наше утверждение про выпуклую комбинации и мы
можем расписать P как выпуклую комбинацию A1, A2, A3. Я могу написать, что P это выпуклая комбинация
лямбда 1A1, лямбда 2A2, лямбда 3A3, где все лямбды не отрицательные, сумма единица. То же самое с Q.
А поскольку Q лежит внутри треугольника, то она представляется в виде выпуклой комбинации точек
B1, B2, B3 с коэффициентами мю1, мю2, мю3, в каждых которых не отрицательность, сумма равна единице.
А это выпуклая комбинация. Так.
Ну да, а дальше давайте рассмотрим такую сумму. Лямбда 1A1, А1 плюс B1,
лямбда 1 умножить на mu1, дальше лямбда 1 умножить на mu2, а1 плюс b2, плюс лямбда 1 умножить на mu3,
а1 плюс b3, ну плюс и так далее, плюс лямбда 3 умножить на mu3, а3 плюс b3. То есть я вот здесь
вот беру точку аи плюс бж и беру ее с коэффициентом лямбда и умножить на muj. Я рассматриваю такую
штуку, она в точности равна p плюс q, значит еще раз, да, я знаю разложение p и q в выпукловой комбинации
точек а и b, дальше рассматриваю вот такую конкретную выпукловую комбинацию, где вершины, ну как бы
элементы это вершины вот этого множества, элементы этого множества и сумма аи плюс бж берется с коэффициентом
лямбда и умножить на muj. Вот рассматриваю такую конкретную выпукловую комбинацию. Значит, во-первых,
эта сумма в точности равна p плюс q, потому что ну скажем какой коэффициент при аи там, я должен
все это просуммировать по всем ж, да, если я фиксирую аи, то я должен просуммировать это все по всем
ж, у меня будет сумма по muj, сумма по ж muj и получается, что коэффициент при аи как раз будет ровно лямбда и,
потому что если я просуммирую вот эти коэффициенты по всем ж, поскольку у меня сумма muj к этой едице,
то у меня будет коэффициент в точности лямбда и при аи, вот он, то же самое при любом бж, если я
просуммирую все коэффициенты при конкретном бж, то это будет сумма по всем и лямбда и на muj, то есть
просто muj, потому что сумма лямбда единица, значит эта штука в точности по плюс q. С одной стороны, с
другой стороны, это выпуклая комбинация вот этого множества точек, потому что здесь все коэффициенты
очевидно не отрицательные, как произведение отрицательных и сумма у них единица, потому что
это ну и там, я поточечно перемножил два набора суммы единица, можно легко проверить, что сумма,
то есть сумма по и, сумма по ж, лямбда и на muj это единица, значит это выпуклая комбинация. Все,
тем самым мы показали, что p-plus q представляется как выпуклая комбинация вот этих точек, но мы знаем,
что все, что представляется как выблококомминация точек, это в точности элементы выпуклооболочки,
поэтому p-plus-q лежит в конв от этого безобразия. Доказали все. Да, давайте. Вот это, да, все? Ну,
значит, смотрите, нам осталось доказать, что p-plus-q принадлежит какой-то выпуклооболочке a1
плюс b1, a1 плюс b2, короче, все возможные a плюс все возможные b. Но при этом мы знаем,
что p и q это какие-то элементы внутри треугольников. p внутри треугольника a-шек, q внутри
треугольника b-шек. Поэтому точно у них есть некие выпуклые представления вот такие. Дальше
рассматриваем вот такую конкретную сумму, где слагаемое a и plus b-жи взято с коэффициентом
λi умножить на межи. Вот такую сумму по всем i от 1 до 3, по всем g от 1 до 3. Здесь будет 9
слагаемых. Но если мы аккуратно все просуммируем, то мы получим в точности p-plus-q. Почему? Потому
что если я посмотрю на все коэффициенты при a и там, то это будет сумма по всем g лямда и умножить на
межи. А это в точности лямда и, потому что сумма всех межи это единица. Да, значит, коэффициент при
a и это в точности лямда и. Просто я все просуммирую по всем g, у меня получится, что вот эта штука единица
дает. Поэтому коэффициент при a и там ровно такой, какой нужно. Коэффициент при b-жи там тоже такой,
какой нужно, потому что если вы просуммируете вот это по всем i от 1 до 3, то у вас все лямды
сократятся в единицу. Поэтому коэффициент при b-жи будет с точностью межи. Значит, здесь получу
sp-plus-q. С одной стороны. С другой стороны, эта штука это на самом деле выпуклая комбинация вот этих
девяти точек. Потому что здесь все коэффициенты не отрицательны. Все вот эти произведения не
отрицательны, как произведения отрицательных. И более того их сумма единицы, потому что сумма
по всем i, сумма по всем g, лямда и межи это единица. Вот. Ну там, как вы перемножаете поточенно два
набора с суммой 1, получается тоже набор с суммой 1. Итого, мы показали, что sp-plus-q равно некоторой
выпуклой комбинации вот этих девяти точек. А значит, по доказанной теореме она лежит в
выпуклой оболочке. Потому что выпуклая оболочка — это в точности все выпуклые комбинации. Доказали.
Ага. Ну смотрите, что у нас здесь написано. Здесь написано сумма по всем i, сумма по всем g,
лямда i умножить на межи, умножить на аи плюс бж. Да, что такое коэффициент при аи? Ну у нас i тогда
фиксировано получается, а g любой от 1 до 3. Если мы просуммируем по всем g от 1 до 3, то у нас
получится лямда i на сумму межишек. Но мы знаем, что сумма межишек — это единица, потому что это
коэффициент выпуклой комбинации. Так, ну теперь мы доказали, наконец, вот то самое движение,
которое хотели, что сумма — это кон всех возможных сумм вершин. Вершины из одного, вершины из другого.
Так. Ну и теперь мы готовы к тому, чтобы написать алгоритм нахождения суммы Минковского.
Суммы Минковского. Алгоритм такой. Значит, мы поняли, что нам по сути достаточно построить
выпуклооболочку вот такого множества точек. Вершины одного плюс вершины из другого. И по всем
возможным вот таким парам построить выпуклооболочку. Ну смотрите, начало следующее. Вот есть два каких-то
там многоугольника. M1, M2. Начало, наше любимое, мы выбираем точку с минимальным х среди таких
с минимальным y в обоих многоугольниках. Давайте это какой-нибудь не знаю, там p1, p2 напишу. Тогда
понятно, что их сумма — это вершина результатов. p1, p2 — это вершина. Ну потому что, как обычно,
нет точек слева и ниже этих точек. То есть вот здесь ничего нету. И при этом p1, p2 лежит в
сумме Минковского. Ну тогда это обязательно вершина, потому что здесь нет никого левее,
нет никого ниже. Потому что, чтобы получить точку левее, мне нужно, чтобы, по крайней мере,
один из х был меньше. Ну а здесь никого нет, здесь никого нет, поэтому в результате здесь тоже
левее никого не будет. И ниже тоже никого не будет, потому что нужно иметь точку ниже,
чем p1 или p2. Значит, p1, p2 — точка вершины. А дальше мы будем делать следующее. Мы будем
поддерживать опять два указателя. Давайте здесь и здесь g. Строить векторы, совпадающие с очередной
стороной. То есть мы обходим наши оба многоугольника опять, против чего стрелки,
поддерживаем текущую сторону. Вот куда ведет текущая сторона — храним вектор. Из этих двух
векторов выбираем наименее крутой, то есть тот, который меньше всего отклоняется от текущего
направления. Из этих двух я нарисую сначала вот это. То есть, по сути, это как если бы я вращал
калипперы. Вот такие вертикальные калипперы сюда подложил. Дальше начинаю их поворачивать.
Сначала происходит натыкание вот на эту сторону. Значит, я ее сначала рисую. То есть,
я просто беру вот этот вектор, здесь рисую. И теперь этот указатель двигает сюда. Соответственно,
у меня выделяется вот эта сторона. Теперь у меня есть два вектора — этот и этот. Я понимаю,
что из них менее крутой это вот этот. То есть, если я продолжаю вращать наши прямые вот так вот,
то у меня сначала я натыкаюсь на этот горизонтальный вектор. Поэтому я его рисую
следующим. Переключаю здесь на вертикальный. Теперь есть такой вектор и такой. Из них менее
крутой вот этот. Я его рисую. Потом переключаю эту сторону на вот эту. Потом там два вертикальных.
Давайте их как-нибудь одновременно нарисуем вот так. Дальше есть такой вектор, такой вектор. Из
них на менее крутой это вот этот. Я его там нарисую. Ну и так далее. То есть, я просто иду
указателями по обоим многоугольникам и рисую очередную сторону, которая имеет
меньший угол. Ну давайте еще что-нибудь напишем. И это самая левая точка в М1,
G это самая левая точка в М2. Ну и пусть вот здесь у меня, пусть это будут пэшки, это будут кушки.
Значит, тогда я смотрю на очередные вот эти вот векторы. И если кросс,
если векторное произведение P i P i плюс 1 запитаю q j q j плюс 1. Вот здесь у меня,
ну давайте я сделаю так. Больше равно нуля. Тогда я сначала прикладываю вектор P i P i плюс 1.
Тогда прикладываем вектор P i P i плюс 1 и делаем плюс плюс i. А иначе мы, наоборот,
прикладываем вторую сторону и делаем плюс плюс j. Иначе прикладываем q j q j плюс 1 и делаем
плюс плюс j. Ну и все так пока оба многоугольника не обойдем. Значит, очень, ну окей, не очень,
но в общем весьма похожий алгоритм на предыдущий. То есть мы опять идем двумя указателями, только
теперь в нашем случае по двум разным многоугольникам. У нас есть два кандидата, мы выписываем из них,
то есть ну прям кладем, добиваем к текущей точке, кладем в сторону следующую, ту, которая из них
менее-менее крутая, то есть та, которая ближе к текущему направлению вращающейся прямой. Вот было
как-то вот так. Тот, кто наступает раньше, в этом случае вот это, того мы и печатаем и сдвигаемся
указателем на следующий. И так пока все не обойдем. В конце у меня будет там какая-то вот такая вот
фигурка. Мы обязательно замкнемся, ну как минимум потому, что сумма этих векторов 0, поэтому мы рано
или поздно точно попадем туда, откуда начали. Так, ну и теперь осталось понять, почему это корректный алгоритм.
Почему это корректно? Ну скажем так, начало точно корректно, вот эту точку мы точно поставили
правильно, потому что, ну я уже обговорил, да, левее и ниже этой точки никого нет, значит это
гарантированная вершина. Ну вот пусть скажем как-то нам так повезло, что несколько первых сторон мы
поставили правильно. Давайте рассмотрим первое место, когда мы поставили неправильную сторону,
то есть так опять возьму цветные мелки. Давайте рыжие это то, что мы ставим, а зеленое то,
что правильно. Мы вот так вот как-то поставили. Начало было правильным, то есть мы первые
несколько сторон поставили правильно, а дальше пошли неправильно, дальше следующий вектор это
неправильная сторона, вот найдем первую такую неправильную. Ну понятно, что вот такого быть не
могло, потому что если правильная сторона как бы лежит внутри, да, то есть по отношению с той,
которую мы поставили, лежит как бы более внутри, то значит мы как будто нарисовали какие-то точки,
которые на самом деле не лежат в сумме Минковского. Но такого точно быть не могло, потому что мы
рисуем только правильные точки. То, что мы рисуем, гарантированно вложено в сумму Минковского,
потому что то, что мы рисуем, это всегда суммы каких-то вершин. То, что я нарисовал, да, вот граница,
граница это всегда сумма вершин каких-то, потому что, ну то есть как вот это получено, это получено,
как там, ну сумма каких-то точек. Дальше я к этой точке прикладываю еще некий другой вектор,
ну сторону по сути прикладываю, то есть у меня была точка, я к ней прикладываю еще какую-то
сторону. Понятно, что это точно лежит в буквы оболочки, поэтому такого быть не может, такого быть не
может, так как строимый многоугольник точно вложен в сумму Минковского, точно вложен в М1 плюс М2.
То, что мы получаем, всегда это какие-то, ну реально, точки, являющиеся суммами каких-то
точек исходных многоугольников, поэтому лишнего мы ничего построить не могли. Ну теперь, наоборот,
в случае, что мы чего-то не добрали, то есть поначалу у нас было правильное, а дальше в продолжении
какое-то вот такое, то есть мы берем что-то, то есть мы чего-то не берем, мы чего-то не берем,
мы чего-то не берем, что должны были. Ну давайте соображать, значит, вот эта точка это какой-то
П плюс Ку, давайте я их нарисую, П вот Ку, это соответственно было в М1, это было в М2,
1 это было в М2, вот, значит, следующая сторона, которую я взял, это один из этих двух векторов,
мой алгоритм так работает, что если у меня вот этот П плюс Ку, то дальше я смотрю на этих, на эти два
вектора, исходящие из них, беру тот из них, который, ну, менее крутой, то есть более всего наклонен,
вот, и его рисую, то есть, по сути, вот этот оранжевый совпадает вот с этим, а этот завернут по часовой
стоилке по сравнению с тем, который я взял, потому что кросс между ними там какой-то определенки,
вот, хорошо, ну, давайте тогда докажем на самом деле, что локально, значит, у меня весь
наугольник, на самом деле, должен длиться вот здесь вот, то есть, в этом угле, и никак выходить из этого угла он не может.
Так, ну, давайте я скажу, что это пусть какая точка Р1 плюс Р2, там х плюс у, тут х, тут у, то есть,
понятно проблема, что я взял как бы экстремальное продолжение, вот это вот рыженькое, а мне говорят,
что есть какое-то еще более экстремальное, которое откуда-то взялось, ну, откуда-то из космоса, ну,
пусть вот это х плюс у, у, то есть, получается, что, смотрите, у меня вот это вот, это вот,
это оранжевый вектор, а здесь я как бы мог приложить вместо того, чтобы, значит, вместо вот этого оранжевого
вектора я мог взять вот такой вектор и вот такой, и приложить их вот сюда, их сумма получилась бы вот
этот зеленый вектор, вот, но такого быть не может, потому что, смотрите, я могу написать следующее,
так, нужно кинуть еще буквы, пусть это будет п штрих, будет ку штрих, нет, давайте просто я назову
рыжий вектор, вектором у, вот это у, значит, тогда, поскольку х лежит внутри выпуклом
многоугольника, ну или на границе, то я точно могу написать, что векторное произвление пх на у у меня
получается неположительно, потому что здесь вращение по часовой стрелке, да, это, значит,
какая-то, ну, следующая сторона, х какая-то внутренняя точка, вращение от внутренней точки до
следующей стороны у нас идет по часовой стрелке, поэтому здесь значок не больше нуля, более того,
я могу написать то же самое для вектора ку у и вектора у, потому что если бы я нарисовал вектор
вот этот вот оранжевый со стартом в ку, то он был бы еще более крутой, чем сторона многоугольника,
а значит направление поворота опять-таки у меня идет по часовой стрелке, поэтому здесь у меня
вектор напряжения опять неположительный, вот, ну и дальше, дальше, потому что у меня вектор
напряжения линейно, я могу написать, что пх плюс ку у на у неположительно, а значит, на самом деле,
вот этот вот поворот от п плюс ку до х плюс у до вектора у, он идет у нас в направлении по
часовой стрелке, поэтому зеленая стрелочка от п плюс ку до х плюс у не может торчать правее,
чем вектор у, а значит, у меня обязательно, если есть вектор между п плюс ку и х плюс у, то он
находится как бы левее, чем у, потому что вот здесь направление поворота по часовой, ну все,
а значит, он не может вытарчиваться куда-то справа, потому что здесь, наоборот, у меня поворот
по часовой, вот здесь против, то есть по неравенству он может быть по часовой, а здесь, по картинке,
против, значит, такого не бывает, противоречие. Ну как-то так.
Значит, напоследок скажу, зачем это может быть нужно, зачем нужно искать сумму Минковского,
значит, задача один, это проверить, пересекаются ли два многоугольника, проверить, пересекаются ли
два многоугольника. Значит, это решается просто, если есть два многоугольника М и М2, то можем
построить их разность Минковского, то есть, по сути, сумму с отзеркалином относительно нуля вторым,
и проверить, лежит ли там ноль, там лежит ноль, если и только если есть одинаковые точки в М1 и М2,
так, сейчас, один момент.
Да, ну и здесь же, можно научиться находить расстояние между двумя выпуклыми многоугольниками,
расстояние между выпуклыми М1 и М2, ну здесь можно опять построить разность Минковского этих
многоугольников и найти точку, ну что такое расстояние здесь, это как раз эвклидова норма
какой-то точки отсюда, значит, нужно просто в этом многоугольнике найти точку с минимальной
эвкидовой нормой, то есть, ближайшую к нулю просто, здесь ноль, вот есть наш страшный многоугольник равный
разности М1-М2, надо найти ближайшую к нулю точку этого многоугольника, найти ближайшую к нулю
точку М1-М2, но это уже гораздо более простая задача, вот, всего, спасибо.
