Итак, всем еще раз здрасте. Сегодня 12-я лекция и 25-е число. Значит, мы в прошлый раз
обсудили AV-дерево. Сегодня мы продолжаем наше изыскание по деревьям поиска, и сегодня
будут еще два из них. Я надеюсь, оба успеем. Будет у нас SP-дерево и B-дерево.
Итак, мы начнем со SP-дерево. И повторюсь, что мы находимся все в одной и той же парадигме,
когда нам нужно разработать какую-то структуру данных, которая, напомню, умеет поддерживать
некоторое множество S. Давайте считаем, что чисел. В общем случае, это просто произвольное множество
каких-то ключей, которые мы можем сравнивать между собой. И нам нужно уметь обрабатывать
операции insert, erase и find. Find – это операция запрос проверки, входит ли данное число в ваше множество S.
Соответственно, вы над ним как-то изгаляетесь, делаете разные запросы к нему, изменения датам,
insert и erase. И вот иногда поступают запросы find, найти, есть ли данный элемент в множестве.
Ну хорошо, что такое будет SP-дерево? SP-дерево – это просто еще одна реализация того же, что у
нас было в прошлый раз. В прошлый раз мы рассмотрели AV-дерево. Это какой-то из подходов к тому,
чтобы отвечать на все эти запросы эффективно. Мы хранили какое-то дерево, дерево поиска,
с каким-то там вариантом, что глубина лево и глубина права, точнее, глубина лево и глубина
права, слижается максимально на единичку. SP-дерево – это тоже будет дерево поиска, двоичное.
SP-дерево – это тоже двоичное дерево поиска. Но в явном виде у него нет никакого инварианта.
Нет варианта в стиле того, что было у AV-дерево. Единственное, что мы будем делать – это следующее,
что если какой-то элемент X потрогался, группа игроков, мы вызвали find от X и нашли элемент X в
нашем деле, то перед тем, как обрабатывать следующий запрос, мы этот X поднимем в корень. То есть после,
скажем, find от X, если мы его нашли, мы вызовем процедуру, которая называется splay от X. И смысл
такой, что она X поднимает в корень. Ну вот помним с прошлого раза, что у нас в AV-L просто куча всяких
вращений. Там этого сделать, то есть если у нас там был вершинка A, то у нас был такой поворот,
который делал наоборот, вершинку B делал предком вершинки A. Ну и там как-то переподвешивался ледерей.
То же самое будет здесь, деревья много всяких поворотов, много всяких вращений, рёбер относительно
друг друга. И мы хотим сделать вот этот элемент X, который мы только что потрогали, который мы
только что нашли, самым верхним, поместить его в корень. Вот это может быть полезно, например,
когда вы работаете с каким-нибудь базой данных, к которой запросы поступают, скажем так, неравномерно.
Например, у вас есть какой-нибудь сайт, на который заходят пользователи, и понятно,
что пользователи можно как-то праранжировать по посещаемости сайта. Чем чаще он посещает сайт,
тем, наверное, быстрее хотелось бы отвечать на все его запросы. Тем быстрее нужно выдавать ему любую
информацию, которую он попросит. И поэтому хотелось бы пользователей, которые часто пользуются вашим
сайтом, хранить в вашем дереве где-то ближе к корню. Потому что время ответа на запрос для каждого
человека — это глубина вот этого элемента X, который ему соответствует. То есть если он там ищет
какую-то информацию, которая хранится у него в аккаунте, вам нужно найти его в своем дереве и
выдать, соответственно, всю информацию, которая ему соответствует. Логин, пароль, дату рождения,
которую он вдруг почему-то забыл, ну и так далее. И, соответственно, чем глубже эта вершина, тем
дольше вы будете работать. И, наоборот, чем выше эта вершина, чем ближе она к корню, тем быстрее вы
будете работать. Поэтому оптимально было бы частых пользователей хранить ближе к корню. Ну и, собственно,
ровно это в сплей дерева и происходит. Вы того пользователя, который только что сделал запрос,
он спросил какие-то данные про себя, что он там когда-то записал на ваш сайт, но забыл про себя.
Вот он говорит, покажи мне, пожалуйста, мою страничку, я там вспомню, что мне там написано.
Значит, он смотрит, открывает, и, соответственно, в дереве поиска, которое неявно хранится внутри
вашего сайта, этот элемент поднимается в корню. И потом, скажем, если этот пользователь еще много
раз идет на ваш сайт, прямо вот сразу, без других запросов, просто он же заходит на сайт
вопросы, то вы сможете отвечать на его запросы за от единицы, потому что он и так в корне, и вам
не нужно никуда спускаться. Это очень удобно, очень быстро. Вот. Потом, когда приходит какой-нибудь
второй пользователь, он его поднимает в корню, соответственно, от того старого куда-то опускает.
Но все равно он не может его опустить слишком сильно. Если у вас какие-то пользователи частые,
то они всегда будут довольно близко к корню. Ну это вот такое неформальное описание того, зачем нам
это нужно. Вот. Ну а сплей — это по-английски так типа... Все эти названия довольно условные.
Сплей — это типа раздвинуть. Сплей Apart — это что-то в стиле расширить какие-то элементы между
собой. И сплей не то, что происходит расширение, но можно считать, что если у нас там было какое-то
дерево с корнем в X, мы X вытаскиваем, насильно берем и поднимаем в корень, и, соответственно,
все остальное раздвигается как левый и правый сын. Ну вот так можно понимать, почему здесь такое
название сплой. И так. Это просто дерево поиска, который последний элемент, который был в запрос,
поднимает в корень перед тем, как перейти к следующему запросу. Вот. Значит, для этого,
для сплея нам нужно будет четыре операции. Четыре операции поворота. Значит, они очень странно
называются. Первый называется зиг. Это поворот, просто на самом деле маленький поворот вправо.
Значит, если есть какая-то вишенка X, и у нее есть родитель P, который является корнем дерева,
значит, если P корень, рассмотрим вот, ну пусть X является левым сыном корня. Тогда вот этот
поворот направо работает так. Вот представьте, что у вас это ребро между X и P является как бы
шарнижчиком, и вы его двигаете так, что X становится теперь верхней вишенкой, а P нижней. То есть
у вас теперь X вверху, а P внизу справа. Вот. Остальные вот эти вот A, B, C как-то переподвешиваются,
ну C остается справа здесь, A остается слева здесь, а B, ну она, к сожалению, ей приходится
переподвешиваться к P. Так же, как у нас было в ВВД дереве, она не может остаться ребенком X,
потому что иначе у X будет три ребенка. Поэтому мы B сюда переподвешиваем. Это вот так называемый,
на самом деле, просто правый малый поворот. Правый малый поворот. Маленький правый поворот.
Вот смысл такой, что мы X-X как бы вытащили чуть повыше, и если он был сыном корня,
то теперь X стал корнем. Если он был сыном корня, то теперь после одного такого поворота он стал сам
по себе корнем. Вот. Ну соответственно, то же самое, если X это правый сын корня, нам нужно делать
левый поворот. Ну, в общем, картинка симметрична, я ее даже рисовать не буду. Хорошо. Ну и понятно,
да, мы тоже это, когда рисовали все правое дерево, мы поняли, что все такие повороты, они сохраняют нам
инвариант дерева. Что левее, ну вот скажем, посмотрим на этот X. Здесь в левом по дереве все
элементы меньше, чем X, в правом должны быть все больше, чем X. Что здесь, да, выполняется легнее
равенство здесь. Ну здесь у меня по-прежнему находятся элементы, все элементы из A меньше,
чем X, потому что они были такими раньше. Вот. А что происходит с B? Здесь должны быть элементы больше
X, но меньше B, да, потому что B находится в правом по дереве X, но в левом по дереве P. Ну, собственно,
оно так было изначально и раньше, оно было в правом по дереве X, а в левом по дереве P. Поэтому никакое
неравенство не нарушится. В общем, все неравенства, которые должны быть в дереве поиска, они выполняются
при таком маленьком повороте. Вот это операция ZIG, которая сына корня делает корнем. Хорошо. Теперь
предполагаем, что вершина не является сыном корня, а у нее есть дедушка, то есть она сама не корень,
родители не корень, значит есть дедушка. Тогда возникают два случая. Так, я как-нибудь вот так
постараюсь их уместить. Значит, первый случай это ZIG-ZIG, когда X и родители X находятся от своего
родителя по одну сторону. Ну, например, может быть такое, что X является левым сыном своего отца P,
и P является левым сыном своего отца ZIG. Это parent, это grandparent. Тогда поворот работает так,
A, B, C, D. Вот эти под деревья у нас есть. Поворот работает так, что мы сначала делаем маленький
поворот направо вот здесь, потом маленький поворот направо вот здесь. И получается у нас такой
результат. Я сразу нарисую, какая будет картинка в конце. Ну, то есть можно для практики честно
сделать сначала первый поворот, собственно, по правилам, которые были нарисованы выше,
потом сделать такой второй поворот и понять, что получится ровно такая картинка, как я сейчас
нарисую. B, G, C, D. Вот получается такое преобразование. Ну и, собственно, идея та же. У нас был какой-то
X, и мы с помощью каких-то двух поворотов сделали X корнем вот этого под деревом. То есть там,
возможно, есть еще какое-то продолжение наверх, какой-то путь наверх. Но главное, что мы глубину
X как бы уменьшим. Мы его подняли на вершинке вверх. И то же самое, поскольку каждый отдельный
поворот, первый и второй, каждый из них отдельно сохраняет инвариант дерева, дерево поиска, что
слева все меньше, справа все больше, то, собственно, и это будет тоже корректное преобразование. Это
можно называть... Так, ну я не буду говорить, что это... Короче, это большой правый поворот, когда у нас
сначала сверху направо, потом снизу направо. Вот это зиг-зиг. И, наконец, зиг-заг. Когда у меня
X и родитель XA находятся по разные стороны от своих родителей. То есть, например, вот есть X. Он,
скажем, является правым сыном своего родителя, но родитель является левым сыном своего родителя,
налевым сыном G. Так, давайте я немножко сдвину, чтобы у меня поместилось все на одном слайде.
Так, X, P, G. Ну и тогда здесь есть какие-то поддеревья, A, B, C, D. Тогда зиг-зиг работает так.
Мне сейчас, блин, сейчас, на секундочку.
Да, мне кажется, что нужно сначала сделать вот этот поворот, потом вот этот поворот. Вот, и тогда
у нас результат будет такой. Значит, X вылезет в корень, слева будет P с поддеревьями AB, справа
будет G с поддеревьями CD. То есть, опять, мы как-то здесь переподвешиваем все вот эти вот ссылочки,
так переназначаем всех детей у вершинок X, P и G, чтобы получился вот такое дерево, чтобы получился
вот такое новое дерево. Ну и можно, как всегда, проверить, что в январе или в январе дерево
сохраняется. Так, наверное, дерево сохраняется, что слева от любой вершинки лежат только меньшие
числа, а справа только больше. Вот, таких трех операций нам будет достаточно, чтобы любую вершинку
поднять в корень. Значит, как будет работать процедура сплой? Она вызывает по очереди зиг-зиг или
зиг-заг в зависимости от того, по одну ли сторону лежат X и его родители от своих родителей. То есть,
если X и родитель X лежат, скажем, оба по левую сторону от родителей, то есть X это левый сын P,
а P это левый сын G, тогда вызываем зиг-заг. То же самое, если у меня, например, X это правый сын P,
а P это правый сын G, то есть, если оба перехода идут направо, то тоже происходит зиг-зиг. Там все
то же самое, только зеркально нужно отразить, вот эту картинку нужно симметрично отразить,
чтобы получить поворот, когда у меня оба, куска направо. Вот, а если у меня, наоборот,
скажем, X это правый сын P, а P это правый сын G, тогда нужен зиг-заг, ну и наоборот, если
у меня x это левый сын p, а p это правый сын g, тогда тоже зигзаг. То есть вот для каждого из четырех
возможных случаев, как у меня происходит подъем к родителю x и как происходит подъем к родителю
p, в каждом из четырех случаев не нужно применить либо зигзаг, либо зигзаг. Ну если, соответственно,
сплей от данной вершинки делает следующее. Он смотрит на текущую глубину вершины, если она
хотя бы два, то есть есть и родитель, и дедушка, тогда он применяет либо зигзаг, либо зигзаг,
в зависимости от того, какие там идут повороты. То есть если нужно подниматься влево и влево,
или вправо и вправо, тогда он делает зигзаг. Если влево-вправо или вправо-влево, то нужно
зигзаг. Тем самым мы как бы уменьшили глубину x на два, мы его подняли на две вершины вверх.
И так поднимаем-поднимаем, пока либо x не окажется в корне, либо x не станет сыном корня. Ну а если
он является сыном корня, то мы просто делаем одну операцию и зиг, и x становится корнем. То есть
сплей от x, давайте напишем, что это несколько раз зиг-зиг и зиг-заг, несколько раз зиг-зиг и
зиг-заг, и потом, ну как это написать, какого-то количества раз, и потом максимум один раз зиг,
один раз. Вот так работает сплей. Хорошо. Зачем вот нам эти двойные, почему нельзя просто какие-то
там зиги-заги делать? Ну с ними ничего не сойдется, там не сойдется асимплатика. Мы докажем чуть позже,
что вот при таких сплоях, да, возможно странных, неестественных, асимплатика будет амортизированный
логарифм на запрос. Если бы мы делали просто зиги или просто заги, да, ну то есть вот подъем
просто в родителя, то там, к сожалению, была бы хуже асимплатика, мы бы не смогли доказать.
У нас же зиг-зиг расписывается как два зига, а зиг-заг как один зиг и один заг. Вот прям можно
даже выразить через них. Вы правы? Сейчас, одну секунду тогда. А нет, смотрите, здесь важен порядок,
потому что если бы мы просто, вот смотрите, вот в случае зиг-зиг у меня поворот происходит сначала
от отца к дедушке, а потом поворот от меня к отцу, да, то есть вот один-два. То есть тут важно
получается в каком порядке применять эти зиги. Да, все равно как бы у меня любой маленький, как бы
что зиг-зиг, что зиг-заг, он складывается из там двух маленьких поворотов, но важно в каком
порядке их применять. Вот, и если не определять зиг-зиг и зиг-заг, то ничего не получится. То есть
ну тут важен порядок у них. Понятно? То есть это такой чистый уровень абстракции, чтобы мы потом не думали о порядке?
Так, фразу уровень абстракции я не понимаю. То есть мы создаем вот зиг-зиги и зиг-заг только
для того, чтобы создать уровень абстракции над зигом и загом, чтобы потом использовать уже зиг-зиги
и зиг-заг, не задумываясь о том, в каком порядке внутри применяются зиги и заги. Так что ли?
Можно сказать, что так, да. Но уровень абстракции мне не нравятся фразы, потому что это ну как бы можно
считать, что они не связаны. То есть можно не думать о том, что они как-то завязаны на зиг и заг. Это
просто какие-то отдельные процедуры, которые вот поднимают х на два уровня вверх. И при этом мы
можем, не потеряя симптомики, выразить их через зиги и заги. Так ведь? Можем, но это для нас не
существенно. Ладно. Ну можем, да. Вот, значит, теперь давайте поймем, как использовать этот сплей,
который поднимает данную вершинку х в корень с помощью этих странных операций. Можно реализовать,
так вопрос в чате. Почему обязательно зиг делаем в конце? Если предпоследний корень был дедушкой,
разве последний зиг нужен? Нет-нет, я сказал, я не написал здесь. Хорошо, давайте подпишем,
что не больше чем один раз, если х стал корнем после зиг-зигов и зиг-загов, то, возможно,
зиг не нужен. То есть если мы уже корень, то, конечно, последний зиг не нужен. То есть он не
больше чем один раз применяется. Итак, как мы делаем insert в нашем сплей дереве? Insert х. Ну,
сначала мы вставляем х так же, как в наивном дереве. Вставляем х так же, как в наивном дереве
поиска. В наивном дереве поиска. То есть мы просто спускаемся в поисках х, пытаемся, ну,
когда-то пытаемся пойти в неисуществующую вершинку и там искать х, ну, тогда вот на место
неисуществующей вершинки подвешиваем х. А дальше в конце вызовем сплей от х. То есть вот давайте
нарисую. Мы как-нибудь там шли-шли-шли искали, дошли до вершинки, куда нужно подвесить х и сюда его
подвешиваем. А дальше вызываем сплей и поднимаем его в корень. То есть там какие-то зиги, зиг-зиги
и так далее, подъемы. Так что теперь х становится корнем. И что нам очень важно в этом случае,
это что время работы инсерта, оно ограничено сверху времени работы сплея. Ну, потому что если
инсерт работает, мы знаем, что инсерт работает за глубину, собственно, которую мы опустились,
то есть мы просто прошли сверху вниз. Да, если глубина этого пути, длина этого пути равна
времени работы инсерта. Просто сколько раз нам нужно пойти вниз. А дальше мы делаем сплей,
который как-то поочередно этот х поднимает вверх, с помощью каких-то поворотов. Ну, понятно тогда,
что время работы сплея, оно тоже пропорционально глубине, собственно, этого пути, просто длине
этого пути. А значит, можно, если мы после каждого инсерта будем вызывать сплей, можно в суммарной
асимптотике, поскольку мы все равно работаем в терминах О большого и мультиприкритинные
константы мы обрасываем, можно считать, что инсерты не вносят вклад, потому что у нас есть
все равно сплей, потому что каждая вставка сопровождается непосредственно вставкой в дерево,
а потом сплеем этой вершинки, вытаскиваем ее вверх. Поэтому если суммарно сложить все
временные работы всех этих процедур, то это максимум в два раза хуже, в два раза больше,
чем просто сумма временной работы сплайов. Потому что каждая операция, вот этот инсерт,
соответствует ограниченно сверху своим сплаймам. Поэтому суммарное время работы мы будем
измерить в количествах шагов, которые сделал сплей, а не сделали инсерт или рейс. С инсертом
разобрались, мы ограничим время работы инсерта, время работы сплая. Что делать с рейсом? Рейс х.
На самом деле здесь будет удаление тоже точно такое же, как в наивном дереве поиска. Удаляем
удаляем х так же, как в наивном дереве поиска. Как это работает, напоминаю, вот есть какое-то
дерево, скажем, и мы нашли в нем х, нашли х. Если у х нет левого или правого сына, тогда мы просто
имеющегося сына подвешиваем на место х, и на этом заканчиваем. Если у х есть и левый и
правый сын, давайте, скажем, спустимся в правого сына, найдем в нем минимальный элемент у. У
запишем на место х, а правого сына у запишем на место у. Это мы обсуждали тоже в прошлый раз,
про наивное дерево поиска. Давайте повторю. Если есть какой-то элемент х, вот мы нашли его в
дереве, элемент х, и у него есть оба сына, левый и правый. Тогда давайте спустимся в правого сына,
вот это вот р, спустились в правого сына. Затем в правом поддерега, в этом правом сыне, найдем
самый минимальный элемент, просто спусками влево, идем влево-влево-влево, пока есть левый сын.
Дошли до кого-то у без левого сына. Теперь просто берем у и копируем на место х. Х удаляем,
пишем на его место у, а вместо у подвешиваем его правого сына. Если здесь был какой-то z,
то мы z подвешиваем на место у. Ровно так же, как у нас было в наивном дереве поиска.
Вот, мы сделали это, и в конце мы запустили сплей от z. И тогда работает то же самое. Время
работы ирейза ограничено сверху временем того, чтобы нам поднять этот z в корень. Потому что,
что такое время работы ирейза? Мы спустились до х, потом спустились до у и еще взяли z. Ну то есть,
мы просто по сути спустились вниз как-то по дереву, что-то там переподвесили. z у перекопировано
на место х, z на место у. Но тогда теперь, если я запущу сплей от z, то время работы как раз будет
ну такое же. Мы просто поднимаемся обратно по этому пути и что-то там переподвешиваем. Поэтому вновь
время работы ирейза ограничено временем работы сплея. И поэтому в общей сумме, когда мы говорим
в тернах о большого, можно считать, что слагаемый соответствующий ирейза просто отсутствует. Есть
только сплей. Есть только операции сплей. Так, ну и последнее, про что я уже неявно говорил,
то что если есть операция find х, то мы сначала находим, если х в дереве, находим, а потом запускаем
сплей от х. Нашли его в дереве, запустили сплей и сделали его корнем. То же самое, время спуска
оценивается сверху временем работы операции сплей. Поэтому в итоге все операции, они оцениваются
сверху сплаями. И давайте мы просто вместо всех операций анализируем только сплей. Так, вопрос
тщательный. Кого мы поднимаем при удалении? Можно еще раз, пожалуйста. Давайте я нарисую картинку
побольше на следующем слайде. Надеюсь, они поймают. Значит, вот есть большое дерево поиска. Сначала
мы находим где-то в нем х. Тот элемент, который нужно удалить. Race х, запрос. Здесь есть два
случая. А, при помощи сплей. Все окей. Сплей от z. Нет, все-таки мне нужна будет картинка. Давайте еще
раз. Если у х есть оба сына, то я спускаюсь в правого сына, затем нахожу в нем минимального
потомка y. У него может быть правый сын z. И что тогда я делаю? Я y перемещаю на место х, z
переподвешено на место y и запускаю сплей от z. То есть правило очень простое. Самая глубокая
потроганная вершинка должна переместиться в корень. Раз у нас время работы рейса пропорционально длине
вот этого пути, то теперь мне достаточно будет вызвать сплей от этой вершинки, которая поднялась
сюда. И тогда время работы сплея тоже будет примерно такое же. Но в терминах тетты большой
будет пропорционально просто в длине пути. Соответственно, рейс ограничивает сверху сплею.
А у нас z может быть не листом? z может быть не листом, да. Ну, тогда мы просто все вот это
под дерево переподвешиваем сюда. То есть просто говорим, что теперь левым сыном вот этого старой
вершинки p является z. То есть там нужно будет просто перенаправить одну стрелку, забыть про y,
и все уже хорошо. А зачем, когда мы удаляем делать сплей? Это для симптотики тоже или вообще зачем?
Ну да, для симптотики, потому что иначе мы никак не сможем оценить время работы рейсов. То есть если
мы ничего не будем делать и просто удалять, как на ином дереве поиска, то... Ну собственно, а тоже вопрос,
а зачем в инсерте делать сплей? У нас же получается мы только замедляем для того,
чтобы было удобнее считать симптотику. Давайте вставим сортируем пузырьком,
тогда вообще легко будет. Сейчас, но мы не то, что замедляем. Нет, но когда мы вставляем,
то понятно, что логично добавился какой-то новый пользователь, мы его сразу наверх докидываем.
Примеряем, но когда мы удаляем, то мы какого-то левого непонятно подняли на самый верх. Да, именно так.
Ну окей, если бы мы так не делали, то не просто было бы тяжело проводить анализ, а это было бы
невозможно, потому что время работы операции рейс мы бы вообще ничем не смогли оценить.
А если мы, допустим, говорим, что операция рейс состоит из некоторого действия по удалению и
операции сплей, причем сплей явно не меньше, чем действие удаления. И мы говорим, что симптотика
сплея равна симптотике удаления. Да, так можно сделать. Тогда мы говорим, что если мы удалим
сплей из операции рейс, то асимптотика не уменьшится, то есть О от сплей получится. Здесь
будет труднее вычислить тету, но вот О от сплей вполне нормально. Секунду. То есть не больше,
чем сплей. И все-таки мне кажется, где-то обман в вашем рассуждении, потому что если, скажем,
рейopen.ru и вы их все по отдельности удалите и не вызовите ни раз сплей, то ну типа нельзя
сказать, что время работы рейс меньше, чем время сплей, потому что сплея у вас вообще нет.
Но если вы доказали, что время работы этого рейса меньшеineshmm,
чем время работы сплей, то... Мы же не делим сплей, если мы не запускаем сплей,
то у нас не понятно с чем мы сравним. Если мы не запускаем сплей, то не понятно, что мы делаем.
Короче, смотрите, давайте мы не будем пытаться переизобретать дерево, в общем, есть такой алгоритм,
он работает, мы сейчас обратно все докажем, почему все сходится. Если делать не так,
то соответственно не сойдется, или там просто в каком-то месте будет дырка, и время рейза не
получится о чем-нибудь оценить. Итак, значит, что мы сказали? Мы сказали, что время работы каждой
операции, ну, t-operation, да, любое, любой операции ограничивается сверху времени работы сплея,
поэтому давайте вместо того, чтобы считать суммарно время работы всех оперiferации,
будем считать суммарно время работы всех сплеёв. И я утверждаю, что время работы,
амортизированное время работы каждого сплея это алгоритм, а ozvylezhashka, напоминаю,
что это у нас обозначает амортизированную сложность. То есть, если, скажем, вы делаете
к изначально пустому сплэй-дереву к запросов, то суммарно можно считать,
неважно каких, да, там insert, erase или find, то суммарно вы на все запросы отвечаете за от колока.
Так, ну Дмитрий задает тот же вопрос, оно...
Да, оно влияет на асимптотику, да, оно влияет на асимптотику, потому что если так не делать, то время работы может вырыться в квадрат.
Да, кстати, вот это правильный вопрос, то есть, если мы не будем делать сплэй, то вы можете сам придумать пример,
когда время работы вырождается в линейное на запрос. Да, это важное замечание, надо было его сказать, да, спасибо за уточнение.
Итак, вот докажем сейчас, что суммарно все будет работать за лоберифом амортизирования.
Мы воспользуемся методом потенциалов, который мы когда-то рассматривали, метод потенциалов.
Значит, давайте скажем, что пусть s от x это количество вершин в подделье x, количество вершин.
Так, давайте я перейду на следующий слайд, у меня не хватает здесь места.
Пусть s от x, количество вершин в подделье x, ну мы считаем, что x лежит в своем подделье, x тоже входит в подделье.
Дальше, скажем, что r от x это двоичный логарифм этого s от x, ну и поскольку s от x это хотя бы единица, раз x самоходит в своем подделье,
значит, это чтобы всегда не отписать. И когда наконец потенциалом нашего сплэй-дерева мы объявим сумму всех этих вот r, сумму всех рангов по всем вершинам.
Сумму по всем x из множества вершин r от x. Это потенциал с плэй-деревом, с плэй-деревом.
Вот, и наша задача теперь с этим потенциалом понять, что амортизировано каждый сплэй работает за отлогарифмом, за отлогарифм,
значит, напоминаю, как мы рассуждаем, когда работаем с потенциалом. Мы ввели какой-то потенциал. Дальше, пусть t и t это реальное время обработки этого запроса,
реальное время обработки этого запроса. Ну а там phi, скажем, с производительным индексом phi жита, это потенциал после житого запроса.
После житого запроса. Тогда мы определяем i и t, как раз-таки вот эту учетную амортизационную сложность, амортизационную стоимость, как t и t,
плюс phi после этого запроса, минус то, что было до него, минус phi, минус 1. То есть это сколько реального времени мы потратили,
плюс изменение потенциала delta phi в момент времени i. Насколько потенциал изменился при выполнении этого запроса.
И вот эта ашка, если мы докажем, что эта ашка оценится сверху от логарифма, оценивается сверху константа у нашего логарифма,
тогда получится как раз-таки то, что нужно. Амортизационная сложность будет у нас логарифмической.
Амортизационная сложность логарифмической. Ну что, давайте этим займемся.
Докажем, докажем, что амортизационное время работы операции splay от x не больше чем 1 плюс 3 r' от x минус r' от x,
где r это старый ранг вершинки x до запроса, а r' это новый ранг вершинки x, то есть после splay.
Давайте подпишем это до splay, до выполнения процедуры splay, это после splay, это после splay.
Вот, значит, это мы докажем чуть-чуть позже, но давайте сразу заметим, что если мы это докажем, то отсюда немедленно следует,
что эта штука оценится сверху единицей плюс 3 log2n.
Значит, вот почему. Что такое r' от x? Ну, вспоминаем, что splay от x поднимает данную вершинку x всегда в корень дерева,
всегда вершинку x поднимает в корень, но тогда r' от x это двоихистный логарифм от числа вершин в подделе, ну, в новом подделе x.
Ну теперь, раз x это корень, то просто r' это логарифм от n, все вершинки лежат в этом подделе, все вершинки лежат в подделе x.
Ну а здесь идет там какой-то минус r' от x, минус какое-то недооцентное число, поэтому здесь будет оценка сверху.
Здесь будет оценка сверху. Ну и как раз это и означает, что амортизационное время работы каждой операции каждого splay'а
оценивается сверху от логарифма, от log2n. Значит, если мы докажем вот это вот неравенство, вот это вот красненькое,
тогда мы победим. Отсюда будет следует, что амортизационно мы работаем за логарифм на запрос.
У нас же потенциал всего дерева это сумма по всем вершинкам.
Вот, у нас потенциал изменился не только у вершины x, а еще у той, с которой мы ее поменяли.
Типа там же мы много вершин мы поменяли, разве нет?
Да, конечно, но смотрите, вот если это утверждение будет верно, то мы победили. Вы с этим согласны? Или нет?
А, то есть мы еще не доказали?
Мы доказали, докажем.
Так, дальше не услышал, три.
А, все, все, хорошо, если докажем, то хорошо.
Да, да, если мы докажем, то мы победим. Сейчас будем доказывать.
Там непростое доказательство, это там на несколько слайдов точно будет.
Вот, ну хорошо, мы помним с вами, что splay' это последовательность всяких сложных операций.
Зиг-зиг, зиг-заг и зиг.
Давайте тогда все их аккуратно проанализируем и поймем учетное вот это амортизированное время работы каждой из них.
Значит, начнем с a вот зиг.
Амортизационное время работы, процедура зиг.
Ну хорошо, давайте я ее так кратко восстановлю.
Значит, было p, было x, тут какие-то под деревья были.
И мы вот такое вращение делаем, соответственно, x становится новым корнем.
p уходит вправо, ну и здесь будет там a, b, c.
Значит, что такое тогда вот это учетное время?
Это реальное время работы.
Давайте я напишу здесь единицу, как знак того, что мы сделали один маленький поворот.
Да, один маленький поворот.
А дальше плюс изменение потенциала.
И вот здесь как раз то, о чем вы говорили.
Извините, ну да, изменение потенциала.
Как меняется потенциал при таком повороте?
Ну у меня у каких-то вершинок поменялся размер под дерево, а значит поменялся r, поменялся рамк.
Но у каких вершин это поменялось?
Только у x и у p.
Понятно, что мы под дерево a не трогали, и поэтому там сумма всех этих r такая же, как была раньше.
То же самое с b, то же самое с c.
Там все потенциалы, все r не поменяются.
Поэтому изменилось что-то только для x и p.
Ну давайте это напишем.
Давайте мы напишем, что здесь изменение потенциала
это r' от x плюс r' от p,
минус r от x, минус r от p.
Где опять штрих означает, что это рамк в обновленной версии дерева,
а r' это рамк вот здесь,
а r от x это рамк вот здесь.
В старой версии до вот этой операции зиг.
Так, хорошо.
Давайте здесь заметим, что r' от p меньше или равно, чем r от p.
Ну это почти очевидно, потому что что такое r от p?
Это двоечисленный рифм всего вот этого размера вот этого под деревом.
А r' от p это размер только вот этого под деревом.
Ну понятно, что у меня размер под деревом p только уменьшился.
Давайте еще раз.
Раньше в нем было все вот это.
И p, и x, и i, и b, и c.
А теперь стало только p, b, и c.
Значит размер под деревом уменьшился.
Значит двоечисленный рифм тоже уменьшился.
Поэтому выполняется вот такое неравенство, что r' не больше, чем r' от p.
Поэтому можно вот это неравенство продолжить.
И сказать, что вот эта вот штука меньше или равно 0.
Если мы прибавляем что-то маленькое, считаем что-то большое,
значит мы прибавили что-то от...
Сейчас, секунду.
Ну да, короче, вот эта вот разность,
то, что я волнистый подчеркнул,
она, конечно, не положительная, меньше она 0.
Поэтому можно продолжить неравенство и написать,
что здесь написано 1 плюс r' от x,
минус r от x.
Вот.
Ну а эта штука, конечно, не больше, чем 1 плюс
утроенная r' от x,
минус r от x.
Вот.
Это очевидно.
Потому что, ну, как бы, я беру вот эту вот
разность, r' минус r от x.
Понятное дело, что она не отрицательна,
поскольку у меня размер по дереву x только вырос.
Давайте посмотрим сюда.
Вот это был старый r от x,
двоичным грифом этого размера.
А новый r' от x, это размер вот этого,
двоичным грифом вот этого размера по дереву.
Понятно, что тогда такая разность не отрицательна.
Значит, если нужно 3, то я ответ только увеличу.
Хорошо, значит, мы получили
оценку на zig точно такой, как нам нужно.
1 плюс утроенная разность
нового r' из старого.
Значит, для zig у нас все есть.
Давайте обведу.
Для zig мы получили оценку.
Едем дальше.
Теперь анализируем zig-zig.
Out-zig-zig.
Давайте я восстановлю картинку.
Значит, был grandparent, parent и x.
У них были там какие-то
поддеревья.
A, B, C, D.
И мы сделали такие повороты,
что x вылезла в корень.
p и g это правая ветка, а здесь A, B, C, D.
Хорошо, тогда что такое
учетная стоимость операции zig-zig?
Сначала мы пишем
реальное время работы этой операции.
Это, конечно, двойка, потому что, ну,
как мы не доказали, но так,
сказали, эта операция
складывается из двух маленьких поворотов.
То есть, если раньше мы делали 1 zig,
то теперь там нужно сделать 2 операции zig.
Здесь время, ну, как бы реальный
время работы будет двойкой.
Плюс обменяем потенциал.
Ну, опять, поскольку в поддеревьях A, B, C, D
у меня ничего не меняется, мне нужно просто
написать r' x, plus r' p,
plus r' g,
минус r' x,
минус r' p, минус r' g.
Да, потенциал изменился ровно на такую разность.
Штрихованные
ранги для x, p и g,
и обычные старые ранги для
x, p и g, ну, с минусом.
Вот, хорошо.
Дальше мне нужны здесь два неравенства.
Штрих – это новый потенциал.
Да, да, штрих – это потенциал в новом дереве.
Вот это всегда штрихи, все, что справа,
это штрихи, а просто r – это старый.
Значит, мне нужны два неравенства, что r' p больше
равно r' x,
и еще, что r' p меньше
равно r' x.
Давайте поймем оба эти неравенства.
Во-первых, что такое r' p и r' x?
Ну, вот это вот r' p –
двоичный алгорифм размера
вот этого поддерева.
А вот это r' x – двоичный алгорифм размера этого поддерева.
Ну, тогда извините, это очевидно.
Да, раз p является родителем x,
то, понятное дело, что в поддереве p-шки
вершинок больше, чем в поддереве x.
Поэтому это неравенство, ну, тривиально.
Значит, то же самое с r' p,
r' x.
Вот это вот r' x,
двоичный алгорифм вот этого поддерева.
Ну, опять-таки, да?
Раз теперь x стал родителем p,
то, ну, здесь, соответственно,
неравенство в другую сторону.
Кто родитель, того ранг и больше.
Хорошо.
Тогда, значит, в нашем этом неравенстве
мы можем
оценить вот это вот сверху
минус 2 r' x,
как я понимаю.
Сейчас, секунду.
Да, то есть минус
r' x.
Минус r', да, да, да.
Это будет меньше, чем минус 2 r' x.
И r' вот
это вот мы оценим
тоже сверху
двумя r' от x.
Да, значит, в итоге у меня получится
такое неравенство. Меньше ли бы равно?
Меньше ли бы равно?
Два плюс.
Так, сейчас, на секунду.
А, pardon.
Мне нужно еще...
Извините.
Я торопился.
Давайте пока так не будем делать.
Давайте пока заметим, что у меня
вот это вот
равно вот этому.
Вот как.
Ну, это тоже просто.
Что такое r' g?
Это двоечисленный грифм всего под дерево
до операции, а r' от x
это двоечисленный грифм размера всего по дереву
после операции. Ну, конечно, это одно и то же.
Раз мы само дерево не меняем, мы не меняем
качество вершины в нем. Значит, r' от x
вот это вот. И r' g это одно и то же.
Хорошо. Значит, в итоге
мы это можем сократить. Они идут с противоположными
знаками, и это одно и то же слагаемое. Мы это сокращаем.
Остается два плюс.
Дальше r' от q мы оценим через вот
это неравенство. Будет r' от x.
r' g оставляем.
Ну, а здесь, как я сказал, да, у меня
минус r' от x минус r' от p.
Минус r' от p я оценивался сверху
через минус два, минус r' от x. Получился
минус 2r' от x.
Минус 2r' от x.
Отбавим атмосферу из 2 плюс r' от x
плюс r' от g минус
2r' от x. Да.
Давайте перепишем.
Значит, мы поняли, что аутик-зик
меньше либо равно, чем 2 плюс
r' от x
плюс r' от g минус
2r' от x.
Так.
Дальше, дальше, дальше.
Докажем,
что вот эта вот штука
меньше либо равна
3r' от x
минус r' от x.
Ну, если мы это докажем,
то дальше продолжение очевидно,
что эта штука не больше, а нет, нет, нет.
Мы так не можем делать. Мы просто докажем вот
это неравенство.
Так, ну, чтобы доказать, это неравенство, конечно,
мы начнем с следующей штуки.
Переносим все налево,
а 2 переносим направо.
Будет вот что.
Будет r' от g
плюс r' от x
минус 2r' от x.
Меньше равно, чем минус 2.
Вот это мы хотим доказать.
Проверяйте за мной.
Я раскрыл здесь скобки.
Перенес 3r' от x сюда.
Оно сократилось
и стало минус 2r' от x.
Перенес плюс 3r' от x сюда,
стало плюс r' от x. Вроде все правильно.
И минус 2 перенес направо.
Я хочу доказать такое неравенство.
Ну, давайте я его представляю
в таком виде, что это r' от g
минус r' от x
плюс r' от x минус r' от x.
Что это меньше, в общем,
минус 2.
Вот, а дальше
мне нужна опять эта картинка.
Давайте ее скопируем с прошлого слайда.
Вот, я просто скопировал.
Теперь смотрите, что такое r' от g
минус r' от x.
Значит, вот оно, r' от g.
Вот оно, r' от x.
Давайте тогда
запишем, что это
минус r' от x
минус r' от x.
Вот оно, r' от x.
Вот оно, r' от x.
Давайте тогда
запишем, что это
это логарифмы размеров по деревьев.
То есть, на самом деле, вот эта вот разность
это логарифм минус логарифм,
то есть, по сути, логарифм отношения.
Логарифм s' от g,
то есть, нового размера под дерево g,
деленное на
размер нового под дерево x.
Вот эта вот разность.
Это такой логарифм.
Значит, дальше.
У меня r' от x минус r' от x.
Вот это было
старая r' от x.
А вот это
новая r' от x.
Здесь будет плюс
логарифм
старого размера x,
деленный на новый размер x.
И вот это мы хотим доказать, что это не больше
минус 2.
Ну а здесь уже
все просто.
Давайте мы вот это вот
x, вот это s' от x, расположен
в нашем новом дереве, штрихованном.
Вот он, s' от x. Это a, b и x.
Значит, это s' от x,
это s' от g.
И смотрите, что здесь написано.
Мы поделили какую-то часть дерева,
ну, размер какой-то части дерева
на всю дерево, вот это s' от x.
Взяли логарифм. Потом прибавили
опять логарифм, опять к какой-то
части дерева, которая не пересекалась со старой,
ну, то есть, вот в слоге
s' от g. И опять поделили на все под дерево,
на s' от x. И взяли логарифм.
Ну, тогда, если я просто скажу,
что давайте вот это обозначу за a,
давайте обозначу за b,
то есть, какая доля вершин
лежит в s' от g,
какая доля вершин лежит в s' от x,
тогда понятно, что a плюс b не больше 1,
потому что они, суммарно, они не пересекаются,
и, суммарно, оба вложены в
s' от x.
То есть, вот эти два множества,
они не пересекаются и вложены в s' от x.
Значит, сумма отношений их
к s' от x
не больше 1.
Ну, а дальше мне написано следующее,
что это два не отрицательных числа a и b,
сумма не больше 1.
И я вдруг хочу доказать, что сумма
изглочных логарифмов не больше, чем
минус 2.
Не больше минус 2.
Но это уже простое упражнение,
простое утверждение.
Давайте мы его докажем, давайте скажем,
что если у меня a плюс b не больше 1,
то произведение a на b
оно не больше, чем
что там?
Значит,
1 четверть
a плюс b в квадрате.
Правда же?
Так, окей, давайте я...
То произведение будет максимально,
когда они реагируют?
Ну, конечно, да, конечно. То есть, тут, на самом деле,
просто скрыто неравенство между средним арифметическим
и средним геометрическим.
Мы точно знаем вот такое неравенство, что корень из a b
не больше, чем 1 вторая a плюс b.
Дальше, если возведу в квадрат,
будет a b не больше, чем 1 четверть a плюс b в квадрате.
Ну, теперь, если я все про логарифм...
Значит, это я понимаю, что это не больше,
чем 1 четверть, раз у меня сумма ограничена
единичкой сверху.
Ну, а это просто... Если я все про логарифмирую,
у меня слева получится лог a плюс лог b
не больше минус 2,
потому что 1 четверть это как раз логарифм
от... Продон...
Минус 2 это логарифм по основанию 2,
а вот 1 четверть. Короче, отсюда нужно
взять логарифм по основанию 2 и победить.
Давайте раскрутим цепочку обратно.
Значит, мы знаем вот это вот.
Мы хотим доказать, что эта штука
оценится сверху вот такой вещью.
Значит, чтобы это сделать,
мы просто перенесли все в удобные стороны,
представили это в виде,
что сумма логарифма в небольшом константе,
поняли, что аргумент логарифма
в сумме идет максимально единичку,
но дальше доказали простое неравенство
из теории чисел, арифметики,
что угодно, алгебры.
И поняли, что это верно.
Значит, и все это исходное верно,
и мы доказали, что время работы зиг-зига,
давайте тоже выделю синим,
не больше, чем утройная разность рангов
икса.
R' от X минус R от X.
Вот, шикарно.
Теперь, последнее,
что нам надо сделать для сплоя,
это зигзаг.
А вот зигзаг.
Ну, здесь тоже ничего...
Все такое же, как было в зиг-зиге.
Давайте эти рассуждения тоже
начнем с продела.
Нарисую картинку.
После зиг-зига
дерево будет таким.
Я просто восстанавливаю то, что у нас было раньше.
АВЦ.
Так, хорошо. Значит, смотрим,
что здесь происходит.
Пишем учет на время работы
зиг-зига.
Ну, сначала мы понимаем, что нам нужно сделать два малых поворота,
поэтому реальное время работы мы пишем, что это двойка.
Дальше, как всегда,
плюс R' от X,
плюс R' от P,
плюс R' от G,
минус R' от X,
минус R' от P, минус R' от G,
потому что, как всегда, другие ранги не меняются.
Хорошо.
Вновь замечаем, что R' от X
можно...
Так, давайте я вот так легонечко
что R' от X
равно R' от G,
потому что что такое R' от G?
Это двоичный гриф вот этого размера по дереву,
а R' от X это двоичный гриф вот этого размера по дереву.
Суммарно, это одно и то же по дереву,
просто как-то переставлено в дыршинке.
Значит, двоичный гриф одинаковый,
поэтому их можно сократить.
Ну, а еще мне нужно одно неравенство в этом случае.
Так.
Да, мне нужно одно неравенство,
что R' от P больше равно,
чем R' от X.
Кажется, у нас это тоже уже где-то было.
Что такое R' от P?
Это двоичный гриф вот этого размера.
Понятно, что он больше равен двоичному грифу вот этого размера.
Да, если P это родитель X в старом деле,
то R' от P больше равно, чем R' от X.
Это очевидно.
Значит, тогда дальше вот это можно продолжить.
Вот эту штуку можно продолжить.
И оценить R' от P через R' от X
будет 2 плюс R' от P
плюс R' от G.
Минус 2 R' от P.
Минус R' от P меньше равно,
чем минус R' от X.
Как раз получается оценка сферы.
И мы теперь докажем,
что вот эта штука
меньше равна, чем удвоенная
R' от X
минус R' от X.
Ну, а если мы это доказали,
то, конечно, это не больше, чем удвоенная R' от X
То есть здесь нам для доказательств
будет удобнее написать двойку,
и там тоже будет, не раясь от того же вида,
удобнее доказывать с двойкой,
а потом это загрубить до тройки.
Так, ну чтобы это доказать,
давайте опять все перенесем,
все R' перенесем влево.
Кажется, что это будет оценка снизу,
потому что ведь R' от P больше, чем R' от X.
Типа, допустим, R' от X3, а R' от P5.
То есть мы вычитали минус 3 было,
стало минус 5.
Там, по-моему, все перегащено.
А, извините, это описка просто, да, извините.
Спасибо, что заметили, да, это я просто описался.
Об этом долго искали.
Да, давайте еще раз повторю.
Вот здесь у меня R' от P
ограничено снизу, значит,
минус R' от P ограничено сверху,
минус R' от X.
Тогда как раз минус R' от X, минус R' от X
будет минус 2 R' от X. Да, спасибо, описался.
Так, хорошо, значит, здесь
давайте все перенесем,
поймем, что сокращается,
и, значит, как с этим работать.
Но вот здесь будет минус 2 R' от X одинаковое,
да, минус 2 R' от X в обеих частях мы это сокращаем.
Остается R' от P
плюс R' от G
минус 2 R' от X.
И это мы хотим сказать, что
меньше набравно, чем минус 2.
Правда ли это?
Значит, если это верно, то мы доказали
все для зигзага, для зигзага.
Хорошо.
Значит, я могу написать точно также, что это
дуичный алгорифм S' от P
делить на S' от X
плюс двоичный алгорифм
S' от G
минус S' от X.
И что это вопрос не больше минус 2.
Здесь логика точно такая же.
Значит, рисуем S' от P.
Вот оно, и мы делим это
на все S' от X.
Рисуем S' от G, вот оно,
и мы это делим на все S' от X.
Тогда, вновь, если вот эти вот штучки
обозначить за A и B,
вот это A,
вот это B,
тогда видно, что A плюс B не больше, чем 1.
Потому что мы берем два
непересекающихся куска
дерева, делим их на
размер всего дерева, тогда понятна сумма этих
долей не больше 1, потому что они не пересекались
и были вложены в исходное дерево.
Значит, работает то же самое. У меня есть два
неопределительных числа с суммой не больше, чем 1.
Значит, сумма двоичных алгорифмов
лог 2 плюс лог 2B
не больше минус 2.
Ровно из тех же самых соображений,
которые были в предыдущем пути.
Все, мы доказали для zigzag.
Но это еще...
Нужно еще кое-что сделать,
чтобы завершить все доказательства
просплей.
Итак, давайте наши результаты
суммируем. Значит, здесь мы доказали
вот это.
И теперь я
это все напишу в одном месте.
Значит, что мы поняли? Мы поняли, что
время работы операции zig
не больше 1 плюс 3
h' от x минус r от x.
Дальше.
Время работы zig-zig.
Не больше, чем просто утройное
h' от x минус r от x.
А zigzag
тоже не больше, чем утройное
h' от x минус r от x.
Где, я повторю, r' это ранг
x в дереве после операции
ну, там, соответствующей операции.
А r от x это дерево, это ранг
в дереве до этой операции.
И здесь, смотрите,
если бы мы
не вводили отдельно zig-zig
и zigzag, как вот меня в самом начале спрашивали,
почему нельзя просто, конечно, zig-zig это там,
zig и zig, а zigzag это zig и zag.
Потому что
у нас бы вот здесь вот везде была бы единичка
1 плюс. То есть,
если бы мы ограничились только вот этой штукой,
у меня была бы плюс один везде, в каждом из действий.
Но за счет того, что мы вот так
хитро делаем, что если у меня
два раза левый синт, мы делаем в таком порядке,
то есть левый-правый в другом порядке,
делаем поворота, у меня так хитро
получается, что оценка более точнее,
вот эта единичка не вылезает.
И это нам будет очень важно.
Итак, теперь, чему же равно время
работы операции с плей?
Ну, как работает с плей?
Это несколько zig-zig и zigzag,
и в конце максимум один zig.
Хорошо.
Тогда давайте скажем, что
ну, вот там, не знаю, r0 от x
это ранг
это рянь R0
до всех поворотов,
до всех ease-gig и zigg pup.
Р1 от x
это ранг XA
после первого поворота.
То есть после первого вот phones
процедуры поворота
zig-zig, zig-zag и так далее.
R2 от x
это тоже самое, после второго поворота,
ну и так далее, dem Rk
после последнего поворота.
последний. тогда смотрите, вот эти вот все ребята это либо зигзиги, либо зигзаги, а это либо зигзиг,
а это что угодно. здесь зигзиги, или зигзаги. вот, ну тогда что такое arts.play? надо просто
просуммировать вот эти вот все оценки на вот эти все времен, на работы учетные, и тогда получится,
что все вот эти вот старые, все вот эти вот, кроме последнего, это утройная разность r, там 3r1 от x
минус r0 от x, плюс 3r2 от x минус r1 от x, и так далее, вплоть до там утройного rk-1 от x минус rk-2 от x.
ну и остается последний поворот, это либо зигзиг, либо зигзаг, либо зиг, но главное, что у них у
всех есть сверху вот такая оценка, 1 плюс утройная разность р, здесь будет плюс 1, плюс 3rk от x,
минус rk-1 от x. ну и как говорят классики, шлёп-шлёп, шлёп-шлёп, значит все вот эти товарищи
сократились, и у нас остается в разности, смотрите, единица, три новых ранга, то есть три ранга
после всего, минус три исходных ранга, минус 3r0 от x, значит получается, так давайте я вот здесь
напишу, получается что a от splay не больше чем 1, плюс 3rk от x, минус 3r0 от x, это ровно то, что мы хотели
доказать, что после одного сплея у нас, точнее у нас просто учетное время работы одного сплея не больше
чем единица, плюс утройный новый ранг x, то есть после всех этих поворотов, после сплея целиком,
минус утройный ранг x в начале, а это ровно то, что мы хотели, из этого следует, что учетное время
работы каждого сплея это логарифм, значит просто амортизировано, каждый раз обрабатывается за от
логарифма, на этом мы на самом деле все просто и доказали, давайте еще раз повторим, мы доказали,
что каждый зигзиг или зигзаг мы поняли, как его учетное время работы, оценили сверху, затем
поняли, как сплей распадается на вот такие зигзиги, зигзаги и так далее, сложили все эти оценки и
получили вот такой оценок, что красивый оценок для a от splay, что чему аценция, которая в квадратике
примерно равна логарифму. possible questions? Почему аценка, которая в квадратике примерно равна
логарифму? Да, потому что, смотрите у нас что такое rank, вспоминаем, это двуечный логарифм размера
поддерева, ну вот здесь написан логарифм размера поддерева, который, ну там на самом деле просто
равен размеру всего дерева, но раз берет какой-то поддерева, то это не больше чем логн, значит это
это максимум log n, здесь еще вы считаете что-то там, порядка log n, вот значит амортизационно
каждый из плей работает за логарифм и значит мы доказали то что хотели, что раз каждый
из плей амортизационно за логарифм, значит и наши вот эти исходные запросы insert, erase и find, раз мы их
оценили сверху тоже с плейами, то значит и наши исходные запросы тоже исходно работают за
учетной отлогой, а можете повторить почему важно все-таки делать display, почему это позволяет его
оценить, только потому что мы делаем с плей, позволяет нам оценить сверху erase с плейом,
ну и черт, ладно, вот erase, почему и выполнение его позволяет оценить сверху, нет, ну смотрите,
здесь и есть очень простая, вот пусть мы сделали какой-то erase, там мы спустились на глубину k,
ну сколько-то шагов прошли, соответственно время работы в пропорциональной
глубине, пропорциональна на k, а дальше мы запускаем сплей, вот вот этот последний
пистелин на вершинах, понятное что время работы сплея, оно пропорционально на k тоже, ну раз мы
делаем вот эти подъёмы, вершинки на глубине k которые мы поднимаем вверх, понятное, что время
работы тоже в пропорциональной ко
удвоенное время сплея, то есть arrays plus splay не больше
чем два сплея, потому что arrays работает не больше
чем splay, а значит, суммарно, когда мы анализируем все
операции, мы можем все insert и arrays оценить сверху соответствующими
им сплеям, и раз каждый сплей за логарифм, то и все
эти тоже за логарифм. Есть контакт?
Ну окей, да. Так, в чате еще важное
Ну, точнее, почему потенциал в конце больше начального?
Да, потому что чтобы у нас был корректный метод потенциалов,
нам нужно, чтобы потенциал всегда был разный, потенциал,
чтобы была в конце минус начало, была всегда интересна.
Ну здесь очень просто, потенциал в начале это ноль,
потому что мы считаем, что у нас изначально есть пустое
дерево, пустое множество, там нет ни одной вершинки,
соответственно, нет ни одного икса, и все ранги, нет рангов,
мы берем пустую сумму, а потом, когда мы делаем всякие запросы,
рейзер и так далее, потом делаем сплей, то у меня потенциал
становится не отрицательным, потенциал это сумма рангов,
каждый ранг это логарифм чего-то, что больше на 1,
то есть потенциал всегда не отрицательный, ну а изначально он ноль,
то есть изначально дерево пустое, а после запросов он
становится каким-то там, вот, хорошо.
Тогда я считаю, что сплей мы обсудили, сплей мы обсудили,
и я повторю, что в принципе, с точки зрения теоретической симптотики,
здесь нет ничего лучшего, чем овельдия, но с точки зрения практики,
вот если этот пример с товарищами, которые там часто приходят на сайт,
их нужно быстро обслуживать, это довольно важно, что
часто элементы будут ближе к коем, вот это такое замечательное
свойство сплейдели. Хорошо, тогда давайте мы теперь перейдем к П-дереву,
сколько успеем, столько успеем.
На секундочку, вот мы с Ашками мы разобрались, что они примерно как логарифм,
а почему само время как логарифм мы как-то там выражали, а через время вот на пол.
Ну, вспоминайте, так работает метод потенциалов, да, что такое А,
если мы ведем А как Т плюс дельта Фи, и вот это А будет там не большим логарифм,
тогда мы просто по определению говорим, что учет на время работы
каждой литрации это логарифм. Что это значит? Да, возможно,
каждая конкретная Т может быть вполне большим, хоть линейной,
но тогда это значит, что у вас потенциал сильно упадет,
то есть если здесь примерно N, тогда здесь дельта Фи, оно там примерно
минус N плюс лог N, чтобы Ашка была логарифмической,
то есть если у вас долго время работы, то у вас сильно падает потенциал.
Значит, суммарно, если вы сделали, скажем, К операций, то можно считать,
ну, это мы доказывали, нужно обратиться к лекции про амортизационный анализ,
там будет метод монеток и метод потенциалов, тогда можно просто считать,
что вот эти Ашки и есть как раз амортизированное время,
но это просто определение, что такое амортизация, что можно так перераспределить
все время вот этих всех запросов, что суммарно как будто бы каждый логарифм.
Да, на самом деле каждый конкретный может хоть за линию работать,
но суммарно из-за вот этого анализа мы показываем, что суммарно они все будут
работать за МЛГ, ну, за К, если К, то что за вопрос?
Сейчас, а вот еще такой вопрос, вот если у нас дерево, у каждого,
у каждого один всего сын там, ну, все влево и все вправо идет,
у нас такое очень длинное дерево, и мы запускаемся то от самого левого элемента,
то от самого правого паянт делаем, не будет ли тогда, ну, низлогарифм?
Ну, на самом деле не будет, потому что, даже не знаю, если у вас так...
Ну вот есть у вас какое-то такое дерево, например, идущее чисто влево,
вы запустите отсюда, тогда у вас тут будут какие-то зигзиги,
и там Х поднимется сюда, но, конечно, надо понять, как пристроится дерево,
мне кажется, оно будет примерно таким, примерно две ветки длины паянта по полу.
Дальше вы запускаетесь отсюда, и там эта ветка тоже за линию время
сокращается по длине две ветки длины N на 4,
и тогда суммарно у вас глубина будет довольно быстро станет логарифмической,
и поэтому, как бы, то есть, да, первые операции какие-то тяжелые,
но в среднем будет логарифм.
Ага, понял, спасибо.
Это единственное преимущество сплэйдерева, это даже что такое быстрое доступ.
Ну, быстрое доступ к сплэйдереву.
Тех того, да, да, ну, смотрите, давайте, давайте не будем ограничивать,
что это единственное преимущество, это одно из преимуществ.
Возможно, есть какие-то другие, просто я о них играть не знаю,
то есть они все эти деревья используются в зависимости, собственно, от ваших задач.
Вот если у вас такая задача, если у вас реально есть частые пользователи,
то это прям оптимальный вариант.
Если вам нужно еще что-то другое, да, то, возможно, как-то можно проанализировать,
где сплэйд тоже будет, скажем, выгоднее, чем АВ.
Почему АВ, а где АВ, выгоднее, чем сплэйд?
Вот, да, вот ответ в чате, да, что мерш и сплэйд адекватнее для сплэя.
То есть если вам нужно делать еще мерш и сплэйд, мы про это еще поговорим на лекциях,
когда будем про дикартовый дерево говорить.
Мерш и сплэйд у сплэйдерева проще, да, и там не возникает точно лог квадрата никакого.
Наверное, если запросы ко всем элементам равновероятны, то АВ лучше, чем сплэйд.
Ну, типа того, да.
Ну, как бы здесь, сейчас, одну секунду.
Да, ну, АВ может быть лучше, чем сплэйд в следующем понимании,
что если у вас нет вот этого вот перекоса в сторону частых пользователей,
и так, как вы предложили, действительно более-менее равновероятны все запросы,
то есть у вас нету там ярко выраженных популярных элементов,
тогда АВ будет лучше, потому что у АВЛ есть свойство, что глубина как сигнала рифмическая.
Мы доказывали в прошлый раз, что глубина-то максимум от лог-логен,
и тогда неважно какие запросы, у вас всегда время работы любой операции максимум алгорифмы.
А в сплэйд дереве, к сожалению, у вас может быть такое, что само дерево вырождается.
И вот ваш пример, я хочу сказать, что у вас может быть такое,
что само дерево вырождается. И вот ваш пример, я, к сравнению, не вижу ваших имен,
спрашивали, что делать, если дерево вот такое в бамбу превращается,
просто сын-сын-сын влево-влево-влево.
Такое может быть в сплэйд дереве, и тогда, когда вы запуститесь вот отсюда,
у вас на одну конкретную операцию уйдет линейное время.
Да, такое будет происходить редко, но здесь зависит от того, что вам нужно.
Если вам нужно быстро обслуживать частых клиентов, и вам пофиг на редких клиентов,
если вам нужно, чтобы вы всегда обрабатывали всех не больше, чем за логарифом,
то ваш вариант овэй. Вот, собственно, и все.
То есть если вам нужно, чтобы любой запрос был не больше, чем сколько-то,
то овэй. Если вам на какие-то запросы пофиг, и вы их можете обрабатывать долго, то сплэй.
Вот и все.
Овэй на такой стабильник.
Да, именно так.
Так, ну хорошо, значит, Б-дерево все-таки мы переходим к нему.
Тоже у него есть свои преимущества, я про все это расскажу.
Значит, давайте мы теперь предположим, что в каждой вершине мы можем хранить не один ключ, а несколько.
И вот давайте скажем, что в вершине, в узле, теперь я буду здесь перемешивать понятие вершины и узел,
это одно и то же будет у нас.
В узле мы будем хранить много ключей.
Ключ К1, К2 и так далее КС.
Причем эти ключи будут упоряточены. К1 меньше, чем К2, меньше, чем и так далее, меньше, чем КС.
И из этого узла будет много стрелок в детей.
Будет стрелка левее, чем К1, будет стрелка между К1 и К2, будет стрелка между К2 и К3 и так далее.
Все вот такие стрелки между всеми интервалами, между ключами, а также с левой и справа.
И смысл такой. Все элементы, лежащие левее вот этого вот левого элемента,
должны иметь ключ меньше, чем k1. Дальше все лежащие вот в этом вот между k1 и k2 должны иметь значение в интервале от k1 до k2.
Все лежащие вот в этом подделе обязаны иметь ключи от k2 до k3, ну и так далее. В последнем вот этом дереве все ключи имеют, ну все ключи только больше, чем ks.
То есть это такое обобщение по сути двоичного дерева поиска. Мы здесь уже отказываемся от двоичности, у меня бывает много детей у каждой вершинки.
Также и ключей в каждой вершинке много, но зато у меня вот такое более полное подразбиение, что ли.
То есть раньше я просто по одному x сверял, куда нужно идти влево или вправо. А теперь как бы я вот если, если честно, буду нарисовать, то я поставил на ней s засечек.
И если мне нужно идти к какой-то x, я понимаю между какими двумя засечками этот x лежит, скажем вот между k1 и k2, когда это означает, что я должен пуститься вот сюда.
То есть оно такое, у меня дерево гораздо более ветвистое, гораздо больше детей у каждой вершинки.
И это в частности позволяет мне спускаться, ну как бы у меня вот меньше операции спуска на самом деле,
потому что если я в каждой вершинке более подробно подраздыл мою бесчастную прямую, тогда у меня как бы меньше будет операции спуска, меньше глубина дерева.
Вот, значит идея такая, в каждой вершинке у нас будет много ключей.
И давайте тогда определим, что такое, что такое b дерево, значит определение b дерево.
Это дерево поиска в том смысле, как было на прошлом слайде. Дерево поиска.
Так, давайте еще b дерево будет с параметром t.
А у нас там ключи это предназначение, да?
Да, ну это какие-то числа просто. Можно пользоваться бинпоиском, можно просто пройтись по массиву и даже без бинпоиска это делать.
Там все равно будет t не очень большое, чтобы его оптимизировать до бинпоиска, там t будет примерно 100 или 1000.
В принципе не сильно страшно, если вы вместо бинпоиска будете просто проходить по всему массиву и искать там точку.
Потому что у нас все равно будет гораздо более сложная операция, и можно без бинпоиска делать просто линейный проход.
Итак, b дерево с параметром t. Это дерево поиска в том смысле, как было на прошлом слайде.
Что у каждой вышки может быть много детей, но они вот так подразбивают, что слева все меньше.
Дальше по интервалам разбивается вся вещастная примарка.
И выполняется еще дополнительно следующее свойство, что в любой некорневой вершине
количество ключей в количестве этих кашек лежит в отрезке от t-1 до 2t-1.
Ну где t, t вот какой-то параметр целочисленных хотя бы двоих.
То есть в каждом некорне, в каждой вершине, которая является некорним, у меня количество ключей от t-1 до 2t.
Это первое условие. Второе условие в корне, количество ключей лежит в отрезке от 1 до 2t-1.
То есть 2t-1 у меня ограничений остается, но теперь в корне может быть меньше, чем t-1 ключ, может быть просто 1 ключ.
От 1 до 2t-1 в любое число.
И наконец третье условие, это что все листья на одной глубине.
Здесь опять можно задать вопрос, почему так, почему t-1, t-2, t-1, почему в корне отдельно.
Я предлагаю сильно над этими думать, давайте просто из книжки возьмем такие свойства и поймем, что это дерево умеет
за логарифм, отвечает на запросы и обладает хорошими искусствами.
То есть не задумываясь о том, как это получено, почему именно так.
Листья совсем на одной глубине или не более какой-то глубины?
Еще раз.
Листья совсем на одной глубине или не более одной глубины?
Нет, нет, все на одной. То есть вот есть у вас корень какой-то, есть у него там несколько сыновей, есть у них там дети.
Ну и значит там, если вот это листья, то они все на одной глубине, то есть вот прям все на фиксированной глубине, на одной и той же.
То есть при необходимости мы где-то можем линию дотянуть, лишь бы была нужна глубина.
Что значит линию дотянуть?
Ну то есть если у нас, допустим, не совсем равномерное, то есть в ВВЛ дереве, например, разрешено отличие на один, а тут прям вот совсем.
Да, тут не будет отличия, тут прям фиксировано, с левой и с правой будет одинаково всегда.
Да, более жестко.
Получается дети Б дерева тоже Б деревни?
В частности, да. Ну то есть если у вас есть большое дерево, и вы берете его любую под дерево, то тоже Б дерево, да, это правда.
А в первом пункте, не гарневая вершина, имеется в виду не самая верхняя?
Да, ну любая, кроме самой верхней.
Так точно будет?
Что?
Да, да, да, действительно.
Хорошо. Вот, значит такие странные условия, которые откуда-то нам взялись с неба.
Давайте докажем, что если дерево обладает такими свойствами, то у него глубина примерно логерифм N по основанию T.
Значит, простое утверждение, что если в Б дереве N ключей, если в нем N значение лежит, то его глубина...
А мы предполагаем, что T сильно меньше, чем N, да?
Да, да, да. Мы предполагаем, что T это какая-то константа в районе 100 или 1000, а N может быть очень-очень большим, там сотни тысяч, миллионы и даже миллиарды.
То есть брать T в 10 в шестой, потом получать единиц не выйдет?
Ну 10 стоит, да, все-таки слишком много. Обычно вот, как я сказал, в районе тысячи. Обычно T в районе тысячи.
Да, то есть это скорее константа, чем параметра от N.
Вот, значит, утверждение, что если в Б дереве N ключей, то глубина этого дерева ограничена сверху логерифмом T этой степени от N.
Ну и соответственно, чем больше T, тем у меня меньше глубина. Чем больше T, тем больше основание логерифма, значит, тем меньше само значение логерифма, тем меньше глубина.
Начну доказательства. Пусть B дерево имеет глубину H, какое в нем может быть минимальное число ключей.
Тут я, к сожалению, возможно, буду иногда оговариваться, потому что раньше всегда у меня, когда было двоичное дерево, у меня ключ и вершина была одно и то же.
В каждой вершине ровно один ключ, ровно одно число. Ну и наоборот, каждый ключ стоит в какой-то вершине.
А здесь наоборот, у меня каждый вершин – это много ключей. И вот тут важно, что N – это ключи, а не вершин, потому что в вершине может быть аж T ключей, поэтому вершин примерно в T раз меньше, чем ключей.
Вот мы считаем именно ключей. Вопрос, какое может быть минимальное число ключей, вершина ключей.
Ну, чтобы было минимальное количество, прификсированное глубине, понятно, что мне нужно в каждом момент времени иметь как можно меньше ключей в каждой вершине.
Значит, я в корне говорю, что всего один ключ. Дальше у корня, получается, есть два ребенка, в каждом из которых минимально возможное количество ключей – это T-1, T-1 ключ в каждом из них.
А какое числоוא quiz That is possible? Это минимально возможно или максимально возможно, или вообще все случаи?
Это минимальное число. Какое может быть минимальное число вершин в этом деле?
Ну, как раз, зак suffering. Такойinen и falling times even, roles often happen often.
минимально возможным числом че, и так далее.
Значит, если у меня в детях по t-1 ключу, то, соответственно, из них выходит по t-стрелок.
Значит, здесь t-стрелок, и здесь тоже t-стрелок.
Потому что если t-1 ключ, то промежутка между ними ровно t.
Здесь тоже t-стрелок. Получается, здесь тоже находятся какие-то дети.
В каждом из них по t-стрелок, и из каждого из них выходит по t-стрелок.
Ну, раз мы хотим минимально возможное число вершин, значит, я в каждой вершине располагаю
внимание, что ключей, то я в каждой вершине располагаю t-1 ключ, минимум возможный,
и, соответственно, дальше вниз t-стрелок.
Ну и так все это до глубины h.
Хорошо, давайте тогда посчитаем, сколько у нас получается вершин.
Значит, здесь одна вершина на этом уровне, один ключ, один ключ от корня.
Дальше здесь 2 на t-1 ключей, 2 на t-1, потому что две вершины в каждой вершине по t-1 ключ.
Дальше сколько у меня ключей вот здесь?
Ну, смотрите, число вершин, это, видимо, 2t.
Потому что на прошлом уровне было две вершины, каждая из них породила t новых детей,
и в каждом ребенке по t-1 ключу.
Поэтому вот это количество ключей на вот этом вот третьем уровне.
Ну, дальше, соответственно, будет 2t квадрат на t-1,
потому что если здесь было 2t вершин,
потом каждая из них порождает еще по t сыновей, значит будет 2t квадрат вершин.
И в каждой из них будет по t-1 ключу.
Ну и так далее. Последнее будет, видимо, 2t в степени h-1 на t-1.
Так, в итоге сумма равна 1 плюс 2 на t-1,
плюс 2t на t-1, плюс и так далее.
Ну, короче, здесь будет геометрическая прогрессия t h-1 t-1.
Что я хочу? Я хочу, видимо, вынести за скобку,
ну, я ставлю единица, я напишу 2t-1, вынесу за скобку,
и в скобках останется 1 плюс t плюс t в квадрате,
плюс так далее, плюс t в степени h-1.
Так? То есть я вынес, я оставил ничку, я вынес за скобку 2t-1,
в скобке осталась сумма степеней t.
1t t в степени h-1.
Едем дальше. Значит, давайте сумму перепишу здесь.
Сейчас мне нужна будет сумма геометрической прогрессии,
чтобы эту форму упростить.
Ну, это что такое? Это t в степени h-1 делит на t-1.
Ну, это просто сумма геометрической прогрессии.
Значит, t-1 чудесным образом сократилась,
и получается, что сумма – это 1 плюс удвоенное t в степени h-1.
И это, смотрите, это минимально возможное число вершин в дереве глубины h.
Ну, значит, если в дереве глубины h n ключей, извините, это минимально возможное число ключей.
Минимально, я опять уговорился, минимально возможное, извините, пожалуйста,
ничего не могу сделать, минимально возможное количество ключей.
Но если в дереве глубины h, если мы предполагаем, что в дереве с n ключами глубина h,
то тогда получается, что эта штука меньше равна, чем n.
То есть это минимально возможное, а это какой-то конкретный, что в нем n ключей.
Тогда, выполняясь такого неравенства, давайте что-нибудь здесь перенесем.
Потом еще единичку перенесем.
И получается, что h не больше, чем логарифм по основанию t от n плюс 1 пополам.
То есть, если в дереве n ключей, то глубина этого дерева не больше, чем логарифм по основанию t от n плюс 1 пополам.
Что и требовалось. Да, нужно было показать, что глубина ограничена сверху.
О от логарифм по основанию t от n.
Ну здесь как раз пополам поделилось с точки зрения асимптотики.
Основная часть это как раз лог t от n.
Все, доказали.
Доказали.
Так, ну хорошо. Давайте тогда я скажу, зачем это может быть нужно.
Мы поймем, как работает find и на этом закончим.
Значит, зачем нужно?
Зачем это дерево?
А вот зачем. Чтобы хранить очень большие базы данных.
Чтобы хранить очень большие.
Ну я напишу базы данных, но имеется в виду просто любые большие хранические информации.
Любые большие деревья.
Значит, такие большие, что само дерево не может уместиться в вашу оперативную память.
То есть вы не можете с ним работать очень быстро.
И лучше, что вы можете сказать, то, что дерево располагается у вас где-то на жестком диске.
Либо вы вставляете флешку и там какая-то база данных, не знаю, какого-нибудь всего мира.
Сколько, чего, какой человек купил.
Ставили на флешке и вот с этим работаете в оперативку.
Вы это не можете подгрузить, там слишком много информации.
Либо это просто информация из жесткого диска, тоже какая-нибудь там большая база данных,
которая вы себе в оперативную память не подгрузится никак.
Там нет слишком много данных.
Тогда будет работать все примерно следующим образом.
Вы можете встать в данное место диска.
Ну, ваще всего у вас все на жестком диске.
Вы встали в данное место диска, которое соответствует какой-то вершинке.
Это вот вершина вашего дерева.
Вершина Б дерева.
И вот здесь ключей в этой вершинке, в принципе, немного.
Их здесь Т.
Эти ключи вы можете подгрузить себе в оперативку.
Значит, подгружаем, подгружаем.
В оперативную память.
Дальше.
Если нам нужно сделать find X, то мы находим, где в этом массиве должен располагаться X.
То есть, если тут K1, K2 и так далее.
Ks.
Где S там от T до 2T примерно.
То мы или бинпоиском, или чем угодно.
Или просто линиями проходом.
Понимаем, между какими двумя ключами, соседними, должен располагаться тот X, который вы ищете.
Ну, соответственно, мы понимаем, куда нужно перейти.
Мы понимаем, какой переход к какому следующему узлу нужно сделать в поисках X.
Вот это мы поняли.
Но дальше смотрите.
У нас вот отсюда стоит какая-то стрелка, которая указывает на какую-то другую вершину.
И, в принципе, если у меня эта база данных огромная, то положение вот этой новой вершинки, следующей вершины, оно может быть довольно далекое.
Соответственно, там просто даже чтобы вам взять головку, которая указывает на нужную позицию в области памяти, на жестком диске,
вам нужно ее поднять, переместить очень-очень далеко и опустить.
Если у вас большая база данных, то у вас могут быть всякие разные ссылки на очень далекие вершинки.
Ну, просто физически далекие, для которых нужно далеко двигаться.
Вот вам нужно так взять и оттуда подвинуться.
Ну и, соответственно, самое тяжелое здесь – это как раз получаются вот эти переходы.
То есть подгрузить T-элементов, прочитать T-элементов, найти, где тут X – это все просто.
Это делается за от T.
А дальше вам нужно взять и передвинуть указатель, то есть прочитать какую-то новую область памяти на жестком диске,
чтобы ее прочитать, чтобы дадут дойти.
Вот это довольно дорогая операция.
То есть да, конечно, если у вас все в оперативке, то это фигня.
Вы можете в любое место тыкаться довольно быстро, считать, что это дешево.
А если у вас все это на жестком диске, то это может быть довольно долго.
Поэтому эта операция дорога, и нам хочется ее минимизировать.
Нам хочется минимизировать количество раз, в которые я это делаю,
когда я перемещаюсь к какой-нибудь другой вершинке, когда спускаюсь в дерево.
Но поэтому логично, что нужно сделать дерево таким более ветвистым и менее глубоким.
То есть в каждой вершинке расположить больше ключей, и при этом глубина уменьшится.
То есть да, у вас увеличится время обработки каждой вершинки.
Она будет обработаться за от T, чтобы понять, где там находится X.
Но все равно здесь самое сложное – это подгрузить в память.
Если у вас есть область данных, вам нужно сначала это все прочитать,
подгрузить себе в память и только потом делать бинпоиск, если хотите.
Но именно поэтому здесь бинпоиск даже не нужен.
Вы можете просто линейно пройтись, раз вы все равно это все считываете.
Можете линейно пройтись и понять, где там должен быть X.
И соответственно за от T вы обработали вершинку, и дальше понимаете, куда нужно перейти.
Ну это как раз переход довольно дорогой, и вам таких переходов хочется как можно меньше.
Ну и давайте тогда T сделаем достаточно большим, чтобы таких переходов было поменьше.
Я имел в виду, что пятиэтажки обычно длинные, невысокие.
Ну то есть это похоже на отличие этого дерева.
А, да, да, да, я понял, типа вот это вот это B дерево, когда у вас мало этажей, но много подъездов.
А вот это A-V-L дерево, когда там два подъезда, но много этажей.
Я так понял.
Так, вопрос про такие баз данных не на SSD, не на SSD.
Слушайте, ладно, я не эксперт по русским дискам SSD, но вот идея такая, что нам нужно такая просто мысль,
что вот если нам тяжело переключаться между разными областями памяти, то вот хочется их минимизировать.
А в контесте будут задачи, где данных там 256 гигабайт?
Нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, ход просто такого не умеет.
Нет, можно будет просто за бонус мне баллы написать B дерево.
То есть, конечно, для наших таких учебных задач такого не будет.
То есть там можно писать XA, XB, XC, что угодно.
Надо будет построить дерево на всех данных серверов VK.
Ну, если хотите, построите и поставим вам бонус.
Смотрите, мы хотим, чтобы переходов было поменьше, чтобы спусков по стрелочкам было поменьше, вот это будет LOCK-T.
блок t. Каждая вершинка обрабатывается за o от t, потому что нужно подгрузить блок памяти,
но соответственно find мы поняли как делать. Мы встали в корень, нашли между какими-то
двумя элементами располагается наш x, спустились, причитали новую вершинку. Опять там нашли,
спустились и так далее и так далее. Нашли до листа, если там есть x, то мы победили, иначе x
нигде нет. Вот, ну тогда все, на этом спасибо за внимание, до следующего раза продолжим пробовать
дерево. Дальше вы расскажете, что, ну как там сохраняется инвариант? Да, конечно, конечно.
