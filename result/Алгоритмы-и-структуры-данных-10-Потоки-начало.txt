Так, у меня остался долг про минимальное вершинное
покрытие и максимальное независимое множество.
Извините, я сегодня буду немножко в нос говорить,
не до конца выздоровел.
Значит, давайте я напомню, что мы сделали, мы доказывали
термин Кёнига, который говорит, что размер минимального
вершинного покрытия в вдольном графе.
Я напишу так, минимальное вершинное покрытие, собственная
аббревиатура Vertex Cover, вершинное покрытие, равно по размеру
максимальному, по рассочетанию, matching.
Ну и в качестве доказательства я там привожу какой-то
алгоритм, типа давайте мы возьмем наш граф, наш
двудольный граф, ориентируем его как-то ребра, ребра
не из поршитания слева направо, ребра из поршитания
справа налево.
Право налево те, которые лежат, ну вот в том самом
максимальном поршитании M, а слева направо те, которые
не принадлежат M.
Дальше запустим какой-нибудь обход типа DFS из всех ненасыщенных
вершин левой доли, из тех, которые ненасыщены поршитанием,
и обойдем все, что из них достижено по вот этим ребрам
ориентированным.
Дальше у нас физиграф распадется на, точнее все вершины распадутся
на 4 категории, посещенные и непосещенные в левой
доле и в правой доле.
То есть вот здесь находились все ненасыщенные левой
доли, из которых мы запускали обход.
Дальше мы как-то ходили по стрелочкам, посетили
все вот это, и еще все вот эти вершинки, то есть мы
иногда могли доходить до насыщенных вершин левой
доли, их тоже посещать.
Соответственно они все лежат в плюсиках L+, R+, а все,
что недостижимо, это вот это L-R-, соответственно
левая и правая доля.
И, значит, я всегда путаю вот это вот и вот это вот,
одно из них это минимальное вершинное покрытие, другое
максимально не здесь, вот сейчас поймем, кто из них
кто.
Значит, для этого надо понять, каких ребер в этом графе
точно нету.
Давайте напишем, каких ребер точно нет.
Ну, во-первых, очевидно, нет никогда ребер из плюсов
L-, поэтому нет ребер из L+, R-, нет ребер из R+, L-.
Значит, и третье, нет ребер, видимо, из R+, L-, наоборот,
из, сейчас, сейчас скажу, из R-, L+, да, да.
Я в прошлый раз вроде успел заметить, что таких ребер
не бывает, потому что если бы они были, то давайте
поймем, что это за ребро.
Это какое-то ребро, ведущее справа налево, то есть это
ребро из парасочетания, это какое-то ребро из
парасочетания, ведущее справа налево, поэтому оба
его конца насыщенные вершины.
Значит, вот отсюда DFS не запускался, это не начальные
вершины никакого пути, поэтому мы, получается, в нее как-то
дошли.
Но дойти в нее из другой ненасыщенной можно было
только с помощью вот этого ребра справа налево.
Это единственное ребро, справа налево, которое
в нее ведет.
Поэтому попасть сюда мы никак не могли, кроме как
с помощью этого ребра.
Да, но если это плюсик, значит, это тоже должно быть плюсик,
противоречие.
Вот, значит, таких ребер точно нет, из этого следует,
что уже вот это вот множество, это независимое множество,
да, потому что нет ребер ни слева направо, ни справа
налево.
Вот они, вот они два.
Значит, L+, R-, это независимое множество.
Ну и как мы отмечали в прошлый раз, значит, дополнение
к нему это вершинное покрытие.
Значит, все остальное R+, в объединении с L-, это вершинное
покрытие.
Докажем, что это минимально, то есть нет никакого другого
вершинного покрытия, которое было бы меньшего размера.
Меньше вершин в покрытии иметь нельзя.
Вот столько минимум меньше, меньше не получится.
Вот, ну для этого заметим давайте, что вот здесь вот
лежат только насыщенные вершины.
В обоих множествах лежат только насыщенные по рассчитанию
вершины.
R+, L-, лежат только насыщенные вершины.
Ну, с тем минусом вроде понятно, потому что ненасыщенные
вершины левой доли, они точно были плюсики.
Из ненасыщенных левой доли мы запускали обход, поэтому
они точно были объединены в нашем обходе, ну как мы
из них запускались.
Поэтому все ненасыщенные вершины левой доли точно
вот здесь.
Ну а значит насыщенные могут быть только здесь.
Ну в смысле не так.
Насыщенные могут быть и здесь и здесь, да, но здесь
ненасыщенные быть не может.
То есть тут только насыщенные.
Поэтому с L минусом очевидно, здесь только насыщенные.
Вот, а с R+, почему там только насыщенные?
Потому, что чтобы там была ненасыщенная, то раз она
в R+, значит мы до нее смогли дойти из ненасыщенных
вершины левой доли.
Значит, мы смогли начать где-то в L+, закончиться в R+, и, получается, мы нашли, на самом деле,
увеличивающий путь. Если бы, если мы нашли путь из ненасыщенного в ненасыщенную, вот в нашем
таком графе, то у нас получился бы увеличивающий путь, а мы предположили, что исход на прошествии
максимально. Вот, поэтому такого тоже не будет. Значит, если бы в R+, была ненасыщенная вершина,
то в G был бы увеличивающий путь. Да, но потому что, что значит, что здесь есть какая-то ненасыщенная,
вот она V ненасыщенная. Раз она в R+, значит, она как-то достижима. То есть, мы начали в какой-то
вершине U ненасыщенной вершины левой доли, как-то походили по ребрам слева-направо,
справа-налево, и рано или поздно пришли в V. Ну, значит, просто по определению это увеличивающий путь.
Я рисовал в прошлый раз тоже картинку. Мы начали, закончили в ненасыщенной, длина хотя бы единица,
потому что это разные доли, ну и как раз у меня есть чередование типов ребер слева-направо,
справа-налево. Это как раз не из порштани, а из поросочетания. Вот, поэтому в R+, это тоже только
насыщенные. Окей? Вот. Более того, я утверждаю, что размер вот этого множества не превосходит
размеры поросочетания. То есть, вершин вот там вот суммарно не больше, чем ребер в поросочетании.
Напоминаю, что здесь мы как бы вершинки меряем, количество вершин измеряем, а здесь количество ребер,
потому что M это у нас семейство ребер. Потому здесь мощность — это количество вершин,
здесь мощность — это количество ребер. Вот. А почему здесь вершин не больше, чем здесь ребер? Ну,
потому что я утверждаю, что каждое ребро поросочетания, каждое ребро поросочетания,
ну, точнее не так. Никакое ребро поросочетания не может выглядеть вот так. Потому что вот я уже
замечал, что ребер из R+, в L-, не бывает. Поэтому на самом деле любое ребро поросочетания мы нарисовали,
что не может идти из R+, в L+, не может идти из R-, в L+, значит оно либо вот такое, либо вот такое. То есть,
из R– в L– или из R++ в L+. Но главное, что это значит — смотрите, вот здесь вот какие-то насыщенные вершины,
и здесь какие-то насыщенные вершины. При этом нет никакого ребра поросочетания,
который бы соответствовал однонавременно двум вершинам отсюда и отсюда. Любое ребро поросочетания
то либо соответственно одно вершине отсюда, либо одно отсюда. Поэтому ребр должно быть хотя бы
столько, сколько вершин. Потому что вот они вершины, каждый из них соответствует хотя бы одно ребро,
при этом эти ребра все разные. То есть не бывает такого, что двум вершинам соответствует одно и
то же ребро про сочетание. То есть вот этим вершинам
соответствуют такие ребра, а этим вершинам соответствуют
такие ребра. Поэтому суммарный вершин не меньше, чем ребер.
Потому что каждой вершине соответствует сходящее
ребро. Либо такое, либо такое. Ну вот отсюда сразу следует
такое неравенство. Да, так как каждой вершине из
этого множества можно сопоставить уникальное ребро из поросочетания.
Уникальное ребро из M. Ну вот, и поскольку они уникальны,
то есть все попарно различны для всех разных вершинок,
то получается, что ребер хотя бы столько, сколько
вершин. Вот. Получилось у нас что?
Смотрите, у нас получилась вот эта штука, это вершинное
покрытие, но при этом его размер не больше, чем размер
максимального поросочетания. Не больше, чем размер M.
Но не бывает вершинных покрытий размера меньше, чем размер
поросочетания. Не бывает вершинных покрытий размера
меньше, чем размер M. Потому что если есть размер какой-то
поросочетания, да, вот есть поросочетания, давайте
вот так красиво нарисую. Вот есть какой-то поросочетания.
Тогда понятно, что чтобы покрыть все эти ребра, мне
нужно взять хотя бы по одной вершинке с каждого
ребра. Да, ну там, я должен взять хотя бы одну из них,
хотя бы одну из них, хотя бы одну из них, хотя бы
одну из них. Никак меньшим числом не обойтись, поскольку
все эти концы различны, поросочетания у нас все
концы попарно отличаются. Значит, мне нужно с каждого
ребра взять хотя бы одну вершинку. Значит, меньше
чем M получить нельзя. Получается, что любое покрытие, любое
вершинное покрытие по размеру хотя бы больше
либо равно, чем M. А мы получили здесь меньше либо равно.
Значит, это минимальное, и мы все доказали. Меньше
быть нельзя, здесь у нас значок меньше либо равно,
поэтому там на самом деле достигается равенства. R
плюс в объединении с L минусом, это в точности M по мощности.
Вот. Ну и меньше нельзя. Значит, это самое маленькое
вершинное покрытие. Минимальное вершинное покрытие. Все.
Мы получили утверждение теоремы, что есть вот такое
вот вершинное покрытие размеров точности, размер
просочетания, и меньше нельзя. Меньше нельзя получить
никакое вершинное покрытие, потому что вот замечания,
да, не бывает таких просто. А такое есть. Размеров
точности M. Вот. Поэтому мы с вами получили конструкцию
для нахождения минимального вершинного покрытия. Ну
и на халяву мы можем заметить, что R минус в объединении
с L плюс это автоматически максимально независимое
множество. Потому что одно всегда дополнение к другому,
дополнение к вершинному покрытию всегда независимое множество,
и наоборот. Значит, если мы одно минимизируем, то
автоматически максимизируется по размеру. Ну все. Теорему
доказали, алгоритм предъявили, и мы, получается, можем,
если у нас, если у нас M уже найдено, то мы можем вот
это вот все дело сделать всего лишь за линейное от
размера графа время, потому что по сути просто DFS. Я
ориентировал как-то ребра, потом запустил какой-то
обход и сказал, что там вот эти два куска это что-то,
а вот эти два куска это что-то другое. Ну там одно независимо
что другое вершины покрытие. Получается, за линейное
время я могу найти вот эти две штуки. Окей? Да. Напомню
в отличие от произвольного графа, где вот эту вот вещь
мы быстрее, чем за экспонент искать не умеем. Так, ну
хорошо. Тогда с этим закончили. Давайте переходить к потокам.
В следующей несколько лекций будет про потоки. Определение.
Значит, сетью я буду называть следующую штуку. Я буду
называть ориентированный граф G с двумя выделенными
различными вершинами. Которые я буду называть и сток и
сток. То есть, грубо говоря, начало и конец. Вот. А C это
какая-то целочисленная функция, выражающая пропускные
способности всех ребер. Функция из E в так. Ну давайте
вот так напишу. Целые неотрясательные числа, которые будут называться
пропускные способности ребер. Вот. Ну и смысл здесь
очень простой. Если у меня есть какой-то граф, есть выделенный
в нем начало и конец, есть на ребрах какие-то ограничения.
Сколько на каждом конкретном ребре может в единицу времени
течь водички. Соответственно, C от E для каждого ребра
это какое-то ограничение, сколько воды может протекать
по ребру. Ну давайте что-нибудь нарисую. Вот. На каждом ребре
напишем какое-нибудь число. Ну пусть будет вот так. Ну
что, вам ноль надо нарисовать где-нибудь? Давайте ноль. Капасти
все неотрясательные всегда. Капасти всегда неотрясательные.
Вот. Ну и нам нужно переправить как можно больше водички
из S в T. Как это можно здесь сделать? Можно ли три единицы
здесь делать? Да, вроде на халяву. Можно вот здесь
вот пустить единичку по вот этому пути и вот здесь
вот двоечку. Нет, нельзя двоечку, да? Ну вот так вот.
Ну как-нибудь можно короче, ну вроде видно. Сейчас давайте
нарисую три пути просто. Такой вот путь. Такой вот путь.
Нарисовался примерно на свою голову. А? Тип того, да. Ну ноль
значит, что мы по факту по нему ничего пускать не можем.
Но нам такие ребра будут на самом деле нужны когда-то. Вот.
Значит я нарисовал три пути. Оранжевый, красный и синий. Если по каждому из них
пустить единичку потока, то мы суммарно передали из S в T три единицы и при этом нигде не нарушили
ограничений. Да, вот здесь вот максимум. Ну здесь течет вообще единица потока,
которая не больше чем два. Здесь две единички как раз это ребро мы целиком насытили. Его
больше не можем использовать. Здесь течет единичка из синий. Ну и так далее. Вот это
вот ребро еще тоже насыщенное. Один из одного. Вот. Ну и можно бдиться очень легко, что это
максимальный поток. Просто потому что из S мы больше ничего выпустить не можем. Да,
здесь суммарное ограничение будет три. Один плюс два. Ну вот как раз три единицы я выпустил. Больше
понятно. Больше нельзя. Вот. Ну и задача это найти как раз тот самый максимальный поток. То есть как
можно больше водички успеть передать из S в T за единицу времени. За у нас будет лучший алгоритм
ЗВ квадрат Е. Ну такое на самом деле. Но оно на самом деле летает, потому что эти симптотики,
они только прям очень теоретически, чтобы оно реально столько работало. Граф должен быть
очень специфический, но такое не достигается на практике. Обычно там сильно лучше будет.
Да. Пока оно, пока не нужно, пока можно. Потом, потом поймем зачем нужно. Вот. Так, что надо дальше
сказать. Да. Зачем нужны ребра capacity 0? Я буду говорить по-русски capacity от слова собственно
capacity. Потому что пропускные способности тяжело мне выговорить, а capacity довольно легко. Так вот.
Мы на самом деле можем считать, что те ребра, которых нет, имеют capacity 0. Ну потому что как
мы видим, вот эта ребра веса 0, она абсолютно бесполезна. Мы все равно по нему ничего передавать
не можем. И как бы что оно есть, что его нет, абсолютно ни на что не влияет. Поэтому если что,
я могу считать, что между всеми вершинами, где нет ребра, на самом деле есть ребро capacity 0. И
более того, даже вот такие обратные ребра будут с capacity 0. Если ребро из У в В, а из В в У нет,
то можно сделать обратное с capacity 0. Вот. И нам это на самом деле будет нужно. Давайте как бы
виртуально проводить все, вообще все ребра в этом графе попарно, и там где нормального ребра не было,
будем считать, что capacity равно нулю. Так. Ну давайте, значит, определение тогда. Дадим,
что такое поток. Ну пусть вот у нас есть какая-то сеть. Тогда функция f из В квадрат в Z называется
потоком, если одновременно выполняются три условия. Во-первых, самое естественное условие,
самое простое, это что поток всегда не большим capacity. Для любой пары у В, f у В не больше,
чем c у В, где c у В это capacity на ребре у В. А если ребра нет, то оно автоматически считается 0.
Давайте это пропишу, что если ребра нет, то считаем, что c равно нулю. Да, все может быть.
Второе, а второе антисимметричность, свойство антисимметричности на любом
ребре, точнее для любой пары вершин, f в одном направлении равно минус f в другом направлении.
На счет называется антисимметричность. Тип того, да. То есть как бы если вы пустили из У в В
единичку потока, то это то же самое, что вы из В в У заняли единичку потока. То есть если один
игрок отдает другому единичку, то второй должен первому единичку. Вот и третье,
свойство сохранения потока говорит о следующем, что если мы выберем любую вершину, отличную от
s и t, то для нее сумма всех исходящих ребер, так вот так придется написать, равна нулю, точнее
сумму всех исходящих потоков. Это называется свойство сохранения потока. Свойство сохранения
потока. Вот. Значит по смыслу, по смыслу это значит, что у нас поток в вершинах не задерживается. То
есть не может быть такого, что вершину притекло больше, чем вытекло или наоборот вытекло больше,
чем притекло. То есть если есть какая-то вершинка В, в нее сколько-то потока притекло, сколько-то
вытекло. Вот не нужно, чтобы суммарно вот здесь было равно то, чему вот здесь. Это как раз обеспечено
за счет антсимметричности и третьего свойства, потому что когда какой-то поток вот здесь вот втек,
представьте там, не знаю, x, y, z. Вот. А здесь выйти какой-нибудь a, b, вот эти величины потоков.
Тогда на вот этих вот обратных ребрах справа налево по антсимметричности будет написан
противоположный поток. Вот здесь будет минус a, здесь будет минус b. Ну и я как бы хотел бы
написать равенство, что x плюс y плюс z равно a плюс b. Но это то же самое, что я написал вот там,
что x плюс y плюс z минус a минус b равно нулю. Потому что x плюс y плюс z это как бы нормальные
втекающие, а минус a минус b это ну как бы втекающее, но со знаком минус. Ну от того,
что их перенес сюда, не раз сохранилось таким же, как надо. Поэтому третье свойство, как раз
смысл ровно такой, что сколько втекло, столько и вытекло. Вот эта вот сумма входящих равна сумме
исходящих. Просто за счет антсимметричности у меня появляются вот эти вот противоположные
ребра, противоположные потоки, ведущие обратно в В, но они будут с противоположным знаком и как
раз здесь встутся. То есть это одно и то же равенство получилось. Потому что для stt это очевидно
не выполняется. Скажем вот здесь вот для вершинки s. Но для вершинки s смотрите, у нас есть одно
ребро с потоком единица, одно ребро с потоком 2 и больше никаких ребер исходящих здесь нету из нее.
То же самое для t. Здесь входит двойка потока, здесь входит единичка потока. То есть отсюда как бы
вытекло 3, а сюда как бы втекло 3. Ну и это соответствует тому, что мы хотим. У нас как бы тут,
не знаю, есть какая-то нефтяная скважина, которая качает нефть и передает ее дальше. А здесь,
наоборот, какой-нибудь склад, куда это нефть переливается. Поэтому отсюда она как бы появляется
неоткуда, а здесь она исчезает никуда. А по дороге она как раз нигде не накапливается. Вот.
Значит, вот такой поток. Ау. Не слышу. Дальше. Следующее определение, это остаточная сеть.
Ж с индексом f. То есть если у меня была какая-то сеть, ж и поток f. Значит, тогда я определяю для
каждой пары вершин, я определяю остаточную пропускную способность, как просто сколько
дополнительным потоком можно перебру пустить. То есть это сув минус фув. Сколько можно было
вообще, минус сколько я уже пропустил. Очень известная штука. Называется остаточная пропускная
способность. Остаточная пропускная способность. Все. То есть мы вот так определяем остаточные
capacity, сколько дополнительно можно еще пропустить по ребру. Но вот здесь, в остаточной сети,
мы давайте, значит, я скажу вот здесь вот. Мы удаляем ребра нулевой capacity. Удаляем
ребра нулевой пропускной способности. Нулевой capacity. То есть мы понимаем, что ребра нулевой
capacity, по ним все равно поток не течет, и вот здесь вот мне удобно будет их прям насильно
исключить из графа. Тогда будет выполняться следующее утверждение, очень удобное, что поток
максимален, если и только если вот в этой остаточной сети относительно этого потока нет никакого
пути из s в t. То есть поток f максимален, если и только если в его остаточной сети нет пути из s в t.
Вот. В такой постановке максимальность потока это то же самое, что отсутствие
какого-либо пути из s в t в остаточной сети g f. Ну, потому что понятно, если какой-то
остаточный путь есть, если есть путь вот здесь вот, g f, какой-нибудь вот такой вот путь,
это значит, что на всех этих ребрах capacity положительная, да, раз capacity всегда это
понятное дело, не отрицательная величина, потому что поток всегда не большим capacity,
значит это разность всегда не отрицательная, и при этом нулевые capacity мы выкинули. Значит,
здесь все capacity положительны, все остаточные capacity положительны. Значит, если я выберу просто из
них минимальное, то я по этому ну или там просто единичку возьму, то я по этому пути могу протокнуть
единицу потока, тем самым увеличу весь поток, а значит изначально не максимальный. Вот. Ну,
в обратную сторону мы докажем чуть позже. Пока вот как бы главный пафос в том, что,
ну во многом схоже с предыдущей лекцией, максимальность достигается в отсутствие каких-то
увеличивших путей. Ну, ну как бы, ну да, я не определил, но величина потока, давайте,
давайте сформализуем тоже все это, давайте. Значит, величина потока это просто сколько из
s вытекает. Модуль f это сколько течет водички из s. Вот. Ну и поток максимальный, если вот эта
штука максимальна среди всех потоков. Максимальный поток, это соответственно нам
нужно максимизировать значение потока. Так, еду дальше. Значит, смотрите, чтобы нам доказать вот
это утверждение, да, критерии максимальности потока, мне нужно будет вести еще несколько
определений и доказать их там по циклу. То есть, чтобы вот эти два доказать, нужно вести еще третье
эквивалентное к ним свойство и потом как бы с его помощью доказать эквивалентность первых двух.
Значит, определение пусть g это сеть, значит, тогда пара st называется разрезом, если,
если выполняется следующее свойство. s-маленькое лежит в s-большом, t-маленькое лежит в t-большом,
и их дизинктное объединение равно множеству всех вершин. Вот. То есть, мне нужно все вершинки
разбить на две группы, s-большое, t-большое, такие, что s-маленькое в s-большом, t-маленькое в t-большом,
и они как раз покрывают все вершины по одному разу. То есть, любая вершина либо здесь, либо здесь.
Значит, дальше величиной потока, sorry, разреза, величина разреза st. Это следующая сумма. Сумма
по всем u из s, v из t. Capacity u, v. То есть, если есть у меня разбиение моих вершин на два множества,
s-большое, t-большое, то величина этого разреза это просто сумма всех вот этих
capacities слева направо. Ну, из st точнее. Вот эти все capacities складываю, получаю величину разреза.
Вот. И третье. Величина потока через разрез. Величина потока f через разрез st. Это следующая
величина. Сумма опять-таки по всем u из s, v из t. Величины потока слева направо, f, v. То есть,
та же самая сумма, только мы берем не capacity, а потоки. Вот. Например, вот на этом рисуночке я
уже на самом деле нарисовал какой-то разрез. Вот он очень простой. s-большое это множество из
одной вершины s, а t соответственно все остальное. t-большое это все остальное. Тогда вот на этом
рисунке у меня получилось capacity этого разреза, величина этого разреза 3, потому что вот всего два
ребра пересекают наш разрез. 1 и 2. А в сумме будет 3. Ну и на самом деле поток тоже здесь суммарно
исходящий равен тройке. Вот здесь единичка потока и здесь два единички потока. Тоже суммарно тройка
получилась. Вот. Ну давайте сначала следующее. Давайте утверждение это напишу. Утверждение
величина потока через разрез равна величине разреза. Вот и потока. Извините, заговариваюсь.
То есть вот эта сумма, которую здесь определил, это на самом деле то же самое, что вот это. То есть
вот по факту я утверждаю равен с вот этих двух сумм. Доказательства. Давайте напишем, что такое FST.
Я хочу переписать это вот так. Вот. Ну это вроде понятно. То есть здесь у меня ушко бегает по
вершинам из S, вешка бегает по вершинам из T. Давайте я сначала разрешу вешке бегать по всем
вершинам, а потом вычту ту сумму, которая получается, если V бегает по S. За счет того,
что S и T в объединении дают в точности все V, то у меня вот здесь вот в этой разности как раз
учтутся только нужные слагаемые. Дальше. Я утверждаю, что вот это ноль, потому что здесь каждый
ребро между вершинами будет учтено два раза. Значит, давайте напишем, что такое FSS. Это сумма
по U из S, V из S, FUV. Значит, это, ну давайте напишу так, давайте формально напишем,
сумма по всем U меньше V, U из S, V из S, FUV плюс FVU, и плюс там будут слагаемые, когда U и V
одинаковые. Давайте напишу X из S, FXX. Ну вот, на самом деле F для любой пары множеств, множество
запятая множество, эта сумма вот такая. Просто когда я беру одну вершину из первого множества,
другую из второго и складываю все такие потоки. Если нет ребра, то мы считаем, что там есть ребро
capacity 0. Ну значит, на самом деле, не обязательно, но обычно да. Например, если между вершинами есть
ребро в одну из двух сторон и там течет какой-то поток, единица, то по обратному ребру на самом
деле что-то поток и минус единица, даже несмотря на то, что его нет. Так, я ответил на ваш вопрос.
Ну, на самом деле все очень просто. Смотрите, я определяю для любых множеств A и B. F от A-B это
сумма по A из A и B из B. F-A-B. Поэтому, когда я здесь пишу S-T, у меня одна переменная бегает по S,
а другая по T. Я отражаю, что вот эта сумма, это же самое, что если я первую перемену фиксирую по S,
а вторую сначала она бегает по всему V, но потом я вычитаю все, когда она бегает по S. Тогда как раз
я сначала беру слишком много, но все ненужное потом вычитаю. Вот я хочу доказать, что это равно 0.
Вот это вот слагаемое равно 0. Я сейчас это доказываю. Так вот, почему FSS равно 0? FSS это сумма
вот такая, просто по определению. Сумма по всем вершинам U из S, V из S. F-U-V. Значит, дальше все
слагаемые я разбиваю на группы. Если U и V различные вершины, то я их разбиваю вот в такие два слагаемые.
F-U-V и F-V-U. То есть в две стороны. И последняя группа слагаемых, это когда U и V одинаковые. Я их
обзывал за X. Ну все, а мы знаем по антисимметричности, что вот это вот 0. На что всегда F-U-V плюс F-V-U это 0.
Вот оно написано. Они противоположные. Потоки в две стороны противоположные. Но эта штука тоже равна 0.
Собственно, тоже из-за антисимметричности, потому что если я вот здесь вот напишу вместо U и VX, у меня
получится F-X-X равно минус F-X-X. Значит, он равен 0. F-X-X. OK. Вот. Все. И из-за антисимметричности у меня
получается все слагаемые здесь нулевые. Значит, вот эта штука равна 0 просто. Так, едем дальше. Зачем
мы это сделали? Едем дальше. Мы показали, что F-S-T это то же самое, что F-S-V. Потому что эта штука равна 0.
Дальше. Я в S-большом выделю отдельно вершинку S-маленькая и соответственно все остальное.
S-большое без S-маленького. Опять-таки это очевидно, что вот здесь выполняется вот это равенство,
потому что в чем отличие? Здесь я первой переменной U разрешал бегать по всему S,
так я просто возьму эту сумму, расщеплю на две суммы. В первой U равна S, во второй U не равна S.
Но бегает по всему S-большому. Вот. Значит, дальше. Смотрите, это в точности величина потока по
определению. Потому что величина потока это как раз сумма всех F-S-V. Вот она, в точности вот
эта вот вещь. Так, ну а и это хотелось бы показать, что это равно 0. Значит, почему F-S без S-V, почему эта
штука равна 0? Давайте посмотрим. Значит, на самом деле сумма по всем U из S без S-маленького,
сумма по всем V из V-большого F-U-V. Ну извините, я знаю, что вот это вот всегда 0. Из-за третьего
свойства. Профит. Конечно, вот оно. У нас же S-T разрез. Вот. Поэтому S-маленькое здесь,
T-маленькое здесь. Все, поэтому смотрите, когда у меня U бегает по S без S, у меня U одновременно
не S и не T. Потому что оно лежит в S-большом, значит, там точно T не лежит, потому что T-маленькое в
F-T-большом. Ну и S-маленькое тоже выкинул. Поэтому все вот эти вот, ну здесь у меня поменял название,
короче, переменной, но U бегает по всем вот этим хорошим вершинкам, V-большое без S и T,
а V бегает просто по всем вершинам. И эта штука равна 0 в точности по третьему свойству. Все.
Поэтому это все тоже 0. Значит, мы доказали, что F-S-T равно величине потока плюс 0. Значит,
просто величина потока. Так, ну вроде сейчас будет перерыв, так что давайте 5 минут перерыв,
потом продолжаем. Стерема Форда Фалкерсона. Это вот то самое обобщение, утверждение о том,
что поток максимален, если только, если в остаточности нет пути. Так вот, следующие
три условия эквивалентные. Следующие три условия эквивалентные. Первое, F это максимальный поток,
то есть его величина максимальна среди всех потоков. Да, величина потока максимальна среди
всех потоков. Второе, то самое слово про остаточную сеть. GF нет путей из S в T. Нет
путей из S в T. И третье, величина F равна величине какого-то разреза. Существует разрез S в T такой,
что величина F равна величине разреза S в T. Вот это вот достаточно для того, чтобы поток был максимальным.
Доказайся, ну давайте по кругу просто, из 1 в 2. На самом деле из 1 в 2 я уже доказал,
потому что если поток максимален, но при этом есть какой-то путь в остаточной сети,
то я могу по нему протолкнуть единичку потока. Поток увеличится, значит исходный был мне
максимальный. Если F максимальный, а в GF есть путь, то F можно увеличить.
Можно просто протолкнуть единичку потока по тому самом пути. Поток, очевидно, увеличится на ту
самую единичку. И значит исходный поток максимальным быть не мог. Дальше из 2 в 3. Если нет пути из S в T в
остаточной сети, то есть разрез, равный по величине потоку. Ну раз в этом письмаре существует,
давайте его конструктивно построим. Я скажу, что S большое – это все вершины,
достижимые из S маленького в нашей остаточной сети. Достижимые из S маленького в нашей остаточной
сети GF. Ну, соответственно, T – это все остальное. Значит, понятно, что это разрез. Ну, поскольку
выполняются все необходимые свойства, S маленькое в S большом, T маленькое, очевидно,
в T большом, потому что если бы T маленькое было в S большом, то у меня был бы путь. Ну, а поскольку
она недостижима, то обязательно T маленькое в T большом. Ну и из вот этого определения очевидно,
что их объединение дизюнктно дает в остаточности V. Я хочу доказать, что величина этого конкретного
разреза равна величине потока. Вот у меня даже нарисован какой-то разрез.
Смотрите, давайте посмотрим на все ребра, ведущие из S большого в T большое. Все эти ребра имеют
нулевую капасти в остаточной сети, потому что на самом деле в остаточной сети нет ни одного
такого ребра, поскольку вот где-то здесь была S маленькая, это все достижимые, это все недостижимые
из S маленького. Значит, на самом деле таких ребров слева направо, но их как бы нет, в остаточной
сети их нету. А это в точности означает, что у них нулевое капасти. Да, потому что мы удаляем,
мы не проводим в остаточности в точности ребра, имеющие нулевую капасти. Поэтому для любой пары
U из S, V из T мы на самом деле имеем, давайте напишем, что если U из S, V из T, то мы на самом
деле имеем, что остаточная капасти слева направо равно нулю, потому что мы как раз только такие
ребра не проводим в GF. А что это означает? Что такое CF? Это на самом деле обычная капасти,
минус поток. Получается, что для любого ребра U, V слева направо мы имеем равное значение
capacity и потока. Вот. Ну все, а дальше получается, что если мы это просуммируем, то мы получим
величину разреза. Если мы это просуммируем, мы получим величину потока через разрез, но она
по утверждению равна просто величине потока. Вот это? Ну потому что, смотрите, давайте рассмотрим
просто любую вершину отсюда, любую вершину отсюда. Между ними, ну как бы по договоренности,
есть ребро. Если ребро нет, то оно имеет нулевую капасти. Вот я в этом графе остаточном GF,
остаточной сети, рассматриваю все такие ребра. Если там есть ребро положительной capacity,
то это бред, потому что левые вершины достижены, правые не достижены. Значит ребер слева направо,
как бы положительной capacity быть не может. Потому что иначе, если бы оно было, то я мог бы еще вот
эту вершину посетить. Значит не все нулевой capacity, значит вот. Все, я теперь это суммирую по всем
УССВСТ. Получаю, слева получаю величину разреза, как сумму по всем УССВСТ СУВ. Здесь аналогичная
сумма потоков. Это по определению в точности равно FST, и это по утверждению равно величине потока.
Вот он. Профит. Мы предъявили некий конкретный разрез, величина которого равна величине потока.
Вот оно. Доказали. Так, ну теперь из 3 в 1.
Из 3 в 1. Если поток равен разрезу, то поток максимальный. Здесь на самом деле нужно сделать
следующее простое наблюдение. Давайте напишу его словами. Величина любого потока не превосходит
величины любого разреза. По следующим опять же очень простым соображением. Значит поток равен
потоку через разрез равен сумме нашей любимой по УССВСТ СУВ. Дальше. Поток из УВ всегда ограничен
на капасти из УВ. Вот это первое свойство, F всегда не большим С. Поэтому здесь в сумме я могу все
слагаемые заменить сверху на СУВ. Получится сумма по УССВСТ СУВ. Но это в точности просто
определение величины разреза. Поэтому любой поток не больше, чем любой разрез, собственно то,
что мне здесь написано. Величина любого потока не превосходит величины любого разреза. Значит,
давайте я для удобства вот так визуализирую. Если я нарисую ось, там, вещественную или целочисленную,
то у меня, смотрите, и давайте на нее нанесу все возможные величины потока и все возможные
величины разреза. Тогда у меня потоки будут где-то вот здесь вот, а разрезы где-то вот здесь вот.
Ну поскольку любой поток меньше либо равен любого разреза, то у меня как бы вот здесь вот все потоки
F, величины F, а здесь величины всех разрезов ССТ. Любой отсюда не больше любого отсюда, поэтому они
как бы так отделимы. Вот эти все слева, эти все справа. Но если вдруг оказалось, смотрите,
что он говорит третий пункт, что какой-то поток равен какому-то разрезу, тогда на самом деле вот
эти вот множества пересекаются в единственной точке. Вот здесь есть какая-то засечка, которая
одновременно и является величиной какого-то F и какого-то разреза. Ну значит, это максимальный
поток и при этом одновременный минимальный разрез. Потому что, если они пересекаются,
то это экстремальный элемент здесь и экстремальный элемент, короче, в обоих множествах, поэтому это
одновременно максимальный поток и минимальный разрез. Вот, значит, если F равно какому-то разрезу,
то F это максимальный поток, а ST это минимальный разрез. Вот и все.
Вопросик есть?
Ну хорошо. Да. Вот это? Вот это. Ну как? Понятно, что F всегда не больше чем C. Нет, не стало. У нас
всегда выполняется. У нас F всегда не больше чем C. Оттого, что F отрицательно, смотрите, это вы вот
опять к этой картинке. Если у меня было какое-то нормальное ребро у В, не знаю, с капастию,
например, два, по которому я опустил дницу потока. Что это значит? Значит, что я как бы на самом деле
ввожу обратное ребро с нулевой капаститию и потоком минус один, но минус один уже не больше чем ноль.
Вот и все. У нас просто определение потока такое, что вот здесь всегда меньше чем C. А
остаточная капастити здесь единица, потому что если я вычту минус 1 из нуля, капастити минус
поток, у меня получится единица. Поэтому в остаточной сети у меня будет вот здесь вот
ребро один и здесь ребро один. Потому что вот это вот ребро на самом деле имеет остаточную
капастити, значит, что я могу отменить вот здесь единицу потока. Могу направить ее из
конца в начало, тем самым я как бы отменяю вот эту единичку потока, которую пустил сначала в конец.
Поэтому это просто свойство потока, что F не больше. Хорошо. Ну и отсюда, собственно,
получаем простейший алгоритм Форда Фалкерсона, который просто делает следующее. Пока в GF есть
какой-то путь из S в T, пусти по нему единичку потока, ну или там сколько влезет потока и
перестрой сети. Так делаем пока, пока есть, собственно, путь в остаточной сети.
Пока в GF есть путь из S в T, ну давайте я скажу следующее, что пусть X это минимальная из
остаточных капастий на этом пути, минимальная из CF на этом пути. Дальше мы, собственно,
по этому пути проталкиваем X потока на этом пути. Давайте добавляем X единиц потока.
Вот. Ну и всё, перестраиваем GF. Перестроить GF.
Пример. Давайте рассмотрим такую сеть. Здесь все капасти единичные. Чтобы не загружать картинку,
все капасти единичные. Значит, как может работать алгоритм Форда Фалкерсона? Например, может
сработать так. Он берет, находит вот этот вот путь, проталкивает по нему единицу потока. Что
будет после этого? После проталкивания единички потока у меня вот эти все ребра остаются,
но смотрите, у меня же на самом деле всегда вот так вот мысленно, надо не забывать,
что всегда есть обратные ребра с нулевой капастью. В момент, когда я проталкиваю обычный поток по
нормальному ребру, у меня на обратном ребре остается поток минус один, так? Потому что если
здесь один, то здесь минус один по антисимметричности. И как я вот здесь пытался объяснить, у меня
получается, что возникает обратный ребро с единичной капасти. Потому что если здесь
капасти ноль, а поток минус один, то их разность будет единица. Поэтому после проталкивания здесь
единицы потока у меня граф будет такой. Значит, вот есть S, вот есть T. Эти ребра будут вот такими
обратными, а здесь они останутся прямыми. Вот, и смысл этих ребров в том, что я могу как бы отменить
единицу потока, которую я опустил по этому ребру. То есть если надо, я мог бы как-нибудь использовав
это ребро, пуская по нему единицу потока, это то же самое, что я отменяю вот эту единицу,
которая течет слева направо. Вот, но здесь это мне не понадобится, ну просто формально граф вот так
перестроится. Потому что на самом деле мы путь какой-то ищем, путь из S в T, а путь из S в T это
всегда какой-то маршрут из S в T. И если мы как бы сложим все изменения, то на всех промежутных
вершинах у нас ничего не изменится, а из S начнет что-то вытекать, и в T начнет что-то втекать.
Поэтому сумма как раз увеличится на то, сколько мы пустили здесь. Ну это порисовать на самом деле
надо просто. Вот, значит дальше я могу найти такой путь, протолкнуть здесь еще одну единичку потока,
и получится, что я уже нашел, что за первый раз это вторая. После этого вновь то же самое,
у меня вот здесь возникает обратное ребро, капасти 1, здесь обратное ребро, капасти 1,
граф становится таким. Вот. Ну здесь уже видно, что из S в T никак попасть нельзя. Ну просто даже
из S нет ни одного исходящего ребра, поэтому мы нашли максимальный поток. Максимальный поток
очень простой, вот здесь вот надо пустить единичку потока, и здесь единичку. Так, это он мог работать
вот так, а мог работать чуть хуже, но тоже корректно. Ну что, мог взять и внезапно найти
такой вот путь. Вот такой. Я же никак не специфицирую, какой именно мы путь находим,
просто какой-то, нам останется в стих какой-нибудь путь. Вот он мог найти вот такой вот путь. Это не
страшно, мы пускаем здесь единичку потока, давайте построим, как теперь выглядит наша сеть. Это ребро
само по себе удаляется, потому что на нем остается нулевая капазиция, но возникает обратное. Это остается,
здесь то же самое, ребро сверху вниз исчезает, потому что оно насытилось, там стало, ну как бы там
нельзя больше ничего пустить, но возникает снизу вверх, потому что на нем 0 минус минус 1 это единица.
Вот, ну здесь остается, и это тоже переориентируется справа налево.
Теперь смотрите, вот тут как раз отмена потока происходит. Теперь в этой сети опять есть путь
из SFT, вот он. Использую вот это вот обратное ребро, которое у меня появилось из-за того,
что я, ну по факту на самом деле я отменяю вот здесь единичку потока. Да, у меня есть путь из
SFT, задействующий вот это центральное ребро, я могу пустить по нему единицу потока, и остаточная сеть
будет, ну видимо, такая же. И по факту, что произошло, я пустил здесь единицу потока, и здесь единицу
потока. Центральная на самом деле съелась сама собой, потому что сверху вниз и снизу вверх я
пустил по единичке, они сами уничтожились, и получился такой же поток, у меня на самом деле
единица течет вот здесь, единица течет вот здесь. Вот такой пример работы, когда какие-то,
грубо говоря, ошибки, которые допускает наш алгоритм, используют какие-то неправильные
ребра, он потом сам их может пофиксить, отменив поток по неправильному ребру. Вот в чем мораль
вот этого ребра, что даже если я его как бы напрасно использую, я могу его отменить и добавить
единичку там, где надо. Вот. Так, ну еще примерчик. Давайте то же самое, только величины побольше,
короче, капасти большие я нарисую здесь. Вот, представьте, что здесь капальство что-то типа 10
9, а здесь единица. Ну понятно, умный алгоритм бы сказал следующее, надо пустить вот здесь вот 10
9 потока, здесь 10 9 потока, мы найдем максимальный. Конечно, больше чем 2 на 10 9 пустить нельзя. Но
если наш алгоритм глупенький, ну и как-нибудь у него неправильные ребра упорядочены, и он делает
какой-то DFS такой странный, он может на самом деле делать следующее, он вот здесь отпускает единичку
потока, потом это ребро инвертирует. Пускать вот здесь единичку потока, опять ребро инвертирует,
так делать 2 на 10 9 раз. Поэтому на самом деле лучше, что можем сказать про симптотику,
это что-то типа f умножить на e, где f это собственно та самая величина максимального потока,
но e это, грубо говоря, то, за сколько работает DFS, потому что по факту внутри мне нужен только
DFS, чтобы найти какой-то путь из SFT. Вот, и в случае, когда у вас бывают большие capacity,
и соответственно, бывает большой поток, вам возможно придется делать очень много
итерации в вашем алгоритме, и это ну как бы не фиксится. То есть если мы говорим, что наш путь
произвольным образом выбирается, то вот пожалуйста пример, где он может работать 2 на 10 9 итерации,
хотя граф очень маленький. Вот, так это понятно пока? Ну ладно, тогда давайте это фиксить как-то.
Да, тут возникают, конечно, возникают обратные, которые постепенно наращивают capacity. Сначала 1,
потом 2, потом 3. Да, ну потому что когда я здесь пустил единичку потока, у меня появилась обратная
1, потому что я умею отменять эту единицу потока. Потом, когда пустил вторую единицу потока,
здесь возникло на самом деле не еще одно, а просто увеличивается capacity здесь, ну и так далее. Поэтому
они тоже конечно возникают, но они все равно не используются. И главное, что вот здесь вот
переключается это ребро. Вот, хорошо. Так вот как это можно пофиксить? Как можно избавиться от
зависимости от лишней потока? Очень просто. Называется алгоритм Эдман Сакарпа. И он отличается
от алгоритма Форда Фалгрессона только тем, что вместо произвольного пути мы выбираем кратчайший
путь почт лури обер. В GF всегда выбираем кратчайший путь, кратчайший почт лури обер.
Еще проще, мы заменяем DFS на BFS. Если раньше я искал какой-нибудь путь с помощью DFS,
каким-нибудь обходом DFS, например, то теперь вместо этого я нахожу кратчайший путь с помощью
BFS и по нему пускаю столько поток, сколько могу. И тогда оказывается, что здесь асимптотика
сразу улучшается до вот такой. Ну, если это можно назвать улучшением. Но асимптотика будет вот
такая. Мы по крайней мере избавляемся от зависимости от капастей. Давайте попробуем доказать,
почему асимптотика будет такая. Понятное дело, корректность этого алгоритма очевидна,
потому что это по факту модифицированный Форт Фалкерсон, который просто пока есть поток в GF,
пока есть путь в GF, пускает по нему что-нибудь. Понятно, что он корректен, поэтому в конце
обязательно будет максимальный поток. Почему он работает за столько? То есть единственный вопрос
это асимптотика. Почему мы работаем за столько? Но давайте попробовать доказывать. Для этого
надо будет постараться. Шлема первая, пусть F и F', это два последовательных потока в алгоритме
Эдманса Карпа. В алгоритме Эдманса Карпа. Понятно, он у нас работает итеративно. Каждый раз
восторженности находит в кратчайший путь и по нему пускает поток. Вот пусть сначала был F,
а после очередной итерации стал F'. Пусть D от V это кратчайшее расстояние в графе GF от S
до V, ну а D' это соответственно расстояние в графе GF' от S до V. Понятно, да, у нас Эдманс Карп
работает с расстояниями невзвешенными. Давайте вот определим D от V это расстояние в оснащенности
GF', D' это расстояние в оснащенности GF'. Вот тогда я утверждаю, что для любой вершины D от V не
больше, чем D' от V. То есть в процессе работы Эдманс Карпа расстояния только увеличиваются,
ну не строго увеличиваются. То есть либо остаются, либо остаются больше. Вот одну итерацию к следующей
у меня может произойти только возрастание. Доказательства пусть не так. То есть пусть есть
какие-то вершины, для которых это не нравится, в другую сторону достигается. То есть здесь будет
строго больше. D от V строго больше, чем D' от V. Тогда давайте выберем такую V, ну для которой верно отрицание
этого нашего неравенства, то есть D от V больше, чем D' от V. Для которой D' от V минимально возможно.
То есть, грубо говоря, смотрите, у меня есть, у меня возможно есть много вершин, для которых это
неравенство нарушается. Давайте из них всех, то есть из всех, для которых верно вот это, вот возьмем
то для которого D' от V минимально. Понятно, это может достигаться, вот это вот неравенство может
достигаться на многих вершинах, но из них всех я возьму такое, что дж-стрих минимально
возможен. Из всех таких выбираю вершину с минимальным дж-стрихом от v. Тогда, ну
давайте рассмотрим кратчайший путь от s до v в графе gf-стрих. Рассмотрим
кратчайший путь от s до v в gf-стрих. Вот s, вот v, это было все в графе gf-стрих.
Ну, во-первых, я утверждаю, что v точно не s, потому что для вершинки s у меня
всегда d от s равно d-стрих от s равно 0. Понятно, расстояние от вершины до
само себя это 0, поэтому для вершины s это неравенство не выполняется. Значит,
она точно не участвует вот в том множестве v-ш, которые я выбираю, поэтому v это
точно не s. Значит, на пути от s до v есть какая-то предыдущая вершина u, раз это
различные вершины, то есть какая-то предыдущая u, которая лежит на пути от
s до v. Давайте ее рассмотрим. Так, значит, что про нее мы можем сказать? Смотрите,
поскольку она лежит на кратчайшем пути от s до v, я смело могу написать такое
равенство. d-стрих от u плюс 1 равно d-стрих от v. Ну, это почти очевидно, вот он кратчайший
путь от s до v, это в частности кратчайший путь от s до u плюс одно ребро. Значит,
d-стрих от u плюс 1 равно d-стрих от v. Просто я взял кратчайший путь до u, добавил одно
ребро, получил кратчайший путь до v. Это первое наблюдение. Второе наблюдение, что для u,
вот из этого следует, что для u это выполняться не может. То есть для u обязательно выполняется
вот такое неравенство. Потому что иначе, если бы для u выполнялась такое же неравенство,
как для v, то из вот этого следовало бы, что d-стрих от u меньше, чем d-стрих от v. Значит,
раз это меньше, и это выполняется, то я вот здесь v неправильно определил, мне надо было бы
брать вместо v u. Ну, поскольку я взял v правильно, то вот этого неравенства обязано выполняться,
иначе я должен был бы взять другую вершину в качестве v. Так как d-стрих от v минимально,
среди вершин с d-стрих от v меньше d от v. Вот. Хорошо, вот есть такие два наблюдения. Теперь
давайте зададимся вопросом. Что ребро uv делает в графе gf-стрих? Откуда на том взялось? Откуда
ребро uv присутствует в графе gf-стрих. Значит, ответ первый, вариант первый. Оно было в предыдущем
графе, в графе gf, и оно осталось после пропускания потока. Ну, то есть как бы вот я смотрю на
конкретную пару uv. Вот я знаю, что в этом графе gf-стрих тут есть ребро из uv. Вот вопрос, а было ли
оно в предыдущем графе? Было ли оно в gf? Два варианта ответа, либо да, либо нет. Давайте первый
случай, когда оно было ребро. uv было в графе gf. То есть в графе gf тоже есть ребро из uv. Точно
также как в графе gf-стрих. Что это значит? Это значит, например, что d от v не больше d от u
плюс 1. Ну, вроде понятно. Потому что если есть какое-то конкретное ребро, то дойти до конца этого
ребра можно точно используя не больше, чем вот столько вот столько ребер. Я могу сначала дойти
до u, а потом добавить одно ребро в конец. Здесь я пишу обычные d, потому что d это расстояние в gf,
не в gf-стрих, а в gf. Вот. Ну и теперь я утверждаю, что вот эти вот все неравенства, которые я написал,
на самом деле ведут к противоречию. Давайте попробуем это продолжить. Что такое d от u
плюс 1? Это не больше, чем d-стрих от u плюс 1, а d-стрих от u плюс 1 это d-стрих от v. То есть отсюда
получилось, что d от v не больше, чем d-стрих от v противоречия. Потому что вот. Значит, используя все неравенства,
которые мы написали, мы пришли к противоречию, поэтому первый случай быть не может. Случай второй.
Случай второй. Ребра uv вот в предыдущей осадочности не было. Уv не было в gf. Что это значит?
Почему его не было в gf, но оно каким-то образом оказалось в gf-стрих? Скажите мне, пожалуйста,
откуда ребро могло появиться в осадочной сети. То есть его не было на предыдущем шаге, но теперь оно
есть в gf-стрих. Да, ребро появиться могло только если по обратному к нему пустили поток. То есть
вот uv не было в gf, значит было vu, и мы по vu пустили сколько-то потока, потому что только в этом
случае могло появиться обратное к нему ребро uv. Значит, чтобы uv появилось в gf-стрих, мы должны
были протолкнуть поток по обратному ребру. Мы должны были протолкнуть поток по vu. Значит,
ребро vu не просто было в графе gf, но еще и по нему мы пустили поток. Значит, это не просто какое-то
ребро в gf, но это какое-то ребро лежащее на кратчайшем пути из s в t. А раз так ребро лежащее на кратчайшем
пути лежащее на кратчайшем пути из s в t, то значит мы можем смело написать, что d от v плюс 1 равно du.
Еще раз, то есть это не абы какое ребро в gf, а такое ребро, по которому мы пустили поток,
значит это ребро на кратчайшем пути от s до t. Но раз это ребро на кратчайшем пути, то кратчайшее
станет до v, на единицу меньше кратчайшее станет до u. Поэтому вот такое такое равенство можно
писать. Ну а дальше я скажу, что опять какие-то противоречия будут. Давайте d от u напишем,
что это не больше d штриха от u. Дальше d штрих от u, это d штрих от v минус 1. Так,
сейчас я, наверное, как-нибудь получше нарисую, все. Давайте туда перейду.
Еще раз, у меня вот там вот написано, что d от u не больше d штрих от u. Дальше d штрих
от u равно d штрих от v минус 1, я верхнее этого равенства переношу единичку направо.
Так, ну собственно все, вот это мне нужно. Получается, смотрите, что, что d от v меньше
либо равно d штрих от v минус 2. А мы предполагали, что d от v больше, чем d штрих от v. Ну опять
противоречие. Да, d от v больше, чем d штрих от v. А вот оно, вот оно, и здесь единичку просто
перенес туда. Вот, не может число быть больше, чем другое, если оно не больше, чем оно минус 2.
Опять противоречие. Значит, ни один из случаев быть не может, поэтому наше исходное предположение
неверно, значит, мы все доказали. То есть вот это вот v вот с этим условием существовать не могла,
ну поэтому мы доказали то, что хотели. Так, окей. Хорошо, значит, тогда отсюда лемма вторая.
Лемма вторая. Значит, каждое ребро, увы, может насытиться, может насытиться не больше от v раз.
Ну что такое насытиться? Это когда ребро не было насыщенным, а стало насыщенным. То есть раньше
по нему тек поток меньше, чем его capacity, а после вот очередной итерации поток стал равен capacity,
то есть ребро насытилось, по нему течет максимально возможный поток. Так вот,
количество насыщений не превосходит от v. Для каждого конкретного ребра не больше, чем от v раз
он насыщается. Ну почему? Давайте вообще поймем, как какое-то ребро может насытиться несколько раз.
Это значит, что я вот взял очередную итерацию. Эта вот скарпа, наше ребро, увы, насытил. Вот там,
давайте рассмотрим первый раз, когда он насыщается. Вот какой-то конкретный раз мы пустили по этому пути
такой поток, что это ребро стало насыщенным. Дальше, чтобы оно стало насыщенным вновь,
мне нужно сначала его раз насытить, то есть сделать его ненасыщенным. Значит,
отменить поток по нему, то есть на самом деле пустить какой-то вот такой вот поток. То есть
на самом деле пустить поток по обратному ребру. После этого ребро, увы, опять появляется в нашей
сети, и я могу его вновь насытить. То есть чтобы насытить ребро еще раз, мне нужно сначала снять
с него какой-то поток и потом еще добить до максимального. То есть получается, что чтобы
насытить ув, насытить ув дважды, нужно сначала, нужно насытить его, потом пустить поток по обратному
ребру, потом опять его насытить. Давайте напишем, насытить ув, потом пустить поток пву,
потом опять насытить ув.
Но смотрите, насыщение ув происходит, когда я когда-то насытил ув, потом пустил поток по
обратному ребру, потом его опять насытил. Значит, в этот момент d от u плюс 1 это d от v, в этот
момент d штрих от v плюс 1 это d штрих от u, и в этот момент d2 штриха от u плюс 1 равно d2 штриха от v.
Ну потому что насыщение и проталкивание потока происходит только если это ребро лежит на
кратчажем пути от s до t, поэтому вот такие вот у меня получается равенства на расстояние от s.
Вот, ну смотрите, вот если здесь было какое-то d от u, значит здесь у меня d от u плюс 1, здесь хотя бы d от u
плюс 1, потому что я знаю, что по первой лемме между итерациями расстояние может только вырасти,
если здесь до v было такое расстояние, то здесь до v будет хотя бы такое расстояние, по первой
лемме у меня d только только возрастает, значит здесь хотя бы d от u плюс 2. Две минуты и заканчиваем,
сори. Значит, смотрите, получилось, что к моменту, когда вот эта вот вершина u может насытиться во
второй раз, у меня расстояние до нее выросло хотя бы на двойку. Если изначально было d от u при
первом насыщении, то ко второму насыщению d будет хотя бы d от u плюс 2. Вот по этим неравенствам,
потому что d всегда возрастает и при проходе по ребру обратно d еще раз выросло, получается,
что между двумя насыщениями d выросло хотя бы на два. Ну а сколько раз мы можем вот это d
увеличивать на два? Понятно, что d всегда не превосходит, скажем, числа вершин, числа вершин
минус 1 на самом деле. Ну и получается, что каждое насыщение соответствует увеличению d хотя бы
на два. Значит, насыщение на самом деле максимум v пополам. Значит, насыщение v соответствует
увеличению d от v, d от u хотя бы на два. Ну и при этом понятно, что d от u не больше,
чем v минус 1. Значит, насыщение не больше, чем, ну, примерно v минус 1 пополам. Но главное,
что это все от v. Что и требовалось. Вот. Ну все, таким образом, вторую лиму доказали,
а завершу давайте уже в следующий раз. Спасибо за внимание, извините, что задержал.
