сплей дерево это самобалансирующая бинарное дерево поиска давайте так теперь поставлю это
самобалансирующая
бинарное дерево поиска что подразумевается под самосбалансируем вообще деревом поиска
так так так сейчас это подключится а то немножко сбивает на самом деле звук подключения ну ладно
что подразумевается вообще под самосбалансированный дерево что ребят выключите микрофон если вы не
задаете вопрос пожалуйста очень сильно бьет их самосбалансированный самосбалансирующая дерево
поиска то есть оно будет менять свое состояние при любых операциях будь то даже просто поиск то
есть мы будем каждый раз изменять его состояние изменять то как оно выглядит изменять то что
находится в корне при помощи одной простой операции это так называемые ивристики ивристика
называется move to root давайте я напишу за счет ивристики
move to root что это означает это означает что каждый раз когда у нас приходит запрос на поиск вставку
или чего-то еще какого-либо элемента мы берем и специально переделываем дерево так чтобы оно
лежало в корне и мы могли получить ответ именно как раз с корня и вот этой ивристикой будет такая
за счет чего будет складываться такая ивристика ну представьте что у меня есть какое-то дерево
ну вот к примеру пример вот такое вот так ну здесь что-нибудь и вот здесь вот а в с д тут
ивристика переноса в корень нашего самого значения а который к примеру мы хотим найти
вот это вот значение будет выглядеть следующим образом мы с вами уже проходили очень много
всяких поворот и так далее и мы с вами получим как раз таки что мы хотим на вершину поставить
корень а наше дерево примет вид следующий вот и тут я то есть она развернется таким вот образом
хорошо ли это с точки зрения остальных вершин мало ли мы следующий будет запрос там к примеру
вершины и мы захотим ее уже поставить на корень возможно нехорошо но мы с вами покажем в конце
лекции о том что в действительности этого достаточно чтобы у нас все происходило как нам
необходимо вот для того чтобы это выглядело правильно и выглядело хорошо будет несколько
понятий но для того чтобы вообще первоначально уже с этим работать давайте просто еще раз
опишем того то как выглядит у нас узел и две дополнительные вещи введем чтобы
могли описать красиво код с плей дерева ну описание узла
ну я думаю ни для кого не секрет что описание узла выглядит примерно следующим образом что
у нас в ноде хранятся я пишу если что псевдо кодом на всякий случай я думаю вы к этому
уже привыкли но мало ли что вот в ноде у нас хранятся указатель налевую а вершинку указатель
на правой в ребенка то есть левый правый ребенок указатель на
родителя и само значение которое мы хотим что нас выполняет роль ключа роль ключа может быть все
что угодно но мы будем исходить из того что пока просто хранить какой-нибудь вот и две
вспомогательные функции которые мне понадобится в принципе чтобы очень часто не писать однообразный
вот мы с вами сделаем следующее что у нас будет установка родители для какой-то вершины просто
выглядящая следующим образом что если у меня тут есть ну да что же такой час
мы сюда передадим ребенка и предполагаем в родителя который мы хотим поставить и
здесь же будем выполнять ну то есть чисто с точки зрения того чтобы у нас код выглядел хорошо что
если у нас ребенок не является
ну то есть нулевым указателем то в этом случае мы скажем что у ребенка его родитель
это сам родитель который мы с вами передали вот и помимо этого нам еще понадобится чисто
вспомогательная вещь тоже это то что мы будем какой-то вершине к вершине будем назначать ее
родителем то есть мы назовем это кип пример от вершины какой-нибудь в в от слова вертекс если
что на всякий случай вот и здесь она просто будет вызывать внутри то что мы устанавливаем
для ее детей родителям то есть мы установим до левого ребенка и мы установим с вами для правого
ребенка тоже просто чтобы не было много повторяющихся вещей вот ну пока вроде бы все понятно здесь
ничего сложного нет ничего вопрос а вопроса я не слышу но ладно надеюсь мне его зададут тогда
что еще раз так еще раз какой вопрос
но видимо нет третий вопрос зачем нам устанавливать детей что он родитель ну вот зачем на функциях
потому что мы когда будем пересвязывать вершины вы увидите для чего это сделано то есть мы когда
будем кидать что-то в корень у нас будут два раздельных дерева для них нужно установить
будет родители ну это с точки зрения удобства реализации просто того чтобы вы понимали что
эти методы делают конечно можем писать отдельно ну то есть вообще не писать лучше разделять
просто в силу удобства и написание тогда понятно все что происходит вот и как вообще
работает с плей дерева с плей дерева это что что еще раз
окей как работает с плей дерева смотрите мы с вами с вами проходили в вл дереве что у нас есть так
называемый правый так называемый левый поворот вот который у нас с вами уже был и выглядел он
следующим образом у нас был с вами давайте я нарисую правый поворот
который делал следующее из вот такого вот
вот дерево
вот это а это б это с это там было по и ку и наоборот
правый поворот делал следующее он вершину ку делал на наш корень здесь у нас оставалось
дерево а а сюда переходила вершина где у нас здесь и сохранялся весь нам необходимый порядок это
был правый поворот помимо этого у нас еще был левый поворот
вот и левый поворот у нас заключался в следующем что если у нас есть вершина
у нее является правым сыном вершина ку здесь у нас есть под дерево а здесь у нас есть под
дерево б здесь у нас есть под дерево с то мы с вами получали следующее что у нас есть вершина ку
на нашем корне а здесь у нас получалось по которым как раз таки находились все необходимые нам от
деревья вот мы сами разбирали как это работает надеюсь здесь много пояснять этого не надо
то есть мы просто разворачивали с вами представьте следующее что у меня пришел запрос на сплей дерево
всегда стремится и всегда делает так чтобы наши вершины от которой запрос стало корнем чтобы
запрос заключался в следующем просто посмотреть значение ключа там в корне к примеру вот и для
того чтобы это работало а первый первое что нам необходимо это по факту как раз таки вот этот
вот поворот и называется он зиг вот то есть если мы с вами поворачиваем либо одну либо
просто правым поворотом либо левым поворотом это называется операция зиг и все зависит от
того просто является ли у нас там является ли у нас там вершина к примеру необходимая нам
слева или справа которую мы ищем и это первая операция которая нам будет необходимой здесь вот
я думаю ну описывается она достаточно просто мы с вами говорим что сюда передается по факту
эту вершину мы с вами передадим родителям и ребенка после чего определимся мою эту
функцию следующим образом у нас с вами есть grandparent дедушка который является там родителем
родителя вот после чего мы перепроверим если у нас если у нас нам необходимо переделать как раз
таки новых родителей поставить ой тщене нового ребенка для этого grandparent и в зависимости от того
являлся ли parent левым или правым сыном то есть вот это вот п являлась вот где-то она
левым или правым примерно здесь в зависимости от этого нам необходимо будет переподвесить данную
вершину ху и сказать что вот теперь она находится здесь это сделать достаточно просто мы сравниваем
с вами как раз таки нашу вершину то есть если она является левым ребенком на
то в этом случае мы с вами получим там например получается что
ребенком для этого выступает теперь в начале аналогично в другую сторону я думаю вы здесь
сможете написать ну то есть здесь сама суть в том что мы переподвесили нашу вершину после
чего нам необходимо взять и поменять местами наши вершины наши вершины по и кум друг с другом
а вот и для того чтобы это сделать ну необходимо написать плюс правый поворот правый поворот
или левый поворот
то есть мы должны переподвесить наши вершины но здесь все тоже достаточно просто я думаю вы
помните как они пишутся там всего было 3-4 строчки вот без фиксации какого-то родителей
понять как это выглядит внутри и после чего мы с вами могли можем здесь написать последнюю
оставшуюся строчку не несколько о том что нам нужно зафиксировать зафиксировать родителей
для зафиксировать родители для ребенка потому что он поменял свое место зафиксировать родителям
нашего родителя которого мы переподвесили вот и сказать что
например там сет перрент
вот получается мы должны теперь сказать что для нашего ребенка является родителем теперь
наш дедушка который был дедушкой вот и чтобы это произошло нам необходимо написать последнее
нам необходимо написать там последнюю функцию я думаю вы понимаете что она выглядит ровно как
сет перрент от получается чайл ты чайл и гранд вот то есть смотрите зиг это по факту именно тот
самый правый и левый поворот который у нас с вами были в овл дерево то есть мы просто берем и
поворачиваем наше дерево в зависимости от того как оно выглядело и с этим всем работаем это первое
что нам понадобится сама хитрость на самом деле вот вся суть типа вл дерево в том что кроме вот
этой операции зип используется еще две операции то есть когда мы будем с вами переподвешивать наши
вершины мы будем пытаться сократить наши дерева с точки зрения высоты то есть это выглядит не
совсем как та самая ивристика которая муф ту рут которая там была то есть мы к ней добавим еще
одно действие а еще одно действие будет заключаться в следующем мы с вами проходили большой левый поворот
и большой правый поворот здесь почти что будет аналогично смотрите что я хочу я хочу уменьшать
высоту дерева после каждого каждого его использования в принципе после каждого момента когда я беру
можно вопрос там вот на прошлом слайде был написано и гран-пэр я понял а теперь давайте
смотреть вообще что мы хотим то есть представьте следующую картину так у кого-то микрофон включен
теперь давайте с вами разбираться с тем вообще что у нас происходит и первое чем мы разберемся это
ну давайте это назовем zig zig так оно и называется в оригинале что такое zig zig представьте следующую
следующий момент вот у меня есть вершина там давайте буду обозначать буквы g это grand
parent здесь у меня parent здесь у меня child вот и здесь у меня есть у него под деревья а
под деревья б здесь у меня под дерево с и здесь у меня под дерево д я хочу сделать с корнем но
так чтобы моё дерево было ну оно переподвесилось как раз таки наверх и оно выглядело по сути примерно
так же то есть мы хотя бы здесь не увеличим высоту если так в общем брать что обцд примерно
ровно операция zig zig делает следующее она поворачивает сначала п сюда после чего мы
поворачиваем ц то есть это просто два поворота направо два поворота направо относительно этой
вершинки вот то есть мы с вами хотим получить по итогу после первого поворота мы получим с
вами здесь п здесь g здесь c здесь у нас будет а тут b тут c и тут d после чего я разворачиваю как
раз таки ц чтобы оно стало корнем я получу с вами вот такую вот картину здесь ц здесь ой ц
да все правильно ц а после чего у меня идет п здесь у меня будет b здесь у меня будет вершина g
который будет два по дерево ц и вот операция zig zig заключается вот в этом то есть смотрите
мы просто переносим нашу вершину child которую мы пытаемся найти прям вот наверх на корень для
того чтобы если мы там искали данную вершину смотрели на нее что-то с ней делали она просто
там была и все было хорошо вот это то что касается операции zig zig она просто берет все и поворачивает
здесь не очень сложно я думаю вы поняли да вот а теперь операция zigzag последняя которая нам
понадобится в чем вообще плюс этого всего на самом деле zip у нас есть с вами операция zigzag
операция zigzag она выглядит как большой правый поворот по сути либо большой левый то что мы как
раз таки с вами тоже видели представьте следующий у меня вот здесь вершина g вот здесь у меня будет
parent а здесь будет child вот и также проставим наши под деревья эти под деревья могут быть пустые
могут быть не пустые нам это не сильно играет роли тогда я вначале беру и делаю правый поворот
относительно ой правый поворот этого неправда вначале я делаю левый поворот с после чего
делаю правый поворот вот то есть после этого я выстрою себе следующую картину после первого
поворота что у меня будет вот здесь вот сэн а вот здесь вот будет наш перн и вот в этом подделье
будет а вот в этом подделье будет б здесь сэн и здесь после чего я захочу хочу цепь перенести как
раз таки в корень тогда я делаю ее корнем справа у меня будет этот grandparent слева у меня будет
parent здесь будет а б с и д вот то есть смотрите авель дерево внутри себя использует вот такие вот
моменты то есть самая главная операция здесь естественно будет zig zig zigzag и просто zig вот
эти три операции они позволяют нам постоянно изменять изменять структуру нашего дерева и
благодаря измене структуры нашего дерева и то что всегда будет на вершине стоять та вершина
которой мы обращаемся то будет все очень хорошо в силу того что мы будем постоянно
перебалансировать наши дерева хотя сбалансированным его назвать в прямом смысле слова нельзя так
как иногда там некоторые операции действительно будут работать к примеру за о отн вот все это
вместе объединяется в так называемую операцию сплей что такое сплей сплей это операция как раз
таки вот этих переподвешиваний в зависимости от того как выглядит наша вершина то есть она
берет и переподвешивает наш запрос который у нас есть вершины на корень после чего мы
можем обработать как раз таки запрос то есть перед любым запросом и будем сначала делать
сплея только после этого что-то там подвешивать или находить и так далее вот в этом случае мы
с вами давайте опишем вообще в принципе как у нас выглядит наша операция сплей для какой-нибудь
вершинки понятна сама суть сплея что произойдет давайте вопросы пока на этом этапе
а можете еще раз зиг зиг показать зиг зиг вот например такой естественно может быть и с другой
стороны спасибо а мы по помощи зиг зиг зиг зиг закала как раз делаем чтобы це стало наверх да
а в каком случае надо делать что бы состав на вер просто зиг когда у нас у перрента нету
никого в принципе сверху мы сейчас сплея это увидим как раз вот вопрос а в чем смысл этого
действия если мы пытаемся поставить цена вверх то есть мы уже знаем где находится ц
с одной стороны это правда вот но есть другой вопрос в том что как часто мы будем за счет
таких операций мы с вами будем постоянно изменять конфигурацию дерева из-за этих изменений мы с
вами это докажем у нас дерево ну точнее любой запрос с плей именно будет работать за логарифом
амортизационно то есть средне он может отработать за от единички если мы будем
постоянно искать один тот же элемент например правда ну то есть он всегда в корне а может
отработать за отн в зависимости от того как оно там выстроилась первоначально чем преимущество
этого перед обычным поиском который тоже за логариф бинарное дерево поиска не всегда работает
за логариф ну хорошо а вот сбалансировано блогу или сбалансированное дерево работает за логариф
в чем плюс этого дерева да смотрите на некоторых повторяющихся операций а смотрите чем больше
у вас повторяющихся операций тем лучше с плей дерева потому что повторяющиеся операции я имею
в виду повторяющиеся с одним и тем же элементом он все выше корнем а если он все выше корня ваши
запросы как можно быстрее обработать то есть вам не нужно будет переходить по указателю то есть
как вы типа вот если мы один раз ищем ц мы его поставили в корень если мы потом будем еще 5 раз
просто брать корень в общем случае да именно так или к примеру мы постоянно будем вставлять
какой-то ключ близки к ц близки к ц мы напишем как это будет выглядеть и за счет чего это будет
складываться но вообще весь самый главный плюс классности по сплее дерева в том что мы
в действительности используем просто с повторяющимся запросами очень-очень быстро мы
можем найти ответ гораздо быстрее чем в некоторых других деревьях вот а симпатически так это тоже
мы с вами докажем окей еще есть вопросы нет хорошо тогда давайте с вами продолжим давайте
опишем с вами функцию сплей и давайте сейчас я я здесь назвал это зиг да давайте это не совсем
зиг это зиг это вправо зак это в другую то есть это не совсем зиг это просто некоторые ротэйт
в зависимости от того левый это или правый поворот то есть если у меня находится кью слева то нам
необходим правый поворот если нам необходим кью справа то это левый поворот прошу прощения вот
окей а давайте с вами напишем функцию сплей нам сплей необходимо чтобы он он поднял вершину в
корень до какого-то момента но так как у нас все операции рекурсивно внутри то нам достаточно
писать сплей в зависимости от конфигурации дерева сейчас которая переподвесит какие-то вершинки вот
именно сейчас то есть примет либо зиг либо зиг зиг либо зигзаг одну из этих операций поэтому
операция сплей от какой-то вершины в будет выглядеть следующим образом но это но да вот мы
говорим что есть ли у нас parent в неопределен неопределен равен а то в этом случае мы вернем
просто наш корень то есть в следующий момент после этого ну мы сделали условия этой остановки
рекурсии а после чего мы можем играть как раз таки работать абсолютно совсем давайте
ведем как раз таки наши вершины parent и grandparent то есть они равны там web parent и grandparent
у меня равен parent от parent
но это дедушка бабушка как хотите назовите эту вершину вот но это та которая является
предком для нашего родителя вот после чего мы с вами говорим что если у нас нету
если у нас нету дедушки то есть у этой вершины нету в общем если нету у родителя у родителя то в
этом случае мы с вами говорим следующее мы просто делаем rotate от вершины ну rotate parent
и мы просто берем и как раз таки поворачиваем необходимую нам вершину в нужную нам сторону либо
это значит что мы нашли корень если grandparent равен а то parent являлся
вот и здесь возвращаем после чего мы с вами говорим что иначе давайте обсудим следующее
в каком случае нас что происходит у нас зиг зиг зиг зиг вызывается в случае если grandparent
parent является левым ребенком от grandparent и сам ребенок является тоже левым ребенком
поэтому в этом случае нам достаточно сделать следующее иначе мы проверяем если grandparent
grandparent left равно parent
grandparent left равно
нашей вершине в то в этом случае мы с вами делаем просто два наших rotate вот то есть мы
берем и просто поворачиваем сначала мы поворачиваем нашу вершину с parent но то есть
корень который был у того под деревом после чего мы с вами берем и поворачиваем поворачиваем
grandparent и вот так это просто зиг зиг мы же по идее можем зиг зиг зиг заг получается
заг заг и заг зиг вывести в распредельные функции их вызывать смотрите в тому со суть что нам
необходимо только зиг зиг и зиг заг да забавный факт такой что нам он будет только лишь это
необходимо вот сейчас я допишу я объясню хорошо вот иначе мы делаем с вами операции
zigzag вот что делает zigzag zigzag просто поворачивает в начале в начале нам необходимо повернуть
grandparent и в после чего нам необходимо повернуть
grandparent и в вот после чего нам достаточно вернуть в этом все
так как мы делаем рекурсивно мы с вами делаем здесь return
return splay от v почему потому что в этом случае у нас так или иначе v стало корнем вот и тогда
нам этого достаточно чтобы что-то произошло почему нам достаточно операции zig zig и zigzag
и просто по факту zig или zag вот потому что если у нас оно является просто правым сыном то мы
будем постоянно перекидывать ну то есть если оно находится правым сыном постоянно с такой правой
ветки то мы просто будем перекидывать наверх делая наш заг если находится слева то мы делаем
zig zig zig zig zig и так далее то есть мы тоже вернемся ровно к этому же моменту но то есть вернемся
вот к такому же моменту что эта операция произойдет вот в ту же сторону потому что ну если мы
к примеру grandparent вызываем от него splay у меня zig с ней zag наоборот будет постоянно увеличивать
ее пока не дойдет до корня вот самое главное что нам нужно определиться что делать когда ты правый
сын а потом стал левый если ты просто правый сын а потом правый сын то все хорошо если ты левый
сын а потом правый сын то у тебя тоже все хорошо потому что они будут в нужном порядке то есть нам
нужно было переопределить только лишь одну штуку вот и все это применяется с помощью вот как раз
таки одного rotate который поворачивает либо налево либо направо и нам нужно было обработать
вот именно вот эту вот штуку по факту все остальное похоже именно на то как это и было вот мы просто
все ситуации приводим к zig zig zig zag и zig or zag да да все правильно то есть все ситуации мы
приводим к одной одной из этих трех вот если у нас grandparent потом направо parent и направо child
так и тогда пока комнат будет сейчас еще раз можно ну а точно также как zig zig только все
направо просто будет все время подъем через zag или как так да давайте еще раз в данном случае
мы с вами рассматриваем то что у нас просто будет подниматься данная вершина и вот будет
происходить грубо говоря вот этот вот левый поворот постоянно если по правой вот идет кусочек
ясно вот этого нам достаточно если вдруг она будет правым и левым ну сначала она
буду правым потом после поворота стало левым то здесь мы уже применяем как раз таки zig zag
нам главное все свести к zig. Зачем надо было отдельно прописывать zig zig? Ну чтобы вы понимали
как это выглядит то есть у нас возможны такие случаи вот я с вами их показал посмотрел как
вопросы есть вот то есть именно так задавалась сама структура первоначально того как она
выглядела я правильно понимаю что в принципе мы вообще можем не павиться там с zig zig и zig
загом а просто ну условно каждый раз поднимать просто ротейпом да ну не совсем да ну смотрите
здесь вся будет проблема в чем когда мы здесь делаем ротейти вот zig zag и zig zig смотрите в одном
случае мы сначала должны повернуть grandparent и parent вот в котором как раз таки вот вот в этом
случае а только потом child иначе мы получим с вами немного другое дерево если мы захотим
сделать наоборот сейчас я не понимаю немного вот ситуация когда у нас parent слева child слева и
когда они оба справа они же как бы симметрично почему мы видим мы хотим рассмотреть пока
достаточно будет одного случая они симметрично я не спорю но да суть спа и дерева в том что мы
ограничимся вот этими функциями по факту данным нужен один ротейт который мы применяем везде
где можно вот zig zig zig zag это немножко раздельные ситуации которые нужно рассмотреть отдельно вот
все остальное вместе здесь у нас получается так что оно позволяет нам перекинуть главное в корень
то есть мы соблюдаем саму туевристику который у нас есть который мы первоначально пытаемся
добиться но вся суть в том что при таких операциях мы будем достигать вот просто там есть удивительный
факт который мы сейчас разберемся что при таких вот операциях мы с вами достигнем следующего что
запросы работают за логарифм при таких достаточно ну скудных знаниях грубо говоря дерево когда
мы будем перебрасывать все наверх понятно то есть у нас есть zig zig zag zig zig zig zig zig zig
вот этих трех операций достаточно данном случае то есть только они определены считаем так вот что
касается самого сплея сплей выглядит вот таким вот образом и мы сейчас будем с ним разбираться но
почему это удобно а это удобно по следующему принципу давайте с вами напишем функцию поиска
то есть нам необходимо найти какой-то ключ в нашем дереве ну не обязательно в дереве полным может
быть в каком-то по дереве поэтому мы сделаем с вами функцию find которая принимает там вершину
в и ключ после чего мы с вами говорим что ну если у нас там к примеру такое условие остановки если
в ровно там на то вернем минус один пример ну здесь зависит от того какие ключи здесь
уже вам необходимо подумать что можно вернуть условия такой остановки критической остановки у
рекурсии вот после чего мы с вами делаем следующее что если у нас хотя не нам давайте пусть у нас
это будет файн он возвращать будет саму ноду пусть у нас будет возвращать налp tr ну просто на вот
если у нас ключ равен ключу нашей вершины то в этом случае мы возвращаем так как мы хотим добиться
чтобы у нас лежало все в корне то мы возвращаем с вами сплей иначе после чего мы с вами говорим
что иначе если у нас ключ меньше чем там ключ который есть в нашей вершине вы то по просто
свойства бинарного дерева поиска мы с вами идем налево вот то есть ключ находится где-то слева то
есть у структуры ноды ключ это ее значение или или как ну когда вы когда написали кейвер сказали
потом расскажите что такое кей на кей это ключ ключ это какое-то значение просто он может
нынче по значению получается да ну конечно ключом может быть любая структура данных на самом деле
который вы все понял вот но в данном случае мы говорим о том что это просто какие-то интенты
чтобы вам было понятнее и легче как-то хорошо то есть если у нас ключ находится слева то мы
можем пойти влево единственное что нужно понимать мы там примеры вообще можем так прийти
или нет если вы говорите о том что в дереве все есть то окей вы просто здесь возвращаете
вот если у вас если у вас ключ будет больше чем
то в этом случае мы возвращаем дощаем поиск вот и ключа ну то есть мы пошли направо там
пример и в принципе сам по себе файн в чем плюс его в том что мы в конце еще раз делаем сплэк
вот то есть смотрите она не сильно процедура файн ты не сильно отличается стандартной
процедуры вообще в принципе как просто мы тянем эту вершину вверх и делаем порн через там через
процедуру сплей по факту то есть мы хотим чтобы эта вершина оказалась там почему у меня в конце
написан сплей в случае к примеру если вы говорите о том что вы можете искать в дереве что-то меньшее
неравное ключу и так далее то в этом случае можно написать следующее здесь например
и вот здесь аналогично и не равно то есть мы вызываем функцию find в случае если у нас
слева нет ничего если ну грубо говоря представьте следующее бинарное дерево поиска у нас с вами
есть тут 5 здесь 4 здесь у него здесь ничего не может быть ну давайте не 5 6 6 4 вот здесь у
него ничего нет здесь там два я ищу элемент 5 он у меня должен по-хорошему вывести 4 вот но
у него нету правого сына то есть вот у нас нам но так как запрос обратился по факту к этой вершине
на последний раз в последний момент то я хочу чтобы это четверка перевелась в наш корень и
у нас получилось следующее дерево 4 2 6 поэтому я вызываю сплей в конце еще раз если же я ключ
нашел то я просто вызвать понятно в первой вариации когда мы еще не дописали дополнительные условия
в и у нас по идее последний ретурн функции никогда не зашла вот в этот сплей не зашла бы она
бы зашла вот сюда и был бы на всегда и мы бы ничего с этим больше не делали вот разы сначала
не в двойке обратимся мы сразу сплэй сделали что еще раз почему мы сразу сплэй сделали мы
разве не должны в двойку пойти почему у нас 5 мы ищем 5 да так если 5 мы ищем то мы нашли четверку
идем вправо никакой их не сработает дополнять никакой их не сработает да вот то есть мы хотим
с вами как раз таки исходить из того что мы даже если запрос плюс минус неудачный но мы
почему-то приходим возможно нас интересует данные вот на конкретном отрезке пример там от 10 до
тысячи а вот все что вовне очень редкие запросы когда мне нужно там миллион найти и вот я хочу
чтобы вот все что было рядышком находилось как можно выше к моему корню вот поэтому в этом
случае сплэй дерево достаточно классно и крутой вот смотрите что касается вставки и удаления
вставка удаления работает следующим образом для того чтобы мы вставляли элемент или удаляли
элементы нам понадобится две дополнительные функции сплит и мерч сплит будет разрезать дерево
по данному ключу то есть что это означает представьте следующее что делает сплит то есть
файн мы с вами нашли сплит для того чтобы у меня сплит работал но у меня было там дерево к
примеру следующее давайте на примерах 8 здесь у меня будет 6 здесь у меня будет 10 сюда пойдет
7 4 здесь там 11 и я хочу разбить свое дерево по ключу 10 например то есть я сплите хочу
получить следующее чтобы у меня было следующее дерево 8 6 7 4 а здесь 10 и 11 и для чего мне
нужен этот сплит представьте я хочу вставить сюда 9 вот хочу вставить в дерево свое девятку
давайте 9 поставим его самое место куда ему необходимо тогда в этом случае 9 должно если
смотреть на вот это дерево 9 вот должно быть вот здесь вот правда так как я разъединил убрал
грубо говоря вот это вот ребро то в этом случае я получил два дерева 8 и 10 с корнями 8 и 10 и
теперь могу 9 поставить сюда и я все еще получил бинарное дерево поиска то есть сплит по ключу
берет и разделяет наше дерево на два под дерево после чего для того чтобы вставить какой-то
элемент мы объединяем их говорим что левым ребенком от сплита ну то есть дерево которое меньше
это левый ребенок для этой вершины новый а правый ребенок это вот новая наша вершина ну то есть
не правый ребенок это другое дерево который объект точно больше то есть сплит у нас будет
работать следующим образом сам по себе он просто будет делить два дерева и получать вот эти вот
кусочки а когда мы уже получим вот эти вот кусочки нам будет достаточно просто вставить как
корень наш новый ключ который мы хотим добавить что будет еще рассказать когда девятка станет
если мы не будем разделять это звенит слева от десятки она станет слева от десятки но нас
это не устраивает мы же делаем когда запрос какому-то смотрите еще сплей дерево работает
любой запрос делает так что эта вершина который у нас есть запрос становится корнем я хочу поставить
в корень для того чтобы поставить корень давайте я разъединю два дерева и скажу теперь это под
деревья девятки все что правее ну то есть мы разделим так что все что правее оно больше все
что левее оно меньше правда правда а значит основное свойство бинарного дерева выполняется
окей намного дольше разве дольше будет если мы просто поставим девятку потом мы сделаем поворот
это здесь можно так сделать а дальше ну в плане у нас у нас понимаем его до корня это не очень
выгодно с точки зрения времени почему потому что мы будем добавлять элементы постоянно куда-то в
даль то есть смотрите мы будем ставить не на их место где они могут быть по факту а мы их
пытаемся в листы запихать и вот первоначально когда мы с вами говорили мы это и делали то есть
мы всегда добавляли в листы после чего там либо либо просто в обычном бинарном дереве поиска
ничего не делали либо мы пытались что-то с этим делать как ввл дереве и перебалансировали здесь
же другая ситуация давайте будем вставлять сюда вершины в нужное им место хорошо вот тогда в
этом случае ну сам по себе сплит будет работать очень очень быстро по сути мы с вами говорим
следующее он тоже рекурсивный здесь будет три случая когда у нас корень больше меньше или
или равен как раз-таки необходимы нам дерево давайте их просто распишем и условия остановки рекурсии
у меня здесь будет код эти вот ну как это снизу вверх ну то есть скакать немножко но здесь будет
отдельный случай первый случай если бы у девятки было там левое под дерево еще то как бы мы поделили
дерево а где у девятки левое если бы оно было у нее или мы бы в принципе не использовали когда
у нас девятки в принципе нет мы пытаемся найти ее место если в десятке было левое по дереву там
должно было быть все больше чем дейм если бы в восьмерке был бы родители допустим 12 куда куда
подожди куда я вставлю твое ну в смысле вот сюда ну да если был бы родители тогда сплит будет
он разделит эти деревья все равно каким образом то есть какое дерево у нас будет в итоге у нас
будет 12 10 и 11 понятно то есть она 12 вот есть 11 но вообще в этом случае в этом случае он
ставится не сюда а вот сюда девятка встанет сюда вместо 11 будет 12 мы захотим ставить 11
что еще раз если вместо 11 у нас будет 12 мы захотим ставить один то есть у нас при разделении
ну у нас не положили такой идеальной ситуации что вот она одна да и мы хотим ставить 11 тогда
в этом случае у нас будет следующее у нас будет 10 8 7 6 4 12 11 соединяем получаем вот так и такое
предполагаю что мы будем делать с помощью сплей еще раз разделение будет приходить
помещу сплит не с помощью сплэй ну в смысле чтобы сделать вот эту ветвь от 8 к 10 и чтобы 10 стало
баррентом чтобы 10 стало корнем будем использовать видимо сплэй да ну ладно зачем нам 10 корнем если
я вставляю 11 но так у нас сейчас получается что 10 это ну она не корень если просто соединим
12 у нас 10 получается не корень а ой я понял почему все это да ссоре я неправильно здесь нарисовал
вот вот но в этом случае я а что что что не так то есть мы будем условно говоря выпрямлять
10 или мы просто к 8 все я понял какой вопрос все хорошо нет мы будем просто делить деревья так
чтобы мы могли вот встать нужное нам место то есть смотрите мы оставляем корнем то что тут было
просто вот всю часть которая слева мы отдаем все также восьмерки а все что является корнем вот
этого правого кусочка говорим что новое дерево любое дерево когда мы вот так вот его рисуем
можно спустить на этот на прямую правда все согласны да вот я думаю вы к этому уже привыкли
представьте следующее вот и что мы будем делать когда мы делаем сплит когда мы делаем сплит то
мы к примеру вот хотим ставить сюда тогда мы оставляем вот этот корень и вот этот новый
корень у правого по дереву то есть мы начинаем разъединять деревья в случае если мы можем
ставить но вот это вот грубо говоря ребро вот сюда нашу вершинку и вместо одного ребра сделать
вот так два понятно вот так работает сплит он вернет мне два корня и мне нужно будет их только
подсоединить если в моем примере он вернет 12 8 да я понял окей давайте с вами опишем
общий сплит как это выглядит просто рекурсивно это достаточно просто если чтобы быть у меня есть
функция сплит все что в нее передается это корень и ключ по которому мы хотим разъединить
наше дерево вот условия ну когда у нас будет корень нулевой то в этом случае мне нужно вернуть
нулевой и нулевой как реализовывается с помощью плюсов ну реализуйте структуру где будут храниться
два корни вот после чего мы с вами говорим что корень у нас будет равен найти корень но найти
в нашем дереве вообще где должен лежать наш ключ вот после чего мы говорим что если у нас
рут рут за счет того мы что мы все там уже перебросили внутри у нас файндижестой работал
а вот а ой да кстати я понял вислав я понял что вы имели в виду видимо опять
правильный ли я имею ввиду а что вернет сплит вот здесь правильно 8 или 10 да смотрите при
условии когда у нас будет работать сплит мы будем говорить следующее что если у нас там рут ну корень
рута равен самому ключу то в этом случае мы будем устанавливать давайте так объясню
сет перинт но здесь мы просто зафиксируем сейчас давайте я расскажу и объясню тогда уже до конца
что происходило сет перинт от рута левт и там нал сет перинт отрут и нал ну то есть мы просто
фиксируем что здесь нулевое и после чего мы возвращаем с вами возвращаем рут
левт и рут рут левый правый его по дереве то есть когда мы будем сплитить по данной по данному
ключу мы говорим о том что мы просто разъединяем если у нас ключ равен тогда мы говорим что все
корень нам больше такой не нужен у нас есть левый есть правый это пример у границы здесь
левт вот если же у нас корень ну ключ корни будет меньше чем ключ сам корень вот этого нового
дерева то в этом случае мы говорим о том что давайте так райд ровно рут райт рут райт
правен но то есть мы отсоединяем этот правый кусочек пример то есть если мы ключ на ключ
там меньше то мы отсоединяем наш правый кусочек говорим что зафиксируем там родителей для правого
по дереву как нау и возвращаем получается корень и правый кусочек то есть смотрите
первоначально мы с вами что делаем мы с вами ищем ищем туда где вообще должен стать наш ключ
место куда он должен это ну в какое место ему необходимо встать из-за того что мы ищем ключ у
нас работает естественно файн дисплей то есть он переболен ну перефиксирует как-то наше дерево
после чего мы с вами уже как раз таки все начинаем делить здесь благодаря файду вот все что у нас
было оно перенесется в корень то есть все те кусочки которые там меньше больше на чем мы
остановились разве руки не должен быть больше чем кей для того чтобы вернули правую сторону для
того чтобы отделяли мы же смотрите смотрите правое под дерево больше чем кей правильно
а ключ то есть смотрите что я имею ввиду после операции find у нас появилось вот такое вот дерево
да ну вот я так нашел его правда и вот тут вот девятку мне вот 10 здесь 11
девятка у меня становится на вот это вот место правда когда мне необходимо его разделить я
говорю о том что левый правый кусочек рутрайт раин рутрайт то есть все что находится справа а
все что является с корнем 8 когда мы 9 вставляем оно является уже как раз таки необходимым не
дерево сейчас когда ключ корня будет меньше чем девят ну меньше чем необходимое нам число то
мы должны разделить как рут и право его под дерево взять его значениями если наоборот будет
ситуация сейчас мы тоже напишем то там просто наоборот то есть если бы я хотел ставить ну
предположим здесь было бы не 7 просто здесь не было бы ничего я хотел бы ставить 7 то мои бы
возвращаемые сплетом значения были бы 8 и 6 понятно какой еще вопрос а вот мы как писали вот этот
сплей так что он делает только слева ну короче вот почему-то написали все для левой ветки а
для правой не писали практически для правой ретейт у нас есть да да а мы это но а почему именно так
мы делали это чтобы у нас вставала на вот этот корень вершина которая уточни значение которое
самое близкое снизу к нужным или как сейчас я не понял вопроса но короче я так и не
поняла почему вы написали все для левой ветки а для правой написали достаточно ли это для
того чтобы нам найти ответ а вот скажи мне я не ало я лиля ссори да ссори лиля да я знаю достаточно
потому что мы с помощью этих операций можем прийти к вершине сверху правда можем тогда давайте
так и делать и будем некоторые усовершенствования не то что нужно просто поворачивать еще в какой-то
момент поворачивать несколько раз и по-другому сделан для того чтобы у нас дерево как раз таки
пыталась поддержать логарифмическую высоту вот это просто сама так структура вы видите вот
почему так мы сейчас с вами разберемся хорошо окей так давайте допишем сплит у нас к сожалению
мало времени очень грустно все давайте можете пожалуйста пояснить вот запись ретурн и через
я сплит возвращает два дерева все в докладе я напишу т1 т2 если хотите
по факту два указатель он должен вернуть если он хочет вернуть два указатель достаточно
написать структуру которая будет это принимать понятно а как этим последствиям пользоваться
а как нельзя обратиться к полю структуры а ну ладно хорошо спасибо вот у нас
операция find вот где рут равна find отрут и запятая к ей она не может на лп тр и вернуть
она может вернуть на лп тр только в случае когда у нас вершины такой нет
ну смысле вот когда вершина равна нулевой но этот случай мы отдельно рассматривали ну то есть
почему мы специально писали в эфе что мы не пойдем влево если там ничего нет потому что мы
хотим вернуть вершина ближайшую к необходимым нам она может вернуть нау никто не спорит но это
только в случае если я передам вот find рут равный нау который я обработал выше то есть
если у меня дерево пусто пусто то как бы расплитив его я получу два пустых это понятно
на всех остальных случаях вот мы рассматриваем это все а зачем нам else после ретерна потому что
мы не рассмотрели абсолютно все случаи но еще вот сейчас не дописали его что будет когда у нас
ключ корня будет больше нам необходимо вернуть как раз таки левую часть и правую часть поэтому
в этом случае мы говорим что левая пусть у нас там левый равен рут левт и рут левт равняется нау
после чего мы с вами фиксируем наших родителей
до левого
как нау вот и возвращаем левая
левая и корень вот это то что касается сплита понятно ли что это делается что происходит надеюсь
что понятно можно еще раз почему у нас не может быть файн возвращайте но где там приведите
пример какой-то несуществующий элемент который ищем вот все несуществующий элемент тогда в
этом случае он будет делать find find до момента вот какого-нибудь из вот этого и тогда в этом
случае не зайдет return find и у нас останется только лишь с плей мы сделаем с плей в и
закончим типа и начнем раскручивать стек в обратную сторону понятно
спасибо вот таким образом мы с вами получили два дерева мы их расплитили и нам осталось понять
то как работает insert но insert работа достаточно простая давайте сделаем следующее вот у меня
было дерево я его расплитил и получил из них два дерева ну вот у меня было а и б
мы с вами знаю вот здесь я получил два таких дерева я их разбил по ключу кей то есть у меня
получается в левом все меньше ключа кей в правом все больше ключа кей тогда для того чтобы здесь
что-то получить мне достаточно сделать ключом свой корень и тогда у меня будет верное дерево
поиска бинарная то есть в этом случае мы с вами говорим о том что мы insert делаем ну от нашего
корня там и кого-то ключа вот мы хотим ключ вставить вот мы с вами делаем следующее что у нас
левая и правая под дерево равно split от корня и ключа то есть мы разбили на эти
деревья после чего нам необходимо добавить вот этот вот то самый корень и для того чтобы добавить
вот тот самый корень давайте сделаем так что рут но это но да давайте сейчас так сделаем
чуть-чуть по плюсовому напишу что но да рут равна у нее есть там у нас по моему левый правый то
есть для него левый ребенок это левый правый это правый здесь нал а здесь ключ ну просто чтобы
вы поняли что мы делаем корень у которого есть левый кусочек правый кусочек в нем лежит ключ кей
вот после чего мы с вами делаем кипер от корня и возвращаем наш корень то есть смотрите при вставке
мы сделаем так что элемент будет являться корнем вот и все вот таким образом выглядит
есть вопросы консерту а тут получается будет конфликт у нас мы в insert
передаем рут потом мы объявляем новый рут тут как как это пофиксить будет не рут хорошо ладно
все в декот вам явно не нравится окей ну не рутом сделай вот так что мы вот этот
рут который передавали в insert мы после мы после спита не используем не используем ну так почему
мы в него просто его нельзя сконструировать ну по-новому то никак не используем смотрите дело в
том что мы можем вернуть сам корень то есть помните вот ситуацию с восьмеркой вот восьмерка
являлась корнем трогайте вопрос так нельзя она является корнем теперь левого под дерево ну так
мы же перезаписали в лест получается но здесь да здесь правда вот здесь можно так сделать ну как
хотите можно так ну то есть можете здесь просто написать но да не просто рут равно вот это хорошо
если вопросы к вставке нет теперь смотрите а помимо того чтобы разделять деревья иногда их
хорошо бы склеивать между собой это так называемый мерч мерч работает это того что мы берем одно
дерево второе дерево и склеиваем их просто в какой-то вот кусочек как это работает если у нас мы
знаем что у нас в левом ход дерева но у нас есть левый кусок есть правый кусочек а и б то есть
левая и правая для нашей корректной работы ключи дерева левт они меньше чем ключи дерева
вот после чего мы будем брать вершину с наименьшим ключом правого под дерево и тянуть ее наверх вот
и после этого мы скажем мы будем соединять деревья то есть смотрите в этом дереве я нахожу
минимум грубо говоря я нахожу минимум вот после чего я с вами ну нашел этот минимум говорю что
теперь она будет являться корнем для этих двух от деревьев то есть это похоже на то самое удаление
которое нас было там в том же овельдере и в том же обычном бинарном дереве поиска мы находим
минимум мы вставляем его наверх и он будет являться корнем для этих сам по себе мерч пишется еще
быстрее представьте что у нас есть левая и правая под дерево и мы делаем следующее что если у меня
правая равно нулю ну то есть это пустое дерево то в этом случае я верну левая если у меня левая равна
то я верну
после чего мне нужно понять где находится минимум ну минимум достаточно просто можно и
тоже рекурсивно просто вызвать каким образом смотрите мы знаем что вот здесь вот вот здесь
вот все элементы а меньше чем бы поэтому для того чтобы найти вершину а куда нам вообще что
является минимальный здесь можно не писать функцию find минимум который у нас есть а просто написать что
просто написать что райд равно файнт от правого и примеру левт точка техи ключ
поэтому find у нас всегда уйдет самый дальний уголок и найдет как раз таки тот самый минимум
помимо этого find сам по себе что делает он берет увеличивает постоянно ну он сделает так в конце что
у нас сверху будет лежать именно та самая вершинка то есть благодаря зиг зигом зиг загом и просто
у нас все с вами получается так что минимальный элемент стал корнем нашего дерева
prosecut если он минимальный элемент то у него левого дерева нет а если у него левого дерева
нет ну awak кусочка то в этом случае ka потому что нашу самую минимальное ключ тут мило ещё встала
в корень то есть у нас она妳 strains this tree in this case, we can say that we have
У нас для правого дерева левым ребенком станет left.
Ну и после чего тут можно написать set parent.
Parent является right, child является left.
Вот. И вернуть корень нашего под дерево это теперь right.
Вопросы к merge есть какие-нибудь?
Когда мы его используем, ну просто...
Тогда нам понадобится merge, а теперь просто очень забавный факт.
Для того, чтобы у нас все работало и все было хорошо,
и удалялись вершинки каким-то образом, нам достаточно взять,
удалить вершину посередине,
получить распличенные два дерева, после чего их соединить.
Вот. Что в принципе логично.
Поэтому в этом случае достаточно сделать следующее.
Как выглядит erase?
Erase какого-то элемента с корнем и ключом.
Что мне достаточно сделать?
Давайте сделаем следующее, что я делаю root.
равно find от корня и ключа.
После того, как я нашел свой корень,
ну нашел свой ключ, искал свой ключ,
я его поставил в корень своего дерева.
Но он действительно является корнем.
Вот. Потому что в принципе сплей так работает,
что он берет и выкидывает абсолютно все вершинки, корни.
Поэтому дальше можно написать, что...
Давайте я сделаю, что set parent от root left равно нулевому.
set parent от root правого равно нулевому.
А после чего мне необходимо просто...
Ну то есть смотрите, я избавился от корня, так как я нашел ключ.
Я избавился от этого корня.
После чего я делаю вернуть...
Ну то есть у меня erase должен вернуть какой-то корень.
Вернуть merge от root left и root right.
Единственное, что нужно понять, как с памятью работать,
как вы почистите и так далее, я думаю, вы здесь справитесь.
Вот. Ну то есть смотрите, здесь ничего сложного в этом плане нет.
Нам достаточно просто взять, разъединить,
ну точнее вывести сначала нашу вершину к корню,
разъединить по этому корню,
после чего убить у нее родителей.
Ну сказать, что все, ты больше не являешься родителем для своих детей,
хоть ты на них указываешь, они тебя больше не принимают.
То есть мы разделили это дерево и замерзли эти два кусочка.
То есть разделили, замерзли, получили.
Смотрите, сейчас будет 10 минут перерыва.
Продолжение, давайте, 18.07.
Я сейчас посидел, подумал.
Я прошу прощения.
Операция zigzag и операция zigzag, она аналогична в обе стороны.
Вот.
Да, то есть смотрите, если у нас справа, то мы...
Справа дважды идет.
То мы дважды делаем грубо разик-зик.
Если у нас справа сначала правый син, потом левый син,
то это операция zigzag.
То есть я неправильно, некорректно все это сказал в первоначале.
Поэтому просто поймите, что вот эти вот операции
в другую сторону работают аналогично.
То есть zigzag, если бы у меня было другое дерево...
Я правда прошу прощения об этом.
То есть у меня могло быть такой случай.
Ну и тут деревья.
То в этом случае, да, у меня бы тоже получилось, что здесь C сверху.
Вот.
Просто единственное, что в этом случае...
Тут раз, тут два.
Справу у нас получается что будет?
G.
А слева?
Справа C.
Нет, после выполнения всего.
То есть мы сначала должны, смотрите, развернуть это вот сюда,
потом вот сюда.
Поэтому справа у меня будет сначала P, а здесь G.
Такие вот кусочки.
Вот.
Основополагающий, на самом деле, вершин.
Основополагающая штука является как раз таки zigzag.
Почему? Потому что он...
То есть он, грубо говоря, выправляет вот эти вот кусочки.
То есть у нас было здесь как-то много всего.
Он сделал так, чтобы вроде бы плюс-минус похож.
Окей, давайте с вами оценивать вообще время работы.
Смотрите.
В операции raise у нас с вами есть find.
Все остальное за U от единички работает.
Потому что merge сам по себе внутри использует тоже только find.
Все остальное за U от единички.
Правда?
В операции insert у нас есть split.
А split сам по себе внутри использует операцию find только.
Все остальное за U от единички.
Ну, то есть здесь возвращается сразу понятно, что...
Таким образом, нам нужно оценить по факту только лишь find.
Но find внутри себя использует только лишь операцию split.
А сам по себе он работает логарифмически относительно коллектива вершин.
Ну, точнее не логарифмически, а от высоты зависит.
Вот.
И split зависит аналогично.
И таким образом нам необходимо...
Если мы оценим splay, мы оценим абсолютно все.
Вот.
То есть find работает пропорционально глубине.
Splay работает пропорционально глубине.
А все остальное работает за счет этих операций.
Все остальные максимум дают какое-то однообразное...
У от единицы мы можем там все посчитать.
Поэтому нам нужно...
Главное, что оценить, это splay.
Для этого введем понятие ранга и будем работать с методом потенциалов.
Ранг вершины v...
Давайте я буду писать r.
Так легче будет.
r от v.
По факту он равен логарифму...
Количество вершин в поддереве, где корень является v.
c от v...
Количество вершин в поддереве с корнем v.
Это первый момент.
Я надеюсь, там все вернулись?
Да?
Вроде бы да.
Это количество вершин в поддереве с корнем v.
Это первый момент.
А вообще потенциалом нашего дерева t будет являться сумма всех рангов.
По всем вершинам.
Понятно?
То есть, грубо говоря, мы сложим все ранги, вот будет мой потенциал дерева.
У дерева может меняться потенциал каким-либо образом.
Вот.
А что такое v от t?
f от t.
Нет, там сумма...
v от t, v это вершины в дереве t.
Ну, просто вершинки.
Ну, граф g это v и e.
Вот это вот v, это и есть количество вершин.
Понятно?
Просто вершины все, которые входят в это дерево.
Окей.
Вот.
Это то, что мы говорим об этом.
Фактически операция splay работает за высоту.
Потому что она просто вызывается рекурсивно друг от друга, от детей и так далее.
Вот.
И по факту это равно количеству элементарных поворотов, которые будут выполнены в ходе процедуры.
То есть смотрите, когда мы смотрим на высоту, чем ниже лежит вершина, тем больше поворотов мы сделаем.
Элементарные повороты я имею в виду вот именно zig.
То есть просто повернуть лево или просто повернуть право.
То есть left rotate, right rotate.
Просто чтобы вам было понятно.
Вот.
И мы сейчас докажем с вами следующее утверждение.
Утверждение.
Амортизационное.
Цонная.
Сложность.
Операция splay.
От вершины V.
В.
В дереве.
T.
С корнем.
С корнем.
Здесь.
Сейчас я подумаю.
С корнем.
Ну давайте root.
Прям так и напишем.
Root.
Составляет.
Составляет.
Три умножить на R от root.
Минус R на V.
Плюс один.
Смотрите.
Если мы с вами это докажем, то у нас все хорошо.
Почему?
Потому что вот это есть логарифм.
Двоичный от количества вершин N.
Это есть логарифм.
Двоичный от количества вершин V.
Но даже если мы выкинем логарифм двоичный от количества вершин V.
То есть просто не будем учитывать.
То в этом случае мы получим, что это три логарифма плюс один.
А это есть O от логарифма.
То есть у нас амортизационно будет работать все очень быстро.
То есть логарифмически.
И давайте сейчас обсуждать вообще почему так.
Первое.
Из чего складывается доказательство.
Рассмотрим с вами операцию зиг.
Вот.
Я думаю вам не стоит напоминать.
Ну или стоит напоминать.
Давайте скажу.
Что если у нас меняются.
Сейчас скажу как это правильно.
Если у нас с вами меняются потенциалы.
То для нас самое важное начальное и конечное состояние.
А не как то, что было в середине.
То есть то, что было в середине не является для нас необходимостью.
Потому что у нас потенциалы так вычисляются.
То есть у нас есть потенциал.
Начало, потенциал конца.
Вот мы его так подберем, что у нас все будет хорошо.
Вот.
Если вдруг кто не помнит, то обязательно посмотрите лекцию про амортизационный анализ еще раз.
Вот. Разберем каждый поворот.
Начнем зиг.
А что делает зиг?
Вот у нас есть там вершины.
Например, root.
У нас от нее есть v.
И вот здесь вот у нас там есть a.
b.
Здесь вот c.
Вот. И я с вами получаю v'.
Ну я просто так сделаю, чтобы у нас было легче.
root'.
Здесь у нас будет a.
Здесь будет b.
Здесь будет c.
Давайте просто посчитаем потенциалы.
С тем, что у нас с вами вообще было здесь.
Время.
Давайте a.
Оно равно единичке.
Почему единичке?
Потому что зиг занимает один поворот.
Поворот это от единицы.
Это значит будет единица.
Плюс.
Как у нас изменился ранг после этого?
У нас стал ранг всего дерева.
Разность вот этих потенциалов.
Смотрите.
Ранг a как-нибудь изменился.
Потенциал под дерева a как-нибудь изменился.
Как ты думаешь, Антоним?
Думаю, да.
Почему?
Потому что он поднялся вверх.
И что?
Что такое ранг?
Ой, что такое потенциал дерева?
Потенциал дерева?
Не знаю.
Мы только что вводили, что такое потенциал дерева.
Не в основном.
Смотрите, еще раз.
Потенциал дерева – это сумма всех рангов внутри.
Так как у нас количество вершин внутри дерева a никак не изменилось,
то потенциал дерева тоже никак не изменился.
Это понятно?
Сколько было там вершин, столько и осталось.
Для нас это неважно.
Аналогично для b и аналогично для c.
Единственное, что у нас изменило потенциалы,
это вот эти две вершины root и v'.
Поэтому мне достаточно сказать,
что разность потенциалов вот этих двух деревьев,
она будет заключаться в следующем.
Что это ранг от v' плюс ранг от root'
минус ранг от v,
минус ранг от r, получается.
Что-то я от root.
Ранг от root.
То есть смотрите, конечное состояние складывается
из потенциала a, потенциала b, потенциала c
плюс ранг root' и ранг v'.
А первоначальное было из потенциала a,
потенциала b, потенциала c и ранга v и ранга корня.
Ну, потенциала a, b и c они сокращаются.
Получается, у нас изменение потенциала заключено
только лишь вот в этих вот вершинках.
Правильно?
Откуда единичка?
Единичка от того, что мы говорим, что у нас
операция сама по себе занимает какое-то время.
Одно.
Оно работает от единиц.
Нам нужно оценить лишь только find внутри.
Спасибо.
Вот.
Нам нужно оценить.
Ну, то есть сам зиг работает.
Ну, мы перевесили вершины, все хорошо.
Нам интересно, как изменился потенциал.
Единица как раз таки именно от этого.
Окей.
Тогда в этом случае скажите мне, что я могу сократить?
Давайте я спрошу кого-нибудь.
Вот Кирилл Кузнецов.
Сократить в каком смысле?
То есть сократить с минусом имеется?
Ну да, вот у чего-то здесь есть равные ранги?
Ну, вроде как, который root с штрих и v просто.
Разве нет?
Нет.
B и C имеют различное количество вершин.
Смотрите.
Root и v-штрих.
Что еще раз?
Root и v-штрих.
Root и v-штрих, потому что, смотрите, моё дерево не прибавило в количестве.
Здесь количество вершин, то есть C от root.
Чему равно?
Оно равно количество вершин в A плюс B плюс C плюс единичка, которая от V.
V-штрих аналогичный.
Это количество вершин A, B и C плюс root-штрих.
Спасибо.
Вот.
Таким образом мы можем взять и сократить вот эти вот штрихы.
После чего мы с вами получаем, что у нас A и T равно 1 плюс ранг от root-штрих-ранг от v.
А теперь вопрос.
Как-то связаны ранги с рамками?
Ни разу.
А теперь вопрос. Как-то связаны ранги root штрих и v штрих?
связано рангом а или что-то рангом рангом боизвиняюсь вот рангом рангом бы
ну смотрите да первоначально у v штрих сейчас ну то есть не как v штрих больше вершин чем было
чем у root штрих правильно то есть мы можем сказать что вот в этом случае у нас вот вот здесь вот
это меньше либо равно чем ранг от v штрих ну количество вершин просто меньше у r штрих правда
ребята вот отлично хорошо хоть один человек услышал и понял вот таким образом у нас получается
что у нас это меньше либо равно чем ранг от v минус ранг точнее v штрих минус ранг от v что же такое то
что ранг от v это понятно
да а получается что в этом случае мы доказали вот ту самую штуку что аито меньше либо равно чем
3 умножить на ранг v штрих минус ранг v плюс один так
ну мы просто на 3 умножили разность разность точно не отрицательный количество вершин только
увеличилось это понятно чудно тогда давайте дальше теперь проверим с вами зиг зиг
здесь будет уже немного посложнее давайте рассмотрим с вами какой-нибудь дерево
вот пусть у меня есть g потом есть p потом есть v у него здесь а здесь b здесь c здесь d
мы с вами берем зиг зиг что делает он переносит в наверх у нас получится v штрих
v штрих g штрих d c
b и а давайте теперь рассматривать с вами как выглядит как выглядит вообще теперь вот это
самый потенциал так как зиг зиг состоит из двух поворотов то его амортизационная стоимость
это там 2 плюс что-то потому что ой да из двух поворотов мы считаем что поворот один работает
за вот единичку на есть два поворота ну на эти два поворота за два ну каких-то два условных
времени вот поэтому мы можем сказать что аито равно смотрите опять же потенциал под деревьев
а б цд никак не меняется вот ну никак поэтому их мы можем сразу исключить поэтому пишем два
плюс ранг от v штрих плюс ранг от п штрих плюс ранг от п штрих плюс ранг от g штрих
минус ранг от g минус ранг от f минус ранг от v здесь появилось слово
хорошо теперь вопрос что мы опять можем сократить скажи мне пожалуйста миша ри
же и в штрих лично у тебя что-то голос какой-то грустный да мы можем сократить
в штрих и же это мы с вами сократили вот после чего мы с вами можем сказать что еще оценить
некоторые ранки мы с вами знаем что ранг по штрих по штрих меньше либо равен чем ранг
в штрих правильно ну давайте сейчас меньше либо равен чем р от в штрих но потому что в штрих
просто больше у нас вещей вот а здесь минус ранг от п этот ранг от п он больше либо равен
чем ранг от вы но мы его вычитаем поэтому здесь нам достаточно с вами показ мы с вами получаем
что а это будет меньше либо равно меньше либо равно чем получается два плюс ранг от в штрих
плюс ранг от ж штрих минус два ранга от в так может быть ранг в штрих равен рангу по
штрих рангу по штрих да у нас меньше равно написано ну никак но мы можем писать ну как бы
не сильно это убивает равенство хорошо вот это очень большой подгон нам и не нужно сказать что
прям строго меньше нам достаточно показать в другой сторону вот и осталось с вами показать
что вот это для того чтобы мы с вами могли получить ту самую оценку которую мы хотим а
мы с вами хотим получить я все еще напомним следующее что а и т меньше либо равно чем 3
на ранг на ранг получается в штрих минус ранг от в
вот мы хотим все еще получить вот эту вот штуку так как мы все еще хотим вот это вот получить то
давайте с вами докажем что 0 меньше либо равен
минус 2 плюс 2 ранга от ваш 3 минус ранг от ж штрих и минус ранг от в смотрите сложив эти два
неравенства я с вами получу необходимое мне неравенство правда я же могу их сложить просто
я получу 0 здесь 3 здесь 0 здесь 3 вот получу все что нужно давайте докажем вот этот вот кусочек
который мне необходим поехали дальше просто пока все перенесем получим что ранг же штрих у нас
будет ну плюс ранг от вы минус там 2 ранга от в штрих меньше либо равен минус 2 сам по себе ранг
это логарифм от количества если это логарифм от количества то я говорю что вот это у меня
логарифм вот это у меня логарифм от с от в вот это у меня логарифм двоичный от с от в штрих
но количество вершин вот увидев все это мы можем сказать следующее а давайте мы так это и представим
после чего вычтем р в штрих у каждого из этих что такая разность логарифм это да все правильно
таким образом мы с вами получим следующее что у меня будет логарифм логарифм двойки от получается
с ж штрих делить на ц в штрих минус ой плюс логарифм логарифм от ц в штрих делить на ц в штрих
да вот мне нужно показать что это меньше либо равно минус 2
вот а теперь скажите мне очевидно ли вам что с от в штрих больше либо равно чем с от ж штрих
плюс ц от в можете картинку назвать давайте еще смотрите ц от в штрих вот оно вот это оно
содержит в себе все по деревья оба цд в содержит в себе только по деревья оба а ж штрих содержит
только ц и д то есть логично что количество вершин в штрих больше либо равно учитывая что
у него еще еще есть п тоже можно сказать что больше это понятно сейчас стало ясно отлично тогда
мы можем сказать что под логарифмами у нас ну если мы их сложим даже в чем суть а можно сказать
следующее что сейчас момент следующий удивительный факт давайте факт логарифм двоичный от x плюс
логарифм плюс логарифм двоичный от игре меньше либо равен минус 2 если
икс плюс игре меньше либо равно единица икс игре положить вот
давайте так понятен ли этот факт
или непонятен откуда это произошло интуитивно понятен
интуитивно понятен они интуитивно можно строго доказать например рассказав что
икс игре там не больше половины и а произведение их максимально как раз если они по половине вот
ну это почти что да это просто неравенство среднем то есть смотрите для того чтобы
доказать этот факт ну кто-то говорил давайте мы можем что ну мы можем возвести двойку в обе
части этого выражения и получить как раз точности неравенства среднем по сути своей это правда но
я сделал чуть-чуть по-другому я просто возьму занесу это вот так вот икс игре здесь меньше
либо равно минус 2 икс плюс игрек меньше либо равно единице мы знаем о неравенстве
а среднем что мы знаем следующее что а плюс б пополам больше либо равно чем корень из обы
правда а плюс б у нас меньше либо равно единицы следовательно корень ну давайте из икс игрек чтобы
вам легче было икс плюс игрек меньше либо больше либо равно чем икс игрек следовательно
корень от икс игрека будет меньше либо равен чем 1 вторая но возведем в квадрат получим 1 четвертую
сумма логарифмов это логарифм от произведения получаем одну ну 1 четвертый это 2 в степени
минус 2 конец забавный факт закончился таким образом мы с вами получили что просто представив
это уже логарифм и так далее мы с вами получили как раз таки то что нам необходимо было здесь
мы доказали с вами факт что вот это вот это корректно я галочки поставил давайте красный
этот факт коррект а если этот факт корректен то у нас корректен и факт когда мы их сложим то
есть у меня получается что действительности а и т а и т меньше либо равно чем 3 3 умножить на
р от в штрих минус р от в да отлично и остался последний момент который нам
необходимо это zigzag zigzag zigzag примерно также доказывается сейчас мы с вами это быстро сделаем
я надеюсь пусть у меня есть же у него есть п у него есть в здесь у меня там а здесь у меня
бы здесь здесь д финальное что я с вами получаю я получаю следующее в штрих здесь у меня будет
п штрих здесь же штрих здесь а в с и д давайте рассмотрим аналогично тому что мы уже с вами
делали просто разность потенциалов то есть а и т равно 2 2 так как мы делаем два поворота каждый
поворот за от единицу 2 плюс плюс к этому всему получается ранг от в штрих плюс ранг от
ж штрих плюс ранг вот п штрих минус ранг от в минус ранг от п и минус ранг от же но мы сразу
можем сказать что вот это сокращается эти ранги нам больше не нужны так как они являются корнями
у них количество вершин как бы не изменилось в этом плане а теперь давайте посмотрим следующее
у меня ранг п ранг п сам по себе ранг п больше либо равен чем ранг в силу того что у меня
п было корнем в родителем поэтому я говорю что у меня а и т равная 2 плюс ранг от п штрих
плюс ранг от ж штрих меньше либо равно не меньше либо равна ранг от ж штрих минус два ранга от
м вот ну а это доказывается все аналогично тому что было в предыдущем моменте ну то есть то что
у вас было в предыдущем вот аналогично сделайте также 0 меньше либо равно чего-то представьте это
виде лабиритм вы получите то что вам необходимо вот в этом будет вся разница на самом деле то есть
здесь не будет чего-то очень-очень сложного для вас это понятно да чего бы лабы по обществу
субподогнал потенциалы так и работают что они для чего-то выбираются вот и таким образом мы
с вами доказываем что у нас операция с плей сама по себе сама по себе ну ранг любой вершины
ограничен логарифмом размера дерева из этого исследует следующая теорема что ну так как ранг
ограничен что операция с плей амортизационно работает за логарифм понятно то есть логика
здесь следующий мы оценили все операции получили с вами что работает за амортизационно зависит
от ранга ранг зависит от логарифма а значит с плей сам зависит от логарифм можно не учить
все это доказательства в плане написать что осталось заметить что или как что-то типа
хорошо можно вообще не выводить ассимтотики хочет к сожалению к сожалению или к счастью
алгоритмы на то алгоритмы что они должны быть эффективны иначе это будет очень-очень грустно
что практически все за либо логарифм либо смотрите а завершить доказательства можно
следующие образы хорошо осталось заметить осталось заметить что ранг любой вершины
ограничен логарифмом дерева
логарифм размера
дерево следовательно с плей
амортизационно
выполняется
за логарифм
логарифмы
вот это смотрите если вам нужно более четко здесь слово оно работает следующим образом
первоначальный потенциал нашей вершины равен там логарифм двоичный ац и икс правильным
первоначальный потенциал конечный потенциал у нас равен когда она стала вершиной стал равен
логарифм двоичный от n где n это количество вершины что касается количества смотрите
zigzag и zigzag внутри себя ограничены как раз таки вот лишь вот три умножить на
сейчас где это момент они ограничены вот этим но внутри себя ограничен если они ограничены вот этим
то каждый раз когда мы полняем zigzag или zigzag то мы можем сказать что нам играет роль только
начальные конечные значения нас даже не прибавляется здесь никакой плюс единички представьте
я сделал zigzag потом zigzag от этой вершины в этом случае у меня будет 3 на потенциал v 2 штриха
минус 3 потенциал потенциал ранг v штриха плюс 3 потенциал ранг v штрих минус 3 ранга в это означает
что нам играет роль только начальные конечные помимо этого помимо этого наша операция zig просто
она ограничена сверху еще плюс единичкой ну просто плюс единичкой то есть она также три ранга
плюс единичка но операция zig в дереве выполняется единожды максимум один раз а так иногда и 0 а из-за
того что она выполняется один или ноль раз у нас вот эта единица максимум один раз появится в том
когда мы будем складывать поэтому здесь если четко писать то мы получим с вами что test player
равна ну то есть нам по-хорошему нужно вычесть из потенциала начала потенциала конца после
там как давайте конкурс как минус потенциал началом или вон вот так как у нас последнее самое
большое что может увеличить потенциал это равно как раз таки нашему zig потому что на плюс 1 а там
без этого было плюс 1 то мы можем сказать что это три логарифма двоичного от н плюс 1 плюс там
какое-то состояние какое-то которое есть у всех остальных вершин но она будет аналогично тому
что будет феном ну то есть мы вычитаем лишь только то что произошло с нашей вершиной вы минус три
логарифма двоичного от с от нет ну вот все вот то есть если четко то вот таким вот образом
рассуждаются вот он лагерин эмортизационный действительно с плодей он работает так если
к этому всему вопросу как-то по мастерте время быстренько оценить сказать что по
быстренько оценить по мастерте ремы время как-то это нет пожалуйста еще сейчас давай еще раз что
ты хочешь мастер те реме но там есть мастер с которой для для оценки времени работал
не все так работает к сожалению здесь легче всего вести потенциал нелегче я бы сказал
легче ну действительно легче то есть ну просто понять как с ним работать и все я понимаю что
это математическая составляющий алгоритм но алгоритма они действительно в себе ночи такой
характер иначе мы я вам буду говорить но она так работает вот такие да потом придется на
работу начнет что-то писать у вас не работает и вы такие не работает вот так что здесь нужно
оценивать в любом случае что-то с этим делать тоже большая большая наука вот но мы сейчас
переходим достаточно интересным темам давайте перерыв минут пять чтобы вы отошли от
сплей деревьев нас с вами осталось не так много осталось последняя тема считать
и этот блок называется динамическое
программирую
кто из вас вообще представляет что такое он знает
ну я знаю примерно так ну то есть это вот у вас какая-то структура у вас будет начальное
положение и на каждом ну начальное положение там сдается каким-то элементом и на каждом
следующем шаге мы следующий шаг получаем результатом какого-нибудь следующего
получаем там за счет каких-то значений смотрите да динамическое программирование примерно в
этом заключается но на самом деле у динамики есть различные ее виды и то как строится она тоже
бывает по-разному вопрос следующим давайте вопрос такой даже у нас есть динамическое
программирование нам необходимо понять вообще что происходит в принципе задача есть классное
вообще о динамическом программировании можете запомнить и вы поймете в чем тогда его суть
о том что в принципе динамическое программирование это когда у вас есть какая-то есть задача
которая непонятно как решать и мы разбиваем эту задачу на мелкие под задачи которые тоже
непонятно как решать вот примерно в этом суть сама динамического программирования в ней есть
оптимальные решения и в ней есть и в ней есть то как мы их можем применять в принципе
в принципе для какого-то подсчета то есть есть перекрывающиеся дач то есть то что нам необходимо
в динамическом программировании вообще это первая оптимальность решения оптимальность
решение что так что подразумевается под оптимальностью решения то что у нас в принципе
сама по себе задача решается подсчетом из других оптимальных под задачу вот оптимальные имеется
в виду то есть здесь стоит такая некоторая задача оптимизации назовем назовем так о том что должно
все работать быстро классно круто и так далее но более формально формально то что
оптимальное решение оптимальное решение но звучит она так что оптимальное решение решение содержит
содержит оптимальное решение
решение
вот задача вот это вообще принцип оптимального решения помимо этого
если мы рассматриваем рекурсивные чаще всего динамическое программирование это больше про
рекурсию обращение к предыдущим элементам и так далее то в этом случае у такой вот
некоторые задачи подсчета имеются перекрывающейся задачи и вот если у нас
есть перекрывающих задач то мы должны сохранять предыдущие значения то есть второе это перекрывающиеся
задачи это первое что нужно понять про динамику следующие что нужно знать про динамику это виды
виды динамики существует три вида динамики мы сейчас их все рассмотрим первый вид первый вид
динамики это прямая динамика ну порядок пересчета так называем это не то что виды динамики хорошо
скобочках порядок пересчет
сейчас мы поймем это на примере какой-нибудь очень-очень простой задачки первое это прямой
порядок прямой порядок второе это обратный
и последний который есть от ленивый ленивая динамика
мне скажет самую простую задачу на динамику наверное с ленивый динамик
самую простую саму задачу бы постановка задачи найти какое-то число фибоначи да то есть смотрите
числа фибоначи числа фибоначи это прямой посыл к тому что не нужно сделать просто так
рекурсию вы с вами точно с вами разбирали на рекурсиях на функциях о том что делать так
плохо и так делать нельзя вот вообще как выглядит прямой порядок давайте вот сейчас
будем решать числа фибоначи с помощью типа вот всех всех порядков пересчета вы поймете в
чем их разница прямой порядок говорить следующее вот у меня были предыдущие какие-то значения и
я их ставил свое новое то есть это старые старые значения это новое что под этим подразумевается
тогда в этом случае прямой порядок с точки зрения чисел фибоначи будет выглядеть следующим
образом ну пусть у меня там есть массив какой-то f и так далее я скажу что f от нуля к примеру
равен нулю f от единицы равен хотя давайте ну хотя так будет f от единицы равен единице после чего
мы с вами просто напишем цикл for и равная нулю и меньше там и и равная 2 и меньше чем там какое-то
число n до которого мы хотим найти число фибоначи и в этом случае мы скажем что f от и равно f от
и минус 1 плюс f от и минус 2 обычный подсчет числа фибоначи вот то есть обычный вид то как это
выглядит в принципе что такое обратный порядок обратный порядок это когда у меня есть какое-то
значение и оно обновляет очень много там различных предыдущих значений не предыдущих а просто оно
влияет на них как это выглядит с точки зрения чисел фибоначи вот вы сейчас поймете в чем будет
принципиальная разница пусть у меня также f от нуля равно нулю f от единицы равно единицы после
чего мы говорим for и равная 2 и меньше n плюс плюс и а здесь кстати мне здесь надо с нуля
ссоре мы говорим следующее что у меня f от и плюс 1 f от и плюс 1 равно ну плюс равно f от
и и f от и плюс 2 равно плюс равно f то есть смотрите я как бы когда получил какое-то свое значение
сразу его закидываю дальше то есть сразу беру и считаю то есть есть первый способ когда я просто
на основе предыдущих есть второй способ когда мы делаем вот таким вот образом и последний
способ это ленивая динамика ленивая динамика заключается чаще всего в рекурсии и выглядит
следующим образом пусть у меня есть там какая-нибудь функция фи фибоначи от и мы говорим следующее что если
и меньше равно ладно давайте так равно нулю то вернуть ноль если и равно единицы то вернуть
то вернуть один я сейчас продолжу тут писать после чего мы сделаем еще одну вот это вот
ленивая штука которая как раз таки нам спасет что у нас есть все-таки массив f где-то ну пусть
глобально я напишу что если у меня в массиве f от и равно оно равно точнее да равно равно не
равно sorry минус 1 то есть мы посчитали у нас все заполнено минус единичек мы первоначально мы
не посчитали это все то я верну число фибоначи от и а иначе я говорю что f от и равно фибоначи
от и минус 1 плюс фибоначи от и минус 2 вот это у меня формула подсчета ну и вернуть надо
то есть смотрите вот вся ленивый здесь заключена в следующем мы не хотим думать когда нам нужно
считать так далее вот она ленивый я называю это в кавычках ленивостью но это так называемая
ленивая динамика которая действительно это понятно вот разница обратно прямого порядка
да новые новые мы меняем на основе того что мы только что узнали о старом
а новые меняем только когда пришли к ним а здесь я наоборот да давайте еще раз пас
ленивую как именно тем что мы рекурсии использовали что тем что смотрите я не хочу задуматься когда
мы начнем считать что-то там и так далее но то есть у меня здесь цикл я явно начинаю считать
чего-то правда ну прям явно и ты я понимаю когда а здесь я не знаю типа что у меня подсчитано
что не почитано с какой стороны подсчитано и так далее я написал установки рекурсии написал
саму формулу подсчета но так как я не могу идти полностью в рекурсию так как вы знаете что там
будет иначе все плохо я скажу что если мы еще не подсчитали предыдущий шаг тогда подсчитаем если
мы его уже считали тогда не буду считать понятно это неформальный вообще такая штука есть то есть
как ленивая динамика действительно есть вот просто она не то чтобы прям очень часто типа вот
прям формально мы с ней будем работать понятно а получается в обратном порядке у нас как бы
из нового следует старая как бы из нового из в обратном порядке мы сразу же кидаем в новое то
есть смотрите я не говорю о том что я не знаю что там будет впереди и минус первое наступит нет
но я все равно кидаю сразу сбрасываю вперед ну просто поймите в чем разница то есть я на
этом шаге здесь сразу прокидываю это вперед а там я не не трогаю и ты шаги которые до этого будет
понятно да вот это первая такая вот задачка на ней я думаю вы понимаете что оптимальность
решение заключается в том чтобы первое хранить значение все предыдущие вот и мы используем как
раз таки эти значения которые были посчитаны предыдущих шагов вот она задача вот она сама
динамика которая нам говорит да это действительно динамик это понятно пока что давайте тогда
разберемся со следующей задачей следующая задача скорее всего вам известная это черепашка
черепашка прям так называется эта задача в чем она заключается задача заключается в следующем
представьте у меня есть какое-то поле какое-то поле и у меня черепашка не знаю умеет ходить
только вниз и вправо скорее всего если кто-нибудь занимался что-то вроде олимпиадной
прогой он с таким вот сталкиваться то есть наверное может быть вот во всей табличке там
расставлены какие-то числа 3 4 5 8 0 1 3 4 ну и так далее черепашка может двигаться только вниз и
вправо она находится первоначально вот здесь вот а вот ей нужно добраться до конца вот и задача
иногда заключается по-разному либо минимальный либо найти путь при котором там будет минимальные
проблемы либо наоборот максимальные сумма чисел которые мы собирали то есть грубо говоря если
черепашка золотоискатель то она будет собирать монетки по максимуме если у нас черепашка
боится там не знаю других черепашек то и нужно пройти по пути на три пашка социофоб например
не знаю то она будет проходить по клеточкам где будет меньше людей типа суммарно чтобы
меньше с кем-то видеться вот ну может там боится вот зависимости от этого будет задача к примеру
по-разному и как эта задача решается нам нужно понять в конце к примеру сколько монеток этот
черепашка соберет вот кто понимает как это можно решать точнее какой первый случай как это
вообще выглядит это выглядит тем что это выглядит тем что у нас в принципе эта задача включена в
каком-то диком переборе что не очень круто но здесь можно использовать как раз таки то что мы
возьмем и будем динамически что-то строить так как мы можем ходить только вправо и вниз то мы
никогда не вернемся к предыдущим клеточкам я думаю вы это прекрасно понимаете то есть нельзя
вернуть там вверх именно поэтому эта задача как раз таки а перекрестных вот таких вот подзадачах
которые мы будем брать за основу но никак следующее не будет влиять на предыдущий то есть
один раз посчитали то все давайте пусть у нас будет задачка где мы будем как раз таки искать
минимальный путь минимальную стоимость пути что мы сделаем мы с вами возьмем и построим аналогичную
табличку аналогично табличку вот и давайте здесь сейчас что-нибудь еще до запомним до конца
4 здесь два один один вот раз два три четыре пять шесть здесь
вот мы с вами получили вот такую вот там табличку первоначально мы говорим что ну
черепашка ну кого-либо встретила например а вот она может двигаться только направо и вниз поэтому
здесь мы можем точно сказать что делать если мы хотим попасть вот в эту точку мы можем идти
только направо то есть заполним верхний наш массивчик это будут наши начальные условия то
есть здесь будет 5 потом будет 5 мы хотим найти стоимость пути минимальная здесь будет 9 здесь
будет 12 здесь будет 16 если что перепроверяйте меня на всякий случай здесь нас будет 3 5 6 7 ну то
есть вправо мы можем только лишь пойти вправо вниз мы можем только вниз пойти а теперь смотрите
я могу попасть в эту клетку вот в эту клетку которая у меня сейчас такой бордовой звездочкой
только лишь сверху или слева правильно вы согласны с этим надеюсь согласны вот поэтому мы будем
выбирать ту клетку где у нас было меньше ну та клетка где у нас суммарная стоимость была меньше
это слева поэтому мы пойдем слева и когда придем в эту клетку нам все равно придется
добавлять ту стоимость которая есть в этой клетке поэтому здесь у нас будет написано уже 7
аналогично заполняем другую клетку здесь у нас 7 и 5 нам легче прийти из 5 сверху но здесь
там стоимость там 8 поэтому здесь будет 13 и так далее мы заполняем вот так вот построчно все
что у нас с вами есть и если нам нужно дойти до конца то суммарная стоимость будет лежать вот
в этой красной клетке есть ли к этому вопроса а это как бы в любом случае в любом обходе так
будет в смысле в любом обходе мы как мы мы считаем клетку как сумму в левой и верхней правильно либо
левой либо верхней плюс самую ее то есть смотрите формула для заполнения все этой
таблички следующая что у нас а там и та житая равно минимум из а и минус первая житая то есть
когда мы на строчку вышли то есть сверху пришли либо а от и та но же минус первая
плюс плюс а и та житая ой ну не а хорошо вот это массив а вот этот массив стоимости ц хорошо
плюс ц и та житая понятно вот ну то есть мы приходим с одной из двух сторон отлично кто
понимает как можно восстановить путь ну можно запоминать в каждой клетке из какого мы пришли
а можно без этого как-то вы читайте потом искать клетку с полученным значением можно так но скажите
я же в любом случае приду либо отсюда либо отсюда да не в то читать минимальный да достаточно
здесь просто посчитать минимальные элементы с двух и мы туда пойдем то есть здесь даже не
нужно ничего вы читать или что-то делать здесь достаточно просто вот так вот пройтись по минимумам
понятно вот но обязательно с конца потому что если пойдете сначала не факт что придете вообще к концу
правильной вот поэтому как-то так то есть мы начинаем раскручиваться с конца мы пришли с
минимальной клетки ну к примеру вот отсюда если мы пришли с нее тогда мы могли прийти к примеру
вот отсюда вот так мы сходили потом вот так ну и так далее рано или поздно все равно придете
здесь к началу ясно как это работает ой я здесь неправильно нарисовал но да
вот именно так работает наша черепашка это пока тоже самая простая задача и видимо
сегодня мы с вами разберем еще одну одну задачу наверное если мы успеем задача звучит
следующим образом давайте что-нибудь сотру пример вот это дача звучит следующим образом требуется
требуется найти количество разложений
количество разложений числа
n на различные
слагаемые
вот что под этой задачей подразумевается например если у меня число n равно 7 то я
7 могу представить в следующем виде 7 3 плюс 4 там 2 плюс 5 1 1 плюс 6 и 1 плюс 2 плюс 4
и вот мне нужно что еще раз звучит как комбинаторная задача неправда она динамическая тут ведь не все
разложение написано а с точностью до перестановок хорошо так скажу
а все я понял вот насколько слагаемых как бы на любое количество тогда почему-то
нету например семи единиц я так понимаю месяц различные слагаемые различные но это
можно с помощью таблички там сделать 1 2 3 4 5 6 7 плюс единицы и переходить считать сумму как-то так она
делает примерно как-то так смотрите там есть два способа расскажу один второй я наверное попрошу
чтобы вам рассказали на семинаре пусть у меня есть состояние динамики состояние динамики
следующая dp от n как это количество количество разложений
разложений числа n
на числа
меньше либо равные как вот
давайте с вами сделаем эту динамику смотрите первое что есть нам необходимо
начальное состояние динамики начальное состояние
начальное состояние достаточно простой как я могу разложить число один из одного элемента
ну не больше чем к числа не больше чем к одним способом один это один нули у нас нет вот
а разложить это
другим способом то есть у нас здесь без повторений считается dp от n и и от единицы и и sorry единицы
это количество получить предыдущий элемент плюс еще единицы это нули но здесь смотрите
в этом случае но вот это наши начальные значения тогда формула подсчета выглядит следующим
образом я сделаю там for и равная единицы и меньше чем к плюс один
плюс плюс и я скажу что dp от n как это равно dp
вот n минус и на и формула подсчета я имею ввиду для n того числа не то что она
заполняет все все все а вот просто для n того числа я напишу формула формула подсчета
то есть смотрите для того чтобы посчитать для n того числа разложение к вот
прошу прощения для того чтобы написать разложение числа n того на к мы можем
сказать что а давайте мы будем использовать количество разложения этого числа что будет
если мы будем его использовать это число тогда у нас останется n минус и чисел правда
точнее сумма их n минус и вот это именно здесь и написано я возьму число и оно может раскладываться
по разному число и там количество у них может быть разным там один ну если это число 3 то это
1 2 к примеру и просто 3 это уже два способа и так далее но я эти разложения прибавлю просто к
своим от n минус и вот и все понятно как это считается или ничего не понятно не совсем что
именно непонятно по сути последняя строчка еще раз как мы разбиваем и конкретно суммиру ну смотрите
сейчас вы согласны с тем что вот у меня есть число 8 к примеру я его могу представить как
3 плюс 5 правда да да я могу сказать что дп от 8 и там к примеру 5 ну так все сутрировано
а это равно чему это равно дп смотрите вот той по той же форме ли подсчет дп n минус и
если я и возьму 5 8 минус 5 а нет давайте тройку 8 минус 5 что я под этим подразумеваю я под этим
подразумеваю следующее что в данном случае у меня вот есть динамика какая-то я хочу там
разбить на числа не больше чем 5 давайте я посмотрю просто а чему 8 минус 8 минус 8 минус что
ж такое то 8 что я хочу я могу сказать что а это то же самое что разбить число 5
на числа не меньше чем 3
тут точнее плюс ровно прошу прощения то есть еще раз n это количество разложений числа и на
числа меньше либо равный как количество разложений числа n минус и на числа не больше чем и
этого достаточно в данном случае формула подсчета будет выглядеть именно так вот и если
просто порасписывать как это выглядит там не знаю до семерки давайте вот распишем для семерки
к примеру можно просто не проще допустим у нас количество способов получается из того что если
допустим 8 это у нас получается из количества способов разложить 7 плюс единица и плюс
количество разложить шестерка плюс двойка плюс количество разложить пятерку плюс ну то есть это
просто количество способов разложить шестерку семерку шестерку пятерку и так далее а теперь
вопрос до какого это делать момента потому что мне не нужно повторяющийся элемент так у нас
получается что повторяющийся мне нельзя в этом вся проблема если просто количества согласен
но здесь есть проблема с повторяющимся элементом там есть действительно действительно случаи
когда-то можно сделать полегче но есть второе решение которое вам действительно покажут это
решение будет заключаться следующим то есть давайте я сейчас быстро отвлекусь немножко у нас
три минуты все равно осталось я могу представить разложение числа в виде так называемых диаграмм
юнга вот ну к примеру как-то так такие ступеньки и тут вот ну там как бы квадратики всякие есть
вот и здесь будет один здесь 3 здесь 8 ну вот я разложу там 12 и что я могу делать этими
диаграммами юнга по факту для того чтобы получить какое-то новое число а так можно
разложить любое число ну то есть мы так и будем раскладывать чтобы порядок возрастания там был
чтобы не повторяются я могу лишь добавить новую строчку с чем-то могу добавить число 1 разложение
грубо говоря либо-либо могу поставить сюда столбец вот сюда вот в этот край для того чтобы
получить какое-то новое число если я добавляю столбец то я что делаю я прибавляю единичку ко
всем числам правда вот и поэтому я могу на единичку еще поставить сверху ну то есть я
буду считать с конца вот грубо говоря то есть я могу вот добавить везде единицы и поставить
еще единичку сверху добавить новый элемент так сказать и вот с помощью этого как-то все
вот то есть я могу либо увеличить все имеющиеся числа там на один либо увеличить все имеющиеся
числа на один и добавить еще один разложение вот один из двух способов я умею так делать все вот
то есть это будет второй способ который я прошу с вами разобрать смотрите что касается динамики
к сожалению нас еще очень много тем по динамике надеюсь что мы успеем за следующую лекцию есть
ли вдруг мы не успеем то возможно контрольный перенесу вам на зачетную неделю не знаю увидим то
есть здесь как получится хорошо потому что нам предстоит еще задача он и больше возрастающие
подпоследовательности наибольшей общей подпоследовательности и задача рюкзаки вот это
очень главные задачи действительно очень важные задачи которые необходимо знать на этом в принципе
все всем большое спасибо всем удачи
