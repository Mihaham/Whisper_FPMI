Вот, и всякие разные задачи с этими последовательствами можно делать.
Первый самый такой самый траспорт и, возможно, самый популярный трек, который можно делать, — расширование.
В этом работает так. Мы для каждой строки определим в ней ее числовой певалент.
Давайте скажем, что х из строки s0, s1 и т.д., это такое выручисло.
С0 на, давайте, x, нет, давайте b в степени n-1, плюс s1 на b в степени n-2, плюс т.д., плюс s0-1, по модулю какого-нибудь m.
Вот, значит, m и b — это выручисло.
А когда я пишу символ умножить на что-то или прибавить что-то, я имею в виду, ну, зачастую.
Либо здесь написано просто ASCII код этого символа, то есть у нас есть таблица ASCII, где 256 символов.
И, соответственно, в каждом из символов, ну, по крайней мере, 20 — это актуал.
У них есть какой-то свой номер, число какое-то.
И вот здесь, собственно, просто чар преобразовывается к n-2, не явно, и происходит перемножение, сложение, все как надо.
Либо это просто ASCII код символа, либо можно считать, что это как бы порядка для номера уставителя.
То есть на среди всех символов, которых у нас, на самом деле, гораздо больше, чем 26, чем бутсла символа уставителя.
А, значит, ну просто номер, да? Вот у меня 25.
И причем, наверное, хочу не от нуля, а от 1. Давайте два варианта, как умножаемость к данным символам.
Ну, разница, например, в том, что строка из всех ASCII у вас будет всегда нулем.
И независимой длины. Это, ну, как бы, может быть и нормально, но не совсем хорошо.
Значит, первый вариант. Это просто ASCII заменяется на ASCII код.
То есть это просто конвертация чар преобразовывается.
Либо, в случае нашего алфавита, да, когда алфавит это маленькая вот эти буквы,
мы можем вместо ASCII записывать, я вот так пишу, S I минус A плюс 1.
Мы узнали порядковый номер символов алфавите путем вычитания символа I по выявлению 1.
Ну и, собственно, это будет то самое число, которое в этой форме представляется.
То есть это число от 1 до 26, это число от 1 до 26 и так далее в ход до последнего символа.
Вот. Значит, давайте считать, в какое породение давайте, как мы живем,
что каждый символ заменяется на какой-то число от 1 до 26.
И тогда, смотрите, если я скажу, возьму B больше, чем 26,
тогда у меня тоже написано в скобках, это, по сути, запись в обычной системе числения какого-то числа.
Да, если, то есть мы вот это все воспринимаем на прозряды,
с 0 и с 1, когда я сниму с 1, то это просто число в обычной системе числения,
я сложусь с нужными степенями, да, и получил какое-то число.
Тогда вот это вот, это просто число в обычной системе числения.
Ну и такое понимание хорошо тем, что, например, разным строчкам соответствует разная вот эта вот величина,
одинаковая, одинаковая.
Понятно, что если у нас есть две разные строки,
то их записи в этой вот обычной системе числения будут различные,
а значит и эти числа будут различные.
А если строки одинаковые, то они по символе равно,
и значит у них будут одинаковые вот эти вот значения су.
Ну то есть в идеале мы могли бы просто каждую строчку воспринимать как число
в какой-то там достаточно большой системе числения,
гумичной, да, где B больше размера алфавита.
И тогда, скажем, проверять, строки нравятся или не нравятся,
можно просто сравнивать эти два числа.
Вот эти вот.
Ну, проблема понятна в том, что эти числа могут быть слишком большие
и ни в какой нормальный тип не помещаться.
То есть, по сути, мы просто перекодировали строку в некое число,
оно может быть такое же длинное, как и исходное,
и поэтому, в принципе, мы мало что выиграли.
Но, когда мы берем по модулю M, вот это вот взятие остатка по модулю M,
мы в каком-то смысле, ну, конечно, мы уменьшаем информацию,
то есть у нас, возможно, какие-то коллизии,
что разные строки теперь отвечают одному и тому же хешу,
после взятия по модулю M вот этого вот.
Но все равно, как бы, хочется верить, что если строки были разные,
то у них хеши будут разные.
Конечно, это не всегда так, но довольно часто так.
Что я хочу сказать?
Да?
Ну, типа когда-то.
Вот это из 56 для ASCII кода.
Смотрите, то есть...
Я понимаю, да.
Ну, как бы, использовать что угодно, на самом деле.
Использовать и двойку, и, типа, и случайное число.
Поэтому тут не особо важны какие-то числа.
Почти что угодно сработают.
Так, значит, давайте я напишу, что мы хотим делать.
Мы хотим научиться определять,
равны ли две строки?
Сейчас у меня есть какие-то скотчки.
Ну, давайте считать, что они одинаковые длины.
Нам лень их проверять символенно.
У нас есть их хеши.
И мы хотим по значениям хешей сказать,
равны исходные строчки или нет.
Ну, и здесь, естественно, поведение такое,
что если хеши совпали,
то мы говорим, что строки исходные равны.
Ну и это, действительно, с хорошей вероятностью
будет верным ответом.
Мы чуть-чуть позже поймем,
почему при правильном выборе BEM
это будет, ну почти всегда правильным утверждением.
Понятное дело, у нас, конечно, бывают коллизии.
Если мы берем по модулю BEM,
мы сужаем пространство возможных значений.
А значит, разные, ну, какие-то разные строки
склеиваются в 1.js.
Но, грубо говоря, так же,
если мы берем по модуле BEM,
мы сужаем пространство возможных значений,
Но, грубо говоря, такое происходит. Но если у них не совпали хэши, то они, конечно, точно не равны.
Ну и в этом случае все совсем понятно. Если у них различные хэши, то они точно различные, не могут быть одинаковые,
потому что одинаковые строки дали бы одинаковые вот эти значения, а значит одинаковые х значения.
Значит, случай, когда равны фэши, но сами строки не равны, называется коллизия.
То есть хэши совпали, они должны были. В идеале они не должны были сюда впасть, потому что строки разные.
Ну давайте в каком-то смысле посчитаем вероятность коллизии. То есть если мы там что-нибудь будем выбирать случайно,
потому что понятно, если у нас все детерминировано и S, и T, и B, и M, то мы, конечно же, ну, такое бывает, и от этого никуда не веримся,
что иногда бывают коллизии. Но вот если что-то выбирать случайно, то коллизии будут довольно редкие.
Ну, подтверждение. Если B от M, так сейчас скажу, B меньше M – случайное число, нет, фиксированное число,
а S и T – случайное строка длинной M, то вероятность коллизии не больше одной равны.
То есть если бы у нас, скажем, были M не фиксированы, а то, что подается на вход представляли бы собой случайные строки,
вот эти S и T, которые подаются, были бы случайными строками, тогда вероятность, ну, как бы ошибки максимум одна M.
И, соответственно, если брать M порядка 10 в 9, ну, там, что в N помещается, 10 в 9 или 10 в 18, если мы хотим влонг-лонг считать ошибки,
тогда вероятность ошибки будет, ну, пренебежимо, мала. 10 – 9 – это прямо супер-ед.
Ну, доказательства. Что значит, что S не равно T, у них равны ошибки.
Ну, давайте начнем вот такую строчку, я ее назову S, ну, это будет минус 5.
То есть я сделал посимольное вычитание, и все равно, поскольку я считаю, что у меня аусловид – это там какие-то числа,
то, соответственно, я просто посимольное число вычитаю, беру все по моделю M и опять получаю, ну, набор чисел.
Я строку сейчас уже воспринимаю не как набор символов, A, B, C и так далее, а скорее как набор чисел, массив чисел в длинной ленте.
И тогда, соответственно, я просто так по компоненту вычитаю из каждого из Итого числа строки ТС,
получаю опять строку, как набор чисел.
Тогда что мы про такую строчку можем сказать?
Во-первых, не наливая строка, потому что S не равно T, не целиком из наливей стоит, но при этом у нее наливой хеш.
При этом у нее наливой хеш.
Ну, потому что понятно, что эта штука аддитивная, если я вот здесь вот из всех хешов вычитаю,
например, из S-ы-то вычитаю T-и-то, то хеши тоже вычитаются.
Вот.
Значит, их разность тогда – это не наливая строка с наливым хешом.
Давайте посчитаем, сколько вообще всего есть строк с наливым хешом.
Хешом или хеш, это равно хешу правильно.
Так, есть ли ответ в зале?
Сколько есть строк данной длины, у которой хеш равен ею?
Ну, смотрите, давайте переформирую вопрос.
Представьте, что у вас зафиксированы вот эти вот все символы.
А, наоборот.
Вот эти вот все символы с U0 по U0,2.
Ну, не более одного символа последней.
Да.
Значит, если это все зафиксировано, то не больше, чем один символ вот здесь вот даст нам наливую хеш.
Ну, и более того, если sigma – это в точности числа от 0 до m-1, то ровно 1.
Потому что, еще раз, да, что вот, допустим, эта штука зафиксирована, что значит, что хеш такой строки 0.
Это значит, что, там, бла-бла-бла, плюс ugoi-1 делится на m.
Ну, или там, сравнимо с 0 по U0.
А значит, чтобы это выполнялось, то нужно просто чтобы ugoi-1 было сравнимо вот с, ну там, вот с минус этим по U0.
Ну, и это, собственно, в точности дает нам значение, чему должно быть ровно ugoi-1.
Да, поскольку у меня, ну, вот, я пишу, что m больше, чем b, а b еще больше, чем ugoi-1,
тогда существует не больше, чем одно значение ugoi-1, которое будет эволюцировать к такому уравнению.
Согласны?
Ну, просто, просто, линейное сравнение, максимально одно решение.
Значит, строк 0 х не больше, чем наборов из n-1 силы.
Ответ их не больше, чем m в степени n-1.
То есть из всех, да, ну, давайте, сейчас, сейчас, одну секунду.
Больше, чем столько.
Даже можно сказать, что их не больше, чем вот столько.
А sigma в степени n-1, конечно.
Вот их не больше, чем столько, а всего строк sigma в степени n-1.
Мощность sigma в степени n-1.
То есть, получается, всего лишь каждая одна сигмовая строка имеет 0 х.
Вот, и сейчас мы это здесь тоже получим.
Сейчас, одну секунду.
Больше, чем столько.
Ну, а строк всего sigma в степени n-1.
Да, строк всего sigma в степени n-1.
Что еще?
А это чем больше?
То есть это меньше значения, чем вот это.
Ну, а строк всего sigma в степени n-1.
Да, строк всего sigma в степени n-1.
Ну, а строк всего sigma в степени n-1.
Ну, а строк всего sigma в степени n-1.
Ну, а строк всего sigma в степени n-1.
Ну, а строк всего sigma в степени n-1.
Ну, а строк всего sigma в степени n-1.
Ну, а строк всего sigma в степени n-1.
Ну, а строк всего sigma в степени n-1.
Ну, а строк всего sigma в степени n-1.
Ну, а строк всего sigma в степени n-1.
Ну, а строк всего sigma в степени n-1.
Ну, а строк всего sigma в степени n-1.
Ну, да, смотрите, если я буду считать что у меня в качестве о самôleи-то вот здесь
Ну, да, смотрите, если я буду считать что у меня в качестве о сам список
Ну, да, смотрите, если я буду считать что у меня в качестве о сам Carouse-Newton
Ну, да, смотрите если я буду считать что у
Ну, да, смотрите если я буду считать что
Ну, да, смотрите если я буду считать что в меня в
Но, да, ideas
вот здесь
выступают как бы числа от 0 до m-1
У меня как раз получится д在oc
до m-1
У меня как раз получится та сама att β
Now, a little less that here
То есть мы поняли что строк с древним хешем
их примерно вот такая доля, значит, если я беру две случайные, то их как бы разность
будет иметь любой hash вот с такой вероятностью, ну, значит, оказывает то, что здесь написано.
Когда я беру две случайные строки, то есть если сигма, если я реально могу выбирать вот такие вот символы
от неляда и минус одного, то здесь вероятность, ну, по сути, на одной и той же. Одна сигма в одной и той же.
Вот.
Хорошо, но это было для случая, когда у меня фиксировано B и M, да, а сами строки выбираете случайно.
Скорее на практике происходит наоборот. Скорее на практике вам строки дают, ну, как бы, они даны на вход, вы не можете их менять.
Но в качестве параметров вы можете как раз и уменять B и M. То, что, как бы, то, как вы строите ваш hash function.
Ну, и в этом случае будет чуть похуже. Оценка, значит, оценка такая. Пусть S, T данные различные строки длины M.
Тогда, при случайном выборе, нет, тогда пусть, пусть еще напишу, M какое-то фиксированное простое число
больше, больше, больше, больше, больше, больше, больше, больше, больше, больше, больше, больше, больше, больше, больше, больше, больше, больше, больше, больше.
Тогда, при случайном выборе B, отверянная минус 1, вероятность комиссии не больше, чем N длина M.
Вот, то есть мы поменяли местами, как бы, случайно и фиксированно, там у меня были случайные строки, здесь, наоборот, строки фиксированные,
а я могу варьировать то, как я выбираю F, то есть M, M и B. Вот M я зафиксировал каким-то простым, достаточно большим,
а дальше B выбираю случайно в отрезке от 0 до 1. Тогда оказывается, что вероятность комиссии вот такая небольшая.
Ну и пример там, если примерно то что-то порядка 10 с пятой, то есть строки примерно там в какой-то такой длины,
я выбираю M, ну давайте там порядка 10 с восемнадцатой, тогда вероятность комиссии ну что-то маленькое, до 10 минус 13.
Вот, итоговая стратегия проведения. Мы фиксируем какое-нибудь большое M, скажем, порядка 10 с восемнадцатой,
простое еще надо, ну чтобы работа этой выражения надо простое, вообще, конечно, тут оценка может быть сильно улучшена,
и даже M не обязательно простое, ну давайте в какой-то остановке жить. То есть пусть M достаточно большое и простое,
дальше я случайно выбираю B среди всех чисел, ну кольца выше по модуле M, и все хэши, я теперь знаю как определяются,
я могу для любой строки найти хэш, и тогда из этого утверждения колись у меня будет очень редко, 10 минус 13.
Если мы будем действовать не так, а будем случайно играть на каждой строке B, и писать B в начале кэша, то колисью будет меньше?
А что если писать B типа пара, B запитает хэшу значение?
Сейчас, а есть у вас разные больше кэши?
Вот, ну и теперь вооружившись такой штукой, мы можем решить, например, следующую задачу.
Задача. У вас есть строка с 0, с 1, с 1, с 1, с 1, и к ней поступают запросы вида для двух подстрок проверить равны или нет.
Значит запрос вам дают l1, r1, l2, r2, надо проверить, равны ли s, l1, и так далее, s, r1, i, s2, и так далее, s, r2.
Короче, выделили две подстроки индексами l1, r1, i, 2, r2, вам надо проверить, равны по строчке или нет.
Вот, но решается это с помощью хэша следующим образом.
Давайте мы заведем какой-нибудь массивчик, давайте его так назову h.
Значит пусть h, i, t, это хэш строки с 0, у и и символ.
Такой хэш, хэш на префекте.
Пусть это хэш с 0, на b в степени i-1, плюс с 1, на b в степени i-2, плюс и так далее, плюс с it, и так далее.
Значит, вот давайте такой массив посчитаем, массив хэша всех префексов.
Его очень легко пересчитывать, потому что как меняется вот эта формула, то и в переходе вот i-1.
Давайте напишем, что это написано.
s0 на b в it, плюс s1 на b в it, плюс 1, плюс так далее, плюс s i, плюс 1.
Вот, видно, что чтобы получить из этой формулы ретту, нужно умножить, видимо, на b и добавить s и плюс 1.
То есть h и плюс 1, это b на ht, плюс s и плюс 1.
Правда?
Вот.
Значит, все такие хэши на префексах мы можем посчитать за линиями время, просто проход слева-направо по строке, и вот такое регульсивное пересчитывание.
Дальше всегда как на тим хэш какой-нибудь под строке.
Ну, если мы знаем хэши всех префексов, то довольно легко.
Что такое хэш строки, скажем, с л-того символа по хр?
Вот, значит, у нас есть такой хэш, есть вот такой хэш.
То есть это похоже на какие-нибудь частичные суммы, префексичные суммы.
Подожди, мы ставим хэш так-выстреки, хэш так-выстреки.
Значит, ну если аккуратно посмотреть, то формула будет такая.
Давайте напишу сразу.
Так, хр-т минус хр множество более степеней.
Значит, потому что хр это какой-то лишний кусок.
А дальше правильные хэшы от этой штуки.
То есть если вы распишете х с индексом r, то здесь будут какие-нибудь ненужные слагаемые, вот эти вот первые.
А дальше все слагаемые скелеты по плаве r будут как раз с нужным коэффициентом.
Там будет с р, с равным с первым множеством b, и так далее.
В общем, здесь будет все правильно.
Вот, и нужно всего лишь вычесть то, что левее этого адреса находится.
Это значит хр минус первое.
Ну и только здесь еще нужно будет поправить степень.
Потому что здесь будет степень нулевая, а надо чтобы была r-лт.
Еще раз?
Внутри скобок плюс т.
А, вы про это.
Ну, давай еще что-то не код, а типа математически сказать.
Да, ну вообще, как бы формально, когда надо было бы, если бы это было строчкой кода, то когда надо вот это было бы сначала преобразовать как число по моделю m, потом перемножить, опять взять по моделю m, и потом еще прибавить.
Ну, я такие подробности оставляю для кода.
Вот, ну и тогда соответственно мы смогли начитать хэш под строки за вот и днице.
За вот и днице.
Ну и тогда соответственно, зная хэш, умея вычинять хэш любой под строки за вот и днице, мы можем вычтенить нужных наших двух под строк тоже х.
Проверьте их на равенство, если равны, то значит скорее всего и под строки равны, если не равны, то точно не равны.
Да, и из-за всяких наших подтверждений, редкость калитии будет маленькая.
Не больше, чем там tn на m точке.
Вопросы?
Вот, хорошо.
Значит, ну эта вот задача была про проверку под строк.
Давайте вторая задача, о проверке вхождения.
Проверка вхождения.
Начнем задачу сформулируется так, у вас есть две строки, p и s.
Две строки.
Надо проверить, входит ли строка p в строчку s.
То есть это у вас какое-то слово, какой-то шаблон, ну в виде небольшого текста.
А это длинный текст, вам надо узнать, встречается ли маленький текст в большом.
Встречается ли p, s, то есть входит ли как строка.
Ну, собственно, здесь уже все просто.
Если мы умеем вычленять хэши для подстрок s, то давайте просто вычленим хэши для всех подстрок s,
в юмировом, такое как нам нужно, и проверим их на равности с хэшом от p.
Если они совпали, то значит мы получили вхождение с хэшом от p.
А если нет хэши, то мы получим хэши с хэшом от p.
И проверим их на равности с хэшом от p.
Если они совпали, то значит мы получили вхождение с хэшом от p.
То есть еще раз, вот есть какая-то короткая строка p, есть длинная строка s.
Давайте мы всюду, где возможно, приложим отрезок такой длины в s.
То есть мы посчитаем хэш у такой строки, у такой, у такой, у такой и так далее.
Возьмем все подстроки длины, ровно такой как p.
Узнаем у них все хэши.
На хэш подстроки мы умеем вычитать за единицу, убирая вот эта техника.
И дальше, если среди них хотя бы один хэш равен хэшу от p,
то мы говорим, что p входит в s.
Потому что мы считаем, что нам достаточно вот эту уверенность,
вероятность там 10-13, точнее 1-10-13.
Если хэши где-то совпали, то мы говорим, что скорее всего p вот здесь входит.
Если есть хотя бы одно совпадение, то p входит в s.
А подстрока тут непрерывная?
Подстрока это всегда несколько подряд символов.
Ну, кажется, все. Тут есть вопрос.
Тут надо просто поприкладывать и сравнить хэши у всех подстрок данной длины.
Это называется рабинокартом.
Рабинокартом.
Рабинокартом.
То есть в итоге мораль.
Хэши довольно прикольная штука.
Часто работают довольно быстро и весьма эффективно.
Но, к сожалению, это всегда может ошибаться.
Поскольку это все-таки вероятная штука.
Мы понимаем, что бывают коллизии.
Мы не можем там сколько годно длинные строки загнать в пространство размерности там 10-18.
Если мы рассматриваем сечность по моделю n, то там гарантированно был коллизий.
Мы когда-то точно ошибаемся.
Но вероятность ошибки настолько ничтожна, что если у нас есть какие-то проблемы,
а мы там b выбираем случайно прииксированным m, то тогда это происходит там почти никогда.
Да, и можно об этом даже не задуматься.
Но тем не менее, конечно, есть какие-то дисциплинированные алгоритмы,
которые не используют случайности, которые умеют решать те же самые задачи.
Значит, следующий.
Это у нас предиспутцы.
Посмотрим.
Значит, пусть есть какая-то строка с 0 и
7 번째 Art의 prolonged,
Пусть есть некая строка s0, s1, y0, y0, y1.
Префикс функции для нее, это набор значений t0, t1, и так далее, y0, y1.
Такое, что принятое, это длина максимального собственного...
Так, сейчас давайте я...
Максимального собственного суффикса строки s0 и т.е. s1,
которая совпадает с перефиксом той же длины.
Так, я не буду писать определение перефикации суффикса,
я давайте нарисую на картинке.
Мы рассматриваем строку с 0 уйти символ.
Вот такое начало наше строке.
Здесь мы хотим найти суффикс, то есть несколько последних символов.
Суффикс это то, что написано в конце,
которые были бы равны те же префиксы, Luxuary that we introduced in the opening.
Префиксы тоже написаны в начале.
Среди всех таких, мы хотим найти максимальный, то есть самый длинный
собственный суффикс.
Собственный, значит, что строка не равна всей строке.
Я могу сказать, что давайте 많이 было вот такой вот суффикс.
Это суффикс, конечно, потому что это несколько последних символов строки.
Это же префикс потому, что несколько первых символов строки.
И они конечно друг weil равны, потому что она directamente из строках.
В интересном случае тогда было бы просто всегда p i-то равно i плюс 1, и это никакой информации не несет.
Но если я запрещаю вот этот искусственный случай, когда суффикс равен к рефиксу просто потому, что это одна и та же строка,
я вот ввожу требование собственности.
Собственность значит, что строка не равна всей строке от негого, у кого есть сил.
Не равна всей строке.
Собственность значит, что это не равен целиком к церкви.
Меня интересует, как можно более длинный конец строки, но, наверное, до начала дольше длинный.
Просто такая рефикс функция в каждой позиции определяет длинную строку.
То есть алгоритм.
А как мы его мы насчитываем?
То есть простое замечание.
Давай сначала о определении что сказать.
Супрефиксом строки t называется...
Ее суффикс равный к рефиксу той же длины.
То есть вместо того, чтобы говорить эту громоздкую фразу суффикс равный к рефиксу той же длины, я буду говорить супрефикс.
Длина ровно вот эта.
Два кусочка.
То есть один кусочек, который находится не в конце и в начале.
Две равные строки, которые лежат вот здесь и вот здесь.
Такое утверждение.
Все суфрефиксы строки s0 и т.д. si имеют длинные.
Их длинные характеризуются следующим набором чисел.
Во-первых, как кашипоиды, как наибольший такой суфрефикс.
Дальше p от p и минус один.
Дальше p от этого же суфрефикса.
Правило такое. Я из предыдущего вычитаю ничку и навешиваю на это p еще раз.
Если я беру предыдущее значение, вычитаю линию и навешиваю b.
Беру b с индексом на 1 меньше, чем предыдущее значение.
До тех пор, пока эта штука не занулиться, если она уже ноль, то брать 1 уже нельзя.
Почему это так? Давайте нарисуем.
Понятно, что это самый длинный супрефикс.
По определению, самый длинный собственный суфикс равный префиксу.
Есть еще суфрефикс, отвечающий всей строке, но мы его не рассматриваем.
Тут можно еще написать i плюс 1.
Но это искусственный суфрефикс, который нам не нужен.
Дальше я вижу, что есть максимальный суфрефикс.
Как может выглядеть любой другой суфрефикс?
Такое замечание, что любой суфрефикс строки от s0 до si также является суфрефиксом строки от s0 до spb минус 1.
Давайте послушаем.
Суфрефикс является также суфрефиксом строки от s0 до spb минус 1.
Здесь все объясняется так.
У меня есть строка своего поитой. Я рассмотрел какой-то суфрефикс.
Например, такие две строки равны друг другу.
И при этом есть максимальный суфрефикс длины поитой.
То есть это какой-то произвольный суфрефикс, а это наибольший суфрефикс нашей строки.
Вот эти две гарантируют на равные и это наибольший суфрефикс.
А это просто какой-то произвольный, меньше длины.
Но тогда, посмотрите, поскольку у меня вот эти верхние душки одинаковые,
то я могу на самом деле вот эту вот штуку принести вот сюда.
А поскольку суфикс здесь равен префиксу здесь, то вот эта строка равна вот этой строке.
И тем самым, смотрите, у меня получилось, что в строке,
состоящей из первых поитых символов нашей строки, несколько первых символов,
но не несколько последних символов.
А значит, то, что было суфрефиксом строки S0, S1,
также является суфрефиксом строки от нулевого символа до вот этого вот P-1.
Поэтому все суфрефиксы этой большой строки, они на самом деле являются также суфрефиксами
всего, что было в строке от S0 до SPI-1.
Вот поэтому, если, скажем, у меня индуктивно уже доказано, что вот здесь вот все суфрефиксы описываются вот так,
значит к ним просто добавляется один вот этот максимальный P-1, и все.
То есть мы показали, что в дополнение к суфрефиксу длины P-1,
все суфрефиксы, кроме максимального, у нас уже были просчитаны,
когда мы обрабатывали эту строчку P-1.
И вот это утверждение оказывается, соответственно, индукцией по I.
Да, и мы видим, что когда мы переходим к новому I, у нас точно добавляется суфрефикс такой длины.
А все остальные, это просто перечтение суфрефиксов строки, вот здесь,
в которой индуктивно уже доказано, что это вот эта последовательность.
Окей?
Ну, тогда отсюда возникает алгоритм построения плетиспункции.
Чему равна P-0?
Да, конечно, потому что у строки длины 1,
ну и единственный собственный суффикс имеет длину 0.
Ну просто по определению.
Вот, а дальше пусть у нас уже посчитаны, пусть найдены P-0 и так далее,
P и P-1, мы хотим найти P.
Просто идем по строке слева направо, насчитываем итеративно все значения P.
Хотим найти P.
Значит, что у нас было? У нас была какая-то строка,
для которой я знал значение тешпульции,
то есть я не знал, что это значение,
а то я знал, что это значение,
для которой я знал значение х-кульции на всех позициях, пришел новый символ s и t
я теперь хочу в этой строке найти максимальный супрефикс
максимальный такой суфикс, который равен префиксу той же длины
при этом смотрите, если я просто отброшу последний символ из обоих кусочков
и отсюда и отсюда, то я получу супрефикс для предыдущей версии строки
потому что отбрасывание этого последнего символа
превращает в эту новую строчку вот супрефикс строки в млевого по имену первого символа
я здесь вычеркну, значит тут сохранено зарядство, поэтому вот супрефикс
и разве нужен самый длинный супрефикс, максимальный супрефикс моей новой версии строки
то мне нужно найти наибольший супрефикс в предыдущей версии строки, вот здесь вот
наибольший хабальчик, являющийся супрефиксом
который продлевается направо к тем же символам, что вот здесь
поэтому, чтобы найти по им
нужно найти максимальный супрефикс строки
с 0 и так далее, с и-1
да, вот максимальный хабальчик, справа от которого написан символ ровно с и
потому что если здесь вместо крестика написано с и, то я соответственно этот супрефикс продлеваю направо
с и, и получаю супрефикс для строки вот этой новой, да, с любой символ
чтобы найти по им, нужно найти максимальный супрефикс, справа от которого
написано с и
то есть, среди всех возможностей супрефиксов этой строки, я должен выбрать самый длинный
среди всех вот этих вот там супрефиксов, должен быть самый длинный такой, что справа
если его в начале приложить, то справа должен быть написан тот же символ, что вот здесь
и соответственно продление на один символ даст нам тот самый искомый максимальный супрефикс
а список всех супрефиксов мы знаем как получать
это вот это вот итеративное навешивание пшки на предыдущее значение супрефикс
ну давайте я начну с ж равно п и минус первое
дальше пока
так, сейчас, что там написано
на idea, и не равноiu- first-nd Persimmon
тогда sky, не равноiu- Oliver
тогда я понял, что�aires уже равно bg минус первую
вот, то есть, смотрите
у меняardg равно длине максимального супрефбица на предыдущем шаге
шаге P-1, а дальше я многократно от JIP прихожу к P-1,
то есть беру все меньше и меньше супрефиксы, до тех пор, пока выполняется это условие,
то есть пока JIP-символ вот здесь вот после этого овальчика, JIP-символ не равен
ИТОМ, тогда мне нужно еще уменьшать супрефикс. То есть я уменьшаю, уменьшаю, уменьшаю
супрефикс, пока первый символ после этого супрефикса не начнет играть без ИТОМ.
Так как только это условие нарушится, у меня соответственно ЭТО равна вот этому,
я могу продлить мой ответ, то есть могу увеличить JIP, увеличить этот супрефикс на единицу,
получить супрефикс, да, но быстрее. Я уменьшу вот так. Вот, ну то есть каковы стои выхода из этого овала?
Либо я дошел до адекватного супрефикса, справа от которого написано такое же символ как здесь,
и тогда выполняется вот эта проверка, и в точности G увеличивается, да, увеличивается
на супрефиксе, и по ИТО равно G становится. Либо же я дошел до G равно нулю, и у меня так получилось,
что даже нулевой символ вот здесь не равен вот этому, даже нулевой символ не равен вот этому.
Тогда после этой проверки G останется равно нулю, и по ИТО будет равно нулю.
Вот, ну еще раз, давайте проговорю быстро. Мы поняли, что нам нужно найти супрефикс,
какой-то супрефикс вот этой предыдущей строки, после которого стоит символ такой же как здесь.
Мы знаем, что чтобы перебрать все супрефиксы, их можно просто вот таким вот алгоритмом,
ну, интеративно навешивать, то есть вычитать единицу и навешивать плеер.
Мы делаем, делаем, делаем так, пока справа от этого супрефикса не будет написано республика.
Но в конце либо так и будет, и нам нужно будет увеличить этот супрефикс на один,
потому что много символ пришло. Либо мы дошли до конца, ни одного из наших супрефикса,
то есть если бы у нас было значение супрефикса справа, который был бы написан правильный символ,
то тогда, соответственно, G будет равно нулю, эта проверка не выполнется, и по ИТО будет равно нулю.
Вот, например, нарисуем еще.
Вот так.
Значит, смотрите, вот это, скажем, прошлая версия статьи, а это новый символ из ИТО равный B.
То есть у меня вот здесь вот значительные все супрефиксы, все значения этих функций,
это приходит новый символ B.
Скорой вопрос, чему равно Q вот в этой позиции?
Чему бы равно Q вот здесь?
Пять.
Еще варианты?
Еще варианты?
Семь.
Так, мне кажется, семь, потому что вот обоцамо, и вот обоцамо.
Суфикс равный префиксу. Никто не говорит, что меня не пересекаются, могут спокойно пересекаться.
Значит, вот здесь вот мы снимаем супрефикс, я длинусь семь.
Вопрос, если я просто этот супрефикс попытаюсь продолжить буквой вот этой такой же, как здесь,
она же здесь будет написана? Нет, да? C не равно B.
Берем следующий по величине супрефикс, вот это наша строка.
Ну и здесь уже, видимо, это будет ABBA.
Да, вот следующий супрефикс, он получается, собственно, вот так.
Взяли ABBA, справа от ABBA написано тоже символ, что здесь.
Опять нет, да, здесь C, здесь B.
Поэтому нужно опять брать еще меньше супрефикс.
Следующий супрефикс будет A, и справа уже от него написано B.
Взяли супрефикс, посмотрели на символ справа, он такой же, как нам нужно, такой же B.
Поэтому мы закончим на G равно единице, да, вот этот супрефикс зеленый A1 будет.
И потом увеличим его на 1 в этом эффекте.
И будет B, видно, равно 2, как знак того, что вот эти два символа равны вот этим.
Да, и значение B будет равным.
Значит, вот такой алгоритм.
Что по времени работа?
Ну, время работа здесь линейная, конечно же, от N.
Потому что, ну, давайте просимеем вот эту переменную G.
G всегда это значение последнего найденного P.
Да, последнее найденное значение предпочтения.
Вот оно очень похоже, да, это значение предыдущего найденного предпочтения.
Каждая интерация ВАЛы уничтожает G хотя бы на 1.
Потому что, что такое G равно G-1?
Мы рассматриваем с того, что у него уже минус первый символ, то есть строка длинной G.
И выбирая время, снимаем супрефикс.
Ну, понятно, что от этого G уменьшается.
Да, то есть мы находим вот такой супрефикс.
G от этого уменьшается.
Каждая интерация ВАЛы уменьшает G.
А увеличение G происходит максимально один раз для каждого I.
Ну, поэтому суммарно, а интерация G ВАЛ будет не больше, чем от это.
Да, потому что увеличивается эта переменная максимально единицу для каждого I.
Поэтому, ну, поскольку она всегда не отрицательна, уменьшаться она тоже не может больше, чем от это.
G это всегда последнее найденное значение предпочтения.
Каждая интерация ВАЛы уменьшает хотя бы на один, уменьшает G хотя бы на один.
И при этом каждая I, то есть, ну, каждая интерация ВАЛ цикла по всем I, увеличивает G максимально на один.
Каждая I увеличивает G не более, чем на один.
Значит, увеличение всего максимума N, G всегда не отрицательна, значит, и уменьшение, ну, максимум, видимо, ну, тоже R.
Да, то есть, если мы максимум N раз прибавили единичку, то уменьшить мы тоже можем максимум на R.
Значит, суммарно, все ВАЛы работают за R.
Да?
Ну, а все остальное это, там, понятные линейные штуки, это цикл по всем E от 0 до 1.
От 1 до 1, там всякие присвания, и все это все линейное время, то есть у нас, как часто бывает, проблема только в ВАЛе, но мы показали, что суммарно все ВАЛы работают максимум в OTA.
Значит, в время работы все это OTA.
Так, мы тогда вернемся, если мы научились находить эту струцию, мы вернемся к задаче о проверке вхождения.
Поверка вхождения П в С.
То есть давайте склеим такую строчку, давайте застрапим вот такую строку. Сначала напишем П, потом какой-нибудь разделитель, символ не входящий ни в П, ни в С.
Скажем, если П и С состоят из, там, маленьких патинских букв, то это может быть, например, решетка. Потом С.
Дальше, для такой строки посчитаем префикс-функцию, и если она хоть где-то равна длине П, в такой позиции префикс-функция равна длине П,
тогда оказывается, что вот здесь вот мы получили вхождение той строки, что была вот здесь.
Считаем префикс-функцию для строки П, пришел строк С.
Если она хоть где-то, ну давайте не так, что я напишу, что каждое значение префикс-функции равно длине П, автоматически гарантирует нам, что только что кончилось вхождение П.
Потому что если где-то значение функции равно длине П, значит, мы получили субпрефикс длины в точности такой, то есть П этот суфикс равен такому префиксу. То есть мы получили вхождение строки П.
Всякий раз, когда значение префикс-функции равно длине П,
мы получаем вхождение П в С.
И при этом значение префикс-функции никогда не может быть больше, чем длина П.
Потому что если бы где-то было, скажем, больше, чем П, это значит, что вот такая строка равна такой, но, извините, решетка у меня только один раз встречается, поэтому никакой сдвиг этой строки не может мне сохранить решетку.
Если я говорю, что такая строка равна такой строке, значит эта решетка где-то еще встречается в другом месте, а такого не бывает. Мы решетку специально взяли, что она уникальна.
Поэтому префикс-функции никогда не может быть больше, чем длина П. Ну а значение меньшее означает, что здесь не целиком входит П.
А давайте еще раз рисуем вот здесь вот.
Если где-то здесь значение префикс-функции меньше, чем длина П, это значит, что какой-то такой суффикс равен этому такому префиксу, но нельзя это продлить, нет большего суффрефикса.
Поэтому, в частности, вот эта штука не является суффрефиксом, а значит здесь не заканчивается вхождение П.
Поэтому нужно просто отследить все значения префикс-функции. Каждый раз, когда оно равно длине П, мы получаем, что вот здесь вот получилось только что вхождение этой строки П.
Если оно меньше, значит оно здесь не получилось. А больше, ну не бывает.
На самом деле можно, конечно, явно не вставляя здесь разделитель, можно было бы просто их склеить подряд П и С, но тогда нужно было бы как раз проверять на нестрогое равенство,
что значение префикс-функции должно быть больше равно, чем длина П, тогда как раз это бы означало, нет, это бы не означало.
То есть почему без разделителя нормально не получится? Потому что если я напишу их подряд, П и С, и буду, скажем, проверять на равенство в точности П,
больше равно, чем П. Если я получил значение префикс-функции больше равно, чем длина П, то это говорит х знает о чем, это говорит о том, что где-то вот здесь раньше оно было, это вхождение.
А дальше будут какие-то символы, которые равны вот этим вот символам. Но, извините, я это вхождение и так бы нашел, когда вот здесь вот стоял,
у меня было бы значение префикс-функции, вот это вот равно вот этому. Да, и здесь опять префикс-функции была хотя бы длина П.
Поэтому без разделителя, ну, наверное, можно это как-то модифицировать, но слишком, короче, вот из-за того, что у меня бывают вот такие вот супрефиксы,
которые частично содержат П и частично содержат начало С. Это, в общем, нам немного портит понимание и проще вставить здесь что-нибудь такое эффективное,
которое запрещает префикс-функции вылезать направо. Вот здесь вот не может быть значения префикс-функции больше, чем длина П. Вот.
Илья, он же ломается, когда у нас префикс будет, значит, второй префикс будет заходить на П.
Ну, типа раз второй префикс, ну, супфикс начинается с П. Да. Типа он заходит на П. Не-не-не-не, он заходит на часть П, которую мы написали сначала.
Когда супрефикс пересекается в П. Да-да-да-да-да-да, когда они пересекаются.
Типа вот что-то такое, или что? Да. Так, и что? Ну он ломается, потому что у нас часть П задействовала.
Можно просто не смотреть. Можно просто не смотреть на все... Да, но в общем-то я дичь против этого не понимаю.
Да не страшно вы, нет, но, в смысле, алгоритм все равно плохой, учит решетки, но можно просто не смотреть на первую каштуку с РКС.
Почему на РКС? Надо только первую каштуку с РКС ломать.
Ну, смотрите, а если у нас есть супрефикс, даже который заходит на строку П, не важно, но у которого хотя бы...
Ну, короче, который кончается дальше чем-то через свой символ от начала с РКС, то это означает...
Ну, и он, ну, вся в УП, то это означает, что...
То есть такое-то может быть сколь угодно далеко с РКС, вот это вот перекрытие.
Ну, может быть, сколь угодно там на правую ходить.
Короче, да, то есть может быть и можно как-то подхватить, но на первый взгляд не видно как, прочность решетки.
Так, еще один алгоритм, это Z функция, которая считает какую-то, ну, в общем, похожую статистику,
которая считала предыдущую функцию, только, ну, короче, немножко в другую сторону.
То есть опять пусть есть строка S0 и так далее, Sn-1.
Мы хотим насчитать значения Z0, Z1 и так далее, Zn-1 такие, что Zn это максимальное значение K,
такое, что строка длины K, начиная с китого символа, равна префиксу той же длины.
То есть картинка такая, мы стоим в позиции И, а затем прыгнем как можно дальше направо, чтобы это было равно вот этим.
То есть если раньше, когда мы считали префикс функцию, мы прыгали как бы влево, мы не рассматривали все, что правее,
и хотели взять как можно больше суффикс, равный префикс.
То есть теперь, наоборот, мы идем как бы направо и берем символы направо, которые равны тому, что было написано в начале.
Вот. Ну давайте я вам поделение.
Z-блок это вот ровно такая штука, ведущая направо, равная тому префиксу.
З-блок это подстрока равная подстроке из первых кассировок.
То есть мы как бы идем слева направо по строке, и когда мы нашли какое-то значение Z и T, мы будем вот это называть Z-блок.
То есть все вот эти вот штуки, давайте вернусь, все вот эти подстроки, ведущие вправо, равные префиксу той же длины, мы будем называть Z-блок.
И для нашего дейта мы будем хранить Z-блок с максимальной правой границы.
То есть среди всех Z-блоков, которые мы нашли, я буду хранить тот, в котором как можно большая вот эта правая граница, вот эта.
И давайте я буду говорить, что этот Z-блок имеет координаты стрель по R.
Соответственно среди всех Z-блоков я храню, поддерживаю Z-блок, который равен R максимально.
Ну вот и этим тогда так вот. Скорейший парадокс, который равен Z0 по определению.
Вся строка, ну опять, это неслежательная информация, какая бы ни была строка, зато и равна ее длине, поэтому на нулевой значении, что префикс функции, что Z функции мы можем даже не смотреть.
Тут ничего полезного не написано никогда.
Вот дальше, ну там стрель давайте считаем, что R минус 1, пока мы не нашли ни одного Z-блока.
Ну и в цикле от одного до N будем делать следующее.
Значит, смотрите, пусть мы нашли уже какой-то Z-блок.
Ну в какой-то ситуации, когда R и R равны уже чему-то осмысленному, в какой-то подстроке равной префиксу длины, пусть, например, E попадает в это вот сюда.
То есть мы нашли значение Z здесь вот везде, теперь мы надеем на E, Z и D.
И пусть так вышло, что E выпало вот рядом под R.
Тогда можно писать следующее, смотрите.
Я, наверное, перерисую, чтобы было еще более видно.
Так, вот был какой-то Z-блок, и попало вот сюда.
Вот, и я хочу как-нибудь оценить значение Z и D, зная все вот эти значения Z-ки левее, чем Z и D.
Посмотрите, поскольку это Z-блок, то, соответственно, вот это вот все равно вот этому всему.
Z-блок это строка равной префиксу длины.
Поэтому, если я как бы эту точечку перенесу вот сюда, то есть параллельно сдвину эту строку на позицию E-D, то локально вот эта вот строка устроена ровно так.
Все символы здесь равны всем символам здесь.
Эта строчка равна.
И поэтому, в частности, я могу сказать, что Z и D точно больше или равно, чем Z и E-D и E-D.
То есть я отвержаю, чтобы всегда вернула вот такая вот оценка.
Почему?
Ну, что такое Z и E-D?
Это максимальный Z-блок вправо начинается в этой позиции.
То есть это вот несколько таких вот первых символов здесь, которые равны вот этим.
Если эта штука не вылезает за вот эту большую строку, за вот этот максимальный Z-блок,
если это не вылезает за границу максимального Z-блока, то тогда, раз это равно вот этому, то это равно вот этому.
Потому что когда эта строка и параллельно перемещенная, значит эта штука приносится сюда, и я получу, что это равно вот этому.
Я получу как раз Z-блок сначала в E.
И из-за того, что эта не вылезает за R, соответственно, все эти символы точно они все будут.
Если же эта вещь вылезает за границу моего найденного Z-блока, тогда картинка чуть хуже.
То есть я знаю, что вот эта равно вот этому.
Но про вот это я ничего не знаю. Я не знаю, что располагается вот здесь.
Я не могу сказать, что вот эти символы также равны вот этим символам.
Потому что все, что находится правее R, это уже какая-то черная зона.
Здесь непонятно, что. Эти символы не обязательно равны вот этим.
Поэтому, если у меня Z и минус 3T вылазят за границу вот этого большого Z-блока,
мне нужно его обрубить и сказать, что он не больше, чем вот этот самый.
Короче, не вылезает за R. Это характеризуется вот этим числом R.
То есть если Z и минус 3T было достаточно большое,
то его нужно обрубить по вот этой длине от и до R.
То есть не больше, чем до R-минус 3T.
Я потерялся от почему.
Тогда у нас в котором классе был бы больше символов?
Еще раз?
Если бы эти полиции совпадали, а символ, который у нас попал, не был бы больше.
То есть, если полиции совпадают, то Бог мог бы поверить, который получается.
Дай секунду, давай подумаем.
То есть если у нас следующий символ совпадает,
у нас Вовка наканчивается DPR, а у нас плюс один.
Где свой максимальный?
Мы еще не проверили, что он совпадает.
Сейчас, сейчас, сейчас.
А если не совпадает, то цена будет строгая.
То есть если не совпадает, то там Вовка строгая.
У нас важный термин?
Не, сейчас еще раз.
Посмотрите, пусть здесь Z в этой позиции.
Вот вылезает ZL.
Что это значит?
Значит, вот эти символы, вот эти блоки.
Ну да.
У нас ALR это блок.
ALR это Z блок.
То есть вот это равно вот это.
Но правее нельзя продлить.
Это значит, что вот это не равно вот этому.
Еще раз.
Раз это Z блок, то значит вот эту границу R нельзя сдвинуть направо.
То есть то, что написано вот здесь, вот не равно,
то можно написать здесь под вопросиками.
Там раз, когда оно еще и диапевтикс тоже не равно.
То есть у нас равно слева два.
Ну.
И один из них не равно правому блоку.
Значит, второй блок тоже не равно.
То есть это значит, если не ходится в блок.
Да?
Не понятно.
Не понятно, да.
Мне вопрос.
Мы все знакомы, один по три.
Мы знаем, что кружочек один по два равный.
Да.
И кружочек...
Первый символ в блоке не равен к первому символу в тройке.
Так.
Кружочек тренируется к кружечку два.
Да.
Значит, он выше тренируется к кружечку два.
Да.
И что?
Ну тогда у нас совершенно нет Z блока.
Почему?
Потому что кружочек один.
ALR или Z блок?
Это должен быть.
Тогда Z блок ограниченно подвиняет.
Еще раз.
Z блок ALR?
За блоком начинаются языки, конечно, с правого границы.
А, ну да.
Ну с того же ровно это здесь и написано.
А в чем я работаю, что не право?
Ну это верно и не нравится.
Ну то есть в этом случае мы не можем сказать, что он просто равно.
Да?
Ну, по-моему, да.
Ну, здесь тем не менее написано верное.
Да, все ладно.
Ага.
Вот.
У нас уже посрочная.
Угу.
Ну у нас посрочная эта с того же Z и ZZ.
И так же Z.
Да.
Ну, значит сейчас, сейчас, сейчас, сейчас, сейчас забьем.
Значит, итак.
Мы получили хоть нижнюю оценку на ZZ.
Не, что-то все перечеркано уже.
Мы получили нижнюю оценку на ZZ.
Затытая. Тогда давайте, чтобы найти точное значение затытая
будем пытаться просто затытая на 1 увелич researched.
То есть мы точно поняли, что несколько вот этих символов равны вот этим.
Тогда давайте просто идти слева направо увеличив下去 пытаться на 1
До тех пор пока эти символы не совпадают.
Пока совпадают, будем идти направо и увеличиваться.
Если он внутри блока, то знает, а если он вот здесь, то тоже на самом деле может, оно может увеличиваться направо.
Сейчас, в общем, давайте я напишу, значит, то, что мы бы тогда и сделали. Мы написали, что z, y, t равно минимум из z, y-a, d и r-a, plus 1.
Дальше, пока i плюс z, y, t меньше чем н, и s i плюс z, y равно s z, y, мы делаем плюс плюс z, y.
Значит, еще раз, мы здесь получили какую-то нижнюю оценку, а дальше мы понимаем, что если есть нижняя оценка, то чтобы получить точное значение z, y, можно просто идти слева-направо и перевернуть символы до тех пор, пока они совпадают на те, которые нужны вот этим вот.
Мы просто увеличиваем z до тех пор, пока они равны. Просто простым ваилом. Пока вот здесь равно 1 увеличен, следующий равно увеличен и так далее.
Соответственно, i плюс z, y это первый непростонный символ вот здесь, а z, y это первый непростонный символ вот здесь. Пока они равны, их можно увеличить.
Вот, и тогда смотрите, что я утверждаю. Я утверждаю, что если мы хотя бы раз вошли в ваил и выполнили увеличение z, y, то это тогда обязательно случай, когда вот здесь среди этих значений минимум попался вот сюда, r-1.
Потому что если, скажем, из этих двух значений минимально было вот это, то оно было строго меньше, чем вот это.
Давайте я опять нарисую картинку. Вот был какой-то z-блок, вот была i, вот была i минус a.
Скажем, вот z минус a не выходило за границу этого z-блока. Тогда мы точно знаем, что то, что написано вот здесь, вот x, не равно тому, что написано вот здесь z-блок.
Потому что здесь по переносу написан x, а это z-блок нельзя увеличить, потому что z-блок карминально, поэтому здесь стоят разные символы.
Значит, и здесь стоят разные символы. Поэтому если z и минус r меньше, чем r минус r-1, то z-блок мы точно знаем, что равно z-минус 1.
И оно уже увеличиться не будет. На, еще раз. Если я переношу параллельно вот этот z-блок вот сюда и понимаю, что z-минус r-д не выходит за границу,
точнее, находится левее границы z и минус r, то есть такой строгой нерайс выполняется, тогда это значит, что этот блок, равный и вот этому, и вот этому, нельзя пролить направо.
То есть этот символ не равен с лучшему в начале строки. Поэтому ваил не исполнит нам ни одной итерации, у меня уже точно найдено значение z, z-минус z.
Вот, а иначе у меня будет увеличиться правая граница.
Что происходит у нас? z и минус l, наоборот, больше всего значим r и минус r-1.
То есть вот здесь вот z-блок, вот этот z-минус r-д равно вот этому, а если мы проложим сюда, то оно выходит за границы нашего lr-блок.
Тогда я обрублюсь вот на этой позиции r, скажу, что изначально z и t равно r-минус 1, минимум за какие-то значения это r-минус 1.
А дальше, если вдруг будет выполняться итерация цепловая, то я буду находить все новые и новые символы справа, которые равны новым символам вот здесь.
То есть я здесь также обрубился и иду направо, пока они равны.
Тогда у меня сдвигается граница r каждый раз. Если у меня происходит увеличение z и, то значит я нахожусь все более и более правой z-блок.
Двигается эта правая граница, я выхожу из-за предела r, двигается правая граница. То есть, смотрите, каждая итерация цепловая, успешная,
задвигает направо хотя бы на один правую границу нашего z-блока.
Значит, это симпатичная линия, потому что эта правая граница не может двигаться больше чем на раз.
Значит, вывод, каждая выполненная итерация вайла
сдвигает самый правый z-блок направо.
То есть раньше был вот этот z-блок lr, а потом мы нашли такой, у которого правая граница правее чем r.
Потом еще z увеличилось, правая граница еще подвинулась и так далее и так далее.
Каждая итерация вайла увеличивает нам r, хотя бы на один.
Поэтому суммарно все вайлы работают за ot.
Поэтому весь алгоритм тоже имеет.
Еще раз говорю алгоритму. Мы заводим z ноль равно тому, чему нужно.
lr пока что не надо ни один z-блок, lr равно минус 1.
Потом идем по строке слева награбленного. Берем z и его добавляем.
У нас есть вот такая оценка. Давайте тогда просто в качестве z и положим минимум эти два значения.
Мы знаем, что r точно больше равен чем то, что мы туда положили.
Давайте просто его пытаться итеративно вступу и пытаться увеличивать.
Вопрос о равно ли следующее? Если равно, то увеличиваем z-блок.
А равно ли следующее? Если равно, то увеличиваем и так далее.
Пока не найдем различные силы.
И в конце после этого вайла нужно не забыть обновить lr.
Если найден z-блок только что найден, то есть с i по i плюс z и минус 1.
Если эта штука правее, чем предыдущий блок lr, то нужно обновить наш максимальный z-блок.
Здесь давайте напишем.
То есть мы теперь нашли z-блок за границами год i, до i плюс z и минус 1.
Соответственно, если его правая граница больше, чем r, она находится правее, чем тот предыдущий максимальный z-блок,
то нужно пересчитать границы.
Сказать, что lr это i, а r это i плюс l и минус 1.
Тем самым, опять, lr это самый правый среди всех найденных z-блоков.
То есть если я нашел какой-то более правый, с большей правой границей, то мне нужно эти границы пересчитать.
Ну и все это когда видно, что это линейное время, потому что все вайлы суммарно работают за линейное время.
То есть тут опять на каждой конкретной итерации i этот вайл может работать довольно долго.
Перебирать силы до первой пары неравных может довольно долго, но суммарно все эти вайлы по всем i работают максимум от l.
Ну видимо даже просто не больше н, потому что каждая итерация вайла увеличивает правую границу на 1, а она не может увеличиться больше н.
Ну и тогда, наконец, опять задача проверки вхождения.
П вкс.
Давайте опять воспользуемся тем же трюком.
Напишем P, решетка S.
Где вновь решетка, это какой-то уникальный сил, который нигде больше не встречается, ни в кой, ни в с.
Тогда каждая позиция, где z функция равна в точности длине P, отвечает началу вхождения вкс.
Если вот здесь z ита равно длине P, значит следующие столько силов равны префинсу той же длине, то есть просто P.
Ну и здесь решетка точно совсем не к чему.
Верно.
Давайте сначала отмечу, потом замечание ваше тоже отмечу.
Всякий раз, когда значение z функции равно длине P, получаем начало вхождения вкс.
Ну и опять из-за того, что я здесь ставил решетку искусственную, у меня значение z функции никогда не может быть больше, чем P.
Если оно было бы больше, значит решетка где-то еще правее бы встречалась.
Чего быть не может по предположению, потому что это уникальное.
Если же здесь написано что-то меньше, чем P, значит вот это вот равно вот этому, а продлить нельзя.
Если тут z функция меньше, чем длина P, значит P здесь не помещается.
То есть какие-то символы, да, возможно, равные, но продлить это до всей P вот здесь нельзя.
Поэтому только те и только те позиции, где z ита равно P, нам подходит.
Это в том числе начало в хранении P вкс.
И больше никаких.
Вот, ну как правильно заметили, здесь решетка менее важна, чем при этой функции.
Если я просто склею без разделителя P и S, то мне достаточно будет проверять все хранения, все позиции, где z ита больше, равно чем P.
Вот если здесь z ита больше, равно чем длина P, тогда, ну, как ни крути, вот эти вот, да, возможно, какие-то символы равны вот этим.
Но главное, что вот эти вот, равны вот этим.
То есть каждый раз, когда z ита хотя бы длина P, я получаю начало в хранении P.
А то, что там правее, ну, вовсе, вот эти равны вот этим хренственным.
Главное, что вот эти вот штрихованные равны штрихованным.
Поэтому в этом случае даже не обязательно решетка, но когда здесь правильство, значит, цена не строгая, не равна такой.
Каждая позиция, где z ита больше, равно чем длина P, отвечает начало в хранении P вкс.
Все, спасибо.
