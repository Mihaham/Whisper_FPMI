Я предстоит обсудить следующие два контейнера, а если успеем, то и три.
Мы сейчас начнем обсуждать, как устроен лист, потом мы пообсуждаем, как устроен STD map,
а если повезет и мы успеем, то еще и обсудим, как устроен STD unordered map.
А на второй паре Федя вам дальше порассказывает про итераторы.
Значит 8.8.5.
Поясняю, у вас параграф 8.3 это был вид итераторов и advanced distance категории итераторов.
Вот, примеры использования итераторов.
Параграф 8.4 это был пример реализации итераторов для класса Vector.
Константный и неконстантный итератор, реверс итераторы.
Вот, поэтому параграф 8.5 это STD list и STD forward list.
В этом же пункте обсудим.
Лист будет вашей следующей задачей, кстати.
Но там основная сложность будет не в самом листе, а кое в чем другом, но пока...
Ну exception set это тоже проблема будет.
Там еще будут аллокаторы, но это мы потом обсудим.
Пока что мы просто обсуждаем, как устроен лист.
Ну, лист это связанный список, как вы знаете, двусвязанный.
Это значит, что в нем что поддерживается?
В нем поддерживается push-back.
Ну, push, pop, back, front.
Вот и push и pop, и в начало и в конец есть и работает оно за вот единицы.
А еще есть insert в середину по итератору.
И race из середины по итератору.
Вот, что такое insert?
То есть вы передаете итератор.
Вот, именно по этой причине нужно было итераторы изучить до обсуждения листа.
Потому что уже рассказывать, как устроен лист, без понимания, что итераторы нельзя.
Вот, ну теперь вы уже знаете, что итераторы, поэтому мы можем полноценно обсудить, как устроен лист.
Ну, потому что в связанном списке нет никакой индексации.
Нельзя по индексу обращаться к элементам связанного списка.
Если бы и можно было, то это бы работало за линейное время.
Ну, потому что понятно почему, это же связанный список, там хранятся вершины указателями провязанные.
Поэтому обращаться к элементам списка, если как-то и можно, то обычно по итератору.
Вот, и как правило, если у вас и есть какая-то работа со связанным листом, то вы имеете дело с итераторами.
Так вот, insert вы делаете по итератору, вот.
И вставляете, значит, туда какой-то элемент.
И race вы можете делать по итератору.
Вот, ну еще вы можете вставлять диапазон.
То есть вы можете сделать insert по итератору и еще пару итераторов передать.
Тогда он просто скопируя, вставит все элементы данного диапазона.
Да.
У меня сбилась номерация.
Итераторы, какая была итераторская?
8.3, да.
Дальше 8.4, это была реализация итераторов.
Например, vector, а также constant и reverse итераторы.
Вот, 8.5, test the list.
Да, в этом году у нас будет такая сквозная номерация.
То, что вам рассказывает Федя, будет, значит, вписываться в общий список того, что вам рассказываю я.
И race тоже можно делать по диапазону.
То есть можно делать и race, и пару итераторов передать.
Тогда он долит все из этого диапазона.
Разумеется, это работа за линейное время и длины диапазона.
Вот.
Ну, все вот это работает, загарантированное от единицы.
Потому что это связанный список.
Вот.
Как это реализовано?
Ну, в принципе, с точки зрения алгоритмов-то понятно как, я думаю.
Тут нечего особо обсуждать, что как связанный список реализовался с алгоритмической точки зрения.
Как это реализовать с точки зрения красивого кода, скорее, стоит обсудить.
У нас в листе, какие есть...
Ну, вот давайте представим, что я так реализую класс-лист.
Вот у меня есть темплейт.
TypeName.t
Class-List.
Что в нем примерно находится внутри?
Так упрощенно.
Ну, будем считать, что private-часть пока мы пишем.
Вот.
В листе должны быть какие-то ноды.
Да, ну, элементы связанного списка, которые хранят указатель на предыдущий элемент и на следующий элемент.
То есть, на самом деле, в листе должен быть еще внутренний класс.
StructNode.
Кстати, к вопросу о...
Вопрос, который в чате задавал господин Барыкин про приватность полей у приватных классов.
Вот у меня в листе есть приватная структура Node.
И у нее публичные поля.
Вот, а когда я по итератору обращаюсь к листу, я таким образом получаю доступ к публичному полю структуры, хотя структура-то приватная.
Ну, вот тебе еще один пример, почему это так не должно работать, как ты хотел бы.
Ну...
Нет, сама структура-то публичная, поэтому в чем проблема?
Нет, структура приватная.
Ну, мы же в мире...
Мы получили объект этой структуры.
Да, да, да.
Но вопрос был... Да, конечно, вопрос был в том, почему, имея, значит, доступ к публичным полям приватной структуры, мы, тем не менее, не получаем ошибку доступа.
Так вот, структура Node, что в ней лежит?
В ней лежит, собственно, t-value.
Вот это вот значение листа.
А еще два указателя.
Node звездочка prev и node звездочка next.
Ну...
Скорее...
Вряд ли там Node что-то другое.
Ну...
Там...
Скажем так, вряд ли, вот...
Прям так, как я напишу, на самом деле.
В STL, конечно, все гораздо сложнее.
Нет, я хочу именно указатели хранить.
Вот.
А...
И...
Кстати говоря...
Мм...
Сейчас...
Через некоторое время станет понятно, что вот это
не совсем хорошо
так делать, как я сделал.
Причем самый лучший?
Причем самый лучший.
Ну...
А...
Я не знаю.
Я не знаю.
Возможно, там точно не это.
Вот 100% там не так.
Там все гораздо сложнее и хуже.
Там куча оптимизаций.
Наверняка там еще какой-нибудь
стоит шаблонный
мета-проверяльщик.
Если здесь там какой-нибудь тип маленький,
то это можно как-нибудь получше упаковать.
Там поля переупорядочить.
Там все, конечно же, гораздо сложнее написано.
Вот.
Но мы не будем париться о таком.
Пока на простом уровне считаем.
На уровне средней школы, да.
Совершенно верно.
Так вот.
Хорошо.
Есть такая структура.
У меня вопрос.
Что
хранится в полях листа?
Ну, указатель на начало и конец?
Вот.
Указатель на начало и конец.
А если лист
пустой, то что там должно быть?
Вот. Я вам могу сразу сказать
самую распространенную ошибку.
Ну, одну из самых распространенных ошибок в реализации листа.
Половина из вас ее точно сделает,
несмотря на то, что я это сказал.
Значит, если лист
пустой,
то он не должен аллоцировать никакую память.
И никакие объекты value, конечно же,
он не должен создавать.
Тем не менее, это все равно каждый год кто-нибудь так сделает.
Если лист пустой,
то никаких ноут создано быть не должно.
Конечно же.
Потому что вообще у Тэни обязан быть конструктор
по умолчанию.
Что же делать?
Ну, надо, можно хранить
NullPTR. Хорошо, давайте будем
хранить NullPTR. То есть
ну, мы как бы
ну,
будем, пока считаешь это
указатели, будет у меня
такое поле бег.
Ну,
бегин я не могу его называть, потому что
это название метода, будет коллизия
с ним.
Я буду вот так делать.
Ну, так покороче
просто.
На доске
можно, на доске разрешено
в целой краткости сокращать переменные. В коде
Нет.
Нет, если
ты напишешь распознавалку,
и оно еще тесты будет проходить.
Можно пробовать, как сейчас модно,
чат GPT.
Вот я на лекции услышал вот это.
Не можешь ли, пожалуйста, написать мне код, который
бы в контест прошел согласно вот этим вот
рассказам лектора. И чат GPT такая, конечно.
Что, вы не следите за трендами?
Чат GPT?
Да ладно.
Спроси у них, они тебе расскажут.
Хорошо.
Тогда вопрос. Если
я создаю
пустой лист,
и беру...
Ну, короче, вопрос такой. Как мне
что из себя
будет представлять итератор на начало и итератор
на конец листа?
Ну, вот если лист пустой, то что должен из себя
представлять итератор? Он должен хранить
на OPTR?
Вообще говоря, конец
это всегда.
Ну, почему бы, кстати, и нет?
Проблема
с хранением NullPtr в итераторе заключается
вот в чем.
Из End надо уметь
декремент делать. У нас в листе
bidirectional итераторы.
А bidirectional итераторы, они должны
позволять
делать плюс-млюс-минус-минус. В частности,
есть требование, что если вы декрементируете
End, вы обязательно получаете последний элемент,
чтобы reverse итератор работал.
Декрементировать это называется.
А begin
декрементировать ты, да, не обязан.
И begin, если список пустой.
И begin, я не обязан.
Нет, если список не пустой,
то что такое итератор N?
Если у меня хранится
в End NullPtr
и мне делают minus-minus-end,
я должен вернуть указатель на последний элемент
списка, где я его возьму. И это должно за вот единицы
делаться.
А что хранить-то?
В End.
В итераторе End хранить последний элемент?
Так это и есть.
Хорошо, а там что хранится?
Erbegin это просто другое слово.
Нет, Erbegin, как мы выяснили
в прошлый раз, хранит как раз End,
просто он декрементирует при обращении
к нему.
Ага, это идея, которая часто
приходит людям.
Я вам сказал, что очень популярная ошибка
это попробовать в листе в пустом
хранить фейковую ноду.
Самый популярный способ ее исправления,
когда людям говоришь, так нельзя делать
и говорят, хорошо, давайте тогда в нодах будем
хранить не ты, а ты звездочку.
У нас будет как бы лист, в котором в нодах
хранятся не сами объекты, а указатели
на объекты. А эти объекты мы
то инициализируем, то нет.
Нет, это конечно плохая идея, потому что
это очень, ну, это накладные расходы
на производительность, совершенно ненужные.
Потому что вам придется, обращаясь
к вершине листа, каждый раз делать прыжок по указателю.
Вам и так-то
когда вы ходите по листу,
нужно постоянно прыгать по указателям.
А так, вам обращаясь к элементам листа, каждый раз надо
два прыжка по указателям делать.
А мы можем сделать вот эту память
не инициализированную просто?
Сделать фейковую ноду, над ней хранить не инициализированную память?
Да, это третья идея.
Вот.
А вы сами понимаете, какими недостатками
было? Ну вы можете, то есть здесь можно
сделать пример следующий. Здесь можно сделать
массив чаров размера size of t,
там с нужным выравниванием,
но про выравниваем пока не говорили.
И да, просто в нужный момент
натравливать на него конструктор, ну а если список пустой,
то просто в нем фейковая нода есть, которая
в ней
массив чаров,
да, но там объекта t не
создана.
Ну, мы хотим создать
фейковую ноду, которая бы как бы существовала
всегда,
даже в пустом списке, но мы не должны
создавать объект t в пустом списке.
Чего?
Чего?
В общем, слушайте, давайте я...
Ну,
то есть ты предлагаешь по-прежнему хранить NullPtr
в Энде?
В Энде?
В Энде хранить последний элемент?
Да.
И как тогда сравнивать с End?
То есть каждый раз при сравнении итераторов,
ты проверяешь, если это последний элемент,
то надо отдельно проверить это End или это настоящий
последний элемент?
Что?
К чему?
Как ты поймешь, что это End?
Вот тебя сравнивают два итератора.
Нет, у тебя есть метод сравнения
итераторов на равенство, например.
И оба итератора указывают
на одну и ту же вершину,
но один из них реально указывает на последнюю вершину,
а другой итератор это End, который у тебя тоже указывает
на последнюю вершину.
Что значит во внешнем мире?
То есть ты хранишь флаг, это End или это настоящий
итератор?
Ну, тебе в итераторе...
Что хранить в итераторе?
Ну, в итераторе, по идее, мы храним тоже указатель
на ноду.
То есть в структуре итератор...
Ну, я напоминаю, что на самом деле
это не структура итератора, а структура
Base Iterator, которая параметризована
шаблонным параметром const или не const.
Ну, давайте я для простоты
назову ее просто Iterator.
Это тоже внутренняя структура листа, и в ней тоже
хранится указатель на ноду.
ПТР.
Вот. И вы предлагаете...
Вот проблема с тем, как
красиво обработать случай End.
Короче, я не буду вас больше
допытывать вопросами, я просто расскажу, как...
В общем, наиболее
красиво известный мне способ это делать,
который будет рекомендоваться вам всем.
На самом деле есть такая хитрость,
и так, кстати, сделано, по-моему, в STL в том числе.
У нас будет две
структуры. У нас будет структура Node,
а будет структура Base Node.
Очень красиво. Сейчас вы увидите,
почему.
У нас будет структура Base Node,
которая хранит
Node звездочка,
которая, в общем, хранит два указателя.
А структура Node,
она наследница
Base Node,
и хранит еще
две.
А теперь мы следующую вещь
делаем. Мы храним список
в закольцованном виде.
У нас есть всегда
вот эта фейковая вершина, Base Node,
которая есть у любого
списка,
и мы начинаем...
Когда у нас
в списке появляются реальные элементы,
то у нас Begin
это вот этот вот элемент,
а End это вот этот вот элемент.
И указывают они вот так
друг на друга. То есть вот это Next.
Следующий за
Node это фейковая
вершина. В ней не лежит
T, и она
является таким маркером конца
списка.
Вот.
А храним мы теперь не указатель
на Node, а указатель на Base Node.
И здесь мы храним указатель на Base Node,
конечно.
Смысл в том,
чтобы у тебя
End и вычитание из End работало
корректно и без костылей.
Чтобы тебе, во-первых, не приходилось создавать
End указатель на NullPtr,
который непонятно как декрементировать.
Еще у тебя End от разных списков,
это по идее должны быть разные указатели.
Ну, по крайней мере, если
ты копируешь до End одного списка,
то ты не должен...
Кстати, я не уверен,
что это формальное требование стандарта. Может, этого и не должно быть.
Но в любом случае у тебя должно...
Ну да, наверное, такого требования нет,
что End от разных списков это разная штука.
Но вот в нашей реализации это будет.
Из Base Node никак?
А, в смысле, как вы...
Ну, вы
будете Cast делать, да.
Static Cast.
Чего?
Оно и так публичное.
Структуры.
Это лист с одним элементом так выглядит.
У листа с одним элементом
на самом деле две вершины,
и они в кольцевой список закручены.
Вот это Begin, а вот это End.
Но в End не хранится значение.
Если это End, то я пытаюсь сделать Static Cast,
и если не удалось...
Когда ты проверяешь на End,
тебе на самом деле теперь в полях
достаточно хранить всего один указатель.
Ты можешь хранить в полях самого листа
тебе достаточно хранить
просто указатель на
вот, не знаю, как хочешь его назови,
Start. Ты знаешь, что
если в твоем листе есть один элемент,
то он следующий после вот этого.
Ну, мы храним вот этот вот
элемент, который на самом деле указывает
на, я не знаю, на fake node.
Да, и это base node, конечно.
То есть мы
от другого костыля пришли к другому.
Но мы
не хотели создавать фейковую вершину,
поэтому создали ее тупо без значения.
Мы хотели...
Ну, фейковая вершина,
я бы не сказал, что это костыль.
Чего?
Мы реально создали фейковую вершину.
Но просто мы не
положили в нее t.
Нам нужно, чтобы была
какая-то штука, маркер конца списка,
в которой бы не лежала t.
Но мы не можем создать объект типа node
для этого, потому что объект типа node
подразумевает создание объекта t.
И дальше мы могли бы пытаться сделать
массив чаров вместо t и вручную new
туда пихать каждый раз и delete.
Чего?
Потому что нам теперь не нужно хранить...
Потому что мы теперь даже сэкономили память на список.
Нам теперь не нужно хранить указатель на начало и конец.
У нас всегда один указатель.
У нас у любого списка есть вот это вот,
маркер конца списка.
Фейковая вершина.
А если список начинает пополняться элементами,
то они вот так вот в круг выстраиваются.
И в конце он закольцован.
Следующий элемент он всегда
приводит к base node.
Ну, от base node мы формально не имеем права
брать.
Но вот если мы берем преф от base node...
Да, если мы берем преф от fake node, то мы получим begin
в случае одной элементного списка, как и должны.
Next это детали нашей реализации.
Next мы тоже получим, но это не по стандарту.
Нет, мы должны получать...
И мы должны предыдущий элемент от end получать
нормальным элементом. Вот это у нас теперь
обеспечено.
Нет, не на lptr там.
Там вот указатель
на эту вершину, которая создается...
Вот в конструкторе надо написать,
как она создается.
Кого выделять в куче?
А я не сказал, что в куче
выделяется.
В итераторе?
А, вот здесь.
Да, это правда.
Совершенно верно. Это я забыл сказать.
Это следующая идея.
Правильная идея. Теперь мы понимаем,
что нам даже не нужно указатель...
Нам ее можно просто на стеке выделить.
Нам не нужно даже хранить указатель на нее.
Нам достаточно хранить просто ее саму
в полях листа.
Саму эту вершину можно
хранить в полях листа, а не указатель на нее.
Потому что...
Пустой лист использует два указателя
памяти, да.
Бейсноут, как это было и раньше.
Ну, сайз хорошо.
Еще 4 байта. Класс.
Ну, все равно
из-за выравнивания будет
24 байта, да.
Да, что?
На стеке.
В пустом случае одна нода.
В случае одного элемента две.
Вот.
Да.
Нам нужно еще хранить
size.
Size t нам нужно
хранить, потому что
если бы мы не хранили size,
то нам бы золото n его вычитать
приходилось. Вот. В списке
хранится еще размер, чтобы
в метод size работал золото единицы.
Вот.
Да.
То мы получим
уб.
А что мы получим в нашей реализации?
Ну, видимо, да.
Begin.
По стандарту это уб.
Да.
Если список пустой, то у нас только
одна фейковая вершина и больше ничего.
Да.
Ну, это будет неудобно, скорее всего.
Ну, можно, наверное.
Вот. Зато
инкрементация, декрементация итераторов и сравнение
сработает теперь очень красиво,
очень коротко. Мы просто
идем вперед по указателям всегда.
Если нам надо инкрементировать, декрементировать итератор.
Да.
Если это фейк ноут,
значит это он.
Вот.
Кстати, каким
важным
итератор
в каком смысле?
Страт итератор.
Ну, я пишу в STL стиле,
но вам надо будет писать
ну, юзинга вам надо будет
писать тоже в STL стиле с маленькой буквы.
Юзинг итератор равно бейс итератор.
Кстати, еще
важный
момент.
Каким важным свойством обладает лист
связанным с итераторами?
Он их не инвалидирует
никогда, ни при каких
обстоятельствах. Лист? Лист, да.
То есть мы с вами раньше говорили, вот помните, что
вектор, он таким плохим
свойством обладает, что если вы что-нибудь
вектор положите, то у вас
сломаются указатели и ссылки на
элементы.
Вообще говоря, сломаются, то есть нет гарантий,
что не сломаются. Если вы в дек
что-нибудь положите,
не обязательно в серединку, хоть в конец.
Если вы в дек что-нибудь положите, хоть в конец,
хоть в начало,
у вас тоже могут сломаться, но
не указатели и ссылки, а только
итераторы. Вот про дек мы, кстати,
не обсудили как следует.
В деке при добавлении элемента
ломаются
итераторы,
а указатели и ссылки не ломаются. Это не тривиальный факт,
над которым я вам предлагаю вам подумать.
То есть указатели и ссылки не ломаются, это мы обсуждали
в прошлый раз. Но итераторы все-таки ломаются
при добавлении в дек, вот это
не тривиально. Понимаете, почему
ломаются при добавлении в дек?
Потому что может реалоцироваться внешний
массив, а итератор он как-то
ну, итератор дек он хранит в себе
скорее всего индекс во внешнем массиве
и индекс вот в том
блоке, который
на который указывается внешний массив.
Вот.
Ну, короче, ты можешь попробовать
в общем
в общем
в общем
Сейчас итераторы инвалидируются, а указатели
указатели и ссылки нет, а итераторы
да, потому что у вас сбивается индексация
и вы там ничего не придумаете хорошего
только если не создадите дополнительный
уровень дирекции. В общем, long story short
не получится, короче, сделать дек
со всеми требованиями, как я сказал
с неинвалидирующимися итераторами, если
только не добавить туда еще накладных расходов
на разыменование дополнительное. Но этого мы
не хотим делать. В общем, когда
вы будете писать дек, вы
помните о том, что
итераторы дек инвалидируют
при добавлении элементов, а вот
указатели и ссылки не обязательно.
Но лист не инвалидирует ничего
ни итераторы, ни указатели, ни ссылки.
То есть вы можете безопасно заводить ссылку
или указательный элемент листа
и
что угодно
с листом делать, добавлять в него, что-нибудь
вставлять, только не удалять
этот самый элемент, на который вы ссылку завели.
Понятно, что если вы удалите его сам из листа
вот меня очень веселит всегда вопрос,
но если я удалю этот элемент из листа,
он же инвалидируется? Да, конечно, если вы удалите
тот элемент, на который у вас итератор,
то итератор инвалидируется. Под неинвалидацией
подразумевается, что операция над всеми
остальными элементами не
портит указатель, ссылку или итератор
на ваш элемент.
То есть у меня в листе
ноды, они однажды
аллоцировавшись, никогда не
не перекладываются никуда.
На каждую новую ноду
лист заново вызывает
оператор new и аллоцирует новый
кусочек маленькой динамической памяти именно под
эту ноду.
Если вы в лист делаете 500
пушбеков, то у вас
500 раз будет вызван оператор new.
Это замедляет
работу, конечно, но это
гарантирует вам, что у вас не инвалидируются
итераторы, если вы будете сколько угодно
добавлять в лист. Ноды эти никогда
никуда не перекладываются.
Такие дела.
Так.
Сейчас я проверю, не забыл я что-нибудь еще сказать про
лист, наверняка забыл.
Чего?
Стоп, а мы будем свою мапу писать, да?
Unordered map.
А свою мапу не будет?
Ну, unordered.
Красно-черная не будет?
Нет.
А где?
А вы в первом семестре не писали его?
Нет.
Я думал, что в первом
семестре вы...
Ну ладно.
Разве не в листе?
В листе, да.
Вот.
У листа есть
несколько
особых методов.
Вот на такие...
Вот если вы откроете сейчас
страницу
list, sdlist на cp-reference,
там вы найдете несколько особых методов,
которых нет у других контейнеров.
Есть только метод splice.
Splice, нет.
Splice это...
Это...
Если я правильно помню перевод с английского,
это значит что-то типа
нарезать кусочками.
Типа вот так вот.
Что такое splice?
А, да, сплетать концы.
А нарезать кусочками значит перепутать с каким-то другим словом.
Блин, а с каким словом я перепутал?
А, splice нарезать кусочками.
Splice это наоборот, да.
Сейчас.
Ох уж, это английский язык.
Сейчас, а где я тогда...
Какой же метод был такой? Ну ладно, неважно.
Splice. Это у меня с питоном, что ли?
Так, все, ладно.
Splice, короче, это значит... Что такое splice?
Это... У вас есть лист?
Да, стыдно, конечно.
Перепутать такие слова,
ну ладно.
У вас есть лист, что вы можете сделать?
Вы можете взять кусок другого листа
и завод едини... ну, как бы...
и вклеить сюда.
Вырезав отсюда.
Со связанными списками такая операция, возможно.
Вот, вырезать отсюда кусок листа
и всклеить сюда.
При этом, по-прежнему, никакие итераторы не инвалидируются.
Вот.
За какой этим точкой это работает?
Вот это хитрый вопрос.
В свое время там...
Вопрос наподумать.
На самом деле это работает за линию от числа элементов.
Почему-то. Хотя, казалось бы.
Вот. Это работает за линию от числа вот этих элементов.
Почему?
Потому что надо поддержать size.
Правильно.
Так это кусок листа.
Ты же не знаешь, сколько между ними.
У вас бы directional итератор.
Все бы хорошо, казалось бы, просто вырежешь отсюда
и вклей сюда.
Но, к сожалению, как я сказал ранее,
нужно поддерживать size за от единицы.
И size как поле.
А значит, придется пройти и посчитать, сколько их было.
Вот.
Считается, что size это более важно
должно за от единицы, чем вот это.
То есть, выбор.
Либо это за от единицы, но тогда size за линию.
Либо наоборот.
Но, очевидно, size это более нужная вещь, чем это.
Поэтому size решили за единицу, а это за линию.
Вы смеетесь,
а вот forward листа
примерно так и есть.
Ну, у него вообще нет метода size.
Вот.
Еще какие есть методы.
Вот у листа есть метод sort.
У листа есть метод sort.
Sort это метод листа.
Это не внешняя функция stdsort,
а это метод листа. List1.sort.
Sort. Да, у листа такой метод.
Опять-таки вопрос на понимание,
почему это отдельный метод?
Почему бы не...
Сортирует лист.
Чего?
Ну, там не contiguous же нужны.
Не random access.
Не random access итераторы.
Stdsort нужны random access итераторы.
Дело в том, что stdsort
требует random access итераторы.
Потому что stdsort
это же quick sort,
с оптимизациями, но тем не менее.
А ей нужны random access итераторы,
потому что она там
ходит назад вперед, потом прыгает куда-то там
в середину, еще куда-то.
Чего?
Насильно написать сюда merge sort.
А вот сюда написано... А здесь merge sort?
Вот. То есть у листа
merge sort работает не так, как stdsort.
Потому что в листе sort
вынужден обходиться лишь
bidirectional итераторами,
и поэтому там написан merge sort.
Потому что вот для merge sort bidirectional итераторов достаточно.
Хорошо вопрос.
А там merge sort за единицу памяти допомнился?
Вот, кстати,
не знаю.
Fun fact, in place merge
метод, который есть востояние,
он
использует не от единицы
в памяти.
Ага.
Интересно, почему это новое,
типа неизвестное алгоритм,
судя по интернету.
Чего-чего-чего метод?
Если вы пробуете погуглить сюда merge
за единицу памяти дополнительной,
то это что-то неизвестное.
Известное алгоритм за mbox
квадрат вместо дополнительной памяти.
Merge sort.
Ладно.
Я не буду спорить, потому что я не уверен
на сто процентов.
Ну да, да.
Давайте дальше.
Какие еще есть методы?
Еще есть метод reverse
развернуть лист.
Вот.
Метод reverse.
Метод reverse.
Опять-таки,
почему reverse это метод листа,
а не стандартный алгоритм?
Потому что действие у него принципиально другое,
там указатели переставлять надо.
А почему нельзя бы просто reverse делать за вот единицы?
Кстати, за какую симптотику reverse работает?
Можно сделать за вот единицы,
просто, казалось бы, свопнув вот эти два указательных.
Просто считаем, что начало списка тут, а конец тут.
Да.
Но тогда у нас
сломаются вот эти.
И тогда нам надо либо хранить каждый раз флаг,
у нас reverse нет лист или нет,
а если потом кусок листа будет вырезан
и всклеен в другой, то все, до свидания.
В общем, нет, reverse за вот единицы не получится.
В общем,
можно заменить еще это на указатели
на члены, как я вам рассказывал в первом семестре, но нет.
В общем, reverse приходится за линию делать.
И какой-то еще метод merge,
по-моему, слияние списков.
Да.
Что такое глобальный бул?
Поле бул?
Когда
ты берешь итератор
на лист и инкрементируешь итератор,
откуда ты будешь узнавать
лист reverse-нутый или нет?
У тебя есть
итератор, в нем хранится указатель
на base-note, ты делаешь
плюс-плюс итератора. Как итератор будет понимать?
Нужно next брать или pref у той вершины,
на которую он указывает?
В итераторе хранить ссылку на лист?
Нет, зачем?
Ну, тогда
может быть, это дешево.
Нет, не надо так делать.
Нет, в итераторе хранить ссылку на
лист не надо.
Тем более,
я напоминаю, что итератор может
пережить лист.
Вершина может быть вырезана из одного листа
и вклеена в другой.
А итератор на нее
должен продолжать быть валидным.
Нет,
ты же когда это делаешь,
ты же всем...
Я завел итератор на эту вершину
и сохранил его где-то, потом
сделал splice, как я вот этот итератор
куда-то вне сохраненный
изменю.
Я завел примерную. Итератор
бла-бла-бла равно вот указатель
на это. Отлично.
Потом листу вызываю splice.
Потом обращаюсь по этому итератору.
Что произойдет?
Откуда в этом
итераторе хранится ссылка уже на
битый лист?
Этот-то итератор уже не изменился.
Как бы он изменился, если ты в нем хранишь ссылку
на лист? Тот лист уже стал
другим.
Все.
Есть еще forward list.
Что такое forward list?
Это как лист, только односвязанный.
Вот forward list довольно странный
контейнер.
В нем нет очень многого.
Например, в нем, если я правильно помню, нет
метода size. Если вы только не добавили,
проверьте, что его нет.
Forward list это минималистичный
до предела лист,
который можно только pushFront
и popFront делать.
У него нет
указателя на последний...
Вы не можете
делать
минус-минус и вы не можете класть в конец.
Этот лист хранит
только...
У него есть maxSize.
MaxSize это у
всех контейнеров есть. Это сколько
максимально теоретически вам позволяет
система в контейнер положить. Я, честно
говоря, не очень знаю откуда берется это число.
Сейчас у него еще есть
этот resize.
Ну resize понятно.
Это вы просто за o от n кладете
ровно столько элементов, инициализируя их
нужными значениями.
Вот.
Хорошо.
У forward
листа конечно же forward
итераторы.
Ну короче, можете сами посмотреть, что там есть.
Так, есть ли вопросы про лист
или forward-лист?
Тогда map.
У него maxSize
1E15.
Ну maxSize это
я не очень сам... Я никогда не пользовался
медным maxSize. Это метод
нужный для проверки того
сколько максимально теоретически
вы можете в данной конфигурации
положить элементов в лист. Я не очень
знаю откуда берется это число.
Следующий пункт
это map.
Ассоциативные контейнеры
и первый из них это
std map.
Так мы вроде для листа
локатора еще не изучили.
Нет, не изучили.
И не будем пока.
Локатор
отдельная тема, на которую мы две пары
потратим.
Я ничего не говорил.
То есть мы изучили листы?
Мы изучили лист, да.
Мы еще ему в семантику не изучили.
Мы еще и выравнивание. Знаешь, сколько всего для листа
еще не изучили. Мы еще о-хо-хо не изучили.
Мы как бы...
Мы не претендуем написать лист сразу в версии
как он в STL реализован, знаешь ли.
Там много есть проблем, которые мы еще не изучили.
Но мы не пытаемся изучить их все
сразу. std map мы теперь
изучаем. А что такое
std map вы наверняка знаете. Это
красно-черное дерево. Это ассоциативный
контейнер. Что он позволяет делать?
Он позволяет, ну давайте вспоминать.
Какие у него есть операции?
Ну insert
по
value. Значит
erase
по значению
или erase по итератору.
Вот.
Что еще можно делать с
мэпом? Можно делать квадратные
скобочки по ключу.
Да. Кстати
insert нужно не value
делать, а пару k value.
Потому что мы же
мэп хранит пары ключ значения.
Поэтому insert как бы
мы делаем пару ключ значения.
Вот. I erase мы делаем
тоже по ключу.
Квадратные скобочки
по ключу.
Давайте напишу оператор квадратной
скобочки.
Что еще?
Push back, push front
никакого нету. А, но есть еще
find по ключу.
По-моему еще есть lower bound.
Ну да, еще есть lower bound, upper bound.
Count. Ну я не буду перечислять
все методы. Это слишком
Да. Кажется, с то ли 17,
то ли 20 добавили contains.
Теперь можно не писать count, потому что
как-то тупо. Вот. Потому что
в мэпе
может быть
только один элемент с уникальным ключом.
Тихо.
В мэпе может быть только один элемент с уникальным ключом.
Вот. Что происходит, когда
вы добавляете
Ну, это понятно,
что делает. Что такое erase по ключу?
Он находит элемент по этому ключу,
и если он есть, то удаляет его,
а если нет, то возвращает
вам, ну, ничего не делает,
а вам возвращает он
пару,
вот что insert, что erase.
Он возвращает вам пару,
в которые первый элемент от итератора,
второй элемент bool.
Если я ничего не путаю.
Ну в insert, по крайней мере, точно.
Первый элемент
от итератора, который вам говорит, куда
был вставлен в итоге этот элемент,
а bool был ли он вставлен,
а почему он может не быть вставлен,
потому что такой уже был с таким ключом.
Вот.
А там возвращается типа false, да,
если он поменял значение?
Нет, он не поменяет значение. Если элемент с таким ключом уже был,
то он ничего не сделает
и вернет вам вторым элементом пары false,
а первым элементом не определено, что.
Или определено, но я не помню,
потому что не нужно прольтиваться этим.
А этот, по-моему, вам возвращает
пару итератор bool, где второй элемент опять
говорит, был ли такой элемент,
а первым элементом
дает вам итератор на следующий за ним.
А erase с кейними, разве не все значения
с ключом кейни?
Такое только одно может быть.
В мэпе, я же говорю.
Есть multimap,
но в нем все хуже.
Я даже не помню,
если там erase по ключу,
разве что erase по итератору
и по диапазону.
А, ну хорошо, да, ладно.
Erase по итератору
понятно, что делает.
Оператор квадратной скобочки,
что делает?
Дает вам ссылку на value.
То есть,
оператор квадратной скобочки
дает вам ссылку
на значение, соответствующее этому ключу.
Вот, тонкий момент.
А что, если вы обращаетесь
к квадратным скобочкам по ключу,
которого нет?
Да, вот это очень интересная особенность мэпа,
что когда вы обращаетесь к квадратным скобочкам
по ключу, которого нет,
то вы не получаете UB как в векторе.
А было бы прикольно, правда?
А вместо этого
создается элемент со значением value
по умолчанию
и возвращается ссылка на него.
А что будет, если у value нет конструктора
по умолчанию?
Ты меня
расстраиваешь. Ты такие вещи говоришь,
что плохо.
CE будет.
Какой exception?
CE, потому что нет такого метода.
Просто нельзя вызывать
квадратные скобочки у
мэпа, у которого
value не имеет конструктора по умолчанию.
То есть вообще даже если
он не поймет...
Вот, я не уверен, написано ли там
это под и в constexpr. Возможно написано.
Но если такого ключа не будет,
то это точно будет CE.
А, правильно, это и будет CE,
потому что он же не может в compile time
проверить, есть такой ключ или нет.
Поэтому это в любом случае CE.
Понятно логика, да?
Можно, только квадратные скобочки не будут работать.
Значит, квадратные скобочки в мэпе
они проверяют,
есть ли такой элемент, если нет,
то создают его по умолчанию.
Но узнать, есть ли такой элемент, может только в run time.
А значит, это не получится
под и в constexpr загнать.
А значит, у вас обязательно должен быть код,
в котором вызывается конструктор по умолчанию
на этапе компиляции должен компилироваться.
А если значит его нет, то это будет CE.
Поэтому квадратные скобочки в мэпе,
у которого value не имеет конструктора по умолчанию,
это CE.
И nouvelle метод,
есть add.
А еще квадратные скобочки, это CE в константном контейнере,
по той же причине.
Квадратные скобочки это не константный метод,
а если у вас мэп константный,
то вы не можете вызывать у него квадратные скобочки,
это CE.
Потому, что квадратные скобочки,
они потенциально меняют мэп.
А значит это не константный метод,
а константного аналога квадратных скобочек не существует.
Можно иди в узкий вshaw if case?
А у 인тalomShell there is constructor по умолчанию.
там нет конструктора. Это не называется конструктор. Это называется default initialization.
Вот. Нет. Там вызывается, ну, если написать вот так, то получится 0. Если написать просто int
x, ну, это я про обычный код говорю в стеке. Если написать так, то это будет неопределенное
значение. А если, если написать так, то будет 0, потому что это называется default initialization,
это называется value initialization, по-моему. Если я ничего не путаю. Ну, короче, я не помню,
как это формально называется, но суть в том, что если вы так напишете, будет 0. А там момент так
описано, что t круглые скобочки. Ну, поэтому синтом это тоже так работает. Да, ну, синтом это
тоже так работает. Int по умолчанию вы создаете. Ну да, если ты явно говоришь, что хочешь int
пронициализировать дефолтным значением, то оно нулевое. Но если ты не говоришь ничего,
то это это разные понятия. Так вот, есть метод add, как и в векторе.
Я думаю, многие очень часто, когда тебе передают мэп по константной ссылке куда-нибудь,
вот он и константный у тебя. Так, ну мы возвращаемся к вопросу, почему нужно принимать объекты,
функцию по константной ссылке. Нет, я не готов возвращаться к этому разговору, это было очень
давно. Мы уже должны к этому привыкнуть. Да, но зато можно использовать add. Что делает add? Он
также вам возвращает ссылку на value, если такой элемент был, а если такого элемента не было,
кидает исключение, конечно. Как и в векторе. Вот. И вот у add есть константный аналог. То есть add
есть версия как для константного, так и для неконстантного мэпа. Если у вас мэп константный,
или вы его приняли по константной ссылке, то вы не можете использовать квадратные скобочки,
зато можете add использовать. А что такое find? Он находит элемент с таким ключом и возвращает
итератор на него. А если не нашел, то возвращает end. Что такое lower bound? Он находит элемент с
ключом. Значит, сейчас надо правильно сформулировать, не ошибиться. Первый элемент,
у которого ключ больше или равен данного. И возвращает итератор на него, а если такого нет,
то end. Upper bound это первый элемент, который строго больше данного, а если такого нет, то end.
Я когда переопределял upper bound... Что ты переопределял upper bound? У кого? У стд мэпа?
Нет, просто upper bound. Ничего не понял. Ты переопределял upper bound у upper bound?
Нет, функция upper bound. А, стд upper bound в смысле из алгоритма?
Он очень странно что-то делал. Кто, твой upper bound или тот,
который ты переопределял? Я передавал туда лямбю функцию. Ага. Если я передавал lower bound,
то он искал по ней. А если я передавал его upper bound, то... Вот я приравен стд upper bound.
Чтобы приравен со значением true или false удавался. Короче, не знаю. Я не готов быстро на это ответить.
Вот lower bound, upper bound. Вот. Все эти операции работают за... Одну и ту же асимптотику за какую?
За гарантированный логорифм. Нет, за логорифм. А, и рейс по итератору за единицу. Да, вот это
вот единица. Да, и рейс по итератору за еди... Что? Нет, минуточку. Нет, нет, нет, ты меня сбил.
И рейс по итератору за... Потому что деревья поворота же делать надо. Это же... Это же удаление из красно-черного
дерева. А, хотя нет, мы сейчас доказывали, что удаление от одного работает. Амортизировано.
Из красно-черного дерева? Да, да. А, амортизировано за вот единицу. Потому что нам не надо спускаться,
это можно учетом чейсь и инсерта, например. Так все, амортизировано. Сейчас. Еще раз, подожди,
еще раз, почему и рейс за вот единица работает амортизированно по итератору? Потому что и рейс
у нас сначала спускается. Спускается, чтобы найти. Да, а потом он поднимается и чинит, если не надо чинить.
Да. Если мы сделаем поворот, то потом очень долго его... Но, кажется, там нужно сделать лишь
константное число поворотов. Да, да, да. То есть, кажется, он все-таки за вот единицу будет работать.
Нет, он не честный от единицы, потому что сначала нужно подняться до момента, когда мы делаем поворот, кажется.
А, ну, то есть, все-таки лагари... То есть, там нужно константное число поворотов, но, возможно, лагарифмическое
число подъемов. Короче, давайте я просто напишу, что это за работа за лагарифом, и не буду уточнить. Это
точно верно. Вот это точно верно. Ну, и рейс по ключу, понятно, работает точно за лагарифом, а это,
может быть, как-то можно лучше оценить, но мы не будем. Вот, это отличный вопрос. Давайте его
как раз и обсудим. А как работает инкремент итераторов в мэпе и в сете? Да, что? Это написано на
себе переференс. А, ну, хорошо, ладно. Давайте обсудим, как работает дикремент, инкремент...
итератора. Вот, проблема в том, что инкремент итератора может в худшем случае работать лагарифом.
Такая проблемка. Вы инкрементируете итератор, а это лагарифом времени занимает, потому что...
Вот, тем не менее, проход по всему мэпу от начала до конца работает за линейное время от размера
мэпа. Вот стандарт не предъявляет требований на то, чтобы инкремент отдельного итератора был
быстрый, потому что он относительно быстрый. Инкремент отдельного итератора может занимать
лагарифом. Но обязательно проход по всему мэпу должен работать линейное время относительно
размера мэпа, если вы пробегаетесь. А инкремент, это следующий получается по возрастанию?
Следующий по возрастанию. Да, конечно же, ключи хранятся в порядке возрастания. И поддерживается
упорядоченная структура дерева красно-черного, когда мы, значит, туда что-то кладем. Почему
проход итератором всего мэпа работает за линейное время от размера мэпа? Потому что каждую вершину
мы посещаем... Ну, потому что в каждую вершину мы один раз заходим, один раз выходим по каждому
из ребер, которые в нее ведут, так попросту говоря. То есть там это 6 умножить на количество элементов,
в худшем случае. Да, значит, еще раз, мы обходим дерево поиска от начала до конца, от меньшего
ключа к большему. Но в каждую вершину мы входим и выходим ровно по три раза суммарно. Ну, значит,
суммарно мы линейное по количеству вершин число операции проделываем для того, чтобы обойти все
дерево. Хотя отдельный инкремент итератора может занимать лагарифмическое время, если мы там,
если нам нужно вот с самой правой вершины левого под дерево попасть в самую левую вершину правого
под дерево, то нам придется подняться по всей этой дороге, а потом спуститься вот сюда. Это один
инкремент итератора будет столько времени занимать. Зато мэп, как и лист, не инвалидирует итераторы
никогда. Как и указатели и ссылки. Потому что все хранится в нодах и ноды никогда никуда не
перекладываются. То есть на них могут переставляться указатели при поворотах дерева. Вот это очень важно
понимать. Это некоторые путаются, когда так не очень, значит, хорошо себе представлять, что происходит.
В мэпе, кстати, по-моему, кто-то из вас мне заявлял тут еще в конце первого семестра, что в мэпе все
ломается при итераторы, если что-то там делается. Нет, указатели тоже не ломаются. Ни указатели,
ни ссылки, ни итераторы не инвалидируются ни при вставке, ни при удалении из мэпа, да. Потому
что никто не перекладывает никуда вершины. Вершины лежат, они выделены один раз и все. Все,
что происходит, что такое повороты красно-черного дерева на самом деле, это просто перестановка
каких-то указателей внутри дерева. Но сами вершины, они остаются в памяти по тем же адресам,
по которым мы были. Просто переставляются указатели друг на дружку. Да, я именно это и хочу
сказать. Открой себе переференс. Если ты обходишь с этой параллельной, ты получишь странные
результаты. Это мы уже обсуждали. Но у тебя ничто не инвалидируется в процессе. Ты получишь
странный результат, потому что у тебя столько того дерева меняется. Да. Нет, ну короче, окей. Но
это просто не работает. Все, хорошо. Это работает просто странно. Нет, просто не так, как ты
ожидаешь. Инвалидация значит, что если ты завел указатель в ссылку или итератор на элемент сета,
а потом что-то повставлял в этот сет, то что бы ты там не вставлял или не удалял из сета,
кроме этого собственного элемента, твои указатели или ссылка или итератор будут указывать на ту же
вершину, что и раньше после всего этого. Вот. Но если ты это делаешь в алгоритме, что? Да. Нам
снова пригодится этот трюк. Сейчас увидите почему. Потому что нам нужно энд поддержать. Опять,
собственно, опять поэтому. Ну давайте обсудим, как это реализовано. Что хранится в мэпе на самом
деле. А, еще одна важная деталь, которую я забыл. А у мэпа есть еще одна интересная штука. Это
компаратор. Вот, когда я пишу тимплейт type name t, во-первых, там type name key, type name value и type
name, ну давайте назову cmp, который по умолчанию равен std less от key. На самом деле там еще есть
значит четвертый параметр локатор, но локатор мы пока не обсуждаем. А компаратор у мэпа есть,
как шаблонный параметр. Что это такое? Это функция, с помощью которой он сравнивает ключи. Ну как он
понимает кто меньше. Вот ключи он должен уметь сравнивать. Значит у ключей должен быть определен
оператор меньше. Либо вы должны передать кастомный компаратор вместо std less. Лист он не упорядоченный.
Ну если вы вызовете sort у листа, то тогда уже должен быть. Ну как? Сам лист не требует компаратор
для того, чтобы лист создать. Ну метод sort требует компаратора. Точно так же, как оператор квадратной
скобочки требует конструктор по умолчанию. Хотя сам мэп не требует. Что создается? Допустим я могу
создать лист от объекта без компаратора, если я нигде не вызываю sort. Конечно, можешь. Потому что
нигде в коде листа не вызывается компаратор. Потому что тела не инстанцируются. Инстанцируются только
объявления. А да, мы про это поговорим поподробнее ближе к концу, когда будем шаблонное метапрограммирование
изучать. В смысле, да, у вас ленивое инстанцирование. Если вы инстанцируете класс, то инстанцируется только
объявления методов, а определение не инстанцируется, пока вы их не начнете использовать. Это правда.
А есть один вопрос. Да. Почему тут ЦМП и тайтнейм? Что значит нельзя функцию? А куда передавать
функцию? Что ты предлагаешь здесь написать вместо тайтнейм? Напоминаю, параметры мэшаблона
могут быть типы, числа, а также другие шаблоны. Что ты предлагаешь здесь написать? Ну, начиная с
C++20 еще кое-что, но мы пока про это не говорим. Указатель там нельзя? Нет. Ну, указатель на функцию. Нет,
нельзя. Ну, начиная с C++20, там стало можно много чего. Может быть даже указатель, я не помню. Но нет,
нельзя пока что. До C++20 по крайней мере нельзя. В смысле, ты хочешь, чтобы функция была константой
времени компиляции? Ты понимаешь, что ты просишь? Ты точно уверен в своем желании? Будь аккуратен со
своими желаниями. Указатель, то, что ты, то, что ты передаешь в шаблон, должно быть константой
времени компиляции. Если ты делаешь параметром шаблона указатель, этот указатель должен быть,
как число захардкожен в шаблон еще в моменте компиляции. И ты хардкодишь указатель на область
памяти в процессе компиляции, то есть ты еще компилируешь и знаешь, какой будет адрес этой функции.
Параметрами шаблонов указатель не могут быть, потому что это абсурд, ну, потому что нельзя в
compile-time знать, каким будет указатель. Нет, нельзя, потому что разыменование указателя так не работает.
Ну, как указатель, это runtime-концепция. Вы в runtime-е проходите в какую-то ячейку памяти и там
смотрите, что лежит. А если вы в compile-time-е хотите захардкодить указатель, это очень странно. Но ты
можешь, подожди, ты можешь передать функцию в качестве, ты понимаешь, что ты опять путаешь,
а на это была задача в зачете предпоследнее, там надо было написать, что там, из, не помню. Там
была именно эта ошибка, мало кто исправил, не все. Надо было вместо int написать type name,
чтобы все заработало, если вы помните. Во втором варианте была такая проблема, да и в первом,
по-моему, была. Вот это тот самый вопрос, который ты сейчас задаешь, потому что если передать число
или указатель, это бред какой-то. Ты можешь передать указатель на функцию в качестве компаратора,
просто это будет type name и тип будет указателем на функцию, а не сам указатель на функцию ты
хардкодишь как константу. Ну начинай с 20, я думаю. Ну начинай с 20, там стало много чего,
можно, там и строки можно, но мы не будем сейчас об этом. Вот, я пока говорю только про нормальный,
плюсы здорового человека. Давай потом мы с тобой это обсудим, потому что иначе это надолго. Да.
Чего? Нет, не понял. Слушайте, давайте может после пары, потому что сейчас мы, я пока отвечаю на ваши
вопросы, у нас пара закончится, а мы еще не успели мэп обсудить. Давайте все-таки поговорим о том,
что в мэпе находится. Вот class map. В нем опять есть внутренняя структура node. Да, ну мы уже умные,
давайте мы сразу напишем base node. Что лежит в base node? Ой. Что лежит в base node? Там должен лежать,
собственно, ну да, там должен быть, значит, base node left,
левый сын, base node правый сын и base node звездочка parent. Parent нужен, потому что,
когда у вас будет итератор, вы должны инкрементировать его уметь. Как вы будете
это делать? А что тогда ты в итераторе будешь хранить? Указатель на начало или что? На какую? Ну,
в итераторе у тебя будет храниться указатель на саму вершину. Как инкрементировать итератор
тогда? Вот у тебя данный итератор сверху, что такое верх? Подожди, подожди, что такое, тихо,
что такое верх? Что такое корень? У тебя в итераторе хранится указатель на твою вершину. Ты не знаешь
корня и он мог поменяться, ты ему не можешь его даже сохранить в итераторе, потому что он мог
поменяться, пока ты, пока твой итератор не... Ну, мы уже обсуждали почему это плохо, потому что у тебя
вершину, ну нет, из мэпа конечно нельзя вырезать, из мэпа вырезать. Нет, нет, давайте, сразу нет,
все, давайте нет. Что еще хранить? Блин, то что ты предлагаешь, это уже, мне проще родители сохранить,
нет, вот вам так не кажется? А алгоритмы как раз обсуждали подробно, ну не очень подробно, но обсуждали,
что можно сделать, если не иметь родители. Ну, мы хотели хранить в состоянии DFS, ну как бы у нас есть итератор,
и мы можем в нем хранить текущие состояния DFS. Ну, в общем, вроде у нас получилось там,
но кажется, можно сделать, я верю, что это теоретически возможно, но кажется,
что это не стоит того, чтобы этим заниматься в STD-мэпе. Еще что надо? Да, но он может быть бул просто.
Чего? Чего? В смысле, у меня два всего значения, я говорил, что енам надо, когда у вас больше двух их,
а у меня их два всего. Нет, я, бул из позитив как раз нормально, вот бул сайн это плохо,
потому что что такое true непонятно. Бул из позитив это нормально, потому что он всего два значения
принимает и отвечает на понятный вопрос. Точно так же бул красная вершина или нет, но если не красная,
то понятно какая. Ну нет, можно просто red, потому что empty у вас же не из empty. Чего? Что значит в
указатель зашить? А, типа сюда последним битиком, чтобы 8, что это есть? А что вы еще на алгосах делаете,
мне интересно, я просто какие-то новые открытия делаю. Мне кажется, раньше Филипп таким не занимался,
он мне кажется изменился за годы преподавания. Нет, ну просто нет, ничего плохого, просто это
казалось бы вопрос уже плюсовой реализации, то есть понятно, что можно битиком запихнуть в указатель,
но казалось бы это не вопрос алгоритмов, но это понятно, что может. Да, чего? Ну можно, да. Что,
хочешь big integer переделать? Так, подожди, так, смотрите, теперь я говорю struct node,
наследница base node, и в ней лежит что еще дополнительно? В ней лежит пара k-value. Почему
пара? Потому что у вас разыменование итератора должно давать mstd pair именно k-value,
поэтому вы и в структуре должны хранить пару k-value, чтобы не создавать ее каждый раз заново.
Вы именно объект пара k-value храните, не отдельно k-value, а пару k-value.
В плюсах и map и set и multi-map и multi-set это все наследники каких-то стрёмных классов,
которые реализованы в других файлах в bits slash что-то там, strb3.h, и вот там, короче,
с определенными юзингами они называются map, set и так далее. Так не работает, что map это
прям вот map нет, это все через другие внутренние классы реализовано. Так, ну стд pair, понятное дело.
Что значит в вершине, а мы где храним? Ну фейковая вершина у нас тоже может быть,
что у нас фейковой вершины это такие вот эти вот нил листочки. Короче, это детали,
это не интересно. Давайте существенные вещи обсуждаем. Как реализовать end? Ну да,
как работает begin? Вот у мэпа есть метод begin, begin возвращает указатель, ну итератор на
начальный элемент мэпа, на наименьший. Как он работает, откуда он берет begin? То есть мэп
хранит, вы предлагаете хранить корень и идти вниз, чтобы получить begin. Вот, я думаю begin
обязан работать вот еници, да, или что? Это ты прочитал или ты знаешь это? Я просто не помню сам,
он обязан или не обязан, но если обязан, то нам надо просто хранить самого левого сына, понятно?
Когда вы изучали? Где? Без меня, да? А я думал, мы сегодня изучать будем.
Ну я сейчас примерно что-то похожее хотел бы сказать, то есть что такое begin? Ну begin это,
ну мы хотим хранить begin как самого левого сына, да, или ну давайте пока считать, что begin это
просто самый левый сын честный. Вот, что такое end тогда? end это должен быть опять,
какая-то фейковая вершина правее всех, больше всех наших. Ну давайте сделаем фейкового,
то есть давайте, что сделаем? Вот у нас есть дерево, давайте ему сделаем,
кстати, вот это правильное замечание, они наверное относительно операции на t опять считают
количество. Спускай, да, это как с деком проблема. Смотрите, как нам end организовать,
давайте сделаем, что фейковый корень видимо, ну то есть мы, нет, даже не фейковый корень,
мы сделаем фейковый корень и все реальное дерево будет фейковое дно.
Не, то, что там внизу какие-то фейковые листья, это не очень удобно. Удобнее в качестве end
сохранить просто фейковый корень и все. Мы просто забиваем, мы поддерживаем вот только
здесь структуру, а на это просто забиваем, я думаю. Я понимаю, да, но мы можем забить и
поддерживать у человека красно-черное дерево только вот для вот этого поддерева, просто при поворотах,
зачем нам поддерживать для фейкового корня. Мы просто знаем, что у нас фейковый корень и он end,
а условия красно-черного дерева только для вот этого поддерева поддерживаем. Вот, и декремент
end дает нам крайнего правого сына. Вот, и последнее. Ну как в тупую? Это не то, чтобы в тупую.
End это мы, для шип энд работал, мы заводим фейковую вершину и делаем ее фейковым корнем. Кого?
End мы делаем за единицу, у нас фейковый корень. End это фейковый корень. А Begin мы можем хранить,
и тогда будет завод единицы, а можем делать за логарифом. Я не знаю, честно говоря, это сделано.
Чего? Я понимаю, да. А вопрос-то в чем? Кто сказал, что end-минус-минус, это вот единицы.
Декремент итератора, вообще говоря, log n в худшем случае. И последнее. Это exception safety. Мы, кстати,
в листе забыли про него поговорить, а вам это будет надо, вам это предстоит на себе ощутить.
В качестве упражнения, да. Как поддержать exception safety в листе? Там не сложно, потому что вы
просто когда лист создаете, если вы создаете лист от многих объектов сразу и к такой-то
объект кидает исключение, то вам надо все алоцированные уже к данному моменту вершины
диалоцировать и уничтожить. Знаете, new это оператор, который делает алокацию.
Вы умеете пользу к операторам new пока что. Ну и malloc еще. Запрещено. Кажется нет. Короче,
в листе понятно, что при всех операциях модифицирующих лист, в том числе при создании
листа, вы должны поддерживать exception safety строгую. Причем вы должны, ну если у вас,
вы создаете какой-то набор объектов, например insert диапазона делаете, занимаетесь копированием,
вот тут у вас конструктор кидает исключение, вы должны все предыдущие уничтожить по одному и
вернуть лист в старое состояние. Только потом выйти из метода. Вот. В мэпе все то же самое,
но только есть интересный момент. Вот кто отгадает в чем заключается особый прикол с exception
safety в мэпе? Да нет, он есть. Тут просто есть дополнительная тонкость, которую надо учитывать,
что вот у вас может, да, у вас может, да, вам нужно все повернуть обратно, когда, если вы
вставили и у вас кто-то кинул исключение, то вам нужно вернуть все как было. Как у вас кто-то
мог кинуть исключение? А есть вот этот вот пацан. Будете? Ну вы будете unordered map писать,
там тоже есть компаратор. Там есть hash и компаратор, там еще хуже. Вот. Так, осознание номер один,
компаратор тоже может кидать исключение, и это надо учитывать. Теперь все должны напоследок
получить осознание номер два, на самом деле это не проблема. Все посмеялись, а теперь все поймите,
что это не проблема и почти ничего не меняет в реализации. Потому что вы никогда не делаете
сравнения после поворотов. Вы сначала делаете все нужные вам сравнения, и только потом решаете
повернуть что-то или нет в красно-черном дереве. И никогда не бывает такого, что вам нужно, вы уже
что-то повернули и вам нужно опять что-то сравнить. Что такое прошлой стадии? У вас константное число
поворотов, вы дошли до какого-то места, поняли где и что нужно повернуть, и вот пока вы это понимали,
у вас могло случиться исключение. Но у вас дерево еще не попорчено, вы еще ничего не повернули. Когда
вы уже дошли до места, где нужно что-то повернуть, вы больше компаратором пользоваться с этого момента
не будете. После этого вы поворачиваете, переставляете указатели, то есть исключения уже нет и все.
Возможно даже так, возможно вам даже сравнений не нужно делать, пока вы делаете поворот.
Возможно это правда. То есть на самом деле мое утверждение в том, что вам никогда не нужно
пользоваться компаратором после того, как вы сделали повороты. Поэтому тот факт, что компаратор
может кидать исключения, не представляет себя большую проблему. Хотя надо конечно это учитывать,
и если компаратор кинул исключения, это нужно вам вершину диалоцировать и вернуть как было все.
Но вернуть как было не подразумевает повернуть дерево обратно, потому что вы
еще не успели повернуть к тому времени. Ну вы алоцировали вершину и начали что-то сравнивать,
вам нужно диалоцировать вершину. Ну еще есть сет, мульти мэп и мульти сет. Ну можно их оставить в
качестве упражнения на самостоятельное изучение. Ну понятно, что такое сет. Сет это то же самое,
только нет value, есть просто ключи и все. И в сете нету обращения квадратными скобками,
вот, потому что нету value опять же, и add нету. Что такое мульти мэп? Это как мэп,
только несколько значений с одним ключом может быть. Там опять же нет квадратных скобок,
и там нету, что там еще нету, ну и add нету. Вот, и там в основном lower bound upper bound вам
нужны будут методы. А еще в мульти мэпе есть такой метод equal range, в котором возвращается
сразу пару, начало и конец диапазона, где начинается и кончается элемент с вашим ключом. Вот,
мульти сет это как мульти мэп, только без value. Итераторы везде там bidirectional и во всех этих
штуках. Вот такие дела. Вот мы с вами разобрали листы мэп, как и планировали.
