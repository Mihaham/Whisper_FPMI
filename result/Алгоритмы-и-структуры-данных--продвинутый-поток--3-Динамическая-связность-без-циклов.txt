Значит, сегодня мы, по крайней мере, начнем с такой маленькой, действительно простой задачи, как динамическая связность без циклов.
Мы попытаемся с вами тут побаловаться деревьями.
Ситуация будет такая. У нас будет, как всегда, n вершин.
Вот. Думаете, дальше будет сложнее?
Ну окей.
Ну вот. Значит, смотрите. Начнем с такой разминочной задачи.
Представим себе, что у нас есть подвешенные деревья. Вот подвешенные там за какие-то корни.
Вот. И у нас, скажем, я далеко не ушел.
И с ними нужно делать два запроса. Вот начнем с простой версии.
Значит, запрос номер раз.
Link.
Значит, от вершины v к вершине, допустим, u.
Это означает, что вершина v корень какого-то под дерево.
Значит, u не потомок v.
Почему корень? Подожди.
Ну вот. Потому что v мы будем подвешивать q.
Все. Хочешь наоборот?
Нет. Я о том, что почему у нас нет линк от двух произвольных вершин.
А вот мы и такие вот. Мы разминаемся.
Нет. Потом мы и научимся переподвешивать дерево.
Это не будет для нас проблемой.
Но пока вот для разминочки давайте не переподвешивать.
Просто вот есть у нас корень. Значит, u у нас не потомок v.
И соответственно цель, понятно, что берем этот корень v и вот давайте даже каким-нибудь красивым режим образом.
Именно так.
И v мы подвешиваем к вершине u, которая корнем быть не обязана, но может им быть.
То есть тут все, что угодно может быть.
Главное, чтобы просто мы не зацикли.
И второй тип запросов это cat. Cat от v.
Где v нет.
Если других запросов нет, я готов отвечать за 1.
Отлично.
То есть если у нас v не корень, то значит мы берем v, берем этого всего родителя.
Тут какое-то безобразие.
И ликвидируем это ребром.
v торжественно объявляется новым корнем своего дерева.
Это самая легкая постановка задачи.
Ее все умеют решать за 1, я надеюсь.
Ничего не делаете?
Кто-то даже да.
Именно метод.
Потому что от вас не просят доказательств того, что вы это реально сделали.
А вот, например, если от вас все...
А вот если от вас попросят что-нибудь такое в духе.
Там are they in one?
Then we should think a bit.
Consolidate.
Нет, куча фибонач, тут не причем.
Значит, это смотреть.
Но давайте думать.
Что тут вообще, говоря, можно сделать?
На самом деле подходы могут быть разные.
Если смотреть по асимптотике, то можно в конце концов делать это в тупую.
Запускать тут, скажем, DFS, например.
Тогда вот подвешивание, там можно вообще за 1 делать.
И вырезание тоже.
Если в списке смежности, вы будете хранить буквально списки.
Корнячка, ну...
Нет, а S&M даже не нужен, кстати, в этой корнячке.
Ну, давайте подробно.
Ну, смотрите, да.
То есть, допустим, если мы хотим делать это корнячкой.
То есть, корнячка от слова корень, но не вот этот вот корень, а вот этот вот корень.
Ну, вы поняли, да?
Радикальный, хорошо.
То, действительно.
И вам еще повезло, и у вас все в офлайне запросы даны.
Вот повезло.
То тогда, на самом деле, у вас есть такой весьма неожиданный чит.
Значит, мы берем списочек наших запросов.
Вот он, запросы, запросы, запросы, запросы, запросы, запросы, запросы, запросы, запросы, запросы, запросы.
И делим их на блоки по бубен.
Ну, тут, ладно, тут на самом деле нет смысла особо тянуть интригу.
На этот раз он будет честный койм.
Вот.
Количество вершин.
Нет, ну просто идея такая.
Да, я хочу койм из этих запросов обрабатывать суммарно за отэн.
Вот, мне, вот, вот, хочу.
Вот, вот, вот, вот, вот, хочу.
Вот, вот, вот, вот, хочу.
Вот.
Значит, ну вот.
И тогда, если я с этим справлюсь, у меня получится синтетика кукарниза.
Так, ну понятно, откуда взялось, да?
Вправивается.
Откуда я это возьму?
Значит, идея будет очень простая. Значит, в начале каждого блока, что приятно, количество живых ребер, которые у меня там в дереве есть, их ровно от n, а точнее n-1. Согласны? Зря.
В смысле, еще раз, смотря с чем согласны?
Осторожно, с тем, что ребер n-1, я бы не торопился соглашаться.
Я согласился, что их хватает.
Вот, их хватает. Ну, их наставили, что их ровно n-1. Это, конечно, не верно, потому что в реальности их n минус количество деревьев.
Нет, тут я вроде правду говорю.
Вот, значит, смотрите.
Да.
Значит, да, за от.
За от.
Нет, q корней из n.
Ну, потому что, смотрите, блоков у вас q поделить на корень из n, и каждый обрабатываете за n.
Поэтому q корней из n.
Нет, тут вроде все нормально.
Так вот.
Значит, смотрите.
Что можно сделать за от?
Значит, заметим, что у нас есть, ну вот, что, значит, рассмотрим вот этот блок.
Значит, на вот этот момент времени у нас есть какие-то деревья.
Нет, мы не будем торопиться на них прям строить компоненты связности.
Мы заметим, что тут есть некие линки, и что самое для нас сейчас главное, некоторые каты.
Вот, каты у нас есть.
Вот.
Значит, идея такая.
Все ребра, все вот эти катовые ребра.
Вот.
Мы сейчас временно удалим.
Ну, заранее вот перед этим блоком.
Вот сейчас временно удалим.
Нет, потом мы, ну вот.
И вот только после этого мы создадим компоненты связности.
То есть у нас действительно есть там, скажем, какие-нибудь вот эти вот подвешенные.
На этот момент будут подвешенные деревья.
То есть, заметим, что черным я сейчас рисую ребра, которые...
То есть так как я вот убрал ребра, которые связаны с линками и катами.
Да, пожалуй, с линками тоже я уберу, потому что мог быть кат этого же ребра.
Заметим теперь маленькую приятную вещь, что вот здесь черным я уже здесь.
Заметим теперь маленькую приятную вещь, то есть вот здесь в черном я рисую ребра, которые в течение этого блока тронуты не будут.
К чему это нас приводит? Приводит это нас соответственно к тому, что конкретно вот эти под деревья можно действительно аккуратно сжать.
Единственный конечно момент, что некоторые из этих ребер на самом деле мы поторопились удалять, потому что конкретно на этот момент времени они еще живы.
То есть поэтому тут может быть какая-нибудь вот такая вот странная, какая-нибудь вот такая ситуация, когда вот этого ребра еще нет.
То есть наоборот оно вот еще есть, но будет когда-нибудь удалено. И более того, на нем даже что-нибудь висит.
Это в принципе тоже нормально. Вот, ну вот, значит красненький тут, ну вот тут, тут еще что-нибудь красненькое вообще всякое бывает.
Вот, ну и так далее. Значит, так вот, значит тут красненькая, тут красненькая.
Ну и теоретически да, мы знаем, что тут могут быть еще какие-то ребра, но не суть.
Значит, почему не суть? Потому что после того, как мы сожмем эти компоненты связности, да, а мы их можем сжать, потому что они вот в таком виде обязательно будут, у нас теперь происходит следующее.
То есть после этого у нас остается на самом деле такой граф на там не более чем корень и зен метавершинах.
Согласны? Ну вот.
Понимаете, подлянка, может быть так, например, что изначально реберта нет вообще.
То есть может быть вообще реберта нет вообще и тогда у вас просто N корней.
Да, поэтому, конечно, утверждать, что у нас N компонент неправильно, а правильно утверждать следующее.
Ну, можно так сказать, а можно сказать, что нас на самом деле, то есть нас на самом деле будут интересовать не более чем от корня компонент связности из них.
Да, но тут видимо начинается, что дальше эту проблему можно решить десятью способами. Видимо у меня с тобой разные способы.
Потому что, смотри, у меня способ такой. Дальше я могу там, скажем, заметить, то есть рассмотреть просто какие у меня тут ребра какие компоненты соединяют.
Ну вот и самое интересное, какие еще компоненты я там, скажем, просматриваю, например.
Да, то есть вот это Rz тоже вот эти. Вот, то есть какие компоненты.
То есть я замечаю, что вот есть только не более чем от корня компонент, с которыми я дальше начинаю реально работать.
Можно еще раз пояснить почему так?
Ну, потому что, смотри, каждый из корней из N запросов работает с одной или двумя компонентами.
Вот, поэтому суммарно они все затрагивают не более чем два корней из N компонентов.
Ага, то есть вообще что запросы тогда? Сколько их реально мы не знаем?
Ну, сколько их реально мы и там можем. Ну, можем узнать, у нас сейчас ОАТН действий есть.
Ну, ОАТН это реально.
Вот, так что соответственно, корень из N. Ну, хотя дальше можно сказать так.
Вот, то есть от корней из N компонент нас действительно интересует.
То есть они там как-то будут. И дальше получается маленькая приятная вещь.
Дальше получается маленькая приятная вещь, что теперь мы, да, ну, сначала мы добавляем те ребра, которые тут есть.
В общем, добавляем их в смысле честно, то есть вот мы там.
За вот единицы.
Да, то есть за вот единицы прямо в список смежности этих мета-вершин мы их добавляем.
Боже упаси их объединять. Как-то потому что это ребро может быть потом удалено.
Вот. И, собственно, ну, там скорее всего и будет удалено.
Ну, и после этого все, что нам остается. Значит, у нас фактически есть граф на О от корней из N вершин.
И нам на нем нужно делать запросы, добавить ребро, удалить ребро, проверить, лежат ли две вершины в одной компоненте связанности.
При этом на каждый запрос мы можем потратить О от корней из N вершин.
А у нас граф фактически на корне из N вершин.
Ну да.
Или вот как можно было еще и правильно сказать, что граф может быть большой, но самое главное, что любая компонента связанности в нем содержит не более чем корень из N вершин.
Ладно, О от корни из N вершин.
К чему это нас приводит? То есть приводит к тому, что тогда мы просто там каждый вот эту штуку запускаем просто тупо, тупой DFS просто.
А мы не знаем, что такое DFS. BFS.
Вот.
Ну да.
Нет, ну то есть по сути, смотрите, мы запускаем, то есть мы берем просто тут вот две вершины.
Ну если они оказались в одной мета вершине, то сразу выводим шлаки они на месте.
А иначе там берем одну мета вершины и запускаем из нее DFS.
И только из нее.
Ну BFS, да.
Да.
Ну да.
То есть тут будет только тонкость, чтобы в массиве юзит, который может у вас быть размером N, не запускать очистку за O от N.
Ну понятно, это техническая.
Ну я просто вот упомяну, что при реализации такая техническая деталь может возникнуть.
А то иногда забудешь такую вещь сделать и бах тебе ты или потом вот внезапно.
Можно уточнить здесь.
Да.
Мы храним это как список смешанности.
Да.
Кат и Кат.
И Кат.
Ну можно даже в тупую прибегаться.
На самом деле Кат легко сделать за O от единицы, если список смешанности у тебя будет реально списком.
Реально списком.
Но не совсем.
Ну как вы смотрите, в данном случае так.
Ну вот.
Нет, ну смотрите, нет.
Ну во-первых, про каждое ребро вы можете в явном виде хранить, где оно конкретно находится в списке обеих своих вершин.
Во-вторых, для каждой вершины можно хранить ребро, которое является предком, поэтому за O от единицы выкрутиться можно.
Да, это не нужно, согласен.
Да, для этой асимптотики это не нужно, но вот чисто теоретически это как бы проблема решаемая.
Вот.
Ну да, да.
На самом деле да, легко можно заметить что конкретно в такой постановке задачи действительно это особо не надо.
Это да.
Это да.
Вот.
То есть да, когда нот пока не корневые, ну пока мы решаем вот закон.
Вот, хотя, ну вот, тут закурит вот такая вот, такая достаточно
одна из стандартных технологий, корниэнод эскорты декомпозиции.
Вот, так что теоретически можно так написать даже
без лишних заморочек.
Так, ну есть-то какие-то вопросы?
Вроде пока все нормально, логично.
Вот.
Но, правда, конкретно в такой постановке задачи
все-таки на самом деле можно попробовать это все-таки
сделать не за корень, а за логариф.
Именно.
Именно.
Вот.
Значит, да, но на этот, но сейчас нам, ну чтобы его
использовать, нам все-таки потребуется сейчас, чтобы
деревья были корневые.
Вот.
Почему нам это потребуется?
Вот.
Потому что, да, сейчас, ну вот, потому что сейчас
мы используем штуку, которая у нас когда-то уже была,
правда, мы ее эллеровым обходом, возможно, даже не называли.
Ну, сейчас вот, вот сейчас то, что я скажу, сейчас будем
смотреть, как это будет преобразовываться.
Ну, доживем.
Нет, в итоге у нас будет, конечно, линка 3, которая
будет уметь спокойно перепадать там, делать корнем что угодно,
но вот.
Ну.
Ну, сейчас доживем.
Ну, давайте для начала предположим, что не умеет.
Пока доживем до этого.
И так.
Хорошо.
Значит, ну, что предлагает, что имеется в виду под эллеровым
обходом?
Ну, на самом деле предлагается то, то безобразие, которым
бы мы Элца сводили к РМКу плюс-минус 1.
Ну, хорошо.
Тут уже, как сказать, как сказать, знаете, часто в этом
месте употребляется такой, видимо, активный программистский
сленг, я вот у многих команд слышал, но у меня почему-то
это ассоциируется с матерными словами, поэтому я не буду
его употреблять.
Вот.
Вот.
Поэтому я в этом месте говорю безобразие.
Вот.
Значит, смотрите, то есть, ну, как это работает?
Ну, очень просто.
То есть мы запустим DFS и будем, напишем сначала корень,
а потом будем писать все вершины.
Причем вершину будем писать каждый раз, когда мы в нее
попадаем, причем неважно, мы в нее приходим сверху
или снизу.
Ну, то есть, помните, да, если я тут вот напишу какие-то
вот эти вот буковки g, там a, b, там, я не знаю, какая там
следующая буква h, там x, ну и так далее.
То есть в результате это будет выглядеть как там
c, d, e, f, e, a, e, h, x, там h.
Ну, в принципе, вы помните, да?
Да, но только здесь, когда у нас одно дерево, может быть...
Нет.
Сейчас, сейчас все будет.
Значит, пока для каждого дерева мы высленно вот это
все храним, причем более того, там, естественно, рядом
храним и глубину.
Вот.
На этот раз даже не для того, чтобы искать там минимум
отрезки, а вот будет немножко с другими целями.
Значит, там h будем хранить, x будем хранить.
Значит, что там дальше?
Там 3, 4, 3, ну и так далее.
Вот.
Значит, соответственно, что дальше?
Что дальше?
Вот.
Ну вот.
Ну, идея будет заключаться в следующем.
Давайте, давайте для каждого дерева вот этот вот обход,
ну, этот обход, он же является массивом, да?
Ну, так его логично хранить в каком-нибудь дереве по
неявному ключу.
Ну, например...
Ну, например, в ВВЛке.
Очень приятно.
Особенно сплит мне касается.
Ну, сплит, мерч, да.
Нет, ну, просто в ВВЛе как бы железобетонно это.
Ну, не нравится ВВЛ, можно красночерное взять, пожалуйста.
Да, сплей мы еще доживем сегодня.
Да, сплей сегодня сыграет важную роль.
Это да, но это мы забегаем вперед.
Пока давайте что-нибудь простое.
Вот, АВЛ.
Вот, значит, смотрите.
Значит, какая тут возникает идея?
Просто давайте вот хранить эти массивы там, собственно,
в декартовом дереве.
Ой, я декартово сказал, ну ладно.
Ладно, АВЛ.
Ну, говорим декартово, подразумеваем АВЛ и вообще.
Ну, как же, да.
Так вот, да, любое сбалансированное двоичное дерево поиска, да, вот, пойдет.
Вот, и значит самое, ну, ты что, что для нас?
И тогда, и самое главное, для каждой вершины храним,
в каком дереве она находится, а желательно храним, где она там хранится.
Что такое где?
А что такое где?
Ну, что такое дерево поиска?
Это что-то вот весящее, вот это вот на указателях.
Да, вот это вот.
На указателях, на указателях, на указателях.
там вот, там как-то находится.
Так вот, я для какой-нибудь вершины х, там,
просто буду тоже тупо хранить указатель,
где эта вершина х находится.
А мы будем хранить, где находится самое первое ее вхождение.
Ну, вот.
А на всякий случай мы еще будем хранить,
хранить, где находится ее последнее вхождение.
Тоже удачи.
Да, ну давай.
Давай посмотрим.
Чего мы очень делаем?
Ну вот. Чего-чего?
Нам недостаточно первое в последнее вхождение в хождении?
Нет, в смысле это не стоит.
Ага.
Ну вот, ну возможно недостаточно.
Ну сейчас мы это увидим.
Сейчас мы внимательно подумаем,
что нам надо.
Нет, смотрите.
Нет, у нас мечта такая.
Для каждой вершины
мы на всякий случай
храним первое вхождение в массив
и последнее в виде ссылок
просто на вершины.
А, да, на всякий случай, конечно,
мы вводим такую редко реализуемую
на практике вещь, как
для каждой вершины указываем ее родителям.
Но в данном случае
это нам реально понадобится.
К сожалению, я очень долго
думал, как это сделать персистентно,
потому что персистентно
на деревьях нельзя
на родителей.
И, короче, поход не как.
Ну бывает, да.
Пишу, да.
Нет, это то самое
сбалансированное двоичное дерево поиска,
в котором мы храним вот этот вот массивчик.
Один или все?
Один. Каждый массив
храним в своем дереве.
Я думал, что какой-то ВЛ-дерев, который все массивы хранит.
У нас ВЛ-дерев будет
по числу деревьев.
Так вот.
Зачем нам нужны родители?
Это для того, чтобы, например, понять,
где х находится в смысле
индекса в массиве и делать
правильные сплиты.
Ведь действительно,
что такое выпилить деревья?
Что такое выпилить, скажем, дерево
х?
То есть сделать вот этот вот кат
и объявить это дерево.
Ну, практически для этого нужно
сделать два вещи.
Во-первых, выпилить соответствующий этому
поддереву подотрезок,
а ведь каждому поддереву, обратите внимание, соответствует подотрезок,
то есть мы его можем тупо
выпилить, просто вот двумя сплетами
и сказать, что вот это дерево
теперь живет само по себе этот подотрезок.
Есть только один, но единственное,
что когда вы его выпилите и
померзите вот эти вот все штуки,
то есть обнаружится, что у вас тут
какие-то две ешки будут идти подряд.
То есть поэтому надо просто одну
удалить.
Мы же записываем,
когда мы приходим в вершину,
когда, короче, каждый раз там
по оказываемой вершине.
Да, ну поэтому...
У нас всего два раза появится та
линия вершинка.
Нет, не-не-не, смотри, вот конкретно эта
вершина появится столько раз, сколько...
Да, она появится
столько раз, сколько в нее ребер ведет.
Вот, или что
то же самое. На самом деле она более общие
утверждение, которое не для корня,
которая для корня тоже работает. Она появится
столько раз, сколько у нее детей плюс один.
Потому что мы придем в нее, обойдем
первое под дерево, тыкнем все еще раз,
пройдем второе по дерево, тыкнем все еще раз,
пройдем третье под дерево, тыкнем все
последний раз.
Кого удалить?
А, ну вот тоже его просто найдем, где оно находится по индексу с помощью того же самого...
У нас есть 2 отрезка. Мы знаем, что он окружен двумя вершинами.
А, ну или так, да.
Мы собираем первую вершину массива и умеем.
Ну, пожалуйста, или так. На усмотрение, на усмотрение.
Нам пока не нужны родители даже.
Пока что да. Они нужны уже для того, чтобы проверять, в одном ли дереве находятся две вершины.
Нет, погоди, родители нужны для того, чтобы определить, какое под деревом мы выпиливаем.
По-моему.
Да так.
Если у тебя есть ссылка на указание в дереве, как ты будешь выпиливать постепенно?
Ну, так шо, увы. Не так все просто.
Еще раз, зачем здесь родители?
Родители, ну для того, чтобы...
Вот тебе хочется выпилить подотрезок, где находится 1 аш и где находится последний.
Но ты индексов не знаешь.
Знаешь указательное место.
Да, ты знаешь указательное соответствующую вершину в дереве.
Да, на первую и последнюю.
Да, на первую и последнюю. Но кто она там, 5, 7, 8, 13, ты не знаешь.
Хорошо, а как узнать?
Вот. Вот для этого нужны родители.
Ну, например, часто проходишься вот до корня.
Оттуда и оттуда найти.
Ну, да.
Можно просто дойти до корня, записать путь, а потом пройти сверху вниз и найти его порядковый номер стандартным способом.
Ну, либо на самом деле сделать это все за один проход.
Просто идем наверх, идти поговорим, что если ребро, по которому ты поднялся, оказалось правым, то к ответу прибавляем что-нибудь.
Вот это вот.
Вот за этим родители откровенно нужны.
Но они не так понадобятся, чтобы искать, что в одной компоненте.
Да, и тем более, что да, как мы будем отвечать, находятся ли две вершины в одной компоненте.
Ну, вот ровно тем же самым способом.
Только для этого мы просто выясним, а как бы поднимемся из одной вершины в корень, из другой вершины в корень.
Потом посмотрим внутрь и скажем, а не в одном ли мы корне находимся.
Вот.
Вот такая вот простая технология.
Вот.
Ну, при большом желании вы можете пытаться хранить, нет, хотя, глубину вершины, но это у вас не получится, поэтому не надо.
Тем более, что, смотрите, если вы хотите хранить глубину вершины, а это бывает иногда полезно, то на самом деле вам придется делать отложенную операцию вида прибавления на поддерево.
Да, изи, особенно когда вы тут сверху вниз поднимаетесь.
Поэтому, но там придется два прохода, то есть нашли путь, а потом по этому пути делаете, пробегаете свеку, опускаете.
А почему нельзя хранить первое хранение и последнее?
А вот сейчас.
Какие хранения на что?
На вершины ВВМ дереве.
Мы их храним.
Что с ними дальше делать?
Ну да, у нас в вершине самый индекс не хранится, если что.
Про что сейчас было отступление про отложенные операции?
Ну, это, да.
А зачем?
Ну, пока да, да и вообще, нет, в такой подзадаче, в общем-то, и незачем, да и вообще почти никогда незачем.
Нет, иногда бывает интересно, но вот.
Для LCA?
Хотя, не-не-не, ну LCA.
Нет, тут LCA не причем, что LCA вот в этом деревеньку отношения к LCA в этом дереве не имеет.
Хотя иногда да, мы хотим, наверное, на подотреске минимум искать, поэтому.
Это в виду высота вершины исходного дерева, который отвечает вершине АВН дерева.
Ну да.
Ну да.
Нет, ну да, иногда это может захотятся делать, вот соответственно.
Значит, далее.
Ну хорошо.
Значит, там с этими вот, да, используя на максимум всех родителей, значит, КАД запилит.
Повторите, что мы выпиливаем под дерево из исходного дерева.
Ну, смотри, значит, еще раз.
Значит, мы выпиливаем под дерево какой-то вершины, вот в нашем случае АШ.
Значит, в нашем, значит, у нас у этой АШ есть первое вхождение в дерево.
И есть последнее вхождение в дерево.
Да, мы знаем соответственно вершину.
Да, мы знаем, где они находятся.
В смысле, можем тыкнуть в вершину в декартовом дереве.
В смысле ВВЛ.
Да, хорошо, да.
Но, значит, хорошо.
Значит, по этим вершинам мы восстанавливаем их индексы в этом дереве.
Зачем?
Для того, чтобы потом сделать сплит по неявному ключу.
Так, ладно, тут сошлемся, что это была программа экзамена.
Вот.
Мы, ладно, пока мы поверим в качестве черного ящика, тогда шоу.
Да, там за логарифом это делается.
Ну да.
Ну да.
Но если мы знаем, что мы как бы хотим вырезать подотрезы крылья, то как бы мы тогда должны
сначала отпилить первую L-1 вершину, а потом отпилить первую L-2 вершину.
Ну да.
Ну да.
Ну да.
Ну да.
Мы должны сначала отпилить первую L-1 вершину, а потом из там правого полученного
дерева отпилить еще вот L-1.
Ну это уже, я в этом смысле живу в один индексации, но это уже как бы не те мелочи,
которые сильно принципиально.
Вот.
Значит, мы сейчас как бы плюс-минус единички сейчас нет смысла особо обсуждать.
Вот.
Ну а теперь, значит, возникает только один вопрос.
Как нам сделать линк?
Как нам сделать линк?
Да, в общем-то так же.
Да, в общем-то так же.
Потому что что нам теперь надо?
Ну теперь самое главное, заметим маленькую приятную вещь.
Нам в общем-то достаточно все равно, вот если я вот хочу к вершине Z подвесить нового ребенка,
а каким он у меня будет?
Первым?
Вторым?
Пятым?
Да, на самом деле абсолютно все равно.
Вот давайте, может быть, для удобства первым.
Ну или последним тоже самое на самом деле будет.
То есть тогда это означает следующее, что вы берете эту вершину E.
Ну вот давайте, мы берем где-то у нас в списке нот.
Где-то у нас в этом, ну я рисую массив, подразумеваю дерево, естественно, да?
Потому что я для массива подразумеваю, вот у меня первое вхождение вот это E.
И тогда я очень хочу вот в это место вставить, что вставить?
Вот этот вот новый подмассив для вершины H, вот этот вот H, X, H, blah blah blah.
И еще одну букву E.
Вот, понимаете, да?
Суть одна от слова вообще.
Да, можно сюда, можно слева, можно после конца,
можно перед концом, пожалуйста.
То есть на усмотрение.
То есть я сейчас поставил вот это для того, чтобы указатель на первую E не менялся.
Это неприятно, потому что здесь нужно будет выклипать, поменялся ли указатель на последнюю E.
Да, ну может, да, но да.
Проще оставить перед E и гарантированно поменять указатель на первую E.
А синтетически не важно?
Вкусовщина немножко, да?
Ну окей, хорошо, пожалуйста.
Вот, да, действительно.
Давайте, значит, мы тут перед E вставляем эту штуку, вставляем еще одну E,
и указатель на самую первую E меняем.
А мы все не храним, мы только первую и последнюю храним.
Ну, потому что мы можем отпилить из этой штуки все под деревья.
Ну как тебе сказать?
Ну как сказать, меньше нот.
Нет, надо подумать, что в принципе...
Ну в принципе, да.
Главное, чтобы под дерево начиналось и заканчивалось с себя любимое, а дальше...
Да, да, да.
А в какой нельзя?
Вот сейчас начнем переподвешивать деревья.
Ну, когда мы начнем переподвешивать...
Нет, ну когда мы начнем переподвешивать закони, у него все равно появится линкап.
Вот, нет, ой-ой-ой.
Трик позволяет переподвешивать.
Ой-ой-ой.
Каким же образом интересно.
Очень неприятно.
Ну, а что нам мешает?
Что должно поменяться при переподвешивании с другими вершинами?
Как нас меняется альтертура?
Ну как?
У нас подотрезок переворачивается и пара штук свапается.
Делаем реверс на отрезке.
Но для этого нужен какой-то отрезок.
Вот я хочу, например, вот эту ажи сделать корнем.
Ну вот, что тогда?
Как выглядел альтертура?
Как стал выглядеть альтертура?
Ну, выглядел страшно.
С внутри Д, внутри Е, внутри Аж.
А теперь должно быть наоборот.
Аж внутри Е, внутри Д, внутри С.
То есть, значит, внутри вот этих вот подотрезков.
Нет, конкретно тут-то без вопросов, да.
Просто следующая ставка была, что хочется там что-нибудь переподвешивать
и, может быть, даже LCA искать.
Кстати, вот, действительно.
Ну вот, и утверждалось, что как-то можно.
Хотя, не знаю, если тут начинаются реверсы на подотрезке,
может уже легче сразу писать линкаты и не париться.
Не-не-не, вешаться не надо.
Как говорится, вешаться не надо.
Пусть деревья вешаются.
Значит, смотрите.
Значит, на самом деле, конечно, мы тут, да,
хоть как-то действительно можно делать,
действительно обойтись какими-то вот просто
высплечиваниями, вмерживаниями.
Но, на самом деле, конечно, хочется...
Мало того, что хочется вводить, значит,
помимо операции линк-кат там,
и вот этого еще какую-нибудь там функцию
эверт, вот будем ее называть там по классике,
эверт от V, это сделать
вершину V корнем
своего поддерева.
Вот это вот хочется делать, например.
Что?
Ну да, линк, конечно,
продолжает подвешивать корень к чему-нибудь.
Нет, она может и корню подвешивать, но самое главное, что V корень.
Да.
Ну V это корень, чтобы как бы структура под деревьев
осталась под деревью.
Ну теперь это уже не проблема, потому что как бы
если вы хотите подвесить ни корень, ни корню,
то как бы вы просто там делаете
соответственно под деревом нужную вершину корнем
и подвешиваете.
То есть это уже такое.
Но это еще только техническая задача.
Вот.
Потому что
тут начинается, потому что мы
на этом не останавливаемся. Мы уже в прошлый раз
начали тут мечтать о каких-то там вещах в духе, что
давайте для каждой вершины,
что в каждой вершине у нас хранится какая-то там чиселка
фиолетовая.
А, не, малиновая.
Вот.
Ну вот.
Все когда-то бывает в первый раз.
Нет, а что такое?
Во.
В изначальном дереве мы хранили в вершинах какие-то значения.
Да просто, даже не в изначальном, а просто в каждой вершине
хранятся какие-то значения.
В каждой вершине ничего.
В каждой вершине исходное... Нет, мы забываем про вот эти
картячки. Да, исходного дерева.
То есть мы сейчас говорим об обстановке задачи.
Ну бора у нас нет на дереве.
Для какого?
Чего? Какой? Где бы?
В программировании слово «бор» имеет принципиально
другой смысл.
Ну вот о простройке мы пока не говорим, поэтому
бором это лучше не называть.
Да, в английском языке, наверное, такого каламбура бы не было, но
в английском языке говорим, поэтому как бы «бор» это другое.
Как бы набор деревьев называется «лес», если что.
Вот, тем более.
Ну вот.
А, ну, кстати, в английском языке он тоже называется «форест», если что.
Вот.
Да, forest, yeah.
Moreover, there is some problems like
minimal spanning forest, for example.
Instead of minimal spanning tree.
Вот.
Согласен.
Не, ну там типа...
Ну, фактически, да, найти миностобов в всех компонентах связности.
Ну, такое понятие есть.
Там оно просто удобно бывает.
Потому что там есть куча алгоритмов в духе.
Давайте вытянем какие-то ребра.
Раф распадется, значит, на компоненты связности в каждом языке.
Там найдем этот минимальный лес.
Вот.
Сожмем их в компоненты, значит, ввернем старые ребра, повторим операцию.
То есть там вот на подобных технологиях...
Ну, там, естественно, удалять будем не просто так,
чтобы там убеждаться, что те ребра, которые мы удалили, они там не сильно нам помешают.
Ну и прочее, прочее, прочее.
Вот.
Значит.
Ну, там разные технологии есть.
В свое время мы это обязательно все увидим.
Ну, вот.
Значит, то есть вот хочется рисовать вот какие-то тут чиселки.
Что?
Объекты какие?
Да, любые.
Ну...
Мы к задаче добавили еще два условия числа и сделать вывод.
Да.
Вот.
И более того, у нас тут начинаются еще какие-нибудь веселые запросы.
Ну, значит, теперь у нас...
Ну да, то есть теперь эта штука будет называться...
Там КОСТ, допустим, АТВ.
То есть там нам будет очень хотеться для каждой вершины узнавать,
а что у нее там написано.
Ну, и это тоже.
Нет, если бы просто было, что в ней написано,
это, конечно, было бы глубоко неинтересно.
Интереснее, конечно, такой веселый запрос, как...
Как говорится, прошу перейти, правильно, МИН-КОСТ.
Нет, если у вас возникли ассоциации с какими-то там потоками,
забудьте о них, пожалуйста.
Как говорится, до них мы тоже доживем, конечно же, но...
Ну...
Думаете, да ладно.
Не, ну это вы... Не, не надейтесь.
Нет, вы понимаете, тут ситуация простая.
Даже если вы переведетесь в основной поток,
то, соответственно, там потоки тоже будут.
Да, но без МИН-КОСТов в этом не обойдетесь, я думаю.
Так что не выживут только те, кто либо переведется в базовый, либо это отчислится.
Ну вот, ну тогда вы перейдете в какой-нибудь другой вуз,
и там тоже будет МИН-КОСТ.
Что это такое?
Что это такое? Что такое отчислится?
Нет, не буду я отвечать на этот вопрос.
А МИН-КОСТ, да, именно.
То есть вы хотите найти, рассмотреть путь от вершины В до своего текущего корня,
вот этого вот.
Рассмотреть все веса вот этих вот всех вершин, вершин, вершин, вершин.
И хотите найти минимальный среди них.
Вот такой вот простой идея.
Ну, это пока для примера.
Потому что на самом деле,
естественно, на самом деле нам захочется менять.
На самом деле, конечно, мы себе в перспективе имеем в виду,
что мы на самом деле можем там всегда делать...
Зачем лца первую вершину?
Да, да, да, боже упаси.
А на самом деле захочется, как всегда, там делать присваивание на пути.
Ну, как в Хэви-Лайте, да.
Присваивание, там, добавление на пути.
Там сумму на пути, минимум на пути.
Вот, пожалуйста, минимум на пути.
Ну, в общем, как всегда.
Нет, самое смешное, что можно.
На самом-то деле.
Отвратительно.
Даже алгоритм деревьев.
Нет, нет.
Нет, какая разница?
Тебе это очень как раз не понравилось.
Нет, что такое? Ты все помержал, все свои суффиксы пересчитал и там...
Да, я да.
Я дерево построил,
прификсы суффиксы насчитал,
левые, правые под деревья там
насчитал, запускаю, хану,
пыщем бы, хащем бы, шайтанам ада.
Что, не было такого?
Не сталкивались.
Не сталкивались.
Ну, мало ли.
Иногда сейс-админы любят так разговаривать.
Вот.
Так, тут нет сейс-админов, ну ладно.
Ладно, хорошо, хорошо.
Ладно, так, смотрите.
Значит, что тут предлагается?
Значит, туда всякие там апдейты
эти делать.
Значит, что тут предлагается делать?
Предлагается делать
маленькую приятную вещь.
Значит, смотрите.
Значит, каждое дерево
предлагается снова
декомпозировать на пути.
Да нет?
Потому что на этот раз
мы не будем говорить о том,
как же мы конкретно будем декомпозировать
на пути.
То есть, это понятие будет динамическим.
То есть, если раньше там...
Когда у нас дерево было статическим,
да, у нас там во всех хевилайтах,
во всех ледерах и прочей радости
мы действительно хранили там,
что давайте пути будем хранить так,
что из каждой вершины ребро ведет
в каком-то самого жирного ребенка
и так далее.
Да, все такое бывало у нас.
Но в данном случае мы себе
не будем привязываться к тому,
кто там жирный, кто там нет.
Вот.
Мы просто будем говорить, что у нас
здесь дерево декомпозируется
на какие-то пути.
Ребра, которые у нас лежат
в этих путях, мы будем называть
жирными, сплошными.
Вот.
А в каждом лесе мы будем то же самое делать.
Вот. Значит, это будет сплошным.
Вот. Сплошным.
Ну вот. Или вот.
В английской литературе они просто
называются solid.
Вот. Нет, я
мог бы тут их нарисовать.
Нет, смотрите, забегай вперед.
Я мог бы их нарисовать, что давайте их рисовать
красными и синими, но я не буду этого делать.
Потому что красные и синие нам потребуется.
Да, потому что
красные и синие, помните, у нас были в
heavy light тяжелые и легкие.
Так вот, сегодня нам они понадобятся.
Так что здесь?
Как говорится, нет.
Как вы знаете, было такое шоу
когда-то, феномен.
А пути все вертикальные?
Да, пути все вертикальные.
Так вот, было вот шоу феномен, пока я тут
рисую. Вот там
действительно, суть была в том, что там
шоу об экстрасенсах, там был
какой-то главный экстрасенс, который все время показывал какую-то
магию, и вот функция ведущего
в этом мини была там что-то стоять сзади
и просто через каждое слово говорить там поразительно,
я не могу в это поверить.
То есть в результате кто-то там
в породе хорошо, поэтому прошлись,
когда в какой-то момент этот
ульзю не сказал. Вот смотрите,
видите, вот у меня в руках вилка
ведущая сзади, поразительно, я не могу в это
поверить.
Так вот, на самом деле
вот это вот как-то у меня вот такие
ассоциации вызывает.
Значит, смотрите,
значит, смотрите, то есть мы
декомпозировали дерево на пути
каким-то образом,
каким-то абсолютно мистическим
образом. Так вот, все ребра,
из которых состоят эти пути мы будем называть
сплошными,
а все остальные ребра мы будем называть
пунктирными.
Не обязательно,
не все ребра
в пути.
Конечно же, не все ребра.
Нет, у нас, если все
ребра в пути, то дерево бомбуча.
Вот.
Вот.
Господи, бля.
Вот.
Это оно есть.
Дэшт.
Вот.
Вот.
Так вот.
Нет.
Нет, сагдельки это другой предмет.
Так.
Ну вот, значит, тут что-то
висит какое-то безобразие.
Вот так вот.
Вот.
Ну, вот так.
Дело в том, что,
как я уже сказал,
гарантировать можем только одно, что из каждой
режимы в какого-то ее ребенка
ведет не более одного сплошного
ребра.
Да, может быть ноль, пожалуйста.
Даже при наличии
детей.
Как это у нас, типа, много детей
и не одного сплошного. Все пунктирные.
Вот.
Значит, что у нас тогда дальше?
Значит,
но фиксировать
мы это разбиение, раз и навсегда,
естественно, не будем, потому что у нас деревья будут
отпиливаться.
Значит,
более того,
мы себе введем,
вот, как бы, если уж
упоминали сплэй-деревья, значит,
по аналогии с ним мы введем
мистическую функцию
expose
от v.
Это будет такая внутренняя функция.
То есть она нужна нам только
внутри самой структуры данных.
И делать, ну вот,
цель ее будет очень простой.
Ее целью будет
взять какую-нибудь вершину v
и
сделать так,
чтобы был, чтобы появился
путь,
который начинается в корне
и заканчивается v, ну или наоборот,
как вы там храните.
Советуют, кстати,
сохранить именно снизу вверх
путь.
Но авторы хотят, чтобы...
авторы рекомендуют, что вот эта вот штука
это начало пути, а вот это конец.
Вот.
Вот.
Да, если чтобы это... Да-да-да, вот это ребро,
кстати, они предлагают действительно делать
пунктирным. И, соответственно,
ну и здесь, соответственно, вот это вот ребро тоже
пунктирное. Ну, в общем случае
понятно, что там действительно исходный
путь мог быть на самом деле вот каким-то вот
действительно вот таким.
Там вот, да, вот как мы рисовали, да.
Там вот как-то вот так вот, да.
То есть тут много чего может быть.
И тогда мы тут действительно
очень много...
То есть если вот эта вершина v,
то вот это ребро мы делаем, значит,
от сплики, ну вот объявляем пунктирным.
Значит, путь действительно строим
вот таким вот образом.
И, соответственно, все вот эти вот...
Такие вот ребра
мы объявляем.
А чтобы они хранимы,
они не разрешены юрагителям?
Не разрешены юрагителям в деревне?
Ну...
Вот.
Но на самом деле не совсем.
В явном виде родителя мы не храним.
Вот.
Ну вот мы
можем делать это чуть-чуть похитрее.
Хотя
можно добиться того, чтобы мы это делали.
Потому что вопрос, как мы будем хранить
эти пути?
А пути мы будем хранить
весьма простым образом. Каждый конкретный
путь мы будем хранить
в каком-то, пока
каком-то двоичном дереве
поиска.
Значит, пока для простоты
каком-то.
Вот.
Ну, разница ставка будет такая.
Дело в том, что...
По неявному ключу.
Вот. По неявному ключу. То есть как бы
каждый путь это такой массив.
Вот. Последовательность вершин.
Вот давайте, как мы только что
уже делали на этом массиве строить
дерево.
То есть какое-нибудь двоичное дерево
для того, чтобы мерчить. Ну, потому что вот тут для
разминочки вот предлагается такое.
Давайте представим себе, что нам фантастически
везло все это время.
И все под...
И у нас все под деревья, которые у нас были,
это бамбуки.
Вот мы работаем
с бамбуками.
И все, что от нас просят, это постоянно там...
Ну, по факту получается свержить
два бамбука или распилить бамбук на два.
То есть тогда как бы
делается без проблем.
Мы там храним каждый бамбук
в ВВЛ-дереве и своем задачу
к сплету и мерчу массивов. Правда?
То есть тут, в общем-то, даже все за логарифом работает.
Более того, если нам очень хочется
сказать, что корень теперь вот этого
дерева теперь не вот эта вершина, а вот эта,
то реверс ВВЛ-дереве, это тоже для нас
уже непроблемная операция. Правда?
А если в серединке?
Чего в серединке?
Если мы хотим, чтобы Борин сделать серединку.
А, ну тогда он перестанет быть бамбучей.
А, логично.
Пока это было бы для нас
вообще не проблема.
Ну вот, хотя вот
в домашней визитации, вы помните, у вас там была одна веселая задача,
где, скажем,
где надо делать фактически что-то типа
динамической связности, только даже с расстояниями,
но вам гарантируется, что степень
каждой вершины не более чем два, помните?
Ну да,
задача тоже обнаружена, что там все
либо бамбук, либо
замкнутый бамбук, соответственно,
и вот
и это действительно
изначально используется определенного рода техники.
Не самые, может быть, приятные, но тем не менее.
Значится далее.
Но, конечно же,
ну вот,
значит, конечно же, в нашем случае
становится
немножко больно.
Потому что,
ну, действительно,
на самом деле, конечно,
теперь у нас
как выполнять все эти запросы?
Идея будет такая,
основная идея
будет следующая,
что мы с вами,
значит, прежде чем сделать вот любую из
вот для начала вот этих операций,
делаем expose.
Вот, да.
Как бы и да, все
не случайно причем, да.
Но самое смешное,
но тут аккуратно, на самом деле это мы где-то
видели что-то похожее на это.
Потому что парадокс такой, линкад был придуман
за два года до сплей 3.
Вот.
То есть более того, они
у них изначально линкад работал за логорифом,
но они там примут,
до этого придумали какое-то там полуукуренное
дерево. Но я не знаю,
может я честно не копал, может оно
не такое укуренное, как кажется, но
в статье я
посмотрел, выглядело страшно. То есть там дерево
с какими-то там зубодробительными условиями,
хотя я подозреваю, что просто, видимо,
что-то более продвинутая версия того, чтобы вот
с вами там в хэви лайте рисовали, на самом деле.
Вот. Но там
были какой-то безобразие. Вот.
Но потом через два года появилась сплей дерева,
которая гемахом решила там кучу сразу проблем,
в том числе и эту.
Ну, помните, да, у нас сплей дерева, почему у нас появилась
сплей дерева, когда у нас как бы все, все что
нужно мы можем делать и B деревом,
и VN деревом, и так далее, да, помните?
То есть там вот было там,
потому что иногда нам хочется не просто честного
алгорифма, а хочется, чтобы у нас были какие-то,
что там какие-то запросы мы делаем
часто, какие-то редко. И хочется,
чтобы дерево это как-то учитывало и работало с этим оптимальнее.
Ну вот оказывается, что там какие бы оптимальности,
то есть сплэй дерево в этом смысле тоже идеально работает,
на самом деле тоже можно оценить.
Вот.
Так вот, ну здесь правда сплэй дерево тоже нужно будет работать аккуратно,
до этого мы доживем, пока давайте, то есть пока для этого нам нужно научиться работать с произвольным.
То есть да, забирая вперед скажем, что на самом деле ставка у нас будет такая.
Если мы тут ставим произвольную АВЛ-ку с Б-шкой,
то тогда я утверждаю, что все эти запросы мы будем делать за лог квадрат.
Вот мы это прям просто докажем, что это будет лог квадрат.
Ну да, а у нас и, ну как бы у нас все будет амортизировано,
но если как только мы введем сплэй,
еще и чуть-чуть проследим за тем, как правильно тут что делать,
то тогда логарифом у нас, как мы докажем, торжественно превратится,
вот такие квадраты торжественно ликвидируются.
Вот такая у нас сегодня ставка.
Вот ставка, понятно?
Вот.
Ну, значится, поехали.
Значится, поехали.
Ну, что ж нам делать?
Ну, во-первых, сделать так, чтобы вершина В была первой вершиной в своем пути,
и это без труда, потому что вы делаете просто сплит соответствующего дерева, правда?
Вот, согласны?
Ну, мы говорим так.
Вот, итак, начинаем.
Значит, первое, что нам нужно сделать эксполс.
Ладно, давайте договоримся.
Если у нас будет черномагический эксполс, который будет перешаманивать вот путь таким образом,
чтобы был путь от В до корня,
то это все, что поменялось.
Ну, то есть условно понятно, что для этого там какой-нибудь вот этот путь трогать не надо, например, да?
Ну, вот, то есть все, что он будет делать, это на самом деле идти от вершины В до корня,
и все сплошные ребра, которые он встретит, прям в честную объявлять,
все не сплошные, наоборот, объявлять сплошными.
Ну, еще, да, соответствующее, если там было другое сплошное ребро, то соответственно объявить его пункти.
Но это все, что он будет делать, больше он никого трогать не будет.
То есть если мы каким-то мистическим образом докажем, что эксполс у нас там за какой-то лог-квадрат или лог работает,
то давайте внимательно посмотрим, что мы с этого можем состричь.
Ну, начнем с простого. Так, корень.
Переподвесить корень.
А мы фактически храним все пути, правильно?
И каждый путь храним в своем АВЛ-дереве.
Вот. Значит, та переча.
Если мы хотим делать эверт.
Эверт делается без труда одним эксполсом, правда?
Ну, эксполсом и реверсом дерева.
Да.
Ну, потому что идея такая, я хочу, чтобы В стал корнем, что мне надо?
Так, ну давайте я запускаю эксполс. Теперь у меня есть путь, который начинается в В и заканчивается в корне.
А мы храним, что может сломаться?
Нет, пока у нас ничего нет. Я описал просто структуру и сказал, что у нас есть мистический эксполс,
который мы пока будем потом эти небеса и факсы изобретать.
А мы храним только путей? Сами деревья уже?
Нет, храним. Почему храним?
Ну, конечно же, в каждом дереве, то есть из каждого дерева идет вверх один пунктирное ребро.
Ну, кроме корневого, конечно.
И мы в каждом пути, в корне этого пути обязательно это ребро храним.
Есть дикартач, построенный на элеровом пути?
Нет.
Все, мы забыли все про элеровые обходы, они нам тут не понадобятся.
Да, то есть это то рассказали, что то версия, как бы она, может быть, более простая была, тут вот действительно можно.
А, мы храним этот пунктирный ребро сверху просто как еще на леврогу пути?
Чего еще раз?
Для каждой вершины храним ее предка, но не обязательно корректная.
Нет.
Важно, чтобы для всех пунктов у нас были корректные предки.
Ну, не совсем. Ну, тут по-разному можно делать.
Вообще советую просто, что у вас есть дерево, в нем при желании, как бы понятно, в любом овл дереве
вы можете хранить там этот двусвязанный список вершин в нужном порядке при желании.
Ну, и, смотри, вот ситуация.
Допустим, тебе там для каждой вершины нужно поддерживать, кто там следующий, кто там предыдущий, в чем в массиве они в этом.
При очень большом желании ты можешь просто в каждой вершине хранить ссылку на следующего и предыдущего.
Зачем нет?
Это другой вопрос.
Зачем нет?
Я сказал, что сейчас нет, сейчас вообще незачем.
Хорошо, тогда я не буду рассказывать.
Ну, вот. Нет, ну, как бы при желании.
Ну, при желании это как бы не сильно большая проблема, потому что, ну, под дерево всегда можно хранить там самые левые, самые правые.
Поэтому, когда вы их межете, там, как-то иначе их никогда не проблема.
Вот.
Нет.
Ну, потому что, нет, в ИСТЛ, к сожалению, там функционал, там товар, там структур сильно меньше, чем хотелось бы.
Ну, вот.
Ну, потому что они сделали, потому что для того, чтобы это делать, вам нужно хранить кучу операций, которые в половине случаев использования сетапа тупо не нужны.
Поэтому они в этом смысле пошли по большей эффективности.
То есть, как бы, и поэтому в таких бнот.
Поэтому в таких случаях, то есть, как бы, если вам нужно что-то более продвинутое, либо лезьте в PBDS, либо пишите сами.
Вот.
Ну, потому что это просто менее такое.
Вот.
Сразу вопрос.
А?
Значит, вот как мы будем быстро понимать, является ли либро сплошным или...
А нам это особо и не надо.
А как это?
Где нам нужно это понимать?
Нет, а где нам нужно?
Нам в реальности нужно следующее.
Жила-была-вершина В.
После обдумывания.
Мы будем подниматься, но где будем?
Какую классировку?
А нам же?
А как мы будем быстро проверять?
Мы пока не делаем экстоз.
Нет.
Значит, не выделаем.
А что мы сейчас...
Нет, смотри, все гораздо проще.
Нет.
Погоди.
Пока мы его не делаем.
Нет.
Пока мы сказали так.
Поверим, что вот Expose, там с Кибес по факсу сказали, что
Expose работает залог-квадрат или залог.
Просто поверим, что так можно.
Пока поверим.
Чуть позже, конечно, разберемся.
Пока вот хочется...
На этом этапе хочется убедиться, что Expose действительно нам
решит все вопросы.
Хорошо.
А что дальше?
Ну вот.
Потому что идея такая.
Вот мы стали обсуждать, как сделать верт с помощью
Expose.
То есть как он сделали?
Мы взяли вершину V тогда, объявили, значит, сделали Expose
нам теперь на одном пути с корнем.
Все, что нам теперь остается, это сделать реверс пути.
Какого пути?
Вот этого, который начинается в V и заканчивается вот в
корне.
Мы делаем реверс.
И теперь получается, что V у нас теперь более высокая,
а это более низкая.
То есть по сути мы вот этот путь как бы развернули.
Все.
А вы еще не меняете?
Да.
У нас корневое дерево?
Да.
Тогда надо корень изменить на V.
Да, а ну перезаписать, что корень теперь V, да.
А куда перезаписать?
А можно не перезаписывать.
А мы где мы это вообще храним?
Ну, будем структурой леса, которые будут структурой деревьев.
Нет, на самом деле...
Нет, где мы храним корень?
Нет, на самом деле идея очень простая.
У каждого этого дерева глобально корень...
Корень, что такое корень, это конец пути, из которого
верхний ведет пунктирного ребра.
Или нету родителя.
Ну, или что ж самое, нету родителя, да.
То есть это...
То есть где у него тут в качестве вот этого пунктирного родителя
собственно лежит нул.
Вот.
У всех остальных не нул.
Хорошо.
Мы научились делать...
Да.
Вот.
Ну, например.
Ну, абсолютно аналогичным образом мы ищем всякие вот
эти вот минкосты, а также присваивания.
Вот.
Всякие вот присваивания там минимумы на пути.
Идея будет очень простая.
Вот.
Сначала мы объявляем U корнем.
С помощью эвекта.
После этого мы вызываем expose от V.
Теперь у нас U.
Теперь это тот самый путь от U до V.
То есть он теперь у нас не из логарифа путей состоит.
Из них мы должны...
Да, мы их теперь собрали в один.
Причем так, что еще один тут начинает...
В один начинается тут, заканчивается в корне.
Да.
И теперь...
То есть у нас этот единый путь, поэтому на этом пути
мы теперь делаем абсолютно любую отложенную операцию.
Вот именно я зашел.
Там понятно.
То есть минимум, там хэш какой-нибудь там под строки
и так далее.
Не надо.
У этого есть название?
LinkCut.
Так и называется.
То, что ты описал только что, называется LinkCut.
Да.
Все это...
Ну, если будет такое, LinkCut 3.
Или LinkingCutting 3 еще.
До этого задача была...
Или вот еще?
Это был...
Нет, это называется так структура данных, это называется.
Вот.
Вот у нас каждое дерево представляется как...
Ну, то есть именно хранится в программе как просто набор путей.
Да, именно.
И как ты эти...
Да.
Как ты эти ребра перебрасываешь.
Посмотри, никак не хранится.
Он у тебя где-то лежит в памяти,
а единственный доступ к этой структуре
это у тебя каждая вершина хранит ссылку
на свою соответствующую ноду в дереве.
Понятно.
В каком дереве?
Ага.
А там-то тоже в дереве просто есть предка или нет?
Нет.
Чего?
Где?
Какого предка?
Нет.
В каждом дереве мы храним...
Каждому дереву, кроме корневого,
то есть каждому пути, кроме корневого,
соответствует пунктирное ребро.
Нет.
Именно что в каждом...
Ну, в каждом...
В каждом путь это дерево...
Ну, я поняла ключи.
И в нём нам придётся кондеплет.
Родительская карта нам будет подниматься.
Нет.
Зачем?
Там всё просто.
Там...
Ну, во-первых...
Нет.
Ну, как подниматься?
Во-первых, в каждом дереве мы...
В каждом пути мы легко можем хранить,
с кого оно начинается,
с кого оно...
Где оно заканчивается.
Вот.
Это раз.
А также там в каждом...
Обращение сплит по вершине.
Ну, сплит по вершине.
Да.
Но сплит по вершине мы, кажется,
только что что-то подобное уже делали.
Антон, а ты сказал?
Что нужно релизно будет хранить.
А, ну...
А, в самом дереве?
Ну да.
Но это уже детали.
Вот.
То есть, я сейчас говорил,
что как хранить?
Это глобально,
а не что хранится конкретно в дереве.
Так-то...
Так-то да.
Надо.
Увы.
Хотя нет.
Вот.
Ну, родителей придётся хранить.
Так или иначе.
Да.
Мы тут умеем делать линк, кат и...
Вот.
Сейчас доживём.
Смотрите.
Вот эти вот все безобразия,
пока деревья сами не меняются,
мы делаем без проблем.
Вот.
Ну, с У и В.
Тоже можно тут развлечься, на самом деле.
Там делаем эксполз.
Ну, там делаем...
Ну, точнее так.
Тут мы делаем просто.
Смотрите.
Делаем У корнем.
Делаем эксполз от В.
И смотрим.
Другой конец пути от В случайно не У оказался.
Например.
Можно сделать два эксполза
и сохранить конец пути.
Можно...
Не-не-не.
Ну, не совсем.
Нет, смотрите.
Если делать эксползату,
а потом эксполз от В.
Кстати, давайте разберём этот вопрос.
Это очень интересно, на самом деле.
Потому что, смотрите.
Вот, допустим, мы вот, да,
делаем вот этот запрос.
Да?
Делаем эксползату.
Да?
Вот у нас получается путь до корня.
Делаем эксполз от В.
Сохраняем, что лежит на другом грамме пути.
Так.
А.
Ну, допустим.
Вот.
Теперь приходит вершина В.
Вот.
Вот.
Вот.
Теперь приходит вершина В.
Ну, тогда у нас два варианта.
Либо...
Если...
Либо...
Либо...
После этого эксполза от В, значит,
на этом конце тоже будет Х.
И тогда мы победили.
И тогда мы легко тут вот на этот запрос
ответили.
Да?
Да.
Есть другой вариант.
В находится в другом дереве.
И тогда эксполз от неё
её соединить с другим корнем.
Упс.
Какая проблема?
Да.
Какая проблема?
Да.
Ну.
Ну.
Ну.
Ну.
Ну.
Ну.
Ну.
Да.
Да.
Да.
Ну.
Да.
Так.
Да.
Да.
Но почему я хочу это
именно рассказать?
Потому что тут
очень интересно, просто что
конкретно произойдёт.
Потому что, смотрите.
Потому что, если тут В
находится в том же дереве,
в том же дереве, то произойдёт
что-то такое.
То есть на самом деле,
у нас теперь будет новый путь.
То есть появится вот такой вот путь.
Вот.
И вот тут
появится сплошное ребро.
Да.
Да.
Да.
Да.
Просто тогда, смотрите, просто что приятно, дело в том, что вот эта вот вершинка,
она у нас именуемая среди мирного населения ЛЦА,
вот, теперь она может быть очень легко найдена. Обратите внимание.
Не, ну не только это ЛЦА, ну как видите, это только он один из, то есть мы тут девятым списком мы тут себе это ЛЦА пишем.
А то это структурно было за один линкат, а просто дерево решающее все.
За логорифом, правда.
А то он потом подсунул задачу, где ЛЦА надо за единицу искать удачи.
А то, как вы догадываетесь, константа тут тоже не самая приятная.
А смотрите, а идея очень простая.
Просто так как тут появился одно сплошной путь, то есть путь от У до Х развалился на два.
То есть получается, тогда теперь ЛЦА вы находите просто, берете эту вершину У,
берете путь, проходите по пунктирному ребру, куда пришли тут то и ЛЦА.
Вот.
Так что вот, вот такой вот красота.
Вот. Ну, ну или нет, на самом деле тут есть еще один.
То есть это, конечно, тут сопорены картинку в предположении, что У и В не являются родителями друг друга.
Вот. То есть на самом деле тут остальные случаи надо рассмотреть, точнее один из них.
То есть если у нас тут вершина В на самом деле чисто случайно оказалась на пути от У до Х,
то на самом деле, да, мы обнаруживаем, что сработает это ровно тем же самым способом.
Тут кажется, что будет случай, когда у нас В ниже У.
Да, вот, да, может быть, да, случай, когда В, наоборот, будет УВ.
Мы ничего не найдем тогда.
Нет, ну, смотрите, давайте посмотрим, да, тогда у нас конкретно этот метод не сработает,
но когда мы тут вот распилим вот так, то мы просто можем обнаружить, что мы пойдем, делаем то же самое.
Мы берем У, отправляемся, значит, берем путь, берем так чаще из него пунктирное ребро, обнаруживаем, что оно не ведет никуда.
Мы замечаем, что это бывает ровно в одном единственном случае, когда У являлся предком В.
Следовательно, он и есть ЛЦА.
То есть, да, такую, вот такую мелочи рассмотреть придется.
Вот, но это один маленький ИВчик в конце.
Откуда мы умеем уходить по пунктирным ребрам?
От каждой вершины ребра пунктирной, если у нее же нет ребра.
Нет, ну, я, ну...
Аксиф, это для каждой вершины по номеру храним ее предком.
Единственное, что этот предок обязан быть корректным, если это что-то ребро пунктирное, и не обязан быть корректным во всех составах.
Ну, не массив, а, точнее, да.
Но, на самом деле, ну, массив сложно нам хранить именно массив, потому что массив, мы помним, деревья, дерево какое-то подвешенное.
Поэтому обычно рекомендуется это подвешенное, обычно рекомендуется это пунктирное ребро хранить, скажем, в корне этого дерева.
Можно в корне, можно в самой правой вершине, пожалуйста.
Да.
В корне аварельки.
Например.
Вот.
То есть, например, можно в самом правом, там, пожалуйста, это...
В явном виде массив?
Как?
Это же вершины, все пронумерованные, все номера индивидуальные.
Ну и что, а потом ты эти пути померчал?
Как ты их переписывать будешь, что ли?
Когда я мержу по земле, я вообще ничего не перемешиваю.
Тогда у нас принципиально разные понимания, словосочетания, храню массив.
Храню массив из n элементов в каждой ячейке int, который говорит у вершины номер ноль, предок номер десять, у вершины номер один, предок номер пять.
Ну, по-моему, это называется уже как конкретно хранишь AVL дерево на указателях или...
Нет, предок в смысле не в AVL дереве, а в предок в смысле пунктирное ребро.
Ну, конечно, храним что-то, ну, как бы, куда из нее ведет AVL дерево, но если так пунктирует...
Храним что угодно.
А, ну, какая, ну, я не знаю, ну, хранить его в...
Ну, это называют то же самое, что хранить в самой правой вершине.
AVL?
Да.
Ну, и так проще, чем AVL.
Ну, на вкус и цвет вам мастера разная, это называется.
Ну, на вкус и цвет, я не знаю, у слейтера и тарьяна, например, другое мнение по данному вопросу.
Ну, вот...
Ну, это другой вопрос.
Ах, да-да-да-да. Ой, ну, они это тоже писали, есть такое подозрение.
Они, конечно, не олимпиадники, это да.
Ну, знаете, кто как, кто как, знаете, кто-то тут глядишь на полуфинал, доедет еще. Нет?
Нет-нет-нет, кто-то в среде, я думаю, еще нет, все.
Да, есть, ну, едет-едет, кто-то из вас даже на сборе в Петрозаводске подключался.
Или...
Да, можно пасть кто угодно.
Ну, нет, не совсем.
Нет, кто-когда, кто-когда, кто угодно, кого заявим мы.
А мы все-таки в первую очередь полуфиналистов заявляли.
Ну, это другой вопрос.
Ну, не совсем так, видите, там это все-таки такое...
Ну, да-да, вопрос только бесплатный.
При желании, так, конечно, пожалуйста, да.
Вот.
Но на полуфинал вот уже кто, просто так уже вы не приедете.
Вот, да.
Так что, ну, соответственно, это вот ждем.
Ну, соответственно, это вот ждем.
Когда-нибудь мы надеемся весной там в какой-нибудь Марте или апреле.
Наконец-то мы там съездим в Питер, там сходим в Маринку, как всегда, ну и так далее.
Вот, Маринка.
Господи.
О, Господи.
Господи.
Вообще тихо на что-то не то, какое-то плохое отношение к Маринке.
Вот, безобразие.
Вот.
Ну, ладно.
Вот.
Значит, смотрите.
Значит, теперь, значит, поняли, что много чего можно делать с помощью эксполза.
У вас небольшой вопрос.
Когда у нас У и В оказываются в разных деревьях, что будет происходить?
Когда вы лца ищете?
Только вы просто обнаружите, что когда вы делали эксползату, эксползату В, корнями оказались разные вершины.
Тогда у них...
Просто на пути, который не существует, ты можешь сделать УВ.
Ну, обычно в таком случае говорят, вы видите там, я не знаю, ссылку на вершину.
Ну, обычно у Тарьяна в этом смысле говорят, верните ссылку на вершину или верните Ну, если ЛСАшки нету.
Вон непонятная ситуация.
Да. Ну, как бы очень, знаете, джавайная логика, джавайно-питоновая алголовая, она на самом деле иногда имеет место быть на самом деле.
Нет, в джавае нет. Именно там имеется в виду именно ссылку вернуть.
Да, в СИШной логике это называется верните указатель.
Нет, ну тут по эти нет, просто есть разница, потому что в джаваях и питонах указателей нет в принципе.
А вместо этого у нас есть как бы классы, к которым мы обращаемся по сути по ссылкам, и когда присваиваем переменные, мы переприсваиваем по сути ссылки.
Вот.
На самом деле, да, то есть помните, да, что если мы хотим скопировать, мы должны явно сказать, что да, мы именно копируем.
А всякак бы, когда мы присваиваем, мы по умолчанию именно копируем.
Вот поэтому там вот начинаются всякие детали наподобие тех, которые вот вы сегодня обсуждали.
Что как бы это, да, что хотите предприсвоить что-нибудь, значит то, что там было раньше надо уничтожить, поэтому проследить, что вы не себя присвоили там, ну и так далее и тому подобное.
Да. Ой, Господи.
Как говорится, какая интриба.
Ой, ну вот. Ну окей, окей, окей, да.
Ладно.
Экспоуз так экспоуз, да. Ну, пожалуй, действительно самое интересное.
Так вот. Ну, экспоуз.
Ну, на самом деле, мы уже практически описали, как конкретно будет работать экспоуз.
Потому что первое, что мы делаем, это, собственно, отпилим все, что лежало ниже вершины В, если такое было.
Ну, вот просят нас почему-то такое делать, ну давайте так делать.
Далее у нас все очень просто.
Значит, после этого, значит, жила была вершина В, она была началом какого-то пути.
Этот путь куда-то пришел.
Если это корень, то мы уже победили.
Если нет, то из нее так считает какое-то пунктирное ребро.
Ведущая нас в какой-то вершине У.
Ну, можно на самом деле тут...
Ну, теперь где такая?
Теперь мы выполняем такую операцию, как splice.
А именно, мы смотрим, есть ли у этой вершины У, значит, какой-то вот тут сплошной ребенок.
Ну, вот если есть, то, соответственно, это безобразие мы отспличиваем, а пути смершиваем.
И повторяем операцию.
И повторяем операцию.
То есть теперь у нас есть более длинный путь.
Мы этот путь видим.
Сейчас рыженьким нарисуем.
Вот тут еще.
Если он тут еще дальше идет какое-то пунктирное ребро, мы повторяем операцию.
Вот.
Ну и так далее, пока не дойдем до корня.
Вот прям splice, то есть вот этот expose, вот это вот в тупую будет делать.
Вот, splice мы будем называть вот эту вот операцию.
Это когда мы, значит, когда мы путь подключаем к более высокому пути, возможно, отпиливая от более верхнего пути то, что было ниже.
То есть то, что пошло не туда.
Вот такая вот у нас идея.
То есть соответственно, то есть вот под expose, поэтому я пишу splice.
Тоже там от вершины v.
Я бы сказал даже скорее от вершины u, наверное.
Ну неважно.
То есть фактически expose, ну вот.
То есть теперь мы замечаем,
что, ну как бы, если пока мы пишем вл, мы можем очень просто мыслить, что реальное время работы expose это количество splice, ну, умножить на логариф.
Это если вот так в тупую оценивать.
Поэтому для доказательства симптоидов с кило квадрата она будет естественно учетная.
Вот мы тогда, ну вот мы тогда попробуем доказать, что у нас за там m, там скажем, или даже за q запросов было не сильно много splice.
Ну понятно, не сильно много splice.
Это понятно что-то типа n плюс q умножить на логариф.
Может быть на какую-то константу там множество.
А нет, ну link-cut, ладно.
Ну мы тогда попробуем доказать, что у нас за там m, там скажем, или даже за q запросов было не сильно много splice.
Ну понятно, не сильно много, это понятно что-то типа n плюс q умножить на логариф.
Ну link-cut еще не обсудили, но здесь вот, ну да, link-cut стоит обсудить, конечно, в том плане, что когда мы тут подвешиваем, тут для нас очень важно вот у этой вершины вызвать splice.
Ну давайте уже давим вот, что тут от этой вершины вызвать u и еще v подвесить.
Ну вот, в чем желать подвесить так, чтобы как бы от v до u был путь.
Ну cut, ну с cut-ом понятно, вызвали expose отпилили.
Так что вот такой вот splice.
Нет, на самом деле тут в этом месте начинается такая техника, что как бы вот переподвешивает вот этот путь.
Ну вот скажем так, с нашей текущей точки зрения не зачем, а вот в будущем, потому что когда мы будем тут вставлять splice, нам может потребоваться более тонкий анализ, поэтому может быть нам это пригодится.
Ну тут как бы, ну понимаете, там же просто как бы забегая вперед, как вы догадываетесь, нам придется вводить какой-то потенциал, причем более сложный даже, чем там был может быть в исходном сплее, и надо как-то вот анализировать так, чтобы вот эти операции не сильно его увеличивали, поэтому мы должны быть очень аккуратны.
