Огонь-то, давайте начинать. Да, всем снова привет. Здорово, что вы сюда добрались. На этот раз на
самом деле очень приятно, чем когда ты читаешь более-менее в пустое аудиторию, дальше встанет
виртуальная. Надеюсь, что это будет не просто так, я что-нибудь полезное расскажу. Ну примерно
такой у нас на сегодня план. Сначала я что-то поговорю. Вы же видели запись прошлого раза? Да,
прокомментирую некоторые штуки, которые я сказал в прошлый раз. Там было не все совсем правдой,
а что-то было не очень подробно и стоит к этому вернуться. Дальше обсудим, наверное, последний
раз набор формул, самая продвинутая вещь, которая вам будет постоянно пригождаться. Поговорим,
как устроены ссылки-гиперссылки в техе, как ссылаться на свой же документ на другие страницы,
как ссылаться на что-то в интернете. Тоже постоянно нужная вещь. И поговорим про инструмент счетчиков,
ну вот тот самый, который позволяет какие-то вычисления внутри теха делать, вычитать номера
страниц, номера секций, как-то регулировать эту номерацию и всякое такое. И подробнее поговорим
про создание окружений, которые мы уже много раз затрагивали в контексте того, как именно
хотим пользоваться. Ну там окружение вроде Center и Flashrite и всякие теоремы, которые тоже
являются окружениями, тоже подробнее на этот раз обсудим. Да, и можно приступать. Во-первых,
я заготовил много комментариев на тему всяких переходов на новую строку. Это, на самом деле,
довольно тонкая материя и, наверное, даже не все, что я сейчас скажу, будет целиком правдой,
но нам на текущем уровне понимания, наверное, стоит сказать вот так. Во-первых, есть много,
очень много разных способов перейти на новую строку. Зачем-то они существуют, при том,
что есть просто двойная пустая строка, ну как мы раньше обсуждали, два Enter — это новый абзац.
Но вот есть много альтернатив. Есть команда Park, которая делает буквально то же самое,
что и переход на новую строку. Возникает это про зачем он не пользоваться, если он может
сделать просто двойной Enter. Ну я ответа дать не могу, я не знаю, я никогда не пользуюсь,
мне кажется, это некий overhead. Есть команда New Line и команда Line Break. В прошлый раз я сказал,
что они более-менее эквивалентны, и это почти правда, но тут есть что пояснить. New Line делает
переход вот прям, где вы его ввели, текст идет, идет, идет, потом пишется New Line. С этого момента
строка сразу обрывается и начинается с новой строки, ну вот, с самого начала. А то, что осталось,
ну там, половинка строки осталась, вот она так и есть. Он с ней ничего не делает, просто оставляет
как в том виде, как она осталась. И то же самое делает команда двойной Backslash. Команда Line Break,
она несколько умнее, она дает теху, ну как я сказал, здесь вот рекомендацию, когда перейти на
новую строку, он это не сделает прямо сейчас, он это сделает тогда, когда ему это удобно. Ну там
есть свои правила, по которым он предъявляет, какая вертка хорошая, какая не очень. Скорее всего
справится с задачей. Другое дело, что ни в случае New Line или двойного Backslash, ни в случае Line Break
тех не начинает нового абзаца, ну которые, скорее всего, строки там со стопом предыдущего абзаца и
все такое. Вот все штуки, которые мы задавали параметрами, вроде setLength, что-то там, то ли на
позапрошлом. Это все будет неприменимым, он просто начнет новую строку вплотную предыдущей.
Ну и есть эквиваленты эти команд, но работающие не для строка, а для страниц,
соответственно New Line, New Page, Line Break, Page Break. Та же самая история, New Page начинает новую
страницу прямо вот с этого момента, как вы написали, сразу все обрывает, начинает новую страницу
следующего нашего слова. Page Break тоже считается рекомендательным, ну и заканчивает там, где более
или менее уместно. Вот Page Break мне пораз пригождался. Иногда, если пишут длинные абзацы, в которых
еще какие-то выкладки внутри, может так случиться, что вот если писать его целиком, то тех вынужден
все строки ужимать друг к другу, чтобы все это уместилось на одну страницу, и почему-то он
не догадывается это перенести сам. Наверняка это можно регулировать как-то иначе, но такой
рабочий крестьянский метод — это писать Page Break, где-нибудь ближе к концу этого абзаца, тогда тех
догадает, что ему нужно, хотя бы не в конце абзаца, немножко пораньше перейти на новую страницу и
сделать это. — А может соответствующий вопрос? — Да. — У меня была ситуация, я писал формулу, и я ее обрамлял так, чтобы она была по центру, и у меня вот была
проблема, что я когда это писал все подряд, у меня из-за того, что на строке не хватало места, у меня это уходило
куда-то вправо. Я чтобы, ну как-то справиться по крестьянски тоже, писал чуть там не влайн,
это не очень хорошо, но здорово, что спросил, для этого есть специальное окружение, такие как MountLine, я их упоминал в прошлый раз под запись, но сегодня мы
про это снова поговорим, потому что вещь полезная. Да, в техе много инструментов, как писать многостроечные
выкладки, и там уже не придется такие костыли делать, вот это применимо все для обычного текста, и в общем-то в основном только для
него. Да, чем еще вообще, ну я вообще не рекомендую эти команды использовать, может кроме PageBreaker, потому что
он бывает полезен, ну для строк почему так, ну потому что они даже начинают новый абзац, вам вряд ли во многих задачах в жизни потребуется
начать новую строку, никак и не форматировав, а просто зачем-то скинув на следующую позицию в тексте, это выглядит не очень симпатично, это первая причина. Вторая причина у двойного
бэкслэша, миллион разных значений, он в каждом окружении значит свое, и в целом, каждое дешнее его вхождение затрудняет читаемость, и если кто-то ваш
код будет читать, он может запутаться и подумать, что это бэкслэш, который, ну чтобы на самом деле хотели делать какое-то окружение, вроде там таблицы или матрицы, и там
бэкслэш оттуда пришел, а потом его убрали, и он остался, ну это как-то тоже не симпатично, но вот разница есть, на всякий случай я прокомментирую, что оно вот так.
Я думаю, что даже оправданно, ну какой-то минимальный, например, привести, здесь я как-то делал, я просто размножил очень много текста, одинаково, ну и посмотрим на разные эффекты.
Давайте тут 4,5,6, чтобы было видно хотя бы какую-то разницу, что будет, если я сделаю new line. Если мы верим в то, что я сказал только что, он прервется прямо на том месте, на котором я написал new line,
и да, видите, строка вроде только началась по его правилам, но вот я ему написал, он взял и перешел на новую, и на новую возникло уже 1,3,4,5,6. Ну не симпатично, правда, не тебе отступа красной строки, ничего, ну то есть не понятно для чего это может быть нужно, я как-то не придумал.
С другой стороны, если бы я сделал здесь вместо этого, что там, line break, как было бы? Видите, он, поскольку это все 1,2,3, разница может быть плохо видна, но он их на первой строке поджал таким образом, чтобы они все вместились в три строки, и чтобы хоть как-то их можно было бы форматировать, то есть он принял мою рекомендацию и все правила форматирования этого абзаца немножко подстроил так, чтобы это было хоть как-то нормально.
И новую строку он действительно начал, причем даже не то что примерно там, где я сказал, а вот прямо там, где я сказал, но это мне повезло, могло и не повести, но опять же, это такая экзотика, я не думаю, что в реальной жизни мне могло бы такое потребоваться, вот.
Ну и глобально, если вам хочется делать просто оступы по вертикали, не то что начинает новая строка, а вот именно отделять текст друг от друга какими-то просто блоками пустого пространства, для этого есть команды vspace соответствующие.
Я про них тоже говорил в прошлый раз, vertical space, и в качестве аргумента указывается расстояние, на которое вы хотите отступить, это по всем параметрам удобнее, во-первых, это читаемое, сразу понятно, что вот эта команда делает просто оступ на какое-то состояние вперед, во-вторых, она масштабируема в том плане, что новыми строками вы можете делать оступ только кратными количеством новых строк, а если вам нужно делать полстрочки оступа или что-нибудь такое, то вы тоже не справитесь с такими инструментами. Вот целых два аргумента, чтобы никогда больше то, что я написал, не писать.
Вот, и еще один комментарий по прошлому разу, ну это одно из окружений, которые часто бывают нужны, я просто кратко упомянул, а вот стоит, наверное, сказать подробнее, вот есть такое окружение cases, давайте еще раз, вы видели в прошлый раз, хотя бы в записи, рассказ про всякие окружения математики для многостроительных выкруток?
Ну, конечно, в среднем по аудитории голоса, да, это здорово, но вот там было окружение cases. Какой у него синтаксис? Оно устроено примерно как окружение, которое рисует вам таблицы, опять же, если помните, как мы это делали в прошлый раз. Есть разделители столбсов, амперсанды, есть разделители строк, опять двойные бэкслэши, вот они снова стрельнули в другом значении, не в том, к которому мы говорили на прошлом слайде.
Что оно делает? Оно делает так, чтобы все левые части, ну, то есть, что вообще такое cases? Это разбор случаев, то есть, вам хочется создать функцию на разных каких-то промежутках, на разных множествах, по-разному, естественно, вы левым столбсовом пишете, какие значения должна функция принимать, ну или какими выражениями должна задаваться, а правыми частями пишете, при каких условиях она сдается таким образом, ну и cases все делает наиболее симпатично,
как это вообще принято в теле литературе, он равняет так, чтобы все условия были по одной вертикальной прямой, чтобы они были на нужном расстоянии, чтобы хватило места для всех этих выражений, которые здесь могут возникнуть, дальше они довольно длинные, он их правильно отступит, все отрисует как положено, ну и сам рисует фигурную скобку, довольно удобно, ну, то есть, при довольно малом использовании кода, всего лишь новое окружение завести, он делает полезную вещь, которая часто встречается с каких-то
работах, которые вам тоже может пригодиться, ну и да, это был пример еще и к тому, что вот, аккуратнее с такими там бэкслэшами амперсандами, они очень много где зарезервированы, такие за особые значения, мы это еще много раз увидим, в матрицах, диаграммах коммутативных много в чем, вот, по рампам, со всем в прошлом раз, наверное, на этом все, но вот сейчас будет большой раздел, где мы повторим всякие окружения типа align, gather, на это прям нужно, вот стоит их различать,
я, мне не жалко, вот, ты еще немножко разговор отвести, давайте так, есть ли вопросы, вот, потому что я до этого сказал, огонь, а, да, ну ладно, это не совсем по теме, но давай выбираемся сейчас, не хочет, он говорит, что не скомплировался, а потому что хотя бы, ему не нравится даже пустой документ, абсолютно, смотри, у тебя какой-то кириллический символ, вот это можно просто вот убрать, оно просто не хочет ничего делать,
сейчас, а, ну, можно пойти решить проблемы и посмотреть, на что он, собственно, жалуется, но это сейчас есть, а до этого их не было, он просто не делал пудоевку, если бы документ был совсем пустой, это бы не сработало, просто потому что пустой документ, ну, здесь есть новая страница, есть, хорошо, запустим прям в таком виде, ничего не происходит, не, смотри, раз ничего не происходит, конечно, он все сделал, можно кнопочкой preview в соседней посмотреть, что произошло, она не работала, ну,
значит, тебе очень повезло, что она заработала на этот раз, да, хорошо, значит, это мы можем закрывать и идти дальше, вот, во-первых, окружение equation,
глобально, оно эквивалентное просто окружению экранированной квадратной скобки, но для чего оно может быть полезно, окружение equation, как и многие окружения математического рода, они номируемые,
если вам хочется сделать формулу, на которую потом будете ссылаться, там, типа, смотри, формула 1, то вы пишете какие-то вот такие вещи, в частности, для этого может помочь equation,
у него есть аналог со звездочкой, ну, то есть, equation звездочка, вместо просто equation, он будет ненумерованным, в таком случае он вообще полностью экваленсен обычным окружением квадратной скобки,
ну, как следствие, вам никогда он не пригодится, потому что это писать просто длиннее, чем обычные квадратные скобки, если вам нужен номерация, то вы делаете вот так, вот, ну, и номерация у меня,
здесь просто единичка, а не номерсекция.единечка, потому что это я комплиировал, когда делал презентацию, если бы я жил в обычном документе, который document class article,
ну, который мы всегда до этого создавали, было бы немножко иначе, давайте посмотрим, как,
ну, мне не что-то придумать, сложное,
для меня это довольно удивительно, потому что я немножко другого ожидал, сейчас секцию создадим,
ну, ладно, значит, придется это регулировать отдельно, когда мы идем до счетчиков,
нет, так, он, конечно, сцентрирует, потому что это как квадратные скобки, ну, это выключенные формулы, которые всегда рисуются по центру с новостарки, как положено,
почему я затупил, мне хотелось другого эффекта, чтобы здесь было выражение вида 1.1 в часть первой секции, вот, это можно регулировать, но мы это, видимо, попозже увидим,
надеюсь, что сегодня, если у меня есть такой слайд, иначе, в начале следующего раза, в общем, это тоже еще штука глубоко регулируемая, тут можно аж даже задавать вообще свои символы,
и своими символами это нумеровать, ну, то есть, там, единичкой, а каким-то выражением, мы это вот, это мы точно сегодня увидим, это все, в общем, настраивается,
ну, по умолчанию вот так, да, и окружение align, окружение align нужно до следующего, если у вас есть какая-то, ну, скажем, некоторое семейство формул, которые хочется записать все в одном блоке, там, друг под другом,
или, например, одну длинную выкладку написать во много строк, но при этом как-то грамотно выровняв, сейчас еще поговорим как, вам для этого потребуется окружение align, что оно делает?
оно берет все формулы, которые вы ему дали, и равняет по правому краю, по умолчанию, но это поведение можно регулировать, можно в каждой строке, да, у нас снова строки отделяются двойным бэкслэшем, то есть, это первая строка, а это вторая, даже если между ними нет двойной новой строки, поскольку я поставил бэкслэша, и здесь это как раз уместно, потому что это бэкслэш, который имеет особое значение в каждой среде, в частности, в среде align, и тут как раз принято писать примерно
вот так, в общем, в каждой строке можно поставить символ апперсанда, вот, и тогда поведение меняется на следующее, он захочет все символы, помеченные амперсандами, разместить по одной вертикальной прямой, какой бы длины они ни были, и вот это как раз бывает полезно, сейчас я продемонстрирую для чего, например, у вас есть, да, символ, который помечен амперсандом слева от него,
причем, как мы выяснили в прошлый раз случайно, именно символ бинарной операции, по всей видимости, ну, например, вы считаете какой-то длинный интеграл, я сейчас не буду придумать конкретный интеграл, который хочется посчитать, я просто скажу, что вот, дотс, чтобы было симпатично, еще дотс, новая строка, далее снова равно снова дотс,
ну, скажем, вот, посчитали что-ли, получили, что он равен единице, смотря что будет по умолчанию, ну, пока много проблем, во-первых, непонятная амперсанда, во-вторых, она как-то не выровнялась, но давай сейчас первую проблему решим, как делать, чтобы она выровнялась, а, мы помечаем все знаки равно амперсандами,
ну, это все для красоты, поставлю еще знаки равенства здесь, чтобы показать, что, типа, вычленение закончилось, и дальше считается, вот, ну, вот уже что-то симпатичное, вот такого вида выражения, если какие-то статьи читаете, вы часто будете встречать,
вот какая-то большая выкладка, какое-то одно выражение хочется долго-долго преобразовывать и к чему-то привести, обычно как раз так это и делается, пишется илайн, и куча-куча строк, и все, как правило, равняются как раз по одной вертикальной прямой со знака равно, ну, потому что это довольно удобно читать,
как будто бы каждая новая строка с того же самого места, это типа новый штаб вычисления, да, и, ну, это мы пока решили часть проблемы, вторая часть проблемы, что у нас пока есть нумерация, опять звездочка, наш спаситель, звездочка после любого меморического окружения делает его ненумируемым, если я сделаю вместо просто илайна, илайна со звездочками, то нумерация пропадет, ура, причем, как вы могли заметить,
нумируется каждая строка независимо друг от друга, ну, например, если вы писали бы какую-то систему уравнений, то, ну, и вам хотелось бы по какой-то причине нумеровать каждое из них, в принципе, это неплохое поведение, они тоже можно будут пользоваться, да, что еще отмечу, если бы у нас было два илайна, ну, или там equation илайн, или вообще любые окружения, которые как-то нумируются, нумерация будет согласованной, это все управляется одним и тем же счетчиком, мы поговорим о том, что такое счетчики, и вот,
каждая новая строка, каждое новое окружение математики, этот счетчик инкриментирует, отрисовывает его новое значение, на 1 больше, чем предыдущее, вот, в частности, им можно даже управлять, и между этими двумя уравнениями можно было бы написать команду вида, прибавь к значению счетчика еще единицу, и нумерация была бы уже не четверкой, а с пятерки, мы это сегодня научимся делать, ну, не знаю, это такое теоретически может пригодиться, немножко в другом виде, ну, то есть, в целом управлять какими-то числами в документе бывает полезно, может быть, не в таком контексте, но вообще, ну, вот так,
да, и тут я перечитаю еще дволь много раз о полезных окружений, которые я в прошлый раз упоминал, но не мешает закрепить, потому что это прям реально супер полезная вещь,
во-первых, mountline, это вот то, что только что прям был вопрос, что делать, если у тебя есть одна выкладка, которая хочет списать намного строк, но по какой-то причине вам иллайн не очень нравится идеологически,
можно иначе, можно mountline, давайте для числа эксперимента просто попробуем ту же самую формулу, но уже без имперсентов, загнать в новое окружение, которое mountline, почему без имперсентов,
ну, потому что это особая хича именно из иллайна, вот там она работает, а нигде больше, она, наверное, и не работает, вернее, возможно, в других окружениях
оперсант тоже поддерживается, но он уже имеет другое значение, и вы получите что-то неожиданное, если вы там его оставите, не зачем рисковать, сделаем так,
ага, смотрите, тут выглядит не очень симпатично, но в основном потому, кстати, давайте я сделаю покрупнее, что ли, потому что мне кажется с камеры, иначе будет не очень понятно,
что он сделал, он взял наши три строки и разместил их так, чтобы центры этих строк находились по одной диагонали, то есть будет это прям реально очень длинная формула, давайте размножим много раз,
вот, ну, это становится уже симпатичнее, это бывает полезно, ну, то есть это как бы вторая альтернатива, как можно было писать длинные выкладки, и она еще тем хороша, что здесь она нумирует только последнюю строку, а не все их,
ну, вернее как, она считается просто единой строкой, но побитой на некоторые части, и грамотно выровненной, но при этом, если будет слишком большое количество символов, они же будут очень узкие, наверное,
ну, да, тут есть, конечно, свои ограничения, если вы сделаете полную строку текста, то, наверное, вам тогда странно было вообще использовать самолайн именно в таком виде, вы бы подразвели ее еще на две строки, но, да, если будет слишком много символов, оно как-то не очень симпатично выровняется, но тогда вы будете просто сами виноваты, вот.
Кристина Ивановна, вот в чем соврал, он не прям центры строк ровняет, а все-таки разбивает все пространство этой строки на равные части, да, точно, на три части, и размещает так, чтобы оно начиналось с 0 третьих строки, с одной третьей строки, с двух третьих строки.
Я вот не умею, мне кажется, что нет, ну, вернее так, это можно регулировать почти наверняка командами типа hspace, ну, то есть, горизонтального пробела, можно сместить его влево или вправо, давай попробуем, я не обещаю, что это вообще сработает, скомпилируется, потому что я не помню работать для hspace по тематике.
Если он умеет, то да, ну, смотри, кажется, что ничего не изменилось, да, если я скажу, я еще больше делаю аргументы, по-моему, ничего не изменилось, а, нет, смотри, работает, я указал hspace, горизонтальный пробел сказал, отступи мне вот еще на 200 пикселей, а он взял и отступил, ну, и как я упоминал в прошлый раз, значение может быть 30 пикселей, но я не думаю, что это будет, я думаю, что это будет, я не думаю, что это будет, я не думаю, что это будет, я не думаю, что это будет, я не думаю, что это будет, я не думаю, что это будет, я не думаю, что это будет,
я не думаю, что это будет, я не думаю, что это будет, я не думаю, что это будет, я не думаю, что это будет, я не думаю, что это будет, я не думаю, что это будет, я не думаю, что это будет, я не думаю, что это будет, я не думаю, что это будет, я не думаю, что это будет, я не думаю, что это будет, я не думаю, что это будет, я не думаю, что это будет, я не думаю, что это будет, я не думаю, что это будет, я не думаю, что это будет, я не думаю, что это будет, я не думаю, что это будет, я не думаю, что это будет, я не думаю, что это будет, я не думаю, что это будет,
я не думаю, что это будет, я не думаю, что это будет, я не думаю, что это будет, я не думаю, что это будет, я не думаю, что это будет, я не думаю, что это будет, я не думаю, что это будет, я не думаю, что это будет, я не думаю, что это будет, я не думаю, что это будет, я не думаю, что это будет, я не думаю, что это будет,
я не думаю, что это будет, я не думаю, что это будет, я не думаю, что это будет, я не думаю, что это будет, я не думаю, что это будет, я не думаю, что это будет, я не думаю, что это будет, я не думаю, что это будет, я не думаю, что это будет, я не думаю, что это будет, я не думаю, что это будет, я не думаю, что это будет,
да, он сделал выравнивание по правому краю
про номерацию я поищу, подумаю, сейчас я не помню как это делается
это будет в числе первых слайдов в следующей лекции вот как раз повод будет на нее прийти, послушать
но такая опция уж точно есть, точность окружения, которая умеет номеровать весь объект по центру, как это, если помещать, например, номерацию
просто вот он мне и likes, а я его подзабыл
Ну и здесь снова есть комментарий, который я уже говорил словами, что окружение со звездой не номируется.
Если ваше обычное окружение не генерировало нумерацию, то и вы хотите отключить, то вы пишете окружение со звездой.
Если по умолчанию ваше окружение нумерации не генерировало, значит, скорее всего, звезда вообще не сработает и, может быть, будет ошибка компиляции.
Ну потому что тут нет поведения, которое можно менять, чтобы еще звезду дорисовывать. Вот по такой, наверное, логике.
Вот то, что я обещал, как выбирать конкретно, ну, какой будет нумерация.
Во-первых, команда tag. Что-то стоит понаблюдать.
Во-первых, она, по крайней мере, в этом примере кода посреди элайна, который даже не нумируется.
То есть команда tag, она буквально в любом окружении, ну в любой математике,
берет текущую строку и нумирует ее так, как вам захотелось. Да тут лучше, видимо, третий закон Ньютона.
Ну и давайте я скопирую код, проверю, что я вас не обману, но что правда все так работает.
Надеюсь, должно ничего не изменилось с прошлого раза. Да, действительно.
Вот, в частности, одно из решений, вот прямо предыдущего твоего вопроса, то, как нумеровать конкретную, ну скажем, по центру.
Выбираешь среднюю строчек, пишешь там tag и указываешь то значение, которое тебе хочется.
В принципе, тоже вполне себе выход. Хочется, чтобы это еще и было значение автогенерируемое,
ну то есть по тем же правилам нумерации, что и все остальные.
Но вот про это мне нужно еще почитать. Я сейчас так не могу сказать, как это делается.
Вот, есть команда tag. Как потом к таким штукам отсылаться, мы поговорим чуть попозже.
Ну вот, синтез базовый такой.
Да, это тоже то, что я в прошлый раз говорил, что некоторые окружения генерируют внутри себя режим математики сами по себе.
А некоторые, чтобы существовать, должны уже быть в режиме математики.
Например, режим математики, это я называю основой либо там доллары окружения, либо квадратные скобочки, но все как всегда.
Некоторые окружения, такие как align, mouthline, gather, они сами по себе делают окружение автоматическим.
Там прямо-то прописано, что align его открывает, ну вернее begin align ее открывает, а end align ее закрывает.
Поэтому здесь не нужно ни доллара, ни квадратной скобки, ничего, оно работает само по себе.
С cases наоборот. Cases требует вокруг себя чего-то, что включает режим математики, и он не скомпилируется вне его.
Я мог бы, как в примере, который был пораньше про функцию Dirichlet, завернуть cases в обычные квадратные скобочки.
Но мог бы завернуть его и в любой другой режим, который открывает математику.
Например, окружение тоже самое align или gather.
Сейчас, не очень примутый вопрос.
Мы сделали cases внутри квадратных скобок.
Да.
А можно ли, наоборот, сделать внутри cases квадратные скобки?
Я думаю, что нет. Это не должно скомпилироваться, потому что...
Короче, да, в код cases почти наверняка зашито, чтобы проверить, что находится внутри математики.
Если не находится, то выкинуть ошибку. Скорее всего, это работает вот так.
Но это вопрос грамотный, давай его проверим.
Да, видишь, missing dollar inserted.
Ну, то есть, он попытался проверить, что он в математике, в долларах, и оказалось, что это не так.
Он попытался это как-то исправить, вставить доллары в нужные места.
У него ничего не получилось.
Вывод, надо просто так не делать.
Ну и, для верности, надо проверить, что, если я сделаю уже вот так, то у нас работает.
Ну, что характерно, мы используем cases не по назначению.
Он же нужен, чтобы рисовать какие-то разборы случаев, начиная с фигурной скобки.
А тут у нас просто какое-то равенство.
Ну, давайте представим, что тут было написано не cases, а какое-то другое окружение.
Скажем, окружение aligned.
Вот я говорю про окружение aligned, оно математику создает само по себе.
Ну, открывает и закрывает.
Окружение aligned, оно работает как align, но при этом оно является окружением, которое вкладывается в математику, не создавая само по себе.
Ну то есть, если вам нужно сделать сложную систему вложных окружений, скажем, cases, чтобы разбирать случаи,
и внутри него еще какие-то многостроечные выкладки, вот там уже нужно будет окружение aligned.
Align не сработает, потому что он откроет математику снова, она уже открыта, и все упадет.
Вот. В этом все разница между align и aligned.
Ну, давайте, чтобы быть уверенным, я предемонстрирую, что вот я так пишу aligned.
Это снова не вполне по назначению, потому что строка всего одна, а, как мы понимаем, такие окружения нужно писать много строк подряд.
Но глобально это работает, будучи вложным.
А если я сделаю не вложным, то оно, наоборот, работать перестанет.
Да. Ну вот, видите, allowed only in math mode.
Ошибка другая, но смысл такой же. Нужно было математику открыть, иначе ничего не сработает.
Вот.
Ну и здесь примерно такой же пример, что вот я открыл режим математики с помощью align, а дальше пошло cases.
Ну, которым, кстати, можно записывать и просто систему уравнений.
Ну просто в чем разница? Тут мы не использовали амперсанды.
Те амперсанды, которые выравнивали правую часть текста по какой-то другой границе справа.
То есть, в принципе, кейс можно использовать и так, просто по системе уравнений.
Но можно и иначе. Можно делать, смотрите как.
Это вы не с презентажки, но это просто стоит прогаментировать, что так бывает.
Допустим, я хочу там не систему, а совокупность, да, то есть не фигурную скобку, а квадратную.
То есть кейс уже не прокатит, уже не сработает.
Я могу сделать так. Я могу сделать left, квадратная скобка.
Ну давайте пока тоже write, квадратная скобка.
Помните, что это такое, да? Это скобки, которые масштабируются по размеру содержимого.
А внутри сделать просто набор строк с помощью команды align, той самой, которая как align, но внутри математики.
Ну потому что она реально вложена в математику, очень логично именно здесь ее применить.
Ну и написать такую же систему, там x равно 1, y равно 0.
Вообще неважно. Ну и да, бэкслайдж, конечно, строки отделить.
Ура!
Команды left и right настолько умные, что они взяли квадратные скобки и завернули в них все содержимое,
которым являлось аж несколько в строк подряд.
Но для совокупности, как мы понимаем, хотелось бы иметь только левую квадратную скобку, а правую не иметь, да?
И выход для этого такой. У команды write в качестве аргумента не скобка, а точка.
Она отличает, что пустая скобка без ничего.
Ну вот, сработало. Вроде симпатично выглядит.
Это полезно, этим можно пользоваться.
Да, и, разумеется, скобка может быть любой, если хотите, скажем, фигурной.
Ну и тогда мы сделали буквально то же самое, что и кейсис, просто более сложным образом.
Но будь у нас скобка, опять же, квадратная, или там, не дай бог, круглая, по какой-то причине,
то это бы уже у нас не сработало. Ну, с помощью кейсис. А так сработает.
Вот.
С этой частью, я думаю, всё.
Ну и вот как раз, раз мы заговорили про всякие там скобочки, естественно упомянусь, как рисуются матрицы.
У вас уже, наверное, были матрицы, да?
Ну какому-то видео уж точно.
И вам постоянно может прикажетаться их рисовать, если вы пишете какие-то там алгебарические выкладки.
И вот для матриц много разных окружений, которые работают примерно похоже на окружение для таблиц.
Если помните, для таблиц, ну или там, как мы видели сегодня, скажем, для а-лайнов или для кейсов,
есть разделители строк, бэкслэши, и разделители столцов, амперсанды.
Матрица забивается так. Ну, просто всё содержимое вот по ячейкам, разделяя, где нужно, амперсандами,
элементы одной строки, и бэкслэшами строки друг от друга.
И заворачивается какое-то окружение. И вот окружение для матриц есть несколько.
Есть p-matrix, который рисует матрицу, у которой будут круглые скобки.
Я не знаю, от какого слова p, возможно, от слова parenthesis, ну вот скобки.
Есть v-matrix, который рисует вертикальные черты у матрицы.
Что? Нет, v-matrix. А, для чего это может быть нужно?
Я вообще видел носации, в которых просто матрицы рисуются как штучки в этих вертикальных чертах.
Ну да, для определителя в частности это полезно так рисовать.
Кажется, что когда я писал какую-то алгебру, я тоже рисовал определители.
Ну, терминант, как ты говоришь, то есть через v-matrix.
Ну давай скопирую и посмотрю, что это сработает.
Но да, мы тестируем сейчас другое окружение. Мы тестируем окружение не p-matrix, а v-matrix.
Поэтому придётся поменять.
Да, действительно, вертикальные черты.
Может возникнуть вопрос, а вот если хочется рисовать две вертикальные черты или там ещё что-то,
вот я сейчас не помню, как это делается.
Есть ещё более хитрое окружение array, которое делает примерно то же, что и line,
но оно ещё и настраивается по-разному, типа как отделять друг от друга разные столбцы,
как там, во что его заворачивать, какие там поставить пробелы.
Это довольно сложно, я в предстоящий раз расскажу.
А сейчас давайте предположим, нам захотелось нарисовать двойные вертикальные черты.
Возможно, это сработает. Сейчас сходу не знаю, будет здорово.
Но мой вариант такой, я предлагаю завернуть это в left, вертикальная черта, right, вертикальная черта.
С ними это тоже должно работать.
Опять помните left, right, которые просто берут скобочки, вертикальные черты тоже считаются скобочками.
На них тоже спространяется, тоже будет работать.
Давайте проверим.
Left, вертикальная.
Мне тоже так кажется, но давай проверим.
А, смотри, конец одного размера.
Получается, мы нашли ещё один способ, как это можно сделать.
Другое дело, что они как-то друг от друга на большом расстоянии.
То есть обычно, когда их две подряд, они как-то друг от друга поплотнее идут.
Скажем, если я сделаю здесь какую-то таблицу.
Ну буквально чуть-чуть.
Ну сейчас сравним, прям сравним.
Так, таблица это tabular, да?
Много-много параметров.
Не хочу указывать.
Вот.
А, tabbing.
Tabular это немножко другое.
Видимо стоит и про это тоже поговорить.
В чем разница и все такое.
Но сейчас я сам исходу не помню.
Поэтому будет не очень просто.
Слушайте, я забыл округление для таблиц.
Как же так?
Просто раз оно было прямо в слайдах.
Нет, давайте я просто подсмотрю.
У меня, собственно, презентации тут тоже все заготовленные это есть.
Мне, конечно, тоже там быть стыдно,
но тут довольно много разного кода
и так бывает, что можно что-то забыть.
Не, все-таки tabular. Что ж он-то не сработал?
Слушай, мне кажется, это встроенные вещи с теха.
Оно должно прямо из коробки работать.
Возможно, дело было в вёдочке.
У меня же, конечно, там была вёдочка.
Ну, давайте проверим,
что оно должно сработать.
Фу.
Вот, лали.
Оно как будто бы... Да, вот.
Видишь, тут сильно более плотно
друг к другу идут вертикальные черты.
То есть, наверное,
я почти уверен, что с помощью окружения
array можно сделать такие же плотные
вертикальные черты и в этом случае.
Но про это сегодня говорить точно не буду.
Пока что мы придумали хоть какой-то
способ, как это можно было бы нарисовать.
Ну, еще, как всегда, наблюдение. Смотрите, тут
у нас прямые латинские буквы, а тут косые.
Ну, курсивные. Ну, почему? Потому что
это текстовое окружение, это
обычно текстовые буквы, а это буквы, как
математические вы будете, переменные.
Странно, а таблицы, вроде бы, казалось бы, что это должно
что-то математическое быть?
Ну, нет, таблицы, это любая статистика,
что угодно, когда-то всё завершится в таблице,
разумеется.
Это нужно обычные тексты тоже.
И, видимо, как раз тейбинг
немножко более математику
нужен, но я про это в следующий раз поговорю.
Сейчас, опять же, сходу
что-то не помню.
Ну, хорошо, смотрится
мы разобрались.
И вот просто более
сложный пример, как можно было бы
делать матрицы.
Сейчас всё прокомментируем, что-то написано.
Первое наблюдение.
Что я зря сделал? Тут
окружение Ln со звездой, но здесь оно
нужно только чтобы математику открыть и закрыть.
То есть, с тем же успехом я мог бы сделать
квадратные скобочки. То есть, не пугайтесь
то, что я тут написал. Я это, наверное,
когда слайды буду выкладывать и справлю,
просто чтобы было более читаемо, тут
эффекта никакого не имеет.
Главное, что нас интересует, собственно,
вот эта вот матрица. Ну, как всегда,
окружение Pmatics, мы его
открыли-закрыли, и внутри синдокса
снова такой же. У нас есть
некоторое количество строк, некоторое
количество столцов. Содержимое
одной строки, но раза столцов,
отделяется апперсандами.
Строки друг от друга отделяются
вдалим бэкслэшами. И если мы
грамотно это выровняем,
вернее, тут даже неважно,
что они находятся на одном и том же
вертикальной прямой. Если бы я про белых
поставил больше или меньше, ничего бы не изменилось,
он выровняется сам, разумеется. Но так просто
более читаемо получается, что
наглядно. У тебя и тут оно в таком
виде, и тут в таком виде.
Но вот что стоит еще сказать.
Во-первых,
во-первых обман. Тут у меня, видите,
индексы с запятыми должны быть, а тут не без
их.
То есть, на самом деле, тут их тоже быть не должно.
То, что отрисовалось на запятых, конечно,
не имеет. А во-вторых, тут разные виды точечек.
Много-много точек, видите?
Есть C dot,
что это такое? Это точки по центру
строки. Ну, C, слово «центр».
Есть V dot, это вертикальные
точки. Есть D dot,
диагональные точки.
Тоже все максимально прозрачно.
А вот у меня вопрос в связи с точками.
Я искал, какие вообще бывают
виды точек, и мне нужно было знак кратности поставить.
Вот я нашел вариант
vertical dot. Это хороший
вопрос. Знак кратности,
к сожалению, в техе не получается
делать метод его из коробки.
Нужно делать свой.
Мы будем обсуждать, как делать свои спецсимволы.
Для этого есть инструментарий, который называется
всякие скейлбоксы, ротейдбоксы.
Я про это поговорю в следующий раз обязательно.
Это прям важная штука.
Наверное, ты нашел какой-нибудь ответ
на stackoverflow, где есть хоть какой-то вариант
как задать эту команду кратности,
и его скопировал, и дальше им пользуешься.
Нет, я на самом деле забил
слова, которые я писал. А, ну или так.
Это тоже третий выход.
Можно делимость обозначать в другую
сторону. Не то, что там...
Сейчас.
Не то, что там
4 делится на 2.
Пока что V dot, пока не будем
создавать свой символ. А можно написать,
что 2 делит 4.
Нет.
Для этого есть символ mid.
Это не очень большая вертикальная палочка.
Да, есть такая
аннотация, что 2 делит 4 обозначается
это вот так. Так тоже можно делать.
Про то, как
сделать знак кратности. Тут три точки маленьких.
Поговорим. Это прям...
Ты здорово напомнил. Это хорошая идея.
Можно вообще написать 4 раз на 2x и x?
Это конечно
тоже можно, но мы как-то изобретаем слишком большой
велосипед, как мне кажется.
А Vmatrix
это на что?
В начале две палки?
Vmatrix это одна палочка. Просто вертикальные
ограничители матрицы. Ну, слово vertical.
Есть еще какие-то.
Есть, кажется,
Bmatrix, которые в квадраты
скобки заворачивают. Возможно, не B. Возможно,
другая буква. Лучше погуглите.
Это все очень просто гуглится. Просто типа
matrix в слотях. Вбивайте
и вам наверняка все окружение эти найдет.
Ну, вот я парочку просто упомянул, что
такое существует.
Вот. На этом слайде, наверное,
теперь все должно быть понятно. Вот есть разные точечки.
И вот так можно большие матрицы
рисовать. Ну, неогранично большие.
Все элементы, которые лишние,
пропускают точечками.
Нужно направление.
Вот. Наверное, вопросов
на этой сайте больше быть не должно. Давайте двигаться дальше.
Этот слайд
не от меня. От моего коллеги
Леша Ребликова. Он, наверное, будет в следующий раз
что-то рассказывать про графику
в техе. Но вот
он пользуется пакетом nice-metrics,
который позволяет
рисовать матрицы как-то...
Ну, так называется пакет.
И так его разработали.
Ну, короче, это как матрица, но с более гибкой
настройкой. Скажем, можно сказать, чтобы
отделили мне последний столбец
вертикальной чертой. Помните, как
в таблицах, когда было типа
tabular, а потом у тебя есть вот эта вот настроечка.
Как выравнивать каждый
столбец по левой стороне, по правой, по центру
или там еще как-то иначе.
Как иначе, еще поговорим попозже.
И вот для nice-metrics
это тоже работает, можно
пользоваться. Я этим
не пользовался, не могу ничего порекомендовать
отдельно, но вот есть
мануал. У меня тут нет интернета.
Прямо сейчас. Но
ссылочка рабочая, я слайды выложу, сможете
по ней пройти, почитать, если что, воспользоваться.
Вот.
Ну, это скорее такая рекламная интеграция,
чем содержательный рассказ.
Да, ссылки.
Это было обещано. Ну и, кстати,
тут вот прямо сейчас я использовал в Техе
ссылку. Вот я про такое сейчас буду рассказывать.
Как такие вещи делать,
чтобы потом это было кликабельно и можно было переходить.
Вот.
Во-первых, можно ссылаться
на штучки внутри документа.
Вот.
Ну, вот.
Что на слайде написано? Да, это делается
с помощью команды label. Сейчас я все поясню.
Во-первых,
ну, то, что здесь тег, не обращайте
внимания. Ну, это просто осталось
со слайда, который демонстрировал возможности
команды тег.
Как сделать так, чтобы у вас
были какие-то метки в тексте,
на которые потом можно было бы ссылаться.
Вот.
Типа, смотри такую-то страницу или смотри такую-то формулу.
Для этого вы
помечаете конкретные объекты.
Например, объекты вида окружения,
ну, какое-то математическое, будь-то там
aline, будь-то gather, будь-то просто какая-то формула,
equation,
команды label.
Она задает, ну, ее аргумент,
это любой набор символов, он значит
следующая. С этого момента
у вас есть специальный маркер, который
указывает, ну, маркер с таким
названием, который вы указали здесь,
который указывает на нужное место в тексте.
Ну, примерно так.
Наверное, да, можно так сказать.
Вот. То, что здесь написано,
ну, есть просто некие
код-стайлы, которым можно придерживаться.
Некоторые код-стайлы рекомендуют писать, типа, что вот
если у вас уравнение, то сначала пишите EQ
от слова equation, а потом там двоеточие,
а потом уже вашу номерацию.
Вообще не важно, можете как угодно писать.
Это просто, ну, так, артефакт
конкретного примера. Ну, вот, допустим,
я захочу сделать equation,
в котором
будет, ну, я даже не знаю, что написать.
Давайте один больше нуля. Снова
разрешательное утверждение.
И вот тут я помечаю
label, ну, какой-то текст.
Ну, допустим,
fact
1, 0. Ну, почему бы
нет?
Сейчас это наше жизнь никак не отразится.
Ну, потому что, что мы сделали?
Мы поместили какой-то, пока никак
не отрисованный указатель
куда-то на странице. Нам нужно учиться
еще на него ссылаться. Вот.
Сейчас мы научимся.
Делается это
с помощью команды ecref.
Давайте посмотрим.
Что делает команда ecref?
Типа, смотри.
Ну, и далее
label, тот самый, который мы указали.
Видите, он даже подсказывает, что можно написать,
потому что он, ну, сам хранит
все лейблы, которые я указал.
Вот. По крайней мере,
редактор VS-кода так устроен.
В общем, он понимает,
что я хочу именно это, и сейчас
оно все получится. Почему формула 1?
Ну, потому что я задал ей номерацию номером 1.
Вот. И, как
видим, ecref что сделал? Он
развернул, ну, он прошел
по этому указателю, смотрел, ага, он указывает на
формулу, которая номер 1. И нарисовал
нам выражение вида 1 в скобочках.
Если бы у меня был какой-то другой текст здесь,
вспоминаем команду
скобочек, который залеет тегать любым другим символом.
Скажем, давайте
тегаем это. Так, господи,
не важно, 666 или 66.
Не отпечатал.
Оно тоже сработает. Во-первых,
номерация изменилась на 66.
Во-вторых, у нас теперь, смотри, формула 66.
Почему это удобно? Почему не писать
просто, смотри, формула 66?
Ну, скажем,
я мог просто написать, типа, вот,
буквально.
Давайте, математики.
Скобочек 66.
Чем это плохо?
Ну, например, у нас
еще одно уравнение выше добавилось,
номерация съехала. У нас
это стало номером 67,
а тут-то не поменялось, потому что мы это указывали
руками. А если бы мы указывали
по-умному, то оно бы тоже на нужный момент
поменялось, и все было бы согласовано.
То есть, многие вещи в техе
может показаться, что это,
ну, типа, какое-то излишество, и можно бы это
сделать, но они нужны для того, чтобы
согласованность охранялась для всего документа,
и вы это, ну, типа, вам не пришлось
думать об этом самим.
Это, ну, когда вы пишете большие
тексты, какие-то там статьи, или там,
не дай бог, книги, у вас уже
возникает очень много объектов,
там, которые друг на друга
ссылаются по каким-то номерам, и за этим
следить руками просто было бы невозможно.
А вот с помощью этого
это делается просто на автомате и вообще не требует
ваших усилий. Вот такая мораль.
Сейчас еще раз, то есть у нас получается
два способа братья, либо
писать qrf и вот ключ,
либо
мы пишем, получается,
а, вызов по тегу, либо.
А, не, подожди, это же точности
то же самое. Ну да.
Ну, я и говорю, это две опции? Нет, это, нет.
Сейчас ты имеешь в виду вызовом по тегу,
ты имеешь в виду то, что ты сейчас написал? Да.
Нет, сейчас я просто написал руками, скобка,
66, скобка. А, точно. То есть, это
вообще ничего другого не значит, он никуда
не ссылается, это просто текст.
И как раз, если бы я тут сделал другой тег,
скажем, ну, наконец-то, сейчас 6 ты писал бы,
то тут бы оно поменялось, а тут уже нет
и оно уже, ну, не работает.
То есть, формулы такой уже нет в документе.
Окружение equation нужно
для чего-то или нет?
Equation нужно было бы,
чтобы нам нумеровать формулы.
А, понял. Поскольку мы уже написали
здесь тег и задали номер сами, это, в принципе,
уже излишество. Могли бы уже без equation
здесь. Ну, просто
так сложилось, что вот конкретно
в этой ситуации мы написали equation. Кстати,
я не уверен, можно, ребята, label для просто
формул, которые даже не equation,
а, ну, скажем,
просто вот в таком окружении, в обычном самом,
которые квадратные скобочки.
Давайте проверим. Интересная задача.
Да, смотрите, тоже будет работать.
Значит, если я здесь сделаю снова ecref
на
1,0.
Да, смотрите.
Вообще сейчас
что-то случилось.
Нет, вроде бы
скомплировалась, вроде бы. Это уже актуальная штучка.
Давайте, чтобы убедиться, что это
не старый документ, я что-нибудь еще припишу.
Ну, на всякий случай еще
да, это актуальный документ, он работает,
все хорошо. Смотрите, что
я сделал командой tag. Я
текущую строку в математике,
даже несмотря на то, что это не какое-то там
хитрое окружение, а просто обычные квадратные скобки,
я текущую строку пометил тегом.
И с этого момента у нас есть
указатель на эту конкретную строку.
И на нее может ссылаться команда ecref.
То есть команда label никак не привязана к конкретному
окружению. Ее можно применять вообще в любой математике.
Ура.
А можно ли
делать активную ссылку на фрагмент тексти,
чтобы он прям тебе перегибел?
Чтобы она была крикабельна? Да, это нужен пакет
каштахref. Сейчас мы примерно поговорим.
Это будет.
Ну что, еще тут стоит посмотреть,
что есть еще pageref.
Он указывает...
Ну, кажется, понятно. Он указывает на
номер страницы, на которой расположен какой-то объект.
Ну, тут не формула.
Видимо, смотреть страницу, один был
правильно написать.
Он просто вместо
вот этого выражения, pageref
и названия подставит номер
страницы, на которой находится объект,
под таким же именем, который мы указали в качестве
переменной. В данном случае как бы неинтересно.
Первая страница, поэтому номер один и подставился.
Но повторюсь, если у вас большие документы
с кучей страницы, это очень полезно,
потому что вы не следите никогда в жизни
за этим всем самостоятельно, чтобы все указывал
на правильные страницы.
И это тоже можно делать крикабельным.
И здесь тоже нужен пакет, которым мы сейчас
попозже поговорим.
Вот, ну на этой стадии, наверное, все очень понятно.
Да?
Вот, pageref.
Вместо этого выражения
в тексте подставится номер страницы,
на которой находится данный объект.
Объект, который
подписан лейблом Factor 10.
Вот, который вот здесь вот.
Да, ну еще есть
figref, чтобы указываться
обращаться конкретно
к фигурам. Мы еще не говорили
про фигуры, поэтому эта информация вам пока
не очень пригодится.
Ну и вообще можно было бы
просто делать ref.
ref и ecref эквивалентны в том, что
ecref работает просто конкретно
для формул. Ну просто номировать можно
разные вещи. Можно номировать страницы, можно
номировать там картинки, можно номировать
секции. И вот
есть для этого разные refs.
И просто ref работает для всего.
А ecref он проверяет, что он отсылается
именно на формулу. Как он это понимает?
Ну потому что мы лейбл указали именно для строчки
математики, ну то есть для формулы.
Поэтому оно сработало. Но сработало бы
и просто ref, если бы я сделал
просто ref.
Ну вот, да, снова c6.
Но что характерно, оно уже
не нарисовало нам эти круглые скобочки.
Смотрите, если мы сделаем
ecref,
оно нарисует там круглые скобочки, потому что
именно в таком формате отсылается именно
на уравнение, ну на equation.
То есть в него просто это зашито.
А в ref ничего не зашито, он
оставляется на что угодно, что ему скажут.
И вот ему сошлись на объект, который называется
fx10. Он идет, ага, объект fx10.
У него tag666.
Ну его и подставлю, значит.
Без скобочек, без всего. Вот.
Ну то есть просто более общая команда, которая может быть
для чего-то еще нужна.
Так, есть ли вопросы по этой части?
Нет. Огонь.
Ну это не совсем про то, о чем мы говорили.
Это внешние ссылки.
Это как ссылаться на какие-то url в интернете.
Есть просто команда href,
ну href,
типа гиперссылка hyperref,
я так понимаю.
Ну синтез очень простой.
Команда href, у нее два аргумента.
Аргумент, какой url,
на какой url ссылаться в интернете.
А второй аргумент, какой текст вместо него поставить.
То есть на самом деле вот здесь,
вот эта вот штучка сгенерирована такой командой.
href, ссылка
Google и подпись google.com
Ну, я конечно могу кликнуть,
но у меня ничего не сработает,
просто потому что у меня нет интернета.
Вот.
Сейчас, слушайте, а я вот,
блин, получается я в этот рассказ не включил,
как делать скрикабельные ссылки.
Знаешь, да,
ну типа, чтобы ссылки были не просто,
как мы и сделали, как мы научились делать
на какой-то номер.
А чтобы на нее можно было кликнуть,
он нас сослал на нужную страницу.
Да, это можно.
Для этого есть конкретный пакет.
Я был уверен, что у меня слайд про него в этой презентации.
Но он, видимо, в следующей.
И даже если это не так, я его сделаю в специальной презентации,
про него расскажу.
Это можно делать.
Но, кстати, мне вот так, мне очень нравится.
Я прям везде руками говорю,
даже если подключен этот пакет,
я отключаю всякие присылки.
Это хорошо, что крикабельнее,
когда можно случайно попасть.
Но так можно делать,
мы при этом поговорим, как это делается.
На самом деле, это совсем несложно.
Вам нужно просто подключить к специальный пакет,
который сейчас подзабыл, как называется,
и там нужно настроечки указать.
Про настроечки тоже просто поговорим.
И это уже будет работать в таком же виде.
То есть, вот этот текущий код,
он сделает не то, что сейчас,
а сделает тут крикабельную ссылку.
То есть, даже не придется нового писать,
но поговорим.
Да, ну и конкретно вот что сейчас заготовлено.
Есть такая штука сноски.
Ну, footnotes.
Ну, оно буквально...
Во-первых, что делает footnote?
Текст,
который является ее аргументом,
помещает в качестве сноски.
То есть, убирает его
с главной страницы
и перемещает его вниз.
Ну, под нужным номером.
У них тоже есть
своя нумерация.
Она задается тоже лейблами.
Да, у сносок есть своя нумерация.
То есть, если бы была еще
еще одна footnote, было бы уже
под номером два и так далее.
Ну, как в обычных технических наверняка такое видели.
И если мы хотим на них ссылаться,
мы тоже можем помещать конкретный footnote
command-label, чтобы потом
на нее ссылаться с помощью ref.
Ну, мы уже видели command-ref, command-label.
Они работают не только для уравнений,
значит, они работают еще и для сносок.
Для чего еще? Ну, сейчас не очень важно.
Да, по умолчанию
сноски всегда отделяются
вертикальной чертой от всего остального текста.
Наверняка это можно регулировать,
но, если честно, я никогда не делал всех документов сносок,
поэтому я не знаю, как это делается.
Я думаю, это можно загуглить.
Наконец, счетчики.
Да, на всякий случай.
Это же было понятно, вопросов не будет.
Я могу двигаться дальше, да? Хорошо.
Да, счетчики.
Это вот инструментарии
и теха, которые позволяют делать какие-то вычисления.
Счетчик – это буквально числовая переменная.
Ой, я потерял заглавную букву, я потом это исправлю.
Чтобы задать счетчик,
нужно использовать команду newcounter.
Да, поскольку теха – это не какой-то язык программирования,
это все-таки язык разметки,
там сложнее работать с переменными.
Тут нет типа арифметики.
То, что вот a плюс b
равно чему-то там
задать какое-то значение.
Командами теха,
ну как бы инициализации переменной,
это команда newcounter.
Она задает счетчик, которого помолчали на любое значение.
Есть более хитрая команда,
которая...
Ой.
Ну вот, мне ни разу не прикаждалось,
но вот есть такой синдексис,
можно указать еще в побочный аргумент
после основного в квадратных скобках.
Это как бы эти два счетчика
завяжут друг на друга в следующем смысле.
Мы можем как-то значение счетчиков
модифицировать, инкриментировать,
но как только инкриментируется счетчик первый,
второй будет обнуляться
и как бы начинаться заново.
Ну, где мы такие эффекты видели?
Секция и подсекция.
Секция номируется там 1, 2, 3,
но в рамках секции,
под секции номируется
каждый раз заново с единицы.
Как будто мы делаем такую же связь.
Мы задаем связь как будто бы
между секцией и под секцией,
только своими новыми переменами,
которые name и other name мы назвали.
Но, опять же,
как мне кажется,
все такого рода связи,
которые нам могут пригодиться,
секции и под секции,
или, может быть, теоремы естественные из теоремы,
их можно регулировать и без использования счетчиков,
поэтому вот в голом виде
место не берегажалось ни разу.
Кстати, если вы смотрели прошлый раз
запись,
такое же синдексис работает,
когда мы хотим сделать номерацию
следствий после теорем.
Мы хотим, чтобы у нас
была теорема,
чтобы она номировала, скажем,
1, 2, 3, и вот были следствия из теоремы,
отдельный вид теорем.
Плохо, что это называется в русском теоремам.
Давайте, у нас была категория теорем,
теоремы, которые
номирались 1, 2, 3.
А потом мы сделали категорию теорем следствия,
которая номируется в честь теоремы.
теорема 1, следствие после нее это 1.1, 1.2 и так далее. После теоремы w либо следствие 2.1, 2.2 и так далее.
Там-то определялось точно так же. Сначала объявлялось, ну, то есть там new-серием, что-то там, тут и вот в конце был аргумент в угарноскопках
категории теорем, все из которой нужно это нумеровать. На словах не очень понятно, но это было в слайдах, и там, в общем, был такой же синтаксис.
Сейчас не очень важно, даже если вы не совсем поняли, просто, ну, к слову, что устройство и синтаксис более-менее одинаково.
Для счетчика можно работать, как я уже говорил, не арифметически, а используя всякие команды.
Есть step-counter, это буквально инкрементировать, ну, прибавить единичку. Есть add to counter, это прибавить конкретное число.
Соответственно, add to counter название, и вторым аргументом 1, эквивалентно просто step-counter, ну, то есть, инкремент, увеличение на 1.
А можно прям задавать числовое значение, это делается через команду set-counter.
Ну, опять же, все переводится английского очень-очень прозрачно.
Да, аргумент name – это название счетчика, которым вы работаете, в частности, ну, тот, который вы объявили, допустим, под названием name, вот, можно на него ссылаться, написав name.
Второй аргумент, который здесь есть, это какое-то число, причем, возможно, даже отрицательное, он их тоже воспринимает.
Что характерно в техе много встроенных счетчиков, хотя, наверное, про это еще поговорим, в общем, в техе много встроенных счетчиков то, что мы видели
номерация секции, номерация страниц, это все тоже делается счетчиками. Есть счетчик page, который отвечает за номер страницы, есть счетчик section, который отвечает за номер секции, ну, и так далее.
В частности, если вы помните, у нас была, как мы делали калантитала, и в калантитале мы указывали номер страницы с помощью команды thepage.
Вот это все не просто так, сейчас мы про это тоже поговорим. Ну, это как раз один из вариантов работы счетчиками. Так выглядит.
Вот. Как обращаться к значению счетчика.
Ну, тут, эта строчка нам уже знакомая, мы объявили новый счетчик, который называется name, и дали ему значение 22. Вот. Ничего удивительного.
Это же понятно. А далее мы по-разному обращаемся к этому счетчику. Во-первых, можно к нему обратиться командой backslash the, а потом название счетчика.
Буквально в одно слово. Для меня это было тоже противоестественно, но вот оно почему-то работает.
В частности, когда я писал команду thepage, я буквально обращался к значению счетчика page.
То есть даже ваше кастомное имя, каким бы оно ни было, вот the и далее ваше кастомное имя, оно сработает.
Это для меня довольно странно, но вот оно вот так.
Можно выдавать значение счетчика форматированным.
Например, если мы хотим, чтобы это было просто арабское число.
Ну, вообще-то оно по умолчанию арабское число, но вот можно приписать еще Arabic.
Ну, наверное, такая команда есть скорее декоситетность, чтобы было понятно, почему другие тоже работают.
Что вот есть команда Roman, которая принимает на вход значение, название счетчика, она выдает значение счетчика в качестве римского числа.
Причем, как видим, страшными буквами. Если хотим заглавными буквами, то Roman заглавные буквы.
Главные буквы, ее команда equivalent.
Но понятно, что римская система числения, она там поддерживает не все числа, а типа только тысяч за десяти, кажется, да, что-то такое.
Да, разумеется, она не умеет в знаке, но и там еще есть некая граница сверху, по-моему, десять тысяч, но может быть поменьше.
Вот если число будет не из этого диапазона, оно не отработает просто, оно скажет ошибку, а то что вот это, я не умею римское число вставать по такому числу.
А если будет нормальное число, как в нашем случае 22, его оно отрицует.
Ну и можно еще в качестве, ну, буквки можно, в общем, рисовать.
Команда alph, это будет такая по счету буква латинского алфавита, какое у нас значение счетчика?
На данном случае значение счетчика 22, 22-я буква алфавита, это буква vi.
Можно ли кириллические буквы так вызывать? По-моему, да, но я не помню как.
Для этого надо будет подключить этот russian или babel?
Ну, во-первых, да, нам потребуется вот это, как всегда, наше мантра для подключения русского языка,
который и babel делает, и там font-eng, input-eng и все такое.
И, наверное, есть какая-то команда, которая умеет кириллические символы вырисовывать.
Я забыл, или даже не так, я не знал, как она делается.
Если вам интересно, я могу погуглить, для червей рассказать.
Ну, вдруг вам захочется нумеровать все формулы в вашем тексте в русским буквуме abvgd.
Ну, по какой-то причине вам так захотелось.
Это можно делать, я уверен, что это можно делать, но сейчас я не помню как.
Но, по крайней мере, я помню, как делается это для числа римских и для просто буквок латинских.
Вот, понятно ли все вот здесь?
Да.
Ну, хорошо.
Да, то, что я уже упоминал, есть многие разные встроенные счетчики.
Есть счетчики page и там номеров других объектов, типа номер текущей таблицы, текущей фигуры.
Мы про это еще не говорили, но мы про это поговорим.
Да, номер текущего футноута, вот это мы только что видели,
то, что у футноутов есть своя нумерация, и вот она регулируется счетчиком футноут.
Вот.
Есть счетчики, номирующие там разделы, типа там section, subsection и так далее.
Их тоже можно модифицировать.
Да, есть счетчик equation, который, естественно, номер текущего уравнения выдает.
А про это сейчас отдельно будет разговор.
Счетчики вида Yanam, ну, типа римская 1, Yanam, римская 2, Yanam, римская 3, Yanam, римская 4.
Это, ну, не вполне счетчики, это переменные, в которых хранится...
Сейчас, нет, даже нет, это действительно счетчики.
Это счетчики, указывающие номер текущего объекта номированного списка
на таком-то уровне вложенности.
И вот это число регулирует именно уровень вложенности.
Давайте, это, наверное, сейчас не было понятно, я лучше пример проведу.
Если так и subsection задается?
В частности, да.
Кстати, да, давайте сначала, пока мы далеко не ушли,
покажу, как регулировать номерацию секций.
Вот, допустим, у меня есть section, первый раздел.
Есть section, дальше внезапно пятый раздел.
Ну, по какой-то причине.
По умолчанию, если я просто попытаюсь это комплировать,
он мне сделает первый раздел под номером 1, а пятый под номером 2.
Ясно, что не то, чего я хочу, да?
Я хочу, чтобы это было цифра 5.
Но теперь мы уже знаем, что вообще-то номер секции –
это счетчик, его можно задавать руками, да?
Но я перед этим и напишу.
Set counter section.
Ну, давай пока попробуем 5, не спойлери.
Казалось бы, должно сработать, но почему-то получается число 6.
Почему так?
Ну, потому что команда section, она сама инкриментирует section на 1.
Ну, потому что когда мы вообще к этому не обращаемся,
а просто пишем секции подряд, нам хочется, чтобы их номера тоже росли, правда?
1, 2, 3, чтобы они шли. Они все время одно и то же значение.
Поэтому команда section при вызове, она счетчик section инкриментирует на 1.
И, ну, поскольку нам хочется, чтобы после этого получалось число 5,
значит, мы делаем... Сначала мы задаем значение 4,
чтобы оно после еще одного инкримента стало уже 5.
Вот.
Если я из пятерки хочу получить 7, то я не один или два добавляю, а я пишу 6.
Да. Ну, либо добавляешь еще один, ну, руками, типа step counter применяешь,
а потом уже вызываешь и снова section, и получается уже седьмая секция.
Вот. Такая идея.
Теперь то, что я обещал в пронумерованные списки.
Помните, да, команда enumerate?
Окружение enumerate.
Вот.
Первый пункт.
Третий пункт.
Ну, опять та же история.
Нам хотелось бы, чтобы то, что называется третьим пунктом,
имело перед собой число 3. Да?
Ну, наверное, это можно как-то регулировать с помощью счетчиков.
Мы думаем, ага, мы только что видели счетчик enum 1.
Да, мы сейчас находимся на первом уровне вложенности.
Ну, то есть, если были вложены какие-то нумерованные списки,
то есть, вот скажем, вместо item еще один enumerate,
а внутри него еще enumerate,
это каждый раз впуск на еще один уровень ниже,
там, на второй, на третий и так далее.
Я в прошлый раз, ну, вы, наверное, в записи видели,
показывал, что на разных уровнях вложенности
нумерация разного формата.
Скажем, на первом уровне арабские числа,
на втором уровне, по-моему, латинские буквы,
на третьем, типа, римские цифры, типа, ну, просто по-разному.
Это все регулируется, мы про это еще тоже поговорим как.
Но вот мы находимся на первом уровне вложенности
и нам хочется, чтобы на первом уровне,
нам прямо сейчас было значение счетчика не 2, а 3.
Ну, мы говорим.
Давайте делаем setCounter enum 1.
Ну, какое значение?
Ну, значение 2, да?
Почему?
Ну, потому что, опять, при вызове еще одного item'а
он экрементируется еще на 1, получится как раз 3.
Ура, получилось.
Соответственно, если бы мы были на уровне вложенности 2,
давайте я спущусь на уровень вложенности 2.
Ну, то есть, просто сделаю...
Вот, у меня на месте первого item'а
вложенный нумерованный список.
И захочу тут тоже сделать, типа, пункт...
пункт 1, а потом пункт 4.
4.
Как мне сделать консистентную нумерацию,
чтобы тут был пункт...
Да, во-первых, как видим, формат тут уже другой,
латинские буквы.
Ну, вот как мне сделать, чтобы этот пункт 4
пошел под буквкой D, а не под буквкой B?
Enum 2 сделать?
Да, задать значение счетчика enum 2.
И там ему 3 написать?
Ну, получается, что так, потому что...
Ой, enum 2.
Значение 3, поскольку вызов команды item
его еще раз инкремитирует.
Получится как раз 4.
Да, другой, скорее, типа, мемный выход.
Можно было бы сделать...
Ну, типа, озеркалить значение тега
и бэпер шлоговда как раз.
Мы про это поговорим, как это делается?
Что?
Ну, типа, завернуть значение вот этой штуки
в mirrorbox, штучка, которая...
Ну, может быть, не прямо одинаково,
но явно очень похоже,
и никто бы не заметил разницу, скорее всего.
Да, посмотрим.
Ну, то есть, в принципе,
мне кажется, если я разверну букву D,
никто ничего не заметит.
Никакой разницы.
Ну, практически не заметит.
Можно и две подряды объяснить.
Ну, ладно, это не так важно.
Мы это в следующий раз обсудим,
когда будем, собственно,
всякие символы вращать, масштабировать,
вот такими вещами заниматься.
Пока, я думаю, хватит у нас такого.
То есть можно обращаться, допустим,
к секции, к секции ГАБД сэкшн?
Да, все так.
Более того, если я тут напишу
уберу этот весь текст,
сделаю сэкшн,
какой-то текст и сделаю the section,
то он мне отрисует номер текущей секции единичку.
Кстати, интересно,
я сейчас сам задумался,
а если секции не будет вообще?
Он вообще,
этот человек пренационизирует нулем
или вообще не пренационизирует?
Давайте посмотрим.
Нет, все-таки нулем.
По умолчанию он нулевой,
но просто каждый вызов команда сэкшн
его будет экремитировать на один.
Вот.
Ну либо мы сами его как-то зададим по-своему,
и он уже будет такое значение иметь.
Ну да, к ним можно обращаться.
И повторюсь,
даже если сделали кастомный счетчик,
который называется abvgd,
ну там abcd,
мы могли бы обратиться к нему,
командой с помощью the abcd.
Вот, это бы тоже сработало.
То есть он в части обращается к той,
которая выше до него находилась?
Сейчас что ты имеешь?
Если у меня есть 1, 2, 3, все там,
секция 3 и все.
А нет, смотри, он обращается не к секции,
он обращается к значению,
ну к числовому значению счетчика.
Счетчик на данный момент
после третьей секции уже имеет значение 3.
Вот.
Кстати, да, это хороший вопрос,
я думаю, что стоит прелюстировать.
Если я даже сделаю,
так, первый,
сделаю короче несколько секций,
второй,
и из каждой секции попытаюсь обратиться к счетчику,
the section,
ну, собственно,
к счетчику,
которому хранится номер секции текущей,
то я утверждаю,
что везде будет разный результат.
Его значение будет,
ну, короче, значение счетчика подсчитывается
на момент данной позиции в тексте.
Вот.
Если мы делаем какую-то манипуляцию
типа set counter section,
думаю, значение 500,
то на тексте выше...
Ой.
На тексте выше это никак не отразится,
потому что мы задали значение уже
после того, как мы вызвали команду the section.
То есть он сначала отрисует счетчика как положено,
а уже потом его модифицирует.
Вот.
То есть тех комплиируется строго сверху вниз.
Хотя, наверное,
это верно вообще для любого языка, да?
Так что это не очень полезное утверждение,
но вот...
Нет, я имею в виду для языка программирования.
Хотя, мне кажется, нет,
потому что HTML, наверное, предпочитывает всю страницу
и отрисовывает ее целиком
и все значения выдают уже конечные.
Вот.
Ну, короче, для тех это точно верно,
что оно работает именно сверху вниз.
Вот.
Я обещал показать,
как задавать нумерацию с помощью других символов.
То есть вот у нас по умолчанию
нумерованные списки нумируются числами
на первом уровне вложенности.
Мы хотим, чтобы у нас был нумерованный список
первого уровня,
скажем, нумерованный буковками.
Для этого в качестве необязательного аргумента
указывается аргумент label,
и значение которого...
Ну, тинкс вот такой.
Пишем ту команду,
которую мы хотим применить к счетчику.
Помните команду alpho, да?
Которая...
Если мы применяем ее к счетчику в качестве аргумента,
мы получаем значение счетчика,
записанное как букву алфавита
со социального номера, да?
Вот он...
Мы указываем, какую команду применить к счетчику,
ну, то есть к звездочке.
Ну, такой синдекс есть.
Сейчас не смотря, почему это именно так пишется,
но вот идея такая,
что мы указываем,
какое преобразование применить
к нашему счетчику номера текущего итама.
Давайте я скобирую этот код.
Но поскольку мы уже поигрались с set counters,
я не буду повторять эффект set counters,
просто удалю эту строку.
Вот посмотрим, что будет,
если я укажу не просто enumerate,
а enumerate,
у которого есть такой вот аргумент.
А, он не скомпилируется.
Прикольно.
Как же так?
Слушайте, я в замешательстве.
А вы не надо заканчивать так же как-то?
Да вроде как все должно работать.
А, потому что для того,
чтобы это работало,
нужно получить пакет enumerate itemize.
Теперь все заработает.
Ура.
Теперь наши аитмы номируются
алтинскими буквами.
Если мы хотели номераться
иринскими зифрами...
Что за звездочка?
В данном сетексе, видимо,
звездочка означает просто
дальше подставить enum 1.
Какой будет номерация?
Не просто enum 1,
а alph enum 1,
то есть примененное к нему
значение преобразования alph,
которое делает из него
алтинскую букву.
Соответственно,
если бы я тут написал ром,
он вместо этого,
то у меня были бы римские числа.
Вот.
Ну, остальное мы тут уже видели.
Мы можем сделать setCounter,
и тогда он задаст нам значение 5,
и следующий item сделает нам
значение 6,
инкритирует на 1,
и получится поэтому буква f,
шестая буква алтинского алфавита.
Тут уже должно все понятно.
Окей, да, двигаемся дальше.
Вот.
Немножко из другой оперы,
но тоже похоже.
Есть счетчик enum 1,
enum 2,
а есть команда label item 1,
label item 2 и так далее.
Это значки для маркированных списков
на разных уровнях вложенности.
Но поскольку там нет номерации,
это уже не счетчики,
это один тоже каждый раз значок,
просто рисуется перед каждым item'ом.
Его тоже можно переобределять.
Вот по умолчанию,
если мы сделаем просто itemize,
потому что тут тоже itemize, конечно,
то по умолчанию они маркируются
вот такими буллетами,
такими закрашенными кружочками.
Если мы хотим,
чтобы это было не так,
мы скажем renew command,
просто переобределим команду
label item 1.
Сейчас я не ошибся,
она так пишется.
Да, label item 1.
И вот каким вы хотите видеть маркеры
перед элементами?
Что тут написать?
Доллар.
Давайте доллар.
Как мы помним,
доллар спецсимвол,
поэтому его экранируем,
чтобы он записался.
Теперь у нас будет маркирован список
маркироваться долларами.
И это будет только
для уровня вложенности 1.
Для вложенного списка
он этого не почувствует.
Это очевидно из того,
что мы задаем только
для первого уровня вложенности,
но в всякий случай.
Тут у него будет своя маркировка.
По умолчанию маркировка
на втором уровне
делается тиражками.
Ну вот, допустим,
мы хотим ее поменять
на какую-то.
Мы переобределяем
quanta label item 2.
Давайте, на что переобредить ее?
Я вот не умею вырисовывать
начок евро.
Может, здесь встроенный?
Давайте посмотрим.
Евро.
Нет.
Не, видимо, нету.
Он предлагает смириться
и сделать просто
какой-нибудь симпатичный значок,
типа крестик times,
математический times.
Ну почему нет?
Пусть будет int.
Что важно,
я его заворачиваю в доллары,
уже не в экранированные,
в обычные математические,
потому что это символ
из математики,
и он иначе просто
не скомпедируется.
Забавно звучит,
обычный математический.
Ну да.
И теперь у нас маркировка
списка второго уровня
делается интегралами.
Зачем-то?
Ну в общем-то,
такая опция есть,
это все можно регулировать
и настраивать под себя.
Я часто делаю
номерованные списки,
маркированные все
этими треугольничками.
Переопределяю
документы своих вот так.
Мне это как-то больше нравится.
Вот.
А нельзя вначале пакет...
А, ну это...
То есть а это работает
для всех вызовов
пакета NM-item?
Мне кажется,
тут NM-item
вообще ни при чем.
Если я его уберу,
ничего не изменится.
Да.
Это вообще встроенные
команды из латеха.
Или ты имеешь в виду,
если мы хотим,
чтобы одни маркированные списки
определялись вот таким
вот образом,
а другие рисовались бы
другими символами.
Типа мы хотим
посреди документов
переопределить.
Среди, как раз таки,
я понял.
Не, вот мне кажется,
это не сработает.
Мне кажется,
что RenewCommand
это команда,
которая должна быть
именно в преамбуле,
а не в документе.
Я подумаю,
она скажет ошибку
компиляции.
А, не смотри,
будет им иметь эффект
только после того,
как мы это написали.
Ну, действительно так.
Опять компиляция
сверху вниз.
Он шел сверху вниз,
видит, ага,
там маркированный список.
Его отрисовал.
Дальше, ага,
переопределили значки.
Значит, дальше
будут использовать
другие значки.
Второй список,
его уже отрисовал
другими значками.
Вот.
Тоже все,
как кажется,
очень прозрачно.
Я, честно говоря,
думал, что
RenewCommand
и пишут вне
окружения документов,
а только в преамбуле.
Оказывается,
это не так.
Да.
И кажется,
что
про счетчики
тоже на сегодня все.
Совсем чуть-чуть.
Я так понимаю,
все уже устали
и время уже позднее.
Но вот просто упомянул
про создание окружений.
В следующий раз,
видимо,
я это повторю.
Помните,
что такое окружение,
да?
Мы с ними сегодня
работаем весь день.
Это штука,
которая begin название,
end название.
Это все окружение.
Можешь создавать их свои
прямо с нуля.
Команда вот такая.
New environment
ну типа новая среда.
Так же,
как с командами.
New environment
далее название среды,
которые мы хотим.
Ну,
вообще любой набор символов.
Далее,
тот код,
который будет
буквально подставлен
перед содержимым среды
при компиляции
и после компиляции.
Сейчас не очень понятно.
Понятнее будет на примере.
Допустим,
мы хотим
окружение,
которое
все внутри себя
делает по центру
еще и жирным.
Вот сразу две задачи
хотим решать.
Делаем такое окружение,
новую среду,
которая будет называется
center bolt.
Ну типа и по центру,
и жирным.
Далее,
второй аргумент.
Мы хотим,
чтобы весь текст,
который внутри нее
завернулся в какой-то код
до и после.
Мы хотим,
чтобы кодом до
было begin center
и начало модификатора
жирного шрифта.
Ну,
то есть,
оно буквально
подставится
перед текстом,
который будет
в это окружение завернут.
Вот.
Но поскольку мы
открыли окружение,
begin center,
мы хотим открыть.
Поэтому,
следующим аргументом,
тем кодом,
который будет поставлен
после всего текста,
будет end center.
Он подставится
уже после этого текста,
вот сюда.
Вот.
Ну, естественно,
оно вот так вот сработает.
Это тоже
можно не перенабирать,
это все будет в слайдах.
Ну, давайте так,
понятна ли общая идея?
Сейчас я могу повторить?
Смотри.
Что делает окружение?
Оно берет то,
пишет
перед ним
какой-то код,
который заранее задан,
и после него
какой-то код,
который заранее задан.
Вот здесь как раз.
Качество этого
и этого аргументов.
То есть,
мы хотим,
чтобы в начале
перед нашим текстом
мы открыли
окружение center,
ну, уже заранее определенное,
и открыли модификатор
bf-series,
который делает все жирным.
Ну, поскольку мы
открыли окружение center,
надо его закрыть.
Поэтому,
по окончании
мы хотим,
чтобы было еще
Это модификатор.
Он просто работает
до конца блока.
Его не нужно закрывать.
Ну, вот.
Это тоже,
повторюсь,
такая, скорее экзотика.
Вот это все end-center
это аргумент,
который тоже
завернут с кодки целиком.
То есть,
команда new-in-ware
принимает в ход три аргумента.
Название среды,
код, который подставить до,
и код, который подставить после.
Если вы напишите
в каком-то другом месте
begin-center
и не закроете
в этом же блоке end-center,
он просто не скомпелируется.
Но,
вот,
и на случай,
когда вы делаете среду,
все сработает,
потому что код,
который внутри,
он не компелирует,
будучи поданным на вход.
Он компелирует его
только,
когда он его подставляет
уже в конкретное окружение
и до, и после,
и вот это уже все вместе
он компелирует
и получается хорошо.
Ну,
надеюсь,
хотя бы
идейно понятно,
что бы произошло.
Ну,
это последнее на сегодня.
Тут тоже дофига всего.
Просто упоминаю,
что это существует.
Помните,
мы делали разные теоремы
и у них были разные стили.
Там Serum Style
можно было задавать.
Вот Serum Style
можно делать вообще свои.
Эта есть команда
New Serum Style.
Ну,
есть какие-то аргументы.
Можно сказать
название стиля,
ну и дальше
параметры.
Там отступы до после,
модификаторы шрифта,
видимо,
даже какие-то цвета,
шрифт заголовка отдельно.
Это я просто
упоминаю,
что это существует.
Да,
это все
аргументы одной команды.
Команда New Serum Style.
Такая вот команда,
у которой раз в три,
четыре штук,
восемь аргументов,
девять.
Ты их просто пустыми делаешь.
То есть
просто пустые фигурные скобки
и ничего не пишут там.
Вот.
Но
вот мнение
о том,
как ты это мог своему стилю.
А потом ты просто...
Помните,
был модификатор
помните,
был модификатор
Serum Style,
который
все, что далее
давайте plain.
Вот
что он говорит?
Все теоремы,
которые будут объявлены далее,
имеют стиль plain.
А вот ты сделал свой стиль,
который называется
my style.
Значит,
ты его так как вызываешь?
Пишешь my style.
Все.
Все теоремы,
которые будут далее,
будут иместить
my style,
который ты объявил.
Я даже не буду компетировать.
Типа,
мне вот такое не пригодалось
делать руками ни разу.
Вот
не знаю.
Мне кажется,
что стили,
которые есть в техи по умолчанию,
там plain, remark
и что-то еще,
их хватает головой.
Ну,
если вам захочется
как-то там выделиться из толпы
и сделать
свою уникальную книжечку,
то вот
вот эта штука
вам может помочь.
И
я подозреваю,
что это все,
что я хотел вам сегодня рассказать.
И дальше должен быть слайд,
который говорит все.
Вот.
Есть ли вопросы какие-то,
да.
Ну, контекстов,
если есть,
там в чате напишите
или там меня лично.
В общем,
думаю,
что на сегодня стоит закончить.
Спасибо за внимание.
Да.
