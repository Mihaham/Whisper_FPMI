У нас сегодня предпоследняя лекция в курсе. Разберем с вами в NoSQL парадигму, назовем ее так,
и посмотрим сегодня на Neo4j, а в следующей лекции на еще, наверное, три варианта NoSQL
базы данных, пастелирующих различные концепции. Ну что, давайте приступим. Итак, что такое NoSQL?
Мы с вами, в принципе, закончили все темы, связанные с SQL, и, как вы знаете, SQL это у нас
на самом деле не модель, а язык. И язык, который работает с представлением данных в виде релационной
модели. NoSQL это такой mismatch, наверное, с точки зрения терминологии, потому что NoSQL обозначает
у нас как раз ни язык, ни отсутствие SQL языка, который может быть в базах данных, реализующих
релизационную модель. Ну как бы технически у нас релизационная модель не зависит от выбранного языка
или используемого языка запросов. NoSQL говорит нам о том, что существуют целые другие парадигмы
проектирования баз данных, представления данных и, соответственно, несколько иной способ
манипулирования этими данными, ну просто потому что у нас SQL, он заточен именно на табличное
представление, на представлении в виде отношений. NoSQL говорит о том, что язык может быть совершенно
другой, именно потому что объекты, над которыми совершаются операции, не похожи на отношение
в релизационной модели. В принципе, тоже можно такую несколько любопытную, ироничную,
что может быть в исторической и исторической перспективе. Вещь отметить, что по большому
счёту у нас SQL это база данных, ну или релизионные как нас таки. Это вот под период на протяжении
большого периода развития систем управления данными, которые начали появляться, как мы помним
из прошлых, из первых лекций, с шестидесятых ещё годов двадцатого века. И, конечно, первые
модели, первые системы управления данными, они не были никакими релизионными, были, как вы
помните, иерархическими сетевыми в первом приближении, ну не говоря уже до права. Системы,
файловые системы первые файлы, первые варианты файловых систем. И только в 1969 году, тере семидесятом
Edgar Cot опубликовал свою статью сначала в НУРИ корпоративном, её изложил, представил, потом
опубликовал уже, так сказать, в широкой печати. И с тех пор началось развитие классической
релизионной модели и релизионных систем управления баз данными. Но у SQL базы данных у нас
появляются, то есть они были до 1969 года, можно говорить смело, и они у нас вновь, ну и продолжили
даже на своё существование и после 69-80-го. И они у нас вновь появляются как мейнстримовое
направление, где-то в районе начала 21-го века, конце 90-х годов, 20-го, начале 21-го века.
Ну вот тоже маленькая историческая здесь напоминалка на слайде, а тоже таймлайн небольшой из того,
что мы вот сказали. Сам термин, причём, сам термин, его атрибутируют некоему Карлу Стротце и по датировке
о возникновении указывать на 98-м год. Но SQL так называлась как раз-таки релизионная СОБД,
разрабатываемая Карлом Стротце, и которая не использовала как раз-таки язык SQL. И вместе с тем,
опять же, как мы сказали ранее, вот этот мисмэтч в терминологии по поводу NoSQL,
некоторые говорят о том, что последовательнее и логичнее было бы называть базы данных,
не использующие релизионную парадигму NoRel, NonRelational, а не NoSQL. Но, тем не менее,
термины прижились, термин прижился, и теперь всё, что не является релизионным, называется,
по общему правилу, NoSQL. А в чём причина появления NoSQL-парадигмы? Ну, на самом деле,
здесь есть определённые параллели с тем, почему появлялись хранилища данных. Единственно,
если хранилища данных всё-таки появлялись как способ агрегации больших массивов информации
в крупных компаниях, и, конечно, они не могли себе позволить легко и просто отказаться от
такой наезженной, накатной дорожки строить SQL-подобные, релизионно подобные базы и хранилища.
Как вы помните, Уильям Эйнман говорил о том, что DWH Data Warehouse должен быть,
просто погрубляя, должен быть нормализованной до третьей формы базой данных релизионной.
У Ральфа Кимпбала немножко более гибкий подход. Но, тем не менее, всё это базируется на таблицах,
на отношениях и на каких-то базовых аспектах релизионной модели. SQL от всего этого отказывается,
но тоже здесь в качестве причин возникновения это и Big Data большие объёмы данных,
требующие легкой масштабируемости систем и частых операций чтения записи и наличия
возникновения распространения повсеместно к концу 90-х уже годов интернета и веб-ресурсов
в разработке, развитие новых парадигм разработки программного обеспечения,
в частности Agile, потому что спроектировать хорошую, корректную с точки зрения релизионной модели
схему базы данных, штука довольно непростая, прямо скажем. Это не просто какой-то небольшой
учебный проектик на 3, 5, 7 таблиц, там могут быть десятки и сотни таблиц. Технически это
довольно сложно, если особенно исповедовать топ-даун подход сверху вниз. Снизу вверх это
ещё и проблемы налагают на то, как вы будете в последствии развивать вашу релизионную базу
данных, потому что в принципе релизионная модель не очень гибкая с точки зрения её доработки
в последующем. То есть вы как сформировали схему, концептуальную, логическую, физическую модель
сформулировали, а если вы хотите как-то быстро поменять сущности, ну быстро у вас не получится,
вам придется заниматься копированием данных, переформатированием этих данных возможно,
то есть какие-то манипуляции, строить провежуточные хранилища и так далее.
А парадигме Agile и в принципе с учётом увеличения скорости бизнес-процессов,
скорости разработки, у нас нет времени на то, чтобы сидеть и разрабатывать нашу гениальнейшую
базу данных на все случаи жизни нашего стартапа с прицелом на то, что он станет многомиллиардной,
прошу прощения, корпорацией. Поэтому у нас должна быть какая-то иная технология
разработки нашего хранилища информации,
кое собственные были разработаны и представлены в конце девяностых, в начале нулевых годов первого
варианта. Принцип работы религационной базы данных, вы помните, это ACID-концепция, это Misty
Consistency Isolation Durability и первая поддержка всех этих принципов, реализованных в 1973 году в IBM,
IMS-системе, но есть так называемая теорема CAP, CAP, теорема Брюер, мы о ней с вами уже говорили в
рамках разговора про ACID-концепцию, но повторим немножко, то есть если мы попытаемся подняться
на одну ступень выше, абстрагируясь от вот этих вот принципов религационной СОБД, это ACID
свойств, то у нас получится, что да, что почему это теорема, на самом деле это тоже
такой вводящий в заблуждение термин, это не теорема, это вот если вы откроете прям википедию,
там с черным по белому написано, это евристическое утверждение, ну собственно так оно и есть,
википедия это конечно в данном случае не такое нарушение аргументации, за отсылка к авторитету,
но как бы по сути своей, это конечно никакая не теорема, никто ее не доказывал, никаких там
аксиом и следствия из нее, ну таких вот в математическом смысле нет, но вот логически
рассуждая, можно говорить, что есть три основных свойства, характеризующих любую базу данных или
СОБД, вне зависимости от того, религационная она или нет, это consistency, availability и partition
tolerance, то есть согласованность данных и доступности, устойчиваясь к разделению и
максимизировать мы можем не более двух из них, можно это использовать вот этот вот такой
категорийный подход к тому, чтобы классифицировать базы данных по указанным свойствам, и мы когда
пытаемся максимизировать два из возможных свойств, то у нас здесь получается либо религиозные
какие-то модели, например, когда мы говорим, что мы максимизируем согласованность и доступность,
либо какие-то варианты NoSQL баз данных, в зависимости от того, какие свойства мы тоже
пытаемся выкручить на максимум, на слайде, соответственно, показаны варианты такой вот,
тоже не очень формальной, но разбивки по группам, потому что по большому счету,
а у нас мы когда максимизируем два из трех свойств, это не значит, что у нас третье
отваливается, то есть у нас все равно наши SQL базы данных, они все равно устойчивы к разделению,
тем не менее, там просто будут проблемы с точки зрения параллельной обработки запросов,
но тем не менее, кому-то придется может быть ждать, чтобы записать или прочитать,
тем не менее, разделить ресурсы мы тоже можем, разделить процессы и ресурсы имеется в виду
хранимые данные. Недостаток к максимизации параметров, здесь как бы понятно, если мы
максимизируем доступность и согласованность, то у нас возникают проблемы, связанные с тем,
что сеть и проблемы с сетью, например, могут застопорить систему, остановить работу система,
воспрепятствовать ей серьезно. Если мы максимизируем согласованность и устойчивость к разделению,
то у нас есть вероятность, что некоторые данные в моменте могут стать недоступными,
или если мы максимизируем устойчивость к разделению и доступность, возможно,
что у нас данные станут не согласованными. Если мы говорим о максимизации, рассматриваем
сторону одной из сторон этого треугольника, и противолежащая вершина у нас уходит в минус,
она, можно сказать, определяет нашу проблему. Мы максимизируем PEC, у нас A-availability
становится вариантом, становится проблемой доступности и так далее.
Опять же, рассуждая в категориях CAP теоремы, теоремы Брюера, мы говорим, что с одной стороны
ее вариантом максимизации доступности и согласованности является реализованная модель,
и тогда у нас по сути дела следствием является ACID-концепция. Но если мы
подумаем еще, какие варианты мы сможем максимизировать, мы получим бейс-модель.
Ей в некотором смысле руководствуется при проектировании NoSQL с УБД, но именно с точки
зрения противопоставления ACID. То есть это концепция конкурирующая, и что такое бейс?
Basically Available, то есть базовая доступность, мы гарантируем ответ на каждый запрос к данным,
soft state – неустойчивое состояние, то есть данные могут меняться в отсутствие операции ввода,
и eventual consistency – согласованность в конечном счете. Что это все значит более подробно?
А почему soft state? Наверное, с этим разберемся сначала. Почему данные могут меняться в
отсутствие операции ввода новой информации? Потому что у нас есть согласованность в конечном
счете. То есть это значит, что у нас есть распределенная система, ее узлы в моменте,
когда, например, в какую-то запись вносится изменение на каком-то узле, в моменте
общее состояние всей этой системы может быть не согласованным, и в моменте у нас меняется только
запись, только в конкретном узле, и мы этим самым гарантируем всегда, что у нас Basically Available
свойство будет работать без проблем. Но поскольку у нас данные изменились только в одном узле,
а нам нужно распространить на всю нашу сеть, которую собой представляет наша база данных,
то под капотом всей нашей subd начинают происходить какие-то внутренние процессы,
которые эти изменения от узла к узлу передают, и в конечном итоге на каком-то шаге у нас все узлы
придут в состояние согласованности с теми первичными изменениями, которые произошли в узле номер 0.
Вот так это на пальцах, на словах работает. Опять же, с точки зрения категории общих.
Давайте перейдем посмотрим на какие-то конкретные варианты баз данных на ОСКЛ. Во-первых,
существует множество категорий, то есть нельзя говорить о какой-то классификации.
Классификация подразумевает основание деления, по которому мы подразделяем наш общий класс на
члены деления. Но здесь мы не можем, наверное, все классы, исчерпывающие, описать. Какие-то
появляются вновь какие-то, являются у нас мутанты, реализующие в себе свойства не одной конкретной
модели, а нескольких. Но принято делить или можно разделить новый SQL базы данных на те варианты,
которые на слайде приведены. K-value stores или storages – это хранилища ключа значения,
то есть максимально простая штука. По сути дела, грубо говоря, это хранилища, хранение данных на
хэштаблицах. Основная фишка, основное свойство, что у нас есть ключ, по которому мы всегда легко
найдем значение. То есть, грубо говоря, это то свойство, которое гарантирует нам хэштаблицы. Там
не обязательно, конечно, что все одна большая хэштаблица, какие-то более интересные и сложные
алгоритмы реализованы, но базово можно рассматривать их как большие, большие сложные хэштаблицы.
Column-oriented базы данных, то есть колончатые базы данных, в них еще выделяют, ну или как подвид,
или как вариант, white-column базы данных, то есть широко колончатые, если прямо переводить на
русский. Но это такие более частные, наверное, вопросы. Мы об этом сейчас поговорим через слайд
буквально. Смысл в том, что здесь, в отличие от реализационных баз данных, физическое хранение
данных организовано иначе. То есть, в реализационных базах данных у нас физически хранится, на каждой
странице в файле хранится у нас строка. Наш вот этот tuple, nefcartage, строка таблицы. Колончатых,
соответственно, друг с другом хранятся значения колонки. Значение внутри колонки имеется в виду,
а не значение def из колонки. Значения там, конечно, дискретные по каждой ячейке. То есть,
друг с другом хранятся значения внутри одной колонки. Ну, сами понимаете, в чем здесь плюс.
Плюс в том, что у нас однотипные значения хранятся вместе. Проще, дисковые операции
становятся заметно проще в том смысле, что у нас данные одного размера всегда хранятся рядом
друг с другом. Возможно, может быть, проще в зависимости от типа данных. Может быть,
проще их как-то заархивировать или компактнее хранить. И операции агрегации проводить на
такого типа данных проще, потому что агрегация, как вы помните из всего нашего предыдущего курса,
по сути, дело своей работает на колонках, а не на строках. Наши агрегатные функции,
даже какие-то запросы Order By, запросы партиции, мы делаем их по колонкам как таковым, а не по
строкам. Document Store с документно-ориентированной базой данных, документное хранилище. Смысл не в том,
что мы храним файл в формате .docx. Вордовский файл или Excel файл или что-то в этом роде. Смысл в
том, что у нас сущность несколько иная в этих базах данных. Называется она document. Там меняется
в связи с этим структура хранения и сильно отличаются операции. Но если проводить какую-то
аналогию, то, наверное, можно говорить, ну, очень так приближенно, что это похоже на JSON формат,
скажем так. Графовые базы данных. Ну, здесь все понятно из названия, то есть бити графов у нас
представлены на модели. И как раз сегодня мы о Neo4j с вами поговорим, чтобы пример был грубый и
зримый, что называется. RDF stores данные представлены в стройках. Это уже что-то похожее больше на
хранилище знаний, субъект, парадекат объект. Хотя хранилище знаний немножко иной подход. Объект,
свойства значения, но тем не менее. Native XML, то есть база данных, ориентированная на работу с
XML форматом строк или вот просто XML форматом значений. Не обязательно, что это именно строки,
как строки будут представлены внутри. Хранилище контента целиком и search engines и поисковые
движки. Например, Elastic Search. Content stores это такие условные штуки. Это что-то уже ближе к болотам
данных и к озерам. Упоминаем мы здесь о них. По утилитарной на самом деле причине. Сейчас мы чуть
ниже опустимся. По презентации вы увидите ссылку на сайт, сайт-агрегатор информации о различных
типах баз данных. Категории этих No-Scale баз приведены в соответствии с тем, как на
этом агрегаторе строится категоризация для удобства какого-то отталкивания от какого-то
какого-то основания. Content stores предлагается выделять как специфический тип хранилища,
но по большому счету. Он скорее больше похож на key value, но может быть. Просто у нас здесь нет
ограничения по типу данных в атрибуте value.
Мы там можем хранить условно говоря видео файл данной презентации, pdf, pptx, расшифровку
речи лектора и так далее. Search engines тоже здесь вопрос больше к тому, что мы считаем No-SQL,
потому что по большому счету search engine не обязательно база данных. Там конечно используется
структура хранения, пресловутые инвертированные индексы, как собственно говоря правда и в
самой Postgres. В Postgres это способ индексации, вариант индекса, а в поисковых движках инвертированные
индексы. Это все-таки скорее основной способ доступа, основной способ контекстного поиска в
базовой модели булева поиска. Базовая модель вот такой. Informational retrieval. Поиск информации по
текстовым данным. Окей, мы с вами посмотрим на четыре моделя. Сегодня, повторюсь, графовая база
данных NeoForge. На следующей лекции еще три оставшиеся. Сейчас просто общая обзорная
характеристика каждого из перечисленных видов. Сейчас немножко углубимся с вами в
column-oriented white-column DB, чтобы просто чуть-чуть лучше понимать, чем разница, потому что далее
будем говорить с вами сегодня о white-column. И колончатые базы данных оптимизированы,
как было сказано ранее, для операции агрегации аналитических запросов. По столбцам хранения
данных тоже производится, позволяет удобную агрегацию изжать и осуществлять. Для ширококолончатых
баз данных, в принципе, все тоже самое работает, но у нас более гибкая система с точки зрения того,
что мы можем хранить данные в столбцах, но сами эти столбцы, они реализуют, в каждой строке,
то есть все равно мы можем и строку считать. Просто, конечно, для колончатых баз данных это
неэффективная операция, в отличие от классических реализованных. Но в каждой строке может быть разное
число колонок, причем физически, что тоже позволяет, за счет именно физического не хранения лишних
данных, пустых данных в той или иной строке, мы более оптимально и лучше с ними работаем,
с данными хранимых и производим запросы. Ну и вот тоже здесь в классических колончатых
структурах фиксировано и однородно, каждая запись или строка содержит данные для каждого
столбца в ширококолончатых, каждая строка может иметь различный набор столбцов и так далее.
А семейство столбцов в ширококолончатых базах тоже имеет место быть, то есть могут быть связанные
столбцы, которые хранятся физически опять же вместе для более удобных операций чтения записи.
Ну хорошо, разобрались с вами с вот таким небольшим различием колончатых и ширококолончатых.
В принципе, это тоже такое условное несколько деление, потому что по большому счету мы можем
настроить одну базу данных для работы так или иначе, одну колончатую или ширококолончатую,
по сути дела это как правило, это даже часто одни и те же, там были, конечно, примеры и разные
на предыдущем слайде, но по сути дела мы можем настроить часто ту или иную базу данных для
работы с колонками в том или ином режиме. Хорошо, Key Value Stores, данные по рэнкингу
соответствующих баз данных, это агрегация запросов, агрегация данных с гид репозиториев,
где соответствующие проекты хранятся и так далее, то есть в принципе довольно авторитетный,
скажем так, ресурс DB Engines, австрийская консалтинговая компания его ведет,
ресурс с которым можно доверять с точки зрения общей информации по различным вариантам баз данных,
и вот Key Value первое место Redis с большим довольно отрывом, и она много лет, собственно говоря,
на первом месте и находится. Здесь, что еще можно отметить, Database Model,
наверное, то есть если вы обратитесь вот этой колонке, вы увидите, что здесь есть либо
multimodal, либо не одно, а несколько значений, но здесь только два Key Value и multimodal, но о чем это
говорит? О том, что в принципе вот это все разделение, оно не то чтобы прям совсем
условно и никому не нужно, все-таки Redis это часто именно как Key Value, но теоретически,
если бы сильно захотим, мы можем нашу изначально колончатую базу данных Redis взять и сделать
multimodal. Это будет не очень удобно, это будет не очень может быть эффективно, но теоретически
это возможно, если, не знаю, там грубо говоря, у вас хорошая команда редисистов, я извиняюсь,
сидит, и вы не хотите тратиться на то, чтобы приглашать специалистов по условному позгрызу и
переливать данные в позгрыз, формировать какую-то классическую революционную схему данных и
применять ее на практике в вашем бизнес процессе. А плюсы, наиболее простой вид из прочих, принцип
работы аналогичного ассоциативного массива на хэштаблицах, отсутствует какая-либо схема
данных, а value может быть любой объект, в качестве ключа могут выступать не единичные значения,
а массивы. Минусы, за счет необходимости просмотра всей хэштаблицы, при чтении может не очень
хорошо масштабироваться, подходит запрос при чтении соответствует, подходит только для очень
простых данных, ну простых в том плане, не в том смысле, да, мы можем в принципе и архив какой-нибудь
засунуть в value, поместить в раздел value и в архиве там можем накидать все что угодно,
любой информации и по сути дела обойти вот так это ограничение. Но про простоту данных речь
именно о том, что сложно структурированные данные, которые удобно не просто логически хранить,
хотя наверное все-таки, которые удобно именно в первую очередь логически хранить раздельно,
и именно за счет этого раздельного хранения мы можем строить какие-то осмысленные запросы. Вот
для такого рода данных к value конечно не подходит. Понятно, что особенно с учетом того,
что мы можем массивы использовать в качестве ключей, можно придумать историю, когда мы вот этот
key value store берем и искусственными методами превращаем в что-то такое вот реалиционно подобное,
что ли, да, делая сложные ключи, какие-то взаимосвязи и так далее. Но у нас все равно остается проблема,
заключающаяся в том, что key value по умолчанию не оптимизирован для такого рода вещей. И если у
вас возникает соблазн наводить сложные функциональные зависимости между значениями, хранящимися в вашей базе
данных key value формата, то подумайте о том, чтобы все-таки использовать что-то иное, а не key value.
Сложность с построением сложных запросов, ну, собственно, да, она протекает из того факта,
что key value на это и не заточены. Все, что мы с вами попытаемся заточить, я извиняюсь,
будет противоречить парадигме key value и будет выражаться просто-напросто в сложной логике
поддержания всего этого, с одной стороны, и сложной обработке запросов, физически сложной,
процедурно сложной для процесса, с другой стороны. WhiteColumnDB тоже с этого же сайта
ranking DB engines. Здесь, опять же, тоже лидер привычный — это Кассандра. EdgeBase тоже, в принципе,
довольно популярное решение, ну, популярное на практике, имеется в виду у нас. У нас, как бы так
сказать, скажем так, по крайней мере, популярное было точно, скажем так, популярным. Вот как бы
так аккуратно оговоримся обо всем этом. Но, тем не менее, тоже, как вы видите, в database module у
нас есть варианты multimodule по отношению к некоторым участникам этого рэнкинга. Опять же,
Microsoft Azure или Azure, Cosmos DB, как вы видите, и здесь занимает топ-позицию, при том, что это multimodule,
опять же. Ну и, в принципе, это облачное решение от Microsoft популярное довольно-таки в бизнес-среде.
Что здесь еще можно заметить? Да, пожалуй, наверное, и все. Перейдем к характеристикам. Плюс — это
гибкость в физическом хранении данных. Строки таблиц распределяются по разным серверам. В строке
могут быть колонки разных типов данных. Ну это тоже как бы такой, понимаете, условный плюс или минус.
Где-то он может быть... Ну, собственно, сейчас мы об этом и скажем в минусах. Где-то он может быть
плюсом, где-то может быть минусом. Быстрота обработки запросов по колонкам и хорошее сжатие. А минусы —
долгая обработка запросов, извлекающих строки целиком. Ну, собственно, двулекий янус. Колонки
можем хранить на разных серверах. Можем хранить раздельные даже на разных серверах, но может быть
неэффективно. Долгая запись данных в строку и почти полная невозможность создания композитных
индексов. То есть индексов там по более чем одной колонке. Ну тоже, да, вот понятные ограничения,
проистекающие из, собственно, решения хранить данные физически по колонкам, а не по строкам.
Но по большому счету можно еще сказать про колончатые базы данных, что это, наверное,
одна из наиболее близких парадигм к SQL, к релиционной модели, по сравнению с остальными, которые мы здесь
рассматриваем сейчас. Просто вот здесь может быть даже в большей степени вопрос в физическом
разделении данных для работы с большими массивами данных однотипных. Документно-ориентированные базы
данных. Опять же, здесь лидер, я думаю, известный, если не всем вам, то многим MongoDB. Также,
как вы видите, есть и наш предыдущий участник Microsoft от Microsoft, и CosmosDB, и амазоновская
DynamoDB тоже их решение для облачного сервиса. Ну тоже здесь, в общем-то, как вы видите,
здесь данные за предыдущие годы, они практически, вот эти вот тройка, пятерка, получается,
восьмерка лидеров не поменялось на протяжении трех лет, ну, двух, да, двух лет, и забесис тоже
никаких с BDD дебла. Документно-ориентированные, здесь нет поддержки схемы данных, вообще никакой,
да, то есть, если K-value это все-таки ключ значения, мы как-то, какие-то у нас наметки на некую,
хотя бы, примитивную схему есть, есть какие-то ключи, есть, опять же, да, вот, по сути дела,
поддержка релиционных операций и релиционного представления в колончатых базах данных,
документно-ориентированных, такого нет. Храним мы документы в виде, в MongoDB, в виде JSON,
например, и она хорошо для этого приспособлена. Быстрые чтения записи, удобные репликации,
шардирования, но здесь нет никаких схем данных, опять же, это уже как видос идет,
потому что мы их можем создавать только искусственно, непросто, да, вот, там, рисуя ограничения,
как мы делали при создании таблиц и, формируя первичные внешние ключи, здесь и такого даже
нету. Здесь все будет, ну, условно, все будет делать с руками. Плохая поддержка SQL подобных
запросов, собственно говоря, да, вот, простекающие из предыдущих плюсов и минусов, у нас нет схемы,
мы не можем сделать запрос по схеме. SQL-запрос, а это, по сути дела, следование некой схеме данных,
по крайней мере, в логике запроса. Мы должны понимать, да, вот, какие у нас там есть отношения
и хотя бы примерно, как они друг с другом взаимодействуют. Документ DB у нас, поскольку
нет отношений и взаимодействия, мы такого рода запроса не то что построить не можем, можем,
конечно, просто аппаратных, программных, да, программных средств СУБД для их оптимизации,
вероятнее всего, не будет. Графовые базы данных, опять же, в очередной раз мы видим космос DB,
вопрос о multimodal, о следовании парадигме мультимодальности в тех или иных вариантах.
Ну, правда, в сетевых таких вот вендорных базах данных сложно сказать о поддержке мультимодальности,
скорее, может быть, разные модули будут работать с теми или иными типами запросов и пользователи или
разработчик просто, да, там, имея единый интерфейс, по сути дела взаимодействует с
несколькими разными базами данных. Ну, ладно, это такие частости и спекуляции, а здесь первую
строчку занимает уже много лет, даже вот помимо этого рейтинга, явно приведенного, просто много
лет занимает Neo4j, как и, в принципе, на топовых местах в предыдущих табличках, те базы,
которые представлены, они, как правило, с первого места очень много лет не смещаются.
Плюсы, у нас строгая математическая модель, возможно, я бы даже сказал, более строгая в некоторых
вещах, чем релиционная алгебра, релиционная модель, строить удобно специфические предметные
области базы знаний, и что очень важно, гораздо удобнее расширять модель данных,
мы, конечно, можем и там в документно-ориентированной базе данных расширять нашу модель,
и в K-value, там, постоянно добавляя новые ключи, можно сказать, расширяем нашу вот такую привитивнейшую,
одноуровневую модель. А здесь мы, сохраняя нашу строгость, математическую строгость графа,
мы можем постоянно добавлять новые узлы, и при этом у нас будут работать все наши графовые алгоритмы,
и таким образом очень удобно пополнять постоянно базы знаний, как отмечено, можно постоянно какие-то
новые данные вносить, это удобно обрабатывать, это не будет влиять принципиально на скорость работы
в рамках сложности работы того или иного алгоритма на графе и его реализации. Но есть, конечно, и минусы
свои. Разнородные языки запросов у каждой графовой базы данных, нет стандарта по отрасли,
ну, это, в принципе, так сказать, и для других баз данных, для других вариантов нового SQL
баз данных характерно, но здесь может быть проблема именно в том, что на стандартную математику нашу,
дискретную, всем известную, ложится слой семантики, которую нужно от продукта к продукту изучать,
немножко знанного, скажем так. Не поддерживают абстракцию транзакций, такой более технический,
наверное, момент, не будем, пожалуй, о нем подробно, ну, как бы не поддерживают, по-моему, молчание. То есть,
вот эта вот атомарность, consistency, durability, isolation, и так далее, посложно обчитывать запросы с
агрегированием, ну, потому что мы можем пройтись по всему графу нашему и подцеплять просто очень
большое количество данных, а тогда как даже в стандартной революционной модели, вернее, базе
данных, мы могли бы стандартным запросам, привычным надо это сделать, но самое главное,
просто алгоритмы под капотом революционной базы данных, удобно бы собрали данные для агрегации.
SQL и против новой SQL реальное положение дела. Что нам говорит этот слайд? Во-первых, опять же,
обратите внимание на database model, здесь многие модели мультимодальные, многие базы данных,
но, тем не менее, мультимодальность все-таки, и здесь она поставлена на второе место, и, по сути
дела, так оно и есть, потому что вот все, что представлено в первой десятке, почти все,
ну, за исключением, пожалуй, MongoDB и Redis, да и Elasticsearch, ну хорошо, большая часть из того,
что представлено в первой десятке, это классические революционные базы данных, о которых вы либо
слышали когда-то вообще, в принципе, они на слуху, либо мы о них прямо говорили, ну вот,
на курсе, вот, о MySQL, а SQLite мы точно упоминали в таком общем беглом разборе различий на первых
лекциях. Microsoft SQL Server, Oracle, просто популярные, известные решения, опустим их в доступность,
да, это рейтинг такой общемировой, и понятно, что он не поменяется принципиально в зависимости
там от доступности, недоступности того или иного продукта в том или ином регионе. Ну, не говоря
уже там про всякие как бы варианты с лицензированием. А что нам это говорит, что нам говорит эта табличка,
почему она интересна для нас, потому что, как вы видите, несмотря на большое количество различных
парадигм, и вот этот вот score, он, скажем так, в одном пространстве, то есть он для всех баз
данных в общем-то применим даже с независимости от того, что там та или иная парадигма используется,
то есть мы можем по нему абсолютного победителя найти. Абсолютный победитель — это наша такая
большая четверка классических реляционных баз данных. От реляционных моделей и баз никто не
отказывается, это все равно наиболее популярная модель для бизнеса уж точно, и поэтому, да, вот в
первую очередь, конечно, необходимо знать реляционную модель, уметь работать с реляционными базами
данных, но и топовые решения по NoSQL, конечно, в общем виде хотя бы надо себе представлять.
Так, хорошо. NoSQL — достоинство. Позволяет хранить большие объемы слабо структурированной
информации в более-менее связанном виде, удобство масштабирования в сравнении с реляционными
базами и системами управления баз данных, удобство репликации шардирования, быстрота
разработки. Недостатки. Не требует проектирования схемы предметной области, поощряют накопление
несогласованной информации в БД. Для сложных предметных областей схема данных стремится к
реляционной по сути дела. Ну, вот так вот на практике складывается. Ну, либо как бы можно
условно тоже сказать, что к графовой модели, может быть, она могла бы стремиться, и как мы с вами
говорили, может быть, вы вспомните на первой лекции, что по большому счету то, что мы с вами видим на
схеме наших данных, не что иное на схеме реляционных наших данных, когда вы проектируете,
не что иное как граф, просто его вершина представлена сложным объектом в виде реляции,
в виде отношений, в виде таблиц, но по большому счету все равно наш граф. Поэтому вот здесь такая
есть взаимопродикновение на концептуальном уровне, но предметно, по сути, все равно нам,
когда мы говорим о каких-то реальных данных, бизнес значимых, в крайней мере, у нас модель
точно будет стремиться к реляционной. Поэтому мы, конечно, можем начать с MongoDB для нашего Agile,
для нашего Agile, Scrum Scripts, Sprint, вернее, и pet-проектов или там стартапов использовать
MongoDB, использовать еще что-нибудь, и проблема просто в том, что на каком-то этапе мы все равно
поймем, что нужно все переделывать и ставить классический наш пресловутый Postgres, а то,
может быть, еще и какой-нибудь Green Palm в качестве DWH, и переписывать то, что у нас есть,
в понятную стандартную реляционную модель. Согласовываясь с конечным счетем,
BASE принцип вносит риски и ошибок, но это то, что должно быть понятно из описания BASE,
которое было дано выше. У нас может быть ситуация, когда у нас данные есть на одном узле и нет на
других, и, соответственно, пока информация не пройдет, не распространится по всем узлам нашей
сети, нашей системы, мы не узнаем, есть ли проблема в выданных пользователю данных, нет ли проблемы,
не сможем даже, по сути дела, что-то сказать по существу. И напоследок, с точки зрения общего
обзора, по крайней мере, это так называемые векторные базы данных. Здесь, скажем так,
есть такая интересная история. Наверное, пару-тройку лет назад это было очень, наверное,
интересно и перспективно. Сейчас, на текущий момент, по крайней мере, лично мне кажется,
что это уже чуть менее перспективно с учетом развития больших языковых моделей, но о чем речь,
давайте все-таки последовательно. Векторные базы данных, то есть мы хотим оптимизировать
хранение и извлечение данных, представленных в векторном виде, то есть мы какие-то наши данные,
как правило, текстовые, строковые, давайте более общий, может быть, термин возьмем, строковые
данные могут быть чисто в этих строках. Строковые данные хотим превратить в эмбидинги, с помощью
какой-то нейросетевой модели мы их превращаем, то есть они у нас становятся векторами в каком-то
вот таком гиперпространстве, в многомерном пространстве, и мы хотим их хранить, мы хотим в них
проводить быстрые операции, искать ближайших соседей, хотя сравнивать их по направленности векторов,
по косинусу угла между ними. Как нам это все сделать? Можно говорить в этом смысле о векторных базах
данных, но это примерно ситуация как с колончатыми и широко колончатыми базами, по сути дела это
все еще кэй вэлью, скорее всего кэй вэлью база данных под капотом, а где просто будет храниться,
хранится в качестве вэлью, в качестве значения вектора, мы да вот как бы некоторые механизмы там
специфически конечно будут, там механизмы хранения, дата стор, индексирование, механизмы запросов,
но это наверное не столь принципиально, здесь какой-то новый концепции, новый парадигмы того,
как хранить данные, как это все представлять, по большому счету нет, мы просто удобно храним
вектора и предоставляем их удобным тоже образом, по крайней мере физически удобным образом,
для того чтобы обрабатывать алгоритмом. Вот стандартный вариант Facebook e-similarity search,
ну скажем так, до последнего времени все еще стандартный, по которому мы с помощью этого алгоритма
мы найдем по нашему запросу, тоже представленному в векторном виде, вектора, похожие на наш вектор
запроса. Важное отличие от иных типов BD, мы при запросе получаем не стопроцентно правильный
результат, ну по отношению к данным, хранящимся в нашей иной базе данных, мы либо получим в иных
базах данных, либо получим по существу какой-то ответ, и он будет прям стопроцентно точно,
мы сколько бы не повторяли наш запрос, при условии неизменности данных, наши ответы будут
всегда идентичными. Здесь в принципе тоже при условии неизменности данных будут ответы
идентичными, окей, но вероятность соответствия нашего ответа нашему запросу, она носит
проблематичный характер, и в зависимости от того, как мы там изменим семантику вопроса, вернее даже
не семантику синтакса, семантика может остаться такой же, у нас может поменяться сильно характер
результатов из-за того, что вектора представления поменяются, и будет иной результат при сравнении
вектора запроса, с векторами хранящимся в базе данных. Ну ладно, такие технические, может быть,
излишние подробности, в принципе ничего сложного нет, просто храним вектора для того, чтобы удобно
было искать как минимум к ближайших соседей, или просто к конкретному вектору, конкретный вектор
сравнить с другим конкретным вектором. Типичные решения на текущий момент Мильвус, Пайнкон, Вивайт,
ну или Пинкон. Вивайт, возможно, я неправильно произношу заранее, прошу меня извинить, не работал,
честно говоря, с этой базой данных, но просто она есть, она в числе таких вот и более распространенных
на данный момент. Давайте кратко посмотрим теперь на то, как в Neo4j представляются данные,
и как с ними происходит взаимодействие. Neo4j получается, это наша графовая база данных,
топовая графовая база данных. Как мы уже с вами сказали, здесь есть сильная подлежащая математика,
теория графов. Она, если не интересно нам с точки зрения, может быть, построения базы данных
самой по себе, то она точно нам интересна с точки зрения того, что мы можем, не боясь строить базы
знаний, строить какие-то гибкие расширяемые модели, и нам будет с ними удобно-комфортно работать
впоследствии, потому что математика, даже может быть не математика, уже алгоритмика какая-то,
вот работа с графами, она позволяет довольно просто, ну понятно и предсказуемо с ними обращаться.
А что у нас такое, что у нас с моделью данных в Neo4j? Данные и отношения между ними представлены
в виде трех объектов модели. Узлов, ну или вершин в графе, отношений и свойств. То есть,
у нас есть узел, это на рисунке в данном случае. В данном случае это вот такие кружки, отношения
это стрелочки или ребра, и свойство это то, что у нас находится в, ну те данные о кружках, скажем так,
об узлах, которые мы записываем. Узлы представляют собой сущности или объектов в графе, они похожи
на записи или объекты в традиционной базе данных. Ну давайте для простоты записи. Узлы это все
равно что записи, и каждый узел может иметь одну или несколько меток, которые определяют его роль
и тип в графе. Метки помогают эффективно организовывать и запрашивать данные. Узлы могут
иметь свойства, которые представляют собой пары ключезначения, представляющие дополнительную
информацию об узле. То есть, вот здесь Person и Actor это метки, Name и Board, это соответственно наши
записи, наши свойства, работающие по типу ключезначения. Узлы могут иметь метки Labels и
пример синтекса создания узла Create, Person, Actor и вот метки, и внутри узла ключезначения Name,
Tom Hanks, Born 1956 год. Про это свойства. Это пары ключезначения, которые используются для хранения
данных об узлах и отношениях. Значение свойства может содержать различные типы данных, такие как
число, строка или булевые значения, и содержать список или массив, состоящий, например, из строк,
чисел или булевых значений. Компоненты должны принадлежать при этом к одному типу. Вот пример
создания свойств со значениями разных типов. Ну опять же, мы по большому счету создаем именно
узел, да, новый, с меткой Example, и внутри него свойства. A, единичка, C, строка, B, число
с плавающей точкой. Действительное число, да, будем все-таки по-русски, наверное, выражаться.
И F это массив, как пример. Отношение, опять же, описываются в связи. Узел может иметь петлю,
отношение с самим собой. Звучит, наверное, не очень. Отношение узла может замыкаться на рем само,
скажем так. Отношения всегда направлены и имеют начальный узел, то есть наш граф всегда
ориентированный. По большому счету мы, конечно, можем это игнорировать, как бы не используя некоторые
уловки. Но по умолчанию это ориентированный граф, и тоже отношения у нас могут иметь и тип, и метку,
и могут иметь соответственно свойства, которые вот представлены на слайде в виде синкса,
на примере синтакса создания отношения. Вот у нас метка или тип, acted in, и свойство roles forest
performance 5. Ну да, вот это про Тома Хэнкса, собственно, что он играл, в какой роли, и performance значимость,
может быть, исполнение какая-то дополнительная техническая информация. И в данном случае
здесь слева и справа должны быть некие узлы, они в примере не показаны, но слева, очевидно,
должен быть Том Хэнкс, справа должен быть Форест Гамп, фильм. Ну или, вернее, слева будет
actor-person-узел, а справа будет узел-фильм. И вот здесь пример создания элементарной базы
данных, то, о чем мы только что сказали. Вот узлы, ну, в общем-то, то, что было, наверное,
на предыдущих слайдах, на начальном слайде про Neo4j. Вот мы создаем узел, причем мы сразу
обратите внимание, создаем все, что показано на иллюстрации, мы создаем одним запросом. Это
не обязательно, но вот можно и так, скажем. А мы создаем person-actor, Том Хэнкс, именно дата
рождения, где играл, какую роль исполнял. Дальше показываем, к какому узлу относятся отношения,
относится наш первый узел, это узел-фильмы, здесь у него есть свойство названия фильма,
и с другой стороны у нас тоже к этому же узлу фильмы дополнительно есть отношения с новым узлом,
это, по сути, своей режиссер, но здесь обозначено как просто персону, то есть, по сути, дело мы,
для чего это сделано, person-person, для, опять же, вот, это метки, это такая, в некотором смысле,
техническая информация, потому что, когда мы будем задавать вопрос по людям, система СУБД у
нас отработает лучше, если мы не просто скажем, что здесь у нас актер, а здесь режиссер, а мы еще
укажем, что они к одному классу принадлежат, то есть, к классу персон, к классу физических
лиц, к классу людей, например, но можно здесь, в этом узле было бы добавить еще и директор,
метку для дополнительной информации. Для наших запросов используется собственный язык Neo4j,
используется Cypher Query Language, CQL, он немного похож, ну, вы уже, собственно, и видели на SQL,
что-то вот такое смутно, смутно похожее на Create Table, было в слове Create, что-то похожее на
Command Create Table, в виде Create, Command Create для создания узла используется, ключевые слова также есть
в виде Match, Where, Create, Delete, Return и другие. Пример поиска по паттерну, приведен на слайде,
Match, Me, Nodes, Nose и Remote Friend, то есть, нужно найти такие вот узлы, которые у нас соответствуют
приведенному отношению, где имя первого узла это Филиппа, а нужно найти, по сути дела,
всех друзей, вот так скажем, всех друзей некоей Филиппы, которая у нас еще и итеративно будем
проходить по нашему графу. Есть агрегирующие функции? Можем ли мы конкретный узел найти,
вы имеете в виду? Вопрос, да, есть у вершины или ребер что-то вроде первичных ключей или
идентификаторов? Ну, как бы, точно есть на физическом уровне, безусловно, а с точки зрения того,
можем ли мы найти какой-то конкретный узел, который нас интересует, просто вот сказав,
задав запрос типа Find там ID такой-то, но мы можем сделать лист всех узлов и выбрать нужный,
если мы не знаем схему. Если мы знаем схему, то теоретически у нас должна быть где-то
графическая модель, как вариант, но техническая информация, безусловно, есть, просто вопрос здесь
такой, как бы, да, зачем она нам нужна. Не совсем может быть понятным, повторюсь,
мы можем список узлов построить и выбрать, есть два варианта, повторюсь, мы знаем схему и нам
не нужен ID-шник, потому что мы просто-напросто знаем, у нас есть какой-то, не знаю, рисунок,
какая-то схема графическая, где у нас там все узлы. Мы не знаем схему, тогда нам нужно, как минимум,
сделать список узлов, мы можем это построить и уже по конкретному узлу найти что-то похожее на то,
что нас интересует. Технически, безусловно, есть ID какой-то, там ID записи на диске, ID внутри
системы, которая будет значима для системы, но напрямую мы его можем просто физически и искусственно
добавить, пожалуй, так.
Так, если кто-то что-то сказал, то да, я не слышу, к сожалению, ребят, почему-то.
Сейчас меня тоже, да, я слышу.
Поэтому либо повторите запрос в чат по поводу слышимости, но на вопрос с ID-шником, мне кажется,
нельзя добавить узел с уже существующим узлом. Не совсем понимаю, узел у нас,
узел это вершина, что значит добавить вершину с уже существующим вершиной?
Запрос, да, вот дополнительно уточняющий запрос, если получается нельзя добавить связь,
а связь с уже существующим узлом. Почему? Нет, мы можем добавить новую связь. Нет,
не обязательно нам указывать все связи с новым узлом, не совсем понимаю. Просто у нас будет,
грубо говоря, команда Create, где мы, для простоты, будет Create какой-то узел, и от него будет
вот там стрелочка, где будет соответственно адрес назначения в виде существующего узла.
Ну, не знаю, извините, может быть, не совсем понимаю, но давайте
двигаемся дальше, сейчас, может быть, вернемся, или станет понятнее, о чем речь.
Просто указав узел. Ну ладно, ребят, давайте сейчас договоримся и вернемся к этому чуть-чуть,
чуть-чуть попложе, здесь немного осталось. Так, есть агрегирующие функции, допустимо,
использовать стандартные операторы, сравнение логические операторы. Да, вот match и вот where и
order by вообще очень похожи на то, что бы с вами видели в релиционных, вернее, в нашем SQL. Здесь все,
соответственно, все узлы с соответствующим типом найдутся при условии, что некое свойство больше
10. Помимо Create, для определения данных используется также конструкция set, delete и merge. Используется
для исключения дубирования данных, в примере вышки узел не будет создан, если в BD уже есть
узел с аналогичными свойствами. Я понял, да, по умолчанию Create создаст новый узел одноименный,
здесь нужно использовать либо set, либо merge, например, в примере. Не обязательно использовать,
то есть Create создает заново, просто другая команда будет использоваться. Смотрите,
у нас допускает создание пользовательских функций, еще раз возвращаемся. Если будет
просто Create использоваться, то у нас будет создаваться новый узел. При этом,
когда мы используем Create для создания отношения, она работает более осмысленно. Если вы укажете
просто метку узла, то у вас он не будет создаваться заново, он будет найден и по нему
будет создано отношение. Если метки совпадают, система выдаст уточнение, уточняющий запрос и
попросит вас как-то специфицировать, но по идее метки, скорее всего, совпадать не будут,
потому что иначе не совсем понятно, вернее, они в принципе не могут совпадать вот так,
потому что не совсем понятно, как тогда эти узлы классифицировать. Если у вас будет 2 Person
и Actor, то непонятно, зачем они, как бы логически непонятно, и система не даст вам это создать
Любое добавление информации в Person и Actor будет всегда идти в раздел с ключ значения и все. Поэтому
если вы хотите связь именно создать, вам нужно указать метки, которые вы указывали при создании
узла. И по сути дела метками у вас специфицируется ваша связь. Ну конечно, там можно сразу начинать
думать о том, что, а если у нас десяток меток? Если у нас десяток меток, тогда есть вопрос в том,
насколько у вас адекватно с вашей предметной области спроектирована ваша база данных.
Действительно ли там должно быть 10 меток для узла или может быть должно быть 5 узлов по 2 метки
и просто со связями между ними. Поэтому здесь вот так вот. Так что ваши ID-шники, по сути дела,
это Person и Actor. Также еще вы можете дополнительно создавать связи. Что еще здесь? Мерч, мы сказали,
да, позволяет исключать дублирование. Ну как бы да, хорошо прощение тогда. Получается все-таки
Create можно создать, окей. Create можно создать дублирующий узел, лучше тогда использовать мерч
для того, чтобы создавать новые узлы в незнакомых по крайней мере вам базе данных. И
связь у нас будет специфицирована опять же метками. Насколько я знаю, насколько я с этим работал,
это не был какой-то большой продакшн, признаюсь честно, но метками специфицируют вершины. И по
большому счету все. Вы можете создать дубль, вы можете использовать мерч, чтобы дубль не
создавать. Вы можете командой Set создать какие-то дополнительные лейблы назначить. Ну вот как-то так.
Смотрите, давайте общий ответ, наверное, будет такой. Если вы хотите прям досконально в командах
разобраться, все-таки здесь не буду кривить душой, лучше использовать документацию. Ну у нас такая
обзорная задача, пожалуй, так. Отличаются узлы у нас все-таки только метками на уровне запросов. Мы
ID-шник. Технически, наверное, можно указать какой-то ID, какая-то специальная команда точно
должна быть, но в более-менее реальной ситуации это будет просто скорее всего метка. Те метки,
которые вы назначили на узел, по ним следует ориентироваться. Ничего не мешает. Мы можем
создать совершенно справедливо новый узел Person Actor. Он будет дублироваться. И как раз
команда Merge используется для исключения дублирования данных. В примере Wish узел не будет создан,
то есть вот в этом примере. Merge Movie Title Matrix ER 1999. Узел не будет создан, если в BD уже есть
узел с аналогичными свойствами. Вот, собственно, вот так вот. Так. Хорошо, давайте мы двинемся
чуть дальше. У нас будет лекция. Я чуть-чуть подробнее тогда синтаксис. Буквально один слайд
сделаю по командам. В целом, что у нас еще? Допускается создание индекса? Да, допускается
создание. Так, ну это я уже говорил. Единственное, может быть, меня не было слышно, но, в общем-то,
здесь все на слайде описано. Давайте немножко просто запросов. Посмотрим, как они работают.
Match John Thorson. Name John. Match John Friend. Friend. Нужно найти имя друга, и будет оно выдано как
Friend Name в колонке. Вот у Джода есть узел, персона, имя John, и мы соответственно ищем по отношению
Friend всех друзей Джона, которые у нас предыдущим графом представлены. И Match John Thorson и Name John
у нас будет соответственно выдано, только наш верхний узел будет выдан. По узлу, это три разных
запроса, если что. По узлу у нас... Рекурсия по графу? Да нет, графовые алгоритмы не обязательно
рекурсивные. Ну еще раз, это три разных запроса. Это раз. Два? Не обязательно. Не скажу сейчас,
как под капотом работает Matching в Neo4j. Да-да-да, три разных. Но нет, на базовых графовых алгоритмах,
если вы помните рекурсии, по-моему, обход ширину, длину, там можно все это... В принципе,
ну ладно, это немножко уже другая история. Мы по связи друг ищем друзей Джона, и вот у нас
появляется John и Friend, Sarah и Joe. Вот Sarah, вот Joe. Мария и Стив – это друзья, соответственно,
Sarah и Joe, поэтому они у нас не попадут во второй запрос. И то же самое. Здесь раз два запроса,
три третий запроса. Это, по сути дела, прикрепляется ко второму. Это вариант второго,
когда у нас просто выдача изменится. Мы таким вот Return форматируем то, что у нас появляется.
Ну, такая немножко техническая история. Прошу прощения, два запроса, по сути дела.
Еще пример запроса. Мы ищем персону, где имя начинается с буквы J, и мы создаем для этой
персоны, для этого человека друга с именем JJ. Что у нас получается? Вот сначала у нас находится
запрос. Вот на этой стадии запроса... Прошу прощения. Сначала у нас находятся люди с именами
Jay, начинающиеся. Вот у нас промежуточная стадия, такой результат. Вот мы нашли Joe и John из нашего
предыдущего графа. Остальных друзей мы не нашли. Но если бы у нас был здесь какой-нибудь
Joy, женское имя, тоже бы это попало в нашу выдачу. У нас было бы здесь вот так вот три узла из пяти.
Дальше наш запрос создает новых друзей для людей с именем John, с именем на John и Jay,
с именем на Jay. И создаются вот PersonNameJJ, PersonNameJJ. В принципе, получается, что у нас
здесь дублируется наш узел. Не очень, наверное, хорошо. Но мы его впоследствии можем смёржить
и сделать в один. У нас будет две связи. Один узел. Здесь немного другая история. Здесь такого
примера не будет. Что еще можно вспомнить? У нас на первом слайде были рекомендации по
интерпретации релиционных данных в графовые. Прямо вот из официального руководства,
если перейдете по ссылке, то увидите, что проку в нашей таблице можно интерпретировать как вершину.
Таблицу в релиционной базе можно, вернее, имя таблицы в релиционной базе можно интерпретировать как
имя, как метку вершины. То есть, имя-отношение – это метка вершины. Join или foreign key – это
операция. Foreign key – это ограничение. Но, тем не менее, там можно интерпретировать как дугу,
как вот эту вот связь, стрелочку, которая у нас на слайде показана. Почитать еще официальная
документация Google. Вопросы были заданы. Я их запомнил из всех попрашающих. Давайте я немножко
обновлю, потому что, честно скажу, довольно продолжительное время назад пользовался
Neo4j. Штука интересная, любопытная. Она с точки зрения того, как на релиционную нашу привычную
модель, которую мы уже, в принципе, восприняли, ложится в голове, интересна. И чуть-чуть, вот буквально
на слайде, на следующей лекции сделаю примеров, покажу, как что работает для наглядности,
чтобы закрыть Neo4j. На следующей лекции у нас тогда колончатые документные и key value и ключ
значения будет по одному примеру. Наверное, radius ключ значения, колончатые, click house и,
что еще у нас, документно ориентированные. Наверное, Mongo.
