И начнем с вами говорить уже чуть больше про алгоритмы, наконец-то, но никуда не
деменимся в то же время от математики. Это видно, это отлично. Очень рад, что вы пришли снова.
Что поделать, что бывает. В действительности, мы сегодня поговорим также, у нас будет вот такой
математический аппарат, где мы будем что-то делать, что-то у нас будет происходить. Вам,
может быть, это частично не понравится, но по итогу мы выйдем к алгоритмам, и мы будем уже
говорить об алгоритмах все в последующее время, кроме, может быть, последней лекции. Последняя
лекция будет такая, более теоретическая. Плюс там еще посерединке будет эмоциональный анализ.
Но это все очень важно, это все очень нужно, поэтому никогда не думайте, что, типа, блин, да зачем мне
нужна эта ваша математика, я вообще хочу стать разработчиком. Разработчиков без математики не
бывает. Вот. Без какого-то, во-первых, мышления, во-вторых, без какого-то понимания, типа, мира.
Вот. И в то же время, ну, напишите, вы перебор, типа, за n в степени n, и будет все грустно. А если
вы будете смеяться и обсуждать какие-то фотки, я не знаю, что вы там делаете. Девочки? Привет! Я
здесь. Вот. Вроде меня не транслируют, поэтому в телефон можете смотреть. В общем-то, все, как обычно,
я прошу вас сильно громко не говорить или вообще не говорить. Это было бы совсем чудесно. А в
остальном, как бы, мы здесь много чему научимся. Я надеюсь, сегодня вы поймете какую-нибудь новую
интересную тему. И первое, что мы будем с вами говорить, это рекуррентные соотношения. Кто
представляет, что такое рекуррентные соотношения? Как тебя зовут? Саша. Да, отлично. Что в твоем понимании
рекуррентные соотношения? Ну, рекуррентные соотношения, когда мы создаем какой-нибудь, ну, член-то за это, через предыдущий.
Да, действительно, это такая подзадача в задача. Мы сначала добиваемся какой-то подзадачи более
маленькой, и с ней мы уже работаем. На самом деле, рекурренты возникают в следующих случаях. Очень
часто вы их встретите в задачах разделяй и властвуй. Это принцип. Это не какое-то такое, знаете,
вот слово, это цитата великих людей, нет. Разделяй и властвуй — это некоторый принцип в алгоритмах, где
говорится о следующем, что благодаря разбиению на какие-то подзадачи мы начинаем собирать полную
задачу. Иначе бы у нас этого не было. И в действительности разделяй и властвуй работает за счет каких-то
рекурсивных разбиений на более мелкие задачи, чаще всего именно рекурсивных. Иногда можно сказать,
что, блин, ну, зачем нам тут рекурсия? И в действительности, если я вас на экзамене спрошу типа,
а надо ли рекурсивную, можно ли любую рекурсивную задачу свести какую-нибудь с циклами, вы должны
мне ответить да. Это правда. Есть отдельное доказательство этому. Но да, любая рекурсивная
задача так или иначе будет сводиться к циклам. Если у вас задача только циклы, не думайте,
что вы не пользуетесь принципом разделяй и властвуй. Это не так работает. Многие задачи можно
переписать даже в каком-то объективно адекватном виде. Вот. И мы в этом принципе что делаем? Когда
мы получили более мелкие подзадачи, мы их комбинируем и получаем какой-то следующий ответ. В этих
более мелких задачах мы спускаемся до каких-то элементарных, где мы точно знаем ответ. Ну, не знаю,
там для нуля это выглядит именно так, для единицы вот так. Отлично. Значит, для двойки мы можем сказать.
Простой пример числа Фибоначчи. Вот вам те маленькие подзадачки. Хотя это больше динамика,
но это очень похожая между собой вещь. Здесь у меня, я не знаю почему, но у меня не отображается
фигурная скобка. Я когда-нибудь, надеюсь, это починю, потому что в превьюшке она всегда есть.
Вообще, если вы используете хоть какой-то алгоритм разделяй и властвуй, то почти, наверное,
во время работы с ним вы встретите какую-то рекурренту, какое-то взаимоотношение между предыдущими
и новыми действиями. Рекуррентное соотношение это, по сути, некоторое уравнение или неравенство,
которое описывает функцию. Это не обязательно всегда равно, это может быть и меньше. То есть мы
выполним меньше действий, чем что-то. Это тоже рекуррента, но если она зависит от какой-то
более мелкой подзадачи. Вот здесь написано, так можно сказать, полная рекуррента, что вот для n
равного единицы у нас есть крайний случай раз, и для всех остальных случаев у нас описано вот таким
вот образом. Чаще всего мы будем сокращать до последнего равенства. Почему? Потому что первое
неинтересное. Что там? Это от единицы. Вы же знаете, что такое это. Значит, зачем нам одно и то же
повторять? Поэтому мы будем смотреть что-нибудь интересное. Вот там вот написано 2tn пополам равно
ttn, там плюс ttn. За это я прошу прощения. Это моя ошибка. Вот, возьмем, к примеру, такую рекурренту. И как
вообще оценить, за сколько это работает? Вот у нас есть рекуррентное соотношение. Как вы, может быть,
в школе какие-нибудь рекурренты встречали? Какие? Числа фибоначи. Хорошо, это правда рекуррента.
Есть еще что-нибудь? Вот самое простое. А факториал еще раз? Другое. Какие еще раз? Натуральные числа.
Хорошо, это правда. А натуральные числа это что? Хорошо, ладно, подведу. Так, и как это называлось у вас?
Линейная рекуррента. Хорошо, ладно, арифметическая прогрессия. Я очень долго пытался добиться этого
слова. А линейная рекуррентная правда, натуральные числа правда, это просто арифметическая прогрессия.
Это самый простой способ рекуррента. Вот та самая арифметическая прогрессия. Существуют еще кроме
одной прогрессии, существуют еще геометрические прогрессии. И как-то с ними тоже нужно работать,
что-то с ними делать. И как же вообще жить в этом плане? Так вот, а если мы с вами говорим о том,
что у нас есть какая-то рекуррент, надо оценить время. Ну вот у нас есть, к примеру, арифметическая
прогрессия. Можем ли мы посчитать сумму арифметической прогрессии? Это все достаточно просто и тривиально.
Сложить первые и последние члены, разделить пополам. Ну либо просто воспользоваться этой суммой. Это не
очень сложная задача сама по себе. Правда? Я надеюсь, вы это знаете. Вы знаете, как сложить чиселки от
одного до ста в уме? Какой ответ там будет? 5000. Отлично, вы все учили в школе. Меня это очень радует.
Да, в действительности, к примеру, вот таким вот образом. Но мы возьмем вот ту рекурренту,
которую мы с вами смотрели. Первый метод – это метод постановки. Метод постановки – очень банальная
вещь. Мы просто предполагаем. Мы такие, ну возьмем, к примеру, вот такую вот оценку. Будем считать,
что там t от n равно θ от n. То есть время работы оно линейно зависит, причем явно линейно. И мы скажем,
хорошо, в этом случае отлично, мы будем с этим работать. Чудно. Вот, но что в этом случае необходимо?
Необходимо доказать. Я подозреваю, что в школе у вас, когда метод мат-индукса, во всяком случае у меня
так было, может меня поправите. Когда вот была сумма квадратов или что-то такое было, для того,
чтобы найти там от 1 до n, необходимо было просто доказать. Вот типа нам дали выражение, такие докажите
методом мат-индукции. Откуда взялась, что взяло, почему – никто не знает. Вот это примерно тот же метод.
Предполагаем, смотрим, доказали, доказали, не доказали – грустная история, пробуем еще раз.
То есть здесь нет какого-то такого глобального, не знаю, как его назвать-то правильно, теории
заговора нет здесь. Вы ее не раскроете, потому что она просто здесь существует. И нужно подумать,
как с этим жить. Возьмем, например, вот такую функцию. t от n равно 2t n пополам. Заметьте,
у меня здесь нижнее округление. Почему? Потому что просто это удобнее. Бывают нижние,
бывают верхние, бывает просто округление. Чаще всего берут что-то одно, просто легче это всегда
оценивать. 2t n пополам плюс n. Вот нам нужно оценить эту штуку. Ну, давайте начнем с каких-нибудь
предположений. Я возьму здесь сразу верное предположение, что это o большое от n log n.
Хорошо выглядит? Ну, хорошо. Давайте пробовать, что делать. Что означает o большое? o большое
означает, что оно меньше, чем c умноженное на n log n. То есть существует такое c, что оно
ограничивает вот сверху вот эту функцию. То есть t от n меньше, чем c от n log n. Это наше
предположение индукции. И нам его нужно доказать. Ну, смотрите, у любой математической индукции есть
что? Есть база, есть переход индукции. Но база здесь всегда почти очень легкая. Единственное,
что вы не можете взять здесь единичку, потому что для единички будет неверно. Потому что логарифм от
единички чему равен? Нулю. Ну а здесь скорее все-таки t от n будет равно единице. То есть для единички оно
не подходит. Но можно сказать, что мы возьмем какое-то n нулевое чуть подальше, чем единичка,
и возьмем какое-то специальное c. И тогда все будет хорошо. Это действительно так, вы можете на это
посмотреть. Вот. Чудно. Это вот такая вот база индукции. И дальше берем предположение индукции.
Предположение какое? Что для любых меньше, чем n, а для любых m меньше, чем n. Предполагаем,
что это верно. В том числе это верно для n пополам. Если это верно для n пополам, тогда вот то,
что у меня написано посерединке. То есть t делить t от n пополам, оно меньше либо равно, чем c
n пополам, но логарифм n пополам. Звучит все равно не круто, не классно. Но что нам это позволяет?
Во-первых, сократить двойку. Это чудесно. Во-вторых, можно раскрыть логарифм. Если в логарифме есть
деление, то это раскрывается как разность логарифма. Все верно. Вот. Именно этим я здесь и использую.
Тогда подставляем это в t от n. Если мы это подставляем в t от n, то мы просто вот эту двойку опять же
сокращаем. Получаем логарифм n пополам плюс n. Я здесь почему ставлю меньше либо равно? Потому
что я вот это n пополам просто беру как число. Я убираю вот то самое округление вниз. Если бы у меня
было округление вверх, тогда бы я должен был взять там n пополам плюс один. Что-нибудь такое. Вот здесь
округление вниз мне помогло. Ну и плюс n? Раскрываю логарифм. Получаю c, n логарифм n,
минус c, n логарифм 2, плюс n. Ну что я могу сказать здесь? Ну у нас логарифм здесь ну возьмем
двоичный. Нам не важно. Константа все и так съест. Вот это c, которое существует, оно все и так съест.
Но мы можем взять специально логарифм по основанию 2, тогда получим, что логарифм 2 по основанию 2
это единичка. Чудно, тогда получаем c, n логарифм n, минус c, n, плюс n. Но вы согласны с тем, что это
меньше, чем c, n логарифм n? Да любой c больше единички. Правильно? Потому что если я возьму c
меньше единички, то будет неверно. Но если я возьму c больше единички, то это окажется верно. Вот оно наше
доказательство индукции. Мы доказали для любого n. Это правда. Это правда. Здесь я не буду спорить.
Можно попробовать. И мы даже это попробуем. Я больше скажу. Но в том суть здесь, что это все нам
позволяет сделать? Что же такое это? Все это нам позволяет с вами посмотреть на то, что здесь
происходит. Как минимум сверху мы уже ограничили. Можем ли ограничить еще? Можем попробовать.
Естественно мы могли сказать o от n квадрат, o от n куб, o от n в четвертый, получить верный ответ.
Да, не спорю. То есть ваши предположения могут сыграть вам на руку, а могут сыграть против вас.
Потому что вы подумаете, что это рекуррент работает за n квадрат. Не круто. Вообще не круто. Но вы
докажете. Но это не будет означать ничего. Для данной именно задачи. То есть в данной
задаче это будут такие вещи. Пока мы будем ограничиваться вот таким методом и еще
максимум с деревьями, потому что для других методов вам нужен чуть-чуть подкачать математический
аппарат. Чуть-чуть. Как подкачаете, поверьте, научите. У вас будут какие-нибудь дискретная
математика, дискретный анализ. Извините, все, я рассуждаю в рамках другого. Да, там такое тоже
возможно. Скорее будет. Ну посмотрите, не знаю точно. Вы встретите слова в виде производящей
функции и это решается с помощью них. Достаточно легкая вещь, когда вы знаете там разложение в
ряды и все такое. Это немного просто другая штука. Поэтому здесь мы не будем на этом долго
останавливаться. Окей. С этим понятно? Отлично. Какие есть ошибки? Вот то самое ОАТН. Возьмем
ОАТН. Скажем, что пусть это так, тогда у нас Т от Н меньше, чем С от Н. Для С больше нуля. Ну,
опустим любые предположения, связанные с единицей и так далее. Здесь оно в принципе подойдет.
Окей. Тогда, рассуждая похожим образом, мы с вами в какой-то момент получим, что Т от Н меньше,
чем два на С и Н пополам плюс Н. Ну, просто подставив. Правильно? Чудно. Мы подставили,
сказали, что это так. Значит оно меньше либо равно, чем С и Н плюс Н. А потом вы говорите типа,
С и Н плюс Н. Но это ОАТН. Все доказали. Где ошибка? Констант меняется. Еще что?
Ну, с точки зрения формальной рассуждения, скажите, где ошибка? Предположение. Мы должны доказать
предположение индукции. В нашем же случае мы предположение индукции не доказываем. У нас
предположение, что меньше либо равно, чем С и Н. А здесь у нас получается меньше либо равно,
чем С и Н плюс Н. Это уже неверное предположение. Значит, мы не доказали это методом от индукции.
Поэтому не спешите все заносить в «О, большое Т, ты думаешь, что вот так хорошо? Она там лежит? Я
его не трогаю? И у меня все хорошо». Нет. К сожалению, в эти моменты могут возникать не те вещи. Поэтому
не делайте так. Второй способ решения, который доступен в общем виде, это деревья рекурсии.
Что такое деревья рекурсии? На самом деле дерево рекурсии достаточно простая штука. Вы просто
рисуете дерево. Вот у вас есть какая-то, например, задача, связанная с рекурсией, и вы в узле храните то,
сколько действий потратится именно в этот момент на это выполнение. Однако все рекурсивные вещи вы
спустите их как детей, и тогда получите такое вот дерево. У меня там будет пример. Давайте я что-нибудь
попишу для приличия. Если мы с вами будем говорить о рекурсии именно в таком виде,
ну не знаю, там скажу, что АТ от N равняется 3Т от N пополам, к примеру, плюс, там не знаю,
ТТ от N. То есть смотрите, каждый раз я должен прибавлять вот это самое ТТ от N и как-то с ним
жить, что-то с ним делать. Что я делаю здесь? Я на самом деле буду строить следующим образом. Вот на
этом месте я буду делать цен действий. Плюсом к этому всему у меня появляется 3 ребенка. Эти
три ребенка сколько действий делают? ЦН пополам. Ну смотрите, они же тоже работают за ТТ от N.
Ну то есть ТТ от N пополам чему? Она равна 3Т от N на 4, плюс ТТ от N пополам. Правильно? Ну вот
она. А так как я ограничил все ТТ от N с константой С, то я могу везде писать С. Правильно? Потому что я
ж функцию говорю, что для любых. И вот в какой-то момент вот это вот все спустится до каких-то
элементарных вещей. Ну там работающих, к примеру, за ТТ от единички. Ну и так далее. И что такое
будет общее время работы ТТ от N? Это нужно просуммировать вот это все. Все верно. Да. Какая? Вот это?
Ну это то же самое, только для N пополам. Для того, чтобы показать, что вот тут ТТ от N пополам,
С от N пополам. Ну я могу сказать, что тут дальше продолжение будет СН на 4. У каждого будет опять
Понятно, что я сделал? Смотри, у меня есть вот такая рекуррента. Она зависит от N пополам. Значит,
я буду рассматривать следующий от N пополам. Для нее я буду рассматривать следующий от N пополам.
И так далее. Согласен? Вот, поэтому здесь N пополам. Вот у тебя ТТ от N пополам. Конечно,
константы это все съест. Ну первые константы, особенно. Потому что ну ТТ от N пополам это то
же самое, что ТТ от N. Но так как я говорю про определенную константу С, то лучше писать вот
так. Вот. И тогда в этом случае я смотрю, я как бы, что должен делать? Я смотрю, что вот на первом
уровне у меня здесь СН. На втором уровне сколько? 3 СН пополам. На третьем уровне сколько будет?
9 четвертых. 9 четвертых СН пополам. Неправда. Это рекурсивно так задано. У вас рекуррента такая,
что у вас зависимость здесь N от N пополам, плюс выполнение действий ТТ от N. На каждом шаге.
Сорри, да. Все верно. Она одинаковая. Ну как бы, мы в каком смысле рассуждаем? Мы же когда
говорим, что у нас ТТ от N, мы можем сказать, ну какая-то там функция F от N, можем сказать,
что F от N меньше, чем СН, правильно? Согласен? Ну если я скажу, что это F от N пополам, то это
СН пополам. Я про ту же, одну и ту же константу. Вот. Потому что иначе бы ТТ от N. Ну единственное,
что, ну как бы эти N должны быть какие? Большие достаточно. Ну и считается таким, чтобы это все
таки симпатически верно работало. Но это не более того. Вот, мы каждый раз это считаем, и у нас
получается вот такое вот восхитительное дерево. Интересное дерево, но интересное дерево. А до какого-то
момента это будет продолжаться, там уже станет это от единички. В какой момент станет это от единички?
Когда мы спустимся с вами вниз на логарифм N по основанию 3. Ой, два. Соря. Количество,
количество 3, а это 2. Да. Мы уменьшаем все время в два раза. Вот. Ну а дальше мы должны сделать сумму ряда.
Вот это? Ну представь следующее. Это строчка, но если убрать коэффициент 3, то это будет очень
похоже на так называемый мёртвый сорт. Не то что так называемый, а действительно мёртвый сорт. Что под этим
подразумевается? У тебя есть два массивчика половинчатых. Ну, к примеру. У тебя есть раз массивчик из N
пополам элементов и два массива из N пополам элементов. Давайте потише. Отлично. А представь
следующее. Они отсортированы между собой. Ну, то есть этот верх и этот верх. Тебе нужно получить из этого всего
массив из N элементов, который тоже будет отсортирован. За сколько времени ты это сложишь?
Ты должен по элементу насмотреть здесь и здесь. Какой меньше, тот сюда и класть. Согласен? Вот. Сколько
раз элементов ты так пройдешь? N. Получается вот это то самое тетто от N. Плюс два t от N пополам.
Потому что как-то я же эти отсортировал. Согласен? Плюс еще тетто от N, потому что я их смёржу.
Но это количество действий на данном шаге. Сколько я потратил времени на данном шаге?
Тебе не нравится, что я складываю с множеством? Это некоторая функция. Здесь воспринимается,
что это некоторая функция оттуда. То есть я должен N элементов сюда переложить. Я считаю,
что это произойдет асимптатически за тетто от N. Там есть какое-то конкретное число, грубо говоря,
но я смотреть на него не буду. Я буду смотреть именно тетто от N. Асимптатически. Это некоторая
функция, которая лежит в этом множестве. Так понятнее? А как тебя зовут, подскажешь? Саша.
Что-то я сегодня только Сашу спрашиваю. Так, да. На C от N. В принципе, в какой-то момент можно,
но что такое C? Можно так попробовать сделать. Это не спорю. Но есть проблема такая, более глобальная.
Если у тебя количество элементов четное, то можешь одно количество делать. Если не четное,
то другое. Тетто от N все это в себя взбирает. Ну да, плюс-минус один, грубо говоря,
а здесь же ты когда конкретно напишешь, это может быть немного проблемно. Привыкайте к тете и к
о большому. Окей, и дальше мы все это складываем. Я вам сейчас покажу пример немного на другой
рекурренте. Вот, а еще я вам покажу, я забыл в прошлый раз сказать, что такое знание алгоритмов.
Знание алгоритмов это вот это. Кто знает, что это? Так, какая? Правда. Алгоритмы по строению
Это самая важная книга по алгоритмам в принципе, которая рекомендует вообще все, всегда. Написана
достаточно нетривиальным языком, я бы сказал. Это книга Кормана. Там на самом деле четыре автора,
но по факту книга Кормана. В ней если что, сейчас скажу, 1300 страничек. Вот, написанных достаточно
небольшим шерифтом, если вы думаете. Частично я беру материалы отсюда, частично нет, но в том
суть, что здесь по сути лежит все. Вот все, что вам будут рассказывать, вот почти в глобальном масштабе
будет здесь. Единственное, там есть некоторые исключения, например там, не знаю, какие-то вещи,
которые мы вам объясняем, они даны как упражнения. Вот, и вы должны сами подумать, как это сделать.
В общем, в глобальном виде оно здесь, все остальное описано, можно посмотреть всегда, поэтому всем
рекомендую, если что, ну не прикупиться. В библиотеке, по-моему, она существует, ну либо взять хотя бы
электронную версию, чтобы если что у вас было. Если, ну вы можете попробовать это взять, да. Можете
посмотреть, что это вообще такое. Это фундаментальный труд. Что-то все закашли резко. Ужас. Видимо,
вам очень не нравится и вы пытаетесь испугнуть эту книгу. Нет, она вас будет преследовать. Так вот,
вернемся к дереву рекурсии. Что там происходит и что мы делаем. Я здесь взял немного другой
пример. Пример действительности из того же Кормана. Тут даже будут картиночки из Кормана.
Возьмем, потому что рисовать в презентации все эти деревья мне, честно, было категорически
сложно, поэтому я просто взял это для фоточки. Возьмем такую рекурсию. t от n равно 3t n делить на
4. Плюс t от n квадрат. А мы возьмем 3t n делить на 4 плюс t от n квадрат. Что в этом случае делать?
Да. Я вам привел алгоритм, пример, для вот этой вот штуки. На три? Ну три кучки мердж.
n делить на три, n делить на три, n делить на три. Давайте еще раз. Эти массивы были сформированы
самостоятельно. Мы пока на них не смотрим. Для того, чтобы сюда положить элементик,
друзья, чтобы первый элемент положить, ты должен сравнить отсюда, 2 отсюда, 3 отсюда и
переложить. Согласен? На каждый из этих элементов я трачу раз, ну там, даже взять так, раз, два,
два сравнения плюс перекладывание. Там три действия. Я таких действий делаю n. Суммарно их
получается 3t n. Если бы мы не смотрели на массивы, то почему, нам уже даны ассортированные массивы,
почему мы тогда прибавляем еще 3t n пополам на их ассортировку? А, вот здесь? Ну здесь n на 3.
3t n пополам? Господи, прости, я взял просто рекурренту, друзья. Нет какого-то, прям как
какого-то сакрального, сакрального здесь смысла. Потому что я точно знаю, что это t,
t, t, t сильнее всегда. Все просто. Давайте посмотрим на дерево рекурсии, вот то рекуррент,
которое у нас было. Давайте я сейчас запишу, на всякий случай, чтобы вы не путались со всеми
остальными. Вот, а давайте я сейчас перепишу. Это 3t n делить, что там, на 4,
плюс тета от n квадрат. Вот я сейчас рассматриваю эту рекурренту. И что-то я с ней делаю. Смотрите,
первое дерево рекурсии. Ну, если мы возьмем первые элементики, то у меня будет cn квадрат,
tt n делить на 4. Ну, к примеру, что там n делить на 4, оно уже пришло к своему апогее. А если мы скажем,
что нет, не пришло, тогда мы еще больше развернем в этом случае количество действий. Вот. А по поводу
вопроса с точки зрения питона, почему мы не посчитаем и просто не умножим. Вопрос следующий,
вот у тебя есть 3 массива. Это 3 разных массива. Как ты каждый из них умножишь?
Ну, типа ты для каждого из них выполняешь какие-то действия. Вот. Мы продолжаем это
рекурсивное дерево и получаем вот такой вот его вид. Красиво, красиво. Я говорю, мне было,
правда, честно признаюсь. Вот. На первом действии это cn квадрат. Почему? Потому что тут tt от
n квадрат. На вторых, там уже идет cn делить на 4 в квадрате количество действий. Поэтому здесь
мы можем сложить вот эти три штуки, получу 3 шестнадцатых cn квадрат. Дальше получу квадрат
этих вещей, то есть 3 шестнадцатых в квадрате cn квадрат и так далее. То есть то же самое,
что здесь. Здесь было 3 вторых, 9 четвертых и так далее. Согласны? Что это такое? Вот это вот.
1, ага, действительность. Да, это геометрическая прогрессия. Как-то с ней нужно жить. На последнем
уровне, я надеюсь вы понимаете почему, tt от n в степени логарифм 3 по основанию 4. Понятно?
Но мы каждый раз увеличиваем в 3 раза, вниз мы делаем логарифм n делить на 4 действия. Вот и все.
Поэтому у нас такое количество. Давайте все это суммировать, смотреть что получается. Красиво
выглядит. Здесь не хватает знака суммы почему-то. Грустная история, то есть тут лимиты написаны,
а знака суммы не хватает. Такой забавный, конечно, забавный вид. Ладно, я потом это перепишу так,
чтобы вам было красиво. Да. Спасибо. Тут уж извините, я это пишу в ночи, иногда могу ошибаться.
За русский язык не ручаюсь, правда. У меня было 80 баллов по-русскому, простите, 8 стадий. Ваше
время я бы... Ладно, я бы поступил. Все было хорошо, у меня был бы вы. Так вот, если мы возьмем это tt от n,
вот у нас есть какая-то огромная сумма. Это сумма геометрического ряда плюс некоторое тета,
которое получилось из нижнего уровня. Давайте смотреть, что мы сделаем. Мы суммируем от нуля
до логариев n-1 по основанию 4, 3 шестнадцатых степени на cn квадрат. Мы получаем вот такую
геометрическую прогрессию. Круто, классно, мы умеем считать эту геометрическую прогрессию,
сумма убывающей геометрической прогрессии, достаточно понятно. Правда? Чудно. Мы это получаем. Такие
классно, круто. А что делать дальше? Что с этим делать вообще? Оно выглядит неприятно и непонятно в
итоге. Это n в степени логарифма ограничения или cn квадрат. Поэтому здесь надо применить просто
следующее. У нас есть сумма бесконечной геометрической прогрессии. Если я добавлю хвост к своей прогрессии,
ничего не изменится, только увеличится. Поэтому я поставлю знак меньше, строго меньше, и получу с вами,
что у меня есть бесконечная геометрическая прогрессия, поэтому я могу просто написать 1
делить на 1 минус 3 шестнадцатых cn квадрат. Красиво? Красиво. Это мы с вами и используем здесь.
Таким образом, мы получим точное число шестнадцатых тринадцатых cn квадрат,
а плюс это от n в степени какой-то логарифм, ну какая-то константа. Эта константа явно меньше
квадрата. Правильно, правильно. Поэтому это все o от n квадрат. То есть, если мы получили с вами
такую рекурриенту, то все это работает за o от n квадрат. А теперь, смотрите, я скажу,
что это работает за t от n квадрат. Почему? Да, можно это просто снизу ограничить, причем не просто,
ну даже 3 шестнадцатых не обязательно, вот t от n квадрат. Ну все, снизу она ограничена
точно, потому что вот эта сумма что-то дает. Еще раз. Почему? Нет, мы не забивали. Вот это cn
квадрат, 3 шестнадцатых cn квадрат, это все от это. Это все идет от это. Еще раз,
смотрите на это дерево. Видите, первое действие, которое требует вот корень,
который там есть, написано cn квадрат. Этот cn квадрат получился отсюда, а дальше у него есть
3 ребенка, которые от n не четвертые, значит они cn на 4. Вот, и так далее. То есть, вот такое тоже
бывает. Поэтому здесь, да, в действительности, если мы с вами рассмотрим, то здесь не просто
у от n квадрат, а t от n квадрат. Красиво-красиво, то есть вот это слагаемое в итоге нам ничего не
испортило. Ага, да. Нет, это конечно. Там по-разному, смотря какие тут коэффициенты будут еще. Вот,
к примеру, здесь вот 3n пополам. Смотрите, здесь какая прогрессия? Неубывающая. Мы просто так
не ограничим. Нужно думать, что делать. Да. Смотрите, на последнем уровне сколько элементов? Вот там
вот везде t от единички. Ну, один элемент какой-то. С ним нужно понять, сколько таких элементов. Ну,
мы вниз спустились сколько раз? Логарифм n по 4, а каждый раз количество детей увеличилось в 3.
Ну вот, твое количество это n в степени, логарифм 3 делить на 4. Ой, господи, 3 по основанию 4.
Так, хорошо. Давайте так, начнем с простого. У нас есть дерево. Сколько находится на этом уровне?
Это нулевой уровень, первый, второй. Два в степени. Вот так находится здесь. Здесь у нас 3 в степени логарифм.
N по основанию 4. Поменять можем? Извините, на выражение лица было бесценно. Количество,
сколько этих элементов? Почему мы можем вот это взять и поменять вот эту тройку с четверкой?
Свойство логарифма существует, правда? Так, какой момент мне из этого объяснить? Давай ты
подойдешь после, я тебе покажу свойство логарифма, хорошо? Ты смотришь на меня очень недоверчиво. Мне страшно.
Смотрите, да, это действительность, но есть несколько свойств у логарифма,
чего как можно переносить. Если я здесь поменяю местами, ничего не произойдет.
Еще вопросы есть? Вопросы задавать не бойтесь, все нормально. Здесь было немного про другое просто.
Хорошо. Понятно, как работать с деревом рекурсии. То есть нужно как-то сверху что-то оценивать.
Почему? Непонятно, но вот так. Но количество действий хотя бы понятно, откуда берется. То есть каждый
ряд просуммировали, все, получили нам ответ. Вот это теорема, я ее доказывать вам не буду,
потому что это а, занимает пару страниц 4, б, наверное, не самая полезная теорема в вашей
жизни будет. Вы вряд ли ее доказательства запомните. А? Почитайте. Все включил. Тебе точно.
Смотрите, эта теорема будет без доказательств точно и даже, наверное, не буду ее спрашивать.
Здесь главный принцип-то какой? Пусть у нас есть некоторая рекурсивная формула, что там
t от n равно a, t от n делить на b, плюс f от n. А больше либо равно единице, b строго больше единице.
Потому что если равно единице, тут все совсем просто становится. Вот. f от n просто некоторая
функция. Окей. Теперь смотрите, если f от n это o большое от n в степени логарифм a-epsilon по
основанию b, где epsilon любое, то все хорошо. Важный момент. Здесь опять мы будем применять вот такие
вот свойства с логарифами. Потому что мы переведем немного в другие степени. Н в квадрате, n в кубе,
что-нибудь такое. Тогда в этом случае мы строго можем сказать, что это t от n в степени логарифма
a по основанию b. Это первое. Второе. Это то, что если у нас f от n это θ от какой-то n в степени логарифм
a по основанию b, здесь нет никакого epsilon, ничего не происходит. Тогда здесь t от n это θ от n в
какой-то степени плюс логарифм, умноженный на логарифм. Ну и последнее, это если это омега
большое, то есть снизу ограничено чем-то с plus epsilon. Друзья, пожалуйста, ну либо встаньте,
уйдите, не мешайте, бога ради. Окей. В этом случае добавляются еще дополнительные ограничения на
f. То есть смотрите, во-первых, здесь омега большое, то есть ограничено с ней. Во-вторых,
a на fn делить на b должно быть меньше либо равно, чем cf от n для некоторой константы c, что тоже непонятно,
типа выглядит неприятно. И тогда для всех достаточно больших θ от n это будет то же самое,
что θ от f от n. По факту, что нам показывает эта теорема в общем-то виде? В общем, в виде она
показывает следующее, вот если мы разбиваем с вами и у нас f от n это там o большое от вот этого n в
степени логарифма, то есть оно делит меньше, чем нам нужно, тогда в этом случае мы смотрим лишь
на первую часть. То есть вот это tn делить на b. То есть f не дает сильного вклада. В последнем же
случае f дает сильный вклад и поэтому все от f зависит. В среднем же случае мы говорим,
что оно и оттуда и оттуда и вашим и нашим, поэтому здесь будет серединка такая. Понятно? Не скажу,
что это теорема, типа вот все вы должны вызубрить, запомнить, снижить. Нет, конечно. Это просто вам
на то, чтобы вы чем-то проще делали. Ну все, на сегодня мы с математикой закончили в каком-то
общем виде. Остались ли вопросы к рекуррентам у вас сейчас? В голове держать? Ну это просто вот
в голове ты держишь и все. Ну вот рекурренты, ну надо как-то решить. Ну ты как-то решаешь.
Все достаточно просто. С рекуррентами на самом деле, а вот пока у вас эти два способа и мы
пытаемся с ними как-то жить. Ну что-то с ними делать. Если мы с вами будем говорить про, не знаю там,
вот у нас есть рекурренты, если мы четкое решение рекурренты хотим, тогда в этом случае нам
действительно понадобятся производящие функции, либо характеристическое уравнение, что-нибудь из
этого и с помощью этого решать. Но это не сейчас, потому что это ровно так же, что я вам буду...
Вот про рекурренты. В действительности мы с рекуррентами встретимся с вами в одном из случаев.
Это будет, это будет быстрая сортировка. Там я с вами буду говорить про рекурренту и про то,
что типа вы ее сами будете решать. Я лишь скажу результат. На экзамене я попрошу вас это решить,
но так в общем мы скорее время на это тратить не будем, мы будем говорить о том, что там
происходит. Научить рекурренту решать я вас научу. Подставить я уж думаю вы сможете,
потому что вы знаете, за сколько это работает. Вот. Когда мы с вами прошли вот это все, мы переходим
к действительности блока с алгосами. Так как пока у вас не так много такой базы по плюсам,
мы начинаем с достаточно простых алгоритмов. Но поверьте, мы очень скоро уйдем куда-то в
глубь, потому что всей базы плюсов типа хватит вам, ну, наверное, за первые 5 недель,
это будет достаточно, чтобы реализовать все остальные алгоритмы в каком-то виде. Не скажу,
что хорошо. Просто в каком-то. Так вот. Первое это алгоритм Евклида. Скорее всего вы встречались с
ним в школе. Вам рассказывали, что существует такой Евклид. Он придумал свой алгоритм для
нахождения наибольшего общего делителя. Наибольший общий делитель числа, ну, в принципе,
это тот, на который делится и первое, и второе число. Все достаточно просто. Самый наивный подход
к этому всему, это просто перебрать все числа от первого до минимального из двух чисел и сказать,
ну вот он тогда наш минимальное число. Классно это? Ну нет, это работает слишком долго. Для этого
существует тот самый алгоритм Евклида. Его существует две версии. Первая версия опирается на то,
что наибольший общий делитель ГЦД, если что, это по-английски наибольший общий делитель. Да? Кто
сможет? Правильно. Отлично. Ни в коем случае не пишите, когда вы будете реализовывать нод. Ну вот,
по-английски вы такие, ну я же англичанин. Вот, типа нод. Нет, это неправда, это ГЦД. Все-таки
давайте будем следовать английскому не только в транслите. Так вот, у нас есть наибольший общий
делитель от А и Б, и это означает следующее, что он есть доказательство, что он равен, во-первых,
наибольшему общему делителю от А и Б минус А. Если мы считаем, что без ограничения общности,
то Б больше чем А. Вот, БОО это без ограничения общности. Возможно, вы в мотоне уже с этим
столкнулись. И еще это то же самое, что А, что наибольший общий делитель от А и Б процент А,
то есть взятие остатка. В этом плане мы можем всегда брать и смотреть, что происходит. В какой
момент какой из алгоритмов останавливается. Но если мы вычитанием работаем, то если что-то
станет нулем, если мы говорим с вами про взятие с остатком, то это то же самое, когда что-то станет
нулем, когда один начнет делиться над другой. Это вариант остановки. А рассмотрим первый вариант.
Достаточно просто. Я пишу здесь все-таки ближе к питону. Вам нужно будет все-таки писать на плюсах.
Специально взял другой язык. Псевдокод некрасиво подсвечивается, поэтому уж на питоне.
Так вот, если мы с вами говорим про наибольший общий делитель, в этом случае то, что мы делаем,
что если один больше другого, тогда вычтем из большего меньше. Иначе, наоборот, будем вычитать
до тех пор, пока у нас один не станет равен нулю, и тогда тот, который не равен нулю, становится
нашим наибольшим общим делителем. Но что в этом случае происходит? Один ноль, другой наибольший
общий делитель. Как понять, кого выбрать? Можно заевфать. Типа, если а равно нулю, то надо сказать,
что наибольший общий делитель равен b. Иначе наибольший общий делитель равен a. Это не круто.
Зачем писать много бесполезных строк, когда можно просто взять сумму? Потому что один из них нулевой,
другой не нулевой. Вот этот не нулевой и будет в этой сумме. Понятно? Все просто. Не пытайтесь из
этого сделать что-то вот, нужно строго, как вот вот прям вот сказали, ну если это ноль, то это нет.
Всегда выкручивайтесь из того, что есть. Не пишите много скода, это лень, и вы действительно скоро
в этом привыкнете. Но есть проблема этого алгоритма Евклида. Какая? В том, что в наихудшем случае это
будет долго работать. Возьмем, например, число a равное единичке и b равное десять восьмой. Он
будет из десять восьмой постоянно вычитать единичку. Приятно это, но не очень. Он будет
десять восьмой раз это делать. То, что у вас это произойдет за одну секунду, дай бог. Потому что он
здесь еще и фает, смотрит, вайлом проходит. Некруто. Это не прикольно, поэтому здесь мы вам такое не
советуем. А советуем использовать алгоритм Евклида с остатком. Алгоритм Евклида с остатком выглядит
то же самое, просто вместо минуса процент. Все довольно просто и очевидно. Но это идет из
определения, наибольшего общего делителя. А дальше, когда что-то стало равно нулю, опять возьмем просто
сумму и получим то, что нам необходимо. Хорошо это хорошо, но за сколько же это работает? Вот я вам
здесь написал. А вы понимаете, что здесь написано? А почему? Смотрите, считайте это загадкой Жака
Фреско для вас. Попробуйте дома, погуглите, подумайте, что здесь происходит. В действительности есть
отдельное доказательство на тему того, что в этом случае вам необходимо взять соседние числа
Фибоначчи, и это будет худший случай для N чисел. Ну для какого-то там числа N, грубо говоря. Вот
ближайшие два числа Фибоначчи до этих чисел. И это будет худшее время работы данного алгоритма.
Это первое, что здесь нужно усвоить. Почему это так? Но это связано с самым делом с сетем остатка.
Там можно это представить в необходимом виде. Это раз. Второе, числа Фибоначчи представимы вот
в таком восхитительном виде. 1 делить на корень из 5 на 1 плюс корень из 5 на 2 в степени. Ну вот так они
могут представляться на самом деле. Красиво, но не сказать что. Но что мы из этого можем сказать? Мы
можем посчитать количество действий. Потому что если он будет идти по числу Фибоначчи, он будет
просто по ним спускаться. Вот мы можем здесь понять количество действий. И тогда здесь на самом деле
количество действий, но N, это просто логарифм от ФН. Ну с какой-то там константой. Согласны?
Да. Ну там есть минус один, ну там есть с минусом, там есть один плюс корень из 5, есть один минус.
Оно всегда будет иррационально. Смотрите, это написано асимптотически, как это выглядит. К этому
можно привести то, что у вас есть. То, что вы сказали, это точное число Фибоначчи. Меня не
интересует точно. Меня интересуют асимптотики всегда. Вот. Поэтому для N-ого числа я могу сказать,
что оно такое. Ну в N-ой штуке. И тогда в этом случае я говорю, что если у меня есть FN, то есть я
нахожу наибольший общеделитель для N-ого числа Фибоначчи. N это число само по себе, значит мне
нужно спуститься сильно вниз. Сколько раз я буду спускаться? Ну все достаточно просто,
так как я буду все время вмешаться на один. Я скажу, что N это логарифма FN. А значит,
а в худшем случае время работы вот этого алгоритма, это O от логарифма, от минимума этих двух чисел.
Ты можешь проверить, как работает этот алгоритм на числах Фибоначчи. Да.
На единицу в плане N-1 числа Фибоначчи. Вот. Попробуйте дома, почитайте, подумайте,
что здесь происходит. Теперь поговорим про другие алгоритмы. Другой алгоритм у нас это
бинарный поиск по ответу. А что такое бинарный поиск по ответу? Я вам не рассказываю пока просто
про бинарный поиск, потому что вы еще массивы не дошли. Но бинарный поиск по ответу мы же можем
с вами поговорить. Бинарный поиск по ответу это достаточно простая штука. А как она выглядит?
Она выглядит примерно в следующем виде, что у нас есть ответы, мы знаем, в каком диапазоне они
лежат. Там от минус N до плюс N. От минус N до N. И я могу каждый раз, я знаю, что и то, и то
достижимо. И я могу по серединкам ходить, в зависимости от того, осознавая, как рекуррентно все зависит.
Могу смотреть, подходит это под ответ или нет, больше чем какой-то ответ или нет. И в зависимости
от этого смотреть. Самый простой смысл с точки зрения бинарного поиска по ответу – это пояс
корни из числа. Пояс корни из числа можно сделать с помощью бинарного поиска. Ну как сказать? Ну пусть
у меня есть неотрицательное число, там до 10-18. Мне необходимо с точностью 10-10 найти это число.
Самый минимальный корень, какой может быть ноль? Самый максимальный – это 10 в 9, согласны? Чудно. И
тогда я просто буду брать середину и смотреть. Ага, если это число в квадрате в середине будет
больше, чем мое число А, тогда в этом случае я должен пойти влево, то есть уменьшить наше
число. Если оно же больше, тогда я должен пойти вправо. Ой, если серединка меньше в квадрате. Тогда
я иду вправо, потому что мне необходимо увеличить это число. И я здесь буду двигать так называемые
правые и левые границы. Правые и левые границы сначала являются ноль и 10 в 9. То есть тот диапазон,
где оно лежит. И я буду так сужаться, сужаться, сужаться до какого-то момента. На самом деле я буду
здесь сужаться до момента, пока разность этих диапазонов не будет 10 в минус 10. Как только она
будет, я сразу попаду в нужный мне диапазончик. Окей? Реализация здесь достаточно простая. Вот у меня
есть левая, есть правая граница. Я говорю, что пока правая минус левая граница больше, чем 10 в минус
10, тогда я буду брать середину, возводить эту середину в квадрат. Если эта середина больше
либо равна а, тогда мне надо уходить влево. Значит, я говорю, что правую границу я сдвигаю на серединку.
Число. Мне надо найти корень из-за. Да, извините, но здесь суть не изменится. Поэтому так можно найти
корень. Ну и последнее на сегодня, и мы с вами как раз укладываемся в тайминг, и я вас не
передержу. Задача с бешеными ксероксами. Ну, я и так назвал. На самом деле задача просто с принтерами
или с ксероксами, всегда по-разному называют. У нас есть какой-то один листочек. Там есть вообще
красивая преамбула этой задачи, что вот у нас там есть... Да, у нас есть распечатанные условия. Вот
его нужно срочно взять и откопировать, наверное, участников Олимпиада, потому что там изменилась
какая-то задача. Я чуть полегче написал просто. У нас есть один листочек, есть два ксерокса. Один
копирует за х секунд, второй за у. За сколько они вместе могут напечатать ян листов. Что здесь важно
понимать? Ну, первое, очевидно, что если нужно сделать 0 копий, то это займет 0 секунд. Это наша
левая граница. Второе, очевидно, что если взять максимальное количество... Ну вот, у меня есть первый
принтер за 5 секунд, второй за 10. Вот если я во второй принтер загружу копии делать, 10 умножить
на вот это n, то это будет время, которое максимально, в принципе, возможно. Согласны? Вот. Потом мне
нужно искать минимальное. Сейчас будем это пробовать сделать. Как мы это можем сделать? Ну,
во-первых, если нам нужно сделать всего одну копию, то ее достаточно сделать на самом быстром
принтере, ксероксе, извините. Это факт, который нам нужно себе оценить. А дальше, как только я сделаю
эту первую копию, то я положу одну копию в один принтер, а другую в другой. И только с этого момента
я начну все копировать в нужном мне порядке. Значит, там будет n-1 количество копий, сколько мне
нужно сделать, я его буду делать и на x, и на y. И каждый раз я буду что-то смотреть, как это делать.
Ну, какое количество времени здесь это займет? Достаточно просто это понять, на самом деле. Вот,
пусть у меня есть некоторое число. Число в серединке подразумевает то самое время. Сколько сделается
копий, если у меня количество времени t? Но это t делить на x, плюс t делить на y. Согласны?
За это время копий может сделано быть. Если это количество копий будет больше моего n-1,
тогда в этом случае что? Значит, я могу быстрее это сделать. Значит, я пойду влево. Если же я не
могу этого сделать, то есть t делить на x, плюс t делить на y, оно будет меньше, чем n, тогда я должен
увеличить время для данных сероксов, иначе они не успеют. Понятно? Ну, вот так это выглядит.
Все достаточно просто. Есть ли у вас какие-то к этому вопросы? А минимум plus left плюс 1. Смотрите,
потому что right minus left больше единички. В момент, когда мы дойдем до нужного момента,
right будет указывать на нужный нам ответ. Можно писать всегда по-разному. Есть ли у вас к этому
всему вопросы? Неужели вам все сегодня было понятно? Чудно. Если вам все было сегодня понятно,
то я скажу вам такой спойлер. Как вы думаете, чем вы будете на семинарах заниматься?
Правильно, все верно. Будете рассчитывать рекурренты, плюс, возможно, будут некоторые задачки отсюда,
мы их поразбираем еще в каком-то виде. На самом деле, задачки, связанные с бинпоиском по ответу,
очень часто будут у вас возникать какие-то рандомные моменты, поэтому вы можете их всегда
найти. И здесь важно всегда понимать, это более такая олимпиадная чуйка, я бы сказал. На этом,
в принципе, сегодня все. Всем большое спасибо, не болейте и хорошего вам вечера!
