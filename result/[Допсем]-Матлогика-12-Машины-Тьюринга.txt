раз мы завершили вопрос теории множеств и начинаем двигаться в сторону новой теории, а именно
теории вычислимости. Как понятно из названия, будет нас интересовать вопрос того, что такое
вычисление. И чтобы задать понятие вычисления, нам нужно построить какую-то математическую модель,
такой математический компьютер. Есть несколько вариантов того, как это делать. Первым из таких
является машина тюринга. Задается на следующим образом. У нас есть sigma, gamma,
множество s большое, s нулевое, s f и дельта. Итак, первое.
Начнем объяснять что и что. Сигма. Дайте так запишу. Конечный алфавит. Все-таки неправильная
запись. Конечный алфавит. Коротко о том, почему вот писать что-то меньше,
чем вот так вот, касательно мощности, некорректно. Вот этот вот знак, это знак
какой-то бесконечно большого часа. Какого-то бесконечно большого часа, то есть это предел.
Что-то шоу очень большое. А мощность, мы помним, это ординалы. Это вот конкретно есть чисто там.
Хорошо, gamma это, конечно, алфавит. Называется такая штука входным алфавитом.
Ходной алфавит. Второе гамма. Тоже конечный алфавит.
Но теперь это называется уже ленточным алфавитом.
Как связаны гамма и сигма. У нас есть следующее правило, что гамма содержит себе сигма.
Причем они не совпадают. В каком смысле? Что есть выделенный символ решетка,
который принадлежит гамма без сигма. Такой символ решетка называется пустым символом.
Дальше. С большое. Это множество состояний.
Я не машина тюринга. Я вот везде дальше буду писать не машина тюринга, а МТ. Сокращение.
Конечное.
Это английского слова states. Состояние. Есть несколько выделенных состояний.
С нулевое. Начальное состояние.
Сф. Final. Завершающие стыни.
То есть у нас есть какой-то компьютер, который умеет начинать работу из состояния с нули,
завершать в некотором состоянии. Но мы помним, что у нас, например, есть функция. У нас есть
функция. Она действует следующим образом. А есть предикат. Который действует из МН множество лжи и
правды. И эти два понятия на самом деле друг другу переводятся. Поэтому, ровно так же,
как мы функцию можем переделать предикат, точно так же мы можем переводить обычные машины тюринга
в такие, назовем их предикатные машины тюринга, у которых место завершающего состояния можно
называть там терминальным, финальным. Есть еще и вместо как раз завершающего состояния есть
состояние SA и SR. А от слова accepted, R от слова rejected. То есть у нас accepted это принимающее
состояние. То, что мапится на истину. А rejected то, что отвергающее состояние. То есть у нас здесь ложь.
Хорошо. Так, это мы дали. Последнее осталось, самый трудный объект, это Delta. Delta это функция
переходов. Начнем. У нас есть Delta. Из чего, куда она действует. Delta берет в себя некоторое
состояние. И символ ленты. После чего она возвращает нам новое состояние. Новый символ
ленты и использует еще 3 дополнительных символа. L это движение влево, N это остаться на месте, R это
движение вправо. На самом деле вместо LNR мы можем писать произвольные вещи. Это просто вопрос
формализации. Это математическая модель, нужно еще сказать как это все интерпретировать. У нас есть
некоторая лента, бесконечная в обе стороны. Эта лента стоит из ячейка. То есть своего рода
что-то изоморфное целым числом. Мы можем, мы на этой ленте имеем какие-то символы в каждой ячейке.
Символы этой ячейки это элементы гамма. То есть своего рода у нас есть что? У нас есть некоторое
отображение из Z в гамма. Последовательность каждому числу мы замапили какой-то символ. И причем
у нас есть условия про входной афавит. То есть на самом деле входные данные это не вся лента.
По большей части на ленте там записан какой-нибудь мусор. Чтобы гарантированно вход занимал не весь
мусор, а какое-то определенное слово, мы сразу требуем наличия вот этого вот пустого символа.
На самом деле пустой символ мы это интерпретируем. Это может быть не пустой символ, а там какой-нибудь
мусор. Там у нас памяти компьютера тоже хранится везде. Вот у нас везде в гамме мусор,
но где-то у нас есть входные данные. Вот у нас кусок входных данных. Здесь все лежит в сигне.
Также у нас есть что-то вида,
скажу, считывающей головки, как в жестком диске. В жестком диске у нас есть головка, сам диск
крутится и читается информация. Вот у нас точно так же здесь есть где-то считывающая головка.
Она сейчас находится на какой-то ячейке. И у нас вся машина живет на состояниях.
Вот здесь у нас сейчас какое-то
состояние идет. Хорошо, это так мы сама передадим. И что умеет делать машина? Машина умеет выполнять
шаги. Один шаг это применение функции перехода. То есть если у нас есть вот например такое состояние,
такой символ, вот с гамма, то мы можем сменить на следующее состояние, записать, заменить,
то есть символ на какую-то гамму и выполнить одно из действий. Переместиться в ячейку влево,
вправо или не перемещаться. Это интерпретация этой модели. На самом деле, если мы посмотрим,
уже сама по себе математическая модель, она достаточно. Нам не нужны никакие ленты,
в принципе даже просто наличие головки. Это то, что мы себе придумали. Не обязательно наличие
какой-то головки. Модель это излишняя штука. Машина как работает? Давайте скажем, что такое.
У нас есть понятие конфигурации.
Конфигурация машины тюринга. Конфигурация машины тюринга это что-то вида снимок всего с
всей машины. Какое у нее состояние? Конкретное максимально цельное состояние общей машины
тюринга. Оно себя должно включать. Понятно, что оно будет включать, например, с состояния. Дальше оно
должно включать что-то, что мы делали раньше. А то, что делали раньше, мы можем сохранить,
например, при помощи записи слова. Мы же работаем как? Что машина принимает на вход какое-то
слово и дальше работает. Машина прочитала какую-то часть слова. Это история до.
И также машина
должна прочитать еще слово when. Это вариант того, как записывается стройка. И в задании
будет следующее. Задание будет в формировке вид следующий, что у нас есть некоторое у, дальше с,
дальше идет в, но причем в мы дробим следующим образом. В равняется некоторый символ сима,
конкатенция, давайте на v'. То есть мы дополнительно здесь слово дробим,
еще выделяем символ. Тут тут sigma и v'. Зачем это делают? Это то, что было раньше. Это история.
Тогда значит сейчас мы находимся на вот этом вот выделенном символе sigma. То есть как бы
вот эту головку указывать вот сюда. Это будущее, то что мы должны будем где-то там в будущем
определить. Хорошо. На самом деле вот это лишь всего лишь расписано слово when.
Тогда что такое в принципе вычисления? У нас есть конфигурации, у нас есть некоторые
конфигурации и мы можем по ним перемещаться. Давайте скажем как можем перемещаться. Я вот
буду переводить таким. У нас есть s1, у, давайте выделим символ sigma, v' и есть другое состояние,
t''v'. В каком случае мы можем переместиться от одной конфигурации в другую? То есть
изменить состояние общей машины. Как-то поменять ее. Если выполнено следующее, что дельта от s' у,
сейчас os s sigma равняется t. Сейчас скажу. Тут будет сложнее сказать.
Давайте я пока t, я сделаю uv, не uv, я сделаю a. Давайте o1 sigma n, t1 tn. Можно переместиться в t,
sigma 1 sigma n, t1 tn. Если мы заменим sigma на tau и останемся на месте. То есть что мы сказали?
Вот у нас есть сейчас некоторое состояние машины s. Мы можем это состояние заменить на состояние t,
если мы должны будем обработать символ sigma. У нас действительно есть символ sigma. Тогда мы
заменяем состояние s на состояние t, заменяем символ и при этом не сдвигаемся по слову.
Это вот да, мы начинаем строить такое отношение, что помним, был у нас что-то уводимость,
теперь у нас-то достижимость. Дальше у нас есть s sigma 1 sigma n sigma tau 1 tau n. Мы аналогично
сможем сменить состояние на t, но только теперь обработаем случай сдвига налево. Случай сдвига
налево, теперь мы n-1 sigma n tau 1 tau n. То есть что произошло? У нас есть функция переходов. Она
приняла в себе состояние s и символ sigma. В результате она нам отдала состояние t символ
tau, но сказала, что сдвинется налево. Это мы сделали. У нас s-s sigma sigma меняется на t. Символ,
который был sigma, поменялся на символ tau, но теперь у нас первым стал не tau, а тот,
который был левее. Вот у нас она сдвинулась налево. Как бы мы слово перекинули один символ
в право. Симметрично этому будет правило перехода из конфигурации. Следующий
в конфигурацию, когда мы... жух. Сдвинемся сюда.
S sigma tau и сдвиг вправо. S есть, sigma есть. Поменяли на t, заменили символ,
но только теперь, так как R, мы сдвинули запятую вправо. L сдвинули запятую влево,
R сдвинули запятую вправо. Всё. Таким образом мы сказали переход по конфигурациям. Дальше
делается стандартный трюк с таким действием. У нас есть конфигурация. Давайте скажем,
что c множество конфигураций. То, что сейчас мы построили, вот, некоторые такой штопор,
то штопор есть не что иное, как под множество c квадрат. Штопор это отношение. Ну, отношение
уже мы понимаем, что в некотором смысле нам его недостаточно. Например, мы можем перейти от
одной конфигурации к другой, потом от второй к третьей, и тогда значит, что мы можем от первой
перейти к третьей. Или там, почему мы, находясь в одной ситуации, не можем достичь другой.
Поэтому проворачиваем, сейчас, проворачиваем фишку с тем, чтобы, давайте так, возьму,
по-пажамистски напишу, что штопор теперь берется рефлексивное и транзитивное
замыкание вот этого штопора.
Можно сказать, что давайте там сделаем что-то типа, здесь навесим там нулевой. Что бы не было,
то теперь у нас вот на основе таких вот базовых переходов, мы смогли распространить, получить
цепочки. То есть, теперь у нас есть что-то типа цепочек вычислений. Здесь есть какая-то конфигурация,
другая, третья, пятая, четвертая. Как-нибудь так. У нас есть там переходы по конфигурациям,
и теперь у нас есть возможность при помощи этого штопора переходить из этой точки сразу вот,
сюда или сюда. Здесь же у нас действует. По сути, здесь это есть элементарные переходы по функции
перехода. Здесь же у нас замыкание это все. Зачем нам нужно такое замыкание? По сути,
теперь у нас есть понимание того, что есть вычисление. Вычисление, опять же там в кавычках,
это последовательность переходов по конфигурациям.
Давайте так скажу. Удовлетворяя вот этим вот штопором. Почему я сейчас сказал штопор,
а не там штопор нулевой? Потому что это в некотором смысле чуть более общим. Вот,
например, когда мы рассматриваем какие-нибудь простые алгоритмы, даже не просто рассматриваем,
вот курс алгоритма, там мы не смотрим на какие-то уж очень элементарные операции. На уровне даже
самого компьютера уже там операция на самом деле сложнее. Мы оперируем там уже достаточно
высокоуровневыми абстракциями. Мы можем сложить два числа, на самом деле сложение двух чисел это
ну не типа hop и сложились. Сложение-то уже там много себе подшагов включает, что у нас есть.
Ну там, например, когда мы строим, ну разбираем, проверяем на правильность, последовательность
скобок. Мы там же не говорим, что вот там мы создали стэк в нем, что-то там создали ноду в нее,
положили, переставили указатель, мы говорим, что ну просто вот типа push в стэк, потом pop из
стэка. Это уже более крупные такие высокоуровневые операции, которые под собой скрывают очень много
других операций. И вот подобным образом я говорю, что мы в качестве вот этих вот элементарных
переходов берем не единичные атомарные шаги, а мы можем уже брать какие-то более сложные
комбинированные шаги и смотреть это с разных уровней абстракции.
Хорошо. Дальше, давайте прежде чем дальше, может кто-то есть вообще в принципе вопросы по тому,
как работает машина тюринга, в чем, какой смысл этой всей математической абстракции,
как она ложится на практику. Но видимо ни у кого нет. Тогда пойдем дальше.
А куда мы пойдем? Мы пойдем в функции, а именно,
рассмотрим функции. Будем рассматривать не оба какие функции, а конкретно из натуральных,
числа в натуральные. Почему мы рассматриваем именно такие функции, там не больше? Потому что,
вот если функции будут действовать из чего-то большего, то как нам например записать это все
на ленте? Все натуральные числа мы можем спокойно перекодировать в числа на этой ленте,
некоторые символы в этой ленте. Если мы возьмем произвольное действительное число. Мы знаем,
что например произвольные действительные числа настолько сложны, что большую часть действительных
чисел мы даже не знаем. Мы даже не представляем, что это просто, там что-то. И представить их уже
просто на уровне каких-то там десятичных знаков мы не можем. Мы помним, что для иррациональных
чисел у нас есть бесконечная, непериодическая десятичная запись. Мы не можем представить это
в виде какого-то деления. Потому что если мы ограничились там условно этими алгебраическими
числами, то алгебраические числа мы можем более-менее как-то явно записать. Записав их,
мы можем интерпретировать. Соответственно, их мы можем вогнать в N в силу равномочности. Там
как-то перекодировать. Концидентный мы уже не можем, поэтому рассматриваем что-то более простое.
Начнем это делать.
Так, есть некоторая функция из N в N. Мы называем ее вычислимой.
Вычислимой.
Называется такая функция F из N в N, что существует
машина тюринга. Давайте я буду называть ее Mio от X. Что Mio от X равняется F
от X. Что для любого N, принадлежащего N, выполняется, что
машина тюринга Mio от N...
Не так. Вот так вот лучше будет.
Что я записал?
У нас есть натуральные числа. У нас есть машина тюринга Mio, у которой есть некоторый входной
алфавит. Соответственно, мы должны уметь как-то переводить натуральные числа в слова, а именно
элементы сигмы со звездой. Делать мы это можем при помощи некоторого кодирования от энкода.
Отображение из N в сигмы со звездой. И получается, у нас есть машина тюринга. Она принимает
в себя некоторый вход. Это будет означать следующее, что у нас машина тюринга приняла
некоторые слова, его обработала и запустила. Но есть одно но. Почему у нас здесь не гамма со
звездой, а некоторая более другая конструкция? Потому что гамма со звездой это множество слов
конечных. У нас же машина тюринга работает как? У нас есть вот такая вот фигуринка и на ней
нож живет. Но это абстракция. Это вот именно что абстракция, что у нас бесконечная обе стороны
лента. В реальности же здесь нигде никакой ленту у нас не зашито. Поэтому мы можем спокойно здесь
писать и работать со словами. Как бы реальности у нас как бы вот в описании модели у нас бесконечная
обе стороны. Но по факту у нас конечность. Эффективно конечна. Единственный способ как мы
можем использовать эту бесконечность просто бесконечно шагать в один из концов. Но в таком
случае просто машина тюринга не завершается, поэтому, поэтому ничего. Ну и я здесь записал,
что у нас есть машина тюринга, у нас есть некоторое закодированное значение числа n и после себя
нас ставит тоже какое-то закодированное значение от FATN. Как мы понимаем, что у нас вход,
что у нас выход. То есть у нас есть последовательность конфигурации. Машина тюринга это вот
переход по конфигурациям. У нас есть конфигурация изначально нулевая, стартовая там, я назову это input,
в нашем случае там закодированное значение числа n и ничего. Слово Epsilon.
Верну здесь sigma в силу того, что мы поняли, что это некая излишняя абстрактность. Здесь sigma
достаточно. Вот у нас здесь есть жух и дальше мы начинаем работать. Хотя сейчас скажу,
я сделаю все-таки здесь гамму, я объясню, зачем я его обратно верну чуть позже. Мы начинаем
переходить по конфигурациям как-то и достигаем следующей конфигурации.
S final. Дальше здесь какое-то слово U, здесь какое-то слово V.
Жух. Тогда результатом машины тюринга мы положим вот этот Uv. То есть все то,
что осталось от работы, это ее выход. SF это конец вычислений. Так вот, на самом же деле мы можем
как-то это скажу. Мы можем как-то вот все эти закодированные штуки на самом деле также и
в результате преобразования получить вот например там что-то типа просто все стереть.
Тогда нам нужно будет то, что вывод это то, что мы все стерли. И вот как раз здесь именно
поэтому я верну обратно гамму. В дальнейшем мы не будем явно писать, что там происходит
перекодирование. Будем просто писать, что есть некоторые машины тюринга U и что U от N равняется
F от N. Понимая, что на самом деле вот здесь вот мы как-то закодировали в терминах слов над
гамма, а это то, что осталось после работы машины тюринга, закодированные тоже в терминах
афавита гамма. Возможно да, сейчас я начинаю, тут слишком много формализма, но мне кажется,
для того чтобы понимать в чем вся соль вот это вот байды, нужно чуть повозиться с этим.
Так вот, как мы вообще понимаем, что машины тюринга у нас функция не определена. Функция
не определена на каком значении, то есть у нее нет ответа. И в случае вот таком,
что перекодирование. Мы вот перекодировали вход, запустили машины тюринга M, у нас начали
вертеться конфигурации, но мы понимаем, что у нас из некоторой конфигурации, в которой машины
тюринга будет зайти в какой-то бесконечный цикл или там она просто пойдет в бесконечность,
у нее никогда не найдется состояния доступного из начальной конфигурации, в котором будет
в качестве состояния иметься SF. То есть у нас буквально не существует,
я скажу, то есть буквально не существует значения функции. Хорошо. Если у нас есть
понятие вычислимости, мы можем смотреть, как вычислимость функции связана с некоторыми множествами.
У нас множество можно, например, определять некоторой характеристической функцией. Вот оказывается,
что если характеристическая функция множества вычислима, то такое множество разрешено называется.
Ну вот, запишем это. Определение разрешимым называется такое множество,
что существует машина тюринга, которая по элементу множества,
просто по заданному элементу скажет, принадлежит ли он нарасту или нет.
Принадлежит ли он множеству или нет, это означает, что мы имеем дело с предикатом машины тюринга.
Принадлежит это значит, мы можем достичь состояния конфигурации с состоянием
с accepted, а если не принадлежит, мы можем достичь конфигурации со состоянием с rejected.
Если мы попытаемся чуть ослабить, казалось бы, свойства хорошо разрешимости,
значит мы можем точно определить по каждому элементу. А что если мы не будем точно говорить,
а просто перечислим все элементы. Перечислим называется такое множество,
что существует машины тюринга, его перечисляющие. Все просто.
Ко перечислимо. В принципе приставка ко говорит о том, что следующее свойство
выполняется для дополнения. Дополнение перечислено. Какие у нас есть критерии разрешимости?
Первые критерии это то, про что я начал. Что характеристическая функция
фи хи от м от элемента а равняется
1 если а принадлежит м и 0 если а не принадлежит м. И она должна быть вычислима.
Второе это то, что называется теоремой поста. И формулируется она следующим образом.
М разрешима равносима тому, что м тире перечислима и ко перечислима. Это что мы имеем
про разрешимость? Про перечислимость мы имеем более грустное свойство.
Первое это аналог, что сделается характеристической функцией. Надо ее как-то испортить. Сделаем
полухарактеристическую функцию. Как работает полухарактеристическая функция?
1 если а принадлежит м и не определено если а не принадлежит м. То есть наша машина
терлинга никогда не остановится. Дайте я скажу, что пусть f тире учислимая функция. Тогда вторым
будет у нас область значений и область определений. Это они будут перечислимыми.
Это последнее, что нужно найти в теории. Перейдем к задачкам. Первая задачка наверное самая
неприятная за контрольную. Ей я дам наверное красный цвет. Давайте разберем. Если на некого
н больше 10 через н в третьей степени плюс один шаг после начала работы машина посетила не больше
н ячейка. А при этом ледночный алфамин состоит только из этих. Пункт а про то, что машина тюринга
также определяется количеством состояний. Давайте я тебе сказал. Наверное да в машине тюринга я забыл
сказать, что эти все с они лежат из нее. И конфигурация у нас вот это вот это из с. Но
слова понятно. Так вот у нас машина тюринга определяется не только самими словами, но и
состояниями. Если у нас очень много состояний, то в целом нам никто не мешает просто стоять на одной
той же ячейке и менять состояние. От пункта а берем давайте я сделаю е в степени н. Состоянии
и я вполне себе могу просто переходить вот там с нулевое, с первое и так далее до с финального.
Я просто стою на месте и меняю вот эти состояния. Я посещу не больше н. Ячейк. Да, для ночного фита
вообще какое угодно. Поэтому это неверно. Одна и та же конфигурация повторилась второй раз. В чем
особенность? Мы рассматриваем машины тюринга особые, детерминированные. Детерминированный
стих выражается, что мы работаем с отображением. Дельта это отображение. У нас каждый переход он
единственный. То есть если мы дошли докуда, то у нас только один способ найти. И поэтому если мы как-то
вот с конфигурацией, мы там что-то двигались, двигались, двигались, двигались, вернулись саму
себя, у нас нигде не может быть развилок. Это означает, что мы зациклились. Если мы дошли до
нее, то вот тут мы не встретили, здесь нет финального состояния. Если вот здесь нет, то значит все. Мы до него
никогда не дойдем. У нас машина тюринга зашла в бесконечность. Через некоторое время после конфигурации
AQB возникла конфигурация AQBB. Ну и поначалу кажется, что все плохо.
У нас никто, что скажу, но
в общем давайте, да, я покажу сейчас на примере просто, почему это неверно. В целом мне кажется,
до этого просто взять и догадаться с ничего достаточно трудно. У меня есть, в какой-то момент
здесь написан B, а по краям ничего нет. Ну хорошо, я нахожусь вот здесь, к стене Q. Тогда что я делаю?
Я возьму, перейду в новое состояние и сдвинусь вправо. Ужух, я сдвинулся вправо. Я окажусь в состоянии Q2.
Но Q2 будет как работать? Что Q2 и пустой символ, здесь у меня все пустые символы.
Переводит нас в Q1, B и лево. То есть буквально мы заменяем этот символ на B,
сменяем состояние на Q1 и двигаемся влево. Возвращаемся изначально в ту же конфигурацию,
но не в ту же конфигурацию, в то же состояние, на той же ячейке. Но если мы возьмем Q2 и уже в этот раз
символ B, то сюда мы перейдем в финальное состояние. Ну и там пофиг уже. Поэтому
здесь зашито то, что вот на этом состоянии мы действительно повторим то же самое действие,
но никто не говорит нам, что если здесь мы повторили то же самое действие, то его второй раз нам
придется повторить его так же. У нас мог измениться следующий контекст. Здесь B не определено.
Хорошо. Для некоторого N больше 10 через N шагов после конфигурации возникла следующая конфигурация.
Давайте смотреть. У меня есть вот следующая конфигурация. Я сейчас, у меня есть N плюс
один нулей. Я нахожусь вот на первом нуле. Следующий же раз через некоторых шагов у меня
возникла конфигурация. Вот такая вот.
Ну теперь я смотрю сюда. Что? Левый контекст у меня одинаковый. Контекст это то, что находится
от указателя. Левый контекст у меня здесь и здесь одинаков. А что с правым контекстом? Вот у меня
здесь написано, что N шагов. То есть на самом деле у меня за N шагов доступен контекст размера N. Я не
смогу за N шагов перейти на больше, чем N ячеек. То есть у меня буквально доступна только вот
эта вот область. Все, что дальше меня не интересует. Даже можно да вот тут вот здесь так же сказать. Все
дальше это что-то, до чего я не доберусь никогда априори. Так вот здесь. Я нахожусь здесь. У меня вот
он контекст. Все, что дальше оно недостижимо. Поэтому если оно недостижимо, я туда никогда не
попаду. Соответственно эта штука не влияет на мой процесс исполнения. И реальной эффективной
реальной эффективной конфигурации моей машины тюринга будет не все, что справа, все что слева,
а вот то, что доступно за эти N шагов влево-вправо. И оно в точности опять же повторилось. А если я
побывал два раза в одной и той же конфигурации, значит я зациклился. Поэтому здесь ГВН. 23 номер.
Вопрос про всю допределенность и вычислимость функций. Как это связано? Мы помним, что у нас
есть полух... Важно помнить сразу про полухареактивистическую функцию, которая вычислима.
Вот. Она может быть вычислима, может быть нет, но при этом она не определена. То есть у нас уже
есть вычислимые функции, но которые не определены. Ну хорошо. Это неверно. Если функция сюда определена,
то она вычислима. Это вообще неверно. У нас же есть неразрешимые множество. Просто давайте пока
запомним, что есть неразрешимые и есть непричислить. И не будем смотреть пример, так вот... У нас есть
неразрешимые множество. Значит, есть характеристическая функция, которая сюда определена, но она
не вычислена. Если функция having сюда определена и принимает только назначение, то она вычислима.
Но если она всюду определевна и возвращает только на значения, то мы можем явно сказать,
как ее вычислить, просто всегда возвращать это значение. Все. Пунга, если функция f всюду принимает
только одно значение, то она вычислима, даже если всюду не определена. Полухарактеристическая
функция, она бывает не вычислимой. Она принимает только одно значение, но не всюду определена.
Это задание крайне простое. На нем нужно утаить баллы. Второе также тривиальное задание.
Какие свойства эквивалентные? Какие эквивалентные разрешимости?
Смотрите, вам специально даже пометили, что имеется ввиду именно эквивалентность.
Не следование, не из этого следует, а что это эквивалентно. У нас есть два простых способа,
их только два. Это теорема поста про перечислимости, кооперечислимость и
разрешимость характеристической функции. Вычислимость характеристической функции.
Видим, что здесь уже все есть два критерия. Вот это a и g. g теорема поста,
а это про характеристическую функцию. А конечно разрешимость. Конечно же это неверно. Самым
простым способом того, что является разрешимым множеством, это множество натуральных чисел.
Мы просто будем всегда возвращать единицу. Так мы рассматриваем функции Zenven. Мы просто
всегда говорим, что да, всегда лежит. У нас нет натуральных чисел, которые бы не лежали
на натуральных числах. А перечислимо. Неверно. У нас из разрешимости следует перечислимость,
а просто перечислимости недостаточно. Должна быть еще кооперечислимость. Все подножества
a разрешимы. Это тоже неверно. Почему, почему, почему? Ну понятно, что если все подножества a разрешимы,
то и a разрешимы. То есть в одну сторону есть импликация, а в другую сторону. Что правда ли,
что у любого разрешимого множества будет все подножества разрешимы? Нет. Возьмем,
рассмотрим снова n. Обращаю внимание на это множество. На него смотрим, пытаемся его применить.
Вот n разрешима, но у него не все множества разрешимы, поэтому это неверно. Просто потому,
что все подножества, которые мы только рассматриваем, это есть множество натуральных чисел. Мы пока живем
на них. Все иное это либо какие-то там переводы в натуральные числа, либо натуральные числа,
n-ты степени натуральных чисел, множество натуральных чисел. И общая картинка мира у нас должна
быть такая. У нас вот есть все множества. У нас есть среди них, дайте кукурузку. Не хочу,
хочу кукурузку. Вот у меня есть кукурузка. У меня есть в этой кукурузке есть вот такая вот штучка.
Это разрешимы. Ой, это у нас перечислимое множество. У нас есть, помимо перечислимости,
есть, например, вот еще другая штучка. Называется она ко перечислимости.
А в их пересечении лежит штучка, называемая разрешимость. Здесь же лежит у нас неразрешимость.
На самом деле у нас буквально там будет початок. Вот он будет вот таким вот просто дальше жук,
и это будет называться арифметической иерархией, но мы поговорим об этом позже.
Сейчас подправим. К початку мы вернемся еще. Новое задание. Вообще самое простое,
которое только может быть. Наверное, из всего этого, из всей контрольной,
самой простой, его нужно просто сразу делать, садиться и писать. Прям на чистовик и лутать
один балл. Это зелень, это зелень, конечно же. Все очень просто и очень эффективно для набора баллов.
Два разрешимых множества. Докажите, что такое множество разрешимы. Что значит доказать,
что разрешимость? Значит, нам нужно сконструировать характеристическую функцию. Конструируем.
Говорим, что вот это вот множество от элемента m равняется. Что равняется у нас? Да, у нас
программирование. Что мы делаем? Мы делаем for int и равняется 0. У нас 0 натуральное число,
не забываем про это. И не превосходит m. Плюс плюс и. For int иод равняется 0. Иод не превосходит m.
Плюс плюс иод. То есть что я хочу сделать? Я хочу просто перебрать все пары и проверить
само число. То есть я беру такую штуку и я проверяю.
У нас из-за разрешимости есть характеристические функции a и b.
И от i и от b от iод. То если i степень iод,
равняется m, то я пишу нормальный код и возвращаю сразу к идика.
То есть буквально что я сделал? Я прошелся от нуля до этого числа и проверяю, что если у меня
вот это вот i и b лежат в этом множестве, то если их... Ладно, тут реально нужно делать if a. Тут нужно
исправлять код. If i степень iod равняется равняется m, то вот тогда я сделаю return
through. А вот почему не получится возвращать? Потому что да, это если вот все проверки не прошли,
только тогда false. И вот если у меня ничего не вышло, ни один for не вышел, я такой... Ну ладно,
значит я все проверил, я такой return false. А единственный случай с нулем. Вот что если я подам 0?
Если я подам 0, то 0 равняется 1. А вот 0 в степени 1 равняется уже 0. Поэтому отдельно тут нужно
помнить, что нужно обрабатывать 0. Но я не буду писать типа как подправить код, чтобы он проверил 0.
Ну там как мне проверить, что 0 лежит в таком множестве? Он лежит в множестве тогда и только
тогда, когда в a есть 0 и в b есть что-то кроме 0. Ну то есть b не пусто и там не 0. Ну просто
дополнительно мы form здесь посмотрели кейс для 0. Последний номер 26. Мы уходим в перерыв.
Так, сейчас напишу.
Да, не забываем его. Так, вот сюда я вставлю задачу. Вот эта задача уже более сложная.
Она более сложная. Я помещу ее желтой. Что происходит? Первый от нас будут прояснить в процессе решения,
почему любой знак разложения можно вычислить. Ну не знак вообще, а цифру имеется в виду. Так,
чисто придеремся к формулировке. Если нам сказано вспомнить формулу Тейлора,
ну давайте вспомним формулу Тейлора. Там формула Тейлора это что? Я лично ее не особо помню,
что это у нас есть ряд iot x iot от iota равного 0 до плюс бесконечности. И у нас там есть как-то
коэффициенты iota. Что такое по определению такой ряд? Это есть предел ряда от iota равному 0 до iota
большой iota и степень iota. Но что такое предел? Предел у нас как задает? Что я назову, пусть это будет
там сумма. Тогда что для любого iot больше 0 существует такое iota большое, что для любого iota
больше либо равного n выполняется, что разница по модру чем iota от 0 до iota большого iota x iota
minus s не превосходит ipsum. В нашем случае s это sin n. То есть у нас мы можем задать конечные суммы
приближения sin. Если мы хотим получить там n и знак, то тогда давайте возьмем число в степени 10
минус n. Давайте я возьму запас mn плюс 2. Это я задам ipsum. Тогда в силу того, что я смогу по
определению предела найти такое iota большое, то на n-том разряде будет верное число.
Это мы пояснили, почему можно получить. Хорошо, если теперь мы знаем, что это можно получить,
нам теперь нужно просто рассказать, как перечислить множество sin a, зная a. У нас
есть некоторый перечислятор элементов множества a. Тут важное замечание. Обратимся к этому коду.
Смотрите, у меня везде здесь i и конечная граница. У меня нигде нет for i из натуральных чисел. Это
строго запрещено. Как только вы записали в разрешимости такую штуку, вы получили ноль баллов.
Нельзя так. Нельзя вот так. Потому что a может быть как раз точностью счетным. Что это значит?
Мой алгоритм будет работать следующим образом. Он пойдет по всем элементам из a. По всем элементам из
a нельзя идти. Их счетное число. У нас алгоритм может не закончиться. Мы просто будем ходить, ходить,
ходить и так не пройдем. Например, если не принадлежит. Мы все будем пытаться обойти,
но мы так в итоге и не обойдемся. А в случае с перечислением, наша задача просто перечислить.
Мы можем бесконечно перечислять. Если элементы бесконечно, то у нас не остается ничего иного,
кроме как перечислять бесконечно. Вот это мы и будем делать. Берем что? У нас
нам нужно будет перебирать последовательность и часть с удовеченным разложением. Нам нужно
будет получать как-то последовательность элементов из разложения синуса и проверять, что она лежит в a.
Ну то есть берем, делаем что? Первый псевходокод будет такой. For int i в натуральных. Давайте так скажу
for i от као натуральных. Делаем следующее. If синус n, который мы можем приблизить. Мы знаем
вот за какое-то конечное число шагов. Здесь конечная сумма, конечное число шагов мы можем
высчитать. С йод по i равняется там, скажем, просто йод и дополнительно нам нужно будет запустить
перечисление a. У нас есть перечислятор, соответственно мы тоже запустим перечислять. Это
равняется a, то выводим эту, там типа, что там, system out println a.
Вот сейчас скажу, это таких x, что последовательность.
А, даже проще, мы просто будем перебирать такие, мы будем делать вывод из этого.
У нас есть его построитель записи, берёмся и поёт.
А теперь важное но. Как нам уметь вот это вот всё защитить перечисление? Мы имеем возможность
перечислять только n. Действительно, 1, 2, 3, 4. А здесь мы перечисляем на n, на n, на a. Такое слабо
возможно. Хорошо, давайте рассмотрим два случая. А у нас может быть конечно, тогда у нас на самом
деле перечисление идёт всё равно по n на n, но n на n на там какой-нибудь там ограниченное множество,
поэтому на нём можно забить. Либо бесконечно, точнее счётно, тогда у нас перечисление уже
на декардовом кубе. Что в таком случае делать? В таком случае нужно будет явно указать следующую
штуку. Так как пусть c из n вычислимая в обе стороны бекцы. У нас она существует,
там из лекции. Ну или даже просто мы там рассматриваем, что у нас есть явный алгоритм,
как нам пронумеровать все элементы табицы. Так вот, если у нас такая штука существует,
то мы можем сделать следующие. Тогда существует phi, которое по n вернёт нам вот такую штуку.
Но если мы можем занумеровать n квадрат, то тогда нам ничего не стоит, ещё раз применяв там psi,
занумеровать куб. И в принципе любую степень. То существует уже супер функция,
я его назову кси от n, которая действует иначе. Она берёт натуральное число и возвращает вот такую
пару. У нас либо n конечную, тогда нам ничего не хватит там дополнительно бекции перевести. А если
там бесконечно, у нас всё равно это может перевестись там какой-то бекцией. Так что никакого
проблемы перевести, никаких проблем перевести phi в кси нет. И теперь вот этот вот весь страшный
бок мы заменяем на и по натуральном, давайте n по натуральном, а дальше и от а равняется кси от n.
Кси приняла, вернула нам три аргумента, мы с помощью их получили. Всё, так мы это всё вывели.
В целом, я на этом всё. Если есть вопросы, готов ответить.
Видимо вопросов нет, тогда всё, всем спасибо.
С вами был Игорь Негода.
