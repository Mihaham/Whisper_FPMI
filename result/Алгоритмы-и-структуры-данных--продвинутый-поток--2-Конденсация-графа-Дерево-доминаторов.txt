Но, действительно, тема у нас, оказывается, сложная.
Но сложная, потому что в прошлый раз мы изучили,
как искать мосты, как искать точки сочинения, и что
самое страшное – компоненты рёберной и вершинной двусвязности.
Вот, да, технология оказалась нетривиальной, но сегодня
мы попробуем её ещё и апгрейдить.
Но потому что давайте вспомним, как мы искали компоненты
рёберной двусвязности.
Искали мы их очень просто.
Мы запустили ДФС.
ДФС привёл нас к тому, что у нас теперь появилось
дерево ДФС.
У нас есть вот такие рёбра дерева ДФС, а также все остальные.
Но самое главное для нас, что выяснилось, что все
компоненты рёберной двусвязности, как множество вершин, они
образуют какие-то, ну, то, что мы называем, связанные
под деревья.
Вот, ну, как-то вот так это устроено.
Да, я ещё не рисовал там всех рёбер, то есть вот как-то
вот так, вот где-то, точно, вот, ну, может быть, как-то
вот так и вот так.
Вот.
И задача у нас сводилась к тому, чтобы научиться
понимать, какая вершина является корнем своей компоненты
рёберной двусвязности.
Помните, было такое, да?
То есть, если в это поверить, то, в общем-то, всё, что нам
оставалось – это, действительно, добавлять эти вершины в
стэк, а потом на выходе из ДФС говорить, если вершина
первая в своей компоненте, то давайте из стэка всё
до неё включительно достанем.
Ой.
Вот, было дело, помните?
Вот.
Что такое?
Вот.
Соответственно.
Вот, ну, в принципе, более того, компоненты вершины
двусвязности мы нашли также.
Только с той оговоркой, что компонент вершины двусвязности
– это множество рёбер.
И надо было определять уже в своей компоненте не первую
вершину, а первое ребро.
Ну вот, значит, сегодня мы попробуем, ну, даже не
попробуем, а просто найдём компоненты сильной связности
и найдём их внезапно абсолютно тем же методом.
Хотя, казалось бы, так, ладно, киловечку мы всё-таки
уберём, а то прыгнет ещё.
Так.
Вот.
Значит, давайте вспомним.
Потому что, конечно, чем у нас отличаются ДФС в
ориентированном графе от ДФС в неориентированном
графе.
Так, что такое лишние ребра?
Да.
Потому что мы помним, что какие у нас ребра бывают.
У нас теоретически бывают, помимо ребер дерева ДФС,
будут обратные ребра.
То есть, ребра, которые соединяют предка с потомком.
У нас бывают прямые ребра, которые соединяют потомка
с предком.
Но мы знаем, что в неориентированном графе это одно и то же.
Поэтому обычно мы считаем только, что у нас есть обратные
ребра.
И есть перекрёстные ребра.
Так.
Да, у нас есть снова перекрёстные ребра, которые не ведут
ни в предка, ни в потомка, ни наоборот.
Но только маленькая проблема, что в неориентированном
графе их не существует.
Оказывается.
Не будем сейчас передоказывать.
Скажем лишь другую проблему.
Проблема в том, что в ориентированном графе всё это есть.
И более того, обратные ребра и прямые ребра – это уже
теперь принципиальная разница.
То есть, теперь у нас эти ребра есть.
Единственная оговорочка, конечно, что у нас не совсем
произвольная ребра.
А есть, собственно, какой-нибудь маленький приятный факт,
который говорит нам о том, что в перекрёстном ребре
УВ оказывается, что тайм-ин от У заведомо больше, чем
тайм-ин от В.
Для интуиции напоминаю, что ДФС мы обычно запускаем
так, что мы как будто всех детей обходим именно в порядке
слева-направо.
Но это просто кисть обозначения.
Итак, ну теперь посмотрим, как же нам искать компоненты
сильной связности.
Ну, чтобы найти компоненты сильной связности, надо,
конечно, узнать, а что это такое вообще?
Что такое сильная связность?
Да, ну здесь действительно просто, ну давайте уже там
формально напишем, что пришло время изучать, что мы говорим,
что в ориентированном графе, значит, мы сегодня живём
в ориентированном графе, то есть в ориентированном
графе говорим, что У, там что вершины У и В сильно связаны,
если что, если что, ну да, если, ну или можно по-другому
написать, от У до В есть путь и от В до У есть путь.
И тут, в чём первые шаги, которые тут надо сделать,
становятся лёгкими, потому что первая, конечно, теорема,
можно даже её теоремой назвать, хотя по сложности это, конечно,
не теорема, но по важности соответственно.
Значит, теорема звучит так, что сильная связанность
отношений и эквивалентности, то есть такое у нас третий
из наших великих лозунгов.
Вот, значит, сильная связанность, отношение, эквивалентность.
В чём, в отличие от предыдущих случаев, доказательство
этого факта практически самоочевидно.
Потому что в прошлый раз, да, в прошлый раз мы немножко
страдали от транзитивности, но в этот раз транзитивность
тоже сама очевидна.
Вот, радость, радость.
Вот, ну, собственно, халява, в общем, на этом и заканчивается.
Ну, значит, и так.
Ладно, общая технология, конечно, можно написать и
так, потому что как у нас работает общая технология.
Давайте так, кодик тут напишем, как он тут выглядит.
Значит, пишем void, там, как всегда, dfs от викшины v.
Так, ну, давайте вспоминать, что мы должны сделать.
Так, ну, во-первых, конечно, покрасить вершину v в серый
цвет, который мы называем гордым именем edfs-gray.
Ой, надо было рыжим, а, нет, не надо.
Так, что мы ещё должны сделать?
Конечно, конечно.
Да, таймы на v равно, ну, вот, ну, да, current time++, да, current
time++.
Так, ну, и, конечно, не забыть функцию uptime, которая у нас
тоже в каком-то виде будет.
Uptime равно, ну, нет.
А вот здесь мы живём немножко по-другому.
Ну, согласно тому, как мы определяли uptime в прошлый
раз, uptime у нас здесь оказался плюс бесконечностью.
Ну, потому что, да, напомним, у нас что такое uptime?
То есть обычно uptime в неориентированном графе говорилось так.
Мы хотим взять вершину, спуститься в какую-то вершину
в её поддереве, там, среди выбрития потомка, и из этого
потомка подняться вверх по обратному ребру.
Нас заинтересовало, в насколько меньше таймы мы таким образом
можем попасть.
Поэтому, по умолчанию, то есть, оказывается, что
если из вашего поддерева не торчат обратных ребер,
то тогда у вас это может быть просто плюс бесконечности.
Вот, да, ну, да, для наших целей, конечно, можно было
и таймы нам инициализировать, но определение у нас было
такое.
Ну вот, так, значит, uptime сделали, ну, а теперь пришло
время побегать по детям.
Так, как мы бегаем по детям?
Так, как мы называем детей?
Нет, как мы называем детей?
Так, сейчас, нет, просто, как вы, нет, я их вообще
люблю называть, но как бы, как вы в прошлый раз их
называли?
Чего?
Ту?
Мы реально их ту называли?
Нет, по-моему, нет, главное, кто-то смотрел, потому
что, дайте, что меня приятно удивило, как что в предыдущей
лекции было 380 просмотров.
Сам в шоке, нет, да, весь потоп, причем каждый посмотрел
где-то там раз по десять.
Ну, мне тоже понравилось, так, а в этом дело, нет,
я два или один, нет, я только один, я вот сегодня посмотрел
только вот.
Так, ладно, поехали, перебираем, ну ладно, давайте, ну ладно,
перебираем, так сказать, потенциальных детей, но
это еще не дети.
Так, ну здесь уже, наверное, придется различать уже
все возможные случаи, там прямые ребра, обратные
ребра, перекрестные ребра и, конечно, их величество
ребра дерева DFS.
Чего?
Так, вот, кстати, теперь еще одна маленькая приятность,
у нас теперь не надо рассматривать ребр в предках.
Да, ребра ориентированы, поэтому если ребро ведет
в предках, то это не то ребро, к которому мы пришли, его
надо отдельно рассмотреть.
Да, поэтому, ура, пока все халявно, прям все дорога
устилается розами и лилиями.
Так, значит, что же у нас, поэтому пишем, ну вот как
всегда, ну давайте, ладно, не будем свечки, так, ой,
а может, свечки из-за моего, без, ну да, так, так, что
напишем?
Врасти, о господи, не, ну мы не настолько, это того,
да.
Ну, да, да, да, когда-нибудь, да, да, да, да, значит, свеч
от coloratoo, давайте, coloratoo, значит, пишем, так, ну давайте
черноработчий вариант, значит, case edfs white, так, есть у нас
цвет белый, то, что мы делаем, так, ну начинаем с того,
что dfs, конечно, активно запускается от вершины
u, так, конечно же, так, uptime, наверное, надо проапдейтить,
так, так, uptime, ну тут мы надеемся, что тоже когда-нибудь
в будущем будет оператор min равно, да, uptime от v, uptime
от u, радость, так, ой, мы что-то самое главное забыли, мы
забыли добавить вершину в stack, это самое важное,
значит, смотрите, так, так, uptime вроде про апдейтили,
чтобы это не было, и что мы теперь делаем, так, а, ну
и все, в общем-то, в общем-то, в этом месте вроде как больше
ничего не делаем, так, да, не забываем написать
бряк, так, дальше, так, нет, следующий номер нашей
программы мы будем писать рыженьким, так, потому что
дальше у нас идет обратное ребро, обратное ребро идентифицируется
очень просто, потому что если вершина, как несложно
догадаться по маркеру, у нас серая, ну как всегда,
ну у нас в прошлый раз уже было, что мы серый режим
обозначали, да, ну да, да, о господи, а в геоме есть
серые вершины, ладно, так, значит, dfs grey, так, что в
случае делать, ну, наверное, конечно, написать, что, да,
крайне логично, на самом деле было бы, наверное,
uptime от v, min равно uptime, да, на этот раз только не uptime,
а, конечно, time in, да, совершенно верно, совершенно верно,
time in от u, ой, что-то не помещается, что, маркер толстый, что
так, давайте, вот так вот сделаем, так, min равно time in,
time in от u, вот, вот теперь хорошо, и, конечно, не забыть
бряк, вот, бряк, так, какие у нас еще есть варианты, а у нас,
собственно, вариантов, ну, как сказать, вариантов-то,
в общем-то, по цветам-то вариантов, в общем-то, и нет
особо, но по типу ребер есть, у нас есть прямые ребра
и есть перекрестные ребра, ну, давайте напишем эти
варианты, значит, case, что делать, если у нас, да, e dfs black,
да, а у нас нет зеленого цвета, нет, погодите, а вот нет,
проблема в том, что, проблема в том, что, как бы, если ребро
идет уже в черную вершину, то это может быть как зеленое
ребро, так и синее ребро, ну, то есть, прямое-то, в прямом
ребре тоже это будет черная вершина, вот, и это тыт мы
напишем, собственно, внутри этого кейса, да, нет, пока
нет проблем, пока проблема в том, что мы хотим отличить
прямое ребро от перекрестного, они, это вот, оба этих типа
ребра подходят под вот этот вот цвет, поэтому, кстати,
теперь вопрос, как в этом предположении отличить,
кстати, прямое ребро от перекрестного, да, да, значит, если, ну да,
давай так, если таймин или наоборот, если таймин
от У оказался меньше нас, а мы-то В, да, это не тривиально,
но мы-то В, так, то, то мы должны что-то сделать, вот.
Нет, нет, почему, смотрите, синий, синий это означает,
что эта вершина оказалась нашим потомком деревья
DFS, это означает, что мы в нее вошли, как бы, ну, вошли
и вышли, но значит, вошли мы в нее позже, чем в себя,
да, то есть, да, вот этот случай, да, то есть, так,
поэтому, да, это у нас синий будет случай, и мы его обозначим
вот так, то есть, вот тут что-то надо сделать, и тут
надо что-то сделать, вот так, ладно, давайте даже
я вот так сделаю, вот так, и вот так, вот, то есть, тут
придется делать, так, и что-то еще надо сделать,
так, да, свитч на этом заканчивается, и, в общем-то, кажется, вся
обработка на этом тоже заканчивается, так, давайте,
вот где-то вот здесь, ой, сколько скобочек красиво,
так, не поместилось, ну, ничего, значит, делается
тогда это так, значит, это мы, значит, переносим вот
сюда, потому что, что мы, вот, что мы по окончании
делаем, ну, во-первых, мы говорим, что color от v равно
ze dfs black, и, в конце, конечно, говорим, что, если у нас
оказалось, что v корень своей компоненты сильной связности,
то тогда, что мы делаем, тогда мы, соответственно,
говорим, что у нас есть вектор int comp, значит, ну, и делаем
наш его величество do while, то есть, do, соответственно,
comp.pushback от st.top, st.pop, ну, и все, ну, вот, и делаем
мы это пока не окажется, что у нас comp.back равен v,
вот, ну, и остается только сказать, там, сохранить
comp.css, ну, и все, давай, почему, как раз-то, нет, именно
поэтому мы делаем do while, то есть, мы достаем вершину,
а потом смотрим, а потом после этого выясняем, что,
ой, она равна v, все, на этом do while заканчивается, да,
comp, не st.bar, да, вот, то есть, вот такую технологию примерно
хочется применить, так вот, да, вот, ну, формально говоря,
да, совершенно верно, значит, да, но для начала, конечно,
для этого надо доказать, что можно говорить о понятии
корня ксс, то есть, что нам для этого нужно, то есть,
нам нужно, чтобы, действительно, каждая компонента сильной
связности, с точки зрения dfs, образовывала бы что-то
подобное, но как в этом, ну, вот, но, на самом деле, в
этом не очень сложно убедиться, господи, зачем у нас доску
свистнули, ну, ладно, так, так, значит, смотрите, то
есть, в общем-то, тут ничего такого нету, ну, давайте
просто себе это представим.
Что для этого, что нужно доказать, ну, то есть, что
нужно доказать, хочется доказать, что когда dfs каким-то
образом, значит, войдет в компоненту сильной связности,
то есть, он ее обойдет так, что внутри дерева dfs, такие,
внутри этой компоненты, то есть, дерево dfs индуцирует
такое связанное, просто подвешенное дерево с корнем
вот в этой вершине, в которую мы первые вошли, ровно это
мы и хотим, правда.
Так, ну, как же это доказать, вот, ну, и здесь, на самом
деле, доказывается достаточно просто, потому что начнем
с маленького приятного факта, начнем с того, что, вот, пусть
вот эта вот вершина, это, назовем ее root, это первая
вершина компонентной сильной связности какой-то, в которую
dfs вообще зашел.
Тогда, в тот момент, когда мы ее посетили, замерно,
вот, значит, все остальные вершины еще белые, и более
того, по ним дойти, и более того, чисто по белым вершинам
до них из этой вершины дойти можно.
Следовательно, по лемме о белых путях, мы понимаем,
что эти вершины будут как минимум потомками этой
вершины в дереве dfs, понятно, да?
Ну вот, остается только одно.
Остается только показать, что они будут образовывать
именно связанное под дерево, а не просто они там какие-то
потомки.
Но доказать это тоже достаточно легко, потому что предположим,
что у нас действительно тут оказалось, что мы тут
походили, потом как-то там вышли-вышли-вышли-вышли,
и, то есть, оказался какой-то несвязанный именно под деревом,
то же потомок, который тоже у нас из этой компоненты.
Но с другой стороны, тогда получается странная вещь.
Смотрите, мы знаем, что мы из этой вершины можем
дойти до всех вот этих и прийти вот в эту с одной
стороны, а с другой стороны мы знаем, что из этой вершины
мы каким-то образом можем и сюда прийти, потому что
они тут в одной компоненте сильной связости лежат.
Но на самом деле из этого очевидно, что тогда получается,
что из этих вершин тоже можно до корня добраться.
То есть вывод, что эти вершины тоже в той же самой компоненте
сильной связности лежат.
Понятно, да?
Ну, можно в принципе сформулировать теорему мистическую о
том, что если у вас есть две вершины из одной компоненты
сильной связности и есть какой-то путь между ними
простой, да даже не простой, неважно, то все эти вершины
тоже лежат в этой компоненте сильной связности.
Ну, а тут все просто.
Так что даже тут уже никаких проблем не было, кажется,
в прошлый раз с вершиной двух связностей нам пришлось
повозиться сильно больше.
Нет, ну зачем обратное, ну потому что еще раз, потому
что вот рассмотрим первую вершину, все эти вершины
являются именно потомками в дереве DFS, именно потомками.
Ну вот, то есть дальше все остальное, надо только
доказать, что они тут, что это будет все связано.
Но это следует из того, что если какая-то вершина
в компоненте, то и весь путь по дереву DFS тоже в ней
будет в этой же компоненте, поэтому дерево связано.
Вот, казалось бы, да, казалось бы, все в наших руках, казалось
бы, там все препятствия, которые должны быть вроде
как рассыпаются.
Пока мы не начинаем додумывать вот этот интеллектуальный
момент.
А как же нам определить и высчитывать uptime?
Ну, хотя, казалось бы, давайте подумаем, что такое uptime?
Так, по определению, ну давайте вот напишем, помните,
мы uptime, мы даже его рыженьким писали, помните?
Давайте вспомним, определение, да, что uptime от V.
Это по определению, это минимальный такой time in от U, от U, ладно,
пусть будет от U, такой что, значит, WU это обратное,
обратное ребро и W потомок V, так, так, тут нормально
видно, что я пишу, кстати, а то тогда маркер не идеальный,
вот.
Так, ну в принципе, да, если вот с перекрестными прямыми
ничего не делать, то в общем-то uptime мы ровно в таком виде
и делаем.
Вот, остается только самая малость, остается только
теперь доказать, что, ну нет, теперь вот возникает вопрос,
а как же нам идентифицировать, хорошо, вот тогда uptime мы
вычисляем правильно, ну очевидно, то есть вот, по
крайней мере, по такому определению мы его вычисляем
правильно.
Вот, так, тогда возникает вопрос, как вычислять корень
своей КСС, как понимать, как нам понимать, является
ли В, корнем своей КСС или не является.
Согласен.
Да, в принципе, вот такое ребро никто не отменял.
Более того, на самом деле какая-нибудь типичная компонента
сильной связности вполне может выглядеть и вот таким
вот нехитрым образом.
Вот, вот так вот и давайте, и еще вот куда-нибудь вот
сюда давайте.
Ну вот.
Ну вот.
Ну вот.
Да.
Так, ну в редком смысле, обратное ребро мы уже идентифицировали.
Ну хотелось.
Так, ну хотелось, да.
Только, только тут, тогда тут может быть все еще страшнее,
потому что может она это ведет в перекресты ребро,
в потомках есть еще перекрестное ребро, из которого есть обратное,
из которого там можно ниже пойти в перекресты, из которого
попасть.
Вот желательно.
Ну давайте, смотрите, что хочется, например, хочется
линейный алгоритм.
Да, ну во-первых, так, давайте так, для начала вот это.
Что мы тут хотим?
Как определить, что В является корнем?
Ну конечно, голубая мечта у нас все-таки так и написать,
что если оказалось, что там uptime от В оказался меньше,
чем time in от В, да, ну как бы, как раньше мы говорили,
да, ладно, нет, наоборот, да, вро, вро, вро, да, конечно,
конечно, то есть если он оказался больше либо равен,
тогда мы корнем.
Вот, то есть, ну в принципе, вот, можно написать вот уже
этот алгоритм.
Ну написать-то все что угодно можем, как это она, как это
у нас на заборе и не такое пишут, вот, но теперь давайте
смотреть, попробуем доказать, почему это работает.
Ну, действительно, в смысле, ну вот, и что, ну давайте
я точки сотру, хорошо, все, вот все, ну как бы, это я
просто типа, типа, да, так, то есть, можно написать
кодки, типа, там принц, ребро, перекросное, там, ну возопить,
там типа, ну в CR куда-нибудь, ну, как всегда, если вам
нужно в коде куда-нибудь возопить, то вы это можете
делать в CR и как бы это все нормально будет, ну, то есть,
вы там на это ТЛ, конечно, потратите, но это уже другой
вопрос, вот, ну, собственно, ладно, я думаю, это я, так,
ну, на всякий случай, все ж помнят, да, что если там
написать что-нибудь в CR, то тестирующая система этого
не заметит, да, ну, это дебагал будет очень полезно, потому
что, как бы, тестирующая система, она проверяет
только то, что вы, как бы, в STD out вывели, поэтому,
что вы вывели в STD ER, она не проверяет, поэтому, ну,
это значит, надо ее побить канделябром, если она это
делает, потому что нормальная тестирующая система этого
не делает, вот, это очень удобно, так вот, давайте,
давайте смотреть, почему же это работает, ну, действительно,
давайте посмотрим, что, во-первых, если вершина, ну,
давайте так, ну, во-первых, если uptime оказался меньше
таймына, что это означает, да, то есть, это означает,
что у нас жила была вершина, мы тут могли тут пойти куда-то
вниз и неожиданно подняться по обратному либу в какую-то
вершину V, вот, то есть, в какого-то предочка, в принципе,
да, это означает, что со всеми вот этими предками эта
вершина, очевидно, лежит в одной компоненте сильной
связности, следовательно, вершина V не корень, то есть,
если uptime оказался, то есть, если условие не сработало,
то вершина V действительно не корень, так, а если это
условие сработало, обязательно ли эта вершина корень?
Да, ну, к сожалению, нет и пример, в общем-то, вот,
потому что, то есть, он, то есть, ну, вот, то есть, в принципе,
как бы, ну, как вы доказали, то есть, корень будет
идентифицирован правильно, да, то есть, как бы корень,
действительно, то есть, эта вершина будет идентифицирована
как корень своей компоненты, но проблема в том, что помимо
нее, как корень будет идентифицирован еще кто-то,
например, вот эта вершина, вот, то есть, вполне вероятно,
потому что, видите, у нас, потому что, а как он, в чем
разница, видите, раньше у нас доказательства, да, там
всякие там прореберные двухсвязались, было основано
на том, что из-под дерева вершины мы можем выйти только
через обратное ребро, теперь это неверно, потому что
у нас теперь появились перекресты, вот, то есть,
получается, у нас есть ложное срабатывание, то есть,
ну, вот, то есть, у нас есть ошибка вот в одну сторону,
то есть, есть ошибка, что, то есть, мы не пропустим корни,
но у нас могут быть лишние, что же делать, как же решить
эту проблему?
Мы обтайм определяли, как мы обтаям определяли,
как мы имейшие таймы, которые достигли из-за одного
дерева, заметим, что мы его неправильно считаем,
так, то, как мы его считаем, не соответствует его
определению, сейчас, так, стоп-стоп-стоп, почему,
нет, в этом я не понял, я ничего не понял, обтайм,
по-моему, мы считаем сейчас абсолютно соответствующим
его определению, вот так, ну, а теперь давайте думать,
а как вы его хотим определять?
Вот как минимальная машина с минимальным таймином,
в котором мы можем попасть из данного под дерево?
Так, так, так, так, так, так, так, так, так, так,
то есть, вероятно, сейчас повернемся, с минимальным
таймином, в котором мы можем попасть.
Ну, как сказать, ну, на самом деле, я боюсь, что уже
это, ну, вот, что это тоже завалится, потому что тут
еще есть такая мелкая проблема, потому что я рассмотрю
другой пример, такой тупой пример, который легко
реализовать, давайте я скажу, что у меня будет обратное
ребро или перекрестное, хотя бы, так, ну, вот, тогда
тут вот тоже можно тут написать, что давайте аптайм
от В, там мин равно можно написать, да, таймин от
В, ну, вот, вот, так, нет, смотрите, а что такое?
А в чем, собственно, проблема?
Ну, да, может оказаться, что у нас тут есть какая-то
вот соседняя компонента, вот как-то так это будет,
в которую тоже ведет обратное ребро.
Так, то есть, да, действительно, то есть, это, то есть, тут
оказывается, то есть, конечно, то есть, вот такой случай
мы убрали, то есть, вот такой случай мы убрали, но тогда
оказывается, что и сам корень может уже перестать быть
идентифицирован как корень, потому что у нас, как бы,
из этой компоненты можно выйти, собственно, в какую-нибудь
соседнюю компонент.
Так.
Кажется, что достаточно изменить условия проверки,
что аптаймат, короче, нужно хранить не таймин минимальной
вершины, а, собственно, вершину с минимальным таймином,
вот, и тогда надо бы проверить, что она наша предка просто.
Ну, а если мы предкой перепишем?
Так, если, чтобы проверять, что она предка нам не достаточно,
тогда разве это не старое определение аптайма?
То есть, давайте проверять только предков.
Да, потому что мы будем по пути читать.
По какому пути?
Мы будем пересчитывать таймин, как бы-то мы и прыгаем не по одному левру,
а по, сколько хотим ребер.
Да, только мою нод.
Сейчас.
Мне кажется, мы можем его пересчитывать, потому что у нас ребра зеленые идут справа-налево,
поэтому у нас лево будет сочетано в жизни такое.
Так.
Так, так, так, так, так.
Остала нод.
Нода.
А, проблема в том, что мы пересчитываешься через себя, когда считаем трипратные ребра.
Угу.
Но есть такая проблема, да.
Поэтому просто так не получится.
Так, ну здесь, по крайней мере, да.
Нет, то здесь просто хотелось обратить внимание, что здесь, кажется, наоборот.
Что здесь у нас, может, наоборот, все некорни будут идти, идентифицированы как некорни.
Ну, потому что из любого поддерева внутри компоненты,
как бы, можно уж либо через обратное, либо через перекрестное точно выйти, причем в рамках этой же компоненты.
Правда?
То есть, некорни будут...
То есть, теперь обратно все...
То есть, раньше у нас было все корни идентифицированы как корни,
только могут...
Ну вот, а некорни могут случайно сработать.
Теперь наоборот.
То есть, теперь у нас некорни точно некорни, а вот корни могут сработать, могут нет.
Давайте сделаем бы то и то.
А.
А.
Чего?
Чего можно?
Я говорю, надо.
Пускай у нас есть Uv, вот зеленый, по которому мы сейчас хотим обновиться.
Так.
Тогда давайте посмотрим, у Uv есть какой-то uptime.
Посмотрим на него.
Мы можем как-нибудь записывать вершину, на которую она ссылается, с таким таймином.
Например, в таймин записывать вершину.
Это нужно определить.
Является ли uptime от v, то есть w, является ли w пред... предком...
Если является, то мы обновляем, если не является, то мы ничего не делаем.
У-у-у...
Сейчас.
То есть, мы для каждого...
У нас и вариант, собственно, обновляем, если не является, то мы ничего не делаем.
У-у-у...
Сейчас.
Сейчас.
То есть, мы для каждого...
У нас и вариант, собственно, uptime, это наименьшая по тайминам вершина, в которую мы можем
попасть из данного потеря.
Так.
Но для этого...
Нет, если мы хотим, чтобы uptime, это была наименьшая вершина, в которую мы вообще
можем попасть, то возникает вопрос, как ее пересчитывать.
Ну, вот я предупреждаю, что...
Что не хватает...
Что оставшийся...
Ну, все предыдущее оставить, а зеленое обрабатывать вот так.
Нет, там просто...
Насчет...
Сейчас.
Не, ну как обрабатывать?
Для этой вершины не очень понятно, как это насчитать.
Потому что минимальная вершина по тайминам, куда мы можем попасть, это вот эта вершина.
Только попасть ее надо скакнуть по обратному ребру, прийти вот сюда и пойти сюда.
То есть, как бы пересчет через то, что мы еще не могли не досчитать.
Потому что это обратно...
Это ребро могло, кстати, вести не из этой вершины, а, например, из этой.
То есть...
То есть, вот такая коллизия.
В общем, не работает, правда.
Насчитают первые таймы.
То есть, первый оттайм, второй оттайм, и...
Что такое первый оттайм и второй оттайм?
Первый без зеленой дописки, второй с зеленой допиской.
Так.
Хорошо.
И тогда мы все корни определяем, и все некорни тоже определяем.
Так.
Так.
Не, слушай.
Так, да.
Нет.
Не, слушай, нет.
Даже интересно.
Да, действительно.
Давайте сфотографируем.
Хорошо.
Нет, ну, нет.
Давайте смотреть.
Потому что мало.
Вдруг мы сейчас придумаем алгоритм круче, чем у Тарьяна.
Вот.
Ладно.
Хорошо.
У нас есть рыжий оттайм.
А есть?
Ну, давайте зеленый оттайм.
Оттайм два.
То есть, то же самое.
То же самое.
То же самое.
То же самое или перекрестное.
То же самое.
То же самое.
Так.
Так.
Насчитать его.
Насчитать такой оттайм достаточно понятно.
Насчитываем легко.
Так.
Теперь будет какая-то вопрос.
И что нам предлагается?
Предлагается поставить условие, если рыжий оттайм больше,
чем наш таймин, и зеленый оттайм.
Что?
и зеленый оптайм больше, нет ну тут так тут как бы да то есть заметим что оптайм 2
он заметно кстати более сильный чем оптайм от В, потому что он включает в себя все то же
самое и что-то еще, нет тут как-то да пока проблемы, первый и не второй, и не второй,
то есть если оптайм да ну просто проблема то что то есть любая век, то есть как бы
по обратным ребрам выйти выше нельзя, а по перекрестным можно, ну вот этот случай,
а нет почему куда-то попали, нет мы пытаемся, у нас была технология, мы пытаемся подогнать,
так чтобы остался алгоритм СОВЫ плюс Е, ну да, причем правда, но вот да хочется когда тем
более что тут проблема что может быть перекрестная обратно, там причем не просто перекрестная спуск,
обратная спуск, перекрестная спуск обратно, нет вот нет на самом деле хотеть, хотя на самом деле
можно заметить что все гораздо проще, ну потому что смотрите, заметим что у нас, ну тут на самом
деле замечание тут оказывается более тонкое, значит смотрите на самом деле куда ведут
перекрестные ребра, перекрест, ну да, но смотрите они ведут либо в соседнее поддерево внутри одной
и той же компоненты сильной связности, видно да, либо они ведут в какую-то другую компоненту
сильной связности, пока очевидно, согласен пока К, ну потому что ребро всегда ведет либо в ту же
компоненту сильной связости, либо в другую, да, другой вопрос, что мы не определили, да, понятно,
что мы не определили, мы как бы хотим, но как бы да, но опять смотрите, но фишка такая, да, пока
ничего не сказал, но фишка такая, смотрите, а что это за компоненты сильной связности, другая в
которой может вести перекрестное ребро, ну смотрите, это может быть, ну может быть, смотрите,
что это может быть, это может быть, например потомок, смотрите, вот может быть в принципе вполне
вот такая ситуация, вот например вот как-то так, да, да, нет, так вполне может быть, вот, то есть это
может быть потомок нашей компоненты просто из другой веточки, а может быть даже не потомок,
а какая-то вот видите ранее рассмотренная компонент, но идея оказывается такая, что в идеальном мире,
если бы до этого момента, до момента входа в эту, то есть там скажем до окончания обработки этой
компоненты правильно обрабатываем все вершины, понимаем кто корень и кто нет, то эти компоненты
были бы уже обработаны, то есть мы как бы уже должны были уже и сюда и сюда уже сходить,
идентифицировать и достать их из стек, правда, то есть просто идея такая, да, что, то есть идея будет
такая, что мы сохраняем оптайм, но при этом нам надо отличать, что это вершину мы уже достали из стека,
вот как это какие как наиболее удобным способом это значит пометить,
нет, нет, но да, нет, нет, но да, super black удобнее, да, да, то есть тарьян называет этот цвет фиолетовым,
да, то есть теперь у нас в DFS будет 4 света белый, серый, черный и фиолетовый, логично,
вот значит значит смотрите поэтому пишем значит теперь update значит color от st точка топ
значит теперь у нас равен e dfs purple
вот
да нет нет на полном серьезе в статье такое написано вот
вот значит теперь и теперь оптим надо определить значит и оптим теперь предлагается значит
значит он сохраняется так оптим 2 убираем так что смотрите там у себя если написал кто случайно
вот вот значит поэтому пишем так обратное ребро или перекрестное
ребро ведущие вне фиолетовую вершину
ну перекрестная перекрестная будет вести в черную обратная в серую вот ну можете этот
дипричастный оборот или как-то называется вот соответственно относить именно к перекрестному
ребро так одни причастный оборот да причастный просто причастный господи не я как давно это было
да вот вне фиолетового давно это было как говорится по-русскому там 82 поэтому поэтому
ну ну я утверждаю что да я утверждаю что вот то есть да как теперь это сделать значит ну значит
вот в этом эфе тогда про перекрестное ребро надо еще теперь написать надо вот сюда написать что
есть а нет уже а смотрите дал да обратите внимание уже ничего не надо писать да то есть продал но
правда единственное только что мы фиолетов с фиолетовой вершины не делаем ничего хорошо давайте
давайте да то есть давайте чтобы отметить что теперь этот случай есть да это мы так значит да
мы не забываем так сейчас нет это зря сделал да значит смотрите во-первых надо брякнуться как-то
черная как раз и нужно потому что у нас как раз такие прекрасно и вы ведущих черную вершину
нас интересует так значит теперь дальше пишем кейс едф с перпл ну короче пум-пум все так и
соответственно такой а вот эту скопочку и надо убрать вот а то оставить вот так вот вот да то
есть вот утверждается что в таком экзотическом виде это будет работать значит за 3 но на самом
деле доказательства будет по индукции причем по таймыну
хотя нет по таймин не получил и значит что мы еще можем в него пойти я ну по индукса индукса
нам потребуется чтобы предполагать что там все вот эти компоненты мы уже правильно идентифицированы
эти вершины уже фиолетовая да только индукция даже я попав не по таймыну а по таймалту да мы
его не считаем но как бы понятно он есть то есть тогда смотрите какая действительно идея будет
то есть тогда доказательства звучит так то есть вот у нас есть вот эти вершины тогда но вот то
есть надо показать что эта вершина будет идентифицирована как корень компоненты а все
вот эти вершины как корень компоненты идентифицированы не будут понятно да как же мы это будем доказывать вот
но доказывать так но первых заметим что мы из этой вершины выйдем последними правда то есть мы
в этом дереве мы в нее первый войдем последний выйдем правда но теперь заметим что в нот что
внутри у каждой вершины из вот у каждой по вершины которые не корень внутри ее под дерево то есть
изнутри ее под дерево есть выход по перекрестному ребру или по обратному ребру внука который но
который ведет нас внутрь этой же компоненты правда но если мы предполагаем по индукции что
в чем ведет она нас тут тут важно тут важный момент что перекрестное ребро ну как бы обратное
ребро ведет нас предка вот то есть как бы если из этого под дерево есть обратное ребро ведущие
выше то понятно что уже об тайм будет меньше и будет все в порядке правда вот а если тут вывод
перекрестная то тут важный момент что перекрестное ребро ведет нас в ребро который у которого не
просто таймы меньше но у него таймы и даже таймаут по идее меньше чем все вот это под дерево правда
вот раз уж мы вышли из этого под дерево вот то есть это означает что мы из этой вершины уже
вышли и по предположении индукции уже корректно определили что эта вершина корнем не является
следовать на наутекущий момент является черной ибо но да более того тут никто тут черным не
является поэтому то есть никто тут корнем не был идентифицирован поэтому она пока еще черная
следовательно никто лишний корнем не будет так остается только убедиться в том что корень
компоненты окажется корнем то есть ее об тайм никуда не выйдет но как это доказать ну заметим
что и самой вот этой компоненты у нас все перекрестные ребра могут видеть там перекрестные обратные
ребра там выше не выше никуда то есть они выше никуда не поведут но с другой стороны из этой
компоненты обратные ребра будут вести в какие-то уже ранее обойденные компоненты которые по тому
же предположению индукции уже были идентифицированы вот казалось бы быть все в порядке то есть уже то
есть они то есть то есть они как бы они на момент рассмотрения ребер они были уже фиолетовая да вот
но отсюда собственно и следует что корень будет корректно идентифицирован как корень и собственно
так что вот так что вот оказывается на самом деле вот таким вот образом можно искать компоненты
сильной связности пока пока мы сейчас не сядем его доказывать да мы сейчас посмотрим вот хотя
вот и не за хотя иногда нет иногда бывает кс я вот люблю вот нет нета написать вот так
да потому что видим кстати код в общем-то оказался не сильно сложный ну типа да ой ну
по этой локе да кто-то там предлагал вообще когда-то там просто надо ваше супер шаблонный
дфс написать так от дерева это не дерево это граф в котором мы запустили дфс ну вот так
что вот такая красота так ну что есть ли еще тут какие-то вопросы да нет наверное
чего бесполезно вопрос создавать бесполезно
нет тут все понятно хорошо да но тут конечно да нельзя не упомянуть что конечно да в олимпиады
среде более популярен почему-то другой алгоритм ну там ну как всегда пуши ну как всегда и отчасти
это называется возможно по историческим причинам может быть нет узнаете тут как бывает то
есть иногда иногда бывает так как в моду вошло потому что как бы нет ну не знаю тут не но это
интересно может да нет может действительно когда-то да может когда кто-то прочитал статью
рассказывал это потом кто-то узнал что существует алгоритм двумя дфс ами он рассказ все стали
рассказывать потом с тех пор об этом алгоритме забыли нет у графа нет ну как бы граф и граф есть
граф тут ничего не поделаешь он всегда есть нет ну да нет понятно да но давайте разбираться
потому что да тут то есть это вот назывался алгоритм тарьяна да как вы догадались вот есть
конечно вот то есть выясняется что есть конечно алгоритм косарая да вот то есть он предлагает
я но то есть не что более тривиальная то есть он предлагает запустить из всех вершин дфс
один который будет работать примитивным образом да но вот так и как он будет работать так ну а
первых давайте так он скажет л ст точку push front нет push front нет неправда не так рано рано рано
согласен да значит то есть пишем тут юзет от в равно труда никаких этих цветов этих ваших на
этот раз просто так for int у пум пум граф от в да вот и тут предлагается значит понятно
что если не юзет от у то дфс 1 от у и в конце добавить в какой эту вершину в какой-то список
только добавить ее в начало то есть push front от в вот вот но потом соответственно
а потом неожиданно появляется дфс 2 в котором уже просто видим вершину записываю в компонент
то есть юзет от в равно тру соответственно значит комп точка push back уже по барабану
от в и да но дальше правда тут начинается фишка потому что потому что у мы теперь берем в
реверсинг графе ну тут по классике не юзет от у то дфс 2 так и конечно самое важное как мы эти
дфс запускаем запускаем мы оказывается теперь так то есть во первых юзет точка ассайн как
всегда там на n и false вот значит тут перебираем тупо там for int там в равно от нуля dn-1 значит если
не юзет от в то дфс 1 вот результате такого дфс у нас образовался список лст какой-то
глобальный то есть ну как как у нас называется список в которой можно делать push front ну например
дэк да ну можно но как бы зачем когда у нас есть да потому что давайте что давайте будем считать
что у нас есть вектор вектор int во первых граф и реверсент граф это мы должны вектор графы
реверсент граф и что-то еще ну во первых да и давайте вот вектор int юзет ну можно можно
был но не хочется марачиваться и конечно его величество дэк дэк int лст вот
нет чего чего бы ну летники а ну может не оно по разному можно колор но ладно раз уж мы компоненты
там там по векторам пихом пишем поэтому давайте так нет понятно что да понятно что там олимпиадом
коди чаще там просто как там легче калор и там писать это да ну вот но соответственно если кто-то
да осталось только чтоб ныряли олимпиаде это вообще пригодилось а было все прям ныряли олимпиаде
они там на сборах каких-нибудь гурма о господи ладно так вот значит поехали значит продолжим
значит юзет точка значит опять ассайн ладно там н 0 по барабану и тут давайте 0 тогда писать
так теперь пишем for int в 2.л ст значит берем вершину и говорим что если она не юзет то что
мы делаем то мы говорим что комп точка clear dfs 2 от в и что-то еще а ну и как всегда сохранить
комп как сс вот да ну да вот такой вот датчик такая вот интерпретация лг и да здесь конечно
важно отметить что здесь мы запускаем на прозвернутому графу что такое развернутый
граф это граф в котором это мы взяли исходный граф и внезапно развернули в нем все
рёбра под совершенно внезапно развернули в нем все рёбра вот так знаете что вот уже такой
простой алгоритм действительно на самом деле спокойно ищет компоненты заморачиваться не надо
единственное у него недостаток единственный что он делает 2 dfs а не один нет ну как бы рекурсия
все-таки да но правда что страшнее константа от рекурсии или звать константа от рекурсии или
там подсчеты которые там вторяне это еще вопрос хотя автор я не на самом деле ничего страшного
не считается но то есть как часто в динамике бывает страшно бывает идейно но там нагрузочно
там ничего нет вот то есть там то ли то только там таймы на аптайм а тут этого нет просто что
покрасили то покрасили но теперь стоит столько разобраться а почему это вообще работает
до до а до ася на экзамене спрашивал да что так что без проблем без проблем скажешь слово
тривиально ну ну там аки не значит итак ну давайте смотреть как же это доказывать так ну заметим
что ну дерево да ну в общем-то такая вот структура дфс общем-то никуда не делась вот первые на
самом деле так если рассмотреть первый дфс то в общем-то относительно деревьев дфс вот эти
компоненты все еще те же самые деревья образуют ну да нет ну да вот видите что-то второе
обращаем я что второй дфс мы запускаем запускаем в порядке ну в порядке л ст но в ст мы добавляем
в начало обычно конечно это рассказывается заклинанием вида что мы во втором дфс и мы
запускаемся в порядке выхода первого дфс а вот причем не не в обратном чем в обратном порядке
поэтому и в начало запихивает но с другой стороны теперь заметим что приятно во первых заметим
маленькую приятную вещь начнем вот у каждой компоненты есть корень теперь заметим маленькую
приятную вещь что в каждой компоненте корень это такая вершина в которую дфс первым вошел и
последним вышел поэтому поэтому во первых заметим что когда мы будем бежать потом по этому л ст мы
у каждой компоненты увидим сначала корень а потом все остальное следовательно то есть получается
мы гарантируем что когда мы идем по л ст мы увидели корень и запустили его дфс и по обратным
ребрам уж его компоненту точно обошли правда вот правда единственная недостатка единственная
проблема что помимо этого мы могли обойти что-то еще но с другой стороны верно но утверждается что
то есть очевидным является такое утверждение что каждый запуск дфс а2 он как бы обошел несколько
компонент одну или несколько компонент целиком но пока теоретически мог как мы чуть позже докажем
не мог но утверждается такое ну давайте так рассмотрим самый первый дфс 2 я отражаю следующий
зашел в какую-то компоненту просто зашел да то он обошел ее всю да нет не очевидно что только ее
да ну то нет вопроса тут что именно очевидно просто вот же так если дфс 2 обошел в какую-то
компоненту впервые то этот же дфс 2 обошел ее это полемия белых путях просто очевидно
другой вопрос что это из этого не следует что дфс 2 не мог там за один присест обойти несколько
компонент и тут уже придется немножко подумать то есть такие заметить тут тут надо заметить более
тонкие вещи какие тонкие вещи а вот какие то есть дело в том что но вот какие что какие
же более тонкие вещи придется заметить но первых заметим конечно что если сжать все компоненты
сильно связаны в одну вершину то у нас получится ациклический граф логично да вот но теперь
соответственно очень хочется показать маленькую приятную вещь очень хочется показать то есть на
самом деле все что нам нужно показать это то что если у нас допустим у нас была какая-то были
какие-то две компоненты сильной связности тут был корень и тут бы там тут какая-то компонента
и допустим выяснилось что между ними есть какое-то ребро вот ну просто нет но это не важно нет это по
не важно то есть хочется пока достаточно что если между двумя компонентами есть
ребро то тогда очень хочется сказать что тогда и из этой вершины то есть из этого
корня мы вышли позже чем из этого очень хочется такое сказать если мы вышли из
из этого корня, то мы уже обошли все вершины, достиженные из него.
Ребро между компонентами может быть только перекрёстным, нет?
А нет, оно ещё может быть...
Оно прямым ещё может быть.
Давайте пронумеруем корни.
Ну да.
Если мы вышли из первого, то мы точно уже обошли второй.
Нет, ну в принципе да.
Нет, ну заметим следующее.
Ну давайте так попробуем.
По-разному можно рассуждать.
Рассмотрим момент времени, когда мы вошли в root 1.
Тогда что у нас могло быть с вот этой компонентой?
Тут надо аккуратно, потому что очень хочется сказать,
что она либо была полностью обойдена, либо полностью не обойдена.
Ну вот.
Но это, конечно, может быть не совсем аккуратно.
Там всякое такое могло быть.
Но на самом деле так.
Смотрите.
То есть на самом деле так.
Допустим, мы вошли в эту компоненту.
DFS тут ходил-ходил.
И в какой-то момент захотел пойти по вот этому ребру.
Что могло произойти?
Так, какой эта вершина могла оказаться?
Она могла оказаться в этот момент белой, серой и черной.
Правда?
Так, ну давайте посмотрим.
Если она оказалась белой.
То что тогда?
Ну тогда я утверждаю, что все эти вершины сейчас белые.
Очевидно.
Ну действительно.
Потому что дело в том, что заметим, что из этой вершины до всех этих вершин дойти можно.
Вот.
Нет, а самое главное и наоборот.
Тогда что?
Ну что тут тогда могло произойти?
То есть тогда если вот так вот.
Ну можно идти тогда до корня.
Утверждается, что как минимум корень белый.
Почему?
Ну давайте смотреть.
Хотя давайте посмотрим.
Что вообще могло тут произойти?
Ну могло произойти, что мы идем по этому пути до корня.
И где-то у нас тут неожиданно обнаружилась черная вершина.
А что такое корень?
Если мы попали в первый раз в вершину.
Нет, в смысле корень дерева ДФС.
Может быть он определится в будущем, что это будет корень?
Ну как бы, да.
Если вот полностью рассмотреть ДФС.
То в каждой компоненте он индуцировал такой корень на ребрах дерева ДФС.
Так.
Ну значит если у нас эта вершина белая.
Ну смотрим.
Тогда на этом пути до корня.
И вот допустим образовалась не белая.
Черная она быть не могла.
Ну у нас не бывает такого.
Что у нас в какой-то момент из черной вершины ведет ребро в белую.
Ну просто не бывает такого. Правда?
Ну что могло быть?
Ну вот.
Она конечно могла случайно оказаться серой.
Да.
Но что это означает?
Серая это означает, что она
во-первых, что она просто предок вот этой вершины.
А на самом деле просто предок вот всего этого.
Что такое серая вершина?
Помните, да?
То есть серая это то, что у нас сейчас в стеке лежит.
То есть получается из этой вершины,
на самом деле,
то есть тут как будто вот куда-то ниже,
на самом деле мы вот сюда и придем.
А почему так не бывает?
Ну да.
Нет, тогда это, ну да, то есть это,
отсюда на самом деле автоматически следует,
что вот этот как минимум пути
следует и все это тоже должно быть в одной компоненте.
А почему, кстати?
А, ну потому что, ну вот.
Ну да, потому что мы из корня можем дойти
до сюда и отсюда можем добраться до корня.
Ну там скажем, сюда и так далее.
Да. То есть серая вершина у нас тут
тоже на пути не будет.
Ну следовательно, действительно
все у нас эти, то есть
все у нас тут белое получается.
Ну белое, белое, белое и вообще
в принципе оказывает, даже можно не до корня
идти, а просто тут все вершины белые,
потому что, соответственно, ни серых, ни черных
тут нет. По
абсолютно тем же причинам мы
в общем-то особо не пользовались тем, что это
путь до корня. Вот.
Да. То есть если эта вершина
белая, то тут все белое.
И это означает, что мы прямо сейчас
обойдем эту компоненту.
Да. Ну правда, вот эта вершина
должна оказаться корнем. Но это вполне
может быть такое. То есть это будет скорее вот
какой-то вот такой случай.
То есть мы ее обойдем. И тогда
из этого корня мы выйдем действительно
раньше, чем из этой. Потому что мы ее
обработаем, а из этой мы еще не вышли.
Да. То есть если
она белая, то все в порядке.
То есть действительно все в порядке.
Так. Что еще может быть?
Следующий случай говорит нам о том,
что у нас эта вершина серая.
Ну здесь все гораздо проще. Да,
серая. Ну да. То есть
серая это означает, что действительно
все вот это вот в одной компоненте связности
противоречит.
Ну и если она черная.
Но заметим, что
ну
почему перекрестные теоретически может быть и
прямое какое-нибудь.
Ну вот. Нет, да,
теоретически такое вполне может быть, кстати.
Вот пример.
Вот. Но это даже не важно.
Так. Если она черная.
Так. Если эта вершина черная.
Ну давайте смотреть.
Так.
Ну тогда утверждается, что
вся эта компонента тоже черная.
Ну потому что
мы уже просто выяснили, что
ну потому что, во-первых, да, мы
из этой вершины можем обойти,
просто пройти до всех вершин. Вот как-то вот так,
вот так, вот так. Ну как-то там.
Но заметим, что все тогда вот эти вершины
они белыми быть уже право не имеют.
Следовательно они все
либо серые, либо черные.
Но если у нас тут кто-то серый, значит это опять
одна компонента. Правда?
То есть значит эти все вершины черные,
значит мы эту же компоненту уже когда-то
обошли, и этот корень уже тоже
ну вот и вышли из нее раньше,
чем из этой.
Вот.
То есть смотрите, то есть оказалось следующее.
То есть убедились
мы теперь в следующем.
То есть это означает такое,
что если между двумя компонентами
сильной связности есть ребро,
ведущий из одной компоненты
в другую, то корень
этой компоненты мы встретим
в листе раньше,
чем корень вот этой.
То есть если рассмотреть
именно корни в листе,
то они будут идти в порядке топологической
сортировки конденсации.
Вот.
Какое пафосное словосочетание.
Вот.
Вот.
Ну и вот.
Ну и в общем-то все.
Ну вот.
То есть такое, да, то есть пришлось немножко пострадать.
Но тем не менее.
То есть такое, конечно алгоритм...
То есть такое алгоритм
конечно получился немножко.
То есть просто пишется, но может быть сложно
доказывается.
Предыдущий алгоритм, правда, не скажешь, что он
просто доказывается совсем.
Ну я бы сказал, по уровню
примерно то же самое.
Ну вот.
Но тем не менее вот такой вот
фокус. Так это у нас
касается компонент сильной связности для кого для вот этого нет почему не надо ну а ну хотя ну как
так но на каком-то уровне надо потому что понятия на тему того черные белые что там каких-то ребер
не бывает надо то есть да нам тут не нужно знать что такое обратные перекрестные ребра да
ну то есть такую базу надо то есть да тут не надо знать что черные белые перекрестные как их
обходить вот дай тем более но фиолетовая честно говоря водится только чисто для
чисто в компонентах сильной связности больше их нигде не видел вот нет но просто с другой
стороны тоже конечно интересно что это технология которая но с другой стороны проблема такая к
сожалению для компонент вершины двух связностей мне какого-то там алгоритма который основан
в чем-то подобном неизвестно нет мне кто-то сказал что там по-моему кто-то там рассказывает что
там компоненты вершины двух связностей можно искать там как-то типа найдем точнее сочленение
потом будем там что-то там смотреть то есть это там рассказывает но утверждал что там выизвать
получается какая-то черная магия нет ну-ка ну кто сказал что наоборот там
правда а
LAUGHTER
может но
это sleeper на первых ежеджит вванедь 있을 earliest а во captures не есть некоторые
но дочерние компоненты разбиваются на отрезки по тейнтаутам.
Разбиваются на отрезки по тейнтаутам?
Нет, почему?
По-моему, что вот так? По-моему, нет.
Потому что компоненты никак встроены.
Вот допустим одно дерево компоненты, и тут на нем висит второе.
Ну ладно, вот висит вот так второе.
Хорошо, и как бы понятно.
И тут тейну тайм-аута будет 1, 2, 3, 4.
И тут будет 5, 6, 7, 8, 9, 10.
А потом тут продолжится 11, 12, 13.
Что значит разбивается?
Если у нас на одной точке висит несколько деревьев,
то можно сопоставить эти деревья в некоторые отрезки.
Нет, но в каждой компоненте так не сопоставишь.
Нет, по дереву, конечно, да.
Но не знаю, там не легче ли окажется просто стэком это идентифицировать потом.
Потому что тоже тут...
Нет, ну просто компоненты можно там пройти тем же стэком найти, на самом деле.
Вот, это уже да.
Так, ну ладно, с Тарьяном мы на эту тему не прощаемся.
Потому что дальше у нас возникает такая вещь, как дерево доминаторов.
Так, ладно.
Сейчас.
Нет, только напомните еще раз.
Кто знает, что такое дерево доминаторов?
Ага.
Примерно, да.
Окей, стало чуть больше.
С прошлого раза стало чуть больше, да.
Видел, что это такое дерево доминаторов?
Ага.
Примерно, да.
Окей.
Чуть больше, да.
Видимо, кто-то приехал из Петрозаводска, да.
А у вас там нет?
А может, у вас там были задачи на дерево доминаторов?
Если были, то мы их не знали.
А, а вы на разбор не ходили, да?
Нет, ходили.
Я ходил, не знал.
А, понятно.
Ну да, потому что у тебя все время вот он знает, что дерево доминаторов, а ты нет, да.
Наверное, там на разборе что-то рассказывали, да.
Ну не сейчас, а после перерыва.
А тогда.
Ладно, все, давайте перерыв.
Потому что дерево доминаторов вещь хорошая.
Так, итак, дерево доминаторов.
Как это, да.
Чем оно приятно, что это одна из тех структур данных,
для которых не сложно ответить,
а зачем это вообще надо?
Потому что конкретно в это нот.
Потому что, честно говоря, я впервые
на эту структуру данных наткнулся в книжке про компиляторы.
Да.
То есть там возникло, потому что
что?
Ну вот.
Ну, то есть более эту вольту там.
То есть, потому что там есть там
какие-то, ну там много книжек про компиляторы.
Сейчас какая у меня была конкретно.
Сейчас у меня тут даже записано вроде.
Так.
Так, так, так. Не Таха Уильямс.
Нет, это не то.
О боже, я забыл какая книжка была.
Так.
Ну ладно.
Так.
А, нет, у меня, ну вот.
А, какие стороны? Нет, у меня тут даже записано, да.
То есть, в принципе, да.
В принципе, есть такая вот
книжка внезапно.
Хотя, интересно, это книжка
или, ну Ахо, да.
А, фу, нет, неправильно.
Нет, не та фамилия.
Ульман.
Но там разные есть.
Вот у меня
утверждается, по крайней мере, у меня здесь, что
есть вот такая книжка.
Ахо Ульман. Принципл сомп компайлер дизайн.
Нет, сразу скажу.
Нет, это не ссылка на то. Там
ничего не написано о том, как искать дерево доминаторов.
Там сказано, что оно есть.
Ну вот.
И нужно оно по оптимизации.
Софта по части оптимизации.
Ну, потому что
часто для оптимизации
в компиляторе нужно.
То есть, компиляторе еще желательно понимать,
что, допустим, программа оказалась
вот в этой точке.
Внимание, вопрос.
А вот в этой точке
была ли она
перед этим в этой точке?
Ну, иногда бывает. Могла быть, могла не быть.
Но хочется иногда понимать, что в этой точке
она точно была.
Например.
Или что-нибудь еще
в этом роде.
Ну, это иногда нот.
Но, допустим, очень помогает, что
если вы тут делаете, допустим,
а плюс равно х, и выясняется,
что у вас тут в этой точке написано
х равно 5, то, в принципе,
можно сразу оптимизировать, что вы там здесь,
допустим, а плюс равно 5. Это такой самый тупой пример,
который возникает.
Вот.
То есть, нот.
То есть, иногда такое хочется.
Поэтому в результате нот.
Можете сначала описать, что имеет эта структура
для тех, кто не знает,
чтобы вы понимали примеры?
Нет, это я просто подвожу.
Нет, это я подвожу.
Естественно, я понимаю, что я еще ничего не сказал.
Да. То есть, нам
хочется, но нам хочется ориентироваться,
что если мы пришли в какую-то, что если ваша программа
пришла в какую-то точку, то она там
перед этим заведомо была в какой-то там,
в какой-то точке. А в какой-то могла быть,
а могла не быть.
Приводит нас
к следующему.
Во-первых, мы вводим понятие,
ссылка,
как бы доминатор 3,
то есть статья Тарьяна сразу.
Там Тарьяна и еще одного товарища.
Точнее, наоборот, еще одного товарища и Тарьяна.
Вот.
Ну там по фамилии в другом порядке идут.
Вот.
Как всегда.
Смотрите.
Ну, во-первых, начнем мы с простого определения.
Так.
Смотрите, определение.
Значит,
пусть у нас,
значит, смотрите,
мы будем говорить, что В, Е и Р,
такая тройка,
это граф потока управления.
Ну,
так, я не помню.
Флоу, внезапно флоу граф.
Причем этот флоу, собственно,
к нашим любимым потокам отношения
не имеет.
Вот.
Значит,
если,
значит, смотрите,
во-первых,
ну, В, Е,
это просто ориентированный граф.
Значит,
Р это просто, это какая-то
вершина.
Смотрите,
из Р доступны все вершины.
Тут, знаете,
так иногда этого не хватает во всяких задачах,
что в ориентированном графе нельзя запустить,
не всегда можно запустить ДФС из одной вершины
и обойти все.
Да, вот в ней ориентирован можно,
в ориентированном не всегда.
Ну, вот.
Ну, у нас мы будем рассматривать граф,
в котором можно.
Вот такая красота.
Значит, доступны все вершины.
Что же делать?
А, ну, пока ничего не делать.
Это пока просто определение.
Так вот.
И вот теперь определение.
Значит, вот у нас
в таком графе,
то есть пусть у нас,
значит, В, Е, Р,
это, допустим,
господи, вот, хочется написать
ГПУ, но веська ощущение, что это аббревиатура
по-другому расшифровывается.
А как?
А по-украински да, что ли, или шо?
Ну, мало ли.
Ну, короче, ладно, граф ПУ.
Давайте так.
Вот.
Нет.
Вот.
Так вот.
Значит, будем говорить, что
вершина У
доминирует над В.
Во.
Ну, естественно,
там В, вершина У
доминирует над вершиной В.
Если
любой путь
из
Р, вот того самого Р,
В, В
содержит
Во.
Да, сразу обозначение.
Обозначение
это будет называться У дом В.
Вот. Дом, ну, от слова
dominate.
И здесь все просто.
Вот.
Вот.
Так.
Ну, возникает вопрос.
А может ли быть так, что
на вершине В не доминирует никто?
Р никто не доминирует.
Чего?
Р доминирует самым самым.
Да, ну,
во-первых, да, тут как
кто-то упоминал уже простое число,
так вот, то же самое.
У каждой вершины В есть
две вершины, которые над ней точно доминируют.
Во-первых, она сама, во-вторых,
Р.
Но, в принципе, да, других может
не быть.
А могут...
Чего?
Да, ну, в принципе, да,
но есть тривиальный случай, он же единица,
это когда сам Р.
Но это не очень интересный случай.
Вот.
Значит, лемма, почему-то она у меня
значена как один штрих. Интересно, почему.
Ладно. Ну, давайте, тут написано
почему-то. Наверное, автор думал, писал,
наверное, почему-то. Вот.
Значит, утверждение такое.
Если
У
дом В
и В дом В,
то
ну, короче говоря,
У дом В.
Ну, или В дом У.
Во.
Ну, короче говоря,
то есть если над одной вершины
доминируют сразу две,
то из этих двух вершин
кто-то над кем-то тоже
доминирует.
Ну,
доказательства
на самом деле очень простое.
Рассмотрим
какой-нибудь путь
от Р
до В.
На этом пути
лежат вершины У и В
в каком-то порядке.
Ну, допустим, сначала У, потом В.
Понятно, да?
Тогда
тогда я утверждаю,
что если У
в этом случае У доминирует
над В.
Почему я такое утверждаю?
Да. То есть она не доминирует.
Знаете, что мы тут каким-то вот обходным путем
каким-то вот таким,
понятно, что он может быть, конечно, вот
такой вот, да, но
нет, как мы убедимся, что на самом деле
найдется обходной путь и вот такой
на самом деле, вот прям буквально такой.
Вот.
Ну, суть такая, да,
но в любом случае, если мы каким-то образом в обход
вершины У можем дойти до В,
то мы в обход вершины У тогда можем и до В
дойти противоречия.
Вот. То есть более того,
на самом деле
то есть на самом деле
то есть эту лему
на самом деле можно было бы
на самом деле сформулировать
и даже в более продвинутом
виде. То есть рассмотрим все
доминаторы вершины В.
Вот.
Допустим, все у меня тут доминаторы
У1, У2, У3,
У4 и так далее.
И какой-нибудь там У,
ну, допустим, там К.
Вот.
Тогда, если они идут вот в таком
порядке,
то тогда получается,
что каждый предыдущий доминирует
над всеми следующими.
Логично, да?
То есть более того,
более того,
на самом деле оказывается, что
в принципе получается,
что у У есть такой ближайший
доминатор. То есть это вот тот
доминатор,
который доминирует над В
и над которым доминирует все,
что доминирует над В.
То есть в принципе
тут-то и появляется новое
определение важное.
То есть вот это вот, на самом деле, это равно
аидом от В.
Аидом.
Или непосредственный доминатор.
Сейчас запишу. Смотрите.
Определение.
Пусть у нас вершина В
но корню. Это важно.
Тогда
значит, вершина У
это непосредственный
доминатор.
Сотовенный
непосредственный
доминатор
В.
Если
во-первых, первое, У
доминирует над В.
Второе,
значит, У
не равно В.
И третье, что для любой вершины В
не равный В,
но доминирующий над ним,
оказывается, что В
доминирует и над У тоже.
Обозначение.
Обозначение аидом
от W.
Почему аидом?
Я.
Шо я?
Понятно, аид
непосредственный
доминатор.
Да, I would say that
I means immediate.
Immediate.
Yeah.
Yeah.
I'm not sure, but
something says means that
it is something
about it.
Да.
Нет, С там спокойно.
Ага, там будет
self-dominating there.
Но до этого
мы доживем.
Так это вот у нас аидом.
Мистическое утверждение,
которое мы
будем называть, гордо будем называть
Ремо-1.
Ну ладно, не мы, а итальян, соответственно.
Точнее,
кто-то итальян.
Нет, ну кто-то вы там можете гуглануть там
помылингауэр там фамилии или что-то вот.
Чего?
Лонганьер.
Okay.
Ну вот.
Значит, и так первая
тиремма Лонганьер-Тарьяна
говорит о том, что
для любой
вершины
неравной корню
существует
и единственен
аидом от W.
Вот.
Почему?
Заметим так,
что
существует кто-то,
кто доминирует на W и не она сама.
Это как минимум корень.
А можно даже без этой леммы,
это была такая разминочка.
Среди всех доминаторов W
рассмотрим последнего из них.
Утверждение. Это он.
Во-первых, это он. Во-вторых, очевидно,
никто другой не подходит.
Лемма.
А также, как и тиремма.
Рассмотрим все вершины,
рассмотрим
все вершины, которые доминируют
над W, а во-вторых, рассмотрим
какой-нибудь путь из R до W.
На этом пути лежат, очевидно,
все доминаторы W.
Вот.
Рассмотрим последнего на этом пути.
Очевидно, что
над ним все доминируют.
Значит, он, как аидом,
под аидома подходит, а во-вторых, заметим, что
больше никто не подойдет, как минимум,
потому что вот этот товарищ ни над кем не доминирует.
Ну, просто вот.
Вот.
Поэтому аидом
существует и единственен.
Так вот.
Тогда, соответственно, можно...
Ну, тогда заметим, что если я
введу такое понятие, как
такой граф, как с теми же вершинами,
но с ребрами
вида аидом
от W
до W, да?
То есть там W – это
V без корня.
Ну, вот. То есть я напишу такое следствие.
Это следствие, что
не теорема 2, я надеюсь.
Вот.
Тогда отсюда следует, что
вот это вот,
это дерево.
Я бы сказал даже подвешенное дерево.
Что такое дерево?
Ой, а что это такое-то вообще?
Подвешенное дерево
с корнем в R.
Да.
Ой, начинается.
Нет, это на физике у нас такое.
Что такое волна?
Ну, что такое волна – и так понятно, мы не будем
вводить точного определения, поэтому вместо этого давайте
изучать ее свойства.
Да, да, да.
Ну, волна.
Нет, просто
я на полном серьезе
на некоторые занятия по физике так объясняю.
Волна.
Так вот.
Подвешенное дерево.
Вот.
Но тут все гораздо проще.
Ну, просто говорим, что
ну, скажем так, давайте
в данном случае можно ввести
понятие ориентированное подвешенное дерево.
Это
во-первых так, что если
отменить ориентацию, то получится дерево.
А во-вторых,
а во-вторых,
ребра ориентированы так, что из корня
до всех вершин по этому дереву, по этому графу
можно дойти.
Вот, например, вот так определить дерево.
Нет, в принципе,
в каких-то википедиях там бывало вообще какое-то
жуткое определение, когда там
для каждой вершины объявлялись,
объявлялся там список детей,
гарантировалось отсутствие какой-то зацикленности.
Ну, может быть,
это совсем ближе к истине какой-нибудь
конкретной модели, но не важно.
Вот.
Соответственно,
но здесь у нас получается, что это
подвешенное дерево.
Так, ну, хотя, конечно, чтобы убедиться в том,
что это подвешенное, так, с корнем,
во-первых, вер,
а во-вторых, ну, чтобы убедиться, что дерево,
надо, конечно, желательно убедиться, что это
не зацикливается.
Вот.
Ну, у нас, очевидно, не бывает такого, что там
Вася доминирует над Петей, Петя доминирует над
Колей, а Коля неожиданно доминирует над
Васей, правда?
Ну, это просто отношение частичного корня.
Ну, вот.
Нет, это да, но
для этого надо доказать, что это не так.
Вот.
Нет, ну, как бы в идеале.
Антисимметричность?
Нет, если вдуматься, то очевидно,
потому что если У доминирует над В,
то есть любой путь до В
проходит через У, то рассмотрим этот путь и
обнаружим, что этот путь от
Р до У не проходит через В.
То есть, получается, мораль.
Если У доминирует над В, то В над У
не доминирует. Ну, либо они равны, конечно.
Да, но транзитивность, да, тоже очевидна.
Какой анод?
Три следствия.
Нет, в смысле?
Так мы это следствие доказываем, в смысле.
Ну, зациклов нет.
Но с другой стороны, в каждую вершину
ведет какое-то ребро.
Кроме корня.
Ну, следом от. Ну, отсюда, в принципе,
следует, что из корня мы до любой дойдем,
потому что просто будем идти по айдему.
Зацикла не будет, значит упрёмся в В.
Ну, например, так.
Так, у нас остается только ввести
определение.
Как вы думаете, как же называется
как же называется это дерево?
Да, оно так и называется.
Дерево доминаторов.
Да.
Субдоминаторов.
Ну, во-первых, скорее селфдоминаторов, а во-вторых,
во-вторых, нет дерева полудоминаторов.
Нет, но это как бы нам
чуть позже понадобится.
Так. Ну, пока давайте поймём,
в чём вообще...
Во-первых, да, что с ним вообще можно делать?
Да.
Ну, на самом деле, да, его...
Ну, действительно, да,
его можно построить.
Это во-первых. Во-вторых,
конечно, утверждается, что если это дерево
как-нибудь построить, то
можно тогда определять, какие вершины
на кем доминируют.
Ну, вот задачи, например, нам дали.
Там есть вершины, допустим, A и B.
Верно ли...
То есть доминирует ли A над B?
Да или нет?
Спрашивается, как это понять?
Да. Ну, утверждается, что да,
для этого надо проверить, верно ли, что A это
предок B. Так, а почему?
Очевидно, да, ладно.
Можно показать, что
путь до корня костелят собой, на самом деле,
список наших доминаторов
в порядке.
Так, ну, в принципе, да.
Да, можно прямо на картинку. Да, действительно.
Рассмотрим действительно всех доминаторов
от R до W.
Но теперь легко убедиться, что
действительно, что
в дереве доминаторов будет
вот такой замечательный путь.
Из R в U1, из U1 в U2,
из U2 в U3 и так далее.
Прям вот...
То есть в дереве доминаторов будет вот такой
путь.
Вот. Да, все действительно автоматически.
То есть просто получается, является ли A предком
B в дереве доминаторов, да или нет.
Да.
Так, давайте, что не так,
давайте сразу разбираться.
Ну, потому что... Так, ну, значит, смотрите, начнем с W.
Ну, во-первых, у нас вот есть ребро
из УК в W, да?
А теперь давайте думать,
кто доминирует над УК?
Я утверждаю, что ровно те же,
кто доминировал над W.
Потому что если над ним, например, доминирует еще
кто-то, то этот кто-то будет и на W.
Да. И более того,
да, все те же над ним доминируют,
и больше никого нет. Поэтому тут берем
предыдущий ребро, повторяем рассуждение.
Вот.
Так что вот такую задачу мы
неожиданно будем решать.
Вот. Но спрашивается, как
ее решать?
Ну, здесь на самом деле, то есть по-разному,
потому что на самом деле в компиляторах тут
неожиданно заявляют, что в общем-то там
лазить к тагьяну не всегда нужно.
Потому что у нас есть
упихон за...
Так.
Называется даже
за N квадрат M.
Как он работает?
Ну, потому что в Олимпиадах обычно такие
алгоритмы называют N квадрат M на 32.
Сталкивались с таким заклинанием?
Ну, конечно, да, потому что...
Ну, то есть да, идея будет
такая. То есть давайте
в каждой вершине
будем хранить просто битмассочку
у тех вершин, которые может
быть над ней доминируют.
Ну, вот.
А, ну, давай, нет, ну, давайте
посмотреть. Что мы хотим? Давайте в каждой
вершине храним битмасску.
Вот. Которая там...
В каждой вершине, которая
изначально полная маска, но
в корне, соответственно, маска состоит только
из себя любимой.
Вот. Ну, и давайте теперь
на каждом нот.
Нам нужно пытаться много-много раз делать
операцию, что рассмотрим какое-нибудь
серебро УВ.
Да.
И скажем, что маска от У,
то есть маска от В,
допустим,
ну, вот
n равно там маска от У, условно.
Ладно, вот так, только маска от У
или один хресь-хресь В.
Вот так.
Вот, мы хотим пробираться
много-много раз по ребрам
и добиться
того, что в какой-то момент
изначально,
как я уже сказал, что
маска от Р
просто равно 1 хресь-хресь
Р,
а все остальные маски
от В, если вы не равно
Р, должны быть равны
к чему?
Ну, 1 хресь-хресь
n минус 1, на самом деле.
Но это
маска на полный n-битм.
Вот.
А потом, после этого, делаем
там много-много раз, допустим,
то есть делаем вот эту штуку много-много раз
по всем ребрам, до тех пор, пока
эта штука что-то
апдейтит.
Чего она еще раз?
Ну, вопрос, как бы, правда,
в каком порядке
это делать?
Ну, типа того.
Да, можно устроить DFS.
То есть,
можно написать что-нибудь тупое.
Тупое, смотрите,
например, DFS от R,
то есть void,
там DFS от V
может звучать так.
For. Нет, ладно, давай DFS от U давайте.
А?
Можно мы разве просто удалить
вершину U, все, что
запустить DFS из R и все, что мы не посетили,
то есть,
почему мы не можем удалить вершину,
запустить DFS и сделать U?
Нет, ну, как бы,
если надо сделать обык какой алгоритм, то да, пожалуйста.
Это будет, да, но
скажем так, скажу почему.
Вот, ну, дело в том, что
на самом деле так, потому что
в кишке по комбинатору предлагается именно такой алгоритм,
мотивируя тем, что
во многих практических случаях он работает
гораздо быстрее.
Не только, но там есть такой, есть еще случай.
Ну, потому что,
как бы, если применять там компиля,
там часто может оказаться, что там
граф иногда ациклический, или почти ациклический,
что-то такое.
Там просто вот действительно.
Нет, ну,
вот. Чего?
Нет, ну, на ациклическом
вот этот алгоритм будет за NM на 32
работать.
Вот.
Ну, давайте смотреть.
Хотя...
Ну, давайте смотреть.
Так, там
пишем NMASK
равно маск.
Там, значит...
Вот.
Вот. Ну, вот можно, например, вот написать вот...
То есть, какое-то вот такое
заклинание.
Нет, ну, в самом начале
мы запускаем все только,
делаем только DFS-R.
Что?
Ой, ой, ой, ой.
А, в этом плане, да, DFS-R, конечно.
Вот.
Да.
Так что вот можно, например, такое.
Ну, давайте смотреть.
Да, в худшем случае...
Так, ну, за сколько это может работать?
Ну, давайте посмотрим.
Сколько раз
мы можем запуститься из одной вершины
DFS может запуститься из одной вершины
DFS может запуститься из одной вершины.
Каждый раз, когда мы обновляем маску...
Да, маску мы обновляем, да.
То есть, как бы, каждый раз у нас количество
бит, то есть, DFS из вершины
запускается, когда количество бит в маске
не уменьшилось. Их изначально
N уменьшится оно может только до нуля,
поэтому, значит, не более чем N раз.
Следовательно, DFS запускается
не более чем M раз, значит, соответственно,
мы...
Получается, каждое ребро мы рассматриваем
не... Значит, каждое ребро
M мы рассматриваем не более чем
N раз.
Вот. И обрабатывая, значит, получается
ассимточка NM умножить на
за какое время мы обрабатываем это ребро.
Но мы его обрабатываем как раз
за те самые N на 32.
Вот. То есть отсюда такая ассимточка получается.
Вот.
Так. Правда, по-хорошему, конечно,
неплохо было убедиться, а почему этот алгоритм вообще
работает?
Да.
То есть, на самом деле, давайте так немножко
поразминаемся, почему он вообще работает.
Ну, верно, на самом деле,
следующее, что если какая-то вершина
в итоге не вошла
в маску, то она
в маску вершины V, то она над
вершиной V, очевидно, не доминирует.
Да.
Ну, просто по индукции.
Вот.
Это очевидно, но с другой стороны,
может быть, там в результате
этого DFS, там какие-то вершины
в маске окажутся все доминаторы
V и еще
какие-то пара лишних вершин.
Может такое быть?
Ну, рассмотрим путь, который содержит
одну таких вершин.
Ну, да.
Ну, понятно, что у корни
этой штуки нет, начинает
быть дискретно неприятность.
Здесь какая-то маска, которая не содержит
эту вершину.
Ну, в принципе, да.
И у нас есть предварительное, что мы через нее
не обдавили маску.
Нет, ну да.
Да, действительно, заметим, что можно рассмотреть,
если вершина U не доминирует на V,
то можно рассмотреть любой путь от R до V
и аккуратненько тоже по индукции
доказать, что в итоге в маске
каждой из этих вершин ушечки
не будет.
Ну, просто потому что,
как минимум, потому что, когда мы запускались из R,
мы уже сразу там, пробежимся
по этому ребру и попытаемся
обновить эту вершину маской без U.
Значит, мы забываем ее нот.
Вот.
То есть, либо она обновится,
и мы прямо сейчас тогда запустимся без U,
либо она уже без U, значит, мы из нее запускались раньше,
причем когда она уже становилась без U.
Но когда мы из нее запускались,
мы тогда пытались сделать вот эту вершину без U,
ну и так далее.
Вот. Поэтому, да, здесь
доказательство получается простое.
Другой вопрос, действительно, что тут NM...
Ну, здорово стоит, что еще тут может быть?
Но, кстати, давайте посмотрим.
Да, ну тут вот, если какая-то вопрос, действительно,
да, как интересно, о авоциклическом графе
действительно это
можно улучшить симптотику?
Ну, в порядке обратного топсорта, наверное.
Нет, ну, в принципе, да, на самом деле, да, если...
Нет, ну, тут так, да.
Ну, на самом деле, так.
К сожалению, я боюсь улучшить вот эту вот симптотику,
наверное, получится не очень.
Чего?
Ну, разве что, да, потому что
проблема в том, что мы можем
как бы пройти по этому ребру, а потом
пройти еще, допустим, вот по этому
какому-то.
Вот.
Вот.
Ну, вот.
Допустим, тут пройти, хотя...
Хотя...
Да, потому что кажется, мы можем просто рассматривать
совершенно несколько вариантов, чтобы запускать
дфс только один раз.
Сейчас, чего еще раз только? Чего запускать?
Кажется, мы можем идти в такой порядок,
яшим, но так и...
Ну, да, потому что... Ну, да, можно, в принципе, да.
Ну, да, просто ациклический граф
можно допилить так. Ну, можно допилить, да,
то есть, на самом деле, это будет правда не дфс, а
просто проход по топсорту, да.
Нет, то это другое.
То есть, топсорта надо сначала запустить
чтобы найти топсорта, в порядке топсорта
пропихивать масочки.
Есть такая классика.
Но, на самом деле, тут... Красивое
определение тут немножко другое, потому что тут
значит...
То, что говорят тут немножко другое.
Сейчас вот тут мне даже
написано, что... Потому что
там в теории компиляторов рассматриваются
такие графы, но не буду сейчас писать,
как такие сводимые графы
или reducible графы.
И говорят они...
И говорят они, предположим, что
помимо...
И предположим,
что у нас есть...
То есть, предположим, что у нас
допустим, совершенно случайно оказалось,
что на самом деле
не все ребра есть, а есть только
ребра, допустим, прямые,
причем прямыми тут называются
ребра, которые формируют, собственно,
так сказать, дерево дфс,
допустим, да, и обратные
ребра.
И вот. То есть, предположим, что у нас оказалось
только такое.
Тогда утверждается, что в этом случае
тогда этот алгоритм тоже за nm на 32
вполне себе будет работать.
Причем так в построении
компиляторов утверждается, что
такие графы как раз встречаются часто.
Ну, там действительно надо это...
То есть, как должен быть устроен код,
чтобы у нас там в...
Там, собственно, образовалось
перекрестное ребро.
Go to.
О, да.
Нет, ну да.
Вот.
А, ну ладно, правда, хорошо, ладно, еще могут
образоваться реально прямые ребра,
которые у нас просто перескакивают, потому что у нас же может быть вот этот
if-чик, правда?
То есть, if что-то, то мы тут делаем...
То есть, вот эта вот типичная вот эта ситуация, да.
То есть, вот такая вот эта. Ну вот.
Ну вот, соответственно, там утверждается, что
если у нас есть только такие...
Ну вот.
То есть, если у нас есть действительно только такое,
то тогда у нас оказывается, что
почему... Утверждается, что
граф тогда за там нормальный
nm на 32 вполне себе работать будет.
То есть, такие вот
утверждения возникли.
Вот.
Соответственно, странная она вот.
То есть, немножко, конечно, странная, потому что
кажется, что у нас здесь действительно в эту вершину
мы все равно можем зайти много-много раз.
На самом деле.
Потому что хочется... Потому что nm на 32
намекает, конечно, что мы должны
каждую вершину
рассмотреть только один раз.
Ну или, по крайней мере, от единицы.
Но как-то получается, что не ухи.
Впрочем... Хотя, с другой стороны,
заметим, что если мы тут прошли по этому ребро,
а потом прошли по этому, то как-то
есть... То как-то там по этим вот,
то есть подозрение, что мы...
Что мы, возможно... Если это
было дерево DFS, то мы, по-моему, из этой
вершины могли ничего нового не узнать.
Да.
Ну если это реально дерево DFS такое.
Вот.
Но, впрочем, не суть.
Ладно, не будем
сейчас на эту тему заморачиваться.
То есть, здесь это для интересующихся, соответственно,
просто отсылаю, просто вот, соответственно,
к этой книжке и, соответственно, к статьям, которые там
дальше есть. Но тем более,
что нам это не особо принципиально,
потому что, как вы уже догадываетесь, мы тут себе...
У нас тут ставки на более серьезные симптомики,
в любом случае.
Чего?
N-куп?
Ага, нет, зачем нам это? Нет, хуже,
нет. Ну сформируем так.
Нет, наша ставка, как уже было
сказано, наша ставка
называется E, она там в идеале
обратную функцию какую-то там вот эту вот.
Да. Это будет ближе к
СНМ, но не то.
Со ссылкой на структуру.
Вот, со ссылкой на структуру, но
это уже просто тема, возможно, отдельного занятия,
изучать, к чему СНМ за обратную функцию
от Ермана работает. Чего?
Нет, это
будет что-то близкое.
То есть, на самом деле, это будет такая структура
данных, которая будет
делать сжатие путей.
Вот.
Но там просто она будет хотеть не совсем
СНМ.
То есть, она будет, ну ладно, давайте я скажу,
что она будет. То есть,
будет такая мистическая, ну в идеале хочется
так. Потому что
значит, хочется, чтобы у нас были подвешенные
деревья,
с которыми хочется поступать
следующим образом.
Ну, во-первых, хочется
учиться одно дерево подвешивать
другому.
Ну, там, допустим, вот куда-нибудь
хотя бы.
Хотя, по факту,
на самом деле, нет. Мы, хотя нам
сейчас достаточно будет, чтобы мы только корень
к корню подвешивали.
Вот, понимаете, да?
Но нам будет хотеться
еще кое-чего.
То есть,
нам еще будет хотеться, чтобы
на каждой
на каждой вершине написаны какие-то
числа.
Там, типа, пять, семь, два, там, четыре,
восемь, там, шесть, там, семь,
два. Ну, там от балды.
И на них
хочется делать еще какую-то
и хочется делать какие-то операции.
То есть, операции такие. То есть, даны деревья
объединив, то есть, подвесь один
корень к другому.
И захочется после этого
еще сказать что-нибудь вроде
возьми-ка ты, пожалуйста, какую-нибудь вершину
и верни мне, а к чему равен, допустим,
максимум на пути
от этой вершины до этой.
Да, кайф. Я согласен, да, линкат.
Но на самом деле
нет, линкат не нужен.
А, потому что, ладно,
давайте-ка я еще тут, значит, тогда
сейчас я еще тут поглядю, потому что
мало того, что эти чиселки будут хотеться.
Потому что, значит,
это я уже сказал, потому что операции
действительно будут у нас линк УВ,
то есть, там подвесь какой там.
Есть операция
ЭВАЛ, то есть, это вот, типа
найди максимум от У до
корня. И кое-что еще.
Потому что структура называется
ЭВАЛ линк апдейт, на самом деле.
Значит, что это такое?
Значит,
что это у нас такое?
Так, так,
ой, у меня тут записано, что это такое,
или нам это тоже не нужно.
Ну, потому что
в идеале там начинается какая догадка,
то есть, в данном случае, то есть, в нашем случае
это получится, что апдейт нужен что-то там, типа
что там
вал от У, там должно быть
максимум равно х, по-моему, или что-то в этом
роде.
Вот.
Вот.
То есть, ладно, в нашем случае
этого не потребуется, на самом деле.
А это вот, ну, смотри,
на каждой вершинке написаны
чиселки У, да?
И нам очень захочется, ну вот,
то есть, вал от У. То есть, ЭВАЛ от У
говорит так, я хочу пройти
по пути от У до корня,
взять все эти валы и вернуть из них
максимум.
Да, давайте
сразу подумаем, как такое решать?
Ну, во-первых, да, у нас, конечно, есть линк ап,
который прекрасно это умеет.
Нет, вот, ладно, с апдейтом.
Хотя нет,
вал от У тут максимум равно х,
и при этом тоже гарантируется, что у корень.
Да, там.
Ну, как халява, да.
То есть, заметим, что в таком варианте
линк ап не нужен.
Потому что, да, мы это в какой-то момент докажем,
но пока есть просто знание, что
на самом деле, если мы просто это будем делать,
как в СНМ, и применять тупо
только эвристику сжатия путей,
ну вот,
то, в принципе,
уже гарантируется, что там
можно показать, что
учетная стоимость будет логарифом.
Но там даже есть более,
на самом деле, жесткое утверждение,
которое там говорит, что
чем ближе m будет к n квадрату,
тем больше эта учетная стоимость будет похожа
на единицу, на самом деле.
То есть, она будет всегда не больше, чем
лог n, но
приближаться к единице она будет,
что-то такое.
Есть там более общая теорема
говорит о том, что в общем случае все будет учетно
за логарифом, но
если гарантируется, что это дерево хоть
насколько-то сбалансировано,
ну там, сбалансированность
гарантируется, что там
типа, что
допустим, что на каждой глубине
находится вершина не более, чем там,
по-моему, что-то типа там, а в какой-то степени,
где, а там еще и там
в какой-то момент.
Ну, то есть, это не сильно так расширяется
аккуратненько, то тогда кажется, что все
действительно работает за вот этого вот
кирмана. Ну вот,
и там дальше начинается то, что для
вот этого максимума, на самом деле, дерево можно
модифицировать так, чтобы какие запросы не были,
а на самом деле можно сделать так, чтобы там
дерево было вот это вот сбалансировано.
Так, да,
это называется краткое, да, это краткое
содержание соседней статьи Торьяна.
Вот.
Просто это вот на отдельную структуру
данных, вот.
То есть, для нас в принципе, то есть, для Олимпиады
к цели можно просто хватать, что сжатие путей
дает логарифм, поэтому в принципе
там и отсюда и получится там алгоритм за
е лог в. Вот.
Хотя, на самом деле отсылаемся на,
имеем в виду, что отсылаемся на более
продвинутую структуру данных и
может быть там на каком-то отдельном занятии
мы это даже и рассмотрим. По крайней мере,
мне бы этого очень хотелось, но я это уже
говорил. Вот.
Нет, ну, в прочем, в принципе,
в прочем, как-то раз нам, по-моему,
нам на самом деле удалось доказать, что СНМ работает
за Акермана. Вот. Там, хотя первая
сложность, понятие, что это за Акерман вообще
такой.
Вот.
Да, тем более... Нет,
там определение уже не самое простое
и, во-первых, под всеми этими альфами
часто появляются разные функции, на самом деле.
То есть, скажем, как я уже
говорил, что, например, помните, в софтхипе,
как я уже говорил, там возникнет другая функция.
Там возникнет функция
бета, про которую только в конце докажут, что
там не более чем альфа умножить на 9.
На самом деле. Поэтому, типа,
это одна и та же функция, но там просто она другая.
Но там просто зависит от того, что в алгоритме
откуда-то рекурренты возьмутся какие-то.
Так вот, ладно. Значит,
это у нас скорее небольшой анонс был.
Вот. Так что
теперь давайте приступим. Значит, как же нам искать хотя бы
за Е лог В? Это дерево
доминаторов.
Но нам поможет одна маленькая
техническая лемма, которую тоже можно было, наверное,
вставить в теорию ДФСа.
Хотя, в принципе, сейчас
она не будет... Сейчас то, что я
сформулирую, лемма не будет иметь никакого
отношения, значит, к
теории ДФСа.
Наоборот, к теории доминаторов.
Как бы мысль правильно сформулировать?
Больше нет. Она будет
иметь отношение к теории доминаторов, просто ее
формулировка к доминации не будет иметь отношения.
Вот почему у меня была лемма один штрих.
Да.
Потому что она будет называться лемма один.
Да. Вот.
Истинная лемма один.
Значит, запустим ДФС.
Там ДФС из R.
Пусть
значит таймы над
U оказался
таймы над U оказался
меньше, чем таймы над
V.
Тогда
любой путь
из
U в
V
содержит
что?
Содержит U и V.
Замечательно.
Что потенциал?
LCA.
Но
это неправда.
Нет, LCA.
Нет, я вам сразу скажу нет.
Нет, LCA это просто заведомая
неправда, потому что
вполне вероятно, что
во-первых, существует прямое ребро сюда,
а во-вторых, обратное ребро сюда.
Вот. А вот
верно от вещей, что содержит
некоторого
общего предка.
То есть как бы
CA, но не обязательно
LCA.
Нет.
Не обязательно.
Потому что я на любом
предке вот
такую картинку нарисовать.
Ну,
предок, естественно, имеется в виду
в дереве DFS.
Да.
Теперь у нас действительно актуально понятие
именно дерева DFS.
Потому что мы в главе играет в поток
управления зердость режима, все, поэтому ура.
Так что вот такая
лемма нам должна пригодиться
по идее.
Так, ну давайте поймем.
Так, ну давайте думать,
почему, собственно, это так.
Да, равно, как и если вы
предоку, да.
Завечательно.
Так, супер.
Увеличивать, простите, да, я запутался.
Вот, потому что у нас
в начале, ну так, у нас
между ВИНКО есть определенное
соотношение, нам нужно посмотреть,
есть вершины, которые также
увеличивают это.
Увеличивают такие
ребра, такие ребра
называются у нас вроде как обратными, только такие.
Сейчас, нет, обратные ребра что увеличивают?
Обратные ребра тайминг как раз уменьшают.
Уменьшают. Да.
Да, у нас нет перекрестных
ребр. То есть, замечу так,
что, как и да, что увеличивают ребра
тайминг, у нас только ребра дерева
ДФС и прямые ребра.
Да, даже перекрестные ребра
они тайминг уменьшают, напоминаю.
Ладно, тогда у нас
есть...
Вот, теперь, если В
не потомокуб, то
получается, что они в разных деревьях
населены какого-то общего предка. Да.
Давайте, поехали.
Почему это?
Так, и что?
Ну, мало ли.
Как-то вообще, но
вообще пока не понятно, мало ли, как мы там
в В попали.
По прямым ребрам и по ребрам ДФС
мы смотрим на последний момент,
когда мы пошли под кому ребру.
Ну.
Тогда очевидно, что если он не заходил
в предков,
тогда получается, что мы находимся где-то
над В, но не над У.
Тогда мы должны сейчас...
Нет, логично уже все, да?
Пока нет.
Пока нет, потому что я пока ничего не понял.
Нет, почему нет?
Смысл может быть...
Смысл может и есть, но пока его очень сложно
понять. Вот так, скажем.
Да, ну давайте смотреть.
Не надо. Хочется, ну как минимум
да, хочется, наверное, индукция, хочется
запустить, конечно, индукцию по длине этого пути хотя бы.
Да, да, во-первых, да, сейчас.
Ну, во-первых, так с тем, что если путь состоит из одного
ребра, то, как мы уже увидели,
то это ребро у нас как бы либо ребро
дерева ДФС, либо прямое, и все автоматически
верно.
Да, то есть это означает, что
У и есть предок В.
Так, отлично.
Ну вот, хорошо.
Ну теперь предположим, что путь больше
чем один, но для меньших путей мы, допустим,
что-то доказали.
Что?
Что-что?
Так.
Ну давайте посмотрим, да.
Ну, во-первых, да, хочется сказать, что
если на этом пути дальше встретится
какой-то предок У,
то в принципе этот предок либо уже сам общий
предок, либо это какой-то этот предок, и дальше
доказываем просто по индукции.
Потому что получился более короткий
путь из предка У, который будет проходить
через общего предка это и это, и значит
общего предка У и В.
Так, и что?
Но это если мы через
предка как-нибудь пройдем.
Так, да, чего?
Все про то же. Мы можем смотреть.
Давайте скажем, что у нас В и У
не дадут друг друга предками, да?
Да.
Тогда можно сказать, что их отрезки тайминов
ну типа от таймин до тайм-аута
не пересекаются, и нет.
Ну и не вложены. Да.
Поэтому как относится у нас
таймин, так и относится у нас тайм-аут.
Да. Теперь мы говорим.
Отлично. Вот теперь про тайм-ауты верно,
потому что увеличиваются они
только при обратных ребрах.
Но при перекрестах уменьшаются,
при прямых и
ДФС уменьшаются.
Так. Поэтому у нас должны быть
обратные ребра, причем обратные ребра
если мы прошли, давайте
посмотрим последние обратные ребра,
которые мы прошли.
Оно утверждает, что оно должно вести
в какую-то вершину, которой тайм-аут
больше, чем у вершины В.
Но оно должно вести в предка,
потому что после этого нет обратных ребра.
Так. Значит обратное
ребро.
Ага. Слушайте.
Так. А ну-ка давайте попробуем.
Ну-ка еще раз.
Так.
Так, так, так.
Сейчас, сейчас.
А как это будет связано потом с таймином?
Как мы это сведем к тайминам потом?
Мы же говорим, что у нас отрезки
от тайминов, тайм-аутов не перетекаются.
Ну и что?
Значит у нас тайм-ыны относятся так же,
как тайм-ауты.
Значит нам нужно увеличивать
нам придется увеличить тайм-аут.
Оно увеличивается при проходе
по обратному ребру.
Значит у нас
в моменты похода по нему
после того, как мы пройдем,
у нас тайм-аут должен быть больше,
чем у тайм-аут В.
Значит это предок В.
Сейчас.
Не.
Это может быть тупо неправда.
Потому что мы пришли
В по перекрестному ребру из соседнего дерева,
в котором мы...
В обратной.
Мы могли идти
по тому ребру,
который еще и тайм-аут,
в дерево, которое где-то правее,
потом в дерево правее.
Вполне могли, да.
Так что да, тут конечно надо...
Так, ну да, тут надо конечно
смотреть.
Вот, потому что, ну вот.
Ну вот.
Так, поэтому да.
Присекает вопрос, хорошо, какие еще идеи могут быть?
Так.
Нет, ну да, просто на уровне картинки
доказательства может быть на самом деле такое.
Смотрите, вот раз у нас у и В не предки друг друга,
смотрите, то вот, допустим,
вот у нас эта лсажка образовалась, да?
Смотрите.
Теперь вот возникает вопрос.
Что как-то у нас
этот путь будет идти
и рано или поздно выйдет
из вот этого под дерево, правда?
Вот, рано или поздно выйдет.
Ну, куда он выйдет?
Либо он выйдет по обратному ребру
в какого-то общего предка, и все доказано.
Либо...
То есть либо
он выйдет в какое-то соседнее под дерево.
Вот, давайте я сейчас возьму зелененький.
Потому что, в принципе,
смотрите, вот у нас есть этот путь,
и у нас есть
значит, ну вот,
и у нас есть вот куча деревьев,
то есть тут вот этих вот под деревьев,
где как-то вот так вот,
но давайте вот так.
То есть вот так, допустим, вот так вот,
то есть вот так вот,
и так далее.
Вот,
давай нот.
То есть, давайте тогда уже смотреть.
пл 봤ы
Допустим мы по перекрестному ребру
вышли в какое-то,
по перекрестному ребру, там вот, то есть тут шли-шли-шли-шли, и вот по перекрестному
ребру вышли в какое-то из этих деревьев. Вот. Ну, утверждается следующее, что, ну, утверждается,
что таймыны у всех этих вершин должны быть, очевидно, меньше, чем таймыны у этого дерева.
Должно быть такое? Нет, оно перекресты, из этого гарантируется, что там мы тут походили, то, что,
допустим, у этой вершины, из которой это дерево, торчит таймын больше, чем здесь. Вот. Но, то есть,
но само по себе из этого не следует, что, скажем, таймына ту не окажется меньше, чем таймыны этой
вершины. Ну, само по себе из этого еще ничего не следует. Нет. Перекрестный ребро, да, то есть,
гарантируется следующее, что, если у вас есть перекрестный ребро АВ, то таймына А больше,
чем таймына Б. Но из этого не следует, что, если у нас есть там какой-то путь от У, который идет
там по какому-то там, по дереву, и потом проходит по перекрестным грузам, из этого не следует,
что таймына У, там, на самом деле, обязательно больше, чем таймына эта вершина. То есть, само по себе.
Короче, отрезок от таймына по дереву это отрезок, и такие отрезки для разных деревьев не присекаются?
Нет. Ну, в принципе, да. Да, на самом деле, да, заметим, что, да, самый тупой доказатель,
что, заметим, что по таймынам у нас вот это все под дерево образует отрезок, поэтому,
если какой-то перекрестное ребро выходит за пределы этого под дерево, то оно нас точно
ведет в вершину по таймыну меньше. Логично, да? Ну, теперь очень хочется сказать, вот, ну, теперь
очень хочется сказать, что рассмотрим вот эту вершину, да, по предположению индукции, путь,
остаток пути от этой вершины до этой будет проходить через общего предка вот этой
вершины и вершины В. Ну, давайте вот у штрихов ее назовем. Ну, вот, индукция по длине пути.
Почему тогда мы перешли, почему там будет играть король? Какой-то путь там? Сейчас, в смысле? Нет,
не понял. Нет, логика должна быть такая же. Ну, хочется сказать так, что рассмотрим путь оттуда,
рассмотрим путь оттуда В. Вот из этого под дерево мы рано или поздно впервые в жизни выйдем, правда?
Вот, мы, ну, вот, то есть мы выйдем в какую-то вершину у штрихов. Вот, нам очень, ну, вот, через,
ну, вот, то есть остался путь, кусочек пути от у штрихов В, он короче. Поэтому мы теперь говорим,
что по предположению индукции этот путь, оставшийся, будет проходить через общего
предка вершин у штрих и В. Другой вопрос, конечно, остается теперь выяснить. Остается только
один вопрос. Почему этот общий предок является еще и предком У? Ну, то есть из картинки вот это
вроде самочи, там, кажется очевидным, но это всего лишь картинка. Чего? Ну, почему-то. Ну,
кажется, вполне себе картинка. ДФС у нас как-то вот так устроен, потому что, ну, вот. Вот, ну,
ладно, полная картинка будет, конечно, если я вот тут еще дорисую, но это тоже не то. Так вот,
спрашивается теперь, почему общий предок, ну, вот, почему у нас общий предок У штрих и В
действительно окажется еще и предком У. Ну, вот, ну, идея, на самом деле, очень простая. Ну, вот, да.
Что-что? Сейчас еще раз. Минимум на общем отрезке, не понял. Нет, ну, не совсем так. Нет, можно,
например, сказать так. Этот общий предок У штрих и В, он является предком В, да, и он находится либо
там выше ЛСА, включительно, либо ниже. Логично, да? Но с другой стороны, очевидно, просто, если он
находится ниже этого, ну, вот. Ну, вот, теперь вот утверждается, что если он находится ниже ЛСА,
то он просто на самом деле не может быть предком У штрих. Он не может быть предком У штрих по,
ну, вот, по, на самом деле, весьма банальной причине. Нет, ну, вот, ну, почти, потому что скорее,
ну, вот, потому что скорее всего этот У штрих на самом деле по таймыну меньше, чем вот эта ЛСА.
Вот. А тут как бы, а вот эта вершина по таймыну, она больше, чем вот эта ЛСА. То есть единственное,
что теперь надо тогда рассмотреть, а что делать, если это соседнее ребро висит просто на той же
самой ЛСАшке? Да, но правда это тоже работает, потому что тогда вот эти вот, если объединить тут все
поддеревья, которые тут висят на этой вершине до вот этого включительно, то они тоже образуют
подотрезок и все в порядке. Если оно висит под дереве какой-то вершины на пути от ЛСА до В. Так,
но тогда, тогда идея такая. Значит, рассмотрим все, значит, вершины, рассмотрим все поддеревья,
которые висят на этой ЛСАшке, но которые были обойдены ДФСом до вот нашего поддерева с
вершиной У включительно. Тогда рано или поздно мы из этого множества вершин выйдем. Но некоторое
время мы тут будем ходить, но рано или поздно мы из них выйдем. Но если мы выйдем по обратному
ребру, то, значит, мы пойдем в ЛСА или его предка и автоматически победа. Если мы выйдем по
перекрестному ребру, то мы выйдем по ребру у штрих, и у штрих будет по таймыну меньше, чем даже ЛСА.
Вот, поэтому так. То есть вот такое доказательство может, например, иметь место. Или может быть,
на самом деле, доказательство про тайм-ауты и, кстати, про обратные ребра на самом деле вполне
себе может и доводиться. Потому что вот другое доказательство могло быть, что действительно кто
у нас увеличивает. Значит, у нас тайм-эн увеличивает только прямые ребра и ребра дерева ДФС. Поэтому
возможно можно было бы рассмотреть последние ребра на пути, которые там увеличивает тайм-эн,
и мы там про него тоже еще не докажем. Ну, например, ну, во-первых, там,
ну да, там, скажем, рассмотрим там последнее прямое ребро или ребро ДФС на пути. А вот, кстати,
давайте, интересно, пять минут подумаем. Вот другое, смотрите, другое доказательство, которое
предлагалось. Рассмотрим последнее прямое ребро на этом пути, в какой-нибудь. Так, ну, пусть оно прямое.
Нет, в смысле, нет, смотрите, хотя бы одно прямое ребро или ребро дерева ДФС на этом пути точно есть,
потому что обратные ребра и перекрестные, они уменьшают тайм-эн. Так, вот рассмотрим. Тогда
после него мы как-то попали в вершину В чисто по прямым и обратным ребрам. То есть по обратным
и перекрестным ребрам. То есть мы там чисто действительно что-то уменьшали. Вот, соответственно.
Так, спрашивает, а что? Ну вот, так, теперь вот возникает вопрос, что нам это дает?
Перекресток прям ломает, да? Но это да. Ну да. Ну да. Ну правда, нет, там, видимо,
доказывать, пришлось бы доказывать по принципу, что путь оттуда, так как вот у этой вершины тайм-эн
заведомо больше, чем у В, значит, и у У тоже, значит, получается, что мы через общего предка
у этой вершины прошли. Стоит только доказать, что это общий предок является и предком вершины В.
То есть тут, видимо, как-то так это будет работать, но это, видимо, что-то похожее вот на это получится.
Окей, ладно, с лем мы разобрались. Значит, тогда давайте переходить ближе к, собственно, так,
давайте попробуем ближе переходить к, собственно, какой-нибудь доминации. Но правда, для этого нам
сразу понадобится, конечно, немножко, то есть, видимо, придется ввести всякие эздомы. Ладно,
значит, лемочку мы убираем. Такие так, ну, доказательства лемочки убираем. Вот. Но,
по-принципе, кстати, само по себе на самом деле очень интересное замечание, на самом деле.
Так, значит, далее. Давайте смотреть, смотреть, смотреть, что у нас тут будет. Вот. Так. Ну,
а первое, да, придется ввести тут действительно еще какое-нибудь веселое понятие. Такое весьма
экзотическое. Так, смотрите, то есть, определение. Значит, пусть у нас, как всегда, значит, w не
равно r. Тогда, значит, давайте, значит, полудоминатор w, полудоминатор w, или я сразу введу обозначение
esdom, то есть, честно говоря, в своей речи даже редко использую понятие полудоминатор. Вот. А, даже
не self-domination, а semi-domination. Вот. Значит, берем, значит, вводим такой вот этот esdom от w. Это,
значит, что это такое? Значит, это, ну, скажем так, знаете, вот в статье Тарьяна немножко по-другому
написано, но я напишу так. Значит, argmin, значит, таймын от w. Значит, минимальная по таймыну такая
вершина v, что, внимание, существует путь, значит, такой, значит, v, значит, v0, v1, v2 и так далее, vk, w.
Ну, и там в конце будет vk равно w. Такой, что, ну вот, для любого i, для любого i,
лежащего на отрезке от 1 до k-1, оказывается, что таймын от w строго больше, чем таймын
от w. Вот. Вот такую неожиданную штуку мы введем. То есть еще, что это означает? То есть это
означает, то есть это означает, что мы можем дойти из вершины v до вершины w, но в качестве
промежуточных вершин используем только, соответственно, вершины по таймыну больше. Да,
вот мы будем писать так, хотя сразу предупреждаю, если будете читать статью Тарьяна, сразу обратите
внимание, что он первое, что делает, перенумеровывает вершины. Он говорит, что давайте запустим DFS и
перенумеруем вершины в порядке входа DFS в них. То есть подобные леммы там начинают формулироваться
сильно проще. Вот. Но мы тем не менее, почему-то будем делать так. Да, почему? Потому что мне так
почему-то больше нравится. Ну, потому что мне как-то ощущение, что вершина w это все-таки какая-то
такая сущность типа камешка, а таймын это какая-то чиселка. Вот. Так, ну давайте смотреть.
Так, ну давайте думать. Значит, соответственно, теперь придется, значит, подоказываем пару
леммочек. Так, что можно про этого издамо сказать? Да, он не просто существует, а просто я даже еще
и сразу, даже пропущу это нулевое утверждение, просто сразу перейду ко второму. Нет, он, конечно,
единственный, потому что мы из всех подходящих вершин выбираем минимум по таймыну. Да, то есть не
просто какая-нибудь вершина, но вот. Так-то, ну вот, значит, s дам от w, она заведомо меньше, чем таймын от w.
Вот начнем с такого простого утверждения. То есть, обратите внимание, видите, я вот в этом
вот условии про саму вершину w ничего не говорил. То есть, сама вершина w может быть меньше таймына.
И это действительно помогает. Так, ну, кстати, почему это лемма, верно? Ну да, просто потому,
что в качестве кандидата в полудоминаторе вполне пойдет родитель в дереве dfs. Потому что,
по идее, этот путь может состоять из одного ребра вполне. Понимаете, да? Более того, то есть,
на самом деле, если мы это ищем, то первое, что мы должны сделать, это просмотреть все прямые
ребра, ведущие в w. И это прямое ребро, то есть, какие-то прямое ребро, которые видят из более
высокой вершины, это вот тоже один из кандидатов в полудоминаторе. Вот. То есть, это мы начинаем с этого.
Так, что у нас еще? Вот. Так. Ну, можно, на самом деле, развить эту идею и сказать сразу, что
w это собственный предок w. Что такое собственный? Да, не совпадающий с самим w совершенно верно.
Вот. Да, казалось бы, почему? Да, потому что ровно для этого мы тут доказывали эту мистическую лему.
Потому что рассмотрим этого эздома. Из этого эздома есть путь в w, и этот эздом по таймыну меньше.
Следовательно, на этом пути встретится общий предок эздома w и w. Но предок, но так как общий
предок это в том числе и предок w, то по таймыну он должен быть, очевидно, меньше, чем w, правда?
В чем строго меньше, потому что, соответственно, сам эздом меньше, значит, его предок тоже меньше.
Но у нас на этом пути есть только одна вершина, которая по таймыну меньше, чем w. Это, собственно,
эздом от w. Вывод, это и есть предок. Вот. Так же такая вот приятная вещь. Понимаете, да? Вот.
Вот. Но, на самом деле, да. Зачем нам эти эздомы вообще нужны? А, ну давайте еще. Так,
ну давайте вообще подумаем. Так, прежде чем я буду формулировать лему, давайте подумаем. А как
эти эздомы вообще связаны с айдомами, как вы думаете? Все, смотрите, ведь как они связаны?
Заметим, что эздом – это предок w, собственный предок w. Но очевидно, что айдом – это тоже
собственный предок w, правда? Но очевидно, наверное, что на пути в дереве DFS, очевидно,
лежат все доминаторы, в том числе айдом. Так. А теперь внимание, вопрос. Как вы думаете, кто
выше? Айдом? Или эздом? Да. То есть пишем айдом, айдом от w. Давайте так писать, ладно. Значит,
предок на этот раз не обязательно, кстати, собственный. Я это даже подпишу. Не обязательно
собственный. Собственный. То есть это не обязательно собственный предок эздома. Вот. То есть не может
быть так, что эздом выше айдома. Почему? Ну да, потому что на самом деле да. Потому что пусть это
не так. И там эздом, допустим, оказался выше. Тогда у нас существует путь вот какого-то такого
вот рода. Вот видите, я его именно через право рисую, потому что он идет через все вершины
большие w. Вот. Ну, точнее так, вот это w. Ладно, он приходит вот либо сюда, либо вот куда-то
в под дерево w и тут еще как-то шатается. Вот так скажем. Вот. Но факт остается фактом, что этот
путь, по идее, если айдом лежит ниже эздома, значит этот путь позволяет обойти айдом,
противоречие с определением айдома. Вот. То есть получается, да, такого не бывает. И айдом это
обязательно предок. То есть более того, то есть более того, так ух ты, какие у меня тут леммы веселые,
да. То есть более того, на самом деле, можно даже поставить более веселую штуку. То есть смотрите,
то есть да, по идее эздом это действительно у нас позволяет делать такие обходы. То есть более того,
на самом деле, в некотором смысле, если какая-то вершина не является доминатором, то есть подозрение,
что ее всегда можно обойти вот каким-то вот таким вот образом. Логично, да? Ну, потому что,
смотрите, давайте я посмотрю, вот прежде чем формулировать. Ну, потому что да, ладно. Хочется
сформулировать на самом деле вот такое. Вот лемма 5. Хочется сформулировать так. Если заменить
в графе все ребра не из дерева, не из дерева DFS. То есть, ну вот, на, на что? На
ребра вида. Ну, на ребра вот эти вот эздом от W и W. Ну, мы, ну, скажем так, то, что у нас был граф,
наш граф, да. Мы запустили DFS из R. Он образовал дерево DFS. Логично, да? Нет, нет, нет, не ребра
дерева DFS. Напоминаю, у нас в классификации прямые ребра и ребра дерева DFS, это разные вещи. Да,
то есть, напоминаю, у нас есть ребра дерева DFS, то есть, ребра, по которым DFS непосредственно
прошел. Есть все остальные ребра. Они бывают прямые, обратные и перекрестные. То есть,
прямые те, которые соединяют предка с потомком, значит, обратные, которые потомка с предком,
перекрестные все остальные. Да, напоминаю. Вот. То есть, если, то есть, заменить вот на все такие
ребра, такие, что W лежит, просто пробегается по всем вершинам, кроме корня, то дерево доминаторов
не изменится. Я так напишу. Ну или просто можно было, да, может быть, более прямее сказать,
отношения доминации не поменяются. Не изменится. То есть, это, в общем-то, обыставание того, а зачем мы
эту полудоминацию вообще ввели. Вот. Ну, давайте думать. Ну, давайте вот, соответственно, думать.
То есть, давайте вот такие вот ребра забабахаем. То есть, ну, во-первых, давайте хотя бы в одну
сторону поймем. Давайте поймем, что почему, если вершина В, то есть, допустим, у нас есть какая-нибудь
вершина В. То есть, допустим, у нас есть, то есть, рассмотрим какой-нибудь путь. Ну, во-первых, вот у
нас дерево ДФС-то у нас остается, да. То есть, дерево ДФС остается, как мы уже убедились, что, в общем-то,
в новом графе можно запустить ДФС так, чтобы дерево ДФС было абсолютно таким же, правда?
Потому что относительно его есть только вот эти прямые ребра. Так вот, рассмотрим какую-нибудь вершину В
на вот этом дереве ДФС. То есть, хочется показать, то есть, действительно, хочется показать, что вершина В
не будет доминировать W, тогда, на W, тогда и только там в исходном графе, тогда и только тогда,
когда и в новом графе она не будет над ним доминировать. Почему? А вот почему, кстати?
Так, ну да, заметим следующее. Во-первых, заметим следующее, что, то есть, давайте себе представим,
что мы сначе, давайте вот в одну сторону, да. Так, хорошо, докажем, что если была доминация в
исходном графе, то будет и в новом графе. Как мы это докажем? А очень просто. Давайте сначала
добавим вот эти ребра, а потом поудаляем старые. Потому что фишка следующая. Заметим, что когда
мы удаляем ребро, то старые доминации никуда не деваются, правда? Но от того, что мы удалили
ребро, удалили ребро не из дерева ДФС, то старые доминации никуда не деваются. То есть, может,
появляется новое. Это с одной стороны. Но с другой стороны, заметим, что я утверждаю,
что если мы в дереве, то есть, с другой стороны, заметим, что добавляем мы теперь в граф только
прямые ребра. Только прямые ребра. Но с другой стороны, заметим, что пусть у меня В доминирует
над W. То есть, пусть у меня В неожиданно доминирует над W, и мы неожиданно решили добавить какое-то
прямое ребро, благодаря которому оно неожиданно, то есть, оно доминировать перестает. Ну что это?
Ну вот. Ну с другой стороны, да. Хочется сказать, что это прямое ребро ведет из предко-вершины В
в потомко-вершины В. Ну вот. Сейчас, чего такого не бывает. Да, но нет, конкретно обхода, обхода
вершины В, конечно, но это ребро не может вести действительно из предко-вершины В в потомко-вершины В.
Действительно, нет. Ну нет, ЛЕМА-4 еще напрямую ничего не говорит, потому что это вершина
В. Поэтому более аккуратное рассуждение звучит так, что раз такое ребро существует, да, кстати,
этот потомок может быть как выше вершины В, так в принципе и ниже, но я пока нарисую выше,
там суть одинаковая. Значит, то есть, идея такая, то есть, если нашлось такое ребро, по которому мы
еще и В, то значит, что в исходном графе можно было пройти из этой вершины вот в эту вершину,
потому что что это такое, если это вершина КА, то это вершина в исходном графе С, да, мата. И это в
принципе означает, что у нас можно было из этой вершины В как-то попасть, причем по вершинам,
которые по таймы ну больше, чем А, а следовательно и больше вершины В. Но если потом из вершины А можно
попасть в В, ну либо потому что она предок, либо потому что она тут еще где-то там в поддереве,
или где-то там она вот под дереве W, вот такое тоже могло быть там вот. Вот, допустим, вершина А тоже
могло быть вот так еще. Вот, но суть одна. Но тогда из этого следует, что эта вот вершина В не доминировала
на W, потому что мы ее обошли. Понятно, да? Ну вот, то есть, противоречие. То есть,
если вершина В. То есть, таким образом у нас получается, ну вот, то есть у нас получается,
что это может быть, то есть, если у нас добавилось ребро, благодаря которому у нас вершина В перестала
доминировать на W, то это не ребро, которое ведет из родителя, из какого-то предка вершины В,
в какого-то потопка вершины В.
На самом деле, мы можем сказать, что у нас все доминаторы лежат на пути до корня,
а на пути именно по ребрам ДФС. Ну, тогда любой полудоминатор означает, что у нас существует путь
по ребрам, ну не только ребрам ДФС, который из А в В буквально. Если мы добавим такое же ребро,
а можно было проще сказать, что рассмотрим вот это ребро. Ну, по-разному можно. Ладно,
я повторяю просто предыдущие. Можно было сказать так, что заметим, что раз вершина В доминировала
W, то есть рассмотрим какое-то ребро. Давайте подумаем, рассмотрим всех доминаторов W,
давайте, вот они, все доминаторы. Теперь выскакивает вопрос, где это ребро, то есть рассмотрим какое-нибудь
новое ребро, такое вот ребро, которое мы добавляем из А в С дома от А. Внимание, вопрос. Где оно может
лежать? Где оно может лежать? Заверяй нот. Хотя нет, не очевидно. Пока, по-моему, легче не стало.
Да, поэтому приходится доказывать, что утверждается, что эти вот А и С дома от А, то есть это ребро не
может как бы вести из родителей какого-то доминатора В в А, не обязательно там непосредственно,
потому что мы только что это обсудили. То есть спрашиваешь, что это тогда может быть? Тогда
это может быть. Давайте это хоть доказать доведем, потому что, по-моему, те, кто сейчас не мыслит вперед,
они, по-моему, уже там должны были уже умереть. Вот, согласаются. Если такого обгона нет,
значит это либо ребро какое-то выше, очевидно, тогда на доминацию В оно никак не влияет. И тогда
либо нот. То есть либо тут вообще что еще может быть? Может быть оно ведет из предка вершины В
в какое-то тут под дерево отдельное, куда-нибудь вот сюда или там куда-нибудь вот сюда. Вот. И что-то
еще. Ну вот. Ну либо она вообще там, действительно, либо там полностью в потомках вершины В и так далее,
но во всех этих случаях это ребро не дает нового пути, который не проходит через вершину В. Почему?
Потому что во всех остальных случаях, если мы можем это ребро в пути заменить на, собственно,
путь по дереву ДФС, который не содержит В. То есть единственная проблема может быть, что из-за чего,
когда мы добавили новое ребро, В перестало доминировать В. Потому что мы прошли нот. То есть
мы прошли по этому ребру, обошли В. То есть путь от этой вершины до этой по дереву ДФС В должен
был содержать. Ну а так как это прямое ребро, то, соответственно, вот. Так что вот у меня было
такая дот. То есть у меня появилось вот такое доказательство. То есть получается, так, ну что
это мы, так значит еще, что мы доказали? То есть мы доказали, что, то есть мы доказали, что,
соответственно, если В доминировало В в старом дереве, то и в новом доминировать будет. Теперь
стоит только доказать, что если В не доминирует В в старом дереве, то и в новом дереве оно
доминировать не будет. Почему так? Значит еще раз, видите, то есть наоборот. То есть пусть теперь В в старом
дереве не доминировала. Вот оно, да. Что это в принципе означает? Вот, давайте. То есть это значит,
что да, существует. Да, то есть вот, соответственно, да. То есть вот у нас W. Значит, смотрите. Тогда
смотрите. Ладно, вершины В у нас на этом пути нет. Но какие-то предки вершины В на этом пути
обязательно существуют. Правда? Давайте рассмотрим. Значит, смотрите. Рассмотрим самый последний из них,
который у вас, у нас на пути встретился. То есть рассмотрим последнего предка на пути, который,
последнего предка В на этом пути, который у нас вообще встретился. Вот, допустим, он. Как путь пойдет
дальше? Вот. Что-что? Погоди, погоди, спокойно. Значит, смотрите. Тут идти такая. Просто как этот
путь пойдет? То есть этот путь как-то пойдет дальше. Но мне как-то вот, но мне как-то очень хочется
сказать, что этот путь... Ну, во-первых, заметим, что этот путь можно, там, по началу пути можно
просто заменить на вот это вот. Вот. Ну вот. А во-вторых, теперь идея такая. Давайте рассмотрим какую-нибудь
следующую вершину. То есть, раз это последний предок, давайте рассмотрим какую-нибудь следующую
вершину, соответственно, следующую вершину на пути. Нет, давайте рассмотрим следующую вершину на
этом пути, которая по таймыну не больше W. Поняли, да? Это, ну, это может быть сама вершина W. Вот. А
может быть кто-то еще. Ну вот. То есть, рассмотрим какую-нибудь следующую. Кем могла быть это
следующая? Ну, во-первых, я утверждаю, что эта следующая вершина должна быть предком W. Почему?
Ну, потому что, хочется сказать следующее, что если она, ну вот, что если она не является предком W,
то в дальнейшем пути какой-то общий предок у этой вершины W найдется. Правда? Пока это
ничему не противоречит. Ну вот. Ну, хотя, но вот, то есть, да, но вот, пока есть, но вот. То есть,
если зашла какая-то меньше, то найдется, то дальше какой-то общий предок с W обязательно
найдется. То есть, тут вот как-то вот так вот пошло. Оп. И там вот, вот как-то так. Вот. Ну,
теперь давайте смотреть, что на этих путях было. То есть, если, в принципе, ну вот, то есть, если у
нас, да, давайте смотреть, да, то есть, если у нас, так, наоборот, вот так и тут, соответственно,
вот так. Так, что у нас тогда здесь появится? Какой из этого вывод можно вывести? Ну, во-первых,
где находится этот общий предок? Ну, во-первых, этот общий предок не может быть предком вершины
W, согласны? Вот. Ну, потому что, да, иначе противоречие с определением вот этого вот,
там, действительно, последнего предка, которого мы встретили. Вот. То есть, значит, получается,
что мы нашли путь, который ведет из предка вершины W в потомка вершины W, который как-то эту саму
вершину W обходит. Видно, да? Но теперь вытекает вопрос. Только, есть ли на этом путь нот? Ну,
заметим, что если бы на этом пути все вершины были больше по таймыну, чем вот хотя бы вот эта
вершина, да, то тогда эта вершина была бы кандидатом W, правда? И получается, что в будущем дереве мы
ее обойдем. А теперь вытекает вопрос, а что, да вот, а что у нас тогда, действительно, делать,
если у нас на этом пути меньше вершина нашлась? Ну, могло ж так теоретически такое случиться.
Что-что? Так. Ну, можем, и что нам это даст?
Ну да, там на самом деле это следующее. В принципе, это означает, что раз у нас есть вот эта вершина
эта, то на пути между ними, очевидно, есть еще какой-то общий предок этой вершины, этой вершины, правда?
Вот. Поэтому можно сказать так, давайте на этом пути, когда вот дальше идем-идем-идем-идем, и рассмотрим
следующую, просто первую-первую же вершину, то есть рассмотрим первую вершину, которая является
предком W. Как вы уже сказали, эта вершина, она не является, то есть она не является выше, она
является ниже W. Но с другой стороны, если на этом пути была вершина по таймыну меньше, чем вот эта
вершина, то тогда между ними был бы еще какой-то предок, причем не совпадающий с этой вершиной.
Логично, да? Но потому что все потомки этой вершины по таймыну больше. Получается противоречие.
То есть еще раз. То есть давайте, если собрать эти мысли воедино, получается следующее. Вот у нас есть
какой-то путь, который идет из R в W и обходит W. Давайте мы этот путь сейчас будем упрощать.
То есть смотрите, упрощение номер раз. Рассмотрим последнего предка вершины W, который встретился на
этом пути. И часть, и первую часть пути заменим вот на вот эту цепочку по дереву DFS. Но это не важно,
на самом деле. Теперь дальше. После этого пойдем по пути и дойдем до первого на этом пути предка W.
Нет, ну сама W тоже является своим предком. Я не сказал, что собственной. Вот. Утверждение.
Назовем эту вершину там, допустим, U. Так вот, я утверждаю, что вот все эти вершины вот на этом пути имеют таймын.
То есть если вот назвать их там UIT, то я утверждаю, что таймын от UIT больше, чем таймын от U. Вот это я утверждаю.
Почему я это утверждаю? Потому что если какая-то нашлась промежуточная вершина по таймыну меньше,
то тогда на пути от нее до U есть общий предок, как мы уже выяснили. Вот. Значит, получается,
он является и предком W. Значит, либо эта вершина является потомком U, что невозможно,
либо мы где-то раньше должны были этого предка встретить. Вот. То есть получается, тогда отсюда
следует, что путь, во-первых, устроен как-то вот так. Понимаете, да? Да, кстати, вполне вероятно,
что этот путь проходит и через под дерево U, на самом деле. Да, и сам этот путь мог проходить,
войти в под дерево W, а потом как-то через обратные ребра высвисеть в W. Но это и неважно. Важно для нас
другое. Потому что вот эта картинка уже нам напоминает определение полудоминаторов, правда?
То есть я бы сказал даже так, что вот эта вершина, это еще не S-dom, но это кандидат.
То есть это кандидат в S-dom от U. То есть это означает, что в новом графе у нас в ребро,
то есть S-dom будет лежать либо здесь, либо выше, у нас тут появится вот такое красивое прямое
ребро, которое обойдет W. И W не будет доминировать на W. Что? Ну, значит, еще раз, смотрите,
был у нас исходный путь от R до W. Мы рассмотрели на нем последнего предка вершины W. Начиная с
этого последнего предка, мы рассматриваем путь. И рассматриваем не весь путь, а только путь до
предка W. То есть после этой вершины мы ищем первую вершину, которая является предком W,
назовем ее U. Сначала предок W, а потом предок W. Потом мы быстро убеждаемся, что U, во-первых,
не является предком W. А потом мы также быстро убеждаемся, что все промежуточные вершины на
этом пути тайпотаймыну больше, чем U. Почему? Потому что у нас там лемма есть, из которой бы следовало,
что там еще какой-то предок был. Тогда из этого следует, что мы получили какую-то вершину U
между W. Такую, что S-dom от U лежит выше, чем W. Почему выше? Потому что он, как минимум,
здесь вот кандидат. Что? Нет, у нас уже есть лемма, что S-dom это предок. Вот. Мы уже в это поверили.
Нет, ну давайте можем даже вспомнить, почему это обязательно именно предок. Ну да, потому что на
пути найдется общий предок, а он по тайпотаймыну будет меньше. Так что получается, что вот уже такой
кандидат. И получается, на самом деле, то есть видите, какая идея получается. Если мы нашли S-dom,
то если мы S-dom и нашли, то в принципе, то получается, что мы можем только оставить,
получается, 2n, то есть оставить только ребра из S-dom, то есть у нас там 2n-2 ребра останется. И
уже на этом графе вполне себе искать айдомы. Что-что? Да, граф теперь железобетонно-оциклический.
Это правда. Да, получается, да. Что у нас получается? 1 квадрат на 32, да? Нет, больше. А, но если это тупо
ДП, если честно, в оциклическом видео, то да. Но на самом деле этого делать не нужно. Но это,
нет, не волнуйтесь. Ну, потому что давайте, нет, тут надо просто действительно подумать. Давайте,
может быть, да, у меня тут, конечно, формально записано. Ой, у меня тут CRM есть, ой-ой-ой-ой. Ну ладно,
давайте, нет, хотя вот, то есть как сказать, да, то есть да, мне обычно нравится проводить, конечно,
эти лекции, да, что лекции в формате, что вот есть идея, давайте с вами все придумаем. Ну вот,
но иногда бывает так, а иногда бывает все, давайте честно пройдем по леммам, и так глядишь и понять
не будет. Вот. Но, впрочем, по-разному бывает. Но давайте вообще думать. Нет, ну, давайте,
вот сейчас, давайте, может быть, чуть-чуть подумаем. Подумаем, вот над чем. Вот идейно,
пока имеется, подумаем. Вот, допустим, нам С-домы известны, допустим, что у нас, ну да,
допустим, у нас С-домы известны. Как нам теперь хотя бы чисто теоретически найти,
найти айдом? Вот давайте подумаем. А я тут пока сотру. Так, ну я надеюсь, вот это уже можно стирать,
я надеюсь. Вот, вот давайте. Так, ну вот кажется, действительно, вот уже начинает, то есть начинает
быть что-то такое вот очень интересное на тему вот чего. Так, ой, что я тетрадку-то держу? Мы ж
думаем, зачем нам тетрадка, да. Так, вот. Значит, что мы имеем? Допустим, у нас есть такое вот прямое
ребро вот в С-дом, да. Можно, но, кстати, кратно даже ребро дерева ДФС, а может и нет. Но мы будем
считать, ну для удобно считать, что скорее нет. Ну просто промежуточных ребер нет. Вот, нет. Вот да,
потому что нет. У нас пока задача такая, предположим, что нам эти С-домы с небес по факсу прислали. Вот,
теперь возникает вопрос, как бы нам теперь найти айдомы? Ну тогда идея тогда, то есть у нас,
то есть у нас вот это вот есть прямое ребро. Значит, теперь мы говорим, так вот все эти вершины
обойти можно, да. Теперь возникает вопрос. Да, кстати, все ребра теперь идут вниз, поэтому ребра,
идущие откуда там, то есть как-нибудь идучие вот как-то вот так, они нас уже не интересуют,
что мы оттуда в W уже не выгребем. Вот, поэтому вывод такой. Так что, ладно, давай скажи.
Нет, ну это может быть точка сочленения, но при этом не доминатор, потому что вот какие-нибудь
вот такие ребра есть еще. Полнейшая точка сочленения, просто отвалится не эта компонента, а вот это.
Ой, мясо. Нет, ну, кстати, нет, может это и правда, но, как бы, честно скажу,
не очень хочется сейчас вспоминать о существовании точек сочленения.
Так, да, идем. Нет, ну не совсем.
Нет, ну там, может быть, идея такая. Допустим, вот дошли до этого. Значит,
удержение такое, если из этих вершин ни одно ребро не идет выше, то есть выше эта вершина,
то очевидно это и есть доминатор, правда. В противном случае тут нашлось какое-то вот такое ребро.
Возьмем из них самое высокое, тогда очевидно вот эти все промежуточные вершины, то есть это мы
тут нашли какую-то вершину w1 и у нее нашли вершину w1. Очевидно, все вот эти вершины,
да, уже доминаторами не являются. А является ли эта вершина доминатором? Ну что, тогда надо
перебрать опять все эти вершины, а точнее все только вот эти вот, и проверить, а нельзя ли из
нее скакнуть куда-то еще выше. Значит, пусть можно, тогда у нас w2, тут получается это, и так,
короче, скачем. Скачем до тех пор, пока не выяснится, что очередной шаг сделать нельзя. Как
только его сделать нельзя, тогда появится радость. Вот, тогда, ну вот, но смотрите,
как интересно, то есть на самом деле это даже похоже на скачки какие-то по деревьям, на самом
деле. Потому что, смотрите, потому что на самом деле приводит таскета к тому, что у меня даже
тут в теореме сформулировано. Да. Так, так, так, так, так. О, даже круче, у меня тут даже две теоремы,
на самом деле. Значит, две теоремы на эту тему звучат так. Так, во-первых, давайте формально
введем такое понятие. Будем говорить, что у стрелочка вот так вот, точка в, если у...
Черт, зачем мы это выводим-то вообще? Нет, ладно, для краткости, по факту это если у предок В,
и у с плюсиком В, если значит у собственной предок В. Да, да, да, да, да, да, да, да. Ну,
такие вот, да, но я не понял, но вот. Ну, как вы и хотим оптимизации надо было еще там DFS запустить
и от таймынов еще избавляться. Так вот, значит, теорема два. Значит, смотрите.
Значит, смотрите, пусть у меня W не равно R, и для любой вершины U такой, что значит у нас из этого
sдома от W можно дойти до U, причем U не равна sдому, вот. А из U можно дойти до W, вот. Пусть для любой
такой вершины U оказалось, что таймын от ее sдома больше либо равен таймын от, соответственно,
sдом от W. Тогда я не ожидаю, что я утверждаю. Да, тогда я утверждаю, что действительно, нет,
никакой, нет, не про предка я ничего не говорю. Тогда я утверждаю, что idom от W это тупо sdom от W.
Это теорема два. Доказательства, ну, вот оно, собственно. Чего?
Ну, смотрите. Ну, как всегда, может, я там опять это больше на меньше поменял, я не знаю. Поэтому
смотрите. Нет, написано там следующее. Смотрите, сейчас я просто покажу. Рассмотрим sdom. Пусть
неожиданно выяснилось, что у всех вот этих вот вершин, которые тут между ними, выяснилось,
что их sдомы лежат не выше этого. То есть как-то вот так вот, вот так и так далее. Вот. Тогда
утверждаю я, что полудоминатор W это есть sдом. Да, проверять это можно, ну, тупой вариант,
знаете, как проверять. Это, ну, например, двоичными подъемами. Нет. Нет. Ну, тут так вряд ли,
потому что тут, тут же еще, пока вы тут dfs-ом ходите, вы даете дожды. Ну ладно, если вы sдомы
уже знаете, то... Нет, погодите, погодите, погодите. Нет, 4 русских вам говорили, куда вы быстро
поднимитесь. А вот минимум на вот этом отрезке пути вам 4 русских не обещали, помнится. Да. Нет,
4 русских вам обещали минимум на пути, минимум на массиве, на этот отрезке, они вам обещали
там за за единицу подняться на любую высоту h. Но, боюсь, вот этот вот минимум даже статистически
они вам сразу не обещали. Нет, сейчас, подойдите, подойдите. Нет, подойдите. Так, давайте внимательно.
Фарах, Колтон, Беддер, что умели? Они умели решать задачу за n единицу a, искать минимум на любом
подотреске массива, во-первых. Ну вот, причем в полном оффлайне, да. И, во-вторых, они вам умели искать
lsa. Здесь нам нужно немножко другое. Здесь нам нужно, надо рассмотреть отрезок пути, и на нем,
то есть на нем тут написаны какие-то числа, и надо на этих числах найти минимум. По-моему,
у нас не было четырех русских, которые обещали вам это. Думаете? Нет, это, конечно, да, но, если
честно, мне не очень очевидно, что тут это. Но, с другой стороны, нет, ну как сказать, нет, если четыре русских,
сейчас эта приплитуция получится за линию, будет неплохо на самом деле. Потому что может вообще выяснить,
что мы сейчас с вами изобретем метод четырех русских, которые дерево-доминатор вообще за линию ищут.
Правда, причем я, честно говоря, да, может и можно написать, потому что мне лично не известно,
что так можно вообще. Нет, там понятно, есть еще sdm, который еще надо искать. Нет, ну тут, смотрите,
в принципе, у меня первая идея, которая тут возникает, смотрите, раз мы запускаем тут,
можно запускать dfs и строить на этих штуках вообще деревоотресков для удобства.
Ну да, а в деревоотресков тоже пушбэрить. А ну, пожалуйста, да, можно фенвик. Нет, стоп,
стоп, стоп, фенвик на минимум, стоп. Нет, погоди, хуже. Да, нет, тебе нужен минимум на суффиксе.
Кажется, фенвик у нас имеет минимум на префиксе, а не минимум на суффиксе. Так что лучше так,
может деревоотресков, а можно двоичный подъем, и суть одна. То есть, как бы, хотя бы n лог n.
То есть, мы чуть позже, но на самом деле, да, но это как бы вот эту проверку поможет сделать,
то есть, если такая проверка выплылась, то idum вот он, но есть, на самом деле, соседняя теремма.
То есть, пусть у меня, ну да, то есть, по сути, пусть вот это вот, и действительно окажется,
что пусть у меня, допустим, w штрих равно, как всегда, так, как это будет,
так, как это будет. Аргмин от таймын от esdom от u, вот мясо, да. Такое, что esdom от w,
стрелочка плюсик u, стрелочка точка w. Что? Это w штрих, да. Значит, пусть совершенно случайно
оказалось, что w штрих не равен esdom от w. Точнее, так, пусть оказалось совершенно случайно,
что действительно этот esdom от w, то есть, esdom от этого w штрих не равен вот этому esdom от w.
Тогда утверждаю я idum от w равен tupa idum от w штрих. То есть, на самом деле, да, эти две тереммы
можно было, конечно, в едино сформулировать, то есть, рассмотрим вот такую версию w. Есть у
нее esdom. То есть, получается, мы в любом случае делаем так, ищем минимум на полуинтервале,
так сказать. Ну вот, смотрим, ну вот, у него esdom. Если esdom у него, если esdom у него совпал с esdom
от w, то, ну, значит, тогда мы idum пишем как esdom. В противном случае мы берем эту вершину и от нее
запускаемся типа рекурсивно. Ну да, потому что, по сути, тут написано следующее. Я беру вершину,
с которой можно подняться как можно выше. Вот, ну и замечаем, что, как бы, ее обходить мы можем
только выше, поэтому там можно, по сути, рекурсивно запускаться от нее. Вот, поэтому,
в принципе, то есть, можно, то есть, на самом деле, действительно, то есть, уже мысленно можно
задуматься о том, что если у вас esdom есть, то idum вы найдете, то есть, idum вы, в принципе,
за n log n, получается, найдете. Можно, ну вот, можно еще чуть позже подумать, а как бы обойтись,
то есть, как бы обойтись без двоичных подъемов, а какими структурами типа everlink update.
Очередь с минимумом, да, ага, только она какая-то персистентная очередь с минимумом,
это не очень хорошо. Нет, ну там вопрос просто, как это все будет, то есть, как еще будет находиться,
как будет esdom, потому что они там тоже все не совсем с потолка сваливаются. Вот, хотя,
но да, но с другой стороны, ладно, в любом случае, так, не пришло время перерыва?
Вот, пришло, ну ладно, ну, до какой-то точки мы дошли, поэтому, да, давайте перерыв.
Так, смотрите, ну, во-первых, да, мы тут задачу практически свели к esdom, но единственное,
мы все-таки поговорим, как свести, ну, то есть, мы решали эту задачу, пусть у нас есть esdom,
как найти idem. Вот, так, ну, вот, ну, значит, соответственно, значит, будет, значит,
хочется все сразу обсудить, значит, задачу, как тогда, как находить по esdom idem, но хочется
свести это к структуре данных, которая как минимум в принципе умеет решать это быстрее,
чем этими вашими двоичными подъемами. Значит, делать мы это будем так, так, ну ладно,
это мы все уже можем брать. Значит, смотрите, допоминаю, у нас есть мистическая структура данных,
значит, у нас есть мистическая структура данных, everlink и, возможно, update, но в нашем случае
потребуется только структура данных everlink, значит, она нам потребуется, ну, то есть,
она там вводится на самом деле тоже там с операциями там вида it, которая там ассоциативна,
там что-то еще в этом роде, там еще там какие-то допусловия могут быть, вот, значит,
но everlink в нашем виде будет такая, смотрите, то есть, у нас есть вершины, они организованы
в какие-то подвешенные деревья и нам потребуется, и на каждой вершине написано число, которое в
процессе еще не меняется, ну, кроме корня, то есть, может меняться только корень,
ну, вот, значит, хочется уметь делать следующую операцию, во-первых, хочется уметь делать
операцию link uv, это означает подвесить корень к, соответственно, вершине v,
ну, естественно, не буду прописывать, но очевидно, подразумевает, что вершина v в под дереве u не
лежит, и хочется еще сделать такое eval от u, это значит найти argmin от вот этого вот,
val от, допустим, v на пути от u включительно до, сейчас будет немножко внезапно,
но это может иметь смысл, до корня не включительно,
так вот, допустим, мы, обратите внимание, нам очень важно, что мы ищем не просто минимум,
а где он находится, так вот, я утверждаю, что мы можем, по идее, свести, что мы можем решать,
если у нас s дымы есть, то я утверждаю, что i дымы мы с помощью этой структуры данных можем
найти за o от n плюс m плюс какое-то линейное количество вот этих вот операций, понятно, да?
m не менее чем n-1, поэтому по сути по m, то есть можно сказать, что асимптотика у нас будет
o от n умножить на там link плюс eval, можно там точнее сказать, сколько у нас там будет линков,
линков, понятно, будет там n минус 1 не более, а eval будет, наверное, чуть побольше, как мы это
будем делать, значит, смотрите, как мы будем именно сводить, будьте здоровы, спокойно, вот,
ну тут как раз ничего страшного нет, так, то есть, в общем-то, то есть половину страшного, на самом
деле, мы уже сделали, вот, да и ничего тут страшного нет, значит, смотрите, идея будет такая, я буду,
пусть у меня s дымы есть, да, по большому счету, смотрите, как у меня устроены запросы, то есть у меня
все запросы, которые я хочу сделать, это запрос, найди мне минимум от w до s дыма от w, правда,
логично, да, вот, то есть, причем напоминаю, все с дыма уже есть, надо найти минимальный s дым,
в чем по большому счету, вот эта теорема говорит мне следующее, что для каждой вершины w надо
найти, так сказать, вот этот минимум и, так сказать, найти вот этого вот предочка, правда,
нет, мы не ищем минимум под дерево, мы ищем минимум на пути,
нет, у нас вот идея, какая будет идея заранее, заранее будет идея такая, что, то есть,
для каждого w нужно найти вот эту штуку, правда, то есть, если мы вот эту штуку w эти найдем, то есть,
тут два варианта, либо w и стрелочка перейдет сама в себя, то есть, сама в себя это будет
в случае теоремы 2, либо это будет стрелочка вот, либо стрелочка в другую вершину, и тогда,
на самом деле, у нас появится вот такое дерево, даже лес, если быть точнее, и для каждой вершины
надо просто пойти тут просто до корня, потом в конце, и этот корень будет окажется доминатором,
понятно, да, это мы будем называть там дом от w, давайте эту вершину будем называть, нет,
просто практически так он, просто дом, это вот просто тариан так предлагает ее называть, то есть,
реально дерево мы так строить не будем, а просто для каждой вершины, на самом деле, просто там,
типа, если дом от нее равен ее, то значит и тут доминатор такой же, а в противном случае,
просто пойди в ее дом и, собственно, запустись к нему, какие-то ассоциации, что ли, вызывают?
Дом, смешное слово, да, так, ладно, страшные ассоциации, да, да, да, да, да, да, да, да,
то смешные шутки не заходят, то неожиданно начинается, ну ладно, не, ну знаете, иногда,
знаете, скажете, знаете, что это там типа, знаете, близкую грушу воробей не укусит,
а потом как, как вы сказали, и все, и все, там уроки в соседних колоссах парализованы, да, потому
что как близкую грушу чего, не так, да, это была не смешная шутка, да, ну нет, ну все говорят,
большую грушу вовремя не укусит, да, вот, да, правильно, а кто это говорит, да, никто, я только
что придумал, но вот этот вот загон, вот, вот, вот загона, кстати, действующий чемпион высшей
лидии КВН, между прочим, вот, ладно, так, значит, хорошо, значит, хорошо, это теперь вопрос,
как этот дом найти, потому что после того, как найти этот дом, получается, то проталкиванием
домов мы все айдомы найдем, вот, значит, вот такая красота, в чем там у Тарьяна даже красивая структура,
как это там потом в процессе, там все вообще там в одном ДФСе вообще будет, ну или практически,
нет, ладно, в одном ДФСе не будет, потому что дело в том, что айдомы мы будем искать в порядке убывания
таймына, внимание, именно убывание, обратите внимание, да, потому что идея будет такая,
потому что давайте так, во-первых, если мы знаем айдомы, то мы для каждой вершины можем записать
просто список всех вершин таких, что айдом это я, вот, про прям список, Тарьяна это называет
бакет, кстати, вот, поэтому идея будет такая, смотрите, вот у меня было тут такое, значит,
было у меня тут дерево ДФСа, изначально, да, вот оно, оно тут есть, вот так вот, как-то вот так,
вот так вот, так вот, так вот, так вот, теперь я буду собирать эти вершины в порядке убывания,
что значит буду собирать, это значит, что у меня изначально все эти вершины будут отдельные, да,
то есть я на них буду строить вот это вот, значит, я буду строить на них вот это вот, вот, то есть вот,
но изначально все эти вершины будут как бы висеть по отдельности, вот я сейчас просто перерисовываю
примерно вот так, как они тут были, вот, а дальше буду собирать их примерно так,
значит, я буду сначала обрабатывать эти вершины в порядке убывания таймин, то есть поработаю с
этой, поработаю с этой, поработаю с этой, потом поработаю с этой, в процессе работы,
подвешу к ней всех ее детей, потом поработаю с этой вершины, потом поработаю с вот этой,
повешу там всех ее детей подвешу не повешу вот да значит это это это да потом это это это потом
но потом вот так и так далее но смотрите что я могу теперь делать в процессе зачем я все это
делаю потому что дело в том что в процессе то есть у меня от каждой вершины есть из дома и поэтому
у меня идея такая для вот этой вот вершины теперь я могу перебрать все вершины значит все
вершины для кого она является с домом то есть вот все тут у нее потомки были какие-то но не
все по не всех потомков конечно просто кто есть да и для каждого из них теперь я в этом
дереве могу просто вызвать операцию ивал вот вот то есть просто я вот так вот под ладон подлавливаю
момент и вычисляю вот это вот дом но потом этот дом я соответственно доупихиваю вот так что вот
такая вот красота дом напоминаю вот что садри как мы ищем вообще вот согласно этим двум теоремам
полудо айдам то есть мы рассматриваем путь от с дома не включить на до дабл и включить на и
находим здесь вершину с самым высоким с домом вот вот ее я называю дом от дабл ее потому что
потом теорема то есть она либо оказывается самим дабл юй и мы тогда просто говорим что полудомина
то есть просто айдам это она есть либо она оказывается выше и тогда мы как бы не отсылает то
есть это мы называем дом то есть получается мы должны получается такое строим этот дом и
потом мы тогда то есть должны дойти теперь до корня и у этого корня взять эстом и это будет
айдам вот так вот я уже начал говорить на каком-то китам языке непонятно что какой из
который вот это вот сюжет и ну похоже да но учитывая что это тоже алгоритм тарья в общем-то
да как бы технологии одинаковые да так вот значит садрить то есть таким образом видите то есть
подвешиваем мы естественно с помощью линка вот ну и соответственно и вал мы вычисляем да тоже
в общем-то да даже не м получается нет конкретно эту часть мы вообще получается делаем за едва
ли не н потому что видите евалов то мы тоже в общем-то n-1 даже я бы сказал можно даже так
это конечно неправильно асимпатически писать но это получается n-1 линк плюс евал да но от
евала мы получили но если мы на каждой вершине пишем таймы его из дома да то получается что то
как бы евалом мы как раз вычисляем вот этот вот дом вот но после которого мы том за линию уже
собственно все айдам и найдем так что остается так что это мы запомнили а теперь остается самое
интересное как собственно найти из дома пока нам их сожалению просто присылали пока нам ну
просто присылали короче давайте разбираться значит как же нам найти из дома но как вы думаете
какая теория мы нам поможет сделать теория мы четыре совершенно верно да ну естественно да ну а
какая еще но по я не тут все теория мы это линга уэр тарьян или как он там ланшет как она ланша
что кто лан пусть будет линга уэр да ну ладно как вы эти да не обидится он на нас так а то знаете
как неловко будет прийти на конференцию он вполне себе живой и разговаривает да я думаю так я
пошел с тарьяном по ходу еще же там вполне себе можно встретиться с этим товарищем я думаю
подавно это иногда у меня полное ощущение что все потом все подобные родно парки вполне могли
быть учениками тарьяна это могла быть какая-нибудь там я из отчасти кандидат часть какой-нибудь пизди на
самом деле ну не обязательно конечно но вот нет умалее я почти уверен что скажем там строгая
куча фибоначи это точно была какая-нибудь пиздишка вот но мне так кажется хотя вот так но я не буду
повторять про строгую кучу фибоначи это мы с вами посуждали значит теория звучит так для любого
в дабл ю не равного эру не равного эру верно что значит шейт такое ух ты у ладно нет все нормально
с дом от дабл ю равен арк минимуму арк минимуму таймына от у где у лежит в объединении множеств
с1 от дабл ю и с2 от дабл ю где да ну естественно вот нет хочется конечно сказать что с1 это там
с2 это какой-нибудь там множество перестановок там на одном элементе но вот у вас еще нет там
теория группа какой-нибудь по всю как это да ладно у вас там должно быть эфем но
но что перестанут но это нет ладно нет если вы нет если вы там знаете теорию
глотвы это хорошо может вы мне даже расскажете так не знаете господи что ж вы там изучали так
я хотя ладно у меня что же была теория группе что тоже что-то изучал в чем хорошие что-то изучал
причем дай я в чем судя потому что у меня там стоял там какой-то отл 8 или отл 9 значит
наверное я ее хорошо изучал вот да чего не не не не ну на самом деле нет там там просто как это
такой теории не было но там там другой там все-таки вот это был такой курс когда 8 9 10
отличается на тем насколько там то есть совсем все ли задачи включая сложные вы там решите или
все-таки что-то для вас останется рабом вот поэтому там вот нет но собственно ладно кто
учился у богданова знаете что у него обычно всегда так да чего а лектор но у нас электросеминарист
все так вот значит с1 короче пока я тут значит да вот значит с1 это что так множество с1 это
такое что это такое множество в что ну просто короче w это ребро ну вот и давайте так напишу
таймы на тв меньше чем таймы от в ну логично да потому что есть потому что среди скажем так
среди кандидатов вездом и наверное есть просто вершины с меньшим таймином с которых просто
ведет ребро в нас но обычно эти ребра называются как они называют как таки ребра обычно
называются но обычно прямые или ну или ребро дерева dfs да но это просто они но логично их
учесть а вот что такое с2 значит с2 это множество таких вершин у таких что а нет вру вру вру вру
нет тут уже мы пойдем по-другому тут не у а тут с да мату нет не у а есть да мату в общем
смотрите у кого мы берем из общем короче так ну давайте уж напишу вообще во первых у дабл ю это
ребро но на этот раз таймин от в оказался то есть таймы но ой как тут все сложно
ой ой ой нет неправда смотрите значит есть ребро в вот так ладно так ладно по-моему
лучше написать как есть надежнее будет там это автор думал слова подбирал это называется во
первых смотрите начнем начнем с другого начнем с того что таймы на ту значит больше чем таймы
и значит существует такая вершина в что во первых из в в в ведет просто ребро
так и при этом еще что важно из у мы можем попасть в по дереву dfs
вот теперь хорошо так попробуем расшифровать да значит череза множество из 2 значит множество
из ну то есть по сути теория мы четыре говорить что алгоритм должен звучать так рассмотрим
вершину дабл ю рассмотрим все входящие в нее ребра если это входящее ребро ведет из вершины
с меньшим таймы нам то самую эту вершину и рассматриваем но если оказалось что это вершина
ведет не из предка в том числе родителя а откуда-то справа оба но вот откуда-то справа или снизу
да снизу тоже вариант то оказывается работает что-то такое смотрите вот давайте то есть работает
примерно так то есть вот жила была допустим вершина дабл и мы тут неожиданно откуда-то
пришли тогда идея такая давайте то есть предлагается нам тогда сделать так давайте
пойдем от этой вершины в так статида это ребро в таком случае окажется либо перекрестным либо
еще будет случай когда оно обратное но основной случай крышка данного перекреста тогда суть
такая предлагает нам этот алгоритм так давайте от этой вершины в честно пойдем
прям пора дите по предкам до тех пор пока не упрёмся в общего предка с дабл ю но очень
просто есть или что тоже самое рассмотрим тут все вершины на этом пути которые потаймы но
больше чем дабл ю но очевидно что это как раз вот до этого предка не включительно да и у всех
этих вершин мы рассмотрим что если мы да в том числе и у нас самой то есть там с дом тут вот
то есть рассмотрим как-то вот так то есть тут еще что-то такое тут куда-нибудь он может совсем
высь пошел там тут наоборот сюда но и так далее вот да только по сути да да правда не
включительно самолца вот то есть по сути утверждается что ровно это мы должны рассмотреть
понимаете да вот более того кстати обратите внимание на маленький приятный момент если мы
сейчас в это поверим то оказывается что ровно вон тем же вал линком на самом деле ищутся и
ищутся за счет маленькой приятной вещи потому что заметим что для того чтобы найти с дабл ю нам
нужно знать только с дамы вершин у которых таймын заведомо больше видно да то есть идея будет
такая то есть но то есть как бы то есть обратите внимание то есть все вот это вот оно вот если мы
применяем вот эту вот веселую технологию да то когда мы рассматриваем дабл ю вот когда мы
рассматриваем какую-то дабл ю то все вершины то в тот момент когда мы начинаем ее рассматривать
все вершины больше по таймыну на самом деле уже объединены в какие-то деревья так ладно у нас
понимаете да то есть поэтому вот эти вот минимумы на путях мы в принципе вполне можем
рассматривать spr scra guys
рассматривать то надо тот же самый минимум из дома который нужен был там понимаете да
то есть нам даже ничего тот есть не надо две функции поддержив었어 одну то есть получается
то есть на самом деле тут был n минус 1 и на самом деле тогда получается
что то есть на самом деле вот то есть ну то есть если мы поверим в эту теорему то на самом деле
нам потребуется то есть потребуется в эту технологию просто добавить не более чем м е валов
потому что абсолютно те же минимум вот потому что мы перебираем для каждой вершины все входящие
в нее ребра и как бы если она по таймену меньше то считаем ее если она больше то
берем минимум на этом пути понимаете да то есть вот получается если мы сейчас поверим в эту
теорию то есть поверивший в эту теорему мы получили алгоритм который ищет который сводит
задачу к эволинку понятно да так но теперь давайте собственно самое интригующее а почему же
вообще верно откуда же у нас такое счастье так да ну да да ну вот ну да заметим дистиле да
заметим маленькоб да то есть первое что очевидно это то что но то то что следующие еще что
что каждая вершина из этого мнfficial является кандидатом в полудоминатор до того теперь
увы твоей давайте вспомнить что такое полудоминатор и что когда кандидат вершины
является кандидатом полудоминаторы если из такое можно дойти до дабл и скольз Azk Kyoto
перемежуточных только вершины стоимы нам больше чем даamel и полудоминатор это кандидат в
полудоминаторы с минимальным таймином. Понимаем, да? Вот. Очевидно, что все эти
вершины действительно являются кандидатами в полудоминаторы. Очевидно?
Ну, действительно, да. Потому что, скажем, если взять какую-нибудь вершину
Эсдома от нее, то как бы из Эсдома от нее до нее мы доходим по тайминам
большим, чем она, но у нее таймин уже больше, чем здесь. И оставшийся этот путь
тоже по тайминам больше, чем здесь. Ну, а то, что есть один кандидат в полудоминаторе,
это очевидно. Остается доказать только одно. Остается только доказать, что истинный
полудоминатор действительно тут найдется. Но давайте разбираться. Но давайте рассмотрим.
Действительно. Так. Ой. Что ж такое? Так. Так. Ой. Так. Стоп. А, это он и есть, да? Ну ладно.
Ладно, давайте так попробуем. Так. Значит, смотрите. Жил-был. Значит, наш путь жил-был W.
Спрашивается. И был у него полудоминатор. Был у него тут полудоминатор. Почему зеленый? Да,
в принципе, почему бы и нет, но тем не менее. Так. Значит, был у него полудоминатор. И как-то мы из
этого полудоминатора в W дошли, причем еще и через вершины больше, чем W, правда? Ну, давайте
во-первых, если этот путь состоял из одного ребра, то очевидно, тогда эта вершина попала в S1.
Но если она тут шла как-то еще, то у нее была предыдущая вершина. Предпоследняя. Вот это вот W.
А у этой, ну вот. А у этой вершины, что было у этой вершины? А у этой вершины был, соответственно,
какой-то вот этот вот путь. Логично, да? Вот. Значит, какой путь? Ну, давайте вот что. Смотрите
давайте от этой вершины W. Ну, что логично. Рассмотрим. Давайте черный коричневый заменим,
а то писать невозможно. Так. Вот. Значит, вот давайте пусть. Это типа черный такой. Вот. Вот.
Значит, смотрите. У нас тут был вот этот вот путь от вершины W до там какой-нибудь LCA, да? Так,
куда-то это LCA ведет. Я не знаю пока куда. В общем, где-то тут S. В общем, жила была вершина W.
Значит, из S. В общем, был какой-то вот такой путь в LCA. Если брать вот этот путь от S. Я уж не знаю,
где он. Ну, где лежит S. Сам по себе. Ну, S. очевидно, лежит либо здесь, либо выше. Правда?
Согласны? Вот. Поэтому давайте вот тут. То есть, S. Допустим. Чего? Ну, заметил, что это вершина.
Ну, вот. Ну, скажем так. Эта вершина сама по себе кандидат в S. Поэтому реально S. лежит либо
здесь, либо выше. Да? Вот. Поэтому давайте для общего случая нарисую, что она выше. Так вот.
Так вот. Теперь идея такая. Значит, давайте. То есть, смотрите. Рано или поздно этот путь от S.
нам от W до W. Раз он проходил через вершину W. Раз у него последняя вершина W, то рано или поздно
этот путь окажется на этом вот пути. Правда? То есть, рано или поздно мы сюда придем. Так вот.
Давайте вот скажем, что мы тут ходили, бродили, ходили, ходили, ходили, ходили, бродили. И вот,
неожиданно, впервые оказались на этом пути. И это оказалась вот эта вот вершина. Давайте Uka
ее и назовем. Ну, заметим, что остальной путь, в принципе, можно не рассматривать, потому что
можно его просто заменить на вот этот вот спуск W. Правда? Ну, идейно. Вот. Но тогда заметим следующее.
То есть, заметим следующее. Тогда я утверждаю, вот мне почему-то жутко хочется утверждать,
что S нам от W. Ну, вот что, то есть, хочется тогда сказать, что не окажется ли S нам от W
случайно S нам еще от этого Uka. Ну, потому что вот хочется мне почему-то сказать такую жуткую вещь.
Вот, не кажется ли вам, что вот эти все вершины, они по таймыну больше, чем Uka? Да, это так. Вот
почему. Потому что пусть вот на этом пути где-нибудь образовалась неожиданно вершина,
у которой таймын меньше, чем таймын от Uka. Тогда у нас есть мистическая теория о том,
что где-то между ними найдется общий предок этой вершины и Uka. И этот предок, как всегда,
не совпадает с Uka. Понимаете, да? Ну, не может быть Uka предком вершины с меньшим таймына. Но тогда,
либо это. Но тогда мы вынуждены заключить. Что либо вот. То есть,
мы вынуждены заключить, что эта вершина либо попадет на… То есть,
она окажется предком Uka, то есть, либо она попадет на эту часть пути.
Но этого не может быть, потому что вот эта вершина такая первая по определению.
Либо, либо тогда окажется что, либо тогда окажется, что эта вершина у нас окажется где-то
это вот на вот этой вот части пути. Понятно, да? Что?
Вершина, которая с которой ты меньше, чем...
Сейчас, что?
Значит, вот это? Так, давайте лучше с нуля тогда.
У нас есть путь от w до w. Напоминаю, по определению
все вершины этого пути были по таймину больше, чем w.
W была последней из этих вершин.
W – это просто вершина, из которой мы просто сюда пришли.
Вот. Значит, тогда у нас идея такая.
Мы пока предположили, правда, еще и так не явно,
что W не является потомком w.
А в принципе такое могло быть, кстати.
Вот. Ну, мы ж могли там спуститься в потомка,
а потом по обратным ребрам подскакать.
Вот. Значит, смотрите.
Но пусть она потомком w не является,
этот случай мы потом отдельно разберем.
Тогда, смотрите, рассмотрим этот путь.
Смотрите. Рассмотрим на этом пути первую вершину,
которая является предком v, но не является предком w.
Вот. Понятно, да?
Нет, первая вершина – это не она, это вот эта она.
Вот. Ну, типа мы говорим, что после нее путь мы даже
для удобства заменим на просто спуск от ука до ве.
Утверждение.
Тогда вытекает утверждение, что все вот эти вот вершины,
все вершины на пути от этого s до w до ука
по таймыну больше, чем ука.
Почему так?
Потому что предположим, что найдется меньше.
Тогда на этом пути найдется собственный предок вершины ука.
Ну, если вот там промотать чуть-чуть.
Ну, во-первых, у них найдется общий предок на этом пути.
Ну, вот, во-первых, а этот общий предок будет автоматически
собственным предком ука.
Но кто это может быть?
Вот на этой части, из этой части предков, из этого пути
он быть не может по определению ука.
Потому что ука – это первая такая.
Но из этой части он тоже быть не может. Почему?
Потому что все эти вершины являются предками w, как следствие,
по таймыну они тоже меньше, чем w.
А у нас таких вершин на синем пути не было, в принципе.
Вот, да.
То есть, вывод.
То есть, вывод очень простой.
То есть, это означает...
Ну, вот.
То есть, это означает, что s до w является кандидатом
в полудоминаторы для ука.
Это что означает?
Это означает, что полудоминатор ука находится либо в s-доме,
либо выше.
Но если бы у него полудоминатор был выше,
то тогда я утверждаю, что и полудоминатор от w оказался бы выше,
потому что мы бы из этой вершины уже тут обошли бы...
То есть, нашли бы вот этот вот путь
по вершинам, у которых таймин больше, чем w.
Понятно, да?
Так, еще не совсем еще умерли?
Нет, нет.
Точно?
Да.
Вот.
Не совсем еще умерли.
Я вообще говорил, есть еще один случай, когда у нас w находится по дереве w,
но он рассматривается очень так же, там все рубожит тоже.
Сейчас, чего, чего, чего?
У нас формально w может быть по дереве w.
Да, единственное только минус в этом доказательстве,
что w может оказаться, в принципе, и в под дереве w.
Да?
Нет, ну, на самом деле, да, картинка будет то же самое,
просто эта лцашка окажется w.
Ну, давайте я просто то же самое...
Я сейчас просто нарисую то же самое, давайте, чтоб просто сомнений не было.
То есть, вот как-то вот так вот это тогда окажется.
Да, вот тот прикол, вроде больше нигде не пользовались, да.
Да, на самом деле, ладно, давайте в качестве упражнения, да.
Можно проследить предыдущие доказательства
и убедиться, что если этим лца оказался, собственно, w,
то ничего не меняется.
Да.
Кто-то это уже сделал, да.
Вот.
Ну, да.
Так что, да, можно соответственно проследить.
Так что, в общем-то, тирема оказалась несложная.
Тирема оказалась несложная.
И это означает маленькую приятную веру.
Ну, вот.
Ну, то есть, это означает, что тирема доказана
и, как следствие, алгоритм, который сводит нас к чисто линк эвалом,
на лицо.
Вот.
Так, сколько у нас времени осталось?
Сколько?
Десять.
Десять?
Да, двадцать минут. Сколько? Десять.
Пятнадцать.
А, пятнадцать. Ну, в общем-то, как тот же, на самом деле, да.
Вот.
Нет, тут вопрос как бы отдельный.
Просто, да, что тогда из этого...
Что тогда за оставшееся время рассказать?
Нет, смотрите, нет, просто...
Ну, да.
Ну, ладно.
Нет, выбор у меня простой.
Либо сейчас добить, на самом деле, двасатые...
Значит, двасатые эллеровые.
Либо...
Ну, просто за оставшееся время можно проговорить про линк эвал
и, собственно, доказать тирема о том,
что если вы делаете это просто тупо сжатием путей,
то это как бы суммарно будет работать
за n плюс m на логарифум n.
Вот.
Ну, второе...
Вот почему-то соблазнительно сделать именно второе,
но я, пожалуй, не буду этого делать,
потому что с СНМ-ом нам все равно придется еще разговаривать.
Нет.
Ну, как минимум... Нет, смотрите.
Что мы заведомо сделаем?
Это докажем, что СНМ работает,
а, за логарифом,
б, за лог-звездочка.
Вот.
Это относительно простые доказательства, да.
Что мне хотелось бы сделать дальше,
это, конечно, доказать про обратную функцию от тирмана.
Вот.
Вот так как эта единая работа большая,
то, пожалуй, не будем это делать,
а лучше, действительно, сейчас...
Соответственно, скажем так, в принципе,
про дерево доминатора, в общем-то, мы обсудили все.
Единственное, я только обсужу, что вот эти вот объединения,
как я уже сказал, то есть делаются...
То есть фактически алгоритм строится в два DFS-а.
Причем первый DFS вам нужен фактически
только для того, чтобы определить порядок таймынов.
То есть определить порядок таймынов,
и там, может быть, для каждой вершины
еще и там описать все входящие ребра.
Вот.
А дальше...
Ну ладно, второй DFS даже не нужен,
потому что дальше вы просто перебираете вершины
в порядке убывания таймына
и насчитываете...
И с одной стороны насчитываете айдомы,
используя бакеты.
А с другой стороны...
А с другой стороны перебираете кандидаты вездомы на будущее.
Вот.
Ну, точнее так, прямо сейчас
насчитываете айдомы,
и прямо в процессе, значит, соответственно,
в бакет этого айдома W
перекидываете W.
То есть таким образом,
когда вы дойдете до конца этой вершины,
то, в общем-то, там уже все в порядке будет.
То есть дойдет до этой вершины,
там уже полный бакет сформирован будет.
Получается такой там красивый алгоритм,
сводящий все вот к этому.
Ну, в реальности понятно.
В олимпиадном коде понятно, что легче там написать
дерево, отрезка, все это за N-логенчик.
Потому что вот этот линк Yawal,
там это не самая тривиальная структура.
Ну, вы, конечно, можете
ее написать тривиально, сожжать им путей,
это уже будет адекватно работать.
Но если вы там чуть-чуть пошаманите,
но это мы отдельно поговорим как.
Вот, соответственно, то там можно
и обратную функцию кирмана получить.
Вот. Никогда не слышал,
честно говоря, чтобы в олимпиадах от вас
требовали прям реально за кирма написать.
Ну, скажи так, я на Кодфорсе
видел пару задач на дерево доминаторов,
но там, по-моему, везде там,
собственно, там от вас там
быстрее, чем за N-логен
от вас не хотели.
Вот. Теперь.
Да?
Ну, так-то да. Так-то да.
Ну, обычно, да. Обычно мы с ним точка основного решения,
в общем-то, не в кирман укладывается.
В кирманы не укладывается, поэтому не глобально.
Вот.
Значит, оставшие все время
поговорим. Ну, во-первых, давайте поговорим
о задаче 2-сад быстренько.
Ну, конечно, быстренько поговорим, но
об чем у нас задача?
Ну, задача формулируется так.
Это задача из бот-логики.
То есть задача вида.
Дано N-переменных
и дана на них какая-то вот такая
булева формула.
В каждой скобочке находится
ровно две переменные
или их отрицание.
Вот. Как-то вот так вот это.
Там х2 или не х3.
Ну, вот что-нибудь такое.
Или там не х1
или не х4.
Ну и так далее.
Всего таких там, допустим,
N-переменных и на них там
M-скобочек.
Внимание, вопрос.
Выполнима ли
эта формула?
Ну, конкретно это, скорее всего,
да, действительно. Хотя все зависит
от того, что там за многоточием.
Да, если да.
Но вообще общая задача.
Выполнима ли формула? То есть существует ли
такие, можно ли подставить такие
булевые значения по всем переменам, чтобы
это было true?
Да или нет?
Сейчас.
Это называется два сад.
Почему это называется два сад?
Сад от слова
satisfiable.
Ну, в принципе, да,
удовлетворение, satisfaction.
Это от него.
Но почему надо это упомянуть?
Потому что эта задача является на самом деле
младшим братом,
или младшей сестрой, не знаю,
знаменитой задачей три сад.
Три сад.
Тоже самое,
только тут
в скобочках находится
по три.
Просто в чем фишка? Фишка заключает
в том, что эта задача
в теории
сложности вычислений занимает просто центральное место.
Потому что
это просто едва ли не главная
и полная задача.
Вот.
Ну, вкратце,
есть знаменитая проблема,
верно, лишь что P не равно NP.
Ну, что такое PNP?
Ну, ладно,
если не вдаваться
во всякие совсем тонкости про машинчуринга
и так далее, то суть такая.
Мы говорим, что
есть задачи, которые решаются
за полиномиальное время.
А есть задачи,
например, которые
теряются за полиномиальное время.
Типичный пример,
например, это задача о раскраске графа
в три цвета. То есть данный ориентированный граф.
Можно ли его раскрасить в три цвета,
так чтобы любой ребро
соединяло вершины разных цветов?
Просто да или нет.
Эта задача принадлежит классу
NP.
По определению,
это означает следующее, что если ответ
да, то существует
сертификат,
который
доказывает, что ответ на эту задачу
да. В данном случае просто раскраска.
Если вам дана раскраска,
вы можете проверить, хороша ли эта раскраска
или плохая.
Или
соответственно задача 3-сад.
Это задача,
если да, то вам существует
просто набор из 0 и 1,
который вы можете тупо проверить за полиномиальное время.
Обратите внимание, в этой теории, кстати,
если это полиномиальное, то сплевать за какое конкретно.
Оно может быть там n в пятой,
n в сотой, n в миллионной, какое угодно.
Главное, чтобы
n в степени константа.
Если константа там 57 в степени 179,
никого не волнует.
Потому что это все равно быстрее,
чем 2 в степени n.
Да, на практике нет,
реально, но теоретически да.
И соответственно ключевой вопрос,
они являются,
являются ли эти классы задач
одинаковыми?
То есть существуют ли задачи,
которые
являются,
которые лежат в классе mp,
но при этом не решаются за полиномиальное время?
Нет, так вот, наука, проблема
пока стоит, она открыта.
А вы
уже говорили об этом?
А, господи,
что вы здесь?
Нет,
если я то, что говорю, вам уже рассказывали,
то не будем тратить время.
Обычно просто рассказывается
на сложности вычисления.
Вам ведут более аккуратно,
что там конкретно
машину тюринга и так далее.
Но
теория там дошла до следующего.
Потому что там существует в классе mp
самые сложные задачи.
Они называются, по-моему, mp трудные.
Но нет, есть понятие mp трудное,
есть понятие mp полное,
это не совсем одно и то же.
Но суть там говорится такое, что
если p не равно mp,
то тогда в mp без p лежат
вот эти mp трудные задачи.
Потому что любая mp задача
сводится к mp трудной.
Так вот, одной из таких задач
является задача 3.sat, а также про раскраски
и так далее.
Но там несколько таких задач.
Поэтому вот эту задачу, если вы научитесь
решать хотя бы за m в миллионной,
то как бы человечество будет
очень-очень-очень сильно благодарно.
И это тоже,
потому что какую-то премию тюринга
вам обязательно выручат.
Другой вопрос у человека,
что пока ничего в этом смысле не умеет.
А вот 2sat, это ее младший брат,
и он решается
не просто за полюном,
а тупо за линию.
Но я не знаю, алгоритм это Тарьяна
или нет, но решение
оказывается неожиданным.
Но давайте его проговорим аккуратненько,
потому что там мало ли
технических деталей. Идея такая,
заведем 2n переменных,
каждый из которых соответствует своей переменной
или ее отрицанию.
Вот 2n переменных всего.
И дальше
аккуратная идея такая.
Мы теперь замечаем,
что на самом деле x1
или x2 это эквивалентно
такой формуле,
как что из не x1 следует x2.
На самом деле да, это
эквивалентно еще вот этому. Из не x2
следует x1.
Предлагается сделать так.
Для такой скобочки мы просто добавим
вот такие 2 ребра, ориентированных в граф.
Вот, x3 и x4.
Но тут соответственно значит,
из не x3 будет следовать не x4,
а из x4 следовать x3.
Так, x2 не x3,
но то же самое.
Дальше там что будет? Из x1
у нас теперь будет следовать не x4,
а из x4 следует вот.
Вот по такому принципу рисуем ребра.
Теперь идея такая.
Не получилось ли у нас в процессе,
что, ну потому что заметим,
что если из вершины в вершину есть путь,
значит имеет место следствия,
по цепочке.
Поэтому если оказалось,
что случайно из x1 следует
допустим отрицание и наоборот,
то тогда из этого следует,
что формула невыполнима уже заведомо.
Как это выяснить? А очень просто.
Ну, по крайней мере сделать такую проверку очень просто.
Давайте в этом графе найдем компоненты
сильной связности и проверим,
не оказались ли какая-то вершина
в своем отрицании в одной компоненте.
Если оказалось, значит фейл сразу.
Более продвинутая утверждение
говорит о том, что если не оказалось,
то тогда, значит,
формула выполнима
и более того достаточно легко
привести, даже построить
конкретный пример.
Пример строится так.
Ну, во-первых,
эти компоненты
с сильной связностью можно, как мы уже помним,
топологически отсаксировать.
Логично, да?
Так вот, рассмотрим
самую, допустим, правую половину.
То есть правую часть.
Смотрите.
Значит, смотрите,
в этом множестве нету
ни одной переменной
вместе со своим отрицанием.
Тогда идея такая. А давайте-ка
всем этим вершинкам
присвоим true.
Тогда автоматически найдется
еще одна компонента
сильной связности, которая содержит
в точности отрицание всего вот этого.
Логично, да?
Прям в точности отрицания.
И более того, из этой вершины
ничего не выходит, а в эту вершину
ничего не входит.
Да, тут автоматически тут тоже
нули, вот это все синхронно.
Тогда я утверждаю, что все стрелочки,
связанные с этими вершинами,
они автоматически удовлетворены.
Потому что либо это внутренние стрелочки,
из один следует один, из ноль
следует ноль.
Либо это исходящие из нуля,
все исходящие из нуля true
и все входящие в один true.
То есть получается мы
выкидываем эти компоненты,
из рассматривших они уже удовлетворены.
Чтобы мы там дальше не ставили.
Но теперь дальше что мы делаем?
Идем дальше, идем здесь, идем в следующую
вершину, которая тут свободна,
тоже тут рисуем один, тут рисуем ноль,
потом идем в следующую, тут рисуем один, тут рисуем ноль.
Получается,
короче, за линию мы победили.
То есть так решается задача 20.
Ну, тут в общем-то несложно.
Так, есть ли тут какие-то вопросы?
Так, ну тут нет.
Наверное, подробнее рассматривать нет смысла,
сколько у нас там времени.
Ну, пока нас не выгоняют.
Ну, давайте так.
Нет, вот дальнейшее все будет зависеть
от другого. Скажите, пожалуйста,
а что такое Эллеров цикл, и когда он существует,
вы изучали на какой-нибудь дискретке?
Или там тачешки?
Нет, ну в школе-то было.
Ну, давайте так.
Так, давайте, кто знает, что такое Эллеров цикл
в графе?
Ага, так, то логично, да?
Так, что такое Эллеров цикл?
Да, нет, ну в том плане, ладно,
давайте быстренько 5 минут потратим,
просто чтобы потом к этому не возвращаться.
Ну, давайте так.
В чем у нас заключается задача?
Задача заключается в том, что дан, допустим,
неориентированный граф,
и хочется найти путь,
который по каждому ребру
проходит ровно один раз.
А лучше цикл.
Ну, возникает простая теорема.
Теорема заключается в том,
что в неориентированном графе,
например, Эллеров цикл
существует тогда и только тогда,
когда...
Да, хочется сказать, что степень
каждой вершины четная?
Нет, не верно.
Нет, тоже не верно.
Да, нет, точная формулевка такая.
Эллеров цикл
в неориентированном графе существует тогда
и только тогда, когда А, все степени
вершины четные,
и Б, все ребра лежат в одной компоненте
связанности.
Ну, потому что изолированная вершина есть.
Вот такая мелкая формальная подлятка.
Вот.
Ну, там, мало ли, просто там на экзамене
встретитесь с каким-нибудь вредным формалистом.
Ну, вот он вас из-за этого
наперездачу отправит.
Ну, в зависимости от настроения,
честно, да.
Ну, скажем так, ладно, обычно
таких проблем не возникает.
Но теперь возникает вопрос.
И мы знаем, что Эллеров цикл существует.
Но тут, как бы у нас...
Да, понятно, в школе, где-нибудь в седьмом классе
вы могли это доказать, там вида...
доказательства, там могло быть вида, что давайте
стартуем из какой-нибудь вершины и будем
просто жадно набирать ребра, пока не упремся.
И мы знаем, что мы, как бы,
упремся куда?
Ну, упремся мы только в стартовую вершину.
И то еще из нее тут походим,
походим, да. Ну, и там подсчетность
очевидна, что в каждой вершине, кроме нее,
следующее ребро обязательно найдется.
Там окажется, что найдем цикл,
если он покрыл не все ребра, то там
выходим, выходим еще тут цикл
этот вешаем и так далее.
Но тут просто важно знать, как это сделать так,
чтобы это все красиво работало
за линию.
Значит, за линию это работает
примерно так. Запускаем
DFS.
Значит, смотрите, то есть запускаем DFS,
но DFS будет хитренький.
Значит, он не будет в вершине
хранить юзид, то есть мы в одну вершину можем
ходить несколько раз.
Но при этом мы следим,
что мы не по одному ребру
не прошли
много раз.
То есть юзиды у нас
помечаются не по...
То есть юзиды у нас помечаются
не на вершины, а на ребра
в обе стороны.
Понятно, да?
И более того, в каждой вершине еще и
на самом деле стоит указатель,
типа до какого ребра
мы уже дошли.
Ну, потому что мы же обычные списки смертности перебираем,
правда?
Так вот.
И тогда идея алгоритма
оказывается такой.
Значит, мы запускаем DFS, который
выходит
из вершины только если...
То есть DFS
всегда входит в любую вершину, которую надо,
но если он выяснил, что ребра закончились,
тогда он из нее выбрасывается.
А если выяснится, что
ребра еще не закончились, значит он
по этому ребру обязательно
выбирает указатель и по этому ребру
вызывается.
Ну, если, конечно, это ребро не было
обойдено в другую сторону.
Да, это важно.
Да, в неориентированном такой случае есть.
Так вот, идея такая.
DFS так обходит ребра.
Ребра эти добавляются в стэк, в стэк, в стэк,
в стэк, в стэк, в стэк, ходили-ходили,
бродили-бродили, бом, ходили-бродили,
ходили-бродили, и вот мы
наконец там
уткнулись в это ребро. И дальше хода нет.
Тогда мы выходим, наконец,
рекурсивно из этого ребра.
И, внимание, это ребро
торжественно
добавляем
уже в ответ.
Что будет происходить дальше?
Ну, то есть идея такая. То есть каждый раз,
когда мы из ребра выходим
из рекурсии, значит мы его добавляем в ответ.
Ну, тогда будет что
происходить? Он тут еще походит, походит,
походит, походит, походит.
На этот раз выяснится, что
он уже уткнется именно в эту вершину.
Ну,
потому что только в ней
на момент втыкания будет
четное число ребр незадействованных.
И тогда, когда из ребра выходим,
тогда добавляем это ребро.
Остается только несложно показать,
что, во-первых, все ребра
в этот цикл войдут, а во-вторых,
что самое важное – это будет действительно цикл.
То есть таким образом,
то есть как это не парадоксально, несмотря на отсутствие
юзеров по вершинам, алгоритм
будет работать за отъем.
Чего?
Не совсем правда, что у нас указатели
именно по спискам смежности, потому что нам
нужно пометить не только то, что мы
ударили. Ну, короче, нужно
ввести массив юз для ребра.
Ну, нужно ввести массив юз для ребра, да.
Да, то есть понятно, что мы здесь
не только указатель помечаем, но и для каждого
ребра помечаем, ходили мы по нему или нет.
Да, в ориентированном графе
будет чуть проще, потому что
если у нас
здесь вот такое ребро, то по нему в обратном
направлении мы пройти не могли.
Но, кстати, в ориентированном графе
конечно все было сложнее.
Потому что в ориентированном графе
эллеров цикл существует, если
во-первых, все ребра
принадлежат одной компоненте сильной связности,
во-вторых, у каждой вершины
входящая степь
равна исходящей.
Ну и тогда доказательства алгоритм
такой же, только единственное, что цикл
будет в обратном порядке, потому что мы ребра
в порядке такой ориентации добавляем.
Вот. Так что вот это просто хотелось
быстро упомянуть, чтобы к этому не возвращаться.
Надеюсь, у вас там, если вам
потребуется найти эллеров цикл, то проблем у вас
не будет.
Так, ну что ж, тогда на этом все.
Ладно, в следующий раз займемся чем-то кроме DFS.
Да.
