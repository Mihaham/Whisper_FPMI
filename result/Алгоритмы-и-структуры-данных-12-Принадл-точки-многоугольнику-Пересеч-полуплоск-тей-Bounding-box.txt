Значит, у нас сегодня две задачки.
Первая – это проверка принадлежности точки многоугольнику.
Задача очень просто ставится.
Есть некий многоугольник, не обязательно выпуклый.
Есть какая-то точка на плоскости.
Нужно для неё понять, лежит она внутри многоугольника
или не внутри.
Первый способ, ну, нулевой способ, который не всегда
работает только в случае, если многоугольник выпуклый.
Выпуклый многоугольник.
Тогда можно сделать следующую штуку.
Давайте считать, что у нас многоугольник так задан,
что его нулевая вершина – это левая нижняя.
Ну, как обычно, когда мы строим какую-нибудь выпуклую
оболочку, у нас всегда нулевая точка – это самая левая
среди таких самая нижняя.
Вот.
Тогда давайте нарисуем вот такие вот лучи из нулевой
точки во все вершины многоугольника.
И попытаемся понять, в каком из образовавшихся углов
лежит наша точка.
Соответственно, эта точка лежит в этом угле между
вот такими двумя лучами.
Это можно очень легко сделать бинпоиском, потому что вот
у вас есть такой развернутый угол, внутри которого точно
точка должна лежать.
Если она, заведомо, не внутри этого угла, то, значит,
она точно не в многоугольнике.
Дальше вы бьётесь пополам, скажем, вот берёте середину,
проверяете, она лежит здесь или здесь, ну и, соответственно,
переходите либо сюда, либо сюда.
Да, поэтому просто бинпоиском однозначно можете за алгорифм
понять, между какими двумя соседними лучами должна
точка лежать.
Дальше, если вы поняли, какие два соседние луча
вам нужны, в конце вам нужно просто проверить, лежит
ли точка вот в таком треугольнике.
Но проверить точку на параллельность треугольника уж как-нибудь
мы сможем.
Да, значит, кратко давайте напишем.
Рассматриваем все лучи из нулевой точки, из нулевой
вершины, бинпоиском находим два соседних, между которыми
должна лежать точка, ну, точнее, между которыми
она лежит.
И в конце проверяем, что точка лежит в треугольнике.
А симптотика – алгорифм, потому что просто бинпоиска
здесь внутри от единички, нам нужно, чтобы проверить,
что лежит на треугольнике.
Значит, способ чуть лучше, а оно тоже не идеальный.
Значит, теперь уже все, мы отказываемся от предположения,
что многоугольник выпуклый.
Первый многоугольник может быть любой, но на самом
случае выпуклого многоугольника вот мы решили, и это самый
крутой алгоритм, лучше мы не надеемся ничего получить.
Значит, что делать с невыпуклым?
Можно, например, сделать следующее.
Давайте мы порисуем те углы, под которыми видны
стороны нашего многоугольника, причем эти углы будем считать
ориентированными.
То есть мы пройдемся по границе многоугольника
по всем сторонам и будем мерить вот эти уголочки.
Вот этот угол проверяем, вот этот угол, вот этот,
вот этот.
Вот этот у нас будет с отрицательным знаком.
Потому что мы начнем вращаться в другую сторону, потом
этот опять с плюсом, этот опять с плюсом.
И все просуммируем.
ну и грубо говоря понятно, что если у нас точки
�!! в многоугольника, то там сумма углов должна
быть два ПИ или минус два ПИ,
смотря в какую сторону мы крутились.
Вот я на самом деле не уверен, что там будет ровно два ПИ
или минус два ПИ, возможно там что так радное
двум ПИ будет.
Потому что если на угольник какой-нибудь там сильный
вот такой закручен, то, возможно, там будет типа 4p или что-то
такое.
Но я не уверен.
Кажется, нет.
Нет, на угольник простой.
Тогда 2p, да?
Вот мне тоже, но я без понятия как это доказывать, поэтому
не ручаюсь.
Ну и соответственно, если мы все углы эти ориентированные
просуммируем, то понятно, что если мы были внутри,
то мы как бы вот так вот полностью обошли точно
по крайней мере один раз круг, а если бы мы были вне
многоугольника, то мы просуммировали все эти уголочки, ну и как
бы, грубо говоря, наш угол вот так вот как-то дергался,
ну понятно, что он суммарно пройдет ноль.
То есть он сначала как-то сюда повернулся, потом сюда
вернулся в исходное состояние, не прокрутившись при этом
на 360.
Поэтому, значит, находим ориентированные углы до
всех сторон, складываем.
Если получился ноль или примерно ноль, то говорим,
что точка снаружи, если не ноль, то внутри.
Если сумма примерно равна нулю, то снаружи.
Ну я здесь пишу примерно, потому что там, когда вы
ищете угол, у вас точно будут всякие неточности,
там какие-то погрешности будут, ну там ровно ноль
вы никогда не получите, но что-то близкое там даст
точность, не знаю, 10 минус 5, 10 минус 4, точно у вас будет
ноль.
А если она внутри, то там сумма будет около 2p, ну
то есть вы как короче ноль и 2p вы точно уж различите
как-нибудь, поэтому внутри и вне как-нибудь мы сможем
здесь распознать.
Значит, единственное, что я хочу сказать, как лучше
всего находить угол, да, угол, ориентированный угол
при стороне какой-то, под которой видна сторона.
Ну вот если это векторы a и v, то лучше всего написать
атан2 или даже атан2l, кросс и дот.
По моему опыту самая точная функция, которая вычисляет
угол между векторами, да, то есть мы могли бы скажем
просто взять колярное произведение и поделить
его на длины и взять аркосинус, или там наоборот взять векторное
и поделить на длины и взять арксинус, но это как бы
еще более точная штука, которая как бы по этому и этому
наиболее точно, в общем, как может старается извлечь
собственно сам угол вот этот вот, ну и собственно
его лучше всего использовать, если мы хотим как можно
меньше точности терять.
Вот, носим точку, конечно, линейная по числу вершин
многогольника, но недостатки здесь тоже весьма очевидны.
Это тригонометрия, тригонометрия проблема, что, во-первых,
все эти функции довольно долгие, но вот это атан2,
он довольно долгий, во-вторых, ну вот есть какие-то погрешности
и с ними возиться не очень хочется.
Итак, напишем, недостатки, тригонометрические функции
работают долго, ну по крайней мере, дольше, чем, не знаю,
всякие произведения и так далее, и позволяют, ну
как бы, и порождают погрешности.
Ну это так, весьма условно недостатки, в принципе мета
стала нерабочей.
Так, ну и следующие две вещи, которые я хочу сказать,
они работают, когда у нас все целочисленное, то
есть вот это у нас в принципе работает, когда и все вершины
не обязательно целочисленные.
А если нам известно, что все координаты целые и мы
хотим это сохранить, да, не хотим переходить в даблы,
тогда вот работает второй и третий способ, значит,
работает, если все координаты целые.
Значит, ну вообще идея такая, что давайте мы выпустим
из нашей вершины некий луч и посчитаем его число
пересечений с границы ногогольника, то есть сколько раз он пересекает
сторону.
И как бы, ну понятно, что если он пересек нечетное
число раз, значит, он изначально был внутри, да, потом вот
так пересековался и вышел, понятно, что бесконечная
далекая точка должна лежать вне ногогольника.
Значит, если здесь нечетный число раз, то, наоборот,
идиазбесконечности мы чередуясь, попадаем внутрь, а если
он пересек, скажем, четное число раз, ну что-нибудь
вот такое я нарисую, два пересечения, то он, значит,
был изначально снаружи, потому что прочередовался
и остался такой же, как был, значит, был снаружи.
Вот, то есть наша задача – это посчитать просто число
пересечений со сторонами и, ну, как бы, по чётности
понять внутри или вне.
Значит, в общем, это такое, что мы пускаем луч, считаем
число пересечений с границей, если нечетно, то внутри.
Если чётно, то снаружи.
Вот, но здесь надо ещё аккуратно разобраться с точками,
которые лежали на границе, давайте вот про границу
мы тоже отдельно скажем, что ещё перед тем, как пускать
луч, отдельно проверим принадлежность нашей точки всем
сторонам нашего ногогольника, то есть отдельно по всем
отрезкам пройдёмся, проверим, лежит ли точка на отрезке,
если хотя бы одна ноль лежит, то значит, она на границе.
Иначе, вот это вот, ну, как бы, количество там точно
можно посчитать, да, не возникает случаев вот таких,
когда точка сама лежит на стороне, это не очень
приятно.
Поэтому отдельно проверяем, не лежит ли она на границе.
Да, значит, проблема в том, что луч может проходить
через вершину, и тогда не очень понятно, как это
учитывать.
Мы с вами ещё порисуем много картинок, чтобы понять,
как это всё учитывать, но вообще по умолчанию, если
мы скажем, ну, вот здесь, если бы мы проходили вот
так через вершину, то это как будто бы мы вообще
не пересекаемся с многогольником, потому что мы вот так коснулись,
ну, как бы, по касательной прошлись, и как бы не зашли
в него, то есть это как бы надо не учитывать как пересечение.
Хотя вроде это как точка пересечения, да, с границей
не очень понятно.
Вот.
Вот тут, ну, типа, а если, а если наоборот, а если
вот такая картинка, если такая картинка, вы проходите
через вершину, учли два раза, на самом деле надо
один раз.
В общем, тут надо аккуратно с вершинами разобраться,
мы это сделаем ещё на чуть позже.
Проблема действительно такая, что, что делать,
если луч проходит через вершину?
Ну, решение здесь весьма прозоичное, давайте просто
подберём такой луч, который через вершину заведомо
не проходит.
Самое тупое решение, это давайте пускать какой-нибудь
случайный луч, да, выпустим случайный луч, но если мы
хотим, чтобы всё было целочисленное, давайте просто выпустим
там луч со случайными координатами, со случайным
направляющим вектором.
Проверим, что на нём нет ни одной точки, в смысле
одной вершины.
Если нет, то, ну, зашибись, да, мы дальше делаем вот
это.
Либо мы можем заведомо подобрать такой луч, на
котором ни одна точка не лежит.
Значит, во-первых, это случайный луч, ну, и соответственно
генерируем в случайную пару координат, там A-B,
давайте не A-B, давайте Х-эгрид.
Генерируем случайный направляющий вектор нашего
луча до тех пор, пока на нём есть хотя бы одна точка.
Если нет, то значит хороший луч.
Вот.
Ну и во-вторых, скажем, если мы знаем, что все координаты,
ну, например, целые от 0 до A, если координаты всех
точек целые в отрезке от 0 до A, то подойдёт луч с
вектором, ну, например, A, A плюс 1.
Вот я утверждаю, что если пустить такой луч из нашей
точки, то на нём никакая вершина быть не может.
Вот здесь там что-то такое есть, есть наша вершина,
мы пускаем вот такой вот луч.
Ну, очень-очень легко понять, почему здесь не может быть
координат.
Потому что если это какая-то точка, то на этом отрезке
от точки до, ну пусть это будет П, а это будет П плюс
вектор А плюс 1.
На этом отрезке никаких других целых точек нет,
потому что координаты этого вектора взаимнопростые,
если бы здесь была какая-то другая точка, то значит
эта штука была бы делителем этого вектора, а у него
нет делителей с целыми координатами, да, потому
что здесь взаимнопростые координаты, значит здесь
просто целых точек нету, ну и эта точка уже заведомо
лежит вне нашего многоугольника, потому что мы лежим в квадрате
а на а, а эта точка имеет координаты хотя бы а плюс
один второму измерению.
Значит, здесь никаких, конечно, нету, просто потому что
они все были целочисленные, ну значит, лучше заведомо
хороший.
Окей?
Вот, ну вроде все, опять получили линейный алгоритм,
да только он уже все считает в целых числах и не переходит
к доблам.
Еще раз?
Ну типа того, да.
Ну то есть такое универсальное правило, оно на самом деле
довольно бесполезно на практике в том плане, что как бы обычно
если вы там пишете какую-нибудь геометрию, то у вас там сразу
все гранаты могут быть добловские, да, но если вдруг
у вас все происходит в какой-нибудь сеточке, вы знаете, что координаты
всегда целые, ну такое в принципе тоже реально, вот,
тогда вам как бы хочется, чтобы у вас ответ всегда
был точно.
То есть если у вас все изначально целое, да, у вас нет погрешностей
в задании входных данных, ну значит и ответ наверное
можно считать точно.
Ну вот, пожалуйста.
Да.
Да, да, смотрим пересекается ли сторона с лучом, считаем
число таких причин, если не чего-то, то внутри, если
чего-то, то снаружи.
Так, ну и значит третье, вот давайте теперь честно
разберемся с вершинами.
Честно разберемся вот с этими плохими случаями,
когда луч проходит через вершин.
Значит давайте я буду для удобства пускать горизонтальный
луч.
Горизонтальный луч вправо.
Так, ну, боже не, пусть будет вот такой.
Пускаю горизонтальный луч вправо и давайте сейчас
честно пойму, что делать с вершинками, так чтобы,
ну короче, правильно учесть все вот эти случаи, да, правильно
учесть случаи вершин.
Значит утверждается, что работает следующий алгоритм.
Ну мы точно так же проходим по всем сторонам.
Значит перебираем стороны, перебираем стороны, пусть
отрезок А и Б это очередная сторона, ну то есть А и Б это
две точки, я точки маленькими буквами тоже буду обозначать.
Значит А и Б это очередная сторона, причем А и Y меньше
и равно B.Y.
То есть я взял очередную сторону и так обозвал вершины,
что А более низко из них, не строго.
То есть например вот здесь вот это А это Б, вот здесь
вот это тоже А это Б.
То есть на каждой стороне у меня свое обзывательство
для обеих вершин.
А дальше я говорю следующее, значит если отрезок, если
сторона лежит целиком строго выше или целиком не строго
ниже, чем этот луч, то мы ее скипаем.
А именно если A.Y больше чем P.Y или B.Y меньше
и равно P.Y, тогда мы просто эту сторону скипаем, считаем
что она не пересекается с лучом, говорим скип.
То есть это соответственно какие картинки, эта картинка
вот такая, ну здесь это естественно, что если даже
у точки А координата по Y больше чем у П, то конечно
здесь точно нет пересечений.
Это условие естественное, а второе условие это что
если у нас картинка какая-то вот такая или даже скажем
вот такая, а мы говорим что все равно пересечений
нет.
И даже сюда же входит случай вот такой, когда наш отрезок
целиком лежит на луче, а мы все равно говорим что
пересечений нет.
Давайте пока так сделаем.
А у них одинаковые Y, поэтому все знают, а, да, спасибо.
Что-то у нас аж 4 картинки уже, капец, да, а внизу всегда
спасибо.
Ну вот, значит делаем это, а в противном случае проверяем
пересечения, если есть пересечения, то там изменяем четность
на единицу.
Значит иначе проверяем пересечение, проверяем
наличие пересечений.
Ну проверить очень просто, если есть такой луч горизонтальный,
если есть некоторый отрезок АВ, то, например, они пересекаются
если и только если вот такое вот их векторное произведение,
то есть я провожу вот такие два вектора, если оно отрицательно,
ну не положительно пишу так, потому что если была бы
какая-нибудь такая картинка, вот такая, скажем, да, тогда
у вас здесь, наоборот, поворот идет против все, то есть положительный.
Ну это опять на картинках все, можно просто порисовать
все возможные взаимные расположения отрезка и луча вот этого
горизонтального и понять, что пересекаются они ровно
в этом случае, когда угол поворота из А от П к Б отрицательный,
то есть в сторону по часовой стрелке.
Ну и все, получается алгоритм очень простой, алгоритм
очень короткий, значит мы идем по всем сторонам,
если очередная сторона имеет там какие-то вершины,
то давайте скажем, что А это более низкая из этих
двух вершин.
Дальше, если выполняется такое условие, мы эту сторону
пропускаем и ничего не делаем, а иначе если выполняется
вот это, то мы проявляем один к счетчику пересечений
и в конце если он нечетный, то значит изначально точка
была внутри, то есть конец такой же, что если насчитали
что-то начало пересечений, то точка внутри.
Ну то же самое надо было еще в самом начале отдельно
проверить, что точка лежит где-нибудь на границе, потому
что с точками на границе тут не очень приятно,
потому что если эта точка П лежит на каком-то из
отрезков, то короче отдельно разберем еще в случае на
границе.
То есть вот здесь вот на самом деле можно было
выписать строгое неравенство, потому что нестрогое означало
бы, что П лежит на отрезке, а это мы отдельно в самом
начале разберем, то есть отдельно проверяем
на принадлежность границы.
Ну что теперь надо доказать, что это работает, что действительно
все случаи вот этих пересечений совершены и мы правильно
обработаем.
Ну надо просто порисовать все случаи какие есть, давайте
разберем.
Ну понятно, что вот здесь вот если наш отрезок лежал
целиком сверху или целиком снизу, то мы его правильно
обрабатываем, здесь точно нет никаких пересечений.
Значит дальше, если одна точка выше, другая точка
ниже, то понятно, что в этот случай мы тоже правильно
разберем, мы проверим наличие пересечений или нет, то есть
на этом отрезке не вершина здесь лежит, поэтому здесь
мы точно все нормально разберем, здесь все хорошо.
Значит проблемы только с тем, когда одна из точек
A или B лежат на луче, одна из точек A или B лежат на луче,
но причем это видимо обязательно A, потому что если и A и B,
то есть если B лежит на луче, то A только ниже, а значит
это случай либо такой, либо такой, поэтому мы бы его
скипнули.
Поэтому нам нужно рассмотреть все случаи, когда A лежит
где-то ниже луча A, а B на луче и понять, что мы их правильно
разбираем.
Ну, какие бывают случаи?
Ну, например, вот такой случай бывает.
Значит, вот была там очередная, просто буду вот так рисовать,
очередная вершина и многоугольник где-то вот здесь был, или
наоборот, была очередная вершина, а многоугольник
где-то вот здесь.
Такие случаи, значит, вот такие случаи, как-нибудь
вот так вот я нарисую.
Давайте с ними пока разберемся, что делать со случаем, когда
вершина попадает к нам на луч.
Значит, если оба прилежащих отрезка лежат ниже луча,
то по сути, когда мы вот так вот проходим через эту
вершину, у нас должно не поменяться число пересечений,
потому что можно считать, что мы по внутренности
То есть нам надо не изменить чётность числа пересечений
при проходе вот этих двух отрезков, но они оба у меня
игнорируются, потому что они оба лежат ниже, ниже
нашего луча, поэтому мы их оба скипнём и чётность
не изменим.
Поэтому этот случай разбирается правильно.
Тут согласны?
То есть нам нужно не изменить чётность, пройдя вот эти
два отрезка, но мы так и сделаем, потому что мы их оба скипнём.
Значит, ну здесь то же самое, здесь мы проходим наоборот
по внешне касательной, и всё равно надо не поменять
чётность, но мы так и сделаем, потому что мы вновь оба
эти отрезка скипнём.
Здесь всё нормально.
Так, ну нужны ещё случаи, когда вот такие случаи, когда
наоборот у нас сверху, ну как бы наверх торчат две
седние стороны, но здесь тоже всё верно, здесь нужно
нам не учесть, что эта вершина как бы является точкой пересечения,
то есть мы как бы вот здесь вот по внешне касательной
проходим, здесь тоже как бы внутри обходим.
Надо учесть с коэффициентом ноль, да, то есть как бы что
эти два отрезка не вносят нам пересечения, но мы так
и сделаем, потому что у нас оба эти отрезка дадут
мне вклад в пересечение, да, то есть это случай, когда
я их не скипаю, но при этом они оба пересекаются, то
если я добавлю здесь единицу, здесь единицу, получится,
что я не изменю четность числа пересечений, поэтому
это случай тоже правильно обрабатывается.
Тут то же самое, у меня оба эти отрезка посчитаются
как пересечения, я добавлю по единице к числу пересечений
и тем самым четность не изменю, всё будет правильно.
Значит здесь, здесь уже чуть-чуть поинтереснее,
если у меня вот такая картинка, то есть я пересекаюсь через
вершину и надо выйти как бы из многоугольника.
Ну тогда мне нужно поменять чётность числа пересечения,
потому что я выхожу за границы многоугольника,
но я ровно так и делаю, потому что нижнюю я скипаю,
нижняя будет скип, да, да, да, да, да и даст на меня
ноль к числу пересечений, а верхнюю я посчитаю как
пересечение, она мне даст единичку и тем самым я
поменяю числа пересечения, всё правильно.
Нижняя скипну, а верхняя будет вот здесь вот разобрана
и посчитается это пересечение.
Тут то же самое, надо поменять, это пропустится, а это добавит
единичку, тем самым я добавлю единицу к общему числу перещений и поступлю правильно.
Так, ну и, кажется, последнее, что надо еще разобрать, это когда сторона лежит на луче.
Еще бывают вот такие вот случаи, например, что-нибудь вот такое.
Вот, тут вроде можно всегда заметить, что в таких картинках можно как будто бы склеить
концы вот этого горизонтального ребра, горизонтальной стороны и считать, что его вообще не было.
То есть вот представьте, что я вот так вот беру и этот кусок как бы притягиваю влево к этой вершинке,
то есть стягиваю этот отрезок в точку, да, и тем самым у меня как бы это перенесется параллельно
сюда, ну здесь соответственно граница как-то там перенесется. И тогда, по сути, да, ну то есть вот
так вот здесь я не изменил как бы число перещений, то есть я как бы вот здесь вот так вот шел по ней,
ждал, ждал, когда что-то произойдет, да, и когда сюда попал, я уже понимаю, что пресуд якобы
попадаю внутрь, но давайте сразу тогда сюда притянем и тем самым поймем, что горизонтальные
отрезки можно игнорировать, они как бы нам не влияют на число перещений. То же самое здесь,
да, вот если я притяну вот эту вот штуку сюда, ну как бы сдвину как-нибудь все вот это вот,
то у меня, ну как бы число перещений не изменится. То же самое здесь и здесь, я могу вот это сдвинуть,
и здесь могу вот это сдвинуть, будет такой многоугольник. Ну соответственно видно,
что горизонтальные отрезки, которые как бы лежат на нашем луче, можно просто игнорировать,
они как бы не дают вклада, то есть если их игнорировать, то можно просто смотреть на
следующую сторону, она и определяет нам как мы пересекаемся. Ну ровно так мы и поступаем с
горизонтальными отрезками, вот они, это вот этот случай, когда B точке грех меньше,
B точке греха мы просто скипаем и не учитываем в пересечении, поэтому такие случаи тоже корректно
все разберутся, ну и вроде все, больше никаких неприятностей нету. Ну вот это мы отдельно ефаем,
чтобы как раз не было кейсов, когда вот эта вот точка совпадает с каким-то из отрезков. То есть
у нас алгоритм в итоге такой, что мы сначала проверяем по всем сторонам, не лежит ли точка
на стороне, если лежит, то говорим, что там лежит на границе, затем запускаем этот простой алгоритм,
тоже проход по всем сторонам вот с этими двумя условиями и потом по учетности определяем
внутри или снаружи. Окей, ну как бы тут ничего приятного, надо просто порисовать картинки,
понять, что мы их правильно учтем в этом алгоритме, все. Ничего приятного, но ничего хитрого.
Так, хорошо, значит с этим тогда разобрались, с этим разобрались и можем ехать дальше,
значит следующая задача это пересечение полуплоскостей.
Задача такая, ну полуплоскость это понятно, что такое, мы живем на плоскости,
полуплоскость это то, что лежит по одну сторону какой-то прямой, то есть есть прямая,
АХ плюс БЮ плюс С равно нулю и какая-то вот из двух частей, на которые она развивает плоскость,
ну скажем вот это. То есть вот это вот, все это какая-то полуплоскость. И теперь представьте,
что есть N таких штук, N полуплоскостей, мы хотим понять, чему равно их пересечение,
как выглядит их пересечение, полностью его описать. Найти пересечение N полуплоскостей.
Ну сначала давайте скажем, как мы вообще будем задавать такие полуплоскости, есть какие-нибудь
предложения? Как можно задать прямую вместе с вот одной из двух частей? Слишком сложно,
слишком много сущностей. Лучше еще. Да, типа того, ну вот то, что вы сказали про буль, на самом деле
можно сделать так, что если буль фолст, то мы могли бы коэффициенты на минус один просто
домножить и получить как раз противоположную полуплоскость. Поэтому вместо буля давайте просто
хранить на самом деле три N, ну там три коэффициенты, и будем считать, что полуплоскость это то,
что дает вот такому вот неравенству. Больше оно нуля. Если бы был буль, то мы бы могли на минус
один домножить, у нас поменялся бы как раз значок. То есть полуплоскость мы будем хранить так же,
как прямую, грубо говоря, в той же структуре line, с коэффициентами abc. И считать, что
полуплоскость это то, что дает вот этому неравенству. А х плюс у плюс все больше нуля. Значит более того,
можно сказать, что это та из двух полуплоскостей, куда смотрит нормальный вектор ab. В эту
полуплоскость смотрит нормальный вектор ab. Да, то есть вот этот вектор, который я пытался
нарисовать, его можно в частности брать нормальным. Ну почему это верно? Легко показать, что если вот
это какая-то точка там x0, y0, лежащая на прямой, тогда эта точка x0 плюс a, y0 плюс b, и если вы
поставите просто вот эти координаты этой точки в это уравнение, то вы получите a квадрат плюс b
квадрат, что точно положительно. Поэтому вот эта вот нормаль с координатами ab как раз ровно в
этой полуплоскости лежит. То есть у нас есть как бы понимание, что полуплоскости мы храним ровно
так, и в частности это та полуплоскость относительно данной прямой, куда торчит вектор нормали. Вот это
вот наш стандартный вектор нормали ab. Да, ну и давайте их сразу будем, мы их сразу будем
нормировать, потому что если нас просят найти пересекание полуплоскостей, то даже если здесь
все целое, если коэффициенты целые, если они задавались целыми точками, целочисленными точками
какими-то, вот целочисленными точками на прямой, то когда вы пересекаете прямые, вы там без доблов
никуда. Ну или по крайней мере без рациональных чисел никуда, потому что если вы пересекаете две
прямые, то точка перчения там может быть какая угодно, дробная. Вот, поэтому сразу давайте считать,
что у нас здесь все смело в доблах, в числах с плавающей точкой, ну и поэтому собственно мы
можем вот эти векторы сразу нормировать. Можем сразу нормировать. То есть сделать так, что длина
это векра единица, то есть сумма кваратов A и B равна единице.
Так.
Да, ну теперь вопрос, да, как вообще в принципе может выглядеть пересечение
N полуплоскостей? Вот вы что-то на плоскость набросали какие-то полуплоскости, пересекли,
что может получиться? Ну в хорошем случае, собственно, в тот цикл, на который мы будем
закладываться, у нас получается выпуклый многоугольник, какой-то конечный выпуклый
многоугольник, да. То есть, например, если вы берете и пересекаете вот такую полуплоскость,
вот такую полуплоскость, вот такую, вот такую, вот такую и вот такую, то их пересечение как раз
вот этот выпуклый многоугольник. Это как раз самый такой, ну самый хороший что-ли случай. Но,
естественно, бывает много других гадостей, да, бывает, например, что пересечение это не выпуклый,
pardon, неограничный выпуклый многоугольник. Например, что у них вот такое, если вы пересекаете,
если вы вот такие полуплоскости пересекаете, то пересечение это вот такая вот чашка,
бесконечный верх. Может быть такое, что вы пересекли две вот такие вот полуплоскости и
получили полоску неограниченную сверху и снизу. Может быть такое, что вы получили какую-нибудь
прямую, например, если вы пересекли вот такую полуплоскость и вот такую. У вас может быть прямая.
Ну, соответственно, где прямая, там и отрезок может быть, если вы пересекли
вот такую и такую полуплоскости, скажем, еще вот такие две, то у вас першень — это отрезок. Значит,
также может быть точка, ну и, конечно, пустое множество, если у вас какие-нибудь противоречия
явные есть. Вот. Ну, конечно, всякая гадость бывает, кроме нормального случая, когда у нас
получается невыраженный, ограниченный выпуклённого угольника, в смысле положительной площади,
бывает еще много всяких таких неприятных штук. Самое неприятное здесь, на самом деле,
это вот эти два случая, когда у нас ногогольник неограниченный получается. Вот. И мы с этим будем
бороться следующим образом. Давайте мы поместим все наше безобразие в некий bounding box, в такую
большую коробочку, где заведомо лежат все точки пересечения. Все точки пересечения наших
полплоскостей там точно лежат. Ну и тогда, соответственно, представьте, что мы вот эту
чашку помещаем в какую-то супергигантскую коробку вот такую. Вот так вот я нарисую. Да, тогда понятно,
что здесь он правильно адекватно себя ведет, а там на бесконечность он пересекается, ну где-то там
очень далеко он с этой коробкой пересекается, получается вот такой вот отрезок. То есть мы с
одной стороны поняли, что наш ногогольник бесконечный, да, раз он пересекается где-то там далеко с
bounding box, вот. Но и с другой стороны поняли, как он себя ведет на вот этом вот конечном нормальном
куске плоскости. То есть там, где они все пересекаются, мы понимаем, как он себя ведет, а также, что он там
бесконечен куда-то на плюс бесконечность. Ну или, короче, куда-то в сторону бесконечных координат,
он бесконечный. Вот, поэтому, значит, подход такой. Значит, ведем bounding box. Наверное,
я не буду переводить, ну как бы ограничивающая коробочка, да, ограничивающий прямоугольник,
внутри которого мы рассматриваем все наше, весь наш мир. Значит, он будет у нас такой, х не больше
чем, ну давайте напишу, с, х больше равно минус с, у меньше равно с, у больше равно минус с. Вот,
и находим уже, после этого у нас, то есть если я насильно вот эти четыре полуплоскости добавлю
в наш мир, в наши н-полуплоскости, в наш список полуплоскостей, то у меня многогольник заведомо
станет конечным, потому что у меня все находится внутри вот такого, как бы, конечного квадрата.
А тогда сразу, тогда пересечение сразу становится конечным. Но при этом также мы можем задетектить,
не является ли оно на самом деле бесконечным. Делается очень просто, если в вашем результатившем
многоугольнике есть хотя бы одна точка на этой границе bounding box, то на самом деле у вас вот
реально такая картинка, и как бы, вот эта вот граничная точка, она на самом деле ограничивает
ваш бесконечный многоугольник. То есть мы не просто сузили его на какую-то конечную область,
но еще и можем однозначно понять, не является ли он на самом деле бесконечным, если нам это почему-то
вдруг нужно. Ну и чтобы ничего не потерять, чтобы не отрезать каких-нибудь точек случайно,
нужно C подобрать таким, чтобы внутри bounding box заведомо лежали все пересечения всех прямых.
C надо подобрать так, чтобы внутри bounding box лежали точки пересечения всех пар прямых.
Если мы это обеспечим, если мы подберем такое достаточно большое C, то мы точно никакие вершины
нашего многоугольника не потеряем, потому что понятно, что вершины это обязательно какие-то
пересечения прямых, прямых из вот этого нашего множества, ну и значит мы ограничим как раз только
на бесконечности. Ничего вот здесь мы лишнюю не отрежем, если обеспечим, что все вершины,
точнее все точки пересечения у нас сохраняются внутри bounding box, тогда мы ничего не отрежем лишнего.
Вот. Ну мы не будем так делать, потому что это будет уже квадратичное время. Мы не будем так
делать, потому что уже будет квадрат по времени. Вот. Ну как-нибудь вот можно оценить. На семинар
будет задачка, что если у вас все прямые изначально задавались целыми координатами,
от там по модуле не больше, чем какой-нибудь A, тогда у вас C достаточно взять типа A в кубе.
То есть если у вас координаты изначально все были там порядка 10.9, то C можно взять порядка 10.27,
тогда у вас короче точки заведомо будут внутри. Ну да, не очень приятно, но с точки зрения теории
надо делать именно так. Вот. Ну хорошо. На счет пусть там какой-то C взяли достаточно большое.
Алгоритм за n в квадрате. Давайте мы начнем с bounding box.
А дальше будем вводить в рассмотрение все наши полуплоскости и пересекать текущий
многоугольник с очередной полуплоскостью и ограничивать соответственно исходный
многоугольник на новую полуплоскость. То есть вот скажем мы знаем, что изначально пересечение
у нас вот такое bounding box. Потом приходит какая-то первая полуплоскость, вот такая.
Тогда как теперь выглядит пересечение? Нам нужно пересечь bounding box с полуплоскостью.
Теперь их пересечение это вот это. Ну как-нибудь его найдем. Дальше у нас есть выпуклый многоугольник,
вот такой. Приходит очередная полуплоскость, их нужно пересечь. Давайте как-нибудь оно,
не знаю, вот так вот выглядит. Их надо пересечь. Ну понятно, вот оно пересечение. И так далее.
И так далее. То есть у нас на каждой террации есть выпуклый многоугольник, приходит прямая.
По сути нам нужно просто пересечь прямую с этим многоугольником и взять одну из двух частей.
Все очень просто. Каждая террация работает за линейное время, потому что мне нужно по сути
просто пересечь эту прямую со всеми сторонами, коих не больше чем n. Ну и потом взять одну из
двух частей и будет у нас новый, ну как бы один из них, один из этих многоугольников, а именно тот,
который лежит вот по этому сторону от прямой и будет нашим новым многоугольником. Даже не
знаю, что написать. Итеративно вводим по одной полуплоскости, по одной полуплоскости пересекаем
текущий многоугольник с полуплоскостью. Вот. Значит это в принципе довольно хороший алгоритм.
И если n у вас действительно там не очень большой такой, что n квадратный можете себе
позволить, то я бы советовал наверное писать его, потому что по сравнению с алгоритмом design log n,
ну как бы этот попроще будет. Вот. И поэтому поскольку он может быть полезен, давайте я немножко
больше деталей дам, как именно его можно реализовать. Значит, ну вот пусть у вас был многоугольник,
все вершины его как-то там занумированы, v1, v2 и так далее, vn. Вот. Давайте vk пусть будет. Так,
понятно почему за квадрат это работает. Потому что n трация, на каждой трации у нас есть максимум
n угольник, мы его пересекаем с прямой за линию, за o от n, и того n квадрат. Ну так вот, пусть есть
многоугольник с ковершинами пронумерованными, приходит какая-то очередная полуплоскость,
мы хотим ограничить наш многоугольник на полуплоскость, пересечь. Значит, простые
случаи. Если все вершины исходного многоугольника лежат по правильную сторону от прямой, то делать
ничего не надо. Значит, случай один. Если все вершины лежат в новой полуплоскости, то делать
ничего не надо. Вот. И благо у нас полуплоскости заданы очень удобно, заданы неравенством,
а x плюс y плюс все большего нуля. Значит, мне нужно просто координаты всех вершин их подставить в это
уравнение, ну в это неравенство скорее, и проверить, что оно выполняется. Если оно действительно
всюду выполняется для всех вершин, то значит наш многоугольник просто сохраняется, он и будет
ответом на следующем шаге. Ну наоборот, то же самое, если наоборот все неравенства не выполняются,
тогда полуплоска какая-нибудь вот такая, и тогда ответ сразу постоит множество. Если ни одна вершина
не лежит в полуплоскости, тогда сразу return пустое множество. Потому что у нас была какая-то фигура,
мы ее пересекли с полуплоскостью, которая не пересекается, значит сразу пересечение пусто,
какие бы другие полуплоскости нам не поступали. Поэтому здесь можно сразу алгоритм завершить,
сказать, что ответ это пустое множество. Вот, ну и наконец третье, если есть вершины и такие,
и такие, то есть и лежащие по правильной стороны, вот по полуплоскости, и по неправильной.
То есть что-нибудь вот такое. Вот так нарисую. Вот, мне соответственно нужно выделить вот это
угольник. Тогда мы делаем следующее. Мы делаем цикл по всем сторонам, рассматриваем какую-то
сторону v и v и плюс один. Вот. И давайте еще заведем какой-нибудь вектор, вершин, куда будем
складывать вершины ответа. То есть понятно, что мне нужно как бы в качестве ответа вернуть
вектор из вот этих вот вершинок в каком-нибудь порядке. А это будет, собственно, наш многоугольник
очередной. Вот давайте я заведу вектор и буду в него поочередно складывать все вершины, которые
я нахожу. То есть нашел очередную вершинку пересечения, положил ее в вектор. Итак, значит
здесь есть следующие случаи. Во-первых, если обе эти вершины лежат вне полуплоскости, давайте
я уже как-нибудь назову h от слова half plane полуплоскости. Если они обе не лежат в полуплоскости,
то я просто делаю continue. v и не лежит в h, v и плюс один не лежит в h, тогда просто continue. Ну,
это, грубо говоря, случай вот этой вот стороны. А у нас сторона лежит вне полуплоскости, понятно,
что она вершин в пересечении не добавляет. Если, наоборот, обе вершины лежат в полуплоскости,
тогда я добавлю в наш список только v и плюс первую. Ну, я не буду добавлять и то, и то,
чтобы у меня не было повторений, потому что, например, если я рассматриваю вот эту сторону,
а потом вот эту и добавляю оба конца каждый раз, то у меня бы эта вершинка продублировалась.
Вот давайте, чтобы этого не было, буду добавлять только вторую из них.
Случай v. Если предыдущая не лежала, а следующая лежит,
тогда у меня получается картинка, что как бы я был вне полуплоскости, теперь попал в нее. То
есть картинка какая-то такая. Вот у меня была h вот здесь, вот v и вот здесь, а v плюс 1 вот здесь.
Тогда у меня появляется некая новая точка, точка пересечения нашего отрезка и полуплоскости,
стороны полуплоскости q. Тогда я добавлю в наш список сначала q, а потом v и плюс первую.
Ну и последний случай. Если наоборот v и в h, а v плюс 1 не в h, тогда картинка будет у нас наоборот.
v и плюс 1 где-то здесь. Опять-таки есть некая точка пересечения. Вот ее я добавлю в наш список.
Это q. Это просто q. Все, в конце я утверждаю, что у меня будет просто список вершин нашего
многоугольника результирующего. Интуиция такая, что к моменту времени, когда я прихожу к какому-то
такой картинке или такой, у меня предыдущая вершина v и t, если надо, она уже добавлена в
наш список. Здесь не надо было добавлять, она добавлена вот здесь. Если у меня рассматривается
такой случай, когда я лежал в многоугольнике, потом вышел из него, то к этому моменту v и
уже добавлена в наш список просто потому, что я так шел. И если вот скажем здесь у меня было
две подряд идущие вершины в h, то я вторую из них обязательно добавляю. У меня v и плюс 1 всегда
добавляется, если она лежит в полуплоскости. Поэтому v и t, если надо, уже была добавлена. Не то,
что я пропустил добавил q, а я ее уже обязательно добавил. Поэтому она точно в списке есть,
я ничего не пропущу. Но тем самым я как раз все вершинки в правильном порядке добавлю.
Окей? Ну все. Единственное, здесь нужно аккуратно разобраться со случаем, когда q совпадает с
и плюс 1, когда не надо ее дублировать. И здесь тоже, если q совпадает с v, то ее не надо добавлять.
Вот. А так у нас получается просто многоугольник, даже без дубликтированных вершин. Так,
за квадрат понятно, идем дальше. Хорошо, тогда у нас следующий алгоритм за n log n.
Так, алгоритм за n log n. Ну давайте номер 1 я его назову. Два рассмотрим. Они очень похожи,
просто как бы что удобно, то пишите. Значит, и начало у них одинаковое. Давайте мы свалим все
наши полуплоскости в одну кучу. Включаю bounding box, который тоже на самом деле является
полуплоскостями. Свалим все в одну кучу и поделим на две группы. Значит, у нас будет первая группа,
это те полуплоскости, у которых нормальный вектор, грубо говоря, смотрит вверх. Вторая
это те, у которых, грубо говоря, нормальный вектор смотрит вниз. Более формально, первая группа
это те, у которых нормальный вектор вот такой, один из вот таких. То есть это набор углов 0
от нуля до пи, не включительно пи, ну как бы от вот этого
обычного направления оси ОХ. Вторая группа полуплоскостей
— это те, у которых нормально образуют вот такие углы,
ну точнее вот такие векторы. Все вплоть до вот этого,
то есть это набор углов от пи до 2п, не включительно.
Да, ну и соответственно как бы мы знаем все такое
нормальный вектор, это вектор с координатами АВ, то есть
здесь условия на принадлежность первой группе следующие.
У вас либо В больше нуля, то есть он смотрит вверх,
или же В равно нулю, но при этом А больше нуля. Это
вот специально отдельно выделенный горизонтальный
вправо вектор. Здесь В меньше нуля или В равно нулю и А
отрицательно. Вот это специально выделенный влево вектор.
Разбили на две такие группы. Это немножко похоже на то,
когда мы строим выпуклую оболочку нижнюю и верхнюю
отдельно. Вот давайте отдельно построим нижнюю и отдельно
верхнюю. Идея такая. Значит, вот разбили на две группы.
Дальше внутри группы давайте эти векторы посортируем.
То есть внутри каждой группы посортируем все полуплоскости.
В порядке вот такого вращения против часовой стрелки
по сравнению с положительным направлением оси ОХ все
полуплоскости вот так отсортируем. То есть это будет нулевая,
первая, вторая, третья и так далее. Здесь то же самое
нулевая, первая, вторая, третья и так далее. Внутри
каждой группы отсортируем полуплоскости по углу. Ну
и делается просто с помощью векторного произведения.
Углы считать не нужно, просто по векторному произведению.
Если есть вот такой вектор и вот такой вектор, мы смотрим
на их векторное произведение и понимаем, что если отсюда
сюда поворот против часовой, то значит это должно быть
раньше, чем этот. Ну, как всегда. Чтобы понять, кто
из векторов раньше, считаем векторное и по знаку понимаем,
кто из них должен идти раньше второго. Вот посортировали.
То есть у нас теперь вот здесь такой порядок, здесь
такой порядок. Значит, дальше. Ну вот, первый алгоритм
такой. Смотрите, у нас точно есть обязательно полуплоскости
с вот таким вектором горизонтально вправо и вот таким горизонтально
влево. Это bounding box, вертикальный прямой bounding box. Если там
есть несколько параллельных, то если кроме bounding box есть
еще какие-то дополнительные прямые, то понятно, что из них
есть смысл оставить только самую мощную, а именно ту,
у которой c минимально. То есть если есть несколько
параллельных прямых, тех, у которых a и b нормальные
векторы одинаковые, то из них есть смысл оставить
только самое сильное неравенство, то есть то, у которого c минимально
возможно. Ну, давайте такие оставим. То есть параллельные
прямые выкинем и оставим из них только самое сильное
неравенство. Вот. И разберемся с первой категорией. Значит,
рисую bounding box, вертикальные прямые. Это пока не буду
рисовать. Давайте добавлять вот эти прямые по очереди
в порядке сортировки из первой группы. Сначала будет какая-то
вот такая полуплоскость, потом вот такая чуть более
наклонная, потом вот такая еще чуть, ну как бы еще более
завернутая и так далее. И на самом деле, за счет
того, что мы их рассматриваем в таком порядке, у нас каждая
очередная полуплоскость заведомо дает какое-то
новое ограничение, потому что, ну то есть если у вас
вот была какая-то такая картинка, и потом вы строите
какую-то еще более крутую прямую, то она на бесконечность
обязательно будет самая высокая. Ну, у нее как бы
максимальный вот такой угловой коэффициент, поэтому
она точно будет максимальная там для достаточно больших
координат. Поэтому здесь обновление очень простое.
Давайте мы просто проведем эту прямую, эту полуплоскость,
и если что, нам нужно будет удалить несколько последних
полуплоскостей, которые у нас лежали в нашем списке.
То есть смотрите, вот это хороший случай, если я добавил,
у меня как бы, ну, по сути, она просто дала очередную
вершинку. Но если бы она лежала, например, вот здесь,
то у меня, соответственно, вот эта предыдущая лежащая
здесь прямая, она как бы становится лишняя, потому
что она накладывает более слабые условия по сравнению
с новой. Я мог эту прямую просто затереть и забыть
про нее. Да, то же самое, если бы она лежала еще
левее где-нибудь вот здесь вот, то не только это бесполезные
условия, но и вот это горизонтальное, потому что, ну, как бы вот
на самом деле пересечение, и здесь это горизонтально
уже не входит. И по сути, алгоритм очень похож на алгоритм
по сравнению выпуклооболочки, когда мы там вот снизу ее
строили, мы идем слева направо, добавляется полуплоскость,
которая заведомо лежит в пересечении, так же как
точка лежала, потому что она была самая правая, так
здесь полуплоскость лежит, потому что она самая наклонная
вот в этом направлении. Ну, и мы просто удаляем несколько
последних, пока они дают более слабые условия, чем
новая прямая. Вот, и в конце у нас первая группа целиком
обработается, закончится на вертикальной прямой,
ну, поскольку она там достаточно там, нет, ну а что? Нет, ну
просто короче, она закончится на какой-то вот такой вертикальной
прямой, и все. Значит, алгоритм пишется очень просто. Мы
храним вектор прямых, храним вектор прямых, вектор прямых,
ну, я буду смешивать понятие прямая и полуплоскость,
потому что они хранятся все равно в одной структуре,
по крайней мере в моей голове. Может, это и плохо так делать
на практике, но вот я буду так делать, потому что они
задаются тремя чистыми, они будут в одной структуре
у меня. Значит, вектор прямых, рассматриваем прямые в
порядке сортировки, рассматриваем прямые первой группы в порядке
сортировки. И вот тут надо написать условия. Значит,
пока в векторе хотя бы две прямые, в векторе хотя бы
две прямые, и пересечение двух последних не льет в новую
полуплоскость, пересечение двух последних не льет в
новой полуплоскости.
Ну тогда надо сделать vector.popback.
Мы как бы последнюю прямую удаляем, последнюю полуплоскость
удаляем.
То есть это как раз картинка, когда у меня была какая-то
вот такая штука, пришла более крутая прямая, пересечение
двух последних векторей лежало вне полуплоскости,
значит вся эта последняя прямая задает бесполезные
условия, его можно удалить, ее можно удалить, ну и соответственно
игнорировать просто.
Мы делаем это с помощью vector.popback.
Все это while, и в конце в этот вектор, извините что
я вектор назвал вектор, но как есть.
Значит вектор pushback, новая прямая, вот эта вот h.i.t,
пусть значит h.i.t, это новая полуплоскость, которую
я рассматривал.
h.i.
И это корректное действие, потому что поскольку она
более крутая, чем все предыдущие, то она точно лежит последней
в нашей выпуклой оболочке, точнее в нашем пересечении.
В итоге, после того, как я рассмотрел всю первую
группу, у меня будет какая-то вот такая вот нижняя огибающая
для всех наших прямых.
Такая опять чашечка, которая является пересечением
всех полуплоскостей из первой группы, ну еще я могу
учесть вот эти вот, сейчас, вот этот вектор могу еще
добавить, это как раз вертикальные ограничивающие справа
bounding box.
Да, я тоже это могу добавить, чтобы у нас была вот такая
вот чашечка.
Какая-то такая чашечка у нас получается.
Понятно?
Так, хорошо.
Ну и на самом деле дальше можно сказать следующее.
Давайте сделаем то же самое для верхней, для второй
группы независимо, получение как крышечка.
А потом с помощью scanline мы их пересечем.
То есть вот так вот встанем вертикально прямой, идем
слева-направо, у нас есть нижняя огибающая, верхняя
огибающая, надо их пересечь, давайте тогда идти вот так
слева-направо и аккуратно смотреть какой у нас сейчас
профиль пересечения нашей прямой с крышечкой и с чашочкой.
Вот так вот идем, видим пока нет пересечения, затем
здесь становится, что вот эта какая-то сторона пересекается
этой стороной.
Здесь открываются пересечения.
Ну дальше нужно просто все вот эти вершины перечислить
и все вот эти вершины перечислить до того, пока они опять не
пересекутся.
Простая такая сканирующая прямая слева направо позволит нам пересечь нижнюю
огибающую, верхнюю огибающую. Давайте немножко слов тут напишем.
Аналогично
строим верхнюю огибающую.
Затем пересекаем их
сканлайном
слева направо.
Ну то еще раз тут как бы проще на картинке объяснить. Вот есть нижняя огибающая и какая-то
верхняя. Давайте ее вот так вот нарисуем. Встали вертикальный прямой здесь, храним
указатель на текущую прямую здесь, на текущую прямую здесь. Встали, смотрим, что сначала
происходит. Сначала происходит как бы прохождение этой прямой. Окей, сдвигаем указатель сюда. Дальше
она целиком проходит, до этого еще не прошли, сдвинули указатель вот сюда. Теперь смотрим,
ага, так, значит сначала пройдется вот эта прямая, затем мы пойдем на эту сторону. Затем
идем, видим, что они пересекаются. Пересекаем текущие стороны, которые мы указываем,
понимаем, что вот они где-то пересекаются. Окей, вот мы входим в пересечение. Дальше мне
нужна верхняя часть нашего пересечения. Это последовательные вершины
вот этой вот крышки, а нижняя часть это последовательные вершины вот этой чашки,
на нижней огибающей. То есть мы дальше идем точно так же. Мы поддерживаем указатель на сторону
здесь, на сторону здесь. Идем пока как бы нижняя, ниже чем верхняя. Идем, просто продолжаем,
запихи все вершины сверху, снизу. И потом, когда они опять пересекаются, потом когда как бы
происходит вот такое, ну как бы наложение стороны на сторону, мы опять ищем их пересечение и говорим,
что здесь у нас завершается наше пересечение, потому что дальше они будут только расходиться еще
дальше друг от друга. Вот, ну собственно все. То есть у нас будет отдельно верхняя,
отдельно нижняя кусок хранится, потом их объединяем в один общий список, и получается
список вершин нашего нагугонника. Не очень приятно, но в принципе делается. Да. Ну у нас есть два
отрезка. Просто смотрим, у кого из них у, ну точнее х меньше. Кто раньше заканчивается,
потому и переходим. Вот, в итоге симптотика будет действительно n log n, потому что самая сложная
со симпатичной точки зрения это сшатировка. Вот здесь мы посортили отдельно первую-вторую группу
за n log n. А дальше все линейный проход, потому что, ну это собственно по симпатике так же,
как выпукла оболочка, хранится вектор, и там последние удаляются, каждая добавится максимум
один раз. И здесь тоже у нас есть нижняя верхняя, уже все и так отсортировано слева направо,
мы берем scanline и просто проходим там двумя указательными по нашим спискам, это уже будет
линейное время. То есть симпточка будет действительно n log n. Значит n log n на сортировку. Все остальное от n.
Так, вот видим второй, тоже n log n.
Начало такое же. Посорти внутри каждой группы независимо, построим нижнюю вот эту вот огибающую.
Но дальше я не буду независимо строить для верхней огибающей, я на самом деле просто свалю все
полуплоскости в один список, сначала первая группа отсоединена, потом вторая. И буду делать вот
это тоже самое. То есть я как бы сначала продаю нижнюю огибающую, и потом сразу здесь же буду
доблюдать верхнюю. Давайте поймем, что получится. То есть вот сначала у меня будет все окей, у меня
будет какая-то нижняя огибающая хранится. Потом поступают прямые, наоборот уже вот такие,
смотрящие куда-то вниз. То есть я начинаю рассматривать верхнюю огибающую. Ну как бы нормальный
случай, это когда приходит очередная прямая, и как-то там что-то высекает, что-то вот такое,
ну так все хорошо. Но на самом деле может быть такое, что, ну как обычно, у нас могут удаляться
какие-то последние вершины. Сейчас нарисую. Ну например, когда приходит вот такая прямая,
мне нужно удалить вот эту прямую, та из нашего вектора. Но более того, могут удаляться некие первые
прямые. Если у нас был какой-нибудь вот такой вот текущий, текущая картинка какая-нибудь,
вот, и приходит еще вот такая прямая, то мне нужно удалить уже первую прямую. Да, но поскольку
как бы по сути, у меня теперь уже новые вот эти полублоски, которые я добавляю, они у меня не
только с как бы последними прямыми пересекаются, но и с первыми тоже могут пересекаться. Поэтому мне
еще может понадобиться удалять какие-то первые прямые из нашего вектора. Да, ну и поскольку мне
нужно удалять не только из конца, но еще из начала, то мне нужно завести какую структуру данных
вместо вектора. Дек. Мы будем хранить не векторы, а дек прямых. Храним дек прямых. Все остальное
практически идентично. Значит, мы когда рассматриваем новую прямую, мы удаляем несколько последних из
дека, пока пересечение двух последних не лежит в полуплоскости. То есть пока вот такая картинка
выполняется, когда вот эта точка лежит вне полуплоскости, я удаляю последнюю прямую. И то
же самое с начала. Пока пересечение первых двух не лежит в полуплоскости, я удаляю первую прямую.
Значит, так и напишу как-нибудь кратенько. Пока пересечение двух последних не лежит в HE,
я делаю дек.popback. То же самое с началом. Пока пересечение первых двух не лежит в HE,
я делаю дек.popfront. Да, удаляю первый элемент из дека. Вот. Ну это довольно естественная штука,
что у нас теперь пересечение может не только какие-то граничные условия с конца давлять,
но и с начала. Вот. Почти все, надо еще только понять при каком условии надо саму HE добавить в
дек. Но ее нужно добавить, если она действительно как бы дает какое-то ограничение. А это случай,
ну вот смотрите, когда она добавляет какое-то ограничение. Когда пересечение первый и
последний не лежит в HE, тогда ее нужно обязательно добавить. Потому что если бы она лежала в HE,
то получается она лежит где-то здесь, и она новых ограничений не добавляет. Вот. Поэтому условия
здесь я пропишу так. Значит, если перешли уже ко второй группе, ну не так. Если мы в первой
группе, то она обязательно добавляется просто автоматически, вот из этой штуки, поскольку она
более крутая, чем все предыдущие, она точно будет лежать в деке. Значит, если в первой группе,
если HE, например, в первой группе, то мы ее точно добавляем в дек, то дек pushback HE, точно добавляем.
Вот. А если мы в второй группе, то нужно проверять условия, что она вот, ну как бы, что она уже может
быть не, не существенная. Она может уже не добавлять ограничений. Для этого нужно пересечь
первую и последнюю в случае, если она не вот эта вертикальная. Значит, ну давайте я грубо напишу,
если HE принадлежит 2, кроме вертикальной прямой, то добавлять в дек, добавляем в дек,
только если пересечение первой и последней из дека не лежит в HE, только если пересечение
первой и последней дек не лежит в HE. Ну вот как-то так.
Ну вроде все. Да, тогда у нас, смотрите, как работает наш алгоритм. Первую группу он обрабатывает
точно так же, как предыдущий алгоритм. То есть он просто идет по первой группе, вот здесь вот, да.
Так. Ну да, он идет просто по первой группе, добавляет вот это вот с концом, то есть он
делает вот эти вот проверки. Он делает еще ненужные проверки про пересечение первых двух не лежит в
HE, и на самом деле это для первой группы никогда не выполняется. Но если выполняется, так. Короче,
для первой группы эта группа никогда не выполняется. То есть если вдруг это верно,
то они на самом деле удалились бы еще вот здесь вот. Если картинка такая, что как-то вот так вот,
и приходит новая полуплоскость вот такая, то мы раньше удалили бы эту прямую, и эта штука
на самом деле никогда для первой группы не выполняется. Затем ее насильно добавляем,
потому что она точно дает новые условия. Потом, когда я перехожу ко второй группе,
у нас уже многоугольник выглядит как-то вот так. Какой-то такой многоугольник, вот эта вот штука,
ограниченная полуплоскостями. Приходит новая прямая. Значит, она либо вообще бесполезна,
тогда это соответственно вот этот случай, когда вот это условие неверно, я ее в дека не добавлю,
и ничего из дека не удалю. Либо же она может, давайте вот такой случай нарисую, какой-нибудь там
самый плохой, как вот так ее нарисую. Она удаляет несколько последних и несколько первых из дека.
Она удалила вот эту, вот эту, вот эту, это были несколько последних, а также вот эту,
вот эту несколько первых. Нет, это он не удалит, только вот эту. Вот. И в конце я ее добавлю в дек.
Сейчас. Блин, сейчас, момент. Вот то, что я написал здесь первый-последний,
это первый-последний вот в этот момент времени. Или так, да, если что-то удалили, то добавить.
Но это недостаточно того, чтобы что-то удалили, потому что она могла быть вот так вот выглядеть,
да, и если мы ничего не удалили, то тоже ее надо добавить. Ну да, если мы хоть что-то удалили,
или если ничего не удалили, то верно вот это, то мы ее добавляем. Да, так верно. Значит, давайте я
здесь вставлю или хоть что-то удаляли, или хоть что-то удаляли, да. Ну либо можно
сказать, что мы вот эту проверку выносим в самое начало, то есть проверяем правда
лишь, что перещение первое и последнее не лежит в h it, и если это верно, здесь было,
то в самом конце я h it добавлю в дек. То есть я вот это условие про принадлежность, ну как
бы про существенность h i выношу в самое начало, если она выполняется в начале, то я в конце
добавляю в дек. Вот так лучше, то есть условия в начало, а pushback, так сейчас,
а pushback в дек я делаю в самом конце, ну собственно, когда все очищу от ненужных прямых. Ну вот,
получается, что мы как бы ну сквозняком все наши прямые рассмотрим, удалим как бы те,
которые несущественны. Вот. Все, хорошо. Ну понятно, что 8 точек здесь будет тоже n log m,
потому что кроме сортировки у нас только линейный проход по деку. Ну какие-то тонкости, какие здесь
есть тонкости? Тонкости. Значит, во-первых, то, что я сказал, с параллельными прямыми надо
разобраться. Из параллельных прямых мы оставляем всегда только самую сильную. Из параллельных прямых
оставляем самую сильную. Самую сильную. Да, ну то есть, что такое параллельные прямые? Это те,
у которых a и b одинаковые. a и b фиксированные, то есть те, которые лежат в одной группе и при
этом у них как бы коллинеарные эти векторочки. Так вот, если у нас есть две прямые, задающие,
соответственно, две полуплотности, то какая из них более мощная? Какая из них задает более
сильные условия? Ну та, у которой c меньше. Если c меньше, то значит, здесь добавляется что-то маленькое,
а значит, на это ограничение побольше будет. То есть, если c1 меньше c2, то вот это вот более сильные,
более сильные условия. Поэтому можем в самом начале, когда мы делаем сортировку внутри первой
группы, внутри второй группы, если мы видим две прямые с одинаковым нормальным вектором, а и b совпадают,
то мы их, скажем, сортируем по c и игнорируем там все подряд идущие, у которых одинаковые a и b,
берем только то, у которого c минимально. Ну или там просто удаляем их из вектора,
чтобы они нам не мешали. Короче, оставляем только самые сильные из параллельных условий.
Значит, еще полезное упрощение такое, что вот смотрите, здесь я все время говорил по дороге
пересечения каких-то прямых, пересечения первых двух, последних двух, первых и последних. Короче,
постоянно вызываю процедуру пересечение прямых. И бывает такое, в принципе, что я вызываю нашу
процедуру для параллельных прямых. Я утверждаю, что если я вызываю эту процедуру для параллельных
прямых, то пересечение точно пусто. То есть если вдруг где-то в процессе этого алгоритма я пытаюсь
пересечь параллельные прямые, то у меня точно пересечение пусто, я могу сразу сказать, ага,
ага, чел, я вижу, ты пересекаешь параллельные прямые, значит, до этого у тебя уже точно было
какое-то противоречие, поэтому я сейчас пересекать не буду, то скажу, что пересекание пусто.
Если алгоритм пытается пересечь параллельные прямые,
мы сразу говорим, что ответы пустые множество. Сразу говорим, что пересечение пусто.
Так, почему? Ну, потому что мы пересекаем всегда только какие-то соседние прямые,
вот в порядке этого многоугольника, то есть я беру либо две последние, это вот подряд
идущие стороны, либо две первые, либо первую последнюю, вот здесь я проверяю первую последнюю,
то есть я всегда проверяю соседние какие-то стороны нашего многоугольника. Но извините,
если я пытаюсь пересечь параллельные при этом, то есть у меня получаетсяalis стороны
соседние параллельные, значит точно я что-то уже настолько не удалялся, что у меня их стороны
двух соседних параллельных挺 много, значит я точно udah что-то такое удалил, что уже Heritage
Ну, многоголик у меня уже точно некорректный, а такое может быть только если соседние стороны параллельны, но такого в реальном мире не бывает, такого для непустого пересечения быть не может.
Ну, например, он что-нибудь так делал-делал, не знаю, там сначала было все нормально. Сейчас, ну что-нибудь придумаю.
Ну, вот, например, он вот такое что-то построил, потом пришла такая прямая, вот такая, которая заставила все удалить.
Да, в ней не лежит ни одна, короче, она дает такое ограничение, что вообще все пусто, вот, и она соответственно удаляет вот эти вот все последние.
А первая остается, потому что ее не с кем пересекать. То есть вот эти вайлы, они работают, коль скоро у нас хотя бы две прямые в деке есть, а если она там одна, то она там одна останется, мы ее никак не можем удалить.
Поэтому у нас после этого в деке будет типа вот это и вот это. Ну, потом, скажем, приходит сейчас вот это и вот это и вот это.
Короче, в какой-то момент у нас в деке может быть вообще что-то неадекватное лежать, и оно соответствует пустому множеству.
И это тогда, соответственно, если, сейчас, немножко плохой пример, да, сейчас сображу.
Вот, я сделаю вот так вот, да, я сделаю вот так, смотрите, наоборот, я сделаю прямую какую-нибудь вот такую, оставлю вот такой, но при этом там были две последние.
Ну, например, если бы я здесь поменял местами эти два вайла, если бы я сначала удалял первые, то я бы удалил все вот эти вот и осталась бы у меня последняя, скажем, вот эта прямая.
Лежит вот это, а потом вот это. И тогда, потом, когда я рассматриваю следующую какую-то прямую, я буду, скажем, рассматривать, пытаться рассмотреть ее пересечения вот с этой.
Вот, и это уже плохо, потому что они параллельны. Ну, что-то такое.
Короче, в какой-то момент я мог удалить все, удалить все из дека так, что у меня остается там только две прямые, ну, скажем, как бы, я поудалял, осталась одна, еще вот эту в конце добавил.
Но это тогда, как бы, соответствует тому, что на самом деле пересечение пусто.
И вот потом, когда я пытаюсь пересекать новую прямую с кем-то, которая дает какое-то странное ограничение, которое тоже надо было удалить, но мы его не удалили, вот, ну, тогда я их могу пересечь, в принципе.
Так, да? Да.
Ну, наконец-то третье. Если в самом конце, если в самом конце деке не больше двух прямых, то нужно вернуть пустое нарастло.
То пересечение пусто.
Да, потому что если пересечение не пусто, в конце должен получиться какой-то адекватный многоугольник. Многоугольник не может сдаваться меньше, чем тремя, тремя сторонами.
Даже если получается просто отрезок, ну, отрезок это вообще четыре аж стороны, четыре ограничения. А если их всего две, то, значит, опять я настолько наудалялся, что удалил вообще всю границу,
положил там какую-то первую сторону и вот эту новую прямую, новую добавленную. Они не образуют многоугольника, а это соответствует тому, что ответ пустой, пересечение пусто.
Ну, вроде все. Последнее замечание такое, что в случае, если у нас пересечение не пусто, у нас может получиться что-нибудь вот такое.
Вот так вот еще может быть. То есть, поскольку у меня все не нравятся всегда нестрогие, то у нас, когда я построил пересечение, в деке могут лежать еще прямые, проходящие просто через вершину.
Потому что они как будто бы задают условия нестрогие, вот такое вот. И они тоже будут лежать в нашем деке. Поэтому если мы хотим построить именно многоугольник, то мне нужно просто попересекать все пары соседних прямых и удалить дубликаты.
Это как раз и отвечает в случае, что если у меня прямая проходит просто через вершину, тогда она как бы два раза какую-то вершину напишет.
Удалить дубликаты вершин. Так, напишу кратко. Удалить дубликаты вершин.
Все, спасибо.
