Сегодня почти закончим с SQL и с его продвинутыми возможностями. Рассмотрим DCL, некоторые пункции,
некоторые команды и варианты команд, которые мы еще не рассмотрели, которые позволяют делать
более сложно интересные вещи с запросами из обработки данных. Поехали. DCL последнее четвертое
подможество нашего глобального множества команд SQL позволяет соответственно нам контролировать
данные путем предоставления доступов и разрешений на операции с ними. Для чего
это вообще в принципе нужно? В первую очередь это обеспечение безопасности данных на уровне
такой логики, что ли, функционирования базы за счет того, что мы можем определить роли,
определить привилегии этих ролей, определить соответственно к каким объектам какие роли
имеют доступ и какие действия над какими объектами они могут совершать. В Postgres
по большому счету реализованы можно сказать полторы модели управления правами, но основная это
role-based access control. Она реализована в полной мере и есть некоторые черты реализованы от
контроля модели разграничения доступа на основе атрибутов объектов. Посмотрим подробнее, что такое
role-based access model. Postgres использует концепцию ролей для управления разрешениями на доступ к
базе данных. Есть еще понятие пользователей, то есть прям физически есть команды, связанные
с предложением user, create user, alter user, grant, что-то там в пользу юзера. Здесь надо понимать,
что на данный момент в Postgres команды, связанные с термином user, с термином role,
они синонимичны, но сейчас правильный будет употреблять термин role в ваших командах.
Role, соответственно, можно рассматривать как пользователя базы данных или как группу
пользователей в зависимости от того, как роль настроена. То есть в рамках одной роли можно
передавать привилегии и эту роль можно передавать не только конкретному человеку,
можно передавать группе пользователей с одной стороны, а с другой стороны в рамках роли могут
быть другие как бы суброли, которые имеют соответственно доступ к привилегиям своей
материнской или групповой роли или не имеют. В зависимости от настроек все можно сделать на
самом деле довольно гибко. Схематично можно изобразить следующим образом то,
как существует модель разграничения доступом на основе ролей. То есть у нас есть некоторые
основные абстракции, скажем так. Есть понятие объекта, понятие действия. То есть у нас есть
какая-то группа объектов в базе данных, мы над ними можем совершать какие-то действия.
Совместно это все называется привилегией, какие действия над какими объектами мы совершаем.
И какие-то привилегии, какое-то их количество объединяются с понятием роли. И роль мы можем
предоставить какому-то пользователю. Пользователю не в смысле предложения юзеру в SQL, а в смысле
пользователю непосредственного базы данных. Основные абстракции. Здесь все то же самое,
но чуть подробнее. То, о чем мы только что сказали. Единственный пользователь соответственно может
получить некоторое количество ролей, не обязательно одно. Наверное это понятно по определению,
по общим каким-то основным моментам. Основные объекты Postgresа перечислены на слайде. В первую
очередь понятно, что это таблицы. Можно обратить внимание, обращаться к столбцам, можно обращаться
к представлениям в юз, последовательностям. Это более продвинутые штуки, которые могут
генерировать последовательности величин, последовательности данных. Можно непосредственно
базу данных считать объектом, функции, хранимые процедуры, схемы и табличное пространство. Все это
может быть объектом. И не только это, скажем так. С теми, с которыми вы сталкивались уже или еще
столкнетесь в рамках курса, это пожалуй основные и даже с некоторым запасом. Соответственно в
отношении всех этих объектов можно гарантировать, можно предоставить какую-то привилегию. Все это
обозначено в качестве какой-то роли. Основной синтаксис. Несмотря на то, что у нас основные
команды на наших слайдах были перечислены на протяжении курса, мы перечисляли всего два,
две, да, grant, revoke. В данном случае create role это не самостоятельная команда получается,
а такая производная от create, от команды create и указанием на определенный объект, который создается
в данном случае роль. Поэтому можно как бы договорить, что это тоже часть синтакса с DCL,
create role команда. Можно это не говорить как, можно об этом не говорить, специально не упоминать,
поскольку это не специфический DCL команда. На всякий случай я говорю в тестах, т.е. в следующем
просто не будет такого вопроса, будет ли create role в синтаксе DCL или нет, чтобы не путаться. Так что
на это счет не переживайте. Но тем не менее мы можем создать роль. Общий синтаксис он приведен
на экране, там довольно все просто, и приведен пример того, как создается роль с некоторым
атрибутом, в данном случае пароль. В стандарте, ну и помимо стандартов документации SQA,
поздно, прошу прощения, перечисляется большое количество атрибутов, ну, вернее сказать,
параметров, если говорить терминологией словного синтакса. Большое количество параметров,
которые можно использовать при создании роли. Можно назначать роль в качестве адмида,
можно разрешать роли логиница в сеанс, ну, там довольно большой перечень, можете посмотреть,
в принципе, там ничего сложного нету. А параметр роли определяет ее полномочий взаимодействия
системы аутентификации клиентов, да, и для изменения атрибутов роли, соответственно, ну,
по аналогии с тем, что мы уже видели для, в частности, таблиц, применяются команды alter, drop,
точно так же, совершенно. Здесь никакой специфики нет, и, опять же, повторюсь,
команда create user теперь является просто синонимом create role, ну, теперь с версии 8.1 поздроса,
то есть почти ровно половину версии назад произошло такое слияние. Ну, маленькое историческое
примарка. Что касается непосредственно команд grant revoke. Вот, по команде grant позволяет нам,
во-первых, ее синтаксис тоже приведен на слайде, во-вторых, она нам позволяет, повторюсь, предоставить
какие-то дополнительные привилегии в отношении каких-то объектов или действий для уже создания
ролей, и команда revoke соответственно делает обратное, позволяет эти привилегии забирать.
Команда grant имеет две основные разновидности, это назначение прав доступа к объектам и
назначение роли одних ролей членами других ролей. Ну, вот, да, здесь на слайде с синтаксисом указано,
что первая часть она видно, что относится к объектам, вторая после предложения to позволяет
указать роль, да, и позволяет соответственно указать там дальше, то есть, какой роли,
и granted by указание роли позволяет указать, к какой группе ролей можно отнести текущую роль.
Примеры grant insert on films to public соответственно позволяет нам для роли паблик, это паблик
ключевое слово в данном случае обозначает роль такого общего доступа. Мы для пользователя по
умолчанию предоставляем ему возможность вставлять в таблицу фильма какие-то данные. Второй
пример позволяет все возможные привилегии для некой таблицы kinds предоставить пользователю
мануэль и последний пример соответственно позволяет у нас в роли админ включить пользователь
джо револк соответственно да как уже было сказано это обратная команда то есть здесь синтаксис
похожий в плане того что мы тоже должны указать либо что мы забираем какие привилегии в отношении
каких объектов или или какие действия запрещаем совершать и указать должны также роль и можем
указать соответственно из какой группы роли какая роль исключается мы можем также показать
да option grant option for соответственно мы можем отозвать право передачи текущей привилегии
от какого-то пользователя но не само эту привилегию и если мы данные указываем
специфик не специфицируем нашу команду grant то да у правой распоряжение им
отзывается по умолчанию совместно примеры ну соответственно тоже довольно простые здесь делаем
все то же самое что предыдущем слайде но в обратном порядке на позапрошлом вернее забираем
у роли паблик возможность вставлять данные в таблицу фильмов забираем все привилегии у роли
мануэль из таблицы кайнс и из группы админов исключаем роль джо из роли админов групповой
роли так вот получается исключаем роль джо так ну хорошо давайте пойдем дальше более продвинутые
функции SQL значит рассмотрим для начала общие табличные выражения по большому счету общие
табличные выражения мы с вами их практически умеем писать и ничего в этом сложного нет ну
для некоторых в принципе уже наверное это понятно потому что кто-то может быть успел
на семинарах пройти а по сути делает те же самые подзапросы о которых мы с вами говорили несколько
лекций назад только синтоксически выраженные более простой форме и ну правда имеющие определенные
нюансы с точки зрения выполнения ну во-первых что можно сказать по выполнению это то что у нас
по в общем случае у нас общие табличные выражения выполняются всегда единожды и перед основным
запросом то есть случаев когда как с выполнением связанных под запросов мы могли попасть в ситуацию
возрастание там до сложности выполнения квадратичной и более потому что у нас по сути
получался вложенный цикл с общими табличными выражениями такое поведение по умолчанию
недопустимо они выполняются повторюсь единожды также у нас получается дали можно разделить
условно операторы которые совершаются внутри общего табличного выражения сети и и которые
совершаются после соответственно внутри сети у нас могут быть select insert update или delete а
после ну тоже select insert update или delete или merge в принципе здесь все тоже довольно тривиально
что еще нужно сказать что сначала ну да у нас все внутри в wi-fi выполняется только потом выполняется
приложение from как уже было сказано и в соответствии со стандартом запросу содержащие сети должны
выполняться как если бы каждой сети было вычислено один раз это относится к тому что у нас внутри
common table expression может быть еще какие-то вложенные выражения здесь сложности у нас не ограничено
по умолчанию и тем не менее все равно это все будет выполняться единожды перед основным запросом то
есть да вот здесь на слайде уже на синтаксе все более понятно что вы recursive запрос вы и какие-то
какой-то определение запроса потом это все соответственно common table expression потом идет
основной select у нас вот все что перед select у нас выполняется перед select буквально то есть
порядок выполнения запроса у нас здесь дополняется как вы помните у нас начинается с from потом
where потом ну и потом так далее там from where идет из основного селекта а в случае наличия общего
табличного выражения перед from из основного селека запрос у нас будет выполняться сначала тем не менее
common table expression если там у нас будет свой селект запрос соответственно он будет у нас идти по
общим правилам селекта начиная со своего запроса from и так далее по порядку выполнения запроса
что такой запрос в определение да это имя запросу и дальше имя столбца можно его опустить если у
нас не рекурсивный запрос и далее мы можем соответственно делать либо выбор путем селекта
либо да как говорилось использовать иные операторы оператор values кстати у нас позволяет возможность
сделать просто-напросто таблицу из неких константных величин values давайте наверное здесь
разоговоримся это нам будет для рекурсии полезно для понимания то есть values мы отдельно его
не рассматривали в рамках курса до сих пор но если вы обратитесь к документации того же
позгресса то увидите что values в списке команд выделено отдельно и по сути дела результат выполнения
команды values как таковой самой по себе что называется это возврат таблицы с тем количеством
значений которые у нас values внутри скобок определено при этом все значения будут в
одной строке вот этой вот итоговой таблицы и мы можем там объединяя несколько запросов
values подряд за счет команды union ну вот так вот искусственно создавать по сути дела
таблицу из констант в ходе там выполнения запроса для чего это нужно ну
как бы бывают случаи скажем так но в общем виде конечно так делать не надо если у вас есть
какой набор константных величин просто запишите их как констант внутри запроса и не надо делать
дополнительных команд с запросом команды values для создания дополнительных лишних таблиц ну
окей сейчас дойдем до рекурсии будет чуть более понятно все это означает а пример сети и да
соответственно что здесь мы делаем ну вот у нас основной селек запрос в общем все понятно наш
типичный селек запрос с группировкой с выборкой по мне даже с под запросом кстати говоря он с
выборкой по вхождению регионов некоторое множество регионов топовых при этом обратите
внимание у нас вот этот вот предварительный запрос сети даже два их во первых мы можем
их через запятую после единственного оператора вы после единственной команды через запятую мы
их можем перечислять псевдонимы мы им назначили да и получается один сети у нас пошел в под
запрос основу запроса селек другой сети у нас оказался в качестве качестве еще в качестве
таблицы да и с которой также у нас под запрос вытаскивает данные уже во втором сети то есть
первой сети regional sales у нас появляется во втором сети топ рэд джонс вот рэд джонс сам
топ рэд джонс появляется у нас в под запросе основного запроса никаких проблем с этим нет
пожалуйста группируйте так вы используете под запрос прошу прощения общие табличные выражения
везде где уместно использовать ссылаться на таблицу потому что до результат выполнения сети
это у нас некое результирующее отношение некое результирующее виртуальная таблица и вот в данном
случае у нас выдаются выдаются итоги по продажам только для передовых регионов предложение да у
два дополнительных оператора об их использовании мы уже с вами сказали что один используется в
другом второй используется в основном селек запросе в качестве внутри даже под запроса можно
было бы переписать без вы как справедливо сказано на слайде но тогда у нас вот в под запросах было
бы но в частности вот в этом под запрос основного запроса просто было бы несколько уровней
вложения селектов несколько вложенных селектов что конечно бы на мой взгляд и на взгляд многих
сильно бы ухудшила читаемость того что мы с вами здесь видим окей давайте рассмотрим рекурсию
рекурсия это по сути дела специальный вид common table expressions и на самом деле хотя это все
называют рекурсии это в стандарте называется рекурсии документации того же постгресса
называется рекурсии это не рекурсия это итерация и по большому счету вот исследователями баз
данных 80 90-х годах были было доказано что мы нашим декларативным сql описать рекурсивный
запрос не сможем не длежащим образом синтаксис практически не меняется за исключением
обязательного включения в него дополнительного ключевого слова ключевого предложения recursive
соответственно используя recursive мы даем команду нашей суббд чтобы хотим сделать наш запрос
рекурсивным что значит в данном случае рекурсивность это означает то что он под
запрос как бы прошу прощения common table expression конечно не под запрос что в наш под наш сети как
бы обращается к собственному результату как бы ну как бы вернее не как бы он бы обращается
к собственному результату ну и мы понимаем что обращение к собственному результату это как бы
обращение к самому себе но на самом деле нет мы просто используя промежуточные схемы для хранения
промежуточное отношение промежуточные виртуальные таблица для хранения результата выполнение каждой
в итоге получаем такой же результат, как если бы мы действительно использовали рекурсию,
то есть вызывали бы наш запрос изнутри него самого повторно, столько сколько там предполагается по
условиям, собственно, запросом. Для чего вообще нужны рекурсивные запросы? Для того чтобы в первую
очередь извлекать данные, имеющие по сути своей иерархическую структуру, но которые тем не менее
хранятся в таком, условно говоря, плоском виде, в виде наших отношений релиционных, в виде таблиц,
по сути дела. Причем таблиц не как мы храним графы в табличном представлении, а в несколько
ином виде сейчас посмотрим как именно. Но давайте посмотрим сначала на примитивный пример рекурсии,
вот это прям не буду даже приписывать себе лишних заслуг, вот это вот просто цитата из документации
Позгресса, здесь такой пример предлагается рассмотреть. Что здесь происходит? Здесь происходит на самом
деле очень простая штука, здесь суммируется числа от 1 до 100. И вот итоговый селект наш основной
выведет соответственно нам там ну больше 5000 в сумме результат. Причем выведет он нам в виде
одного скалярного значения, хотя на самом деле вот здесь вот у нас будет появляться довольно
большая таблица, которая в итоге на самом деле вот здесь вот схлопнется. Давайте попробуем
разобраться, что происходит по этапам. Во-первых, из чего состоит рекурсивный запрос в данном случае.
Вот у нас есть несколько его частей, вот эта вот верхняя рамочка красная,
в которую заключено обращение к некой таблице, по сути не таблице, прошу прощения, к некой
переменной в данном случае. То есть мы помним, что по, так немножко далеко, то запрос WIF у нас
начинается с имени запроса. И вот в примере мы с вами видели, что это просто-напросто после
WIF идет имя запроса, которое мы произвольно назначаем САБИ. В данном случае мы произвольно
назначили некое имя запроса и указали днем на столбец, тоже в данном случае произвольный.
И это важно, потому что у нас столбцы должны, их количество должно соответствовать внутри нашего
рекурсивного запроса. Должно соответствовать тому количеству столбцов, которые мы определили вот
в этой такой переменной нашей, условно говоря, которую мы используем для рекурсии. Нерекурсивная
часть. По сути дела это все, что идет после скобки и до команды union или union all. В данном случае
union all. Вы помните union all у нас сохраняет все повторяющиеся строки. По сути дела,
присоединяя каждую новую строку к уже имеющимся. А просто union у нас тогда бы что сделал,
у нас бы он исключал строки повторяющиеся, ну затирал по сути дела. И после команды union
или union all у нас идет собственно рекурсивная часть. И в данном случае что у нас происходит? У
нас селект запрос, ну во-первых value, давайте все-таки с ней рекурсивной части. Value 1, как мы с вами
чуть раньше сказали, команда values у нас вернет строку таблицы. В данном случае у нас по сути
дела вернет скалярное значение. Будет у нас не строка, а единственная таблица из единственной
ячейки, в которую у нас будет значение единичка. Вот что у нас здесь делает нерекурсивная часть.
Что у нас делает рекурсивная часть? Она обращаясь к столбцу n добавляет в него единичку из таблицы
до тех пор пока у нас значение n не будет равно сотне. Казалось бы окей, почему это все у нас будет
работать больше чем один раз? Собственно говоря, вот почему. Потому что порядок выполнения рекурсивного
запроса, то есть порядок выполнения CTE с вот этим ключевым словом recursive, у нас изменяется,
у нас появляются промежуточные этапы хранения наших промежуточных, собственно говоря, результатов.
Какой порядок? Да, здесь циферка 2 должна быть. Какой порядок? Вычисляется нерекурсивная часть.
Для union отбрасываются дублирующие сроки, все оставшиеся сроки включаются в результат
рекурсивного запроса и также помещаются во временную рабочую таблицу.
При этом важно также понимать, что у нас вот грубо говоря, очень грубо говоря, двойные,
тройные и так далее кавычки, вот мы вот это обращение, вот это обозначение t в скобках n,
n как некий столбец, как некая колонка, мы это можем рассматривать как своего рода переменную и у
нас количество вот этих вот переменных столбцов должно совпадать с тем, что у нас получится в
нерекурсивной части количеством столбцов и в рекурсивной части, то есть если бы у нас здесь
было n1, n2, n3, у нас бы здесь values должно было быть 1, 2, 3 и так далее по количеству столбцов
в нашем имени CTE и вот здесь вот в рекурсивной части также у нас select запрос должен был бы
выдавать количество столбцов, равное количеству столбцов в имени нашего общего табличного
выражения рекурсивного. Далее у нас помещается во временную рабочую таблицу наша нерекурсивная
часть и пока рабочая таблица не пустая повторяются следующие действия. Вычисляется рекурсивная
часть, так что рекурсивная ссылка на сам запрос обращается к текучему содержимому рабочей
таблицы, происходит в принципе то же самое у нас вычисляется, добавляется все это в некую таблицу,
но уже промежуточную и далее содержимое рабочей таблицы заменяется содержимым промежуточной
таблицы, а затем промежуточная таблица очищается. То есть пока у нас не окажется результатом вот этого
запроса пустая таблица, то мы не остановимся в выполнении и остановка произойдет соответственно
по условию в данном случае, что n меньше 100. Как это все еще можно понять, ну как бы более что-ли
на пальцах для себя? Можно попробовать вот что сделать, попробовать разложить вот этот вот запрос
рекурсивный на нерекурсивные части, попробовать его переписать. Тогда у нас вот это values 1 должно
стать create table n к table t, прошу прощения, с колонкой n и мы туда добавляем значение единичка. И вот
мы в отличие от рекурсивного запроса у нас здесь появляется виртуальная таблица, не существующая
в базе нашей, которая условно называется рабочая. Здесь мы ее прямо-прямо создаем, если мы пытаемся
вот разложить для себя, воспроизвести рекурсивный запрос нерекурсивно. А рекурсивную часть
рекурсивного запроса мы повторяем вот следующим образом. Select n from t и union all select n plus 1
from t or n меньше 100. Единственно что? Единственно что? Вот эта часть вот в этой рабочке, она выполнится
конечно единожды. Для полного тождества нам пришлось вот это вот все заключать в функцию или в процедуру и
функции или в процедуре нам проверять условия и итерировать вот это вот, вот этот вот select запрос
столько сколько потребуется. Дополнительно еще и его результаты добавляя в нашу вот исходную
таблицу t, которую мы прямо физически создали. Вот в принципе наверное и все что что нужно
попытаться понять о рекурсивном запросе вот на таком базовом уровне. Для простоты я вам предлагаю
просто руками попробовать поиграться с рекурсией, с простыми какими-то элементарными запросами,
взять тот же вот этот вот запрос по вычислению первых ста, по вычислению суммы первых ста
натуральных целых чисел и посмотреть да вот что будет если там поменять один параметр,
поменять другой, поменять количество колонок, поменять вместо суммы поставить например просто
в основном селегозапросе поставить просто выборку всего что получится в рекурсии и так далее. Но в
целом да надо просто понимать что у нас каждый раз к вот этой нашей первой ну в данном случае первой
строке добавляется новая строка и когда у нас но сначала у нас появляется две сначала у нас
появляется строка с единичкой здесь у нас появляется тоже одна строка но с двойкой она
добавляется вот сюда далее мы прибавляем здесь единичку и у нас появляются строки 2 3
мы их опять добавляем вот сюда потом у нас появ tasted все сразу на 2 строки 1 2 3 мы добавляем
единичку появляется строки 2 3 4 мы добавляем опять в исходную нашу в التي но в рабочую
нашу таблицу, появляются строки 1, 2, 3, 4 и так далее до тех пор, пока мы не дойдем до 100, а
потом у нас все склопывается в основном селекозапросе с помощью агрегирующей функции сам и выводится
просто скалярный результат сложения всех первых 100 чисел. Результат 550, можете там проверить,
запустить запрос, проверить результат, посмотреть. Если мы как раз, как я и говорил, уберем из-за
внешнего селекозапроса функцию суммирования, то из основного селекозапроса у нас получится
просто набор наших данных до сотни, причем, что интересно, да, почему у нас здесь 100 будет,
потому что вот здесь вот, когда мы будем выбирать в последний раз из нашей рабочей таблицы все
значения и прибавлять к ним единичку, у нас условия n меньше 100 еще не сработает. У нас сработает
условие, у нас выберется все значения до 99, мы к ним прибавим единичку, у нас появится 100, то есть
вот этот селект работает корректно и мы вот то, что получилось в нашей рабочей таблице, вернее в
промежуточной таблице, да, с единички по 100, по сотню мы соединим команды union all с нашей рабочей
таблицей и уже на следующем шаге у нас с рекурсию закончится, потому что мы как раз n равно 100 найдем
на, найдем на нашей рабочей таблице. Поэтому здесь, ну, здесь корректный, это корректный результат,
он получится в том числе и у вас и здесь не надо этого как бы страшиться, да, это не баг,
это фича, это особенности обработки рекурсии, потому что здесь мы, соответственно, на этапе 99,
когда мы выберем все значения до 99, а потом прибавим единичку, мы получим сотню, поэтому все
корректно. Ну, это примерно как в цикле while условия у нас идет проверка условия
после совершения операции. Вернее, прошу прощения, перед совершением операции, конечно же.
Давайте посмотрим на более сложный пример. Вот у нас есть таблица parts, мы хотим посчитать,
сколько деталей нам нужно для нашего продукта, our product, то есть our product это некий агрегированный
продукт, состоящий из некоторого количества деталей, а у него есть соответственно, да, части
и субчасти, то есть вот это вот все, если вы обратите внимание, будет построено в виде графа,
вершинами, в виде дерева даже, и на верхушке дерева верхним самым узлом будет our product,
от него будут отходить соответственно, четыре дуги к вершинам bolt, четыре дуги к вершинам nap,
четыре дуги к вершинам washer, и уже от bolt, screw и washer будут отходить, ну, в данном случае от bolt,
конечно же, и от washer тоже, прошу прощения, и от вершин bolt и washer будут отходить еще дуги к screw,
от screw будет отходить дуга к metal, от washer будет отходить дуга к rubber, ну, соответственно,
вот такое вот у нас дерево получается, раз, два, три, четыре, четырех, четырехуровневые максимально
глубину, и мы хотим, соответственно, посчитать, сколько деталей нам нужно для каждого нашего
продукта, вот этого конечного our product, и наш ожидаемый результат вот такой вот, то есть мы
считаем количество дуг, по сути дела, в этом графе, вот our product, четыре болта нам нужно,
в четырех болтах по два винта, ну, так условно, давайте тогда на английском, четыре bolt нам нужно
для our product, два screw нужно для каждого болта, и по одному metal нужно для каждого screw,
соответственно, один на два на четыре получается восемь, восемь частей metal нам нужно, правильно?
правильно, metal восемь, и как нам этого добиться? вот таким вот интересным запросом, обратите
внимание, как мы с вами и говорили, перечисляемые в имени нашего рекурсивного CTE столбцы, они все
должны у нас фигурировать и в нерекурсивной части, и вот они у нас все фигурируют, и в нашей
рекурсивной части, и вот они у нас тоже все фигурируют, и соответственно,
да, да, все правильно, и соответственно, что мы с вами делаем? здесь выбираем в рабочую нашу таблицу
part-part-quantity из таблиц частей наших, где у нас часть является главным продуктом,
где выбираем все части для главного продукта, и дальше мы из таблиц частей и также из
самого нашего этого рекурсивного запроса начинаем выбирать все части, при этом мы количество
из таблиц частей умножаем на количество из нашего рекурсивного запроса, выбираем все части по
условию, где часть равна своей запчасти, ну понятно, да, то есть мы по сути дела вот таким образом по узлам
дерева нашего спускаемся вниз до тех пор, пока у нас не нарушатся условия рекурсии, ну в данном
случае пока у нас не будет несоответствия между частью и запчастью, далее мы ну все это понятно
складываем там где нужно и группируем складываем и получаем нашу результативающую таблицу вот как
в ответе, опять же ну здесь просто рекомендую руками, что называется, попробовать этот запрос
по задавать базе, по обращаться к базе с ним, может быть попробовать убрать грубая, чтобы посмотреть
как у нас и сам quantity например тоже, чтобы посмотреть как вообще у нас сам рекурсивный
запрос отработает в таком первом приближении без какой-то агрегации и обработки его данных в
основном запросе, но еще раз наверное важно понимать пожалуй самое главное это то, что у нас количество
этих наших условно говоря переменных, а по сути дела название столцов должно везде у нас совпадать,
если у нас не будет совпадения, это будет проблема для запроса, у нас он упадет с ошибкой и по сути
дела вот здесь у нас union all, вот все чтобы здесь делаем union или у нас будет union all,
но это уже там как бы частности, по сути дела вот результат рекурсивного запроса это большая
большая таблица, где у нас там могут быть какие много повторяющихся данных, которые мы можем
сгруппировать по столбцам и так далее, то есть вот здесь у нас всегда не вот это вот, не вот
этот приличного вида результат, из семи строк, шести строк сущностных или вот как здесь результат
из скаляра, результат рекурсивного запроса это большая массивная таблица, где там будет много
всякой разной информации жидучей своего часа, чтобы быть агрегированной и обработанной как-то
более рационально, но еще раз повторюсь, что просто вот для понимания здесь нужно поработать с этим
руками и просто покрутить какие-то рекурсивные запросы, поизменять их параметры, примеры
рекурсивных запросов вы можете еще найти в документации позгресса и то еще важно отметить,
что вот таким образом с помощью рекурсии конечно мы обрабатываем в первую очередь какие-то
иерархические данные, данные подразумевающие иерархическую структуру внутри себя, это конечно
не те данные, которые бы хотелось хранить в нашей революционной базе, но за неимением лучшего,
за неимением возможности в рамках, оставаясь революционного подхода, описать граф как-то
более эффективным, приходится делать обход графа таким образом, по сути дела, граф хранимого вот так.
Так, опять же, это не таблица смежности, повторюсь, это совершенно другая конструкция,
которая из теории алгоритмов, алгоритмов о графах не следует, ей вообще не соответствует.
Окей, двигаемся дальше. У нас на очереди представление. Что это такое? Представление,
в принципе довольно простая вещь, это виртуальные таблицы, которые представляют собой результаты
выполнения некоторых SQL запросов. Важно понимать, что представление, в отличие от того, о чем мы
с вами говорили ранее, это не реальная таблица, это просто определение, по сути дела, запроса.
Представление внутри себя всего лишь сохраняет SQL запрос, назначает ему некий псевдоним,
по сути дела, и предоставляет возможность обращаться к нему как к таблице. Соответственно,
у нас представление наше, будучи по сути дела еще не исполненным запросом, может быть,
тем не менее, может фигурировать в любых местах наших реальных SQL запросов, где требуются таблицы
или табличные данные. Представления также могут ссылаться внутри себя не только на таблицу,
но и на другие представления. Соответственно, в таком случае у нас будет каскадное выполнение
представления при обращении к верхнюю уровню. По цепочке, двигаясь вниз к нашим физическим
отношениям, будет соответственно выполняться наш запрос. Вообще цель использования представлений
это абстракция безопасности, логическое разделение данных, но мне лично, наверное,
больше всего нравится в этом смысле абстракция. То есть мы можем создать слой внутри нашей базы,
некий дополнительный слой абстракции, когда даже пользователи смогут обращаться не к нашим
физическим представлениям, а к чему-то, например, к чему-то более похожему, вот обращаясь к теме
проектирования, к чему-то более похожему на логическую схему или, может быть, даже
вообще на концептуальную схему данных. Это уже такие вопросы, немножко перемежающиеся с
хранилищами данных, с обработкой данных, с анализом данных, так сказать, на лету в режиме онлайн,
да, вот с тем, что как мы данные агрегируем, собираем их в хранилища, из хранилища их
выводим на витрины, делаем лапку бы и так далее. Вот тема немножко смежная с этим, она не
тождественна, конечно, но поскольку мы еще остаемся в рамках позгресса и обычной революционной
СОБД, но, тем не менее, связь, да, очевидно, прослеживается, то есть мы можем несколько упростить работу
аналитиком с нашей какой-то конкретной отдельно взятой базой, используя представление как способ
формирования нового слоя, нового слоя абстракции. Так, и позгресс также поддерживает, в принципе,
материализованные представления, то есть те представления, которые могут быть сохранены
в виде физической таблицы, периодически обновляемой либо автоматически, либо вручную. Да, кстати,
ну соответственно, коль скорое представление у нас выполняются на лету в процессе выполнения
запроса, обращающегося к ним, соответственно, у нас представление, да, по сути дела, всегда
некие актуальные данные в отличие от варианта физического хранения результата промежуточных
запросов. Ну понятно, что если мы таблицу храним, она у нас, некую таблицу на физическом уровне мы
подразумеваем, что она всегда у нас актуальна, просто по определению, поскольку мы постоянно в неё
заносим какие-то данные, но чисто технически, вот может быть удобно хранить какой-то набор
агрегатных данных по нашей основной, что ли, схеме данных, потому что не всегда удобно там
джойнить и группировать, агрегировать какое-то большое количество физических таблиц и какое-то
большое количество данных. Поэтому представление, ну правда, конечно, здесь есть нюансы, что если мы
храним какие-то промежуточные данные, периодически их обновляем в виде физической таблицы, мы
сокращаем расходы на запросы. Представления нематериализованы, конечно, расходы на запросы не
сокращают, они просто более удобный синтаксис могут предоставлять конечным пользователям. Ну
окей, ладно, это такие темы более абстрактные. Давайте посмотрим на представления вблизи.
Представления ещё бывают изменяемые и неизменяемые, да, важно отметить. Изменяемые
представления позволяют при этом не только выполнять чтение, но и изменять данные в базовом
отношении, на которые они ссылаются, к которому они обращаются. И по умолчанию все простые
представления являются автоматически изменяемыми. Для сложных представлений такого эффекта может
добиться, ну, например, используя триггеры, в частности триггеры instead of. Что значит
простое представление? Простое представление является таковым, если оно соответствует некоторым
условиям, а именно в списке from должен быть ровно один элемент. В определении представления
не должно содержаться предложение with, distinct, group, by, having и вот еще некоторых. Но, опять же,
это на верхнем уровне запроса. Мы можем внутри вложить, конечно, поиграться и вложить что-то
еще, как бы обманув таким образом систему, что называется. Также не должно содержаться команд
union, intersect, accept и список выборки, то есть то, что у нас между select и from расположено,
а именно перечисление наших столбцов. Не должен содержать агрегатных и оконных функций, а также
функции возвращающих множество. Синтаксис представления довольно простой. Опять же,
используются команды create. Дальше, некоторый набор возможных дополнительных команд. Опять же,
обратите внимание, можно создавать рекурсивные представления. И после create мы используем
дополнительное обязательное слово view и дальше имя нашего представления. Далее
представление, по большому счету, задается как, например, select запрос. Например, создание
представления комедии из данных некой таблицы с фильмами. Мы создаем наше представление по
условию, что тематика или жанр фильма у нас соответствует теме комедии, соответствует маркировке
комедии. При этом обратите еще внимание на нашу select звездочку. Звездочка в данном случае ведет
себя специфически, потому что мы, хотя и вроде бы обращаемся, казалось бы, ко всем столбцам,
но на самом деле наша база запоминает при создании, что мы делаем, а именно, вернее,
запоминает при создании представления свою структуру. И в дальнейшем, когда мы будем
использовать наш запрос, у нас будут выдаваться не все наши столбцы из таблицы фильмов,
а только те столбцы, которые были в таблице фильмы на момент создания запроса. Вот пример
создания представления с изменяемого представления, но это изменяемое мое представление,
оно имеет ограничение по условию проверки. То есть у нас здесь, если мы обратимся, вот мы создали
представление Universal Comedies. Если мы к нему обратимся в дальнейшем по команде insert с
командой insert или update, то мы не сможем вставить или обновить запись, если у нас она не пройдет
проверку, если у нас не будет поля classification равно значению U. При этом ограничение по полю
kind, вот то, о чем мы говорили при создании представления комедии, а мы обратите внимание еще
раз в предложении from, ссылаемся тоже на представление Comedies, созданное ранее. То есть мы при
добавлении в наше представление второго уровня Universal Comedies должны будем соблюсти только по
классификации, только по условию classification правильное значение, мы должны будем добавлять только
сроки с classification равно U. А тот факт, что у нас еще на самом представлении Comedies было наложено
ограничение, то есть столбец kind, он проверяться автоматически не будет. У нас, соответственно,
могут быть какие-то ошибки в связи с этим, если у нас нет ограничений дополнительных на
наше, на нашем базовом отношении. А если мы хотим сделать необходимую проверку не только нашего
текущего отношения представления, к которому мы обращаемся, но и подлежащих представлений,
то есть представления, на которые ссылается наше верхнеуровневое, то мы должны check option
изменить и использовать не local, а cascaded. Тогда у нас в случае создания представления по команде
на слайду, на слайде, прошу прощения, будет проверяться не только столбец classification,
чтобы в нем была маркировка PG, но и столбец kind нашего подлежащего представления Comedies,
чтобы также маркировка была правильная, по сроке, по столбцу Comedies было значение Comedies.
Вот еще пример представления, где поддерживается операция insert и delete,
но изменятся будут все столбцы из таблицы films, кроме вычисляемых столбцов, то есть у нас здесь,
мы выбираем из таблицы films все столбцы, вот f. звездочка, но еще мы добавляем несколько столбцов
несколько столбцов, которые вычисляются в процессе, это country и average rating, при этом
country code to name это некоторая вот у нас функция получается, и average rating это у нас результат
выполнения внутреннего, связан с результатом выполнения под запрос Select, они не соответствуют
в данном случае определению простого запроса, и они у нас изменяться не будут при использовании
insert, update или delete. Хорошо, оконные функции, в данном случае оконные функции это расширение,
можно сказать, функциональности предложения group by, за счет того, что мы можем теперь не склопывать
строки с одинаковыми значениями, а оставлять их различными, так вопрос можно сделать так,
чтобы представление выдавало действительно все значения, даже добавленные после создания view,
но в общем случае оно будет выдавать все значения даже после создания view, просто если здесь вопрос,
смотрите, новые строки оно выдавать будет, новые атрибуты внутри таблицы, к которой оно
обращается, оно выдавать не будет, вот такой механизм, то есть здесь вы ограничены по атрибутам,
вы тогда просто будете обновить представление после создания. С оконными функциями, как уже я
сказал, строки не группируются в одну выходную строку, и оконную функцию можно определить путем
того, что она всегда содержит предложение over, смотрите, здесь довольно синтаксис, наверное,
простой, вот с пониманием опять же оконных функций будет сложнее, то есть когда у нас есть некоторая
функция, мы можем использовать после нее предложение over и дальше определить, собственно говоря,
окно, внутри которых функция получается у нас будет действовать, и для определения окна у нас
существует несколько вариантов, имя существующего окна, но этого мы касаться не будем, а вот partition
by, order by и определение рамки, об этом сейчас с вами поговорим. Предложение, собственно,
over определяет то, как именно нужно разделить строки запроса для обработки оконной функции.
Да, предложение partition by, дополняющее over, разделяет строки по группам или разделам,
объединяя одинаковые значения выражений partition by, и оконная функция вычисляется тогда соответственно
по строкам, попадающим в один раздел с текущей строкой. Предложение order by позволяет определять
порядок, в котором строки будут обрабатываться оконными функциями, а параметр рамки окна
позволяет определить набор строк в ее разделе партиции, которые будут обрабатываться оконной
функцией. Давайте посмотрим на примерах. Оконные функции, если у нас внутри over не определено,
собственно говоря, окно, по сути дела отработает как просто суммирование. Все значения из столбца
salary по сути дела у нас в данном случае подцепятся, просуммируются и присоединятся в виде дополнительного
столбца сам. А вот что будет, если мы в данном случае определим среднее жалование, но окно
определим по департаменту. В таком случае мы везде смотрим на каждую строку и по департаменту мы
соответственно определяем партицию. То есть окно для, ну единственно здесь у нас, прошу прощения,
немножко разновой получился с заголовками и с определением столбцов, но depth name это department,
employee number и salary. Average соответственно average salary. То есть мы здесь в столбце department
выбираем имя, конкретное прошу прощения название департамента depth develop и наша партиция получается
равна вот этому вот окну. Наш раздел, вот оконная функция у нас будет действовать вот в этом
вот разделе develop, но по каждой строке. Единственно что в данном случае у нас нет никаких спецификаций
для определения рамки окна, то есть внутри и внутри партиции может быть еще и дополнительное
ограничение, дополнительная рамка по отношению к строке. И у нас получается тогда функционал очень
похожий на group buy. По департаменту суммируется все жалование и вычисляется среднее жалование,
средняя заработная плата. То же самое по департаменту personnel и по департаменту sales.
Ну опять повторюсь, очень похоже на group buy. Первые три столбца извлекаются из нашей
таблицы непосредственно, а причем для каждой строки таблицы есть строка результата. В четвертом
столбце оказалось среднее значение, вычисленное по всем строкам, имеющим то же значение depth name,
что и текущая строка. Единственное, что здесь еще можно сказать, если бы у нас было group buy,
если бы было group buy, у нас бы ответ был бы не по каждой строке, у нас бы вот это вот все
схлопнулось вместе и ответ был бы только один. И мы бы не смогли его подцепить,
не используя там каких-то дополнительных ущрений, не смогли бы подцепить напрямую
к каждой строке нашей исходной таблицы. С партиционированием с оконной функцией мы это
делаем легко, потому что, как говорилось в определении, результат выполнения оконной
функции при использовании оконной функции у нас не происходит схлопывания строк, у нас вот этот
over, даже определение окна, не заставляет базу данных все это сжимать воедино в некий,
ну условно говоря, сжимать, да в кавычках, в некий агрегированный результат. Давайте посмотрим
еще на пример с order buy. Здесь довольно любопытная штука происходит, потому что order buy у нас
действует по умолчанию с указанием order buy. Ранка состоит из всех строк, от начала раздела до текущей
строки, из строк равных текущей по значению выражения order buy. Но об этом чуть подробнее через
несколько слайдов. Так, и мы здесь, по сути дела, вычисляем ранг по жалованию внутри партиции,
определенной по департаменту. Соответственно, у нас есть департамент, у нас есть жалование,
и вот у нас первое окно develop, разработка, и смотрим тогда, да, какой у нас ранг по жалованию.
6000, это максимально в нашем окне? Да, это максимально, вот у нас первый ранг. И 5200,
соответственно, следующее значение, и 4500 значение номер 4, и 4200 значение номер 5,
почему так? Потому что у нас здесь одинаковые значения жалования, и ранг, он у нас один,
но в общем зачете это уже получается, да, третья строка. Вот эта строка четвертая,
пятая в общем зачете работников, что ли, да, поэтому, то есть это пятая, это четвертый работник
всего, и он на четвертом месте, но он как бы на третьем месте, но по сути он четвертый. Вот такая
немножко сложная логика за счет использования order by rank, но в принципе, если вы попробуете это
руками, вы к этому привыкнете. Выдает порядковый номер, как уже было сказано, для каждого уникального
значения в разделе текущей строки, по которому выполняется сортировка order by. У функции rank нет
параметров, так как ее поведение полностью определяется поведением over. Давайте еще немножко
с примерами. Здесь у нас тоже вычисление суммы заработной платы, но без партиционирования и
только с использованием order by для задания rank окна. Тогда что у нас происходит? Поскольку order
by у нас действует, как было сказано ранее, на все предшествующие строки и на текущую, то когда мы
вот в этом окне начинаем по каждой строке, мы проходим, повторюсь, начинаем проходить по каждой
строке. От сортированной по жалованию получается, что 3500 это наименьшее значение, то есть до 3500
у нас просто физически нет меньшего значения, то есть физически нет другой строки, поэтому здесь
только 3500. Следующее значение 3900, и здесь уже мы объединяем текущую строку с предыдущей,
4200 мы объединяем текущую строку с предыдущими, 4500 тоже самое. Опять же order by идет по salary,
поэтому мы суммируем не сам, суммируем не экспоненциальный рост, получается все здесь
нормально. У нас получается рост по salary, 3500 плюс 3900, 7400 плюс 4200, 11600 и так далее. И
каждая новая строка у нас расширяет рамку нашего окна. Ну, наше окно вернее, скажем так,
правильнее, чтобы не путать понятия. Вот у нас при первой строке окно в виде одной строки,
прошу прощения, для второй строки окно уже из двух строк, для третьей строки окно уже из трех
строк и так далее. Если бы у нас было еще партиционирование дополнительно, например,
по, опять же, по тому же департаменту, то у нас было бы тогда внутри вот этого вот окна нашего,
рамка окна всегда бы двигалась по order by посрочно, то есть было бы первое 4200 значение,
и здесь был бы не rank, а sum, было бы тоже 4200. Второе значение было бы 4500. Рамка окна
внутри партиции была бы уже из двух строк, и sum была бы 8700. Дальше было бы 505200. Рамка окна
была бы уже из трех строк, и была бы sum соответственно 8700 плюс 5200 до 13900 и так далее.
Поэтому вот это вот задание окна, определение окна, оно не взаимо исключающее, вот то,
что здесь приведено, а оно взаимодополняющее, и мы можем поэтому говорить о том, что у нас есть
окно, которое задается командой over. Внутри окна мы можем дополнительно еще задать выражение,
которое нам это окно либо сузит, либо как-то специфически расширит, и внутри окна мы
можем задать еще и рамку, по которой будет наша функция проходить, чтобы уменьшить или каким-то
образом специфическим агрегировать наши результаты так, как нам это необходимо.
Так, хорошо, тогда у нас небольшой комментарий по селекту, который мы с вами только что видели,
по тройоконной функции. В общем-то бы это уже все сказали, что накапливаются зарплаты от первой,
самой низкой до текущей, включая повторяющиеся текущие значения. Обратите внимание на результат,
вот в одинаковых сроках он не просуммировался у нас, потому что в данном случае у нас нет,
ну не просуммировался дважды, потому что в данном случае у нас однопорядковый
результат для выполнения вот этой команды. Order by salary, то есть 4800, 4800, он не различает,
как и 5200, 5200, поэтому для него это одно и то же, он не считает это, ну парсер, оптимизатор и так
далее. Наш SQL запрос не рассматривает вот эти вот строки как различающиеся, они для него едины,
и он SQL запрос для себя внутри вот своих каких-то оптимизационных процедур нашей СВД уже учел эту
строку и новое идентичное значение для него уже не воспримет.
