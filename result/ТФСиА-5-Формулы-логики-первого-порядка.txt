Я напомню, что в прошлый раз я начал рассказывать про логику первого объекта.
Проформализм, который позволяет выражать цельирательные математические угрожения.
Устроил он так, чтобы выразить, что у него есть и есть и есть, и есть и есть, и есть и есть, и есть и есть.
Устроил он так, чтобы из каких-то предикатов, то есть отношений,
с помощью перейско-множных операций, ну или булевых операций, если смотреть на предикаты, как на логическое высказывание,
устроим более сложные предикаты.
Также мы можем использовать пантеры, и у нас есть возможность использовать функции.
Вот сегодня я сформулирую более точно определение этого формализма, что мы можем, что не можем.
Начать я хочу... Вопросов тут будет два.
Первый вопрос – выразимость, что мы можем выражать, если мы зафиксируем какие-то предикаты,
что мы можем выражать, используя наши средства и данный базовый набор предикатов.
Ну и второй вопрос – что мы можем доказать. Этот вопрос мы отсудим только в относительно частном случае.
Ну и примерно я объясню, что происходит в общем случае.
Ну вот, в том, что касается выразимости.
В прошлом семестре курс алгебры мы изучали – группы, кольца, поля, и все это примеры более общего понятия модели.
Что такое модель?
Модель – это такой довольно сложный набор.
В котором мы указываем некоторое множество, которое называется носитель модели.
Выделяем некоторые предикаты или отношения. Они могут быть разной арности.
Будем быть цель на этом же множестве.
Ну и каким-то элементом этого множества мы даем специальное имя, это называется констант.
Вот если все это задано, мы говорим о том, что задана модель.
Ну, например, группа. Если у нас есть группа G, тогда модель есть соответствует.
Ну, во-первых, G как множество.
Во-вторых, предикат равенства.
Ну, когда мы рассуждаем о группах, мы говорим, что один элемент группы равен друг другу.
Ну, это вот бинарный предикат, он нам нужен.
У нас также есть бинарный функциональный символ взять обратного элемента.
Бинарная функция символа будет чуть позже.
Бинарная функция – перемножение элементов группы.
И обычно, когда мы что-то говорим о группах, нам нужно уметь указывать на нейтральный элемент.
Вот нейтральный элемент это как-то обозначается.
Ну, допустим, есть, в случае общей группы обычно его обозначают.
Вот это типичный пример модели.
Забирая немножко вперед, я сразу скажу, что в модели очень существенно какие арности у предикатов и функций.
Если это задано, мы говорим о сигнатуре модели.
То есть сигнатура – это не сама модель, а вот то, какие у нас есть операции логические и содержательные.
Ну, вот здесь, скажем, сигнатура – один бинарный предикат, один функционал, одна бинарная функция и одна константа.
Вот эта сигнатура.
И в принципе у нас может быть очень много моделей в той же самой сигнатуре.
Я могу предикат на что-то заменить, оставался бинарным, функцию на что-то заменить, эту функцию, ну и элемент модели любой выделить.
Получится какая-то модель.
То есть даже оставаясь в рамках группы, мы можем на той же группе задать какую-нибудь другую модель, задав в качестве отношения что-то другое.
Например, отношения соображенности задав как бинарный предикат, функции как-то по-другому задав вместо константы.
Для конкретной группы выглядит такой-то другой элемент.
В общем, моделей очень много.
И возникает такой вопрос.
Вот у нас задана модель, повторяю еще раз, вопрос о выразимости.
Я думаю, несколько раз сегодня буду возвращаться.
Вот есть модель.
У нас есть какие-то базовые предикаты.
И мы можем, используя эти базовые предикаты, выражать что-то еще.
Причем я напомню, у нас, когда мы берем кванторы, мы уменьшаем арность предиката.
У нас иска арного предиката получается к-1.
Если мы возьмем квантор по мунарному предикату, у нас останется 0 арный предикат.
Что такое 0 арный предикат?
Это просто логическое значение.
У нас появляется возможность выражать какие-то утверждения.
И нас интересует, какие предикаты и какие утверждения в данной модели мы можем выразить, если мы ограничены себе этими средствами.
Почему мы хотим ограничить себя какими-то средствами?
Потому что это позволяет сформулировать внятно математическую задачу.
Если мы каждый раз что-то будем добавлять в какой-то новый предикат, то не очень понятно, на чем мы остановимся.
А так у нас появляются какие-то возможности сказать, что вот такой-то предикат не выражается.
И если он нам нужен, мы должны его добавить в сигнатуру.
А вот какие-то выражаются.
Например, здесь константа, вообще говоря, избыточна.
Можно определить константу, используя равенство и отношение квантера.
Потому что что такое нейтральный элемент?
Нейтральный элемент удовлетворяет такому свойству.
Для любого элемента рукой выполняется вот такое равенство.
То есть мы можем определить, каким образом этот элемент, дальше его использовать в суждении.
Но часто удобно все-таки вводить дополнительные символы.
Иногда это вообще принципиально.
Может быть, не забуду об этом сказать, когда найду этого учебника.
Давайте посмотрим на какую-нибудь новую модель.
Не такую, как уже было.
И эта модель будет нам интересна довольно долго, но ее будет довольно долго изучать.
Она традиционно называется алкебротарская.
Вообще, когда у нас задан набор предикатов функции констант,
помимо того, что модели еще говорят об алкебрах предикатов,
что мы можем какую-то евроидческую структуру навести с помощью тех операций, в которых я говорил.
Алкебротарство – это вот что такое.
Ввестителем являются действительные числа.
Предикаты – это сравнение чисел по величине и на равенство.
Ну это, опять-таки, искусственная работа.
У нас есть умножение, у нас есть заражение.
И традиционно добавляются две константы.
Опять-таки, вы понимаете, что их можно, конечно, выразить.
Но для простоты записи формул мы их добавляем в сигнатуру.
И возникает естественный вопрос.
Что можно выразить такими выразительными средствами?
Мы говорим о действительных числах, но нас интересуют не все мыслимые свойства
решения о действительных числах или какие-то утверждения о действительных числах,
а те, которые выражаются только с помощью этих базовых предикатов.
Например, понятно, что мы можем выразить такой предикат, что уравнение квадратное имеет корень.
То есть, это предикат, он тернарный, он от трех зависит в переменах A, B и C.
Если вы зафиксируете значение A, B и C, это получится истинный или ложный.
Для каких-то уравнений корня есть действительных числа, для каких-то нет.
Ну и что еще можно выразить?
В принципе, довольно много.
Понятно, что мы можем выражать все, что можно выражать гиброрически, используя еще неравенство.
У нас есть сравнение по величине, то есть мы можем еще задавать неравенство.
Этому вас, наверное, еще ни в каком курсе не учили.
Многие факты из выпухлой геометрии можно так выражать.
Но не все, а те, которые задаются алгеброрически.
Содержательно алгебротавство интересно тем, что оно практически покрывает элементарную геометрию.
Давайте обратнусь.
Символически напишу вот так.
Ну, элементарная геометрия – это классическая область математики.
Поэтому достаточно интересно, что этими средствами мы можем выразить более-менее все теоремы.
Я не буду обсуждать, что мы именно можем выразить.
Но сейчас объясню, как это делать.
Ну, собственно, вы это знаете.
Для простоты я буду говорить о планеметрии только.
И вы хорошо знаете, что есть такой способ в свои геометрические утверждения о числах ввести систему координат.
Ну, давайте введем прямоугольную систему координат.
После этого каждая точка плоскости – это просто пара чисел.
Что такое прямая?
Прямая – это…
Ну, можно по-разному это записывать.
Давайте я это запишу вот так.
Это множество решений линейного равнинга.
Ну, нужно еще потребовать, чтобы не все коэффициенты одновременно обращались в ноль.
Да, как раз все прямые будут замкнуты.
Соответственно, если мы хотим сформулировать предикат, что какая-то точка лежит напрямой,
это сделать очень просто.
У нас есть это управление.
Вот мы поставили пять чисел.
То есть это предикат, который зависит от одной прямой и одной точки.
Но прямая у нас задается тремя числами.
А точка двумя?
Ну, значит, от 50 до 60.
Точно так же можно написать уравнение окружности.
Хорошо знаете, конечно, это то, что окружность с произволенным центром отдаётся одним поменям.
Тут мы тоже используем только алхебрические операции, которые у нас есть в модели.
И, соответственно, предикат – точка лежит на окружности.
Мы можем выразить.
Ну, можно более сложно для вас, хотя я думаю, что вас уже все-таки кто-то учил,
выразить свойство, что точка, скажем, лежит внутри треугольника.
Давайте я до краткости, как это обычно мы делаем, буду писать пары чисел одним отозначением.
Сейчас P1, P2, P3.
И х – это пара чисел.
Как сформулировать предикат, что вот х лежит внутри задного пиолета?
На самом деле очень просто.
Можно и с разными способами делать.
Самый простой такой.
Мы говорим, что у нас найдутся три числа, которые обладают таким свойством.
Я использую обычное сокращение объекта в операции.
То есть ламба 1 умножить на кроя 1.
Каждый чисел умножаем на ламбу f.
То же самое.
Число является такой линейной комбинацией.
Все эти числа ненавицательные.
И в сумме дают один.
Вот это свойство выражает, что точка лежит в треугольнике.
А у вас есть учитывание такого представления треугольника?
Да, это называется геометрией…
Ой, как вы сказали?
Гиперполический.
Ну, гиперполический.
Действительно, слово забыл.
Действительно, можно сказать, что это координаты выпуклые.
И с помощью можно выводить.
Можно сделать по-другому.
Я думаю, это тоже вам легко сообразить.
Зная координаты точек, можно взять уравнение.
Например, если существуют какие-то коэффициенты,
такие, что эти точки лежат на этой крымке.
И дальше написать три нерадиста.
Что х лежит в одной полуплоскости относительно одной крымы относительно этой крымы.
Эти способы замечательным образом.
Я не говорю о частных случаях двух разных представлений выпуклых.
Про это я не буду говорить.
Но в случае алгебры таска вот так все получается.
Ну и теперь смотрите.
Как устроены теоремы геометрии?
Ну, теорема геометрии, типично, говорит, что все точки лежат на одной прямой или на одной окружности.
Или все окружности проходят через одну точку.
Или все прямые проходят через одну точку.
Ну, я так утрирую.
Но более-менее только про это и идет речь.
Скажем, знаменитая теорема Эллера.
Что вы можете определить центр тяжести треугольника.
Центр описанной окружности.
И точку трещения высота.
И они лежат на одной крыме.
И это можно записать в алгебритарском академическом утверждении.
То есть это будет замкнутое выражение.
Нуральный предикат.
Оно истинно или ложно.
Оно в данном случае истинно.
И вопрос, как это доказать.
Ну, если вы немножко подумаете, у вас может быть какой-нибудь вопрос.
Эллеры еще очень любят углы.
А, увы, они как-то не очень понятно, как их в эту картину вписать вначале.
Потому что полный угол это 2p.
У нас константы p нет.
И функции sin и cos нет.
И это не случайно.
Потому что это меняет образительные возможности в нашей модели.
Но для теоремы элементарной геометрии выход очень простой.
Если у вас есть угол, значит вы знаете его две стороны.
Вы берете по точке на стороне, получите тривольник.
И cos этого угла вы можете выразить по теорему cos.
Ну и зная cos, если это тривольник, то, понятно, угол от уля 180.
Поэтому в сущности вы знаете.
Можно и sin как-то попытаться написать.
Во всяком случае те теоремы, где нужно говорить о делечении угла,
можно всегда переформулировать,
говоря о значении sin и cos,
которые уже гибролически выражают через длинный сторон.
Ну а длинный сторон там, конечно, нужны квадратные корни.
Но, я думаю, вам понятно, что квадратный корень нашими образительными средствами выразить легко.
Вот, я пишу условия, что s это квадратный корень из-за.
Что это такое, что s в квадрате равно?
Ну, ничего сложного, просто определение квадратного корня.
Дальше я это s могу где-то использовать еще для каких-то отражений.
Таким образом, интерес стал гибритарского совершенно не в разном.
Тысячелетиями считалось, что доказательство геометрических теорем – это сложная вещь,
требующая, чтобы выразить квадратный корень.
Теорем, требующая сообразительности, интеллекта и так далее.
И математики тратили и тратят до сих пор массу времени.
Ну, сейчас уже любители математики, профессиональные математики,
в какой-то планемент их не занимаются.
Ну, разве что по кубе.
Но, тем не менее, есть огромное количество теорем.
Люди доказывали, всегда доказывали, всегда это считалось сложным.
Вот, все эти теоремы можно сформулировать в базе Гритарского.
И, в частности, поставить вопрос не взяли.
Потом все эти теоремы как-то автоматически доказывают.
Вы писаете компьютерную программу, которая открывается в школе вечернего геометрия,
берете задачу, записываете соответствующую форму в архитектуре гибрита.
Ну, и программа вам говорит «да» или «нет»,
если задача вычислить длину, то на какой-нибудь длину.
В общем, все такое.
Ответ довольно интересен.
Такая программа существует.
То есть, есть алгоритм, который это умеет делать.
Но у него есть некоторая принципиальная с ним сложность.
Но давайте это я скажу позже.
Сейчас, пока это я немножко забегаю вперед.
О чем я хочу сказать сейчас?
Буквально через три минуты я начну довольно тяжелую часть своей лецы.
Я буду давать очень длинное определение.
Если вы помните, как я определял форму за счастливым,
то скажу, что это было довольно длинно.
И, вроде бы, очевидная вещь, я потратил там кучу времени.
Сейчас я потрачу еще больше времени.
Это, вроде бы, очевидная вещь.
Вот я вам уже пишу выражение.
Зачем еще что-то определять?
Есть принципиальная проблема.
Она во всем этом курсе, включая, когда мы будем изучать алгоритмы,
тут ситуация такая.
Если у нас есть способ что-то выразить,
вот как я с треугольником написал,
то нет особого сомнения, что я выразил предикат,
точка лежит внутри треугольника.
Таким вот способом.
Надо еще проверить, конечно, что это корректно,
но это вопрос уже к содержательной геометрии.
Правда.
Но если у нас не получается выразить какой-то предикат,
что это значит?
Давайте посмотрим на такой предикат.
Умаг.
Я его обозначу.
Мне удобно иметь для него обозначение.
N от X.
И словами напишу.
X целая положительная.
Для каких-то действительных чисел этот предикат есть,
для каких-то ложных,
ну вот, действительный, ровный,
для целых положительных, в принципе.
Можно ли его выразить в алгебритарском?
Ну, с одной стороны, непонятно.
С другой стороны, давайте вспомним математическую индукцию.
Мы знаем, что любое натуральное число получается единицей, прибавлением.
По следовательным прибавлениям единицы.
Поэтому я могу написать такое выражение.
X равно единицы.
Или...
Существует такое или,
что или тоже удовлетворяет этому предикату,
или, ну, не важно в каком порядке,
плюс будет и сравняется или плюсов.
У меня нет пока сочетания,
но так вот я записать могу.
Выразил ли предикат X целое число?
Ну, а куда деваться?
Мы знаем, что к такому свойству будут удовлетворять только целые положительные числа.
Что?
Да.
Ну, смотрите, я когда в прошлый раз вводил разные операции,
вот здесь использовано то, о чем я не говорил.
Мы определяем предикат N,
используя значение N для других значений элементов.
Это рекурсивное определение.
Рекурсивное определение, как всегда, кориентное.
В данном случае кориентное, это можно отдельно показать.
Но это требует отдельной работы.
Но в этот момент возникает вопрос.
Выразили мы или нет?
Чтобы на этот вопрос можно было ответить,
нужно зафиксировать те выразительные средства,
которые мы можем использовать, и использовать только их.
И тогда у нас появляется принципиальная возможность доказать,
что какой-то предикат нельзя выразить.
Пока я этого не сделал, у меня руки свободны,
но вот я показал, как можно использовать свой предикат.
Ну, забыл про рекурсивное определение.
Вот и и так.
Еще один вопрос, который тут естественно возникает.
Он такой.
Ну, хорошо.
Я вот какой-то ограниченный набор выразительных средств ввел.
Сейчас вот вам показалось, что есть рекурсия, есть еще разные приемы
в определении математики.
Почему бы не рассмотреть самые общие выразительные средства?
Ну, во-первых, потому что этот список открыт.
Завтра кто-нибудь может придумать еще какой-нибудь этот список.
То есть если мы хотим что-то утверждать определенно,
как математическое утверждение, нам нужно этот список зафиксировать.
Можно ли добавить в рекурсию выразительные средства?
В принципе, можно, хотя там уже нужны довольно сложные оговорки.
Повторяю еще раз, не всегда рекурсивное определение корректно.
Но тогда получатся другие выразительные средства.
И для них тоже что-то не будет выражаться, но доказывают уже сложнее.
То есть это логики этот вопрос изучают.
Логики с индуктивными определениями вполне себе существуют.
Есть много разных способов определять логику.
Я напомню, что я никогда не начал говорить,
я говорил, что я буду вам объяснять про формализм логики первого порядка.
И это намодит на мысль, что, наверное, есть и логика второго порядка,
и еще какого-то порядка, и они сложнее и, естественно, более выразительные.
В частности, в логике второго порядка,
в алгебритарство примените предикат, и целое выразить можно.
Так что вот теперь я предупредил вас,
и должен начать вот эти сложные определения.
Ну давайте модель я оставлю, это нам еще понадобится,
там потом чуть-чуть подправлю запись,
ну уберу алгебритарство.
Алгебритарство я несколько раз буду возвращаться.
Одна из моих целей доказать, что при правильно зафиксированном формализму
предикат из целой невыразимости.
Это доказательство невыразимости всегда сложнее.
Мы должны как-то поработать против всех более угодно умных людей,
которые будут пытаться выразить.
Понимаете, да, мы должны ограничить всех всех всех.
Какого-нибудь потенциального ароматучана,
еще какого-нибудь смышленного парня.
В общем, это нужно делать правильно,
тем не менее в некоторых ситуациях это удается,
и я вам это докажу.
Не сразу, это как раз будет довольно длительный процесс,
но начать надо с того, чтобы зафиксировать определение.
Я определил то, что называется формулы первого порядка.
Давайте я напишу.
Развернута логики первого порядка.
Я буду обычно говорить формулы первого порядка,
чтобы не накрутить уголовных людей.
Это похоже на те формулы, которые я определял на исчисление
высказывания, я их буду называть булевые формулы для определенности.
Они выражают булевые функции.
Формулы логики первого порядка будут выражать предикаты.
Как мы поймем, но что именно они будут выражать,
это мы вернемся к этому вопросу чуть позже.
Давайте зафиксируем определение,
прежде чем объяснять, что же вот эти конкретные формулы выражают.
Формулы, как принято в логике, я буду определять как слова.
Слова в некотором алфавите.
Давайте я К, припишу буквы ФО,
указывая, что это алфавит логики первого порядка.
Из чего он состоит?
Он довольно многое из чего состоит.
Я сейчас перечислю.
В случае...
Формулы, представляющие булевую функцию, у нас были только каймены.
А тут, видите, большой наморд.
И даже с двумя индексами.
Да, а вот теперь у меня будет сложно.
Я тут стал ставить запятые.
На самом деле, запятая сама по себе это элемент нашего алфавита.
Нам требуется в нашем формулизме запятая.
Я вот так это напишу.
Ну круглых скобок у меня, слава богу, нет.
У меня такие феррорные скобки сейчас написаны.
Вот это тоже есть.
Что мне еще нужно?
Ну, мне нужны булевые связки.
Мне нужны кланки.
Ну, кажется, все.
Запятые, скобки, булевые связки.
Там все.
Значит, вот эти вот бесконечные части алфавита.
Тут есть конечное количество уже символов.
А бесконечная часть алфавита, это вот называются символы переменной.
А бесконечная часть алфавита, это вот называются символы переменной.
Мы будем считать, что их бесконечно много.
Вот они задумированы.
То есть счетное количество.
Это мы будем называть символы констант.
Это мы будем называть предикатные символы.
Почему символы?
Потому что это алфавит.
У нас будет составляться формула в виде слова.
И там вот элементы этого алфавита, в частности, вот такие.
А это функциональный символ.
Ну, и вот эта клавка, которая наверху написана, она существенна,
потому что она указывает, какой символ.
То есть мы просто сразу говорим, что А3,2 это вот...
Это не то же самое, что А3,2.
Это второй символ арности 3.
АА2,2 и второй символ арности 2.
То есть у нас для каждой арности есть бесконечная последовательность символов.
Ну, в реальной жизни, конечно, мы придаем этим символам какие-то конкретные имена.
Вот как я уже делал содержательные прицелы.
Вместо того, чтобы писать F1,2, если я хотел бы быть совсем аккуратным,
я бы писал как-то вот так.
А потом бы сказал, что вот это вот сложение, вот это вот тоже.
Ну, легче от этого читать формулы не станет,
поэтому в конкретных примерах я буду вместо вот этих вот формул,
писать удобные семантические обозначения, которые в сути получаются.
Ну, это я забегаю немножко в сторону, потому что сейчас нам нужно определить,
что такое формула.
Для этого нам...
Вот, мы зафиксировали такой алфавит, чтобы нам хватило всегда всего этого.
И...
И, к сожалению, определение формулы первого порядка сложнее,
чем определение болевой формулы.
И оно состоит из нескольких этапов.
На следующем этапе мне нужно определить то, что называется терм.
Это еще не форма.
Это тоже слова алфавита.
Какие?
Определение рекурсивное как раз здесь, так же, как и было с болевыми формулами.
Термами, во-первых, являются слова, которые состоят из одного символа переменной.
Во-вторых, слова такого вида.
Вначале стоит функциональный символ, потом открывающая скобка.
Дальше через запятую перечислено n каких-то терм.
И стоит закрывающая скобка.
Корректность определения здесь обеспечивается чем?
Что, если вы имеете какое-то слово...
Ну, тем, что у нас есть условия обрыва в рекурсии.
Любой терм, если его длина больше двух, если его длина один,
мы должны просто посмотреть, написано символ переменной или нет.
Если символ переменной в терме, если нет, то нет.
А для слов высшей длины вы должны, прежде всего, посмотреть на самый первый символ.
И по нему вы определите арность.
То есть, сколько у вас дальше должно идти такое слово.
В круглых столбках через запятую перечислено n слов.
n отвечает арности этого символа.
Если это не так, то это уже не терм.
Вы можете сразу сказать, что это не терм.
А если так, вы должны посмотреть на каждое из этих слов.
Оно более короткое.
И снова применить то же самое определение.
Таким образом, вы спуститесь в долгий ринг.
Ну, почему нужны термы?
Я, собственно, уже сегодня это делал.
Чтобы написать вот такой вот предикат,
мне нужно уметь использовать не только переменные,
но и какие-то результаты применения,
имеющихся у меня функции, переменным.
Возможно, константом.
Ой, прошу прощения.
Константы тоже термы.
Я извиняюсь.
Переменные и константы.
Термы 1, переменные и константы.
Это я, прошу прощения, забыл.
Потому что мы хотим что-то вычислять.
Ноль у меня написан.
Если я начну разбирать термы, то мне надо будет иметь констант.
Итак, это общий способ записи суперпозиции функций.
То есть функции в общем виде мы записываем всегда похожим образом.
И у нас не будет никаких инфиксных записей и так далее.
Просто чтобы для единобразия.
Небольшое возведение.
Квадрат взять обратно.
Все это мы в формализме хотим у нас.
Следующий этап.
Это мы определяем элементарные или короче говорить атомарные формы.
Это снимаем.
Это сравнительно простая вещь.
Потому что это слова совершенно конкретного языка.
Они начинаются с предикатного символа.
И дальше, примерно как в поделении термах.
В круглых словах, через которые написано N термам.
И N это арность вот этого предикатного символа.
Вот это и только это является элементарной формулой.
Ну понятно, что прогреть является без слова атомарной формулой очень легко.
Вы смотрите на первый символ.
Он должен быть предикатным.
И по нему вы знаете.
У каждого символа известная парность.
Просто преди как каждому символу.
Значит дальше разбор должны делать так.
У вас дальше должно все начинаться с открывающей скобки.
Заканчивается открывающей скобкой.
Выделите запятые, сколько их есть.
Их должно быть N минус 1.
Получается N каких-то под слов между скобками и запятыми.
И каждый из этих слов должен быть тихим.
Проверили.
Если все так и есть, то это...
Вы получили элементарную формулу.
Ну только элементарную формулу нам точно не будет хватать.
И вот собственно формулу.
Давайте чтобы еще не стирать, напишу на этой доске.
Значит определение опять рекурсивное.
Значит формулы это атомная формула.
Или один из возможных случаев.
Давайте я сразу где-нибудь здесь напишу.
B церковной.
Где это понадобится.
Не обязательно.
Ну и дальше случаи.
Что я могу формулу применять?
Ну даже как в случае буревых формул могу применять
композициональный связки.
Мне сейчас удобнее не экономить связки.
Я отзыву цвета.
Я уже сразу включаю.
Они выражаются.
Но тем не менее давайте подстирать.
Ну и вот.
И есть новая форму.
Ой, только я там B и C написал.
Прошу прощения.
Я не очень понятно стал писать.
Значит слово A является формой.
А форма если.
Атомальная формула.
Или вот здесь вот.
Я буду писать уже равенство.
Давайте аккуратно перепишу.
А то получается не будет.
Эта часть повторяет определение.
Как мы видим буревые формулы.
Это в каком-то смысле.
Обращенный вариант.
Это.
Обращенный вариант формул первого порядка.
И есть еще две формулы.
Которые как говорят.
Получаются навешиванием пантера.
У нас возникает такой пантерный блок.
И за ним следует формула.
Давайте сразу мне все равно по ноге собеседим.
Вот это вот.
Под формулом.
Формула называется область действия.
То есть это чисто.
Это не токсичная форма.
Если глядя на слово.
Мы можем определить где оно заканчивается.
Сколько я формулок иногда буду опускать.
Но если не понятно.
Надо просто указать старшинство операций.
Я буду считать что.
Клантеры.
Давай считать что они старше чем логические операции.
Я постараюсь ставить все скобки.
В соответствии с этим проектом.
Если я какие-то скобки буду пропускать.
Вы не стесняйтесь.
Меня переспрашивают.
Возможно ситуация.
Что я чего-то напишу.
Вроде бы понятно.
Скобки вокруг пантеров почти никогда не ставятся.
Потому что скорее происходит так.
Тут есть вот эти скобки.
И мы можем всегда определить.
Но в общем определение лучше их ставить.
Почему?
Потому что скобки.
Я напомню.
Они задают нам дерево разбор.
Давайте я вот здесь вот сотру.
Да и других формул нет.
Это позволяет опять таки устраивать разбор.
Мы можем находить.
Самую внешнюю.
Применяя одного из этих правил.
Самое внешнее.
Значит сзади получается дерево.
Но дерево теперь получается более сумасшедшее.
Смотрите.
Вершинам этого дерева уже могут быть приписаны пантеры.
Вот так вот.
Вот здесь у нас возникает уровень атомарных форм.
Когда написан предрекратный символ.
Под ним уже идут не формулы, а термы.
То есть дерево разбора мы, естественно, можем построить.
Термы тоже разбираются.
Скобка определения тоже такая.
В самом конце переменные константы.
Каждая ветка дерева заканчивается листом.
Где написано переменная или константа.
Но теперь у нас возникает уровень атомарных форм.
Но теперь у нас возникает такая сложная структура.
Выше предрекратных символов у нас идут логические звездки и пантеры.
Ниже предрекратных символов идут функциональные символы.
И переменные константы.
И теперь разница в общем.
Когда мы будем придавать значение формы.
Вот вы помните как у нас был булевый случай.
Мы переменным присваивали булевые значения.
И дальше по дереву мы просто хролажим.
Каждый решение дерева сопоставляли логическое значение.
Дерево у нас будет не так.
У нас теперь переменные будут сопоставляться значения в некоторой модели.
Я сейчас сразу поправлю.
Даже может быть сейчас будет перерыв.
В общем смотрите.
Чтобы формулам придавать которые используют предрекратные символы.
Р1, Р2, Р3, Р4, Р5, Р6, Р7, Р8.
Нужно задать модель соответствующей сигнатуры.
То есть у нас известно предрекратные символы в какой тарности.
У нас в модели должно быть соответствующие отношения и так далее.
В квадратных скобках я пишу отношения.
Теперь это у меня.
Меняю смысл записи.
Для какого-нибудь места на доске.
Теперь у меня это символы.
Функциональные предрекратные символы.
И я теперь хочу интерпретировать некоторые модели.
Давайте сейчас сделаем переворот.
Как раз самое время.
Потому что правила оценки тоже отдельная история.
Это очень короткие.
Итак я определил такую довольно сложную вещь.
Формулу первого порядка.
И теперь я хочу придавать ей значение.
Чтобы придать значение формуле.
Мне нужна модель.
Но одной модели не достаточно.
Мне еще нужно то, что называется оценка перемена.
То есть каждой переменной мы сопоставляем.
Давайте это называем оценкой переменной.
И буду использовать такое обозначение.
Мы сопоставляем некоторые элементы модели.
И обозначать это буду так.
Я буду брать переменную в квадратные скобки.
И приписывать пи.
Это у меня будет общее обозначение значения.
Фи.
Я буду брать переменную в квадратные скобки.
И приписывать пи.
Это у меня будет общее обозначение значения.
Ферма и формулы данной модели.
На данной оценке.
Чтобы получить эти значения.
Мне потребуется.
Оценка перемен.
То есть если задана модель.
И задана оценка перемены.
Формуле можно придать значение истинной или ложной.
Более того.
Я сразу скажу.
Всем термам.
Будут придаваться качества значений.
При заданной оценке.
Элементы модели.
А начиная с автоматной формы.
Уже будет истинная ложь.
Теперь надо эти правила оценки зафиксировать.
У нас есть оценка.
Придекатных символов которые входят в формулу.
Функциональных символов.
Может быть с каким-то запасом формул.
Все которые входят в формулу.
Должны в этом списке быть.
Мы должны знать какие предекаты соответствуют.
И мы знаем оценку.
Каждый перемен.
Х равно 2.
Формула.
Х равняется у плюс 2.
Она истинная или ложная.
В зависимости от значения х и у.
При значении х ноль.
Ноль она ложная.
То есть смысл такой очень простой.
Но давайте смотреть.
Прежде всего мне нужно написать.
А я наверное буду...
Вот у меня определение формулы.
Я прям так по нему буду длинаться.
И теперь смотрите.
Вот это уже определение.
Как определить теперь значение терма произвольно.
Определяется тоже ликурсивно.
Смотрите.
А у нас мы знаем.
Как у модели определяется функциональный символ.
Он отвечает какой-то конкретной функции.
И мы уже знаем.
Мы определяем отличных термах.
В общем мы знаем.
Чему равны значения термас.
Которые входят в эту модель.
Ну в самом простом случае переменных.
Или более сложных термах.
И поэтому мы от них можем...
Все термы принимают значение множество.
Поэтому корректно определим значение функции.
Вот это вот и есть значение соответствующего терма.
Все совершенно естественно.
Может быть громоздко.
Но идея совершенно понятна.
Как определить значение терма.
Определите значение функционального символа.
В этой модели.
Определите значение все подходящего.
В этот терм под терм.
После этого примените функцию полученного значения.
То же самое с этамарными формами.
То же самое с этамарными формами.
Чтобы определить значение этамарных форм.
Я беру предикат.
Который отвечает этому предикатному символу в модели.
И применяю его к значению терм.
Это истинная или ложь.
Потому что предикат принимает значение.
Истинная или ложь.
Я напомню.
Я считаю, что предикат это такое элементарное высказывание.
Данный набор элементов.
И сносителя модели.
И сносителя модели.
Осталось теперь понять вот здесь.
Здесь с этамарными формами мы уже разобрались.
С пропозициональными связками все очевидно.
Я даже не буду это выписывать.
Понятно.
У нас формулы.
Из которых составлена более сложная формула.
Уже мы присваиваем значение.
Разбираем по дереву.
Ну и присваиваем дальше соответственно со связкой.
То есть если импликация.
Присваиваем импликацию.
Если отрицание.
Присваиваем отрицание.
Салонтеры не чуть сложнее.
Но это соответствует тому определению салонтеров.
Салонтеров которые давал.
Давайте я напишу определение.
Значение формулы.
Вот это вот.
Истина.
Истина я буду единицы обозначать.
Для краткости.
Если.
Значение формулы.
В.
Истина.
Вот тут надо сказать где.
А всех оценок перемен.
В.
В.
В.
В.
В.
В.
В.
В.
В.
В.
В.
В.
То есть мы берем все возможные оценки.
Тут уже определение такое.
Ну а иначе нет.
Чтобы определить значение формулы.
С салонтером всеобщенности.
Мы на данные оценки перемен.
Мы используем.
Значение области действия салонтера.
На разных оценках перемен.
На каких?
А именно на тех которые все переменные.
Понимают те же самые значения что наши оценки.
За исключением.
Которые уже можно прислать.
Мы смотрим на все такие.
Нам нужно.
Чтобы они все.
Переменялися.
То есть аналогично.
Получается громоздко.
И это делает задачу.
Почисление оценки.
Формулы не совсем.
Совершенно аналогично.
Вот так.
Тут уже достаточно одной оценки.
Я напишу вот так.
Чтобы не повторять.
Для какой-то одной оценки.
Из 3, которая отвечает только.
Формула в истину.
Таким образом.
Получается довольно сложная вещь.
Когда я оцениваю формулу.
До элементарных формул.
Меня интересует при оценке формулы.
Только значение переменных.
Которые у нас.
Но когда я начинаю оценивать формулу с плантером.
Для оценки формулы.
Я должен взять под формулу.
И оценивать ее.
На разных оценках перемен.
То есть та переменная.
Я должен пробежать все возможные ее значения.
И вот если все они дают одну.
Тоже, то эта планта все очень слегка.
Единицу, извините.
А соответственно.
Планта совершенно естественная.
Если хотя бы одно значение х.
Значение костальных переменных.
Совпадающее с.
Нашей оценкой переменных.
Дает единицу.
Вот так оцениваются формулы.
То есть в результате мы можем.
Для каждой формулы.
Написать.
Ее значение.
При заданной оценке переменных.
Ну дальше.
Чтобы с нашим неформальным обсуждением.
Свести концы с концами.
Я должен сразу сделать некоторые.
Замечательно.
Вот смотрите.
Формально.
А мне нужна оценка.
Даже не всех.
Символов переменных.
А тех, которые входят в форму.
Но.
Значение формулы.
Даже и одних не всех.
Вот первый важный шаг.
Понять, что формулы могут быть.
Переменные.
От которых.
Не зависит.
Значение формулы.
Что это за переменная?
Давайте посмотрим.
Это очень важно.
Вот у нас.
Переменная х может формулу.
Какому угоду.
И я говорю.
Это связано.
А если переменная входит в кванторный блок.
Или в область действия квантора.
По этой перемене.
То есть как здесь.
То есть в область действия квантора.
Какой-то подслома нашей формулы.
И вот если там встречается символ.
Тоже символ переменных.
Который встречается в кванторном блоке.
Такое вхождение мы называем слева.
Остальные вхождения свободны.
И наконец параметр.
Форм.
Переменная.
У которой есть свободные вхождения.
Ну вот я сразу напишу.
Какой простой пример.
Вот такая формула.
Изюмца какой-то.
Атомарной формулы.
И формула для любого х.
Б от х.
Переменная х уходит трижды.
Вот эти вхождения связаны.
А это свободные.
Их является параметром.
То есть нас интересует.
Наличие свободных вхождений.
Связанных при этом тоже могут быть.
Это нам никак не мешает.
И вот.
И вот лева простейшая.
Которую я хочу доказать.
Значение формулы.
Зависит.
Только.
От значений.
И.
Параметр.
То есть если какая-то переменная.
Имеет только связанные вхождения.
А значение этой переменной.
В оценке переменной.
Значение формулы точно не зависит.
Поэтому если мы смотрим.
На какую-то форму.
И хотим понять какой предикат.
Она выражает в модели.
Мы должны найти все параметры формы.
Вот скажем в этом примере.
Тут одна очень переменная.
Вот эта параметра.
Эта формула в любой модели.
Соответствующей сигнатуры.
С двумя предикатами.
Выражает.
Тоже какой-то унарный предикат.
Тоже другой.
Зависит от понимания А и В.
Но это уже не тот предикат.
А и В.
Но существенно что он унарный.
Могло бы быть так.
Что у нас несколько.
Вхождений разных переменных.
И предикатов там допустим один или два.
Переменных которые имеют связанные.
Вхождений очень много.
А мы все равно считаем что.
Формула задает.
Предикат вот только от параметра.
При этом на самом деле.
Формула может задавать консомнатный предикат.
Может случиться так.
Что эта формула в какой-то модели.
Но все равно мы считаем.
То есть для определенности мы считаем.
Что формула выражает.
Как говорят.
Предикат.
Арности.
Количество параметра.
Как доказывается это ленту?
Доказательства используют правила оценки.
Формулы.
И индукцию по разбору.
Значит смотрите.
В базе индукции будут атомарные.
В атомарной формуле мантера вообще нет.
Поэтому там все переменные входят свободно.
Количество параметров.
Просто равняется количеству переменных.
Ясно что ни от каких других переменных.
Значение этой формулы не зависит.
Посмотрите.
Атомарная формула. Ясно что.
Какие переменные входят в эти термы.
А в тех переменных значение этой формулы зависит.
Если z не входит.
То значение переменной z.
Это атомарная формула.
Зависит не было.
Это база.
Теперь шаг индукции.
Ну а.
Нужно рассмотреть разные случаи.
Болевые связки все рассматриваются одинаково.
Давайте о дезюнции говорить.
И о прибеленности.
Вот смотрите.
Если платформулы.
Зависят только от переменных.
Которые имеют свободные входения в эти платформы.
То эти же переменные.
Будут иметь свободные входения в дезюнцию.
Потому что.
На дереве размора очень легко понять.
Как определяется.
Где свободные связки.
Если у меня есть плантор по x.
Я смотрю.
Путь в лист.
Все дерево.
Которое идет ниже этого плантора.
Все входения x.
У нас есть листья.
Вот те листья.
Эти переменные связаны.
Все остальные входения x свободны.
Чтобы понять.
Надея свободна ли входение x.
Мы должны построить путь к корню.
И если на этом пути есть плантор.
По соответствующей переменной.
Но ухождение связано.
А если нет.
То оно свободно.
Соответственно.
Здесь ничего сложного нет.
Но может так случиться.
Что переменная.
И свободное хождение и сюда и сюда.
Но она будет параметром.
На одной и другой подформулы.
Но она будет параметром без юга.
Тут никаких трудностей особо нет.
Осторожно смотреть.
Случай навешивания квантора.
Здесь тоже все очень просто.
Смотрите.
Мы знаем, что мы навешиваем квантор.
На какую-то форму.
Которая зависит.
Мы применяем.
Значение этой формулы зависит только от значения параметра.
Уже от этой маленькой.
А как меняется количество параметров.
Когда я навешиваю квантор.
Из параметров может пропасть переменная х.
Остальные параметры как были так и остались.
Но значение переменной х.
Посмотрите на определение.
Значение формулы с навешиванием квантора не зависит.
Потому что мы берем все возможные.
Мы берем все возможные.
Оценки когда х продает все возможные значения.
Поэтому вот конкретно.
Если я оцениваю формулу с квантором.
А х при х равном единице.
Ее значение все равно будет получаться.
Я должен будет подставлять все возможные значения х.
И никакой зависимости от х нет.
Вот в сущности все.
Очень несложно.
По крайней мере.
Это скорее совсем простые наблюдения.
Вот.
Нашим довольно громоздким.
Определение формул и значение формул.
И вот теперь уже у нас возникает.
Корректно сформулированная задача.
У нас есть формулы первого порядка.
Они выражают какие-то предикаты.
Нужно зафиксировать модель.
Они будут выражать предикаты.
Ну например.
Зафиксируем алгебру таск.
Мы осматриваем все формулы первого порядка.
Каждая формула будет выражать какой-то предикат.
У нас есть средние предикаты.
В теории нет такого предиката.
Я ее закажу.
Но прежде чем доказывать.
Мне нужно сделать небольшое отступление.
Без этого как-то совсем не получится.
Про то, о чем я в основном буду говорить позже.
Значит смотрите.
Что у нас есть?
Ну.
Во-первых.
Если формула замкнутая.
То есть у нее вообще нет параметров.
Оно зависит только от модели.
Значит замкнутая формула.
У которой параметров нет.
И замкнутые формулы.
Поэтому они выражают.
Это как-то набор теоремы модели.
То есть те замкнутые формулы, которые у моделисти
выражают набор теоремы модели.
Теперь.
Бывают такие формулы.
Ну вот.
Мне все-таки доска нужна.
Давайте как-нибудь вот эту пока смотру.
Может быть одной доской ограничусь.
Посмотрим.
Мне хочется, чтобы это громоздкое определение
вы видели.
Оно для вас новое.
Я мог на него воткнуть пальцем.
Вот и конкретно выводится.
Выводит.
Так называемые общезначимые.
Это формулы, которые истинны.
В любой модели, на любой оценке перемен.
Вот.
То есть вот бывают такие формулы
первого порядка, что
вы написали какую-то формулу.
И что бы вы ни делали,
какую бы модель вы написали,
как бы вы ни оценили переменной, значение формулы сработисти.
И это она вот.
Такое вот обобщение
тавтологии в область
логики пирога.
И нас общезначимые формулы будут
сильно интенсовать дальше.
Но уже сейчас
мне хочется про них что-то сказать. Почему?
Потому что общезначимые формулы,
как и тавтологии, это способ выражать законы логики.
Мы будем использовать
переобразование формул.
И нам хотелось бы, чтобы эти переобразования
были корректны.
И поэтому мне нужны общезначимые формулы.
На самом деле мне нужно больше.
Мне нужны так называемые равносимые формулы.
Ну, эти формулы
принимают одинаковые значения.
В любой модели,
на любой оценке перемен.
Другими словами, формула A
равносильна B
общезначимая.
Ну, а это у меня
в списке моих связок
этого не было.
Это как обычно просто конъюнция
двух комплектаций.
И знания
булевой логики нам достаточно,
чтобы понять, что действительно
тогда есть такая формула общезначимая,
то это означает, что A
и B должны... Они могут быть
ложны каких-то оценок перемен,
каких-то моделях, но одно время
A и B должны быть ложны.
B должен быть логиком.
И наоборот.
А вот
равносильные формулы нам будут нужны,
потому что хочется иметь возможность
как-то формулы преобразовывать.
Ну, давайте какие-нибудь
примеры рассмотрим. То есть у нас
есть время, немножко времени.
Я хочу рассмотреть пример.
Давайте
какие-нибудь здесь
совсем простые примеры напишу.
Тут попробуем потом
менее очевидно
примеры написать.
Ну, во-первых, как я уже говорил...
У нас есть
тоже у нас есть какая-то
тавтология.
То есть
формула
от буревых переменных,
которая равна единице
на любом наборе
значений буревых переменных.
Я могу в эту формулу вместо переменных
поставить формулы первого порядка.
Любые.
И это получится
общезначимое.
Ну, действительно, смотрите.
Я как-то, чтобы вычислить
значения этой формулы,
вспомним правила оценки.
Я двигаюсь сверху вниз, у меня
в начале какие-то формулы,
а1, а2, аn вычисляются, потом они
подставляются, с ними выполняются
какие-то буревые прансы,
и что-то вычисляется.
Ну, раз уж я вычислил значения формулы а1,
а дальше идут только связки,
то, конечно, вычисление вверх
оно будет
таким же, как в случае
вычисления тавтологии, призаданным
буревым значением вот этих вот
формул а1, а2. Раз это
тавтология, то, конечно, получается...
Может быть...
Так звучит слишком австрактно, давайте
такую совсем простую тавтологию напишем.
Если формулу первого порядка не подставил,
это будет, конечно, истина.
Но как я буду вычислять по правилам
отсылки значения такой формулы?
Я должен вычислить значения формулы а,
а потом вычислить импликацию
из вычисленного значения а,
импликация, то же самое вычисленное
значение а1. Получится всегда
единица, неважно, чему равнозначение формулы.
Второй важный пример уже не столь очевидный.
Но он должен быть вам
известен.
Потому что обычно
на анализе
это очень любят.
Ну, я пишу вообще начало
и можно сказать, что пара формул
равносильна. Смотрите, если у меня есть формула
на отрицании формулы
которая получается, навеш� ا
кланатор сообществ на какую-то формулу
а, она равносильна какой формуле.
Кланатор существования, навешанный на отрицание
формулы а.
И наоборот, если я навешиваю
отрицание
на клантор существования,
то тогда это равносильно тому, что я беру
в начале кланатор сообществ по той же самой переменной
и навешиваю на формулу
где происходит отрицание.
То есть, как обычно говорят, это правила перестановки отрицания и квантера.
То есть, если вы переставляете местами отрицание и квантер, то у вас квантер должен измениться.
Все общество будет в сочетании, сочетание станет все общество.
И это совершенно очевидно из вот этих определений.
Смотрите, когда ложна формула отрицания квантера все общество?
Ну, вот смотрим.
Тогда, когда существует такое значение переменной X, что на оценки с этим значением
и все остальные переменные ценивают так-то, формула A обращается в ложку.
То есть, само отрицание A обращается в ложку.
Но смотрим на вторую строчку.
Это означает, что квантер существования, в смысле формула с квантером существования действует.
Ну и в обратную сторону тоже самое.
Если у вас нашлось значение X, на котором отрицание формулы A истинно,
это значит, что при такой оценке переменных A ложно,
ну и тогда у вас при оценке формулы с квантером в сочности будет вот эта вот строчка.
То же самое со второй парой.
Тут ничего в сущности можно считать, что я оба совмещаю.
Это уже менее тривиальный пример.
Мы дальше будем разбираться, что делать,
когда мы хотим переставлять квантеры и пропрессиональные связки.
Там будет сложно, сейчас именно то, что мы сказали.
Что за оставшееся время я хотел бы еще объяснить, это...
Некоторые простые и не очень простые вещи, связанные с переменами.
Вот как вы думаете, A это предикатный символ.
Формула A от X и формула A от Y, они равносильны или нет?
Ну, казалось бы, какая разница, как мы называем переменными, да?
Тем не менее, для нас разница есть.
Вот смотрите, я уже зафиксировал все определения.
Теперь, когда я говорю, равносильны ли эти две формулы,
это означает, что вот такая формула должна быть вообще значима.
Но очень легко построить модель, в которой эта формула ложится.
Смотрите, возьмем модель на двух элементах, 0 и 1.
А предикат A от X, это просто-напросто предикат X равно 0 и 0.
Тогда смотрите, что здесь написано.
Поскольку всего два возможных значения, можно писать прямо табличку.
Значение X, значение Y.
Если значения X и Y совпадают, то эта формула, конечно, истинна.
Потому что и это, и это равно 0.
Или и это, и это равно 1.
Но если X равен 0, а Y равен 1, то она, смотрите, A от Y равно 1,
а A от Y равно 0.
Поэтому у нас на такой оценке переменных эта формула ложится.
То есть, имена переменных играют в значение.
Мы не можем просто так взять и сказать, что вот эту формулу мы заменяем.
Почему это важно?
По сути, конечно, вы понимаете, что когда мы записываем какие-то математические утверждения,
мы можем переменные разными буквами обозначать.
Суть от этого обычно не меняется.
В чем тут дело?
Дело тут в том, что когда мы рассуждаем о формулах, мы хотим использовать некоторые свойства.
И одно из очень важных свойств вызывается лемма замене.
Вот пусть у нас есть две равносильные формулы A и B.
Есть формула phi и формула phi' которая получается там.
Я здесь использую такое обозначение phi, вертикальная черта и дальше некоторая запись.
Вот эта запись понимается так.
Под формула A заменена на B.
То есть вот прямо в дереве формула, где-то он есть, я беру, вырезаю прямо то дерево, которое отвечает A,
и вставляю вместо него дерево, которое отвечает B.
Так вот, если A и B общезначены, то тогда phi' и phi тоже общезначены.
Ну, phi' и phi равносильны, соответственно, вот такая вот формула.
Это очень важное.
Лемма, которую постоянно мы будем использовать, то есть если у нас есть какая-то очень сложная формула,
и мы какую-то ее часть знаем, что она равносильна какой-то другой формуле,
мы рассуждая значение формулы, нам все равно мы можем заменить, получим формулу,
на той же значении те же самые.
Мы этим будем пользоваться дальше стоя.
И поэтому было бы плохо, если бы мы разрешили считать такие формулы равносильно.
То есть, конечно, когда у вас формулы входят X и Y, если вы A от X замените на A от Y,
у вас все может перепутаться, будет плохо.
Мы хотим без ограничений пользоваться леммой,
именно поэтому нам нужно различать значение переменной.
Ну, хорошо скажете вы, это пример, когда переменные входят свободно.
Потому что, по крайней мере, когда они входят связанно, тут тоже.
Точно не важно, какой буквой я обозначаю связанное в храждении.
Это же напоминает индексы суммира.
Вот представьте, что вы пишете там сумма по Y, ну какого-то уже Y в квадрате.
Если вы напишете сумма по Y в квадрате, то значение суммы от этого не изменится.
И это, в общем-то, естественно, потому что мы берем все возможные значения,
в одном случае и в другом случае Y,
и результат не должен зависеть от того, какой буквой мы обозначили все эти возможные значения.
Так вот, здесь тоже есть сложность.
Мы уже зафиксировали все определения, и теперь мы к ним привязываем.
Ну, можете, конечно, сказать, что я по-дуатски зафиксировал определение,
что у меня возникают какие-то такие синтаксические проблемы непонятные.
Но здесь плохая.
Хорошего синтакса люди придумать не смогли.
Какой-то вот, вот, например, такой, можно придумать.
Но у любого синтакса первого порядка есть те или иные проблемы.
Но все-таки мы довольно сложные лечи хотим выражать.
И получается так, что вот совсем младко этот формализм не работает.
Возникают какие-то трудности, нужно внимательно следить за тем, что происходит.
Вот, смотрите, здесь со связкой перемена.
Вот есть такая штука, в которой Y входит свободно, а X входит связкой.
Казалось бы, кто мне мешает их заменить на любую другую.
Давайте попробуем заменить их с на букву E.
Получим формулу.
И я думаю, вам понятно, что эти формулы неравно сильны.
Но эта формула говорит, что предикат А, если аргументы одинаковые, он всегда истинный.
Всегда истинный.
А эта формула говорит, что при заданном значении второго аргумента и любом значении X предикат истинный.
Совершенно разные.
У нас возникают проблемы.
Связанные вхождения мы тоже просто так менять не можем.
Но здесь хочется побороться, потому что интуиция-то у нас правильная.
А в связных переменах не должно ничего зависеть.
В чем тут проблема?
Проблема синтоксическая.
Когда мы делаем такую подстановку, мы допускаем лишние связи.
У нас было свободное вхождение.
Если я сюда подставлю, то возникает коллизия.
Это вхождение становится связанным.
Было свободным, стало связанным.
Эта коллизия нам мешает.
И действительно, если убрать такие коллизии, то получается корректное вхождение.
Я сейчас его сформулирую.
Вот пусть есть формула A.
И переменная Y не входит в A.
Я не самый большой обществе это формулирую, но нам этого хватит.
Y не входит в A.
Это то, что называется замена на свежую перемену.
То есть мы берем какую-то новую переменную, которую мы никак не используем.
И вот тогда мы можем утверждать следующее.
Вот здесь мы заменяем свободное вхождение X.
То есть мы берем формулу A.
Все свободные вхождения X заменяем на Y.
И в мантере заменяем X на Y.
И получаем равносильную форму.
Вот это вот корректное правило.
Частный случай, но это вот такая замена корректная.
Она дает равносильную форму.
На самом деле достаточно скажем, чтобы Y не входило свободно в A.
Даже более слабо.
Но давайте нам вот такого свойства будет хватать.
Я не хочу в полной обществе формулировать, чтобы упростить доказательство.
Ну почему так?
Давайте смотреть.
Вот пусть у нас есть оценка перемен.
И мы теперь хотим построить новую оценку X.
Так что оценка X совпадает с оценкой Y.
А оценка Y совпадает с оценкой X.
Остальные переменные одинаковые.
То есть я делаю такую странную вещь.
Мне нужно доказывать равносильность.
Я зафиксировал модель, я доказываю равносильность формы.
Пусть модель уже зафиксировал.
Теперь мне надо для разных оценок переменных доказывать, что результаты одни и те же.
Я беру и рассмотрю не одно оценку, а две.
Вот какая-то одна х и полученная из нее х-штрих, пересталовка и значение х.
Что важно, что вот эта формула не зависит...
Значение этой формулы не зависит от х.
Потому что х вообще в этой формуле.
Означение этой формулы не зависит от х.
Потому что все свободные окружения х я заменил на и.
У меня не осталось свободных окружений х.
Поэтому получается что?
Что оценка формулы А на х совпадает с оценкой этой формулы.
Давайте я как-нибудь обозначу вот эту форму.
Обозначу а-штрих.
Чтобы не переписывать в этом образ.
На х-штрих.
Потому что...
Смотрите, когда вот так я переставил, у меня же что получилось?
Я вычисляю а-штрих так же, как и а.
Но только теперь у меня там свободно входят перемены на и.
Которая не входила раньше свободно.
То есть это единственное свободное вхождение.
И я подставляю вместо ирика те же самые значения.
Чтобы я поставил вместо х а в формулу а.
Поэтому вычисление даст тот же самый результат.
Ну и теперь уже понятно.
Смотрите, когда я навешиваю квантор всеобщности.
Я беру оценки, которые отличаются...
Вот когда я навешиваю на а квантор всеобщности.
Я беру оценки, которые отличаются значением переменной х.
А когда оцениваю вот этот квантор.
Я беру оценки, которые отличаются значением переменной и.
Но вот при таком соответствии видно, что все, что проведает.
Все возможные оценки для навешивания квантора на формулу а.
Им отвечают какие-то оценки при навешивании ирика на а.
Ну вот при такой оценке, которую я написал.
При переставривании х и наоборот.
А наши правила оценки говорят, что все зависит.
Все зависит только от всего множества оценок.
То есть нам не важно какое конкретное значение принимает х.
Чтобы эта формула была истинной.
Нам нужно, чтобы она была истинной при любых значениях х.
Но если это так, тогда эта формула будет истинна при любых значениях и.
Потому что она выполняется вот такое равенство.
И вот отсюда мы получаем, какие у нас возможные значения для х.
И какие же будут возможные значения для и.
При оценке х.
Ну все. У меня и время вышло.
И на это время я хотел сегодня закончить.
