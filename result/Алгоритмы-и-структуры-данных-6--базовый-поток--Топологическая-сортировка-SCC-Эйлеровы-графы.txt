Добрый день.
У вас запутались наушники или у вас запуталась цепочка?
Что нужно сделать?
Нужно ее распутать.
Необходимо упорядочить звенья так, чтобы все связи шли только в одну сторону.
На этом графе можно положить звено 2, 3, 0, 1, 5, 6, 4.
Если таким образом упорядочить вершину вашего графа, то что у нас получится?
2, 3, 2, 0, 3, 1, 3, 0, 3, 4.
3, 1, 3, 0, 3, 4.
Дальше из нуля ничего.
1, только 5.
И дальше 6, 4.
Понятно.
Если у вас наушники беспроводные или цепочка, то представьте себе такую ситуацию.
У вас есть некоторый набор задач, и все задачи условно разделены по телам.
У вас есть задача на то, чтобы применить DFS, задача на то, чтобы применить BFS,
есть задача на то, чтобы применить hash таблицу.
А есть более сложные задачи.
Есть задачи, которые требуют знания и BFS, и DFS одновременно.
Есть задачи, которые требуют знания и hash таблицы DFS.
Есть, грубо говоря, задачи, которые можно решить, только зная про hash таблицы,
и то, как решается вот эта задача.
Вопрос. В каком порядке решать все эти задачи и задания?
Ну, естественно, по возрастанию сложности.
То есть если вы знаете, как решать задачу DFS, и знаете, как решать задачу про BFS,
то, скорее всего, вы знаете обе идеи, поэтому вы можете приступать к решению более сложной задачи.
И так далее.
И мы можем упорядочить все эти вершины.
Давайте снова 0, 1, 2, 3, 4, 5.
Вот таким образом.
То есть есть задача 0, из которой следует задача 3, 4.
Есть задача 1, из которой следует задача 4.
Есть задача 2, из которой следует задача 3, 5.
Ну и есть задача 5, которая следует из задачи 3.
Снова упорядочили ровно таким образом, что все ребра идут слева направо.
Или сейчас в последнее время очень стали популярны так называемые графы вычислений.
Я не знаю, вы на экран слышали про нейросети.
Вот нейросети такие сложные функции, которые состоят из большого количества блоков.
То есть из большого количества таких вычислительных модулей.
Они, собственно, как раз таки устроены так, что, допустим, у вас есть входы.
Дальше эти входы могут подаваться в различные более сложные функции.
Дальше эти функции могут комбинироваться в более сложные конструкции и так далее.
И, соответственно, возникает вопрос, а в каком порядке это все безобразие вычислять?
То же самое. Необходимо просто упорядочить так, чтобы когда вы выполняете определенный блок,
все предыдущие блоки уже были выполнены. То есть мы этого хотим.
Но для этого, соответственно, нужно упорядочить граф таким образом, чтобы все ребра в нем шли слева направо.
И вот эта задача упорядочивания графа называется топологической сортировкой.
Так, давайте более формально.
Пусть задан частичный порядок на вершинах графа.
Ну, какой порядок? Порядок такой, что если у вас есть ребро из A в B, то из этого следует, что у вас A меньше, чем B.
Ну, ровно как здесь. То есть если у нас есть ребро 2 и 3, то мы предполагаем, что 2 меньше 3.
Поэтому в упорядочивании нам хочется, чтобы 2 стояло раньше, чем 3.
Ну и задача стоит в том, чтобы упорядочить в соответствии с этим порядком.
То есть в некотором смысле нам дано некоторое частично упорядоченное множество, и нам необходимо его отсортировать.
Проблема заключается в том, что не между всеми парами вершин вы знаете больше оно или меньше.
Ну и понятно, что она никак не связана вообще с основным графом, то есть есть две слабо связанные компоненты.
И вот вас спрашивают, сравните число единицу и восьмерку. Мы их сравнить не можем, потому что они никак не связаны никаким порядком.
Задача усложняется этим, что не между всеми парами вершин есть на самом деле какая-то связь.
Еще более сложная ситуация состоит в том, что у вас граф в некотором смысле разреженный.
Он содержит не всю информацию. Вот пример. Вот у вас есть такая цепочка A, B, C, D.
При этом вы понимаете, что в этом смысле A меньше B, B меньше чем C, C меньше чем D.
Ну и так как мы говорим, что это частичный порядок, то в нем выполняется свойство транзитивности.
То есть естественно C больше чем A и D больше чем A. Но при этом таких связей в нашем графе нет.
То есть если мы обращаемся к паре A и C и нам говорят, что я не знаю какая там связь.
То есть A меньше C или C меньше чем A, я не знаю этого. Это может означать две вещи.
Либо они никак не связаны как здесь, либо просто мы пропустили вот эту транзитивную связь, хотя на самом деле порядок на них есть.
Сложность понятна. Вот и поэтому хотелось бы придумать какой-то алгоритм, который бы работал вот в этих условиях.
То есть с одной стороны мы знаем, что на вершинах каким-то образом задан частичный порядок,
а с другой стороны мы знаем, что граф наш не совсем полный, но в частности в нем пропущены транзитивные связи.
То есть связи вот такого типа пропущены. Понятна постановка, да?
Так, окей. Ну и перед тем, как мы придем к обсуждению, как это все можно сделать, такой вопрос.
Как вы думаете, любой ли граф можно топологически отсортировать? Какие графы нельзя топологически отсортировать?
Да, отлично. Замечание. Задача имеет смысл только для ориентированных ациклических графов.
Ну или сокращенно так. Directed acyclic graph. Вот, то есть если у вас в графе есть цикл,
давайте вот тут его придумаем какой-нибудь вот такой, то понятное дело, что упорядочить не семерку, не восьмерку друг от друга никак нельзя.
То есть неверно, что семерка меньше восьмерки, неверно, что восьмерка меньше семерки.
То есть как бы вы не упорядочили, вы получите противоречие. Окей? Вот.
Так, ну давайте еще тут напишем, что в терминах, ну тут мы задали топологическую сортировку как упорядочивание
некоторого частично упорядоченного множества. Давайте скажем, что в терминах графов, ну так что для понимания,
в терминах графа, топологическая сортировка означает упорядочение вершин в массиве так,
чтобы все ребра шли слева направо. Ну понятно, да? Шли слева направо.
Ну и давайте, я думаю, сразу пойдем к алгоритму. В общем, алгоритм, на самом деле,
от топологической сортировки вообще ничем не отличается от обхода DFS. Вот этим образом оказывается,
что одного запуска DFS на графе вполне достаточно, чтобы отсортировать все вершины.
Вот в том виде, в котором мы хотим. Давайте сразу алгоритм. Алгоритм – это арена.
Давайте сначала обсудим идею. Вот, например, здесь. Давайте возьмем произвольную вершину и запустим от нее DFS.
Произвольную, допустим, двойку. Запустил от нее DFS. DFS каким-то образом гуляет, гуляет,
и в какой-то момент DFS будет некуда идти. Такое очевидно произойдет. В какой вершине это произойдет впервые?
На этом графе можно, в общем, в случае.
Что еще раз? Да, впервые вы остановитесь в той вершине, у которой исходящая степень 0.
То есть вы остановились в какой-то вершине. Если вы в ней остановились, то что это означает?
То есть вот вы запустили DFS. Вот у вас серая вершина, вот эта серая вершина, здесь вы остановились.
Почему вы в ней остановились? Ну вы могли остановиться по двум причинам.
Либо из нее идти некуда. Ну а что значит идти некуда? Ну просто у нее нет никаких ребер, исходящих из нее.
Тогда мы ее спокойно, естественно, можем положить в конец списка.
Потому что она ничему не будет мешать. У нее нет никаких ребер, поэтому никаких ребер назад идти не будет.
Или у нее есть ребра, но все ребра, которые ведут в какие-то вершины, они все заняты.
Но по какой причине они в данном случае могут быть заняты? Они серые, да?
А мы могли встретить серые вершины? Нет, серые вершины мы встретить не могли. Почему?
Потому что у нас граф ациклический. Поэтому мы спокойно можем пятерку положить в конец очереди.
Вот, мы ее положили. Ну что мы делаем дальше? Мы положили пятерку и пометили ее черным цветом.
Дальше аналогично. Продолжаем поиск. В какой-то момент остановились в вершине.
Снова что это означает? Это означает, что либо у нас нет никаких вообще исходящих ребер,
тогда снова можно спокойно ее положить в конец очереди. Не в очереди, а в начало списка.
Либо из нее есть исходящие ребра, которые ведут в уже посещенные вершины.
А какие это могут быть вершины? Либо серые, ну тогда у нас есть цикл, чего не может быть.
Либо черные. Но если вершина черная, то она уже в списке.
Поэтому если я положу сюда четверку, то у меня ребра будут идти только вправо.
Идея понятна? То есть черные вершины, они уже в списке, поэтому у меня ребра будут идти только в них.
А остальные вершины я по очереди как раз положу в мою очередь.
Идея очень простая. Давайте запустим топ-сорт на графе G.
Ну что мы делаем? Во-первых, говорим, что цвета как обычно всех вершин изначально
белые. Ну и заводим массив ответов. Изначально пустой.
Вот этот массив мы потихоньку будем добавлять в вершины, формируя упорядоченное
согласно топологической сортировке. Ну и для каждой вершины из множества вершин,
если она белая, запускаем ДФС топ-сорта G и V.
Ну а как выглядит ДФС топ-сорта G и V? Давайте я напишу так, что ДФС топ-сорт от G и V
Это то же самое, что и обычный ДФС. Нет, давайте нормально напишу там.
Заодно исполним.
Так, изначально что мы делаем? Мы говорим, что цвет вершины V серый.
Дальше, для каждой вершины U среди соседей вершины V, что мы делаем?
Проверяем в первую очередь, если мой сосед серый, то что в этом случае происходит?
Ну все, панику поднимаем. Мы встретили цикл.
Это значит, что топологически сортировать мы наш граф не можем.
Помните, в прошлый раз обсуждали критерии цикличности. Если мы встретили серую вершину,
то это значит, что в нашем графе есть цикл.
А если в нашем графе есть цикл, то топологически сортировать невозможно.
Ну просто включим о помощи.
Далее, если вершина белая на самом деле, то в этом случае запускаем DFS TopSort JU.
Ну и все, после того как цикл закончился, мы помечаем нашу вершину черным цветом
и добавляем эту вершину V.
И добавляем вершину V в начало списка.
Ну, давайте считать, что они как бы... вот эти colors и answer это вот отсюда.
Я думаю понятно.
Давайте push-front от V.
Ну и здесь делаем просто return answer.
Здесь можно поступить немного по-другому, то есть делать push-back,
а потом вернуть перевернутый массив.
Ну давайте считать, что у меня массив позволяет быстро осуществлять вставку в начало.
Вот такой алгоритм. То есть просто запускаем DFS и добавляем только одну строчку.
После того как закончили обрабатывать вершину, добавляем ее в начало массива.
Результирующий массив возвращаем.
Ну давайте посмотрим, как он работает.
Вот давайте вот этого графа.
От него запустим DFS. Ну от какой вершины?
Ну, например, давайте от вершины 3.
Мы попали в вершину 3, пометили ее серым цветом.
Дальше попали, допустим, в вершину 4.
И понимаем, что из четверки идти некуда.
Значит в этот момент мы завершаем над ней работу и кладем в начало из списка.
Далее откатываемся в тройку и из тройку идем, допустим, в единицу.
Из единицы идем в пятерку. Из пятерки идем в шестерку.
Из шестерки идти некуда.
Пометили ее черным цветом, кладем в конец списка.
Дальше откатываемся в пятерку, из пятерки идти некуда, кладем в начало.
Из единицы снова идти некуда, кладем единицу.
Из тройки можно пойти в ноль. Из нуля никуда.
Пишем ноль.
Дальше возвращаемся в тройку, из тройки теперь снова идти некуда.
Завершаем, кладем в тройку.
Ну и в конце запускаемся от двойки, из двойки идти некуда.
Завершаем работу.
Все.
Ну и что у нас получилось?
2, 3, 2, 0, 3, 0, 3, 1, 3, 4.
3, 0, 3, 1, 3, 4.
А, ну ровно то, что и мы и делали, да?
Окей? Все, никакого мало.
Так, теперь давайте обсудим.
Что еще раз?
Так смотрите, у нас уже...
Да, мы запустили от тройки.
Спасибо за вопрос.
Мы запустились от тройки, и действительно из тройки до двойки мы не могли добраться.
Да?
Но у нас же весь алгоритм состоит в чем?
Мы рассматриваем все вершины,
и если вершину мы до этого не посещали,
мы вызываем от нее DFS TopSort.
То есть изначально мы запустились от тройки,
тройка породила все возможные вот эти вот...
свои подковерные игры.
В общем, мы запустила все DFS от тех вершин, до которых она может дотянуться.
Затем мы вышли из вот этого DFS TopSort
и перешли на следующую итерацию цикла.
И с помощью вот этого EFA нашли первую вершину,
точнее нашли, да, нашли очередную вершину,
которую мы еще не посетили в рамках предыдущего прохода.
Понятно?
То есть мы запускаем DFS TopSort от произвольной вершины.
Если вот этот DFS TopSort посетил не все вершины,
то мы запускаемся заново от какой-либо другой вершины,
которая все еще белая.
Ну и так далее, пока не обойдем все вершины.
Окей?
Ну то есть вот этот вот цикл как раз нужен, чтобы обойти
во-первых, все компоненты слабой связности,
ну а во-вторых, все те вершины, до которых мы раньше не доходили.
Так, ну и теперь, почему это работает не на том графе,
который я нарисовал, а вообще в любом случае.
Теорема.
Альгоритм Тарьяна
либо
корректно
определяет
наличие цикла.
Это первое, что может сделать этот алгоритм.
Либо
корректно
определяет
наличие цикла.
Либо
корректно
строит
топологическую сортировку.
Это два.
Откуда следует первое утверждение?
Он скорее следует
из критерии ацикличности.
А не из ИФА.
Ну то есть вот этот алгоритм
да, вот этот вот алгоритм,
то есть если забыть вообще про этанцию,
он дословно повторяет алгоритм поиска циклов.
Но мы в прошлый раз оказали, что циклы у нас
ищутся корректно.
Поэтому этот первый случай просто следует
из критерии
ацикличности.
Так, теперь два.
Давайте по индукции докажем.
Изначально у нас массив пустой,
в нем все корректно.
Изначально
массив
корректен.
Корректен.
Рассмотрим
добавление
вершины В в массив.
Допустим, в какой-то момент мы добавили очередную
вершину В. То есть у нас есть какой-то
построенный массив.
То есть тут есть какие-то вершины.
И на очередном шаге
добавили вершину В.
Сначала.
Добавили вершины В в массив.
Что было до этого?
Вот что произошло
до добавления вершины В.
До добавления вершины В мы проходили
по всем его соседям.
До этого
мы рассматривали
всех
соседей В.
Что могло произойти?
Во-первых, могла произойти грустная ситуация,
когда соседей у вершины В вообще не было.
Согласно, вот эта итрация
этого цикла ни разу не повторилась.
Точнее, ни разу мы не вошли внутрь этого цикла.
А
соседей
не было.
Не было, в смысле, совсем
никаких. Ни черных, ни белых,
ни серых.
Что из этого следует?
Верно ли, что тогда
я вполне спокойно могу положить вершину В
сюда? Почему?
Потому что у меня нет ребер, которые идут
справа налево.
Раз нет ребер совсем,
раз у него нет соседей, то это значит, что
ребер, которые будут вести справа налево,
нет.
Нет.
Ребер.
Ребер
ведущих
справа
налево.
Ну и
второй случай.
Все соседи уже черные.
Белых соседей быть не может, потому что мы их уже
обошли. Серых соседей не может быть так,
как мы предполагаем, что граф у нас уже
ациклический. Значит, все соседи
черные. Согласны?
Все соседи
черные.
А если все соседи черные,
то что это значит?
Да, они уже вот здесь.
Все соседи уже здесь.
Вот он, вот он.
Все соседи
уже справа.
Ну это просто нам означает, что все ребра
идут для вершины V слева
направо.
Ну все.
Окей?
Ну, наверное.
Как?
Каким образом?
Ну, предположим, что у нас
ну, в общем-то, алгоритм
не коллектно строит логическую сортировку.
То есть, он его
так и построил, но у нас какие-то две вершины
вспоминаются в неверном порядке.
То есть, для них верно, что
та вершина, которая слева,
она, условно, младшая вершина,
которая справа. То есть, вершина справа
ведет следовательно вершину слева.
Такая ситуация, то есть.
Да, ну тогда давайте
заметим, что так
у нас мы добавляли каждую вершину V
ровно в тот момент, когда
у нее не было ребра, которые
исходят в другую вершину.
Значит, вершина
у нас каким-то образом
уже разводит.
Или уже добавлен.
Ну, кажется, что это ровно то же самое, что я тут
показывал. Ну, то есть,
можно так. А тут противоречие с тем,
что U была добавлена
позже, чем вершина V.
Хотя во время вызова V
мы вызывали U. И поэтому она должна была
оказаться раньше. Примерно то же самое здесь
и написано. Если вам так удобнее,
то можно так.
Еще вопросы?
Окей.
Ага.
На этом удивительно,
но с топологической сортировкой пока все.
Простая задача, простое решение.
Теперь давайте
как и заявлялось
на прошлой лекции, будем рассматривать
компоненты сильной связанности.
Ну и сильно про топологическую сортировку
не забывайте, она нам еще сегодня понадобится.
Вот.
Компоненты сильные.
Да.
Отлично, да.
Вот давайте кто-нибудь будет в этой аудитории отвечать
за асимптотику алгоритмов.
Кто-то будет дико любопытный.
Все, вот кто-нибудь.
Выберите себя. Да, отлично.
Ну, асимптотика, на самом деле,
очень очевидная. Ну, то есть мы в прошлый раз
анализировали DFS.
DFS работал, ну, если мы использовали списки смежности,
то за V плюс E.
Соответственно, так как здесь мы ничего, кроме DFS,
по сути, не делаем, то асимптотика
от V плюс E.
Время точно совпадает
со временем работы DFS.
Время работы DFS
от V плюс E.
То есть, по сути, залинейное
от размера графа время
вы создаете топологическую сортировку.
Тут еще, кстати, может возникнуть
вопрос, а можно ли, с помощью grammar,
сортировать, скажем, обычные
числа, ну, то есть выполнять
обычную сортировку. Что это значит?
Это значит, что вы просто-напросто строите полный граф,
то есть, вам дано множество чисел и вы на всем
множестве чисел строите полный граф.
То есть, между каждой парой вершин проводите какой-либо реброн.
Допустим, один меньше двойки,
двойка меньше десятки и так далее.
Но, на самом деле,
тогда это все вырождается, по сути, в сортировку выбора.
если вы посмотрите, то по сути это сортировка выбором. То есть вы ищете самую большую вершину,
вершину с точки зрения порядка наибольшую, кладете ее в начало, потом ищете следующую по величине,
кладете в начало и так далее. И это все вырождается, секунду, в асимптотику o от v квадрат.
Потому что общее число ребер порядка v квадрат.
А если мы проведем ребра из 2 в единичку, то есть e будет v, а не v квадрат,
тогда у нас получится сортировка 2 в единичку.
Да, но тогда, смотрите, в этом случае, нет, у вас другая проблема возникает.
У вас неупорядочный граф, но вот эти вот ребра вам нужно каким-то образом построить.
А для этого вам нужно определить, что 0 это минимальное число, единица это следующее,
то есть вам в любом случае придется выполнить какую-то сортировку.
Поэтому теорию вы не обманете.
Компоненты сильной связности. В прошлый раз мы обсуждали, что такое компоненты сильной связности.
Давайте устно напомню. Компоненты сильной связности в ориентированных графах это такие компоненты,
то есть такой наибольший подграф, в котором из любой вершины можно добраться до любой другой.
Самый простой случай – это треугольник.
Вот это компоненты сильной связности, из любой вершины можно добраться до любой другой.
Это не компоненты сильной связности. Из этой вершины до этой можно добраться, обратно нельзя.
Давайте ведем такое понятие, как конденсация графа.
Конденсации ор-графа.
Ор-графа G называется граф G SCC.
SCC – это аббревиатура от strongly connected points.
Называется граф G SCC, в котором вершины – это компоненты сильной связности.
А ребро проводится, если в исходном графе есть ребро из одной компоненты в другую.
Что это значит? Давайте нарисуем конденсацию графа.
Есть треугольник, есть какой-то такой цикл, есть что-то такое.
Какой-то такой граф. Давайте сначала выделим компоненты сильной связности.
Что тут? Какие тут компоненты? Вот компоненты, вот компоненты, вот компоненты и вот компоненты.
Да, компоненты сильной связности, как я сказал, это максимальное приключение.
Ну и действительно, вот это вот множество никак нельзя расширить никакой другой вершиной так, чтобы сильная связность сохранилась.
То же самое с этой компонентой, с этой, с этой. Понятно, да?
В некотором смысле я разбил граф на такие мощные куски, внутри которых я могу свободно передвигаться.
Теперь давайте я представлю, что вот эти вот красные кружочки, это вершины графа, которые я сейчас строю, то есть конденсация.
И ребра между компонентами я буду проводить, если у меня есть ребро из соответствующей компоненты в другую компоненту.
То есть вот здесь у меня есть ребро между этими компонентами, которое ведет отсюда сюда.
Поэтому я провожу здесь ребро. У меня есть ребро из этой компоненты в эту и из этой в эту.
Поэтому я тут провожу ребр. Ну есть ребро из этой компоненты в эту компоненту.
То есть таким образом я получаю вот такой граф. Вот так, так, вот так, вот так...
Вот это конденсация графа. Вот это обычный граф.
Понятно? Может вы скажете, каким свойством у меня всегда обладает граф конденсации?
Он не сильно связан, но это правда. Если бы он был сильно связан, тогда у меня и весь граф был бы сильно связан.
А какое еще есть свойство интересное? Оцикличен. Это важно.
Все понимают, что в графе конденсации не может быть циклов? Нет, не все. Отлично.
Допустим, у меня есть цикл. Давайте нарисую. Допустим, у меня есть вот такое ребро.
Допустим, вот эти вершины образуют цикл. Что это означает?
Это означает, что я внутри этой компоненты могу двигаться как угодно.
Ну и плюс я между этими компонентами тоже могу двигаться как угодно. Почему?
Потому что отсюда я беру произвольную вершину, добираюсь до вершины, из которой ведет ребро в эту компоненту.
И отсюда уже добираюсь, куда мне надо. И соответственно наоборот. Понятно?
Если у меня есть две компоненты связанности, то есть есть какой-то путь сюда, есть какой-то путь сюда.
И мне нужно построить путь из произвольной вершины отсюда в произвольную вершину сюда.
Ну как мне нужно действовать? Давайте я просто доберусь до этой вершины, пройдусь путем до некоторой вершины отсюда и доберусь сюда.
Аналогично из этой вершины я смогу добраться до этой вершины. Ну, например, вот так и вот так.
То есть если у меня в графе конденсации есть цикл, то это означает, что те вершины, которые образуют цикл, на самом деле сами по себе являются сильной компонентой.
То есть я между ними могу спокойно перемещаться. Теперь понятно?
Поэтому такой ситуации быть не может.
То есть циклов в графе конденсации не бывает.
Ну и наша задача на сегодняшнюю лекцию понять, каким образом строить конденсацию графа, ну и каким образом выделять сами компоненты сильной связности.
Ну и в прошлый раз, я думаю, мы обсудили, что наивный подход с помощью одного обхода DFS нам не поможет.
Ну потому что в зависимости того, с какой вершиной вы начинаете, вы обойдете разное количество компонентов.
Ну, допустим, если вам повезло и вы сортовали с этой вершины, то вы обойдете только эту вершину, и она, соответственно, у вас будет в компоненте, ну, образовывая компоненту сильной связности.
Но если вы начнете отсюда, то вы обойдете весь граф целиком.
Но при этом неверно, что весь граф целиком является компонентой связности, компонентой сильной связности.
Хорошо.
Перед тем, как мы перейдем к основному алгоритму, давайте накажем одну небольшую лему.
Давайте даже как-нибудь озаглавим.
Лемма о том, что будет, если забыть проверять ацикличность в орграфе.
Что будет, если забыть проверять ацикличность перед топологической сортировкой.
Ну, сокращенно.
Мы к этой лемме будем обращаться именно так.
Ну, то есть, формулировка такая, если запустить топ-сорт без проверки циклов.
Что?
Нет, ну, смотрите, вот так. Не будет иррора.
Вот представьте себе, что вы запустили топологическую сортировку, но убрали вот эту строку.
То есть, просто игнорируете серые вершины.
Алгоритм же что-то сделает.
Более того, он сформирует вам какой-то массив.
И вот эта лемма сейчас вам скажет, какой массив вы сформируете.
То есть, если вы забыли на самом деле проверить серые вершины, то вы на самом деле не забыли.
Вы сделали что умное.
Ну, не сейчас, хорошо.
Давайте пока вы запомните название леммы, а потом после перерыва продолжим.
Продолжим.
Немного изменил начало.
Пусть запустили топологическую сортировку без проверки циклов.
Теперь утверждение.
Если есть ребро из компонента сильной связности C в компоненту сильной связности C штрих, то...
Ну, то есть, что утверждает лемма.
Вот у меня есть какой-то граф ориентированный.
Я на нем запустил топсорт и при этом забил на циклы.
Допустим, у меня есть компоненты сильной связности одна, есть вторая компонент связности,
из одной в другую идет ребро.
Пусть это C, а это C штрих.
Вот что утверждается тогда.
Найдется вершина U, которая принадлежит компоненте сильной связности C.
Такая, что в массиве answord она будет лежать.
Такая, что идет вершина, которая будет лежать левее всех остальных вершин из C штрих.
Левее всех вершин из C штрих.
Ну, что это означает?
Смотрите, вот есть граф, есть компонент связанности C, есть компонент связанности C штрих.
В таком графе я запустил топологическую сортировку.
И получил мы какой-то упорядоченный у нее вершин.
И вот что утверждается.
Найдется вершина U, вот некоторая, которая лежит в C.
Такая, что она находится левее вообще всех вершин, которые принадлежат C штрих.
Допустим, все вершины C штрих сосредоточены где-то здесь.
В какой-то такой области.
И обязательно найдется такая вершина U из C, которая будет лежать левее всех остальных.
То есть в некотором смысле топологическая сортировка без проверки циклов
топологически сортирует граф конденсации.
Понятно?
То есть, если вы запускаете топологичную сортировку в таком графе,
то вы получите такое упорядочение.
Сначала у вас будет какая-то вершина из вот этой компоненты,
то дальше вы идете, ходите, встретите какую-то вершину из этой компоненты связанности
и дальше идете, встретите какую-то вершину из этой компоненты связанности
и самое последнее, вы встретите первую вершину из вот этой компоненты связанности.
Если бы мы проверяли циклы, то уже на этом шаге мы бы зафэрились.
Если мы проверяем циклы, то у нас алгоритм в целом не работает.
Он сообщает об ошибке.
А если мы на циклы забиваем, то мы запускаем на графе,
и он какой-то массив нам строит.
И вот я утверждаю, что в таком массиве есть циклы,
то есть есть ребра, которые идут справа налево,
но при этом существует вершина из С, которая находится левее, чем все вершины из С'.
Итак, для любой пары компонент-связи, между которыми есть ребро.
Как будем доказывать?
Пусть у первая вершина из С, которую нашел топ-сорт.
То есть мой топ-сорт как-то гуляет по графу,
но в какой-то момент попал в компонент-связи С.
И вот это первая вершина, в которую мы попали.
Что тогда?
Тогда возможны два варианта.
Первый вариант.
Мы попали в компонент-связи С, и при этом компоненту С' еще не обходили.
Т.е. компоненту С' еще не обходили.
У меня есть компонента С, у меня есть компонента С' , в которой есть ребро.
Вот она, вершина У.
И тут, и тут все вершины белые.
А что это значит?
Так, а что это значит?
То есть все вершины из С и С' белые.
Что это значит по лемме о белом пути?
Да, по лемме о белых путях это значит, что когда я запускаю DFS от U,
я посещу все вершины из С' и С.
Мне сейчас важно, что я посещу все вершины из С' во время запуска DFS от U.
По лемме о белых путях во время DFS от U посещу все вершины из С'.
А это в свою очередь что означает?
Что все вершины из С' будут лежать правее, чем U.
То есть я сначала положу все вершины С' в мой массив,
и только потом спустя какое-то время положу вершину U.
Потому что с вершины U я заканчиваю позже, чем с вершинами С'.
Значит, что все вершины С' будут правее или положены раньше вершины U.
Все. В этом случае доказали.
Теперь второй случай.
Можно?
Второй случай.
До посещения U посещали С'.
Вот у меня есть компоненты С, есть репро из компонента С'.
Вот U это вообще первая вершина, в которую я попал, из компонента С'.
Но при этом в С' есть вершины, которые я посещал.
Верно ли, что это означает, что все вершины в С' уже черные?
Все понимают, что все вершины в С' черные.
Не очевидно.
Если я в какой-то момент попал в компоненту С', то в компоненту С я попасть никак не мог.
То есть, когда попал в С', не мог добраться до С'.
Так как С' у меня компонент сильной связности, при этом у меня граф конденсации ациклический.
То есть, я не мог добраться до С'.
Из этого следует они стали черными до посещения С'.
То есть, из какой-то вершины С' я запустил поиск.
Этот поиск обошел мне все вершины из С'.
Обошел, может быть, еще какие-то компоненты.
Но я точно знаю, что в вершину С я не добрался.
Соответственно, все вот эти вершины стали черными, так и не добравшись вот отсюда.
Да?
То есть, ни один вызов DFS от С' не мог меня привести сюда.
Это значит, что они завершились так и не узнав, что есть какая-то компонента С.
Да?
Иронно это я написал.
Они стали черными до посещения С'.
Из этого следует они все правее вершин из С'.
Все.
То есть, если я посещаю компоненту С' раньше, чем С',
то в С попасть не могу.
То есть, эта компонента чернеет, и дальше только я посещаю вершину С'.
Если я сначала посещал компоненту С',
то во время посещения компонента С я обязательно посещу компоненту С'.
Но при этом с ней я закончу раньше, чем с вершинами отсюда.
Вот и вся соль.
Окей?
Хорошо.
Ну и наконец, давайте попробуем построить алгоритм
для выявления компонентов сильной связности.
Так.
Давайте на каком-нибудь идейном уровне попробуем понять,
что нам хочется сделать.
Вот смотрите.
Вот представьте себе, что нам удалось,
представьте себе, что мы откуда-то, ну пока не понятно,
откуда знаем конденсацию нашего графа.
Вот мы ее откуда-то знаем.
И плюс она как-то топологически отсортирована.
Вот.
Могу ли я как-то посетить вершину, то есть запустить DFS из вот этой компоненты
так, чтобы я попал только внутрь вот этой компоненты,
то есть я обошел только все вершины из этой компоненты
и при этом не попал в другие?
Могу ли я это как-то устроить?
А если все другие черные?
А если не все черные?
Вот если я только запустил DFS, все вершины белые,
я как-то запускаю DFS от этой вершины,
чтобы при этом с целью обойти только вот эти вершины,
только вершины из этой компоненты.
Нет.
Нет. А можно ли как-то граф исправить, чтобы это было возможно?
Ну можно, чтобы не шли никакие.
Не шли никакие что?
Ну чтобы не на какие левы выходили.
Так. А как это устроить?
Давайте просто поменяем ребра местами, то есть обратим все ребра.
Смотрите, давайте я возьму граф и все ребра в нем инвертирую.
Это называется транспонирование графа.
УВ принадлежит ЕТ, когда ВУ принадлежит Е.
Транспонированный граф это такой граф, в котором я поменял направление всех ребр.
Представьте себе, что я в моем графе G поменял направление всех ребр.
Изменились ли у меня компоненты сильной связности?
Нет! Транспонирование графа никак не влияет на компоненты сильной связности.
Потому, что я по одному пути добрался от одной вершины до другой, так я могу и по другому пути добраться с помощью переворачивания ребер.
То есть на компоненты сильной связности это вообще никак не влияет.
А влияет ли это на достижимость в графе конденсации?
Влияет, потому что если я теперь стартую с этой вершины и у меня все ребра перевернуты,
то я обойду только те вершины, которые мне нужны.
Согласны?
Теперь, допустим, я обошел все вершины здесь.
Дальше я иду, согласно топологической сортировке, в другую компоненту сильной связности.
Допустим, вот в эту.
Куда я могу из нее добраться?
Теоретически я могу добраться по обратному ребру вот сюда.
Предполагаем, что это ребро перевернуто.
Но эта вершина уже черная.
То есть сюда я не доберусь.
А сюда я не доберусь, потому что это ребро перевернуто.
По глазам вижу, что надо...
Давайте по порядку. В чем план?
Алгоритм будет называться...
Ну как будет называться? Его назвали уже.
Алгоритм к сараю.
Состоит он из трех простых шагов, которые вам всем уже известны.
Первый шаг.
Запускаем топсорта G без проверки циклов.
Топсорт без проверки циклов.
Второй шаг.
Транспонируем граф G.
Давайте, пока не забыл, сразу буду писать сложность каждого шага.
Топологическая сфотография графа G без проверки циклов по-прежнему от V плюс E.
Транспонирование графа тоже за V плюс E выполняется.
Просто надо пройтись по всем ребрам и поменять их местами.
То есть поменять вершины местами.
И, наконец, запустить DFS на графе G, точнее на G-транспонированном, в порядке, заданном пунктом 1.
Все компоненты, полученные на шаге 3, это компоненты с сильной связностью.
Давайте продемонстрирую, как это работает.
Давайте тот граф вернем.
0, 1, 2, 3, 4, 5.
Вот как-то так.
Давайте я на нем просто проверну вот всю такую схему.
Давайте я стартую.
Первый шаг.
Запускаю топологическую сортировку на этом всем графе.
rocks.
Допустим, запускаю с вершины 0, из вершины 0 я иду в вершину 2.
Из вершины 0 я иду в вершину 2.
Из вершины 2 я иду в вершину 3.
Из вершины 3 я иду в вершину 5.
Из вершины 5 quantitative, не куда?
Кладу в начало.
Дальше.
Откатываюсь в тройку, из тройки – негуда.
Откатываюсь в двойку, из тройки – некуда.
Откатываясь в ноль, из нуля могу пойти в единицу, из единицы в четверку.
Из четверки возвращаясь обратно в единицу, и из единицы обратно в ноль.
Теперь давайте проверим ту лему, которая для любой компонента связанности верна,
что если есть ребро, то какая-то вершина находится левее всех остальных.
Есть ребро между этой компонентой и этой компонентой.
Верно ли, что пятерка находится позже какой-либо из вершин отсюда?
Ну верно. Вот есть ноль, а пятерка находится здесь.
Вот, дальше, 1-4. но при этом ноль находится левее, чем любая вершина отсюда.
Пятерка, точнее, единица находится левее, чем пятерка, то есть все вершины отсюда.
Вот. Это первый шаг.
Теперь второй шаг.
Затем граф ЖТ.
Вот так, вот так.
0, 2, 3, 1, 4, 5.
Вот. Это транспонированный, это обычный граф.
Ну и, наконец, третий пункт.
Запускаю DFS в соответствии вот с этим порядком.
Ну, что это означает?
Раньше DFS я выполнял как?
Ну, на бум.
Да, для каждой вершины, которая еще не посещена, естественно.
Что это означает?
Это означает, что раньше, когда мы делали DFS,
мы обходили вообще в произвольном порядке.
То есть здесь нам было неважно, в каком порядке мы обходим вершины.
Хоть с нулевой стартуем, хоть с первой, хоть с десятой.
А здесь мы вот этот вот обход, вот здесь цикл,
начинаем именно в том порядке, в котором заданы все вот эти вот вершины.
Ну, то есть что это означает?
Обход начинаем с вершины номер 0.
Вот отсюда.
Что мы сделаем? Что сделает обход при запуске от нуля?
Да, он обойдет только вот эти вершины.
Согласны?
Почему?
Как раз-таки потому, что я пытался объяснить до этого.
Потому что на первом шаге мы топологически отсортировали все компоненты сильной связности.
То есть сначала идет компонент, который принадлежит 0,
дальше идет компонент, который принадлежит единицы,
дальше идет компонент, который принадлежит пятерки.
Отсортировали все компоненты сильной связности.
И потом перебираем как раз-таки все вершины в порядке
топологической сортировки компонент связности.
Но так как мы обратили ребра,
то есть как у нас строено топологическая сортировка.
все ребра идут слева направо. Но после того, как мы обратили ребра, у нас все
ребра стали идти справа налево. То есть нет ни одного ребра, который вышел из одной
компоненты связанности слева в компоненту связанности справа. То есть из-за
этой компонент связанности мы теперь никуда выйти не можем. Понятно? Вот, поэтому
запускаем DFS от нуля, получаем 0, 2, 3. Далее идем. Запускаем DFS от единицы. Единицу
мы еще не проходили. Что нам обходит DFS от единицы? Ну, единицу и четверку. Снова, отсюда
мы уже сюда не доберемся, то есть другую компонент связанности мы не доберемся.
А вот сюда мы не доберемся, потому что всю эту компонент связанности мы уже
ранее обошли. DFS от единицы обойдет нам единицу и четверку. Дальше, пытаемся запустить DFS от четверки, но четверка уже посещена.
DFS от двойки, двойка уже посещена. DFS от тройки, тройка уже посещена. DFS от пятерки, ну, наконец
находим компонент связанности, который состоит из одной вот этой вершины. Все, магия. Круто? Вот и
все. Ну, основная идея, давайте запомним, в чем стоит основная идея. Это каким-то образом
отсортировать компоненты сильной связанности, а потом поступить хитро. Обратить обратные
ребра и сделать так, чтобы из одной компонент связанности мы не могли добраться ни до одной
другой. То есть мы, грубо говоря, компонент связанности запираем в самой себе. Вот. Так. Вот. Ну и третий пункт,
за сколько работает. Это V плюс E, это V плюс E. Третий пункт, за. Ну, тоже V плюс E. Тут DFS, тут DFS, тут просто
транспонирование графа. Все, то есть за рамки алгоритма DFS мы вообще не выходим последние две
лекции. То есть все за счет DFS. Ну и суммарно, естественно, тоже O от V плюс E. Все, то есть, по сути,
залинейное от размера графа время вы находите все компоненты сильной связанности. Ну и осталось
доказать корректность. О корректности. Ну, алгоритм Косараю.
корректно находит все компоненты сильной связанности. Почему так? Ну, потому что, значит, после первого шага,
что у нас получается? После первого шага по, почему? Ну вот, по вот этой вот штуке. По лемме. О,
вот об этом всем. Что у нас получается? Топологически отсортированы компоненты сильной связанности. Ну,
с точки зрения, что первая вершина из компонентов сильной связанности, то есть если мы возьмем самые
первые вершины из компонентов сильной связанности, то они будут образовывать топологическую сортировку.
Ну, обсуждали. Вот. На шаге 3 запускаем DFS от первой вершины. Какие вершины она обойдет?
Она обойдет все вершины из своей. Давайте ее обозначим STC1.
Но в силу шага 2 не попадет в остальные. Ну, почему? Потому что вот у меня есть массив,
отсортированный в топологическом порядке, и у меня все ребра в исходном графе шли только
вот так. Из-за этой компоненты сильной связанности. Так как я на шаге 2 все ребра обратил, у меня нет
исходящих ребр, то есть все ребра только входящие. Из-за этой компоненты сильной связанности.
Мне попадет в остальные. Вот. Следующая вершина обойдет свою компоненту сильной связанности
ДС2. Не попадет в остальные, так как из шага 2 следует. Нет исходящих ребр.
Ну и плюс нельзя попасть в компоненту сильной связанности 1, потому что она уже пройдена. То есть из
компонента сильной связанности 2, то есть которая здесь, я не буду попасть в те компоненты сильной
связанности, которые находятся правее, потому что у меня ребра инвертированы. И плюс вот в эту компонентную
связанность я не попаду, но потому что я ее уже обошел. Ну все, ну и так далее для любой компонент
сильной связанности. Все. Вот такие дела.
Ну и давайте обсудим еще одно интересное свойство, которое непосредственно вытекает из доказательства
теоремы, но и самого алгоритма. Что вы можете сказать про порядок компонентов связанности, которые мы тут получаем?
Ну вот мы получили компоненты сильной связанности 0, 2, 3, 1, 4 и 5. Да, смотрите. Во-первых, мы выделили
компоненты сильной связанности, это первый шаг, что уже неплохо. А второй момент, когда вы выписываете
все вот эти компоненты сильной связанности, вы их выписываете как раз в порядке топологической сортировки.
То есть у вас вот эти компоненты уже топологически отсортированы в самом результате, понятно?
То есть если у вас перед вами стоит задача, допустим, выделить граф, точнее выделить компоненты
сильной связанности, и все эти компоненты сильной связанности топологически отсортировать, то по сути faced andivedsnob
алгоритм Сарае сразу иерои и то и другое. То есть не нужно отдельно строить граф конденциации,
и строить его топологическую сортировку.
Да, потому что сами компоненты уже топологически отсортированы.
Вот эти компоненты.
То есть вот компонент 0.2.3
она топологически находится раньше, чем компонент 1.4.5.
Сначала выписали вот эту вершину, а вот эту.
И потом эту.
Наверное, на этом все, что касается сильной связности, все.
Есть вопросы?
Раз осталось время, давайте тогда перейдем.
И начнем следующую тему.
Алгоритмы, наверное, не успеем обсудить, но необходимые определения дадим.
Поговорим мы про эйлеровые циклы.
Слышали что-то про них?
Не все.
Эйлеровые графы.
Давайте за оставшийся 10 минут устроим легбез небольшой.
Следующую лекцию начнем с алгоритмов.
Эйлеров путь.
Это путь в графе, проходящий по каждому ребру графа ровно один раз.
Здесь нет эйлеров в пути, давайте где-нибудь придумаем.
В таком графе эйлеров в пути есть.
То есть я могу пройти вот так, вот так, вот так, вот так, вот так, вот так и вот так.
То есть я могу повторяться по вершинам, но примерно по каждому ребру я могу пройтись только один раз.
Граф, в котором есть эйлеров путь, называется полуэйлеров.
Это граф с эйлеровым путем.
Эйлеров цикл.
Просто замкнутый эйлеров путь.
Ну, например, если я возьму этот граф и добавлю в нем вот такое ребро, то я получу эйлеров цикл.
Раз, два, три, четыре, пять, шесть, семь, восемь.
Откуда стартовал, откуда туда и закончил.
То есть весь граф представляет себя один большой реберный цикл.
Эйлеровым графом как раз называется граф, который представим в виде одного эйлерового цикла,
в котором содержится эйлеров цикл.
Эйлеров граф с эйлеровым циклом.
Понятное дело, что не в любом графе есть эйлеров путь и эйлеров граф.
Ну, как минимум, в несвязанном графе, очевидно, таких путей и таких циклов не существует.
Сегодня мы не будем обсуждать, как искать эйлеров путь и эйлеровые циклы в графах, если они существуют.
Давайте сегодня ограничимся тем, что поймем, как вообще понять, если посмотреть на граф,
есть ли в нем эйлеров цикл или нет эйлеров цикла, при этом не строя сам цикл.
Хорошая новость заключается в том, что это возможно.
То есть, возможно, просто глядя на граф, понять, есть ли в нем такой цикл или путь или нет.
Давайте 1.1 критерий
Полуэйлеровости. Нет, давайте эйлеровости.
Для неорграфов.
Значит, дан неориентированный граф, ну, без направлений ребер, необходимо понять, является он эйлеровым или нет.
То есть, есть ли в нем эйлеров цикл или нет.
Связана игра в G эйлеров тогда и только тогда, когда связана в графе G для любой вершины V
из множества вершин, степень вершины четна.
Очень простой критерий. Если степень каждой вершины в графе у вас четная, в связанном графе четкая,
то значит, в этом графе у вас есть эйлеров цикл.
Это неориентированный граф.
Для ориентированного графа, да, там мы будем различать входящий и исходящий. Пока так.
Ну, давайте, доказывается просто, ну, вот в одну сторону.
Ну, почему это так? Ну, просто следует из баланса входящий и исходящий ребер.
Давайте просто построим сам цикл.
Построим цикл.
В каждую вершину вошли столько же раз.
Сколько вышли?
Из-за этого следует, что степень каждой вершины четна.
Ну, как у нас выглядит эйлеров цикл? Мы попадаем в какую-то вершину, из нее выходим.
Ну вот, если я допустим стрелочками, у меня указано направление цикла.
Для каждой вершины, видите, что есть стрелка входящая, есть стрелка исходящая, есть стрелка входящая, есть стрелка исходящая.
То есть ни в какой вершине мы не застреваем.
Поэтому степень каждой вершины четна.
Обратно покажем конструктивно предъявив алгоритм.
Но это в следующий раз.
То есть в следующий раз мы рассмотрим алгоритм и покажем, что если все вершины четные, то мы найдем эйлеров цикл.
Вопросы есть?
Теорема 1.2.
Критерий...
Что?
Я сказал, мы алгоритм предъявим в следующий раз.
То есть сегодня мы алгоритм не обсуждаем.
Ну в следующий раз давайте.
Критерий полуэйлерности
неориентированного графа.
В связной графе G полуэйлеров.
Когда и только тогда.
Когда, на самом деле, то же самое.
В связном графе G
для любой вершины
четная, кроме
может быть двух.
Это если у вас все вершины четные, точнее, степень кончески четная, то у вас есть Book clerk в циклу.
Ну а Bookler в циклу, соответственно, Perform150 contr gab iyi.
Но при этом возможно такая ситуация, что у вас есть ровно две вершины, вот ровно две,
у которых степень нечетная.
Но тогда у вас просто есть earrings-путь, но Эйлерова цикла нет.
Ну, как доказать?
Кажется, очень просто. Сведем к теореме 1,1, добавив
ребро между вершинами с четними степенями, понятно? Вот мы нашли две вершины, у которых
степень нечетная. Что? Может есть, но просто ставим еще одну.
Мульти граф не важно. Вот ровно то, что мы делали до этого. Да, у нас был эллеров путь, точнее был граф,
в котором, если представить тебе, что все эти вершины, все эти ребра неориентированы, то у каждой
вершины степень была четная, кроме вот этих двух. Мы просто между ними ставили ребро, нашли цикл,
а потом цикл обратно вернули в это ребро, получили путь.
