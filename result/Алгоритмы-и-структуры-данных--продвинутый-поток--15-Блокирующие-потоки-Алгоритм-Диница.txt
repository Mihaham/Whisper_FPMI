Итак, то есть что мы сделали в прошлый раз?
Ну, с точки зрения теории, мы с вами в прошлый раз доказали теорию ухода Фолкерсона
и даже алгоритм Эдман Саккарта.
Но сегодня мы попробуем изучить более продвинутый алгоритм.
Ну а начиная с этого момента, тут уже алгоритмы поиска потока, их много,
но есть два магистральных направления, в которых они бывают.
Мы изучим оба.
Первое, что мы сегодня будем изучать, это концепция блокирующих поток.
Сразу два момента, во-первых, не единица, а единица, напоминаю.
А во-вторых, здесь вот такое, обычно это ассоциируется с фамилией Динец,
потому что он был первым, кто предложил алгоритм, но мне кажется целесообразным
отделять глобальную концепцию блокирующих потоков непосредственно алгоритма Динеца.
Сейчас увидите почему.
А в чем у нас идея?
Давайте вспомним, как был устроен алгоритм Эдман Саккарта?
Применяем метод Форда Фолкерсона, каждый метампуть ищем по этому.
Или если переформулировать это по-другому, то мы берем, то есть в каждый момент времени
мы в остаточной сети ищем кратчайший по количеству ребер путь, по которому можно протекнуть поток.
И мы доказали мистическую теорему о том, что расстояние от истока до стока в этом смысле не уменьшается.
Концепция блокирующих потоков предлагает делать более хиткую вещь.
Ведь заметим, что мы на каждом шаге запускаем БФС честно.
Концепция блокирующих потоков предлагает следующее.
Значит запустим БФС.
Что у нас получится?
Вот этот поток мы уже, как помнится, в ретроанализе рисовали.
Это по остаточной сети.
Ну, я еще не сказал 3 слов, но это да, это она.
Ну, почти.
Ну, конечно же, внимательные зрители заметят, что я рисую не все ребра.
Во-первых, когда я сейчас рисую ребра, я имею в виду, естественно, ненасыщенные ребра.
Понимаете, да?
Значит, меня интересуют только ненасыщенные ребра.
Пока что вы рисуете только... вообще только ребра, которые в БФС были учтены?
Абсолютно верно.
Да, то есть действительно, можно сказать, что еще на самом деле есть и другие ребра.
То есть могут быть ребра какие?
Ну, могут быть там всякие вот эти вот ребра.
Вот эти вот, да, не очень видно, но они нам и не нужны.
Поэтому рисую такие матеры.
И ребра, конечно, ведущие куда-то слой назад.
Самое главное, что для нас верно, это то, что не существует ребра, которые ведут вперед.
По определению БФС.
Да, через слой.
Ну, или через несколько слоев, да, просто по определению БФС, совершенно верно.
Вот тут всякое вот такое.
Потом тут слой может сужаться, а может и нет.
Там где-то тут он наконец включается, сток, наконец-то.
Слои на этом, кстати, не заканчиваются, что интересно.
Ну, они нам относительно бессмысленно, да.
Мы же их не ищем после этого.
Почему?
БФС работает полностью.
Ну, в принципе, в БФС, в БФС, в БФС, в БФС.
И теперь идея такая.
А давайте-ка...
Значит, нот.
А давайте-ка попробуем, значит, во-первых, временно проигнорировать.
Ну, мысленно даже вот, мы можем себе представить мысленно, что мы их просто вот выкидываем.
представить мысленно, что мы их просто вот выкидываем, ну по факту мы их временно игнорируем, тогда то, что осталось называется слоистая сеть.
Слоистая.
То есть вот только черные ребра имеют значение, все остальные мы их знаем.
Так вот, так вот наша цель найти в этой сети блокирующий потоп.
Ну полный мы же прошлый раз сталкивались даже с понятием блокирующий потоп.
Что это такое?
Максимальный потоп вести.
Такое, что нельзя добавить еще что-то.
А целый путь.
Да нельзя просто целый путь добавить.
Ну не совсем.
В общем случае, помним, блокирующий потоп это нельзя по какому-то пути пропихнуть потоп без отмены потока по какому-то ребру.
То есть может быть этот потоп будет не максимальным, но вам тогда придется забить.
Ну в терминах вот этой сети, то есть вам придется отменять потоп по контр-ребру, это означает, что вам придется как-то вот так вот.
То есть действительно сейчас нас интересует, сейчас мы будем пихать потоп, но пихать потоп мы будем только по путям из СТ, такие, что каждое ребро ведет в следующий слой.
То есть условно ходить как-то внутри слоя, перескакивать как-то вот так вот, круги наворачивать.
Вот что мы не будем, то мы не будем.
Так что соответственно идем, идем, идем.
То есть наша цель не найти в этой сети максимальный потоп.
Нам достаточно найти в соответствии с концепцией именно блокирующий потоп.
То есть потоп такой, что именно вот по вот такому вот виду пути припихнуть потоп уже не удастся.
То есть у нас нельзя использовать обратное?
Нельзя.
Причем не только обратное, которое мы выкинули, потому что мы оставили только черное, но еще и обратное к черным, которое появится, если мы будем просто потопиться.
Ну да.
Ну да.
Ну теперь заметим, что конечно же, так как мы нашли блокирующий поток, он не обязан быть максимальным.
Ну и что, мы идем заново?
Что нам предлагает концепция?
Концепция предлагает действительно следующее.
Значит запустили BFS, нашли блокирующий потоп.
Значит восстановили в правах все ребра.
Ну а также если появились какие-то новые обратные, там где-то появились вот какие-то наши любимые рыжие, дорогие ребра.
Так.
Вот, там какие-то вот такие могли появиться.
Могли еще такие.
Так, как тут еще даты можно дойти?
А, ну как-нибудь вот так вот можно.
Ну можно.
Может быть вот это вот так вот.
Да, ну ладно.
Вот.
Всяк это могло быть, какие-то ребра пришли.
Ну все восстанавливаем в правах и запускаем BFS заново.
Запускаем BFS заново, получается вообще другая сеть, и мы в ней теперь еще блокирующий поток.
Да, но конечно же старые потоки мы не отменяем.
Да, но BFS все еще запускаем по...
Нет, не односущное.
Вы думаете, что мы умеем по обрядным рогам там ходить?
А, ну в этом плане, да.
Формальное определение можно еще раз повторить?
Блокирующего потока?
Нет, это по-настоящему блокирующий поток.
Нет, да.
Ну я бы сказал да.
Нет, на самом деле да, потому что блокирующий поток это поток, который нельзя улучшить путем исключительно добавления потока по всем ребрам.
Или вот, или в цервинах слои...
Не существует ненасыщенного пути из стока в исток, все?
Да, в нашем случае строка по черным ребрамам.
А, по черным, потому что нет, мы сказали выкинем все остальные ребра, а потом в получившемся графе найдем блокирующий поток.
Ну здесь я просто сказал, что как-то будет в церквенах именно слои стоить.
Да, конечно.
Первое, что я сказал, это в общем случае работает, но в общем случае блокирующий поток не нужен.
Вот.
Но тогда, когда мы уже второй запустили другой БФС, другой граф, другие ребра вообще стали черными, бывшая рыжая могла стать черным, там черная могла стать фиаретовым, там все что угодно.
А могло и просто исчезнуть, потому что у нас нет.
Ну теперь мы и в ней поверх старого накидываем блокирующий поток.
Ну поверх понятно, как мы сказали, могут быть отменные вот эти все.
Делаем мы это так, пока в полном соответствии с методом форда фонстракциона, пока из СТ вообще есть путь.
Ну как только еще другой БФС скажет, что пути нет, значит ура, поздравляем.
Собственно, мы нашли максимальный поток, теряем форда фонстракциона, восприветствуем.
Вот.
То есть вот такой получается металгарита.
То есть сама в себе концепция, она заключается в следующем.
То есть прям вот концепция.
То есть это такой тоже еще один про алгоритм.
То есть так сказать, вот я его могу так сравнивать.
Пока в, ну вот из СТ есть путь в остаточной сети, так сказать, ЖФ, по ненасвещенным ребрам.
То, соответственно, запустить БФС, вот я так напишу, запустить БФС, запитая, построить слоистую сеть, я тут через запятую напишу, потому что это одновременно делается.
Слоистую сеть.
И соответственно, найти в этой сети, в этой сети наш патрон.
Вот.
Вот.
Вот.
Вот.
Вот.
И соответственно, найти в этой сети, в этой сети наш любимый блокирующий патрон.
А чем отличается от Эдманса Карпа?
От Эдманса Карпа он отличается следующим, смотрите.
Эдманс Карп, он за один БФС находит один путь.
Один путь.
Один путь проталкивает по нему поток и запускает БФС заново.
А тут мы сразу все пути.
Он находит не блокирующий поток, а просто единичный.
Ну не обязательно все.
Да, не обязательно все.
Но мы пытаемся из этого БФСа, из этих слоев, понаходить тут как можно больше пути и попихать как можно больше поток.
Но при этом, ну правда, не то чтобы как можно больше, прям идеально больше, но мы это делаем жадно.
То есть пока вдоль этого же БФСа можно пихать, мы пихаем, пихаем, пихаем.
Может получиться не оптимальность, но напоминаю, вот давайте я напомню этот классический пример на единичных графах.
Чем вот, просто напомню, чем блокирующий поток отличается от максимального, да?
Потому что вот может сложиться вот такая красивая ситуация.
Вот такая красивая слоистая сеть.
И допустим.
Очень умными ножки, вот такой поток.
Ну вот, ну вот, сейчас я давайте вот нарисую.
Вот, ну значит поехали.
Ну вот, значит что может быть блокирующим потоком?
Ну, можно конечно максимальный найти, но нам на самом деле для наших целей, вот я не буду сейчас обратные ребра рисовать.
Потому что сейчас они тут слоистой сети не нужны.
Но заметим, что вот этот поток максимальным возможным конечно не является, но для блокирования его хватит.
То есть нам самое главное, чтобы от СДТ вот просто вот чисто вот по этой вот вырезанной сети слои по слои сети нельзя дойти.
То есть в остаточной сети конечно же вот там вот так вот дойти можно, но а так нельзя.
Поэтому это нас, вот такое нас устраивает.
А как мы можем быстро найти блокирующий поток?
Вот именно поэтому я употребляю слова концепция и мета алгоритм.
А, хорошо.
Пока еще конечно никак.
Я лишь говорю вот общей концепции.
Потому что дальше в этом месте могут быть подставлены самые разные методы.
И метод Диница это только первый из всех.
И подставлены они могут быть только в поисках блокирующего потока.
Да.
Со стороны остается как всегда.
Да, да, да.
Вот.
Но прежде чем переходить к этим конкретным методам,
то есть кое-что мы можем уже сказать и сейчас.
Но в первую очередь нас интересует вот что.
А не может ли это алгоритм вообще зацепиться?
Нет.
А как это?
А не может ли этот алгоритм вообще зацепиться?
Нет.
Почему?
Потому что максимальный поток существует.
Значит он работает в худшем случае за...
В худшем случае количество вайлов, которые мы проделали, это максимальный поток.
Так.
Вот тут...
Да, да, да.
Осторожно.
Напоминаю, и в одной из задач нам это жестко пригодится,
что профессиональные способности и потоки не обязаны быть целыми.
Да.
Наш алгоритм фолда фарклопса...
Он тоже зацикливался.
Зацикливался.
И более того, там даже будет пример, когда он не просто зацикливается,
а даже не сходится.
Правильно.
Вот.
Что?
Ладно, я просто...
Ну, как-то...
Например, на пяти вершинах.
Ну да.
Число ФИХ.
Да, там с ФИВа всякие.
Золотое сечение такое.
Ну, кажется, у этой алгоритмы должны быть ровные те же проблемы.
Казалось бы.
Мы же говорили, что если берем кратчайший консерватор...
Но мы говорим следствие.
Предположим, что блокирующий поток нам с небес по пакцию присылает.
Да, конечно.
Так вот, я утверждаю, что он...
А, точно, я знаю почему.
Но по другой причине.
Потому что в каждой следующей сети...
В каждой следующей сети...
Остыковая сеть называется...
Своей сети будет более длинный путь.
Да, совершенно верно.
То есть утверждение следующее, что после каждой итерации этого вайла
расстояние от СДТ будет, внимание, строго увеличиваться.
Оно не останется тем же и не уйдет дальше.
Вот.
То есть вот такое утверждение.
В общем, более того, если вы вспомните доказательства Айбонсакарпа,
по чьей части его, то в общем-то здесь доказательства то же самое.
То есть доказательства такое.
Вот предположим, вот у нас очередная, так сказать, фаза этой концепции.
Вот она.
Вот у нас очередная слоистая сеть.
Мы в ней нашли какой-то таз блокирующий поток.
Что поменялось?
Что в остаточной сети.
Поменялось то, что остались...
То есть некоторые черные вот эти ребра поисчезали.
Попроявлялись некоторые вот такого вида рыжая.
Ой, ладно, придется нижние ребра присывать.
Придется сделать.
Присывать точно.
То есть некоторые, естественно, поисчезали.
Потому что, естественно, мы проталкиваем там по каждому найденному пути максимум того, что можем.
Ну, условно там, конечно.
Блокирующий поток не обязан сделать именно это.
Ну, какие-нибудь ребра там вот.
Вот это там поисчезало.
Вот это поисчезало.
Ну и так далее.
Но фиолетовые ребра остались без измени.
Теперь попробуем представить себе, каково теперь в остаточной сети с учетом рыжих ребр
это.
Заметим, что меньше, чем было, оно не встало.
Потому что если мы рассмотрим те же самые слои, то есть те же самые слои,
то мы заметим, что каждое ребро может увеличить номер слоя все еще не больше, чем найденое.
Потому что вот таких вот ребр у нас не появилось.
У нас появились только ребра, ведущие назад.
Понимаете, да?
Угу.
Значит расстояние не уменьшилось.
Может оно осталось тем же?
Тогда у нас есть путь от СДТ, СБТ.
Совершенно верно, да.
То есть за то же расстояние можно идти исключительно по черным ребрам,
а у нас по определению блокирующего потока таких нет.
По собственному мнению, это и нацеливает.
То есть следовательно, расстояние от СДТ, выраженное в количестве ребр,
строго увеличивается.
То есть после каждой фазы расстояние будет строго больше.
То есть это означает, что количество итерации даже не просто небесконечное,
а оно не более чем В.
Ну, да.
То есть то, что путь не уменьшается аналогично Эду Цукарку,
а то, что не может стать таким же, потому что у нас нет пути, которые может быть лучше.
Именно, да.
В общем, можно сказать, что блокирующий поток – это как раз цель сделать так, чтоб такого пути не было.
То есть нам этого достаточно, и это уже не зациклено.
Вот такая разница.
Вот такая кохивая у нас разница.
Остается только, как же найти блокирующий поток.
Всего-то, конечно.
Да.
Ну, вот.
И так.
Ну, самый простой метод.
Ну, Машка, самый простой, конечно.
Хотя, скорее всего, самый...
Хотя, например, самый идейный первый, что напрашивается.
Но, раз уж не равно, жадно.
А давайте просто будем искать...
Найдем там первый попавшийся путь.
Там, из СВТ.
И пропустим поток по нему.
И еще раз.
Единственное, нужно помечать ребра, которые умерли.
Спокойно, погоди.
Оттуда ты все бежишь. Спокойно.
Лук.
Значит, смотри.
То есть, действительно, если делать...
Ну, теперь, вот, если это все соходить, то представим себе,
что просто будем как-нибудь там любым даже ДФСом.
Вот, внезапно, ДФСом.
Ну, да.
Ну, нет.
Не совсем.
То есть, ну, на первом этапе, конечно, да.
Хоть ДФСом, хоть...
Да, смешно.
Ну, лучше ДФСом, чтобы уже...
Чтобы не путаться.
А то каждый ДФС, где есть свои слои.
Один раз запустили, давайте там.
Запустили ДФС, нашли путь.
Запустили еще раз ДФС, нашли еще путь.
Итак, ищем, пока ДФС не скажет, все пути нет.
Вот, внимание, вопрос.
За какое время сработает такой алгоритм?
За количество вершин.
Почему вершины?
А, количество вершин нет.
В худшем случае, количество вершин.
Ну, да. То есть, количество вершин, количество вершин.
Количество вершин, количество вершин.
На каждом шаге мы убиваем хотя бы одно ребро.
В чем заметим, что с точки зрения слоистой сети мы его убиваем безвозвратно.
Ну, с точки зрения слоистой, да.
Вот, это приятно.
Но ребро-то у нас все равно остается Е.
И каждый ДФС работает за Е.
То есть, получается, если у нас получится, что одна итерация тогда сработает за Е квадрат, а это алгоритм в Е квадрат.
Ну, да.
Ну, на самом деле, если взять этот алгоритм, заменить ДФС обратно ДБФС и отменить понятие слоистой сети, то, в общем-то, мы просто получим алгоритм Эдмоцикрата.
В явном виде.
Так что, в общем-то, ничего удивительного.
Но, оказывается, не сильно сложно это все сократить.
Ну, вот такая нота.
Идея здесь такая.
Что, значит, открою ноту.
Ну, как вы говорили, что каждый ДФС у нас работает, с одной стороны, за от Е, да.
Ну, теперь у нас мысль такая.
Заметим, что, во-первых, если ребро убилось, то, наверное, и атламика не восстановится.
Тогда идея такая.
Такая несимпатическая оптимизация.
А давайте его еще и выкинем.
Ну, пока, чисто виртуально мы же, пока мы помним, что мы умеем, как же, выкидывать ребра, а потом восстановить в правах, правда?
Ну.
Ну, хотя бы виртуально мы умеем, я сейчас не призываю, прямо сейчас бежать и за пять минут написать, как это делать.
Да, тем более, что потом мы увидим, как это на самом деле делать в данном случае.
Но, мы, по крайней мере, можем себе представить, что у нас есть там, ну, у нас есть обычная остаточная сеть, да.
А на ней стоит вот надстройка слоистая сеть, где вместо каждого ребра стоит ссылка на реальное ребро.
Ну, нет, ну я просто такой, просто такой понятный образ рисую.
Просто чем тогда это будет приятно, ссылка, такие ссылки?
А теперь, если мы представим, что эти ссылки находятся, скажем, в каком-нибудь двусвязанном списке, то значит, тогда, если ребро стало насыщенным, мы его просто выкидываем в следующих ДФС-ах, не тратим на него времени.
Понимаете, да?
Ну, сама по себе эта оптимизация мало что даст.
Но ее можно докрутить дальше.
Если мы не убили ребро, если мы не нашли, то не было пути.
Ну вот.
Но теперь, действительно, заметим теперь следующее.
Что если мы пошли по ребру, вот пришел, блядь, вот пошел по ребру, и путь до Те не нашел, то заметим, граф у нас устроен так, что он, в общем-то, путь по этому ребру больше не найдет никогда.
И это означает, что в этом случае ребро тоже можно убить.
Вау.
Понятная идея?
Да.
Так, если не понятно, лучше спросить.
Понятно.
Так, кстати, Дан, надо было сразу спросить, а кто вообще знает этот алгоритм?
Я очень давно не писал про этот алгоритм.
Тут только без доказательств, просто писать.
Ну понятно, да.
А как называется он?
Алгоритм Джинница.
А, ну тогда да.
У вас название знаю?
Когда-то было, да.
Я даже написал.
Да, да, да.
Не сработало, к сожалению, но это...
Не, сработало, сработало.
Джинниц.
Правда, задача все равно не зашла.
Но это странно.
А про асимпточку...
ДФС-х можно еще раз повторить?
Про какой, про яквадрат?
Да, почему...
Ну, если в тупую ДФС, то асимпточка простая.
Потому что, смотрите, каждый ДФС убивает ребро.
Ребер всего е.
Значит, ДФС-ов будет не более чем е, каждый ДФС работает за е.
Ну вот.
Итого одна фаза е-квадрата, так как фаза более чем е, итого дали е-квадрат.
Вот.
Ну а теперь мы говорим, вот ДФС в первичном более продвинутый ДФС.
Мы говорим, что мы убиваем ребро не только...
То есть мы ребро убиваем, в смысле, прям выкидываем из графа.
Прям вот вообще выкидываем, прям из списка выкидываем.
А еще говорим, что если мы прошлись по ребру и путь до Т, не нашли, то есть ДФС вернулся с носом.
То больше он по этому ребру, то по этому ребру вообще ходить бессмысленно.
И мы его тоже игнорируем.
Как?
Как же изменилась и синтетика?
А теперь давайте себе это вообразим.
Что у нас будет тогда происходить?
Как будет выглядеть ДФС?
Значит...
Значит, Джилл был С.
Значит, ДФС пошел по ребру.
Значит, из этой вершины он тоже пошел по ребру.
Пошел по ребру.
Пошел по ребру.
Пошел по ребру.
Пошел по ребру.
А тут ходить некуда.
Да, и это все не естественно.
Значит, мы обнаруживаем, что по этому ребру ходить бессмысленно.
Мы его тоже выкидываем.
Значит, идем хорошо в следующую вершину.
Но тут в этом слое, в принципе, это какой-то слишком далекий слой.
Прям вот где-то здесь.
Там в каком-то вот этом, допустим, слое.
Ну вот.
Поэтому это мы тоже игнорируем.
Вот.
Значит...
Ну и вообще тут, смотрите, пробежались тут по всем ребрам.
И все они великолепно игнорируют.
И так возвращаемся сюда.
Значит, видим, что теперь, оказывается, здесь ходить бессмысленно.
Поэтому мы это тоже убили.
Вот.
Так, ну что у нас тут еще происходит?
Ну здесь у нас еще какое-то великолепие.
Сюда можно пойти.
Ну и здесь, допустим, там, допустим, вот пара ребр.
Тоже их поубивали.
Ходить бессмысленно.
И это тоже.
И что дальше?
Нет, погодите, сейчас.
Ну, я тут еще рассмотрел.
Хорошо.
Пошли отсюда-сюда.
Вот это убили.
Пошли сюда.
Так.
Ну и ребро ведет сюда.
Заметим, что на этот раз мы за О от единицы выбрасываемся.
Почему?
Потому что здесь тупо не осталось ребр.
Обратите внимание.
Потом пошли куда-нибудь вот сюда.
И тоже убили.
Ну и здесь уже что-то новенькое, но тоже поубивали.
Ну и, допустим, вот наконец-то мы пришли в Т.
И вот сюда.
Да, пришли в Т.
Значит, ура.
Мы нашли путь.
И давайте по этому пути протолкнем поток.
В общем, какой-то ребро еще при этом даже убилось.
А может и несколько.
Ну хотя бы одно убилось.
Так.
Ну какое же ребро убилось.
Ну давайте вот это.
Вот.
То есть смотрите, как интересно.
Значит, что теперь происходит?
Значит.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Значит.
Теперь.
Второй ДФС.
Значит.
Запускаемся.
Значит идем по этому же ребру.
Идем.
Ну порядок.
Ну первое в списке, поэтому.
Да.
Скорее всего да.
Ну в общем-то алгоритм бы работал и без этого, но.
Да.
Ну вряд ли вы там будете рандом шафтить ребра перед каждым ДФСом.
Да.
Ну вот.
Это симпатику лучше.
Ну, смотря как писать.
Может на самом деле там среднюю будет хорошо.
Ну вот.
Значит идем дальше.
Что у нас тут?
Значит.
Значит да.
Это ребро убилось.
Ну мы идем.
Такое ребро.
Вот.
Потом допустим идем сюда.
Потом идем сюда.
Потом уже.
И потом.
В чем?
Заметьте.
Тут золотые единицы.
Сюда и сюда.
Нашлось.
Нашлось.
Теперь можно еще что-то поубивать.
Ну можно сразу поубивать скажем.
Вот это ребро.
Вот это.
Ну и вот.
Вот.
Ну и так далее.
Производ.
Производ.
То есть основной смысл теперь такой.
Что каждый.
Ассинтотип каждого ДФСа.
Ну ассинтотип каждого ДФСа.
А заметите что у нас такой не совсем тривиальный ДФС.
Что мы даже не особо помечаем вершины.
То есть у нас нет пассива юзер на вершине.
Круто.
Потому что в общем-то если мы уже там были в вершине.
А потом пришли в ее второй раз.
Значит вы выброситесь оттуда за вот эти единицы.
То есть юзером будет такой неявный.
И будет такой неявный.
И будет такой неявный юзер за счет удаления.
И тогда я упреждаюсь что один ДФС.
Он работает за О от.
Расстояния от С до Т.
Плюс.
Количество.
Удаленных ребр.
Ну он продолжает работать по сути.
За О.
Каждое ребро которое он увидел.
Ну а каждое ребро либо удалено.
Либо вошло в итоге в этот вот путь.
Сначала этот.
А потом может выяснилось что вот этот.
Но заметьте теперь.
То есть теперь если мы все это просуммируем.
Что получится?
О от Е плюс С.
Заметьте что если мы просуммируем удаление ребр.
То суммарное удаление ребр.
Все это сумма будет в принципе.
О от Е в каждое ребро может быть удалено не более чем один раз.
Ну вот с этим сложнее.
Потому что.
Ну расстояние.
В худшем случае оно В.
И убивает сколько одно ребро.
На каждом шаге он константа.
Ну как константа.
Константа Л.
И в худшем случае константа В.
А в среднем пополам.
Поэтому мы вынуждены оценивать как В.
У нас строго уменьшается.
Кто уменьшается?
А увеличивается.
Во-первых увеличивается в одной слоистной сети.
А оно вообще фиксируется.
То есть получается да.
Можно так упомянуть.
Ну то есть это в принципе гарантирует нам то.
Что DFS все еще будет не более чем Е.
Даже не О от Е.
А Е.
Понимаете да?
Потому что каждый DFS в итоге убьет хотя бы одно ребро.
И тогда получается в сумме.
Значит DFS.
Чего?
О, в квадрат Е получилось.
Ну да.
То есть как бы в сумма.
То есть сумма по всем DFS.
Получается значит О от.
Значит вот так я напишу.
Е умножить на диск.
От СТ.
И еще плюс Е.
Думаю в одной операции.
Это один блокирующий поток.
В одной слоистной сети.
Ну соответственно понятно.
Что эта штука не превосходит В.
Поэтому пишем.
Что можно оценить действительно.
Поиск блокирующего потока.
Как О от ВЕ.
Да.
Потому что да.
Так как да.
Всего.
То есть и того получается в квадрате.
Вот такая вот приятная.
Вот.
Но на самом деле часто конечно можно сказать.
Что это может быть не самая лучшая симптутика.
Конечно.
Потому что мало ли там.
Потому что обычно любят конечно симптутику там.
Хотя бы Е.
Вот.
Но на самом деле тем не менее.
Во всяких этих ваших олимпиадах.
Собственно алгоритм Денис является самым популярным.
Ну вот.
И он почти всегда заходит.
Но мы сегодня будем очень активно изучать причины почему.
Потому что на самом деле.
Это мы оценили.
Эта оценка В квадрат Е.
Эта оценка в абсолютно абстрактном случае.
То есть когда у нас ребра абсолютно произвольные.
И там.
То есть вообще даже не целые.
Вот.
А на самом деле если они целые.
То имеют место и другие акции.
Сейчас просто оцент.
Да.
Абсолютно тот же самый алгоритм.
Но он будет работать быстро.
Это очень странно звучит.
Ну.
Почему?
Ну потому что можно же любые веса.
Эпо и Близи.
Целыми?
Да.
Ну просто там.
Ну там так.
Или расследствовать типа лог.
Нет.
В этих всех асимптотиях будет активно участвовать.
И ограничение на пропускную способность.
Да.
Поэтому если просто приближать.
То просто Ц будет очень большой.
А можно же сформально повторить.
Какие мы вообще ребра удаляем?
Мы удаляем те.
Из которых дальше нельзя дойти до Т.
Да.
Те.
Которые.
И еще какие.
Ну и конечно те.
Которые насытились.
И все.
Да.
Больше.
Ничего.
Вот.
Но правда.
Нет.
Единственное.
Процелы.
Это мы конечно будем отдельно обсуждать.
Но теперь на самом деле.
Как это?
Кто-то уже вчера.
Так это.
Кто-то уже вчера.
В смысле вчера.
Неделю назад.
Да.
Ну.
Это было вчера.
Да.
Вот.
Детей-то спрашивал.
А при чем тут линка?
А при чем тут линка?
Нет.
Так.
Так вот.
При очень большом желании.
На самом деле.
Да.
Так.
Вот.
Вот теперь.
Вот.
Вот.
Вот внимательно посмотрите.
И скажите.
Где здесь.
Можно найти.
Линка.
Так.
Чтобы он.
Улучшил.
Ассертизм.
Ну.
В тот момент.
Когда мы ДФС.
Может.
Ну.
Короче.
Погнали.
Сделаем.
Кучу разных деревьев.
Будем их.
Переподвешивать.
Друг за друг.
Когда.
Умерли.
И.
Тогда.
Пропускание потока.
Это будет.
Просто.
Операция.
На.
Пути.
Что.
За.
Вред.
И.
Несу.
Чего.
Чего.
В чем.
В чем.
В чем.
В чем.
В чем.
В чем.
В чем.
В чем.
Так.
Всего для Бога.
Ты должен ты это.
В чем.
В чем.
В чем.
В чем.
В чем.
В чем.
В чем.
В чем.
ramer.
Как inserting.
К erased.
Наже что.
Д音.
Отс exacerbated.
Дай опускать и не Rickyм.
Станет.
ВыQWaY.
Да-а-а.
Вogen.
На.
Получается.
ВыQWaY.
Это pleasures.
Какching.
Да.
Дерево на EPS, когда ты удалишь ребро, у тебя отвалится целое под дерево.
Это нормально, так же должно быть.
Ну вот, всегда когда удаляешь ребро, под дерево удаляется.
Я не знаю, в чем плюс.
Ну нет, я знаю, в чем плюс.
Вот мы его делаем, делаем, делаем.
И теперь у нас...
А, у нас все равно проход будет долгий.
Ну да, заметим, что самое узкое место, на самом деле, где самое большое дает, это то, что все-таки вот эти вот пути мы проталкиваем долго.
Даже не само проталкивание долго, а просто поиск этого пути, в итоге, оказывается.
Ну да.
Если большая его часть уже где-то лежит, в каких-то деревьях.
Нет, ну как сказать?
Ну как поиск.
В некотором смысле заметим, что поиск и проталкивание конкретно этого пути, это одно и то же.
Потому что все, что кроме него делается, это отки.
Ну да, действительно, как бы он действительно делал так, чтобы искать пути?
А самое главное, у всех, как запропускать поток, быстрее, чем заводить.
А это никак не связано с тем, чтобы хранить дерево ДФС в линкафе?
Дерево на ФС нет.
Дерево, конечно, да, но тут не дерево ДФС, а немножко на опору.
Вот так.
Я же правильно помню, что в линкате можно удалять ребра.
Ну да, можно.
Сакшановер.
Да, сакшановер.
Нельзя построить дерево, потом мы находим блокирующий поток из СВТ, удаляем ребро, а потом мы проводим, вот у нас остается два по дереву, находим какое-то ребро и проводим новое, так сказать.
Ну а не получится тогда, найдем условно, где маркером рисуем, получится, живо было какое-то дерево.
Вот такой вот край, край, край.
И вот где-то тут нашлась Т.
Ну вот.
И вы говорите по количеству...
Допустим, куда убиваете это ребро, ну там пропускаете путь, удаляете, ну вот, и что теперь?
А теперь мы вот из той вершины находим предыдущий, не-не-не, значит следующий, из следующей вершины находим ребро, которое оттуда входит.
А, может быть не дерево.
Ну да, может быть не дерево.
И может не остаться ребра.
Стоп, почему может быть не дерево?
Нет-нет-нет, может не остаться ребра, имеется ввиду, которое ведет.
Ну может не остаться.
Нет, если вообще их не осталось, то и слава богу.
Ну тогда придется предикаскадно как-то с этим еще раз упираться.
Правда.
Ну вообще что?
Ммм...
Ммм...
Вот есть у нас вершина вот этого, который вы отцепили.
Пойдем по обратным ребрам искать путь.
По обратным?
Если мы его, если мы путь никого не найдем, по дороге удаляемся, и вообще ничего не нашли, все такое.
Если мы дошли к какому-то дереву, к какой-то вершине, которая уже в дереве, коннектимся.
Если ничего не нашли, удаляем.
Сейчас откуда запускаемся, где запускаемся?
Ну сейчас, вот мы в вершине, в которой сейчас ведет удаленное ребро.
Мы по обратным ребрамам пытались найти путь до любой вершины, которая все еще в нашем дереве.
Если там, ну таким же алгоритмом, что и раньше, то есть если что-то не нашли, то удалили ребро.
То есть это другой дерево DFS, что ли строить?
Мы ничего не строим, ходим просто DFS.
Там же линкаты не будет.
Если мы все прошли, ничего не нашли, то можно удалить эти два ребра тоже.
Ну правда, если мы найдем путь, а этот путь окажется по обратным ребрамам, он не может отойти.
Дерево DFS, оно тоже слоистое, напоминаем.
Поэтому, в принципе, можно просто перебирать все входящие ребра.
А чего бы нет, кстати?
Я с оригинального видом был другой, лучше его расстоять, потому что...
А я не знаю, что с оригинального видом.
Нет, ну скажи так.
Нет, я смотрю, что с оригинального видом.
Есть версия вот у меня, она чуть другая.
Но по-моему, это чуть сложнее в том плане, что перебирать придется ребра входящие.
Я просто не могу перебирать прямые ребра, потому что они же могут нечаянно замкнуть что-нибудь.
Не могут.
Но если перебирать из случайного места...
Нет, смотри.
Не, а чего случайно?
Нам нужно первое попавшееся живое ребро.
Оно из какой-то из этих вершин.
Да.
Поэтому, собственно, это под деревом будет просто переподвешено.
Эти заведомо выше...
Откуда, куда?
Ну, сюда.
Откуда-то...
То есть даже обратные ребра перебираем?
Ну да, по сути, да.
То есть, по сути, такая модификация...
То есть получается даже алгоритм такой.
Вообще совсем не совсем динец получается.
А, действительно, то есть метод такой.
Один раз запускаем, ну там, строим какой-нибудь подобного рода дерево.
Запихиваем его в ленка.
Естественно, эскорень.
И дальше говорим следующее.
Так.
Ну вот.
И дальше можно говорить примерно следующее.
Вот.
Что...
Ну, давайте, значит, если, значит, Т у нас является потомокрест,
значит, берем, за алгоритмом находим минимум.
Угу.
Значит, да.
Значит, делаем, так сказать, это...
Проталкивание потока, это, называется, на пути отложенное.
Да, после этого, конечно, верим вообще, как это вообще.
Но идея очень простая, на самом деле.
Потому что, ну, то есть у нас есть, там, понятно, будут какие-то условные сплои деревья.
В них мы умеем делать отложенные операции.
Просто внутри вот этого пушдауна, на самом деле, просто прописываем, что там...
Внутри пушдауна мы еще там прописываем, что надо, вот конкретно у этого ребра, действительно, там, протолкнуть какой-то поток.
Еще одно.
Так, это понятно, о чем я говорю, да?
Ну да.
Ну, то есть, там, в каждой вершине хранится, что у всего под деревом, там,
то есть, у всего под деревом, у всех ходящих ребра надо припихнуть еще вот такой вот поток.
Только вот пока они еще...
Все под деревом, а это же, правда, не обратно, на пути.
А мы же говорили, откуда мы...
Да, ну, поэтому, ну-ка, да, ну, как бы, до этой пусистой сплои деревья у нас сейчас будет.
Поэтому мы в оконне пишем, дорогие друзья, во всех вот этих вот ребрах, значит, надо такжественно...
Просто операция на пути, короче.
Ну да, действительно.
Но, правда, единственное, надо проследить, что если там...
Ну, там...
Ну, в принципе, да.
То есть, операция на пути отложена.
Ну, там, да, возникают, короче, маленькие, там, все какие-то технические тонкости, там,
в какой момент конкретно, там, надо удалять во всех пушдаунах, там, что-то.
Ну, просто иногда ребра могут поменяться.
Ну, в общем-то, поменяются они когда?
Ну, потому что, очевидно, чтобы найти, как бы, какое ребро насытилось, надо найти минимум на этом пути.
И его у нас это поддерживает.
Значит, нашли этот минимум, протолкнули и торжественно его удалили.
То есть, что значит удалили с точки зрения линката, это означает, что мы вот эту вершину от этой вершины...
Да, отрезали.
Ну, потому что, конечно, эта вершина родитель.
Поэтому ее...
Ну, вот, отрезали.
Ну, там, сохранив, конечно, вот эту отложенную операцию, там, со всеми людьми.
Ну, это понятно.
Ну, и теперь мы просто перебираем ребра опять...
Ну, там, скажем, берем просто...
Там, перебираем, смотрим опять ребра ведущие из этого слоя.
Из какого?
Из предыдущего.
У нас других ребра нет, в принципе.
А если оно будет вот сюда?
Куда сюда?
Какую-то нашу вершину уже...
А мы их удалили, помните?
Почему?
У нас только... у нас только... у нас в игре сейчас только ребра слоистой сети.
Да, ну, сейчас почему?
Вот, можешь тыкнуть пальцем на слой, из которого мы сейчас будем искать ребра?
Почему она не может быть в вершину следующего слоя?
А, ну, потому что я имею в виду следующее.
Мы отдельно для каждой вершины будем хранить список не только исходящих ребра, но и входящих.
И что?
Ну, тогда, когда мы удалили это ребро, вот для этой вершины мы можем взять следующее ребро, скажем, входящего.
Почему мы?
Это первое попастье.
Потому что, напоминаю, мы сохраним, мы связываемся.
Я не понимаю алгоритма.
Я не понимаю, что мы вообще делаем.
От кого мы куда идем?
Что ищем?
Ну, сколько удалили ребра?
Вот мы удалили ребра.
Так.
Я вообще перестал понимать, откуда мы после этого что-то запускаем.
Мы ничего не запускаем.
Мы...
Причем тут предыдущие...
Мы...
Мы говорим, что в каждой вершине мы храним ну, связанный список входящих в Нью-Йорк слоиста сети.
Без проблем.
Это так раз.
Еще мы храним некое мистическое дерево.
Которое скорби влез, которое дотягивается до всех вершин, на которых вообще можно дойти.
Ну, там понятно, что есть какие-то вершины, так только уже дойти нельзя, но, естественно, их в дереве.
Вот.
Значит, мы говорим, пока в этом дереве есть мистическая вершина Т, мы говорим следующее.
Значит, возьмем путь этот от С до Т в дереве.
Найдем в нем минимум.
И, собственно, ровно такой поток мы пропустим.
Отложенная операция через сплей дерева.
Значит, найдем тогда кто-то из этих минимумов превратился в ноль.
Найдем этот ноль.
Удалим это ребро.
Можно его даже стереть.
Да, можно его даже стереть.
Дерево перестало быть деревом.
Да, дерево перестало быть деревом, потому что вот у этой вершины, то есть теперь вот эта вершина стала пока самостоятельным портом.
Да.
Хочется ее переподвести.
Для этого, то есть, напоминаю, у нас был.
Да, был двухсвяз для список ребра, как помните.
Из которого мы только что это ребро ударили, да?
В этом двухсвязном списке, наверное, еще остались ребра.
В лучшем случае остались.
И тогда, если тут какое-то ребро нашлось, то, собственно, мы также это ребро, так сказать, добавляем в линкар.
Ну, в смысле, подвешиваем эту вершину уже к этой, имея в виду вот это ребро.
Заметьте, за вот единицами.
Ну, в смысле, за логоритм.
Она обязательно найдется?
Нет.
Вот, да, есть одна, конечно, маленькая приятная мелочь.
Как говорится, ребра в вершине могут и закончиться.
А, подожди, она может и не закончиться, но просто вести в эту вершину, которая нет в линкаре?
Или не могла?
Так.
Ну, такое-то оно.
Так.
Да, действительно.
Хотя...
Если она ведет в вершину...
Ну, хотя, да, такое можно.
Но, с другой стороны, тогда такие ребра мы просто сразу игнорируем.
Не лежит в линкаре? В смысле?
Потому что я утверждаю следующее.
Мы же поддерживаем вариант, допоминаем, да?
Что в линкаре у нас сейчас одно дерево с кординамбес, и в нем лежат все вершины, до которых еще из СПАста отыкали.
А, если так, то хорошо, да.
Вот можно дойти.
Поэтому остальные вершины прям помещены, что они уже плохие.
То есть изначально линкат инициализируется деревом БФС?
Да.
Хорошо.
Вот.
Ну, или даже деревом БФС.
Кстати, сразу боже, что было бы.
Да, да.
Ну, в данном случае, да.
Ну, просто как-то за хер.
Вот.
Но теперь, если, соответственно, в какой-то момент это произошло,
значит, у вершины кончились ребра.
Да, ну, лишнее удаление ребра, конечно, перестало быть совсем золотой идеей,
но удаление ребра все равно,
когда его удаляется за единицы,
поэтому у откиньи суть.
Но если вершина...
Значит, в вершине все плохо,
то что мы делаем?
Ну, тогда, естественно, мы объявляем ее...
Теперь ее объявляем плохой.
Ага.
А-а-а.
Вот, и, как говорится, и у вершины, и ко всем ее детям
называется, примеряем.
Вот это все мероприятие.
Пусть у нее был ребенок,
может ли у нее быть ребенок,
в который сейчас не ведет из нее ребро?
Ну, конечно, может,
потому что мало ли в чем проблема.
Теоретически...
Сейчас, так, дерево перестало быть деревом?
Нет, почему не перестало?
Если вот эту вершину мы убили,
и вот это ребро, а эту вершину переподвесили сюда,
то достало дерево.
Нет, это не об этом.
Может ли у нас из только что вершины,
которую мы хотим забанить,
которая сейчас, ребро,
которого сейчас нет для Кати?
Э-э-э...
По поводу теоретики...
Сейчас.
Теоретически такое вполне может быть,
потому что может быть у нее теоретически еще
ведет ребро в какую-то вот такую,
но при этом эта вершина находится...
Тогда мы с этой вершиной ничего не делаем вообще.
Да, нет, мы ничего не делаем.
Нет, у нас как бы проблема только одна,
что удалив эту вершину, у нас вот новые нетривиальные кости.
Понимаешь, да?
Дети...
То есть появились ее, соответственно, дети в линкате.
Вот.
Ну вот.
Появились ее...
Появились, соответственно, ее дети в линкате.
И, значит, для этих детей
мы просто сделаем абсолютно то же самое
рекурсивно.
Да, то есть слои, кстати, приятны тем,
что там зациклов не получится
автоматически.
Потому что мы все равно будем подвешивать к предыдущему слою.
Но если не подвесилось, то там дальше
рекурсивно, рекурсивно, рекурсивно.
Вот.
Так что вот такая
получается красота.
Вот.
Ну и за какую симптомику тогда
это получается?
Вместо В.О.
Ну да, то есть по сути, да.
То есть заметим, что проталкивание пути у нас
теперь получается вместо
В получается
логарифом В.
Правда, единственная оговорка, что у нас
есть вот эти вот каскадные вырезания, так сказать.
Ну и что?
Они в сумме там будут получиться.
Ну ладно.
Сейчас.
Погодите.
Давайте подумаем.
За какое время?
То есть когда мы удаляем вершину, мы тут пробегаемся
по ее детям. Вообще один маленький вопрос,
как в линкате найти по вершине ее детей
и хранить?
Ну да, в данном случае можно в тупую хранить.
Это не проблема.
Вот.
Да, это каскад.
В общем случае в линкате, кстати, у вас не получится
это делать, потому что в линкате еще есть, помните, при подвешивании
в другом кофе.
Но слава богу у нас единый корень на этот раз.
Нет.
У нас подвешивание только корня к чему-то.
У нас нет реверсов.
Да, у нас так, реверсов нет, направление все
в одну сторону, поэтому в данном случае
для каждой вершины тоже двух связных список
при желании хранить можно, если очень хочется.
Но вопрос в другом.
Просто пройтись по реверсам из вершины
еще не убитым.
И проверять, является ли это ребенка в линкате.
Это же не страшно.
А, ну один раз
можно и пройти.
А, ну с другой стороны теперь заметимся, да.
Просто кажется, что все равно этих реверсов может быть даже детей много.
Скажем, что-то надо делать.
Ну и что?
Ну с другой стороны заметим, что
вот.
Но здесь теперь можно заметить, что
условно говоря, можно считать, что удалив вершину, мы
каждый из этих ребер удаляем
и виртуально у нас получается, что
каждое конкретное удаление работает
за, ну что-то типа.
Ну там в сумме получается E log V.
Потому что мы прикажем удаление
ребра, либо за log V
переподвешиваем вершину в чему-то.
Либо выясняем, что все закончилось
и сводим задачу к удалениям
еще каких-то ребер.
Поэтому получается, что у нас тут получается E log V
и здесь асимплуатика получается
V E log V.
Вот, слушайте. Да, красиво.
Можно еще раз напомнить,
с чего мы построили инкад?
С чего мы начинаем?
Мы просто говорим, так, жила была
декшина T, и выяснилось, что
декшина T еще не удалена.
Изначально дерево, помнишь, что?
Нет, нет, мы сделали инкад.
Изначально мы его построили как дерево DFS.
То есть достижение у него
все вершины достижены.
Пока T не объявлено
удаленной вершиной,
как только она удалена, значит все.
Пока она не удалена,
берем путь от S.
Находим минимум пропускных способностей.
Мы можем найти
меню,
само ребра.
Да, хорошо.
Сплей дерева такие вещи
поддерживает.
А алгоритм не рассчитан на то, чтобы
выписать. Честно-честно.
Ну, как сказать, мало вещей.
Ну, а что, инкад проблема?
Ну, не знаю,
просто вы инкад храните минимум
восстанавливаете,
где он находится,
это внутри сплея делается.
Случай, когда у нас больше
ребра из вершины
можно повторить.
Да, вершины некогда.
Мы идем в ее детей,
смотрим, нет ли из них ребра.
Мы ее удаляем.
Если выяснилось, что в нее
подходящих ребр нет, то мы ее удаляем.
Что значит мы ее удаляем?
Мы удаляем все ребра,
ведущие из нее.
И потом идем
и дальше
и пустим.
У нас есть мистическая функция
удалить ребро.
Которая работает так.
Значит, удалить ребро.
Значит,
удалить ребро.
Ну, имею в виду инкад.
Мы говорим, что если у нас есть
еще хотя бы одно входящее ребро,
мы их за вот единицы понимаем,
то мы смотрим.
Но если оно из удаленной вершины,
то мы его тоже быстренько
игнорируем.
И вот, но если оно
ведет не из удаленной вершины,
то, соответственно, мы в этом месте
просто подвешиваем эту вершину
к этой линкате.
За это ребро так вот вес сохраняем.
И заканчиваем работу.
Если в процессе выяснилось,
что ребра нет,
то
тогда мы перебираем,
во-первых, мы объявляем эту вершину
удаленной.
И значит, перебираем
все еще живые ребра из нее.
И для каждого из них рекурсивно
вызываем удаление ребра.
Все.
То есть мы блокирующий поток
находим за логарика ВВ
Е, плюс В, плюс Е.
Ну,
Е хотя бы В.
Ну, скорее Е, потому что на самом деле
Е обычно больше В.
Ну, в данном случае, тем более, что мы можем
игнорировать все вершины, которые ДФС не дотянулось.
Вот, поэтому по факту здесь
так что получается такая красота.
То есть все это делалось для того, чтобы
проталкивать путь за логарику.
А не за В.
Каждый раз мы ищем ребра из предыдущего слоя.
Да.
То есть мы из последнего, на котором
мы объявляем.
Ну, да. Ну, у нас в слоистой сети есть
только вообще ребра из предыдущего слоя, в принципе.
Других ребер у нас нет.
Такое вопрос, что они могут вести из удаленной вершины
или не удаленной вершины.
Вот. Нет, ну вот.
То есть, на самом деле, честно,
ну ладно, я все-таки встал. У меня была, на самом деле,
версия немножко другая.
То есть у меня была версия тоже
ранее в линках, но корнем является
не С, а Т.
То есть это будет сейчас уже ближе к
реально алгоритму Диница.
Ну, потому что давайте вот
если мы вспомним, да, вот был у нас такой
алгоритм минут 20 назад, да.
Вот.
Значит, смотрите.
Работал он примерно
следующим образом.
То есть вы помните, да, мы запускали
ДФС, но ДФС заметил,
но как был устроен ДФС?
Он был устроен так, что
соответственно, если мы в прошлый раз
ДФС, значит, закончил свою работу на вот этом
ребре, то следующий
ДФС начнет работу в этой вершине
именно с этого же ребра.
Помните, да?
То отсюда вытекает две вещи.
Во-первых, реализационная.
Вот это я забыл сказать, но это важно.
Вот мы тут говорили, что мы реализовать
алгоритм Диница, надо там это всё
научиться там удалять
ребра, потом восстанавливать
двусвязный список, да.
Так вот, на самом деле, всего этого не нужно.
Потому что на самом деле,
вот если так внимательно
посмотреть, то мы говорим, что если
у нас до вершины фиксировал порядок
ребр, в котором мы её рассматриваем,
то по сути у нас в каждый момент времени
удалено несколько первых ребр.
Если какое-то ребро ещё не удалено, то ДФС
будет ходить по нему, пока это ребро не удалится.
В результате
можно вообще в реальности
ничего не удалять,
а просто в каждой вершине
хранить там какой-то указатель
или индекс, или вот в нашем случае
итератор, вот как мы в прошлый раз писали, да.
Начиная с какого момента ДФС
должен работать.
Если ребро удалилось, если у него всё плохо,
то удаление ребра
тогда делает очень просто.
Итератор плюс кузов.
Ну или в нашем случае итератор точка Н.
Вот, да, конечно.
Нехорректно говорить слово
итератор к тому, что мы написали.
Хотя нет, в джаве корректно.
В джаве они именно так сделаются.
Интерфейсно.
То есть, заметим, что теперь
при такой технологии,
когда в каждой вершине
мы просто,
когда мы храним просто итератор,
можно даже слоистую сеть отдельно не строить.
А в реальности
просто сказать следующее, что
давайте просто храним все ребра
из каждой вершины у нас есть список
смежности, просто всех ребр, которые вообще
теоретически есть.
И просто внутри ДФС говорим, что
первое, что проверяем, а это ребро из
слоистой сети вообще.
То есть, если нет, то его тоже, значит, итератор
плюс-плюс регулирует.
То есть, в результате
никаких этих там
двухсвязных списков не надо.
То есть, в результате там получается
корр достаточно минималистично.
Маленький ДФСик, маленький ДФСик.
Ну и всякие пуши, конечно.
И более того, кстати,
еще отметим, что на самом деле
есть еще такая модификация этого алгоритма
такая, ну не очень понятно
по синтетику, но
существует тесты капиллёвичей, на которых
классический динец не работает,
а с этой модификацией почему-то начинает там просто
летать за какие-то дни секунды.
Суть заключается
в следующем.
Вот смотрите, вот вы нашли путь
Это с линкатом или без линката?
Не, без линката, без, без, без.
То, что я сейчас говорю, это без линката,
хотя как бы тут с линкатом это...
Ну тут вот без линката.
Значит, смотрите, помните, у нас был устроен ДФС.
Да?
И вот, допустим,
и вот мы
нашли какой-то путь, по которому
наконец можно что-то припихнуть.
И было тут, допустим,
допустим, я не знаю,
19, 12,
15, 3,
ну и допустим все.
Так вот, идея заключается в следующем.
Что может быть вместо
того, что... Вот смотрите, ведь ДФС
он в любом случае первое что сделает,
это пройдет по этим ребрам, и только с этой вершины
начнется какой-то нетривиальный путь, правда?
Так вот, идея на самом деле
такая тихая. А давайте просто, когда у нас есть
ДФС, мы храним, сколько мы
по уже набранному пути можем
припихнуть воды.
А мы всегда что-то делаем?
По умолчанию мы находим путь, потом
по нему проходим себя... О господи.
По умолчанию, да.
По умолчанию, да.
То есть в данном случае мы храним,
что по этому пути можем протолкнуть
в 12.
И теперь вот мы протолкнули 3,
это означает, что мы в принципе с этой вершины
можем еще протолкнуть 9.
И давайте вот по этим ребрам будем собрать.
Вот если мы тут встретили,
то есть допустим какой 5,
и нашлось тут еще 5, то значит мы протолкнули
еще 5 единиц потока, и осталось
4.
Но если тут еще
нашлось, и тут допустим нашлось
ребро, по которому можно протолкнуть
7,
то тогда мы...
Но тут уже ситрость. Теперь мы в рекурсию
передаем здесь все-таки 4.
Потому что мы больше не можем.
И если там удастся
это 4 так-то распихать,
так или иначе,
ну потому что может повезет, а может
ДФС будет на самом деле теперь возвращать, а сколько мы реально
припихнули, может получиться меньше.
Так, это понятно, о чем я говорю?
Вот, ну понятно.
Вот.
То, соответственно, тогда тут придется скажем,
что все, 4 протолкнули, больше нельзя,
значит откатываемся, говорим, что
до сюда мы могли
дойти за 12, ну теперь вместо 12.
А мы...
А, мы здесь, конечно, не забываем.
А мы Форд и Фалкерсона не так писали?
Что? А мы Форд и Фалкерсона не так писали?
Нет. Просто гораздо короче получается.
Ну, вообще да.
Но Форд и Фалкерсона мы не так писали.
Нет, мы предлагали, чтобы нашли
нашли путь в протолкнули, все.
Но это вот важный оговор.
Да.
Особенно такой же этот есть, и он периодически
очень хорошо работает.
Ну а симпточки формально говорят так же.
Это понятно.
Формально так же, но почему?
Можно еще с пускпистами
о двойке написать отдельно?
Нет, нет, так. Ну, во-первых,
масштабирование это для творчественных сетей,
это отдельная большая тема.
Кстати,
может масштабирование для творчественных сетей?
Верно ли, что можно
не для творчественных сетей
с помощью масштабирования искать просто приближение
с кого-либо на большой ад.
Залог там...
Ну, с Лёдом скажу, что да.
В некотором смысле, да.
И думаю, мы в этом сегодня увидимся.
Так, ну,
да, не сейчас, у нас там до конца пары,
10 минут осталось.
Вот, значит, поэтому давайте
доразберемся с Винейцем.
Этому вот мы поговорили, значит, как писать
этого Диница, что на самом деле легко
пишется. Вот.
Ну, а теперь, значит, осталось только рассказать, значит,
какая лично у меня тут версия сленка.
Ну, действительно, для...
Ну, вот у вас версия достаточно хорошая,
но она требует, чтобы вершины
хранить из список исходящих рыб
и список входящих рыб.
Так вот, я же предлагаю именно модифицировать
алгоритмом Диница следующего.
То есть, можно сказать, что
вот рассмотрим
эти ребра, на которые в каждый момент времени указывает
итератор, да?
И теперь, давайте я скажу,
что именно эти ребра
мы будем, на этих ребрах
будем строить ленка.
То есть, это будет ребро
дерева, подвешенное уже к вершине
Т, а не к вершине С.
Потому что
из каждой ребра ведет одно, а в
каждой, из каждой вершины ведет одно ребро,
а ведет в не одно. Окей.
То есть, раньше
вы говорили, что у нас предки слева
тут справа, а у нас будет
из вершины С,
они все устроены и так далее.
То есть, это
актуальные ребра, на которые указывает
итератор.
Все более того, в этом месте на тему удаленных
вершин даже клюем, потому что если
из вершины не осталось ребр, ну значит,
условно.
Условно может быть не с инфа.
Хотя нет.
Вот теперь давайте, как модифицируется алгоритм
Дениса?
Он говорит так.
Если у вас из вершины С
корень Т,
то значит, находим путь
и удаляем ребро.
Как мы его удаляем?
Как и ранее.
То есть, как и ранее. Находим минимальное
ребро и удаляем его.
Что значит удаляем? Ну сдвигаем в нем
итератор и пытаемся переподвести.
То есть, как только найдем очередное ребро,
ну подходит что?
То есть, ведет следующий слой
и
не расстричь.
Это тоже важно.
Ну вот. И соответственно,
находим такое ребро и просто объявляем
нового родителя. То есть, тут переподвести.
Есть у нас есть два ребра
одинакового веса. Нужно ли нам
в этом задумываться? Или
в какой-то момент мы потолкнем нулевой поток
и забудем?
Не-не-не-не-не.
Смотрите, если вы будете протолкнуть нулевые потоки,
у вас полетит ассимпотика.
Нет. Потому что каждый такой нулевой поток
означает, что какое-то
ребро было должно быть выстрелено раньше,
но сейчас мы его удалим, как бы запоздало.
Может быть.
Но я бы на всякий случай так не делал.
Просто тогда иначе нужно в линкате
писать функцию, которая возвращает
список минимума.
Какой список минимума? Ну вот.
Пусть у нас на одном. А, в этом?
А, понял, понял.
А как он сам отработает?
Нашли какой-то минимум из всех.
Что дальше будет?
Ну, смотри, утоление ребра – это
сдвиг итератора, и сдвиг итератора у нас
по-любому есть.
Ну вот.
Ну и каждый сдвиг итератора работает
за логорифом, потому что он либо
переподвесит вершину, либо
скажет, что плохо пойдет дальше.
Ну так, получается
никаких проблем нет.
Но окажется, что в какой-то момент
да, в какой-то момент может так случиться,
что мы по пути притолкнем поток величины
боль.
Но оно просто пройдет куда-нибудь.
Но правда есть та же оговорка,
что и у вас.
Что делать, если в какой-то момент
выяснится, что
от вершины С
до вершины
дойти нельзя?
Корень тут оказался другой.
Как?
Как? Или надо было просто
переподвесить к соседней вершине?
Нет, сейчас, это в какой момент произошло?
Если наш алгоритм вот сейчас
ищет, есть ли ССП путь его нет,
то все плохо.
Все хорошо, значит, что пути просто нет.
Но когда мы удаляем ребро, нам конечно же нужно продолжать.
Ну да.
Нет, ну теперь нет, просто оговорка такая,
что если у вас встретилась такая ситуация, значит,
что надо удалить вот это ребро.
Ну вообще говоря, алгоритм двигается,
надо удалить вот это ребро.
Причем плевать сколько там потока,
главное его удалить.
Главное его просто найти,
и дальше делаем то же самое.
В каком случае?
Если выяснилось, что у С,
корень дерева, в котором находится вершина С,
не оказался П.
У нас был путь из С в Т.
Мы удалили ребро на этом пути.
Что мы дальше делаем?
Подвигали итератор,
нашли подходящее ребро,
и переподвесили эту вершину
согласно ребру.
Все, теперь корень Т.
То есть у нас нет никаких ситуаций,
когда корень не Т.
Когда этого ребра мы делаем?
Когда мы что делаем?
Ну, с предлагаемой точки зрения,
когда мы делаем,
ну, с предлагаемой точки реализации,
останавливаемся.
Останавливаем эту итерацию.
Некуда переподвесить,
значит не переподвесить.
И тогда у нас может произойти...
Или есть вариант,
что можем прямо рекурсивно,
что если не нашлось, значит давайте удалить это ребро
и повторяем операцию,
пока не переподвесится.
Хотя это тоже не безопасно,
потому что на этот раз может так случиться,
что в какой-то момент,
когда вершина была подвешена вот этой,
и мы удалились и подвесились вот так.
А проблема?
Ну, просто проблема в том,
что все равно нам придется рассматривать случай,
когда есть путь от С до куда-то.
То есть он ведет не куда-то,
но это еще не означает что-то.
То есть фактически нам бы тоже нужно было
хранить обратные ребра,
но мы этого избегаем.
Ну да.
То есть все, что нам теперь нужно,
это хранить опять.
Какой...
Ну хотя...
Да.
Ну нет, хотя нет.
Можно не хранить.
Ну да, можно не хранить,
но тут надо просто уметь.
Тогда вам придется просто в линкате говорить,
что у вас есть С, есть его путь до корня,
а скажите, пожалуйста,
какое там последнее именно ребро было.
Вот вас очень попросят.
Такую оговорку придется делать.
Ну поэтому я говорю, что раз это все равно придется делать,
тогда лучше, мне кажется,
если от вершины уже все ребра кончились,
то давайте лучше вместе интеракцию остановим.
То есть делаем это
мы фактически, то есть пока...
Ну условно, пока не выяснится,
что у С кончились ребра.
И таким образом мы узнаем,
что нам нужно зачерпывать вершину.
И не нужно хранить обратные ребра.
Ну да, да, да.
Ну и более того, практически мы...
То есть по сути, на самом деле, что вот этот алгоритм,
он ближе к алгоритму Тинница, мне кажется,
чем модель.
Хотя как бы суть более-менее та же.
Ну вот.
Можно повторить?
Может С, Н, К, Т, К, К.
Так. Какую из Н, К, С?
Ну по-моему, которая последнюю упрещена.
Значит, смотрите, идея такая.
Значит, идея такая.
Значит, назовем ребро...
Вот, вообразим себя алгоритм Тинница, да?
Как мы уже сказали, в каждый момент времени
у каждой вершины есть интератор,
который указывает какое-то ребро,
которое ДФС будет сейчас рассматривать, да?
И идите дальше.
Так вот, назовем это ребро актуальным.
То есть у каждой вершины будет
актуальное ребро.
Ну, не более чем одно.
И вдоль этих ребер построим дерево.
Причем на этот раз более правая вершина
является родителем более левой.
Ну теперь мы говорим, что
то есть у каждой вершины есть актуальное ребро,
которое ведет куда-то вправо, да?
Если объедините все ребра,
получится
подвешенный лес.
Ну вот. Причем именно лес.
Не гарантирую, что именно дерево.
Причем более правая вершина будет всегда
родителем более левой.
Да, то есть теперь у нас как бы это...
Ну вот. И единственное еще ограничение
мы будем сразу считать, что из вершины Т
есть вершины С,
но они нам не нужны.
Так вот. И дальше говорим.
И говорим, пока у нас в вершине С
не кончится игра.
Кстати, это не обязательно. Можно считать,
что из вершины Т есть пути, потому что тогда у нас
сработает ИВ, что из С корень не Т
и мы удалим эти проблемы.
Сейчас то есть...
Ну, короче, и так сработает.
Не сработает.
Там может так случиться, что пути теоретически есть,
но параллодификации надо привести.
Нет, пусть из Т
у нас что-то есть, лишний путь
из Т.
Корень тогда дерева не Т.
Ну, корень дерева
с Т всегда Т.
Вот если нет, то это не страшно.
Что он просто удаляется.
Лучше не надо, потому что
если у вас там из Т путь еще идет куда-то дальше,
то тогда вы рискуете делать
лучше по этим ребрам, а вам,
Боже мой, по сей вам это делать.
Короче, не надо.
Ладно, нормально. Так что лучше не надо.
Т корень.
Да, Т всегда корень.
Так вот, алгоритм устроен так.
Пока у нас из С есть актуальное ребро.
Вот давайте я так скажу.
Мы говорим так.
Скажите, пожалуйста, мы узнаем,
кто является корнем
у вершины С.
Если является Т,
значит мы берем этот путь от С до Т.
Мы и так уже эксполс вызвали.
Значит берем этот путь.
Находим на нем минимум.
Проталкиваем на нем минимум.
А также находим этот минимум
и мы обнаружим, что этот минимум должен быть удален.
Потому что насыщенное ребро.
И в этом месте
мы вызываем функцию
удалить ребро.
Вот у нас такая мистическая функция
удалить ребро.
Чуть позже расскажу, что удалить ребро.
Второй случай.
Если выяснилось, что С,
корень у дерева с вершины С,
не Т.
Это означает, что ДФС
бы тут шел-шел-шел и уткнулся бы сюда.
Следовательно, надо удалить
просто последнее ребро на этом пути.
То есть по сути теперь мы вызываем
функцию удалить ребро
уже от вот этого ребра.
И теперь, что делает функция
удалить ребро?
Делает она следующее.
Мы говорим, что мы хотим удалить это ребро.
Это означает, что эта вершина
перестала быть
ребёнком этой вершины.
Хочется её куда-то переподвести.
Что мы делаем?
Мы помним, что это ребро было активным.
Помните, на него итератор указывал.
В соответствии с алгоритмом Диницы
мы двигаем итератор дальше,
перебираем ребра,
игнорируем ребра, которые нам не подходят.
Нам не подходит ребро,
которое не лежит в слоистой сети
или которое насыщено.
Откуда у нас может быть насыщенное ребро?
Как я уже сказал,
реализация с итераторами позволяет
вообще не удалять ребра.
Мы тут говорим о слоистой сети,
но в реальности у нас в списке ребр
фиолетовые тоже жирные.
Насыщенное ребро в слоистой сети
уже убили, согласен.
Хотя ещё насыщенные ребра в слоистой сети
могут оказаться...
Да, ещё может быть так,
что так как на каждом пути
может быть удалено не одно ребро,
а на самом деле несколько,
то мы удаляем только одно.
Потому что если у нас там есть
где-то второе, допустим,
то в какой-то момент у нас просто появится
актуальный путь от СДТ,
и мы просто найдём это ребро и удалим.
Просто протолкнув поток
величины ноль.
Так вот, удаление ребра
в качестве ИФА
лучше сразу написать,
что это ребро из слоистой сети
и оно не насыщено.
Скажем так, может быть так,
когда вы запускаете BFS,
может быть так, что отсюда-сюда
ведёт ребро простой способности ноль.
Так может случиться,
поэтому это обязательно надо проверять.
Так вот.
И чем это заканчивается?
Ну вот, и тогда
если вы ребра в соответствии с алгоритмом Дениса проматываете,
как только находите ребро из слоистой сети,
которое не насыщено,
то вы просто тогда
в этом месте объявляете, что вы эту вершину
теперь подвешиваете
к этой вершине.
Ну там меняете, естественно, вес
на крупную способность
вот этого ребра.
Какой вес? Я с кого меняю?
У каждого повода.
В линкате у нас вообще-то
вес вершины есть, помните?
В линкате
мы вообще-то ещё как-то минимум
на пути ищем.
А минимум чего?
Как мы это делаем?
По умолчанию в линкате
веса в вершинах находятся.
Мы сопоставляем вершине
вес ребра исходящего из неё.
Периодически приходится его менять,
но это линкат умеет.
Вот.
То есть, соответственно,
переподвесили, остановились.
То есть, на этом заканчивается функция
удалить ребро.
Заметим, что сама по себе функция
удалить ребро работает за от
количества удаляемых ребер в суммарной орге
плюс логарифом на подвешивание.
А, ну и важная оговорка,
что ещё может так случиться, что
из вершины ребра всё, просто
ребра кончились.
Так что функция удалить ребро
завершает свою работу.
Ну, также, если она объявит, что из этой вершины
актуальность ребра больше нет.
Вот и веселый.
Так что вот ради чего
в этом месте лекции появлялся линкат.
Так что вот такая красота.
Вот.
Ну, сразу скажем, что, значит,
последнее, что тут скажем, мы сейчас
заметим, что алгоритм Диница
это только первый алгоритм в концепции
блокирующих поток.
Вот.
Ну, то есть, на самом деле, дальше,
первым исторически алгоритмом, работавшим
ЗВК, стал просто алгоритм Карзанова.
Ну, как-то фамилия можете догадаться, да.
То есть, конкретно эти разработки проходили
по нашу сторону железного занавеса.
Да, это очень забавно, да,
потому что в этой науке с другой стороны
что-то происходило. Правда, алгоритм
Карзанова, нельзя сказать, что
прям очень хорошо он публикован.
Там просто такая забавная ситуация
произошла. То есть, он его
опубликовал в виде, то есть, на очередной
конференции какой-то там под эгидой академии
наук СССР. Да, дело в советские
времена было, естественно.
Вот. Значит, он там просто вышел и вот
зачитал доклад на тему того, что вот тут
на самом деле каким-то образом можно попихать-попихать
и, короче, найти поток злоку.
То есть, там вот это все, что там как-то
зубы в квадрате делали.
Вот. Примерное описание этого алгоритма
в итоге есть там где-то у Тарьяна.
Не помню, где, вот я помню.
То есть, сейчас все, что мы
лучшее, что мы смогли сделать,
это V...
А, это E лог В мы смогли сделать.
Ну, сейчас мы сделали В Е лог В.
Нет, просто E лог В.
Ну, Е лог В на... Ну, позвольте, а у него
В квадрат. А у него в квадрат.
Ну, понятно там, с оговорками,
что Z, естественно, мы уживаем В квадрат,
в этом месте я оставляю упражнения,
как добиться того, что...
То есть, там...
Как сделать сжатие
всех кратных ребер, причем даже
не за В квадрат плюс В,
а за В плюс Е.
А, проблем. Почему?
Именно за В плюс Е.
Вот смотри, как сжать все кратные ребра.
Вот дан какой-то хал, у тебя
накиданы ребра в родном порядке.
Что-то в мак все сложить.
Анордерд.
Хэши.
Что хэши? Я обожаю хэши.
Я что, зря анордерд мэп писал?
Нет, ну...
Это другой предмет.
Это другой предмет.
А если без хэши?
Мы не любим хэши.
Ну, кроме как когда мы там изучаем какую-то
какую-то...
Когда я хэши изучаю, тогда люблю хэши.
Когда изучаем, да? А без хэши слабо?
Нет, может быть, зачем?
В общем, первое упражнение подумайте.
Вот, на самом деле несложное решение.
Вот.
Значит, соответственно
так вот, после того, как сжать все не превосходит в
в квадрат, поэтому в этом
смысле бы кукла сошел.
Можно посортить пару. Это долго и логично.
Так.
Ну, да, посортим.
Посортим с этим, господи,
подшкотом. Все.
С сестренков и ребра подшкотом.
Ну, ради к сорту, на самом деле.
По второй вершине, потом по первой,
и кратые ребра будут идти подряд.
То есть повесить там обыску. И обязательно.
Вот. Так что...
Хорошо. Вот.
Получается в квадрат. То есть далее
далее... Ну вот. Ну в итоге
произошла забавная ситуация,
потому что с другой стороны образовались такие
ученые, как Малхотра, Умар и Мохишвари.
Да. В общем, это, наверное, вот.
И предложили статью, просто вы ее можете там
при желании легко нагуглить,
при желании. Но это при желании
не обязательно даже.
Ну, вот. Статья на две страницы.
Ну, буквально.
Ну, в смысле, две страницы А4.
Ну, правда, вот таким вот мертвым шрифтом
две колодки.
Из которых там полторы страницы,
там где-то, ну, во-первых, там что-то
Саглавия, авторы, там ссылки
в литературу, описание там истории
и вопрос, что там был это, был Форкмахерсон,
там бла-бла-бла. Вот есть Денис, вот, который
вот сделал вот это вот. Так вот.
Там был еще Корзанов, но там что-то непонятное.
Так вот, мы предлагаем на наш взгляд более
простое алгоритм ЗВК.
И там буквально на полустранический четко
описано.
Так вот.
Так что при желании можете даже нагуглить.
Причем алгоритм так называется, алгоритм
Молхотри, Кумани, Вахишвари.
Да, это точно фамилия.
Да, эти фамилии очень простые для мирового
сообщества, поэтому он не называется
алгоритм трех индусов.
Соответственно,
то есть алгоритм методинца
круглозаваранжева-розарева, это очень
сложно. Или там этих двух китайцев,
я их уже не знаю.
Но это очень глотно. Но не суть.
Вот. Ну ладно, в общем, суть в том,
что, ну вот, на самом деле этот алгоритм
я рассказывать не буду, потому что он
у нас будет в домашнем интернете.
Придумайте его.
Там будет его название, чтобы загубить
можно было? Ну я вам сказал
Молхотри, Кумани, Вахишвари. Кто-нибудь писал?
А можно тебе на это сказать?
Нет, на самом деле нет смысла
его купить, потому что там в задаче
мне будет достаточная подсказка на то, что
на самом деле вы его просто приделаете.
Ты очень хорошо мнения,
спасибо.
Вот.
Ну вот нет, тут как бы
индийские фамилии, они как слышат,
так и пишутся.
Так, вот эту букву я не
помню букву.
Или вот. Не помню букву.
Да, скорее вот эту, наверное.
Вот. То есть тут вот такая
забавная история произошла.
Вот.
Так что это вот, что еще хочется сказать.
То есть более того, насколько я знаю, тут я подробностью
уже так сейчас не поручусь,
но, возможно, чемпионские алгоритмы
поиска потока, кстати, да.
Кстати, чемпионом на текущий момент является алгоритм,
который работает за ВЭ.
А, не за ВК, все понятно, да?
Да.
Там не ВЭ, ГЕ, ЛОГ, ЛОГ, ДЕЛИК,
но ЛОГ, ЛОГ, ЛОГ, ЛОГ, ЛОГ.
Не-не-не, там по-моему в 15-м году ВГ.
А там, в общем-то, алгоритм, который приобретает
в куче случаев, где нас алгоритмы пихают в зависимости
от отношений ЭК, ВЭ и такого.
Может быть.
Как все последние алгоритмы придуманы в средних лет,
скорее всего, да.
В этом случае давайте хотя бы со стволами
разберемся.
Нет, ну тут нет как бы
эпического алгоритма.
Он работает за лучшую ассинтотику,
за которую вообще возможно искать астолы.
А что это за ассинтотика, наука не знает.
Что?
Что?
Существует, значит, в теории поиска минимальных
астолов, есть эпический алгоритм.
Значит реально.
И он говорит так, он говорит,
что он ищет миностол
за минимально возможную ассинтотику,
за которую
теоретически вообще можно искать миностол.
Но за какую не знаем?
Да.
Ну там какие-то там деревья решения
как-то аккуратно построены.
О господи.
А его можно использовать?
Наверное, можно.
Нет, ну я не знаю,
с точки зрения практики, как бы есть алгоритм
Чизеля на основе софтхипа.
Который работает за Е
на обратную функцию атервана.
Очень-очень круто, вау.
Точно да.
Хотелось бы его изучить,
а то зачем мы софтхип изучали.
Вот.
Так что это вот что хотелось сказать
о концепции плотивающих поток.
Хотя, конечно, оно вот.
Ну, как вы сказали, это один метод.
У нас будет альтеркотинная концепция.
Концепция известного уже
полюбившегося нам американского математика
Эндрюга Чеснаупера.
Обожаю его.
Да, его так зовут.
Принципиально другая концепция.
Просто вообще принципиально другая.
Но, правда, я выяснил это, может быть, не сегодня.
Да, это точно не сегодня.
Потому что сегодня мы поговорим про целочисленные сети
на втором занятии.
И про то, почему алгоритм денется
на самом деле в целочисленных сетах,
потому что он работает быстрее, чем В квадрат Е
может вам намекать.
