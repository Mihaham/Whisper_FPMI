Здравствуйте, продолжаем про FFT. Несколько задач посмотрим про многочлены, как можно их решать с помощью FFT.
Начну. Первая промежуточная задача – это деление многочленов с остатком.
Мы научились их умножать. Теперь представьте, наша задача – два многочлена поделить один над другой с остатком.
Вывести частные, вывести остаток. Чтобы не заботиться о дробях, давайте сразу в ZP переместимся, чтобы у всех чисел были обратные.
И можно было делить спокойно, если надо, возводя обратные по модульбюря. Как вы предлагаете лог квадрат?
Ну, за сколько угодно, быстрее. Нет, будет у вас NM.
Ну хорошо, чтобы это научиться делать, давайте сначала промежуточную задачу решим.
Давайте прямо так напишу задачу. Перед тем, как делить, давайте научимся находить обратные по модулю.
Пусть P многочлен, а хотим найти P в минус первый по модулю х в маленькой МТ.
Что такое P в минус первый? Это обратный многочлен, такой, что при домножении на P будет единица по модулю.
То есть это такой многочлен, давайте его назову как-нибудь Q, что произведение Q на P сравнимо с единицей по модулю х в МТ.
Ну, что такое по модулю х в МТ? Если у вас есть многочлены по модулю х в МТ, значит по факту вы просто отбрасываете все коэффициенты, начиная с МТ.
Потому что все мономы, в которых х хотя бы в МТ степени при взятии по модулю обнуляться, их, соответственно, не будет.
То есть по факту это значит, что произведение вот этих двух многочленов это единица плюс, возможно, еще какие-то коэффициенты старше, хотя бы М и старше.
Да, это мы живем в ZP, то есть все коэффициенты у меня из ZP.
Ну, конечно, П там достаточно хороший, чтобы можно было в Fourier там запускать.
Вот. Так, ладно. Значит, будем это делать следующим образом.
Во-первых, мы давайте будем считать, что M это степень двойки, потому что, скажем, если меня просят найти обратный по модулю х в десятой, то если я найду обратный по модулю х в шестнадцатой, то я сделаю только лучше.
Ну, потому что вот как раз модуль х в МТ, значит, я коэффициенты начинаю с кого-то отбрасывать.
Поэтому давайте сразу считать, что M это степень двойки. Если надо, округлим вверх до ближайшей степени двойки.
И теперь давайте научимся переходить от M к 2M. То есть, например, пусть я нашел обратный по модулю х в МТ, давайте найдем обратный по модулю х в степени 2M.
Значит, ну начнем с M равно единице.
Значит, обратный по модулю х в МТ для M равно единице.
Вот. Но здесь все просто. Если у нас многочлен P, и мы хотим найти обратный к нему по модулю х, то, значит, все коэффициенты, начиная с х, можно отбросить.
И по факту мне нужно просто обратный к младшему члену.
То есть, если P от х это что-то вот такое,
вот тогда в качестве обратного можно взять просто 1 на 0.
Вот. Ну более того, только такое мы взять и можем.
Да, потому что по модулю х у нас все коэффициенты, начиная вот отсюда отбрасываться, мне нужен обратный.
К этому это как раз 1 на 0.
Значит, в частности, если а 0 не 0, то мы так сделать можем, а если а 0 это 0, то мы так сделать не можем.
Вот. Ну и вроде логично, представьте себе, что если бы у вас был здесь 0, тогда бы у вас это все делилось на х.
То есть, вот представьте, я отслагаю моменту, тогда все делится на х.
Понятно, где вы не можете найти обратный по модулю х.
Что-то кратно х при домножении на что-то не может быть единицей по модулю.
Оно обязательно должно делиться на х.
Вот. Поэтому мы поняли, что если младший коэффициент 0, то задача не решаемая.
Если не 0, то решаемая.
Понятно?
Вот. Ну давайте подпишу, что а 0 не 0.
Ну дойдем до этого еще.
Там это проблемы не составит, кажется.
Ну, наверное, предпочитать будет сложно, потому что p большое.
Ну, запускаем там...
Обратный по модулю, это а в степени p-2, потому что мало термин фирма.
Вот. Значит обратный можно там, в бинарном возрасте степень посчитать.
Ну, логарифом. Ну, это не очень сложно.
Я про это, наверное, не буду говорить, про всякие обращения.
Ну, если надо, посчитаем. Но так это как бы, я считаю, что как-то встроенно делается, и бог с ним.
Вот. Все. Теперь давайте считать, что у меня по модулю хвм-то и нашелся обратный.
Я хочу найти обратный по модулю хвм-то.
Значит, пусть q0 таково, что q0 это обратный по модулю хвм-то.
Хотим найти q1, давайте просто q, такой, что q на p это 1 по модулю хвм-то.
Вот.
Хорошо. Ну, давайте я его искать буду в следующем виде.
Значит, я оставлю первые m-коэффициентов из q0 и допишу еще какие-то m-коэффициентов.
Значит, это опять-таки многочлен степени меньше, чем m.
Вот. Ну, тоже вроде логичное предположение, потому что что мне нужно?
Смотрите, q0 у меня был многочлен степени m-1, да, потому что если я все рассматриваю по модулю хвм-то,
то мне достаточно только коэффициенты от 0 до m-1.
Дальше я расширяю пространство, я говорю, что у меня теперь коэффициентов вдвое больше,
то есть у меня могут добавиться какие-то коэффициенты в более старших степенях.
Ну, понятно, что вот эти вот, они не влияют на поведение при маленьких степенях.
Поэтому маленькие степени можно оставить такие, как было.
Вот. Ну, соответственно, а вот старшие, все начиная с m-то, какие-то.
Вот давайте скажем, что это многочлен t, сейчас будем t искать.
Значит, более того, я представлю p в виде таком же самом,
p0 после хвм-ты на p1.
Ну, то есть опять-таки это какой-то большой многочлен,
я скажу, что его младше m-коэффициентов это p0,
вторая группа многочленов это p1.
Вот. Хорошо.
Значит, давайте напишем, что у меня уже есть.
У меня есть вот это.
И здесь понятное дело, что вот в этом равенстве тоже участвует только p0.
Вот здесь вот p1 никак не влияет, поэтому я ему могу выкинуть
и написать, что q0 на p0, это единица по модулю хвм-ты.
Вот.
Ну, вот.
q0 на p0, это единица по модулю хвм-ты.
Так. Хорошо.
Ну, давайте напишем в точности, что это значит.
Давайте напишем в точности значение вот этого многочлена.
Давайте скажем, что это 1 плюс хвм-ты на какое-то, скажем, r.
Мы знаем, что если это единица по модулю хвм-ты, значит первые m-коэффициентов
это только 1 и куча нулей,
и возможно, что какие-то еще более старшие, начиная с хвм-ты.
Ну, то есть если надо, я их просто переножил, честно, и получил полное представление.
Коэффициентов с 1 по m-1 нет, есть только возможность м-то.
Вот. Окей.
Значит, это у меня есть.
А теперь давайте напишем, что я хочу вот здесь вот.
Я хочу, чтобы q на p равнялся единицей по модуле хвм-ты.
Давайте распишем, что такое q на p.
Значит, это q0 плюс хвм-ты t на p0 плюс хвм-ты p1.
Вот. Ну, опять-таки, так.
Здесь мне надо подписать, что это происходит по модуле хвм-ты.
Да, понятно. Ну, короче, я не рассматриваю коэффициенты с номерами 2m и больше.
Потому что если я сейчас живу по модуле хвм,
то мне коэффициенты, начиная с этого, не нужны.
Поэтому p я вот так вот просто обрубаю.
Там есть какие-то еще более старшие в p коэффициенты.
Но они мне сейчас значения вот в этом вот, в этом кольце значения не имеют.
Ну, раскрываем.
Значит, здесь будет в частности наша q0p0,
которую мы только что посчитали.
Хвм-ты у меня будет домножаться на q0p1 плюс p0t.
Вот. Ну, и останется хвм-ты на что-то там, на tp1.
Вот. Но если, повторяю, мы живем в этом кольце по модуле хвм-ты,
то вот это зануляется.
Потому что это хвм-ты, это какие-то ногощины, значит, это будет 0 по модулю.
Согласны?
Ну, вот.
Значит, переписываю.
Ну, и давайте q0p0 сразу распишем, как оно у нас есть.
1 плюс хвм-ты r, хвм-ты сразу вынесу за скобку,
а у меня останется r плюс q0p1 плюс p0t.
Вот. Это все по модулю хвм-ты.
И мне хотелось бы, чтобы это внезапно была единица.
Ау?
Ну, вон же.
Вот. Мне хочется, чтобы было так.
Напомню, я хочу найти такое t, чтобы это было верно.
Для этого необходимо и достаточно, чтобы вот эта штука делилась на хвм-ты.
Потому что тогда единичка будет единичкой,
а здесь как раз что-то кратное хвм-ты, то есть она как раз и нулится по модулю.
Окей. То есть мне нужно решить сейчас такое сравнение,
что p0t
сравнимо с минус r
минус q0p1
по модулю хвм-ты.
Чтобы это делилось на хвм-ты.
Ну, и вот.
Чтобы это делилось на хвм-ты,
я просто перенес вот эти вот штуки направо.
Мне надо, чтобы выполнялось вот это.
Да?
Ну, что дальше делать, скажите, пожалуйста?
умножить на p0 в минус 1, потому что мы уже p0 в минус 1
и по этому модулю посчитали.
А мы знаем, что p0
на q0
это 1 по модулю хвм-ты.
Поэтому если сейчас обе части этого сравнения
домножим на q0,
у меня p0 сократится слева, а справа
появится просто умножитель q0.
То есть вот давайте напишу, я домножу это
на q0
с обеих сторон.
Слева у меня q0 на p0
заединичится, останется просто t.
Ну, а справа будет там какая-то гадость.
q0
умноженное на минус r
минус q0
p1
хвм-ты.
Вот.
То есть чудесным образом мы смогли разрешить
это сравнение относительно многочленов,
зная обратный к p0.
Все, мы получили явное выражение для t.
Причем его можно спокойно посчитать.
Смотрите, q0 мне известно с предыдущего шага,
это обратный к p0 по модулю хвм-ты.
Значит, это мне известно. r я тоже
посчитать могу, просто перемножив честно q0
на p0 и оставив ставшие коэффициенты.
Здесь q0, здесь p1,
p1 в общей части инпута.
Здесь я перемножаю два многочлена,
вычитаю, домножаю
еще на многочлен.
И отбрасываю все коэффициенты,
начиная с m-того, потому что если я живу в
х-тепени m, то мне коэффициенты нужны только
от 0 до m-1.
Все.
Ну, конкретно вот этот шаг
да, за m-логом, за вот
m-логом работает, да.
Вот. Да, давайте это напишем, что этот шаг
мы сделали за
o от m-лог m.
Потому что все многочлены
у меня сейчас состоят из m-коэффициентов,
от 0 до m-1.
Здесь перемножение двух таких многочленов,
ну, сложение вообще за линию работает,
и еще перемножение многочленов тоже там m на m порядка.
Супер. Мы тем самым научились переходить
от вот такого вот к такому.
То есть мы научились наращивать
степень х в двое.
За m-логом.
Ну, все. А теперь, если у меня есть база
для х-тепени 1,
я потом от него перехожу по модулю
х в квадрате, х в четвертый, х в восьмой, х в шестнадцатый и так далее,
пока не леду до
нужной мне достаточно большой степени х.
Вот. Значит, до сколько это работает?
Значит, мне нужно просуммировать
все степени двойки,
давайте так напишу, да,
m это степень двойки,
m не больше, чем
m большое.
Мне нужно просуммировать m-лог m.
Ну, правда, да, конечно.
Ну, давайте я вот так вот сделаю просто.
Да, да, это правда, конечно.
Вот.
Ну, понятно же, просто на каждом шаге m-лог m
по всем степням двойки суммируем от единицы
до m большого. Ну, вот я
скажу, что это будет просто m-лог m.
Надо?
Ну, смотрите, если бы у меня, вот давайте
представим себе идеальный мир, где логарифма не было бы.
Тогда бы я складывал просто степень двойки
1, 2, 4, 8 и так далее. Мы знаем, что их сумма,
это максимальная из них, там, умноженная
на 2. Да, поэтому сумма
просто была бы m большая.
Ну, а теперь вы каждую логарифму можете оценить
в лог m большое.
Ну, и получить немедленно вот это вот.
Да, да, да. Ну, то есть на самом деле, как бы вы
делаете фурье для многошленов длины
1, 2, 4, 8, 16 и так далее.
Ну, понятно, что только последний у вас самый
сложный, все остальные они вообще копеечные.
По сравнению с последним.
Все, обратили.
Номана?
Вот. На самом деле
техника вот эта вот
весьма
ну, такая, весьма общая.
Довольно много задач можно решать в таком виде.
То есть, смотрите, я хочу там найти что-то
по модулю x в м-той. Давайте я
буду итеративно расширять
это m в двое. То есть, представьте, что я
решил задачу по какому-то маленькому модулю, там
x в м-той, вот, например, такое.
Хочу посчитать x в 2 м-той, по модулю x в 2 м-той.
То же самое сделать. Ну, вот если какую-то магию
поделать, то обычно как раз
это получается сделать. То есть, точность
ответа количества известных коэффициентов
можно увеличивать в двое.
Вот. Частенько такое
срабатывает.
Ну, в каком-то смысле
на самом деле это
что-то типа метода
Ньютона касательных.
Да, когда у вас есть график функции,
вы хотите найти корень
корень какой-то функции, f от x равно 0.
Ну, давайте я нарисую.
Я вас уже сказал.
Представьте, у вас есть какой-то график, да?
Вы хотите найти корень в нём.
То есть, там, где она зануляется. Что такое
метод Ньютона?
Это вы берёте какое-то начальное приближение,
говоришь, что ответ примерно здесь.
Далее рисуете касательно,
и говоришь, что ответ теперь примерно здесь.
Ну, то есть, как бы вот эту ординату имеет.
То есть, вот эту точку. Потом здесь рисуете касательно,
она вас всё ближе и ближе к ответу приближает.
Ну, на самом деле, да.
Только там
длина шага
равна просто
так, чтобы попасть на o, x.
Но если там начальное приближение достаточно
хорошее, функция достаточно хорошая,
то это очень быстро сходится.
В каком-то смысле мы сделали
то же самое. Если на это по-другому посмотреть,
то можно обнаружить то же самое.
Но это...
Это знать нельзя.
Так, хорошо.
Значит, мы научились обращать
по модулю x в m t,
коль скоро младше коэффициент не ноль.
Ну, теперь давайте научимся делить многочлены.
Сейчас будет ещё большая магия.
Значит, пусть у нас есть два многочлена
f и g.
Многочлены.
Мы хотим их поделить с остатком
f на g.
Хотим
поделить с остатком
f на g.
Хотим
поделить
f на g с остатком.
Ну, что это значит?
То есть, мы хотим найти такие два многочлена
p и q.
Что f это
p, g...
Нет, не p и q, я их
переназову как-то.
У меня было бы q и r всё-таки.
Quotient и
remainder.
Значит, q и r, что это q g плюс r.
Ну, где степень r,
меньше степень g.
Вот. Хотим поделиться
с остатком, чтобы остаток имел меньшую степень.
Окей.
Сейчас будет магия.
Смотрите, давайте определим
на многочленах простую
функцию реверс.
Как она работает? Если у вас
p было равно
a n
x v n
плюс так далее, плюс a 0,
эта штука просто берёт
и реверсит список
коэффициентов.
То есть, давайте считать, что a 0
это
старше ненулевой коэффициент.
Она просто берёт...
Уважая длину, да,
то есть она оставляет,
то есть она берёт старше ненулевой коэффициент,
то есть как раз что степень p это n
и просто разворачивает этот список, получая
вот такой вот многочлен.
Вот, и здесь в частности получается, что теперь младший
как раз будет ненулём.
Так как мы и хотели в какой-то момент
вот, ну, это сыграет ещё.
Хорошо.
Так, ну, я вот хочу теперь
эту функцию рев применить к обеим частям
этого равенства.
Значит, ну, слева понятно будет просто рев
а справа я хочу понять
что такое рев вот этой вот суммы
странной.
Значит, ну, замечание первое,
что рев от произведения
q на g
это на самом деле произведение
ревов q и g.
Пруфы.
Может, кто-нибудь скажет почему это так?
Да, да, да, да, да, это в каком-то смысле
значит, я вместо
x пишу 1 на x, да, и умножаю
на x в m, да, вы вот так вот говорите.
Так, сейчас я проверю, что это верно.
Да, то есть a0 будет как раз с этим.
Да, да, ну, это в точности.
В точности рев от p, это в точности такой многочлен.
Вот.
Ну, и тогда вроде очевидно,
что в произведении вы как раз
заменяете в обоих
многочленах x на 1 делить на x.
Тут ещё умножаете на x в степени
степень q плюс
x в степени степень g, ну, и здесь тоже самое
x в степени степени q плюс x в степени степени g.
Вот, поэтому рев мультипликативно,
да, можно рев от произведения
ревов.
Более того, я утверждаю,
что реверс всей правой части
целиком q на g плюс r.
Это следующее.
Рев r, но
немножко сдвинутая.
Потому что, смотрите,
r само по себе, оно довольно маленькой
степени,
но когда вы его добиваете
спереди большими коэффициентами,
ну, в смысле, коэффициентами
с большими номерами, то после реверса
вот эти маленькие коэффициенты в r
наоборот будут влиять на старшие коэффициенты
в результате.
Поэтому после реверса вам нужно их умножить
на что-то типа степень
f минус степень r.
Ну как?
Ну, окей,
степень qg можно
я могу здесь написать.
Вот, да, то еще раз картинка давайте,
пусть вот это вот все было qg плюс r,
вот это все было qg,
а вот здесь вот было еще r добавлялось сверху.
Тогда после реверса у вас r будет
влиять на вот эти вот старшие коэффициенты,
а если вы просто сам по себе
r развернете, то он как бы будет вот здесь вот на месте
это делать. Но вам надо еще сдвинуть это сюда,
чтобы старший перешел вот сюда.
Похоже?
Ну, супер.
Ну, супер.
Тогда, значит,
мы знаем следующее, что
revf
это revq на revg
плюс revx
на x какой-то там
степенью.
Значит, теперь я хочу избавиться
здесь от ревер.
Я хочу избавиться
вот от этого и сначала решить задачу
с поиском q.
Что можно сделать в этом
равенстве, чтобы избавиться вот
ревер?
Да, просто берем и смотрим
это равенство
по модулю x, ну, в степени
на один меньше, чем вот этот x.
На то, с dg
минус dgr
минус один.
Берем это по такому модулю, просто смотрим
это сравнение. Тогда это полностью умирает,
потому что здесь x в большей степени, чем здесь.
Ну, и остается такая штука.
Так, справедливо.
Справедливо, да, извините, значит,
я, наверное, глупо сказал.
Да,
по такой
модулю смотрим.
Вот это все по модулю
x в степени dg
минус dgr.
Вот, хорошо.
А то есть
мы, если не полностью
теперь умеем находить рев q,
а смотрите, что такое решить вот это уравнение.
Смотрите, мне f известно, g известно.
Чтобы вычислить отсюда рев q, мне нужно
просто домножить на обратный к рев g по модулю
как раз x в степени m.
Такое мы уже решать умеем, да, то есть если я нахожу обратный
к этому по модулю вон тому,
я на него домножаю, оно переходит сюда
и остается рев q равно чему-то там, значит, мы знаем q.
Но не совсем, мы знаем q
по такому модулю.
Я утверждаю, что этого хватает.
Давайте просто на степень посмотрим.
То есть я утверждаю, что вот эта вот степень
достаточно большая,
так что рев q при взятии по этому модулю
сохраняет все свои коэффициенты.
То есть мы ничего не потеряли, мы никакую информацию
про q не потеряли.
Потому что, смотрите, какая степень у q?
Ну, видимо, f минус g.
Правда же, потому что я делю многочисленные
на одной степени на другой,
неполно частные имеют степень разности.
Ну, если я в ZP живу, конечно.
Вот.
И дальше я знаю, что
дег r меньше, чем дег g.
Значит, минус
дег g будет
меньше,
чем дег f
минус дег r.
Потому что вот у меня есть
такая неравенственная степень.
Ну, все.
Значит, у меня в q
коэффициентов
достаточно мало, что при рассмотрении
их по этому модулю я ни один не потеряю.
То есть степень q меньше, чем вот это вот,
чем x в той степени, по которой я его рассматриваю.
Значит, при
решении этого сравнения я никакую информацию
не потерял.
То есть у меня были там какие-то коэффициенты, я их развернул,
они все остались на месте, потому что
здесь достаточно большая степень, я ничего не теряю.
Но такие сравнения я решать уже умею.
Я домножаю на вот это вот обратное,
получаю рев q, разворачиваю, получаю q.
И более того, так я делать умею,
потому что здесь младший коэффициент
не ноль. У рева всегда младший коэффициент
не ноль, потому что я это проговаривал,
где-то здесь картиночка была.
Значит, я умею обращать, я умею находить
рев q.
Давайте скажу, что я умею находить отсюда рев q.
После реверса я знаю q.
Ну и после этого r найти уже
никакого труда не составляет, r это просто f-q.
Поделились с остатком.
За, кажется, опять n лог n,
где n это степень f.
Потому что что я здесь делаю?
Я делаю обращение по кому-то модулю.
Это вот,
ну эта штука имеет меньше,
степень меньше, чем n.
Значит, здесь все fft-шки работают
от n лог n.
Потом мне вот здесь нужно еще переножить
два многочлена и тоже работают за n лог n.
Ну и вычесть.
Все, получается, поделились за n лог n.
Нормально?
Что делать остать хочется?
Вот, то есть, смотрите.
Мы научились с многочленами
делать, ну более-менее, все риторические
операции, умножать, делить.
Что-то там еще, получился,
вот, вот.
Вот, вот.
Вот, вот.
Вот, вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Делить.
Что-то там еще были бы странные операции.
Возвадить в степень – это, наверное, ту матч.
Х в степени х, я не знаю, что такое, например.
Вот.
Но умножать делить мы умеем.
Хорошо, вот с многощинами как ни странно разобрались.
А вот если бы нам надо было делать то же самое с числами,
то это чуть сложнее.
Скажем, ну умножать числа можно довольно просто с
помощью FFT.
А вот делить – там, там запара, да.
Ну представьте, у вас есть два длинных числа.
Одно длины 10 в шестой, другое длины 10 в пятый.
Вам надо одно на другое поделить.
Ну мы хотим какую-то адекватную симпатику, да, чтобы не
10 в 11 работало, а что-то нормально.
Вот.
Ну, значит, там сложнее алгоритмы, они тоже существуют,
на базе FFT это все работает, конечно.
Но там прям, там прям жестко.
Нет.
Ну, много чего, например, потому что когда мы живем
в 10-шеме числении, нам, типа, надо делить по модлю 10,
во-первых.
Там не всегда есть обратный.
Во-вторых, ну, типа, даже, ну, как бы, вы просто никак
переход не сделаете.
Ну, вот, поделили многочлены один на другой, да, то есть,
ну, понятно, да, если у меня есть какое-нибудь число,
например, там, ну, не знаю, 9, 2, 3, его, наверное, логично
отождествится с самым многочленом 9х2 плюс 2х плюс 3, да, и как
бы, подразумевает, что х равно 10.
Ну вот, я утверждаю, что если вы поделите один многочлен
такого видна другой, и даже, там, если что-то у вас получится,
то что с этим делать потом, непонятно.
Ну вот, потому что коэффициенты, которые вы там получите,
они будут, ну, не цифрами, как минимум, а вам надо,
чтобы были цифры, и как их проталкивать, там непонятно.
Ну, вот, короче, короче, сложно, ну, и там по-другому
делаете, так не получится, скорее всего, вот, поэтому
с многочленами работать почему-то приятнее получается,
с числами даже, такая магия.
Ну ладно, давайте скажем, что это сложно, и мы этого
делать не будем.
Давайте еще порешаем про многочлены, раз с ними
так все хорошо получается, давайте еще с ними какие-то
задачки порешаем.
Значит, задача называется multi-point evaluation, у вас есть
многочлен, заданный набором своих коэффициентов, давайте
x в m-той, вот, и вам нужно найти его значение во многих
точках.
Значит, найти p в точке x1, и так далее, p в точке xn,
вот такая задача, найти p во многих точках.
Ну, понятно, что там обычно алгоритм работал бы за
nm, если вы в тупую поставляете каждую точку в многочлен,
то это работает за линию на каждую точку, на каждый
запрос.
Мы сделаем побыстрее.
Да, мы будем делить.
Значит, скажите, пожалуйста, знаете ли вы, чему равно
значение многочленов в точках, как это можно выразить
с помощью делений, например, поинтеллектуально.
Терембезу, помните?
Такая умная теорема есть.
Значит, почему это верно?
Ну, потому что p от x по модулю многочлены первой степени
точно число, и если подставить, что подставить, ну да, что
вот это значит?
Если написать, что p от x это какой-то там q от x на x
минус x, плюс какое-то значение a, еще раз, остаток это обязательно
число a, число не многочлен, но вот если сюда поставить
x и, то у вас получится p в точке x и равно нулю плюс
a.
Значит, как раз значение в точке x и.
Поэтому, чтобы нам решить такую задачу, мне достаточно
найти процент по многим модулям, остаток определений
на много многочленов x минус x1, x минус x2 и так далее.
Не надо.
Дальше мы сделаем следующее, смотрите.
Давайте я, ну я сейчас для удобства, я, короче, нарисую
картинку, когда я пытаюсь найти значение в 8 точках.
Давайте построим следующие многочлены.
Я сначала напишу все наши 8 элементарных наличия
на степени 1.
Вот, дальше начну их по парному нажать.
Я умножу вот эти два, получу какой-то многочлен, ну равный
вот такому.
Значит, эти два умножу, получу такой многочлен.
Дальше перемножаем.
Да, дерево отрезков построили на самом деле, это правда.
Да.
В конце, в корне дерева будет произведение всех скобок,
верно.
Значит, зачем мы это сделали?
Смотрите, я хочу найти значение p по всем вот этим вот модулям.
Но если это делать нашим обычным алгоритмам, то это будет
n log n на запрос.
Если у меня есть многочлен на степени n, найти его остаток
по модулю многочлена какого-то, это n log n.
Вот.
Давайте мы сначала найдем остаток p по вот этому модулю.
У нас останется многочлен степени 8.
Даже 7.
Если я найду остаток p по этому модулю, у меня останется
многочлен степени 7.
А дальше уже я смогу это прокидывать по всем веточкам
нашего дерева.
У меня есть многочлен степени 7, я здесь нахожу его остаток
по многочлену, по модулю многочлен степени 4, остается
многочлен степени 3.
Ну, здесь harp, многочлен степени 3, и так далее.
И поскольку я на каждом шаге беру процент не от многочлена
степени n, а от многочлена все меньше и меньше степени,
то это будет работать все быстрее и быстрее.
То есть, если я вот эти все многочлены как-то нашел,
то за сколько у меня теперь работают все вот эти проценты?
То есть, еще раз, во-первых, я утверждаю, что чтобы найти,
скажем, p по модуле этого многочлена, мне достаточно сделать
следующее.
модулю, потом остаток взять по этому модулю, потом остаток
по этому модулю, потом остаток по этому модулю.
Ну, вроде очевидно.
Еще раз?
Ну, это наша исходная задача, да, мы хотим значение многочленов
во всех точках.
Вот для этого я говорю, что достаточно найти проценты
по всем этим модулям, теряем безу.
Дальше я это делаю так, я нахожу сначала по проценту
вот этот вот многочлен, у меня остается многочлен
степени 7, дальше я его проталкиваю в обе веточки, беру многочлен
в степени 7 по обоим модулям, получаю многочлен в степени
3, ну и так далее, проталкиваю его вниз, каждый раз степень
многочленов сокращается вдвое, ну и соответственно
деление занимает все меньше и меньше времени.
Ну, типа того, да, ну не совсем.
Да, вот давайте представим, что вот это вот дерево у
меня полностью построено, давайте посчитаем, за сколько
будет все эти деления работать.
Так, ну вот первое будет что-то типа, давайте вот
так напишу, m plus m log n plus m, а то есть если этот многочлен
неизвестен, я беру остаток многочлена степени m по
модулю многочлена степени n, вот этот вот степени m
беру по модулю многочлена степени n, но это работает,
мы знаем, деление в частности вычлений остатка работает
за сумму умножить на лог суммы, на самом деле за m log m на
самом деле, да, ну типа да, если n больше, ну это грубая
оценка сверху.
Значит, смотрите, напоминаю, мы считаем, что мы построили
все это дерево, мы знаем все эти многочлены в явном
виде, то есть я пока что их написал как произведение
каких-то двучленов, да, на самом деле, ну чтобы делить,
мне нужно знать многочлен в явном виде, как набор
коэффициентов, то есть еще раз, я еще пока что предполагаю,
что здесь все эти многочлены раскрыты, я знаю все их коэффициенты,
потом еще посчитаем, сколько нужно времени на это, вот,
ну давайте делить, значит, мы p пропускаем через это
дерево, первое деление, самое сложное, оно вот такое,
примерно m log m, дальше у меня на этом уровне остается
многочлен степень ни больше, н, ну даже строго меньше,
но я n-ко ограничу, потому что я взял его по модулю многочлена
степени n, остался всего многочлен станет меньше,
чем n.
Дальше, я на каждом уровне делю намногочлены степеней
в два раза меньше, здесь степень n пополам, здесь
степень n пополам и делаю это дважды, у меня остаются
многочлены степени n пополам, но вот эти деления работают
за 2 раза n log n, потому что намногочлен Степени n делю
что-то. Остаются многочлены степени n пополам. Теперь я многочлены степени n
пополам четыре раза делю на многочлены степени n на 4. Получается у меня, что это
все работает за 4 n пополам лого n пополам, потому что многочлены степени n
пополам поделились на что-то. После этого остаются многочлены степени n на 4.
Опять, я их 8 раз делю на многочлены еще меньшей степени. Получается, что весь
вот этот слой обрабатывается за 8 n на 4 лого n на 4. Ну и так далее. Давайте
просуммируем, что, скажем, сумма по всем k от нуля там до логорифма примерно, так
2 в степени k плюс 1 n на 2 вкатой лого n на 2 вкатой. Вот такая у меня
получается сумма, если я ничего не путаю. Ну то есть k это номер слоя. Количество
делений в слой это 2 в степени k плюс 1. Многочлены в слой имеют вот такую длину.
Правда? Ну все, это не больше, чем сумма k от нуля до логорифма. 2 вкате, 2 вкате
сокращается n лого n. Да, и это есть n лого квадрат. Мне неизвестно, кажется, никто пока не умеет.
Тут согласны? Ну, короче, сложили, получили честный n лого квадрат. Плюс не забываем,
что первое еще деление было, да, то есть если у меня m было какой-то большой степени, надо
еще добавить там типа m лого m, но это оставляю, оно здесь у меня написано. Так, теперь вернемся к
тому, что мне еще нужно дерево все посчитать. Напоминаю, что мне нужны эти многочлены раскрыть
как набор коэффициентов, не как какие-то со множды, а именно коэффициент. Ну, давай считать,
за сколько это можно сделать. Давайте мы дерево будем снизу вверх строить и перемножать многочлены
с помощью фурье. Понятно, нижний слой у меня посчитан, это просто вот двучлены такие. Теперь
на каждом слое мне нужно перемножить два многочлена степени одинаковой, получить многочлен степень в
два раза больше. Вот, но я тоже, что если это опять просуммировать, то опять получится n лого квадрат.
То есть, чтобы это построить дерево, будет n лого квадрат, чтобы потом все поделить, тоже будет n
лого квадрат. Ну, давайте посчитаем, сколько у меня занимает построение дерева. Так, вопрос.
Ну, давайте скажем опять, возьмем какой-то катый уровень. Так, момент, сейчас я буду, сейчас я
немножко поторможу, но все-таки было бы хорошо это нормально писать. Значит, вот здесь у меня будут
многочлены степени n на 2 в катый примерно. Здесь будут многочлены степени в два раза меньше,
n на 2 в степени k плюс 1. Я их перемножаю и делаю это ну столько раз, какой номер уровня. Ну, короче,
та же самая сумма получится, потому что, ну типа вот здесь я иду сверху вниз и делю один многочлен
на два многочлена поменьше, это работает там суммарно за n лого квадрат. А теперь, если я наоборот
буду снизу вверх идти и перемножать многочлены, то есть я вот здесь делил один большой на два поменьше,
чтобы пойти снизу вверх, нужно сначала перемножить вот эти два маленьких, получить один побольше. Но
перемножение работает за столько же сколько деления, поэтому то же самое время будет тоже n лого
квадрат. Вот, ну все, значит, суммарно n лого квадрат и на построение, и потом на спускание вот
этого вот p по всем модулям. Такие дела. Так, вопросы есть? Вот здесь в смысле? Ну, еще раз,
у вас есть остаток по модулю, вы берете его по этому модулю, по этому модулю, по этому модулю,
у вас получается значение в точке. И так, и так по всем веточкам. Не, еще раз, еще раз, если у вас,
еще раз, кто большой? Н? Не знаю, честно говоря. Хорошо, вопрос я сходно не могу ответить. Ну,
подумайте, я что-то не уверен, честно говоря, что если точек сильно больше, чем степень многочлена,
бог его знает, не знаю. Хз. Давайте дальше поедем. Давайте мы решим обратную задачу интерполяция.
Значит, прошлой задачей я находил по многочлену значение его в каких-то точках, теперь обратная
задача по значению в наборе точек хочу восстановить коэффициенты многочлена. Значит, по значениям
p от x1 равно y1 и так далее, p от xn равно yn восстановить коэффициенты p. Ну да, мы такую задачу
решали, если у нас степень, pardon, точки, в которых заданы значения, это корни за
единицы степени там какой-то. Такую задачу мы решаем, это фурье. Ну, давайте в общем случае
теперь с помощью фурье обобщим на произвольный набор точек. Так, сейчас будет чудо. Давайте мы
разобьем нашу задачу на две. Давайте первым шагом, вот смотрите, я хочу найти такой многочлен.
Давайте первый шаг сделаем такой. Значит, найдем многочлен, давайте его назову a1,
который равен нужным значениям на первой половине точек. То есть, a1 от x1 равно y1,
а 1 от x2 равно y2, ну и так далее, вплоть до x с номером n пополам. Вот, это задача вдвое
меньшего размера. Если я сведу большую задачу к двум задачам размеров вдвое меньше, у меня
будет там асимптотика понятна какая. Вот, ну давайте сначала скажем такое. Вот, а дальше я говорю,
что, коль скоро я a1 нашел, говорю, что дальше я буду искать p в виде, так, a1x плюс,
так сейчас один момент. Кажется, вот в таком виде это буду искать. Значит, где q, да, да, да,
все правильно, все правильно. Где q это произведение x-x по всем i от 1 до n пополам.
Значит, q это произведение x-x по всем вот тем i, который я построил в этой первой части. То есть,
по i от 1 до n пополам. Вот, ну понятно, что это разумное предположение, потому что если я
буду подставлять вот эти вот x с маленькими номерами в этот многочлен, p от x равно вот этой
штуке, у меня q будет зануляться и значение будет такое же, как в a1. Поэтому на первой половине точек
у меня все будет адекватно. Но если у меня p имеет вот такой вот вид, где q это такое произведение,
то во всех точках x1 и так далее x и n пополам, у меня значение будет совпадать со значением
многочлена a1. А это то, что мне нужно. Вот. Н-лог-куб. Нормально, нормально. Так, ну что умеем. Значит,
давайте разберемся, с первыми и n пополам точками разобрались, что делать с остальными. Да,
давайте я скажу, что i это больше чем n пополам. Давайте поймем тогда, что здесь написано. Что такое
p в точке x? Давайте xj назову это. Это a1 от xj плюс a2 от xj на q в точке xj. Я знаю,
чему должно быть равно a2 в точке xj. Ну там как-то перегруппирую, вычту, получится, что надо.
Причем эта штука не нулевая, потому что это произведение каких-то не нулевых множителей.
Правда? Ну вот. Все, что мне осталось сделать, это найти такой a2, что в точках с номерами от
n пополам плюс 1 до n, его значения вот такие. Что такое такие? p в точке xj я знаю, что это просто
yj. По условия задачи мне нужно, чтобы pxj было yj. Это я знаю, это значение уже найденного многочлена
в каких-то точках. Это опять-таки значение какого-то понятного многочлена в каких-то точках. Это
предыдущая задача. Задача multi-point evaluation. У меня есть два многочлена, я их явным образом знаю,
но a1 я вообще нашел с рекурсивного запуска. Я знаю a1, q. Найти тоже не очень сложно. Мы в прошлой
задаче этим как раз занимались. Мы строили дерево, в частности в корне которого было произведение
всех вот этих вот товарищей. Значит я нахожу такое произведение, я знаю многочлен q, и дальше
мне нужно найти его значение в n пополам точках. Вот этих вот xj со всеми вот этими номерами. Это
опять-таки предыдущая задача multi-point evaluation. Найти значение многочлена в куче точек. Значит
и того второй шаг. Находим значение a1 и q в точках x с номером n пополам плюс 1 и так далее xn.
С помощью прошлой задачи за n лог квадрат. Ну и третий шаг. Находим a2 как многочлен с
такими значениями в таких точках. Находим a1 рекурсивным вызовом. Ну отсюда n лог q,
потому что у вас на каждом шаге n лог квадрат. Находим a1 рекурсивным вызовом. Ну то есть
еще раз мы знаем, извините, а2, да, спасибо, а2. А2-то у нас уже есть, 1 в смысле есть. Мы находим
а2, потому что мы знаем какие значения он должен принимать в каких точках. Это задача того же
порядка, только в два раза меньшего размера. Ну и значит время работы будет у меня два раза
пятен пополам плюс n лог квадрат. Ну значит по мастертиареме это просто n лог куб. Такие дела.
Так, это правда вообще, кстати?
В смысле легко оценивается? Мне кажется мастертиарема говорит, что здесь n лог квадрат будет, нет?
Входит, потому что одно превосходит другую на лог. Да, значит не мастертиарема, ну а просто если
честно расписать, то будет n лог куб. Да, по индукции. Нет, вот здесь квадрат и здесь куб. Да-да-да. Нет,
я имею ввиду, sorry, это не мастертиарема, потому что не помещается ни в один из случаев. Это ну
отдельно, типа отдельно можно по индукции доказать или расписать, что вот это вот там,
опять расписать это как n лог квадрат. Ну да-да-да-да-да, ну короче будет лог куб. Вот,
вопросы? Ну вроде, вроде, вроде ничего так. Вот, ну это конечно лучше, чем всякие там обычные
многочлены интерпретационные, там Lagrange или Newton, потому что они требуют перемножения каких-то
многочленов, деления и там еще сумма какая-то в общем, если это руками делать, то это будет
квадрат. Вот, а тут он лог куб. Ну как бы, не бог весть, конечно, какая оптимизация для каких-то
адекватных n, но если оно очень большое, то вполне себе. Так, хорошо, блин, что-то время как-то медленно
идет, ну ладно. Задача. Ревнивые рекурренты. Представьте себе, что у вас есть последовательность
чисел, которая подчиняется какому-то рекуррентному линейному соотношению такого
вида. Ну давайте пример сразу нарисуем. Давайте скажем, что аэнная это что-нибудь типа 7 аэн-1,
минус 8 аэн-2, плюс, не знаю, 13 аэн-3, минус аэн-4. То есть это линейная комбинация нескольких предыдущих
членов с фиксированными коэффициентами. То есть вот эти 7, минус 8, 13 и минус 1, они общие для
всех n, то есть для всех n, начиная с 4, выполняется такое соотношение. Линейная рекуррента с
постоянными коэффициентами. Вот, предлагается понять, как это, как можно будет быстро находить
n-ый член такой последовательности. Слишком знакомая, да. Ну можно матрички, это правда. Давайте скажем,
что линейная порядка у меня будет, линейная рекуррента у меня будет с этого порядка. Это значит
просто, что аэнная зависит от s предыдущих. В данном случае s равно 4. От скольких предыдущих
членов зависит аэн, таков порядок рекуррента. Значит, ну тогда можно записать простое матричное
соотношение, что вот такие вот s членов прогрессии, рекурренты, равны матрице на предыдущие s
аналогичных значений. Аэн минус 1 и так далее, аэн минус s. Здесь соответственно в первой строке
будут вот эти вот коэффициенты, как аэн выражается через столбец предыдущих. А здесь будет вот такая
вот простая матрица с единичками по диагонали. Согласны? Ну просто умножение матриц так работает.
Вот, ну это будет у меня за s куб лог n. Значит, тогда, если мне хочется посчитать
аэнный элемент рекурренты, то это получается алгоритм за s куб лог n. Потому что умножение
матриц работает за куб. Бинарное возведение требует еще логарифмического множителя. Ну и тогда
аэн и мы можем за такую симпатику считать. Вот. Ну мы хотим побыстрее, чем s куб.
Кого? А вы имеете в виду через корни вот это вот? В смысле, решение, уравнение решите
характеристическое? Да, ну решать мы его не будем, но характеристики многощины мы построим.
Значит, смотрите, давайте действительно для вот этой штуки я заведу характеристические
многочлены. Раз у нас сегодня было все про многочлены, давайте построим характеристические
многочлены. Значит, что будет здесь? Вот на этом примере давайте построим. Если я не ошибаюсь,
то следующий многочлен. Значит, x4 минус 7x в кубе плюс 8x в квадрате минус 13x плюс 1. То есть,
я беру x в этой, а дальше с противоположными коэффициентами вычитаю все, ну вот, короче,
какой здесь номер h и с такой степенью x будет. Вот это характеристические многочлены. Давайте
я как-нибудь обозначу, пусть будет. Отверждение. Пусть x в n по модулю p
Это следующий многочлен. Так, b-шки у меня свободные. Давайте b0 плюс b1x плюс и так далее,
плюс bs минус 1 и xs минус 1. Ну понятно, это многочлен степени s. Степень многочлена характеристичка
такая же, как порядок рекурренты. При взятии остатка по нему у меня получается многочлен
в степени не выше s минус 1. А возможно это 0, тогда это меньше степени многочлен. Так вот,
тогда я утверждаю, аn равно a0 b0 плюс a1 b1 плюс и так далее, плюс аs минус 1 bs минус 1. А вот,
первые с-коэффициентов нашей рекурренты, первые значения нашей рекурренты. То есть,
ну вообще, что такое рекуррент, если она с-то в порядка, то у нее очень-очень первые с-значения
должны быть заданы. То есть, а0, а1, а2, а3 должны быть заданы, потому что, ну как тут написано,
что n хотя бы 4. Значит, первые с-членов у меня фиксированы, какие-то константы. А дальше все,
начиная с с этого выражаются через предыдущий вот по такой рекурренте. Так вот, я утверждаю,
что если взять х венны по модулю х-многочлена, у меня получится как раз представление а n через 1s
коэффициентов. То есть, вот эти вот коэффициенты перед х будут то, с какими коэффициентами надо
взять изначальные вот эти ашки. Соответственно, если мы это докажем, то что остается сделать?
Остается поделить один многочлен на другой с остатком. Ну, единственная правда, что у него
может быть большая степень. Да, я хочу делать это примерно за log n. Вот, надо будет еще понять,
как многочлен вот такой степени брать по модулю. Ну, это еще собрать. Давайте с этим разберемся сначала.
Так, первый раз жизни будут доказывать, так что ничего не обещаю. Индукция по n.
Значит, база n до s-1 тривиально. Если n до s-1, то мы берем многочлен маленькой степени по модулю
многочлена с этой степени. Значит, я ничего не делаю и у меня остается просто х венный. То есть,
коэффициент перед х венный будет единичка, все остальные нули. Это как раз выражение а n-ого
через само себя, через а n. Если n маленькое, то это просто выражение а n само через себя.
То есть, в этом случае я а n выражаю само через себя. Согласны? Ну, теперь давайте для х веста
это докажем. Значит, n равно s тоже в базу индукции я запихаю. Давайте докажем для n равно s руками.
Ну, я беру вот такой многочлен и к степени s, делю его на характеристический той же степени,
причем он имеет обязательный вид х веста и там минус что-то. Так, ну, давайте напишу минус что.
Ну, я обозначу вот эти вот коэффициенты, с помощью которых выражается а n-ое через предыдущий,
как за c-шки просто. Вот я говорю, что это c s-1, это c-3, это c-2, это c-1, это c-0. Ну, с минусами. Вот.
Ну, давайте поделим в столбик. Понятно, что старше здесь будет единица. Мне нужно вычесть это из этого это.
Да, то есть, минус х многочлен, остается сумма этих c-шек с плюсами уже. То есть, c s-1, x s-1,
плюс так далее, плюс c-0. Ну, не очень сложно многочлены делить, пока что еще не разучились. Ну,
это ровно то, что нужно. Потому что мы получили, что определение как раз остатка деления х веста
на p, это вот такая вот вещь. Но мы же с вами знаем, что а s-то, это в точности вот такая вот комбинация
ровно с такими коэффициентами первых s-значений. То есть, мы знаем, что верно вот это вот. А это мы
хотим доказать. Вот. То есть, еще раз. Что я хочу? Я хочу сказать, что если я взял х вестой по модулю
p, получил какой-то многочлен, то вот эти вот коэффициенты, результаты, которые я получил в остатке,
вот эти вот коэффициенты, это и будут коэффициенты выражения а s-того через первые s-ашек. Ну вот. То
есть, мне надо доказать вот это. Ну ровно это как бы и написано в рекурренте. Что а для всех n
начиная с s, это вот такое вот выражение через предыдущее. Понятно? Вот. Ну, значит, база есть.
Теперь переход. Значит, пусть х вентой в процент p от x, это вот тот многочлен. И известно,
что а n-ая, это линейная комбинация первых s-ашек, вот опять-таки с такими же коэффициентами. То есть,
это b0 а0, плюс так далее, плюс b s-1 a s-1. А теперь рассмотрим х вен плюс первый. Вот. Ну,
я напишу, что х вен плюс первый это х умножить на х венный. Значит, х умножить на х венный по
модулю p и потом вот это вот все еще раз по модулю p. Вот это почему верно? Ну, потому что,
ну, смотрите, если мы погрузимся в кольцо по модулю zp, по модулю p от x, если p как модуль
воспринимать, то вам неважно, в каком порядке делать перемножение. Вы можете сначала х вентой
взять по модулю, потом домножить на х и взять по модулю. Либо сразу вот это взять по модулю.
Ну, это я не буду доказывать, совсем просто. Ничего, если подумать, то поймете. Вот. Ну,
чего? х венты по модулю я знаю, что такое. Это вот эта вот вещь. b s-1 х v s-1. Значит,
теперь после домножения на х, давайте я веду как раз по модулю, я говорю, что я перемещаюсь в кольцо
по модулю p от x, этот процент везде сотру. Но теперь я вот этот стук умножаю на х. Тут будет
написано b 0 х в первой, b 1 х во второй, плюс так далее, плюс b s-1 х в эстой. Вот. Ну,
а теперь х в эстой меняем, да и побеждаем, собственно. Так, сейчас. Да, ну вот я написал
сравнимо по модулю p от x, да. Сейчас, сейчас, сейчас. Ну, давайте так скажу. Смотрите,
я получил выражение х в n плюс первой через вот эти вот s х. Это в частности означает,
смотрите, это в частности означает, что a n плюс первая, это следующее. Почему? Потому что,
смотрите, я знал это для a n. Я знал, что a n выражается вот с коэффициентами b через первые
s х. Теперь, я говорю, я сдвигаю все на единицу, и a n плюс первая выражается с теми же самыми
коэффициентами через вот эти ашки, с первой по эстой. Почему? Ну, потому что вот у меня была
бесконечная последовательность, бесконечная рекуррента, у нее первая s члена фиксированная,
все астамии выражаются по формуле. Давайте я сдвину ее на 1 и начну нумерацию не с нулевого, а с первого.
Ну, тогда выражение n плюс первого члена будет выражено как раз через вот эти вот первые члены
с первого по эстой с теми же самыми коэффициентами, что x в n было выражено через a 0, и так далее,
ас минус 1. То есть, если вот это вот корректное выражение для x в n через 0, и так далее,
ас минус 1, то это корректное выражение для x в n плюс первое через a 1, и так далее, ас. Ну,
просто я сдвинул рекуррент на 1 влево. Поскольку рекуррентно-соотношение не изменилось,
то у меня выполняется по-прежнему вот это вот выражение любого члена через предыдущее.
Ну вот. А дальше мы знаем, ну все, а дальше уже очевидно. Дальше мы знаем, что x в эстой,
если взять по модулю P, то оно превратится, оно как бы разложится при взятии по модуле,
оно как раз даст разложение x в эстой через все меньшие степени. То есть, как вот это вот
выражается через a 0, и так далее, ас минус 1. Ну и значит, после взятия по модуле у меня как раз это
прокинется во все предыдущие ашки. То есть, мы уже знаем с вами, у нас по индукции мы знаем,
что x в эстой, по предположению индукции мы знаем, что x в эстой, так о чем? Можно просто сказать,
что это по модулю, по модулю P, это мы знаем, что, это вот здесь написано, да? С с минус 1,
x в эстой минус 1, и так далее, c 0 x 0. Значит, если я беру b множитель, то b с минус 1 на x в эстой по
модулю P, это все то же самое, только коэффициент надо еще умножить на b.
Ну вот, это то же самое, что если бы мы вот это вот ас расписали через первые
члены с номерами от 0 до с минус 1. Поэтому в итоге у нас получилось, что вот этот многочлен,
после взятия его по модулю P от x, у меня получится ровно то же самое разложение его через первые
с коэффициентов, что и если бы мы разложили вот в этом вот выражении ас через первые с коэффициентов.
Нет, все нормально, я на константу умножил просто, она вот здесь везде есть. Я просто вот эту строчку
на константу умножил. Вот, ну вроде, вроде, да. Точно так же, мы же знаем, как ас раскладывается
через предыдущие. Ас это с, с минус 1, ас минус 1, плюс и так далее, плюс с нулевое, а нулевое.
То есть строчка по факту вот такая же. Теперь еще если на b с минус 1 умножить, то будет вот эта
вот строчка. Ну вот, получается, что вот это вот и вот это вот это одно и то же. Еще раз? Ну вот, ас
минус 1. А, извините, да, да, да, да. Спасибо. Вот, то есть, ну вот эти вот строчки, если взять
xс по модулю p или если ас разложить через первые с членов, получится одно и то же. Ну а ровно это
и мы хотим показать, что взять xn плюс 1 по модулю p имеет коэффициенты такие же, как разложение
ан плюс 1 по первым с членам рекуррента. Ну, на самом деле, магия здесь небольшая. Магия только
вот в этом члене, что если вы xс-то берете по модулю p, то вы получаете его разложение по первым
с коэффициентам. Выражение ас-то через первые с коэффициентов. Ну а дальше, более-менее тривиально,
если у вас это верно, то при умножении на x у вас просто проталкивается степень через предыдущие.
При взятии по модулю у вас xn плюс 1 проталкивается через предыдущие. Если каждое правильно разложилось
через предыдущие, через первые с, ну то значит это тоже разложится, грубо говоря. Вот. Хорошо,
значит это мы доказали. Теперь давайте посмотрим, как задачу теперь решать. Все готово? Значит,
смотрите, мне нужно взять многочлен вот такой вот по модулю p от x, где это многочлен степени s.
Правда? Давайте будем это делать внезапно так же, как бинарного зрения в степень. То есть,
я из такой позиции, ну смотрите, как у нас работает бинарное зрение в степень, а в n-й это
а n пополам в квадрате, если n четно. То же самое здесь, если у меня есть x в n-й и n четно,
давайте скажем, что n четно, тогда я сначала посчитаю x в степени n пополам по модулю p,
потом возведу в квадрат и еще раз возьму по модулю p. Это мне упрощает жизнь, потому что после
взятия по модулю у меня получается многочлен степени s, и возведить его в квадрат работает за s
лог s. То есть, если n очень большой, ну там, не знаю, миллиарды, десятки миллиардов, там 10 в 9,
а s какой-нибудь типа 10 в 5, ну то понятно, что возведить многочлен порядка s в квадрат легко,
более-менее, по сравнению с многочленом степени n. Вот, ну поэтому просто бинарное зрение в степень.
То есть, я делаю следующее, если n четно, то я решаю сначала такую задачу, получаю многочлен
степени s, возвожу в квадрат, делю по модулю p, все это работает за s лог s. Если n нечетно,
то я вычитаю единичку, сначала считаю x в n минус 1 по модулю p от x, получаю опять-таки многочлен
степени s, потом домножаю на x и опять беру процент. Значит, это было в случае n четно,
это в случае n нечетно. Вот. Ну дальше, как обычно, получается, хотя бы на каждой второй
итерации я n поделю пополам, значит у меня итерация всего будет порядка логарифма,
и каждая итерация работает за s лог s, потому что каждая итерация это, в худшем случае,
просто возведение в квадрат и взятие по модулю. Это я умею делать за s лог s,
где s размер многочленов. Значит, s лог s на итерацию. Ну и получается общая сложность s лог s лог n.
Потому что это бы работал за n лог n. Представьте, что n очень большое, было бы тогда n лог n. То есть,
можно было бы сразу просто поделить с помощью фурье, но это n лог n. Если n очень большое,
мы можем только логарифм от n брать, ну 8 точек в смысле включать, то вот можно так.
s лог s лог n, это уже более-менее что-то адекватное. То есть, еще раз, да, представьте себе,
что у вас есть рекуррента не очень большого порядка, там ну 100, 200, может быть 1000,
может быть 10 в пятый. Ну короче, s, что-то такое, что можно брать многочлены,
перемножать многочлены размера s. Ну а n какой-нибудь очень большой, вам надо посчитать очень большой
член рекуррента. Ну тогда вот, пожалуйста. Так, вопросы можете? Ну все тогда, спасибо.
