Сегодня, значит, на первой из двух пар мы должны разобрать два пункта и первый пункт будет
называться unions, ну по классике include eostream. У нас тема называется type erasure и что-то там
еще, я не помню. Вот и это параграф 14.3 unions and small strings optimization, что бы это не значило.
Сейчас мы познакомимся с еще одной замечательной возможностью c++. Ну кто из вас
знает что такое unions? Один человек. И что это? На самом деле unions это такая несколько
выделяющаяся тема из всех, вообще не знаю, за последние три месяца, наверное, это очень
необычная для нас тема, потому что это единственная за последние три месяца вещь, которая была еще
до c++11 изучаемая нами. На самом деле это очень древняя возможность c++, просто в силу того,
что она довольно редкая, мы ее отложили на потом. Вот, по идее про нее можно было в самом первом
семестре рассказать вместе с классами. На самом деле unions это еще один такой вид типов. Вот
бывают классы, да, бывают структуры, бывают unions. А unions это такое ключевое слово,
значит вы можете объявлять unions, ну объединение то бишь. Вот, что такое unions? Ну давайте я вот
создам такой unions, в нем будет лежать int x double y, не очень оригинально. И вот заведу объект такого
union. Ну вот первое же, что вас должно заинтересовать, это то, что размер такого будет не 16, как в случае
класса, а 8 всего лишь. А что в смысле? Double 8 занимает. Ну это конечно не специфицировано в стандарте,
но у нас 8. Вот, как это так-то? А просто union это такая штука, которая, ну если класс это вещь,
которая состоит из полей и хранит одновременно их все, то union это штука, которая в каждый момент
времени хранит что-то одно из перечисленного. Вот так. Да, поэтому я это, чтобы не шокировать вас
раньше времени, я это отложил аж на апрель. Рассказ об этой возможности замечать. Есть реально
логичный вопрос. Вот, так сказать, you are free to ask questions. Давайте, какие у вас вопросы, пожалуйста,
вот я понимаю, что у вас может это не... А она сама выбирает кого хранить? Ну если я не сказал,
что туда положить, до чертова Мексика. Слушайте, я не знаю, что с этим делать. В общем, если я не сказал,
кого туда положить, то там будет лежать вот то, что там первая перечислена. Давайте я скажу,
интекс равно 1 и double равно 3,14. Не, давайте 5, чтобы на всякий случай ничего не... А я не могу по
умолчанию инициализировать несколько членов. Ну вот да, если я так напишу, то будет 5 union не
лежать. Да, но если я ничего не написал, то отлично. Сейчас он перезвонит, смотрите.
Почему не выказывал? Я же говорю. Сейчас выйду. После этого он звонит на телефон.
Чего? Я понимаю, я знаю, что такое ног, но как ты вообще пришел к этой идее? Может просто максимум?
Я могу легко создать поле размера 3. Это массив чаров из трех чаров. Вот у меня
может быть чар С из трех. И нет, он не будет кратен трем тогда размер. Нет, размер это максимум,
ну с точки до выравнивания. Вот, хорошо. А давайте какие-нибудь примерчики разберем. У union есть
такое понятие как активный член. Это то, что лежит в нем в данный момент. Вот если я просто так
написал union по умолчанию, то активный член в нем становится первый. И я могу попросить его вывести,
я могу попросить вывести у.x. Ну выведется там рандомное число скорее всего, но это... А если ты
инициализируешь у и выведешь у.x, что будет? Будет у.b, формально, но по факту мне выведется
интовое представление дабла, что логично. Ну давайте я так напишу. У.b, видимо, потому что с другими
типами это непонятно как будет работать. Ну да, давайте вот так сделаем. Мне вывелся какой-то
int, но по сути интерпреткасс сделался из первой части дабла в int. Обращаться к тому члену union,
который в данный момент не активен, на чтение, это у.b. Я могу, впрочем, сказать у.x равно 5 и это
нормально. И если это примитивные типы, то я спокойно могу просто присваивая одному перезатирать
другой. Да, если я так делаю, то вывести его будет нормально. А если не примитивные типы становятся
интереснее. Давайте предположим, что у меня тут еще std string лежит. У которого есть прекрасные поля,
типа разумной. Да. Сейчас мы из стринга перезапишем случайно. Вот, ну во-первых, у меня сразу возникла
ошибка. Default constructor of u is implicitly deleted. Если у меня в union одним из полей является что-то
с нетривиальным конструктором, то я уже не могу создавать union по умолчанию. Мне нужно явно
определить конструктор union. Есть то есть, но он нетривиальный. Считается, что мотивацию этого,
что небезопасно так делать. Если я в union положил какие-то объекты, которые нетривиально
конструируются, а потом говорю, создай мне union по умолчанию. У тебя там случайно лежит стряка,
у которой в размере прописан миллиард. Это как-то не безопасно что ли. Мало ли что там
код конструктора делает. Если я написал u, что я хочу? Я точно хочу вызвать вот тот код конструктора,
который там происходит. Непонятно. Короче, если у меня есть какие-то более формальные требования,
возможно даже не суть в том, что конструктор нетривиальный, а что-то там более тонкое. Но
короче, я вынужден определить конструктор по умолчанию. Давайте я скажу, что там просто я
их санитализирую пятеркой и все. Все равно не могу, потому что теперь деструктор неопределен. Это,
кстати, тоже логично, потому что что делать деструктору-то тоже непонятно, но вот теперь
нормально. То есть я должен определить и конструктор, и деструктор union явно теперь. Ну,
почему я должен деструктор union явно определить? Потому что, вообще говоря, компилятор не может
знать, когда union уничтожается, надо что-то уничтожить или нет. Это просто в целях безопасности
сделано так, что я должен явно прописать, что должен делать компилятор, когда union уничтожается.
Потому что мало ли там какие-то нетривиальные поля, надо как-то нетривиально уничтожать. Пока
поля были примитивные, все было просто. А когда появилось поле какое-то вот такое, создавать,
уничтожать union стало нетривиально. Ну, короче, вот. Вот я, значит, создал union, точно также в
списке инициализации пронициализировал x. Теперь меня активен x, и я спокойненько им пользуюсь.
Вот. Ну, ничего интересного, сейчас просто пятерка выявится.
Нет. Нет, нельзя. Конечно, именно вам его и надо будет реализовать. Это пятая задача, да? Да. И как
раз о том, как это сделать, мы будем обсуждать все две пары следующие. Ну, то есть, да, в следующий
понедельник мы как раз... Сегодня вас Федя познакомит с этим замечательным объектом, так сказать,
с этой замечательной сущностью из стандартной библиотеки, а в следующий понедельник мы с вами
все три часа потратим на обсуждение, как же это реализовано. Так, а ты уезжаешь через день? Я
уезжаю, нет, вот, послезавтра. И в следующий раз у нас уже должен быть онлайн. Ну, если все стоит,
там еще, возможно, что-то... Просто непонятно, как это все будет. Ой, да господи. Ну, господи,
сдвинем их попозже, если там, чтобы вам удобно было доехать, докуда надо. Короче, разберемся.
Вот. Ну, тут все понятно. Да, чем плохи юнионы, тем, что никак не поймешь, кто активен, это вы
должны сами как-то запоминать где-то. Ну, вот вам нужно как-то... Например, вы можете хранить структуру,
в которую хранить тег и юнион. И этот тег будет показывать, какой член активен. Это называется
тег и юнион. И это, в общем-то, иногда используется. Вот. Давайте разберем более интересный пример.
Смотрите. Допустим, я сделал вот так, проинстилизировал у х, проинстилизировал пятеркой, а дальше
решил, что мне надо бы строку чем-то проинстилизировать. И решил вывести х. Ну, не х, строку. То есть,
я что решил сделать? Я такой, окей, у меня активный член х, а еще там лежит строка. Ну, все. Я хочу
теперь, чтобы строка была активной. Давайте я строку вот теперь сделаю активной и выведу. Может быть,
кто-то догадается, что сейчас будет не так? Ну, видимо, там вызывается оператор копирования,
а не... Оператор присваивания. Точно. Да, оператор присваивания. Конечно, конечно, конечно. Это классическая
ошибка при использовании юниона, да, и такой главный вопрос на понимание. Вот. Почему так очень плохо?
Нет, стоп. Ну, убивает то, что лежит по указателю. Это классическая ошибка, когда вы вместо того,
чтобы делать placement new, делаете присваивание. Вы взяли и присвоили. Но что это такое? Это оператор
присваивания, у которого левый оперант стринг и правый оперант стринг. То есть, вызывается оператор
присваивания стринг от стринг. То есть, первым делом делается delete квадратной скобочки на
pointer. А там не pointer, там int, там лежит пятерка. Ну и все, значит. Set fold. Как же быть? Что же делать?
Как же? Как же нам вместо int положить страху? Но я уже сказал, placement new надо использовать.
Нужно сказать new по адресу вот этой строки.
Std string. Ну, я в new хочу отдать указатель на t, то есть на то, что я создаю от abc. Вот.
И мы должны сами же это чистить. Конечно. Вот. Сейчас будет, казалось бы, все нормально.
Но только утечка памяти, да. Потому что деструктор строки, конечно же, никто не вызвал. В деструкторе
union ничего не происходит. Я могу, конечно, здесь вызывать деструктор строки, но... А всегда ли она
инициативой? Да, а если строка сейчас неактивна. Поэтому, чтобы все было корректно, мне нужно эту строку
и уничтожить вручную. А как это сделать? u.str. Что? Давайте, давайте, это уже вопрос на понимание.
Что надо написать? u.str. Что? Тильда что? Нет. Нет. Такой функции tilde string. Есть функция tilde
basic string с шаблонным параметром char. Вот. Вот теперь все нормально. Если бы я написал tilde string,
это бы не скомпилировалось. А разве не нужно писать tilde std basic string? Нет, потому что мы уже в пространстве
std когда вошли в .str. Ага, окей. Ну вот, ну, как вы уже видите, что expected class name string это не
class name, это using. Такие дела. Вот так. Очень странно, что using не прокатывает, потому что теоретически это реализуемо.
Ну, давайте теперь посмотрим немножечко на cbp-reference и остальные возможности, так сказать, в формате
быстро пробежимся. А что еще может быть в unions? Ну, unions могут иметь функции члены,
включая конструкторы и деструкторы, но не виртуальные функции. Union не может ни от кого
наследоваться и от union нельзя наследоваться. У union не может быть нестатических членов ссылок.
До C++11 unions не могут содержать нестатический член, у которого не трев... О, до C++11 нельзя было делать
string, полем union, но начиная с C++11, если union такой член содержит, то тогда соответствующая функция в
union как раз удалена по умолчанию и нужна вот, нужна это в определении явно. То есть мы добавили
полем string, это значит, что все то, что у string нетривиальное, копимув конструктор, копимув сайны,
деструктор, все это сразу у нашего union стало implicitly deleted и мы должны явно это определять.
Вот, так же как и в структуре, да в union могут быть модификаторы доступа, правила public,
но по умолчанию так же как и в структуре все публичное. Вот, для чего нужны union?
Илья, а что мешало union сгенерить такой же конструктор и деструктор, как вот то, что мы написали?
Что значит такой же деструктор? Ну, имеется в виду, что если бы была конструктура и мы напишем то же самое, то у нас как бы оно все само сгенерится, а то оно почему-то запрещено, почему-то.
Потому что комитет... Ну, а почему бы... Зачем генерировать конструктор и деструктор, который заведомо скорее всего делает что-то неправильное?
Если ты добавил в union член с нетривиальным конструктором, то скорее всего... Ну, это что-то наподобие правила трех, ну, типа, однажды мы уже обожглись очень сильно о том, что компилятор генерировал за нас копий конструктор в случае, когда он скорее всего бы неправильно работал, и после этого у нас куча багов.
Зачем компилятору генерировать конструктор, если ситуация явно подозрительная? Компилятор уж лучше скажет нам, чувак, задумайся, что должно здесь происходить, а не я по умолчанию сделаю что-то от балды. Ну, мне кажется, это поведение очень логично.
Открывай, пожалуйста, код, который... Вот, если заменить union на struct и стереть конструктор и деструктор, что будет работать?
Да.
Вот, еще раз, я не понимаю мотивации, почему, если мы меняем на union, то уже не работает?
Потому что в struct однозначно понятно, что делать, нужно проинitiциализировать все, а когда мы заканчиваем, нужно уничтожить все. А в union, вот union, допустим, выходит из области видимости, нужно уничтожить не все, а что-то одно, что?
Нужно уничтожать string или не нужно, когда мы у union заканчиваем область видимости? Не понятно. Вот здесь должен называться деструктор string или не должен? Не понятно.
Если он будет не вызывать никакой деструктор, то, вероятно, это будет утечка памяти у нас постоянно. Если он будет вызывать все, ну, какой-то деструктор от балды, то это будет seg-fall в половине случаев. Он не может сам отгадать, что делать здесь.
А в данном случае он не вызывает никакого?
В данном случае я написал пустой деструктор, он ничего не делает, да. Поэтому, чтобы у меня утечку памяти избежать, мне нужно вручную вызывать деструктор поля, вот так вот.
Ну, то есть вообще union это какая-то очень тупая обертка над старой памятью.
Да, union обычно используется в низкоуровневом коде, когда вам нужно экономить память. Ну, когда у вас по одному и тому же адресу может лежать что-то из перечисленных, у нас может лежать числа там с разными значениями, либо число, либо символ, ну не знаю.
В общем, когда у вас какая-то вот структурка, в которой одно из полей бывает то одним, то другим, для этого использовались union.
Я вам сейчас покажу...
Сейчас, можно вопрос?
Ну?
Как у нас вообще может быть что-то нетривеленное в деструкторе, если это зависит от того, в какой поле активно?
Кто может?
Ну, вот вне у.
Тильда у.
Да.
Ну, он не генерирует никакой деструктор, ты сам должен написать.
Ну, я не знаю, ну, напиши что, ну, хорошо, не можете, можете написать, можете не написать.
Нет, у тебя могут быть какие-то другие знания, у тебя может быть какие-то там данные, исходя из которых ты понимаешь, что сейчас нужно уничтожить, что не нужно уничтожать.
Компилятор за тебя, конечно же, этого не знает.
Давайте все, пожалуйста, остальное в перерыве, иначе мы не продвинемся.
Простите.
Пойдем дальше.
Так вот, у нас есть, значит, ну, вот тут описано, как начинается и заканчивается время жизни членов, есть анонимные юнионы.
Это прекрасная вещь.
Для чего это надо?
Для чего это надо?
Ну, это надо...
Смотрите, да, вот есть такая штука еще.
Когда вы хотите на стеке положить либо инк, либо какую-то сейчас звездочку, то есть вы как бы в область видимости локальную внесли сразу и а, и п, но они на одном и том же адресе оказались.
Вот.
Это вот так можно использовать.
А зачем бы так нужно делать?
А почему здесь нет такой проблемы, что мы присваиваем?
Потому что здесь тривиальные поля.
Здесь конс, чай, звездочка.
Нету никаких объектов в полях.
Вот, ну вот, вот паттерн, о котором я говорил.
TaggedUnion, то есть у меня структура, в которой есть ену, ну, маленькая чиселка, которая говорит, что сейчас лежит, а дальше юнион, в котором что-то лежит.
И таким образом мы можем на одной и той же памяти хранить что-то из трех и, глядя на первый там битик, допустим, нашей структуры, смотреть, что там лежит.
Как-то понимать.
Например, вот так.
Это, конечно, довольно уродская конструкция, но вот как есть.
А сейчас я вам покажу одну...
Сейчас я вам, в общем, как сказать?
Я подниму на новый уровень ваше представление о базовых вещах, так сказать.
Вы хорошо знаете, как устроен класс StdString?
Вы его в первом семестре реализовывали?
Нет.
Там была пометка, что это очень непрощенно.
А вот и нет.
Вот на самом деле в классе String используются юнионы.
Да.
Отгадайте, зачем.
Вот я сейчас я открою...
Я сейчас на ваших глазах открою код Basic String, и мы там найдем слово Union в коде.
Зачем оно там?
Возможно, смысл в том, чтобы, типа, когда мы строковый ветерал, от него, допустим, конструируемся...
Так.
...конструировать его, а просто условно сохранить, что...
Ну вот есть этот строковый ветерал, тогда мы знаем, что он в тексте хранится и никогда не поменяется.
Э-э-э...
Нет, это не так.
Так не работает.
Ну, то, что ты называешь...
То, что ты говоришь, это называется, скорее, оптимизацией Copy on Write.
Типа, не копировать, пока нас не попросили изменить.
Вот.
Ну, тебе же, если я попрошу квадратными скобочками что-то присвоить, то мне придется копию создать.
То есть, получается, что обращение квадратными скобочками присваивания по индексу иногда будет занимать линейное время в твоей реализации.
Так не пойдет.
Но так некоторые строки реализованы.
Одна из возможных оптимизаций реализации строка называется Copy on Write Optimization.
Cal Optimization.
C-O-W.
Кстати, очень полезная штука.
Тоже на собеседованиях можно выпендриваться этим знанием.
Но...
А если мы в конец стринк операционства будем передаем строковый ветерал, там может как-то отмениваться?
Господа, подсказка...
Подсказка написана в названии параграфа.
Вот, смотрите.
Кто слышал когда-нибудь такой термин?
Small Strings Optimization.
А если у нас очень маленькая строка...
Если у нас строка очень маленькая,
нафига под нее динамическую память выделять?
Если у нас строка, например, длины 3,
то она уместится на те 8 байт, на которые мы обычно указатель кладем.
Чего?
Ну что, это сильно ускоряет?
Конечно.
Конечно, это сильно ускоряет.
Если у вас маленькие строки, то под них не надо выделять динамическую память.
Боже...
И вы не смейтесь.
Вам это сейчас кажется извращенным,
но это как раз очень и очень правильно.
Это так все нормальные строки реализованы.
Вот, наоборот, строка, которая так не реализована,
плоха очень.
А?
Когда-то раньше ты нам говорил, что есть еще указательные члены в строках.
Нет, указательные члены...
А, что одно из полей строка...
Да.
Да, да, да, да.
Ты проховал, да, ты проховал жизнь.
Сейчас, сейчас до этого дойдем.
А можно мне тоже?
Сейчас, я говорю, сейчас до этого дойдем.
Я сначала вам покажу, что в строке реально написано.
Тихо.
Давайте я просто сейчас воспользуюсь магией,
Господи, которая мне позволяет мой новый чудо Vim,
и открою код Basic String.
Вот.
И тут я найду слово Union.
Я, к сожалению, не помню, как между вкладками Vim переключаться.
Control-V и вниз или вверх.
Control-V...
Что?
Control-V?
Control-V.
Control-V.
Control-W.
Control-W.
Control-W.
И J.
И ну туда-сюда, вверх-вниз.
Сейчас J-T.
О, отлично.
Я сейчас выйду отсюда и останусь вот здесь.
Спасибо.
Мы оказались с вами в коде STD String.
Наконец-то.
Смотрите, что тут написано.
Это...
Это...
Да, ну, во-первых, тут есть замечательная структурка ElogHider.
Вы уже догадываетесь, зачем она нужна.
Это MTBase Optimization.
Здесь есть структурка ElogHider, которая наследуется от Allocator.
И в ней хранится Pointer.
Значит...
Блин, тудуховы стояли в ском-коде, это смешно.
Итак.
Да нет, их там полно.
У нас есть ElogHider, mdata+, а еще size-t string-length.
А дальше у нас лежит следующая штука.
Union из local-buffer размера local-capacity-plus-1, а также size-t-capacity.
То есть, у нас на одном и том же адресе...
Это анонимный Union.
То есть, у нас на одном и том же адресе лежит size-t cap, то самое вот это capacity.
Господи, где мы?
А, ну, потому что нам реально capacity не нужно.
Да.
У нас на одном и том же адресе лежит число capacity, то что у нас называлось cap,
и массив local-buff размера local-capacity-plus-1.
Вот.
И как работает, значит, например, обращение по индексу.
Давайте я найду оператор.
Квадратные скобочки.
Return mData, круглые скобочки, по индексу pos.
А что такое mData?
А эта функция такая.
Ой, не сработало.
Ладно.
Так, а чего?
Что-то мне не находишь определение.
А, вот, наверное, вот оно.
Return mData-plus-mp.
А, что такое mData-plus, давайте вспомним?
Это pointer-mp.
Короче, что такое data-plus?
Это pointer в data-plus лежит, вот этот pointer, он указывает либо на вот этот local-buff,
либо куда-то вовне.
Значит, как он проверяет?
Ну, то есть, понятная идея, у вас что должно быть?
У вас есть поле size.
У вас есть поле size, которое хранит размер строки.
И еще есть у вас pointer.
А также у вас есть поле capacity.
Так вот, если ваш размер меньше, чем то, что вы можете вместить в size-of-size-t,
то вам незачем выделять динамическую память.
Вам можно на тех битах, на которых вы храните capacity, хранить саму строку,
а pointer будет указывать вот именно на это место.
То есть, ваш pointer указывает на то самое поле, на другое поле вас же.
А capacity тут написано 15 делить на size-of-charter.
Почему 15? Потому что... Почему, кстати, 15?
Ну да, потому что там еще на trailing 0, значит, сколько-то выделено.
Смотри, у тебя есть...
Я кто-то писал?
У тебя есть size-t, size, у тебя есть size-t-s-s.
Вот размер строки ты всегда знаешь, ты его ничем не переписываешь.
У тебя есть charge-звездочка-ptr и union, где лежит либо size-t-cap,
либо charge-buffer размера, ну сколько-то там, 8.
И вот этот... Ты смотришь на size-e и понимаешь, если твой size-e меньше, чем вот этот размер буфера локального,
то pointer у тебя просто указывает вот на это место, то есть на твое же другое поле.
А если size-e больше, то ты понимаешь, что ты находишься в другой ситуации,
и по этим bit-ам у тебя лежит число capacity, а не строка, а строка лежит там, где я pointer указываю.
Понятно? Это называется small strings optimization.
И это, на самом деле, очень распространенная оптимизация, так устроены...
Ну, все нормальные строки, короче, так устроены, иначе это очень эффективные строки.
Та строка, которую вы писали в первом семестре, была отвратительной.
Вот вопрос. Все строки, какие есть?
Ну все адекватные строки. Ну и, господи, открой любой большой проект.
Яндекс, Google, там, не знаю, кто угодно, VK, что угодно, Telegram, там ты найдешь кучу реализации класса string.
Не знаю, qt, мне нравится qstring, например.
Ну, типа, ну каждый просто реализует строку кто во что гора.
Стандартная строка многих не устраивает, кто-то там хочет ее как-то заоптимизировать еще.
Ну, короче, не важно.
Честно, он же, кажется, не может по размеру узнавать в каком сейчас состоянии, если...
Может он по размеру узнавать в каком состоянии.
Мы же можем попбэкать эти строки, да, или как?
Ну, как только вы попбэкаете, вы переходите в ста...
Если вы понимаете, что превзошли размер, то все, вы выделяете домическую память.
Нет, в смысле, это есть ужбэк, а есть попбэк.
Мы уменьшили размер, да, размера маленькой строки.
Значит, если вы сделали попбэк, ну он должен это поддержать.
Значит, если вы сделали...
Да, если...
Да, если вы сделали попбэк, у вас размер уменьшился, но, видимо, он должен переложить.
Ну, то есть, по СЗ он должен как-то это понимать.
То есть, да, кстати, на размере 8...
Сука, там 16.
Если мы делаем попбэк, пушбэк, попбэк, пушбэк, то он перекладывает каждый раз?
Ну да.
Я понимаю, почему многих не устраивает стандартная строка.
Я, кстати, не знаю, это хороший вопрос, можно посмотреть, что он делает.
В смысле, ты так будешь делать в нормальном ходе?
Это работает за от 80.
Так, господа.
Спасибо.
Да, ну еще тут аллок-хайдер, но аллок-хайдер понятно зачем.
Так, господа, господа, господа.
Теперь, вот, значит, господин Андрусов, да, прохавал жизнь.
Сейчас вы это тоже прохаваете.
Помните, мы с вами, я вскользь упоминал в очередной раз про пушбэк.
В очередной раз наши бараны про пушбэк.
Я говорил, помните, мы когда в пушбэке делали мем CPI?
Я говорил, нельзя делать мем CPI.
Это уже для СТ стринга работать не будет.
Так вот, поэтому и не будет.
У вас стринг является типом, у которого одно из полей может быть поинтером на другое поле?
Поэтому, если вы строки копируете мем CPI-м, STD-шные, у вас уже УБ.
Ой, понятно?
То есть, строка, STD-шная строка, самая что ни на есть обычная STD-шная строка.
Так устроено, что одно из ее полей является, вообще говоря, поинтером на другое ее же поле.
И если вы такую строку мем CPI-м будете копировать, у вас УБ.
И настоящий самый УБ, вы сломаете все.
Такие дела.
То есть, стринг является как раз примером такого самого типа, который...
Ну и любой тип, у которого small object optimization, является примером такого типа.
Вот это то, что я хотел вам рассказать про union и про small object optimization.
Вот.
А теперь мы с вами поговорим о том, как реализовать STD-фанкшн.
Это то, что я вам обещал в прошлый раз.
Помните такой тип STD-фанкшн?
Вот.
Теперь мы сможем наконец реализовать его полноценно.
Да.
Ну, я говорил, что вообще реализовать STD-фанкшн – это хорошая задача содержательная.
Но вам и так задач хватает, поэтому не будем.
Ладно.
Смотрите.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Вот.
Ладно.
Спасибо.
STD-фанкшн.
Напоминаю, это тип, который может хранить себе любой
callable-объект и подменять его один на другой в рантайме.
Я просто ржу, что мы в четвером отновременно этим занимаемся.
Так.
Значит.
Во-первых.
Если моя фанкшн использована не с теми шаблонными параметрами,
Рабочая является только специализацией STD-фанкшн от таких
параметров.
Так.
Резулт.
Да.
Класс.
Резулт.
Значит.
Да.
Вот.
Если фанкшн.
С любыми параметрами, с которыми нас устраивают,
то это CE.
Фанкшн только вот от такого шаблонного параметра
это не CE.
Просто это мы оставим без реализации, и все.
Хорошо.
Сейчас.
Шаблонный параметр это что?
Это функция ResultAttacks.
Ну.
Сейчас.
Мы обсуждали фанкшн, и в прошлый раз тебя не было,
кажется.
Поэтому сорян.
Давайте подумаем, какие поля.
Ну кто помнит TypeRage, о чем мы должны хранить.
Не, ну давайте нормально.
Мы уже реализовывали похожие вещи.
Сначала мы реализуем как умеем.
Значит у нас будет template.
У нас будет базовый класс.
Ну он будет.
Будет ли он шаблонным?
Хороший вопрос.
А зачем базовый шаблонный делать?
Наверное не будет, да.
StructBase, в которое будет virtual.
Base.
Ну давайте я все-таки назову не Base, а BaseFunktor.
BaseFunktor равно Default.
Ну нам еще что-то потребуется, но пока отложим этот вопрос.
Вот.
И теперь у нас будет template.
Шаблонный класс.
Derived.
С каким шаблонным параметром?
Наверное с шаблонным параметром Funktor.
Давайте скажу с шаблонным параметром F.
StructDerived.
Funktor.
Это наследник BaseFunktor.
Вот.
И в нем будет лежать F.
Правильно.
Ну классический type arranger.
Да?
Что мы будем хранить в полях?
В полях мы будем хранить указатель на BaseFunktor.
FPTR.
Вот.
Как будет устроено наше все.
Что мы должны делать?
Я пока даже ничего нового.
Все это мы в прошлый раз обсуждали.
Я пока никаких новых идей не добавляю к тому, что мы в прошлый раз обсуждали.
Ну давайте напишем что-нибудь.
Давайте напишем например конструктор.
Ну да.
Вот здесь какие должны быть методы.
Самое главное, что должно быть у нашего функтора?
Оператор круглые скобочки.
Ну это значит что у BaseFunkтора должны быть круглые скобочки виртуальные тоже.
Virtual.
Дальше что?
Какой тип?
Возвращаемый.
Result.
Оператор круглые скобочки.
От каких аргументов?
По какой ссылке нужно принимать ARKS?
По универсальной ссылке.
Только она должна быть параметром самого...
Да, это отличное замечание.
Но...
Кстати вот с этим проблемком.
Потому что...
Нам очень хочется форму использовать, да?
Ну нам конечно хочется использовать форму.
Ладно, давайте отложим этот вопрос в какой-то сложный вопрос, что-то я над ним не подумал.
Давайте пока так делать.
Нет, это как-то ужасно.
Сейчас.
Что будет, если я...
Сюда присоединяюсь?
Нет.
Нет.
Нет.
Нет.
Нет.
Сюда приму параметры по...
По какой ссылке?
Да, это какая-то неловкая ситуация, слушайте.
Ладно, мы эту проблему все равно решим сегодня.
И...
Значит...
Давайте пока оставим.
Равно нулю.
To do.
Forwarding reference.
Вы понимаете проблему?
Мы не хотим копировать то, что можно можно.
Да, а проблема, почему я не могу написать тимплейт?
Ну, если я напишу тимплейт, вот это вот.
Virtual result operator круглой скобочки.
Что вообще значит, что виртуальный метод является шаблонным?
То есть компилятор должен...
Ну, это причем еще pure virtual метод, являющийся шаблоном.
То есть, по сути, каждый из наших игр должен объявлять
какой же шаблон, где идет себя конструктор.
Все, которые мы вызываем, в принципе.
Да.
Ну, хотя он вообще может, когда-нибудь определяйте.
Сейчас, я что-то туплю.
Может, это и будет работать?
Нет, кажется прям явных проблем.
Если я сделаю...
Давайте, господи, давайте я попробую.
Template type name многоточие new arcs.
И вот здесь напишу new arcs.
И попробую это скомпилировать.
Ну, вот.
В общем.
Можно и не гадать.
Не могут функции члены быть шаблонными.
Виртуальные.
Короче, эту проблему нам придется пока оставить.
Но он просто не сможет.
Это несочетаемые вещи.
Ему надо, с одной стороны, в compile-time-е знать,
все типы, с которыми он вызывается.
А с другой стороны, он виртуальный.
Это значит, что он может вызываться с типом,
не соответствующим реальному типу того,
от чего его вызвали.
Ему нужно в virtual table ходить.
Ну, все нормально.
Всем детям просто просчитываем эти вызовицы.
В смысле.
Потому что мы подставили всем детям этот аргумент.
Ну, все нормально.
Ну, все нормально.
Ну, все нормально.
Ну, все нормально.
То есть объявляем этот аргумент.
Теоретически это сочетаемый?
Вопрос на сколько мы этого хотим просто.
Ну, вот.
Короче.
Мне кажется, что там есть какая-то проблема.
Не кажется, скорее всего, там есть
проблема, которую я сейчас忘 heл.
Почему это не получается сделать?
Но короче, так или иначе,
это ошибка в компиляции.
Нам пока придется с этим жить.
да ст функшен и вы от аркс двойной персант вызываетесь кстати давайте
проверим это у нас вот как раз страничка заготовлена а функшен вот у
меня есть оператор круглые скобочки и он ха смешно сильно
это прям очень сильное утверждение а так подождите кажется это будет
нормально работать если я передал по ссылке но это кстати кажется будет
нормально работать как раз по той причине помните я говорил что есть такой тоже
способ когда вы принимаете по значению если вам мунули то вы рвл ее отдадите а
если вы лвл и ссылку отдали то значит скопируется да другой вопрос что вам
придется именно явно отдавать лвл и ссылку туда потому что если вы отдадите
просто что-то лвл и тип все равно выведется как а нет господи все все
нормально мы мы все тупим аркса даже шаблонные параметры класса если у меня f
от шаблонных если у меня функцион от шаблонных параметра допустим им персант
им персант то аркста будет сам персантами и все нормально и форвэд их
поразнёт правильно то есть у меня если я хочу ссылки принимать параметры
функции то это уже закодировано в типе аркс поэтому мне не нужно указывать этот
тип когда я вызываюсь этот аркс он уже в классе да смотрите еще раз я вот как
пользуюсь этим я говорю int main и говорю там std function допустим я хочу чтобы она
там void была от int амперсант int 2 амперсанда f вот эти аркс выведутся как
int амперсант int 2 амперсанда у меня аркс будут сам персантами уже все они с
амперсантами амперсант никуда не деваются теперь везде где я пишу аркс
амперсанты сохраняются вывод типа в заново не происходит я явно указал типа
когда класс объявлял конечно поэтому здесь все ссылки сохранятся поэтому аркс по значению но
по факту аргументы при этом могут быть посылки и все нормально и форвард корректин в этой
ситуации поэтому проблемы нет все проблема решена мы будем форвардить и все будет нормально
работать потому что если там lvl и ссылка она форварднется правильно понятно кто понял
давайте дальше ну пересмотрите давайте дальше давайте дальше значит result оператор круглой
скобочки override что мы тут должны делать а оператор круглой скобочки от аркс
аркс override что мы тут должны делать
но вызвать f от аркс только астеса форвард от аркс
правильно
а я не там скобку закрыл так нормально все понятно
кто успевает следить за происходящим кого смущает то что я написал до корректора
да ретерн надо сделать конечно а если там void это нормально это он void
кого смущает то что я написал никого не смущает все нормально вроде написал то так на самом деле
здесь есть одна один косячок у нас f да хранится конечно как объект хранится
f это может быть либо функциональный объект полноценный либо function pointer либо лямбда
функция либо еще ну либо closure объект либо bind объект помните bind вот ну в общем да
рво здесь здесь ну если я возвращает рвл ю то да конечно а если не рвл ю то ну если
f возвращает пьюр рвл ю то да а если все остальное то нет какой рвл так еще вопросы
давайте дальше диструктор а диструктор можно не писать потому что все и так корректно отработает
правда же все давайте напишем конструктор function наконец function от чего но он шаблонный должен
быть template type name functor function от чего
ну я function могу сконструировать от любого объекта от любого коллабел объекта от любого
коллабел объекта да значит f равно там не знаю круглые скобочки int x int y return x меньше y
да ну это я показываю пример как я мог бы использовать function вот мне нужно сделать
function конструктор от чего потому что он function не за inclusion вот по какой ссылке надо
принять functor ну по идее нам нужно уметь и по рвл ю и по лвл ю ссылки принимать на самом деле
здесь по универсальной можно принять вполне мы его форварднём но то есть нам надо вот этот
functor положить как поле в класс derived functor мы его форварднём сейчас туда мы его мувнем либо
скопируем в зависимости от того по какой ссылке приняли только нам надо стать и кассирт знаете
какой стд из инвокабл да из инвокабл от f от functor с нашими аргументами ну
ну можно и это проверить ну давайте это оставим ну потому что будет ошибка потому что ошибка
будет во первых пока я не вызвал ее я должен не уметь создаваться с такими типами если я
создался но ни разу не вызвал это у меня не упадет все равно нужно упасть но я не инстанцировал там
этот ну хотя нет если я подставлю в derived functor ну да да да это все равно упадет согласен я же
инстанцировал все равно но ошибка компиляции будет некрасивая лучше ловить таки но на самом
деле спойлер мы с вами скоро пройдем ну как скоро достаточно скоро уже концепты и у нас
будет вообще очень вообще 2 знака подчеркивания из инвокабл возможно потому что этот подсказчик
не обладает и плюс 17 ну давайте я вам покажу из инвокабл значит есть такой type 3 и мы его
конечно же тоже научимся реализовывать а вскоре нам уже нам уже это вот вот предстоит но это
начинается плюс 17 метафункция которая проверяет правда ли функция ну правда ли этот класс вызываем
колобл с такими параметрами вот тут тут есть много странных уточнений которые мы пока не будем
обсуждать короче ладно а ну нету так нету такого type 3 ты не знаешь так не знаешь о нем как
говорится что мы делаем мы должны про инициализировать что fptr new derived functor
с шаблонным параметром functor от чего std forward от шаблонным параметром functor от functor
а и тут мы понимаем что нам конструктора не хватает в этом классе давайте его напишем
derived functor чего где фигурные скобки писать а зачем нам конструктор а нельзя фигурные скобки
написать если ты хочешь чтобы я вот так сделал типа вот так кстати не знаю так я не там скобки
поставил вот так не сделал а нет к сожалению так нельзя я думаю нельзя потому что виртуальные
функции есть ну короче для структуру мне кажется для структуры с виртуальными функциями
еще и шаблонных это уже не работает короче нет конструктор все-таки нужен давайте его напишем
ну давайте напишем derived functor от а что мы тут можем написать а мы можем f просто
принять по значению как раз и сделать f от std move от f правда мне кажется так будет работать
ну то и ну я для краткости по-хорошему надо написать конструктор от const f амперсанта от f2
амперсанта и в одном случае к этому другому но я могу так сказать почему это будет работать
понимаете ну потому что если я форвард ну форвард сработал как муф я передал x value здесь
я спронициализировал f от x value то есть муфнул уже и это f тоже муфнул но если я скопировал то
все равно я один раз копирую когда передал сюда а здесь уже муфну то есть не покопирую
в целом один лишний муф но да ну мы считаем что типа поддержит муф семантику короче понятно вот ну
вот пожалуйста function минимальный реализа да но еще оператор круглой скобочки нужен давайте сделаем
оператор круглой скобочки result оператор круглой скобочки от arcs многоточие arcs вопрос const или
вот короче тут какая-то очень тонкая грань на самом деле это константный оператор так по
стандарту сказано возможно это ошибка разработчиков стандарт ну короче круглой
скобочки function это константный оператор просто если бы он был не константным то приняв
function куда-либо по константной ссылке вы бы не могли его от него вызывать круглой скобочки это
проблема а почему мы вообще можем не ходить в общем это константный оператор просто примите
это что мы должны сделать мы же мы должны что и это все что мы требуем в константности
ну фптр же мы не меняем никак не меняем да фптр мы не меняем это все что мы требуем когда
навешиваем констант да ну все нормально да поэтому тут констант такое а о чем делаем
return фптр оператор круглые скобочки под чего стд форвард от arcs от arcs многоточие точка
запятой может это не ошибка ну это ну это не возможно нужно было сделать два оператора
круглой скобочки один коз другой не конст зачем нам не константный ну просто в чем смысл
почему она может быть не констант почему можем хотеть точнее не констант
просто честно мне понятен смысл нет но вообще кажется что это странно что мы у
него у нас константный пункшен мы вызываем константный метод что-то меняется под указателем
слушайте я понимаю ну короче вот просто примите как факт это константный оператор можно
философствовать на тему правильно это или неправильно идеологически ну короче это
константный оператор для того чтобы по конст ссылке можно было функции куда-то
передавать и там вызывать скобки хорошо этим тогда вообще отлично то есть все никаких вопросов
у вас нет давайте дальше потому что нам самое интересное впереди на самом деле давайте
диструктор быстренько напишем function диструктор что он делает delete fptr ну дальше надо написать
конструктор копирования конструктор перемещения оператор копирующего присваивания оператор
перемещающего присваивания но в общем да это не интересная часть давайте поговорим о некоторых
так сказать как говорят на западе concerns вот у нас тут new не наводит ли это вас на мысль что
нужно что-то еще добавить а локатор добавить да кажется я вам уже рассказывал про эту историю
я вам рассказывал правда был раньше такой конструктор у function с нестандартным
локатором он был начиная с до function появилась тоже c++ 11 но это мы уже обсуждали он был до
c++ 17 помните почему нам говорил в общем комитет понял что перестарались они добавлять тела
локаторы везде везде где ни попадя разработчики компилятор сказали шоке нет вы нет добавить
локатор function как-нибудь потом в общем они так и не добавили нормально и короче это удалились
стандартно просто ну короче не получилось function не поддерживает нестандартные локаторы
потому что это была гиблая идея да да компилятор и ну потому что нам бы сейчас на один указатель
нестандартный локатор держит вот другая проблема но давайте какие вы здесь видите проблемы какие два
класса по другому ты не сможешь подменять на самом деле то о чем он говорит это правильно ты был
в прошлый раз а тогда все понятно но мы в прошлый раз обсуждали ну блин плохо но надо ты упустил
важную часть рассуждений ну я не выложили да видимо нам нужен type erasure потому что нам
нужно как-то динамически подменять тип который у нас хранится и деструктор вызывать под
правильного типа когда мы подменяем одно другим вот ну когда нам говорят function вот давайте
я напишу function % оператор равно от const function other вот тут интересно потому что мне
надо сделать delete fptr а потом сказать fptr равно new derived functor
да ну много чего там еще но exception и проверить там и так далее но в общем new derived functor
а шаблонным параметром кстати с каким шаблонным параметром нам надо other стрелочек
outer.fptr getCopy помните да такое скорее всего так да ну вот у нас здесь еще должен быть метод сделай копию
ладно что-то я это не хочу ну в общем короче вы помните про эту проблему но проблем пока
проблем пока не в этом тут есть проблемы и посерьезней это не эффективно очень скажите
пожалуйста вы часто в своей жизни встречали функции или функциональные объекты которые
весят больше чем 8 байт большинство функции это либо просто поинтеры на самом деле либо лябды
в которых либо ничего не захвачено либо ну максимум чиселка какая-нибудь захвачена или еще
какой-нибудь поинтер но функции которые весят ну хорошо больше чем 16 байт очень мало а мы
здесь выделяем динамическую память на каждую сущность то есть даже если я функции присваиваю
обычный сишный поинтер я выделяю динамическую память здесь просто кричит просто вот просто
просто красная лампочка мигает small objects optimization конечно же function обязательно нужно не выделять
динамическую память если можно иначе будет совершенно никуда не годный класс его на помойку
выкинуть сразу же никто не будет пользу такой функции вы хотите чтобы функция она не выделяла
динамическую память на каждый значит на хранение 8 байтного поинтера то есть у вас функция хранит
поинтер по которому лежит поинтер по которому лежит нет не так должно работать должен быть
small objects optimization у меня должен быть здесь union конечно же он должен быть это логично но нафиг
либо указатель на base functor либо массив чаров размера ну скажем 16 ну только elines ну тут
нужно есть такой класс elines storage ну давайте я скажу elines std max elines t можно и так сказать
чар кстати кажется это можно писать ладно чар размера ну 16 чар буф 16 локал буф
вот непонятно что max elines t где лежит max elines t напомните пожалуйста
почему ты скобку не закрыл как не закрыл а хорошо все остальное были мне понятно new может
я уже пытался
hunks max elines thanks
Так вот, а как нам понимать, в какой из двух ситуаций
Мы находимся по сайзов, увидимого
Ну можно хранить булл, да, в принципе
Вообще, кстати, кажется, это даже можно нигде не хранить
Смотрите, правда ли, что когда мы создаёмся от функтора, мы же...
А, нет, никак не проверять не получится, потому что мы...
Мы должны проверить, понимать, мы в ситуации локал или нет
Ну давайте, да, ну хорошо, давайте вот здесь поймём
Вот смотрите, вот что я делаю здесь
Я говорю, если... Тут мне уже придётся, видимо, в теле конструктора код писать
Очень жаль
Удалю это нафиг
Если constexpr
Ну давайте я напишу static const size t local boof size равно 16
А зачем они быстрее для этого сделали непременную, а енуф всего одно значение
Не знаю
Значит, if constexpr...
If constexpr что?
If constexpr sizeof functor меньше или равен, чем local boof size
То мне не надо создавать никакой new
Мне надо просто сказать placement new по адресу local boof
Что?
A functor от std forward от functor от functor
Как это прекрасно пишется всё, конечно
А иначе я уже делаю вот это
Но только я пишу равно здесь
Вот, а теперь как мне...
Опять в операторе круглые скобочки, что мне надо делать?
Опять if constexpr
И if constexpr sizeof functor меньше или равно, чем local
Какой functor? У нас уже нет functor
Во, да, у нас нет functor, и что делать?
И как понимать тогда?
То есть мне всё-таки нужен какой-то bool
Кто говорил, что bool не нужен?
Либо bool храним, либо sizef, но кажется, что bool не хруст
Привет, друзья!
Здрасте
Значит, if local равно true, а здесь if local равно false
Ну и дальше, что понятно, в принципе, можно не писать
Ну давайте для примера напишу
Тут будет to do if local
А если constexpr?
Тут уже не constexpr, к сожалению, а просто if
if local
то
то что?
to reinterpret cast
ну reinterpret cast
к чему?
к functor
ampersand
отлов
А, да, отличный вопрос
Так, и что же делать?
А мы не знаем проблемы
Ну base functor
Кажется, надо не так делать
Кажется, надо, чтобы base functor всё-таки был
Просто указывал в одном из случаев тоже на наше другое поле
Да, давай, а, ой
Так мы тогда ничего не выиграли
Ну оно будет всё ещё локальное
Да, мы динамическую память просто не кладём
Да, так не получится, то есть base functor в любом случае
Вот этот FPTR в любом случае нужен
А в чём релект конкрет cast?
Нет, 100
На что указывают base functor?
Что-то не знаю
Что-то что?
На что надо будет указывать?
На то же самое?
Нет, в юнионе вот этого уже не будет
Давайте подумаем, нам нужен ли
Нет, нет, нет, давайте подумаем, нам нужен ли вообще юнион тогда?
Нет, очевидно
Нет, подождите, ещё не очевидно
Нам уже два поля, значит один FPTR, а другой
А, ну возможно и не...
Вот, может быть действительно не нужен юнион
Да, кажется не нужен юнион, вы правы
Потому что как мы будем понимать, что мы в...
Какой-то мем просто
Как мы будем понимать, что мы в локальной ситуации
А просто этот FPTR будет указывать
На то самое поле и всё
Правда?
Нам не нужен локал, да
Нам даже локал не был в сайзе
Чё, чё странно
Ну, а нет
Так вот, если FPTR
Если сайзов такой, то FPTR мы присваиваем
Локал boof
Только его надо reinterpret cast-нуть
К намужному типу
Сейчас он скажет это не...
Так, я не могу, вы что сейчас сделаете?
Я букву f забыл ещё
Interpret cast-out
Base звёздочки
Вот, локал boof
Одну букву f
Да, а new-то нам нужно положить не функтор, а derived
Функтор, с шаблонным параметром функтор
Чтоб там таблица виртуальных функций правильно лежала
Я букву f потерял в локал boof, стручка
Да, господи, это не так важно
Да, и ещё не base, а base-функтор
Так, base-функтор, хорошо
А если нет, то...
То всё
В чём у нас эта проблема не решилась?
В чём у нас была проблема с юнионом?
Почему нельзя было вызывать просто, типа
Всегда PTR, а если у нас там не PTR, а это для массива чаров
Как мы отличим PTR от массива чаров?
Зачем нам вызывать? Зачем нам отвечать, типа?
Нас просто...
Вот, я в операторе круглые скобочки, а что сделать?
Вот, всегда будем f PTR вызывать
Что значит вызывать? Что я напишать должен?
Ну, типа f
f PTR, стрелочка, что?
Да
Так если в юнионе активен не этот член, это уб
Да, но там же всё равно будет, типа, такой же массив
Как это так?
На том же месте будет лежать вот этот массив чаров
Нет
Или как?
Там может быть функциональный объект с какими-то полями
Да
И как ты у него стрелочку, оператор круглые скобочки?
Стрелочка подразумевает, что там лежит Пойнтер
И ты...
Ты пытаешься разыминовывать локально
Ты пытаешься разыминовывать нечто, что не является Пойнтером, а является лообъектом локально
Почему нельзя простануть бейс пасу в поле, если у нас и боков
Чего-чего нельзя сделать?
Ну, сделать каст к бейс пуктеру, а потом вызвать круглые скобочки
А туда положить дирайвт пуктер, на самом деле
Ну да
А, то есть...
Что, ещё раз переделывать, что ли?
По адресу localbuff предлагается сделать...
Предлагается положить дирайвт пуктер
А если из local, то просто кастить его к бейс звёздочки
И вызывать оператор круглые скобочки через стрелочку
Да, кажется, это сработает
Чтобы сэкономить память?
Чтобы сэкономить память, да
Давай забьём на память сейчас
Ну давайте забьём
Короче, понятно, что... Да, кажется, так можно
Ещё раз... Ну блин, ну давайте напишу тогда
Ой
Ещё раз, у нас юнион
Бейс пуктер звёздочка и вот это
Мы кладём new localbuff дирайвт пуктер
И ещё буль храним из local
Если из local, то reinterpret cast к бейс звёздочки
от localbuff
Стрелочка, оператор круглые скобочки
Ну поскольку там дирайвт пуктер, всё нормально отработает
Да, так будет получше
Сейчас а мы в наследовании можем показывать
У нас же в наследовании там касты какие-то странные
Какие? Ну чего?
У нас тут никакого множества наследований
У нас обычно у нас бейс звёздочка и от него дирайвт звёздочка
А анонтируется ли, что это корректное поведение?
Ну по логике да
Если там лежит дирайвт пуктер
Мы к нему обратились как будто это бейс пуктер, то конечно это корректно
Ну просто мы к нему обратились не через динамит каста, а через reinterpret каст
Да, мы сказали, что там лежит указатель на бейс
Мы сказали, считай, что там лежит указатель на бейс
А под ним лежит указатель на дирайвт пуктер
А под ним лежит дирайвт пуктер, да, нормально
Да какое приведение? Ещё раз
У меня есть бейс
У меня есть объект дирайвт
У меня есть объект дирайвт
Я завёл пойнтер на бейс
И сказал, вот
И заставил указывать туда, где начинается объект дирайвт
Ну и что?
А гарантируется ли стандартом, что они начинаются в одном и том же месте?
Да, думаю да
А где оно будет?
В таблице виртуальных функций
В таблице виртуальных функций, конечно
На этом и virtual тут и припилили
Минуточку, мы положили туда
Объект дирайвт пуктер
Дирайвт пуктер это полиморфный объект
Значит, первым полем у него есть vptr
Значит, под него создалась таблица виртуальных функций, где-то в статической памяти
Этот vptr на неё указывает
Короче, тут тоже туду
Давайте
В общем, с этой проблемой понятно
Small object optimization
Нам надо ещё две проблемы обсудить
Так вот, как остальевский код пишется
Примерно тайна
Так весь код пишется, я вам открою тайну, типа
Что-то мы не успеваем по дидлайну
Что-то у нас время заканчивается
Давайте туду оставим, потом когда-нибудь решим эту проблему
Спустя год
Что-то так и не решили
И работает нормально
Да и вроде нормально работает
Так, ещё две проблемы надо обсудить
А, уважаемые господа
Посмотрите, пожалуйста, вот на эту строчку
Вот ещё раз, я вас спрашивал
Вас здесь ничего не смущает
Теперь время смущения
Вас должно здесь что-то смущать
Да нет, здесь всё вообще
Тут f это поле наше
Я напомню вам
Я напомню вам
Нет, лучше вы напомните мне
Напомните мне, что является
Colable объектами
Что вообще является Colable
Указатели на функции
Указатели на функции, сами функции
Функциональные классы
Клоузеры, байнды
А ещё
Лямды, я уже сказал
Клоузеры, а ещё указатели на методы
А если это
PointerToMember
Да ё-моё
Если это указатель на метод
То такой Col не сработает
Потому что нужно делать точку со звёздочками
И передавать
Неявно первым аргументом
В общем
В общем, if constexpr
Ой, что я написал
Ну
Можно примерно
Написать так
std isPointerTo
Я забыл
isPointerToMember
isMemberPointer
IsPointerTo
С роут криком
Ну тут есть isMemberFunctionPointer
Вот что нам надо
IsMemberFunctionPointer
Atf
Well, memberFunctionPointerV
Опять он сейчас скажет, что нет такого
Ну хорошо, MemberFunctionPointerValue
То что
Ну return
F. звёздочка
то ретюр
ну то есть нам нужно
откусить начало пакета здесь
давай это сделаем
здесь я просто вдираю
фанкты
нет у нас пакет
для класса
целиком
можно предложить
давай вдираем фанкты
и сделаем просто
функцию в духе
result call
у которого
который видимо тоже будет
шаблон
я предлагаю сделать
решение в стиле stl
смотрите какая замечательная вещь
template type name f
type name многоточие
type name
ну давайте скажу arc
type name head type name tail
правда нам нужна будет специализация
на перемен количества
ладно на случай когда их ноль
а есть такая замечательная функция
а еще type name result
есть такая замечательная
функция
invoke
которая принимает по
универсальной ссылке f
и все это тоже
и что она делает
а вот она как раз это и делает
если constexpr
ну я предлагал это просто внутри
написать
о это пришел
и еще раз
if constexpr is member
function pointer
то
что
вкуснотища
обожаю
опять пришел в такой же куртке как у меня
я в прошлый раз перепутал куртки
ты знал об этом?
head.f
от tail
head.
звездочка
head.
конечно сейчас сделаем
f от
tail многоточие
но надо сделать std forward
ко всему этому
от head
от head
точка звездочка
std forward
от tail
от tail
что смеетесь это все на экзамене будет
а иначе
не надо дядя
у нас еще самый интересный впереди
подождите мы еще такое 10 апреля
а
не ну это какой нибудь хор будет скорее
5
вот
а иначе что
а иначе std forward
от f
с шаблон параметром f
от f точка
а все просто вот так можно написать
а мы сверху не забыли
а f не надо forward
мы же знаем что это из member function pointer
что его forward
это просто указатель
а
head от head
запятая
std forward
от tail от tail
вот
такойخرой
в Sanpreza
1968
вот такая функция действительно есть
в стандартной библиотеке она так называется std invoke
а еще она умеет вызывать pointer to
member object
помните я говорил что колоблами являются
указатели на члены
на поля и их вызов он как бы с неявным аргументом ссылка на класс ссылка на объект просто возвращает
это поле но это удобно если вам там да да но в общем здесь еще надо разобрать случай если это
поле член но мы не будем его разбирать в общем а здесь мы просто вместо того чтобы делать круглые
скобочки напишем return std invoke от f и от std forward от arcs вот arcs нужно ли st forward от f делать
у нас она как поле хранится она у нас lvl и в любом случае нет не нужно
так мы же вот в нашем вулке еще type name result
надо тогда явно дай стд инвок да кажется ну кажется у нее первым параметром result чтобы
мы явно говорили а нет знаете нет почему потому что там кажется есть шаблонные давайте посмотрим
что он сам шаблоны подставит потому что он знает что возвращает думаю ну давайте проверим
значит а у нее вообще нету этого шаблонного параметра но есть версия с ним а есть версии
без него а почему а потому что зачем мне делать его если я могу написать декл тайп
декл тайп от f ну вот тут короче есть такая проблемка что я не могу написать декл от
чего именно декл тайп потому что либо от этого либо от этого опять в зависимости того чем оно
было но как раз на этот случай есть мета функция инвок result то есть result он тоже
выводится автоматически с помощью штуки под названием инвок result который тоже делает декл
тайп там про от правильной штуки ну давайте я его тоже открою вам result инвок result вот да
смотрите смотрите что здесь написано здесь все очень или а что нам мешает просто вместо декл
тайпа авто написать сам разберется кстати может быть можно и декл тайпа авто написать
почему просто потому что авто ссылки отбросит может же быть такая ситуация что мы хотим чтобы
типа у нас функции какой-то из этих вариантов возвращает нам флот а мы хотим скастить
что у тебя сама господа давайте наверное мы на этом сегодня закончим и видимо да обсудим
в следующий раз потому что уже нам пора заканчивать уже пришел и ждет цель пробросить вы пробросить
ответ функции короче мы с вами на самом деле почти все проблемы обсудили а я вам рассказал про
функции invoke но мы еще до до дочитаем вот что тут написано в следующий раз тут видите как
много тут видите много этих кастом template deduction rules вот для того что он правильно
уводил эти типа вот ну давайте ладно давайте на этом закончим все теперь точно и вот значит
смотрите сначала поговорим про просто простую ути литарную штуку вот полиморф на локаторе
значит штука простая но у нас есть целый на им спейс под нее вот вы даже возможно где-то
видели на цп референс например вот если мы откроем дек или вектор или строку или лист вот
у нас здесь видите всегда есть основная так сказать объявление класса рядом еще одно вот
на им спейсе пимар вот это просто на самом деле специализация дека с каким-то конкретным
локатором стд помар полиморфик локатор вот какой же флекс сегодня сегодня мы с вами
очевидно попробуем понять что такое ну хорошо что такое полиморф на локатор какой это параграф
илья вот идея в чем идея в том что вот у нас есть разные разные виды локаторов например
то что вы писали в листе те кто писали стэка локатор у нас есть там локатор который
заведет new delete есть локатор там какой-то другой и вот люди решили что давайте
делаем один локатор который имеет вот это все и нам не нужно явно указывать какие-то сложные
типы мы можем со всеми тем работать и оно очень классно комбинируется и вот да и
получился полиморф на локатор кстати что такое комбинируется зачем вообще нужно
может захотелось комбинировать локаторы как вы думаете комбинировать вот у вас есть два
локатор и хоп делать один вот например так подменить тоже можно да вот вот идея мне нравится
что если у нас вот есть наш локатор на стэке да и как вам например такое поведение мы выделили
память на стэке она быстрая но если она вдруг закончилась мы начинаем вызывать new delete вот
ну прикольно прикольно же иметь такой локатор просто большие объекты через new delete а маленькие
на стэке то есть размер объекта там я не знаю больше чем да я понял твою идею 64 байта давай
да тут чтобы вот такое сделать придется пописать кастомный код но да вот вот ту
проблему прям красиво решим на смотрите как работает полиморф на локатор у нас
есть вот этот один тип локатора который обычный локатор и он значит конструируется от так
называемого memory ресурса вот memory ресурс это то что выдает память какая-то штука у
которой есть память который умеет выдавать память и забирать память обратно например
стэк сторож да в некотором смысле и на самом деле вот раз мы заговорили о стэк сторожи у
нас в стандарте есть стэк сторож он называется стд пмр мана тоник баффер ресурс вот давайте
мы его собственно создадим на стэке вот поэтому вы его не нашли
не знаю могли посмотреть в код и написать зачем-нибудь когда писали стэк сторож но
на самом деле умеет больше чем ваш стэк сторож вот так это просто 100 байт memory ресурс
он умеет конструироваться по умолчанию я локатор умеет конструироваться по умолчанию
внезапно что вы думаете происходит если мы конструируем такой локатор по умолчанию вот
что бы почти значит он это то же самое практически что написать стд пмр get default ресурс у нас есть
какой-то дефолтный ресурс мы его можем который глобальный тип в программе мы его можем получать и
мы его можем устанавливать в любой момент то есть мы можем например сделать наш баффер
дефолтным ресурсом через стд мар сет дефолт ресурс абсолютно верно кто-то что-то нашел вот
но он принимает указательный ресурс ему же указатель потому что нет потому что так как
локатор полиморфный как это вообще все внутри работает ну через виртуальные функции у вас просто
есть базовый класс memory ресурс мы от него наследуемся каждым ресурсом вот и каждый ресурс по
своему определяет просто до locate вот поэтому все так относительно красиво и удобно относительно
пока не заглянешь в код видимо понимать каким локатором делись кто вот вот такая
а кому на ходу решили локатор поднимать вот кажется локатору мы уже не можем нет мы можем
только получить ресурс мы не можем установить действительно было бы что-то странное вот окей
так вот дай дефолтный ресурс а значит дефолтный ресурс это следующего вида ресурс значит я
призываю вас догадаться что он делает это ресурс у нас локатор один вообще что мне нравится
да ну он просто вызывает типа вы вызываете не локейт он вызывает нью вызываете у него
делокейт он вызывает delete все так чуть-чуть что он с ума сошел мне как у нас есть глобальный
указатель где-то в программе и он устанавливает грит вот этот ресурс теперь дефолтный если кто-то
позовет потом гет дефолт ресурс он получит указатель на то что мы туда положили это что-то
что умеет выдавать тебе сырую память то есть в отличие от локатора эта штука вообще не думает
никак о типе вот представьте свой стек сторож все о чем он думает это его могут попросить выдать
сколько-то памяти его могут попросить забрать эту память обратно все ну именно для работы
с вот этим полиморфным локатором так я хочу понять понимаете вы что тут пошло не так ну в общем
есть нью дилит ресурс я вам обещаю вот какие ресурсы еще есть вот два тех с которыми мы
работали мы уже назвали какой вы можете придумать кроме этих двух самый простой локатор вообще
на самом деле это монотоник баффер мы можем ему передать готовый начнетоник баффер может
от количества байт создаться а может от кого-то указателя можем выделить и передать
его указатель и размер и тогда он будет от него работать еще проще не выделять не выделять память
ну именно так вот ну memory ресурс у нас есть действительно самый простой вообще галлокатор
и так он может быть но то есть у него просто нет памяти он всегда говорит у меня нет памяти
так я хочу немножко понять он как будто еще на прошлой строчки не видит
нет не дилит остается не дилитом но вот если ты если ты после этого создашь например вот
такой локатор он будет использовать наш ресурс если ты после этого создашь стд пмар дек
он будет использовать твой ресурс более того есть особенность у него если ты в этот дек положишь
строки здесь будет дек стд пмар строк вот строки внутри будет использовать тот же локатор с тем
же ресурсом что и сам дек но помните там у вас было же что там этот как это штука называется я
забыл даже да скоптала катор адаптер вот вот вот примерно также что-то меня волнует это конечно
немножко чтобы какой-то очень странно выдают
есть у вас идея что пошло не так
так нет
интересно ну-ка давайте стандарт смысле но у меня вроде
это функция
все понял это функция которая возвращает указатель на эту штуку мы можем вот так сделать
да ну и тогда соответственно растет уже указатель вот да все все хорошо но с ней
дилет ресурсом видимо также что в том справедливо зачем нам их создавать если он для всех везде
окей так ну мы ресурс ну соответственно если я что-то в этот дек добавлю то мы получим исключение
бд лог очень просто вот и последний стандартный ресурс это значит ладно на самом деле это
пара ресурсов стандартных значит есть стд помар значит есть синхрон айст пол ресурс и
ансинхрон айст
ну чем отличается синхрон айст от ансинхрон айст мы подробно говорить не будем если коротко
тем что один безопасен для работы с многими потоками другой нет вот то синхрон айст можно
использовать разных потоков параллельно как например new delete new delete имейте право
использовать из разных потоков и не думать ни о чем а вот что на самом деле налагает некоторые
ограничения на ну на производительность ансинхрон айст пул ресурс вот он об этом не думает
наш пул ресурс
вот что это за ресурсы такие значит ну
они работают следующим образом
внутри они выделяют несколько больших блоков памяти которые режут на несколько больших
чанков памяти которые лежат на маленькие блоки вот блоки маленького размера давай не знаю порисую
для общего сведения в целом мы это писать не будем но кстати вам это потом может пригодиться в
будущем на курсе как раз многопоточки так справляюсь ладно может этого хватит а куда
значит смотрите
откуда-то эта штука берет себе память она эту память делит на несколько таких больших кусков
которые мы не видим
несколько больших кусков кусок 1 кусок 2
кусок n значит в каждом куске память делится на одинакового размера блоки
но они одинаковые внутри одного куска но между кусками разные вот понимаете ли вы после этого
как она будет примерно алоцировать в чем идея зачем так делать
нет сейчас это memory ресурс синхронизм и синхронизм работает похожим образом и вот
идейна вот эта логика для них для обоих верно но вот еще раз я примерно типа в общих деталях
объясняю как внутри работают pool memory ресурс синхронизм или синхронизм вот я говорю что внутри
хранит у него есть несколько больших чанков памяти которые он делит на маленькие блоки вот
есть идеи зачем так делать ну да что там еще может лежать но везде попросили нас нет смысле картинка
двухмерная но в плане у нас есть сам элемент чара они объединяются вот в эти блоки блоки
ну допустим может что-то типа корневой корневой ну смотрите зачем это на самом деле сделано вот
представьте вы локатор вы хотите написать вы хотите работать эффективно вы вот а еще вы в данном
случае вот эта штука вы даже не локатор вы memory ресурс и вы должны алоцировать память
разных размеров должны алоцировать инты должны алоцировать указатели чары массивы всего этого
это все очень разного размера и вы хотите эффективно это выделять и возвращать ну не совсем то
есть смотрите вот давайте представить что мы взяли наш кто-то стек локатор из листа и захотели
научить его удалять память типа как как это можно было бы сделать через бурю страдания у нас
есть задача нам уже рассказывали хранить эти отрезки и сливать хранить трески
ну смотрите в чем у вас проблема вот у вас есть один большой кусок памяти
правильно у вас попросили сначала не знаю вот столько потом попросили вот столько потом
попросили вот столько потом вам говорят я хочу освободить вот скажем вот эту память
да ну типа например мы все эти отрезки храним в каком-то сете отрезки памяти
свободно смотрим что справа что справа и возможно их вот как вот когда мы выделяем как нам после
этого находить вот нам нам вот скажем у нас вот здесь был кусок и вот здесь вот был кусочек
ну откуда-то найдем мы мы мы ресурс но да то есть окей то есть допустим если мы удалили потом
вот эти две штуки мы их как-то там хитро объединяем ким толгосом в общую память и потом когда нас
попросили допустим вот столько памяти мы должны как-то найти вот это окей вот утверждается что
значит можно выделять память быстрее чем двоичным деревьев поиска вот так смотрите за от одного ну
смотрите вот у нас есть допустим да чанхи допустим здесь не знаю 4 байта здесь 8 байт здесь 16 байт вас
попросили выделить инт что вы делаете так этого недостаточно просто берем отщипываем отсюда
выделяем блок окей нас попросили память 7 байт что мы делаем просто выделяем из восьмерки
всю восьмерку даем пофиг мы выделили немножко лишнего зато зато быстро
он умеет удалять еще вот вот в общем у нас получается такая система
в целом да там ну как вариант мы можем хранить просто список из блоков действительно типа
фрилли свободных блоков если мы освобождаем чан какой-то мы его в конец листа докидываем и
все у нас все операции 100 единиц вот ну это вот типа теория как как как это примерно работает
зачем-то примерно люди хотели вот да ну вопрос что он делает если у него что делать если нас
попросили 32 байта памяти ну вот нет нельзя два по 16 потому что если мы хотим очень просто
всем этим работать не могут 32 да значит ну что делает pool ресурс он горит так значит у меня
закончилась память попрошу кого-нибудь у кого памяти есть вот мы ему можем указать у кого
просить памяти если памяти нет если мы ему не укажем он будет просить из дефолта ресурса
вот и просто сразу грит все прошу 32 я отдаю и не думаю вот такая идея значит идейно это было
сделать сделано чтобы быть быстрее я в прошлом году замерял на каких-то многих разных тестах
время типа сравнивал вот этот pool локатор и new delete локатор по моему у меня на моих тестах
ни разу не получилось обогнать new delete потом я нашел где-то на реддите пост от человека который
его имплементировал в одной из тестов дали он сказал что вот как-то так работает но я не
знаю как обгонять молок молок слишком быстрый ну потому что на самом деле внутри молок почти
наверное делает еще что-то вот то же самое если мы наворачиваем что-то похожее сверху это не очень
да но new delete не всегда обращается к еду у new delete тоже внутри какие-то свои структуры на
самом деле да да мы себе вот как-то монотоник buffer resource он тоже обгонит типа и pool и молок
обгонит все нормально но проблема в том что он не чистит ни фига ну да он вообще ничего не
запоминает вот у него нет вот этой все надстройки это можно чистить если мы удалили ровно последний
элемент да это можно больше мы ничего не умеем это можно делать да как ты будешь это все отслеживать
не имеется в виду что можно удалить только только последний выделенный если нам пришел запрос на
удаление элемента и это вдруг последний выделенный ну давай честно удалим его да и все в смысле
освободим память скажем что мы ее можем рьюзить так вот не можем нас может быть что-то не удаленно
еще слева то что удалили последнего чувака это значит что мы можем его памяти рьюзить его да ну я
в этом и говорю нет ну смотри
просто в конец ну или в начало как удобнее
у нас эти блоки не обязаны быть подряд типа окей вот соответственно что еще тут нужно сказать что
вот у pull memory ресурса и на самом деле у monotonic memory buffer ресурса они умеют принимать ну скажем вот
мы можем взять какой-нибудь char ray 100 передать сюда ray 100 и еще можем передать откуда брать
если у нас закончилось можем там несколько буферов сделать и вот они также будут делать если
память у них самих закончилась братью следующего вот это про то что я говорил про комбинацию
нескольких локаторов вот окей с этим вопросов нет вот если у вас типа сейчас заставить
реализовать полиморфик локатор вы понимаете как это сделать ну давайте попробуем супер быстро
нет сейчас тут все очень просто давайте попробую я попробую написать какой-то
вместе с вами а он есть все так то есть у нас действительно есть стракт
в какой момент
как как сделать полиморфик локатор вот давайте что должно быть бейс ресурса
метод чтобы выделить метод чтобы освободить ну в целом да но что он должен быть ну какой-нибудь
допустим do allocate что он что он принимает сайс и но alignment да кажется все вот прям так
ну на самом деле можно делать allocate просто есть такой паттерн в целом который кажется и
используется в том числе здесь что у вас сама функция locate будет выглядеть как-то так
вот звездочка locate что еще да ну смысле там куча разных конструкторов вообще делает вот так
в чем смысл так делать ну в целом как паттерн это используется чтобы например у вас могла быть
какая-то общая логика в базовом классе ну как это самый банальный пример вы-то можете логировать
вас неважно какой ну класс под вами это кажется совсем бесполезно вы просто делали
до allocate чтобы написать лишнего кода и просто ну да не типа я могу переносить на allocate
смысл самого локатора в том что вы можете написать любой ресурс и не меняя никаких типов
программе просто взять его и другой это типа удобство использования ну второй дефолт не стоит
мак салант это ну тут действительно locate без долога потому что это не имеется да это правда
но это просто такая опция такой вот кусочек из тд либо вот можно пользоваться можно не
пользоваться я в целом согласен то есть насколько я понимаю на самом деле а локаторы они пришли
изначально вообще из там других побуждений они на старых каких-то архитектурах помогали
работать с поинтерами разных размеров но и со временем из-за локаторов выпилили почти все
оставили практически только работу с памятью вот memory resource это как бы такая штука которая
вот абсолютно абстрагируется от всяких конструирований муссимантики вот этого всего
просто выделяет память и как бы для удобства использования если вам просто нужно какой-то
новый способ выделять память вы можете так сделать да вы платите тем что вызываете виртуальные
функции виртуальных функций дороже чем просто вот но как бы если вы по умолчанию считаете что
алоцирование это дорогая операция то и делать ее не слишком часто наверное это в каких-то
ситуациях вполне приемлемый трейдов как реализуем вот у нас какой-то бейс ресурс у нас есть
локатор ну давай подумаем что он хранить ну наверное он хранит у себя
бейс ресурс звездочка когда мы вызываем у него locate который выглядит кажется примерно так же
мы просто завем allocate да все есть там ну констракт нам нужно какой-то ну как обычно
как у локатора делаем констракт но вроде не нужен какой констракт это на самом деле реально очень
простая концепция которая как раз для удобства сделано вот поэтому тут никаких хитростей не
нужно все поэтому по этой части есть какие-то вопросы еще что зачем когда откуда почему в чем
полимортность потому что полимортные функции ну смотри например мы тут просто мы должны что-то
понять написать конструктор локатора от бейс ресурс звездочки и тогда но будет просто приравнивать
это поле все ну да смотри к преимущества захотел ты написать дек на ты понимаешь что у тебя есть
какая-то ситуация ты не знаю считываешь много данных что ты по нему считаешь сразу все удаляешь
ты понимаешь что это операция у тебя часто используется занимает много времени в том числе
потому что ты вектор там например pushback и алоцируешь много раз память такой окей как я
могу это оптимизировать или даже лист вот листы нам на каждый pushback в лист будешь алоцировать
такой хочу стэка локатор как это сделать все берешь готовый ресурс нужный те в том случае
monotonic buffer подключаешь его готово альтернативно ты бы мог написать стэка локатор свой но его
нужно писать ну я говорю да это штука ну типа для удобства в теории каждую из этих штук ты
мог бы нет нет картину резко не поворачивает ну и плюс тут именно это это все для удобства если
ты придумал какой-то свой новый способ выделять память просто пишешь наследуешься там стд memory
ресурс пишешь свой ресурс и все просто подключаешь его готовый код все замечательно ничего
сверх интеллектуального тут нет ну смысл ты просто вот вот вот здесь тебе был раньше res 2
а теперь будет там res 1
опа и все res 3 res 1 у меня нет тут вообще никакого подвоха нет все мне кажется максимально просто
потому что вот это вот один тип у него просто разные ресурсы ну типа для удобства все
можешь ли ты написать свой стэк локатор можешь ну вот тут сделано так
еще вопрос почему такой локатор позволяет нам решить проблем не в скопе локатора ну как
когда вот у нас вот это стринг и мы хотим чтобы и стрит чтобы стрим использовала тот же
локатор что используем ну вот там дек дек строк у нас была проблема что мы хотим вот у нас
строка где-то алоцируется мы хотим чтобы там же строка алоцировала и свои приколы вот как
этот локатор решает эту проблему как он решает проблему что вопрос я даже
вот что изменилось почему нам стало
лучше чем полиморфик локатор отличается от обычного что он позволил нам вот так вот
ну вот тут написано давайте разберемся
да да да все как он это делает вот значит нас есть стд юзис локатор что он делает
илья помнишь это что делает стд юзис локатор вот ладно честно говоря я
ну смотри тут просто меня спросили как он делает так чтобы строка из дека
использовала тот же локатор что и сам дек вот мне цепи референс рассказывает что значит
используя юзис локатор он как-то этого добивается я честно говоря даже не задумывался об этом
строка использовала тот мемори ресурс короче мы хотим как-то его заменить заменить ну мы не
можем уже заменить так какую проблему он решал он решал проблему что мы хотели чтобы строка
использовала тот же локатор да ну просто локатор прик clever при создании строки мы укажем
локатор и передадим в аргумент Эрак локатор а тот же ресурс который в нашем локатор до
да, да, все так. Ну и все. Ну давай лучше перенесем тогда
этот разговор в чат, ты спроси и мы подробно ответим.
Ну если мы везде пользуемся дефолтным ресурсом, то да.
Безусловно, я не знаю, как это относится к нашей теме.
Ладно, давайте, ну, давайте быстро поговорим все-таки о второй части.
Ну то есть, если единственный вопрос, который остался, это как...
Ну сейчас, я на самом деле не вижу проблемы. Действительно, у нас же, что такое
ПМАР-дек, ПМАР-строк. Вот ПМАР-строка это строка с нашим аллокатором.
Окей? Теперь все аллокаторы, если мы живем в мире ПМАР, это полиморфик аллокаторы.
Они друг от друга отличаются только тем ресурсом, который они используют.
Мы просто при создании строки в ее аллокатор передадим наш ресурс, и все.
А, ну окей, сейчас все, я, кажется, понял. Кажется, сколп, аллокатор, адаптер, он решал
проблему не в памяти, а конструирование. Ну, кажется, у нас там была разница в том, как
конструировать. Сейчас, я, кажется, понял. Вот есть подозрение, что если мы напишем вот так,
то больше это будет неправда. Неправда, что мы будем пользоваться тем же ресурсом
памяти, что и раньше. Ну, потому что мы можем сделать, ну типа, мы можем сделать строку
над нашим стек-аллокатором. Отдельный тип. Если мы передадим ее в дек, вот так же, как сейчас,
вот эта строка, это на самом деле строка от STD-аллокатора дефолтного. Она, очевидно, не может
использовать нашу штуку. Значит, мы передаем тот же ресурс только для PMR-строки. Ну, как это сделать
для PMR-строки, очевидно. Ладно, давай, действительно, если ты попробуешь сформулировать вопрос
чаще разберемся. Значит, у нас есть еще одна штука сегодня. Вариант. Мы только начнем о нем
говорить сегодня. Смотрите, есть STD-вариант. Что такое STD-вариант? Вот, это такая переменная,
которая хранит один из выбранных типов. Что-то такое мы сегодня уже видели. Что такое вы сегодня
уже видели? Как же это вас называлось? Юнион. Да, вот это, на первый взгляд, примерно то же самое,
что и юнион. Вот давайте попробуем разобраться, почему это лучше, чем юнион. Вот давайте представим,
что у нас есть юнион. Да, он сам будет разбираться с тем, как почистить планет. О да. В том числе.
То есть это юнион только осмысленный? Ну, видимо, что-то вроде того. То есть, сейчас мы написаем,
как я бы пользовался этим юнионом? Я бы мог написать s.s равно
А вот сам. Так, ну только сейчас. Не мог бы, потому что конструктор для s-ки нужно определять.
Во-первых, нужен конструктор для юниона? Так. Тебе в s, в юнионе нужно явно определить конструктор,
потому что он не умеет дефолтный создавать. Все так. Потому что у тебя стринг или... Все так.
Короче, уже хочется выбрать. Уже хочется, да. Так, сейчас. Ну я же как-то явно могу. Нет? Не надейся.
Не могу. У тебя и вектор, и стринг имеют нетривиальные конструкторы по умолчанию? Нельзя. Очень жаль.
Окей. Ну давайте еще диструктор, на всякий случай. Да, диструктор тоже требуется. Да.
А теперь ты не создал. Вот, окей. У нас есть такая штука. Если хочу теперь записать сюда вектор, я, очевидно,
что должен сделать? Возможно, вы вообще должны вот так сделать. Вы правы. Что вроде, значит, адрес...
Адрес... Попросить юниона ничего нельзя. Ну в смысле, здесь ты хочешь STD Basic String написать от?
Нет, все. Не хочу даже. Короче, сжечь нафиг все. Что еще сделать?
С конструирует с отпускной строки. Да, наверное. Давайте U.
U. Теперь можно написать U.S равно Abatsaba. Это правда. Вот, но теперь чтобы записать вектор, мы должны сначала разрушить строку,
вызвать руками диструктор, потом создать вектор, и потом в конце программы не забыть еще руками вызвать диструктор вектора.
Именно так. Да. Не забыть повеситься в конце этого всего действия. Чтобы делать не ручками, нам подарили STD вариант.
Это чтобы забыть повеситься в конце этого. Да, значит, смотрите, мы можем сделать STD String и STD Vector.
Интуов. Чаров. Класс. Мы можем написать V. Вот V. не можем написать, как и с туплом, очевидно.
Ну, а мы можем написать STD. Мы можем написать, знаете, что? Мы можем написать V равно STD Vector.
Вот так мы можем написать. Просто через равно. Все сработает, никакого UB. Стоп, а он у вас?
Потом мы можем написать V равно. Почему нет? У вас не получится, что у него размер 97 теперь.
Чего? Сейчас, подожди, у кого размер 97? Возможно, там, например, хранится первым полем вектора Чаров его размер.
Так. Не-не-не, я же фигурные скольточки написал.
Ниш, так можно писать. По-моему, лучше просто... Я могу его так написать без проблем.
Сейчас, давай проверим, хорошо. Можем писать STD SEOUT.
Ну, в смысле, я уверен, что тут тоже все в порядке. Я вам сейчас докажу.
Смотрите, вопрос. Я хочу вывести, скажем, последний элемент вектора, который лежит в варианте.
Что я могу сделать? Чтобы это сделать, я пишу STD GET.
GET что? Как и в тупле, точно так же. Я могу обратиться GET либо к типу, либо к индексу.
То есть, я могу сказать STD Vector Char. Дай мне, пожалуйста, свой STD Vector Char. V и .back.
Да. Он активно это делает в рентайме. Вот. Вот это сработает.
Значит, вопрос. Что будет, если мы напишем вот так? Вот так.
Да. Он поймет, что мы делаем что-то не то и кинет нас исключением. Смотрите.
Давай теперь. Все прекрасно. Мы увеличили B и потом мы получили Bad Variant Access.
Попросили тот тип, который сейчас активный. Можно?
Давайте я тогда вот так сделаю. Да, было бы славно.
Да. Ну, это он и есть. Вот размер два, если кто-то сомневался.
Можем ли мы получить тип, не выстреливая себе в ногу и не используя Tray Catch?
Получить тип. Спросить, что в тебе хранится. Смотри, а как ты себе это представляешь? Что тебе эта функция должна возвратить?
Нет. Скорее хотелось бы уметь вызывать функцию, которая определена для всех типов, которые содержатся в STD Variant, чтобы она корректно работала.
Так. Какая еще раз функция? Ну, например, у вас для всех типов определена функция Shout и хотелось бы, чтобы вызываясь просто STD Variant, она выводила...
Я понял, чего ты хочешь. Ты хочешь, чтобы я мог написать вот этот STD Get Back и чтобы он сработал и для вектора, и для строки. А я на самом деле могу так сделать.
Ну давайте, смотрите. У нас есть функция, которая лежит рядом с вариантом, называется STD Visit.
А если там еще Get лежит, то оно не свободно, да?
Ну да. Ну сейчас посмотрим. Смотрите, STD Visit принимает...
Я хотелось бы, например, уметь копировать текущие активные члены из STD Variant.
Ну, у него есть индекс. Вы можете позвать v.index. Он вернет вам индекс активного типа.
Ну это и факт надо.
Ну, еще раз. Вот давай. Представим. Ты хочешь...
Я хочу вне зависимости от того, что в нем лежит, сказать, вот возьми, что в тебе сейчас активно, запиши мне переменную под названием S.
А какого типа эта переменная?
Я не могу даже да, понятно.
Ну, ты можешь очевидно приравнивать один Variant к другому. Это нормально.
Ну вот, смотри. Visit. Он почему-то сначала принимает лямду. Ну не лямду, а какой-то visitor.
Это что-то, что можно вызвать.
И мы на этом item давайте возьмем и вызовем, собственно, вот это.
И мы потом передаем сам Variant.
Вот. И теперь мы можем вот это удалить.
Вызвать точно такой же visit вот здесь.
И сейчас работает ровно так, как ты хотел.
B, A.
Потому что у Vector последняя B, у строки последняя A.
Вот.
Как это работает? Вопрос сложный и не требующий спешки.
Давайте сначала посмотрим, что мы с этим можем сделать.
Давайте быстренько загляну, смотри, что ничего не забыл.
Ink в эту же структуру. Без проблем. Но тогда мы не скомпилируемся.
Так, сначала Vector, потом строка, да.
Да, ну смотри, ну теперь если мы уберем Back,
просто будем вводить item. На самом деле мы можем больше сделать.
Да, и теперь уберем Vector отсюда. Снова заработает.
Да, да. Именно так. Более того, он, ну как бы, что еще интересно,
вы можете сделать вот так. Нет, так вы не можете сделать.
Ну хорошо, ну вы можете написать int816t1.
И смотрите, что здесь произошло, почему это важно?
Это он. Ну я хочу вам показать, что мы приравниваем наш вариант к int16.
И он все еще компилируется, потому что один из его типов умеет, ну типа, может сконструироваться от int16, это int.
Если здесь будет еще int64t, ну давайте int64t.
Скомпилировалось. А что мы получим?
В смысле, да. У нас какой активный член тогда? Есть вопрос.
Есть вопрос, давайте посмотрим. Ну, значит он решил, что какой-то из них более подходящий.
Ну это реально выстрелом в ногу.
Вопрос работает ли, это просто по правилам перегрузки.
Да, кажется. Один, значит int, ну в целом, справедливо.
Почему? Несправедливо.
Мы куда угодно могли записать.
Ну, смотри, если мы здесь делаем, так, нужен какой-нибудь пример, когда касс будет точно неоднозначный.
А, кстати, давай прямо попробуем в другом порядке, сначала int64t, потом int.
А это ничего не изменит.
А сейчас посмотрим.
Ну, вообще не должно. Я уверен, что не изменит.
В первое совпадение положил просто.
Представь, что у тебя два конструктора.
Изменило?
Изменило, изменило.
Да.
А, нет.
Ну, в смысле, он int все еще. Все еще int.
Это логично.
Да.
То есть точно нельзя два int положить?
Два int, а два int можно положить.
Что?
Ну, он теперь типа не понимает.
Смотрите, вот здесь, это легальное объявление переменной типа variant, но теперь он не понимает вот здесь, что ему делать.
А какое разумеет, когда оно полезно?
Я, честно говоря, не знаю.
Все нормально.
Я, у меня в голове примера, когда это полезно, нет.
Вот.
Ну, потому что бесполезно, наверное.
Вот, да.
У нас видит вызывается только один раз.
То есть, если мы посмотрим был, то у нас...
Там 30, там 1000.
А 1 – это индекс.
Да, да.
Ну, в смысле, потому что видит вызывается на активном элементе.
Активно?
Да.
Да.
Все, все, понятно.
Вот.
Что еще важно сказать?
Variant после создания активный первый элемент.
Вот, видите, сначала...
А, ну, мы не вводим.
В общем, вот эта вот штука выведет ноль.
Соответственно, видите ли вы проблему?
Дефолт для конструктора?
Да.
Если у вас, скажем...
Ну, ни у одного из типов, которые вы хотите вариант передать, нет дефолтного конструктора.
Что делать?
Стандартная библиотека идет к вам на помощь.
У нее есть специальный тип.
Std monostate.
Это пустой...
Ломаем все виды.
Это просто пустая структура, которая нужна для такого случая.
А сколько?
Можно вопросить?
Да.
Что это в Std пустых структур с различными именами?
Много.
Тейди как минимум.
Вот.
Есть monostate.
Про него полезно знать.
Visit.
Вот так работает.
Get.
Понятно.
Через дрансу можно присваивать.
Что еще полезно знать про варианты?
Для них определены хэш и сравнение.
Значит, вы можете пихать их в мапу и в хэш-мапу.
Сейчас.
А как сравнивать?
То есть для пара они не определили хэш?
Сейчас.
Не-не-не.
Ты что?
Нет.
Какой интерпретер звездочка?
Зачем?
За что?
Если у нас два разных типа активных, то это что?
А.
Если два разных типа активных, то кажется это нельзя так.
У меня очень много вопросов к разработчикам Std линии.
Get по индексу.
Что?
Get по индексу можно.
Тут у нас один объект.
В.get от 0.
Ну, от 1, чтобы сработало.
Ну, то есть скорее всего так.
А, потому что не v.get, а std.get.
Так, что мне не нравится?
А, потому что от v.
Где три слыша подряд?
Так.
Окей.
Вот.
Что у нас еще есть?
У нас есть helper функции variant-size.
Variant-size возвращает сколько у нас типов просто в варианте.
А get единичка это?
Это альтернативный get.
Ну, типа можно делать get по типу.
А можно по индексу?
А можно по индексу.
То есть вот это и вот это одно и то же.
Окей, хорошо.
Вот.
Это просто как этим всем пользоваться.
Просто если у нас огромные типы, мы явно не хотим их писать каждый раз.
Ну, может быть.
А может быть у нас несколько типов.
Вот.
У нас тип имеет право повторяться.
Поэтому иногда только по индексу можно.
Сейчас.
Да.
Часто variant используется с полиморфными типами в том плане, что если мы храним
как бы указатель на...
То есть...
Сейчас.
Я...
А если variant-size?
Короче, мы можем в варианте хранить кучу указателей на разные структуры, которые являются...
Ну, которые являются сыновьями какой-то базовой структуры, чтобы потом получать
что-то, пытаться в родной мере поделить, что лежит под этим.
В смысле, что лежит под этим.
Пока все, что ты сказал, мы можем делать.
Да.
Про то, что у нас есть индекс, но мне очень понятно, как нам по индексу получать
какой-то тип.
Я пытаюсь понять, каким образом можно получить там...
Что там в подробии?
Decal type от v.tango.
Variant-tango.
Смотри.
Есть такая штука, как holes-alternative.
Так, давайте.
Значит, holes-alternative позволяет нам понять, лежит тип или не лежит.
А, variant-alternative.
Был неправ.
Вот.
Мы можем позвать...
А, нет.
Мне это позволяет делать.
Сейчас.
Что такое variant-alternative?
Что такое variant-alternative?
Мы...
Я нам наврал.
Variant-alternative, она просто по...
Так, ей нужен вообще вариант?
Нет, не нужен.
Мы просто выдаем ей единичку, выдаем ей, кажется, v.
И это тип, который лежит в этом варианте по индексу.
Что?
Type name?
И что?
Нет какой-то конструкции, что в подробии, эквивалентный
get авто каким-то левым боком.
Еще раз.
Get это авто?
Можно мы каким-то образом variant в runtime определять его key?
Вот вопрос такой.
Без индекса.
Без индекса.
То есть, как бы непонятно, что мы индекс не можем передать
в этот блок, просто потому, что это...
Ну, мы не можем передать в этот блок.
Ну да.
Ну вот единственный способ определять тип в runtime-е,
это полимортное предъятие.
Что полимортное?
Ну, в смысле, единственный способ, как мы можем определять
тип в runtime, физический язык, если пусть тут ставится,
то из того, что мы знаем.
Да.
Это пользоваться, ну, виртуальными функциями.
Вот.
Есть ли что-то, какое-то анало для variant?
Ну, давай так.
Что ты хочешь сделать?
Ты хочешь типа запустить какой-то код, который если
тип один, то делай одно, если тип другое, делай другое.
Да?
Да.
Смотри, это можно.
Это можно сделать.
Ну, то есть, во-первых, ты можешь зайти в видит
и написать что-то вроде там if const export std isSameVariantVariantVariantVariantVariantVariantVariant
isSameVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVari
Да, ну в смысле у тебя в рантайме, сейчас еще раз, подождите, вы мне утверждаете, что это не сработает?
Я утверждаю, что это сработает, сейчас я посмотрю, в каком хедре лежит ASTD decay, это сработает, type traits, в целом ожидаемо.
Ну смотрите, ну мы с вами на самом деле обсуждали, что это, она удаляет всякие консты, удаляет амперсанды и превращает массивы в указатели.
Вообще, я хочу сказать, что вообще с ASTD decay любые консексы проекта, не важно, что они лежат, другие работать не будут.
Потому что в большинстве того, что бывают ситуации, когда компалируют амперсанды, и невозможно определить, что там лежит.
Ровно так же, как мы не делали для ASTD, мы вместе ставим. Просто точно то, что мы делали.
Так.
Это не сработает только Пэр.
Ну, я вот очень хочу сказать сейчас.
Сейчас посмотрим.
Это вообще не должно так себя вести.
Не должно так себя вести.
Сейчас я могу вот так сделать.
Тип B, на того, что у меня лежит, зависит от runtime.
Безусловно.
Смотри, хорошо.
В консексе он не сможет работать.
Окей.
Вот такой код, который если строка делает одно, если не строка, делает другое.
Ну, конечно.
Видимо, он может хранить указатель на функцию, который ему нужен.
Указатель runtime.
Вот. Давайте посмотрим вот так.
Ну, какой билд?
Нет, у нас тут билд-система, к сожалению.
Здесь у нас есть стринг.
Окей. Почему это не стринг?
Потому что есть вот эта строка.
Если мы берем вот эту строку, и вот эту строку, и вот эту строку.
Ага. А теперь я там напишу, что if вот с клавиатуры...
This is a string.
А теперь я говорю, что if вот с клавиатуры равен 228, я записываю туда строку, иначе int.
И что делает твой degle type?
Объясни мне.
Ну, смотри. Хорошо. Давай вот так.
Видишь, человек понимает.
Давай. Если вот это вот равно 42?
Ну, вот типа того, да.
То делаем вот так.
Да.
Ну, argc это явно исключительно runtime штука.
Да пофиг.
Ну, хорошо. Давай не 42. Давай будет 2 аргумента.
Потому что теперь я смогу показать, что вот один раз компилировал.
Запустил...
This is a string.
This is an out-argument.
This is not a string.
Okay?
В compile-time все работает.
Ну, constexpr не может работать в runtime.
STD из sameware работает только в compile-time.
Более того, сейчас вот, смотрите, у меня есть здесь план.
Вот здесь, видите, написано std-visit-boom.
Это типа...
А дальше написано overload-pattern и большой boom.
Смотрите.
Нет.
Да.
Лянда.
Это у вас структура просто
и скобочки.
Вы можете также написать... Не обязательно.
Вы можете написать просто структуру свою.
Сделать у нее, например, много операторов круглые скобки.
Или там шаблонный оператор круглые скобки.
Пожалуйста.
Ну, и у нас просто
template-ная штука генерируется...
Ну, видите, генерируется для каждого
типа, который может
храниться в этом варианте.
Да.
Раз он знает...
И потом он в run-time
вызывает нужную.
В run-time вызывает нужную. Все проблемы.
То есть, вы знаете, что если мы сейчас запустим проверку
в убитый теориям формата, у нас полукод просто
местный генерируется. Что мы сейчас делаем?
Ну, запустим, например.
Ну, если мы сейчас делаем какой-то цикл, который вообще
нереально что-то делает, и в зависимости от этого
может генерируется бесконечное число версии
варианта, то код наш не запустится.
В смысле, бесконечное число яснее генерируется?
Я не понимаю вопрос.
Кажется, мы копилируем сами условия,
а
не то,
выполнились ли одни.
Мы по временам делаем сами условия.
Мы constexpr раскрываем. Мы все константные вещи
раскрываем. Просто для каждого типа
из варианта независимо.
То есть, мы для всех типов, что у нас есть
варианта... Нам не нужно проверять
выполнение условий. Мы просто проверяем.
Мы просто делаем код для случаев,
когда выполнен, и для случаев, когда не выполнен.
Так вот.
И про антайли мы уже выбираем
какой год выпускается.
Да, все генерируются.
У тебя их конечное количество по числу типов,
которые могут храниться конкретно
на этом варианте.
У тебя просто какая-то темплейная структура есть,
у которой темплейные параметры
может быть ровно столько,
сколько у тебя вариантов разных типов можно изразить.
Ну, подставим все.
Смотрите, что я еще могу сделать.
Почему больное? Невероятно красивое.
Смотрите.
Смотрите, что мы можем сделать.
Сказать.
То же самое, но более красиво
гораздо. Значит, если нам дают строку,
выведи,
что это строка.
Так.
Что-то не хватает.
А, точки запятая.
Если у нас
int
int
std
int
точка запятая.
Так.
Сейчас посмотрим на overload.
Смотрите, string
и, соответственно,
int.
Видали, что я написал? Это почти pattern matching в плюсах.
Если string выполняет этот код,
если int выполняет этот код.
Как вам такое?
Нет.
Ну, это то же самое, только не нужно писать
if constexpr std is same way
std decay t decal type item
запятая std string. Можно писать просто?
std string.
Да. Значит, как это вдавиться?
Что?
Всего четыре строки.
Что?
Функция сплошные точки.
Сплошные точки.
Ну, давайте разберем. Давайте попробуем
разобраться, что здесь происходит и почему
эта штука красная.
Это называется overload pattern.
Это называется overload pattern.
У нас есть структура,
у которой есть
параметр pack шаблонный.
Да.
Мы от них от всех наследуемся публично.
Вот здесь уже вопросики.
В этом моменте
уже очень много.
Мы передаем туда
сколько угодно типы и от каждого из этих типов
наследуемся. Нормально?
Почему нет?
Давай сразу посмотрим,
какие типы мы передадим в этот overload
из двух лямб.
Какие это типы?
Ну, это тип лямб
в мейне на 31 строке и лямб
в мейне на 32 строке.
Это структура, как мы помним.
Почему мы вообще создаем overload?
У нас конструкторов нет.
Почему? Как это работает?
А, у нас есть...
У нас там в конце стримки янта, что ли?
Нет, подожди.
Что такое
оператор круглой скобочки?
Это, смотри.
Мы делаем using.
Из каждого из типов,
от которых наследуемся,
берем оттуда оператор круглой скобочки.
И вот это значит, что это делаем
для каждого из...
А, для каждого из types?
Для каждого из types.
Так, стоп.
Как же это прекрасно.
Как же это плохо.
Подождите, у нас квадрат?
Что квадратное?
Меня очень беспокоит, как мы вообще overload создаем?
В смысле, что-то как-то происходит.
Это самый мужской способ объединиться.
Ну, давай подумаем, что такое overload?
Overload у нас в данном случае
наследуется от двух родителей.
Правильно?
Какие аргументы у нас вообще как шаблонные
подставляются, и как это
подставляется, потому что мы же...
Ну, смотри, какие
подставляются аргументы. У нас есть вот эта штука.
Мы пытаемся вызывать какой-то конструктор,
непонятно от чего.
Вот у нас есть auto-lamb1.
У нее тип
decal-type от auto-lamb1.
Больше никакой.
У нас есть auto-lamb2
равно вот это.
Мы создаем overload
от decal-type
от lambda1,
decal-type
от lambda2.
Да?
А, в самом деле, вот этого уже достаточно?
Типа, вот этот код будет делать то же самое?
Почему нам типа все достаточно?
Ну, потому что...
Ну, что такое тип lambda?
Это просто пустая структура, у которой
оператор круглые скобочки, который статический,
потому что у нас нет захватов.
Он статический, да.
У нас это пустая структура со статической функцией.
Все, статическим методом.
Но вообще, на самом деле непонятно,
потому что мы не пишем шаблонные параметры
и просто пишем, от чего им генировать,
он сам
как-то это очень аккуратно
парсит. Тут не очевидно.
Ну, происходит deduction-guide.
Ну, не очевидно, как именно
происходит, кажется.
На самом деле,
до C++20
нужно было писать кастомный deduction-guide
здесь. Чтобы это так красиво работало,
нужно было писать... Вот к этому вопросов
нет. Это понятно почему. Вообще
непонятно, почему после 20-х не нужно.
Ну, потому что
мощный update. Это очень сильная
магия должна быть написана.
Сейчас, а где нужно было
писать deduction-guide? Ну, до 20-х
плюсов нужно было... Вот здесь нужно было
написать что-то вроде...
Так, давайте вспомним. Нужно было объяснять ему,
что делать с шаблонными параметрами.
Что вроде такое...
Мы
создаем overload
от
types
types
Кажется, что-то вот такое.
Вот, видите, он ругаться перестал.
Ну, ругался он, потому что клан, как вы помните,
еще пока нет.
Не успел.
Не успел.
Ну, вот тут понятно.
Ну, просто 20-й плюсы такую штуку
по умолчанию сгенерили. Нам повезло.
Что если мы хотим поддерживать
функцию для вейн, которая
может...
которая в одном случае корректна,
в другом случае не корректна.
Еще раз, мы хотим хранить две перегрузки
в одном случае
вызывать, которое можно, например,
астремиала, но то, что мы показывали с точка back
и у int.bat нет.
Поэтому мы такого делать не можем.
Есть ли какой-то способ
с вейн, который позволяет
для разных вариантов того, что
в нем лежит, одну функцию исполнять
или не исполнять?
Кажется, я могу написать...
То есть, судя по тому,
как это работает, насколько я понял,
мы просто генерируем все варианты функций
в compile-time для каждого из вариантов.
Но что, если один из вариантов функций
нельзя сгенерировать?
То есть, можно ли
попытаться имплементировать логику,
где...
Ну, короче, для кого-то можно
что-то делать, для кого-то нельзя.
Ну вот, смотри, давай попробуем вот так.
Вот так.
Вот.
И теперь давай мы...
Так, я опять забыл точку запятой.
Вот.
Допустим, мы добавим сюда
какой-нибудь
std-вектор опять.
И вот в двух этих штуках
от int-ов
в двух этих штуках мы будем
выводить, скажем, вот string.
Потом, собственно говоря,
item, который мы пока опускали,
вводим item.
Вводим int.
Ну, пожалуйста, вводим этот int.
Вот.
То есть, вот эта у нас штука сломалась,
но наша новая более красивая
все скомпилировалась.
Все хорошо.
Почему больно-то?
Да, надо.
Так.
Нужную перегрузку
для каждого...
для каждого из гляд.
И в том...
Да, у меня одна гляда потерялась куда-то.
Потому что она в одной стройке.
А?
А?
Это предложение 35-й стройки, да.
Все.
Не очевидно, нет.
Вот, смотрите, вот так, пожалуйста.
Ну, типа, если это строка
или int, выводим, если что угодно другое.
Да.
Нет.
Что еще нужно сказать про видеть?
Видеть, на самом деле, было бы логично,
чтобы он принимал вариант первым
аргументом, да, не вторым.
Но он принимает его вторым, потому что вы можете туда
сколько угодно вариантов передать.
И он...
для каждого из них
запустится.
Или нет.
Не знаю, почему он решил не запускаться.
Кажется, должен.
Visit.
Visit.
VisitorVariants.
Ну, подозрительно.
Вот.
Ну, соответственно, если у вас какой-то есть вектор вариантов
или мапчик вариантов, можете по ним проходиться
и для каждого вызвать Visitor.
Потому что у вас в векторе вариантов, очевидно, разные
варианты могут иметь разные активные элементы.
И для каждого из них автоматически выберется
нужная штука.
Ну, так.
По времени уже все, да?
По времени мы все пятнадцать минут назад.
А, черт.
Какой юзинг? Вот этот?
Ну, это типа...
Представь, что types в нашем случае, это там
лямбда один, лямбда два,
лямбда три, да?
Окей. Тогда это будет
то же самое, что написать
юзинг там лямбда один,
оператор, клыскопки.
Только оператор.
Что это за запись вообще?
Это значит, что этот оператор
можно вызывать от нас.
Мы добавляем себе
из нашего родителя вот этот метод,
даже если его у нас нет.
Ну, так же, как с конструктором мы делали.
Мы, наверное, когда-то так делали
с конструктором, что типа...
Ну, можно попробовать...
Вот так. Давай сделаем это
на вот этой штуке.
Второй кое-ниче.
Верлот два, и у него
мы будем делать юзинг на бэк.
Почему нет?
И здесь делаем
верлот два
от стд
от стд
от стд
от стд
верлот два
от стд
ринг
стд вектор
int.
Так, что мне нравится?
Он с конструктором не справился,
что в целом справедливо.
Давай просто укажем у стд
ринг,
стд вектор
вектор
во, пожалуйста,
можем.
Ну, векторе их и так несколько.
Ну, просто он все их добавляет.
Так, ладно, давайте заканчивать.
С чем он не справился?
ну потому что это слишком сложно для него ну смотри то есть что ему нужно сделать
а да сейчас да он скорее всего на геймпультуста скомпилиться
но тут нужно чтобы он добавил ровно те же самые дедакшн гайды
Publix
все
