Давайте начнем. В прошлый раз мы обсуждали все значимые равносильные формулы. Там получили
ряд результатов, то есть что для любой формулы есть равносильная такая-то, такая-то. Это нам
все понадобится, но я напоминаю, что у меня первое желание было обсудить проблему выразимости
предикатов. Вот сейчас, когда у нас уже есть некоторый запас, ну как бы, закона в логике,
можно вернуться к этому вопросу. О чем идет речь? Вот у нас есть какая-то модель.
Значит, чем задается модель? Множеством носителям модели, какими-то предикатами на этой модели и
какими-то функциями и константами. Причем, тут у меня как раз спрашивали перед лекцией, я хочу
еще раз подчеркнуть, что функции должны быть всюду определенные. То есть, когда мы задаем модель,
предикат это какое-то подножество соответствующей декартовой степени m, а функция это всюду
определенное отображение из наборов k элемента в m в элементы m. Она должна быть всюду определенной.
Так у нас модель задана. Ну и, используя формулы первого порядка, можно из имеющихся предикатов
встроить какие-то другие. То есть, каждая формула задает какой-то предикат в этой модели и возникает
вопрос, у нас есть какой-то предикат, не принадлежащий вот этому списку, можно ли его выразить в этой
модели формулой первого порядка? Ну, тут частая ситуация. Если ответ да, можно выразить, то можно
надеяться подобрать эту формулу, ну как-то исходя из здравого смысла, из содержательных особенностей
модели. То есть, это скорее, когда мы хотим выразить, нам нужно что-то про математику этих предикатов
и функций понять. Но может так получиться, что не выражается. И что тогда? Как доказать, что нет ни
одной формулы, которая выражает данный предикат? Ну, задача кажется трудной, она, в общем, действительно
не очень легкая, но есть несколько способов это делать. И вот, ближайшая моя цель, эти способы
представить. Начнем мы с самого простого и начнем поэтому с очень простой модели. Давайте возьмем
такую модель. Рациональные числа, отношение-сравнение строгое, ну и скажем плюс-сложение. Модель, видно,
очень бедная, много сказать не удастся в любом случае, но что-то сказать можно, например, предикат
х равно нулю. Я напомню, что я буду всюду дальше использовать такое соглашение о записи. В кавычках
я буду писать то, что я пишу на нашем обычном математическом жаргоне. То есть, это не формулы
первого порядка, а просто какое-то математическое утверждение. Вот я хочу такой предикат выразить
в модели. Как это сделать? Ну, давайте так. Значит, для любого у неверно, что у строго меньше,
чем х плюс у или х плюс у строго меньше, чем у. Ну вот формула первого порядка, я ее написал не
совсем канонически, потому что отношение порядка мы пишем инфиксно. По нашему формализму надо было
бы написать знак меньше, потом в скобках аргументы. Но для наглядности я пишу так,
это легко механически перестраивается с такими привычными значками, зато легче понять, что здесь
написано. Давайте посмотрим. Это же можно применить правила Деморгана. Отрицание дизъюнкции,
это конъюнкция отрицаний. Что значит отрицание этого утверждения? Ну, это означает, что у больше
либо равен х плюс у. А что значит отрицание этого утверждения? Что х плюс у больше либо равен у.
Но из этих двух неравенств сразу получаем равенство. У нас равенства нет в сигнатуре,
но оно выражается. Вот, собственно, такой формулой можно выразить предикат равенства. Получаем,
что для любого у, у равняется х плюс у. Ну, для каких х такое будет верно? Такой х единственный,
это ноль. Это свойство нуля, свойство нейтрального элемента. Поэтому такой предикат выражается.
Ну, давайте попробуем сделать следующий шаг и выразить предикат х равно единице. Возможно ли
это? И вот тут начинается проблема. Ноль мы так выразить можем, но сложение нуля нам ничего нового
не дает. Как получить единицу? То есть мы можем зафиксировать какое-то число, но как выразить факт,
что оно равно единице? Не очень понятно. Умножения у нас нет. Если было бы умножение,
мы могли бы написать аналогичный закон нейтрального элемента по умножению. Но умножения у нас нет,
у нас только сравнение и сумма. Но вот оказывается, что это сделать вообще невозможно. Есть препятствие,
которое я сейчас попробую объяснить. Давайте посмотрим на такое отображение,
которое задается формулой. Х переходит в 2х. Ну что мы про него можем сказать? Во-первых,
ясно, что это биекция. Обратное отображение это просто деление пополам. У нас рациональные числа,
деление возможно. Во-вторых, мы знаем, что х меньше у тогда и только тогда, когда 2х меньше 2у.
Умножение на положительное число сохраняет неравенство. Как говорят, это отображение сохраняет
предикат. То есть если мы применяем его к паре чисел, для которых выполняется отношение, то для
результата тоже будет выполняться. Наконец, тоже несложно заметить, что образ суммы равен сумме
образов. Это линейная функция, поэтому образ суммы равен сумме образов. Такое отображение называется
автоморфизмом модели. Я чуть позже дам точное определение, но уже сейчас понятно, почему я его
называю автоморфизмом. Так же, как в алгебре у нас были автоморфизмы групп, это биекция группы
на себя такая, что сохраняется операция. Это уже пример чуть подробнее прокомментирую, когда появится
точное определение. Сейчас я хочу сказать вот что, что интуитивно кажется очевидным, что предикат,
который выразим в модели, будет сохраняться при автоморфизме. Но автоморфизм ничего не меняет
в наших базовых предикатах и функциях, ну значит, когда мы его применим, у нас предикат должен перейти
в какой-то выразимый предикат. И здесь мы видим препятствие, потому что вот этот предикат не
сохраняется. Смотрите, вот у нас есть такой предикат, но один умножить на два это два, поэтому во что он
перейдет при таком автоморфизме? Если x равен 1, он перейдет в предикат x равно 2. И это не то же
самое, поэтому представим, что у нас есть формула, которая выражает предикат. Она должна после
применения автоморфизма давать снова его же, а не дает. Смотрите, вот у нас есть предикат,
который единицы только, истинен только в точке 1. Теперь мы применили это отображение, эта точка
перешла в двойку, когда psi от x истинно. psi от x равно 1, а и когда x равно 1 и 2. Это в обратную
сторону. Я, честно говоря, даже не знаю, как правильнее это записать. То есть в единицу
переходит одна вторая, единица переходит в двойку. Вопрос, к чему мы применяем? Мы вначале применяем
предикат или функцию. Если мы хотим применить к предикату, значит мы должны подставить в предикат
функцию. То есть вот это я сейчас правильно написал, так что вот такой правильный ответ. Прошу упрощения,
согласен, это я погорячился. Но в любом случае видно, что не сохраняется. Ну в смысле, так нет,
единица, она что? Это вот точка. Вот смотрите, у нас вот такой вот предикат. После того,
как я подействовал моделью, эта точка перешла в двойку, а в единицу перешла одна вторая. У меня
получился другой предикат. Вопросы на эту тему очень хороши. Сейчас давайте я дам формальное
определение, и мы посмотрим, куда что должно переходить. В сущности, вот поскольку такие
вопросы возникают, возникает сомнение, что это рассуждение корректно. То есть казалось бы
очевидным, что формулы должны сохраняться при автоморфизмах. А там кто его знает? Вот что-то
здесь напутали, может быть, есть какие-то сложности в этом. Надо поступить, как всегда в математике,
если непонятно, надо написать строгое определение и доказать исходя из него. Вот давайте напишем
определение. Значит, у меня вот есть модель. Наверное, я вот здесь вот напишу определение.
Раз уж модель все равно написана. Автоморфизм. Модели. Ну, это прежде всего биекция, опять-таки.
Значит, биекция, которая должна удовлетворять двум свойствам. Ну, на самом деле, столько свойств,
сколько у нас предикатных функциональных символов, двум группам свойств. Если я беру предикат,
и применяю его к элементам у нас их несколько. Давайте я сразу буду писать, чтобы было понятнее
я ставлю квадратные скобки, чтобы соответствовать моему определению оценки FORT. То есть у меня есть
интерпретация предикатного символа R и ТОВ, и есть оценки переменных. И нужно, чтобы это совпадало
с предикатом, который оценивается на переменных с другой оценкой, когда я применяю к оценке
переменных PSI. Оценка переменных, я напомню, это функция из переменных в модель. Соответственно,
я могу взять композицию, вот тут вот еще применить PSI, и получится оценка уже другая. Так вот,
на этой другой оценке должно выполняться то же самое. То есть если было в отношении, то и осталось
в отношении. То есть вот это исходный предикат, это новый предикат. Ну и можно теперь посмотреть,
что нам нужно сделать здесь в неравенстве. Значит у нас был предикат х равно 1, унарный.
Значит теперь я должен написать предикат, вот как я второй раз написал, PSI от х равно 1. Поэтому
получается предикат х равно 1, вторая. Ну и должно выполняться, я напомню, в примере у меня еще была
функция и тоже для нее выполнялось, должно выполняться такое естественное свойство. Если мы применяем,
сейчас, секунду, если мы применяем наш автоморфизм к значению какой-то функции,
у нас, я напомню, были термы. И вот мы применили функцию, а потом применили автоморфизм. Функция
дает нам опять-таки значение в m, автоморфизм потом можно применить. Так вот, результат будет
такой же, как если мы эту функцию применим к оценке переменных. То есть те же самые термы,
но уже оценим в другой точке, в других значениях переменных, которые отвечают,
которые отвечают оценке переменных, получаемой вот этой вот оценки. Вот у нас была оценка
кси, а вот эта вот оценка это то, что я называю psi от кси. То есть переменная в начале приобретает
какое-то значение в оценке кси, а потом к этому значению я еще применяю автоморфизм. Ну в принципе
это то же самое, что написано вот здесь. Вот посмотрите, я применил к функции автоморфизм,
и это должно равняться функции от автоморфизма, примененного к аргументам. То есть это такое
обобщенное свойство автоморфизма, образ суммы равен сумме образов. Но давайте это чуть подробнее
рассмотрим, потому что определение довольно абстрактное. Вот на примере группы, я сказал,
что это определение у нас будет обобщать автоморфизм и группы. Давайте посмотрим,
как это выглядит в случае группы. Ну группа это что такое с нашей точки зрения текущей? Это такая
модель множество, предикат равенства, функция произведения, но я ее пишу с переменами, потому
что иначе трудно записать. То есть это бинарная функция, и есть унарная функция взятия обратного,
есть константа нейтральный элемент. Что означают условия автоморфизма? То есть у нас есть отображение
группы в себя, которые объект С, и должны выполняться вот эти свойства. Первое свойство
совсем простое. Что мы пишем? Если у нас х равно у, должно быть равносильно, раз тут равенство
написано. Это означает, что равносильно для всех оценок переменных такое должно выполняться.
Должно быть равносильно, ψ от х равняется ψ от у. Ну это конечно верно, ведь ψ-биекция,
значит частности, она инъекция. То, что если х равен у значение функции от х,
сравняет значение функции от у, это вообще для любой функции. А в обратную сторону это
свойство инъекции. Если значения функции равны, то и аргументы равны. Ну а у нас вообще даже
биекция, поэтому это конечно выполняется. То есть когда один предикат равенства, с предикатом
проблем нет. Теперь с функциями. Давайте смотреть, что у нас написано. Фи от произведения должно
равняться произведению образа х и у. Но это свойство гаваморфизма, это мы знаем. И уже этого
достаточно. Вот смотрите, если у нас есть гаваморфизм, и биекция это уже называется
автоморфизмом группы, но формальное определение требует еще двух условий. Вот здесь? Ну в группе. То
есть, фи у нас действует на группе, то есть это я пишу просто условия в группе. Фи от х-1 равняется
фи от х-1. И нужно, чтобы сохранялась константа. Это вот если константе тут применить, то это
получится, что автоморфизм должен константу переводить константу. Ну про группы мы знаем,
что если выполнено вот это, то вот эти два свойства следуют. Мы их доказывали. Их можно
вывести из свойств гаваморфизма и биективности. Ну собственно, даже при биективности нужна из
свойства гаваморфизма они выводятся. Любой гаваморфизм обладает таким свойством, что образ
обратный обратный к образу и образ единичного единичный. Ну вот так вот нужно, вообще говоря,
выписать не два, как мы привыкли в группах, а четыре условия. Просто два оказываются в данном
случае следованием из предыдущего. Ну вот это вот автоморфизм. И теперь я хочу доказать теорему.
Где бы ее написать? Ну давайте вот тут вот я. Пусть у нас ПСИ это автоморфизм модели.
Тогда для любой формулы оценка этой формулы на оценке переменных КСИ совпадает с оценкой
этой формулы на оценке переменных ПСИ от КСИ. То есть в частности из этой теоремы как раз следует
вот аккуратное решение нашей задачи, потому что, смотрите, предположим, что предикат выразим,
тогда берем оценку КСИ от Х, там равно, не знаю, а. Ну или вообще пусть будет единицы. А тогда что
у нас будет ПСИ от КСИ от Х? Это будет двойка. И из этой теоремы следует, что предикат в точке
1 и в точке 2 должен оцениваться одинаково. Это не так. Он оценивается по-разному. Здесь он истинный,
здесь он ложный. Вот приходим к противоречию и все. То есть в сущности, чтобы использовать
метод автоморфизма, нам нужна в точности эта теорема. Ну ее надо еще доказать. Давайте доказывать.
Как всегда, это получается довольно длинно, потому что начать надо с термов. Я напомню,
что формулы первого порядка, у них есть такая проблема, что они имеют сложную структуру. Они
построены из атомарных формул, атомарная формула к применению предикатного символа к термам, а термы
сами по себе построены применением к термам. Поэтому в начале нам нужна лемма про термы.
Значит, если Т терм, ну я не буду писать, что ПСИ, а автоморфизм, то тогда выполняется вот то же
условие, которое я написал для основных функций модели, но на самом деле оно верно для любого терма.
Первым делом мы хотим это обобщить. Вот смотрите, что нам дано, если это автоморфизм,
что применение к функциям, которые входят в сигнатуру, оно автоморфизмом сохраняется.
Теперь я хочу доказать, что то же самое будет верно для любого терма. Ну не очень сложное
доказательство, но надо его аккуратно проделать. Давайте начнем индукция по разбору терм. Значит,
у нас самые простые термы – это переменные. Давайте начнем с переменной.
Что здесь написано? Ну вот я пишу такие обозначения, оценка переменной. Вот
здесь я писал КСИ как обычную функцию, как принято в математике, а здесь я использовал
другое обозначение, потому что оно мне удобнее. Но сейчас удобнее понять как раз это так, как
написано на левой доске. Это то же самое. Это применение двух функций, композиция двух функций.
Ну и теперь это что такое? Это означает, что мы переменную оцениваем уже как КСИ от КСИ. Это
просто... База вообще ничего не требует, кроме определений. То есть у нас просто такие
специфические обозначения, а так она, в общем-то, очевидна. Теперь шаг индукции. Я предполагаю,
что у меня есть терм, который имеет вид. Какая-то функция, примененная к другим термам. И эти
другие термы заведомо короче. У меня индукция по разбору терм, то есть по длине, можно сказать.
Термы, которые стоят в этом выражении, они будут короче, чем Т. И для них по индуктивному
предположению вот это вот выполняется. Ну давайте теперь применим... Возьмем оценку какую-то КСИ и
применим автоморфизм к значению терма на оценке КСИ. Ну как это нужно написать? Давайте распишем
подробнее. Как оценивается терм? Вот терм у нас выражается вот так. Мы должны взять функцию,
отвечающую вот этому символу, и подставить вместо ее аргументов, термов, подставить их значение при
оценке КСИ. Это просто определение значения терма. Теперь смотрите, у нас появляется
СИ, примененная функцией Ф нашей модели. Это в свойстве автоморфизма у нас записано. Теперь
мы можем применить свойство автоморфизма. Написать это так. Функция. А дальше мы должны применить уже
автоморфизм к значениям термов аргументов. Ну отлично, но тут мы уже Лему знаем это индуктивное
предположение, поэтому мы можем переставить. Автоморфизм, примененный к значению терма,
это значение терма на другой оценке, которая получается с применением автоморфизма.
Ну хорошо, мы уже почти победили. Посмотрите на то, что написано. Это по определению,
вот так же как я вот здесь расписывал, это по определению значение терма Т. У нас же терм Т
это Ф от Т1 ТК. Вот он написан. Ну и так вот он вычисляется в точке ПСИ от КСИ. Ровно то,
что нам нужно в Лемме. То есть вот для термов мы доказали, что для термов тоже выполняется
вот это соотношение, которое было в автоморфизме. То есть применение терма сохраняется при
автоморфизме. Вот это? Переход между строками. Давайте посмотрим. Да, из определения автоморфизма.
Мы в каждом аргументе... А нет, не определение автоморфизма. Извините, это индуктивное
предположение. Я прошу прощения. Да, но здесь написано F. Я извиняюсь, если это неразборчиво,
тут написано F. Мы требуем только... Смотрите, чтобы проверять свойства автоморфизма, нам не
хочется со всеми термами работать. Мы хотим только вот с теми функциями, которые есть в сигнатуре. И
мы требуем только для функции сигнатуры выполнения этого свойства. А сейчас я доказываю,
что это переносится на любые термы. Это достаточно очевидно, тут никаких нетривиальных
идей нет, но надо бы проверить, потому что у нас формализм уже задан жестко, в нем могут возникать
какие-то проблемы. Следующая лемма про атомарные формулы. Она достаточно очевидна. Если А... А
это какой-то предикатный символ, это атомарная формула, то тогда ее оценка на кси совпадает с
оценкой на си от кси. Ну и уже понятно, что нужно сделать. Нужно применить вот эту лему и
определение, которое у нас есть. А это символы сигнатуры в атомарной формуле. Поэтому мы получаем...
Давайте как-нибудь здесь поставлю звездочка, чтобы не переписывать. Много места уходит.
Звездочка. Это у нас что? Это мы должны посмотреть на предикат, которым мы интерпретируем символ,
а и применить его к оценкам термов на кси. Это по определению. А теперь воспользуемся леммой.
Удобнее давайте я сейчас, чтобы гладче было, напишу вот так вот. Вначале мы вот к этой оценке
применим. И теперь воспользуемся леммой в каждом аргументе. Я переписал порядок, чтобы не применять
обратный автоморфизм. Конечно, обратное отображение будет автоморфизмом. Зачем нам лишние сложности?
Вот смотрите, это я тут ка раз применил лему про термы. Вынес автоморфизм сюда. А теперь я применяю
уже определение, чтобы запись была на доске корректной, я вот с этого начинаю. Теперь я
применяю определение автоморфизма. У меня А оценивается вот на таком. Давайте я перепишу вот так,
потому что это получается не очень красиво. Это то же самое, я обращаю ваше внимание,
что я записываю то же самое. Просто у нас есть два способа записать композицию функции и нагляднее
все-таки вот так вот записать. Тут бы я мог, конечно, еще одну строчку написать, загнав эту ПСИ.
Нет, никуда не надо загонять. Вот это вот уже я применяю вот это свойство. Здесь мне было удобнее
переписать вот немножко вот так вот. Но это то же самое, я вот уже это использовал. Сейчас уже стерто.
А нет, вот не стерто, вот оно написано. Вот видите, это то же самое. Ну и все, мы доказали для
атомарных формул. Теперь осталось доказать теорему уже для произвольной формулы. Ну и здесь я даже не
буду особо расписывать ничего, а буду так на слова говорить, потому что дальше мы помним,
как строятся формулы. Ну точнее мне один случай надо будет написать. Как строятся формулы? Они
строятся из булевых связок и навешивания кванторов. Но смотрите, если мы навешиваем булевую связку и
у нас теорема выполняется для двух частей, ну тогда она будет выполняться и для булевой связки,
потому что булева связка это функция, булева функция значений при оценке, то есть естественно
будет выполняться. Но есть тонкость с оценкой кванторов. Давайте только про квантор всеобщности
скажем, потому что рассуждение аналогично, ну и мы знаем, что эта формула равносильна формуле с
квантором сочетания, равносильна формуле с квантором всеобщности. И нам нужно вот доказать вот такое вот
равенство. Тут есть нюанс. Смотрите, когда я оцениваю левую часть, у меня переменная х,
все переменные зафиксированы, а х пробегает все возможные значения. А когда я оцениваю правую
часть, опять-таки все переменные зафиксированы, но х пробегает там какие-то значения. И тут
становится существенным, что эти множества значений одинаковы. Когда мы подставляем вместо х
psi от возможных значений в этой модели, мы получаем то же самое. Тут даже не важно, что у нас
psi биекция, нам достаточно, что psi сюръекция. Потому что если сюръекция, то она уже пробежит
все, что нужно. Обычно автоморфизм все-таки предполагается, что он биективен, хотя иногда
бывает удобно использовать эту теорему и для такого обобщения, как это называется,
если инъективный аморфизм это эндоморфизм, а сюръективный я не знаю. Какое-то название у него,
но я сейчас не помню. Когда биекция, никакой проблемы нет. Мы оцениваем здесь и здесь одно и то же.
Нам же нужно, смотрите, чтобы использовать для формулы A индуктивное предположение, мы же
доказываем индукции по разбору формулы, я должен формулу A оценивать на оценки psi от кси. И при
этом мне важно, что все возможные значения переменной х у меня встретятся. Но это так,
поскольку биекция. Вот на этом мы заканчиваем об основании метода автоморфизмов. Он дает,
ну вот я начал с примера, потому что пример более наглядный, а доказательства такое занудные и
выглядит переливанием из пустого порожня, но в логике так бывает, какие-то вещи чисто технически
лучше проверить, чтобы убедиться, что там нет каких-то подвохов. Ну очень хороший метод,
например, давайте я сразу какой-нибудь еще пример быстренько разберу. Вот как устроены
автоморфизмы. Мы знаем, что в любой группе есть такие внутренние автоморфизмы, сопряжение.
Ну это мы проверяли в курсе алгебры, я сейчас проверять не буду, а вот у меня группа осталась.
Давайте я теперь напишу конкретную группу, скажем, группу перестановок третьего порядка,
и напишу, предикаты все те же самые, и напишу предикат, который я хочу выразить, x1,2. Я утверждаю,
что он невыразим. Потому что опять-таки транспозиция 1,2 не сохраняется при всех сопряжениях. Сопряжение
можно ее перевести в любую другую транспозицию, в 1,3 или в 2,3, это мы проверяли, я сейчас даже не
буду выписывать. Поэтому получается так, что у нас нет имени, у нас есть имя только для нейтрального
элемента. И вот выразить, ну можно там про любой из пяти оставшихся элементов сказать, если у нас мы
хотим выразить предикат x равно циклу длины 3, он тоже не будет выражаться, потому что циклы длины 3,
они тоже все друг с другом сопряжены, их два и они сопряжены. Поэтому у нас нет возможности выразить
имя. Вот если дать еще имя какой-нибудь из транспозиции, скажем вот этот предикат ввести,
то остальные мы легко выразим. Ну не так, не то чтобы легко, но выразим. Или нет? Хорошо,
это хороший вопрос. Подумайте, я стал сомневаться, что выразим, если добавить константу транспозиции
1,2, можем ли мы тогда выразить предикат перестановка равна какому-нибудь другому элементу с3? Что?
Есть подозрения, что есть еще автоморфизм, который 1 и 2 меняет местами, но это надо проверить.
Но такое ощущение, что это можно доказать просто автоморфизмом. Ну то есть если не выражается,
ну он по-моему действительно не выражается. Хорошо, но есть еще одна проблема с методом
автоморфизмов. В чем с ним проблема? Проблема в том, что иногда в моделях просто нет нетривиальных
автоморфизмов. Если автоморфизм в моделях только тривиальный, то мы ничего из этой теории мы не
получим. Потому что если psi-тошдиостное отображение, то мы получаем равенство,
что а равно а. Как-то неубедительно. Никаких противоречий точно отсюда не получится.
И я сейчас приведу простой пример. Вот у нас была модель Q с неравенством. Давайте
добавим равенство, мне не жалко. Плюс и давайте добавим константы. В такой модели уже, понятное
дело, можно выразить любой предикат X равняется целое число. Ну и на самом деле, если подумать,
любой предикат X равняется какому-то конкретному рациональному числу. Но автоморфизмов нет.
Только тривиальный. Почему так? Ну это очень легко заметить. Смотрите, пусть у нас есть автоморфизм.
Это же линейная функция. Возьмем какое-нибудь число k. И возьмем это так k раз. С одной стороны,
это будет psi от единицы, одна k прибавленная к раз. С другой стороны, это будет k умножить на
psi от единицы на k. Ну тут это просто единица, а единица должна сохраняться, она у нас константа
модели. Значит мы получаем, что psi от единицы на k это одна kt. У нас есть равенство, из него мы
получаем выражение для psi на единицу на k. Ну теперь пойдем чуть дальше. Возьмем аналогичное
равенство p разделить на q. Да, если k отрицательное, можно примерно так же рассуждать. На самом деле я
на этом не останавливаюсь. Давайте для краткости поделим. Возьмем q раз сумму дробей p на q. Это,
конечно, будет просто p. И точно так же применим автоморфизм. Что у нас получится? С одной стороны,
это получится psi от целого числа p. И поскольку единица сохраняется, p это сумма p единиц. Единица
сохраняется, значит это тоже p. А тут мы можем поступить иначе, поскольку все эти слагаемые дают
одинаковый результат. Это будет q умножить на psi p разделить на q. То есть это свойство
автоморфизма. Ну и все, мы получаем опять таки, что psi от p разделить на q равняется p разделить
на q. То есть просто получили, что автоморфизм все рациональные числа вставляет на месте.
Ну сейчас уже нужно делать перерыв. Я добавлю, что если бы у меня была модель не с рациональными,
а с действительными числами, там бы тоже не было автоморфизмов. Рассуждению пришлось бы чуть-чуть
продолжить. Я начал с q, чтобы успеть. А с рациональными числами, я думаю, вы догадываетесь,
как нужно продолжить. Нужно рассмотреть то, что называется додекиндовое сечение. Любое
действительное число, рациональное, оно однозначно задается множеством рациональных чисел, которые
меньше его и которые больше его. Поскольку они остаются на месте, то теорема двух милиционерах
говорит нам, что деваться этому числу некуда оно должно переходить себя. То есть такой элементарный
анализ. Ну хорошо, значит, метод автоморфизма вложился в пол пары. Дальше он удобен тем,
что он прост. На семинарах, я надеюсь, вы будете решать задачи, где будете его применять. То есть
если он применяется, то если есть какие-то автоморфизмы, видно, что предикат не сохраняется,
его очень легко применять. Другие методы посложнее. Ну вот мы их начнем обсуждать.
Ну сейчас давайте перерыв пока. Ножка в сторону уводит.
Значит, ну больше про метод автоморфизма я ничего говорить не буду, его полезно знать и применять,
когда он применяется, потому что его легко обычно применять. А что делать, если он не
применяется? Ну вот модели, которые мы сейчас говорили, рациональные числа, сложения, сравнения
и две константы. Все константы выражаются, все тривиально. Ну раз константы выражаются,
это следствие из этой теоремы, они должны переходить себя при автоморфизме. Это я уж не
буду сейчас объяснять, это можно доказать такой более общий факт, но аналогично этому доказательству.
Но что можно сделать? Тут во многих случаях, в том числе и в этой модели, помогает очень
интересный прием. У нас, конечно, формул много, но иногда выразительная сила модели ограничивается
только частными случаями формул. В частности, важный случай формул, бескванторные формулы.
Ну что такое бескванторная формула? Понятно из названия, она по определению формула, в которой
нет ни одного квантора. Мы можем построить такую формулу, атомарные формулы, все бескванторные,
но помимо этого мы можем еще применять к атомарным формулам булевые связки,
тоже будут получаться бескванторные формулы. Понятно, что если мы ограничиваем себя таким
образом, не используя кванторы, то выразительная сила скорее уменьшается. И действительно,
вот можно доказать, давайте для примера докажем такое утверждение. Рассмотрим ту самую модель,
где нет автоморфизмов. Я утверждаю, что в ней нет бескванторной формулы, которая выражает
предикат х целое. Вот для каждого конкретного значения, для каждого конкретного целого числа
предикат х равняется а выражается в этой модели. Ну если оно положительно, это просто нужно написать
совсем простую формулу, что х равен сумме а штук единицы. А если отрицательно, мы должны выразить
обратный, это мы можем сделать как обычно. У нас же есть плюс, есть ноль, то есть мы можем записать,
как всегда, в группе выражения для обратного и получить тоже самое. Но вот общий предикат,
что вот х целое, это другой предикат, его выразить бескванторными формулами нельзя.
Почему так? Ну давайте подумаем. Дальше мы будем, ну может быть и в этой модели я посмотрю,
может быть я чуть более простую буду разбирать, более технически, но анализ очень похож. Вот смотрите,
как доказать такое утверждение? У нас есть, я для простоты оставил только один предикатный символ,
и как у нас устроены предикаты, атомарные формулы, которые выражаются в этой модели. Ну вот так вот
они устроены. На самом деле, как выясняется, мы ничего не выиграли, что убрали равенство,
но сейчас мне так будет проще сказать немножко. То есть у нас есть один предикат, и мы сравниваем
два терма. А что такое термы? Вот давайте смотреть, как выглядит терм. Это суммы, значит терм составлен
применением функциональных символов и констант, быть может и переменных. Но у нас функциональный
символ один, сумма. Поэтому терм это всегда будет сумма. Сумма чего? Переменных и констант. То есть
у нас будет, он будет иметь вид какой-то там x1, плюс x2, плюс сколько-то, xr, плюс какая-то константа.
Никаких других термов у нас просто нет, потому что у нас только вот один функциональный символ,
ну и две константы. А ноль, прибавление нуля ничего не меняет. Соответственно, значит у нас
получается, что выражает эта марная формула. У нас одно такое выражение слева. Заметьте, что
среди переменных могут быть одинаковые. Этому ничему не противоречит. Это тоже будет терм. То
есть я могу написать x1, плюс x1, плюс x1. Это будет вполне себе терм, он будет означать 3х1. Поэтому
фактически у нас получается так. У нас получается, что мы имеем некоторую линейную функцию с целыми
коэффициентами и сравниваем ее ну с какой-то константой. Тоже целый. Целый, потому что это терм.
Мы можем подставить только целые числа терм. А знак может быть любой, потому что, смотрите,
наши атомарные формулы, переменная может ходить в левую и в правую часть. Соответственно,
если мы хотим поменять знак, мы должны просто соответствующую переменную написать в другой
части. Потому что я-то тут уже пишу неравенство, как обычно. В приведенном виде переменная с одной
стороны, константа с другой. Ну вот, просто перенося туда переменной, мы это всегда можем свести к
сравнению двух линейных функций с положительными коэффициентами. Для атомарных. То есть у нас термы
совсем простые, атомарные формулы тоже, видите, очень простые по сути дела. Давайте теперь подумаем,
что может быть в бескванторной формуле. Бескванторная формула это какое-то логическое условие с помощью
наших логических связок на вот такие неравенства. Но в нем, что существенно этих линейных функций,
давайте вот я эту функцию обозначу как-то L. Линейных функций вот таких, их конечное количество. Ну у нас
вообще атомарных формул, в формуле конечное количество, поэтому линейные функции тоже конечное
количество. Они могут совпадать, но каждая атомарная формула, ей будет соответствовать только одна
такая функция. Ну и давайте для простоты считать, что функции нетривиальные, какие-то изоитых
существует какой-то коэффициент, неравный нулю. Ну почему? Потому что если все коэффициенты равны
нулю, то такой предикат вообще никаких переменных не зависит. У нас получается неравенство 0 меньше
B, где B тоже какая-то константа. Но тогда оно либо верно, либо неверно, мы можем это узнать и
подставить нашу формулу соответствующую логическую константу и упростить формулу там, сделать
упрощение и избавиться от такой функции. То есть все элиты, они не нулевые. Что? Ну у нас есть какая-то
формула бескванторная. Я хочу сказать, что в атомарных формулах этой формулы встречается только
конечное количество линейных функций. Запись формулы и формула. Мы договорились, что формула это
слово. Когда мы какую-то более хитрую запись придумаем, я наоборот говорю о писании формулы. Не
всего, конкретные формули. Мы сейчас говорим об оценке бескванторной формулы. И смотрите,
что получится. Мы знаем, как устроены нетривиальные линейные функции. Они, начиная с некоторого места,
но у нас... Да, теперь мы хотим написать предикат от одной переменной. В бескванторной формуле это
означает, что других переменных просто не входит, потому что у нас нет кванторов, мы не можем связать
переменные. Значит, наша бескванторная формула, которую мы хотим выразить, наш предикат, она
должна содержать только переменную х. И это все сильно упрощает, потому что, смотрите, линейные
функции от х обладают таким замечательным свойством, что у линейной функции есть ровно один корень. И
когда х больше этого корня, функция имеет какой-то знак. Я сейчас b перенесу в левую часть, тоже чтобы
мне удобно сейчас неоднородные функции. Знак вот на всем таком бесконечном интервале у соответствующей
этамарной формулы получается одно и то же истинное значение, потому что этамарная формула это
сравнение, фактически знак этой линейной функции. Вот я там написал строго неравенство, а тут надо
написать знак. Ну и если 0 считать, что это не тот знак. Но если больше уже корня, то значение
всюду одинаково. Может быть истина, может быть ложно. Вот здесь, скажем, эта функция положительная,
а эта функция, наоборот, вот на этом бесконечном интервале всегда отрицательная, то есть неравенство.
Ну на самом деле вот тут у нас истина, у меня, если так уж совсем буквально смотреть на то,
что я написал, там истина, там ложь, но это не очень важно. Важно, что константа. И теперь смотрите,
какое рассуждение. Вот у нас есть бескванторная формула, и мы знаем, что если мы будем подставлять
х больше некоторого фиксированного числа, поскольку функции конечное количество, у нас все корни, они
ограничены каким-то числом. Конечное множество корней ограничено. Есть число, которое заведомо
больше всех этих корней. И вот тут вот, фи, вот если мы оцениваем здесь, оно, мы не знаем истину или ложную,
но она константа. Она будет принимать одинаковое значение во всех числах, которые больше некоторой
границы. Ну граница как-то по формуле будет определяться. Ну а давайте посмотрим на наш
предикат, х целое. Видно, что он не такой. Какое бы вы число не взяли, больше его найдутся как целые,
так и не целые. Для любого числа есть целое, которое больше его, есть не целое, которое больше его. Значит,
у нас получается, что предикат, который задается в бескванторные формулы, точно отличается от
нашего. Это вот типичный пример, как удается про бескванторные формулы доказывать, что они
что-то не выражают. Они все-таки очень ограниченные. Ну зависит, конечно, от модели, от того, какие у нас
получаются атомарные формулы. Но вот в этом случае получаются. И можно перенести это рассуждение
на какие-то другие модели. Например, вот важный пример, очень похожий на этот. Это прям название
конкретной модели. Вот как была у меня алгебратарского, это действительные числа, сравнения, сложения и
умножения еще. Арисметика Презбургера, там нет умножения, там есть, ну там равенство всегда добавляют,
чтобы не мучиться. Добавляют знак сравнения и сложения, и вот 0,1,5. Но теперь у нас модель в целых
числах, то есть носитель модели целые числа. Немножко другая модель. Но то, что в ней не выражается
предикат. Ну х целая неинтересна, конечно. Давайте какой-нибудь х-четная, да. Х-четная не выражается
без кванторных формул в этой модели. Ну точно такое же рассуждение. Тут у нас просто будут,
надо чуть-чуть, у нас неравенство, ну тут рациональные числа, поэтому мы можем вообще
поделить там. А здесь целые, но это не очень большая проблема, потому что если у нас есть
неравенство с рациональными коэффициентами, ну вот так получилось допустим, мы всегда можем
домножить наименьшее кратное, положительное, и получить неравенство с целыми числами. В общем,
это не проблема, все такие неравенства выражаются, но они нас не спасают, потому что вот та же
самая проблема. Если у нас формула без кванторная, в ней всего одна переменная, все атомарные формулы
задают какие-то линейные функции, на бесконечности получается константа, истина или ложь, как любой
формула. А предикаты в счетную не такое, там бывает больше любого числа, бывает как четные,
так и нечетные числа. Поэтому вот, ну это еще один простой пример, он мне сейчас понадобится,
потому что я постепенно приближаюсь к тому, чтобы ввести вот второй способ доказательства
невыразимости, который называется иллюминация кванторов. Модель допускает иллюминацию кванторов,
если любая формула равносильна в этой модели без кванторной. Ну я тут немножко расширил то,
что я использовал в прошлый раз, у нас были просто равносильные формулы, а сейчас мне нужно говорить
о формулах, равносильных модели. Пределение, я думаю, совершенно понятное. Модель у нас зафиксирована,
но мы при любой оценке переменных подставляем две формулы, соответствующую оценку переменных,
получаем всегда один и тот же результат. Это называется равносильные в модели. И оказывается,
что для некоторых моделей верен такой факт, что для любой формулы есть равносильная в этой
модели без кванторной. В этом случае говорят, что модель допускает иллюминацию кванторов.
Иллюминация означает истребление. Ну исключение, истребление, не знаю, какой правильный оттенок,
я латыни не знаю. И это очень важное свойство, потому что, смотрите, если модель допускает
иллюминацию кванторов, то мы сразу получаем бесплатный способ, ну скажем, вот та модель,
про которую я говорил. Давайте на секунду поверим, что она допускает иллюминацию кванторов. Тогда мы
получаем утверждение, что в этой модели предикат эксцелы не выразим. Ну сходу. Потому что если бы
он был выразим, для соответствующей формулы была бы равносильная в этой модели без кванторной,
а без кванторной он не выражается. И это типичный способ просуждения, он применим к алгебритарскому
точно так же. Пралгебритарского тоже известно, что в ней возможна иллюминация кванторов. Это важная
теорема, я ее, наверное, полностью доказывать не буду, но в следующий раз мы ее обсудим чуть
подробнее, сегодня до нее еще дело не дойдет. Поэтому, если у вас есть какая-то формула с
действительными числами первого порядка, то есть вы берете кванторы по действительным числам,
какие-то арифметические операции, сравнения, вы знаете, что можно написать эквивалентную без
кванторную. Более того, для алгоритмических приложений существенно, что бывает эффективная
иллюминация. Ну что это означает? Я слово эффективный всегда использую в одном смысле. У меня есть
такое условие, что для любого чего-то существует что-то. Эффективное означает, что есть алгоритм,
который по формуле строит равносильную в этой модели без кванторную. И чем замечательна
эффективная иллюминация кванторов, если она есть, что мы получаем алгоритм оценки значения любой
формулы в этой модели. Почему? Потому что возьмем замкнутую формулу и применим алгоритм построения
эквивалентной без кванторной. Что там будет? Там будут только то, что называется замкнутые термы и
соответственно замкнутая атомарная формула. Замкнутый термин составлен только из константов,
константы функций. Конечно, нужно еще уметь вычислять значения атомарных формул, вот замкнутых,
относительно замкнутых термов. В большинстве моделей это очень просто. Скажем, алгебритарского,
смотрите, что такое замкнутый термин? Это какое-то арифметическое выражение с нулем и единицей,
ну и какой-то знак сравнения. Ну, арифметику выполним и сравним два числа. Ясно, что есть алгоритм,
который это делает. Поэтому бескванторную формулу с нулем переменных мы всегда можем вычислить,
а для любой замкнутой формулы есть алгоритм построения эквивалентной без кванторной. Поэтому
мы запускаем этот алгоритм, потом оцениваем получившуюся бескванторную формулу. Но в частности,
это означает, что есть алгоритм, который берет любую теорему элементарной геометрии и проверяет,
верна она или нет. Записываем ее в виде формулы первого порядка. Когда я вводил алгебру тарского,
я говорил, что в сущности вся элементарная геометрия выражается. Потому что что нам нужно? Ну,
нужно там писать условия, что прямая проходит через окружность. Значит, существует решение
такого-то уравнения. Две окружности пересекаются в какой-то точке. Ну, существует, опять-таки,
если в конкретной точке, то прямо алгебраические условия, а если что они пересекаются, ну, тогда
существует. То же самое, я не знаю, четыре точки лежат на одной окружности, тоже поставим квантор,
все получим. И все более-менее стандартные теоремы элементарной геометрии, за исключением тех,
что в бенугольниках с произвольным n, а вот такие нормальные про треугольники, про четырехугольники,
про окружности. Вот они все выражаются в алгебритарского. И, значит, у нас есть алгоритм,
если доказать, что возможна иллюминация кванторов, это верно. У нас появляется алгоритм,
который решает любую задачу по геометрии. В следующий раз я немножко подробнее отслужу,
что с этим алгоритмом не так. Потому что сейчас я хотел бы, у меня еще достаточно много времени,
хотел бы чуть-чуть продвинуться дальше, чтобы начинать доказывать для конкретных моделей
возможность иллюминации кванторов, нужно вначале некоторую техническую работу провести. Вот мы ее
для этой модели, по сути дела, уже начали. Но прежде чем к этой работе приступать, давайте я
закончу с арифметикой прессбургера, потому что мне захочется эту доску освободить. В арифметике
прессбургера иллюминация кванторов невозможна. Почему? Потому что вот этот предикат замечательным
образом выражается в арифметике прессбургера с квантором. Существует такой у, что x равняется
у плюс у, но это свойство четного числа. Таким образом в арифметике прессбургера бывают модели,
где иллюминация кванторов невозможна. Вот это простейший пример. Но конкретно в этом случае все
еще интереснее. Мы можем расширить сигнатуру модели. Есть такой прием, я про него подробно,
наверное, не успеваю рассказать, ну просто вот сейчас скажу, чтобы вы знали, что такое есть.
Вот в этой модели иллюминация кванторов невозможна. Ну то есть у нас вот есть вот такой предикат,
который не выражается. А давайте расширим сигнатуру и добавим условия делимости на
произвольное число n. То есть у нас будет счетное количество новых унарных предикатных символов,
которые говорят, что x делится на n. То есть центы предиката означают делимость на n. Ну и конечно
бесконечно много, но в конкретную формулу будет входить конечное количество. И вот для этой
модели иллюминация кванторов возможна. Ну и даже эффективная иллюминация. Тут ясно,
что оценки замкнутых термов труда не составляют, но и иллюминация возможна. Поэтому замкнутые
формулы в этой модели есть алгоритм, который... Ну в частности, как выразить эту формулу? Ну
понятно, это же и есть. Этот предикат, он просто означает сравнимость по модулю 2, то есть это прям
мы в сигнатуру такое включили. То есть фактически мы такое делаем, минимальное расширение. Мы
нашли формулу с квантором, которая не выражается бескванторной. Ну давайте ее и все аналогичные добавим
в сигнатуру. И оказывается этого достаточно. В случае арифметики Презбургера этого оказывается
достаточно. Получается, что мы выражаем, и это такой важный действительно случай. Поэтому вы,
скорее всего, в книжках встретите утверждение, что в арифметике Презбургера иллюминация кванторов
возможна. Не всегда при этом будет упоминаться, что добавляются дополнительные предикатные символы.
Просто имейте в виду. Потому что додуматься того, что четность выражается формулой с квантором,
и не выражается бескванторной легко, чтобы не возникало недоумения. Потому что арифметика
Презбургера в многом возникает, и то, что там возможна иллюминация кванторов существенно,
но не всегда говорят вот про, правильно говорят про сигнатуру. Так, ну и вот после этого отступления,
теперь все, арифметика Презбургера у меня закончилась, и я хочу объяснить,
как вообще мы будем доказывать иллюминацию кванторов. Давайте я начну выписывать,
какие нам потребуются для этого утверждения. В большинстве случаев вот этот этап, он все равно
необходим, нам прежде всего нужно понять, что выражают атомарные формулы. Ну что делать дальше?
А дальше нужно вот что. Нужно научиться избавляться от одного квантора, и оказывается этого достаточно.
Пусть для любой дескванторной формулы, я их пишу сокращенно, просто чтобы места на доске экономить,
в которой давайте я напишу переменные, выделю одну переменную. Ну вообще в нее входят вот
переменные у, x1, xn. Существует, даже не так, для любой, ну да, ладно, хорошо, пусть будет существует.
Давайте я напишу формально, потом подумаю, как это сказать. Я хочу истребить квантор существования.
Ну вот, напишу такая что. Как-то умнее не придумал, как это написать. То есть, видите, да? Значит,
у нас есть формула, в которой всего один квантор существования, он в самом верху висит, то есть он
с него к формуле начинается, и потом стоит бескванторная формула. И условие такое, условие Леммы,
что любая такая формула равносильно бескванторной. Тогда модель допускает иллюминацию кванторов.
Ну и я на доске не пишу, на словах скажу, ну и в конспектат напишу, что если в условии написано,
что не просто существует эквивалентная бескванторная B, а есть алгоритм, который по формуле с одним
квантором в сочетании строит вот эту эквивалентную бескванторную, тогда существует эффективная
иллюминация квантора. То есть, по модуле вот этого перехода к этой бескванторной формуле, я сейчас
напишу алгоритм, как для любой формулы строить равносильную в модели бескванторную. И это очень
простой алгоритм. Смотрите, что мы делаем. Вот у нас есть формула какая-то большая, сложная. Мы,
во-первых, первым делом заменяем все кванторы всеобщности на кванторы существования. Ну как
это сделать? У нас в прошлый раз была равносильность. Это не в модели, а вообще просто равносильные
формулы. Это отрицание квантора существования, отрицание формулы A. То есть, применяем левому
о замене. То есть, если у нас есть подформула, которая состоит на вешивании квантора всеобщенности,
мы ее заменяем вот на такую. То есть, у нас остались только кванторы существования. И вот,
после этого мы уже находим самый глубокий квантор. Что это означает? Что вот здесь уже написано
бескванторная формула. Мы находим какой-то квантор, ниже которого уже кванторов нет. Понятно,
что такой должен быть. Потому что, напомню еще раз, по формуле мы строим дерево разбора формулы,
и внутренние вершины помечены булевыми связками и кванторами. Ну вот идем от корня, и на любом пути,
поскольку заканчивается все атомарными формулами, то на любом пути у нас рано или поздно должны
закончиться кванторы. Ниже какого-то квантора уже кванторов нет. Ну вот это и такой квантор
мы находим, и применяем лему к нему. Ну, можно было бы, конечно, вначале сделать
предваренную нормальную форму, но здесь это даже не нужно. Действительно, можно было бы рассуждать
иначе. Давайте приведем формулу к предваренной нормальной форме, заменим там, все равно кванторы
всеобщенности надо будет заменить на кванторы существования, ну и потом вот, начиная с конца,
применим. То есть нам достаточно, можно было бы не рисовать дерево, рисовать такую линейку.
Вот что-то вот такое, и внизу бескванторная форму. Это правильно, это верное рассуждение,
можно дерево не держать в голове, а держать такую линейную структуру, но это мало чего меняет,
потому что мы должны вот применить вот самому глубокому квантору лему, и получить, применить
LEMO, а замене. Тут заметьте, есть такая тонкость, мы теперь LEMO, а замене должны применять не для
равносильных формул, а для равносильных моделей формул. Ну, понятно, что там буквально все
пересказывается, потому что если мы в доказательстве LEMO, а замене будем говорить только о конкретной
модели и произвольных оценках переменных, там буквально ничего не изменится. Лемо, а замене,
верное для формул и для фиксированной модели, то есть замена на равносильную модели формулу,
дает равносильную модель формулы.
Ну и все.
И у нас получается равносильная формула, где уже кванторов
меньше.
Вот эта вот равносильная.
Кванторов стало на единичку меньше.
Потому что равносильная бескванторная формула.
Лемма нам обеспечивает бескванторную формулу.
Продолжаем так несколько шагов, пока кванторы не
закончатся.
Что бескванторная формула?
То есть в сущности вот все, что нужно сделать.
Ну так, ничего сложного, но заметьте, что это нам
упрощает?
Мы теперь должны сосредоточиться только на формулах ограниченного
вида.
Когда квантор всего один, квантор существования,
то есть мы утверждаем что-то бескванторное и говорим,
что надо выполнить условия для какой-то перемены.
У нас есть параметры x1, xn.
И для какой-то переменной вот это бескванторное условие
должно выполняться.
И мы хотим, ну это напоминает решение уравнений.
У нас есть уравнение с параметрами, допустим.
Мы хотим написать условия его разрешимости.
Ну вот это частный случай такой вот замены.
И это не случайный пример, потому что действительно
так обычно это и получается.
Что-то типа, ну не уравнение, конечно чуть сложнее, уравнение
и неравенство систем, в частности для алгебритарского
так получится.
И там поскольку это более сложно, то и доказательство
довольно техническое.
Я, наверное, технические детали пропущу.
Но все равно обычно еще один шаг делается.
Вот смотрите, вообще с точки зрения структуры бескванторные
формулы это обычные булевые формулы, в которых вместо
переменных подставлены атомарные.
И поэтому очень естественно переносить терминологию.
Булевые формулы на такой случай.
Конъюнктом я буду называть конъюнкцию атомарных формул
и отрицание атомарных формул.
Ну вам, наверное, в прошлом году объясняли про DNF, она
составлена как раз как дизюнция конъюнктов.
Ну вот мне тоже сейчас удобно про конъюнкты говорить.
Только теперь у меня будут не переменные булевые,
а атомарные формулы.
Но я буду все равно называть конъюнктом, просто чтобы
короче было.
И лемма усиливается.
Для любого конъюнкта.
Ну и дальше то же самое, если для любого конъюнкта
дальше условия точно такое же, то возможна иллюминация
кванторов.
То есть мы еще сужаем класс формул, для которых
нужно учиться истреблять кванторы.
Здесь это была произвольная, бескванторная, а я говорю,
не нужна произвольная, достаточно конъюнкта, то есть написать
конъюнкции атомарных и отрицаний, но это проще,
поэтому хочется сделать этот шаг в общем случае.
И в приложениях мы будем использовать именно эту
лему.
Это основной инструмент.
Ну потому что это почти что бесплатно, вы сейчас
увидите, что мы в сущности ничего умного для этого
не нужны.
Мы уже доказали вот ту лему, какими-то там рассуждениями
с оценкой формул, а вот тут это уже будет.
Если у нас есть какая-то булева формула, то я ж не
случайно упоминал ДНФ, она равносильна ДНФ, у вас была
такая теория.
Ну ей доказать-то не сложно, ну в общем понятно, поэтому
я беру бескванторную формулу, строю равносильную ДНФ,
а ДНФ у меня выглядит как дизьюнкция конъюнкций
как раз атомарных и их отрицаний.
Давайте как-нибудь тут напишу атомарная формула
и тут вот игж это как-то вот так вот.
Соответственно давайте подставим в эту формулу
с квантором существования всё это дело.
Получается, что она равносильна такой формуле, существует у, дизъюнция, конъюнция и каких-то там атомарных формул, возможно, с отрицанием.
А теперь давайте вспомним, что дизъюнция и кванторсуществование перестановочны.
Мы это в прошлый раз обсуждали.
То есть это равносильно уже, просто равносильно не в модели, а всюду.
И это на самом деле равносильно всюду.
А вот тут уже кванторсуществание с конъюнцией просто так не переставить, поэтому мы должны ограничиться вот тут g, а тут i.
Мы должны ограничиться в этом месте.
Но теперь мы вот это вот, используя условия нашей новой леммы, вот этой основной леммы, мы заменим на бескванторные, уже равносильные в модели.
Ну а дизъюнция бескванторных формул – это бескванторная формула.
Все, закончили.
То есть получается так, что если удастся…
Ну не обязательно у нас есть, помимо DNF, есть KNF.
Если зачем-то удобнее истреблять кванторы…
Ну тогда надо квантор всеобщности брать, надо истреблять другие кванторы.
В общем, тут выигрыша особого нет, если DNF, KNF.
Ну могут быть какие-то другие связки, которые могут оказаться чем-то удобнее.
Я примеров хороших сходу не назову.
Обычно вот так бывают удобные именно конъюнты.
Причем понятно почему.
Вот давайте, осталось немножко времени, я сделаю буквально следующий шаг, потому что разбор конкретных примеров лучше начинать в начале лекции, чтобы не было путаниц.
Сейчас я просто на будущее, на следующий раз скажу, что собственно мы хотим.
Вот смотрите, что такое конъюнция атомарных формул и их отрицаний в той модели, которая рассматривала рациональные числа, сравнения и сложения.
Ну, атомарная формула – это неравенство.
Отрецание неравенства – это тоже неравенство, только отрицание строго неравенства – не строгое неравенство.
Но если мы сразу добавим знак равно, то мы получим, что мы можем выражать буллевым образом строгое неравенство как буллевое условие на нестрогие неравенства и наоборот.
Поэтому фактически, когда у нас есть вот такая формула, конъюнция атомарных и их отрицаний, речь идет фактически о системе линейных неравенств относительно переменных с какими-то константами.
И в эту систему входит переменная, по которой квантор.
И нам нужно решить, я же не случайно говорил, что решение параметрического уравнения для нас типовая задача.
Нам нужно решить такую задачу. Вот есть параметрическая система неравенства, нужно выразить существование ее решения в зависимости от параметров.
Но неравенство от одной переменной – вот что существенно.
У нас будет всего одна переменная, потому что мы же истребляем только один квантор.
Ну а это, наверное, уже сделать можно. В школе это называется метод интервалов.
В науке о линейных неравенствах это называется алгоритм Моцкина.
В принципе, это такая важная практическая задача, поскольку у меня там все равно пару минут осталось, я немножко отвлекусь на неравенство.
Есть система линейных неравенств, проверить, есть ли у нее решение.
А как вообще это сделать? Не очень очевидно.
Моцкин придумал такой способ, что надо исключать переменные. Вы знаете, как решать уравнения исключением переменных.
У нас есть система линейных уравнений.
Берем какое-то уравнение, куда переменная входит с нулевым весом, выражаем эту переменную, из этого уравнения подставляем в остальном.
Так вот, с неравенствами тоже можно исключать переменные, только делать это нужно хитрее.
Получается так, что будет система неравенств, которой неравенств станет гораздо больше.
Вот с уравнениями все хорошо. Мы выразили из одного уравнения переменную, поставили, у нас количество уравнений просто уменьшилось.
А с неравенствами оно увеличится, но переменных станет меньше.
Поэтому мы истребим одну переменную, получим систему
не равен с большим количеством, но с меньшим количеством
переменных, истребим следующую, опять получим и так далее,
и у нас нарастет, в конечном счете получится тривиальная
система не равен с константами, но какого-то очень большого
размера.
Поэтому метод Моцкина, на самом деле, конечно он
непрактичный.
Его на самом деле применять буквально такие алгоритмы,
ну разве что в качестве упражнения кто-то писал,
но они будут работать очень плохо.
Решение систем линейных неравенства — это типовая
задача для индустрии, то есть это то, что называется
задачей линейного программирования.
Она эквивалентна, на самом деле, решению систем линейных
неравенств.
И в жизни нужно решать задачи линейного программирования
сотнями тысяч переменных, и они решаются.
И понятно, что не методом Моцкина, потому что там после
столетий исключений переменных нарастет необъятное количество
неравенств.
Решается другими методами, это отдельная история, но
есть эффективные алгоритмы.
Метод Мотткина зато хорошо ложится на логику, он дает вот как раз вот иллюминацию кванторов.
Да, ну мне пора останавливаться, я немножко заговорился.
