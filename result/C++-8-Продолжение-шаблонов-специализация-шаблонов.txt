Так, у нас последнее, что было, это templates overloading.
Мы разговаривали про то, как при наличии нескольких
версий шаблонных функций компилятор выбирает версию.
Я, кстати, сегодня собираюсь скинуть программу.
Сегодня, во-первых, появится четвертая задача, возможно, последняя в этом семестре.
А во-вторых, я вам скину программу за этот семестр,
чтобы вы начинали повторять, что ли, систематизировать.
Это все человек сказал.
Вот я в прошлый раз вроде что-то говорил такое, но не очень, возможно, отчетливо.
Вот я напоминаю, что если у вас есть f, который принимает t-амперсант,
f, который принимает код с t-амперсант, то тут перегрузка корректно работает.
А вот если бы вы одно принимали по значению, а другое по ссылке,
то такая перегрузка уже не сработает и будет неоднозначность.
Ну, в принципе, как и с обычными типами это происходит.
Вот так, тут у меня что-то лишнее написано, извините.
И есть еще такой интересный эффект.
Иногда бывает, что вы в классе, ну вот у вас есть какой-нибудь класс,
и вы в нем решаете объявить s, ну вы в нем решаете объявить шаблонный конструктор,
ну вот скажем, от вот такого. Ну зачем-то вот решаете объявить такое.
Тогда у вас поглотится конструктор копирования. Что значит поглотиться?
Но если вы напишете s от const s-амперсант, а потом будете создавать свое s от другого s,
то вы будете попадать сюда, потому что по правилу точное соответствие лучше приведения типа,
лучше попасть в конструктор, соответствующий точно по сигнатуре, чем навесить константность.
Вот это такой неприятный эффект, который надо иметь в виду, когда вы своему классу
определяете шаблонные конструкторы. А вы наверняка будете своему классу
определять шаблонные конструкторы. И там придется что-то придумывать,
чтобы конструктор копирования при этом оставался на плаву.
Да, если я теперь создаю s от другого s, то я попаду не в конструктор
копирования, как хотелось бы, а сюда. Потому что это предпочтительнее,
ну потому что тут const не надо делать. Вот, ну вариант либо определять отдельно
конструктор вот такой, который кстати тоже формально считается конструктором копирования,
и его кстати тоже компилятор умеет генерировать. Ну можно написать, что типа, ну там, этот конструктор
можно определить просто как s от, ну идут const cast навесить какой-нибудь, ну вряд ли такое вам
пригодится. Скорее, ну короче увидите, когда такая ситуация случится, тогда и поговорим.
Что делаете? Если это const, то конечно этот, потому что частное предпочтительнее общего.
А зачем может понадобиться вызов конструктора по ссылке? Ну в смысле, вы написали это ссылка.
Чего вызов конструктора, а что там должно по-твоему быть? Константная ссылка?
Ну такой-то конкретно случай у вас вряд ли будет, а вот с двумя амперсандами очень даже будет,
когда будет универсальная ссылка, так называемая. Всё, проехали. Просто имейте в виду,
что такая проблема есть. Давайте дальше. Следующая штука это специализация шаблонов.
Не буду писать полностью слово. Так вот, я вам рассказал про перегрузку шаблонных функций,
но есть ещё специализация шаблонов. Сейчас мы поговорим о том, что такое специализация шаблонов.
Ну проще рассказать, что такое специализация шаблонов классов. Вот у вас есть какой-нибудь класс.
Ну давайте опять-таки, я буду писать структура S. Абстракт S. Ну и в нём что-то есть, я не знаю.
Ну что угодно типа. А давайте я сразу буду на примере вектора. Вот в векторе есть значит
T звёздочка массив, да, как мы уже выясняли там. Size T, size, size T, capacity. А казалось бы,
что может пойти не так. Можно для некоторых конкретных типов этот класс переопределить
иначе. Вот что такое специализация. Да, вот вы знаете, я неспроста привёл вектор,
потому что такой классический пример. Вы можете захотеть, чтобы ваш класс для вот
некоторого конкретного типа был определён не так, как для общего случая. Да, и, например,
вектор bool является таким классом, который специализирует обычный вектор. А в чём его
реализация отличается от стандартного вектора? Ну там не вектор, ну там не bool звёздочка, там
char звёздочка скорее. А когда вы в него по индексу записываете, там происходит записывание определённого
битика в нужный char. Но я сейчас не буду писать, как устроен вектор bool, хотя у нас в планах это
достаточно подробно разобрать. Сейчас мы не будем с вами прям писать реализацию, но меня сейчас
больше волнует, как это синтактически пишется, как именно с точки зрения специализации. Как это
пишется? Пишется следующим образом. Я пишу опять шаблонный префикс template, указывающий на то,
что это всё ещё шаблон, а дальше у меня уже ноль шаблонных параметров, зато вот здесь есть
один явно указанный шаблонный параметр, и тут что-то там, какие-то поля. Вот, вот,
внимание на синтакте специализации, он может быть неинтуитивный. Вот здесь вот я перечисляю те
шаблонные параметры, которые мне реально остались нужны. Их совершенно необязательно должно быть
ноль. В общем-то их даже необязательно должно быть меньше, чем было здесь, а их даже может
быть больше, чем было здесь. Смысл специализации в том, что она после слов template и какие-то там
угловые скобочки, уточняет вектор от чего. Вот, когда я определяю обычный шаблонный класс,
я пишу template blah blah blah в вектах, ну, название класса, и дальше у меня вот эти вот шаблонные
переменные, метапеременные внутри тела класса. Когда я определяю специализацию, я пишу template
какой-то снова шаблонный префикс, смотря сколько мне нужно шаблонных аргументов оставить. И здесь
определяю, значит, в угловых скобочках, прямо после названия, для чего я конкретизирую. Вот,
специализация обязательно должна быть объявлена после общей версии. Если я напишу так до нее,
то это будет CE, компилятор скажет, что я пытаюсь специализировать класс, который еще не объявлен.
Вот, если я... вот так ты хочешь написать или что?
Ну, да, есть более умный способ. Значит, скоро мы с вами научимся навешивать условия на типы,
и вам не придется такое писать. То есть, на самом деле, мы просто научимся скоро делать
compile-time-проверки, чем является тип. Ну, например, если тип это будет или имп,
сделай одно иначе другое. Ну, такое тоже можно. Вот, но пока мы не умеем, да, поэтому так.
Вот, специализация должна быть объявлена после общей версии. Вот, когда есть специализация,
то только вот такой конкретный тип попадает сюда. Если даже тип не явно приводится,
то это не повод идти в специализацию, только вот для данного конкретного TE. И еще раз напоминаю,
что эти два типа, вектор от какого-то TE и вектор от Bool, это не связанные друг с другом типы
с точки зрения компилятора. Один к другому никак не преобразуется, это просто нагенерированный
код. Компилятор просто подставляет то, что называется делать инстанцирование, когда мы
подставляем какие-то TE, но это не означает, что эти типы для него как-то какие-то что-то общие имеют
с точки зрения компилятора. Вот, то, что я показал, называется полная специализация. Вот это вот полная
специализация. А бывает еще частичная специализация. Частично это когда вы не все параметры
специализируете, или когда вы специализируете лишь, скажем так, вид параметра, а не его конкретное
значение. Сейчас продемонстрирую. Вот представьте, что у меня есть структура, вот теперь уже будет
абстрактно. Представьте, что у меня есть структура вот такая. TypeNameT и TypeNameU. Стракт S. И тут есть два
поля вот таким. Вот, но это такая шаблонная структура с двумя параметрами, шаблонными параметрами.
Вот, но я могу, допустим, эту структуру специализировать для ситуации, когда у меня типы одинаковые.
Допустим, в такой ситуации я хочу сделать всего одно поле. Вот, пожалуйста, тоже себе вполне
специализация корректная. Обратите внимание на синтаксис. У структуры все еще два шаблонных
параметра. Я не могу путем специализации уменьшить ей число шаблонных параметров,
но я могу навесить некоторые ограничения на то, какие они путем специализации. Сейчас я написал,
что если так сложилось, что в этой структуре передали два одинаковых параметра, то иди вот в эту
частную версию. Вот это называется частичная специализация. Частичная она, потому что я
не уточнил конкретно, то есть у меня под эту специализацию подходит много вообще
ситуаций. Вот, ее частичность лишь в том, что я навесил условия, что параметры равны,
но не сказал, чему они конкретно равны. Конечно, никак это они не связаны друг с другом. Я могу
объявить, в принципе, ничем не мешает шаблонный конструктор от другого S. Понятно, что если я
захочу, я могу сделать их все конструируемыми друг из друга. Я могу, например, сделать их все
друзьями друг друга. А можно как-то общие методы делать? Кому? Так, они... Если у них должны быть
какие-то методы прям совершенно одинаковые, то их не подойдет. Ну, унаследоваться можно от общего предка,
например. А можно одну унаследоваться, другую нет? Да, по-моему, можно, да. Ну, есть-то разная
сершонтипа, может быть одна наследница и чего-то, а другая не является наследником. Вот, кажется, да.
Что еще можно? Можно их все сделать друзьями, да, например, все такие шаблонные структуры. То есть
написать шаблонное объявление друга, то есть сказать template typeName a, typeName b, friend struct S. Я
вот только правда не уверен, что здесь нужно писать a, typeName b в угловых скобочках. Ну, в общем,
неважно. Ну, короче, можно все их сделать друзьями друг с другом. Такой шаблонный друг. Мой шаблонный
дружок. Так, хорошо. Да. Вот частичная специализация бывает еще вот какая. Например, я могу сделать так.
Давайте я это скопирую и сказать следующее. Представим, что у меня, например, ну так вот выглядит
дело. Это другой вид частичной специализации. Я навесил условия на тип тем самым. Шаблонных
параметров по-прежнему две, но теперь, допустим, вот если второй из них является ссылкой, то я попаду
в эту версию. Но я тоже самое могу сделать там, если этот параметр является указателем, я попаду в
эту версию. Или если он является константным, например, я попаду в эту версию. То есть я просто
один из параметров сделал каким-то уточнил, скажем так. И теперь, если я попадаю в
частный случай, что у меня, например, если я s от int запятая double-impercent создам, то попаду сюда.
Вот, если я, допустим, сейчас создам специализацию, ой, создам попытающий экземпляр s, например,
int&int%, то скорее всего будет ce, потому что из двух специализаций он не сможет выбрать какая лучше,
какая более частная. Ну, непонятно какая. И это чем-то хороша, и это чем-то хороша. Вот,
здесь, скорее всего, он не сможет выбрать, скажет, неоднозначность. Как с ним бороться? Делать
нормальные специализации. Так же, как при перегрузке функции, вы с ним боретесь. Либо не создавать
таких объектов, либо делать так, чтобы было понятно, как из специализации выбирать. Вот,
значит, это специализация классов. Теперь поговорим про специализацию шаблонных функций. Она
тоже бывает. Но с шаблонными функциями есть загвоздка. Дело в том, что у функций же бывает
еще и перегрузка, помимо специализации. Вот, смотрите, сейчас мне понадобится main,
наверное. Ну, давайте я возьму, сделаю шаблонную функцию. Ну, неважно, не буду тип указывать. Если
кто еще не знает, чтобы компилятор не жаловался на не используя переменную, нужно просто не
указывать имя переменной, то я в очередной раз хочу обратить ваше внимание на это, а то,
когда люди такие вопросы ближе к концу семестра, в чате создают мне даже неловко. Так вот,
ну, обычная функция. А теперь смотрите. Не так. Давайте будет функция с двумя аргументами.
Ну и тут два типа я принимаю. У типов нету параметров, потому что некоторые, я уверен,
что до сих пор не все знают, что можно так. Да, да, да, но понимаешь, в чате много раз писали,
много чего до этого. Тем не менее люди спрашивают. Вот, ну, смотрите, вот я сделал такую штуку. Вот у
меня есть функция двух шаблонных параметров, которые уют один, и этот от одного, который выводит два.
Ну, аргументов в обоих случаях два, а шаблонных параметров то один, то два. Ну, ни у кого не
вызывает, я думаю, все понимают, что выведется в каждом из этих двух случаев. Ну, что выведется в
каждом из случаев? Сначала один, потом два, потому что второе более частное. Вот, но то, что я сейчас
написал, это не специализация функции. Это очень странный... так, что? О-хо-хо-хо. Темплэйт, а не тайпнэйм.
Вот, но это, это не специализация сейчас, это перегрузка. А в чем разница между перегрузкой
и специализацией? А вот сложно сказать. Ну, короче, это не специализация, точно говорю. А сейчас покажу
специализацию. Специализация будет вот. F от int int. Вот это специализация. Поскольку для функций
существует перегрузка, комитет по стандартизации решил проблему терминологическую таким образом. Вот,
если у вас есть несколько версий функций с одним и тем же именем, но разными наборами параметров или
разными наборами шаблонных параметров, то это все называется перегрузкой. А специализация считается
только ситуацией, когда у вас с пустого префикса темплэйта начинаются объявления функций. А все остальное
считается перегрузкой функций. Казалось бы, какая разница, как это называть, а вот сейчас выяснится,
что есть разница, но сначала давайте поймем, что выведется в этих случаях. Ну, очевидно, выведется
сначала один, потом три. А разве что-то изменится, если мы уберем темплэйт пустой? Сейчас. В данном случае как-будто нет.
Сейчас увидим. Короче, сейчас понятно будет один, потом три. Вот. Давайте закомментируем. Теперь это
перегрузка. Ну, теперь ее нельзя вызывать шаблонными аргументами, например. То есть, я не могу,
вот если я напишу вот так, то я получу два. Вот. А если бы здесь был темплэйт, то при таком вызове
я все равно получил три. Вот смотрите, вот сейчас я все равно получу три при втором вызове. Потому что
теперь считается, что это вот это f, это под случай как-бы вот этого случая, когда я от него
шаблонного аргумента вызываю. Вот. Но есть один замечательный пример интересный.
Где? Да, ну. Вот если так я написал, ну так все равно будет три. А если бы тут не стоял шаблонный
префикс, то так было бы два. А теперь фокус. Я беру и вот эту вот штуку переношу сюда. Да блин,
никак не научусь вставлять в ВИМИ нормально. Смотрите, теперь у меня что есть. Ну да, shift-Pan,
тот же вопрос. Что сейчас выведется?
Перестававки, что должно поменяться?
Вот сейчас внезапно выведется два, а не три во втором случае.
Потому что так решил комитет по стандартизации.
Значит, почему? Почему он так решил? Ну, а специализация, она должна прицепиться
к какой-то версии функции. Специализация это как-бы такая прицепка к какой-то основной из версий.
Вот у нас сейчас здесь две перегрузки, и у одной из них есть специализация. Просто специализация
прицепляется ближайше сверху. Вот сейчас по факту у меня две версии F, но одна из них специализирована.
Ну, потому что это с точки зрения перегрузки версии две. Это просто прицепка к первой версии.
Сначала решается, кто победил в перегрузке, а потом, если у этой версии перегрузки была
специализация, то мы посмотрим, не подходит ли она. В данном случае в перегрузке выигрывает
вторая версия, вот эта. А у нее нет специализации, поэтому сюда мы не попадаем. Вот это важный
пример, который стоит запомнить, демонстрирующий разницу между специализацией перегрузкой для
шаблонных функций. Просто поменял местами и изменилось поведение от этого. Почему, почему что?
Ну, я же только что рассказал, потому что сначала решается какая версия перегрузки побеждает,
а потом уже нет ли у этой версии перегрузки специализации подходящей. Специализация
прицепляется к ближайшей сверху версии перегрузки. Нет, третья. Вот это, это перегрузка.
Ну да. Но пригодится, ну нужно ли вам будет так писать, я не знаю, но теории можно, почему нет?
Сначала перегрузка, потом специализация. Почему же на этом этапе не выберется средняя функция,
потому что она не является перегрузкой. Нет, она является специализацией другой просто версии.
Еще раз, у вас есть две версии, вот FATU и FATT. Эта штука прицепилась к той, которая сверху была,
вот они две версии перегрузки, а это какой-то из них прицепилась как подверсия, скажем так.
А чтобы вызвать там среднюю функцию, нужно, что нужно сделать вообще?
Ну сейчас, наверное, если я сделаю вот так, то я получу третью.
Ну потому что у нее два шаблонных параметра, а у этой всего один шаблонный параметр.
И вот таким вызовом я всегда получу версию, причем более того, даже если я вот так сделаю,
кажется я все равно получу третью, правда я вот тут уже не уверен. А нет, тут я получу, тут я
получу первую, да, потому что он ставит соответствие соответствующих. Да, ну вот так получу третью.
Сейчас специализация она работает примерно как наследование, то есть у нас есть какой-то
дерево с главной функцией. Ну что значит? Я не знаю, что значит как наследование,
но вот она так работает, как я рассказывал. Ближайший сверху, я же три раза сказал уже.
Так, все, идем дальше. Вот, ладно, это были такие технические подробности. Сейчас будет очень
важный пункт, который вам прямо пригодится в ближайшее самое время. Сейчас мы разберем,
что еще может быть параметрами шаблона кроме, собственно, типов.
Не знаю, а изучение вообще любого языка, например, там русского или английского, это что?
11 глаголов исключений, например. Это как так вышло? Так решил комитет по грамматизации.
Когда новый стандарт выпустили? Ну вот, да, вот выпустили новый стандарт,
стало можно кофе в среднем роде говорить. Вот примерно так и живем.
Ну да, да, я и говорю, вот кофе среднего рода теперь можно.
Так, очень важный пункт. Очень важный пункт не типовые параметры шаблонов. Не типовые не в том
смысле, что они какие-то необычные, а в смысле, что не являющиеся типами.
Что еще может быть параметрами шаблонов кроме типов? Вот сейчас, если никто из вас до этого,
ну никто, если кто-то из вас вот с шаблонами до этого не работал, у него может немножечко
сломаться мозг, потому что в первый раз, ну, в общем, большой риск немножечко запутаться,
но постарайтесь. Числа могут быть параметрами шаблонов, просто числа, а не типы. Я могу
написать template int n, а дальше void f, вот чего-нибудь, int x, например. Ну и там, не знаю, вывести x
плюс n. Вот, пожалуйста, я вам написал функцию, у которой шаблонным параметром является число,
и обычным параметром является число. Ну и как такой функции пользоваться? Ну, могу, например,
вызвать f с шаблонным параметром 2 от 1, выведется 3. Это много, чем отличается. Что за хрень-то?
Я понял. Да что ж такое? Зачем я? Господи, потому что я, все, я понял, потому что я вместо g
плюс-плюс пишу vim. Все понятно. Ну вот, вот 3 вывелось. Значит, вот, добро пожаловать,
функция с шаблонным параметром int и с обычным параметром int. И вот я вызываюсь от этих.
Да, между словом template и открывающей угловой скобкой пробел ставится, а вот между названием
функции открывающей круглой не ставится. Вот так вот живите с этим. У меня появился второй вопрос.
Да, кстати, смотрите, code style, значит, ну просто привыкните и пишите так, все нормальные люди так
пишут, и вы так делаете. Когда вы объявляете шаблон, вот здесь пробел ставится, а когда используете,
не ставится. Вот здесь не ставится пробел, а тут ставится. Понятно? Да, все ясненько вам, понятненько.
Так, что, есть вопросы вот про этот пример? Тут вроде все понятно. Ого-го-го, ну сейчас,
нет, зачем это как раз, вот это как раз очень нужно. Когда мы писали просто template от какого-то
type name n, то как нам завести, допустим, вот у нас в template было написано type name t, как нам в этом
же template завести переменную типа t? Как так и завести t и x точкой запятой? Нет, вот у тебя в template
допустим было type name t. Что значит в template завести? Как в template передать переменную типа t? А, нужно было бы написать,
допустим, у тебя было написано type name t, а не ты бы через запятую передал t, а какой-нибудь t, n. Ты хочешь
прямо в угловые скобки t что ли вставить? Да, да. Да, можно и так, например, так можно написать.
Допустим, у меня есть type name t, после этого t уже в принципе рабочее, я могу вот так написать.
Ну, только мне надо здесь другое, ну так могу написать. А можно маленький вопрос задать? Можно, да. А код что ли по
ходу компиляторам этого мусора собирается? Что значит по ходу компилятора? У нас очень много разных видов функций,
как это устроено на уровне реализации? У нас же очень много разных видов функций, это скипами там еще понятно,
типа плюс-минус их счетное количество, а вот значение перегенда может быть очень новым. Так, вот смотрите,
это устроено также как и с типами. И вот здесь как раз я сейчас должен сказать важную вещь,
главное ограничение, которое проистекает из такого. Вот это вот n должна быть константой,
причем не просто константой, а compile time константой. Да, да, да, ну я пока еще не объяснял,
что это такое, но да, вот то, что является параметрами шаблона, должно быть константой,
но не просто константой, а compile time вычислимой константой. Что, например, ну, например,
я очевидно не могу сделать так. Он дает написать просто constant без constant. Сейчас, сейчас,
сейчас обсудим. Вот так я не могу сделать, очевидно. Вот, вот все посмотрите, пожалуйста,
на этот пример и поймите, почему так невозможно просто сделать даже теоретически. Да, вот если
вы пока не понимаете, если вам кажется, что казалось бы, что такого плохого я написал,
вот пере, переосмыслите свои взгляды. Вот вам должно стать, вам должно стать очевидно и
понятно, что вот это полный бред и компилятор такое скомпилировать не в состоянии. Он же знает,
что переменная a тип знает и что он не знает, чему она равна на момент компиляции. Нет,
он должен ее передать шаблонным параметрам. Это не то же самое, что передать обычным параметрам.
Значит, шаблонные параметры это штука, которая подставляется в compile time и генерируется. Вот
если у меня будет, вот понимаете ли вы следующее, что например f, вот такая f, вот такая f,
вот такая f, ну и так далее. Это все разные f, у них разные адреса, например. То есть я могу,
ну вот кто-то понимает, вот я остальных спрашиваю. Я могу спросить, какой адрес,
ну сейчас конечно мне не выведется, потому что адреса функций так себе вводится на консоль.
Но вот это все три разных функции с тремя разными адресами. В памяти прям это как три разных
функции лежит, отдельных, не связанных друг с другом. То есть компилятор в compile time
подставляет вместо шаблонных параметров конкретные числа, конкретные значения. Точно
так же, как он подставляет типы, так он здесь подставляет конкретные числа. И это и компилятор
генерирует код. Значит шаблоны это история про кодогенерацию. Компилятор фактически подставляя
разные значения в compile time генерирует много разных f уже без угловых скобочек. И вот их
компилирует уже нормально. Шаблонная кодогенерация это такой подэтап, предшествующий нормальной
компиляции фактически. То есть теперь у нас появился еще такой новый этап. Подэтап компиляции
это шаблонная подстановка. Сначала развертывание при процессор, потом шаблонные подстановки,
потом только нормальная компиляция. Так вот, ну инклуды всякие. Когда инклуды разворачиваются при
процессор я говорю. Это разворачивание при процессорах. Потом делается шаблонные подстановки,
вот уже когда компилятор начинает работать. Вот, тем не менее, если я напишу вот так, то так все-таки
можно. Но только надо проинциализировать эту a. Ну то есть если компилятор в состоянии в compile
time понять чему равно значение константы и подставить, то он сумеет сгенерировать. Но
какой пример константы, от которой нельзя сделать? Ну вот такой же, давайте я заведу.
Арксинуса нуля? Нет, арксинуса нуля получится, почему нет? А у меня не получилось, когда я объявлял D.
Ну там, давай ладно, я сейчас не буду этот пример разбирать, это долго, мы отвлечемся. Ну там
констэкспорт должен быть в самой функции, поэтому оно должно работать вроде как. Он будет
кастовать здесь W. Вот смотрите, сейчас. А да, sin. Вот, теперь я беру и говорю вот так и вот так
уже конечно не выйдет у меня ничего. То есть вот это константа, но это не compile time константа.
Вот. Is not usable in a constant expression. Вот для таких выражений существует понятие constant
expression. Constant expression это выражение, которое вычисляется в момент компиляции и значение его
известно на этапе компиляции. Вот сейчас B это не constant expression. Вот до этого A это было constant
expression, потому что в compile time компилятор уже знает чему оно равно и знает что не поменяется,
значит может подставить шаблон. А здесь он не знает и поэтому не может подставить шаблон. Зачем нужны
шаблоны с числовыми аргументами? А они очень даже нужны. Например для чего? Чтобы что? Например
или например матрице. Матрица M на N. Это же какой-то тип. Ну у вас допустим матрица из int размера
10 на 10. Это же другой тип нежели матрица из int размера 5 на 10. Не так ли? Ну и вот. Вот вам
пожалуйста тип параметризованный числом. Давайте я продемонстрирую вам такой еще один класс
из стандартной билетеки. Да. А если мы заранее не знаем размер матрицы? Значит все провал,
ничего не получится. Если нам размер матрицы дается в входный данный? Тут мне надо повторить
мантру, которую я говорил в самом самом начале. C++ это статически типизированный язык,
к счастью или к сожалению. Все типы должны быть известны на этапе компиляции. Если мы не знаем
размер матрицы, то видимо надо все-таки его делать параметром не шаблона, а поля. Ну да,
тогда его придется делать каким-то runtime параметром, а не compile-time параметром. А можно
отнаследовать этот мусор, который был озвучен? Какой мусор? Подожди, подожди, я никого мусора
сейчас не озвучил. Ты зря так. Матрицы это фиксированный размер? Да. Манити размер не фиксированный,
как правило. Да. А кого из них ты мусором-то назвал? Я что-то не пойму. Нет, это не очень приятно.
Ну ты можешь и что тебе это даст? Нет, отнаследовать ты можешь, а что тебе это даст-то? Ты в матрицах,
которые без шаблонных параметров реализуют какие-то общие методы типа, а как они будут выглядеть?
У тебя же все методы, они используют размер свои в себе. Как нормально работать с переходами,
а не шаблонов и шаблонов? То есть если у нас есть тип не шаблонный, с которым мы как-то в общем
виде работаем, и при этом мы хотим иметь такой же тип, но не шаблонный, чтобы с ним работать
немножко по-другому. Я не понимаю, это какой-то очень абстрактный вопрос, очень-очень общий.
Конкретный пример, если у нас есть матрицы, мы хотим иметь два вида матриц. Матрица конкретно
размера 3 на 3, для них иметь отдельные методы. И матрица размера n на n, для которого у нас будет...
Сделаем матрицы размера 3 на 3 специализацией матриц размера n на n. У тебя для матрицы 3 на 3
будут свои отдельные методы, не похожие ни на кого другого.
Нет, n на n у нас не зафиксированы.
А если мы хотим параллельно с этим параметром, вот такие вот n и m, передавать пользователю, чтобы они...
Если ты хочешь, чтобы n и m были runtime-параметрами, то шаблоны тебе никак не помогут.
Все, шаблоны — это чисто compile-time-штуковина.
Это просто два разных подхода к реализации.
Давай я тебе сейчас покажу другой пример, который, собственно, и собирался показать, прежде чем...
Глубоко компилятор запускает почувствения вот этих вот...
Это мы обсудим через... Это мы в следующем пункте обсудим.
То есть, если писать constar, но p, b и r, то все равно...
А, ты про это... Не знаю, если честно.
Насколько так глубоко можно осуществить?
А... Я тебе...
Есть одно специальное волшебное слово, которое заставляет компилятор досчитать на этапе компиляции.
Оно называется constexpr.
Но я не хочу сейчас про него рассказывать.
Я хочу про него рассказать, когда мы уже более базовые вещи разберем.
Вот, смотрите.
Есть в стандартной библиотеке такой замечательный класс.
Называется array.
Знали о таком?
А почему он подсветился сюда? Мы будем его разбирать.
А вот мы его уже и разбираем.
Все разобрали.
Все разобрали. Он вот так и выглядит.
Ну, в нем есть методы разные.
В нем есть методы. Сейчас я вам только...
Ну, давайте я вам браузер открою.
Пошел.
А у нас запись идет, да?
Я просто в какой-то момент научился под запись не открывать свой браузер,
а то там всякие ненужные вещи возникают.
Потом все знают, что...
Потом все знают, что браузеры имеют.
Да, какие страницы я в свободное время открываю.
Вот, значит...
Ну вот, std array.
Неужели справочник будет тоже?
Вот. Что это за штука?
Ну, это... Это что за покемон?
Это просто массив фиксированного размера.
Большой вопрос, а на хрена?
На хрена.
А это очень удобно.
Потому что...
В ООП парадигме реализовывают массив фиксированного размера.
Почему это удобно?
Ну, обычные массивы, сишные,
они обладают разными странными неприятными свойствами.
Например, они кастуются к указателям неявно.
Или их нельзя друг к другу присваивать, скажем.
Вы помните, что массивы нельзя друг к другу присваивать, например?
Да.
Вот. Или нельзя там делать...
Что там еще с ними нельзя делать?
Можно деструктур прописать ему или тогда памятник.
Нет, деструктур у него и так...
В смысле, кому?
Не, не, не.
Вот.
А этот STDRA, им пользоваться очень удобно.
Ты просто берешь и...
Ну, то есть, у него есть все методы, как у обычного контейнера.
То есть, можно квадратными скобочками, front, back,
итераторы, размер, значит, empty.
Вот.
Ну, вот просто пример.
Пример использования, да?
Чего? Сайз? Что?
Да, да, да.
Вот.
Код чего?
Мой?
Ой, ну вот все.
Открыл браузер, и вы увидели много чего лишнего.
Ну вот.
Вот, собственно, все, что этот массив хранит.
Он не динамический.
Он просто хранит на стеке.
В полях.
То есть, массив из N элементов.
Ну, собственно, его можно создать от N элементов.
Ну, можете посмотреть, что вы можете создать.
Здесь N это константа времени компиляции.
То есть, это одномерный такой массив.
По сути, это одномерный вектор.
Но константного размера.
И пользоваться таким массивом, конечно же, гораздо эффективнее,
чем вектором, если вам не нужно
размер менять в runtime.
И удобно.
Потому что этот массив ведет себя, как обычно, переменно.
Присваивать можно его друг к другу.
Ну и так далее.
Разумеется, в прочем, если вы заведете такой массив
слишком большого размера, например,
не знаю, 100 миллионов,
то вы получите секфолд, потому что стекворфлоу.
Но, да.
Вот, как бы,
как он понимает,
какое количество массивов нужно выделить?
Понятно, что мы фиксируем размерный,
мы можем как-нибудь форики, в зависимости от runtime
сделать несколько таких массивов.
Не очень понятно, как он на этапе компиляции выделит под них файлы.
Как он понимает, сколько интов надо выделить тебе?
Так же, как и столько массивов.
Ну, обычная переменная.
Это же на стеке.
То есть, он по очереди будет на стеке.
Это же переменная на стеке.
Как он понимает.
То есть, мы не можем считать переменную и создать array?
Размера n, где n в виде нос клавиатуры нет, не можем.
В этом и смысл array.
Размер известен на этапе компиляции.
Вот.
Ну, а соответственно,
логичная штука,
которая вам предстоит,
логичная следующая идея.
Это двумерный массив размера...
Вот.
Такой замечательный класс.
Давайте я бы...
Давайте я бы сказал...
Я бы причем даже написал вот так.
И здесь написал...
Вот что.
Вы уже,
наверное же,
дошли до матриц над произвольным полем,
или нет?
Ну вот, видите, как хорошо?
Ну...
Ну как-то не очень хорошо
типы одной буквы называть,
если это не числа.
Так что, подожди, m и n это не типы.
m и n это константы.
t и u без d и k.
Ну t это, как бы,
такое...
Соглашение.
t и u соглашение, а f это...
Ну да, да, да.
Нет, ну,
здесь скорее дело вот в чем.
Просто это вам, это уже прям,
класс, который не постоянно реализовывается.
Это все были учебные примеры, а это уже такой настоящий,
жизненный пример. Вот, ну и все.
И здесь вы храните фактически
массив размера m на n,
или вектор размера m на n.
Ну как хотите.
Можете массив c размера m на n хранить.
Вот.
У вас будет вот так.
Надо сделать.
Вот, то есть, смотрите,
матрицы, они же могут быть над разным.
Они могут быть над
рациональными числами,
а могут быть над...
Над веществными уж тогда.
Но...
Еще, я вас прошу
реализовать вот такой класс.
А...
Да.
Ну, смотрите,
у вас бывают вычеты
по моделю m.
Да.
И над ними тоже можно делать
матрицы.
Соответственно,
матрицы у меня будут
как над...
Ну, они будут над разными
штуками пытаться строиться.
Бывают матрицы над рациональными числами.
Соответственно, там...
Операции там, обращения,
всего, определители и так далее
будут нормально вычтяться.
Шаблонный f of t?
Шаблонный f of t? Нет.
Кажется, не придется.
А чего ты там так боишься?
Пиши шаблонный f of t.
А зачем f of t?
А вот хотелось бы
как-то
compile time запрещать
ситуацию, когда
фил не является моим лидером.
Да!
Ты прям...
Я рад, что мои желания
совпадают с вашими. Это тоже
надо будет делать.
Значит, в compile time
ну, это
небольшое забегание вперед,
но сейчас мы это сделаем, да.
Мы сейчас научимся в compile time проверять
на простоту.
А как это проверить?
А как это проверять в compile time?
Что ты имеешь в виду?
Что значит проверять в compile time, что оно является полем?
Как ты в compile time будешь проверять,
например, что сложение ассоциативно?
Я не очень понимаю.
Сложение ассоциативно?
Чего?
Сложение...
Ты веришь?
Ну, вот в то,
что выполним отделение,
верить никак нельзя.
То есть, что именно
ты хочешь, формально,
с точки зрения плюсов, что означает твои условия,
что оно является полем?
Что в нем поддерживаются определенные операции.
Без уточнения
свойств этих операций.
Такое можно делать.
Для этого служат
сфинае, так называемые, а еще
концепты, но это будет конец второго
семестра. Мы...
В общем, это можно, но это
очень весело, классно
и будем мы это делать весной.
Сейчас пока мы будем этого делать,
потому что это вам и так хватит.
Да, что за вопрос?
Нельзя в качестве шаблонного поля
для поля...
Шаблонного поля для поля?
Передать поле.
Передавать таблицу сложения и
умножения. Что значит, передавать таблицу?
Это как?
Но мы же можем
передавать миру.
Давайте передавать массив.
Нет, я не понимаю.
Как ты таблицу на генерешену
сделаешь?
Генерешен уходит от 4 элемента.
Ты делаешь...
Я не очень
понимаю, что вы хотите сделать.
Давайте я расскажу, что
можно делать и что вам нужно будет
сделать. Тихо. Давайте я расскажу,
что можно делать, что нужно будет сделать,
а фантазии на тему, а что еще
теоретически можно было бы сделать.
Мы потом, как-нибудь, не в учебное время
в чате пообсуждаем, потому что иначе
передавать не успеем ничего.
Короче, вот.
Класс вычетов по моделю N
и класс
матриц
размера M на N над произвольным
полем.
Вот.
Кстати,
как будет, например,
выглядеть оператор умножения
двух матриц? Это может быть кому-то
не очевидно, давайте напишем.
Но он будет не членом.
Вот как будет выглядеть
давай, вот кто понимает,
как объявить умножение матриц?
С такими вот.
Ну, блин,
темплей, это очевидно.
А дальше что?
Сайс T, M,
сайс T,
N,
сайс T, K.
Ну,
и type name.
Ну, давайте
все-таки field.
А то, что
Irrational прописал это по дефолту?
Да, это шаблонный параметр по умолчанию,
я про это рассказывал в прошлый раз.
А здесь почему не прописал параметр?
Ну, потому что
это же
оператор, я же от двух матриц его вызываю,
когда я буду вызывать его от двух матриц,
уже по матрицам понятно, какой field.
Вот.
Что будет возвращать?
Matrix.
Размера M на K.
Field.
И вот здесь, кстати,
я могу не писать, кажется.
А, нет, должен писать, потому что оно
должно быть таким же, как там.
Оператор умножить
от
const matrix
обожаю.
M запятая
M
Подожите, я так не хотел.
Я не знаю почему.
M запятая
field
ampersand
const
matrix
N, K
field
ampersand.
Если я...
Ну да, имена я потом.
Соответственно, если я
начну таким образом пытаться перемножить
матрицы несоответствующих размеров, я получу
CE.
Или если я буду пытаться перемножить
матрицы
над разными
полями, я тоже получу CE.
Вот.
Могу.
Ну, секрет.
Но я могу.
И вас тоже научу скоро.
На самом деле
есть
лайфхак, плюсовый,
как делать проверку.
На самом деле я уже делал проверку
на CE, если вы внимательно
смотрели.
Когда, например, я проверял, что
константной строки ничего нельзя
присваивать, как я это проверял.
Есть такая метафлукция.
std is assignable. Я беру квадратные скобочки
от вашей строки и проверяю, что ей
допустимо присвоить char.
Она возвращает true, если можно,
и false иначе.
Но это другое дело. То есть можно просто
проверить, определённый ли метод в классе.
Вот.
В общем, короче, существуют способы
это написать, и это мы с вами тоже
разберём, как делать.
Но есть более простой способ
для тех, кто плюсов не знает.
Я же могу просто написать
G++
Но я могу написать G++ ваш код
или G++
G++ маленький тестик
или G++
следующий маленький тестик и так далее.
И в самом только конце
G++ уже нормальный код.
Ну, вы же
знаете, как работают
аргументы командной строки, двойная персант,
двойная вертикальная черта.
Вот компилятор при неуспешной компиляции
возвращает код ошибки 1.
Соответственно, будет продолжаться
выполнение этого конвейера G++
или G++, только если
неуспешной была предыдущая компиляция.
Вот и всё.
И у вас просто не дойдёт компиляции до нужного файла
и вы получите странный вердикт,
что ничего не удалось завершить.
Так что да, я смогу в контесте
проверить, что у вас не компилируется
то, что не должно компилироваться.
Вот, поэтому да.
Можно просто будет
сделать так, как Яндекс.Контест обычно
делает СЕ и без лода.
Это он так редко делает.
Не, после этих выходных я вообще
не пастор Яндекс.Контеста стал, мне кажется.
Что угодно могу проверить Яндекс.Контеста.
Так, господа,
продолжаем. Нам ещё надо
успеть
много чего.
Да, смотрите,
ну, вот
какие типы могут быть параметры мешаблона?
Ну числа могут быть, могут быть
чары, могут быть, ну вообще любые
числочисленные типы.
Вот.
А может ли дабл быть параметром
шаблона?
Могут ли камень не платить налоги?
Может ли дабл быть параметром шаблона?
А
стринг
раз и не может? У нас вообще
был пример
а стринг не может.
Ну давайте
попробуем.
Но кажется нет.
Кажется, потому что
я не уверен, что они там добавили все
плюс-плюс 20, может и это тоже добавили.
Но нет, всё-таки не может.
Потому что
так решил. Ну короче не может.
Ну потому что
это довольно-таки
бессмысленно. Ну да, типа как
в compile-time дабл хранить?
Это можно было бы делать, но
Дабл, наверное, понятно.
Да, ну то есть даже
с плюс-плюс 20 нельзя дабл
делать параметром шаблона.
Вот может ли стринг быть параметром шаблона?
А как вы это себе представляете?
Там же динамическая память должна выделяться.
А там, что не должна выделиться
динамическая память выделяться?
А там, что не
должна?
Нет, он сейчас звёздочки...
Если передавать строку элитерал,
он ничего не выделяется в динамической памяти.
Ну на самом деле
сейчас правда, конечно
будет немного странно,
но давайте я вот так сделаю.
А...
Ладно.
Значит...
Как видите...
Да, because it's not structural.
Короче, нет, не может.
Но на самом деле
с плюс-плюс 20
ослабили ограничение на то, что может быть параметром шаблона,
и там теперь параметрами
шаблона могут быть классовые типы.
Вот до с плюс-плюс 20 параметрами шаблона
могли быть только целочистые типы,
ну да и всё, в общем-то.
А начиная с плюс-плюс 20 параметрами
шаблонов могут быть
объекты некоторых классов, но
не любых.
Ну...
Честно говоря, я не помню какие там формальные
требования. Вот стринг не подходит,
но если я заведу какую-нибудь простую структурку,
в которой будет несколько...
Не знаю, не помню.
Не пользовался этим.
Шаблон массив передавать, что ли?
Ээээ...
Чё?
А рей передавать?
СТД рей параметром
шаблона быть, кажется, не мог.
Да, не мог, нет, не мог.
А вот сейчас мог.
Ну это, ты довольно странный,
ну вот, например, такое, кажется, можно, да.
Но только рей
непонятно что, сейчас я его заинклужу.
Можно сейчас написать
типа...
Ну всё.
Вот, например, СТД рей,
это вполне себе нормальный
параметр для шаблона,
потому что он, ну, просто на стеке
хранит 10 тинтов. Пожалуйста,
можно параметром шаблона делать
рей, то есть, например, я могу теперь
написать так.
f от
1, 2, 3, 4, 5
в фигурных скобочках.
А остальные
нулями проницилизируются.
О, как вам такое?
Сейчас, а указатель
я тоже...
Ну нет, он не может
из initializer листа рей сделать
в compile-time.
Ну, короче, можно сделать...
Нужно ещё написать слово
constexpr, чтобы рей compile-time
создался, и дальше получится.
Короче, я не хочу, я сейчас
не буду это про это дальше говорить,
не знаю, попробую.
Я не буду пробовать сейчас.
Указатель, думаю,
можно.
Указатель, думаю, можно.
Но
я не хочу сейчас.
Я не хочу.
Короче, сейчас пока
от вас требуется только уметь
пользоваться шаблонами с параметрами,
являющимися типами,
с параметрами, являющимися целыми числами
и булями. Вот, все эти
приколы примочки C++20
мы обсудим, когда
там, короче, веслой.
Сейчас пока хватит и без этого
вам с чем возиться.
Но это всё ещё
не все виды шаблонных параметров,
которые бывают. Бывают
шаблонные параметры, являющиеся
типами, бывают шаблонные параметры,
являющиеся числами
ну или переменными,
а бывают шаблонные параметры, являющиеся
шаблонами.
Темплэйт, темплэйт параметры,
так называемые.
Сейчас я вам покажу
шаблонный параметр,
являющийся шаблоном.
Только я для этого хочу, чтобы у меня
код начал компилироваться.
Давайте я удалю просто вот эту часть.
Смотрите.
Вот знаете, есть такой
класс,
стандартная библиотекя
stack.
Темплэйт typeName
class
stack.
Стд stack.
Вот класс stack, короче,
есть в стандартной библиотеке.
Всё ещё в 6.4.
Всё ещё в 6.4, да.
К сожалению.
Ну,
всё ещё в 6.4, да.
Всё ещё в 6.4, да.
Всё ещё в 6.4, да.
К сожалению.
Ну,
ладно, нормально, если...
А с кочуром будет пар или сибирь?
Не, вечером снова буду я
и снова будут плюсы, да.
Мы не... Мы...
Надо много по плюсам ещё успеть. Пройти в этом
семестре, что там медленные.
Вот.
Так вот.
Stack. Знаете, что такое stack?
Кажется,
этот вопрос я уже задавал где-то в начале
тестера.
Что внутри stack?
Как устроен класс stack?
Там на самом деле
есть...
Stack это на самом деле обёртка над другим
контейнером всего лишь.
Stack это не самостоятельный контейнер
в стандартной библиотеке.
Он состоит из...
Ну, на самом деле у него есть второй
шаблонный параметр.
Который по умолчанию равен
stddec от t.
Вот. Но его можно сделать
stdvector от t.
Ну, короче, вот.
Я просто делаю stack на основе
шаблонного контейнера.
На основе контейнера.
Я вторым параметром передаю
underline-container,
подложка.
Stack на основе вектора, например,
могу сделать.
Вот. Но!
Я мог бы сделать и по-другому.
Я мог бы написать
следующее.
Что параметром шаблона
является шаблон. Но ведь по сути у меня
вектор это шаблон, который является параметром
другого шаблона. Правильно?
Я stack делаю на основе вектора.
Тогда...
Я могу написать вот так.
Я сделал параметром шаблона
шаблон.
Я написал
темплей... А, да. Кстати, я вам
показать, что если мне не нужны
шаблонные параметры,
то я их могу тоже имена им не давать.
Этот векс, кажется, не говорил.
Это только может потребоваться.
Очень скоро потребуется.
Увидеть.
Точно тогда же, когда есть
функция. Вот. Я могу
не давать шаблонному параметру название,
если не собираюсь его использовать.
Ну, например, когда я
специализацию шаблона делаю, я могу не использовать
некоторые из параметров.
Вот. Так вот здесь я сделал
именно это. Я написал темплей.
Дальше снова угловые скобочки, и я перечисляю,
что является шаблонными параметрами
шаблона. Уже этого.
А потом говорю class container.
Вот здесь
тонкий момент.
До C++17
вот здесь обязательно нужно было писать class,
а type name уже не подходило.
Но начиная с C++17,
здесь тоже можно писать type name.
Ни в чем, кроме того,
что вот иногда нужно писать
ни в чем.
Сейчас уже ни в чем. Начиная с C++17 вообще ни в чем.
Но вот
здесь
или здесь
надо было писать class, а не тут.
Ну, короче, неважно. Сейчас можно везде
писать type name.
Вот.
Ну,
я по старой привычке буду писать здесь
слово class, имея в виду, что это
все-таки не какой-то тип,
а прям настоящий класс целый, с шаблонными
акубентами даже.
Да, давай удалим, чтобы, так сказать,
не...
Ну да, я вот удалил здесь название n,
поэтому, видите,
он не понимает, что такое n.size.
Так вот.
Я сделал
контейнер шаблонным параметром шаблона stack.
Теперь контейнер внутри stack
это шаблон от одного аргумента.
И я могу, например, говорить
контейнер от int
c.
То есть контейнер теперь это не полноценный тип,
а шаблон, которому нужно подставить еще один
аргумент, чтобы он стал полноценным типом.
Нормально?
Вполне.
Вот.
Смогу... Давайте
я попробую такой stack
создать от std-вектора, например.
Получится?
Стоп.
Чего?
Ой-ой-ой, виноват, виноват, конечно, да.
Вот именно здесь я не должен писать шаблонные аргументы.
Потому что я передаю
в качестве шаблонного параметра шаблон,
а не тип. Вектор int это
законченный тип, а вектор просто
без уточнения это шаблон,
а не законченный тип.
Ты можешь передать еще в отдельный параметр t?
Сейчас.
Да, я могу сказать
template typeNameT
Чтоб у тебя скомпилировалось?
Пока я еще не компилировал.
Но сейчас-то не скомпилируется, если что.
Можно
вот так сделать.
Тогда я могу написать вот так.
int.std-вектор.
А у него есть шаблон просто typeNameT, написать template typeNameT
классный пример?
Эээ...
Могли, но
t это откуда
бы взялось?
Ну, ровно в этом прошибу.
Передали бы.
А,
ты пишешь это вот так?
Ммм...
Кстати...
Да, а здесь
что, тогда тебе придется здесь писать
контейнер от t, по-моему...
По-моему, так...
Нет, стоп.
Может, кстати, так и сработает.
Ну, сейчас это не сработает по той причине, что у вектора
на самом деле не один, а два шаблонных параметров.
Вот здесь мне нужно
еще один typeName.
Мало кто знает, но у вектора есть
второй шаблонный параметр, который по умолчанию,
который все обычно забывают.
Он называется allocator, да.
Поэтому вот теперь это сработает.
Кхм-кхм...
Ааа...
Теперь это...
А, это не сработало, потому что
стэк же не знает, что у контейнера
второй аргумент по умолчанию,
поэтому мне теперь нужно второй аргумент
передать по умолчанию.
Ну...
Ааа...
Там
он вот так по умолчанию выглядит.
std allocator at int.
Сейчас.
Теперь...
Теперь-теперь-теперь...
В стэке, там же наверху,
я в стэк передал
два шаблона
аргумента, а их всего один.
Все, теперь компилируется.
Давайте попробуем
сказать то, что вы
написали, не получится ли у меня
вот так.
Честно говоря,
да, я даже не знаю, но мне кажется, что
нет, да, не получится.
Ну правильно, да,
потому что, что такое T?
Откуда взялось, непонятно.
Илья, а если ты в принципе не будешь
создавать такого стэка, то у тебя компилируется?
Да, потому что
ну, я могу дать имена этим шаблонным
параметрам, просто я их нигде
не использую.
Нет, смотри, я могу теоретически
как-то использовать. Допустим, у меня потом
еще был бы шаблонный параметр какой-то, который
в себе использовал там
допустим typeName
равно std-вектора T.
Вот здесь это T, оно понятно откуда.
Потому что
потому что
вот здесь понятно откуда
ему взять T. Вот этот контейнер, T
это его первый шаблонный аргумент.
Тогда вот здесь второй typeName, это будет
std-вектора T.
А, нет, не работает.
Ну значит...
Это шаблон в шаблоне,
то есть вы говорили
компиляция, то есть вот здесь
вы можете в контейнере
написать стэк, а вне контейнера
уже стэк, определен даже внутри
внутри стэк.
Да, согласен, так нельзя, так
неправильно, да, согласен.
Я, что такое контейнер?
Ну, я могу здесь написать равно
и по умолчанию написать чему равно.
Наверное. Чего, что такое контейнер?
В смысле...
В данном примере
или вообще?
Вообще.
Это долго рассказывать,
это целый, у нас целая глава будет
про это.
Видимо какой-то абстракт
да, что?
Можно еще раз мотивацию так
писать?
Чтобы параметром шаблона был шаблон,
чтобы я мог вот, ну как, вот,
я в стэк отдал просто
не вектор от конкретных типов,
а вектор...
Вектор как таковой, а внутри
этого уже могу конкретизировать
вектор.
Все, пока что.
На пункт
6.4.
Вот, ну, а сейчас будет
моя любимая, и на этом мы закончим
первую пару.
Следующий
пункт, который я хочу успеть разобрать,
это...
вот такой замечательный
пункт.
Сейчас мы с вами позанимаемся
простейшими
вычислениями на этапе компиляции.
Что?
А, да, все нормально.
Так.
Давайте...
6.5. Извиняюсь.
У меня просто в другом году была
номерация немножечко измененная.
В прошлом году
виртуальные функции были после шаблона.
Может быть, циклы какие-то...
Значит...
Отвечаю на вопрос
и сразу говорю
то, что
может кого-то шокировать.
Язык шаблонов полон
по тьюрингу?
Ну, то есть,
шаблоны
этот язык в языке полноценный.
На шаблонах можно
вычислить все.
Что значит вычислить на шаблонах, вы сейчас увидите.
Сейчас я вам покажу
классический пример, как
в Compile Time с помощью шаблонов
вычислить n-ное число фибоначчи.
А на олимпиадах есть ограничения
на премьеру? Да, это самый популярный
вопрос, который задает продвинутый поток
после того, как я это говорю.
Год от года вопрос не меняется.
А как это использовать на олимпиадах?
Ну, можете попробовать
использовать на олимпиадах, да.
В предвычислении, да,
в Яндекс.Монтесте есть ограничения на время компиляции.
Более того,
во втором семестре у нас будет задача,
где самое сложное будет влезть в Compile Time
тл, а не в
Rantart. Но у нас
и в этом семестре будет такая задача.
В общем-то, это и будут матрицы.
Вам нужно будет проверять
число на простоту в Compile Time.
Ну, то есть, у вас есть
матрица.
У вас есть кольцо
по модулю N?
Иногда оно является полем, иногда нет.
Если N простое, то является.
Соответственно, если оно простое,
то деление должно быть определено.
А если нет, то не должно быть.
И это должна ошибкой компиляции быть, а не ошибкой Rantime.
Если я пытаюсь
поделить,
если я пытаюсь выяснить оператор деления
в кольце, вычитав
по модулю 10,
то я должен получать CE.
11 не должен.
Соответственно, задача
реализовать класс
вычитав по модулю N так,
чтобы тогда и только тогда, когда N
простое, в нем был определен оператор деления.
Ну, то есть, вызов оператора деления
не давал CE.
Да.
Для некоторых
да, но в общем случае нет.
Поэтому мы говорим CE, если я
пытаюсь поделить.
Значит, я хочу, чтобы
когда модуль не простое число, деления не было.
Ну и
даже так,
я хочу, чтобы просто,
например, матрицу нельзя было обратить,
если то, что переданим,
не является полем, в том смысле,
что в нем нету,
скажем...
Ну вот,
у меня есть, допустим, матрица
над кольцом вычитав
по модулю 10.
Такую матрицу создать я могу.
И я могу перемножать такие матрицы.
Но я хочу, например,
что в момент, когда я пытаюсь инвертировать матрицу
над полем вычитав по модулю,
извиняюсь, над кольцом вычитав по модулю 10,
я бы получал CE,
а не RE со словами деления на ноль.
И вот именно так, и нужно
вот именно это реализовать и будет
вашей основной целью
в последней задаче, видимо, последней этого семестра.
Видимо, пятую учитку не успеть.
Давайте для начала я покажу,
как вычислить числа фибоначчи на этапе компиляции.
Это стандартный пример,
с которого все начинают. Смотрите.
Я пишу
template int n,
ну size tn на самом деле, но ладно.
struct
fibonacci
an
Да, это будет структура.
Это будет
метапрограммирование такое.
У меня здесь
функции,
такие метафункции, это на самом деле структуры.
А значение этих метафункций
это
константы, которые
в структурах лежат.
Вот у меня в структуре фибоначчи
будет статическая константа
value
равная
fibonacci
n-1 value
плюс
fibonacci
n-2 value
У меня бесконечная рекурсия.
Что же делать?
Как же избавиться от рекурсии?
Ну надо специализировать.
Сейчас, подождите, давайте я напишу
fibonacci от 1
и тут я пишу
static constant
int value
равно 1.
Ну а еще
от 0.
static constant value
равно 0 будет.
Ну, 0-ое число
fibonacci это поможет.
Ну, 0-ое число fibonacci это
по-моему все-таки 0.
Это зависит от того, как ты хочешь
я предпочитаю число fibonacci
определять так, что в формуле бене было n,
а не n-1.
Вот если ты
0-евым числом fibonacci назовешь 0,
то кажется у тебя формула бене сработает
с постановкой
phi в степени n надо будет возводить как раз.
Вот поэтому я, лично я предпочитаю
любым числом fibonacci считать 0,
но я не против, если у вас другое определение
числа fibonacci, теоретически у меня
как бы не протестую.
Потому что что?
Я не прослышал.
Так, смотрите какие
чудеса-то.
Теперь, если я беру и говорю
как что такое?
Это обращение к статическому полю класса.
Я обращаюсь не к нему, я обращаюсь
к полю другого класса.
Который уже от n-1.
Это другой совершенно класс.
Ну давайте выведем 10 число fibonacci.
О, пошли глубокие вопросы.
У нас же есть ограничение на время
исполнения, а есть ограничение на количество
сгенерированного кодакода.
Ну так и работает.
Там есть EML и ETL
в compile-time.
Ну, в настройках контеста,
если вот здесь посмотреть,
вот я
классно.
Ну вот, тут есть
в настройках вполне себе
Господи, ладно,
хорошо, я предпочитаю вот это.
Блин, в настройках задачи
делается.
Ну короче, есть в настройках
вполне себе
Ну давайте, вот я покажу вам на примере
biginteger.
То есть ограничение EML и ETL
существует как у run-time, так и у compile-time.
Не-не-не,
это плохой путь, нет.
Так, ну вот, давайте
10 число fibonacci вычислим.
Вот, пожалуйста, 55.
Чего?
Да, я знаю.
Смотрите,
вот что будет,
если я
сделаю бесконечную шаблонную
рекурсию?
Ну, логично, что будет CE.
Сейчас будет очень забавная
шипрокомпиляция.
Fatal error.
Template instantiation depth exceeded
maximum of 900.
Значит,
по умолчанию у компилятора
есть лимит,
сколько уровней шаблонной рекурсии
он готов
инстанцировать.
И здесь такая подскаточка.
Используйте вот такой параметр, чтобы увеличить этот лимит.
Минус Ftemplate depth
равно.
Вот, когда вы будете проверять
числа на простоту в Compile Timer
с помощью шаблонной рекурсии, вам предстоит
увеличить этот лимит.
Нет, здесь же написано
минус Ftemplate depth, это такой параметр
компиляции.
В системе у меня будет
стоять минус Ftemplate depth сколько надо.
А если он не стоит, то сколько надо?
А если мы считаем, что надо больше?
Я не знаю,
можно ли это делать через Pragma,
но вот я знаю, что можно делать таким шаблонным параметром.
У Selengo, кстати,
лимит повыше.
У Selengo лимит
1024.
А ты попытался вывести какой-то большой
число? Я попытался
просто, я бесконечную рекурсию
сделал.
Вот, ну хорошо.
А он на циклы проверяет?
Если он
зациклится, то все, рекурсия
закончилась же.
Ему больше не надо инстанцировать.
Дальше вопрос в том,
зацикленные у тебя сами
определения, то уже будет runtime рекурсия, кажется.
О нет, не runtime, виноват.
Ну короче, его именно инстанцирований
много слишком.
Если он как-то вот руками
на этапе компиляции
Если у меня нулевое число фибоначи
бы использовалось снова 10 число фибоначи,
то мы зациклились бы
в цикл, но это был не
бесконечная шаблонная рекурсия,
это была бы бесконечная компиляция просто.
Вот не знаю,
если, кстати, будет
я не знаю, наверное,
это было бы CE, наверное,
возможно, блин, я даже не знаю,
честно говоря, надо попробовать, не знаю.
Потому что за линию вычисляется все это?
Вот, за какое время вычисляется
n-ое число фибоначи здесь.
Залинейное, потому что каждая
структура
инстанцируется один раз, просто так,
как он ее сгенерировал один раз, ему больше не надо.
Вот это не то, как
вызовы функций работают, если вы делаете
просто тупую рекурсию с вычислением
чисел фибоначи, то у вас получается экспоненциальная
сложность, правильно? Потому что вы
каждый раз вызывая f от n, вычисляете
заново f от n минус 1 и все предыдущие.
Здесь не так, здесь если вы
проинстанцировали фибоначи от n,
то вы больше не инстанцируете
его заново, когда к нему обращаетесь, там уже
готовая константа лежит.
Вот, понимаете ли вы,
почему здесь статик
и почему конст?
Статик, потому что я не
создаю ни одного объекта типа фибоначи,
я просто использую эту структуру,
как...
Ну, мне
только статическое поле в ней интересует.
И почему конст? Потому что если
было не конст, то в compile-time-е он бы отказался
вычислять это.
Вот.
Ну...
Чего если?
Так это же то же самое.
Нет, он
не будет создавать
десятки заново.
Блин, а почему
он вообще так эгилирует,
когда подобный код в систему я вызывал?
Ну, давайте я проведу эксперименты
здесь и здесь, попребовать от него
фибоначи десятая.
Что произойдет? Вероятно
он упадет с той же ошибкой, потому что он
просто зациклится в инстанцированиях.
Ну, хотя с другой стороны, он же вроде не инстанцирует.
Нет, то же самое
произошло, то же самое.
То же самое.
Ладно.
Ну, потому что чтобы ему посчитать,
чему равно
фибоначи первая, ему пришлось опять зайти в
фибоначи десятая.
Он так и не понял, чему равно
фибоначи... А, вот почему.
Потому что фибоначи десятая же он не сумел понять,
чему равно.
Для этого ему пришлось зайти и так далее, и так далее,
фибоначи первая, а там снова фибоначи десятая.
Он так и зациклился, потому что у него теперь...
Ну да. То есть он так и не инстанцировал
фибоначи никакой в конечном итоге.
А можно
но
для этого потребуется
слово constexpr,
а вам будет запрещено им пользоваться, вам нужно
пока на шаблонах.
Что?
В этой задачи нельзя
использовать constexpr, в этой задачи вам
нужно на шаблонах все написать.
constexpr мы
будем потом пользоваться.
В втором семестре. Вот, последняя
штука. Помните, я вам
говорил, что бывают шаблонные
переменные?
Ну вот теперь вы понимаете, зачем они могут быть
нужны.
Шаблонная
переменная,
добро пожаловать.
То есть мне теперь не надо писать
value
вот это вот все, мне просто
можно писать фиб десятая.
И это переменная, шаблонная
переменная, параметризованная
числом,
которая равна вот этому вот.
Луки, а это ты там сорок не писать?
Никак.
Дайте им полночь.
А вы не писать?
Вопросики?
Вопрос,
а, но если так написать, он только
десятого сгибает? Да, конечно.
Зачем мы генерировать остальные?
А если там будет допустим cn и
cfn? Ага.
ce
n это не константное выражение.
Не может параметром
шаблона быть runtime переменная.
Только compile time
константа может быть параметром шаблона.
Если ты еще потом попробуешь вывести
двадцатая
у него
первые десять уже сгенерированы, мне придется
заново.
Вот смотрите, давайте я попытаюсь
вывести, не знаю.
Стотысячное число
фибоначи.
Вот я,
вот у меня сейчас
a.out занимает шестнадцать килобайт.
Давайте я попытаюсь
сгенерировать, не знаю,
двухсоттысячное число фибоначи.
А произойдет
ub, потому что
переполнение, ну как, произойдет
в runtime ub. Но меня
это не волнует. То есть пусть там будет какая-то
непонятная константа.
Да, я хочу
сделать
минус f template depth равно дофига.
Не-не-не.
Вот.
Двухсоттысячное число фибоначи.
Но там будет бред какой-то.
Кстати, возможно будет
Смотрите, warning.
Не early exhaust.
Как приятно.
Да, тут произошла
неувязочка.
Он мне выдал ce
из-за того, что у него переполнение int
случилось, кажется.
Сделаем unsigned depth, вроде как
переполнение unsigned depth.
Да, давайте
static const
unsigned
Господи.
Да, давайте
Господи.
Я уже
объяснял, что оно считается за atn,
потому что одинажды инстанцировав шаблон,
он потом не должен инстанцировать
его снова.
Все, теперь у меня
все int без знаков, и давайте попробуем
еще раз.
Теперь переполнение не должно быть.
Main, master, turn, int.
Не удалось, конечно.
Хорошо, давайте просто int
сделаем.
Еще раз
пробуем.
Но ничего, потерпим.
И подождем, да.
Все, скомпилировался.
Теперь, смотрите.
Да, я minus f template depth.
А, нет, тоже 16440.
Ну,
значит, он не вписал
в бинарник все эти значения.
То есть к чему был этот эксперимент?
Эксперимент был к тому, что
он же сгенерировал
по ходу компиляции 200 тысяч
экземпляров Fibonacci.
И в каждой из них
статическая константа value есть.
То есть это супер долго.
И ему, то есть в compile time
он вот это все проделал.
И по идее
все эти вот экземпляры
этих структур Fibonacci, то есть все вот эти
вот классы, определение классов, все
он создал. Он их сгенерировал.
У него 200 тысяч разных классов
он скомпилировал, пока компилировал эту программу.
Вот. Но он их
не вписал в бинарник, потому что
ему только один из них потребовался, он
константу вывел.
Вот. Но вообще-то
если вы генерируете
если вы, короче, генерируете шаблонный
код, имейте в виду, что компилятор
реально создает вот такое количество
классов, которые вы тут запросили,
когда шаблонные рекурсии ему организовали.
А почему у тебя переполнение
не произошло?
А переполнение чего должно было произойти?
Не знаю, stack, допустим.
Зачем? Откуда?
Он сказал stack nearly exhausted,
но не переполнился, видишь?
А, это warning он
выкопал. Это warning, да.
Ну, я не знаю.
Вот, кстати, G++ как бы
с этим справился можно проверить.
А, G++ падает.
А это что?
А, во-во-во, да-да-да.
Вот G++ не справляется. О-о-о!
Да-да-да.
Да.
Да, смотрите, смотрите,
смотрите, что произошло.
Сейчас G++ упал
из-за того, что
произошел segfault в compile-time.
Потому что
пока он инстанцировал,
пока он инстанцировал эти 200...
Ну, C-Lang справился. C-Lang, видимо,
более оптимально это делает.
А G++ не справился инстанцировать
200 тысяч шаблонов.
И упал с segfault в compile-time.
Internal compiler error.
Причем, смотрите,
в чем не сказали.
А, вот...
Да что же такое это? Нет, не посылать ничего.
Segmentation false signal
terminated program CC1+.
Вот, помните, я вам говорил, ну или Федя вам рассказывал,
что компиляция состоит
из нескольких частей,
и первая из этих частей там подстановка.
Вот CC1+, это что такое?
Это вот та самая программа,
которая непосредственно компиляция занимается,
то есть у вас G++ — это же конвейер.
Там сначала идет распаковка инклудов,
потом идет непосредственно компиляция,
потом идет линковка.
То есть у вас на самом деле две программы
сначала...
Ну, подстановка инклудов,
потом CC1+, вот эта та самая
программа, которая непосредственно
компиляцию выполняет, кода,
то есть языковую компиляцию.
А потом вызывается LD-линковщик.
И вот у нас segfault
программу cc1+, здесь написано
Segmentation Folded Signal Terminated Program
cc1+, то есть операционная система убила
вот тот самый cc1+, который
компиляция занимался,
пока он компилировал. И g++
сказал, что произошла internal compiler error.
И мы с вами сейчас научимся проверять
число на простоту в Compile Timer.
Но я сделаю это за ОАТН,
а вам надо будет за ОАТ нормального.
Ну чего-то.
Ну...
Если вы сделаете закон
в четвертой степени, можно будет, не знаю,
до балл дать.
Ну, в смысле, до балла-то, типа,
не по 10 бальней шкале, конечно, и даже не по...
Корень четвертой степени на шаблонах, проверка на простоту, на шаблонах, не в обычных проверках.
Корень четвертой степени это долго, можно же там выскокать, залог квадрата.
Ой, какой лог квадрат?
Залог квадрат.
Нет, залог квадрат вряд ли.
Лучшее, что я знаю, если детерминированно, это, это, кстати, вам Райгородский на конце первого курса расскажет.
Если мы хотим не разложить, а только проверить на частоту, там же есть...
На простоту.
Продлинг-ризайн, наверное.
Что там есть?
Если ты про алгоритм Миллера Рабина, то он работает за куб, и то это при том, что ты фурье пишешь.
Там в кубе логу log n получается.
То есть четвертой степень, короче, там примерно.
И еще и при этом у него вероятность ошибки есть.
Ну, короче, все плохо там.
Так, что-то мы какую-то вот фигню сегодня обсуждаем.
Давайте плюсы лучше пообсуждаем.
Давайте, давайте пообсуждаем.
А у нас опять запись идет или нет на этот раз, я не знаю.
Давайте подумаем, как вот проверить, что...
Прости, а за сколько нам нужно сделать?
Да за корень квадратный.
Эх, нет, хотите, я вас за корень четвертой степени сделаю.
И не сделаем, будете РО-полоку на шаблонах писать, но не надо.
А не в этом цель.
Так, вообще, на самом деле, может быть, я вам и не буду показывать, а вы сами напишите просто.
Можно показать просто?
Давайте я идейно покажу, что надо сделать, да?
На шаблонах, да.
На шаблонах.
Ну, смотрите, template, type name...
Ой, какой type name?
int n
Я недавно научился, после того, как Вим поискал какую-то строку, чтобы сделать ее неподсвеченной, надо набрать команду NOH.
Вы знали о таком?
Да.
О чем Mustang Overflow за этот ответ набрал 1970 очков.
И, таким образом, 19700 рейтинга, а весь его рейтинг это 27000.
То есть, просто за один этот факт ты стал звездой Static Overflow, понимаете?
А вы говорите, если бы Static Overflow исчезло, можно было бы заново на таком рейтинг набирать, а не как сейчас.
Так вот, структура isPrime будет у меня.
В ней будет static const bool value равно...
А вот теперь давайте подумаем, что надо здесь написать.
Наверное, мне нужен, знаете, такой helper.
Но я буду сейчас перебирать делители.
На самом деле, блин, неинтересно, я сейчас за вас свою задачу решу почти.
Ну давайте, да, я напишу template int int int d.
struct isPrime helper.
И тут будет примерно такое.
Значит, что здесь будет?
Ну, он будет...
Когда я дошел до...
Ну, что-то не хочу я дописывать, потому что сейчас все сразу станет вам всем очевидно.
Давайте я все-таки не буду дописывать, а то слишком легко.
Да, я примерно так, может быть, сейчас и оставлю, не буду дописывать.
Ну, смотрите.
В чем идея? Я имитирую цикл.
То есть этот isPrime helper, он рекурсивный.
И он, грубо говоря, проверяет делимость стен на D.
Да, да, именно.
Программирование на шаблонах это функциональное программирование, если вы знаете, что это такое.
По сути, программирование на шаблонах это и есть функциональный язык внутри языка C++, да.
А...
Так вот.
Я что должен сделать?
Ну, я начну перебирать делители.
То есть я буду говорить.
Это равно isPrime helper от n запятая n, допустим, 2.2.value.
И этот isPrime helper, он будет...
Рекурсию делать такую, он будет спрашивать isPrime helper...
Ну, если n делится на D, то ответ сразу false.
А если нет, то рекурсивно вы isPrime helper от n запятая d-1 уходим.
Понимаете?
Ну и все.
Ну, там нужно будет обработать хвост, то есть там, когда D равно единице, допустим.
Ну, он делится всегда.
Ну, надо обработать, ну и надо сделать, чтобы не все мы числа проверяли, а только числа до корня.
Вот.
Функцию с qrt вызывать нельзя.
Как?
Ну, так можно, вот нельзя.
Зато можно в квадрат возвести.
Да, в квадрат можно возводить.
Можно все ребята в квадрат вызвести, как мы знаем.
В compile time?
Нет.
Нет.
Сейчас, у тебя же isPrime helper нет еще никакого value?
Ну, я не написал специально, чтобы вам сложнее было.
А же, может повторить, пожалуйста, еще раз?
Ну, еще раз.
Это рекурсивная штука.
Там же запись.
Все, вот можно же на записи пересмотреть потом.
И я уже, я уже рассказал решение по суде, что надо написать.
Надо просто сделать рекурсивный, ну, цикл надо делать такой, как бы, с помощью рекурсии имитировать цикл.
Если это делится над D, то ответ сразу false, а если нет, то переходим из isPrime helper от n и d-1.
Ого.
Ну, это завод от n.
А если надо завод корни из n, ну, надо, блин, просто делители от одного до корни из n перебирать там и все.
Ну, вот и все.
Таким образом, у нас будет isPrime в compile time проверять число на простоту.
А там можно тернарный?
Тернарный оператор можно.
А там разве не только тернарный можно оператором?
Значит, только тернарный.
Нет, ну как?
А как?
Мы же value что-то присваиваем.
Нет, ну можно разные операторы использовать, не знаю, оператор плюс можно использовать.
Конечно же, только тернарный оператор.
Ну, для if-ов.
Да ну вы не получится, да?
If-ов нету. У вас есть только шаблоны.
Все.
Так, это был пункт 6.5.
А мы можем там завести переменную, как-то что-то с ней сделать, а потом сказать, что наша статическая константа равна этой переменной?
Нет.
Что такое переменная?
Нет, вы только константы можете заводить.
Ой, какая боль.
Ну, в смысле, стандарт — это эмоциональная штука.
Почему не констант?
Что мешает?
Какие завещенцы в этом пишут?
Потому что нельзя в compile time заводить переменную, не лезть с константами времени компиляции.
Не просто константы, а константы времени компиляции только завершены.
Компилятор не будет.
Создавать в compile time переменную не конст.
Все.
Правила такие.
Как решил комитет постанализации, что еще могу сказать?
Ну в смысле, а как-то сделать не так?
Это же невозможно не так.
Ну, теоретически можно было бы заставить компилятор в compile time выполнять произвольный код просто с обычными переменными.
И в общем-то так оно и сделано уже в C++, даже 11.
Просто нужно правильные волшебные слова употребить.
Есть волшебное слово, которое говорит, пожалуйста, все-таки заведи не константы в compile time.
Но вам нельзя.
Вы будете пока только...
Мы еще не научим.
Да, вы будете страдать, да.
А во втором семестре мы научимся страдать более естественно.
Пункт 6.6 называется...
Вот так.
Dependent names.
Зависимые имена.
Это такой технический пункт, который вам...
В общем-то, в этом пункте я не расскажу никаких новых возможностей,
а лишь опишу вам некоторые проблемы, о которых вы, скорее всего, не задумывались до сих пор,
и некоторые технические костыли, как комитет по стратизации придумал их решить.
А зачем я их опишу?
Да потому что мы с ними уже скоро начнем сталкиваться вот прямо в ближайшее время,
и вы будете спрашивать, почему костыли им... почему такой костыль.
Ну вот сейчас узнаете.
Вот когда мы добавили в язык шаблоны, у нас появилась следующая интересная история.
Вот давайте я заведу такую структуру,
а в ней заведу шаблонную структуру.
Или даже не так.
Да не, все нормально, да.
Сейчас я вспомню этот пример, я его каждый раз забываю, каждый раз заново придумываю.
Значит, тут у меня есть такая шаблонная структура,
и в ней пусть у меня будет, скажем,
функция F,
которая...
Сейчас, дайте мне минутку подумать.
А, ну да.
Значит, и здесь у меня будет написано using...
Да, вот как будет сейчас.
Сейчас вам скажу.
Смотрите.
У меня есть шаблонная структура,
и в ней написано using...
О.
Класс.
Теперь я напишу специализацию.
От типа, ну я не знаю, от какого.
От какого хочу.
Там, скажем.
От какого хочу.
От какого хочу.
От какого хочу.
От какого хочу.
От какого хочу.
Да хоть int.
Ну давайте char, чтобы не казалось, что
это как-то связанные типы.
И здесь напишу static const int a равно нулю.
Как вам, нравится?
Вам вы уже предчувствуете, чем пахнет?
Ну смотрите, я завел шаблонную структуру,
и в ней вот
сделал
тип
a, который равен int внутренней.
А потом завел специализацию этой структурой,
и в этой специализации...
Ну слушайте, давайте даже я не так сделаю,
я вот лучше так сделаю, скажем.
Это неконкурсивная...
Ну, я не знаю, что это такое.
Вот так вот сделаю.
То есть смотрите, если у меня структура
от произвольного t, то в ней using a равно int.
А если структура от t является указательным,
то в ней static const int a равно нулю.
А теперь
я объявляю некоторую функцию f,
ну разумеется шаблонную,
которая
в своем коде делает следующее.
s с шаблонным параметром t
2.2.a
звездочка x
а x это int.
Ну x это...
Ну пока непонятно, что такое x.
Вот вы компилятор.
Что здесь написано?
Ну пока по сути ничего не описано,
потому что у нас не задано ни один контекст для f.
Нет, вы компилятор,
и вам нужно этот код скомпилировать.
Вот я говорю g++,
я говорю t++,
значит компилируй.
Как ты будешь это компилировать?
Вот здесь вот,
что ты скажешь на этой строчке?
Хорошо,
если я здесь напишу вот так,
ты что-нибудь скажешь мне?
Что ты скажешь?
Непонятно, что такое set?
Правильно? Нет.
У тебя будет семантическая ошибка,
у тебя будет объявленный идентификатор set.
Какая ошибка будет здесь?
Ты как компилятор,
как ты должен эту строчку понять?
А точная ошибка будет?
Это тоже вопрос.
Будет ли ошибка и какая?
Одну для первой версии, а вторую для специализации?
Ты компилируешь,
пока сим, вот тебе нужно
прочитать этот код,
я еще не вызвал f ни с каким t,
я ничего не подставил никуда,
я не попросил сгенерировать тебя f,
вот какая здесь,
это что, как это расправить?
Непонятно, куда пойдет
t,
но в зависимости от того,
от кого выберется первая перегрузка,
не повторяй.
Так, вы не понимаете моего вопроса.
Вот я написал
g++, вот этот код,
.cpp,
как компилятор должен прочитать эту строчку?
Можно поругаться на то,
что у нас a может не являться
x,
но
можно и не ругаться,
потому что
код может быть корректным,
в зависимости от того,
от какой мы тейпы были.
На самом деле, то, что вы сказали, так и будет сейчас.
Dependent names.
А, нет, вру,
он поругался не на это, сейчас,
сейчас, сейчас.
x,
вы забудете здесь x,
это стока с объявлением
a.
Нет, он поругался,
в общем-то, правильно он поругался,
это я просто неправильно понял, что он так.
Он мне сказал, что x не объявлен.
Он воспринял a как переменную,
а не как название типа.
А что дальше происходит?
Ничего, не происходит.
Ну как, что ли?
Значит, компилятору
надо как-то партии,
как-то читать, синтоксически же надо ему
как-то читать ваш код,
когда вы пишете шаблоны.
Даже если вы не
подставили ничего в шаблон,
компилятор должен как-то это прочитать.
Ему нужно понять,
это expression или declaration.
Вы понимаете, что здесь проблема в том,
это что вообще?
Это понимать как объявление указателя типа
такого и название его x
или как умножение величины
a на x.
Компилятор вообще не знает,
что такое a.
Оно может быть разным в зависимости от разных t,
и компилятор даже не будет пытаться выяснять,
при разных t действительно у него
разная семантика или нет.
Компилятору нужно в отрыве от всех t
как-то прочитать эту строчку,
как он это будет делать.
Так вот, правило следующее.
Если у компилятора есть два варианта,
как прочитать строчку,
как тип или value,
он будет читать как value.
Правило такое,
если у вас внутри шаблонного класса
объявлено нечто,
и вы
в шаблонном коде
обращаетесь к нему
через двойной двойточие,
то компилятор будет
по умолчанию считать,
что это не название типа,
а это величина некоторая,
статическая переменная.
Просто правило такое,
потому что компилятору нужно
прочитать этот код
еще до всех подстановок типов.
Ему нужно синтоксический парсинг
произвести до того,
как он начнет подставлять t
и что-то осмысленное делать.
Да.
Если бы у нас не было структуры,
где i, то это статик...
Неважно.
Компилятор читает это как value.
Компилятор читает это...
Ему нужно провести синтоксический анализ этого.
И во время синтоксического
анализа компилятор совершенно
не в состоянии пойти,
полезть выше по коду,
посмотреть, оправда ли во всех возможных
специализациях этой структуры,
а означает оно и то же,
и это везде типа незначение. Нет.
Компилятор во время синтоксического анализа
не будет такое делать. При синтоксическом анализе
компилятор парсит это как value,
а не как тип.
Да, даже если оно...
Потому что компилятор не будет
во время синтоксического анализа
верить, что получается.
Это задача совершенно другого уровня.
Компилятор должен делать...
Должен для начала сделать просто
синтоксический анализ.
А если мы напишем вместо a, например,
set?
Поэтому...
Ну, давайте я закомментирую
и покажу вам.
Ошибка всё равно та же.
Если вместо a set напишем,
как он поймёт, что это уже настоящий set?
Что... Какой set?
Вот такой?
Чего?
В st вообще нет
ничего с названием set.
Нет, подожди.
Set он как бы глобальный.
Какой может быть set внутри s-a-t?
Да, я имею ввиду, если он не внутри s-a-t,
а просто set, как он поймёт,
что это не труп, не элемент?
Ты в отрыве от s-a-t
вот ты спрашиваешь.
То есть если я пишу std set,
и что-то там? Или что?
Нет, я имею ввиду, в какой момент он перестаёт
считать, что это value.
Что мне надо написать? Какой у тебя вопрос?
Я не понимаю пока.
Какой пример ты хочешь разобрать?
Вот вы говорите, что a может быть
везде типом, и всё равно он это
проинтервизирует как value.
Он... a это некоторая
переменная внутри шаблонного класса.
Где t ещё не подставленный
тип?
Вот если я здесь напишу std vector,
помните, у нас в самом начале,
когда мы с вами шаблоны делали,
у нас была следующая проблема.
Ну вот что-то такое я написал.
И была именно эта проблема.
Когда t не подставлена,
а я внутрь шаблонного класса прохожу
параметризуя его параметром t,
компилятор уже не может понять,
что итератор это вообще говоря тип или value.
И поэтому, если я так пишу,
компилятор считает, что итератор
это некоторая переменная,
а не тип.
Если я нахожусь внутри шаблонного...
если я нахожусь в шаблонном коде,
параметризованном t, и внутри этого шаблонного кода
у класса, параметризованного t,
вызываю какое-то внутреннее имя,
через двойное двоеточие,
компилятор теряется, ему надо понять,
это тип или value?
И он решает, что это value, если я явно
не скажу обратно. Понятно?
А нужно писать слово type name.
Вот здесь вот нужно
писать type name.
Я скажу, пожалуйста,
а без этого type name, даже если вот...
Еще раз спроси,
даже если там не было специализации,
в которой это value, да, третий раз
повторяю, да, все равно будет CE,
я это уже показал. У меня просто компелит
если закомменитить.
Какая у тебя версия?
Я себе 17-ю выставил.
Чего?
Compilator какая версия,
а не языка?
It's a language++.
Версия, это хороший вопрос.
Забавно, что можно написать
в этой же функции одно state name
корректно, одну без...
Вот, короче,
вот, ну давайте
я еще раз продемонстрирую, вот все равно
ошибка.
Если я сделаю C lang++,
все равно ошибка.
Та же самая причем.
Необъявленный идентификатор.
В том же самом,
когда я пишу STD VectorT итератор,
это абсолютно один в один та же ситуация.
Один в один.
VectorT итератор, что такое итератор,
пока не известно, что такое T, непонятно,
это тип или значение?
Ну, все, для тех, кто знает,
для тех было понятно.
Для тех, кто не знает, потом столкнетесь.
Вот, но это еще...
Ладно, это еще цветочки.
Есть
пример более
интересный.
Да, собственно, почему этот параграм называется
dependent names? Вот такие имена...
Вот это вот называется dependent name.
Вот это вот A называется зависимым
именем, dependent name.
Когда мы находимся в шаблонном коде
и внутрь шаблонного класса проходим.
Вот, но это еще...
Ладно, это еще цветочки.
А представьте, что у меня есть следующая
штука.
У меня еще тут есть
template type int n
using R,
значит, и тут написано using R,
но я не знаю, что.
Ну,
std array
от
int zeta n.
Вот.
И теперь я говорю.
Вот так.
Теперь смотрите, какая ситуация.
Это может быть
шаблоном?
То есть, если
я пришел в эту версию,
то это я сейчас сделал не что иное,
как объявил массив int в размере 5
и назвал его x.
Правильно?
А если это
другая версия,
то я сейчас
сделал следующее.
Взял int,
сравнил его с пятеркой,
получился bool, неявно конвертировал bool в int,
сравнил его с x.
Вопрос.
Как компилятор должен допарсить?
Конечно же, вторым способом.
Очевидно.
Очевидно, я имел в виду именно это.
Вот.
Будет опять то же самое.
Компилятор решает, что это
сейчас int,
что это некоторое value,
которое я пытаюсь сравнить с пятеркой,
а потом результат сравнить с x.
Но у него Anticlade Artifier x.
Давайте.
Вот если я сейчас добавлю
глобальный x, то ce исчезнет.
Вот int, допустим.
Ну, чтобы не отказать себя.
Ну, все будет хорошо.
Давайте.
А, подожди, f от int.
В смысле, чтобы я попал в первую версию?
Да.
Будет ce.
А, нет.
Сейчас я соображу, что будет.
Подождите, я хочу сначала
разобрать то, к чему мы пришли.
Я сделал глобальный x.
И как компилятор это прочитал?
Почему он не выдал мне никакой ошибки?
Что я с чем пытаюсь сравнить?
Что за бред я делаю?
Какой ноль?
Он не знает, что такое a.
А есть внутри...
А есть внутри темплейта.
И что?
Он не заходит внутрь темплейта.
В смысле, он синтактически это распарсил?
Все нашлось?
Да.
Все правильно.
Нужно понимать, что компиляция
шаблонного кода, она
состоит из двух стадий.
И синтаксический анализ не требует
подстановки t никаких.
Вот эта ошибка о том,
что x не объявлен в идентификаторе,
это ошибка
на уровне синтаксического анализа произошедшего.
Потому что он распарсил эту штуку
как выражение,
и в нем встретил x,
который непонятно откуда взят.
Но, если я
сделаю, что x это для него
понятное имя,
то он успешно пройдет эту стадию.
T он никакой не подставляет.
Он просто понял, что это корректный expression.
Он смог распарсить это как корректный expression.
Но поскольку подстановки типов еще не случилось,
он не выдал ошибку компиляции.
Ошибка компиляции о том,
что не поддерживается такая операция, имеет смысл в том,
когда подставили T и поняли, что реально получилось.
Вот.
Теперь давайте вызовем f
шаблонным параметром int.
И посмотрим, что будет.
Вот сейчас я заставил его
проинстанцировать.
Значит...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
то есть по идее попал сюда то есть я заставил его я заставил его теперь
считать что а это вот эта штука и он не смог все равно а давайте селенг а это
селенг и есть давайте г плюс плюс вот ну здесь g plus plus получше справился
обычно селенг лучше справляется с выдачей нормальных ошибок но на этот раз
селенг g plus plus лучше справился дело в том что синтоксический анализ уже
проведен он считает что эта штука это обозначать value а когда я инстанцировал
и он вдруг внезапно понял что это было не value он такой ой но от этого не
исправит синтоксический анализ свой то есть он когда анализировал эту функцию
до подстановки типов он понял что это expression а сейчас я подставил ему такое
t что это оказался не expression а он скомпилировал уже но он уже построил
там все синтоксическое дерево все там под настроил конструкции свои и он
решил что там был expression в этом месте вот поэтому несмотря на то что я даже
заставил его теперь подставить сюда такой тип что породил он ему не value он
все равно сломался потому что оказалось это не value а он думал что это value вот
но если я вызовусь от звездочки то все будет нормально вот так вот как мне
победить это а ты звездочки да он он все корректно скомпилирует потому что он
понял что 0 меньше 5 больше нуля просто у него получилось и все вот ну вот давайте
напишу здесь type name
вот теперь он справляется да потому что он понимает что это тин так и
силен кажется справится а нет не справляется почему-то вот же плюс плюс
и силенка идут себя по-разному
а почему это вот на самом деле тут есть тонкость потому что вот ну тут как-то
вот разные компиляторы немного по-разному это читают но идея в
следующем что слово type name может быть недостаточно если я написал даже type
name он все равно ну то есть когда я написал type name он партий это как тип а
надо партий как шаблон то есть теперь он считает что вот это название некоторого
типа но на самом деле это не название типа это название шаблона и следующий
знак меньше ему нужно спастить как головую скобочку открывающую вот несмотря на то
что написал type name он все равно не понимает что-то на самом деле template они
просто type name он партий до сюда дальше голову скобочку партий все еще как знак
меньше и це я вот поэтому чтобы совсем победить ошибку окончательно нужно
здесь еще написать слово template значит слово template используется не только для
того чтобы объявлять шаблоны и шаблонные параметры
оно используется еще в конструкциях неоднозначности когда в выражениях зависимых от t у вас
некоторая штука может читаться как well я может как шаблон вот сейчас должно все
скомпилироваться любым компилятором вот а если я вообще не буду этого делать и не
объявлю x давайте посмотрим что вот сейчас будет вот я сейчас допустим уберу слово template здесь
поймет ли он возможно даже сейчас поймет до g plus plus справляется селенк все равно не
справляется вот ну возможно кстати селенк и ну со стд си плюс плюс 20 может быть у меня
просто да он даже предложил просто да да нет селенк сказал что здесь не хватает слова template
а g plus plus просто скомпилировал и так понял без слова template вот по моему по стандарту нужно
ставить template кто ну же плюс плюс компилирует вот кто из них прав я не помню значит кто из
них прав я не помню если честно если он предлагает короче я не помню кто из них прав но вот лучше
писать template тогда надежно будут все компилировать понятен пример и его решение да
чего type name что что это означает вот о том что это означает я последние 20 минут и
рассказывал зачем здесь слово type name вот именно об этом этот пункт зачем здесь нужно type name
чтобы он парсил это как тип а не как value ну я привел пример ну слушай ну блин ну что мне
все занято но я не знаю но я привел как раз пример что была неоднозначность это можно
прочитать как expression а можно как declaration по умолчанию он парсит как expression как expression
потому что он должен какое-то решение принять по умолчанию вот так он принимает по умолчанию
решение чтобы заставить его принять по умолчанию считать что-то тип он начинал написать type name
перед этим нужно для того чтобы компилятор считал это типом а не значением при парсинге при
синтоксическом анализе своем да да сами создали проблемы сами их решили нет почему так
вы постоянно будете так делать когда у вас будет и тараторы в контейнерах вы будете с этой ситуации
ну ситуации template вы будете ну вы тоже не столкнетесь много раз но когда вы будете
сталкиваться с вектор т и в нем что-то нужно из него достать у вас будет постоянно такая
проблема ну короче проблема это частая и приходится с ней возиться неприятно вот
последнее что я скажу в этом пункте да что
в смысле два варианта void f с одинаковый шаблонным набором параметров с одинаковой
сигнатурой где вот здесь очевидно нельзя перегрузить функцию с одинаковыми сигнатурами
типа вот это redefinition of f вот и все а тайт-нэм с рейтингом ce потому что после угловой
скобочки ожидается нет ну можно вот так сделать ну короче все понятно чего
давайте подойдешь после пары потому что я боюсь что мы задержим всех и опять не успеем сейчас
что хитро я не понял что ты сказал ну да ладно так еще одна вещь про которую надо сказать в
этом пункте представьте что у меня следующая ситуация так смотрите вот
давайте рассмотрим следующий пример
ну например вот так так господа посмотрите пожалуйста следующий пример вот такой пример
казалось бы что может пойти не так есть шаблонный класс base от него унаследовался derived заметьте
кстати что здесь я вынужден повторять type name т шаблонный префикс потому что я использую
его внаследовании и здесь я в методе derived инкриментирую x давайте попробуем
подскомпилировать внезапно оказывается что x не объявленный идентификатор
что посмотрите на этот код что могло бы пойти не так казалось бы плюс плюс x ce x не объявленный
идентификатор нет здесь плюс плюс x не объявленный идентификатор меня только в одном месте кода плюс плюс x
написано и же плюс плюс солидарен и минус остодесии плюс плюс 20 не помогает что же делать у кого есть
идеи почему так это опять dependent name пункт называется dependent name мне очень нравится этот человек вот
слушай вот у нас в прошлом году был тоже такой человек который все время очень громко кричал когда
подобные вещи рассказываю озмущался вот ты пожалуйста не пропускай пары потому что мне нужно чтобы на
парах был хоть один человек реакцию из зала выдаёт вот и хорошо да во втором особенно не
пропускай чтобы как бы я ощущал вот фидбэк от того что я рассказываю да да да вот примерно так
дело в том что поля бейс вообще говоря зависит от т и компилятор когда мы находимся в наследнике
смотря какое т их сможет либо быть либо не быть ну как я могу сказать темплей я могу специализировать
структуру без для им ты в ней не написать никакого поле x вы чего да я такой вот и тут не будет
никакого x и вот и вопрос то есть получается что когда я из наследника обращаюсь к полю x его
наличие зависит от того какой был т оно может быть а может его и не быть вот поэтому поэтому но
тут я уже не знаю тут мои полномочия все как говорится я просто скажу как это работает а вот
объяснить глубинные причины почему комитет так решил я значит по умолчанию компилятор если вы
наследуетеся шаблонного родителя компилятор не лезет не пытается лезть в поля шаблонного
родителя он считает что ну когда он парсит ваш код наследника он смотрит только на ваши поля и
на ваших обычных родителей на поля шаблонных родителей не смотрит потому что понимать что они
могут быть и могут не быть и он просто не берется выяснять а во всех ли возможных
подстановках ты есть это поле а если его нет где-то то что мне делать вот он просто считает что
их нет а если вы хотите к ним обратиться вам нужно явно квалифицировать откуда вы берете из насли из
родителей то есть вам надо писать base от t2.2.x только не так конечно да плюс плюс base от t2.2.x вот так
ну если будет перегрузка с entom конечно же будет ce потому что он подставил ent и увидел что нет
поля x он не подставляет t когда компилирует он не смотрит вы понимаете он компилирует шаблонный
код и он не идет в родителей просто видя что они шаблонные он не пытается посмотреть какие у них
есть поля он не пытается он не пытается на первой стадии компиляции шаблонного код
среди двух стадий первая стадия это просто проверка синтаксиса и базовых но на второй
стадии когда т конкретизируется конечно же когда т конкретизируется компилятор подставляет
конкретный т и смотрит что получилось и тут выдает уже ошибки следующего уровня но на первой
стадии он не пытается подставлять никакие т потому что в зависимости от поставки разных
тем может получиться разное поэтому он просто говорит я не знаю что такое x я не ходил туда и не
смотрел что там скажи мне что x оттуда если ты хочешь его явно взять оттуда вот такая проблема
при взятии полей из шаблонного родителя если вы наследуетесь от шаблонного родителя то когда
обращайтесь к полям нужно явно квалифицировать откуда поля он же и до этого не подставлял
inequality при этом до этого не отставлял вот сейчас он не подставляет �пки это когда у нас
когда что мы не указывали откуда именно нужно брать x тоже не подставляй ну теперь он верит
нам там есть x понимает neck議 ᶗ tatas это он не верил до этого он просто не знал что
что такое икс откуда его брать он не ходил в родители он не смотрел что у них он он не занимается вот этим вот
на стадии статистическую анализа схожу ка и посмотрю на тех родителей подставлю ка от и увижу какие там
возможные имена переменах получиться он занимается этим если не темплей то скажет если не темплей то да но
если темплей он отказывается это делать потому что потому что это другая стадия компиляции если там
нет шаблонов то это он проворачивает ну короче не знаю друг другая другой другой модель компилятор
за это ответственно изначально шаблонный кто или кто шаблонный стадия компиляции сначала
паре сначала проверяется синтакса с точки зрения корректности просто вот до подстановки шаблонный
проверять делаются базовые проверки синтакса после уже подставляются типы что я правильно
он верит что там есть поле x просто мы явно об этом сказали да да да еще еще можно писать
вис стрелочка x да еще вот так можно писать так тоже работает он тоже понимает что это из
родителя значит но если я так пишу то он понимает что это поле значит да он просто
справляется с парсингом после этого а до этого не справляется
да да да все а теперь он же всегда мог в принципе базовый не специфицированный
я отказываюсь комментировать я рассказываю как есть вот все
все мы идем дальше дорогие господа у нас сейчас с вами такой достаточно важный момент вот то что
я сейчас расскажу оно вам пригодится в жизни да вот но на самом деле предыдущий пункт был подготовкой
к этому пункту сейчас мы с вами впервые столкнемся с таким замечательным и совершенно великолепным
на мой взгляд явлением стандарта библиотеки это прям вот одна из моих любимых частей языка
c++ один из любимых закололков я надеюсь вы тоже получите удовольствие называется type traits это
такие метафункции ну по сути мы сейчас будем простенькой метапрограммирование на типах делать
такие метафункции до что значит слово мета значит что такое метапрограммирование мета это запрещенная
значит метапрограммирование это такой подход к программированию когда я уже говорил сегодня
утром у нас теперь функции это структуры а в роли объектов выступают типы сейчас вы увидите вот
смотрите давайте напишем простую функцию метафункцию которая проверяет является ли данный тип
указательным или ссылкой давайте я напишу простую метафункцию которая проверяет является ли тип
указательным traits это значит характеристики а я пишу template typeNameT struct isPointer и вот теперь
помните у нас у нас в код стайле было написано типа нужно писать с маленькой буквы с большой
буквы все это правило отменяется если мы говорим о метафункциях если на самом деле тип метафункция то
есть его роль ответит на какой-то вопрос про другой тип значит можно с маленькой ну да static
const bool value равно false пишу я а теперь я делаю следующее
заметьте что из pointer подсвечивается зеленым потому что есть такая cd-шная функция а вот
здесь я пишу static const bool value равно true таким образом теперь если у меня есть некоторая шаблонная
функция я могу использовать это следующим образом если isPointer по t value то сделать что-то одно а иначе
что-то другое нету никого сфинает это пока не пугайте людей раньше не слушайте его он сумасшедший
он слишком да так он слишком долго ботл плюсы поэтому да понятно что здесь написано понятно как
этим пользоваться вот но пользоваться этим неудобно поэтому я еще напишу вот такой хелпер
const bool isPointer в равно isPointer от t2.2.value но что бы мне не приходилось писать вот это вот
я вместо того чтобы писать isPointer t value буду просто писать isPointer v от t
да молодцы вы вы вы узнали вы распознали до из assignable из assignable это метафункция
которая проверяет можно ли присвоить типу объекту типа a объект типа b но ее мы с вами сейчас не
реализуем это сложно пока мы реализуем только простые вот пожалуйста вам проверка на то
является ли тип указателя вот на самом деле здесь я еще вот что скажу я все-таки здесь
используя вот это запрещенное слово которое вообще-то запрещено которое вам нельзя будет
использовать в задаче про матрицы но я вам про него все-таки скажу но потому что просто грех не
сказать в такой ситуации про него просто иначе ну я не знаю ну просто да ну это иначе выглядит
ужасно значит есть такое слово constexpr которое можно после ифа писать вот есть такая конструкция
пока не думайте о том что значит слово constexpr само по себе у него особенное значение если оно
пишется после ифа и в constexpr это значит это сделает compile time проверку в compile time проверить
истинно ли это и если истинно то ну то есть просто не компилирую вторую часть если вот это
неверно вот например если это pointer то тогда я не знаю что-нибудь напиши там tx равно null ptr
вот а иначе ничего не делай вот и что произойдет если допустим я сейчас вызову эту f от какого
нибудь типа который не является pointer то есть я написал f от ну я не знаю 100d string вот если
здесь не было написано constexpr была бы ошибка компиляции потому что потому что ну эта строчка
же ну потому что здесь подставляется t и я пытаюсь сказать string x равно null ptr no conversion from std null ptr t to std string
но constexpr означает не компилирует этот кусок кода если условие не выполнено просто игнори его на
этапе компиляции просто игнорирует эту часть это очень полезная штука поэтому про нее лучше
рассказать можно раньше чтобы у вас не было в коде таких некрасивых конструкций когда вы там
ну короче вот такие вещи как проверка является какой-то тип каким-то свойством обладает она в
compile time делается и соответственно проверить что этот тип не является указателем можно написать
constexpr и это просто не приведет к тому что код не сгенерируется под это если тип был не таким
но если это условие некомпайл тайм проверяемая то есть здесь написано некомпайл тайм константа то
будет ce со словами не могу посчитать это на этапе компиляции понятно чего я подумаю я подумаю
возможно вы фах можно будет чего специализация чего-чего тихо что где вторая из вот это это
специализация частичная это же структура не функция у структур не бывает перегрузки у них
бывает только специализация специализация в эту функции это мета функция но с точки зрения языка
это класс класса нельзя перегружать можно только специализировать так я не буду отвечать на этот
вопрос потому что ты заставляешь меня рассказать вам что такое констэкспорт целиком это я буду
рассказывать весной если хочешь после пары подойдет но вам нельзя им будет пользоваться так
вот если я сейчас это так скомпилирую basic type traits то нет я не получил ce почему-то а потому
что ce потому что стрейн конструируется от чара от костчар звезды а налptr конвертируется в
костчар звезду наверное поэтому ну я не знаю можно там от чего не короче не важно ну блин
нет наверное все-таки надо показать ну давайте какой-нибудь тип который от налptr ну точно
нельзя дабл наверное нельзя давайте проверим ну все вот нельзя из налptr сделать дабл но если
я напишу здесь констэкспорт то можно будет все так понятен ли пример с из pointer из pointer
вот на самом деле из pointer это штука из стд то есть это это такая стандартная метафункция стд из
pointer кроме стд из pointer есть еще много чего в стандартной библиотеке а найти бы их только
кто первый найдет слово traits тот молодец
нет конечно
вот смотрите смотрите пожалуйста вот вот у меня очень много файли type trait стандартных
метафункций из integral из floating point из array из enum из union из class из function
из pointer из lvl reference из lvl из member object pointer то есть вот например как проверить является ли тип
массивом да очень просто вот просто написали специализацию но тут правда нужно объяснить что
такое стд false type стд true type ну стд false type это просто тип в котором написано static
равно false и все чтобы короче писать все метафункции вот смотрите пожалуйста вот
пожалуйста метафункция из array если надо проверить является ли тип массива но тут
является ли тип константным вот пожалуйста метафункция проверяющая является ли тип
константным очень просто упражнение на тройку реализовать такую метафункцию на зачете
ну да ну да да да да да вот можно слушайте ну давайте потише я так кричу громко а вы
еще болтаете вслух вы очень громко очень тяжело вас перекрикивать вот ну тут есть
много разных значит метафункций и большинство из них мы сейчас вами не в сцене реализовать
потому что они требуют довольно жесткого метапрограммирования который мы позанимаемся
весной но пока вот из pointer из reference из array вот еще одна очень полезная функция которая вам
наверняка понравится это функция из same метафункция конечно значит смотрите метафункция из same
из same type tmt type name u проверяет являются ли два типа одинаковыми значит вот я беру
здесь пишу false а теперь специализирую для одного типа и здесь пишу true
это есть стандарт на библиотеке я же только что показывала стд я показывал
вот соответственно я например могу если меня ну если и и еще для всех для них есть вот такие
вот алиасы и сэм в это шаблонные а темплейт значит type name t
стракт ой какой стракт const bool value равно ой что пишу из сэм в равно из сэм от t тут нужно
два типа да type name u и сэм t u 2.2. value чтобы вам не приходилось писать вот эти вот явные обращения
к структурам это шаблонная переменная вот ну для справки все эти штуки вот все эти
тайп трейд и они начиная с и плюс плюс 11 а вот эта штука только начиная с и плюс плюс 17 есть
если вдруг что если вы где-то будете где нет с и плюс плюс 17 вот этих алиасов там еще не
добавили конечно шаблонные переменные появились и плюс плюс 14 но история такая с 11 появились
вот эти тайп трейд и все плюс 14 добавили шаблонные переменные а все плюс 17 в библиотеку
добавили реализации шаблонных переменных для этих штук и в конст экспорт тоже только начиная с
и плюс плюс 17 да поэтому если у вас нет и плюс плюс 17 то вам придется имитировать и в конст экспорт
довольно хитрым способом значит не буду рассказывать каким это мы все по втором семестре обсудим
да уже много чего 23 плюсы уже утверждены фактически уже известно что мне
нет пока нет как будто вас это спасет стринг тоже в стандартной библиотеке есть знаете ли но
вам все равно и вы реализовываете это же говорили что когда-то планировали бигендеджер конечно
засовывать в стандап то по моему где-то в 21 году было им фарш то нет отказались от этой идеи
еще одна еще одна очень еще быстро две метафункции а потом я должен вам успеть рассказать про
вариативные шаблоны смотрите вот эти функции которые сейчас которые сейчас показывал они
берут типы из них возвращают значение а можно рассмотреть такую штуку а стракт
римов референс например ну или римов поинтер что это такое это такая структура в которой
написано юзинг тайп равно ты очень полезно вот но все конечно становится интересней когда я
добавлю специализацию он ли как это работает то есть вот у меня я вот пишу код какой-то
шаблонный и у меня есть некоторые тип те и мне нужно получить как бы снять с него амперсант
если он на нем был мне нужно получить тип который был которым был те если с него амперсант снять
ну я использую метафункцию римов референс я пишу стд римов референс от ты двоеточие
двоеточие тайп вот давайте я так и попробую сделать вот допустим я здесь но я эту функцию
сейчас вызову от им там персант здесь напишу римов референс от ты двоеточие двоеточие тайп икс и
вызовусь я от ссылки на дабл в каком смысле не идти вот вот именно поэтому я и думаете для
чего это сейчас он показал вот ты это понял а все это поняли именно вот вы спрашивали где мы с
этим столкнемся а вот именно для этого и нужен был предыдущий рассказ длинный про то что за еще
раз вот у меня смета функция которая снимает амперсант стипа римов референс называется ну
такая же есть функция римов конст римов поинтер есть функция это поинтер и вот я хочу вот у меня
шаблонный код и я хочу взять тип т который меня передан шаблонным параметром и снять с него
амперсант и получить получить получить некоторые тип ну и вот я вызвал f от дабл амперсант и хочу
здесь в этой функции ну то есть это должно превратиться во что я просто объявляю дабл то есть
вот так вот это должно теперь выглядеть да но сейчас будет ce и вы же понимаете почему
потому что потому что он распарсит type как значение они как тип поэтому здесь надо писать
type name и теперь да теперь все будет хорошо а в чем прикол вот такой прикол нет никого
приклада римов референс ох как ты заблуждаешься но я пока я пока не буду спойлер зачем это
что а ссылка может быть только одна да римов поинтер это будет снятие одного одной
звездочки да ты можешь написать римов поинтер и кстати да это звучит как отличная задача для
зачета написать функцию метафункции ему вау поинтер она вызывает римов поинтер рекурсивно до тех
пор пока результат вызова не станет равен тому что было до вызова да можно написать римов по
олл поинтерс вот да есть еще такая функция метафункция римов экстент сейчас покажу
ну вот есть римов конст римов волатайл римов поинтер и от поинтер римов экстент вот
например есть функция что она делает она снимает одни квадратные скобочки но у вас может быть
многомерный массив вы снимете с него одно измерение ну вот но у вас был тип т квадратной
скобочки квадратной скобочки вы сняли вторые квадратные скобочки стал просто т квадратной
скобочки да просто ну чё вы задаёте какие-то вопросы странно а зачем нужно я не знаю
теория марда шакурадо зачем да ну что нет неоднозначно type это непонятно что тип или значение
поэтому он парщит его по умолчанию как значение нигде не используется для компилятора ну
господи в четвертый раз повторяю неважно если там это специалист или нет он парщится как значение
всегда в четвертый в пятый раз повторяю да всегда парщится как значение если написать
это об этом был разговор в течение получаса до этого да всегда парщится как значение поэтому
нужно писать type name вот и поэтому крайне полезно использовать алиас смотрите юзинг
сейчас я делаю шаблонный юзинг шаблонный алиас помните что шаблонными могут быть и юзинги
еще так вот я пишу юзинг рему в референс т равно type name рему в референс а т двоеточие
двоеточие type ну и все вот и теперь когда мне нужно это использовать в нормальном коде я уже
не пишу type name и не пишу двоеточие двоеточие type а просто пишу рему референс т вот эти штуки
появились начиная си плюс плюс 14 но это для справки вот начиная си плюс плюс 20 сейчас я
вас совсем угроху конечно вот здесь type name все-таки можно не писать но просто когда я делаю
юзинг тип равно другой тип но очевидно что type name не надо и так понятно уже тут точно
вот начиная си плюс плюс 20 разрешили не писать type name в этом месте но если я попрошу меньше
версии языка то будет цена ну не все но стремимся к этому вот ну короче да потому что я убрал type
name у него что-то сломался нет это же не шаблон это просто тип это не не шаблон просто тип так
еще одна очень полезная метафункция и после этого я вам должен все-таки успеть рассказать про
ой господи прошу вариативные шаблоны так еще одна божественная совершенно метафункция без которой
я не могу вас оставить в этом семестре это замечательная метафункция стд conditional
тернарный оператор тернарный мета оператор смотрите template type name ну не так template
bool b type name t type name f struct conditional
вот using type равно ну f дальше template type name t type name f struct conditional
true за 5 т за 5 f using type равно t понятно как это работает ну и разумеется template
bool b type name t type name f извиняюсь using conditional t равно ну если мы все плюс плюс 20 то уже
type name можно не писать conditional от b запятая t запятая f двоеточие две точки type
соответственно я могу например сказать вот мне передали t я могу спросить conditional t из
const v от t запятая не знаю int запятая double x равно нулю вот пожалуйста если
тип т был константным то я интервью а если не константно то дабл объявлю тернарный мета
оператор ну я бы не рассказывал это если бы вам это не пригодилось ближайший ну это вам
пригодится уже в задаче который будет следующий после матрицы и видимо она будет первые же
в самом начале второго семестра это вам пригодится вот если вам кажется что я
сейчас рассказываю бесполезную хрень и вообще кто этим пользуется вы очень заблуждаетесь этим
как раз пользуется очень активно в промышленном коде вот да все польза куда не выйдет на улицу
спроси вот ту женщина вся пользуется каждый бесполезную хрень я буду рассказывать в конце
второго семестра а сегодня а сейчас им рассказываю очень полезную хрень я можем
страйк conditional от false t f сделать можем ну и присловить using type равно f ну здесь надо ну здесь
тогда надо будет равно t написать а здесь равно f да можем ну на ну типа в общей версии я что-то
должен написать а в частности написать что-то другое еще про метру создать пол ну можем можем
а зачем так же короче да видимо двадцатый силенг все-таки не любит так чтобы убирали так
ну силенг да силенг вообще с двадцатыми плюсами интересная история силенг медленнее всех
поддерживать научился по моему то есть быстрее всех как ни парадоксально научился поддерживать их
мсв цепом на втором месте г плюс плюс а на третьем месте сил вот силенг дольше всех короче то есть
силенга еще много фичей не реализована в том числе ну как мы могли убедиться даже библиотеки силенга
еще некоторые штуки не реализованы сейчас прости а если мы мы вот там напишем и для у нас написан
для true и мы напишем для холста получается общая версия у нас вообще никогда не получается да
может нет не могу мне надо еще один пункт вам рассказать потому что мы очень ну хорошо нас
смотри а что было в конце нет ну запись же идет зачем это уже я не знаю давайте я вам расскажу
последнюю очень важную вещь которая вам вероятно пригодится в ближайшее время и отпущу вас с миром
вареник темплэйс
ну геомия да смотрите ну у нас были функции с аргументами по умолчанию у нас были функции у которых
что там еще у значит аргументов не указаны имена но в общем и у нас были функции с произвольным
количеством аргументов вот после этого у нас появились шаблоны шаблоны значит у нас появились
тоже у которых есть аргументы по умолчанию у которых можно там не указывать имена значит
но вот c плюс плюс 11 это все начало вот этот пункт он c плюс плюс 11
появились люди подумали а что давайте сделаем и шаблоны с переменным количеством аргументов
значит шаблоны с переменным количеством аргументов я могу написать темплэйт с
многоточие ну тс скажем много типов стракт с ну и тут что-то написать вот ну пока не очень
понятно для чем для чего это надо структура с переменом количеством шаблонов аргументов это
такая не очень легкая для понимания вещей давайте я покажу на примере функции вот представьте что
у меня есть функция классический пример это функция принт вот знаете можно придумать такую
функцию принт допустим вот также чипл да устроен где-то конечно да ну в смысле также да он с
переменным количеством шаблонных аргументов да да да а тс это что это тип какой то тс это вот
трудно сказать что такое тс это пакет это некоторая новая сущность значит тс это пакет типов
ну я затрудняюсь дать вам какую-то интуицию того что такое пакет типов я предпочитаю
воспринимать пакет типов исключительно по как знаете утиная типизация ну типа вот по списку того
что с ним можно делать вот пакет типов это некоторая необычная сущность которая существует
только на этапе компиляции не является сама по себе никаким типом вот ну что с ней можно
делать ее можно распаковывать как ее можно распаковывать можно распаковывать когда вы
перечисляете аргументы вот например так я распаковал пакет ну вот такая конструкция означает что
теперь у меня аркс это пакет аргумент можно распаковывать пакет типов получать им самым пакет
аргументов да ну тут все корректно я просто объявил шаблонную функцию с первым количеством
аргументов ничего не передал ни от чего не вызвать я распаковал пакет но то есть я объявил
функцию с переменным количеством шаблонных аргументов которая принимает значит вот как с
этим работать это прекрасный вопрос а ну вот в таком виде довольно трудно давайте я напишу
функцию которая дело следующий она выводит все аргументы в консоль все аут через по одному вот
ну это классический пример значит как не не не не не аркс это не контейнер чтобы по нему так
ходить у него же нет атераторов мы проверим ли мы проверили а вот есть идеи как вообще вот
воспользоваться чем-то из этого пакета что нет нет аркс это пакет аргументов аркс сам по себе
аркс сам по себе это никакой не это не переменная никакого типа это как бы такое имя за которым
скрывается много переменных пакет можно пакет переменных можно распаковывать в свою очередь
тоже получать таким образом несколько переменных через запятую я могу например сказать вот здесь
ф от аркс многоточие и это будет означать как если написал f от а 1 запитая 2 запитая ну и короче вот
я могу применить многоточие к пакету аргументов это будет означать что я вот все эти аргументы
через запятую как будто перечислять нет ты не может это будет означать while и через запятую
аргументы но это не оператор запитая это это перечисление можно напрямую нельзя чего можно
присвоить массив нет можно получить количество впрочем можно типа убрать первый аргумент допустим и
так пока не а вот это а вот это ты молодец так и надо да значит чтобы чтобы нам из этого пакета
хоть что-то достать применяется следующий трюк мы делаем первый аргумент нормальным а после
этого делаем хвост из переменного количества аргументов и мы принимаем в функцию первым
аргументом голову а дальше хвост с переменным количеством аргументов соответственно да если
теперь я вызову принтер пустого количества аргументов то это будет сие потому что нет
соответствующей версии соответственно теперь я делаю вот так а после этого вызываю принт от
хвоста распакованного да то есть я могу написать принт один запятая 2 запятая обц запятая 3.0 вот и
это почти скомпилируется проблема только в том что не будет версии для принта без аргументов мы
но мы ее не специализируем а перегрузим потому что специализация функции шаблонных это другое
она нужна перегрузка да мы даже не будем она даже шаблонной не должна быть мы просто вот так
сделаем все все нет не все а правильно потому что я объявил ее позже после того как она мне
понадобится вот все работает что в какой момент вообще выводит что-то в ран тайме он выводит
акапеллирует компайлпайны пакеты представляет он выводит голову потом ты ему передаешь
снова все пакеты и у него меняется голова и меняется строго говоря он ничего не выводит он
только код генерирует а когда ты им пустой я сейчас сгенерировал 5 версий функций принт
вот этот код приводит в генерации пяти версий функций принт от нуля от 4 аргументов потом от
трех от двух от одного ну и вот в итоге у меня от нуля от нуля сам написал от нуля сам написал
да вот ну и каждый из этих функций делается ся вот первого аргумента своего и вызывает
предыдущую функцию но в ран тайме они уже вызываются одна за другой все ну разумеется сюда
можно принимать например по константной ссылке или просто по ссылке вот здесь вот я тоже могу
навешивать украшать или на тип вот так мы будем писать но применять да это значит ко всем типам
применить вот такую штуку да то есть у меня будут все аргументы по константной ссылке
таким образом ну все давайте на сегодня закончим
