в прошлых сериях мы сделали аналог std function да шар на вот сюда и сюда шар оба шара
стд function сделали мы его более оптимально чем на виртуальных вызовах да с помощью таких
типа виртуальных таблиц которые мы записывали указатели на функции, функции генерили через
шаблон где мы это делали ну вот тут например шаблонная лямбда в зависимости от того что
прислали ну шаблонная не лямбда сам конструктор на зависимости от того что туда положили лямбда
в итоге становится разной и собственно с помощью этого мы в рантайме диспатчили наши вызовы
к разным функциям, к разным конструкторам, к разным деструкторам и т.д. и т.п. вот и в конце
позвучала мысль что дай-ка мы объединим все вот эти вот call, deconstructor, constructor, еще copy
constructor да объединим их все в одну таблицу для пущего удобства сейчас мы эту идею будем
развивать ну и кажется я сказал что в итоге получается что-то очень сильно похоже на сами
виртуальные функции, виртуальные вызовы фактически на шаблонах переизобрели ООП с нуля сейчас мы
будем продолжать переизобретать ООП с нуля на шаблонах да но перед этим небольшое замечание
комментарии исправления про которое забыл сказать да вот декл-тайп от авто я обещал что расскажу что это
и так его написал и так и не рассказал ну если вдруг кто не знает на всякий случай расскажу
с какого-то там стандарта мы можем писать вот так и в конце указывать тип
я не знаю с 11 но более того вот когда мы так пишем мы можем вот в этом вот типе в конце
трейлинг так называется формально говоря мы в нем можем использовать аргументы которые нам
прислали функцию ну если это просто какая-то функция это не особо полезно вот если функция
шаблонная то когда мы вот здесь писали тип мы не могли как-то использовать а например да
писать декл-тайп от а или там а стрелка где-то какой-нибудь вот вот это не работало там а не
было видно и собственно вот этот трейлинг ритор мы добавили ровно для этого чтобы мы могли
вот так вот писать ну
ну нет декл-вал здесь не особо подходит потому что нам нужно очень аккуратно
обрабатывать кейсы когда а это l-value ссылка или r-value ссылка и формально говоря ну там надо
очень аккуратно это сделать там легко ошибиться вот в таком виде оно выглядит легко просто и
понятно более того если говорить о свиная то вот эта часть внутри декл-тайпа или вообще весь
возвращаемый тип оно тоже учитывается в стена и что какую какую магическую магию это нам
позволяет сделать взять и буквально скопировать возвращаемый тип возвращаемое
выражение функции пахнуть его сюда теперь функция да сейчас секунду теперь функция возвращает ровно
то же самое что возвращал вот этот где то есть если где-то возвращает ссылку она возвращает
ссылку р-value ссылку р-value ссылку вот и вроде если значение то просто значение и это очень
здорово это нам по сути позволяет делать perfect forwarding и для аргументов и для возвращаемых
значений то есть вот это вот прошлойка и не кэст она вообще никак не влияет на ни на что ни на какие
категории значения ни на какие ссылки полностью сохраняет информацию о том l-value или r-value
хотим ли мы мовнутили скопировать вот но это неудобно да очень неудобно поэтому решили ну блин
а что делать да если функции функции много строчек то все их сюда впихивать это очень
костыльно и неудобно поэтому мы можем делать вот так и все оно автоматом вместо этого авто
подставит вот это выражение заметьте что вот это все не то же самое что написать вот этот
сейчас надо вспомнить конечно но в каких-то случаях вот этот авто он немножко не так
работает как мы хотим если get возвращает l-value ссылку в общем это хороший вопрос как оно
конкретно работает вообще да наверное все-таки она не будет да она не будет как ссылка в общем
это бесполезно пытаться запоминать проще каждый раз загуглить и посмотреть такие тонкости очень
редко нужны но при этом могут больно отстрелить ногу и если вы знаете что вам вот прям нужно
типа полностью все сохранить как бы l-value и r-value категории и на входе и на выходе то вы
используете деколта и под авто ну и писать вам можно не только сзади но и спереди теперь вот
но это немножко меняет семантик работы всего этого по сравнению с тем что вот тут было что
меняется манглинг нет это не интересно в чем разница между вот этим вот этим достаточно
важная да вот здесь свиная работы то есть если вот это выражение оно как бы некорректно да я
не знаю а нету такого шаблонного метода гет да то вот в таком случае у нас просто и не каст
вылетит из списка кандидатов функции которые могли бы вызвать сюда вот при огорел от резолюшен
мы обсуждали что строится сет потенциальных функций которые нам подходят и свиная просто
говорит о том что если в сигнатуре функции что-то подставилось и произошла ошибка то мы не
выкидываем компиляции а исключаем из множества подходящих функций вот соответственно где-то
в другом месте может быть другая перегрузка и не каста определенно который уже умеет
справляться как бы со случаем где где вот это вот не работа например стд а давайте даже демонстрируем
это а мы уже все стерли про и не каст ладно давайте вот здесь стреляем по-быстрому представим
что мы нам прислали шаблоном какой-то тешку про который мы точно знаем что она какая-то
имплементация они до стд либо не стд либо наши они а может быть и не наши не может быть
они из густа или вообще из другой библиотеки как нам написать от универсально чтобы они каст
который мы предполагаем есть у нас и во стд и в пусте работал во всех случаях если мы напишем
просто они каст да то кажется это нас спасет в этом случае да ладно плохой пример давайте
отложим этот вопрос мы потом да с они кастом мне не дастся демонстрировать
окей значит потом но до просфена и поняли так с финай есть вот так с финай нет но это не
единственное что мы еще хотим соблюдать при вот таком вот перфект форвардинге да давайте
подумаем вот где-то если он но accept и не каст он же все равно будет не но accept и это неприятно
не всю как бы информацию прокинули про функцию или про вызов очень хотелось бы чтобы если
нет но accept и не каст но accept если он не но accept то и не каст не но accept мы так можем мы пишем
но accept от буля вот так можно делать теперь по моему 17 и можно писать true или false соответственно
это будет определять рули но accept или false этот truly false может вам приходить из шаблонных
параметров например может быть какая-то глобальная применная config что-нибудь такое но
самое интересное то что можно написать еще раз но accept а в скобках какое-то выражение
после requires requires это не должно уже вызывать сильного шока вот эта вещь с 11 вообще здорово нет
но accept specify рэда а то что буль скобках можно писать да здорово вот вот эта штука
выдаст вам true если выражение скобках но accept иначе false и этот буль который говорит получится ли
вот это вот как но accept вычислить вы прокидываете собственно мой акцент для не каста и теперь
кое не каста мой к сепаря такой же как и у гета ну или у других частей этого выражения то есть
если все выражение но accept нигде там никогда не может выскочить исключение то вот это но тогда
и не каст макса и вот это вот совсем перфект перфект супер перфект форварде где вообще все
сохраняется и все здорово вот вот с комментарием к прошлому на этом всем давайте переходить к
будущему мы хотим вот эту вот идею с виртуальной таблицей развить обобщить и сделать супер классно
ну с какой цели на самом деле цели очень много первая наша цель будет симулировать
пусть у нас есть класс base даже айбез на интерфейс есть вот такая виртуальная функция есть вот
такая виртуальная мы делаем драйв и там перекружаем обе функции ну и делаем другой
класс draft такие изготовки айбез айбез паблик я не знаю зачем классы
не папсулировать пришли полиморфировать другой так ok соответственно что происходит
реальные вещи сейчас буду говорить ничего сложного мы делаем указатель на айбез который
равен и такую же фигню для 2 для хорошести давайте и вот эту базу мы можем запустить
можем запустить бейс 2 полиморфизм тип у них один синтаксис один вызов нас приводит в разные
точки кода один сюда другой сюда здорово давайте тоже самое делать руками что получается когда
мы объявляем айбез ну на самом деле в памяти айбез немножко больше чем нам кажется давайте
как-то это обозначим ну тут никаких данных не хранится давайте им положим туда чтобы он был
если бейс был просто структуркой без виртуального вот этого всего то и в памяти
он выглядел как просто один им но так как мы объявили виртуальные функции у экземпляров
айбез теперь будет лежать до вот этого им а указатель на виртуальную таблицу и умолчанию
если мы просто сделаем ну мио и бейс ну нам даже не позволит мне быть сделать да экземпляров
чисто абстрактных классов то есть кто-таки у которых хотя бы один метод чисто виртуальный мы
делать не можем окей что происходит когда мы экземпляра айдрайв ну как мы знаем если
мы наследуем что-то то наш родителей становится под объектом нас то есть как бы память состоит
теперь из двух частей давайте наверное даже горизонтально записывать чтобы было нагляднее
такими палочками разделять блоки соответственно теперь у нас все это состоит из двух блоков один
блок этой бейс а дальше идет как бы данные айдрайв и внутри этого и бейс у нас все еще
есть тейпл звездочка и все еще есть если мы какие-то данные добавим сюда то они просто дальше
будут складываться соответственно что происходит когда конструируется экземпляр дарайф 1 ну у нас
выделено такая вот память и как бы конструирование идет от под объектов к общему объекту да то бишь
сначала нужно самый вложенный объект то бишь родителя сконструировать ну так как формально
говоря конструктор вызывать нельзя это такое не очень понятное слово сконструировать но вот здесь
могут быть всякие инициализации да которые нужно сделать ну больше того конструктор это все-таки
могут быть у айбэйс и их все равно нужно запустить и при запуске конструктора драйв у нас
сначала запустится конструктор айбэйс который витей был звездочка положит ну вот это там данные
как-то инициализирует конструктор полностью отработает дальше мы придем конструктор драйф
один и вот перед тем как запускать само тело конструктора которые мы написали драйв один
подменит указатель на виртуальную таблицу на наш указатель на виртуальную таблицу где вот
уже записан указатель на вот эти наши функции затем инициализирует наши поля и уже запустит
наш конструктор если бы драйв дать один был еще один ребенок то он бы дальше в свою очередь
подменил опять вот и был звездочка на какого-то своего на какие-то свои какой-то свой вот это
соответственно когда мы кастим указатель с не ударает один на айбэйс ну фактически с ним
ничего не происходит он все еще указывает на тоже начало памяти и там все еще вот есть этот вот
но как бы по типу айбэйза мы знаем что в этом вот это и был вот это и на самом деле лежат
два указателя на функции войб от аргументов и их можно вызвать что собственно вот здесь и происходит
и когда мы создаем два разных драйв да драйв 1 драйв 2 вот эти указатели нова тейбл у них
получается разные после каста к айбэйзу и ровно за счет этого получается полиморфизм
окей это такое напоминание если сейчас что-то было непонятно давайте это говорить это вот
просто механика что как бы есть указатель на виртуальную таблицу он подменяется как бы
наследниками на свои вот в случае когда у нас только один родитель все просто понятно и хорошо
ну отдельные проблемы может быть то что у нас вот здесь могут добавляться новые виртуальные
и как бы нужно расширять таблицу вызовов но про это чуть попозже мне кажется мы это осили
не факт возможно этим не стоит заниматься так как мы будем изобретать наш велосипед
ну конечно нам понадобится структурка и конечно же она будет шаблонно вот какие шаблонные
аргументы там будут мы пока не понимать как компилятор вообще понимает в каком
порядке хранить функции виртуальной стаблице да ну наверное просто в порядке объявлений
сначала фу потом бам но как бы когда мы убирать делаем нам нужно по названию функции или там
сигнатуре понять в какой из слотов вот этих виртуальных функций идет оверрайт
там да скорее всего лежит какая-то каштаблица что-то вроде того так у нас тут мэта прога мы не
будем каштаблицу сам по ил тайме делать мы сделаем проще мы будем пытаться по некоторому ключу
индексировать а элементы витамин то бишь что это все значит давайте заведем еще одну структуру
витамин 3 и она тоже будет шаблонная и шаблоне у нас будет две вещи первая это статик стринг из
первого задания помните его он полез я решил на 64 сделать потому что 256 как-то жирновато
соответственно это будет что-то вроде имени функции вот меня сейчас как-то что-то останавливает меня
просто взять и заходить здесь статик стринг поэтому заготовочку на будущее давайте сразу
сделаем здесь некоторые даже лучше нет не лучше давайте сделаем некоторые класс ключа и
будем принимать экземпляры этого класса ключа а также нам понадобится нам понадобится сигнатура
чтобы знать но как вызывать эту функцию с какими аргументами ну это сигнатура соответственно
изначально у нас будет просто f и дальше нам понадобится наши любимые специализации как
обычно соответственно мы уточняем что у нас сигнатура была рет от аргстрой точь так все хорошо
все хорошо и хранить мы здесь будем соответственно указатель на функцию
сделаем юзин для удобства
указатель
discipl
соответственно
the
ics table table table table как мы сможем запихнуть произвольное количество
витейбл entry, наш витейбл. вот такое уже где-то видели.
когда мы, я не знаю, писали factory, там были какие-то креатуры, в которых нужно было
штуку запихнуть в класс, нет? что-что? ну да, именно так, через наследок. здесь будет
некоторый баг, пока не определились какой, но в итоге мы эти в витейбл entry сюда с чем-то
подставим и развернем такой баг. что там должно быть? кажется, у нас ключ должен быть один для всех,
а вот баг конкретных значений типа ключа и сигнатур, это уже чуть проблематично.
сейчас я пытаюсь сделать заготовку, чтобы потом не пришлось ничего переписывать,
я не знаю, насколько она будет сейчас.
давайте сделаем всю эту специализацию опять.
ааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааа
да, нужно подкасты лягать совершенно традиционные вещи
вот так мы сделаем
вот, все хорошо
нет, это пока никакие не полиции
хотя, если присмотреться, возможно
нет, мы пытаемся изобрести вотейбл
вотейбл должен состоять из entry
каждый entry содержит одну функцию
и мы определились, что мы хотим по какому-то ключу получать доступ к этим bitable entry
соответственно, да, вот так
приходится везде протягивать этот ключ
и в итоге в сам bitable мы будем впихивать
pack, par, key, value, ну и какой-то тип key
ну пока ничего особенного
теперь нам надо научиться доставать по ключу
из bitable
соответствующей функции
как мы хотим это сделать?
у меня есть сильное ощущение, что я такие вещи уже рассказывал
но я запамятал
мы же учились из вот такой конструкции, когда у нас куча наследников
вытаскивать из какого-то конкретного по ключу данного
когда в factory делали?
abstract factory
да, мы делали в каждом классе какую-то функцию
да, это момент параметра pack через вот в этот момент
но нам же тоже самое надо сделать
если мы собрались делать гет по ключу
одна только проблема
мы не очень понимаем, какая сигнатура будет в итоге
и с этим пока непонятно, что делать
ну как с factory и double element
давайте
да, double element
у нас примерно такая же ситуация
давайте ровно так сделаем
template key key
пока будет auto get
что нам нужно сделать?
прикастить себя к тому из наследников, у которых есть key
что-то типа того
давай ты мне поможешь написать эту фолпер функцию
я код colab сейчас не включал, что мы хотим?
нам наверное нужен template auto value tag
чтобы по нему диспатчить
соответственно вот table entry
мы будем возвращать
диспатч назовем
какие аргументы будут?
нет, мы хотим тихую диспатчить
мы хотим вот такие функции в каждой table entry объявить
в итоге вот здесь мы сделаем using
и вот здесь диспатч будем использовать
и мы хотим чтобы...
ну теперь все эти диспатчи они overloaded
они все видимо в одной области
это все перегрузки одной и той же функции
мы хотим чтобы с помощью overload resolution
мы каким-то образом выбрали диспатч
тот который нужен для этого ключа
но вот так не получится
почему так не получится?
ну да, у всех key одинаковый тип
да
поэтому я сказал что нам нужен value tag
мы хотим принять value tag
причем такой, где принимается ровно наш key
все
в теле мы вернем его, если мне кажется
я даже сказал бы, что это cast называется
что не так?
скажи мне
ну без карт возможно еще
ладно, неважно
вот теперь здесь мы делаем авто звездочка entry
cast
не забудьте здесь поменять
причем, если я не ошибаюсь, все-таки index cast
а нет, не index, мы их заusing-ли
в прошлый раз это выяснили
value tag
создать
ура
диспатчеризировались
через overload resolution
к нужной entry
теперь мы можем
в принципе сразу можем, даже не сохраняя
вернуть
value
ура
мы научились делать ket
что нам еще нужно?
нам нужно создавать это table
мы хотим, чтобы
если мы сделали такой класс ibase
то для него была бы создана одна статическая
как одна для этого класса
одинаковая для всех экземпляров
виртуальная таблица
где просто написано нули
или какие-то функции, которые там
кидают или что-то такое
также для draft1
для класса draft1
тоже генерируем
один единственный объект
его виртуальная таблица
которые используются всеми его экземплярами
то же самое draft2
мы перед тем, как
возиться, как это все сделать
перед тем, как возиться, как это сделать статическим
давайте
создавать мелочи
нужен конструктор
либо
либо метод create
и
в ходе хорошей библиотеки
я увидел, что они делают
публичном жарлонный метод create
поэтому мы тоже так сделаем
и возможно в процессе
поймем, зачем они так делают
а если не секрет, а какой библиотеки
идёт речь?
liveunifex
мы тоже сейчас доживём
надеюсь, это семинар
очень интересно узнать
надо как-то ускориться
конструктор vtable
будет принимать список
fnt value
он должен принимать
в каком-то виде набор ключей
и набор значений, которые
уже не классы
этих значений, а уже конкретные функции
мы хотим
выводить
на самом деле
давайте через метод create выводить
vtable
create
create будет принимать
да, именно так
static
он будет принимать
пак из функций
вернее указателей
на функцию
их мы пока
распаковывать не будем
здесь вот в retargs
это просто будут какие-то
типы
что конечно ключи
давайте их тоже выводить
да, сейчас
давайте
подглянем
потому что
происходит очень высокоуровневая магия
очень легко
да, не тот goodbolt
или тот
не тот goodbolt
не тот goodbolt
нас ждет
да, происходит очень классная магия
надеюсь к концу мы
начнем принимать
да
тут предлагают
указывать
функции ключи
ну да
это менее удобно
чем
нам придется поменять немножко подход
нам придется
сделать все-таки
конструктор
шаблонный
принимающий
пары
пары
из указателей на функцию
и value
тега
да
ключи
да
keys2 key
что значит ключи
второй пак ключей
зачем
второй пак ключей
второй пак ключей
нам нужно написать
deduction guide
цель какая
я не знаю
напишем вот так
static auto
auto
myq
be table
от
здесь будет пак пар
да
не знаю указатель
на какой-нибудь
какие есть глобальные функции
у нас на xp и std
которые можно для тестов использовать
видимо никаких
давайте сделаем static void
void foo
void bar
очень здорово классно
bar
value tag
bar
sister
жух
а это просто клан
как бесится
на самом деле код компельса работает
да
это был bar, а вот это foo
мы пока не умеем
делать
вот эту операцию автоматом
так можно
сложно и очень осторожно
поэтому пока что мы
к сожалению
давайте для отсутствия костылей
сделаем макро
чисто чтобы было удобно
честное слово
кто помнит как
решетка f
так кажется
и вот так
ура
это нас избавит
от проблем
это можно сделать без макросов
мы просто пока не умеем
научимся через пару семинаров
а нет умеем
кажется скорее не умеем
даже не научимся в таком конкретном кейсе
беда
ладно, оставим так
то есть что произошло
мы просто взяли и создали
vetable
и вся эта муть
с ключами value
и вот этим страшным паком
и специализациями, она автоматом выявилась
мы теперь просто указываем список
функций, которые мы туда кладем
это неплохо
вопрос
что ли это что нам нужно
что?
тип вывелся
вот этот
пак пар
из values
должны вывестись
из fs
да, пока не вывелось
мы дедакшн гайд не написали
мы дедакшн гайд сейчас напишем
и все будет хорошо
ключи, соответственно
из вот этого
этой части пака вывелись
и values
и keys
как ты поймешь
где я раскраничивается
мне кажется это не будет работать
давай не будем экспонентировать
просто как есть все сделано
так, теперь мне кто-то должен
будет помочь вспомнить как работает
дедакшн гайд
вернее какой у них синтаксис
это самое нас интересующее
кажется мы можем сделать вот так
и сказать
что если конструктор вызвали
от
вот так
то
выводится вот тейбл
от
нам нужно вывести вот эту
пару
вот примерно такая жесть
keys2
искренне надеюсь что это
будет работать
давайте проверим
вот так
запятая
такая запятая
нас не занимается
мне кажется нам нужно сделать это так
интересно сработает ли это
кажется да теперь она работает но только у нас дедакшен 5 не подходит почему не подходит где
мы ошиблись да это конечно проблема
это проблема проблема в чем мы здесь использовали как бы да кажется если мы сделаем вот так
все будет круто нет ничего не будет
ну что сделай здесь key 0
так мне кажется надо прекратить вот на это тратить время что-то более
продуктивное давайте скажем что мы просто будем явно указывать все эти штуки не будем
себе пудрить мозги, соответственно в конструктор мы просто принимаем values, конкретные экземпляры,
соответственно наши функции, которые мы собираемся вызывать и наших предков нужно
инициализировать агрегатно вот valse, то есть в каждого редкого table entry мы кладем
соответствующие вот это да конечно это агрегат ну explicit и всякую такую фигню, а что может быть
единственная проблема вот эти values мы не сказали от указателей на функции или ссылки на функции это
внезапно разные вещи в языке но одно в другое легко превращается так что кажется здесь должно
быть нормально то бишь существует вот такой тип, ровно его мы пишем просто до функции, но переменные
такого типа нельзя создавать, переменные можно только вот такого типа создавать указательно
да и мы хотим вот здесь соответственно указывать все-таки так же как в std function красиво,
вот здесь чтобы хранилось все-таки со звездочкой вот и соответственно значение вот эти вот наверное
мы тоже хотим принимать указатели поэтому вот как уже правильно замечают есть такая вещь как
std dkt которая куча всего разного непонятного делает но помимо прочего оно превращает вот такую
штуку вот такую то есть добавляет звездочку вот теперь кажется точно все хорошо давайте
мы будем с этим бендрижом все-таки сейчас париться времени маловато давайте создадим
лучше какой-нибудь тип, ки у нас будет static string 64, давайте даже лучше сделаем сразу это назовем
power table
это будет ключ значения, мы их сюда закидываем, чтобы просто не писать каждый раз static string,
когда мы будем баловаться с ним, а теперь
да это просто план бейсица, все отлично
сможем ли мы теперь сделать cool table
я слишком много сетета, да
ну да это клан
ура
обернули все в очень обобщенный код, пока непонятно что добились эти
о чем мы на самом деле добились, а все, теперь такой полиморфизм как в примере
нет давайте на всякий случай чуть-чуть-чуть потестим
и попытаемся его вызвать
да то есть читать это нужно как бы
получили указательную функцию
теперь вызовем
ура vtable работает
начнем копипастить вот этот код
наделаем его через наш cool table, а не standard
что это значит
во-первых все предстоит быть виртуальным
сейчас до максимума удобства мы наверное не будем стараться эту штуку довести
по конфликту имен добавим слово cool
все
здесь в самом начале нам хочется vtable звездочка
который на самом деле указывает на какой-то статический vtable
ровно как тот, который мы объявили
давайте его стянем
и наверное его объявим online, чтобы все было хорошо
наверное его унициализируем
да, но не хочет чтобы он у нас без унициализации жук
давайте сделаем
ну как, нельзя, конструктора-то нет без аргументов
значит надо его добавить
жук
вот непонятно, это просто клан весятся или что-то не так
а, равно 0 надо убрать
ну да, мы теперь не можем делать функции без объявления
ну типа, немножко недавно сработает
мы вообще можем эти функции убрать
потому что вместо этих объявлений virtual равно 0
у нас теперь вот этот vtable
который равен
тут еще
я так плохо называю
потому что все равно сейчас
поменяю
но это дико неудобно
каждый раз такую штуку городить
более того, если вдруг у нас 2 одинаковых набора
вот этих вот всех аргументов
сейчас
не складывается
не складывается
не складывается
и да
давайте пока так продолжим
да
у него свой vtable
в котором
давайте даже объявить
так
так, сделаем
ок
теперь аналогичная конструкция
должна приехать
в каждую следующую функцию
только теперь
да, только здесь
теперь нужно вписать наши функции
но вот беда
мы там сказали, что функции void
у нас на самом деле
не совсем функция void
это методы, которые что-то принимают
соответственно, нам такие методы
не нужны
соответственно, нам таки нужно сказать
что здесь мы принимаем
и если мы теперь хотим overriding
попробуем добиться того
чтобы оно ровно с такими явлениями
работало
для этого нам нужно как-то
превратить вот эти функции
которые принимают
icool base звездочек и запихивают
их и вызывают у них
ну мы вновь
будем
делать прикольные мены
здесь мы будем делать
статик cast
нам
мы это
имеем право делать
так как эта функция находится
в виртуальной таблице нашей
следовательно
если из этой виртуальной таблицы
что-то вызвалось, значит
настоящий динамический тип
статик cast мы имеем право делать
еще раз, ты не понял, почему
можно статик cast
конечно
да, конечно
да
так лучше
кажется ему совсем
плосо, надо
отправлять
окей
это же еще не все
мы вот так делаем
на самом деле у нас там пары принимались
теперь нам нужно
через запятую
имя вроде
так же мы делали
да
нет, мы не так делали
нет, мы просто в том же порядке, в котором их объявили
да, мы
отбросили эту идею
потому что ничего чуть-чуть не получилось
и проще так
похоже на правду
мне кажется похоже
если есть вопросы
давайте это обсудим
мне хочется чтобы мы сейчас
поняли какую магию мы
руками сделали
оп-полиморфизм без оп
вот так
ну и все в принципе
конечно все это можно вернуть в макросы
какие-нибудь классные
да
еще не все
мы вот здесь вот так сделали, но это конечно же не то
что нам нужно
да, мы хотим родительский table
подменять на наш конструктор
ровно это мы и сделаем
как бы в конструкторе
говорим
как мы его назвали
мне почему-то кажется, что в деструктуре
мы тоже кое-что должны сделать
вопрос что
что будет, если мы
уничтожаем
объект типа cool-drive1
у него
в конструкторе table
положилась вот эта штука
а потом кто-то из предков например
iql-base в деструктуре решил
виртуальную штуку вызвать
как бы вызваться все будет нормально
вызваться вот эта вот функция
которая прикастит
да прикастит base-cool-drive1
который уже как бы уничтожен
во внешнюю оболочку
над-объект уже как бы начали
удалять
и беда
cool-drive1 уже удален
а base еще нет
нам прислали base у которого
как бы нет cool-drive1 части
мы его кстати кастнули и взрыв
да, нам нужно делать
table
конечно мне хотелось чтобы все было гораздо красивее
автоматизировать не стримлайн
но
судьба такова что
придется
ура
билдес
drive2 drive2
fullbar
отлично
вопрос а как вызвать
давайте iql-base
перемешаем
ну тут как бы опять хочется
какой-нибудь rtp использовать чтобы на самом деле
подмешивать вот этот вот getable
и вот эту штуку тоже подмешивать
но это слишком для крутых ребят
мы сделаем пока тупо
мы просто сделаем
ничего не будем делать
зачем мне ее писать
да, поехали
iql-base
равно
ui-drive
cool-drive1
2
base1
base2
каких тебе по мне
нет там буквы не
ура
ура
base1
double
get
шаблон
да
get по ключу
и вызываем это
конечно не очень удобно
да
вот какую обертку мы можем написать iql-base для удобства
мы можем делать диспетчеризацию
через
value-tag
сейчас
как мы это хотим
мы хотим чтобы это
был template
или нет
да, это будет template
static stream
4s
который лежит вот здесь
и
некоторые аргументы для вызову
возвращать он будет
угадайте что
table
table
table get
s
args
args
args
forward
args
forward
args
forward
forward
forward
get
get
get
get
этот get нам еще и указательно
возвращает
так
это уже будет работать
проверим
base 1
virtual call
foo
да
и мы никаких аргументов не передаем
теперь base 2 позовем
foo
эксперименты
и
get
да, действительно
попытка номер 2
нет
а, нам нельзя забывать про this
this
вот что мы забыли
да, оно работает
виртуальная таблица вызовов руками
на костылях
какие ограничения
и что вы можете сделать если вам вдруг очень
хочется поиграться с этим
первая проблема
расширение этой виртуальной таблицы
если мы в CoolDirect
хотим добавить
еще один виртуальный
метод
его нужно добавить в таблицу
да, идти в таблицу уже меняется
но вообще говоря
мы можем
заменив
вот эту вещь
на
как бы наследование от vtable
с откусанным
последним аргументом
да, мы как бы генерируем
иерархию в каком-то смысле
откусываем из начала по одному
одной функции
одной паре ключа значения
и это нам позволит
кастить vtable
который содержит
на одну функцию больше
помимо всех таких же
к тем кто
как бы к родительским vtable
т.б. vtable который содержит
примерно вот такие функции
void от int
и void от la
его должно быть можно
прикастить к vtable который содержит
void от int
но это сигнатура
ключи считаем что
одинаковые
да, давайте даже напишем
вот если у нас есть foo
в одном vtable
в другом vtable foo и bar
в третьем foo, bar
и bus
вот этот vtable
должно быть возможно
скастить к вот этому
в таблицу
да, статически
то есть просто вот этот
должен наследовать вот этот
должен наследовать вот этот
это вам позволит
в детях хранить статическую
переменную
с вот таким
vtable
а в родителях с вот таким
vtable, ну не статическую
переменную, а вот
ну не статическую переменную, да и указатель, нет статическую переменную
я уверен, что сейчас ничего не понятно, но давайте назовем эти типы как-то, что вот как бы
table такого формата, table3 это table2
в родителе может храниться указатель на table2
равно три точки, а ребенок может создать table вот такой, основной функции больше
после чего прикастить к вот этому и положить в родителя вот этот указатель на table
если вот эта штука как бы реально наследует вот эту, а этот наследует вот эту и при каждом
наследовании у нас на одну большую функцию становится, то мы так можем
и это собственно и позволяет нам в ребенке добавить еще одну новую виртуальную функцию,
которую его уже дети смогут перегружать, вот это первое, что здесь нужно пофиксить
нет, он один, да вот такой table2 звездочка один, но туда можно как бы положить любого
наследника, указатель на любого наследника и потом статик кастами приводить обратно к нужному
да, на самый верхний один указатель, да, иначе будет что-то очень странное происходить
я хочу сделать на эту задачу, но мне скорее всего не будет времени, поэтому не сделаю
да, мне кажется третьей задачей можно в таком стиле что-то написать, еще тут еще не так, да,
множественное наследование, мы пока его вообще никак не умеем контролировать, что произойдет,
если у нас несколько наследников, у них разные таблицы, нужно как бы уметь верайдить и туда и туда
а наши таблицы это должна быть как бы комбинацией их таблиц, не сильно думайте об этом, это нужно
долго писать и вникать, ну что-то такое, причем эта идея, она немного артагональна идее вот этой вот,
потому что вот такие две штуки сконконтонировать мы как бы не особо можем, и мне кажется это супер
такое хардкорное упражнение сделать эту штуку с поддержкой множественного наследования,
а потом подъезжает виртуальное наследование и вообще просто пиши пропало, давайте,
вот, но идея вот этих вот виртуальных таблиц, которые можно в шаблонах просто явно прописать
и как бы использовать, она не ограничивается ОП-шкой
остановились мы на том, что накостреляли VTABLE, сказали, что можно сделать его конечно и лучше,
гораздо лучше, но очень сложно, и мы сейчас немножко в другую сторону пойдем, чтобы более
интересное применение этого VTABLE увидеть, давайте как-то вот эти прикольные классы, все
namespace.op бахнем, и туда же вот это все бахнет
так, все, да, значит поехали, то о чем я с Anycustom пытался донести мысль, если мы пишем люто-шаблонный код,
и нам присылают какой-то какие-то те каким-то образом почему-то,
например, что-то такое, и нам понадобилось сделать swap,
что будет происходить, ну, во-первых, обычно мы std swap пишем, ну, как правило, человек сел сядь на
плясах, он ставит функцию std swap, а почему это не очень хорошо, потому что std swap он как реализован,
он делает три move, ну да, но вот по дефолту swap делает три move, а что если тип лежит в какой-то другой библиотеке,
эти move не заинлайнятся, и они там ну плюс-минус дорогие, три вызова функции из какой-то другой
библиотеке, которая еще там что-то делает, очень часто есть способ сделать swap дешевле, это возможно
микро оптимизм, но тем не менее стандарт позволяет кастомизировать swap, то есть если у вас в каком-нибудь
namespace есть какая-то структурка, вы можете прямо в этом namespace сделать swap для этой структурки,
и вообще говоря хотелось бы, чтобы этот swap можно было использовать в обобщенных алгоритмах,
и это работает, если вы используете какой-нибудь стандартный алгоритм для структурки s, ну или там
я не знаю, какой-нибудь sort, используйте для вектора s, вероятно sort внутри использует где-нибудь swap,
ну как бы это зависит от имплементации, конечно же какой у них там sort, но вероятно, предположим это пузырик,
и вот этот swap из стандартной библиотеки, если он там конечно есть, он обязательно найдет вот эту
функцию swap, каким образом? алгоритм стандартной библиотеки, если он использует swap, да он найдет,
почему? argument-dependent lookup это называется, я не помню, обсуждали ли мы это с вами, скорее всего нет,
но если мы пишем вот такой вот вызов, то есть unqualified без уточнения namespace, то вот эту функцию
swap будут искать не только в глобальном namespace, а еще и во всех namespace связанных с типом
аргументов, то есть связанных с типом ten, если мы сейчас запустим эту функцию foo от sss,
сделаем из этого вектора, то все будет работать,
давайте даже в качестве обязательства выведем, отлично,
ты про то, что swap должен быть концептами какими-то связанными,
ну да, мы конечно вот нехорошо сделали, конечно по стандарту, если вы вот такую штуку сделали и
определили в связанном с namespace операцию swap для s, то вы уже подписывайтесь выполнять семантику
swap в этой функции или у вас ub, то это ub, это одна из проблем, в которой я иду, среди таких
функций swap, считайте глобально зарезервированные имя, begin, есть такая функция std begin от контейнера,
стд end от контейнера, все эти функции это такие глобально зарезервированные имена, также называемые
точками кастомизации, такие функции, которые нужны примерно для всего подряд на свете и
хочется уметь их кастомизировать, помимо вот дефолтного какого-то определения, для конкретных
типов, например, стд begin кастомизирован, чтобы если от него передали сишный массив,
он все равно не ломался, как и стд end, это тоже такой поинт, что если у вас, давайте даже так
сделаем для пущего эффекта, если у вас какой-то неизвестный контейнер в шаблонном коде, делать
вот так нельзя, это не корректный шаблонный код, потому что в качестве контейнера могут
передать сишный массив, вообще говоря, а правильно делать стд begin от век, и вот он уже умеет
обрабатывать, он умеет обрабатывать сишные массивы, еще какие-то коронаптехи есть на самом деле,
систроки, мне кажется, и подобные штуки, в общем не будем, коронаптехи бывают, так вот,
на чем остановился, ну окей, мы написали, круто, кастомизируется, и не работает, давайте
скомпилим, чтобы более адекватное сообщение об ошибке, да swap not defined, потому что мы сюда
пихнули int, и как мы как бы, у нас нет такой функции swap, у нас даже нет namespace связанного
с int, в котором бы моглась найти функцию swap, ну мы напишем не std swap, мы напишем using std swap
и после этого swap, и здесь тоже самое, using std begin, а потом просто begin, таким образом в список
функции, которые будут рассмотрены, добавляются, во-первых, std swap, который мы заюзингали, поэтому
к нему можно без qualifiers обращаться, во-вторых, любой слог, который лежит в связанном namespace
с типами аргументов, то есть вот этот слог, и вот это уже корректно написанный шаблонный код,
который уважает точки кастомизации стандарта, ну постепенно, да, это первый шаг программы,
вот, но нам же нифига не удобно вот так делать, ну come on, кто помнит в шаблонном коде, что каждый
раз, когда ты там вызвал какую-то из вот этого списка функций стандарта, нужно обязательно сделать это
вот таким образом, но это больно, поэтому в каком-то там, то ли 14, то ли 11 году мистер Эрик Нибблер придумал
чит хак вообще убойный, чит хак заключается в следующем, правда, чит хак должен находиться в том
месте, где мы первый раз объявляем вот эту точку кастомизации swap, то есть в том месте, где std swap объявлен,
так как мы силами менять стд либо не обладаем, мы будем свою точку кастомизации объявлять,
mybegin, например, давайте сбихнем это, как бы лучше все это сделать, давайте вот здесь, да,
сделаем какую-то функцию, не так, трюк начинает с того, что мы теперь используем не функции,
а мы используем как бы функторы, но лучше говорить функциональные объекты,
да, я обожаю спорить на эту тему, то бишь, что я имею в виду, мы делаем inline, статик не статик,
пока не важно, он стэкспор, стракт, mycpo назовем, и что может делать наша цеплошка,
давайте она будет принт делать, это будет наш принт, и назовем принт cpo,
окей, вас не смущает этот лютый синтаксис? вас он должен смущать всех,
то есть что мы здесь сделали, да, мы как бы прямо внутри объявления переменной объявили структурку,
типа которой она будет, без понятия о чем речь, ну ладно,
окей, ну да, это такая типа древняя техника, так носи писать очень любили,
ну и сейчас так носи пишут, но в писах редко встречается, вот здесь как раз, вот, и мы хотим в
итоге вот эту точку кастомизации запускать принт, и это сразу нам на самом деле несколько проблем
решит, ну понятно, ладно, пока не решит, окей, соответственно, если мы собрались запускать эту
штуку, у нее должен быть оператор круглой скобки, давайте он будет принимать что угодно, конечно же,
возвращать ничего и делать какой-то дефолт адекватный, будем писать unknown,
дефолтной имплементации, так, так, так, все хорошо, теперь если мы вот так вот сделаем, туда запихнем нашу
давайте даже эту эсочку в другой namespace запихнем, что, что, да, сейчас я,
возникли ли у меня проблемы, если они в одном namespace, мне кажется, может, это будет, это
my space, namespace, my, нет, ладно, должно быть, я помню, что это работает, значит у нас заработает, все,
да, конечно же, нам нужно эту штуку пометить const и не const, а static, просто const,
окей, окей, окей, здорово, пока ничего не добились хорошего,
давайте лучше все в кинепринт, не могу я решиться, лучше мы сделаем свою точку
кастомизации для свопа, и будет он принимать уже теперь не 1, а 2,
да, а будет делать он следующее, ровно тот самый бюфазный лукап, вот этот вот кастильный,
ну, типа, вот этот странный способ делать шаблонный код, конечно же, здесь немножко не хватает
форварда, но меня недавно научили, что форвард можно вот так делать, потому что в слове форвард много букв,
а времени бесконечно, надо сокращать код, код, да, ну, кстати, каст тоже долго писать, понимаешь,
это очень много бюф, для кода на семинаре отлично, вот в чем трюк, трюк заключается в следующем,
что, мне кажется, мы даже это можем просто слабо назвать,
а да, у нас есть вот этот фигетин еще, сейчас, давайте сделаем так,
нет, так и задуман, давайте для индикации того, что происходит увидим кирк, и теперь попробуем просто
где-нибудь взять, а собственно, что нам пытаться, вот у нас здесь есть, вот это уберем, внимание, что получится,
да, почему три раза, вызвали один раз, интересно, трюк очень сложный просто, но что должно было произойти?
а потому что, нормально, трюк удался, все нормально,
в чем заключается трюк, да, в чем заключается трюк, когда мы объявили переменную, а это перемен,
в глобальном namespace, мы на самом деле зашедовали, а даже для пущего эффекта, мы это пишем namespace.std,
в общем, идея в чем, вот такой вызов через объект, глобальный, его оператор круглые скобки,
он на самом деле отключает ADATE, если мы сейчас положим вот эту вот штуку в какой-то,
ладно, давайте не будем про это, тут очень сложно последовательно все рассказать, беда.
она будет приоритетней, чем любая функция слов, вот в этом прикол, да, то есть, да, вот-вот-вот-вот-вот,
все, я сформулировал мысли, нет, я думаю, мне стало полегче, нет, не стало, вот здесь, раньше,
пока не добавили вот эту фигню, у нас вызывался слоп, который лежал внутри, став s, слоп, который
лежал вот здесь, так, теперь, когда мы добавили вот такую штуку, почему-то вызывается не вот этот
слоп, который функцией найденной ADL, а оператор круглые скобки у объекта, почему так, потому что
вот этот слоп, он в приоритете над всеми остальными как бы функциями, которые также называются,
могут быть найдены там ADL или еще как-то, вызов, вернее так, определение имени как название глобальной
применной в приоритете над определением имени как вызовов функции или как функции, и вот на этом
основан этот лютый трюк, мы специально всегда вот такие вызовы слоп теперь пропускаем через вот
такую конструкцию, и там уже обрабатываем вариант, что у нас может быть из-за стд-слоп, а может быть
найден ADL слоп, вот, и этот, да, что ты имеешь ввиду, давай теперь в namespace,
mylib, да, что значит как бы не обращались, что ты имеешь ввиду,
а, в плане, что если, да, в плане, что такая же функция foo или там bar, она может лежать в том же namespace и
просто как бы вот так делать, и ей уже не нужно указывать qualified имя, ну, в общем, это немножко
упорядочивает вот этот вот весь ад с метапрошным вызовом каких-либо точек кастомизации, потому что по
дефолту нужно вот так писать, везде всегда помнить, а если все вернуть такой вот трюк, то не нужно
об этом думать, просто пишите, хоть mylib2.swap, хоть и просто swap, если уже внутри этой библиотеки,
и все работает, и называется этот трюк, и вот этот объект nebloid, вот, где же нам нужны nebloids,
ну, как оказалось, не совсем nebloids там нужны, а даже более прокачанная вещь,
где же они, а может header видим, что не так,
ой, они еще по переименованию,
не, да, раньше было написано nebloid, красивое же слово, а, теперь customization.object,
да, это, я думаю, достаточно очевидно, nebler, nebloid, история заключается в следующем, один
из редакторов cppreferent спрашивает, как мне назвать вот эти выпендрежные супер дупер объекты от Эрика,
ответ Эрика, могу ли я со всей скромностью посоветовать имя nebloids, следующее сообщение,
это скрин, где везде проставлено слово nebloid, но с тех пор они его поменяли, беда, ну вот,
да, begin и end и прочие вещи в рэпжах, они такие nebloids, окей, ну, видимо, где-то поменяли, где-то нет,
вот, то есть как бы inline constexpr unspecified begin равно unspecified, то есть это переменная
непонятного типа в непонятном namespace, да, ну и на самом деле выглядит оно вот примерно так,
как мы здесь написали, давайте посмотрим из любопытства, inline constexpr cast access begin,
begin, ровно оно, только тут куча всяких выпендрежей, да, там require сами их связывают, в общем,
все круто, и вот, собственно, да, вот наш самый оператор круглые скобки constexpr, к тому же
возвращающий авто, но accept, как мы видели еще в самом начале, он там в зависимости от того,
accept ли что-то другое, и вот он костыль для массивов сишных, если вот этот tp, который сюда передали,
это array, то мы убираем все extents с array, в общем, делаем невероятные вещи, которые, видимо,
нужны, чтобы это действительно всегда работало, независимо от каких-то странных кейсов, да,
интересно, вот, ну ладно, ну давайте не будем пытаться понять, да, ну типа как бы сишный массив и
указатель на его начало, формально говоря, по стандарту, чуть-чуть разные вещи, хотя и на деле
тоже, поэтому нужна вся эта чехарда, кажется, вот, дальше проверяют, если у него есть как бы метод
begin, то вызывают у него метод begin, иначе делают вот этот вот, вот тот самый, который мы здесь сразу
делаем, то есть через стандартную функцию, но так как у них и так это все в namespace и cstd определено,
и вот этой строчки нет, то есть у них вот это вот, ну оно само находится как бы в текущем namespace,
вот, тут есть еще несколько некоторых тонкостей, о которых проще всего, конечно же,
узнать от самого Эрика, а не пытаться придумать, где, нет, значит я пудрил, в общем есть вот такая статья,
где все это подробно и очень понятно расписывается, статья еще 14 года, и тут есть небольшое замечание,
что вообще говоря, ну объект с одним оператором скобки или такой тип, его можно генерить автоматом
на самом деле, да, через лямбда, на что Эрик привел ряд причин, почему так нельзя, а у нас,
мне кажется, так можно, потому что мы в будущем, наверное, мы сейчас не будем на это тратить время,
да, лямбды не бывают куда-то с экспортом, теперь бывают, ОДР тоже не проблема, потому что у нас
ключевое слово inline, которого раньше не было, да, для перемен, constraint, generic, лямбда, раньше было нельзя,
теперь можно, automatic return type deduction, ну там со свиная могут возникнуть проблемы, да,
что если мы пишем какой-то более капертизированный алгоритм, чем слов, например, begin, мы должны,
как они вот здесь вот это делают на самом деле, да, с помощью requires проверить, что мы вообще,
типа, такой тип нам подходит, у него есть вообще это begin или он контейнер, ну вот здесь немного так,
типа, странно, так а maybe board range это, а, вот, концепт, вот, как минимум вот это, да, концепт,
который требует, чтобы вот этот аргумент был range, тип его, а зачем это надо, вдруг две разных
библиотеки объявляют вот такой customization point object, да, cpo, если еще называется, ну под
названием size, один имеет в виду размер вектора или там структуру данных, другой имеет в виду
площадь геометрической фигуры, ну, типа, размер же блин, вот, чтобы эти все вещи не конфликтовали,
можно концептами вот здесь затребовать, чтобы работало только для такого и тогда, в случае,
если мы имеем два size, один от shape другого от контейнера, пихнув, ну, сделав вызов size от shape,
оно само поймет, что вот это не подходит второе и вызовет первое, окей, это все здорово, это все классно,
но одну из главных причин и главных болей мы не решили, мы все еще глобально резервируем ключевое слово swap,
эта проблема понятна, если при каждой точке кастомизации, которых в стандарте внезапно,
ой-ой-ой-ой, как много, это еще не все, тут еще алгоритмов есть, в общем, их становится реально много,
если с каждой новой точкой кастомизации мы новое слово глобально резервируем и никому нигде в коде
не разрешаем его использовать для других вещей, то очень быстро слова в английском кончатся и нам
будет больно, эту проблему надо как-то решить, и ее решение тут просто бомбезное, как бы к нему подвести,
но мы его в принципе уже знаем, мы только что вот там где-то сверху,
где же оно было, а вот здесь оно было, вот этот каст мы его диспетчеризировали через оверлоуды,
то есть какой-то ключ внутри такого вот value тега использовали, чтобы выбрать какой из кастов
мы хотим вызвать в зависимости от ключа, окей, давайте заведем, это будет теперь не myLib, а std,
который с большой буквы, как бы std, заведем здесь две вещи,
давайте class и заведем здесь, наверное мы сразу вот эту,
заведем здесь функцию, вернее customization point, под названием tag-invoke,
он будет уже немного сложнее,
он будет принимать некоторые cpo и аргументы,
и собственно он будет пытаться все еще точно так же как было раньше,
он будет пытаться с помощью ADL найти функцию tag-invoke, куда прокинет cpo, куда прокинет аргументы,
в чем pond, это некоторая инфраструктура, которая нам теперь позволит плодить эти точки
кастомизации, где мы хотим, как мы хотим, и они не будут у нас конфликтовать,
давайте в namespace объявим точку кастомизации,
допустим это какой-то наш особый begin, бегову назовем, потому что не хочу бороться с конфликтом,
все еще делаем примерно то же самое, почти такое же не было делаем,
оператор какой-то скобки шаблонный,
но вот здесь делаем несколько иное, мы делаем tag-invoke под бег,
ну да, наверное нам так-то и не нужен, делаем вот такую штуку,
наверное так, в чем идея?
мы будем выбирать некоторую функцию tag-invoke, у нее будет много перегрузок в разных namespaces,
где угодно лежащих, основываясь на вот этом первом аргументе, то бишь если мы захотели
сделать какую-то свою структуру данности, здесь должно быть много кода, но его здесь нет,
это будет vectorintof, и мы решили эту точку кастомизации бег кастомизировать для него,
например он приватно следует, или приватно его где-то хранит, и поэтому мы не можем
просто так точку begin вызвать или std begin, кастомизировать мы будем так,
да, здесь конечно не будет, а декл-тайп от авто, возвращать нужно этот результат,
friend tag-invoke, или там myVectorBeg,
наверное это должно работать, но конечно так сложно,
почему tag-invoke сам себя вызывает, ну точно так же как у нас раньше swap сам себя вызывал,
это он вызывает не сам себя, он вызывает функцию, а вот эта штука это какая-то переменная,
и соответственно вот эта штука, вот это имя не увидит, потому что оно еще не объявлен,
и найдет варианты только с std и возможностями функций, ну вообще конечно да, и вот здесь,
ну вот да, там был какой-то костыль кажется, что вот нужно что-то аккуратно сделать,
чтобы вот в каких-то супер крайних случаях не нашелся, вот сам же этот tag-invoke рекурсивно,
ну окей, последуем стандарту, inline namespace, это такой namespace,
который как бы namespace не является, а просто добавляет все свои результаты в внешний namespace,
но каким-то хитрым образом, вот тут уже черт много сломят, говорят это помогает,
собственно зачем оно на cpp референсов не используется, ну имя у namespace как мы знаем,
можно не указывать, так вот, а вот здесь уже вся эта фига мне не нужна, здесь у нас все хорошо,
можно даже вот так сделать и в чем-то оправляем, это статическая функция, которая выкидывается в внешний
namespace, но вот эта friend функция, которая как бы и добавилась в namespace, ее нельзя явно вызвать,
единственный способ ее вызвать это addl, а addl у нас может быть по всем аргументам, соответственно
там вот myvector, второй аргумент и позволит нам, наверное не constant, и позволит нам найти вот эту
friend функцию при вызове tag-invoke, то есть вот в этом месте, когда мы попытаемся сделать tag-invoke
с первым аргументом begin, вторым аргументом myvector, оно с помощью addl все-таки найдет и вызовет
ее, так давайте это уберем, и проверим работает ли теория, мне кажется все-таки
самым интересным времени не останется, и да, окей, ладно, попробуем, mylib, бег, там с маленьким, бег от myvector, бег,
давай что-то положить бы хорошо, ну ладно,
да, constant теряли вот здесь, вот это работает,
все даже нормально, а type-it это
ну чем мне нравится, давайте проверим,
да, то есть действительно нам вернулся итератор на вот этот вектор, который там лежал внутри,
окей, почему это все очень здорово, теперь у нас зарезервировано ровно одно глобальное имя в namespace std под
названием tag-invoke, все больше зарезервированных глобальных имен нет, второе, так как лукап идет по
конкретным типам других точек кастомизации, мы никогда не сможем перепутать что мы вызываем,
вот если у нас так окажется, что вот ситуация с двумя сайзами, один из которых для фигур,
другой для контейнеров, это что значит, это значит что у нас две вот таких точки кастомизации с
одинаковым названием две глобальных переменност в одном файле видны в одном месте, это будет
ambiguous name, нам сразу просто выдадут ошибку и скажут, извините, и попросят уточнить, а из какого
namespace мы хотим вызвать функцию, мы уточним, а из namespace геометрических фигур, и все будет
работать после этого, я не знаю, вот этот begin, если мы явно указали, что мы используем mylib-bg,
то уже нет выбора, кроме как прийти вот сюда, а tag-invoke будет среди оверлоудов выбираться при
помощи вот этого вот уникального, так сказать, ключа, типа структурки, который мы вот здесь
inline объявили, и ни с какой другой точкой кастомизации, с другой библиотеки или откуда-то не было бы,
это не спутать, и кажется на этом все, в итоге мы найдем какую-то из перегрузок функции tag-invoke,
которые обычно пихнуты как френды в какие-то конкретные, какие-то конкретные типа, но не
обязательно, их можно и в глобальном namespace делать еще много где, так, еще про кастомизацию,
для вот таких точек кастомизации, которые сделаны через tag-invoke, конечно же, тоже можно делать
default, ну и мы примерно представляем, посмотрев уже вот сюда, как они там будут делаться,
ладно, я потерял этот код, можно проверить, что у tag-invoke есть regim, тогда мы можем сразу вернуть
tag-in, иначе мы можем сесть и вызвать вот этот вот левок, и тогда наша конструкция сразу начнет
работать, вот теперь давайте все-таки вернемся к источнику всей этой
магии, замечательному пропузелу, он написан очень простым языком и очень наглядно показывает
все эти проблемы, так что рекомендую ознакомиться, потому что это все попадет в стандартском,
вот, ну и соответственно, если мы совсем все по-хорошему пишем и как большие дяди действуют,
то объявляя новую какую-то точку кастомизации foo, нам нужно, во-первых, предусмотреть noexcept,
во-вторых, предусмотреть SFINA, чтобы если случайно название, вернее, здесь это кажется не особо
нужно, да, вроде как есть какие-то corner cases, где важно именно вот так делать, tag-invoke, как вы
понимаете, это тот же самый tag-invoke, что у нас, а SFINA нужно, ну зачем, да, вот здесь просто this
перекидывают, я не знаю, почему я так же не сделал, я зачем-то заново создал экземпляр того же типа
можно просто сделать this, и тут супер подробно написано, почему это вылечивает примерно все
проблемы, вот про адаптеры еще важно сказать, но их пример какой-то супер неприятный, давайте
представим, что мы делаем какой-то адаптер, который внутри себя хранит т-шку, как мы в классических
плюсах или в классическом op прокидывали все вызовы, которые умел делать т, к нему обратно,
ну если просто по плюсовому, то можно в оператор стрелочкой или там оператор звездочкой вернуть
вот эту т-шку и прокинуть ему вызовы, как вы в домашней собственно должны сделать, если мы
делаем op-style, то нам тут нужно как бы да вот сделать вот так вот, самоследовать т, надеяться,
что у него методы виртуальные, и тогда если мы храним указательный адаптер, его вызовы автоматом
прокинуться к т, а вот если мы адаптер хотим сделать с помощью вот этих тег инвоков, то
внезапно получается конфетка, вот этот friend тег инвок мы можем кастомизировать по самой цп ошки,
да помним, что тег инвок, первый аргумент, это некоторый класс цпо, который просто говорит,
как бы кто пытает, вернее какую функцию мы пытаемся вызвать, какую точку кастомизации,
мы можем сказать, что если любую точку кастомизации попытались вызвать с адаптером т,
да, но не сейчас, мы можем сказать, а пойди-ка и сделай все еще тег инвок с той же цп ошкой,
но теперь не для адаптера, а для его флешки, то есть мы прокинули все вызовы точек кастомизации
к адаптеру на вызовы к его элементу, это может быть, например, share ptr или unique ptr и это нам
позволит любые попытки unique shared ptr использовать в точке кастомизации какой-либо, прокинуть запрос
к тому, что лежит под указателем, мне кажется, это немножко ого-го, как круто, но то есть реально
очень сильно освобождает головной боли при работе с такими адаптерами, с паттерным адаптером,
ОП потребовала бы динамической диспетчеризации, здесь, заметьте, вся диспетчеризация статическая,
да, ну также можно подобные трюки делать не только для, как бы объявляя френдов,
можно их и глобально объявлять, но глобальные минуты говорят засорять хорошо. Так, какие еще
есть классные пункты? Да, мы можем концептами описать список, вернее, мы можем описать класс,
который умеет вызываться в следующих точках кастомизации, то есть вообще, если задуматься
точки кастомизации, это алгоритм, а типа это какие-то данные. Можем сделать концепт,
как бы его назвать адекватно, не знаю, вот так. Вообще говоря, для тех, кто немножко шарит
другие языки, это можно назвать trait, потому что это максимально похоже на trait в Rust. Я знаю,
что они там бывают динамические и статические, вот динамические — это то, на что у нас не хватит
времени, а это статические, да, и мы просто требуем, чтобы, если нам дали такую тешку,
да, по аналогии с тем, что этих ребят мы могли любую из этих цеплошек запустить. Надеюсь,
у меня сейчас сработает с разверткой. Ну ладно, скорее всего не сработает, придется чуть похитрее.
Вот, теперь мы в каких-то шаблонных функциях можем просто описывать, что...
Мы можем сделать концепт range, который там затребует, чтобы у T были std ranges begin, std ranges end,
ну и все в принципе, но только нам нужны... Да, не совсем так, это конечно не классы, это объекты.
Вот, и вот это максимально похоже на type классы в Haskell или traits в Rust,
где вы просто указываете, какие... Ну, когда вы создаете какой-то trait или type класс, вы говорите,
какие функции должны у него поддерживаться, потом совершенно отдельно вы прям обязаны сказать для
каждой из этих функций, что я как бы вписываюсь в этот trait. Ну, есть некая разница, но мне кажется,
эту мысль можно добить. Окей, давайте наверное на сегодня завершим тогда,
или какие-нибудь вопросы можно по обсуждать, проблемы с домашними и прочее.
