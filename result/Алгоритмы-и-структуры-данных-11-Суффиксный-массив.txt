Ну давайте вспомним, на чем мы вообще остановились, о чем там у нас вообще.
То есть мы помним, чем мы вообще занимаемся. Мы ищем подстроку в строке. Ищем соответственно
подстроку в строке, хотим найти все ее вхождения, но при этом затратить единицы дополнительной
памяти. В принципе алгоритма мы напоминать не будем, но пожалуй такие леммочки все-таки
основные напомним. Так, ну, так, ну, во-первых, давайте помните вышедшее префиксный период.
Ну, это который встречается что-то там. Ну, точнее так, давайте начнем вот с чего. Давайте,
давайте напомним. Определение значит строка там допустим с базовая, если что.
На что? Нет, тут все проще. Строка с базовая,
если ее нельзя представить в виде конкатинации больше чем одной одинаковой строки.
А вот, ну, вот, то есть также у нас еще было определение, что с у нас допустим
L периодично. Давайте уж так напомним, да, если там допустим S от 1. Вот я, ну, по-разному это
можно писать, но я вот могу написать так. Вот, можно и вот таким образом определение написать.
Да, мы писали раньше по-разному, мы говорили, что любые два символа на расстоянии L в строке
S совпадают, но легко убедиться, что это ровно то же самое. Вот, но это, конечно, такие достаточно
стандартные определения. То есть самое нестандартное, но при этом ключевое, это мы говорим, что там допустим
T префиксный период S и вот тут уже принципиально. Префиксный период S, если T в степени K, значит
префикс S и T базовая. Вот, да, напоминаем, что у нас есть мистическая константа K равно 4.
Да, префикс, да, важно написать префикс S. Ну вот, ну и в принципе, да, то есть все у нас, в общем-то,
плесало вокруг префиксного периода, вокруг этого понятия, и мы вообще всячески хотели минимизировать
понятие префиксный период. Вот, ну у нас там была, нет, ну вы говорите, может я, кстати, зря тратю время
на то, чтобы что-то выписывать или не зря? Потому что в принципе я пишу то, что по идее у вас и так есть.
Вот, ну кратенько давайте тогда свяжем, что у нас есть с вами лемма о периодичности,
которая говорит так, что если S, P периодично, Q периодично, значит и модуль S больше либо равно
P плюс Q, то тогда мы знаем, что S, GCD от PQ периодично. Вот, ну у нас там было более сильное утверждение,
там модул S больше либо равно P плюс Q минус GCD, но нам это сейчас не пригодится. Там повторять
старые доказательства сейчас не будем. Вот, то есть, ну это такая, ну вот это в принципе общая лемма,
которую вообще полезно знать. Вот, есть лемма, ну вот, но есть вот две леммы, которые мы уже
пользовались для того, чтобы даже построить сам алгоритм в предположении одной те реммы. Так,
но для этого надо воспомнить еще одно понятие мистическое. Напомните-ка мне,
пожалуйста, что такое shift с индексом S от Q. Наименьший период. Наименьший период? Ну в принципе да,
то есть это минимальное такое L такое что? Минимальный период кого? Это какая-то чиселка
от одного до модул S. Да, совершенно верно. Да, оказывается, это действительно у нас очень
удобно. Так вот, лемма один. Лемма один у нас говорила следующее, что если shift с индексом S
от Q меньше либо равен чем Q делить на K, вот, то S соответственно от 1 boom boom shift с индексом S
от Q. Это что? Как это да? Чекакашный вопрос. Завершите лему двумя словами.
Конечно, конечно. А какими еще тут двумя словами можно закончить лему? А так да,
это у нас лемма один. Так вот, то есть в принципе действительно оказывается очень удобно. Ну вот,
ну и дальше говорим лемма два. Лемма два у нас говорит, ну тут у нее пострашнее были условия.
Если оказалось, что S1 boom boom L это префиксный период, вот, то оказывалось эквивалентное,
то есть вот это вот условие, что L равно вот этому шифту, и поэтому этот шифт еще и меньше либо
равно чем Q делить на K, и это верно тогда и только тогда, когда K умножить на L оказывается меньше
либо равно Q, меньше либо равно reach с индексом S от Q. Да, то есть можно сказать, что для любого Q вот это верно.
Вот, были такие леммы, помните? Вот, это в принципе мы это доказывали и этим даже пользуемся,
вот, потому что у нас есть там действительно какой-то, действительно есть какая-то мистическая
модификация там методок, но там урис аппарата, но вот, который там позволяет как-то аккуратно
насчитывать вот этот reach. О, кстати, не вспомнили, а помните, что такое reach? Насколько сейчас максимальный L периодичный префикс?
Да, да, да, вот я давайте вот здесь напишу. Ну да, то есть коротко можно определение написать так,
reach S от L просто равен, на самом деле, L плюс Z функция в точке L плюс 1. Да, мы писали тогда
другое определение, мы писали, что reach это там максимальный префикс статист, который является L периодичным.
А мы не можем L 1 написать в обе стороны? В обе стороны. Ага, да, да, да. Ну, почему ловушка-то сразу? Наоборот, может, хорошо.
Ну, мы пока толком и не начали, на самом деле. Мы пока это воспоминаем. Вот, например, сейчас вот
действительно Никита задал интересный вопрос, а нельзя ли L 1 написать в обратную сторону? Вот,
допустим, жил был у какой-то, жил был у строки S префиксный период. То есть, да, понятно, вот,
точнее так, получается, жило было какое-нибудь Q такое, что shift S оказался префиксным периодом строки S.
Да, ну, тут, видимо, подразумевается, что префиксный период строки S, конечно. Вот,
внимание, вопрос, следует ли этого, что shift S от Q меньше либо равен Q делить на K? Вот, давайте подумаем.
Ну, если это префиксный период. Так, и что? Ага, куда?
Так, давайте, давайте, давайте. Ну, да. Ну, так,
его четыре копии. Да, совершенно верно. Да, то есть, на самом деле, то есть, конечно,
Лема в таком, в обратном виде утверждает, что если у какого-то Q есть, для какого-то Q есть shift,
который является префиксным периодом, то четыре копии этого shift обязаны помещаться в Q. Но это,
конечно, вовсе не так. То есть, мы просто берем префиксный период и в качестве Q берем длину
этого префиксного периода, плюс один, например. Да, поэтому нет. Вот, но, тем не менее, вот,
то есть, в обратную сторону, что если shift умещается, то он все-таки действительно префиксным
периодом, он, естественно, является. Вот, так, это у нас такая штука была. Да, поэтому, я говорю,
мы пока воспоминаем. Да, потом была вторая, да, а потом прошло еще две, а потом прошло еще две,
если не три недели. То есть, там прошло две недели, то есть, более-то, вот тут вообще там, ну да-да-да,
нет, все еще ходит туда, тут еще кто-то вместо меня приходил. Вот, так, соответственно, это
отдельная песня. Вот, так что, поэтому придется воспомнить. Ну, на самом деле, остановились мы,
в общем-то, на, то есть, мы пытаемся, то есть, остановились мы на том, что мы пытаемся доказать
мистическую теорему 3, ладно, не теорему 3, а теорему о декомпозиции. Что это за теорема? Она говорит
нам, что любую строку P можно порисонуть на строчке P равно UV, где в некотором смысле, значит,
у В не более чем один префиксный период. Ну вот, и У, ну вот, и длина У равно О от шифта этого В.
Вот. Мы пытаемся доказать такую теорему, потому что, если мы, то есть, мы пытаемся доказать не
просто, что такая теорема верна, а еще взять строку P и распилить ее на две такие части, то есть,
явно в виде найти эти все УВ. А еще и совсем в идеале, конечно, УВ неплохо было найти и,
ну вот, соответственно, и какой-нибудь шифт от В, и, ну вот, там, желательно найти шифт от В,
и, конечно, ну вот, и, собственно, этот префиксный период. Вот. А вот, кстати,
а давайте действительно на эту тему подумаем. А вот, допустим, нам дана строковая, нам известно,
что у нее не более чем один префиксный период. Вот задачка. Найти этот префиксный период.
Понятно. Желательно. Вот как его найти? В любом случае, все равно пригодится,
поэтому давайте попробуем повключаться тут. Вот задача. Как найти, или даже по факту это будет
в общем случае, как по заданной строке В найти минимальный префиксный период? Соответственно В.
Так, что LMA-1 говорит? Ну как? Ну что значит нужна? На самом деле она может сильно пригодиться в
доказательстве, но как минимум заметим следующее, что есть подозрение, что минимальный, скажи так.
Он автоматически базовый будет. Нет, подождите. Ну как сказать? Ну, скажем так. Ну да, можно,
конечно, заметить, что наша бы задача найти минимальную строку Т такую, что Т в степени К
префикс С. Утверждение, да, утверждение. Это Т, если такое существует, оно заведомо базовое.
Это мы понимаем почему, да? Понимаем, да? Вот. Что у нас еще есть? Так, к сожалению, так, напоминаю,
у нас фишка, просто префиксы за эту функцию мы насчитать не можем, потому что мы живем в мире,
где до памяти должна быть вот единица, поэтому мы тут вообще страдаем. Так-то в общем-то задача
поиски подстроки в страте с до памяти у нас уже давно решена и сильно более простыми средствами.
Ну, во-первых, у нас еще сувмасс есть. Так, но это тоже, но это будет тоже просто достаточно,
но после этого точно. Так, но давайте думать, как же это вообще можно сделать? Но для этого мы
вспомним, что у нас есть вообще, давайте вспомним, у нас был мистический рыжий механизм. Вот вы можете
этот старый конспект поднять и вспомнить, что у нас основу даже алгоритма шел какой-то вот
мистический механизм. Ну вот, то есть там механизм, что у нас была какая-то, значит, то есть какая-то
пара PQ, которая была равна там изначально 1, 0, да? Ну вот, и дальше там механизм мог идти как? Ну,
давайте вспомним там, скажем, ваил, там, ну, допустим, я не знаю, P там меньше, чем модулес,
там у нас алгоритм звучал как-то так. То есть мы поддерживали, что такое PQ? Ну,
то есть инвариант говорил так, что S от P плюс 1, пум-пум, там, P плюс Q равно чему? Ну, когда мы искали
под строку P в строке S, то он должен был быть равен там что-то типа префиксу 1, пум-пум, Q. Помните,
да? И мы, в общем-то, это Q, но это Q мы вот всем или иным способом пытались подкрутить, то есть там
в данном случае там ваил оказывалось там P плюс Q плюс 1, там, значит, меньше либо равно, видимо,
там, модуль S, там, ну и, видимо, надо еще, в данном случае придется еще сказать, что Q плюс 1 меньше
либо равно модуль P, там, and-and что-то еще. А что еще было? А еще было, ну и, соответственно,
если выяснилось, что не просто там, а выясняется, что PQ плюс 1 равно S от P плюс Q плюс 1, ну, значит,
мы делаем плюс-плюс Q, вот. То есть мы вот так вот как-то идем, то есть поддерживаем такое минимальное Q,
и там, ну, где-то говорим, что если оказалось, что там Q равно равно модуль P, то как бы пум-пум-пум типа
вхождения, вхождение идентифицировано, да. А потом мы говорим, что PQ неожиданно превращается в
P-Q-. И это был такой мета-алгоритм, да. То есть главное, чтобы вот, то есть, в принципе,
все решает вот эта волшебная функция. Ну, давайте воспомним, да, что, ну вот, но теперь давайте,
вообще, к чему она может быть равна? Ну, самый, ну, идеальный вариант, конечно, какой у нас идеальный
вариант? Идеальный вариант — это сказать, что, там, в идеале Q штрих равно shift с индексом P от Q.
Ну, и понятно, P штрих, естественно, равно P плюс Q минус Q штрих. Это был бы, это прям вот идеальный
вариант. То есть, если этот, я утверждаю, что этот shift присылают нам с небес по факсу, то, в общем-то,
это практически алгоритм Кнута Мориса, правда, в явном виде. Пока ими кто-то так считает. Да, мы,
конечно, с точки зрения префикс-функции смотрим на это немного иначе, но, на самом деле, суть понята.
Так вот, действительно понятно, почему, если бы у нас вот такое было, то алгоритм работает.
Ну, там идея такая. Так, давайте я просто это нарисую. Вот жила была строка S. И вот мы
неожиданно нашли какую-то позицию P и обнаружили, что вот, начиная с этой позиции, вот на P плюс Q,
вот эта вот позиция является префиксом строки P. Ну вот, теперь возникает вопрос,
где может начаться следующее вхождение? Мы замечаем, что следующее вхождение может начаться вот
в какой-то такой позиции. Такой, что, если мы отсюда начнем искать совпадение с префиксом,
то мы дойдем вот как минимум до сюда, правда? Но тогда это будет означать, что это тоже префикс
строки P, и тогда отсюда будет следовать, что вот это вот совпадет с вот этим. Логично, да?
То есть, так как вот это сам префикс строки P, получается, надо у него взять шифт, вот минимальный
шифт. А мы Q сделали не меньше, мы Q меньше. Ну Q' меньше, чем Q. Конечно. Ну, вроде да. Вот. Тут,
конечно, классная коллизия, что типа букву P обозначает и позицию строку. Да, проблема.
Проблема. Ну, хорошо. Ну, можем пока не поздно быстренько строку P и строку S подбегать на другие
буквы, какие мы предпочитаем. Т у нас уже базовый префикс. Ну, не важно. Нет, мне кажется, это не
обозначение базового префиса. Ну, хорошо. Ищем, хорошо. Т, префисный период. Давайте не Т. На что?
Т точно. Давайте R. Р, пожалуйста. Ищем R, V, S. Так, хорошо. Ищем R, V, S. Тогда давайте вот тут везде,
где P. Нет, ну, P, V, R поменять, знаете, это простая вещь. Даже зачекивать ничего не надо. А в те
время декомпозиции? Ну, в те время. Да, пожалуйста. А это непринципиально. Ну, давайте уж тогда уж. Ну,
в первую очередь понятно. Мы-то, в общем-то, строку R в итоге обрабатываем для того,
чтобы было удобно ее искать. Там, в общем-то, идея была в том, что... То есть там идея была какая вообще?
Там была идея в том, что мы находим... То есть мы по факту будем искать вхождение именно строки V.
И для каждого найденного вхождения строки V будем еще от шифта еще и проверять. Там линейность,
по крайней мере, этой проверки заключалась в том, что каждое следующее вхождение V будет не
менее чем через шифт от V, поэтому получалось хорошо. Поэтому конкретно эти проверки работали
за линию. Да, это было для нас прям вот хорошо. Так, ну что ж, вас помнили. Так что вас помнили.
В принципе, в идеале было бы так, но для этого, конечно. Но чтобы знать шифт, необходимы такие
идеальные шифты. Это то же самое, что знать префикс функцию, по сути.
Ну, кстати, в такой постановке не очевидно, почему это за линию работает.
Почему это за линию работает? Ну, например, заметим, что P плюс Q... Ну, заметим, скажем, что у нас
P плюс Q никогда не уменьшается. Потому что P плюс Q – это граница этой строчки. Она влево не двигается.
Поэтому как бы два указателя налицо. Так что здесь-то еще все понятно. Вопрос как бы в том,
что заметим, что знать шифт то же самое, что знать префикс функцию. Помним такое? Потому что на самом
деле шифт мы могли вообще определить, как Q минус префикс функции от Q по факту. Прям вот в
явном виде. Ну, на самом деле там алгоритм был посложнее. Ну, там предлагалось, что если УВ
нет вообще префиксного периода, то была альтернативная версия. Давайте себе представим,
ну давайте так вот. Воспомним, что если УР нет, допустим, префиксного периода. То есть,
тогда из этого следовало у нас, что P штрих Q штрих равно чему? Что-то там P плюс Q делить на K,
запятая ноль вообще. Неожиданно нам заявляли. А почему нам это давать? Ну давайте так.
По сути да, LEMMA-1 или вот идейно, ну то есть интуицию тоже можно немножко покачать. Оказывалось,
что если мы тут нашли вот такой префикс, у которого шифт там меньше, чем KТ часть, то есть вот этих
вот шифтов, то есть это вот шифт, а я тут могу этих шифтов еще 4 штуки набить. Ну вот этот шифт,
то тогда это или что-то меньшее должно было быть префиксным периодом. Вот. Поэтому получалось так.
Ну а если префиксный период есть, хотя бы нот, то там тоже выясняется, что если он в этот префикс
совмещается, то где-то он маленький. Нет, давайте нот. Ну то есть действительно давайте нот,
ну давайте тогда. Тут как бы вот префиксный период есть. Нет, а вот давайте представим, давайте
вот уже разминаться так до конца. А если у нас ровно один префиксный период у строки V есть и он
равен P, что делать? Ну смотрите, вот мы только что сказали, что пусть у строки R нет префиксного
периода. Тогда мы сказали, что мы просто перескакиваем вот так и не паримся, потому что как бы вот.
Ну вот. А теперь представим себе, что префиксный период есть, но он один и он равен P. Там у R есть
там префиксный период, длины. Так P. А у нас опять коллизия, да? Да что ж ты будешь делать? А там M?
О господи. Нет, давайте так. Ладно, будем следовать статье P1. Ну там будет второй префиксный период,
он будет P2. Вот это оно. Тогда что? Пусть у нас есть один префиксный период. Воспоминаем,
а также воспоминаем интуицию. Почему? Потому что вся эта интуиция у нас там дальше начнет
работать. Просто мы там искать префиксные периоды будем примерно тем же методом. То есть знаете,
то есть идеи будут примерно вот вокруг этого крутиться. Вот, значит, смотрите. Ну вот давайте
смотреть. Итак, представим, что у нас есть префиксный период длины P1. И вот мы нашли какой-то
префикс. И тогда у нас как бы два случая. То есть случая номер первый. Там префиксный период,
то есть четыре копия этого префиксного периода у нас никуда не вкладываются. Спрашивается,
насколько тогда можно сдвинуться. Ну да. Ну то есть оказалось, что вот этот P1 умножить на
K оказалось больше, допустим, чем Q. Заметим, как бы в этом месте мы как-то пользуемся леммой 2.
А что нам говорила лемма 2? То есть как бы она в этом месте говорила, что Q, видимо,
меньше ли ровно reach от этого префиксного периода. Хотя, но с другой стороны, она как бы не больше
либо равна, чем K умножить на P1. Следовательно, то есть вот эта лемма в наглую нам говорила,
что эта лемма у нас оказывается, то есть из этого следовало, что shift от этого Q больше,
чем Q поделить на K заведомо. И более того, отсюда даже из картинки даже можно быстренько понять,
откуда мы это взяли. Потому что предположим, что здесь есть какой-то мелкий shift. Вот предположим,
что у нас возник какой-нибудь такой мелкий shift, у которого тут 4 копии есть, хотя бы 4 копии. Но
тогда утверждается, что самый минимальный shift, он по-любому должен быть префиксным периодом,
правда? В том числе и строки P, в том числе и строки R. Поэтому здесь мы получаем противоречия
с единственностью префиксного периода у строки R. Следовательно, в этом случае тоже оказывается,
надо сдвигаться на Q поделить на K без проблем. Нет, это если достаточно далеко. А было другой
случай. Если совершенно случайно выяснилось, что префиксный период P1, то есть вот эти как
минимум 4 копии сюда прекрасно втискиваются. Что у нас верно тогда?
Префиксный период длины P1, значит он помещается в R. Ну в R-то он по-любому помещается, это да.
Мы тут стартовали в позиции P строки S, и насчитали с этого момента максимальную подстрочку,
совпадающую с префиксом R. Выясняется, что 4 копии строки R могут сюда не попадать. Вот,
то есть они могут попадать, а могут не попадать. Вот, ну что делать, если они сюда попадают? Ну тут
на самом деле одно из двух. На самом деле верно здесь одно из двух. То есть смотрите, так как на этот
раз вот это условие верно, правда? То есть Kу на P1 меньше либо равно Q, правда? В данном случае да.
Значит, если он меньше либо равно Q, то теперь проверка. Верно ли, что Q меньше либо равно
reach. В данном случае с индексом R от P1. Ну то есть если мы вот возьмем этот префиксный период и
зациклим его до длины вот найденной нами Q, то прям возьмем и зациклим, зациклим, зациклим,
зациклим. То есть доскачит ли она до Q самой строки R? Ну да, мы просто расшифровываем,
что оно значит, да. Ну правда, только что в предыдущем случае не выполнялось. Нет,
из леммы ничего не следует. Нет, тут лемма говорит, что вот эти утверждения эквивалентны вот этим
утверждением. Я понял. Вот. Сейчас у нас по определению L shift от Q меньше либо равно, чем K1 на Q,
потому что мы так. Ну да. Нет, про shift мы ничего не знаем. Ну shift хотя бы наш префиксный период.
Ну мы пытаемся понять. Ну действительно да, shift у нас действительно не имеет. Ну тут неважно.
Да, тут везде shift у нас не должен быть меньше префиксного периода. По камере в данном случае
здесь. Ну да, хорошо. Точнее здесь точно в предыдущем случае могло быть больше вопросов на самом деле.
А тогда shift как минимум столько, ну теперь возникает вопрос, ну возникает вопрос сколько? Что? Ну тогда
просто надо проверять. То есть если вот этот reach там достигается, а там заранее в строке R,
это проверить можно, если вы уже знаете префиксный период. То есть вы один раз знаете префиксный период,
то reach от него вы можете прям в явном виде насчитать. Ну да. Что нет? Вот. Ну раз мы его можем насчитать,
то там дальше выникала победа. Ну вот. Ну вот тогда получается, что если этот reach доходит до Q,
то есть эта строка действительно P1, то есть этот префикс строки R, он еще и P там периодичен,
то действительно мы с чистой совестью можем сказать, что shift прям тогда в явном виде равен,
то есть вот этому сдвигу, то есть вот P1, и тогда мы там просто действуем вот по этому правилу. То
есть P сдвигаем P равно P плюс 1, Q там минус равно P1, то есть тогда вот это тоже совпадающий префикс УРА.
Ну Q минус равно P1, а P плюс равно P1. То есть как бы если тут вот зацикл, то есть по сути,
если тут зацикл есть, то надо сдвигать ровно на P1, не на шоу кроме. Вот. Но если этого reach нету,
то есть reach оказался имею, то есть там этот зацикл, зацикленность P1 достигает там,
заканчивается раньше, чем Q. Да, тогда мы вынуждены действительно сдвигать на Q делить на K, оказывается.
Вот давайте еще раз, давайте еще раз. Давайте попробуем еще раз все это собрать. И так,
предположим, что у нас совершенно случайно выяснилось, то есть мы вот догнали вот это
вот Q у нас, да, вот это вот Q, то есть это вот позиция P плюс Q. Вот. И выяснилось,
что префиксный период, то есть четыре копии префиксного периода сюда не попадают. Вот.
Ну да. То есть если тут рисовать четыре копии, то они доходят до Q и уходят дальше. Тогда
я утверждаю, что shift заведомо больше, чем Q делить на K. Почему? Ну просто потому,
что если тут shift, если тут у Q есть shift меньше, чем Q делить на K, то этот shift явно тут является
префиксным периодом, как мы уже раньше выясняли. Это даже не лемма два, а просто лемма один. Но
тогда тут был бы префиксный период, противоречие с тем, что у нас нет другого префиксного периода.
Понимаете, да? Вот. Значит, у нас пока его нет. Так. Вот. Поэтому здесь получается,
что мы просто сдвигаем P просто на Q делить на K, а Q обнуляем. Вот, кстати,
с линейностью у вас здесь могут быть вопросы. Потому что раньше у нас линейность достигалась
за то, что правая граница никогда вправо не двигается. А здесь она резко, то есть влево не
двигается. Вот. Потому что, смотрите, просто в этом случае мы делаем переход такой. P превращается
в позицию P плюс Q делить на K, а Q превращается в ноль. То есть мы с этого момента начинаем
двигаться в тупую. Вот. Не понятно. Вот. Поэтому здесь линейность уже, то есть линейность
здесь не так очевидна, на самом деле. Отка. А, ну домножение на K, да. Ну, то есть утверждается
следующее, что... Ну вот. Ну да. Ну, по сути, да. То есть смотрите, как интересно. Ну, на самом деле,
действительно, здесь можно в этом убедиться следующим образом. То есть у нас гарантировалось
следующее, что если у нас P увеличилась на какую-то величину, скажем, дельта X, то тогда это
гарантирует, что вот с этим вот Q, то есть это Q не более чем 4 дельта X. Ну, в смысле как дельта
X, да. И это означает, что у нас обработка была не более чем 4 на дельта X. То есть тогда,
получается, если просуммировать по всем дельта X, то получается, что суммарно у нас все здесь
сделалось не более чем за 4 длины строки S. Понятно, да? То есть поэтому вот это удобно. То есть если
мы сдвигаем P, даже вот обнуляя Q, хоть на какую-то вот Q делить на константу, то это как бы нормально.
Вот. Ну, вот. Ну, это правда, если мы сдвигаем только настолько. Ну, там, конечно, есть комбинация,
потому что мы сдвигаем иногда вот так, а иногда по шифту. Ну, а с другой стороны, там тоже ничего
страшного нету, потому что тогда у нас получается, что у нас мы с какого-то момента начали к уровну 0,
оно тут шло-шло, мы там двигали-двигали-двигали-двигали, а потом, наконец, все-таки решили обрубить. Но в этом
случае тоже легко обнаружить, что если рассмотреть вот эту суммарную Q, вот на которую мы тут с самого
начала сдвинулись, то как бы это итоговая P здесь там переместится тоже как минимум на вот глобальные
эти сдвиги поделить на K по фактам. Понятно, да? Вот. Да, то есть поэтому здесь вот такая нот. То есть
это у нас такая интуиция, почему это все линейно работает. Да. Что мы делаем, если помещается? Да. Ну,
это мы дальше тогда. Значит, если, значит, если не помещалось, то мы чуть-чуть, мы только что обсудили,
а вот если неожиданно, если помещается, если помещается, то есть допустим, что у нас тут вот P1
неожиданно поместилось. Давайте вот я тут буду.
Точно нет. Это мы точно знаем. Потому что, да, был бы меньше shift, был бы меньше префиксный
период. Вот, бесспорно. Вот, поэтому, но вот. Да, но может так случиться, что штиф равен P1. Как мы это делаем?
Это мы заранее выясняем, так как у нас у строки, напоминаю, R единственный префиксный период,
поэтому для него за линию можно выяснить, отчему равен reach от него. То есть насколько
префикс длины R может быть P1 периодичным, прям в тупую выяснение. И оказывается, если как бы этот
префикс, P1 периодичный префикс длины Q или более оказался, то мы можем просто сказать,
что shift равен P1 и сказать, что P равно P плюс 1, а Q равно Q минус P1. И получится, что, то есть
следующий раз Q стартует как бы с этой же позиции, по сути. Понятно, да? Вот, ну а в любом ином случае
что делать? То есть, допустим, если P, но вот, но теперь, если оказалось, что, то есть, P1 периодичности
у нас нет, но тогда, тогда, но тогда утверждается, что тогда можно смело сдвигаться хотя бы на Q
делить на K. Почему? Ну, во-первых, у нас в лиме написано, что это так. Ну, точнее так, вот это утверждение,
ну, хотя нет, лима, конечно, говорит не совсем это. То есть подлость заключается в том, что на самом
деле, если вот это утверждение не верно, то в общем-то, конечно, и то, что не верно уже вот это вот,
и то, что shift больше, чем Q делить на K, там само по себе никто не говорил. Нет. Сейчас у нас
эквалентность же. Эквалентность-то да, но эквалентность прям всех вместе условий. А так у нас
выяснилось, что K умножить на P1 оказалось меньше либо равно Q, но Q при этом больше, чем reach. То есть,
это условие не верно. Ну, вот. Да. Нет. Может быть не верно просто, что P1 не равен shift.
Так что формально это еще ничего не значит. Поэтому придется как бы снова пушировать
нашу интуицию. Давайте подумаем. Но тем не менее, очень хочется сказать, что меньше, чем Q делить
на K, двигаться не придется, если тут вот прям. Но действительно, потому что, предположим,
что обнаружено, что у нас есть какой-то мистический сдвиг, какой-то P-штрих. Такой,
что вот строка P-штрих периодично, и при этом тут хотя бы четыре копии P-штриха найдутся.
Мы доказываем следующее, что предположим, что оказалось, что у нас четыре копии этого
префиксного периода P1 влезают в Q, но при этом вот эта строка длины Q, то есть она же префикс
длины Q строки R, P1 периодично не является. Вот. Тогда я утверждаю, что если мы найдем вот этот
shift P-штрих, то я утверждаю, что shift должен быть больше, чем Q делить на K. Потому что, говорим,
пусть у нас найдется shift P-штрих, который меньше, чем Q делить на K, но меньше либо равен. То есть
четыре копии тут как бы есть. Что тогда можно сказать? Ну, как минимум, можно заметить,
что, ну, конечно, нельзя сказать, что P-штрих это префиксный период, конечно, да? Хотя почему
нельзя? Можно. Да, то, конечно, да, он прям префиксный период и есть. Но у нас же нет
другого префиксного периода, кроме P1. Ну все, фейл. Вывод, значит, на Q делить так, а двигаться
можно. То есть вот такая у нас была интуиция. Такая интуиция, такая логика, такое шел.
Так, это мы еще, но это мы воспомнили. А теперь попробуем решить уже новую для нас задачу.
Ну практически, но сейчас нет. Да, нет, это была не новая задача, да. Нет, мы решали полтора часа
на прошлой паре, мы решали другую задачу немножко. Сейчас я, да, ну прошлую со мной хорошо вот так.
Нет, прошлую с вами и Галилом. И Галилом? О, ну да. С вами прошлая была с субтитров. А, ну да,
только. Да, да, да, да, да, да. Да, да, да, да, да. Ой, господи, как все сложно. Ой, господи, то это,
то это. То Бабин с миобиусом еще придут и Дерехле. Нет, вот там Дерехле с миобиусом было, да? А ты не был?
Нет, я не пришел. Отсчеток. Ну вообще у нас. Нет, ну частично, нет, одно дело, другое дело с точки
зрения алгоритмов. Нет, там, нет, там иронично, зато там было, насколько я был в Бестия, наоборот,
пришли люди, которые обычно сюда не ходят. Ну да, ну просто да, как давно я Васю Дубинину, например,
не видел. Ну сюда и сюда не ходят. Нет, нет, ну сформулируем так. Обычно, скажи так,
те, кто сейчас вот на втором курсе сюда стабильно ходил, я вроде более-менее знаю. Так что да. Так
что да. Ладно. Ну вот, ну хорошо будет, да. Ладно, так вот, значит теперь у нас новая для
нас задачка. Дана строка R, найдите, пожалуйста, ее там, ладно, или даже дана строка V, надо
найти ее минимальный префиксный период. Вот очень хочется, точнее, понять, желать назвать,
есть ли у нее префиксный период, если да, то вот минимальный какой. Вот такой вот задачка.
Давайте попробуем, глядя вот на этот механизм, понять, а не можем ли мы случайно такую штуку
найти. Давай. У нас был один случай, в котором мы сдвигались не на Q, делить на K, а на P1. Да.
Не могли в этом случае тоже сдвинуться на Q, делить на K. Нет. Некорректно было. Нет, ну точно,
сдвинуться, нет, куда, ну вот. Нет, ну там просто shift, ну просто в чем цель сдвига? Когда мы сдвигаем
мы гарантируем, что начиная с более ранних позиций, интересных вхождений нет. А что такое интересное
вхождение? Мы хотим, чтобы начиная с этого момента подстрока совпадала с префиксом длины хотя бы
вот дотягивающимся досюда. Вот у нас в этом цели была. То есть если она заведомо не дотягивается,
то их даже рассматривать бессмысленно. Вот. Там такого было нельзя, потому что там какой-то есть,
то есть мы знали, что такой префикс есть, начиная с позиции P плюс shift. Ну когда как? Нет, смотри,
там два варианта. Если мы знаем, что shift меньше, чем Q делить на K, то приходится на этот shift
сдвигаться, но тогда мы знаем, что это за shift, и знаем, что тогда он дотянется хотя бы досюда,
и Q может стартовать прямо с этого места. Вот. А если мы знаем, что shift там, мы не знаем,
какой shift, но мы знаем, что он больше, чем Q делить на K, значит начиная с Q делить на K
и смотреть здесь, начиная с Q равно нулю, мы вполне можем. Так вот, такой вот глубокий смысл.
Во, так же и да. А, все настолько просто, что Миша уже смотрит в учебник по матанализм.
Там есть ответ вот на это. Ничего себе. Так, ну ладно, давайте смотреть про минимальный
пресексный период. Как же искать минимальный пресексный период? Так вот, я утверждаю,
что искать его надо примерно так же. Вот просто буквально тем же механизмом,
только мы будем работать не с двумя строками, а с одной. Ну давайте так, начнем вот с чего.
Когда вот этот алгоритм, в итоге, да, пользовались. А здесь не факт. Но смотрите,
в чем фишка. Смотрите, а что нам вообще нужно? Тем не менее, забираю вперед, я даже скажу,
мы там даже два минимальных пресексных периода найдем. Да, пока вам это может
рвать шаблон, но тем не менее, я думаю, сейчас мы в этом убедимся. Смотрите,
ну начнем с простого. Ищем минимальный пресексный период. Как его найти? Ну нам
нужно найти минимальное такое, по сути, то есть, минимальное такое P. Так, ну,
минимальное такое P, что там reach от P хотя бы 4P. Ну да. Логично, да? То есть,
фактически, надо минимальное такое P найти или убедиться, что его нет.
Тогда идея такая, тупой алгоритм мог так и выглядеть. Давайте переберем тупо все P,
для каждого P прям в тупую, но считаем reach. Да, это будет за квадрат, но это будет работать,
правда? Но теперь идея, что давайте попробуем пользоваться вот этими методами. Как мы будем
пользоваться вот этими методами? А очень просто, смотрите, жила была строка V. Допустим, вот это
была строка V, и мы тут в какой-то момент исследовали вот такое P. То есть, насчитали
мы тут у него reach, да? То есть, насчитали тут это P плюс Q такое, что префикс длины P плюс Q
П периодичен, да? И оказалось, что P плюс Q строго меньше, чем КП. Пока меньше. Вот,
ну потому что как только мы начнем, найдем первое, то есть как только мы начнем, найдем первое P такое,
что там P плюс Q, кажется, больше либо равно КП, и это будет P периодичная строчка, да? То как бы
значит мы победили. Вот, но это пока оно меньше, теперь давайте думать. Так, ну давайте думать,
насколько нам, то есть скажем, имеет ли нам, то есть куда нам имеет смысл сдвигаться?
То есть, нам имеет смысл сдвигаться вперед. То есть, нам хочется сдвинуться на какую-то вот
такую штуку. То есть, нам сказать, что хочется сдвинуться на куда-то, на какую-то P плюс,
там P штрих, допустим, да? Хочется как-то вот сдвинуться на P плюс P штрих, какой-то,
то есть гарантировать, что между P и P плюс P штрих подходящих вот этих штук точно нет. Вот,
но что мы здесь делаем? Здесь мы делаем, на самом деле, смотрите, интуитивно, вот здесь надо
заметить важную вещь, что когда мы проверяем вот этот вот ритч, мы по сути ищем вхождение строки
V в самой себе, правда? В самой себе. Ну, смотри, ну, когда мы, то есть, по сути, когда мы тут ищем
ритч, мы прям вот этот символ сравниваем с первым символом строки P, вот этот со вторым,
этот с третьим и так далее, пока совпадают. То есть, по сути, это вот раньше мы делали то же
самое, когда искали строку R в строке S, да? То есть, по сути, у нас теперь задача, ну вот, то есть,
у нас теперь примерно то же самое, то есть, мы пытаемся, то есть, по сути, мы пытаемся найти
вхождение строки V в самой себе. Ну, что-то типа Z функции насчитать, правда? То есть, просто идея
такая, то есть, идея такая, то есть, мы хотим найти вхождение, то есть, совпадение с префиксом,
у подстроки с префиксом, причем префиксом достаточно длинным. Тогда, смотрите, вот это должно быть
префиксом. И тогда, чтобы нам было интересно, потому что, если мы сдвинем позицию P вправо,
то требование на Q должно быть еще больше, да? А отсюда следует, что вот это, то есть, смотрите,
то есть, вот это префикс строки V и вот это тоже префикс строки V. Ну, чтобы нам хотя бы интересно
было, точнее, он должен претендовать на это. То есть, получается, значит, P штрих, ну, то есть,
получается, вот этот двиг, то есть, в идеале хотелось бы, чтобы, ну, вот, что здесь хочется,
в идеале хотелось бы, ну, совсем в идеале, чтобы P штрих был равен shift, конечно, от чего, от Q. Вот
в идеале можно было бы делать так, тогда бы Q вправо не двигалось. И тогда мы бы все успешно
делали, правда? Да, да. Ну, это в идеале.
Мы хотим, чтобы все вот это вот было префиксом, точнее, да, префикс, с P до P плюс Q префикс.
Самое главное, с P плюс P штрих до P плюс Q префикс. То есть, вот это префикс, ну, в идеале хотелось бы,
чтобы это было префиксом, да? Ну, то есть, если мы хотим, чтобы это было, ну, вот, то есть, как бы
интересным префиксом, то есть, на самом деле, интересной позицией является только то, что, хотя,
что ничто не противоречит тому, что это, что здесь, что вот это могло бы быть префиксом.
Так, да, а если это оба префиксы, то получаем, что... Ну, это минимально, чтобы было шифт,
потому что идея... Если это оба префиксы, то, в частности, второй префикс, первое, и вот этот вот зазор, это шифт.
Ну, да. Ну, в идеале хотелось бы. Но проблема в том, что этого шифта мы, естественно, не знаем,
но знаем, как всегда, другое. Мы знаем, что я утверждаю, что шифт V от Q, он будет заведомо больше,
чем Q делить на K. Да ладно. Все догадываетесь, да? Как бы мозг в этом случае должен уже стандартный
шаблон подставлять, да? Ну, либо, ну, либо стандартно ссылаться на L1, либо подставать
стандартный шаблон, который ее, по сути, доказывает. Если у нас уже есть... Но там говорилось бы так,
что, предположим, шифт оказался меньше, да? Тогда тут, оказывается, есть четыре периода. Ну,
там шаблон почти такой же. Он говорит так, что тогда это является префикс, то есть это как бы
префиксный период, но тогда в том числе и префиксный период строки V, причем меньшей длины. Ну вот,
а мы его пока не нашли. А мы его типа пока не нашли. Ну вот, да. То есть, да, смотрите,
то есть обратите внимание, то есть нам плевать, сколько V префиксных периодов, нам главное,
что пока мы не нашли первый, как бы на той части строки, где мы работали, его не было. Мы это
достоверно знали. Поэтому как бы приятная новость для нас, приятная новость для нас заключается в том,
ну вот, заключается в том, что первый нод, что, оказывается, мы, если у нас минимальный,
ну, если префиксного периода нет вообще, то мы за O от V это поймем. А если префиксный период
есть, и он равен, допустим, P1, то я утверждаю, что мы его найдем, причем за O от P1. Ладно,
формально умножить на K. Но K это константа, поэтому нам неинтересно. Неплохо, правда?
То есть, в принципе, когда у нас, получается, в теореме декомпозиции желательно, то есть просто,
если нам дадут вот эти УВ, и гарантируют, что у нас не более одного префиксного периода,
то мы в принципе этот префиксный период уже найдем. Ну, по сути, да.
Хотя, на самом деле, честно скажу, при поиске само разбиения мы эту логику тоже будем учитывать,
то есть, поэтому я ее не столько для того, что она, то есть, как бы нам пригодится сама логика,
а не непосредственно этот алгоритм. Хотя, нам пригодится, знаете, какой алгоритм? Нам
пригодится более сложный алгоритм. Как найти два минимальных префиксных периода?
Нет, ну а что не так? Ну, допустим, более того, мы ровно тем же алгоритмом найдем первый
префиксный период. Так вот, допустим. Так, ну теперь давайте посмотрим. Да, мы можем, конечно,
это аккуратно... Да, но заметим следующее, что если... Да, то есть, смотрите, тут фишка такая. Вот у нас
тут был алгоритм, который когда мы работали в предположении, что строки R, ровно один префиксный
период. По сути, на самом деле, можем применять ту же саму идею, пока мы не нашли второй префиксный
период. Правда? Ну, давайте так. Хорошо. Так. Значит, смотрите. Так. Ну, тут эти красоту тут навести
так. У меня уже такой соблазн. Вот эти определения можно стереть? Блин, я на них постоянно смотрю.
Хорошо, не буду. Ладно. Ну да. Так, господи. Знаете, мы на Саше Бабина две доски из
другой аудитории тащили. Ух ты. Там он писал какие-то стрёмными маркерами, которые через час и акция
всю доску загадили. А, поэтому, да. Поэтому мы принесли две другие и делали... И их тоже загадили. Нет. Нет, ребята. Нет, самое...
Нет, знаете, самое грустное на самом деле был интересный момент, потому что вот когда я год
назад это читал, как-то это было в аудитории 9244, но это менее принципиально, более принципиально,
что там было две доски. Это было так удобно, что на одной доске пишутся все определения илемы, а на другой
собственно мы и тут работаем. А тут мы немножко упихиваемся. Правда, тут есть преимущество, там как бы
на камеру две доски не помещались. Да. Ну, там было легче, потому что там камеру никто не таскивал. Там
сидел Антон Садович и снимал всё на свой айфон. Ну вот. Так. Хорошее качество, кстати, было. Ну,
можете сами посмотреть. В общем-то там лекции-то никуда не делись. Вот. Соответственно, да. Вот. Да,
хочется сказать, я там был ещё молодой. Нет, Антона там не было. Нет, показывали там, в основном,
только меня. Ну, почему? Ладно, насчёт меня это на самом деле шутка, потому что выглядел я там
буквально так же. Вот прям буквально. Прям с точностью до одежды. На самом деле. Ну, это год
назад было чего. Вот, отлично. Так вот. Значит, смотрите. Давайте сначала. Итак. Смотрите. Жила была
строка В. И мы запускаем наш вот этот механизм, который ищет префиксный период. Ну, там вот. Ну,
в идеале нам что? Как мы искали штуку для нас минимальный префиксный период? Мы хотели найти
такое П, что Рич от П больше либо равно, чем К на П. Правда? Или там К-1П, как мы там Рича
определили? А, ну да, КП. И вот, допустим, мы её нашли. Вот такой вот П1. То есть этот наш алгоритм
шёл-шёл и дошёл до П1, где вот это вот П плюс К оказалось, П1 плюс К оказалось больше либо равно,
чем КП1. Ну, теперь вот вгибание вопрос. Как вы думаете, теперь мы должны найти ещё
какой-то... Теперь мы должны найти такое П2, которое больше, чем П1, так, чтобы П2 было
префиксным периодом. Давайте подумаем. Какие условия нам нужны для того, чтобы сказать,
что какое-то П2 нам подходит? Вот. Что это за второй префиксный период? Ну, как минимум,
конечно, нужно, чтобы... Да, что ж ты будешь делать? Как минимум, нам нужно... То есть шифт В от П2 на
самом деле был больше либо равно, чем КП2. Так, ладно, только не шифт, а, пардон, Рич. Хотелось бы,
да? И, конечно, но при этом хотелось бы, чтобы П2 было больше, чем П1. Так, действительно. Ещё
логичнее, да. Так, скажем так, это необходимые условия, но достаточно или... Вот. Ну, тут надо
смотреть. Потому что, смотрите. Потому что... Ну, смотрите, давайте... Ну, на самом деле так. Мы же,
в принципе, можем вот этот алгоритм продолжать. Что? Если у нас будет П1 повторён 8 раз,
то 2П1 мы подумаем, что это П2. А это не базовая строка. Ну, вот. Это давайте прям точно ли не
базовая? Ну, 2П1 не базовая строка. Ну, 2П1, конечно, не базовая строка. Это правда проблема. Да,
не то есть... Ну, у нас тут ломается разумзение, что префикс... Ну, короче, про базовость ломается,
что она автоматически строк. Ну, понятно, понятно, да. Нет. Но давайте смотреть. Да,
круто. Ну, то есть, смотрите. Там действительно до какого-то... Ну, то есть, на самом деле,
тут идея такая. То есть, давайте так, продолжим тот же алгоритм, что мы делали раньше. То есть,
по сути, что нам нужно. Ну, до какого... То есть, мы говорим, что алгоритм, по сути, занимается тем,
что ищет все такие позиции p, что rich от p больше либо равно, чем kp, правда?
Точнее, ну пока какие-то ищут. Вот мы нашли сейчас самую первую. А давайте
продолжим этот же алгоритм. Только единственная разница будет в том, что если
раньше мы говорили, что shift это точно хотя бы q поделить на k, поэтому просто
сдвигаем, обнуляем q и не паримся, то теперь у нас, как у нас и в этой
части могут быть проблемы. Проблема могут быть связаны с тем, что как бы shift на
самом деле может оказаться меньше, чем q делить на k, но у нас фишка в том, что
этот shift в этом случае обязан быть равен ровно p1. Помним, да? То есть у нас вот
этот алгоритм базировался на том, что если у вас пока у строке есть только
один префиксный период, пока у вас есть в строке
только один префиксный период, мы гарантируем, что shift у нас только один
и он равен p1. Правда, да, тут вытекает, конечно, вопрос, а может быть вот в этой
вот строке на самом деле уже префиксный период достаточно маленький. То есть может
окажется, что даже четыре строки p2 на самом деле сюда вкладываются,
что вот этот префикс может быть очень длинным. Вдруг вот четыре копии p2 даже
сюда прекрасно вкладываются, ведь вот эта q может быть очень длинным, она же
не обязана быть ровно 4p1. То есть по нему мы только знаем, что оно больше
либо там больше либо равно, чем 3p1, но насколько больше мы не знаем.
Если p2 меньше, чем q делить на k, то кажется это будет несколько раз повторенный p1.
Ну пока да. То есть более того первое, что мы скажем, то что вот у этой строки shift он
заведомо p1, правда. И более того, и более того заметим следующее, смотрите, что shift
так не равен ровно p1, ну других там, то есть там других шифтов у нее очевидно нету, но тогда
если мы тут сдвинули на p1, то тогда мы получаем здесь снова нот, то есть тогда мы получаем
действительно снова p1, там, периодичную какую-то строчку. То есть в принципе есть
подозрение, что пока эта строчка не станет достаточно маленькой, то, наверное, мы просто
тут на p1 можем честно сдвигаться. То есть дело в том, что дальше у нас все равно shift станется
таким, но дальше он просто не сдвинется. Почему так? Потому что получается, что раз вот эта
вся строка была p1 периодично, а мы тут сдвинулись ровно на p1, то есть сказали,
что вот это вот 2p1, то по крайней мере поначалу будет оказываться, что мы этот символ будем
сравнивать с абсолютно тем же символом, что и раньше. Понимаете, да? Ну вот, то есть с каким-то
тем же. Поэтому получается, что до некоторого момента будут проблемы. Другой вопрос,
а какие условия у нас были для того, чтобы гарантировать, что у нас shift будет ровно такой?
Достаточно короткая, потому что сейчас у нас для того, чтобы гарантировать,
что shift только либо p1, либо qdelete на k. Пока нам требовалось, чтобы p1 мог на это претендовать,
у нас тут было условие, что это у нас хотя бы 4 копии тут есть. Может быть тут и 5, и 6, и так далее.
Ну да, да, да, 3, хорошо. Ну хорошо, 3 копии точно. Вот так давайте, хорошо я нарисую. Да, 3 копии.
Да нет, нормально. Так, вот, то есть жили были вот такие 3 копии, с ними все в порядке. Ну вот,
ну хотя тут действительно отдельная песня, потому что в принципе, то есть на самом деле,
если этот p1 оказался больше, чем qdelete на k, то в принципе уже можно на qdelete на k сдвигаться,
потому что все равно других шрифтов типа нет. Ну скажем так, с одной стороны мы ничего нового,
ну скажем так, ну давайте так, с одной стороны мы ничего нового не откроем, с другой стороны мы
как бы shift будем точно знать. То есть если это был shift, p1 это shift, то мы в принципе q уже знаем,
что оно вот такое и в принципе можем продолжить за линию. Другой вопрос, что копий тут может
быть настолько много, что здесь этот reach тоже может быть там больше, чем k на вот это вот. Такое
вполне, ну вот, то есть действительно такое у нас теоретически вполне может быть.
Вот, но другой вопрос, что мне почему-то все равно очень хочется утверждать, что не может быть так,
что самое главное для нас, что на самом деле kp2 вкладывается вот в это вот, по 1 плюс q.
Ну в принципе вообще у нас когда-то было верно маленькое утверждение,
что если у нас есть два разных префиксных периода, то эти префиксные периоды отличаются
друг от друга хотя бы в k-1 раз. Когда-то давным-давно такое утверждение было. Почему оно было?
Почему именно k-1, кстати, а не k? Ну вот нет, на самом деле идея очень простая. Нет, потому что там
просто идея была такая, что допустим у нас есть какой-то префиксный период p2, который длины
меньше чем 3p1. Тогда у нас оказывается, что там хотя бы строка длины вот этой вот, там p2
плюс p1, она и p2 периодично. Вот, то есть вот так вот, и еще вот так вот, и вот так вот, типа p2
плюс p1. То есть оказывалось, что это строка и p1 периодично, и p2 периодично. Следовательно,
она гцд от p1 и p2 периодично. Следовательно, как минимум вот эта строка не базовая до свидания.
Понимаете, да? Вот, поэтому в принципе отсюда можно сделать вывод. То есть отсюда можно
действительно сделать маленький приятный вывод, что p2 имеет смысл искать только, ну как минимум,
начинает с k-1 на p1. Это как минимум. А как максимум, на самом деле, ровно по этой же причине. Я
утверждаю, что p2 имеет смысл искать, начиная, ну то есть такие, утверждается такое. Скажем так,
во-первых, то есть так, p2 должно быть больше либо равно, чем k-1 на p1. Это я уже могу сказать. А еще
я могу из тех же утверждений утверждать, что p2 должно быть больше либо равно, чем, знаете,
что? Чем вот эта вот старая q? Даже я бы сказал, строго больше, чем q. Да, q это длина вот этой строки.
Ну то есть вот это минус p1. Если у меня p2 будет где-то, то есть если p2 будет заканчиваться хотя бы
на p1 раньше, чем вот этот речь, то рассуждение будет абсолютно то же самое. Ну типа того. Вот,
ну то есть, нет, ну да, то есть применяем ГЦД радость. Так вот, так вот, идея такая. Так давайте
вот с какого-нибудь, да, с какого-нибудь максимума из вот этого и этого и начнем.
Или просто начнем с максимума из, ну или может быть просто надо сказать, что p2 давайте с q и
начнем и просто с нуля. Так вот, хочется, но просто чем это приятно? Это приятно тем, что если мы
возьмем такое достаточно большое p2, то kp2 заведомо закончится позже, чем здесь, правда?
Нет, вот изначально-то у нас этого не было, мы из-за этого в общем-то и страдаем. То есть просто
начиная с какой-то позиции там, то есть как бы есть тут периодов не 3, а 33, то как бы 2п1 нам
тогда вот с точки зрения вот этого речи подойдет 3п1 подойдет, что угодно подойдет. А мы и хотим,
чтобы оно подходило. Но если мы стартуем, что p2 это хотя бы, извиняюсь, просто там p1
плюс q и минус p1 еще, там плюс p, то уже заведомо тогда 4 штуки, то есть даже уже вторая копия p2
уже за пределы этого префикса выйдет, правда? Но теперь хочется утверждать следующее. Так давайте
начиная с этого момента искать себе действительно вот эту штуку ровно по этому механизму,
да? И тогда утверждаю, что если мы начиная с этого момента найдем там какую-то вот,
начиная с этой позиции, начнем какую-то вот какую-то там позицию x, что рич у нас от x будет
больше либо равен 4x, то я утверждаю, что этот x как раз вторым префиксным периодом и станет.
Так, ну пока мне хочется, я еще пока не понял, почему это так.
Так, ну давайте еще рассмотреть, да, то есть давайте вот начиная с этого момента, то есть
хорошо, вот p1 у нас какой-то префиксный период есть и вот оно вот, давайте вот сейчас еще раз
отрушу, чтобы тут было красиво, то есть давайте думать, что у нас тут могло теперь быть. А тут я
могу хоть вот так вешать. Так, еще раз, рич от p, то есть жила было p1, он был какой-то маленький,
и вот мы искали-искали и нашли какую-то вот мистическую позицию, вон тут далеко x,
что у нее тут вот 4 копии нашлось, вот и x причем достаточно большое, то есть настолько большое,
что как бы 3 копии p1 точно в этот x умещаются, да, и даже в рич это все умещается. Вот вы текаетесь
первый вопрос, нашли такой видимо минимальный x, возникает вопрос, верно ли, что этот x базовый,
ну вот, то есть что вот это минимально, ну вот, ну давайте смотреть, потому что если x оказался
не базовый, то значит у нас тут где-то что-то типа то ли x пополам, то ли x поделить на 3,
в общем первое вхождение было какое-то сильно раньше, но единственная у нас проблема, что мы
его могли попытаться приноть, но что это за база могла быть, что это за база могла быть,
вот здесь уже не просто работает, что у нас других прификсных периодов нет, да,
но вот теоретически да, теоретически это вполне может быть, вот, а почему, потому что если не
базовая, значит есть какой-то период, так и есть его период, его период, его период, да, ну возьмем
короче, давайте, хорошо, возьмем минимальный, ну как всегда, возьмем минимальный, возьмем
минимальный период x, он точно базовый, но скажем так, ну вот, ну что это может быть, действительно,
что это может быть, нет, скажем так, вопрос, кстати, сколько у этих x будет этих копий одинаковых,
если этих копий одинаковых хотя бы четыре, нет, вот уже внутри самого x есть, как бы сам x это
четыре копии одного и того же или больше, тогда длина этой копии, ну вот, тогда длина этой копии
может быть чем, ну тогда что-то очень хочется сказать, что больше чем p1, потому что кроме как
p1 она ничем быть не может, ну вот, ну да, то есть действительно, если она, ну как кратно, ну вот,
кратно p1 она, ну да, ну да, то есть это тот период, он не может делиться на p1, потому что тогда,
во-первых, тогда понятно, что просто p1 это просто период этого префикса, причем на целый делящийся,
и тогда получается, что x тут у нас, то есть x в этот reach входит, а мы x брали достаточно большим,
чтобы он тут как бы в этот reach, ну то есть в reach может быть и не входил, точнее так, x может
входить в reach, но x умножить на 4 полностью в reach не входит, поэтому тогда получается,
что если этот меньше период есть, то он как бы получается не p1, то есть видимо и не кратен p1,
значит, следовательно, ну вот, ну вот, но так как x у нас как минимум 3 p1, то тогда получается,
что этот префикс у нас gcd от p1 и чего-то там еще периодичен, и тогда получается,
что мы нашли меньше период. Нет, наоборот, мы же уже, мы сказали, что x больше, чем 3 p1,
мы же только начиная с этого момента ищем, вот, то есть напоминаю, что у нас x, то есть что у нас
произошло, x, во-первых, больше, чем k-1 на p1, то есть те самые 3, и x больше, чем, по сути,
я так скажу, reach с индексом v от p1, минус p1. Вот. В общем-то, то есть вот это условие,
то есть это условие нам гарантистировано, что, то есть, допустим, мы нашли вот такой,
то есть такой минимальный x, допустим, мы нашли такой минимальный x, что верно, вот это условие,
это условие, и reach оказался от x больше либо равен, чем kx. Вот утверждается, что если мы такой
минимальный x случайно найдем, минимальный, то он и есть второй префиксный период, а до этого
момента никаких префиксных периодов, кроме охраня p1, не было. База очевидна, потому что мы
уже знаем, что вот в этих позициях не превосходящих вот этого, вот никаких других префиксных периодов
по-любому нет. Помним, да? Помним, да. Отлично. Есть у нас теперь reach, есть у нас minimum,
есть радость. Что у нас теперь еще есть? Значит, идем теперь на vx. Вот, то есть теперь мы говорим,
что фактически, что нам нужно доказать? То есть нам нужно, по сути, доказать, что вот эта строка
базовая. Хотим мы это доказать? Хотим. И теперь говорим, что пусть она не базовая, то есть пусть
неожиданно выяснилось, что v от 1 x равно, на самом деле, какой-нибудь там t в степени l, где l больше
одного. Тогда, смотрите, тогда отсюда следует, что в принципе вот это вот v от 1 делить на x,
она p0. Ну, что при нее тогда можно сказать? Ну, как минимум, она модуль t периодично. Так, то есть
она модуль t периодично. Что, какой из этого можно сделать вывод? Ну, на самом деле, да, то есть
нельзя сказать, что вот это строка не обязательно p1 периодично, потому что x может быть совсем
больше. Но, вот. Но, в чем она? В чем у нас тогда может быть противоречие? Ну, допустим, вот,
Ну, то есть, модуль Т периодично, казалось бы. В чем проблема?
Не, но если модуль Т сам, если Т само удовлетворяет вот этим условиям, то противоречит тем, что мы нашли минимальный х.
Угу. Так. И что? Ну, хорошо, допустим, модуль Т... Дам.
Конечно, тогда, допустим, тогда модуль Т не удовлетворяет этим условиям, что...
Вот. Если он удовлетворяет, то...
Так.
Ну, то, то будет, то Т плюс П1.
Ну, такие давайте...
И Т периодично, и П1 периодично.
Так. Ну, там как повезет. Может, еще Т достаточно маленькая, кстати.
Ну, оно хотя бы...
Ну, точнее так. Давайте так. То есть, давайте так. Модуль...
То есть, смотрите, давайте так. Модуль Т удовлетворяет вот этому условию, да?
Ну, вот этому-то оно точно удовлетворяет?
Ну, так.
Модуль Т?
Да. Модуль Т удовлетворяет вот этому условию.
Ну, если вместо х подставить модуль Т.
Ну, потому что если тут 4 копии х и сам х делится на Т, то само Т тоже там 4 копии.
Там даже 4... Там 4 умножить на... Там х делить на Т найдется.
Вот.
Ну, значит, тогда получается...
Если Т меньше, чем П1, то, причем, речь о с выбором П1.
Ну да.
Заметим. Да.
Что да?
Тогда, значит, модуль Т больше... Давайте пишем. Больше, чем П1.
То есть, там больше либо равно П1.
Ну, вот. Иначе...
Иначе Т было бы...
...прификсным периодом.
Вот. Так. Хорошо.
Ну, с другой... Так. И что?
С другой стороны, да. Заметим, что модуль Т не равно П1.
Вот так скажем. Да?
Почему?
Потому что наша... Ну, иначе у нас вся эта строка П1 периодично.
Ну, вот.
А мы уже вылезли по определению.
Ну, вот. Иначе...
Ну да. То есть, иначе...
Иначе, значит...
То есть, иначе, на самом деле, оказывается, что...
Действительно, это Т нот.
То есть, у нас эти 4 Х оказываются в речи от П1.
То есть, иначе КХ нот.
Иначе получается КХ меньше либо равно речь от П1.
С индексом. Да.
Ну, вот.
А это невозможно.
А почему это невозможно, кстати?
Что именно невозможно?
Ну, почему невозможно, что КХ...
Почему не может так оказаться, что КХ меньше либо равен, чем речь от П1?
Это у вас в условиях? А, нет?
Нет. У меня в условиях написано немножко другое.
Короче говоря, вы взяли Х так, чтобы его 4 вхождения вылезали за пределы.
Угу.
Ну...
Нет, ну да.
Ну вот.
Так, ну да.
Но заметим, что...
Уже два вхождения Х вылезают за пределы, и с первых двух не нравится.
Ну да.
Ну да. То есть, заметим, что речь...
Ну, то есть, из этого следует, что КХ должно быть строго меньше, если верить этому условию, как Х плюс П1.
Да, то есть, из этого должно следовать, что П1 больше, чем, получается, Х умножить на...
Нет.
Ну, смотрите, у вас Х от К-1 на П1, и потом вы знаете, что Х больше, чем речь, минус П1.
Ну...
Очевидно, К-1 на П1 больше, чем...
Нет, давайте так. Х...
Значит, 2Х больше, чем речь П1.
Больше, чем речь П1.
Во.
А, впрочем, это неважно.
А, ну можно и так...
А, можно просто вот фейл с этим условием.
Я просуммирую эти условия.
Ну...
Ну можно, ну как угодно.
Ладно, это уже не так принципиально.
Так.
То есть, в принципе, да, Х...
Хотя нет, погодите.
Нет, Х меньше, чем П1 делить на К-1.
Но он должен быть больше, чем П1 умножить на К-1.
Даже так.
Ну, типа.
Да.
Ладно, ну в общем, как угодно.
Хорошо.
Модуль Т больше, чем П1.
Что это значит?
Так.
Ну еще, наверное, почему-то...
Ну еще, наверное, и так значит модуль Т больше, чем П1, как мы выяснили.
Да.
Так, я утверждаю, что еще модуль Т не делится на П1.
Ну...
Нет, вот это уже...
Хотя нет, вот это уже не так очевидно.
Не, ну потому что тогда Х тоже...
Потому что тогда Т не базовая.
Что?
Нет, не факт.
Нет, знаете, там как может быть?
У вас вот П1, П1, П1, П1, там любая бредятина, а потом П1, П1, П1, П1, любая бредятина.
Так, ну хорошо.
Сейчас, ну если Т делится на П1, а Х делится на Т...
Еще раз, Т меньше, чем К-1 на П1.
У нас пока ограничение на Т только...
Короче говоря, у нас Т не удовлетворяет условиям на Х.
Нет, погодите, пока мы доказали только то, что Т строго больше, чем П1.
Это все, что мы знаем.
Т не удовлетворяет условиям на Х, иначе у нас модулы Х.
Так?
Это мы тоже знаем.
Но если она не удовлетворяет условиям на Х, то она должна быть левее, чем reach В от П1.
Если она левее, чем reach В от П1, и делится на П1, тогда она просто П1 умножить на что-то.
Ну да, или у этой строки есть период меньше, чем П1.
Не, она не базовая.
Да-да-да.
Нет, ну Т, ну да.
А, ну да, можно было...
Ну вот.
Так, ну хорошо.
И так, модуль Т мы доказали больше, чем П1.
А еще мы говорим, что...
Ну вот.
Так, сейчас давай так...
Интересно, кстати, почему Т не удовлетворяет условиям на Х.
Да, если бы Т удовлетворяла эти условия, то мы бы в качестве...
То есть тогда противоречие с выбором Х.
Понимаете, да?
Вот.
Так, вы там это живы?
Хорошо.
И так, жил был модуль Т.
Но получается, единственное условие, которое мы доказали больше, чем П1.
Ну да.
Хорошо.
И так, жил был модуль Т.
Но получается, единственное условие...
Нет, хотя подождите.
Каким условием это действительно может нарушать?
Какие условия могут нарушать?
Так, это условие точно выполнено.
А вот какие-то вот эти условия как бы уже не факт.
Я не понимаю вопроса.
Слишком.
Слушай, ну мы скажем так.
Учитывая там длинную цепочку, мы сейчас глобально ищем второй префиксный период.
Мы доказываем, что Х не будет.
Мы доказываем, что Т не делится на П1.
Мы доказываем, что Х базовая.
Нет, мы хотим так.
Мы, допустим, мы нашли какой-то такой минимальный Х, удовлетворяющий вот этим условиям.
Вот этим, точнее, просто вот, минимальный Х, удовлетворяющий этим условиям.
Мы пытаемся доказать, что Х это и есть второй префиксный период.
Ну тогда пусть есть такое Т, тогда, тогда, тогда.
Точнее, да.
Для начала мы доказываем, что...
Ну то есть, точнее так.
Единственное, что мы доказываем, это то, что Х базовая, по сути.
Что Х базовая.
Это все, что нам надо.
Мы говорим, так пусть у нас Х оказалась случайно не базовой.
То есть она оказалась там Т в степени L, L больше 1, в чем, естественно, L мы берем максимально возможно.
А T максимально маленькая.
Мы показали, что T больше, чем P1.
Вот.
Значит, заявили мы.
Еще мы утверждаем, что T не удовлетворяет вот этим условиям.
Точнее, одновременно всем трех не удовлетворяет.
Потому что иначе бы мы противоречили с выбором Х.
Но следовательно...
Но смотрите, но так как Х удовлетворяет вот этому условию,
то, очевидно, вот это Т тоже будет удовлетворять этому условию еще и с большим запасом.
Правда?
Да.
Следовательно, они удовлетворяют кому-то из вот этих условий.
Угу. Все проще.
Вот.
То есть, по сути, получается, что T меньше либо равно, чем K-1 на P1.
Или модуль T меньше либо равно, чем reach от P1 минус P1.
Вот.
Но теперь хочется сказать, что с каждым из этих условий у нас получится и должно получиться какое-то противоречие.
Какое?
Ну...
Если мы к Т прибавим еще P1 символов,
мы все еще будем меньше, чем reach от V.
Хотя...
Давайте так.
Начнем с того, что какое-то из этих утверждений не верно.
Но заметим, что если...
Давайте так.
Заметим, что...
То есть, какое-то из этих утверждений точно верно.
Но заметим, что если вот это верно, то это точно верно, потому что reach от P1 больше либо равно, чем K-P1.
Правда?
Да.
Да?
Да.
То есть, в принципе, мы заведы...
То есть, в принципе, я тут...
Сорочу нас с выборочными условиями.
То есть, на самом деле, да.
То есть, в общем-то, по факту мы можем рассматривать только вот это условие.
Потому что вот это условие просто более сильное.
И так, значит, тогда мы его, значит, вот это мы не рассматриваем.
И просто говорим, жил-был вот этот reach.
То есть, модуль T оказался таким.
Вот.
Но тогда из этого я могу сделать вывод.
Тогда, значит, из этого всего я делаю такой вывод.
Что префикс длины модуль T плюс P1, P1 периодичен и модуль T периодичен.
Ну, модуль P1 периодичен ровно вот по этой...
Ну, вот.
То есть, ровно вот по этой причине.
Потому что вот эта строка входит в reach от P1.
А модуль T периодично.
Ну, просто потому что на самом деле у нас как минимум две копии T в начале строки V существует.
Вот.
Но тогда из этого следует что?
Тогда из этого следует, что у нас...
Тогда вот эту нот.
Тогда у этого V есть...
То есть, тогда у нас тут есть период у T и P1.
То есть, у T есть период GCD от T и P1.
Но в принципе это уже противоречие.
Потому что тогда сама противоречие даже не с базовостью строки P.
Там P1 вот этой.
А с базовостью строки T.
То есть отсюда в принципе автоматически следует, что V от...
Да, тут 1 T.
Она, оказывается, нот от модуль T запятая P1 периодично.
И этот период он строго меньше, чем T.
С одной стороны он строго меньше, чем T.
С другой стороны является делителем модуль T, потому что это GCD.
Вывод какой?
Вывод тогда получается, что T не базовая.
А если бы мы вот эту L взяли как можно больше, она была бы базовая.
А можно и по-другому сказать, что мы же L взяли как можно больше.
А вот эта GCD означает, что мы эту T можем саму распилить на одинаковые копии.
И тем самым там L увеличить.
То есть, вывод.
Мы действительно ищем минимальное такое X.
Большее.
То есть, начиная с какого-то момента ищем минимальное такое X.
Удовлетворяющие.
То есть, минимальное такое X, вот начиная с этого момента.
Что L больше ли брал, чем KX, это и будет второй перификсный период.
Доказали, да?
Так, ну что ж.
Нет, смотрите.
Перерыв, я думаю, имеет смысл сделать после того, как мы убедимся.
Теперь еще и поймем, видимо, более простую часть.
А как теперь этот X найти?
Я хотел есть подозрение, что самую интеллектуальную часть мы сделали.
Ну, сдвинуть и вот это.
Ну, то есть, решение такое, что давайте, мы говорим так.
За O от P1.
Ну, где-то за O от P1K мы вот это нашли.
Ну, на самом деле, за O от Richard P1 мы теперь можем и сам Richard P1 найти, правда?
Можем?
Вот, нашли.
И теперь давайте стартуем.
То есть, алгоритм теперь так.
Начинаем, стартуем с позиции вот этой плюс один.
И начинаем абсолютно в тупую искать абсолютно нот.
То есть, просто искать вот эти вот Q.
То есть, двигать их абсолютно так же.
До тех пор, пока не найдем такое Q, которое оказалось равно 3 умножить на свою очередную позицию.
Как мы это будем делать?
Ну, собственно, ровно тем же способом.
Потому что, да?
То есть, давайте вот еще раз.
Так, ладно, в утверждение мы уже поверили.
Поэтому давайте я сейчас все это сотру.
И вот.
Так.
Вот оно, вот оно, вот оно.
Так.
Не-не-не.
Так.
Так-так-так.
Так-так-так.
Вот так вот.
Значит, логика.
Итак.
Начиная с этого момента.
То есть, где-то у нас там был какой-то очень далекий P1.
И вот мы тут.
То есть, как бы алгоритм звучит так.
То мы опять ищем какой-то P.
То есть, ищем P, который больше, чем вот это.
И ищем Q.
Прям вот в тупую.
Вот прям P плюс Q, чтобы оно вот совпадало.
Как только Q станет равно 3P.
Мы говорим, что ура, мы победили.
Вот как мы только что доказали.
А что делать, если Q оказалось меньше?
Ну, тогда идея опять такая же.
То есть, надо.
То есть, получается, надо сдвинуть P так.
То есть, как-то вот сдвинуть так.
Чтобы опять получить какой-то P плюс P'.
Так, чтобы, если я тут буду делать речь, то мы могли дойти хотя бы до сюда.
Вот.
Ну, логика опять была такая же.
Но тут возникает вопрос.
Что?
Ну, опять у нас, конечно, в идеале была бы мечта.
Что давайте P' это просто Q делить на K.
Потому что, типа, раньше никаких сдвигов не будет.
Но у нас опять та же логика.
Логика говорит.
То есть, логика говорит, что в принципе этим сдвигом.
Вот, что в некоторых случаях окажется, что сдвигом может быть вполне себе и P1 на этот раз.
Ну, точнее так.
Давайте так.
Какие сдвиги?
Ну, то есть, какие у нас могут быть проблемы?
Что нам мешает просто сказать, что это P плюс Q делить на K и не париться?
Какие проблемы могут быть?
Единственное.
Давайте вот просто опять повторяем те же самые рассуждения.
Но тут надо их повторять, чтобы их привыкнуть.
А теперь давайте думать.
Вот, допустим, вот это P плюс Q делить на K.
Теперь давайте думать.
Давайте думать.
Может же так оказаться, что на самом деле shift от Q.
По сути, shift от Q оказался вполне себе меньше, чем Q делить на K.
Правда?
Могло такое быть?
Могло.
Ну, теперь давайте подумаем.
А shift такое?
Так.
То есть, замечаем, что этот shift, это такой shift, что у него.
То есть, этот shift обладает таким свойством, что 4 копии этого шифта в Q вкладываются.
Следовательно, это префиксный период.
Но с другой стороны, у нас на текущий момент, скажем так, получается, меньше P1 это быть точно не может.
Потому что мы знаем, что меньше P1 у нас такого безобразия нет.
Ну вот, может быть, сам P1?
Да.
Вполне может быть.
А может быть, это больше, чем P1?
Что больше, чем P1?
Вот этот вот shift оказаться больше, чем P1.
Это может быть делитель, кажется, кратный P1?
Нет.
Ну, с одной стороны, да.
Ну, ничего страшного.
Нет, ну там просто фишка будет в том, что это делителем, кратно P1 она будет...
Ну, хотя нет.
Может, делителем P1 тоже, может быть, там же никто не сказал, что периодов будет ровно P.
Фишка будет в другом.
Фишка будет в том, что если это есть, то мы тогда, получается, в это...
То есть, если это будет больше, чем P1, то тогда получается, что это было уже префиксным периодом, который мы почему-то раньше не нашли.
А мы должны были его найти, потому что тогда вот в этой позиции...
То есть, когда мы рассматривали эту позицию, мы должны были там идентифицировать эту Z и победить.
А мы этого как бы раньше не сделали.
Просто вот именно что конкретно раньше.
Вот эту.
Да, но тут мы, конечно, еще в явном виде пользуемся, что Q у нас маленькая.
Потому что теоретически P1 могло оказаться и больше, чем даже P.
В смысле?
Ну, теоретически.
Нет?
Да, практически нет.
Вот именно потому, что Q маленькая.
Ну, Q меньше, чем 3 делить на P.
Как могло P1 оказаться больше, чем P?
Ну, если бы Q было очень...
Ну, как бы это...
Ну, как бы...
Мы ищем P, а после P.
Нет, ну да, подождите, мы же P, мы же очень сильно вправо отодвинулись.
Мы взяли reach P1-P1, плюс 1.
И?
Ну, мало ли.
В плане, мы ищем вправо вот P1, P.
Оно всегда больше, чем P1.
Нет, от Q, может быть?
Нет, ну Q...
Нет, про Q мы знаем только одно, что Q меньше, чем 3P.
Все.
Да.
Но тогда мы в принципе...
Ну, из этого мы раз Q меньше...
Ну, то есть P плюс Q меньше, чем 4P.
Ну, из этого следует автоматически, да?
Ну, что из этого следует?
Что вот этот вот шифтик, я имею в виду шифтик, он должен быть меньше, чем вот эти 3P поделить на 4.
То есть получается меньше, чем P, да?
Это важно.
Потому что, чтобы сказать, что мы как бы...
Потому что у нас цель какая?
Сказать, что если тут был какой-то вот эта штука, то мы ее должны были найти раньше.
Ну вот.
Но для того, чтобы доказать, что мы это могли найти раньше, мы должны доказать, что этот шифт обязан быть меньше, чем P.
Вот.
Но мы и показали, что такой шифт должен не превосходить.
Получается...
Что там он не должен происходить?
Получается там трех четвертей P.
Но с другой стороны, как мы выяснили, тогда в этом случае он как бы больше, чем P1.
То есть получается больше, чем P1 в этом предположении он быть не может.
Потому что мы тогда его действительно раньше нашли.
То есть получается вывод...
Ну вот.
То есть тогда вывод...
То есть меньше он быть не может, больше не может быть.
Значит получается единственное, к чему может быть равен шифт меньше, чем Q делить на K.
То есть Q делить на 4.
Это, собственно, P1.
Остается только проверить, не является ли у этой строки шифт действительно P1.
А как это проверить?
Ну, совсем в тупую нельзя, но просто мы же можем сказать, что верно ли, что ричи от P1 больше ли равен Q.
Да или нет?
Мы же ричи уже нашли когда-то.
Да.
Потому что это сам префикс.
Да.
То есть вот и вся идея.
Да.
Ну, все, ура.
То есть вывод простой.
То есть получается в этих случаях надо проверить, что если P1 оказалось меньше либо равно, чем Q делить на K, то просто проверяем, можно ли сдвинуться на P1.
А вот понять, зачем нам это нужно?
Нет.
Это нам нужно было для того, чтобы найти второй префиксный период.
Ну да.
То есть в сухом оставке говорим так, мы можем найти, то есть скажем так, мы можем за O от V проверить, есть ли тут хотя бы два префиксных периода.
И более того, если есть два префиксных периода P1 меньше, чем P2, то мы сделали это за, я утверждаю, от P2 умножь на K, то есть от P2.
Вот.
Это все, что я.
То есть вот на самом деле, что мы сейчас достигли.
Это на самом деле будет значительная часть нашего.
Подождите.
Жду.
Рич мы за сколько считаем?
За, ну рич от P1 мы считаем за O от рич.
Прям буквально.
Ну а это может быть вся строка.
Может.
Ну то есть, ну типа нам тут ничего не дает вот это вот.
Дает, дает, дает.
Знаете почему?
Потому что мы знаем, что второй префиксный период, он должен быть хотя бы вот столько.
Нет, нет, нет.
Нет, нет, нет.
Я имею в виду, что у нас суммарно алгоритм работает за O от В.
Нет.
Да.
А рич как?
Если мы нашли два P1 и P2, то утверждается, что P2 по длине всего он порядка ричит P1.
Нет.
Рич от P1 за сколько ты находишь?
Если я на P2, то я его нахожу не больше, чем за P2.
Если P2 есть.
То есть смотри, если у тебя есть P2.
Ну по сути следующее.
То есть по сути алгоритм у тебя останавливается в тот момент, когда ты нашел P1.
То есть ты, когда алгоритм у тебя, предположим, что P2 есть.
Тогда что сделает твой алгоритм?
Он найдет P1, потратит на это, найдет за рич.
То есть за O от P1 он найдет P1.
За O от рич от P1 он найдет рич от P1.
Потом стартует с этого момента.
А этот момент, напоминаю, как минимум 3 четверти P1, кстати.
Ну, потому что рич это как минимум 4 P1.
Начиная с этого момента, он будет искать X и куда-то двигаться вправо.
Но как только он найдет X, от которого он вправо сдвинется, аж до 4X, он ровно в этот момент закончится.
Нам вот эта оценка принципиальна.
Что?
То, что мы написали, тут P2, а не V.
Это играет какую-то роль или нет?
Может сыграть.
Потому что мы...
Ну, потому что...
Ну, скажем так, в будущем алгоритме...
Нет, в будущем алгоритм у нас будет по сути...
Там будет заниматься чем-то типа, найди префиксный период и отпили его.
Чего?
Да, вот такое веселье.
Ну, потому что...
Ну, просто давайте подумаем.
Как эта терематика декомпозиции, в принципе, может быть доказана?
Она может там теоретически быть доказана, что...
Так, давайте думать.
Нет ли случайно у строки R префиксного периода?
Двух префиксных периодов.
Ну вот, тут мы начинаем думать.
Тут мы начинаем думать.
Так, давайте найдем эти два префиксных периода.
Будем искали-искали, и вот бабах!
В какой-то момент отсекли, нашли, что, оказывается, есть два префиксных периода.
И там идея может быть такая.
А давайте вот эту первую часть...
Просто отпилим эти четыре префиксных периода.
И у оставшейся строки V повторим операцию.
И так далее, и так далее.
Ну ладно, увидим.
Вот, примерно.
Конечно, там будет несколько не так, там будет похитрее.
Но суть будет примерно такая.
Так что вот получила нот.
Так что вот получилась такая красота.
Но, конечно, сейчас перерыв сделать уже время явно пришло.
Так, ладно, мы научились искать даже и один префиксный период, и два префиксных периода.
Спрашивается, зачем нам все это надо?
Ну, давайте вспоминать, зачем нам все это надо.
Так, ну что?
Ну что, интересно, идти в этом месте сначала или с конца?
Ну, как понятнее.
Как понятнее?
Ну, там, может быть, от перестановки мест сложаемых иногда бывает.
Ну ладно, давайте так, сначала так сначала.
Давайте попробуем теперь все-таки столкнуться с тем, на чем мы остановились в прошлый раз.
Так, да, тирема, декомпозицию у нас есть.
Так, мы на эти шифты продолжаем смотреть?
Ну...
Ладно, ладно, у меня наглая просьба.
Если вы хотите на них смотреть, фотографируйте их, пожалуйста.
Ну, они так-то и в тетради есть.
Ну, как бы на доске, конечно, удобнее.
Ну ладно, можно есть.
Нет, то просто, я не знаю, просто у меня ощущение, что если я буду вот это вот рисовать просто на верхней части доски,
по-моему, всем будет сильно виднее.
Нет?
Или всем по барабану.
Ну ладно.
Независимо от ответа.
Ну ладно.
Но в конце концов, я думаю, что такое базовая столка, что такое периодичная, что такое префиксный период,
я думаю, мы уже и так запомнили.
Как бы я думаю.
Если мы вот это еще вспоминаем, то понятно, что нам, конечно, титанически сложно.
Но я думаю, что мы уже, по-моему, уже эту схему более-менее выучили.
Нет?
Нет, ну...
Ну ладно, хотя я уже думал, что такое префиксный период,
что такое префиксный период, я думаю, мы все равно знаем,
что такое shift, в общем-то, интуитивно уже тоже.
Там всякие нюансы могут быть.
Ладно, Леммо я...
Ну вот, так, ладно, Ричи это, да.
Так, Ричи, да, кара в 0,4, мы, наверное, тоже помним.
Так, хорошо.
Просто на самом деле мы пытались,
то есть мы остановились в том, что мы пытались ввести
Леммо 3.
Леммо 3
говорила нам следующее.
Попоминаем, да?
Леммо 3 говорила,
что пусть у нас есть какое-то W
и это базовая строка.
Это важно.
Базовая строка.
Тогда
говорим мы.
Тогда неожиданно оказывалось, что
можно...
Тогда оказывалось, что, ну давайте так,
существует разбиение.
Там w равно
w1, w2
такой,
что
любая строка
вида там w2,
w1 в степени
k-1, w'
не имеет
префиксного периода.
Меньшего,
чем модуль w.
Вот такая заяла у нас.
Да, вот они
формулировали в таком виде.
Не,
а это тогда у тебя шо?
Че, у тебя
лемма 0 была?
Или
типа это утверждение ты пропустил,
как самоочевидно?
Да, я б не пропускал.
Это у меня вообще как лемма
не написано, но просто написано.
Понятно. Ну вот, ладно,
будем мыслить так. Итак,
значит откуда мы берем?
Значит такое счастье.
Так, ну давайте воспомним.
Мы в принципе уже начали как-то ее доказывать.
Потому что начали мы на самом деле с того,
что показали, что в общем-то
какое w' подставлять,
сюда в общем-то значение не имеет.
Попытались мы это доказать за счет
того, что этот префиксный период
со всеми k-копиями
видимо обязан
пропихиваться куда-то сюда.
Просто в w2,
w1 в степени k-1.
Почему?
Потому что там идея была такая.
Смотрите, вот у нас есть,
давайте я тут нарисую 4 копии w.
Мы доказываем математическую лему.
И вот w, w, w, w.
И вот мы распилили ее на w1
и w2.
И еще сюда прицепили
какой-то там w'.
Теперь говорим, что означает,
что у нее есть префиксный период
меньше, чем w.
Это означает, что у нее есть
какой-то, то есть вот этот вот.
То есть если этот префиксный период равен p,
то получается
хотя бы две копии сюда уместятся.
Я бы сказал даже хотя бы три.
Четвертая может уже отправиться в аут.
Копии сюда уместятся, правда?
Вот.
Но тогда
я утверждаю следующее, что
тогда на самом деле можно заметить,
что можно заметить.
Я утверждаю следующее,
что на самом деле я утверждаю,
что четвертая копия
на самом деле в аут не отправится.
Это как раз и будет означать,
что нам в общем
на w' плевать.
То есть я просто хочу доказать,
что на самом деле,
что если префиксный период есть,
то есть на самом деле,
что если такое разбиение есть,
то в этом разбиении префиксный период
будет все равно достаточно маленьким.
И он даже будет
больше у строки w2 и w1 в степени k-1.
Доказательство очень простое.
Предположим, что
4 копии p1 не влезли.
Вот до сюда не влезли.
Видно, да?
Тогда получается вот эта вот
строка длины.
То есть какая тут длина этой строки?
Длина этой строки получается
какая у нас?
3 модуль w плюс w2.
Достаточно большая строка.
Это заведомо больше,
чем, скажем,
модуль w плюс p1.
Согласны?
Но тогда
эта строка и w периодично,
и p1 периодично,
раз мы тут четвертая копия,
аж куда-то в аут отправилась, да?
Почему вы тут
рисуете w, если у нас
w1?
Господи, потому что
мне почему-то тупое интуитивное
желание написать тут единицу
на автомате, причем уже второй год подряд
поворачивать, я вчера там запись смотрел,
у меня тут тоже это было, я не знаю почему.
Потому что тут, конечно, имеется в виду
w.
Поэтому я тут рисую w.
Если у меня p1, значит, тут четвертая копия
отправляет в аут, значит, это все p1 периодично
и w периодично.
Но тогда
здесь автоматически противоречие с
чем?
Чего?
Нет, ну как бы да, понятно,
что это строка, нод
w p1 периодично.
Но этот нод
так как p1 меньше,
чем w у нас по предположению,
то получается, что
вся эта строка
нод
где-то там d периодично,
где d делитель w.
Противоречие с
базовостью строки w.
Видно, да?
То есть, вывод такой,
что мы сейчас доказали? Мы доказали следующее,
что
в любом таком, если
в каком-то разбиении нашелся
префиксный период меньше w,
то его 4 копии
вот сюда укладываются,
вот в эту строчку.
И в принципе, какой w штрих
нам приписывать, нам абсолютно все равно.
То есть, по большому счету,
задача будет в том, что надо
найти такое разбиение, чтобы
префиксный период меньше,
чем w был уже в строке w2,
там w в степени k-1.
Поэтому для удобства доказательства,
это утверждение нужно для удобства
доказательства сказать, что на самом деле нам все равно,
что приписывать в качестве w штрих,
поэтому мы будем говорить, а давайте я тут просто
еще w в бесконечном количестве
приписываю.
Вот, ну и так далее.
Да, сейчас мы на самом деле повторяем то,
с чем мы в прошлый раз как раз справились.
Вот, как мы будем сейчас с этим справляться?
Мы с этим будем
справляться мистическим алгоритмом.
Алгоритм будет говорить следующее.
То есть, он нам будет говорить,
значит, алгоритм будет такой,
то есть, жила была вот эта строчка,
пока вот мы, чему равно w1, w2,
мы не знаем, пока у нас
просто есть вот эта строчка w, w, w, w.
То есть, я так и напишу.
То есть, алгоритм будет такой,
то есть, s присвоить w в степени бесконечность,
и будем дальше говорить while
То есть, будем говорить
есть
префикс
z с
модуль z
в степени k
префикс s
и модуль z
меньше модуль w
мы будем говорить, что давайте
отпилим
минимальный такой z
от строки s.
Вот такой алгоритм.
Кстати, как мы уже интуитивно догадываемся,
мы алгоритм ровно в таком виде
можем в принципе реализовать,
даже за адекватную симпатику.
Потому что я минимальный такой z могу найти
за o от z, как мы выяснили.
Потому что это тот самый минимальный
префиксный период, правда?
Понимаете?
Отлично.
Значит, смотрите, сейчас магия будет.
Ну вот.
В прошлый момент вот где-то вот там
началась подлянка.
Да.
Но подлянка началась, ну вот.
Но сейчас, как бы,
сейчас, наверное, интуитивно должно быть проще,
потому что в результате предыдущих двух часов
как бы мы поняли, что этот алгоритм не совсем
на то истинно даже,
что можно его в принципе и...
Вот.
И спрашивает, что тогда?
Нет, в чем у нас была
подлянка?
Ну, нет, нам просто действительно...
Так, ну у нас просто хотим проанализировать
этот алгоритм.
Алгоритм говорит...
Так, теперь возникает вопрос, не до бесконечности
ли мы будем отпиливать?
Значит, выясняется следующее,
что если мы будем отпиливать
с точки Z1, Z2,
Z3 и так далее,
то, оказывается,
верна мистическая штука.
Знаете какая?
Даже...
Ну, во-первых, давайте это отметим,
что каждая следующая строка не короче
предыдущей, но на самом деле
верну более сильное утверждение.
Каждая Z и T
префикс
следующей строки.
Вот.
То есть мистическое утверждение.
Хотя, в общем-то, если вдуматься,
утверждение не самое сложное.
Откуда оно берется?
Откуда оно берется?
Давайте внимательно посмотрим.
Смотрите.
Вот мы, допустим, отпилили...
Ну, там вот идем, идем, идем.
В каждый момент времени у нас строка W периодично.
Кстати, это мы понимаем, да?
Но это даже не важно.
Важно другое.
Давайте и так в какой-то момент
мы решили отпилить
Z и T.
А что значит мы решили отпилить
Z и T?
Это означает, что у нас дальше, вот в этой бесконечной
строке строка, у нас бесконечная,
есть еще как минимум три
копии
Z и T, правда?
Вот.
И теперь мы абсолютно
неожиданно
решили отпилить еще
какой-то Z и
плюс один.
Ну, теперь давайте думать.
В принципе, из этой картинки уже очевидно
становится, что либо Z и префикс
Z и плюс один, либо, наоборот,
Z и плюс один префикс Z и.
Потому что Z и плюс один
начинается где-то здесь. То есть он либо
закончится раньше этой позиции, либо позже.
Согласны, да?
То есть нам, по сути,
надо доказать...
То есть, по сути, наоборот,
надо просто показать, что этот Z и плюс один
не мог закончиться раньше.
Ну, тут идея очень простая.
Вопрос.
Где закончились его четыре копии?
Ну, четыре копии
в Z и...
В трех Z и закончиться не могли.
Потому что иначе они бы и тут тогда
были, и тогда спрашивается, почему мы отпиливали
вообще Z и, правда?
Понимаете, да?
Но, только есть маленькая проблема.
Если тут нашлось вот,
допустим, три копии
и четвертая пошла в аут,
то опять получается, что у нас строка
Z и периодично,
Z и плюс один периодично.
То есть, следовательно, она
GCD от этих двух чисел
периодично.
Ну, потому что она достаточно длинная, да?
Но GCD
тогда это GCD является делителем
Z и не совпадающим Z и,
следовательно, Z и T
ну, можно сказать, Z и T не базовое.
А это означает, что мы тут вместо Z и могли
тут префиксы поменьше взять.
Все. То есть опять вот,
какая-то вот эта абсолютно стандартная
идея, которую мы, конечно, просто эксплуатируем,
просто,
что называется, фост и взрыв.
Так.
Вот.
Итак,
то есть получается, что каждая следующая,
что мы отпиливаем, оно получается
как минимум тоже,
что было раньше, только, вот,
только следующей.
Вот.
Только к нему еще приписали что-то.
Вот.
Ну, теперь выясняет
вопрос. Ну, теперь, на самом деле,
как теперь доказать, что эта последовательность
от пилов не бесконечна?
Ну, точнее так.
Ну, точнее, что рано или поздно нам потребуется
отпилить что-то, равное W.
Да.
Но заметим следующее, что единственное,
почему оно, если оно всегда меньше W,
то тогда найдется длина,
которая, начиная с какого-то момента,
пойдет навсегда.
Ну что, значит, она пойдет какая-то длина.
Если тут все Z биометал photograph's
пойдут длины l, то тогда это означает,
что, начиная с какого-то момента,
строка станет просто l периодичной.
В общем, l меньше, чем W.
Это запрещено.
Да. Но просто этот суффикс будет...
Но тогда просто это означает, что как бы
вся эта строка, начиная с какого-то момента,
и w периодично, а следовательно она будет в hcd от l и w периодично, значит w не базовая, потому что
опять там, потому что этот hcd является делителем w, но не совпадает с самим w. Да, так, то есть смотрите,
уже неплохо, то есть этот алгоритм закончится. Чудо, да? Ну а запнулись мы даже не в этом месте,
с этим мы справились, запнулись мы на более серьезном утверждении. Нам было заявлено,
что этот алгоритм становится раньше, чем закончится первая копия w. То есть утверждается,
что этот алгоритм отпилит строчек суммарной длины строго меньше, чем w. Ну кстати, давайте
поймем. Давайте вообще поймем, зачем этот алгоритм вообще нужен, какое он клемия вообще
имеет отношение. Ну я скажу так, давайте мы вот где-то остановились, мы знаем, что мы остановились
не на целой части w, потому что иначе мы бы зациклились. Заметим, что алгоритм ни в коем
времени так или иначе не мог отпилить несколько целых копий w и больше ничего. Потому что если
это так произошло, значит он зациклится. А мы убедились, что это невозможно. Так вот,
значит он где-то остановился. Я утверждаю, что это и есть w, надо взять как w2, а это w1. Ну потому
что здесь становится достаточно очевидно, потому что тогда вот этот алгоритм и будет нам гарантировать,
что у этой строки префиксного периода меньше, чем w нет. Ну что, понимаете, минимальная такая,
минимальный такой префикс и есть минимальный префиксный период, как мы поняли, да? Потому что
z по любасику базовая. Поэтому получается, то есть зачем нам нужен этот алгоритм? Забабахаем этот
алгоритм, что какой огрузок от w в конце останется, w2 мы в качестве w2 берем и радуемся. Теперь фишка
еще в том, то есть она нам еще поможет, что на самом деле вот это вот финальный распил,
он произойдет не здесь, а на самом деле здесь. То есть мы не можем в какой-то момент сказать,
что мы скушаем целую строчку w и пойдем дальше. И вот на этом мы запнулись. И вот теперь, значит,
пришло время разопнуться. Так, где бы нам это сделать? Все? Ты готов к этому? Так, Никита готов.
А все готовы? Так. Как-то что-то не уверенно как-то. Ну это, конечно, да, но это называется,
как это, да. А еще, да, надо разбить большую гору, не выкинуть ли нам для этого молотки.
А, это ты отправил, да? Пришлось по всем конкурентам по одному приходить. Ну да, да, да. Ну ладно,
неважно. Окей, хорошо. Ладно, давайте все. К сожалению, придется это убрать. Ну потому что я, кстати,
не уверен, что леммы в таком виде нам вообще понадобятся, кстати. Да? Уверен? Да, вот эти
леммы, наверное, уже в таком виде. Вот тебе лемма понадобится, потому что по большому счету мы
занимаемся тем, что доказываем ее, да. Нормально. Значит, смотрите. Поехали. Давайте я тут побольше
нарисую. В. В. Господи. Значит, смотрите. Будем отпиливать. Отпиливаем зетки. Отпиливаем,
отпиливаем, отпиливаем, отпиливаем. И тут опа, неожиданно перескочили границу. Да, как мы уже
сказали, вот это вот границы отпилов. Так вот, заметим, что вот это вот само w отпилом быть не
может. Почему? Потому что если мы отпилили в какой-то момент ровно w, значит будет зацикл,
а это невозможно. Более, я вам даже больше скажу. Смотрите, вот допустим, вот эта вот штука у меня
будет равна, ну допустим, она равна, этот отпил будет равен w плюс p. Тогда, смотрите, рассмотрим,
где-то тут рассмотрим число p. Так вот, утверждение, число p отпилом не является. Вот смотрите,
ну пусть, смотрите, пусть мы в какой-то момент перескочили через границу w. Пусть
первый отпил после w это w плюс p. Утверждение, p, то есть за w, спасибо. Ну вот, p, не отпил.
Спасибо. p не отпил. Почему? Потому что если у нас и p отпил, то есть если у нас p отпил,
а потом w плюс p отпил, то опять зацикл налицо. Ну тогда смотрите, какая магия. Вот рассмотрим,
то есть p находится между какими-то отпилами. Да, кстати, 0 мы тоже будем считать отпилом для
удобства. Так вот, смотрите, идея такая. Давайте я вот эти вот две строчки назову x и y. Тогда
я утверждаю следующее. Ну легко показывать, что так как мы решили вот эту строку x плюс y отпилить,
то, наверное, где-то здесь было 4x плюс y, да? Логично, да? А, вы еще налево. У нас в
прошлый раз y был x. А теперь вот. А, нет, все. Черт. Тут уже не принципиально, на самом деле,
то, что было в прошлый раз надо вообще забыть. Вот. Но нет, как хочешь, если ты хочешь ввести
другие буквы, давай пока не поздно. Давай вместо x. Вместо x. Да? Да. Пожалуйста. Хорошо. Так,
пусть это будет x. Ну, хорошо. Пусть это будет x. А дальше мы отпилили. Мы смотрим, когда мы отпилили
сам x, да? Не совсем. Ну, нет, сам x мы никогда не отпиливали. Так, вот у нас тут слева есть и это.
Так, придется тут ввести другие буквы. Мы там вводили какие-нибудь буквы? Ну, можно z,
например. z, а тут? Ну, мы, короче, не вводили для двух частей. Хорошо. Ладно, я введу a и b.
A и z, хорошо. Значит, итак, ab, ab, ab, ab. Ну, как-то там накладывается. Так вот. Ну, понятно, да?
Потому что раз мы отпилили вот эту строку a плюс b, значит, тут еще три копии a плюс b было. У нас
алгоритм так устроен, да? А теперь смотрите внимательно. Заметим, что строка, начинающая
с x и строка, начинающая с w плюс x, это одно и то же.
Верно. К чему это нас приводит? А приводит нас так вот к чему. Это означает, что эта строка
начинается со строк b, ab, ab, ab. Ну, я просто вот это переписал. Абсолютно то же самое. Что там
дальше я не знаю, но уж тут точно будет b, ab, ab, ab. Это я гарантирую. Ну, в принципе,
гарантирую, что тут еще и ab было на самом деле. Вот. А теперь магия. А теперь супермагия. Вы же
помните, что каждый следующий отпил, то есть каждый предыдущий отпил является префиксом всех
следующих, да? Чего? Я помню. Каждый отпил является префиксом следующего. Да, у нас бы тут
уже даже записали этот. Было, было. Только что было. Пять минут назад было. И тогда, кстати, тоже.
Нет. Нет, префикс это вообще не правда. Правда, правда, правда. Ну, в целом, да. Ну, как бы,
логично следующее, что ладно, если мы верим в то, что они не убывают, то после того, как вы отпилили
z и, у вас там дальше идут три копии z и. Так что понятно, что то, что вы, если вы отпиливаете не
менее чем z и, значит, вы отпилили z и еще что-то. Так что нет. Так, все, разобрались, не кидывали
зай. Давай. Все. Потому что теперь, смотрите, но тогда, смотрите, у нас имел место отпил ab, да?
Значит, любой следующий отпил имеет префикс ab. Догадываетесь, что это значит? Это означает,
что в этом месте, да, да, в этом месте есть, имеет место строчка ab, то есть после wx мы начинаем с ab.
Нет, а вдруг это был самый последний отпил? Самый последний отпил? Смотри, а это неважно. Самое
главное, что, хорошо, формальное доказательство. Давай так, формальное доказательство. Ладно,
хорошо, более формальное доказательство звучит так. Вот у нас был последний отпил. У него есть
префикс ab, но тогда, когда мы его отпилили, значит, тут дальше идут как минимум три копии этого же,
значит, префикс ab тут точно есть. Да, спасибо за уточнение, да, действительно, это важно. А то,
мало ли, начну там на экзамене спрашивать. Ну и что? А я скажу, не доказали, минус 8. Ну ладно,
но это вопрос, какой конкретный фистер слил полуфинал, а то, знаешь, там 18 человек поедут,
я надеюсь. Нет, если, конечно, фистер слёт четверть финала столько, что тогда поедет не 18 человек,
тогда я действительно расстроюсь, это да. Но с другой стороны, как вы видите, по 17 году,
хотя хрен его знает, там уровень конкурентов тоже вырос. Ну это проблема. А то жалко вы на
тренировки не ходите обычно, а то в воскресенье там мы писали просто Петрозаводск зимой 14-го года.
Ну вот, скажем, шавер мастерс так просто слёту там в контесте третье место заняли.
Это будет в Фистех-Сити? Да. Кто, что? Можно туда конкурентов не пускать. Не, нельзя. Так, всё.
Это никак не позволяет захода от команды Фистеха. А, ты хочешь из Фистеха не пускать? Ну,
посмотрим. Ну, посмотрим. Ну, письмак по ТФКП в следующее воскресенье. Чего? Теория функции
комплексного переменного, что-то такое. И что? Так, слушай, так, сразу что сказал,
смотри, если вы заморочитесь заранее, его освободят от этого дела. И вообще,
то есть я думаю, тогда просто если мы заранее предупреждим об этом Рыгородского, то я думаю,
Рыгородский в этом месте на встречу пойдёт. Рыгородский в плане, это не кафедра ДМА? Ну,
тем не менее, но это факультет, так что я думаю, как-то порешать вопрос, мне кажется, по крайней
мере, попытаться стоит. Так, то есть вы утверждаете, погодите, то есть поэтому, как вы так, обязательно
напишите мне, там, когда у кого какая контроль, какая там принципиальная контрольная по ТФКП.
Не во время четверти. Чего? Не во время четверти, а во время трени. Аааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааа
Не-не-не, нет, слушайте, нет, я вас уверен, там, на полуфинал, за поехавших на полуфинал, я думаю, тут точно прижёмся. Так вот, ладно, не будем это, пока, значит, смотрите, тогда смотрите, какая магия, он начинается с, это, значит, W плюс X, дальше идёт строка AB, то есть он начинается с AB, но ещё он начинается с BA. То есть вывод очень простой. AB, RAVDO, BA, и чё это значит, как вы думаете?
Нет, ну не, ну не группа, ну, а, ну, так, нет, давайте, нет, давайте подумаем, в чём противоречие? Вот я утверждаю, что вот это, этот факт того, что здесь, как бы, что вот AB...
Ну, видимо, мы могли определить сильно меньше в тот раз.
На самом деле, смотрите, нет, ну да, ну, по сути, да, AB равно BA, это означает, что у этой строчки есть период, ну, не прям нацело, но период меньше, чем A плюс B.
Ну, то есть утверждение такое, это строка модуль A периодично. Вот это строка модуля A периодично, почему? Потому что вот это равно вот этому, то есть, если вот этот суффикс длинный там, вот, сдвините налево на A, то получится то же самое.
А ещё, ну, она не просто A периодично, она ещё и B периодично, ровно по той же причине. Ну, если она A периодичная, и B периодичная, и её длина A плюс B, следовательно, она GCD от AB периодично.
Ну, можно сказать просто всё, она не, ну, вот, то есть она не базовая. Ну, раз она не базовая, то есть её можно распилить на одинаковые копии, но тогда получается, что вот эту четвёрку можно было уже здесь и поменьше сделать.
Ага, да, вот на чём мы не додумались в прошлый раз.
Так что вот такая неожиданная магия. То есть вот, да, как-то вот такое, то есть вот такой вот оказался момент, до которого мы просто взяли и не додумались.
Вот. Да, то есть очень красивый момент.
Ну, да. Ну, чё, нет, почему наклона нет. Классика это называется «Дубинки» там в фильме «Проморозка». Там что-то в надо, как бы это, в начале фильма там, что-то летом, называется, Иванушка взял дубинки, отправил в небо, сказал ось к зиме вернуться, а потом в самый нужный момент зимой они реально вернулись.
Причём упали на голову ровно тому, кому надо. Это было красиво.
Вот. Хорошо. Так вот, смотрите. Значит, это у нас АВ. Так, ну хорошо, то есть мы доказали, что отпиливать мы будем не более, чем w. То есть закончим отпилы мы раньше, чем закончится w.
А знаете, что это значит? Это значит, что мы же можем, как мы уже поняли, мы вот этот алгоритм можем в явном виде, то есть вот этот z найти и отпилить мы можем за o от z, мы это уже выяснили, да? Согласны?
Это означает, что в принципе верна не просто лемма, а верно ещё то, что вот сами по себе эту w2 и w1 мы прекрасно можем найти за o от w.
А я даже больше скажу. За o от w1, я бы сказал.
По факту алгоритм у нас работает за o от суммарной длины того, что мы отпилили.
А зачем он 2?
Кто 2?
Зачем он было 2?
Ну мы ещё не весь алгоритм описали. Мы же только про лему говорим, а не про всю теорию модекомпозиции.
Итак, пока мы просто говорим, что, скажем так, у нас есть алгоритм, который распилил w на w1, w2 с вот таким вот мистическим свойством.
Вот. Спрашивается, зачем это нам? То есть алгоритм есть, он работает за o там, получается, при желании даже не просто o от w, а o от w1.
Вот. Так вот, дальше пришло время теперь доказывать теорию модекомпозиции.
Вот. Так, всё, вот это запомнили.
Далее. Ну вот. А теорию модекомпозиции мы уже запомнили?
Ну ладно, теорию модекомпозиции я, пожалуй, стирать не буду, потому что мы её доказываем сейчас.
Да, вот это вот всё, да, это всё мы можем уже убрать спокойненько. Там это мы убираем, это мы убираем.
Ну вот. Так, алгоритм запомнили, запомнили, что он будет работать ещё и за o от w1, при желании, да.
То есть будем отпиливать, отпиливать, отпиливать и отпиливать.
Потому что дальше появляется алгоритм, который работает следующим образом.
Так, смотрите. Так, мы доказываем вот эту вот строку r, да.
Так вот. Сейчас мы к этой строке r применим следующий алгоритм.
While у r хотя бы два префиксных периода.
Что мы делаем? Мы скажем, что пусть у меня p2 это второй префиксный период.
О, красота, красота.
Значит дальше алгоритм говорит так. Найти такое i меньше модуль r, такое что, ладно, вру, меньше, ладно, меньше не i, а меньше, чем p2.
Такое что r от i, r не имеет префиксного периода, короче, p2.
Ну и просто говорим, что r присвоит этой штуке, то есть отпил.
Вот.
Давайте, так, давайте, раскусите этот алгоритм.
Пожалуйста.
Пожалуйста.
Давайте.
Давайте.
Да, почему? Так, ну напоминаю, мы как бы не лему 3 доказываем, мы уже теперь моде композиции доказываем, да.
Да, у нас цель распилить r на две части, так и можно, чтобы у второй части префиксный период был не более чем один.
И мы говорим, пока у r хотя бы два есть, то мы выполняем какой-то добрый отпил.
А что за i меньше, чем p2?
Найти такую, вот смотри, а вот, мы находим мы, ну наш, ну вот, вот здесь, то есть мы находим какую-то позицию i такую, что все перед i надо отпилить.
Почему надо?
Хотим.
Ну, хотим, говорит, а у нас есть два префиксных периода, хотя бы два, пусть они p1 и p2, да.
Так вот, я хочу найти у r такой суффикс, у которого префиксный период минимальный, минимальный, хотя бы p2.
То есть, лемма гарантировала, что я могу это сделать.
Такой, что префиксный период.
Не имеет префиксного периода, короче, p2, ладно, я тут сразу петую написал.
Ну да, в плане, а почему сейчас такой?
А потому что, смотри, сейчас картинку нарисуем, жила была r, да.
Почему они монотонные в плане?
Да почему?
Сейчас, смотри, ну в смысле монотонные.
Нет, я так отпиливаю, смотри.
Потому что идея такая, жил был у меня префиксный период, даже не минимальный, вот он.
Но это префиксный период, p2, p2, p2, p2.
То есть, вот у меня вот, давай вот эту строку я, ну вот, тогда утверждение такое.
Давай я скажу, пусть у меня w, это равно вот это вот префикс длины p2.
Тогда что говорит лемма 3?
Что говорит лемма 3?
Лемма 3 говорит, что w можно распилить на, то есть, вот это вот w на, как бы, w1, w2.
И тут автоматически w1, w2.
W, потому что p2 базовый.
Ну вот.
Да, p2 базовый, это важно.
И тогда оказывается, что можно распилить таким образом, чтобы вот это, чтобы вот эта вот строка,
то есть w2, 3 копии w и еще абсолютно любая хрень здесь, как сказал бы классик.
Вот.
Соответственно, не имеет префиксного периода меньше, чем длина этого w, то есть p2.
Вот.
Такая небольшая магия.
Вы ищете любой такой.
Абсолютно любой.
Я какой-нибудь вот такой и неожиданно найду.
Более того, я уже, более того, мы уже описали, какие был алгоритм за o от w1, я его даже найду.
Помните, да?
То есть я там за o от w1 его найду, отпилю.
И скажу, что у меня радость.
Но, впочем, это неважно.
Что за o от w1, я вам забегаю вперед скажу, но уже хорошо.
Сейчас.
Вот.
То есть мы смотрим префиксный период.
Вот наш алгоритм умеет искать два префисных периода.
Ага.
А потом нам нужно найти, а потом нам нужно находить отпиливать, пока у нас не придет w2.
Нет, не совсем так, все еще круче.
Мы найдем два префиксных периода.
То есть на самом деле алгоритм будет звучать, ну, не важно как будет.
Как мы будем искать вот это w2?
А как раньше отписали.
Прямо в явном виде возьмем вот эту строчку, прямо даже вот эту строчку.
Но можно там, мысленно пятую копию прихвЫсовать, ну, это не важно.
И будем от нее просто честно отпиливать, то есть находить минимальный префиксный период отпиливать,
потом опять находить минимальный префиксный период отпиливать,
до тех пор, пока этот минимальный префиксный период, он не окажется хотя бы p2.
хотя бы п2, да, то есть заметим, что каждый отпил мы будем находить за от его длины,
поэтому как бы суммарно это получится за сколько нам надо. Ну вот, но правда и сам второй прификсный,
правда всю эту операцию мы все равно, то есть получается сделаем за от п2, потому что нам
нужна от п2 для того, чтобы вообще второй прификсный период найти. Но это пока не важно,
пока как бы важно, что мы теорему доказываем. Сейчас нам важно другое. То есть хорошо, вот мы
применили этот алгоритм. Да, в принципе становится очевидно, что, ну хотя нет, пока вообще даже не
очевидно, закончится ли вообще этот алгоритм. А вот действительно закончится ли этот алгоритм.
Да, ну правда заметим в следующий, что мы что-то отпиливаем, но заметим, что от п2 мы никогда не
отпилем все по этому алгоритму. Обратите внимание, да? Нет, все мы не отпилем, потому что по определению.
Ну в смысле не больше, чем у АТР шагов. Да, на самом деле меньше либо равно. Вот так.
Нет, ну нам не хотелось бы, чтобы пустая строчка была. Нам принципиально, чтобы вот эта В была
не пустая, причем у нас даже есть сильное условие, что она должна быть очень не пустая. Точнее так,
она может быть настолько не пустая, что у это от шифта даже ее. А теперь давайте думать.
Ну то есть отдельно закончится ли вообще? Ну то есть да, алгоритм конечно закончится.
Вот. Но на самом деле заметим, что он будет заканчиваться быстрее, чем кажется. Знаете,
почему? Потому что у нас была мистическая теорема, когда-то давным-давно, не будем сейчас
повторять доказательства, что если у нас есть два префиксных периода, то не отличается друг от друга
хотя бы в к-минус один раз. Даже Серге, по-моему, уже что-то повторяли. Да, то есть если у тебя есть два разных,
у строки есть два разных префиксных периода, то они отличаются друг от друга даже строго больше,
чем в к-минус один раз. Была такая теорема. Но тогда это означает следующее. Все, смотрите,
если у нас сейчас, то есть тогда мы заметим, что у нас сейчас П2 это второй префиксный период,
да, и он на следующем шаге будет, даже первый префиксный период будет не менее чем П2. То есть
следовательно, у нас длина второго префиксного периода на каждом шаге получается в три раза
больше, чем в прошлые разы. То есть получается итерация, которая сделает этот вайл, но это не
сильно претепляет, даже не более, чем логарифм получается. Да, но не то чтобы нам это сейчас сильно
помогает, но пока просто для понимания происходящего. Сейчас мы еще более внимательно посмотрим,
какие строки он отпиливает и убедимся, что на самом деле, что на самом деле, действительно,
не слишком много отпилит вот в этом вот плане. Давайте внимательно думать, потому что давайте,
тут еще верно следующее, что каждая вот эта итерация вайла, она сделается за от П2 и при этом отпилит
меньше, чем П2 элементов, правда? Ну, не больше, чем П2. Она отпилит, да, не более, чем П2 элементов.
Ну, она отпилит строго меньше, чем П2, на самом деле. Она отпилит и минус один. Понимаете, да? Ну,
тогда, вот, так что она это отпилит. Но самое главное для нас вот, что и так в самом конце,
у нас осталась какая-то строка R, у которой есть только один префиксный период. Ну, не более,
чем один. Вот. Ну, теперь возникает вопрос. Ну, то есть, нам теперь нужно вот что-то про шифт
доказать, да? Ну, во-первых, заметим вот что. Смотрите, у этой строки, смотрите, когда мы тут
отпиливали, у нас были первые префиксные периоды. Давайте их назовем P1, P2, P3 и так далее. Вот,
допустим, мы отпиливали L раз, да? Вот. Вот. И в конце вот у нас осталась финальная строка R,
в которой там P1, L плюс 1, который может быть какой-нибудь там, может быть бесконечностью,
в смысле, не существует. Значит, это у нас первые префиксные периоды. А еще у нас были
вторые префиксные периоды. То есть, я так нарисую. Они были P2, P1, P2, P2. Нет, нет, нет, нет, не факт,
не факт. Они не совсем не совпадают, они не совпадают, они вот такие. Вот там меньше либо равно.
Ну да. Ну вот. Но при этом мы знаем, что каждый следующий вот здесь, он как бы строго больше,
чем вот умножить на K. Потому что второй префикс, это префиксные периоды одной и той же строки. Это
первый, это второй. Да. Понятно, да? То есть, как у нас эта последовательность растет? То есть,
тут надо умножить на там, ой, как тут это поворачиваться-то? K-1, вот на K-1. Ну вот, и тут.
Да, тут можно тоже это написать. Тут меньше либо равно, тут строго больше, чем умножить на K-1. Вот.
То есть, вот так эти префиксные периоды вообще, последовательности префиксных периодов устроены.
Вот. Ну теперь давайте думать. Теперь давайте думать. Чему равен shift от V? Вот, действительно,
давайте подумаем. Ну вот. Но я утверждаю следующее. Ну, в принципе, по большому счету мы уже
топтались вокруг этого движения. Можем теперь заявить. Ну, во-первых, что удвижение такое. Shift
от V, он, если у нас не более, ну давайте так. То есть, мы уже много раз пользовались тем, что если у строки
нет префиксного периода, то shift он не менее, чем длина строки поделить на K. Было дело, да? Ну,
действительно, если у вас сдвиг меньше, чем длина делить на K, за 4 копии найдутся, значит префиксный
период есть, правда? Более того, как бы могли заметить, если у вас сдвиг, то есть, более того,
следующее, что если минимальный сдвиг у вас есть, и он меньше, чем длина строки делить на K,
то этот сдвиг является префиксным периодом, правда? Ну, давайте еще раз. Ищем shift у какой-нибудь
рандомной строки. И пусть выяснилось, что этот shift, вот длина строки у нас равна N, и, допустим,
этот shift оказался меньше, чем N делить на K. То есть, shift означает, что она вот столько
периодичной, как минимум 4 копии тут есть, и еще дальше что-то идет. Тогда утверждение,
если мы найдем минимальный такой shift, то это строка базовая. Потому что была бы не базовая,
тут был бы меньше период. Вывод. Shift является префиксным периодом. Ну, то есть, если shift
меньше, чем N делить на K, то он является префиксным периодом. Следовательно, если у вас
префиксный период в принципе один, то это он. То есть, у вас префиксный период либо не меньше,
то есть shift у вас либо как минимум вся строка делить на K, то есть, получается тета от ее длины,
либо вот этот префиксный период. Понятно, да? Ну, причем более того, мы выяснили, что если его нет,
так, ну теперь давайте рассмотрим два случая. Пусть его нет. То есть, если префиксного периода нет,
тогда shift у вас, тогда этот shift получается равен чему? V делить на K не менее. Но давайте подумаем,
а сколько мы отпилили? Ну, на самом деле, смотрите, мы отпилили, мы всего отпилили не более чем вот
стока, плюс вот стока, плюс вот сток, плюс вот сток. Правда? Ну, теперь давайте следующее. То есть, мы
пишем отпилили меньше либо равно, чем P2,1, плюс P2,2, плюс P2,3, плюс и так далее, плюс P2,L. Как мы уже
поняли, это не превосходит P2,L умножить на пум-пум-пум-пум-пум. Вот тут с конца лучше писать
1 плюс 1 делить на K минус 1, плюс 1 делить на K минус 1 в квадрате, плюс и так далее. Это, в общем,
короче говоря, это равно θ от P2,L. Понимаете, да? Ну, тогда, то есть, ну, вывод тогда получается
очень простой. Тогда у нас просто два варианта. Если префикс этого периода у итоговой строки нет,
то тогда P2,L, ну, тогда мы просто говорим, что shift это от V, это θ от V, потому что не
менее, чем V поделить на K, правда? Чего? Что не так? С какого? Значит, смотрите. Так вот, мы поняли,
что мы отпилили ровно θ от последнего второго префиксного периода. Тогда у итоговой строки
префиксного периода не оказалось вообще. Тогда ее shift это θ от V, потому что не менее, чем V делить
на K, но не более V. То есть, оно получается такое не более, чем V. Но тогда утверждение следующее,
что P2, наверное, вряд ли очень сильно превосходит V. Причина очень проста. Смотрите, у нас P2,L
перед последним отпилом, P2,L было префиксным периодом. То есть, у нас было 4 раза по P2,L,
у нас еще было в строке R. А мы отпилили меньше, чем одну копию. То есть, следовательно, P2,L не
превосходит даже R поделить на 4. Ну, само P2,L. То есть, P2,L получается не более,
чем треть от остатка V. Ну, или там K минус первая часть. Поэтому получается,
что если у финальной строки префиксного периода нет, то действительно это победа.
А если префиксный период есть, то тогда shift становится либо P0. Но тогда у нас два варианта.
Либо это, то есть, либо он оказывает нот. То есть, тогда либо оказывается, что префиксный период
больше, чем Q делить на K, и утверждение абсолютно доказывается также. Либо эта единственная
проблема может быть, когда вот этот префиксный период все-таки меньше, чем остаток делить на K.
Но тогда из этого следует, что, из этого автоматически следует, что и этот второй
префиксный период, предыдущий был тоже менее, чем… Ну, тогда shift был P1, как мы уже выяснили,
да? Ну, и победа автоматическая. То есть, тогда этот shift будет в P1, а это O от этой штуки.
Поздравляю, все время доказано. Вообще не просто доказано, а исходя из всего остального,
мы вообще-то уже это все уже реализовали. Ну, если у вас не осталось вопросов,
вы уже все поняли. Так, ну давайте так. Теорему доказали, да? Потому что раньше, когда-то,
мы закончили на следующем, что если мы поверили в это, что нам для победы нужно только не просто
поверить в эту теорему, но в явном виде научиться за линию искать вот эти вот УВ, а УВ еще и найти
этот префиксный период, если он есть. Так вот, на самом деле я описал алгоритм, как мы это делаем.
Но теперь смотрите. То есть алгоритм говорит, что мы ищем честно за… То есть мы умеем,
во-первых, мы научились за линию для строки проверять, есть ли у нее два префиксных периода,
и более того, если есть, то мы умеем находить второй префиксный период и заявлять, что мы
проделали действие не более чем от П2. Мы теперь говорим, что мы это несколько раз делали и по
отпиливали. Да? Сами по себе префиксные периоды мы находили за вот эту вот асимптотику, и выяснилось,
что она сумма от последнего отпила, да? А последний отпил мы за линию. Ну вот, это раз. А во-вторых,
вот это интеллектуальное нахождение мы тоже внутри себя научились делать за от П2. Потому что мы там
тоже просто находим минимальные префиксные периоды, отпиливаем, отпиливаем, отпиливаем, до тех пор пока
отпиливается. А выяснится, что быстро отпиливается. Ну что, за последний час, за оставшийся час нам нужно
успеть обсудить дерево денденных повторов. Нет, ну как сказать? Нет, ну скажем так, дерево дендных
повторов я боюсь придется отменить. Нет, ну сформулируем так, оно бы было, если бы я был в прошлый
раз. Ну в прошлый раз я, к сожалению, проболел. Вот. Нет, на самом деле, мне тоже нравится, что вместо
него появилось. Мне кажется, это даже более полезно, на самом деле, если честно было. Ну там важные
чешные алгоритмы были. Вот. Ну соответственно, а вот сувмасс нам обсудить придется. Ну думаю,
мы сегодня за час его спокойно обсудим. Ну вот, а здесь, ну там мы победили. Можете быстро повторить,
что мы делаем, если p1 или plus 1 не бесконечно. Если он не бесконечно, у нас тогда два варианта.
Там либо, если этот p1 оказался все равно больше, чем q делить на k, а ладно, он не оказался. Если он
есть, то он по-любому меньше, чем q делить на k. Но тогда утверждение следующее, что у меня shift,
ну там просто ключевое утверждение, тогда shift в этом случае, либо вот этот префиксный
период, либо тупо q делить на k, либо не менее, чем q делить на k. То есть других шифтов нет там,
потому что если есть shift меньше, значит там с p1 проблемы с его минимальностью префиксного
периода. А если там есть shift меньше, чем q делить на k, но больше, чем p1, ну тоже коллизии. Ну там
с этими периодами, базовостями и так далее. Поэтому мы говорим, что единственным, то есть получается,
то есть shift у нас как минимум омега от p1. Вот так скажем в любом случае. Но мы доказали,
что мы раньше отпилили о от p2l, который не превосходит этого префиксного периода. Все. Ура.
Так что вот такая разница. Есть ли тут вопросы?
Почему p1 и q1 меньше, чем q9 на k? Потому что по определению префиксного периода. То есть
как бы p является префиксным периодом строки, значит 4 копии p. Где я произнес такое умное слово?
Где я произнес q? Ну для нас строки делить на k хорошо.
Вот. Ну что? Да нет, наверное. Окей.
Ура, мы справились. Да, это конечно стоило нам больше негрных клеток, чем я изначально думал,
если честно. Но мы в итоге справились. Ну посмотрим. Интересно, что будет в следующем
году на самом деле. Потому что в этом году что-то как-то так заходит, что то ли все упорно молчат,
то ли как-то там даже софт хип оказался не очень сложным алгоритмом. Ну тогда нет, то есть правда
это хор, то что тогда на отл. То есть я не знаю, это придумать вот это с нуля или софт хип там.
По токе. Нет, у меня теоретически была мечта. У меня были силы. Я бы вообще, на самом деле,
можно было забабахать просто отдельный спецкульс типа там супер продвинутые алгоритмы.
Нет, ну как бесполезно. Нет, с точки зрения науки это интересно. Там много чего копать,
потому что если изучать алгоритмы, то знаешь, что тоже голубая мечта, из этого можно хоть там
спецкульс сделать. Можно, можно. Ну это называется да. Ну да. Ну как сказать, вы уже на последних
контестах какую-то там элементарную задачу на потоке не сдали. Да ты так что, ты ж кубок не
пишешь. Давай. А ну нет, у тебя в принципе есть опция написать еще последний этап кубка. Да,
ну твое право. Хотя зря там висит, там висело на самом деле. Да, конечно, в принципе неожиданно,
конечно, заканчивать курс по строкам именно этим алгоритмам, учитывая, что мы в принципе с вами
обсудили. То есть смотрите, на самом деле мало того, что мы это с вами как бы обсудили более
сложные алгоритмы, так более того и в принципе парадокс в том, что мы сейчас будем изучать
алгоритм строения суфмасса за n log n, хотя с помощью суффиксного дерева, дфс, можно эту, там все,
что мы будем изучать дальше построить за линию, причем очень легко. Потому что что такое суффиксный
массив? Да, ну как всегда, напомним, где мы находимся. То есть мы напоминаем, что мы ищем соответственно
подстрок, там пытаемся искать подстроки в строке, но пытаемся искать это в онлайне. То есть дан текст,
мы его как-то как-то обрабатываем, потом подстроки искаем в онлайне, желательно за o от их длины,
ну или хотя бы за там o от их длины плюс что-то связанное с алгоритмом. Но давайте думать.
Значит, с помощью суффмасса в принципе, да, за o от p я вам не обещаю, но p плюс log s достигнем.
Итак, что такое суффиксный массив? Да, внимание, внимание, важный момент, сейчас будет неожиданно,
но мы будем жить в ноль индексации. Вот, да, ну просто мы тут раньше жили в один индексации,
только что два часа. Сейчас будем жить в ноль индексации. Как же мы это будем делать?
Будем делать так. Ну вот, то есть идея такая, значит, что такое суффиксный массив? Мы просто
возьмем числа 0 и 1, там s-1, и расположим их в порядке лексиграфического возрастания
соответствующих суффиксов. Напомню, что, что такое yt-суффикс? Да, совершенно верно. Ну,
тут может быть путрица, кто-то считает, что yt-суффикс, это там либо yt-суффикс уже в ацертировом
порядке, либо суффикс длины i. Так вот, нет, ни в коем случае ни то, ни другое. То есть yt-суффикс для
нас, по умолчанию, это суффикс, начинающийся с yt-го символа. Вот, так вот, если их так расположить,
то, в общем, это суффиксным массивом и является. То есть, суффиксный массив – это перестановка
чисел. Вот. Ну, в принципе, вот для строки Аббатсаба, как легко убедиться, там суффиксный массив просто
ищется по телефону 6402513. Так, ну что? Так. Ладно, требуется на доске нарисовать, откуда это берется?
Нет. Ну, тут, думаю, все понятно. Вот. Чего? Ну, да. Ну, я не знаю. Значит, как его построить? Ну,
тут, в принципе, отдельная письма. Есть большой соблазн вообще спросить так, а кто вообще этот
алгоритм знает, как его ZN-Logan строить? Все подымают руки. Нет, не все? Ладно, обсуждаем. Ну,
задача просто. Кто знает вообще, как строить суффиксный массив ZN-Logan? Ну, да. Ну, в принципе,
кто-то может не знать. Ну, здесь мы сформулируем так. Мы это воспомним и заодно еще так воспомним,
как это эффективно писать. Вот. То есть, да. Значит, смотрите. Ну, вообще, отметим, какие еще вещи
можно? Можно это делать в тупую, в худшем случае, за s2 log s. Но как мы уже отметили, что если строка
какая-нибудь достаточно рандомная, то, в принципе, этого вам может и хватить, потому что вы сравнивать
будете за быстро. А еще можно сделать s log s2, кстати. Еще можно, если вы делаете бинпоиск с хшами.
То есть, любые два суффикса можно спринять бинпоиском и хшами за логарифом. Ну, точнее,
бинпоиском найти их максимальный общий префикс и, соответственно, и следующий символ в явном
виде сравнить. Вот. Так что вот. Ну, кстати, еще вбор можно еще запихнуть. То есть,
за s2, пожалуйста. Тут еще такие простые вещи есть. Но у нас есть классический алгоритм
кавк по миллеру Розенфельда, который будет его строить за s log s. Тут есть парадокс. Мы умеем
с вами строить, конечно, суффиксный массив за быстрее с помощью DFS в суффиксном дереве. То есть,
как можно построить такое дерево? Очень просто. Давайте припишем к строке $, построим суффиксное
дерево и запустим DFS. Как только пришли в какой-то лист, этому листу соответствуют суффиксы
своей длины, мы его и записываем. Вот. Это понятная идея, да? Вот. Тем не менее, оказывается,
что быстрее, чем s log s, суффиксный массив построить нельзя. В каком смысле нельзя? А вот в каком.
Предположим, смотрите, у нас, чтобы построить суффиксный массив, подразумевается, что буковки
между собой сравниваются, правда? То есть, мы знаем, что каждая буковка меньше или больше какой-то
любой другой буквы, правда? А теперь предположим, что это все, что нам известно. То есть, известно,
что у нас буковки — это те самые камешки из сортировки. То есть, все, что мы можем — это взять
два камешка, положить их на весы, и весы нам скажут, кто меньше. Тогда заметим, что суффиксный массив
быстрее, чем за s log s, построить нельзя в принципе. Почему? Потому что, если все буковки попарно
различны, то это эквивалент тупо сортировки этих камешков. Поэтому парадокс, что, с одной стороны,
быстрее, чем за s log s нельзя, но, с другой стороны, если алфавит константный, то, конечно, все вполне
возможно. То есть, скажем, Уканина на самом деле, как вы помните, мы строили не за o от s, а за o от s
алгоритм алфавита. Поэтому, если бы алгоритм был различный, то есть, если мы там храним все в
мапчике, допустим, то, в принципе, получился бы вполне себе s log s, потому что у вас в корне было бы там
n различных символов. Так вот, но как же этот s log s будет работать? Так, ну вот, мы уже упоминали
добавить в s какой-нибудь символ. Я почему-то сказал доллар, но здесь предлагается все-таки диезик. То
есть, первая идея, которая возникает, давайте к строке s припилим диезик. Диезик – это символ,
который будет считаться меньше всех остальных. Ну и основная идея будет заключаться в том, что,
если вы припилите к двум суффиксам строки по диезику, то результат их сравнения этикографического
от этого не поменяется. То есть, разница будет только в том, что ни один из суффиксов больше не
будет являться префиксом другого. Понимаете, да? Более того, оказывается, что теперь можно в
принципе сказать, что давайте теперь сравнивать не суффиксы, а циклические сдвиги. Понятная
идея, да? То есть, более того, будет идея, что мы эти циклические сдвиги будем считать, что их
длина бесконечна. То есть, мы эти циклические сдвиги будем просто записывать друг за другом
бесконечно. Вот и оказывается, что теперь мы будем сортировать именно их. То есть,
функция построить суффиксный массив на самом деле у нас…
В нашем определении пустой суффикс мы не сортируем. Хотя, если вы его хотите сортировать,
то пожалуйста. Вот. И четвертая строка – ретурн А. Все. То есть, получается все. Мы научились
искать суффиксный массив в четыре строчки. Правда, с вызовом функции, которую нам придется
реализовать. Это вот понятная идея, да? Или нет? Понятно, да? Не, я могу там вам чуть позже код
показать. У меня там еще и код есть. Вот. Там это будет. Ну ладно, это мы дойдем. Итак, значит,
начиная с этого момента, мы не строим суффиксный массив, мы сортируем циклические сдвиги. Вот.
Значит, мы эти циклические сдвиги считаем бесконечными. Но основная идея, то есть,
мы будем делать log s иterации, где просто мы будем сортировать эти циклические сдвиги по первым…
Чего? А, это l, между прочим. Это такая l, выделенная курсивом. Да. А не то, что мы подумали. Вот.
То есть, будем сначала сорвать по первому одному символу, потом по первому двумя,
потом по первому четырем, потом по первому восьми. Так что, не так? Нет, ты просто так
смотришь, что началось. Я это изучал очень давно, но там что-то другое было. Везде рассказывается
вроде этот алгоритм. Вот. Итак. Ну, понятно, как только эта степень двойки станет больше либо равна s,
значит, циклические сдвиги отсортированы полностью. Как же мы это будем делать? Ну,
первую итерацию по одному символу мы прямо честно сортируем по одному символу. Можно подсчетом
сортировать, ну или если там у вас реально камешки, значит, честно за n log. Но идея такая,
что начиная с этого момента, после того, как вы отсортировали по первому символу, вы уже точно
можете считать, что… То есть, все символы считать, что они от одного до n. Ну, потому что можно символы
заранее, скажем, отсортировать и перенумеровать их с одного по n, сохраняя порядок. Правда? Поэтому
базовую итерацию делаем. А теперь идея такая. Пока нет. А что? Нет, пока нет. Итак. А теперь
идея такая. Значит, у нас теперь будет говорить следующее. Значит, каждая итерация теперь будет
говорить так. Вот мы уже имеем циклические сдвиги, отсортированные по l символам. То есть,
мы будем считать, что у нас есть массив a, в котором вся эта сортировка уже есть. И более того,
для каждой подстроки длины l мы будем еще и заведем ее цвет. Причем цвет будет говорить,
что сравнивать строки мы будем по цветам. То есть, во-первых, одинаковым строкам одинаковые цвета,
разным строкам разные цвета, причем в меньшей строке меньший цвет. Ну да. Причем с сохранением порядка.
Вот. И теперь на каждой итерации, то есть, что нам надо делать? Требуется тоже вычислить те
же самые массивы a и c, но для преферсов уже не длины l, а длины 2l. Как же это сделать? Ну,
в общем-то, легко. Да, тут написан какой-то страшный текст, но краткая идея стоит в следующем,
что каждую строку длины 2l, то есть, каждая строка длины 2l – это конкотинация двух
строк длины l. И про каждую строчек длины l мы знаем ее цвет, вот эта класса эквивалентности. То есть,
по сути нам нужно просто отсортировать пары чисел от 1 до n. Сначала по первому числу,
а при равных первых – по второму. И идея в том, что мы умеем это делать. Мы уже обсуждали,
когда там год назад, даже больше, чем год назад, там соответствующие сортировки.
Мне кажется, мы не обсуждали. Обсуждали, обсуждали. Сортировки были?
У нас бы там… Бинплейс, конечно. Да, бинплейс. Сортировки? Нет. Сортировки – нет. Это все
мои подсчеты, и конкретно эти мы подробно обсуждали. Вот. И там было… Но давайте напомним,
что как отсортировать пары чисел… Пусть у нас есть n пар чисел, каждое число от 1 до n. Как
их отсортировать за линию? Для нас удобный способ будет такой. Отсортируем сначала подсчетом их по
второму символу. По второму чиселку. А потом полученный массив отсортируем устойчивым образом,
по первому. Это подсчет, когда… Подсчет – это когда у вас просто даны числа от 1 до n отсортируете.
Бакетсорт – это когда у вас даны кортежи таких чисел. То есть 2, 3, 4 и так далее. А наша цифровая
сортировка, кстати. То есть мы же так же можем строить… Если у вас там даны 100 тысяч чисел,
каждая длина 50, то вы можете их отсортировать за 100 тысяч умножить на 50. Вот ровно этим способом.
Ну там 50 будет на 100 тысяч плюс 10. Ну или сколько у вас там цифр. Вот. То есть, ну как бы,
в принципе, идея на алгоритм, в общем-то, на этом закончился. Но практически есть маленький лайфхак.
Ведь сортировка пар чисел, у вас будет что подразумевать? Она вас будет подразумевать,
что вы уже все отсортируете, что, в принципе, вы сделаете две сортировки подсчета. Правда?
Ну сначала по второму, потом по первому. Но есть маленькая неосимпатическая идея,
которая, в принципе, ваше время работы оптимизирует где-то раз в два. Она будет
сказать так, что после первого шара, на самом деле, что вам известно после первого шара? У вас есть
массив А, в котором все циклические сдвиги отсортированы по первым L символам. Правда?
Так вот, идея такая. А давайте возьмем массив А и с каждого числа вычтем L, ну с учетом за цикла.
Тогда у вас получатся циклические сдвиги, отсортированные по вторым L символам.
Но это и будет означать, что вам, в общем-то, получается, одну из этих двух фас устойчивой
сортировки делать не надо. То есть по второму мы уже отсортировали, теперь остается только по первому
сортировать. То есть получается, на каждом шаге только одна сортировка подсчетом нужна,
но правда красивая. И в результате код получается вот примерно такой.
Так, ну сейчас. Да, ну начнем вот с чего. Вот эта маленькая функция, которую я говорил. Видите, да?
Да, все-таки три строчки. Начиная с этого момента, сортируем циклические сдвиги.
Как же мы это делаем? Делаем это вот так.
Нет, вот еще вот этими.
Ну по сути да, но так как у меня передаются стринги, то я замечаю, что у меня как бы символов там не более чем 256.
Ну на самом деле даже 128, если честно. То есть я это делаю тоже честной сортировкой за линию.
Ну так, для унификации. Да, это не принципиально.
Ну так сказать, знаете, как будет. Смотрите, у вас вот этот весь код работает за n log n, да?
И вот этот за n log n. Поэтому там как бы, ну понятно, константа у этой штуки, наверное, чуть поменьше,
но я думаю, какой-то значимый процент она все-таки занимать будет, если вы n log n замените на n.
Вот так что в принципе, я думаю, какой-то профит это скорее всего даст.
Вот, впрочем, да, если строка маленькая, ну если строка маленькая, вообще можно не заморачиваться,
но может быть даже быстрее будет. Вот, ну так в принципе да, вот мы, я тут в принципе честно написал
вот эту сортировочку. Да, кстати, да, не забываем свапать вектора вот таким образом. Нет, здесь я просто
подчеркиваю, что я хочу свапать вектора так, чтобы они свапались за у от единицы, а не за линию.
Да, современный c++, конечно, свапа та это нас ведет к этому, но не современный не обязан этого делать.
То есть какой? Подожди, в 98 стандакте есть вектора? Да ладно, по-моему даже самих векторов там нет.
Да, но между 98 и 11 стандакты были. Там по-моему...
А, ну третий. Ну короче, мысль в том, что до 11-го очень долго ничего не было, потому что они готовили вот это вот.
Да, да, да. Ну может быть, но и третьим. Ну понятно. Типа люди 8 лет. Не, 8 лет готовят.
Ну правильно, нет, ну там просто по сравнению с тем, что было раньше, там действительно в 11-м революция произошла.
Ну не другой, он как бы совместим с тем, что был, но как бы...
Ну понятно. Ладно, ну я как бы да, я в принципе с тех старых времен, как вы понимаете, как вы уже можете посчитать, я как бы впервые съездил на полуфиналы CPC до того, как появился 11-й стандарт.
Не, ну дело было не в этом. Честно скажу, до Мещерина там глубоко это все не изучали на самом деле.
То есть как бы исторически там произошло просто, что на самом деле Мещерин там стал просто... То есть там изначально произвало, что вот по нашему предмету мы одновременно должны C++ изучать.
Поэтому нас было двое. Ну вот обычно у меня как бы в напарниках был человек, который брал техническую часть.
И он пришел в Мещерин и прям очень жестко взял, потому что он там в какой-то момент обнаружил, что да, потому что я это как бы так совсем глубоко не копал.
Ну вот, а он так обнаружил, что это можно сделать и копнул. Ну вот стал копать так, что вот это произвел в отдельный курс, так что кайф.
Вот. Вот так вот, значит смотрите. Значит тут у нас посортировали, ну в принципе вот это классический код на самом деле, который мы когда-то видели.
Ну и дальше возникает вот эта вот теперь классика. То есть обратите внимание, то есть мы тут в данном месте размеры корзин считаем честно,
потому что нам, когда мы их считаем, нам не важно в каком порядке перебирать суффиксы.
Но видите, когда мы Ашки берем, то есть каждый раз мы берем не АИТ вот в устойчивом порядке, а вот это вот А-Л+.
Да, кстати, важная неосимпатическая оптимизация, конечно, избавляться от этого процентика.
Потому что, видите, он N log N раз берется, и этого может очень жирно быть.
Поэтому, то есть пока я тут до предела не оптимизировал, но как бы можно написать и так.
Вот. Ну и в конце, конечно, не забыть насчитать собственно сами вот эти вот С-шки.
Вот. Так что вот такая идея. Ну в принципе есть еще, конечно, такая отсечка, что если вы поняли, что в конце, что col C равно N, то в общем-то сортировку на этом можно и закончить.
Ну вообще-то говоря, вот это как раз максимально полезная оптимизация.
Нет, ну на самом деле, ну скажем так, сформулировать так, потому что она работает, по-моему, так. То есть надо подумать, потому что есть подозрение.
Это несколько задач, в которых типа если не писать col C равно N, ну если не оптикаться по col C равно N, а прям делать честный лоу, они начинают работать несколько раз медленнее и иногда даже не заходят.
А вот это, смотри. Вот мы тут насчитываем количество новых, то есть новые цвета.
Col C это количество разных цветов. То есть если выяснилось, что у тебя разных цветов N, то в принципе уже по текущим L-символам в принципе все суффиксы оказались попарно различными.
Видимо дело в том, что типа если строчка нормальная, то будет продвигаться?
Ну да, это называется непереводимая, то в части сдачи, ну просто для нее ответ сам быстро посчитается.
Ну да, но там надо думать, потому что начинается, знаешь, какой чит. Там чит начинается, что давайте прежде чем это запускать, давайте Z функции найдем какой-нибудь минимальный период этой строки.
Хотя, кстати, ну вот.
А зачем?
А хотя, нет, не поможет.
Ну да, но к сожалению Col C для строки A, A, A, A, A, A и даже диезик он, кстати, не обвалится.
Ну это да, в принципе да. Ну тут да, то есть какие-то серьезные совпадения разных постройщик тут должны быть.
Да, ну в общем такой вот получается алгоритм. Да, мы его, конечно, немножко берло обсудили, но в общем-то да, ничего сложного в нем нет.
Чего?
Вот.
Вот.
Но заметим, что сам по себе суффиксный массив на самом деле нужен, там помогает не особо.
Ну точнее так, как с помощью суффиксного массива искать подстройки в строке?
Само, так вот ответ, само по себе никак, просто не никак, а за P log S.
Просто bin поиском для каждой строки P и нещем куда ее вставить в суффиксный массив.
Понимаете, да?
Хотя в принципе с помощью хэшей на самом деле можно это оптимизировать за P plus log S.
Да, конечно.
Ну прям конечно, прям всем очевидно, как?
Мне тоже не очевидно.
Просто сказал.
Давайте, а вот тут давайте включим свет.
Ладно, я не успел подумать, но в целом это очевидно.
Нет, ну давайте.
А вот давайте.
Так, ладно.
Вот, как говорится, замечательный вид спорта токволи. Играйте в токволи, вам понравится.
Не знаю, для этого да, для этого нужно.
Ну можно и спуск делать так-то.
О господи. Так.
По постам Марса.
Ладно, единственная проблема, что я попрошу свет включить.
Так, потому что.
Коскодирование.
Так, ладно, значит свет временно выключим.
Не понял.
Спасибо.
Нет, ну сейчас мы его обратно включим.
Но пока смотрите.
Значит, итак, как всегда.
Ищем строку P в строке S.
Так, давайте строка.
Давайте строка у нас будет какой?
Она будет черной.
Как всегда.
Как всегда, в чем-то черном мы ищем что-то рыжее.
И так, ну суффиксный массив я очень люблю рисовать вот таким вот нехитрым способом.
Ну как-то так вот.
Какие-то домики.
Ладно, эти там домики я тоже высокими нарисую.
Хотя понятно, что где-то тут домики бывают и совсем длинные, один мелкий.
Но я буду, значит, искать строку P.
То есть буду пытаться искать бенпольском, куда ее можно вставить.
Что значит искать бенпольском?
Это означает, что в каждый момент времени у меня есть такие вот суффиксы L и R.
Буду считать такие, что этот суффикс меньше строки P, а этот суффикс больше строки R.
Ну, лексерографически, конечно.
Ну, стандартный бенпоиск сказал бы, что я теперь должен взять средний суффикс между ними.
Ладно, давайте я еще поправее R нарисую.
Вот где-нибудь.
Вот здесь.
Вот.
Ну вот.
И должен теперь сравнить его и тогда в соответствии с этим сдвинуть либо L, либо R.
Я это буду делать чуть хитрее, потому что я буду подразумевать, что у меня есть не только L и R,
но у меня еще есть Lcpl и Lcpr.
Что такое Lcpr?
Это, то есть Lcpl здесь, это минимальный общий префикс вот этого суффикса и строки P.
Да, в принципе, да, мы будем, то есть можно даже сразу определение сказать,
какое-нибудь такое зелененькое, давайте напишем.
Ой, давайте вот этим напишем.
Определение.
Ой.
Видно?
Видно.
Вам видно.
А камере видно?
Да, вот во всех наборах есть вот этот маркер.
Но не всегда понятно, зачем он сдушит.
Поэтому придется взять наш любимый рабочий крестьянский маркер.
Значит, смотрите, я тут веду определение такое, давайте.
Lcp для строчек каких-нибудь там.
Я не знаю, там.
Ладно, давайте s и t.
Это минимальное такое лен.
Такое, что s от 0 до лен.
Ладно, не минимальное, а максимальное, конечно.
Там лен, значит, равно t от 0 до лен минус 1.
Догадывайте, как расшифровывается аббревиатура lcp.
List common ancestor.
Мимо.
Все равно мимо.
Только longest.
Да, longest common prefix или largest common prefix.
Да, наибольший общий префикс.
Тут все дословненько.
Вот.
Так вот.
Именно в этом месте.
Lcpl рыженьким я помечаю в знак того, что тут мы берем lcp этого суффикса и строки p.
Ну и здесь.
Ну и vary lcpr здесь.
Так вот, первая идея.
Рассмотрим случай, когда...
Мы сейчас будем рассматривать случай, когда lcpl меньше, чем lcpr.
Я выберу такой случай, потому что если он будет больше, то будем рассматривать аналогично, просто симметрично.
Во-первых, начнем вот с чего.
Я утверждаю, что lcp у всех вот этих суффиксов между lr со строкой p, хотя бы lcpl.
А как вы еще раз ввели lcpl?
Это lcpl.
Так, ну хорошо, давайте так.
Где-то у меня тут нот.
То есть, да, у меня тут есть пассив sa, и теперь утверждение.
В плане левой правой утверждения по первому l.
Нет, это граница бинпоиска.
То есть, допустим.
Смотри, пишу так.
Пишем invariant.
Значит, я знаю, что s от saL, модуль s-1 меньше p, меньше, чем s от saL, модуль s-1.
Давайте вот так сделаем.
Это первый invariant.
Второе.
Еще я знаю, что lcpl это равно lcp от этого l, этого суффикса, saL, модуль s-1 и p.
Что?
sa, suffix array.
Да, sa это суффиксный массив.
Да, давайте я тут еще и черненьким напишу.
Почему черненьким?
Потому что суффиксный массив ни от какого бинпоиска, естественно, не зависит.
В общем, тогда правильнее было бы вообще вот так написать, конечно.
Но это ладно, совсем уж так переписывать не буду.
А это какое алгоритм сейчас происходит?
За p-logs или за p-plus-logs?
Вот я пытаюсь с помощью хэшей сделать за p-plus-logs.
Ну просто p-logs это мы бы просто не заморачивались.
Мы просто делали logs страции бинпоиска и saL от p.
Но мы сейчас с помощью хэшей, а в будущем и без хэшей, как вы догадываетесь, на самом деле...
Так, ну здесь то же самое, только вместо l у меня r.
Вот. То есть вот такой вариант.
Я хочу поддерживать, то есть я хочу в бинпоиске поддерживать lcpl и lcpr.
Короче, по смыслу...
Ну, по смыслу...
Да я правильно понимаю, что мы просто поддерживаем левый и правый суффикс,
которые совпадают с первыми...
Самый левый и самый правый суффикс, которые совпадают с первыми и символами строки p?
Нет.
Напоминаю, у нас бинпоиск.
Ну я не знаю, просто по идее вот эти слова уже должны объяснять, что такое lr,
но если нет, значит видимо у тебя какое-то очень извращенное понимание бинпоиска.
Потому что обычно в классическом...
Когда ты в бинпоиске в массиве что-то ищешь, у тебя в каждом время говоришь то,
что ты ищешь, что находится между l элементом массива и r элементом массива.
То есть по смыслу...
Вот это отражает инвариант.
То есть тут написано следующее, что вот этот суффикс меньше строки p,
а вот этот суффикс больше строки p.
Это пока все, что мы знаем.
Нет, еще мы знаем lcp между l суффиксом и p и lcp между r суффиксом и p.
Мы эти числа будем поддерживать.
Так вот, я предположил, что lcp меньше, чем lcp, считаю, что второй случай симметричен.
Так вот, утверждение такое, рассмотрим все суффиксы между l и r.
Я утверждаю, что lcp у каждого из этих суффиксов с p, как минимум, вот столько.
Но причина очень простая.
Если суффиксы отсортированы, у этого суффикса эти символы совпадают с префиксом p,
и этот вот префикс совпадает с префиксом p.
Следовательно, по сортировке получается, что у всех вот этих вот суффиксов,
у каждого lcp символов такие же.
То есть, значит, тут как минимум вот столько будет.
Я просто смотрел сверху вниз, а не снизу вверх.
Нет, давайте, смотрим снизу вверх.
То есть, как начало снизу.
Тут подразумевается, что тут единый уровень, на самом деле.
Это диаграмма по количеству.
Видимо, надо было нарисовать, потому что суффиксный массив в строте Аббатсабы я себе воображаю вот так.
Сверху вниз никогда не знал.
Подожди, у тебя суффиксный массив, вот он слева направо написан.
А мы каждый индекс раскрываем его соответствующий суффикс.
Ну куда нам его раскрывать? Вверх.
Так, вот смотрите, вот я себе суффиксный массив вот так воображаю.
Это суффиксный массив в строте Аббатсабы.
Все снизу вверх.
Снизу вверх, слева направо.
Вот.
Да ладно, задачи про референдум как рисовали.
Какую задачу про референдум?
Да ладно.
Это как тебе объясняли?
Да ладно, это где интересный...
У нас дерево календромов про референдум.
Нет, вопрос в другом.
Это где же так рассказывают задачи про суффиксный массив,
где не рассказывают задачи про референдум?
Это, по идее, обычный стандартный план лекции.
Расскажи про суффиксный массив, расскажи про лца, расскажи задачи про референдум.
Если это было года четыре назад, то...
Нет, просто там очень интересно,
что задача про референдум как бы обошлась без этой картинки,
на которой как бы прямоугольник рисуется.
Ну ладно, дойдем до этого.
Хорошо.
Нет, это просто методология очень интересная,
просто я такого не встречал.
Вот.
Ладно, смотрите.
Хорошо.
Итак, LCPL везде совпало, да?
Да.
Так вот.
Ну идея у нас какая?
Вообще мы берем вот какой-то мид,
то есть мидовый суффикс, так его и назовем.
Вот мид.
И теперь нам нужно найти теперь LCP mid.
То есть какая-то вот такая мечта.
То есть найти тут какой-то LCP mid.
И следующий несовпадающий символ
с соответствующим силой строки P
и сравнить и в соответствии с этим понять,
пойти влево или пойти вправо.
Идейно нам нужно вот это, правда?
Но в принципе, если у нас есть хэши, кстати,
этот LCPL mid можно найти было бы и пенпоиском, правда?
И в принципе тогда алгоритм у вас бы работал
за P плюс лог модуль S лог модуль P.
Да, почему P?
Чтобы хэши для строки P насчитать, естественно.
А хэши для строки S придется насчитывать
в предподсчете изначально.
Мы хотим найти, где больше СПД или что?
Нет, мы хотим вот дан мидовый суффикс,
вот этот L plus R пополам, да?
Надо найти LCP mid, а зная LCP mid
мы можем за вот единицы сравнить этот суффикс
со строкой P.
В смысле, за вот единицы?
А, хэшами?
Нет, причем это хэши.
Так, утверждение.
Если вы у двух строк знаете их LCP,
то сравниваете стихографически, вы можете за вот единицы.
Хорошо.
А, вы ищете, вы сначала нашли LCPL?
Да.
Если вам его с небес по факсу прислали,
то надо просто вот этот символ,
учитывая, что у нас 0 линдексация,
тут посравнить у строк S и T.
У кого меньше, тот и меньше.
Все.
Обязательно ли LCP mid будет выше, чем LCPR?
Вот.
А вот это и магия.
Вот в решении за такое симпатическое нам плевать.
Потому что мы можем вот этим фактом про LCPL
даже не пользоваться.
Просто bin поиском найти и все.
Ну и с хэшами, да?
Ну, мы попытаемся обойтись.
Ну, мы попытаемся урезать хэши.
Ну, пока совсем не избавимся,
но потом с помощью массива LCP мы избавимся.
Смотрите.
Вы правильно заметили, что ключевой вопрос для нас будет такой.
А этот LCP mid выше, чем LCPR или нет?
Ну, потому что, смотрите, тупой алгоритм мог быть так.
Давайте LCP mid найдем в тупую, начиная с LCPL.
Вот прям в тупую.
То есть вот до этого момента точно совпадает,
а дальше идем, идем, идем, идем, идем.
Вот.
И тогда в какой-то момент остановимся,
ну и пойдем там влево или вправо.
Ну вот.
То есть в принципе такой алгоритм тоже будет работать,
даже без всяких хэшей, обратите внимание.
Но вопрос только за какую симпатику?
Потому что очень хотелось бы сказать.
Ну вот.
Ну, потому что что очень хотелось бы сказать?
Ну, в идеале кажется, что действительно какая нам разница?
То есть можно заметить, что если мы от LCPL,
а тут идем, идем и не сильно далеко дойдем,
вот LCP mid тут окажется ниже, чем LCPR.
То мы заведомо пойдем вправо, правда?
И тогда у нас получится LCP mid и LCPR,
и получается, что LCPR не поменялся,
а LCP mid увеличился на столько шаров, сколько мы сделали, правда?
То есть попахивает как...
Ну потому что, смотрите, у нас есть два суффикса.
У большего из них совпадает LCPL символов.
Вот.
А у меньшего из них совпадает меньше символов.
Так вот, наверное, есть подозрение, что P будет больше этого суффикса.
Вот.
Поэтому если LCP mid окажется меньше, чем LCPR, конечно, да?
То есть попахивает какой-то амортизацией, правда?
Правда, есть одна маленькая подлянка.
Что делать, если LCP mid больше?
Ну, в общем-то, тоже кайфец.
Если мы пойдем вправо, то в принципе кайфец.
Потому что мы сделали вот столько шаров
и увеличили LCP mid.
Ну, в общем-то, тоже кайфец.
Если мы пойдем вправо, то в принципе кайфец.
То есть мы сделали вот столько шаров и увеличили LCPL на это, да?
Но подлянка заключается в том, что мы,
если LCP mid больше, чем LCPR, то ничто нам не мешает пойти влево.
Там всякое бывает.
Но тогда, смотрите, тогда с потенциалом у нас возникнут трудности.
А именно, то есть мы сделали шаров вот аж настолько,
а потенциал увеличился там только настолько.
То есть получается, вот эти вот походы между LCPL и LCPR
мы должны как-то оплатить.
То есть как вот это неоплачено.
Что же делать?
А потенциал у вас просто сумма.
Ну, типа да.
Ну, это даже формально не совсем потенциал, конечно, да.
Да, ну вот.
Но идея, на самом деле, очень простая.
Смотрите, мы здесь воспользуемся хэшами
чисто внутри строки S.
То есть для строки P мы даже не будем насчитывать хэши.
А идея будет такая.
Неверно ли, случайно?
То есть для этого, на самом деле, идея такая.
Давайте посмотрим на уровень LCPR и попытаемся сравнить.
А LCPL имеет он больше LCPR или меньше?
Как это сделать?
Значит, просто надо сравнить.
Верно ли, что вот эта строка равна вот этой строке?
Заметьте, это можно сделать чисто внутри строки S.
Обратите внимание.
То есть для строки P даже хэши уже больше насчитывать не надо.
И тогда, если LCPR как минимум стока,
то начиная с этого момента насчитываем в тупую.
И тогда с потенциалом все в порядке.
А если он меньше, то тогда насчитываем его в тупую, начиная с LCPL.
Но тогда эта сумма LCPL плюс LCPR точно будет увеличиваться ровно на это.
То есть таким образом мы убили.
Нет, не это мы убили.
Вот это мы убили.
Вместо этого остается только лог S на сам Бинпоиск.
Плюс P остается, потому что за P мы теперь считаем не хэши для строки P,
а два указателя, вот эти.
Понятна логика, да?
То есть по большому счету в этом алгоритме
на самом деле нам единственное, где от нас вот эти хэши,
где нужны хэши, то есть нам нужен это небеса,
то есть где нам нужны небеса и факс.
Только для того, чтобы вот, для отвечать на вот такой запрос.
Даны две подстроки строки S, скажите, пожалуйста, равны ли они.
На этот раз просто да или нет
Даже не по строке, а два суф 모양?
Нет, это префиксы двух суффиксов.
Но префикс суффикса это по сути подстрока.
То есть по сути нам хочется...
Если бы мы хотя бы научились отвечать на запрос данные две строки,
вот задаются двумя парами индек disastров, скажите, пожалуйста, равны ли они, да или нет.
Если бы мы научились это делать без хэшей, то мы в принципе вот этот бинпорк забабахали бы без хэшей.
Как же это сделать?
А сделается это с помощью достаточно классической штуки.
Конечно, знаменитый массив ЛЦП.
То есть тут у нас появляются, это конечно неполиткорректно поговорить, но с другой стороны точнее как 5 азиатов, это не назовешь.
Мне кажется, что кок не азиат.
Чего?
Нету там никакого кока.
Нет, если ты имеешь в виду алгоритм кока-янгера-косами, то он к этому не имеет отношения.
Вот.
То есть на самом деле будем, будем, будем, просто я это на презентации сделаю.
Когда?
Сегодня.
Сегодня кончается через 9 минут.
Ой, да мы быстро, господи.
Стоп, в смысле как вы, то есть вы нам покажете за быстро построение сапмасса за ОАТН?
Нет, нет.
Нет, этого я вам уже не покажу.
Не, не волнуйтесь.
Нет, по сути я с вами должен сейчас обсудить только ЛЦПшки, как их построить, ну и быстренько задать про рефрен.
А, ну все тогда.
Вот.
Но это, но это я вас уверяю, это не сложная вещь.
Так, во-первых, смотрите, тут для этого мы вводим определение, то есть такое.
То есть давайте, то есть я ввожу такой массив ЛЦП от нуля до модуля с минус два,
где я говорю, что ЛЦП ИТ это будет просто ЛЦП двух суффиксов ИТ и плюс первого.
Там модуля с минус один.
То есть вот определение вот такое.
С, СА и плюс один.
Там модуля с минус один.
Вот.
То есть вот, предположим, что у меня вот такой массив откуда-то нарисовался.
Вот, например, если у нас тут вот суффиксный массив для аббатсаба это шестьсот сорок двадцать пять тринадцать,
то, смотрите, вот смотрите сейчас сюда на картинку, как я его себе здесь воображаю.
Вот, я его воображаю как тринадцать десять двадцать.
Вот так видно, да?
И здесь я, в общем-то, его себе воображу ровно таким же способом.
То есть как-то вот так, вот так, там вот так, вот так, там может быть,
то есть я не знаю, там вот так, ну и тут, скорее всего, там как-то вот так и вот так.
Ладно, и вот так.
Видно, да?
То есть вот так я себе воображаю ЛЦП.
Теперь предположим, что их нам пристали с небес по факсу.
То есть на презентации чуть позже мы, ну, как минимум, заметим, кстати, для простоты,
там в какой-нибудь школе n log n, вам могут, например, даже еще и подробно рассказать,
как это за соответствующую симпатику найти бин поиском и хэшами.
Ну типа, учитывая, что у нас СУФМА строится за n log n.
Ну да.
Но правда нет, они там, как кому-то, они, кстати, СУФМА за n log квадрат бин поиском и хэшами рассказывали,
считали, что этого достаточно.
Кто они?
Ну, те, кто потом, ну, школа n log n.
Что за школа?
Какая, какая?
Ну есть такая школа миссисофты, ну есть такая школа миссисофты делают.
Она так называется?
Школа n log n, да.
А?
Нет, у них, в принципе, еще даже, можете найти, даже там n log n contest info, это вообще классная тестирующая система.
Ну как тестирующая система?
Она не тестирующая система, она, скажи так, она сама мало чего тестирует, она умеет как бы, как бы,
брать задачи с какими-нибудь там код форсисов, яндексов и прочего и посылать их в соответствующую систему.
То есть она так.
А еще она умеет по ним хорошо искать.
То есть в принципе, если у вас задача собрать, то есть она как бы умеет, то есть удобно как бы собирать мэшапы,
если вы хотите собирать их не только с код форса, а там, скажем, с код форсиса, яндекса, там, тимуса и так далее.
То есть на самом деле классная вещь.
Если б не глючило, конечно.
Да, да, да.
Вот, но это так.
Так вот.
Но не важно.
Чуть позже мы скажем, как это, там, как бы придут пять изиатов и скажут, как, собственно, эту штуку искать за линию,
если у вас уже есть суфмасс.
Все без всяких хэшей и очень простым алгоритмом.
Но предположим, что эта ЛЦПшка у вас есть.
Тогда есть ключевое утверждение.
Утверждение говорит следующее.
Что пусть у вас, допустим, и меньше жи.
Тогда, если вы хотите найти ЛЦП двух суффиксов,
и этого в суффиксном массиве,
и житого,
и житого,
то он просто равен минимуму из ЛЦПитого,
ЛЦПи плюс первого и так далее,
ЛЦПжи минус первого.
Вот такое мистическое утверждение.
Оставлю в качестве упражнений убедиться, почему это так.
Ну, в принципе, понятно, что ровно столько символов у всех совпадает.
Получается, по вот столько плюс первому они все отсортированы,
и поэтому там и получается.
В принципе, что нам дает это утверждение?
Утверждение дает, что если вы хотите сравнить две какие-то подстроки одинаковые,
то вы можете сделать это.
Что нам дает это утверждение?
Утверждение дает, что если вы хотите сравнить две какие-то подстроки одинаковой длины,
то вы говорите, так, берем суффиксы,
которые начинаются с них, смотрим, в каком месте они начинаются в суффиксном массиве,
ну, там обратную перестановку можно предподсчитать,
и ищем минимум на отрезки.
Если вы хотим делать за от единицы, то просто на этих ЛЦПшках вам, по сути,
надо SparkStable насчитать.
Или, ну, можно в фарах Колтенбендера, но вы все равно уже многое на обстрельнее сухмасса потратили,
так что не важно.
Да, то есть, в принципе, такая, есть такая, какая теоретически мощная комбинация.
Суффиксная массив, ЛЦАшки и Спарсы на них.
ЛЦАшки.
То есть, ЛЦАшки и Спарсы на них.
Ну, вот, то есть, в принципе, это мощная комбинация,
которая, в принципе, позволяет кое-что решать.
Вот.
Ой, можете, кстати, ту задачку на дерево палендровых,
кстати, попробовать решить с помощью этой комбинации, кстати, она решается.
Правда, без хэшей вы там, по-моему, не обойдетесь, но не важно.
Вот.
Так вот.
То есть, теперь вы вот, то есть, в принципе, что эта штука делает?
Тогда получается вот эту вот задачу, получается, сравнить две подстроки,
то есть, вам теперь, получается, вы с помощью этой комбинации делаете очень легко.
Понимаете, да?
Вот.
Что еще?
Ну, вот.
Ну, в принципе, да.
То есть, с помощью ТЛЦПшки вам становится очень легко решать даже задачу про рефрен.
Вот давайте вспомним, да, мы уже обсуждали.
Вот задача про рефрен говорит так.
Найдите подстроку такую, что ее длина на количество вхождения в строку С максимально возможна.
Да.
Но если вкратце, то заметим следующее, что суперсы, которые начинаются с вхождения одной же, той же подстроки,
они здесь идут подряд.
То есть, они идут, обратите внимание, они идут как-то подряд,
при этом не просто подряд,
а заметим, что их вхождение образует вот такой прямоугольник,
который находится, у которого верхняя граница не выше, чем вот эти вот ЛЦПшки в промежутках.
Видно, да?
Тут я не там нарисовал.
Причем, по большому счету, заметим, что этот прямоугольник всегда можно прям упереть в один из промежуточных ЛЦАшек, вот этих.
То есть, по большому счету, вам нужно найти вот такого рода прямоугольник в максимальной площади, правда?
Как его это сделать?
Ну, в принципе, да, достаточно просто.
То есть, на самом деле получается, что высота его должна упираться в какой-то ЛЦП.
Давайте переберем вот в эту ЛЦПшку и скажем, какой максимальный прямоугольник будет упираться именно в эту ЛЦП.
Но для этого нужно пойти вправо и слева найти ближайшую ЛЦПшку, которая меньше.
Строго меньше.
А тут найти ближайшую ЛЦПшку, которая тоже строго меньше.
И дальше начинается стандартная задача, вида дан массив.
Для каждого числа найдите, пожалуйста, слева ближайшая, которая меньше.
Ну, надеюсь, не надо расписывать, каким стэком это делается, да?
Или надо?
Почему отвратительная?
Да ладно, со стэком очень легко.
У вас возникали проблемы с тем, чтобы написать какие-то форумы.
Нужно аккуратно вывести, идти с конца или сначала, нужно аккуратно вывести, брать меньше или больше?
Ну, что делать?
Потому что я боюсь, вот такие методы еще там, на олимпиадах до восьмого класса, как бы, задачи будут просто на это давать постоянно.
Типа да, их дают постоянно и понятно, но приходится каждый раз, типа...
Ну да, ну что делать?
Ну окей, ладно.
Ну вот, в принципе, классическое решение задачи на референ на самом деле вот такое.
Если хотите попроще, пожалуйста, пишите суффиксное дерево или там, или даже суфо...
А, ну, кстати, пожалуйста, можете суфо-автомат с динамикой написать.
Да, суфо-автомат с динамикой тоже, пожалуйста, все что угодно.
Да.
Ну, на ваше усмотрение.
Хотя суфо-автомат, в общем-то, по коду пишется, кстати, по-моему, примерно так же, как суфмасс плюс ЛЦП.
Вот.
Так же, но соответственно.
Так, это мы проговорили про задачу референ.
Более того, прежде чем я сейчас выключу свет и мы покажем, как эти ЛЦП-шки искать, я, конечно, должен отметить еще одну.
Надо обсудить, как на самом деле быстро построить суффиксное дерево.
Ага.
Ну, глядя на эту картинку, вы уже догадываетесь, как построить суффиксное дерево.
А, ну, собственно, вот эти ЛЦП-шки...
Да.
То есть, на самом деле, если вы будете добавлять суффиксное дерево суффикса именно в этом порядке, то эти ЛЦП-шки вам в явном виде показывают, где вы должны ответвиться.
То есть ключевое соображение, когда вы будете искать это место ответвления, вы должны в суффиксе идти не от корня к листу, а, наоборот, от листа к корню.
Понимаете почему, да?
Так, понимаете почему?
Так, не надо.
Но там просто идея в том, что...
Но там два варианта.
Либо у вас как бы этот соответствующий путь по количеству ребер будет как бы в стеке, и вы ребрами выкидываете.
Ну, либо можно еще говорить так, что вы, по сути, это дерево просто ДФС-ом пройдете.
Потому что у вас есть текущий суффикс, и вы идете как бы от листа, идете вот сюда-сюда-сюда, и в этом месте ответвляетесь, и идете сюда.
Вот.
Ну, тут много классики, конечно.
Потому что классическая задача, я вам рекомендую, не буду сейчас рассказывать, но вообще, знаете...
Ну, во-первых, как бы всеми этими способами легко решить какую-нибудь задачу в духе о сколько различных подстрок в строке, правда?
Ну, здесь очевидно это как делать через лца, можно там в суффиксном дереве это делать.
А есть более веселая задача.
А теперь дана строка, и у вас есть запросы.
Пушбек в строку.
Ну, во-первых, просто, смотрите, дана строка, у вас есть запросы. Пушбек в строку и найди количество различных подстрок.
Ну, в автомате сложнее, а вот в дереве на халяву.
Потому что поддерживать в дереве суммарную длину листов, как бы, никаких, суммарную длину рыбек, никаких проблем нет.
Вот.
Да.
Но на самом деле есть более крутая задача.
Когда у вас есть запросы, пушбек и попбек, такая антиамортизация.
Пушбек, попбек, и после каждого запроса вы видите, что у вас есть запрос.
А если у вас есть запрос, пушбек и попбек.
Пушбек, такая антиамортизация.
Пушбек, попбек, и после каждого запроса вы видите, сколько у вас подстрочек.
Не, ну там может быть персистент.
Хе-хе-хе.
Вот задача.
Как написать этого персистентного укранина?
Персистент, амортизация и не укранина.
Вот.
Ну да.
Могу только в качестве маленькой подсказки, почему вспомнил об этой задачи именно сейчас, а не в теме про укранина.
Хе-хе-хе.
Шикарная задача.
Ну там попробуйте сами подумать, а потом расскажите.
Если не придумаете, отдельно расскажу.
Шикарное решение, на самом деле.
Хе-хе-хе.
Ладно.
Но закончим и сегодня не едем.
Сейчас я вас попрошу снова выключить свет.
Ой.
Двойник свектового.
Мы не будем обсуждать, сколько я умираю.
Потому что это вообще не связано.
Потому что это алгоритм.
Извините.
Так.
Вы его будете обсуждать в формалках.
Можешь включить на сколько-то?
Сейчас я включу его.
А, там проектор включится?
Да, я сейчас проектор включу, конечно.
Я видимо название перепутал просто.
Не-не-не.
Это задача вида, что дана грамматика, скажи...
Дана грамматика, дано слово, скажи, пожалуйста.
Слово вылезает в грамматике или нет.
Причем желательно...
Причем алгоритм еще, по-моему, требует, чтобы она была еще в адекватной форме Хомского.
Вот.
Ну, если она в адекватной форме Хомского, то это как бы по нашим...
По олимпиадным меркам это стандартная ДП-шка.
Так.
Так, давайте не путать Накамуру и Аримуру.
Это разные люди.
Слушай, а как бы Накамура не занимается алгоритмами.
У него нет времени.
Он там сидит в интернете и стримит, как он в блице играет по шахматам.
На самом деле...
А еще в перерывах он там на текущий момент второй в мире по классическим шахматам.
На самом деле, как ни странно, есть Рэнзист.
Самый великий Рэнзист.
У него там стоя одна потрясающая задача.
Абсолютно не поднимаем, он очень красивый.
Ну окей, хорошо.
Ну это хорошо, но я боюсь, как бы это не тот Накамура.
Эх, Накамура.
Ну хотя малый, потом тут Накамура.
Еще вопрос откуда.
Шахматы Накамура, он, как известно, американский.
Ну да.
Как это классика.
Да, американские.
Да, эти замечательные американские шахматисты.
Там ведущие.
Это называется Накамура.
Фабиана Каруана.
Кто там еще есть?
Левон Оранян, конечно.
Ой, кого там только нету.
А, Уэс Лисо, конечно.
Ха-ха-ха.
То есть, в общем, Ханс Ниммон там.
Не, Ханс Ниммон тоже такое имя не совсем американское.
Ладно.
Так вот.
Ну у нас, значит, ой.
Что за...
Так.
Да, это у меня тут определение, кстати.
Вот.
Ну и здесь все просто.
Ну а это все про ЛЦПшки.
Тут даже доказательства есть при желании.
Так что можете там их почитать.
Бла-бла-бла.
Бла-бла-бла.
Бинпоиск.
Ой, не понял.
Это как вообще?
А.
Так, нет, что-то самовал горит, но тут как будто нет.
Странно.
Ладно.
А вот он, потому что вот он.
Во.
Да.
Значит, смотрите.
Итак.
А, уже убегаешь?
Ну я только знаю.
Ааа.
Так может все знают его?
Ты не знаешь Супмасс, но знаешь ЛЦП.
Хороший.
Ну окей.
Ну ладно, Лед.
Ну окей, хорошо, хорошо.
Да, ну может ты это Хэшами Бинпоиском пихнул.
Внухо, молодец.
Хорошо.
Так, ну во-первых, смотрите какое интересное утверждение.
Вот.
Во-первых, конечно в этих леммах вводится понятие поз ИТ.
Это типа где находится ИТ-суффикс в суффиксном массиве.
Но обратная перестановка та самая, да?
Так вот, идея такая.
Давайте будем искать ЛЦП-шки именно в этом порядке.
То есть сначала для поз нулевого, потом для поз первого и так далее.
Ключевое утверждение говорит о том, что каждое следующее это не менее, чем предыдущее минус 1.
Ну в принципе я думаю достаточно очевидно, что если мы в это поверим, то тупой алгоритм поиска ЛЦП, который будет пользоваться этим, сработает за линию, правда?
Ну потому что у нас есть какая-то текущая влечина.
Изначально 0, всегда не меньше n.
Значит уменьшается она не более чем n раз.
Следовательно увеличивается она не более чем 2n раз.
Ой тут даже кода нету, жалко.
Все что нам остается это утверждение доказать.
Ну утверждение доказывается, да тут написано опять какой-то текст.
Да, легче было конечно свет не выключать.
Ну потому что идея в общем такая.
Рассмотрим этот ИТ-суффикс.
А, вот здесь я даже свет не надо включать на самом деле.
Да, как это часто бывает в строчках, тут написано какой-то текст.
Давайте-ка я сейчас на доске просто нарисую, что он значит.
Так, где я нарисую?
Ну где-то здесь я нарисую, короче.
Смотрите.
То есть идея на самом деле просто так.
То есть идея на самом деле простая.
То есть жил был...
То есть жил был у нас тут какой-то суффиксный массив.
Допустим жил был у нас тут ИТ-суффикс.
Вот эта вот позиция posi.
И у него lcp было где-то здесь.
Это был суффикс номер.
Это был posi и ты-суффикс.
Это был там pos от какого-то икса.
Допустим, да?
Ну, во-первых, смотрите.
Если это lcp было равно нулю, то утверждение очевидно, правда?
Ну, потому что как бы такая lcp следующая больше, чем минус один.
Ну, да.
Но если оно оказалось больше нуля,
то тогда оказывается, что у этих товарищей совпадают первые буковки.
Ну, там, ладно, пусть они будут d.
Тогда смотрите.
Что делать, если взять у этих двух суффиксов и отпилить две буковки?
Тогда окажется суффикс номер posi...
То есть какой-то и плюс первый суффикс и икс плюс первый суффикс.
И плюс первый будет меньше, чем икс плюс первый, правда?
То есть это означает, что pos и плюс один будет где-то тут в массиве находиться.
Неважно слева-справа от них.
Но главное, что где-то справа от него будет pos икс плюс один.
То есть самое главное, что вот этот правее этого.
То есть они могут казаться оба правее вот этих двух, могут оба левее.
Может этот левее, этот правее.
Может кто-то из них даже с кем-то совпадает, кстати, вполне.
Но это не важно.
Вот этот правее этого.
Но смотрите, если этот правее этого и между ними...
Но тогда между ними lcp хотя бы столько минус один.
То есть если вот тут lcp равно l, то тут уж хотя бы l минус один точно есть, правда?
Ну точнее вот между ними lcp l минус один.
Но тогда мы гарантируем, что между этим и следующим точно уж хотя бы l минус один да есть.
А может и больше.
Ну все, доказательство окончено.
Все, мы победили.
Собственно, не сильно сложная победа оказалась.
Ну в общем-то по сути это все, что я должен был рассказать про суффиксный массив.
Так что да, ладно, до дерево тандемных повторов, к сожалению, не дожили.
Увы, жалко.
Ну вот, ну ничего страшного.
Ну вот.
Ну ладно, потому что в следующий раз никакого дерево тандемных повторов не будет,
потому что времени уже мало, придется начинать геометрию.
И так уже опасаюсь, что не придется в какой-нибудь понедельник и дополнительно собраться.
Вот.
Очень надеюсь, что не придется.
