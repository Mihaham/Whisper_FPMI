Закончим эту самую теорему, значит, теорема говорит, что для, если, следующее, следующее утверждение эквивалента.
Значит, первое утверждение, а перечислимо. Второе, существует f из n в n, частичная функция f, вычислимая.
Такая, что domain f равен 2, а третья, а существует f, частичная, f, вычислимая.
Такая, что range f равен, а вот в четвертом пункте я в прошлый раз сделал небольшую, короче, не совсем корректно сформулировал, потому что я забыл записать одно условие, при котором это выполняется.
Почему, собственно, вот этот пункт все еще нужен? Потому что здесь не всегда такая тотально вычислимая функция существует, а только если a не пусто.
Для пустого, конечно, тотально вычислимая функция, у которой range пустой, не бывает.
Значит, если a не пусто, то существует тотально вычислимая функция f из n в n.
Такая, что range f равна a.
Ну и последняя, пятая, существует вычислимая под множество, существует разрешимая, существует разрешимая b,
под множество n² такое, что a есть проекция на первую координату b.
Что мы доказали? Один эквивалент на два доказали, один эквивалент на три я хочу доказать по-другому, потому что я усложнил это доказательство.
Нет, в обратную сторону, из 3 в 1, как мы доказывали?
Я там как-то какую-то тотально вычислимую номерацию придумал, на самом деле там это все не нужно.
Из 1 в 3 я усложнил, слишком усложнил, то есть предъявить нужно функцию, у которой range f равна a.
Из 3 в 1, да, я сослался, я помню.
Из 1 в 3 я усложнил, то есть на самом деле очень простая функция вычислимая, у которой range f равна a.
Знаете какая? Какую я привел?
А, это, я это сказал, да? Извините, тогда все хорошо.
То есть 1-2 эквивалентно мы доказали, 1-3 эквивалентно мы доказали, 1-5 тоже, или что, где мы закончили?
То есть, вот это да, я знаю, знаю, это осталось, я помню.
Это осталось, так, то есть осталось у нас из 5 в 1, да, что проекция разрешима.
Ну давайте, значит, как мы будем перечислять проекцию?
То есть существует разрешимая b под множество m квадрат такой, что a проекция на первую координату b.
Вот, значит, смотрите, как доказать, что разрешима перечислима?
Ну, собственно, в этом суть утверждения, да?
Ну, как перечислить проекцию?
Ну давайте просто, у нас же разрешима b, будем перебирать пары, ну не знаю, по номерам просто.
Сначала первую, у нас есть тотально вычислимая номерация, можно в принципе в любом порядке перебирать пары n квадрат.
mn из n квадрат, в любом порядке.
Если и проверяем для каждой пары, принадлежит она b или нет, проверяем mn принадлежит b или нет.
Вот, если принадлежит, то выписываем первую координату, если не принадлежит, к следующей паре переходим, и так далее.
Поняли, да?
Если mn принадлежит b, то печатаем m.
Иначе переходим к следующей паре.
Ну, собственно, все, таким образом мы проекцию перечислим.
Понятно?
Ну хорошо, пример множества, для которого множество b из n квадрат, для которого проекция только перечислема, но неразрешима.
Наверное, может быть, на этой, может быть, на следующей лекции даже дадим.
Ну, ссылаясь на вот это утверждение, на самом деле.
Значит, смотрите.
Ну, теперь 1,4.
Смотрите, а перечислимо и а не пусто.
Вот, а перечислимо, а не пусто.
Пусто множество тоже перечислимо, я про это вам говорил.
Перечислитель там забавный, это программа, которая ничего не выводит, но работает бесконечно долго.
Ну, понятно, что тотально вычислимые функции, которые range пустой, нельзя придумать, в принципе.
Но она не будет тотально вычислимой.
Поэтому с этим проблема, то есть здесь нужно требовать, чтобы они пусто были.
Ну, хорошо.
Тогда, на самом деле, вот такая конструкция.
Строим следующую.
Пусть к.
Самый первый шаг.
На котором перечислителя вывел какое-то число, но самое первое число.
На котором перечислителя вывел первое число.
k – это шаг, на котором появилось самое первое число перечислителя.
Тогда f0 – это то число, которое на катом шаге было выведено.
Число, появившееся на перечислителе.
На катом шаге.
А вот дальше, давайте скажем вот так.
f1 – это последнее число, которое появилось на перечислителе на k-plus первом шаге.
Ну, или до, или раньше.
Последнее число.
Число выведено перечислителем на k-plus первом шаге.
До k-plus первого шага.
Включительно.
Ну и так далее.
Вот сюда вот переведите.
f at n – это…
Подождите.
А?
На k-plus n, до k-plus n-го шага, да, наверное так.
Последнее число.
Последнему числу, которое было выведено…
Подождите, проверю, что у меня сомнения появились.
А, да, все правильно.
Последнему числу, выведенному перечислителем.
До k-plus n-го шага.
Ну, то есть он дальше будет печатать, да, может там следующее, следующее.
Но вот как выглядит эта функция?
Она в нуле – это самое первое число, которое будет выведено.
А потом, потом вот расстояние по шагам между первым и вторым
будет то самое первое число постоянно в качестве значений, да.
Потом второе число, которое было выведено, и так далее.
Если множество конечное, то это будет там дальше
бесконечный хвост из одинаковых значений, да.
И эта функция тотального числима понятна, да, почему.
Просто очень вполне разрешимое свойство.
Нужно количество шагов сделать, посмотреть последнее число, которое появилось.
Правильно, ребята?
Вот.
То есть вот она, тотально вычислимая функция из n-vent,
такая же, что rangef равно a.
Такая вот конструкция, красивая, да, ребят?
Вот.
Из 4 в 1.
Ну, то, что область значений вычислимой функции перечислима,
в данном случае даже очень понятно, почти как перечислять
эта область значений.
Тут даже, она же тотально вычислима, то есть тут даже изгаляться-то не надо.
Можно просто по очереди брать натуральные числа, вычислять значения
и печатать их.
Вот все.
Вот вам перечислитель.
Это просто вычислимая функция, тут нужно было стараться,
нужно было вот эту тотальную нумерацию брать,
делать какое-то количество шагов, потому что если
функция не определена, в какой-то точке вы закончите число шагов,
вы это не выясните, это неразрешимое свойство.
Вот.
Поэтому приходилось, собственно, перебирать, делать какое-то
количество шагов алгоритма, если он вывел, только тогда печатать.
А вот здесь стараться даже не надо, оно всегда закончится
в любом натуральном числе.
Вот.
Поэтому перебираем все n,
все n из m,
вычисляем
f от n
и печатаем.
Все.
Вот это свойство удобное, вот это конкретно свойство удобное,
но правда, видите, нужно не забывать, что для множества
должно быть не пустые.
Вот.
Ну хорошо.
Теорема 2.
Давайте небольшое определение дадим.
Определение.
Дана вычислимая функция,
дана вычислимая функция f.
Ну давайте просто дана функция f,
частичная функция f.
Ее графиком,
ее графиком
называется множество.
Гамма от f,
которая есть
множество пар m, n,
n, m, давайте вот так,
n, m из n квадрат.
Такие что
f, m равно
f от m.
Ну понятно, в всех точках
n из domain f.
Вот.
График функции.
Множество точек,
точек на плоскости, собственно говоря,
первая координата x,
вторая f от x,
но только для тех точек,
которых определена, конечно же.
Вот.
Давайте теперь теорема 2.
И вам.
Функция f
из n
в m
вычислима
тогда и только тогда,
когда ее график
перечислим.
Это вот такой вот критерий.
Ну давайте докажем.
Ну,
как ни странно, вот в эту, в прямую сторону,
то есть нам известно, что функция вычислима,
график,
тогда график перечислим.
Несколько сложнее будет доказать.
Ну смотрите, можно
теперь вот на ту теорема 1,
которая сейчас такой стер,
сослаться.
Вот, значит,
ну давайте смотреть.
Есть такое читерское доказательство,
но давайте попробуем его привести.
Значит,
f
из n
вот в эту сторону,
то есть мы знаем, что она вычислима.
Известно, что она вычислима.
Тогда и domain,
и range, область значения, область определения, они перечислимы.
Мы это доказали вот в теореме 1.
Перечислимы.
А ну, коль скорая они перечислимы,
к сожалению, к хорошему критерию про существование
тотального числима мы здесь сослаться не можем,
потому что мы не знаем, не пустыли эти domain и range,
у нас общие случаи.
Поэтому придется как-то довольствоваться более,
более простым критериям,
которым существует
таталь,
таталь,
таталь,
простым критериям,
в котором существует
собственно, существует функция,
существует g
из n
в n.
Такая, что
domain g
равен
domain f.
Ну, как бы, вот такая функция.
Ну, мы ее давайте даже просто
определим, что ли.
Подождите.
Да, зачем это нам функция нужна?
А, давайте вот так.
Нет.
Придумал, прошу прощения.
Если g, если domain f пуст,
если domain f пуст.
Так, нет, все равно чушь.
Так, так, так, так, так.
Сейчас пытаюсь, пытаюсь сообразить.
Нет, нам нужна, нужна, нужна.
Существует g
из n
в n частично.
Такая, что
domain f, domain g
это
domain f.
Так?
Угу.
Так, ну да,
в принципе, подождите.
Ну, да.
Да, я просто,
знаете, я более формально,
знаете, такое алгебраическое
доказательство пытаюсь вспомнить,
но что-то не вспоминается.
Да, так-то вот не алгебраически,
если излагать, то именно так мы
и делаем.
Вот.
Мы перечисляем,
мы перечисляем,
именно так мы и делаем.
Вот.
Мы перечисляем domain,
в каждой точке перечисленной
считаем значение, собственно,
и выводим пару.
Вот.
Ну, давайте.
Так.
Я пытался просто алгебраически как-то это сделать,
ну ладно.
Так, значит, перечисляем.
Domain F.
В каждой
выведенной точке
x считаем
f от x
и печатаем
x от x
Вот так перечисляем график.
Это будет перечислением графика.
Ну, как же.
Так.
Из той теории мы, наверное,
ну, в принципе, оно доказывается также.
Доказывается также, конечно, напрямую не следует.
Доказывается также, как перечислить
область определения, область значения.
Ну, как?
Да она вычислимая функция.
Как перечислить?
Ну, просто берем, перебираемся пары.
x, k.
Да.
На входе x, k шагов алгоритма делаем.
Перечисляем там, не знаю, по возрастанию номеров или как-то.
На самом деле можно даже не заморачивать
с этой номерацией тотально вычислимой.
Просто в любом порядке перечислять вот эти пары.
Считать, значит, запускать алгоритм
и сделать первые k шагов этой алгоритмы.
А если что-то будет выведено,
то, собственно, если мы перечисляем domain,
то мы пишем x, печатаем x.
Если мы перечисляем range,
то печатаем вторую координату.
Ну и все, собственно.
Ну, не второй координат, а то, что вычислено.
Ну, просто отдельной LEM можно просто,
что для вычислимой функции domain range перечислимая.
Просто принцип доказательства такой же.
Там я привел рассуждение.
Да, это некорректно ссылаться.
Напрямую-то, конечно, я-то и не доказывал,
и с той теориями не следует.
Просто рассуждение такое же.
Так, это будет перечислителем.
Gamma t.
В обратную сторону.
Пусть Gamma t, наоборот, перечислил.
Это нам известно.
Как вычислить значение f от x,
если оно определено?
Перечисляем пары.
Да.
Тогда...
Тогда на входе x...
На входе x...
Перечисляем Gamma t.
Перечисляем Gamma t.
И ждем пару.
И ждем пару.
С первой компоненты x.
Ну, если такая пара появилась,
то печатаем вторую компоненту.
Если она появилась,
печатаем вторую компоненту пары Гамаев.
Компоненту этой пары.
Если в точке x функция не определена,
то такая пара с такой первой компонентой
никогда перечислена не будет.
Ну, а значит, мы будем бесконечно долго ждать,
но, то есть, по сути, зациклимся.
Это нам и нужно.
Если x не из домейна f,
то такой пары на перечислителе не появится.
То пары с первой компонентой x
не появляются.
Никогда не будет перечислено.
Но это нам и надо, собственно говоря.
Нужно зациклиться, если значений нет,
и если значение будет, то вычислить.
Ну, собственно, вот все это и сделали.
Хорошо.
Так, что еще я хотел рассказать?
В этой части, прошу прощения,
чтобы не забыть ничего.
Ну, хорошо.
Давайте следствие у вас этой теории
мы два небольшое выведем
и начнем, собственно,
универсальные вычислимые функции изучать.
Вопрос?
Думаю, просто потому, что там напрямую следует
с первой сиремой все-таки,
что рейндж и домейн перечислим.
Там не надо ничего дополнительного доказывать.
В обратную сторону...
А, подождите, действительно,
то есть в обратную сторону же
это именно так и звучит.
То есть если f вычислима,
то у нее домейн перечислим.
То есть это в обратную сторону и есть.
Мы это доказали.
Следствие.
Если f у нас вычислимая функция,
вычислимая,
а перечислима,
то f от а и f-1 это тоже перечислим.
Как вы думаете, как такое доказать?
А как?
Подождите еще раз.
У нас же а не обязательно,
а под множество n перечислимое.
Как перечислить f от а?
f-1 как?
Подождите еще раз.
Перечисляем а, а вдруг...
Я же не сказал, что а под множество домейн f.
То есть не в всех точках...
Повторяю.
Хорошо, а мы можем перечислить,
но не во всех точках мы можем вычислить значение.
Как делать?
Подождите.
Не разрешитель?
Это не годится.
Нам нужно перечислить.
Что значит одна итерация?
Шаг, что ли, один алгоритм?
Да.
А вдруг алгоритм не вычислен?
f от x определено,
f от x не обязательно вычисляется за один шаг.
Почему?
f от а, да, конечно.
Но не обязательно перечислимое.
Перечислимое не верно.
Давайте просто тупо подумаем.
Мы подумаем, если перечислимое множество без...
перечислимых множество конечно верно.
Поэтому с собой не обязательно
под множество разрешимого, перечислимого,
перечислимого или разрешимого.
Вот.
То есть два перечисления делает, да?
Трудно так перечислять,
честно говоря.
То есть видите,
я бы придумал что-нибудь поинтереснее,
например,
скажем, запускать x
вычисление f,
перечислитель f на k шагов.
Перечислителя давайте запускать на k шагов.
И еще m шагов делать алгоритму вычисляющего af.
На последнем элементе, который перечислитель вывел.
То есть мы перечисляем все тройки
натуральных чисел
вычислимым образом.
И делаем вот что.
То есть мы перечисляем a,
делаем k шагов перечисления.
Потом на последнем выведенном перечисленном элементе
делаем m шагов алгоритма,
если при этом что-нибудь...
Ну и на входе x.
Соответственно, если при этом будет что-то выведено,
то печатаем.
Вот как-нибудь так, например,
f от a будем разрешать.
Давайте просто воспользуемся вот этой предыдущей теорем,
почему я написал, что это следствие.
f вычислимо...
f вычислимо...
Следовательно, график f перечислим.
Теперь, что такое у нас f от a?
Это пересечение графика.
С чем?
С множеством a декартов m.
Правда?
Да, да, проекция.
Проекция на вторую координату вот этого дела.
Это f от a.
Смотрите, вот это перечислимо.
Вот это тоже перечислимо.
Значит, пересечение перечислимых –
это перечислимое множество.
Ну, как раз под множество это неверно,
но пересечение перечислимых перечислимое.
И проекция перечислимого множества тоже перечислимое.
Значит, все это перечисbled...
Это f от a
ну перечисляем а и не знаю нужно все пары до вывести нужно все по вместе
ну да да да можно так
ну да да то есть как бы перечисляем а потом перечисляем для каждого выведенного нового
элемента перечисляем все предыдущие элементы на n там пускай n элемент был выведен а все
предыдущие декартовы n перечисляем да и ну все все числа с новым элементом от одного декартова
от одного dn вот такие пары и так так мы перечислим то есть придется конечно работать со всеми
предыдущими то есть если вот для первого мы выведем первый элемент 1 потом когда
второе число появится выведем первый элемент 2 второй элемент 1 2 ну и так далее поняли да это
тоже можно мы доказывали что декартовы при произведении перечислим это перечислима а
а перечислима поэтому оно перечислима это вот на самом деле можно да сослаться на теоремы
которые мы уже доказали а проекция на первую координату гамма f пересечь а декартовы
это это вот это фота а вот это f-1 это поэтому оно тоже перечислима
ну все вот следствие так ну хорошо теперь так 12 20 да или 10 у нас 10
теперь про универсально вычислимые функции будет говорить
но более менее удовлетворимое объяснение формальной доказательства я не дам того что
существует универсально вычислимая функция вот потому что для каждой конка я объяснял почему
потому что для каждой конкретной модели алгоритма там на самом деле их много например ну вот мы еще
на михмате нас любил наш декан у нас читал правда предмет назывался мат логика но читал нам
дискретно математику вот не знаю почему так было сделано но он декан он может вот значит
то есть у нас был поток разбит на два подпотока и одного подпотока был один лектор и другого
подпотока был второй лектор тот лектор который не наш был он логику читал наш читал дискретно
математику вот ну так вот он во время этой логики дискретной математики значит давал
вторую модель на самом деле это так называемые автоматные функции можно еще там некоторые еще
некоторые есть модели вычисления алгоритмов но по каждой модели в принципе можно привести
формальные доказательства того что есть универсальная вычислимая функция но это очень
долго очень сложно там не знаю по машинам тюринга есть целая книжка которая доказывает вот главный
результат который это вот что есть универсальная вычислимая функция ну параллельно построена
хорошая классификация всех вычислимых функций но вот этот под задачи которая нужна чтобы это
доказать значит что такое сейчас сначала определение а потом такое рукомахательное
объяснение почему она бывает такая значит функция вычислить тотально так вычислимая функция
от двух аргументов
но это частичная функция из антикарта вн вн называется называется универсальная вычислимая
функции если для любого вычислимого f для любой вычислимой функции
что делать что делать так любой вычислимая
существует такое n из n такое что для любого x из n вот сейчас я напишу значок потом объясню
нужно сам деле самом начале этот значок было определить но я всегда забываю определить потому
что в начале курса ну в начале вот нашей темы он не нужен он не используется вот он начинает
использоваться вот именно здесь значок вот такой вот сейчас надо объяснить что он значит значит
что это значит это значит что если вот это он x точке x определена то знать то f от x тоже
определена и значения их совпадают если у он x точке x не определена то ф от x тоже не
определена и в обратную тоже да то есть у них если если у них один одновременно либо они
определены у них тогда одинаковые значения либо они не определены но тоже в обе стороны как бы
совпадающие частичные функции получается у нас такая вот такой значок равенство с волной ну
просто вот чистое равенство писать некорректно просто потому что ну может в этих точках она не
определена тогда равенство какое о каком равенство речь идет да то есть они одновременно либо не
определены условное равенство тогда будет либо поделены тогда не равны вот
хорошо то есть смотрите вот такая вот штука у н x что это такое то есть вот n зафиксировано x
меняется да и у нас получается вот какая-то понятно что смотрите если у нас он x это
функция как вы понимаете научи conquest как функция двух переменных то есть и anat��고
функция двух перемен вы чтобы при фиксации любого любого числа вот на первой позиции мы можем в
принципе мы получаем в качестве вот мы если менять вторую координату получаем тоже вычислимая
функцию да только что такой в bola小心о функция эта функция такая что при всех
фиксациях, но тут все возможные вычислимые функции будут в качестве срезок, так
называемых срезок. Иногда это обозначается вот так у n, ну то есть вот n зафиксирован,
а x вот так. Поняли, да? То есть в срезках все возможные вычислимые функции, которые
существуют. Это универсальная вычислимая функция. Почему такая в принципе существует? Ну вот такое
объяснение зиждется на недоказанном предположении о том, что множество всех возможных программ
перечислимо. Вот смотрите, вот слово, слово алфавит сигма, на котором алгоритмы строятся,
программа это слово в алфавите сигмы, да, набор команд. Поскольку у нас алфавит конечен, множество
слов вообще-то перечислимо, но это не факт, что множество программ отсюда, не следует, что отсюда,
что множество программ перечислимо, это под множество какое-то, которое компилируется,
да, но вот интуитивно предполагаем, что множество всех программ над алфавитом сигмы перечислимо.
Ну да, оно же всегда алфавит конечен, над которым у нас все делается. А раз оно перечислимо,
то есть тотально вычислено, понятно это не пустое, это бесконечно множество само собой,
значит есть тотально вычислимая функция. Алфавит сигма, но слов-то бесконечно много и
программ бесконечно много. Конечно, там длина-то не ограничена. Вот это не обосновано,
чтобы доказать, книжки надо писать целые, но давайте предположим, что вот это верно,
тогда у нас существует тотально вычислимая функция f из n в n такая, что range f равен множеству
всех программ. Я обозначу p, множество всех программ. Ну, вычислимая функция соответствует
программу, которая ее вычисляет. Мы предполагаем, что множество всех программ можно перечислить,
значит есть тотально вычислимая функция, у которой область значения это все вычислимые
программы. Единственное, туда не в n, а в сигма со звездой. Но тут тонкость в чем? В том,
что это еще множество, поэтому в принте можно такое предположить. То есть как-то перенумеровать
вот эти программы, ну, слова. Слова, в принципе, можно перенумеровать, то есть взять просто,
например, по длинным сначала индексировать, помните? Но не знаю, это в первом семестре вы
делали, но я даже на семинарах, на лекциях вроде рассказывал, то есть фиксируем длину,
перечисляем все слова данной длины, это конечное множество в любом порядке, потом увеличиваем
и следующий, ну и так далее. Можно как-то перенумеровать. Слова, множество слов над
конечным алфавитом оно счетно. Даже над счетным, кстати, алфавитом тоже счетно. Так. Смотрите
теперь, как описать программу, которая, собственно, печатает, считает универсальные
вычислимые функции. Программа, вычисляющая значение, значит, по ходу nx,
что мы сделаем? Мы считаем значение, считаем значение, значение fat n, получаем слово,
которое есть программа, программу переделываем на какой-нибудь язык программирования, запускаем
на входе x, получаем программу. Эту программу
на входе, запускаем на входе x. Ну, если что-то выведется за конечным
время, выводим. Если не выведется, мы зациклимся. Собственно, все, что мы будем делать. Понятно,
да? Почему универсальная вычислимая функция? Ну, потому что в качестве range все возможные
программы, а значит, все вычислимые функции там будут. Но я не утверждаю, кстати, что для одной
и той же вычислимой функции нельзя написать несколько программ, которые ее считают. Конечно,
можно. То есть, конечно, в качестве срезок есть повторяющиеся вычислимые функции. И это, кстати,
очень интересный факт. Мы позже выясним, что, например, для хороших универсальных вычислимых
функций, так называемых главных. Чуть позже определю, что это такое. Их даже бесконечно много таких
вот записей. То есть, каждая вычислимая функция бесконечно много раз встречается в качестве срезок.
Значит, ну ладно. Вот так вот условно доказали, что существует универсальная вычислимая функция.
Хорошо, да. Повторюсь, это не есть формально доказательство. Как минимум оно основано
на одном недоказанном утверждении, что множество программ перечислимые.
Ну да, проблема вот с чем. В том, что это вот на такое рассуждение не предполагает,
что у нас получится вычислимая функция двух аргументов. Нам нужно получить вычислимую
функцию двух аргументов. Да, понятное дело, берем перечисляемую. Я также рассуждал,
когда вот начинал преподавать, я тоже не до конца разобрался с теми, вот так же рассуждал.
Берем все вычислимые функции еще одномного. Берем первую функцию в первую срезку,
вторую функцию во вторую, третью в целей, и так далее. Пожалуйста, универсальная вычислимая
функция. А почему некорректное рассуждение? Потому что такая функция о двух переменах и факт,
что вычислимая. Ну а как вы алгоритм же нужен? Как вы алгоритм построите, который считает
такую функцию? Ну а как вы вычислимым образом сопоставите числу натуральному вычислимую
функцию? Это же вычислимым образом делать, но это нельзя сделать вычислимым образом,
потому что вычислимым образом можно число числа сопоставлять. Вот число функции нельзя. Да-да,
собственно, здесь я алгоритм вам описал даже, который все считает. А вот такое рассуждение
просто строит функцию из n в квадрат В, но не доказывает, что она вычислима. А нам
нужна именно вычислимая функция от двух аргументов. Ну хорошо, теперь определим свойства,
на которых мы дальше будем работать. Знаете, есть два способа записать. Я предпочитать буду вот
такой nx, nk, na. Ну забыл еще, вспомнил, что еще нужно вести. Если у nx универсальная вычислимая
функция будем сокращать вот так uvf, универсальная вычислимая функция, то если у n есть f от x,
то мы будем писать, то будем писать. Что? Я просто хочу обозначения вести, которые нам нужны будут.
Вот такие фигурные скобочки n, это функция. Еще универсальная вычислимая функция называется
нумерацией. Вот функция по нумерации u с номером n обозначается вот такими скобочками фигурными.
Иногда сама нумерация здесь в индексе указывается, но если по контексту понятно,
какая нумерация, если в теории она одна, этот индекс мы будем пропускать. Если там
нумерации будет несколько, то нужно будет в качестве индекса указать, по какой нумерации
но то есть вот это в квадратных скобочках это функция с номером n по нумерации u. Поняли?
Это нам нужно понадобиться. В доказательствах теоремы для сокращения некоторых записей,
иногда там будет громоздкие штуки появляться. Вот иногда там нужно будет такая штука.
Что хотел рассказать? Нужно было вести это определение, сейчас я забыл его вести,
поэтому сейчас. Что дальше нужно? А, да, свойства. Два способа записать. Есть два предиката,
так называемые t предикаты. Потом мы дальше будем пользоваться чуть позже. Эти t предикаты
конкретно в нашем курсе нужны будут. Как предикат мы можем писать вот как, либо
есть t предикат просто, есть t штрих еще предикат. Сейчас определю, что это такое. Второй способ это
вот так записать. Это предикат. Это утверждение, которое на каждом наборе либо 1, либо 0. Это
вычислимый предикат. Важно. Тотально вычислимый предикат равный единице тогда и только тогда.
Что? Предикат это функция из n в куб в данном случае в 0,1. Значит вычислимая функция,
тотально вычислимая функция, которая говорит вот что это единица тогда и только тогда,
когда у nx, он собственно на входе xn нашим nx, остановится заказ шагов.
Вполне себе вычислимое свойство, правда? У нас есть программа вычисляющая универсально
вычислимую функцию и мы можем вычислить, то есть программу запустить на входе nx, сделать ко шагу
и выяснить остановится в данном случае за ровно ко шагу. Второй t-штрих предикат или менее то ложь, да, то ложь.
Есть еще t-штрих предикат чуть более расширенный, он четырехместный, значит
тоже тотально вычислимый предикат, значит который говорит вот что, что у nx остановится
за ровно ко шагу, за ровно ко шагу и выведет y, и выведет y.
Тотально вычислимый предикат, вполне проверяемое свойство алгоритмически.
Вот, t-предикаты, ну и такую задачку, да, ребят, а вы на семинарах что сейчас изучаете? Что закончили?
В смысле, вы закончили с точечными функциями или что, я не понял? А если у него время есть чужонный весь, интересно, время вагона, да, интересно, нужно спросить, а кто у вас?
Нет, я понимаю, что в некоторых группах застряли на графах и еле-еле успеют этот листочек про вычислимые функции, да, я понимаю, да, и там еще по Тимашиной Чьюринга листочек, да, про это я в курсе, поэтому, собственно, в некоторых группах приняли решение только половину, потому что другую не успеет, половина листочка.
Изучить, но если у вас время-то есть, то чего, непонятно. Ну, собственно, подскок, вы листочек не успеваете, я буду из листочка некоторые вещи разбирать здесь, тем более, что я немножко с опережением графика иду, значит, по ходу вот этого вот, вот этой вещи, такая задача.
Она в листочках была А, Б, под множество М, перечислимые множество, тогда существует А штрих, Б штрих,
перечислимые такие, что А штрих объединит с Б штрих, есть А объединит с Б, то есть их объединение то же самое, но А штрих, Б штрих не пересекаются при этом.
В чем тут главная загвоздка в этой задаче? В том, что, ну, вот тупо рассуждать, в чем идея, что нужно сделать? Нужно, у нас есть пересечение, да, у нас есть пересечение, и это пересечение нужно как-то разделить между множествами А и Б, А штрих и Б штрих, так, чтобы они не пересекались.
Они стали перечислимыми, ну, просто взять, например, ВА отдать все пересечение, Б минус А не всегда перечислимо, разность двух перечислимых множеств не обязательно перечислима, а поэтому не факт, что просто все отдать можно будет, так, чтобы А штрих, Б штрих остались перечислимыми, то есть нужно вот это пересечение таким перечислимым образом разделить между ними, так, чтобы они...
не пересекались. Ну вот, в этом и загвоздка. А, значит, как кто-нибудь, кто разобрал на семинарах, у кого разобрали эту задачу? Была? Ну и как?
Ну давайте, чуть более формально хочу рассказать с Т-предикатами, в данном случае с Т-предикатами хочу рассказать. Решение-то правильное.
Значит, действительно, перечисляем А и Б, и смотрим вот что. Если те элементы, которые появились на ленте перечислителя А, раньше, чем на ленте перечислителя Б, пишем во штрих, те, которые появились позже, пишем в Б штрих.
Ну понятно, что элементы не из пересечения однозначно в какую-то из множества попадут, да? Понятно, да? Вот. А, собственно, а элементы не из пересечения, собственно, как-то между собой поделятся.
Ну вот идея доказательства такая, да? То есть мы запускаем оба перечислителя и смотрим, что раньше появится. Если там, где раньше появилось, но если на первое раньше, чем на второй, то в А штрих пишем, если в Б штрих позже, чем на первое, то пишем в Б штрих этот элемент.
Вот. Значит, давайте. А у вас кто? Вот у кого закончилось всё?
Согдеева.
Угу. Значит, давайте формальнее чуть-чуть просто. Тут есть простор, где формулы пописать. Значит, если А или Б пусто, то у нас то понятно, как разделить.
Правда? То А штрих равно А, и Б штрих равно Б, тут без проблем, если одно из них пусто. Тогда пусть А штрих, А и Б не пусты, не пусты.
Тогда, хотя, наверное, это не надо. Ну, в принципе, да. Тогда пусть... Сейчас, думаю, подождите, подождите.
Тут нужно к УВФ как-то свести, собственно, сейчас. Забыл, как это сводится. А, да.
Существует F и существует G частичные функции. Такие, что...
Значит, Domain F равно Domain G равно B. Что теперь сделаем? Делаем вот что.
Значит, вот рассмотрим любую УВФ у Nx. Тогда у нас, собственно, есть нумерация вычислимых функций. Есть вот вычислимые функции F и G, да, наши.
Значит, тогда, что мы сделаем? Не знаю, как это обозначить? F штрих это номер. Это номер F в нумерации У.
А G штрих это номер G в нумерации У. Тогда вот что.
Тогда A штрих есть Tx, для которых такие что? Существует K, для которого Tx...
Так, T, F штрих, x, K. То есть вычисляем F штрих. На номере F штрих, собственно, читаем. На входе x делаем K шагов. Вычисления закончились.
То есть Domain x принадлежит Domain F штрих. Тут формула должна быть. Ну и, собственно говоря, как формально записать, что раньше появилось на перечислителе F штрих, грубо говоря, но не появилось на перечислителе G штрих.
Ну и для любого M меньше либо равно, чем K, не T, G штрих, x, M. Вот такое вот свойство.
Теперь B штрих. Это все x, для которых существует K, наоборот, для которого T, G штрих, x, K.
Но для любого M в данном случае придется записать меньше, строго меньше, несимметрично немножко. Не T, F штрих, x, M.
Вот так. Это понятно? Вот. Тут, собственно, мы еще перечислили, описали, куда пойдут элементы, которые в неформальном этом рассуждении, куда пойдут элементы,
которые одновременно появляются на перечислителе F штрих и G штрих. Вот мы сказали, что они в А штрих пойдут. Вот формально. Что надо доказать, что A штрих перечислимо, что B штрих перечислимо,
что их объединение совпадает с объединением AB, и что они не пересекаются. Как доказать, что A штрих перечислимо? Вот это свойство разрешимо, правда?
Свойство тотально разрешимо. Причем даже вот эта формула тотально... Подождите, неправильно говорю. Это вот это свойство перечислимо конкретно, поскольку вот эти штуки разрешимы. Почему?
Помните, как мы перечисляли проекции всякие? То есть мы перебирали все пары. В данном случае xk. Вычисляли F штрих xk. Так, ребята?
То есть потом нужно будет проверить вот это свойство. Если t штрих xk оказалось верным, то есть перечисляем пары xk, считаем t F штрих xk. Если оно верно оказалось, то проверяем вот это свойство.
Вот здесь конечное число проверок нужно сделать, поэтому это вполне вычислимо, если мы знаем, что это верно. Поняли, ребята?
Как устроены функции fg? Fg – какие-то вычислимые функции, у которых domain равен a и domain равен b.
Ну, не знаю, какая разница. Здесь в t предикатах значение – это неважно. Мы же само их перечислили. То есть мы по сути на domain только внимание t обращаем.
Если бы нас интересовало значение, мы бы вот t штрих предикат использовали, не t.
Так, вы запутались, да? Это сложно? Нет? Я просто почему? Дальше еще сложнее будет, и нам придется эти формулы писать.
Значит, с t предикатами. Поэтому я хочу сразу вас приучить. Да, это задача можно рукомаханиями доказать.
И вам, скорее всего, на семинарах будут так делать. Но я хочу с формулами с t предикатов это сделать, чтобы вы привыкли к ним.
Потому что там в следующих задачах уже не обойтись без них. Нужно будет эти формулы писать, чтобы привыкали постепенно.
То есть, смотрите, это перечислимое множество. Просто вот перечислитель описывает. Перечисляем все пары, считаем вот это.
Если единица, то проверяем еще вот это. Если одновременно выполнено, пишем x.
Ну и так перечисляем все пары и вот так делаем. Поняли, да? И это тоже перечислимое множество.
Теперь, почему их объединение вместе это объединить b?
Потому что вот этот предикат существует k, для которого f'xk верен, только если x принадлежит domain f. Согласны?
Ну, может быть, верен. Вот это утверждение, вот эта формула существует k, f.
Верно, только если x принадлежит domain f, то есть из a.
А вот эта формула может быть верна только тогда, когда x принадлежит domain g, то есть b.
Без вот этих формул это же все не истинно, правда? То есть вот здесь формула ложна, если x не из domain a.
А здесь, если x не из domain b. Поняли?
Не перечислители это функции. Мы их определяли в теореме как полухарактеристические.
Помните, это единица, если x принадлежит ta и не определено иначе.
Вот тогда это вычислимая функция, потому что у нас a перечисляем, перечисляем a.
Если она перечислилась, то выводим единицу, если не перечислилась, то мы зациклимся и не выведем ничего.
То есть не определено.
Мы можем взять такие функции, полухарактеристические, например.
Но это не перечислитель. Это, конечно, не перечислитель.
Так, понятно сейчас? Почему они не пересекаются?
Ну да.
Но если они пересекутся, то что у нас получится?
То есть есть k, для которого f' xk и для любого m' либо равно не g' xm.
И существует l. Ну давайте просто проверим, что эти формулы несовместимы.
То есть у нас получилось, если они пересекаются, то у нас получается на уровне формул вот такая штука.
Конъюнкция двух формул выходит.
Существует k, f' xk и для любого m' либо равно не g' xm.
И существует l, такое, что t g' xl и для любого m меньше, чем l, не t f' xl.
Правда? Если одновременно бы это выполнялось.
Смотрите, то есть если k меньше либо равно l, то у нас что у нас будет?
Смотрите, существует k, которое t f' xk, но для всех m строго меньше, чем l.
Обратите внимание, не f' xm. Правда?
Но правда, если давайте строго меньше только.
И вот из этой части у нас получается и не t f' xk. Всё. Противоречие. Правда?
Если k наоборот больше либо равно, чем l, то у нас получается вот что.
Значит у нас t g' xm, t g' xl, вот.
А отсюда у нас будет следовать, что не t g' xl, потому что для всех меньше либо равно k, значит для l в том числе. Правда?
В любом случае противоречие, то есть которое доказывает, что они не пересекаются.
Ну вот, собственно, вот формальное построение этих заданий, этих ашторих в виде формул.
