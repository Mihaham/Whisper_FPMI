Прошлый раз не успели, а именно, ну вы можете вслух там не разговаривать, пожалуйста, хотя бы,
а именно, enable shared from this. Мы в прошлый раз почти все сказали про умные указатели,
что нужно было для первого знакомства. Как я уже сказал, следующей вашей задачей будет реализовать
shared ptr после nord.map, но это будет задача вам выдана только недели через, видимо,
две от текущего момента. Или может уже даже и на следующий, кстати. Может, кстати, и на следующий уже успеем.
Потому что проблем... дедлайнов пока не установлено. Потому что проблема с shared ptr какая?
Мы должны в нем научиться поддерживать нестандартный аллокатор и нестандартный дилитер.
Но, к сожалению, мы пока не знаем, как это делать, чтобы их не делать шаблонами параметрами класса.
Вот эту проблему мы пока отложим. В остальном, про shared ptr мы вроде все поняли.
А почему мы не хотим делать шаблонами параметрами класса?
Ну, потому что это очень неудобно, чтобы типом shared ptr, части типа shared ptr было аллокатор.
Вообще, разработчики, ну, комитет по стандартизации, они такие ребята...
В общем, им свойственно ошибаться, как и людям.
Они поняли, что с контейнерами, конечно, это все классно, что аллокатор является частью типа.
Но делать с shared ptr аллокатор частью типа — это какой-то перебор.
Если просто в shared ptr от разных аллокаторов нельзя было бы друг другу присваивать, то это было бы совсем неудобно.
Поэтому для shared ptr они решили аллокатор не делать частью типа, но это... и дилитер не делать частью типа тоже.
Но это не очень просто. Поэтому мы пока отложим эту проблему.
Подождите, то есть мы хотим, чтобы несколько shared ptr с разными аллокаторами и дилитерами умели ссылаться на друг друга?
С разными типами причем, да.
Да, а каким из дилитеров тогда будет уничтожаться?
Нет, нет, нет. У разных shared ptr на один тот же объект, один и тот же дилитер.
Shared ptr и shared и объект аллокатора и объект дилитера.
Но мы можем присвоить одному shared ptr и другой shared ptr с другим аллокатором, и этот shared ptr подменит себя на тот.
Это какой параграф?
Чего? Это никакой параграф, это мы уходим от повествования.
Мы откладываем эту проблему пока. Мы не хотим делать аллокатор частью типа shared ptr, но пока не умеем этого делать.
А потом окажется, что можно.
Ну, мы научимся просто это делать.
Вот, кстати, может там тоже шторы закрыты? А, они и так закрыты, ну ладно.
Так вот, enable shared from this, это пункт 13-5. Ой, 12-5, виноват.
Какая проблема у нас осталась? Мы хотим научиться получать shared ptr на себя.
Возможно, мне надо светлую тему сделать.
Что значит на себя?
В плане, был бы только shared ptr, мы строили же указатель, а потом сразу кидали на него, то есть...
Я пытаюсь сделать светлую тему, но, к сожалению, это долго будет ее делать.
Ладно, не буду делать светлую тему.
Черт!
Черт! Да, стало еще хуже.
О! Класс!
Размечтался!
Ладно, хорошо, оставим так.
Ну, короче, да.
Нет.
Класс!
А чего, все это время можно было читать текст отсюда?
Да.
А не просто слушать, как и я набираю этого.
Так, у нас есть следующая проблема. Вот у меня есть какая-то структура.
Ну, структура.
И я хочу из ее методов научиться получать shared ptr на объект этой структуры.
Вот, ну тут мне, может быть, нужно иногда вернуть shared ptr на себя.
Такое бывает, такое бывает, кстати, не так редко, как может показаться,
когда вы пишете объектно ориентированный код и хотите кому-то вернуть указатель на себя,
но при этом не хотите, чтобы это был сишный ptr.
То есть как, представьте, что у вас все на shared ptr написано.
В том числе ваш объект вашего класса, он сам, вы имеете к нему доступ через shared ptr.
И вы хотите shared ptr на этот объект куда-то вернуть наружу.
Но вы знаете, что вы были созданы через shared ptr.
И если вы вернете наружу сишный ptr, то чувак, к которому вы его вернете,
он будет думать о том, как вас удалять.
Ну типа это что, это сишный ptr, значит его освобождать надо, непонятно.
Вы хотите, чтобы был shared ptr, но вы не можете вернуть shared ptr.
Я, к сожалению, из-за переустановки системы угрохнулся автодополнитель ВИМИ,
поэтому пока буду снова по дедовски, так сказать, скрепа дедовски, без автодополнения.
Но, тем не менее, я не могу написать вот так std shared ptr.
Ну, я не могу сказать std make shared, например.
Понятно, почему.
Atess от this.
Ну, синтоксически-то это корректно, это даже скомпилируется.
Так мы два раза вернем.
Но мы создадим классическую проблему, мы создали второй shared ptr, но то же самое.
Возможно.
Нет, если мы уже были как shared ptr созданы, то мы обязательно создадим второй shared ptr на то же самое.
А если мы изначально не были созданы через shared ptr, то мы тем более не должны создавать shared ptr на себя,
потому что shared ptr в конце будет считать, что он обязан удалить нас.
Но если мы были не через shared ptr созданы, то мы и не должны создавать на себя shared ptr.
Ну иначе как, иначе это бред полный.
В связи с этим есть специальный, ну я не знаю, стоит ли назвать его костылем.
Есть такой класс в стандартной библиотеке, называется enable shared from this.
Как им пользоваться?
Надо написать struct atess публичный наследник std enable shared from this.
Но это шаблонный класс, а шаблонный параметр у него как раз s.
Чего?
Да, это ожидаемая реакция, так и было задумано.
Это должно вызвать некоторые, что?
Зачем? s-то не шаблонное, это enable shared from this шаблонный.
То есть мы наследуемся к классу, у которого мы шаблонный аргумент.
Да.
Кого это шокирует?
Кому кажется, что это что-то странное и так не должно работать?
На самом деле то, что вы можете, пожалуйста, вслух не разговаривать между собой,
потому что мне очень тяжело громко кричать все это время.
Вот эта штука называется CRTP.
Это некоторый паттерн объектно-ориентированного программирования,
который расшифровывается как curiously recursive или recurrent, не помню, template pattern.
Это именно такой паттерн, когда класс является наследником кого-то,
класс является наследником шаблонного родителя, у которого шаблонный параметр – это он сам.
Вот.
Если тебя не смущает, ну тут есть три уровня.
Первый уровень вас вообще ничего не смущает, потому что вы ничего не понимаете.
Второй уровень вы что-то понимаете и вас начинает смущать, как же это так работает,
но третий уровень вы все-таки понимаете, что это не проблема и будет работать.
Ты на каком уровне, на первом или на третьем?
Я понимаю, видимо, что ему придется не помыть, когда он состоит в объекте и пошедший.
Значит, давайте я отвечу тем, кто находится на первом уровне, на возникающую…
Можно просто ответ на задание.
Давайте, только быстро.
Что если мы при создании шаблонного класса enableShare.js обратимся к какому-то статическому целью, которое было в OBS.
То есть, таким образом мы хотим отэннивировать штуку, которая зависит от enableShare.js from this,
но эта штука как-то будет воспользоваться спричатой зависимостью между…
Ничего не понимаю, все нормально будет, почему?
Пусть у нас, то есть, еще раз, почему эта шаблонная штука не замыкается на спричатой зависимости?
Это значит, ты находишься на первом уровне, если у тебя такие вопросы есть.
Еще раз, что у нас делать, чтобы он просто по классу конструмирует…
Да, да.
Если этот код зависит от какого-то поля, которое было в OBS.
Ну и что?
Если это поле, то, например, статическое.
Тем более тогда и что?
Если это поле, то, например, статическое.
Мне кажется, это очень длинный разговор.
Давай, пожалуйста, я расскажу то, что собирался рассказать, а если тебя это не устроит, то ты в перерыве спросишь.
Я утверждаю, что это не проблема никакая, не для компилятора, не для runtime, потому что что на самом деле означает шаблон?
Что такое enableShare.js from this?
Это просто такой шаблонный класс, в котором где-то фигурирует T как метапеременная.
Что означает enableShare.js from this с шаблонным параметром S?
Это значит, что просто в качестве T нужно формально подставить S.
Это никак не мешает ничему.
Я просто генерирую код класса enableShare.js from this с шаблонным параметром S.
Просто подставляя S вместо T.
Это никакая не проблема.
Если, конечно, enableShare.js from this в себе попытается хранить сам объект S, это будет странно.
Но если он будет себе хранить указатели или ссылки тока, то это никакая не проблема.
Сейчас мы перешли на второй.
В комбе enableShare.js from this.
У enableShare.js будет поле, которое будет равняться, например, статическое поле, которое будет равняться, например, S.
Что такое точка?
Что такое S?
С – это тип, у него нельзя точку брать.
Если это статическое поле, то можно.
Нет, нельзя.
Два двоеточия можно брать.
Двоеточие – двоеточие.
Хорошо, никакой проблемы.
Эта статическая штука могла бы унаследоваться.
Что значит унаследоваться?
Статическая штука?
Давай, пожалуйста, потом.
Очень сложно.
Очень долго, точнее.
Мы сейчас реализуем enableShare.js from this, если что.
Это быстро.
Так вот.
А, да, собственно, что умеет этот enableShare.js from this?
Он умеет делать главную вещь.
Share it from this.
Благодаря тому, что мы унаследовались от enableShare.js from this, у нас появился метод share it from this,
который возвращает sharedPointer на нас,
не создавая новое семейство sharedPointer.
Как должен быть такой класс реализован?
Давайте его реализуем.
Let's write typeNameT.
Ну, я буду писать struct понятным причинам.
enableShare it from this.
А что у него будет в полях для начала?
Ваши предложения.
Ну, не shared, а weak.
Потому что
если он уничтожил,
ну, наличие enableShare it from this
не влияет на счетчик.
Да, если бы у нас S оставался последним из магикан, что называется, объектом,
то получился, поскольку он наследник enableShare it from this, enableShare it from this хранит sharedPointer на него,
то это он никогда бы не удалился, что ли?
Ну нет, это странно.
У нас будет weakPointer.
На T.
Ptr.
Вот.
Как мы его будем инициализировать?
Ну, от чего мы вообще создаваться умеем?
Ну, наверное, от указателя на T.
Или нет?
Сейчас, подождите, давайте подумаем.
Давайте поймем, вот
когда нас создают,
когда S создаётся,
как это происходит?
Это создаётся через sharedPtr, то есть происходит
newS
от чего-то.
И это передаётся в
в конструктор sharedPtr.
В конструкторе sharedPtr
мы получаем pointer
на T
и
значит создаём sharedPtr
из него.
Хорошо, мы пока не понимаем,
как будет создаваться enableShare it from this.
Ну, мы понимаем, как будет работать
enableShare it from this.
Он будет просто возвращать sharedPtr.
Зачем я пишу std?
Я могу просто писать.
Нет, ладно, буду писать std.
std sharedPtr
на T
sharedFromThis
ну, наверное,
const
без
всё, просто sharedFromThis, const.
Что он делает?
Он может
неявный каст сделать,
просто написать
pointer.
Ну, мы просто, да, вернём
sharedPtr.
Ну, на самом деле метод
вот так называется, ptr.log.
Log — это метод
у weakPtr, который возвращает
sharedPtr от него. Кажется, я его
называл в прошлый раз.
Ну,
окей, он так называется.
В этом нет ничего откровенного.
Да.
Я хочу, чтобы выяснить
use case вообще вот этого
структуры S, потому что
мне лично непонятно вообще
как она используется, какую задачу
мы сейчас совершаем. Что нам хочется
сделать?
У тебя есть какой-то
объект,
который был создан через
make.shared. И этот объект,
ну, я не знаю, что бы это ни было,
какой-то объект там,
какое-нибудь хранилище, не знаю,
был создан через sharedPtr.
И вся программа, во всей программе
у тебя хранится куча счетчиков
на этот объект, ну, не куча
счетчиков, куча sharedPtr на этот объект,
все там, все компоненты используют этот
объект посредством sharedPtr.
Вот. В этом компоненте
у тебя есть какой-то метод,
который тебе возвращает
указатель на хранилище.
Этим хранилищ, он,
например, может тебе вернуть указатель,
ну, у тебя может быть какое-нибудь еще другое
хранилище, может быть, это самое хранилище.
И вот у тебя в этом хранилище есть метод
получить указатель на
что-нибудь, на хранилище.
И он, например, иногда
возвращает указатель на какую-нибудь другую штуку,
которая является хранилищем, а иногда
на себя. И все это sharedPtr
и он должен вернуть sharedPtr
на не читая, являющийся хранилищем.
При этом он сам является хранилищем.
Вернуть, например,
получить хранилище
сообщений. И это
хранилище там. Вот оно само.
Ну, возможно
мне, конечно, надо какой-нибудь более конкретный
пример привести.
Нет, код я не буду
писать, сорян, очень долго будет.
Я могу
попробовать прислать тебе
код чего-нибудь
реального. Можно на Stack Overflow,
думаю, найти конкретный пример этого.
Да, можно скачать
утекший архив кода Яндекса
и найти там enableSharedFromThis.
Они там есть, точно, я уверен.
Ну, на самом деле
придумывать
какой-то практический
пример
здесь не обязательно. Проблема
и без практического примера
понятна.
Нельзя создать sharedPtr
на себя, иначе это будет
убе. Нам надо как-то уметь
обрабатывать эту ситуацию, чтобы shared
возвращать на вис.
Зачем это может пригодиться?
Вот.
А как
теперь нам
сделать, чтоб все корректно работало?
А нам надо
нам хочется понять, как
вообще этот ptr инициализируется и чем?
И в какой момент? Вот этот вот ptr.
Да, он должен быть
проинициализирован каким-то sharedPtr.
Откуда возьмется этот sharedPtr?
Вот это невероятно хороший вопрос.
Вот, ответ.
А просто сам конструктор
sharedPtr должен
учесть этот случай.
То есть, смотрите.
Вот в классе
sharedPtr.
Кстати, я тут точку поставил,
поставил. Вот почему это одна из
последних задач. Бла-бла-бла-бла.
А как нам
обработать случай? Ну, паблик,
наверное. Как нам обработать
случай, когда мы создаемся от
t звездочки?
Да нет, зачем?
Вот мы создаем
sharedPtr от ptr.
Ну, мы
тут что-то делаем. У нас тут есть, значит,
слушайте, ну там, короче,
у нас есть ptr,
sizeT,
sizeT звездочка,
count. Я не буду,
там у нас еще есть на самом деле
control блок, есть sharedCount,
count. Все это я не буду сейчас повторять.
Мы проинциализировали ptr,
проинциализировали count,
new sizeT
от единицы.
И
вот здесь вот
мы должны сделать еще одну важную
вещь. Мы должны
если
t наследник enableSharedFromThis,
то у enableSharedFromThis,
у t нужно проставить
вот это вот поле ptr равное
нам.
И в constexpr.
Что?
std is
base of
v.
Понятно, почему v, да?
Is base of v от чего?
От
сначала base,
потом derived, сначала
база,
enableSharedFromThis
от t
запятая t,
ну нам
нужно будет forward declaration,
потому что
непонятно, что enableSharedFromThis.
Так,
я все еще не научился
в ВИМе нормально копировать текст.
Вот,
если вот это,
то что?
То нужно
ptr,
стрелочка, ну это конечно будет некрасиво,
в общем.
Ну,
это поле,
оно называется как-то вот,
вот как-то так.
Что?
Вот, видишь, не помогает твоя конструкция.
Помогало достаточно долгое время,
прошу заметить.
Мы не тестировали,
мы не делали A-B тестирование, но, возможно,
без нее тоже так бы было.
Так вот.
Ну, примерно это надо сделать,
только вот так надо сделать.
Кого?
ptr это
наследник?
enableSharedFromThis,
а значит у него есть все поля enableSharedFromThis.
Конечно,
нам нужно другом стать,
нам нужно стать friend enableSharedFromThis,
разумеется.
Да это коалиция просто,
они все друзья там, они все заодно,
понимаете, все эти чуваки.
Friend
class
sharedptr
шаблонный причем.
А, нет,
нам нужно friend иметь sharedptr
только от…
не совсем, у нас же еще родители
наследники могут быть.
Ну, давайте
посчитать для простоты, что вот так пока.
А для не…
Ну, да,
возможно, шаблонный друг нужен, я, кстати,
не уверен, может быть, и так достаточно будет, надо подумать.
Но если что шаблонного друга сделаем?
Почему наш ptr обязан иметь в ptr?
Потому что он наследник
enableSharedFromThis.
Вот, все.
То есть, на самом деле,
в конструкторах sharedptr мы просто
инициализируем этот
weekptr
и тем самым этот enableSharedFromThis
знает,
откуда брать
ptr.
Все, в общем, по сути, мы все реализовали.
Значит, господин
Сватеев был первым. Как это работает?
Не, ну это какой-то слишком общий вопрос.
Да, да.
Ну,
как это будет
работать? Подождите, давайте я вам
покажу код просто. Вот, смотрите, я говорю,
sharedptr
от s
ps
равно
от new s.
В этот момент
создается объект
s. Но создавая…
Когда создается объект s, сначала должен создаться объект
enableSharedFromThis от s.
Ну,
он создается просто по умолчанию.
Тут конструктор, который ничего не делает,
но weekptr инициализируется пустым.
А дальше
создается
сама s, тоже ничего
не происходит. А потом создается sharedptr.
sharedptr
в своем конструкторе видит, что тип,
который ему дали, это наследник enableSharedFromThis,
все это
инициализирует и попадает в этот if.
В нем
он понимает, что нужно
инициализировать поле этого enableSharedFromThis
с собой, что и делает.
Все, после чего
у s можно вызывать sharedFromThis.
Кстати, да,
еще use case.
Даже не еще, а, наверное, главный
use case, который я не сказал,
который я не придумал тогда.
Представьте, что в STS имеете дело не по указателю,
а по ссылке. Но вам кто-то дал,
вы уже ссылку на эту S получили.
А вернуть вы хотите
pointer на нее обратно, sharedptr.
Как вам это получить? Никак, только через enable,
только через sharedFromThis.
Но если вы в STS имеете дело
по ссылке.
Как вам pointer sharedptr на нее
отдать куда-то? Никак, вы же не можете новость
создать, вам нужно sharedFromThis от нее вызвать.
Смотрите,
это только работает из-за того, что
у нас есть конструктор sharedptr.
Да?
А иначе это не имеет смысл? Нет,
если я взял
какой-то
sx
с
вот,
я хочу сделать,
чтобы мне вернул эту штуку
ссылку на... Будет exception.
Ну вот,
а я хочу, чтобы она вернула на sharedptr.
Нельзя так делать.
Нельзя возвращать sharedptr на то,
что не было изначально создано через sharedptr.
Вот именно ты не хочешь,
потому что если бы ты так сделал, это было бы уб,
это было бы хуже чем exception.
Ты можешь сделать просто
обычный указатель.
Ну, значит,
не пользуйся обычными указателями.
Я не понимаю, в чем твоя проблема.
А,
ну,
ты s по ссылке имеешь,
а тебе нужно отдать куда-то sharedptr
на нее. Как ты это сделаешь?
Никак, только через shared
from this.
Сейчас мы не хотим
для s запретить
создание на стеке.
Можем и запретить, да.
Ну, например, да,
это может быть нужно, для s
запрещено может быть создание на стеке.
А str так не делает?
Но я хочу сказать,
что sharedptr не обязательно занимается
управлением sharedptr. Вообще говоря,
может быть нестандартный дилитер.
У тебя sharedptr может
в своем дилитере делать не освобождение
памяти, а закрытие соединения.
Например, этот объект s
это tcp-соединение.
Tcp-соединение в начале должно быть
начато handshake сделано, а в конце
должно быть послано конец соединения.
И пока еще кто-то пользуется
этим соединением, мы все шарим
вот этот вот pointer. Как только
кто-то последний раз,
как только оно умирает, sharedptr
в своем диструкторе вызовет вот этот
дилитер, который пошлет конец соединения.
А еще мы не хотим
запрещать, кажется, конструирование
на стеке для s. Это зависит от того,
в каком сценарии. Может быть, для каких-то
s хотим.
Господа, мы ведем дискуссию, но, к сожалению,
дискуссию я вынужден остановить,
потому что это
надолго.
Давайте дальше.
В общем, все, sharedptr
sharedptr... А что я встал-то?
Я же дальше буду код писать, не буду вставать.
Короче, это все, что я хотел
рассказать про sharedptr сегодня.
Ну и вот,
наше первое знакомство
с sharedptr. Вы поняли,
что там все не так просто, как
могло бы казаться в самом начале.
И у нас следующая тема.
Тема тоже не длинная,
тоже, я бы не сказал, что сложная,
но очень полезная
и важная.
Ты там ногой провод дергаешь?
Я не знаю, нет.
Как только ты отворачиваешь,
доска становится вот такой, да.
Может быть, не я там, а кто-то там?
Я не знаю.
Я не знаю.
Я не знаю.
Может быть, не я там, а кто-то другой
провод задевает.
Следующая тема, лямбда функции.
Давайте назову просто лямбда.
Лямбда.
Чего?
Что?
Что? Еще раз, я ничего
не слышу.
А, ну да, естественно.
Это, скорее всего, потому что я
написал правильно, а потом что-то удалилось.
Нет?
Я так и написал с самого начала.
Это очень странно.
Да, неприятно.
Все, короче,
живем с этим.
Глава тринадцатая.
Лямбда функции
и
элементы
fp.
fp это
functional programming, да.
Чуть-чуть функционального программирования.
Вот.
Ну, функциональное программирование у нас будет такое
на минималочках.
Хотя сегодня вам как раз
Федя придет рассказывать про Ranges.
И вот Ranges это такой
ну,
можно сказать,
в каком-то смысле
от голоса функционального
программирования все плюс-плюс.
Ладно, я не буду сейчас рассказывать, что такое функциональное
программирование, пока мы просто
изучим.
А, вам уже рассказывали, что такое функциональное программирование.
Как обычно,
идея и простые примеры.
Вот, на самом деле,
все то, что мы сейчас с вами
проходим, что муфсимантика,
ну, муфсимантика нам нужна будет теперь
во всех темах.
Shared pointers это
штука, которая
на практике пользуется очень часто.
И
она вам еще очень много где пригодится,
если вы будете промышленной разработкой заниматься.
Лямбда функции, впрочем, тоже.
Лямбда функции это такая тема, которая маленькая да удальненькая.
И знать надо обязательно.
Ну, современному
разработчику не значить, как лямбда функции
это позор.
Это все.
Да.
А, так вот.
Ну, я не знаю, что с этим делать.
Да.
Попробуй.
Вот именно, что не длинный он там.
У нас просто
подожди, а тут что-то подключено, а вот это
что такое? Нет, я боюсь, это не надо выключать.
Подожди,
я боюсь, не надо это выдирать из розетки, иначе
все сломается.
Там...
Итак, ну, что такое
лямбда функции?
Ну, я думаю, вы все знаете, как обычно,
что это такое.
Кто пользовался лямбда функциями
в своей жизни хоть раз?
Меньше суток назад.
Ну, в общем, вот.
Ну, вот.
Так что...
Что тут, собственно, рассказывать?
Можно с этого начинать вообще?
Может, в первый семястр эту тему перенести?
Ну, да ладно.
Ну, да, какой стандартный
сценарий? Вот вы
хотите
что-то отсортировать?
Ну, давайте я
вектор.
Да банально вектор, вот у меня будет
вектор сейчас.
V равно 1, 2, 3,
4, 5, 6, 7, 8.
Заметьте, я уже не пишу
шаблонные параметры, потому что, как мы знаем,
начиная с 17
можно их не писать.
Вот. И я хочу это отсортировать.
V.begin, V.end, но с каким-нибудь
странным
условием сортировки, ну, например,
по возрастанию
модуля.
Вот. Тогда я что делаю? Я пишу квадратные
скобочки.
Дальше
аргументы.
Int x,
int y.
Дальше
return.
Ну,
abs от x
меньше, чем abs от y.
Фигурная скобка закрылась, круглая
скобка закрылась, точка запятой.
Вот это
expression, на самом деле, правильно?
Ну, то есть вот это вот выражение, вот это вот
начиная с квадратных скобок, так некоторые
expression.
Я думаю, он не по этому поводу.
Который мы передаем в
stdsort в качестве
параметра обычного.
stdsort в качестве
параметра ожидает объект компаратора.
То есть вот этот вот
expression он
корректный объект компаратора.
Замечательный вопрос.
Как раз вот его ты и хотел задать.
А какой тип у этого expression?
Ну, мы с вами,
во-первых, знаем, что
тип, для того чтобы узнать тип,
есть decal type. А давайте попробуем
так и сделать. Вот я сейчас напишу
значит стандартный.
Что я сейчас сделаю?
Я скажу
вот так.
И скажу
c
от decal type.
Ну, я хочу, чтобы компилятор
сказал мне, какой тип у этой штуки.
Это runtime
определение типа. А я хочу compile time
определение типа.
Так, у меня лишние скобочки
здесь.
Есть различные разницы между runtime
и compile time? Конечно, потому что
в compile, в runtime что
ты увидишь, это некоторую строку,
которую компилятор, который компилятор
внутри в структуре typeinfo
называет этот тип. Для inta это будет i, например.
А здесь ты увидишь тип, как он в языке.
Тип, как в коде он был.
Я хочу получить
е, конечно же. Да, я говорю
вот так. Все, у меня
скобки сходятся и сходятся.
И сейчас я узнаю, какой тип у этого
выражения, потому что компилятор скажет, не могу
инстанцировать c с таким шаблонным параметром
и тут-то он испалится с каким шаблонным
параметром. Смотрите.
Lambda. Ой, подождите,
мне нужно в cpp.
g++
c++d, c++17
Lambda с cpp.
Что?
А, потому что я
эти файлы, кажется, создал
в своей домашней директории. Вот черт.
Так, ладно. Значит,
Lambda я вот сюда.
Так, и shardptr заодно сразу
сюда.
Хорошо.
Вот.
Вот.
А...
Хорошо.
Да.
А это потому что у меня
g++ старый.
Я же переустановил систему
и у меня теперь же cc9 всего лишь.
Мне надо накатывать новый, но я пока не успел.
Блин, с Мексикой не получилось побороться.
А...
Что, опять Мексика?
Все, так.
c++2, это кодовое название
c++20.dot.com вышел.
Что за первая ошибка, которая
отгестила?
Ну, Lambda expression в
unrelated-контексте.
Ну, это значит, что
выражение, которое не вычисляется.
Под декл-тайпом у тебя
не вычисляющееся выражение.
Как и под сайзовом.
Ну, было запрещено раньше писать
Lambda выражение вот здесь, потому что
компилятор не хотел генерировать Lambda.
Ну, а сейчас можно.
Чтобы компилятору сделать Lambda,
ему нужно сгенерировать специальный тип.
Для этого типа ему нужно определить.
Ему, короче, нужно генерировать кучу кода.
А если это не вычисляющееся выражение,
то компилятор не должен был этим заниматься.
И не разрешено было писать Lambda в
не вычисляемых контекстах.
Сейчас стало можно.
Так.
Это не касается нашей сегодняшней темы.
Мы сейчас обсуждаем вот это.
У нас сейчас вот этот вот разговор.
Мы хотели увидеть, какой тип у Lambda.
Вот что мы увидели.
На самом деле компилятор не говорит нам,
какой у нее тип.
Он говорит нечто...
Если вы компилируете с
каким-нибудь новым G++
или с C-Lang, то возможно вы увидите...
У меня, к сожалению, даже C-Lang сегодня не установлен.
То возможно вы увидите
какое-нибудь другое,
более развернутое название этого типа.
Но
в любом случае это будет какой-то специальный тип,
название которого
очень содержит много
странных символов.
Ну, там название может быть в стиле
там
два знака подчеркивания,
Lambda, два знака подчеркивания,
Main, что-нибудь int
и какая-нибудь куча букв. Ну, вот какой-нибудь специальный тип.
Нет, компилятор сделает так,
что названия Lambda, которые генерируют,
не пересекаются с вашими названиями.
Это, я думаю, он умеет обеспечивать.
Нет, а если я напишу ZecalPy,
как они здесь типа полкиются?
Да, все будет нормально.
Вот, сейчас мы
к этому придем.
Так вот, смотрите.
Что?
А, правильно.
Так вот, ну ладно.
Эээ...
Сейчас.
На этот раз у меня с собой есть распечатанная
штука.
Да.
Как можно
было бы использовать Lambda?
Ну, я мог бы, например,
создать Lambda
как объект.
То есть, я могу вот эту вот штуку...
Ну, давайте я скопирую эту строчку.
И вот здесь вот
напишу
авто
f равно вот такая штука.
Это теперь некоторый объект.
f это некоторый объект.
Вот.
Сказать, какой у него настоящий тип,
я не могу.
Вот здесь мне, кроме авто,
по сути, и нечего сказать.
Я могу разве что сказать
там.
Ну, я могу еще DecalType сказать,
если бы знал DecalType от чего
брать. Ну, в общем,
точный тип я здесь
не в состоянии назвать, потому что компилятор его сам
генерирует для меня.
Это же не может быть тот вывод DecalType,
который у нас был, подставить.
Он однозначно установлен, для всех компиляторов
одинаковый должен быть тип. Что значит одинаковый?
Ну, в данной ситуации...
Что ты называешь разными типами?
Одинаковый с точки зрения строки...
Не зависит от компилятора.
Что такое тип?
Понятие типа, оно
теряет смысл, когда ты переходишь между...
Если одинаковые параметры будут в функции одинаковые,
тип возвращаемого значения,
то это будет одно и то же?
Что такое одно и то же?
Какие типы называются разными?
Нет, конечно, компилятор
не обещает вам ничего про строку,
которую он там запишет.
Если вы спрашиваете, гарантируют ли все компиляторы мира,
что они нагенерируют один и тот же набор
символов в своем внутреннем названии
класса, нет, конечно, не гарантируют
и не должны. Это какая-то дурацкая
затея.
А это, конечно, они гарантируют,
потому что это то, что на них стандарт
накладывает.
Спроси у разработчиков G++.
Спроси у разработчиков G++, почему они
именно такое сообщение об ошибке решили вывести,
а не другое?
Можно спросить, почему
здесь именно такой текст? То, что тут
написано, это просто то,
как G++ сообщает вам об ошибке.
Он не обязан вам, вообще говоря,
ничего конкретного здесь
говорить. Просто мы надеялись,
что он нам что-то скажет, но он не сказал.
И не обязан был. Он не должен называть
внутреннее название своего типа.
Какой-нибудь другой компилятор мог бы что-то более подробное
сказать.
Если ты напишешь
декол-тайп от одной лямбды, равно-равно
декол-тайп от лямбды?
Что такое равно-равно для типов?
Так.
Естественно, это будут разные типы.
Разумеется. Более того, если
ты напишешь две абсолютно одинаковые лямбды,
это все равно будут разные типы.
Для каждой написанной тобою лямбды компилятор
будет проверить свой собственный тип.
По-моему, да.
Ну, возможно, компилятор умеет их
как-то матчить и делать одинаковыми,
но, по-моему, нет. Все-таки они будут разными.
Да, это будет, скорее всего, CE.
Но я не хочу проверять.
Ну, давайте проверим,
кстати.
Ну, под каждую...
Ну, да. То есть, если я скажу вот так,
декол-тайп от вот этого F
равно вот этому,
то я думаю, будет
сейчас CE.
Потому что конверсия из лямбды
в лямбду запрошена, а это разные
лямбды, и у них разные типы.
Давайте я все-таки продолжу
рассказывать, потому что если вы будете
задавать вопросы, то мы не успеем.
Нет, нельзя.
Извините, мы не успеем иначе.
А тем более нельзя,
это не нужно сейчас.
Ты задал уже три вопроса, твой
лимит вопросов...
Что?
Как писать лямбда функции?
Так, пожалуйста, тихо.
У тебя закончилась по именам подписка.
Ну, вообще, нет.
Но если вы в одну строчку пишете,
то можно и разделять. Но вообще,
конечно, желательно лямбды писать вот так.
Ну, и типа вот делать так.
Но если у вас очень короткая лямбда,
то ее можно в одну строкочку писать.
Ну, да, думаю, можно и так.
Тут нет
четких каких-то сформулированных правил.
Разные люди пишут по-разному.
Вот.
Главное, чтобы красиво...
Так.
Допустим, я хочу лямбды
использовать как компаратор в мэпе.
Что мне тогда надо делать?
А тогда мне надо как раз делать мэп
от int int
и декл-тайп от int
от f.
Вот это пример, когда мне может понадобиться
декл-тайп от объекта лямбды.
Например, лямбду хочу использовать как компаратор
в контейнере. Тогда мне декл-тайп здесь
нужен. Правильно?
Вот.
Да.
И заметьте, что если я здесь напишу
декл-тайп от экспрешена,
то это не сработает. Мне нужно именно декл-тайп
от объекта. То есть, если я хочу в компаратор
мэп передать лямбду, то мне нужно именно
от объекта брать декл-тайп.
Потому что, как я уже сказал, для разных
лямб генерируют разные типы.
Вот.
Дальше.
Как лямбда
понимает, что и возвращать?
Вообще-то это тоже не тривиальный вопрос,
потому что обычно для функций
мы указываем их возвращаемый тип, а тут вдруг
не указываем.
Да, значит, на самом деле
для лямбд по умолчанию
делается вывод типа автоматически.
То есть, вот то, что мы раньше
с вами говорили про вывод типа для функций,
то есть, мы тут... Федя тут час
распинался про то, что там есть
авто, есть такое, авто-секой, авто-декл-тайп,
авто-авто-амперсант,
сто пятьсот правил, как это делается.
Для лямбд они все молчаливо по умолчанию
зашиты, и вы не пишете в лямбде
возвращаемый тип, он сам выводится. То есть,
вы, если не написали в лямбде
ничего про возвращаемый тип, то он как будто
авто.
Но вы можете
возвращать в лямбде явный возвращаемый тип и пишете это
вот здесь, после скобочек, через
стрелочку, да, нужно написать вот так,
например, буль вот здесь написать.
Разумеется,
если я
вот здесь вот, ну давайте я
вот так уже эту лямбду
сделаю многострочной,
здесь, допустим, я могу написать,
если, господи,
если
что-нибудь, не знаю, х меньше
у, то вернуть
там один,
а иначе
вернуть один у.
То, что
То, что
что скажет компилятор.
What does the fox
Что говорит компилятор?
Тихо, тихо, тихо,
в общем, да.
Что говорит компилятор? Несовместимые типы,
не знаю, какой выводить. Ну, что в общем-то
и происходит, когда вы автопишете
в возвращаемом типе функции? Понятно.
Компилятор
он должен в compile-time решить, какой тип возвращаемый
у этой функции, а он не знает,
ваши типы разные, и у него нет предпочтений.
Вы написали два ретерна, он не
выбирает, как бы, к чему привести.
Он должен понять в возвращаемый тип функции, какой.
Ну, давай вопрос.
Почему нужно писать
фигурные скобочки
точку с запятой в конце, если вот так надо
строчную, а если однострочную, то не будет?
Как это не нужно? Нужно?
Нет, у вас вон там хостесвор
и в конце после ретурна нет.
А вот это параметр
потому что
Чел, ну потому что это параметр функции,
скобка закрылась, и точка с запятой после конца инструкции.
Я имею ввиду
Ты объявляешь переменным для
С условно, и
фигурная скобочка закрывается.
А, господи!
Потому что таков синтаксис
условных операторов C++.
Ну, я не знаю, как тебе сказать, это
как бы тема
первой пары. Ну, типа такой синтаксис,
что я должен тебе?
Давай мы, пожалуйста,
не будем обсуждать синтаксис
ИФА сейчас. Вот мы правда
хотим этим заниматься? Я думаю, нет.
Мы не пишем точку с запятой после
последней скобочки. Вот у вас
фигурная скобочка.
Так.
Идем дальше.
А...
Тип непонятный.
Мы должны написать явно,
если мы хотим возвращать разные типы.
Ну, вообще, конечно, это плохой код style,
если у нас лямбда возвращает разные типы потенциально.
Вот.
Если мы так
напишем, то оно скомпилируется,
но теперь вот это будет конвертироваться
не явно в int. Ну, то есть здесь мог бы быть double,
и тогда он бы не явно конвертировался в int.
В пятый раз
прошу не говорить вслух громко,
пока вы там между собой общаетесь.
А...
Явно написали возвращаемый тип.
Разумеется, я мог бы написать
возвращаемый тип, который
является каким-то сложным, то есть я мог бы написать
декл-тайп
от чего-нибудь здесь,
какого-нибудь там выражения,
например, от x плюс y.
Вот. И это бы тоже скомпилировалось.
Возвращаемым типом был бы int.
Вот.
Вот. Ну, хорошо.
Кстати,
я не уверен, могу ли я здесь писать декл-тайп
от авто. Думаю,
не могу. Но давайте проверим.
Нет, могу.
Потому что, ну,
могу, он просто будет ссылку тогда возвращать.
Ну, типа...
Вот так я могу написать?
Интересно.
А.
Могу.
Могу и так. То есть я могу сказать здесь,
ну, то есть я могу попросить его
возвращать не авто, что он делает по умолчанию,
а авто-амперсант. Или декл-тайп
от авто. И тогда он просто будет применять те
правила вывода типов, которые применялись бы,
если бы это была обычная функция с таким возвращаемым типом.
Ну, да.
Получается так, да.
Хорошо.
Еще пара
маленьких замечаний, и пункт
на этом закончен.
Вот этот вот expression,
вот этот вот expression,
да, начиная от квадратных скобок,
заканчивая закрывающей фигурной скобкой,
называется closure, замыканием.
Вот.
Такое название.
Нет, вру.
Замыканием называется не expression,
а его тип как раз.
Вот тип, вот тип этого expression
называется замыканием.
Ну, это определение,
пришедшее из функционального
программирования.
К сожалению, не могу дать никаких коммента...
не могу дать никаких комментариев, просто
вы можете встречать в тексте
в тексте там какого-нибудь
переференс или, значит,
каких-нибудь статей на хабре
каких-нибудь стандартов,
вы будете встречать такое слово closure.
Что такое closure? Это как раз то,
что получается в результате генерации
лямбда функции. Вот closure
это тип того, что получается.
Все такие типы называются типами замыканиями.
Это просто такой вид типа.
Да, тип
вот этого выражения это замыкание.
Ну, они могут быть разными,
разные лямбды, разные замыкания.
И одинаковые лямбды, разные замыкания.
И одинаковые лямбы, разные замыкания.
Вот.
И последнее. Нет, предпоследнее.
А
лямбду можно прямо на месте вызывать.
Например,
давайте
я вот здесь уберу возвращаемый тип
и напишу вот так.
Какой тип будет у f
сейчас?
Да, это правда.
Ну, я могу вот так сделать.
Нет. А, ну да.
Все еще непонятно, что возвращать.
Но давайте вот так сделаю. Вот сейчас f будет
и типа int.
Потому что я сразу же вызвал лямбду на месте.
Вот.
А вот здесь
конечно же так писать нельзя.
Если я так напишу, то будет c и e. Кстати, это отличный вопрос
для зачета на оценку
3. Типа, что будет,
если здесь круглые скобки написать и почему так.
Да.
Это immediate invocation.
Кстати, есть такой мем,
что c++11 можно написать вот так.
И это корректный код.
Это не просто все скобки подряд,
это еще добивающие в конце.
Вот.
Ну, это лямбда,
которая ничего не принимает, ничего не делает
и сразу же выполняется.
Да, это правда.
Но вот так смешнее.
Вот.
И последнее, что я скажу в этом пункте,
я бы хотел вам
озвучить
один пример
использования лямбды неочевидный, который
можно...
Ну, который, во-первых, отличная
задача для экзамена
или для собеседования, а во-вторых,
просто чтобы расширить кругозор,
так сказать, что лямбды
использовать можно не только когда вам надо
куда-то отдать функциональный объект.
Их можно, например, использовать
вот для чего. Представьте, что
мне нужно проинцелизировать,
мне нужно завести некоторый const int
равный, но чтобы
его вычислить, нужно сделать сложные
какие-то манипуляции. То есть мне нужно завести
константную перемену какой-то типа,
но я не могу сразу сказать, чему она должна быть равна.
Я должен сделать каких-то много вызовов функций
и то, что получится в результате, объявить
константной переменной.
Что я должен... Что я могу тогда сделать?
А я могу сказать
лямбда
тут что-то повычислять,
return там
что-то и сразу же выполнить.
Вот это пример, когда immediate
invocation может быть полезно.
Чтобы не...
Ну, то есть чтобы вот
вычисление значения какой-то переменной,
что вы хотите сделать константной,
выделить в отдельную штуку,
но не создавать отдельную функцию под это.
Прямо на месте создали
какие-то вычисления и вычислили.
И объявили константную перемену такого типа.
Вот, например, когда immediate invocation
может быть полезно.
И это, например, полезно
еще, когда у вас есть список
инициализации конструктора,
и там вам надо какую-нибудь ссылку инициализировать
в полях, но вы не можете сразу сказать,
чем инициализировать, вам опять нужно какие-то длинные вычисления,
чтобы сказать, чему она равна. Вы пишете там
x в скобочках и вы должны
пронициализировать чем-то. Тогда вы опять можете
лямбду, в ней написать какой-то код
и сразу выполнить круглые скобочки.
И вернуть эту штуку.
Вот это immediate invocation полезная
штука.
Хорошо.
Это базовые примеры.
Теперь давайте будут примеры поинтереснее.
Следующий
параграф это
захват в лямбду.
Как раз об этом сейчас
будет разговор.
Сейчас об этом и будет
разговор.
Пункт 13.2 называется
захват в лямбду.
Capture lists in lambdas, ну или captures
просто. Вот.
В этом пункте разговор
пойдет про то, что вот эти квадратные
скобочки на самом деле за собой таят.
Вот они неспроста.
Давайте я вот это все удалю
и начну писать что-нибудь
заново.
Отвратительный подход. По код стайлу
будем банить такое, если что.
Значит, эта штука вообще
deprecated по-моему даже и
хороший компилятор ругается на
когда вы амперсант в квадратных
скобках пишете.
Сейчас расскажу.
Смотрите.
Иногда мне в лямбде может потребоваться
использовать какие-то переменные из внешней
области видимости.
Да, ну вот опять
давайте я возьму
блин, зря я все удалил.
Нет, давайте все-таки я не все удалю,
а вот эту лямбду все-таки оставлю.
Вот тут, допустим, я хочу
я хочу здесь
ну, учебный пример.
Я хочу сравнивать
я хочу, чтобы это был такой компиратор,
который проверяет
вот что-нибудь такое.
И вот эта пятерка, это
внешний параметр такой.
Я хочу компиратор по признаку
насколько эти два числа, кто из них дальше
от точки напрямой.
Такой компиратор.
Но эта точка напрямая
она тоже является некоторым параметром.
И она не должна быть параметром
самого компиратора.
Я не хочу ее передавать как параметр функцию,
потому что функция двух переменных.
Я ее, допустим, хочу отдать в сортировку,
а в сортировке я должен сравнивать два числа.
Но в этой функции мне нужно использовать
еще какие-то внешние данные,
которые не являются параметрами функций.
Что мне тогда делать?
А тогда мне нужно их захватить в лямбду.
Это называется capture.
Вот если я просто так напишу здесь
использовать, начну эту переменную,
то у меня будет CE.
Потому что нельзя в лямбде
использовать
необъявленную переменную.
Необъявленную переменную, да.
Внутри лямбды ее не существует.
Mid – это переменная,
которая не существует
с точки зрения лямбды.
Ну, с точки зрения лямбды,
если бы вот здесь
была какая-то переменная Mid,
то она бы существовала.
Глобальной переменной использовать можно.
А он пытается локально его сожрать,
потому что с таким же названием есть.
Так, сейчас. Нет, подожди, подожди, подожди.
Сейчас.
А, я понял.
Он
локально как бы затмевает глобальную,
да, но при этом локально он не может
использовать, и поэтому такая ошибка. Очень весело.
Но вот глобальную использовать можно,
а из-за конфликта имен было нельзя.
Глобальную использовать можно.
Но локальные переменные, если вы не захватили
их, использовать вы не можете.
А что значит захватить?
Ну, мне надо написать.
Давайте, чтобы не было конфликта имен,
я вот здесь вот этот раз закомментирую.
Я должен вот здесь в квадратных скобочках
написать, что я захватываю. В данном
случае Mid.
Я прямо в квадратных скобочках
указываю переменные, которые я
захватываю. Это называется Capture.
Я могу захватить несколько
переменных.
Я не знаю, вот здесь будет...
Я уже не уверен, что это корректный компаратор,
но...
Можно, сейчас все будет.
Я могу
захватить несколько переменных.
Тогда я через запятую их указываю.
Вот.
Ну ладно.
Ну, допустим,
я хочу
сравнивать не
инты, а строки.
И тогда возникает
логичная проблема.
Мне захватывать по значению
или по ссылке?
Да.
Это как раз тот вопрос, на который
я сейчас и собираюсь отвечать.
Я говорю, вот
представь, что я бы не инты сравнивала
строки.
Тогда
у меня возникает вопрос.
А если у меня вот это Mid, которое
захватываю, является строкой?
Ну, я...
Давайте, наверное, все буду все-таки...
Допустим, короче, мне
строка нужна для того, чтобы
два инта сравнить. Не знаю, вот я хочу...
Ну, давайте какой-нибудь пример
придумаем, для чего мне может быть нужна строка в сравнении
двух интов.
Ну, не знаю, допустим...
Ну, строка вот...
Ладно, не хочу придумать пример.
Просто хочу захватить строку.
Вот у меня...
Вот у меня есть строка.
И я хочу ее...
Вот, и я хочу...
Да, класс.
Вот я хочу, короче, так делать.
Я хочу спрашивать
s.subster
Я не знаю.
0.x
меньше, чем
s.subster
s.size
минус
y.y
Так, по-моему, да, начиная с какого символа
и сколько символов.
Я хочу проверить, правда ли
префикс этой строки длины x
графически меньше, чем
суффикс этой строки длины y.
Очень полезная функция.
Так вот.
Ничего только не бывает в Олимпиадах по программированию, правда?
Мне подарили массив.
Филипп очень любит задачи про строки,
и он уже решил все задачи,
поэтому решил придумать свою.
Массив строк?
Поэтому он попросил
на день рождения массив строк,
и дальше он стал с ним делать следующую операцию.
Так вот.
Мне надо строку в лямбду захватить.
Господи, что я сделал?
Мне нужно захватить строку в лямбду.
Но если я напишу вот так,
как вы думаете, она по значению или по ссылке
захватится? То есть она скопируется в лямбду
или нет?
Правильный ответ скопируется.
Почему четыре-то?
Один раз скопируется.
Ну вот. Прямо сейчас один раз скопируется.
А как делать, чтобы она
не копировалась?
Надо захватить по ссылке.
Как захватить по ссылке?
А вот так.
Амперсант перед именем надо поставить.
То есть надо
поставить амперсант перед именем переменной,
когда вы ее захватываете.
Амперсант и имперсант.
Нет, нет, нет.
Нет, нет, нет.
Это
CE будет. Значит, захватывать
можно либо по значению,
либо по ссылке. У вас есть два варианта,
чего вы можете написать. Вы можете написать либо имя
переменной, либо амперсант имя переменной.
И все это через запятую. Других способов
пока нет, но там есть еще
кое-что, но мы потом обсудим.
Нет, так нельзя.
Вот.
Хорошо.
Давайте затестим.
Давайте я верну все-таки
mid
и буду здесь
все-таки сравнивать.
Это лекция о том,
как играет
компаратор.
Буду здесь сравнивать вот это.
Но
я буду
из этой функции менять переменную mid.
И в одном
случае я буду
да,
я буду наблюдать, что
mid меняется, а в другом нет. Правда
сейчас будет
некоторая проблема. Сейчас, короче, вы увидите.
Да, то есть я говорю f от 1
2 и еще раз
mid.
Зачем?
Что-то хотелось.
Вот. Давайте я так
сделаю. Сейчас у меня, правда, наверное, что-нибудь
не скомпилируется. А нет, все скомпилировался. Смотрим.
Изначально было 5, потом стало
6, потому что я mid захватил по ссылке.
И стало быть, когда я меняю mid
внутри функции, я тем самым влияю на локальную
переменную, которая была в этом
в мейне. Ничего удивительного.
Ничего удивительного. Но что
если бы я захватил по значению?
Кто знает, что сейчас будет?
Страшно.
Надеюсь, что я не пострадаю.
Это либо compilation roll, либо
UB. Какой compilation roll?
Все нормально. Просто висит 5,5.
А он создает прям
локальную копию или это будет как?
Значит, правильный ответ будет CE.
Как же я хорош!
Ну иначе
бы я не спрашивал.
Значит,
смотрите,
сейчас вам
придется
с этим смириться,
потому что, к сожалению, я
пока не готов объяснить,
почему такое правило введено в язык.
Но вскоре мы поймем, почему.
Но на самом деле правило следующее.
Если вы захватываете что-то по значению,
то оно по дефолту считается константным.
Это очень странно звучит
на первый взгляд. Казалось бы,
почему не наоборот. То, что мы захватываем
по ссылке, оно не константное.
Мы его и захватывая менять можем.
Но если бы что-то в лямбду захватили
по значению,
то оно константное.
Оно скопировалось,
и при этом оно константным стало.
Честно скопировалось
и стало константным.
Конст и редонли это разные вещи?
Нет, редонли
потому что конст.
Оно константное.
Вот, мы объясним это
видимо сегодня уже не успеем.
Нет, может и успеем, кстати.
В общем, вскоре мы поймем,
почему так, но пока просто поверим.
Тем не менее, есть
способ этого избежать.
Как же мне захватить что-то по значению,
чтобы его можно было менять?
Для этого есть слово mutable.
Я могу написать mutable,
но его надо написать после сигнатуры.
Слева, если мне нужно
явный тип возвращить, то вот так.
К сожалению, так не выйдет.
Можно перед аргументом
конст мид написать?
То есть нельзя перед мид написать
конст мид?
Нет, нельзя, я уже говорил.
Это какой-то избират, честно говоря.
Вот, теперь будет 5,5.
То есть теперь все работает,
компилируется и...
Ну да, мы же скопировали
и то, что мы меняем
внутри функции, не влияет на исходную переменду.
Она могла скопироваться
на все вызовы функций.
Сиаут мид внутри функции, пожалуйста.
Чего? Сиаут мид внутри функции?
Ну, где здесь?
Ну, 6 будет.
Два раза?
Да.
Нет, один раз.
Ну, потому что мы вызываем один.
А!
Я понял вопрос.
Если я второй раз вызову,
тогда будет... Ну, давай подумаем.
Ну, 7, значит, будет,
потому что в ней она хранится,
старое значение хранится между вызовами.
Конечно, она копию создала
и сохранила у себя в объекте.
Лямбда функция – это объект.
А зачем она это сделала?
Ну, мы вроде немножко
не змеи заклинаем туда.
То есть она как бы статическая?
Как будто бы статическая.
Почему статическая?
Она просто хранится в объекте, как поле.
Причем почему статическая?
Оно не общее на все объекты такого типа.
Оно для данного объекта.
Нет, объект не обязательно один.
Я могу написать
авто f2 равно f.
Я могу написать
авто f2 равно f.
Что, можно?
В смысле, я могу создать такой...
Это будет один и тот же тип,
но разные объекты.
Я не говорил, что лямбда функция такого тип
может существовать только одна.
Если я напишу дословный такую же лямбда функцию,
это будет другой тип.
Но если я напишу авто f2 равно f,
то это будет вторая лямбда функция точно такого же типа.
Это за что?
Чего?
Если мы несколько переменных указываем,
мы мьютабел пишем один раз
после сигнатуры.
Мьютабел на всю лямбда функцию.
А можно наследовать?
Кого?
От кого?
Как?
Можно ли сказать...
Можно ли объявить класс S
наследник декл-тайп от...
Объект лямбда, который наследует
тип, который наследует...
Ну смотри, давай я попробую.
Смотри, смотри, давай сделаю.
Ну я не вижу препятствий.
Я глобально говорю авто f
равно вот этому.
А дальше говорю...
Только мид, правда, непонятно, что такое.
Мид придется убрать.
Нет, мид придется...
Да, блин, все придется убрать.
Черт.
Глобально забей уже
и забей.
Так CE все равно, потому что
нельзя захватывать глобальные.
Захватывать может только локальные.
И он не поймет, что такое захват глобальный.
Давайте мид внутри.
Так не захватывай.
Илья, не захватывай.
Делай просто глобальный мид.
Ну так убрать захват в этом и проблема.
Так, все.
Я написал. Теперь я говорю
struct S
паблик декл-тайп
от f.
Нормас.
Кажется, я не вижу препятствий.
Это за мида.
Ну, CE из-за мида, да,
но наследоваться
от лямбда функции можно. Почему нет?
А лямбда функцию можно
от наследования функции?
Как?
Очень громко.
Опять кричите.
Ты слишком громко говоришь. Так, господа,
слишком много вопросов. Идем дальше, мы иначе не успеем
опять. Ну все, у нас дискуссия
какая-то разгорается.
Давайте дальше.
Следующее, что надо сказать.
А что, если мы хотим что-то мувнуть в лямбда функцию?
Да.
Да.
Просто я показал
очень громко.
Просто я показал, что тип лямбда функции
вполне себе нормальный тип, от него можно наследоваться,
в частности, в чем проблема. Ну это такой класс.
Что это класс?
Оператор круглой скобочки, например.
Как и у всех лямбда функций.
Поле?
Поле нет. Он не знает, какие у него
поля.
Идем дальше. Идем дальше.
Как захватить что-то в лямбда функцию
через move?
Вот допустим, я хочу мувнуть строку в лямбда функцию.
Что мне надо сделать?
Да.
Вот это, кстати,
желание, оно в отличие от ваших
тут разных фантазий,
неизращенское.
Мувать что-то в лямбда функцию
бывает нужно.
Например,
если вы находитесь где-то
в ту же строку, у вас лямбда функция
может использовать какие-то внешние данные,
но эти внешние данные вы локально
создали и сразу же хотите ей отдать. Вы не хотите,
чтобы они туда копировались.
И вы не собираетесь
хранить ссылку на них. Вы лямбда функцию
как объект запихнули в какой-нибудь
дредпул, не знаю, чтобы она
в очереди выполнялась как задача,
в каком-нибудь потоке, но ей нужны данные.
Вы эти данные хотите ей передать.
Но вы не хотите хранить эти данные, и вы их сейчас
уничтожите, и вы не хотите ссылку на эти данные
поэтому передавать. Это значит вы
хотите их передать move.
Вы не хотите их не копировать, не ссылку
на них хранить, потому что их временно создали
и сейчас уничтожите. Вы хотите, чтоб она их
вам себе туда что вы хотите сделать вы хотите мовнуть эти данные в лямбда
функцию как это сделать до c++14 не было синтакса так сделать не было синтакса
захватить что-то в лямбда функцию через муф и приходилось извращаться довольно
стрёмными способами но я не буду про них рассказывать они уже устарели
начиная c++14 появился захват с инициализацией вы можете в лямбда
функцию захватить что-то сразу указав чему его до чему и чем его надо
проинциализировать при захвате смотрите что я могу сказать вот у меня есть да
std string s равно там a b c d e f g вот я говорю авто f2 равно и сюда я захватываю мувом
строку ну я мог бы захватить его по ссылке ну давайте мастер моя функция
например она будет возвращать не знаю и ты элемент строки отличная функция
очень полезно вот return а значит s и по индексу вот но допустим я в эту
функцию хочу передать строку не по ссылке а копии причем ну копии бы я вот
так передал но это мы поняли как мунуть чтобы мунуть нужно вот здесь
написать s равно и написать чему равно а да если му вот с например можно
писать да здесь это как списках инициализации будет работать то есть
вот это s это будет внутренней внутреннее имя с а это эста то есть
который локально видно и я могу им даже разные имена дать нет это непонятно как
раз потому что раньше у нас синтаксис был я указываю имя того что я
захватываю а теперь я использует тут некоторая другая логика я теперь если
у меня синтаксис с равенством то я указываю имя не того что я захватываю от
того как я хотел бы чтобы это называлось у меня а справа от равно я
пишу некоторые expression от того что я вижу локально вот сейчас я захватил ss
как знать как строку сейчас я захватил ss как строку по значению но я мувнул
эту s туда то есть если я вот здесь прошу какой у меня размер с будет 0
давайте проверим вот здесь мне выведется 0 потому что я мувнул строку в лямбда
функцию тут много конечно проблем какие проблемы у меня здесь есть
мид у знот деклэр а потому что мид потому что потому что мид был ниже да я слишком
не туда это перенес давайте сюда это перенесу вот f2 уже было это будет f3
ну пусть на память останется так 0 потому что строка мувнулась в лямбда
функцию жестко вот тем не менее я не могу менять эту строку отсюда строка все еще
константная хоть и мувнутая да вопрос какой это какой-то сложный вопрос давай на перерыве
потому что мы сейчас потратим кучу времени на него вот могу захватить черепом могу захватить
мувом но это используется не только для мув захвата то есть я могу разумеется здесь какое-нибудь
другое выражение написать то есть я могу написать вот это вот ss равно и какое-нибудь выражение чем я
бы хотел чтобы являлась сс у меня но в частности это позволяет муф захват делать что если мне
нужно сделать захват нескольких вещей некоторые из которых хочу про инициализировать но я
через запятую перечисляю я могу захватить вот это например так а еще я могу захватить вектор
посылки вот пожалуйста то есть я у меня через запятую перечисляются и захвата с инициализации
и захвата без инфилизации я могу перечислить через запятую что я захватываю по значению что по
ссылке а что с инициализацией да как конструктор чего конструктор мувающий конструктор но я
создаю объект лямбда объект лямбда в себе хранит объект строки и он создался это значит вот
момент когда создают два с чего нет нет объект f2 же создан вот сейчас f2 это созданный объект в
нем лежит поле строка поэтому создаваясь он должен мунуть строку в себя чего f3 что где вот тут
да можешь ты можешь написать захватить сказать чему будет равно конкретно да это будет constant
любой expression можно писать вот есть дефолтный захват а еще момент я могу вот например что
сделать например я хочу вот вы спрашивали как захватить по константной ссылке да просто так же
через мувающий через захват с инициализацией просто я вот такую функцию использую у меня есть
стандартной библиотеки такая функция специально на этот случай стд с конст которая просто берет
объекты возвращает конст референс на него очень удобно таким образом я захвачу сс по константной
ссылке а как мух чтобы можно менять чтобы не конст стринг а нормально
чего поменять ну не как если константная ссылка то ничего чего мью то был написать а вот дальше есть
дефолтный захват что такое дефолтный захват я могу написать в квадратных скобочках просто равно
чем вас это веселит это значит что я собираюсь захватить все локальные переменные по значениям
а персант значит по все по ссылке а ты не знал типа то есть вы пользовались захватом а персант
но не знали что это что он делает в общем-то так и бывает часто именно поэтому а персант вот
именно поэтому а персант и запрещен современными кодстайлами очень рекомендуется к использованию я
вам объясню почему потому что вы захватываете все по ссылке а ваша лямбда может пережить то что
вы захватили по ссылке а вы даже не знаете что вы по ссылке захватили у вас убе как нефиг делать
возникнет нет вы просто лямбда функцию захватили по ссылке и объект этой лямбда куда-то передали и
у вас может эту лямбу там кто-то еще скопировал кто-то куда-то положил и те перемены которые
захватила по ссылке уже давным-давно свое отжили и функция та завершилась а в той лямбде все еще
будут храниться ссылки на них равно захватит все локальные переменные вам именно локальные то
есть она не захватит глобальные но глобальные захватывать не нужно они и так вам доступны
вы захватите все локальные переменные которые вам видны вот из этого места вот отсюда а если
вы по значению они все будут скопированы и все будут конст их и если хотите менять мьют и был
написать если вы напишите вот так то это значит вы все локальные переменные захватите по ссылке
вот например сейчас у меня получится что с size это 8 потому что я в с положил а и стало абc да
нет я неправильно посчитал что ли а потому что я не вызвал вот если я так сделаю f2 от нуля например
а потом сделаю сайс то будет 8 понятно да понятно почему вот без этого 7 а если это написать то 8
хорошо как я уже сказал захват по ссылке вот этот дефолтный захват это очень плохой
код style и не рекомендуется так делать почему не рекомендуется потому что я уже сказал ваша
лямбда функция может как нефть делать пережить по времени жизни те переменные которые вы
локальные захватили а вы поскольку вы их даже не заметили то есть вы вы очень рискуете вы
пишете захвати мне все и у вас из лямбда оно остается доступно при том что его время жизни
может быть меньше чем время жизни вашей лямбды вот и это опасно поэтому рекомендуется если вы
что-то захватываете явно перечислять что вы захватили вы так обезопасите себя от того что
вы случайно захватили что-то а потом забыли и начали этим пользоваться и последнее про захват
если вы захватили все по ссылке то тем не менее некоторые вещи вы можете захватить по значению
вместо того чтобы по ссылке я могу например написать вот так это значит я все захватываю
посылки кроме векторов и его по значению копирую аналогично я могу сказать равно запитаем персант
тес это значит я все захватываю по значению но вотr по ссылке
А карбиллятор никак не оптимизирует то, что мы некоторые переменные просто не используем нигде в лямбде?
Нет, не оптимизирует, потому что ты поймешь почему, когда мы поговорим как лямбды устроены внутренне.
А мы об этом скоро поговорим. Ну вот Феде все нет, может быть мне и начать про это уже говорить.
Да, вот смотрите, давайте я вам приведу пример такой.
Пример, когда у меня возникают проблемы. Вот пусть у меня есть структура S, но не вот такая, а вот такая.
В ней есть какое-то поле A. Нет, не так. Вот в моей структуре S будет функция, вот такая странная функция, которая будет делать следующее.
Ну вот. Изврат-то и изврат, но тем не менее вы думаете в реальном коде такое не встречается, очень даже встречается.
Да, я говорю, return f. Ну, допустим, я хочу такую функцию, которая мне вот. Я, это конечно плохо.
Я создаю класс, который умеет генерировать функциональные объекты. Он умеет генерировать функциональные объекты от разных параметров.
То есть я хочу, чтобы мне класс умел давать штуку, которую я потом вызывать смогу. Вот. И это зависит от параметра.
Например, вот моя функция, она будет возвращать число, которое получается добавлением х к пятерке.
Ну, это конечно учебный пример, но понятно, что это может быть очень сложная функция.
Я говорю S, S. Сейчас. Подождите, подождите, подождите. Зачем мне X get function?
А, ну да. Мне здесь не нужен X. Мне нужен скорее, мне скорее вот что нужно. Вот я что хочу сделать. Я хочу вот это назвать A.
Да, да, да. Вот так я хочу сделать. То есть у меня функция, которая прибавляет некоторую штуку, фиксированную к тому, что я от этого, от чего эту функцию вызываю.
И вот я говорю S, S. И да, смотрите. Пять новых способов, десять новых способов сложить два целых числа я вам сегодня покажу.
Вот, смотрите. Я говорю A, G равно S.get function от пяти. Вот. И потом я вызываю G от трех, например.
Вот. Чего? S.get function, конечно. Вот. Это UB. Все понимают, почему это UB? Кто понимает, почему это UB? Так можно проверить, кто еще слушает меня.
Да, это UB. Потому что эта функция захватила по ссылке локальную переменную, которая уничтожилась сразу же после того, как вернулась эта функция. То есть в этой функции хранится ссылка на то, чего уже не существует.
Скорее всего, фактически это все еще 8? Да нет, вряд ли как раз. Вот здесь как раз вряд ли это 8. Ну давайте проверим.
Чего? Где? А, ну это не помешает, но давайте уберем. Чего не должно быть? Так. У меня conflicting declaration опять.
Переименуй просто и все. Вот две верхних строчки просто переименуй, а с маленькой и забей. А то иначе мы сейчас будем пол кода переделывать.
Да, ну все-таки 8. Ну а если минус O2, то 3. Ну это в общем-то логично. Потому что зачем, зачем что-то складывать, если можно ничего не складывать. И так UB.
Ну да, кстати. Вот, но это в простом случае 8. А если бы я после того, как создал эту функцию, еще насоздавал каких-то объектов на стеке, а потом уже вызвал эту функцию, то там бы все перезатерлось и было бы не 8, а рандомное число.
То есть там нужно передавать по значению. Вот. Да. Да, вот если бы я сюда передал по значению, то было бы нормально.
Потому что я бы скопировал и она бы, ну 8, да. Вот, а теперь другой интересный момент. Представьте теперь, что у меня это A было не параметром функции, а полем класса.
И я, создавая AS, сказал ему от чего создаться. Вот, и теперь я хочу вот здесь использовать это A. Как вы думаете, что будет? Ну сейчас-то понятно, что будет. Здесь все нормально, потому что, да, во-первых, будет ли ошибка компиляции?
А это не локальная переменная. А это класс scope переменная. Локальная переменная – это переменная, которая в функции объявлена, которая объявлена в local scope. А поле – это не локальная переменная.
И если я напишу вот так. О, Федя пришел. Все, значит мы закругляемся. Если я напишу вот так, то будет ошибка компиляции. Правда, по какой-то странной причине.
Ну да, вот нельзя захватить non-variable. Интересно, конечно, у него. Почему non-variable? Ну, короче, нельзя захватывать то, что не является локальными переменными. Это просто запрещено. Захватывать может только локальная переменная. Поля класса нельзя в capture-листах указывать.
Вот. Да. Что будет, если я так напишу? А вот если я так напишу, то будет нормально. Ну, ненормально по какой-то другой причине, потому что там что-то вывести не получается.
А, нет, не будет, да, нормально. Потому что он... Да, сорян, сорян, сорян. Так не будет работать. Тоже не будет, потому что а, нет.
А если конс добавить? Нет, статик добавить. Чего конс добавить? Где? А, да, спасибо, да. А если мы не хотим конс? Нет, все равно не работает.
Так, короче, рассказываю, что надо сделать, чтобы поле класса в лямду захватить. Надо на самом деле написать здесь вот такую вещь. Да, мы в классе, мы в классе.
Значит, когда мы из класса, из метода класса, пытаемся в лямде использовать поля класса, мы не можем захватить их непосредственно, потому что они не локальные переменные.
Ну вот, нельзя. Вот, скопируем на вис, это же поинтер. А, ну ладно. Вот. Значит, если мы в объекте хотим использовать поля объекта, то нам надо в лямду захватить, как бы получить доступ к нашему объекту, из которого мы вызываемся.
И делается это следующим способом. Мы пишем в списке захвата вис. Вис дает нам неявный доступ ко всем полям. Вот теперь А будет в лямдо функции браться из полей объекта.
Захватив вис, мы из лямдо функции получили доступ ко всем полям нашего объекта. Но если мы эту лямдо функцию куда-то отдадим наружу, а наш объект будет уничтожен раньше, чем эта лямдо функция, то, разумеется, это будет УВ.
Потому что мы захватили все эти поля, получили к ним доступ по указателю, то есть по ссылке на объект, а объект умер. Поэтому мы схватим УВ с ноу.
Мы так можем изменить ссылку на поле и убить объект, пользоваться ссылкой.
Вис – это указатель на объект. Мы захватили в лямдо указатель на наш объект. И когда мы в лямдо используем поля объекта, они неявно подменяются на вот такое. Указатель на тот объект, который мы захватили, стрелочка – это поле.
Вис – это специализированный синтаксис. Это еще один костыль, что может быть в Capture List. Там может быть имя переменной, амперсант имя переменной, имя переменной равно Expression и еще Vis. А еще просто равно, а еще просто амперсант.
Правда ли, что мы убьемся раньше, чем будем использовать? Давайте мы закончим пару, потому что надо уже перерыв и надо Федю.
Сейчас мы поговорим про тему новую. В смысле, у нас впервые в курсе. Это фича чистое 20 стандарта.
Ключи свет, пожалуйста.
Ой, а чего он седонный такой?
Все, хватит.
И в целом, наверное, я бы хотел, чтобы сегодня семинар был более интерактивный, чтобы мы просто пощупали, как это работает.
И глубоко разобраться, как это внутри устроено, и нам, на самом деле, пока не хватает теории.
Ты что, оставил мужицкий ВИМ?
Во-первых, это ВИМ, ты просто не видишь.
Нет, это Мексика, я вижу.
Я, конечно, знаю, что высказала балочка над ВИМом.
Нет, это ВИМ, потому что здесь стоят все ВИМские биндинги.
Вот, суть в чем. Смотрите, давайте начнем. Начнем издалека.
Вы, наверное, еще не говорили даже про...
Да, вы точно не говорили, потому что как-то на прошлом семинаре я упоминал стринг-вью.
И вы такие, о, что такое стринг-вью?
Вот, есть такой класс на дартной библиотеке STD-String-View.
Он лежит в отдельном хедере.
А микрофон?
Вот, в чем его смысл?
Это такой класс, у которого в полях он выглядит примерно с следующим образом.
На самом деле он прям таким образом выглядит.
Ну, кроме того, что у него есть несколько шаблонных аргументов, в которых мы умолчим.
Значит, у него есть указатель на начало, и у него есть вот так.
Вот такая штука.
Он позволяет... Ну, и куча методов, как у строки.
Вот кому-то у него есть шаблонные аргументы.
Ну, и куча методов, как у строки.
Вот кому-то из вас понятно, когда такой класс может быть полезнее, чем STD-String?
Ну, я только что объяснил, что он делает.
Это он внутри хранения, и у него куча методов, собственно говоря, как у строки.
Да, абсолютно верно.
Когда у нас уже где-то хранится строка.
Например, если вы когда-то писали, не знаю, где-нибудь статическую переменную или глобальную,
STD, String, Global равно Hello World.
Что здесь происходит, на самом деле?
У вас есть вшитый в бинарник строка Hello World.
Я не помню, смотрели мы с вами или нет, но вот строки, они прям вшиваются в исходный код, прям в Assembler.
И затем...
Да.
И затем, еще до функции main, там вызывается сишная стандартная библиотека такая,
что я вижу стандартную переменную, в смысле, глобальную переменную,
и я ее конструирую на запуске программы.
Хотя, на самом деле, зачем нам может быть понадобится такой стринг?
Ну, потому что с стрингом общаться удобнее, чем с const charge звездочкой.
Вот если здесь написать string view, все еще произойдет то же самое, в смысле вызовется конструктор.
Но этот конструктор, например, не пойдет в кучу, он не будет алоцировать новую память.
Мы создадим указатель на начало этой строки и пробежимся за линию, посчитаемую длину.
И теперь у нас всегда будет ее длина.
Это очень удобно.
Вот есть такая штука.
Собственно, он называется string view.
View, потому что он как бы смотрит на данные, понятно, да?
Он не владеет ими.
Это кажется на введение 17-х плюсов, этот класс.
Вот.
Вот.
Вот с ним понятно пока все, да?
Окей.
Вот, начиная с 20-х плюсов, у нас появилась огромная новая библиотека, ну как бы под библиотека, в стандартной библиотеке.
Значит, заголочный файл ranges.
Или диапазоны.
Что это такое?
Это мы хотим на самом деле частично переписать немножко остальные алгоритмы.
Сейчас мы посмотрим зачем и почему.
А частично мы хотим вот идею string view очень сильно обобщить.
И накрутить на нее кучу-кучу-кучу классных штук.
Вот какую классную кучу классных штук сейчас мы с вами и посмотрим.
Вообще кто-то пользовался уже ranges?
Кто-то что-то про них знает, слышал?
Да.
Ну хорошо, смотрите.
Давайте начнем пока просто поговорим.
Что такое произвольный диапазон?
Вот.
Да.
В целом определение рейнджа в стандарте почти такое.
За единственным исключением, что в этой рейндже очень много
Определение рейнджа в стандарте почти такое, за единственным исключением, что пара итераторов это на самом деле даже несколько сильное условие. То, что мы хотим от рейнджа чуть-чуть слабее, чем пара итераторов.
Почему так? Ну, смотрите. Какой у нас может быть диапазон?
Да, но он может быть бесконечным.
Он может быть бесконечным. Это правда. Но тогда у нас все равно есть бесконечность. Математиками тоже пишем. От, до, плюс бесконечность.
Ну, как бы что-то там справа есть. Вот что-то справа есть, но это не совсем итератор.
А мы должны уметь проверять на то, что кончилось.
Мы должны уметь проверять на то, что кончилось. Это правда.
А что мы еще хотим от второй части? Мы хотим вообще что-то еще от второй части?
Просто здесь срабатывать и все?
Да. Это на самом деле все, что мы от нее хотим. Это правда.
Потому что, как вы помните, у нас есть этот pass the end итератор. Его нельзя разыминовывать, очевидно. Это UB.
Более того, его нельзя даже инкрементировать. Это UB, как мы правили тесты и выяснили это лишний раз.
Вот. Это UB. Все, что с ним можно делать, это иногда декрементировать. Иногда. Не всегда. Потому что вообще не все итераторы можно декрементировать.
Ну, наш тип итератора можно, то есть...
Ну да. И сравнивать с ним. Вот давайте вспомним какой-нибудь итератор, для которого вот эта правая часть как раз была такой странной штукой,
которая не совсем тот же самый итератор, что слева.
Вот я вам два таких, кажется, показывал. Один совсем скользь, другой мы относительно подробно рассматриваем.
Истрим, я бы сказал. Ну, stream output, он там отдельно. Вот истрим, да. Вот у нас есть истрим итератор.
Это текущее место в импуте. А есть конец. И вот конец, мы его как делали? Мы просто говорили, ну, типа, какое-то особое значение итератора этого же типа.
Да, да. Вот к чему весь этот, все эти слова, а к тому, что в плюсах range определяется так.
Это объект, у которого можно позвать begin, у которого можно позвать end. Begin и end не обязаны возвращать один и тот же тип.
Но они обязаны быть сравниваны.
Ну, мы этого ожидаем, я не уверен, что это формальное определение самого range есть, но вообще да.
А как еще мы внутри это вообще можем реализовать, если мы не умеем сравнивать begin и end?
Ну да, да, да. Давайте скажем, что мы их хотим сравнивать.
Ну сейчас мы можем на самом деле, смотрите, вот у меня есть волшебный сайт cpp-reference, мы можем к нему сегодня время от времени обращаться.
Вот у нас есть ranges-range, и тут написано, что это что-то, у чего есть begin, у чего есть end. Кажется, кажется, все, вообще все.
Вот, то есть понятно, что в тех местах, где мы будем их использовать, мы будем налагать дополнительные ограничения на то, что возвращает begin и end.
У нас есть какие-то алгоритмы, которые работают только с random access-терраторами. Ну, то есть нам уже подойдет только, какие-то ограничения добавить на будут.
Окей, это глобально, абстрактно. Значит, у нас появилась такая штука, абстрактный range.
Давайте посмотрим, как на вот этот вот концепт, который появился, отреагировала стандартная библиотека.
Вот в первую очередь, значит, стандартные алгоритмы. Вот как мы раньше делали stdsort.
Вот если у нас есть, допустим, вот мне интересно, кстати, у нас есть лист int.
Что произойдет, если я сделаю вот так?
Ну, он посредствуется.
Отличное предположение. Да, но неверное. Этот код не скомпилируется.
Ответ.
Значит, смотрите, у нас ошибка. И где-то вот в 1938 стручке он вычитает.
Он не будет сортировать за квадрат, наверное.
Я не хочу думать об этом.
Вот с другой стороны, если мы сделаем вектор, вот все будет нормально.
Смотрите, что произошло первое в стандартной библиотеке.
У нас появилась копия всех стандартных алгоритмов,
которые работают не с парой итераторов, а с объектом range.
Значит, эти алгоритмы лежат в std ranges.
И вот здесь есть sort, в который можно передать просто объект.
Вот вектор, как мы понимаем, это range. У вектора есть begin и end.
Значит, он range. Значит, можно передать сюда. Класс.
Я думаю, вы так хотели делать. Теперь можно так делать.
Ну, нам не приходилось сортировать листы вообще-то.
Ну, листы нельзя, это вектор.
Тем более можно попытаться определить операторы.
Операторы?
Ладно, вот. Что еще важно?
А да, есть общепринятое более-менее в комьюнити сокращение,
чтобы не писать std . . . ranges . . . долго это надоедает.
Часто, и я на этом семинаре точно буду использовать rng это ranges.
Почему аналогия string u?
Потому что кроме ranges у нас появились view.
Куча-куча классных-классных view.
Давайте сначала разберемся с алгоритмами.
Давайте сначала поговорим про алгоритмы.
На самом деле, потому что это не все, что изменилось в стандартных алгоритмах.
А, то есть факты стандартных алгоритм.
То есть sort это не include sort, это из sort.hfile.
Это настоящий sort.
Это не ranger-ский sort.
Нет, нет.
Ну, короче, ну, я не знаю, как внутри это сделано.
Возможно, они зовут какие-то общие функции,
но там типа не просто добавили перегрузку, нет.
Почему не просто добавили перегрузку?
Потому что, как я только что сказал,
у нас имеет право range в отличие от пары итераторов,
чтобы эти пары итераторов у range была разного типа.
Что это значит?
Что если у нас есть какая-то структура S,
у нее внутри есть T1, T2.
Это какие-то итераторы.
И она возвращает там T1, begin.
И T2, end.
То вот эту структуру мы сортировать не сможем в std-сорте.
std-sort ожидает, что у нас один и тот же тип у двух итераторов.
Rng-sort он просто...
Rng-sort он уже нормально.
Что значит нормально?
Ну, в смысле, он с этим работает.
Он это компилирует.
No.
Ну, понятно, что вот эту структуру мы сейчас не посортим,
потому что кучи всего не хватает, но идея такая.
Точек с запятой, кстати, не хватает.
Все-таки он не сможет посортить, если мы не сможем сравнить begin и end.
Да, сравнение должно быть, безусловно.
Кстати, мне вот интересно, какую ошибку нам выдаст Rng-sort, если мы попробуем...
От листа, да?
Да, от листа.
Вот раньше у нас какая была ошибка?
У нас ошибка...
Нет, у чего-то там нет минуса.
Какая у нас здесь ошибка?
Мы не смогли найти call, кандидат...
constraints not satisfied, ограничения не соблюдены.
Мы хотим std random access итератор так, а у нас bidirectional итератор так.
Ошибка вообще другая.
Мы сломались немножко в другом месте.
То есть у этих ranges алгоритмов явно прописаны условия,
типа если там не просто скомпилировалось-скомпилировалось,
а типа условия, если мне не дали random access итератор, CE.
Вот.
Ну хорошо.
Давайте еще немножко поговорим об обычных стандартных алгоритмах.
Друзья, можно чуть потише, это прям раздражает.
Окей, немножко про стандартные алгоритмы.
Смотрите, представьте, что у нас есть задача.
У нас есть структура стандартная, не знаю, point.
У нас есть float x, float y.
У нас есть что?
Что мы хотим с ним сделать?
Мы хотим их считать, мы хотим их пофильтровать.
Это что?
Запишите 13-я тема ranges.
Ноль, наверное.
Только сам пронумеруй.
Хорошо.
Илья в номенклатуре больше понимает.
Вот.
Давайте вот придумаем что-то более-менее стандартное с этой точкой.
И потом попробуем реализовать это не фориком, а истерильевскими алгоритмами.
Как это как бы должно бы быть?
Значит, ну сначала мы хотим считать эти структуры с входа.
Потом, скажем, хотим отфильтровать те, которые находятся в квадрате там 0, 10.
Там 0, 0, 10, 10.
И потом все эти точки, не знаю, сдвинуть вправо и вывести.
Еще где-нибудь отсортировать их в середине.
Вот как мы можем это сделать?
Есть у кого-то какие-то идеи.
Ну или давайте начнем, типа, чуть попроще.
Давайте считать, что они у нас уже считаны.
Вот у нас есть вектор, пойнтов.
Вот у нас есть... что?
Мы хотим фильтр, sort.
Нет, фильтр transform, sort, output.
Короткий фильтр не приходит.
Приходит только создать новый вектор и у него попушбекать все, что подходит.
Окей, первый вариант.
Вот, а как попушбекать?
Давай, хотя бы вот этот вариант.
Мы, так как прострелять алгоритмы не говорили, вот давай хотя бы этот вариант.
Мы делаем новый вектор.
Делаем новый вектор points filter.
Что мы дальше делаем?
Не-не-не, погоди.
Алгоритмы.
Мы хотим на алгоритмах написать.
Смотрите, хорошо, есть стандартный алгоритм.
std, copy, if.
В общем, есть куча стандартных алгоритмов.
Многие из них можно навешивать.
Блин, есть шикарное выступление на каком-то старом цепопоконе от человека, который сделал гигантскую карту алгоритмов и говорил, что вот есть алгоритмы.
А на них можно навешивать rune.
И вот if это rune.
Или там нижнее подчеркивание n это rune.
Вот, у вас есть copy.
И copy if делает copy, но с условием.
Копирует только если.
Да?
points.begin points.end
back
inserter
inserter
points
filtered
std ranges
Это просто страшное.
Давайте, у нас сейчас задача
посмотреть, как это делается в std и как это
можно делать стильно, модно, молодежно.
Так, давайте вот так
сделаем.
Ну и лямбду там написать.
Да, и последний аргумент это
лямбда, которая принимает
что?
point.
Мне кажется,
вот для перфоманса вот это желательнее.
Point занимает всего лишь
немного байтов.
Да.
Ну 4 и 4. 8 байт.
Указатель занимает 8 байт.
Ещё добавляет индирекцию.
Вот.
И мы возвращаем
ну скажем
return
x.
value.x
не знаю, меньше
10.
Ну вот такое простое условие.
Вот так.
Окей, мы это сделали.
Мы сделали шаг фильтр.
Что мы делаем дальше?
Что мы делаем дальше?
Transform.
Мы хотим сдвинуть все точки.
Ну давайте, раз мы пофильтровали по x,
сдвинем их по игроку.
Каждому игроку прибавим
тоже 10. Как мы это
сделаем?
Так, std for each есть.
Но что он делает?
Так, а вы
помните std for each?
Он
имеет ли право
наменять элементы? Я что-то даже забыл.
Ну хорошо.
Вообще должен.
Давайте попробуем.
For each уже
значит у нас
points
points filtered
.begin
points filtered
.end
принимаем лямду.
Берем
instant
value
и делаем
что мы делаем?
Мы делаем value.y
плюс равно 10.
Пока все понятно.
Ну предположим, что это сработает.
Мы конечно можем проверить.
О, работает.
Упс, фокус.
Окей.
Окей, хорошо. Теперь нам нужно
посортировать.
Как мы будем сортировать?
А сортировать мы хотим
по x.
Стд sort
от
тоже filter
получается.
Filter
.begin
in points
filtered
.end
и
кастомный
компаратор.
Видите?
Лямды только
прошли, они уже так нужны.
Лямды всю жизнь были нужны.
Left,
alt, right.
Что возвращаем?
Left, x меньше,
чем right, x.
Почему?
Почему?
В смысле?
Ну подожди, хорошо, вектор чисел мы можем
посортировать?
Чем это отличается от сортировки вектора чисел?
Мы просто игнорируем.
Мы считаем равными элементами,
у которых разные игроки, но одинаковые к суду.
Не, это можно посортировать.
Тут все нормально.
И output. Как мы делаем output?
Копии.
Да.
Я, честно говоря,
устал это писать.
Вот.
И в std,
astrim,
operator.
Да, да, да.
Ну, предположим, что определен.
Ладно, тогда это вот.
Ну, типа того, да.
Окей. Смотрите.
Значит, в чем проблема
этого подхода?
Заметили вы какие-то проблемы, что они
удобны?
Окей, да, это решено.
Это вот прям решается буквально вот
следующим способом.
Опа.
Что у нас тут?
Кажется, можно сделать просто вот так.
Окей, да?
Хорошо,
эта проблема решили. Еще проблема
очевидная.
Лямды.
Что именно в лямды?
Что, ты хочешь сказать, что мы что-то
сильно умнее тут напишем?
Да. Ну, про избавление от лямб.
Ну, смотрите, вот личное
личное мнение нравится писать
вот это.
Нет, не вот это, вот это.
Ну, то есть мы должны
задавать кастомный компаратор, да?
Значит, в RNG-сорте
есть еще один параметр
проекция так называемая.
Вот.
Почему? Математик.
Смотрите. Что такое проекция?
Мы берем наш элемент
и его как бы превращаем в что-то другое.
И запускаем алгоритм
уже на вот этих превращенных элементах.
Осортируем изначально.
Ну, суть в том, что здесь мы хотим посортировать по иксам.
Что я хотел сказать? Посортировать по иксам.
Мы говорим... Смотрите.
Смотрите, мы можем сделать вот так
и здесь написать
return value.x.
Ну, тогда нет.
Что это значит?
Это значит, что мы сортируем вот
по значениям, которые возвращают этот альамат. Прикольно, да?
Зачем мы фигуельные сотни?
Зачем у нас между этим всем?
А, ну, потому что мы все еще принимаем
компаратор.
Значит, у нас же как? У STD-сорта
есть какие-то шаблонные аргументы, правильно?
И компаратор, как вы понимаете сейчас,
это один из шаблонных аргументов.
Но
у него есть
дефолтное значение, шаблонное.
Это STD-less. То есть просто вызов
оператора минус.
Что здесь происходит? STD-сорт
подставляется STD-less
и это дефолтная конструкция STD-less.
То есть мы говорим, используй оператор минус.
Окей?
Вот.
Ну, потому что мы не можем сделать
перегрузку STD-сорт под компаратор
и перегрузку STD-сорт под
проекцию в том, чтобы это был
второй аргумент. Ну, потому что
куча проблем. Понятно, да?
Окей. Вот вам это больше нравится, чем
раньше было или нет?
А что если я скажу, что можно сделать
еще лучше? Значит,
в проекции можно передавать не только функции
и функторы. В них
можно передавать.
Ну, сейчас.
Значит, я утверждаю, что
можно сделать вот так.
В смысле, что вы должны знать,
что это такое?
Это указатель
на...
Да.
Мы говорим, пожалуйста,
спроецируй мой тип вот сюда.
И он сделает это.
Так.
Вот.
И он сделает это.
И будем сортировать по иксам.
Давайте попробуем скомпилировать.
Мы скомпилировали.
А вы сомневались?
А, он ничего не выведет.
Ну, он ничего не выведет, да?
Ну, вот у нас...
У нас точно нет чем...
Да.
Вот.
Вот как вам такое? По-моему, это шикарно.
Очень вкусно?
Да.
Окей. Я утверждаю, что мы все еще можем сделать лучше.
Что еще вам здесь не нравится?
Ну, нет.
Мне кажется, вы упускаете
что-то довольно ключевое.
Я могу только
вот так сделать.
Да, так можно.
Ну, ребят, я вам...
Ну, я не знаю, вы обращали внимание или нет.
Вот int main вообще-то ничего не возвращает.
А компилятор не ругается.
Ну, может возвращать. А у меня не возвращает.
Компилятор не ругается.
Он сам добавляет. Это специально для main.
Ну, void тоже может.
Войд всегда...
Всегда все хорошо уйдет.
Нельзя.
Ладно, нельзя.
А почему нельзя?
Компилятор, по-моему, зависит еще.
MSWC может.
Да, возможно.
Значит, это нестандартное расширение.
Пам-пам.
Окей.
Копииф. Что нам не нравится в копиифе?
Самое главное, друзья.
Лямда.
Ну, смотри.
Я не понимаю, как сделать лучше проверку.
Действительно. Потому что мы хотим в проверку
запихивать произвольный предикат. Правильно?
Я хочу. А вы?
Тогда оставляем лямду.
Это человек что-то знает.
Друзья, у меня
подозрение, что самое плохое в этом коде.
Вот до этого мы правили какие-то...
Мы делали код более красивым.
Идейно он остался таким же.
Но основная проблема в том, что он
копия. Потенциально копия всех наших
данных. Правильно?
Ну, вообще неприятно так-то.
Да. А вот если у нас есть какой-то
view, который...
Вот представьте себе. У нас есть
вектор. Это range. Мы можем сказать
view. Как string view,
только какой-нибудь условно...
Условно говоря, vector view.
Такого нет, потому что есть лучше.
Которого сделаем дополнительный параметр.
Пожалуйста, скипай все элементы
типа filter, vector, view.
Почему? Я считаю, что вот это неэффективно
по времени. Мы кучу динамических локаций
делаем.
Партишен.
На месте их переставить.
Смотрите.
Да, что ж такое-то?
Point заключается в следующем.
Что мы хотим...
Вот эта операция, видите, тут мы
хотим...
Что мы хотим...
Вот эта операция, видите, тут
написано filter, а потом происходит copy if.
Вот мы хотим именно фильтровать
изначальные
данные.
Мы не хотим их копировать.
Стандартный библиотек не дает нам
других штук. А если бы мы их
фильтровали, а не копировали, нам бы пришлось
писать гигантский фор. Потому что
не написав гигантский фор,
следующие алгоритмы у нас сломаются.
Потому что все следующие алгоритмы зависят
от предыдущих. Понятно?
Вот в чем проблема?
В том, что если мы сразу отфильтруем,
нам придется этот результат
где-то хранить. Значит, мы хотим
фильтровать не сразу.
На самом деле, что нам позволяют
RNG? Они нам позволяют сделать гигантскую
композицию из алгоритмов и
запустить их только все вместе, когда мы
закончим.
То есть мы хотим идти по ходу, фильтровать,
потом выполнять transform
и выполнять потом sort, когда все это
закончится.
Как это выглядит
у человека, у которого есть RNG? Значит,
мы говорим
points. Я сразу не буду вас
мучить. Покажу еще одну классную
фичу.
Можно писать вот так.
Points.
Как в линуксе, пайпируем их,
так сказать. Куда?
В views
фильтр от
лямды.
Какой лямды?
От вот такой лямды.
Значит,
можем вот так сделать.
Что это за синтаксис?
Ну, это
типа того.
Ну, смотрите, палка
это оператор.
Вертикальная палка это
оператор в языке.
Собственно говоря, побитого или...
Здесь, на самом деле, чуть более хитрый механизм,
к сожалению.
Вот здесь
здесь тонкий момент.
На самом деле, проблема в том,
что, значит, вот этот оператор
работает для
стандартных рейнджей, стандартных
view, а
ваш view пока что
не умеет такой оператор
делать. Вы можете написать свои
произвольные view, но его придется вызывать
типа скобочками, как обычно. Проблема
вызывать скобочками и не палочкой в том, что
ну, как это будет?
У вас будет фильтр от
points, от этого вы вызовете
там
foreach, от этого вы вызовете
transform. Вам нужно читать выражение
изнутри в снаружу.
Понятно? То есть
я могу также написать
типа фильтр
от points.
Потом напишу
transform
от filter, от points.
И вот сначала происходит
вот это, потом вот это, потом вот это. Это неудобно читать.
А палка разворачивает наоборот.
Палка преобразует
вот это, вот
вот это, вот это.
Да, я говорю, это особый случай,
он вшит в компилятор, типа
насколько я понимаю, у него есть
списочек, вот для этих штук
сделай вот такую магию,
пожалуйста, пока.
Да.
Ну, тебе придется написать этот
оператор.
В общем, я не уверен, насколько
я понимаю, это не сделать.
Вот. Можно попробовать,
если у вас получится, браво,
пожалуйста, научите меня.
Сейчас, чем-то критерия отличается.
Смотрите.
Что такое вот эта
штука? В.
Давайте назовем ее filtered.
Вот давайте начнем с малого.
Мы сказали points, палка,
views, filter.
Вот мы теперь можем, во-первых, убрать вот это.
А во-вторых,
сделать вот это.
И вроде все еще даже скомпилироваться.
Нет.
Expected запятая.
41.
38, а, ой, да, я не прав.
И points filtered
не declared.
Не declared.
А, кстати,
да, нельзя, но это мы посмотрим.
Сейчас мы поймем, почему.
Блин, ссор там нехороший пример.
Ну, в общем, вот.
Смотрите. Вот на этом этапе
у нас произошел
вот что такое filtered.
Filtered — это объект
довольно сложного типа, но смысл
в том, что это view на наш
изначальный вектор. Он
не владеет никакими элементами, как сам.
Он только смотрит на вектор. При этом,
если мы сейчас пройдемся по нему вот этим
фарычем, он выдаст только те элементы,
которые удовлетворяют вот этому условию.
Он пропустит все ненужные.
Окей?
Да.
Пока.
Еще раз.
Filter — это структура, у которой
просто есть начальный итератор, конечный
итератор, и внутри, по-моему, хранится
этот, ну да,
предикат. Все, больше там ничего не хранится.
Нет, предикат должен
в итератор.
Filter — это же не range.
Filter — это view.
Ну, view — это STD range с там view.
Честно, у нас вот лямбда,
мы же в любом случае будем проходить
цели. Да.
Смотри, у нас на этом этапе
во-первых, вообще не произошло
никаких вычислений, а во-вторых,
когда мы...
Еще раз, что такое filter?
Объект, в котором хранится
указатель на начало
вектора.
Окей?
Он сам умеет возвращать свой собственный
итератор, указатель-итератор.
Что делает этот итератор?
Он говорит,
текущий элемент вектора
удовлетворяет условию.
Если да, на разоменование
верну его. Если нет,
пойду вперед.
Типа на
плюс-плюс.
Когда мы проходимся, мы все равно
сверяем.
Что мы копируем?
Это чисто из-за лямбды.
А,
это копирование, да.
Ну, в смысле, да, но я могу написать
интересант, тогда этого копирования не будет,
не суть.
Это такой метод, да, у него
плюс-плюс, ну или что такое?
У него оператор плюс-плюс,
в общем, какой-то.
Он все равно будет находить массив золота.
Мы не выделили второе вектор.
Да, да.
С фильтр?
Кстати, какие есть операции с фильтр?
Смотрите.
За бесплатно, практически. Золот единицы.
Вот здесь ничего
не произошло еще с элементами
вектора. Них никто не смотрел.
Мы только создали, вот это
ключевая идея, что мы на этом этапе
не выполнили никаких вычислений.
Да.
Но каждую фурыщ
и так будет ЗОТН.
Но, да, это важно помнить, что
вот эта штука будет пересчитываться
каждый раз, когда вы вызываетесь.
Если вам нужно это куда-то сохранить, вы можете
сохранить.
Нет, она
не будет создавать под собой никакого нового
хранилища.
Если 3 элемента подходят, а
3 не подходят, то мы можем, что сделать?
Да.
Вот.
Что есть у фильтрда?
У фильтрда...
У него
сложный тип.
Давай его попробуем вывести.
Print
filtered
type
of
filtered.
Вот такой.
А type of он в run time?
А?
Type of он в run time.
Type of...
50 на 50.
Ну вот, смотрите.
СТД...
Кстати, можем посмотреть. Здесь есть важная
особенность, которая отличает
вот эти новые view от string view, о
котором мы поговорили в начале.
Что у нас такое? У нас есть STD ranges
filtered view
от STD ranges
ref view
от STD vector point.
Ref view это
такой
view, который
собственно говоря, просто
не владеет.
Вот и все.
Вот.
Во-первых, это композиция, значит
если вы навешите еще палок, вот здесь увеличится
вот эта вот строчечка.
Но, что важно, мы
помним, что мы пришли из вектора.
В STD string view
мы не помним, откуда мы пришли. Мы могли
пришли из конччара, мы могли
из STD string, мы могли
из двух произвольных итераторов.
Здесь мы помним.
Вот.
И мы можем, кстати, вызывать точка
base.
Filtered
точка base.
Ну, ref
view.
Точка base у любого
view возвращает то,
как бы, раскрывает
одну луковичку.
Понятно, да?
Да,
как она раскрывает эту луковичку? Она возвращает
копию. То есть, если мы
сделаем вот так, мы здесь
получим вектор.
Ampersand.
Должны быть копии.
Ну ладно.
Вот.
Так, с этим понятно.
Окей, давайте немножко
ускоримся, наверное.
Сколько у нас там времени
осталось? Не очень много, кажется.
Так, ну давайте тогда, раз мы поговорили
про view, во-первых, я вам покажу несколько
классных полезных view, во-вторых, скажем формально
какие требования к тому, чтобы view был view.
Во-первых, view это range.
Во-вторых, view
должен быть movable.
Давайте я вам прямо покажу, мне кажется, вам понравится.
Смотрите.
Ranges library.
View.
Вот. Ranges view.
Смотрите, какие у нас требования к
view. Она должна быть range,
она должна быть movable
и...
Что значит вот эта штука? Эта штука значит, что мы
сказали,
что мы view.
Вот три условия. Мы должны быть range, мы должны
быть movable, и мы должны сами
обещать клятвенно, что мы являемся view.
Что значит клятвенно обещать, что мы являемся
view? Это значит, у нас есть семантические
реквариенты. Вот здесь написано, что
мы должны
муваться за от
единицы, наш деструктор
должен работать за от единицы,
и если мы вдруг решили сделать
копирование, оно должно работать за от
единицы. Смысл в том, что view
это очень легковесный объект.
Мы зачем муваться?
Зачем муваться?
Ну, смотри, хорошо. Зачем
unique pointer муваться? Он же
легковесный.
А, стоп, вы еще... Нет,
unique pointer... А, были, были.
Ну, смотри,
потребовать от view
копировать, это слишком сильно.
От всех view копироваться. Есть view, который
нельзя копировать. По примеру,
идейно, условно говоря,
unique ptr, это view, который владеют чем-то.
Вот есть std owning view,
он
владеет своим
рейнджом, его нельзя копировать, но его
можно мывать. Вот мы хотим, чтобы
хотя бы мывать можно было.
Объект, который нельзя
ни мывать, ни копировать, это сложный
объект, чтобы с ним нормально работать.
Вот.
Окей.
Ну, смотрите,
для применения в повседневной
жизни, что нам может понадобиться?
У нас есть...
Давайте покажу, например,
for reach, как это обычно используется.
И там
двоеточие. У нас там был points.
Вот, представьте,
что points теперь это, например,
фигура. Да?
Это набор точек, которые составляют полигон.
И мы хотим его
нарисовать.
Что значит нам? Нам нужно пройти
по нему по всему,
плюс еще раз вернуться в первый элемент,
чтобы каждый отрезок получить.
Понятна проблема, да?
Как бы мы это
написали? Мы написали
обычным циклам.
For reach, потом next.
For reach от 0 до 0.
Да.
И в конце еще сделать еще одну дополнительную
итерацию после цикла.
Нет, просто в хоре увеличение на 1 больше.
В хоре мы помним e,
и у нас в каждой итерации цикла
мы соберем переменную, как кружит,
и плюс один размер.
Окей, да, это вариант.
Вот, да, можно сделать так.
Добавлять в конец
не хочется, это, во-первых, pushback,
что можно сделать?
Можно сделать views.
О, кстати, это, кстати, сложно.
Смотрите,
мы хотим добавить view.
Здесь views.
Так, как же тебе зовут?
А не join ли тебя зовут?
Split, join.
Нет, ладно.
Давайте сначала начнем с простого.
Как бы я это, например,
сделал? Сказал...
last
равно points.front.
Берем первый элемент, потом говорим.
Мы хотим пройтись по
points, палка,
drop 1.
Что делает drop 1?
Пропускает сколько-то элементов.
Смотрите,
когда мы делаем
какой-то view, потом палка
views.drop, он берет
этот view, но отщипывает
от начала столько, сколько
мы ему скажем.
Почему? Points это вект.
Ну да, это не view, но это range.
Не важно.
Range тоже так работает.
Призвольный range вот так может делать.
Вот, сейчас мы пропустим
view это...
Да, смотри, view обязательно
range, plus movable, plus сказал,
что он view.
Зачем last тогда?
А?
Зачем last? Ну, потому что мы можем
делать
point
кто?
Не знаю.
Почему мы говорили, что мы взяли последний элемент,
хоть мы берем front?
Типа
previous
draw там
от previous
до item.
Вот, ну понятно, да?
Вот так.
Ну,
это гипотетическая
функция, которая достает линию. Помните, мы
хотели нарисовать полигон.
Draw line.
Вот.
Сейчас, drop 1 он сначала
дропает, да?
Да, да.
Он на самом деле просто указатель смещает.
Да. Итератор.
Вот. У drop есть его
двойник take.
Он, наоборот, берет n первых.
Типа, если вам нужно взять
n первых элементов, вы берете range,
палка take и проходите
вот так. Плюс в том, что вообще не нужно
думать про индексы.
Take, take, а что он сделает?
Он возьмет только первый элемент.
Первый элемент, то есть мы пройдемся только по первому элементу?
Да.
А если мы делаем drop, он у нас
первый элемент выбирает?
Да. А, все остальные оставляет, мы по ним проходим?
Да.
А мы можем это комбинировать?
Да, мы можем сделать вот так.
И это будет ничего.
Ай, фиги, это классно.
Нет, эта штука
выдаст ноль элементов.
Да, если мы делали
текстурный рик,
а если мы делали фообразный рик...
Да, мы бы получили только
второй элемент.
Ну, соответственно, мы уже видели, что
есть фильтр.
Это все,
все сюда можно комбинировать. Фильтр
от какой-то лямбды.
Смотри.
Оно
генерирует другой код.
В смысле, ассемблер другой.
Замедляет
ли оно? Кажется, что
не особо.
Возможно,
даже нет. Нужно смотреть на
каждом конкретном компиляторе, в каждом конкретном
случае. Но, идейно, вообще
замедление не особо должно быть.
Ну, возможно.
Только лучше. Вот. Что
еще можно делать?
Ну, можно делать
правда, с 23
плюсов, к сожалению.
Уже 23.
Зип.
Точно там, точно там.
Вы туда передаете несколько рейнджей,
и он выдает вам пару.
Мап 23 добавит?
SDMap существует давно.
Смотрите.
Да, вот у нас есть points.
И, не знаю, points еще раз. Мы получим
пары points сейчас.
Не очень интеллектуально.
Дальше input stream.
Что мы можем сделать еще? Еще, на самом деле.
Вот. У нас есть
например,
iota view.
Понимаете ли вы, куда я клоню?
iota view?
Да.
Прикол.
Кажется, мы сделали numrate.
Это линиевый
датчик.
У нас points.
У нас остается view
из двух элементов.
Кажется, действительно,
points мы зря передаем куда-то.
Почему?
Почему?
Что-нибудь так.
А?
Зачем мы
пайпаем еще points?
Что-то странное происходит.
Да-да, вот так.
Там есть std
ranges-генератор, так что не надо.
Zip что возвращает?
Zip возвращает какой-то
view.
Там std ranges-view
zip-view от вот этого
всего.
Не пара, это объект какой-то zip-то.
Он будет выдавать тюфлы?
Он будет выдавать тюфлы, да.
Вот.
Что еще есть классного и полезного,
что немаловажно.
Значит, можно делать
следующие.
Points
палка
views
reverse.
И пройтись в обратном порядке.
Ушли времена, когда нам
нужны
хаки с IST.
Так.
Так же можно?
Можно, можно.
Решил проверить, да?
Вот. На самом деле
важный момент.
Что?
А что?
А что не так?
Сейчас
мимо идеи вы должны делать
типа условий минус-минус-н.
Так.
View может
вообще range может
Он может быть
бесконечной и правой.
Когда, видимо, у тебя просто
Смотри. Скорее всего, у тебя
требования на этот
тебе... Давай, давай
попробуем, давай попробуем
сделать view с
и это ноль.
Вот это, мне кажется, не скомпилируется.
Скомпилировалось.
Ну отсюда и до обеда, видимо.
Segmentation fault.
То есть он постарался, он
пытался.
В начале перед созданием
реверса
находится до конца.
Теперь, как на настоящем питоне, у нас
нету CE, у нас только ANTAN.
Опять Segmentation fault. Сейчас, стоп, а на что
на Segmentation fault?
Как бы питон имеет
свои последствия.
Неагонизм.
Нет, нет.
Лучше, чем UB.
Нет.
Да.
Сейчас у нас points
не пустим.
Все еще UB.
Так, давайте
посмотрим.
Сейчас.
Так, давайте посмотрим,
что не так. 44-я строка.
А, ну потому что points
front нет, все нормально.
Вот.
На реверс?
А давайте. Я, кстати, я, честно говоря,
удивлен, что это скомпилировалось. Я буду честен.
Мне очень
интересно, что произойдет.
А, ну, видимо, может я не сохранил
тогда случайно.
Нет, все-таки оно не скомпилировалось.
Давайте поймем, почему
оно не скомпилировалось. Смотрите, он говорит, нет
оператора. Почему нет оператора?
Что еще раз?
Если мы сделаем вот так,
возможно, это скомпилируется.
А, да,
ой, да, вы правы.
Я опечатался.
Ну, заработать оно не должно, конечно.
Ну, и он завис.
Хоба, а вот так работает?
Это мы, да.
Не-не.
Ну, он не смог найти конец.
Что возможно?
Ну, я думаю, что
он не смог найти конец.
Ну, я думаю, что
он не смог найти конец.
Нет, потому что оно
под собой ничего не хранит.
Ну, что тебе нужно? Тебе нужно получить
итератор на конец и идти
типа до итератора до начала.
Ну, примерно. Идейно это.
Сейчас.
Сейчас. А давайте
я покажу вам, на самом деле,
в чем вообще мощнейшая
сила этих штук, потому что вот их
можно бесконечно
бесконечно
навешивать друг на друга.
А...
А, давайте
поставим, короче, иота ноль.
Поставим проверку на то, что
является квадратом и спечатаем все
квадраты натуральных штук.
Красивый фильтр, конечно.
Что еще раз?
Да.
И скажем,
я не знаю,
от всего
от этого, например,
views drop
2. Вот так.
Чтобы
поставить ноль
и без реверса, чтобы он искал последний
просто бесконечно
мечаток. Сейчас, что не так?
Ну, типа без ноль запятай 10.
Он же сможет бесконечно
мечаток. Да.
Теперь точно кетон.
Может генератор. Ну, это генератор.
Вот, удобно.
Вот, удобно. Нашел
красотельное кровь.
Квадрат отрицательный, да.
Ну и ты.
Вот. А что еще можно делать?
А знаете, как еще его можно ограничить?
Вот так. Действительно. Take 20,
например, написать, и тогда он
возьмет из этой бесконечной последовательности
только 20 первых.
Ну,
пропустив, конечно же, первые 2,
потому что там drop 2 написано.
Вот.
Take 20 он берет 20 первых
и drop, то есть он берет
на полной интервале,
на интервале от 2 до 20.
Не-не-не-не. Возначало drop,
а потом take.
То есть там ровно
10. Да.
Мы как написали, он после сделал.
У нас
4,41 квадрат.
Так.
Так.
Давайте вот,
что сделаем.
Есть еще пара фичей, которые я вам
хочу показать классных.
Это все вещи.
Вот это, мне кажется, то, ради чего стоит
жить.
Это прекрасно.
И теперь нам не нужны эти руны на алгоритмов.
Не нужен copy if. Мы можем отфильтровать,
а потом скопировать.
Да.
Да. Видишь? Плюсы.
Так.
Да.
Как
он работает внутри?
Не уверен.
Мне, честно говоря,
вот что,
вот что важно сказать.
Помните, я вот здесь,
какое-то время назад
сказали, что с сортом что-то не так.
С сортом что-то не так. Кто-то скажет мне
теперь, когда мы примерно это все
пощупали, потрогали, что не так
с сортом было.
Он RNG.
Вот у нас есть этот фильтр,
и мы хотим посортить.
Кажется, он ничего не изменится.
Вот это не скомпилируется сейчас.
Потому что фильтр ничего не меняет.
Да, у фильтра не random access
итератор.
Ну, что логично вообще-то.
Вам нужно каждый элемент по очереди.
Вы не можете прыгнуть за от единицы.
Вам нужно за от отходить.
Вот эта штука поменяла
в процессе преобразования категорию итератора.
Больше мы не можем сортить.
Окей, но какие-то простые штуки,
типа дропа,
у них
категория итератора сохраняется.
Реверс, который стандартный,
реверс.
Типа реверс, не который view с реверсом, который
реверс, нормальный реверс.
Что, какой реверс, что?
Мы можем от реверса что-то поменять?
В смысле, мы можем ли вызвать стандартные
алгоритмы на view?
Да, до тех пор, пока
у них одинаковый тип
итераторов. На самом деле, всегда
можем. Если у вас у view разные типы
итераторов, вы можете сделать...
А как мы вообще view должны передавать
в стандартной алгоритме?
Вызывать у них .begin и .end.
А какая типовая итератора?
Какая типовая итератора у view?
У какого смотря?
У фильтров, forward, не, хотя
bidirectional, наверное.
Они все правят итераторы, да?
Ну, они делают свои итераторы поверх
того, что было раньше.
Скорее всего...
Матрешка такая.
Скорее всего, это bidirectional.
Ну да, они повышать не могут явно.
Скорее всего, это bidirectional.
Скорее всего, да.
Не, ну почему только, например, теоретически
может повысить?
Нет.
Да.
Сначала дропнули,
потом взяли.
Ну и что?
Конечно, не является...
Что тут важно сказать?
Если у вас по какой-то причине,
у вас какой-то legacy или еще что-то
нужно передать view
в стандартный алгоритм,
вы можете сделать
std ranges
common view
от вашей штуки.
И она сделает так, чтобы у вас...
Эта штука будет такая же,
как была раньше, но тип
итераторов будет один и тот же.
Она...
Нет.
Ну потому что само-само-бейс
тоже может быть другой итератор.
Она, как бы, нет проблем, которые
нельзя решить дополнительным уровнем абстракции.
Мы добавили уровень абстракции
и сделали новый тип
итератора, который
хранит внутри старый этот,
и они между собой сравниваются.
Вот. Что, кстати говоря,
интересная деталька.
Понял.
Common view это понижать может быть.
Сейчас. Смотри.
Давай посмотрим. Вот есть common view.
Common view берет какой-то view.
Вот у него
конструктор.
Ладно, давайте...
Тут есть пример использования.
Это C++20, да?
C++20, да.
Смотрите.
Вот у нас есть R
какой-то.
Какой-то view.
И здесь, видите, это subrange
из итератора и default sentinel.
Default sentinel это специальная штука
как раз для таких итераторов,
про которые мы говорили, у которых...
Которые мы по дефолтам конструктуры
делали и сказали, это конец.
Вот у них... Можно для них использовать
default sentinel.
Для новых.
Так вот.
Вот мы делаем ranges
common view от range,
у которого разные типы итераторов.
Разный тип у итератора и
у конца. Конец называется sentinel.
И теперь
мы можем вызывать std accumulate
от него. Видите?
А, мы begin and end
одинаковыми. Да, все, что он делает,
все, что он делает, делает
begin and end одинаковыми.
Вот зачем это может понадобиться.
Смотрите.
Как можно... Значит, лайфхак
небольшой, это не то, что ключевая тема,
но небольшой лайфхак. Как можно
выиграть немножко перфа примерно в два раза,
используя std ranges
в некоторых ситуациях. Смотрите.
Представим, что у нас есть vector and off.
Как говорится, мне на день рождения
подарили vector and off.
Сегодня такое было.
Сегодня точности.
Настя Пысак.
Нет, у меня...
На прошлый день рождения.
Я его берем для вас.
Вот, смотрите, у нас есть такая
штука. И мы
хотим найти в ней число 6.
Вот, хотим найти итератор
на число 6. Окей?
Как мы обычно это делаем?
std find
от int begin.
Ну, понятно.
Как будет работать
std find от этой штуки?
Он будет каждый раз
проверять, нашли
ли мы вещь и дошли ли мы
до конца.
Правильно? Две проверки
и, типа,
все. Return.
Просто.
Смотрите, сейчас вспоминаем,
как работает find.
Ну, ладно, мне подсказали,
что нужно 3 найти. Давайте искать 3.
Мы хотим найти 3. Как внутри устроен
find? Он говорит следующее.
Текущий итератор. Это еще не end?
Окей. Если
не end, то текущий итератор.
По нему лежит то, что мы ищем.
Да, возвращаю. Нет. Идем дальше.
Правильно?
На каждую итерацию две проверки.
Но мы-то с вами знаем, что 3 тут есть.
Поэтому мы можем
вот сюда написать вместо end
std
unreachable
sentinel.
Нифига
он умный.
Опять у тебя английский язык
вместо end.
У нас не будет сравняться с концом.
Это
sentinel, который
у которого, значит, все, что есть,
это оператор равно-равно, и он всегда
возвращает false.
У меня
end.
Опять
не тот wave space.
И смотрите, что это значит.
Компилятор видит, что у вас функция
тупо, всегда, безусловно,
возвращает false. Он ее
выхинит из кода.
Вы когда-то проверяете, что вход
миллиметра, он только
возвращает false.
Не-не-не, смотри.
Он на этапе компиляции видит, что эта штука
не может вернуть не false.
Он говорит, это бесполезная проверка.
Я ее уберу.
Замерил, если что,
прямо на Compiler Explorer
дает ускорение.
102
104
Еще одна фишка, не плюс-плюс 23.
Вот такой прикол.
А, я вызвал RNGFind.
Он умеет, ну,
вот.
Это я сказал,
это я сказал, и
так, а сколько у меня времени осталось?
Минус две минуты.
8 минут, окей.
Смотрите, есть
важная вещь.
Мы начали
специально пару
не пораньше, чтобы закончили...
Нет, мы начали нашу пару чуть попозже,
потому что когда я пришел, у вас еще была пара.
Чуть-чуть. Но мы задержимся...
Быстро, смотрите.
Если мне вектор подарили
вот таким способом.
Понимаете ли вы
проблему?
Ну, во-первых,
это скомпилируется,
потому что вектор это range, правильно?
Я потом скину
лучше, с более хорошим,
нормально пройдусь по коду и скину.
Что возвращает Find?
Find возвращает итератор.
Во!
Проблемка.
Что будет, если я сделаю вот так?
Убе.
Убе.
Компиляционеррор не хотите?
Что?
Он что, сильно умный что ли?
Смотрите, оператор
звездочка у
std ranges-dangling
нету.
Смотрите, он
понял, что мы pair value
передали то,
что нельзя передавать. Он понял,
что оно протухнет и вернул нам специальный
тип,
который
он ничего не умеет, он пустой.
Типа, если мы сделаем вот так,
это скомпилируется.
Не правда, что
он ничего не умеет.
Вот, не совсем так.
Чуть более хитро, потому что если я напишу здесь
ну, смотрите,
я же хочу уметь писать
вот так.
У меня
в смысле, про
что?
Ой, не то.
Смотрите, я с другой стороны
хочу уметь
писать какой-нибудь view от вектора здесь, да?
Скажем, если я напишу здесь vw
take 1,
вот это должно быть
валидно, хотя take view это объект,
и он здесь создается.
То есть, если написать более явно,
ну, не знаю, давайте напишем какой-нибудь
reverse.
Это тоже rvalue, конечно,
это объект, но это скомпилируется
и не вернет нам dangling.
Смотрите, а
нет, не скомпилируется, почему?
А, потому что я sort раскомментировал.
Sort, уходи.
Мы с тобой уже разобрались.
Во, скомпилировалось.
А, ну, так, ладно, я звездочку.
Ну, короче, можно даже вот так делать.
Point в том, что
для некоторых типов он вернет dangling,
а для некоторых он такой
ага, это view, нормально.
Если view уничтожится,
оператор не протухнет, потому что объект
все еще существует.
Вот это важная
особенность view.
Типа
жизнь их итераторов
не привязана к их собственной жизни.
Если view разрушился, итераторы могут остаться
валидными.
Да, да, да.
Вся логика в итераторе.
Что?
Что значит не может быть наложен view?
Вопрос. Вы уже должны примерно
понимать, как он понимает
в каком случае, если он получает Rvalue,
ему возвращать dangling, а в каком
не dangling?
Это первое Rvalue.
Это не первое Rvalue.
Какой тип был у самого первого, изначального?
Это первое Rvalue, да.
И какой же у всех, которые на него наращиваются?
У первого рейджа.
Ну да, у первого рейджа.
Вот он помнит, что в начале было?
В начале был вектор.
Тут тоже в начале был вектор.
Может быть есть какая-то функция, типа
из view, которая...
Если вы скажете,
что мой тип
там...
Я забыл точно название этой перемены,
но вы можете переопределить, короче, переменную
не переопределить, а специализировать.
Говорите, мой тип
можно передавать
по Rvalue в алгоритмы.
И тогда он такой, хорошо, я не верну тебе
dangling. Если вы этого не сделаете,
если он получает
Rvalue, он считает, что
вы накосячили и вернет вам
dangling на этапе компиляции.
Что я считаю великолепно.
Это явно лучше, чем UB.
Да.
И пожалуйста, как это работает?
Как это работает, смотри.
Вот у нас есть find от
std
vector
от vw.
Можно вообще написать не просто std vector,
а еще find и reverse?
Можно.
А, кстати,
хороший вопрос.
Да.
Он, наверное,
понимает,
там какой-нибудь user написан
value type
и написано правдами, что Rvalue
или value и так.
Так, ну мы хотим, чтобы он сломался.
Нет, он понял.
Наверное, он
просто запоминает, как это
чем был изначальный
плюс, с которого все началось.
Ну...
Да.
Да, ему нужно вспоминать, да.
Да.
Это хорошее замечание.
Вот это CE. Вот это не CE.
Вот.
Так, ну смотрите.
Да.
Так мы только что это делали.
Ну, считай, это вот эта строчка так и есть.
Ну, только я его по копии создаю,
а не по 123. Давай 123.
Вот то же самое.
Да.
Отскобочек? Это то же самое.
Особенно то же самое.
Нет, зачем здесь писать std vector,
я хочу проверить следующий вопрос.
Ну, смотри. Конечный объект
это views-reverse. И его можно
по Rvalue передавать.
Не, ну views-reverse просто говорит, что
можно ли его передавать, зависит от того,
что передали ему и все.
Да. Да.
Ну...
Хорошее замечание.
Нет, нет, нет.
Сейчас. Тут x-value, p-value
не важно.
Rvalue. Просто Rvalue или не Rvalue.
Вот в чем вопрос.
Смотри. Он получает
тип. И тип, у него
явно есть глобальная
так сказать, константная переменная
существует.
Которая говорит, можно этот тип так
передавать или нельзя. Если там написано
нельзя, то он вернет дендинг.
Если написано можно, он вернет итератор.
View
в зависимости
от того, как они были сконструированы.
Да. Да.
Ну, определяет себе это состояние в зависимости
от того, как... То есть, вот видишь, вот если мы
написали вот так. Ну, давай, чтобы было
прямо одинаково, напишем вот так.
Здесь вот vw, палка.
Да.
Ну,
да. Ну, давай добавим сюда
да.
views
drop 1.
Я утверждаю, что это все еще не должно скомпилироваться.
Оно не скомпилировалось.
Нет оператора у дендинг.
Ну, дендинг типа провис итератор.
Да, для того все еще скомпилируется.
Вот.
Это очень
честно говоря, поверхностный
обзор того, что можно делать в
view.
Вот.
Это моя любимая фича 20
плюсов.
Но, к сожалению,
она сильно опирается, например,
на концепты. И
посмотреть, как они устроены.
Нам пока не хватает. Вот.
Вот. 23 добавили еще больше классных
view, например zip добавили 23.
Вот. Там есть
ну, тут очень много всего.
Мы с вами не пройдем. Вот я как бы вас
призываю открыть эту страничку.
Она не душная.
Вот. Что еще классного?
Что у вас view, например, умеет
если вы сделали какой-то view от вектора
и это какой-то простой view,
например, есть view all, который просто берет
все элементы и делает из этого view.
У вас останутся методы size,
empty, cast bool, если вы empty
и так далее.
Вот.
Заглянули на забор.
Что еще?
Да, вот эта штука в 23
появилась. Вы можете потом
навесить точка to к чему
и написать, типа, а вот это view потом сделай вектор,
пожалуйста, чтоб ручками не писать, создай
новый вектор и скопируй туда этот view.
Вот.
Думаю, да.
Non view range.
Ну, это
уже реальная штука, которая владеет,
создает копию.
То есть это может быть контейнер какой-то.
Да. Ну, вот ты туда и передаешь,
какой контейнер. Ты передаешь
to вектор.
Контейнер это range всегда.
Ну, это
нечто больше, чем range.
Да.
Нечто другое, да. Вот.
Да, да. Я просто, типа, обращу внимание
на какие-то штуки. У вас есть всякие конструкторы,
из которых можно собирать маленькие штуки.
Типа single.
Вы передаете элемент. Это
view из одного элемента. Есть
всякие классные, типа, cycle.
Cycle, типа, сумасшедший.
Нет. Типа...
Это типа, cycle. Вы передаете
view и он по циклу будет по нему ходить бесконечно.
Вот. Repeat – один элемент.
Повторяя этот элемент, там, либо сколько-то раз,
либо бесконечно. И вы можете конструировать так
довольно...
Да, только
куча...
Да. Вот. Ну, и там
case value на мапчик можете навесить.
Пройдите по ключам мапчика или по value мапчика.
Спасибо за внимание.
Я вас не буду больше задерживать.
