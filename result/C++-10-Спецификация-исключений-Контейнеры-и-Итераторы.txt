ну вы возможно знаете что когда мы используем исключение у нас может быть
такой неприятный сценарий вот представим что мы что делаем здесь там
выделяем динамическую память например вот а дальше вызываем какую-нибудь другую
функцию не знаю g от вот этого p а дальше делаем delete p ну потому что мы же его
динамически выделили поэтому надо его сделать delete ну и вернуть ans
что-то такое а функция g она так устроена что она кидает исключение но там допустим
она должна вернуть int в конце не знаю ну пусть она возвращает 3 вот но тут она что-нибудь делает
там проверяет если под p лежит 0 то значит она что-то бросает стд я не знаю runtime
и вот мы эту функцию вызываем и что же произойдет ну конечно же произойдет утечка памяти понимаете
ну вот функция f обладает утечкой памяти
ну здесь не обладает вот если здесь 0 ну скажем я в f тоже передаю какой-нибудь x и вот если
я вызову единицы все нормально если от нуля то утечка памяти правильно понимаете почему утечка
памяти вот это вообще пожалуй но я бы не сказал самый популярный но вообще может и самый популярный
сценарий почему в принципе бывают утечки памяти ну казалось бы чего сложного просто
делай делить себя когда делаешь ню вот и все ну там пиши конструктор деструктор и операторы
присваивания правильно написал один пиши остальные ну вроде это как раз если это люди какие-то и не
умеют делать то они быстро этому научаются вот там вот в стринге этому уже научились теперь у вас
утечек памяти там не возникает я думаю но победить вот этот сценарий гораздо сложнее тут так просто
не научишься это побеждать тут нет какого-то простого способа как писать код так чтобы вот
подобных вещей никогда не происходило использовать исключения например не использовать исключения да и
это на самом деле один из но это не простой способ исключения зачастую хочется использовать а еще
стандартные функции стандартные методы стандартной библиотеки некоторых используют но вот можно
конечно не использовать исключения и это одна из причин почему это одна из главных один из
главных аргументов против использования исключений вот эта ситуация ну и эта ситуация и ей подобные
потому что это она очень примитивная понятно что в чистом виде такой встречается в реальности но
идейная такая ситуация очень проблемная она встречается постоянно вы что-то выделяете причем
здесь вот надо все понимать в очень обобщенном виде вот здесь не обязательно даже new и delete
это может быть любая другая операция которая требует ну обратной операции сделать когда-то вот
например вы открыли что-нибудь не обязательно динамическую память выделили а не знаю открыли
соединение по сети сделали там какую-нибудь вызвали функцию которая сишную которая открывает вам
соединение с сервером вот и у вас оно висит в системе это соединение его закрыть надо когда
вы закончили пользоваться но между тем как вы его открыли и тем как вы его собираетесь закрыть
у вас произошло много всего и что-то из этого кидает исключение проблема вы не дойдете до строчки в
которой вы его закрываете вот другой третий пример и он будет очень вам часто встречаться когда
вы будете писать многопоточные программы он вообще еще хуже там есть такая вещь mutex
ну блокировка когда у вас многопоточный код когда у вас параллельно несколько конкурентных
потоков ну или процессов одну и ту же вещь обрабатывают вам нужно иногда захватить блокировку
что называется вы как бы вызываете некоторую функцию которая дает вам единоличное владение
каким-то участком и после этого все те кто пытаются захватить они ждут пока вы освободите вот у вас все
зависают ожидая пока вы сделаете релиз но вы его не делаете потому что пока вы там делали то что
собирались у вас вылетело исключение вы выскочили из этой функции и опять релиз сделать не успели и
это очень большая проблема она приводит к тому что у вас все зависает намерто многопоточная программа
но выделение освобождения памяти самый простой пример который все знаете уже вот и что же
делать как же быть как же вот если у меня есть какой-то ресурс который захватил а потом
исполнять какой-то код который потенциально кидает исключения то что же мне делать как же мне
избежать ситуации утечки памяти в случае когда исключение будет брошена ну конечно я могу вот
это все оборачивать в трай но то есть тупой способ я могу вот это все оборачивать в трай тут
писать catch тут делать вот это вот ну потому что мы знаем ну вот так да делать но это ну вы
представляете это теперь надо всегда писать да это мы ничего не победить теперь надо всегда так
писать будет всякий раз когда вы делаете не ю и между не длит хоть что-то делать какую-то
функцию вызываете вы значит должны вот такой конструкции нет проблемы что если у нас удалось
то мы не удалили а да это правда это правда и здесь еще нужно на раз написать дилет то есть
ну это да это полная чушь ну так не надо делать вот правильно и вот вы это только что придумал
да это раньше не знал ну гений ну в общем об этом и есть пункт значит что такое ра и и собственно
в этом и заключается идея а давайте используем оп для решения этой проблемы давайте заведем класс
который к которому
которому в конструктор будем отдавать вот этот вот рис вот эту штуку ну вот заведем
хоть класс назовем его как-нибудь я потом значит объясню как он на самом деле должен
называться но вот идея в чем вот этому все вот этот весь кошмар мы уберем а вот
привычка от ноутбука теперь я уже не умею нормальными комбинациями клавиш пользоваться
ну да да ну вот смотрите давайте сделаем следующее мне нужно этот указатель обернуть в
некоторый класс который сам его удалит что внутри чего ну можно но мы сейчас сделаем вот так то есть
у меня есть некоторые указатель и этот класс он будет в конструктор принимать вот этот указатель
и вот им инициализироваться а в деструкторе его роль будет сводиться к тому чтобы просто
сделать delete вот тогда мы здесь вместо того чтобы использовать сырой указатель на int будем
использовать вот этот вот класс ну я его так назвал конечно ну вот так я могу сделать и теперь
вот этого уже не нужно писать да она со стека снимется причем в любом случае неважно в
случае да неважно вылетит ли исключение или я выйду стандартным штатным способом вот здесь
надо конечно писать по точка п вот но на самом деле давайте я уж перестану скрывать от вас это
называется на самом деле smart pointer такой класс и он шаблонный обычно шаблонный он в зависимости
от того какой тип он хранит вот здесь он хранит и принимает ты звездочку да вы не пишете не надо
писать будет звездочка потому что это нужно каст каждый раз делать вы просто говорите
заводите вот этот умный указатель и просто вместо того чтобы сырым указателем работать
работать всегда с умным указателем правда тут возникает новая проблема непонятно как делать
его копирование и что вообще такое копирование этого указателя он как ну понятно если делать
копирование тривиальным образом вот если сейчас делать тривиальным копирование то будет двойной
вот а если его делать как следует ну что можно делать например можно делать копирование которое
забирает п у того объекта дело его на лптр мы забирает новый экземпляр себе п но это какой-то
бред тем не менее до 7 плюс плюс 11 так и было но но потому что ничего лучшего придумать не
получалось но можно просто запретить копирование и тогда его нельзя передавать по значению никуда
только по ссылке вот а можно что а можно а можно да а можно завести счетчик ну то есть
можно сделать этот класс сложной логикой внутренней который будет считать сколько еще таких же
указателей на то же самое и delete только когда их ноль да это будет класс который называется
шерет птр такой класс есть стандартной библиотеке он внутри содержит логику которая вот позволяет
он ведет внутри счетчик этих ссылок вот шерет птр он потому шерет потому что он с разделяемым
владением стд шерет птр шерет поинтер он именно такую имеет семантику вы его создаете от указателя
и в деструкторе он удаляет в поинтер но его еще можно копировать и копировать его можно при
копировании он корректно ну подсчитывает сколько еще поинтеров на то же самое там увеличивает
счетчик какой-то где-то хранимый и так далее вот но мы сейчас не будем вглубь уходить как он устроен
как это реализовать вот это тизер на второй семестр нам предстоит подробно и в деталях
обсудить как реализовать такое это будет весело ну пока же я передаю просто им просто
т-звездочку так п это ну теперь да теперь ничего тебе надо переделать я могу шерп
тера вызвать метод гет шерп тера есть метод гет который вот настоящий поинтер меня возвращает
потому что мы когда пользуемся смарт-пойнтерами мы обычно не то что не явный каст в сишные поинтеры
мы вообще не хотим допускать кастов сишные поинтеры мы не хотим чтобы сишные поинтеры
хоть где-то присутствовали в нашей программе вот но если уж мы все-таки явно хотим именно
сишные поинтер получить есть метод гет но не надо вот ну иногда бывает надо но но это опасно
да вот неприятный шерп тер то что когда изнутри самого объекта нельзя его получить можно почему
а как ну можно есть способы ну нет есть есть метода стд есть класса стд enable shared from this но
давай не будем сейчас об этом я же говорил это интересная история как писать шерп тер
есть объект и когда у нас есть в нем мы можем из него получить указатель здесь шерп тер тяжелее
получить ну в общем есть средства и для этого да но это как раз нам подстоит он лежит в заголовочном
вот но есть еще более простой вариант это вот другой подход это юник птр юник птр это в
которой нельзя копировать вот это наиболее простое решение просто копировать нельзя у него дилет
конструктор копирования оператор присваивания объект юник птр нельзя копировать вот такой вот
вот такая вот структура у которой но я могу просто писать конструктор копирования равно дилет вот
это и сделано юник птр чтобы не париться чтобы не было накладных расходов на ведение этих счетчиков
но главный функционал работает вот такие дела правда мувать можно но вот что такое мув
это тоже сложный разговор поэтому мы с вами обсудим как работают эти умные указатели уже
когда будем подкованы в му в семантике и тогда реализуем их заодно эти умные указатели вот
это называется идиома ра и и а расшифровывается так ресурс эквизишин ресурс эквизишин из инициализация
ресурс эквизишин из индициализация приобретение ресурса есть инициализация когда вы хотите
захватить какой-то ресурс то неплохо бы создать объект обертку над этим ресурсом который в
деструкторе будет освобождать этот ресурс тогда вы избавитесь от проблемы вот этой вот которая
бывает что у вас исключение вылетело посреди вашей деятельности ну конечно это добавляет скажем так
геморроя к разным программированию потому что теперь надо париться еще об этом когда вы
захватываете ресурсы надо помнить да ну вот мы уже вот очень скоро с вами увидим как на практике
приходится писать код чтобы он был безопасно относительно исключений и вот прям даже сегодня
я думаю мы это успеем увидеть первая ваша задача во втором семестре которая вам выдам в этом
семестре но она будет относиться ко второму это вот будет как раз большое развлечение на то как
с исключениями работать ну да в начале февраля скорее кто хоть в январе будет
решать не не рассказывать вот для delete квадрата да есть ну для этого надо вот такой у них
птр вызывать еще он делает delete квадратной скобочки а не просто delete p да у них птр есть
специализация для массивов но я не рекомендую вам ей пользоваться никогда ну потому что она
уродская потому что она не знаю никогда не видел чтобы она использовалась по-моему ее даже
ну короче очень специфичная штука на самом деле такая не знаю какая-то очень странная очень
стыдно я бы сказал ладно вот теперь исключение в конструкторах смотрите какая штука представьте
что мы пишем какой-нибудь класс класс ну не не что-то я не то пишу dangerous да опасный опасный да
можно писать класс exceptional да отличный класс отличное название ну да давайте вот мне больше
нравится такое название вот такой вот класс и он вот чем интересен он в конструкторе кидает
исключение как же хорошо жить а этот мой конструктор треугольника например видите как
удобно так подожди надо в таких такие моменты надо бы ошибку компиля а ну там от вектор
у тебя конструктор да тогда никак тогда это правда ну вот ну все все тихо не об этом сейчас а вот
у меня класс который в конструкторе кидает исключение что может пойти не так например
что вот отличный вопрос давайте подумаем ну давайте я ну я вот этот сотру пожалуй вот давайте я создам
exceptional от этого x и вот вызову сет нуля что же тут пойдет не так что же тут может пойти не так
но тут я все обработаю ну вот какая течка памяти куда она возьмется да у нас нет полей а если бы были ну
если если ну вот давайте так сделаем я вот это вот поле инициализируете мексом
да это все лежит на стеке поэтому когда вылетает исключением он должен снять все поля со стека
вот и ну и ну и сам объект exceptional со стека тоже должен снять поэтому ничего плохого пока
еще не будет но ладно а вот если а вот если здесь будет такая история мы не сможем выращаться
после его создания потому что он уничтожен и что после после его создания пошел ничто что
в момент когда ты создаешь x от x у тебя уже ты выходишь из этой функции потому что там
exception и и все но если ты создался нет нуля то все нормально будет обращайся пожалуйста конечно
в этот момент он вылетит из f просто ну вот теперь я сделал еще более хитрый пример теперь
у меня в exception лежит pointer который я освобождаю в деструкторе
тоже все должно быть нормально потому что у нас происходит инициализация а в общем
складывается нас так а потом начинается выполняться начинает выполняться вот конструктора
потом давайте я сначала не так сделаю извините меня давайте я сначала вот так
сделаю давайте сначала я сделаю стд share от птр вот здесь а тут ничего не будет происходить
ну диструкторе меньше не надо делать вот вот такой пример сначала рассмотрю более простой я
постепенно ухудшаю ситуацию вот в этой ситуации будет ли что-то плохое ничего плохого не будет
все еще потому что пэс создалось до когда летит исключение нужно уничтожить ну нужно снять нужно
уничтожить все поля которые были успели которые успели создаться но п успела создаться и значит
оно должно быть уничтожено вы ну все поля успели создаться вызовутся диструкторы полей вот когда
я вылетаю из конструктора с исключением вызываются диструкторы всех полей прежде чем я сниму со стека
сам объект и вылечу из этой функции поэтому здесь все будет хорошо но вот в этом примере уже не
будет все хорошо нет диструктор от exceptional как раз не должен вызваться и в этом весь и разговор
в этом вся и суть разговора потому что exception не создался не со не был не был создан объект
до конца вот когда мы вылетаем из конструктора с исключением у нас вызывается диструкторы всех
полей но не вызывается диструктор самого класса и вот в такой ситуации будет уже утечка памяти
потому что мы ну подумаем логически нельзя вызывать диструктор объекта который недосоздался ведь
мы не закончили конструктор правильно если бы мы если бы вызывался в такой ситуации диструктор
exceptional а то это бы приводила к убе зачастую ну потому что диструктор он пишется в предположении
что объект создан и в нем все там вся логика все проставлено все значит свойства объекта
соблюдены а если у нас внутри тела конструктора что-то пошло не так и мы не смогли до делать
создание объекта то поля то мы все-таки создали и поля уничтожить надо но сам объект мы не
создали он объект не считается созданным пока не доработает как конструктор до конца и поэтому
нам нужно ну поэтому мы не имеем права вызвать диструктор вот такая логика поэтому в такой
ситуации будет утечка памяти но вот если там был шерп тера то не будет утечка памяти а в такой
ситуации будет утечка памяти потому что диструктор exceptional не вызовется это еще
один аргумент почему нужно использовать умные указатели вместо обычных указателей а если у нас
ровно стоит не конструкторе диструкторе при этом конструкция прекрасно это следующий пункт который
я собираюсь обсудить ну с этим окей допустим понятно теперь давайте представим что у нас
фроу есть в диструкторе не ну я даже не знаю что здесь сказать если вы указывает на двое то
вот так какой-то все нормально мы прекращаем уничтожать так не у нас после этого будет дилит
прописан который не сработает ну да но мы сами навалили но просто мы вышли из диструктора и
полетели с ошибкой все что мы не успели уничтожить как бы мы сами а исключение в диструктор да я забыл
сказать главное исключение в конструкторах это плохо старайтесь так не делать но это не
настолько плохо насколько исключение в диструкторах то что ты хотел сказать можем это будет следующее
что я обслужу после исключения в диструкторах все продумано все продумано да да да и самое
главное я же это вас все потом спрошу на зачете ну может быть не все это ну что-то из этого я
о чем-то из этого вопроса будут это пока еще да пока еще это в рамках программы первой
семью да хорошо что все что надо можно получить по очереди так что плохого исключения в диструкторе
вот почему исключение в диструкту тут-то вроде ну что ну тут просто если что-то пошло не
так то дилит п ну конечно так будет утечка памяти да если если под п лежит не 0 то значит
там будет утечка памяти ну давайте хорошо если под п лежит 0 то будет утечка памяти потому что
опять код диструктора не до выполнится до конца поле со стека снимется но никто дилит не вызовет
после чего сам объект снимется со стека вот но есть проблемы и пострашнее да да какое-нибудь
сетевое приложение что-нибудь вам не удалось ну вот вы в диструкторе допустим вы что вы должны
тсп соединение с сервером разорвать вы тсп соединение оно начинается там с обмена рукопожатием
и заканчивается тем до свидания до свидания ну вот вы послали до свидания вам не ответили например
и что делать может можно просто убить подключение все и не принимать никакие ответы ну да ну корректный
корректный способ завершить там подключение ну кстати в тсп может я кстати может вас обманул
может тсп не надо дождаться ответа но в некоторых протоколах для того чтобы корректно завершить
подключение нужно послать типа до свидания и дождаться чтобы вам ответят до свидания потому
что иначе он будет думать что вы еще живы и типа будет дополнительную какую-то нагрузку
да возможно еще второе подтверждение да ну действительно короче теоретически бывает когда
надо в диструкторе хочется что-то бросить подмывает значит дьявол вот сделать такую вещь а ну вот кто
понимает почему это вот уж совсем плохо ну вот вообще ужасно это даже это вот в разы хуже чем
исключение в конструкции нет нет не в ту сторону вы думаете дело в том что исключение исключение
в диструкторе они иногда могут приводить к тому что ваша программа крешница без возможности это
поймать смотрите вот представьте себе такую ситуацию смотрите вот представьте такую ситуацию
вот я вот я создал какой-то объект а потом начал еще какие-то действия делать и вот выяснил что
что-то пошло не так и надо бросить исключение пока у меня существует этот объект объект существует
а мне надо бросить исключение я бросаю исключение но в этот момент объект должен сняться со стека
а для этого должен вызвать его диструктор я бросаю исключение и это приводит к раскрутке стека вот
этот стэк анвиндинг как я говорил и вызываются диструкторы всех локальных объектов чтобы быть
снятыми со стека чтобы я выскочил свои функции потому что исключение летит но так вышло что
пока я вызывал эти диструкторы один из них сам кинул исключение и вот это и вот это катастрофа
которая которая не подлежит обработке в этот момент все падает и ничего поймать нельзя если
вылетает исключение в момент когда уже летит исключение то все падает сразу не не поддерживаются
присутствует два одновременно исключения а с первым тогда что делать ну это это явно что-то со
вторым тогда что делать это явно что-то не корректное это значит что что-то пошло совсем
не по сценарию надо падать ну потому что у вас обрабатывается одна ошибка и в этот момент
произошла другая которую вы молча проигнорируй так делать нельзя надо падать нет нельзя ну как если
вы не ловите то вы падаете но поддерживать два исключения одновременно нельзя поэтому просто
падает все сразу и это кстати хорошая мысль существует такая функция стд анкот exception
не стд анкот exception наоборот значит стд анкот exception это такая булевская функция
без параметров которая поддерживается на уровне либо ну то есть и она как-то внутренне реализована
компилятором и она возвращает true если в данный момент летит не пойманное исключение вот если
вам уж очень надо в деструкторе кидать исключение то вы можете вызывать эту функцию и
ну вот проверять ну вот если она вернула фолс то нормально почему это вы
знаете сразу в него идет оно снимает сначала объекты со стека оно выходит из функции оно не
может знать сразу в какой трой кач оно попадет потому что оно может потому что стек функции это
рон тайм вещь она стек функции по разному может выглядеть чего
причем тут это вот вот прям сейчас я бросаю исключение и вот здесь мне нужно снять вот этот
объект со стека и для того чтобы его снять нужно бросить исключение еще одно как быть с этим
кто где поймает нет короче я еще раз говорю если бросается исключение в диструкторе в момент
количества исключения все выпадаете сразу а возможно потому что это устаревшие и начиная с
и плюс плюс какого-то там двадцатого что ли оно стало уже во множественном числе
кажется возможно возможно что-то что-то меняли поэтому подождите сейчас я вам я еще не так
рассказал что сам расскажу вещь после которой ваше представление здесь самое важное еще не было
сказано подождите вот короче есть такая функция да если во время раскрутки стека летит исключение
ну давайте я продемонстрирую как это выглядит ну а как мы падаем ну просто terminate происходит
ну вот здесь написано throw will always call terminate вот что произошло ох
ну вот потому что когда пришлось бросить runtime error в тот момент когда уже летел int все мы
сразу упали вот но сейчас я вам кое-что покажу что вас возможно удивит я стираю вот эту вот
часть где я бросаю исключение где я бросаю int и просто вот так делаю и запускаю в чем дело
нет как оно должно было быть поймано здесь ой
то есть даже несмотря на то что не было второго исключения я все равно упал почему потому что
начинает c++ 11 ввели следующее правило исключение в деструктуре бросать просто нельзя если бросать
исключение в диструктуре вы сразу падаете вот то есть вся эта история про то что нельзя бросать
исключение в деструктере, потому что если вдруг это будет второе исключение, когда летит уже первое, то вы упадете, она была актуальна до C++11.
А после этого просто бам. Вот, да. И в C++11 решили, что давайте просто запретим бросать исключение, в принципе, из деструкторов, ну, потому что это вообще очень плохо.
Вот, и вот здесь даже компилятор мне об этом сказал. Note in C++11 destructors default no accept. Ну, то есть, из деструкторов по умолчанию бросать исключение нельзя.
Если вы бросаете, сразу рье. А это же получается ломается код, который раньше мог работать. Ну, да. Можно видеть. Да? Но всем насыкать.
Но вот на это решили забить. Решили сказать, что вот если кто-то бросался к чему-то в деструкторе, то он сам виноват. Он сам знал, что он делает, что иногда он будет падать просто без предупреждения.
Ну, теперь он может всегда есть буквы слова по умолчанию. Да, это можно себе позволить это делать. Если написать специальное, ну, если написать волшебное слово, то можно будет бросать исключение из деструкторов.
Ну, надо написать no accept false. Я сейчас вам это покажу. Вот, но прежде чем это показать, давайте я разберу последний пример. А именно, что если исключение возникает вот здесь.
О, Господи. Можно вопрос? А почему на этапе CE нельзя проверять, что не брошено исключение в деструкторе?
Почему нельзя в Compile Time проверять, что исключение не бросается? Это отличный вопрос. На эту тему есть длинный большой ответ на Stack Overflow.
Я даже на эту тему однажды дискутировал там, в Яндексе, тогда еще, три года назад, с коллегами, потому что для некоторых, ну, для многих, и для меня тогда это было для самого удивлением, почему казалось бы просто не сделать проверку этого в Compile Time.
Правильно. Но дело в том, что эта проверка привела бы к тому, что у вас бы сломалось уже слишком много. Вы должны запретить throw, но тогда вы должны запретить в том числе и new и dynamic cast.
А еще вы должны запретить все, что потенциально кидает исключение же, иначе это бессмысленно.
Я хочу мы напишем свои исключения.
Ну, вы должны тогда запретить, если вы хотите в Compile Time проверять, то вы должны запретить не только throw непосредственно, вы должны запретить также любые операторы, которые бросают исключение, а также любые вызовы функций, которые сами могут бросать исключение.
То есть вы должны весь потенциальный stack вызовов, все, что вы делаете в деструкторе, все методы до самого конца проследить, не бросают ли они исключения хоть в каком-то сценарии.
Нельзя по старому сценарию запретить слова типа throw, assert или еще что-нибудь, а если написал остальное, а сам дурак знал, что делал.
А что в этом случае будет происходить?
Ну, то, что происходит сейчас, например.
А, то есть у вас и так warning есть?
Ну, просто этот warning сделать Compiler Aurora.
Ну, минус в Error.
Ну, по стандарту это довольно странное костыльное ограничение, что в деструкторах нельзя писать слово throw, но вообще бросать исключения можно, но вот если они обернуты в одну слово, в один свой.
Да, именно throw в деструкторе это CE, но это какая-то очень странная штука.
Ну, типа очень странный костыль.
Вarning вы и так получаете, а проверять по всему стеку вызовов, что вы никакую функцию не вызываете, которая не вызывает еще через 10 слоев функцию, которая бросает исключения, такого в Compiler Time уж не хочется делать, поэтому этого не сделали.
А последнее, что я разберу, что если исключения вылетают вот тут?
Вот пусть у меня есть функция G, которая, ну пусть тут уже int просто.
А объект когда-то снимется на стеку, если у него вызываются исключения?
Объект конечно снимется, ну что значит объект, поля объекта снимутся, ну а значит и он сам.
Объект это же его поля, у него не, поля в любом случае уничтожатся, которые успели создаться.
А как проявлять какие успели создаться?
Ну как? Которые до этого были прогнициализированы, те и успели.
Ну не знаю, вот тут return y плюс 1, но если y равно нулю, то что-нибудь бросить.
Кстати, не очевидно все-таки про остальные поля, а вдруг...
Что не очевидно? В деструкторе все снимется.
В деструкторе мы договорились, что мы его не вызываем.
В деструкторе мы вообще пока не умеем бросать исключения.
По диструктору речь, не очевидно, что вы здесь делаете, если у нас поля не все прогнициализировались.
Что, где не очевидно?
Когда ты находишься в теле конструктора, у тебя все поля уже прогнициализируются, значит они для всех вызываются диструкторы.
Ну послушай меня, ну послушай, если ты в списке инициализации, вот сейчас мы этот случай разбираем.
Что если исключение вылетает в списке инициализации?
К этому моменту какие-то поля уже прогнициализированы, то есть у вас несколько полей.
Ну до этого могут быть еще какие-то поля.
Ну хорошо, пусть еще будет поле, не знаю, t.
Вот вы уже прогнициализировали t.
Сначала t, потом x.
Ну, к моменту инициализации x, t уже прогнициализировано.
Тем не менее, что будет, если вот попытка инициализации какого-то поля кинет исключение?
Ну понятно что, а вызовутся диструкторы для всех предыдущих полей?
А для следующих?
Для следующих, конечно нет, потому что они не прогнициализированы еще.
Почему? Давайте уже передадим указатель на zys, и пусть у нас после x будет t, который тоже будет и нет.
Что? Что такое указатель на vys?
Минуточку, разыменование vys это убеда до тех пор, пока объект vys не создан.
Ну ладно.
У тебя не созданный не то что объект vys, у тебя поля не созданы еще.
Ты можешь куда-то отдавать vys только то, что объект создан.
А стоп, внутри конструктора нельзя здесь обращаться вообще, получается.
Ну хорошо, к полям vys ты можешь обращаться внутри конструктора к полям vys, потому что ты знаешь, что они уже созданы.
И к методам некоторым ты можешь обращаться, потому что ты в конструкторе, потому что ты сам пишешь логику своего класса.
Но отдать куда-то указатель для конструирования одного из полей на vys вовне это очень плохо.
Понятно, что это плохо.
Ну так не надо так делать.
Или там указатель на поле следующее, например, передать.
Убе это будет.
Поля инициализируются в порядке объявления.
Если ты передаешь чуваку указатель на поле, которое заведомо не проинциализировано, то ты задаешь убе.
Какие претензии?
Так тем не менее, а вот это вот исключение, окей, оно значит вылетает отсюда.
А его нельзя ли как-то поймать здесь?
Вот что делать, если исключение вылетает в списке инициализации?
Как его поймать, не вынося, так сказать, ссор из избы?
Вот если у меня не получилось проинциализировать, то есть я про это рассказываю даже не к тому, что будет уничтожено, а что нет.
Понятно, что вызвался деструктор предыдущих полей.
Но как мне добиться того, чтобы это исключение было поймано прямо внутрикласса?
Как это сделать?
Никак.
Ну, можно проводить прямо там.
Нет, в тело мы не зайдем немножко.
Есть следующий синтаксис?
Значит, существует следующий синтаксис, это называется FunctionTryBlock.
Вот, можно писать try перед списком инициализации, и тогда catch надо будет писать после тела конструктора.
Этот try поймает то, что вылетело в списке инициализации или же в теле конструктора.
При этом понятно, что будут вызваны деструкторы всего того, чего надо.
Причем, кстати, вот тут я уже сам не помню, по-моему, когда мы будем в этом catch, еще поля не будут уничтожены.
Ну, то есть те поля, которые успели проинциализироваться, еще не будут уничтожены, по-моему.
Но тут я чуть не уверен. Ну, по-моему, да, не будут.
Ну, можно проверить.
Вот, но на самом деле это можно использовать и в обычных функциях. Можно писать try вот прям здесь.
Если вам надо все тело функции обернуть в try-catch, то можно писать try прямо перед открывающим, открывающим фигурный скоб и функция.
И тогда вся функция как-бы будет обернута в try-catch.
Тогда вот если у вас все, что угодно в этой функции произойдет, вы поймаете это прямо тут, на этом уровне.
Но потом, но потом в сравнении с функцией есть, да?
Нет, ну если вы после catchа, внутри catchа снова напишите throw, то да. Ну а если нет, то нет.
В плане, вы завершите выполнение функции, но не вылетите с заключения.
Ну, мы корректно завершили.
Ну, вам нужно написать, что оно вернет.
Ну, вам нужно здесь будет написать, что вернуть, да. Вот здесь вот.
Это то же самое, что написать try внутри функции на всю функцию. Это просто короче.
Но, вот когда без этого не обойтись, это вот тогда, когда у вас исключение в списке инцелизации, то есть вы не можете написать в этой функции.
Нет, нельзя.
Тогда оборачивай просто try и все тело конструктора.
Можно вопрос тогда?
Ну.
Вот мы, мы допустим, мы оборачиваем все тело конструктора.
Ну, мы не оборачиваем все тело конструктора.
Мы не оборачиваем все тело конструктора.
Мы не оборачиваем все тело конструктора.
Мы оборачиваем все тело конструктора.
Можно вопрос тогда?
Ну.
Вот мы, мы допустим, создали объект, типа исключение.
Ну, короче, вот этот объект.
Ну.
Которым у нас в конструкторе вызвался вот этот try.
Мы его перехватили catch и мы вышли.
Я правильно понимаю, что после этого любое взаимодействие с данным объектом, это уб.
Сейчас.
Вот вы.
Кстати, интересный вопрос.
Я даже не думал об этом.
Слушайте, а я даже не знаю.
Что будет, если мы не оборачиваем все тело конструктора?
Если вы тут поймаете и не пробросите дальше.
Типа, если у нас здесь не пронициализировались поля.
Мы, значит, это здесь поймали, не пробросили дальше.
А этот объект как бы существует?
И мы, типа, такие, оба идем дальше.
Ну, может, рассчитывается, что мы в гэтче должны их пронициализировать тогда?
Ну, то есть, как бы мы их инициализировали просто из тела.
И что если мы это не сделали, то они какие-то дефолтные.
Какие дефолтные?
Если у них нет конструктора.
Ну, если у тебя нет конструктора.
Если вы не шалайзер листе не напишешь конструктор, то для примитивных типов там будет мусор.
Для непримитивных там назовется дефолтный конструктор.
Ну, вот да, в этом и есть.
Нет дефолтового конструктора.
Мы не успели дойти до конструктора.
При создании у нас нужно сохранить.
Да.
Да.
В результате полного конструктора нет, но у тебя там будет мусор.
Ну, а ДНТ есть, но вот у меня есть структура, у которой нет дефолтового конструктора.
Да, у тебя же может структура просто быть...
Ну, тогда это runtime.org будет.
В смысле runtime.
Ну, давайте проверим.
Это, кстати, отличный вопрос.
Я что-то даже и не знаю.
Отличный вопрос.
Да, да, я прям даже...
Сохраним его.
Ну, не, не, не, не.
Для вас это не будет вопросом, потому что, ну, раз я не знал, то я такие вещи сам не буду спрашивать.
А на следующий год уже можно, все правильно.
Так все и происходит.
А...
Да, ну давайте проверим, что будет.
Вот, значит, здесь я просто удалю этот конструктор.
Это что ж такое-то?
Это, скорее всего, ну, что-то типа Fatal Aurora.
Вот, а здесь...
А, господи.
Какого Fatal Aurora? Ты что?
Ну, да, есть...
Ну, давайте попробуем это скомпилировать.
Может быть, оно просто не скомпилируется.
Эм...
А потому что S маленькое?
Да.
Он скомпилировался.
Логичная странность.
Мы не можем это в compile-time отловить, потому что нормально.
Мы не можем в compile-time сказать, что у нас cache вообще вызовется хоть раз.
Слушайте, я не знаю, что будет.
Нет, я не хочу тратить время, потому что некогда.
Давайте забьем.
Ну, в общем, я не знаю, что будет.
Это очень прикольно.
Спасибо за вопрос, но я не знаю ответа.
Можно науглить.
Можно почитать страничку cpp-reference про это.
Да, прикольно, прикольно.
Вопрос был про то, если мы не кидаем исключения.
Потому что тут cpp-reference пишет, что каждый кетч автоматически из функции делается ровно, даже если не написано.
А, ну все.
Значит, тогда на самом деле мы все.
Ответ получен.
Что из функции делается?
Мы просто, из этого, да.
Если ты зашел в кетч и там даже не написал в тролл, то он автоматически будет ровно.
А зачем он нужен?
Как решил комментировать по стандартизации?
Нет, он нужен, чтобы если ты успел что-то проинциализировать, а что-то не успел,
ты как бы успел сделать какие-то действия.
Но вдруг ты в инициализации какого-то поля произвел какие-то вычтения, которые там в свою очередь требуют...
Вдруг я не хочу croll, вдруг я хочу там вынициализировать чем-нибудь другим?
Все поля.
Хотя с другой стороны, казалось бы, там можно было просто деструктором обойтись.
Но деструктор у нас же еще не создан в нырях.
Нет, деструктор для предыдущего поля, которое создано.
Так разве деструктор не вызовется?
А если мы в кетче, то мы можем в кетче написать delete.
Да, ну например для этого.
Если ты успел сделать не u из полей, а следующее поле у тебя при создании кинуло исключения,
тогда ты можешь в кетче сделать delete на то поле, которое успел сделать u.
То есть у нас не вызовется автоматический деструктор?
Вызовется автоматический деструктор.
Это не поможет. Нужно сделать delete p.
Так, значит с этим мы закончили.
И последнее.
Последний параграф это noexcept.
7.5 exception specifications.
Спецификация исключений.
Начиная с 7.11, вы можете...
Ну на самом деле и до 7.11, но там это было очень криво.
И даже не стоит вспоминать, как там это было.
Но начиная с 7.11, вы можете пометить функцию как не кидающую исключение.
Ну например, я не знаю, вы реализуете в своей строке метод size.
Там у вас size t, size const и вы можете его пометить еще словом noexcept.
Ну вы наверное видели на cpp-reference многие методы в многих контейнерах.
Ну в многих классах помеченного таким словом noexcept.
Noexcept это означает, что вы обещаете, что исключений не будет.
Зачем?
Чтобы тот, кто ваш код вызывал, не парился по всем тем поводам, которые мы тут до этого полчаса обсуждали.
Вот если кто-то вызывает в строке size, он точно знает, что ничего плохого не случится.
Вот.
Хотелось бы верить, что хотя бы size работает без exception.
Ну size работает без exception, он просто возвращает int.
Ну вот, кстати, вопрос.
Ну вот тут у меня есть, значит, я снова эти поля size t, size const, size const.
А вот вопрос.
Вот у меня есть такой замечательный оператор, квадратные скобочки.
Но он не константный.
Он принимает индекс.
Ой, господи, что со мной сегодня?
Он accept или нет?
Нет.
Стоп, секундочку, мы же там никаких проверок не сделаем.
Если мы обращаемся куда-то за границей памяти, это просто уб.
Да, да, мы там ничего не делаем, просто уб.
То есть exception оттуда не вылетает?
Exception оттуда не вылетает.
Тем не менее, этот оператор не noexcept.
Просто уб.
Да, да, мы там ничего не делаем, просто уб.
То есть exception оттуда не вылетает?
Exception оттуда не вылетает.
Тем не менее, этот оператор не noexcept.
По стандарту.
Если вы посмотрите, то квадратные скобочки нигде не noexcept.
Ну в векторе, наверное, он может быть.
Нигде.
Просто вероятно, он имеет то же происхождение, что и вектор.
А в векторе, если вдруг ты обращаешься по объекту, который не существует, возможно у него внутри будет noexcept.
Нет.
Вектор точно так же, как строка работает.
Обратился мимо уб.
Ну потому что это уб может быть exception.
Нет.
Нет?
Не может быть exception.
Ну, теоретически может.
Уб может быть всем чем угодно, но оно не будет exception точно.
Почему?
Давайте сделаем массив фактически два раза больше и будем там хранить какие-нибудь объекты, возвращающие сроу при обращении к ним.
Что значит объекты возвращающиеся сроу при обращении к ним?
Чего?
Мне кажется, ты не понимаешь, как вектор устроен.
Там сырая память лежит по адресам, за которыми ничего нет.
Не, а давайте фактически выделять больше.
Да, но так и есть.
Выделяется больше.
Но там хранить объекты...
Там не хранятся объекты.
В смысле?
В прямом смысле.
Нет, так нельзя делать.
Нет.
Нет.
Нет.
Нет.
Нет.
Нет.
Нет.
Нет.
Нет.
Нет.
Нет.
Нет.
Нет.
Нет.
Нет.
Нет.
Так нельзя делать.
Там сырая память лежит.
Нет, она не инициализированная.
Кто?
Мы?
Вектор?
Кто мы то?
Кто?
Кого ты здесь видишь?
Внутри класса string будем гарантировать, что по индексу там минус один будет лежать
что-то, что кидает сроу.
Что значит что-то, что кидает сроу?
чар лежит по индексу минус 1.
Ну блин.
Уйдем от стринга, к чему-то посложнее.
Мы сейчас обсуждаем конкретный
вот стринг и вектор.
Вот почему квадратные скобочки в них не
noexcept, хотя там неинициализированная
память, если ты выходишь за границы.
И там нет проверки на то, что
ты вышел за границу. Ты просто возвращаешь
ссылку на неинициализированную память.
Не noexcept, потому что
значит
опять-таки в свое время
я читал про странный ответ
на stackoverflow про это, можно его
нагуглить.
Ну вот считается, что
noexcept
в общем, принято
не писать noexcept
в ситуации, когда что-то может быть
не так. Noexcept это как бы слово, которое
а
его
значение несколько шире, чем
просто не вылетит исключение.
Noexcept ставится у методов
по крайней мере в STL, так принято
ставить noexcept только у методов,
у которых в принципе ничего не может
пойти не так. Вот если у вас
метод при некоторых параметрах
может, скажем так,
завершиться неудачно, не обязательно из
исключения. Ну просто вот если он
ub иногда возвращает, то это уже не
noexcept. Noexcept помечаются
методы, которые вот точно
с которыми точно ничего плохого
не будет. Вот ты их вызвал, и они
гарантированно не
упадут и не приведут к ub.
Ну просто так принято.
Просто noexcept
ставится только у таких методов.
Просто это делается для
удобства пользователя, для удобства
читателя. Вот.
А что
произойдет, если
вы из noexcept метода кинете
исключение? Или
вызовете какую-нибудь функцию, которая
там в итоге кинет исключение?
Ну нет.
Re. Почему?
Потому что я уже объяснял почему.
Потому что мы не будем
потому что это
во-первых очень сложно, а во-вторых это
сломает весь существующий ранний
код. Если мы будем ce
что?
Чего нельзя делать?
Ну он ведь может исключение, но вообще
все, что вызывает исключение, нужно убрать.
А если ты
его ловишь, то окей.
А если ты вызываешь
если ты ловишь, то окей.
А если ты вызываешь какую-нибудь функцию,
которая в сочи вызывает функцию, и так еще
цепочка из десяти функций, которая кидает
исключение. Это тоже нужно все проследить
и запретить.
Ну
Нет.
Это не отслеживается в compile time. Я уже
объяснял. Это нереально.
То есть теоретически это возможно
отследить. Но это во-первых
эта компиляция во-вторых-то сломала бы
тонны существующего до этого кода.
Просто пришлось бы везде расставлять
этот noexcept и просто
все бы с ума сошли. Ну представь, теперь у вас
на каждый чих
вы и так уже
задолбались везде const писать, если вы
объект не меняете. А теперь представьте
вам еще везде нужно было бы
расставлять noexcept, если вы исключений
не кидаете, вот прям точно не кидаете.
И это по всему
старому legacy коду надо было расставлять.
В какой порядке правильно написать override const
и noexcept?
Аааа
const
const noexcept override
по-моему.
То есть const видимо всегда первый
идет? Ну const да, const в начале
а что раньше override
или noexcept
я думаю что override
что noexcept раньше, потому что
noexcept начиная с
c++17 это по-моему часть сигнатуры.
То есть
если у тебя была родительская функция
noexcept, а ты
в дочерме не написал noexcept
то ты ошибся в сигнатуре и
это разные функции
да, да, это разные функции
и поэтому надо писать override
обязательно, но override после
потому что оно как бы говорит, что вот сигнатуры
а дальше я говорю override. Спасибо
сознательному силу и счастливой детства. Да
за счастливую юность я бы лучше
сказал. Ну может детство
у кого-то счастливое было тоже
детство не было
хорошо
так, окей
есть еще условный noexcept
условный noexcept
это noexcept когда вы
ну например
очень негативно
не гарантируем. Нет, когда вы
бываете то noexcept то нет в зависимости
от каких-то compile там условий. Ну например
вот, а че стринг с кругломисковкой
что-то сегодня со мной вообще не то
ну вот, давайте
считать, что я теперь реализую вектор, а не
строку
ну да, давайте вектор с большой буквы
и вот здесь
допустим, допустим
я хочу этот оператор сделать
условным, условным
noexcept скажем
в зависимости от того, ну вот если
тип T это класс, то условно
то будет
noexcept, а иначе нет
ну что-нибудь в таком-то
не-не, я хочу
вот просто сказать, если тип
ну я не знаю, какой-нибудь
просто какое-нибудь условие
noexcept, вот если какое-нибудь условие
то noexcept
тогда я могу написать условно noexcept
noexcept, а в скобочках некоторое булевское
выражение
если оно true, то будет noexcept
например
я из pointer
v от t
вот, этот метод
будет noexcept в том и только
том случае, если тип T был
указателем
я пока оставляю
за рамками разговор
для чего это может быть надо, ну вот
условный noexcept
а, ну например, получение обратного элемента
в классе Residue, если модуль
непростой, то он точно noexcept, а если модуль
непростой, то бывают те элементы, у которых нет
обратных
нет, если модуль непростой, у вас не должно
не Residue, а Resdue
и
ну в теории бывают обратные элементы
так что для некоторых можно
нет, вам нужно, чтобы этого метода не было
у класса, который
непростой, вы просто
да, вам
вы хотите целью
да, ну например, можно было бы так сделать
да, действительно, можно было бы сказать, что
это noexcept при условии
что у нас
простое число
а если не простое, то иногда бывает exception
да, но у вас другое требование
у вас нужно CE выдавать
да, хороший пример
вот
вы можете написать просто
noexcept true или noexcept false
ну здесь любое булевское выражение должно быть
compile-time-вычислимое, noexcept true
значит всегда noexcept, noexcept false
значит никогда не noexcept
и вот
а зачем такое писать?
а вот помните, я вам говорил, что есть волшебное слово
как разрешить деструктуру
бросать исключения
надо написать noexcept false
вот если вы напишите деструктуру noexcept false
то вы разрешите бросать исключения
из деструктура
потому что он как бы noexcept
но нет, ну как бы нет
а
вот
и бывает, послушайте, бывает
часто такое, что вам нужно сделать какой-то метод
noexcept или нет в зависимости от того
является ли noexcept что-то другое
ну например
я здесь, ну я не знаю, что я сейчас реализую
я какой-то метод реализую
ну вот допустим я здесь вызываю какой-то метод
фу, еще
ну какой-то метод f
вот, f
от
не знаю
от чего-нибудь
с шаблонным параметром t
вот, я не знаю вот этот метод
он noexcept или нет, он может быть сам
noexcept или нет
я хочу сделать свой метод
noexcept
если то, что я вызываю
внутри само noexcept
вот мне нужно сделать
условный noexcept в зависимости от того
является ли noexcept то, что я использую внутри
но
да, для этого существует
оператор noexcept
не путайте, пожалуйста
спецификатор noexcept и оператор noexcept
существует еще оператор
noexcept
оператор noexcept
он работает как
sizeof или как typeid
он
compile-time вычислимый, он возвращает
bool и принимает
некоторое выражение, он не вычисляет
это выражение, как и
sizeof
он не вычисляет выражение
он просто говорит
true или false в зависимости от того
есть ли в этом выражение
не noexcept функции
что это значит
он смотрит на это выражение и говорит
присутствует ли в нем throw
или
new, или dynamic cast
или typeid
или какой-то вызов функции, который не
помещен как noexcept
присутствует, то ответ false
а если ничего этого нет, то ответ true
соответственно
чтобы вам поставить
noexcept своей функции в зависимости от
условий является ли noexcept другая
функция, вам надо написать noexcept
от noexcept
от этого выражения
как же я это угадал
да, noexcept от noexcept
здесь первый noexcept
это спецификатор
а второй noexcept это оператор
а если у нас в этом выражении
в f мы передаем аргументы каких-то
типов
то мы здесь должны не
нет, он не вычисляет
выражение, он просто смотрит на сигнатуру
он решит перегрузку
увидит нужную версию, поймет
noexcept она или нет
если у нас f она там перегружена
допустим
ну вы здесь вызываете
от чего-то
он разрешит
перегрузку, выберет ту версию
посмотрит она noexcept или нет
это compile-time все делается
мы должны какие-то аргументы
представить в compile-time
да, можете им по умолчанию
подставить
ну и последнее
последнее
и перерыв сделаем
это
exception-safety
есть такое важное очень понятие
которое
будет
у вас
которое вы возненавидите
в ближайший месяц
два
ну в феврале точно возненавидите
exception-safety
вот теперь после того как мы изучили
исключения
программировать на c++
стало еще интереснее и
разнообразнее
потому что теперь
когда мы пишем код
нам нужно думать о том
особенно когда мы пишем какие-нибудь классы
или вот когда мы пишем контейнеры
например когда мы реализуем вектор
а нам нужно думать о том
а что если
методы
которые мы вызываем у
нижележащего типа t
бросают исключения
мы ведь вообще-то не можем
быть уверены, что они их не бросают
когда мы создаем вектор
кладем в него tr
а вдруг
tr бросает исключения
при создании
вот допустим мы
делаем pushback вектор
понимаем что нужно сделать реаллокацию
делаем реаллокацию
начинаем конструировать
t на новом месте
а оно исключение бросает
а мы реаллокацию уже сделали
что нам надо делать
нам надо
вернуть все как было
или еще хуже мы делаем реаллокацию
перекладываем, а пока перекладываем на новое место
оно исключение бросает
мы часть объектов уже переложили, а часть еще не переложили
конструктор t
при реаллокации может
бросить исключение
вектор, как и вообще любой контейнер
должен корректно обрабатывать эти ситуации
мы должны вернуть контейнер в исходное состояние
если любой метод t
мы не будем исключения пока мы что-то там делали в контейнере
это называется exception safety
вот контейнеры
которые вам предстоит реализовывать
они должны быть тоже exception safe
потому что стандартные контейнеры все exception safe
бывают два вида
exception safety
базовая гарантия
и strong
basic guarantee это
следующее требование
базовая гарантия
безопасности относительно исключений
гарантирует, что
если в процессе выполнения метода
над вашим объектом
вылетела исключение
какой-то метод вашего объекта кинул исключение
то класс
использующий ваш объект
не обязательно вернется
в исходное состояние, но он останется
по крайней мере в корректном состоянии
вот например
если вы в векторе делаете реаллокацию
или если вы в хэшмэпе делаете реаллокацию
или если вы в красном черном дереве
делаете повороты
вам нужно
если вдруг в процессе этого какой-нибудь объект
кинет исключение
вам нужно все переложить как было хотя бы так
чтобы контейнер остался в корректном состоянии
не обязательно в исходном
но в корректном
чтобы не было утечек памяти
чтобы не было часть объектов переложена, часть не переложена
чтобы он не был разломанным
это называется базовая гарантия
это говорит о том, что
объект должен вернуться в исходное состояние
не отличимое от того
в котором он был до начала работы
до вызова этого метода
вот почти все методы
всех контейнеров
в C++ они имеют
strong guarantee относительно исключений
то есть вектор, мэп
unordered, мэп, лдек
все что угодно
если в любой момент, любой метод вашего ТР
кидает исключение, то контейнеры
все переложат обратно
аккуратненько так, что не будет
утечек памяти, ничего плохого
все будет лежать обратно на местах
и контейнер вернется в исходное состояние
а что он при этом скажет?
ничего не скажет
он пробросит
ваше исключение дальше
вы поймаете это исключение
но контейнер будет как будто нетронутым
да, то есть если мы пытались
pushback-нуть
да, pushback-нуть что-то
если он кидает исключение
то он нам вытянет наше исключение обратно
а контейнер останется нетронутым
а стоп даже
да
то есть адреса все останутся
все останутся
нет, адреса не останутся
потому что у любой
нет, любой вызов pushback
нет, это другое
любой вызов pushback ломает адреса
нет, кстати
адреса все равно останутся
он не удаляет
он не удаляет, да, адреса все равно останутся
но так делать не надо
просто
после pushback-а
адреса вообще говоря ломаются
но в данном случае они не сломаются
еще раз, какие же
отличия между basic и strong?
basic это значит что вернется
в корректное состояние
strong значит что вернется в исходное состояние
все, давайте перерыв сделаем
я закончил тему главу 7
и на самом деле
это называется контейнеры
и итераторы
давайте сдвинемся
вот
такие
все плюс плюс существуют контейнеры
ну опять таки
я наверное
начну со слов вы все это и так
знаете
смотрите, есть
да, есть
есть такая библиотека шаблонов
которую
разработал в свое время
значит
наш соотечественник, между прочим
Александр Степанов, по-моему его звали
не, не, не
не он
не он
он
не очень хорошо
плюсы знает
плюс
не настолько чтобы
вот это реализовать я думаю
ну короче да
есть последовательные контейнеры
есть ассоциативные контейнеры
это два вида
контейнеры да
что тут контейнеры вообще
давайте начнем с разговора что такое контейнеры
а чтобы ответить на вопрос
что такое контейнеры я вам открою
страницу cpp-reference
тут написано что такое контейнеры
вот если кто хочет формальное определение контейнеров
вот что это
значит контейнер
это такой
да, параграф 8.1 называется
обзор контейнеров
контейнер это такой
класс
ну неформально
который используется для хранения
других объектов
и значит
он же следит за
меморе
ну там за использованием памяти этих объектов
вот теперь
что формально такое контейнер
пусть t это
тип элементов
c это тип контейнера
a и b это объекты
типа c
rv это значит
выражение типа c
а далее
приводится список требований
что должно быть чтобы объект считался контейнером
во первых в контейнере
обязательно должен быть объявлен внутренний тип
value type и он должен быть равен
t
и он должен быть
copy constructable и erasable
это еще некоторые требования
каким должен быть этот тип
вот copy constructable это значит что он должен
поддерживать копирование
вот
reference это еще один внутренний тип
который должен быть определен как temp percent
const reference это еще один тип который должен быть
определен как const temp percent
в векторе булов
референс
возможно
кстати что
он такой
просто
это понятно я про то
определенный тип референс как temp percent
не помню
но может
быть здесь ошибка
такой тоже бывает
референс бывают ошибки
стандарту конечно
но только стандарт
черновик он тоже предупреждает
что у него будут ошибки и неточности
скачай платный стандарт
если хочешь надежную информацию иметь
дальше внутри контейнера должны быть
такие типы как
иожет он
контейнер
и тут еще дополнительные
требования
конструирование атервэллию другого контейнера, присваивание, деструктор должен
быть, методы begin и end, c, begin, c, end, сравнение контейнеров, оператор не равно, метод
swap, просто версия вызов swap от двух контейнеров должен работать, size обязательно
должен быть у контейнера, max size и empty. Вот. И кроме того, вот еще здесь перечислено
каким должны удовлетворять требованиям все типы. Вот тогда это называется
контейнер. Я надеюсь, я удовлетворил требования буквоедов, ответил на вопрос, что
такое контейнер формальный, теперь могу использовать этот термин в разговоре.
Правильно? Вот. Если кому-то хочется формальное определение контейнера, вот
пожалуйста. Что такое erasable? Ну откройте, прочитайте. Ну типа я не хочу тратить на
это время. Контейнеры в стандартной библиотеке, их вот, сколько их штук? Ну типа
8, да. Это array, vector, deck, list, forward, list. Это так называемые sequence контейнеры.
Последовательные контейнеры, они, ну это уже не, ну кажется, есть тоже формальное
определение, что такое последовательные контейнеры, но я уже не буду его открывать.
Это контейнеры, которые хранят, ну, блин, ну как это сказать, я не знаю. Ну понятно,
что последовательные контейнеры. Это либо массив, либо двусторонняя очередь,
либо связанный список. Вот что такое контейнеры последовательные. Что такое ассоциативные
контейнеры? Это множество. Что неявное? Неявное декартовое дерево? Это не контейнер. Неявное
декартовое дерево, вообще любое дерево, это структура данных. Вот если ты его реализуешь,
если ты используешь его для реализации контейнера, то вероятно для ассоциативного контейнера.
Нет, оно же неявное. А, неявное. Я не знаю, давай читать определение последовательного контейнера.
Ну типа, ну да, наверное, это будет скорее последовательный контейнер. Ну блин,
понимаешь, что такие вопросы какие-то они не в тему, потому что ты спрашиваешь меня,
вот есть структура данных, какой она контейнер? Да сама по себе она никакой не контейнер. Вот ты
можешь реализовать какой-то контейнер на основе ее с какими-то методами, и тогда он будет, значит,
каким-то контейнером. А какой-то контейнер на основе его реализуешь? Ну я не знаю. Наверное,
ты реализуешь массив с дополнительными операциями там, что-то там, вырезание и вклейки. Наверное,
да, это будет последовательный контейнер, если ты реализуешь так. Наверное, да. Такого контейнера
нет в стандарт-библиотеке, к сожалению, или к счастью, не знаю. Ассоциативный контейнер
это значит сет мэп, мульти сет мульти мэп. Что под собой хранят сет мэп? Мульти сет мульти мэп,
красно-черное дерево там, во всех в них четырех. Вот еще unordered set, unordered map,
мульти сет мульти мэп. Это хэштаблица. Все знают, что такое хэштаблица? Я понимаю,
что вот хэштаблицу вы не проходили, поэтому у вас с ней могут быть сложности, но вам ее реализовывать
предстоит, поэтому вот как раз ее вам предстоит реализовывать во втором семестре. Что такое array?
Понятно. Это массив, хранящийся на стэке, массив фиксированного размера. Мы с ним уже работали.
Что такое vector? Вы все прекрасно знаете, это массив, который может динамически менять размер.
Вот его методы. Что такое deck? Это двусторонняя очередь. Deck это почти как vector, только еще
дополнительно она умеет делать push front и pop front. Push front и pop front. Это то,
что vector не умеет делать. Зато deck не обладает методами capacity и reserve. Что умеет? Deck умеет
обращаться по индексу, умеет добавлять в конец начала, но не умеет capacity и reserve,
потому что для него бессмысленно он устроен иначе просто. В вашей ближайшей задачей будет реализовать
deck как раз. Сейчас мы про него как deck устроим, возможно успеем поговорить даже подробно,
но сначала мы поговорим про vector. Лист. Что такое лист? Это связанный список. Что умеет лист?
Лист умеет также push back, push front, то есть добавлять в начало в конец. Важно,
что лист не умеет обращаться по индексу, зато он умеет делать вставку в середину за от единицы и
удаление середины за от единицы, а vector умеет только за от n. Ну, произвольное место. Ну,
если у вас указатель на это место, то бишь итератор, то у вас получится. Про итератор мы поговорим
уже попозже. Forward лист то же самое, что лист, только он односвязанный. А можно вопрос? Когда
мы говорим про контейнеры, мы говорим про них вместе с их реализацией или отдельно смотрим
на них как-то интерфейсы. В смысле, когда мы говорим, что у нас лист умеет за от единицы вставлять
в середину, а vector не умеет, это по сути какой-то вопрос реализации? Нет, это формальное требование
к листу. Нет, понятно, что про произвольный контейнер я не могу говорить, умеет ли он вставлять
в середину, это бессмысленный вопрос. Но про конкретный контейнер, есть требование прям в
стандарте. Vector это такой контейнер, который поддерживает такие-то операции за такую-то
асимптотику. Ну то есть, про все эти контейнеры прям в стандарте написано, что такие-то операции
должны быть и работать за столько-то. Сет, мэп, мультисет и мультимэп это двоичные деревья,
поиск, асполансированный, ну по факту красно-черный. В стандарте не написано, что они должны быть красно-
черные, но во всех известных мне человечеств реализации ХСТЛ это красно-черные деревья.
Ну unordered set, unordered map это хэштаблиция. Что такое хэштаблиция? Ну это такая структура
данных, которая позволяет вам делать, вот в общем-то здесь написано, что она позволяет
делать. Она позволяет вам делать поиск, вставку и удаление по ключу за среднему от единицы,
но у вас элементы не отсортированы. Вот в сет и мэп вы можете вставлять, удалять и искать по
ключу за от log n гарантированно, потому что это красно-черное дерево. Гарантированно за log n
вы можете искать. Но еще дополнительно сет и мэп они позволяют вам, они вам позволяют такие методы,
как например lower bound. Найти элемент первый не меньше, чем данный. Или upper bound. Найти
элемент первый больше, чем данный. Вот и вы можете, обходя мэп, ну или вы можете обходить сет и
будете получать элементы в порядке возрастания ключа. Вот с unordered map, с unordered set вы будете
получать их в роддомном порядке в каком-то, то есть у вас не отсортированные элементы и вы не можете
спросить там upper bound или lower bound, нет таких методов, потому что нет сортированный контейнер.
Вот. Ну вот тут есть, значит, большая таблица, в которой написано, что за сколько работает,
нет кажется не написано, что за сколько работает, очень жаль. А еще она не увеличивается, не
уменьшается. Ну в общем, есть большая таблица, а это у меня просто страница зависла, ладно,
хорошо. А нет, все-таки она уменьшается. Да, тут есть таблица, какие методы в каких контейнерах,
начиная с какой версии C++ добавлены. Вот это о чем таблица. Вот, ну еще где-то, наверное,
должна быть таблица за какое время, что работает. Вот, но давайте я вам просто скажу,
что это все очевидно и не буду это перечислять. Вот. Но я надеюсь, что вам правда и так это понятно,
что что умеет vector, что умеет deck, что умеет list, что умеет mapset, unordered map, unordered set. Это на
самом деле такие базовые знания о контейнерах. Если вы представляете, как устроены все эти
контейнеры изнутри, а вы уж точно будете представлять к концу года, то вы легко ответите на вопрос,
за сколько это работает. Вот. На самом деле вопрос, за сколько что работает в каком контейнере,
это супер популярный вопрос на собесах, что в яндекс, что в Google. Ну, там правда не спрашивают.
Нет. Ну вот, если вы будете проходить собесы в яндекс, то просто за сколько работает какой-нибудь
метод в контейнере, вас вот по-любому спросят. На каком-нибудь собеседовании. Ну, то есть это такие
базовые совершенно знания. Вот то, что я сейчас не говорю, это не какая-то там странная вещь,
которую никто не использует, непонятно зачем кто-то ее придумал. Нет, это супер базовые знания и типа
ну, просто скрининг. Не то что на собеседовании. Еще когда вы по телефону с вечером разговариваете,
она может вас спросить типа, а вот можно быстренько а симптотики в листе какие? Вот. И если вы
неправильно зовете, вас просто не допустят до собес. Ну, то есть это такие совсем базовые штуки.
Если вы претендуете на должности PPP разработчика, то вот это знать, это совсем база. Это так к сведению.
Вот. Но я думаю, что вам понятно, что связанный список умеет, а вектор не умеет и наоборот. Мы
сейчас с вами поговорим о том, как реализовать вектор. Вот, и видимо это то, на чем мы закончим
сегодня, потому что больше мы ничего не успеем. Следующий пункт нашей программы это будет реализация
вектора. Сейчас будет, да, сейчас мы увидим, насколько... Да, да, да, да, да. Вот, а, значит пункт 8.2 это
будет implementation of STD-вектор. Ну, обычно, когда люди говорят о контейнерах, то первым делом они,
конечно же, обсуждают вектор, и вот то, как устроен вектор, это вот самое первое, что обычно люди узнают
о контейнерах. Реализовать метод pushback в векторе, это, наверное, я не знаю, вот бывают вопросы. Вот
как одним вопросом проверить, насколько человек знает плюсы от уровня совсем новичка для уровня
сеньора. Вот реализовать pushback векторе, это такой вопрос. Мы с вами сейчас будем реализовывать pushback,
но мы его реализуем очень плохо, мы к этому вопросу вернемся еще три раза, и только лишь в конце
семестра мы реализуем его как следует. Я знаю ответ. А реализовать, она же реализована. Нет, нет. Реализовать pushback это,
короче, такая штука, которая вот прям реально можно проверить, насколько вы знаете плюсы,
прям вот до самых вот, до самых глубин. То, что вы в стринге писали, это детский лепет, вообще,
это детский сад совсем. Все становится интересно, потому что вектор шаблонный класс. Ну давайте
попробуем реализовать вектор. Класс вектор, ну я с большой буквы уж напишу, так и быть. Вектор у меня
есть что? Massive, size t, cz, ну я их так уж по привычке буду называть, size t, cap. Ну можно и так, давайте
сделаем... Значит, ну давайте что мы сделаем? Ну давайте сделаем это будет указатель на начало,
указатель на конец. Ну просто begin и end это название методов. Begin, знак подчеркивания,
end, нижние подчеркивания. Я не знаю, что мне будет больше нравится. Ладно, хорошо, пусть будет так.
IT звездочка, как бы нам это назвать-то? Alloc. Что Alloc? Какой Alloc? Мне нужно указатель на начало,
указатель на после последнего элемента и указатель на после выделенного элемента.
Я не знаю. Блин, это ужасно. Мне так не нравятся эти названия. Я просто привык писать в указатель
два числа. Блин, сейчас мы, сейчас будет очень-очень мерзко. Я не знаю, кто я. Ну давайте, да,
ну как бы я говорю, тут сейчас я может что-нибудь, ну сам новое для себя открою, пока буду реализовывать.
Ну давайте, давайте как назовем только limbovend. Нет, все, ладно, давайте так оставим. Короче,
у нас три указателя. Вот, и что эти указатели показывают? Ну они показывают, что такое size?
Что такое size? Size это end-begin. Вот, что такое capacity?
Нет, такого не можно. Нет, это в паблике уже. Вот эти методы, ну я, вот эти методы я сейчас
реализую, чтобы понять, ну чтобы был понятен смысл этих полей. Вот, что такое capacity? Оно тоже
accept. И оно возвращает bovend. Минус. Я обязательно установлю себе you complete me, чтобы подсказывать,
чтобы автодополнение было в следующем смене. Ну пока так живем. Я себе такое уже два года говорю,
поэтому в этот раз я точно справлюсь. А, мешает даже? Слишком легко работать становится. Нет,
ну правильно, если вы тренируетесь проходить собесы в яндекс или гугл, то надо вообще на доске
марки учиться писать, так что все правильно. ГДБ учиться не бажит. ГДБ учиться не бажит, вообще
правильно, все правильно. Так, ладно, давайте поймем, как, например, работает конструктор. Вот смотрите,
у меня конструктор должен быть. Вектор от числа и объект, да, по умолчанию пустой. Вот,
ну нет, это два разных конструктора, насколько я помню. А ну давайте проверим.
Сейчас, а почему мы передаем? Count все-таки не по умолчанию. Вектор без параметров это отдельный
конструктор, поэтому конструктор от числа у нас будет отдельно. Чего, почему? Почему мы здесь как-бы
рассчитываем на то, что деколтный конструктор есть? Потому что это требование. Нет, мы на это не
рассчитываем. А, если мы его нигде не используем, то все будет хорошо. Мы на это не рассчитываем,
да. Если нам передали value, это очень правильный вопрос, это отличный вопрос. Если мы передали
value, то конструктор не будет вызван. А если передали, то, если не передали value, то он будет вызван.
Но если его нет, то все. Так, список, надо инициализировать поля. Чем инициализировать поля?
Но сначала надо инициализировать begin. Чем инициализировать? Newt. Ну, видимо,
ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну
ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну,
ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну,
ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну,
ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну,
ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну, ну,
то есть там же есть такое правило что
указатель на int должен делиться на
а, типа, значение как-то
чё должен делиться?
указатель начальник нельзя же кастить допустим указатель на int
это правильное замечание но мы пока на это забиваем
на это мы пока забиваем мы значит пока выделяем вот так вот
у нас там как-то нечётное
мы не можем написать newt account
Потому что это значит, что у T не обязан присутствовать конструктор по умолчанию.
Если нас просят создать count штук value, то просто newT от count не скомпилируется.
Понимаете? Это просто не скомпилируется.
Поэтому нам нужно выделить сначала сырую память.
Дальше. End чем проинциализировать?
End надо проинциализировать begin'ом плюс count.
И этим же надо проинциализировать boof end.
Begin плюс count.
Заходим в тело.
Это все еще детский сад?
Это начальная школа.
Сейчас главное понять, почему я с reinterpret cast связался.
Почему она не подсветила?
Reinterpret.
Я не мог писать newT от count. Это самое главное, что здесь надо было понять.
Пронициализировал. Теперь что делать?
Теперь мне надо создать объекты T.
Я выделил память, и теперь мне надо по всем этим адресам создать объекты типа T от нужного value.
Ну вот без std.
Как мне написать свой fill?
Что надо написать?
В чем проблема std fill?
Я хочу не использовать std.
Я хочу написать сам.
T звездочка it равно begin.
T звездочка it равно begin.
It меньше end, видимо.
Ну, не равно end.
Есть какие-то мемы?
Есть.
Они, по-моему, без конструктора.
Да, да, да.
Сишные штуки просто да. Мне надо конструктор.
Незначение под указателем равно value.
Как классно. Так.
Хорошо. А равно value?
Да.
Отлично. Отлично. Да. Да.
Все правильно.
Здесь у нас есть превосходная возможность многократно отстрелить себе новую.
Да. Все так. Все правильно. Именно так.
Именно этого я и ждал.
Именно так и реализуют вектор люди, которые впервые пишут вектор.
Значит, что здесь происходит?
Здесь происходит разыменование указателя на T.
Таким образом получается ссылка на T.
А дальше вызывается оператор присваивания двух T.
Левый оператор T и правый оператор T.
Кто сказал, что он есть?
Нет. Оператор присваивания, допустим, есть.
Оператор присваивания даже, может быть, и есть.
Он должен быть.
Но, допустим, T это стринг.
Добро пожаловать. Delete по рандомному поинтеру.
Все. Р. Е.
Можно для тех, кто сейчас вообще ничего не понял?
Здесь вызван оператор присваивания двух стрингов.
Ну, допустим.
Что такое левый аргумент?
Непроинциализированная память.
У тебя лежит сырая память, которую ты реинтерпед касталул к T.
И вызвал оператор присваивать ее, как будто это полноценный стринг.
Но, минуточку, там на месте полей лежит мусор.
Объект ничем не проинциализирован еще.
Ему ничего нельзя присваивать.
У него не вызван конструктор ни разу.
Можно еще раз касталуть?
Нам надо каким-то образом вызвать конструктор?
Нужно вызвать конструктор объекта на данной памяти.
Мы не можем вызвать никакой метод этого объекта.
В том числе оператор присваивания.
Это все равно оператор присваивания.
Нужно вызвать конструктор.
Э... Чего?
Это как же?
Я хочу создать объект в другом месте, а потом принести память, которая создалась, на ту, которую мы имеем.
А как создать объект в другом месте?
Ну, просто написать...
Нет, так просто в случае со стрингом ты указать их будешь какую-нибудь.
Нет.
Я хочу просто сказать что-то по типу так.
Память, которая у нас есть, реинтерпед равно варь.
Что такое память, которая у нас есть?
Ты предлагаешь где-то отдельно создать Т, а потом мем CPI-нуть его по байтово в то место, в которое надо.
Да, да.
В случае стрингом ты копируешь указать.
Нормально.
Ты сначала вызываешь конструктор копирования, потом копируешь всю эту новую информацию.
Это выглядит как будто нормально.
Это будет, к сожалению, работать...
Это, к сожалению, будет работать не для всех типов, корректно.
Stack Overflow говорит, что можно New на данной памяти.
Какой ты молодец.
Ну, конечно, да.
Я знаю, что Stack Overflow правильно говорит.
Stack Overflow небось и в Pushback говорит, как реализовывать надо.
И вообще все проблемы решает.
Существует специальный синтаксис для того, чтобы вызвать конструктор по данному адресу.
Это правда.
Вот это мы сейчас должны заботить.
Он называется Placement New.
Вот это вот ни в коем случае нельзя делать.
Вот это вот очень серьезная ошибка.
Это вот...
Можно считать, что ради...
Собственно, ради этого я и начал вам показывать, как писать конструктор, в общем-то.
Потому что вот здесь вот...
Ну, просто первое, что приходит в голову написать, вот это.
И это совершенно неправильно.
Это просто фразу до свидания.
Вы не понимаете.
Здесь нам нужен новый синтаксис, потому что у нас до сих пор его не было.
Нам нужен...
Нам нужна особая форма роператора New.
Особая форма.
Пишется это так.
New в скобочках указатель, а дальше T от чего.
И это...
Специальный синтаксис, как вызвать конструктор по данному адресу.
Вот здесь его не нужно, да.
Потому что это не поле.
Вот.
Понятно?
Я вызываю...
Что такое...
Вот это называется PlacementNew.
Давайте я вам открою даже про него страницу на SIP Reference.
Это особая форма роператора New, которая не выделяет никакой памяти.
Она просто...
По данному...
Адресу...
Вызывает конструктор, создаёт объект.
New.
PlacementParams в скобочках.
NewType и initializer.
Ну вот это вот...
Вот так оно выглядит.
Значит New...
Сейчас мы пример посмотрим.
Ну вот.
New.
От адреса.
И дальше T.
Создаёт объект типа T.
Помещая его прямо по прелоцированному указателю.
А зачем писать там, что T звёздочка равно тогда?
Где T звёздочка равно?
Ну там T звёздочка равно, что T фотоядка равно New.
Ну просто нам.
Потому что оно возвращает...
Потому что это выражение возвращает указатель, как и раньше.
Но нам не нужно его возвращаемое значение, мы просто кладём его туда.
Нам этот указатель не нужно использовать.
Оно возвращает тот же указатель, который мы передаём.
Да.
Оператор New всегда возвращает указатель.
А что нам мешает просто скопировать объект и адрес намога скопированный объект поместить в...
Какой объект?
Куда скопировать?
Ну почему мы могли...
Мы хотим поместить его в Wayo.
Могли бы просто взять скопировать в Wayo.
Взять его адрес и поместить его в...
Что значит скопировать в...
Сдаём новый объект.
Что ты предлагаешь написать здесь?
Вместо этого.
Не знаю.
Ит равно адрес value равно value
Ит равно что?
Ит равно имперсант
Ит равно имперсант
В скобочках value равно value
Чего?
Чего?
Чего?
Может там типа нилу ты от value
или что-нибудь такое-то хочешь?
Я хочу копировать value, чтобы он вернул мне
копию value
И взять адрес копии
Стоп, он же копию потом удалит, потому что это временная
предмет
Ну
Это то, что уже подзагадили, там все равно
это не всегда будет работать, если ты даже тупо
сырую память
Да, если ты даже будешь тупо сырую память
копировать, это все равно работать не для всех типов
У типов могут быть сложные
ссылки на самого себя
Там указатель на указатель
на указатель на указатель
Там бывают типы, у которых
одно поле является
указателем на другое поле
Таким типом, например, является
STD String
Но я вам этого пока не говорил
Вот как раз
на STD String это не будет работать
Но это потом
В общем, нет, это не для всех типов будет работать
Я понимаю
Это тизер
на второй семестр, понимаешь, я вас должен заинтересовать
Чего? Какая конструкция?
Это триллер
Она берет
типа им это указатель
Она берет, просто вызывает конструктор данного
типа по данному адресу и возвращает
этот адрес, все
не выделяет память больше
Вопрос
У нас же чар выделенный
выравнивается абсолютно
Мы забиваем на выравнивание
пока забиваем
Ничего страшного не будет
Здесь ничего не сломается
Ничего не сломается, будет неудобно
Уже выровнено будет процессор лишней инструкции читать
Мы потом поговорим про выравнивание
Пока и без этого проблем хватает
Это мы уже
Сдавали
Все
Мы молодцы
Все сделано, что надо в конструкторе
Хорошо
А что если конструктор T кидает исключение?
Это проблема пользователя
Нет
Мы должны
корректно освободить память
в этом случае
Ну вот смотрите, пусть
конструктор T кинул исключение
Придется обернуть
Сейчас будем оборачивать
Конструктор T
кинул исключение
Пусть нам надо было создать 10 объектов T
Мы создали 5 и вот 6
Кинул исключение
Что произойдет в этой ситуации?
Если все написано как написано
То дилит никто не вызовет
И даже деструкторы старых объектов никто не вызовет
То есть будет создано 5 объектов
Память будет утеряна, утечка памяти
Те объекты созданы и все
А представьте, что эти объекты
Это какие-нибудь в свою очередь соединения по сети
Или что-нибудь подобное
Какие-нибудь ньютексы, открытые файлы
Они все так и будут открыты
И никто их не уничтожит, не удалит
Подожди
То есть нам придется хранить сколько объектов
Мы уже создали где-нибудь
Нам нужно
Чего?
Нет, нет, нет
Какой массив шерт ПТР
Чтобы в векторе хранились
Не сами T, а шерт ПТР на T
Нет
Нет
Ты в Олимпиадках хочешь ТЛ проходить?
Тогда не надо так делать
Я такого делать не буду
В Олимпиадках ты вектором пользуешься?
Да
Вот если бы вектор использовал шерт ПТР
На T, а не T-звездочку
Мы при лечении были ниже, потому что
Вектор в писах пишет
Я думаю, что
Пластмассовый мир бы победил
Раз ты бы победил, на C вы писали
Нет, никакой шерт ПТР
Просто потому, что была эта проблема
Мы решили, какой еще шерт ПТР
Мы сейчас реализуем вектор
Нет
Подождите, нам нужно хранить количество элементов
Которые мы уже создали
У нас здесь указатель, на котором мы сломались
Так мы знаем, на каком указателе мы сломались
Мы оборачиваем внутри форта
Да
А зачем нам вообще это?
Ну мы пишем T звездочка И
равно begin вот здесь
Вот здесь мы пишем вот так
Вот так
А теперь трай вокруг этого
Вот так мы оборачиваем?
Конечно
И ловим
А здесь что мы делаем?
А теперь мы проходим с
Begin до end
И убиваем
T звездочка
Как его назвать?
Подожди
Подожди, подожди
Сейчас я допишу
T звездочка
JT будет у меня
Но я не знаю, как это по-другому назвать
Можно его назвать
The It как Del It
Хорошо, T звездочка
Del It
равно
Begin
Ладно
Del It
Не равно It
Потому что по указателю It мы уже не создали
Мы не смогли создать T
Плюс-плюс Del It
И что мы здесь делаем?
Как так получилось, что мы создали первые несколько объектов
По какому-то value
А на следующем мы упали
И не смогли
Например, в конструкторе
1 десятый выбрасывается
Например, создание объекта T
И на какой-то момент память закончилась
Окей, ладно
Это, кстати, момент
У нас же она закончилась
Подожди, подожди
Пожалуйста
Все сейчас
Будет нормально
Сейчас все сделаем
А почему мы не интервьюруемся просто с конца начала?
Потому что условия проверки будут неудобно писать
Давайте минус-минус на 1
Все, короче, не хочу
Я обсуждать это
Вот здесь вот
Что?
Что?
Что?
Еще раз
Вот так?
Это Убе
Вы что?
Вы вызываете delete по указателю
По которому не было new
А мы можем стрелочкой просто деструктов вызвать?
Можем
И именно так и надо сделать
Вот здесь первая в жизни ситуация
Когда нам нужно явно вызывать деструктор
В чем проблема?
Проблема чего?
Да потому что delete освобождает память
По данному указателю
А по данному указателю не было никакой памяти выделено
Там был конструктор только вызван
А память освободить нужно вот здесь
А он же его не полностью выделил
Нужно полностью освободить
Память выделена целиком
А вот деструкторы нужно вызвать не для всех элементов
А delete квадратной скобочки что?
Видимо reinterpret cast
Reinterpret cast обратно к чару
Потому что он же T
Ну это пока да
Это четвертый класс
Не ну ладно
Так
Begin
Не ну ладно мы уже в среднюю школу переходим
А смотрите
Какой вопрос
Нам главное сейчас на второго семестра научиться успеть
В этот средний школу
А если исключение
Вот здесь вылетит что делать?
Плакать
Ничего
Не надо делать
Если исключение вылетает в этот момент
Это std battlelog
То оно само и полетит дальше
Ничего делать не надо
Нам нужно обработать только вот
Исключение здесь
Я забыл еще очень важную вещь написать
Вот здесь надо throw написать
Нет
Cache многоточие
Вот здесь
Вот
Это я реализовал конструктор Vector
Ну там
С поправкой на то что на самом деле
В общем еще не совсем так должно быть
Что мы делаем если у нас в диструкторе произошел
Вот что мы делаем если в диструкторе
Произошло исключение ничего мы не делаем
Мы считаем что диструктор не кидает
В исключение
Диструкторы
No except по стандарту
Если кто-то кидает исключение в диструкторе
То все риски он берет на себя
Точно так же мы считаем что оператор delete
Не кидает исключение
Диструктор и оператор delete не кидает исключение
Мы работаем в этом предположении
Иначе все бессмысленно
Она не нужно сразу сделать
Какое-то конкретное
Мы кинули то что
Поймали
Чтобы это не было
Окей ну давайте теперь pushback реализуем
Наконец
Ну чтобы реализовать pushback
Нам надо реализовать
Reserve
Ну смотрите
Ну давайте реализуем pushback
Pushback
const t ampersand value
Вот как нужно
Вот pushback самое интересное в векторе
Что должен делать pushback
Проверять что у нас не кончилось паре
Вот если
Size равно capacity
То есть если end равно boof
end
То что-то сделать
Давайте сделаем отдельную функцию repeat
Какую функцию?
Rebuild
Да не rebuild, она называется reserve
Это стандартный метод
Reserve на два раза больше
Мы же не используем стандарты
Так мы реализуем ее сейчас
Мы пишем вектор
Сейчас мы реализуем этот метод
2 умножить на capacity
2 умножить на
boof end
да boof end
Давайте плюс один сделаем
Плюс один сделаем пожалуйста
Ну давайте заefаем здесь
Что делать
Нет, мы не будем делать плюс один
Capacity увеличится в два раза
Нет, мы не будем сейчас этим заниматься
Мы reinterpret castом должны пользоваться
Но мы сейчас не будем этим пользоваться
Нам нужно понять как это работает
А не красивый код написать
Ну
Ну давайте здесь я напишу
максимум
Ну максимум я все-таки использую
стандартный из вот этого
Ну чтобы если
Capacity 0, то
типа у нас
понятно
было один
Давайте реализуем резерв
Что делает резерв
Нет, это публичный метод
резерв от
числа
Ну если мы
понимаем что наша текущая
Capacity уже хватает, то мы просто
ничего не делаем
Если
boof end
минус begin
Ну хорошо
Capacity
больше или равно чем new cap
то просто
ничего не делаем
Ну и здесь тогда можно сразу Capacity было вызвать
А хорошо Capacity не хватает
Что делаем
Перевыделяем
t звездочка
new
r
равно
Ну давайте что
reinterpret cast
cast t звездочки
от new char
размера new cap
умножить на size of t
А мы можем вызвать конструктор
от нас
от вектора
размера 2 на
new r и заполнено чем-нибудь
Нет
Мы ничем не должны его заполнять
Мы не должны создавать объектов
У t может вообще не быть
конструктор по умолчанию
А чем тогда ты его заполнишь
если там нет конструктора по умолчанию
Ты что, рандомные параметры конструктору
передашь?
Я рандомного значения причем
Если был у нас полный пустой массив
я бы передал просто первый элемент
Какой первый элемент?
Первый элемент массив
А я могу передать ему value
который я передаю в pushback
и им заполнять
Ладно, это не сработает
Выделили новую память
Конструктора копирования может
тоже не быть на самом деле
Но это отдельная песня
Ну, тогда
должен быть muv
muv конструктор будет, да, но это
отдельная история
Мы же пока что это не рассматриваем
Пока не рассматриваем, да, но вы просто видите
вот конструктор копировать должен быть
не обязательно
Сейчас пока пишем то, что работает
в любом случае
Ну вот, хорошо
Выделили новую память, дальше что?
А дальше, друзья мои, надо
Не торопиться, у нас же мог быть бедолог
Бедолог мог произойти
Если у нас бедолог, мы просто вылетаем
с бедологом и все
Ничего не делаем
Бедологи мы не обрабатываем
Бедолог мы с ним так и вылетим
Мы пока еще ничего не поменяли
в нашем векторе
Вот, теперь
перекладываем старые объекты
на новое место
Ну
мне удобнее
так делать, потому что
мне нужно счетчиками
Что мы делаем?
Мы считаем, что конструктор
копирования есть
потому что
если его нет, то
должен быть хотя бы мув конструктор
но
короче, должен быть
мув конструктор
но
короче, должен быть либо
конструктор копирования, либо мув конструктор
про мув конструктор мы пока не знаем
поэтому мы считаем, что есть конструктор копирования
Мы здесь не можем сделать Memcpi
по битовой
Это не будет работать для тех типов, у которых в полях есть ссылки
на себя уже
Вот
Поэтому мы должны
полноценно копировать
Короче говоря, мы берем и полноценно копируем
Мы говорим
new
plus
i, t
от
звездочка
begin
но я могу сказать так
begin и t
вот так
Это оборачиваем в StrikePatch
Точно
Это я скопировал все объекты
и конечно же это надо обернуть в StrikePatch
Вот
Трай
вот это все
и если
catch
что угодно
то
тут можно просто скопировать этот кусок
Я
не
соблюдать code style, когда пишу учебные примеры. Если вы хотите придираться к
code style, то вот здесь нужно было придираться к именам функций, но вы же
этого не делали, я здесь однобуквенные переменные заводил. Если вы хотите, чтобы я
везде придумывал, соблюдал code style, то у нас темп будет в два раза медленнее.
Кто не изменится? Он нулевой? Так, что я здесь делаю? Ну я просто говорю size t, другой
счетчик. Допустим g равно нулю, g неравно и
плюс плюс g, ну можно же меньше. Вот и что я говорю? Я говорю new r плюс i, new r плюс i, плюс g.
Стрелочка, деструктор t. Потом я делаю delete or interpret cast вот это, new r так и throw.
Правильно? Вот, а теперь, если мне все это удалось сделать, то что я делаю дальше?
Мне надо сказать, что begin равно new r, n равно new r плюс size, видимо.
Не-не-не-не-не-не-не-не-не-не. Чего? Нет. Что нет? Потому что size у нас превращается к разнице между end и begin.
Нам надо раньше запомнить. Вот поэтому я и не хотел три указателя, хотел указатель два числа. Ну давайте напишем.
Ну перед begin просто size t и size равно size. Стоп, нам еще нужно 2 раз begin сохранить,
потому что иначе у нас утечка. Мы сейчас удалим begin. Да, если мы begin записываем дела, как мы его удалим.
А, ну надо сначала его удалить, значит. А потом обновить вот это.
Сейчас, стоп. Делить риндер при откасте. Да, риндер при откасте, конечно.
Я не буду ничего делать, я просто напишу update end и boot end. Ну и не хочу.
Короче, понятно. Тут больше исключений никто не бросает. Вот этот delete исключений не бросает.
Ну, вот мы сделали reserve, а теперь что? А теперь надо...
Нам нужно добавить само вот это value или хоть же reserve?
Само. Это ссылка, как мы само добавить, я не понимаю.
Но в плане мы добавляем ровно тот элемент, который нам передают или некий его кофе.
Что значит ровно тот элемент, который нам передают? Это как?
Ну, в плане, если мы изменяем тот элемент, который нам передали, то он внутри...
Как ты это себе представляешь?
Но если мы сейчас напишем равно value, то кажется так и сработает.
Что, напишем равно value? Ну pushback value.
Что? Что ты предлагаешь написать сейчас?
Тебе нужно положить элемент в вектор. Как ты собираешься положить ссылку вместо элемента?
Я не понимаю, что ты предлагаешь вообще.
Я тоже.
Но нам нужно сделать опять new по адресу end t от value.
И инкрементировать end.
Ну вот проблема. Это тоже может бросить исключение.
А если это бросит исключение, то нам надо не только его вернуть на место,
нам надо все обратно вернуть, как было.
Ну, короче, pushback в векторе, на самом деле, через резерв выражать не очень хорошая идея,
потому что после того, как мы положили новый элемент в вектор,
после того, как мы сделали резерв, мы делаем вот это, и у нас может это бросить исключение,
и тогда нам надо все вернуть назад.
Да, мы должны все вернуть назад.
Ну, давайте я не буду это уже писать, это уже понятно, это вы уже сами можете писать.
Ну, на данный момент у нас есть просто стандарты.
Мы не должны, если мы не можем, здесь просто делать try в кейч и shrink to fit в кейч.
Shrink to fit – само кидать исключение.
Ну да.
Ну, если в кейче сделаешь shrink to fit, то ты будешь перекладывать обратно.
Тебе надо хранить обе копии до того, как ты все положил, и только потом уничтожать ту.
То есть, мы на самом деле должны сделать конструктор копирования
и создать резервы копий нашего вектора?
Ну, можно и так сказать, наверное.
Но только надо аккуратно обработать exception safety там везде.
Вот, ну ладно, значит, это был вектор.
Хорошо.
Теперь вот что.
Как мы уже говорили, как кто-то из вас говорил,
вектор bool, он отличается от обычного вектора, он по-другому устроен.
Нам отдельно давайте надо обсудить, как устроен вектор bool.
Вот смотрите, если у нас шаблонная, если у нас специализация,
а вот здесь template typeNameT, template, точнее, без параметров,
вектор bool, он реализован иначе.
Вектор bool, он совсем по-другому реализован, а почему?
Потому что там на самом деле хранится массив не bool, а char.
Давайте я хотя бы здесь все-таки буду использовать два числа.
Вот я все-таки здесь буду использовать числа.
Вы уж меня извините, но так просто проще писать.
Да, нам надо к этому вектору научиться обращаться квадратными скобочками
и записывать элемент по индексу.
Вот, ну а как это работает?
Если мы храним упакованные по 8 boolevские значения в 1 byte,
то что происходит, когда мы обращаемся квадратными скобочками
и пытаемся прислоить?
Ну вот, у вектора bool мне интересно обсудить,
как работает оператор в квадратной скобочке.
Что возвращает он?
Оператор в квадратной скобочке.
bool или ссылка на bool?
Нет, какая ссылка на bool?
У нас вообще нет bool.
А что тогда он возвращать должен?
bool?
Что?
bool просто?
Так ему нельзя присваивать, это же rvelo.
Ссылка на bool проблема, потому что где сам bool-то?
Нет, мы же хотим писать bool x равно чему уже там.
Откротительно.
Нет, Вася еще вроде сказал нормальную идею.
Какую идею?
Отдельный тип, в который я приписал их себе, будет меняться по нужной гидр.
Ну давайте.
Значит, на самом деле внутри класса vector bool нам нужен еще
приватный тип, который называется bool-reference.
Вот.
А как он будет устроен?
Что в нем будет?
Ну видимо index или нет?
Значит, это индекс чанка.
Ну вот.
Чанк.
Ну это номер вот этой корзиночки, в которой по 8.
И внутри нее еще номер самого этого.
Номер бита.
Ну я тут сделаю, не знаю, uint8t мне хватит для этого, хотя
можно было бы и меньше.
Ну вот.
И что эта структура будет уметь?
Ну у нее должно быть...
Ну видимо, это прям нот.
А все-таки что будет возвращать оператор квадратной скорости?
А все-таки что будет возвращать оператор квадратной скобочки?
У тебя ссылка от bool-reference.
Bool-reference или ссылку на bool-reference?
Ссылку на bool-reference.
Он будет возвращать просто bool-reference.
Да это очень понятно.
Это не так уж понятно.
А что будет делать bool-reference?
Иначе она будет просто снимать статики элементов, которые
издали в центре вот таких операторов.
А что будет делать оператор присваивания bool-reference?
А присваивать можно будет ей bool.
Присваивать?
Да.
Значит bool-reference будет возвращать
новый bool-reference,
а присваивание bool-reference
ей можно bool присваивать.
Вот.
И это будет изменение
массива по вот тому индексу.
То есть вот мы берем array
по индексу chunk
и
и
тут if кажется придется.
И правильно понимаешь, что мы таким еще неявное приведение
по bool-reference?
Да.
Значит если это true,
то значит мне надо что сделать?
Array по индексу chunk
типа сделать вот так, да?
Нет.
Ну да.
Вот так
один
сдвинутый влево на bit.
Ну присваивание они имеют самый низкий приоритет
кроме throw и запятой.
Вот все бинарные операторы выше присваивания.
Что?
А как мы на array присваиваемся?
Да, кстати, отличный вопрос.
А как мы на array присваиваемся?
А нам нужно, знаете что, нам нужно указатель
на char.
Нам здесь надо не число указатель хранить.
Ну потому что
иначе
да, действительно, как мы будем ссылаться.
Да, нам придется
вот так делать.
А если мы получили ссылку, потом
сделали resize
вектора, а потом по этой ссылке
хотим поменять значение?
Убе?
В смысле у нас
уже невалидная...
Это и в обычном векторе, так?
Ну ладно.
У меня другой вопрос.
Я сам напишу
world x равно наш
оператор равно, а потом
x равно 1 world.
Так.
Я реализовал оператор равно.
Есть претензии к реализации?
Нормально?
Есть, есть, есть.
Что?
Надо в
векторе
надо в
и равно, вроде бы, отрицание
куда пришлится.
Еще надо return звездочка вис.
А, да, нужно
отрицание.
Для того, чтобы так, что ли?
Мне кажется, что это будет плохо,
потому что ты должен для каждого элемента
сонить массив указателей
на указатель или на него.
Да, так похоже.
Хорошо.
Я в операторе квадратной скобочки
возвращаю
bool reference
У меня оператор квадратной скобочки
опять ничего не принимает. Классный оператор.
Я возвращаю bool
reference от каких параметров?
Индекс
сдвинутый на 3
Вот этот массив плюс
индекс, деленный на 8?
Нет, сдвинутый на 3, деление супер долго.
Хорошо.
А, сдвинутый вправо
на 3, видимо.
И кажется, это в скобочки надо сделать.
Да компилятор оптимизирует деление на 8,
господи.
И чего? Индекс
по модулю
8.
Или здесь тоже надо манипуляциями
делать?
Н7, да. Н7.
Хорошо.
Ну, вообще, чтобы было понятнее, что здесь
за магией происходит, можно 0,
B3 единички.
Кажется, в такой ситуации понятнее.
Нормально.
Нормально.
Нормально.
Посмотрите, пожалуйста,
на этот замечательный оператор квадратной
скобочки и осознайте,
что мы с вами
только что написали. Мы с вами
возвращаем
копию,
но ей можно присваивать.
То есть, когда мы пользуемся таким
вектором,
там V,
ну, не знаю, от 5, но у меня нет
у конструктора.
Я говорю, V3 равно там true.
Вот это выражение,
это будет
копия, а стало быть R-value.
Это будет временное значение.
Мы с вами
получили пример R-value,
которого можно присваивать.
Причем не искусственный,
а настоящий.
Это действительно так реализовано.
Вектор Boolean просто возвращает
вам временную копию
некоторого типа,
который просто так устроен,
что присваивание ему меняет
сам вектор.
Но это R-value.
То есть, присваивание мы делаем
к R-value.
Я вам говорил, что
то, чему нельзя присваивать,
это неправильное определение и ни в какую
сторону. Вот мы с вами до этого знали примеры
R-value, которым нельзя присваивать.
А теперь мы знаем примеры R-value, которому можно,
причем не искусственный пример, а настоящий.
А если мы напишем CoolDix
равно V3?
Вот. Теперь нам нужен еще
оператор кастов bool, потому что мы хотим,
чтобы эта штука вела себя как bool.
Но мы уже не сможем
присваивать.
Ну, конечно, не сможем.
А bool-impercent мы не сможем
сделать.
Пронициализировать ссылку на bool
вот этим мы не сможем.
Но просто bool
пронициализировать этим мы сможем.
Что мы сделаем? Мы скажем
return.
Что там?
Звездочка chunk
и
ну вот
так кажется.
Нет.
Еще сдвинуть на бит назад.
Почему назад?
Ещё сдвинуть на бит вправо.
Зачем?
Оно кастанется
в bool.
А равенство с нулём и останется в bool.
Ну да, но оно сделается каст bool,
поэтому нормально будет.
Ну, в этом случае да, но
в каких-то других байках.
Ну да.
Так, ну вот.
Вот мы и поняли, как устроен вектор bool.
Ну, по сути
мы поняли, как устроен вектор, на самом-то деле.
Вот все основные моменты
мы осветили.
Только на уровне четвёртого класса?
Ну, на уровне пятого, средней школы, да.
Ну, кстати, не все.
У нас есть проблемы, Дмитрий Юрьевич.
Какие?
У нас, раз мы удаляем по ретерпреткассу
тот указатель,
то деструкторы от того, что было...
А!
Слушайте, конечно!
Конечно! Что же мы этого не сделали?
Здесь нужно ещё деструкторы вызвать.
Здесь нужно
вызвать деструкторы, но
тут на самом деле нужно вот это вот
сделать.
Прежде чем удалять старый массив,
конечно же, мы должны вызвать ещё деструкторы.
Это...
Это очень большой косяк, да.
Что я так не сделал.
Delete только не равно
end.
Делить не равно end, да.
Вот, мы вызвали деструкторы
по старому массиву.
Освободили старый массив, обновили
Begin and Buffet, и после этого
вот.
Здесь ещё
не учтено выравнивание, здесь
не учтена move-семантика, здесь не учтены
аллокаторы, здесь не учтено, что для некоторых
типов всё это можно делать эффективнее, здесь
не учтены проблемы с исключением при move-семантике.
Но это всё мы обсудим попозже.
Вот.
Такие дела.
Но мы в целом реализовали
вектор. Давайте последнее, что я скажу
по поводу вектор.
Это...
Про инвалидацию указателей
из ссылок. Вот вы знаете, что
вот вы этот вопрос уже
задавали сегодня. Если я
беру вектор.
std-вектор.
Стандартный вектор на сей раз.
int, не знаю, v от 10.
И говорю, int
& x равно v
5.
После чего говорю, v.pushback
что угодно.
1.
Вы понимаете,
что обращение к x после этого, это
ub.
Вот это очень важный
момент. Он
прям такой ключевой.
На самом деле в этом...
на это бывает, люди делают ошибки
прям на практике.
Если вы
плохо понимаете, как устроен вектор,
или вы не задумывались
никогда об этом, то у вас даже сейчас
может возникнуть заблуждение.
Вы будете думать, что ну, что такого, я завел
ссылку или указатель на элемент вектора,
потом поменял вектор
и обратился по этой ссылке указателя.
Нет, все. После того, как вы сделали pushback
над вектором, или после того, как вы сделали
insert над вектором, причем
над любым вектором, неважно, это вектор bool
или вектор int, или вектор чего угодно.
Обращение по старым указателям и ссылкам
к элементам вектора, это UB.
Это называется инвалидация
указателей ссылок.
Еще бывает, когда, типа, фориком бежишь,
и там внутри где-то pushback,
то почему бежишь?
Да, вот это очень опасное
использование вектора.
Ну,
вектор очень
небезопасен относительно
устойчивости
инвалидации итераторов
и указателей ссылок. Если вы
вектор модифицируете,
то когда вы потом обращаетесь по этим
по старым указательным ссылкам, вы уплочете UB.
Вот,
дек таким свойством не обладает, кстати.
Вот, дек,
не обладает
таким свойством.
Если вы возьмете
стд дек
и сделаете все то же самое,
то это нормально, это корректно.
Потому что
дек так
решил комитет мастаннортизации. Почему?
Потому что дек
ну, именно поэтому, что
дек обязан так делать. А как он так устроен?
А вот это отличный вопрос.
Только у вектора есть такая проблема,
у дека такой проблемы нет.
И у листа нет такой проблемы,
и у сета нет такой проблемы.
Наоборот, есть такая проблема,
у сета
да,
что нельзя, так как нельзя делать?
Короче, вы называете проблемой то,
что вы называете что?
Проблема
это инвалидация.
У сета нет инвалидации.
И у листа нет инвалидации.
У сета
и у мэпа ничего не инвалидируется
никогда.
Если ты заводишь ссылку
на элемент сета, а потом добавляешь
кучу всего в сет,
то ссылка валидная остается.
Да.
И указатели ссылки
остаются валидными, если ты в сет
наклал кучу всего,
а ссылка твоя старая.
Сет это красно-черное дерево.
В сете, чтобы вы туда не клали,
элементы никуда не перекладываются.
Они лежат в памяти по старым адресам.
Происходят лишь повороты
в красно-черном дереве, но повороты в
красно-черном дереве не влияют
на расположение этого элемента
непосредственно в памяти.
Там итераторы ломаются.
И итераторы в сете не ломаются.
Там точно что-то ломалось?
Нет, не ломаются в сете ни итераторы,
ни указатели, ни ссылки.
Тогда делаешь FORQINS INSET,
а потом внутри инсертишь элементы.
Это же пред?
Это уже другое,
потому что ты инкрементируешь итератор,
потому что FORQINS расшифровывается в то,
что ты FORAuto инкрементируешь итератор.
Но по мере того, как ты
поменял сет, у тебя могло
измениться структура дерева,
и инкрементация этого итератора приведет тебя
куда-то в другое место, а не туда.
То есть ты не обойдешь весь сет.
Ты не обойдешь весь сет, но ты нормально дойдешь
и не сломаешься нигде.
Нет, ты можешь зациклиться, если ты каждый раз
будешь вставлять сразу после себя.
Если ты делаешь так, то да,
но это не инвалидация итераторов,
не инвалидация указателей ссылок.
Ты будешь обращаться всегда к валидным элементам.
Вот в unordered set уже похитрее.
В unordered set инераторы инвалидируются.
Но это разговор уже на потом.
Короче, в векторе все инвалидируется,
а в деке нет.
Вот, и вам нужно будет реализовать дек.
А здесь сказать наоборот.
В векторе инвалидируются все.
И итераторы, и указатели, и ссылки.
А в деке нет.
В деке инвалидируются
только итераторы,
но не указатели и ссылки.
Вот так можно с деком,
с вектором нельзя.
Я сказал, что дек не инвалидируется.
Что такое инвалидируется?
Это значит, что
инвалидируется, значит, становится не валидным.
Значит, нельзя так делать.
Портится.
В деке не портится,
а в векторе портится.
Вам нужно будет реализовать дек,
в котором есть,
во-первых, безопасность относительно исключений,
во-вторых,
есть итераторы,
в-третьих, корректно обрабатываются
вот эти ситуации, когда у вас у Т
нет конструктора по умолчанию,
и когда конструктор кидает исключения,
когда хочет.
И в-четвертых,
чтобы эти итераторы,
точнее, чтобы указатели и ссылки не инвалидировались,
когда вы в дек что-то кладете.
То есть нам на уровне средней школы нужно выписаться?
Да, вам нужно на уровне средней школы
написать дек.
Вопросики.
Ну все, на сегодня.
Видимо, это последнее, что я вам рассказал в этом семестре.
