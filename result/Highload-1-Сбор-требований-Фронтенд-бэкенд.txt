Идогон, напоминаю ситуацию, к вам приходит, вы и архитектор,
системный архитектор, к вам приходит, вы ставите
задачу, будете ставить задачу программистам, объяснять
им, что нужно делать, крупными мазками придумывать, как
реализовать задачу, которую вам принес эффективный
или не очень менеджер.
Итак, менеджер хочет социальную сеть, спрашивайте.
Окей, важнейший, самый главный вопрос, функциональные
требования.
Что она должна уметь, как она должна реагировать,
какие функции должны быть и так далее, чем больше
здесь информации, тем лучше, спрашивайте, что видит
пользователь.
Самый простой вопрос.
Ничего не ошиблись.
Вот он зашел на страницу, что он видит?
Он видит, не знаю, логотип, понятно, аватар, пользователи,
список того-то, список там, я не знаю, селений, список
событий в каком-то городе, если это туристическо-социальная
сеть.
Допустим, я вам отвечаю, ну давайте так, в социальной
туристической сети у нас будет следующее, у нас будут
пользователи, пользователь может залогиниться, у него
есть анкетка, фотография, вот, и пользователи, бывает
двух видов, он может быть туристом, а может быть
гидом.
Если он гид, то он привязан к какому-то локальному месту
и он про это локальное место может писать, например,
статьи.
Ну, собственно говоря, все.
Так, ответил на вопрос, что должна уметь в социальной
сети.
Да?
Давай.
Уточняй.
Ну, все остальное неважно, чувак, да.
Вот я перечислил, больше ничего не надо.
Чего?
Я эффективный менеджер, какие паттерны доступа
дома?
Не скажи, какие паттерны доступа дома.
Каким данным?
Мне не надо данные, ты мне, пожалуйста, сделай.
Короче, у меня есть пользователи, пользователи, фотографии
и статьи.
Нет, почему?
Каждый может, нет, гид может постить и статьи, и фотографии,
а пользователь вообще ничего не может.
Окей, ну это ты совсем уже уходишь в другую область.
Это вторая часть, то есть первая функциональное
требование.
Вы ничего не знаете про то, что вы собираетесь
разрабатывать сейчас еще, вот я вам намекаю.
Ты говоришь про нефункциональные требования.
Да, то есть еще раз, какая нагрузка, какая, что там,
что еще?
Ну подожди, ну давай так, это все разные вещи.
Да, ну да, то есть смотрите, есть гид, он привязан к
какому-то месту.
То есть гид постит статьи, статья красивая, с текстом,
с картинками, еще что-то.
Да, да, да, за объекты только картинки в текст.
Про что вы начали спрашивать?
Вы начали спрашивать про данные, окей, я согласен.
Второй блок, уловили, вам нужно понять все типы
данных, которые есть в системе, и как они друг
с другом связаны.
Что бы быть не очевидно для говорящего?
Я вам сказал, например, о том, что есть пользователи,
есть гиды, они постят статьи, привязанные к месту.
Вот здесь сколько типов данных?
Пользователь, статья, фотография, гид, мест, и так далее.
Это связь, и связь между ними.
То есть у тебя есть данные и все типы связей.
Не факт, что ты это все будешь в базе хранять.
Ты сейчас на уровень некоторых абстракций просто-напросто
строишь сущности и связываешь их друг с другом, а как-то
потом ляжет куда?
В базу, в базульку или еще куда-нибудь, это же потом
посмотрим.
Мы пока не знаем.
Итак, функциональные требования.
Продолжайте меня расспрашивать.
Данные и не функциональные требования.
Все требования к скорости, к скорости ответа и все
тому подобное.
Деградация сюда же, да.
Да-да-да.
То есть вы не просто спрашиваете про то, что важно, что неважно.
Вот докрути.
Что можно потерять, что нельзя потерять.
Что мы должны показать в любом случае, что не должны
показать.
Что можно не показать, например.
Если можно не показать, то сколько?
Что самое важное из нефункциональных требований?
Какие минуты простое?
Это разное очень требование.
Например, бывают банковские системы, где минута простоя
стоит миллион долларов.
А бывает социальная сеть, где если я не смогу посмотреть
фотографии Васи Пупкина конкретного, ну и фиг бы
с ним.
Процент оптайма и важности тех или иных данных.
То есть насколько ты должен.
Деградация в национала.
Деградация в национала, чем ты можешь пожертвовать?
Например, 2004 год.
Я в Браммлере работаю, у нас происходит, или какой
там год, когда у нас теракт был на Дубровке.
Короче, в Москве серия терактов.
Вот, один из терактов.
И у нас посещаемость на сайт новостей взлетает
просто колоссально.
Мы не справляемся.
Она вырастает в 20 раз за час.
Ну понятно, все ломанулись смотреть.
Новости телевидения не справляются с потоком.
Чем мы сделали?
Мы просто увеличили время кэширования.
То есть если раньше главная страничка сайта обновлялась
раз в минуту, теперь она обновлялась раз в 20 минут.
Пользователь не заметил ничего.
Ну сайт работает, новости обновляются раз в 20 минут.
Это не заметно.
А мы выдержали нагрузку.
Это называется пример деградации функционала, когда вы намеренно
заранее проектируете, от чего вы откажетесь в случае,
если что-то пойдет не так.
Какого-то, не знаю, маленькой функции, посмотрите на страницу
Яндекса.
Если, ну это конечно не заметить сейчас, если у Яндекса что-то
не работает, вот главная страница Яндекса она собирается
из различных блоков.
Блок поисковой строки, блок новостей, блок погоды,
кусочек почты, еще что-то, еще что-то.
Каждый из этих блоков выдается разными кусками Яндекса.
За каждым из блоков, там, я не знаю, кластеры из тысяч
серверов, которые его готовят, выдают.
Ну не только вам, а вообще всем.
Если погода в Яндексе сломается, главная страница перестанет
работать?
Нет.
Просто там вместо погоды будет ничего.
Там даже не будет никакого сообщения в ошибке, вы
ничего не заметите.
Просто погода не вставится.
Вот это тоже деградация функционала, то есть такое
плавное снижение функциональности.
От чего можно отказаться, от чего нет?
Она понимаешь, она не сломается целиком полностью.
Если она сломается, то скорее всего тебе выдадут закешированные
результаты.
Не знаю, результаты, которые устарели час назад.
Они вряд ли помнят все поисковые запросы, но они помнят самые
часто повторяемые поисковые запросы.
Поисковый, ну хорошо, поисковый индекс, как правило, состоит
из, то есть как вы думаете, поисковый индекс, что это
А?
Как она хранится?
Надеюсь, когда это… Опять же, если на сегодня байке,
2007 год, Павел Дуров выступает у нас на конференции, в первый
раз показался, у него спрашивают, 2009, в ВКонтакте уже растет
бешено, огромное количество пользователей.
Они спрашивают, как вы храните фотографии, технический
вопрос.
Люди интересуются.
Ну блин, такое море фотографий.
Как их хранить нужно, распределять по серверам, еще что-то.
Он так смотрит на чувака и говорит, на дисках.
Короче, к чему я это рассказал?
За что я зацепился?
Про индекс.
Индекс хранится не на одном сервере.
Индекс хранится на тысячах, если не десятках тысяч серверов,
разделенные на кусочки.
Поисковая система в целом не сломается, может сломаться
какой-то конкретный кусочек.
То есть ты в результатах поиска у тебя не будет, например,
одной десятитысячной части.
Ты об этом никогда не узнаешь.
Индекс сломаться, в смысле поиск сломаться в индексе
почти не может.
Это там какая-то катастрофа.
Когда вы ищете что-то в Яндексе, поиск происходит одновременно
по всей этой сети.
То есть эта машина ищет великий Путин у себя.
Эта машина ищет великий Путин у себя.
Великий Путин скорее всего закэшировано.
Какой-нибудь у меня не знаю.
Великий Навальный просто ищет старательно.
Каждый из них выдает свой кусочек результата, они
собираются выше, потом еще выше, еще выше, и ты видишь
уже результат.
Короче, если кто-то что-то только наверху сломается,
тогда вы можете заметить, что Яндекс не работает.
Но это очень редко.
Вот если что-нибудь такое сломается, тема авторизации
и так далее.
Лады, но это каждый раз такая головная боль на всех.
Так, понеслась.
Значит, функциональные требования.
Что видят пользователи на каждой странице.
Ну давайте про социальную сетку про нашу.
Что можно подойти к этому вопросу, что может сделать
пользователь.
Каждый из пользователей.
Но это не совсем ваша работа.
Давайте пока не будем.
Нет, не может.
Да, он может подписываться на гидов.
Нет, давайте он может подписываться даже не на гидов,
он может подписываться на места.
Ну типа я хочу посмотреть.
Нет, давайте на гидов.
Он подписывается на гидов, соответственно у него есть
лента из его, из статьи гида.
А ты заходишь тогда, ну можно зайти на страничку мест.
Ну есть место, есть гид, да.
Гид публикует статьи, привязанные к месту.
Какую-то нужно выбрать логику.
Это не ваша работа в прямом смысле.
То есть вам системный аналитик по-хорошему,
аналитик должен принести пачку технического задания.
Но вам для того, чтобы понять, нужно какая-то логика.
Ну допустим давайте пойдем по страницам.
Можно пойти по объектам.
Или по пользователям, по типам пользователей.
Пользователь – гид.
Вот он что может сделать на сайте.
Раз, два, три, четыре, пять.
Пользователь – простой путешественник.
Что он может сделать на сайте?
Раз, два, три, четыре, пять.
Или по страницам.
Страничка – место.
Что там отображается?
Раз, два, три, четыре, пять.
И дальше у вас складывается какая-то некая логика.
Страничка пользователя, его личная страничка.
Что он там видит?
Страничка его фронтлента.
Окей, пора спрашивали.
Все вопросы, все поняли.
Дальше.
Про данные.
Что будете спрашивать?
Такого у нас пять клипов данных.
Место, статья, фотка, пользователь, гид.
Не, не, не.
Как быстро отклик получать – это скорее функциональное требование.
Как быстро страница у тебя показывается.
Как быстро сервер отвечает.
Вот это не функциональное требование.
Функции сайта.
От слова функции.
Как эти функции работают?
Не как в смысле, что делают.
У тебя максимальное время ответа – одна миллисекунда.
Вот это не функциональное требование.
Время простое.
Не больше одного часа в год.
Это не функциональное требование.
Как скоро что?
Давай.
Ну, я не знаю.
Ну, пусть будет функциональное.
Хорошо.
Это функции сайта.
Понимаешь, это скорее…
То есть важно ли пользователю видеть…
Ну да.
Хорошо.
Видеть это сразу.
Окей.
Короче, давайте не скакать.
Выясняем все про данные.
Про каждый объект.
Что мы хотим спросить?
Ага.
Количество.
Объем.
Количество.
Количество.
Так.
Максимальный размер.
Время жизни.
Ага.
Ну как-то.
Все важно.
Все важно.
Все важно.
Все важно.
Что еще?
Про каждый объект.
Количество.
Окей.
Максимальный размер.
Окей.
Время жизни.
Что еще?
Чего не хватает?
А?
Ну понятно дело, да.
Описание само, да.
Окей.
Я понял.
То есть какая-то…
Не знаю.
Ну то есть вот…
Ну это количество.
По большому счету.
Ну я тебе скажу, что в день миллион статей, я не знаю,
пять миллионов фотографий.
Вот ты в принципе…
В связи с объектом.
В связи…
В связи…
Отдельная история, да.
А потом с объектом.
Не каждый объект.
Да.
А пишем?
Мы потом их будем еще друг с другом связывать.
Что еще?
Здесь не все.
Окей.
Время жизни.
Давайте еще что-то…
Не знаю.
Жизненный цикл.
Напишем вот такую историю.
То есть можно это меняться или нет?
Вы знаете, что, например, большинство социальных сетей,
когда вы что-то удаляете, оно не удаляется.
Реально.
Это очень дорого.
Не имеет смысла.
Нужно…
Жесткий диск фаргментируется.
Его просто помечают, как удаленное, и все.
Все ваши поток…
А это не так…
Не так страшно.
Памяти очень дешевые.
Памяти очень дешевые.
А вот скорость гораздо важнее.
Даже потеря от того, что у тебя битый будет просто-напросто…
На диске все будет не подряд идти, а где-то будет дырка.
Ну, знаете, как работает жесткий диск.
Да, то есть если у вас банально тупо вырезали какой-то…
Вот у вас файл лежит.
Длинный.
Вы вот этот кусочек вырезаете.
Он свободен.
А потом нужно записать какую-то вот такую-то фигню.
Что сделать нормальный жесткий диск?
Вот этот кусочек запишет сюда.
Вот этот кусочек запишет вот сюда.
То есть он уже фрагментирован.
Не, не хотим.
Потому что в этом случае у тебя как минимум требуется,
не знаю, два движения…
Ну, смотря какой у тебя жесткий диск, да.
То есть как будто два запроса.
Сначала вот это считаешь, потом вот это считаешь.
Считай там все равно блоками.
Да ну нафиг.
Никто этим не парится.
Просто помечают галочки.
Удалено.
Причем ты удалять это должен сейчас не с одного места.
Скорее всего это все данные хранятся в нескольких местах.
Еще что-то где-то в бекапах и т.д.
Но сейчас скорее всего от этого уходит, потому что мы же…
Потому что GDPR, Европейский закон о защите персональных данных,
и по нему ты можешь потребовать, чтобы твои данные были удалены.
Физически.
Раньше на эту тему никто не парился.
Про что?
Ну согласен.
Хорошо.
Еще.
Ну это скорее вот сюда.
То есть как бы есть ли у нас какая-то региональная привязка.
Или нет.
То есть типа в одном регионе одни типы данных другом-другом.
Нет.
Ну все примерно, наверное.
Еще чего-то не хватает.
Достаточное.
Давайте так.
Максимальные размеры вы спросили.
Количество вы спросили.
Важно ли вам, не знаю, ну говоря вам важно, да?
То есть средние размеры.
Короче, когда вы спрашиваете про данные, вы спрашиваете не только максимальные значения.
Вы про все спрашиваете максимальные значения и средние значения.
Конечно.
Если он хороший менеджер, он эффективный и хороший менеджер, он проектирует систему.
Да, он примерно знает.
Догадывается или есть какие-то предварительные прикидки.
Зачем вам это потребуется?
Это очень просто.
Максимальные значения вам потребуется для того, чтобы рассчитать общие какие-то объемы хранения.
Общие объемы хранения.
А как бы предельные случаи.
Какого размера может быть видео на YouTube?
Не, видео, видео, видео.
Вот ты закачиваешь видосик.
Не любого.
Когда ты закачиваешь собственное видео на YouTube, ты не можешь закачать любой размер.
Ни фига.
А есть какое-то ограничение, по-моему 2 ГБ или что-то такое.
Но это тебе ничего не дает для того, чтобы рассчитать, сколько тебе места потребуется, например, для того, чтобы все это хранить.
Это тебе дает средние значения.
Поэтому тебе нужно и то, и то.
И это все остается как количества, так максимального размера.
Сколько всего в среднем публикуется постов о местах в день?
И сколько максимум можно публиковать?
Есть ли какие-нибудь ограничения?
В Facebook'е 5000 друзей.
Почему?
Клиент?
Ленту.
Ну, ленту, да.
Они построили какую-то такую архитектуру, в которой появляется это ограничение.
Они не могут сделать бесконечное у тебя ленту.
Бесконечное количество участников.
То есть, там есть ограничения.
5000 друзей.
Все, не больше.
Почему-то, я не знаю, почему они так делают.
Был такой сайт Life Journal.
Крутишь назад, они ленту держали за последние, не знаю, полгода.
А потом эта лента превращалась в календарь.
И ты смотрел уже посты не в виде ленты, а в виде, привязанных к календарной дате.
Тоже по какой-то внутренней архитектурной причине.
Какая-то ошибка.
Но у всех ли у пользователей Facebook'а 5000 друзей?
Нет, там среднее значение где-то 300.
И тебе для того, чтобы рассчитать общий объем базы данных
и понять сколько тех связей между пользователями, тебе нужны средние значения.
Так, но этого все равно недостаточно.
Количество максимальной средней значения, доступа, описания этого недостаточно для того, чтобы правильно спрактировать.
Чего упустили?
Один очень важный кусок.
Ну?
Думаете?
Не сможете, не заработает.
В смысле спроектируете, заработает.
А через год придется выбросить.
Да.
Как данные будут изменяться.
Все вот эти же самые параметры.
Еще и в динамике.
Жизненный цикл это можно удалять, нельзя удалять, можно изменять, нельзя удалять и так далее.
Нет.
Да.
Что будет через год, грубо говоря.
Что будет через год.
Во-первых, у вас могут появиться вообще просто тупо через год новые типы данных.
Конечно, скажу я, как эффективный менеджер, нужно видео еще выкладывать из мест.
А места мы объединим с вами в регионы.
А еще добавим достопримечательности.
И отдельно статуи.
И вот я вам накидал уже пяток еще каких-то новых данных и так далее.
А то, что у вас появляется видео, вам вообще может повлиять кардинально на то, что вы хотите разработать.
И так далее.
И то есть, не только про новые типы вообще как класса, но и про конкретное значение.
Вот сейчас выкладывается, например, 100 мест, ребят.
А через год мы добавим весь мир.
У нас мест будет уже 10 тысяч.
Мы потом, когда с вами начнем непосредственно проектировать, у нас от этого начнет вообще все сыпаться.
Вот от вот этих вот вопросов.
Что происходит, как происходит, как они будут меняться и так далее.
От этого могут решения ваши.
То есть, что вы выбираете, что не выбираете.
И так вот.
Нет, подожди.
Мы не можем сказать, что будет просто 10 тысяч.
Потому что мы так и должны держать в голове, что сейчас 100, потом будет 10 тысяч.
И во-первых, что это означает?
Это означает, что эти будут расти.
Количество будет постепенно добавляться.
То есть, ты должен такую архитектуру придумать, где ты можешь легко добавлять новое количество мест.
Конечно, если бы я тебе сказал, что будет там, я не знаю, 100 мест.
И так будет всегда.
Ты можешь выделить по одному серваку на место и тупо расслабиться и забыть об этом, например.
И закрыть вопрос с архитектурой навсегда.
Ну, допустим.
А если их будет постепенно увеличиваться, значит, ты должен придумать схему, когда будет сначала 2, потом 4, потом 10, потом 100 и так далее.
А архитектура может быть подавленной идеей, которая в данном случае трудно внедряться.
Да.
Поэтому очень часто, когда новая команда программистов приходит на проект, мы первым делаем, что пытается сделать?
Все переписать.
Не потому, что предыдущие были идиотами, а потому, что, как правило, предыдущие действовали в определенный...
Ну, то есть, у них был определенный набор входных данных, они его сделали.
Прошло время, данные поменялись, и новые задачи не всегда впихиваются в проект, не всегда предусмотрены.
Это плохая архитектура.
Хорошая архитектура предполагает, как бы, это все учитывает, потенциально растучитывает.
Так, что еще?
Короче, вот это все, потом тоже среднее значение, и потом тоже самое, что будет через год.
Еще.
Нет, вообще по всему. Давайте подумаем про всему.
Сроки отработки.
Хороший вопрос.
Можно добавить сюда еще бизнес-требования.
В предыдущие года мы об этом не догадывались.
Сроки, деньги, какие-то граничные условия, которые у нас есть.
Например, есть разные языки программирования. На разных языках программирования разная стоимость программирования.
То есть, как бы, стоимость разработчиков.
Есть языки очень дорогие, но эффективные.
Ну, например, вот СИШники, СИ++. Прекрасный язык.
Но, блин, программисты стоят дорого, их мало, их дорого, их мало.
Ядро Янекса написано СИ++. Естественно, больше не на чем.
А какую-нибудь сетку, социальную сетку можно написать, в принципе, на любом языке программирования.
И вот это есть бизнес-требования. Сколько у нас есть денег? Сколько мы готовы ждать?
Ну, может устраивать, да.
Может прийти заказчик и сказать, слушай, это нужно через два месяца.
Или у нас как Олимпиада делась в 2014?
Через пень-колоду в последний момент пришли, сказали, через полгода у нас сделать.
Олимпиаду. Сайт Олимпиады.
А там безграничное потенциальное количество человек в день.
Да, а потом при этом ты должен учитывать, что поиспользует, потом выбросит.
И нагрузка будет скакать.
Да, то есть она сегодня на 100 миллионов человек в день, а завтра она миллион.
А послезавтра ноль.
И, пожалуйста, построи такую архитектуру, чтобы она, когда послезавтра ноль человек,
я не платил столько же, сколько за 100 миллионов.
Ну, это скорее, это скорее какие-то вот суда, вот профили нагрузки.
То есть как у нас будут работать, что мы ожидаем, сколько человек, посещаемость и так далее.
Кстати, про посещаемость вы меня спросили?
Да.
Ну.
Ну да, надо не забыть.
У нас функциональная или не функциональная?
Короче, посещаемость.
И профили посещаемости.
Да, то есть как нам ходят, откуда.
Что мы про это знаем?
Есть ли, я не знаю, какие-то регионы, которые нас особо любят?
Или время, например, я не знаю.
Клерки возвращаются с работы и смотрят.
Так, ладно, дальше.
Бизнес-требования. Деньги, время.
Деньги, время, команда. Кто у нас уже есть?
У нас сейчас важно, не найдешь программистов, их мало, они дорогие и так далее.
Если у нас есть, например, там три PHP-шника, придется писать на PHP.
В идеальном мире это несвязанные вещи.
Ну, то есть как бы у тебя, по-правильному, конечно, до.
То есть ты берешь, но реально, как правило, все происходит параллельно.
Но тебе с точки зрения проектирования архитектуры не важно.
По большому счету.
Там очень в небольшом количестве мест архитектурное решение влияет на то, на каком языке это нужно писать.
В очень небольшом количестве мест. То есть мы когда говорим про архитектуру, мы говорим про паттерн.
Ну, например, шардирование. Общий объем данных разделяется на кусочки.
Винь, ты слышал, какую конкретную базу данных здесь использовать?
Вот когда я сейчас сказал. Общий объем данных разделяется на кусочки, каждый кусочек кладется в свою базу данных.
Какую базу данных мы будем использовать? Да без разницы.
То же самое и с языком.
Вот этот принцип разделения большого объема данных на кусочки каждой из своих баз данных называется архитектурный паттерн шардирования.
Он параллелен тому, какую базу данных ты используешь.
В большинстве архитектурных паттернов параллельно, какой язык ты используешь. Не важно.
Там один или два паттерна там важны.
Да, то есть, ну, какой он там, не знаю, комет, сервер или какой-нибудь, не знаю, сервер, который держит какие-нибудь кипелайв соединения, сложно написать на чем-нибудь, кроме там C++ или Go.
Сложно написать на PHP, а так в основном без разницы.
Так, дальше, что еще?
Еще один кусочек маленький забыли.
Здесь посещаемость, скорость ответа, страниц, да, деградация, потенциальные.
Так, во-первых, мы должны еще с вами узнать функциональные требования точно так же.
Мы уже раздели сейчас, в разрезе сейчас и потом.
А что будет через год? Не только про данные мы с вами спрашиваем, что нас изменит, но и про функциональные требования.
В принципе все, все вопросы, которые вы задавали, сейчас посмотрю, они упираются во что-то из вот этого.
Вы спрашиваете функциональные требования, что умеет делать система.
Вы спрашиваете про данные.
Вы спрашиваете про то, какие они есть, про их количество, про их максимальные и средние размеры, про их жизненный цикл, что с ними может происходить.
Понятное дело, состав, описание, права доступа, как к ним организован доступ, есть ли какие-нибудь ограничения, потом связи между ними, как они связываются с друг с другом.
У пользователя есть подписки на гидов. Сколько может быть? Какие есть ограничения? На сколько я могу подписаться на гидов? На одного, двух, на сто. Я могу не подписываться на гидов, я могу отписаться на гидов.
Все это в разрезе, что сейчас и что будет потом. То же самое с нефункциональными требованиями, тоже в разрезе, что сейчас и что будет потом.
Как быстро сайт должен отвечать? Какая посещаемость? Какая нагрузка? Сколько мы планируем? Могут ли быть какие-то скачки посещаемости? Не знаю, в пять раз, в десять раз. Ну как вообще это работает?
И бизнес-требования. Сколько у нас денег? Сколько у нас времени? Можем ли мы, не знаю, кто у нас есть уже из команды и так далее.
Вообще каждый раз по-разному. Не, никаких у тебя, может быть, что угодно. Максимальные значения тебе нужны для того, чтобы в предельные случаи проверить, чтобы понять, как тебя там, не знаю, взламывать будут.
Я могу написать пост в виде войны и мира или нет? Понятно дело, что таких странных людей будет мало. Обычно будут нормальные посты, не знаю, два-три абзац.
Но если ты будешь рассматривать и придумывать систему хранения для двух-трех абзацов, то какой-нибудь чувак, который публикует войну и мир, может тебе все сломать просто-напросто.
Поэтому обычно, обычно, вот эти вот максимальные значения, менеджер тебе может говорить, ну без разницы, мне все равно. И когда ты начнешь проектировать архитектуру, у тебя начнут эти максимальные значения вылезать.
Ну, топа, ты не можешь видео. Откуда там, не знаю, два гигабайта? Такой, не знаю, кусочек слота на диске выделено под каждый видосик. Я не знаю, надо подумать.
Или два гигабайта передаются между серверами с бэкапом, не знаю, не больше минуты, а у нас с тайм-аут минуты. Поэтому два гигабайта.
То есть через какое-то время ты все равно все эти максимальные значения, если они даже не заданы исходно, ты их все равно задашь, просто уже исходя из своей архитектуры, исходя из того или иного пункта.
Так, все, едем дальше, стираем. Запомнили?
Едем дальше. Прямо начнем. Вообще структура нашего самого процесса. Сейчас мы с вами в каком-то смысле все еще готовимся к тому, чтобы начать.
Подготовились? Можно начинать. Сейчас мы с вами приступаем к изучению так называемых архитектурных паттернов.
То есть некие устоявшиеся подходы к проектированию тех или иных кусочков, к проектированию тех или иных блоков системы и так далее, мы их все изучаем.
Пройдем все, поймем для чего, каждый из них, в каких ситуациях и так далее, и так далее, и так далее.
Затем мы с вами изучим некий алгоритм вот этого самого проектирования. Прям первым пунктом является вот то, что мы с вами уже сделали, задавание вопросов.
То есть выяснение того, что мы будем проектировать. Алгоритм проектирования очень простой. 5-6 шагов и так далее.
А затем попробуем просто-напросто применить одно и другое. Будем брать проекты и будем пытаться их спроектировать.
Итак, архитектурные паттерны. У нас их несколько штук. Давайте начнем с самых простых.
Вот есть паттерны, которые потребуют от вас чего-то там, от программистов, которыми вы управляете или которым вы ставите задачу, каких-то серьезных больших переделок.
А есть паттерны, которые не потребуют практически ничего. То есть не нужно покупать никаких новых серверов, не нужно ничего делать.
Просто берете, внедряете и все начинает работать.
Сейчас давайте прикинем, какой-нибудь мы начнем. То есть нам нужно увеличить в каком-то смысле производительность нашей системы.
Нас проектировать. Понять, понять что. Возьмем сайт ВКонтакте. Кто смотрел?
В прошлом занятии предлагал посмотреть, что происходит, когда вы загружаете странички ВКонтакте. Кто видел?
Смотрел? Сколько страничек? Сколько там чего происходит?
Ну да.
Ну да, ну да.
Ладно, так. Типичный сайт. Вот ВКонтакте, как пример.
Страничка, логотипчик, много текста, много картинок.
Мы с вами в прошлый раз смотрели, что происходит, как браузеры ее запрашивают.
Браузер смотрит ее в кэше, затем скачет вот эту самую страничку, затем начинает скачивать каждую картинку отдельно.
Ну в смысле параллельно, но тем не менее, каждый из них скачивается.
После того, как он все это более-менее скачал, он скачал еще отсюда CSS файлы, JavaScript файлы и так далее.
Вот допустим, у нас есть получается один HTML, то есть вот это вот весь контейнер, в котором все данные и все прочее.
И для него нам нужно было произвести вычисления, посмотреть, не знаю, достать из базы последние новости или последние посты и так далее.
Дальше. Внутри этого HTML у нас, например, не знаю, 5 CSS файлов, это файлы оформления.
Не знаю, 5 JavaScript файлов, это файлы различных, не знаю, как это там запускается, всякие мигающие картиночки, мигающие бегающие надписи и так далее.
Не знаю, 20 картинок и так.
Ну вот у нас, вот такой вот у нас характер.
Причем вот это у нас 100 килобайт, вот это у нас, не знаю, 20 килобайт.
Суммарно, тоже 20 килобайт, а это мы примерно, не знаю, 1 мегабайт.
Это все можно писать, это я придумываю из головы.
Давайте думать. Здесь один запрос и еще 30 запросов на оформление.
Вот структура. Давайте подумаем, как мы можем это спроектировать?
Как мы можем как-то облегчить жизнь серверу, ускорить его работу, за что бы нам здесь сами зацепиться?
Что вам здесь кажется подозрительным?
Скорее, мне кажется, наоборот.
Ну да, здесь уже, у тебя же здесь уже данные.
У тебя в HTML, у тебя пост, текст поста, текст новости.
Допустим, давайте новостной сайт для простоты.
Вот новый новый сайт.
Вот новый новый сайт.
Ну что, один раз спрограммировали ребята, что при наведении на название новости появляется всплывашечка с автором, все.
Спрограммировали, положили в Javascript и он лежит там годами.
Это как сайты или сайты сайта сайта сайта сайта сайта сайта сайта сайта сайта сайта сайта сайта сайта, это не все.
положили в JavaScript, и он лежит там годами.
С...
А?
Окей, хорошо.
Но это...
Давай как архитекторы.
Хорошо, да, можно пожать.
Что еще можем сделать?
Ну это вы...
Да, это вы сложную штуку придумываете.
Так делают, да.
Согласен, это...
Ну так делают, да.
Да, когда вы тоже там
БК или Фейсбук загружаете,
он не загружает вам все, он загружает вам
первые два-три поста.
А все остальное
он не загружает.
Он не загружает.
Он не загружает.
Поста.
А все остальное будет подгружаться.
Это...
Запомни и вспомни через
пару занятий.
Эту идею. Она сложная.
Так, более простой способ, ребят.
Вот это все можно
закашировать, я согласен.
Что еще можно сделать?
Параметрию.
Как же они там запомнили,
где это будет все?
А картинки надо зачем кашировать?
Когда мы будем за Лену
кашировать?
Давай у нас новостной сайт.
Новости.
Да, картинки бывают разные,
у тебя картинки бывают прясные к новостям,
может их не надо кашировать.
Хотя я бы все равно кашировал.
Наверное, ты зашел на страницу,
ну что, закашируй просто на день.
Логотип ты можешь закашировать
на год, а картинки на день.
Здесь у тебя есть картинки оформления
и картинки новостей.
Эти на год,
картинки новостей на день,
пусть через день спираются.
Потому что через день новость уже
устарела и ушла куда-то в архив.
Еще.
Не хочу особо ничего
менять.
Но здесь, что здесь еще кажется
подозрительным.
То есть вот это у нас меняется.
Как только вышла новая новость, это все меняется.
Вот это все не меняется.
Да, потенциально мы положим все, что не меняется
в кэше.
А с серверной стороны,
вот у вас на сервере, помните, да?
То есть идет запрос. Каждый из этих
запросов попадает на серва,
каждый из этих запросов обрабатывается.
Почему?
Ну,
поднимаем вашу мысль,
давайте ее докрутим.
Ну, то есть смотрите.
Для того, чтобы вот это вот...
Какие ресурсы серверные нам нужны?
Для того, чтобы вот HTML
нарисовать.
Нам нужно как процессорное время,
нам нужно их вычислять,
так и достать все это
из базы данных, данные какие-то, да?
Вот.
Память нам нужна,
и память нам нужна тоже в вычислении
где-то производительного, не знаю, склада.
Ну, в общем, короче, нам нужны ресурсы.
А для того, чтобы CSS-ки...
Только там вычисления
не нужно, только жесткий диск.
Скачал из жесткого диска и отправил.
И это тоже.
Потому что в HTML у тебя
все данные нужно формировать.
Не в том, чтобы отправить,
а в том, чтобы формировать.
Да?
Картинки формировать на лету
это очень плохая идея, да.
Ну да.
Ну, это плохая идея, правда.
Гидрация.
Может быть, скорее всего,
они заранее все пригенерировали,
тебе что-нибудь подставляли туда, что-нибудь такое, да.
И да, короче, смотрите,
в чем фишка, да.
Есть разные типы хранения
картинок.
Формат картинки.
Есть картинки, которые загружаются сверху,
вверху, вниз. Есть картинки, которые
загружаются,
как называем, progressive PNG.
Тебе загружается, например,
сначала размытая картинка, потом
она уточняется следующим слоем, потом
еще уточняется и так далее.
То есть это просто разные типы
храни... не формат.
То есть это специально
с этим ничего не делает.
Так сохранили, тебя бразер и грузит,
и он принимает решение.
Он тебе показывает ее сразу или ждет,
загрузится или показывает построчно
выводит и так далее.
Так, короче,
на что пытаюсь обратить ваше внимание.
Ребят, там нужны разные ресурсы
сервака для того, чтобы выдавать
разные картинки.
И мы можем подумать на тем,
как мы можем это использовать.
Как минимум, мы действительно
можем
положить
вот эти данные пользователю
поближе.
Для них нам не нужно ничего вычислять.
Как только запрос пришел,
мы сразу взяли и отдали.
То, к чему я вас веду,
называется вообще просто
основой основ.
Называется трехзвеневая
структура хранения,
структура обработки.
Трехзвеневые три звена.
Какие три звена?
Вот пришел запрос на сервак.
Первое звено.
Так называемый
frontend.
Первый веб-сервер,
который получает запрос от пользователя.
Что он делает?
Он просто-напросто смотрит на запрос.
Что это такое?
Что это такое?
Если это что-то легкое и не требующее вычислений,
которое нужно просто взять с диска
и отдать, он берет с диска и отдает.
Так называемую статику.
Основа основ.
Любая система сейчас так строится.
То есть пришел
запрос,
если это статика,
если это картинка,
что-то, что не требует никаких вычислений,
считать с диска
или взять из памяти и отдать.
И забыть, закрыть вопрос.
Если это что-то
требующее вычислений.
Идем дальше.
Но только в этом случае.
Идем в backend.
Либо backend,
либо backend.
И вот здесь уже ваша программа,
которая занимается вычислениями.
Которая строит,
достает из базы данных нужные новости,
последние 10 штук.
Как-то их там, я не знаю, компонует.
Ставит заголовочек в одно место,
вырезает анонсы,
ставит в другое место.
И отдает пользователю готовость
на HTML, HTML.
Вот здесь, собственно говоря, вычисления.
Происходит.
И третья звено, какое?
Хранение, да.
Да, либо просто какая-то
система хранения.
Ваша программа-то не знает?
Ничего.
Она умеет обрабатывать.
Она делает запрос базы данных.
Дай последние 10 новостей.
Окей.
Дай последние...
Не знаю, дай для вот этой новости,
она главная.
Вестит.
Я выведу у нее анонс ни из одной страны,
ни из одного абзаца, а из пяти.
Окей.
Наверное, количество запросов
поддали, сформировала,
вернула и так далее.
Ну да.
Нет.
Модель view-контроллер
это организация твоего программного кода
внутри. То есть я, грубо говоря,
вот здесь, вот внутри
твоей программки, модель
view-контроллер там.
То есть как ты это внутри
организуешь, нас сейчас особо
не волнует. Мы рассчитываем, естественно,
что ты хороший программист
и нас здесь сидишь.
Так. Пронтент,
бэкент, субэдэй.
Субэдэй или хранение, что-то такое.
Фактически всегда
вот эти три звена есть.
Они могут по-разному называться.
Фронтентом иногда еще называют то,
что происходит внутри браузера, ну в смысле
в браузере и так далее.
В банковских системах почему-то
фронтом называют на самом деле
кусочек бэкэнда.
Да, то есть как бы
в NSPK я вчера был,
который платежные системы делают,
у них фронтент это вот кусочек вот этого.
Ну не суть.
Исторически сказалось так, что фронтент
это маленький быстрый сервер.
Ну, например,
вот, собственно говоря, то, что сделал Игорь Цисоев,
он здесь используется Nginx.
Обычно. Чаще всего в России
почти всегда.
Знаете, в чем, например, проблема?
В смысле, в чем выгода?
Вот, например,
смотрите, здесь, ну, например,
мы с вами старожилы, мы с вами пишем
на PHP.
И у нас вот здесь, в этом случае,
на каждый экземпляр PHP
вашей программы.
Ну, как вы думаете, сколько нужно памяти?
Ну, много, на самом деле.
Ну, не знаю, 100 мегабайт.
Да на милую душу.
PHP, интерпретатор,
они, дай бог, там Java.
А если Java, то там
и того больше.
На каждый экземпляр,
на каждую вашу программу.
А здесь сколько?
То есть на каждый запрос
операционная система
должна алоцировать вот такой вот,
я не знаю, кусочек, выделить.
И если у вас 60
гигабайт памяти,
значит, что
максимум параллельных запросов,
которые вы можете выполнить.
Сколько?
600.
А больше нельзя.
Сервак больше не потянет.
Вот эти, вот здесь.
Сколько NGINX тратит на обработку
одного запроса памяти?
Ну, типа того.
1 килобайт.
Потому что запросы другие.
Ну, не один, на самом деле, там 2-3 или что-то такое.
Ну, не суть.
Гораздо меньше.
Ничего считать не надо.
Но нам это нужно.
Потому что, вот смотрите, да,
у нас на один запрос
такой, даже на нашем новостном сайте,
приходит 30 запросов вот таких.
У нас здесь именно такое отношение.
То есть, просто введя вот такое
разделение, мы с вами
30 раз увеличили производительность.
Я когда
занимался консультированием
за деньги
по выстраиванию высоких нагрузок,
я на вот этом вот паттерне
получил большую часть денег.
Ты приходишь в компанию, там ничего нет.
Ты смотришь, скорее всего, у них нету
разделения на фронт-энд, бэк-энд и
на фронт-энд и бэк-энд.
Говоришь, встать и ребята NGINX,
вау, ставят,
можно уходить. Все, дальше можно не работать.
Деньги взял и ушел.
Нет.
Не совсем так, смотри.
Прошел запрос от пользователя.
Пронтент его принял.
Расшифровал.
Да, есть некий оверхэп.
Он его расшифровал, смотрит внутрь запроса
и по некоторым правилам, по которым он настроен,
пытается понять, что это за запрос.
Если это картинка, он отрабатывает,
сразу выдает. Он понял, что это
не картинка.
Он вот это соединение не закрывает.
Он открывает сам соединение
к следующему серваку,
к бэк-энду.
Для него это так называемый
upstream.
Выше стоящий.
Открывает к нему соединение
и пересылает ему
запрос пользователя исходного.
То есть он никому, он пользователя
не перебрасывает. Для пользователя
все прозрачно. Пользователь соединился с фронтендом.
Это важно. Мы сейчас с вами еще подумаем
для чего.
Пользователь соединился с фронтендом
и он не знает про бэк-энду.
Это в том числе еще для безопасности.
Он не знает про базу данных.
Естественно, не дай бог.
База данных нельзя вообще снаружи подключить
отсюда, из внешнего контра.
Он получил ответ.
Бэк-энд вычислил.
Он отдает ответ фронтенду.
И этот сервак отдает
уже пользу.
Грубо говоря, запрос пользователя
один единственный
проходит
через несколько серверов.
В данном случае два.
Ответил на этот вопрос?
Обычно почти всегда
картина гораздо больше
чем всего остального.
Почти всегда
фронтенд отбивает запрос
и забывает.
Едем дальше.
А для чего еще нам пригодится фронтенд?
Вот отличная штука.
Мы поставили, заработали денег
увеличивая производительность
системы в развитии.
А для чего еще?
Чего делать?
Почтается на фронтеде
и бэк-энд занимает фотографию.
Установить скуму.
Окей, хорошо.
Всего
шифромания.
Для чего нам еще нужен фронт?
Да.
Дальше.
Как именно?
Понятно, он все принимает
фронтенд.
Хороший ответ.
Да.
Дос-атаки безопасность.
Почему?
Как конкретно
дос-атаку можно организовать?
В смысле,
как конкретно можно организовать?
Что здесь можно поломать?
Ну я вам рассказывал
это в прошлый раз.
Если у нас на каждый из
вот этих вот PHP
требуется 100 мегабайт,
у нас, не знаю, 6 гигабайт
оперативы, значит
всего 660
процессов.
Мы открываем соединение с каждым.
И ждем.
Ничего не отправляем
в это соединение.
У нас эти
60 процессов,
60 соединений
можно с ноутбука открыть.
То есть можно положить любой сайт.
Но не тут-то было, если
перед Backend PHP
там стоит Nginx.
Потому что здесь нужно открыть уже не 60 соединений,
я не знаю,
600 тысяч соединений.
Ну пойди попробуй открыть с ноутбука
600 тысяч соединений.
То есть
простейшая, элементарнейшая
защита от DOS.
Запрос приходит сюда
и Frontend не начинает
с ним ничего делать, пока он не пришел
полностью.
И только когда он пришел полностью,
мы достоверили, что запрос пришел, он отправляет его
к Backend, ждет ответа
от Backend, все это у себя
буферизует и после этого отдает.
То есть самая простая защита
от DOS.
А если
это злонамеренные?
А если не злонамеренные?
Вот смотрите, мы точно знаем, что у нас
сервер DOSить не будут.
И у нас нету картинок
и нету статики. Нам нужен Frontend
или нет? Если нужен,
для чего?
Пользователь может
сидеть на мобильном телефоне.
Что это означает?
Это значит, что он будет нормально работать
и скачивать данные, которые ответил
ему PHP, но в час
по чайной ложке.
Вот я сижу на
GPS, где-нибудь на рыбалке.
И качается
просто медленно, 1 килобайт в секунду.
И вот у меня страничка на 100 килобайт.
100 секунд я буду качать.
Поэтому тоже в том числе
ставят Frontend.
Он полностью получил ответ
от Backend,
от PHP на эти 100 килобайт, сохранил их
где-то себе сюда, на жесткий диск
и потихонечку пользователя
отдает. Backend он уже освободил.
Вот этот конкретный экземпляр
Backend он освободил.
Понимаете, да?
Понимаете?
Точно понимаете? Все понимают?
Галерку понимают? Окей.
Медленные запросы.
То есть незаланамеренные.
Просто когда медленные клиенты.
Клиенты.
Когда клиент медленно
качит или медленно закачит.
Или хуже того.
Большие запросы.
Я на YouTube выкладываю
3,2 гигабайта.
Час будет закачиваться.
Если мы все это время
будем держать
100 мегабайтный экземпляр
Backend, ну дороговато.
Нет, мы держим 1 килобайт
Frontend.
То есть Frontend буферизует
общение с Backend как в одну сторону,
так и в другую.
Он полностью ждет, пока весь запрос
от пользователя загрузится.
Как только и только
он загрузился, он
передает его Backend.
А здесь уже все это происходит быстро.
Они рядом.
Или они вообще на одном серваке.
Расположены. То есть медленные запросы
там вообще буферизация
всего.
Еще.
Для чего мы еще можем много использовать?
Ну, смотри.
Как бы
и да, и нет.
Потому что мы потом дальше
с вами пойдем. Про масштабирование
будем говорить. И каждый из этих
звеньев масштабируется отдельно.
Frontend по одним способам,
это другим, это третьим.
Скорее всего, в правильно
организованной системе
мы будем говорить.
И каждый из этих звеньев
масштабируется отдельно.
Скорее всего, в правильно организованной системе
у тебя
а YouTube, скорее всего, в правильно организованной
системе у тебя будут разные Frontend
для того
для этой ситуации, когда ты смотришь
видосики и когда
ты закачиваешь их.
Но вообще, по большому счету, да.
То есть в хорошо
организованной системе
любой запрос пользователя
сначала проходит через
какое-то легковесное
звено.
Через Frontend.
А чего это зависит?
Ну да,
от функциональных требований.
Вот иногда менеджер Google
эффективный менеджер
в Google
сказал своему программисту
или архитектору, ну слушай,
ты говоришь, что все закачалось
только тогда, когда все закачалось.
А например
эффективный менеджер в YouTube
сказал не так.
Он сказал, что ты сейчас ответишь
пользователю, что мы передали
информацию, и она обрабатывается.
А когда
она обработается, мы тебе
отдельно напишем.
Она когда заканчиваешь видео, видосик в YouTube
он тебе не пишет, он тебе пишет, закачала.
Она не пишет, обработала.
И через какой-то
через пять минут она может тебе выдать
сорян,
не смогла обработать.
Закачала, но что-то ты не то
залил. Вот.
Грубо говоря, если правильно,
если отвечать на твой вопрос,
то обычно, да,
обычно вся вот эта
цепочка успеет пробежать, но
вот это все происходит очень быстро,
потому что она, во-первых, рядом,
во-вторых, над этим вот это все
ты контролируешь, вот эти все взаимодействия.
Вот здесь то, что происходит, ты не знаешь,
что там происходит, не контролируешь. А вот это
все у тебя рядышком стоит
на одной машине или на разных машинах,
ну рядом и так далее. То есть ты знаешь,
как это работает.
Но обычно, да, когда ты выдаешь
любой запрос современной
информационной системы, он успевает
пройтись с десятки машин,
десятки каких-то там, не знаю, путей,
собраться из пяти различных вариантов
и тебе вернуться.
Ничего страшного в этом нет.
У тебя вот здесь вот какое соединение?
Какое?
Вай-фай какой-нибудь, не знаю.
Сидишь на 5 мегабит, окей?
А здесь у тебя, не знаю,
тысячи мегабит,
один гигабит,
один гигабит,
один гигабит,
один гигабит,
один гигабит.
То есть даже если у тебя это на разных серваках,
то вот так.
Вот собственно вся разница.
И здесь у тебя
помехи, солнце, я не знаю,
чего угодно.
А здесь у тебя ничего этого нет.
Они рядом стоят, друг к другу
воткнутый рядышком.
Даже, как правило, так.
То есть если хочешь прям очень быстро
делаешь так.
Или вообще, это если они
на разных серверах.
А если они на одном.
Для большинства проектов,
еще важный момент,
но это вы конечно столкнетесь,
в большинстве проектов
все, что мы с вами будем изучать,
не потребуется никогда.
В 99% проектов достаточно вот это вот
внедрить, причем на одном серваке.
И все.
И вы 100 тысяч посетителей в сутки
выдержите. Больше не надо.
Большинство сейчас в современных CMS
даже битрикс, по-моему, вот так вот сделан.
Я к чему?
Я к тому, что это скорее всего еще на одной машине работает.
А если так, то здесь у тебя еще вот так вот.
С памятью общаться.
Без проблем.
Для чего
нам потребуется
фронт?
Маферизация, статический контент.
Шифрование.
Что еще можно сделать?
Итак, у нас новостной сайт.
Давайте думать.
Ну вот уже начинается.
То есть ты хочешь сделать
нинжинэкс, а фронтэн тумным.
Да, ну он
тупой должен быть.
Максимум, что он может сделать, это вывести красивую
картинку,
если у него бэкэнд не отвечает.
Чего делать?
Ну да.
Хорошо.
Обработка ошибок. То есть мы можем показывать красивую
картинку.
То есть вот
кто знает, какие у нас программисты,
может криво написали, ошибки
выдает и так далее. То есть
обработка ошибок.
Но обработка в каком смысле?
Обработка для пользователей. Даже не
скорее не обработка, а открытие ошибок.
того, что у нас там внутри.
Если вы открываете на строке нжинэкса,
у него там прям все черное по белому написано.
Если выдается такая,
то есть у него настройки очень простые.
Во-первых, для того, чтобы понять статика
это или не статика.
То есть такого вида запроса
это статика, отдавая из диска,
такого вида запроса это
динамика, передавая их на бэкэнд.
Это первый класс
настроек, а второй класс настроек,
если бэкэнд ответил
таким-то кодом ошибки,
выведя вот эту
красивую страничку.
Так, обработка ошибок. Что еще мы можем
на нее повесить?
У нас есть
легковесный быстрый сервер, который быстро
обрабатывает
большую часть запросов.
Давайте представим новостной сайт.
Вот я пришел,
через секунду ты пришел.
Что-нибудь вам возникает
какие-то идеи?
Да?
Давайте так сделаем.
Давайте на нее просто тупо
какое-нибудь каширование повесим,
простроим.
Да.
А где это мы уже не всегда.
Для этого мы как раз и будем функционально
требования спрашивать, что у нас
там на страничке показывается.
Ну, часто можно.
Новостной сайт,
но нет.
Новостной сайт такой без авторизации.
Даже в Яндексе,
когда заходишь на него,
у него там есть персонализация.
Но в 80% случаев персонализации нет,
что пользователь не залогинен.
И почему бы нам до 80% случаев
не закашировать эту гребаную главную страницу,
которая так долго строится,
которая так важна.
Давайте мы закашируем на 5 секунд.
Мы тем самым еще
на 50% запросов к нам убьем.
Еще в 5 раз, 10 раз повысим
эффективность нашей работы.
Вы понимаете, у нас первое занятие,
мы час работаем, мы вам уже в 100 раз
подняли посещаемость.
Потенциально.
Короче, каширование.
Каширование запроса в бэкэнду.
То есть бэкэнд вполне может
говорить, слушай,
этот запрос там, я не знаю, можно закашировать
на 5 минут.
Каширование.
Фронтенды маленький свой локальный кэшик,
либо в памяти, либо в памяти,
либо на диске.
Не важно, это все равно будет работать быстрее,
чем повторное вычисление.
Так, еще что-нибудь? Все?
Хватит?
Ну хватит.
Хотя нет, есть еще один пункт.
Здесь у нас один килобайт.
Здесь у нас
100 мегабайт.
Короче, фронтенд
очень часто используется
для того, чтобы балансировать
нагрузку к бэкэнду.
Медленные запросы нет, не совсем.
Что имеется в виду?
Вот смотрите.
Вот здесь у нас, допустим,
может быть...
Ну то есть очевидно,
что нам для того, чтобы
вычислить запрос, нужно гораздо больше
ресурсов бэкэнда, чем ресурсов фронтенды.
Вот этот фронтенд
может потянуть, я не знаю,
100 тысяч запросов
в секунду.
Ну допустим,
100 тысяч запросов в секунду.
И мы с вами смотрели, у нас в исходных данных
одна тридцатая от этих запросов
это запросы
к динамике.
И вот мы одну тридцатую
считаем, это у нас
100 на 30,
у нас, например, 3000
запросов в секунду,
это запросы к динамике.
Ну дальше, мы еще
кширование сюда ввели,
и у нас, я не знаю, еще
в двадцать раз сократили эту цифру.
У нас остается,
давайте в тридцать раз мы сократим,
у нас остается 100 рпс
к динамике.
100 запросов на вычисление
в секунду.
На одно вычисление
допустим, тратится одна секунда,
это очень много, ну допустим.
И у нас 6 гигабайт памяти,
которым мы можем выделить на бэкэнд.
Вывод это означает, что у нас
всего лишь 60 процессов,
которые мы можем запустить.
А 60 процессов, каждый из них вычисляет
одну секунду, значит 60 рпс.
Что нам делать?
Мы ставим второй бэкэнд.
Еще один бэкэнд.
У нас уже потенциальная пропускная способность
максимальная, 120.
Так, конечно, немножко считать нельзя,
это очень грубо.
Ну, допустим, для наших
бэкэнд сейчас сойдет.
Как нам теперь сбалансировать?
Очень просто.
У нас фронтенд,
мы прописываем фронтенд,
что, дорогой мой, теперь у тебя два
бэкэнда.
Ты половину запросов вправляешь сюда,
а половину запросов отправляешь сюда.
Тупо пополам.
Мы с вами еще потом обсудим,
когда это возможно, когда это невозможно,
в каких ситуациях так стоит делать,
в каких ситуациях так не стоит сделать.
Но в общей сложности называется
балансировка.
Фронтенд используется для балансировки
запросов к бэкэнду.
То, что дальше от бэкэнды, потом
будут использованы для балансировки запросов
к базе данных.
То есть очень такая, ну,
тревогитная цепочка.
Балансировка.
Мы с вами ничего еще особо не
меняли.
Мы программу не переписывали.
Мы программу не переписывали.
Программа точно докажет,
как и раньше.
Мы ее просто запустили
под другим
управлением. Мы поставили
перед ними фронтенд. Все.
Что еще?
Задание к следующему разу.
Прикиньте, что еще мы можем сделать с каким-то
минимальными изменениями.
Чтобы ничего особо не менять,
десятки серваков не покупать,
никакую логику
внутри вот этой истории сильно не
переписывать и так далее.
Какие еще мы можем сделать подход?
Как еще подойти к снаряду, чтобы увеличить
нашу потенциальную
производительность?
Мы потратили на самом деле
реально час времени.
Мы скачали NGINX, скомпилировали
его и прописали
ему, что он должен половину запросов
перехватить и все.
Не половину, а 95% запросов перехватить.
На строчный файл из 10
строчек мы написали. Все.
Реально все.
Ну, как я сказал,
мы не будем
прописывать.
Мы не будем прописывать.
Ну, понятное дело,
настроили, что теперь он обрабатывает
80-й порт,
входя 443-й,
а потом уже передает
бэкэнду, который на другом порту
перевесили бэкэнд на другой порт.
Но мы самого программирования вообще не трогали.
Это работа системы администратора.
Он как бы даже проверкался.
Короче, ничего не произошло.
Да, кажется, что мы
ввели кучу новых абстракций
и так далее, но реально нет.
Вот в следующий раз,
в следующую среду,
давайте вот эти все идеи,
что еще можно сделать
такого простого, какие у нас еще
архитектурные паттерны простые есть.
Вот это основной, называется
трехзвеневая структура.
Все. На сегодня это все.
Остальные в следующий раз. Готовимся.
Все. Пока-пока.
