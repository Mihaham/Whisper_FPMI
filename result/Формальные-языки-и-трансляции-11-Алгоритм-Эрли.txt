всем доброго дня мы сегодня так сказать начинаем может быть продолжаем тему связанную с парсерами
значит у кого-то на колокольни был вопрос посвященный парсерам да давайте попробуем
сформулировать что же такое парсер да
ну да по факту это алгоритм который имеет в инпуте
в слово или грамматику же тут в зависимости от некоторые алгоритмы сами зашивают при
процессе и грамматику некоторые не зашивают и наша цель ответить на следующий вопрос
лежит ли слово w в языке задаваемой грамматика же если ответ на этот вопрос правда то построить
дерево вода вот так это обозначу вот на какой парсер мы с вами уже разбирали
алгоритм кока янгера косами и наша цель сегодняшняя будет понять как построить парсер который бы мог
работать с произвольной грамматикой и мы начали с вами в прошлый раз немножечко колдовать значит
мы с вами в прошлый раз построили дерево разбора то есть у нас есть грамматика из эс выводит ас бс
и из эс выводит вэпсио мы с вами напомнили что это правильная скобочные последовательности
и идея следующая давайте попробуем про эмулировать это дерево вывода то есть мы
с вами попробуем сделать так чтобы мы обходом в глубину обошли это дерево вывода начиная слева
верхней точки то есть мы начинаем слева верхнего узла и должны дай обойти все дерево целиком и
дойти до правой штуки то есть вот так вот обойти наши дерево вот наша цель если мы на каком в
каком-то моменте заткнемся замкнемся то значит можно сказать наверное что слово не лежит в языке
задаваем на грамматик вот идея такая и по факту будем спускаться с вами вниз и пытаться
пристроить какое-то дерево кусочек дерева вывода но возможно тут может быть несколько
вариантов почему может быть несколько вариантов понятно да потому что грамматика не обязательно
является однозначной вот поэтому нужно выявить хоть какой-то вывод поэтому мысленно мы будем
с вами вот держать вот эту вот историю и попытаемся разобрать построить конструкцию
которая позволит нам разобрать все слово целиком давайте подумаем какие у нас три ситуации возможно
когда мы будем разбирать это дерево разбора ну опять же напоминаю что у нас есть слово ааб значит
видим если у нас есть первая буква а в этом дереве то мы можем точку проскочить если идем
вниз то опять же напоминаю что если посмотреть на внимательно на алгоритм обхода в глубину да то
у нас по факту есть такая структура как стэк стэк вызовов рекурсии обходов глубину и по факту чтобы
выскочить из этого стэка нам необходимо понять а где же точка возврата нашей функции то есть куда
в какую точку мы возвращаемся здесь идея ровно такая же давайте мы возьмем значит позицию в которой
мы находимся обозначим ее черный кругляшочком и позиция родительская где мы находимся у родителя
нашего дерева разбора на текущий момент как круглую точку полую точку и когда мы прыгаем вниз мы
по факту запоминаем где у нас эта точка была то есть вот у нас черная точка была здесь соответственно
мы спускаемся вниз эта черная точка становится белой точкой для того чтобы потом мы могли из
нее выпрыгнуть да да мы пытаемся обойти в глубину сейчас мы гипотетически его знаем вот а дальше мы
будем пытаться перебирать все возможные префиксы для того чтобы строить гипотетическое сет возможно
деревьев на текущем префиксе который у нас получается вот просто нам необходимо понять
какие конфигурации какие правила у нас с вами есть то есть если у нас есть символ и у нас есть он
хороший то мы можем прыгать вниз переходить двигать точку а если мы встречаем препятствие в виде
не терминала то мы должны обойти наше дерево целиком спуститься вниз разобрать под слово
который соответствует этому дереву выйти вверх вот и вот первый момент времени который у нас
есть мы должны выйти из этого дерева целиком мы считайте обошли весь лист который у нас с вами
был вот здесь ну я сам пустое слово поэтому нам надо вернуться вверх ну как понять куда вернуться
значит у этой точки есть родительская точка она находится где-то здесь да а мышку видно кстати
вот смотрите у этой точки мы знаем где родитель он находится здесь но а в этой
точке мы обошли поэтому когда мы обошли все по дереву целиком мы можем взять и перепрыгнуть
через этот терминал поет через этне терминал но собственно мы его стоп это не туда собственно
мы его перепрыгиваем. Вот так вот. И повторяем все процедуры, которые здесь есть. Вот здесь мы
закрыли все под дерево из SWET-ISBS и должны прыгнуть вот сюда. Оба прыгаем и так далее обходим слово
целиком. Вот. Но на самом деле сейчас это гипотетическая история. И поэтому в прошлый раз, когда
мы начали обсуждать эту картинку, мы сказали следующее, что на самом деле нам необходимо отслеживать
позицию в слове, где мы находимся на текущий момент. То есть давайте зашифруем блоки,
в которых мы находимся, через позиции точек и правила вывода. А именно, давайте определим
следующую вещь как ситуация для определенного правила грамматики. То есть вводим новое понятие.
Для правила давайте я напишу сначала так. А выводит гамма. Это следующий объект. Мы гамму
разбиваем на некоторую последовательность двух терминалов. У нас получается следующее,
что это мы будем записывать а, стрелочка, альфа, точка, бета. То есть у нас добавляется в нашем
правиле грамматики где-то точка посередине. По факту это позиция, в которой мы будем с вами
находиться. Дальше мы будем кодировать эту штуку некоторым элементом и. Сейчас я объясню. И вот
эта вот штука будет находиться в некотором множестве дежиты. По факту мы можем сказать, давайте
кодировать это двумя индексами элементов и и g. Но с точки зрения реализации алгоритма,
иногда вот это вот g заменяют и пишут, что вот эта вот штука, вот эта вот история находится в
некотором множестве, которое индексируется позиции g. Сейчас я попытаюсь объяснить,
что же такое и и g. Для этого давайте я немножко перерисую наше дерево. Как оно у нас выглядело?
И у нас слово ABB. И теперь смотрите. Вот если мы находимся вот в этом месте,
у нас полая точка находится здесь, а жирная точка находится, я не предположим, где-то здесь.
Это значит, что на самом деле мы находимся с вами в следующей ситуации. Давайте это пример.
У нас будет что? Мы находимся в ситуации s стрелочка, а s точка. Видите, точку посередине
этого правила ставим. B, S. Дальше. Смотрим, где у нас вот эта точка находится полая.
Сколько букв мы до этого прочитали? Одну, одну. Да, да, да. Одну. Да, слева от полой точки,
от родительской точки. Как вы думаете, жирную точку чем кодируем? А жирная точка это позиция,
которая находится здесь. То есть сколько мы прочитали на текущий момент? Два. Что это за
конструкция? Это по факту мы говорим, что нам вообще по боку что происходит в другой вещь.
Мы можем, грубо говоря, из-за того, что мы обходим наше дерево обходом в глубину, нам важно только,
где мы находимся в вытекущем правиле, где находится позиция точки, мы ее кодируем по факту. Поскольку
мы разбираем определенное слово, то мы можем кодировать позиции в данном слове. И нам важно
позиции вот этой точки. И мы ее кодируем позиции опять же в слове. А чтобы выпрыгивать потом из
дерева вверх. То есть мы обошли все под дерево целиком, нам надо подняться наверх.
Ну да, а при этом нам надо хранить вариант, где же позиция находится у родителя. То есть когда у нас
есть два под дерево вывода, у нас точка находится здесь, точка находится здесь, то для этой точки нам
необходимо выяснить, а где же позиция полой точки для этой точки. Чтобы без рекурсии достаться.
Это будет перебором делать.
Где-где-где? Вот тут?
А черная точка должна встать вот сюда.
Ну смотрите, давайте немножко разберем. Если мы дойдем до сюда, это значит, что мы сколько символов
прочитали? Три. То есть у нас ситуация будет С-стрелочка, А, С, Б, С-точка. Значит сколько? Один-три?
Три-три-три, это бы они прочитали еще. Эпсилон это не буква, это пустое слово. Конечно же, это пустое
слово. Мечтаем, конечно же, терминал. Теперь смотрите, вопрос, если мы вот эту вот точку,
которая у нас есть, поднимем наверх, сколько терминалов мы в данный момент прочитаем? Все,
еще три. А теперь смотрите, смотрим вот в это правило, которое у нас здесь было.
Какое? Вот теперь вот как раз к этому мы сейчас потихонечку переходим. Как склеивать эти все
истории? То есть наша цель теперь научиться склеивать эти истории. Я утверждаю, значит это
полгородство утверждает, что имея только вот эту информацию, мы можем грамотно склеивать все
переходы. И наша цель сейчас определить эти три правила. Информация, значит как, значит это
информация о том, где мы сейчас находимся в деле вывода, сколько мы разобрали до, сколько мы
разобрали сейчас, и где мы сейчас находимся именно в конкретном правиле. Да, да, да. Ну теперь нам
надо грамотно это все соединить. А дальше, когда мы увидим основную лему, которую мы будем доказывать,
индукции в обе стороны, мы как раз и сложим наш пазл. Один, значит это сколько терминалов мы
прочитали слева от этой точки вообще во всем дереве, а это сколько терминалов мы прочитали
слева от этой точки. Собственно, барочка примеров. Скажите позиции белой точки и черной точки.
4, 4, да. Значит это ситуация S стрелочка точка 4 принадлежит D4. Молодцы. Так, это мы уже закодировали,
это С стрелочка АС точка БС, один принадлежит D2. А теперь смотрите, как мы будем это все мачить.
Три операции. Значит будет три операции. Я обычно, если у меня есть цветные маркеры, а у меня нет
тут цветных мелов, к сожалению, я их обозначаю тремя разными цветами. То есть scan. Это нам
позволяется читать терминал, предикт. Будем спускаться вниз, пытаться предсказать,
по какому правилу нам надо раскрываться. И третья история, это комплит. Мы поднимаемся наверх.
Это пишется следующим образом. G это математический термин, а DG это как бы прогерский термин,
потому что мы вот эти штуки будем хранить в определенном множестве. То есть DG это на самом деле
set. То есть у нас есть переменная D, а в нем G это индекс. Итак, давайте подумаем. Если нам
надо прочитать букву А, вот в данном моменте, мы находимся в такой определенной ситуации.
Какая ситуация будет корректная после того, как мы прочтем эту букву? Я пока ищу сухую тряпку.
Да-да-да, именно так. Это описание базовых шагов алгоритма. Сейчас он появится, подождите.
Просто пока мы эти шаги не разберем, мы не сможем алгоритм построить.
Смотрите. И при этом у нас важно, что G-тое букво равняется А. То есть как бы мы смотрим на наше
слово, вот оно слово W, и вот она G-тое букво, она А. То есть мы в принципе и в текущем слове ее
можем прочитать. То есть повезло. Так что в той позиции, в которой мы находились, за следующую
букву А, которая есть. И если у нас есть такая ситуация, то при помощи операции scan и выполненной
этой условия, то мы можем перейти в ситуацию такого рода. Вот мы теперь при помощи операции scan
можем прочитать букву. Да, принимает дожитое и по факту пытается прочитать. Ну принимает множество
всех ситуаций, которые находятся на текущей позиции. То есть нам надо прочитать букву по факту.
Она берет все ситуации такого типа, проверяет может ли сдвинуть точку. И двигает точку для
всех ситуаций, в которых буква G плюс один совпала. Ну да множество всех ситуаций, да.
Да, мы храним все возможные ситуации, которые оканчиваются в джитое позиции. И дальше нам
надо будет перестраивать это множество лавинообразно. Вот смотрите, со scan вот такая история. Теперь давайте
вторую операцию рассмотрим. Оказалось все так, что у нас с вами есть не терминал, который нам
мешает продвинуться дальше. Ну а мы можем его раскрыть по какому-то правилу. Ну повезло нам
найти правила. Правил может быть несколько. Значит у нас была ситуация A стрелочка альфа
точка B бета. И принадлежит джитое. Но есть правила грамматики. Давайте подумаем какую
ситуацию мы с вами можем нарисовать. B стрелочка точка гамма. Давайте нарисую дерево.
Смотрите, точка опускается вниз. Мы добавляем такую ситуацию. Если мы стоим перед не терминалом,
и оказывается есть правило, которое может раскрывать этот не терминал. Пока нормально, да?
Так, осталось последнее. Потому что вот эта позиция это житое позиция в слове. Когда мы
спускаемся вниз, то сколько букв мы читаем? Ноль. Значит текущая позиция точки, когда мы
спустимся вниз, она будет житой. А вот эта точка мы знаем, что она кодирует житую позицию. А эта
точка стала вот такой полой точкой, поэтому это тоже житое. Отлично, разобрались. Давайте я сейчас
нарисую дерево. Оно будет трехэтажным. Смотрите, мы закончили разбирать какое-то дерево. У нас
картинка такая. Полая точка здесь, такая точка здесь. Тогда смотрите, что мы можем сделать. Мы с
вами можем понимать следующее, что у нас есть B, стрелочка гамма. О, господи, точка. Давайте обозначим
эту позицию к принадлежит дожитому. Теперь смотрите, давайте поймем, когда мы можем сдвинуть точку.
Когда у нас мы в какой-то ситуации находились перед ней терминалом B. Мы находились с вами перед
ней терминалом B. Нам надо достать правило, в котором точка находилась перед ней терминалом B.
Тот же самый. Нет, мы читаем, а дальше мы будем лупаться между вот той операцией,
вот той операцией. Живет в произвольной G, сейчас когда алгоритм откроем. Давайте отмотаемся,
как эта штука у нас была получена. У нас была ситуация, здесь была родительская точка, здесь
у нас альфа точка B бета. Здесь вот эта позиция, это позиция под индексом K, потому что позиция этой
точки под индексом K. Это то, что было до этого. Давайте закодируем эту позицию точкой некоторым
индексом И. Это значит, что из этой штуки у нас была ситуация вида, а стрелочка альфа точка B бета.
Что у нас получается? И теперь мы берем и объединяем две истории и можем двигать точку.
Сейчас, то есть мы можем, имея вот эту точку, имея вот это вот под дерево, вот имея вот эту
точку и имея закрытое правило вывода, наконец-таки сдвинуть эту точку, то есть прочитать это под
дерево целиком.
То есть имея вот такую вот такую ситуацию, мы добавляем вот такую ситуацию.
Да, да, да, именно так. Ну да, мы продвинулись, но поэтому добавляем. Да, предыдущий нельзя
убирать, она еще может понадобиться. Да, это все возможные варианты разбора. Да, да, да, да.
Да, ну ничего, мы боремся за симптонику. Вот такая картинка. Итак, у нас есть три базовых операции.
Значит, scan, predict, complete. Теперь нам надо с вами... Комплит будет принимать множество. Доставать
все ситуации, которые были здесь. К, лупаться по К. Причем искать именно те терминалы, которые
находятся в левой части правила. Точку перед левыми частями правила. Да, сейчас будет псевдокод.
Ну давайте, ладно, раз уж пьянка такая пошла, то давайте псевдокод complete напишем.
Значит, смотрите, эффективная структура хранения данных в данном случае будет следующая. Множество
будет храниться так. ДКТ от Б. Это множество всех не терминалов, которые имеют вид А. Множество всех ситуаций,
которые имеют следующий вид. А, стрелочка Альфа, точка Б бета. Да, но при этом нам, понятно,
у этой структуры данных необходимо, чтобы у нас хранился левый элемент быстро. Значит, собственно,
правила грамматики, на всякий случай, и позиция родителя. Ну да, позиция, где мы находимся в
текущем правиле. Давайте лев назовем. Так, ну поехали. Значит, нам нужно что сделать.
ДКТ, ой, completed дежитово. 4. Что нам надо сделать? Нет, на самом деле, я утверждаю, что нам
нужно пойти for. Смотрите, почему эта структура данных интересна. Доллар от конца слова. То есть
нам надо выдернуть все ситуации, в которых точка находится в конце. Тоже заводим такие. То есть это
по факту вот здесь будет храниться следующая позиция, следующий терминал или не терминал после точки.
Вот. Ну и что нам надо взять тогда? То есть fo, b, стрелочка, гамма, точка, к, ind, dj. Дальше нам
нужно обратиться с вами. Куда? Да-да-да. Да-да-да. Во. Да. То есть мы обращаемся к множеству
DKTB. Здесь дежитовый доллар, здесь DKTB. И добавляем множество дежитов. На самом деле, чтобы честно,
тут надо сделать... А? А чего? У нас вроде все маппится. Ну, if можно там, если, допустим,
у нас на этой штуке еще какой-нибудь хэшмап навешан, чтобы не добавлять лишние множества в сет.
Лишние ситуации, чтобы не добавлять. Лишние ситуации не добавляют множество дежитов. Но
собственно, djt это получается а, стрелочка, альфа. Кстати, так. Так, что нам надо добавить и? Так,
еще смотрите. Здесь бы полезно знать первую букву от b. От бета. Ну да. На всякий случай.
Все равно может что ферс Виталий введет на следующей лекции, поэтому пусть оно сейчас появится.
Все равно Виталий на следующей лекции будет вводить множество ферс. Да, ладно, да. В случае да,
а там будет это вывод первой буквы. В общем, это первый терминал или не терминал, который у нас
находится в В. Собственно, вот такой вот алгоритм. На самом деле, давайте чуть-чуть про оптимизация.
Тут надо писать дельту. Да, если это djt от ферс бета. Так, рубрика оптимизации. Значит,
поскольку первый символ, который есть у нас в бете. Но бета нулевое можно написать. Да,
просто бета может состоять из нуля символов, тогда это доллар. Да, конечно. Вот, значит,
про оптимизацию. Потому что, если вы сейчас так будете писать алгоритм, вы получите алгоритм
за четвертую степень. А у нас как бы коккянгеракасами закуп работает. Тут не djt,
тут дельта djt. То есть необходимо отслеживать изменения, которые мы добавляем в множество.
Давайте я поясню почему. Давайте чуть-чуть вперед забежим. Алгоритм просто я покажу.
Он гипотетически пытается строить дерево, всевозможные деревья вывода для префиксов нашего слова.
Значит, смотрите. Помните, как мы грамматику в нормальной форме Хомского приводили? Помните,
мы добавляли новое стартовое состояние? s'. Чтобы избавиться от s в правых частях правил.
Вот, здесь всегда добавляется правило s'. Для того, чтобы мы явно могли задать правила вывода.
То есть всегда добавляем правило это. И тогда мы точно с вами можем оттрекать,
когда у нас старт алгоритма. Старт алгоритма у нас начинается в том случае,
когда у нас есть ситуация s'. Стрелочка точка s, d0 принадлежит d0.
Стрих выводит s, точка здесь, точка здесь. Конец. Как вы думаете, успешный конец когда будет?
Ноль. Так, отлично. В общем, вот это алгоритм.
Всевдокод. Значит, d0 это множество из одной ситуации. Дальше, пока наше множество d0 изменяется,
мы выполняем комплит и предикт. Что, почему, что? Ну, мы насыщаем, мы пытаемся найти все
возможные ситуации, которые заканчиваются, не разобрав еще ни одной буквы. Ну, по сути,
шлейф будем хранить, который будет строить все возможные деревья вывода до тех пор,
пока мы не разобраем первую букву. Потому что у нас первый не терминал, может раскрываться,
раскрываться, раскрываться, раскрываться. А? Пример? Ну, окей, пример. Значит, s-штрих выводит s.
Блин, зачем я пишу? s-a-s-b, s-a-s-v. Изначально у нас в d0 лежит следующее. s-штрих стрелочка s,
точка s0, потом мы спускаемся вниз, раскрываем s-a-s-b0, потом мы еще спускаемся вниз, раскрываем эту
всю штуку вот так. То есть мы, грубо говоря, спускаемся максимально вниз по дереву вывода до
тех пор, пока мы не можем прочитать одну букву. И нам надо хранить все возможные спуски. Потом
читаем букву, повторяем те же самые действия. Смотрите, тут важно в алгоритме, что пока дожитое
меняется, мы выполняем эти стадии. Значит, кто понимает, как в этом алгоритме не напортачить и
нормально написать псевдокод, чтобы он работал не за большую асимпточку? Ну, если его алгоритм
вот так реализовать, это будет работать за пятую степень. Да, complete и predict должны возвращать
изменения. И complete и predict в новых итерациях мы должны запускать только от новых полученных
правил, от новых полученных ситуаций. Вот. Ну да, мы просто построили D0. А, вот, смотрите, вот,
смотрите, вот раз, вот два. Мы уже обошли дерево с точкой, поэтому мы должны вот эту штуку передвинуть.
Вот. Ноль. Ну да, тогда наша D0 заканчивается, мы переходим, может, туда идем. Когда мы не
можем в операция complete и predict не добавить ни одного ситуации в нашей D0? Ну да, ну давайте
попытаемся опуститься вниз, вроде опуститься вниз не сможем, закомплитить вроде тоже. А, не, подождите.
Да. Complete вот этого правила и вот этого правила. Теперь все. Да, мы разобрали D0, да, теперь дальше
если на что пустое мы победили, иначе двигаемся дальше. Мы по факту взяли и построили все деревья
вывода, все, так сказать, ситуации, в которых мы могли оказаться во всех возможных гиптических
деревьев вывода, не разобрав еще ни одной буквы. Вот. А блин, тут картинки рисовать, это уже, я не знаю,
вы умеете рисовать на двумерной доске так, чтобы была трехмерная картинка? Вот я не умею. Нет,
у нас сет деревьев выводов. Для разных возможных ситуаций. Для разных возможных ситуаций, для всех
возможных слов, которые выводят в этой грамматике, но при этом мы еще ни одну букву не разобрали.
Раз, два, три, четыре, пять ситуаций тут. Да, да, попытаться делать скан от них. Ну,
понятно, что тут только одна ситуация подойдет. Рекурсивный спуск работает далеко не для всех
грамматик. Да, еще он экспоненциальный. Да, он работает для всех грамматик, но за экспоненту.
Этого алгоритма все-таки детерминированный. Почти. Кстати, для однозначных грамматик он работает
за квадраты длины. Круто. А теперь физический смысл в математических терминах. Собственно,
это основная лемма алгоритма Эрли, которая, если вы не поняли то, что я пытался донести в картинках,
вот вам, собственно, то, что это формулируется. Давайте я выпишу эту лему, потому что...
Так, коричительные напитки пошли. Значит, что там у нас? Можете продиктовать.
Альфа выводит.
Кстати, тут сразу скажу, что G включено. И тоже включено. А, не, подождите.
Плохо. Тогда, ну по факту, черт, ладно, сейчас будем переписывать. Смотрите, в общем,
идея такая, что мы с вами берем, разбираем все, что у нас было до этого слова. А, С. И дальше
мы за один шаг берем и раскрываем эту ситуацию. Теперь в дереве. То есть, если у нас встретилась
такая ситуация в алгоритме Эрли, она могла встретиться тогда и только тогда, когда у нас
существует замечательное вот такое дерево вывода. Что у нас здесь выводится слово от нуля до итого.
Дальше у нас есть АПСИ, которое за один шаг раскрывается, значит, по альфа бета, а потом из альфы
выводится слово с итого до итого. Так, секунду. Ну давайте подумаем. Мне кажется, если говорить
в честных питоновских определениях, то тут надо писать I-1 и G-1. В смысле? Ну смотрите,
по факту вот здесь позиция родительской точки, а здесь позиция нашей точки. Это перевод картинки.
То есть, здесь столько, сколько мы разобрали до родительской точки. Это позиция слова с нулевого
до итого. То есть, сколько букв мы разобрали. А, стоп, у нас ноль нумераций, я дебилу кусок. Ну,
вы же знаете, кто у нас лектор. Так, а здесь мы разобрали G-букв. Все, ура. Так, ну в общем. Так,
это лемма, на самом деле, одна из самых сложных лемм, которые я буду доказывать в курсе. Собственно,
угадайте, в какую сторону сложнее? Слева направо или справа налево? Справа налево намного сложнее.
Что, вы хотите слева направо или справа налево? Доказывать будем. Ладно, давайте пожалеем.
Начало докажем слева направо. Слева направо это индукция по количеству шагов алгоритма.
База какая? Так, мне кажется, надо мне выписать все шаги. Значит, тут уже математика, поэтому давайте
выпишем все шаги, которые у нас есть. Значит, scan это у нас, если у нас есть ситуация alpha точка a
beta i принадлежит dg, то из этого мы делаем с вами alpha стрелочка alpha a точка beta i принадлежит dg
плюс один. Предикт. У нас a стрелочка alpha точка b beta i принадлежит dg, есть b стрелочка гамма,
принадлежащая правилам грамматики, то мы из этого получаем b стрелочка точка гамма, g принадлежит dg тому и complete
Господи, b стрелочка гамма точка k принадлежит dg тому, a стрелочка alpha точка b beta i принадлежит dk тому,
то мы можем двигать точку. Так, ну поехали, значит база. За сколько шагов? В первом шаге что мы делаем?
На первом шаге у нас добавляем ситуацию a стрих стрелочка точка s.
Че нам надо подобрать вот такую вот цепочку. Так, ну давайте выводить.
V00 s штрих phi, ну тут просто s штрих, да, то есть в нашем случае получается psi будет равно
и дальше за один шаг что мы выводим с вами? Эпсилон, вот этот эпсилон переходит в этот эпсилон,
дальше мы выводим v00 s. Вот, ну собственно вот эта штука у нас эпсилон s и она нам кодирует как раз
необходимую ситуацию. То есть мы просто расписали вывод s штрих выводит s в тербинах вот этой штуки.
Вот это понятно? Ага, хорошо. Ну переходы будут такие, Миша, приблизительно. Ну переходы,
значит какие у нас три стадия алгоритма могут быть? Давайте рассмотрим что происходит при скане.
Давайте я наверное на отдельной доске буду писать, потому что я не хочу мельчить.
Ну берем, короче, считаем, что каждый шаг алгоритма, каждая строчка алгоритма,
которая мы исполнили при добавлении чего-то в джитово, это эффективный шаг в алгоритме.
То есть как только какое-то множество мы что-то добавляем, это эффективный шаг.
Так, переход. Значит, смотрите, у нас было правило, мы находились с вами в ситуации вот такой,
а стрелочком альфа точка а бета и принадлежит джитому. Что это значит? По предположению индукции
у нас есть такая цепочка вывода. Значит, мы из а штрих выводим в нолито, дальше верхнюю часть
а, пси, дальше за один шаг мы выводим в нолито альфа точка а бета, так а, бета, так пси. При этом у
нас, смотрите, из альфы будет выводиться слово ситово по-житому. Ага, а тогда скажите мне,
что выводится из альфа а? Какое слово выводится? Ага, потому что у нас буква совпадает. Вот,
а это значит, что мы в принципе за один шаг с вами альфа и бета. И вот это вот слово уже выводит
джит плюс один. То есть мы по факту двинули точку. Да, если мы сейчас обозначим альфа штрих альфа
а, то у нас индукционный переход выполнится. То есть вот это заменяем на альфа штрих и смотрим на
индукционную картинку. Понятно, как делается шаг? Да, это мы сделаем скан. Это просто тут небольшое
переобозначение. Давайте сделаем предикт комплит. Итак, предикт. У нас с вами было правило
альфа точка б бета. Так, смотрите, давайте писать. Значит, что у нас есть? У нас из С. Есть вывод
в 0 и т, а пси. Дальше за один шаг мы выводим с вами что? В 0 и т альфа б бета пси. При этом альфа у нас
выводит слово в и ж. Давайте я тут вот это вот перенесу. Теперь, смотрите, сделаем финтушами. Мы
понимаем с вами, что альфа выводит в и ж. Поэтому здесь мы можем заменить в 0 и т. Здесь мы пишем
б бета пси. А теперь давайте сделаем еще один шаг вывода в этой штуке и раскроем не терминал b.
В 0 и т. Вот здесь вот у нас будет в и ж и т, которое нам необходимо будет. Здесь будет гамма бета пси.
Вот это мы с вами обозначаем как пси штрих. Да, и получаем. Смотрите, у нас из b выводится гамма.
Та позиция, которая у нас была с точкой точкой находится здесь. А мы хотим, у нас из предикта,
что получается? Что b это стрелочка точка гамма, ж принадлежит джи. То есть у нас добавляется эта
штука. Ну здесь она и добавляется. То есть смотрите, получается до b мы разобрали g позиции. Перед гаммой мы
тоже разобрали g позиции. Вот, поэтому то, что мы хотим в лемме индукционный переход для предикта
тоже выполнен. Ага, или не ага? Не, а? Понятен ли этот этот шаг как расписан? То есть мы из
мы сделали следующее. Мы явно раскрыли b и альфу вывели. Мы узнаем, что из альфы выводит w и gt
по предположению индукции, потому как у нас инвариант сохраняется. Получается v0 и v и gt
получаем v0 gt. Вот, а дальше за один шаг вот как раз вот этот вот b за один шаг раскрывает гамму,
добавляя w gt. Собственно, что нам требовалось в инварианте? То есть как только наш не
терминал, который в левой части ситуации находится, раскрывается, то из того, что находится за точки,
выводится в позиции сытого до житого. Наш стучит в позиции с житого до житого.
Здесь? Альфа штрих эпсилон, а бета штрих это гамма.
А теперь, как говорится, Кракен подберите рифму сами.
Комплит. Так, значит у нас есть ситуация. А стрелочка, альфа точка б бета и принадлежит
до катому и бета стрелочка гамма точка катая принадлежит до житому. Давайте напишем для вот
этой штуки предположение индукции. Значит, для вот этой штуки шагов-то меньше было. Мы получаем
следующее, что у нас из с выводится в нулевое и, потом у нас выводится а, потом выводится у
нас какой-то фи, потом за один шаг у нас выводится из в нулевого и, альфа у нас раскрывается как альфа
б, альфа б бета, си. А при этом, смотрите дальше, что происходит. Дальше нам надо твинуть точку за
не терминал b. Ну, смотрите, что мы понимаем, что в тот момент, когда мы с вами раскроем бета за
один шаг. Давайте напишу в нулевое и т. Значит, альфа у нас раскрывается во что? Альфа у нас это
w и kt, b бета, си. Да, а b из вот этой штуки. Если внимательно посмотреть, у нас из бета,
как только мы раскрыли бету, то у нас из гаммы будет выводиться символ с катова пожитого.
Да, это из предположения индукции будет. Ага, а это значит, что из бета выводится символ с катова
пожитого. Ну и получается, что альфа бета у нас выводит символ с этого пожитого. То есть,
в нашем случае альфа штрих будет равно альфа бета, бета штрих будет равняется бета. И, собственно,
у нас появляется правило. Тут давайте напишу. А, стрелочка альфа, б, точка бета. И принадлежит
дожитая. Ну, собственно, оно и появляется. То есть, у нас все, что было от нулевого до итого,
мы раскрыли. Потом альфа штрих, который у нас альфа бета, получается, выводит с итого пожитого,
и точка встает сюда. Где? Альфа б. Альфа выводит с итого до катого, б выводит с катого пожитого.
Что, сошлось? Мне кажется, все в ауте. Тонкая манипуляция с теми фактами, которые у нас
получаются. То есть, здесь главное, значит, все, что до точки, у нас на самом деле будет
выводить символы скатого дожитого. Вот. Собственно, раскрываем эту штуку. Поскольку у нас бета выводит
гамма с точкой, то бета выводит то же самое правило. Значит, бета может вывести дв скатого
поджитого. Подставляем сюда, получаем. Собственно, из того, что альфа выводит еще тут. Это у нас по
предположению. Конкатенируем это, получаем альфа, выводит w и т ж т. Это переход в одну сторону.
Я боюсь, товарищи. Давайте соберемся с силами. Это была простая часть.
Индукция по трем параметрам. Давайте я добавлю здесь некоторые индексы. Значит, смотрите, первая
индукция это по параметру g. При равенстве g мы смотрим на суммарное количество выводов,
которые у нас есть вот здесь и вот здесь. То есть смотрите, индукция по параметру g,
по параметру k плюс l, то есть сумма длин вывода из альфы и из к. И если эта штука равняется,
то мы смотрим на третий параметр l. Да, сколько шагов и с левой части правила нам
понадобится для того, чтобы его раскрыть в слово.
База. Нам надо найти ситуацию. Помогите.
Смотрели мультик? Дора-путешественница. На русский язык переводится Даша-путешественница.
Оригинал Дора. Скорее всего, на английском.
Так, k равно 0, l равно 0. Так, ну давайте смотреть. Давайте поймем, что мы можем вывести за ноль
шагов. За ноль шагов что мы вводим? s-штрих. Дальше за один шаг мы должны раскрыть этот s-штрих.
Как мы можем раскрыть этот s-штрих за один шаг? Только в s. А дальше что нам надо сделать?
Так, секунду. Нам надо из альфы тоже за ноль шагов что-то раскрыть. Что за ноль шагов у
нас из альфа раскрывается? Пустое слово. То есть то, что стоит перед s. В нашем случае альфа равно
пустое слово. И тогда какая ситуация у нас должна была возникнуть из этого?
Можешь сообразить? Давайте подставлять. a равно s-штрих, альфа это эпсилон,
а бета это у нас с. То есть у нас должно было появиться правило s-штрих.s0 принадлежит данной.
То есть g равно нулю и тоже будет равняться нулею. А такая ситуация у нас есть? Да,
мы с нее начинали. Так, базу доказали. Переход. Надо рассмотреть несколько случаев. Давайте
рассмотрим последний символ не терминала a. Последний символ альфы. Давайте сейчас я
проговорю сначала. Тут три случая возможны. Какие? Буква, не буква и эпсилон.
Так, последний терминал альфы.
Давайте рассмотрим первый случай. Альфа равно альфа-штрих b. Нагадываетесь какое у нас правило
будет? Да, тут должен появиться скан. Ну, давайте смотреть. Значит, у нас получается из s-штрих,
то давайте, наверное, деревьями рисовать. Потому что деревьями это вообще офигенно.
У слайдов есть деревья. Смотрите. Вот так вот. Смотрите. Из альфы-штрих у нас выводится
v и g-1. А выжитая буква значит символ b. И тогда у нас получается следующее, что у нас из s-штрих
выводится альфа-штрих b бета-пси. То есть, смотрите, у нас мы знаем, что из альфы выводилось символ
ситого до житого. Альфа равно альфа-штрих b. Следовательно, альфа-штрих выводил w и g-1, а b равно
выжитая. А тогда давайте посчитаем просто аккуратненько, за сколько количество шагов мы
выводили ту или иную вещь. Значит, смотрите. Из s-штрих, за те же k шагов, мы выводили v0 и t,
аpsi. За один шаг мы вывели что? Альфа-штрих b бета-пси. Ну и понятно, что на самом деле из альфы-штрих,
за то же самое количество шагов, мы вывели слово v и t g-1, потому что у нас ни в какие-нибудь
терминалы не открываются. А теперь смотрите. У нас получается, что альфа-штрих выводило слово
c и по g-1. Значит, в нашем дереве v0 и t за 1 шаг. Здесь количество шагов меньше. В итоге нам
надо индукцию перевести для параметра g-1, k плюс l и k, k плюс l и l. Но для такого параметра индукция у нас верна.
Да ведь? Ну мы индукцию сначала по параметру g делаем, потом по меньшему параметру. И в итоге
получается, что, оказывается, из этого у нас была ситуация следующего рода, что из а мы, это
предположение индукции, выводим альфа-точка b бета и принадлежит даже минус 1. Только мы делим
эту часть на вот этот составляющий и вот этот составляющий. Ну а значит, наше правило, которое
мы хотим показать. Как вот это правило тогда появляется у нас с вами? Если у нас есть вот эта
ситуация и gt буква у нас b. Альфа-штрих. Значит, как это правило у нас могло появиться? Новое. Значит,
применяя скан, мы получаем альфа-стрелочка альфа-бета-штрих бета-точка бета и принадлежит дожитое. А вот это как
раз наша альфа. Так, понятна идея? Хорошо. Давайте следующий переход я нарисую на
картинке, потому что иначе мы с вами будем очень-очень долго. Вот картинка. Значит, у нас из a-штрих за
k шагов вывелось gt. Если что, мы рассматриваем в случае альфа-штрих равно альфа-бета. Альфа равно альфа-штрих
бета. Апси. И дальше за один шаг мы смотрим, что такое альфа-штрих b-бета. А теперь смотрите
чудеса. Мы понимаем с вами, что альфа-бета-штрих альфа-штрих бета за какое-то количество шагов k,
за l шагов у нас выводит слово с итовопожитой. И теперь рубрика арифметика. Предположим,
что у нас бета за один шаг выводит гамму. И мы закрываем это правилом. И теперь считаем,
пусть вот эта штука за t раз у нас закрыла. Мы режем эту штуку пополам, получаем w. Сколько у
нас получается с итово по м? Давайте считать количество шагов. В сумме вот здесь у нас должно
быть l шагов. Значит здесь шагов l-t-1. Вmgt. Теперь смотрите. К сожалению, у меня нет цветных мелков,
но тут надо заметить две картинки. Я их покажу двумя разными цветами. Смотрите, первая картинка,
которую нам надо заметить, это вот этот вот вывод. И вот этот вот вывод. Для пары, смотрите,
для пары g. Количество выводов здесь k плюс t и t. t меньше l, потому что здесь как минимум один
шаг вывода есть. Мы получаем s штрих, ой, что из a выводится, что у нас выводится,
а стрелочка, альфа штрих, точка b бета и принадлежит dmt. Потому что для вывода под вот
этого вот подшага, для этого не терминала, нам потребуется в сумме меньше шагов. С другой стороны,
вторая картинка. Тут внимательно, надо внимательно очень посмотреть. Давайте я их волнистой чертой обведу,
либо обведу к крышке. Смотрите, давайте рассмотрим вот эту вещь и вот эту вещь. То есть как из этой
штуки выводился этот кусок, а из этой штуки выводился первый кусок. Количество шагов здесь
будет g. Считаем, значит k плюс t плюс l минус t минус 1 и плюс 1. Вот это? Смотрите, мы выводим альфа
штрих только. Раскрываем только альфа штрих. Альфа штрих мы выводим за t шагов. Эту штуку мы выводим
за k шагов. Значит сумма k плюс l в том случае, если мы рассматриваем вывод в альфа штрих,
их будет количество k плюс t. Ну и третье, это сколько мы из этой штуки выводим, это t.
Согласен. Согласен, да, m. Вот так, да. Ну либо m меньше k, либо m меньше j, либо, собственно,
по второму параметру мы делаем инакционный переход. Спасибо за замечание. А здесь надо считать,
то есть смотрите, здесь k, здесь t, здесь вот эта вот единичка, потому что она теперь включается
в наш подвывод. Вот. И здесь l минус t минус 1. То есть смотрите, здесь у нас получается k плюс l,
то есть мы не боремся с нашим вторым параметром, но третий параметр становится меньше. И из этого у нас
получается, что альфа, что бета, стрелочка гамма точка, м принадлежит дожитой. Ну а значит,
наши правила получились по комплиту.
Третье, да? Значит, смотрите, мы рассматриваем вот это под дерево, то, что мы выводим до не
терминала b, здесь. А вот это то, что после гаммы выводим. Да-да, после гаммы. Но мы же хотим завязать
эту всю штуку на гамме и на b. То есть нам надо рассмотреть, за сколько шагов мы все вывели до b,
и за сколько шагов мы из гаммы что-то выводили. Ну, чтобы точку после нее поставить. Вот. Ну и считаем.
Значит, здесь мы, количество шагов у нас l минус t минус 1, а здесь k плюс 1 плюс получается t и плюс
только здесь. Это понятно? Стало понятнее, откуда? Что третье? А, это количество шагов вывода из
не терминала, который стоит, из последствий, которые стоит с левой точки. А в нашем случае это гамма.
Ну, если мы хотим получить правило b стрелочка гамма точка, то надо посмотреть,
за сколько шагов мы из гаммы что-то вывели. Так. Третий случай. Альфа штрих это эпсел.
Тогда, если у нас альфа штрих это эпсел. Точнее, альфа это эпсел. Тут опечатка. Тогда у нас i равно g,
и l равно 0. Альфа равно эпсел. Значит, если мы из альфа что-то попытаемся вывести до
w и gt за l шагов, это значит, что i равно g и l равно 0. Да? А теперь давайте посмотрим,
как это альфа появилась. Кто его породил? Собственно, у нас была такая картинка.
0,0i, а,psi. За один шаг мы получили на самом деле какой-то терминал бета. Точка мы предполагаем
будет здесь. А теперь, смотрите, давайте посмотрим, как получился альфа. Как получился
а. На самом деле он появился из какого-то терминала бета. Если мы с вами сейчас посмотрим,
как из этого терминала появился бета. Фиксуем тот момент, когда он появился. Тогда у нас тут гамма,
а, дельта. Значит, из а мы за один шаг получаем бету. И теперь надо считать. Считать-считать
очень долго. Это значит, если мы делаем s штрих, дальше мы делаем следующее. Значит,
здесь мы вводим какой-то c штрих, а здесь мы должны сделать разбивку нашего слова. То есть,
вот эта совокупность, вот эта совокупность у нас должна вывести слово с нулевого по итой,
то есть поджитой. Значит, гамма у нас тоже за какое-то число шагов выводит слово с этого пожитой.
Давайте считать. Мы с вами что понимаем? Мы с вами понимаем, что вот эту цепь мы выводим
в сумме за k шагов. Вот это плюс вот это плюс вот это. Значит, если мы это выводим за t шагов,
то вот эту цепь мы выводим за k-1-t шаг. Так, ну что? Давайте смотреть. Теперь нам надо как-то
понять, что у нас тут хорошо. Давайте рассмотрим как раз. У нас из гаммы выводится,
за сколько шагов? За t шагов у нас выводится w и jt. Значит, здесь гамма. Ой, здесь ставим t.
Дальше смотрите, что здесь индекс у нас будет, если мы обрубаем по вот этой истории, по вот этой
истории, то здесь у нас индекс p. p при этом может быть не больше, чем g. А здесь смотрите,
суммарно количество правил вывода из этой штуки b, из этой штуки будет k-1-t плюс t. То есть это k-1.
И в итоге у нас для тройки p k-1t мы можем написать следующее, что из b выводится гамма точка a дельта,
она у нас была, p принадлежит дожитому. И у нас есть правило a стрелочка бета. Это значит,
что наше правило a стрелочка точка бета могла появиться по правилу, получается какому? По
правилу предикта. То есть еще раз, идея доказательства такая, что мы аккуратненько смотрим,
как в нашем интерминале альфа какой был предпоследний шаг. Попытается понять,
какой терминал мы до этого прямо раскрыли. Может быть три случая, если у нас эта буква,
мы работаем по скану, если мы перепрыгнули не терминал, это скорее всего у нас
комплит, а если у нас слово было пустое, то это предикт. И мы просто явно сидим и по деревьям это
вытаскиваем. Вот. Кажется, я всех ухакошил. А теперь смотрите, финиш. Да, к сожалению,
мы не сможем доказать асимптотику, но когда алгоритм будет написан за четвертую степень,
вам по башке настучат на практикуме. Короче, если вы напишете алгоритм за четвертую степень,
псевдокодом и не будете хранить множество дельта переходов, то есть тех ситуаций,
которые добавляются на текущий момент, то вам скажут переписать, потому что это неэффективный
алгоритм. А симптотика это алгоритма Куб. Но сильно меньше константы, чем алгоритмы Кока-Янгера-Касами.
А для однозначной грамматики симптотика квадрат. Тоже квадрат. Итак, давайте в конце посмотрим,
что же у нас получается. Мы говорили с вами следующее, что у нас слово лежит в грамматике.
Смотрите, мы говорили, что вин у нас когда и только тогда, когда у нас есть вот такая ситуация.
Да? Вы с вами же сказали так? Слово лежит в языке. Теперь надо доказать это. Так,
теперь пишем это, что это значит. Это значит, что из штрих мы за какое-то количество шагов
вывели слово с нулевого по нулевой. Вывели первую часть. Это что у нас? s штрих,
psi. Но это по факту у нас пустое слово, мы с вами догадываемся. Дальше. Что получается? За один шаг
мы выводим слово с нулевого по иты, с нулевого по нулевой. Дальше у нас какая-то непонятная
альфа возникает. Ну, точнее, мы понимаем, что это за альфа. У нас выскакивает здесь не терминал s.
Здесь по факту у нас точка, которую мы раскроем psi. И теперь получается следующее, что у нас из s,
из нашей штуки, из нашей леммы мы выводим слово w в индексах с нулевого подлинно слово w. А это
что у нас такое? То есть это верно тогда и только тогда. А это верно тогда и только тогда, когда что?
Да, слово лежит в языке задаваемой данной грамматикой.
Вот. Значит, смотрите, если интересно будет посмотреть, тут есть доказательства того,
как это считать. Мы это не будем просить, но асимптотика, смотрите какая. Асимптотика,
тут каждых шагов можно оценить. В общем, асимптотика длина от слова грамматики в кубе на количество
суммарных правых частей, суммарное количество не терминалов и терминалов, которые встречаются
во всех правилах в квадрате. Для однозначных, это длина слова в квадрате на g квадрат.
Нет, это суммарно по всем. На одну операцию, на одну операцию для конкретного g надо поделить на
длину слова w. Вот, но поскольку у нас с вами есть эффективная реализация, то это можно
сесть аккуратно, посчитать амортизованным анализом. Я думаю, что мы поступим следующим образом,
что если вдруг у вас попадется на экзамене билет с алгоритмом Эрли, то там будет процедура экзамена
такая, что в качестве задачи на отл-8, потому что у нас система будет шкалированная, то есть там
как на каокли, вы видели, то есть до 7 мы решаем какие-то базовые типовые задачи, отвечаем на билет,
дальше на отл начинаем решать задачи. Так вот, будет такой вопрос, что если вдруг вам попадется
билет с алгоритмом Эрли, то можно будет доказать асимптотику и перепрыгнуть с 7 на 8.
