Все, всем привет! Сегодня мы продолжаем и заканчиваем говорить закуду. Может быть потом еще что-нибудь поговорим на каких-нибудь семинарах или дополнительных историях.
Но сегодня будет у нас самая математическая лекция. То есть то, что мы читали пропускные способности сетей, вот это вот все, это был детский сад, ромашка.
Сегодня будет рум-математика. И сегодня мы будем решать две задачи. Первая задача это редакшн. То есть мы будем что-то с вами вычислять в какую-то общую копилку.
И вторая задача это задача сканирования. Вот. Так, сейчас. Ты листать будешь? Вот.
Значит, план. Решить задачу редакшн, дать формулировку задачи редакшн, дать формулировку задачи сканирования. После этого решить задачу фильтрации, реализовать функцию фильтр.
Знаете, что в питоне функция фильтр делает?
Ну, наверное, знаете. Или нет? Нет? Ладно.
Так. Она делает следующее. Я забыл, где у нее итеры, куда у нее итеры болтаются.
Я не знаю.
Как вы думаете, что она сделает?
Ну, создать генератор, который будет выкидывать числа 1 и 3. То есть вы передаете лямбда функцию, которая...
Вообще какую-то функцию, относительно которой возвращает true либо false, и вам нужно оставить только те объекты, у которых значение условия true.
Вот. Это функция фильтр. Вот. И потом мы с промышлением этой всей истории реализуем quicksort.
Да. В общем, может быть, не эффективно реализуем, но реализуем. Вот. Это наш план.
И в конце, может быть, еще немножко поговорим вообще про то, какие библиотеки бывают для работы с кудой,
потому что многое из чего, что есть и можно реализовать на видеокарте, обычному разработчику не реализовать.
Вот. Поэтому это спрятанный набор библиотек.
Итак. Задача редакшн. У нас есть массив, нам надо посчитать в нем сумму элементов.
Вот. Вопрос. Вот. У нас есть классическое решение. Мы делаем n операции по регистрам.
Ну что, мы пишем обычный for, да? Я не знаю.
Не привычно мне код писать на доске, но, в общем, обычное сложение это элемент массива.
Вот. В общем, мы делаем n операции по регистрам.
Ну что, мы пишем обычный for, да? Я не знаю.
Ну, можно, да. Вот. В общем, что у нас получается? У нас с вами n операции.
Сколько потоков они исполняются у нас? Один.
Так. Умные люди говорят, что так лучше не делать.
Как можно сделать умнее, если у нас есть с вами ap параллельно исполняемых потоков?
А, ну это уже совсем умное решение. Это, видимо, на семинаре, что ли, уже рассказали?
А, понятно. Да, немножко спеллернули. Вот.
Давайте тупое решение с учетом того, что мы еще не знаем продвинутого решения.
Тоже можно. Да. То есть у нас есть p количество потоков.
Можно сделать так. Первое решение. Это взять, вообще тупо массив на p-части поделить,
в каждом из них сложить, а потом сделать общий результат. Это на каком темпе, на каком темпу на p делается.
Вот. Но на видеокарте это будет работать слишком медленно.
Я не знаю. Я по крайней мере своей группе показывал на семинаре, что это будет очень медленно работать.
Я не знаю, у других показывали, почему так работает сильно медленнее.
Нет, ну короче смотри. Давай я тебе скажу, где это смотреть.
Да, да, ну конечно. Так, сейчас.
Там просто, правда, бардак?
Ну что там, сильный бардак?
Нормааас.
Кто сможет сделать, можно законтрибьютить это, сделать оглавляшку. Я буду благодарен.
Так. Где это? Вот. Вот. Вот это вот пример.
Классический. Я не знаю, видно или нет.
Короче, это реализован нормально, стипетет реализован фигово.
Стипетет, по сути, суммулированное вычисление элементов последнего.
Почему это плохо? Потому что это кашли не ломает.
Которое мы с вами в прошлый раз говорили.
Да, вот. Поэтому это бет с Алешей.
Второе решение, которое предлагает, это попытаться складывать элементы с шагом каким-то.
То есть, один поток будет заниматься сложением нулевого, 32-го, 64-го элемента и так далее.
Первый поток будет складывать, первый, там, не знаю, третий и так далее.
Ну и потом, ой, 33-й. И потом они все дружно сложат.
Можно сделать так, но мы тут тоже лимитированы.
К сожалению, но это один из способов предобработки.
Здесь у нас что получается? Какое количество операций?
Да, P плюс N делить на P.
Вот. Ну в чем минус этого подхода?
Смотрите. Давайте посчитаем.
N у нас порядка 10 в 9. Если у нас N порядка 10 в 9,
а P порядка, я не знаю, сколько?
Ну давайте 4 на 10 в кубе. Ну это количество кудов потоков.
Сколько это получается у нас с вами?
Ну, смотрите, тут операции немножко неодинаковые.
Потому что если вот это мы можем сделать где?
С вами.
На ЦПУ, на ГПУ.
Да, мы, в принципе, на ГПУ можем сделать там.
Но если мы будем делать где?
На ЦПУ, на ГПУ.
Да, мы, в принципе, на ГПУ можем сделать там.
Сделать форик, да.
И еще, особенность этого подхода, это первое.
То вот это мы на чем делаем?
Ну, мы сложили в каждом из этих подблоков.
Да, получились, потом надо посложить, складывать.
Да, на ЦПУ.
Пока мы можем, но пока не можем.
Не, не можем, потому что пока не научились.
Так, а теперь смотрите, еще в чем подвох.
Тут нечистая константа П будет.
Потому что эффективно распараллеливать в П раз мы не умеем.
Опять же вспоминаем структуру видеокарты.
Если бы мы хотели бы это написать, да, то что у нас получается?
For int и равно нулю и меньше, чем блок size и погнали, да?
У нас есть ограничение на размер блока.
У нас внутри блока выполняются не все операции единовременно.
А только варпы.
То есть у нас не получится ровно N делить на P слагаемых в результате.
Понимаете почему?
Блок size максимально где-то 10 в кубе, да?
Блок size максимально 10 в кубе.
1024.
Теперь смотрите, в чем прикол.
Прикол заключается в том, что...
На самом деле мы, если напишем реализацию на видеокарте,
то мы получим здесь не константу П.
Мы здесь получим величину блок size.
Блок size умножен на количество стриминг мотивроцессоров.
Товарищи, почему это так?
Напоминаю, что P это у нас...
где-то приблизительно 64 умножек на количество стриминг мотивроцессоров.
Да, это курт попугая.
Почему здесь такая штука произойдет?
Ну, за обработку...
Там в стриминг мотивроцессоре лежит несколько варпов на эксплуатации.
И у нас есть еще одна штука.
И у нас есть еще одна штука.
И у нас есть еще одна штука.
И у нас есть еще одна штука.
За обработку...
Там в стриминг мотивроцессоре лежит несколько варпов на исполнении.
Ну да, два варпа в каждом 32.
Давайте такую спеку возьмем.
Почему именно так?
Напоминаю, почему это так.
Потому что вот это у нас, это физическое представление.
А вот это у нас какое?
Представление?
Ну, логическое.
Во!
Не, мы, конечно, эту штуку можем выровнять.
Но тогда нам нужно указывать блок size64.
Это раз.
Ну то есть, если мы укажем блок size не 1024, а 64, в принципе, это мы можем сделать.
Ну то есть, если мы укажем блок size64, не 1024, а 64, в принципе, это мы можем сделать.
Да, тогда у нас эти чиселки сравняются.
Ну согласны, да?
Ну да, типа блок size мы сами можем устанавливать.
Вот. Но в чем проблема возникает?
Проблема возникает в том,
что нам чтобы это еще эффективно реализовывать.
Нам нужно во втором параметре ядра явно передавать количество стрелк-антипроцессоров.
Нам нужно во втором параметре ядра явно передавать количество стрелк-антипроцессоров.
чтобы это все максимально эффективно реализовывалось.
Вот.
Если не думая, вообще в тупую не думая,
вообще в тупую, не думая, и отдать все по автоматике,
то у нас количество операций будет немножечко больше.
У нас количество операций будет...
Сколько?
Давайте 1024 умножить...
Стреминг метеопроцессоров сколько у нас?
Я положил.
По автомату 64, поделите у нас, а не 64.
Да, ну где-то 64.
А эта константа у нас с вами не меняется.
Да, кажется, она у нас не меняется.
И уже получается немножечко неприятно.
Мы что-то ошиблись так, с процентов на 20.
А?
Ну, все равно.
А, еще я учитываю, что у нас есть накладные расходы,
которые нам нужны для сложения.
Это скопировать, перекопировать.
Сами знаете, что копирование данных у нас занимает до 90% времени.
Да, то есть это еще...
На 9 перемножить, вот тогда получим эффективную цифру.
Так, ну хорошо.
Тогда вопрос, а что же с этим делать?
Ну, идея такая, давайте вот эту операцию попытаемся максимально реализовать эффективно на ГПУ.
То есть этот ЦПУ заменить на ГПУ.
Наша задача сегодня, это научиться читать сумму чисел в блоке.
Понять, за сколько это можно эффективно сделать.
Угу.
Ну вот, то есть если сумма не влияет на сумму чисел?
Да, да.
То есть у нас получается, что сейчас сумма считается поблочно.
Да, вот в той абстракции.
Поэтому нам нужно считать сумму по блокам.
То есть мы для каждого блока можем посчитать сумму значений внутри этого блока.
Да.
А дальше попробовать это каким-то образом агрегировать.
А размер блока у нас 1024?
Нет, размер блока у нас 1024 будет.
А где 1024?
Ну, ну можно 64, но типа обычно ставят побольше.
Ну типа это эффективнее будет.
Вот, параллельное решение на ЦПУ, оно типа вот такое, оно более простое.
На ГПУ вопрос, ну типа, опять же мы обсудили, что нельзя получить и наделить на С.
Поэтому, смотрите, давайте поймем, за сколько мы можем обработать каждый блок по времени.
Вот, утверждение такое, как тут Байер говорил, надо складывать все пирамидкой.
Вот, вы смотрите, предположение, блок size у нас является размером двойки.
Да, мы его задаем.
Поэтому мы можем начать складывать вот таким вот образом.
То есть берем значение, которое у нас есть.
Берем и говорим, что нулевой трет будет заниматься сложением чисел 0,1.
Второй трет будет заниматься вторым и третьим и так далее.
В итоге после первой операции, которая по сути делается за одну, за один логический такт,
на физических тактах там будет чутка побольше, мы вычисляем сумму по два.
На следующей итерации мы вычисляем сумму по четыре.
Взяв значение суммы, которая у нас находится в нулевом потоке и во втором потоке.
Потом нулевой четвертой суммы по четыре получаем восемь и так далее.
Пирамидкой.
Ну, мы не используем ничетные блоки, но сейчас обсудим как раз это тоже интересная особенность.
А, ну да, но они простаивают.
Как вы думаете, это эффективно?
Нет.
Хороший вопрос про ничетные блоки, за счет этого как раз возникает неэффективность.
Давайте поймем, почему эта операция выполняется за n делить на... так.
Каждый блок можно обработать за...
Чего кажется, константа какая-то другая.
За алгорифм от размера блока точно.
Да.
Давайте я поправлю константу.
Это количество итераций алгоритма.
Каждый такт за сколько исполняется?
1 цикл 4.
Ну да, но учитывайте, что у нас блок состоит из нескольких ворпов.
Да, то есть это...
Каждая операция
будет выполняться за...
Одна итерация.
Ворпсайз.
Что?
VS это ворпсайз.
Ворпсайз.
Ворпсайз.
Ворпсайз.
Что?
VS это ворпсайз.
То есть у нас блок делится несколько ворпов.
Да, и каждый ворп выполняется за один такт времени.
А нам нужно пройти по размеру всему блока.
По всему блоку.
В одном ворпе все потоки работают одновременно.
А в блоке ворпы работают последовательно.
Ну давайте еще честно...
На самом деле надо на количество ворпшедулеров помножить.
Вот такая формула на самом деле.
Потому что у нас два ворпа могут работать параллельно внутри одного.
А?
Ну да, это ворпсайз называется.
Так.
Это вот если в тупую реализовывать, а это реализовываться в тупую.
Давайте экономить.
Смотрите.
Как реализовывать?
Можно делать так.
Реализовывать так, как на картинке указано, что 0-ой, 2-ой, 4-ой поток, 8-ой, 6-ой, 8-ой и так далее отвечают сложению.
А можно сделать так, как предложила София.
Эти воспользуемся нечетными нитрацами.
То есть у нас получается, 0-ой поток будет заниматься сложением 0-ого и 1-ого.
1-ой поток будет заниматься сложением 2-ого и 3-его.
2-ой поток занимается сложением 4-ого и 5-ого и так далее.
Как вы думаете, что быстрее будет работать?
Да, да.
Да, во второе будет кошмидсу, да.
Ну, вообще думаем, но оно не будет играть существенную роль в этой задаче.
Ну вот, смотрите.
Давайте посчитаем.
Вопрос, который я хочу задать.
Представим, что размер блока 256.
В первой операции сколько варпов у нас будет работать?
За сколько варпов мы посчитаем первый элемент?
Нет, количество варпов именно.
Нет, почему два?
Да, варпсайд 32, размер блока 256.
Ну, смотрите.
У нас за первую итерацию вычисляются элементы 0-ой.
Берется 0-ой поток, 2-ой поток, 4-ой поток, 6-ой поток.
Так далее.
254-ый поток.
Первый варп, это потоки с 0-ого по 31-ый.
Это один.
Да, все варпы будут работать.
32, 63. Это второй варп.
И получается последний.
Давайте я сделаю так.
256-32, 255.
Это 8. Итого 8 варпов будут работать за эту итерацию.
Ну, что в каждом куске из 32 подряд идущих потоков
существует как минимум один, который работает.
Это значит, что у нас варп точно работает.
Просто у него половину потоков простаивает.
Неэффективно.
Согласна. Что-то все работает.
На первой итерации 8.
На второй итерации, кстати, вопрос, сколько будет варпов работать?
Опять все. 8.
То есть они через 4. Третья итерация.
Опять все?
Четвертая итерация.
Ну, смотрите, почему все?
Потому что у нас номер потока, который отвечает от них,
они идут от 0 до 256 шагом 8.
Да? 8.
А?
Что?
Да, да, да. Ну, да.
Так, на четвертой итерации тоже 8.
Потому что они пока через 16.
Через 32 опять 8.
Потому что в каждом есть ровно по одному варпу.
В 64 сколько будет? Через 64 когда?
7. Нет, не 7.
4. Половина уйдет.
А?
Ну, потому что у нас будут отвечать за сложение
0, 64, 128 и 192.
То есть с 31 по 63 пропадут.
Ну и так, каждый второй.
И последнее сложение будет двумя варпами.
Итого, если я правильно посчитал,
будет 46 варп итераций.
46 в раз мы затригмируем ворп.
Запоминаем цифру.
46.
И вот это 46.
А?
Нет, не только высота.
Ну вот она, у нас по сути получилась
достижимая верхняя оценка, плюс-минус константа какая-то.
Почему константа появляется?
Потому что, вот здесь, какая?
Ну вот, а что такое 8 у нас?
Ну вот, а что такое 8 у нас?
Ну вот, а что такое 8 у нас?
Ну вот.
Ну вот, а что такое 8 у нас?
Сколько варпов у нас
используется внутри блока?
Да.
Вот, как раз у нас 8.
Блок size поделить на warp size.
Ну и на каждой итерации они
оттригируются.
Ну потому что на самом деле
если бы был один ворп-шедулер,
то у нас в блоке бы все ворпы
исполнялись последовательно.
А так мы можем раскинуть на два ворпа параллельных.
Так, теперь предлагаем умный подход.
Давайте сделаем по-честному.
Давайте картинку нарисуем для того, чтобы было понятно.
Ну вот.
Ну вот.
То есть у нас с вами
нулевой поток отвечает
за сложение нулевого первого.
Сначала
первый поток за сложение второго
плюс третьего и так далее.
Тут поток, по-моему, 127.
Будет заниматься сложением 254
плюс 255.
Почему у нас тут задействовано?
Половина. Потому что вторая со 128
уже не работает.
А?
Чего?
Да, да.
Сначала подвое.
Но только номера поток, в которые занимаются этим, уже другие.
Ну, потому что
у нас ворпы с ID-шниками
со 128 там до 159
простаивает, потому что он не используется.
А?
Да, эти потоки не используются, поэтому ворп не используется.
Ну ворп опираться по ним.
Вот. Дальше нулевой будет складывать.
Первый будет складывать.
И так далее.
И тут, по-моему, 63 должен быть сложить.
Вот такую вещь.
Какие-то четыре последних.
И сложно считать.
Сколько здесь ворпов будет использоваться?
Два.
Ну, дальше видите картинку.
Начиная с какого-то момента
мы с вами будем уже использовать слишком
меньше операций.
То есть у нас константа, вот смотрите,
было 46, стало 11.
Четыре раза сэкономили.
Ну, получится в два раза.
Ну, не в четыре, но в два.
Это еще не вся магия.
Ну, в два раза.
Ну, в два раза.
Это еще не вся магия.
А?
Ну, во-первых, они в последний,
а во-вторых, это просто так процессора.
Мы отправляем так процессора вычислить задачу.
А если мы еще должны элементы массива взять оттуда,
то это еще полто с операцией.
Если они не в shared память.
На самом деле все элементы массива изначально
мы складываем, мы можем использовать al1cache,
то бишь shared блок, для использования этой операции.
Там все равно блокировка потом будет.
Так что cache-miss, не cache-miss, там вообще
особо нет.
Вот.
Но, когда мы с вами используем
даже вот эту вот историю,
вот эту операцию,
потому что, типа, у нас нулевой поток
исполняет операцию. 0 плюс 1, 0 плюс 2, плюс 3.
Первый будет использовать 4 плюс 5, плюс 6, плюс 7.
Это тоже не очень хорошо.
Вспоминаем размер кашления.
И чего у нас размер кашления?
32.
И теперь я хочу рассказать про одну особенность,
связанную с использованием shared памяти.
Она называется,
по сути, такая супер кашление,
она называется банк.
Вот вы,
классический пример, который я привожу,
входили в ОФЦ?
Там куча окошечек, да,
которые вас направляют.
Вопрос. Если вас отправили в одно окошко,
и другого человека отправили в одно и то же окошко,
то что произойдет?
Это если мы с вами злые люди
и любим по конфликту.
Кто-то будет ждать.
Так вот.
Shared памяти — это у нас МФЦ такое,
в котором есть 32
окошка.
И смотрите, в чем прикол.
Если у вас
какой-то из потоков
обратится к пятому окну,
и какой-то другой поток
обратится к пятому окну,
обратится к пятому окну,
то что произойдет?
Кого-то поставят на ожидание.
Кого-то поставят на ожидание.
Да, то есть у вас может случиться так,
даже,
что у вас там вот этот поток,
смотрите, особенно в чем опасно.
Если это происходит внутри варпа,
допустим, это первый поток внутри варпа
обратился к пятому окошку,
а тут шестой поток обратился в окошко,
в пятое окошко,
тогда эта операция будет осуществлена
не за один такт времени, а за два.
Потому что каждый друг друга будет ждать.
Эта история называется банконфликт.
Особенно в том, что
внутри варпа операция
осуществляется за один такт,
вместо того, что мы обращаемся
с shared памятью, у нас возникает блокировка на shared память,
и в итоге вместо одного обращения к памяти
мы будем два такта работать.
Потому что нам нужно, по сути,
освободить обслуживающий персонал,
который будет здесь.
А теперь смотрите, прикол,
у нас нулевой поток в какой-то момент времени
нулевой поток складывал элементы
0 плюс 16.
Да, там реализация важная,
что элементы у нас с вами
будут храниться таким же образом.
Т.е. thread ID будет заниматься не тот,
а сумма элементов будет складываться именно так.
Т.е. в нулевом элементе у нас будет храниться с вами
сумма нулевого и первого,
во втором элементе складываться будет
сумма второго и третьего и так далее.
Вопрос.
Если мы перейдем до очень плохой стадии
в shared памяти,
то у нас возникнет когда-то такая проблема.
Я сейчас ее нарисую.
Смотрите, вот у нас тут вот
нулевой элемент,
вот тут сумма находится от нулевого до
пятнадцатого,
да, нулевого до пятнадцатого,
а в шнадс на блоке находится сумма
шестнадцатого до тридцать первого.
Да, это массивы.
В 32 элементе будет находиться сумма
32 по 47,
а 48 из 48 по 63.
И тут смотрите, что говорит.
Нулевой элемент для того, чтобы посчитать
сумму вот этого плюс вот этого,
должен за три гирицы,
давайте их жирными обведу,
вот этот нулевой
плюс шестнадцать, т.е. вот это вот шестнадцать.
А первый поток
будет триггерить сумму 32 плюс 48
элемента массива.
В чем проблема?
Напоминаю, что получение
данных и шеред памяти
происходит по 32 окнам.
Смотрите, в чем заключается
проблема. Первый поток значений
32 элемента из какого окна будет получать?
Из нулевого.
Почему из первого?
Не, смотрите.
История такая, что здесь у нас
в нулевом элементе хранится сумма от нулевого до пятнадцатого,
в шестнадцатом элементе от шестнадцатого до тридцать первого.
А здесь мы берем, что
в 32 элементе массива хранится сумма
32 до 47, а в 48
от 48 до 63.
То есть это у нас
массив А, в котором мы хотим
посчитать сумму.
Почему?
От нулевого до пятнадцатого.
В чем проблема?
Товарищи, смотрите.
Вот этот вот элемент, то есть как это перекладывается в код?
Тут у нас А0 и плюс А16 будут,
а здесь у нас будет
А32 и плюс А48.
Вопрос.
А32 из какого окна будем получать?
Из нулевого.
Давайте его так.
То есть А0 мы будем получать из окна
ноль, а А32
мы будем получать из окна под номером ноль.
Причем вот эта операция,
операция загрузки элемента, она будет происходить в один такт времени.
Что произойдет?
А? Один будет ждать.
А?
Ну, потому что элементы
грузят в массив последовательно,
там опять же все кошлини поделены на размер 32.
Вот и все.
Там все, там фиксировано.
Ты приходишь на почту, да?
Вот у тебя индекс написан
141.701, да?
Да, берется в процент 32,
это фиксированный адрес,
то есть у тебя именно фиксированное окно.
Тебя так или иначе отправляют, потому что там, если смотреть
в банковской сфере, там талон B, что-то там.
Да, и тебя сразу отправляют в определенный О,
потому что у тебя буква Б начинается.
Вот, у нас возникает проблема, у нас возникает банк конфликт.
Понятно, да, откуда возникает он?
Вот.
У нас банк конфликт.
Да, я тут написал, что такое банк конфликт.
Это поведение к ворб в shared memory, когда два потока внутри одного ворпа
запрашивают данные разных кошлини по одинаковому индексу,
по модуле ворб-сайз. Мы как раз на картинке это обсудили.
Они устраиваются в очередь, ну и возникает проблема.
Значит, как это решать?
А решается это вот так вот, вот такой картинкой.
То есть нулевой элемент теперь будет заниматься сложением...
То есть давайте как раз картинку поясню.
Здесь у нас блок size на этой картинке равен к чему?
32, да?
Смотрите, что происходит.
Нулевой элемент будет заниматься сложением нулевого
и 128-го элемента.
Первый будет заниматься сложением первого
и 129-го элемента и так далее.
То есть они будут заниматься сложением не последних элементов,
а через проскок.
Короче, дайте, чтобы не запутаться.
С вами нарисуем картинку.
Вот так вот.
То есть этот будет заниматься сложением...
Нулевой поток будет заниматься сложением вот этого.
Первый поток будет заниматься сложением вот так.
Второй вот так вот.
А 127-й вот так вот.
Вот.
вот так вот. Ну типа считать, что вы берете вот этот массив и параллельно
переносите на первую половину. И отчисляем еще раз такую операцию. Тогда давайте
рассмотрим, что у нас произойдет на моменте, когда у нас будет 16. То есть у нас
с вами самый интересный момент. Это когда у нас с вами тут 31, 63. Какие потоки у нас
с вами будут задействованы? Нулевой будет складываться с 32, первый будет складываться
с 33, а 31, 63. Тут даже видно, что они обращаются по модулю 32 всегда к разным ячейкам.
И вот она у нас с вами как раз естественная версия без кэш миссов. И занимает она у нас
11 операций сложений внутри блока. 11 варпсайзов. 11 варпов. Ну потому что у нас кэшлиния
загружается параллельно внутри варпа, а первый поток будет обращаться к первому и к этому.
129. Там кэш мисс считается, проблема была бы если бы у нас нулевой поток обращался к нулему,
а первый поток бы обращался к второму элементу. У нас же кэшлиния подгружается последовательно,
то есть на ворп на один. То есть они все дружненько взяли элемент, потом дружненько все взяли второй
элемент и сложили. Ну да, ну и параллельно с этим, с первым подъедет 29, второму 130 и так далее.
Не-не-не, смотри, прикол. Когда нулевой поток подгружает кэш для нулевого,
у первого же тоже стоит операция взять первый элемент. У нас же код как написан?
Не, они просто, вот эти вот все первые 31 операции они выполнят просто за одну команду ассемблера.
Ну вот, да, вот это, то есть у нас операция какая-то, аит равно аит плюс а, вот такая вот, да?
Вот, там просто когда мы хотим вот это, что у нас такое, лот, аит, да, она просто для и от нулевого до 31
выполняется за один такт, просто за одну команду. Поэтому этим ребятам нул подгружается своя кашление.
В варпе одинаково работают, это главная особенность видеокарты, что внутри в варпа прямо просто
синхронно. Ну это по сути, я бы сказал, со скоростью света, да, то есть там просто, по сути, импульс дается и все.
Вот, вот эти, честно, один от спор по операции, вот они вот здесь получаются. Вот, то есть мы научились
складывать сумму массивов на ЦПУ, ой, на ГПУ внутри блок. Значит, как можно сделать сумму массивов на несколько блоков?
Давайте обсудим. Ну да, можно так, типа, можно пирамидальную историю сделать, то есть у вас
сначала один блок, потом второй блок, потом третий блок, то есть у вас сначала делаете сумму массива
внутри блока, потом внутри блока блоков и так далее. Вот, можно попытаться посчитать сумму массивов
внутри блока, сумму массивов внутри этого. По каждому блоку, вот как, как саккумулировали мы с вами, в начале обсуждали,
как это делать, а потом сделать сумму массива внутри блока, но там надо считать, что лучше получается.
Вот, так, по сложению, по операциям понятно?
Ну да, там проблемы с ГПУ памяти у нас есть.
Итак, упоротые фишки. Так, товарищи, значит, шайтанские фишки, которые мы посмотрим с вами на семинаре.
Помните, про ИЛП мы с вами рассуждали в прошлый раз, очень-очень долго, типа, что взять одну операцию,
продублировать ее, тем самым уменьшить блок size в два раза, там, либо количество блока в два раза.
Здесь это можно сделать на этапе загрузки в shared память и сэкономить себе очень-очень сильно.
То есть вы там, как код выглядит, вы берете, копируете весь массив блока в shared память,
потом в shared памяти выполнять какие-то операции. Вы вместо того, чтобы копировать сразу в shared
память, вы делаете операцию, первый блок на первом уровне и кладете это все в shared память.
То есть вот это вот элемент, то есть вместо того, чтобы сразу сделать копию массива 256,
вы создаете массив размера 128 и выполняете первую операцию, сложение и присваивание в shared память.
Понятно, или рассказать, или показать?
Смотрите, давайте, давайте, может быть, я код даже напишу, какой-нибудь псевдокод.
Давайте vim.
Неважно, что там происходит, да?
Значит, важно с вами, что у нас есть x, ну и, допустим, у нас массив a.
Вот, смотрите, первое, что мы могли бы сделать.
Так, мы могли бы сделать вот такую вот вещь.
A idx, idx мы умеем высчитывать, да, я не показывал, как его высчитывать.
Это первая версия, ага, вторая, она немножко вот такая вот.
Так, по-моему, shared все-таки неправильно обознать, да.
То есть мы делаем, смотрите, какую вещь, да, тут флоты, здесь делаем вот так вот, x.
Вот, первая версия у нас обычная, вторая версия умная.
То есть вместо того, что в тупую скопировать массив, мы берем, делаем операцию, потом копируем массив.
Нам все равно количество операций на чтении не поменяется за все время работы алгоритма.
Хоть мы выдергиваем вот так вот, хоть мы два раза выдергиваем.
Да, но при этом количество записей и shared на памяти уменьшается в два раза.
Ну можно, но это уже смысла там нету, там уже нет такого профита.
Вот, вот такая вот вещь.
Вторая вещь, вообще, вторая вещь крутая, которая заключается в том, что когда вы уже находитесь внутри одного варпа,
да, когда у вас все операции внутри одного варпа идут, то есть у вас вот тут вот, да, вопрос, зачем нам здесь цикл уже?
А? Незачем? Вот, поэтому вы доходите суммой цикла до размера 32, а потом берете и разворачиваете эту фигню.
Просто пять операций сложения пишете, что-то типа такого.
Ускорение до 16 раз.
Ну пять, потому что это 32, 16, там и так далее.
Третий вообще кук-хацкер. В куде девятый плюс появилась регистровая операция,
которая умеет делать магию.
Есть операция shuffle-down-sink, которая за одну регистровую команду, это реально регистровая команда, берет и сделает битовый сдвиг внутри элементов массива.
А? Да блин, задолбала.
Ну то есть, смотрите, у вас элемент был А16, да, после применения этой операции, если сдвиг на 16 идет, то он берет и делает его А0.
И там просто пять регистровых операций выписывается, которые типа битовые.
В ассамблерные команды это чуть-чуть быстрее получается.
Что, не работает?
Вот.
На семинаре посмотрите эти примеры, они все есть в репозиториях.
Это сложение, мы с сложением разобрались.
Да, у нас еще сколько минут? Два часа.
Попробуем со сканированием разобраться.
Значит, по суммированию понятно?
Теперь сложная задача, которая еще хуже параллеляется.
У нас есть массив А, нам нужно посчитать сумму на префиксе.
Кто-нибудь решал такую задачу параллельно?
Нет?
Ну, в общем-то, у нас есть массив А, нам нужно посчитать сумму на префиксе.
Кто-нибудь решал такую задачу параллельно?
Вообще нет.
Давайте разобраться.
Смотрите.
Первый алгоритм наивный.
То есть, что вам происходит?
Давайте я на бумажке тогда расскажу.
На доске.
А?
Да-да-да, массив сумма на префиксе.
Давайте я тогда рисовать начну.
Ну, все равно нам поможет картинка.
Давайте рассмотрим массив из 8 элементов.
Это, если что, индекс элементов массива.
Итак, смотрите, что мы делаем.
Наберем...
Складываем массивы по одному.
Потом один-два.
Потом один-два.
Потом через два.
Один-четыре.
Два-пять.
Ну, и потом последняя операция.
0,7.
0,7.
Скажите, почему это плохо?
Почему так делать плохо?
Именно так, как показано это на экране.
Конкурирующая запись.
Конкурирующая запись мы пишем в шерп память.
То есть, когда мы будем писать, допустим,
вот информацию вот сюда,
да?
У нас вот этот вот элемент,
который начнет писать информацию сюда,
он может уже взять информацию
не суммы второго и третьего,
суммы третьего элемента,
а суммы второго и третьего взять.
Потому что мы перезапишем это значение.
То есть у нас гонка данных возникает.
Поэтому такая реализация отстойная.
Давайте поумнее что-нибудь придумаем.
Это, знаете, задача
на уровне этих лохотронов по телеку,
которые показывают.
Уберите лишние стрелочки на экране, чтобы это работало.
Ну, вы знаете, там бывает,
по телеку показывают там эти всякие, типа...
Да, да.
Ну, а, фу ты.
А, да, ёптись.
Сейчас.
Да.
Ну, а оно там получается так.
То есть и так, тут 0,3, тут 0,2,
0,1 и тут 0.
Потому что 0,1,
тут мы складываем.
Чё?
0,1,2?
Да, вот потому что здесь мы складываем
0,1,2.
Тут получаем 0,2.
Там и так далее.
Тут понятно, что мы складываем
0,1,4.
Да.
Вопрос. Давайте сотрём стрелочки
на экране так, чтобы было верно.
Можем ли мы так сделать?
Давайте начнём с этой стрелочки.
Вопрос. 3,4 у нас где-нибудь используется?
Давайте проследим. Вот тут вот операция.
3,4 идёт.
Вопрос.
3,4 у нас где-нибудь используется?
Давайте проследим.
Вот тут вот операция. 3,4 идёт.
Да? Где она используется?
3,4,5,6.
3,4,5,6. 3,6 используется.
Где у нас?
0,2 и 3,6.
Так.
Вопрос.
Могли бы мы это как-то другим
способом получить?
То есть мы написали с вами, что 0,6
это 0,2
плюс 3,6.
Как мы это ещё можем написать?
Давайте по степеням 2 это разложение сделаем.
Можем так посчитать?
То есть 0,6
это сумма от 0 до 3, сумма от 4 до 5, сумма
от 6 элементов.
Поэтому...
Ну да, немножечко другую.
Смотрите, история такая. Вот у нас
concurrency возникает, raise
возникает из-за того, что мы берём сумму
3 и 4, чтобы посчитать сумму 3 и 4.
Давайте убирать лишние стрелки.
Оставим только 4.
Здесь оставим 6.
То есть будем аккумулировать сумму по степеням 2.
Ну потому что у нас...
Смотри, что мы делаем.
Вот когда мы считаем
сумму
2,3
и 3,4,
что такое 3,4?
Это сумма 3 и 4.
Но у нас может случиться такой момент,
что уже сумма 2 и 3 в этом моменте
уже была посчитана.
И поэтому мы вместо суммы
вместо 3 элемента поставим сумму 2 и 3.
Здесь получается 2 плюс 3 плюс 4.
Это плохо.
Вот.
Поэтому смотрите, история такая.
По степеням 2 сохраняем значение
элементов.
Получаем вот такую картинку.
Тут 4.
Тут 2.
Тут 2.
Это что-то похоже
на структуру под названием дерева Фенвика.
Если вы знакомы с такой.
Сейчас, секунду.
И получается, к сожалению,
неполная сумма.
Получается небольшой огрысток.
А?
4,5, 4,5.
Они везде тут остаются.
Да.
Ну тут смотрите, чем недостаток
этого алгоритма.
Что если мы начинаем стирать что-то лишнее,
у нас сейчас стрелочек,
проблемы с кондиционами не будет никаких.
Вот такая вот.
Такой массив.
Давайте стрелки нарисую.
То есть,
здесь сложение идет так.
Здесь массив идет так.
А здесь элементы идут так.
Вроде проблем со стрелками теперь у нас
не возникает.
Да?
Но в чем проблема у нас с вами получается?
Не, он требует 0,1 и 2,3.
Ну в 0,1 и 2,3 при этом мы не пишем ничего.
То есть в эти ячейки мы ничего не пишем
по ходу операции.
Вот, а теперь вопрос.
Как это собрать?
Ну да.
То есть смотрите, у нас получается есть
0,01,2,0,3,4,4,5,6,0,7.
Да, то есть с определенной степени двойки.
Так, давайте тогда не будем обращать то,
что на доске, а попытаемся
с этим сделать алгоритму.
Итак, дальше.
Рисуем этот массив.
Этот алгоритм двустодейный,
если что.
0,01.
Давайте поймем, как посчитать сумму
с нулевого до шестого.
Ну, мы, кажется, это писали.
Ну да.
Ну да.
Ну да.
Ну да.
Мы, кажется, это писали.
Это 0,03, плюс 4,5, плюс 6.
То есть что нам нужно сложить
здесь, чтобы получить сумму
от нулевого до шестого?
Какие элементы?
Ну да.
Давайте подчеркнем.
Давайте я конечную картинку нарисую,
которая должна быть.
Сумму элементов от нулевого
до седьмого запомним.
А здесь мы сделаем такую вещь.
Как нейтральный элемент будем обозначать?
Посложение.
Я предлагаю его обозначить епсиловым.
Вы не против?
Да, е.
Да, е.
Так, главное, чтобы у меня
тут сдвиг не случился.
Вот такую историю
мы с вами будем моделировать.
Давайте я тут.
Вот так вот сделаем.
Не, не.
Это особенность такая.
Ну давайте думать,
что мы можем сделать с этой штукой.
Ну что мы можем сделать с этой штукой?
Да.
То есть смотрите,
у нас
0,3.
Я сейчас напишу стрелочки.
У нас 0,3 должен уйти сюда.
4,5 должен уйти сюда.
И 0,7, ой.
И 6 должен уйти сюда.
Ну вот.
Да?
Вопрос.
Куда нам нужно утащить 0,3?
В каких элементах у нас присутствует 0,3?
В 0,3.
Смотрите, он у нас
во второй половине должен быть.
Этого массива.
А здесь 0,3 нету.
Он нам не нужен во второй половине.
Поэтому знаете, что делаем?
Перетаскиваем его сюда.
Перетаскиваем его сюда.
Ну то есть перетачиваем его сюда,
потому что он должен быть во второй половине.
А здесь что у нас должен быть на замену?
Сюда нужно поставить кандидата,
который не содержит 0,3.
Сюда нужно поставить кандидата,
который не содержит 0,3.
А давайте сюда E поставим.
Ну типа есть 0,3, нет 0,3.
Остальное пока оставляем.
Тут обычно еще в классическом алгоритме
делают вот так.
0,7 выкидываем, вставим E и делаем замену.
То есть меняем этот элемент
с этими местами.
Так, давайте дальше придумывать.
4,5. Что нам с 4,5 нужно?
Вот у нас тут 4,5 находится.
Куда его нам надо отправить?
Да, опять в правую половину отправить.
А 0,3 где у нас должен быть?
Да, там где четверка.
0,3 отправляем сюда специально.
А здесь нам уже не нужен сам 0,3
и сам 0,4,5.
Нам нужен 0,5.
Поэтому здесь мы берем и складываем эту штуку.
Ой, 0,5.
Здесь аналогичная картинка будет.
То есть такой перекрестный алгоритм получается.
Здесь получается 0,5.
Здесь получается 4.
И здесь идет сложение.
Понятно?
То есть 2 стадии на алгоритм.
Первым мы собираем сумму по степеням 2,
во втором мы их перекидываем.
Так, что как думаете?
Проектор завершен.
Я честно не знаю.
Надо посмотреть.
Вот.
Давайте я сейчас пытаюсь подключиться еще раз.
Я надеюсь, он подрубится.
Опять же тут проблемы с варпами идут.
Смотрите.
Сначала сумма по степеням.
Нулевой поток вычисляет сумму нулевой и первого элемента.
Нулевой поток потом будет вычислять сумму первого и третьего элемента.
Ну, он берет элемент 1 и берет элемент 3.
Нулевой поток будет вычислять сумму третьего, третьего, poner и зайittle www.
Не advantить yarn,
это залово.
Но вы Hmntămat all the same
Нолевой поток будет вычислять сумму третьего и седьмого элемента.
Согласны?
Опять же по картинке.
То есть нолевой поток будет вычислять сумму вот этого и вот этого элемента.
Нолевой поток вычисляет сумму седьмого и пятнадцатого.
Пятнадцатого и тридцать первого.
Пятнадцатый поток будет вычислять в этот момент сумму 32-го и 33-го потока.
Ой, что я пишу? Почему 32-го и 33-го?
Скажите, где баг.
А, нет.
Шестнадцатый поток в нулевой операции будет складывать сумму 32-го и 33-го элемента.
Да, то есть пример.
То есть у нас где-то в той истории возникает поток 32-го и 33-го, мы их складываем.
Видите проблему?
Что это проблема?
Опять конфликт. У нас нолевой поток.
Здесь это нолевой поток, здесь это шестнадцатый поток.
Они внутри одного вакпана находятся и конфликтует по нулевому элементу.
Это первый конфликт.
Чем дальше мы поднимемся, тем шире конфликт.
Потому что у нас количество повторяющих элементов будет все еще больше и больше и больше.
Очень много банков конфликтов.
Как будем разрешать их?
Не, здесь не получится.
Здесь история очень жесткая, сейчас попытаюсь рассказать.
Делаем паддинг.
Мы еще позже начали.
У вас пара есть дальше?
Дайте, я сейчас попытаюсь рассказать эту историю.
Делаем паддинг.
В чем он заключается?
Он заключается в том, что вы делаете 25-й кадр.
Кто знает, что такое 25-й кадр?
Вставка какая-то не нужная.
Вставка ненужная.
Вы берете и каждый 32-й элемент вставляете ненужный.
Давайте сейчас я попытаюсь на картинке нарисовать это.
И тогда конфликты пропадут, но не все.
Давайте на той картинке разберем.
Смотрите.
Делаем 0, 1, 2, 3.
31.
Дальше идет фигня.
32.
33.
34.
35.
36.
37.
38.
39.
32.
33.
60.
Сколько?
3.
Фигня.
64.
Причем позицию элементов нам нужно тоже сохранять.
0, 1, 2, 3.
31.
Этот элемент у нас будет 32, 33, 34.
64 будет...
Вот так.
Это элементы массива.
Тогда вопрос.
Нулевой элемент будет складывать первое.
Сумма нулевого и первого.
Айдишники будут такие же.
16-й поток.
Сумму каких элементов будет складывать?
Он будет складывать 32 плюс 33.
Но в каких айдишниках он находится?
Не-не-не.
33, 34.
По модулю 32
они начинают отличаться.
Они начинают отличаться.
Мы избегаем конфликта.
То есть мы специально делаем сдвиг, чтобы избежать этого конфликта.
Да, ну вот в коде вы посмотрите, как это делать.
Нет, смотрите.
Мы смотрим на варп-конфликты внутри одной регистровой операции.
То есть загрузку из регистра.
То есть вот эта одна операция у нас выполняется внутри варп.
То есть внутри этой операции нужно смотреть,
если конфликт нет.
И внутри этой операции мы смотрим, если конфликт нет.
И дальше можно посмотреть историю, что если добавлять паддинги
раз в 32.
раз 32, то эта вся история будет отрабатывать так же. Мы избавимся от большей части банк
конфликтов, к сожалению от всех не избавимся. Там по-моему еще каждый какой-то кадр нужно будет
еще один конфликт, padding добавлять, мусор, и тогда это будет у нас с вами работать.
Так, тут история как это еще можно посчитать. Давайте разберем. Смотрите, замечаем, что, как
вообще типа костыльнуть эта история. Замечаем, что 1024 это 32 на 32. 1024 это максимальный размер блока.
История такая, что внутри регистровых операций у нас ворб конфликтов особо не возникает. Поэтому
мы берем, считаем по сути один раз сумму внутри регистров, да, вот с операциями shuffle up sync,
вот, вот shuffle up sync, а потом еще второй раз выполняем функцию операции shuffle up sync,
и в итоге у нас получается пирамидка, 2 стадины обработка. Сначала каждые 32 складываем,
потом еще каждые 32, внутри 32 эти 32. Вот, ну да, она уже пропала, но я думаю, что это,
мы можем закончить на этом. К сожалению, мы не посмотрели quicksort, как работает, но в качестве
заданий я скажу, что при помощи операции скана можно делать операцию фильтрации. Там, по сути,
нужно сделать так, вы те элементы, которые подходят под условия, отмечаете единичками, те элементы,
которые не подходят под условия, отмечаете нолькой. Дальше считаете сумму на массиве, сумму на префексе,
как раз вы получаете айдишники тех элементов, которые вам нужно вычешивать. То есть, это не
сложная вещь. А quicksort это что, по сути? Как quicksort реализуется? Ну да, а теперь мы умеем
получать все элементы меньше такого, все элементы больше такого. Запускаем два ядра и делаем это
рекурсивно. К сожалению, это вкратце. Извините, что я вас задержал. Вроде бы мы посмотрели так или
иначе все, что связано с теоретической кудой. Практическую куду обычно уже никто не реализует,
а просто используют в библиотеке, которую NVIDIA дает. Там есть особенность реализации. Я думаю,
если что, можете поморожить семинаристов или меня в чате по поводу применения, я там что-нибудь
покидаю. Ну все, всем спасибо тогда. Дальше вроде буду вести уже не я, а лекции. В следующей
лекции уже будет вести Олег. И там будет уже распределенная часть. А параллельную часть,
по сути, мы с вами закончили. Осталось это все распрактиковать и добить. Давайте вопросы задавайте,
если есть. Там презентацию я выложил, там есть некоторый обзор библиотек на видеокарте,
которую использовать. Вот ее может будет посмотреть. Усё. Да, спасибо, спасибо.
Ура!
