Технические проблемы затянули начало лекции. Сегодня центральная лекция второй части курса про неразрешимые проблемы.
Теория, которую мы будем доказывать и обобщать, это то, что существует перечислимое, но неразрешимое множество.
И будет несколько примеров. Начинается изложение с универсальной машины тюринга. Давайте вспомним, что это такое.
Давайте говорить про универсальную вычислимую функцию, неважно построена по универсальной машине или как угодно еще.
Универсальная вычислимая функция. Это вот что такое. Это функция двух аргументов. Как обычно, аргументы могут быть натуральными числами, могут быть конечными словами.
Пусть будут натуральные числа. Функция двух аргументов такая, что верно две вещи. Во-первых, она сама вычислима как функция двух аргументов.
Во-вторых, в ней заключены все вычислимые функции одного аргумента.
То есть, для любой f из натуральной вычислимой существует p такое, что для любого x у от px равно f от x.
Как это нужно понимать? Нужно понимать, что у этого такой языкопрограммирование или компилятор, который получает текст программы и фото этой программы.
И потом он эту программу запускает на этом входе и возвращает ответ. То именно за язык определяется компилятором.
Можно, конечно, говорить про чисто такие языковые определения, как должна выглядеть корректная программа, что там баланс оборот должен сходиться, какие команды могут быть и так далее.
Но, в принципе, необязательно так делать. В принципе, можно сказать, что есть компилятор.
И можно сказать, что вообще любая последовательность будет программой для этого компилятора.
А если там должны сходиться скобки, то это будет означать, что если скобки не сходятся, то компилятор выдаст ошибку.
Ну и тогда, например, это означает, что программа просто нигде не определена.
Что программа с синтактической ошибкой это одна из программ для нигде неопределенной функции.
Хорошо. А что говорится? Говорит, что это такой универсальный язык или, как говорят, тюринг полный.
То есть для любой машины тюринга одного аргумента, для любой вычисленной функции одного аргумента есть программа на этом языке, которая ровно эту функцию вычисляет.
Вот это есть универсальность.
Хорошо. Ну тогда теорема, которую, собственно, тюринг доказал.
Сейчас, давайте сначала рассмотрим.
Вот такую диагональную функцию, можно сказать, ну или диагональное множество.
С, но ж таких М, то У от НН определено.
То есть это множество самоприменимых программ.
Множество самоприменимых программ.
Вот. Ну что, например, можно понять?
Ну, например, можно понять, что оно нетривиальное в том смысле, что оно не пустое и дополнительно тоже не пустое.
Среди всех программ есть нигде неопределенное.
Соответственно, нигде неопределенное неопределенное нигде, в том числе и на самой себе.
Поэтому это не все. Не все натуральные числа.
Но, конечно, есть и всюду определенное, всюду определенное прелинвезде, в том числе на своем номере.
Поэтому не пустое. Вот. Более того, всюду определенных точно бесконечно.
Да, потому что есть там константа 0, константа 1, константа 2 и так далее.
Вот.
Но утверждается больше.
Теорема. Вот это множество S перечислимо, но неразрешимо.
Так. Значит, тут две части. Во-первых, перечислимость.
Но для перечислимости у нас было много разных свойств.
Ну, например, можно сказать так, что вот это S – это просто область определения диагональной функции.
Значит, S – это область определения диагональной функции.
Значит, D от N, U от NN.
Значит, эта диагональная функция вычислима как композиция вычислимых.
Но можно сказать, что одна функция собирает из N пару NN, а вторая функция подставляет ее в универсальную.
Значит, поэтому D от N – это композиция вычислимых, значит, D от N – вычислимо.
Ну и ясно, что вот S – это точность ее области определения.
Так, сейчас тут, наверное, так надо поставить.
Ну, а у нас была теорема, что все, что является областью определения любой вычислимой функции...
Давайте допишу. Диагональная функция вычислима.
Из этого следует, что S – перечислимо.
Вот. Это простая часть.
Вот. А дальше есть сложная часть.
Значит, сложная часть – это...
Ну, так скажем, более сложная часть.
Это не то, чтобы уж прям такое сложное рассуждение.
Значит, неразрешимость.
Значит, для неразрешимости работает диагональный метод.
Та же самая идея, которую мы использовали, когда доказывали, что действительно чисел не счетное число.
В общем, взять диагональ и сделать наоборот.
Значит, неразрешимость дает диагональный метод.
Ну, смотрите, предположим...
Да, значит, предположим, что S – разрешима.
Значит, предположим, что S – разрешима.
Рассмотрим такую функцию.
Так, наверное, насоски закрытия.
Так, наверное, насоски закрытия.
Так, значит, предположим, что S – разрешима.
Значит, тогда можно алгоритм, который определяет принадлежность S, как-то еще использовать.
Значит, можно рассмотреть вот такую функцию, и тогда она получится вычислимой.
Значит, тогда вычислима функция.
Значит, вот такая D' от N.
Там где-то еще открыто, а вон там наверху.
Так, значит, вычислима функции вот такая.
Смотрите, D' от N равняется, например, единице, если у от N не определено.
И не определено, если у от N определено.
Вот, значит, почему это будет разрешима?
Ну, потому что если S – разрешима, то можно вот эту штуку проверить.
Значит, и, соответственно, понять, какая из двух возможностей имеет место.
И, соответственно, либо напечатать единицу, либо зациклиться бесконечно.
Хорошо.
Значит, вот она вычислима. В чем же будет проблема?
Ну, а в том, что, раз она вычислима, то ее можно найти среди как бы самих сечений функции U.
Значит, тогда по определению универсальности,
тогда из универсальности мы получаем, что существует
такая программа P,
то для любого N U от PN равняется D' от N.
Ну, а раз для любого N, значит, в том числе для N равного P.
В чем была проблема?
Ну, в том числе, если у от N равняется D',
то в том числе для N равного P.
В чем была идея диагонального метода?
Что как раз, если взяли диагонали и делали все наоборот,
то то, что получилось, не может встретиться в таблице.
А почему не может встретиться в таблице?
Ну, потому что на перечень это диагонали этой строки получат противоречие.
Что будет конкретно здесь?
Ну, вот если поставим N равное P, то получится, что
значит, у от PN равняется D' от P.
Это потому, что мы подставили N равное P.
Вот, но тут получится противоречие.
Потому что, смотрите, если у от PN определен,
если у от PP определен, то тогда D' от P не определено.
Ну, а тогда, раз одно определено, другое не определено, значит, они не равны.
Тогда получается, что D' от P не равно у от PP.
Вот, ну и наоборот, значит, наоборот у от PP не определено.
Из этого следует, что D' от P равно 1.
И следует, все равно D' от P не равно у от PP.
Ну и получили противоречие.
В любом случае, получили противоречие.
Вот, так, ну все, значит, на этом заканчивается рассуждение.
Какие-нибудь вопросы?
Все понятно?
Ну, действительно, значит, да.
D', потому что вот это условие можно проверить.
Ну, вот это вот от NN определено, это в точности,
точнее, вот это вот означает, что N лежит в S,
а вот это означает, что N не лежит в S.
Вот, то есть программа будет такая.
Если у нас есть программа для S, то нужно в эту программу поставить N.
И, соответственно, если программа сказала да, то тогда зациклится,
если программа сказала нет, то вы досоедините.
Так, хорошо.
Ну, значит, более известна не проблема самоприменимости,
а проблема остановки или останова.
Значит, проблема остановки.
Значит, это множество H, halting, halting problem H,
это уже множество пар, множество пар Px,
таких, что у от Px определено.
Вот, вот и так, что она тоже неразрешима.
Значит, аж неразрешима,
значит, так как N лежит в H тогда и только тогда,
когда пара N, ой, сейчас не то я написал, N лежит в S.
N лежит в S тогда и только тогда, когда пара NN лежит в H.
Ну и, соответственно, если бы H был разрешимым,
то было бы разрешимым и S,
потому что мы просто брали бы такую диагональную пару
и про нее спрашивали бы о H.
Если бы H было разрешимым,
то можно было бы...
Так, можно было бы решить и S.
Да, значит, как именно решить?
Ну, вот так вот решить, взять N на вход,
из него изготовить пару NN
и эту пару подать в решатель H.
И ровно тот же самый ответ, который даст решатель H,
будет ответом и для S, вот для одиночного N.
Соответственно, получается, что H тоже неразрешим.
Интуитивно можно сказать так.
Ну, что вообще можно делать в общем виде с программой?
Ну, только запустить.
Как бы непонятно, ну, смотрите, для некоторых программ
можно прямо из текста понять, что она делает
и как-то там доказать, что она делает правильно.
Но есть такая вещь, как обфускация.
Слышали такое слово?
Это намеренное искажение программы,
чтобы было непонятно, что она делает.
Обычно это всякое вредоносное программное обеспечение,
притворяет, что оно хорошее.
Я не знаю, что вы слышали, несколько дней назад была
скандальная история, что обнаружилось, что
некоторый пакет злоумышленники на протяжении многих месяцев
писали вредоносный код,
притворяясь, что они хорошие.
Сначала долго что-то хорошее писали,
получили доступ к ядру и потом внедряли вредоносный код,
так чтобы это потом было установлено на серверах
и можно было там красть данные.
Но потом они погорели на том, что этот вредоносный код
исполнялся долго, и один едливый человек
увидел, что программа стала работать на полсекунды дольше,
стал разбираться, что случилось,
и нашел, соответственно, это внедрение.
Соответственно, есть проблема,
что когда программист хочет, чтобы было понятно,
что делает его код, то он может написать так,
что можно будет доказать, что код правильный.
Но если программист хочет, чтобы было непонятно,
что он делает, то он тоже может так сделать.
И нет никакого способа универсально по коду
понимать, что он будет делать.
Соответственно, в общем виде, допустим,
нам интересно, в принципе, остановится эта программа или нет.
Что с ней можно делать всегда?
Всегда можно начать выполнять.
Мы ее запустили, она работает, что-то делает.
Остановится она или нет?
Непонятно, если она уже остановилась,
то да, может точно знать, что она остановилась.
В этом смысле аж тоже перечислимо.
Аж перечислимо, дайте я тоже отмечу,
аж перечислимо просто как область определения самой функции U.
Как область определения вычислимой функции U.
Так что если она остановилась, то мы это поймем.
Но если она зациклилась, то есть повторилась конфигурация,
то мы тоже поймем, что она уже никогда не остановится.
Может она не завершилась, не зациклилась,
но в какой-то такой повторяющийся не совсем цикл вошла.
Например, в случае с машиной Тьюринга
какое-нибудь бесконечное движение в одну сторону.
Тогда она тоже точно не остановится.
Но если она все время берет новую память,
что-то там делает, но что она делает непонятно,
то вот неясно, она остановится или нет.
Ну и непонятно, сколько нужно ждать,
чтобы уже понять, что она точно не остановится.
Ну и в этом как бы и есть проблема,
что никак алгоритмически это понять нельзя.
Сколько машина должна проработать,
чтобы уже точно не остановиться,
это алгоритмически понять нельзя.
Хорошо, возникает такой вопрос.
А нельзя ли от этой проблемы вообще как-нибудь избавиться?
Значит, нельзя ли разработать такой язык программирования,
чтобы все программы останавливались?
Вот такой вопрос.
Значит, можно ли разработать язык программирования,
чтобы все программы останавливались?
Ну, так точно, конечно, можно, в принципе,
но универсально нельзя.
Ответ, в принципе, можно, но нельзя сделать так,
чтобы этот язык был универсальным.
Значит, можно, но не получится сделать так,
чтобы все всюду останавливающиеся программы можно было написать.
Значит, но нельзя сделать так,
чтобы были программы для всех всюду определенных функций вычислимых.
Ну, и рассуждение точно такое же диагональное.
Значит, рассуждение такое.
Ну, давайте попробуем повторить теорию.
Скажем, что назовем тотально вычислимой функцией.
Значит, определение f – это тотально вычислимая функция.
Если f – вычислимая и всюду определена.
Ну, и скажем, что давайте ее как-нибудь назовем, скажем,
с индексом t, для тотальных.
Универсальная – тотальная.
Она тоже из n на n в n.
Значит, это универсальная, тотальная вычислимая функция.
Значит, если точно так же верны две вещи.
Первое, что у t – тотальная вычислима.
И второе, что для любой функции f одного аргумента из n в n,
значит, тотально вычислимой, существует такое p,
что для любого x, у от px, у t, у t от px равно f от x.
Но теорема, что вот такой функции не существует.
То есть тут как бы либо одно, либо другое.
А сразу и то, и другое не будет.
Значит, теорема, что вот такая вот, в отличие от просто универсально вычислимой,
универсально-тотально вычислимой не существует.
То есть как бы составить язык, для которого проблема остановки тривиально, можно,
но зато на этом языке не все задачи можно решить.
Да, не все программы можно написать.
Так. Ну и доказательств точно такой же диагонально.
Так, значит, доказательства.
Значит, пусть существует, пусть универсально-тотальная функция существует.
Значит, тогда рассмотрим диагональную функцию.
Значит, тогда рассмотрим вот такую диагональную-тотальную-подальженную функцию,
тогда рассмотрим вот такую диагональную тотальную функцию от n, которая есть у тотальная от n.
Вот тогда это диагональная-тотальная тоже тотально вычислима.
Диагональная-тотальная, тотальная вычислима, ну опять же, как композиция тотально вычислимых.
Конечно, формирование диагонали это тотальная вычислимая, и подстановка в тотальную тоже будет тотально вычислима.
Вот, ну тогда рассмотрим ново изгинутую, значит, D't от n, которая будет равна Dt от n плюс 1, тоже тотально вычислима.
Тоже тотально вычислима.
Ну и тогда сейчас противоречит как в предыдущем рассуждении, значит, тогда для него должна быть программа.
Существует P такой, что для любого n, у тотальная от pn равняется Dt от n, значит, подставляем n равное p.
Получаем, что у тотальная от pp равняется Dt от p, а у тотальная от pp это Dt.
Получается, что здесь Dt от p, а Dt от p плюс 1.
Вот это противоречие, значит, это противоречие, что число равно себе плюс 1.
Противоречие, то m равняется m плюс 1.
Так, хорошо, а почему такое же противоречие не работает просто для универсальной функции?
Ну а для тотальной, для универсальной мы вроде доказали, ну или по крайней мере, помахали руками, почему просто универсальный существует.
Почему для просто универсальной такое же рассуждение даст противоречие?
Конечно, да, конечно. В данном случае это просто число натуральное, и противоречие, что число равняется себе плюс 1, это противоречие.
А для просто универсальной это может быть неопределенным значением, ну а то, что неопределенность равна неопределенность плюс 1, это не противоречие.
Потому что неопределенность плюс 1 тоже неопределенность.
Вот, но так получается еще одно доказательство, что на диагональной универсальной функции точно есть неопределенности.
Если бы их не было, то это все-таки было противоречием.
Ну вот, хорошо.
Ну вот, получается, что никак не спрятаться.
Никак не спрятаться от проблемы остановки, то есть либо у вас будет совсем не универсальный язык, либо у вас будет неразрешимая проблема остановки.
А может, в принципе, то и другое.
Ну и то и другое, это там уже экзотика, что не все программы можно написать, но при этом остановка неразрешима.
Такое, конечно, можно сделать.
Вот.
Ну хорошо.
Итак.
Ну ладно, давайте посмотрим какую-нибудь другую задачу.
Ну, например, посмотрим вот на что.
Значит, множество с от слова константа.
Значит, это функции, постоянные на своей области определения.
То есть это получается множество программ таких, что для любых x, y.
Значит, если у от px и у от py определены, то тогда они равны друг другу.
У от px равно у от py.
Это уже какое-то более хитрое множество.
Вот. Ну тут что получается?
Получается, что оно непонятно, почему и перечислимым будет.
Значит, как можно доказать, что на всей области определения постоянное?
Это не понятно, что такое, потому что нужно бесконечно много чисел проверить.
То есть непонятно, как...
Вот пусть мы ее запустили, даже в донецких входах, как-то параллельно перескакиваем туда-сюда.
На каких-то точках получили значения.
Пусть даже они все одинаковые, но непонятно, что на всех остальных тоже будут одинаковые.
Вот. Ну, на самом деле здесь это множество не будет причислимым.
Значит, его дополнение будет ц с чертой.
На самом деле будет перечислимым.
Значит, почему?
Ну, что такое ц с чертой?
Ц с чертой – это множество таких П,
то существует х, у, на что...
Так, дать я так напишу, что у от ПХ равняется К.
А у от ПЮ равняется М, который не равно К.
И это как бы подчеркнешь, что когда я пишу равно К, это имеется в виду, что равно натуральному числу, а не неопределенности.
Хорошо. Ну а почему это...
Это почему перечислимо?
Ну, можно по-разному говорить.
Да.
Ну, почти так. Да, почти так. Только нужно еще один параметр.
Потому что если у вас просто есть х и крик, то вы не сможете понять верное это или неверное.
Потому что если у вас уже есть ответы, то вы, конечно, можете сравнить, что они не равны.
Но если ответов нет, то не понимаете, как понять, что их не будет в будущем.
То есть тут нужно добавить еще один квантор.
Можно написать так, что тут существует нож таких П,
что существует, ну, допустим, Х, У, С, Т,
что от ПХ вычисляется за С шагов.
Значит, от ПЮ вычисляется за Т шагов.
И, соответственно, У от ПХ не равно У от ПЮ.
Ну и тогда это очень похоже на пределы проекции.
То есть можно сказать, что у нас есть такие четверки, Х, Ю, С, Т, ну и еще отдельно П.
И мы, соответственно, перебираем уже в пятимерном пространстве, получается.
Ну, можно сказать, что и в двумерном, можно всю эту четверку закодировать одним числом.
И перебирать, соответственно, наборы ИСП и коды четверки.
И проверять вот это. То, что здесь написано в скобках.
Так, кстати, вот эту скобку надо еще закрыть.
То, что написано в скобках, это уже разрешимый предикат.
Потому что можно докодировать четверку, можно запустить на данное число шагов,
можно проверить, остановится или нет. Если остановился, то можно проверить, будут равны или нет.
Вот. То есть это получается перечислимо, как проекция разрешима.
С чертой перечислимо, как проекция разрешима.
Так. Почему не разрешима?
Ну, сейчас чуть попозже обсудим.
Да, значит, не разрешима.
Значит, это позже будет.
Так, а надо перерыв делать.
И можно дальше.
Позже начали, давайте тогда.
Постараемся успеть то, что я планировал.
Значит, еще одна задача. Это про всюдуопределенность.
Значит, это Т.
Значит, Т это...
Давайте я с словами сначала напишу.
Множество всюдуопределенных программ, то есть тотальных.
Всюдуопределенных программ.
То есть получается, что Т это множество таких П,
что для любого Х у от ПХ определено.
Но от У от ПХ определенно это тоже не разрешимый предикат, как мы уже выяснили.
То есть можно еще так, чуть подлиннее формулу написать.
Можно писать, что это множество таких П,
что для любого Х существует Т.
Значит, что У от ПХ
останавливается за Т.
Но вот эти вот два квантора для любого существуют,
намекают на то, что это не будет ни перечислимо,
ни, как говорят, ко-перечислимо.
Ко-перечислимо означает вот это, что дополнение перечислимо.
И вот это, что мы уже выяснили,
что это не будет ни перечислимо, ни, как говорят, ко-перечислимо.
Ко-перечислимо означает вот это, что дополнение перечислимо.
Значит, смотрите, в перечислимости у нас один квантор существования,
потому что проекция.
Или может быть много, но все кванторы существования.
Тогда это как один квантор по К-бочке.
Вот в ко-перечислимости у нас получилось вот здесь квантор всеобщности.
Для любого верно там что-то.
Нужно добавить, чтобы в скопках получилось что-то разрешимое.
А здесь получилось, что сначала квантор для любого, потом существует.
Ну и вот это вот на самом деле, значит, Т будет не перечислимо
и не ко-перечислимо, то есть Т с чертой тоже не перечислимо.
Давайте еще один пример, а потом будем изучать, как это все доказывать.
Доказывать, что что-то не перечислимо и не ко-перечислимо.
Еще один пример, давайте конечную область определения.
FD, finite domain.
Это может таких программ, то у от p и второго аргумента имеет конечную область определения.
Как это записать через кванторы?
Что такое вообще конечное множество?
Это означает, что есть какой-то предел, что после него уже нет никаких элементов множества.
Вот так и можно написать.
Это означает, что тут существует...
Там такое... Нет, сейчас им большой, наверное, нехорошо будет путаться.
Если существует m, для любого n больше m и для любого t,
значит будет, что от p и n не остановится за t шагов.
Видите, тоже два квантора, но другие, чем здесь.
Здесь для любого существует, там существует для любого.
Это все неспроста, это нас все потихоньку подводит к формальной арифметике,
которую мы, наверное, через пару лекций обсудим.
Теперь давайте обсудим, как доказывать...
Вот это fd тоже не перечислимо и неко перечислимо.
fd не перечислимо.
fd с чертой тоже не перечислимо.
Основной инструмент, как это все доказывать, называется m-сводимость.
Инструмент m-сводимость.
Значит, только и буквка m никто точно не знает.
Есть две стандартных расшифровки.
Одна расшифровка – это mapping predictability.
Mapping – это отображение.
Сейчас у нас будет отображение.
А второе – это many to one.
В смысле, что это не взять на инъекции, это отображение.
Но и действительно сейчас у нас будет вполне себе many to one.
Хорошо.
M-сводимость – это вот что такое.
Определение.
Это отношение на множественных или на языках.
Это множество a.
m-сводится к множеству b-a.
Если верно следующее.
Если существует тотально вычислимая f, такая что для любого x верно следующее.
x лежит в a тогда и только тогда, когда f от x лежит в b.
Зачем эта штука нужна?
Основные свойства m-сводимости.
Ключевое, наверное, следующее.
Если у нас множество разрешимо, и к нему что-то сводится другое множество, то это другое множество тоже разрешимо.
В чем вообще общая идея сводимости, скажем, одно из задачек другой?
То означает свести задачку уже решенной.
Но это означает, что то решение, которое есть для уже решенной, можно применить и для той, которую мы свели.
Соответственно, вон как раз ключевое свойство, что если a сводится к b, значит a-b разрешимо, то тогда a тоже разрешимо.
Так, как это доказывается?
Другим цветом буду, конечно, писать.
Ну, можно по-разному писать.
Вообще мы про похожую вещь уже говорили.
Когда говорили, почему неразрешимый проблем остановки, то мы не явно такую штуку использовали.
Если вы умеете решать задачу b, то по x из a вы посчитаете f от x.
То есть не из a, а про x, про который нужно выяснить, лежит он в a или нет.
По этому x вы посчитаете f от x, про f от x выясните, лежит он в b или нет.
И тот же самый ответ годится для a.
Но форму можно такую написать.
Значит, характеристическая функция множества a от x это будет просто характеристическая функция b от f от x.
Ну и, соответственно, поскольку f тотального числимо и хи b тоже тотального числимо, то композиция тоже тотального числимо.
То есть вот это вот будет тотально вычислимое как композиция тотального числимо.
Ну а это и означает, что и a тоже будет вычислимым.
Это означает, что a разрешима.
Явно отмечу.
Значит, получаем, что хи а вычислимо.
Сюда получаем, что а разрешима.
Так, вроде стихово можно открыть обратно.
Второе.
Ну, вторая транзитивность.
Значит, если а им сводится к b, значит, а b им сводится к c, то тогда а им сводится к c.
А а им сводится к c.
Вот. Значит, это почему?
Ну, тоже примерно так же.
То есть тут нужно написать, что х лежит в a тогда и только тогда, когда f от x лежит в b.
А это тогда и только тогда, когда g от f от x лежит в c.
Ну и, соответственно, вот эта композиция тоже будет тотально вычислимой.
И соответствующий условие будет верно.
То есть g в композиции с f тотально вычислимой.
Так, хорошо. Какие у нас еще будут нужные свойства?
На самом деле, пункт один, он верен не только для разрешимых, но и для причислимых множеств.
Значит, вот это давайте поймем.
Значит, если a сводится к b, а b перечислимо, то тогда a тоже перечислимо.
Вот. Это у нас есть разные определения перечислимостям.
Ну, например, можно сказать так, что пусть b это область определения какой-то функции g.
Значит, b это область определения g.
Тогда получается, что a...
Так, сейчас давайте это еще тут распишем.
Что это значит? Это значит, что x лежит в b.
Тогда и только тогда, когда g определено.
А a тогда будет равняться области определения от g в композиции с f.
Потому что получается, что x лежит в a.
Тогда и только тогда, когда f от x лежит в b.
Это тогда и только тогда, когда g от f от x определено.
Ну и, соответственно, если у нас b был и перечислимым, то g вычислимо.
А f тотально вычислимо, значит g в композиции с f тоже вычислимо.
Не обязательно тотально, только f тотально вычислимо.
И, соответственно, ее область определения это в точности a.
Их лежит в a тогда и только тогда, когда вот эта штука определена.
Можно еще пять других рассуждений привести для других свойств.
Ну, ограничимся одним.
Так, хорошо, значит, что нам еще нужно?
Ну, есть еще очень простое свойство, но при этом важное.
Значит, простое свойство такое, что a им сводится к b.
Тогда и только тогда, когда дополнение k им сводится к дополнению b.
Ну, тут на самом деле просто та же самая f подойдет.
Значит, тут подойдет та же f.
Поэтому это очень просто.
Значит, получается, что x лежит в a с чертой тогда и только тогда, когда x не лежит в a.
Это тогда и только тогда, когда f от x не лежит в b.
И это тогда и только тогда, когда f от x лежит в a с чертой.
Так, ну, наверное, даже там достаточно свойств.
Дальше, соответственно, следствие будет такое.
Следствие из третьего.
Следствие, наоборот, что если a сводится к b и a неперечислимо,
то тогда b неперечислимо.
Это такая контрпозиция.
Если a сводится к b, значит, и a неперечислимо,
то тогда b тоже неперечислимо.
Вот такое следствие.
Значит, у нас это есть.
Еще у нас есть неразрешимые проблемы остановки.
Значит, еще есть одно следствие.
Значит, из того, что h перечислимо, но неразрешимо.
Значит, следствие просто что h с чертой неразрешимо.
Не, извините, неперечислимо.
Неразрешимо, конечно, тоже, но и неперечислимо, потому что есть теория Маппоста.
Да, теория Маппоста говорит, что если нож твоего дополнения перечислим,
то само множество разрешимо.
Если множество неразрешимо, но перечислимо, то его дополнение
обязано быть неперечислимым, иначе оно само было бы разрешимым.
Хорошо, то есть у нас есть вот этот принцип, есть то, с чего начинать.
Соответственно, можем доказывать разнообразно другие множества, что они неперечислимы.
Так, ну вот, давайте посмотрим на примеры применения.
Вот как раз из тех множеств, которые мы изучали.
Первое, значит, первое, что множество c, помните, что это?
Это значит, констант на своем гостиопределении.
Значит, множество c неперечислимо.
Но для этого нужно показать, что вот это h с чертой к нему сводится.
Нужно, что h с чертой m сводится к c.
Ну, это очень легко.
Смотрите, что нужно делать.
Мы рассмотрим вот такую функцию.
Ну, не знаю, скажем, q ее обозначим.
А, ну и ладно, давайте этим цветом.
Значит, q от t это будет вот что.
Это будет единица.
Единица, если у от px не остановилось за t шагов.
Вот, и ноль иначе.
Тогда смотрите, что получается.
Получается, что если у от px, значит, если у от px останавливается,
то тогда q от t тождественно равно единице.
А тогда получается, что q у нас лежит в c.
Так.
Нет, сейчас я неправильно писал.
Вот тут не останавливаться должно быть.
Значит, не останавливается.
Да, значит, смотрите.
Не останавливается, значит, не останавливается ни за какое конкретное время.
Значит, какой бы t тут ни было, будет единица, значит, будет всегда единица.
Ну, вот, и все.
Ну, вот, и считай, что всё-таки за ноль шагов,
никакая функция не остановится.
Да, хотя бы один шаг нужно сделать.
Давайте считать.
Что, хотя бы перейти и завершать считай, это уже хотя бы один шаг.
Да, поэтому если t равно нулю, то всё-таки точно будет единица.
Т.е. мы не будем считать, ну, что это будет,
и мы будем считать, что у нас будет,
то у нас будет 1,
но я не понимаю, как это будет?
будет единица, а за какое-то число остановится, то с кого-то момента будет ноль.
Если у от px останавливается за там t большое шагов, то тогда получается, что q
от нуля равно единице, значит q от t большое равно 0.
Из этого следует, что q не принадлежит с.
Вот и получилось, глобально получилось, что px не лежит в аж тогда и только тогда, когда q лежит в с.
Остается, однако, вопрос, почему этот переход от пары px к q вычислимый?
Почему переход от пары px к q вычислимый?
Это вопрос, на самом деле, не такой простой, как может показаться.
На самом деле ответ такой, что это на самом деле не всегда так.
Нужно некоторые специальные тонкие свойства универсального членимых функций.
Но если это нормальная универсальная членимая функция, которая делается из универсального машины тюринга, то это будет верно.
Или проще даже рассуждать не из терминов универсального машины тюринга, а в терминов какого-нибудь обычного языка программирования.
Смотрите, что вообще означает? Вопрос такой, откуда q берет пару px?
Пары px не поступают как аргумент, как аргумент поступает только t.
Но можно сказать, что это такой параметр.
То есть можно сказать, что прямо в тексте программы q должны быть заданы px.
Ну и, соответственно, если программа q выглядит как на нормальном языке, то будет так.
Сначала под программа p, которое такое-то, такое-то, такое-то, там число x, которое такое-то, такое-то, такое-то.
И потом мы запускаем компилятор на этой штуке, на t шагов.
То есть программа q выглядит как просто компилятор машины у со счетчиком шагов.
И с изначально записанными прямо в тексте программы px.
Но ясно, что преобразование px в такую программу, это будет вычислимое преобразование.
Просто у нас будет шаблон. Вот как бы p равно тому-то, x равно тому-то.
Дальше мы, соответственно, запускаем все как надо.
И, конечно, преобразование пары px в эту программу q, это будет просто подстановка в шаблон конкретных значений px.
И если у нас программы выглядят так, то, конечно, эта штука будет вычислимая.
И для машин тюринга, конечно, это будет так. Можно взять специальные состояния, которые будут печатать px,
а потом переходить в новую машину, которая будет вот это все делать.
Да, это, конечно, какая-то такая сложная штука, там шаги еще как-то надо считать.
Но, в общем, в эти детали мы лезть не будем. Интуитивно, в нормальном языке программирования,
переход от px q, это будет просто подстановка в шаблон констант.
И это, конечно, простая строка в операции, которая будет вычислимая.
Так, сейчас это я отдельно напишу.
Так, значит, в нормальном языке программирования, в калычках,
в нормальном языке программирования,
переход от пары px q, это просто подстановка в констант в шаблон.
Вот, а в ненормальном тому утверждение может быть неверно.
И даже, наверное, утверждение о том, что с, посмотрите, то, что с неразрешимо,
и это вообще не зависит от того, какой именно универсальный шаблон.
И даже, наверное, утверждение о том, что С неразрешимо.
И это вообще не зависит от того, какое именно универсальное
языкопрограммирование, то есть какая именно универсальна
вычисленная функция. Независимо от этого,
проблем в самбремении всегда будет неразрешимо.
И проблем в остановке, наверное, тоже.
А вот это вот проблема может и будет.
Это тонкие вещи, мы это немножко обсудим на следующей лекции.
Но вообще это скорее такой дополнительный материал.
Что такое нормальное формально, это мы тоже в следующий раз обсудим.
Значит, в ненормальном переход может быть и не вычислил.
Хорошо. Что такое нормальное и ненормальное?
Обсудим в следующий раз.
Пока, наверное, что еще сегодня обсудим?
Это вот про задачу о патальности.
Почему язык Т не перечислимый и некоперечислимый?
Почему язык Т не перечислимый и некоперечислимый?
Почему язык Т не перечислимый и некоперечислимый?
То есть его дополнение тоже не перечислимо.
Это второй пример.
Т не перечислимый и некоперечислимый.
То есть Т с чертой тоже не перечислимый.
Но тут, смотрите, исходя из всего предыдущего,
получается, что нам достаточно доказать две вещи.
Нам достаточно, чтобы было H вводилось к Т.
И H с чертой вводилось к Т.
Сейчас я подумаю, что мне лучше.
Давайте тоже черту переставлю вот сюда.
Это для чего нам нужно было четвертое правило,
что неважно с какой стороны черта стоит.
И это будет одно и то же.
То есть у тиждей нам вообще нужно было, чтобы H с чертой
сводилось к Т, с чертой сводилось к Т.
Но доказывать будет удобнее, когда черта перенесена в другую часть.
Хорошо, значит нам нужно две сводимости.
Ну и сейчас их обсудим.
Первая часть, что H сводится к Т.
Но тут, смотрите, я определю так, что опять же пара Px
переходит в Q.
Такое, что Q от любого T будет на самом деле от T не зависеть.
А будет равно просто у от Px.
То есть тут вход, аргумент фиктивный.
Вот это T, оно вроде как есть, но никак не используется при вычислении.
И сразу программа уже сама знает, что делать.
На место того, чтобы использовать аргумент, она запускает другую программу.
Ну и, соответственно, если у от Px останавливается, то U facial
сразу везде определена.
Если у от Px Charge не останавливается, то Q нигде не определяна,
но, в частности, не везде определена.
Тут подробнее напишу.
Значит, P от X лежит ваше.
Тогда получается, что у от Px останавливается.
Отсюда получается ли для любого T, U от T останавливается.
То есть вот следующая, что Q лежит в Т.
вот значит если p от x не лежит ваш то тогда у от p x не останавливается тогда
для любого t у от и не останавливается ну и тогда куне лежит в общем получилось
получилось по x лежит ваш тогда только тогда когда ку лежит ты то есть аж велик ты
ну и переход будет опять же всюду определенную ну по тем самым причинам да тоже на сайт
там есть сложное рассуждение что на самом деле тут само утверждение будет опять для любого
верно вот но это мы ну может некоторых самых сильных группах может быть обсудят
вот но в общем на лексам это не будем обсуждать есть более сложное рассуждение
про говорит что в любом случае вот это t будет не перечисливаемый никак перечисливаем так
значит и вторая часть вторая часть что аж сводится к тес чертой
сводится к тес чертой здесь уже аргумент будет использоваться значит здесь будет
так а счетом будет то же самое что раньше ну-ка давайте посмотрим подойдет нам вот это вот
а не совсем подойдет нам место нуля нужно будет неопределенность дальше пример такая
же штука так значит куа те будет единица если у от пейкс не останавливается за те шагов
и не определено иначе
так соответственно дайте аккуратно проверим и на этом сегодня завершим
значит получается что если пара пейкс лежит ваш то что получается получается что существует
и существует это кое-что вот пейкс остановится за те шагов
значит отсюда получается что существует и только вот и не определено
ну и значит ку не лежит в те
не лежит в те вот значит а если это не остановится
значит если программа п на фуде икс не останавливается то тогда получается что для любого
т у от пейкс не остановится за те шагов отсюда получается что для любого
т куа т равно единица и тогда соответственно ку у нас лежит
вот ну вот вот и получилось свадимость то есть пейкс лежит ваш тогда и только тогда когда ку
не лежит в те ну то есть вот как раз то что нужно
ну все значит это у нас велось все значит у нас есть две свадимости
неперечислимого к т его дополнению значит это непричислимый дополнитель ты тоже не
причислима а это нам и нужно было вот вот такое рассуждение на что в следующий раз обсудим
следующий раз во-первых я самая расскажу в общем что что означает нормальный язык и что
означает не нормальный а в суде почему универсальный машин тюнг это нормальный язык вот а также
на фоне почему бывают не нормально языке значит а именно окажется что не только вот эти все
примеры будут по крайней мере не разрешимыми но и вообще любое свойство программ в нормальном
языке если только есть программы которые обладают этим свойством программы которые не
обладают будет не разрешимым это называется тирема успенского райса вот вот ее мы обсудим а еще
мы обсудим программы которые с собственным текстом работают да например теорема есть такая что в
любом языке программирования есть так называемый куайн куайн это программа которая свой собственный
текст печатает на этом же языке программирования вот вот оказывается что в любом опять же нормальном
языке есть куайн и это мы тоже докажем через теорему подвижной точки спасибо за внимание приходите
