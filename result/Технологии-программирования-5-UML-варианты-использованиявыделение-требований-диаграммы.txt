Всем доброго дня! Мы с вами продолжаем изучение нашего курса и сегодня мы детальнее будем
говорить про UML и просмотрим все виды диаграмм, которые могут быть полезны. Это, так сказать,
наша лекция предурочена к тому, что через неделю уже сдавать первую итерацию проекта,
поэтому нужно детальнее разобрать некоторые части, которые, возможно, вы уже сами нашли,
но нужно каким-то образом это дополнить. В прошлый раз мы с вами начали с того,
что мы посмотрели два способа выделения классов. Давайте еще раз их напомню. Первый способ это
CRC-карточки, то есть это мы делаем небольшие карточки, они обычно определенного объема. У нас
выделяется какой-то объект, который мы выделяем в класс, и после этого мы пытаемся определить имя
класса, его ответственности и кто с ним взаимосвязан. После этого, на самом деле,
когда вы имеете такой объект, вы можете уже легко на самом деле составить не только диаграмму
классов, но и диаграмму объектов, то есть когда вы показываете именно взаимодействие между конкретными
экземпляров класса. Вот, допустим, здесь у нас на примере есть CRC-карточки для продажи, то есть
за что у нас отвечает продажа, то есть он отвечает за знания, за поведение, за промоушн. Это скорее
всего именно продавец. Кто у него коллаборатор, это у него партнера и это клиент. То есть у нас
сразу, если мы говорим про EML-диаграмму, у нас у класса Sales появляется связь с классами партнера
клиента. Если мы говорим про транзакцию, собственно, здесь у нас методы MinyTransfer и Audit,
значит коллаборатор это у нас тоже клиенты, то есть у нас получается уже, дайте-ка, EML найду.
Взаимосвязь, то есть у нас есть класс Sales, значит он взаимодействует с партнером,
и с клиентами. Мы не понимаем какое вид связи, это нужно детальнее уже рассматривать. Дополнительно
у нас с вами есть заказ. Заказ взаимодействует с Customers и видно, что у заказа прямо есть
некоторая ответственность. Значит смотрите, как здесь можно определять какие у нас поля класса,
а какие у нас методы класса. Вот давайте поймем. Вот у нас есть price, у нас и stock, есть valid
payment. Что из этого скорее всего будет методом, а что полями? Да, price, stock,
то что мы можем сказать в русском языке называется как-то, не отглагольный существительный,
какой-то другой термин, то есть существительный, который выделяет некоторые действия. Вот,
то тогда мы можем сказать, что это метод, то есть скорее всего у заказа будет метод validate
payment. И дополнительно мы видим с вами, что у нас допустим у того же класса delivery, доставка.
Опять же это не конкретные объекты классов, они могут у нас уточняться с течением времени. То есть
мы с вами уже по крайней мере по двум классам выявили какие связи между ними есть. Дополнительно
у нас с вами у класса транзакции тоже есть ссылка на клиента. Значит, смотрите, здесь сразу нужно
сказать, кто такой клиент. Это либо объект-экземпляр класса, либо это некоторое действующее лицо. То есть
возможно, что это не экземпляр класса, это просто такой человечек его обычно обозначают, который
будет взаимодействовать со всем остальным миром. Он сидит перед компьютером и выполняет какие-то
действия. То есть здесь мы выделяем несколько суставных частей. То есть скорее всего это
будут у нас классы. Возможно, что, кстати, sales это тоже некоторое действующее лицо, которое сидит
по ту сторону системы и тоже пытается работать с нашей системой. Так, это что касается CRC-карточек.
Теперь давайте вспомним, в чем заключается метатаббот. Мы выделяем существительные, объединяем
некоторые синонимы, исключаем числительные или существительные, которые обозначают количество,
исключаем эфемерные слова, данные информации и дополнительно мы исключаем слова, не подходящие к
предметной области. Понятно, что последняя сфера, последний пункт отвечает за то, что нам действительно
нужно пойти к человеку, который работает в этой предметной области, выяснить действительно
ли нужны эти существительные или нет. Давайте вспомним вот этот пример. Значит, у нас, кажется,
мы с вами уже выписывали все существительные и пытались выделить классы. Так, давайте подумаем.
Давайте еще раз повторим это. Какие у нас есть существительные? У нас есть служба. Что еще? Давайте
перечислять. Клиент. Да, еще что? Транспорт. Маршрут. Там, кажется, еще история есть.
Что еще? Плечо. Значит, виды транспортов мы определили с вами, что у нас есть тип,
тип маршрута, тип плеча, и мы скорее всего поняли, что это у нас будет енам. Опять же,
нужно будет посмотреть, является это енамом или является это активным классом, который
будет менять свое состояние. Так, еще есть такая вещь, как доставка и получение.
Так, что еще? Да вроде все из таких основных моментов. О, путь.
Так, хорошо. Давайте поймем, где здесь синонима. Здесь скорее всего есть синонима. Путь и маршрут,
да, это синонима, поэтому оставляем только одно из них. Скорее всего лучше сказать,
что это маршрут. Класс Путина у нас уходит. Служба класс нам нужен. Да, это что-то все облемающее,
поэтому в прошлый раз сказали, что этого нам не надо. Хорошо. Клиент. Можно его сделать частью
заказа, но в принципе, если мы хотим, чтобы клиент был в нашей системе как отдельное лицо,
то скорее всего лучше сделать его уже классом. Вы заходите на сайт. Да, но смотрите, здесь,
если мы говорим про систему, то скорее всего клиент будет играть в двух апостасиях. Во-первых,
это собственно экземпляр класса, и скорее всего это уже будет не клиент, а какой-то
пользователь нашей системы, а сам клиент будет скорее всего действующим лицом, актором.
Вот, значит, история. Кажется, еще один момент. Является ли история классом? Да, это запись. Это
некоторая запись действия. В принципе, ее можно оставить для того, чтобы явно обеспечить,
что у заказа есть какая-то история перемещения. Тут вопрос будет состоять в том, хранить ли это
все в маршруте или нет. Хорошо. И давайте теперь последний момент. Доставка и получение. Будут ли
это экземплярами классов? Ой, будет ли это классом? Да, это некоторое действие. Поэтому,
скорее всего, это перейдет в методы нашего класса. Все. То есть у нас получается с вами остаются классы
клиент, заказ, транспорт, маршрут, либо история, плечо, тип плеча, ну и все. Значит, смотрите,
теперь давайте посмотрим. Служба выполняет доставки заказов клиенту. Значит, доставка
заказа шляется по маршруту. То есть получается, что у нас с вами? У заказа есть какой-то маршрут.
Дальше. Значит, маршрут состоит из последними соединенных плеч. Скорее всего, это будет у нас
какая-нибудь ассоциация. Почему плечо является ассоциацией не композиции? Ровно по той причине,
что плечо может быть такое же у другого маршрута. Просто у нас есть какой-то перевалочный пункт,
по которому у нас доставка идет. И для каждого плеча у нас есть атрибут. Какой-нибудь плюс транспорт.
Понятно, что мы не специфицируем транспорт. И здесь нам нужно принять следующее решение. Мы
отвечаем за транспортировку или кто-то внешне отвечает за транспортировку. Если значит,
за транспортировку отвечаем мы, то есть мы вообще компания по перевозу там занимаемся именно
перевозками. Но тогда нам нужно будет описывать вот эту вот часть деталей. Если нет, то оставляем
это за пределы системы и выносим это в другую сущность. Так, значит, заказ у нас есть. Начальное
плечо, это передача в доставку, конечное его получение. То есть, это именно описание деятельности.
Значит, служба ведет историю заказов для каждого клиента. У нас есть, наверное,
какой-нибудь history storage. Ну, storage мы не будем писать. Лучше его называть. У нас служба ведет
историю заказов для каждого клиента. Тут скорее всего будет связь. У нас с вами это будет
клиент. Значит, получается история. У нас связывается с клиентом. Тут надо решить,
что это такое. То есть, возможно, что здесь у нас будет список заказов. То есть, это делается
по соотношению 1 к звездочке. А клиент будет иметь свою собственную историю. Здесь нужно будет
определить. Это у нас 1 к 1 отношение будет, то есть у каждого клиента ровно одна история.
Либо может быть так, что у нас один экземпляр клиента может иметь несколько историй. Почему
такое может быть? Потому что клиент может попытаться идентифицировать себя разными способами.
То есть, сначала он, допустим, авторизовался по номеру телефона, потом он ввел почту. На самом
деле это может быть один и тот же клиент. Просто потом нужно будет сделать так, чтобы все эти
аккаунты соединились в один у нашего пользователя. Такая процедура, возможно, должна быть предусмотрена
в системе. В целом получается вот такая базовая диаграмма классов. Опять же, они тут у нас очень
даже просто взаимосвязаны. Паятель это пример. Мы по факту делаем следующее. Мы выделяем
существительное, мы выделяем действие и смотрим какое следующее существительное с ним завязано.
Здесь как раз мы применили композицию метода ABOTA плюс метод CRC-карточка, когда я рассказал про это
взаимодействие. Тут еще доставка и получение. Это мы можем делать специальный идентификатор
про заказ. Это можно оставить. Тут если выкинуть все эфемерные слова, то получается следующее.
Заказы, маршруты, плечо, путь. Плечо, маршруты, в принципе, эфемерные. Заказы, маршруты, плечо, путь.
Мы еще выделили с вами клиенты и историю. Здесь у нас как раз некоторое соответствие есть другое.
Так, давайте теперь мы отмотаемся обратно, потому что на самом деле про классы нужно поговорить еще
детальнее. Перейдем в поведенческую роль. И здесь нам очень важно будет рассказать, что же такое
варианты использования. Что такое варианты использования? Это сценарий взаимодействия наших
клиентов с программным обеспечением. При этом нам здесь нужно выделить очень важные границы
нашей системы. То есть, что должна делать система, а что должны делать мы как клиенты. Обычно есть
специальная диаграмма вариантов использования. И они обозначаются вот таким образом. Здесь мы
стараемся как раз максимально четко выделить требования к нашей системе. Именно функциональные
требования, которые выполняют определенную роль. Смотрите, из чего состоит диаграмма. Видите
человечков в этой диаграмме? Это действующие лица, то есть кто есть в нашей системе. У нас с вами
в нашей системе по одну сторону есть официант, клиент, и кэшер это кассир, а с другой стороны у
нас есть шеф. При этом у нас есть с вами, вот смотрите, здесь главное не углубляться в деталях,
а прописать вот основные сценарии поведения вашей системы. То есть, что у нас может сделать клиент?
Он может заказать некоторую еду, съесть эту еду, у нас же все-таки ресторан, и заплатить за еду.
То есть, в принципе, даже видно в каком порядке они идут. Да, можно заплатить за еду до, если у вас
допустим онлайн заказ. Дополнительно, что здесь мы видим с вами? Здесь есть несколько вариантов
расширения этого всего дела. Сразу скажу, что в отличие от основных диаграмм классов, у нас в
диаграмме классов есть только наследование, по факту, и есть какая-то взаимосвязь между ними. Здесь
есть два атрибута. Первый атрибут взаимоотношения между двумя вариантами использования это отношение
include. Значит, что она означает? Если у нас есть вариант использования A, есть вариант использования B,
то мы можем сказать, что один из них включает другой. То есть, у нас есть некоторые шаги
варианта использования B. То есть, шаг 1, шаг 2. Дальше мы говорим, что у нас включается вариант
использования A, 3 и 4. То есть, это как раз именно включение этих пунктов. Давайте пример. Какое-нибудь...
Сейчас, сходу попробую придумать. Когда у нас какое-то действие включает себя в другое.
Ну да, допустим, если мы говорим про оплату какого-то заказа, то, в принципе, он себя включает,
так сказать, добавление товара в корзину. Потому что, как бы, без добавления товара в корзину мы
действительно не оплатим заказ. То есть, у нас сначала идет вариант A, потом у нас идет, в зависимости
от него, вариант B. Есть второй способ. Это расширение. Он обозначается так. У нас есть вариант
использования A, и вариант использования B расширяет вариант использования A при наступлении
определенного условия. К примеру, вариант использования посетить, пройти медосмотр.
Медосмотр. Здесь, не поверите, напрашивается очень простое расширение.
Причем два варианта расширения в зависимости от пола. Смотрите, если клиент у нас,
это человек мужского пола, то у него будет одно расширение. А если перед нами клиент
женского пола, то мы идем в другое место. Все достаточно просто. То есть, как бы, при наступлении
условия, мы с вами посещаем разных врачей. А с другой стороны, у нас тоже есть как раз действующие
Значит, это у нас один врач, а это у нас другой врач. Вот, то есть, вот такие вот варианты. Главное,
что нам нужно будет здесь определить границы системы. И здесь важно как раз, когда мы говорим
про варианты использования, четко прописать с каждой стороны, что именно делается, что делают
клиенты, что делают акторы, а что делает система в этот момент времени. То есть, допустим, если мы
говорим про медосмотр, давайте поговорим про посещение врача, то в чем у нас будет заключаться
последовательность действий. Ну да, ну давайте для медосмотра. Значит, первое, клиент заходит к врачу.
Второе, ну клиент заходит к врачу. Дальше что делает врач? Врач делает запрос в систему
о клиенте. Значит, третье, значит, если запрос у нас успешен, а мы полагаем, что запрос у нас
успешен. Значит, врач опрашивает клиента и вносит записи. Дальше, значит, врач нажимает на кнопку
«сохранить». Система должна синхронизировать данные, ну и выдаёт вердикт. То есть, печатает
бланк заключения. Ну вот, такой вот пример. Значит, что здесь может пойти не так? Ну, во-первых,
первое, что делает запрос системы может быть неуспешным. Тогда мы делаем альтернативный
сценарий. Говорим, что если на шаге два у нас что-то пошло не так, то шаг 3.1 будет
заключаться в том, что врач скажет, что у вас нет системы. Увы, я не могу вас принять. Это
первый сценарий. Второй сценарий, если система выдала ошибку, допустим, на время запроса,
то тогда в роль включает системный администратор и мы переходим, допустим, в вариант использования
«разберись с проблемами в системе», образно говоря, там устранение ошибки в софтеризации. Значит,
здесь, опять же, врач опрашивает клиента и вносит запись в систему при сохранении
синхронизации данных. У нас, опять же, может произойти ошибка синхронизации данных. И это
у нас будет ещё один вариант сценария 5.1, альтернативный, который мы с вами описываем.
Собственно, это я сейчас показал на примере, и каким образом описывается у нас сценарий use
case. У нас с вами есть название, варианты использования, дальше действующие лица,
после этого у нас есть основной сценарий и дальше есть альтернативный сценарий. Я как раз подготовил
пример, чтобы не было это всё эфемерно. Давайте я его как раз открою. Наверное,
я этим поделюсь с вами этими примерами. Это, собственно, некоторые варианты использования,
которые были в системе Ahchak. Правда, сразу скажу, что эти варианты использовались где-то уже год
с лишним. Смотрите, первый вариант использования. Назначить студенту преподавателя. Это происходит
по время регистрации в системе. У нас есть ущельица, администратор и система. Здесь у нас нету
ни студентов, ни препадавателей. По факту именно администратор действует системой. Администратор
заправляет запрос системы, которая состоит из студента-припадавателя курса. Система проверяет,
что преподавателе-студент зарегистрирован на курсе. Если у нас они не регистрированы,
то должен быть альтернативный сценарий. Система создает запись базы данных, состоящую из трёх
полей. Студент-тичер-курс. Система проверяет, что для курса и студента нету назначенного
преподавателя. Там это поле уникальное, чтобы для студента и преподавателя у нас ровно одна
связь была. Хотя, скорее всего, с учетом того, что мы будем проверять проекты, это немного поменяется.
Вот альтернативы и сценарий здесь нету. Пример. Второй. Получить список заданий на проверку.
Собственно, действующие лица здесь. Это преподаватель и система. Основной сценарий.
Преподаватель нажимает на кнопку проверка заданий. Система отправляет запрос баз данных.
Вот. Третий вариант. Значит и система возвращает список submission для клиентов. То есть видите,
эти сценарии не прописаны четко. То есть они зачастую именно определяют бизнес требования,
которые у нас должны быть. В общем, я пришлю здесь этот вариант, чтобы вы поняли. А вот,
кстати, кнопочка отправить задания на проверку ревью преподавателя. Значит,
в случае нарушения условия 2 основного сценария системы удавляет пользоваться, что не может
отправить задания на проверку. То есть вот такие вот базовые вещи. Здесь мы явно прописываем.
Смотрите, у нас есть какие-то требования. Они могут быть функциональными, то есть по функции,
а могут быть не функциональными. И вот, чтобы вы как раз это понимали, какие требования бывают
функциональными или не функциональными, я нашел отличный слайд, который это показывает. Так,
мне кажется, тут со светом плохо, да? Блин. Ладно, давайте я прочитаю тогда. Значит, обычно
требования, которые мы предъявляем, они делятся на несколько основных частей. Первое, это бизнес
требования. Второе, это требования пользовательские. И третье, это системные требования. Значит,
если мы говорим про бизнес требования, это то, что важно именно с точки зрения бизнеса. almonds
són пользовательские это как раз с точки зрения клиента, который пользуется нашей системой,
а системные требования это те требования, которые важны именно с точки зрения ПО,
О, которое мы обеспечиваем. И вот смотрите, в чем особенность. Сразу скажу, что чтобы понять,
какое у нас требование перед нами функциональное и не функциональное, нужно понять на какой вопрос
мы отвечаем. Если мы говорим про функциональные требования, то мы отвечаем на вопрос «что». Если
не функциональное, то вопрос «как». Давайте пример. Функционально ограничить доступ
помещения нам нужно. Как? Система не должна организовывать скопление пользователей. То есть,
как мы говорим, следующее, что ограничить доступ помещения — это наша основная цель. А вот не
функционально, допустим, для того чтобы не организовывать скопление народов, нам нужно
между людьми соблюдать дистанцию полтора метра. Тем самым мы не ограничим, точнее, как сказать,
ограничим количество пользователей. Следующий пример. Про полицкие требования. Пользователь,
имеющий право доступа, имеет возможность войти. Пользователь, не имеющий права доступа,
не может войти. Опять же раскладываем, уже декомпозируем нашу задачу. А как сценарий
проходит в помещение должен занимать не более двух секунд? Что это означает, что этот сценарий
должен занимать не более чем две секунды? Можем ли мы поставить человека на фейс-контроле,
чтобы этот сценарий у нас занимал не более двух секунд? Человек нет, поэтому нам нужна пропускная
система, которая, если что, нас свернет в альтернативный сценарий, который говорит проверить
пользователя по базе. Третье. Системные. Помещение должно иметь дверь со следующими
функциями. То есть, видите, уже спускаемся на реализацию, и оказывается, что реализация это
дверь. Значит, у нее должна быть функция открытие-закрытие, запирание-отпирание. То есть,
запирание-отпирание это означает следующее, что у вас дверь просто автоматически, просто вы
дергаете за дверь, у вас она не открывается. И дверь должна иметь... А дальше вот нефункциональные
требования к двери, к самой, что дверь должна иметь не более чем 70 сантиметров, а ключ должен
отпирать замок не менее чем за один оборот. Если у нас, допустим, будет три или четыре оборота,
то, скорее всего, если мы говорим про автоматическую систему, то вряд ли мы ее откроем
за две-три секунды. Да, то есть, мы прям декомпозировали это все на функциональные
и нефункциональные требования. Это вот на одном примере, связанных с проходом помещения. Так,
поняли ли этот слайд? Хорошо. И теперь давайте как раз поговорим про то, к чему же это все
вносится. Собственно, когда мы с вами специфицируем требования к ПО, то у нас есть некоторые бизнес
требования, которые мы можем предъявлять в системе, и у нас могут быть некоторые бизнес-правила.
То есть, это правила хорошего тона, которые у нас могут быть. Дальше из бизнес-стребований как раз у
нас определяются границы нашей системы. Вот как раз, что мы делаем, а что мы не делаем. Если мы
говорим в концепциях скрама, которые мы говорили с вами, то это так называемый продукт-реквайернц,
это требование к нашему продукту. Зачем он делается? Как вы думаете? Зачем мы должны
описать требования к нашему продукту? Заранее договориться о них. Чтобы не рисовать красных
единорогов посередине проекта, когда это захотелось заказчику. То есть, по факту,
это документ-граница, который позволяет нам сказать, что мы вот этого не делаем. После этого
уже как раз исходя из бизнес-правил и концепции границ, у нас возникают пользовательские требования.
То есть, допустим, что у нас тут должна появиться система, которая открывает наши двери. Дальше у
нас появляется документ пользовательских требований и по факту, где-то вот здесь вот по различным
спецификациям возникают варианты использования. То есть, как раз документ пользовательских
требований иногда еще называют документом о вариантах использования. Это все будет влиять
на функциональные требования к нашей системе. То есть, дальше мы уже будем спускаться на
архитектурный уровень. И как раз здесь уже для функциональных требований нам могут помочь
некоторые атрибуты качества, которые можно замерить. Система должна быть там гибкая,
адаптируемая и так далее. То есть, мы специально тоже их прописываем для того,
что получить наши требования. Дополнительно системные требования тоже могут влиять на
функциональные требования. Опять же главное, тут отделить функциональные и не функциональные
требования. И дополнительно у нас как раз могут появиться ограничения с нашей системы. То есть,
какие-то законодательные, регламентирующие, сертифицирующие. И мы получаем спецификацию
требований к программному обеспечению. То есть, по факту мы можем проработать дальнейшим
наши варианты использования для того, чтобы уже оставить
какие-то основные вещи.
Самое главное, не делите минимально вариант.
То есть, образно говоря, если у вас есть какая-то
игра, то вы в качестве игры можете сказать следующее,
изменить настройки уровней, уровней, настройки игры
— это вариант использования.
А вот изменить громкость игры — это уже не совсем
вариант использования, это уже некоторые реализации
варианты использования, связанные с тем, что изменяем
настройки игры.
То есть, крупными мазками все делаем.
Так, хорошо.
Давайте вопрос по этой части.
Тут и стоит задавать, можно даже глупые вопросы задавать.
Молчок.
Хорошо.
Давайте тогда мы поедем дальше, поговорим не про
некоторые поведенческие диаграммы, которые позволяют
описать связь наших объектов.
Первый из диаграмм, который очень часто используется
и вам понадобится по жизни — это диаграмма последовательности.
Значит, что мы с ней сделаем?
Мы с вами по факту из нашей системы, после того, как
выделили варианты использования, мы как раз попытаемся реализовать
один из вариантов использования, которые здесь есть.
Их можно реализовать несколькими способами.
Первый способ реализации — это диаграмма последовательности.
Второй из способов — это диаграмма активности.
А третий из способов — это диаграмма состояния.
Поговорим с вами сначала про диаграмму последовательности.
В чем ее суть?
Ее суть — показать в течение времени, как происходит
процесс.
Что происходит?
Мы с вами из акторов и из нашего клиента, из нашей
системы выделяем, во-первых, действующее лицо, раз, а
во-вторых, выделяем по экземпляру наших объектов.
То есть у нас ордер, двоеточие, ордер.
То есть это конкретный экземпляр.
И дальше мы с вами показываем на, так сказать, линейной
шкале, на шкале времени, что происходит.
Значит, смотрите пример.
У нас с вами, допустим, есть система с банкоматом,
и у нас здесь есть действующее лицо.
Это клиент нашего ATM.
Дополнительно у нас с вами есть, смотрите, важно, что
это не класс, это не класс ATM и класс банк-сервер.
Это именно экземпляры класса банкомат и экземпляры
класса банковский сервер.
Что мы делаем?
Значит, здесь бывают следующие методы.
Очень важно.
Опять же, небольшой технический заброс на будущее.
Бывают методы синхронные.
Что означает синхронный метод?
Вы по факту так вызываете любую функцию.
То есть вы вызываете функцию, ожидаете результат его исполнения.
Бывают функции асинхронные.
Что означает функция асинхронная?
Вы отправили какой-то запрос, и результат вам сразу не
приходит.
Вы можете делать действия в дальнейшем.
Классический пример.
Вы заходите на госуслуги, нет, вы заказываете какую-то
справку.
Вам же справку сразу не выдают, вам отдают справку
только через некоторое время, и то в отдельном письме.
То есть вы получаете ответ на ваш запрос при помощи
некоторого ответного действия.
Допустим, функцию, которую вы должны вызвать после
того, как ваша функция отработает.
Это называется колбэк.
И на диаграмме последности это тоже можно продемонстрировать
при желании.
Система.
Что здесь прописывается?
Здесь прописывается вариант использования авторизации
в банкомате.
Действующие лица.
Это клиент, это ATM и это банк-сервер.
Что делает ATM customer?
Он вставляет карту.
Это асихронное действие в данном случае.
Дальше, что у нас происходит?
У нас с вами ATM запрашивает информацию у банковского
сервера, можем ли мы верифицировать карту.
А дальше в зависимости от ответа у нас возникают
два альтернативных варианта.
Первый вариант альтернативный, это если у нас карта окей,
тогда мы клиенту отправляем запрос введите пароль.
Этот запрос будет синхронным.
То есть мы ждем пока клиент введет пароль и возвращаем
результат.
Значит, стрелочки это возвращение результата.
А если у нас карта неволидная, то мы переходим на другой
альтернативный сценарий.
То есть тут видно прямо при помощи кнопки alt, при
помощи действия alt, вот там вот alt написано, что карта
неволидная и мы хотим вернуть карту.
Все, вариант использования заканчивается.
То есть здесь прямо по пунктам можно прямо прописать
из вариантов использования какие шаги мы с вами делаем.
Так, с этим примером, разобрались или нет?
Там сейчас будет еще один пример.
Он будет страшнее.
Все готовы?
Вот такой вариант использования.
Значит, что мы здесь делаем?
Это форма определения комментариев.
Собственно, здесь прямо прописан код взаимодействия
сервера и клиента.
Значит, у нас есть клиент, он может перейти в какой-то
другой вариант использования.
Это ворота.
Мы отправляем сообщение, значит, message validate.
Дальше, значит, окно у нас отправляется еще один
раз все в коммент.
И дальше здесь есть специальная вещь, что мы называем конструктор
класса.
Здесь идет запрос вида Ajax, то есть мы идем на сервер
и создаем этот экземпляр и отправляем запрос.
Видно, что он является асинхронным, то есть результата ожиданий
у нас нет.
У нас Proxy присылает все на сервер и дополнительно
в одном из методов validate мы с вами получаем копчу.
То есть нам нужно проверить на копчу.
Дальше у нас есть ошибки, ошибки, ошибки и возвращается
метод callback, что нам нужно сделать.
И дополнительно мы с вами по факту производим сеанс
верификации и дальше мы с вами уже отправляем комментарии,
которые нам нужны.
То есть здесь асинхронные запросы как раз происходят
при помощи метода Ajax.
Вот, то есть это уже реальный пример диаграмма по сенсии.
Тут даже больше вещь состоит не в том, чтобы вы могли
эти диаграммы рисовать, а их читать, потому что они
явно показывают в каком порядке действует система.
Вот код, который бы это было написано, он был бы ужасный.
А на диаграмме сразу все видно.
Что у нас происходит.
Особенно, кстати, частенько диаграммы последовательности
используются для всяких проектов, связанных с мобильными
устройствами или с графическими интерфейсами, когда необходимо
прописать все возможные варианты взаимодействий.
Так, хорошо, понятно ли вот эта вещь, вот эта диаграмма?
То есть здесь опять же в качестве упражнения можно
попробовать как раз отрисовать.
Клиент отправляет заказ и так далее.
Я вам отправлю пример диаграмм варианта использования,
диаграмма последовательств для этого проекта, для вот
этих примеров.
Так, с этим разобрались?
Хорошо.
Следующая диаграмма, это диаграмма состояния.
И здесь, как ни странно, мы встретим с вами еще один
паттерн, потому что есть как раз паттерн под названием
состояние.
В чем он состоит?
Нам нужны некоторые активные объекты.
Что это означает?
Это означает, что этот объект может сам управлять
своим жизненным циклом.
То есть он, во-первых, может управлять другими объектами
и у него есть свой собственный поток управления.
Пример очень простой такой системы, это холодильник.
Значит, он может сам нагреваться, может сам охлаждаться.
И при этом еще у него есть взаимодействие с другими
объектами.
То есть его может кто-то открыть.
То есть вот такие вот автономные объекты, которые не управляются
изне, мы называем активными объектами.
Может ли кто-то еще попробовать привести примеры активных
объектов нашей жизни?
Вы не поверите, с некоторыми активными объектами вы действуете
как по...
Это слишком большой объект, это прям система.
Я бы скажу так, процесс запуска демонов в сервере,
демоны, которые находятся в сервере, то есть не программы,
которые мы запускаем, а которые контролируются
сервером.
Так, давайте жизненные примеры.
Вы поверите, каждый день с ним взаимодействуете.
Светафор, конечно же, он же сам переключает практически
ветки.
То есть в зависимости от того, в какое время суток
вы переходите и в какое время вы пришли, у вас автоматически
идет переключение.
Светафора.
Причем он сам меняет свое состояние.
Для одних он желтый, для других он красный, для третьих
он зеленый.
То есть он показывает разные цвета.
Вот.
И вот вот пример.
Тут как раз банковский тоже АТМ-пример, в нем есть несколько
состояний.
Значит он изначально выключен, и дополнительно значит есть
некоторые кнопки, которые могут переключить его состояние.
То есть он либо сам при некоторых условиях может перейти
с одного состояния в другое.
Либо он сам его, либо кто-то выполняет какой-то триггер.
Значит смотрите, у нас автомат выключен, это у нас состояние.
Дальше при действии turn-off мы делаем, а это наоборот.
Значит смотрите, при нажатии кнопки turn-on или вызовем
этот стартап, мы начинаем само тестирование нашей
системы.
Значит если при этом тестирование системы происходит неуспешно,
то мы выходим с вами в out of service.
То есть у нас автомат не работает.
А если у нас все окей, мы переходим в состояние idle.
Что означает это состояние?
Idle это состояние ожидания запросов.
Дальше, когда мы вставляем карту в банкомат, у нас срабатывает
еще одно действие, и мы переходим в большое состояние, связанное
с взаимодействием пользователей.
То есть у нас одно состояние, которое может быть, может
быть структурным, и в нем есть тоже некоторые варианты
использования.
Ой, не варианты использования, а некоторые состояния.
Собственно, когда мы заходим в этот момент, мы прописываем,
что мы заходим тогда, когда мы прочитываем карту.
А выходим тогда, когда мы вынимаем карту.
То есть видите, здесь как раз диаграмма состояний
в банковской ячейке у нас с вами находится.
Примеры такие же есть, если вы включите компьютер,
компьютер по факту тоже является автономным объектом.
Он дополнительно еще может вызывать действия, связанные
с проверкой обновления операционной системы.
Причем триггеры могут быть не явные, явные могут быть
с наступлением по какому-то временному масштабу.
То есть мы можем отправить так называемое сообщение
для того, чтобы у нас сервер начал свою работу.
То есть у нас есть некоторые переключения либо по внешнему
действию, либо самостоятельно.
И вот нам надо это каким-то образом реализовывать.
И вот как раз для того, чтобы это реализовать, существует
паттерн состояния.
Значит, нам необходимо реализовывать переключение
между состоянием таким образом, чтобы не приходилось
выполнять сложную функциональность при этом переключения.
Примеры, кстати, светофор, как мы сказали, или отслеживание
доставки товаров.
То есть у нас с вами автоматический, так сказать, заказ должен
переключать свое собственное состояние.
Три перехождения из одного ключа в другое.
То есть у нас есть, допустим, мы только собираем заказ.
Дальше, значит, кто-то по действию либо его переключает,
либо соответственно автоматическая система, которая, допустим,
у вас есть геолокация на вашем товаре, и вы определяете,
где ваш товар находится.
Сейчас текущий момент времени.
Вот.
И нам это необходимо как раз реализовать.
Допустим, нам нужно больное действие.
Нужно пройти код-ревью преподавателя.
Собственно, для этого нам необходимо двустороннее
взаимодействие по каждой заданче, преподаватель
должен посмотреть код, отправить комментарии, а студент должен
исправить эти замечания или ответить на вопросы.
Некоторые вещи должны происходить автоматически.
То есть сама система должна менять состояние, а некоторые
вещи не должны происходить автоматически, а должны
ожидать какого-то триггера.
Вот.
И вопрос здесь состоит, как это все совершить.
И здесь есть достаточно элегантное решение с точки
зрения объектно-ориентированного программирования.
Оно будет заключаться в том, что давайте мы выделим
класс, который занимается активным объектом, и под
классы, которые будут отвечать за каждое из этих состояний.
Сейчас я поясню на примере.
Цель, собственно, паттерн состояние является обеспечением
поведения объектов в зависимости от его состояния.
Пример паттерна следующий.
То есть смотрите, у нас есть клиент, у него и у нас
есть контекст.
Значит, в данном случае контекст это будет светофор.
Есть заказ.
И у него есть ссылка на определенный интерфейс под
названием состояние.
У него есть три состояния.
Красный, желтый, зеленый.
И у каждого из состояния есть метод перейти в следующее
состояние, которое должен вернуть как раз это состояние.
То есть у нас получается у состояния три реализации
красный, желтый, зеленый.
Значит, у красного состояния, куда он должен переходить?
У желтого в зеленый и наоборот.
Единственное, что возможно, что у нас еще контекст должен
хранить, в каком направлении мы это все делаем.
И в итоге код у нас будет следующий.
Переключение светофора.
Мы просто говорим, значит, светофор переключайся 20
раз.
Что делается при переключении светофора 20 раз?
Значит, он берет состояние, которое у него есть сейчас
на текущий момент, и вызывает у него метод getNext.
Давайте я как раз попробую нарисовать.
Это состояние, то есть что у нас получается?
Представьте себе, что у нас есть светофор.
У него состояние красное.
Значит, когда мы вызываем метод goNext, а у нас у светофора
делает следующее k goNext, значит, красный goNext вернет
желтый.
И сделает следующее.
Пожалуйста, светофор, установи состояние на
желтый.
То есть вот такая реализация будет у красного.
То есть реализация goNext заключается в том, что мы создаем конструктор
класса желтый и подставляем его сюда.
То есть после завершения этого действия у нас вот
этот объект пропадает, у нас появляется объект
желтый.
Дальше мы еще раз вызываем goNext.
Значит, теперь у нас идет желтый goNext и в зависимости
от контекста, который мы можем установить в вызове
конструктора, допустим, g здесь в кубочках z, мы говорим,
окей, у желтого стоит контекст в зеленый, поэтому мы вызываем
конструктор зеленого и дальше устанавливаем setState на зеленый.
Вот, и теперь у нас здесь стоит зеленый.
То есть мы скрываем детали перехода из одного состояния
в другое внутри нашего класса.
Да?
Ну конечно же, типа у нас получается, я бы сказал
так, это основано даже на композиции, то есть что
у нас вот этот вот объект, внутренний, делегируемый
объект, он не виден, не может существовать без контекста,
который мы с вами поставили.
Ну а так здесь, да, конечно же, механизм виртуальных
функций используется, потому что мы используем наследование
одним из классов, в зависимости просто от того, что написано
в реализации каждого из классов, мы переключаемся
на другой класс.
То есть у красного одна логика, у желтого вторая логика,
у зеленого другая логика, третья логика.
Вот, дополнительно можно еще поставить какие-нибудь
триггеры, которые будут переключать состояние.
То есть мы все-таки разрешаем у контекста установить
определенное состояние.
Более того, если внимательно подумать и расширить этот
процесс, вы можете, наоборот, запретить некоторые переходы
внешние при желании.
То есть как раз там, если говорить про систему, в которую
мы задаем домашнее задание, там как раз так и сделано.
То есть там просто проверяет список возможных состояний,
в которые вы можете перейти, и они возвращаются.
Так, значит, когда это можно применять?
Это применяется тогда, когда объект, к поведению которого
действительно может меняться кардинально от состояния,
то есть, допустим, если у нас заказ доставлен, то
обратно мы, то следующее состояние, которое у нас
может быть для этого заказа, это только вернуть его в
изначальную точку, если его не забрали в течение
какого-то времени.
Вот, и у нас возможно, что в этом коде, как ни странно,
ИФОВ будет минимальное количество, потому что обычно
что бы мы сделали?
Если цвет желтый впереди в зеленый, если цвет зеленый
впереди в красный, здесь ИФОВ не будет в этой реализации,
а один ИФОВ будет, когда нам нужно сделать какую-то
развилку.
Вот, и, значит, плюс и минус.
Избегаем много ИФОВ, значит, концентрация кода у нас
в одному состоянию, бизнес-логика на каждом состоянии у нас
отделяется от бизнес-логики светофора, то есть мы с
вами как бы уменьшаем связанность класса, и причем
увеличиваем к ахижам.
Вот, но сразу скажу, что опять же у нас принцип какой
основной до тех пор, пока мы применяем паттерны.
Давайте вспоминать, какие аббревиатуры мы с вами проходили.
Да, здесь кис, keep it simple-stupid, и что говорит keep it simple-stupid,
говорит, что не надо делать паттерн состояния, когда
условия совсем простые.
И, кстати, есть еще одна концепция, примеру использования
кис, есть анти-паттерн один.
Он называется, знаете как?
Он очень интересный называется, называется чрезмерное использование
паттернов, то есть анти-паттерн против чрезмерного использования
паттернов.
Ну, то есть не надо, если вы можете какие-то простые
концепции использовать, то почему, зачем вам использовать
паттерны?
У вас как бы янам вполне для хранения типов транспорта
здесь вот в нашем примере нужны.
Так, понятен ли паттерн состояние?
Да, скорее всего, если у вас там светофор не на
какую-нибудь сковородку с кучей развилок.
А если уже светофор сложный, то лучше, конечно же, переключать
состояние.
Особенно, если он там регулируем в зависимости от времени
суток.
Вот, хорошо, значит, про диаграмму состояний.
То есть, это визуальная таблица переходов.
И последняя диаграмма, как ни странно, вы с ней
очень сильно знакомы.
Выходили в школу на уроки информатики?
Рисовали блок схемы?
Ладно, алгоритмы в виде блок схем, типа громбики,
кругляшки и так далее.
В общем, это организация рабочего процесса.
То есть, если вам нужно описать, допустим, что происходит
в определенном состоянии, либо прописать конкретную
последовательность шагов, в которые мы можем что-то
делать для этого, хорошо подходит диаграмма деятельности.
Она еще называется Activity Diagram.
Здесь пример использования диаграмм деятельности
для определенного состояния.
Значит, громбик обозначает условия в нашем случае.
То есть, если у нас есть неопытные участники в группе, то мы
делаем разминку, так сказать.
Объясняем проблему, представляем правила игры, вызываем идеи.
Если у нас есть идеи, которые можно обработать, тогда мы
говорим это, двигаемся дальше.
Иначе, типа, предлагаем мысль.
Дальше, значит, идея Available.
Если у нас несколько идей, то мы записываем их.
Если идея одна, то мы делаем вот такой вот штопор.
Значит, что здесь обозначает вот эти вот две горизонтальных черточки?
Здесь у нас идет презент идея и рекорда идея.
Это, как ни странно, параллельное исполнение.
То есть, вы параллельно можете записывать идеи и представлять
свои идеи.
То есть, оно показывает, какие шаги действительно
могут быть распараллельны.
И это очень удобно для организации процесса.
Во-первых, для того, чтобы ускорить работу программы.
А во-вторых, для того, чтобы, если вы хотите рабочий
процесс наладить, и что-то, если можно распараллелить,
то почему бы их не распараллеливать.
Вот такая вот вещь здесь, это как раз для конкретного
состояния.
То есть, можно использовать для организации рабочего
процесса.
Опять же, после максимальной атомизации всего этого
процесса все эти действия превращаются в функции.
Если мы говорим про пользователей, то здесь мы можем сделать
другую вещь.
То есть, как бы сказать, что мы приходим в стартовое
состояние какое-то и описываем действие.
Если у нас есть что-то, то мы делаем определенный
переход.
Как раз, опять же, есть эти, либо экземпляры объектов,
либо как раз, собственно, действующие лица в вариантах
использования.
То есть, как раз, мы текстово описываем просто бизнес
требования, а здесь мы уже по факту описываем функциональные
требования, которые у нас есть в нашем продукте.
Вот так выглядят диаграммы деятельности.
То есть, если вам сложно разобраться в каком-то
процессе, можно вычленить, нарисовать несколько столбиков
и попытаться понять, как это происходит.
Более того, если мы говорим про большие проекты, то мы
можем использовать еще и другие диаграммы.
Они обычно называются дорожные карты или диаграммы ГАНТа.
Собственно, давайте тоже про это расскажу.
Представьте себе, что у вас какой-то есть очень сложный
проект, который должен идти долгое время, и тогда
вы что делать?
Вы разбиваете ваш проект на команду, на определенные
стадии.
Это такая временная диаграмма, а дальше вы по оси Т делаете
следующее.
Прописываете, допустим, какие варианты использования
вы будете реализовывать со временем.
И закрашиваете, допустим, это у нас аналитики, это
у нас разработка, допустим, это бэк-энд, это у нас фронт-энд,
а это у нас с вами тестирование.
И дальше вы обрисовываете, закрашиваете определенные
части, когда та или иная команда будет работать.
Допустим, сначала мы пишем бэк-энд, потом мы подключаем
работу фронт-энда, ну и наконец мы там параллельно начинаем
тестировать.
Первая процедура, вторая процедура, третья процедура.
То есть у вас получается по временной шкале, типа
такой а-ля календарь получается, в котором вы можете спокойно
ориентироваться и понимать, проходите ли вы сроки или
нет.
То есть обычно для этих диаграмм даже есть временная шкала,
в которой можно отслеживать, где мы находимся на текущий
момент и все ли мы успели.
Так, понятно это или нет, вот эта диаграмма.
То есть вы можете прямо для своего проекта взять
и нарисовать такую диаграмму и понять, успеваете ли вы
в срок.
Или про обучение можете попробовать нарисовать,
у вас есть там задание по мотану и вот эту там по
мотану, по ТП и так далее, и вот эту временную шкалу
нарисовать и понять, типа успеваете ли вы в сроке
или у вас есть некоторые проблемы.
В смысле, а, понял, типа или мы не успеем.
Ну опять же всегда для любого задания есть некоторый процент
выполнения.
То есть если понятно, что начинать все делать на
сто процентов, то конечно же нас отчислят, если попробовать
допустим делать не все на сто процентов, то скорее
всего возможно и нет.
Мы получим более низкую оценку.
Так, давайте следующий диаграмм перейдем, диаграмм
пакетов.
Значит, что такое пакет?
Это набор классов, объединенных по логической сущности.
Значит, пример, кстати, вот здесь вот есть и на нем
видно явно следующая вещь.
У нас структура пакетов здесь и оказывается, что
у вас пакеты, которые есть, допустим, класс COM-A-Бизнес
и есть банк, который взаимодействует с аккаунтингом, ordering,
который вызывает зависимость класса системы аккаунтинг.
И видите, у нас есть шипинг COM-A-Бизнес и шипинг Data
Management.
И видно, что у нас есть стрелочки из одной стороны
в другую.
И здесь у нас возникает в коде так называемая циклическая
зависимость, что компонент A зависит от компонента
B, а компонент B, пакет B зависит от пакета A.
В чем проблема будет этого всего?
Чудо.
А?
Да, будет сложно расширять, все-таки нужно выбрать
более главного действующего лица.
Ладно, если это в одном компоненте происходит, это еще не особо
страшно.
Когда у вас происходит интеграция между этими
компонентами, вам нужно будет закрывать заглушки
в двух местах, то есть два канала информации.
Возможно, что здесь как раз можно переорганизовать.
Смотрите, ordering и шипинг, возможно, что нужно именно
делать запросы на изменение данных, а не использовать
бизнес-логику, то есть не потягивать бизнес-логику.
То есть я бы на этом месте убрал бы стрелки из снизу
вверх, а делал их только сверху вниз.
То есть как бы у нас бизнес управляет данными, а не данные
бизнеса.
А действия все происходят по запросу.
То есть по факту, как ее построить, вы берете ваш
проект, берете структуру директории, которая у вас
есть, и классы, которые в ней есть, и пытаетесь нанести
на диаграммы.
И по факту стрелочка это те инклуды, которые вы используете.
Такая вот визуальная диаграмма, которая вам явно все покажет,
если у вас проблемы.
Так, хорошо.
Есть ли вопрос по этой диаграмме?
Вот.
Значит, когда будет самая простая диаграмма, вопрос
к вам.
В каком случае будет?
Ой, простая диаграмма.
А?
Один пакет, все написали в одном файле.
Ну, понятно, что тогда мы очень долго будем разбираться
в этом коде, потому что у нас никакой поддержимости
не будет.
Так, давайте сейчас следующий диаграмм.
По-моему, это последний из диаграмм, который здесь
есть в этой презентации, это диаграмма компонентов.
Собственно, это, так сказать, большие мазки нашей системы.
То есть это как раз очень будет полезно тем, кто делает
проекты, состоящие из нескольких подсистем.
То есть в каждой из них мы определяем с вами определенную
подсистему.
Здесь, на примере, есть три подсистемы.
Это интернет-магазин, есть warehouse, это склады, есть
система расчета.
И дальше показано, как они взаимодействуют, каким
образом они связаны между собой.
Значит, у нас с вами вот эта вот подсистема, связанная
с веб-магазином, имеет две входных точки.
По факту, эти входные точки — это, так или иначе, наши
варианты использования, которые мы предлагаем нашими
системами.
Значит, у нас есть вариант использования поиска продуктов,
product search.
Мы описываем его каким-то интерфейсом.
Опять же, какие интерфейсы бывают, мы с вами поговорим
чуть попозже, когда мы будем говорить про веб-заимодействие.
И вот здесь как раз есть связь, которая позволяет
нам по факту передать информацию, которая у нас идет с внешнего
интерфейса, внутренний компонент.
Значит, это порт.
То есть, возможно, вы слышали как раз, что когда вы подключаетесь
к интернету к какому-то запросу, вы на самом деле идете по
определенному порту, по протоколу HTTP или HTTPS.
HTTP расшифровывается как HyperText Transfer Protocol, HTTPS расшифровывается
как HyperText Transfer Protocol Secure.
Всегда вы идете по одному из этих протоколов.
И здесь как раз можно явно описывать, какие протоколы
у вас идут.
А дальше у нас идет система заказов веб-магазин, допустим,
онлайн-покупка товаров.
Дальше мы идем в компонент под названием продуктовая
корзина.
Да, это большая компонента.
И дальше она уже идет в подсистему аккаунтинга, зависит от
того, какие заказы у нас есть.
То есть, каким образом мы с вами можем изменять эти
заказы.
Вот.
И дальше они уже дополнительно идут в склад.
То есть, как раз здесь мы видим связи между системами.
Кто, от какой подсистемы зависит.
Понятно, что, кстати, сразу скажу, такой забавный момент,
что вот те связи, которые у нас идут в обычный интернет-магазин,
вот отсюда, они отличаются от тех связей, которые производят
здесь.
То есть, мы здесь, вот, в части взаимодействия зависимости
можем делать все, что угодно.
Мы можем, в принципе, на одном и том же компьютере
расположить эти компоненты.
Но самое важное зачастую, что вот сейчас в современных
реалиях разные компоненты системы располагаются
на разных компьютерах.
То есть, у вас есть один сервис, это называется сервисами.
У вас есть сервис как раз по веб-магазину, у вас есть
сервис по складам, у вас есть сервис по аккаунтингу.
Вот.
И связь между ними может быть настроена по одному
из протоколов.
Вы можете там файлами обмениваться, положить его куда-то в
общее хранилище, либо там отправить запрос по сети.
Либо еще как-нибудь это очень забавный кейс, вы просто
идете ручками, значит, печатаете вот эти вот все запросы и
тащите их в другой компонент.
Вбиваете их ручками и все у вас работает.
То есть, понятно, что когда у нас тестовые заглушки,
тестовые сценарии, то понятно, что нам нужно будет делать
заглушки для того, чтобы это у нас все работало.
То есть, это вот такая большая-большая диаграмма, на которой
прямо видно структура всей вашей системы.
Потом мы ее уже бьем на классы и дальше уже смотрим
на наше поведение между этими объектами.
Здесь, кстати, диаграмма достаточно хорошая, то есть
у нас нет никаких циклических зависимостей.
Так, вот такая большая диаграмма.
И здесь как раз мы можем вспомнить наш паттерн-адаптер,
потому что каждую из связей, которые у нас есть, желательно
делать при помощи адаптеров, чтобы, если что, мы могли
легко поменять наш протокол, взаимодействие.
Так, все, это что касается паттернов, ой, диаграмм,
давайте вопросы по ЮМЛю.
Смотрите, давайте достаточно простой пример, допустим,
если у нас очень простой сценарий в нашем системе.
Давайте тогда, сейчас напишу, во-первых, классы точно
нужны, диаграмма классов, варианты использования
тоже нужны.
Значит, если вариант использования, так сказать, достаточно
несложный, полезно нарисовать либо диаграмму деятельности
либо диаграмму последности, то есть они друг друга взаимозаменяют.
То есть она, диаграмма деятельности показывает большую часть,
как у нас объекты существуют между собой, как актеры,
как акторы.
То есть, если у вас в системе много пользователей и каким-то
образом они обмениваются информацией, лучше все-таки
использовать диаграмму деятельности.
Если у вас в системе мало акторов, но при этом у вас
есть какой-то сложный алгоритм, именно сложный алгоритм
вызова сообщений, то для этого лучше использовать
диаграмму последностей.
Если у вас есть система, в которой есть что-то напоминает
состояние, переключение этих состояний, то мы можем
использовать диаграмму состояний.
И если, допустим, у нас эти состояния переключаются
по каким-то триггерам, то для этого у вас состояние
можно нарисовать диаграмму деятельности.
В конце, если у вас система очень большая, и у вас это
не какая-то простая игра, то, опять же, нужно сначала
придумать, собственно, вот облачную архитектуру,
попытаться разбить большие блоки на маленькие компоненты
и дальше двигаться по ним.
Но в нашем проекте я сразу советую, в наших проектах
я сразу советую не использовать диаграмму компонентов,
потому что вы сначала застрелитесь, вам сначала нужно маленькую
логику проработать, а потом уже думать по этой маленькой
логике, как это все бьется на отдельные компоненты.
Пока что у нас просто знаний нет для того, чтобы соорудить
большой проект с компонентами.
Надо разбираться в веб-заимодействии, в базах данных, в транзакционности
и других разных вещах протоколов.
Поэтому мы пока живем на уровне бизнес-логики, и
в нашем случае как раз будет достаточно, то есть если
вы не работаете в проекте в несколько человек, то
будет достаточно сейчас диаграммы классов, диаграммы
классов, диаграмма вариантов использования.
И для бизнес-логики будет достаточно диаграмма
вариантов последовательств, диаграмма последовательств,
этого вполне будет достаточно.
Так, давайте еще вопрос, спасибо за вопрос, да, действительно
полезно.
Я ответил на него?
Да.
Хорошо.
Давайте тогда я сделаю затравку некоторую на следующую
лекцию.
Значит, в следующие две лекции, даже две с половиной, мы
будем говорить про одну интересную тему.
Это тема тестирования ПО, то есть пока что мы с вами
только разрабатывали ПО и говорили про архитектуру,
но мы пока вообще ни разу не говорили про то, как его
тестировать.
Что у вас возникает при понятии тестирования, когда
я говорю тестирование?
Чего-чего тестировать?
Ага.
Это уже продвинутая мысль.
Да, некоторые уже знают, что такое юнит-тест.
Да.
Ну да, по которым он выполняет определенные действия.
На самом деле, давайте так скажу, что вы понимаете
под понятием тестирующей системы.
Да, сравнивать желаемое состояние с получаемым.
То есть обычно, когда мы говорим про тестирование,
мы думаем, что у нас есть какая-то программа, по каким-то
входам мы получаем какие-то выходы.
И все.
Но на самом деле, тестирование – это намного большая структурная
вещь, которую нам детально нужно разобрать.
Я сейчас начну с некоторой большой картинки про то,
какие виды тестирования бывают.
Готовы?
Картинка.
Значит, давайте я ее сейчас буду увеличивать у себя.
Такие виды тестирования существуют.
Значит, мы с вами сначала пойдем в наших лекциях говорить
про уровни тестирования.
Что означает уровни тестирования?
То есть мы тестируем свои модули, мы с вами тестируем
взаимодействие между компонентами, либо всю программу целиком,
либо всю программу целиком в реальных условиях.
Это приемочные тестирования.
Про это мы будем говорить в следующий раз.
Дальше важно, чтобы вы понимали, как это все работает.
По объекту тестирования, по предмету тестирования.
И здесь как раз разделяются тестирования функциональных
требований и нефункциональных требований.
Значит, давайте поговорим, что мы просто можем тестировать
в функциональных требованиях.
ой, я все сломал, так, вот, значит, что мы можем тестировать?
Мы можем тестировать функциональности, то есть как раз выполняется
ли у нас бизнес требования, которые прописали, и выполняются
ли основные сценарии в вариантах использования.
Дальше мы можем тестировать безопасность, то есть это
доступа, то есть, что, грубо говоря, если вы заходите
по паролю, можете ли вы его перебрать, включена
ли у вас двухфакторная аутентификация, хотя это
больше про нефункциональные требования, и вы можете
дополнительно проверить, тестировать совместимость
ваших версий продукта, то есть вы завещаете, допустим,
говорите, что у вас компьютер должен работать на таких-то
ресурсах, действительно ли он запускает наш продукт
на определенных ресурсах.
Дополнительно вы можете проверить, что у вас пользователи
такими-то правами должны иметь доступ, а пользователи
такими-то правами не должны иметь доступ, это как раз
тестирование доступности, и вот это все включается
в функциональные тестирования, а все остальное, это нефункциональные
тестирования, и как раз здесь можно понять, что является
нефункциональными требованиями.
Здесь кстати, важно подчеркнуть, что именно когда мы говорим
про security, это security и access control, это функциональные
что ваши данные не утекают, что у вас все не разваливается.
Значит, теперь давайте поговорим про нефункциональные требования.
Первое нефункциональное требование это интерфейс пользователя.
Что это означает? Это означает, что если у вас в функциональных требованиях написано,
что вот у вас система должна делать такие-то действия A, B, C, D, E.
А потом вы такие думаете, нам бы хотелось, чтобы пользователи с точки зрения бизнеса
с правил получали красивые окошки для того, что на них можно было удобно тыкать.
Или если вы покупаете какой-то товар, то у вас есть корзина отрисованная, прямо картиночка.
И вот вы тестируете, насколько удобно вам пользоваться этим интерфейсом.
Я не знаю, видел ли кто-то из вас, как выглядят разные системы по поводу того,
когда вы покупаете товар в магазине.
Вот у вас мобильное приложение выглядит очень красиво.
Кнопочки там, все такое. А что происходит с обратной стороны?
Ну либо 1S какой-нибудь стоит, либо...
Там есть системы про онлайн-кассы, где у вас прям просто некоторый набор кнопок,
вы тыкаете кнопки и дальше у вас что-то пробивается.
То есть там никакого интерфейса нету, user-friendly.
Хотя функциональные требования выполнены.
То есть некоторые, наоборот, отказываются от удобства интерфейс-спользования.
Следующее тестирование – тестирование локализации.
И давайте я как раз проведу тест по локализации и его сломаю.
Я скажу, что система не проходит тестирование локализации.
Так, ну давайте тестировать.
Тестирую локализацию, тестирую и на переход на другой язык.
Пока работает, да?
Да, ну перевода нет.
Здесь вроде тоже все окей.
Идем в курсы.
Где курс по ТП?
Так, тест-таск все отлично.
Все, тестирование локализации провалено.
Да, мы не перевели задание на английский язык.
Да, жаль, жаль, жаль, жаль.
Здесь тоже не перевели.
Здесь тоже, здесь тоже.
Надо будет заняться.
Вот мы провалили тестирование локализации.
Опять же, в зависимости от того, куда вы заходите, у вас может быть разная вещь.
Допустим, на Фистехе, кстати, раньше была такая забавная особенность,
что русскоязычная версия сайта отличалась от англоязычной.
Причем самое забавное было, что русская версия сайта открывается по адресу mip-true,
а английская у вас идет переадресаться на фистех.edu.
Я не знаю, осталось это сейчас или нет, но такое есть.
Дальше у нас с вами идет тестирование скорости и надежности.
И здесь тоже выделяют разные виды тестирования.
Это либо тестирование производительности,
либо стресс-тестирование, либо нагрузочное тестирование.
Давайте поговорим про следующее.
Да, кстати, я забыл выделить, что есть UI-тестирование.
То есть вы проверяете, что у вас кнопки работают.
Несмотря на то, что вы когда нажимаете на кнопки,
под капотом на самом деле идут запросы по сети.
То есть вы можете в принципе вашу систему проверять
с точки зрения нажатия кнопок на запросы.
А есть тестирование, так сказать, удобства использования.
То есть все, что у вас кнопки красивые, и они правильно отрисованы.
Допустим, есть ли у вас версия для слабовидящих.
Это очень важно.
А тестирование надежности и скорости, если мы говорим,
они тоже бывают разными.
И давайте я сейчас вам покажу пример
того, как это происходит.
Вы можете делать следующую вещь.
Вы с момента времени t можете увеличивать количество запросов
на ваш сайт, на любой ваш сервис.
Опять же, это говорится про функциональные.
Значит, смотрите, в чем заключается стресс-тестирование.
Вы начинаете увеличивать постепенно нагрузку на сайт.
Знакомые с этим, с термином запас прочности,
прочность системы, это физическое понятие.
То есть это максимальная сила, которую нужно приложить
на объект, которая разломает этот объект пополам.
Что происходит в стресс-тестировании?
Вы пытаетесь увеличить нагрузку на вашу систему
и ищете первый момент, когда оно у вас сломается.
Когда у вас сайт перестанет работать.
Отмечаете этот момент, а дальше вы проверяете,
стабильно ли ваша система работает под этой нагрузкой.
То есть вы снижаете уровень нагрузки
и начинаете постоянно прогонять эту нагрузку.
Смотрите, какое количество ошибок у вас прилетит.
Давайте проверим.
Опять же, тут нужно отправлять количество запросов.
У кого есть компуктер под руками?
Я сейчас выполню этот запрос.
Утилита АБ на Apache Benchmark.
Я сейчас буду отправлять 5000 запросов на сайтах check
с календарной стресс-тестировкой.
У меня тут есть дополнительный патрон.
Я буду использовать его для расписания터�ов.
Утилита АБ на Apache Benchmark.
Я сейчас буду отправлять 5000 запросов на сайтах check
с календарной стресс-тестировкой.
только с из 24-х потоков
slash нужно добавить
а вот кстати защита от ботов стоит по-моему сейчас 20 тысяч в месяц базовая
если смотреть кажется мы это даже в чате с пренями обсуждали в комнате наших для преней
вот ну что мы видим с вами мы видим с вами что в принципе основная страница курса сайта загружается
где-то за 233 запросов в секунду переживает вот и при этом здесь мы можем с вами видеть
квантили распределение то есть получается в 99 процентах случаев сайт открывается не больше
чем за 126 миллисекунд вот основная страница собственно если мы хотим провести нагрузочное
тестирование то нам надо дать большее количество запросов большое количество запросов и отправляйте их
в постепенном потоке есть специальные инструменты для нагрузочного тестирования кто-нибудь еще
запустил команду там минус ц количество запад этих ядер на своем компьютере и слэш в конце нужно
не забыть что запустили скажите когда запустите на гитлап действительно часто падает
но надо увеличить нагрузку на ахчек то я увеличил нагрузку она гитлап то не очень
о помог тут мне ну либо не запустили либо это а в общем видно что 24 запроса вполне выдерживает
там я думаю сейчас пик где-то под 200 под 500 запросов вот выдержит в принципе этого достаточно
для наших бизнес целей вот 180 миллисекунд в принципе достаточно и тестирование совместимости
это показывает следующее что вы вас система запускается на операционной системе не ниже
такой-то такой-то такой-то то есть это то что обычно выносит системные требования вот значит
у нас сегодня лекции конец значит следующий раз мы как раз будем смотреть уровни тестирования вот
и дополнительно будем разбирать какие методы тестирования по доступности кода существует
все значит если есть вопросы задавайте спасибо
