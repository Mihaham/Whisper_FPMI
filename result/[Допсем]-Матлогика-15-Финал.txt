Теперь, то, что ты делал в логике с высказами, можно
делать точно так же с типами и выводом типов.
И, например, оказывается, есть такая штука, как соответствие
Карриф Хорварда, который утверждает, что любая формула
первого порядка мы можем перейти в какой-то тип,
и дальше просто оперируясь типами, мы можем доказывать
выражение в...
Это типа как мы кодируем, чтобы потом...
Типа того, ну, на самом деле, ну, просто пример, что
у меня там есть какое-нибудь выражение, что ну, сейчас
скажу, вот, например, я могу вести типу натуральное
число.
Натуральное число, но я буду писать как-то в программе
есть, например, язык Hustle есть, там, в Olysem, у нас есть
натуральное число. Его можно определить следующим образом, что у нас это либо
ноль, либо это следующее за натуральное число. У нас есть два варианта
получения того типа. У нас есть ноль, а есть следующее за некоторое натуральное число.
Дальше мы можем делать что? Мы можем, например, доказать, мы можем сказать такое
больше-меньше-либо равно. Там, например, что? Снова, меньше-либо равно это какое-то
утверждение в логике первого порядка. Мы же, если это утверждение, то мы переводим
в какой-то тип. Ну, вот, например, data less than. Это тип меньше-либо равно. Это даже не
чисто. Как он работает? Что? Сейчас. LTE, он берет в себя как? Он принимает некоторое
натуральное число, дальше принимает второе натуральное число. Ну, и пишется так, что
типа это мы получаем некоторый тип. Ну, и там дальше пишется, например, where. И мы говорим,
что каким способом вообще можно получить такой тип? Давай я скажу less than or equal.
Можно сказать, что LTE 0. Это у нас что? Если мы возьмем 0, то есть 0 это какой-то тип. Вот так вот.
Если мы возьмем тип, какое-то дальше мы возьмем произвольное натуральное число, то мы получим
LTE 0 n. Ну, то есть, если я возьму 0, какое-то произвольное, я получу действительно, что это тип
0 меньше-либо равно. Я могу сделать там, есть такая штука как LTSA. Если мы возьмем здесь что? У нас
может быть либо 0, либо следующий за каким-то. Ну вот, следующий за n. Дальше я должен буду взять что?
Мне нужно взять что-то за чем-то предыдущим. То, если это, сейчас скажу,
меньше-либо равно. Если 0 это всегда, если здесь следующий за n, мне нужно получить следующий за k
и спуститься к тому. Я возьму следующий за k. Дальше, ну вообще там, например, можно сказать,
что если есть тип LTE от nk, записать так, что это типа компилятор языка может вывести, то тогда я получу
LTE за вот sn sk. Но это уже как раз по сути введение такого типа. Дальше более сложное, но тут можно делать
более продвинутый паттерн матчинг. Например, по сути, switch по инаму, это вот немножко
сфункциональное программирование. Да, ну по сути, буквально, например, есть язык скала. Он с одной
стороны, да, он с одной стороны совмещает в себя объектно-ориентированное программирование из
джава. С другой стороны, у него есть функциональные программирования. Например, я не помню в каком году
там была научная работа, которая доказала, что система типов языка джава, система типов языка
скала противоречила. И поэтому создатели языка скала пошли и создали сначала систему типов. Я не помню, там
как-то есть название хорошее для этого всего. И на основе этой системы типов они пошли строить самый
язык. И в результате, например, для скала в спецификации, там прям есть такая табличка. Она
похожа на какие-то вот эти вот правила вывода, как в там с модом с поносами и прочей вот этой
истории. Только теперь это для типов. Вот есть правила вывода, и на основе этих правил вывода типов
работает язык скала, работает его там компилятор.
Японский бог как меня засрала. Это сложности.
Пару секунд.
ТП.
122 это.
Вадя Тупаев помогал меня. Что-нибудь интереснее где это у меня было.
Вот это вроде.
Все.
Ладно, поехали.
Сейчас перекомпилирую.
Ну, в общем, последняя тема, лямбда исчисления. Это альтернативный подход к тому, как можно
вести вычисления. В прошлый раз мы говорили про машину Сьюринга и как можно использовать машину
Сьюринга подходить к вычислениям. Теперь же у нас будет другая абсолютная история, которая больше
основана на синтаксисе. Начнем вводить вообще лямбда исчисления. Давайте я скажу первое, что у меня есть
некоторое множество лямбда большое. Это множество лямбда термо. Мы его будем вводить следующим образом.
Во-первых, давайте как в прошлые разы зафиксируем множество вар. Это было счетное множество каких-то
переменных, которые мы можем использовать в нашем языке. Дополнительно в наш язык нам понадобится
алфавит, состоящий из символа лямбда, который будет специальным, давайте скажем так, лямбда квантором.
Дальше нам понадобятся скобки и можно там сказать, что нам понадобится точка, но точка это такой,
синтактический сахар. В целом на этом все, что нам нужно закончилось. Как мы будем вводить вообще множество
лямбда термов, то есть каких-то слов в нашем языке. Первым делом мы строим базу нашего индексивного
определения. Базой будет множество переменных. Мы считаем, что вот оно счетное. Если х принадлежит
переменным, то х принадлежит множеству лямбда термов. Второе. Эта штука называется аппликацией, но если мы
попробуем перевести на русский язык, это применение. То есть, если у меня есть некоторый терм, дайте его назову,
не буду лямбда использовать. У меня есть мю1, есть мю2, это некоторые два лямбда термов, то мю1, мю2 в скобках принадлежит множеству
лямбда термов. Это буквально будет означать, что у нас есть некоторый терм, некоторые другой терм, мы их вместе написали.
Интерпретацию этой истории будет применение. Ну, например, если мы вспомним баш, то, как ни странно, у нас, например,
эхо что-то там, это будет означать, что у нас есть некоторый терм эхо, некоторый терм такой, и мы применяем терм эхо к этому терму и получаем
некоторые значения. Да, все хорошо. Дальше терм называется лямбда абстракция. У меня есть некоторый мю, принадлежит лямбда большое, тогда лямбда х, мю,
ну я поставлю точку, принадлежит лямбда. Ну давайте я скобочки еще поставлю. Так мы ввели понятие того, что есть лямбда терм, с каким вообще множеством мы работаем.
Также нам потребуется определить некоторые два вспомогательные множества. Первое, например, мы можем определить множество свободных переменных.
От некоторого терма мю, это множество свободных переменных. По аналогии с исчислением предикатов,
свободной переменной мы назовем ту, по которой не стоит лямбда квантор. Как мы его определяем? Определяем аналогично исчислению предикатов индиктивно.
Ф и В, а то free variables. Первое, это что если х принадлежит вар, то есть на самом деле мы делаем в некотором смысле switch по построению.
У нас есть некоторые способы построения и мы теперь просто разбираем каждый способ построения и по нему идем. У нас есть первый способ построения, что это х принадлежит множеству вар.
Тогда мы говорим, что означает free variables от х. Free variables от х будет самим х, потому что по нему не стоит квантор.
Второе, у нас есть мю1, мю2 принадлежат множеству лямбда термов, тогда free variables от, дайте я буду квадратную скобку писать, чтобы не было колизий скобок.
Free variables от аппликации мю1, мю2, это есть free variables от мю1 объединить free variables от мю2.
И последний способ построения лямбда термов, это лямбда аппликация, лямбда абстракция.
Поэтому если мю принадлежит лямбда, то лямбда точка х мю, точнее множество свободных переменных от него будет равняться free variables от
мю без переменной, по которой произошла абстракция.
Все супер.
Аналогично множеству свободных переменных можно задать множество связных переменных, правильно это называется bound variables на английском языке, поэтому bv от мю множество связных переменных.
Его можно аналогично провести индуктивное определение, можно определить также функцию var от мю, которая будет принимать некоторые лямбда терм и по нему сообщать, какие переменные в нем используются.
И понятно, что var от мю это дизюнктное объединение bv и fv.
У нас есть теперь какие-то операции со словами, есть просто слова, дальше мы будем вводить на этих словах некоторые операции, которые в целом и будут пытаться как-то объяснять, что такое вычисление.
Основных операций мы рассмотрим две, их можно делать побольше, но мы будем рассматривать его на две.
Первая операция называется альфа конверсии, я буду называть это альфа эквалентностью.
Идея альфа эквалентности такая, что у меня есть некоторый терм лямбда, и он в себе содержит некоторую переменную, давайте я назову v, он в ней участвует в качестве, сейчас скажу,
тогда я могу альфа эквалентностью перевести его в терм лямбда, но где вместо v я подставлю новую переменную, то есть вместо v я подставлю переменную w.
Например, давайте рассмотрим терм, первый случай это a-b-c, я могу, что скажу, здесь важные условия, что v должна принадлежать множеству
ограниченных переменных. То есть, например, если мы попытаемся здесь перевести альфу в какой-нибудь там d, то эти два терма не равны.
Дальше следующим ограничением на перевод у нас будет, что w не должен создавать корризии, давайте я возьму не как отдельные условия, что w не должен создавать корризии,
а я возьму более сильные условия, что я скажу, что w просто не принадлежит множеству, ладно, не буду я делать такое требование, просто w,
как у нас можно получить корризии, например, лямбда xy, xyy, да даже не так, лямбда xy, лямбда x, дальше в скобках,
лямбда ww, и здесь будет xww, вот я могу попробовать сделать что, давайте я переведу v в x, то есть лямбда x,
лямбда xw, xxw, что получается, у нас здесь было ранее две различные переменные, здесь они слились в одну, поэтому такое тоже нельзя.
Корректным бы здесь был перевод, если бы я переводил v в, например, переменную a, то есть лямбда x. лямбда aw, xaw.
Вторая вещь, это бета-редукция, данная трансформация лямбда термов работает следующим образом.
Нет, переименовать их не разрешается.
Дальше, бета-редукция, что мы производим, у нас есть некоторый терм вида лямбда x. mu от x,
что у нас есть лямбда x, mu используется где-то x, и дальше приписан некоторый терм mu, тогда мы можем провести бета-редукцию, каким образом ее можно
осуществить. Мы просто подставим вместо xa в, в это какой-то произвольный терм. Опять же, у нас аналогичная история с тем, что данная замена не должна создавать коллизий.
Не может случиться такого, что у нас был терм лямбда x, дайте я скажу, xy и лямбда, я скажу,
лямбда xy. xy, а здесь будет лямбда y. y. Например, бета-редукция вида, когда мы вместо y поставим такое, лямбда y. y. y.
она нехорошая. На самом деле ее можно дальше работать, но давайте я лучше скажу,
я не так сделаю, я сделаю вот так, мне же никто не помешает, я сделаю y, сделаю w. Вот так вот я делаю, лямбда y. Вот, какова красота.
Вот, например, такую штуку точно нельзя производить. Почему? Что здесь у нас свободная w, а тут внезапно она стала связана.
И вообще вот эти все размышления наталкивают на то, что, например, все трансформации должны так или иначе сохранять равенство множестве связанных и свободных переменных.
В целом, это одно из необходимых условий для равенства лямбда термов, но для того, чтобы начать говорить про равенство лямбда термов, нужно еще поговорить о нескольких моментах.
Первый момент это то, а как нам здесь провести вообще бета-редукцию. Кажется, что здесь все хорошо, по идее мы можем это как-то сделать, но непонятно, что это и как.
Для этого мы разрешим более продвинутое преобразование, которое будет, давайте назовем его двумя стрелочками, тоже еще одна трансформация лямбда термов.
Я буду называть ее как раз учислением. В чем смысл вот этой вот штуки? В том, что теперь мы можем комбинировать альфа эквалентности бета-редукцию.
То есть у меня есть некоторый терм ню, и он бета-редуцируется к терму ню.
Тогда терм ню, его можно преобразовать такой более сложной двойной стрелочкой к терму ню.
Дальше у меня есть терм ню, который можно альфа эквалентно перевести в ню. Тогда я могу ню уже более сложным образом перевести в ню.
И дальше, если у меня есть ню, если у меня ню переводится в ню,
а ню переводится в пи, то ню можно будет вести к пи.
То есть в некотором смысле, что здесь? Мы сделали замыкание одновременно и вот этого порядка, и вот этого порядка.
Понятно, что если у меня есть преобразование, то это порядок. Здесь просто классический частичный порядок, здесь предпорядок, который оказывается эквалентностью.
Потому что если мы в одну сторону переименовали, мы в обратную сторону также можем вернуть те перемены.
Здесь мы объединили переименование и бета-редукцию.
Включается, что теперь мы можем сделать? Мы можем вот эту штуку перевести сюда. Почему?
Потому что здесь я переименую перемену w, x будет не w, а просто w, x, y, λ, y, w.
Я это вот сюда перевел альфа эквалентностью. Дальше я провожу бета-редукцию до лямда v, дальше лямда y, точка w от y на сюда.
И на самом деле я могу провести еще одну редукцию здесь и получить вообще лямда w, w.
Вроде не ошибся.
Вроде не ошибся.
Давайте я гляну, что там мне написано.
Вроде не ошибся.
Теперь мы начинаем из вот этого отношения порождать отношение равенства на лямдо t.
В следующем образе мы говорим, что отношение равенства на лямдо t.
То есть если терм mu, я могу свести к nu, то mu равняется nu.
Если я наоборот ню свел к mu, то mu равняется nu.
И наконец, если у меня есть такая разница, мы бы могли на это забить, если бы мы знали сразу, что это отношение симметрично.
А вот же в случае у нас отношение обязательно симметричное.
И получается, что эти два условия кардинально разные.
Бета-редукции, смотри, у меня есть терм.
Смотри, она не симметрична. Я вот сюда проведу редукцию бета, поэтому я смогу сюда сделать.
Но в обратную сторону я тянея навешиваю лямдо квантор.
Поэтому за счет именно бета у нас все равно эта штука не симметрична.
Да, она рефлексивна, она транзитивна, но она не симметрична и не антисимметрична. Это предпорядок.
Это у нас типичный предпорядок. Бета-редукция, в ней рефлексивности нет, то есть там прямо явно.
В альфа эквалентности у нас есть симметричность, у нас есть транзитивность, и на самом деле там тоже есть рефлексивность.
Но поменяем перемены на саму себя. Это равняется отношению эквалентности.
Здесь мы просто разрешили более интересным образом проводить редукцию.
И тем самым здесь получили рефлексивность и транзитивность.
Здесь мы навешиваем еще симметричность.
Вот следующим образом, и дальше мы говорим, что если mu равняется mu, mu равняется некоторому pi, то тогда mu будет равняться pi.
У нас здесь вытечет рефлексивность из нашего числения.
Дальше вот эта симметричность, эта транзитивность.
Идейно это нам позволило сделать что?
Что если есть некоторые термы, которые там есть терм mu, терм nu, но сводилось оно как-то так, и терм pi,
то теперь мы можем благодаря этому отношению говорить, что вот эти штуки равны.
Если у нас есть отношение равенства, на самом деле не совсем настоящего равенства,
настоящее равенство мы будем означать следующим образом.
Вот там из первосеместного от логики отношение равенства в смысле синтоксического сходства.
Это и есть настоящее равенство.
Это некоторое отношение к валентности.
И на самом деле отношения равенства и отношений к валентности не совсем верны, они не совпадают.
Поэтому мы хотим посмотреть что-то вида класса квалентности, и чтобы на них было прям равенство, которое равенство.
Что будет означать эта история с классами квалентности?
Такая история связана с понятием нормальной формы лямбдо-терма.
Нормальная форма лямбдо-терма.
Это такая форма, в которой нельзя провести бета-редукцию, даже перед этим как-то переименовав.
Дальше не существует, дайте скажем так, терм μ в нормальной форме, если не существует такого терма ню,
что μ-бета сводится к ню, но с важным условием, что здесь мы можем заиспользовать дополнительно альфа-квалентность.
Не прямо чисто одно операция бета сводимости, а можно еще как-то переименовать, помочь нам.
И вот оказывается, что подобным образом нормальная форма гарантирует нам следующее, что нормальная форма лямбдо-терма единственна с точностью до альфа-кваленции.
То есть у нас есть некоторое множество лямбдо-термов.
Если мы попробуем его профакторизовать по отношению альфы-квалентности,
то на данном множестве у нас переходы по бета-редукциям, они таковы, что если мы можем закончить это вычисление, то только единственным образом.
Вообще зачем это так важно и почему на это стоит уделить внимание?
Давайте попробуем привести интерпретацию лямбдо-исчисления в рамках того, что есть само по себе вычисление.
У нас в машинных тюрингах вычисления было переход по функции дельта, дельта это некоторое преобразование было, и соответственно набор этих преобразований было вычислением.
Теперь же мы говорим, что пусть у нас есть некоторые абстракции жизни, произвольные абсолютно, мы его попытаемся как-то закодировать при помощи лямбдо-терма.
В машинных тюрингах мы пытались это как-то закодировать при помощи машины тюринга, конфигурации, точнее, машины тюринга, и дальше мы можем проводить некоторые операции, вычисления.
Эти вычисления, по сути, будут вот эти вот стрелочки. Мы будем преобразовать лямдо-1, лямдо-2, лямдо-3 и так далее.
И оказывается, что в какой-то момент, если это вычисление действительно останавливается, то оно останавливается в некотором лямдо-н таком, что дальше мы не можем этот терм упростить, видоизменить.
Переменование, на самом деле, ничего умного не делает. И дальше мы можем лишь просто переименовать переменные, которые не влияют на сам смысл.
И нормальная форма, это, по сути, означает, что конец вычислений. Отсюда можно интуитивно заключить, что вопрос существования нормальной формы неразрешим.
Просто потому что в машинах тюринга вопрос того, остановится ли наше вычисление, то есть машина тюринга останавливается или нет, он, как мы знаем, язык HALT не разрешим.
Точно так же и здесь. Множество термов с начальной формы неразрешимо, но это не вычислимо.
Немножко про равенство. Например, понятно, что если два терма равны, то если у одного существует нормальная форма, то и у второго она тоже будет.
Поэтому одним из необходимых условий равенства термов в том, что если у одного существует нормальная форма, то и у второго тоже должна существовать.
Или если у первого не существует, то и у второго не должна существовать. У вас будет номер на контрольной, на котором нужно проверять равенство лямбда термов.
И первое, что можно сделать, это просмотреть и проверить, есть ли у термов нормальная форма. Если вдруг окажется, что одного есть и другого нет, то победа, вы доказали их неравенстве.
Давайте проговорим про еще один интересный момент связанный с этой всей историей. Называется эта штука теоремой ронды.
Теорема черчерослера.
Теорема черчерослера звучит следующим образом. У нас есть два терма. Есть термню и есть термню, про которую мы знаем, что они равны.
Тогда должен существовать некоторый терм п, такой, что мю как раз таким образом сведется к этому п, и ню также сведется к п.
Пробуя эту редукцию, так как мы понимаем, что это в некотором смысле операция, которая действительно сильно изменяет структуру термов, хочется понять, а вообще у этого отображения есть ли такая штука, как неподвижная точка.
Оказывается, что неподвижная точка есть. Раз мы назовем терм омега большое, следующую историю, а лямбда х, х, х, лямбда х, х, х. То есть применим функцию двоения саму к себе.
Окажется, что если мы применим бета-редукцию, то мы получим сам же себя.
И, например, терм омега большое будет классическим примером того терма, который не имеет нормальной формы.
Хорошо, у нас вообще неизвестно и нельзя определить, есть ли у терма нормальная форма всегда, но есть ли какие-то хорошие случаи алгоритма получения нормальной формы.
Ответ на этот вопрос положительный. У нас есть нормальная стратегия редукции.
В чем она заключается? Что мы должны на каждом шаге мы должны редуцировать самый левый редекс.
Редекс это конструкция, которую мы как раз можем средуцировать.
Например, в задании про поиск нормальной формы можно использовать нормальную стратегию редукции для проверки того, а есть ли вообще нормальная форма.
Вообще данная стратегия редукции настолько хорошая, что есть доказанный факт про нее, что если у терма существует нормальная форма, то ее можно получить, использовать данную стратегию редукции.
Если нет, то не получится. Чем это хорошо? Что мы точно можем теперь используя эту стратегию редукции доказывать, что у терма нет нормальной формы.
Например, мы проведем нормальную стратегию редукции. В какой-то момент у нас был терм лямбда 1, мы как-то пришли лямбда штрих, терм потом мы как-то двигались, двигались, двигались и снова пришли к лямбда штрих.
У нас появился цикл используя нормальную стратегию редукции, что будет означать, что мы не сможем получить нормальную форму используя данную стратегию, а значит терма не может быть нормальной формой.
Иначе, если бы она была, то мы однозначно бы получили. А здесь все, у нас цикл.
Еще я вам контрольную открою, что у нас там еще.
Да, забыл про это рассказать. Соглашение о скобках.
Главально у нас соглашение о скобках таких. Первое это называется лево-ассоциативностью аппликации.
То есть если у нас есть некоторые конструкции вида ню-ню-пи, то мы это интерпретируем следующим образом.
Это будет означать следующее, что скобки расставлены следующим образом.
Вторая история называется право-ассоциативностью лямбда абстракции. То есть если здесь мы вставили скобки слева направо, право-ассоциативность начнем вставить справа налево.
Классическим примером лево-ассоциативных операций являются в различных языках программирования операции вида арифметических.
Классическим примером право-ассоциативной операции является операция присвоения.
Например, в C++, в Java и других языках C семейства можно написать выражение a равняется b равняется c.
Оно вот выполнено следующим образом. Сначала мы присвоим b значение c, вернем то значение, которое присвоили, потом повторно применим к a.
Аналогично здесь у нас есть лямбда xy точка mu. Это будет означать, что у нас есть лямбда x точка, лямбда y точка mu.
Сначала проводим по этому, потом по другому.
И последнее, что я, наверное, по качеству теории расскажу, остальное вроде все как раз и сказал, это будет то, как я дальше постараюсь все записывать.
Например, запись лямбда xy что-то там, она хорошая, формальная, все с ней хорошо, но если мы начнем думать о нас как о людях, она достаточно неинтуитивна, не особо хорошо читаемая, поэтому хочется ее как-то преобразовать.
А преобразовать мы будем ее следующим образом.
Если у меня есть функции вида лямбда x1, xn и дальше какие-то аргументы, я буду стараться записывать так, что лямбда мне писать лом полноценно, я буду писать прочек, что-то типа от лямбда ставим только стрелочку.
Я буду записывать x1, x2, x3, xn через пробел и ставить стрелочку.
Аналогично я могу, например, сделать на самом деле x1 стрелочка, x2 стрелочка, x3 и так далее, мы можем смотреть на это как на функцию многих переменных или на множество функций и функций функций.
Дальше, если у меня есть термы мю ню, я буду их просто записывать как мю пробел ню.
В некотором смысле мы как раз просто перешли записи очень схожие с баш.
А теперь поехали к заданию.
Давайте сатур нормальным образом.
3 стрелочка.
1 задание.
И первое задание звучит следующим образом.
У меня есть различные термы, нужно определить корректный переход или некорректный.
Первый лямбда x, xy, y, y, 3y, x, xx, u, uz, v, uz, zu.
Дальше, uz, u, uz, zu.
Tx, xy, u, uz, zt.
Дальше v, z, z.
Лямбда x, y, u, uz, z, u, uz, zt.
И три варианта ответов.
Переход корректен и получается одним применением бета редукции для одной переменной.
Переход корректен, но иным способом и переход некорректен.
Начнем с первого момента.
Давайте сразу делать следующее.
Если у нас есть такая история, то давайте выделять, какие термы у нас свободны, какие термы связаны.
Здесь у нас свободный y, x связаны.
Поэтому при попытке бета редукции мы поставим вместо сюда x и y и все отработает корректно.
Здесь все хорошо, однократная бета редукция.
Второй способ. У меня есть x и дальше y, аналогично y и z.
Я должен подать в x аргумент какой-то один.
Этим единственным аргументом будет y.
z это второй аргумент.
Поэтому подставлять сюда я могу только y. Я не подставлю u, z, uz.
Я сюда поставлю y, y. Так что это некорректный переход.
Х, з, у и дальше я подставлю y.
Я y должен буду подставить вместо x.
То есть я получу что?
Что у меня будет y, z, а дальше внезапным образом y, который ранее был свободной переменной,
по нему станет стоять квантор.
Поэтому это тоже некорректный переход.
А, z и t.
У меня есть x и y, z здесь свободное.
И я должен поставить вместо x z, вместо y t.
Ну и я получаю z, t, z. Все ок.
Но есть одно но. Я здесь провел не одну бета-редукцию, а две бета-редукции.
Поэтому здесь ответ больше, чем одной бета-редукции. Получен корректный переход.
Здесь более сложная история. У меня есть функция двоей линии, есть функция identity и функция reverse.
Мне нужно провести бета-редукцию.
Итак, что вот происходит?
Reverse от, давайте назову это double.
Мы потом вернемся к этим значениям.
Это функция identity, это функция reverse.
Ref double identity переходит в перемену аргументов.
Аргументы у нее это и это, поэтому они меняются местами.
Функция identity применяется к функции удвоения.
Ну понятно, что функция identity к любому аргументу, это есть сам аргумент.
Поэтому мы придем к функции double.
Ну действительно, это вот она и есть, функция double.
Но у нас здесь больше, чем одна бета-редукция.
В целом, задание здесь достаточно простое. Важно быть вот, например, с этим моментом.
И здесь не забывать про соглашение скобок, что если один аргумент, то это ровно один аргумент.
Вместе мы можем подавать только когда они идут в скобках.
Что?
Да, определенно.
Вообще, я очень советую эту контрольную.
Все, кроме первого номера про арифметичность, это easy-балы.
И в дорежке советую решать первым делом лям-досчастление. Самая простая тема, которая есть. И приятная.
Ну мне не нравится это задание.
Следующее задание, оно как раз про понятие вычислений.
Если мы вспомним определение равенства, то это своего рода симметрично-транзитивное замыкание отношения вычислений.
Поэтому одним из пунктов было, что если P вычислили даку, то P равняется Q. Здесь все.
Вторым пунктом у нас спрашивают, а что если наоборот?
P равняется Q, следует ли из этого, что мы сможем P вычислить даку?
Ну, конечно же нет. Это опять же тот же пример, когда мы...
Q проверили одну бета-редукцию в P, и назад мы навесить клантер не можем.
А тут какое равенство отношение имела то, которое приводило к значению эквалентности?
Отношение эквалентности. То есть везде дальше значок равенства это значок эквалентности.
Когда мы говорим про синтоксическое равенство, мы будем использовать специальный значок, как в обычных словах.
Поэтому нет, неверно.
Пункт третий. Ух! P равняется Q. Q в нормальной форме.
И тогда утверждается, что P с Вадимом Q.
Ну, давайте думать.
Вообще правда ли это?
Первый случай, который можно рассмотреть, что у нас P как-то-как-то там велось, и перевелось сюда Q.
Но так как Q в нормальной форме, то понятно, что это может быть единственным образом только альфа-конверсия.
Но если это альфа-эквалентность, мы можем аналогично вернуть обратно, и как бы здесь сёк.
Есть другой случай, что если у нас есть вот такая вот история.
Там из некоторого эра.
Но в таком случае у нас есть теорема ОРОМБИ.
Которая утверждает, что найдётся некоторый терм T, которому одновременно сведутся они.
Ну, по сути, здесь просто явно чуть более продвинутое использование теоремы Чорча Росера.
Что же это? А, вот это.
Сейчас один момент.
Вот, теперь сёк.
Тогда получается, что мы сверись к вот этому случаю.
А здесь, как мы знаем, что в силу того, что Q в нормальной форме, вот эти вот штуки, они альфа-эквалентны.
Поэтому, ну окей, мы как-то приведём к T и вернёмся к Q.
Так что здесь сёк.
Ну, аналогично, если вдруг там окажется, что вот какая-нибудь такая лесенка.
Ну окей, мы просто каждый раз её применяем, применяем, применяем.
Получим там что-то типа схождения, и окажется здесь что-то альфа-эквалентное Q.
Всё.
И, наконец, четвёртое утверждение про если P вычисляется до Q, и Q равняется R, то P к R.
Ну, конечно же, это неверно.
Возьмём какую-нибудь здесь, не исходяющую бета-редукцию с P, а здесь другую, не исходяющую бета-редукцию.
Ну и понятно, что, например, вот эту сторону у нас не обязана быть бета-редукцией.
Или альфа-эквалентностью.
Ну и по классике пункт D про все утверждения верны не работает.
Теперь более интересная тема про логические высказывания.
У меня есть следующие попытки ввести, что я скажу, ввести логические высказывания.
Закодируйте их при помощи лямботермов.
В этом году я их так вводил, поэтому.
Истину мы вводим следующим образом.
Это лямбда X, Y, X.
Это правильно, всё ввиду.
Это первый компонент, это второй компонент, да?
Супер!
Ложь мы вводим так.
Из пары аргументов выбираем второй аргумент.
Используя вот эти вот два завтутных терма, мы можем строить более сложные конструкции.
Например, можно строить различные логические высказывания.
Начнём.
Попробуем посмотреть следующие логические высказывания.
У нас есть терм.
Подобную вещь мы можем совершить следующим образом.
Первым делом давайте посмотрим, какие вообще значения могут принимать PQ.
PQ в них приходит в качестве аргументов либо истинно, либо ложь.
И сюда, и сюда.
Поэтому, если мы видим тройку, то вот этот вот первый аргумент будет выбирать,
какое из оставшихся двух будет значением данной тройки.
В первом случае у меня PQ, в втором случае Q.
Удобно рассмотреть именно первую скобку, потому что она нам скажет,
чему здесь равняется, и в результате мы можем понять, как дальше все редуцируется.
То есть в некотором роде думаем в смысле нормальной стратегии редукции.
Рассматриваем два варианта.
Опять створим паттерн-махинг.
У нас есть ложь. Пусть P равняется ложь.
Тогда P это проектор второй компоненты.
У меня есть два аргумента, он вернет вторую компоненту, то есть P.
Это будет ложь, ложь, QPQ.
Первое, что стоит сказать, что вот тут Q вообще ничего не решает.
Так как оба аргумента у него P, то какой бы он ни выбирал, это будет P.
Поэтому здесь будет классическое P.
Все, это я могу отредуцировать.
А если это у меня P, а P ложь, то это будет ложь, это ложь, ложь, ложь.
Что равняется ложь? Все.
Второй паттерн-махинг P равняется истине.
То есть у меня будет здесь истина.
Когда она выберет первый аргумент, это будет Q.
И это все средуцируется к от ложь истины.
А теперь давайте посмотрим, что вообще это за история такая.
Если Q истина, она выберет первый аргумент, то есть ложь.
Если Q ложь, она выберет второй аргумент, то есть истину.
Это инверсия.
Тогда, какой имеем мы функцию?
0, 0, 0, 1, 1, 0, 1, 1.
Если P ложь, то все и ложь.
Ну, значит здесь 0, 0.
А во втором случае это инверсия второго аргумента.
Данный вектор функции указывает нам на то, что это инверсия импликации.
Ну, естественно, здесь никакого ксора и рядом нет.
В целом я буду везде говорить какая-то функция,
потому что в прошлых годах задание было такое, что вам дается куча этих штук,
вам нужно сказать, какой функции это соответствует.
Поэтому, например, было важно помнить, что у нас есть штрих шефера.
Это NAND, то есть отрицание дизъюнкции.
0, 1, 1, 0, 1, 1.
Штрих шефера, отрицание конъюнкции это 1, 1, 1, 1.
Стрелка пирса это нор, поэтому это 1, 0, 0, 0.
Ну, и там отрицание импликации, импликация, обратная импликация,
отрицание обратной импликации, там ничего интересного.
Что еще раз?
Да, получается.
Ну, кто знает, может на реальной контрольной вам изменить формат задания.
Следующая история. У нас снова ПК данные.
Дальше ПКФТ и дальше П.
Это мы уже помним, это у нас классическая инверсия.
И получается что? У нас все приводится к тому, что ПНК и П.
Если П это true, то он вернет НК.
НК, если П это false, то он вернет false.
Ой, ну тут короче, это вот эта штука, это она, а здесь наоборот я просто перекутал.
Здесь когда П...
Сейчас.
Когда П false.
А, то же самое? Ну ладно.
Вон она.
Поднимаю, чтобы тряпку снять.
Так, я ловлю историю.
Лямбда ПК, ПКПК и К.
Затем, что если бы они не стояли, мы бы смотрели так и так же.
Итак.
Ну опять же, смотрим на первый аргумент, там нормальной стратегии редукции.
Первая эта штука, это П, проверяем, делаем паттерн мачем по П.
П ложь. Если П ложь, он возвращает второй аргумент.
Это Q.
Дальше я редуцировать не буду, но понятно просто позапишу там в таблете совестиности Q.
П истинно. Тогда он вернет первый аргумент.
То есть будет эта история. Это будет Q.
True и Q.
Что это такая история?
Если Q это true, то оно вернет Q.
Если Q это false, то оно вернет Q.
То есть на самом деле это тоже Q.
Таким образом, это вообще функция проектор второй компоненты.
Что не ксор?
Грустно, что таксоров у нас нет.
Лямбда ПК.
ППК.
Фолс.
ПКП.
Снова делаем паттерн мачем по П.
Если П это false, то мы видим, что это Q от false.
Здесь false поэтому будет брать.
Второй компонент это тоже false.
Q от false false, независимо с того, чем является Q, это равняется false.
Уже на этом этапе можно сказать, что это не ксор, но давайте все равно продолжим, что дальше.
П равняется true.
Тогда здесь он вернет первую компоненту.
Это будет true вот здесь.
От первой компоненты здесь Q.
True берет первую компоненту, это false.
Это вообще функция тождественной лыжи.
Последняя история, которая у нас осталась.
Самое страшное.
Это лямбда ПК.
ПКП.
Это false.
Это true.
Когда мы видим такое, мы понимаем, что это инверсия второго аргумента.
Но пойдем по привычной схеме.
Паттерн мачем по первому аргументу это П.
П это true, тогда здесь мы получаем true.
Дальше здесь П.
Первая компонента Q это инверсия Q.
И в результате это даст нам инверсию Q.
Хорошо.
П равняется тождественной лыжи.
Тогда отсюда мы получим Q.
Отсюда мы берем что?
Q true это...
Один момент.
Q true...
Сейчас, П это false.
Второй аргумент false.
Здесь второй аргумент true, поэтому берем true.
А здесь берем Q.
Ну, Q true Q это как истанно Q.
Потому что если истинно, мы вернем истину.
Если ложь, вернем ложь.
А вот это уже сорок.
Если П true мы берем неку, а здесь ку.
Ну, это у нас ксо.
Все.
Задание это вообще потрясающий способ набрать баллы.
Очень советую его.
То есть, например, в 49-м, которое было про эту историю,
оно такое может быть не особо приятным.
Там какие-то сложные моменты, если особо не особо разобрались.
Особенно, если не особо разобрались.
Вот эта история просто берем pattern matching по true-false и получаем ответ.
Теперь давайте разберемся с задачами по десяткам.
В прошлом году я это не рассказывал, поэтому расскажу о этом.
В 51-м задании на проверку равенства я буду в основном все свои размышления
и так или иначе базировать на нормальной стратегии редукций.
Этот факт не рассказывается в курсе и не доказывается в курсе.
Поэтому если вдруг семена риск или проверяющие начнут прикапываться,
а что это, как это, ну просто залазим в интернет,
копируем доказательства этой теории.
Мы вначале вставляем лемма, доказательства из интернета
и дальше просто пользуемся всем этим фактом. Все.
Стандартная история.
Начнем. Первый терм.
Что, во-первых, я буду советовать в этой задаче делать?
Как ни странно, я буду советовать первым делом вводить переменные.
То есть вводить дополнительные функции.
Итак, у меня есть лямбда АВ, АААВ, дальше лямбда, лямбда ААА,
лямбда ААА.
И от меня хотят в следующий терм,
лямбда АВА, лямбда ВВ, лямбда АВББАА и лямбда АА.
Доказательство равенства в разы проще, чем доказательство неравенства.
Как раз доказательство неравенства будет основываться в нормальной стратегии редукции.
Доказательство равенства просто в приведении преобразований.
Итак, начинаем с первого. Я буду вводить какие-то базовые функции.
Первым делом функция Identity.
Она будет означать следующее, что если я возьму какую-то В, я получу В.
Дальше функция DB или Double.
Я не буду писать длинные слова, потому что я задолбаюсь это все писать по 100 раз.
DB это лямбда ВВВ.
Двое или аргументы.
Функция REF. Знакомые функции из БОША, функции обращения.
Если у меня есть аргументы В и ВВ, я верну их в обратном порядке.
Вот эти стремные истории я никак называть не буду.
Начнем с первого. У меня здесь в качестве первого аргумента функция DB и функция Identity.
Начинаю подставлять сюда вместо А и вместо В.
Итак, вместо А я подставляю функцию Double.
Как я говорил ранее, я буду писать пробел, просто для читайности.
Double, Double. Дальше Double Identity.
Теперь время вспомнить, что у нас есть Омега, который равняется Double, Double.
И он является неподвижной точкой бета-редукции.
Поэтому в начале мы имеем Омега терм, а значит этот терм не будет иметь нормальной формы.
Просто потому что согласно нормальной стратегии редукции, нам бы приходилось проводить всегда редукцию здесь,
но если мы получили цикл, значит нормальной формы нет.
Но мы можем на самом деле это подупростить.
Например, Double от Etda мы можем провести редукцию и посмотреть, что будет там.
Давайте я проведу вот там вот редукцию.
Омега, а здесь будет Id.
Identity это Identity, как в принципе Identity от любого.
Это просто оно само.
Поэтому я приду к формату, что у меня будет Омега большой и дальше Id.
Всё.
Вторая история. У меня реверс.
Давайте я запишу.
Реверс от Identity, какой-то странной хрени и Double.
Реверс принимает два аргумента, соответственно он поглотит Identity, вот этот знак вопроса.
И поменяет их местами.
Но меняет знак вопроса Identity и Double.
Итак, получается вот эта вот история у меня в качестве A нужно подать Id, в качестве B подать db.
Ну провожу это, получаю Double, Double, Identity.
Ну они равны. Всё.
То есть эти термы, да, действительно равны, мы доказали и показали это.
Второй же случай, как мне сложно догадаться, будет ответ Нет.
Давайте показывать почему же нет.
Ух!
lambda ab.aab
Теперь я буду прямо сразу писать без вот этих вот длинных выражений, буду сразу на функциях писать введённых.
Double и Identity.
Давайте попытаемся её сразу преобразовать.
Ну поехали. Поставляем вместо A функцию Double, вместо B функцию Identity.
Получаем Double, Omega Term и функцию Identity.
Можем ещё преобразовать, получим Omega Term, Omega Term, функцию Identity.
Закончили.
Так, сейчас, давайте ещё раз проверю, что я всё верно, корректно подставлял там Double, Double, Double, It.
Всё, здесь можно провести, здесь всё корректно, здесь рев два аргумента, всё, да, всё действительно корректно.
Хорошо.
Ну, второй аргумент, это функция Double от функции lambda ab.aab
И функция снова Double, это в аргументах к кому?
В аргумент к ней.
Ну поехали.
Первое, что хочется, хочется подставить сюда как-то провести, но давайте всё-таки будем следовать нормальной стратегии редукции,
вдруг вообще тут нормальная форма будет.
Поехали. У нас есть вот это основа, означая знака вопроса.
Вжух и всё.
Проведим с редукцией в самом левом редоксе.
Делаем дальше. Самый левый редокс теперь вот эта история.
Причём, что это за история?
Это история, когда у нас lambda ab, aab, здесь db, а здесь вот такая вот фигулина.
Ну и что, мы теперь видим, что такое a, что такое b?
Проводим b3.
db, db я сразу заменю на ωt.
А оставшееся b, это будет история от b.
Ой, это не ab, это double.
Так, теперь получается я могу, в самом левом редоксе это ω, мы помним on and variant, поэтому всё.
Нормальной формы как и там, так и тут нет, но не получится таким простым способом доказательной равенства.
Ну ладно, попробую провести редукцию здесь, вдруг я там как-то буду прощу.
Ну провожу. У меня ab, значит я представляю db.
Омега, дальше аа, если мы поставим вместо аа double, то мы получим снова term omega.
Но есть одно но.
Сейчас, я скажу.
Не помнится, что у меня другая здесь получилась?
Давай-давай-давай-давай, сейчас.
Мне кажется, а, вот, я смотрю, сейчас, не пропустил я ещё раз чего-то.
Сейчас, не момент.
А, нет, всё ок.
И здесь у меня останется аргумент b.
Ну, точку писали, ок, точка.
Ну и всё.
Теперь давайте смотреть, к чему мы пришли.
С одной стороны, у меня есть вот такая вот история.
С другой стороны, у меня есть вот такая история.
Если бы они были равны, то, согласно теориями Чорча Рослера, у меня должен был существовать какой-то другой лямбдо-терм, к которому они оба сводились.
Но, в данном случае, посмотрим к чему это может свистись.
Если мы проведём редукцию по омеге, мы ничего не получим.
Здесь у нас инвариантность.
Здесь у нас другой редокс, это снова омега, это снова инвариант.
А остальное ничего мы средуцировать не можем.
То есть, эта штука, она инвариантно дальше относительно бета-редукции.
Мы дальше никуда ни за неё не выходим.
Это же история.
Мы можем провести, действительно, редукцию по омеге, но снова придём к самому омегу.
Аналогично здесь.
И мы не сможем отредуцировать, ничего больше не можем отредуцировать.
Получается, эта штука тоже инвариантна относительно бета-редукции.
Таким образом, если бы они вдруг могли бы равняться, то существовал бы терм, который выглядел одновременно и таким, и таким образом, а это уже чисто синтоксически не может совпадать.
Они альфа неквалентны.
Поэтому из чаема Чорча Росарра заключаем, что не равны.
Даже получилось доказать, по сути, не опираясь на нормальную стратегию редукции.
Хотя мы ей и пользовались.
Ну, в целом, да.
Про это задание, вкратце, есть вопрос, как это делать.
Применяем нормальную стратегию редукции к первому терму, ко второму терму.
Доводим до какого-то инварианта, вот типа этого, этого, того, что там делали.
И либо эти инварианты совпадут, либо эти инварианты, ну, вы не совпали, ни победа не получилось.
И если они не совпали, не получились, просто ссылаемся на теорему Чорча Росарра.
Вот примерно с тем комментариям, которые я звучал ранее.
Ну, 52-ое, второе задание я не совсем буду комментировать.
Ну, то есть, вкратце скажу.
У нас уже есть понятие там, функции multiply, функции, это что там?
Да, у нас эти функции есть, дальше их записали, ну, и просто приводить к нормальной форме, все.
Особого интереса в 52-м нет.
А в 53-е задание, оно интересное. Интересное на чем?
Что сейчас я расскажу про то, что я называю kernel функции.
Для этого сначала вспомним о попытке формализовать, ну, точнее закодировать в гамме до исчислений обычный метуральный число.
Как мы помним из формальной арифметики, натуральное число мы получали в сигнатуре с нулем и с аксессором.
Давайте попытаемся сказать теперь то же самое, но на уровне λ-термов.
Что бы ты?
Ни момента.
Ну, поехали.
Начинается все с того, что у нас снова есть в некотором смысле ноль.
Тот ноль был как у нас нулем, так и останется.
Ну, поехали.
Начинается все с того, что у нас снова есть в некотором смысле ноль.
Тот ноль был как у нас нулем, так и останется.
Сейчас, не нужно ответить.
Так, да, у нас снова есть номерал черчилл.
Ой, снова говорим про вот истинное значение, там было вот false.
Идея следующая, что давайте у меня есть некоторое число n, и оно выглядит следующим образом.
В альфметике мы сказали, что это s, s от нуля, n раз.
Давайте теперь просто скажем, что такое нуль, скажем, что такое s, и точно так же запишем в λ-термах.
Пусть у меня есть некоторые s, есть некоторые o, и я говорю, что это номерал черчилл, который соответствует числу n.
Записывается вот следующее подчеркивание.
В случае нуля, это s от будет o. Действительно, это совпадает и одновременно с номералом черчи 0, и одновременно со значением лжи.
Скорее всего, на лекциях у вас вместо s и o использовались f, но понятно, что лямбда конверсии можно привести там более обычному виду, что это альфа конверсия.
В целом, да. Надеюсь, понятно, что вот это вот странное, вообще не пойми что, пришло к нам из простой обычной альфметики.
Особенность номералов черча, что если мы номерал черча, и мы к нему подадим некоторую функцию f и аргумент x, то на выходе мы получим n-ту степень этой функции от x.
Например, используя это, можно получать функции унажения, получать функции сложения, и так далее.
Дальше нас будет интересовать предикат пары. Пару я буду означать, что вот у меня есть терм, возначающий пару, вот я буду значать такими скобочками, и он будет равнять следующему.
Если у меня есть некоторый аргумент first, есть аргумент second, есть p доступ к паре, то я получаю, что я беру ключ, проектор, и два аргумента f и second.
Тогда мне нужны будут функции проекторы. Проектор первой компоненты, это лямбда first, second, которая возвращает first.
Проектор второй компоненты, это мы берем first и second и возвращаем second.
Сейчас, да, спасибо, это я мощно, я беру некоторую пару.
Так, я получил пару, и мне в эту пару нужно будет что-то подать, тогда я возьму в пару и подам в пару, мне нужно будет сейчас сказать, пару D.
Один момент, лямбда пара, пара, и в пару мне нужно будет что-то подать, только мне кажется, я сейчас сделал не так.
Сейчас, прошу прощения, мне кажется, тут нужно другая. Тут идея на мне, если я подаю сюда, это пара, первый аргумент отдается сюда, поэтому мне кажется, я сейчас перепутал порядок.
Один момент, я проверю.
Пара.
Нет, все верно.
Окей, да.
И в пару мне нужно подать проектор. Соответственно, проекторами у нас реально выступает, как мы помним, true и false, true был проектор первый, а false был проектор второй.
Да, все, что-то я натупил. Хорошо.
Так, дальше.
Просто расскажу, в чем была у меня загвоздка, я подумал, что здесь, надейно что, мы получаем пару каким образом, что? Пару мы, это создание пары, то есть у нас есть некоторые два аргумента, которые мы подаем в описании пары, тем самым мы редуцируем первые два аргумента FST.
После этого у нас готовая пара, она прибудет в формате, что есть некоторый проектор, а она ожидает этот проектор, у нас есть два аргумента, там value 1 и value 2.
А теперь нам, чтобы получить какой-то из них, нам просто нужно подавать проектор. Ну и в первом случае я буду подавать проектор true, а во втором проектор второй компонент, который false.
То есть, да, я здесь просто подумал, что мы подаем конструктор, мы подаем не конструктор, а уже сконструированный объект.
Хорошо. Итак, теперь начнем думать про задание. У нас есть некоторые функции, у нас есть некоторые функции, у нас дается рекуррентная формула, и наша задача построить комбинатор, позволяющий вычислять эту функцию.
То есть, для того, чтобы это все доброработало, нам понадобится поговорить про такую штуку.
Комбинатор E.T.E.
Итак, E.T.E. If, then, else. Что он будет себя принимать? Он должен принимать себя следующей вещью. Он принимает себя некоторая condition.
Дальше он принимает то, что выполняется при true, и то, что выполняется if, then, else.
Ну, понятно, я сейчас буду писать таким образом. Вам, когда нужно записывать явно в термы, просто приведем некоторое там преобразование записи и получим соответствующий явно в терм.
И он должен возвращать следующее, что если conditional true, то будет false, а в противном случае else. Но ведь condition у нас это какой-то boolean.
Сюда мы будем подавать либо true, либо false.
Тогда, если будет true, то мы знаем, он будет возвращать первый аргумент. Если false, то будет второй.
Поэтому, на самом деле, мы можем это просто записать как condition if true, if else. И уже здесь, в зависимости от true, он выберет нужное нам значение.
Это и есть, по сути, у нас комбинатор if, then, else. А теперь самая главная идея вот это вот вычисление. Как мы будем работать?
Мы будем работать при помощи пары. То есть у нас будет пара глобальная, когда у нас некоторая вот итерация есть, у нас здесь будет пара, которая будет состоять из двух компонентов.
В первой компоненте мы будем говорить про итератор. На каком конкретном мы сейчас шаге.
И здесь у нас будет аккумулятор. То есть некоторое место, где мы будем аккумулировать значения функции. Сагрегированные по нужным.
В данном случае нам требуется на самом деле хранить два значения функции. Минус первое и минус второе.
Поэтому просто пары нам недостаточно. Нам понадобится пара из итератора дальше минус первое значение и минус второе значение.
Вот такая вот более сложная штука. На самом деле это что у нас картеша с трехорогым инструментом.
Теперь давайте думать, как эта штука будет работать. Работать она будет на основе следующего принципа.
Мы заводим kernel function. То есть у нас есть некоторое ядро преобразования.
А дальше мы используем смысл нумералов Чорча как n-ную итерацию функции. Мы просто запустим вот этот процесс итерирования.
Сейчас откроем заготовку.
Поехали. Как будет работать наш kernel?
Kernel будет работать следующим образом. Он принимает в себя некоторую пару и вычисляет значение следующей пары.
То есть у нас есть некоторая пара и по паре начинает производить вычисления.
Какие вычисления у нас есть? У нас есть в условии некоторой рекусе, которая говорит, что в нулях она придает определенное значение,
на остальных n она задана. То есть у нас если 0, то a, если 1, то b, если все остальное, то 3fn-1 плюс 2fn-2.
Пользуемся буквально if-then-else.
Если условия. Условия давайте я пока скажу яку, потом мы подумаем как яку задать.
Некоторый кабинатор равенства λ-термов и говорит, что если equals от нуля и аргумента, аргумент какой у нас?
Это итерация. То есть пара, итерация нас первая. Это будет projection 1 от пары.
Если так, то я должен сказать, что вернуть в этом случае. В этом случае я возвращаю a.
Иначе же теперь проверяем на равенство единицы.
If-then-else condition equals единичке текущей итерации. Если это так, то я возвращаю b.
Теперь мне нужно иначе. Что я дальше делаю?
Понятно, что kernel у нас должна работать таким образом.
Давайте я скажу что-то типа ее типа. У нас есть там пара из итератора и еще пара двух аргументов.
И она должна возвращать нам пару из итератора плюс 1 и пары из каких-то там новых аргументов.
Вот у меня того, что такое kernel. Поэтому здесь на самом деле я буду возвращать не a, а пару из следующей итерации за нулем.
За нулем это 1. Предыдущие значения давайте я поставлю здесь a.
Это будет пара из следующей итерации 1 и пары из предыдущего и предпредыдущего значения.
Понятно, предыдущие значения в первой это будет a, а предпредыдущие, перед нулем я могу записать все что угодно, потому что дальше единичка затрет.
Поэтому пофиг, я возьму ноль. Просто потому что мне так нравится, на самом деле здесь может произвольная фигня быть.
Здесь также будет не b, а будет пара из следующего, это 2.
Дальше пара из предыдущего значения. Для двойки предыдущие значения это будет то, что в единице, а в единице у нас b, а в нуле у нас a.
И теперь мы начинаем рассматривать случай самый интересный, когда у нас уже есть сама функция, и она должна вычислять вот эту стрёмную фигню.
Мы должны будем возвращать итерацию от первой, мы должны будем повысить итератор, тогда у меня есть функция плюс, номерал черча 1, а где у нас лежит итератор?
В первом аргументе пары, снова скобочка, проектор 1 пары, всё, это вот итератор плюс 1. Теперь я задаю значение.
Для следующего числа, для следующей итерации его значение будет вот такое.
Это что у нас? Сначала плюс, первое аргумент у плюса, умножение 3 на f, это умножение на тройку на предыдущие значения.
Предыдущие значения у нас лежит в где? Нам нужно будет взять проектор второй компоненты, получим снова пару, и предыдущие нам нужно будет к этому применять ещё раз проектор первой компоненты.
Это проектор первой компоненты, от проектора второй компоненты пары. Это буквально f-1 умножить на 3, продолжаем, плюс.
Плюс второй аргумент, это умножение, уже теперь двойки, но на минус второе значение. Это проектор второй компоненты, от проектора второй компоненты.
Ух, проектор второй компоненты, от проектора второй компоненты, от поданной пары. Жух-жух-жух, третья скобка, жух-жух-жух, третья скобка.
Дальше это мы всё, подали это её. Сейчас, это вот раз аргумент, это два аргумента. Всё, получили плюсик? Закрываем скобку. Давайте добавим цветов, потому что иначе мы здесь зашьёмся вообще в этих скобках.
Это плюс, это красненький, вор. Жить можно. Красно видно или лучше другим цветом?
О-ка-и-ё, вот этот самый длинный. Так, это я знаю значение предыдущее. А какое же значение будет пред предыдущим? Это то, которое на данный момент предыдущее.
То есть я подаю сюда вторым аргументом, проектор первой компоненты, от проектора второй компоненты пары. Ну и на этом я благополучно завершаю.
Вот её ещё. Текс, вот так. Всё, жёлтенькое, готово. Итак, у меня есть ИТЕ, для него подали, получили что-то. Дальше ИТЕ, для него подали, подали.
ИТЕ твой налево. Это кондишен, это body, это else body.
Значит, сейчас. Ё. Один момент. А, нет, вот. Ух, блин. Вот это втор... это короче пара вот для этих аргументов, а вот полностью это вот оно.
Знаете, прям жирное в ряду, потому что иначе я сам задолбаюсь в этих скобках, что происходит. Вот. Всё. Это else body. Вот такую вот стрёмную фигню мы вернули.
Ну и осталось поставить завершающую скобку. Вот так вот. Всё. Не стой. Да. Получилась вот такая вот функция гидра преобразования, которая берёт пару, проверяет, что если 0 она возвращает, у нас что?
Возвращает A, если это единица, то мы вернём предыдущие B дальше A, если это какой-то N, в первом случае мы его увеличим на 1, а дальше дадим пару из предыдущего значения, которые вычислим по этой формуле, используя вот эти вот элементы.
А в качестве предыдущего, текущие предыдущие дадим. Всё. Это по сути kernel function, это мы записали один шаг преобразования, причём используя вот эти вот итоешки, мы смогли сделать вот pattern matching по всем случаем индукции.
Теперь нам осталось самое последнее, самое простое запустить эту террацию. Если мы хотим вычислить F от M, то вопрос насколько шагов нам нужно будет там запускать эту историю, сейчас скажу.
Да, всё верно, нам нужно будет запускать всю историю на N шагов. Как это делать? А делать это следующим образом.
То есть, итоговая функция, которую нас хотели. F. Сначала у нас были там A и B, чисто которые это берут. Хорошо, возьмём число A и B. Я их выдаю сначала именно для того, чтобы, например, мы могли, передав A и B задав, всё, мы получаем функцию, которая работает абсолютно нормально от N.
Не так, что мы передаём N, а потом задаём какие-то там параметры функции. А сначала идёт параметризация функций, а потом уже её аргумент. N, A, B и N, и дальше она возвращает следующую историю.
Мне нужно будет N раз запустить функцию kernel от стартовых условий.
Итак, какое же происходит стартовое условие? Стартовое условие на следующее, что нам нужно подать пару.
А нам подать вообще какую стартовую пару? Мы начинаем с, ну давайте тут напишу, пара, начальное значение. Первая террация, какая у нас, нулевая, правильно, здесь подам 0.
Дальше же я должен подать вот эти вот значения. Ну, нули они там всё равно сияются, поэтому на самом деле пофиг. Окей, я передам тогда пару из нуля и нуля и закрою скобку.
Хорошо, на выходе значит я получу действительно пару из какого-то итератора значения, вот соответствующий там F от N, F от минус N, это я подам 0, она вычислиться даст и я запущу, сейчас скажу.
Один момент, сейчас проверим просто на что именно мы запустим, на сколько итераций. Если я подам на 0, то я верну пару из нуля и нуля и нуля, если я подам 1, я один раз запущу функцию от этого, она мне вернёт всё как надо.
Вот, я запущу на N плюс 1, то есть на самом деле как-то будет выглядеть ABN плюс N1, вот, так вот верно. То есть для чего я это делаю? Именно для того, чтобы в обычном смысле у нас здесь лежит минус 1 и минус 2 значение,
я запущу на 1 итерацию раньше и получу, что у меня здесь будет FNT, а здесь FN-1, всё, у меня есть FN. Теперь я получу такую сложную конструкцию, мне тут нужно конструкцию из неё вытащить FN, поэтому вот теперь я ещё раз применяю проекторы.
Я сначала возьму вторую компоненту, а потом к этому я применю проектор первой компоненты и тем самым вытащу FN. То есть я теперь сделаю проектор первой компоненты, вот проектора второй компоненты, вот это вот полученное значение.
Компонент плюс N1.
Кернелл от вот этой всей истории, которая такая вот. Это первая скобка и вторая скобка, и вот этот уже действительно будет F.
Ещё вот так вот. Вот такая вот страхолюдина. На самом деле задание не сложное, просто нужно понять, что вот эту историю и дальше в конце распасить ответ.
Глобально саму итерацию нам позволяют проводить на пиралу Чорча и наша задача лишь обозначить функцию ядра.
Ну это же вроде всё.
Тогда ещё ничего интересного ещё не было. Это было было было было было было было было было было.
Да, тогда на этом всё. Всем спасибо. Всем удачи на контрольной и на экзамене.
